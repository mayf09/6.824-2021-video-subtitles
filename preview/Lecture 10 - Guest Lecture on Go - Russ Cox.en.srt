1
00:00:00,240 --> 00:00:03,600
okay uh good afternoon good morning

2
00:00:03,600 --> 00:00:06,000
good evening good night wherever you are

3
00:00:06,000 --> 00:00:07,919
uh let's get started again

4
00:00:07,919 --> 00:00:11,040
uh so uh today we have a guest lecture

5
00:00:11,040 --> 00:00:13,280
and probably speaker that needs a little

6
00:00:13,280 --> 00:00:14,080
introduction

7
00:00:14,080 --> 00:00:16,880
uh uh there's uh russ cox uh who's one

8
00:00:16,880 --> 00:00:17,760
of the

9
00:00:17,760 --> 00:00:20,880
co-leads on the go uh project and

10
00:00:20,880 --> 00:00:22,800
you know we'll talk a lot more about it

11
00:00:22,800 --> 00:00:24,320
uh let me say a couple words

12
00:00:24,320 --> 00:00:27,840
uh and not try to embarrass russ too

13
00:00:27,840 --> 00:00:29,199
much

14
00:00:29,199 --> 00:00:30,560
russia has a long experience with

15
00:00:30,560 --> 00:00:32,719
distributed systems uh

16
00:00:32,719 --> 00:00:36,239
he was a developer and contributor to

17
00:00:36,239 --> 00:00:38,480
plan nine uh when he was a high school

18
00:00:38,480 --> 00:00:41,120
student and as an undergrad at harvard

19
00:00:41,120 --> 00:00:44,800
he joined the phd program at mit uh

20
00:00:44,800 --> 00:00:47,440
which is where we met up and probably if

21
00:00:47,440 --> 00:00:48,399
you're taking any

22
00:00:48,399 --> 00:00:51,360
sort of you know pdos class if you will

23
00:00:51,360 --> 00:00:52,559
there's going to be a

24
00:00:52,559 --> 00:00:55,760
you will see russ's touches on it

25
00:00:55,760 --> 00:00:59,760
and certainly in 824 you know the

26
00:00:59,760 --> 00:01:02,399
the go switch to go for us has been a

27
00:01:02,399 --> 00:01:03,359
wonderful thing

28
00:01:03,359 --> 00:01:07,360
and uh but if you differ in opinion

29
00:01:07,360 --> 00:01:09,040
of course feel free to ask russ

30
00:01:09,040 --> 00:01:11,920
questions and make suggestions um he's

31
00:01:11,920 --> 00:01:15,280
always welcome to uh entertain any

32
00:01:15,280 --> 00:01:18,479
ideas so with that russ it's yours great

33
00:01:18,479 --> 00:01:20,720
thanks can you still see the slides

34
00:01:20,720 --> 00:01:23,920
is that working okay great so um so we

35
00:01:23,920 --> 00:01:24,799
built go to

36
00:01:24,799 --> 00:01:26,400
support writing the sort of distributed

37
00:01:26,400 --> 00:01:28,560
systems that we were building at google

38
00:01:28,560 --> 00:01:30,320
and that made go a great fit for you

39
00:01:30,320 --> 00:01:31,759
know what came next which is now called

40
00:01:31,759 --> 00:01:32,720
cloud software

41
00:01:32,720 --> 00:01:35,840
and also a great fit for a24 um so

42
00:01:35,840 --> 00:01:37,119
in this lecture i'm going to try to

43
00:01:37,119 --> 00:01:39,040
explain how i think about writing some

44
00:01:39,040 --> 00:01:41,439
current programs in go

45
00:01:41,439 --> 00:01:42,799
and i'm going to walk through the sort

46
00:01:42,799 --> 00:01:44,799
of design and implementation of

47
00:01:44,799 --> 00:01:47,040
programs for four different patterns

48
00:01:47,040 --> 00:01:48,880
that i see come up often

49
00:01:48,880 --> 00:01:50,079
and along the way i'm going to try to

50
00:01:50,079 --> 00:01:51,920
highlight some hints or rules of thumb

51
00:01:51,920 --> 00:01:53,759
that you can keep in mind when designing

52
00:01:53,759 --> 00:01:55,200
your own go programs

53
00:01:55,200 --> 00:01:56,640
and i know the syllabus links to an

54
00:01:56,640 --> 00:01:58,320
older version of these slides so you

55
00:01:58,320 --> 00:01:59,600
might have seen them already

56
00:01:59,600 --> 00:02:01,200
i hope that the lecture form is a bit

57
00:02:01,200 --> 00:02:02,719
more intelligible than just sort of

58
00:02:02,719 --> 00:02:03,759
looking at the

59
00:02:03,759 --> 00:02:06,560
slides um and i hope that in general

60
00:02:06,560 --> 00:02:08,319
these patterns are like common enough

61
00:02:08,319 --> 00:02:09,599
that you know maybe they'll be helpful

62
00:02:09,599 --> 00:02:11,599
by themselves but also that you know

63
00:02:11,599 --> 00:02:12,000
you'll

64
00:02:12,000 --> 00:02:14,480
you'll the hints will help you prepare

65
00:02:14,480 --> 00:02:18,790
for whatever it is you need to implement

66
00:02:18,800 --> 00:02:20,480
so to start it's important to

67
00:02:20,480 --> 00:02:22,319
distinguish between concurrency and

68
00:02:22,319 --> 00:02:23,680
parallelism

69
00:02:23,680 --> 00:02:25,520
and concurrency is about how you write

70
00:02:25,520 --> 00:02:27,520
your programs about being able to

71
00:02:27,520 --> 00:02:30,640
compose independently executing control

72
00:02:30,640 --> 00:02:31,840
flows whether you want to call them

73
00:02:31,840 --> 00:02:34,160
processes or threads or go routines

74
00:02:34,160 --> 00:02:36,319
so that your program can be dealing with

75
00:02:36,319 --> 00:02:37,519
lots of things at once

76
00:02:37,519 --> 00:02:40,160
without turning into a giant mess on the

77
00:02:40,160 --> 00:02:40,640
other hand

78
00:02:40,640 --> 00:02:42,239
parallelism is about how the programs

79
00:02:42,239 --> 00:02:44,720
get executed about allowing multiple

80
00:02:44,720 --> 00:02:46,160
computations to run

81
00:02:46,160 --> 00:02:47,920
simultaneously so that the program can

82
00:02:47,920 --> 00:02:50,160
be doing lots of things at once not just

83
00:02:50,160 --> 00:02:52,000
dealing with lots of things at once

84
00:02:52,000 --> 00:02:53,680
and so concurrency lends itself

85
00:02:53,680 --> 00:02:55,920
naturally to parallel execution

86
00:02:55,920 --> 00:02:57,920
but but today the focus is on how to use

87
00:02:57,920 --> 00:02:59,840
go's concurrency support to make your

88
00:02:59,840 --> 00:03:01,599
programs clearer

89
00:03:01,599 --> 00:03:03,200
not to make them faster if they do get

90
00:03:03,200 --> 00:03:04,800
faster that's wonderful but but that's

91
00:03:04,800 --> 00:03:07,200
not the point today

92
00:03:07,200 --> 00:03:09,599
so i said i'd walk through the design

93
00:03:09,599 --> 00:03:11,599
and implementation of some programs for

94
00:03:11,599 --> 00:03:12,000
four

95
00:03:12,000 --> 00:03:14,879
common concur excuse me concurrency

96
00:03:14,879 --> 00:03:16,800
patterns that i see often

97
00:03:16,800 --> 00:03:18,560
but before we get to those i want to

98
00:03:18,560 --> 00:03:19,920
start with what seems like a really

99
00:03:19,920 --> 00:03:22,080
trivial problem but that illustrates

100
00:03:22,080 --> 00:03:23,440
one of the most important points about

101
00:03:23,440 --> 00:03:25,280
what it means to use concurrency

102
00:03:25,280 --> 00:03:28,159
to structure programs a decision that

103
00:03:28,159 --> 00:03:28,720
comes up

104
00:03:28,720 --> 00:03:30,319
over and over when you design concurrent

105
00:03:30,319 --> 00:03:33,040
programs is whether to represent states

106
00:03:33,040 --> 00:03:36,319
as code or as data and by as code i mean

107
00:03:36,319 --> 00:03:38,720
the control flow in the program

108
00:03:38,720 --> 00:03:40,640
so suppose we're reading characters from

109
00:03:40,640 --> 00:03:42,720
a file and we need to scan over a c

110
00:03:42,720 --> 00:03:44,720
style quoted string oh hello so the

111
00:03:44,720 --> 00:03:46,480
slides aren't changing

112
00:03:46,480 --> 00:03:48,879
yeah it will they well can you see

113
00:03:48,879 --> 00:03:50,640
prologue gorgeous for state right now

114
00:03:50,640 --> 00:03:53,439
no we see the title slide oh no yeah i

115
00:03:53,439 --> 00:03:55,519
was wondering about that because um

116
00:03:55,519 --> 00:03:56,959
there was like a border around this

117
00:03:56,959 --> 00:03:58,840
thing when i started and then it went

118
00:03:58,840 --> 00:04:00,159
away

119
00:04:00,159 --> 00:04:01,920
so let me let me just unshare and

120
00:04:01,920 --> 00:04:04,080
reshare

121
00:04:04,080 --> 00:04:07,120
i have to figure out how to do that in

122
00:04:07,120 --> 00:04:08,400
zoom

123
00:04:08,400 --> 00:04:12,400
uh unfortunately the keynote menu wants

124
00:04:12,400 --> 00:04:13,680
to be up and i don't know how to get to

125
00:04:13,680 --> 00:04:14,000
the zoom

126
00:04:14,000 --> 00:04:19,749
menu um

127
00:04:19,759 --> 00:04:22,400
ah my screen sharing is paused why is my

128
00:04:22,400 --> 00:04:24,800
screen sharing paused

129
00:04:24,800 --> 00:04:27,919
can i resume there we go yeah

130
00:04:27,919 --> 00:04:30,080
all right i don't know the zoom box says

131
00:04:30,080 --> 00:04:31,759
your screen sharing is paused so if that

132
00:04:31,759 --> 00:04:33,600
now now the border's back so i'll watch

133
00:04:33,600 --> 00:04:35,680
that

134
00:04:35,680 --> 00:04:38,880
all right so um see

135
00:04:38,880 --> 00:04:41,120
i was back here so so you know we're

136
00:04:41,120 --> 00:04:42,400
reading a string

137
00:04:42,400 --> 00:04:43,919
it's not a parallel program it's reading

138
00:04:43,919 --> 00:04:45,280
one character at a time so there's no

139
00:04:45,280 --> 00:04:46,880
opportunity for parallelism but there is

140
00:04:46,880 --> 00:04:48,800
a good opportunity for concurrency

141
00:04:48,800 --> 00:04:50,560
so if we don't actually care about the

142
00:04:50,560 --> 00:04:53,199
exact escape sequences in the string

143
00:04:53,199 --> 00:04:54,720
what we need to do is match this regular

144
00:04:54,720 --> 00:04:56,560
expression and we don't have to worry

145
00:04:56,560 --> 00:04:57,919
about understanding it exactly

146
00:04:57,919 --> 00:04:59,680
we'll come back to what it means but but

147
00:04:59,680 --> 00:05:01,120
that's basically all you have to do is

148
00:05:01,120 --> 00:05:02,880
implement this regular expression

149
00:05:02,880 --> 00:05:04,720
and so you know you probably all know

150
00:05:04,720 --> 00:05:06,320
you can turn a regular expression into a

151
00:05:06,320 --> 00:05:07,199
state machine

152
00:05:07,199 --> 00:05:08,880
and so we might use a tool that

153
00:05:08,880 --> 00:05:10,800
generates this code

154
00:05:10,800 --> 00:05:12,160
and in this code there's a single

155
00:05:12,160 --> 00:05:14,000
variable state that's the state of the

156
00:05:14,000 --> 00:05:14,880
machine

157
00:05:14,880 --> 00:05:16,720
and the loop goes over the state one

158
00:05:16,720 --> 00:05:18,479
character at a time reads a character

159
00:05:18,479 --> 00:05:19,919
depending on the state and the character

160
00:05:19,919 --> 00:05:21,759
changes to a different state until it

161
00:05:21,759 --> 00:05:22,960
gets to the end

162
00:05:22,960 --> 00:05:24,320
and so like this is a completely

163
00:05:24,320 --> 00:05:26,320
unreadable program but it's the kind of

164
00:05:26,320 --> 00:05:27,840
thing that you know an auto-generated

165
00:05:27,840 --> 00:05:29,120
program might look like

166
00:05:29,120 --> 00:05:30,720
and and the important point is that the

167
00:05:30,720 --> 00:05:32,400
program state is stored

168
00:05:32,400 --> 00:05:34,160
in data in this variable that's called

169
00:05:34,160 --> 00:05:36,960
state and if you can change it to store

170
00:05:36,960 --> 00:05:37,680
the state

171
00:05:37,680 --> 00:05:41,280
in code that's often clearer

172
00:05:41,280 --> 00:05:44,080
so here's what i mean um suppose we

173
00:05:44,080 --> 00:05:45,840
duplicate the read care calls

174
00:05:45,840 --> 00:05:48,160
into each case of the switch so we

175
00:05:48,160 --> 00:05:49,680
haven't made any semantic changes here

176
00:05:49,680 --> 00:05:50,960
we just took the read care that was at

177
00:05:50,960 --> 00:05:54,000
the top and we moved it into the middle

178
00:05:54,000 --> 00:05:56,319
now instead of setting state and then

179
00:05:56,319 --> 00:05:57,759
immediately doing the switch again

180
00:05:57,759 --> 00:06:01,830
we can change those into go to's

181
00:06:01,840 --> 00:06:03,520
and then we can simplify a little bit

182
00:06:03,520 --> 00:06:05,120
further there's a go to state one that's

183
00:06:05,120 --> 00:06:06,800
right before the state one label we can

184
00:06:06,800 --> 00:06:08,960
get rid of that

185
00:06:08,960 --> 00:06:11,759
then there's a um i guess yeah so then

186
00:06:11,759 --> 00:06:12,560
there's

187
00:06:12,560 --> 00:06:14,000
uh you know there's only one way to get

188
00:06:14,000 --> 00:06:15,520
to state two so we might as well pull

189
00:06:15,520 --> 00:06:17,199
the state two code up and put it inside

190
00:06:17,199 --> 00:06:19,280
the if where the go to appears

191
00:06:19,280 --> 00:06:21,600
and then you know both sides of that if

192
00:06:21,600 --> 00:06:23,360
now end in go to state one

193
00:06:23,360 --> 00:06:26,240
so we can hoist that out and now what's

194
00:06:26,240 --> 00:06:28,479
left is actually a pretty simple program

195
00:06:28,479 --> 00:06:30,160
you know state zero is never jumped to

196
00:06:30,160 --> 00:06:31,680
so it just begins there

197
00:06:31,680 --> 00:06:33,120
and then state one is just a regular

198
00:06:33,120 --> 00:06:34,800
loop so we might as well make that

199
00:06:34,800 --> 00:06:38,000
look like a regular loop um

200
00:06:38,000 --> 00:06:39,919
and now like this is you know looking

201
00:06:39,919 --> 00:06:41,199
like a program

202
00:06:41,199 --> 00:06:42,880
and then finally we can you know get rid

203
00:06:42,880 --> 00:06:44,800
of some variables and simplify a little

204
00:06:44,800 --> 00:06:46,240
bit further

205
00:06:46,240 --> 00:06:48,319
and um and we can rotate the loop so

206
00:06:48,319 --> 00:06:50,160
that you know we don't do a return true

207
00:06:50,160 --> 00:06:51,360
in the middle of the loop we do the

208
00:06:51,360 --> 00:06:54,080
return true at the end

209
00:06:54,080 --> 00:06:56,319
and so now we've got this program that

210
00:06:56,319 --> 00:06:57,199
is actually

211
00:06:57,199 --> 00:07:00,240
you know reasonably nice and it's worth

212
00:07:00,240 --> 00:07:01,120
mentioning that

213
00:07:01,120 --> 00:07:02,560
it's possible to clean up you know much

214
00:07:02,560 --> 00:07:04,240
less egregious examples you know if you

215
00:07:04,240 --> 00:07:05,919
had tried to write this by hand

216
00:07:05,919 --> 00:07:07,199
your first attempt might have been the

217
00:07:07,199 --> 00:07:08,960
thing on the left where you've got this

218
00:07:08,960 --> 00:07:10,319
extra piece of state

219
00:07:10,319 --> 00:07:12,240
and then you can apply the same kinds of

220
00:07:12,240 --> 00:07:13,440
transformations to

221
00:07:13,440 --> 00:07:15,280
move that state into the actual control

222
00:07:15,280 --> 00:07:17,759
flow and end up at the same program that

223
00:07:17,759 --> 00:07:19,919
we have on the right that's cleaner

224
00:07:19,919 --> 00:07:21,919
so this is you know a useful

225
00:07:21,919 --> 00:07:23,840
transformation to keep in mind

226
00:07:23,840 --> 00:07:25,360
anytime you have state that kind of

227
00:07:25,360 --> 00:07:26,880
looks like

228
00:07:26,880 --> 00:07:29,039
it might be just reiterating what's

229
00:07:29,039 --> 00:07:31,759
what's happening in the program counter

230
00:07:31,759 --> 00:07:34,800
um and so you know you can see this

231
00:07:34,800 --> 00:07:37,039
if the the origin in the original state

232
00:07:37,039 --> 00:07:38,639
like if state equals zero the program

233
00:07:38,639 --> 00:07:39,680
counter is at the beginning of the

234
00:07:39,680 --> 00:07:40,400
function

235
00:07:40,400 --> 00:07:42,319
and if state equals one or if an escape

236
00:07:42,319 --> 00:07:44,080
equals false and the other version the

237
00:07:44,080 --> 00:07:45,680
per encounter is just inside the for

238
00:07:45,680 --> 00:07:47,120
loop and state equals two is you know

239
00:07:47,120 --> 00:07:48,879
further down in the for loop

240
00:07:48,879 --> 00:07:50,560
and the benefit of writing it this way

241
00:07:50,560 --> 00:07:51,919
instead of with the states

242
00:07:51,919 --> 00:07:54,000
is that it's much easier to understand

243
00:07:54,000 --> 00:07:55,039
like i can actually

244
00:07:55,039 --> 00:07:56,479
just walk through the code and explain

245
00:07:56,479 --> 00:07:57,840
it to you you know if you just read

246
00:07:57,840 --> 00:07:59,199
through the code you read an opening

247
00:07:59,199 --> 00:07:59,840
quote

248
00:07:59,840 --> 00:08:01,360
and then you start looping and then

249
00:08:01,360 --> 00:08:02,720
until you find the closing quote you

250
00:08:02,720 --> 00:08:04,319
read a character and if it's a backslash

251
00:08:04,319 --> 00:08:05,759
you skip the next character and that's

252
00:08:05,759 --> 00:08:07,120
it right you can just read that off the

253
00:08:07,120 --> 00:08:08,639
page which you couldn't do

254
00:08:08,639 --> 00:08:11,759
in the original this version also

255
00:08:11,759 --> 00:08:12,560
happens to run

256
00:08:12,560 --> 00:08:14,160
faster although that doesn't really

257
00:08:14,160 --> 00:08:15,680
matter for us

258
00:08:15,680 --> 00:08:18,000
um but as i mentioned i'm going to

259
00:08:18,000 --> 00:08:19,199
highlight what i think are kind of

260
00:08:19,199 --> 00:08:21,039
important lessons as hints for designing

261
00:08:21,039 --> 00:08:22,479
your own go programs and this is the

262
00:08:22,479 --> 00:08:23,360
first one

263
00:08:23,360 --> 00:08:26,080
to convert data state into code state

264
00:08:26,080 --> 00:08:28,560
when it makes your programs clearer

265
00:08:28,560 --> 00:08:31,199
and again like these are all hints you

266
00:08:31,199 --> 00:08:32,320
should you shouldn't

267
00:08:32,320 --> 00:08:33,440
you know for all of these you should

268
00:08:33,440 --> 00:08:35,360
consider it as you know only if it helps

269
00:08:35,360 --> 00:08:38,149
you can decide

270
00:08:38,159 --> 00:08:40,320
so one problem with this hint is that

271
00:08:40,320 --> 00:08:42,880
not all programs have the luxury of

272
00:08:42,880 --> 00:08:44,399
having complete control over their

273
00:08:44,399 --> 00:08:46,000
control flow so

274
00:08:46,000 --> 00:08:47,839
you know here's a different example

275
00:08:47,839 --> 00:08:49,440
instead of having a read care function

276
00:08:49,440 --> 00:08:50,880
that can be called

277
00:08:50,880 --> 00:08:53,120
this code is written to have a process

278
00:08:53,120 --> 00:08:54,880
care method that you have to hand the

279
00:08:54,880 --> 00:08:55,600
character to

280
00:08:55,600 --> 00:08:58,320
one at a time and then process care has

281
00:08:58,320 --> 00:08:59,760
no choice really

282
00:08:59,760 --> 00:09:02,160
but to you know encode its state in an

283
00:09:02,160 --> 00:09:03,680
explicit state variable because

284
00:09:03,680 --> 00:09:05,440
after every character it has to return

285
00:09:05,440 --> 00:09:07,040
back out and so

286
00:09:07,040 --> 00:09:08,480
it can't save the state in the program

287
00:09:08,480 --> 00:09:10,080
counter in the stack it has to have the

288
00:09:10,080 --> 00:09:10,959
state

289
00:09:10,959 --> 00:09:14,480
in an actual variable but

290
00:09:14,480 --> 00:09:16,640
in go we have another choice right

291
00:09:16,640 --> 00:09:18,480
because we can't save the state on that

292
00:09:18,480 --> 00:09:18,959
stack

293
00:09:18,959 --> 00:09:21,360
and in that program counter but you know

294
00:09:21,360 --> 00:09:22,959
we can make another go routine

295
00:09:22,959 --> 00:09:26,080
to hold that state for us so supposing

296
00:09:26,080 --> 00:09:27,120
we already have this

297
00:09:27,120 --> 00:09:29,440
debugged read string function that we

298
00:09:29,440 --> 00:09:30,480
really don't want to

299
00:09:30,480 --> 00:09:32,399
rewrite in this other way we just want

300
00:09:32,399 --> 00:09:33,760
to reuse it it works

301
00:09:33,760 --> 00:09:35,200
maybe it's really big and hairy it's

302
00:09:35,200 --> 00:09:36,560
much more complicated than the thing we

303
00:09:36,560 --> 00:09:37,440
saw

304
00:09:37,440 --> 00:09:39,279
we just want to reuse it and so the way

305
00:09:39,279 --> 00:09:41,120
we can do that and go is we can start a

306
00:09:41,120 --> 00:09:42,399
new go routine

307
00:09:42,399 --> 00:09:44,000
that does the read string part and it's

308
00:09:44,000 --> 00:09:46,080
the same read string code as before we

309
00:09:46,080 --> 00:09:48,000
pass in the character reader

310
00:09:48,000 --> 00:09:51,200
and now here the um you know the init

311
00:09:51,200 --> 00:09:52,399
method

312
00:09:52,399 --> 00:09:54,320
makes this this go routine to do the

313
00:09:54,320 --> 00:09:56,240
character reading and then every time

314
00:09:56,240 --> 00:09:57,760
the process care

315
00:09:57,760 --> 00:10:01,440
method is called um we send a message to

316
00:10:01,440 --> 00:10:03,040
the go routine on the car channel that

317
00:10:03,040 --> 00:10:03,519
says

318
00:10:03,519 --> 00:10:05,519
here's the next character and then we

319
00:10:05,519 --> 00:10:07,040
receive a message back that says like

320
00:10:07,040 --> 00:10:08,399
tell me the current status and the

321
00:10:08,399 --> 00:10:10,079
current status is always either

322
00:10:10,079 --> 00:10:13,839
i need more input or you know it

323
00:10:13,839 --> 00:10:16,560
basically you know was it okay or not

324
00:10:16,560 --> 00:10:18,640
and so um

325
00:10:18,640 --> 00:10:21,760
you know this lets us move the this the

326
00:10:21,760 --> 00:10:22,880
program counter that we

327
00:10:22,880 --> 00:10:24,560
we couldn't do on the first stack into

328
00:10:24,560 --> 00:10:26,320
the other stack of the go routine

329
00:10:26,320 --> 00:10:28,399
and so using additional go teams is a

330
00:10:28,399 --> 00:10:29,760
great way to hold

331
00:10:29,760 --> 00:10:31,519
additional code state and give you the

332
00:10:31,519 --> 00:10:33,839
ability to do these kinds of cleanups

333
00:10:33,839 --> 00:10:35,360
even if the original structure the

334
00:10:35,360 --> 00:10:37,120
product the problem makes it look like

335
00:10:37,120 --> 00:10:41,350
you can't

336
00:10:41,360 --> 00:10:45,040
but go ahead i i assume you're fine with

337
00:10:45,040 --> 00:10:46,320
uh people asking questions

338
00:10:46,320 --> 00:10:47,760
yeah absolutely i just wanted to make

339
00:10:47,760 --> 00:10:50,000
sure that yeah yeah definitely please

340
00:10:50,000 --> 00:10:53,680
interrupt um and so so the hint here is

341
00:10:53,680 --> 00:10:55,200
to use additional go routines

342
00:10:55,200 --> 00:10:57,519
to hold additional code state and

343
00:10:57,519 --> 00:10:58,720
there's there's one

344
00:10:58,720 --> 00:11:01,680
caveat to this and then it's not free to

345
00:11:01,680 --> 00:11:03,360
to just make go routines right you have

346
00:11:03,360 --> 00:11:04,800
to actually make sure that they exit

347
00:11:04,800 --> 00:11:06,320
because otherwise you'll just accumulate

348
00:11:06,320 --> 00:11:08,800
them and so you do have to think about

349
00:11:08,800 --> 00:11:10,800
uh you know why does the go routine exit

350
00:11:10,800 --> 00:11:12,640
like you know is it going to get cleaned

351
00:11:12,640 --> 00:11:13,120
up

352
00:11:13,120 --> 00:11:16,079
and in this case we know that you know q

353
00:11:16,079 --> 00:11:17,120
dot parse

354
00:11:17,120 --> 00:11:20,079
is going to return where you know parse

355
00:11:20,079 --> 00:11:22,320
go

356
00:11:22,320 --> 00:11:26,230
sorry that's not right um

357
00:11:26,240 --> 00:11:27,760
oh sorry the read string here read

358
00:11:27,760 --> 00:11:29,200
string is going to return any time it

359
00:11:29,200 --> 00:11:30,000
sends a

360
00:11:30,000 --> 00:11:32,240
a message that says need more input

361
00:11:32,240 --> 00:11:33,040
where'd it go

362
00:11:33,040 --> 00:11:34,079
there's something missing from this

363
00:11:34,079 --> 00:11:38,550
slide

364
00:11:38,560 --> 00:11:43,839
sorry i went through this last night um

365
00:11:43,839 --> 00:11:46,800
so so as we go in we go into init we

366
00:11:46,800 --> 00:11:48,079
kick off this go routine it's going to

367
00:11:48,079 --> 00:11:49,760
call read care a bunch of times

368
00:11:49,760 --> 00:11:51,360
and then we read the status once and

369
00:11:51,360 --> 00:11:52,880
that that first status is going to

370
00:11:52,880 --> 00:11:53,680
happen

371
00:11:53,680 --> 00:11:56,480
because the the first call to read care

372
00:11:56,480 --> 00:11:58,000
from read string is going to send i need

373
00:11:58,000 --> 00:11:59,120
more input and then we're going to send

374
00:11:59,120 --> 00:12:00,959
a character back

375
00:12:00,959 --> 00:12:02,320
um we're going to send the character

376
00:12:02,320 --> 00:12:04,000
back in process care

377
00:12:04,000 --> 00:12:05,680
and then every time process care gets

378
00:12:05,680 --> 00:12:07,760
called it returns a status

379
00:12:07,760 --> 00:12:10,560
and so up until you get um you know need

380
00:12:10,560 --> 00:12:12,079
more input you're going to get the

381
00:12:12,079 --> 00:12:15,360
um uh sorry

382
00:12:15,360 --> 00:12:17,519
this is not working um you're going to

383
00:12:17,519 --> 00:12:18,880
get any more input for every time you

384
00:12:18,880 --> 00:12:20,720
want to read a character

385
00:12:20,720 --> 00:12:21,839
and then when it's done reading

386
00:12:21,839 --> 00:12:23,839
characters what i haven't shown you here

387
00:12:23,839 --> 00:12:25,040
what seems to be missing

388
00:12:25,040 --> 00:12:28,399
somehow is when things exit and when

389
00:12:28,399 --> 00:12:29,519
things exit

390
00:12:29,519 --> 00:12:31,519
let's see if it's on this slide yeah so

391
00:12:31,519 --> 00:12:33,200
there's a return success and a return

392
00:12:33,200 --> 00:12:35,360
bad input that i'd forgotten about

393
00:12:35,360 --> 00:12:37,519
and so uh you know these return a

394
00:12:37,519 --> 00:12:39,600
different status and then they're done

395
00:12:39,600 --> 00:12:42,639
so when process care uh you know

396
00:12:42,639 --> 00:12:44,639
in in the read stream version when it

397
00:12:44,639 --> 00:12:47,120
returns you know bad input or success

398
00:12:47,120 --> 00:12:49,360
we we say that you know it's done and so

399
00:12:49,360 --> 00:12:51,120
as long as the caller

400
00:12:51,120 --> 00:12:54,560
is going through and um

401
00:12:54,560 --> 00:12:56,399
you know calling until it gets something

402
00:12:56,399 --> 00:12:58,240
that's not need more input

403
00:12:58,240 --> 00:13:00,480
then the go routine will finish but you

404
00:13:00,480 --> 00:13:02,000
know maybe if we stop early if the

405
00:13:02,000 --> 00:13:04,079
caller like hits an eof and stops on its

406
00:13:04,079 --> 00:13:06,000
own without telling us that it's done

407
00:13:06,000 --> 00:13:07,920
there's a go routine left over and so

408
00:13:07,920 --> 00:13:09,440
that could be a problem

409
00:13:09,440 --> 00:13:10,959
and so you just you need to make sure

410
00:13:10,959 --> 00:13:12,720
that you know when and why

411
00:13:12,720 --> 00:13:15,440
each go routine will exit and the nice

412
00:13:15,440 --> 00:13:17,519
thing is that if you do make a mistake

413
00:13:17,519 --> 00:13:19,760
and you leave guardians stuck they just

414
00:13:19,760 --> 00:13:21,519
sit there it's like the best possible

415
00:13:21,519 --> 00:13:22,959
bug in the world because they just sit

416
00:13:22,959 --> 00:13:24,240
around waiting for you to look at them

417
00:13:24,240 --> 00:13:25,360
and all you have to do is remember to

418
00:13:25,360 --> 00:13:26,320
look for them

419
00:13:26,320 --> 00:13:28,079
and so you know here's a very simple

420
00:13:28,079 --> 00:13:30,800
program at least go routines and it runs

421
00:13:30,800 --> 00:13:32,240
an http server

422
00:13:32,240 --> 00:13:34,320
and so you know if we run this it kicks

423
00:13:34,320 --> 00:13:36,160
off a whole bunch of effort routines

424
00:13:36,160 --> 00:13:38,320
and they all uh block trying to send to

425
00:13:38,320 --> 00:13:40,000
a channel and then it makes the http

426
00:13:40,000 --> 00:13:40,800
server

427
00:13:40,800 --> 00:13:42,480
and so if i run this program it just

428
00:13:42,480 --> 00:13:44,320
sits there and if i type control

429
00:13:44,320 --> 00:13:46,399
backslash on a unix system i get a sig

430
00:13:46,399 --> 00:13:47,360
quit

431
00:13:47,360 --> 00:13:48,959
which makes it crash and dump all the

432
00:13:48,959 --> 00:13:50,480
stacks of the go routines

433
00:13:50,480 --> 00:13:52,160
and you can see on the slide that you

434
00:13:52,160 --> 00:13:53,360
know it's going to print over and over

435
00:13:53,360 --> 00:13:54,720
again here's the go routine in h

436
00:13:54,720 --> 00:13:57,120
called from g called from f and and in a

437
00:13:57,120 --> 00:13:58,800
channel send

438
00:13:58,800 --> 00:14:00,160
and if you look at the line numbers you

439
00:14:00,160 --> 00:14:02,639
can see exactly where they are

440
00:14:02,639 --> 00:14:04,560
another option is that since we're in an

441
00:14:04,560 --> 00:14:06,959
http server

442
00:14:06,959 --> 00:14:09,440
and the hp server imports the net http

443
00:14:09,440 --> 00:14:10,480
prof package

444
00:14:10,480 --> 00:14:12,160
you can actually just visit the http

445
00:14:12,160 --> 00:14:15,040
server's debug pprofgoreteen url

446
00:14:15,040 --> 00:14:16,639
which gives you the stacks of all the

447
00:14:16,639 --> 00:14:18,880
running go routines and unlike the crash

448
00:14:18,880 --> 00:14:19,519
dump

449
00:14:19,519 --> 00:14:21,279
it takes a little more effort and it

450
00:14:21,279 --> 00:14:22,880
deduplicates the go routines based on

451
00:14:22,880 --> 00:14:24,000
their stacks

452
00:14:24,000 --> 00:14:26,240
and so and then it sorts them by how

453
00:14:26,240 --> 00:14:27,760
many there are of each stack and so if

454
00:14:27,760 --> 00:14:29,279
you have a go routine leak

455
00:14:29,279 --> 00:14:31,120
the leak shows up at the very top so in

456
00:14:31,120 --> 00:14:32,720
this case you've got 100 go routines

457
00:14:32,720 --> 00:14:34,160
stuck in h called from g

458
00:14:34,160 --> 00:14:36,079
call from f and then we can see there's

459
00:14:36,079 --> 00:14:37,680
like one of a couple other go routines

460
00:14:37,680 --> 00:14:39,519
and we don't really care about them

461
00:14:39,519 --> 00:14:41,360
and so you know this is a new hint that

462
00:14:41,360 --> 00:14:43,199
it just it's really really useful to

463
00:14:43,199 --> 00:14:45,279
look for stucco routines by just

464
00:14:45,279 --> 00:14:49,040
going to this end point all right

465
00:14:49,040 --> 00:14:52,000
so that was kind of the warm-up now i

466
00:14:52,000 --> 00:14:53,120
want to look at the first

467
00:14:53,120 --> 00:14:54,560
real concurrency pattern which is a

468
00:14:54,560 --> 00:14:56,560
publish subscribe server

469
00:14:56,560 --> 00:14:58,079
so publish subscribe is a way of

470
00:14:58,079 --> 00:15:00,240
structuring a program that you decouple

471
00:15:00,240 --> 00:15:01,440
the parts that are publishing

472
00:15:01,440 --> 00:15:02,480
interesting events

473
00:15:02,480 --> 00:15:04,079
from the things that are subscribing to

474
00:15:04,079 --> 00:15:05,920
them and there's a published subscriber

475
00:15:05,920 --> 00:15:07,360
pub sub server in the middle that

476
00:15:07,360 --> 00:15:08,399
connects those

477
00:15:08,399 --> 00:15:10,079
so the individual publishers and the

478
00:15:10,079 --> 00:15:11,600
individual subscribers don't have to be

479
00:15:11,600 --> 00:15:12,000
aware

480
00:15:12,000 --> 00:15:15,040
of exactly who the other ones are so you

481
00:15:15,040 --> 00:15:16,560
know on your android phone

482
00:15:16,560 --> 00:15:18,320
um an app might publish a make a phone

483
00:15:18,320 --> 00:15:20,480
call event and then the the dialer might

484
00:15:20,480 --> 00:15:22,320
subscribe to that and actually start and

485
00:15:22,320 --> 00:15:24,720
you know help dial

486
00:15:24,720 --> 00:15:26,320
and and so in a real pub sub server

487
00:15:26,320 --> 00:15:27,920
there are ways to filter events based on

488
00:15:27,920 --> 00:15:28,959
like what kind they are

489
00:15:28,959 --> 00:15:30,399
so that when you publish and make a

490
00:15:30,399 --> 00:15:31,839
phone call event like it doesn't go to

491
00:15:31,839 --> 00:15:33,120
your email program

492
00:15:33,120 --> 00:15:34,560
but you know for now we're just going to

493
00:15:34,560 --> 00:15:36,320
assume that the filtering is taken care

494
00:15:36,320 --> 00:15:37,199
of separately

495
00:15:37,199 --> 00:15:38,800
and we're just worried about the actual

496
00:15:38,800 --> 00:15:40,959
publish and subscribe

497
00:15:40,959 --> 00:15:43,440
and the concurrency of that so here's an

498
00:15:43,440 --> 00:15:44,160
api

499
00:15:44,160 --> 00:15:46,720
we want to implement with any number of

500
00:15:46,720 --> 00:15:48,639
clients that can call subscribe

501
00:15:48,639 --> 00:15:51,360
with a channel and afterwards events

502
00:15:51,360 --> 00:15:53,040
that are published will be sent on that

503
00:15:53,040 --> 00:15:54,399
channel

504
00:15:54,399 --> 00:15:55,759
and then when a client is no longer

505
00:15:55,759 --> 00:15:58,079
interested it can call cancel and pass

506
00:15:58,079 --> 00:15:59,199
in the same channel

507
00:15:59,199 --> 00:16:01,279
to say stop sending me events on that

508
00:16:01,279 --> 00:16:03,440
channel and the way that cancel will

509
00:16:03,440 --> 00:16:05,040
signal that it really is done

510
00:16:05,040 --> 00:16:06,639
sending events on that channel is it

511
00:16:06,639 --> 00:16:08,720
will close the channel so that the the

512
00:16:08,720 --> 00:16:10,399
receive the caller can can keep

513
00:16:10,399 --> 00:16:11,920
receiving events until it sees the

514
00:16:11,920 --> 00:16:13,360
channel get closed and then it knows

515
00:16:13,360 --> 00:16:16,720
that the cancel has taken effect

516
00:16:16,720 --> 00:16:20,079
um so notice that the information is

517
00:16:20,079 --> 00:16:20,959
only flowing

518
00:16:20,959 --> 00:16:22,880
one way on the channel right you can

519
00:16:22,880 --> 00:16:24,720
send to the channel

520
00:16:24,720 --> 00:16:26,399
and then it the receiver can receive

521
00:16:26,399 --> 00:16:28,000
from it and the information flows from

522
00:16:28,000 --> 00:16:29,519
the sender to the receiver and it never

523
00:16:29,519 --> 00:16:30,399
goes the other way

524
00:16:30,399 --> 00:16:32,959
so closing is also a signal from the

525
00:16:32,959 --> 00:16:33,600
sender

526
00:16:33,600 --> 00:16:35,759
to the receiver but all the sending is

527
00:16:35,759 --> 00:16:37,920
over the receiver cannot close the

528
00:16:37,920 --> 00:16:39,519
channel to tell the sender like i don't

529
00:16:39,519 --> 00:16:40,720
want you to send anymore

530
00:16:40,720 --> 00:16:42,160
because that's information going the

531
00:16:42,160 --> 00:16:44,399
opposite direction and it's just a lot

532
00:16:44,399 --> 00:16:45,920
easier to reason about

533
00:16:45,920 --> 00:16:48,320
if the information only goes one way and

534
00:16:48,320 --> 00:16:49,120
of course

535
00:16:49,120 --> 00:16:51,199
if you need communication in both

536
00:16:51,199 --> 00:16:52,560
directions you can use a pair of

537
00:16:52,560 --> 00:16:53,279
channels

538
00:16:53,279 --> 00:16:54,800
and it often turns out to be the case

539
00:16:54,800 --> 00:16:56,480
that those uh

540
00:16:56,480 --> 00:16:57,759
different directions may have different

541
00:16:57,759 --> 00:17:00,079
types of data flowing like before we saw

542
00:17:00,079 --> 00:17:01,199
that there were runes going in one

543
00:17:01,199 --> 00:17:02,800
direction and status updates going in

544
00:17:02,800 --> 00:17:04,640
the other direction

545
00:17:04,640 --> 00:17:07,839
so how do we implement this api

546
00:17:07,839 --> 00:17:09,760
here's a pretty basic implementation

547
00:17:09,760 --> 00:17:11,919
that you know could be good enough

548
00:17:11,919 --> 00:17:14,400
we have a server and the server state is

549
00:17:14,400 --> 00:17:16,559
a map of registered subscriber channels

550
00:17:16,559 --> 00:17:18,480
protected by a lock

551
00:17:18,480 --> 00:17:20,319
we initialize the server by just

552
00:17:20,319 --> 00:17:22,079
allocating the map

553
00:17:22,079 --> 00:17:24,000
and then to publish the event we just

554
00:17:24,000 --> 00:17:26,959
send it to every registered channel

555
00:17:26,959 --> 00:17:28,640
to subscribe a new channel we just add

556
00:17:28,640 --> 00:17:30,960
it to the map and to cancel we take it

557
00:17:30,960 --> 00:17:32,320
out of the map

558
00:17:32,320 --> 00:17:35,039
and then because these are all um these

559
00:17:35,039 --> 00:17:36,320
are all methods that might be called

560
00:17:36,320 --> 00:17:38,080
from multiple go routines

561
00:17:38,080 --> 00:17:40,960
um we need to call lock and unlock

562
00:17:40,960 --> 00:17:42,080
around these

563
00:17:42,080 --> 00:17:44,880
to um you know protect the map and

564
00:17:44,880 --> 00:17:46,960
notice that i wrote defer unlock

565
00:17:46,960 --> 00:17:49,039
right after the lock so i don't have to

566
00:17:49,039 --> 00:17:51,039
remember to unlock it later

567
00:17:51,039 --> 00:17:52,480
uh you've probably all seen this you

568
00:17:52,480 --> 00:17:53,760
know it's sort of a nice idiom to just

569
00:17:53,760 --> 00:17:55,440
do the lock unlock and then you know

570
00:17:55,440 --> 00:17:56,880
have a blank line and have that be its

571
00:17:56,880 --> 00:18:02,630
own kind of paragraph in the code

572
00:18:02,640 --> 00:18:04,960
one thing i want to point out is that

573
00:18:04,960 --> 00:18:06,720
using defer makes sure that the mutex

574
00:18:06,720 --> 00:18:07,600
gets unlocked

575
00:18:07,600 --> 00:18:09,120
even if you have multiple returns from

576
00:18:09,120 --> 00:18:10,799
the function so you can't forget

577
00:18:10,799 --> 00:18:12,400
but it also makes sure that it gets

578
00:18:12,400 --> 00:18:14,160
unlocked if you have a panic

579
00:18:14,160 --> 00:18:16,240
like in subscribe and cancel where

580
00:18:16,240 --> 00:18:18,960
there's you know panics for misuse

581
00:18:18,960 --> 00:18:21,280
and there is a subtlety here about if

582
00:18:21,280 --> 00:18:23,120
you might not want to unlock the mutex

583
00:18:23,120 --> 00:18:23,600
if

584
00:18:23,600 --> 00:18:25,280
the panic happened while the thing that

585
00:18:25,280 --> 00:18:27,760
was locked is in some inconsistent state

586
00:18:27,760 --> 00:18:29,919
but i'm going to ignore that for now in

587
00:18:29,919 --> 00:18:31,520
general

588
00:18:31,520 --> 00:18:33,520
you try to avoid having the the things

589
00:18:33,520 --> 00:18:35,039
that might panic

590
00:18:35,039 --> 00:18:36,559
happen while you're you know potentially

591
00:18:36,559 --> 00:18:38,559
an inconsistent state

592
00:18:38,559 --> 00:18:40,400
and i should also point out that the use

593
00:18:40,400 --> 00:18:42,400
of panic at all in subscribe

594
00:18:42,400 --> 00:18:44,880
and cancel implies that you really trust

595
00:18:44,880 --> 00:18:46,720
your clients not to misuse the interface

596
00:18:46,720 --> 00:18:47,200
that

597
00:18:47,200 --> 00:18:49,679
it is a program error worth you know

598
00:18:49,679 --> 00:18:51,039
tearing down the entire program

599
00:18:51,039 --> 00:18:52,000
potentially

600
00:18:52,000 --> 00:18:54,240
for that to happen and in a bigger

601
00:18:54,240 --> 00:18:55,919
program where other clients were using

602
00:18:55,919 --> 00:18:57,440
this api

603
00:18:57,440 --> 00:18:58,880
you'd probably want to return an error

604
00:18:58,880 --> 00:19:01,039
instead and not have the possibility of

605
00:19:01,039 --> 00:19:02,480
taking down the whole program

606
00:19:02,480 --> 00:19:05,039
but panicking simplifies things for now

607
00:19:05,039 --> 00:19:06,480
and you know error handling in general

608
00:19:06,480 --> 00:19:07,120
is kind of

609
00:19:07,120 --> 00:19:10,880
not the topic today

610
00:19:10,880 --> 00:19:12,400
a more important concern with this code

611
00:19:12,400 --> 00:19:14,880
than panics is what happens

612
00:19:14,880 --> 00:19:17,200
if a go routine is slow to receive

613
00:19:17,200 --> 00:19:18,559
events

614
00:19:18,559 --> 00:19:20,480
so all the operations here are done

615
00:19:20,480 --> 00:19:22,240
holding the mutex which means all the

616
00:19:22,240 --> 00:19:23,760
clients kind of have to proceed in

617
00:19:23,760 --> 00:19:25,440
lockstep

618
00:19:25,440 --> 00:19:27,840
so during publish there's a loop that's

619
00:19:27,840 --> 00:19:28,559
sending

620
00:19:28,559 --> 00:19:30,559
on the channels sending the event to

621
00:19:30,559 --> 00:19:32,640
every channel and if one subscriber

622
00:19:32,640 --> 00:19:33,760
falls behind

623
00:19:33,760 --> 00:19:35,039
the next subscriber doesn't get the

624
00:19:35,039 --> 00:19:36,880
event until that slow subscriber you

625
00:19:36,880 --> 00:19:38,880
know wakes up and actually gets the

626
00:19:38,880 --> 00:19:41,280
the event off off that channel and so

627
00:19:41,280 --> 00:19:42,880
one slow subscriber

628
00:19:42,880 --> 00:19:45,360
can slow down everyone else and you know

629
00:19:45,360 --> 00:19:47,280
forcing them to proceed in lockstep this

630
00:19:47,280 --> 00:19:47,600
way

631
00:19:47,600 --> 00:19:50,080
is not always a problem if you've you

632
00:19:50,080 --> 00:19:51,679
know documented the restriction

633
00:19:51,679 --> 00:19:53,600
and for whatever reason you know how the

634
00:19:53,600 --> 00:19:54,880
clients are are written

635
00:19:54,880 --> 00:19:56,400
and you know that they won't ever fall

636
00:19:56,400 --> 00:19:58,320
too far behind this could be totally

637
00:19:58,320 --> 00:20:01,039
fine it's a really simple implementation

638
00:20:01,039 --> 00:20:03,840
and um and it has nice properties like

639
00:20:03,840 --> 00:20:05,760
on return from publish you know that the

640
00:20:05,760 --> 00:20:06,400
event has

641
00:20:06,400 --> 00:20:07,840
actually been handed off to each of the

642
00:20:07,840 --> 00:20:09,520
other grow routines you don't know that

643
00:20:09,520 --> 00:20:10,880
they've started processing it but you

644
00:20:10,880 --> 00:20:12,400
know it's been handed off

645
00:20:12,400 --> 00:20:14,080
and so you know maybe that's good enough

646
00:20:14,080 --> 00:20:16,480
and you could stop here

647
00:20:16,480 --> 00:20:18,640
a second option is that if you need to

648
00:20:18,640 --> 00:20:20,559
tolerate just a little bit of slowness

649
00:20:20,559 --> 00:20:23,200
on the the subscribers then you could

650
00:20:23,200 --> 00:20:24,640
say that they need to give you a

651
00:20:24,640 --> 00:20:26,480
buffered channel with room for a couple

652
00:20:26,480 --> 00:20:27,840
events in the buffer

653
00:20:27,840 --> 00:20:30,480
so that you know when you're publishing

654
00:20:30,480 --> 00:20:31,679
you know as long as they're not too far

655
00:20:31,679 --> 00:20:33,120
behind there'll always be room

656
00:20:33,120 --> 00:20:35,440
for the new event to go into the channel

657
00:20:35,440 --> 00:20:36,159
buffer

658
00:20:36,159 --> 00:20:38,000
and then the actual publish won't block

659
00:20:38,000 --> 00:20:39,440
for too long

660
00:20:39,440 --> 00:20:41,039
and again maybe that's good enough if

661
00:20:41,039 --> 00:20:42,559
you're sure that they won't ever fall

662
00:20:42,559 --> 00:20:43,679
too far behind

663
00:20:43,679 --> 00:20:46,559
you get to stop there but in a really

664
00:20:46,559 --> 00:20:48,320
big program

665
00:20:48,320 --> 00:20:50,320
you do want to cope more gracefully with

666
00:20:50,320 --> 00:20:53,039
arbitrarily arbitrarily slow subscribers

667
00:20:53,039 --> 00:20:54,559
and so then the question is what do you

668
00:20:54,559 --> 00:20:55,440
do

669
00:20:55,440 --> 00:20:56,799
and so you know in general you have

670
00:20:56,799 --> 00:20:58,720
three options you can slow down the

671
00:20:58,720 --> 00:20:59,679
event generator

672
00:20:59,679 --> 00:21:01,840
which is what the previous solutions

673
00:21:01,840 --> 00:21:02,799
implicitly do

674
00:21:02,799 --> 00:21:05,200
because publish stops until the

675
00:21:05,200 --> 00:21:07,120
subscribers catch up

676
00:21:07,120 --> 00:21:09,919
or you can drop events or you can queue

677
00:21:09,919 --> 00:21:11,760
an arbitrary number of past events

678
00:21:11,760 --> 00:21:14,400
those are pretty much your only options

679
00:21:14,400 --> 00:21:15,600
so we talked about

680
00:21:15,600 --> 00:21:17,440
you know publish and slowing down the

681
00:21:17,440 --> 00:21:19,039
event generator

682
00:21:19,039 --> 00:21:20,880
there's a middle ground where you

683
00:21:20,880 --> 00:21:23,200
coalesce the events or you drop them

684
00:21:23,200 --> 00:21:26,799
um so that you know the subscriber might

685
00:21:26,799 --> 00:21:27,760
find out that

686
00:21:27,760 --> 00:21:29,120
you know hey you missed some events and

687
00:21:29,120 --> 00:21:30,400
i can't tell you what they were because

688
00:21:30,400 --> 00:21:31,840
i didn't save them but but i'm at least

689
00:21:31,840 --> 00:21:32,480
going to tell you

690
00:21:32,480 --> 00:21:34,960
you missed five events and then maybe it

691
00:21:34,960 --> 00:21:37,440
can do something else to try to catch up

692
00:21:37,440 --> 00:21:39,840
and this is the kind of approach that um

693
00:21:39,840 --> 00:21:41,440
that we take in the profiler so in the

694
00:21:41,440 --> 00:21:43,360
profiler if you've used it

695
00:21:43,360 --> 00:21:46,559
if uh there's a go routine that uh fills

696
00:21:46,559 --> 00:21:48,320
the profile on on a signal handler

697
00:21:48,320 --> 00:21:49,120
actually

698
00:21:49,120 --> 00:21:51,280
with profiling events and then there's a

699
00:21:51,280 --> 00:21:52,880
separate go routine whose job is to read

700
00:21:52,880 --> 00:21:54,640
the data back out and like write it to

701
00:21:54,640 --> 00:21:56,880
disk or send it to a http request or

702
00:21:56,880 --> 00:21:58,240
whatever it is you're doing with profile

703
00:21:58,240 --> 00:21:59,120
data

704
00:21:59,120 --> 00:22:01,440
and there's a buffer in the middle and

705
00:22:01,440 --> 00:22:02,159
if the

706
00:22:02,159 --> 00:22:04,000
receiver from the profile data falls

707
00:22:04,000 --> 00:22:06,320
behind when the buffer fills up we start

708
00:22:06,320 --> 00:22:08,080
adding entries to

709
00:22:08,080 --> 00:22:11,039
a final profile entry that just has a

710
00:22:11,039 --> 00:22:12,559
single entry that's that's

711
00:22:12,559 --> 00:22:14,640
a function called runtime.lost profile

712
00:22:14,640 --> 00:22:15,840
data and so

713
00:22:15,840 --> 00:22:17,120
if you go look at the profile you see

714
00:22:17,120 --> 00:22:18,320
like hey the program spent five percent

715
00:22:18,320 --> 00:22:20,159
of its time in lost profile data

716
00:22:20,159 --> 00:22:22,960
that just means you know the the profile

717
00:22:22,960 --> 00:22:23,520
reader

718
00:22:23,520 --> 00:22:26,320
was too slow and it didn't catch up and

719
00:22:26,320 --> 00:22:27,440
and we lost some of the profile but

720
00:22:27,440 --> 00:22:28,960
we're clear about exactly

721
00:22:28,960 --> 00:22:30,799
you know what the error rate is in the

722
00:22:30,799 --> 00:22:33,039
profile and you pretty much never see

723
00:22:33,039 --> 00:22:34,559
that because all the readers actually do

724
00:22:34,559 --> 00:22:35,360
keep up

725
00:22:35,360 --> 00:22:37,440
but just in case they didn't you have a

726
00:22:37,440 --> 00:22:40,240
pretty clear signal um

727
00:22:40,240 --> 00:22:42,720
an example of purely dropping the events

728
00:22:42,720 --> 00:22:44,480
is the os signal package

729
00:22:44,480 --> 00:22:47,520
where um

730
00:22:47,520 --> 00:22:49,120
you have to pass in a channel that will

731
00:22:49,120 --> 00:22:50,799
be ready to receive the signal

732
00:22:50,799 --> 00:22:54,159
a signal like sig hop or sig quit and

733
00:22:54,159 --> 00:22:55,520
when the signal comes in

734
00:22:55,520 --> 00:22:57,120
the run time tries to send to each of

735
00:22:57,120 --> 00:22:58,480
the channels that subscribe to that

736
00:22:58,480 --> 00:22:59,200
signal

737
00:22:59,200 --> 00:23:00,799
and if it can't send to it it just

738
00:23:00,799 --> 00:23:02,240
doesn't it's just gone

739
00:23:02,240 --> 00:23:03,760
um because you know we're in a signal

740
00:23:03,760 --> 00:23:06,080
handler we can't wait and so

741
00:23:06,080 --> 00:23:07,600
what the callers have to do is they have

742
00:23:07,600 --> 00:23:09,200
to pass in a buffered channel and if

743
00:23:09,200 --> 00:23:10,960
they pass in a buffered channel

744
00:23:10,960 --> 00:23:12,720
that has you know length at least one

745
00:23:12,720 --> 00:23:14,480
buffer length at least one

746
00:23:14,480 --> 00:23:16,640
and they only register that channel to a

747
00:23:16,640 --> 00:23:18,320
single signal

748
00:23:18,320 --> 00:23:21,440
then you know that if a signal comes in

749
00:23:21,440 --> 00:23:22,559
you're definitely going to get told

750
00:23:22,559 --> 00:23:23,360
about it

751
00:23:23,360 --> 00:23:25,280
if it comes in twice you might only get

752
00:23:25,280 --> 00:23:26,480
told about it once

753
00:23:26,480 --> 00:23:28,000
but that's actually the same semantics

754
00:23:28,000 --> 00:23:30,080
that unix gives to processes for signals

755
00:23:30,080 --> 00:23:30,799
anyway

756
00:23:30,799 --> 00:23:32,960
so that's fine so those are both

757
00:23:32,960 --> 00:23:34,880
examples of dropping or coalescing

758
00:23:34,880 --> 00:23:36,720
events

759
00:23:36,720 --> 00:23:38,640
and then the third choice is that you

760
00:23:38,640 --> 00:23:39,760
might actually just

761
00:23:39,760 --> 00:23:41,600
really not want to lose any events it

762
00:23:41,600 --> 00:23:43,279
might just be really important that you

763
00:23:43,279 --> 00:23:44,559
never lose anything

764
00:23:44,559 --> 00:23:46,880
in which case you know you can queue an

765
00:23:46,880 --> 00:23:48,400
arbitrary number of events you can

766
00:23:48,400 --> 00:23:50,080
somehow arrange for

767
00:23:50,080 --> 00:23:52,480
the program to just save all the events

768
00:23:52,480 --> 00:23:53,279
that the

769
00:23:53,279 --> 00:23:54,960
you know slow subscriber hasn't seen yet

770
00:23:54,960 --> 00:23:56,960
somewhere and and give them to the

771
00:23:56,960 --> 00:23:58,559
subscriber later

772
00:23:58,559 --> 00:23:59,760
and it's really important to think

773
00:23:59,760 --> 00:24:01,679
carefully before you do that because in

774
00:24:01,679 --> 00:24:03,440
a distributed system

775
00:24:03,440 --> 00:24:05,120
you know there's always slow computers

776
00:24:05,120 --> 00:24:06,720
always computers that

777
00:24:06,720 --> 00:24:08,480
have fallen offline or whatever and they

778
00:24:08,480 --> 00:24:10,000
might be gone for a while

779
00:24:10,000 --> 00:24:11,440
and so you don't want to introduce

780
00:24:11,440 --> 00:24:13,600
unbounded queuing in general you want to

781
00:24:13,600 --> 00:24:15,200
think very carefully before you do that

782
00:24:15,200 --> 00:24:16,320
and think well you know

783
00:24:16,320 --> 00:24:18,240
how unbounded is it really and can i

784
00:24:18,240 --> 00:24:19,520
tolerate that

785
00:24:19,520 --> 00:24:21,360
and so like that's a reason why channels

786
00:24:21,360 --> 00:24:24,240
don't have just an unbounded buffering

787
00:24:24,240 --> 00:24:25,760
it's really almost never the right

788
00:24:25,760 --> 00:24:27,520
choice and if it is the right choice

789
00:24:27,520 --> 00:24:28,720
you probably want to build it very

790
00:24:28,720 --> 00:24:30,559
carefully

791
00:24:30,559 --> 00:24:32,880
um and so but we're going to build one

792
00:24:32,880 --> 00:24:35,840
just to see what it would look like

793
00:24:35,840 --> 00:24:38,000
and before we do that i just want to

794
00:24:38,000 --> 00:24:39,919
adjust the program a little bit

795
00:24:39,919 --> 00:24:42,960
so we have this mutex in the code

796
00:24:42,960 --> 00:24:45,200
and the mutex is an example of of

797
00:24:45,200 --> 00:24:46,000
keeping the

798
00:24:46,000 --> 00:24:48,000
the state whether you're locked or not

799
00:24:48,000 --> 00:24:49,279
in a state variable

800
00:24:49,279 --> 00:24:51,360
but we can also move that into a program

801
00:24:51,360 --> 00:24:52,880
counter variable

802
00:24:52,880 --> 00:24:55,039
by putting it in a different go routine

803
00:24:55,039 --> 00:24:57,120
and so

804
00:24:57,120 --> 00:24:58,720
in this case we can start a new go

805
00:24:58,720 --> 00:25:01,039
routine that runs a program a function

806
00:25:01,039 --> 00:25:02,720
called s dot loop

807
00:25:02,720 --> 00:25:04,720
and it handles requests sent on three

808
00:25:04,720 --> 00:25:06,480
new channels publish subscribe and

809
00:25:06,480 --> 00:25:07,760
cancel

810
00:25:07,760 --> 00:25:10,159
and so in init we make the channels and

811
00:25:10,159 --> 00:25:11,520
then we we kick off

812
00:25:11,520 --> 00:25:14,960
s dot loop and s dot loop is sort of

813
00:25:14,960 --> 00:25:16,960
the amalgamation of the previous method

814
00:25:16,960 --> 00:25:18,480
bodies and it just

815
00:25:18,480 --> 00:25:20,799
receives from any of the three channels

816
00:25:20,799 --> 00:25:21,520
a request

817
00:25:21,520 --> 00:25:23,919
a publish a subscriber a cancel request

818
00:25:23,919 --> 00:25:26,000
and it does whatever was asked

819
00:25:26,000 --> 00:25:29,120
and now that map the subscriber map

820
00:25:29,120 --> 00:25:31,279
can be just a local variable in s dot

821
00:25:31,279 --> 00:25:32,240
loop

822
00:25:32,240 --> 00:25:34,480
and and so um you know it's the same

823
00:25:34,480 --> 00:25:35,679
code

824
00:25:35,679 --> 00:25:38,159
but now that data is clearly owned by

825
00:25:38,159 --> 00:25:40,000
s.loop nothing else could even get to it

826
00:25:40,000 --> 00:25:44,310
because it's a local variable

827
00:25:44,320 --> 00:25:45,679
and then we just need to change the

828
00:25:45,679 --> 00:25:47,600
original methods to send the work over

829
00:25:47,600 --> 00:25:49,520
to the loop go routine and so uppercase

830
00:25:49,520 --> 00:25:50,400
publish

831
00:25:50,400 --> 00:25:52,960
now sends on lowercase publish the

832
00:25:52,960 --> 00:25:53,840
channel

833
00:25:53,840 --> 00:25:55,679
the event that it wants to publish and

834
00:25:55,679 --> 00:25:58,240
similarly subscribe and cancel

835
00:25:58,240 --> 00:26:01,200
they create a request that has a channel

836
00:26:01,200 --> 00:26:01,679
uh

837
00:26:01,679 --> 00:26:03,520
that we want to subscribe and also a

838
00:26:03,520 --> 00:26:05,200
channel to get the answer back

839
00:26:05,200 --> 00:26:07,120
and they send that into the loop and

840
00:26:07,120 --> 00:26:11,909
then the loop sends back the answer

841
00:26:11,919 --> 00:26:14,159
and so i referred to transforming the

842
00:26:14,159 --> 00:26:15,760
program this way as like converting the

843
00:26:15,760 --> 00:26:16,320
mutex

844
00:26:16,320 --> 00:26:18,559
into a go routine because we took the

845
00:26:18,559 --> 00:26:20,000
data state of the mutex there's like a

846
00:26:20,000 --> 00:26:22,000
lock bit inside it and now that lock bit

847
00:26:22,000 --> 00:26:22,240
is

848
00:26:22,240 --> 00:26:24,000
implicit in the program counter of the

849
00:26:24,000 --> 00:26:25,919
loop um

850
00:26:25,919 --> 00:26:27,840
it's very clear that you can't ever have

851
00:26:27,840 --> 00:26:29,440
you know a publish and subscribe

852
00:26:29,440 --> 00:26:30,960
happening at the same time

853
00:26:30,960 --> 00:26:32,960
because it's just single threaded code

854
00:26:32,960 --> 00:26:36,559
and just you know executes in sequence

855
00:26:36,559 --> 00:26:38,240
on the other hand the the original

856
00:26:38,240 --> 00:26:40,000
version had a kind of like clarity of

857
00:26:40,000 --> 00:26:42,320
state where you could sort of inspect it

858
00:26:42,320 --> 00:26:44,000
and and reason about well this is the

859
00:26:44,000 --> 00:26:46,400
important state and and it's harder in

860
00:26:46,400 --> 00:26:47,120
the

861
00:26:47,120 --> 00:26:48,640
go routine version to see like what's

862
00:26:48,640 --> 00:26:50,480
important state and what's kind of

863
00:26:50,480 --> 00:26:52,320
incidental state from just having a go

864
00:26:52,320 --> 00:26:53,600
routine

865
00:26:53,600 --> 00:26:55,840
and in a given situation you know one

866
00:26:55,840 --> 00:26:57,760
might be more important than the other

867
00:26:57,760 --> 00:27:00,240
so a couple years ago i did all the labs

868
00:27:00,240 --> 00:27:01,679
for the class when it first switched to

869
00:27:01,679 --> 00:27:02,320
go

870
00:27:02,320 --> 00:27:05,440
and and raft is a good example of where

871
00:27:05,440 --> 00:27:07,039
you probably prefer the state with the

872
00:27:07,039 --> 00:27:08,480
mutex is because

873
00:27:08,480 --> 00:27:11,200
raft is is so different from most

874
00:27:11,200 --> 00:27:12,960
concurrent programs and that like

875
00:27:12,960 --> 00:27:15,360
each replica is just kind of profoundly

876
00:27:15,360 --> 00:27:17,360
uncertain of its state right like the

877
00:27:17,360 --> 00:27:18,880
state transitions

878
00:27:18,880 --> 00:27:20,080
you know one moment you think you're the

879
00:27:20,080 --> 00:27:21,440
leader and the next moment you've been

880
00:27:21,440 --> 00:27:22,080
deposed

881
00:27:22,080 --> 00:27:23,679
like one moment your log has ten entries

882
00:27:23,679 --> 00:27:24,960
the next moment you find actually no it

883
00:27:24,960 --> 00:27:26,080
only has two entries

884
00:27:26,080 --> 00:27:28,000
and so being able to manipulate that

885
00:27:28,000 --> 00:27:29,200
state directly

886
00:27:29,200 --> 00:27:31,039
rather than having to you know somehow

887
00:27:31,039 --> 00:27:32,960
get it in and out of the program counter

888
00:27:32,960 --> 00:27:34,880
makes a lot more sense for raft but

889
00:27:34,880 --> 00:27:37,919
that's pretty unique in most situations

890
00:27:37,919 --> 00:27:39,600
it cleans things up to put the state in

891
00:27:39,600 --> 00:27:42,549
the program counter

892
00:27:42,559 --> 00:27:44,559
all right so in order to deal with the

893
00:27:44,559 --> 00:27:46,080
slow subscribers

894
00:27:46,080 --> 00:27:47,440
now we're going to add some helper go

895
00:27:47,440 --> 00:27:49,360
routines and their job

896
00:27:49,360 --> 00:27:51,360
is to manage a particular subscriber's

897
00:27:51,360 --> 00:27:53,360
backlog and keep the overall program

898
00:27:53,360 --> 00:27:54,480
from blocking

899
00:27:54,480 --> 00:27:57,120
and so this is the helper go team and

900
00:27:57,120 --> 00:27:57,679
the the

901
00:27:57,679 --> 00:27:59,279
the main loop go routine will send the

902
00:27:59,279 --> 00:28:00,720
events to the helper

903
00:28:00,720 --> 00:28:02,960
which we then trust because we wrote it

904
00:28:02,960 --> 00:28:05,120
not to fall arbitrarily behind

905
00:28:05,120 --> 00:28:07,200
and then the helpers job is to cue

906
00:28:07,200 --> 00:28:08,799
events if needed and send them off to

907
00:28:08,799 --> 00:28:10,880
the subscriber

908
00:28:10,880 --> 00:28:13,440
all right so this actually has um two

909
00:28:13,440 --> 00:28:14,720
problems

910
00:28:14,720 --> 00:28:16,799
the first is that if there's nothing in

911
00:28:16,799 --> 00:28:17,840
the queue

912
00:28:17,840 --> 00:28:19,919
then the select is actually wrong to try

913
00:28:19,919 --> 00:28:21,840
to offer q of zero and in fact just

914
00:28:21,840 --> 00:28:23,600
evaluating q of zero at the start of the

915
00:28:23,600 --> 00:28:24,559
select will panic

916
00:28:24,559 --> 00:28:27,440
because the queue is empty and so we can

917
00:28:27,440 --> 00:28:28,720
fix these

918
00:28:28,720 --> 00:28:30,799
by setting up the arguments separately

919
00:28:30,799 --> 00:28:32,880
from the select and in particular

920
00:28:32,880 --> 00:28:35,679
we need to make a channel send out

921
00:28:35,679 --> 00:28:36,960
that's going to be nil

922
00:28:36,960 --> 00:28:39,039
which is never able to proceed in a

923
00:28:39,039 --> 00:28:40,000
select

924
00:28:40,000 --> 00:28:42,720
um as we know when we don't want to send

925
00:28:42,720 --> 00:28:44,080
and it's going to be the actual

926
00:28:44,080 --> 00:28:46,159
out channel when we do want to send and

927
00:28:46,159 --> 00:28:47,760
then we have to have a separate variable

928
00:28:47,760 --> 00:28:49,120
that holds the event that we're going to

929
00:28:49,120 --> 00:28:50,399
send it will only you know

930
00:28:50,399 --> 00:28:52,000
actually read from q of 0 if there's

931
00:28:52,000 --> 00:28:55,350
something in the queue

932
00:28:55,360 --> 00:28:57,360
the second thing that's wrong is that we

933
00:28:57,360 --> 00:28:59,360
need to handle closing of the channel of

934
00:28:59,360 --> 00:29:00,399
the input channel

935
00:29:00,399 --> 00:29:02,480
because when the input channel closes we

936
00:29:02,480 --> 00:29:04,000
need to flush the rest of the queue and

937
00:29:04,000 --> 00:29:06,640
then we need to close the output channel

938
00:29:06,640 --> 00:29:08,720
so to check for that we change the

939
00:29:08,720 --> 00:29:09,679
select from just

940
00:29:09,679 --> 00:29:12,640
doing e equals receive from n to e comma

941
00:29:12,640 --> 00:29:14,480
okay equals receive from n and the comma

942
00:29:14,480 --> 00:29:15,760
okay we'll be told

943
00:29:15,760 --> 00:29:17,600
whether or not the channel is actually

944
00:29:17,600 --> 00:29:20,080
sending real data or else it's closed

945
00:29:20,080 --> 00:29:22,399
and so when okay is false we can set

946
00:29:22,399 --> 00:29:23,200
into nil

947
00:29:23,200 --> 00:29:24,880
to say let's stop trying to receive from

948
00:29:24,880 --> 00:29:25,840
in there's nothing there we're just

949
00:29:25,840 --> 00:29:27,039
going to keep getting told that it's

950
00:29:27,039 --> 00:29:28,640
closed

951
00:29:28,640 --> 00:29:31,279
and then when the loop is fine when the

952
00:29:31,279 --> 00:29:33,360
queue is finally empty we can exit the

953
00:29:33,360 --> 00:29:33,919
loop

954
00:29:33,919 --> 00:29:36,000
and so we change the for condition to

955
00:29:36,000 --> 00:29:38,080
say we want to keep exiting the loop as

956
00:29:38,080 --> 00:29:38,640
long as

957
00:29:38,640 --> 00:29:40,720
there actually still is an input channel

958
00:29:40,720 --> 00:29:41,840
and there's something

959
00:29:41,840 --> 00:29:43,279
to write back to the output channel and

960
00:29:43,279 --> 00:29:45,200
then once both of those are not true

961
00:29:45,200 --> 00:29:45,919
anymore

962
00:29:45,919 --> 00:29:47,440
it's time to close it's time to exit the

963
00:29:47,440 --> 00:29:49,360
loop and we close the output channel

964
00:29:49,360 --> 00:29:50,559
and we're done and so now we've

965
00:29:50,559 --> 00:29:52,960
correctly propagated the closing

966
00:29:52,960 --> 00:29:54,480
of the input channel to the output

967
00:29:54,480 --> 00:29:56,559
channel

968
00:29:56,559 --> 00:29:58,640
so that was the helper and the server

969
00:29:58,640 --> 00:30:01,360
loop used to look like this

970
00:30:01,360 --> 00:30:03,520
and to update it we just changed the

971
00:30:03,520 --> 00:30:04,880
subscription map

972
00:30:04,880 --> 00:30:06,720
before it was a map from subscribe

973
00:30:06,720 --> 00:30:08,480
channels to bools it was just basically

974
00:30:08,480 --> 00:30:09,360
a set

975
00:30:09,360 --> 00:30:11,120
and now it's a map from subscribe

976
00:30:11,120 --> 00:30:12,960
channel to helper channel

977
00:30:12,960 --> 00:30:15,039
and every time we get a new subscription

978
00:30:15,039 --> 00:30:16,559
we make a helper channel

979
00:30:16,559 --> 00:30:19,200
we kick off a helper go routine and we

980
00:30:19,200 --> 00:30:20,640
record the helper channel in the

981
00:30:20,640 --> 00:30:21,840
subscription map

982
00:30:21,840 --> 00:30:24,559
instead of the the actual channel and

983
00:30:24,559 --> 00:30:26,320
then the rest of

984
00:30:26,320 --> 00:30:29,120
uh the rest of the the loop actually

985
00:30:29,120 --> 00:30:32,470
barely changes at all

986
00:30:32,480 --> 00:30:34,159
so i do want to point out that like if

987
00:30:34,159 --> 00:30:36,159
you wanted to have a different strategy

988
00:30:36,159 --> 00:30:39,200
for you know what you do with uh clients

989
00:30:39,200 --> 00:30:40,559
that fall too far behind

990
00:30:40,559 --> 00:30:42,320
that can all go in the helper go routine

991
00:30:42,320 --> 00:30:44,080
the code on the screen right now

992
00:30:44,080 --> 00:30:45,840
is completely unchanged so we've we've

993
00:30:45,840 --> 00:30:47,279
completely separated the

994
00:30:47,279 --> 00:30:49,440
publish subscribe maintaining the the

995
00:30:49,440 --> 00:30:51,200
actual list of subscribers map

996
00:30:51,200 --> 00:30:53,279
from the what do you do when things get

997
00:30:53,279 --> 00:30:54,399
too slow map

998
00:30:54,399 --> 00:30:58,080
or problem and so it's really nice that

999
00:30:58,080 --> 00:30:59,600
you've got this clean separation of

1000
00:30:59,600 --> 00:31:01,120
concerns into completely different go

1001
00:31:01,120 --> 00:31:02,559
routines and that can help you you know

1002
00:31:02,559 --> 00:31:04,159
keep your program simpler

1003
00:31:04,159 --> 00:31:06,000
and so that's the general hint is that

1004
00:31:06,000 --> 00:31:07,760
you can use go routines a lot of the

1005
00:31:07,760 --> 00:31:11,830
time to separate independent concerns

1006
00:31:11,840 --> 00:31:15,440
all right so um

1007
00:31:15,440 --> 00:31:17,360
the second pattern for today is a work

1008
00:31:17,360 --> 00:31:18,480
scheduler

1009
00:31:18,480 --> 00:31:20,000
and you did one of these in lab one for

1010
00:31:20,000 --> 00:31:21,679
mapreduce and i'm just gonna

1011
00:31:21,679 --> 00:31:24,159
you know build up to that and and this

1012
00:31:24,159 --> 00:31:25,840
doesn't do all the rpc stuff it just

1013
00:31:25,840 --> 00:31:27,120
kind of assumes that there's kind of

1014
00:31:27,120 --> 00:31:27,600
channel

1015
00:31:27,600 --> 00:31:29,760
channel based interfaces to all the the

1016
00:31:29,760 --> 00:31:31,360
servers

1017
00:31:31,360 --> 00:31:33,120
so you know we have this function

1018
00:31:33,120 --> 00:31:34,399
scheduled it takes a

1019
00:31:34,399 --> 00:31:36,720
fixed list of servers has a number of

1020
00:31:36,720 --> 00:31:37,679
tasks to run

1021
00:31:37,679 --> 00:31:39,840
and it has just this abstracted function

1022
00:31:39,840 --> 00:31:41,760
call that you you call

1023
00:31:41,760 --> 00:31:44,159
to run the task on a specific server you

1024
00:31:44,159 --> 00:31:45,440
can imagine it was you know doing the

1025
00:31:45,440 --> 00:31:48,159
rpcs underneath

1026
00:31:48,159 --> 00:31:49,600
so we're going to need some way to keep

1027
00:31:49,600 --> 00:31:51,440
track of which servers are available

1028
00:31:51,440 --> 00:31:54,000
to execute new tasks and so one option

1029
00:31:54,000 --> 00:31:55,519
is to use our own stack or queue

1030
00:31:55,519 --> 00:31:56,640
implementation

1031
00:31:56,640 --> 00:31:58,640
but another option is to use a channel

1032
00:31:58,640 --> 00:31:59,919
because it's a good

1033
00:31:59,919 --> 00:32:02,399
synchronized queue and so we can send

1034
00:32:02,399 --> 00:32:03,519
into the channel

1035
00:32:03,519 --> 00:32:05,519
to add to the queue and receive from it

1036
00:32:05,519 --> 00:32:07,200
to pop something off

1037
00:32:07,200 --> 00:32:09,279
and in this case we'll make the queue be

1038
00:32:09,279 --> 00:32:10,640
a queue of servers

1039
00:32:10,640 --> 00:32:12,720
and we'll start off it's a queue of idle

1040
00:32:12,720 --> 00:32:14,000
servers servers that aren't doing any

1041
00:32:14,000 --> 00:32:15,679
work for us right now

1042
00:32:15,679 --> 00:32:17,279
and we'll start off by just initializing

1043
00:32:17,279 --> 00:32:19,360
it by sending all the known servers into

1044
00:32:19,360 --> 00:32:21,760
the idle list

1045
00:32:21,760 --> 00:32:23,519
and then we can loop over the tasks and

1046
00:32:23,519 --> 00:32:25,519
for every task we kick off a go routine

1047
00:32:25,519 --> 00:32:27,440
and its job is to pull a server off the

1048
00:32:27,440 --> 00:32:28,559
idle list

1049
00:32:28,559 --> 00:32:30,399
run the task and then put the server

1050
00:32:30,399 --> 00:32:32,720
back on

1051
00:32:32,720 --> 00:32:35,200
and this loop body is another example of

1052
00:32:35,200 --> 00:32:36,880
the earlier hint to use guaranteeing

1053
00:32:36,880 --> 00:32:38,159
select independent things run

1054
00:32:38,159 --> 00:32:39,120
independently

1055
00:32:39,120 --> 00:32:41,039
because each task is running as a

1056
00:32:41,039 --> 00:32:42,559
separate concern they're all running in

1057
00:32:42,559 --> 00:32:44,880
parallel

1058
00:32:44,880 --> 00:32:46,399
unfortunately there are two problems

1059
00:32:46,399 --> 00:32:48,000
with this program

1060
00:32:48,000 --> 00:32:50,240
the first one is that the closure that's

1061
00:32:50,240 --> 00:32:51,840
running as a new go routine refers to

1062
00:32:51,840 --> 00:32:53,440
the loop iteration variable which is

1063
00:32:53,440 --> 00:32:54,320
task

1064
00:32:54,320 --> 00:32:55,760
and so by the time the go routine starts

1065
00:32:55,760 --> 00:32:57,279
exiting you know the loop has probably

1066
00:32:57,279 --> 00:32:59,120
continued and done at task plus plus and

1067
00:32:59,120 --> 00:33:00,480
so it's actually getting the wrong value

1068
00:33:00,480 --> 00:33:02,399
of task

1069
00:33:02,399 --> 00:33:04,720
you've probably seen this by now um and

1070
00:33:04,720 --> 00:33:06,240
of course the best way to to

1071
00:33:06,240 --> 00:33:08,640
catch this is to run the race detector

1072
00:33:08,640 --> 00:33:10,240
and at google we even encourage teams to

1073
00:33:10,240 --> 00:33:11,919
set up canary servers that

1074
00:33:11,919 --> 00:33:13,840
run the race detector and split off

1075
00:33:13,840 --> 00:33:15,440
something like you know 0.1 percent of

1076
00:33:15,440 --> 00:33:16,640
their traffic to it

1077
00:33:16,640 --> 00:33:18,960
just to catch um you know races that

1078
00:33:18,960 --> 00:33:20,720
might be in the production system

1079
00:33:20,720 --> 00:33:22,080
and you know finding a bug with a race

1080
00:33:22,080 --> 00:33:24,320
detector is is way better than having to

1081
00:33:24,320 --> 00:33:27,760
debug some you know corruption later

1082
00:33:27,760 --> 00:33:30,000
so there are two ways to fix this race

1083
00:33:30,000 --> 00:33:30,799
the first way

1084
00:33:30,799 --> 00:33:32,240
is to give the closure an explicit

1085
00:33:32,240 --> 00:33:34,159
parameter and pass it in

1086
00:33:34,159 --> 00:33:37,279
and the go statement requires a function

1087
00:33:37,279 --> 00:33:39,279
call specifically for this reason

1088
00:33:39,279 --> 00:33:41,600
so that you can set specific arguments

1089
00:33:41,600 --> 00:33:42,880
that get evaluated

1090
00:33:42,880 --> 00:33:44,240
in the context of the original go

1091
00:33:44,240 --> 00:33:46,240
routine and then get copied to the new

1092
00:33:46,240 --> 00:33:47,519
go routine

1093
00:33:47,519 --> 00:33:49,120
and so in this case we can declare a new

1094
00:33:49,120 --> 00:33:51,120
argument task two we can pass

1095
00:33:51,120 --> 00:33:53,360
task to it and then inside the go

1096
00:33:53,360 --> 00:33:54,480
routine task 2

1097
00:33:54,480 --> 00:33:56,640
is a completely different copy of of

1098
00:33:56,640 --> 00:33:58,080
task

1099
00:33:58,080 --> 00:33:59,840
and i only named it task 2 to make it

1100
00:33:59,840 --> 00:34:01,440
easier to talk about

1101
00:34:01,440 --> 00:34:03,120
but of course there's a bug here and the

1102
00:34:03,120 --> 00:34:04,480
bug is that

1103
00:34:04,480 --> 00:34:06,559
i forgot to update task inside the

1104
00:34:06,559 --> 00:34:08,399
function to refer to task two instead of

1105
00:34:08,399 --> 00:34:09,200
task

1106
00:34:09,200 --> 00:34:12,000
and so we basically never do that um

1107
00:34:12,000 --> 00:34:13,440
what we do instead

1108
00:34:13,440 --> 00:34:16,320
is we just give it the same name so that

1109
00:34:16,320 --> 00:34:17,520
it's impossible now

1110
00:34:17,520 --> 00:34:19,040
for the code inside the go regime to

1111
00:34:19,040 --> 00:34:22,399
refer to the wrong copy of task

1112
00:34:22,399 --> 00:34:24,159
um that was the first way to fix the

1113
00:34:24,159 --> 00:34:25,760
race there's a second way which is you

1114
00:34:25,760 --> 00:34:27,200
know sort of cryptic the first time you

1115
00:34:27,200 --> 00:34:29,520
see it but it amounts to the same thing

1116
00:34:29,520 --> 00:34:31,440
and that is that you just make a copy of

1117
00:34:31,440 --> 00:34:32,560
the the variable

1118
00:34:32,560 --> 00:34:36,320
inside the loop body so every time

1119
00:34:36,320 --> 00:34:38,320
a colon equals happens that creates a

1120
00:34:38,320 --> 00:34:40,399
new variable so in the for loop in the

1121
00:34:40,399 --> 00:34:42,000
outer for loop there's a colon equals at

1122
00:34:42,000 --> 00:34:42,800
the beginning

1123
00:34:42,800 --> 00:34:44,399
and there's not one the rest of the loop

1124
00:34:44,399 --> 00:34:46,079
so that's all just one variable for the

1125
00:34:46,079 --> 00:34:47,119
entire loop

1126
00:34:47,119 --> 00:34:48,879
whereas if we put a colon equals inside

1127
00:34:48,879 --> 00:34:50,879
the body every time we run an iteration

1128
00:34:50,879 --> 00:34:52,960
of the loop that's a different variable

1129
00:34:52,960 --> 00:34:55,040
so if the guard if the go function

1130
00:34:55,040 --> 00:34:57,119
closure captures that variable

1131
00:34:57,119 --> 00:34:59,599
those will all be distinct so we can do

1132
00:34:59,599 --> 00:35:01,200
the same thing we do task two and this

1133
00:35:01,200 --> 00:35:03,359
time i remember to update the body

1134
00:35:03,359 --> 00:35:05,280
but you know just like before it's too

1135
00:35:05,280 --> 00:35:07,040
easy to forget to update the body

1136
00:35:07,040 --> 00:35:08,720
and so typically you write task colon

1137
00:35:08,720 --> 00:35:10,480
equals task which looks kind of magical

1138
00:35:10,480 --> 00:35:12,000
the first time you see it but but that's

1139
00:35:12,000 --> 00:35:14,160
what it's for

1140
00:35:14,160 --> 00:35:16,079
all right so i said there were two bugs

1141
00:35:16,079 --> 00:35:18,000
in the program the first one was this

1142
00:35:18,000 --> 00:35:19,760
race on task

1143
00:35:19,760 --> 00:35:22,800
and the second one is that uh we didn't

1144
00:35:22,800 --> 00:35:23,760
actually

1145
00:35:23,760 --> 00:35:25,520
do anything after we kicked off all the

1146
00:35:25,520 --> 00:35:26,800
tasks we're not waiting for them to be

1147
00:35:26,800 --> 00:35:28,480
done

1148
00:35:28,480 --> 00:35:31,200
um and and in particular uh we're

1149
00:35:31,200 --> 00:35:33,040
kicking them off way too fast

1150
00:35:33,040 --> 00:35:35,040
because you know if there's like a

1151
00:35:35,040 --> 00:35:36,160
million tasks you're going to kick off a

1152
00:35:36,160 --> 00:35:37,520
million guard teams and they're all just

1153
00:35:37,520 --> 00:35:39,040
going to sit waiting for one of the five

1154
00:35:39,040 --> 00:35:39,599
servers

1155
00:35:39,599 --> 00:35:41,760
which is kind of inefficient and so what

1156
00:35:41,760 --> 00:35:42,720
we can do

1157
00:35:42,720 --> 00:35:45,599
is we can pull the fetching of the the

1158
00:35:45,599 --> 00:35:46,800
next idle server up

1159
00:35:46,800 --> 00:35:50,320
out of the go routine and we pull it up

1160
00:35:50,320 --> 00:35:51,520
out of the go routine

1161
00:35:51,520 --> 00:35:53,440
now we'll only kick off a go routine

1162
00:35:53,440 --> 00:35:56,160
when there is a next server to use

1163
00:35:56,160 --> 00:35:58,240
and then we can kick it off and and you

1164
00:35:58,240 --> 00:36:00,160
know use that server and put it back

1165
00:36:00,160 --> 00:36:01,680
and the using the server and put it back

1166
00:36:01,680 --> 00:36:03,440
runs concurrently but

1167
00:36:03,440 --> 00:36:05,119
doing the the fetch of the idle server

1168
00:36:05,119 --> 00:36:06,720
inside the loop slows things down so

1169
00:36:06,720 --> 00:36:07,119
that

1170
00:36:07,119 --> 00:36:09,280
there's only ever now number of servers

1171
00:36:09,280 --> 00:36:10,880
go routines running instead of number of

1172
00:36:10,880 --> 00:36:12,320
tasks

1173
00:36:12,320 --> 00:36:14,079
and that receive is essentially creating

1174
00:36:14,079 --> 00:36:16,160
some back pressure to slow down the loop

1175
00:36:16,160 --> 00:36:19,040
so it doesn't get too far ahead and then

1176
00:36:19,040 --> 00:36:20,560
i mentioned we have to wait for the task

1177
00:36:20,560 --> 00:36:21,920
to finish

1178
00:36:21,920 --> 00:36:23,520
and so we can do that by just at the end

1179
00:36:23,520 --> 00:36:25,839
of the loop uh going over the the list

1180
00:36:25,839 --> 00:36:27,280
again and pulling all the servers out

1181
00:36:27,280 --> 00:36:28,400
and we've pulled you know the right

1182
00:36:28,400 --> 00:36:30,240
number of servers out of the idle list

1183
00:36:30,240 --> 00:36:32,240
that means they're all done and so

1184
00:36:32,240 --> 00:36:33,359
that's that's the

1185
00:36:33,359 --> 00:36:36,720
full program now to me the most

1186
00:36:36,720 --> 00:36:37,920
important part of this

1187
00:36:37,920 --> 00:36:39,359
is that you still get to write a for

1188
00:36:39,359 --> 00:36:41,760
loop to iterate over the tasks

1189
00:36:41,760 --> 00:36:42,960
there's lots of other languages where

1190
00:36:42,960 --> 00:36:44,240
you have to do this with state machines

1191
00:36:44,240 --> 00:36:46,160
or some sort of callbacks

1192
00:36:46,160 --> 00:36:48,160
and you don't get the luxury of encoding

1193
00:36:48,160 --> 00:36:49,680
this in the control flow

1194
00:36:49,680 --> 00:36:51,920
um and so this is a you know much

1195
00:36:51,920 --> 00:36:53,520
cleaner way where you can just you know

1196
00:36:53,520 --> 00:36:55,280
use a regular loop

1197
00:36:55,280 --> 00:36:57,040
but there are some some changes we could

1198
00:36:57,040 --> 00:36:58,560
make some improvements

1199
00:36:58,560 --> 00:37:01,760
and so one improvement is to notice that

1200
00:37:01,760 --> 00:37:03,520
there's only one go routine that makes

1201
00:37:03,520 --> 00:37:05,040
requests of a server at a particular

1202
00:37:05,040 --> 00:37:05,760
time

1203
00:37:05,760 --> 00:37:07,440
so instead of having one go routine per

1204
00:37:07,440 --> 00:37:09,520
task maybe we should have one go routine

1205
00:37:09,520 --> 00:37:10,960
per server

1206
00:37:10,960 --> 00:37:12,400
because there are probably going to be

1207
00:37:12,400 --> 00:37:14,400
fewer servers than tasks

1208
00:37:14,400 --> 00:37:16,079
and to do that we have to change from

1209
00:37:16,079 --> 00:37:18,160
having a channel of idle servers to a

1210
00:37:18,160 --> 00:37:18,960
channel of

1211
00:37:18,960 --> 00:37:21,200
you know yet to be done tasks and so

1212
00:37:21,200 --> 00:37:23,920
we've renamed the idle channel to work

1213
00:37:23,920 --> 00:37:26,240
and then we also need a done channel to

1214
00:37:26,240 --> 00:37:27,280
count um

1215
00:37:27,280 --> 00:37:29,599
you know how many uh tasks are done so

1216
00:37:29,599 --> 00:37:30,880
that we know when we're completely

1217
00:37:30,880 --> 00:37:32,160
finished

1218
00:37:32,160 --> 00:37:34,320
and so here there's a new function run

1219
00:37:34,320 --> 00:37:36,079
tasks and that's going to be the per

1220
00:37:36,079 --> 00:37:38,480
server function and we kick off one of

1221
00:37:38,480 --> 00:37:40,320
them for each server

1222
00:37:40,320 --> 00:37:42,160
and run tasks his job is just to loop

1223
00:37:42,160 --> 00:37:43,760
over the work channel

1224
00:37:43,760 --> 00:37:45,599
run the tasks and when the server is

1225
00:37:45,599 --> 00:37:48,320
done we send true to done

1226
00:37:48,320 --> 00:37:50,160
and the you know the server tells us

1227
00:37:50,160 --> 00:37:52,000
that you know it's done

1228
00:37:52,000 --> 00:37:53,839
and the server exits when the work

1229
00:37:53,839 --> 00:37:55,280
channel gets closed that's what makes

1230
00:37:55,280 --> 00:37:56,079
that for loop

1231
00:37:56,079 --> 00:37:59,200
actually stop so then

1232
00:37:59,200 --> 00:38:00,880
you know having kicked off the servers

1233
00:38:00,880 --> 00:38:02,480
we can then just sit there in a loop

1234
00:38:02,480 --> 00:38:05,920
and send each task to the work channel

1235
00:38:05,920 --> 00:38:07,040
close the work channel and say hey

1236
00:38:07,040 --> 00:38:08,160
there's no more work coming all the

1237
00:38:08,160 --> 00:38:09,520
servers you should finish and then and

1238
00:38:09,520 --> 00:38:10,400
then exit

1239
00:38:10,400 --> 00:38:11,680
and then wait for all the servers to

1240
00:38:11,680 --> 00:38:15,349
tell us that they're done

1241
00:38:15,359 --> 00:38:17,200
so in the lab there were a couple

1242
00:38:17,200 --> 00:38:18,640
complications one was that

1243
00:38:18,640 --> 00:38:20,000
you know you might get new servers at

1244
00:38:20,000 --> 00:38:22,480
any given time um and so we could change

1245
00:38:22,480 --> 00:38:24,320
that by saying the servers come in on a

1246
00:38:24,320 --> 00:38:27,270
channel of strings

1247
00:38:27,280 --> 00:38:28,880
and and that actually fits pretty well

1248
00:38:28,880 --> 00:38:30,480
into the current structure where

1249
00:38:30,480 --> 00:38:32,160
you know when you get a new server you

1250
00:38:32,160 --> 00:38:34,480
just um kick off a new uh

1251
00:38:34,480 --> 00:38:36,400
run tasks go routine and so the only

1252
00:38:36,400 --> 00:38:37,760
thing we have to change here is to put

1253
00:38:37,760 --> 00:38:38,640
that loop

1254
00:38:38,640 --> 00:38:40,400
into its own go routine so that while

1255
00:38:40,400 --> 00:38:42,160
we're sending tasks to servers we can

1256
00:38:42,160 --> 00:38:44,000
still accept new servers and kick off

1257
00:38:44,000 --> 00:38:47,200
the helper go routines

1258
00:38:47,200 --> 00:38:48,400
but now we have this problem that we

1259
00:38:48,400 --> 00:38:49,839
don't really have a good way to tell

1260
00:38:49,839 --> 00:38:51,680
when all the servers are done because we

1261
00:38:51,680 --> 00:38:52,960
don't know how many servers there

1262
00:38:52,960 --> 00:38:56,000
are and so we could try to like

1263
00:38:56,000 --> 00:38:58,079
maintain that number as servers come in

1264
00:38:58,079 --> 00:38:59,520
but it's a little tricky

1265
00:38:59,520 --> 00:39:01,440
and instead we can count the number of

1266
00:39:01,440 --> 00:39:02,880
tasks that have finished

1267
00:39:02,880 --> 00:39:05,040
so we just move the done sending true to

1268
00:39:05,040 --> 00:39:06,560
done up a line

1269
00:39:06,560 --> 00:39:08,320
so that instead of doing it per server

1270
00:39:08,320 --> 00:39:09,920
we now do it per task

1271
00:39:09,920 --> 00:39:11,359
and then at the end of the loop or at

1272
00:39:11,359 --> 00:39:12,560
the end of the function we just have to

1273
00:39:12,560 --> 00:39:14,160
wait for the right number of tasks to be

1274
00:39:14,160 --> 00:39:15,520
done

1275
00:39:15,520 --> 00:39:19,359
and so so now again we sort of know uh

1276
00:39:19,359 --> 00:39:21,760
why these are gonna the finish um

1277
00:39:21,760 --> 00:39:23,520
there's actually a deadlock still

1278
00:39:23,520 --> 00:39:25,280
and that is that if the the number of

1279
00:39:25,280 --> 00:39:27,599
tasks is um

1280
00:39:27,599 --> 00:39:30,000
is too big actually i think always you

1281
00:39:30,000 --> 00:39:31,040
you'll get a deadlock

1282
00:39:31,040 --> 00:39:32,720
and if you run this you know you get

1283
00:39:32,720 --> 00:39:34,320
this nice thing where the dirt it tells

1284
00:39:34,320 --> 00:39:35,760
you like hey your routines are stuck and

1285
00:39:35,760 --> 00:39:36,800
the problem is

1286
00:39:36,800 --> 00:39:39,440
that you know we have this run task uh

1287
00:39:39,440 --> 00:39:40,640
server loop

1288
00:39:40,640 --> 00:39:42,000
and the server loop is trying to say hey

1289
00:39:42,000 --> 00:39:44,000
i'm done and you're trying to say hey

1290
00:39:44,000 --> 00:39:45,440
like here's some more work so if you

1291
00:39:45,440 --> 00:39:47,119
have more than one task you'll run into

1292
00:39:47,119 --> 00:39:48,800
this deadlock

1293
00:39:48,800 --> 00:39:50,560
where you know you're trying to send the

1294
00:39:50,560 --> 00:39:51,920
next task to a server

1295
00:39:51,920 --> 00:39:54,320
i guess that is more task than servers

1296
00:39:54,320 --> 00:39:55,599
you're trying to send the next task to a

1297
00:39:55,599 --> 00:39:56,880
server and all the servers are trying to

1298
00:39:56,880 --> 00:39:58,720
say hey i'm done with the previous task

1299
00:39:58,720 --> 00:40:00,160
but you're not there to receive from the

1300
00:40:00,160 --> 00:40:01,839
done channel

1301
00:40:01,839 --> 00:40:04,400
and so again you know it's really nice

1302
00:40:04,400 --> 00:40:04,880
that the

1303
00:40:04,880 --> 00:40:06,400
the guardians just hang around and wait

1304
00:40:06,400 --> 00:40:08,319
for you to look at them and we can fix

1305
00:40:08,319 --> 00:40:09,680
this

1306
00:40:09,680 --> 00:40:12,800
one way to fix this would be to add a

1307
00:40:12,800 --> 00:40:14,160
separate loop that actually does a

1308
00:40:14,160 --> 00:40:14,720
select

1309
00:40:14,720 --> 00:40:17,280
that either sends some work or accounts

1310
00:40:17,280 --> 00:40:19,359
for some of the work being done

1311
00:40:19,359 --> 00:40:22,720
that's fine but a cleaner way to do this

1312
00:40:22,720 --> 00:40:25,200
is to take the the work sending loop the

1313
00:40:25,200 --> 00:40:27,280
task sending loop and put it in its own

1314
00:40:27,280 --> 00:40:28,160
go routine

1315
00:40:28,160 --> 00:40:30,079
so now it's running independently of the

1316
00:40:30,079 --> 00:40:32,240
counting loop and the counting loop

1317
00:40:32,240 --> 00:40:35,599
can can run and you know unblock servers

1318
00:40:35,599 --> 00:40:37,119
that are done with certain tasks while

1319
00:40:37,119 --> 00:40:41,349
other tasks are still being sent

1320
00:40:41,359 --> 00:40:44,000
but the simplest possible fix for this

1321
00:40:44,000 --> 00:40:45,599
is to just make the work channel big

1322
00:40:45,599 --> 00:40:46,240
enough

1323
00:40:46,240 --> 00:40:49,040
that you're never gonna run out of space

1324
00:40:49,040 --> 00:40:50,880
because we might decide that you know

1325
00:40:50,880 --> 00:40:52,800
having a go routine per task is you know

1326
00:40:52,800 --> 00:40:54,880
a couple kilobytes per task

1327
00:40:54,880 --> 00:40:56,720
but you know an extra inch in the

1328
00:40:56,720 --> 00:40:58,079
channel is eight bytes

1329
00:40:58,079 --> 00:40:59,599
so probably you can spend eight bytes

1330
00:40:59,599 --> 00:41:01,200
per task

1331
00:41:01,200 --> 00:41:03,040
and so if you can you just make the work

1332
00:41:03,040 --> 00:41:04,720
channel big enough that you know that

1333
00:41:04,720 --> 00:41:05,839
all the sends on work

1334
00:41:05,839 --> 00:41:07,599
are going to never block and you'll

1335
00:41:07,599 --> 00:41:10,079
always get down to the the counting loop

1336
00:41:10,079 --> 00:41:13,119
at the end pretty quickly and so

1337
00:41:13,119 --> 00:41:15,280
doing that actually sets us up pretty

1338
00:41:15,280 --> 00:41:16,720
well for the other wrinkle in the lab

1339
00:41:16,720 --> 00:41:17,520
which is that

1340
00:41:17,520 --> 00:41:19,440
sometimes calls can time out and here

1341
00:41:19,440 --> 00:41:20,800
i've modeled it by

1342
00:41:20,800 --> 00:41:22,400
the call returning a false so just say

1343
00:41:22,400 --> 00:41:24,480
hey it didn't work

1344
00:41:24,480 --> 00:41:27,440
um and so you know in run task it's

1345
00:41:27,440 --> 00:41:30,400
really easy to say like if

1346
00:41:30,400 --> 00:41:32,640
it's really easy to say like if the call

1347
00:41:32,640 --> 00:41:34,400
uh fails

1348
00:41:34,400 --> 00:41:36,640
then or sorry if the call succeeds then

1349
00:41:36,640 --> 00:41:38,400
you're done but if it fails just put the

1350
00:41:38,400 --> 00:41:40,160
task back on the work list

1351
00:41:40,160 --> 00:41:42,240
and because it's a queue not a stack

1352
00:41:42,240 --> 00:41:43,680
putting it back on the work list is very

1353
00:41:43,680 --> 00:41:46,160
likely to hand it to some other server

1354
00:41:46,160 --> 00:41:48,960
um and so that will you know probably

1355
00:41:48,960 --> 00:41:49,680
succeed

1356
00:41:49,680 --> 00:41:50,880
because it's some other server i mean

1357
00:41:50,880 --> 00:41:52,960
this is all kind of hypothetical but

1358
00:41:52,960 --> 00:41:56,240
um uh it's a really you know it fits

1359
00:41:56,240 --> 00:41:57,680
really well into the structure that

1360
00:41:57,680 --> 00:42:00,630
we've created

1361
00:42:00,640 --> 00:42:02,720
all right and the final change is that

1362
00:42:02,720 --> 00:42:03,920
because the server guarantees are

1363
00:42:03,920 --> 00:42:05,119
sending on work

1364
00:42:05,119 --> 00:42:07,599
we do have to uh wait to close it until

1365
00:42:07,599 --> 00:42:09,440
we know that they're done sending

1366
00:42:09,440 --> 00:42:11,680
and uh because again you can't close you

1367
00:42:11,680 --> 00:42:14,160
know before they finish sending

1368
00:42:14,160 --> 00:42:16,079
and so we just have to move the close

1369
00:42:16,079 --> 00:42:17,839
until after we've counted that all the

1370
00:42:17,839 --> 00:42:19,599
tasks are done

1371
00:42:19,599 --> 00:42:21,200
um and you know sometimes we get to this

1372
00:42:21,200 --> 00:42:23,119
point and people ask like why can't you

1373
00:42:23,119 --> 00:42:23,520
just

1374
00:42:23,520 --> 00:42:25,440
kill go routines like why not just be

1375
00:42:25,440 --> 00:42:27,040
able to say look hey kill all the server

1376
00:42:27,040 --> 00:42:28,240
guardians at this point we know that

1377
00:42:28,240 --> 00:42:29,760
they're not needed anymore

1378
00:42:29,760 --> 00:42:31,119
and the answer is that you know the go

1379
00:42:31,119 --> 00:42:32,880
routine has state and it's interacting

1380
00:42:32,880 --> 00:42:34,319
with the rest of the program and if it

1381
00:42:34,319 --> 00:42:36,079
all of a sudden just stops

1382
00:42:36,079 --> 00:42:38,000
it's sort of like it hung right and

1383
00:42:38,000 --> 00:42:39,520
maybe it was holding a lock

1384
00:42:39,520 --> 00:42:40,800
maybe it was in the middle of some sort

1385
00:42:40,800 --> 00:42:42,160
of communication with some other guru

1386
00:42:42,160 --> 00:42:43,359
team that was kind of expecting an

1387
00:42:43,359 --> 00:42:46,480
answer so we need to find some way to

1388
00:42:46,480 --> 00:42:47,680
tear them down more gracefully and

1389
00:42:47,680 --> 00:42:49,359
that's by telling them explicitly hey

1390
00:42:49,359 --> 00:42:49,760
you know

1391
00:42:49,760 --> 00:42:51,200
you're done you can you can go away and

1392
00:42:51,200 --> 00:42:52,880
then they can clean up however

1393
00:42:52,880 --> 00:42:57,430
they need to clean up

1394
00:42:57,440 --> 00:42:59,040
um you know speaking of cleaning up

1395
00:42:59,040 --> 00:43:00,240
there's there's actually one more thing

1396
00:43:00,240 --> 00:43:01,760
we have to do which is to shut down the

1397
00:43:01,760 --> 00:43:03,280
loop that's that's watching for new

1398
00:43:03,280 --> 00:43:04,160
servers

1399
00:43:04,160 --> 00:43:05,839
and so we do have to put a select in

1400
00:43:05,839 --> 00:43:07,920
here where

1401
00:43:07,920 --> 00:43:10,000
uh you know the the thing that's waiting

1402
00:43:10,000 --> 00:43:11,520
for new servers on the server channel we

1403
00:43:11,520 --> 00:43:12,000
have to

1404
00:43:12,000 --> 00:43:14,000
tell it okay we're done just like stop

1405
00:43:14,000 --> 00:43:15,280
watching for new servers because all the

1406
00:43:15,280 --> 00:43:16,880
servers are gone

1407
00:43:16,880 --> 00:43:19,520
um and we could make this the caller's

1408
00:43:19,520 --> 00:43:21,200
problem but but this is actually fairly

1409
00:43:21,200 --> 00:43:24,150
easy to do

1410
00:43:24,160 --> 00:43:26,720
all right so um pattern number three

1411
00:43:26,720 --> 00:43:28,800
which is a a client for a replicated

1412
00:43:28,800 --> 00:43:29,520
server

1413
00:43:29,520 --> 00:43:32,960
of service so here's the interface that

1414
00:43:32,960 --> 00:43:34,319
we want to implement we have some

1415
00:43:34,319 --> 00:43:35,440
service

1416
00:43:35,440 --> 00:43:38,079
that we want that is replicated for

1417
00:43:38,079 --> 00:43:39,280
reliability

1418
00:43:39,280 --> 00:43:40,960
and it's okay for a client to talk to

1419
00:43:40,960 --> 00:43:42,800
any one of these servers

1420
00:43:42,800 --> 00:43:45,839
and so the the replicated client is

1421
00:43:45,839 --> 00:43:48,480
given a list of servers the uh the

1422
00:43:48,480 --> 00:43:50,800
arguments to init is a list of servers

1423
00:43:50,800 --> 00:43:53,200
and a function that lets you call one of

1424
00:43:53,200 --> 00:43:55,119
the servers with a particular argument

1425
00:43:55,119 --> 00:43:57,200
set and get a reply

1426
00:43:57,200 --> 00:44:00,079
and then being given that during init

1427
00:44:00,079 --> 00:44:02,640
the replicated client then provides

1428
00:44:02,640 --> 00:44:05,280
a call method that doesn't tell you what

1429
00:44:05,280 --> 00:44:07,119
server it's going to use it just finds a

1430
00:44:07,119 --> 00:44:08,480
good server to use

1431
00:44:08,480 --> 00:44:10,079
and it keeps the same keeps using the

1432
00:44:10,079 --> 00:44:12,000
same server for as long as it can until

1433
00:44:12,000 --> 00:44:15,119
it finds out that that server is no good

1434
00:44:15,119 --> 00:44:17,119
so in this situation there's almost no

1435
00:44:17,119 --> 00:44:19,119
shared state that you need to isolate

1436
00:44:19,119 --> 00:44:20,640
and so like the only state that persists

1437
00:44:20,640 --> 00:44:22,079
from one call to the next is what server

1438
00:44:22,079 --> 00:44:23,520
did i use last time because i'm going to

1439
00:44:23,520 --> 00:44:25,440
try to use that again

1440
00:44:25,440 --> 00:44:27,359
so in this case that's totally fine for

1441
00:44:27,359 --> 00:44:29,119
a mutex i'm just going to leave it there

1442
00:44:29,119 --> 00:44:31,280
it's always okay to use mutex if that's

1443
00:44:31,280 --> 00:44:33,760
the cleanest way to write the code

1444
00:44:33,760 --> 00:44:34,880
you know some people get the wrong

1445
00:44:34,880 --> 00:44:36,240
impression from how much we talk about

1446
00:44:36,240 --> 00:44:37,760
channels but it's always okay to use a

1447
00:44:37,760 --> 00:44:40,800
mutex if that's all you need

1448
00:44:40,800 --> 00:44:42,800
so now we need to implement this

1449
00:44:42,800 --> 00:44:44,880
replicated call method whose job is to

1450
00:44:44,880 --> 00:44:47,760
try sending to lots of different servers

1451
00:44:47,760 --> 00:44:49,359
right but but first to try the

1452
00:44:49,359 --> 00:44:52,000
the original server so so what does it

1453
00:44:52,000 --> 00:44:52,720
mean if

1454
00:44:52,720 --> 00:44:55,680
you know the try fails well there's like

1455
00:44:55,680 --> 00:44:56,319
no

1456
00:44:56,319 --> 00:44:58,319
clear way for it to fail above it just

1457
00:44:58,319 --> 00:45:00,000
always returns a reply and so the only

1458
00:45:00,000 --> 00:45:01,599
way it can fail is if it's taking too

1459
00:45:01,599 --> 00:45:02,160
long

1460
00:45:02,160 --> 00:45:03,839
so we'll assume that if it takes too

1461
00:45:03,839 --> 00:45:05,920
long that means it failed

1462
00:45:05,920 --> 00:45:08,000
so in order to deal with timeouts we

1463
00:45:08,000 --> 00:45:08,960
have to run that

1464
00:45:08,960 --> 00:45:10,240
that code in the background in a

1465
00:45:10,240 --> 00:45:12,160
different go routine so we can do

1466
00:45:12,160 --> 00:45:14,079
something like this

1467
00:45:14,079 --> 00:45:16,839
um where we set a timeout we create a

1468
00:45:16,839 --> 00:45:18,000
timer

1469
00:45:18,000 --> 00:45:19,760
and then we use the go routine to send

1470
00:45:19,760 --> 00:45:21,920
in the background and then at the end we

1471
00:45:21,920 --> 00:45:23,839
wait and either we get the timeout

1472
00:45:23,839 --> 00:45:25,920
or we get the actual reply if we get the

1473
00:45:25,920 --> 00:45:26,880
actual reply

1474
00:45:26,880 --> 00:45:29,440
we return it if we get the timeout we

1475
00:45:29,440 --> 00:45:30,560
have to do something we'll have to

1476
00:45:30,560 --> 00:45:32,240
figure out what to do

1477
00:45:32,240 --> 00:45:34,880
um it's worth pointing out that you have

1478
00:45:34,880 --> 00:45:35,440
to

1479
00:45:35,440 --> 00:45:37,920
call tdot stop because otherwise the

1480
00:45:37,920 --> 00:45:39,839
timer sits in a timer queue that you

1481
00:45:39,839 --> 00:45:41,680
know it's going to go off in one second

1482
00:45:41,680 --> 00:45:42,960
and so you know if this call took a

1483
00:45:42,960 --> 00:45:44,480
millisecond and you have this timer

1484
00:45:44,480 --> 00:45:45,599
that's going to sit there for the next

1485
00:45:45,599 --> 00:45:46,079
second

1486
00:45:46,079 --> 00:45:47,760
and then you do this in a loop and you

1487
00:45:47,760 --> 00:45:49,359
get a thousand timers sitting in that

1488
00:45:49,359 --> 00:45:51,599
that um that queue before they start

1489
00:45:51,599 --> 00:45:52,880
actually you know um

1490
00:45:52,880 --> 00:45:55,680
disappearing and so this is kind of a

1491
00:45:55,680 --> 00:45:56,800
wart in the api

1492
00:45:56,800 --> 00:45:58,400
but it's been there forever and we've

1493
00:45:58,400 --> 00:46:00,640
never fixed it um

1494
00:46:00,640 --> 00:46:02,079
and and so you just have to remember to

1495
00:46:02,079 --> 00:46:04,160
call stop

1496
00:46:04,160 --> 00:46:05,599
uh and then you know now we have to

1497
00:46:05,599 --> 00:46:07,119
figure out what do we do in the case of

1498
00:46:07,119 --> 00:46:08,720
the timeout

1499
00:46:08,720 --> 00:46:10,160
and so in the case of the timeout we're

1500
00:46:10,160 --> 00:46:11,839
going to need to try a different server

1501
00:46:11,839 --> 00:46:14,880
so we'll write a loop and we'll start

1502
00:46:14,880 --> 00:46:18,880
at um the id that id0 it says

1503
00:46:18,880 --> 00:46:20,720
and you know if a reply comes in that's

1504
00:46:20,720 --> 00:46:22,560
great and otherwise we'll reset the

1505
00:46:22,560 --> 00:46:24,560
timeout and go around the loop again

1506
00:46:24,560 --> 00:46:26,880
and try sending to a different server

1507
00:46:26,880 --> 00:46:28,240
and notice

1508
00:46:28,240 --> 00:46:30,240
there's only one done channel in this

1509
00:46:30,240 --> 00:46:31,680
program and so

1510
00:46:31,680 --> 00:46:33,200
you know on the third iteration of the

1511
00:46:33,200 --> 00:46:35,040
loop we might be waiting

1512
00:46:35,040 --> 00:46:36,720
and then finally the first server gives

1513
00:46:36,720 --> 00:46:38,560
us a reply that's totally fine we'll

1514
00:46:38,560 --> 00:46:41,040
take that reply that's great

1515
00:46:41,040 --> 00:46:44,960
um and so then we'll stop and return it

1516
00:46:44,960 --> 00:46:46,480
and but if we get all the way through

1517
00:46:46,480 --> 00:46:47,760
the loop it means that we've sent the

1518
00:46:47,760 --> 00:46:49,520
request to every single server

1519
00:46:49,520 --> 00:46:51,359
in which case there's no more timeouts

1520
00:46:51,359 --> 00:46:52,800
we just have to wait for one of them to

1521
00:46:52,800 --> 00:46:53,599
come back

1522
00:46:53,599 --> 00:46:55,599
and so that's the the plain receive and

1523
00:46:55,599 --> 00:46:58,160
the return at the end

1524
00:46:58,160 --> 00:47:00,240
and then it's important to notice that

1525
00:47:00,240 --> 00:47:01,520
the done channel

1526
00:47:01,520 --> 00:47:04,079
is buffered now so that if you know

1527
00:47:04,079 --> 00:47:05,200
you've sent the result to three

1528
00:47:05,200 --> 00:47:06,160
different servers

1529
00:47:06,160 --> 00:47:07,920
you're going to take the first reply and

1530
00:47:07,920 --> 00:47:10,000
return but the others are going to want

1531
00:47:10,000 --> 00:47:11,920
to send responses too

1532
00:47:11,920 --> 00:47:13,200
and we don't want those go routines to

1533
00:47:13,200 --> 00:47:14,640
just sit around forever trying to send

1534
00:47:14,640 --> 00:47:16,319
to a channel that we're not reading from

1535
00:47:16,319 --> 00:47:17,760
so we make the buffer big enough that

1536
00:47:17,760 --> 00:47:19,520
they can send into the buffer and then

1537
00:47:19,520 --> 00:47:20,240
go away

1538
00:47:20,240 --> 00:47:22,839
and the channel just gets garbage

1539
00:47:22,839 --> 00:47:27,910
collected

1540
00:47:27,920 --> 00:47:29,599
that says like why can't the timer just

1541
00:47:29,599 --> 00:47:30,960
be garbage collected when nobody's

1542
00:47:30,960 --> 00:47:32,640
referencing it instead of having to to

1543
00:47:32,640 --> 00:47:34,000
wait when it goes off when you said that

1544
00:47:34,000 --> 00:47:34,880
you have multiple

1545
00:47:34,880 --> 00:47:36,240
waiting if it goes off in one

1546
00:47:36,240 --> 00:47:37,920
millisecond yeah the the problem is the

1547
00:47:37,920 --> 00:47:38,400
timer

1548
00:47:38,400 --> 00:47:41,200
is referenced by the the run time it's

1549
00:47:41,200 --> 00:47:43,440
in the list of active timers

1550
00:47:43,440 --> 00:47:45,040
and so calling stop takes it out of the

1551
00:47:45,040 --> 00:47:46,800
list of active timers

1552
00:47:46,800 --> 00:47:48,960
and and so like that's arguably kind of

1553
00:47:48,960 --> 00:47:49,920
a wart in that

1554
00:47:49,920 --> 00:47:51,920
like in the specific case of a timer

1555
00:47:51,920 --> 00:47:53,680
that's like

1556
00:47:53,680 --> 00:47:55,119
only going to ever get used in this

1557
00:47:55,119 --> 00:47:56,640
channel way like we could have special

1558
00:47:56,640 --> 00:47:57,920
case that by like

1559
00:47:57,920 --> 00:47:59,520
having the channel because inside the

1560
00:47:59,520 --> 00:48:01,680
timer is this t.c channel right

1561
00:48:01,680 --> 00:48:03,200
so we could have had like a different

1562
00:48:03,200 --> 00:48:04,880
kind of channel implementation

1563
00:48:04,880 --> 00:48:06,559
that inside had a bit that said hey i'm

1564
00:48:06,559 --> 00:48:08,000
a timer channel right

1565
00:48:08,000 --> 00:48:10,640
and and and then like the select on it

1566
00:48:10,640 --> 00:48:12,400
would like know to just wait

1567
00:48:12,400 --> 00:48:13,920
but if you just let go of it it would

1568
00:48:13,920 --> 00:48:16,000
just disappear we've kind of like

1569
00:48:16,000 --> 00:48:17,440
thought about doing that for a while but

1570
00:48:17,440 --> 00:48:18,559
we never did and

1571
00:48:18,559 --> 00:48:20,720
so this is like the state of the world

1572
00:48:20,720 --> 00:48:22,160
um but but you know the garbage

1573
00:48:22,160 --> 00:48:24,079
collector can't distinguish between

1574
00:48:24,079 --> 00:48:25,760
you know the reference inside the

1575
00:48:25,760 --> 00:48:26,960
runtime and the reference and the rest

1576
00:48:26,960 --> 00:48:28,960
of the program it's all just references

1577
00:48:28,960 --> 00:48:31,440
and so until we like special case that

1578
00:48:31,440 --> 00:48:33,200
channel in some way like we we can't

1579
00:48:33,200 --> 00:48:37,589
actually get rid of that

1580
00:48:37,599 --> 00:48:40,480
thank you sure so um so then the only

1581
00:48:40,480 --> 00:48:42,079
thing we have left is to

1582
00:48:42,079 --> 00:48:43,839
have this preference where we try to use

1583
00:48:43,839 --> 00:48:46,240
the same um id that we did the previous

1584
00:48:46,240 --> 00:48:47,280
time

1585
00:48:47,280 --> 00:48:50,480
and so to do that preference um

1586
00:48:50,480 --> 00:48:52,319
we you know had the server id coming

1587
00:48:52,319 --> 00:48:53,680
back in the reply anyway

1588
00:48:53,680 --> 00:48:56,880
in the result channel and so you know we

1589
00:48:56,880 --> 00:48:57,760
do the same sort of

1590
00:48:57,760 --> 00:48:59,839
loop but we loop over an offset from the

1591
00:48:59,839 --> 00:49:01,359
actual id we're going to use which is

1592
00:49:01,359 --> 00:49:02,000
the pre

1593
00:49:02,000 --> 00:49:04,000
the preferred one and then when we get

1594
00:49:04,000 --> 00:49:05,040
an answer

1595
00:49:05,040 --> 00:49:07,119
we uh set the preferred one to where we

1596
00:49:07,119 --> 00:49:09,359
got the answer from and then we reply

1597
00:49:09,359 --> 00:49:10,880
and you'll notice that i used a go to

1598
00:49:10,880 --> 00:49:12,800
statement that's okay if you need to go

1599
00:49:12,800 --> 00:49:13,839
to it's fine

1600
00:49:13,839 --> 00:49:16,160
um it's not sort of there's no zealotry

1601
00:49:16,160 --> 00:49:18,000
here

1602
00:49:18,000 --> 00:49:21,119
all right so uh the fourth one and then

1603
00:49:21,119 --> 00:49:22,880
we'll we'll do some questions

1604
00:49:22,880 --> 00:49:26,480
um is a protocol multiplexer and this is

1605
00:49:26,480 --> 00:49:28,960
kind of the logic of a core of any rpc

1606
00:49:28,960 --> 00:49:29,680
system

1607
00:49:29,680 --> 00:49:31,440
and and this comes up a lot i feel like

1608
00:49:31,440 --> 00:49:33,040
i wrote a lot of these in grad school

1609
00:49:33,040 --> 00:49:35,680
and sort of years after that

1610
00:49:35,680 --> 00:49:38,079
and so the basic api of a protocol

1611
00:49:38,079 --> 00:49:38,880
multiplexer

1612
00:49:38,880 --> 00:49:40,960
is that it sits in from some service

1613
00:49:40,960 --> 00:49:42,400
which we're going to pass to the init

1614
00:49:42,400 --> 00:49:43,520
method

1615
00:49:43,520 --> 00:49:44,960
and then having been initialized with a

1616
00:49:44,960 --> 00:49:47,359
service you can call

1617
00:49:47,359 --> 00:49:49,359
and you can call call and give it a

1618
00:49:49,359 --> 00:49:51,599
message a request message and then it'll

1619
00:49:51,599 --> 00:49:53,119
you know give you back the reply message

1620
00:49:53,119 --> 00:49:54,000
at some point

1621
00:49:54,000 --> 00:49:55,760
and the things it needs from the service

1622
00:49:55,760 --> 00:49:57,599
to do multiflexing

1623
00:49:57,599 --> 00:49:59,440
is that given a message it has to be

1624
00:49:59,440 --> 00:50:01,200
able to pull out the tag that uniquely

1625
00:50:01,200 --> 00:50:02,880
identifies the message

1626
00:50:02,880 --> 00:50:04,800
and and will identify the the reply

1627
00:50:04,800 --> 00:50:06,160
because it will come back in with a

1628
00:50:06,160 --> 00:50:08,000
matching tag and then it needs to be

1629
00:50:08,000 --> 00:50:09,520
able to send a message out

1630
00:50:09,520 --> 00:50:11,599
and to receive you know a message but

1631
00:50:11,599 --> 00:50:13,040
the send and receive

1632
00:50:13,040 --> 00:50:14,800
um are there arbitrary messages that are

1633
00:50:14,800 --> 00:50:16,480
not matched

1634
00:50:16,480 --> 00:50:18,559
it's the multiplexer's job to actually

1635
00:50:18,559 --> 00:50:21,030
match them

1636
00:50:21,040 --> 00:50:23,599
so um to start with we'll have a go

1637
00:50:23,599 --> 00:50:25,839
routine that's in charge of calling send

1638
00:50:25,839 --> 00:50:27,200
and another group team that's in charge

1639
00:50:27,200 --> 00:50:29,040
of calling receive both in just a simple

1640
00:50:29,040 --> 00:50:29,920
loop

1641
00:50:29,920 --> 00:50:31,440
and so to initialize the service we'll

1642
00:50:31,440 --> 00:50:33,520
set up the structure and then we'll kick

1643
00:50:33,520 --> 00:50:35,680
off the send loop and the receive loop

1644
00:50:35,680 --> 00:50:37,599
and then we also have a map of pending

1645
00:50:37,599 --> 00:50:39,280
requests and the map

1646
00:50:39,280 --> 00:50:42,079
it maps from the tag that we saw the id

1647
00:50:42,079 --> 00:50:43,760
number in the messages to

1648
00:50:43,760 --> 00:50:45,599
a channel where the reply is supposed to

1649
00:50:45,599 --> 00:50:47,839
go

1650
00:50:47,839 --> 00:50:50,000
the send loop is fairly simple you just

1651
00:50:50,000 --> 00:50:51,440
range over the things that need to be

1652
00:50:51,440 --> 00:50:52,640
sent and you send them

1653
00:50:52,640 --> 00:50:53,839
and this just has the effect of

1654
00:50:53,839 --> 00:50:55,680
serializing the calls to send because

1655
00:50:55,680 --> 00:50:57,040
we're not going to force

1656
00:50:57,040 --> 00:50:59,520
the service implementation to you know

1657
00:50:59,520 --> 00:51:00,079
deal with

1658
00:51:00,079 --> 00:51:01,680
us sending you know from multiple

1659
00:51:01,680 --> 00:51:03,440
routines at once we're serializing it so

1660
00:51:03,440 --> 00:51:04,960
that it can just be thinking of

1661
00:51:04,960 --> 00:51:06,839
you know sending one one packet at a

1662
00:51:06,839 --> 00:51:09,119
time

1663
00:51:09,119 --> 00:51:11,440
and then the receive loop uh is a little

1664
00:51:11,440 --> 00:51:13,359
bit more complicated it pulls a receive

1665
00:51:13,359 --> 00:51:14,960
it pulls a reply off the

1666
00:51:14,960 --> 00:51:17,040
the service and again they're serialized

1667
00:51:17,040 --> 00:51:18,960
so we're only reading one at a time

1668
00:51:18,960 --> 00:51:20,839
and then it pulls the tag out of the

1669
00:51:20,839 --> 00:51:23,599
reply and then it says ah i need to find

1670
00:51:23,599 --> 00:51:25,359
the channel to send this to

1671
00:51:25,359 --> 00:51:26,800
uh so it pulls the channel out of the

1672
00:51:26,800 --> 00:51:28,880
pending map it takes it out of the

1673
00:51:28,880 --> 00:51:30,400
pending map so that you know if we

1674
00:51:30,400 --> 00:51:32,079
accidentally get another one we won't

1675
00:51:32,079 --> 00:51:33,520
try to send it

1676
00:51:33,520 --> 00:51:36,880
and then it sends the reply and then to

1677
00:51:36,880 --> 00:51:38,000
do a call

1678
00:51:38,000 --> 00:51:39,680
you just have to set yourself up in the

1679
00:51:39,680 --> 00:51:41,599
map and then hand it to send and wait

1680
00:51:41,599 --> 00:51:42,480
for the reply

1681
00:51:42,480 --> 00:51:45,760
so we start off we get the tag out

1682
00:51:45,760 --> 00:51:48,319
we make our own done channel we insert

1683
00:51:48,319 --> 00:51:48,880
the tag

1684
00:51:48,880 --> 00:51:50,640
into the map after first checking for

1685
00:51:50,640 --> 00:51:52,960
bugs and then

1686
00:51:52,960 --> 00:51:55,520
we send the the argument message to send

1687
00:51:55,520 --> 00:51:56,880
and then we wait for the reply to come

1688
00:51:56,880 --> 00:51:57,680
in undone

1689
00:51:57,680 --> 00:51:59,920
it's very very simple i mean like i used

1690
00:51:59,920 --> 00:52:01,359
to write these sort of things in c and

1691
00:52:01,359 --> 00:52:04,960
it was it was much much worse

1692
00:52:04,960 --> 00:52:06,800
so that was all the patterns that i

1693
00:52:06,800 --> 00:52:08,079
wanted to show

1694
00:52:08,079 --> 00:52:09,839
and um you know i hope that those end up

1695
00:52:09,839 --> 00:52:12,000
being useful for you in whatever future

1696
00:52:12,000 --> 00:52:13,359
program you're writing

1697
00:52:13,359 --> 00:52:15,760
and and i hope that they're you know

1698
00:52:15,760 --> 00:52:18,079
just sort of good ideas even in non-go

1699
00:52:18,079 --> 00:52:19,680
programs but that you know thinking

1700
00:52:19,680 --> 00:52:21,119
about them and go can help you when you

1701
00:52:21,119 --> 00:52:23,040
go to do other things as well

1702
00:52:23,040 --> 00:52:24,960
so i'm gonna put them all back up and

1703
00:52:24,960 --> 00:52:27,200
then um i have some questions that fran

1704
00:52:27,200 --> 00:52:30,319
sent that were you know from all of you

1705
00:52:30,319 --> 00:52:32,240
and um we'll probably have some time for

1706
00:52:32,240 --> 00:52:34,400
uh you know questions from from the chat

1707
00:52:34,400 --> 00:52:35,520
as well

1708
00:52:35,520 --> 00:52:37,599
i have no idea in zoom where the chat

1709
00:52:37,599 --> 00:52:39,040
window is so

1710
00:52:39,040 --> 00:52:40,319
when we get to that people can just

1711
00:52:40,319 --> 00:52:42,720
speak up just

1712
00:52:42,720 --> 00:52:44,319
i don't use zoom on a daily basis

1713
00:52:44,319 --> 00:52:46,079
unfortunately um

1714
00:52:46,079 --> 00:52:48,720
so uh and and normally i know how to use

1715
00:52:48,720 --> 00:52:50,319
zoom like regularly but with with the

1716
00:52:50,319 --> 00:52:51,920
presentation it's like zoom is in this

1717
00:52:51,920 --> 00:52:53,440
minimize thing that doesn't have half

1718
00:52:53,440 --> 00:52:54,880
the things i'm used to

1719
00:52:54,880 --> 00:52:57,359
anyway um someone asked how long ago

1720
00:52:57,359 --> 00:52:57,920
took

1721
00:52:57,920 --> 00:53:00,240
and so far it's been about 13 and a half

1722
00:53:00,240 --> 00:53:01,119
years

1723
00:53:01,119 --> 00:53:03,359
we started discussions in late september

1724
00:53:03,359 --> 00:53:04,559
2007

1725
00:53:04,559 --> 00:53:06,800
i joined full-time in august 2008 when i

1726
00:53:06,800 --> 00:53:08,559
finished at mit

1727
00:53:08,559 --> 00:53:10,400
we did the initial open source launch

1728
00:53:10,400 --> 00:53:12,800
november 2009

1729
00:53:12,800 --> 00:53:14,559
we released go one the sort of first

1730
00:53:14,559 --> 00:53:17,200
stable version in october 2011.

1731
00:53:17,200 --> 00:53:19,359
uh or sorry the plan was october 2011.

1732
00:53:19,359 --> 00:53:22,079
go one itself was march 2012.

1733
00:53:22,079 --> 00:53:23,520
and then we've just been on you know

1734
00:53:23,520 --> 00:53:25,440
it's a regular schedule since then

1735
00:53:25,440 --> 00:53:27,440
the next major change of course is is

1736
00:53:27,440 --> 00:53:28,800
going to be generics

1737
00:53:28,800 --> 00:53:30,720
and um and adding generics and that's

1738
00:53:30,720 --> 00:53:32,720
probably going to be go 118

1739
00:53:32,720 --> 00:53:37,430
which is going to be next in february

1740
00:53:37,440 --> 00:53:38,880
someone asked you know how big a team

1741
00:53:38,880 --> 00:53:41,280
does it take to build a language like go

1742
00:53:41,280 --> 00:53:43,359
and you know for those first two years

1743
00:53:43,359 --> 00:53:45,040
there were just five of us

1744
00:53:45,040 --> 00:53:47,760
and and that was enough to get us to uh

1745
00:53:47,760 --> 00:53:49,280
you know something that we released that

1746
00:53:49,280 --> 00:53:51,599
actually could run in production

1747
00:53:51,599 --> 00:53:54,160
but it was fairly primitive um you know

1748
00:53:54,160 --> 00:53:55,680
it was it was a good prototype it was a

1749
00:53:55,680 --> 00:53:57,119
solid working prototype but

1750
00:53:57,119 --> 00:53:59,680
but it wasn't like what it is today and

1751
00:53:59,680 --> 00:54:01,359
over time we've expanded a fair amount

1752
00:54:01,359 --> 00:54:03,760
now we're up to something like 50 people

1753
00:54:03,760 --> 00:54:05,760
employed directly or employed by google

1754
00:54:05,760 --> 00:54:07,839
to work directly on go

1755
00:54:07,839 --> 00:54:09,440
and then there's tons of open source

1756
00:54:09,440 --> 00:54:11,280
contributors i mean there's literal cast

1757
00:54:11,280 --> 00:54:12,720
of thousands that have helped us over

1758
00:54:12,720 --> 00:54:14,160
the last 13 years

1759
00:54:14,160 --> 00:54:15,599
and there's absolutely no way we could

1760
00:54:15,599 --> 00:54:17,200
have done it even with 50 people

1761
00:54:17,200 --> 00:54:19,440
without all the different contributions

1762
00:54:19,440 --> 00:54:23,589
from the outside

1763
00:54:23,599 --> 00:54:26,640
someone asked about design priorities um

1764
00:54:26,640 --> 00:54:29,920
and and motivations and you know we we

1765
00:54:29,920 --> 00:54:30,640
built it for us

1766
00:54:30,640 --> 00:54:31,839
right the priority was to build

1767
00:54:31,839 --> 00:54:33,839
something that was gonna help google and

1768
00:54:33,839 --> 00:54:35,040
it just turned out that google was like

1769
00:54:35,040 --> 00:54:36,400
a couple years ahead we were just in a

1770
00:54:36,400 --> 00:54:38,000
really lucky spot where google was a

1771
00:54:38,000 --> 00:54:39,200
couple years ahead of the rest of the

1772
00:54:39,200 --> 00:54:40,079
industry

1773
00:54:40,079 --> 00:54:42,400
on having to write distributed systems

1774
00:54:42,400 --> 00:54:43,920
right now everyone using

1775
00:54:43,920 --> 00:54:45,839
cloud software is is writing programs

1776
00:54:45,839 --> 00:54:47,440
that talk to other programs and sending

1777
00:54:47,440 --> 00:54:49,119
messages and you know there's

1778
00:54:49,119 --> 00:54:51,280
hardly any single machine programs

1779
00:54:51,280 --> 00:54:52,480
anymore

1780
00:54:52,480 --> 00:54:55,040
and so you know we sort of locked into

1781
00:54:55,040 --> 00:54:56,240
at some level

1782
00:54:56,240 --> 00:54:58,480
you know building the language that we

1783
00:54:58,480 --> 00:54:59,599
that the rest of the world needed a

1784
00:54:59,599 --> 00:55:01,599
couple years later

1785
00:55:01,599 --> 00:55:03,200
and and then the other thing that that

1786
00:55:03,200 --> 00:55:04,880
was really a priority was making it work

1787
00:55:04,880 --> 00:55:05,200
for

1788
00:55:05,200 --> 00:55:07,599
large numbers of programmers and because

1789
00:55:07,599 --> 00:55:09,119
you know google had a very large number

1790
00:55:09,119 --> 00:55:11,440
of programmers working in one code base

1791
00:55:11,440 --> 00:55:13,280
and and now we have open source where

1792
00:55:13,280 --> 00:55:15,280
you know even if you're a small team

1793
00:55:15,280 --> 00:55:16,640
you're depending on code that's written

1794
00:55:16,640 --> 00:55:18,960
by a ton of other people usually

1795
00:55:18,960 --> 00:55:21,119
and so a lot of the the issues that come

1796
00:55:21,119 --> 00:55:22,880
up with just having many programmers

1797
00:55:22,880 --> 00:55:24,799
still come up in that context

1798
00:55:24,799 --> 00:55:26,319
so those were really the things we were

1799
00:55:26,319 --> 00:55:28,000
trying to solve

1800
00:55:28,000 --> 00:55:30,240
and you know for all of these things we

1801
00:55:30,240 --> 00:55:31,599
we took a long time

1802
00:55:31,599 --> 00:55:33,280
before we were willing to actually

1803
00:55:33,280 --> 00:55:34,799
commit to putting something in the

1804
00:55:34,799 --> 00:55:36,400
language like everyone basically had to

1805
00:55:36,400 --> 00:55:36,880
agree

1806
00:55:36,880 --> 00:55:39,760
in the the core original group and and

1807
00:55:39,760 --> 00:55:41,200
so that meant that

1808
00:55:41,200 --> 00:55:42,799
it took us a while to sort of get the

1809
00:55:42,799 --> 00:55:44,400
pieces exactly the way we wanted them

1810
00:55:44,400 --> 00:55:46,160
but once we got them there they've

1811
00:55:46,160 --> 00:55:48,720
actually been very stable and solid and

1812
00:55:48,720 --> 00:55:50,799
really nice and they work together well

1813
00:55:50,799 --> 00:55:52,079
and and the same thing is kind of

1814
00:55:52,079 --> 00:55:53,680
happening with generics now

1815
00:55:53,680 --> 00:55:56,079
where we actually feel i feel personally

1816
00:55:56,079 --> 00:55:58,079
really good about generics i feel like

1817
00:55:58,079 --> 00:56:00,480
it feels like the rest of go and that

1818
00:56:00,480 --> 00:56:02,079
just wasn't the case for the proposals

1819
00:56:02,079 --> 00:56:02,799
that we had

1820
00:56:02,799 --> 00:56:04,880
you know even a couple years ago much

1821
00:56:04,880 --> 00:56:08,789
less the you know early ones

1822
00:56:08,799 --> 00:56:10,640
uh someone said they they really like

1823
00:56:10,640 --> 00:56:12,720
defer uh which is unique to language and

1824
00:56:12,720 --> 00:56:13,599
and i do too

1825
00:56:13,599 --> 00:56:15,680
thank you um but i wanted to point out

1826
00:56:15,680 --> 00:56:17,680
that you know we we did absolutely

1827
00:56:17,680 --> 00:56:20,240
you know create defer for go but um

1828
00:56:20,240 --> 00:56:21,920
swift has adopted it and i think there's

1829
00:56:21,920 --> 00:56:23,839
a proposal for sipos bus to adopt it as

1830
00:56:23,839 --> 00:56:25,760
well so you know hopefully it kind of

1831
00:56:25,760 --> 00:56:29,109
moves out a little bit

1832
00:56:29,119 --> 00:56:31,760
there was a question about um go and

1833
00:56:31,760 --> 00:56:34,079
using capitalization for exporting

1834
00:56:34,079 --> 00:56:35,839
and which i know is like something that

1835
00:56:35,839 --> 00:56:37,440
uh you know

1836
00:56:37,440 --> 00:56:39,760
sort of is jarring when you first see it

1837
00:56:39,760 --> 00:56:41,040
and and the story behind that is that

1838
00:56:41,040 --> 00:56:41,359
well

1839
00:56:41,359 --> 00:56:43,520
we needed something and we knew that we

1840
00:56:43,520 --> 00:56:44,720
would need something but like at the

1841
00:56:44,720 --> 00:56:45,920
beginning we just said look everything's

1842
00:56:45,920 --> 00:56:47,680
exported everything's publicly visible

1843
00:56:47,680 --> 00:56:50,000
we'll deal with it later and after about

1844
00:56:50,000 --> 00:56:51,440
a year it was like clear that we needed

1845
00:56:51,440 --> 00:56:52,640
some way to

1846
00:56:52,640 --> 00:56:54,400
you know let programmers hide things

1847
00:56:54,400 --> 00:56:55,839
from other programmers

1848
00:56:55,839 --> 00:56:58,799
and you know c plus plus has this public

1849
00:56:58,799 --> 00:57:00,319
colon and private colon

1850
00:57:00,319 --> 00:57:02,559
and in a large struct it's actually

1851
00:57:02,559 --> 00:57:03,760
really annoying that like

1852
00:57:03,760 --> 00:57:04,799
you're looking you're in the you're

1853
00:57:04,799 --> 00:57:06,480
looking at definitions and you have to

1854
00:57:06,480 --> 00:57:08,079
scroll backwards and try to find where

1855
00:57:08,079 --> 00:57:09,599
the like most recent public colon or

1856
00:57:09,599 --> 00:57:10,960
private colon was

1857
00:57:10,960 --> 00:57:12,720
and if it's really big it can be hard to

1858
00:57:12,720 --> 00:57:14,319
find one and so it's like hard to tell

1859
00:57:14,319 --> 00:57:15,599
whether a particular definition is

1860
00:57:15,599 --> 00:57:17,920
public or private and then in java of

1861
00:57:17,920 --> 00:57:19,359
course it's at the beginning of every

1862
00:57:19,359 --> 00:57:20,720
single field

1863
00:57:20,720 --> 00:57:22,480
and that seemed kind of excessive too

1864
00:57:22,480 --> 00:57:24,799
it's just too much typing

1865
00:57:24,799 --> 00:57:26,240
and so we looked around some more and

1866
00:57:26,240 --> 00:57:27,920
and someone pointed out to us that well

1867
00:57:27,920 --> 00:57:29,599
python has this convention where you put

1868
00:57:29,599 --> 00:57:31,280
an underscore in front to make something

1869
00:57:31,280 --> 00:57:32,240
hidden

1870
00:57:32,240 --> 00:57:34,559
and that seemed interesting but you

1871
00:57:34,559 --> 00:57:35,760
probably don't want the default to be

1872
00:57:35,760 --> 00:57:36,480
not hidden

1873
00:57:36,480 --> 00:57:39,200
you want the default to be hidden um and

1874
00:57:39,200 --> 00:57:40,480
then we thought about well we could put

1875
00:57:40,480 --> 00:57:42,720
like a plus in front of names

1876
00:57:42,720 --> 00:57:46,000
um and then someone suggested well like

1877
00:57:46,000 --> 00:57:46,559
what about

1878
00:57:46,559 --> 00:57:48,559
uppercase could be exported and it

1879
00:57:48,559 --> 00:57:50,880
seemed like a dumb terrible idea

1880
00:57:50,880 --> 00:57:53,760
it really did um but as you think about

1881
00:57:53,760 --> 00:57:54,240
it like

1882
00:57:54,240 --> 00:57:56,400
i really didn't like this idea um and i

1883
00:57:56,400 --> 00:57:58,640
have like very clear memory of sitting

1884
00:57:58,640 --> 00:58:00,640
of like the room and what i was staring

1885
00:58:00,640 --> 00:58:02,319
at as we discussed this

1886
00:58:02,319 --> 00:58:04,160
uh but i had no logical argument against

1887
00:58:04,160 --> 00:58:06,240
it and it turned out it was fantastic

1888
00:58:06,240 --> 00:58:08,720
it was like it seemed bad it just like

1889
00:58:08,720 --> 00:58:09,760
aesthetically

1890
00:58:09,760 --> 00:58:11,839
but it is one of my favorite things now

1891
00:58:11,839 --> 00:58:13,760
about go that when you look at a use of

1892
00:58:13,760 --> 00:58:14,240
something

1893
00:58:14,240 --> 00:58:16,480
you can see immediately you get that bit

1894
00:58:16,480 --> 00:58:18,319
of is this something that other people

1895
00:58:18,319 --> 00:58:19,760
can access or not

1896
00:58:19,760 --> 00:58:21,599
at every use because if you know you see

1897
00:58:21,599 --> 00:58:23,119
code calling a function to do

1898
00:58:23,119 --> 00:58:24,480
you know whatever it is that it does you

1899
00:58:24,480 --> 00:58:26,240
think oh wow like

1900
00:58:26,240 --> 00:58:28,319
can other people do that and and you

1901
00:58:28,319 --> 00:58:29,680
know your brain sort of takes care of

1902
00:58:29,680 --> 00:58:30,720
that but now i go to c

1903
00:58:30,720 --> 00:58:33,359
plus and i see calls like that and i get

1904
00:58:33,359 --> 00:58:34,720
really worried i'm like wait is that is

1905
00:58:34,720 --> 00:58:37,280
that something other classes can get at

1906
00:58:37,280 --> 00:58:39,359
um and having that bid actually turns

1907
00:58:39,359 --> 00:58:40,960
out to be really useful for for reading

1908
00:58:40,960 --> 00:58:42,960
code

1909
00:58:42,960 --> 00:58:44,559
a couple people asked about generics if

1910
00:58:44,559 --> 00:58:46,480
you don't know we have an active

1911
00:58:46,480 --> 00:58:48,160
proposal for generics we're actively

1912
00:58:48,160 --> 00:58:49,599
working on implementing it

1913
00:58:49,599 --> 00:58:52,160
we hope that the the release later in

1914
00:58:52,160 --> 00:58:52,720
the year

1915
00:58:52,720 --> 00:58:54,000
uh towards the end of the year will

1916
00:58:54,000 --> 00:58:56,079
actually have you know a full version of

1917
00:58:56,079 --> 00:58:57,599
generics that you can you can actually

1918
00:58:57,599 --> 00:58:58,400
use

1919
00:58:58,400 --> 00:59:00,559
the the um that'll be like a preview

1920
00:59:00,559 --> 00:59:02,720
release the real release that we hope it

1921
00:59:02,720 --> 00:59:03,359
will be in

1922
00:59:03,359 --> 00:59:06,000
is go 118 which is february of next year

1923
00:59:06,000 --> 00:59:07,520
so maybe next class

1924
00:59:07,520 --> 00:59:09,119
uh we'll actually get to use generics

1925
00:59:09,119 --> 00:59:10,799
we'll see

1926
00:59:10,799 --> 00:59:12,000
but i'm certainly looking forward to

1927
00:59:12,000 --> 00:59:13,599
having like a generic min and max the

1928
00:59:13,599 --> 00:59:15,280
reason we don't have those is that

1929
00:59:15,280 --> 00:59:16,559
you'd have to pick which type they were

1930
00:59:16,559 --> 00:59:18,319
for or have like a whole suite of them

1931
00:59:18,319 --> 00:59:19,680
and it just seemed silly it seemed like

1932
00:59:19,680 --> 00:59:22,480
we should wait for generics

1933
00:59:22,480 --> 00:59:25,200
um someone asked is there any area of

1934
00:59:25,200 --> 00:59:26,240
programming where go

1935
00:59:26,240 --> 00:59:28,160
may not be the best language but it's

1936
00:59:28,160 --> 00:59:29,280
still used

1937
00:59:29,280 --> 00:59:31,200
and and the answer is like absolutely

1938
00:59:31,200 --> 00:59:32,640
like that happens all the time with

1939
00:59:32,640 --> 00:59:33,839
every language

1940
00:59:33,839 --> 00:59:35,839
um i think go is actually really good

1941
00:59:35,839 --> 00:59:37,200
all around language

1942
00:59:37,200 --> 00:59:39,440
um but you know you might use it for

1943
00:59:39,440 --> 00:59:41,680
something that's not perfect for

1944
00:59:41,680 --> 00:59:43,280
just because the rest of your program is

1945
00:59:43,280 --> 00:59:44,559
written and go and you want to

1946
00:59:44,559 --> 00:59:45,680
interoperate with the rest of the

1947
00:59:45,680 --> 00:59:46,160
program

1948
00:59:46,160 --> 00:59:47,680
so you know there's this website called

1949
00:59:47,680 --> 00:59:49,280
the online encyclopedia of integer

1950
00:59:49,280 --> 00:59:50,160
sequences

1951
00:59:50,160 --> 00:59:51,680
it's a search engine you type in like

1952
00:59:51,680 --> 00:59:53,200
two three five seven eleven and it tells

1953
00:59:53,200 --> 00:59:54,559
you those are the primes

1954
00:59:54,559 --> 00:59:56,559
um and it turns out that the back end

1955
00:59:56,559 --> 00:59:58,400
for that is all written and go

1956
00:59:58,400 --> 01:00:00,480
and if you type in a sequence it doesn't

1957
01:00:00,480 --> 01:00:01,680
know it actually does some pretty

1958
01:00:01,680 --> 01:00:03,280
sophisticated math on the numbers

1959
01:00:03,280 --> 01:00:04,559
all with big numbers and things like

1960
01:00:04,559 --> 01:00:06,480
that and all of that is written in go to

1961
01:00:06,480 --> 01:00:07,119
because

1962
01:00:07,119 --> 01:00:09,040
it was too annoying to shell out to

1963
01:00:09,040 --> 01:00:10,559
maple and mathematica and

1964
01:00:10,559 --> 01:00:12,000
sort of do that cross-language thing

1965
01:00:12,000 --> 01:00:13,359
even though you'd much rather implement

1966
01:00:13,359 --> 01:00:14,640
it in those languages

1967
01:00:14,640 --> 01:00:16,559
so you know you run into those sorts of

1968
01:00:16,559 --> 01:00:20,950
compromises all the time and that's fine

1969
01:00:20,960 --> 01:00:24,480
um someone asked about uh

1970
01:00:24,480 --> 01:00:26,480
you know go is supposed to be simple so

1971
01:00:26,480 --> 01:00:27,920
that's why there's like no generics and

1972
01:00:27,920 --> 01:00:29,280
no sets

1973
01:00:29,280 --> 01:00:30,960
but isn't also for software developers

1974
01:00:30,960 --> 01:00:32,319
and don't software developers need all

1975
01:00:32,319 --> 01:00:33,839
this stuff and you know it's silly to

1976
01:00:33,839 --> 01:00:35,280
reconstruct it

1977
01:00:35,280 --> 01:00:36,960
and i think that's it's true that

1978
01:00:36,960 --> 01:00:38,559
there's someone in tension but but

1979
01:00:38,559 --> 01:00:40,559
simplicity in the sense of leaving

1980
01:00:40,559 --> 01:00:42,799
things out was not ever the goal

1981
01:00:42,799 --> 01:00:45,280
so like for sets you know it just seemed

1982
01:00:45,280 --> 01:00:47,119
like maps are so close to sets you just

1983
01:00:47,119 --> 01:00:47,680
have a

1984
01:00:47,680 --> 01:00:49,680
set a map where the value is empty or a

1985
01:00:49,680 --> 01:00:50,880
boolean

1986
01:00:50,880 --> 01:00:53,520
that's a set and for generics like you

1987
01:00:53,520 --> 01:00:55,440
have to remember that when we started go

1988
01:00:55,440 --> 01:00:58,799
in 2007 java was like just

1989
01:00:58,799 --> 01:01:01,599
finishing a true fiasco of a rollout of

1990
01:01:01,599 --> 01:01:02,720
generics

1991
01:01:02,720 --> 01:01:04,400
and so like we were really scared of

1992
01:01:04,400 --> 01:01:06,240
that we knew that if we just tried to do

1993
01:01:06,240 --> 01:01:06,880
it

1994
01:01:06,880 --> 01:01:09,280
um you know we would get it wrong and we

1995
01:01:09,280 --> 01:01:10,559
knew that we could write a lot of useful

1996
01:01:10,559 --> 01:01:12,000
programs without generics

1997
01:01:12,000 --> 01:01:15,119
and so that was what we did and um and

1998
01:01:15,119 --> 01:01:17,119
we came back to it when you know we felt

1999
01:01:17,119 --> 01:01:17,680
like

2000
01:01:17,680 --> 01:01:19,119
okay we've you know spent enough time

2001
01:01:19,119 --> 01:01:20,640
writing other programs we kind of know a

2002
01:01:20,640 --> 01:01:22,319
lot more about what we need from from

2003
01:01:22,319 --> 01:01:24,079
generics for go

2004
01:01:24,079 --> 01:01:25,839
and and we can take the time to talk to

2005
01:01:25,839 --> 01:01:28,640
real experts and i think that you know

2006
01:01:28,640 --> 01:01:30,079
it would have been nice to have them

2007
01:01:30,079 --> 01:01:31,760
five or ten years ago but we wouldn't

2008
01:01:31,760 --> 01:01:32,400
have had

2009
01:01:32,400 --> 01:01:34,000
the really nice ones that we're going to

2010
01:01:34,000 --> 01:01:35,920
have now so i think it was probably the

2011
01:01:35,920 --> 01:01:39,990
right decision

2012
01:01:40,000 --> 01:01:42,079
um so there was a question about go

2013
01:01:42,079 --> 01:01:43,680
routines and the relation to the plan

2014
01:01:43,680 --> 01:01:45,359
line thread library which which was all

2015
01:01:45,359 --> 01:01:46,880
cooperatively scheduled

2016
01:01:46,880 --> 01:01:48,240
and whether go routines were ever

2017
01:01:48,240 --> 01:01:49,680
properly scheduled and like if that

2018
01:01:49,680 --> 01:01:51,280
caused problems

2019
01:01:51,280 --> 01:01:53,040
and it is absolutely the case that like

2020
01:01:53,040 --> 01:01:54,799
go and and

2021
01:01:54,799 --> 01:01:56,799
the go routine runtime were sort of

2022
01:01:56,799 --> 01:01:58,960
inspired by previous experience on plan

2023
01:01:58,960 --> 01:01:59,680
nine

2024
01:01:59,680 --> 01:02:01,200
there was actually a different language

2025
01:02:01,200 --> 01:02:03,039
called aleph on an early version plan

2026
01:02:03,039 --> 01:02:03,760
nine

2027
01:02:03,760 --> 01:02:06,640
that was compiled it had channels it had

2028
01:02:06,640 --> 01:02:07,440
select

2029
01:02:07,440 --> 01:02:09,760
it had things we called tasks which were

2030
01:02:09,760 --> 01:02:11,039
a little bit like our teens but it

2031
01:02:11,039 --> 01:02:12,480
didn't have a garbage collector and that

2032
01:02:12,480 --> 01:02:14,079
made things really annoying in a lot of

2033
01:02:14,079 --> 01:02:15,039
cases

2034
01:02:15,039 --> 01:02:17,119
and also the way that tasks work they

2035
01:02:17,119 --> 01:02:19,039
were tied to a specific thread so you

2036
01:02:19,039 --> 01:02:19,680
might have

2037
01:02:19,680 --> 01:02:22,079
three tasks in one thread and two tasks

2038
01:02:22,079 --> 01:02:23,520
and another thread

2039
01:02:23,520 --> 01:02:24,880
and in the three tasks in the first

2040
01:02:24,880 --> 01:02:27,520
thread the only one ever ran at a time

2041
01:02:27,520 --> 01:02:29,200
and they could only reschedule during a

2042
01:02:29,200 --> 01:02:30,480
channel operation

2043
01:02:30,480 --> 01:02:32,319
and so you would write code where those

2044
01:02:32,319 --> 01:02:33,680
three tasks were all operating on the

2045
01:02:33,680 --> 01:02:35,119
same data structure

2046
01:02:35,119 --> 01:02:37,039
and you just knew because it was in your

2047
01:02:37,039 --> 01:02:38,720
head when you wrote it

2048
01:02:38,720 --> 01:02:40,400
that you know it was okay for these two

2049
01:02:40,400 --> 01:02:42,240
different tasks to be scribbling over

2050
01:02:42,240 --> 01:02:43,359
the same data structure because they

2051
01:02:43,359 --> 01:02:45,440
could never be running at the same time

2052
01:02:45,440 --> 01:02:46,720
and meanwhile you know in the other

2053
01:02:46,720 --> 01:02:48,079
thread you've got the same situation

2054
01:02:48,079 --> 01:02:49,280
going on with different data and

2055
01:02:49,280 --> 01:02:50,559
different tasks

2056
01:02:50,559 --> 01:02:51,680
and then you come back to the same

2057
01:02:51,680 --> 01:02:52,880
program like six months later and you

2058
01:02:52,880 --> 01:02:54,720
totally forget which tasks could

2059
01:02:54,720 --> 01:02:56,799
write to different pieces of data and

2060
01:02:56,799 --> 01:02:58,480
i'm sure that we had tons of races i

2061
01:02:58,480 --> 01:02:59,359
mean it was just

2062
01:02:59,359 --> 01:03:01,280
it was a nice model for small programs

2063
01:03:01,280 --> 01:03:03,119
and it was a terrible model for for

2064
01:03:03,119 --> 01:03:04,720
programming over a long period of time

2065
01:03:04,720 --> 01:03:06,319
or having a big program that other

2066
01:03:06,319 --> 01:03:07,839
people had to work on

2067
01:03:07,839 --> 01:03:09,440
so so that was never the model for go

2068
01:03:09,440 --> 01:03:11,359
the model for go was always

2069
01:03:11,359 --> 01:03:12,799
it's good to have these lightweight go

2070
01:03:12,799 --> 01:03:14,640
routines but they're gonna all be

2071
01:03:14,640 --> 01:03:16,079
running independently and if they're

2072
01:03:16,079 --> 01:03:17,440
going to share anything they need to use

2073
01:03:17,440 --> 01:03:18,880
locks and they need to use channels to

2074
01:03:18,880 --> 01:03:20,160
commute to communicate

2075
01:03:20,160 --> 01:03:23,440
and coordinate explicitly and and that

2076
01:03:23,440 --> 01:03:25,119
that has definitely scaled a lot better

2077
01:03:25,119 --> 01:03:26,559
than any of the planned line stuff ever

2078
01:03:26,559 --> 01:03:27,440
did

2079
01:03:27,440 --> 01:03:30,319
um you know sometimes people hear that

2080
01:03:30,319 --> 01:03:31,920
go routines are cooperatively scheduled

2081
01:03:31,920 --> 01:03:33,440
and they they think you know something

2082
01:03:33,440 --> 01:03:34,559
more like that

2083
01:03:34,559 --> 01:03:37,839
it's it's true that early on the go

2084
01:03:37,839 --> 01:03:39,520
routines were not as preemptively

2085
01:03:39,520 --> 01:03:41,039
scheduled as you would like

2086
01:03:41,039 --> 01:03:43,200
so in the very very early days the only

2087
01:03:43,200 --> 01:03:44,640
preemption points when you called into

2088
01:03:44,640 --> 01:03:45,839
the run time

2089
01:03:45,839 --> 01:03:47,680
shortly after that the preemption points

2090
01:03:47,680 --> 01:03:50,559
were any time you entered a function

2091
01:03:50,559 --> 01:03:52,400
but if you were in a tight loop for a

2092
01:03:52,400 --> 01:03:54,400
very long time that would never preempt

2093
01:03:54,400 --> 01:03:55,760
and that would cause like garbage

2094
01:03:55,760 --> 01:03:56,880
collector delays because the garbage

2095
01:03:56,880 --> 01:03:57,599
collector would need to

2096
01:03:57,599 --> 01:03:59,280
stop all the go routines and there'd be

2097
01:03:59,280 --> 01:04:00,799
some guaranteeing stuck in a tight loop

2098
01:04:00,799 --> 01:04:02,079
and it would take forever to finish the

2099
01:04:02,079 --> 01:04:03,039
loop

2100
01:04:03,039 --> 01:04:05,119
um and so actually in the last couple

2101
01:04:05,119 --> 01:04:06,880
releases we finally started we figured

2102
01:04:06,880 --> 01:04:07,599
out how to get

2103
01:04:07,599 --> 01:04:10,079
um unix signals to deliver to threads in

2104
01:04:10,079 --> 01:04:11,200
just the right way

2105
01:04:11,200 --> 01:04:12,960
so that and we can have the right

2106
01:04:12,960 --> 01:04:14,720
bookkeeping to actually be able to use

2107
01:04:14,720 --> 01:04:16,559
that as a preemption mechanism

2108
01:04:16,559 --> 01:04:18,960
and and so now things are i think i

2109
01:04:18,960 --> 01:04:20,640
think the preemption delays for garbage

2110
01:04:20,640 --> 01:04:22,240
collection are actually bounded finally

2111
01:04:22,240 --> 01:04:23,920
but but from the start the model has

2112
01:04:23,920 --> 01:04:24,640
been

2113
01:04:24,640 --> 01:04:25,680
that you know they're running

2114
01:04:25,680 --> 01:04:27,520
preemptively and and they don't get

2115
01:04:27,520 --> 01:04:30,960
control over when they get preempted

2116
01:04:30,960 --> 01:04:32,559
uh as a sort of follow-on question

2117
01:04:32,559 --> 01:04:34,240
someone else asked uh you know where

2118
01:04:34,240 --> 01:04:35,599
they can look to in the source tree to

2119
01:04:35,599 --> 01:04:37,200
learn more about guru teams

2120
01:04:37,200 --> 01:04:39,839
and and the go team scheduler and and

2121
01:04:39,839 --> 01:04:41,039
the answer is that you know this is

2122
01:04:41,039 --> 01:04:42,640
basically a little operating system like

2123
01:04:42,640 --> 01:04:44,000
it's a little operating system that sits

2124
01:04:44,000 --> 01:04:44,720
on top of

2125
01:04:44,720 --> 01:04:46,559
the other operating system instead of on

2126
01:04:46,559 --> 01:04:48,000
top of cpus

2127
01:04:48,000 --> 01:04:50,240
um and so the first thing too is like

2128
01:04:50,240 --> 01:04:52,160
take six eight two eight which is like

2129
01:04:52,160 --> 01:04:54,960
there i mean i i worked on 6828 and and

2130
01:04:54,960 --> 01:04:56,000
xv6

2131
01:04:56,000 --> 01:04:57,520
like literally like the year or two

2132
01:04:57,520 --> 01:04:59,200
before i went and did the go run time

2133
01:04:59,200 --> 01:05:00,960
and so like there's a huge amount of 688

2134
01:05:00,960 --> 01:05:02,240
in the go runtime

2135
01:05:02,240 --> 01:05:04,240
um and in the actual go runtime

2136
01:05:04,240 --> 01:05:06,640
directory there's a file called proc.go

2137
01:05:06,640 --> 01:05:08,160
which is you know proc stands for

2138
01:05:08,160 --> 01:05:09,520
process because like that's what it is

2139
01:05:09,520 --> 01:05:09,839
in

2140
01:05:09,839 --> 01:05:12,000
the operating systems um and i would

2141
01:05:12,000 --> 01:05:13,359
start there like that's the file to

2142
01:05:13,359 --> 01:05:14,960
start with and then sort of pull on

2143
01:05:14,960 --> 01:05:18,150
strings

2144
01:05:18,160 --> 01:05:20,079
someone asked about python sort of

2145
01:05:20,079 --> 01:05:21,359
negative indexing

2146
01:05:21,359 --> 01:05:23,680
where you can write x of minus one and

2147
01:05:23,680 --> 01:05:24,720
and that comes up a lot

2148
01:05:24,720 --> 01:05:27,039
especially from python programmers and

2149
01:05:27,039 --> 01:05:28,720
and it seems like a really great idea

2150
01:05:28,720 --> 01:05:30,160
you write these like really nice elegant

2151
01:05:30,160 --> 01:05:31,520
programs where like you want to get the

2152
01:05:31,520 --> 01:05:33,920
last element you just say x minus one

2153
01:05:33,920 --> 01:05:35,599
but the real problem is that like you

2154
01:05:35,599 --> 01:05:37,680
have x of i and you have a loop that's

2155
01:05:37,680 --> 01:05:38,960
like counting down from

2156
01:05:38,960 --> 01:05:41,359
from you know n to zero and you have an

2157
01:05:41,359 --> 01:05:43,280
off by one somewhere and like now x of

2158
01:05:43,280 --> 01:05:44,799
minus one instead of being

2159
01:05:44,799 --> 01:05:47,119
you know x of i when i is minus one

2160
01:05:47,119 --> 01:05:48,559
instead of being an error where you see

2161
01:05:48,559 --> 01:05:50,000
like immediately say hey there's a bug i

2162
01:05:50,000 --> 01:05:50,960
need to find that

2163
01:05:50,960 --> 01:05:52,799
it just like silently grabs the element

2164
01:05:52,799 --> 01:05:54,559
off the other end of the array

2165
01:05:54,559 --> 01:05:56,559
and and that's where you know the sort

2166
01:05:56,559 --> 01:05:57,599
of python

2167
01:05:57,599 --> 01:06:00,640
um you know simplicity you know makes

2168
01:06:00,640 --> 01:06:02,000
things worse

2169
01:06:02,000 --> 01:06:03,280
and so that was why we left it out

2170
01:06:03,280 --> 01:06:04,960
because it was it was gonna hide bugs

2171
01:06:04,960 --> 01:06:06,960
too much we thought

2172
01:06:06,960 --> 01:06:08,799
um you know you could imagine something

2173
01:06:08,799 --> 01:06:10,960
where you say like x of dollar minus one

2174
01:06:10,960 --> 01:06:12,160
or len minus one

2175
01:06:12,160 --> 01:06:14,799
not len of x but just len but you know

2176
01:06:14,799 --> 01:06:16,079
it seemed like too much of a special

2177
01:06:16,079 --> 01:06:17,200
case and it really

2178
01:06:17,200 --> 01:06:20,390
it doesn't come up enough

2179
01:06:20,400 --> 01:06:23,599
um someone asked about uh you know

2180
01:06:23,599 --> 01:06:25,119
what aspect of go was hardest to

2181
01:06:25,119 --> 01:06:26,640
implement

2182
01:06:26,640 --> 01:06:28,480
and honestly like a lot of this is not

2183
01:06:28,480 --> 01:06:29,839
very hard um

2184
01:06:29,839 --> 01:06:31,520
we've done most of this before we'd

2185
01:06:31,520 --> 01:06:33,280
written operating systems and threading

2186
01:06:33,280 --> 01:06:35,280
libraries and channel implementations

2187
01:06:35,280 --> 01:06:36,559
and so like doing all that again was

2188
01:06:36,559 --> 01:06:38,640
fairly straightforward

2189
01:06:38,640 --> 01:06:39,760
the hardest thing was probably the

2190
01:06:39,760 --> 01:06:42,000
garbage collector

2191
01:06:42,000 --> 01:06:43,760
go is unique among garbage collected

2192
01:06:43,760 --> 01:06:45,760
languages in that it gives programmers a

2193
01:06:45,760 --> 01:06:46,000
lot

2194
01:06:46,000 --> 01:06:47,839
more control over memory layout so if

2195
01:06:47,839 --> 01:06:49,039
you want to have a struct with two

2196
01:06:49,039 --> 01:06:49,599
different

2197
01:06:49,599 --> 01:06:51,520
other structs inside it that's just one

2198
01:06:51,520 --> 01:06:52,799
big chunk of memory

2199
01:06:52,799 --> 01:06:54,640
it's not a struct with pointers to two

2200
01:06:54,640 --> 01:06:56,240
other chunks of memory

2201
01:06:56,240 --> 01:06:57,599
and because of that and you can take the

2202
01:06:57,599 --> 01:06:59,200
address of like the second field in the

2203
01:06:59,200 --> 01:07:00,880
struct and pass that around

2204
01:07:00,880 --> 01:07:02,160
and that means the garbage collector has

2205
01:07:02,160 --> 01:07:03,920
to be able to deal with a pointer that

2206
01:07:03,920 --> 01:07:05,359
could point into the middle of an

2207
01:07:05,359 --> 01:07:06,720
allocated object and that's just

2208
01:07:06,720 --> 01:07:08,319
something that java and lisp and other

2209
01:07:08,319 --> 01:07:10,319
things just don't do

2210
01:07:10,319 --> 01:07:12,079
um and so that makes the garbage

2211
01:07:12,079 --> 01:07:14,000
collector a lot more complicated in how

2212
01:07:14,000 --> 01:07:16,079
it maintains its data structures

2213
01:07:16,079 --> 01:07:18,240
and we also knew from the start that you

2214
01:07:18,240 --> 01:07:19,760
really want low latency because if

2215
01:07:19,760 --> 01:07:20,559
you're handling

2216
01:07:20,559 --> 01:07:23,680
network requests uh you can't you know

2217
01:07:23,680 --> 01:07:24,079
just

2218
01:07:24,079 --> 01:07:26,319
pause for 200 milliseconds while and

2219
01:07:26,319 --> 01:07:27,599
block all of those

2220
01:07:27,599 --> 01:07:29,200
in progress requests to do a garbage

2221
01:07:29,200 --> 01:07:30,720
collection it really needs to be

2222
01:07:30,720 --> 01:07:32,880
in you know low latency and not stop

2223
01:07:32,880 --> 01:07:34,640
things and we thought that multicore

2224
01:07:34,640 --> 01:07:35,839
would be a good

2225
01:07:35,839 --> 01:07:37,119
a good opportunity there because we

2226
01:07:37,119 --> 01:07:38,400
could have the garbage collector sort of

2227
01:07:38,400 --> 01:07:39,599
doing one core

2228
01:07:39,599 --> 01:07:41,599
and the go program using the other cores

2229
01:07:41,599 --> 01:07:42,960
and and that might work really well and

2230
01:07:42,960 --> 01:07:43,920
that actually did

2231
01:07:43,920 --> 01:07:45,839
turn out to work really well but it

2232
01:07:45,839 --> 01:07:48,000
required hiring a real expert in garbage

2233
01:07:48,000 --> 01:07:48,880
collection

2234
01:07:48,880 --> 01:07:52,079
to uh like figure out how to do it um

2235
01:07:52,079 --> 01:07:53,200
and make it work

2236
01:07:53,200 --> 01:07:56,400
but but now it's it's really great um i

2237
01:07:56,400 --> 01:07:59,440
i have a quick question yeah you said um

2238
01:07:59,440 --> 01:08:02,160
like if it's struck like it's declared

2239
01:08:02,160 --> 01:08:03,520
inside another stroke

2240
01:08:03,520 --> 01:08:06,160
it actually is all a big chunk of memory

2241
01:08:06,160 --> 01:08:06,720
yeah

2242
01:08:06,720 --> 01:08:08,400
why do why did you implement it like

2243
01:08:08,400 --> 01:08:10,559
that what's the reasoning behind that

2244
01:08:10,559 --> 01:08:12,880
um i well so there's a couple reasons

2245
01:08:12,880 --> 01:08:14,400
one is for a garbage collector right

2246
01:08:14,400 --> 01:08:15,359
it's a service

2247
01:08:15,359 --> 01:08:17,279
and the load on the garbage collector is

2248
01:08:17,279 --> 01:08:18,960
proportional to the number of objects

2249
01:08:18,960 --> 01:08:19,759
you allocate

2250
01:08:19,759 --> 01:08:21,520
and so if you have you know a struct

2251
01:08:21,520 --> 01:08:22,799
with five things in it you can make that

2252
01:08:22,799 --> 01:08:25,120
one allocation that's like a fifth of

2253
01:08:25,120 --> 01:08:26,480
the the load on the garbage collector

2254
01:08:26,480 --> 01:08:27,359
and that turns out to be really

2255
01:08:27,359 --> 01:08:28,400
important

2256
01:08:28,400 --> 01:08:29,359
but the other thing that's really

2257
01:08:29,359 --> 01:08:31,679
important is cache locality

2258
01:08:31,679 --> 01:08:33,520
right like if you have the processor is

2259
01:08:33,520 --> 01:08:34,799
pulling in chunks of memory

2260
01:08:34,799 --> 01:08:36,400
in like you know 64 byte chunks or

2261
01:08:36,400 --> 01:08:37,920
whatever it is and it's much better at

2262
01:08:37,920 --> 01:08:39,520
reading memory that's all together

2263
01:08:39,520 --> 01:08:41,759
than reading memory that's scattered and

2264
01:08:41,759 --> 01:08:42,719
so

2265
01:08:42,719 --> 01:08:44,560
um you know we have a git server at

2266
01:08:44,560 --> 01:08:46,080
google called garrett

2267
01:08:46,080 --> 01:08:47,920
that is written in java and it was just

2268
01:08:47,920 --> 01:08:49,279
starting at the time that

2269
01:08:49,279 --> 01:08:51,600
go was you know just coming out and and

2270
01:08:51,600 --> 01:08:53,279
we we just missed like garrett being

2271
01:08:53,279 --> 01:08:55,600
written and go i think by like a year

2272
01:08:55,600 --> 01:08:57,679
um but we talked to the the guy who had

2273
01:08:57,679 --> 01:08:59,199
written garrett and he said that like

2274
01:08:59,199 --> 01:08:59,920
one of the

2275
01:08:59,920 --> 01:09:02,000
biggest problems in in garrett was like

2276
01:09:02,000 --> 01:09:03,839
you have all these shot one hashes

2277
01:09:03,839 --> 01:09:06,560
and just having the idea of 20 bytes is

2278
01:09:06,560 --> 01:09:08,159
like impossible to have in java you

2279
01:09:08,159 --> 01:09:10,159
can't just have 20 bytes in a struct

2280
01:09:10,159 --> 01:09:12,400
you have to have a pointer to an object

2281
01:09:12,400 --> 01:09:13,199
and the object

2282
01:09:13,199 --> 01:09:15,199
like you know you can't even have 20

2283
01:09:15,199 --> 01:09:16,239
bytes in the object right you have to

2284
01:09:16,239 --> 01:09:17,839
declare like five different ins or

2285
01:09:17,839 --> 01:09:19,920
something like that to get 20 bites

2286
01:09:19,920 --> 01:09:21,679
and there's just like no good way to do

2287
01:09:21,679 --> 01:09:23,520
it and and it's just the overhead of

2288
01:09:23,520 --> 01:09:25,359
just a simple thing like that

2289
01:09:25,359 --> 01:09:28,640
really adds up um and so you know

2290
01:09:28,640 --> 01:09:30,080
we thought giving programmers control

2291
01:09:30,080 --> 01:09:33,590
over memory was really important

2292
01:09:33,600 --> 01:09:36,880
um so another question was

2293
01:09:36,880 --> 01:09:38,719
was about automatic parallelization like

2294
01:09:38,719 --> 01:09:40,080
for loops and things like that

2295
01:09:40,080 --> 01:09:41,600
we don't do anything like that in the

2296
01:09:41,600 --> 01:09:43,679
standard go tool chain there are there

2297
01:09:43,679 --> 01:09:45,600
are go compilers for go front ends for

2298
01:09:45,600 --> 01:09:47,279
gcc and llvm

2299
01:09:47,279 --> 01:09:49,040
and so to the extent that those do those

2300
01:09:49,040 --> 01:09:50,880
kind of loop optimizations in c

2301
01:09:50,880 --> 01:09:52,719
i think you know we get the same from

2302
01:09:52,719 --> 01:09:54,320
the go friends for those

2303
01:09:54,320 --> 01:09:56,000
but it's it's not the kind of

2304
01:09:56,000 --> 01:09:57,840
parallelization that we typically need

2305
01:09:57,840 --> 01:09:58,480
at google

2306
01:09:58,480 --> 01:10:00,880
it's it's more um you know lots of

2307
01:10:00,880 --> 01:10:02,480
servers running different things

2308
01:10:02,480 --> 01:10:04,960
and and so you know that sort of you

2309
01:10:04,960 --> 01:10:06,880
know like the sort of big vector math

2310
01:10:06,880 --> 01:10:08,400
kind of stuff doesn't come up as much so

2311
01:10:08,400 --> 01:10:09,679
it just hasn't been

2312
01:10:09,679 --> 01:10:12,719
that important to us um

2313
01:10:12,719 --> 01:10:14,400
and then the last question i have

2314
01:10:14,400 --> 01:10:16,400
written now is that someone uh

2315
01:10:16,400 --> 01:10:18,080
asked about like how do you decide when

2316
01:10:18,080 --> 01:10:19,600
to acquire release locks and why don't

2317
01:10:19,600 --> 01:10:20,960
you have re-entry locks

2318
01:10:20,960 --> 01:10:22,719
and for that i want to go back a slide

2319
01:10:22,719 --> 01:10:25,199
let me see

2320
01:10:25,199 --> 01:10:28,159
yeah here so like you know during the

2321
01:10:28,159 --> 01:10:30,080
lecture i said things like the lock pro

2322
01:10:30,080 --> 01:10:32,239
like new protects the map or it protects

2323
01:10:32,239 --> 01:10:33,120
the data

2324
01:10:33,120 --> 01:10:34,960
but what we really mean at that point is

2325
01:10:34,960 --> 01:10:36,719
that we're saying that the lock protects

2326
01:10:36,719 --> 01:10:39,199
some collection of invariants that apply

2327
01:10:39,199 --> 01:10:41,199
to the data or that are true of the data

2328
01:10:41,199 --> 01:10:42,640
and the reason that we have the lock is

2329
01:10:42,640 --> 01:10:45,360
to to protect the operations that depend

2330
01:10:45,360 --> 01:10:46,320
on the invariants

2331
01:10:46,320 --> 01:10:47,840
and that sometimes temporarily

2332
01:10:47,840 --> 01:10:49,679
invalidate the invariants from each

2333
01:10:49,679 --> 01:10:50,800
other

2334
01:10:50,800 --> 01:10:52,800
and so when you call lock what you're

2335
01:10:52,800 --> 01:10:53,920
saying is

2336
01:10:53,920 --> 01:10:55,760
i need to make use of the invariance

2337
01:10:55,760 --> 01:10:57,199
that this lock protects

2338
01:10:57,199 --> 01:10:58,400
and when you call unlock what you're

2339
01:10:58,400 --> 01:11:00,400
saying is i don't need them anymore and

2340
01:11:00,400 --> 01:11:00,880
if i

2341
01:11:00,880 --> 01:11:03,120
temporarily invalid invalidated them

2342
01:11:03,120 --> 01:11:04,239
i've put them back

2343
01:11:04,239 --> 01:11:05,840
so that the next person who calls lock

2344
01:11:05,840 --> 01:11:08,880
will see you know correct invariants

2345
01:11:08,880 --> 01:11:10,719
so in the mux you know we want the

2346
01:11:10,719 --> 01:11:12,560
invariant that each registered pending

2347
01:11:12,560 --> 01:11:13,199
channel

2348
01:11:13,199 --> 01:11:16,239
gets at most one reply and so to do that

2349
01:11:16,239 --> 01:11:18,159
when we take don out of the map

2350
01:11:18,159 --> 01:11:20,560
we also delete it from the map before we

2351
01:11:20,560 --> 01:11:21,360
unlock it

2352
01:11:21,360 --> 01:11:22,719
and if there was some separate kind of

2353
01:11:22,719 --> 01:11:24,400
cancel operation that was directly

2354
01:11:24,400 --> 01:11:26,239
manipulating the map as well

2355
01:11:26,239 --> 01:11:28,960
it could lock the it could call lock it

2356
01:11:28,960 --> 01:11:30,400
could take the thing out

2357
01:11:30,400 --> 01:11:32,880
call unlock and then you know if it

2358
01:11:32,880 --> 01:11:34,800
actually found one it would know

2359
01:11:34,800 --> 01:11:36,560
no one is going to send to that anymore

2360
01:11:36,560 --> 01:11:38,239
because i took it out

2361
01:11:38,239 --> 01:11:40,800
whereas if you know we had written this

2362
01:11:40,800 --> 01:11:41,600
code to have

2363
01:11:41,600 --> 01:11:43,840
you know an extra unlock and re-lock

2364
01:11:43,840 --> 01:11:44,800
between the done

2365
01:11:44,800 --> 01:11:47,360
equals pending of tag and the delete

2366
01:11:47,360 --> 01:11:49,120
then you wouldn't have that you know

2367
01:11:49,120 --> 01:11:50,800
protection of the invariants anymore

2368
01:11:50,800 --> 01:11:51,920
because you would have

2369
01:11:51,920 --> 01:11:53,520
put things back you unlocked and

2370
01:11:53,520 --> 01:11:55,360
relocked while the invariants were

2371
01:11:55,360 --> 01:11:56,239
broken

2372
01:11:56,239 --> 01:11:58,560
and so it's really important to you know

2373
01:11:58,560 --> 01:11:59,520
correctness

2374
01:11:59,520 --> 01:12:01,120
to think about locks as protecting

2375
01:12:01,120 --> 01:12:02,800
invariants

2376
01:12:02,800 --> 01:12:05,760
and and so if you have re-entrant locks

2377
01:12:05,760 --> 01:12:06,560
uh

2378
01:12:06,560 --> 01:12:08,320
all that goes out the window without the

2379
01:12:08,320 --> 01:12:10,320
re-entrant lock when you call lock

2380
01:12:10,320 --> 01:12:13,120
on the next line you know okay the lock

2381
01:12:13,120 --> 01:12:14,159
just got acquired

2382
01:12:14,159 --> 01:12:16,320
all the invariants are true if you have

2383
01:12:16,320 --> 01:12:17,280
a re-entrant lock

2384
01:12:17,280 --> 01:12:19,840
all you know is well all the invariants

2385
01:12:19,840 --> 01:12:20,640
were true

2386
01:12:20,640 --> 01:12:22,320
for whoever locked this the first time

2387
01:12:22,320 --> 01:12:23,840
who like might be way up here on my call

2388
01:12:23,840 --> 01:12:24,800
stack

2389
01:12:24,800 --> 01:12:27,280
and and you really know nothing um and

2390
01:12:27,280 --> 01:12:29,040
so that makes it a lot harder to reason

2391
01:12:29,040 --> 01:12:31,440
about like what can you assume

2392
01:12:31,440 --> 01:12:32,880
and and so i think reentrant locks are

2393
01:12:32,880 --> 01:12:34,480
like a really unfortunate part of java's

2394
01:12:34,480 --> 01:12:35,679
legacy

2395
01:12:35,679 --> 01:12:37,440
another big problem with re-engine locks

2396
01:12:37,440 --> 01:12:38,880
is that if you have code

2397
01:12:38,880 --> 01:12:40,880
where you know you call something and it

2398
01:12:40,880 --> 01:12:42,560
is depending on the re-entrant lock

2399
01:12:42,560 --> 01:12:43,679
for you know something where you've

2400
01:12:43,679 --> 01:12:45,840
acquired the lock up above

2401
01:12:45,840 --> 01:12:47,520
and and then at some point you say you

2402
01:12:47,520 --> 01:12:48,960
know what actually i want to like have a

2403
01:12:48,960 --> 01:12:50,880
timeout on this or i want to do it uh

2404
01:12:50,880 --> 01:12:52,320
you know in some other go routine while

2405
01:12:52,320 --> 01:12:53,679
i wait for something else

2406
01:12:53,679 --> 01:12:55,199
when you move that code to a different

2407
01:12:55,199 --> 01:12:57,360
go routine re-entrant always means

2408
01:12:57,360 --> 01:12:59,120
locked on the same stack that's like the

2409
01:12:59,120 --> 01:13:00,719
only plausible thing it could possibly

2410
01:13:00,719 --> 01:13:01,760
mean

2411
01:13:01,760 --> 01:13:03,360
and so if you move the code that was

2412
01:13:03,360 --> 01:13:04,960
doing the re-entrant lock

2413
01:13:04,960 --> 01:13:07,120
onto a different stack then it's going

2414
01:13:07,120 --> 01:13:08,400
to deadlock because it's going to

2415
01:13:08,400 --> 01:13:10,000
that lock is now actually going to real

2416
01:13:10,000 --> 01:13:11,360
lock acquire and it's going to be

2417
01:13:11,360 --> 01:13:13,040
waiting for you to let go of the lock i

2418
01:13:13,040 --> 01:13:14,000
mean you're not going to let go of it

2419
01:13:14,000 --> 01:13:14,880
because you know you think

2420
01:13:14,880 --> 01:13:16,719
that code needs to finish running so

2421
01:13:16,719 --> 01:13:17,760
it's actually like completely

2422
01:13:17,760 --> 01:13:19,520
fundamentally incompatible with

2423
01:13:19,520 --> 01:13:21,199
restructurings where you take code and

2424
01:13:21,199 --> 01:13:22,800
run it in different threads or different

2425
01:13:22,800 --> 01:13:24,000
guarantees

2426
01:13:24,000 --> 01:13:25,679
and so so anyway like my advice there is

2427
01:13:25,679 --> 01:13:26,960
to just you know think about locks as

2428
01:13:26,960 --> 01:13:28,480
protecting invariants

2429
01:13:28,480 --> 01:13:30,320
and then you know just avoid depending

2430
01:13:30,320 --> 01:13:32,960
on reentrant locks it it really just

2431
01:13:32,960 --> 01:13:35,600
doesn't scale well to to real programs

2432
01:13:35,600 --> 01:13:37,360
so i'll put this list back up

2433
01:13:37,360 --> 01:13:38,320
actually you know we have that up long

2434
01:13:38,320 --> 01:13:39,440
enough i can try to figure out how to

2435
01:13:39,440 --> 01:13:40,960
stop presenting

2436
01:13:40,960 --> 01:13:44,830
um and then i can take a few more

2437
01:13:44,840 --> 01:13:47,040
questions

2438
01:13:47,040 --> 01:13:50,640
um i had i had a question yeah um and

2439
01:13:50,640 --> 01:13:53,040
i mean i i think coming from python like

2440
01:13:53,040 --> 01:13:54,080
it's very

2441
01:13:54,080 --> 01:13:56,719
useful right it's very common to use

2442
01:13:56,719 --> 01:13:58,719
like like standard functional operations

2443
01:13:58,719 --> 01:13:59,760
right like map

2444
01:13:59,760 --> 01:14:03,360
yeah um or filter stuff like that like

2445
01:14:03,360 --> 01:14:06,560
um like list comprehension

2446
01:14:06,560 --> 01:14:09,199
and when you know i switched over to go

2447
01:14:09,199 --> 01:14:10,640
and started programming

2448
01:14:10,640 --> 01:14:13,040
it's used i i looked it up and people

2449
01:14:13,040 --> 01:14:14,400
say like you shouldn't do this

2450
01:14:14,400 --> 01:14:16,560
do this with loop right i was wondering

2451
01:14:16,560 --> 01:14:17,679
why

2452
01:14:17,679 --> 01:14:20,159
um well i mean one is that like you

2453
01:14:20,159 --> 01:14:21,280
can't do it the other way so you might

2454
01:14:21,280 --> 01:14:22,800
just look through the way you can do it

2455
01:14:22,800 --> 01:14:25,440
um but uh you know a bigger a bigger

2456
01:14:25,440 --> 01:14:27,440
issue is that

2457
01:14:27,440 --> 01:14:29,679
well there's that was one answer the

2458
01:14:29,679 --> 01:14:31,280
other answer is that

2459
01:14:31,280 --> 01:14:33,679
uh you know if you do it that way you

2460
01:14:33,679 --> 01:14:34,800
actually end up creating a lot of

2461
01:14:34,800 --> 01:14:35,440
garbage

2462
01:14:35,440 --> 01:14:37,199
and if you care about like not putting

2463
01:14:37,199 --> 01:14:38,480
too much load on the garbage collector

2464
01:14:38,480 --> 01:14:39,760
that kind of is another way

2465
01:14:39,760 --> 01:14:43,040
to avoid that you know so if you've got

2466
01:14:43,040 --> 01:14:43,600
like

2467
01:14:43,600 --> 01:14:45,440
a map and then a filter and then another

2468
01:14:45,440 --> 01:14:47,360
map like you can make that one loop over

2469
01:14:47,360 --> 01:14:48,800
the data instead of three loops over the

2470
01:14:48,800 --> 01:14:50,480
data each of which generate a new piece

2471
01:14:50,480 --> 01:14:53,350
of garbage

2472
01:14:53,360 --> 01:14:55,040
but you know now that we have generics

2473
01:14:55,040 --> 01:14:56,960
coming um you'll actually be able to

2474
01:14:56,960 --> 01:14:58,159
write those functions like you couldn't

2475
01:14:58,159 --> 01:14:59,440
actually write what the type signature

2476
01:14:59,440 --> 01:15:00,400
of those functions were

2477
01:15:00,400 --> 01:15:01,840
before and so like you literally

2478
01:15:01,840 --> 01:15:04,000
couldn't write them and python gets away

2479
01:15:04,000 --> 01:15:05,280
with this because there's no no

2480
01:15:05,280 --> 01:15:07,280
you know static types but now we're

2481
01:15:07,280 --> 01:15:08,480
actually going to have a way to do that

2482
01:15:08,480 --> 01:15:10,400
and i totally expect that once generics

2483
01:15:10,400 --> 01:15:12,000
go in there will be a package slices and

2484
01:15:12,000 --> 01:15:13,440
if you import slices you can do

2485
01:15:13,440 --> 01:15:15,760
slices.map and slices.filter

2486
01:15:15,760 --> 01:15:17,760
and like slices.unique or something like

2487
01:15:17,760 --> 01:15:18,880
that and and i think

2488
01:15:18,880 --> 01:15:21,520
those will all happen um and you know if

2489
01:15:21,520 --> 01:15:22,840
if that's the right thing then that's

2490
01:15:22,840 --> 01:15:25,840
great

2491
01:15:25,840 --> 01:15:30,159
thanks sure um

2492
01:15:30,159 --> 01:15:33,040
one of the hints that you had it was

2493
01:15:33,040 --> 01:15:33,520
about

2494
01:15:33,520 --> 01:15:37,199
running go routines that are independent

2495
01:15:37,199 --> 01:15:40,880
like concurrently um and some of the

2496
01:15:40,880 --> 01:15:42,400
examples of the code i

2497
01:15:42,400 --> 01:15:44,960
i think i couldn't understand it seemed

2498
01:15:44,960 --> 01:15:45,840
to me like you can

2499
01:15:45,840 --> 01:15:48,960
just like call the function in the same

2500
01:15:48,960 --> 01:15:49,840
thread

2501
01:15:49,840 --> 01:15:53,120
rather than a different thread and i was

2502
01:15:53,120 --> 01:15:54,640
not sure why you would call it in a

2503
01:15:54,640 --> 01:15:56,239
different thread

2504
01:15:56,239 --> 01:15:59,360
so um usually it's because you want

2505
01:15:59,360 --> 01:16:02,400
them to proceed independently so um so

2506
01:16:02,400 --> 01:16:03,360
in one of the

2507
01:16:03,360 --> 01:16:05,760
one of the examples we had like the

2508
01:16:05,760 --> 01:16:07,280
there was a loop that was sending

2509
01:16:07,280 --> 01:16:10,560
um you know tasks to the work queue

2510
01:16:10,560 --> 01:16:12,560
but there was the servers were running

2511
01:16:12,560 --> 01:16:14,159
in different go routines and reading

2512
01:16:14,159 --> 01:16:15,840
from the work queue and doing work

2513
01:16:15,840 --> 01:16:17,199
but then when they were done they would

2514
01:16:17,199 --> 01:16:19,600
send uh you know hey i'm done now to the

2515
01:16:19,600 --> 01:16:20,719
done channel

2516
01:16:20,719 --> 01:16:23,040
but ascend in go doesn't complete until

2517
01:16:23,040 --> 01:16:24,080
the receive

2518
01:16:24,080 --> 01:16:27,040
actually matches with it and so if the

2519
01:16:27,040 --> 01:16:29,199
thing that's sending on the work queue

2520
01:16:29,199 --> 01:16:30,880
is not going to start receiving from the

2521
01:16:30,880 --> 01:16:32,560
done channel until it's done sending to

2522
01:16:32,560 --> 01:16:33,920
all the work queues

2523
01:16:33,920 --> 01:16:35,679
or sending all the work into all the

2524
01:16:35,679 --> 01:16:37,120
tasks into the work queue

2525
01:16:37,120 --> 01:16:39,360
then now you have a deadlock because the

2526
01:16:39,360 --> 01:16:40,480
the main thread

2527
01:16:40,480 --> 01:16:42,560
the main go routine is trying to send

2528
01:16:42,560 --> 01:16:44,159
new work to the servers

2529
01:16:44,159 --> 01:16:45,679
the servers are not taking new work

2530
01:16:45,679 --> 01:16:47,199
they're trying to tell the main thread

2531
01:16:47,199 --> 01:16:48,159
that they're done

2532
01:16:48,159 --> 01:16:49,280
but the main thread's not going to

2533
01:16:49,280 --> 01:16:51,040
actually start at like reading from the

2534
01:16:51,040 --> 01:16:52,159
done channel

2535
01:16:52,159 --> 01:16:53,679
until it finishes giving out all the

2536
01:16:53,679 --> 01:16:55,360
work and so there's just they're just

2537
01:16:55,360 --> 01:16:56,560
staring at each other waiting for

2538
01:16:56,560 --> 01:16:57,840
different things to happen

2539
01:16:57,840 --> 01:17:00,239
whereas if we take that loop that if we

2540
01:17:00,239 --> 01:17:01,679
just put the little girl routine around

2541
01:17:01,679 --> 01:17:03,360
the loop that's sending the work

2542
01:17:03,360 --> 01:17:05,360
then that can go somewhere else and then

2543
01:17:05,360 --> 01:17:06,800
it can proceed independently and while

2544
01:17:06,800 --> 01:17:07,760
it's stuck

2545
01:17:07,760 --> 01:17:10,000
waiting for the servers to send to um

2546
01:17:10,000 --> 01:17:10,960
take more work

2547
01:17:10,960 --> 01:17:12,960
the servers are stuck waiting for the

2548
01:17:12,960 --> 01:17:14,960
main go routine to you know

2549
01:17:14,960 --> 01:17:17,120
acknowledge that it finished some work

2550
01:17:17,120 --> 01:17:18,640
and now the main goal team actually gets

2551
01:17:18,640 --> 01:17:19,840
down to the loop

2552
01:17:19,840 --> 01:17:21,520
that you know pulls that finishes that

2553
01:17:21,520 --> 01:17:23,199
actually acknowledges that it finished

2554
01:17:23,199 --> 01:17:24,320
the work that reads from the done

2555
01:17:24,320 --> 01:17:25,120
channel

2556
01:17:25,120 --> 01:17:26,960
and so it's just a way to separate out

2557
01:17:26,960 --> 01:17:28,239
you know these are two different things

2558
01:17:28,239 --> 01:17:29,280
that logically

2559
01:17:29,280 --> 01:17:30,960
they didn't have to happen one after the

2560
01:17:30,960 --> 01:17:32,719
other and because they were happening

2561
01:17:32,719 --> 01:17:33,920
one after the other that caused a

2562
01:17:33,920 --> 01:17:35,520
deadlock and by taking one out and

2563
01:17:35,520 --> 01:17:37,679
moving it let it run independently

2564
01:17:37,679 --> 01:17:41,830
um that removes the deadlock

2565
01:17:41,840 --> 01:17:44,880
thank you so much sure could you talk a

2566
01:17:44,880 --> 01:17:46,640
little bit about how ghost race detector

2567
01:17:46,640 --> 01:17:48,159
is implemented

2568
01:17:48,159 --> 01:17:51,360
sure it is the llvm race detector um

2569
01:17:51,360 --> 01:17:53,199
and so that probably doesn't help but

2570
01:17:53,199 --> 01:17:54,800
but it is exactly the thing that

2571
01:17:54,800 --> 01:17:58,159
llvm calls thread sanitizer and um

2572
01:17:58,159 --> 01:17:59,679
and so we actually have a little binary

2573
01:17:59,679 --> 01:18:02,560
blob that uh you know we link against

2574
01:18:02,560 --> 01:18:03,679
because we don't want to depend on all

2575
01:18:03,679 --> 01:18:06,560
of lvm but it's the llvm race detector

2576
01:18:06,560 --> 01:18:08,400
and the way the llvm race sector works

2577
01:18:08,400 --> 01:18:10,159
is that it allocates a ton of

2578
01:18:10,159 --> 01:18:12,239
extra virtual memory and then based on

2579
01:18:12,239 --> 01:18:13,600
the address of

2580
01:18:13,600 --> 01:18:15,840
of the thing being read or written it

2581
01:18:15,840 --> 01:18:16,800
has this other

2582
01:18:16,800 --> 01:18:18,880
you know spot in virtual memory where it

2583
01:18:18,880 --> 01:18:19,840
records

2584
01:18:19,840 --> 01:18:22,080
information about like the last uh

2585
01:18:22,080 --> 01:18:24,000
thread you know it thinks of threads but

2586
01:18:24,000 --> 01:18:25,199
their go routines

2587
01:18:25,199 --> 01:18:27,360
um has with the last thread that did a

2588
01:18:27,360 --> 01:18:28,400
read or a write

2589
01:18:28,400 --> 01:18:30,560
and then also every time a synchronizing

2590
01:18:30,560 --> 01:18:32,000
event happens like you know a

2591
01:18:32,000 --> 01:18:33,600
communication from one go routine to

2592
01:18:33,600 --> 01:18:34,640
another

2593
01:18:34,640 --> 01:18:37,360
uh that counts as establishing a happens

2594
01:18:37,360 --> 01:18:38,960
before edge between two different go

2595
01:18:38,960 --> 01:18:39,760
routines

2596
01:18:39,760 --> 01:18:41,440
and if you ever get something where you

2597
01:18:41,440 --> 01:18:43,840
have a read and a write

2598
01:18:43,840 --> 01:18:46,080
and they're not properly sequenced right

2599
01:18:46,080 --> 01:18:47,600
like so if you have a read and then it

2600
01:18:47,600 --> 01:18:49,120
happens before something in another

2601
01:18:49,120 --> 01:18:50,800
chain which then you know later does the

2602
01:18:50,800 --> 01:18:52,239
right that's fine

2603
01:18:52,239 --> 01:18:53,520
but if you have a read and a write and

2604
01:18:53,520 --> 01:18:55,199
there's no happens before sequence that

2605
01:18:55,199 --> 01:18:56,320
connects them

2606
01:18:56,320 --> 01:18:58,719
then um then that's a race and it

2607
01:18:58,719 --> 01:18:59,679
actually you know

2608
01:18:59,679 --> 01:19:02,480
has some pretty clever ways to you know

2609
01:19:02,480 --> 01:19:04,800
dynamically figure out quickly you know

2610
01:19:04,800 --> 01:19:07,040
did this read happen is there a happens

2611
01:19:07,040 --> 01:19:08,400
before a path between this readings

2612
01:19:08,400 --> 01:19:09,679
right as they happen

2613
01:19:09,679 --> 01:19:11,440
and it slows down the program by like

2614
01:19:11,440 --> 01:19:12,800
maybe 10x

2615
01:19:12,800 --> 01:19:14,800
but you know if you just divert a small

2616
01:19:14,800 --> 01:19:15,840
amount of traffic there

2617
01:19:15,840 --> 01:19:18,000
that's probably fine if it's for testing

2618
01:19:18,000 --> 01:19:19,440
that's also probably fine

2619
01:19:19,440 --> 01:19:20,960
and it's way better than like not

2620
01:19:20,960 --> 01:19:22,480
finding out about the races so it's

2621
01:19:22,480 --> 01:19:23,440
totally worth it

2622
01:19:23,440 --> 01:19:26,480
and honestly 10 or 20 x is is fantastic

2623
01:19:26,480 --> 01:19:28,159
the original thread sanitizer was more

2624
01:19:28,159 --> 01:19:28,880
like

2625
01:19:28,880 --> 01:19:30,719
100 or a thousand x and that was not

2626
01:19:30,719 --> 01:19:32,400
good enough well what's the rate

2627
01:19:32,400 --> 01:19:33,600
detector called

2628
01:19:33,600 --> 01:19:36,239
lrvm uh it's called thread sanitizer but

2629
01:19:36,239 --> 01:19:37,840
it's part of llvm

2630
01:19:37,840 --> 01:19:40,560
which is um the clang c compiler the the

2631
01:19:40,560 --> 01:19:41,120
one that

2632
01:19:41,120 --> 01:19:44,560
um almost everyone uses now

2633
01:19:44,560 --> 01:19:54,630
is is part of the llvm project

2634
01:19:54,640 --> 01:19:56,480
can you talk about slices um and like

2635
01:19:56,480 --> 01:19:58,000
the design choices having them as

2636
01:19:58,000 --> 01:20:00,400
views on a raise which like confused me

2637
01:20:00,400 --> 01:20:01,199
at first

2638
01:20:01,199 --> 01:20:03,280
yeah yeah it is a little confusing at

2639
01:20:03,280 --> 01:20:05,360
first um

2640
01:20:05,360 --> 01:20:06,960
the the main thing is that you want it

2641
01:20:06,960 --> 01:20:08,639
to be efficient to kind of walk through

2642
01:20:08,639 --> 01:20:09,840
an array or to like

2643
01:20:09,840 --> 01:20:11,440
you know if you're in quicksort or merge

2644
01:20:11,440 --> 01:20:12,639
sword or something where you have an

2645
01:20:12,639 --> 01:20:13,600
array of things

2646
01:20:13,600 --> 01:20:14,960
and now you want to say well now sort

2647
01:20:14,960 --> 01:20:16,719
this half and sort the other half

2648
01:20:16,719 --> 01:20:18,480
you want to be able to efficiently say

2649
01:20:18,480 --> 01:20:20,480
like here this is half of the previous

2650
01:20:20,480 --> 01:20:21,199
one like

2651
01:20:21,199 --> 01:20:24,719
you know sort that and so in c the way

2652
01:20:24,719 --> 01:20:26,560
you do that is you just pass in

2653
01:20:26,560 --> 01:20:27,840
you know the pointer to the first

2654
01:20:27,840 --> 01:20:29,600
element and the number of elements

2655
01:20:29,600 --> 01:20:31,679
and that's basically all a slice is and

2656
01:20:31,679 --> 01:20:33,760
then the other pattern that comes up a

2657
01:20:33,760 --> 01:20:34,560
lot when you're

2658
01:20:34,560 --> 01:20:36,080
you know trying to be efficient with

2659
01:20:36,080 --> 01:20:38,560
arrays is you have to grow them

2660
01:20:38,560 --> 01:20:40,480
and and so you don't want to recall

2661
01:20:40,480 --> 01:20:42,320
realic on every single

2662
01:20:42,320 --> 01:20:44,560
new element you want to amortize that

2663
01:20:44,560 --> 01:20:46,800
and so the way you do that

2664
01:20:46,800 --> 01:20:48,719
in in c again is that you have a base

2665
01:20:48,719 --> 01:20:50,080
pointer you have the length that you're

2666
01:20:50,080 --> 01:20:51,280
using right now and you have the length

2667
01:20:51,280 --> 01:20:52,400
that you allocated

2668
01:20:52,400 --> 01:20:54,400
and then to you know add one you you

2669
01:20:54,400 --> 01:20:56,080
check and see if the length is is bigger

2670
01:20:56,080 --> 01:20:57,520
than the amount you allocated if so you

2671
01:20:57,520 --> 01:20:58,880
reallocate it and otherwise you just

2672
01:20:58,880 --> 01:21:00,320
keep bumping it forward

2673
01:21:00,320 --> 01:21:02,320
and and slices are really just an

2674
01:21:02,320 --> 01:21:03,920
encoding of those idioms

2675
01:21:03,920 --> 01:21:05,199
because those are kind of the most

2676
01:21:05,199 --> 01:21:07,199
efficient way to manage the memory

2677
01:21:07,199 --> 01:21:09,360
and so in in any kind of like c plus

2678
01:21:09,360 --> 01:21:10,560
vector or

2679
01:21:10,560 --> 01:21:12,239
um sort of thing like that that's what's

2680
01:21:12,239 --> 01:21:14,000
going on underneath

2681
01:21:14,000 --> 01:21:16,639
but it makes it a lot harder to um like

2682
01:21:16,639 --> 01:21:17,440
the c plus

2683
01:21:17,440 --> 01:21:20,080
vector because of ownership reasons you

2684
01:21:20,080 --> 01:21:21,679
know the vector is tied to the actual

2685
01:21:21,679 --> 01:21:23,360
underlying memory it's a lot harder to

2686
01:21:23,360 --> 01:21:23,679
get

2687
01:21:23,679 --> 01:21:25,920
like a sub vector that's just the view

2688
01:21:25,920 --> 01:21:28,800
onto like the second half for merge sort

2689
01:21:28,800 --> 01:21:30,960
so that's sort of the idea is that it

2690
01:21:30,960 --> 01:21:32,159
just like there are all these patterns

2691
01:21:32,159 --> 01:21:32,480
for

2692
01:21:32,480 --> 01:21:33,840
accessing memory efficiently that came

2693
01:21:33,840 --> 01:21:36,239
from c and we tried to make them fit and

2694
01:21:36,239 --> 01:21:38,400
to go in an idiomatic way

2695
01:21:38,400 --> 01:21:42,400
in a safe way

2696
01:21:42,400 --> 01:21:45,600
can you talk about how you decided to um

2697
01:21:45,600 --> 01:21:47,440
implement the go like remote module

2698
01:21:47,440 --> 01:21:48,960
system where you import directly from a

2699
01:21:48,960 --> 01:21:49,840
url

2700
01:21:49,840 --> 01:21:52,800
versus like yeah um i mean i just didn't

2701
01:21:52,800 --> 01:21:54,480
want to run a service and like like

2702
01:21:54,480 --> 01:21:57,360
you know a lot of the things like ruby

2703
01:21:57,360 --> 01:21:59,840
gems and those like were not as as

2704
01:21:59,840 --> 01:22:02,000
for the front of my mind at the time

2705
01:22:02,000 --> 01:22:03,360
just because they were newer

2706
01:22:03,360 --> 01:22:04,880
but like i had used pearl for a while

2707
01:22:04,880 --> 01:22:07,040
and like cpan and and i just thought it

2708
01:22:07,040 --> 01:22:08,639
was it was insane that like

2709
01:22:08,639 --> 01:22:10,080
everyone was fighting over these short

2710
01:22:10,080 --> 01:22:12,239
names like db you know

2711
01:22:12,239 --> 01:22:13,679
there probably shouldn't be an argument

2712
01:22:13,679 --> 01:22:15,520
over like who gets to make the db

2713
01:22:15,520 --> 01:22:16,480
package

2714
01:22:16,480 --> 01:22:19,199
um and so putting domain names in the

2715
01:22:19,199 --> 01:22:20,239
front seemed like a good way to

2716
01:22:20,239 --> 01:22:21,679
decentralize it

2717
01:22:21,679 --> 01:22:23,040
and and it was also a good way for us

2718
01:22:23,040 --> 01:22:24,800
not to run any server because you know

2719
01:22:24,800 --> 01:22:25,840
we could just say well

2720
01:22:25,840 --> 01:22:27,199
you know we'll recognize the host name

2721
01:22:27,199 --> 01:22:28,880
and then and then go grab it from source

2722
01:22:28,880 --> 01:22:29,840
control

2723
01:22:29,840 --> 01:22:31,760
um from someone else's server and that

2724
01:22:31,760 --> 01:22:33,360
turned out to be a really great idea i

2725
01:22:33,360 --> 01:22:34,239
think

2726
01:22:34,239 --> 01:22:36,000
um because we just we don't have that

2727
01:22:36,000 --> 01:22:37,360
kind of same infrastructure

2728
01:22:37,360 --> 01:22:40,400
that other things depend on like in the

2729
01:22:40,400 --> 01:22:42,080
java world it's actually

2730
01:22:42,080 --> 01:22:43,920
really problematic there are multiple

2731
01:22:43,920 --> 01:22:46,159
there's no sort of standard registry but

2732
01:22:46,159 --> 01:22:47,920
they all use these short names

2733
01:22:47,920 --> 01:22:50,800
and so uh like maven can be configured

2734
01:22:50,800 --> 01:22:52,159
to build from multiple different

2735
01:22:52,159 --> 01:22:53,440
registries

2736
01:22:53,440 --> 01:22:55,199
and you if you're an open source

2737
01:22:55,199 --> 01:22:56,639
software package provider you actually

2738
01:22:56,639 --> 01:22:58,000
have to go around and be sure that you

2739
01:22:58,000 --> 01:22:59,040
upload it to all the different

2740
01:22:59,040 --> 01:22:59,920
registries

2741
01:22:59,920 --> 01:23:01,600
because if you don't if you miss one and

2742
01:23:01,600 --> 01:23:03,199
it becomes popular someone else will

2743
01:23:03,199 --> 01:23:05,120
upload different code to that one

2744
01:23:05,120 --> 01:23:07,520
and um and then like maven actually just

2745
01:23:07,520 --> 01:23:08,960
takes whichever one comes back first it

2746
01:23:08,960 --> 01:23:10,400
just like sends a request to all of them

2747
01:23:10,400 --> 01:23:12,159
and whatever comes back first so like

2748
01:23:12,159 --> 01:23:13,280
you know if someone wants to make a

2749
01:23:13,280 --> 01:23:14,800
malicious copy of your package all you

2750
01:23:14,800 --> 01:23:16,159
do is find some registry other people

2751
01:23:16,159 --> 01:23:17,679
use that you forgot to upload it to

2752
01:23:17,679 --> 01:23:19,679
and like you know they get to win the

2753
01:23:19,679 --> 01:23:21,360
race sometimes

2754
01:23:21,360 --> 01:23:23,280
so it's like it's a real problem like i

2755
01:23:23,280 --> 01:23:25,199
think having domain name there really

2756
01:23:25,199 --> 01:23:27,040
helps split up the ownership in a really

2757
01:23:27,040 --> 01:23:28,960
important way

2758
01:23:28,960 --> 01:23:34,800
thank you sure

2759
01:23:34,800 --> 01:23:37,120
so the maybe we should take a quick uh

2760
01:23:37,120 --> 01:23:37,840
pause here

2761
01:23:37,840 --> 01:23:39,520
those people that have to go can go i'm

2762
01:23:39,520 --> 01:23:41,280
sure russ is willing to uh stick around

2763
01:23:41,280 --> 01:23:42,239
for a little bit longer

2764
01:23:42,239 --> 01:23:44,880
yeah and answer any questions uh but i

2765
01:23:44,880 --> 01:23:45,600
do want to thank

2766
01:23:45,600 --> 01:23:47,679
ross for giving this lecture uh you know

2767
01:23:47,679 --> 01:23:49,199
hopefully this will help you running

2768
01:23:49,199 --> 01:23:49,520
more

2769
01:23:49,520 --> 01:23:52,880
good go programs these patterns

2770
01:23:52,880 --> 01:23:56,320
and uh so thank you russ very welcome

2771
01:23:56,320 --> 01:23:59,990
it's nice to be here

2772
01:24:00,000 --> 01:24:01,679
and then more questions feel free to ask

2773
01:24:01,679 --> 01:24:03,760
questions yeah

2774
01:24:03,760 --> 01:24:06,880
oh just a little logistical thing uh the

2775
01:24:06,880 --> 01:24:09,520
slides that are on the 6824 website are

2776
01:24:09,520 --> 01:24:10,000
not

2777
01:24:10,000 --> 01:24:12,320
they exactly the same as russ's slides

2778
01:24:12,320 --> 01:24:13,040
people

2779
01:24:13,040 --> 01:24:15,840
check them out i'll get franz a new pdf

2780
01:24:15,840 --> 01:24:18,470
yeah

2781
01:24:18,480 --> 01:24:21,199
more general question about when is

2782
01:24:21,199 --> 01:24:23,360
writing a new language the

2783
01:24:23,360 --> 01:24:25,840
like the best solution to a problem

2784
01:24:25,840 --> 01:24:26,800
that's a great question

2785
01:24:26,800 --> 01:24:30,320
um it's almost never the best solution

2786
01:24:30,320 --> 01:24:32,880
but you know at the time we had just an

2787
01:24:32,880 --> 01:24:34,400
enormous number of programmers like

2788
01:24:34,400 --> 01:24:35,840
thousands of programmers working in one

2789
01:24:35,840 --> 01:24:36,960
code base

2790
01:24:36,960 --> 01:24:39,120
and the compilations were just taking

2791
01:24:39,120 --> 01:24:40,239
forever because

2792
01:24:40,239 --> 01:24:42,560
um seatbelts plus was just not not meant

2793
01:24:42,560 --> 01:24:44,719
for you know efficient incremental

2794
01:24:44,719 --> 01:24:46,000
compilation

2795
01:24:46,000 --> 01:24:49,840
and and so it and furthermore

2796
01:24:49,840 --> 01:24:51,520
at the time like threading libraries

2797
01:24:51,520 --> 01:24:52,960
were really awful like people just

2798
01:24:52,960 --> 01:24:54,000
didn't use threats i remember

2799
01:24:54,000 --> 01:24:55,679
like one of the first days i was at mit

2800
01:24:55,679 --> 01:24:57,600
and talking to robert and robert said to

2801
01:24:57,600 --> 01:24:58,159
me

2802
01:24:58,159 --> 01:25:00,080
um like in 2001 he said to me like well

2803
01:25:00,080 --> 01:25:01,040
we don't use threads here because

2804
01:25:01,040 --> 01:25:02,239
threads are slow

2805
01:25:02,239 --> 01:25:04,159
and and that was like totally normal

2806
01:25:04,159 --> 01:25:05,600
like that was just the way the world at

2807
01:25:05,600 --> 01:25:06,480
the time

2808
01:25:06,480 --> 01:25:09,440
um and and at google we were having a

2809
01:25:09,440 --> 01:25:10,239
lot of trouble

2810
01:25:10,239 --> 01:25:11,840
because it was all event-based like

2811
01:25:11,840 --> 01:25:13,920
little callbacks in c plus plus

2812
01:25:13,920 --> 01:25:15,760
and there were these multi-core machines

2813
01:25:15,760 --> 01:25:17,199
and we actually didn't know how to get

2814
01:25:17,199 --> 01:25:18,639
things to work on them because like

2815
01:25:18,639 --> 01:25:20,000
linux threads were not something you

2816
01:25:20,000 --> 01:25:22,000
could really rely on to work

2817
01:25:22,000 --> 01:25:24,080
and and so we ended up like if you had a

2818
01:25:24,080 --> 01:25:25,679
four core machine you just run four

2819
01:25:25,679 --> 01:25:26,000
different

2820
01:25:26,000 --> 01:25:27,360
process in completely independent

2821
01:25:27,360 --> 01:25:28,639
processes of the web server and just

2822
01:25:28,639 --> 01:25:30,560
treat it as like four machines

2823
01:25:30,560 --> 01:25:32,880
um and that was clearly like not very

2824
01:25:32,880 --> 01:25:33,600
efficient

2825
01:25:33,600 --> 01:25:35,600
so like there were a lot of good reasons

2826
01:25:35,600 --> 01:25:37,520
to like try something

2827
01:25:37,520 --> 01:25:40,639
um but you know it's a huge amount of

2828
01:25:40,639 --> 01:25:42,000
work to get to the point where go is

2829
01:25:42,000 --> 01:25:43,760
today and i think that

2830
01:25:43,760 --> 01:25:46,159
um so much is not the language right

2831
01:25:46,159 --> 01:25:47,360
like there were important things that we

2832
01:25:47,360 --> 01:25:48,880
made did in the language that enabled

2833
01:25:48,880 --> 01:25:49,440
other

2834
01:25:49,440 --> 01:25:52,719
um considerations but uh

2835
01:25:52,719 --> 01:25:54,400
so much of the successful languages the

2836
01:25:54,400 --> 01:25:55,840
ecosystem that got built up around it

2837
01:25:55,840 --> 01:25:57,199
and the tooling that we built and the go

2838
01:25:57,199 --> 01:25:59,040
command and like all these like not the

2839
01:25:59,040 --> 01:26:00,560
language things so

2840
01:26:00,560 --> 01:26:02,560
you know programming language uh people

2841
01:26:02,560 --> 01:26:03,840
who are like focus on the language

2842
01:26:03,840 --> 01:26:04,800
itself

2843
01:26:04,800 --> 01:26:06,719
i think sometimes get distracted by all

2844
01:26:06,719 --> 01:26:08,159
the stuff around like they miss all the

2845
01:26:08,159 --> 01:26:15,189
stuff around it

2846
01:26:15,199 --> 01:26:18,239
um can i ask a follow-up on that yeah i

2847
01:26:18,239 --> 01:26:19,520
was wondering how is

2848
01:26:19,520 --> 01:26:22,000
working on go different now since it's

2849
01:26:22,000 --> 01:26:23,199
more mature than

2850
01:26:23,199 --> 01:26:27,440
it was before oh

2851
01:26:27,440 --> 01:26:29,600
that's a great question um you know in

2852
01:26:29,600 --> 01:26:31,120
the early days it was so easy to make

2853
01:26:31,120 --> 01:26:31,760
changes

2854
01:26:31,760 --> 01:26:33,600
and now it's really hard to make changes

2855
01:26:33,600 --> 01:26:35,120
i think that's the number one thing

2856
01:26:35,120 --> 01:26:39,440
um you know in the early days like

2857
01:26:39,440 --> 01:26:40,719
everything was in one source code

2858
01:26:40,719 --> 01:26:42,080
repository literally all the go code in

2859
01:26:42,080 --> 01:26:43,120
the world was the one source code

2860
01:26:43,120 --> 01:26:44,639
repository and so like there were days

2861
01:26:44,639 --> 01:26:45,840
where we changed the syntax like you

2862
01:26:45,840 --> 01:26:47,600
used to have a star before chan

2863
01:26:47,600 --> 01:26:48,960
every time you set a channel because it

2864
01:26:48,960 --> 01:26:50,639
was then it was a pointer underneath and

2865
01:26:50,639 --> 01:26:52,000
it was all kind of exposed so you'd

2866
01:26:52,000 --> 01:26:53,760
always say star channel instead of jan

2867
01:26:53,760 --> 01:26:54,480
and

2868
01:26:54,480 --> 01:26:56,560
and and similarly for maps and at some

2869
01:26:56,560 --> 01:26:57,520
point we realized like

2870
01:26:57,520 --> 01:26:59,040
this is dumb like you have to say the

2871
01:26:59,040 --> 01:27:00,639
star let's just take it out

2872
01:27:00,639 --> 01:27:02,480
and um and so like we made the change to

2873
01:27:02,480 --> 01:27:04,400
the compiler and i opened up literally

2874
01:27:04,400 --> 01:27:04,880
like

2875
01:27:04,880 --> 01:27:06,639
the couple hundred go source files in

2876
01:27:06,639 --> 01:27:08,400
the world in my editor and like

2877
01:27:08,400 --> 01:27:10,320
the entire team stood behind me and like

2878
01:27:10,320 --> 01:27:11,920
i typed some regular expressions and we

2879
01:27:11,920 --> 01:27:13,520
looked at the effect on the files

2880
01:27:13,520 --> 01:27:15,280
yep that looks right save it you know

2881
01:27:15,280 --> 01:27:16,960
compile it we're done

2882
01:27:16,960 --> 01:27:18,960
and like today you know we can't make

2883
01:27:18,960 --> 01:27:20,800
backwards compatible changes at all

2884
01:27:20,800 --> 01:27:23,440
um and and even making you know new

2885
01:27:23,440 --> 01:27:25,199
changes like it

2886
01:27:25,199 --> 01:27:28,560
it affects a lot of people and so uh

2887
01:27:28,560 --> 01:27:30,639
you know you sort of propose something

2888
01:27:30,639 --> 01:27:32,159
and you know people point out well this

2889
01:27:32,159 --> 01:27:33,520
won't work for me and you try to like

2890
01:27:33,520 --> 01:27:35,040
adjust that maybe

2891
01:27:35,040 --> 01:27:36,480
um it's just it's a lot harder we

2892
01:27:36,480 --> 01:27:38,159
estimate there's at least a million

2893
01:27:38,159 --> 01:27:39,600
maybe two million go programmers in the

2894
01:27:39,600 --> 01:27:40,560
world and

2895
01:27:40,560 --> 01:27:41,920
it's very different from when they were

2896
01:27:41,920 --> 01:27:51,669
you know four or five

2897
01:27:51,679 --> 01:27:53,440
not sure if this is a valid question but

2898
01:27:53,440 --> 01:27:55,360
what what language is go written in is

2899
01:27:55,360 --> 01:27:57,440
it written in go also or no

2900
01:27:57,440 --> 01:27:59,520
now it is now it is the original um

2901
01:27:59,520 --> 01:28:01,280
compiler runtime were written in c

2902
01:28:01,280 --> 01:28:02,880
but a few years ago we went through a

2903
01:28:02,880 --> 01:28:05,040
big um we actually wrote a

2904
01:28:05,040 --> 01:28:07,440
a program to translate c to go and that

2905
01:28:07,440 --> 01:28:09,280
only worked for rc code but still it was

2906
01:28:09,280 --> 01:28:10,000
good enough

2907
01:28:10,000 --> 01:28:12,159
so that we wouldn't lose kind of all the

2908
01:28:12,159 --> 01:28:14,000
sort of encoded knowledge in that code

2909
01:28:14,000 --> 01:28:15,440
about why things were the way they were

2910
01:28:15,440 --> 01:28:16,639
and like how things work so we have to

2911
01:28:16,639 --> 01:28:17,760
start from scratch

2912
01:28:17,760 --> 01:28:19,600
but now it's all written and go and you

2913
01:28:19,600 --> 01:28:21,040
know a little bit of assembly

2914
01:28:21,040 --> 01:28:24,000
and that means that um people can uh you

2915
01:28:24,000 --> 01:28:24,800
know

2916
01:28:24,800 --> 01:28:26,800
people who know go can help on the the

2917
01:28:26,800 --> 01:28:28,800
go project whereas before like

2918
01:28:28,800 --> 01:28:30,239
if you wanted to work on the compiler or

2919
01:28:30,239 --> 01:28:32,000
the runtime you had to know c really

2920
01:28:32,000 --> 01:28:33,040
well and like

2921
01:28:33,040 --> 01:28:34,239
we weren't getting a lot of people knew

2922
01:28:34,239 --> 01:28:35,679
c really well like there's not actually

2923
01:28:35,679 --> 01:28:37,199
that many of them proportionately and

2924
01:28:37,199 --> 01:28:38,560
and furthermore like our entire user

2925
01:28:38,560 --> 01:28:40,880
base is go programmers not c programmers

2926
01:28:40,880 --> 01:28:42,480
so moving to go was was a really big

2927
01:28:42,480 --> 01:28:46,070
deal

2928
01:28:46,080 --> 01:28:48,560
i was wondering how did you prioritize

2929
01:28:48,560 --> 01:28:50,480
what features to add to the language at

2930
01:28:50,480 --> 01:28:52,639
like this point like in all generics

2931
01:28:52,639 --> 01:28:54,480
like a lot of people were like asking

2932
01:28:54,480 --> 01:28:55,840
for that like

2933
01:28:55,840 --> 01:28:57,520
did y'all know like how you choose what

2934
01:28:57,520 --> 01:28:59,120
to work on

2935
01:28:59,120 --> 01:29:00,800
i mean we've considered language mostly

2936
01:29:00,800 --> 01:29:02,320
frozen for a while

2937
01:29:02,320 --> 01:29:04,000
and um and so we haven't been adding

2938
01:29:04,000 --> 01:29:05,760
much uh there was a long period where we

2939
01:29:05,760 --> 01:29:07,040
said we weren't adding anything and then

2940
01:29:07,040 --> 01:29:08,800
we added a little bit of things

2941
01:29:08,800 --> 01:29:10,719
in the last couple years to lead up to

2942
01:29:10,719 --> 01:29:12,320
generics just kind of shake the rust off

2943
01:29:12,320 --> 01:29:13,360
on like all the like

2944
01:29:13,360 --> 01:29:14,560
what breaks when you change something in

2945
01:29:14,560 --> 01:29:16,080
the language so like you can put

2946
01:29:16,080 --> 01:29:17,520
underscores between digits and long

2947
01:29:17,520 --> 01:29:18,159
numbers now

2948
01:29:18,159 --> 01:29:21,280
things like that um but you know

2949
01:29:21,280 --> 01:29:22,960
generics has clearly been the next thing

2950
01:29:22,960 --> 01:29:23,280
that

2951
01:29:23,280 --> 01:29:24,480
needed to happen and we just had to

2952
01:29:24,480 --> 01:29:26,320
figure out how

2953
01:29:26,320 --> 01:29:28,000
in general we try to only add things

2954
01:29:28,000 --> 01:29:30,080
that don't have weird kind of

2955
01:29:30,080 --> 01:29:31,920
interference with other features

2956
01:29:31,920 --> 01:29:33,360
and we try to add things that are you

2957
01:29:33,360 --> 01:29:34,880
know really important that will help a

2958
01:29:34,880 --> 01:29:36,719
lot of people for the kinds of programs

2959
01:29:36,719 --> 01:29:37,280
that

2960
01:29:37,280 --> 01:29:38,560
we're trying to target with go which is

2961
01:29:38,560 --> 01:29:40,400
like distributed systems and

2962
01:29:40,400 --> 01:29:50,149
that sort of thing

2963
01:29:50,159 --> 01:29:53,120
cool thank you oh i had a question

2964
01:29:53,120 --> 01:29:54,560
actually yeah

2965
01:29:54,560 --> 01:29:58,320
uh so um for i noticed that like you

2966
01:29:58,320 --> 01:29:58,800
know

2967
01:29:58,800 --> 01:30:01,040
uh go doesn't have like basic functions

2968
01:30:01,040 --> 01:30:03,520
like min or max for like

2969
01:30:03,520 --> 01:30:05,760
yeah so is that like something that

2970
01:30:05,760 --> 01:30:07,679
you're considering like say adding with

2971
01:30:07,679 --> 01:30:09,600
like the generic stuff maybe is that why

2972
01:30:09,600 --> 01:30:11,199
you didn't decide yeah exactly right

2973
01:30:11,199 --> 01:30:12,800
because like you can't have a min

2974
01:30:12,800 --> 01:30:13,920
you'd have been event and you could have

2975
01:30:13,920 --> 01:30:15,199
minivan date but those had to have

2976
01:30:15,199 --> 01:30:16,560
different names and that was kind of

2977
01:30:16,560 --> 01:30:17,440
annoying

2978
01:30:17,440 --> 01:30:19,280
um so now we can write just a generic

2979
01:30:19,280 --> 01:30:21,760
name over any type that has a less than

2980
01:30:21,760 --> 01:30:23,040
operator

2981
01:30:23,040 --> 01:30:24,480
yeah that'll be good and you know

2982
01:30:24,480 --> 01:30:26,239
honestly like for the specific case of

2983
01:30:26,239 --> 01:30:27,520
min and max

2984
01:30:27,520 --> 01:30:30,080
so i know it's not that hard to code i

2985
01:30:30,080 --> 01:30:31,360
know i was gonna say i'm starting to

2986
01:30:31,360 --> 01:30:32,159
feel like we should just make some

2987
01:30:32,159 --> 01:30:32,960
built-ins like

2988
01:30:32,960 --> 01:30:35,280
like you know print and things like that

2989
01:30:35,280 --> 01:30:36,800
so that you know you can just always

2990
01:30:36,800 --> 01:30:37,600
have them

2991
01:30:37,600 --> 01:30:39,199
but even if we don't like you it'll be

2992
01:30:39,199 --> 01:30:41,520
math.min and that'll be there at least

2993
01:30:41,520 --> 01:30:43,440
um yeah we really didn't want to make

2994
01:30:43,440 --> 01:30:44,880
them built-ins until we could like

2995
01:30:44,880 --> 01:30:46,480
express their types and we couldn't do

2996
01:30:46,480 --> 01:30:48,239
that until generics happened

2997
01:30:48,239 --> 01:30:49,920
because there is actually a min for like

2998
01:30:49,920 --> 01:30:51,600
floating points actually

2999
01:30:51,600 --> 01:30:53,520
yeah i know it's kind of weird because

3000
01:30:53,520 --> 01:30:55,040
it's because the math library is

3001
01:30:55,040 --> 01:30:57,600
basically copied from the c math.h set

3002
01:30:57,600 --> 01:31:00,870
of things yes

3003
01:31:00,880 --> 01:31:02,080
so that's a good point like we can't

3004
01:31:02,080 --> 01:31:03,199
actually put them in math because

3005
01:31:03,199 --> 01:31:04,800
they're already there

3006
01:31:04,800 --> 01:31:07,840
okay but no yeah but we'll figure it out

3007
01:31:07,840 --> 01:31:09,040
like i think we should probably just put

3008
01:31:09,040 --> 01:31:10,159
them in the language but we have to get

3009
01:31:10,159 --> 01:31:11,600
generis through first

3010
01:31:11,600 --> 01:31:13,280
and another thing actually i noticed

3011
01:31:13,280 --> 01:31:15,280
that you did usako like competitive

3012
01:31:15,280 --> 01:31:16,960
programming yeah i did too

3013
01:31:16,960 --> 01:31:20,320
actually oh cool yeah so how did you so

3014
01:31:20,320 --> 01:31:22,080
actually i included this in one of the

3015
01:31:22,080 --> 01:31:22,880
questions that i

3016
01:31:22,880 --> 01:31:25,199
submitted let me pull it up um so my

3017
01:31:25,199 --> 01:31:26,480
question was like

3018
01:31:26,480 --> 01:31:31,360
um how did how was like how did you

3019
01:31:31,360 --> 01:31:33,360
go from doing competitive programming to

3020
01:31:33,360 --> 01:31:34,719
like doing what you

3021
01:31:34,719 --> 01:31:36,239
you're doing now at google working on

3022
01:31:36,239 --> 01:31:37,760
going how's the transition

3023
01:31:37,760 --> 01:31:40,080
between like competitive programming to

3024
01:31:40,080 --> 01:31:41,120
systems also

3025
01:31:41,120 --> 01:31:43,040
finally what made you decide to go into

3026
01:31:43,040 --> 01:31:45,040
systems and how did it relate to

3027
01:31:45,040 --> 01:31:46,560
programming i mean competitive

3028
01:31:46,560 --> 01:31:48,159
programming at the time that i did it

3029
01:31:48,159 --> 01:31:50,239
was not as all-consuming as i gather it

3030
01:31:50,239 --> 01:31:50,880
is now

3031
01:31:50,880 --> 01:31:53,520
like like you know you could just like

3032
01:31:53,520 --> 01:31:54,159
be able to

3033
01:31:54,159 --> 01:31:55,840
implement a simple dynamic programming

3034
01:31:55,840 --> 01:31:57,840
like little two for loops and that was

3035
01:31:57,840 --> 01:31:58,639
fine and now you have

3036
01:31:58,639 --> 01:32:00,159
all these like complex hall algorithms

3037
01:32:00,159 --> 01:32:02,080
and all that stuff that i can't do

3038
01:32:02,080 --> 01:32:03,520
so like you know at some point like at

3039
01:32:03,520 --> 01:32:05,360
some level like it was different

3040
01:32:05,360 --> 01:32:08,080
um but you know i was actually more

3041
01:32:08,080 --> 01:32:09,360
interested in the sort of

3042
01:32:09,360 --> 01:32:10,560
systems you kind of stopped from the

3043
01:32:10,560 --> 01:32:13,040
start and and the the program contests

3044
01:32:13,040 --> 01:32:14,320
were just like something fun to do on

3045
01:32:14,320 --> 01:32:15,600
the side

3046
01:32:15,600 --> 01:32:17,120
so there wasn't like a huge transition

3047
01:32:17,120 --> 01:32:19,120
there um i was never into like

3048
01:32:19,120 --> 01:32:21,199
implementing complex algorithms and and

3049
01:32:21,199 --> 01:32:22,960
that you know max flow and all those

3050
01:32:22,960 --> 01:32:24,159
sorts of things

3051
01:32:24,159 --> 01:32:26,080
on the other hand like when you start a

3052
01:32:26,080 --> 01:32:28,080
new language you actually do get to

3053
01:32:28,080 --> 01:32:29,199
write a lot of

3054
01:32:29,199 --> 01:32:31,760
core things right um like someone has to

3055
01:32:31,760 --> 01:32:33,280
write the sort function

3056
01:32:33,280 --> 01:32:34,880
and it has to be a good general sort

3057
01:32:34,880 --> 01:32:36,480
function and like i spent a while

3058
01:32:36,480 --> 01:32:38,320
last month like looking into dip

3059
01:32:38,320 --> 01:32:40,719
algorithms and and that's like you know

3060
01:32:40,719 --> 01:32:42,320
sort of matches that background pretty

3061
01:32:42,320 --> 01:32:44,719
well so like it does come up

3062
01:32:44,719 --> 01:32:47,040
um but you know it's just it's just a

3063
01:32:47,040 --> 01:32:48,159
different kind of programming

3064
01:32:48,159 --> 01:32:49,520
oh so you thought of it as more of a

3065
01:32:49,520 --> 01:32:51,360
side thing back then no like yeah

3066
01:32:51,360 --> 01:32:52,960
it wasn't it was definitely not the sort

3067
01:32:52,960 --> 01:32:54,159
of main thing i did when i was writing

3068
01:32:54,159 --> 01:32:54,880
programs

3069
01:32:54,880 --> 01:32:56,880
yeah because like today it's effectively

3070
01:32:56,880 --> 01:32:58,400
like the main thing i know i know it's

3071
01:32:58,400 --> 01:32:58,639
you

3072
01:32:58,639 --> 01:33:00,800
know if you don't do it full-time like

3073
01:33:00,800 --> 01:33:02,159
there's just no way you can

3074
01:33:02,159 --> 01:33:03,679
you know there just weren't that many

3075
01:33:03,679 --> 01:33:07,189
people who cared it you know in

3076
01:33:07,199 --> 01:33:15,030
uh 1995 yeah 20 years later

3077
01:33:15,040 --> 01:33:16,639
um can you ask a related question to

3078
01:33:16,639 --> 01:33:19,520
that so how did you decide to go

3079
01:33:19,520 --> 01:33:22,560
from i'm from like academic work

3080
01:33:22,560 --> 01:33:25,440
into i mean your work is still like a

3081
01:33:25,440 --> 01:33:27,040
little bit more different than

3082
01:33:27,040 --> 01:33:29,440
like the usual like software engineering

3083
01:33:29,440 --> 01:33:30,080
thing but

3084
01:33:30,080 --> 01:33:33,760
still yeah um

3085
01:33:33,760 --> 01:33:35,760
you know i got lucky uh i i grew up near

3086
01:33:35,760 --> 01:33:37,600
bell labs in new jersey and so like that

3087
01:33:37,600 --> 01:33:39,040
was how i ended up working on playing

3088
01:33:39,040 --> 01:33:40,320
the iron a little bit in high school and

3089
01:33:40,320 --> 01:33:41,280
college

3090
01:33:41,280 --> 01:33:44,320
um and so you know i sort of knew i was

3091
01:33:44,320 --> 01:33:45,679
going to go to grad school and

3092
01:33:45,679 --> 01:33:47,120
you know the plan was to go back to bell

3093
01:33:47,120 --> 01:33:48,880
labs but it kind of imploded while i was

3094
01:33:48,880 --> 01:33:51,600
in grad school with the dot com boom and

3095
01:33:51,600 --> 01:33:53,280
the dot com crash

3096
01:33:53,280 --> 01:33:55,760
and um and so like you know google was

3097
01:33:55,760 --> 01:33:57,040
was sort of a

3098
01:33:57,040 --> 01:33:59,600
just vacuuming up phds systems phds at

3099
01:33:59,600 --> 01:34:00,639
the time

3100
01:34:00,639 --> 01:34:02,159
and and and doing really interesting

3101
01:34:02,159 --> 01:34:03,360
things i mean you probably you know

3102
01:34:03,360 --> 01:34:04,719
there's a i don't know i haven't looked

3103
01:34:04,719 --> 01:34:06,000
at syllabus for this year but you know

3104
01:34:06,000 --> 01:34:07,679
there's things like spanner and

3105
01:34:07,679 --> 01:34:10,239
um big table and chubby and and things

3106
01:34:10,239 --> 01:34:11,760
like that and you know they they had a

3107
01:34:11,760 --> 01:34:13,760
whole host of good distributed systems

3108
01:34:13,760 --> 01:34:15,360
kind of stuff going on

3109
01:34:15,360 --> 01:34:17,040
and so you know it was sort of lucky to

3110
01:34:17,040 --> 01:34:19,120
be able to to go to that too

3111
01:34:19,120 --> 01:34:22,480
um and you know at the time i graduated

3112
01:34:22,480 --> 01:34:23,679
i was also looking at you know

3113
01:34:23,679 --> 01:34:25,199
industrial research labs like microsoft

3114
01:34:25,199 --> 01:34:26,000
research and

3115
01:34:26,000 --> 01:34:28,159
and places like that so you know there's

3116
01:34:28,159 --> 01:34:29,920
definitely an opportunity there for

3117
01:34:29,920 --> 01:34:32,080
you know researchy things but not in

3118
01:34:32,080 --> 01:34:34,239
academia if that's what you want

3119
01:34:34,239 --> 01:34:36,159
um it's a little harder to find now i

3120
01:34:36,159 --> 01:34:37,440
mean most of the places i know like

3121
01:34:37,440 --> 01:34:39,360
microsoft research imploded too

3122
01:34:39,360 --> 01:34:42,560
a couple years later but um you know

3123
01:34:42,560 --> 01:34:45,920
it's uh it's still an option and and you

3124
01:34:45,920 --> 01:34:47,040
know it's just a

3125
01:34:47,040 --> 01:34:50,080
slightly different path um you end up

3126
01:34:50,080 --> 01:34:51,840
the the differences i see from academia

3127
01:34:51,840 --> 01:34:53,520
is like you end up caring a ton

3128
01:34:53,520 --> 01:34:55,920
more about actually making things work

3129
01:34:55,920 --> 01:34:57,760
100 time and supporting them for like a

3130
01:34:57,760 --> 01:34:58,960
decade or more

3131
01:34:58,960 --> 01:35:00,320
whereas like you finish your paper and

3132
01:35:00,320 --> 01:35:01,520
you kind of like get to put it off to

3133
01:35:01,520 --> 01:35:02,960
the side and that's that's really nice

3134
01:35:02,960 --> 01:35:03,520
actually

3135
01:35:03,520 --> 01:35:06,880
at some level um it's uh

3136
01:35:06,880 --> 01:35:08,639
it's definitely strange to me to be you

3137
01:35:08,639 --> 01:35:10,560
know editing source files

3138
01:35:10,560 --> 01:35:13,600
that i wrote you know in in some cases

3139
01:35:13,600 --> 01:35:15,280
actually 20 years ago

3140
01:35:15,280 --> 01:35:16,960
um because i used a bunch of code that

3141
01:35:16,960 --> 01:35:19,119
i'd already written when we started go

3142
01:35:19,119 --> 01:35:20,880
and it's very weird to think that like

3143
01:35:20,880 --> 01:35:22,320
i've been keeping this program running

3144
01:35:22,320 --> 01:35:26,310
for 20 years

