1
00:00:00,000 --> 00:00:02,639
good afternoon good evening good night

2
00:00:02,639 --> 00:00:04,640
wherever you are

3
00:00:04,640 --> 00:00:07,040
so today i want to talk about farm this

4
00:00:07,040 --> 00:00:08,000
is a paper from

5
00:00:08,000 --> 00:00:10,160
2015 so i want a little bit more of a

6
00:00:10,160 --> 00:00:11,200
recent paper

7
00:00:11,200 --> 00:00:12,799
and then it's really a research paper

8
00:00:12,799 --> 00:00:14,880
and the topic of the research paper

9
00:00:14,880 --> 00:00:17,520
is trying to explore some ideas and

10
00:00:17,520 --> 00:00:28,830
technologies to get high performance

11
00:00:28,840 --> 00:00:31,679
transactions

12
00:00:31,679 --> 00:00:34,320
and with a high performance just to uh

13
00:00:34,320 --> 00:00:36,079
make sure that we're on the uh

14
00:00:36,079 --> 00:00:38,160
roughly what we're looking for uh high

15
00:00:38,160 --> 00:00:39,440
performance from that means

16
00:00:39,440 --> 00:00:43,350
they're getting 140 million

17
00:00:43,360 --> 00:00:45,840
transactions per second uh on this you

18
00:00:45,840 --> 00:00:48,790
know t80p

19
00:00:48,800 --> 00:00:58,640
benchmark using 90 machines

20
00:00:58,640 --> 00:01:00,800
and so uh you know whether this number

21
00:01:00,800 --> 00:01:02,320
is impressive of course you know depends

22
00:01:02,320 --> 00:01:02,719
on

23
00:01:02,719 --> 00:01:04,559
the numbers you know and so anybody

24
00:01:04,559 --> 00:01:05,920
remember like how many transactions per

25
00:01:05,920 --> 00:01:24,830
second spanner could do

26
00:01:24,840 --> 00:01:27,040
anybody

27
00:01:27,040 --> 00:01:29,360
so if we remember in the paper there's a

28
00:01:29,360 --> 00:01:31,119
certain uh interjection there you know

29
00:01:31,119 --> 00:01:31,920
took about you know

30
00:01:31,920 --> 00:01:34,159
depending on what you did you know 10 to

31
00:01:34,159 --> 00:01:35,680
100 milliseconds so

32
00:01:35,680 --> 00:01:39,200
you know 10 to 100 uh transactions

33
00:01:39,200 --> 00:01:42,479
uh per second and so

34
00:01:42,479 --> 00:01:45,439
uh the numeral transactions that farming

35
00:01:45,439 --> 00:01:45,840
can do

36
00:01:45,840 --> 00:01:47,759
is in a completely different order of

37
00:01:47,759 --> 00:01:48,960
magnitude

38
00:01:48,960 --> 00:01:50,079
and that partly is because they're

39
00:01:50,079 --> 00:01:52,159
completely different systems uh

40
00:01:52,159 --> 00:01:54,799
spanner tries to do synchronous geo

41
00:01:54,799 --> 00:01:56,880
replication across the world

42
00:01:56,880 --> 00:01:59,200
and farm actually everything runs in in

43
00:01:59,200 --> 00:02:04,469
a single data center

44
00:02:04,479 --> 00:02:06,479
and so the applications that have been

45
00:02:06,479 --> 00:02:07,600
targeted by

46
00:02:07,600 --> 00:02:10,080
farm and spanner are quite different

47
00:02:10,080 --> 00:02:11,360
spenders targeting

48
00:02:11,360 --> 00:02:15,110
applications that cannot tolerate

49
00:02:15,120 --> 00:02:17,120
the crash of the data center like you

50
00:02:17,120 --> 00:02:19,200
know the f1

51
00:02:19,200 --> 00:02:22,239
ad serving database while spender is

52
00:02:22,239 --> 00:02:22,720
much

53
00:02:22,720 --> 00:02:25,040
very well far much much more targeting

54
00:02:25,040 --> 00:02:26,480
sort of like you're

55
00:02:26,480 --> 00:02:28,640
if you were using mysql or some other

56
00:02:28,640 --> 00:02:30,080
sort of

57
00:02:30,080 --> 00:02:32,959
database database system and you want

58
00:02:32,959 --> 00:02:35,280
much more high performance

59
00:02:35,280 --> 00:02:37,599
transactions then you know as far as

60
00:02:37,599 --> 00:02:38,319
sort of a

61
00:02:38,319 --> 00:02:40,080
possible design or a possible

62
00:02:40,080 --> 00:02:41,840
alternative

63
00:02:41,840 --> 00:02:48,390
they do provide a strict serializability

64
00:02:48,400 --> 00:02:51,840
which is similar to the

65
00:02:51,840 --> 00:02:55,200
external consistency that uh

66
00:02:55,200 --> 00:02:58,000
spanner offered and so the whole goal is

67
00:02:58,000 --> 00:02:59,200
to get high performance so there's a

68
00:02:59,200 --> 00:03:00,959
number of ideas you know they're going

69
00:03:00,959 --> 00:03:01,440
to

70
00:03:01,440 --> 00:03:04,319
achieving high performance uh one they

71
00:03:04,319 --> 00:03:05,519
shard

72
00:03:05,519 --> 00:03:08,159
that's probably the main you know

73
00:03:08,159 --> 00:03:09,680
standard technique that they use that

74
00:03:09,680 --> 00:03:10,560
was going to give us

75
00:03:10,560 --> 00:03:12,879
performance for example if you know

76
00:03:12,879 --> 00:03:13,680
different

77
00:03:13,680 --> 00:03:16,000
records are on different charts and the

78
00:03:16,000 --> 00:03:17,200
transactions

79
00:03:17,200 --> 00:03:18,959
touch the different charts then these uh

80
00:03:18,959 --> 00:03:20,400
transactions can just run in

81
00:03:20,400 --> 00:03:23,200
parallel and so um if you have 90

82
00:03:23,200 --> 00:03:24,319
machines you know you get

83
00:03:24,319 --> 00:03:27,200
90 times uh you know the performance of

84
00:03:27,200 --> 00:03:28,400
a single machine

85
00:03:28,400 --> 00:03:30,000
so sharding is sort of the starting

86
00:03:30,000 --> 00:03:33,360
point but then there you go much further

87
00:03:33,360 --> 00:03:36,720
so they use non-volatile

88
00:03:36,720 --> 00:03:40,879
dram and this is to avoid you know the

89
00:03:40,879 --> 00:03:43,200
bottleneck of having to write to

90
00:03:43,200 --> 00:03:46,480
uh stable storage devices so in their

91
00:03:46,480 --> 00:03:48,239
design you don't actually have to write

92
00:03:48,239 --> 00:03:51,599
in the critical path to an ssd or a disk

93
00:03:51,599 --> 00:03:54,959
uh and so they avoid the whole cost of

94
00:03:54,959 --> 00:03:56,560
doing so and which can be quite

95
00:03:56,560 --> 00:03:58,239
expensive and that's what for example

96
00:03:58,239 --> 00:04:01,040
you think about your uh

97
00:04:01,040 --> 00:04:04,000
implementations of raft you know they uh

98
00:04:04,000 --> 00:04:04,799
they

99
00:04:04,799 --> 00:04:07,840
they store or make data persistent uh

100
00:04:07,840 --> 00:04:09,360
and typically you know making something

101
00:04:09,360 --> 00:04:11,519
persistent on a stable storage device uh

102
00:04:11,519 --> 00:04:12,959
you know in the order of

103
00:04:12,959 --> 00:04:16,479
you know 100 milliseconds of

104
00:04:16,479 --> 00:04:19,280
uh a few milliseconds you know to you

105
00:04:19,280 --> 00:04:20,239
know tens of mills

106
00:04:20,239 --> 00:04:21,759
to 10 milliseconds if you're actually

107
00:04:21,759 --> 00:04:23,520
using magnetic disc

108
00:04:23,520 --> 00:04:25,840
but an ssd you know sort of uh sort of a

109
00:04:25,840 --> 00:04:27,120
millisecond

110
00:04:27,120 --> 00:04:29,360
um and so given the time frame they

111
00:04:29,360 --> 00:04:30,960
operate you know that we just do two

112
00:04:30,960 --> 00:04:31,600
costly

113
00:04:31,600 --> 00:04:33,280
so they use something what they call

114
00:04:33,280 --> 00:04:34,960
non-volatile dram this we'll talk about

115
00:04:34,960 --> 00:04:36,400
in a second

116
00:04:36,400 --> 00:04:38,880
um then so that gets us rid of the

117
00:04:38,880 --> 00:04:39,440
storage

118
00:04:39,440 --> 00:04:43,120
uh access cost and so the next

119
00:04:43,120 --> 00:04:45,759
you know two bottlenecks they address is

120
00:04:45,759 --> 00:04:47,199
cpu bottlenecks

121
00:04:47,199 --> 00:04:49,680
and network bottlenecks and for that

122
00:04:49,680 --> 00:04:50,320
they use

123
00:04:50,320 --> 00:04:56,960
a technique called kernel bypass

124
00:04:56,960 --> 00:04:59,520
it basically avoids the operating system

125
00:04:59,520 --> 00:05:01,600
for to talk to the network card

126
00:05:01,600 --> 00:05:03,120
and then they use network cards that

127
00:05:03,120 --> 00:05:05,360
have a special feature

128
00:05:05,360 --> 00:05:10,560
called rdma

129
00:05:10,560 --> 00:05:13,280
that allows the car to read and write

130
00:05:13,280 --> 00:05:15,039
memory from a remote server without

131
00:05:15,039 --> 00:05:16,240
actually having to interrupt

132
00:05:16,240 --> 00:05:20,000
you know that remote server and so this

133
00:05:20,000 --> 00:05:23,199
gives us really low latency uh network

134
00:05:23,199 --> 00:05:25,840
access to your remote server

135
00:05:25,840 --> 00:05:27,360
or to remote memory and this is where

136
00:05:27,360 --> 00:05:29,039
partially where the name farm comes from

137
00:05:29,039 --> 00:05:30,560
you know the r stands for remote

138
00:05:30,560 --> 00:05:34,800
and for memory and the f is for fast

139
00:05:34,800 --> 00:05:38,000
um so those are the the sort of the

140
00:05:38,000 --> 00:05:40,880
technologies they use um and then you

141
00:05:40,880 --> 00:05:42,320
know to be able to really exploit these

142
00:05:42,320 --> 00:05:44,400
technologies uh this drives them to

143
00:05:44,400 --> 00:05:45,919
a design that uses optimistic

144
00:05:45,919 --> 00:05:48,400
concurrency controls or occ

145
00:05:48,400 --> 00:05:50,840
uh the short version of this so

146
00:05:50,840 --> 00:05:56,230
optimistic

147
00:05:56,240 --> 00:05:58,080
um and in contrast to many of the

148
00:05:58,080 --> 00:06:00,319
designs that we've seen so far where

149
00:06:00,319 --> 00:06:02,160
they use what we're typically called

150
00:06:02,160 --> 00:06:04,000
pessimistic currency control schemes and

151
00:06:04,000 --> 00:06:05,199
pessimistics controls

152
00:06:05,199 --> 00:06:08,639
the schemes basically acquire walks uh

153
00:06:08,639 --> 00:06:12,000
on the uh the objects are being touched

154
00:06:12,000 --> 00:06:13,919
by the transaction

155
00:06:13,919 --> 00:06:16,880
and so when they get to the commit time

156
00:06:16,880 --> 00:06:17,199
they

157
00:06:17,199 --> 00:06:19,039
own all the locks of all the relevant

158
00:06:19,039 --> 00:06:20,720
objects and just go ahead and

159
00:06:20,720 --> 00:06:23,520
complement while with optimistic

160
00:06:23,520 --> 00:06:25,120
concurrency control you don't actually

161
00:06:25,120 --> 00:06:26,240
acquire

162
00:06:26,240 --> 00:06:28,319
locks in particular in a farm you don't

163
00:06:28,319 --> 00:06:30,080
require locks on the

164
00:06:30,080 --> 00:06:33,520
read transactions and

165
00:06:33,520 --> 00:06:35,520
uh when you then go commit you actually

166
00:06:35,520 --> 00:06:36,720
have to validate that

167
00:06:36,720 --> 00:06:39,039
you read you know the re you have read

168
00:06:39,039 --> 00:06:40,560
the most recent objects

169
00:06:40,560 --> 00:06:42,800
uh and if so you can commit and if

170
00:06:42,800 --> 00:06:44,000
you're not you know you have to

171
00:06:44,000 --> 00:06:47,360
board and you know maybe try again and

172
00:06:47,360 --> 00:06:49,120
the reason they use optimism concurrence

173
00:06:49,120 --> 00:06:50,479
control as we'll see in a second is

174
00:06:50,479 --> 00:06:52,160
really driven by the fact that they want

175
00:06:52,160 --> 00:06:52,800
to use

176
00:06:52,800 --> 00:06:56,720
our dna um

177
00:06:56,720 --> 00:06:58,000
okay so then the final comment i want to

178
00:06:58,000 --> 00:06:59,680
make on this is sort of an overview this

179
00:06:59,680 --> 00:07:05,110
is really a research prototype

180
00:07:05,120 --> 00:07:08,160
so unlike uh spanner you know which is a

181
00:07:08,160 --> 00:07:09,199
deployed

182
00:07:09,199 --> 00:07:12,240
system that you know it's being in

183
00:07:12,240 --> 00:07:13,360
active use

184
00:07:13,360 --> 00:07:16,319
uh farm is really a product of the

185
00:07:16,319 --> 00:07:18,080
research arm of microsoft

186
00:07:18,080 --> 00:07:20,319
uh microsoft research trying to explore

187
00:07:20,319 --> 00:07:21,840
new ideas you know to

188
00:07:21,840 --> 00:07:25,680
see how to see if one can achieve higher

189
00:07:25,680 --> 00:07:27,280
or really high performance transaction

190
00:07:27,280 --> 00:07:28,880
systems and this is just a very active

191
00:07:28,880 --> 00:07:30,000
research

192
00:07:30,000 --> 00:07:33,120
people would just love to have the power

193
00:07:33,120 --> 00:07:34,720
of transactions

194
00:07:34,720 --> 00:07:40,390
and but also the the performance

195
00:07:40,400 --> 00:07:41,919
okay so that's sort of a short

196
00:07:41,919 --> 00:07:49,990
introduction any questions so far

197
00:07:50,000 --> 00:07:53,199
okay let's uh talk a little bit about

198
00:07:53,199 --> 00:07:59,280
the setup

199
00:07:59,280 --> 00:08:02,479
for farm and so there's basically

200
00:08:02,479 --> 00:08:10,150
90 machines

201
00:08:12,950 --> 00:08:12,960
90 of these guys they're connected uh by

202
00:08:12,960 --> 00:08:14,240
a high-speed

203
00:08:14,240 --> 00:08:16,400
data center network uh and you'll see a

204
00:08:16,400 --> 00:08:17,440
particular one

205
00:08:17,440 --> 00:08:20,000
i'm just going to draw that as a single

206
00:08:20,000 --> 00:08:20,479
line

207
00:08:20,479 --> 00:08:21,840
of course it's a switch network

208
00:08:21,840 --> 00:08:24,160
internally

209
00:08:24,160 --> 00:08:27,199
and uh and basically charts

210
00:08:27,199 --> 00:08:29,360
you know the data is sharded across uh

211
00:08:29,360 --> 00:08:30,400
these uh different

212
00:08:30,400 --> 00:08:34,159
uh machines and the the

213
00:08:34,159 --> 00:08:35,519
level of sharding happens at the

214
00:08:35,519 --> 00:08:37,839
something else called the region

215
00:08:37,839 --> 00:08:41,519
so region is two

216
00:08:41,519 --> 00:08:44,710
gigabyte

217
00:08:44,720 --> 00:08:46,240
and you know those regions are sharded

218
00:08:46,240 --> 00:08:48,160
across in different networks

219
00:08:48,160 --> 00:08:50,240
and the different machines the regions

220
00:08:50,240 --> 00:08:51,920
live in memory

221
00:08:51,920 --> 00:08:56,870
so this is just drm

222
00:08:56,880 --> 00:08:59,760
and not in for example on the disk and

223
00:08:59,760 --> 00:09:00,080
so

224
00:09:00,080 --> 00:09:03,839
basically uh the total data set

225
00:09:03,839 --> 00:09:06,160
of your database actually has to fit in

226
00:09:06,160 --> 00:09:07,519
the joint

227
00:09:07,519 --> 00:09:09,120
drams of the machine that you're using

228
00:09:09,120 --> 00:09:10,720
so if your data set is larger than your

229
00:09:10,720 --> 00:09:12,000
current set of machines you have to buy

230
00:09:12,000 --> 00:09:13,760
more machines to get more dram so they

231
00:09:13,760 --> 00:09:16,080
can actually fit

232
00:09:16,080 --> 00:09:18,720
and again the reason why you know they

233
00:09:18,720 --> 00:09:20,240
want to use dram is because you know

234
00:09:20,240 --> 00:09:22,720
they want no one really bottlenecked by

235
00:09:22,720 --> 00:09:26,240
the performance of uh storage devices

236
00:09:26,240 --> 00:09:29,279
and uh so of course you know machine can

237
00:09:29,279 --> 00:09:29,760
fail

238
00:09:29,760 --> 00:09:32,000
and if the machine fails it uses a loses

239
00:09:32,000 --> 00:09:32,880
a drm

240
00:09:32,880 --> 00:09:35,279
uh and so therefore they use replication

241
00:09:35,279 --> 00:09:36,000
and so they

242
00:09:36,000 --> 00:09:37,839
replicate regions across multiple

243
00:09:37,839 --> 00:09:40,240
machines one machine is the

244
00:09:40,240 --> 00:09:42,959
primary for a region and the same

245
00:09:42,959 --> 00:09:43,680
machine

246
00:09:43,680 --> 00:09:45,440
region might be replicated on another

247
00:09:45,440 --> 00:09:47,360
machine which is then a backdrop so you

248
00:09:47,360 --> 00:09:49,200
use primary backup for

249
00:09:49,200 --> 00:09:52,880
uh uh for replication

250
00:09:52,880 --> 00:09:56,160
and so this is region one you know

251
00:09:56,160 --> 00:09:56,880
region two

252
00:09:56,880 --> 00:09:58,959
you know the backup might be on the same

253
00:09:58,959 --> 00:10:00,800
machine as the primary for

254
00:10:00,800 --> 00:10:03,920
backup for region two and here you know

255
00:10:03,920 --> 00:10:05,120
we have the private

256
00:10:05,120 --> 00:10:08,560
region too and so this deals

257
00:10:08,560 --> 00:10:10,480
you know so that one machine has a

258
00:10:10,480 --> 00:10:12,560
kernel panic or some device and goes

259
00:10:12,560 --> 00:10:13,040
that

260
00:10:13,040 --> 00:10:15,360
or you know just crashes you know for

261
00:10:15,360 --> 00:10:16,480
some other reason

262
00:10:16,480 --> 00:10:19,200
then uh there's a second machine that

263
00:10:19,200 --> 00:10:20,480
actually has a copy

264
00:10:20,480 --> 00:10:21,920
of the data and just could proceed from

265
00:10:21,920 --> 00:10:23,760
there of course

266
00:10:23,760 --> 00:10:25,200
then we need some you know way of

267
00:10:25,200 --> 00:10:27,920
keeping track of the mapping from

268
00:10:27,920 --> 00:10:31,519
uh regions to uh

269
00:10:31,519 --> 00:10:34,000
primaries and backups and so they use a

270
00:10:34,000 --> 00:10:35,040
configuration

271
00:10:35,040 --> 00:10:39,279
manager a cm that sits on the site

272
00:10:39,279 --> 00:10:41,440
and she himself actually is coupled you

273
00:10:41,440 --> 00:10:42,959
know with a system that we've seen

274
00:10:42,959 --> 00:10:43,360
before

275
00:10:43,360 --> 00:10:46,720
zookeeper and it's really the

276
00:10:46,720 --> 00:10:48,800
zookeeper and the configuration

277
00:10:48,800 --> 00:10:50,320
management that keep track

278
00:10:50,320 --> 00:10:54,949
of the mapping

279
00:10:54,959 --> 00:10:59,190
you know from region number

280
00:10:59,200 --> 00:11:04,630
to the primary and whatever the backups

281
00:11:04,640 --> 00:11:08,160
for every region okay

282
00:11:08,160 --> 00:11:11,200
um now there's one

283
00:11:11,200 --> 00:11:13,839
uh series problem of course here uh i

284
00:11:13,839 --> 00:11:15,279
talked about like well primary

285
00:11:15,279 --> 00:11:16,880
we have primary backup replication great

286
00:11:16,880 --> 00:11:18,399
so we have false

287
00:11:18,399 --> 00:11:20,320
then i know one mission can fail now the

288
00:11:20,320 --> 00:11:21,600
machine can take over

289
00:11:21,600 --> 00:11:23,360
uh because except you know the one sort

290
00:11:23,360 --> 00:11:25,360
of tricky case that this scheme can't

291
00:11:25,360 --> 00:11:26,399
handle

292
00:11:26,399 --> 00:11:28,640
so far is when there's a correlated

293
00:11:28,640 --> 00:11:29,920
failure for example there's a power

294
00:11:29,920 --> 00:11:31,600
failure of the data center

295
00:11:31,600 --> 00:11:34,480
and all machines now go down and to

296
00:11:34,480 --> 00:11:36,079
handle that case

297
00:11:36,079 --> 00:11:39,279
basically the dram uh has

298
00:11:39,279 --> 00:11:41,680
sits on a ups where every machine sits

299
00:11:41,680 --> 00:11:44,480
on an uninterruptible power supply

300
00:11:44,480 --> 00:11:45,839
so we're going to draw this as like a

301
00:11:45,839 --> 00:11:54,470
big battery that sits on the site

302
00:11:54,480 --> 00:11:57,279
and uh the battery basically or the ups

303
00:11:57,279 --> 00:11:58,880
you know provides enough energy

304
00:11:58,880 --> 00:12:01,600
that uh if there's a global power

305
00:12:01,600 --> 00:12:02,480
failure

306
00:12:02,480 --> 00:12:04,240
uh the machine can keep running for a

307
00:12:04,240 --> 00:12:06,480
little time and in that little time

308
00:12:06,480 --> 00:12:08,399
uh the machine can actually store you

309
00:12:08,399 --> 00:12:10,240
know the farm will actually store the

310
00:12:10,240 --> 00:12:11,839
data on

311
00:12:11,839 --> 00:12:14,880
on ssds or basically it just flushes you

312
00:12:14,880 --> 00:12:16,720
know the content of its memory

313
00:12:16,720 --> 00:12:19,600
all the regions all the transaction

314
00:12:19,600 --> 00:12:20,160
state

315
00:12:20,160 --> 00:12:24,079
all the logs for the transactions it

316
00:12:24,079 --> 00:12:25,920
actually flushes it to an ssd so if

317
00:12:25,920 --> 00:12:28,000
there's a complete power failure

318
00:12:28,000 --> 00:12:30,480
of the whole data center the data center

319
00:12:30,480 --> 00:12:31,600
at some point will come back

320
00:12:31,600 --> 00:12:34,880
up and they can load you know the memory

321
00:12:34,880 --> 00:12:37,760
contents of the machines from the ssd

322
00:12:37,760 --> 00:12:40,720
and start basically running again and so

323
00:12:40,720 --> 00:12:42,480
this is basically the only place

324
00:12:42,480 --> 00:12:45,600
where the ssds are being used

325
00:12:45,600 --> 00:12:48,720
to deal with a correlated failure of

326
00:12:48,720 --> 00:12:53,680
many machines in the data center

327
00:12:53,680 --> 00:13:03,030
any questions so far

328
00:13:03,040 --> 00:13:04,880
okay now let me say a little bit about

329
00:13:04,880 --> 00:13:06,240
the software

330
00:13:06,240 --> 00:13:08,560
so in the regions so we have a region

331
00:13:08,560 --> 00:13:09,839
here

332
00:13:09,839 --> 00:13:13,279
in this region objects live

333
00:13:13,279 --> 00:13:15,279
so you can just think about an array

334
00:13:15,279 --> 00:13:16,720
region as an

335
00:13:16,720 --> 00:13:18,399
array of bytes you know two gigabytes of

336
00:13:18,399 --> 00:13:20,639
bikes and in you know the variation

337
00:13:20,639 --> 00:13:21,440
bytes

338
00:13:21,440 --> 00:13:24,560
objects live and objects have a unique

339
00:13:24,560 --> 00:13:29,190
identifier

340
00:13:29,200 --> 00:13:33,200
an oid and the oid of an object is

341
00:13:33,200 --> 00:13:34,079
nothing else then

342
00:13:34,079 --> 00:13:37,360
it's region number triple

343
00:13:37,360 --> 00:13:40,079
the region number and then the address

344
00:13:40,079 --> 00:13:46,829
you know within that

345
00:13:46,839 --> 00:13:48,959
region

346
00:13:48,959 --> 00:13:52,240
uh associated with every uh object

347
00:13:52,240 --> 00:13:54,000
there's a little bit of metadata

348
00:13:54,000 --> 00:13:56,560
for that particular object and the

349
00:13:56,560 --> 00:13:57,279
particular

350
00:13:57,279 --> 00:14:00,399
uh for the object header contains

351
00:14:00,399 --> 00:14:05,910
a 64-bit number

352
00:14:05,920 --> 00:14:09,680
and the number consists is basically

353
00:14:09,680 --> 00:14:13,430
a version number

354
00:14:13,440 --> 00:14:16,240
in the bottom 63 and then a lock bit as

355
00:14:16,240 --> 00:14:17,199
we'll see

356
00:14:17,199 --> 00:14:21,279
in the top uh bit in the high order bit

357
00:14:21,279 --> 00:14:24,880
so every object has this uh you know 64

358
00:14:24,880 --> 00:14:26,160
bit number i'm just going to refer to it

359
00:14:26,160 --> 00:14:26,720
as a

360
00:14:26,720 --> 00:14:28,959
version number and then we'll see in a

361
00:14:28,959 --> 00:14:30,240
plays an important role

362
00:14:30,240 --> 00:14:33,760
in the optimus frequent currency control

363
00:14:33,760 --> 00:14:37,120
um the way applications

364
00:14:37,120 --> 00:14:40,560
uh use you know this system

365
00:14:40,560 --> 00:14:42,079
let me say a little bit about that so

366
00:14:42,079 --> 00:14:43,600
what sort of the application programmer

367
00:14:43,600 --> 00:14:53,030
interface

368
00:14:53,040 --> 00:14:59,990
so the api is your starter transaction

369
00:15:00,000 --> 00:15:05,350
then you read some objects

370
00:15:05,360 --> 00:15:07,680
so they're going to read a call and the

371
00:15:07,680 --> 00:15:09,519
read call takes an oid

372
00:15:09,519 --> 00:15:12,800
as an argument uh

373
00:15:12,800 --> 00:15:15,680
the application then the object can

374
00:15:15,680 --> 00:15:17,839
manipulate you know change the field

375
00:15:17,839 --> 00:15:20,639
in the in the object or whatever add one

376
00:15:20,639 --> 00:15:22,560
to it

377
00:15:22,560 --> 00:15:27,279
and then at some point right

378
00:15:27,279 --> 00:15:31,590
the object

379
00:15:31,600 --> 00:15:33,279
right there update the object itself

380
00:15:33,279 --> 00:15:35,680
using the right call and then you know

381
00:15:35,680 --> 00:15:37,600
commit it when you're using through tx

382
00:15:37,600 --> 00:15:41,279
and commit

383
00:15:41,279 --> 00:15:43,440
um you know it might also be the case

384
00:15:43,440 --> 00:15:44,560
that uh

385
00:15:44,560 --> 00:15:46,959
the transaction needs to abort or

386
00:15:46,959 --> 00:15:48,639
because of the optimism currency control

387
00:15:48,639 --> 00:15:49,839
and in that case

388
00:15:49,839 --> 00:15:51,360
uh the application will typically just

389
00:15:51,360 --> 00:15:55,279
retry the transaction um

390
00:15:55,279 --> 00:15:57,279
and so in the transaction the way it

391
00:15:57,279 --> 00:15:58,639
shows the transaction here there's only

392
00:15:58,639 --> 00:16:00,079
one object manipulated

393
00:16:00,079 --> 00:16:01,759
but the transaction could manipulate

394
00:16:01,759 --> 00:16:03,279
many many objects those objects could

395
00:16:03,279 --> 00:16:03,759
live in

396
00:16:03,759 --> 00:16:06,800
uh different regions and uh

397
00:16:06,800 --> 00:16:08,240
and so there you know they have to have

398
00:16:08,240 --> 00:16:10,320
some plan as we'll see for running some

399
00:16:10,320 --> 00:16:11,440
two-phase commit like

400
00:16:11,440 --> 00:16:14,639
protocol uh to do atomic operations

401
00:16:14,639 --> 00:16:15,600
across

402
00:16:15,600 --> 00:16:17,600
uh objects living in different uh

403
00:16:17,600 --> 00:16:20,079
regions

404
00:16:20,079 --> 00:16:23,519
any sort of questions about the api

405
00:16:23,519 --> 00:16:29,829
and the setup

406
00:16:29,839 --> 00:16:32,959
uh sorry the address oid it is

407
00:16:32,959 --> 00:16:36,880
the address in the machine itself

408
00:16:36,880 --> 00:16:39,920
yeah which is the uh or the offset uh

409
00:16:39,920 --> 00:16:46,310
within that region

410
00:16:46,320 --> 00:16:49,680
okay because regions can move correct

411
00:16:49,680 --> 00:16:50,240
you know

412
00:16:50,240 --> 00:16:52,079
if they re-replicate it or the

413
00:16:52,079 --> 00:16:54,160
configuration manager redesigns the

414
00:16:54,160 --> 00:16:54,959
mapping

415
00:16:54,959 --> 00:16:57,279
uh the actual address where the object

416
00:16:57,279 --> 00:16:58,480
lift might change

417
00:16:58,480 --> 00:17:00,160
uh so this is a region number plus an

418
00:17:00,160 --> 00:17:01,600
offset

419
00:17:01,600 --> 00:17:03,279
so if i'm a little bit better here i

420
00:17:03,279 --> 00:17:09,909
should set off it

421
00:17:09,919 --> 00:17:12,319
sorry i have another question kind of

422
00:17:12,319 --> 00:17:12,959
that

423
00:17:12,959 --> 00:17:15,600
um what was the design choice or design

424
00:17:15,600 --> 00:17:17,760
thinking behind making a global address

425
00:17:17,760 --> 00:17:19,280
space

426
00:17:19,280 --> 00:17:22,720
uh did you have everything in

427
00:17:22,720 --> 00:17:26,390
dram

428
00:17:26,400 --> 00:17:28,000
i'm not sure that answers your question

429
00:17:28,000 --> 00:17:32,160
but uh

430
00:17:32,160 --> 00:17:33,679
the whole goal of them is to actually

431
00:17:33,679 --> 00:17:35,520
run the transactions on an in-memory

432
00:17:35,520 --> 00:17:36,160
database

433
00:17:36,160 --> 00:17:37,440
you know sort of this is a whole trend

434
00:17:37,440 --> 00:17:39,120
of set of databases where all the data

435
00:17:39,120 --> 00:17:40,240
is always in memory it's called

436
00:17:40,240 --> 00:17:41,919
in-memory databases

437
00:17:41,919 --> 00:17:44,000
uh driven by the fact that you know dram

438
00:17:44,000 --> 00:17:45,200
is reasonably cheap

439
00:17:45,200 --> 00:17:47,280
and so that would allow you to basically

440
00:17:47,280 --> 00:17:48,320
run transactions

441
00:17:48,320 --> 00:17:49,760
without actually having to go to

442
00:17:49,760 --> 00:17:51,360
persistent storage and

443
00:17:51,360 --> 00:17:54,400
they're basically jumping on that uh

444
00:17:54,400 --> 00:17:58,240
train of in-memory databases

445
00:17:58,240 --> 00:18:00,480
i see and that requires like a global

446
00:18:00,480 --> 00:18:02,960
address space that they all share

447
00:18:02,960 --> 00:18:04,880
the address space is per machine right

448
00:18:04,880 --> 00:18:06,080
uh the

449
00:18:06,080 --> 00:18:07,760
uh every machine has its own address

450
00:18:07,760 --> 00:18:09,520
page from zero to whatever

451
00:18:09,520 --> 00:18:13,440
uh and the uh

452
00:18:13,440 --> 00:18:17,200
the the objects are really the global

453
00:18:17,200 --> 00:18:21,990
numbers for global names

454
00:18:22,000 --> 00:18:26,390
thank you

455
00:18:26,400 --> 00:18:30,320
okay good so let's uh talk so so far

456
00:18:30,320 --> 00:18:32,400
uh i think you know we basically sort of

457
00:18:32,400 --> 00:18:33,679
established that you know

458
00:18:33,679 --> 00:18:35,520
they sort of gotten the stable storage

459
00:18:35,520 --> 00:18:37,200
devices out of the way

460
00:18:37,200 --> 00:18:40,799
and so there's no bottleneck for

461
00:18:40,799 --> 00:18:42,240
reading writing storage devices because

462
00:18:42,240 --> 00:18:44,000
they're basically not using them

463
00:18:44,000 --> 00:18:46,400
other than in this one exceptional case

464
00:18:46,400 --> 00:18:47,120
when the

465
00:18:47,120 --> 00:18:50,160
power fails and so the next set of

466
00:18:50,160 --> 00:18:51,440
things their focus on

467
00:18:51,440 --> 00:18:54,870
is trying to reduce

468
00:18:54,880 --> 00:18:56,640
cpu utilization or try to be very

469
00:18:56,640 --> 00:18:58,320
efficient with the cpu and be very

470
00:18:58,320 --> 00:19:00,799
efficient at the network

471
00:19:00,799 --> 00:19:04,000
and the there's two uh key ideas here

472
00:19:04,000 --> 00:19:04,480
that

473
00:19:04,480 --> 00:19:07,280
are pretty well known so the first one

474
00:19:07,280 --> 00:19:20,870
is kernel bypass

475
00:19:20,880 --> 00:19:24,240
and the the story of that is reasonably

476
00:19:24,240 --> 00:19:24,960
simple

477
00:19:24,960 --> 00:19:26,799
so we have farm that runs as a user

478
00:19:26,799 --> 00:19:31,909
level process

479
00:19:31,919 --> 00:19:34,480
on top of windows the windows operating

480
00:19:34,480 --> 00:19:36,640
system so here's the operating system

481
00:19:36,640 --> 00:19:38,320
so let's move a little bit on the side

482
00:19:38,320 --> 00:19:40,240
so here's the operating system

483
00:19:40,240 --> 00:19:41,679
and the operating system of course has

484
00:19:41,679 --> 00:19:43,520
you know all the features for scheduling

485
00:19:43,520 --> 00:19:45,679
processes from a virtual memory

486
00:19:45,679 --> 00:19:48,880
a standard operating system and it also

487
00:19:48,880 --> 00:19:51,440
has drivers for hardware

488
00:19:51,440 --> 00:19:53,760
devices and like one of the hardware

489
00:19:53,760 --> 00:19:54,480
devices

490
00:19:54,480 --> 00:20:00,470
is a network interface card

491
00:20:00,480 --> 00:20:02,960
and you know typically you know the oss

492
00:20:02,960 --> 00:20:03,760
driver

493
00:20:03,760 --> 00:20:08,080
inside of it that uh

494
00:20:08,080 --> 00:20:09,840
programs in the network interface card

495
00:20:09,840 --> 00:20:11,679
so the reach and write registers on the

496
00:20:11,679 --> 00:20:13,360
network interface card to basically send

497
00:20:13,360 --> 00:20:14,799
like send a packet

498
00:20:14,799 --> 00:20:16,880
or to reconfigure the network interface

499
00:20:16,880 --> 00:20:19,440
card et cetera et cetera

500
00:20:19,440 --> 00:20:21,280
and so the typical way you know that you

501
00:20:21,280 --> 00:20:23,039
know applications interact

502
00:20:23,039 --> 00:20:25,520
with the network cart is they make you

503
00:20:25,520 --> 00:20:26,559
know system calls

504
00:20:26,559 --> 00:20:29,200
you know to do the kernel and ask the

505
00:20:29,200 --> 00:20:31,760
kernel to basically send a packet

506
00:20:31,760 --> 00:20:33,760
uh and that you know involves you know

507
00:20:33,760 --> 00:20:35,120
the operating system that follows the

508
00:20:35,120 --> 00:20:37,200
tcp stack the network stack

509
00:20:37,200 --> 00:20:38,960
uh and it tends to be you know quite

510
00:20:38,960 --> 00:20:40,240
expensive

511
00:20:40,240 --> 00:20:43,919
um and so they want to avoid this uh uh

512
00:20:43,919 --> 00:20:45,600
this overhead you know go in entering

513
00:20:45,600 --> 00:20:48,559
the kernel running tcp etc and the way

514
00:20:48,559 --> 00:20:49,679
they do that is something there's a

515
00:20:49,679 --> 00:20:50,320
technique called

516
00:20:50,320 --> 00:20:52,720
a kernel bypass and if the network is

517
00:20:52,720 --> 00:20:54,080
sort of a collaboration between the

518
00:20:54,080 --> 00:20:55,280
network card

519
00:20:55,280 --> 00:20:57,440
and the operating system and basically

520
00:20:57,440 --> 00:20:58,400
what it does

521
00:20:58,400 --> 00:21:00,159
uh is that the cues that the network

522
00:21:00,159 --> 00:21:02,720
interface has so here's a set of queues

523
00:21:02,720 --> 00:21:04,320
for example send queue and the receive

524
00:21:04,320 --> 00:21:06,320
queue those queues are basically

525
00:21:06,320 --> 00:21:06,880
directly

526
00:21:06,880 --> 00:21:10,320
mapped or into the address space of the

527
00:21:10,320 --> 00:21:12,960
application so the application can ask

528
00:21:12,960 --> 00:21:13,440
you know

529
00:21:13,440 --> 00:21:15,280
operating system please you know take

530
00:21:15,280 --> 00:21:16,640
some uh

531
00:21:16,640 --> 00:21:19,280
cues that the nick has and map them into

532
00:21:19,280 --> 00:21:21,120
the address space of the application

533
00:21:21,120 --> 00:21:22,799
and so you can just think about this as

534
00:21:22,799 --> 00:21:25,760
huge as basically is directly accessible

535
00:21:25,760 --> 00:21:28,320
uh from the user level application so

536
00:21:28,320 --> 00:21:30,159
the user level application you know can

537
00:21:30,159 --> 00:21:31,440
basically now read and write

538
00:21:31,440 --> 00:21:33,840
you know commands or packets into the

539
00:21:33,840 --> 00:21:35,280
network interface card

540
00:21:35,280 --> 00:21:38,000
without actually having to involve the

541
00:21:38,000 --> 00:21:39,200
operating system at all

542
00:21:39,200 --> 00:21:40,480
and so this cuts the whole operating

543
00:21:40,480 --> 00:21:43,280
system out of the picture and

544
00:21:43,280 --> 00:21:44,640
improves you know performance

545
00:21:44,640 --> 00:21:46,400
considerably

546
00:21:46,400 --> 00:21:48,400
in the case of farm uh they also don't

547
00:21:48,400 --> 00:21:49,600
want to use interrupts so

548
00:21:49,600 --> 00:21:51,440
one way of delivering a packet correct

549
00:21:51,440 --> 00:21:52,720
is the packet comes in the network

550
00:21:52,720 --> 00:21:54,480
interface card delivers an interrupt

551
00:21:54,480 --> 00:21:55,919
to the operating system the operating

552
00:21:55,919 --> 00:21:59,360
system then alerts the application that

553
00:21:59,360 --> 00:22:02,400
the packet has arrived and informally

554
00:22:02,400 --> 00:22:04,000
try to avoid that cost and the way they

555
00:22:04,000 --> 00:22:05,440
follow that cost is basically

556
00:22:05,440 --> 00:22:09,760
they pull the receive queue

557
00:22:09,760 --> 00:22:11,600
so there's basically an usual level

558
00:22:11,600 --> 00:22:13,120
thread you know that

559
00:22:13,120 --> 00:22:16,000
sits in the farm application and it

560
00:22:16,000 --> 00:22:17,600
basically does nothing else than sort of

561
00:22:17,600 --> 00:22:18,480
reading

562
00:22:18,480 --> 00:22:20,799
uh the receive queue to see if actually

563
00:22:20,799 --> 00:22:23,440
packet is available

564
00:22:23,440 --> 00:22:25,760
and so that requires no immediate

565
00:22:25,760 --> 00:22:27,840
vibration so that avoids the use of

566
00:22:27,840 --> 00:22:31,120
interrupts uh and uh you know at the

567
00:22:31,120 --> 00:22:33,200
cost of basically having a polling uh

568
00:22:33,200 --> 00:22:35,440
threat uh that's you know sits there

569
00:22:35,440 --> 00:22:37,360
doing nothing else and pulling

570
00:22:37,360 --> 00:22:39,360
and environment turns out there are this

571
00:22:39,360 --> 00:22:41,200
thread actually switches back and forth

572
00:22:41,200 --> 00:22:42,880
between running some application code

573
00:22:42,880 --> 00:22:43,760
and

574
00:22:43,760 --> 00:22:47,280
pulling uh the nic so that's sort of

575
00:22:47,280 --> 00:22:49,440
kernel bypass

576
00:22:49,440 --> 00:22:52,000
and you know this is reasonable standard

577
00:22:52,000 --> 00:22:53,039
some people may

578
00:22:53,039 --> 00:22:58,630
some of you may know familiar with the

579
00:22:58,640 --> 00:23:03,200
bbjk which is a data plane

580
00:23:03,200 --> 00:23:06,320
development kit which is a development

581
00:23:06,320 --> 00:23:07,760
kit to

582
00:23:07,760 --> 00:23:09,200
basically leverage you know kernel

583
00:23:09,200 --> 00:23:11,760
bypass so there's a reasonable standard

584
00:23:11,760 --> 00:23:13,280
thing

585
00:23:13,280 --> 00:23:15,200
and it's available on many operating

586
00:23:15,200 --> 00:23:16,720
systems

587
00:23:16,720 --> 00:23:18,640
um so then the next you know sort of

588
00:23:18,640 --> 00:23:20,240
piece of technology that use

589
00:23:20,240 --> 00:23:23,120
uh is a little bit also well known as

590
00:23:23,120 --> 00:23:24,400
widely standardized

591
00:23:24,400 --> 00:23:27,440
many network cards uh supported uh

592
00:23:27,440 --> 00:23:30,159
or more high-end network cards supported

593
00:23:30,159 --> 00:23:30,559
and that's

594
00:23:30,559 --> 00:23:36,159
something that's called rdma

595
00:23:36,159 --> 00:23:40,710
which stands for remote

596
00:23:40,720 --> 00:23:50,799
remote direct memory access

597
00:23:50,799 --> 00:23:52,960
and the basic idea is that uh you know

598
00:23:52,960 --> 00:23:53,919
this requires

599
00:23:53,919 --> 00:23:58,000
uh nics that actually understand uh rdma

600
00:23:58,000 --> 00:24:00,720
and so you know here with cable here we

601
00:24:00,720 --> 00:24:01,039
have

602
00:24:01,039 --> 00:24:03,279
nick on the other side the operating

603
00:24:03,279 --> 00:24:05,440
system may be sitting on top of it

604
00:24:05,440 --> 00:24:12,789
you know we here we have farm

605
00:24:12,799 --> 00:24:17,200
and then um and basically you know the

606
00:24:17,200 --> 00:24:18,960
application on this site on the center

607
00:24:18,960 --> 00:24:20,640
side you know can basically put

608
00:24:20,640 --> 00:24:24,320
a particular packet into the send queue

609
00:24:24,320 --> 00:24:27,679
um and you know send an rdma

610
00:24:27,679 --> 00:24:30,000
packet so basically somewhere it is a

611
00:24:30,000 --> 00:24:31,039
bit in

612
00:24:31,039 --> 00:24:32,880
the header of the packet saying like hey

613
00:24:32,880 --> 00:24:35,279
i'm an rdna packet

614
00:24:35,279 --> 00:24:37,039
and then the nick will send it over to

615
00:24:37,039 --> 00:24:39,279
the nick the destination deck

616
00:24:39,279 --> 00:24:41,760
the destination x sees that this is a

617
00:24:41,760 --> 00:24:43,840
special packet in rdma packet

618
00:24:43,840 --> 00:24:45,440
and looks at the instruction that you

619
00:24:45,440 --> 00:24:47,600
know goes along with the rdma package

620
00:24:47,600 --> 00:24:49,120
and so the instruction might be

621
00:24:49,120 --> 00:24:50,640
you know read a particular memory

622
00:24:50,640 --> 00:24:52,080
location or write a particular manual

623
00:24:52,080 --> 00:24:53,120
location

624
00:24:53,120 --> 00:24:55,120
so here so for example let's say it's a

625
00:24:55,120 --> 00:24:59,350
read operation

626
00:24:59,360 --> 00:25:01,440
and the read operation essentially takes

627
00:25:01,440 --> 00:25:03,679
an address

628
00:25:03,679 --> 00:25:06,720
and it allows the nic to basically

629
00:25:06,720 --> 00:25:09,840
read that address straight out of

630
00:25:09,840 --> 00:25:11,840
memory out of ram so for example let's

631
00:25:11,840 --> 00:25:13,039
say you know here

632
00:25:13,039 --> 00:25:16,559
we have our region you know with objects

633
00:25:16,559 --> 00:25:18,080
in it

634
00:25:18,080 --> 00:25:21,360
and uh the

635
00:25:21,360 --> 00:25:24,880
sending uh farm uh application can just

636
00:25:24,880 --> 00:25:25,440
say

637
00:25:25,440 --> 00:25:28,880
okay i want to read you know the the

638
00:25:28,880 --> 00:25:30,799
this particular address you know which

639
00:25:30,799 --> 00:25:32,159
makes it correspond to this

640
00:25:32,159 --> 00:25:35,200
address with this object o and uh we'll

641
00:25:35,200 --> 00:25:35,679
send

642
00:25:35,679 --> 00:25:37,760
an rdma packet to the neck on the other

643
00:25:37,760 --> 00:25:39,760
side

644
00:25:39,760 --> 00:25:42,159
the next is that there's an rdma packet

645
00:25:42,159 --> 00:25:43,200
and

646
00:25:43,200 --> 00:25:45,200
you know basically reads you know from

647
00:25:45,200 --> 00:25:47,440
memory the value is stored at that

648
00:25:47,440 --> 00:25:48,880
particular location

649
00:25:48,880 --> 00:25:51,120
and sends them straight back you know to

650
00:25:51,120 --> 00:25:52,640
the

651
00:25:52,640 --> 00:25:55,600
source and what is cool about this

652
00:25:55,600 --> 00:25:56,799
technology

653
00:25:56,799 --> 00:25:59,600
is that uh the nick can do this without

654
00:25:59,600 --> 00:26:00,240
actually

655
00:26:00,240 --> 00:26:03,120
interrupting or interfering with the

656
00:26:03,120 --> 00:26:04,400
server at all

657
00:26:04,400 --> 00:26:05,760
uh it doesn't have to generate an

658
00:26:05,760 --> 00:26:07,440
interrupt it doesn't have to run any

659
00:26:07,440 --> 00:26:08,320
code

660
00:26:08,320 --> 00:26:11,520
on the uh the processors that run the

661
00:26:11,520 --> 00:26:13,360
operating system in the application

662
00:26:13,360 --> 00:26:15,760
instead you know the nikkei has firmware

663
00:26:15,760 --> 00:26:17,520
uh that runs you know executes those

664
00:26:17,520 --> 00:26:18,400
instructions

665
00:26:18,400 --> 00:26:21,919
and loads you know the uh values stored

666
00:26:21,919 --> 00:26:22,640
to those members

667
00:26:22,640 --> 00:26:24,320
at the requested memory addresses you

668
00:26:24,320 --> 00:26:26,240
know straight into a response packet and

669
00:26:26,240 --> 00:26:27,919
essentially responds back it back

670
00:26:27,919 --> 00:26:30,080
and then of course on the receiving side

671
00:26:30,080 --> 00:26:31,520
you know that will show up in the

672
00:26:31,520 --> 00:26:32,559
receive queue

673
00:26:32,559 --> 00:26:34,320
and so far i'm you know at some point

674
00:26:34,320 --> 00:26:35,840
you know we'll hold the receive queue

675
00:26:35,840 --> 00:26:37,600
and see actually you know the result of

676
00:26:37,600 --> 00:26:38,000
that

677
00:26:38,000 --> 00:26:41,750
rdma

678
00:26:41,760 --> 00:26:43,760
this this particular version that i've

679
00:26:43,760 --> 00:26:45,039
been describing here

680
00:26:45,039 --> 00:26:50,830
the paper refers to as one-sided

681
00:26:50,840 --> 00:26:53,120
rdma

682
00:26:53,120 --> 00:26:54,720
and that typically refers in the paper

683
00:26:54,720 --> 00:26:56,799
to uh

684
00:26:56,799 --> 00:27:00,480
uh read operations

685
00:27:00,480 --> 00:27:03,590
um

686
00:27:03,600 --> 00:27:06,400
yeah go ahead sorry professor can you uh

687
00:27:06,400 --> 00:27:07,200
can you repeat

688
00:27:07,200 --> 00:27:10,559
how how the polling of the um

689
00:27:10,559 --> 00:27:13,840
like nick cues works on the on a client

690
00:27:13,840 --> 00:27:17,200
or yeah on like there's almost

691
00:27:17,200 --> 00:27:20,399
nothing to it uh the the

692
00:27:20,399 --> 00:27:23,760
client uh just has a thread that reads a

693
00:27:23,760 --> 00:27:25,520
particular memory location

694
00:27:25,520 --> 00:27:27,919
and uh which indicates whether a packet

695
00:27:27,919 --> 00:27:29,279
is arrived or not

696
00:27:29,279 --> 00:27:31,520
and when the nic receives a packet it

697
00:27:31,520 --> 00:27:33,120
sticks it in the

698
00:27:33,120 --> 00:27:35,440
receive queue and as a side of set

699
00:27:35,440 --> 00:27:36,960
setting in the receive queue you know

700
00:27:36,960 --> 00:27:37,520
the

701
00:27:37,520 --> 00:27:40,720
flag the bit you know turns into a one

702
00:27:40,720 --> 00:27:42,480
and the application knows oh yeah you

703
00:27:42,480 --> 00:27:45,990
know there's a packet there

704
00:27:46,000 --> 00:27:48,799
um is it a specific thread that you know

705
00:27:48,799 --> 00:27:49,760
that paul's all

706
00:27:49,760 --> 00:27:51,520
like yeah and they're they're in their

707
00:27:51,520 --> 00:27:53,440
system they have specific threads that

708
00:27:53,440 --> 00:27:53,919
actually

709
00:27:53,919 --> 00:27:59,430
are dedicated to pulling uh the cues

710
00:27:59,440 --> 00:28:02,960
thanks sorry i'm not confused here so

711
00:28:02,960 --> 00:28:04,720
does the knee cooperate with the system

712
00:28:04,720 --> 00:28:06,480
or is it regularly doing the job

713
00:28:06,480 --> 00:28:11,440
like as in any regular leg um

714
00:28:11,440 --> 00:28:12,880
this is not a you know whatever your

715
00:28:12,880 --> 00:28:14,480
standard nick right

716
00:28:14,480 --> 00:28:16,240
there's a nick that supports both kernel

717
00:28:16,240 --> 00:28:18,000
bypass and

718
00:28:18,000 --> 00:28:21,279
uh remote direct reaction and rgma

719
00:28:21,279 --> 00:28:26,159
uh and typically for nick to support uh

720
00:28:26,159 --> 00:28:27,679
kernel bypass it means it has to have

721
00:28:27,679 --> 00:28:30,159
multiple receive send queues

722
00:28:30,159 --> 00:28:31,840
and it just gives a pair to send the

723
00:28:31,840 --> 00:28:34,159
receive queues to an application

724
00:28:34,159 --> 00:28:36,559
uh and it cannot like of course you know

725
00:28:36,559 --> 00:28:37,679
you can't have

726
00:28:37,679 --> 00:28:39,679
a send receive queue for every process

727
00:28:39,679 --> 00:28:41,200
running on your machine

728
00:28:41,200 --> 00:28:42,799
so typically there are like 16 of them

729
00:28:42,799 --> 00:28:45,360
or 32 of them and you know get some of

730
00:28:45,360 --> 00:28:46,640
them you know to a particular

731
00:28:46,640 --> 00:28:48,880
os basically allows some applications to

732
00:28:48,880 --> 00:28:50,159
own basically

733
00:28:50,159 --> 00:28:53,360
uh a center receive queue

734
00:28:53,360 --> 00:28:56,000
so much and that also means there's some

735
00:28:56,000 --> 00:28:57,760
specific support for dma

736
00:28:57,760 --> 00:29:00,880
and make that all work out so you know

737
00:29:00,880 --> 00:29:02,880
so this requires a nick that is

738
00:29:02,880 --> 00:29:04,080
reasonable sophisticated although it's

739
00:29:04,080 --> 00:29:07,039
in a reasonable standard these days

740
00:29:07,039 --> 00:29:10,240
okay so that's one-sided uh rdma they

741
00:29:10,240 --> 00:29:10,960
also use

742
00:29:10,960 --> 00:29:14,399
rdma to do writes and

743
00:29:14,399 --> 00:29:18,000
to actually implement rpc and so

744
00:29:18,000 --> 00:29:21,520
there's a they typically call this write

745
00:29:21,520 --> 00:29:25,120
argument in the paper it's basically the

746
00:29:25,120 --> 00:29:28,070
same thing

747
00:29:28,080 --> 00:29:30,080
except you know the sender can put in

748
00:29:30,080 --> 00:29:31,919
the rdma packet

749
00:29:31,919 --> 00:29:33,600
uh saying like oh this is the right

750
00:29:33,600 --> 00:29:35,679
operation and right you know the

751
00:29:35,679 --> 00:29:37,360
the following bytes to a particular

752
00:29:37,360 --> 00:29:39,360
address and

753
00:29:39,360 --> 00:29:42,720
the paper uses two places or two things

754
00:29:42,720 --> 00:29:43,120
where

755
00:29:43,120 --> 00:29:45,840
rights are actually going to uh objects

756
00:29:45,840 --> 00:29:46,480
are never really

757
00:29:46,480 --> 00:29:49,039
written directly with rdma but there's

758
00:29:49,039 --> 00:29:49,679
two other

759
00:29:49,679 --> 00:29:51,279
data structures that are being written

760
00:29:51,279 --> 00:29:53,039
with uh right rdmas

761
00:29:53,039 --> 00:29:56,070
one is a log

762
00:29:56,080 --> 00:30:00,630
and you'll see the role of the log later

763
00:30:00,640 --> 00:30:01,760
and this is like related for the

764
00:30:01,760 --> 00:30:03,840
transaction so it has commit records

765
00:30:03,840 --> 00:30:06,559
locking records uh et cetera et cetera

766
00:30:06,559 --> 00:30:08,480
and so if the source you know wants to

767
00:30:08,480 --> 00:30:10,080
append a lock record

768
00:30:10,080 --> 00:30:12,159
uh to this particular log you know it

769
00:30:12,159 --> 00:30:13,360
can just do right

770
00:30:13,360 --> 00:30:16,799
you know rdma and uh and then

771
00:30:16,799 --> 00:30:18,480
the receiving nick will just you know

772
00:30:18,480 --> 00:30:20,000
add you know the

773
00:30:20,000 --> 00:30:22,960
new entry in the log you know to the uh

774
00:30:22,960 --> 00:30:25,039
specified location

775
00:30:25,039 --> 00:30:28,480
okay um and so that means like the

776
00:30:28,480 --> 00:30:29,279
sender

777
00:30:29,279 --> 00:30:31,279
and there's one of these cues and one of

778
00:30:31,279 --> 00:30:32,640
these logs is per

779
00:30:32,640 --> 00:30:34,880
uh send and receive a pair so that the

780
00:30:34,880 --> 00:30:36,080
sender direction can manage

781
00:30:36,080 --> 00:30:37,440
and know what the beginning and the end

782
00:30:37,440 --> 00:30:40,159
of the log are

783
00:30:40,159 --> 00:30:42,640
then in addition to that there's some

784
00:30:42,640 --> 00:30:46,630
there are message cues

785
00:30:46,640 --> 00:30:51,279
and also a one pers pair

786
00:30:51,279 --> 00:30:52,880
and these are basically used to

787
00:30:52,880 --> 00:30:55,520
implement rpcs

788
00:30:55,520 --> 00:30:57,360
so if you want to do a remote procedure

789
00:30:57,360 --> 00:30:58,640
call

790
00:30:58,640 --> 00:31:02,000
the client the the sender

791
00:31:02,000 --> 00:31:05,039
makes and write rdm rdma packet right

792
00:31:05,039 --> 00:31:06,720
you know the data the message basically

793
00:31:06,720 --> 00:31:07,600
into the

794
00:31:07,600 --> 00:31:10,960
remote message queue there's a thread

795
00:31:10,960 --> 00:31:12,240
sitting

796
00:31:12,240 --> 00:31:14,159
on the destination site that is

797
00:31:14,159 --> 00:31:16,799
basically pulling that message queue or

798
00:31:16,799 --> 00:31:19,039
pulling all the message queues if it

799
00:31:19,039 --> 00:31:20,720
sees a message you know it processes the

800
00:31:20,720 --> 00:31:21,360
message

801
00:31:21,360 --> 00:31:24,559
and can then send a response back using

802
00:31:24,559 --> 00:31:32,480
a write rdma

803
00:31:32,480 --> 00:31:34,480
uh and this turns out to be uh you know

804
00:31:34,480 --> 00:31:35,600
cheaper you know

805
00:31:35,600 --> 00:31:37,200
implementing root measure calls using

806
00:31:37,200 --> 00:31:39,279
rdma that turns out to be cheaper than

807
00:31:39,279 --> 00:31:39,919
basically

808
00:31:39,919 --> 00:31:43,519
uh using sort of a standard rpc package

809
00:31:43,519 --> 00:31:46,880
that you know uh since uh

810
00:31:46,880 --> 00:31:48,720
just package using a regular nick but

811
00:31:48,720 --> 00:31:50,159
without rdma

812
00:31:50,159 --> 00:31:51,840
and has a thread on the other side you

813
00:31:51,840 --> 00:31:54,240
know the response

814
00:31:54,240 --> 00:31:57,919
okay um so is there any validation step

815
00:31:57,919 --> 00:31:59,279
here to make sure that

816
00:31:59,279 --> 00:32:01,279
you're you're only writing to a region

817
00:32:01,279 --> 00:32:03,360
of memory that's like expressly allowed

818
00:32:03,360 --> 00:32:05,120
for rdma you know it's like you don't

819
00:32:05,120 --> 00:32:07,120
write applicate onto application memory

820
00:32:07,120 --> 00:32:07,840
or something

821
00:32:07,840 --> 00:32:10,000
yeah so there's all kinds of you know

822
00:32:10,000 --> 00:32:11,600
this is sort of the high level idea

823
00:32:11,600 --> 00:32:14,080
uh there's all kinds of details here um

824
00:32:14,080 --> 00:32:15,200
so when

825
00:32:15,200 --> 00:32:21,029
uh you sort of set up one of these rda

826
00:32:21,039 --> 00:32:23,279
in order to do these one-sided rdmas or

827
00:32:23,279 --> 00:32:24,480
write rdmas

828
00:32:24,480 --> 00:32:26,240
you first have to do a connection setup

829
00:32:26,240 --> 00:32:27,600
so there's a negation

830
00:32:27,600 --> 00:32:29,919
negotiation step between the sender and

831
00:32:29,919 --> 00:32:30,880
the receiver

832
00:32:30,880 --> 00:32:33,120
uh to set up uh basically like it's

833
00:32:33,120 --> 00:32:34,640
almost like a tcp channel except you

834
00:32:34,640 --> 00:32:35,760
know rdma

835
00:32:35,760 --> 00:32:38,039
doesn't use tcp but it sets up a

836
00:32:38,039 --> 00:32:39,600
connection-oriented

837
00:32:39,600 --> 00:32:43,120
reliable ordered

838
00:32:43,120 --> 00:32:46,480
channel and

839
00:32:46,480 --> 00:32:48,159
so the security checks and access

840
00:32:48,159 --> 00:32:49,360
control checks are happening at the

841
00:32:49,360 --> 00:32:53,190
point of the setup

842
00:32:53,200 --> 00:32:54,799
so would you have to do that between

843
00:32:54,799 --> 00:32:56,240
every pair of machines

844
00:32:56,240 --> 00:33:00,240
yes so that would become really costly

845
00:33:00,240 --> 00:33:00,799
to add

846
00:33:00,799 --> 00:33:03,600
um like one machine to a large cluster

847
00:33:03,600 --> 00:33:04,799
right

848
00:33:04,799 --> 00:33:08,159
we have n square rdma connections

849
00:33:08,159 --> 00:33:09,440
and otherwise you would have n-squared

850
00:33:09,440 --> 00:33:12,240
tcp connections

851
00:33:12,240 --> 00:33:14,240
not clear there's a major difference

852
00:33:14,240 --> 00:33:17,990
there

853
00:33:18,000 --> 00:33:20,640
um so ju so just to clarify so the

854
00:33:20,640 --> 00:33:22,720
message and the logs basically they both

855
00:33:22,720 --> 00:33:24,880
sit also in memory they just sit in

856
00:33:24,880 --> 00:33:25,840
different places

857
00:33:25,840 --> 00:33:28,159
than where the objects sit yeah exactly

858
00:33:28,159 --> 00:33:29,039
so if you do

859
00:33:29,039 --> 00:33:31,120
this is sort of here on the right it's

860
00:33:31,120 --> 00:33:32,799
sort of a picture of the memory layout

861
00:33:32,799 --> 00:33:33,840
of the

862
00:33:33,840 --> 00:33:36,880
farm process you know there's an uh

863
00:33:36,880 --> 00:33:39,600
region table or an object table well

864
00:33:39,600 --> 00:33:40,559
there's regions

865
00:33:40,559 --> 00:33:43,679
in the memory of the server

866
00:33:43,679 --> 00:33:46,159
these regions have objects in them and

867
00:33:46,159 --> 00:33:48,080
in addition to the regions there are

868
00:33:48,080 --> 00:33:49,200
message queues

869
00:33:49,200 --> 00:33:52,559
and there are logs see

870
00:33:52,559 --> 00:33:54,799
and also for the nick to support the

871
00:33:54,799 --> 00:33:56,000
direct access from

872
00:33:56,000 --> 00:33:58,080
memory so since here we don't have any

873
00:33:58,080 --> 00:33:59,919
software involved since then it can

874
00:33:59,919 --> 00:34:00,960
directly access the

875
00:34:00,960 --> 00:34:04,159
uh the memory without even

876
00:34:04,159 --> 00:34:07,120
notifying the application or the os

877
00:34:07,120 --> 00:34:08,399
shouldn't be some coordination on the

878
00:34:08,399 --> 00:34:09,200
hardware

879
00:34:09,200 --> 00:34:12,159
level uh or at least some support uh

880
00:34:12,159 --> 00:34:14,079
also from the processor

881
00:34:14,079 --> 00:34:17,200
uh to this uh feature

882
00:34:17,200 --> 00:34:19,520
yeah so there's uh basically you know

883
00:34:19,520 --> 00:34:20,800
the nick can read or write

884
00:34:20,800 --> 00:34:25,280
uh uh read or write uh cache lines

885
00:34:25,280 --> 00:34:28,720
uh atomically and so uh to support this

886
00:34:28,720 --> 00:34:29,520
you know there is an

887
00:34:29,520 --> 00:34:32,000
uh an interface you know to the memory

888
00:34:32,000 --> 00:34:32,800
system

889
00:34:32,800 --> 00:34:34,639
uh between the nic and that has to be

890
00:34:34,639 --> 00:34:36,560
carefully set up you know between your

891
00:34:36,560 --> 00:34:38,240
os and you know when the connection

892
00:34:38,240 --> 00:34:40,639
setup is done

893
00:34:40,639 --> 00:34:43,829
i say thank you

894
00:34:43,839 --> 00:34:47,119
um sorry the right to rdma on

895
00:34:47,119 --> 00:34:49,919
the right side that is in red what

896
00:34:49,919 --> 00:34:52,079
happens there

897
00:34:52,079 --> 00:34:56,159
so uh the sender the left machine

898
00:34:56,159 --> 00:34:59,040
can do right rdma which basically sends

899
00:34:59,040 --> 00:35:00,720
in right rdma packet

900
00:35:00,720 --> 00:35:03,040
to the right side you know the the

901
00:35:03,040 --> 00:35:04,160
destination

902
00:35:04,160 --> 00:35:06,160
and the nick you know sees that this is

903
00:35:06,160 --> 00:35:07,520
a right rdma

904
00:35:07,520 --> 00:35:09,599
packet and will write the content that

905
00:35:09,599 --> 00:35:11,040
came in over the network

906
00:35:11,040 --> 00:35:13,520
to the address that's specified in the

907
00:35:13,520 --> 00:35:14,839
right rdma

908
00:35:14,839 --> 00:35:18,870
command

909
00:35:18,880 --> 00:35:21,280
but that would be just and so there's a

910
00:35:21,280 --> 00:35:22,960
reload so the remote machine can just

911
00:35:22,960 --> 00:35:24,560
write the memory location

912
00:35:24,560 --> 00:35:26,800
the set of addresses on the destination

913
00:35:26,800 --> 00:35:28,320
machine without actually having the

914
00:35:28,320 --> 00:35:29,119
server

915
00:35:29,119 --> 00:35:32,240
you know being involved other than doing

916
00:35:32,240 --> 00:35:33,760
setup of course

917
00:35:33,760 --> 00:35:37,119
yeah thank you um

918
00:35:37,119 --> 00:35:40,160
so quick question so the the

919
00:35:40,160 --> 00:35:43,200
um the queue the queue in the

920
00:35:43,200 --> 00:35:46,400
nic is only used for read rdma it's like

921
00:35:46,400 --> 00:35:47,359
the right

922
00:35:47,359 --> 00:35:50,000
writes directly to memory and the

923
00:35:50,000 --> 00:35:51,520
receiver

924
00:35:51,520 --> 00:35:54,000
yeah on the on the uh okay so they're on

925
00:35:54,000 --> 00:35:55,280
the right rdma as you

926
00:35:55,280 --> 00:35:57,119
maybe noticed in the paper there's there

927
00:35:57,119 --> 00:35:59,359
can be an acknowledgement coming back

928
00:35:59,359 --> 00:36:02,640
uh so if the sender you know sends uh

929
00:36:02,640 --> 00:36:04,320
does the right rdma

930
00:36:04,320 --> 00:36:06,800
it can wait from an acknowledgement from

931
00:36:06,800 --> 00:36:07,359
the

932
00:36:07,359 --> 00:36:09,599
receiving nic that actually indeed

933
00:36:09,599 --> 00:36:13,599
performed the right rdma

934
00:36:13,599 --> 00:36:16,640
okay thanks

935
00:36:16,640 --> 00:36:21,190
and that will play an important role

936
00:36:21,200 --> 00:36:25,280
any more questions about this part

937
00:36:25,280 --> 00:36:26,800
so this is sort of a cool piece of

938
00:36:26,800 --> 00:36:28,400
technology you know that has

939
00:36:28,400 --> 00:36:30,960
come into existence pretty quite

940
00:36:30,960 --> 00:36:32,000
widespread

941
00:36:32,000 --> 00:36:34,800
uh in the last decade and basically they

942
00:36:34,800 --> 00:36:37,670
want to leverage it

943
00:36:37,680 --> 00:36:40,480
because it allows them to get very know

944
00:36:40,480 --> 00:36:41,359
designing the

945
00:36:41,359 --> 00:36:43,440
latency to actually do one of these

946
00:36:43,440 --> 00:36:45,119
one-sided rdmas

947
00:36:45,119 --> 00:36:48,950
is about five microseconds

948
00:36:48,960 --> 00:36:54,320
so very low latency uh

949
00:36:54,320 --> 00:36:55,920
much much much faster correct than for

950
00:36:55,920 --> 00:36:57,839
example reading or writing a disk

951
00:36:57,839 --> 00:37:01,280
uh and uh not much slower you know

952
00:37:01,280 --> 00:37:02,880
slower than writing your own

953
00:37:02,880 --> 00:37:06,839
our uh memory uh but you know pretty

954
00:37:06,839 --> 00:37:09,760
fast because it allows you to do

955
00:37:09,760 --> 00:37:11,520
uh if it's one microsecond you could do

956
00:37:11,520 --> 00:37:12,880
a million packets per second

957
00:37:12,880 --> 00:37:17,430
which is pretty impressive

958
00:37:17,440 --> 00:37:20,800
okay so this so far basically standard

959
00:37:20,800 --> 00:37:24,870
technology right

960
00:37:24,880 --> 00:37:27,920
cutting edge but you know standard

961
00:37:27,920 --> 00:37:31,119
so the

962
00:37:31,119 --> 00:37:32,560
real challenge that this sort of paper

963
00:37:32,560 --> 00:37:36,720
addresses um

964
00:37:36,720 --> 00:37:40,960
is actually how to use you know rdma

965
00:37:40,960 --> 00:37:43,599
you know both right rdma and one-sided

966
00:37:43,599 --> 00:37:44,320
rdma

967
00:37:44,320 --> 00:37:46,000
to actually doing transactions so the

968
00:37:46,000 --> 00:37:47,760
challenge is this paper addresses

969
00:37:47,760 --> 00:37:57,510
transactions using rdma

970
00:37:57,520 --> 00:38:00,880
um and you know

971
00:38:00,880 --> 00:38:02,960
to sort of see that this is a challenge

972
00:38:02,960 --> 00:38:04,079
you know we sort of have to think a

973
00:38:04,079 --> 00:38:05,119
little bit about all the

974
00:38:05,119 --> 00:38:07,680
protocols that we've seen so far so

975
00:38:07,680 --> 00:38:11,670
protocols for

976
00:38:11,680 --> 00:38:14,720
you know for transactions

977
00:38:14,720 --> 00:38:18,720
uh two-phase commit et cetera

978
00:38:18,720 --> 00:38:20,400
all those programs and protocols have

979
00:38:20,400 --> 00:38:30,829
required sort of service site

980
00:38:30,839 --> 00:38:33,200
participation

981
00:38:33,200 --> 00:38:35,440
and so for example uh you know what i

982
00:38:35,440 --> 00:38:36,480
mean with that

983
00:38:36,480 --> 00:38:39,359
is you know the uh a client sensor

984
00:38:39,359 --> 00:38:41,200
request or the transaction coordinator

985
00:38:41,200 --> 00:38:42,240
sends a request to one of the

986
00:38:42,240 --> 00:38:43,359
participants

987
00:38:43,359 --> 00:38:46,320
uh for example to require a walk on a

988
00:38:46,320 --> 00:38:47,280
particular

989
00:38:47,280 --> 00:38:49,760
object and you know just waits you know

990
00:38:49,760 --> 00:38:51,040
on the

991
00:38:51,040 --> 00:38:53,200
on the server or the receiver until the

992
00:38:53,200 --> 00:38:55,440
lock actually becomes available

993
00:38:55,440 --> 00:38:57,839
or you know runs you know the server run

994
00:38:57,839 --> 00:38:59,680
some validation

995
00:38:59,680 --> 00:39:04,000
step you know to see uh if the

996
00:39:04,000 --> 00:39:06,560
transaction can be committed or not uh

997
00:39:06,560 --> 00:39:07,200
and so

998
00:39:07,200 --> 00:39:09,520
in all those cases basically uh if you

999
00:39:09,520 --> 00:39:11,119
have some server-side precipitation that

1000
00:39:11,119 --> 00:39:12,480
means that you have to run

1001
00:39:12,480 --> 00:39:22,550
code on the server

1002
00:39:22,560 --> 00:39:25,760
and you know that is sort of counter to

1003
00:39:25,760 --> 00:39:27,839
what rdma gives you right your rda

1004
00:39:27,839 --> 00:39:29,119
actually uh doesn't

1005
00:39:29,119 --> 00:39:31,040
uh really provide you with the ability

1006
00:39:31,040 --> 00:39:32,240
to run code

1007
00:39:32,240 --> 00:39:34,880
on the server and so the the the the the

1008
00:39:34,880 --> 00:39:36,640
designers or the authors of this paper

1009
00:39:36,640 --> 00:39:38,800
have to come up with sort of protocols

1010
00:39:38,800 --> 00:39:40,560
that allow you to implement like

1011
00:39:40,560 --> 00:39:42,079
two-phase commits

1012
00:39:42,079 --> 00:39:45,440
and transactions in general to without

1013
00:39:45,440 --> 00:39:46,240
actually or

1014
00:39:46,240 --> 00:39:47,760
trying to reduce you know server-side

1015
00:39:47,760 --> 00:39:49,440
participation

1016
00:39:49,440 --> 00:39:50,880
so that they can at least do some part

1017
00:39:50,880 --> 00:39:53,760
of the operation using rdma

1018
00:39:53,760 --> 00:39:55,760
and you know some using remote procedure

1019
00:39:55,760 --> 00:39:57,119
calls as usual

1020
00:39:57,119 --> 00:39:59,119
traditional would do in a traditional uh

1021
00:39:59,119 --> 00:40:00,720
designs that we've seen in the last you

1022
00:40:00,720 --> 00:40:02,400
know a couple weeks

1023
00:40:02,400 --> 00:40:03,920
and so that's sort of the central

1024
00:40:03,920 --> 00:40:05,520
challenge uh

1025
00:40:05,520 --> 00:40:08,720
in uh in this paper uh and this

1026
00:40:08,720 --> 00:40:11,599
pushes them uh in this direction you

1027
00:40:11,599 --> 00:40:12,000
know

1028
00:40:12,000 --> 00:40:14,800
to solve that problem uh the high level

1029
00:40:14,800 --> 00:40:16,400
strategy that they use

1030
00:40:16,400 --> 00:40:21,109
is

1031
00:40:21,119 --> 00:40:25,119
the high level strategy uses optimistic

1032
00:40:25,119 --> 00:40:30,710
concurrency control

1033
00:40:30,720 --> 00:40:34,720
and and really really where

1034
00:40:34,720 --> 00:40:36,240
this shines for them is on the read

1035
00:40:36,240 --> 00:40:38,079
operations

1036
00:40:38,079 --> 00:40:39,839
because basically the basic plan is

1037
00:40:39,839 --> 00:40:42,400
we're going to read objects

1038
00:40:42,400 --> 00:40:45,280
that are part of the transaction without

1039
00:40:45,280 --> 00:40:51,030
you know acquiring locks

1040
00:40:51,040 --> 00:40:52,960
make an example require walks and that

1041
00:40:52,960 --> 00:40:54,240
would mean uh

1042
00:40:54,240 --> 00:40:56,640
interrupting maybe the server uh the

1043
00:40:56,640 --> 00:40:58,000
server has to do some work

1044
00:40:58,000 --> 00:41:00,319
and then you know maybe block the client

1045
00:41:00,319 --> 00:41:02,000
into the election the lock is available

1046
00:41:02,000 --> 00:41:04,400
and then uh return the object and you

1047
00:41:04,400 --> 00:41:06,160
know that is not really uh

1048
00:41:06,160 --> 00:41:09,599
suitable or messes up nicely with uh

1049
00:41:09,599 --> 00:41:12,880
or lines up nicely with rdma

1050
00:41:12,880 --> 00:41:14,560
and so they're going to go to an

1051
00:41:14,560 --> 00:41:16,240
optimistic scheme where

1052
00:41:16,240 --> 00:41:17,599
basically reading objects is not going

1053
00:41:17,599 --> 00:41:19,680
to require any locks at all you just can

1054
00:41:19,680 --> 00:41:20,960
fetch an object

1055
00:41:20,960 --> 00:41:24,400
uh and start using it and as we'll see

1056
00:41:24,400 --> 00:41:25,839
uh you know of course you need to have

1057
00:41:25,839 --> 00:41:27,599
some mechanism to discover whether

1058
00:41:27,599 --> 00:41:28,960
you're reading an old version a new

1059
00:41:28,960 --> 00:41:29,440
version

1060
00:41:29,440 --> 00:41:30,720
and this is where the version numbers

1061
00:41:30,720 --> 00:41:39,270
are going to play an important role

1062
00:41:39,280 --> 00:41:41,760
so when you read an object uh in forum

1063
00:41:41,760 --> 00:41:43,200
and you get the object back then you get

1064
00:41:43,200 --> 00:41:43,920
also the

1065
00:41:43,920 --> 00:41:46,000
version number back for that object and

1066
00:41:46,000 --> 00:41:47,760
then

1067
00:41:47,760 --> 00:41:49,680
the basic idea is that at the point of

1068
00:41:49,680 --> 00:41:50,880
commit

1069
00:41:50,880 --> 00:41:56,230
uh we're going to do a validation step

1070
00:41:56,240 --> 00:41:59,280
to check that the

1071
00:41:59,280 --> 00:42:01,119
objects being have that you regret at

1072
00:42:01,119 --> 00:42:02,640
the beginning of the transaction

1073
00:42:02,640 --> 00:42:04,960
or actually haven't been modified and so

1074
00:42:04,960 --> 00:42:06,720
during the validation chat instead

1075
00:42:06,720 --> 00:42:07,920
we're basically going to check for

1076
00:42:07,920 --> 00:42:15,750
conflict

1077
00:42:15,760 --> 00:42:17,520
and the conflict is basically if the

1078
00:42:17,520 --> 00:42:18,960
version number uh

1079
00:42:18,960 --> 00:42:21,119
has been incremented you know since you

1080
00:42:21,119 --> 00:42:22,240
know the

1081
00:42:22,240 --> 00:42:25,359
uh coordinator actually read the object

1082
00:42:25,359 --> 00:42:30,800
so the version numbers are different

1083
00:42:30,800 --> 00:42:34,319
are different then

1084
00:42:34,319 --> 00:42:39,750
the transaction is aborted

1085
00:42:39,760 --> 00:42:41,599
and if they're saying are still the same

1086
00:42:41,599 --> 00:42:43,440
that basically means that nobody

1087
00:42:43,440 --> 00:42:45,680
no other transaction actually modified

1088
00:42:45,680 --> 00:42:47,119
uh the transaction

1089
00:42:47,119 --> 00:42:49,200
the object and then you know we can

1090
00:42:49,200 --> 00:42:52,710
actually go ahead and commit

1091
00:42:52,720 --> 00:42:54,640
and of course in the case of abort you

1092
00:42:54,640 --> 00:42:57,040
know typically will happen is that the

1093
00:42:57,040 --> 00:42:59,359
client you know will maybe run run the

1094
00:42:59,359 --> 00:43:00,079
whole track

1095
00:43:00,079 --> 00:43:02,400
transaction again perhaps waiting for a

1096
00:43:02,400 --> 00:43:03,119
little while

1097
00:43:03,119 --> 00:43:05,119
before uh actually doing it for for some

1098
00:43:05,119 --> 00:43:07,760
random in a period of time

1099
00:43:07,760 --> 00:43:10,319
so that's the basic uh plan right so

1100
00:43:10,319 --> 00:43:12,319
this is just this optimistic scheme

1101
00:43:12,319 --> 00:43:15,440
so that reads can uh completely exploit

1102
00:43:15,440 --> 00:43:18,960
our dna and as we'll see in fact

1103
00:43:18,960 --> 00:43:21,920
regional and require any state changes

1104
00:43:21,920 --> 00:43:22,480
on

1105
00:43:22,480 --> 00:43:25,510
on the servers at all

1106
00:43:25,520 --> 00:43:27,520
and so this is basically sort of the you

1107
00:43:27,520 --> 00:43:29,359
know the basic idea behind you know

1108
00:43:29,359 --> 00:43:31,680
figure four

1109
00:43:31,680 --> 00:43:33,280
except you know as we'll see in a second

1110
00:43:33,280 --> 00:43:34,240
there's quite a bit of more

1111
00:43:34,240 --> 00:43:36,079
complications to it

1112
00:43:36,079 --> 00:43:38,640
and so this again sort of the i think i

1113
00:43:38,640 --> 00:43:40,160
used this phrasing a little while ago a

1114
00:43:40,160 --> 00:43:41,119
couple lectures ago

1115
00:43:41,119 --> 00:43:43,440
so the optimistic scheme in contrast to

1116
00:43:43,440 --> 00:43:44,960
the pessimistic scheme is

1117
00:43:44,960 --> 00:43:46,720
you're basically going to assume that

1118
00:43:46,720 --> 00:43:48,640
you're allowed to do the operation

1119
00:43:48,640 --> 00:43:50,160
and if it turns out you're not allowed

1120
00:43:50,160 --> 00:43:52,160
you sort of apologize and abort

1121
00:43:52,160 --> 00:43:54,160
uh in the pessimistic case you basically

1122
00:43:54,160 --> 00:43:55,920
first ask for approval to do the

1123
00:43:55,920 --> 00:43:57,920
operation by acquiring locks

1124
00:43:57,920 --> 00:43:59,040
and then you know you basically

1125
00:43:59,040 --> 00:44:00,960
guarantee that at commit time you can

1126
00:44:00,960 --> 00:44:02,400
actually commit

1127
00:44:02,400 --> 00:44:06,240
okay any questions about optimistic

1128
00:44:06,240 --> 00:44:07,280
concurrency control

1129
00:44:07,280 --> 00:44:10,550
at this high level

1130
00:44:10,560 --> 00:44:11,920
just the question about the version

1131
00:44:11,920 --> 00:44:13,920
numbers how do they ensure that

1132
00:44:13,920 --> 00:44:16,079
two different op that there's like

1133
00:44:16,079 --> 00:44:18,640
consistency across different objects

1134
00:44:18,640 --> 00:44:21,040
so that you're not reading one object

1135
00:44:21,040 --> 00:44:22,480
and then like later reading another

1136
00:44:22,480 --> 00:44:23,680
object but those

1137
00:44:23,680 --> 00:44:26,319
but a transaction modified some of those

1138
00:44:26,319 --> 00:44:27,280
in between

1139
00:44:27,280 --> 00:44:30,319
yeah well uh that's a great question uh

1140
00:44:30,319 --> 00:44:30,880
and so we'll

1141
00:44:30,880 --> 00:44:32,720
let's uh i think we're going to get out

1142
00:44:32,720 --> 00:44:34,240
of is we got to dive into

1143
00:44:34,240 --> 00:44:36,720
actually figure four and which i think

1144
00:44:36,720 --> 00:44:39,760
should be the core of this paper

1145
00:44:39,760 --> 00:44:48,829
so let's look at figure four

1146
00:44:48,839 --> 00:44:50,720
and

1147
00:44:50,720 --> 00:44:53,840
oops not that one

1148
00:44:53,850 --> 00:44:56,560
[Music]

1149
00:44:56,560 --> 00:44:59,990
all right you're figure four

1150
00:45:00,000 --> 00:45:01,760
i'm going to spend quite a bit of time

1151
00:45:01,760 --> 00:45:04,960
uh basically talking about figure four

1152
00:45:04,960 --> 00:45:07,599
yeah uh so the first you know thing

1153
00:45:07,599 --> 00:45:08,800
let's get it oriented

1154
00:45:08,800 --> 00:45:16,829
uh in this figure four uh you know we

1155
00:45:16,839 --> 00:45:18,480
see uh

1156
00:45:18,480 --> 00:45:21,920
so we have a a transaction coordinator

1157
00:45:21,920 --> 00:45:24,640
the c here and really the direction

1158
00:45:24,640 --> 00:45:25,920
coordinator is the

1159
00:45:25,920 --> 00:45:28,319
application and the application runs on

1160
00:45:28,319 --> 00:45:29,839
the same machines one of those 90

1161
00:45:29,839 --> 00:45:30,960
machines

1162
00:45:30,960 --> 00:45:32,400
but the way you're going to think about

1163
00:45:32,400 --> 00:45:34,240
it for the rest of this lecture is that

1164
00:45:34,240 --> 00:45:35,599
it runs it in a separate machine i don't

1165
00:45:35,599 --> 00:45:36,480
really care about it

1166
00:45:36,480 --> 00:45:39,680
that much okay and then uh

1167
00:45:39,680 --> 00:45:42,000
there are different charts in this case

1168
00:45:42,000 --> 00:45:43,440
there are three shards

1169
00:45:43,440 --> 00:45:46,400
you know one two and three and each

1170
00:45:46,400 --> 00:45:46,880
chart

1171
00:45:46,880 --> 00:45:48,960
is replicated twice once in the primary

1172
00:45:48,960 --> 00:45:51,040
and one's on the backup

1173
00:45:51,040 --> 00:45:54,400
um then you know we'll see that this is

1174
00:45:54,400 --> 00:45:56,079
the execution phase of the transaction

1175
00:45:56,079 --> 00:45:58,079
so the transaction has two phases

1176
00:45:58,079 --> 00:45:59,680
one is the execution phase and that's

1177
00:45:59,680 --> 00:46:01,359
the commit phase

1178
00:46:01,359 --> 00:46:04,319
uh and during the execution phase this

1179
00:46:04,319 --> 00:46:05,920
is like where the transaction just runs

1180
00:46:05,920 --> 00:46:07,280
so does it begin

1181
00:46:07,280 --> 00:46:10,000
uh does it read uh for example in this

1182
00:46:10,000 --> 00:46:11,680
case the three objects are being read

1183
00:46:11,680 --> 00:46:13,599
you know one that was located

1184
00:46:13,599 --> 00:46:15,680
whose primary is in uh one object that

1185
00:46:15,680 --> 00:46:17,440
is actually included in shard one

1186
00:46:17,440 --> 00:46:19,200
one object that's sitting chart three

1187
00:46:19,200 --> 00:46:21,599
and one object that sits in chart two

1188
00:46:21,599 --> 00:46:26,000
all right region two and uh

1189
00:46:26,000 --> 00:46:28,400
the we can see actually you know we look

1190
00:46:28,400 --> 00:46:29,599
a little bit ahead

1191
00:46:29,599 --> 00:46:32,640
uh we'll see that the for the two of

1192
00:46:32,640 --> 00:46:33,920
these objects are actually being

1193
00:46:33,920 --> 00:46:36,560
uh written and one of them is being read

1194
00:46:36,560 --> 00:46:37,440
now so the

1195
00:46:37,440 --> 00:46:40,240
object form number you know sharp three

1196
00:46:40,240 --> 00:46:42,079
this is just a read operation

1197
00:46:42,079 --> 00:46:44,160
these are right operations or these are

1198
00:46:44,160 --> 00:46:45,760
read operations but

1199
00:46:45,760 --> 00:46:48,240
those objects are going to be modified

1200
00:46:48,240 --> 00:46:49,359
so basically

1201
00:46:49,359 --> 00:46:50,880
as the transaction runs you know it

1202
00:46:50,880 --> 00:46:53,599
fetches objects from different machines

1203
00:46:53,599 --> 00:46:56,079
modifies them locally and then you know

1204
00:46:56,079 --> 00:46:58,160
in the commit phase

1205
00:46:58,160 --> 00:47:00,720
the changes are being applied and of

1206
00:47:00,720 --> 00:47:02,720
course you know the whole challenge here

1207
00:47:02,720 --> 00:47:04,720
is that in the end we want

1208
00:47:04,720 --> 00:47:17,510
to achieve straight serializability

1209
00:47:17,520 --> 00:47:20,559
um and in some ways

1210
00:47:20,559 --> 00:47:24,400
the protocol

1211
00:47:24,400 --> 00:47:26,880
for at least writes almost follows like

1212
00:47:26,880 --> 00:47:28,000
sort of very similar

1213
00:47:28,000 --> 00:47:29,359
two-phase commit protocols that we've

1214
00:47:29,359 --> 00:47:30,559
seen in the past you know there are

1215
00:47:30,559 --> 00:47:31,760
differences in the details

1216
00:47:31,760 --> 00:47:34,559
uh but the basic strategy is the same uh

1217
00:47:34,559 --> 00:47:35,359
and you know

1218
00:47:35,359 --> 00:47:38,319
we can sort of uh so let's assume that

1219
00:47:38,319 --> 00:47:39,839
now we're done with the execution phase

1220
00:47:39,839 --> 00:47:40,800
so we're

1221
00:47:40,800 --> 00:47:42,240
we're at the end of the transaction and

1222
00:47:42,240 --> 00:47:43,520
so the transaction is going to try to

1223
00:47:43,520 --> 00:47:44,160
commit

1224
00:47:44,160 --> 00:47:45,440
the transaction there could be two

1225
00:47:45,440 --> 00:47:46,720
outcomes you know there's actually you

1226
00:47:46,720 --> 00:47:48,000
successfully commits or it actually

1227
00:47:48,000 --> 00:47:49,359
aborts

1228
00:47:49,359 --> 00:47:51,200
uh anyway you're bored because like some

1229
00:47:51,200 --> 00:47:52,880
other transaction ran concurrently

1230
00:47:52,880 --> 00:47:54,880
and modifies one of the objects that we

1231
00:47:54,880 --> 00:47:56,240
either read or that we're trying to

1232
00:47:56,240 --> 00:47:57,599
write

1233
00:47:57,599 --> 00:48:01,040
um and so the first thing

1234
00:48:01,040 --> 00:48:03,359
the so the protocol the commit phase

1235
00:48:03,359 --> 00:48:04,319
basically has

1236
00:48:04,319 --> 00:48:06,960
five steps you know the locking step the

1237
00:48:06,960 --> 00:48:08,079
validation step

1238
00:48:08,079 --> 00:48:09,760
the commit backup steps the commit

1239
00:48:09,760 --> 00:48:11,839
primary and then the trunk and the

1240
00:48:11,839 --> 00:48:13,680
truncate basically runs

1241
00:48:13,680 --> 00:48:16,640
uh almost uh lazily and so it's not

1242
00:48:16,640 --> 00:48:17,839
particularly important

1243
00:48:17,839 --> 00:48:19,920
basically for our perspective basically

1244
00:48:19,920 --> 00:48:21,280
the point of interest of where things

1245
00:48:21,280 --> 00:48:22,640
are stopping

1246
00:48:22,640 --> 00:48:24,400
is here so that's sort of where the end

1247
00:48:24,400 --> 00:48:25,680
of the transaction uh

1248
00:48:25,680 --> 00:48:29,200
is okay so

1249
00:48:29,200 --> 00:48:30,880
um each of these objects as i said

1250
00:48:30,880 --> 00:48:33,040
before you know when you read them has a

1251
00:48:33,040 --> 00:48:34,480
version number so near the version

1252
00:48:34,480 --> 00:48:37,270
number

1253
00:48:37,280 --> 00:48:40,800
um and uh there i modify this is it

1254
00:48:40,800 --> 00:48:42,480
locally then at the point of this you

1255
00:48:42,480 --> 00:48:42,880
know when

1256
00:48:42,880 --> 00:48:44,800
when the so this is the commit point

1257
00:48:44,800 --> 00:48:46,480
where when the application calls and

1258
00:48:46,480 --> 00:48:48,079
transaction uh

1259
00:48:48,079 --> 00:48:51,359
the the protocol this whole commit phase

1260
00:48:51,359 --> 00:48:53,520
protocol kicks in

1261
00:48:53,520 --> 00:48:56,400
um and so the first thing it does uh is

1262
00:48:56,400 --> 00:48:58,079
what's called the locking step

1263
00:48:58,079 --> 00:49:00,880
step number one and the goal here in

1264
00:49:00,880 --> 00:49:02,880
this step is to basically acquire locks

1265
00:49:02,880 --> 00:49:04,880
on all the objects that are being

1266
00:49:04,880 --> 00:49:06,079
written

1267
00:49:06,079 --> 00:49:07,839
uh and so we can see you know based on

1268
00:49:07,839 --> 00:49:09,440
this diagram that

1269
00:49:09,440 --> 00:49:11,680
apparently two objects are uh being

1270
00:49:11,680 --> 00:49:13,200
written namely

1271
00:49:13,200 --> 00:49:16,640
um the you know this object correct

1272
00:49:16,640 --> 00:49:19,280
because the context is the primary of uh

1273
00:49:19,280 --> 00:49:20,880
shard one or region one

1274
00:49:20,880 --> 00:49:22,880
and then uh this object is being wrapped

1275
00:49:22,880 --> 00:49:24,720
uh that is actually located on

1276
00:49:24,720 --> 00:49:27,040
region two right and apparently the

1277
00:49:27,040 --> 00:49:28,880
third object that we read you know from

1278
00:49:28,880 --> 00:49:31,200
primary free

1279
00:49:31,200 --> 00:49:34,319
it's not being uh red because it doesn't

1280
00:49:34,319 --> 00:49:36,720
participate in the locking phase

1281
00:49:36,720 --> 00:49:40,400
so in the locking phase uh

1282
00:49:40,400 --> 00:49:42,319
the the arrows actually have all kinds

1283
00:49:42,319 --> 00:49:43,520
of different meanings

1284
00:49:43,520 --> 00:49:46,720
so these dashed arrows are

1285
00:49:46,720 --> 00:49:57,030
one-sided rdmas

1286
00:49:57,040 --> 00:49:59,440
so those objects are being we have rdmas

1287
00:49:59,440 --> 00:50:01,440
they're just fetched from the remote

1288
00:50:01,440 --> 00:50:04,400
uh memory location uh and brought

1289
00:50:04,400 --> 00:50:06,319
locally you know to the

1290
00:50:06,319 --> 00:50:08,079
into the memory of the uh the

1291
00:50:08,079 --> 00:50:10,160
application or the coordinator

1292
00:50:10,160 --> 00:50:14,559
um the uh

1293
00:50:14,559 --> 00:50:17,920
the solid ones are right rdmas

1294
00:50:17,920 --> 00:50:21,349
and uh

1295
00:50:21,359 --> 00:50:26,319
and in this particular case

1296
00:50:26,319 --> 00:50:32,069
they append on lock uh entry to the

1297
00:50:32,079 --> 00:50:34,720
to the the log of the primary so the

1298
00:50:34,720 --> 00:50:36,079
primary has a log

1299
00:50:36,079 --> 00:50:38,079
every primary has a lock so i'm just

1300
00:50:38,079 --> 00:50:40,400
going to draw it like this

1301
00:50:40,400 --> 00:50:43,839
and actually use a different color

1302
00:50:43,839 --> 00:50:46,480
so here we have the primary eye we have

1303
00:50:46,480 --> 00:50:49,349
a log

1304
00:50:49,359 --> 00:50:54,559
and basically uh the the

1305
00:50:54,559 --> 00:50:58,160
the coordinator now it's a commit record

1306
00:50:58,160 --> 00:51:00,880
oh no sorry sorry the lock record is

1307
00:51:00,880 --> 00:51:05,589
called

1308
00:51:05,599 --> 00:51:08,000
to uh the log i'm going to make it a big

1309
00:51:08,000 --> 00:51:08,880
record so i can

1310
00:51:08,880 --> 00:51:11,359
write down what's in it and in it is the

1311
00:51:11,359 --> 00:51:12,240
version number

1312
00:51:12,240 --> 00:51:14,160
of the time of the red and when the

1313
00:51:14,160 --> 00:51:15,760
object is read so that version number

1314
00:51:15,760 --> 00:51:19,030
that came out here

1315
00:51:19,040 --> 00:51:21,599
that goes back into the log record the

1316
00:51:21,599 --> 00:51:22,079
object

1317
00:51:22,079 --> 00:51:25,520
id that's being read and the new value

1318
00:51:25,520 --> 00:51:29,510
for the object

1319
00:51:29,520 --> 00:51:32,319
and so this record is just appended you

1320
00:51:32,319 --> 00:51:33,440
know to

1321
00:51:33,440 --> 00:51:37,040
the uh you know uh

1322
00:51:37,040 --> 00:51:40,559
primary one and primary twos uh log

1323
00:51:40,559 --> 00:51:43,839
using uh a right rd main and so there's

1324
00:51:43,839 --> 00:51:44,800
some threat

1325
00:51:44,800 --> 00:51:47,200
sitting on those machines that looks at

1326
00:51:47,200 --> 00:51:48,839
these logs and then actually does some

1327
00:51:48,839 --> 00:51:50,480
operations

1328
00:51:50,480 --> 00:51:52,640
so in this particular case if there's a

1329
00:51:52,640 --> 00:51:54,160
thread sitting on the

1330
00:51:54,160 --> 00:51:57,200
uh on p1 and p2 that you know

1331
00:51:57,200 --> 00:51:59,920
monitors or spins or pulls you know this

1332
00:51:59,920 --> 00:52:00,640
log

1333
00:52:00,640 --> 00:52:02,480
and sees there's a new log record and

1334
00:52:02,480 --> 00:52:04,319
then in this particular case what it

1335
00:52:04,319 --> 00:52:04,800
will do

1336
00:52:04,800 --> 00:52:07,119
it will try to get a lock on the object

1337
00:52:07,119 --> 00:52:08,240
you know that actually

1338
00:52:08,240 --> 00:52:12,240
is listed in the uh

1339
00:52:12,240 --> 00:52:15,599
in the transaction so somewhere there's

1340
00:52:15,599 --> 00:52:18,240
an object

1341
00:52:18,240 --> 00:52:20,319
and that object has some data in it and

1342
00:52:20,319 --> 00:52:21,599
it has this lock bit

1343
00:52:21,599 --> 00:52:25,190
and the version number in it

1344
00:52:25,200 --> 00:52:27,680
and so p1 you know has one object you

1345
00:52:27,680 --> 00:52:29,200
know that is being

1346
00:52:29,200 --> 00:52:32,400
uh modified by uh the coordinator

1347
00:52:32,400 --> 00:52:34,319
p2 has another object that is modified

1348
00:52:34,319 --> 00:52:35,599
by the coordinator

1349
00:52:35,599 --> 00:52:38,640
and basically the uh

1350
00:52:38,640 --> 00:52:40,720
the primary charge is required to walk

1351
00:52:40,720 --> 00:52:42,000
on the

1352
00:52:42,000 --> 00:52:45,280
uh on the object using a test and set

1353
00:52:45,280 --> 00:52:46,480
instruction

1354
00:52:46,480 --> 00:52:52,069
and so it will try to set the log bit

1355
00:52:52,079 --> 00:52:54,559
uh i'm using testing set instruction and

1356
00:52:54,559 --> 00:52:56,400
if the log bit was zero

1357
00:52:56,400 --> 00:53:00,559
uh uh before

1358
00:53:00,559 --> 00:53:03,359
and the log bit was zero and

1359
00:53:03,359 --> 00:53:05,200
successfully set the bit to one

1360
00:53:05,200 --> 00:53:08,240
uh then it knows that the uh

1361
00:53:08,240 --> 00:53:10,079
the army knows that it actually required

1362
00:53:10,079 --> 00:53:11,760
the lock and in that

1363
00:53:11,760 --> 00:53:14,079
case and we'll send them one rd main

1364
00:53:14,079 --> 00:53:14,960
message back

1365
00:53:14,960 --> 00:53:17,520
uh to append a message you know to the

1366
00:53:17,520 --> 00:53:18,880
coordinator's message queue

1367
00:53:18,880 --> 00:53:22,480
saying okay you successfully acquired

1368
00:53:22,480 --> 00:53:23,119
logs

1369
00:53:23,119 --> 00:53:26,559
for these particular objects if

1370
00:53:26,559 --> 00:53:30,240
the transaction uh if the the locker is

1371
00:53:30,240 --> 00:53:31,119
already taken

1372
00:53:31,119 --> 00:53:33,920
by another transaction and then at that

1373
00:53:33,920 --> 00:53:35,280
point in time the transaction

1374
00:53:35,280 --> 00:53:38,480
uh is aborted uh and so uh so when the

1375
00:53:38,480 --> 00:53:39,520
primary eye

1376
00:53:39,520 --> 00:53:41,280
you know tries to get the walk finds out

1377
00:53:41,280 --> 00:53:43,040
that the lock is already set

1378
00:53:43,040 --> 00:53:46,000
using this test and set instruction then

1379
00:53:46,000 --> 00:53:46,960
that lock

1380
00:53:46,960 --> 00:53:51,030
so the try lock will fail

1381
00:53:51,040 --> 00:53:54,240
and the

1382
00:53:54,240 --> 00:53:57,839
the primary will add a message to the

1383
00:53:57,839 --> 00:54:00,240
queue of the using right to the queue of

1384
00:54:00,240 --> 00:54:01,359
the coordinator

1385
00:54:01,359 --> 00:54:03,280
saying like i you know i could not

1386
00:54:03,280 --> 00:54:04,559
acquire the locks

1387
00:54:04,559 --> 00:54:06,400
and the coordinator in that case will

1388
00:54:06,400 --> 00:54:10,000
report the transactions

1389
00:54:10,000 --> 00:54:13,270
any questions so far

1390
00:54:13,280 --> 00:54:14,960
how are the are the locks obtained

1391
00:54:14,960 --> 00:54:16,640
through zookeeper

1392
00:54:16,640 --> 00:54:18,559
no these are uh there's there's other

1393
00:54:18,559 --> 00:54:20,079
set of locks using suit keeper that's

1394
00:54:20,079 --> 00:54:21,520
really for the configuration management

1395
00:54:21,520 --> 00:54:22,480
like the

1396
00:54:22,480 --> 00:54:25,599
uh the mapping of uh

1397
00:54:25,599 --> 00:54:28,720
uh region number two uh primary and uh

1398
00:54:28,720 --> 00:54:29,599
backups

1399
00:54:29,599 --> 00:54:32,160
these are just in-memory logs uh that

1400
00:54:32,160 --> 00:54:32,640
the

1401
00:54:32,640 --> 00:54:35,839
uh primary maintains so in the address

1402
00:54:35,839 --> 00:54:36,559
space

1403
00:54:36,559 --> 00:54:39,040
look a little bit back correct uh we

1404
00:54:39,040 --> 00:54:40,400
look back at this picture

1405
00:54:40,400 --> 00:54:42,960
uh there was a region has objects every

1406
00:54:42,960 --> 00:54:43,760
object has

1407
00:54:43,760 --> 00:54:46,559
some data and uh a header and in that

1408
00:54:46,559 --> 00:54:47,760
header there's basically

1409
00:54:47,760 --> 00:54:50,480
a 64-bit number uh that where the

1410
00:54:50,480 --> 00:54:51,280
top-level bit

1411
00:54:51,280 --> 00:54:54,319
is the lock bit and the 63 other bits

1412
00:54:54,319 --> 00:54:54,559
for

1413
00:54:54,559 --> 00:54:57,040
the version number uh what if the

1414
00:54:57,040 --> 00:54:57,839
primary

1415
00:54:57,839 --> 00:54:59,520
goes down does the backup have the same

1416
00:54:59,520 --> 00:55:01,680
locks of the primary

1417
00:55:01,680 --> 00:55:04,960
if the primary goes down the whole uh

1418
00:55:04,960 --> 00:55:06,559
what's going to happen is that there's a

1419
00:55:06,559 --> 00:55:08,240
whole reconfiguration protocol

1420
00:55:08,240 --> 00:55:12,000
uh happening in a new recovery protocol

1421
00:55:12,000 --> 00:55:13,839
the end result of that is that in this

1422
00:55:13,839 --> 00:55:15,040
case the

1423
00:55:15,040 --> 00:55:16,319
we hope that the injection would be

1424
00:55:16,319 --> 00:55:18,319
aborted correct because it never made it

1425
00:55:18,319 --> 00:55:19,599
to the end

1426
00:55:19,599 --> 00:55:21,599
uh we'll we'll get to photology in a

1427
00:55:21,599 --> 00:55:22,640
little while so let's

1428
00:55:22,640 --> 00:55:25,359
shoot for uh i'm gonna go talk about it

1429
00:55:25,359 --> 00:55:26,799
in a couple boards and i'll talk about

1430
00:55:26,799 --> 00:55:27,680
full tolerance

1431
00:55:27,680 --> 00:55:31,190
thank you

1432
00:55:31,200 --> 00:55:34,079
um so the version numbers are per object

1433
00:55:34,079 --> 00:55:35,200
right

1434
00:55:35,200 --> 00:55:38,480
sure per object yeah

1435
00:55:38,480 --> 00:55:42,150
exactly

1436
00:55:42,160 --> 00:55:48,079
okay good so um question

1437
00:55:48,079 --> 00:55:50,240
um why do they choose to abort the

1438
00:55:50,240 --> 00:55:51,839
transaction rather than blocking and

1439
00:55:51,839 --> 00:55:54,640
waiting for the lock to be released

1440
00:55:54,640 --> 00:55:56,480
uh because they have read uh old

1441
00:55:56,480 --> 00:55:57,760
material

1442
00:55:57,760 --> 00:55:59,440
they have not read the laser's material

1443
00:55:59,440 --> 00:56:01,200
uh value

1444
00:56:01,200 --> 00:56:04,799
and so the transaction has to board

1445
00:56:04,799 --> 00:56:06,640
oh i see because the lock means that

1446
00:56:06,640 --> 00:56:08,000
it's going to change

1447
00:56:08,000 --> 00:56:10,000
the next time well they asked for the

1448
00:56:10,000 --> 00:56:11,280
walks after really

1449
00:56:11,280 --> 00:56:14,319
written the object right so the

1450
00:56:14,319 --> 00:56:16,240
coordinator modifies the object based on

1451
00:56:16,240 --> 00:56:17,599
some version number

1452
00:56:17,599 --> 00:56:20,559
uh submits a bunch of writes uh assuming

1453
00:56:20,559 --> 00:56:22,720
that has read the latest version number

1454
00:56:22,720 --> 00:56:26,720
and so by the time uh the uh

1455
00:56:26,720 --> 00:56:28,559
the commit starts to happening and you

1456
00:56:28,559 --> 00:56:30,640
try to get the locks and you discover

1457
00:56:30,640 --> 00:56:31,920
that somebody else is blocked that means

1458
00:56:31,920 --> 00:56:33,680
somebody else already modifying it

1459
00:56:33,680 --> 00:56:36,160
and so that would violate serialization

1460
00:56:36,160 --> 00:56:39,030
right

1461
00:56:39,040 --> 00:56:40,799
so in fact at the point you get the lock

1462
00:56:40,799 --> 00:56:43,119
here that's sort of the serialization

1463
00:56:43,119 --> 00:56:45,440
point for right transactions

1464
00:56:45,440 --> 00:56:47,359
okay so this this point uh the

1465
00:56:47,359 --> 00:56:49,119
transaction has acquired all the logs

1466
00:56:49,119 --> 00:56:49,760
for all the

1467
00:56:49,760 --> 00:56:52,160
objects is modified so so nobody else

1468
00:56:52,160 --> 00:56:53,119
can actually

1469
00:56:53,119 --> 00:56:54,720
modify them at this particular point in

1470
00:56:54,720 --> 00:56:56,000
time and so that's sort of the

1471
00:56:56,000 --> 00:56:57,920
serialization point for the right part

1472
00:56:57,920 --> 00:57:02,069
of the transaction

1473
00:57:02,079 --> 00:57:07,040
make sense yes thank you

1474
00:57:07,040 --> 00:57:10,559
good okay so now uh you might have felt

1475
00:57:10,559 --> 00:57:13,440
like oh why not do the same thing for

1476
00:57:13,440 --> 00:57:14,000
reef

1477
00:57:14,000 --> 00:57:15,520
correct and you know get the lock for

1478
00:57:15,520 --> 00:57:17,200
the read objects uh

1479
00:57:17,200 --> 00:57:18,799
get the lock from the objects that are

1480
00:57:18,799 --> 00:57:20,079
read you know check the version numbers

1481
00:57:20,079 --> 00:57:22,319
and you're in good shape

1482
00:57:22,319 --> 00:57:24,880
and the reason that that is actually in

1483
00:57:24,880 --> 00:57:26,559
separate phase namely the validation

1484
00:57:26,559 --> 00:57:27,520
phase

1485
00:57:27,520 --> 00:57:30,319
uh is to basically avoid these expensive

1486
00:57:30,319 --> 00:57:32,160
bright rdmas right you

1487
00:57:32,160 --> 00:57:33,760
if you look at this vertical step you'll

1488
00:57:33,760 --> 00:57:35,200
see there's a writer dma

1489
00:57:35,200 --> 00:57:36,880
then the server actually has to run

1490
00:57:36,880 --> 00:57:38,720
something and it basically does

1491
00:57:38,720 --> 00:57:40,799
the acquiring the locks and then

1492
00:57:40,799 --> 00:57:42,720
responds with another write our dma so

1493
00:57:42,720 --> 00:57:46,400
here this this is a full rpc

1494
00:57:46,400 --> 00:57:47,760
that actually required server

1495
00:57:47,760 --> 00:57:50,240
participation and as we'll see in a

1496
00:57:50,240 --> 00:57:51,040
second

1497
00:57:51,040 --> 00:57:54,160
in the to handle the read and the

1498
00:57:54,160 --> 00:57:55,599
objects that have been read

1499
00:57:55,599 --> 00:57:59,839
uh the the firearm uses this validation

1500
00:57:59,839 --> 00:58:01,280
step and that validation step

1501
00:58:01,280 --> 00:58:04,079
just used one-sided rdmas and so there's

1502
00:58:04,079 --> 00:58:11,990
no real server involvement necessary

1503
00:58:12,000 --> 00:58:15,040
okay so uh

1504
00:58:15,040 --> 00:58:16,720
what happens on the so we're basically

1505
00:58:16,720 --> 00:58:18,240
at this point the you know

1506
00:58:18,240 --> 00:58:19,599
where we're here the transaction

1507
00:58:19,599 --> 00:58:21,760
coordinator actually has the

1508
00:58:21,760 --> 00:58:23,680
red blocks and now the only thing it

1509
00:58:23,680 --> 00:58:26,079
does is it validates the read logs or

1510
00:58:26,079 --> 00:58:28,480
basically the read version numbers

1511
00:58:28,480 --> 00:58:31,839
and so it uh for every object that is

1512
00:58:31,839 --> 00:58:33,040
read but not modified

1513
00:58:33,040 --> 00:58:34,799
so in our particular example that's only

1514
00:58:34,799 --> 00:58:36,240
one object correct this is the one that

1515
00:58:36,240 --> 00:58:37,760
actually is being read

1516
00:58:37,760 --> 00:58:41,040
the one at region three

1517
00:58:41,040 --> 00:58:43,599
uh so it sends it basically there's a

1518
00:58:43,599 --> 00:58:45,119
one-sided rdma

1519
00:58:45,119 --> 00:58:48,000
to read the version number that 64-bit

1520
00:58:48,000 --> 00:58:49,119
number

1521
00:58:49,119 --> 00:58:52,000
for the object that's being read and

1522
00:58:52,000 --> 00:58:53,520
when it gets it back

1523
00:58:53,520 --> 00:58:56,400
uh when it gets it back here it checks

1524
00:58:56,400 --> 00:58:57,680
two things

1525
00:58:57,680 --> 00:59:00,480
um if the lock is taken or so the lock

1526
00:59:00,480 --> 00:59:01,200
bit is set

1527
00:59:01,200 --> 00:59:03,119
that means that some core that is a

1528
00:59:03,119 --> 00:59:04,559
concurrent transaction is being

1529
00:59:04,559 --> 00:59:06,720
is trying to modify it so at that point

1530
00:59:06,720 --> 00:59:08,240
adjuster boards

1531
00:59:08,240 --> 00:59:10,240
uh and so the whole transaction aborts

1532
00:59:10,240 --> 00:59:11,680
again

1533
00:59:11,680 --> 00:59:14,559
if the first number is identical and

1534
00:59:14,559 --> 00:59:15,839
it's not locked

1535
00:59:15,839 --> 00:59:17,599
that means that no other transactions

1536
00:59:17,599 --> 00:59:18,880
are using at this particular point in

1537
00:59:18,880 --> 00:59:19,599
time

1538
00:59:19,599 --> 00:59:22,640
and the

1539
00:59:22,640 --> 00:59:24,880
the transaction can proceed basically

1540
00:59:24,880 --> 00:59:26,559
all the objects that are being read and

1541
00:59:26,559 --> 00:59:27,520
modified

1542
00:59:27,520 --> 00:59:29,280
have the version number at the start of

1543
00:59:29,280 --> 00:59:31,119
the transaction

1544
00:59:31,119 --> 00:59:33,599
and nothing has changed yet and so it is

1545
00:59:33,599 --> 00:59:35,280
okay for the transaction to commit this

1546
00:59:35,280 --> 00:59:36,559
is really you know the true

1547
00:59:36,559 --> 00:59:38,480
generalization point

1548
00:59:38,480 --> 00:59:40,240
and since you know the transactions

1549
00:59:40,240 --> 00:59:41,839
numbers are required at the beginning or

1550
00:59:41,839 --> 00:59:42,960
the version numbers are read at the

1551
00:59:42,960 --> 00:59:44,319
beginning of the transaction

1552
00:59:44,319 --> 00:59:46,000
uh the you know the transaction will

1553
00:59:46,000 --> 00:59:47,760
commit in the order of the version

1554
00:59:47,760 --> 00:59:48,880
numbers basically

1555
00:59:48,880 --> 00:59:51,839
and uh they also will get basically

1556
00:59:51,839 --> 00:59:52,400
strict

1557
00:59:52,400 --> 00:59:55,760
serializability because any transaction

1558
00:59:55,760 --> 00:59:57,839
that will start after your transaction

1559
00:59:57,839 --> 00:59:59,200
commits will have a higher version

1560
00:59:59,200 --> 01:00:00,880
number so therefore it also will commit

1561
01:00:00,880 --> 01:00:04,710
later

1562
01:00:04,720 --> 01:00:07,440
okay so this is the point basically

1563
01:00:07,440 --> 01:00:08,240
where

1564
01:00:08,240 --> 01:00:11,200
the transaction coordinator says uh you

1565
01:00:11,200 --> 01:00:12,160
know at this point

1566
01:00:12,160 --> 01:00:15,839
you know the uh we know that all the

1567
01:00:15,839 --> 01:00:17,599
we have the we have acquired the locks

1568
01:00:17,599 --> 01:00:19,920
we have verified validated the

1569
01:00:19,920 --> 01:00:22,000
version numbers for the read objects and

1570
01:00:22,000 --> 01:00:25,829
so this is basically the commit point

1571
01:00:25,839 --> 01:00:27,599
or the start of the commit point so at

1572
01:00:27,599 --> 01:00:29,200
this point the transaction is going to

1573
01:00:29,200 --> 01:00:30,000
say

1574
01:00:30,000 --> 01:00:31,599
okay i'm going to go i'm going to go

1575
01:00:31,599 --> 01:00:34,069
commit

1576
01:00:34,079 --> 01:00:36,160
and you know there's a multiple uh

1577
01:00:36,160 --> 01:00:38,079
messages necessary in the commit points

1578
01:00:38,079 --> 01:00:39,119
as we'll see in a second

1579
01:00:39,119 --> 01:00:41,040
and those are mostly for fault tolerance

1580
01:00:41,040 --> 01:00:42,559
reasons

1581
01:00:42,559 --> 01:00:46,480
um and so at this point namely

1582
01:00:46,480 --> 01:00:49,200
uh only the primary you know has been

1583
01:00:49,200 --> 01:00:50,079
the

1584
01:00:50,079 --> 01:00:52,799
only the primaries have been contacted

1585
01:00:52,799 --> 01:00:54,319
of the

1586
01:00:54,319 --> 01:00:56,160
uh of the objects that are being

1587
01:00:56,160 --> 01:00:58,079
modified but not the backgrounds

1588
01:00:58,079 --> 01:00:59,520
and of course you know we want to ensure

1589
01:00:59,520 --> 01:01:01,599
that uh and write you know

1590
01:01:01,599 --> 01:01:04,720
once a commit uh will survive uh

1591
01:01:04,720 --> 01:01:06,799
failures right the system is designed to

1592
01:01:06,799 --> 01:01:09,359
uh handle f plus one failures

1593
01:01:09,359 --> 01:01:12,480
in our particular designs there's uh

1594
01:01:12,480 --> 01:01:14,720
one backup and so it can only survive

1595
01:01:14,720 --> 01:01:16,880
one failure

1596
01:01:16,880 --> 01:01:19,280
and so what happens in this uh final

1597
01:01:19,280 --> 01:01:20,799
phase to commit backup phase

1598
01:01:20,799 --> 01:01:24,400
is actually we're gonna write to the

1599
01:01:24,400 --> 01:01:27,680
logs of the primary of the backups so

1600
01:01:27,680 --> 01:01:31,599
the backups have log so here's backup i

1601
01:01:31,599 --> 01:01:33,280
you know similarly there's a log entry

1602
01:01:33,280 --> 01:01:35,359
in it and

1603
01:01:35,359 --> 01:01:38,720
uh what we're going to do is

1604
01:01:38,720 --> 01:01:41,040
write what's called the commit backup

1605
01:01:41,040 --> 01:01:42,010
record

1606
01:01:42,010 --> 01:01:50,390
[Music]

1607
01:01:50,400 --> 01:01:52,880
and the kabit backward exactly has the

1608
01:01:52,880 --> 01:01:54,960
same information as the

1609
01:01:54,960 --> 01:01:57,920
uh locking record that we saw earlier so

1610
01:01:57,920 --> 01:01:58,559
in it

1611
01:01:58,559 --> 01:02:00,480
it's going to be the version number the

1612
01:02:00,480 --> 01:02:01,839
oid

1613
01:02:01,839 --> 01:02:07,910
and uh the new value

1614
01:02:07,920 --> 01:02:12,079
okay and this is you know like before

1615
01:02:12,079 --> 01:02:18,829
this is actually done using a right

1616
01:02:18,839 --> 01:02:21,200
rdma

1617
01:02:21,200 --> 01:02:22,720
now the backup doesn't really have to do

1618
01:02:22,720 --> 01:02:24,400
any operation

1619
01:02:24,400 --> 01:02:25,839
at this point like the server side of

1620
01:02:25,839 --> 01:02:27,200
the backup doesn't really have to run

1621
01:02:27,200 --> 01:02:27,920
anything

1622
01:02:27,920 --> 01:02:31,200
i just need uh and and so the

1623
01:02:31,200 --> 01:02:33,760
the here's this trick uh were the

1624
01:02:33,760 --> 01:02:34,960
basically the center weights on the

1625
01:02:34,960 --> 01:02:36,720
acknowledgement of the neck

1626
01:02:36,720 --> 01:02:39,760
and so this you know doesn't this is not

1627
01:02:39,760 --> 01:02:40,880
a one-sided

1628
01:02:40,880 --> 01:02:43,599
or a right rdma this is just a nick

1629
01:02:43,599 --> 01:02:45,839
acknowledging that it got the right rdma

1630
01:02:45,839 --> 01:02:47,280
and that the right rdma has been

1631
01:02:47,280 --> 01:02:48,240
performed

1632
01:02:48,240 --> 01:02:49,920
and so that basically acknowledges you

1633
01:02:49,920 --> 01:02:51,680
know when we get this particular point

1634
01:02:51,680 --> 01:02:52,799
in the protocol

1635
01:02:52,799 --> 01:02:56,240
the transaction coordinator knows the

1636
01:02:56,240 --> 01:02:58,000
object is in the log of all the

1637
01:02:58,000 --> 01:03:00,559
primaries and the objects in the

1638
01:03:00,559 --> 01:03:02,960
in the log of all the backups and so now

1639
01:03:02,960 --> 01:03:04,319
we're in a good position in terms of

1640
01:03:04,319 --> 01:03:06,319
fault tolerance correct because

1641
01:03:06,319 --> 01:03:09,359
um if any of one of the two fails then

1642
01:03:09,359 --> 01:03:10,880
the other one can actually apply the

1643
01:03:10,880 --> 01:03:13,829
right operation

1644
01:03:13,839 --> 01:03:17,280
then there's one more step

1645
01:03:17,280 --> 01:03:19,359
that needs to be performed and that is

1646
01:03:19,359 --> 01:03:20,960
the

1647
01:03:20,960 --> 01:03:22,400
commit primary and we'll talk about a

1648
01:03:22,400 --> 01:03:24,720
little bit later in more detail

1649
01:03:24,720 --> 01:03:28,079
but this is the final step where

1650
01:03:28,079 --> 01:03:31,039
there's one more log record written in

1651
01:03:31,039 --> 01:03:32,860
the primary namely a commit record

1652
01:03:32,860 --> 01:03:38,470
[Music]

1653
01:03:38,480 --> 01:03:40,079
and the commit record just assessed the

1654
01:03:40,079 --> 01:03:42,839
transaction id that actually is being

1655
01:03:42,839 --> 01:03:44,960
committed

1656
01:03:44,960 --> 01:03:46,880
and so like every i didn't write that

1657
01:03:46,880 --> 01:03:48,480
down in the other records but every

1658
01:03:48,480 --> 01:03:50,000
record has a transaction id so that we

1659
01:03:50,000 --> 01:03:51,280
know which transaction we're talking

1660
01:03:51,280 --> 01:03:53,359
about

1661
01:03:53,359 --> 01:03:56,880
and uh and again this uses the same sort

1662
01:03:56,880 --> 01:03:58,160
of strategy there's a

1663
01:03:58,160 --> 01:04:05,270
right rdma to append

1664
01:04:05,280 --> 01:04:08,880
to the uh to the log

1665
01:04:08,880 --> 01:04:10,640
and you know there's an acknowledgement

1666
01:04:10,640 --> 01:04:13,359
the nic acknowledges

1667
01:04:13,359 --> 01:04:17,119
the the right rdna and so but it doesn't

1668
01:04:17,119 --> 01:04:17,680
require

1669
01:04:17,680 --> 01:04:20,400
any interrupts or there's no the server

1670
01:04:20,400 --> 01:04:21,599
itself is not being

1671
01:04:21,599 --> 01:04:24,160
interfered with just the nic is involved

1672
01:04:24,160 --> 01:04:26,960
in these two operations

1673
01:04:26,960 --> 01:04:30,000
then as soon as the one of the

1674
01:04:30,000 --> 01:04:33,039
nics acknowledges the commit

1675
01:04:33,039 --> 01:04:35,359
record on one of the primaries at that

1676
01:04:35,359 --> 01:04:36,559
particular point in time

1677
01:04:36,559 --> 01:04:38,880
the transaction really truly committed

1678
01:04:38,880 --> 01:04:43,750
so this is the true commit point

1679
01:04:43,760 --> 01:04:45,359
the commit starts basically here and

1680
01:04:45,359 --> 01:04:47,200
this is actually the actual commit point

1681
01:04:47,200 --> 01:04:49,680
and at that particular point in time the

1682
01:04:49,680 --> 01:04:51,200
transaction coordinator informs the

1683
01:04:51,200 --> 01:04:52,000
application

1684
01:04:52,000 --> 01:04:54,559
yes your transaction has committed and

1685
01:04:54,559 --> 01:04:57,430
uh is done

1686
01:04:57,440 --> 01:04:59,039
then you know of course your point later

1687
01:04:59,039 --> 01:05:00,720
the logs need to be cleaned and

1688
01:05:00,720 --> 01:05:02,240
shortened up and truncated and all that

1689
01:05:02,240 --> 01:05:03,200
kind of stuff and this is like the

1690
01:05:03,200 --> 01:05:04,160
truncated

1691
01:05:04,160 --> 01:05:06,880
uh phase and that's basically piggly

1692
01:05:06,880 --> 01:05:08,000
back on later

1693
01:05:08,000 --> 01:05:11,359
walking faces and validation phases

1694
01:05:11,359 --> 01:05:12,480
and so i'm not really going to talk

1695
01:05:12,480 --> 01:05:14,640
about it at all but basically it is to

1696
01:05:14,640 --> 01:05:15,839
truncate the logs

1697
01:05:15,839 --> 01:05:23,599
so that they don't grow unbindedly

1698
01:05:23,599 --> 01:05:27,359
uh sorry but the hardware

1699
01:05:27,359 --> 01:05:31,520
acts they just go directly into

1700
01:05:31,520 --> 01:05:34,960
into the neck of the coordinator

1701
01:05:34,960 --> 01:05:37,520
yeah so let's go back to the rda picture

1702
01:05:37,520 --> 01:05:38,319
right

1703
01:05:38,319 --> 01:05:41,520
so if a right rdma happens uh

1704
01:05:41,520 --> 01:05:44,319
so you're gonna write rdma the sender

1705
01:05:44,319 --> 01:05:46,079
the coordinator was running here right

1706
01:05:46,079 --> 01:05:47,920
and here's maybe one of the primaries or

1707
01:05:47,920 --> 01:05:50,160
the backups and

1708
01:05:50,160 --> 01:05:52,319
so the right argument goes in you know

1709
01:05:52,319 --> 01:05:54,880
writes maybe an entry into the log

1710
01:05:54,880 --> 01:05:57,119
the nick does that the nick sends an

1711
01:05:57,119 --> 01:06:00,150
acknowledgement back

1712
01:06:00,160 --> 01:06:02,000
and the coordinator will see that

1713
01:06:02,000 --> 01:06:07,109
announcement in the received queue

1714
01:06:07,119 --> 01:06:08,880
and so as soon as the coordinator sees

1715
01:06:08,880 --> 01:06:10,480
the ack you know for

1716
01:06:10,480 --> 01:06:13,839
uh it's one right rdma

1717
01:06:13,839 --> 01:06:17,280
it can proceed and knows that the right

1718
01:06:17,280 --> 01:06:23,829
argument they succeeded

1719
01:06:23,839 --> 01:06:27,119
so does the right rdmas only write to

1720
01:06:27,119 --> 01:06:27,760
the log

1721
01:06:27,760 --> 01:06:30,880
they they're in two cases

1722
01:06:30,880 --> 01:06:32,960
uh they're both used for these message

1723
01:06:32,960 --> 01:06:34,400
queues and for the

1724
01:06:34,400 --> 01:06:41,510
uh the log append

1725
01:06:41,520 --> 01:06:44,240
um so when we say that that a right rdma

1726
01:06:44,240 --> 01:06:45,839
has been performed we mean that it has

1727
01:06:45,839 --> 01:06:46,960
been attended to the log

1728
01:06:46,960 --> 01:06:49,280
and not actually executed necessarily by

1729
01:06:49,280 --> 01:06:50,079
the application

1730
01:06:50,079 --> 01:06:52,240
that's correct that's correct so for

1731
01:06:52,240 --> 01:06:54,000
example you know to for example to do

1732
01:06:54,000 --> 01:06:54,240
the

1733
01:06:54,240 --> 01:06:57,520
for the backup to actually uh perform

1734
01:06:57,520 --> 01:06:59,039
the update to the object you know it

1735
01:06:59,039 --> 01:07:00,960
needs to read the log entry and then

1736
01:07:00,960 --> 01:07:03,599
apply the update

1737
01:07:03,599 --> 01:07:05,839
i see and also for the lock bit for

1738
01:07:05,839 --> 01:07:08,079
every object so since everything resides

1739
01:07:08,079 --> 01:07:08,400
in

1740
01:07:08,400 --> 01:07:10,240
memory and we have like 64 bits for the

1741
01:07:10,240 --> 01:07:12,400
version number plus the lock bit

1742
01:07:12,400 --> 01:07:14,319
so i'm assuming that it can fit in a

1743
01:07:14,319 --> 01:07:16,079
single memory address

1744
01:07:16,079 --> 01:07:17,599
but we can still have the problem of

1745
01:07:17,599 --> 01:07:19,359
let's say like the processor

1746
01:07:19,359 --> 01:07:21,039
fetching that memory address into the

1747
01:07:21,039 --> 01:07:23,280
register uh and then maybe if we have

1748
01:07:23,280 --> 01:07:24,559
like a multi-core

1749
01:07:24,559 --> 01:07:27,280
uh machine then another core fetching

1750
01:07:27,280 --> 01:07:28,319
that uh

1751
01:07:28,319 --> 01:07:30,160
like that same address and then both of

1752
01:07:30,160 --> 01:07:32,480
them flipping from zero to one

1753
01:07:32,480 --> 01:07:34,319
so uh so i'm assuming that there's some

1754
01:07:34,319 --> 01:07:36,000
support from the hardware there

1755
01:07:36,000 --> 01:07:37,599
yeah so like as i mentioned a little bit

1756
01:07:37,599 --> 01:07:39,440
earlier the primary when it acquires

1757
01:07:39,440 --> 01:07:40,799
so the primary is actually involved

1758
01:07:40,799 --> 01:07:43,520
correct in the primary on the

1759
01:07:43,520 --> 01:07:46,880
uh there's the coordinator sense so

1760
01:07:46,880 --> 01:07:48,960
in the lock step like this this step

1761
01:07:48,960 --> 01:07:50,559
correct step one

1762
01:07:50,559 --> 01:07:53,039
the primary or the coordinator sends an

1763
01:07:53,039 --> 01:07:53,680
uh

1764
01:07:53,680 --> 01:07:56,960
a right rdma to the

1765
01:07:56,960 --> 01:07:59,280
to the primaries asking the primaries to

1766
01:07:59,280 --> 01:08:00,160
lock

1767
01:08:00,160 --> 01:08:03,599
the object and

1768
01:08:03,599 --> 01:08:06,319
the primaries answer explicitly with a

1769
01:08:06,319 --> 01:08:06,880
message

1770
01:08:06,880 --> 01:08:10,079
that reply and so this crucial

1771
01:08:10,079 --> 01:08:12,319
step that happens is at the primary when

1772
01:08:12,319 --> 01:08:13,920
it actually tries to get the lock

1773
01:08:13,920 --> 01:08:17,040
and that lock uh is set you know the

1774
01:08:17,040 --> 01:08:18,880
reason this is a one single 64-bit

1775
01:08:18,880 --> 01:08:19,520
number

1776
01:08:19,520 --> 01:08:20,960
is so that you can use intestine set

1777
01:08:20,960 --> 01:08:23,199
instruction which is atomic

1778
01:08:23,199 --> 01:08:27,359
to set the walk so if two

1779
01:08:27,359 --> 01:08:29,520
uh so this is never the case like

1780
01:08:29,520 --> 01:08:30,640
there's only if two

1781
01:08:30,640 --> 01:08:31,759
tests and second structures run at

1782
01:08:31,759 --> 01:08:34,000
exactly at the same time one is going to

1783
01:08:34,000 --> 01:08:36,400
win the other is going to lose

1784
01:08:36,400 --> 01:08:38,960
i see thank you and that's a crucial

1785
01:08:38,960 --> 01:08:39,440
point

1786
01:08:39,440 --> 01:08:44,239
right i've started a question

1787
01:08:44,239 --> 01:08:49,199
about the blue commit point yeah um

1788
01:08:49,199 --> 01:08:52,400
wouldn't it so should i let me uh maybe

1789
01:08:52,400 --> 01:08:54,080
it's better to actually uh

1790
01:08:54,080 --> 01:08:55,679
open a new slide with the picture again

1791
01:08:55,679 --> 01:08:58,159
and just uh instead of scribbling even

1792
01:08:58,159 --> 01:08:59,359
more over this

1793
01:08:59,359 --> 01:09:01,359
let me let's get one more picture so we

1794
01:09:01,359 --> 01:09:14,390
can talk about other scenarios

1795
01:09:14,400 --> 01:09:18,470
a little bit bigger

1796
01:09:18,480 --> 01:09:21,839
okay uh so you're worried about

1797
01:09:21,839 --> 01:09:24,719
let me see yeah the commit point between

1798
01:09:24,719 --> 01:09:25,359
step

1799
01:09:25,359 --> 01:09:27,679
after step two but before step three

1800
01:09:27,679 --> 01:09:28,560
yeah so here

1801
01:09:28,560 --> 01:09:30,400
um here's the decision correct you're

1802
01:09:30,400 --> 01:09:32,719
right starting to commit and then

1803
01:09:32,719 --> 01:09:35,359
basically here's the actual complete

1804
01:09:35,359 --> 01:09:35,759
point

1805
01:09:35,759 --> 01:09:39,199
where okay um yeah i guess

1806
01:09:39,199 --> 01:09:41,199
i was trying to think about the scenario

1807
01:09:41,199 --> 01:09:42,560
where

1808
01:09:42,560 --> 01:09:45,440
wouldn't it be possible for a completely

1809
01:09:45,440 --> 01:09:47,759
separate concurrent transaction

1810
01:09:47,759 --> 01:09:51,759
that writes only p3 to get interleaved

1811
01:09:51,759 --> 01:09:55,760
to like start and complete in that space

1812
01:09:55,760 --> 01:09:58,320
and then wouldn't that no wouldn't be

1813
01:09:58,320 --> 01:09:59,360
problematic

1814
01:09:59,360 --> 01:10:00,560
yeah it would be problematic but it

1815
01:10:00,560 --> 01:10:02,239
can't correct because when it writes it

1816
01:10:02,239 --> 01:10:04,560
has to get the lock at some point

1817
01:10:04,560 --> 01:10:06,320
and when we get the lock we check the

1818
01:10:06,320 --> 01:10:09,990
version number and the lock bit

1819
01:10:10,000 --> 01:10:12,960
but does the read does the read the p3

1820
01:10:12,960 --> 01:10:15,280
affect the version number and lock it

1821
01:10:15,280 --> 01:10:19,199
no no it just gets the version number

1822
01:10:19,199 --> 01:10:22,640
but it's like okay let me

1823
01:10:22,640 --> 01:10:23,840
hold that question we're going to come

1824
01:10:23,840 --> 01:10:26,400
back at this and then we'll see

1825
01:10:26,400 --> 01:10:28,960
what actually happens all right sounds

1826
01:10:28,960 --> 01:10:31,520
good thanks

1827
01:10:31,520 --> 01:10:34,870
any other questions

1828
01:10:34,880 --> 01:10:36,400
this might be like a separate scenario

1829
01:10:36,400 --> 01:10:38,480
but what happens if um

1830
01:10:38,480 --> 01:10:42,000
uh you know after the execution phase

1831
01:10:42,000 --> 01:10:45,120
uh you know it tries to acquire a lock

1832
01:10:45,120 --> 01:10:47,679
and then crashes right after that and

1833
01:10:47,679 --> 01:10:49,440
the lock has been acquired but no one

1834
01:10:49,440 --> 01:10:51,920
else after that can acquire it

1835
01:10:51,920 --> 01:10:53,520
yeah okay so well first of all that

1836
01:10:53,520 --> 01:10:55,199
machine disappears from the earth

1837
01:10:55,199 --> 01:10:57,040
correct and the memory content is gone

1838
01:10:57,040 --> 01:10:59,280
too

1839
01:10:59,280 --> 01:11:02,640
and in the whole recovery protocol that

1840
01:11:02,640 --> 01:11:04,080
is described in the next section in the

1841
01:11:04,080 --> 01:11:04,640
paper

1842
01:11:04,640 --> 01:11:08,000
kicks in and that protocol in the end

1843
01:11:08,000 --> 01:11:08,480
will

1844
01:11:08,480 --> 01:11:17,510
abort that transaction

1845
01:11:17,520 --> 01:11:26,400
so it actually will get cleaned up

1846
01:11:26,400 --> 01:11:29,120
just another question uh so so here like

1847
01:11:29,120 --> 01:11:30,719
the coordinator

1848
01:11:30,719 --> 01:11:32,480
is the client right like it's the

1849
01:11:32,480 --> 01:11:34,080
application yeah well

1850
01:11:34,080 --> 01:11:37,199
yeah it is sure and so the client is

1851
01:11:37,199 --> 01:11:38,000
basically doing

1852
01:11:38,000 --> 01:11:40,320
all the steps of like log value that

1853
01:11:40,320 --> 01:11:42,239
commit yeah yeah yeah so

1854
01:11:42,239 --> 01:11:43,440
you can think about the application is

1855
01:11:43,440 --> 01:11:45,440
running on the same set of 90 machines

1856
01:11:45,440 --> 01:11:47,679
right and you know running this

1857
01:11:47,679 --> 01:11:48,480
transaction

1858
01:11:48,480 --> 01:11:50,159
which apparently you know writes two

1859
01:11:50,159 --> 01:11:51,600
objects in reach one

1860
01:11:51,600 --> 01:11:55,040
and runs the protocol and

1861
01:11:55,040 --> 01:11:58,320
so um i guess what's confusing is

1862
01:11:58,320 --> 01:12:00,560
so does the primary not communicate with

1863
01:12:00,560 --> 01:12:02,159
the backup directly

1864
01:12:02,159 --> 01:12:04,880
it's the no it's actually indeed the

1865
01:12:04,880 --> 01:12:06,320
primary does not directly communicate

1866
01:12:06,320 --> 01:12:09,920
with the backup nice

1867
01:12:09,920 --> 01:12:11,600
other than during the recovery protocol

1868
01:12:11,600 --> 01:12:12,560
there's all kinds of communication

1869
01:12:12,560 --> 01:12:18,470
happening but that's not shown here

1870
01:12:18,480 --> 01:12:20,239
so the coordinator just uses the

1871
01:12:20,239 --> 01:12:22,400
configuration from the zookeeper

1872
01:12:22,400 --> 01:12:24,880
yeah yeah yeah okay so going back to

1873
01:12:24,880 --> 01:12:26,560
this very first picture

1874
01:12:26,560 --> 01:12:28,080
uh and you know there's all kinds of

1875
01:12:28,080 --> 01:12:29,600
stuff you know related to this too that

1876
01:12:29,600 --> 01:12:30,960
i'm not talking about

1877
01:12:30,960 --> 01:12:32,719
uh like this precise membership and all

1878
01:12:32,719 --> 01:12:34,880
that kind of thing uh but basically the

1879
01:12:34,880 --> 01:12:36,320
suit keeper and the connection manager

1880
01:12:36,320 --> 01:12:38,000
really decide okay well this is this is

1881
01:12:38,000 --> 01:12:38,960
a configuration

1882
01:12:38,960 --> 01:12:40,560
the current configuration we're running

1883
01:12:40,560 --> 01:12:42,400
in these are the regions

1884
01:12:42,400 --> 01:12:43,679
how they're mapped and prime engine

1885
01:12:43,679 --> 01:12:46,480
backups and all that stuff

1886
01:12:46,480 --> 01:12:48,239
and in any failure it happens you know

1887
01:12:48,239 --> 01:12:49,920
there's a whole reconfiguration process

1888
01:12:49,920 --> 01:13:00,790
going on in recovery

1889
01:13:00,800 --> 01:13:03,760
okay maybe i'm going to skip the

1890
01:13:03,760 --> 01:13:04,640
breakout room

1891
01:13:04,640 --> 01:13:07,600
uh so i can uh go a little bit further

1892
01:13:07,600 --> 01:13:08,159
uh

1893
01:13:08,159 --> 01:13:10,080
the question you know i wanted to answer

1894
01:13:10,080 --> 01:13:12,320
the question uh in the

1895
01:13:12,320 --> 01:13:13,840
uh that was asking the post in the

1896
01:13:13,840 --> 01:13:15,440
lecture and i'm going to as a lecturer

1897
01:13:15,440 --> 01:13:16,080
question and

1898
01:13:16,080 --> 01:13:18,080
i'm just going to do that by talking

1899
01:13:18,080 --> 01:13:20,000
about an example a transaction and this

1900
01:13:20,000 --> 01:13:22,000
also comes to the earlier question about

1901
01:13:22,000 --> 01:13:23,679
uh you know what happens you know two

1902
01:13:23,679 --> 01:13:26,400
transactions run and read one version

1903
01:13:26,400 --> 01:13:28,880
and then it commits and all that all

1904
01:13:28,880 --> 01:13:30,159
this stuff so

1905
01:13:30,159 --> 01:13:32,560
uh so this is really the topic here is

1906
01:13:32,560 --> 01:13:33,520
going to do we get strict

1907
01:13:33,520 --> 01:13:39,510
serializability

1908
01:13:39,520 --> 01:13:41,040
and what i'm going to do is like i'm not

1909
01:13:41,040 --> 01:13:42,400
going to give you a proof you know never

1910
01:13:42,400 --> 01:13:43,760
getting straight around very ability

1911
01:13:43,760 --> 01:13:44,800
instead what i'm going to do is i'm

1912
01:13:44,800 --> 01:13:47,199
going to walk for one or two examples

1913
01:13:47,199 --> 01:13:49,520
uh to get build up some intuition and

1914
01:13:49,520 --> 01:13:51,040
hopefully that intuition you know sort

1915
01:13:51,040 --> 01:13:52,480
of convinces us you know that

1916
01:13:52,480 --> 01:13:55,199
things might actually be fine so let's

1917
01:13:55,199 --> 01:13:56,640
let's look at the following transaction

1918
01:13:56,640 --> 01:14:00,480
we have t10 begin and this transaction

1919
01:14:00,480 --> 01:14:01,520
is you know

1920
01:14:01,520 --> 01:14:08,550
like in the beginning it reads an object

1921
01:14:08,560 --> 01:14:13,189
adds one

1922
01:14:13,199 --> 01:14:18,149
and then write

1923
01:14:18,159 --> 01:14:21,600
the object and commits or

1924
01:14:21,600 --> 01:14:25,920
ends of course commit by fail

1925
01:14:25,920 --> 01:14:28,960
so that's the transaction and you know

1926
01:14:28,960 --> 01:14:30,000
we want to

1927
01:14:30,000 --> 01:14:31,679
ask ourselves like what are the legal

1928
01:14:31,679 --> 01:14:33,120
outcomes right what are the

1929
01:14:33,120 --> 01:14:42,080
outcomes that are correct

1930
01:14:42,080 --> 01:14:44,239
uh so what are the possible outcomes of

1931
01:14:44,239 --> 01:14:44,930
this injection

1932
01:14:44,930 --> 01:14:47,199
[Music]

1933
01:14:47,199 --> 01:14:49,120
what could be the state of let's say x

1934
01:14:49,120 --> 01:14:50,800
started at zero

1935
01:14:50,800 --> 01:14:52,400
and we're running two transactions you

1936
01:14:52,400 --> 01:14:54,560
know t1

1937
01:14:54,560 --> 01:14:58,800
and t2 what are the possible outcomes

1938
01:14:58,800 --> 01:15:00,000
that are

1939
01:15:00,000 --> 01:15:04,070
uh fine

1940
01:15:04,080 --> 01:15:06,400
um either one of them could commit or

1941
01:15:06,400 --> 01:15:08,239
both of them could commit

1942
01:15:08,239 --> 01:15:10,880
yeah and so we can have access to

1943
01:15:10,880 --> 01:15:12,880
correct we both commit

1944
01:15:12,880 --> 01:15:15,040
uh action one is a possibility one

1945
01:15:15,040 --> 01:15:16,640
commits and you want another award for

1946
01:15:16,640 --> 01:15:18,239
example they truly run concurrently or

1947
01:15:18,239 --> 01:15:19,280
something

1948
01:15:19,280 --> 01:15:25,280
and any other possible outcomes

1949
01:15:25,280 --> 01:15:27,600
yeah zero if you know basically both

1950
01:15:27,600 --> 01:15:28,480
aboard correct

1951
01:15:28,480 --> 01:15:31,600
maybe there's a crash okay so those are

1952
01:15:31,600 --> 01:15:33,600
the three legal outcomes

1953
01:15:33,600 --> 01:15:36,239
um and so that's you just have to make

1954
01:15:36,239 --> 01:15:37,440
sure that is the case so

1955
01:15:37,440 --> 01:15:40,239
let's say p1 runs and so it does a read

1956
01:15:40,239 --> 01:15:41,199
operation

1957
01:15:41,199 --> 01:15:44,159
it gets x back maybe at version zero

1958
01:15:44,159 --> 01:15:44,719
same thing

1959
01:15:44,719 --> 01:15:48,080
with t2 it reads you know uh

1960
01:15:48,080 --> 01:15:51,280
access zero and so it gets

1961
01:15:51,280 --> 01:15:53,440
basically to run through the concurrent

1962
01:15:53,440 --> 01:15:55,199
and you know this is the question i

1963
01:15:55,199 --> 01:15:56,560
think this sort of was asked or in the

1964
01:15:56,560 --> 01:15:57,520
last question we do

1965
01:15:57,520 --> 01:16:01,440
lock effects we do a lock effects and

1966
01:16:01,440 --> 01:16:03,760
um and here's sort of the crucial step

1967
01:16:03,760 --> 01:16:05,600
correct because at this particular point

1968
01:16:05,600 --> 01:16:06,400
uh

1969
01:16:06,400 --> 01:16:08,560
there are we're trying to get the locks

1970
01:16:08,560 --> 01:16:09,520
on object

1971
01:16:09,520 --> 01:16:14,790
zero and uh can both succeed

1972
01:16:14,800 --> 01:16:18,640
in reading x

1973
01:16:18,640 --> 01:16:20,800
oh and getting the lock um not at the

1974
01:16:20,800 --> 01:16:22,159
same time

1975
01:16:22,159 --> 01:16:24,320
no so one is gonna one is gonna succeed

1976
01:16:24,320 --> 01:16:25,360
correct

1977
01:16:25,360 --> 01:16:27,199
and so let's say the first one succeeds

1978
01:16:27,199 --> 01:16:28,719
and gets the walk

1979
01:16:28,719 --> 01:16:31,760
that means it can commit right so this

1980
01:16:31,760 --> 01:16:33,280
guy will commit

1981
01:16:33,280 --> 01:16:35,760
um and uh what happens with the second

1982
01:16:35,760 --> 01:16:36,880
guy

1983
01:16:36,880 --> 01:16:39,520
um the second one if it tries to obtain

1984
01:16:39,520 --> 01:16:40,880
the lock at the same time that the first

1985
01:16:40,880 --> 01:16:42,239
one is holding the lock it will abort

1986
01:16:42,239 --> 01:16:43,360
and stop

1987
01:16:43,360 --> 01:16:45,440
um if the first transaction goes through

1988
01:16:45,440 --> 01:16:47,520
all the way and the lock is released

1989
01:16:47,520 --> 01:16:49,360
then it will obtain the lock and then

1990
01:16:49,360 --> 01:16:51,040
check to see whether

1991
01:16:51,040 --> 01:16:53,360
the version that it has for x is still

1992
01:16:53,360 --> 01:16:54,320
correct

1993
01:16:54,320 --> 01:16:56,320
um and it will find that the version has

1994
01:16:56,320 --> 01:16:58,320
been changed and then it will abort

1995
01:16:58,320 --> 01:17:00,239
yep yep good this is exactly the the

1996
01:17:00,239 --> 01:17:02,080
true the two cases

1997
01:17:02,080 --> 01:17:03,760
so let me talk about the validation case

1998
01:17:03,760 --> 01:17:05,440
in this in a second with a slightly

1999
01:17:05,440 --> 01:17:06,480
different example to make it more

2000
01:17:06,480 --> 01:17:07,360
interesting

2001
01:17:07,360 --> 01:17:09,440
uh but this is the basically the outcome

2002
01:17:09,440 --> 01:17:11,440
correct

2003
01:17:11,440 --> 01:17:13,920
good and so even though these

2004
01:17:13,920 --> 01:17:14,480
transactions

2005
01:17:14,480 --> 01:17:16,000
mean this particular picture ran you

2006
01:17:16,000 --> 01:17:17,600
know exactly at the same time

2007
01:17:17,600 --> 01:17:20,080
uh they're actually getting ordered and

2008
01:17:20,080 --> 01:17:21,840
one wins and the other one loses

2009
01:17:21,840 --> 01:17:22,880
and that means that the other one that

2010
01:17:22,880 --> 01:17:25,520
lost can run again it will run then read

2011
01:17:25,520 --> 01:17:25,760
r

2012
01:17:25,760 --> 01:17:27,920
axis one and then hopefully succeed in

2013
01:17:27,920 --> 01:17:29,440
the retry

2014
01:17:29,440 --> 01:17:32,630
okay

2015
01:17:32,640 --> 01:17:36,470
okay so um

2016
01:17:36,480 --> 01:17:39,830
uh

2017
01:17:39,840 --> 01:17:42,400
okay let me do one example and then i'll

2018
01:17:42,400 --> 01:17:44,400
stop and i'll resume on uh

2019
01:17:44,400 --> 01:17:47,760
on on thursday uh let's see what time is

2020
01:17:47,760 --> 01:17:50,080
it 24. let me actually just stop here

2021
01:17:50,080 --> 01:17:53,280
and then i'll do a second example that

2022
01:17:53,280 --> 01:17:56,400
answers that earlier question uh on on

2023
01:17:56,400 --> 01:17:57,120
thursday

2024
01:17:57,120 --> 01:18:00,560
and uh also talk about fault tolerance

2025
01:18:00,560 --> 01:18:03,840
i don't want to run too much over time

2026
01:18:03,840 --> 01:18:05,840
uh anybody that has to go please feel

2027
01:18:05,840 --> 01:18:07,920
free to go uh

2028
01:18:07,920 --> 01:18:09,920
and i'll see you on thursday uh anyone

2029
01:18:09,920 --> 01:18:12,320
who has would like to ask

2030
01:18:12,320 --> 01:18:14,080
more questions you know please feel free

2031
01:18:14,080 --> 01:18:15,920
to stay and i'll try to try the best

2032
01:18:15,920 --> 01:18:18,159
to answer them as you see this is a

2033
01:18:18,159 --> 01:18:19,520
complicated paper

2034
01:18:19,520 --> 01:18:22,640
uh and i'm glad that we're going there

2035
01:18:22,640 --> 01:18:24,080
we're able to go in sort of depth we're

2036
01:18:24,080 --> 01:18:26,560
trying to really understand at least

2037
01:18:26,560 --> 01:18:32,390
the the protocol for normal operation

2038
01:18:32,400 --> 01:18:34,080
so like that i just like when i finish

2039
01:18:34,080 --> 01:18:35,760
this lecture and

2040
01:18:35,760 --> 01:18:37,440
if you see your first day or if you have

2041
01:18:37,440 --> 01:18:41,120
any questions please hang around

2042
01:18:41,120 --> 01:18:44,080
i had two like the high level questions

2043
01:18:44,080 --> 01:18:45,040
one was

2044
01:18:45,040 --> 01:18:48,719
um this this whole

2045
01:18:48,719 --> 01:18:51,040
hardware structure that you're using

2046
01:18:51,040 --> 01:18:52,000
would it be

2047
01:18:52,000 --> 01:18:53,920
useful at all if you're using it with

2048
01:18:53,920 --> 01:18:56,960
pessimistic and currency control

2049
01:18:56,960 --> 01:18:58,800
yes you know i'm sure you could make the

2050
01:18:58,800 --> 01:19:01,040
pessimistic foreign also better because

2051
01:19:01,040 --> 01:19:03,920
your rpcs are just cheaper correct but

2052
01:19:03,920 --> 01:19:04,719
the real thing

2053
01:19:04,719 --> 01:19:06,400
and i haven't gotten i haven't been able

2054
01:19:06,400 --> 01:19:07,679
to point this out yet but i was planning

2055
01:19:07,679 --> 01:19:08,560
to

2056
01:19:08,560 --> 01:19:11,600
what i can do now is if you look at the

2057
01:19:11,600 --> 01:19:13,679
read-only transactions here

2058
01:19:13,679 --> 01:19:16,800
so read-only transactions so you view a

2059
01:19:16,800 --> 01:19:18,400
transaction that basically only reads an

2060
01:19:18,400 --> 01:19:19,520
object or

2061
01:19:19,520 --> 01:19:24,790
multiple objects

2062
01:19:24,800 --> 01:19:26,400
what's the performance how good is that

2063
01:19:26,400 --> 01:19:30,470
like how well is that going to perform

2064
01:19:30,480 --> 01:19:32,719
um probably pretty well since you only

2065
01:19:32,719 --> 01:19:34,080
do the

2066
01:19:34,080 --> 01:19:36,800
one-sided yeah correctly if you look at

2067
01:19:36,800 --> 01:19:38,480
the object that is stored at

2068
01:19:38,480 --> 01:19:41,199
uh region three correct which is the

2069
01:19:41,199 --> 01:19:42,480
object that's being read

2070
01:19:42,480 --> 01:19:44,560
the only thing that happens is one-sided

2071
01:19:44,560 --> 01:19:48,229
reads

2072
01:19:48,239 --> 01:19:52,229
or one-sided maze correct

2073
01:19:52,239 --> 01:19:55,600
and there's no uh rights uh

2074
01:19:55,600 --> 01:19:58,880
nothing at all uh so uh those

2075
01:19:58,880 --> 01:20:02,640
uh because of the uh this

2076
01:20:02,640 --> 01:20:04,320
because the read operations don't

2077
01:20:04,320 --> 01:20:05,760
require logs there's nothing to be

2078
01:20:05,760 --> 01:20:07,199
written

2079
01:20:07,199 --> 01:20:08,400
the only thing that needs to happen is

2080
01:20:08,400 --> 01:20:10,320
this validation step which also is a

2081
01:20:10,320 --> 01:20:12,000
one-sided rdma

2082
01:20:12,000 --> 01:20:13,679
so read-only transaction can just run

2083
01:20:13,679 --> 01:20:16,800
with two one-sided rdnas

2084
01:20:16,800 --> 01:20:18,560
and and that's where the big one comes

2085
01:20:18,560 --> 01:20:19,920
from and

2086
01:20:19,920 --> 01:20:21,360
and the reason that that bitcoin is

2087
01:20:21,360 --> 01:20:22,960
there is because of the optimistic

2088
01:20:22,960 --> 01:20:24,239
currency control

2089
01:20:24,239 --> 01:20:26,480
so i think basically to exploit our dna

2090
01:20:26,480 --> 01:20:27,920
sort of two is foolish

2091
01:20:27,920 --> 01:20:30,159
fullest and i'm trying to make read-only

2092
01:20:30,159 --> 01:20:33,840
transactions really really fast

2093
01:20:33,840 --> 01:20:35,920
they got went to optimistic concurrency

2094
01:20:35,920 --> 01:20:38,390
control

2095
01:20:38,400 --> 01:20:41,440
okay i see i see it makes sense another

2096
01:20:41,440 --> 01:20:42,239
question was about

2097
01:20:42,239 --> 01:20:45,679
like security is this thing isn't going

2098
01:20:45,679 --> 01:20:47,600
to be secure if it's

2099
01:20:47,600 --> 01:20:50,480
um i guess the bro someone already asked

2100
01:20:50,480 --> 01:20:51,920
about this but

2101
01:20:51,920 --> 01:20:54,560
the part where the neck just reads

2102
01:20:54,560 --> 01:20:55,280
memory

2103
01:20:55,280 --> 01:20:57,520
it seems a little scary so yeah yeah

2104
01:20:57,520 --> 01:20:59,360
yeah it's totally scary

2105
01:20:59,360 --> 01:21:01,199
uh and so there there's there's some

2106
01:21:01,199 --> 01:21:02,560
bunch of interaction uh

2107
01:21:02,560 --> 01:21:04,400
between you know when the rdma

2108
01:21:04,400 --> 01:21:05,679
connection is set up

2109
01:21:05,679 --> 01:21:06,960
uh the operating system in the

2110
01:21:06,960 --> 01:21:09,669
application

2111
01:21:09,679 --> 01:21:11,280
so the operating system won't allow you

2112
01:21:11,280 --> 01:21:12,960
know the nic to write to any

2113
01:21:12,960 --> 01:21:14,960
arbitrary location it will tell it you

2114
01:21:14,960 --> 01:21:16,560
know here the address is

2115
01:21:16,560 --> 01:21:19,120
here's the vm virtual memory addresses

2116
01:21:19,120 --> 01:21:21,199
that you can write to

2117
01:21:21,199 --> 01:21:24,960
okay so you can make that product yes

2118
01:21:24,960 --> 01:21:28,239
exactly question about the

2119
01:21:28,239 --> 01:21:31,679
performance yep so if you have so

2120
01:21:31,679 --> 01:21:34,239
the reads are are quick because of the

2121
01:21:34,239 --> 01:21:35,920
one-sided rdmas

2122
01:21:35,920 --> 01:21:38,159
yep but if you have a lot of rights

2123
01:21:38,159 --> 01:21:39,040
happening like

2124
01:21:39,040 --> 01:21:41,760
a lot of data and contention um oh yeah

2125
01:21:41,760 --> 01:21:42,800
that's still the case

2126
01:21:42,800 --> 01:21:45,199
or no correct like what happens if you

2127
01:21:45,199 --> 01:21:46,159
have contention

2128
01:21:46,159 --> 01:21:47,440
actually we saw this in this particular

2129
01:21:47,440 --> 01:21:49,600
case correct

2130
01:21:49,600 --> 01:21:52,790
yeah if there's one

2131
01:21:52,800 --> 01:21:54,000
and we have a lot of potential one of

2132
01:21:54,000 --> 01:21:57,199
the transactions will abort

2133
01:21:57,199 --> 01:21:59,600
so this is really good for transactions

2134
01:21:59,600 --> 01:22:01,040
that don't contend

2135
01:22:01,040 --> 01:22:03,040
or not writing to the same records or

2136
01:22:03,040 --> 01:22:05,280
same objects

2137
01:22:05,280 --> 01:22:08,000
and even the reads right yeah even the

2138
01:22:08,000 --> 01:22:09,360
reads right because the version numbers

2139
01:22:09,360 --> 01:22:13,110
might change

2140
01:22:13,120 --> 01:22:15,440
so what's like the main um i guess use

2141
01:22:15,440 --> 01:22:17,120
case for

2142
01:22:17,120 --> 01:22:18,480
there's a lot of you know okay so

2143
01:22:18,480 --> 01:22:20,080
there's a lot of studies independent of

2144
01:22:20,080 --> 01:22:21,679
this paper about pessimistic versus

2145
01:22:21,679 --> 01:22:22,239
optimistic

2146
01:22:22,239 --> 01:22:25,600
currency control and you know clearly

2147
01:22:25,600 --> 01:22:27,440
from the two benchmarks that they use in

2148
01:22:27,440 --> 01:22:30,080
the paper like tpcc and tatp

2149
01:22:30,080 --> 01:22:32,320
there's not a lot of uh not a lot of

2150
01:22:32,320 --> 01:22:35,590
conflicts

2151
01:22:35,600 --> 01:22:37,040
so this is actually submitted maybe by

2152
01:22:37,040 --> 01:22:38,639
different users or different clients and

2153
01:22:38,639 --> 01:22:45,590
they basically touch different tables

2154
01:22:45,600 --> 01:22:48,880
so i have a question if there's multiple

2155
01:22:48,880 --> 01:22:50,159
clients

2156
01:22:50,159 --> 01:22:53,760
doing transactions on the same objects

2157
01:22:53,760 --> 01:22:57,679
um how so that they want to do a right

2158
01:22:57,679 --> 01:22:59,040
rdma right to

2159
01:22:59,040 --> 01:23:02,880
to to the log um

2160
01:23:02,880 --> 01:23:04,639
is it possible that there would be like

2161
01:23:04,639 --> 01:23:06,560
a conflict like you know like one of

2162
01:23:06,560 --> 01:23:08,239
them will write over the other log

2163
01:23:08,239 --> 01:23:11,840
or no no no no there's one lock per pair

2164
01:23:11,840 --> 01:23:14,960
uh okay so every this is exactly the

2165
01:23:14,960 --> 01:23:16,960
reason why

2166
01:23:16,960 --> 01:23:20,000
and and then uh but when the

2167
01:23:20,000 --> 01:23:21,520
transactions like time

2168
01:23:21,520 --> 01:23:24,520
is it like you know like to provide

2169
01:23:24,520 --> 01:23:26,000
serializability

2170
01:23:26,000 --> 01:23:29,199
is it timed um based on what

2171
01:23:29,199 --> 01:23:32,480
on the version number uh there's nothing

2172
01:23:32,480 --> 01:23:33,920
like true time or anything like that

2173
01:23:33,920 --> 01:23:34,960
here

2174
01:23:34,960 --> 01:23:36,400
just logical numbers like in the same

2175
01:23:36,400 --> 01:23:38,480
way as in lab trick right where you have

2176
01:23:38,480 --> 01:23:40,880
logical sequence numbers for

2177
01:23:40,880 --> 01:23:41,760
implementing your

2178
01:23:41,760 --> 01:23:44,080
key value store conversion numbers

2179
01:23:44,080 --> 01:23:53,910
basically play the same role

2180
01:23:53,920 --> 01:23:56,320
well if two number of two transactions

2181
01:23:56,320 --> 01:23:57,600
got the same

2182
01:23:57,600 --> 01:24:00,560
um number then only the one that got to

2183
01:24:00,560 --> 01:24:01,120
the commit

2184
01:24:01,120 --> 01:24:04,560
point first just going yeah okay

2185
01:24:04,560 --> 01:24:07,040
yeah this is this case right one will

2186
01:24:07,040 --> 01:24:13,430
abort the other one succeed

2187
01:24:13,440 --> 01:24:15,280
if there is a message queue that is

2188
01:24:15,280 --> 01:24:17,920
basically established between every pair

2189
01:24:17,920 --> 01:24:20,239
then how do you know uh so then you

2190
01:24:20,239 --> 01:24:21,280
would have like multiple

2191
01:24:21,280 --> 01:24:24,320
message queues given primary how do you

2192
01:24:24,320 --> 01:24:26,400
know which order to read those in

2193
01:24:26,400 --> 01:24:28,960
um so you don't read them out of order

2194
01:24:28,960 --> 01:24:31,040
uh

2195
01:24:31,040 --> 01:24:33,440
there is you read all the messages from

2196
01:24:33,440 --> 01:24:35,280
one source in the same order correct

2197
01:24:35,280 --> 01:24:36,560
because they're all going to be

2198
01:24:36,560 --> 01:24:39,120
in one cube so one source writes to one

2199
01:24:39,120 --> 01:24:40,159
queue

2200
01:24:40,159 --> 01:24:43,360
uh multiple uh machines

2201
01:24:43,360 --> 01:24:45,520
might write you know concurrently to uh

2202
01:24:45,520 --> 01:24:46,719
different cues

2203
01:24:46,719 --> 01:24:48,320
and you don't know what the order anyway

2204
01:24:48,320 --> 01:24:50,320
is so

2205
01:24:50,320 --> 01:24:52,159
it couldn't affect the uh correctness of

2206
01:24:52,159 --> 01:24:54,239
the protocol

2207
01:24:54,239 --> 01:24:56,159
i see so we don't rely on the orderings

2208
01:24:56,159 --> 01:24:57,280
of the

2209
01:24:57,280 --> 01:24:59,040
incoming concurrent messages that's

2210
01:24:59,040 --> 01:25:00,480
correct you know you pull them in some

2211
01:25:00,480 --> 01:25:01,280
order and then

2212
01:25:01,280 --> 01:25:02,639
you pull the cues in some order and

2213
01:25:02,639 --> 01:25:04,080
that's the way that the way that they're

2214
01:25:04,080 --> 01:25:04,400
going to

2215
01:25:04,400 --> 01:25:07,440
be processed got it

2216
01:25:07,440 --> 01:25:09,440
um i also have one more more specific

2217
01:25:09,440 --> 01:25:11,199
question

2218
01:25:11,199 --> 01:25:12,880
there's a part where a sentence in the

2219
01:25:12,880 --> 01:25:14,560
paper that it provides lock

2220
01:25:14,560 --> 01:25:16,239
block free reads which we've just talked

2221
01:25:16,239 --> 01:25:19,040
about um but it also says it all

2222
01:25:19,040 --> 01:25:22,239
uh also provides locality hints which

2223
01:25:22,239 --> 01:25:25,040
enable programmers to co-relate related

2224
01:25:25,040 --> 01:25:27,360
objects on the same set of machines

2225
01:25:27,360 --> 01:25:30,159
yeah and i do not understand that like

2226
01:25:30,159 --> 01:25:32,560
the latter or part of the sentence

2227
01:25:32,560 --> 01:25:34,960
uh okay so i i have to look up the

2228
01:25:34,960 --> 01:25:36,320
details what it is but i think what it's

2229
01:25:36,320 --> 01:25:36,960
referring to

2230
01:25:36,960 --> 01:25:39,600
is that if you like if your objects are

2231
01:25:39,600 --> 01:25:41,040
all kinds in different regions right

2232
01:25:41,040 --> 01:25:41,360
like

2233
01:25:41,360 --> 01:25:43,760
let's look at this picture here then you

2234
01:25:43,760 --> 01:25:45,520
would have to talk to lots of different

2235
01:25:45,520 --> 01:25:48,000
uh primaries right so like your object

2236
01:25:48,000 --> 01:25:49,679
one is in this primary

2237
01:25:49,679 --> 01:25:52,560
object two is at this primary uh and if

2238
01:25:52,560 --> 01:25:54,080
you were touching many of this

2239
01:25:54,080 --> 01:25:55,520
if you're touching always a cluster of

2240
01:25:55,520 --> 01:25:57,199
objects together it would be nice if

2241
01:25:57,199 --> 01:25:58,560
that cluster of objects is all at the

2242
01:25:58,560 --> 01:25:59,840
same primary

2243
01:25:59,840 --> 01:26:01,520
so you only have to contact one primary

2244
01:26:01,520 --> 01:26:05,510
instead of many

2245
01:26:05,520 --> 01:26:13,110
i see thank you

2246
01:26:13,120 --> 01:26:18,390
any further questions

2247
01:26:18,400 --> 01:26:20,560
so this so farm is like not really

2248
01:26:20,560 --> 01:26:21,600
suitable for

2249
01:26:21,600 --> 01:26:24,400
long transactions right um because

2250
01:26:24,400 --> 01:26:25,040
that's

2251
01:26:25,040 --> 01:26:28,239
because yeah yeah you're worried

2252
01:26:28,239 --> 01:26:29,440
the long transactions that you get

2253
01:26:29,440 --> 01:26:32,229
conflicts

2254
01:26:32,239 --> 01:26:35,600
i mean it also is assuming i guess

2255
01:26:35,600 --> 01:26:38,159
read-only transactions since we really

2256
01:26:38,159 --> 01:26:39,440
optimized for them right

2257
01:26:39,440 --> 01:26:42,159
yeah absolutely many transactions you

2258
01:26:42,159 --> 01:26:42,560
know

2259
01:26:42,560 --> 01:26:43,920
people have done studies and you know

2260
01:26:43,920 --> 01:26:45,440
and you saw it in spanner paper too

2261
01:26:45,440 --> 01:26:46,239
correct

2262
01:26:46,239 --> 01:26:47,920
where a large fraction of the

2263
01:26:47,920 --> 01:26:53,510
transactions are read-only transactions

2264
01:26:53,520 --> 01:26:54,719
but that's clearly a property of the

2265
01:26:54,719 --> 01:27:01,270
workload

2266
01:27:01,280 --> 01:27:04,560
um i had i think going back to my

2267
01:27:04,560 --> 01:27:05,600
earlier question i think

2268
01:27:05,600 --> 01:27:08,719
i realized i was misunderstanding

2269
01:27:08,719 --> 01:27:11,679
okay basic about strict serializability

2270
01:27:11,679 --> 01:27:12,960
yeah um

2271
01:27:12,960 --> 01:27:16,560
is it so uh strict so okay so here's

2272
01:27:16,560 --> 01:27:16,880
here's

2273
01:27:16,880 --> 01:27:19,840
the situation um say there's one

2274
01:27:19,840 --> 01:27:21,600
transaction that begins first

2275
01:27:21,600 --> 01:27:24,960
that writes um shard one shard two and

2276
01:27:24,960 --> 01:27:27,600
read shard three

2277
01:27:27,600 --> 01:27:29,440
and so that that begins like first in

2278
01:27:29,440 --> 01:27:43,189
time okay right

2279
01:27:43,199 --> 01:27:45,760
um and then say there's this second

2280
01:27:45,760 --> 01:27:46,880
transaction

2281
01:27:46,880 --> 01:27:49,120
that begins after transaction one has

2282
01:27:49,120 --> 01:27:49,920
started

2283
01:27:49,920 --> 01:27:54,000
yeah like here yeah and it writes

2284
01:27:54,000 --> 01:27:57,040
z so for before it

2285
01:27:57,040 --> 01:28:00,080
uh writes you then must have read z uh

2286
01:28:00,080 --> 01:28:02,960
yeah yeah and so red z what version

2287
01:28:02,960 --> 01:28:05,360
number doesn't read

2288
01:28:05,360 --> 01:28:10,550
uh the state the same one

2289
01:28:10,560 --> 01:28:12,719
um and then say reads then it tries to

2290
01:28:12,719 --> 01:28:15,440
write z

2291
01:28:15,440 --> 01:28:19,199
yep um and then say t2 commits before t1

2292
01:28:19,199 --> 01:28:21,910
commits

2293
01:28:21,920 --> 01:28:26,560
uh yes okay so this commits yeah

2294
01:28:26,560 --> 01:28:29,120
and then t1 commits after 22 minutes oh

2295
01:28:29,120 --> 01:28:30,719
i'll try to commit correct

2296
01:28:30,719 --> 01:28:32,719
and now we'll start doing this whole the

2297
01:28:32,719 --> 01:28:34,560
whole walk for the validation and blah

2298
01:28:34,560 --> 01:28:36,719
blah blah correct

2299
01:28:36,719 --> 01:28:39,600
so before before so what's going to

2300
01:28:39,600 --> 01:28:40,719
happen correct is you know

2301
01:28:40,719 --> 01:28:42,480
i was going to give you this example uh

2302
01:28:42,480 --> 01:28:44,000
there's an example that i'm saving for

2303
01:28:44,000 --> 01:28:45,760
next lecture but

2304
01:28:45,760 --> 01:28:47,920
yeah basically what happens correct c

2305
01:28:47,920 --> 01:28:50,960
one would be z will be going at one

2306
01:28:50,960 --> 01:28:53,280
at this point the z will be at version

2307
01:28:53,280 --> 01:28:54,480
one correct

2308
01:28:54,480 --> 01:28:56,239
so the validation phase will run after

2309
01:28:56,239 --> 01:28:58,000
the commit that's what you said

2310
01:28:58,000 --> 01:29:01,199
right and so here's a validation of z

2311
01:29:01,199 --> 01:29:03,679
and you know it has zero correct and

2312
01:29:03,679 --> 01:29:04,560
then now it's one

2313
01:29:04,560 --> 01:29:07,199
and will this transaction will be abort

2314
01:29:07,199 --> 01:29:08,639
okay so this is what i was wondering

2315
01:29:08,639 --> 01:29:09,520
about then so

2316
01:29:09,520 --> 01:29:12,080
because after the validation phase

2317
01:29:12,080 --> 01:29:13,040
passes

2318
01:29:13,040 --> 01:29:16,229
there's a period of time

2319
01:29:16,239 --> 01:29:18,719
after the validation uh phase passes a

2320
01:29:18,719 --> 01:29:20,639
period of time passes then it commits

2321
01:29:20,639 --> 01:29:23,199
what if this validation happened before

2322
01:29:23,199 --> 01:29:25,600
t2 committed so it still saw the old

2323
01:29:25,600 --> 01:29:28,159
version number i cannot happen because

2324
01:29:28,159 --> 01:29:29,280
the uh

2325
01:29:29,280 --> 01:29:32,480
after the validation uh uh after the

2326
01:29:32,480 --> 01:29:33,280
commit

2327
01:29:33,280 --> 01:29:35,440
after the commit has completed correct

2328
01:29:35,440 --> 01:29:36,320
the

2329
01:29:36,320 --> 01:29:38,320
commit backup you know has recorded and

2330
01:29:38,320 --> 01:29:39,679
the primary have come or

2331
01:29:39,679 --> 01:29:43,120
have made the change before the

2332
01:29:43,120 --> 01:29:44,719
application is returned before the

2333
01:29:44,719 --> 01:29:46,159
commit returns the energy has been

2334
01:29:46,159 --> 01:29:49,030
updated

2335
01:29:49,040 --> 01:29:52,560
um wouldn't or i guess what i'm saying

2336
01:29:52,560 --> 01:29:52,800
is

2337
01:29:52,800 --> 01:29:55,840
isn't it possible for t1's validation

2338
01:29:55,840 --> 01:29:56,320
phase

2339
01:29:56,320 --> 01:29:59,360
to happen before or i guess maybe what

2340
01:29:59,360 --> 01:30:00,159
i'm trying to say is

2341
01:30:00,159 --> 01:30:03,120
isn't it possible that t2's commit

2342
01:30:03,120 --> 01:30:04,080
happens between

2343
01:30:04,080 --> 01:30:07,360
t1's validate what happens after t ones

2344
01:30:07,360 --> 01:30:08,560
validate but before

2345
01:30:08,560 --> 01:30:12,000
t t one's commit

2346
01:30:12,000 --> 01:30:15,040
uh clearly you know there's a risk

2347
01:30:15,040 --> 01:30:21,440
uh and this must be excluded uh

2348
01:30:21,440 --> 01:30:24,800
and it's excluded uh so okay so you're

2349
01:30:24,800 --> 01:30:26,239
worried

2350
01:30:26,239 --> 01:30:27,600
let me just construct this case maybe

2351
01:30:27,600 --> 01:30:29,040
i'll come back to you next week when

2352
01:30:29,040 --> 01:30:30,400
we're gonna talk about it anyway

2353
01:30:30,400 --> 01:30:32,159
uh but i think you were worried about uh

2354
01:30:32,159 --> 01:30:33,360
let's see if i could get the picture

2355
01:30:33,360 --> 01:30:34,239
back

2356
01:30:34,239 --> 01:30:38,480
uh years over here we did uh

2357
01:30:38,480 --> 01:30:41,520
so this guy

2358
01:30:41,520 --> 01:30:43,520
committed so he's basically doing the

2359
01:30:43,520 --> 01:30:46,719
commit phase correct this is t1

2360
01:30:46,719 --> 01:30:51,270
of

2361
01:30:51,280 --> 01:30:55,040
uh so t2 is about doing is here

2362
01:30:55,040 --> 01:30:58,159
correct and then t1 is coming in

2363
01:30:58,159 --> 01:31:02,080
before uh everything happens

2364
01:31:02,080 --> 01:31:05,760
before d2 it finishes correct so right

2365
01:31:05,760 --> 01:31:08,960
so like t1 validation also comes in here

2366
01:31:08,960 --> 01:31:10,880
so actually maybe okay let me rewrite it

2367
01:31:10,880 --> 01:31:12,080
and then we'll get back to you okay

2368
01:31:12,080 --> 01:31:14,880
okay that's exactly what i wanted to

2369
01:31:14,880 --> 01:31:15,600
talk about

2370
01:31:15,600 --> 01:31:18,080
okay all right thank you you're welcome

2371
01:31:18,080 --> 01:31:18,960
so just make sure

2372
01:31:18,960 --> 01:31:21,360
you're asking about t2 being like in

2373
01:31:21,360 --> 01:31:23,760
between stage two and three of t1

2374
01:31:23,760 --> 01:31:26,800
yeah yeah exactly

2375
01:31:26,800 --> 01:31:29,600
well in that case then t2 we could we

2376
01:31:29,600 --> 01:31:31,920
could serialize it as t2 coming before

2377
01:31:31,920 --> 01:31:32,560
t1

2378
01:31:32,560 --> 01:31:36,159
right yep so

2379
01:31:36,159 --> 01:31:37,840
let's let's get let's get back to this

2380
01:31:37,840 --> 01:31:39,520
on the on thursday here because i have

2381
01:31:39,520 --> 01:31:41,040
an example for that and exactly where

2382
01:31:41,040 --> 01:31:46,470
this is going to go over top of this

2383
01:31:46,480 --> 01:31:48,639
sorry in the validation stage you just

2384
01:31:48,639 --> 01:31:50,800
read the

2385
01:31:50,800 --> 01:31:58,080
read the version number yep

2386
01:31:58,080 --> 01:32:00,719
and serializability allows us to reorder

2387
01:32:00,719 --> 01:32:01,840
transactions

2388
01:32:01,840 --> 01:32:03,360
yeah but strict serializability not

2389
01:32:03,360 --> 01:32:05,760
correct like even uh if a transaction

2390
01:32:05,760 --> 01:32:07,520
structure analyzer requires that even

2391
01:32:07,520 --> 01:32:09,040
transaction starts if somebody

2392
01:32:09,040 --> 01:32:10,400
after somebody committed that

2393
01:32:10,400 --> 01:32:11,920
transaction is also committed after that

2394
01:32:11,920 --> 01:32:15,110
transaction

2395
01:32:15,120 --> 01:32:16,639
with this vertical guarantee because of

2396
01:32:16,639 --> 01:32:19,840
the version number

2397
01:32:19,840 --> 01:32:22,320
got it thank you but strict

2398
01:32:22,320 --> 01:32:23,360
serializability

2399
01:32:23,360 --> 01:32:26,880
doesn't it's like if t2 ends

2400
01:32:26,880 --> 01:32:31,120
it's not enough for t1 the end after t2

2401
01:32:31,120 --> 01:32:34,560
ends t1 had to have started

2402
01:32:34,560 --> 01:32:36,480
or maybe i need to think about this more

2403
01:32:36,480 --> 01:32:38,239
but yeah i think that was this is always

2404
01:32:38,239 --> 01:32:39,920
tripping you up it's like there's also a

2405
01:32:39,920 --> 01:32:40,480
a

2406
01:32:40,480 --> 01:32:42,639
a rule about when the transaction starts

2407
01:32:42,639 --> 01:32:44,080
yeah yeah well

2408
01:32:44,080 --> 01:32:46,000
well what happens in real life right

2409
01:32:46,000 --> 01:32:47,199
right this actually starts at some

2410
01:32:47,199 --> 01:32:48,480
particular point in time and

2411
01:32:48,480 --> 01:32:51,520
basically if if t1 uh

2412
01:32:51,520 --> 01:32:56,229
if t2 starts after t1 commits

2413
01:32:56,239 --> 01:32:58,719
right so so then it must be the case

2414
01:32:58,719 --> 01:33:00,320
that t2 observes

2415
01:33:00,320 --> 01:33:02,880
you know t2 t1 changes that's trick

2416
01:33:02,880 --> 01:33:04,639
serializability

2417
01:33:04,639 --> 01:33:08,080
right but what happens if t2 starts and

2418
01:33:08,080 --> 01:33:08,639
commits

2419
01:33:08,639 --> 01:33:10,880
solely within then it's a concurrent

2420
01:33:10,880 --> 01:33:12,880
transaction and either outcome is fine

2421
01:33:12,880 --> 01:33:15,679
okay okay what the answer is for you

2422
01:33:15,679 --> 01:33:16,400
yeah yeah yeah

2423
01:33:16,400 --> 01:33:18,000
yeah i think that's what i was confused

2424
01:33:18,000 --> 01:33:19,679
enough

2425
01:33:19,679 --> 01:33:22,639
when they literally when t2 starts

2426
01:33:22,639 --> 01:33:23,280
before

2427
01:33:23,280 --> 01:33:25,520
t1 commits it's considered a concurrent

2428
01:33:25,520 --> 01:33:27,199
transaction

2429
01:33:27,199 --> 01:33:30,000
and so t1 or you know t2 can observe

2430
01:33:30,000 --> 01:33:30,800
either it can be

2431
01:33:30,800 --> 01:33:32,400
ordered before or either after doesn't

2432
01:33:32,400 --> 01:33:34,719
matter okay okay

2433
01:33:34,719 --> 01:33:36,560
okay thank you i think it's also the

2434
01:33:36,560 --> 01:33:38,159
answer to your example

2435
01:33:38,159 --> 01:33:41,440
right right okay thank you okay

2436
01:33:41,440 --> 01:33:44,719
we got it anyway already you're saying

2437
01:33:44,719 --> 01:33:45,280
if

2438
01:33:45,280 --> 01:33:48,800
t2 start is like between the t1 start

2439
01:33:48,800 --> 01:33:49,120
and

2440
01:33:49,120 --> 01:33:51,040
in right like yeah like and then you

2441
01:33:51,040 --> 01:33:52,880
know can we could be go for it or after

2442
01:33:52,880 --> 01:33:53,600
it doesn't matter

2443
01:33:53,600 --> 01:33:56,800
okay okay that makes sense oh can i ask

2444
01:33:56,800 --> 01:33:58,159
a little just six questions

2445
01:33:58,159 --> 01:34:01,600
yeah i remember in in 6s oe1

2446
01:34:01,600 --> 01:34:05,199
you post these slides too

2447
01:34:05,199 --> 01:34:08,719
yes yeah yeah i didn't do that here uh

2448
01:34:08,719 --> 01:34:11,600
you'd like to be on the website i think

2449
01:34:11,600 --> 01:34:13,199
slides are useful if

2450
01:34:13,199 --> 01:34:15,199
if you just need to like look at the

2451
01:34:15,199 --> 01:34:16,880
slides you don't need to like scroll

2452
01:34:16,880 --> 01:34:18,080
through the video

2453
01:34:18,080 --> 01:34:21,120
okay um you're the first asking that's

2454
01:34:21,120 --> 01:34:21,520
all

2455
01:34:21,520 --> 01:34:24,239
this is why i haven't done it okay yeah

2456
01:34:24,239 --> 01:34:26,159
i'm happy to do it i

2457
01:34:26,159 --> 01:34:29,590
do shave them all

2458
01:34:29,600 --> 01:34:32,239
thank you so much thank you it was a fun

2459
01:34:32,239 --> 01:34:39,120
lecture thanks

