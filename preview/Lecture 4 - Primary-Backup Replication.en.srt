1
00:00:03,199 --> 00:00:03,919
okay

2
00:00:03,919 --> 00:00:06,000
good afternoon or good morning or good

3
00:00:06,000 --> 00:00:08,800
evening wherever you are

4
00:00:08,800 --> 00:00:10,880
uh i want to talk today about the

5
00:00:10,880 --> 00:00:12,320
perma-backup replication

6
00:00:12,320 --> 00:00:14,160
and really sort of an introduction to

7
00:00:14,160 --> 00:00:16,240
primary backup application

8
00:00:16,240 --> 00:00:19,119
uh we'll come back to this in multiple

9
00:00:19,119 --> 00:00:21,039
lectures during the semester

10
00:00:21,039 --> 00:00:24,640
but this is a the the fmt default the

11
00:00:24,640 --> 00:00:25,920
virtual memory or for

12
00:00:25,920 --> 00:00:29,039
vmware fault tolerant paper is sort of a

13
00:00:29,039 --> 00:00:30,000
really nice introduction

14
00:00:30,000 --> 00:00:32,239
that brings out a lot of issues that are

15
00:00:32,239 --> 00:00:33,200
going to come up

16
00:00:33,200 --> 00:00:36,719
throughout the semester so the plan for

17
00:00:36,719 --> 00:00:41,030
lecture today is as follows

18
00:00:41,040 --> 00:00:42,960
i'm first going to talk about failures

19
00:00:42,960 --> 00:00:44,559
that you might hope

20
00:00:44,559 --> 00:00:47,600
to tolerate using primary backup

21
00:00:47,600 --> 00:00:50,480
replication and some that you might not

22
00:00:50,480 --> 00:00:52,079
be able to

23
00:00:52,079 --> 00:00:53,360
then i want to talk a little bit about

24
00:00:53,360 --> 00:00:56,559
the main challenges in sort of any

25
00:00:56,559 --> 00:01:00,000
backup scheme uh sort of rotating

26
00:01:00,000 --> 00:01:00,480
speaking

27
00:01:00,480 --> 00:01:03,199
then talk about two you know dominant

28
00:01:03,199 --> 00:01:04,720
approaches

29
00:01:04,720 --> 00:01:08,560
uh to replication uh

30
00:01:08,560 --> 00:01:10,479
one is you know what's typically called

31
00:01:10,479 --> 00:01:12,080
state transfer

32
00:01:12,080 --> 00:01:15,270
replication

33
00:01:15,280 --> 00:01:16,880
and the second is typically called

34
00:01:16,880 --> 00:01:24,870
replicated state machines

35
00:01:24,880 --> 00:01:26,799
and today's paper is an example of a

36
00:01:26,799 --> 00:01:28,320
replicated state machine

37
00:01:28,320 --> 00:01:31,119
approach and in fact you know lab two of

38
00:01:31,119 --> 00:01:32,320
the lab three and lot four

39
00:01:32,320 --> 00:01:33,840
you know also we'll be using replicated

40
00:01:33,840 --> 00:01:35,520
state machine approach and in fact you

41
00:01:35,520 --> 00:01:36,240
know the

42
00:01:36,240 --> 00:01:39,439
gfs paper uh or replicating chunks and

43
00:01:39,439 --> 00:01:40,960
was using a replicated state machine

44
00:01:40,960 --> 00:01:42,159
approach

45
00:01:42,159 --> 00:01:44,320
uh so it's a quite a common approach and

46
00:01:44,320 --> 00:01:45,360
then you know i want to

47
00:01:45,360 --> 00:01:47,360
make everything a little bit concrete by

48
00:01:47,360 --> 00:01:52,630
looking at this case the case study

49
00:01:52,640 --> 00:01:57,119
of the vm vmware fall tolerance

50
00:01:57,119 --> 00:02:00,719
scheme or implementation or system

51
00:02:00,719 --> 00:02:02,880
so any questions before i get started

52
00:02:02,880 --> 00:02:05,040
just to

53
00:02:05,040 --> 00:02:07,520
put up i have tried to answer all your

54
00:02:07,520 --> 00:02:08,959
questions that you sent by email

55
00:02:08,959 --> 00:02:11,840
uh uh the ones you know they're coming

56
00:02:11,840 --> 00:02:13,040
before midnight that generally all

57
00:02:13,040 --> 00:02:14,560
answer that wants to come in after

58
00:02:14,560 --> 00:02:16,480
midnight you know i try to answer

59
00:02:16,480 --> 00:02:18,640
as many as i can uh but if i didn't

60
00:02:18,640 --> 00:02:19,840
answer your question then

61
00:02:19,840 --> 00:02:21,920
you and the topic comes up in lecture or

62
00:02:21,920 --> 00:02:23,440
at any point by that time you'll feel

63
00:02:23,440 --> 00:02:24,160
free to

64
00:02:24,160 --> 00:02:28,080
interrupt and ask it okay any questions

65
00:02:28,080 --> 00:02:39,190
before we dive in

66
00:02:39,200 --> 00:02:43,200
okay um so let's talk about failures

67
00:02:43,200 --> 00:02:46,560
in a very broad sense you get a sense of

68
00:02:46,560 --> 00:02:47,840
like what we might hope for

69
00:02:47,840 --> 00:02:58,470
that a replication scheme can handle

70
00:02:58,480 --> 00:03:01,360
so first of all typically the papers

71
00:03:01,360 --> 00:03:02,480
that were in the system there were going

72
00:03:02,480 --> 00:03:03,040
to be a

73
00:03:03,040 --> 00:03:05,519
building will only deal with what

74
00:03:05,519 --> 00:03:07,200
sometimes called or typically called

75
00:03:07,200 --> 00:03:08,480
fail stop

76
00:03:08,480 --> 00:03:14,149
failures

77
00:03:14,159 --> 00:03:15,840
and the basic idea is that there if

78
00:03:15,840 --> 00:03:17,360
there's a failure or a component of the

79
00:03:17,360 --> 00:03:19,920
computer doesn't really work well

80
00:03:19,920 --> 00:03:27,990
that actually stops the computer

81
00:03:28,000 --> 00:03:29,920
so the assumption is that basically the

82
00:03:29,920 --> 00:03:31,200
computer goes from working

83
00:03:31,200 --> 00:03:33,200
to not working sort of instantaneously

84
00:03:33,200 --> 00:03:35,120
it doesn't produce like weird results

85
00:03:35,120 --> 00:03:36,400
because the computer's not working

86
00:03:36,400 --> 00:03:38,080
uh correctly so it just follows the

87
00:03:38,080 --> 00:03:39,519
protocols uh

88
00:03:39,519 --> 00:03:41,200
you know when it you know does to add it

89
00:03:41,200 --> 00:03:43,440
adds it to register values you know that

90
00:03:43,440 --> 00:03:45,680
producers are correct you know add value

91
00:03:45,680 --> 00:03:46,080
uh

92
00:03:46,080 --> 00:03:47,599
and so we're just assuming that when the

93
00:03:47,599 --> 00:03:49,200
computer works you know it works

94
00:03:49,200 --> 00:03:49,760
correctly

95
00:03:49,760 --> 00:03:52,959
and when there's a failure it just stops

96
00:03:52,959 --> 00:03:55,360
um and this covers it in many scenarios

97
00:03:55,360 --> 00:03:56,560
you know for example like whenever you

98
00:03:56,560 --> 00:03:57,920
fan of the computer

99
00:03:57,920 --> 00:04:01,519
uh fails you know the computer overheats

100
00:04:01,519 --> 00:04:04,080
and then the computer shuts down itself

101
00:04:04,080 --> 00:04:05,280
um

102
00:04:05,280 --> 00:04:08,239
the other cases are where like you know

103
00:04:08,239 --> 00:04:09,920
somebody steps over the power cord

104
00:04:09,920 --> 00:04:11,280
and boom you know the whole computer

105
00:04:11,280 --> 00:04:12,959
disappears or you know

106
00:04:12,959 --> 00:04:15,120
you know cuts the network link and you

107
00:04:15,120 --> 00:04:16,560
know that point you know the

108
00:04:16,560 --> 00:04:18,320
computer might keep you running uh but

109
00:04:18,320 --> 00:04:21,680
uh it is completely disconnected

110
00:04:21,680 --> 00:04:24,080
sometimes you know systems or software

111
00:04:24,080 --> 00:04:25,120
on the computer itself

112
00:04:25,120 --> 00:04:26,800
does it best you know to turn these

113
00:04:26,800 --> 00:04:29,199
partial failures into uh stop till stop

114
00:04:29,199 --> 00:04:30,000
failures

115
00:04:30,000 --> 00:04:31,520
so example you might you know the

116
00:04:31,520 --> 00:04:33,520
software might compute checksums on data

117
00:04:33,520 --> 00:04:34,240
and then

118
00:04:34,240 --> 00:04:35,520
if it sees that the checksum is

119
00:04:35,520 --> 00:04:37,440
incorrect you know just stop you know

120
00:04:37,440 --> 00:04:39,040
the computer

121
00:04:39,040 --> 00:04:42,160
um uh and so that's a quite common

122
00:04:42,160 --> 00:04:44,320
uh and to do so the basic model of the

123
00:04:44,320 --> 00:04:45,440
world is

124
00:04:45,440 --> 00:04:46,720
computer work correctly then the

125
00:04:46,720 --> 00:04:48,720
computer starts

126
00:04:48,720 --> 00:04:50,320
so what does this exclude you know

127
00:04:50,320 --> 00:04:51,759
there's a whole bunch of sort of

128
00:04:51,759 --> 00:04:53,759
failures that it excludes for example

129
00:04:53,759 --> 00:04:55,520
uh it doesn't really deal well with

130
00:04:55,520 --> 00:04:57,040
logic bugs

131
00:04:57,040 --> 00:04:58,880
like if you have an error in your

132
00:04:58,880 --> 00:05:00,639
software you know whatever you divide by

133
00:05:00,639 --> 00:05:01,120
zero

134
00:05:01,120 --> 00:05:03,759
and then uh incorrectly or in the where

135
00:05:03,759 --> 00:05:04,960
you shouldn't have

136
00:05:04,960 --> 00:05:06,479
then though it is very likely that the

137
00:05:06,479 --> 00:05:08,400
backup will do exactly the same thing

138
00:05:08,400 --> 00:05:10,479
because when the software is broken and

139
00:05:10,479 --> 00:05:12,560
so it's broken on the primary it's

140
00:05:12,560 --> 00:05:13,520
broken on the backup

141
00:05:13,520 --> 00:05:15,840
and so nothing you know basically

142
00:05:15,840 --> 00:05:17,120
replication really not

143
00:05:17,120 --> 00:05:19,440
does not solve that problem for you

144
00:05:19,440 --> 00:05:20,240
similar

145
00:05:20,240 --> 00:05:22,840
you know if you have configuration

146
00:05:22,840 --> 00:05:26,469
errors

147
00:05:26,479 --> 00:05:27,840
memory backup is not going to assault

148
00:05:27,840 --> 00:05:31,120
you no problem for you if you know the

149
00:05:31,120 --> 00:05:33,520
uh the files that you know specify the

150
00:05:33,520 --> 00:05:34,960
replicas that are just incorrect

151
00:05:34,960 --> 00:05:38,000
then the system will not work correctly

152
00:05:38,000 --> 00:05:40,479
uh similarly we're not really in this

153
00:05:40,479 --> 00:05:41,039
class

154
00:05:41,039 --> 00:05:42,479
we'll talk a little bit at the end of

155
00:05:42,479 --> 00:05:44,160
the semester but we're not

156
00:05:44,160 --> 00:05:48,160
dealing with malicious errors

157
00:05:48,160 --> 00:05:50,080
so we're not dealing with attackers that

158
00:05:50,080 --> 00:05:52,479
you know try to fake the protocol

159
00:05:52,479 --> 00:05:55,280
uh you know have run servers that send

160
00:05:55,280 --> 00:05:56,720
incorrect messages

161
00:05:56,720 --> 00:05:58,800
and try to sort of spoof the whole

162
00:05:58,800 --> 00:06:00,880
system uh which is not in consideration

163
00:06:00,880 --> 00:06:02,000
so in uh

164
00:06:02,000 --> 00:06:03,919
for most of the semester presume that

165
00:06:03,919 --> 00:06:05,280
the software works correctly

166
00:06:05,280 --> 00:06:07,039
does not have logic bugs there are no

167
00:06:07,039 --> 00:06:08,319
configuration errors

168
00:06:08,319 --> 00:06:09,759
and the thing that we're focusing on is

169
00:06:09,759 --> 00:06:12,800
actually handling stop failures

170
00:06:12,800 --> 00:06:14,800
there's some failures that sort of fall

171
00:06:14,800 --> 00:06:17,199
you know that could be handled

172
00:06:17,199 --> 00:06:20,800
or maybe handled with uh primary backup

173
00:06:20,800 --> 00:06:22,479
replication

174
00:06:22,479 --> 00:06:25,120
or not and as an example you might think

175
00:06:25,120 --> 00:06:25,680
about like

176
00:06:25,680 --> 00:06:29,590
an earthquake

177
00:06:29,600 --> 00:06:31,440
you know if the primary and back are

178
00:06:31,440 --> 00:06:33,360
physically you know separated

179
00:06:33,360 --> 00:06:35,199
uh in completely different parts you

180
00:06:35,199 --> 00:06:36,720
know on different continents or maybe

181
00:06:36,720 --> 00:06:38,880
parts of the same continent i know you

182
00:06:38,880 --> 00:06:39,840
might hope that

183
00:06:39,840 --> 00:06:42,479
you might have some hope that the uh the

184
00:06:42,479 --> 00:06:44,080
backer could take over if the failure

185
00:06:44,080 --> 00:06:46,000
if the primary fails due to an

186
00:06:46,000 --> 00:06:47,680
earthquake but

187
00:06:47,680 --> 00:06:49,759
um you know some other primary

188
00:06:49,759 --> 00:06:51,280
replication schemes you know this is not

189
00:06:51,280 --> 00:06:52,639
going to be the case you know where for

190
00:06:52,639 --> 00:06:54,240
example at the primary and the backup on

191
00:06:54,240 --> 00:06:55,759
the same data center and the whole data

192
00:06:55,759 --> 00:06:57,440
center uh disappears

193
00:06:57,440 --> 00:07:01,120
then you know sort of end of story okay

194
00:07:01,120 --> 00:07:02,240
so hopefully that gives you a little bit

195
00:07:02,240 --> 00:07:03,440
of context of sort of the type of

196
00:07:03,440 --> 00:07:04,160
failures that

197
00:07:04,160 --> 00:07:07,039
we're trying to shoot for now even with

198
00:07:07,039 --> 00:07:08,160
this sort of

199
00:07:08,160 --> 00:07:10,560
just focusing on stop uh till stop

200
00:07:10,560 --> 00:07:11,280
failure

201
00:07:11,280 --> 00:07:13,440
it turns out to be difficult to build

202
00:07:13,440 --> 00:07:14,880
you know fault along systems

203
00:07:14,880 --> 00:07:15,840
and we're going to talk a little bit

204
00:07:15,840 --> 00:07:17,680
about the general issues that will show

205
00:07:17,680 --> 00:07:18,000
up

206
00:07:18,000 --> 00:07:21,039
you know if we're going to build

207
00:07:21,039 --> 00:07:24,950
a primary backup system

208
00:07:24,960 --> 00:07:26,400
and you know we'll see concrete exam

209
00:07:26,400 --> 00:07:28,639
instances of these problems in the

210
00:07:28,639 --> 00:07:34,000
vm ft paper so you know one challenge is

211
00:07:34,000 --> 00:07:37,120
you know if a failure happens you know

212
00:07:37,120 --> 00:07:47,589
has the primary actually failed

213
00:07:47,599 --> 00:07:49,440
uh an issue here you know that makes

214
00:07:49,440 --> 00:07:51,039
this challenging is that in intercepted

215
00:07:51,039 --> 00:07:52,319
systems you can't tell the difference

216
00:07:52,319 --> 00:07:54,000
between a network petition and a machine

217
00:07:54,000 --> 00:07:55,759
failed so it might be perfectly possible

218
00:07:55,759 --> 00:07:56,639
that the

219
00:07:56,639 --> 00:07:59,120
network uh that the primary is still up

220
00:07:59,120 --> 00:08:00,879
but you know that some computers cannot

221
00:08:00,879 --> 00:08:02,879
talk to the primary because

222
00:08:02,879 --> 00:08:04,720
the network has petitioned and so for

223
00:08:04,720 --> 00:08:06,479
example the backup may decide that you

224
00:08:06,479 --> 00:08:07,680
know the primary is dead because

225
00:08:07,680 --> 00:08:09,280
network's petitioned but in fact the

226
00:08:09,280 --> 00:08:10,560
primary is not that

227
00:08:10,560 --> 00:08:12,000
and maybe some of the clients are still

228
00:08:12,000 --> 00:08:13,599
able to talk to the primary and so you

229
00:08:13,599 --> 00:08:15,120
have to have some story

230
00:08:15,120 --> 00:08:17,759
of making sure that you don't end up in

231
00:08:17,759 --> 00:08:18,960
a situation

232
00:08:18,960 --> 00:08:21,759
where you have two primaries and again

233
00:08:21,759 --> 00:08:22,560
you know

234
00:08:22,560 --> 00:08:24,080
we talked a little bit about last time

235
00:08:24,080 --> 00:08:25,440
it shows up in this paper again we'll

236
00:08:25,440 --> 00:08:26,080
show up

237
00:08:26,080 --> 00:08:27,759
next week too which is like you know we

238
00:08:27,759 --> 00:08:29,680
want to avoid that we get into situation

239
00:08:29,680 --> 00:08:31,199
where there's sort of a split brain

240
00:08:31,199 --> 00:08:35,029
system

241
00:08:35,039 --> 00:08:37,360
where we basically have two primaries

242
00:08:37,360 --> 00:08:39,200
and like one subset of the klein

243
00:08:39,200 --> 00:08:40,800
to one primary and the other subset of

244
00:08:40,800 --> 00:08:42,240
the client talks to the other parent

245
00:08:42,240 --> 00:08:44,399
and clearly that's going to diverge you

246
00:08:44,399 --> 00:08:45,680
know the state of the system

247
00:08:45,680 --> 00:08:48,800
and when the the network heals

248
00:08:48,800 --> 00:08:51,360
we are in an incorrect state so we have

249
00:08:51,360 --> 00:08:52,080
to avoid this

250
00:08:52,080 --> 00:08:56,000
at all costs the second uh

251
00:08:56,000 --> 00:08:58,399
general challenge is you know how do we

252
00:08:58,399 --> 00:08:59,360
keep

253
00:08:59,360 --> 00:09:02,399
the you know how do we keep the primary

254
00:09:02,399 --> 00:09:13,829
and the backup in sync

255
00:09:13,839 --> 00:09:16,399
and our goal is going to be that uh if

256
00:09:16,399 --> 00:09:18,080
the primary fails then we can just

257
00:09:18,080 --> 00:09:20,320
gracefully fail over to the backup and

258
00:09:20,320 --> 00:09:21,120
the backup just

259
00:09:21,120 --> 00:09:22,880
picks up right where the primary left

260
00:09:22,880 --> 00:09:25,200
off and that requires that the backup

261
00:09:25,200 --> 00:09:26,320
actually is up to date

262
00:09:26,320 --> 00:09:27,839
we have like the latest things that the

263
00:09:27,839 --> 00:09:29,360
primary action has written

264
00:09:29,360 --> 00:09:32,560
uh to its state so that action can pick

265
00:09:32,560 --> 00:09:32,880
up

266
00:09:32,880 --> 00:09:35,920
seamlessly and the return errors or uh

267
00:09:35,920 --> 00:09:37,200
responses to the client that are

268
00:09:37,200 --> 00:09:38,720
completely unexpected

269
00:09:38,720 --> 00:09:40,160
you know from the client's perspective

270
00:09:40,160 --> 00:09:41,760
it really should look like you know the

271
00:09:41,760 --> 00:09:43,360
whole thing even though it's replicated

272
00:09:43,360 --> 00:09:44,800
it's like a single computer it just

273
00:09:44,800 --> 00:09:45,600
happens to be a little bit more

274
00:09:45,600 --> 00:09:48,640
fault-tolerant than a single computer

275
00:09:48,640 --> 00:09:50,560
and that turns out to be uh difficult

276
00:09:50,560 --> 00:09:52,080
you know first of all we

277
00:09:52,080 --> 00:09:54,000
have to make sure that we apply all

278
00:09:54,000 --> 00:09:55,519
changes we have to apply the changes in

279
00:09:55,519 --> 00:10:01,829
the right order

280
00:10:01,839 --> 00:10:04,480
and you know in continuous uh issue and

281
00:10:04,480 --> 00:10:06,000
that is that

282
00:10:06,000 --> 00:10:08,640
we have to sort of avoid non-determinism

283
00:10:08,640 --> 00:10:09,120
or

284
00:10:09,120 --> 00:10:13,430
we have to deal with non-determinism

285
00:10:13,440 --> 00:10:15,839
i mean if the same change on the primary

286
00:10:15,839 --> 00:10:17,440
behavior is different than on the backup

287
00:10:17,440 --> 00:10:18,640
because you know for some reason

288
00:10:18,640 --> 00:10:20,160
that would be not good you know we got

289
00:10:20,160 --> 00:10:21,680
to make sure that we make a change in

290
00:10:21,680 --> 00:10:23,360
the primary backup very identical

291
00:10:23,360 --> 00:10:24,240
effects

292
00:10:24,240 --> 00:10:27,600
uh to the primary and the backup

293
00:10:27,600 --> 00:10:29,440
uh a similar you know sort of issue that

294
00:10:29,440 --> 00:10:30,640
overwhelming shows up

295
00:10:30,640 --> 00:10:35,350
you know as a challenge is failover

296
00:10:35,360 --> 00:10:37,680
you have actually the primary fails and

297
00:10:37,680 --> 00:10:39,120
we need to fail over to

298
00:10:39,120 --> 00:10:40,880
the backup and we've cursed all they've

299
00:10:40,880 --> 00:10:42,480
got to make sure that the

300
00:10:42,480 --> 00:10:45,600
their other primary is definitely dead

301
00:10:45,600 --> 00:10:47,920
but for example the primary might have

302
00:10:47,920 --> 00:10:49,440
was in the middle of an operation

303
00:10:49,440 --> 00:10:52,079
and uh it was about to send a packet out

304
00:10:52,079 --> 00:10:53,600
to the response to the client

305
00:10:53,600 --> 00:10:56,240
or maybe not and so we got to figure out

306
00:10:56,240 --> 00:10:57,680
whether that response if you send or not

307
00:10:57,680 --> 00:10:58,240
being sent

308
00:10:58,240 --> 00:11:01,910
or is it okay for us to send it again

309
00:11:01,920 --> 00:11:05,760
um there's a question here in the chat

310
00:11:05,760 --> 00:11:06,320
like when

311
00:11:06,320 --> 00:11:08,000
would failover need to be happen no

312
00:11:08,000 --> 00:11:09,600
fails need to happen when the primary's

313
00:11:09,600 --> 00:11:09,920
gone

314
00:11:09,920 --> 00:11:12,160
right because then we want to fail over

315
00:11:12,160 --> 00:11:13,279
to the backup that's sort of the

316
00:11:13,279 --> 00:11:14,000
terminology

317
00:11:14,000 --> 00:11:17,760
used and then often

318
00:11:17,760 --> 00:11:20,079
another issue we fail over is like who

319
00:11:20,079 --> 00:11:21,519
actually has you know we have multiple

320
00:11:21,519 --> 00:11:23,279
backups which is not the case in today's

321
00:11:23,279 --> 00:11:23,839
paper

322
00:11:23,839 --> 00:11:25,279
uh you know we actually have the latest

323
00:11:25,279 --> 00:11:26,800
stage like for example maybe they all

324
00:11:26,800 --> 00:11:27,279
crash

325
00:11:27,279 --> 00:11:29,519
after a few operations they come back up

326
00:11:29,519 --> 00:11:30,480
and

327
00:11:30,480 --> 00:11:33,279
uh and and uh and we are going to make

328
00:11:33,279 --> 00:11:34,320
sure that we're actually talking to the

329
00:11:34,320 --> 00:11:35,920
one that acts in the most recent states

330
00:11:35,920 --> 00:11:36,959
you know this is going to be not an

331
00:11:36,959 --> 00:11:38,480
issue today tomorrow so much

332
00:11:38,480 --> 00:11:40,480
as we'll see in a second why but it will

333
00:11:40,480 --> 00:11:42,160
come up later in other replication

334
00:11:42,160 --> 00:11:45,509
protocols

335
00:11:45,519 --> 00:11:46,959
yeah so basically failover means you

336
00:11:46,959 --> 00:11:51,190
know the backup takes over

337
00:11:51,200 --> 00:11:54,240
um okay so that's sort of the main you

338
00:11:54,240 --> 00:11:55,040
know fail

339
00:11:55,040 --> 00:11:56,399
the type of failures that we hope to

340
00:11:56,399 --> 00:11:58,800
handle the main challenges

341
00:11:58,800 --> 00:12:01,040
uh and we'll deepen those challenges out

342
00:12:01,040 --> 00:12:02,000
as we go

343
00:12:02,000 --> 00:12:04,079
um and you know i want to talk about

344
00:12:04,079 --> 00:12:06,320
sort of two the two main approaches that

345
00:12:06,320 --> 00:12:07,760
we'll see in the semester

346
00:12:07,760 --> 00:12:10,240
uh for dealing with primary backup

347
00:12:10,240 --> 00:12:18,949
replication

348
00:12:18,959 --> 00:12:21,839
one is as i mentioned earlier that is

349
00:12:21,839 --> 00:12:27,590
state transfer

350
00:12:27,600 --> 00:12:29,200
now there's been a reasonable at a high

351
00:12:29,200 --> 00:12:30,720
level very straightforward you know we

352
00:12:30,720 --> 00:12:32,240
got a primary

353
00:12:32,240 --> 00:12:33,839
uh you know it's you know the clients

354
00:12:33,839 --> 00:12:35,519
talk to the primary

355
00:12:35,519 --> 00:12:37,760
the primary you know updated state once

356
00:12:37,760 --> 00:12:39,279
update to state in response to

357
00:12:39,279 --> 00:12:41,519
client request and once a while it sort

358
00:12:41,519 --> 00:12:47,990
of makes a checkpoint

359
00:12:48,000 --> 00:12:55,990
once a while basically checkpoints state

360
00:12:56,000 --> 00:13:00,949
it stayed to the backup

361
00:13:00,959 --> 00:13:02,720
and of course if you want to the backup

362
00:13:02,720 --> 00:13:04,399
in the primary to be in sync you know

363
00:13:04,399 --> 00:13:05,839
that means that every time the primary

364
00:13:05,839 --> 00:13:07,680
actually performs an operation

365
00:13:07,680 --> 00:13:09,839
i before it responds to the client it

366
00:13:09,839 --> 00:13:11,839
basically has to transfer whatever state

367
00:13:11,839 --> 00:13:13,600
changes that were made by that operation

368
00:13:13,600 --> 00:13:15,760
to the backup

369
00:13:15,760 --> 00:13:19,279
so that's one scheme one of

370
00:13:19,279 --> 00:13:21,760
high level approach the second approach

371
00:13:21,760 --> 00:13:22,959
is what uh

372
00:13:22,959 --> 00:13:27,430
it's called replicated state machine

373
00:13:27,440 --> 00:13:32,949
state machine replication

374
00:13:32,959 --> 00:13:36,000
often shortened to rsm

375
00:13:36,000 --> 00:13:38,560
and here you know the uh you know the

376
00:13:38,560 --> 00:13:39,040
picture

377
00:13:39,040 --> 00:13:41,120
is you know we got the primary we got

378
00:13:41,120 --> 00:13:42,320
the clients they're talking to the

379
00:13:42,320 --> 00:13:43,120
primary

380
00:13:43,120 --> 00:13:44,240
and of course you know we have the

381
00:13:44,240 --> 00:13:45,760
primary talking to the backup to keep

382
00:13:45,760 --> 00:13:46,959
the backup in sync

383
00:13:46,959 --> 00:13:50,399
but instead it was sending the state

384
00:13:50,399 --> 00:13:52,000
changes or the modifications to the

385
00:13:52,000 --> 00:13:53,440
state from the prime to the backup what

386
00:13:53,440 --> 00:13:56,079
we do actually we sent the operations

387
00:13:56,079 --> 00:14:00,160
to the background so before the primary

388
00:14:00,160 --> 00:14:01,680
response to the client you know

389
00:14:01,680 --> 00:14:03,120
executing its operation

390
00:14:03,120 --> 00:14:04,800
you know we sent the operation that the

391
00:14:04,800 --> 00:14:06,720
client sent to us you know to the backup

392
00:14:06,720 --> 00:14:08,480
so the backup can execute the operation

393
00:14:08,480 --> 00:14:10,880
to uh updates its state you know

394
00:14:10,880 --> 00:14:12,399
acknowledge it to the primary primary

395
00:14:12,399 --> 00:14:13,760
actually updates it's state two

396
00:14:13,760 --> 00:14:15,440
you know executes the operation and then

397
00:14:15,440 --> 00:14:16,959
sends the response back to the pre

398
00:14:16,959 --> 00:14:20,000
to the client and

399
00:14:20,000 --> 00:14:22,959
sort of in all these sort of in in all

400
00:14:22,959 --> 00:14:23,680
these

401
00:14:23,680 --> 00:14:25,360
in both approaches you know the sort of

402
00:14:25,360 --> 00:14:27,040
the scheme is like the primaries of some

403
00:14:27,040 --> 00:14:28,320
particular state

404
00:14:28,320 --> 00:14:31,600
uh we apply changes to the state um

405
00:14:31,600 --> 00:14:33,440
and we do exactly the same thing at the

406
00:14:33,440 --> 00:14:34,639
back so the backup

407
00:14:34,639 --> 00:14:36,000
starts out in the same state as the

408
00:14:36,000 --> 00:14:38,079
primary we apply the same changes to the

409
00:14:38,079 --> 00:14:39,360
state whether it's through an operation

410
00:14:39,360 --> 00:14:40,399
or state transfer

411
00:14:40,399 --> 00:14:42,240
we end up in a new state and that state

412
00:14:42,240 --> 00:14:43,600
has to be identical to the state that

413
00:14:43,600 --> 00:14:44,079
the primary

414
00:14:44,079 --> 00:14:47,360
has so if then ever there's a failure

415
00:14:47,360 --> 00:14:49,360
uh you know we know that when we fail

416
00:14:49,360 --> 00:14:51,040
over to the backup and it's exactly in

417
00:14:51,040 --> 00:14:52,959
the same state as the primary and so

418
00:14:52,959 --> 00:14:57,120
it can take over um

419
00:14:57,120 --> 00:14:58,320
and we'll see you know this is actually

420
00:14:58,320 --> 00:15:00,160
challenging to actually make happen but

421
00:15:00,160 --> 00:15:01,920
that's what the basic point

422
00:15:01,920 --> 00:15:05,440
um the primary

423
00:15:05,440 --> 00:15:06,720
goal approach is actually reasonably

424
00:15:06,720 --> 00:15:08,800
popular the primary disadvantage

425
00:15:08,800 --> 00:15:10,880
of the state transfer approach is that

426
00:15:10,880 --> 00:15:12,639
like if an operation generates a lot of

427
00:15:12,639 --> 00:15:13,519
state

428
00:15:13,519 --> 00:15:15,279
uh then it's going to be expensive right

429
00:15:15,279 --> 00:15:16,639
like if a single operation writes a

430
00:15:16,639 --> 00:15:18,399
gigabyte of data then that gigabyte of

431
00:15:18,399 --> 00:15:20,000
data needs to be transferred to a

432
00:15:20,000 --> 00:15:22,399
primary or due to backup and it might be

433
00:15:22,399 --> 00:15:24,240
much more expensive and much more

434
00:15:24,240 --> 00:15:25,920
less expensive to basically just send

435
00:15:25,920 --> 00:15:27,839
over the operation to the backup to the

436
00:15:27,839 --> 00:15:31,120
backup connection to the operation so

437
00:15:31,120 --> 00:15:34,160
many of the systems that were

438
00:15:34,160 --> 00:15:35,680
talking about actually therefore follow

439
00:15:35,680 --> 00:15:37,519
the second approach you know where

440
00:15:37,519 --> 00:15:39,279
they send the operation but not the

441
00:15:39,279 --> 00:15:41,040
state transfer

442
00:15:41,040 --> 00:15:43,600
and uh in fact you know if you think

443
00:15:43,600 --> 00:15:44,160
about

444
00:15:44,160 --> 00:15:48,000
uh gfs uh the discussion from last week

445
00:15:48,000 --> 00:15:50,079
when we saw that basically the primary

446
00:15:50,079 --> 00:15:51,199
since the

447
00:15:51,199 --> 00:15:52,880
append operations or the right

448
00:15:52,880 --> 00:15:55,120
operations to the backups

449
00:15:55,120 --> 00:15:56,639
it doesn't do the append and then send

450
00:15:56,639 --> 00:15:58,639
the result you know to the backups that

451
00:15:58,639 --> 00:16:00,240
actually sends the operations so that's

452
00:16:00,240 --> 00:16:01,120
an example

453
00:16:01,120 --> 00:16:03,040
of a replicated state machine approach

454
00:16:03,040 --> 00:16:04,959
where we'll be sending operations

455
00:16:04,959 --> 00:16:07,199
and the paper of today also follows this

456
00:16:07,199 --> 00:16:08,959
replicated state machine approach where

457
00:16:08,959 --> 00:16:10,240
the operations are not

458
00:16:10,240 --> 00:16:12,720
you know append and right uh file system

459
00:16:12,720 --> 00:16:14,079
append to file system right

460
00:16:14,079 --> 00:16:16,000
but the operations are actually x86

461
00:16:16,000 --> 00:16:17,680
instructions you know um

462
00:16:17,680 --> 00:16:21,360
that's what we'll see later but they uh

463
00:16:21,360 --> 00:16:24,560
both you know send operations

464
00:16:24,560 --> 00:16:27,360
in labs as i mentioned earlier labs

465
00:16:27,360 --> 00:16:28,320
three and four

466
00:16:28,320 --> 00:16:31,680
uh are also replicated state machine uh

467
00:16:31,680 --> 00:16:33,040
approaches where you know we're gonna be

468
00:16:33,040 --> 00:16:34,639
sending operations from the primary to

469
00:16:34,639 --> 00:16:40,550
the backup

470
00:16:40,560 --> 00:16:47,110
as a

471
00:16:47,120 --> 00:16:48,480
because there's a question to chad why

472
00:16:48,480 --> 00:16:50,160
does the client do not send

473
00:16:50,160 --> 00:16:51,920
not need to send the data to the backup

474
00:16:51,920 --> 00:16:53,839
in our replicated state machine because

475
00:16:53,839 --> 00:16:56,399
the the idea is that these operations

476
00:16:56,399 --> 00:16:57,519
are deterministic

477
00:16:57,519 --> 00:16:59,120
and so the primary and this you know

478
00:16:59,120 --> 00:17:00,639
remember the we'll talk about this in

479
00:17:00,639 --> 00:17:01,759
much more detail but the primary and

480
00:17:01,759 --> 00:17:03,600
backup are in the same state same state

481
00:17:03,600 --> 00:17:05,360
as

482
00:17:05,360 --> 00:17:08,799
the uh if the operation is deterministic

483
00:17:08,799 --> 00:17:10,400
and you apply it to the same state you

484
00:17:10,400 --> 00:17:11,919
know they will end up in the same state

485
00:17:11,919 --> 00:17:13,280
as prime

486
00:17:13,280 --> 00:17:14,959
and so there's no reason for the

487
00:17:14,959 --> 00:17:16,720
application the client to send the data

488
00:17:16,720 --> 00:17:18,319
in this case because by just sending

489
00:17:18,319 --> 00:17:20,000
this deterministic operation

490
00:17:20,000 --> 00:17:21,760
it is guaranteed that that operation

491
00:17:21,760 --> 00:17:26,949
will generate the same data

492
00:17:26,959 --> 00:17:28,559
so subsequent question is how do you

493
00:17:28,559 --> 00:17:29,919
know for all programs and their

494
00:17:29,919 --> 00:17:30,960
operations whether they are just

495
00:17:30,960 --> 00:17:31,440
stimulus

496
00:17:31,440 --> 00:17:32,960
or non-deterministic to know what

497
00:17:32,960 --> 00:17:34,720
information need to be sent

498
00:17:34,720 --> 00:17:36,240
so the typical approach is to in

499
00:17:36,240 --> 00:17:38,000
replicated state machine approach is to

500
00:17:38,000 --> 00:17:40,400
make all operations deterministic

501
00:17:40,400 --> 00:17:41,919
non-deterministic operations are not

502
00:17:41,919 --> 00:17:43,600
allowed and we'll see in a second how

503
00:17:43,600 --> 00:17:48,710
you do that

504
00:17:48,720 --> 00:17:50,880
okay so before you know going to a

505
00:17:50,880 --> 00:17:52,400
little bit more specific

506
00:17:52,400 --> 00:17:56,320
uh under hybrid approaches

507
00:17:56,320 --> 00:17:58,559
uh yes you know there are hardbacker

508
00:17:58,559 --> 00:18:00,480
approaches you know for example you can

509
00:18:00,480 --> 00:18:02,160
run sort of by default in a replicated

510
00:18:02,160 --> 00:18:03,600
state machine approach

511
00:18:03,600 --> 00:18:07,520
uh uh in effect in some ways the paper

512
00:18:07,520 --> 00:18:11,280
uh does this then if uh uh

513
00:18:11,280 --> 00:18:13,360
if the backup fails or primary fails and

514
00:18:13,360 --> 00:18:15,039
you go back to a single machine

515
00:18:15,039 --> 00:18:17,200
then you need to create a new replica

516
00:18:17,200 --> 00:18:18,960
and often for the new replica the way

517
00:18:18,960 --> 00:18:20,320
you do it is actually by

518
00:18:20,320 --> 00:18:22,559
transferring the state from the existing

519
00:18:22,559 --> 00:18:24,160
replica or a copy of the state of the

520
00:18:24,160 --> 00:18:26,880
existing replica to a new replica

521
00:18:26,880 --> 00:18:28,720
but that's like hopefully a less

522
00:18:28,720 --> 00:18:30,640
frequent operation

523
00:18:30,640 --> 00:18:33,360
and then actually you know doing the uh

524
00:18:33,360 --> 00:18:34,480
uh

525
00:18:34,480 --> 00:18:35,840
then replicating the operations that

526
00:18:35,840 --> 00:18:39,669
they're doing much more frequently

527
00:18:39,679 --> 00:18:41,919
um also three uh feel free to ask the

528
00:18:41,919 --> 00:18:43,440
questions you know in real time as

529
00:18:43,440 --> 00:18:44,880
opposed to chatting uh typing them in

530
00:18:44,880 --> 00:18:46,080
the chat either way he's fine

531
00:18:46,080 --> 00:18:49,520
but um okay so

532
00:18:49,520 --> 00:18:50,960
as i hinted you know with this

533
00:18:50,960 --> 00:18:52,559
replication state machine approach you

534
00:18:52,559 --> 00:18:54,000
know there's a question about

535
00:18:54,000 --> 00:18:57,200
what level

536
00:18:57,200 --> 00:18:59,039
of replication are due what level of

537
00:18:59,039 --> 00:19:04,230
operations

538
00:19:04,240 --> 00:19:10,320
to replicate

539
00:19:10,320 --> 00:19:13,760
um so in one

540
00:19:13,760 --> 00:19:16,640
uh one possibility sort of application

541
00:19:16,640 --> 00:19:35,510
level operations

542
00:19:35,520 --> 00:19:38,160
so what i mean is you know think i think

543
00:19:38,160 --> 00:19:38,799
back at the

544
00:19:38,799 --> 00:19:46,710
gfs like whether it's append file append

545
00:19:46,720 --> 00:19:51,510
or right

546
00:19:51,520 --> 00:19:54,880
another and the the okay and

547
00:19:54,880 --> 00:19:56,799
if you play the game sort of replicate

548
00:19:56,799 --> 00:19:58,320
state machine game at the level of the

549
00:19:58,320 --> 00:19:59,760
sort of application level operations

550
00:19:59,760 --> 00:20:00,960
that means that the application has to

551
00:20:00,960 --> 00:20:01,679
be involved

552
00:20:01,679 --> 00:20:02,960
you know because it knows what the

553
00:20:02,960 --> 00:20:05,120
semantics of these operations are

554
00:20:05,120 --> 00:20:06,640
and then it knows what an independent

555
00:20:06,640 --> 00:20:08,159
actually supposed to do

556
00:20:08,159 --> 00:20:10,080
uh or what a ride is supposed to do and

557
00:20:10,080 --> 00:20:11,200
so uh if you're

558
00:20:11,200 --> 00:20:12,880
playing a replicated state machine

559
00:20:12,880 --> 00:20:14,400
approach at the that kind of

560
00:20:14,400 --> 00:20:16,000
application level then the application

561
00:20:16,000 --> 00:20:17,440
itself needs to be modified

562
00:20:17,440 --> 00:20:20,080
you know to actually uh perform or play

563
00:20:20,080 --> 00:20:21,440
part of the replicated state machine

564
00:20:21,440 --> 00:20:22,799
approach

565
00:20:22,799 --> 00:20:24,559
one thing that's cool about the paper

566
00:20:24,559 --> 00:20:26,240
today that we're looking at too

567
00:20:26,240 --> 00:20:29,280
and we're looking at today is

568
00:20:29,280 --> 00:20:31,200
it you know does the operations at the

569
00:20:31,200 --> 00:20:32,559
machine level

570
00:20:32,559 --> 00:20:34,320
or the processor level or the computer

571
00:20:34,320 --> 00:20:35,679
level uh

572
00:20:35,679 --> 00:20:39,280
and so the state uh is registers

573
00:20:39,280 --> 00:20:41,840
you know the x86 registers the memory

574
00:20:41,840 --> 00:20:44,549
state

575
00:20:44,559 --> 00:20:47,039
and the operations are just ordinary

576
00:20:47,039 --> 00:20:48,240
computer instructions

577
00:20:48,240 --> 00:20:51,760
and by replicating at that level

578
00:20:51,760 --> 00:20:55,200
then you can basically um

579
00:20:55,200 --> 00:20:56,640
make your replication completely

580
00:20:56,640 --> 00:20:58,559
transparent because you can take one

581
00:20:58,559 --> 00:20:59,760
computer

582
00:20:59,760 --> 00:21:00,960
run the application or an operating

583
00:21:00,960 --> 00:21:02,960
system on top of it that just runs

584
00:21:02,960 --> 00:21:05,760
x86 instructions and this replicated

585
00:21:05,760 --> 00:21:07,120
state machine approach

586
00:21:07,120 --> 00:21:10,720
uh automatically uh creates a backup

587
00:21:10,720 --> 00:21:13,120
of that of that particular execution so

588
00:21:13,120 --> 00:21:14,240
the application doesn't have to be

589
00:21:14,240 --> 00:21:16,320
modified at all in fact in this paper

590
00:21:16,320 --> 00:21:18,880
the uh operating system is not modified

591
00:21:18,880 --> 00:21:20,640
the application is not modified you can

592
00:21:20,640 --> 00:21:22,799
take an ordinary application not even

593
00:21:22,799 --> 00:21:24,960
written with fault tolerance in mind and

594
00:21:24,960 --> 00:21:26,000
using this sort of

595
00:21:26,000 --> 00:21:28,960
uh machine level uh or instruction level

596
00:21:28,960 --> 00:21:30,400
replication

597
00:21:30,400 --> 00:21:33,120
it can be transparently replicated so

598
00:21:33,120 --> 00:21:34,480
one of the things that is very cool

599
00:21:34,480 --> 00:21:36,240
about you know the paper of today

600
00:21:36,240 --> 00:21:42,310
is it's just completely transparent

601
00:21:42,320 --> 00:21:46,000
now um that makes you wonder like you

602
00:21:46,000 --> 00:21:46,480
know

603
00:21:46,480 --> 00:21:47,840
you know how to do that because like

604
00:21:47,840 --> 00:21:49,760
what happens if like you have a machine

605
00:21:49,760 --> 00:21:52,480
and an interrupt happens you know that

606
00:21:52,480 --> 00:21:53,600
interrupt needs to

607
00:21:53,600 --> 00:21:56,400
be propagated in some way directly to

608
00:21:56,400 --> 00:21:57,760
the backup because like if you think

609
00:21:57,760 --> 00:21:59,520
about the x86 machine

610
00:21:59,520 --> 00:22:00,720
you know of course the regular

611
00:22:00,720 --> 00:22:02,000
instructions that the applications

612
00:22:02,000 --> 00:22:03,200
execute like add

613
00:22:03,200 --> 00:22:05,120
you know whatever divide you know

614
00:22:05,120 --> 00:22:07,039
conditional branch branching

615
00:22:07,039 --> 00:22:09,120
uh procedure calls but there are also

616
00:22:09,120 --> 00:22:10,880
other events like you know interrupts

617
00:22:10,880 --> 00:22:12,880
and they need to be you know handled

618
00:22:12,880 --> 00:22:14,960
with and so how do you do that

619
00:22:14,960 --> 00:22:19,039
and so um the traditional uh

620
00:22:19,039 --> 00:22:20,880
way of doing sort of machine level

621
00:22:20,880 --> 00:22:22,080
replication

622
00:22:22,080 --> 00:22:24,159
uh used to be sort of quite expensive in

623
00:22:24,159 --> 00:22:25,120
the sense that

624
00:22:25,120 --> 00:22:27,919
uh the you could buy computers or where

625
00:22:27,919 --> 00:22:29,440
the processors like maybe replicate it

626
00:22:29,440 --> 00:22:31,039
twice or three times

627
00:22:31,039 --> 00:22:33,360
and the hardware itself would organize

628
00:22:33,360 --> 00:22:35,280
you know that these processors

629
00:22:35,280 --> 00:22:38,559
ran exactly in lockstep um

630
00:22:38,559 --> 00:22:39,760
and you know that there's a lot of

631
00:22:39,760 --> 00:22:41,280
hardware machinery to actually make this

632
00:22:41,280 --> 00:22:41,840
happen and

633
00:22:41,840 --> 00:22:44,799
this paper has a cool observation that

634
00:22:44,799 --> 00:22:45,360
uh

635
00:22:45,360 --> 00:22:47,280
you don't really need to do really

636
00:22:47,280 --> 00:22:48,960
hardware replication

637
00:22:48,960 --> 00:22:52,830
instead you can actually use virtual

638
00:22:52,840 --> 00:22:57,430
machines

639
00:22:57,440 --> 00:23:00,480
and that's the way they do it now pure

640
00:23:00,480 --> 00:23:02,320
hardware replication happens too

641
00:23:02,320 --> 00:23:05,919
uh you know for example in uh

642
00:23:05,919 --> 00:23:09,039
in aeronautics or

643
00:23:09,039 --> 00:23:11,679
uh you know whatever mars rover uh you

644
00:23:11,679 --> 00:23:12,320
know often

645
00:23:12,320 --> 00:23:13,679
the hardware modules are just like you

646
00:23:13,679 --> 00:23:15,520
know double

647
00:23:15,520 --> 00:23:17,840
duplex replicated or triple replicated

648
00:23:17,840 --> 00:23:19,679
and have a hardware voting scheme

649
00:23:19,679 --> 00:23:21,520
you know to keep the processors in sync

650
00:23:21,520 --> 00:23:23,039
and to detect failures

651
00:23:23,039 --> 00:23:24,480
but a sort of a level of you know

652
00:23:24,480 --> 00:23:26,640
tolerance that you know that's not what

653
00:23:26,640 --> 00:23:27,280
the

654
00:23:27,280 --> 00:23:30,080
this this uh the level of autonomous

655
00:23:30,080 --> 00:23:30,559
that the

656
00:23:30,559 --> 00:23:33,039
this vmft paper is not actually shooting

657
00:23:33,039 --> 00:23:34,720
for it's really thinking about like you

658
00:23:34,720 --> 00:23:36,159
know you got a

659
00:23:36,159 --> 00:23:38,799
business application uh running on on

660
00:23:38,799 --> 00:23:40,159
the computer and now you want to make

661
00:23:40,159 --> 00:23:41,520
that business application more fall

662
00:23:41,520 --> 00:23:42,480
tolerant

663
00:23:42,480 --> 00:23:44,720
and the approach to take is to you know

664
00:23:44,720 --> 00:23:48,390
exploit fertilization

665
00:23:48,400 --> 00:23:53,269
so the piston to vmft

666
00:23:53,279 --> 00:23:56,480
and exploit virtualization that's the

667
00:23:56,480 --> 00:24:00,230
main

668
00:24:00,240 --> 00:24:02,960
big idea that they uh bring along to

669
00:24:02,960 --> 00:24:04,799
this problem and you know by doing so

670
00:24:04,799 --> 00:24:05,760
they can make this

671
00:24:05,760 --> 00:24:07,520
replication transparent to the

672
00:24:07,520 --> 00:24:16,310
application

673
00:24:16,320 --> 00:24:18,000
of course you don't have to design as an

674
00:24:18,000 --> 00:24:19,919
application design and then a

675
00:24:19,919 --> 00:24:21,600
replication scheme like you know for

676
00:24:21,600 --> 00:24:25,039
example the way it's done in uh

677
00:24:25,039 --> 00:24:28,400
in gfs uh it appears you know

678
00:24:28,400 --> 00:24:29,760
using the scheme there's replication

679
00:24:29,760 --> 00:24:31,600
scheme that the vmct

680
00:24:31,600 --> 00:24:35,039
uses it appears basically that the

681
00:24:35,039 --> 00:24:38,320
severe client but the service is a

682
00:24:38,320 --> 00:24:44,630
single machine

683
00:24:44,640 --> 00:24:46,880
meaning just you know we'll see in a

684
00:24:46,880 --> 00:24:48,080
second how but you know basically

685
00:24:48,080 --> 00:24:49,120
they're going to provide very strong

686
00:24:49,120 --> 00:24:51,360
consistency you know the the the

687
00:24:51,360 --> 00:24:54,400
client on the outside can't even tell um

688
00:24:54,400 --> 00:24:56,480
and uh it actually you know the paper

689
00:24:56,480 --> 00:24:58,159
sort of cool paper because it actually

690
00:24:58,159 --> 00:25:04,149
is it's a real product

691
00:25:04,159 --> 00:25:08,400
and it's still in use you can uh

692
00:25:08,400 --> 00:25:12,080
you know get this uh this is the support

693
00:25:12,080 --> 00:25:15,200
uh if you want to uh the current product

694
00:25:15,200 --> 00:25:16,799
i think is quite different from the one

695
00:25:16,799 --> 00:25:19,120
that we actually read about in the paper

696
00:25:19,120 --> 00:25:21,600
uh but you know at the very high level

697
00:25:21,600 --> 00:25:22,400
you know the

698
00:25:22,400 --> 00:25:24,720
the issues are very similar in fact you

699
00:25:24,720 --> 00:25:25,600
know the

700
00:25:25,600 --> 00:25:28,240
one of the big uh shortcomings as many

701
00:25:28,240 --> 00:25:29,919
of you noted in the questions

702
00:25:29,919 --> 00:25:32,799
uh of the the the one that's scrapped in

703
00:25:32,799 --> 00:25:33,360
the paper it's

704
00:25:33,360 --> 00:25:35,440
like it's a single core solution so

705
00:25:35,440 --> 00:25:37,360
there's no multi-core support and so

706
00:25:37,360 --> 00:25:38,400
multiple application

707
00:25:38,400 --> 00:25:40,240
multiple threads on one computer cannot

708
00:25:40,240 --> 00:25:41,600
run in parallel

709
00:25:41,600 --> 00:25:43,200
and we'll talk about in a second why the

710
00:25:43,200 --> 00:25:44,799
solution doesn't really support that

711
00:25:44,799 --> 00:25:48,640
uh in i think later later versions of

712
00:25:48,640 --> 00:25:51,679
ft this actually works and uh

713
00:25:51,679 --> 00:25:53,840
i think you know there's no pay real

714
00:25:53,840 --> 00:25:56,080
detailed paper that describes it

715
00:25:56,080 --> 00:25:58,080
but i actually think that instead of

716
00:25:58,080 --> 00:25:59,600
using actual replicated state machine

717
00:25:59,600 --> 00:26:01,120
approach to actually using a state

718
00:26:01,120 --> 00:26:03,360
transfer approach

719
00:26:03,360 --> 00:26:05,360
but i really don't know any really the

720
00:26:05,360 --> 00:26:07,279
details

721
00:26:07,279 --> 00:26:08,880
i'm going to focus on the replicated

722
00:26:08,880 --> 00:26:10,159
state machine approach because one

723
00:26:10,159 --> 00:26:11,760
reason i like this paper is because it

724
00:26:11,760 --> 00:26:13,279
sort of illustrates replicated state

725
00:26:13,279 --> 00:26:14,960
machining approach in a very clean

726
00:26:14,960 --> 00:26:15,679
manner

727
00:26:15,679 --> 00:26:17,760
and all the you know a lot of the

728
00:26:17,760 --> 00:26:19,279
subsequent uh

729
00:26:19,279 --> 00:26:20,400
replication schemes that we're going to

730
00:26:20,400 --> 00:26:22,640
be looking at are replicated state

731
00:26:22,640 --> 00:26:26,230
machine approaches

732
00:26:26,240 --> 00:26:30,549
okay so

733
00:26:30,559 --> 00:26:35,510
so let us sketch out the overview

734
00:26:35,520 --> 00:26:38,559
of this system and so the first thing

735
00:26:38,559 --> 00:26:40,880
uh you sort of need to realize is that

736
00:26:40,880 --> 00:26:42,240
there is a virtual there's a virtual

737
00:26:42,240 --> 00:26:43,039
machine monitor

738
00:26:43,039 --> 00:26:44,559
involved so what is a virtual machine

739
00:26:44,559 --> 00:26:46,799
monitor well virtual machine monitor

740
00:26:46,799 --> 00:26:48,480
basically takes a piece of hardware

741
00:26:48,480 --> 00:26:51,600
and uh it makes it appear you know

742
00:26:51,600 --> 00:26:52,000
basically

743
00:26:52,000 --> 00:26:54,799
makes end pieces of hardware out of it

744
00:26:54,799 --> 00:26:55,200
uh

745
00:26:55,200 --> 00:26:58,480
so if we like have a you know an x86 box

746
00:26:58,480 --> 00:26:59,760
you know we can take a virtual machine

747
00:26:59,760 --> 00:27:03,269
monitor and run it on top of it

748
00:27:03,279 --> 00:27:04,880
and you know on top of it we can have

749
00:27:04,880 --> 00:27:07,440
virtual machines and a virtual machine

750
00:27:07,440 --> 00:27:08,720
uh we're gonna have multiple virtual

751
00:27:08,720 --> 00:27:10,640
machines although in most of this paper

752
00:27:10,640 --> 00:27:12,080
we're gonna be talking about running one

753
00:27:12,080 --> 00:27:13,600
virtual machine on top of the virtual

754
00:27:13,600 --> 00:27:15,279
machine monitor

755
00:27:15,279 --> 00:27:17,039
um and so for example we might actually

756
00:27:17,039 --> 00:27:19,200
have a linux you know operating system

757
00:27:19,200 --> 00:27:19,760
running

758
00:27:19,760 --> 00:27:21,360
on top of the virtual machine you know

759
00:27:21,360 --> 00:27:28,230
with its you know applications

760
00:27:28,240 --> 00:27:30,000
and you know here's actually the actual

761
00:27:30,000 --> 00:27:31,840
hardware

762
00:27:31,840 --> 00:27:35,840
and why you know so and so the vm

763
00:27:35,840 --> 00:27:37,360
uh the terminology used here is

764
00:27:37,360 --> 00:27:38,880
sometimes called the hypervisor it's

765
00:27:38,880 --> 00:27:40,799
called the virtual machine monitor

766
00:27:40,799 --> 00:27:43,679
um and so in our case you know really

767
00:27:43,679 --> 00:27:45,279
with the the hypervisor here

768
00:27:45,279 --> 00:27:49,990
this is actually you know vmft

769
00:27:50,000 --> 00:27:52,000
so it's a hypervisor modified you know

770
00:27:52,000 --> 00:27:54,240
to include you know the ideas that

771
00:27:54,240 --> 00:27:57,360
vmft has

772
00:27:57,360 --> 00:27:59,200
and why is this cool well the reason

773
00:27:59,200 --> 00:28:01,279
this is cool because or useful

774
00:28:01,279 --> 00:28:02,880
uh for replicated state machines is

775
00:28:02,880 --> 00:28:04,880
because even hardware you know interrupt

776
00:28:04,880 --> 00:28:06,000
actually happens

777
00:28:06,000 --> 00:28:07,440
that hardware interrupt doesn't really

778
00:28:07,440 --> 00:28:09,279
go straight you know to linux in fact

779
00:28:09,279 --> 00:28:10,559
the hardware interrupt goes first

780
00:28:10,559 --> 00:28:12,399
through the vm monitor

781
00:28:12,399 --> 00:28:14,000
the vm monitor actually this site's

782
00:28:14,000 --> 00:28:15,679
going to win to deliver you know that

783
00:28:15,679 --> 00:28:17,679
interrupt you know to linux

784
00:28:17,679 --> 00:28:20,320
and so any external events you know

785
00:28:20,320 --> 00:28:22,320
before they actually sort of observed

786
00:28:22,320 --> 00:28:24,080
you know by the virtual machine

787
00:28:24,080 --> 00:28:25,840
are actually captured by or can be

788
00:28:25,840 --> 00:28:27,200
captured by the

789
00:28:27,200 --> 00:28:30,240
hypervisor and so this gets us about

790
00:28:30,240 --> 00:28:30,960
this mess

791
00:28:30,960 --> 00:28:32,399
you know of like what i mentioned a

792
00:28:32,399 --> 00:28:34,559
little bit earlier where you know

793
00:28:34,559 --> 00:28:36,000
what happens if there's an external

794
00:28:36,000 --> 00:28:37,440
interrupt you know how can we sort of

795
00:28:37,440 --> 00:28:38,559
replicate that

796
00:28:38,559 --> 00:28:40,640
and the way we're going to replicate it

797
00:28:40,640 --> 00:28:41,919
here is because the virtual machine

798
00:28:41,919 --> 00:28:45,120
monitor just gets control over it

799
00:28:45,120 --> 00:28:46,159
and we'll see you know this is going to

800
00:28:46,159 --> 00:28:48,320
be an extremely powerful tool uh

801
00:28:48,320 --> 00:28:51,039
to actually uh make instruction

802
00:28:51,039 --> 00:28:53,120
deterministic you know handle external

803
00:28:53,120 --> 00:28:55,440
operations et cetera et cetera

804
00:28:55,440 --> 00:28:58,399
so the basic plan is like if uh an

805
00:28:58,399 --> 00:28:59,360
interrupt comes in

806
00:28:59,360 --> 00:29:00,799
you know whether there's an interrupt

807
00:29:00,799 --> 00:29:02,720
from the network or from

808
00:29:02,720 --> 00:29:06,880
uh uh from the hardware itself like a

809
00:29:06,880 --> 00:29:07,919
timer interrupt

810
00:29:07,919 --> 00:29:09,520
you know basically the timer interrupt

811
00:29:09,520 --> 00:29:11,120
is delivered you know to the

812
00:29:11,120 --> 00:29:13,600
virtual machine monitor uh the virtual

813
00:29:13,600 --> 00:29:14,880
machine monitor

814
00:29:14,880 --> 00:29:16,960
then in the case of fmnt it does two

815
00:29:16,960 --> 00:29:18,000
things you know

816
00:29:18,000 --> 00:29:19,600
not only delivers it at some point to

817
00:29:19,600 --> 00:29:21,120
the application it also sends

818
00:29:21,120 --> 00:29:23,600
over a logging channel to a backup

819
00:29:23,600 --> 00:29:24,960
computer

820
00:29:24,960 --> 00:29:26,559
and that computer is restructured in the

821
00:29:26,559 --> 00:29:28,480
same way you know it has hardware

822
00:29:28,480 --> 00:29:32,000
uh it has uh the virtual machine monitor

823
00:29:32,000 --> 00:29:33,600
sitting on top of it so here's another

824
00:29:33,600 --> 00:29:34,720
copy of

825
00:29:34,720 --> 00:29:37,360
fmft and you know on top of this virtual

826
00:29:37,360 --> 00:29:37,840
machine

827
00:29:37,840 --> 00:29:40,000
you know where identical software

828
00:29:40,000 --> 00:29:41,840
running on it like linux

829
00:29:41,840 --> 00:29:43,520
same version of linux you know with you

830
00:29:43,520 --> 00:29:47,750
know whatever some set of applications

831
00:29:47,760 --> 00:29:50,559
all right okay and so like you know

832
00:29:50,559 --> 00:29:51,200
these

833
00:29:51,200 --> 00:29:53,919
machines both on you know some networks

834
00:29:53,919 --> 00:29:58,070
so here's the logging channel

835
00:29:58,080 --> 00:30:00,720
and maybe years of clients you know

836
00:30:00,720 --> 00:30:02,559
talking basically to

837
00:30:02,559 --> 00:30:05,520
the hardware uh do the sensor packet

838
00:30:05,520 --> 00:30:06,720
over the network

839
00:30:06,720 --> 00:30:09,200
uh the actual hardware you know receives

840
00:30:09,200 --> 00:30:10,320
that packet

841
00:30:10,320 --> 00:30:13,840
uh and then uh they will uh and

842
00:30:13,840 --> 00:30:15,679
deliver it you know and the virtual

843
00:30:15,679 --> 00:30:17,440
machine monitor just gets control and

844
00:30:17,440 --> 00:30:18,960
delivers it and the hardware delivers it

845
00:30:18,960 --> 00:30:20,240
to the virtual machine monitor or the

846
00:30:20,240 --> 00:30:21,440
virtual machine monitor if you will

847
00:30:21,440 --> 00:30:21,919
picks it

848
00:30:21,919 --> 00:30:25,120
up and so um

849
00:30:25,120 --> 00:30:27,039
if you think about it you know this this

850
00:30:27,039 --> 00:30:28,960
packet you know results

851
00:30:28,960 --> 00:30:32,640
in an in an interrupt that's delivered

852
00:30:32,640 --> 00:30:34,240
to the virtual machine monitor

853
00:30:34,240 --> 00:30:36,159
the virtual machine monitor will send

854
00:30:36,159 --> 00:30:37,440
that interrupt

855
00:30:37,440 --> 00:30:38,960
as we'll see in a second you know

856
00:30:38,960 --> 00:30:41,279
forward it to the backup

857
00:30:41,279 --> 00:30:45,039
uh deliver it it delivers it also to the

858
00:30:45,039 --> 00:30:47,679
local virtual machine the local virtual

859
00:30:47,679 --> 00:30:49,520
machine you know was just linux running

860
00:30:49,520 --> 00:30:51,279
she saw i got an interrupt and so it

861
00:30:51,279 --> 00:30:52,720
does it's normal processing it always

862
00:30:52,720 --> 00:30:54,480
we're doing an interrupt and so at some

863
00:30:54,480 --> 00:30:56,000
point you know maybe it will

864
00:30:56,000 --> 00:30:58,960
generate a response and also for example

865
00:30:58,960 --> 00:30:59,360
write

866
00:30:59,360 --> 00:31:01,039
you know to the network card or at least

867
00:31:01,039 --> 00:31:02,399
it will think it's writing to the

868
00:31:02,399 --> 00:31:04,399
network interface card but really what

869
00:31:04,399 --> 00:31:04,799
it is

870
00:31:04,799 --> 00:31:06,559
is a virtual network interface card that

871
00:31:06,559 --> 00:31:07,919
is like

872
00:31:07,919 --> 00:31:09,840
emulated you know by the virtual machine

873
00:31:09,840 --> 00:31:11,519
monitor so when it writes actually you

874
00:31:11,519 --> 00:31:11,840
know

875
00:31:11,840 --> 00:31:15,120
a bunch of instructions uh to this you

876
00:31:15,120 --> 00:31:15,600
know

877
00:31:15,600 --> 00:31:17,519
virtual cart really what it is it's

878
00:31:17,519 --> 00:31:18,799
actually writing to the virtual machine

879
00:31:18,799 --> 00:31:20,480
monitor and so the future museum is like

880
00:31:20,480 --> 00:31:21,519
ah you know here's

881
00:31:21,519 --> 00:31:23,440
uh an operating system trying to

882
00:31:23,440 --> 00:31:25,039
actually send the packet

883
00:31:25,039 --> 00:31:26,559
and then you know the virtual machine

884
00:31:26,559 --> 00:31:27,919
monitor you know can actually send the

885
00:31:27,919 --> 00:31:29,440
packet on behalf of the operating system

886
00:31:29,440 --> 00:31:29,840
by

887
00:31:29,840 --> 00:31:31,600
programming the real hardware and then

888
00:31:31,600 --> 00:31:32,960
the real hardware you know sends off

889
00:31:32,960 --> 00:31:36,000
you know response to the client right

890
00:31:36,000 --> 00:31:38,320
now just the sort of normal execution

891
00:31:38,320 --> 00:31:40,000
for what here's the

892
00:31:40,000 --> 00:31:44,710
the primary and here's our backup

893
00:31:44,720 --> 00:31:46,080
and basically the backup the same thing

894
00:31:46,080 --> 00:31:47,760
happens you know if you know the machine

895
00:31:47,760 --> 00:31:49,360
started exactly in the same

896
00:31:49,360 --> 00:31:51,600
state you know they take the interrupt

897
00:31:51,600 --> 00:31:52,880
you know at the same time and the

898
00:31:52,880 --> 00:31:54,399
virtual machine monitor can control

899
00:31:54,399 --> 00:31:55,919
when to deliver the interrupt so you can

900
00:31:55,919 --> 00:31:57,440
arrange you know to make sure that the

901
00:31:57,440 --> 00:31:59,120
interrupt is actually delivered exactly

902
00:31:59,120 --> 00:32:00,720
at the same time and exactly the same

903
00:32:00,720 --> 00:32:01,760
instruction

904
00:32:01,760 --> 00:32:03,840
that the primary got it so we'll deliver

905
00:32:03,840 --> 00:32:05,519
the interrupt you know to the

906
00:32:05,519 --> 00:32:06,640
you know we'll receive the interrupt

907
00:32:06,640 --> 00:32:08,480
from the primary maybe buffer for a

908
00:32:08,480 --> 00:32:09,840
little while until the

909
00:32:09,840 --> 00:32:11,519
back of us was seen second hits near

910
00:32:11,519 --> 00:32:12,880
sort of the same instruction that the

911
00:32:12,880 --> 00:32:13,679
primary dot

912
00:32:13,679 --> 00:32:15,360
then delivers the interrupt you know to

913
00:32:15,360 --> 00:32:18,080
linux linux just as usual way it will be

914
00:32:18,080 --> 00:32:19,679
you know since it's exactly in the same

915
00:32:19,679 --> 00:32:21,200
state as in the primary it will do

916
00:32:21,200 --> 00:32:22,799
exactly the same thing as the primary

917
00:32:22,799 --> 00:32:23,279
dos

918
00:32:23,279 --> 00:32:25,519
so at some point you know it will you

919
00:32:25,519 --> 00:32:26,559
know program the

920
00:32:26,559 --> 00:32:28,480
virtual network card to actually send a

921
00:32:28,480 --> 00:32:29,679
response packet

922
00:32:29,679 --> 00:32:31,519
you know all that stuff will happen and

923
00:32:31,519 --> 00:32:32,880
at some point says like you know sent

924
00:32:32,880 --> 00:32:33,519
that packet

925
00:32:33,519 --> 00:32:35,600
you know the virtual machine uh monitor

926
00:32:35,600 --> 00:32:36,799
will get control

927
00:32:36,799 --> 00:32:38,640
it knows it's a backup and so it doesn't

928
00:32:38,640 --> 00:32:40,000
doesn't do anything it actually doesn't

929
00:32:40,000 --> 00:32:41,360
send the packet on the network

930
00:32:41,360 --> 00:32:44,480
because it's the background okay that's

931
00:32:44,480 --> 00:32:45,279
the

932
00:32:45,279 --> 00:32:48,399
basic plan then there's uh

933
00:32:48,399 --> 00:32:50,880
one more component in this story that is

934
00:32:50,880 --> 00:32:52,399
important to realize which is that there

935
00:32:52,399 --> 00:32:53,279
is on the

936
00:32:53,279 --> 00:32:58,000
side on the side on the same network

937
00:32:58,000 --> 00:33:07,590
there is a storage server

938
00:33:07,600 --> 00:33:09,679
you can think about this as the the hard

939
00:33:09,679 --> 00:33:11,039
disk you know for these

940
00:33:11,039 --> 00:33:13,840
uh for these two virtual machines or for

941
00:33:13,840 --> 00:33:14,320
the

942
00:33:14,320 --> 00:33:16,799
and so when an application you know here

943
00:33:16,799 --> 00:33:18,559
writes to a file really what it turns

944
00:33:18,559 --> 00:33:19,440
into

945
00:33:19,440 --> 00:33:22,159
is you know the kernel will you know

946
00:33:22,159 --> 00:33:24,320
that file system is maybe mounted

947
00:33:24,320 --> 00:33:26,559
uh on there on the the local linux

948
00:33:26,559 --> 00:33:28,000
operating system the linux operating

949
00:33:28,000 --> 00:33:29,679
system sees ah this is like a remote

950
00:33:29,679 --> 00:33:30,399
disk

951
00:33:30,399 --> 00:33:32,320
and we'll format the packet and then

952
00:33:32,320 --> 00:33:34,480
we'll send that packet you know to

953
00:33:34,480 --> 00:33:36,159
you know let me throttle maybe in a

954
00:33:36,159 --> 00:33:37,279
slightly different we'll send a packet

955
00:33:37,279 --> 00:33:39,279
you know to the virtual machine monitor

956
00:33:39,279 --> 00:33:40,640
the same place in a virtual machine

957
00:33:40,640 --> 00:33:42,320
monitor like send it off the virtual

958
00:33:42,320 --> 00:33:44,080
machine monitor you know we'll go off

959
00:33:44,080 --> 00:33:45,760
and send it over the network you know to

960
00:33:45,760 --> 00:33:49,039
the storage server the storage server

961
00:33:49,039 --> 00:33:50,720
will respond at some point and in some

962
00:33:50,720 --> 00:33:52,480
ways this communication looks identical

963
00:33:52,480 --> 00:33:53,440
as if there's like

964
00:33:53,440 --> 00:33:54,799
a client sitting on the other side of

965
00:33:54,799 --> 00:33:56,559
the network you know the only difference

966
00:33:56,559 --> 00:33:58,240
is being that in the

967
00:33:58,240 --> 00:34:01,120
uh storage server case the linux sort of

968
00:34:01,120 --> 00:34:01,600
inner

969
00:34:01,600 --> 00:34:03,360
starts the communication while in the

970
00:34:03,360 --> 00:34:04,840
other case the client starts the

971
00:34:04,840 --> 00:34:06,880
communication

972
00:34:06,880 --> 00:34:08,320
green errors represent communication to

973
00:34:08,320 --> 00:34:10,079
the storage server so a network packet's

974
00:34:10,079 --> 00:34:11,760
being sent from

975
00:34:11,760 --> 00:34:13,040
through linux through the virtual

976
00:34:13,040 --> 00:34:15,520
machine monitor to the storage server

977
00:34:15,520 --> 00:34:18,480
and so when uh so i'm right by an

978
00:34:18,480 --> 00:34:19,760
application through a file basically

979
00:34:19,760 --> 00:34:21,040
results in these messages

980
00:34:21,040 --> 00:34:22,720
and then you know it will whatever

981
00:34:22,720 --> 00:34:24,480
update any state you know

982
00:34:24,480 --> 00:34:27,119
persistent state that you know on the on

983
00:34:27,119 --> 00:34:29,839
the storage server

984
00:34:29,839 --> 00:34:31,520
now as we saw in the paper uh the

985
00:34:31,520 --> 00:34:33,599
storage server place

986
00:34:33,599 --> 00:34:38,480
an additional role on top of uh

987
00:34:38,480 --> 00:34:39,839
on top of a basically being stored

988
00:34:39,839 --> 00:34:41,839
server namely there's sort of a special

989
00:34:41,839 --> 00:34:43,520
flag

990
00:34:43,520 --> 00:34:45,679
that sits on the site where there's a

991
00:34:45,679 --> 00:34:48,879
block in the storage server

992
00:34:48,879 --> 00:34:51,839
that's being used to arbitrate who

993
00:34:51,839 --> 00:34:56,000
becomes the primary after a failure

994
00:34:56,000 --> 00:34:59,200
so so and this all comes down to

995
00:34:59,200 --> 00:35:01,680
this is the part of the failover plan so

996
00:35:01,680 --> 00:35:02,480
let's say

997
00:35:02,480 --> 00:35:06,240
you know the uh logins general breaks or

998
00:35:06,240 --> 00:35:06,640
and

999
00:35:06,640 --> 00:35:08,960
in the way you know this manifests you

1000
00:35:08,960 --> 00:35:10,480
know through the virtual machine monitor

1001
00:35:10,480 --> 00:35:11,359
is that it

1002
00:35:11,359 --> 00:35:13,200
sends periodically packets you know over

1003
00:35:13,200 --> 00:35:14,400
this logging channel

1004
00:35:14,400 --> 00:35:18,400
and it doesn't get any responses uh uh

1005
00:35:18,400 --> 00:35:20,880
from the other side then it assumes that

1006
00:35:20,880 --> 00:35:21,920
the

1007
00:35:21,920 --> 00:35:23,760
other side there's a problem and of

1008
00:35:23,760 --> 00:35:25,119
course it can't decide

1009
00:35:25,119 --> 00:35:26,880
whether you know just the network is not

1010
00:35:26,880 --> 00:35:28,400
working or

1011
00:35:28,400 --> 00:35:29,760
whether actually the virtual machine

1012
00:35:29,760 --> 00:35:31,280
monitor you know the computers really

1013
00:35:31,280 --> 00:35:32,240
crashed

1014
00:35:32,240 --> 00:35:33,599
and if it's really crashed of course it

1015
00:35:33,599 --> 00:35:35,280
should you know take over

1016
00:35:35,280 --> 00:35:36,960
and if it's really not crashed then you

1017
00:35:36,960 --> 00:35:38,560
know we have to arbitrate in some way

1018
00:35:38,560 --> 00:35:40,000
we'll make sure that only one of them

1019
00:35:40,000 --> 00:35:42,160
actually proceeds so let's say the

1020
00:35:42,160 --> 00:35:44,320
network partitions

1021
00:35:44,320 --> 00:35:46,160
and so this is the harder case when the

1022
00:35:46,160 --> 00:35:48,160
network petitions uh instead of like

1023
00:35:48,160 --> 00:35:50,640
one of them two crashes so yeah network

1024
00:35:50,640 --> 00:35:51,920
partitions

1025
00:35:51,920 --> 00:35:54,960
uh but you know notice that the two can

1026
00:35:54,960 --> 00:35:56,400
still communicate both the

1027
00:35:56,400 --> 00:35:57,839
frame and the backup can communicate to

1028
00:35:57,839 --> 00:35:59,520
the storage server

1029
00:35:59,520 --> 00:36:01,599
and so in this particular case you know

1030
00:36:01,599 --> 00:36:03,280
what will happen is they will notice you

1031
00:36:03,280 --> 00:36:04,640
know both sites will notice

1032
00:36:04,640 --> 00:36:06,640
the primary and backup will notice oh

1033
00:36:06,640 --> 00:36:07,920
there's some problem because i can't

1034
00:36:07,920 --> 00:36:08,880
talk to their

1035
00:36:08,880 --> 00:36:11,440
primary anymore or use it and so they at

1036
00:36:11,440 --> 00:36:12,880
some point decide well the other guy

1037
00:36:12,880 --> 00:36:13,599
must probably

1038
00:36:13,599 --> 00:36:15,680
could be dead and i want to promote

1039
00:36:15,680 --> 00:36:17,440
myself to primary so the backup says

1040
00:36:17,440 --> 00:36:18,640
like i want to promote myself the

1041
00:36:18,640 --> 00:36:19,200
primary

1042
00:36:19,200 --> 00:36:20,880
or the primary says like well i just

1043
00:36:20,880 --> 00:36:23,520
want to really continue uh

1044
00:36:23,520 --> 00:36:25,280
serving client requests and i just want

1045
00:36:25,280 --> 00:36:27,839
to ignore the backup for now

1046
00:36:27,839 --> 00:36:29,520
so basically this says this is what they

1047
00:36:29,520 --> 00:36:33,109
call they want to go live

1048
00:36:33,119 --> 00:36:35,440
basically go back into single mode and

1049
00:36:35,440 --> 00:36:36,320
we want to do

1050
00:36:36,320 --> 00:36:39,119
and with one primer and so the way that

1051
00:36:39,119 --> 00:36:40,160
this happens is that

1052
00:36:40,160 --> 00:36:42,160
you know both of them you know send try

1053
00:36:42,160 --> 00:36:43,920
to read

1054
00:36:43,920 --> 00:36:49,109
they call this a testis set operation

1055
00:36:49,119 --> 00:36:50,400
and i'll talk a little bit about it in

1056
00:36:50,400 --> 00:36:52,160
more detail but basically both reach out

1057
00:36:52,160 --> 00:36:53,359
to the storage server

1058
00:36:53,359 --> 00:36:55,359
and try to write the flag saying you

1059
00:36:55,359 --> 00:36:58,079
know instead of do one

1060
00:36:58,079 --> 00:36:59,920
and if the flight was already set to one

1061
00:36:59,920 --> 00:37:01,440
set to one

1062
00:37:01,440 --> 00:37:03,359
then it ended like that the other guy

1063
00:37:03,359 --> 00:37:04,560
won earlier

1064
00:37:04,560 --> 00:37:07,440
okay so it goes from zero to one uh they

1065
00:37:07,440 --> 00:37:09,200
both try to do this atomically

1066
00:37:09,200 --> 00:37:10,800
one of them is going to go first you

1067
00:37:10,800 --> 00:37:12,640
know that will succeed you know sitting

1068
00:37:12,640 --> 00:37:14,880
to one and look at return the old valley

1069
00:37:14,880 --> 00:37:17,040
zero so it knows that you know nobody

1070
00:37:17,040 --> 00:37:18,560
else succeeded actually in writing the

1071
00:37:18,560 --> 00:37:19,520
flag to one yet

1072
00:37:19,520 --> 00:37:21,200
and therefore you know i should become

1073
00:37:21,200 --> 00:37:23,280
the primaries to keep it running

1074
00:37:23,280 --> 00:37:24,800
and the second guy you know what's the

1075
00:37:24,800 --> 00:37:26,560
primary the backup you know that

1076
00:37:26,560 --> 00:37:28,400
uh comes in second you know we'll see

1077
00:37:28,400 --> 00:37:30,000
you will try to set the flag to one it's

1078
00:37:30,000 --> 00:37:31,520
already set to one the return value

1079
00:37:31,520 --> 00:37:32,880
would be one because that was the old

1080
00:37:32,880 --> 00:37:33,680
value

1081
00:37:33,680 --> 00:37:35,599
by the time it you know did this test

1082
00:37:35,599 --> 00:37:37,599
operation and therefore it will decide

1083
00:37:37,599 --> 00:37:38,880
well i'm just going to give up

1084
00:37:38,880 --> 00:37:40,960
uh because you know there's already

1085
00:37:40,960 --> 00:37:43,760
somebody else who took over from me

1086
00:37:43,760 --> 00:37:45,359
and basically you know as the paper

1087
00:37:45,359 --> 00:37:49,920
calls up you know it terminates itself

1088
00:37:49,920 --> 00:37:50,880
okay

1089
00:37:50,880 --> 00:37:53,280
so that's sort of the high level uh

1090
00:37:53,280 --> 00:37:54,079
operation

1091
00:37:54,079 --> 00:37:57,440
uh uh uh the high level operation for

1092
00:37:57,440 --> 00:37:58,640
failure there's a

1093
00:37:58,640 --> 00:38:00,400
question in the uh chat which is a good

1094
00:38:00,400 --> 00:38:02,240
question and when does the flag reset to

1095
00:38:02,240 --> 00:38:03,440
zero

1096
00:38:03,440 --> 00:38:05,119
well there's sort of basically a whole

1097
00:38:05,119 --> 00:38:06,800
separate story that i haven't talked

1098
00:38:06,800 --> 00:38:07,359
about yet

1099
00:38:07,359 --> 00:38:09,520
and you know so you'll get through uh is

1100
00:38:09,520 --> 00:38:11,680
that in once you know the primary runs

1101
00:38:11,680 --> 00:38:12,240
on

1102
00:38:12,240 --> 00:38:14,880
like one we have one server running now

1103
00:38:14,880 --> 00:38:17,359
i would like to make a second backup you

1104
00:38:17,359 --> 00:38:17,680
know

1105
00:38:17,680 --> 00:38:19,040
and so get in the position that we

1106
00:38:19,040 --> 00:38:20,400
basically have to back up again you know

1107
00:38:20,400 --> 00:38:21,839
we have to do what's called repair

1108
00:38:21,839 --> 00:38:23,839
because if we don't do repair then you

1109
00:38:23,839 --> 00:38:25,599
know the we start every two computers

1110
00:38:25,599 --> 00:38:27,359
one fails then we have one computer and

1111
00:38:27,359 --> 00:38:28,720
a little bit later that one computer may

1112
00:38:28,720 --> 00:38:30,560
fail then we have no computers anymore

1113
00:38:30,560 --> 00:38:31,920
and so it has to be the case there has

1114
00:38:31,920 --> 00:38:33,599
to be some repair plan

1115
00:38:33,599 --> 00:38:36,480
and in you know dmvt this repair plan is

1116
00:38:36,480 --> 00:38:38,480
executed manually you know so somebody

1117
00:38:38,480 --> 00:38:41,680
you know monitors where the the monitor

1118
00:38:41,680 --> 00:38:44,079
software uh sort of notice this and

1119
00:38:44,079 --> 00:38:47,280
basically creates then a new replica

1120
00:38:47,280 --> 00:38:49,839
or based on the vm image of the the

1121
00:38:49,839 --> 00:38:50,800
first one

1122
00:38:50,800 --> 00:38:54,000
uh ensures that it's in sync and then

1123
00:38:54,000 --> 00:38:54,480
you know

1124
00:38:54,480 --> 00:38:58,720
it uh resets that flag and you know and

1125
00:38:58,720 --> 00:39:00,320
it's the logging starts again and then

1126
00:39:00,320 --> 00:39:02,000
you know the flag is reset so

1127
00:39:02,000 --> 00:39:03,520
once that second primary is completely

1128
00:39:03,520 --> 00:39:05,359
back up

1129
00:39:05,359 --> 00:39:08,240
and following the protocol then the flag

1130
00:39:08,240 --> 00:39:09,599
can be reset

1131
00:39:09,599 --> 00:39:13,510
okay

1132
00:39:13,520 --> 00:39:17,430
okay uh

1133
00:39:17,440 --> 00:39:18,800
okay good that's a great question like

1134
00:39:18,800 --> 00:39:21,040
you know why maybe the logging channel

1135
00:39:21,040 --> 00:39:21,839
broke but maybe

1136
00:39:21,839 --> 00:39:26,079
the the the the

1137
00:39:26,079 --> 00:39:28,640
the channel to the server broke too and

1138
00:39:28,640 --> 00:39:29,280
uh

1139
00:39:29,280 --> 00:39:30,880
and so you know we're not going to get

1140
00:39:30,880 --> 00:39:32,640
the response and that

1141
00:39:32,640 --> 00:39:33,920
basically that point the system just

1142
00:39:33,920 --> 00:39:36,400
stops if you will until something

1143
00:39:36,400 --> 00:39:37,440
repairs

1144
00:39:37,440 --> 00:39:38,960
uh because nothing can be done so at

1145
00:39:38,960 --> 00:39:40,320
that point from then on no clients

1146
00:39:40,320 --> 00:39:42,160
requests are actually processed

1147
00:39:42,160 --> 00:39:44,400
uh because we just don't know what state

1148
00:39:44,400 --> 00:39:46,160
we are

1149
00:39:46,160 --> 00:39:47,760
and maybe at some point network link

1150
00:39:47,760 --> 00:39:49,200
will get uh

1151
00:39:49,200 --> 00:39:50,800
repaired and then point you know things

1152
00:39:50,800 --> 00:39:52,560
get started moving forward again

1153
00:39:52,560 --> 00:39:54,240
so that's sort of the disaster case

1154
00:39:54,240 --> 00:39:56,640
right where the you know disaster cases

1155
00:39:56,640 --> 00:39:58,320
actually the primary backup are

1156
00:39:58,320 --> 00:39:59,599
both actually up and running by all the

1157
00:39:59,599 --> 00:40:01,839
network tables of broken and which is

1158
00:40:01,839 --> 00:40:03,280
sort of similar basically to the case

1159
00:40:03,280 --> 00:40:04,720
where both the primary and backup failed

1160
00:40:04,720 --> 00:40:08,950
at the same time

1161
00:40:08,960 --> 00:40:11,920
okay question yeah could you explain

1162
00:40:11,920 --> 00:40:12,880
again real quick

1163
00:40:12,880 --> 00:40:14,880
when the client is reading from the

1164
00:40:14,880 --> 00:40:16,400
storage server

1165
00:40:16,400 --> 00:40:17,680
the client never reaches really from the

1166
00:40:17,680 --> 00:40:19,599
store server that's the

1167
00:40:19,599 --> 00:40:22,000
uh linux that might or the application

1168
00:40:22,000 --> 00:40:23,359
running on top of linux might be running

1169
00:40:23,359 --> 00:40:24,400
from the storage server

1170
00:40:24,400 --> 00:40:25,760
and that's the one case in the second

1171
00:40:25,760 --> 00:40:28,160
case the mft might be running from the

1172
00:40:28,160 --> 00:40:29,920
storage server to read that slack or

1173
00:40:29,920 --> 00:40:32,079
test and set that flag so that like

1174
00:40:32,079 --> 00:40:33,359
green arrow at the bottom from the

1175
00:40:33,359 --> 00:40:34,480
storage server to

1176
00:40:34,480 --> 00:40:38,079
see is uh

1177
00:40:38,079 --> 00:40:41,599
oh ah sorry not green that's a bad green

1178
00:40:41,599 --> 00:40:43,040
arrow that should have gone like all the

1179
00:40:43,040 --> 00:40:43,599
way

1180
00:40:43,599 --> 00:40:45,599
oh okay thank you it's just going over

1181
00:40:45,599 --> 00:40:47,040
the network and not intended to go to

1182
00:40:47,040 --> 00:40:48,160
see it was intended to go over the

1183
00:40:48,160 --> 00:40:49,839
network

1184
00:40:49,839 --> 00:40:52,319
thanks for clarifying that i hadn't

1185
00:40:52,319 --> 00:40:53,359
realized that

1186
00:40:53,359 --> 00:40:56,800
okay so um

1187
00:40:56,800 --> 00:40:59,359
so what i'd like so i want to maybe take

1188
00:40:59,359 --> 00:41:00,000
a

1189
00:41:00,000 --> 00:41:02,880
quick uh break at this point or do a

1190
00:41:02,880 --> 00:41:04,000
breakout room

1191
00:41:04,000 --> 00:41:06,160
uh in particular i would like you to do

1192
00:41:06,160 --> 00:41:07,680
is talk a little bit about the homework

1193
00:41:07,680 --> 00:41:08,560
question

1194
00:41:08,560 --> 00:41:11,520
uh which we sort of you know covered uh

1195
00:41:11,520 --> 00:41:12,640
at this instance

1196
00:41:12,640 --> 00:41:15,829
uh but i want you to think about

1197
00:41:15,839 --> 00:41:17,839
understand or argue with each other and

1198
00:41:17,839 --> 00:41:19,200
you know convince yourself that the

1199
00:41:19,200 --> 00:41:20,319
scheme actually

1200
00:41:20,319 --> 00:41:24,079
provides uh avoids this sort of um

1201
00:41:24,079 --> 00:41:25,839
range you know split brain syndrome in

1202
00:41:25,839 --> 00:41:27,119
the sense that there's never

1203
00:41:27,119 --> 00:41:29,040
going to be two primaries and the second

1204
00:41:29,040 --> 00:41:30,880
thing you know maybe to debate

1205
00:41:30,880 --> 00:41:33,040
is is this a reasonable design because

1206
00:41:33,040 --> 00:41:34,480
it looks like you know what we've done

1207
00:41:34,480 --> 00:41:35,920
is like we pushed all the sort of real

1208
00:41:35,920 --> 00:41:37,520
hard part of default towels into the

1209
00:41:37,520 --> 00:41:38,960
storage server and it's not really the

1210
00:41:38,960 --> 00:41:40,720
case or is that not the case

1211
00:41:40,720 --> 00:41:42,720
uh so that seems like a two things that

1212
00:41:42,720 --> 00:41:44,560
i would like you to discuss

1213
00:41:44,560 --> 00:41:46,400
uh in these breakout rooms so i'm gonna

1214
00:41:46,400 --> 00:41:51,109
stop the sharing

1215
00:41:51,119 --> 00:41:54,790
and i'm going to

1216
00:41:54,800 --> 00:41:57,440
participants and i'm going to make lily

1217
00:41:57,440 --> 00:41:59,040
post

1218
00:41:59,040 --> 00:42:01,119
so that you can set up the breakout

1219
00:42:01,119 --> 00:42:03,359
rooms

1220
00:42:03,359 --> 00:42:08,150
and enjoy you know talking to each other

1221
00:42:08,160 --> 00:46:19,430
lately you got this under control

1222
00:46:19,440 --> 00:46:21,280
testing to see if i can uh join a

1223
00:46:21,280 --> 00:46:28,400
different room this time not looking

1224
00:46:28,400 --> 00:46:54,829
good though

1225
00:46:54,839 --> 00:47:04,069
uh

1226
00:47:04,079 --> 00:49:00,829
well yes i'm stuck here

1227
00:49:00,839 --> 00:49:54,630
good

1228
00:49:54,640 --> 00:50:00,790
the screen again

1229
00:50:00,800 --> 00:50:06,230
okay everybody from the screen

1230
00:50:06,240 --> 00:50:09,520
yes okay good um

1231
00:50:09,520 --> 00:50:11,680
so i hope you had a good discussion and

1232
00:50:11,680 --> 00:50:12,960
hopefully met some more

1233
00:50:12,960 --> 00:50:15,920
uh new students in the class uh than uh

1234
00:50:15,920 --> 00:50:17,599
than you knew before

1235
00:50:17,599 --> 00:50:20,319
and uh let's sort of proceed uh talking

1236
00:50:20,319 --> 00:50:21,200
a little bit about

1237
00:50:21,200 --> 00:50:25,280
uh the the design of uh

1238
00:50:25,280 --> 00:50:28,559
uh off at the mpt and just like

1239
00:50:28,559 --> 00:50:30,400
summarize quickly you know this could

1240
00:50:30,400 --> 00:50:32,160
you repeat like

1241
00:50:32,160 --> 00:50:34,160
when the flag is reset to zero i feel

1242
00:50:34,160 --> 00:50:35,520
like some of us might have missed the

1243
00:50:35,520 --> 00:50:36,559
explanation

1244
00:50:36,559 --> 00:50:39,920
okay uh okay so okay good good good good

1245
00:50:39,920 --> 00:50:41,200
okay so

1246
00:50:41,200 --> 00:50:42,800
okay so here let's draw the picture

1247
00:50:42,800 --> 00:50:45,119
again uh in a sort of simpler way

1248
00:50:45,119 --> 00:50:47,520
here's our primary with the vm

1249
00:50:47,520 --> 00:50:49,680
everything in it here's the backup

1250
00:50:49,680 --> 00:50:51,520
with the everything in it you know and

1251
00:50:51,520 --> 00:50:53,359
there's the login channel in between

1252
00:50:53,359 --> 00:50:55,040
they're connected you know to a storage

1253
00:50:55,040 --> 00:50:56,400
server and

1254
00:50:56,400 --> 00:50:57,680
you know one thing to think about is

1255
00:50:57,680 --> 00:50:59,119
that the storage server is doing playing

1256
00:50:59,119 --> 00:51:01,119
tool roles so let's

1257
00:51:01,119 --> 00:51:03,119
separate the two roles one is given the

1258
00:51:03,119 --> 00:51:04,400
storage you know for

1259
00:51:04,400 --> 00:51:06,400
you know a disk basically for you know

1260
00:51:06,400 --> 00:51:07,599
the primary and the backup

1261
00:51:07,599 --> 00:51:09,040
and then look we could just split that

1262
00:51:09,040 --> 00:51:10,960
and just attach the disk to the primary

1263
00:51:10,960 --> 00:51:11,839
backup

1264
00:51:11,839 --> 00:51:14,480
and then we basically have the role here

1265
00:51:14,480 --> 00:51:20,390
is really the arbitration server

1266
00:51:20,400 --> 00:51:23,839
and it has a flag

1267
00:51:23,839 --> 00:51:26,079
and the flag is initially zero right and

1268
00:51:26,079 --> 00:51:28,319
so now let's say there's a

1269
00:51:28,319 --> 00:51:30,160
partition of primary backup can actually

1270
00:51:30,160 --> 00:51:32,400
not uh talk to the

1271
00:51:32,400 --> 00:51:33,520
to each other anymore so they're going

1272
00:51:33,520 --> 00:51:34,800
to talk to the arbitration server

1273
00:51:34,800 --> 00:51:37,040
basically to try to promote themselves

1274
00:51:37,040 --> 00:51:38,079
through the single

1275
00:51:38,079 --> 00:51:40,720
uh to go live and sort of be the single

1276
00:51:40,720 --> 00:51:43,280
server that serves the client request

1277
00:51:43,280 --> 00:51:44,960
so they both sent the packet to do a

1278
00:51:44,960 --> 00:51:46,640
test to set operation

1279
00:51:46,640 --> 00:51:48,240
one gets a zero back the other one gets

1280
00:51:48,240 --> 00:51:49,760
a one back the one that gets one back

1281
00:51:49,760 --> 00:51:51,359
knows that it was actually the second

1282
00:51:51,359 --> 00:51:52,319
who tried

1283
00:51:52,319 --> 00:51:55,359
and then uh and so the first one will

1284
00:51:55,359 --> 00:51:55,839
succeed

1285
00:51:55,839 --> 00:51:57,280
and will go live so let's say this guy

1286
00:51:57,280 --> 00:51:59,760
goes live and this guy just you know

1287
00:51:59,760 --> 00:52:01,200
disappears

1288
00:52:01,200 --> 00:52:03,520
this virtual machine is terminates

1289
00:52:03,520 --> 00:52:04,800
itself and

1290
00:52:04,800 --> 00:52:08,319
is done and so now the flag is set to

1291
00:52:08,319 --> 00:52:11,829
one

1292
00:52:11,839 --> 00:52:13,040
and of course now at this point there's

1293
00:52:13,040 --> 00:52:14,480
no arbitration in necessary anymore

1294
00:52:14,480 --> 00:52:16,480
because there's no secondary replica

1295
00:52:16,480 --> 00:52:18,400
there's no backup at all so really the

1296
00:52:18,400 --> 00:52:19,839
question is like you know what happens

1297
00:52:19,839 --> 00:52:20,640
next

1298
00:52:20,640 --> 00:52:22,400
and in terms of repair that has to be

1299
00:52:22,400 --> 00:52:24,160
the case that the second backup the new

1300
00:52:24,160 --> 00:52:25,680
backup is brought up to the light

1301
00:52:25,680 --> 00:52:26,319
correct and

1302
00:52:26,319 --> 00:52:28,400
this section 31 of the paper talks about

1303
00:52:28,400 --> 00:52:30,160
this in quite a bit of detail

1304
00:52:30,160 --> 00:52:32,960
and the way it works is that you know on

1305
00:52:32,960 --> 00:52:34,480
the user interface you know through the

1306
00:52:34,480 --> 00:52:36,559
system you know vmware motion

1307
00:52:36,559 --> 00:52:38,079
uh you're basically saying like hey i

1308
00:52:38,079 --> 00:52:39,680
want to clone this primary

1309
00:52:39,680 --> 00:52:43,119
and uh the cloning operation uh

1310
00:52:43,119 --> 00:52:46,960
basically will we'll basically stop

1311
00:52:46,960 --> 00:52:49,839
processing pioneering during cloning the

1312
00:52:49,839 --> 00:52:50,319
the

1313
00:52:50,319 --> 00:52:52,160
the primary won't actually work the one

1314
00:52:52,160 --> 00:52:53,760
system still running won't actually

1315
00:52:53,760 --> 00:52:55,359
serve any client requests

1316
00:52:55,359 --> 00:52:59,119
the uh the the emotion thing

1317
00:52:59,119 --> 00:53:02,640
makes a vm clone and basically copies

1318
00:53:02,640 --> 00:53:04,960
you know the state of this vm up to the

1319
00:53:04,960 --> 00:53:07,280
backup and so here we have an identical

1320
00:53:07,280 --> 00:53:09,280
uh copy of the backup of the primary

1321
00:53:09,280 --> 00:53:10,720
that becomes the backup

1322
00:53:10,720 --> 00:53:12,720
and so this state of the virtual machine

1323
00:53:12,720 --> 00:53:14,079
is identical

1324
00:53:14,079 --> 00:53:15,760
once you know the sort of this cloning

1325
00:53:15,760 --> 00:53:17,280
operation has happened

1326
00:53:17,280 --> 00:53:19,520
then again it's free you know the the

1327
00:53:19,520 --> 00:53:21,440
the user interface is free to set that

1328
00:53:21,440 --> 00:53:24,640
this guy back to zero two client

1329
00:53:24,640 --> 00:53:26,800
requests are still not being processed

1330
00:53:26,800 --> 00:53:28,559
when that has actually happened then the

1331
00:53:28,559 --> 00:53:30,319
system can go sort of live again

1332
00:53:30,319 --> 00:53:32,880
but now with two machines with a primary

1333
00:53:32,880 --> 00:53:33,680
and a backup

1334
00:53:33,680 --> 00:53:34,960
and the client requests are being

1335
00:53:34,960 --> 00:53:36,319
processed you know they're send over the

1336
00:53:36,319 --> 00:53:36,960
channel

1337
00:53:36,960 --> 00:53:40,079
etc etc so we're back in business does

1338
00:53:40,079 --> 00:53:47,750
that answer the question

1339
00:53:47,760 --> 00:53:50,800
i hope it does if not i'm happy to

1340
00:53:50,800 --> 00:53:52,640
uh revisit this actually maybe at the

1341
00:53:52,640 --> 00:53:54,839
end of the lecture if they're still

1342
00:53:54,839 --> 00:53:57,040
confusing

1343
00:53:57,040 --> 00:53:59,680
okay good um okay well i want to go back

1344
00:53:59,680 --> 00:54:01,440
now to sort of this sort of like the

1345
00:54:01,440 --> 00:54:03,920
overall architecture of the system i now

1346
00:54:03,920 --> 00:54:04,559
want to

1347
00:54:04,559 --> 00:54:07,680
dive in a little bit more and uh talk uh

1348
00:54:07,680 --> 00:54:08,960
you know we have decided i think you

1349
00:54:08,960 --> 00:54:10,319
know that you know this arbitration

1350
00:54:10,319 --> 00:54:11,920
scheme allows you to at least avoid a

1351
00:54:11,920 --> 00:54:13,359
split brainstorm

1352
00:54:13,359 --> 00:54:15,200
uh but you know the surge is still this

1353
00:54:15,200 --> 00:54:16,960
larger issue that if you know two

1354
00:54:16,960 --> 00:54:18,559
machines are running

1355
00:54:18,559 --> 00:54:22,710
uh you know our goal is going to be

1356
00:54:22,720 --> 00:54:24,240
you know basically behave like a single

1357
00:54:24,240 --> 00:54:29,829
machine

1358
00:54:29,839 --> 00:54:31,359
so from the client perspective it should

1359
00:54:31,359 --> 00:54:33,200
not be possible to really

1360
00:54:33,200 --> 00:54:35,920
discern or at least you know sort of

1361
00:54:35,920 --> 00:54:37,200
demonstrate a bad way

1362
00:54:37,200 --> 00:54:38,559
that you know we're actually having two

1363
00:54:38,559 --> 00:54:40,559
machines right

1364
00:54:40,559 --> 00:54:42,640
and so there's usually take a step back

1365
00:54:42,640 --> 00:54:44,799
you know we can get at a very high level

1366
00:54:44,799 --> 00:54:46,799
you know we have here our primary in the

1367
00:54:46,799 --> 00:54:48,799
house you know like machine registers

1368
00:54:48,799 --> 00:54:49,839
the virtual machine

1369
00:54:49,839 --> 00:54:52,079
uh you know some registers there's

1370
00:54:52,079 --> 00:54:53,040
memory

1371
00:54:53,040 --> 00:54:55,440
and our basic plan is to you know sort

1372
00:54:55,440 --> 00:54:56,880
of forward you know make sure that

1373
00:54:56,880 --> 00:54:58,640
basically it executes exactly the same

1374
00:54:58,640 --> 00:55:01,589
instructions

1375
00:55:01,599 --> 00:55:05,280
uh boom boom boom here's our own

1376
00:55:05,280 --> 00:55:08,640
here's our backup here's a primary

1377
00:55:08,640 --> 00:55:11,280
and you know basically you know when the

1378
00:55:11,280 --> 00:55:12,240
uh

1379
00:55:12,240 --> 00:55:14,720
uh you know when the primary so we start

1380
00:55:14,720 --> 00:55:15,920
the map in the same state

1381
00:55:15,920 --> 00:55:17,520
and they start executing instructions

1382
00:55:17,520 --> 00:55:18,640
you know so like maybe the first

1383
00:55:18,640 --> 00:55:20,079
instructor is an ink

1384
00:55:20,079 --> 00:55:22,640
the second instructions in deck you know

1385
00:55:22,640 --> 00:55:24,880
through the structure is a branch

1386
00:55:24,880 --> 00:55:26,960
and if they you know start all in the

1387
00:55:26,960 --> 00:55:28,559
same state correct then at the first

1388
00:55:28,559 --> 00:55:30,000
destruction just branch they will branch

1389
00:55:30,000 --> 00:55:31,280
in the same direction

1390
00:55:31,280 --> 00:55:32,880
and so maybe the brands do some

1391
00:55:32,880 --> 00:55:34,880
instruction and and you know whatever

1392
00:55:34,880 --> 00:55:37,280
the next instructions in the divide

1393
00:55:37,280 --> 00:55:40,160
et cetera et cetera now all these

1394
00:55:40,160 --> 00:55:40,960
instructions are

1395
00:55:40,960 --> 00:55:42,559
deterministic so that's they're pretty

1396
00:55:42,559 --> 00:55:44,319
straightforward right like if you know

1397
00:55:44,319 --> 00:55:45,920
we both start at the same style

1398
00:55:45,920 --> 00:55:48,000
state they execute exactly these you

1399
00:55:48,000 --> 00:55:50,079
know the same set of instructions in the

1400
00:55:50,079 --> 00:55:50,960
same order

1401
00:55:50,960 --> 00:55:52,960
then we're going to end up in a state s

1402
00:55:52,960 --> 00:55:54,000
prime

1403
00:55:54,000 --> 00:55:55,760
and those two states are going to be

1404
00:55:55,760 --> 00:55:57,520
identical

1405
00:55:57,520 --> 00:56:00,880
right now the thing that is sort of the

1406
00:56:00,880 --> 00:56:01,680
challenge

1407
00:56:01,680 --> 00:56:04,960
in uh this design or like any sort of

1408
00:56:04,960 --> 00:56:06,480
replication scheme is

1409
00:56:06,480 --> 00:56:08,720
there might be sources of divergence you

1410
00:56:08,720 --> 00:56:10,640
know so our goal is to actually get them

1411
00:56:10,640 --> 00:56:12,079
exactly to the same

1412
00:56:12,079 --> 00:56:14,559
uh state as prime but you know they're

1413
00:56:14,559 --> 00:56:15,440
sort of

1414
00:56:15,440 --> 00:56:22,710
sources of divergence

1415
00:56:22,720 --> 00:56:24,640
and it's pretty good obviously what

1416
00:56:24,640 --> 00:56:25,760
those are you know for example

1417
00:56:25,760 --> 00:56:26,559
instructions

1418
00:56:26,559 --> 00:56:35,270
that are non-deterministic our problem

1419
00:56:35,280 --> 00:56:37,440
and so what are what is an example of a

1420
00:56:37,440 --> 00:56:42,390
non-deterministic instruction

1421
00:56:42,400 --> 00:56:44,880
getting the time yeah getting the time

1422
00:56:44,880 --> 00:56:47,280
why is that non-dehumanistic

1423
00:56:47,280 --> 00:56:50,799
because and

1424
00:56:50,799 --> 00:56:53,520
the machines are not like the backup is

1425
00:56:53,520 --> 00:57:00,870
not executing

1426
00:57:00,880 --> 00:57:02,799
the issue here correct is that if you

1427
00:57:02,799 --> 00:57:05,280
know the primary and the backup you know

1428
00:57:05,280 --> 00:57:06,559
at some point they'll execute this you

1429
00:57:06,559 --> 00:57:06,880
know

1430
00:57:06,880 --> 00:57:08,880
get time of day instruction if you will

1431
00:57:08,880 --> 00:57:10,720
and they might not execute it exactly at

1432
00:57:10,720 --> 00:57:12,799
the same time so the values returned

1433
00:57:12,799 --> 00:57:14,000
you know by that instruction is going to

1434
00:57:14,000 --> 00:57:16,319
be different right so

1435
00:57:16,319 --> 00:57:20,000
that's an uh source of potential source

1436
00:57:20,000 --> 00:57:21,760
of the

1437
00:57:21,760 --> 00:57:24,240
divergence that we need to control in

1438
00:57:24,240 --> 00:57:25,839
fact we basically have to turn every

1439
00:57:25,839 --> 00:57:27,599
non-deterministic instruction into the

1440
00:57:27,599 --> 00:57:29,359
deterministic instruction now we'll see

1441
00:57:29,359 --> 00:57:30,640
a second here and how does

1442
00:57:30,640 --> 00:57:33,839
how could that be done similarly uh

1443
00:57:33,839 --> 00:57:36,640
inputs right or packet inputs like when

1444
00:57:36,640 --> 00:57:38,400
a packet arrives over the network

1445
00:57:38,400 --> 00:57:41,200
you know at the primary uh you know we

1446
00:57:41,200 --> 00:57:43,359
got to make sure the you know the

1447
00:57:43,359 --> 00:57:45,119
that the package is executed or

1448
00:57:45,119 --> 00:57:46,400
processed or

1449
00:57:46,400 --> 00:57:48,000
the the interrupt that goes along with

1450
00:57:48,000 --> 00:57:50,000
that packet is exactly delivered at

1451
00:57:50,000 --> 00:57:51,280
exactly the same point in the

1452
00:57:51,280 --> 00:57:52,319
instructions team

1453
00:57:52,319 --> 00:57:54,400
right so we go back our previous paper

1454
00:57:54,400 --> 00:57:55,440
the day page

1455
00:57:55,440 --> 00:57:56,799
and like you know the backup's also

1456
00:57:56,799 --> 00:57:59,040
executing these instructions

1457
00:57:59,040 --> 00:58:01,520
and deck blah blah blah blah and exactly

1458
00:58:01,520 --> 00:58:02,319
in the same order

1459
00:58:02,319 --> 00:58:04,400
so if the primary for example you know

1460
00:58:04,400 --> 00:58:05,920
we get the you know the interrupt is

1461
00:58:05,920 --> 00:58:07,359
delivered between instruction one and

1462
00:58:07,359 --> 00:58:09,040
two we got to make sure that at the

1463
00:58:09,040 --> 00:58:09,760
backup it

1464
00:58:09,760 --> 00:58:11,839
also is delivered between one and two

1465
00:58:11,839 --> 00:58:13,440
because if it's delivered exactly in the

1466
00:58:13,440 --> 00:58:13,839
same

1467
00:58:13,839 --> 00:58:16,000
uh point in the instruction stream the

1468
00:58:16,000 --> 00:58:17,599
interrupt handler will run and it will

1469
00:58:17,599 --> 00:58:18,400
you know

1470
00:58:18,400 --> 00:58:19,599
they both will execute the same

1471
00:58:19,599 --> 00:58:23,200
instructions again however if you know

1472
00:58:23,200 --> 00:58:24,880
example the backup

1473
00:58:24,880 --> 00:58:26,640
you know would process you know this

1474
00:58:26,640 --> 00:58:28,079
timer interrupt you know where this

1475
00:58:28,079 --> 00:58:29,520
impacted arrival interrupted a little

1476
00:58:29,520 --> 00:58:30,240
bit later

1477
00:58:30,240 --> 00:58:31,440
in a different side of the stream then

1478
00:58:31,440 --> 00:58:32,799
the state of the system might be

1479
00:58:32,799 --> 00:58:33,359
different

1480
00:58:33,359 --> 00:58:34,880
and therefore the result of that you

1481
00:58:34,880 --> 00:58:36,400
know computation might be different and

1482
00:58:36,400 --> 00:58:38,079
so we can't have that so it has to be

1483
00:58:38,079 --> 00:58:38,880
the case

1484
00:58:38,880 --> 00:58:41,359
that in interrupts whether it's packets

1485
00:58:41,359 --> 00:58:42,160
or timers

1486
00:58:42,160 --> 00:58:44,079
all get delivered exactly at the same

1487
00:58:44,079 --> 00:58:46,480
time and the same put in the instruction

1488
00:58:46,480 --> 00:58:47,119
stream

1489
00:58:47,119 --> 00:58:50,480
so input packets

1490
00:58:50,480 --> 00:58:56,470
or timer interrupts

1491
00:58:56,480 --> 00:58:57,839
need to basically be delivered at the

1492
00:58:57,839 --> 00:59:00,640
same point in the instruction stream

1493
00:59:00,640 --> 00:59:04,000
um and so those are the sources

1494
00:59:04,000 --> 00:59:06,240
of divergence uh that we need to handle

1495
00:59:06,240 --> 00:59:09,359
any other source of diversions that

1496
00:59:09,359 --> 00:59:11,680
um so i can like i think it was

1497
00:59:11,680 --> 00:59:12,880
mentioned in the paper that

1498
00:59:12,880 --> 00:59:14,160
concurrency also can produce

1499
00:59:14,160 --> 00:59:16,000
non-determinism but uh

1500
00:59:16,000 --> 00:59:17,359
from my understanding here since the

1501
00:59:17,359 --> 00:59:18,880
hypervisor actually controls the

1502
00:59:18,880 --> 00:59:19,599
interrupts

1503
00:59:19,599 --> 00:59:21,680
and since we have a uni processor

1504
00:59:21,680 --> 00:59:22,799
wouldn't the thread

1505
00:59:22,799 --> 00:59:24,640
switch be conducted through the

1506
00:59:24,640 --> 00:59:26,000
hypervisor by by

1507
00:59:26,000 --> 00:59:27,440
interrupts so if we control the

1508
00:59:27,440 --> 00:59:29,359
interrupts and we can transmit them

1509
00:59:29,359 --> 00:59:30,000
exactly

1510
00:59:30,000 --> 00:59:32,799
at the right location wouldn't we also

1511
00:59:32,799 --> 00:59:34,319
uh control the non-determinism from

1512
00:59:34,319 --> 00:59:35,359
concurrency

1513
00:59:35,359 --> 00:59:36,720
yeah so i think there's a great

1514
00:59:36,720 --> 00:59:38,640
observation so let me it's a

1515
00:59:38,640 --> 00:59:40,400
potential divorce okay so first of all

1516
00:59:40,400 --> 00:59:41,920
let's first agree that it's a potential

1517
00:59:41,920 --> 00:59:43,440
source of the uh

1518
00:59:43,440 --> 00:59:48,950
uh divergence so multi-core

1519
00:59:48,960 --> 00:59:51,359
and let's say you know basically the way

1520
00:59:51,359 --> 00:59:52,559
the solution

1521
00:59:52,559 --> 00:59:54,240
in this particular paper to avoid this

1522
00:59:54,240 --> 00:59:55,599
problem is to say like well

1523
00:59:55,599 --> 00:59:58,630
just disallow

1524
00:59:58,640 --> 01:00:00,559
we're not allowed to have that and so

1525
01:00:00,559 --> 01:00:02,000
just only unit processors

1526
01:00:02,000 --> 01:00:05,040
but let's say we had multi-core and you

1527
01:00:05,040 --> 01:00:05,520
know what

1528
01:00:05,520 --> 01:00:06,559
just to make sure that we understand

1529
01:00:06,559 --> 01:00:08,319
what the issue is the issue here is

1530
01:00:08,319 --> 01:00:09,119
correct we have

1531
01:00:09,119 --> 01:00:10,640
two threads running on the same

1532
01:00:10,640 --> 01:00:12,240
processor

1533
01:00:12,240 --> 01:00:14,960
with them different cores and they erase

1534
01:00:14,960 --> 01:00:15,839
for example to

1535
01:00:15,839 --> 01:00:18,720
grab a walk and one of them is going to

1536
01:00:18,720 --> 01:00:19,280
win

1537
01:00:19,280 --> 01:00:20,720
and so that that's the threat that's

1538
01:00:20,720 --> 01:00:22,400
going to run next and the other one is

1539
01:00:22,400 --> 01:00:24,160
going to be stopped for a little while

1540
01:00:24,160 --> 01:00:25,599
if we want to do this replicated state

1541
01:00:25,599 --> 01:00:27,119
machine approach at the back up the same

1542
01:00:27,119 --> 01:00:28,000
thing would have to have

1543
01:00:28,000 --> 01:00:30,000
happened right where if the two threads

1544
01:00:30,000 --> 01:00:31,119
run you know

1545
01:00:31,119 --> 01:00:33,280
race for that lock at the same time then

1546
01:00:33,280 --> 01:00:34,799
we got to be arranged that the

1547
01:00:34,799 --> 01:00:36,400
whatever winner on the primary is also

1548
01:00:36,400 --> 01:00:38,240
the winner on the backup

1549
01:00:38,240 --> 01:00:40,079
and so that requires a whole bunch of

1550
01:00:40,079 --> 01:00:41,599
machinery uh

1551
01:00:41,599 --> 01:00:43,520
that you know additional machinery or

1552
01:00:43,520 --> 01:00:45,280
complexities that the you know the paper

1553
01:00:45,280 --> 01:00:46,640
clearly didn't want to address or didn't

1554
01:00:46,640 --> 01:00:48,480
know how to address and basically

1555
01:00:48,480 --> 01:00:50,000
said like okay we're just gonna exclude

1556
01:00:50,000 --> 01:00:52,319
that uh possibility of divergence by

1557
01:00:52,319 --> 01:00:53,359
just declaring

1558
01:00:53,359 --> 01:00:55,440
that the process is a unique processing

1559
01:00:55,440 --> 01:00:56,880
and so then thread switching and all

1560
01:00:56,880 --> 01:00:57,839
that kind of stuff doesn't matter

1561
01:00:57,839 --> 01:00:59,280
anymore there's always one you know

1562
01:00:59,280 --> 01:01:00,720
computation running on the computer on

1563
01:01:00,720 --> 01:01:01,760
the processor

1564
01:01:01,760 --> 01:01:03,599
and it will switch you know if the

1565
01:01:03,599 --> 01:01:05,200
primary switches to a different thread

1566
01:01:05,200 --> 01:01:07,280
the backup will switch also to the same

1567
01:01:07,280 --> 01:01:08,400
different thread because it's like a

1568
01:01:08,400 --> 01:01:09,760
single instruction screen

1569
01:01:09,760 --> 01:01:11,359
and they get their external inputs

1570
01:01:11,359 --> 01:01:15,510
exactly at the same time

1571
01:01:15,520 --> 01:01:18,480
that make sense so in some ways and it's

1572
01:01:18,480 --> 01:01:19,599
a little bit lame you know they're just

1573
01:01:19,599 --> 01:01:21,839
give up on multi-core

1574
01:01:21,839 --> 01:01:25,119
and as i mentioned later systems uh

1575
01:01:25,119 --> 01:01:27,119
the more recent systems of this uh

1576
01:01:27,119 --> 01:01:29,599
product do handle multi-core

1577
01:01:29,599 --> 01:01:33,200
and you know and i don't have time to i

1578
01:01:33,200 --> 01:01:33,839
don't actually

1579
01:01:33,839 --> 01:01:35,119
understand exactly how they do it

1580
01:01:35,119 --> 01:01:36,799
there's a potential difference uh

1581
01:01:36,799 --> 01:01:38,160
potentially different schemes that you

1582
01:01:38,160 --> 01:01:39,839
could think of doing uh

1583
01:01:39,839 --> 01:01:42,640
people have done uh multi-core replay

1584
01:01:42,640 --> 01:01:43,359
which is really what's

1585
01:01:43,359 --> 01:01:45,599
the thing that is necessary so uh but i

1586
01:01:45,599 --> 01:01:46,720
don't really know exactly so i'm not

1587
01:01:46,720 --> 01:01:48,160
going to talk about that at all

1588
01:01:48,160 --> 01:01:49,359
i'm just going to talk about that

1589
01:01:49,359 --> 01:01:52,079
focusing on the first three items

1590
01:01:52,079 --> 01:01:58,230
and see how they handle it in this case

1591
01:01:58,240 --> 01:02:02,630
okay any questions

1592
01:02:02,640 --> 01:02:04,880
oh sorry just to make sure it only

1593
01:02:04,880 --> 01:02:06,480
transmits the

1594
01:02:06,480 --> 01:02:09,839
um instructions that the that the

1595
01:02:09,839 --> 01:02:11,039
application makes

1596
01:02:11,039 --> 01:02:12,480
right it doesn't transmit the

1597
01:02:12,480 --> 01:02:15,599
instructions that linux

1598
01:02:15,599 --> 01:02:18,640
makes uh yeah exactly so here's an

1599
01:02:18,640 --> 01:02:19,039
interesting

1600
01:02:19,039 --> 01:02:21,119
uh thing but we'll see in a second uh

1601
01:02:21,119 --> 01:02:22,880
but let me make that more clear

1602
01:02:22,880 --> 01:02:25,920
uh right away the

1603
01:02:25,920 --> 01:02:27,359
in fact these instructors ink and deck

1604
01:02:27,359 --> 01:02:29,680
and branch are not sent to the primary

1605
01:02:29,680 --> 01:02:30,960
backer at all they basically have their

1606
01:02:30,960 --> 01:02:32,400
own copy correct and we're just starting

1607
01:02:32,400 --> 01:02:33,440
them at the same

1608
01:02:33,440 --> 01:02:34,880
point in the program and so therefore

1609
01:02:34,880 --> 01:02:37,119
they run exactly in a sort of lock step

1610
01:02:37,119 --> 01:02:38,079
almost

1611
01:02:38,079 --> 01:02:39,680
they're no longer running lockstep but

1612
01:02:39,680 --> 01:02:41,839
they execute them in the same order

1613
01:02:41,839 --> 01:02:43,839
only something special has to happen in

1614
01:02:43,839 --> 01:02:45,119
at these points of diverge

1615
01:02:45,119 --> 01:02:47,760
possible divergence and you know the

1616
01:02:47,760 --> 01:02:49,359
assumption that sort of paper makes is

1617
01:02:49,359 --> 01:02:50,480
that you know most instructors are

1618
01:02:50,480 --> 01:02:51,839
deterministic so we don't really have to

1619
01:02:51,839 --> 01:02:52,720
do anything

1620
01:02:52,720 --> 01:02:54,160
it's only at the instructions where

1621
01:02:54,160 --> 01:02:55,760
things are going to potentially go wrong

1622
01:02:55,760 --> 01:02:57,440
we have to do something and so

1623
01:02:57,440 --> 01:02:58,559
one of those sources where something

1624
01:02:58,559 --> 01:03:01,440
could go wrong is interrupts

1625
01:03:01,440 --> 01:03:02,559
so let's talk a little bit about

1626
01:03:02,559 --> 01:03:10,630
interruption

1627
01:03:10,640 --> 01:03:12,960
and so here like basically the the

1628
01:03:12,960 --> 01:03:13,680
virtual machine

1629
01:03:13,680 --> 01:03:17,200
sort of comes to rescue and really helps

1630
01:03:17,200 --> 01:03:18,559
you know us solve this problem so let's

1631
01:03:18,559 --> 01:03:18,880
say

1632
01:03:18,880 --> 01:03:23,430
here we have our hypervisor

1633
01:03:23,440 --> 01:03:26,160
an interrupt happens then the interrupt

1634
01:03:26,160 --> 01:03:28,799
will show up at the hypervisor

1635
01:03:28,799 --> 01:03:31,200
and the hypervisor knows exactly at what

1636
01:03:31,200 --> 01:03:32,559
instruction

1637
01:03:32,559 --> 01:03:35,039
the application was or where the vm was

1638
01:03:35,039 --> 01:03:36,000
at this level

1639
01:03:36,000 --> 01:03:37,680
so your linux is running inside of this

1640
01:03:37,680 --> 01:03:40,079
vm uh the interrupt happens

1641
01:03:40,079 --> 01:03:43,520
uh of course via the the the

1642
01:03:43,520 --> 01:03:45,520
photo the hyperfix already has taken

1643
01:03:45,520 --> 01:03:47,280
over control and it knows

1644
01:03:47,280 --> 01:03:49,119
where it stopped you know linux to

1645
01:03:49,119 --> 01:03:50,559
actually take the interrupt so maybe you

1646
01:03:50,559 --> 01:03:52,640
know whatever it took at it

1647
01:03:52,640 --> 01:03:54,160
you know it has executed 100

1648
01:03:54,160 --> 01:03:56,079
instructions so far

1649
01:03:56,079 --> 01:03:57,680
and then you know this interrupt comes

1650
01:03:57,680 --> 01:04:00,319
in and the hypervisor now wants to

1651
01:04:00,319 --> 01:04:02,480
deliver that uh interrupt basically

1652
01:04:02,480 --> 01:04:04,000
after instruction hundred

1653
01:04:04,000 --> 01:04:05,680
and before doing that actually it just

1654
01:04:05,680 --> 01:04:07,280
sends over the logging channel

1655
01:04:07,280 --> 01:04:10,000
the message you know to the backup okay

1656
01:04:10,000 --> 01:04:10,319
so

1657
01:04:10,319 --> 01:04:14,000
here's the backup ft and in that message

1658
01:04:14,000 --> 01:04:15,440
it basically says like okay

1659
01:04:15,440 --> 01:04:17,599
add instruction hundred you know when

1660
01:04:17,599 --> 01:04:19,039
you get to instruction hundred

1661
01:04:19,039 --> 01:04:21,119
you know deliver this interrupt and you

1662
01:04:21,119 --> 01:04:22,799
know maybe some data associated with the

1663
01:04:22,799 --> 01:04:24,559
interrupt

1664
01:04:24,559 --> 01:04:26,000
right so this does two things and the

1665
01:04:26,000 --> 01:04:27,599
inner comes in sees what the instruction

1666
01:04:27,599 --> 01:04:28,880
number was and then it sends to the

1667
01:04:28,880 --> 01:04:30,720
backup this message saying like hey

1668
01:04:30,720 --> 01:04:32,079
you know at some point you know when you

1669
01:04:32,079 --> 01:04:36,720
get to instruct

1670
01:04:36,720 --> 01:04:38,240
and you know some point later you know

1671
01:04:38,240 --> 01:04:40,799
there's interrupt one and interrupt two

1672
01:04:40,799 --> 01:04:41,599
comes in

1673
01:04:41,599 --> 01:04:44,000
uh and so you know the hypervisor does

1674
01:04:44,000 --> 01:04:45,039
exactly the same thing

1675
01:04:45,039 --> 01:04:48,480
you know again you know we'll send out

1676
01:04:48,480 --> 01:04:51,839
say this is instruction 200 you know we

1677
01:04:51,839 --> 01:04:54,240
send the message 200 interrupt you know

1678
01:04:54,240 --> 01:04:55,839
perhaps any data associative the

1679
01:04:55,839 --> 01:04:59,510
interrupt you know to the ft

1680
01:04:59,520 --> 01:05:03,039
so when you know the backup

1681
01:05:03,039 --> 01:05:05,200
gets the first message it just buffers

1682
01:05:05,200 --> 01:05:06,880
the message

1683
01:05:06,880 --> 01:05:08,640
because it doesn't know how long it can

1684
01:05:08,640 --> 01:05:10,000
run after that message

1685
01:05:10,000 --> 01:05:12,640
until it knows what the next point is

1686
01:05:12,640 --> 01:05:14,799
that it has to deliver something

1687
01:05:14,799 --> 01:05:16,319
so at the point that the second message

1688
01:05:16,319 --> 01:05:17,440
comes in you know for the second

1689
01:05:17,440 --> 01:05:18,079
interrupt

1690
01:05:18,079 --> 01:05:20,240
it knows you know it's perfectly fine to

1691
01:05:20,240 --> 01:05:21,839
start the computer

1692
01:05:21,839 --> 01:05:23,599
at instruction hunter deliver the

1693
01:05:23,599 --> 01:05:25,359
interrupt and basically keep running

1694
01:05:25,359 --> 01:05:28,160
until instruction 200

1695
01:05:28,160 --> 01:05:29,920
and the way it does it is that basically

1696
01:05:29,920 --> 01:05:31,760
most processors have this but the x86

1697
01:05:31,760 --> 01:05:32,640
has this too

1698
01:05:32,640 --> 01:05:34,640
where you can basically program the x86

1699
01:05:34,640 --> 01:05:35,680
and to say like well

1700
01:05:35,680 --> 01:05:37,440
you should stop after executing 100

1701
01:05:37,440 --> 01:05:38,799
instructions and so

1702
01:05:38,799 --> 01:05:40,640
the processor will stop executing it

1703
01:05:40,640 --> 01:05:42,400
after 100 instructions and just give

1704
01:05:42,400 --> 01:05:42,720
back

1705
01:05:42,720 --> 01:05:44,960
control to the operating system in this

1706
01:05:44,960 --> 01:05:47,599
case the virtual machine monitor

1707
01:05:47,599 --> 01:05:50,400
and so you know so this is the scheme

1708
01:05:50,400 --> 01:05:52,079
this is the scheme that the

1709
01:05:52,079 --> 01:05:54,960
uh the mft uses to basically you know

1710
01:05:54,960 --> 01:05:56,480
deliver interrupts

1711
01:05:56,480 --> 01:05:58,480
both at the primary and the backup

1712
01:05:58,480 --> 01:06:00,160
exactly at the same instruction

1713
01:06:00,160 --> 01:06:02,160
so that they sort of stay in this and

1714
01:06:02,160 --> 01:06:03,760
exactly execute the instructions in

1715
01:06:03,760 --> 01:06:06,079
exactly the same order

1716
01:06:06,079 --> 01:06:07,359
to arrange this of course you know the

1717
01:06:07,359 --> 01:06:13,589
backup needs to lag lex behind one

1718
01:06:13,599 --> 01:06:19,910
that's behind one message

1719
01:06:19,920 --> 01:06:23,510
okay

1720
01:06:23,520 --> 01:06:25,280
um so just to be clear so the

1721
01:06:25,280 --> 01:06:27,119
deterministic operations don't

1722
01:06:27,119 --> 01:06:28,640
don't get communicated through the

1723
01:06:28,640 --> 01:06:31,039
logging channel it's only the operations

1724
01:06:31,039 --> 01:06:32,160
that

1725
01:06:32,160 --> 01:06:34,960
perhaps might diverge exactly if you got

1726
01:06:34,960 --> 01:06:35,520
it

1727
01:06:35,520 --> 01:06:36,960
that's exactly what it does so let's

1728
01:06:36,960 --> 01:06:38,480
look at one more you know just to get

1729
01:06:38,480 --> 01:06:38,799
the

1730
01:06:38,799 --> 01:06:41,119
flavor and then we'll talk about it yeah

1731
01:06:41,119 --> 01:06:41,839
go ahead

1732
01:06:41,839 --> 01:06:44,960
sorry so deterministic operations you

1733
01:06:44,960 --> 01:06:45,440
said

1734
01:06:45,440 --> 01:06:46,880
don't get communicated through the

1735
01:06:46,880 --> 01:06:48,480
logging channel no

1736
01:06:48,480 --> 01:06:51,440
there's no need for them because both of

1737
01:06:51,440 --> 01:06:52,319
them of course have

1738
01:06:52,319 --> 01:06:54,079
a copy of all the instructions of like

1739
01:06:54,079 --> 01:06:56,000
the binary that like whatever linux runs

1740
01:06:56,000 --> 01:06:56,799
correct

1741
01:06:56,799 --> 01:06:58,480
uh but you know the instructions are not

1742
01:06:58,480 --> 01:07:00,000
communicated over the logging channel

1743
01:07:00,000 --> 01:07:03,200
it's only the non-deterministic watch

1744
01:07:03,200 --> 01:07:04,799
so like in this interrupt and we'll see

1745
01:07:04,799 --> 01:07:06,160
in a second you know let's talk about

1746
01:07:06,160 --> 01:07:07,359
the second one

1747
01:07:07,359 --> 01:07:11,190
non-deterministic instructions

1748
01:07:11,200 --> 01:07:14,079
like you know get the timer time of day

1749
01:07:14,079 --> 01:07:16,000
so the way that works is

1750
01:07:16,000 --> 01:07:18,559
uh so years we got our linux running in

1751
01:07:18,559 --> 01:07:19,200
the vm

1752
01:07:19,200 --> 01:07:22,640
you know we got our ft running and

1753
01:07:22,640 --> 01:07:25,520
basically when you know this linux uh

1754
01:07:25,520 --> 01:07:25,920
you know

1755
01:07:25,920 --> 01:07:27,680
usually the image you know the program

1756
01:07:27,680 --> 01:07:29,440
image that linux runs

1757
01:07:29,440 --> 01:07:31,119
and maybe you know here's our

1758
01:07:31,119 --> 01:07:33,760
non-deterministic instruction

1759
01:07:33,760 --> 01:07:37,200
and basically what ft has done uh before

1760
01:07:37,200 --> 01:07:38,240
it started linux

1761
01:07:38,240 --> 01:07:40,079
is sort of gone through like the linux

1762
01:07:40,079 --> 01:07:41,280
binary and

1763
01:07:41,280 --> 01:07:42,559
found all the instructions that are

1764
01:07:42,559 --> 01:07:44,240
non-deterministic like you know get time

1765
01:07:44,240 --> 01:07:44,960
of day

1766
01:07:44,960 --> 01:07:47,119
and basically ensure you know turn them

1767
01:07:47,119 --> 01:07:48,960
in sort of an invalid instruction

1768
01:07:48,960 --> 01:07:51,599
and so when linux execute executes that

1769
01:07:51,599 --> 01:07:53,359
non-deterministic instruction

1770
01:07:53,359 --> 01:07:55,359
it actually controls transfers control

1771
01:07:55,359 --> 01:07:57,760
to the hypervisor

1772
01:07:57,760 --> 01:08:00,799
this is the trap and now the hypervisor

1773
01:08:00,799 --> 01:08:02,400
knows okay well this was you know

1774
01:08:02,400 --> 01:08:04,640
whatever instruction 341

1775
01:08:04,640 --> 01:08:06,720
i know that is a non-deterministic

1776
01:08:06,720 --> 01:08:08,319
instruction because i wrote you know

1777
01:08:08,319 --> 01:08:10,960
those bits you know that caused the trap

1778
01:08:10,960 --> 01:08:11,599
and

1779
01:08:11,599 --> 01:08:13,039
it will emulate you know that

1780
01:08:13,039 --> 01:08:15,280
instruction and so it will do all the

1781
01:08:15,280 --> 01:08:16,880
effects that that instruction has

1782
01:08:16,880 --> 01:08:19,040
but record what the results of those

1783
01:08:19,040 --> 01:08:20,560
effects are so for example

1784
01:08:20,560 --> 01:08:22,080
you know whenever we record what the

1785
01:08:22,080 --> 01:08:24,000
result you know executes instruction

1786
01:08:24,000 --> 01:08:27,199
the result says goes into a0 uh it

1787
01:08:27,199 --> 01:08:28,640
records the value of the a0

1788
01:08:28,640 --> 01:08:31,839
and then basically sends to the backup

1789
01:08:31,839 --> 01:08:33,759
you know the outcome you know of that

1790
01:08:33,759 --> 01:08:35,600
instruction so whatever is like

1791
01:08:35,600 --> 01:08:39,120
the value in a0 is you know whatever 221

1792
01:08:39,120 --> 01:08:40,880
then it will you know send back you know

1793
01:08:40,880 --> 01:08:41,679
saying you know there's none

1794
01:08:41,679 --> 01:08:43,600
deterministic construction

1795
01:08:43,600 --> 01:08:47,440
uh the result of it is 221.

1796
01:08:47,440 --> 01:08:48,960
and at some point correct you know the

1797
01:08:48,960 --> 01:08:50,799
backup legs behind

1798
01:08:50,799 --> 01:08:53,920
uh it will you know execute because it's

1799
01:08:53,920 --> 01:08:55,040
actually keeping the instructions in the

1800
01:08:55,040 --> 01:08:56,080
same order in the

1801
01:08:56,080 --> 01:08:57,839
same way it will also execute the

1802
01:08:57,839 --> 01:08:59,759
numbers to deterministic instruction

1803
01:08:59,759 --> 01:09:02,480
that will trap into the kernel uh and

1804
01:09:02,480 --> 01:09:04,000
the usual wait until

1805
01:09:04,000 --> 01:09:05,920
you know since it lags behind it already

1806
01:09:05,920 --> 01:09:07,440
has received probably the message

1807
01:09:07,440 --> 01:09:09,040
and basically you make sure that you

1808
01:09:09,040 --> 01:09:10,640
know it sticks the same value

1809
01:09:10,640 --> 01:09:12,640
you know or returns the same value as it

1810
01:09:12,640 --> 01:09:14,319
did on the primary

1811
01:09:14,319 --> 01:09:16,239
right so this is how non-deterministic

1812
01:09:16,239 --> 01:09:21,600
instructions are handled

1813
01:09:21,600 --> 01:09:24,400
sorry so that happens um like the

1814
01:09:24,400 --> 01:09:26,319
modification of the binary it happens

1815
01:09:26,319 --> 01:09:27,440
when

1816
01:09:27,440 --> 01:09:30,560
um it creates the virtual

1817
01:09:30,560 --> 01:09:32,319
machine yeah we think about it when it

1818
01:09:32,319 --> 01:09:35,520
boots the vm okay

1819
01:09:35,520 --> 01:09:39,040
right so the um the backup re-executes

1820
01:09:39,040 --> 01:09:39,920
the

1821
01:09:39,920 --> 01:09:42,239
the non-deterministic instruction and

1822
01:09:42,239 --> 01:09:43,600
then just verifies the

1823
01:09:43,600 --> 01:09:46,880
result no what it actually does is if

1824
01:09:46,880 --> 01:09:49,600
the virtual machine monitor executes the

1825
01:09:49,600 --> 01:09:50,960
instruction

1826
01:09:50,960 --> 01:09:53,440
and then you know uh or actually the

1827
01:09:53,440 --> 01:09:54,640
virtual machine model doesn't execute

1828
01:09:54,640 --> 01:09:55,840
the instruction at all

1829
01:09:55,840 --> 01:09:58,400
uh it knows that this instruction needs

1830
01:09:58,400 --> 01:09:59,440
to be executed

1831
01:09:59,440 --> 01:10:01,280
and it knows what things will be changed

1832
01:10:01,280 --> 01:10:02,960
like what registers need to be updated

1833
01:10:02,960 --> 01:10:04,560
as a result of this uh

1834
01:10:04,560 --> 01:10:06,800
instruction and it sticks the value from

1835
01:10:06,800 --> 01:10:07,760
the message

1836
01:10:07,760 --> 01:10:10,480
into the red register so that the uh you

1837
01:10:10,480 --> 01:10:11,760
know the linux running on the backup

1838
01:10:11,760 --> 01:10:13,360
sees exactly the same effect as

1839
01:10:13,360 --> 01:10:20,390
the the linux running on the primary

1840
01:10:20,400 --> 01:10:21,600
and so like this assumes that the

1841
01:10:21,600 --> 01:10:24,239
hypervisor will do some work before even

1842
01:10:24,239 --> 01:10:26,560
uh or while putting up the vm just

1843
01:10:26,560 --> 01:10:28,000
because of where the locations of these

1844
01:10:28,000 --> 01:10:29,360
non-determinations oh yeah yeah i'm

1845
01:10:29,360 --> 01:10:30,719
wishing any hypervisor does to these

1846
01:10:30,719 --> 01:10:32,800
days

1847
01:10:32,800 --> 01:10:34,480
so this is our standard hypervisor stuff

1848
01:10:34,480 --> 01:10:36,159
this is nothing new to uh

1849
01:10:36,159 --> 01:10:38,800
ft uh other than you know these guys are

1850
01:10:38,800 --> 01:10:39,920
the tone and experience doing

1851
01:10:39,920 --> 01:10:42,000
hypervisors right because of vmware

1852
01:10:42,000 --> 01:10:44,400
and so they understand like what what a

1853
01:10:44,400 --> 01:10:45,840
neat what it takes

1854
01:10:45,840 --> 01:10:46,719
and which instructions are

1855
01:10:46,719 --> 01:10:51,350
non-deterministic thank you

1856
01:10:51,360 --> 01:10:54,560
okay so i i had one more

1857
01:10:54,560 --> 01:10:57,760
uh one more question so if

1858
01:10:57,760 --> 01:11:00,159
you know it's a program of fully like

1859
01:11:00,159 --> 01:11:02,320
deterministic instructions

1860
01:11:02,320 --> 01:11:05,600
uh could could the backup run

1861
01:11:05,600 --> 01:11:09,120
faster than the primary um

1862
01:11:09,120 --> 01:11:10,320
okay so you know there's a whole

1863
01:11:10,320 --> 01:11:11,760
discussion in the paper about like the

1864
01:11:11,760 --> 01:11:13,360
speed of the primary in the backup and

1865
01:11:13,360 --> 01:11:14,320
making sure that they're

1866
01:11:14,320 --> 01:11:15,600
running roughly at the same speed

1867
01:11:15,600 --> 01:11:17,120
because you don't want to get one far

1868
01:11:17,120 --> 01:11:19,520
behind ahead and the one not far behind

1869
01:11:19,520 --> 01:11:21,280
um i think you should think about them

1870
01:11:21,280 --> 01:11:22,560
they're running on sort of identical

1871
01:11:22,560 --> 01:11:24,159
hardware and so they run roughly at the

1872
01:11:24,159 --> 01:11:25,120
same speed

1873
01:11:25,120 --> 01:11:28,400
uh it's also the case that uh there's

1874
01:11:28,400 --> 01:11:30,320
gonna be always some communication over

1875
01:11:30,320 --> 01:11:31,440
this uh channel

1876
01:11:31,440 --> 01:11:33,840
uh because interrupts are happening

1877
01:11:33,840 --> 01:11:35,440
periodically right like

1878
01:11:35,440 --> 01:11:37,840
every you know whatever you know a

1879
01:11:37,840 --> 01:11:38,960
couple milliseconds

1880
01:11:38,960 --> 01:11:40,480
or maybe 100 milliseconds or 10

1881
01:11:40,480 --> 01:11:42,320
milliseconds depending on like what how

1882
01:11:42,320 --> 01:11:42,880
linux

1883
01:11:42,880 --> 01:11:44,239
and what rate linux programmed the

1884
01:11:44,239 --> 01:11:46,080
hardware timer there will be a timer

1885
01:11:46,080 --> 01:11:46,640
interrupt

1886
01:11:46,640 --> 01:11:47,840
and the timer interrupt will be

1887
01:11:47,840 --> 01:11:50,080
propagated you know to the backup and

1888
01:11:50,080 --> 01:11:53,600
sort of be your sync points if you will

1889
01:11:53,600 --> 01:11:56,400
right but um my question is like for

1890
01:11:56,400 --> 01:11:56,960
example

1891
01:11:56,960 --> 01:11:58,800
say you you have a bunch of like

1892
01:11:58,800 --> 01:12:00,480
deterministic instructions right

1893
01:12:00,480 --> 01:12:01,840
instructions that aren't sent through

1894
01:12:01,840 --> 01:12:03,840
the logging channel

1895
01:12:03,840 --> 01:12:06,960
um which means you know the primary and

1896
01:12:06,960 --> 01:12:07,520
backup

1897
01:12:07,520 --> 01:12:09,600
can run those instructions and at their

1898
01:12:09,600 --> 01:12:10,960
own pace correct

1899
01:12:10,960 --> 01:12:14,239
yes so say i mean i don't know if this

1900
01:12:14,239 --> 01:12:16,080
could happen but say like

1901
01:12:16,080 --> 01:12:19,280
um it's you know a hundred instructions

1902
01:12:19,280 --> 01:12:22,480
and the primary goes to like instruction

1903
01:12:22,480 --> 01:12:23,520
50

1904
01:12:23,520 --> 01:12:26,800
and gets gets a timer interrupt

1905
01:12:26,800 --> 01:12:28,880
uh but the backup is already a timer

1906
01:12:28,880 --> 01:12:30,640
like 60 or something

1907
01:12:30,640 --> 01:12:32,480
could that like that could not happen

1908
01:12:32,480 --> 01:12:34,080
great because remember the backup

1909
01:12:34,080 --> 01:12:38,149
likes behind one of these messages

1910
01:12:38,159 --> 01:12:39,920
so the back of both start executing the

1911
01:12:39,920 --> 01:12:41,199
next block until the

1912
01:12:41,199 --> 01:12:44,640
primary has finished it okay now this is

1913
01:12:44,640 --> 01:12:45,440
why

1914
01:12:45,440 --> 01:12:51,520
this is why it lacks behind one um

1915
01:12:51,520 --> 01:12:53,679
like to ensure that the backup is like

1916
01:12:53,679 --> 01:12:55,840
lagging behind one instruction that does

1917
01:12:55,840 --> 01:12:56,400
that mean

1918
01:12:56,400 --> 01:12:58,560
no no not one instruction one message on

1919
01:12:58,560 --> 01:13:00,159
the channel

1920
01:13:00,159 --> 01:13:02,000
but the interrupt is unexpected right so

1921
01:13:02,000 --> 01:13:04,000
if we have as you said if you have 100

1922
01:13:04,000 --> 01:13:06,960
lines of instructions and uh running on

1923
01:13:06,960 --> 01:13:07,600
the backup

1924
01:13:07,600 --> 01:13:09,679
as well as on the primary then the

1925
01:13:09,679 --> 01:13:10,960
department would the backup would not

1926
01:13:10,960 --> 01:13:12,080
have started yet

1927
01:13:12,080 --> 01:13:14,000
right so the primary runs the 400

1928
01:13:14,000 --> 01:13:16,239
instructions the backup actually waits

1929
01:13:16,239 --> 01:13:17,440
until

1930
01:13:17,440 --> 01:13:20,080
uh the priming actually has completed

1931
01:13:20,080 --> 01:13:21,040
you know whatever those hundreds

1932
01:13:21,040 --> 01:13:21,840
instructions

1933
01:13:21,840 --> 01:13:23,520
before it starts running those hundred

1934
01:13:23,520 --> 01:13:25,440
instructions

1935
01:13:25,440 --> 01:13:26,960
so just again one way to think about is

1936
01:13:26,960 --> 01:13:29,360
like always runs like one epoch behind

1937
01:13:29,360 --> 01:13:31,760
oh so it's kind of a batching kind of

1938
01:13:31,760 --> 01:13:33,040
scheme yep

1939
01:13:33,040 --> 01:13:35,679
all right thank you okay so i want to

1940
01:13:35,679 --> 01:13:36,960
talk a little bit about failover because

1941
01:13:36,960 --> 01:13:38,320
there's a couple of interesting there's

1942
01:13:38,320 --> 01:13:40,080
one more rule that needs to be ensured

1943
01:13:40,080 --> 01:13:40,880
that we actually

1944
01:13:40,880 --> 01:13:44,239
uh get the right behavior and so

1945
01:13:44,239 --> 01:13:46,400
uh so let's uh walk through some

1946
01:13:46,400 --> 01:13:48,239
scenarios here's the primary

1947
01:13:48,239 --> 01:13:51,280
here's our hypervisor correct ft uh

1948
01:13:51,280 --> 01:13:54,239
here's our logging channel

1949
01:13:54,239 --> 01:13:56,960
it's ft the bose is on the network

1950
01:13:56,960 --> 01:13:59,440
here's a client

1951
01:13:59,440 --> 01:14:03,910
and here's our backup

1952
01:14:03,920 --> 01:14:05,520
and i'm going to talk about a couple of

1953
01:14:05,520 --> 01:14:07,360
scenarios so

1954
01:14:07,360 --> 01:14:10,400
um the first scenarios or the normal

1955
01:14:10,400 --> 01:14:11,120
case or

1956
01:14:11,120 --> 01:14:14,400
the client sends a message

1957
01:14:14,400 --> 01:14:16,400
you know to the primary or like the

1958
01:14:16,400 --> 01:14:17,920
server is running on the primary you

1959
01:14:17,920 --> 01:14:19,840
know that's delivered of course

1960
01:14:19,840 --> 01:14:21,840
you know to the primary it's also sent

1961
01:14:21,840 --> 01:14:23,920
you know to on the channel

1962
01:14:23,920 --> 01:14:26,080
and uh let's assume for a second that

1963
01:14:26,080 --> 01:14:27,679
actually the message you know

1964
01:14:27,679 --> 01:14:31,040
arrives you know at the hypervisor so it

1965
01:14:31,040 --> 01:14:32,239
actually knows that this was an

1966
01:14:32,239 --> 01:14:33,520
interrupt and some packet

1967
01:14:33,520 --> 01:14:37,360
arrived and so now let's say the

1968
01:14:37,360 --> 01:14:40,960
primary sensor responds back

1969
01:14:40,960 --> 01:14:44,800
and at that point the computer crashes

1970
01:14:44,800 --> 01:14:46,640
so the primary fails the client has not

1971
01:14:46,640 --> 01:14:48,719
gotten response yet

1972
01:14:48,719 --> 01:14:50,400
now this turns out to work out perfectly

1973
01:14:50,400 --> 01:14:52,239
fine right because before

1974
01:14:52,239 --> 01:14:53,840
you know the backup actually takes over

1975
01:14:53,840 --> 01:14:55,280
it first processes all

1976
01:14:55,280 --> 01:14:58,800
its uh messages that hasn't received yet

1977
01:14:58,800 --> 01:15:00,000
because lag's one behind

1978
01:15:00,000 --> 01:15:02,159
you know as we talked before so you know

1979
01:15:02,159 --> 01:15:04,239
this thing will be

1980
01:15:04,239 --> 01:15:09,430
delivered so it will sorry

1981
01:15:09,440 --> 01:15:12,480
um uh

1982
01:15:12,480 --> 01:15:14,159
ah okay let me be a little bit more

1983
01:15:14,159 --> 01:15:16,800
careful uh okay so that gets delivered

1984
01:15:16,800 --> 01:15:18,400
the prime backup does it you know but it

1985
01:15:18,400 --> 01:15:20,800
actually won't send in the response

1986
01:15:20,800 --> 01:15:22,719
because it's still sort of you know

1987
01:15:22,719 --> 01:15:24,159
doing exactly what the primary

1988
01:15:24,159 --> 01:15:25,600
has done you know gets to that

1989
01:15:25,600 --> 01:15:27,600
particular point and stops

1990
01:15:27,600 --> 01:15:29,199
then point you know the erase you know

1991
01:15:29,199 --> 01:15:30,560
or like the backup actually comes to

1992
01:15:30,560 --> 01:15:32,000
primary you know from the arbitration

1993
01:15:32,000 --> 01:15:32,880
server

1994
01:15:32,880 --> 01:15:34,480
and the client will just time out and

1995
01:15:34,480 --> 01:15:36,800
retry right because like tcp packet then

1996
01:15:36,800 --> 01:15:37,760
get a response and

1997
01:15:37,760 --> 01:15:40,960
retracts everything works right perfect

1998
01:15:40,960 --> 01:15:44,719
the interesting case is what happens

1999
01:15:44,719 --> 01:15:48,390
in the following scenario where

2000
01:15:48,400 --> 01:15:51,360
the client sends the request it can

2001
01:15:51,360 --> 01:15:52,400
arrive at the primary

2002
01:15:52,400 --> 01:15:54,719
primary uh does the operation or

2003
01:15:54,719 --> 01:15:56,480
whatever process the client requests

2004
01:15:56,480 --> 01:15:57,840
sends the message to default talent

2005
01:15:57,840 --> 01:15:59,520
server

2006
01:15:59,520 --> 01:16:01,679
in the meantime okay it was also sent on

2007
01:16:01,679 --> 01:16:02,800
the logging channel

2008
01:16:02,800 --> 01:16:04,880
but let's say we got unlucky the message

2009
01:16:04,880 --> 01:16:06,480
actually never made it over the logging

2010
01:16:06,480 --> 01:16:07,840
channel

2011
01:16:07,840 --> 01:16:13,669
and um uh

2012
01:16:13,679 --> 01:16:15,920
but the primary actually you know sends

2013
01:16:15,920 --> 01:16:16,719
a response

2014
01:16:16,719 --> 01:16:20,080
before and just sends a response

2015
01:16:20,080 --> 01:16:23,360
and then it fails right and so for

2016
01:16:23,360 --> 01:16:24,480
example like maybe

2017
01:16:24,480 --> 01:16:26,400
you know this request was like increase

2018
01:16:26,400 --> 01:16:27,920
you know the variable from 10 you know

2019
01:16:27,920 --> 01:16:29,440
to 11. so

2020
01:16:29,440 --> 01:16:32,320
inc you know the old state was 10 and

2021
01:16:32,320 --> 01:16:36,070
now the new state is 11.

2022
01:16:36,080 --> 01:16:39,679
right and is this problematic

2023
01:16:39,679 --> 01:16:43,280
the scenario um yeah because

2024
01:16:43,280 --> 01:16:46,320
when the backup takes over it won't

2025
01:16:46,320 --> 01:16:49,600
uh know about that increase

2026
01:16:49,600 --> 01:16:52,400
um and so it'll just continue execution

2027
01:16:52,400 --> 01:16:53,520
as if it didn't happen

2028
01:16:53,520 --> 01:16:56,560
and this provides um like

2029
01:16:56,560 --> 01:17:00,000
inconsistent uh output to the external

2030
01:17:00,000 --> 01:17:02,719
um like facing world i guess yeah

2031
01:17:02,719 --> 01:17:03,199
exactly

2032
01:17:03,199 --> 01:17:04,800
right because the primary will take the

2033
01:17:04,800 --> 01:17:06,239
backup will take over the value will

2034
01:17:06,239 --> 01:17:07,360
still be 10

2035
01:17:07,360 --> 01:17:09,920
uh and now if the client doesn't inc it

2036
01:17:09,920 --> 01:17:10,560
can actually

2037
01:17:10,560 --> 01:17:12,640
uh gets 11 back instead of 10 over

2038
01:17:12,640 --> 01:17:13,840
instead of 12

2039
01:17:13,840 --> 01:17:16,320
right so this is no good and so how is

2040
01:17:16,320 --> 01:17:18,560
this avoided this problem

2041
01:17:18,560 --> 01:17:21,840
um the primary will send

2042
01:17:21,840 --> 01:17:24,480
things to the backup and then wait for

2043
01:17:24,480 --> 01:17:26,719
acknowledgement and once that

2044
01:17:26,719 --> 01:17:28,480
ah once that acknowledgement is received

2045
01:17:28,480 --> 01:17:30,560
it can uh send

2046
01:17:30,560 --> 01:17:32,960
output and it doesn't matter whether the

2047
01:17:32,960 --> 01:17:34,000
backup actually

2048
01:17:34,000 --> 01:17:36,000
runs the command it just has to like

2049
01:17:36,000 --> 01:17:37,840
have it so that

2050
01:17:37,840 --> 01:17:40,400
if it ever needs to take over as primary

2051
01:17:40,400 --> 01:17:42,080
it has that in its logs and it will

2052
01:17:42,080 --> 01:17:42,640
catch up

2053
01:17:42,640 --> 01:17:45,440
before actually like becoming the

2054
01:17:45,440 --> 01:17:46,880
primary this is exactly right

2055
01:17:46,880 --> 01:17:48,719
so this is what's called the output rule

2056
01:17:48,719 --> 01:17:51,430
right

2057
01:17:51,440 --> 01:17:53,360
and the rule is that you know before you

2058
01:17:53,360 --> 01:17:55,600
can output you got to make sure

2059
01:17:55,600 --> 01:17:58,640
that the preceding messages that you

2060
01:17:58,640 --> 01:18:00,320
were sent to the backup actually have

2061
01:18:00,320 --> 01:18:02,480
been received by the backup

2062
01:18:02,480 --> 01:18:04,159
so the scenario that just drew out you

2063
01:18:04,159 --> 01:18:06,159
know can actually never happen

2064
01:18:06,159 --> 01:18:07,760
because you know at the point you know

2065
01:18:07,760 --> 01:18:09,760
the primary wants to send the response

2066
01:18:09,760 --> 01:18:11,280
out on the network

2067
01:18:11,280 --> 01:18:14,480
the ft the primary ft will wait until

2068
01:18:14,480 --> 01:18:16,080
this message actually has

2069
01:18:16,080 --> 01:18:17,840
has been received by the pr by the

2070
01:18:17,840 --> 01:18:19,199
backup and

2071
01:18:19,199 --> 01:18:21,679
only when it receives an acknowledgement

2072
01:18:21,679 --> 01:18:23,840
from the

2073
01:18:23,840 --> 01:18:26,960
backup ft uh and now it knows you know

2074
01:18:26,960 --> 01:18:28,000
that basically the

2075
01:18:28,000 --> 01:18:31,440
backup has uh a copy of this input

2076
01:18:31,440 --> 01:18:33,520
uh and so whatever you know whenever it

2077
01:18:33,520 --> 01:18:34,800
fails you know the

2078
01:18:34,800 --> 01:18:36,800
backup will you know process that input

2079
01:18:36,800 --> 01:18:38,159
and basically get you know the computer

2080
01:18:38,159 --> 01:18:39,280
in the same state as in

2081
01:18:39,280 --> 01:18:41,840
the primary so at that point it actually

2082
01:18:41,840 --> 01:18:42,320
save

2083
01:18:42,320 --> 01:18:45,199
you know to send out the reply and so

2084
01:18:45,199 --> 01:18:46,560
this is the output rule

2085
01:18:46,560 --> 01:18:49,600
is that you don't output until

2086
01:18:49,600 --> 01:18:51,600
all proceeding messages that you send

2087
01:18:51,600 --> 01:18:52,719
over the log channel

2088
01:18:52,719 --> 01:18:54,239
actually have been received by the

2089
01:18:54,239 --> 01:18:57,199
backup and so just to clarify

2090
01:18:57,199 --> 01:19:00,320
it seems that the output rule is here to

2091
01:19:00,320 --> 01:19:00,880
uh

2092
01:19:00,880 --> 01:19:02,400
to solve the inconsistency that could

2093
01:19:02,400 --> 01:19:04,880
happen if we have some non-determinism

2094
01:19:04,880 --> 01:19:07,120
so like let's say that we have the

2095
01:19:07,120 --> 01:19:08,000
output operation

2096
01:19:08,000 --> 01:19:11,360
to be instruction 60 and uh we did not

2097
01:19:11,360 --> 01:19:11,920
have the

2098
01:19:11,920 --> 01:19:14,400
uh the output rule and so the backup

2099
01:19:14,400 --> 01:19:14,960
actually

2100
01:19:14,960 --> 01:19:16,960
did not let's say for some reason did

2101
01:19:16,960 --> 01:19:18,480
not receive the

2102
01:19:18,480 --> 01:19:21,760
output operation um or it did not

2103
01:19:21,760 --> 01:19:23,679
receive up until the output operation

2104
01:19:23,679 --> 01:19:25,760
if the instructions are deterministic

2105
01:19:25,760 --> 01:19:26,719
between the point

2106
01:19:26,719 --> 01:19:28,960
where the backup did not receive

2107
01:19:28,960 --> 01:19:29,840
messages

2108
01:19:29,840 --> 01:19:31,920
until the point where we have an output

2109
01:19:31,920 --> 01:19:32,880
operation

2110
01:19:32,880 --> 01:19:34,880
do we still run into the problem of the

2111
01:19:34,880 --> 01:19:36,239
inconsistency

2112
01:19:36,239 --> 01:19:37,199
yeah because the client might have

2113
01:19:37,199 --> 01:19:39,760
observed it right the client might have

2114
01:19:39,760 --> 01:19:41,360
observed that actually the value is now

2115
01:19:41,360 --> 01:19:43,520
11.

2116
01:19:43,520 --> 01:19:45,600
and so when it actually talks to the

2117
01:19:45,600 --> 01:19:46,560
backup after

2118
01:19:46,560 --> 01:19:49,280
the primary has failed you know then the

2119
01:19:49,280 --> 01:19:50,000
values certainly

2120
01:19:50,000 --> 01:19:53,360
10. and this is that can't be true

2121
01:19:53,360 --> 01:19:55,679
so that you know that reveals that it's

2122
01:19:55,679 --> 01:19:59,350
not behaving like a single system

2123
01:19:59,360 --> 01:20:00,719
it's really the external it's the

2124
01:20:00,719 --> 01:20:02,480
external thing you know the external

2125
01:20:02,480 --> 01:20:04,000
client that will observe something right

2126
01:20:04,000 --> 01:20:06,080
and this is why the output role exists

2127
01:20:06,080 --> 01:20:07,840
and any replication system that we'll

2128
01:20:07,840 --> 01:20:09,920
see this semester has something like the

2129
01:20:09,920 --> 01:20:11,199
output rule

2130
01:20:11,199 --> 01:20:13,199
it turns out to be you know for example

2131
01:20:13,199 --> 01:20:15,120
we'll see in the uh

2132
01:20:15,120 --> 01:20:18,320
even in the rav paper but also in

2133
01:20:18,320 --> 01:20:20,639
zookeeper there's sort of this notion

2134
01:20:20,639 --> 01:20:22,159
that you know sometimes you want to like

2135
01:20:22,159 --> 01:20:24,719
uh respond to reads immediately but you

2136
01:20:24,719 --> 01:20:26,239
can't really do that because

2137
01:20:26,239 --> 01:20:27,760
you run this risk and there's sort of a

2138
01:20:27,760 --> 01:20:29,679
sort of an equivalent of an output rule

2139
01:20:29,679 --> 01:20:31,679
that tries to avoid you know problems

2140
01:20:31,679 --> 01:20:35,750
like like that

2141
01:20:35,760 --> 01:20:39,440
so does the client um re-execute the

2142
01:20:39,440 --> 01:20:40,719
command

2143
01:20:40,719 --> 01:20:42,400
like do they get some sort of signal

2144
01:20:42,400 --> 01:20:44,639
that because the

2145
01:20:44,639 --> 01:20:48,320
command okay

2146
01:20:48,320 --> 01:20:50,560
okay so let's say uh we did not get the

2147
01:20:50,560 --> 01:20:52,719
ack right

2148
01:20:52,719 --> 01:20:54,400
so it got to the back up but not to the

2149
01:20:54,400 --> 01:20:56,400
ack then

2150
01:20:56,400 --> 01:20:59,040
uh the client will have not you know

2151
01:20:59,040 --> 01:21:00,560
this response would have not been sent

2152
01:21:00,560 --> 01:21:03,040
to the client yet correct

2153
01:21:03,040 --> 01:21:04,880
the backup will take over the client

2154
01:21:04,880 --> 01:21:06,159
presumably will time out

2155
01:21:06,159 --> 01:21:07,920
and do whatever it needs to do you know

2156
01:21:07,920 --> 01:21:09,280
either you know does nothing

2157
01:21:09,280 --> 01:21:11,199
you know if you know the that's part of

2158
01:21:11,199 --> 01:21:13,120
the their that's part of the protocol

2159
01:21:13,120 --> 01:21:14,480
between the servers and the client

2160
01:21:14,480 --> 01:21:16,480
most likely the client will reset like

2161
01:21:16,480 --> 01:21:18,080
it's a tcp connection

2162
01:21:18,080 --> 01:21:20,639
uh the response packet didn't get

2163
01:21:20,639 --> 01:21:22,480
whatever received and so it will

2164
01:21:22,480 --> 01:21:25,840
you know try to uh resend and so it will

2165
01:21:25,840 --> 01:21:28,560
resent to the backup and then finish the

2166
01:21:28,560 --> 01:21:30,400
operation

2167
01:21:30,400 --> 01:21:40,830
but it won't observe an old value

2168
01:21:40,840 --> 01:21:50,790
okay

2169
01:21:50,800 --> 01:21:54,320
okay um now i want to

2170
01:21:54,320 --> 01:21:57,280
talk one thing a little bit uh so this

2171
01:21:57,280 --> 01:21:57,840
system

2172
01:21:57,840 --> 01:21:59,360
i think is actually very cool it's a

2173
01:21:59,360 --> 01:22:01,600
very clean uh

2174
01:22:01,600 --> 01:22:03,760
version of uh sort of statements of

2175
01:22:03,760 --> 01:22:05,360
state machine replication

2176
01:22:05,360 --> 01:22:06,880
uh it brings out these issues of

2177
01:22:06,880 --> 01:22:09,040
non-determinism uh the issues like

2178
01:22:09,040 --> 01:22:11,120
the output rule that we'll see in the

2179
01:22:11,120 --> 01:22:12,480
versions of that we'll see in

2180
01:22:12,480 --> 01:22:16,159
similar uh in in other

2181
01:22:16,159 --> 01:22:17,920
systems but i want to talk a little bit

2182
01:22:17,920 --> 01:22:19,199
about performance

2183
01:22:19,199 --> 01:22:22,480
because like one downside of this system

2184
01:22:22,480 --> 01:22:24,480
is you know because you're doing things

2185
01:22:24,480 --> 01:22:26,000
at the level of the

2186
01:22:26,000 --> 01:22:27,440
machine instructions or like at the

2187
01:22:27,440 --> 01:22:29,679
level of interrupts uh there

2188
01:22:29,679 --> 01:22:32,880
you pay uh a performance a hit

2189
01:22:32,880 --> 01:22:35,840
um so i want to point to the two tables

2190
01:22:35,840 --> 01:22:38,320
that are in the paper uh

2191
01:22:38,320 --> 01:22:39,520
and one you know the first thing to

2192
01:22:39,520 --> 01:22:41,360
observe is that actually the left table

2193
01:22:41,360 --> 01:22:43,360
is actually extremely good

2194
01:22:43,360 --> 01:22:45,520
uh so the backup and the primary if you

2195
01:22:45,520 --> 01:22:46,719
run the backup on primary the

2196
01:22:46,719 --> 01:22:48,719
performance is very close to as if you

2197
01:22:48,719 --> 01:22:50,560
were not running with a

2198
01:22:50,560 --> 01:22:53,520
backup which is very very impressive

2199
01:22:53,520 --> 01:22:54,639
including the fact that you're running a

2200
01:22:54,639 --> 01:22:56,239
virtual machine

2201
01:22:56,239 --> 01:22:59,360
uh the more uh the more

2202
01:22:59,360 --> 01:23:02,400
uh troublesome part is this

2203
01:23:02,400 --> 01:23:05,120
side of the things where um if you don't

2204
01:23:05,120 --> 01:23:05,760
run

2205
01:23:05,760 --> 01:23:07,520
in in a primary backup mode you know

2206
01:23:07,520 --> 01:23:09,120
like your bandwidth and receiving

2207
01:23:09,120 --> 01:23:10,639
ascending actually is pretty high you

2208
01:23:10,639 --> 01:23:10,880
know

2209
01:23:10,880 --> 01:23:12,239
at least in the particular experiment

2210
01:23:12,239 --> 01:23:14,080
they did but you know when you're

2211
01:23:14,080 --> 01:23:15,360
running the backup mode

2212
01:23:15,360 --> 01:23:16,880
things are actually not so good right

2213
01:23:16,880 --> 01:23:18,400
you know these numbers are quite

2214
01:23:18,400 --> 01:23:19,280
different

2215
01:23:19,280 --> 01:23:20,560
in fact there's sort of like a 30

2216
01:23:20,560 --> 01:23:23,120
reduction in performance

2217
01:23:23,120 --> 01:23:24,960
and where is that 30 coming from like

2218
01:23:24,960 --> 01:23:34,159
why why is that the case

2219
01:23:34,159 --> 01:23:36,239
um is it because the primary is actually

2220
01:23:36,239 --> 01:23:38,960
the one receiving inputs from outside

2221
01:23:38,960 --> 01:23:42,000
yeah well i think there's two cases in

2222
01:23:42,000 --> 01:23:42,880
on the receiving

2223
01:23:42,880 --> 01:23:44,639
case right the primer is receiving input

2224
01:23:44,639 --> 01:23:46,080
from the outside and where does that

2225
01:23:46,080 --> 01:23:50,239
need to go it receives a packet from the

2226
01:23:50,239 --> 01:23:52,080
from the client and so the packet has to

2227
01:23:52,080 --> 01:23:53,280
be sent you know to

2228
01:23:53,280 --> 01:23:56,400
the uh

2229
01:23:56,400 --> 01:23:58,719
to the backup and furthermore but the

2230
01:23:58,719 --> 01:23:59,920
primary is also the one

2231
01:23:59,920 --> 01:24:03,600
sending output uh to back to the clients

2232
01:24:03,600 --> 01:24:05,600
so is that what's using the bandwidth

2233
01:24:05,600 --> 01:24:08,159
uh well there's the that's one reason

2234
01:24:08,159 --> 01:24:09,199
that's what the bandwidth

2235
01:24:09,199 --> 01:24:10,639
that's part of the band revision but the

2236
01:24:10,639 --> 01:24:12,400
real thing i think was going on here is

2237
01:24:12,400 --> 01:24:13,360
that the

2238
01:24:13,360 --> 01:24:16,080
uh primary has to wait until it can send

2239
01:24:16,080 --> 01:24:17,440
the response to the

2240
01:24:17,440 --> 01:24:19,199
client until the backup actually has

2241
01:24:19,199 --> 01:24:20,880
acknowledged it

2242
01:24:20,880 --> 01:24:22,560
and so it just can't like process

2243
01:24:22,560 --> 01:24:23,920
packets at the same speed

2244
01:24:23,920 --> 01:24:27,360
as it could without actually a backup

2245
01:24:27,360 --> 01:24:28,880
and therefore you know we should see a

2246
01:24:28,880 --> 01:24:32,080
reduction in performance

2247
01:24:32,080 --> 01:24:33,440
nevertheless this performance is pretty

2248
01:24:33,440 --> 01:24:35,600
impressive but you know

2249
01:24:35,600 --> 01:24:37,760
there is a performance cost and this is

2250
01:24:37,760 --> 01:24:38,960
one reason that people

2251
01:24:38,960 --> 01:24:41,440
uh play you know this game of replicated

2252
01:24:41,440 --> 01:24:42,800
state machines not at the

2253
01:24:42,800 --> 01:24:44,560
instruction level but at like the

2254
01:24:44,560 --> 01:24:45,920
application level and

2255
01:24:45,920 --> 01:24:47,520
you'll basically be able to get higher

2256
01:24:47,520 --> 01:24:49,520
performance but that requires

2257
01:24:49,520 --> 01:24:51,120
modifications to the applications as we

2258
01:24:51,120 --> 01:24:56,310
saw in gfs

2259
01:24:56,320 --> 01:24:57,840
okay i think i'm running a little bit

2260
01:24:57,840 --> 01:24:59,280
over time so i'm going to stop right now

2261
01:24:59,280 --> 01:25:00,239
uh so that

2262
01:25:00,239 --> 01:25:02,239
and i hope people that actually uh

2263
01:25:02,239 --> 01:25:03,440
needed to leave already

2264
01:25:03,440 --> 01:25:05,679
left uh but i will stick around and so

2265
01:25:05,679 --> 01:25:06,880
if people have more questions

2266
01:25:06,880 --> 01:25:10,000
uh i'd be happy uh uh

2267
01:25:10,000 --> 01:25:13,360
to answer those and i'll talk to you on

2268
01:25:13,360 --> 01:25:14,320
tuesday

2269
01:25:14,320 --> 01:25:18,229
thank you

2270
01:25:18,239 --> 01:25:22,080
um i had a question about the previous

2271
01:25:22,080 --> 01:25:25,120
image that you drew

2272
01:25:25,120 --> 01:25:28,800
with with the uh yeah yeah that one

2273
01:25:28,800 --> 01:25:32,480
um i was confused because wasn't it

2274
01:25:32,480 --> 01:25:35,920
the case that if that number 10

2275
01:25:35,920 --> 01:25:38,239
it just sits in the memory then when we

2276
01:25:38,239 --> 01:25:40,159
do an increment

2277
01:25:40,159 --> 01:25:43,040
we don't need to send anything to the

2278
01:25:43,040 --> 01:25:45,679
backup right

2279
01:25:45,679 --> 01:25:47,199
there okay so there's two things going

2280
01:25:47,199 --> 01:25:48,719
on here so we do

2281
01:25:48,719 --> 01:25:50,320
at the at the point that the message

2282
01:25:50,320 --> 01:25:53,360
comes in like this increment comes in

2283
01:25:53,360 --> 01:25:56,800
from the client arrives at the

2284
01:25:56,800 --> 01:25:59,679
ft at the uh the hype the primary

2285
01:25:59,679 --> 01:26:01,120
hypervisor

2286
01:26:01,120 --> 01:26:04,800
it needs to forward that message to the

2287
01:26:04,800 --> 01:26:07,199
backup ft so that it can you know

2288
01:26:07,199 --> 01:26:08,239
process it if it

2289
01:26:08,239 --> 01:26:09,440
needs to be processed when it needs to

2290
01:26:09,440 --> 01:26:11,199
be processed you know when it you know

2291
01:26:11,199 --> 01:26:11,520
it

2292
01:26:11,520 --> 01:26:13,199
processes exactly at the same point in

2293
01:26:13,199 --> 01:26:14,800
this instruction stream

2294
01:26:14,800 --> 01:26:18,320
right so it sends it off and then you

2295
01:26:18,320 --> 01:26:19,920
know delivers it to the primer

2296
01:26:19,920 --> 01:26:21,199
and then the primary goes up and does

2297
01:26:21,199 --> 01:26:23,199
its thing primary you may

2298
01:26:23,199 --> 01:26:25,600
respond with a message and so the if the

2299
01:26:25,600 --> 01:26:27,040
prime response is a message

2300
01:26:27,040 --> 01:26:29,120
the output you know of that message is

2301
01:26:29,120 --> 01:26:30,080
stopped or hold

2302
01:26:30,080 --> 01:26:33,280
hel on hold into all uh the backup

2303
01:26:33,280 --> 01:26:35,440
has acknowledged the reception of this

2304
01:26:35,440 --> 01:26:39,669
increment

2305
01:26:39,679 --> 01:26:41,440
which will ensure that if the backup has

2306
01:26:41,440 --> 01:26:43,040
to take over you know whatever

2307
01:26:43,040 --> 01:26:44,639
it will process that increment first and

2308
01:26:44,639 --> 01:26:46,560
it also will be 11

2309
01:26:46,560 --> 01:26:52,070
before response is sent

2310
01:26:52,080 --> 01:26:55,360
okay okay thank you

2311
01:26:55,360 --> 01:26:58,000
welcome one thing i was kind of confused

2312
01:26:58,000 --> 01:26:59,280
about is a

2313
01:26:59,280 --> 01:27:02,719
goal of the system to uh

2314
01:27:02,719 --> 01:27:04,880
to help with like bucking up an actual

2315
01:27:04,880 --> 01:27:06,320
server where

2316
01:27:06,320 --> 01:27:07,840
because it's not easy to handle the

2317
01:27:07,840 --> 01:27:10,800
interrupts uh without a hypervisor or

2318
01:27:10,800 --> 01:27:14,159
is it actually to help distribute uh

2319
01:27:14,159 --> 01:27:17,120
virtual machines themselves it is purely

2320
01:27:17,120 --> 01:27:18,639
to make an apnea like so you have a

2321
01:27:18,639 --> 01:27:20,239
business application that runs on a

2322
01:27:20,239 --> 01:27:21,360
single machine

2323
01:27:21,360 --> 01:27:22,400
and you want to make it more fault

2324
01:27:22,400 --> 01:27:24,960
tolerant and uh

2325
01:27:24,960 --> 01:27:27,440
the what this scheme does is it makes it

2326
01:27:27,440 --> 01:27:28,400
fall down for you

2327
01:27:28,400 --> 01:27:30,639
transparently you know you run the

2328
01:27:30,639 --> 01:27:32,560
business applications and both machines

2329
01:27:32,560 --> 01:27:33,120
on the

2330
01:27:33,120 --> 01:27:35,760
on the ft hypervisor and the ft high vr

2331
01:27:35,760 --> 01:27:37,280
exerciser will assure that you know

2332
01:27:37,280 --> 01:27:38,719
basically these applications more or

2333
01:27:38,719 --> 01:27:40,080
less you know not literally

2334
01:27:40,080 --> 01:27:42,800
running lockstep but basically you know

2335
01:27:42,800 --> 01:27:43,920
you know

2336
01:27:43,920 --> 01:27:47,120
are fault tolerantly replicated so the

2337
01:27:47,120 --> 01:27:48,960
vm using the vm itself is kind of a

2338
01:27:48,960 --> 01:27:50,000
design decision

2339
01:27:50,000 --> 01:27:53,199
yes and that is a good design decision

2340
01:27:53,199 --> 01:27:53,840
because

2341
01:27:53,840 --> 01:27:55,040
it allows you to do this sort of

2342
01:27:55,040 --> 01:27:57,520
replication at a transparent level

2343
01:27:57,520 --> 01:28:02,550
got it thank you so much you're welcome

2344
01:28:02,560 --> 01:28:03,920
yeah there's a question in the chat

2345
01:28:03,920 --> 01:28:05,840
about can the uh

2346
01:28:05,840 --> 01:28:07,280
the output rule is it possible that the

2347
01:28:07,280 --> 01:28:08,800
client sees the same response twice and

2348
01:28:08,800 --> 01:28:10,480
the answer is yes

2349
01:28:10,480 --> 01:28:11,920
uh it's absolutely possible that the

2350
01:28:11,920 --> 01:28:13,520
client will see you get the

2351
01:28:13,520 --> 01:28:16,080
response twice uh and basically what

2352
01:28:16,080 --> 01:28:17,120
they argue

2353
01:28:17,120 --> 01:28:20,000
uh that's okay uh because in sort of the

2354
01:28:20,000 --> 01:28:21,600
fault model of the network

2355
01:28:21,600 --> 01:28:23,600
it is always assumed that the network

2356
01:28:23,600 --> 01:28:25,679
can actually duplicate messages anyway

2357
01:28:25,679 --> 01:28:28,400
and so protocols like tcp are totally

2358
01:28:28,400 --> 01:28:32,080
designed to deal with duplicate messages

2359
01:28:32,080 --> 01:28:35,360
so yes it's okay because of tcp

2360
01:28:35,360 --> 01:28:38,719
or whatever replication duplication

2361
01:28:38,719 --> 01:28:40,560
scheme the application uses or the

2362
01:28:40,560 --> 01:28:43,199
client uses

2363
01:28:43,199 --> 01:28:45,440
i was curious about uh cat's question

2364
01:28:45,440 --> 01:28:46,639
which is uh

2365
01:28:46,639 --> 01:28:48,800
if the primary like sort of like goes

2366
01:28:48,800 --> 01:28:50,560
down for a few minutes

2367
01:28:50,560 --> 01:28:54,400
back up goes live then sets up

2368
01:28:54,400 --> 01:28:57,760
it's uh it's its own backup you know

2369
01:28:57,760 --> 01:29:01,840
switches the bit back to like uh to zero

2370
01:29:01,840 --> 01:29:04,960
and then suddenly somehow the the

2371
01:29:04,960 --> 01:29:08,000
first primary goes back like

2372
01:29:08,000 --> 01:29:10,239
goes back oh yeah it has to be the case

2373
01:29:10,239 --> 01:29:11,360
that first crime is definitely

2374
01:29:11,360 --> 01:29:13,760
terminated it's cleaned up

2375
01:29:13,760 --> 01:29:17,360
and gone nice

2376
01:29:17,360 --> 01:29:21,510
yep thanks

2377
01:29:21,520 --> 01:29:23,520
i was gonna ask um actually something

2378
01:29:23,520 --> 01:29:24,960
similar this may be too broad of a

2379
01:29:24,960 --> 01:29:26,480
question but like will you ever need to

2380
01:29:26,480 --> 01:29:27,520
store

2381
01:29:27,520 --> 01:29:30,480
more things besides like an arbitration

2382
01:29:30,480 --> 01:29:32,000
flag in the server

2383
01:29:32,000 --> 01:29:35,199
and decide to flag an arbitration server

2384
01:29:35,199 --> 01:29:38,480
um if you have like multiple like

2385
01:29:38,480 --> 01:29:42,639
uh backups oh yeah like

2386
01:29:42,639 --> 01:29:44,560
this is a scheme tailor two and one

2387
01:29:44,560 --> 01:29:46,239
backup and not more than one backup so

2388
01:29:46,239 --> 01:29:47,840
if you had more backups you know the you

2389
01:29:47,840 --> 01:29:49,920
know

2390
01:29:49,920 --> 01:29:51,120
there's other issues that we need to

2391
01:29:51,120 --> 01:29:52,480
resolve and in fact you know we'll come

2392
01:29:52,480 --> 01:29:54,159
back to this on tuesday you know with

2393
01:29:54,159 --> 01:29:55,840
more sophisticated protocols that you

2394
01:29:55,840 --> 01:29:56,400
know handle

2395
01:29:56,400 --> 01:30:03,990
those cases much cleaner okay

2396
01:30:04,000 --> 01:30:05,360
i have one question about the

2397
01:30:05,360 --> 01:30:07,520
performance yeah

2398
01:30:07,520 --> 01:30:10,560
um so can you go back to that table

2399
01:30:10,560 --> 01:30:13,520
yeah so my question is is it the delay

2400
01:30:13,520 --> 01:30:14,239
only be

2401
01:30:14,239 --> 01:30:16,400
viewed on the first pack here like after

2402
01:30:16,400 --> 01:30:18,239
the first packet it will just flow

2403
01:30:18,239 --> 01:30:18,880
through

2404
01:30:18,880 --> 01:30:21,679
the channel and there is no extra delay

2405
01:30:21,679 --> 01:30:22,159
on

2406
01:30:22,159 --> 01:30:24,320
the link so the bandwidth should be

2407
01:30:24,320 --> 01:30:25,360
roughly the same

2408
01:30:25,360 --> 01:30:28,320
but no no okay for every packet received

2409
01:30:28,320 --> 01:30:30,000
correct by the primary you know that

2410
01:30:30,000 --> 01:30:32,480
packet has to be forwarded to the backup

2411
01:30:32,480 --> 01:30:34,320
yeah and for every response you know the

2412
01:30:34,320 --> 01:30:35,840
backup will have to wait on the primary

2413
01:30:35,840 --> 01:30:37,280
has to wait until the output

2414
01:30:37,280 --> 01:30:39,120
rule is satisfied and then it can send

2415
01:30:39,120 --> 01:30:42,070
the response

2416
01:30:42,080 --> 01:30:45,120
so there's some like processing on the

2417
01:30:45,120 --> 01:30:46,159
backups

2418
01:30:46,159 --> 01:30:48,719
backup server too before getting back to

2419
01:30:48,719 --> 01:30:49,360
the primer

2420
01:30:49,360 --> 01:30:50,719
yeah so again they talk a little bit

2421
01:30:50,719 --> 01:30:52,080
about that correct like the particular

2422
01:30:52,080 --> 01:30:53,280
crossing that needs to be done is

2423
01:30:53,280 --> 01:30:54,719
actually acknowledging the

2424
01:30:54,719 --> 01:30:56,960
uh perception of the packet on the

2425
01:30:56,960 --> 01:30:58,239
logging channel

2426
01:30:58,239 --> 01:30:59,840
and they talk a little bit about like

2427
01:30:59,840 --> 01:31:02,320
how to reduce the delay

2428
01:31:02,320 --> 01:31:03,920
to make sure that that sort of the

2429
01:31:03,920 --> 01:31:06,719
acknowledgement is very quick

2430
01:31:06,719 --> 01:31:09,520
i see i see okay thank you you're

2431
01:31:09,520 --> 01:31:10,159
welcome

2432
01:31:10,159 --> 01:31:12,000
i have a question about the the logging

2433
01:31:12,000 --> 01:31:14,639
channel so they they mentioned that they

2434
01:31:14,639 --> 01:31:17,280
they use udp um and i assume that's

2435
01:31:17,280 --> 01:31:19,040
mostly for performance

2436
01:31:19,040 --> 01:31:21,840
but then so basically if a single

2437
01:31:21,840 --> 01:31:22,800
failure happens

2438
01:31:22,800 --> 01:31:25,840
the primary like if a single packet is

2439
01:31:25,840 --> 01:31:28,239
unacknowledged then it assumes that the

2440
01:31:28,239 --> 01:31:29,360
backup failed

2441
01:31:29,360 --> 01:31:31,520
without any like re-transmission no no

2442
01:31:31,520 --> 01:31:33,600
no no uh

2443
01:31:33,600 --> 01:31:36,239
because of there's a timer interrupt uh

2444
01:31:36,239 --> 01:31:37,679
and the timer interrupt goes off

2445
01:31:37,679 --> 01:31:39,679
like every 10 milliseconds or something

2446
01:31:39,679 --> 01:31:41,120
uh the

2447
01:31:41,120 --> 01:31:43,280
there's always sort of multiple you know

2448
01:31:43,280 --> 01:31:44,560
one package is sent if that packet

2449
01:31:44,560 --> 01:31:46,000
doesn't get uh

2450
01:31:46,000 --> 01:31:48,480
there's no heartbeat coming back then it

2451
01:31:48,480 --> 01:31:49,280
will do a couple

2452
01:31:49,280 --> 01:31:50,880
of these time interrupts before it gives

2453
01:31:50,880 --> 01:31:52,400
up okay

2454
01:31:52,400 --> 01:31:55,360
and the the the heartbeats are they

2455
01:31:55,360 --> 01:31:57,600
saving from the primary or

2456
01:31:57,600 --> 01:31:58,800
it was like sort of implied it was like

2457
01:31:58,800 --> 01:32:00,800
from somewhere else in the system well

2458
01:32:00,800 --> 01:32:01,920
they sort of come from the time you're

2459
01:32:01,920 --> 01:32:03,920
in the heartbeat basically have an

2460
01:32:03,920 --> 01:32:05,199
indirect side effect

2461
01:32:05,199 --> 01:32:06,719
because every 10 milliseconds you're

2462
01:32:06,719 --> 01:32:08,080
going to send an interrupt message to

2463
01:32:08,080 --> 01:32:12,320
the overlogging channel anyway

2464
01:32:12,320 --> 01:32:15,910
i see okay

2465
01:32:15,920 --> 01:32:21,590
all right thank you thank you welcome

2466
01:32:21,600 --> 01:32:23,920
actually i wanted to follow up on that i

2467
01:32:23,920 --> 01:32:24,960
think it said that

2468
01:32:24,960 --> 01:32:28,320
it's gonna wait a couple a few seconds

2469
01:32:28,320 --> 01:32:30,639
to go yeah we'll wait a while you know

2470
01:32:30,639 --> 01:32:32,320
we'll do a couple heartbeats and wait a

2471
01:32:32,320 --> 01:32:33,840
while and if there's really none of them

2472
01:32:33,840 --> 01:32:34,639
to go through

2473
01:32:34,639 --> 01:32:37,679
then it will stop okay and

2474
01:32:37,679 --> 01:32:39,760
is there is a few seconds that's that's

2475
01:32:39,760 --> 01:32:41,040
a lot right

2476
01:32:41,040 --> 01:32:42,239
yeah i don't remember exactly all the

2477
01:32:42,239 --> 01:32:43,760
numbers uh so you could be right in a

2478
01:32:43,760 --> 01:32:45,120
few seconds i would imagine it's a

2479
01:32:45,120 --> 01:32:47,360
little bit shorter but maybe it's not

2480
01:32:47,360 --> 01:32:49,679
clear i think is that like something in

2481
01:32:49,679 --> 01:32:52,480
the order of a few seconds but

2482
01:32:52,480 --> 01:32:56,800
is it bad that was for the cloning

2483
01:32:56,800 --> 01:33:01,520
but you know i can remember the right

