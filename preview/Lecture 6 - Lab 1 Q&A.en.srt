1
00:00:05,279 --> 00:00:06,319
all right

2
00:00:06,319 --> 00:00:08,240
well it's five after so i'll just go

3
00:00:08,240 --> 00:00:10,160
ahead and get started so today's

4
00:00:10,160 --> 00:00:13,679
lecture is a q a on the first lab the

5
00:00:13,679 --> 00:00:14,960
mapreduce lab

6
00:00:14,960 --> 00:00:18,320
and also some just general coding q as

7
00:00:18,320 --> 00:00:20,080
for go programming that might help in

8
00:00:20,080 --> 00:00:22,720
future labs so feel free to stop at any

9
00:00:22,720 --> 00:00:23,279
time or

10
00:00:23,279 --> 00:00:24,880
put questions in the chat and i'll be

11
00:00:24,880 --> 00:00:27,199
checking it um occasionally

12
00:00:27,199 --> 00:00:29,039
and i'm sure like the other case can

13
00:00:29,039 --> 00:00:31,519
also um help as well

14
00:00:31,519 --> 00:00:34,320
uh if you are unmuted and typing it

15
00:00:34,320 --> 00:00:37,680
would be helpful if you meet yourself

16
00:00:37,680 --> 00:00:40,559
but yeah all right so the agenda for

17
00:00:40,559 --> 00:00:42,000
today the first thing we're i'm going to

18
00:00:42,000 --> 00:00:43,760
do is actually walk through a solution

19
00:00:43,760 --> 00:00:44,879
of lab one

20
00:00:44,879 --> 00:00:48,160
and this is my personal solution um it's

21
00:00:48,160 --> 00:00:50,640
probably not perfect but it's an example

22
00:00:50,640 --> 00:00:52,480
of what you could have done

23
00:00:52,480 --> 00:00:54,320
um second we're going to discuss some

24
00:00:54,320 --> 00:00:56,719
alternative solution designs

25
00:00:56,719 --> 00:01:07,270
uh

26
00:01:07,280 --> 00:01:09,920
um third we're going to discuss some of

27
00:01:09,920 --> 00:01:11,520
the common design mistakes and

28
00:01:11,520 --> 00:01:13,520
some of the bugs that you guys had in

29
00:01:13,520 --> 00:01:14,880
your solutions

30
00:01:14,880 --> 00:01:17,680
um four just go over some general tips

31
00:01:17,680 --> 00:01:18,799
and then finally

32
00:01:18,799 --> 00:01:21,119
we're going to if there's time go

33
00:01:21,119 --> 00:01:23,119
through some q and a's both

34
00:01:23,119 --> 00:01:25,759
questions you might have right now and

35
00:01:25,759 --> 00:01:26,720
also

36
00:01:26,720 --> 00:01:30,000
questions that you submitted um before

37
00:01:30,000 --> 00:01:31,759
lecture

38
00:01:31,759 --> 00:01:34,240
so first for the lab solution

39
00:01:34,240 --> 00:01:35,600
walkthrough

40
00:01:35,600 --> 00:01:38,640
um let me know if the font's too small

41
00:01:38,640 --> 00:01:40,960
um if now i'll just stick with this all

42
00:01:40,960 --> 00:01:42,079
right so

43
00:01:42,079 --> 00:01:46,320
i basically uh went step by step

44
00:01:46,320 --> 00:01:47,840
and i'll show how i developed my

45
00:01:47,840 --> 00:01:50,799
solution so the first thing i did

46
00:01:50,799 --> 00:01:54,479
was this is rpc.go and the first thing i

47
00:01:54,479 --> 00:01:55,360
did was

48
00:01:55,360 --> 00:01:57,920
figure out the api in which i wanted my

49
00:01:57,920 --> 00:02:00,399
worker and coordinator to communicate

50
00:02:00,399 --> 00:02:04,399
and so the first thing i did was define

51
00:02:04,399 --> 00:02:06,880
what types of tasks there are and so

52
00:02:06,880 --> 00:02:08,560
there are map and reduce tests and

53
00:02:08,560 --> 00:02:11,360
in order to signal that the coordinator

54
00:02:11,360 --> 00:02:11,840
has

55
00:02:11,840 --> 00:02:13,760
things the job is done there's a done

56
00:02:13,760 --> 00:02:14,879
test

57
00:02:14,879 --> 00:02:18,000
and so these are the types of tap so

58
00:02:18,000 --> 00:02:20,160
you zoom in a bit can you zoom in a bit

59
00:02:20,160 --> 00:02:21,520
oh yeah the fine

60
00:02:21,520 --> 00:02:26,229
yeah uh is that that good

61
00:02:26,239 --> 00:02:29,680
all right yeah thanks cool

62
00:02:29,680 --> 00:02:31,920
yeah it's hard for me to tell how it

63
00:02:31,920 --> 00:02:34,790
looks

64
00:02:34,800 --> 00:02:37,920
hopefully this is good um

65
00:02:37,920 --> 00:02:41,840
and so the there are two rpcs i decided

66
00:02:41,840 --> 00:02:42,720
to implement

67
00:02:42,720 --> 00:02:44,640
the first is a worker asking the

68
00:02:44,640 --> 00:02:46,480
coordinator to give it a task

69
00:02:46,480 --> 00:02:49,280
so one of math reduce or done and please

70
00:02:49,280 --> 00:02:50,400
exit

71
00:02:50,400 --> 00:02:53,680
and basically there's like the arguments

72
00:02:53,680 --> 00:02:55,120
you don't really have to put any

73
00:02:55,120 --> 00:02:56,800
arguments or you're just asking for a

74
00:02:56,800 --> 00:02:57,680
task

75
00:02:57,680 --> 00:03:00,400
and the coordinator replies with what

76
00:03:00,400 --> 00:03:01,440
task is this

77
00:03:01,440 --> 00:03:05,120
which task of that type should you do

78
00:03:05,120 --> 00:03:08,239
and also some extra data that's needed

79
00:03:08,239 --> 00:03:10,640
for the map or reduced tests such as the

80
00:03:10,640 --> 00:03:12,640
number of map tests in the system

81
00:03:12,640 --> 00:03:15,920
or the number of reduced tasks and the

82
00:03:15,920 --> 00:03:16,959
second rpc

83
00:03:16,959 --> 00:03:19,680
is a finished task rpc that the worker

84
00:03:19,680 --> 00:03:21,840
uses to notify the coordinator

85
00:03:21,840 --> 00:03:25,120
that it has finished the task and it

86
00:03:25,120 --> 00:03:27,200
passes in as arguments which task it has

87
00:03:27,200 --> 00:03:28,319
finished

88
00:03:28,319 --> 00:03:30,000
and they don't actually really need to

89
00:03:30,000 --> 00:03:32,560
get reply for this so that's the first

90
00:03:32,560 --> 00:03:33,200
step

91
00:03:33,200 --> 00:03:38,309
um of the implementation

92
00:03:38,319 --> 00:03:42,319
so hi all right so as a second step

93
00:03:42,319 --> 00:03:44,640
what i did is implement the handlers for

94
00:03:44,640 --> 00:03:46,080
all these rpcs

95
00:03:46,080 --> 00:03:49,120
and so that's in coordinator

96
00:03:49,120 --> 00:03:52,080
so first i had to actually populate the

97
00:03:52,080 --> 00:03:54,080
coordinator with the coordinator state

98
00:03:54,080 --> 00:03:56,239
and so there's the mutex which protects

99
00:03:56,239 --> 00:03:57,760
the state from concurrent access

100
00:03:57,760 --> 00:03:58,879
because the coordinator will have

101
00:03:58,879 --> 00:04:00,879
multiple threads running um

102
00:04:00,879 --> 00:04:03,920
concurrently then the second uh

103
00:04:03,920 --> 00:04:06,319
part is to keep track of just like the

104
00:04:06,319 --> 00:04:08,000
files that we need for map tests

105
00:04:08,000 --> 00:04:10,640
and the number of map and reduced tests

106
00:04:10,640 --> 00:04:12,319
and

107
00:04:12,319 --> 00:04:15,519
this metadata is used to track which

108
00:04:15,519 --> 00:04:16,959
tasks have we issued

109
00:04:16,959 --> 00:04:20,160
and which tasks have finished um

110
00:04:20,160 --> 00:04:22,079
the ones that we've issued we keep track

111
00:04:22,079 --> 00:04:23,840
of a timestamp so that we know

112
00:04:23,840 --> 00:04:25,440
if these tasks haven't completed within

113
00:04:25,440 --> 00:04:28,240
a certain amount of time to reissue them

114
00:04:28,240 --> 00:04:32,560
and finally we have um the like has all

115
00:04:32,560 --> 00:04:36,800
has the coordinator finished um boolean

116
00:04:36,800 --> 00:04:39,600
so to handle the get task rpc we have a

117
00:04:39,600 --> 00:04:40,479
handler

118
00:04:40,479 --> 00:04:43,600
that um essentially what it does

119
00:04:43,600 --> 00:04:46,800
is it will set the reply fields

120
00:04:46,800 --> 00:04:49,680
right now i haven't yet implemented the

121
00:04:49,680 --> 00:04:51,919
part that actually issues the tests

122
00:04:51,919 --> 00:04:54,479
and if all the math and reduce tests are

123
00:04:54,479 --> 00:04:55,040
done

124
00:04:55,040 --> 00:04:57,520
it will send a done task to the worker

125
00:04:57,520 --> 00:04:59,199
and exit

126
00:04:59,199 --> 00:05:02,479
um and then we have the the

127
00:05:02,479 --> 00:05:05,840
handler for the finish finished rpc

128
00:05:05,840 --> 00:05:08,479
and what this does is it basically

129
00:05:08,479 --> 00:05:10,960
depending on what task it was

130
00:05:10,960 --> 00:05:14,479
sets that uh flag to true that it has

131
00:05:14,479 --> 00:05:15,199
that

132
00:05:15,199 --> 00:05:18,560
task has finished so that's the second

133
00:05:18,560 --> 00:05:18,960
step

134
00:05:18,960 --> 00:05:20,479
which is implementing the handlers with

135
00:05:20,479 --> 00:05:24,080
our pcs

136
00:05:24,080 --> 00:05:27,120
so the third step i have is um

137
00:05:27,120 --> 00:05:30,320
actually sending the rpcs and

138
00:05:30,320 --> 00:05:36,830
so that happened isn't the work

139
00:05:36,840 --> 00:05:40,629
so

140
00:05:40,639 --> 00:05:43,440
top of this is what we provided what it

141
00:05:43,440 --> 00:05:45,440
does is it starts up this loop

142
00:05:45,440 --> 00:05:49,199
that basically for every loop it calls

143
00:05:49,199 --> 00:05:51,280
the handler forget task in the

144
00:05:51,280 --> 00:05:52,720
coordinator

145
00:05:52,720 --> 00:05:54,400
and depending on what task it gets it

146
00:05:54,400 --> 00:05:56,400
will either perform the map task

147
00:05:56,400 --> 00:05:59,120
with the relevant data or metadata that

148
00:05:59,120 --> 00:06:00,000
it needs

149
00:06:00,000 --> 00:06:01,680
perform the reduced task or in the case

150
00:06:01,680 --> 00:06:04,319
of done it will exit

151
00:06:04,319 --> 00:06:06,000
and so that's very simple and once it's

152
00:06:06,000 --> 00:06:07,919
finished that task it will send

153
00:06:07,919 --> 00:06:11,680
a finished task rpc to the coordinator

154
00:06:11,680 --> 00:06:15,520
so this is just the skeleton code for

155
00:06:15,520 --> 00:06:18,960
the worker sending rpcs

156
00:06:18,960 --> 00:06:20,560
all right so we have rpcs we have the

157
00:06:20,560 --> 00:06:22,240
handlers we have the senders

158
00:06:22,240 --> 00:06:24,080
and so now let's actually like implement

159
00:06:24,080 --> 00:06:25,280
some stuff

160
00:06:25,280 --> 00:06:28,710
so

161
00:06:28,720 --> 00:06:32,080
in step four it's i just added

162
00:06:32,080 --> 00:06:34,880
a ton of handlers to manage this

163
00:06:34,880 --> 00:06:35,919
intermediate file

164
00:06:35,919 --> 00:06:39,120
stuff which a lot of you also did

165
00:06:39,120 --> 00:06:42,080
and basically it uses like os rename it

166
00:06:42,080 --> 00:06:44,240
gets like a temporary file

167
00:06:44,240 --> 00:06:47,199
um so it's not super interesting and

168
00:06:47,199 --> 00:06:48,479
then the next step

169
00:06:48,479 --> 00:06:50,560
let's actually implement some of the

170
00:06:50,560 --> 00:06:52,400
worker functionality

171
00:06:52,400 --> 00:06:56,000
so we're back in the worker

172
00:06:56,000 --> 00:06:58,240
and now let's implement the perform map

173
00:06:58,240 --> 00:07:00,240
function

174
00:07:00,240 --> 00:07:03,599
and what this does is as many of you

175
00:07:03,599 --> 00:07:04,319
have to do

176
00:07:04,319 --> 00:07:07,759
it reads the file maps them to keys

177
00:07:07,759 --> 00:07:10,000
and then creates temporary files writes

178
00:07:10,000 --> 00:07:11,039
them to

179
00:07:11,039 --> 00:07:13,120
the intermediate files and then we use

180
00:07:13,120 --> 00:07:15,039
an atomic rename

181
00:07:15,039 --> 00:07:17,440
to ensure that maps aren't conflicting

182
00:07:17,440 --> 00:07:20,560
as they process the keys and write them

183
00:07:20,560 --> 00:07:23,680
so this is pretty much taken from

184
00:07:23,680 --> 00:07:25,919
the sequential implementation and how

185
00:07:25,919 --> 00:07:28,479
you would apply the map function

186
00:07:28,479 --> 00:07:32,560
and then similarly we

187
00:07:32,560 --> 00:07:35,599
implement the reduce function so

188
00:07:35,599 --> 00:07:37,520
here's the format and then we have

189
00:07:37,520 --> 00:07:38,960
perform reduce

190
00:07:38,960 --> 00:07:40,960
and so what that does is it gets all the

191
00:07:40,960 --> 00:07:42,960
intermediate files um

192
00:07:42,960 --> 00:07:45,759
with the appropriate uh from all the map

193
00:07:45,759 --> 00:07:46,319
tests

194
00:07:46,319 --> 00:07:50,240
uh for this reduced task and sorts them

195
00:07:50,240 --> 00:07:53,599
so the sorting happens in the

196
00:07:53,599 --> 00:07:56,720
in the worker because the worker needs

197
00:07:56,720 --> 00:07:59,360
the reducer needs access to all keys of

198
00:07:59,360 --> 00:08:00,000
that type

199
00:08:00,000 --> 00:08:03,280
and then to sort them i

200
00:08:03,280 --> 00:08:04,800
it wouldn't make sense for the mapper to

201
00:08:04,800 --> 00:08:07,039
sort them before because the mapper only

202
00:08:07,039 --> 00:08:10,319
has access to a subset of the keys

203
00:08:10,319 --> 00:08:12,400
and then we apply the reduce function to

204
00:08:12,400 --> 00:08:13,759
all values of the same key

205
00:08:13,759 --> 00:08:16,240
and then we atomically rename the

206
00:08:16,240 --> 00:08:18,000
temporary reduced file to the

207
00:08:18,000 --> 00:08:21,199
final reduce file so now

208
00:08:21,199 --> 00:08:24,879
this loop we've implemented basically

209
00:08:24,879 --> 00:08:28,400
the actual performance of the task and

210
00:08:28,400 --> 00:08:29,840
we're basically done with the worker

211
00:08:29,840 --> 00:08:31,759
implementation

212
00:08:31,759 --> 00:08:34,159
so one last step remains um and that's

213
00:08:34,159 --> 00:08:35,440
actually implementing

214
00:08:35,440 --> 00:08:37,919
how this coordinator tells the worker

215
00:08:37,919 --> 00:08:39,519
which task to do

216
00:08:39,519 --> 00:08:42,640
and this is probably where um

217
00:08:42,640 --> 00:08:45,120
you ran into the most uh complexity with

218
00:08:45,120 --> 00:08:46,000
synchronization

219
00:08:46,000 --> 00:08:49,440
in the coordinator so let's go back to

220
00:08:49,440 --> 00:08:51,440
the coordinator

221
00:08:51,440 --> 00:08:54,959
so nothing has changed in the state

222
00:08:54,959 --> 00:08:56,880
so but now what we've done is we've

223
00:08:56,880 --> 00:08:58,720
added a loop in the coordinator

224
00:08:58,720 --> 00:09:00,720
that handles sending the test to the

225
00:09:00,720 --> 00:09:02,640
worker

226
00:09:02,640 --> 00:09:05,760
and um when we're

227
00:09:05,760 --> 00:09:08,160
issuing the map tests so first we want

228
00:09:08,160 --> 00:09:09,680
to issue all the math tasks

229
00:09:09,680 --> 00:09:12,320
and so essentially what this loop does

230
00:09:12,320 --> 00:09:13,440
here

231
00:09:13,440 --> 00:09:16,880
is until there's a task to issue

232
00:09:16,880 --> 00:09:20,560
the coordinator will just

233
00:09:20,560 --> 00:09:22,800
iterate through this loop and if we're

234
00:09:22,800 --> 00:09:24,080
done with all the map tests then we'll

235
00:09:24,080 --> 00:09:26,640
break out the loop

236
00:09:26,640 --> 00:09:28,399
and then if all the map tests are done

237
00:09:28,399 --> 00:09:31,040
then we issue a reduced test

238
00:09:31,040 --> 00:09:35,350
which is what's done here

239
00:09:35,360 --> 00:09:38,399
so oh yeah i have

240
00:09:38,399 --> 00:09:41,519
i guess i have one last step which is

241
00:09:41,519 --> 00:09:44,480
actually what we do when the maps or the

242
00:09:44,480 --> 00:09:45,600
reduces

243
00:09:45,600 --> 00:09:48,480
um when there's no task to issue and so

244
00:09:48,480 --> 00:09:50,000
what we want to do then

245
00:09:50,000 --> 00:09:52,480
is the coordinator should just wait for

246
00:09:52,480 --> 00:09:53,920
a task to issue

247
00:09:53,920 --> 00:09:56,880
and once it there's a test issue it'll

248
00:09:56,880 --> 00:09:58,720
do another iteration through the loop

249
00:09:58,720 --> 00:10:01,839
and then actually issue the task

250
00:10:01,839 --> 00:10:03,600
and i'll continue until all the map or

251
00:10:03,600 --> 00:10:06,720
all the reduced tests are done

252
00:10:06,720 --> 00:10:08,560
and if they're done it'll return again

253
00:10:08,560 --> 00:10:13,590
so

254
00:10:13,600 --> 00:10:17,120
all right so in order to support

255
00:10:17,120 --> 00:10:21,040
that weighting what my solution

256
00:10:21,040 --> 00:10:24,640
does is it uses a condition variable

257
00:10:24,640 --> 00:10:27,760
um and

258
00:10:27,760 --> 00:10:30,399
essentially what that does is if there

259
00:10:30,399 --> 00:10:31,360
are no

260
00:10:31,360 --> 00:10:34,880
map tests to issue but the mappers

261
00:10:34,880 --> 00:10:38,959
um but they're uh because we've assigned

262
00:10:38,959 --> 00:10:39,519
all them

263
00:10:39,519 --> 00:10:41,519
for example and we're waiting for them

264
00:10:41,519 --> 00:10:43,440
and they haven't timed out yet

265
00:10:43,440 --> 00:10:46,640
then what we want to do is wait um

266
00:10:46,640 --> 00:10:49,120
because we cannot issue a reduced task

267
00:10:49,120 --> 00:10:51,120
if all the mappers have not finished

268
00:10:51,120 --> 00:10:53,519
so we're just going to wait here and

269
00:10:53,519 --> 00:10:55,040
then once we get

270
00:10:55,040 --> 00:10:57,120
some type of signal we're just going to

271
00:10:57,120 --> 00:10:59,040
go back to the top of this loop

272
00:10:59,040 --> 00:11:00,560
and check whether we can issue a task

273
00:11:00,560 --> 00:11:02,640
again

274
00:11:02,640 --> 00:11:05,760
similarly if all the reducers aren't

275
00:11:05,760 --> 00:11:07,760
done but we can't actually issue the

276
00:11:07,760 --> 00:11:11,200
worker task we're going to wait for

277
00:11:11,200 --> 00:11:12,800
there to be some type of signal so when

278
00:11:12,800 --> 00:11:15,279
does the signal actually happen

279
00:11:15,279 --> 00:11:19,360
well we want to signal any time

280
00:11:19,360 --> 00:11:22,160
either a task has gone on for too long

281
00:11:22,160 --> 00:11:23,600
and we haven't heard back so there might

282
00:11:23,600 --> 00:11:25,360
have been a failure

283
00:11:25,360 --> 00:11:28,959
or if the if a worker has actually

284
00:11:28,959 --> 00:11:29,920
completed a test

285
00:11:29,920 --> 00:11:31,600
because for example that might mean all

286
00:11:31,600 --> 00:11:33,200
the math tests have finished and we can

287
00:11:33,200 --> 00:11:35,440
move on to a reduced task

288
00:11:35,440 --> 00:11:38,640
so in order to um

289
00:11:38,640 --> 00:11:44,870
do that what we have are

290
00:11:44,880 --> 00:11:48,160
we have a guru team here that's

291
00:11:48,160 --> 00:11:52,000
uh kind of spun off immediately as the

292
00:11:52,000 --> 00:11:53,680
coordinator starts

293
00:11:53,680 --> 00:11:55,680
and what this does is every once in a

294
00:11:55,680 --> 00:11:56,800
while

295
00:11:56,800 --> 00:11:59,680
um after some you know maybe every

296
00:11:59,680 --> 00:12:00,800
second or so

297
00:12:00,800 --> 00:12:03,279
when a task might not have finished or

298
00:12:03,279 --> 00:12:04,000
maybe this is

299
00:12:04,000 --> 00:12:05,839
10 seconds i can't remember actually it

300
00:12:05,839 --> 00:12:07,680
doesn't really matter it just wants to

301
00:12:07,680 --> 00:12:09,200
wake up the coordinator every so often

302
00:12:09,200 --> 00:12:10,399
so the coordinator

303
00:12:10,399 --> 00:12:12,320
will do another check to see whether

304
00:12:12,320 --> 00:12:14,000
there is a task to issue

305
00:12:14,000 --> 00:12:16,800
and so this just loops around and every

306
00:12:16,800 --> 00:12:18,160
second it will broadcast

307
00:12:18,160 --> 00:12:22,560
to wake up the coordinator um

308
00:12:22,560 --> 00:12:25,120
and the other time we want to signal is

309
00:12:25,120 --> 00:12:27,040
when a task is finished

310
00:12:27,040 --> 00:12:29,279
so that's actually going to happen in

311
00:12:29,279 --> 00:12:30,800
this handle finish task

312
00:12:30,800 --> 00:12:34,560
which is called when a a worker

313
00:12:34,560 --> 00:12:37,600
like senza i finished a task our pc

314
00:12:37,600 --> 00:12:40,800
and so here we have a broadcast right

315
00:12:40,800 --> 00:12:41,360
after

316
00:12:41,360 --> 00:12:45,200
we set the fields to done

317
00:12:45,200 --> 00:12:48,880
or to completed to done and

318
00:12:48,880 --> 00:12:51,440
when the coordinator goes back to go

319
00:12:51,440 --> 00:12:52,959
check one of these loops and see whether

320
00:12:52,959 --> 00:12:54,240
there's a task to

321
00:12:54,240 --> 00:12:57,279
finish it will see that updated done

322
00:12:57,279 --> 00:12:59,120
status

323
00:12:59,120 --> 00:13:02,480
so that's essentially my solution

324
00:13:02,480 --> 00:13:07,760
um it uses convars and mutexes to

325
00:13:07,760 --> 00:13:10,880
protect shared state of the coordinator

326
00:13:10,880 --> 00:13:13,519
so this is only one possible solution

327
00:13:13,519 --> 00:13:14,000
and

328
00:13:14,000 --> 00:13:17,839
i'll get back to here

329
00:13:17,839 --> 00:13:20,959
and so this is the the kind of layout of

330
00:13:20,959 --> 00:13:23,040
the steps i took

331
00:13:23,040 --> 00:13:25,200
are there any questions on that

332
00:13:25,200 --> 00:13:31,110
particular solution before i move on

333
00:13:31,120 --> 00:13:33,120
can you please elaborate a little more

334
00:13:33,120 --> 00:13:36,800
on the conditional variable

335
00:13:36,800 --> 00:13:40,389
sure um

336
00:13:40,399 --> 00:13:44,000
so uh what exactly so i guess like

337
00:13:44,000 --> 00:13:48,240
you a conditional variable is very

338
00:13:48,240 --> 00:13:48,880
useful

339
00:13:48,880 --> 00:13:50,480
for when you want to wait for a

340
00:13:50,480 --> 00:13:52,000
particular predicate

341
00:13:52,000 --> 00:13:55,440
or particular condition to become true

342
00:13:55,440 --> 00:13:58,880
so in this case a condition variable

343
00:13:58,880 --> 00:14:02,560
is a natural let me just

344
00:14:02,560 --> 00:14:05,600
go to wherever i use this um is a

345
00:14:05,600 --> 00:14:06,480
natural

346
00:14:06,480 --> 00:14:09,519
way to implement waiting for there to be

347
00:14:09,519 --> 00:14:11,279
a task available

348
00:14:11,279 --> 00:14:13,519
because you know it's a particular

349
00:14:13,519 --> 00:14:14,639
condition

350
00:14:14,639 --> 00:14:18,160
and it occurs

351
00:14:18,160 --> 00:14:21,360
asynchronously so for example a task is

352
00:14:21,360 --> 00:14:22,399
available

353
00:14:22,399 --> 00:14:25,440
when a worker has finished a task

354
00:14:25,440 --> 00:14:28,800
um or a task might be available

355
00:14:28,800 --> 00:14:31,839
when the um

356
00:14:31,839 --> 00:14:34,480
when a failure occurs and we need to

357
00:14:34,480 --> 00:14:35,920
reissue the task

358
00:14:35,920 --> 00:14:40,399
so you can think of any case in which

359
00:14:40,399 --> 00:14:43,920
a you need to wait for a particular

360
00:14:43,920 --> 00:14:44,720
condition

361
00:14:44,720 --> 00:14:47,120
that's where condition variables become

362
00:14:47,120 --> 00:14:48,560
very helpful

363
00:14:48,560 --> 00:14:52,160
um does that help a little bit

364
00:14:52,160 --> 00:14:55,990
yeah thank you

365
00:14:56,000 --> 00:14:59,920
you can also uh like all of these

366
00:14:59,920 --> 00:15:01,600
higher level like channels condition

367
00:15:01,600 --> 00:15:03,040
variables um

368
00:15:03,040 --> 00:15:04,399
all these higher level synchronization

369
00:15:04,399 --> 00:15:06,079
perimeters are actually they're

370
00:15:06,079 --> 00:15:08,560
built on top of blocks so they're all

371
00:15:08,560 --> 00:15:10,000
implemented using locks

372
00:15:10,000 --> 00:15:13,199
it's just their uh kind of like a higher

373
00:15:13,199 --> 00:15:14,560
level way of thinking about

374
00:15:14,560 --> 00:15:15,920
synchronization that allows you to

375
00:15:15,920 --> 00:15:16,399
reason

376
00:15:16,399 --> 00:15:22,069
for example about conditions

377
00:15:22,079 --> 00:15:24,639
um would that have the same effect as

378
00:15:24,639 --> 00:15:26,399
for example sleeping

379
00:15:26,399 --> 00:15:29,759
in that loop that you have in the

380
00:15:29,759 --> 00:15:32,079
um in the get task function instead of

381
00:15:32,079 --> 00:15:33,440
like having

382
00:15:33,440 --> 00:15:36,959
a condition variable that

383
00:15:36,959 --> 00:15:40,240
makes the loop run every second

384
00:15:40,240 --> 00:15:43,759
i guess yeah so it it is

385
00:15:43,759 --> 00:15:45,199
like it's essentially the same as

386
00:15:45,199 --> 00:15:47,199
sleeping um

387
00:15:47,199 --> 00:15:50,480
the so

388
00:15:50,480 --> 00:15:55,759
the uh loop here the timeout loop here

389
00:15:55,759 --> 00:15:58,959
the difference is that

390
00:15:58,959 --> 00:16:01,759
for example the condition variable or

391
00:16:01,759 --> 00:16:03,600
you could be woken up

392
00:16:03,600 --> 00:16:07,199
by a test that has completed where in a

393
00:16:07,199 --> 00:16:08,079
loop in which you

394
00:16:08,079 --> 00:16:10,240
sleep for example a second every single

395
00:16:10,240 --> 00:16:11,199
loop

396
00:16:11,199 --> 00:16:14,480
you have to wait a second whereas

397
00:16:14,480 --> 00:16:16,160
with a conditioned variable you could be

398
00:16:16,160 --> 00:16:18,240
woken up after you know like

399
00:16:18,240 --> 00:16:20,079
10 milliseconds because the worker has

400
00:16:20,079 --> 00:16:21,600
completed a test

401
00:16:21,600 --> 00:16:24,880
so it potentially has better liveness

402
00:16:24,880 --> 00:16:27,990
properties

403
00:16:28,000 --> 00:16:30,639
but in this case we do like say if every

404
00:16:30,639 --> 00:16:31,040
task

405
00:16:31,040 --> 00:16:34,639
always takes over like five seconds or

406
00:16:34,639 --> 00:16:35,440
something

407
00:16:35,440 --> 00:16:38,639
then yes this is essentially

408
00:16:38,639 --> 00:16:41,199
very similar to sleeping for one second

409
00:16:41,199 --> 00:16:43,600
every loop

410
00:16:43,600 --> 00:16:46,240
thanks i have a question i think i

411
00:16:46,240 --> 00:16:48,800
missed the part where you um

412
00:16:48,800 --> 00:16:51,839
how you handle uh when uh like a request

413
00:16:51,839 --> 00:16:52,880
comes for a task

414
00:16:52,880 --> 00:16:55,199
but you're like there's no tasks to give

415
00:16:55,199 --> 00:16:56,800
out currently like do you

416
00:16:56,800 --> 00:16:58,959
how do you tell the worker to like sort

417
00:16:58,959 --> 00:17:00,800
of either come back or do you

418
00:17:00,800 --> 00:17:03,120
keep them waiting and sort of

419
00:17:03,120 --> 00:17:04,319
tangentially to that

420
00:17:04,319 --> 00:17:07,760
um i'm curious why you chose this like

421
00:17:07,760 --> 00:17:08,559
sleep

422
00:17:08,559 --> 00:17:11,600
uh way of doing it instead of just like

423
00:17:11,600 --> 00:17:13,520
checking the time when you get

424
00:17:13,520 --> 00:17:16,559
a request for tasks and seeing like when

425
00:17:16,559 --> 00:17:17,439
you get a request

426
00:17:17,439 --> 00:17:20,720
what has timed out and reissuing it then

427
00:17:20,720 --> 00:17:24,559
instead of like constantly checking

428
00:17:24,559 --> 00:17:28,640
yeah okay so yeah so um i'll just your

429
00:17:28,640 --> 00:17:33,200
first question first um so basically

430
00:17:33,200 --> 00:17:36,000
how i handle the i've completed the task

431
00:17:36,000 --> 00:17:37,039
um

432
00:17:37,039 --> 00:17:40,320
is uh

433
00:17:40,320 --> 00:17:42,400
once all map tests have finished once

434
00:17:42,400 --> 00:17:43,360
all reduced half

435
00:17:43,360 --> 00:17:46,480
tests have finished then the test that

436
00:17:46,480 --> 00:17:47,120
we

437
00:17:47,120 --> 00:17:49,120
returned to the worker because the

438
00:17:49,120 --> 00:17:50,240
worker has called us

439
00:17:50,240 --> 00:17:53,440
um to ask for a task is this

440
00:17:53,440 --> 00:17:56,640
extra task type that i called done

441
00:17:56,640 --> 00:18:00,480
um and then i also set the coordinator

442
00:18:00,480 --> 00:18:02,160
is done to true

443
00:18:02,160 --> 00:18:04,000
and so in the worker so i'll go to the

444
00:18:04,000 --> 00:18:05,440
worker now

445
00:18:05,440 --> 00:18:08,960
in the worker we have um

446
00:18:08,960 --> 00:18:11,679
this loop that basically as the worker

447
00:18:11,679 --> 00:18:12,880
is asking for

448
00:18:12,880 --> 00:18:16,400
tests if it gets returned a task

449
00:18:16,400 --> 00:18:19,520
is a done test then it exits um

450
00:18:19,520 --> 00:18:21,520
so that's how i handle conveying to the

451
00:18:21,520 --> 00:18:23,840
worker that it should exit

452
00:18:23,840 --> 00:18:26,880
i guess i was asking like sorry if you

453
00:18:26,880 --> 00:18:27,520
know let's say

454
00:18:27,520 --> 00:18:29,120
uh you're still finishing up all your

455
00:18:29,120 --> 00:18:30,880
map tasks and

456
00:18:30,880 --> 00:18:33,360
you get requests for a task and you

457
00:18:33,360 --> 00:18:35,840
still can't give out your reduced tasks

458
00:18:35,840 --> 00:18:39,280
how do you tell the worker oh so that's

459
00:18:39,280 --> 00:18:42,880
um a lot of you are

460
00:18:42,880 --> 00:18:46,400
um an alternative design is to basically

461
00:18:46,400 --> 00:18:48,320
if the worker if there's no task to give

462
00:18:48,320 --> 00:18:49,520
the worker

463
00:18:49,520 --> 00:18:52,720
then the coordinator returns or reply to

464
00:18:52,720 --> 00:18:54,240
the worker immediately

465
00:18:54,240 --> 00:18:57,600
and the worker sleeps in its loop but

466
00:18:57,600 --> 00:18:59,679
you can see here right the worker loop

467
00:18:59,679 --> 00:19:01,679
there is no sleep

468
00:19:01,679 --> 00:19:04,640
and the reason for this is because this

469
00:19:04,640 --> 00:19:05,120
call

470
00:19:05,120 --> 00:19:09,039
will block until the coordinator replies

471
00:19:09,039 --> 00:19:12,240
and in my solution uh going back to the

472
00:19:12,240 --> 00:19:13,600
coordinator

473
00:19:13,600 --> 00:19:17,120
for example like if we look at not done

474
00:19:17,120 --> 00:19:20,720
in this solution the coordinator handler

475
00:19:20,720 --> 00:19:24,000
will not return that reply

476
00:19:24,000 --> 00:19:27,440
to that call unless it has a test

477
00:19:27,440 --> 00:19:30,799
to return so it's we're waiting in the

478
00:19:30,799 --> 00:19:32,080
coordinator

479
00:19:32,080 --> 00:19:35,360
rather than in the worker um so the

480
00:19:35,360 --> 00:19:37,280
coordinator is the one

481
00:19:37,280 --> 00:19:39,520
that is constantly checking to see

482
00:19:39,520 --> 00:19:41,280
whether there's a task

483
00:19:41,280 --> 00:19:43,840
and sleeping where whereas the worker

484
00:19:43,840 --> 00:19:44,320
just

485
00:19:44,320 --> 00:19:47,679
simply blocks on this call until the

486
00:19:47,679 --> 00:19:49,600
coordinator returns to it

487
00:19:49,600 --> 00:19:52,480
is it is there any advantage to doing it

488
00:19:52,480 --> 00:19:52,880
um

489
00:19:52,880 --> 00:19:59,669
in the coordinator um

490
00:19:59,679 --> 00:20:04,950
so i think one advantage is that

491
00:20:04,960 --> 00:20:08,080
all the workers aren't constantly

492
00:20:08,080 --> 00:20:10,960
sending rpcs you send an rbc it's one

493
00:20:10,960 --> 00:20:11,760
rpc

494
00:20:11,760 --> 00:20:14,960
per task right right um whereas if the

495
00:20:14,960 --> 00:20:16,240
worker is constantly looping and

496
00:20:16,240 --> 00:20:17,120
sleeping

497
00:20:17,120 --> 00:20:18,640
and constantly replying you have a lot

498
00:20:18,640 --> 00:20:21,520
more network traffic

499
00:20:21,520 --> 00:20:24,400
yeah um i think that's but definitely

500
00:20:24,400 --> 00:20:25,440
both solutions

501
00:20:25,440 --> 00:20:28,559
are feasible and they both work

502
00:20:28,559 --> 00:20:32,320
right um i had one other question which

503
00:20:32,320 --> 00:20:34,880
is i i see you use uh

504
00:20:34,880 --> 00:20:38,080
defer for the uh for unlocking quite a

505
00:20:38,080 --> 00:20:38,960
bit

506
00:20:38,960 --> 00:20:41,120
and yeah while i was doing my

507
00:20:41,120 --> 00:20:42,080
implementation i

508
00:20:42,080 --> 00:20:44,799
i realized i mean in a straightforward

509
00:20:44,799 --> 00:20:45,360
function

510
00:20:45,360 --> 00:20:48,720
it it's clear when it gives up control

511
00:20:48,720 --> 00:20:50,080
of the lock

512
00:20:50,080 --> 00:20:53,760
when but for example if you

513
00:20:53,760 --> 00:20:57,520
like have a go routine created

514
00:20:57,520 --> 00:21:00,880
from within the function

515
00:21:00,880 --> 00:21:02,880
it's not very clear when it gives up

516
00:21:02,880 --> 00:21:05,039
control

517
00:21:05,039 --> 00:21:07,360
so a go routine runs on a separate

518
00:21:07,360 --> 00:21:09,520
thread so the goverting never

519
00:21:09,520 --> 00:21:11,520
starts with the lock acquired even if

520
00:21:11,520 --> 00:21:13,039
you spin off the routine

521
00:21:13,039 --> 00:21:16,799
while you hold the lock okay yeah

522
00:21:16,799 --> 00:21:20,000
if we if we issue like a go if we create

523
00:21:20,000 --> 00:21:21,039
a go routine

524
00:21:21,039 --> 00:21:23,760
it'll just spin up a thread and from the

525
00:21:23,760 --> 00:21:25,840
beginning it will not have a lock

526
00:21:25,840 --> 00:21:28,240
right yeah yeah it's essentially just

527
00:21:28,240 --> 00:21:29,039
like

528
00:21:29,039 --> 00:21:30,240
you know you can think about another

529
00:21:30,240 --> 00:21:32,240
thread just starting to run that go

530
00:21:32,240 --> 00:21:35,600
like go funk that function okay

531
00:21:35,600 --> 00:21:38,720
yeah and then um yeah okay and then

532
00:21:38,720 --> 00:21:39,440
defer

533
00:21:39,440 --> 00:21:42,480
unlocks at any return like

534
00:21:42,480 --> 00:21:45,600
any return statement or yep yeah it's

535
00:21:45,600 --> 00:21:46,480
pushed onto

536
00:21:46,480 --> 00:21:49,840
a like basically like the functions to

537
00:21:49,840 --> 00:21:50,159
run

538
00:21:50,159 --> 00:21:53,600
when the there's a stack of functions

539
00:21:53,600 --> 00:21:55,440
that the

540
00:21:55,440 --> 00:21:58,159
returning from like handle get task will

541
00:21:58,159 --> 00:21:59,039
run

542
00:21:59,039 --> 00:22:01,919
so um i also have this in the slide so

543
00:22:01,919 --> 00:22:03,760
you'll be able to refer to this later

544
00:22:03,760 --> 00:22:06,320
but defer just ensures that when this

545
00:22:06,320 --> 00:22:07,679
function exits

546
00:22:07,679 --> 00:22:10,240
you over you'll run on lock and then i

547
00:22:10,240 --> 00:22:12,559
could also do something like

548
00:22:12,559 --> 00:22:17,200
um like like unlocking

549
00:22:17,200 --> 00:22:20,320
and like i could just do something like

550
00:22:20,320 --> 00:22:23,760
uh before the last print

551
00:22:23,760 --> 00:22:27,039
or print one so these are all pushed

552
00:22:27,039 --> 00:22:28,000
onto a stack

553
00:22:28,000 --> 00:22:30,720
and then they're popped off in um fifo

554
00:22:30,720 --> 00:22:31,280
order

555
00:22:31,280 --> 00:22:34,640
no phone uh

556
00:22:34,640 --> 00:22:38,240
yeah first in first out

557
00:22:38,240 --> 00:22:41,840
no they're run in

558
00:22:41,840 --> 00:22:45,679
lasting out yeah so it's a stack right

559
00:22:45,679 --> 00:22:46,640
so

560
00:22:46,640 --> 00:22:49,840
um this will run before unlock

561
00:22:49,840 --> 00:22:51,840
locking which won't actually run before

562
00:22:51,840 --> 00:22:53,200
the the lock

563
00:22:53,200 --> 00:22:54,640
so if you're going to use multiple

564
00:22:54,640 --> 00:22:56,400
difference just be careful in the order

565
00:22:56,400 --> 00:22:58,799
that you use them but deferring the

566
00:22:58,799 --> 00:22:59,840
unlock at least

567
00:22:59,840 --> 00:23:03,120
is a very useful strategy um

568
00:23:03,120 --> 00:23:06,159
that will come in handy okay i'm

569
00:23:06,159 --> 00:23:09,679
um so the last thing is uh if we if we

570
00:23:09,679 --> 00:23:11,840
call up function within

571
00:23:11,840 --> 00:23:15,520
um within our

572
00:23:15,520 --> 00:23:18,400
our function where we acquire the lock

573
00:23:18,400 --> 00:23:20,159
it doesn't return the lock

574
00:23:20,159 --> 00:23:22,640
right uh when it goes to the other

575
00:23:22,640 --> 00:23:23,679
function

576
00:23:23,679 --> 00:23:25,120
the other function returns to this

577
00:23:25,120 --> 00:23:27,679
function and then until we

578
00:23:27,679 --> 00:23:30,640
like the thread keeps a lock like

579
00:23:30,640 --> 00:23:31,120
through

580
00:23:31,120 --> 00:23:34,870
like jumping around yeah

581
00:23:34,880 --> 00:23:36,960
yeah so like a function that's just like

582
00:23:36,960 --> 00:23:39,280
a normal function call within one thread

583
00:23:39,280 --> 00:23:43,909
will be called with the law count yes

584
00:23:43,919 --> 00:23:48,470
thanks

585
00:23:48,480 --> 00:23:50,320
all right so you guys have already kind

586
00:23:50,320 --> 00:23:51,600
of discussed some of the alternate

587
00:23:51,600 --> 00:23:53,520
synchronization designs

588
00:23:53,520 --> 00:23:55,200
like waiting in the worker rather than

589
00:23:55,200 --> 00:23:56,960
the coordinator and we've talked about

590
00:23:56,960 --> 00:23:58,799
some of the pros and cons of that

591
00:23:58,799 --> 00:24:00,559
um using time actually i think you

592
00:24:00,559 --> 00:24:02,240
covered all these except for channels

593
00:24:02,240 --> 00:24:04,630
maybe

594
00:24:04,640 --> 00:24:06,880
so just one thing i wanted to note

595
00:24:06,880 --> 00:24:08,159
because there are a couple questions

596
00:24:08,159 --> 00:24:09,039
about this

597
00:24:09,039 --> 00:24:11,679
so waiting for mac has to be done or

598
00:24:11,679 --> 00:24:13,600
like any synchronization

599
00:24:13,600 --> 00:24:17,279
that we've shown is on a single server

600
00:24:17,279 --> 00:24:19,440
so cross-server communication between

601
00:24:19,440 --> 00:24:22,159
the worker and the coordinator

602
00:24:22,159 --> 00:24:24,400
are they're only it's only done ever by

603
00:24:24,400 --> 00:24:25,520
rpcs

604
00:24:25,520 --> 00:24:27,200
so for example like locking in the

605
00:24:27,200 --> 00:24:28,720
coordinator has nothing to do with

606
00:24:28,720 --> 00:24:30,080
locking on the worker

607
00:24:30,080 --> 00:24:32,400
or on your raft implementation locking

608
00:24:32,400 --> 00:24:33,919
on different servers

609
00:24:33,919 --> 00:24:37,039
like don't interfere with each other so

610
00:24:37,039 --> 00:24:39,279
i just want to be clear about that

611
00:24:39,279 --> 00:24:41,520
um so one thing i thought would be

612
00:24:41,520 --> 00:24:43,200
interesting is for you to see

613
00:24:43,200 --> 00:24:47,039
a kind of an example using channels

614
00:24:47,039 --> 00:24:48,480
because there are also some questions

615
00:24:48,480 --> 00:24:51,679
using channels about using channels

616
00:24:51,679 --> 00:24:55,679
so this is kind of it's a

617
00:24:55,679 --> 00:24:58,960
not complete implementation of using

618
00:24:58,960 --> 00:25:00,240
channels

619
00:25:00,240 --> 00:25:03,360
but it's a potential way to that you

620
00:25:03,360 --> 00:25:05,120
could think about having used channels

621
00:25:05,120 --> 00:25:05,440
in

622
00:25:05,440 --> 00:25:09,360
mapreduce and so in this example

623
00:25:09,360 --> 00:25:11,360
the input to the coordinator actually

624
00:25:11,360 --> 00:25:13,440
includes a channel

625
00:25:13,440 --> 00:25:16,799
in which the coordinator is told of

626
00:25:16,799 --> 00:25:20,320
what workers exist and this is

627
00:25:20,320 --> 00:25:23,360
to handle the

628
00:25:23,360 --> 00:25:25,679
possibility that workers are failing and

629
00:25:25,679 --> 00:25:26,960
then some client

630
00:25:26,960 --> 00:25:29,120
is telling the coordinator hey this

631
00:25:29,120 --> 00:25:30,880
other worker joined our cluster

632
00:25:30,880 --> 00:25:32,320
here's a new worker that you can give

633
00:25:32,320 --> 00:25:34,320
tasks to so that's slightly different

634
00:25:34,320 --> 00:25:35,360
than what we

635
00:25:35,360 --> 00:25:39,029
had in the lab

636
00:25:39,039 --> 00:25:42,559
so the coordinator has two channels

637
00:25:42,559 --> 00:25:45,919
one in which it will send

638
00:25:45,919 --> 00:25:49,520
tasks to workers or it won't send tests

639
00:25:49,520 --> 00:25:51,760
to workers it'll send tasks to a

640
00:25:51,760 --> 00:25:54,799
thread that will issue tasks to workers

641
00:25:54,799 --> 00:25:58,320
and then it has a done channel so

642
00:25:58,320 --> 00:26:02,000
again just like i i know i

643
00:26:02,000 --> 00:26:03,840
said something a little strange which i

644
00:26:03,840 --> 00:26:05,039
was like oh you can send

645
00:26:05,039 --> 00:26:06,640
tests to workers over the channel but

646
00:26:06,640 --> 00:26:08,480
you actually can't the channel

647
00:26:08,480 --> 00:26:11,039
is only on the coordinating your server

648
00:26:11,039 --> 00:26:13,600
and we'll see how that works in a second

649
00:26:13,600 --> 00:26:15,840
so the first thread of the coordinated

650
00:26:15,840 --> 00:26:17,120
that we create

651
00:26:17,120 --> 00:26:20,400
is a go routine that basically will for

652
00:26:20,400 --> 00:26:24,159
every worker um start the issue

653
00:26:24,159 --> 00:26:27,200
worker task thread so

654
00:26:27,200 --> 00:26:30,000
what this does is as workers are you

655
00:26:30,000 --> 00:26:30,320
know

656
00:26:30,320 --> 00:26:32,240
coming and going because they're failing

657
00:26:32,240 --> 00:26:33,679
and then restarting

658
00:26:33,679 --> 00:26:35,760
this channel basically says okay we want

659
00:26:35,760 --> 00:26:38,080
to for every of these workers

660
00:26:38,080 --> 00:26:40,159
start a thread that will issue this

661
00:26:40,159 --> 00:26:41,919
worker tests

662
00:26:41,919 --> 00:26:46,559
um so this is one go routine here

663
00:26:46,559 --> 00:26:49,360
then the coordinator what it does is it

664
00:26:49,360 --> 00:26:50,880
for all the tasks that we're given it'll

665
00:26:50,880 --> 00:26:51,679
just

666
00:26:51,679 --> 00:26:55,279
push those tasks onto this channel and

667
00:26:55,279 --> 00:26:57,440
this task channel we actually made it a

668
00:26:57,440 --> 00:26:58,799
buffered channel

669
00:26:58,799 --> 00:27:01,360
so we know it will hold exactly num

670
00:27:01,360 --> 00:27:02,640
tasks tasks which

671
00:27:02,640 --> 00:27:05,679
are the that's the limit of the number

672
00:27:05,679 --> 00:27:06,559
of tasks

673
00:27:06,559 --> 00:27:09,120
that will exist on the system so what

674
00:27:09,120 --> 00:27:11,760
this also means is that we can push

675
00:27:11,760 --> 00:27:14,880
the number of tasks uh tasks

676
00:27:14,880 --> 00:27:17,360
onto this channel without blocking so

677
00:27:17,360 --> 00:27:19,279
the coordinator will not block

678
00:27:19,279 --> 00:27:22,320
on pushing tests to the task channel

679
00:27:22,320 --> 00:27:25,679
and then the coordinator will read from

680
00:27:25,679 --> 00:27:28,880
this done channel until it has

681
00:27:28,880 --> 00:27:32,080
done so number of test times in which

682
00:27:32,080 --> 00:27:34,240
case it knows it's done um in this case

683
00:27:34,240 --> 00:27:35,200
we're

684
00:27:35,200 --> 00:27:36,960
i'm not separating macro reduce test

685
00:27:36,960 --> 00:27:38,640
let's just imagine that there are

686
00:27:38,640 --> 00:27:40,159
some number of tasks that the

687
00:27:40,159 --> 00:27:43,039
coordinator needs to run

688
00:27:43,039 --> 00:27:45,200
and once it's knows the tasks all the

689
00:27:45,200 --> 00:27:46,159
tasks have finished

690
00:27:46,159 --> 00:27:49,279
it closes the task channel and then

691
00:27:49,279 --> 00:27:53,440
um basically we'll exit

692
00:27:53,440 --> 00:27:57,200
and so the where some of the

693
00:27:57,200 --> 00:27:59,440
interesting part comes in is these

694
00:27:59,440 --> 00:28:01,520
worker task threads which i've separated

695
00:28:01,520 --> 00:28:02,000
out into

696
00:28:02,000 --> 00:28:05,520
a function here so these all run

697
00:28:05,520 --> 00:28:09,360
on separate go routines and what it does

698
00:28:09,360 --> 00:28:13,760
is for as long as there are tasks in the

699
00:28:13,760 --> 00:28:14,880
test queue

700
00:28:14,880 --> 00:28:18,000
it will pull a task out and then

701
00:28:18,000 --> 00:28:21,520
oops i didn't mean to that and then uh

702
00:28:21,520 --> 00:28:24,880
call basically an

703
00:28:24,880 --> 00:28:26,960
rpc that will send the task to the

704
00:28:26,960 --> 00:28:28,159
worker

705
00:28:28,159 --> 00:28:31,760
so note that this channel actually is

706
00:28:31,760 --> 00:28:33,279
talking to another thread of the

707
00:28:33,279 --> 00:28:35,520
coordinator and that thread

708
00:28:35,520 --> 00:28:38,000
is actually the one that's in charge of

709
00:28:38,000 --> 00:28:39,120
calling

710
00:28:39,120 --> 00:28:42,320
um the the worker

711
00:28:42,320 --> 00:28:44,480
and then once it's done with the task it

712
00:28:44,480 --> 00:28:46,559
says it's done

713
00:28:46,559 --> 00:28:49,440
if it's not able to if the call fails

714
00:28:49,440 --> 00:28:50,399
for some reason

715
00:28:50,399 --> 00:28:53,840
for example it times out then what this

716
00:28:53,840 --> 00:28:55,760
loop does is it'll push that task

717
00:28:55,760 --> 00:28:58,640
back onto the task channel so another

718
00:28:58,640 --> 00:29:00,640
worker or potentially this threat again

719
00:29:00,640 --> 00:29:03,360
could pick up that task

720
00:29:03,360 --> 00:29:06,080
so just to clarify how the channel

721
00:29:06,080 --> 00:29:08,399
communication works so the worker

722
00:29:08,399 --> 00:29:10,000
sends tasks on the attach channel which

723
00:29:10,000 --> 00:29:12,880
is read through these loops

724
00:29:12,880 --> 00:29:16,399
and this loop will exit when the

725
00:29:16,399 --> 00:29:20,240
coordinator closes the channel um

726
00:29:20,240 --> 00:29:23,679
done it's sent on these worker issue

727
00:29:23,679 --> 00:29:25,039
worker threads

728
00:29:25,039 --> 00:29:28,159
um and it's read by the coordinator the

729
00:29:28,159 --> 00:29:30,320
original coordinator thread

730
00:29:30,320 --> 00:29:33,679
and this exit equals true will basically

731
00:29:33,679 --> 00:29:34,480
tell

732
00:29:34,480 --> 00:29:36,320
the coordinator like oh i don't need to

733
00:29:36,320 --> 00:29:38,240
listen for any more workers coming

734
00:29:38,240 --> 00:29:41,279
or workers starting up so it'll cause

735
00:29:41,279 --> 00:29:44,799
this other girl routine to exit

736
00:29:44,799 --> 00:29:46,880
so i know that this is a pretty complex

737
00:29:46,880 --> 00:29:49,440
example it's also not quite what we

738
00:29:49,440 --> 00:29:51,919
um specified in the lab but it's an

739
00:29:51,919 --> 00:29:54,159
example of how channels could be used

740
00:29:54,159 --> 00:29:56,240
to implement something like mapreduce or

741
00:29:56,240 --> 00:30:00,230
something similar to mapreduce

742
00:30:00,240 --> 00:30:02,960
there is a question in the chat about

743
00:30:02,960 --> 00:30:04,480
where is exit divide

744
00:30:04,480 --> 00:30:08,559
in this code

745
00:30:08,559 --> 00:30:12,159
that is a good question and it's not

746
00:30:12,159 --> 00:30:14,399
so it it'll it they'll be exactly the

747
00:30:14,399 --> 00:30:15,600
same thing as done

748
00:30:15,600 --> 00:30:18,880
um it'll just be another channel

749
00:30:18,880 --> 00:30:23,200
that's uh a bullion yeah

750
00:30:23,200 --> 00:30:26,960
that's a that's a good uh good cash

751
00:30:26,960 --> 00:30:30,159
oh can i i can't i've seen how do you

752
00:30:30,159 --> 00:30:31,679
add things to the workers channel or

753
00:30:31,679 --> 00:30:32,720
when do you add things to the workers

754
00:30:32,720 --> 00:30:34,000
channel like how would you handle done

755
00:30:34,000 --> 00:30:35,840
this gif

756
00:30:35,840 --> 00:30:38,880
so in this case um worker the workers

757
00:30:38,880 --> 00:30:39,440
channel

758
00:30:39,440 --> 00:30:41,600
is provided to the coordinator so

759
00:30:41,600 --> 00:30:42,720
imagine that

760
00:30:42,720 --> 00:30:45,679
for example in you know how your

761
00:30:45,679 --> 00:30:46,720
coordinator

762
00:30:46,720 --> 00:30:51,200
was actually called or created by

763
00:30:51,200 --> 00:30:54,880
the mr coordinator in maine

764
00:30:54,880 --> 00:30:57,919
in the that folder so we would

765
00:30:57,919 --> 00:31:01,279
imagine that in an mr coordinator we

766
00:31:01,279 --> 00:31:01,919
would create

767
00:31:01,919 --> 00:31:05,600
a workers channel and mr coordinator

768
00:31:05,600 --> 00:31:06,720
would basically

769
00:31:06,720 --> 00:31:09,919
be in charge of tracking when workers

770
00:31:09,919 --> 00:31:10,799
crash

771
00:31:10,799 --> 00:31:13,919
and when workers join so this is for

772
00:31:13,919 --> 00:31:14,480
example

773
00:31:14,480 --> 00:31:17,600
in a case where you know maybe new

774
00:31:17,600 --> 00:31:19,440
servers are added to our cluster at some

775
00:31:19,440 --> 00:31:20,480
later point

776
00:31:20,480 --> 00:31:22,559
or some worker crashed and then came

777
00:31:22,559 --> 00:31:24,559
back and and our coordinator would be

778
00:31:24,559 --> 00:31:25,600
constantly

779
00:31:25,600 --> 00:31:29,039
sending like these worker ids to

780
00:31:29,039 --> 00:31:32,240
our coordinator in order to tell it hey

781
00:31:32,240 --> 00:31:33,840
like this new worker you should

782
00:31:33,840 --> 00:31:36,799
start issuing it tasks um so that part

783
00:31:36,799 --> 00:31:38,320
is not shown

784
00:31:38,320 --> 00:31:41,120
got it yeah i just i just uh was

785
00:31:41,120 --> 00:31:41,919
wondering like

786
00:31:41,919 --> 00:31:43,840
so this is really cool i was just

787
00:31:43,840 --> 00:31:45,279
wondering like inside like

788
00:31:45,279 --> 00:31:48,799
the lab one like how i think it's like

789
00:31:48,799 --> 00:31:50,320
call worker and you've defended an rpc

790
00:31:50,320 --> 00:31:52,559
to the worker uh

791
00:31:52,559 --> 00:31:53,760
is that something we could have done in

792
00:31:53,760 --> 00:31:55,919
black one

793
00:31:55,919 --> 00:31:59,200
uh it's possible but

794
00:31:59,200 --> 00:32:01,200
it definitely was not what we pushed you

795
00:32:01,200 --> 00:32:02,559
toward um

796
00:32:02,559 --> 00:32:04,559
because you would basically insist

797
00:32:04,559 --> 00:32:06,320
setting up the coordinator as being the

798
00:32:06,320 --> 00:32:08,399
rpc server you would have to set up

799
00:32:08,399 --> 00:32:11,440
like rpc servers on the workers

800
00:32:11,440 --> 00:32:13,840
um you could also think of in this

801
00:32:13,840 --> 00:32:15,039
implementation

802
00:32:15,039 --> 00:32:18,720
call worker could have handlers actually

803
00:32:18,720 --> 00:32:20,159
for each worker

804
00:32:20,159 --> 00:32:22,960
and each worker could be sending the

805
00:32:22,960 --> 00:32:24,159
coordinator

806
00:32:24,159 --> 00:32:28,720
like get task rpc's that's a little

807
00:32:28,720 --> 00:32:30,799
that's a little funky um so in this

808
00:32:30,799 --> 00:32:32,480
example it's actually more natural to

809
00:32:32,480 --> 00:32:33,200
imagine

810
00:32:33,200 --> 00:32:35,760
that call worker um that the coordinator

811
00:32:35,760 --> 00:32:37,279
is the client and the

812
00:32:37,279 --> 00:32:41,360
workers are the ones that are handling

813
00:32:41,360 --> 00:32:45,120
got the yeah okay thanks really cool

814
00:32:45,120 --> 00:32:48,240
i have two questions um first is just a

815
00:32:48,240 --> 00:32:49,919
general lego question so in that

816
00:32:49,919 --> 00:32:52,240
second for loop on on the left at the

817
00:32:52,240 --> 00:32:53,600
bottom

818
00:32:53,600 --> 00:32:57,440
if you don't use i will go complain or

819
00:32:57,440 --> 00:33:01,279
in a for loop uh so

820
00:33:01,279 --> 00:33:03,519
i run like all the go linter and all

821
00:33:03,519 --> 00:33:04,480
that stuff

822
00:33:04,480 --> 00:33:07,600
and it's fine i think

823
00:33:07,600 --> 00:33:10,799
like in this case you

824
00:33:10,799 --> 00:33:14,080
do need to have eye because you're

825
00:33:14,080 --> 00:33:16,080
incrementing it and keeping the state of

826
00:33:16,080 --> 00:33:17,200
eye around

827
00:33:17,200 --> 00:33:20,399
through the can you do the same thing

828
00:33:20,399 --> 00:33:21,440
with like uh

829
00:33:21,440 --> 00:33:23,600
like just a norm like a while loop like

830
00:33:23,600 --> 00:33:25,360
a just for empty for loop

831
00:33:25,360 --> 00:33:29,360
with a select um where it's like

832
00:33:29,360 --> 00:33:32,399
popping off of done um

833
00:33:32,399 --> 00:33:36,159
so you

834
00:33:36,159 --> 00:33:38,720
can't actually well you still need to

835
00:33:38,720 --> 00:33:39,760
keep track of

836
00:33:39,760 --> 00:33:42,559
how many times you've read from done

837
00:33:42,559 --> 00:33:44,159
right because you can't just

838
00:33:44,159 --> 00:33:47,679
read once you have to read number of

839
00:33:47,679 --> 00:33:50,830
test

840
00:33:50,840 --> 00:33:52,000
times

841
00:33:52,000 --> 00:33:55,279
i see okay yeah so you do need

842
00:33:55,279 --> 00:33:59,679
some type of state that will track that

843
00:33:59,679 --> 00:34:02,710
um

844
00:34:02,720 --> 00:34:04,720
and then there's the for the one on the

845
00:34:04,720 --> 00:34:06,159
right like the where you're like

846
00:34:06,159 --> 00:34:08,960
reading from ask and repopulating it um

847
00:34:08,960 --> 00:34:10,159
is there like any

848
00:34:10,159 --> 00:34:13,119
downside to that or if you're like just

849
00:34:13,119 --> 00:34:14,639
constantly reading and adding

850
00:34:14,639 --> 00:34:19,589
back and forth to the same channel uh

851
00:34:19,599 --> 00:34:22,480
i don't i can't think of it off the top

852
00:34:22,480 --> 00:34:23,280
of my head so in

853
00:34:23,280 --> 00:34:25,839
in this case at least you won't block

854
00:34:25,839 --> 00:34:27,919
because every time you read it you're

855
00:34:27,919 --> 00:34:30,240
popping something off the channel every

856
00:34:30,240 --> 00:34:30,960
time you

857
00:34:30,960 --> 00:34:34,399
um add it you're pushing something so

858
00:34:34,399 --> 00:34:37,119
because we have that the task is a

859
00:34:37,119 --> 00:34:38,079
buffer channel

860
00:34:38,079 --> 00:34:41,119
like you'll never block on that

861
00:34:41,119 --> 00:34:45,359
so in terms of like performance

862
00:34:45,359 --> 00:34:48,879
i think i mean channels are built using

863
00:34:48,879 --> 00:34:49,440
locks

864
00:34:49,440 --> 00:34:52,800
so locks are usually more lightweight um

865
00:34:52,800 --> 00:34:55,119
but i don't think i don't think you'll

866
00:34:55,119 --> 00:34:56,320
see like a huge

867
00:34:56,320 --> 00:34:58,480
performance impact um doing something

868
00:34:58,480 --> 00:34:59,599
like this

869
00:34:59,599 --> 00:35:02,000
okay i guess i have like a sorry just

870
00:35:02,000 --> 00:35:03,280
like a general

871
00:35:03,280 --> 00:35:05,280
question of like what's your like

872
00:35:05,280 --> 00:35:07,680
calculus for choosing between

873
00:35:07,680 --> 00:35:11,119
mutexes and channels or like a hybrid or

874
00:35:11,119 --> 00:35:14,320
like at the very beginning yeah

875
00:35:14,320 --> 00:35:17,200
so mutexes are very natural for just

876
00:35:17,200 --> 00:35:19,200
protecting a piece of state

877
00:35:19,200 --> 00:35:22,240
so like your coordinator or like your

878
00:35:22,240 --> 00:35:23,920
raf servers have a log

879
00:35:23,920 --> 00:35:26,000
i want to protect every time i append to

880
00:35:26,000 --> 00:35:28,160
the log um

881
00:35:28,160 --> 00:35:31,760
that seems very difficult or it seems

882
00:35:31,760 --> 00:35:33,599
very unnatural to try and do using

883
00:35:33,599 --> 00:35:35,280
channels because

884
00:35:35,280 --> 00:35:36,720
essentially you'd be using the channel

885
00:35:36,720 --> 00:35:38,800
as a lock you'd want to

886
00:35:38,800 --> 00:35:40,720
ensure that no one else is modifying the

887
00:35:40,720 --> 00:35:42,560
state while you're modifying it

888
00:35:42,560 --> 00:35:44,640
and then you would have to essentially

889
00:35:44,640 --> 00:35:45,920
before you modify it

890
00:35:45,920 --> 00:35:47,599
try to read on the channel to ensure

891
00:35:47,599 --> 00:35:49,520
that no one else or

892
00:35:49,520 --> 00:35:50,560
like someone would have to send

893
00:35:50,560 --> 00:35:51,920
something on the channel to show that

894
00:35:51,920 --> 00:35:52,720
they've done

895
00:35:52,720 --> 00:35:54,240
they've been finished modifying it and

896
00:35:54,240 --> 00:35:55,760
so on and so forth

897
00:35:55,760 --> 00:35:58,800
so in that case it's actually very hard

898
00:35:58,800 --> 00:36:00,079
to imagine how you would do it with

899
00:36:00,079 --> 00:36:00,960
channels whereas

900
00:36:00,960 --> 00:36:02,800
mutexes would make that completely

901
00:36:02,800 --> 00:36:04,160
straightforward

902
00:36:04,160 --> 00:36:07,760
um where channels come in very handy

903
00:36:07,760 --> 00:36:10,800
is like i think our implementation

904
00:36:10,800 --> 00:36:12,000
already has this like apply

905
00:36:12,000 --> 00:36:16,560
channel is where you have to wait for

906
00:36:16,560 --> 00:36:19,920
uh in some ways it's like almost like a

907
00:36:19,920 --> 00:36:21,920
specific instance of a condition

908
00:36:21,920 --> 00:36:24,160
variable in which you want to wait for

909
00:36:24,160 --> 00:36:24,720
something

910
00:36:24,720 --> 00:36:28,800
to be ready um or a

911
00:36:28,800 --> 00:36:33,440
um like a very specific type of

912
00:36:33,440 --> 00:36:37,119
command to be finished um so

913
00:36:37,119 --> 00:36:38,880
for something like issuing tasks it's

914
00:36:38,880 --> 00:36:40,880
actually not a bad example

915
00:36:40,880 --> 00:36:44,880
um or something like blocking until

916
00:36:44,880 --> 00:36:47,040
you have something on a queue it like

917
00:36:47,040 --> 00:36:48,560
it's you can almost think of it as like

918
00:36:48,560 --> 00:36:49,920
a queueing system

919
00:36:49,920 --> 00:36:51,680
or at least that's how i like to think

920
00:36:51,680 --> 00:36:53,200
about it but

921
00:36:53,200 --> 00:36:55,599
for almost all modifications to shared

922
00:36:55,599 --> 00:36:58,480
state or like the race conditions you'll

923
00:36:58,480 --> 00:37:01,920
encounter locks are

924
00:37:01,920 --> 00:37:03,680
much simpler and in some ways a lot

925
00:37:03,680 --> 00:37:09,040
easier to reason about but

926
00:37:09,040 --> 00:37:12,640
yeah thank you sorry i have a follow-up

927
00:37:12,640 --> 00:37:13,440
question to

928
00:37:13,440 --> 00:37:16,800
this slide um what happens if

929
00:37:16,800 --> 00:37:19,920
the so you call the go issue worker task

930
00:37:19,920 --> 00:37:21,680
thread which spins up another

931
00:37:21,680 --> 00:37:24,240
go routine i mean it goes through all

932
00:37:24,240 --> 00:37:26,880
the tasks in the channel what if it

933
00:37:26,880 --> 00:37:29,359
fails when it's what if the go routine

934
00:37:29,359 --> 00:37:30,640
fails when it's

935
00:37:30,640 --> 00:37:34,829
sitting on the if call worker

936
00:37:34,839 --> 00:37:37,990
so

937
00:37:38,000 --> 00:37:41,520
if it fails then i guess

938
00:37:41,520 --> 00:37:45,280
you've taken a task out

939
00:37:45,280 --> 00:37:48,829
and not put it back

940
00:37:48,839 --> 00:37:51,839
um i'm actually not sure that seems like

941
00:37:51,839 --> 00:37:53,920
uh

942
00:37:53,920 --> 00:37:55,520
like you're not you're saying like the

943
00:37:55,520 --> 00:37:58,079
entire thread crashes

944
00:37:58,079 --> 00:38:00,880
rather than as coworker not like

945
00:38:00,880 --> 00:38:02,640
returning falls or something

946
00:38:02,640 --> 00:38:05,839
yeah like the the go routine crashes

947
00:38:05,839 --> 00:38:08,400
or is that possible for a single go

948
00:38:08,400 --> 00:38:08,960
routine

949
00:38:08,960 --> 00:38:11,280
to fail or would like the entire thing

950
00:38:11,280 --> 00:38:14,310
just blow up

951
00:38:14,320 --> 00:38:16,160
france you know i think the model you

952
00:38:16,160 --> 00:38:18,079
should have is that if a

953
00:38:18,079 --> 00:38:21,680
go routine crashes the process crashes

954
00:38:21,680 --> 00:38:25,589
yeah that would solve it

955
00:38:25,599 --> 00:38:30,480
oh sorry so if just the worker crashes

956
00:38:30,480 --> 00:38:34,160
then you pick a different task

957
00:38:34,160 --> 00:38:37,680
but should you i guess you would still

958
00:38:37,680 --> 00:38:38,000
have

959
00:38:38,000 --> 00:38:41,760
the same worker like

960
00:38:41,760 --> 00:38:44,960
worker number um

961
00:38:44,960 --> 00:38:46,720
would you still connect to the same

962
00:38:46,720 --> 00:38:48,079
worker even though they

963
00:38:48,079 --> 00:38:51,040
have failed yeah so in this case

964
00:38:51,040 --> 00:38:52,000
basically

965
00:38:52,000 --> 00:38:53,520
call worker would just continue

966
00:38:53,520 --> 00:38:55,040
returning false

967
00:38:55,040 --> 00:38:57,920
and you know this their routine that's

968
00:38:57,920 --> 00:38:58,320
uh

969
00:38:58,320 --> 00:39:00,240
specific for this worker would just

970
00:39:00,240 --> 00:39:01,680
continue to loop

971
00:39:01,680 --> 00:39:05,280
um and eventually when

972
00:39:05,280 --> 00:39:08,000
the ma when the coordinator has

973
00:39:08,000 --> 00:39:09,280
determined that all the tasks have

974
00:39:09,280 --> 00:39:09,760
finished

975
00:39:09,760 --> 00:39:11,280
it'll close the channel and then the

976
00:39:11,280 --> 00:39:13,280
discover team will exit

977
00:39:13,280 --> 00:39:15,920
so there could potentially like if all

978
00:39:15,920 --> 00:39:17,280
your workers

979
00:39:17,280 --> 00:39:18,640
continue crashing and you have like

980
00:39:18,640 --> 00:39:20,560
hundreds of new workers joining

981
00:39:20,560 --> 00:39:22,240
like you could potentially have a lot of

982
00:39:22,240 --> 00:39:24,079
go routines just that are just like i

983
00:39:24,079 --> 00:39:25,760
can't contact my worker i can't contact

984
00:39:25,760 --> 00:39:26,800
my worker

985
00:39:26,800 --> 00:39:29,760
but once the task is finished this all

986
00:39:29,760 --> 00:39:31,119
of them will exit

987
00:39:31,119 --> 00:39:39,430
properly

988
00:39:39,440 --> 00:39:42,240
cool all right so that's an example with

989
00:39:42,240 --> 00:39:43,280
channels

990
00:39:43,280 --> 00:39:46,560
and now let's move on to some of the

991
00:39:46,560 --> 00:39:49,200
more like your questions and bugs and

992
00:39:49,200 --> 00:39:50,880
things like that so some common but

993
00:39:50,880 --> 00:39:53,359
passing design mistakes that we saw was

994
00:39:53,359 --> 00:39:54,000
pushing

995
00:39:54,000 --> 00:39:56,079
too much work to the coordinator so

996
00:39:56,079 --> 00:39:57,680
essentially making the coordinator

997
00:39:57,680 --> 00:39:58,640
bottleneck

998
00:39:58,640 --> 00:40:00,800
um and this included both like the

999
00:40:00,800 --> 00:40:02,800
coordinator and

1000
00:40:02,800 --> 00:40:05,280
sorting the results or the coordinator

1001
00:40:05,280 --> 00:40:06,880
like reading file contents

1002
00:40:06,880 --> 00:40:10,240
whereas a lot of the kind of beauty of

1003
00:40:10,240 --> 00:40:11,040
mapreduce

1004
00:40:11,040 --> 00:40:14,240
is that all the state all the

1005
00:40:14,240 --> 00:40:17,599
computation happens on the workers

1006
00:40:17,599 --> 00:40:20,960
um and another common um

1007
00:40:20,960 --> 00:40:22,480
it's not really a mistake but

1008
00:40:22,480 --> 00:40:23,599
potentially something you can think

1009
00:40:23,599 --> 00:40:24,400
about is

1010
00:40:24,400 --> 00:40:28,079
how many rpcs are you sending and like

1011
00:40:28,079 --> 00:40:29,680
do you really need to send that many

1012
00:40:29,680 --> 00:40:31,839
rpcs so for example

1013
00:40:31,839 --> 00:40:33,760
sending an rpc to check whether there's

1014
00:40:33,760 --> 00:40:35,200
a map task available

1015
00:40:35,200 --> 00:40:37,440
and then sending another rpc to ask like

1016
00:40:37,440 --> 00:40:38,720
give me a task

1017
00:40:38,720 --> 00:40:41,520
is a little redundant and you want to

1018
00:40:41,520 --> 00:40:42,720
try and like reduce

1019
00:40:42,720 --> 00:40:45,920
the number and types of like reduce the

1020
00:40:45,920 --> 00:40:47,200
api between the

1021
00:40:47,200 --> 00:40:50,400
master or the coordinator and the worker

1022
00:40:50,400 --> 00:40:52,640
um but these were like they would pass

1023
00:40:52,640 --> 00:40:53,839
the test and

1024
00:40:53,839 --> 00:40:57,589
it's just things we wanted to point out

1025
00:40:57,599 --> 00:41:00,480
so now okay cool we're about like

1026
00:41:00,480 --> 00:41:01,760
halfway through lecture

1027
00:41:01,760 --> 00:41:05,200
so for the next say like five six

1028
00:41:05,200 --> 00:41:06,160
minutes

1029
00:41:06,160 --> 00:41:07,920
why not we're going to do breakout rooms

1030
00:41:07,920 --> 00:41:10,880
um let me stop sharing actually

1031
00:41:10,880 --> 00:41:14,160
all right so we'll do breakout rooms and

1032
00:41:14,160 --> 00:41:18,839
oh shoot let's see

1033
00:41:18,839 --> 00:41:21,599
uh

1034
00:41:21,599 --> 00:41:27,910
i think zoom just crashed on me

1035
00:41:27,920 --> 00:41:30,240
we could still hear you don't see you

1036
00:41:30,240 --> 00:41:32,000
all right i'm back

1037
00:41:32,000 --> 00:41:34,720
yeah i upgraded zoom right before this

1038
00:41:34,720 --> 00:41:36,319
lecture that was a bad idea

1039
00:41:36,319 --> 00:41:37,839
but all right for the next five or six

1040
00:41:37,839 --> 00:41:39,760
minutes uh you should

1041
00:41:39,760 --> 00:41:42,319
talk about just like you know any

1042
00:41:42,319 --> 00:41:44,240
interesting bugs or observations you had

1043
00:41:44,240 --> 00:41:45,119
about the lab

1044
00:41:45,119 --> 00:41:47,359
um or you could you know complain about

1045
00:41:47,359 --> 00:41:48,880
how long it took you to find a certain

1046
00:41:48,880 --> 00:41:49,599
bug

1047
00:41:49,599 --> 00:41:52,079
or ask questions to each other and then

1048
00:41:52,079 --> 00:41:52,880
we'll come back

1049
00:41:52,880 --> 00:41:55,920
and go over some of your questions all

1050
00:41:55,920 --> 00:41:57,680
right

1051
00:41:57,680 --> 00:42:00,829
um

1052
00:42:00,839 --> 00:42:27,190
okay all right see you in a bit

1053
00:42:27,200 --> 00:42:28,960
oh so i thought you were with franz do

1054
00:42:28,960 --> 00:42:30,800
you want me to move you somewhere else

1055
00:42:30,800 --> 00:42:32,560
probably best but let me see if i can do

1056
00:42:32,560 --> 00:42:33,920
it myself

1057
00:42:33,920 --> 00:49:37,750
okay i'm going to be right back

1058
00:49:37,760 --> 00:49:41,200
all right are we mostly back

1059
00:49:41,200 --> 00:49:46,549
i think all right cool

1060
00:49:46,559 --> 00:49:48,960
all right so i hope that was pretty fun

1061
00:49:48,960 --> 00:49:49,599
or at least

1062
00:49:49,599 --> 00:49:51,040
you got to talk about some of your

1063
00:49:51,040 --> 00:49:53,520
frustrations during the live

1064
00:49:53,520 --> 00:49:55,839
um yeah so for the rest of the lecture

1065
00:49:55,839 --> 00:49:57,040
we're going to go through

1066
00:49:57,040 --> 00:49:59,599
oh right first before questions here

1067
00:49:59,599 --> 00:50:01,280
some general tips that you'll want to

1068
00:50:01,280 --> 00:50:02,160
look out for for

1069
00:50:02,160 --> 00:50:05,359
future labs um so first of all

1070
00:50:05,359 --> 00:50:09,119
the one thing you'll find very handy

1071
00:50:09,119 --> 00:50:11,119
for debugging is just you know classic

1072
00:50:11,119 --> 00:50:12,160
printfs

1073
00:50:12,160 --> 00:50:13,680
and so you can have conditional

1074
00:50:13,680 --> 00:50:15,599
printouts which only print

1075
00:50:15,599 --> 00:50:17,839
when you want to debug so for example

1076
00:50:17,839 --> 00:50:18,960
you don't have to go through your code

1077
00:50:18,960 --> 00:50:19,839
and comment

1078
00:50:19,839 --> 00:50:21,280
them all out before you submit or

1079
00:50:21,280 --> 00:50:23,119
something like that and so

1080
00:50:23,119 --> 00:50:26,800
in the wrath lab we provide this dprintf

1081
00:50:26,800 --> 00:50:30,079
in the utils.gov file um and you can

1082
00:50:30,079 --> 00:50:31,440
modify that

1083
00:50:31,440 --> 00:50:34,079
to for example also print out like the

1084
00:50:34,079 --> 00:50:35,119
server id

1085
00:50:35,119 --> 00:50:36,960
every single time you call dprintf or

1086
00:50:36,960 --> 00:50:38,160
something like that

1087
00:50:38,160 --> 00:50:41,520
so yeah like customize it to you know

1088
00:50:41,520 --> 00:50:42,800
print out in different colors for

1089
00:50:42,800 --> 00:50:45,440
different rpcs things like that

1090
00:50:45,440 --> 00:50:47,839
um and also like redirecting your output

1091
00:50:47,839 --> 00:50:48,640
to files

1092
00:50:48,640 --> 00:50:49,920
just so that you can like search the

1093
00:50:49,920 --> 00:50:52,559
files will come in handy

1094
00:50:52,559 --> 00:50:55,280
um another trick that you probably want

1095
00:50:55,280 --> 00:50:55,760
to

1096
00:50:55,760 --> 00:50:58,400
keep in mind is you can look at all the

1097
00:50:58,400 --> 00:50:59,520
go routines to see

1098
00:50:59,520 --> 00:51:02,559
where in their like execution they're

1099
00:51:02,559 --> 00:51:05,520
running and so just type control um

1100
00:51:05,520 --> 00:51:08,240
backlash in order to do that

1101
00:51:08,240 --> 00:51:10,160
and the final thing which we've already

1102
00:51:10,160 --> 00:51:12,000
sort of talked about are these differs

1103
00:51:12,000 --> 00:51:14,000
and these slides will be uploaded also

1104
00:51:14,000 --> 00:51:16,319
so you can refer back to them

1105
00:51:16,319 --> 00:51:19,839
but essentially you can push multiple

1106
00:51:19,839 --> 00:51:22,160
functions to run right before the

1107
00:51:22,160 --> 00:51:23,599
function returns

1108
00:51:23,599 --> 00:51:27,920
and they just be careful of the ordering

1109
00:51:27,920 --> 00:51:30,240
all right so now let's get to some of

1110
00:51:30,240 --> 00:51:31,119
your questions

1111
00:51:31,119 --> 00:51:34,480
um a lot of you submitted also questions

1112
00:51:34,480 --> 00:51:35,599
about raft so

1113
00:51:35,599 --> 00:51:38,240
those we'll get to for like the rough q

1114
00:51:38,240 --> 00:51:39,440
a or like

1115
00:51:39,440 --> 00:51:41,280
maybe office hours or you can put that

1116
00:51:41,280 --> 00:51:43,520
on piazza but i'm going to focus mostly

1117
00:51:43,520 --> 00:51:44,960
on the ones from mapreduce

1118
00:51:44,960 --> 00:51:46,720
or maybe we have time then we can also

1119
00:51:46,720 --> 00:51:50,000
get to the rough questions

1120
00:51:50,000 --> 00:51:53,680
right so the first category of questions

1121
00:51:53,680 --> 00:51:55,119
kind of falls under

1122
00:51:55,119 --> 00:51:57,119
um questions specifically about

1123
00:51:57,119 --> 00:51:58,559
mapreduce

1124
00:51:58,559 --> 00:52:01,520
um so some more complex tasks that you

1125
00:52:01,520 --> 00:52:02,319
might want to use

1126
00:52:02,319 --> 00:52:04,720
mapreduce for um it's actually used a

1127
00:52:04,720 --> 00:52:06,720
lot in ml or like data mining

1128
00:52:06,720 --> 00:52:07,680
statistical

1129
00:52:07,680 --> 00:52:11,359
applications um i linked here to

1130
00:52:11,359 --> 00:52:14,240
uh hadoop which is uh it implements

1131
00:52:14,240 --> 00:52:16,000
mapreduce and a lot of people use it to

1132
00:52:16,000 --> 00:52:16,480
run

1133
00:52:16,480 --> 00:52:20,319
these type of tasks and for example

1134
00:52:20,319 --> 00:52:23,599
here's a simple or

1135
00:52:23,599 --> 00:52:26,640
maybe not so simple but basically matrix

1136
00:52:26,640 --> 00:52:28,559
multiplication example of how you would

1137
00:52:28,559 --> 00:52:31,280
run that using macroduce

1138
00:52:31,280 --> 00:52:34,720
um second like you for a full tolerance

1139
00:52:34,720 --> 00:52:36,319
of the coordinator the paper food

1140
00:52:36,319 --> 00:52:40,960
is a very simple um checkpointing

1141
00:52:40,960 --> 00:52:43,119
mechanism in which you'll just start up

1142
00:52:43,119 --> 00:52:45,119
the a new coordinator using the last

1143
00:52:45,119 --> 00:52:46,720
checkpointed state

1144
00:52:46,720 --> 00:52:48,720
and in some ways this is a very natural

1145
00:52:48,720 --> 00:52:50,319
design for macro dues

1146
00:52:50,319 --> 00:52:52,160
because everything is deterministic so

1147
00:52:52,160 --> 00:52:53,440
there's no

1148
00:52:53,440 --> 00:52:55,440
um the coordinator really doesn't have

1149
00:52:55,440 --> 00:52:56,960
that much state to hold all it needs to

1150
00:52:56,960 --> 00:52:58,319
know is like which tasks have finished

1151
00:52:58,319 --> 00:52:59,920
and which tests haven't

1152
00:52:59,920 --> 00:53:04,079
um so you could use raft of course to

1153
00:53:04,079 --> 00:53:07,680
like enable fault tolerance and have a

1154
00:53:07,680 --> 00:53:09,520
set of coordinators that all agree on

1155
00:53:09,520 --> 00:53:11,920
like the commands that's issued so far

1156
00:53:11,920 --> 00:53:14,319
and the current state but

1157
00:53:14,319 --> 00:53:16,240
in some ways it seems a little overkill

1158
00:53:16,240 --> 00:53:19,430
for

1159
00:53:19,440 --> 00:53:22,079
um the coordinator for something that's

1160
00:53:22,079 --> 00:53:22,960
more stateful

1161
00:53:22,960 --> 00:53:25,440
it's uh like a key value store or

1162
00:53:25,440 --> 00:53:26,079
something it

1163
00:53:26,079 --> 00:53:27,920
it's much more natural to use slanted

1164
00:53:27,920 --> 00:53:30,319
craft

1165
00:53:30,319 --> 00:53:32,480
um so some other questions about

1166
00:53:32,480 --> 00:53:35,280
reproduce the shuffle or combiner step

1167
00:53:35,280 --> 00:53:37,040
when does it happen and what does it do

1168
00:53:37,040 --> 00:53:39,040
so combining occurs

1169
00:53:39,040 --> 00:53:40,640
um like right after the map functions

1170
00:53:40,640 --> 00:53:42,640
applied for example in combining the

1171
00:53:42,640 --> 00:53:43,359
word counts

1172
00:53:43,359 --> 00:53:45,359
of a particular word because having a

1173
00:53:45,359 --> 00:53:46,640
lot of entries that

1174
00:53:46,640 --> 00:53:50,000
you know like the one you could you know

1175
00:53:50,000 --> 00:53:52,800
combine them and then write only that to

1176
00:53:52,800 --> 00:53:54,720
the immediate file

1177
00:53:54,720 --> 00:53:57,839
our intermediate file um sorting occurs

1178
00:53:57,839 --> 00:53:58,559
at the reduce

1179
00:53:58,559 --> 00:54:00,559
after all the outputs of the map are

1180
00:54:00,559 --> 00:54:03,520
read by the reducer

1181
00:54:03,520 --> 00:54:05,680
um let's see a successor to mac produced

1182
00:54:05,680 --> 00:54:06,720
yeah so actually

1183
00:54:06,720 --> 00:54:08,880
i'm not super familiar with it but you

1184
00:54:08,880 --> 00:54:10,000
can look at stuff like

1185
00:54:10,000 --> 00:54:13,359
google cloud data flow um and other

1186
00:54:13,359 --> 00:54:16,319
sort of directed graph computations

1187
00:54:16,319 --> 00:54:17,040
where

1188
00:54:17,040 --> 00:54:19,520
inputs flow into a node so you can think

1189
00:54:19,520 --> 00:54:20,960
of it as a graph and then they

1190
00:54:20,960 --> 00:54:23,520
might flow out to other nodes and that

1191
00:54:23,520 --> 00:54:24,559
node in the middle

1192
00:54:24,559 --> 00:54:26,400
that performs for example a map

1193
00:54:26,400 --> 00:54:28,319
computation and produces intermediate

1194
00:54:28,319 --> 00:54:28,880
data

1195
00:54:28,880 --> 00:54:30,960
that is then sent to other like reducer

1196
00:54:30,960 --> 00:54:32,240
nodes in the graph

1197
00:54:32,240 --> 00:54:35,280
so it's a um interesting way

1198
00:54:35,280 --> 00:54:37,359
it's like a data data flow way to think

1199
00:54:37,359 --> 00:54:39,839
about mapreduce

1200
00:54:39,839 --> 00:54:41,680
um and i'm sure that there's others that

1201
00:54:41,680 --> 00:54:44,400
i'm not necessarily like that aware of

1202
00:54:44,400 --> 00:54:46,960
i don't know one one maybe one of them

1203
00:54:46,960 --> 00:54:50,829
spark which we'll read later about oh

1204
00:54:50,839 --> 00:54:52,799
yeah

1205
00:54:52,799 --> 00:54:55,920
yeah so but the i i like the graph way

1206
00:54:55,920 --> 00:54:57,359
of thinking about that reduce

1207
00:54:57,359 --> 00:54:58,480
because right now we're only really

1208
00:54:58,480 --> 00:55:00,960
thinking about like a two-step operation

1209
00:55:00,960 --> 00:55:03,680
where it could actually be like you know

1210
00:55:03,680 --> 00:55:06,240
many many steps

1211
00:55:06,240 --> 00:55:07,920
um oh yeah and then how are inputs

1212
00:55:07,920 --> 00:55:10,640
partitioned in practice so

1213
00:55:10,640 --> 00:55:13,680
usually because the input space

1214
00:55:13,680 --> 00:55:15,440
is very application specific and the

1215
00:55:15,440 --> 00:55:17,040
output space is also application

1216
00:55:17,040 --> 00:55:18,000
specific

1217
00:55:18,000 --> 00:55:20,480
um it's really up to the programmer to

1218
00:55:20,480 --> 00:55:21,760
specify

1219
00:55:21,760 --> 00:55:29,990
um there sometimes are

1220
00:55:30,000 --> 00:55:33,119
natural for example like maybe a local

1221
00:55:33,119 --> 00:55:34,640
matrix computations and you want to

1222
00:55:34,640 --> 00:55:36,160
combine them or

1223
00:55:36,160 --> 00:55:39,440
so on so forth um or you could if it's

1224
00:55:39,440 --> 00:55:40,000
just like an

1225
00:55:40,000 --> 00:55:42,559
enormous document or like enormous text

1226
00:55:42,559 --> 00:55:43,040
text

1227
00:55:43,040 --> 00:55:45,040
files you can just split it up into

1228
00:55:45,040 --> 00:55:46,319
reasonable sizes of work so that you

1229
00:55:46,319 --> 00:55:47,040
know like

1230
00:55:47,040 --> 00:55:48,880
applying the map function isn't going to

1231
00:55:48,880 --> 00:55:51,440
take forever um and also it depends on

1232
00:55:51,440 --> 00:55:52,960
the size of your cluster so how many

1233
00:55:52,960 --> 00:55:57,190
workers you have

1234
00:55:57,200 --> 00:55:59,760
so some further mapreduce questions why

1235
00:55:59,760 --> 00:56:01,920
do macrosphere files locally so in the

1236
00:56:01,920 --> 00:56:02,640
paper

1237
00:56:02,640 --> 00:56:04,960
this is because at that time the network

1238
00:56:04,960 --> 00:56:06,400
band bandwidth was

1239
00:56:06,400 --> 00:56:09,520
their bottleneck um that's why they

1240
00:56:09,520 --> 00:56:09,839
don't

1241
00:56:09,839 --> 00:56:12,319
use gfs and they only use gfs to write

1242
00:56:12,319 --> 00:56:14,829
the

1243
00:56:14,839 --> 00:56:16,160
um

1244
00:56:16,160 --> 00:56:19,040
yeah to write the output files um are

1245
00:56:19,040 --> 00:56:20,720
leaders necessary for distributed

1246
00:56:20,720 --> 00:56:21,680
systems

1247
00:56:21,680 --> 00:56:25,119
not necessarily um they're

1248
00:56:25,119 --> 00:56:26,799
like think of bitcoin like other

1249
00:56:26,799 --> 00:56:28,480
decentralized systems in which

1250
00:56:28,480 --> 00:56:29,760
all the nodes sort of perform

1251
00:56:29,760 --> 00:56:32,480
computation and some random node or like

1252
00:56:32,480 --> 00:56:34,240
some node in the network is responsible

1253
00:56:34,240 --> 00:56:34,640
for

1254
00:56:34,640 --> 00:56:36,079
committing that so there are definitely

1255
00:56:36,079 --> 00:56:38,880
more like egalitarian designs

1256
00:56:38,880 --> 00:56:41,440
um oh yeah and then our challenge was

1257
00:56:41,440 --> 00:56:43,280
actually to run map reduce onto

1258
00:56:43,280 --> 00:56:45,119
on like actual different servers rather

1259
00:56:45,119 --> 00:56:46,640
than um

1260
00:56:46,640 --> 00:56:49,680
what we kind of had you do in the lab

1261
00:56:49,680 --> 00:56:52,000
and so in order to do this like you

1262
00:56:52,000 --> 00:56:52,880
would just

1263
00:56:52,880 --> 00:56:55,359
instead of using sockets to communicate

1264
00:56:55,359 --> 00:56:57,760
um over for like the rpcs

1265
00:56:57,760 --> 00:57:00,799
you would use like tcp id basically like

1266
00:57:00,799 --> 00:57:01,920
normal

1267
00:57:01,920 --> 00:57:05,760
um like over the network communication

1268
00:57:05,760 --> 00:57:08,640
and you would use a shared file system

1269
00:57:08,640 --> 00:57:09,760
like gms so

1270
00:57:09,760 --> 00:57:11,839
the equivalent i think all of you have

1271
00:57:11,839 --> 00:57:13,119
access to athena

1272
00:57:13,119 --> 00:57:15,040
if at least if you're at mit and you

1273
00:57:15,040 --> 00:57:16,319
could you know

1274
00:57:16,319 --> 00:57:18,559
ssh to multiple athena machines and use

1275
00:57:18,559 --> 00:57:20,240
afs which is

1276
00:57:20,240 --> 00:57:22,559
the file the shared file system that i

1277
00:57:22,559 --> 00:57:23,359
think that uses

1278
00:57:23,359 --> 00:57:26,799
to basically you can access your files

1279
00:57:26,799 --> 00:57:28,880
on athena from any machine

1280
00:57:28,880 --> 00:57:31,280
um similarly you could do the same thing

1281
00:57:31,280 --> 00:57:34,880
by renting aws instances and using s3

1282
00:57:34,880 --> 00:57:37,920
but uh we didn't expect you to spend any

1283
00:57:37,920 --> 00:57:38,960
money to

1284
00:57:38,960 --> 00:57:43,109
to run our lab

1285
00:57:43,119 --> 00:57:44,799
right so some questions that came up

1286
00:57:44,799 --> 00:57:46,720
about just like general code design so

1287
00:57:46,720 --> 00:57:47,200
we've

1288
00:57:47,200 --> 00:57:50,400
some of these we've discussed as well so

1289
00:57:50,400 --> 00:57:52,720
lab one was pretty small lab two is

1290
00:57:52,720 --> 00:57:54,240
going to be

1291
00:57:54,240 --> 00:57:56,400
much larger um especially as you get to

1292
00:57:56,400 --> 00:57:57,760
the later stages

1293
00:57:57,760 --> 00:58:00,640
and as lab 3 and lab 4 come along as

1294
00:58:00,640 --> 00:58:01,680
well

1295
00:58:01,680 --> 00:58:04,720
and one thing that i personally find

1296
00:58:04,720 --> 00:58:05,520
very handy

1297
00:58:05,520 --> 00:58:08,319
is to separate different chunks of code

1298
00:58:08,319 --> 00:58:09,920
by their purpose

1299
00:58:09,920 --> 00:58:12,960
so and also in how i

1300
00:58:12,960 --> 00:58:16,240
implement each step of my code

1301
00:58:16,240 --> 00:58:18,480
so separating them out by for example

1302
00:58:18,480 --> 00:58:19,440
rpcs

1303
00:58:19,440 --> 00:58:22,559
and the settlers and handlers and feel

1304
00:58:22,559 --> 00:58:23,599
free to

1305
00:58:23,599 --> 00:58:25,200
actually separate these out like

1306
00:58:25,200 --> 00:58:26,960
physically in different files

1307
00:58:26,960 --> 00:58:29,359
um that won't like that's fine for our

1308
00:58:29,359 --> 00:58:30,240
tests and

1309
00:58:30,240 --> 00:58:33,440
it will probably help you um like not

1310
00:58:33,440 --> 00:58:35,359
have thousands of lines of code in one

1311
00:58:35,359 --> 00:58:38,799
gigantic file um i

1312
00:58:38,799 --> 00:58:40,799
i personally like to put all definitions

1313
00:58:40,799 --> 00:58:42,319
of state together

1314
00:58:42,319 --> 00:58:45,359
and then functions are

1315
00:58:45,359 --> 00:58:47,040
like sort of separate but that's my

1316
00:58:47,040 --> 00:58:50,480
personal preference um factoring out

1317
00:58:50,480 --> 00:58:52,160
common pieces of code into functions

1318
00:58:52,160 --> 00:58:53,839
will also be very helpful

1319
00:58:53,839 --> 00:58:56,960
for example every single rpc you will

1320
00:58:56,960 --> 00:58:58,799
get in raft you need to check for a sale

1321
00:58:58,799 --> 00:58:59,520
term

1322
00:58:59,520 --> 00:59:02,480
so putting all that logic so that resets

1323
00:59:02,480 --> 00:59:04,079
all the state properly and everything

1324
00:59:04,079 --> 00:59:06,319
into one function that you can just call

1325
00:59:06,319 --> 00:59:07,599
will help

1326
00:59:07,599 --> 00:59:09,200
because you know you don't want to

1327
00:59:09,200 --> 00:59:11,599
actually forget to like reset your

1328
00:59:11,599 --> 00:59:13,760
election timer like reset voted for or

1329
00:59:13,760 --> 00:59:14,640
something

1330
00:59:14,640 --> 00:59:18,000
um although you should have reset the

1331
00:59:18,000 --> 00:59:19,440
election timer so don't do that

1332
00:59:19,440 --> 00:59:21,359
that was an example i pulled off the top

1333
00:59:21,359 --> 00:59:23,119
of my head um

1334
00:59:23,119 --> 00:59:25,200
and also finally having a good

1335
00:59:25,200 --> 00:59:27,119
environment with like autocomplete or

1336
00:59:27,119 --> 00:59:28,559
like being able to search

1337
00:59:28,559 --> 00:59:30,559
for certain keywords in your code and so

1338
00:59:30,559 --> 00:59:32,559
forth can help a lot

1339
00:59:32,559 --> 00:59:35,760
um so if you need any help setting this

1340
00:59:35,760 --> 00:59:37,760
up like come to office hours or there's

1341
00:59:37,760 --> 00:59:40,319
tons of tutorials online you can look up

1342
00:59:40,319 --> 00:59:41,839
you know a good editor

1343
00:59:41,839 --> 00:59:43,680
but it's not necessary it's definitely

1344
00:59:43,680 --> 00:59:45,280
not necessary but it could

1345
00:59:45,280 --> 00:59:49,040
it does help um and then oh yeah so

1346
00:59:49,040 --> 00:59:50,400
someone else has using go

1347
00:59:50,400 --> 00:59:51,680
decrease the amount of time students

1348
00:59:51,680 --> 00:59:54,079
spend debugging so i've never actually

1349
00:59:54,079 --> 00:59:55,280
implemented the labs in c

1350
00:59:55,280 --> 00:59:58,000
plus plus but according to franz like

1351
00:59:58,000 --> 00:59:58,960
well

1352
00:59:58,960 --> 01:00:02,079
the one huge advantage of go is its

1353
01:00:02,079 --> 01:00:03,520
memory management

1354
01:00:03,520 --> 01:00:05,200
so it uses garbage collection and you

1355
01:00:05,200 --> 01:00:06,960
don't have to deal with like

1356
01:00:06,960 --> 01:00:09,680
you know there are pointers but you

1357
01:00:09,680 --> 01:00:10,880
don't have to deal with them in the same

1358
01:00:10,880 --> 01:00:12,160
way that you would in c or c

1359
01:00:12,160 --> 01:00:15,359
plus plus um so like i don't know how

1360
01:00:15,359 --> 01:00:17,040
many of you run into psych faults

1361
01:00:17,040 --> 01:00:19,599
so far but i'm guessing very few of you

1362
01:00:19,599 --> 01:00:21,680
or they were very easy to fix

1363
01:00:21,680 --> 01:00:25,440
and this definitely makes it easier to

1364
01:00:25,440 --> 01:00:26,000
debug

1365
01:00:26,000 --> 01:00:27,680
um or there are just certain types of

1366
01:00:27,680 --> 01:00:30,640
bugs that you don't need to worry about

1367
01:00:30,640 --> 01:00:33,119
sorry i have a question yeah and this is

1368
01:00:33,119 --> 01:00:34,000
like a more

1369
01:00:34,000 --> 01:00:36,960
ghost specific question um but uh when

1370
01:00:36,960 --> 01:00:37,920
you have a function

1371
01:00:37,920 --> 01:00:40,480
that can take in uh let's say you have

1372
01:00:40,480 --> 01:00:41,359
like a

1373
01:00:41,359 --> 01:00:42,960
you have like the pen entries arc and

1374
01:00:42,960 --> 01:00:45,119
you also have like the uh

1375
01:00:45,119 --> 01:00:47,040
request vote arg both of them have a

1376
01:00:47,040 --> 01:00:48,640
term variable inside

1377
01:00:48,640 --> 01:00:50,960
but when you pass it to a function how

1378
01:00:50,960 --> 01:00:51,760
do you

1379
01:00:51,760 --> 01:00:53,359
tell the function that's like hey i

1380
01:00:53,359 --> 01:00:54,960
expect a struct

1381
01:00:54,960 --> 01:01:00,150
that has a term field

1382
01:01:00,160 --> 01:01:03,920
is that possible so you you define

1383
01:01:03,920 --> 01:01:10,069
the types right so it's like any other

1384
01:01:10,079 --> 01:01:11,599
when you pass it into the function the

1385
01:01:11,599 --> 01:01:13,599
function expects an argument of a

1386
01:01:13,599 --> 01:01:15,119
particular type

1387
01:01:15,119 --> 01:01:18,480
and those types yeah yeah let's say i

1388
01:01:18,480 --> 01:01:20,319
want to share one function across

1389
01:01:20,319 --> 01:01:23,280
both types i believe you can use an

1390
01:01:23,280 --> 01:01:24,160
interface

1391
01:01:24,160 --> 01:01:28,240
um but i'm not sure oh yeah so i tried

1392
01:01:28,240 --> 01:01:31,040
but when i do dot term it says i don't

1393
01:01:31,040 --> 01:01:31,599
know this

1394
01:01:31,599 --> 01:01:34,240
field or like it doesn't exist i think

1395
01:01:34,240 --> 01:01:35,599
you need to convert it

1396
01:01:35,599 --> 01:01:38,160
or you need to still have casting i

1397
01:01:38,160 --> 01:01:40,480
can't remember but there's a way to

1398
01:01:40,480 --> 01:01:42,960
coerce you have to type casted back you

1399
01:01:42,960 --> 01:01:43,920
know to whatever

1400
01:01:43,920 --> 01:01:47,040
structure want to access

1401
01:01:47,040 --> 01:01:50,559
like you basically need to tell go

1402
01:01:50,559 --> 01:01:53,280
that by the time i actually use this

1403
01:01:53,280 --> 01:01:53,920
variable

1404
01:01:53,920 --> 01:01:57,039
it is of a particular type got it

1405
01:01:57,039 --> 01:01:58,880
thank you so one thing if you want to

1406
01:01:58,880 --> 01:02:00,640
reuse the function for multiple

1407
01:02:00,640 --> 01:02:01,599
different types

1408
01:02:01,599 --> 01:02:04,000
you can pass in an interface but you

1409
01:02:04,000 --> 01:02:07,119
might also need to pass in for example

1410
01:02:07,119 --> 01:02:10,799
a like uh enum or a bull or something

1411
01:02:10,799 --> 01:02:11,680
that tells it

1412
01:02:11,680 --> 01:02:13,119
like hey this is going to be of this

1413
01:02:13,119 --> 01:02:14,559
type and then you need to cast that

1414
01:02:14,559 --> 01:02:15,680
interface

1415
01:02:15,680 --> 01:02:20,000
into the right type before you use it i

1416
01:02:20,000 --> 01:02:20,880
think

1417
01:02:20,880 --> 01:02:22,400
i think the way people usually handle

1418
01:02:22,400 --> 01:02:24,640
this is by um putting setters and

1419
01:02:24,640 --> 01:02:26,000
getters in the interface

1420
01:02:26,000 --> 01:02:27,359
so you don't actually need to know which

1421
01:02:27,359 --> 01:02:29,200
type it is

1422
01:02:29,200 --> 01:02:30,960
in actuality you can just access the

1423
01:02:30,960 --> 01:02:34,319
variable using interface

1424
01:02:34,319 --> 01:02:38,160
yeah but

1425
01:02:38,160 --> 01:02:41,280
yeah i don't think it you should need

1426
01:02:41,280 --> 01:02:44,319
to use interfaces that much in raft

1427
01:02:44,319 --> 01:02:46,079
like i don't think i used it all other

1428
01:02:46,079 --> 01:02:49,599
than the command which is provided

1429
01:02:49,599 --> 01:02:53,349
um

1430
01:02:53,359 --> 01:02:56,000
yeah like i guess factoring out common

1431
01:02:56,000 --> 01:02:57,920
pieces of code is good unless it adds

1432
01:02:57,920 --> 01:03:02,000
additional complexity um

1433
01:03:02,000 --> 01:03:04,799
or like i wouldn't try and force your

1434
01:03:04,799 --> 01:03:06,400
types to all

1435
01:03:06,400 --> 01:03:08,480
be able to run on the same function like

1436
01:03:08,480 --> 01:03:09,839
it might just be simpler

1437
01:03:09,839 --> 01:03:13,039
to have two slightly different functions

1438
01:03:13,039 --> 01:03:14,799
or if the only like shared piece you're

1439
01:03:14,799 --> 01:03:16,160
using is the term you can have

1440
01:03:16,160 --> 01:03:18,000
like the same function take in just the

1441
01:03:18,000 --> 01:03:20,480
term and in both cases pass in the dot

1442
01:03:20,480 --> 01:03:21,839
term of the

1443
01:03:21,839 --> 01:03:26,950
structure we're using yeah

1444
01:03:26,960 --> 01:03:29,039
cool all right some other code design

1445
01:03:29,039 --> 01:03:31,440
questions this is your extreme museum

1446
01:03:31,440 --> 01:03:34,799
once when separating the code into

1447
01:03:34,799 --> 01:03:36,559
multiple files is their naming

1448
01:03:36,559 --> 01:03:37,920
convention

1449
01:03:37,920 --> 01:03:40,480
like required because when we make the

1450
01:03:40,480 --> 01:03:42,400
lab it seems like it's copying the

1451
01:03:42,400 --> 01:03:44,160
source file so is there any naming

1452
01:03:44,160 --> 01:03:46,000
conversion

1453
01:03:46,000 --> 01:03:49,119
um i mean i would put them in raft the

1454
01:03:49,119 --> 01:03:50,319
raft folder

1455
01:03:50,319 --> 01:03:52,079
but there's no naming convention like

1456
01:03:52,079 --> 01:03:53,440
you can name your files whatever you

1457
01:03:53,440 --> 01:03:53,839
want

1458
01:03:53,839 --> 01:03:57,760
um okay our grading scripts will replace

1459
01:03:57,760 --> 01:03:59,920
anything that's necessary for or like

1460
01:03:59,920 --> 01:04:00,799
anything that

1461
01:04:00,799 --> 01:04:04,079
belongs to the testing framework so

1462
01:04:04,079 --> 01:04:07,119
the config file or like the test file

1463
01:04:07,119 --> 01:04:09,039
anything that you change in there will

1464
01:04:09,039 --> 01:04:10,839
be wiped out

1465
01:04:10,839 --> 01:04:14,480
um yeah there was

1466
01:04:14,480 --> 01:04:16,559
like also be slightly careful about

1467
01:04:16,559 --> 01:04:18,640
using external dependencies

1468
01:04:18,640 --> 01:04:22,000
um i ran into a couple issues with

1469
01:04:22,000 --> 01:04:22,640
grading

1470
01:04:22,640 --> 01:04:26,079
some scripts i had external dependencies

1471
01:04:26,079 --> 01:04:26,480
like

1472
01:04:26,480 --> 01:04:29,839
using some github package go package

1473
01:04:29,839 --> 01:04:32,640
but those were i was able to like fix it

1474
01:04:32,640 --> 01:04:33,839
just be a little careful

1475
01:04:33,839 --> 01:04:36,880
if you do that but yeah create as many

1476
01:04:36,880 --> 01:04:40,640
dot go files and raft as you want

1477
01:04:40,640 --> 01:04:44,319
um yeah so a pointer versus

1478
01:04:44,319 --> 01:04:46,640
a value well passing by reference can be

1479
01:04:46,640 --> 01:04:47,359
cheaper

1480
01:04:47,359 --> 01:04:49,599
because go won't just like copy the

1481
01:04:49,599 --> 01:04:51,920
struct um this was

1482
01:04:51,920 --> 01:04:54,720
this question was asked in particular

1483
01:04:54,720 --> 01:04:55,680
for

1484
01:04:55,680 --> 01:04:58,240
why call takes the arguments and the

1485
01:04:58,240 --> 01:04:59,680
reply as

1486
01:04:59,680 --> 01:05:02,640
um pointers and so you know those could

1487
01:05:02,640 --> 01:05:03,039
be

1488
01:05:03,039 --> 01:05:04,960
potentially extremely large and so good

1489
01:05:04,960 --> 01:05:06,240
doesn't have to copy them

1490
01:05:06,240 --> 01:05:07,599
when you call the function that's the

1491
01:05:07,599 --> 01:05:09,920
main reason um using bud locks and

1492
01:05:09,920 --> 01:05:10,880
channels are possible

1493
01:05:10,880 --> 01:05:14,240
yes um you'll use them both in math so

1494
01:05:14,240 --> 01:05:15,520
you will definitely see how it's

1495
01:05:15,520 --> 01:05:18,390
possible

1496
01:05:18,400 --> 01:05:19,839
oh yeah and then we're getting a lot of

1497
01:05:19,839 --> 01:05:22,400
questions about timeouts um

1498
01:05:22,400 --> 01:05:25,119
so in math in the mapreduce lab the

1499
01:05:25,119 --> 01:05:26,240
timeout was sort of

1500
01:05:26,240 --> 01:05:28,480
well we gave you a set 10 seconds for

1501
01:05:28,480 --> 01:05:30,480
the worker test when they failed

1502
01:05:30,480 --> 01:05:31,839
but in terms of like how long do you

1503
01:05:31,839 --> 01:05:33,440
sleep and stuff you were pretty much

1504
01:05:33,440 --> 01:05:36,079
able to choose anything under that for

1505
01:05:36,079 --> 01:05:37,839
raft you have to choose timeouts a

1506
01:05:37,839 --> 01:05:39,200
little more carefully

1507
01:05:39,200 --> 01:05:42,400
and our tests are like kind of sensitive

1508
01:05:42,400 --> 01:05:44,079
but not super sensitive

1509
01:05:44,079 --> 01:05:45,839
like you'll be able to for example

1510
01:05:45,839 --> 01:05:47,599
probably be within a range of like one

1511
01:05:47,599 --> 01:05:47,920
to

1512
01:05:47,920 --> 01:05:50,960
100 to 200 milliseconds and be fine

1513
01:05:50,960 --> 01:05:54,160
um yeah uh

1514
01:05:54,160 --> 01:05:58,400
in terms of choosing them it

1515
01:05:58,400 --> 01:06:01,119
probably helps to first think about why

1516
01:06:01,119 --> 01:06:01,440
you're

1517
01:06:01,440 --> 01:06:05,920
waiting at all and for example in the

1518
01:06:05,920 --> 01:06:08,000
for raft your leader is sending

1519
01:06:08,000 --> 01:06:09,200
heartbeats

1520
01:06:09,200 --> 01:06:12,079
and your timeout is to detect when the

1521
01:06:12,079 --> 01:06:14,640
leader is dead

1522
01:06:14,640 --> 01:06:17,760
so you kind of want to give the leader a

1523
01:06:17,760 --> 01:06:19,760
couple chances to tell you that it's

1524
01:06:19,760 --> 01:06:20,640
alive

1525
01:06:20,640 --> 01:06:23,200
otherwise you know you'll just

1526
01:06:23,200 --> 01:06:25,039
continuously think it's dead

1527
01:06:25,039 --> 01:06:27,359
so depending on what you set your

1528
01:06:27,359 --> 01:06:28,880
heartbeat time out to be

1529
01:06:28,880 --> 01:06:30,880
or your heartbeat interval to be which i

1530
01:06:30,880 --> 01:06:32,000
think we give you some guidelines

1531
01:06:32,000 --> 01:06:33,839
if it can't be 10 more than 10 times per

1532
01:06:33,839 --> 01:06:36,000
second or something like that

1533
01:06:36,000 --> 01:06:38,880
um depending on what you set your

1534
01:06:38,880 --> 01:06:39,839
heartbeat to be

1535
01:06:39,839 --> 01:06:41,440
you'll want your timeout to be something

1536
01:06:41,440 --> 01:06:43,200
like pretty reasonable like maybe

1537
01:06:43,200 --> 01:06:45,359
allow for the chance to get two to three

1538
01:06:45,359 --> 01:06:46,720
heartbeats

1539
01:06:46,720 --> 01:06:49,039
and then you'll have to randomize some

1540
01:06:49,039 --> 01:06:49,920
like

1541
01:06:49,920 --> 01:06:52,400
range because you don't want all your

1542
01:06:52,400 --> 01:06:53,839
servers to start elections at the same

1543
01:06:53,839 --> 01:06:54,880
time

1544
01:06:54,880 --> 01:06:57,599
and to do that you can you know like a

1545
01:06:57,599 --> 01:06:59,599
range of

1546
01:06:59,599 --> 01:07:04,240
maybe like two to five heartbeats

1547
01:07:04,240 --> 01:07:07,520
sometime out between there is reasonable

1548
01:07:07,520 --> 01:07:10,720
but in terms of the test you'll

1549
01:07:10,720 --> 01:07:13,359
see whether you're sending too many rpcs

1550
01:07:13,359 --> 01:07:14,640
or too many bytes are going over the

1551
01:07:14,640 --> 01:07:15,359
network as

1552
01:07:15,359 --> 01:07:18,799
the tests go um in later labs

1553
01:07:18,799 --> 01:07:20,400
and you can tweak your timeouts very

1554
01:07:20,400 --> 01:07:22,079
easily it's

1555
01:07:22,079 --> 01:07:25,280
slightly implementation dependent

1556
01:07:25,280 --> 01:07:28,400
so i can't tell you like what's the

1557
01:07:28,400 --> 01:07:29,920
perfect number for you

1558
01:07:29,920 --> 01:07:32,079
but thinking of it in terms of like why

1559
01:07:32,079 --> 01:07:33,280
am i timing out

1560
01:07:33,280 --> 01:07:36,240
in the first place and how many rpcs do

1561
01:07:36,240 --> 01:07:37,520
i want to get from like

1562
01:07:37,520 --> 01:07:40,079
other servers before i time out is a

1563
01:07:40,079 --> 01:07:42,400
good metric to keep in mind

1564
01:07:42,400 --> 01:07:45,039
um so hopefully that helps a little bit

1565
01:07:45,039 --> 01:07:46,960
timeouts

1566
01:07:46,960 --> 01:07:49,119
uh okay yeah so some implementation

1567
01:07:49,119 --> 01:07:50,480
questions that

1568
01:07:50,480 --> 01:07:53,280
um came up about the mapreduce lab and

1569
01:07:53,280 --> 01:07:55,359
also the labs in general

1570
01:07:55,359 --> 01:07:59,440
so some people actually did implement

1571
01:07:59,440 --> 01:08:01,280
backup tests which is pretty cool and we

1572
01:08:01,280 --> 01:08:02,880
definitely did not require that

1573
01:08:02,880 --> 01:08:06,559
for this lab um and

1574
01:08:06,559 --> 01:08:08,400
i think something that was important to

1575
01:08:08,400 --> 01:08:10,319
keep in mind is that the paper

1576
01:08:10,319 --> 01:08:13,359
has makes a distinction between start

1577
01:08:13,359 --> 01:08:16,000
restarting a task because a worker has

1578
01:08:16,000 --> 01:08:17,199
failed

1579
01:08:17,199 --> 01:08:20,480
and issuing the task again

1580
01:08:20,480 --> 01:08:23,440
to speed up a lagging task that you know

1581
01:08:23,440 --> 01:08:25,279
the worker hasn't failed

1582
01:08:25,279 --> 01:08:28,319
but you want the task to complete faster

1583
01:08:28,319 --> 01:08:30,080
and so backup tasks are used for the

1584
01:08:30,080 --> 01:08:32,560
latter when tasks are haven't failed yet

1585
01:08:32,560 --> 01:08:33,600
but they're

1586
01:08:33,600 --> 01:08:37,040
they're just slow and timeouts

1587
01:08:37,040 --> 01:08:39,040
start tasks when workers are actually

1588
01:08:39,040 --> 01:08:40,640
detected to fail

1589
01:08:40,640 --> 01:08:43,199
so in the paper the coordinator actually

1590
01:08:43,199 --> 01:08:45,679
gets heartbeats from the workers

1591
01:08:45,679 --> 01:08:48,480
whereas in the design that we proposed

1592
01:08:48,480 --> 01:08:49,679
for your lab

1593
01:08:49,679 --> 01:08:52,080
we use timeouts both to detect that

1594
01:08:52,080 --> 01:08:52,880
worker has

1595
01:08:52,880 --> 01:08:55,920
probably failed and also to detect slow

1596
01:08:55,920 --> 01:08:56,560
tests

1597
01:08:56,560 --> 01:08:58,880
so some in some ways we make that just

1598
01:08:58,880 --> 01:09:00,719
we don't have that distinction

1599
01:09:00,719 --> 01:09:02,719
we just assume that like if this task

1600
01:09:02,719 --> 01:09:05,279
hasn't completed in this set of time

1601
01:09:05,279 --> 01:09:06,960
that you know like probably the worker

1602
01:09:06,960 --> 01:09:08,480
has failed or maybe it's just insanely

1603
01:09:08,480 --> 01:09:10,239
slow and let's reissue it

1604
01:09:10,239 --> 01:09:13,440
so that's why um our labs

1605
01:09:13,440 --> 01:09:16,799
don't really mention backup tests

1606
01:09:16,799 --> 01:09:20,000
um so and then yeah so there

1607
01:09:20,000 --> 01:09:21,199
this is again going back to the

1608
01:09:21,199 --> 01:09:23,600
confusion the next question um

1609
01:09:23,600 --> 01:09:25,600
about like synchronization if the

1610
01:09:25,600 --> 01:09:27,040
servers are on different machines so the

1611
01:09:27,040 --> 01:09:27,839
servers

1612
01:09:27,839 --> 01:09:30,480
are on different machines and they only

1613
01:09:30,480 --> 01:09:32,480
communicate using rpcs

1614
01:09:32,480 --> 01:09:34,799
all synchronization is just protecting

1615
01:09:34,799 --> 01:09:36,799
or like synchronizing the threads on one

1616
01:09:36,799 --> 01:09:38,000
server

1617
01:09:38,000 --> 01:09:40,400
um i just wanted to emphasize that one

1618
01:09:40,400 --> 01:09:43,189
more time

1619
01:09:43,199 --> 01:09:45,359
um common sources of race conditions

1620
01:09:45,359 --> 01:09:46,839
just you know

1621
01:09:46,839 --> 01:09:50,719
blocking um i

1622
01:09:50,719 --> 01:09:53,279
in some ways i think uh someone's

1623
01:09:53,279 --> 01:09:54,320
talking about like

1624
01:09:54,320 --> 01:09:56,000
you know how do you know when to log and

1625
01:09:56,000 --> 01:09:57,440
how do you know when to

1626
01:09:57,440 --> 01:10:00,640
you know use synchronization so anytime

1627
01:10:00,640 --> 01:10:04,000
you're modifying the state of the

1628
01:10:04,000 --> 01:10:05,600
you know like your raf server or the

1629
01:10:05,600 --> 01:10:08,880
coordinator anytime you modify this date

1630
01:10:08,880 --> 01:10:11,440
you want to unlock and what you'll

1631
01:10:11,440 --> 01:10:11,920
notice

1632
01:10:11,920 --> 01:10:15,600
is that for almost every function

1633
01:10:15,600 --> 01:10:18,400
in your raft implementation for example

1634
01:10:18,400 --> 01:10:19,199
you will have

1635
01:10:19,199 --> 01:10:22,000
a lock and then a defer unlock like

1636
01:10:22,000 --> 01:10:24,000
right after that

1637
01:10:24,000 --> 01:10:26,320
the only times you need to make sure

1638
01:10:26,320 --> 01:10:27,440
that you're not locked

1639
01:10:27,440 --> 01:10:29,679
is when you make a call that might block

1640
01:10:29,679 --> 01:10:30,560
so

1641
01:10:30,560 --> 01:10:33,600
sending an rpc um

1642
01:10:33,600 --> 01:10:34,960
you know sending something over a

1643
01:10:34,960 --> 01:10:37,520
channel those type of operations you

1644
01:10:37,520 --> 01:10:38,800
shouldn't lock around because then

1645
01:10:38,800 --> 01:10:39,360
you're

1646
01:10:39,360 --> 01:10:41,040
you're that thread will just be blocked

1647
01:10:41,040 --> 01:10:42,719
on that and hold the lock

1648
01:10:42,719 --> 01:10:45,120
and stop the server any thread on the

1649
01:10:45,120 --> 01:10:47,679
server from making progress

1650
01:10:47,679 --> 01:10:49,679
um yeah and then there are also some

1651
01:10:49,679 --> 01:10:51,679
questions about like

1652
01:10:51,679 --> 01:10:53,600
there are some data races that are

1653
01:10:53,600 --> 01:10:55,520
benign like for example you could set is

1654
01:10:55,520 --> 01:10:56,320
done

1655
01:10:56,320 --> 01:10:58,800
um to be true and you know like you

1656
01:10:58,800 --> 01:11:00,080
don't really need to walk around that

1657
01:11:00,080 --> 01:11:02,080
but the razor detector is complaining

1658
01:11:02,080 --> 01:11:05,040
um you could use an atomic bowl which

1659
01:11:05,040 --> 01:11:06,719
has the same behavior as like walking

1660
01:11:06,719 --> 01:11:07,440
before and

1661
01:11:07,440 --> 01:11:10,480
unlocking after but

1662
01:11:10,480 --> 01:11:11,840
even though you might think this data

1663
01:11:11,840 --> 01:11:13,520
race is benign it's

1664
01:11:13,520 --> 01:11:16,880
undefined behavior so it just so happens

1665
01:11:16,880 --> 01:11:18,159
that you know eventually

1666
01:11:18,159 --> 01:11:21,440
the next read like your read might miss

1667
01:11:21,440 --> 01:11:22,800
the fact that it's done but the next

1668
01:11:22,800 --> 01:11:24,640
time you call is done it'll say

1669
01:11:24,640 --> 01:11:27,760
true and then you're fine but undefined

1670
01:11:27,760 --> 01:11:28,400
behavior

1671
01:11:28,400 --> 01:11:30,960
could technically be implemented as

1672
01:11:30,960 --> 01:11:31,679
anything

1673
01:11:31,679 --> 01:11:33,280
like it just so happens that your

1674
01:11:33,280 --> 01:11:35,760
compiler and your processor does

1675
01:11:35,760 --> 01:11:36,880
something reasonable

1676
01:11:36,880 --> 01:11:39,600
when there's a database so you should

1677
01:11:39,600 --> 01:11:41,120
handle them especially when they're this

1678
01:11:41,120 --> 01:11:42,159
simple

1679
01:11:42,159 --> 01:11:43,920
um and they don't really affect

1680
01:11:43,920 --> 01:11:46,080
performance that much

1681
01:11:46,080 --> 01:11:50,000
another thing is well

1682
01:11:50,000 --> 01:11:53,120
in in theory you could have

1683
01:11:53,120 --> 01:11:55,120
this like is done data race could

1684
01:11:55,120 --> 01:11:56,800
potentially mean that your

1685
01:11:56,800 --> 01:11:59,760
process would never exit because you

1686
01:11:59,760 --> 01:12:00,480
know the right

1687
01:12:00,480 --> 01:12:03,120
to is done setting it to true might

1688
01:12:03,120 --> 01:12:04,960
never actually propagate to the thread

1689
01:12:04,960 --> 01:12:06,159
that's reading

1690
01:12:06,159 --> 01:12:08,480
what whether it's true or not because it

1691
01:12:08,480 --> 01:12:09,280
could be stored in

1692
01:12:09,280 --> 01:12:11,760
some like buffer and never flushed what

1693
01:12:11,760 --> 01:12:13,120
locks ensure

1694
01:12:13,120 --> 01:12:16,000
is that you're right um the next thread

1695
01:12:16,000 --> 01:12:17,280
that reads

1696
01:12:17,280 --> 01:12:20,480
is done will see the last

1697
01:12:20,480 --> 01:12:23,760
um right is done and i'll actually flush

1698
01:12:23,760 --> 01:12:24,400
it from

1699
01:12:24,400 --> 01:12:26,640
for example a potential buffer that the

1700
01:12:26,640 --> 01:12:28,400
right could be stored in

1701
01:12:28,400 --> 01:12:31,440
so yeah that's just emphasizing like

1702
01:12:31,440 --> 01:12:33,199
you don't want data races even if you

1703
01:12:33,199 --> 01:12:36,400
think that they're really friendly um

1704
01:12:36,400 --> 01:12:39,679
clean way to exit so

1705
01:12:39,679 --> 01:12:42,159
sending a exit rpc from the coordination

1706
01:12:42,159 --> 01:12:43,040
worker

1707
01:12:43,040 --> 01:12:46,080
works also like the

1708
01:12:46,080 --> 01:12:48,640
quote-unquote like messy exits where the

1709
01:12:48,640 --> 01:12:49,520
worker like

1710
01:12:49,520 --> 01:12:51,600
tries to send an rpc and sees the socket

1711
01:12:51,600 --> 01:12:53,679
is closed like those are also fine

1712
01:12:53,679 --> 01:12:57,120
um we like both

1713
01:12:57,120 --> 01:13:01,679
solutions are equally acceptable um

1714
01:13:01,679 --> 01:13:04,480
and then unexpected end of file errors

1715
01:13:04,480 --> 01:13:05,679
so

1716
01:13:05,679 --> 01:13:07,760
you can look i have a link here that

1717
01:13:07,760 --> 01:13:09,520
basically shows when it's invoked in the

1718
01:13:09,520 --> 01:13:11,600
client but it's a little

1719
01:13:11,600 --> 01:13:14,159
um confusing as to when that actually

1720
01:13:14,159 --> 01:13:15,840
happens so i would

1721
01:13:15,840 --> 01:13:17,760
not worry about it too much if anyone

1722
01:13:17,760 --> 01:13:21,270
has insights into

1723
01:13:21,280 --> 01:13:24,480
uh if they got this error at a very like

1724
01:13:24,480 --> 01:13:26,480
strange moment then we could look into

1725
01:13:26,480 --> 01:13:28,480
it but i think it's very specific on

1726
01:13:28,480 --> 01:13:29,679
your implementation so i would have to

1727
01:13:29,679 --> 01:13:30,400
look at that

1728
01:13:30,400 --> 01:13:32,400
in particular but we got a bunch of

1729
01:13:32,400 --> 01:13:34,800
questions about that

1730
01:13:34,800 --> 01:13:38,159
um yeah i think so that's basically

1731
01:13:38,159 --> 01:13:40,480
most of the questions that came up and i

1732
01:13:40,480 --> 01:13:42,080
think now if you have any questions

1733
01:13:42,080 --> 01:13:43,199
about you know

1734
01:13:43,199 --> 01:13:46,400
go mapreduce or if you want to

1735
01:13:46,400 --> 01:13:49,040
ask some stuff about the the labs i had

1736
01:13:49,040 --> 01:13:50,080
a question about

1737
01:13:50,080 --> 01:13:54,800
um the clean way to exit

1738
01:13:54,800 --> 01:13:58,080
um so you're saying like send an xcr pc

1739
01:13:58,080 --> 01:13:59,600
i was just wondering if there were like

1740
01:13:59,600 --> 01:14:02,000
if there was like a case

1741
01:14:02,000 --> 01:14:04,719
where like a worker for some reason just

1742
01:14:04,719 --> 01:14:05,679
takes a very like

1743
01:14:05,679 --> 01:14:08,239
a very long time to reach the server

1744
01:14:08,239 --> 01:14:08,880
right like

1745
01:14:08,880 --> 01:14:12,080
like how does the server know like when

1746
01:14:12,080 --> 01:14:12,400
to

1747
01:14:12,400 --> 01:14:15,760
like shut down because because uh

1748
01:14:15,760 --> 01:14:17,600
because the the coordinator shuts down

1749
01:14:17,600 --> 01:14:18,880
at some point right like when

1750
01:14:18,880 --> 01:14:21,280
when when it says like done when done

1751
01:14:21,280 --> 01:14:22,880
returns through

1752
01:14:22,880 --> 01:14:25,679
um it shuts down and so it stops

1753
01:14:25,679 --> 01:14:26,560
replying

1754
01:14:26,560 --> 01:14:29,600
to the workers um how does it decide

1755
01:14:29,600 --> 01:14:32,800
when to do that if it's waiting for for

1756
01:14:32,800 --> 01:14:34,080
workers

1757
01:14:34,080 --> 01:14:37,520
to to shut down themselves

1758
01:14:37,520 --> 01:14:40,880
oh so in this case the coordinator

1759
01:14:40,880 --> 01:14:44,239
isn't oh i guess so sun is

1760
01:14:44,239 --> 01:14:45,920
probably the wrong word the coordinator

1761
01:14:45,920 --> 01:14:48,000
isn't waiting for the workers to respond

1762
01:14:48,000 --> 01:14:50,800
the coordinator is it's not sending it's

1763
01:14:50,800 --> 01:14:52,640
replying to the

1764
01:14:52,640 --> 01:14:55,360
request from workers with a like the

1765
01:14:55,360 --> 01:14:57,199
task is done please exit

1766
01:14:57,199 --> 01:14:59,600
so the worker isn't uh the coordinator

1767
01:14:59,600 --> 01:15:00,400
isn't actually

1768
01:15:00,400 --> 01:15:02,239
waiting for the workers at all and so in

1769
01:15:02,239 --> 01:15:04,320
this case the coordinator could actually

1770
01:15:04,320 --> 01:15:07,040
still exit before the workers and cause

1771
01:15:07,040 --> 01:15:08,159
the workers to

1772
01:15:08,159 --> 01:15:11,920
like you know have a disconnected socket

1773
01:15:11,920 --> 01:15:14,080
error and then exit

1774
01:15:14,080 --> 01:15:16,320
yeah i guess that was my question right

1775
01:15:16,320 --> 01:15:17,440
like like if

1776
01:15:17,440 --> 01:15:21,760
if it like the coordinators replying

1777
01:15:21,760 --> 01:15:23,760
to workers right that are like

1778
01:15:23,760 --> 01:15:25,280
potentially like

1779
01:15:25,280 --> 01:15:28,320
asking for um get tasks

1780
01:15:28,320 --> 01:15:31,360
but what happens if the worker shuts

1781
01:15:31,360 --> 01:15:32,159
down

1782
01:15:32,159 --> 01:15:34,159
or sorry the coordinator shuts down

1783
01:15:34,159 --> 01:15:35,840
before it gets a

1784
01:15:35,840 --> 01:15:39,199
like a re i get i get task rpc from

1785
01:15:39,199 --> 01:15:41,920
the worker oh then the next time that

1786
01:15:41,920 --> 01:15:43,360
the worker tries to contact the

1787
01:15:43,360 --> 01:15:45,120
coordinator the worker will see that the

1788
01:15:45,120 --> 01:15:47,120
connection is closed and then exit

1789
01:15:47,120 --> 01:15:50,560
okay yeah that just clean

1790
01:15:50,560 --> 01:15:55,990
uh i shut down that as well get

1791
01:15:56,000 --> 01:15:58,159
uh essentially i mean you could imagine

1792
01:15:58,159 --> 01:15:59,360
that

1793
01:15:59,360 --> 01:16:01,280
you know you could set up the workers to

1794
01:16:01,280 --> 01:16:03,600
be rbc servers and then you would

1795
01:16:03,600 --> 01:16:05,760
actually have the coordinator be sending

1796
01:16:05,760 --> 01:16:07,840
these like please exit and the

1797
01:16:07,840 --> 01:16:08,960
coordinator would have to wait for the

1798
01:16:08,960 --> 01:16:10,000
workers to exit

1799
01:16:10,000 --> 01:16:15,189
but it's not um

1800
01:16:15,199 --> 01:16:16,800
or it doesn't seem like you would get

1801
01:16:16,800 --> 01:16:20,480
any utility out of that um

1802
01:16:20,480 --> 01:16:24,960
thanks yeah uh cat i see you have your

1803
01:16:24,960 --> 01:16:28,080
hands uh yeah something that i was

1804
01:16:28,080 --> 01:16:28,960
wondering about

1805
01:16:28,960 --> 01:16:31,040
is for the future labs are we allowed to

1806
01:16:31,040 --> 01:16:32,480
have more files because i think

1807
01:16:32,480 --> 01:16:34,000
explicitly in the map produce lab we

1808
01:16:34,000 --> 01:16:36,640
were only supposed to have three

1809
01:16:36,640 --> 01:16:38,880
and it didn't read something where it

1810
01:16:38,880 --> 01:16:40,640
was like hey you should have all of your

1811
01:16:40,640 --> 01:16:41,360
stuff

1812
01:16:41,360 --> 01:16:44,400
contained in one oh yeah so

1813
01:16:44,400 --> 01:16:47,600
you can definitely have more files um

1814
01:16:47,600 --> 01:16:50,239
that's like i would almost encourage

1815
01:16:50,239 --> 01:16:50,719
that

1816
01:16:50,719 --> 01:16:55,040
um i did we say that about mapreduce

1817
01:16:55,040 --> 01:16:56,960
i i don't i can't remember whether we

1818
01:16:56,960 --> 01:16:58,560
did what were you saying you couldn't

1819
01:16:58,560 --> 01:16:59,679
edit any of the other

1820
01:16:59,679 --> 01:17:01,679
main files is it like yeah you can't

1821
01:17:01,679 --> 01:17:02,719
edit the files and

1822
01:17:02,719 --> 01:17:05,679
yeah okay i misread that thanks this

1823
01:17:05,679 --> 01:17:06,320
makes me

1824
01:17:06,320 --> 01:17:09,679
feel a lot better all right yeah yeah um

1825
01:17:09,679 --> 01:17:11,520
but definitely like bringing up your

1826
01:17:11,520 --> 01:17:14,840
code will be useful

1827
01:17:14,840 --> 01:17:16,880
um i have a

1828
01:17:16,880 --> 01:17:21,040
question about the benign data races um

1829
01:17:21,040 --> 01:17:23,679
i guess like because sometimes there's

1830
01:17:23,679 --> 01:17:24,960
for example in raft you just want to

1831
01:17:24,960 --> 01:17:26,800
like read the current state

1832
01:17:26,800 --> 01:17:30,400
of the uh of the raft server um

1833
01:17:30,400 --> 01:17:32,719
why would multiple write multiple

1834
01:17:32,719 --> 01:17:34,000
threads writing to it

1835
01:17:34,000 --> 01:17:36,400
and one reading so why would a read and

1836
01:17:36,400 --> 01:17:38,239
a write to the same variable

1837
01:17:38,239 --> 01:17:40,800
end up cause undefined behavior because

1838
01:17:40,800 --> 01:17:42,840
three either comes before or after the

1839
01:17:42,840 --> 01:17:44,080
write

1840
01:17:44,080 --> 01:17:47,920
so one thing that can happen

1841
01:17:47,920 --> 01:17:52,560
and most processors don't do this but

1842
01:17:52,560 --> 01:17:56,080
every time you have a

1843
01:17:56,080 --> 01:17:59,040
like so these any thread can run on like

1844
01:17:59,040 --> 01:18:00,640
a separate core

1845
01:18:00,640 --> 01:18:04,159
um and every core has a

1846
01:18:04,159 --> 01:18:07,199
buffer for the data that it's reading or

1847
01:18:07,199 --> 01:18:08,000
writing

1848
01:18:08,000 --> 01:18:09,760
um or writing i guess like a store

1849
01:18:09,760 --> 01:18:11,760
buffer so for example

1850
01:18:11,760 --> 01:18:15,440
thread one could write one value

1851
01:18:15,440 --> 01:18:18,640
to the state and thread two could

1852
01:18:18,640 --> 01:18:20,640
try to read it um or like multiple

1853
01:18:20,640 --> 01:18:22,239
threads could be writing

1854
01:18:22,239 --> 01:18:26,000
and thread one without a lock so locks

1855
01:18:26,000 --> 01:18:29,280
essentially flush the buffer um

1856
01:18:29,280 --> 01:18:32,880
without that lock this right might just

1857
01:18:32,880 --> 01:18:35,520
like stay in thread one's like store

1858
01:18:35,520 --> 01:18:36,960
buffer forever

1859
01:18:36,960 --> 01:18:40,080
and the read will never return

1860
01:18:40,080 --> 01:18:43,120
um the updated value so

1861
01:18:43,120 --> 01:18:46,480
this behavior doesn't quite happen in

1862
01:18:46,480 --> 01:18:47,520
practice but it's an

1863
01:18:47,520 --> 01:18:49,520
allowable behavior because you do not

1864
01:18:49,520 --> 01:18:51,199
have the law

1865
01:18:51,199 --> 01:18:53,040
sorry so what happens if the right has a

1866
01:18:53,040 --> 01:18:55,280
lock but the read doesn't

1867
01:18:55,280 --> 01:19:03,110
like doesn't read always need a lock

1868
01:19:03,120 --> 01:19:06,830
yes

1869
01:19:06,840 --> 01:19:11,430
because

1870
01:19:11,440 --> 01:19:14,880
i think i'll read i i googled it a

1871
01:19:14,880 --> 01:19:16,400
little bit and people are like yeah

1872
01:19:16,400 --> 01:19:16,719
don't

1873
01:19:16,719 --> 01:19:20,000
don't even try lot less share data but i

1874
01:19:20,000 --> 01:19:21,120
don't really understand

1875
01:19:21,120 --> 01:19:25,430
why that would be a problem

1876
01:19:25,440 --> 01:19:28,000
go ahead you could like be doing

1877
01:19:28,000 --> 01:19:29,440
something that assumes the thing was

1878
01:19:29,440 --> 01:19:31,040
true and then like when you read

1879
01:19:31,040 --> 01:19:33,280
it's not actually true yet like there

1880
01:19:33,280 --> 01:19:36,480
might be multiple things right

1881
01:19:36,480 --> 01:19:38,000
that's why you don't want to lock this

1882
01:19:38,000 --> 01:19:39,760
read so

1883
01:19:39,760 --> 01:19:42,880
the only time you might

1884
01:19:42,880 --> 01:19:45,760
be able to even get away with this is if

1885
01:19:45,760 --> 01:19:46,239
you

1886
01:19:46,239 --> 01:19:49,840
only read a single word and that's all

1887
01:19:49,840 --> 01:19:51,360
the thread does and it never

1888
01:19:51,360 --> 01:19:54,880
does multiple reads but i think you

1889
01:19:54,880 --> 01:20:01,110
still have some issues with

1890
01:20:01,120 --> 01:20:04,320
one of the other things is

1891
01:20:04,320 --> 01:20:05,840
if you're reading more than one piece of

1892
01:20:05,840 --> 01:20:07,600
data like if on one thread

1893
01:20:07,600 --> 01:20:10,800
you take a lock a sign a a sign b

1894
01:20:10,800 --> 01:20:13,920
another thread it doesn't take a lock

1895
01:20:13,920 --> 01:20:17,199
might see b the new value of b before it

1896
01:20:17,199 --> 01:20:18,080
sees the new value

1897
01:20:18,080 --> 01:20:20,159
of a the ordering that you messed up and

1898
01:20:20,159 --> 01:20:21,360
so if you read like

1899
01:20:21,360 --> 01:20:24,639
a term uh from one that

1900
01:20:24,639 --> 01:20:27,360
from one variable and like whether or

1901
01:20:27,360 --> 01:20:28,480
not it's the leader from another

1902
01:20:28,480 --> 01:20:29,360
variable

1903
01:20:29,360 --> 01:20:31,840
you might read a pair of values that

1904
01:20:31,840 --> 01:20:33,600
never actually existed

1905
01:20:33,600 --> 01:20:36,800
because there aren't the guarantees

1906
01:20:36,800 --> 01:20:38,480
like when you're working with concrete

1907
01:20:38,480 --> 01:20:40,320
systems you

1908
01:20:40,320 --> 01:20:42,159
need to build everything based off what

1909
01:20:42,159 --> 01:20:43,840
the guarantees are that the platform

1910
01:20:43,840 --> 01:20:44,800
provides to you

1911
01:20:44,800 --> 01:20:47,040
and if you don't there's all kinds of

1912
01:20:47,040 --> 01:20:48,800
weird edge cases that can

1913
01:20:48,800 --> 01:20:52,480
throw you off and yeah

1914
01:20:52,480 --> 01:20:54,400
yes because i think the only case in

1915
01:20:54,400 --> 01:20:56,000
which you can even

1916
01:20:56,000 --> 01:20:58,880
like try to reason about this is that as

1917
01:20:58,880 --> 01:21:00,000
if there's only ever

1918
01:21:00,000 --> 01:21:03,040
one like you know word in the system

1919
01:21:03,040 --> 01:21:03,920
that you're ever

1920
01:21:03,920 --> 01:21:06,239
trying to read and write to as soon as

1921
01:21:06,239 --> 01:21:08,080
you try to

1922
01:21:08,080 --> 01:21:11,840
write or read multiple uh pieces of data

1923
01:21:11,840 --> 01:21:12,880
then it's

1924
01:21:12,880 --> 01:21:14,639
like you won't be able to reason about

1925
01:21:14,639 --> 01:21:17,830
anything without loss

1926
01:21:17,840 --> 01:21:20,080
basically if you want to play games with

1927
01:21:20,080 --> 01:21:21,520
this you have to

1928
01:21:21,520 --> 01:21:23,920
really understand the compiler the

1929
01:21:23,920 --> 01:21:25,120
programming language and the memory

1930
01:21:25,120 --> 01:21:25,840
model

1931
01:21:25,840 --> 01:21:28,239
the processor you're using and yeah it's

1932
01:21:28,239 --> 01:21:30,400
like memory coherency system

1933
01:21:30,400 --> 01:21:33,040
um it gets slightly complicated

1934
01:21:33,040 --> 01:21:34,719
incredibly quickly

1935
01:21:34,719 --> 01:21:36,560
yeah it's also like i mean this is all

1936
01:21:36,560 --> 01:21:38,480
undefined behavior so even if it works

1937
01:21:38,480 --> 01:21:39,280
now

1938
01:21:39,280 --> 01:21:41,199
like you know i could someone could

1939
01:21:41,199 --> 01:21:43,440
write just like a new compiler and then

1940
01:21:43,440 --> 01:21:46,080
you're like that's where the whole thing

1941
01:21:46,080 --> 01:21:48,239
about like demons can fly up your nose

1942
01:21:48,239 --> 01:21:50,560
like it can literally do anything if you

1943
01:21:50,560 --> 01:21:51,840
have a database because it's like oh

1944
01:21:51,840 --> 01:21:52,480
this program

1945
01:21:52,480 --> 01:21:54,880
like doesn't have any semantics that we

1946
01:21:54,880 --> 01:21:55,520
can

1947
01:21:55,520 --> 01:21:58,639
like you know go crazy so i would i

1948
01:21:58,639 --> 01:22:01,669
would not risk it

1949
01:22:01,679 --> 01:22:04,880
okay it makes sense thank you yeah so so

1950
01:22:04,880 --> 01:22:06,560
even when we're accessing like

1951
01:22:06,560 --> 01:22:08,159
anything just reading like let's say a

1952
01:22:08,159 --> 01:22:10,000
rap server state we should still

1953
01:22:10,000 --> 01:22:13,280
wrap it in a lock yes right yeah it just

1954
01:22:13,280 --> 01:22:14,800
gets annoying sometimes because you have

1955
01:22:14,800 --> 01:22:16,719
to like

1956
01:22:16,719 --> 01:22:18,960
wrap the single read in a lock and

1957
01:22:18,960 --> 01:22:19,920
unlock but

1958
01:22:19,920 --> 01:22:24,639
i'm not sure if like anything

1959
01:22:24,639 --> 01:22:28,239
uh that shouldn't happen super often

1960
01:22:28,239 --> 01:22:31,760
um like i mean maybe if you want to for

1961
01:22:31,760 --> 01:22:33,440
example check that you're still a leader

1962
01:22:33,440 --> 01:22:34,960
if you're not exit or something like

1963
01:22:34,960 --> 01:22:40,470
that but

1964
01:22:40,480 --> 01:22:43,360
yeah i don't like i forget do we use

1965
01:22:43,360 --> 01:22:45,360
like atomic pools for

1966
01:22:45,360 --> 01:22:49,350
like killed state for example

1967
01:22:49,360 --> 01:22:51,440
that like you could use an atomic bowl

1968
01:22:51,440 --> 01:22:52,719
which essentially is like

1969
01:22:52,719 --> 01:22:54,560
locking and unlocking right before

1970
01:22:54,560 --> 01:22:55,760
accessing it

1971
01:22:55,760 --> 01:22:59,920
and right after but

1972
01:22:59,920 --> 01:23:03,750
yeah i

1973
01:23:03,760 --> 01:23:07,360
i i think you'll like having in some

1974
01:23:07,360 --> 01:23:09,280
ways very like coarse grain locks and

1975
01:23:09,280 --> 01:23:10,400
knowing that

1976
01:23:10,400 --> 01:23:11,840
you're the only one touching a piece of

1977
01:23:11,840 --> 01:23:13,440
state will become

1978
01:23:13,440 --> 01:23:15,600
very handy as you reason about your

1979
01:23:15,600 --> 01:23:17,840
implementations

1980
01:23:17,840 --> 01:23:21,910
thank you

1981
01:23:21,920 --> 01:23:24,719
uh i have a question about the channels

1982
01:23:24,719 --> 01:23:25,600
so

1983
01:23:25,600 --> 01:23:27,360
when you make a channel it's only

1984
01:23:27,360 --> 01:23:29,600
between two threads

1985
01:23:29,600 --> 01:23:31,440
right or it can be between multiple

1986
01:23:31,440 --> 01:23:32,800
threads but like

1987
01:23:32,800 --> 01:23:36,400
if you not if you don't have it um

1988
01:23:36,400 --> 01:23:38,639
buffered it can potentially just lock

1989
01:23:38,639 --> 01:23:40,560
and block forever right so

1990
01:23:40,560 --> 01:23:42,159
for example if you want to do something

1991
01:23:42,159 --> 01:23:44,800
raph and then you have like election

1992
01:23:44,800 --> 01:23:47,040
you have a channel that like does

1993
01:23:47,040 --> 01:23:48,000
something about election

1994
01:23:48,000 --> 01:23:50,560
timeouts you would need a buffer channel

1995
01:23:50,560 --> 01:23:52,239
that's like the size of the amount of

1996
01:23:52,239 --> 01:23:54,000
servers correct because like you could

1997
01:23:54,000 --> 01:23:54,800
like

1998
01:23:54,800 --> 01:23:56,800
send something and then like it blocks

1999
01:23:56,800 --> 01:23:58,159
because

2000
01:23:58,159 --> 01:24:00,320
you can be you can have multiple like

2001
01:24:00,320 --> 01:24:01,520
election uh

2002
01:24:01,520 --> 01:24:04,159
things election messages sent between

2003
01:24:04,159 --> 01:24:05,840
the channels

2004
01:24:05,840 --> 01:24:07,600
correct so if you want a on buffer

2005
01:24:07,600 --> 01:24:09,360
channel it should only be between

2006
01:24:09,360 --> 01:24:11,040
it should only be between two threads

2007
01:24:11,040 --> 01:24:13,360
only correct

2008
01:24:13,360 --> 01:24:15,280
um i mean not necessarily like if two

2009
01:24:15,280 --> 01:24:16,960
threads are consumers and one thread's a

2010
01:24:16,960 --> 01:24:17,679
producer

2011
01:24:17,679 --> 01:24:20,800
then okay but

2012
01:24:20,800 --> 01:24:22,639
multiple producers i guess you would

2013
01:24:22,639 --> 01:24:25,760
need that correct

2014
01:24:25,760 --> 01:24:27,600
well not necessarily i mean if the

2015
01:24:27,600 --> 01:24:29,199
consumer is

2016
01:24:29,199 --> 01:24:30,400
you know just doing a loop and

2017
01:24:30,400 --> 01:24:32,239
constantly reading then

2018
01:24:32,239 --> 01:24:35,760
all the producers would just

2019
01:24:35,760 --> 01:24:38,560
like i guess it depends on how they're

2020
01:24:38,560 --> 01:24:39,760
scheduled

2021
01:24:39,760 --> 01:24:43,040
uh but if you like you would eventually

2022
01:24:43,040 --> 01:24:45,840
have someone reading from the channel so

2023
01:24:45,840 --> 01:24:47,840
you can have multiple producers and one

2024
01:24:47,840 --> 01:24:50,870
consumer

2025
01:24:50,880 --> 01:24:52,800
actually does anyone know about the like

2026
01:24:52,800 --> 01:24:54,400
kronsalt um

2027
01:24:54,400 --> 01:24:55,360
do you know about the ordering

2028
01:24:55,360 --> 01:24:57,280
guarantees of channels like is there a

2029
01:24:57,280 --> 01:25:02,470
liveness guarantee or are you

2030
01:25:02,480 --> 01:25:03,920
i feel like there isn't a liveness

2031
01:25:03,920 --> 01:25:06,159
guarantee so i guess if you have

2032
01:25:06,159 --> 01:25:08,480
uh it's kind of like logs right like if

2033
01:25:08,480 --> 01:25:09,760
you're always trying to acquire the

2034
01:25:09,760 --> 01:25:11,199
locks and another spread is like

2035
01:25:11,199 --> 01:25:12,800
also spinning and like trying to acquire

2036
01:25:12,800 --> 01:25:14,239
the lock there's no

2037
01:25:14,239 --> 01:25:17,199
guarantee that you will ever require it

2038
01:25:17,199 --> 01:25:18,800
which is why like

2039
01:25:18,800 --> 01:25:24,830
randomization might be necessary in that

2040
01:25:24,840 --> 01:25:26,000
case

2041
01:25:26,000 --> 01:25:27,760
also i realized i think lecture is

2042
01:25:27,760 --> 01:25:29,120
technically over

2043
01:25:29,120 --> 01:25:31,280
um i am holding the office hours right

2044
01:25:31,280 --> 01:25:33,360
now so if you have questions online too

2045
01:25:33,360 --> 01:25:35,040
or i want to continue asking questions

2046
01:25:35,040 --> 01:25:36,000
i'll be there

2047
01:25:36,000 --> 01:25:38,000
um and i think like maybe franz if you

2048
01:25:38,000 --> 01:25:39,280
want to stick around or

2049
01:25:39,280 --> 01:25:43,520
other others but i will move to

2050
01:25:43,520 --> 01:25:46,560
to office hours now

2051
01:25:46,560 --> 01:25:50,480
so thank you all so much for coming

2052
01:25:50,480 --> 01:25:55,990
thank you thank you

2053
01:25:56,000 --> 01:25:59,590
um

2054
01:25:59,600 --> 01:26:03,360
oh can i just ask a quick question

2055
01:26:03,360 --> 01:26:05,120
yeah all right franz you're the host now

2056
01:26:05,120 --> 01:26:06,960
so i'm going to just hop off to my

2057
01:26:06,960 --> 01:26:11,430
office

2058
01:26:11,440 --> 01:26:14,239
oh what's the theme like my color scheme

2059
01:26:14,239 --> 01:26:16,159
yeah

2060
01:26:16,159 --> 01:26:17,760
that's a good question i'm not actually

2061
01:26:17,760 --> 01:26:19,760
sure

2062
01:26:19,760 --> 01:26:28,950
let me check

