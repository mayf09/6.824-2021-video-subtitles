1
00:00:04,319 --> 00:00:05,359
okay here

2
00:00:05,359 --> 00:00:08,080
good afternoon good evening or good

3
00:00:08,080 --> 00:00:09,280
night or good morning

4
00:00:09,280 --> 00:00:12,639
uh whatever time zone you're in and

5
00:00:12,639 --> 00:00:15,679
watching this lecture um

6
00:00:15,679 --> 00:00:18,800
just double checking on sound uh people

7
00:00:18,800 --> 00:00:25,029
can hear me

8
00:00:25,039 --> 00:00:29,119
yes yes okay sure okay uh i'm going to

9
00:00:29,119 --> 00:00:31,039
talk about two things today i want to

10
00:00:31,039 --> 00:00:33,600
finish off our discussion a farm

11
00:00:33,600 --> 00:00:36,719
and then i'll talk about spark and just

12
00:00:36,719 --> 00:00:38,320
to remind everybody else

13
00:00:38,320 --> 00:00:41,520
or everybody where we were farm were

14
00:00:41,520 --> 00:00:44,239
talked about executing a transaction

15
00:00:44,239 --> 00:00:45,760
without any failures

16
00:00:45,760 --> 00:00:48,640
and we looked at one example of whether

17
00:00:48,640 --> 00:00:49,360
actually the

18
00:00:49,360 --> 00:00:51,840
transaction provided uh external

19
00:00:51,840 --> 00:00:53,039
consistency or

20
00:00:53,039 --> 00:00:56,239
strict serializability and

21
00:00:56,239 --> 00:00:58,160
so i want to talk about one more example

22
00:00:58,160 --> 00:00:59,920
uh to look about

23
00:00:59,920 --> 00:01:01,680
to talk about serializability and then

24
00:01:01,680 --> 00:01:03,600
uh let's talk a little bit about fault

25
00:01:03,600 --> 00:01:04,400
tolerance

26
00:01:04,400 --> 00:01:06,400
but before doing so uh it's probably

27
00:01:06,400 --> 00:01:08,000
helpful to remind uh

28
00:01:08,000 --> 00:01:09,600
my reminds ourselves exactly you know

29
00:01:09,600 --> 00:01:11,040
how a

30
00:01:11,040 --> 00:01:13,040
transaction works uh if there are no

31
00:01:13,040 --> 00:01:14,159
failures

32
00:01:14,159 --> 00:01:16,479
uh and so in farm an application goes

33
00:01:16,479 --> 00:01:18,320
through for two phases the execution

34
00:01:18,320 --> 00:01:19,040
phase

35
00:01:19,040 --> 00:01:21,680
uh where it fetches objects from uh

36
00:01:21,680 --> 00:01:22,560
different

37
00:01:22,560 --> 00:01:25,520
shards and then the commit phase and so

38
00:01:25,520 --> 00:01:26,880
we look back at this uh

39
00:01:26,880 --> 00:01:29,119
picture here you know where there is in

40
00:01:29,119 --> 00:01:30,560
the execution phase three objects are

41
00:01:30,560 --> 00:01:32,159
being

42
00:01:32,159 --> 00:01:36,390
uh three objects are being read

43
00:01:36,400 --> 00:01:38,720
you know one from each uh different

44
00:01:38,720 --> 00:01:41,360
chart uh you know we have shard one gr2

45
00:01:41,360 --> 00:01:42,320
and chat three

46
00:01:42,320 --> 00:01:45,040
and every chart has one backup so this

47
00:01:45,040 --> 00:01:47,840
system can tolerate one failure

48
00:01:47,840 --> 00:01:50,799
uh so the objects are read the the two

49
00:01:50,799 --> 00:01:52,240
objects are being modified

50
00:01:52,240 --> 00:01:55,600
uh as we see in the second and then

51
00:01:55,600 --> 00:01:58,079
uh once you know the the free object red

52
00:01:58,079 --> 00:01:59,360
and two are modified

53
00:01:59,360 --> 00:02:01,439
the application might decide to commit

54
00:02:01,439 --> 00:02:03,119
and then so the whole commit phase goes

55
00:02:03,119 --> 00:02:03,759
into action

56
00:02:03,759 --> 00:02:06,560
so this is this whole story from uh

57
00:02:06,560 --> 00:02:07,600
steps one through

58
00:02:07,600 --> 00:02:10,640
five and in step one

59
00:02:10,640 --> 00:02:12,959
uh the transaction takes out locks on

60
00:02:12,959 --> 00:02:13,760
the objects that

61
00:02:13,760 --> 00:02:16,480
have been written written so we see here

62
00:02:16,480 --> 00:02:17,840
there have been two objects that have

63
00:02:17,840 --> 00:02:18,640
been

64
00:02:18,640 --> 00:02:22,160
uh written to by the transaction and so

65
00:02:22,160 --> 00:02:23,920
we're propagating what's called locked

66
00:02:23,920 --> 00:02:24,720
records

67
00:02:24,720 --> 00:02:28,080
you know to uh every primary

68
00:02:28,080 --> 00:02:31,200
so every primary is going to have a lock

69
00:02:31,200 --> 00:02:32,319
record for this

70
00:02:32,319 --> 00:02:35,840
transaction and for the objects involved

71
00:02:35,840 --> 00:02:36,239
in

72
00:02:36,239 --> 00:02:38,879
that transaction so and the lock records

73
00:02:38,879 --> 00:02:40,080
you know contains

74
00:02:40,080 --> 00:02:42,879
an object id which identifies the object

75
00:02:42,879 --> 00:02:43,840
uniquely

76
00:02:43,840 --> 00:02:47,040
a version number so at the time that

77
00:02:47,040 --> 00:02:50,160
uh the transaction reads an object

78
00:02:50,160 --> 00:02:52,319
it gets back a version number in fact it

79
00:02:52,319 --> 00:02:53,360
gets back this

80
00:02:53,360 --> 00:02:56,879
64-bit number which in the top is a log

81
00:02:56,879 --> 00:03:01,350
bit and the rest is the version number

82
00:03:01,360 --> 00:03:08,550
and then a new value

83
00:03:08,560 --> 00:03:11,680
uh so you know primary one and primary

84
00:03:11,680 --> 00:03:12,000
two

85
00:03:12,000 --> 00:03:13,519
is going to have frame one is gonna have

86
00:03:13,519 --> 00:03:15,360
a lock record for object one primary two

87
00:03:15,360 --> 00:03:16,560
is gonna have to lock uh

88
00:03:16,560 --> 00:03:19,760
object for primary for object two then

89
00:03:19,760 --> 00:03:21,680
there's a separate phase uh for the

90
00:03:21,680 --> 00:03:23,040
validation of

91
00:03:23,040 --> 00:03:25,680
the read-only operations or operations

92
00:03:25,680 --> 00:03:26,159
or

93
00:03:26,159 --> 00:03:27,760
objects that are only be read but not

94
00:03:27,760 --> 00:03:29,360
modified

95
00:03:29,360 --> 00:03:31,120
and as we can see in those in this

96
00:03:31,120 --> 00:03:33,040
validation step

97
00:03:33,040 --> 00:03:35,040
the dotted lines represent one-sided

98
00:03:35,040 --> 00:03:40,630
rdmas

99
00:03:40,640 --> 00:03:43,120
and as we talked about on tuesday you

100
00:03:43,120 --> 00:03:44,959
know those basically involved no server

101
00:03:44,959 --> 00:03:46,640
involvement you know the

102
00:03:46,640 --> 00:03:49,519
the sender can just read a an object out

103
00:03:49,519 --> 00:03:50,560
of the memory of the

104
00:03:50,560 --> 00:03:52,879
server with actually without actually

105
00:03:52,879 --> 00:03:54,080
having to interrupt you know the

106
00:03:54,080 --> 00:03:55,439
computation that's actually running on

107
00:03:55,439 --> 00:03:56,879
the server

108
00:03:56,879 --> 00:03:59,519
so they had to be very fast unlike you

109
00:03:59,519 --> 00:04:01,360
know these operations that we saw here

110
00:04:01,360 --> 00:04:07,589
which are actually right rdmas

111
00:04:07,599 --> 00:04:09,040
they're cool too in the sense that you

112
00:04:09,040 --> 00:04:10,799
know you get the right you know to

113
00:04:10,799 --> 00:04:13,120
the appends you know to this log record

114
00:04:13,120 --> 00:04:15,040
without actually interrupting the server

115
00:04:15,040 --> 00:04:16,560
but the server actually has to process

116
00:04:16,560 --> 00:04:18,320
these log records and

117
00:04:18,320 --> 00:04:20,479
um then the server in this case once it

118
00:04:20,479 --> 00:04:21,680
actually processes one of these lock

119
00:04:21,680 --> 00:04:22,560
records

120
00:04:22,560 --> 00:04:24,080
uh you know it tries to take out the

121
00:04:24,080 --> 00:04:25,680
lock if it succeeds trying out until

122
00:04:25,680 --> 00:04:26,880
they take the lock

123
00:04:26,880 --> 00:04:28,479
the version number hasn't changed or the

124
00:04:28,479 --> 00:04:30,960
lock bit or no other transaction is

125
00:04:30,960 --> 00:04:32,080
taking the lock

126
00:04:32,080 --> 00:04:34,240
then it will reply back you know using

127
00:04:34,240 --> 00:04:35,440
another one

128
00:04:35,440 --> 00:04:38,880
uh right rdma saying okay

129
00:04:38,880 --> 00:04:40,880
and so you know we see that on the

130
00:04:40,880 --> 00:04:42,880
acquiring the lock requires action on

131
00:04:42,880 --> 00:04:44,320
the server

132
00:04:44,320 --> 00:04:46,720
but the one-sided rdma for reads

133
00:04:46,720 --> 00:04:48,639
validation doesn't require any action on

134
00:04:48,639 --> 00:04:51,120
the server

135
00:04:51,120 --> 00:04:54,639
then there's the if

136
00:04:54,639 --> 00:04:57,199
everything turns out to be okay so the

137
00:04:57,199 --> 00:04:59,120
transaction is basically able to

138
00:04:59,120 --> 00:05:02,000
obtain all its right locks and validate

139
00:05:02,000 --> 00:05:02,720
the reit

140
00:05:02,720 --> 00:05:06,000
operations it actually makes a decision

141
00:05:06,000 --> 00:05:06,800
to commit

142
00:05:06,800 --> 00:05:10,720
and to commit it uh first communicates

143
00:05:10,720 --> 00:05:14,469
to every backup

144
00:05:14,479 --> 00:05:18,160
the object the change

145
00:05:18,160 --> 00:05:25,909
so right to commit backup record

146
00:05:25,919 --> 00:05:28,479
and it appends that to every uh to the

147
00:05:28,479 --> 00:05:30,320
backups of the

148
00:05:30,320 --> 00:05:31,919
objects that have been modified and

149
00:05:31,919 --> 00:05:33,840
again you know it's basically a copy of

150
00:05:33,840 --> 00:05:34,320
the

151
00:05:34,320 --> 00:05:36,960
bach record you know oid goes in there

152
00:05:36,960 --> 00:05:38,000
the version number goes

153
00:05:38,000 --> 00:05:42,310
in there and the new value

154
00:05:42,320 --> 00:05:44,720
once you know all the backups you know

155
00:05:44,720 --> 00:05:45,759
have

156
00:05:45,759 --> 00:05:48,240
uh we have reported that they actually

157
00:05:48,240 --> 00:05:49,360
have a copy of the

158
00:05:49,360 --> 00:05:51,199
object now we're basically in pretty

159
00:05:51,199 --> 00:05:53,039
good shape right because the primary has

160
00:05:53,039 --> 00:05:53,680
a copy

161
00:05:53,680 --> 00:05:55,600
the backup has to copy except the

162
00:05:55,600 --> 00:05:56,800
primary doesn't really know if the

163
00:05:56,800 --> 00:05:57,759
transaction has been

164
00:05:57,759 --> 00:06:00,639
uh committed yet or not and so a final

165
00:06:00,639 --> 00:06:02,880
step is that actually the

166
00:06:02,880 --> 00:06:05,759
uh the coordinator or the traction

167
00:06:05,759 --> 00:06:07,360
coordinator write out a

168
00:06:07,360 --> 00:06:18,469
commit record and commit primary record

169
00:06:18,479 --> 00:06:20,800
informing the primaries that actually

170
00:06:20,800 --> 00:06:23,360
the transaction actually has committed

171
00:06:23,360 --> 00:06:24,960
and as soon as it gets an

172
00:06:24,960 --> 00:06:26,960
acknowledgement from one of the nicks

173
00:06:26,960 --> 00:06:29,520
indicated by the dotted lines uh it

174
00:06:29,520 --> 00:06:30,639
actually reports back

175
00:06:30,639 --> 00:06:32,880
to the application saying that the

176
00:06:32,880 --> 00:06:37,830
transaction committed

177
00:06:37,840 --> 00:06:40,160
so what we want to do now is look at two

178
00:06:40,160 --> 00:06:41,120
cases

179
00:06:41,120 --> 00:06:42,560
one we wanted to talk a little bit more

180
00:06:42,560 --> 00:06:44,800
about the serializability just to see if

181
00:06:44,800 --> 00:06:46,080
the concurrency control worked out and

182
00:06:46,080 --> 00:06:47,360
then we want to talk a little bit about

183
00:06:47,360 --> 00:06:48,560
fault tunnels and see if the full

184
00:06:48,560 --> 00:06:51,599
tolerance story works out

185
00:06:51,599 --> 00:06:54,400
so let me first start uh with uh

186
00:06:54,400 --> 00:06:56,319
serializability

187
00:06:56,319 --> 00:06:58,000
or excel maybe before doing that let me

188
00:06:58,000 --> 00:06:59,840
just ask if

189
00:06:59,840 --> 00:07:02,240
there's any questions so far and whether

190
00:07:02,240 --> 00:07:04,240
everybody sort of has swapped

191
00:07:04,240 --> 00:07:07,520
successfully swapped far back into

192
00:07:07,520 --> 00:07:12,150
into your memories

193
00:07:12,160 --> 00:07:15,520
what does the rectangle mean in this

194
00:07:15,520 --> 00:07:18,800
picture so what's the rectangle

195
00:07:18,800 --> 00:07:20,639
what does it signify along the oh is it

196
00:07:20,639 --> 00:07:21,919
an object

197
00:07:21,919 --> 00:07:25,990
oh it's an object okay

198
00:07:26,000 --> 00:07:31,199
okay any other questions

199
00:07:31,199 --> 00:07:34,639
okay good let's uh uh

200
00:07:34,639 --> 00:07:37,840
so let's uh look at the correctness

201
00:07:37,840 --> 00:07:40,720
from the concurrency perspective so the

202
00:07:40,720 --> 00:07:42,000
correctness correct is

203
00:07:42,000 --> 00:07:49,029
strict serializability

204
00:07:49,039 --> 00:07:51,599
and on tuesday we looked at a

205
00:07:51,599 --> 00:07:53,680
transaction that

206
00:07:53,680 --> 00:07:56,400
didn't really involve a right validation

207
00:07:56,400 --> 00:07:58,400
because there was no object that was

208
00:07:58,400 --> 00:08:01,199
uh read but not written and so i want to

209
00:08:01,199 --> 00:08:02,560
look at another transaction this time

210
00:08:02,560 --> 00:08:03,919
around where actually the validation

211
00:08:03,919 --> 00:08:04,400
phase

212
00:08:04,400 --> 00:08:06,319
plays a role and so i'm going to look at

213
00:08:06,319 --> 00:08:08,319
two transactions

214
00:08:08,319 --> 00:08:10,840
and this is sort of this example is a

215
00:08:10,840 --> 00:08:13,440
classic uh example to test

216
00:08:13,440 --> 00:08:15,280
uh whether a protocol provides

217
00:08:15,280 --> 00:08:16,879
serializability or not of course it's

218
00:08:16,879 --> 00:08:18,000
not going to be approved

219
00:08:18,000 --> 00:08:19,919
but it's sort of one of the key examples

220
00:08:19,919 --> 00:08:22,319
that generally is very helpful to see

221
00:08:22,319 --> 00:08:23,759
to understand whether how the protocol

222
00:08:23,759 --> 00:08:26,080
works so the protocol uh the

223
00:08:26,080 --> 00:08:27,919
transactions are if x is zero

224
00:08:27,919 --> 00:08:31,039
then we're gonna set y to one so if

225
00:08:31,039 --> 00:08:31,680
object x

226
00:08:31,680 --> 00:08:33,919
is zero we'll set object y it's one the

227
00:08:33,919 --> 00:08:35,120
transaction two

228
00:08:35,120 --> 00:08:38,159
is sort of the opposite it looks if y is

229
00:08:38,159 --> 00:08:39,680
zero

230
00:08:39,680 --> 00:08:43,909
and if y is zero we'll set x to one

231
00:08:43,919 --> 00:08:45,760
and the reason that these uh sort of

232
00:08:45,760 --> 00:08:48,160
this is a good test for serializability

233
00:08:48,160 --> 00:08:49,920
uh is that you know either transaction

234
00:08:49,920 --> 00:08:51,920
one should go after two two correct or

235
00:08:51,920 --> 00:08:54,320
two should go after t1

236
00:08:54,320 --> 00:08:56,399
and depending on which order you run you

237
00:08:56,399 --> 00:08:57,760
know either y is one

238
00:08:57,760 --> 00:09:01,360
or x is one but you never should have

239
00:09:01,360 --> 00:09:03,279
you never should have the outcome since

240
00:09:03,279 --> 00:09:05,040
x is one

241
00:09:05,040 --> 00:09:08,720
oops x is one

242
00:09:08,720 --> 00:09:12,560
and y is one and that should not be

243
00:09:12,560 --> 00:09:14,320
allowed because that would be definitely

244
00:09:14,320 --> 00:09:16,160
violate serializability

245
00:09:16,160 --> 00:09:22,399
does that make sense

246
00:09:22,399 --> 00:09:24,000
okay so what we want to do is you know

247
00:09:24,000 --> 00:09:26,480
test whether uh

248
00:09:26,480 --> 00:09:29,839
firearm actually is successful in uh

249
00:09:29,839 --> 00:09:31,519
where we want to understand refinements

250
00:09:31,519 --> 00:09:34,080
indeed uh it is not possible that

251
00:09:34,080 --> 00:09:37,120
x is one and y is one uh get produced

252
00:09:37,120 --> 00:09:39,839
so let's look at the timeline let's say

253
00:09:39,839 --> 00:09:41,279
here we have t1

254
00:09:41,279 --> 00:09:46,320
here we have t2 uh here's the timeline

255
00:09:46,320 --> 00:09:48,640
so they both you know in their sort of

256
00:09:48,640 --> 00:09:50,080
the preparation or the execution

257
00:09:50,080 --> 00:09:52,560
phase they both read these objects so

258
00:09:52,560 --> 00:09:53,519
let's say they run

259
00:09:53,519 --> 00:09:55,920
truly concurrently we do a read of x and

260
00:09:55,920 --> 00:09:57,200
at version number zero

261
00:09:57,200 --> 00:09:59,920
we do a read of y version number zero

262
00:09:59,920 --> 00:10:04,240
same here

263
00:10:04,240 --> 00:10:07,279
and of course you know t1 will update y

264
00:10:07,279 --> 00:10:10,720
two will update x and they base at some

265
00:10:10,720 --> 00:10:11,920
point you know both

266
00:10:11,920 --> 00:10:19,279
start the commit phase

267
00:10:19,279 --> 00:10:22,480
and you know let's uh uh

268
00:10:22,480 --> 00:10:24,720
so let's say the t1 starts first and

269
00:10:24,720 --> 00:10:26,240
basically it grabs the

270
00:10:26,240 --> 00:10:29,600
you know it needs to lock on y

271
00:10:29,600 --> 00:10:32,640
uh since it's going to be writing y so

272
00:10:32,640 --> 00:10:33,200
let's say

273
00:10:33,200 --> 00:10:36,320
x successfully graph the log and y and

274
00:10:36,320 --> 00:10:37,680
so that actually will set

275
00:10:37,680 --> 00:10:39,839
you know the log bit okay in the version

276
00:10:39,839 --> 00:10:41,920
number of the

277
00:10:41,920 --> 00:10:46,000
y object and then you know let's say you

278
00:10:46,000 --> 00:10:47,040
know actually

279
00:10:47,040 --> 00:10:49,120
since it's going to read it has has red

280
00:10:49,120 --> 00:10:50,320
x but it's not v

281
00:10:50,320 --> 00:10:52,880
uh uh it's has a red x but it's not

282
00:10:52,880 --> 00:10:53,680
modifying x

283
00:10:53,680 --> 00:10:56,720
and it's going to be validation of x

284
00:10:56,720 --> 00:10:59,040
uh you know x was read at version number

285
00:10:59,040 --> 00:11:00,079
zero

286
00:11:00,079 --> 00:11:03,519
uh the you know uh

287
00:11:03,519 --> 00:11:05,120
at the validation files you know nothing

288
00:11:05,120 --> 00:11:07,200
actually has changed yes with x so the

289
00:11:07,200 --> 00:11:09,680
version over still zero there yeah we

290
00:11:09,680 --> 00:11:11,440
run executed in this order

291
00:11:11,440 --> 00:11:14,640
and so things are sort of are fine

292
00:11:14,640 --> 00:11:16,720
and you know at some point you know this

293
00:11:16,720 --> 00:11:17,839
transaction

294
00:11:17,839 --> 00:11:22,240
might commit so let's look at t2

295
00:11:22,240 --> 00:11:25,920
and let's say you know t2

296
00:11:25,920 --> 00:11:28,000
runs after the validation of x so it

297
00:11:28,000 --> 00:11:31,269
grabs the log

298
00:11:31,279 --> 00:11:34,959
and um and then you know the

299
00:11:34,959 --> 00:11:37,040
it is has red y so it needs to do a

300
00:11:37,040 --> 00:11:38,800
validation of y

301
00:11:38,800 --> 00:11:41,040
and so it's going to do a validation of

302
00:11:41,040 --> 00:11:42,000
why

303
00:11:42,000 --> 00:11:45,920
and the question is is that validation

304
00:11:45,920 --> 00:11:46,240
could

305
00:11:46,240 --> 00:11:51,829
succeed or not

306
00:11:51,839 --> 00:11:54,160
no because the previous the other

307
00:11:54,160 --> 00:11:56,000
operation has a lock and modified the

308
00:11:56,000 --> 00:11:57,279
value so it's not the same

309
00:11:57,279 --> 00:12:00,240
that was originally read yeah so the the

310
00:12:00,240 --> 00:12:01,360
version numbers might mean they're still

311
00:12:01,360 --> 00:12:02,320
the same but the

312
00:12:02,320 --> 00:12:05,279
y you know t1 excel has set the lock bit

313
00:12:05,279 --> 00:12:05,600
right

314
00:12:05,600 --> 00:12:07,920
or the object of y and so at this point

315
00:12:07,920 --> 00:12:10,800
this validation will fail

316
00:12:10,800 --> 00:12:14,160
because it's not the same or the log bit

317
00:12:14,160 --> 00:12:14,959
has been set

318
00:12:14,959 --> 00:12:16,800
and so to t2 transaction the t2

319
00:12:16,800 --> 00:12:19,839
transaction will abort

320
00:12:19,839 --> 00:12:23,360
okay does that make sense so we see at

321
00:12:23,360 --> 00:12:24,800
least in this particular example

322
00:12:24,800 --> 00:12:27,839
that you know the it is the case that t1

323
00:12:27,839 --> 00:12:29,360
and t2 both don't commit

324
00:12:29,360 --> 00:12:31,440
which would result in this incorrect

325
00:12:31,440 --> 00:12:34,790
outcome

326
00:12:34,800 --> 00:12:39,440
any questions about this

327
00:12:39,440 --> 00:12:42,639
i i had a question yeah

328
00:12:42,639 --> 00:12:46,720
yeah so um like for for the transactions

329
00:12:46,720 --> 00:12:49,600
so the these are like these have to be

330
00:12:49,600 --> 00:12:51,519
like update transactions like not like

331
00:12:51,519 --> 00:12:52,800
re write

332
00:12:52,800 --> 00:12:55,519
correct because we always read they

333
00:12:55,519 --> 00:12:55,920
could

334
00:12:55,920 --> 00:12:59,760
do it yeah go ahead i just wonder like

335
00:12:59,760 --> 00:13:00,160
if

336
00:13:00,160 --> 00:13:02,480
they were like read operations you could

337
00:13:02,480 --> 00:13:03,440
do that like

338
00:13:03,440 --> 00:13:06,639
log free right and as long as the yeah

339
00:13:06,639 --> 00:13:08,160
so this is actually good let's go back

340
00:13:08,160 --> 00:13:09,839
to this picture here right then let's

341
00:13:09,839 --> 00:13:11,040
look at the

342
00:13:11,040 --> 00:13:12,639
let's say there were no rights involved

343
00:13:12,639 --> 00:13:14,399
in this transaction at all right like so

344
00:13:14,399 --> 00:13:15,760
for example the two objects that are

345
00:13:15,760 --> 00:13:17,760
being read correct or stored at

346
00:13:17,760 --> 00:13:20,959
p1 and p2 so let's assume that these

347
00:13:20,959 --> 00:13:22,320
guys are actually not involved

348
00:13:22,320 --> 00:13:24,480
so those objects were not written so the

349
00:13:24,480 --> 00:13:26,399
only operation that's happening is a

350
00:13:26,399 --> 00:13:27,920
read of that object

351
00:13:27,920 --> 00:13:30,959
and if you see in uh and so the protocol

352
00:13:30,959 --> 00:13:32,480
is carefully designed

353
00:13:32,480 --> 00:13:35,200
so that if you only do reach you only do

354
00:13:35,200 --> 00:13:37,920
one-sided rdmas correct

355
00:13:37,920 --> 00:13:40,000
uh here in the execution phase and then

356
00:13:40,000 --> 00:13:43,680
one rds ada to do the validation

357
00:13:43,680 --> 00:13:46,720
and no locks are taken out no rights are

358
00:13:46,720 --> 00:13:47,360
being done

359
00:13:47,360 --> 00:13:49,279
no records are being appended that's the

360
00:13:49,279 --> 00:13:51,760
only thing that happens

361
00:13:51,760 --> 00:13:54,560
and so this is one of the cool features

362
00:13:54,560 --> 00:13:55,600
about farm

363
00:13:55,600 --> 00:13:58,000
is that these transactions that only do

364
00:13:58,000 --> 00:13:58,959
reach

365
00:13:58,959 --> 00:14:02,000
uh can be executed without

366
00:14:02,000 --> 00:14:06,240
with only one-sided rdmas and

367
00:14:06,240 --> 00:14:09,920
only with no rights to any

368
00:14:09,920 --> 00:14:12,160
logs or grabbing any locks and so that's

369
00:14:12,160 --> 00:14:13,920
why one reason that they get extremely

370
00:14:13,920 --> 00:14:16,079
high performance

371
00:14:16,079 --> 00:14:17,680
and this is also the reason why for

372
00:14:17,680 --> 00:14:19,120
example the

373
00:14:19,120 --> 00:14:21,440
lock fade the lock step and the

374
00:14:21,440 --> 00:14:23,440
validation steps are two separate things

375
00:14:23,440 --> 00:14:26,480
because uh in for read only transactions

376
00:14:26,480 --> 00:14:31,040
there's no lock step

377
00:14:31,040 --> 00:14:35,120
okay actually a question on that

378
00:14:35,120 --> 00:14:38,560
um for read-only transactions why do we

379
00:14:38,560 --> 00:14:39,760
need the second

380
00:14:39,760 --> 00:14:42,240
val why do we need the validation phase

381
00:14:42,240 --> 00:14:43,920
because aren't you like reading a value

382
00:14:43,920 --> 00:14:45,440
and then you're immediately validating

383
00:14:45,440 --> 00:14:47,040
right after it like the version

384
00:14:47,040 --> 00:14:49,519
it seems like there could be another

385
00:14:49,519 --> 00:14:50,240
transaction that

386
00:14:50,240 --> 00:14:53,120
has been has modified the object yet so

387
00:14:53,120 --> 00:14:54,800
if a transaction ran

388
00:14:54,800 --> 00:14:59,199
or started and committed before uh okay

389
00:14:59,199 --> 00:15:00,800
a concurrent transaction actually writes

390
00:15:00,800 --> 00:15:04,550
might modify the object

391
00:15:04,560 --> 00:15:08,560
and that would be bad right so the the

392
00:15:08,560 --> 00:15:11,680
the the the transaction that uh

393
00:15:11,680 --> 00:15:13,920
writes then the transaction that

394
00:15:13,920 --> 00:15:15,360
actually follows it you know should

395
00:15:15,360 --> 00:15:19,110
you know see you observe that last right

396
00:15:19,120 --> 00:15:20,880
but if they occur at the same time then

397
00:15:20,880 --> 00:15:22,480
we can reorder them either way

398
00:15:22,480 --> 00:15:24,160
yeah as we occur exactly at the same

399
00:15:24,160 --> 00:15:26,160
time we can over

400
00:15:26,160 --> 00:15:32,230
order rewarded them yeah

401
00:15:32,240 --> 00:15:34,560
so it still seems to me like this the

402
00:15:34,560 --> 00:15:35,600
second validation

403
00:15:35,600 --> 00:15:37,360
because the first time you read it the

404
00:15:37,360 --> 00:15:39,199
second time you just immediately ping

405
00:15:39,199 --> 00:15:40,639
and see if the version is the same as

406
00:15:40,639 --> 00:15:41,120
scene

407
00:15:41,120 --> 00:15:42,720
it still seems to me like the second

408
00:15:42,720 --> 00:15:44,560
validation is like

409
00:15:44,560 --> 00:15:47,600
almost unnecessary i i i i you might

410
00:15:47,600 --> 00:15:48,880
you might be right i haven't thought

411
00:15:48,880 --> 00:15:50,480
very hard about this that they're if

412
00:15:50,480 --> 00:15:51,519
they're

413
00:15:51,519 --> 00:15:54,240
if there's if there are transactions

414
00:15:54,240 --> 00:15:55,680
there are only read-only transactions

415
00:15:55,680 --> 00:15:56,880
you know then the validation is

416
00:15:56,880 --> 00:15:58,240
undoubtedly not necessary

417
00:15:58,240 --> 00:16:00,000
i haven't very carefully thought about

418
00:16:00,000 --> 00:16:01,839
like when there's a mix of transactions

419
00:16:01,839 --> 00:16:03,279
uh where there is a case where you need

420
00:16:03,279 --> 00:16:05,040
the validation yeah

421
00:16:05,040 --> 00:16:06,959
what would that be the case where like

422
00:16:06,959 --> 00:16:09,920
you have like if you read a value

423
00:16:09,920 --> 00:16:11,839
um like you expect to read like two

424
00:16:11,839 --> 00:16:14,160
values atomically you read a value

425
00:16:14,160 --> 00:16:16,399
after you read a value like some

426
00:16:16,399 --> 00:16:19,839
transaction modifies the other value

427
00:16:19,839 --> 00:16:25,189
um yeah

428
00:16:25,199 --> 00:16:29,120
um yeah i shouldn't i'm not i'm not

429
00:16:29,120 --> 00:16:30,000
quite sure

430
00:16:30,000 --> 00:16:31,920
actually in that case if that's a

431
00:16:31,920 --> 00:16:33,040
problem

432
00:16:33,040 --> 00:16:34,639
like for example in this case you know

433
00:16:34,639 --> 00:16:36,320
this t1 and t2 case it's

434
00:16:36,320 --> 00:16:38,240
really crucial that y actually does the

435
00:16:38,240 --> 00:16:41,120
validation correct

436
00:16:41,120 --> 00:16:43,199
even though actually that transaction

437
00:16:43,199 --> 00:16:45,759
you know t1

438
00:16:45,759 --> 00:16:49,590
only reads y

439
00:16:49,600 --> 00:16:53,440
correct what if

440
00:16:53,440 --> 00:16:56,959
uh transaction two was just x equals one

441
00:16:56,959 --> 00:16:59,120
instead of like without the f statement

442
00:16:59,120 --> 00:17:02,870
uh blind right

443
00:17:02,880 --> 00:17:04,959
if it's just a blind write yeah it's

444
00:17:04,959 --> 00:17:07,439
just x equals one and then it executes

445
00:17:07,439 --> 00:17:11,039
after the validation of of t1

446
00:17:11,039 --> 00:17:23,949
yeah that's fine correct

447
00:17:23,959 --> 00:17:26,720
is just like uh right like you know

448
00:17:26,720 --> 00:17:27,120
write

449
00:17:27,120 --> 00:17:30,640
x equals one within the validation step

450
00:17:30,640 --> 00:17:32,960
like after and and it executes after the

451
00:17:32,960 --> 00:17:35,039
validation step of t1

452
00:17:35,039 --> 00:17:38,400
wouldn't then t1 think that x

453
00:17:38,400 --> 00:17:41,919
equals zero but then x becomes

454
00:17:41,919 --> 00:17:46,799
one before the commit

455
00:17:46,799 --> 00:17:49,679
uh okay so okay let me maybe we can we

456
00:17:49,679 --> 00:17:50,799
can hold this up because

457
00:17:50,799 --> 00:17:52,640
i gotta you know redraw you know the

458
00:17:52,640 --> 00:17:53,840
whole picture and figure out exactly

459
00:17:53,840 --> 00:17:56,160
what the scenarios you're talking about

460
00:17:56,160 --> 00:17:58,160
okay so maybe we can go back to this at

461
00:17:58,160 --> 00:18:02,310
the end

462
00:18:02,320 --> 00:18:03,919
sorry i had a question what is the use

463
00:18:03,919 --> 00:18:07,360
case for the only transaction

464
00:18:07,360 --> 00:18:10,720
uh if you

465
00:18:10,720 --> 00:18:12,960
if you think backup spanner and this

466
00:18:12,960 --> 00:18:14,240
paper like uh

467
00:18:14,240 --> 00:18:15,919
there's often the case in these

468
00:18:15,919 --> 00:18:17,360
workloads uh

469
00:18:17,360 --> 00:18:20,240
the tpcc workload and the tatp workload

470
00:18:20,240 --> 00:18:20,640
where

471
00:18:20,640 --> 00:18:22,640
you know there's a transaction that only

472
00:18:22,640 --> 00:18:23,919
does reach for example

473
00:18:23,919 --> 00:18:25,520
i've computed the balances of a set of

474
00:18:25,520 --> 00:18:27,440
accounts you know nothing is being

475
00:18:27,440 --> 00:18:28,000
written

476
00:18:28,000 --> 00:18:29,760
uh but you know a lot of things a lot of

477
00:18:29,760 --> 00:18:33,510
accounts are being read

478
00:18:33,520 --> 00:18:38,150
thank you

479
00:18:38,160 --> 00:18:39,520
okay so we see here that there's

480
00:18:39,520 --> 00:18:41,200
actually the validation phase is crucial

481
00:18:41,200 --> 00:18:43,039
correct for this t1 and 2tk

482
00:18:43,039 --> 00:18:46,559
uh transaction uh in uh and furthermore

483
00:18:46,559 --> 00:18:47,760
that actually things that work out

484
00:18:47,760 --> 00:18:48,799
correctly you know we get strict

485
00:18:48,799 --> 00:18:50,320
serializability of course this is not a

486
00:18:50,320 --> 00:18:51,760
proof but it gives you

487
00:18:51,760 --> 00:18:54,240
uh you know this example that sort of uh

488
00:18:54,240 --> 00:18:56,000
try to get at the tricky case

489
00:18:56,000 --> 00:18:57,840
uh you know actually the farm seems to

490
00:18:57,840 --> 00:19:00,799
work out correctly

491
00:19:00,799 --> 00:19:03,760
okay so so that's on the concurrency

492
00:19:03,760 --> 00:19:04,640
control

493
00:19:04,640 --> 00:19:07,440
uh then the second part we want to talk

494
00:19:07,440 --> 00:19:08,240
a little bit about

495
00:19:08,240 --> 00:19:11,440
is fault tolerance

496
00:19:11,440 --> 00:19:14,240
and she's going to want to get the i'm

497
00:19:14,240 --> 00:19:15,520
not going to go with great amount of

498
00:19:15,520 --> 00:19:16,400
depth here

499
00:19:16,400 --> 00:19:19,840
just want to talk about the you know key

500
00:19:19,840 --> 00:19:20,799
challenge

501
00:19:20,799 --> 00:19:23,520
and see you know and build some

502
00:19:23,520 --> 00:19:24,240
intuition

503
00:19:24,240 --> 00:19:27,760
why we might actually be hopeful that uh

504
00:19:27,760 --> 00:19:30,400
farm actually uh uh addresses that key

505
00:19:30,400 --> 00:19:31,440
challenge

506
00:19:31,440 --> 00:19:35,120
and so the key challenge uh

507
00:19:35,120 --> 00:19:37,360
maybe actually the key challenge is that

508
00:19:37,360 --> 00:19:39,039
the trajectory

509
00:19:39,039 --> 00:19:43,590
crashes

510
00:19:43,600 --> 00:19:53,840
after telling the application

511
00:19:53,840 --> 00:19:55,679
and then it has to be the case right

512
00:19:55,679 --> 00:19:57,440
that the transaction

513
00:19:57,440 --> 00:20:01,360
persists because we have informed the

514
00:20:01,360 --> 00:20:02,640
application that the detection is

515
00:20:02,640 --> 00:20:04,000
committed so we can't actually

516
00:20:04,000 --> 00:20:06,559
lose you know any rights that the

517
00:20:06,559 --> 00:20:07,600
transaction has

518
00:20:07,600 --> 00:20:10,400
done and so we can look at this picture

519
00:20:10,400 --> 00:20:12,159
again

520
00:20:12,159 --> 00:20:14,240
and see if we're going to be hopeful

521
00:20:14,240 --> 00:20:22,149
that this is the case

522
00:20:22,159 --> 00:20:24,480
so you know there's a couple things to

523
00:20:24,480 --> 00:20:25,280
observe

524
00:20:25,280 --> 00:20:29,120
uh after you know the lock phase

525
00:20:29,120 --> 00:20:33,110
uh it is the case that

526
00:20:33,120 --> 00:20:34,880
after the lock phase it is the case that

527
00:20:34,880 --> 00:20:37,440
the two primaries p1

528
00:20:37,440 --> 00:20:42,710
and p2 have a lock record

529
00:20:42,720 --> 00:20:44,720
which describes the update we don't

530
00:20:44,720 --> 00:20:46,000
really know the transaction

531
00:20:46,000 --> 00:20:48,240
you know that record doesn't say whether

532
00:20:48,240 --> 00:20:49,840
the record actually

533
00:20:49,840 --> 00:20:52,480
uh whether the transaction is committed

534
00:20:52,480 --> 00:20:53,280
but we have

535
00:20:53,280 --> 00:20:56,480
information about the transaction then

536
00:20:56,480 --> 00:20:59,039
after this step to commit backup step

537
00:20:59,039 --> 00:21:00,000
now we know that

538
00:21:00,000 --> 00:21:04,480
you know backup p1 b1 and b2

539
00:21:04,480 --> 00:21:12,630
have the commit record

540
00:21:12,640 --> 00:21:16,240
and then before you know the transaction

541
00:21:16,240 --> 00:21:18,320
you know the transaction coordinator uh

542
00:21:18,320 --> 00:21:20,559
reports to the application that

543
00:21:20,559 --> 00:21:22,880
uh it has been successful we know that

544
00:21:22,880 --> 00:21:24,640
one of the primaries

545
00:21:24,640 --> 00:21:28,840
or let's say p1 also has the commit

546
00:21:28,840 --> 00:21:34,070
record

547
00:21:34,080 --> 00:21:35,840
so you know let's assume there's a crash

548
00:21:35,840 --> 00:21:37,120
you know like right here

549
00:21:37,120 --> 00:21:38,720
so at that particular just after that

550
00:21:38,720 --> 00:21:40,320
commit point you know

551
00:21:40,320 --> 00:21:42,640
and the system crashes and what we want

552
00:21:42,640 --> 00:21:43,760
to convince ourselves of

553
00:21:43,760 --> 00:21:47,200
is that uh if there's one failure uh

554
00:21:47,200 --> 00:21:48,960
for for each chart you know things

555
00:21:48,960 --> 00:21:50,960
actually work out correct

556
00:21:50,960 --> 00:21:53,280
and so the worsen case basically erect

557
00:21:53,280 --> 00:21:54,080
is

558
00:21:54,080 --> 00:21:58,400
that you know b2 fails

559
00:21:58,400 --> 00:22:01,760
so here where is v2 uh usb2

560
00:22:01,760 --> 00:22:05,440
d2 fails um and so we lose you know that

561
00:22:05,440 --> 00:22:08,000
commit record that is actually there

562
00:22:08,000 --> 00:22:10,400
the primary might actually have not a

563
00:22:10,400 --> 00:22:12,240
commit record yet

564
00:22:12,240 --> 00:22:13,840
because you know it crashed after we

565
00:22:13,840 --> 00:22:16,000
received the acknowledgement of one

566
00:22:16,000 --> 00:22:18,080
primary so let's say the p1 must

567
00:22:18,080 --> 00:22:20,320
actually have to commit record

568
00:22:20,320 --> 00:22:22,159
so in this case p1 will have to commit

569
00:22:22,159 --> 00:22:25,190
record

570
00:22:25,200 --> 00:22:27,039
and you know and of course you know the

571
00:22:27,039 --> 00:22:28,880
backup has a commit record for

572
00:22:28,880 --> 00:22:31,840
b1 and so this is enough information

573
00:22:31,840 --> 00:22:32,960
correct to for

574
00:22:32,960 --> 00:22:35,919
to convince the uh during recovery that

575
00:22:35,919 --> 00:22:37,280
actually the transaction has

576
00:22:37,280 --> 00:22:39,280
committed because you know we have a

577
00:22:39,280 --> 00:22:40,640
commit record you know which

578
00:22:40,640 --> 00:22:43,039
is just what the tid is that's committed

579
00:22:43,039 --> 00:22:45,039
and we actually have all the information

580
00:22:45,039 --> 00:22:46,000
that the backups

581
00:22:46,000 --> 00:22:48,960
namely the lock the commit records which

582
00:22:48,960 --> 00:22:49,520
describe

583
00:22:49,520 --> 00:22:52,720
the the right transformations on the

584
00:22:52,720 --> 00:22:54,640
backups and so during recovery

585
00:22:54,640 --> 00:22:56,000
we actually have enough information to

586
00:22:56,000 --> 00:22:57,679
decide you know that the transaction

587
00:22:57,679 --> 00:23:00,640
actually has committed

588
00:23:00,640 --> 00:23:03,360
um and so that's sufficient of course

589
00:23:03,360 --> 00:23:04,799
there's a complex protocol that actually

590
00:23:04,799 --> 00:23:06,320
needs to go into action and sort of look

591
00:23:06,320 --> 00:23:07,200
at all the

592
00:23:07,200 --> 00:23:08,720
pieces that are left behind by the

593
00:23:08,720 --> 00:23:10,400
transaction but there are enough pieces

594
00:23:10,400 --> 00:23:11,840
left behind for the transaction for the

595
00:23:11,840 --> 00:23:12,400
coordinator

596
00:23:12,400 --> 00:23:14,640
for the sort of new uh coordinator or

597
00:23:14,640 --> 00:23:16,640
the recovery process to decide that

598
00:23:16,640 --> 00:23:18,159
actual distance action indeed has

599
00:23:18,159 --> 00:23:18,880
committed

600
00:23:18,880 --> 00:23:22,320
and should be persistent

601
00:23:22,320 --> 00:23:29,990
okay

602
00:23:30,000 --> 00:23:34,559
good um so let me sort of summarize farm

603
00:23:34,559 --> 00:23:36,880
and before we jump into the discussion

604
00:23:36,880 --> 00:23:41,190
of spark

605
00:23:41,200 --> 00:23:43,440
so you know top level you know what what

606
00:23:43,440 --> 00:23:44,799
is sort of cool about

607
00:23:44,799 --> 00:23:48,080
farm is fast it can execute many many

608
00:23:48,080 --> 00:23:50,400
many transactions per second

609
00:23:50,400 --> 00:23:52,640
you know there are some restrictions of

610
00:23:52,640 --> 00:23:54,640
course you know on farm

611
00:23:54,640 --> 00:23:58,870
you can't do it in all

612
00:23:58,880 --> 00:24:02,230
all the time

613
00:24:02,240 --> 00:24:05,600
so first of all it assumes few

614
00:24:05,600 --> 00:24:09,679
conflicts so it uses this optimistic

615
00:24:09,679 --> 00:24:12,799
uh concurrency control scheme

616
00:24:12,799 --> 00:24:14,000
and the reason that it uses this

617
00:24:14,000 --> 00:24:15,520
optimistic recurrence pro screen because

618
00:24:15,520 --> 00:24:16,880
it doesn't want to take out logs because

619
00:24:16,880 --> 00:24:19,200
it wants to do this one-sided r dnas

620
00:24:19,200 --> 00:24:21,679
without actually any server involvement

621
00:24:21,679 --> 00:24:23,039
uh so use an optimistic

622
00:24:23,039 --> 00:24:25,360
currency control control scheme uh that

623
00:24:25,360 --> 00:24:26,080
means that

624
00:24:26,080 --> 00:24:28,480
uh if you want to get good performance

625
00:24:28,480 --> 00:24:29,520
and you know avoid

626
00:24:29,520 --> 00:24:31,600
transaction boards the workload better

627
00:24:31,600 --> 00:24:32,880
actually have few uh

628
00:24:32,880 --> 00:24:34,240
conflicts and we've seen in the

629
00:24:34,240 --> 00:24:35,760
evaluation that there are sort of the

630
00:24:35,760 --> 00:24:37,360
two common benchmarks that are being

631
00:24:37,360 --> 00:24:39,440
used in the transaction literature to

632
00:24:39,440 --> 00:24:41,600
measure systems uh for those two

633
00:24:41,600 --> 00:24:42,480
benchmarks

634
00:24:42,480 --> 00:24:44,799
uh you know clearly is doing extremely

635
00:24:44,799 --> 00:24:45,600
well this

636
00:24:45,600 --> 00:24:47,679
doesn't mean there are not that many

637
00:24:47,679 --> 00:24:49,919
conflicts

638
00:24:49,919 --> 00:24:51,120
the second assumption it makes is that

639
00:24:51,120 --> 00:24:58,390
the data must fit in memory

640
00:24:58,400 --> 00:25:00,240
so this either means that if you have a

641
00:25:00,240 --> 00:25:01,840
really really big database you have to

642
00:25:01,840 --> 00:25:03,440
buy more machines

643
00:25:03,440 --> 00:25:06,720
uh or if you really the data's too big

644
00:25:06,720 --> 00:25:08,000
and you don't want to buy more machines

645
00:25:08,000 --> 00:25:09,840
then basically you can't use farm

646
00:25:09,840 --> 00:25:11,279
and you have to sort of go back to a

647
00:25:11,279 --> 00:25:12,880
more traditional database that actually

648
00:25:12,880 --> 00:25:14,720
has you know persistent storage there

649
00:25:14,720 --> 00:25:15,279
and

650
00:25:15,279 --> 00:25:19,200
so you can read and write

651
00:25:19,200 --> 00:25:24,470
records to a much larger storage device

652
00:25:24,480 --> 00:25:29,600
replication is only

653
00:25:29,600 --> 00:25:36,390
it's only within the data center

654
00:25:36,400 --> 00:25:39,279
so in that way in that way respect it's

655
00:25:39,279 --> 00:25:40,880
quite different from

656
00:25:40,880 --> 00:25:43,360
spanner the whole goal there was to do

657
00:25:43,360 --> 00:25:44,720
synchronous transactions across the

658
00:25:44,720 --> 00:25:46,720
synchronous replication across

659
00:25:46,720 --> 00:25:49,039
data centers uh you know to support

660
00:25:49,039 --> 00:25:51,520
applications that you need to be able to

661
00:25:51,520 --> 00:25:55,039
survive or continue while some data

662
00:25:55,039 --> 00:25:56,320
centers are down

663
00:25:56,320 --> 00:25:58,080
in the case of you know farm that is

664
00:25:58,080 --> 00:25:59,520
just not the case

665
00:25:59,520 --> 00:26:00,880
it's not targeted to those kinds of

666
00:26:00,880 --> 00:26:03,669
applications

667
00:26:03,679 --> 00:26:08,960
and then the final point is it requires

668
00:26:08,960 --> 00:26:13,760
you know pretty fancy or exotic

669
00:26:13,760 --> 00:26:16,799
hardware in particular it has two things

670
00:26:16,799 --> 00:26:17,200
this

671
00:26:17,200 --> 00:26:20,960
uh ups distributed gps to

672
00:26:20,960 --> 00:26:24,480
survive complete data center outages and

673
00:26:24,480 --> 00:26:27,360
more importantly you know uses this rdma

674
00:26:27,360 --> 00:26:28,640
mix

675
00:26:28,640 --> 00:26:34,950
to get actually really high performance

676
00:26:34,960 --> 00:26:40,149
okay sort of all i wanted to say about

677
00:26:40,159 --> 00:26:50,830
farm unless there are any further

678
00:26:50,840 --> 00:26:55,350
questions

679
00:26:55,360 --> 00:26:58,960
okay um so that basically ends uh our

680
00:26:58,960 --> 00:27:02,159
uh set of papers uh

681
00:27:02,159 --> 00:27:03,919
or this is the sort of transaction side

682
00:27:03,919 --> 00:27:05,760
of the this uh

683
00:27:05,760 --> 00:27:07,600
of eight to four so we've like sort of

684
00:27:07,600 --> 00:27:09,360
done three lectures on

685
00:27:09,360 --> 00:27:11,520
uh transactions and uh that was

686
00:27:11,520 --> 00:27:12,799
basically uh this is the

687
00:27:12,799 --> 00:27:14,159
the end of talking about the

688
00:27:14,159 --> 00:27:15,919
transactions that will show up in other

689
00:27:15,919 --> 00:27:17,120
papers but you know we're not going to

690
00:27:17,120 --> 00:27:18,799
talk about that in any more detail

691
00:27:18,799 --> 00:27:20,880
in fact we're basically sort of done

692
00:27:20,880 --> 00:27:21,840
with

693
00:27:21,840 --> 00:27:23,520
talking about you know sort of the most

694
00:27:23,520 --> 00:27:25,360
challenging part in distributed systems

695
00:27:25,360 --> 00:27:26,000
namely

696
00:27:26,000 --> 00:27:27,600
you know building fall tall and storage

697
00:27:27,600 --> 00:27:29,200
systems

698
00:27:29,200 --> 00:27:31,520
and you know we're now seeing a broad

699
00:27:31,520 --> 00:27:32,880
spectrum of different designs

700
00:27:32,880 --> 00:27:34,320
including designs that there are

701
00:27:34,320 --> 00:27:36,880
actually support this very powerful

702
00:27:36,880 --> 00:27:39,919
programming extraction of transactions

703
00:27:39,919 --> 00:27:42,159
so in the next this lecture or the

704
00:27:42,159 --> 00:27:43,840
remaining of this lecture and

705
00:27:43,840 --> 00:27:45,360
subsequent lectures you know we're going

706
00:27:45,360 --> 00:27:47,279
to sort of look at different topics

707
00:27:47,279 --> 00:27:49,279
that are sort of unrelated to storage

708
00:27:49,279 --> 00:27:51,360
systems

709
00:27:51,360 --> 00:27:53,440
and so the first topic that we're going

710
00:27:53,440 --> 00:27:55,679
to be talking about

711
00:27:55,679 --> 00:27:58,640
is spark

