1
00:00:03,200 --> 00:00:07,820
Okay, good afternoon, good morning or good evening, wherever you are.

2
00:00:08,820 --> 00:00:12,300
I want to talk today about primary/backup replication,

3
00:00:12,330 --> 00:00:15,570
really sort of an introduction to primary/backup application.

4
00:00:16,350 --> 00:00:20,520
And we'll come back to this in multiple lectures during semester,

5
00:00:20,910 --> 00:00:28,650
but this is [] or a VMware fault tolerance paper,

6
00:00:28,650 --> 00:00:31,620
is a really nice introduction that brings out a lot of issues,

7
00:00:31,830 --> 00:00:34,560
that are gonna come up throughout the semester.

8
00:00:35,860 --> 00:00:38,410
The plan for lecture today is as follows.

9
00:00:41,170 --> 00:00:43,090
I'm just going to talk about failures,

10
00:00:43,090 --> 00:00:48,580
that you might hope to tolerate using primary/backup replication,

11
00:00:48,580 --> 00:00:51,310
and some that you might not be able to.

12
00:00:51,990 --> 00:00:54,570
Then I want to talk a little bit about the main challenges,

13
00:00:54,960 --> 00:00:57,630
in sort of any backup scheme,

14
00:00:58,980 --> 00:01:00,570
sort of broad speaking.

15
00:01:00,570 --> 00:01:06,500
Then talk about two you know dominant approaches, two application,

16
00:01:08,300 --> 00:01:12,980
one is what's typically called state transfer replication,

17
00:01:15,330 --> 00:01:18,420
and the second is typically called replicated state machines.

18
00:01:24,980 --> 00:01:29,060
And today's paper is an example of a replicated state machine approach,

19
00:01:29,450 --> 00:01:32,480
and if in fact you know lab 2 or lab 3, lab 4

20
00:01:32,480 --> 00:01:34,940
you know also will be using replicated state machine approach,

21
00:01:34,940 --> 00:01:39,470
and the fact that the GFS paper is replicating chunks

22
00:01:39,530 --> 00:01:41,510
was using a replicated state machine approach.

23
00:01:42,160 --> 00:01:44,020
Since it's quite a common approach.

24
00:01:44,290 --> 00:01:46,930
And then you know what I sort of make everything a little concrete,

25
00:01:46,930 --> 00:01:49,270
by looking at this case the case study,

26
00:01:52,140 --> 00:01:59,160
of the VM VMware fault tolerance scheme or implementation or system.

27
00:02:00,020 --> 00:02:03,020
Any questions before I get started,

28
00:02:03,020 --> 00:02:04,490
just to,

29
00:02:04,490 --> 00:02:09,380
I have tried to answer all the questions that you send by email,

30
00:02:10,040 --> 00:02:12,620
ones you know they're coming before midnight,

31
00:02:12,620 --> 00:02:15,290
generally all answer the ones that come in after midnight,

32
00:02:15,290 --> 00:02:17,360
you know try to answer as many as I can,

33
00:02:17,810 --> 00:02:19,520
but if I didn't answer your question,

34
00:02:19,520 --> 00:02:23,240
then you and the topic comes up at lecture or at any point by the time,

35
00:02:23,240 --> 00:02:25,610
you know feel free to interrupt and ask it.

36
00:02:26,920 --> 00:02:29,710
Okay, any questions, before we dive in.

37
00:02:41,740 --> 00:02:45,550
So let's talk about failures in a very broad sense,

38
00:02:45,790 --> 00:02:46,600
you get a sense of

39
00:02:46,600 --> 00:02:50,470
like what we might hope for that replication scheme can handle.

40
00:02:58,610 --> 00:03:00,740
So, first of all, the typically,

41
00:03:00,740 --> 00:03:03,680
the papers that where in the system that we're going to be about building

42
00:03:03,890 --> 00:03:06,020
will only deal with some things

43
00:03:06,020 --> 00:03:09,140
called were typically called fail-stop failures,

44
00:03:14,250 --> 00:03:15,510
and the basic idea is that,

45
00:03:15,510 --> 00:03:16,710
the infrastructure failure

46
00:03:16,710 --> 00:03:18,960
or component of the computer doesn't really work well,

47
00:03:19,470 --> 00:03:21,810
that actually stops the computer,

48
00:03:28,120 --> 00:03:29,140
so the assumption is that,

49
00:03:29,140 --> 00:03:33,190
basically the computer goes from working to not working, so instantaneously,

50
00:03:33,370 --> 00:03:35,230
it doesn't produce like weird results,

51
00:03:35,230 --> 00:03:37,240
because the computer is not working, correctly.

52
00:03:37,270 --> 00:03:39,730
So it just follows the protocols,

53
00:03:39,730 --> 00:03:43,210
you know when does to adds it to register values,

54
00:03:43,210 --> 00:03:45,370
you know that produces are correct, add value,

55
00:03:45,700 --> 00:03:47,530
and so we're just assuming that,

56
00:03:47,530 --> 00:03:49,840
when the computer works, it works correctly,

57
00:03:49,840 --> 00:03:52,120
and when there's a failure, it just stops.

58
00:03:53,030 --> 00:03:55,520
This covers in many scenarios,

59
00:03:55,580 --> 00:04:00,020
for example whatever you know fan of the computer fails,

60
00:04:00,020 --> 00:04:01,460
you know the computer overheat,

61
00:04:01,490 --> 00:04:03,440
and then the computer shuts down itself,

62
00:04:04,080 --> 00:04:09,870
the other cases are where somebody steps over the power cord,

63
00:04:10,020 --> 00:04:12,000
and boom, you know the whole computer disappears,

64
00:04:12,090 --> 00:04:14,370
or you know cuts the network link,

65
00:04:14,400 --> 00:04:15,840
and at that point,

66
00:04:15,840 --> 00:04:17,880
you know the computer by keeping running

67
00:04:17,880 --> 00:04:20,370
about is completely disconnected.

68
00:04:21,780 --> 00:04:25,170
Sometimes you know systems or software on the computer itself,

69
00:04:25,170 --> 00:04:29,820
it does best you know to turn these partial failures into a stop fail-stop failures,

70
00:04:30,240 --> 00:04:33,480
for example you might software might compute checksums on data,

71
00:04:33,480 --> 00:04:36,120
and then if it sees that the checksum is incorrect,

72
00:04:36,120 --> 00:04:38,160
you know just stop you know the computer.

73
00:04:39,080 --> 00:04:42,290
And so those are quite common

74
00:04:42,290 --> 00:04:43,430
and to do so,

75
00:04:43,430 --> 00:04:45,200
the basic model of the word is,

76
00:04:45,620 --> 00:04:47,540
computer work correctly, then the computer stops.

77
00:04:48,810 --> 00:04:50,130
So what does this exclude,

78
00:04:50,160 --> 00:04:52,920
you know there's a whole bunch of sort of failures that exclude,

79
00:04:52,920 --> 00:04:56,400
for example it doesn't really deal well with logic bugs,

80
00:04:57,140 --> 00:04:59,180
like if you have an error in your software,

81
00:04:59,180 --> 00:05:01,220
you know whatever you divide by zero

82
00:05:01,220 --> 00:05:04,580
and incorrectly you were where you shouldn't have,

83
00:05:04,940 --> 00:05:06,380
then you know it is very likely,

84
00:05:06,380 --> 00:05:08,210
that the backup will do exactly the same thing,

85
00:05:08,270 --> 00:05:10,130
because one of the software which is broken,

86
00:05:10,130 --> 00:05:13,400
and so it's broken on the primary, it's broken on the backup,

87
00:05:13,550 --> 00:05:17,270
and so nothing you know basically replication really not

88
00:05:17,270 --> 00:05:18,710
does not solve that problem for you.

89
00:05:19,520 --> 00:05:22,190
Similar, if you have configuration errors,

90
00:05:26,150 --> 00:05:29,120
primary/backup is not going to solve you the problem for you,

91
00:05:29,240 --> 00:05:35,000
if you know the, the files that you specify the replica said that incorrect,

92
00:05:35,030 --> 00:05:37,430
then the system will not work correctly.

93
00:05:38,030 --> 00:05:41,000
Similarly, we're not really in this class,

94
00:05:41,000 --> 00:05:43,160
we'll talk a little bit at the end of the semester,

95
00:05:43,160 --> 00:05:46,400
but we're not dealing with malicious errors,

96
00:05:48,170 --> 00:05:53,420
so we're not dealing with attackers you know try to fake the protocol,

97
00:05:53,420 --> 00:05:56,660
you know have run servers that send incorrect messages

98
00:05:56,840 --> 00:05:59,300
and try to sort of spoof the whole system,

99
00:05:59,420 --> 00:06:00,920
we're just not in consideration.

100
00:06:00,920 --> 00:06:03,260
So in the for most of the semester,

101
00:06:03,320 --> 00:06:05,420
we assume that the software works correctly,

102
00:06:05,450 --> 00:06:06,860
does not have logic bugs,

103
00:06:06,890 --> 00:06:08,420
that no configuration errors,

104
00:06:08,510 --> 00:06:11,450
and the thing that we're focusing on is actually handling stop failures.

105
00:06:12,950 --> 00:06:15,350
There's some failures that sort of fail,

106
00:06:15,530 --> 00:06:21,770
that could be handled or may be handled with primary/backup replication

107
00:06:22,010 --> 00:06:23,240
or or not,

108
00:06:23,540 --> 00:06:26,570
as an example, you might think about an earthquake,

109
00:06:29,690 --> 00:06:33,260
you know if the primary/backup are physically you know separated,

110
00:06:33,410 --> 00:06:35,240
in completely different parts,

111
00:06:35,240 --> 00:06:38,030
you know different continents or different parts of the same continent,

112
00:06:38,300 --> 00:06:39,800
when that, you might hope that,

113
00:06:39,800 --> 00:06:41,090
you might have some hope that,

114
00:06:41,090 --> 00:06:43,550
the backup could take over,

115
00:06:43,550 --> 00:06:46,580
if the primary fails due to an earthquake,

116
00:06:46,760 --> 00:06:50,900
but you know some other primary replication schemes,

117
00:06:50,900 --> 00:06:52,160
this is not going to be the case,

118
00:06:52,160 --> 00:06:55,250
you know [] primary and the backup on the same data center,

119
00:06:55,250 --> 00:06:57,260
and the whole data center disappears,

120
00:06:57,470 --> 00:06:59,060
then you know sort of end of story.

121
00:07:00,220 --> 00:07:00,850
Okay?

122
00:07:01,060 --> 00:07:02,830
So hopefully that gives you a little bit of context

123
00:07:02,830 --> 00:07:05,500
of the type of failures you're trying to shoot for.

124
00:07:06,510 --> 00:07:11,130
You know, even with this sort of just focusing on stop fail-stop failures,

125
00:07:11,340 --> 00:07:14,880
that turns out to be difficult to build fault tolerant systems,

126
00:07:15,060 --> 00:07:18,120
we're going to talk a little bit about the general issues that will show up,

127
00:07:18,120 --> 00:07:22,350
you know if we're going to build a primary/backup system,

128
00:07:25,040 --> 00:07:30,350
and also concrete instances of these problems in in the the VM FT paper.

129
00:07:31,010 --> 00:07:33,980
So you know one challenge is

130
00:07:33,980 --> 00:07:36,410
you know if a failure happens,

131
00:07:36,560 --> 00:07:38,810
you know has the primary actually failed?

132
00:07:47,690 --> 00:07:50,570
A issue here you know that makes this challenging is that,

133
00:07:50,570 --> 00:07:51,470
in distributed systems,

134
00:07:51,470 --> 00:07:54,410
you can't tell the difference between a network partition and a machine failed,

135
00:07:54,410 --> 00:07:55,850
so it might be perfectly possible,

136
00:07:55,850 --> 00:07:59,300
that the network, that the primary is still up,

137
00:07:59,300 --> 00:08:01,940
but you know that some computers cannot talk to the primary,

138
00:08:01,940 --> 00:08:04,310
because the network has partitioned,

139
00:08:04,310 --> 00:08:06,230
and so for example the backup might decide,

140
00:08:06,230 --> 00:08:07,490
that you know the primary is dead,

141
00:08:07,490 --> 00:08:08,660
because networks partitioned,

142
00:08:08,840 --> 00:08:10,340
but in fact the primary is not that,

143
00:08:10,700 --> 00:08:13,280
maybe some of the clients are still able to talk to the primary,

144
00:08:13,400 --> 00:08:14,930
so you have to have some story

145
00:08:15,080 --> 00:08:20,720
of making sure that you don't end up in a situation where you have two primaries.

146
00:08:21,360 --> 00:08:24,240
And again, you know we talked a little bit about last time,

147
00:08:24,240 --> 00:08:25,470
it shows up in this paper again,

148
00:08:25,470 --> 00:08:26,970
will show up next week too,

149
00:08:27,120 --> 00:08:29,820
which is like we want to avoid that we get into a situation,

150
00:08:29,820 --> 00:08:31,740
where there's a split-brain system,

151
00:08:35,090 --> 00:08:37,460
where we basically have two primaries,

152
00:08:37,460 --> 00:08:40,160
and one subset of client talks to one primary,

153
00:08:40,160 --> 00:08:42,050
and the other subset of client talks to the other primary,

154
00:08:42,320 --> 00:08:46,160
and clearly that's going to diverge you know the state of the system

155
00:08:46,280 --> 00:08:50,840
and when the network heals, we are in an incorrect state,

156
00:08:50,990 --> 00:08:53,000
so we have to avoid this at all cost.

157
00:08:54,230 --> 00:08:57,500
The second general challenge is,

158
00:08:57,830 --> 00:09:00,260
how do we keep the,

159
00:09:00,290 --> 00:09:03,620
you know how do we keep the primary/backup in sync.

160
00:09:14,000 --> 00:09:15,350
Our goal is going to be that,

161
00:09:15,350 --> 00:09:17,570
if the primary fails,

162
00:09:17,570 --> 00:09:20,390
then we can just gracefully fail over to backup,

163
00:09:20,390 --> 00:09:23,240
and the backup just picks up right where the primary left off,

164
00:09:23,920 --> 00:09:26,350
that requires that the backup actually is up to date,

165
00:09:26,350 --> 00:09:31,480
like the latest things that are primary actually has written to its state,

166
00:09:31,480 --> 00:09:33,580
so that actually can pick up seamlessly

167
00:09:33,580 --> 00:09:38,470
and don't return errors or responses to the client to completely unexpected,

168
00:09:38,980 --> 00:09:40,270
from the client's perspective,

169
00:09:40,360 --> 00:09:41,440
really what should look like,

170
00:09:41,440 --> 00:09:43,450
you know the whole thing even though it's replicated,

171
00:09:43,570 --> 00:09:44,650
like a single computer,

172
00:09:44,680 --> 00:09:47,230
just happens to be a little more fault tolerant than a single computer.

173
00:09:48,680 --> 00:09:50,690
And that turns out to be difficult,

174
00:09:50,720 --> 00:09:51,710
you know first of all,

175
00:09:51,710 --> 00:09:54,560
we have to make sure that we apply all changes,

176
00:09:54,560 --> 00:09:56,450
we have to apply the changes in the right order,

177
00:10:01,880 --> 00:10:05,600
and you know in continuous issue in that,

178
00:10:05,990 --> 00:10:08,180
we have to sort of avoid non-determinism,

179
00:10:08,660 --> 00:10:10,880
or we have to deal with non-determinism,

180
00:10:13,610 --> 00:10:17,540
I mean the same change on the primary behaves different on the backup,

181
00:10:17,540 --> 00:10:19,580
because for some reason, that would be not good,

182
00:10:19,610 --> 00:10:20,780
you know we got to make sure,

183
00:10:20,780 --> 00:10:22,490
that we make a change in the primary/backup

184
00:10:22,490 --> 00:10:25,790
very identical effects to the primary/backup.

185
00:10:27,740 --> 00:10:30,710
A similar issue that always shows up,

186
00:10:30,710 --> 00:10:32,390
you know challenge is fail over,

187
00:10:35,460 --> 00:10:37,740
you have actually the primary fails,

188
00:10:37,740 --> 00:10:39,870
and we need to fail over to the backup,

189
00:10:40,110 --> 00:10:42,150
and of course we've got to make sure that,

190
00:10:42,600 --> 00:10:45,180
there are other primary is definitely dead,

191
00:10:45,390 --> 00:10:49,500
but for example the primary might have was in the middle of an operation,

192
00:10:49,500 --> 00:10:52,290
and it was about to send a packet out,

193
00:10:52,290 --> 00:10:53,580
to the response to the client,

194
00:10:53,760 --> 00:10:54,630
or maybe not,

195
00:10:54,900 --> 00:10:56,370
and so we got to figure out,

196
00:10:56,370 --> 00:10:58,290
what that response that being send or not being sent,

197
00:10:58,320 --> 00:11:00,120
or is it okay for us to send it again.

198
00:11:04,300 --> 00:11:05,890
There's a question in the chat,

199
00:11:05,890 --> 00:11:07,840
like when would fail over need to happen,

200
00:11:07,840 --> 00:11:10,360
you know fail over need to happen when the primary is gone, right,

201
00:11:10,540 --> 00:11:12,970
because then we want to fail over to the backup,

202
00:11:12,970 --> 00:11:14,500
that determine all you used.

203
00:11:16,860 --> 00:11:19,710
And then often another issue we fail over is,

204
00:11:19,830 --> 00:11:22,080
who actually has to know we have multiple backups,

205
00:11:22,080 --> 00:11:23,820
which is not the case in today's paper,

206
00:11:23,880 --> 00:11:25,740
yeah we actually ask the latest [stage],

207
00:11:25,740 --> 00:11:28,650
like for example, maybe they all crash after a few operations,

208
00:11:28,650 --> 00:11:29,520
they come back up

209
00:11:29,550 --> 00:11:33,720
and and and we're going to make sure that,

210
00:11:33,720 --> 00:11:36,060
we're actually talking to one that has the most recent states,

211
00:11:36,060 --> 00:11:38,400
this is going to not an issue today so much,

212
00:11:38,640 --> 00:11:40,140
as we'll see in a second why,

213
00:11:40,200 --> 00:11:42,930
but we'll come up later in other replication protocols.

214
00:11:45,640 --> 00:11:48,190
Yeah, so basically fail over means the backup takes over.

215
00:11:51,280 --> 00:11:55,030
Okay, so that's sort of the main you know failure,

216
00:11:55,030 --> 00:11:59,320
the type of failures that we hope to handle and the main challenges,

217
00:11:59,320 --> 00:12:02,770
in we'll deepen those challenges out as we go.

218
00:12:03,070 --> 00:12:06,160
You know I want to talk about two two main approaches,

219
00:12:06,190 --> 00:12:07,630
that we'll see in a semester,

220
00:12:07,780 --> 00:12:10,990
for dealing with primary/backup replication.

221
00:12:19,000 --> 00:12:23,050
One is as I mentioned earlier, that is state transfer,

222
00:12:27,780 --> 00:12:30,510
you know these reasonable at a high-level very straightforward,

223
00:12:30,510 --> 00:12:31,740
you know we've got a primary,

224
00:12:32,360 --> 00:12:35,060
you know if you know the clients talk to the primary,

225
00:12:35,390 --> 00:12:37,310
and the primary updated state,

226
00:12:37,310 --> 00:12:40,310
once updated state in response to client request,

227
00:12:40,400 --> 00:12:42,650
and once a while, it sort of makes checkpoint,

228
00:12:48,240 --> 00:12:57,330
once a while, basically checkpoints state, it's state to the backup,

229
00:13:01,120 --> 00:13:04,510
and of course if we want the backup and the primary to be in sync,

230
00:13:04,510 --> 00:13:07,450
that means that every time the primary actually performs the operation,

231
00:13:07,750 --> 00:13:09,730
before it responds to the client,

232
00:13:09,790 --> 00:13:14,350
it basically has to transfer whatever state changes that were made by the operation to the backup.

233
00:13:15,480 --> 00:13:17,580
So that's one scheme.

234
00:13:17,970 --> 00:13:22,140
One of high-level approach, second approach is,

235
00:13:22,140 --> 00:13:28,980
what is called replicated state machine, state machine replication,

236
00:13:32,920 --> 00:13:35,110
often shortened to RSM.

237
00:13:36,180 --> 00:13:39,690
And here you know the you know the picture is,

238
00:13:39,750 --> 00:13:40,920
we still got the primary,

239
00:13:40,920 --> 00:13:43,080
we've got the client talking to the primary,

240
00:13:43,320 --> 00:13:45,600
and of course we have the primary talking to backup

241
00:13:45,600 --> 00:13:46,830
to keep the backup in sync,

242
00:13:47,040 --> 00:13:52,320
but instead it sending the state changes or modifications to the state

243
00:13:52,320 --> 00:13:53,310
from the primary to the backup,

244
00:13:53,400 --> 00:13:56,940
but we do actually sent the operations to the backup,

245
00:13:58,990 --> 00:14:01,570
so before the primary response to the client,

246
00:14:01,570 --> 00:14:03,100
you know executing its operation,

247
00:14:03,310 --> 00:14:06,700
we sent the operation that the client sent to us to the backup,

248
00:14:06,880 --> 00:14:09,070
the backup can execute the operation too,

249
00:14:09,370 --> 00:14:12,160
updated state, acknowledge it to the primary,

250
00:14:12,160 --> 00:14:13,810
primary actually updates its state too,

251
00:14:13,810 --> 00:14:15,220
you know execute the operation,

252
00:14:15,220 --> 00:14:17,770
and then sends a response back to the client.

253
00:14:19,500 --> 00:14:24,810
And so in all these sort of, in all these both approaches,

254
00:14:24,870 --> 00:14:28,050
you know the scheme is the primary of some particular state,

255
00:14:28,410 --> 00:14:30,690
we apply changes to the state,

256
00:14:31,020 --> 00:14:33,870
and we do exactly the same thing as the backup,

257
00:14:33,870 --> 00:14:36,660
so the backup system starts out in the same state as the primary,

258
00:14:36,720 --> 00:14:38,460
we apply the same changes to the state,

259
00:14:38,460 --> 00:14:40,500
where it's through an operation state transfer,

260
00:14:40,530 --> 00:14:41,760
we end up in a new state,

261
00:14:41,880 --> 00:14:44,610
and that state has to be identical to the state that the primary has.

262
00:14:45,200 --> 00:14:47,270
And so even ever there's a failure,

263
00:14:47,450 --> 00:14:50,300
you know, we know that when we fail over to backup,

264
00:14:50,300 --> 00:14:52,520
and it's exactly the same state as the primary,

265
00:14:52,520 --> 00:14:53,900
and so it can take over.

266
00:14:57,190 --> 00:15:00,040
We'll see you know this is actually challenging to actually make happen,

267
00:15:00,040 --> 00:15:01,420
but that's the basic plan,

268
00:15:01,990 --> 00:15:07,600
the primary both approach is actually reasonable popular,

269
00:15:07,600 --> 00:15:11,020
the primary disadvantages, the state transfer approach is that,

270
00:15:11,020 --> 00:15:13,870
if an operation generates a lot of state,

271
00:15:13,870 --> 00:15:15,070
then it's going to be expensive,

272
00:15:15,640 --> 00:15:17,530
for a single operation writes gigabyte of data,

273
00:15:17,530 --> 00:15:21,670
then gigabyte of data needs to be transferred to the primary to the backup,

274
00:15:21,820 --> 00:15:25,090
and it might be much more expensive, much more, less expensive

275
00:15:25,090 --> 00:15:27,520
to basically just send over the operation to the backups,

276
00:15:27,670 --> 00:15:29,410
backup can executing operation.

277
00:15:30,710 --> 00:15:34,880
So many of the systems that we're talking about,

278
00:15:34,880 --> 00:15:36,800
actually they're follow the second approach

279
00:15:37,010 --> 00:15:40,220
where they send the operation, but not the state transfer.

280
00:15:41,080 --> 00:15:45,580
And in fact if you think about GFS,

281
00:15:45,640 --> 00:15:47,980
the discussion from last week,

282
00:15:48,130 --> 00:15:49,210
when we just saw that,

283
00:15:49,210 --> 00:15:54,970
basically the primary sends the append operations or the write operations to the backups,

284
00:15:55,090 --> 00:15:58,600
doesn't do the append and then send the result to the backups,

285
00:15:58,600 --> 00:16:00,010
that actually sends the operations,

286
00:16:00,010 --> 00:16:03,070
so that's an example of a replicated state machine approach,

287
00:16:03,160 --> 00:16:04,660
where we'll be sending operations.

288
00:16:05,060 --> 00:16:08,720
And the paper of today also follows this replicated state machine approach,

289
00:16:08,720 --> 00:16:11,750
where the operations are not you know append and write,

290
00:16:12,050 --> 00:16:14,150
file system append, file system write,

291
00:16:14,180 --> 00:16:16,670
but the operations are actually x86 instructions,

292
00:16:16,670 --> 00:16:19,040
you know we'll see later,

293
00:16:19,640 --> 00:16:23,000
but they both you know send operations.

294
00:16:24,560 --> 00:16:27,140
In labs, as I mentioned earlier,

295
00:16:27,140 --> 00:16:32,300
lab 3 and 4 are also a replicated state machine approach,

296
00:16:32,300 --> 00:16:35,120
where we're gonna be sending operations from primary to backup.

297
00:16:40,710 --> 00:16:41,550
As a.

298
00:16:47,330 --> 00:16:48,350
Okay, there's a question in chat,

299
00:16:48,350 --> 00:16:52,100
why does the client do not send not need to send the data to backup

300
00:16:52,100 --> 00:16:53,240
in our replication state machine,

301
00:16:53,240 --> 00:16:57,530
because the the idea is that these operations are deterministic,

302
00:16:57,560 --> 00:16:59,690
and so the primary and this you know remember,

303
00:16:59,690 --> 00:17:01,250
we'll talk about this in much more detail,

304
00:17:01,250 --> 00:17:03,140
but the primary/backup are in the same state,

305
00:17:03,140 --> 00:17:05,940
same state as the,

306
00:17:06,330 --> 00:17:08,820
if the operation is deterministic,

307
00:17:08,850 --> 00:17:10,500
and you apply it to the same state,

308
00:17:10,500 --> 00:17:12,690
you know they will end up in the same state as primary,

309
00:17:13,400 --> 00:17:16,640
and so there's no reason for the application, the client to send the data,

310
00:17:16,670 --> 00:17:17,270
in this case,

311
00:17:17,270 --> 00:17:19,940
because by just sending this deterministic operation,

312
00:17:20,060 --> 00:17:21,200
it is guaranteed,

313
00:17:21,200 --> 00:17:23,000
that operation will generate the same data.

314
00:17:26,800 --> 00:17:28,270
So subsequent question is,

315
00:17:28,270 --> 00:17:30,490
how do you know for all programs and their operations,

316
00:17:30,490 --> 00:17:32,500
whether they are deterministic or non-deterministic,

317
00:17:32,620 --> 00:17:34,870
to know what information needs to be sent.

318
00:17:34,870 --> 00:17:37,960
So the typical approaches do in a replicated state machine approach is

319
00:17:37,960 --> 00:17:39,850
to make all operations deterministic,

320
00:17:40,320 --> 00:17:42,510
non-deterministic operations are not allowed,

321
00:17:42,600 --> 00:17:44,220
and we'll see in a second how to do that.

322
00:17:48,650 --> 00:17:53,270
Okay, so before you know go into a little bit more specific,

323
00:17:54,660 --> 00:17:56,100
and a hybrid approach,

324
00:17:56,280 --> 00:17:59,160
yes you know there a hybrid approach,

325
00:17:59,160 --> 00:18:01,080
you know for example you can run sort of

326
00:18:01,080 --> 00:18:05,670
by default in a replicated state machine approach,

327
00:18:05,670 --> 00:18:08,610
in the fact, so in some ways the paper does this,

328
00:18:08,730 --> 00:18:13,350
then if a backup fails or primary fails,

329
00:18:13,350 --> 00:18:14,850
and you go back to a single machine,

330
00:18:15,030 --> 00:18:17,310
then you need to create a new replica,

331
00:18:17,340 --> 00:18:19,380
and often new replica the way you do,

332
00:18:19,380 --> 00:18:23,160
it is actually by transferring the state from the existing replica

333
00:18:23,160 --> 00:18:25,800
or copy of the state of existing replica to the new replica,

334
00:18:26,990 --> 00:18:29,780
without like hopefully less frequent operation.

335
00:18:30,760 --> 00:18:32,080
And then actually you know during,

336
00:18:32,080 --> 00:18:37,150
then replicating the operations you're doing much more frequently.

337
00:18:39,810 --> 00:18:43,410
Also free, feel free to ask questions in real time

338
00:18:43,410 --> 00:18:45,300
as opposed to typing in the chat,

339
00:18:45,330 --> 00:18:46,980
either way is fine, but.

340
00:18:48,080 --> 00:18:50,510
Okay, so, as I hinted,

341
00:18:50,600 --> 00:18:52,460
you know with this replicated state machine approach,

342
00:18:52,640 --> 00:18:53,840
there's a question about

343
00:18:53,960 --> 00:18:58,340
what level of replication are doing

344
00:18:58,340 --> 00:19:05,130
or what level of operations to replicate.

345
00:19:12,540 --> 00:19:17,940
So one one of possibilities sort of application level operations,

346
00:19:35,600 --> 00:19:37,310
so what I mean is,

347
00:19:37,310 --> 00:19:39,590
you know think back GFS,

348
00:19:39,770 --> 00:19:47,520
like whether it's append file append or write.

349
00:19:50,900 --> 00:19:54,620
Another and okay and

350
00:19:54,950 --> 00:19:57,650
if you play a game sort of replicate state machine game

351
00:19:57,650 --> 00:19:59,810
at the level of these application level operations,

352
00:19:59,810 --> 00:20:01,760
that means that the application has to be involved,

353
00:20:01,820 --> 00:20:04,760
because it knows what the semantics of these operations are,

354
00:20:05,280 --> 00:20:07,770
and then it knows what append actually supposed to do,

355
00:20:08,190 --> 00:20:09,990
or what write you're supposed to do,

356
00:20:09,990 --> 00:20:13,320
and so, if you're playing a replicated state machine approach

357
00:20:13,320 --> 00:20:15,360
at that kind of application level,

358
00:20:15,390 --> 00:20:17,550
then the application itself needs to be modified

359
00:20:17,550 --> 00:20:22,020
to actually perform or play part of the replicated state machine approach.

360
00:20:22,740 --> 00:20:25,980
One thing that's cool about the paper today that we're looking at to,

361
00:20:26,370 --> 00:20:29,040
it's like looking at today is,

362
00:20:29,340 --> 00:20:32,010
it you know operations at the machine level,

363
00:20:32,660 --> 00:20:34,790
or the processor level or computer level,

364
00:20:35,270 --> 00:20:42,410
and so the state is registers x86 registers, the memory state,

365
00:20:42,830 --> 00:20:48,200
and the operations are just an ordinary computer instructions

366
00:20:48,230 --> 00:20:51,440
and by replicating at that level,

367
00:20:51,530 --> 00:20:57,340
then you can basically make your application completely transparent,

368
00:20:57,820 --> 00:20:59,140
because you can take one computer,

369
00:20:59,140 --> 00:21:01,990
run the application operating system on top of it,

370
00:21:01,990 --> 00:21:04,360
just runs x86 instructions,

371
00:21:04,720 --> 00:21:06,970
and this replicated state machine approach

372
00:21:07,180 --> 00:21:13,090
automatically creates backup of that particular execution,

373
00:21:13,090 --> 00:21:15,100
so the application doesn't have to be modified at all,

374
00:21:15,100 --> 00:21:19,030
in fact, in this paper, the operating system is not modified,

375
00:21:19,060 --> 00:21:20,470
the application is not modified,

376
00:21:20,560 --> 00:21:22,120
you can take an ordinary application,

377
00:21:22,120 --> 00:21:24,640
not even written with fault tolerance in mind,

378
00:21:24,880 --> 00:21:29,950
and using this sort of machine level or instruction level replication,

379
00:21:30,040 --> 00:21:32,860
it can be transparently replicated.

380
00:21:33,210 --> 00:21:34,560
One of the things that's very cool

381
00:21:34,560 --> 00:21:37,740
about you know paper of today is completely transparent.

382
00:21:42,350 --> 00:21:47,430
You know that makes you wonder you know how to do that,

383
00:21:47,430 --> 00:21:48,480
because what happens,

384
00:21:48,480 --> 00:21:49,860
if you look at machine

385
00:21:49,860 --> 00:21:51,270
and an interrupt happens,

386
00:21:51,510 --> 00:21:57,060
you know that interrupt needs to be propagated in some way directly to the backup,

387
00:21:57,060 --> 00:21:59,520
because like if you think about the x86 machine,

388
00:21:59,700 --> 00:22:02,640
of course the regular instructions that the applications execute,

389
00:22:02,790 --> 00:22:08,430
like add, you know whatever divide, you know conditional branch branching procedure calls,

390
00:22:08,460 --> 00:22:11,010
but there are also other events like an interrupts,

391
00:22:11,010 --> 00:22:13,320
and they need to be you know handled with,

392
00:22:13,380 --> 00:22:14,250
so how do you do that.

393
00:22:15,020 --> 00:22:21,890
And so a traditional, a way of doing a machine level replication,

394
00:22:22,100 --> 00:22:24,140
used to be sort of quite expensive,

395
00:22:24,140 --> 00:22:25,730
in the sense that,

396
00:22:25,760 --> 00:22:28,700
the you could buy computers or whatever processors,

397
00:22:28,700 --> 00:22:30,860
like maybe replicated twice or three times

398
00:22:31,100 --> 00:22:34,820
and the hardware itself would organize you know these processors

399
00:22:34,820 --> 00:22:37,040
sort of ran exactly in lockstep,

400
00:22:38,080 --> 00:22:41,710
and you know there's a lot of hardware machinery to actually make this happen,

401
00:22:41,710 --> 00:22:44,530
and this paper has a cool observation that,

402
00:22:44,830 --> 00:22:48,760
you don't really need to do really hardware replication,

403
00:22:48,820 --> 00:22:51,250
instead you can actually use virtual machines,

404
00:22:57,520 --> 00:22:58,750
and that's the way they do it,

405
00:22:59,360 --> 00:23:02,270
that pure hardware replication happens too,

406
00:23:02,300 --> 00:23:11,270
you know, for example in in [] or whatever [] over,

407
00:23:11,300 --> 00:23:13,700
you know often the hardware modules are just like

408
00:23:13,700 --> 00:23:17,930
duplex replicated to triple replication

409
00:23:17,930 --> 00:23:19,520
and have a hardware voting scheme

410
00:23:20,030 --> 00:23:22,820
to keep the processors in sync to detect failures,

411
00:23:22,970 --> 00:23:24,950
but that sort of level of fault tolerance,

412
00:23:24,950 --> 00:23:33,410
that is not the the level, is that VM-FT paper not actually shooting for,

413
00:23:33,530 --> 00:23:34,850
is really thinking about like,

414
00:23:34,850 --> 00:23:39,440
you know you got in a business application running on on the computer,

415
00:23:39,440 --> 00:23:42,110
and now you want to make that business application more fault tolerant,

416
00:23:42,560 --> 00:23:46,010
and the approach to take is to exploit virtualization.

417
00:23:48,550 --> 00:23:55,880
So the situation to VM-FT is exploit virtualization,

418
00:23:55,940 --> 00:24:01,080
that's the main big idea,

419
00:24:01,080 --> 00:24:03,630
that they bring along to this problem,

420
00:24:03,630 --> 00:24:04,950
and you know by doing so,

421
00:24:04,950 --> 00:24:08,340
they can make this replication transparent to the application,

422
00:24:16,580 --> 00:24:17,870
of course, you don't have to design,

423
00:24:17,870 --> 00:24:21,050
as an application design and then the replication scheme,

424
00:24:21,050 --> 00:24:26,210
where like for example the way it's done in, in GFS,

425
00:24:26,510 --> 00:24:29,240
it appears using the scheme,

426
00:24:29,240 --> 00:24:32,150
this replication scheme that VM-FT uses,

427
00:24:32,390 --> 00:24:36,510
appears basically that the appears to client,

428
00:24:37,560 --> 00:24:39,300
but the server is a single machine,

429
00:24:44,430 --> 00:24:47,520
meaning just you know seeing in a second how,

430
00:24:47,520 --> 00:24:49,920
but basically they're gonna provide very strong consistency,

431
00:24:49,920 --> 00:24:53,070
you know the client on the outside can't even tell.

432
00:24:53,560 --> 00:24:57,310
And, it actually you know the paper sort of cool paper,

433
00:24:57,310 --> 00:24:59,740
because it actually is, it's a real product,

434
00:25:04,210 --> 00:25:05,770
and it's still in use,

435
00:25:06,160 --> 00:25:12,940
you know you can get this, there's this support if you want to.

436
00:25:13,730 --> 00:25:16,970
The current product I think is quite different from the one,

437
00:25:16,970 --> 00:25:19,610
that we actually read about in the paper,

438
00:25:19,610 --> 00:25:21,710
but you know at a very high level,

439
00:25:21,740 --> 00:25:23,690
you know the issues are very similar,

440
00:25:24,170 --> 00:25:28,070
in fact you know one of the big shortcomings

441
00:25:28,070 --> 00:25:29,720
as many of you noted in the questions,

442
00:25:29,960 --> 00:25:33,200
of the the one that [] in the paper,

443
00:25:33,200 --> 00:25:35,150
it's a single core solution,

444
00:25:35,450 --> 00:25:37,100
so there's no multi-core support,

445
00:25:37,310 --> 00:25:41,120
so multiple applications or multiple threads on one computer cannot run in parallel,

446
00:25:41,600 --> 00:25:42,680
then we'll talk about in a second,

447
00:25:42,680 --> 00:25:44,630
why this solution doesn't really support that,

448
00:25:44,870 --> 00:25:50,510
in I think later later versions of FT does actually works,

449
00:25:50,540 --> 00:25:56,270
and I think there's no paper detail paper that describes it,

450
00:25:56,300 --> 00:25:57,260
but I actually think that,

451
00:25:57,260 --> 00:26:00,110
instead of using actually replicated state machine approach,

452
00:26:00,110 --> 00:26:02,240
actually using state transfer approach,

453
00:26:02,920 --> 00:26:06,100
but I really don't know any really the details.

454
00:26:07,420 --> 00:26:09,820
We're going to focus on the replicated state machine approach,

455
00:26:09,820 --> 00:26:11,440
because one reason I like this paper is,

456
00:26:11,440 --> 00:26:15,520
because it sort of illustrates replicated state machine approach in a very clean manner,

457
00:26:15,730 --> 00:26:20,170
and all the you know all the subsequent replication schemes,

458
00:26:20,170 --> 00:26:21,160
that were going to be looking at

459
00:26:21,190 --> 00:26:23,620
are replicated state machine approaches.

460
00:26:26,290 --> 00:26:36,530
Okay, so, so let's sketch out the overview of the system.

461
00:26:37,250 --> 00:26:41,030
And so the first thing sort of need to realizes that,

462
00:26:41,030 --> 00:26:43,610
there's a virtual virtual machine monitor involved,

463
00:26:43,700 --> 00:26:45,170
so what is a virtual machine monitor,

464
00:26:45,410 --> 00:26:48,380
well virtual machine monitor basically takes a piece of hardware

465
00:26:48,470 --> 00:26:53,930
and it makes it appear you know basically makes n pieces of hardware out of it.

466
00:26:54,760 --> 00:26:58,630
So if we look at the x86 box,

467
00:26:58,630 --> 00:27:01,330
you know we can take a virtual machine monitor run it on top of it,

468
00:27:03,280 --> 00:27:05,830
and you know on top of it, we can have virtual machines,

469
00:27:06,310 --> 00:27:09,370
and virtual machine, we're gonna have multiple virtual machines,

470
00:27:09,370 --> 00:27:11,710
although most of this paper we're going to be talking about,

471
00:27:11,710 --> 00:27:14,470
running one virtual machine on top of the virtual machine monitor.

472
00:27:15,320 --> 00:27:19,250
And so for example we might actually have a Linux operating system

473
00:27:19,250 --> 00:27:23,030
running on top of the virtual machine with its applications.

474
00:27:28,260 --> 00:27:30,720
And you know here is actually the actual hardware.

475
00:27:31,920 --> 00:27:35,700
And why you know so and so VM,

476
00:27:35,880 --> 00:27:38,940
the terminology used here sometimes called a hypervisor,

477
00:27:38,940 --> 00:27:40,560
it's called a virtual machine monitor,

478
00:27:40,830 --> 00:27:45,390
and so in our case, you know will the the hypervisor here,

479
00:27:45,390 --> 00:27:47,730
this is actually you know VM-FT,

480
00:27:50,400 --> 00:27:51,900
so it's a hypervisor modified,

481
00:27:51,900 --> 00:27:56,340
you know to include you know the ideas that were VM-FT has.

482
00:27:57,570 --> 00:27:58,440
Why is this cool,

483
00:27:58,440 --> 00:28:00,240
well, the reason this is cool, because,

484
00:28:00,240 --> 00:28:02,970
or useful for replicated state machines is,

485
00:28:02,970 --> 00:28:05,880
because even a hardware interrupt actually happens,

486
00:28:06,120 --> 00:28:09,030
that hardware interrupt doesn't really go straight to Linux,

487
00:28:09,030 --> 00:28:11,730
in fact, the hardware interrupt goes first through the VM monitor,

488
00:28:12,500 --> 00:28:14,090
the VM monitor actually decides

489
00:28:14,090 --> 00:28:17,150
you know when to deliver you know that interrupt to Linux.

490
00:28:17,800 --> 00:28:24,040
And so any external events before they actually sort of observed by the virtual machines

491
00:28:24,100 --> 00:28:28,000
actually captured by or can be captured by the hypervisor.

492
00:28:28,650 --> 00:28:31,110
And so this gets us out of this mess,

493
00:28:31,140 --> 00:28:33,180
you know like what I mentioned a bit earlier,

494
00:28:33,180 --> 00:28:36,570
where you know what happens if there's an external interrupt,

495
00:28:36,570 --> 00:28:38,340
how can we replicate that,

496
00:28:38,640 --> 00:28:41,160
and the way we're going to replicate here is,

497
00:28:41,160 --> 00:28:43,350
because the virtual machine monitor just get control over it.

498
00:28:44,480 --> 00:28:47,900
And we'll see you know there's going to be an extremely powerful tool

499
00:28:47,930 --> 00:28:52,130
to actually make instruction deterministic,

500
00:28:52,130 --> 00:28:54,680
you know handle external operations, etc etc.

501
00:28:55,620 --> 00:28:56,640
So the basic plan is,

502
00:28:56,640 --> 00:28:59,480
like if an interrupt comes in,

503
00:28:59,510 --> 00:29:01,640
you know where there's an interrupt from the network

504
00:29:01,640 --> 00:29:07,790
or from from the hardware itself, like a timer interrupt,

505
00:29:08,090 --> 00:29:13,310
you know basically the timer interrupt is delivered to the virtual machine monitor,

506
00:29:13,340 --> 00:29:17,510
virtual machine monitor, then in the case of VMFT, does two things,

507
00:29:17,510 --> 00:29:20,360
you know not only delivers it at some point to the application,

508
00:29:20,480 --> 00:29:24,260
it also sends it over a logging channel to a backup computer,

509
00:29:25,130 --> 00:29:28,250
backup computer is constructed in the same way as hardware,

510
00:29:28,580 --> 00:29:32,840
it has virtual machine monitor sitting on top of it,

511
00:29:32,840 --> 00:29:35,690
so there's another copy of VM-FT,

512
00:29:35,870 --> 00:29:38,270
and on top of is a virtual machine,

513
00:29:38,270 --> 00:29:41,570
were identical software running on it like Linux,

514
00:29:41,900 --> 00:29:43,040
same version of Linux,

515
00:29:43,040 --> 00:29:45,200
you know with whatever some set of applications.

516
00:29:47,840 --> 00:29:48,740
Okay?

517
00:29:49,560 --> 00:29:55,470
And so like you know these machines both on networks use the logging channel,

518
00:29:58,180 --> 00:30:03,460
and maybe your client you know talking basically to the hardware,

519
00:30:03,460 --> 00:30:06,430
do the send a packet over the network,

520
00:30:06,700 --> 00:30:10,000
the actual hardware you know receive the packet,

521
00:30:10,480 --> 00:30:14,590
and then that will and deliver it,

522
00:30:14,620 --> 00:30:18,190
you know and the virtual machine monitor just gets control and delivers it,

523
00:30:18,190 --> 00:30:20,230
and hardware delivers to the virtual machine monitor,

524
00:30:20,230 --> 00:30:22,210
virtual machine monitor will pick it up.

525
00:30:22,900 --> 00:30:26,260
And so, if you think about it,

526
00:30:26,260 --> 00:30:32,340
you know this, this package, you know results in, in an interrupt,

527
00:30:32,340 --> 00:30:34,050
that deliver to the virtual machine monitor,

528
00:30:34,110 --> 00:30:37,530
the virtual machine monitor will send that interrupt,

529
00:30:37,620 --> 00:30:38,700
you'll see in a second,

530
00:30:38,700 --> 00:30:40,440
and go forward to the backup,

531
00:30:41,380 --> 00:30:46,360
deliver it, deliver it also to the local virtual machine,

532
00:30:47,120 --> 00:30:49,610
the local virtual machine you know it's just Linux running,

533
00:30:49,610 --> 00:30:50,810
it saw I got an interrupt,

534
00:30:50,840 --> 00:30:52,430
and so it does normal processing,

535
00:30:52,430 --> 00:30:53,900
it always will doing an interrupt,

536
00:30:53,930 --> 00:30:57,290
and so at some point, you know maybe it will generate a response,

537
00:30:57,720 --> 00:31:00,780
and also for example write you know to the network card,

538
00:31:00,810 --> 00:31:03,630
or at least it will think it's writing to the network interface card,

539
00:31:03,840 --> 00:31:06,510
but really what it is, is a virtual network interface card,

540
00:31:06,510 --> 00:31:10,320
that is like emulated by the virtual machine monitor,

541
00:31:10,320 --> 00:31:16,620
so when the writes actually you know a bunch of instructions to this you know virtual card,

542
00:31:16,680 --> 00:31:19,230
really what it is actually writing to the virtual machine monitor,

543
00:31:19,230 --> 00:31:21,090
and the virtual machine monitor seems like you know,

544
00:31:21,090 --> 00:31:24,480
here's a operating system trying to actually send the packet,

545
00:31:25,190 --> 00:31:27,410
and then the virtual machine monitor can

546
00:31:27,410 --> 00:31:29,540
actually send the packet away out of the operating system,

547
00:31:29,540 --> 00:31:31,250
by programming the real hardware,

548
00:31:31,520 --> 00:31:34,310
and then the real hardware, it sends off in response to the client.

549
00:31:36,140 --> 00:31:38,390
Right, that has a normal execution,

550
00:31:38,390 --> 00:31:42,470
for what here's the primary, here's the backup,

551
00:31:44,820 --> 00:31:46,590
and basically the backup of the same thing happens,

552
00:31:46,590 --> 00:31:49,950
you know if the machines started exactly in the same states,

553
00:31:49,950 --> 00:31:52,860
you know they take the interrupt you know at the same time,

554
00:31:52,860 --> 00:31:55,650
and the virtual machine monitor control when to deliver the interrupt,

555
00:31:55,650 --> 00:31:57,390
it can arrange to make sure,

556
00:31:57,390 --> 00:31:59,910
that the interrupt to be delivered exactly at the same time,

557
00:31:59,910 --> 00:32:02,940
exactly the same instruction, that the primary got it.

558
00:32:03,270 --> 00:32:05,760
So it will deliver the interrupt to the,

559
00:32:05,760 --> 00:32:07,560
you know will receive the interrupt from the primary,

560
00:32:07,710 --> 00:32:09,150
may be buffered for a while,

561
00:32:09,150 --> 00:32:13,590
until the backup machine second hits there's a same instruction the primary does,

562
00:32:13,680 --> 00:32:16,020
then delivers the interrupt the Linux,

563
00:32:16,110 --> 00:32:17,580
Linux is a usual way,

564
00:32:17,580 --> 00:32:18,150
it will be,

565
00:32:18,180 --> 00:32:20,910
you know since it's exactly the same state as in the primary,

566
00:32:20,910 --> 00:32:23,250
it will do exactly the same thing as the primary does,

567
00:32:23,400 --> 00:32:24,930
so at some point, you know it will,

568
00:32:25,460 --> 00:32:29,450
you know program virtual network card to actually send a response packet,

569
00:32:29,840 --> 00:32:31,370
you know all that stuff will happen,

570
00:32:31,520 --> 00:32:33,590
and at some points as like you know send a packet,

571
00:32:33,680 --> 00:32:36,680
you know the virtual machine monitor will get control,

572
00:32:36,920 --> 00:32:38,000
it knows its backup

573
00:32:38,000 --> 00:32:39,440
and so it doesn't do anything,

574
00:32:39,440 --> 00:32:41,360
it actually doesn't send the packet on the network,

575
00:32:41,390 --> 00:32:42,320
because it's the backup.

576
00:32:43,170 --> 00:32:46,240
Okay, that's the basic plan,

577
00:32:46,900 --> 00:32:50,650
then there's one more component in this story,

578
00:32:50,650 --> 00:32:51,910
that is important to realize,

579
00:32:51,910 --> 00:32:54,700
which is that there is on the side, on the side,

580
00:32:56,130 --> 00:32:57,420
on the machine network,

581
00:32:58,140 --> 00:32:59,400
there is a storage server,

582
00:33:07,730 --> 00:33:10,310
you can think about this as the hard disk,

583
00:33:10,460 --> 00:33:14,420
for these for these two virtual machines or for,

584
00:33:14,420 --> 00:33:17,900
and so when an application here writes to a file,

585
00:33:17,900 --> 00:33:21,770
really what it turns into is you know the kernel will,

586
00:33:22,040 --> 00:33:27,440
you know that file systems may be mounted on the local Linux operating system,

587
00:33:27,440 --> 00:33:30,260
the Linux operating system sees this is a remote disk,

588
00:33:30,500 --> 00:33:32,060
and will format the packet

589
00:33:32,060 --> 00:33:34,280
and then will send a packet you know to,

590
00:33:34,700 --> 00:33:36,710
you know, let me draw out maybe in a slightly different,

591
00:33:36,710 --> 00:33:40,160
will send a packet to the virtual machine monitor the same place,

592
00:33:40,160 --> 00:33:42,170
and virtual machine monitor like send it off,

593
00:33:42,170 --> 00:33:44,210
the virtual machine monitor you know go off,

594
00:33:44,210 --> 00:33:46,700
and send it over network you know to the storage server,

595
00:33:48,300 --> 00:33:50,400
the storage server will respond at some point,

596
00:33:50,400 --> 00:33:52,650
in some ways this communication looks identical,

597
00:33:52,650 --> 00:33:55,410
as if there's a client sitting on the other side of the network,

598
00:33:55,980 --> 00:33:56,970
the only difference being that,

599
00:33:56,970 --> 00:34:03,150
in the storage server case, the Linux starts the communication,

600
00:34:03,150 --> 00:34:05,280
while in other cases, the client starts the communication,

601
00:34:06,280 --> 00:34:09,160
green array represent communication to the storage server,

602
00:34:09,160 --> 00:34:10,750
so a network packets being sent

603
00:34:10,750 --> 00:34:14,830
from through Linux, through virtual machine monitor to storage server.

604
00:34:15,660 --> 00:34:19,530
And so we write by an application to file,

605
00:34:19,530 --> 00:34:21,150
basically results in these messages,

606
00:34:21,150 --> 00:34:23,820
and then it will whatever update any states,

607
00:34:23,820 --> 00:34:27,990
you know persistent state, that you know on the on the storage server.

608
00:34:30,040 --> 00:34:31,300
You know as we saw in the paper,

609
00:34:31,360 --> 00:34:35,020
the storage server plays an additional role,

610
00:34:35,050 --> 00:34:40,280
on top of, on top of basically being storate server,

611
00:34:40,310 --> 00:34:44,810
namely, there's sort of a special flag that sits on the side,

612
00:34:45,170 --> 00:34:47,240
or there's a block in storage server,

613
00:34:48,030 --> 00:34:54,300
that's being used to arbitrate who becomes the primary after a failure.

614
00:34:55,190 --> 00:34:59,180
So, so this all comes down to,

615
00:34:59,180 --> 00:35:01,250
this is the part of the failure over plan,

616
00:35:01,640 --> 00:35:06,020
so let's see you know the logging channel breaks

617
00:35:06,020 --> 00:35:11,030
or in the way you know this manifest to the virtual machine monitor is that,

618
00:35:11,120 --> 00:35:14,390
it sends periodically packets you know over this logging channel,

619
00:35:14,540 --> 00:35:19,960
and it doesn't get any responses from the other side,

620
00:35:20,020 --> 00:35:23,380
then assumes that the other side, there's a problem,

621
00:35:23,500 --> 00:35:25,120
and of course it can't decide,

622
00:35:25,150 --> 00:35:27,430
whether you know just a network is not working,

623
00:35:27,460 --> 00:35:31,930
or whether actually the virtual machine monitor you know the computers really crashed.

624
00:35:32,440 --> 00:35:33,340
If it's really crashed,

625
00:35:33,340 --> 00:35:35,230
of course, it should you know take over,

626
00:35:35,410 --> 00:35:36,670
and if it's really not crash,

627
00:35:36,670 --> 00:35:38,740
then you know we have to arbitrate in some way,

628
00:35:38,740 --> 00:35:41,050
will make sure that only one of them actually proceeds.

629
00:35:41,540 --> 00:35:43,190
So let's say the network partitions,

630
00:35:44,520 --> 00:35:47,190
and so this is a harder case when the network partitions,

631
00:35:47,250 --> 00:35:49,470
instead of like one of them two crashes,

632
00:35:49,680 --> 00:35:51,510
so here network partitions,

633
00:35:52,010 --> 00:35:55,880
but you know notice that the two could still communicate,

634
00:35:55,880 --> 00:35:58,640
both the primary and backup can communicate to the storage server.

635
00:35:59,610 --> 00:36:01,500
And so in this particular case,

636
00:36:01,530 --> 00:36:02,460
what will happen is,

637
00:36:02,460 --> 00:36:03,360
they will notice,

638
00:36:03,360 --> 00:36:04,830
you know both sides will notice,

639
00:36:04,830 --> 00:36:06,180
the primary and backup will notice,

640
00:36:06,510 --> 00:36:07,650
there's some problems,

641
00:36:07,650 --> 00:36:10,650
I can't talk to primary anymore [] [],

642
00:36:11,010 --> 00:36:12,240
and so at some point to say,

643
00:36:12,240 --> 00:36:14,520
well the other guy most probably could be dead,

644
00:36:14,520 --> 00:36:16,860
and I want to promote myself to primary,

645
00:36:16,860 --> 00:36:19,170
so the backup is like I want to promote myself to primary,

646
00:36:19,380 --> 00:36:24,900
or primary says like well I just want to really continue serving client request

647
00:36:24,900 --> 00:36:27,300
and I just want to ignore the backup for now.

648
00:36:27,970 --> 00:36:31,210
So basically says this is what they call they want to goes live,

649
00:36:32,910 --> 00:36:35,190
basically we go back into single mode

650
00:36:35,220 --> 00:36:37,440
and we want to and we want one primary.

651
00:36:38,440 --> 00:36:40,510
And so the way this happens is that,

652
00:36:40,510 --> 00:36:43,000
both of them you know send try to read,

653
00:36:43,060 --> 00:36:45,820
they call test-and-set operation.

654
00:36:49,340 --> 00:36:50,930
I'll talk a little bit about it in more detail,

655
00:36:50,930 --> 00:36:53,330
but basically both reach out to the storage server,

656
00:36:53,360 --> 00:36:56,360
and try to write a flag saying set to 1,

657
00:36:57,340 --> 00:37:00,730
and if the flag was already set to set to 1,

658
00:37:00,850 --> 00:37:02,140
then it end,

659
00:37:02,140 --> 00:37:04,540
like the the other guy 1 was earlier,

660
00:37:04,720 --> 00:37:06,280
actually goes from 0 to 1.

661
00:37:07,040 --> 00:37:09,080
They both try to do this atomically,

662
00:37:09,290 --> 00:37:10,700
one is gonna go first,

663
00:37:10,760 --> 00:37:13,160
you know that will succeed setting to 1,

664
00:37:13,160 --> 00:37:15,440
and we could return to old value 0,

665
00:37:15,530 --> 00:37:19,550
so it knows that nobody else succeeded actually in writing to flat to 1 yet,

666
00:37:19,610 --> 00:37:22,430
and therefore I should become the primary to keep it running.

667
00:37:23,370 --> 00:37:25,830
And the second guy, you know what's the primary/backup,

668
00:37:25,830 --> 00:37:27,810
you know that comes in second,

669
00:37:27,930 --> 00:37:28,530
you know we'll see,

670
00:37:28,530 --> 00:37:29,910
we will try to set the flag to 1,

671
00:37:29,910 --> 00:37:30,990
is already set to 1,

672
00:37:30,990 --> 00:37:32,190
the return value would be 1,

673
00:37:32,190 --> 00:37:33,450
because that's the old value,

674
00:37:33,660 --> 00:37:36,330
by the time you know did test-and-set operation,

675
00:37:36,510 --> 00:37:37,740
and therefore it will decide,

676
00:37:37,740 --> 00:37:38,910
well, I'm going to give up,

677
00:37:38,940 --> 00:37:42,930
because you know there's already somebody else who took over for me,

678
00:37:43,840 --> 00:37:47,530
and basically you know as the paper calls, you know they terminate itself.

679
00:37:49,990 --> 00:37:50,560
Okay?

680
00:37:51,080 --> 00:37:54,110
So that's sort of the high-level operation,

681
00:37:54,170 --> 00:37:58,070
high-level operation failure.

682
00:37:58,160 --> 00:38:00,890
There's a quick question in chat is a good question,

683
00:38:01,190 --> 00:38:02,750
and when is the flag reset to 0.

684
00:38:03,490 --> 00:38:06,130
Well, there's sort of basically a whole separate story,

685
00:38:06,160 --> 00:38:08,860
that I'm talking about yet, you know see it get through,

686
00:38:09,100 --> 00:38:11,830
is that once you know the primary runs,

687
00:38:11,860 --> 00:38:14,740
on when we have one server running now,

688
00:38:14,980 --> 00:38:17,320
would like to make a second backup,

689
00:38:17,350 --> 00:38:20,560
you know and so get into position that we're basically having backup again,

690
00:38:20,560 --> 00:38:21,940
we have to do what's called repair,

691
00:38:21,970 --> 00:38:23,200
because we don't do repair,

692
00:38:23,320 --> 00:38:25,630
then you know the start with two computers,

693
00:38:25,630 --> 00:38:27,220
one fails, then we have one computer,

694
00:38:27,250 --> 00:38:28,210
and a little bit later,

695
00:38:28,210 --> 00:38:30,190
one computer may fail, then we have no computers anymore.

696
00:38:30,720 --> 00:38:31,770
So it has to be the case,

697
00:38:31,770 --> 00:38:33,240
there has to be a repair plan,

698
00:38:33,690 --> 00:38:37,470
and in VMFT, repair plan is executed manually,

699
00:38:37,620 --> 00:38:44,010
if somebody you know monitors, where monitor software sort of noticed this,

700
00:38:44,010 --> 00:38:46,320
and basically creates a new replica,

701
00:38:46,500 --> 00:38:50,610
or based on the VM image of the the first one,

702
00:38:50,880 --> 00:38:53,340
ensures that in sync,

703
00:38:53,460 --> 00:38:56,940
and then you know it reset that flag,

704
00:38:56,940 --> 00:39:00,120
and you know in log log starts again,

705
00:39:00,120 --> 00:39:01,560
and then the flag is reset,

706
00:39:01,560 --> 00:39:04,230
so once that second primary completely backup,

707
00:39:04,530 --> 00:39:09,060
yeah and following the protocol, then the flag reset.

708
00:39:09,690 --> 00:39:10,200
Okay?

709
00:39:13,590 --> 00:39:15,120
Okay.

710
00:39:17,550 --> 00:39:18,750
Okay, great, there's a great question,

711
00:39:18,750 --> 00:39:21,450
like why, you know may be logging channel broke,

712
00:39:21,450 --> 00:39:27,930
that maybe the the the the channel to the server broke too,

713
00:39:28,110 --> 00:39:31,770
and and so you know we're not gonna get a response,

714
00:39:32,160 --> 00:39:34,530
and that basically that point the system just stops,

715
00:39:34,560 --> 00:39:37,170
if you will, until something repairs,

716
00:39:37,530 --> 00:39:38,820
because nothing can be done,

717
00:39:38,850 --> 00:39:40,020
so at that point from then on,

718
00:39:40,020 --> 00:39:41,850
no clients request actually process,

719
00:39:42,180 --> 00:39:44,910
because we don't know what state we are,

720
00:39:46,300 --> 00:39:49,810
and maybe at some point network link will get repaired,

721
00:39:49,810 --> 00:39:52,270
and that point things get started moving forward again,

722
00:39:52,660 --> 00:39:54,340
so this is a disaster case,

723
00:39:54,370 --> 00:39:56,740
where you know disaster case is,

724
00:39:56,740 --> 00:39:59,380
actually the primary backup or both actually up and running,

725
00:39:59,380 --> 00:40:00,730
but all the network cables broken.

726
00:40:01,230 --> 00:40:03,330
And which is sort of similar basically to the case,

727
00:40:03,330 --> 00:40:05,400
where both the primary backup failed at the same time.

728
00:40:09,090 --> 00:40:09,420
Okay.

729
00:40:09,420 --> 00:40:12,810
Question, could you explain again real quick,

730
00:40:12,810 --> 00:40:15,960
when the client is reading from the storage server.

731
00:40:16,540 --> 00:40:18,520
The client never read really from the storage server,

732
00:40:18,550 --> 00:40:21,550
that's the Linux that might,

733
00:40:21,550 --> 00:40:22,990
or the application running on top of Linux

734
00:40:22,990 --> 00:40:24,430
might be running from the storage server,

735
00:40:24,460 --> 00:40:25,450
and that's the one case.

736
00:40:25,450 --> 00:40:26,320
And the second case,

737
00:40:26,530 --> 00:40:28,780
the VM-FT might be running from the storage server

738
00:40:28,780 --> 00:40:31,030
to read that flag or test-and-set flag.

739
00:40:31,690 --> 00:40:33,160
So that like green arrow at the bottom

740
00:40:33,160 --> 00:40:37,930
from the storage server to C, is a.

741
00:40:38,140 --> 00:40:41,980
I'm sorry, that green, that's a bad green arrow,

742
00:40:41,980 --> 00:40:43,330
that should have gone all the way.

743
00:40:43,690 --> 00:40:44,800
Okay, thank you.

744
00:40:45,040 --> 00:40:46,180
And just going over the network

745
00:40:46,180 --> 00:40:47,320
and not intended to go to C,

746
00:40:47,320 --> 00:40:48,640
it was intended to go over the network.

747
00:40:49,820 --> 00:40:53,000
Thanks for clarifying that, and realize that.

748
00:40:53,180 --> 00:40:54,830
Okay, so.

749
00:40:56,950 --> 00:40:58,480
So what I'd like, so I want to,

750
00:40:58,510 --> 00:41:02,350
maybe if we take a quick break at this point,

751
00:41:02,530 --> 00:41:03,730
or do a breakout room,

752
00:41:03,880 --> 00:41:06,370
in particular, would like you to do,

753
00:41:06,370 --> 00:41:08,320
and talk a little bit about the homework question,

754
00:41:08,620 --> 00:41:12,610
which we sort of covered at this instance,

755
00:41:12,730 --> 00:41:14,440
but I want you to think about it,

756
00:41:15,990 --> 00:41:17,640
understand or argue with each other,

757
00:41:17,640 --> 00:41:19,050
and you know convince yourself,

758
00:41:19,050 --> 00:41:24,480
that the scheme actually provides avoids this sort of [],

759
00:41:24,480 --> 00:41:25,860
you know split-brain syndrome,

760
00:41:25,860 --> 00:41:28,320
in the sense, that there's never going to be two primaries.

761
00:41:28,760 --> 00:41:31,580
The second thing you know maybe to debate is,

762
00:41:31,700 --> 00:41:32,990
this a reasonable design,

763
00:41:32,990 --> 00:41:34,700
because it looks like what we've done is,

764
00:41:34,700 --> 00:41:38,240
we put all the real hard part of fault tolerance into the storage server,

765
00:41:38,300 --> 00:41:39,350
and it's not really the case,

766
00:41:39,350 --> 00:41:40,430
why is that not the case.

767
00:41:40,820 --> 00:41:44,420
So that seems like two things that I'd like you to discuss,

768
00:41:44,540 --> 00:41:45,980
in these breakout rooms.

769
00:41:46,010 --> 00:41:47,420
So I'm going to stop the sharing.

770
00:41:50,530 --> 00:41:55,980
And I'm gonna, participants,

771
00:41:56,040 --> 00:41:58,170
I'm gonna make Lily host,

772
00:41:59,210 --> 00:42:01,730
so that you can set up the breakout rooms,

773
00:42:03,490 --> 00:42:05,860
and you know enjoy talk to each other.

774
00:42:08,180 --> 00:42:09,890
Lily, you got this under control.

775
00:46:19,440 --> 00:46:22,650
Testing to see if I can join a different room this time,

776
00:46:28,000 --> 00:46:29,080
it's not looking good though.

777
00:47:04,190 --> 00:47:06,140
Well, yes, I'm stuck here.

778
00:49:54,720 --> 00:49:55,740
The screen again,

779
00:50:01,020 --> 00:50:02,430
can everyone see my screen?

780
00:50:06,380 --> 00:50:06,860
Yes.

781
00:50:07,420 --> 00:50:09,070
Okay, good.

782
00:50:09,640 --> 00:50:11,260
So I hope you had a good discussion,

783
00:50:11,290 --> 00:50:16,990
and hopefully get more new students in the class than you knew before.

784
00:50:17,580 --> 00:50:19,530
And let's sort of proceed,

785
00:50:19,800 --> 00:50:27,760
talking a little bit about the the design of of the VMFT,

786
00:50:27,760 --> 00:50:29,980
and there's like summarize quickly, you know.

787
00:50:30,310 --> 00:50:34,000
Sorry could you repeat like when the flag is reset to 0,

788
00:50:34,000 --> 00:50:36,580
I feel like some of us might have missed explanation.

789
00:50:36,610 --> 00:50:39,950
Okay, okay, so okay, good good good.

790
00:50:39,950 --> 00:50:40,730
Okay, so let me,

791
00:50:41,240 --> 00:50:43,850
okay, so here let's draw the picture again,

792
00:50:43,850 --> 00:50:45,080
it's sort of similar way,

793
00:50:45,080 --> 00:50:48,350
here's our primary with the VM, everything in it,

794
00:50:48,350 --> 00:50:51,030
here's the backup, with everything in it,

795
00:50:51,060 --> 00:50:53,310
you know and just logging channel in between,

796
00:50:53,550 --> 00:50:55,590
you know connected to a storage server.

797
00:50:55,890 --> 00:50:57,810
And you know one thing to think about this,

798
00:50:57,810 --> 00:50:59,880
that the storage servers to playing two roles,

799
00:50:59,910 --> 00:51:02,200
so let's separate the two roles,

800
00:51:02,230 --> 00:51:04,570
one is you knwo to storage you know for,

801
00:51:04,630 --> 00:51:07,600
disk basically for you know the primary and backup,

802
00:51:07,600 --> 00:51:09,100
when we could just split that,

803
00:51:09,130 --> 00:51:11,500
and attach the disk to the primary backup,

804
00:51:11,950 --> 00:51:16,120
then where basically have the role here is really the arbitration server,

805
00:51:20,440 --> 00:51:22,090
and it has a flag,

806
00:51:24,010 --> 00:51:26,050
and the flag was initially 0, right.

807
00:51:26,050 --> 00:51:27,310
And so now let's say,

808
00:51:27,310 --> 00:51:29,860
there's a partition to primary backup

809
00:51:29,860 --> 00:51:33,310
can actually not talk to each other anymore,

810
00:51:33,310 --> 00:51:34,870
so they're going to talk to arbitration server,

811
00:51:34,870 --> 00:51:39,700
basically to try to promote themselves to the single to go live,

812
00:51:39,700 --> 00:51:42,430
and sort of do single server, server the client request.

813
00:51:43,470 --> 00:51:46,290
So they both send the packet to the test-and-set operation,

814
00:51:46,530 --> 00:51:47,850
one get 0 back,

815
00:51:47,850 --> 00:51:48,960
the other get 1 back,

816
00:51:48,960 --> 00:51:52,110
one gets 1 back, knows that it was actually the second who tried,

817
00:51:52,440 --> 00:51:56,550
and then, and so the first one will succeed, and will go alive,

818
00:51:56,550 --> 00:51:58,050
so let's say this guy goes live,

819
00:51:58,770 --> 00:52:00,630
and this guy just disappears,

820
00:52:01,210 --> 00:52:05,560
the virtual machine is terminate itself and is done,

821
00:52:06,890 --> 00:52:08,870
and so now the flag is set 1.

822
00:52:12,020 --> 00:52:13,010
And of course now at this point,

823
00:52:13,010 --> 00:52:14,600
there's no arbitration necessary more,

824
00:52:14,600 --> 00:52:16,340
because there's no secondary replica,

825
00:52:16,370 --> 00:52:17,570
there's no backup at all,

826
00:52:17,930 --> 00:52:20,360
so really the question is like what happens next,

827
00:52:20,660 --> 00:52:22,010
and in terms of repair,

828
00:52:22,010 --> 00:52:22,910
that has to be the case,

829
00:52:22,910 --> 00:52:26,120
that the second backup, new backup is brought up to alive, correct,

830
00:52:26,120 --> 00:52:29,660
and section 3.1 the paper talks about this in quite a bit of detail,

831
00:52:30,230 --> 00:52:32,360
and the way it works is that,

832
00:52:32,360 --> 00:52:34,130
you know on the user interface,

833
00:52:34,130 --> 00:52:36,380
you know to the system, you know VMware motion,

834
00:52:36,620 --> 00:52:37,880
you're basically saying like,

835
00:52:37,880 --> 00:52:39,620
hey I want to clone this primary,

836
00:52:39,680 --> 00:52:44,360
and the clone operation basically,

837
00:52:45,620 --> 00:52:48,230
well, basically stop processing processing client,

838
00:52:48,890 --> 00:52:51,860
during cloning, the primary won't actually worried about,

839
00:52:51,860 --> 00:52:53,120
the one system still running,

840
00:52:53,270 --> 00:52:55,130
one actually serve any client request,

841
00:52:55,280 --> 00:53:01,340
the the VMotion thing makes them VM clone

842
00:53:01,430 --> 00:53:05,420
and basically copies the state of this VM up to tho backup,

843
00:53:05,690 --> 00:53:09,410
so here we have an identical copy of the backup, of the primary,

844
00:53:09,410 --> 00:53:10,280
that becomes the backup,

845
00:53:10,810 --> 00:53:13,480
and so the state of the virtual machine is identical.

846
00:53:14,040 --> 00:53:16,950
Once you know the sort of cloning operations happened,

847
00:53:17,340 --> 00:53:18,630
then it's free,

848
00:53:18,630 --> 00:53:23,010
user user interface is free to set this guy back to 0 too,

849
00:53:24,480 --> 00:53:26,400
client requests are still not being processed,

850
00:53:26,760 --> 00:53:28,380
when that has actually happened,

851
00:53:28,380 --> 00:53:30,420
then this system can go sort of live again,

852
00:53:30,420 --> 00:53:33,690
but now with two machines, with a primary and a backup,

853
00:53:33,810 --> 00:53:35,790
and the client requests are being processed,

854
00:53:35,790 --> 00:53:37,740
they are sent over the channel and etc etc,

855
00:53:37,770 --> 00:53:38,970
so we're back in business.

856
00:53:40,120 --> 00:53:41,170
So answer the question?

857
00:53:47,960 --> 00:53:48,590
I hope it does.

858
00:53:49,490 --> 00:53:52,220
If not, I'm happy to revisit this actually,

859
00:53:52,220 --> 00:53:54,590
and maybe at the end of the lecture is still confusing.

860
00:53:55,560 --> 00:53:56,370
Okay.

861
00:53:56,670 --> 00:53:57,720
Okay good.

862
00:53:58,200 --> 00:54:00,000
Okay, I want to go back now

863
00:54:00,000 --> 00:54:03,390
to sort of like the overall architecture of this system,

864
00:54:03,630 --> 00:54:06,030
now I want to dive in a little bit more,

865
00:54:06,030 --> 00:54:09,030
and talk you know we decided to think,

866
00:54:09,060 --> 00:54:13,080
you know this arbitration scheme allows you to at least point to split-brain syndrome,

867
00:54:13,380 --> 00:54:16,020
but you know this sort of larger issue,

868
00:54:16,020 --> 00:54:17,940
that if you know two machines are running,

869
00:54:18,590 --> 00:54:20,270
you know, our goal is going to be,

870
00:54:22,870 --> 00:54:24,730
basically behave like a single machine.

871
00:54:29,950 --> 00:54:31,210
So from the client perspective,

872
00:54:31,210 --> 00:54:34,150
it should not be possible to really discern,

873
00:54:34,180 --> 00:54:37,330
or at least in a sort of demonstrate a bad way,

874
00:54:37,330 --> 00:54:40,270
that we actually have two machines, right.

875
00:54:40,630 --> 00:54:42,670
And so there's this big step back,

876
00:54:42,880 --> 00:54:44,950
if we think at a very high level,

877
00:54:44,950 --> 00:54:46,540
you know we have here primary,

878
00:54:46,720 --> 00:54:51,910
and it has you know like machine registers, the virtual machine registers,

879
00:54:51,910 --> 00:54:52,720
there's memory,

880
00:54:53,020 --> 00:54:56,170
and our basic plan is to sort of forward

881
00:54:56,170 --> 00:54:59,380
to make sure that basically executes exactly the same instructions.

882
00:55:02,980 --> 00:55:05,470
Boom, boom, boom, here's our own,

883
00:55:05,470 --> 00:55:08,360
here's backup, here's primary,

884
00:55:08,690 --> 00:55:14,240
and you know basically you know when the, when the primary,

885
00:55:14,240 --> 00:55:16,070
so we started to map in the same state,

886
00:55:16,070 --> 00:55:17,660
and they start executing instructions,

887
00:55:17,900 --> 00:55:19,700
like maybe the first instruction is inc,

888
00:55:20,210 --> 00:55:21,620
second instruction is dec,

889
00:55:22,010 --> 00:55:24,080
you know third instruction is branch,

890
00:55:24,970 --> 00:55:27,940
and if they start all in the same state, correct,

891
00:55:27,940 --> 00:55:29,560
then at the third instruction is branch,

892
00:55:29,560 --> 00:55:31,120
that will branch into the same direction,

893
00:55:31,420 --> 00:55:33,730
and so maybe the branch to some instruction,

894
00:55:33,760 --> 00:55:38,500
and then we know whatever the next instruction is divide etc, etc.

895
00:55:39,600 --> 00:55:41,760
You know all these instructions are deterministic,

896
00:55:41,760 --> 00:55:43,560
so that's pretty straightforward, right,

897
00:55:43,560 --> 00:55:46,440
like if you know we both start at the same state,

898
00:55:46,440 --> 00:55:50,910
they execute exactly the same set of instructions in the same order,

899
00:55:51,060 --> 00:55:53,610
then we're going to end up in state S',

900
00:55:54,080 --> 00:55:58,040
and those two states have to be identical, right.

901
00:55:58,800 --> 00:56:04,110
Now the thing that is sort of a challenge in design,

902
00:56:04,110 --> 00:56:06,360
where any sort of replication scheme is,

903
00:56:06,420 --> 00:56:08,790
there might be sources of divergence,

904
00:56:08,790 --> 00:56:13,890
you know so our goal is to actually get them exactly the same state S',

905
00:56:13,950 --> 00:56:16,770
but you know there source or sources of divergence.

906
00:56:22,760 --> 00:56:25,250
And it's pretty obvious, correct, what those are,

907
00:56:25,280 --> 00:56:28,760
for example instructions that are non-deterministic our problems,

908
00:56:35,300 --> 00:56:38,780
and so what are one example of non-deterministic instruction?

909
00:56:42,410 --> 00:56:43,640
Getting the time.

910
00:56:44,200 --> 00:56:46,270
Yeah, getting the time, why is it non-deterministic?

911
00:56:47,360 --> 00:56:48,500
Because it didn't,

912
00:56:50,280 --> 00:56:59,250
and the machines are not like the backup is not executing.

913
00:57:00,050 --> 00:57:02,360
Yeah the issue here correctly is that,

914
00:57:02,360 --> 00:57:05,120
if there's the primary and the backup,

915
00:57:05,120 --> 00:57:08,150
you know at some point will execute this you know get time of day instruction,

916
00:57:08,150 --> 00:57:08,750
if you will,

917
00:57:08,960 --> 00:57:11,480
and they might not execute it exactly at the same time,

918
00:57:11,480 --> 00:57:16,070
so the values returned by the instruction is going to be different, right,

919
00:57:16,070 --> 00:57:22,460
so that's a source of, the potential source of divergence,

920
00:57:22,460 --> 00:57:23,720
that we need to control.

921
00:57:24,240 --> 00:57:24,630
In fact,

922
00:57:24,630 --> 00:57:28,980
we basically have to turn every non-deterministic instruction into a deterministic instruction,

923
00:57:29,040 --> 00:57:31,680
we'll see in a second and how, how could that be done.

924
00:57:32,800 --> 00:57:36,420
Similarly, inputs, packet inputs,

925
00:57:36,420 --> 00:57:38,370
like when packet the arrives over the network,

926
00:57:38,610 --> 00:57:39,720
you know the primary,

927
00:57:40,050 --> 00:57:42,060
you know we got to make sure,

928
00:57:42,060 --> 00:57:45,840
that you know the that packets executed or processed,

929
00:57:46,550 --> 00:57:50,030
the interrupt goes along with that packet is exactly delivered

930
00:57:50,030 --> 00:57:52,700
exactly the same point in the instruction stream, right.

931
00:57:52,700 --> 00:57:55,370
So we go back to our previous paper, at previous page,

932
00:57:55,550 --> 00:57:58,280
and like the backup is also executing these instructions,

933
00:57:59,140 --> 00:58:01,060
and dec, blah blah blah,

934
00:58:01,060 --> 00:58:02,410
exactly the same order,

935
00:58:02,440 --> 00:58:04,150
so if the primary for example,

936
00:58:04,330 --> 00:58:07,900
you know we get the interrupt is delivered between instruction 1 2,

937
00:58:08,020 --> 00:58:09,040
we've got to make sure that,

938
00:58:09,040 --> 00:58:11,500
the backup it also delivered between 1 and 2,

939
00:58:12,040 --> 00:58:15,790
because it really delivered exactly the same point in the instruction stream,

940
00:58:15,850 --> 00:58:18,490
the interrupt handler will run and will do this,

941
00:58:18,490 --> 00:58:20,500
they both execute the same instructions again.

942
00:58:22,030 --> 00:58:25,990
However, if you know for example the backup you know would process

943
00:58:26,020 --> 00:58:29,410
this timer interrupt or is packet arrival interrupt

944
00:58:29,410 --> 00:58:31,390
a little bit later in a different side of stream,

945
00:58:31,420 --> 00:58:33,370
then the state of the system might be different,

946
00:58:33,490 --> 00:58:36,280
and therefore the result of you know computation might be different,

947
00:58:36,520 --> 00:58:37,510
so we can't have that,

948
00:58:37,510 --> 00:58:38,860
so it has to be the case,

949
00:58:38,950 --> 00:58:44,500
that interrupts whatever packets and timers all get delivered exactly at the same time,

950
00:58:45,140 --> 00:58:46,910
for the same input in the instruction stream,

951
00:58:47,240 --> 00:58:51,940
so input packets or timer interrupts,

952
00:58:56,380 --> 00:58:59,230
need to basically be delivered at the same point in the instruction stream.

953
00:59:02,940 --> 00:59:05,070
And so those are sources of divergence,

954
00:59:05,190 --> 00:59:06,330
that we need to handle,

955
00:59:06,330 --> 00:59:08,160
any other source of divergence that?

956
00:59:09,440 --> 00:59:12,590
So I think, like I think it was mentioned in the paper,

957
00:59:12,590 --> 00:59:15,080
that concurrency also can produce non-determinism,

958
00:59:15,350 --> 00:59:17,150
but from my understanding here,

959
00:59:17,150 --> 00:59:19,520
since the hypervisor actually controls the interrupts,

960
00:59:19,730 --> 00:59:21,530
and since we have a unique processor,

961
00:59:21,770 --> 00:59:26,600
wouldn't the thread switch be conducted to the hypervisor by by interrupts,

962
00:59:26,600 --> 00:59:27,950
so if we control the interrupts,

963
00:59:27,950 --> 00:59:31,790
and we can transmit them exactly at the right location,

964
00:59:32,030 --> 00:59:35,000
wouldn't we also control the non-determinism from concurrency.

965
00:59:35,450 --> 00:59:37,280
Yeah, so I think there's a great observation,

966
00:59:37,280 --> 00:59:37,760
so let me,

967
00:59:37,760 --> 00:59:39,770
it's a potential diverge,

968
00:59:39,800 --> 00:59:40,460
okay, so first of all,

969
00:59:40,460 --> 00:59:44,780
let's first agree that it's a potential source of divergence,

970
00:59:44,780 --> 00:59:46,310
so multicore.

971
00:59:49,120 --> 00:59:49,810
And let's see,

972
00:59:49,810 --> 00:59:53,770
you know basically the way the solution in this particular paper

973
00:59:53,770 --> 00:59:55,060
to avoid this problem is to say,

974
00:59:55,060 --> 00:59:59,780
well, there's disallow, we're not allow to have that,

975
01:00:00,020 --> 01:00:02,000
and so just only uniq processor,

976
01:00:02,180 --> 01:00:03,800
let's say we had multi-core,

977
01:00:04,160 --> 01:00:07,460
and you know what just to make sure that we understand what the issue is,

978
01:00:07,640 --> 01:00:08,720
the issue here is correct,

979
01:00:08,720 --> 01:00:11,450
we have two threads running on the same processor,

980
01:00:12,040 --> 01:00:13,510
sort of on different cores,

981
01:00:13,930 --> 01:00:16,690
and they arranged for example to grab grab a lock,

982
01:00:17,630 --> 01:00:19,040
and one of them is going to win,

983
01:00:19,370 --> 01:00:21,680
and so that's the thread that's going to run next,

984
01:00:21,710 --> 01:00:23,780
and the other one is going to be stopped for a little while,

985
01:00:24,300 --> 01:00:26,850
if we want to do this replicated state machine approach at the backup,

986
01:00:26,850 --> 01:00:28,860
the same thing would have to happen, right,

987
01:00:28,860 --> 01:00:33,030
where if the two threads run, you know race for that lock at the same time,

988
01:00:33,180 --> 01:00:36,330
then we got to be arrange that whatever winner on the primary,

989
01:00:36,330 --> 01:00:37,530
also the winner on the backup.

990
01:00:38,310 --> 01:00:40,860
And so that requires a whole bunch of machinery,

991
01:00:40,890 --> 01:00:44,220
that you know additional machinery complexities,

992
01:00:44,220 --> 01:00:46,440
that you know the paper clearly didn't want to address

993
01:00:46,440 --> 01:00:47,610
or didn't know how to address,

994
01:00:47,910 --> 01:00:48,990
and basically just said, like,

995
01:00:48,990 --> 01:00:52,230
okay, we're just gonna exclude that possibility of divergence,

996
01:00:52,230 --> 01:00:55,050
but just declaring that the processor uni-processor.

997
01:00:55,660 --> 01:00:58,300
And so then thread switching and all that kind of stuff doesn't matter anymore,

998
01:00:58,300 --> 01:01:01,570
there's always one you know computation running on the computer, on the processor,

999
01:01:01,780 --> 01:01:03,220
and it will switch,

1000
01:01:03,250 --> 01:01:05,230
if the primary switches to a different thread,

1001
01:01:05,290 --> 01:01:08,020
the backup switch also to the same different thread,

1002
01:01:08,020 --> 01:01:09,280
because it's a single [instruction],

1003
01:01:09,850 --> 01:01:12,400
and they get their external inputs exactly at the same time.

1004
01:01:15,640 --> 01:01:16,270
That makes sense?

1005
01:01:17,760 --> 01:01:19,170
So in some ways a little bit lame,

1006
01:01:19,170 --> 01:01:20,700
they just give up on multi-core.

1007
01:01:21,980 --> 01:01:24,440
And as I mentioned later systems,

1008
01:01:24,590 --> 01:01:29,240
in the more recent systems of this product, do handle multi-core.

1009
01:01:29,780 --> 01:01:33,200
And you know and yeah I want to talk to,

1010
01:01:33,200 --> 01:01:35,540
I don't actually understand exactly how they do it,

1011
01:01:35,540 --> 01:01:38,060
potential difference potential difference schemes,

1012
01:01:38,060 --> 01:01:39,140
that you could think of doing,

1013
01:01:39,140 --> 01:01:42,770
people have gone multi-core replay,

1014
01:01:42,770 --> 01:01:44,720
which I really want the thing that is necessary,

1015
01:01:44,810 --> 01:01:46,520
so, but I don't really know exactly,

1016
01:01:46,520 --> 01:01:48,110
I'm not gonna talk about that at all,

1017
01:01:48,230 --> 01:01:51,140
I'm just gonna talk about that focus on the first three items,

1018
01:01:51,440 --> 01:01:54,020
and see how they handle it in this case.

1019
01:01:58,130 --> 01:02:00,150
Okay, any questions?

1020
01:02:02,760 --> 01:02:04,170
Oh, sorry, just make sure,

1021
01:02:04,200 --> 01:02:11,430
it only transmits the instructions that the the application makes, right,

1022
01:02:11,430 --> 01:02:16,330
it doesn't transmit the instructions that Linux makes.

1023
01:02:17,010 --> 01:02:18,180
Yeah, exactly,

1024
01:02:18,240 --> 01:02:20,790
so here's interesting thing we'll see in a second,

1025
01:02:21,000 --> 01:02:24,000
but let me make it more clear right away,

1026
01:02:24,210 --> 01:02:27,800
the, in fact, these instructions inc dec branch

1027
01:02:27,800 --> 01:02:30,320
are not sent to the primary backup at all,

1028
01:02:30,320 --> 01:02:31,880
they basically have their own copy, right,

1029
01:02:31,880 --> 01:02:34,430
and we're just starting them at the same point in the program,

1030
01:02:34,430 --> 01:02:37,220
and so therefore they run exactly the sort of lockstep,

1031
01:02:37,220 --> 01:02:39,590
almost there's [no] one running lockstep,

1032
01:02:39,620 --> 01:02:41,060
but they execute them in the same order,

1033
01:02:41,900 --> 01:02:43,640
only something special has to happen

1034
01:02:43,640 --> 01:02:46,400
at these points of diversion possible divergence,

1035
01:02:47,140 --> 01:02:49,480
and you know the assumption that sort of paper makes,

1036
01:02:49,480 --> 01:02:51,280
the most instructions are deterministic,

1037
01:02:51,280 --> 01:02:52,450
so we don't really have to do anything,

1038
01:02:52,840 --> 01:02:55,900
it's only the instructions were things that could potentially go wrong,

1039
01:02:55,900 --> 01:02:56,740
we have to do something.

1040
01:02:56,740 --> 01:02:59,980
And so one of those sources where something could go wrong is interrupts.

1041
01:03:01,590 --> 01:03:03,210
So let's talk a little bit about interrupts.

1042
01:03:10,880 --> 01:03:14,450
And so here basically the virtual machine sort comes to

1043
01:03:14,450 --> 01:03:18,390
rescue and really helps solve this problem,

1044
01:03:18,390 --> 01:03:21,390
so let's say here we have our hypervisor,

1045
01:03:22,800 --> 01:03:25,380
and interrupt happens,

1046
01:03:25,530 --> 01:03:27,900
that the interrupt will show up at the hypervisor,

1047
01:03:28,860 --> 01:03:31,020
and the hypervisor knows exactly at,

1048
01:03:31,020 --> 01:03:34,080
what instruction the application was

1049
01:03:34,080 --> 01:03:35,790
or where the VM was at this level,

1050
01:03:36,120 --> 01:03:38,340
so here Linux running inside of this VM,

1051
01:03:38,580 --> 01:03:39,990
the interrupt happens,

1052
01:03:40,110 --> 01:03:46,470
of course you know the the the hypervisor already has taken over control,

1053
01:03:46,500 --> 01:03:50,070
and it knows where it stopped you know Linux to actually take the interrupt.

1054
01:03:50,070 --> 01:03:51,780
So maybe you know whatever it took it,

1055
01:03:52,780 --> 01:03:55,210
it has executed a hundred instruction so far,

1056
01:03:56,160 --> 01:03:58,050
and then this interrupt comes in,

1057
01:03:58,260 --> 01:04:00,090
and the hypervisor that wants to

1058
01:04:00,270 --> 01:04:03,570
deliver that interrupt basically instruction after 100,

1059
01:04:04,220 --> 01:04:05,510
and before doing that actually,

1060
01:04:05,510 --> 01:04:07,250
it just sends over the logging channel,

1061
01:04:07,430 --> 01:04:08,840
a message you know to the backup,

1062
01:04:10,390 --> 01:04:12,910
so here's backup FT,

1063
01:04:13,240 --> 01:04:14,110
and in that message,

1064
01:04:14,110 --> 01:04:16,840
it basically says like okay at instruction 100,

1065
01:04:17,440 --> 01:04:18,880
you know when you get the instruction 100,

1066
01:04:19,150 --> 01:04:20,710
you know delivered this interrupt,

1067
01:04:20,740 --> 01:04:23,350
and maybe some data associated with the interrupt.

1068
01:04:24,860 --> 01:04:26,870
So this is just two things interrupt comes in,

1069
01:04:26,900 --> 01:04:28,250
sees what the instruction number was,

1070
01:04:28,250 --> 01:04:29,840
and then it sends to backup this message,

1071
01:04:29,840 --> 01:04:31,730
saying like hey you know at some point,

1072
01:04:31,730 --> 01:04:33,050
when you get to instruction 100,

1073
01:04:33,050 --> 01:04:35,210
you know process you know this interrupt.

1074
01:04:36,800 --> 01:04:41,270
And you know some point later, this interrupt 1 and interrupt 2 comes in,

1075
01:04:41,570 --> 01:04:46,040
and so then the hypervisor exactly the same thing you know again,

1076
01:04:46,810 --> 01:04:51,640
they'll send out, say this is instruction 200,

1077
01:04:51,640 --> 01:04:54,400
you know will send a message 200 interrupt,

1078
01:04:54,400 --> 01:04:57,760
perhaps and any data associated the interrupt to the FT.

1079
01:04:59,590 --> 01:05:04,790
So when you know the backup gets the first message,

1080
01:05:04,790 --> 01:05:06,020
just buffers the message,

1081
01:05:06,890 --> 01:05:09,950
because it doesn't know how long it can run after that message,

1082
01:05:09,950 --> 01:05:13,970
until it knows what the next point is that it has to deliver something.

1083
01:05:14,900 --> 01:05:16,880
So at the point that the second message comes in,

1084
01:05:16,910 --> 01:05:17,990
you know for the second interrupt,

1085
01:05:18,080 --> 01:05:21,230
it knows you know it's perfectly fine to start a computer,

1086
01:05:21,620 --> 01:05:24,200
and instruction 100 delivered to interrupt,

1087
01:05:24,350 --> 01:05:26,840
and basically keep running into instruction 200.

1088
01:05:28,360 --> 01:05:28,990
And the way it does,

1089
01:05:28,990 --> 01:05:31,120
it is basically most processors have this,

1090
01:05:31,120 --> 01:05:32,740
but x86 has this too,

1091
01:05:32,800 --> 01:05:34,810
where you can basically program the x86

1092
01:05:34,810 --> 01:05:38,200
and say well you should stop after executing 100 instruction,

1093
01:05:38,500 --> 01:05:41,980
so the processor will stop where executing after 100 instructions,

1094
01:05:42,010 --> 01:05:44,800
and this give back control to the operating system,

1095
01:05:44,800 --> 01:05:46,540
in this case, the virtual machine monitor.

1096
01:05:47,720 --> 01:05:50,570
And so you know so this is the scheme,

1097
01:05:50,570 --> 01:05:54,080
this is a scheme that VM-FT uses

1098
01:05:54,110 --> 01:05:56,240
to basically you know deliver interrupts,

1099
01:05:56,270 --> 01:05:58,460
both at the primary and the backup,

1100
01:05:58,490 --> 01:06:00,200
exactly at the same instruction,

1101
01:06:00,260 --> 01:06:02,780
so that they sort of stay in exactly

1102
01:06:02,780 --> 01:06:04,880
execute the instructions exactly the same order.

1103
01:06:06,250 --> 01:06:06,880
To arrange this,

1104
01:06:06,880 --> 01:06:14,870
of course going to backup which needs lag behind one, lag behind one message.

1105
01:06:19,870 --> 01:06:20,530
Okay?

1106
01:06:23,970 --> 01:06:25,080
So just to be clear,

1107
01:06:25,080 --> 01:06:27,060
so the deterministic operations don't

1108
01:06:27,210 --> 01:06:29,460
don't get communicated through the logging channel,

1109
01:06:29,460 --> 01:06:33,700
it's only the operations that perhaps might diverged.

1110
01:06:33,970 --> 01:06:34,660
Exactly.

1111
01:06:34,660 --> 01:06:35,290
Usually got.

1112
01:06:35,650 --> 01:06:36,730
Exactly, what it does,

1113
01:06:36,760 --> 01:06:39,220
so let's look at one more actually get the flavor,

1114
01:06:39,220 --> 01:06:39,940
then we'll talk.

1115
01:06:40,150 --> 01:06:41,650
Yeah, go ahead.

1116
01:06:41,830 --> 01:06:44,740
Sorry, so deterministic operations,

1117
01:06:44,920 --> 01:06:47,800
is that don't get communicated through the logging channel.

1118
01:06:48,040 --> 01:06:49,540
No, there's no need for them,

1119
01:06:49,870 --> 01:06:53,980
because both of them of course have a copy of all the instructions,

1120
01:06:53,980 --> 01:06:56,500
like the binary that, like whatever Linux runs, correct,

1121
01:06:56,830 --> 01:07:00,310
but you know the instructions are not communicated over logging channel,

1122
01:07:00,310 --> 01:07:02,050
only the non-deterministic wants.

1123
01:07:02,400 --> 01:07:05,370
So like in this interrupt and we'll see in a second,

1124
01:07:05,370 --> 01:07:09,480
here let's talk about the second one, non-deterministic instructions,

1125
01:07:11,190 --> 01:07:13,410
like you get the timer, get timer of day.

1126
01:07:14,260 --> 01:07:15,550
So the way that works is,

1127
01:07:16,060 --> 01:07:19,300
so here's we got our Linux running in the VM,

1128
01:07:19,330 --> 01:07:21,040
we got our FT running,

1129
01:07:22,000 --> 01:07:27,130
and basically when you know this Linux use a image,

1130
01:07:27,310 --> 01:07:29,170
program image that Linux runs,

1131
01:07:29,530 --> 01:07:32,710
and maybe you know here's are non-deterministic instruction,

1132
01:07:33,830 --> 01:07:36,290
and basically what FT has done,

1133
01:07:36,500 --> 01:07:38,390
before it started Linux,

1134
01:07:38,450 --> 01:07:40,880
you sort of gone through the Linux binary

1135
01:07:40,910 --> 01:07:43,520
and found all the instruction that the non-deterministic,

1136
01:07:43,520 --> 01:07:44,720
like get time of day,

1137
01:07:45,050 --> 01:07:48,650
and basically ensure you know turn them in sort of invalid instruction,

1138
01:07:49,010 --> 01:07:53,180
and so when Linux execute, executes that non-deterministic instruction,

1139
01:07:53,390 --> 01:07:57,200
it actually controls transfers control to the hypervisor,

1140
01:07:57,610 --> 01:07:58,840
this is the trap.

1141
01:07:59,600 --> 01:08:01,340
And now the hypervisor knows,

1142
01:08:01,340 --> 01:08:04,430
okay, well this was whatever instruction 341,

1143
01:08:04,730 --> 01:08:07,220
I know that is a non-deterministic instruction,

1144
01:08:07,220 --> 01:08:10,760
because I wrote you know those bits you know that caused the trap,

1145
01:08:11,030 --> 01:08:13,700
and it will emulate that instruction,

1146
01:08:13,880 --> 01:08:16,910
and so it will do all the effects that instruction has,

1147
01:08:16,970 --> 01:08:19,640
but record what the results of the effects are,

1148
01:08:19,670 --> 01:08:24,170
so for example, you know whatever we record what the result execution instruction,

1149
01:08:24,170 --> 01:08:27,020
the result stays goes into a0,

1150
01:08:27,020 --> 01:08:28,730
it records the value a0

1151
01:08:28,760 --> 01:08:30,530
and then basically sends to the backup,

1152
01:08:32,020 --> 01:08:34,360
you know the outcome you know of that instruction,

1153
01:08:34,360 --> 01:08:38,890
so whatever its value in a0 is whatever 221,

1154
01:08:39,160 --> 01:08:40,780
then of all you know send back,

1155
01:08:40,780 --> 01:08:43,210
you know saying you know there's non-deterministic instruction,

1156
01:08:43,720 --> 01:08:46,120
result of it is 221,

1157
01:08:47,600 --> 01:08:48,560
and at some point, correct,

1158
01:08:48,560 --> 01:08:50,330
you know the backup legs behind,

1159
01:08:50,870 --> 01:08:53,540
it will you know execute,

1160
01:08:53,570 --> 01:08:56,870
because it's executing these instructions in the same order, in the same way,

1161
01:08:56,930 --> 01:08:59,750
it will also execute the non-deterministic instruction,

1162
01:08:59,780 --> 01:09:01,310
that will trap into the kernel,

1163
01:09:01,870 --> 01:09:03,490
and that usually wait

1164
01:09:03,490 --> 01:09:05,650
until you know since legs behind,

1165
01:09:05,650 --> 01:09:07,360
the already receives probably the message

1166
01:09:07,510 --> 01:09:10,720
and basically make sure that it sticks the same value,

1167
01:09:10,750 --> 01:09:14,710
you know returns the same value as it did on the primary, right.

1168
01:09:14,710 --> 01:09:17,260
So this is how non-deterministic instructions are handled.

1169
01:09:21,160 --> 01:09:23,800
Sorry, so that happens,

1170
01:09:23,890 --> 01:09:25,870
like the modification of the binary,

1171
01:09:25,870 --> 01:09:30,070
it happens when it creates the virtual machines?

1172
01:09:30,070 --> 01:09:33,190
Yeah, we think about it, when it to boot to the VM.

1173
01:09:33,890 --> 01:09:34,700
Okay.

1174
01:09:35,580 --> 01:09:42,240
But so the the backup re-executes the non-deterministic instruction,

1175
01:09:42,240 --> 01:09:44,250
and then just verifies the result?

1176
01:09:44,460 --> 01:09:45,870
No, what it actually does is,

1177
01:09:45,870 --> 01:09:50,250
if the virtual machine monitor executes the instruction,

1178
01:09:51,000 --> 01:09:53,070
and then you know,

1179
01:09:53,100 --> 01:09:55,650
actually virtual machine monitor that doesn't execute instruction at all,

1180
01:09:55,860 --> 01:09:59,340
it knows that this instruction needs to be executed,

1181
01:09:59,550 --> 01:10:01,380
and it knows what things will be changed,

1182
01:10:01,380 --> 01:10:03,120
like what registers need to be updated,

1183
01:10:03,120 --> 01:10:05,250
as a result of this instruction,

1184
01:10:05,340 --> 01:10:09,150
and it sticks the value from the message into the register,

1185
01:10:09,180 --> 01:10:12,000
so that the Linux running on the backups

1186
01:10:12,000 --> 01:10:15,600
is exactly the same effect as a Linux running on the primary.

1187
01:10:20,560 --> 01:10:23,500
And so like this assumes that the hypervisor will do some work before

1188
01:10:23,500 --> 01:10:26,380
even or while putting up VM

1189
01:10:26,380 --> 01:10:29,110
just where the locations of these non-deterministic.

1190
01:10:29,260 --> 01:10:31,180
Yeah that with hypervisor does these [].

1191
01:10:32,920 --> 01:10:34,570
So this is a standard hypervisor stuff,

1192
01:10:34,570 --> 01:10:36,880
there's nothing new to FT,

1193
01:10:37,210 --> 01:10:40,750
other than these guys a ton of experience do hypervisor,

1194
01:10:40,750 --> 01:10:41,740
because VMware,

1195
01:10:42,100 --> 01:10:45,400
and so they understand like what what it takes,

1196
01:10:45,940 --> 01:10:48,340
and which instructions are non-deterministic.

1197
01:10:51,420 --> 01:10:52,410
Okay, so.

1198
01:10:52,410 --> 01:10:55,740
I I had one more, one more question,

1199
01:10:55,740 --> 01:11:01,830
so if you know it's a program of fully like deterministic instructions,

1200
01:11:02,400 --> 01:11:07,090
could, could the backup run faster than the primary.

1201
01:11:08,180 --> 01:11:11,240
Okay, so you know there's a whole discussion in the paper

1202
01:11:11,240 --> 01:11:13,340
about like the speed of the primary and backup,

1203
01:11:13,340 --> 01:11:15,740
and making sure that run roughly at the same speed,

1204
01:11:15,740 --> 01:11:19,190
because you don't want to get one far ahead and one far behind,

1205
01:11:19,610 --> 01:11:21,470
I think you should think about them,

1206
01:11:21,470 --> 01:11:23,150
they're running on the sort of identical hardware,

1207
01:11:23,150 --> 01:11:24,860
and so they're running roughly at the same speed.

1208
01:11:25,300 --> 01:11:27,580
It's also the case that,

1209
01:11:28,160 --> 01:11:31,400
there's going to be always some communication over this channel,

1210
01:11:31,460 --> 01:11:35,120
because interrupts are happening periodically, right,

1211
01:11:35,480 --> 01:11:39,050
like every you know whatever you know a couple of milliseconds,

1212
01:11:39,050 --> 01:11:41,150
or maybe a hundred milliseconds or ten milliseconds,

1213
01:11:41,150 --> 01:11:45,110
depending on how Linux what rate Linux program the hardware timer,

1214
01:11:45,170 --> 01:11:46,610
there will be a timer interrupt,

1215
01:11:46,790 --> 01:11:50,120
and timer interrupt will be propagated to the backup,

1216
01:11:50,120 --> 01:11:51,740
and sort of be sync points if you want.

1217
01:11:53,630 --> 01:11:55,910
Right, but my question is like,

1218
01:11:56,150 --> 01:12:00,470
for example say you have a bunch of deterministic instructions, right,

1219
01:12:00,590 --> 01:12:02,870
instructions that are sent through the logging channel,

1220
01:12:03,800 --> 01:12:07,610
which means you know the primary and backup

1221
01:12:07,610 --> 01:12:10,850
can run those instructions at at their own pace, correct.

1222
01:12:11,090 --> 01:12:11,420
Yes.

1223
01:12:11,630 --> 01:12:13,610
So, say what I mean,

1224
01:12:13,610 --> 01:12:14,900
I don't know if this could happen,

1225
01:12:14,900 --> 01:12:19,310
but say like it's you know a 100 instructions,

1226
01:12:19,310 --> 01:12:23,300
and the primary goes to like instruction 50

1227
01:12:23,570 --> 01:12:26,420
and gets gets a timer interrupt,

1228
01:12:26,880 --> 01:12:30,420
but the backup is already a timer like 60 or something,

1229
01:12:30,450 --> 01:12:31,290
could could that.

1230
01:12:31,620 --> 01:12:32,790
It could not happen, right,

1231
01:12:32,790 --> 01:12:36,030
because remember the backup legs behind one of these messages.

1232
01:12:38,400 --> 01:12:42,540
So the backup won't start executing the next log until the primary has finished.

1233
01:12:42,990 --> 01:12:43,530
Okay.

1234
01:12:44,380 --> 01:12:46,960
This is why this is why it lags behind one.

1235
01:12:47,560 --> 01:12:48,520
Hmm.

1236
01:12:51,440 --> 01:12:55,610
Like, to ensure that the backup is like lagging behind one instruction,

1237
01:12:55,610 --> 01:12:56,660
that does that mean.

1238
01:12:56,660 --> 01:12:59,150
No not one instruction, one message on the channel.

1239
01:13:00,180 --> 01:13:01,890
But the interrupt is [interrupt], right,

1240
01:13:01,890 --> 01:13:02,550
so if we have,

1241
01:13:02,550 --> 01:13:05,610
as you said, if we have a hundred lines of instructions,

1242
01:13:06,200 --> 01:13:09,800
and running on the backup as well as the primary, then.

1243
01:13:09,800 --> 01:13:12,440
The primary backup would not have started yet, right,

1244
01:13:12,440 --> 01:13:14,780
so the primary runs 200 instructions,

1245
01:13:14,990 --> 01:13:16,310
the backup actually wait

1246
01:13:16,310 --> 01:13:21,860
until the primary actually just completed whatever those 100 instructions,

1247
01:13:21,920 --> 01:13:24,260
before it starts running those 100 instructions.

1248
01:13:25,580 --> 01:13:26,990
So just one way to think about,

1249
01:13:26,990 --> 01:13:29,000
it always runs like one epoch behind.

1250
01:13:29,360 --> 01:13:32,240
Oh, so it's kind of a batching kind of scheme.

1251
01:13:33,110 --> 01:13:33,500
Yeah.

1252
01:13:33,500 --> 01:13:33,830
Alright, thank you.

1253
01:13:34,670 --> 01:13:36,890
Okay, so I want to talk a little bit about failure over,

1254
01:13:36,890 --> 01:13:38,240
because there's a couple interesting,

1255
01:13:38,240 --> 01:13:40,280
there's one more rule that needs to be ensured,

1256
01:13:40,280 --> 01:13:42,950
that we actually get the right behavior.

1257
01:13:43,500 --> 01:13:46,980
And so, so let's walk through some scenarios,

1258
01:13:46,980 --> 01:13:48,000
here's the primary,

1259
01:13:48,330 --> 01:13:50,670
here's our hypervisor correct FT,

1260
01:13:51,240 --> 01:13:55,440
here's our logging channel, FT,

1261
01:13:55,740 --> 01:13:57,090
you know they both on the network,

1262
01:13:57,090 --> 01:13:57,990
here's a client,

1263
01:13:59,430 --> 01:14:01,080
and here's our backup.

1264
01:14:04,010 --> 01:14:06,410
And I'm going to talk about a couple of scenarios,

1265
01:14:06,830 --> 01:14:10,850
so the first scenario are the normal case,

1266
01:14:10,850 --> 01:14:16,000
a client sends a message you know to the primary,

1267
01:14:16,000 --> 01:14:17,980
where the servers running on the primary,

1268
01:14:17,980 --> 01:14:21,260
you know that's delivered of course to the primary,

1269
01:14:21,260 --> 01:14:23,420
also sent you know to on the channel.

1270
01:14:24,000 --> 01:14:26,040
And let's assume for a second,

1271
01:14:26,040 --> 01:14:30,810
that actually the message you know arrives you know at the hypervisor,

1272
01:14:30,810 --> 01:14:32,940
so it actually knows that this was an interrupt,

1273
01:14:32,940 --> 01:14:34,200
some packet arrived,

1274
01:14:35,640 --> 01:14:40,350
and so now let's say the primary who sent a response back,

1275
01:14:41,030 --> 01:14:43,340
and at that point, the computer crashes,

1276
01:14:44,860 --> 01:14:46,120
so the primary fails,

1277
01:14:46,120 --> 01:14:47,710
the client has not gotten a response yet.

1278
01:14:48,900 --> 01:14:51,210
Now, this turns out to work out perfectly fine,

1279
01:14:51,210 --> 01:14:53,970
because before you know the backup actually takes over,

1280
01:14:53,970 --> 01:14:58,920
it first processes all it's message that has received yet,

1281
01:14:58,920 --> 01:15:01,350
because lags one behind, as we talked before,

1282
01:15:01,650 --> 01:15:04,980
so you know this thing will be delivery.

1283
01:15:04,980 --> 01:15:06,750
So it will, sorry.

1284
01:15:12,640 --> 01:15:15,490
Okay, let me a little bit more careful,

1285
01:15:15,490 --> 01:15:18,310
okay, so it gets delivered to the primary backup does it,

1286
01:15:18,310 --> 01:15:20,230
but it actually won't send any response,

1287
01:15:20,930 --> 01:15:21,740
because it's still,

1288
01:15:21,740 --> 01:15:24,800
so you know doing exactly what the primary has done,

1289
01:15:25,010 --> 01:15:26,930
gets through that particular point and stops.

1290
01:15:27,610 --> 01:15:29,110
Then point you know []

1291
01:15:29,110 --> 01:15:31,150
you know or like the backup becomes the primary,

1292
01:15:31,150 --> 01:15:32,590
you know through the arbitration server,

1293
01:15:32,980 --> 01:15:35,140
and the client will just timeout and retry,

1294
01:15:35,200 --> 01:15:37,600
because like TCP packet, then get a response,

1295
01:15:37,600 --> 01:15:39,430
so retry actually trying to work out perfect.

1296
01:15:41,100 --> 01:15:42,510
The interesting case is,

1297
01:15:42,660 --> 01:15:45,890
what happens in the following scenario,

1298
01:15:45,920 --> 01:15:51,000
where the client sends a request,

1299
01:15:51,150 --> 01:15:52,410
it can it arrives at the primary,

1300
01:15:52,410 --> 01:15:54,660
primary does the operation,

1301
01:15:54,660 --> 01:15:56,430
or whatever process the client request,

1302
01:15:56,490 --> 01:15:58,590
since the message to fault tolerance server,

1303
01:15:58,710 --> 01:16:00,450
in the meantime,

1304
01:16:00,450 --> 01:16:02,790
okay, it was also sent on the logging channel,

1305
01:16:02,910 --> 01:16:04,290
but let's say we got unlucky,

1306
01:16:04,440 --> 01:16:06,990
and the message actually never made it over the logging channel,

1307
01:16:07,860 --> 01:16:09,600
and,

1308
01:16:12,520 --> 01:16:16,750
but the primary actually you know sends a response,

1309
01:16:16,750 --> 01:16:23,000
before just sends a response and then it fails, right,

1310
01:16:23,000 --> 01:16:24,170
and so for example like,

1311
01:16:24,170 --> 01:16:28,580
maybe you know this request was to increase the variable from 10 to 11,

1312
01:16:28,580 --> 01:16:36,640
so inc the old state was 10 and now the new state is 11, right.

1313
01:16:38,300 --> 01:16:40,640
And is this problematic, this scenario?

1314
01:16:41,810 --> 01:16:44,720
Yeah, because when the backup takes over,

1315
01:16:44,720 --> 01:16:49,680
it won't know about that increase,

1316
01:16:49,710 --> 01:16:53,580
and so it'll just continue execution as if it didn't happen,

1317
01:16:53,580 --> 01:16:58,920
and this provides like inconsistent output

1318
01:16:58,920 --> 01:17:02,130
to the external like [facing] world I guess.

1319
01:17:02,370 --> 01:17:03,540
Yeah, exactly, right,

1320
01:17:03,540 --> 01:17:05,820
because the primary will takeover, the backup will take over,

1321
01:17:05,820 --> 01:17:07,140
the value still be 10,

1322
01:17:07,410 --> 01:17:09,810
and now if the client does inc,

1323
01:17:09,810 --> 01:17:11,730
it can actually gets 11 back,

1324
01:17:11,730 --> 01:17:14,290
instead of 10, instead of 12, right.

1325
01:17:14,590 --> 01:17:15,550
So this is no good,

1326
01:17:16,000 --> 01:17:17,830
and so how is this avoided this problem?

1327
01:17:18,570 --> 01:17:23,790
The primary will send things to the backup

1328
01:17:23,790 --> 01:17:25,410
and then wait for acknowledgement,

1329
01:17:25,410 --> 01:17:28,590
and once that acknowledgement is received,

1330
01:17:28,590 --> 01:17:31,140
it can send output,

1331
01:17:31,590 --> 01:17:35,040
and it doesn't matter whether the backup actually runs the command,

1332
01:17:35,040 --> 01:17:36,840
it just has to have it,

1333
01:17:36,870 --> 01:17:40,470
so that if it ever needs to take over as primary,

1334
01:17:40,470 --> 01:17:41,880
it has that and it's logs,

1335
01:17:41,880 --> 01:17:46,150
and it will catch up before actually like become primary.

1336
01:17:46,150 --> 01:17:48,760
Exactly right, so this is what's called the output rule,

1337
01:17:51,520 --> 01:17:54,190
and the rule is that you know before you can output,

1338
01:17:54,520 --> 01:17:56,260
you got to make sure that,

1339
01:17:56,260 --> 01:18:00,070
the preceding messages that you were sent to the backup

1340
01:18:00,070 --> 01:18:01,810
actually have been received by the backup.

1341
01:18:02,610 --> 01:18:05,580
So this scenario I just drew out going actually never happen,

1342
01:18:06,220 --> 01:18:07,630
because you know at that point,

1343
01:18:07,630 --> 01:18:10,840
you know the primary wants to send a response out on the network,

1344
01:18:11,290 --> 01:18:14,200
the FT, the primary FT will wait

1345
01:18:14,200 --> 01:18:18,460
until this message actually has has been received by the backup,

1346
01:18:18,960 --> 01:18:24,890
and only when it received an acknowledgement from the backup FT,

1347
01:18:25,190 --> 01:18:30,830
and now knows you know that basically the backup has a copy of this input,

1348
01:18:31,450 --> 01:18:34,030
and so whatever you know whatever it fails,

1349
01:18:34,030 --> 01:18:36,910
you know the backup will you know process that input,

1350
01:18:36,910 --> 01:18:40,060
and basically get a computer in the same state as the primary,

1351
01:18:40,240 --> 01:18:43,870
so at that point and actually safe to send out the reply.

1352
01:18:45,080 --> 01:18:46,580
And so this is the output rule,

1353
01:18:46,580 --> 01:18:48,560
is that you don't output

1354
01:18:48,560 --> 01:18:52,760
until all preceding messages that you send over log channel

1355
01:18:52,790 --> 01:18:54,770
actually have been received by the backup.

1356
01:18:55,760 --> 01:18:57,050
And so just to clarify,

1357
01:18:57,050 --> 01:19:02,120
it seems that the output rule is here to solve the inconsistency,

1358
01:19:02,120 --> 01:19:04,580
that could happen if we have some non-determinism,

1359
01:19:04,880 --> 01:19:09,380
so like let's say that we have the output operation to be instruction 60,

1360
01:19:09,740 --> 01:19:13,400
and we do not have the output rule,

1361
01:19:13,580 --> 01:19:15,770
and so the backup actually did not,

1362
01:19:15,800 --> 01:19:19,940
let's say for some reason did not receive the output operation,

1363
01:19:20,210 --> 01:19:23,570
or it did not receive up until the output operation,

1364
01:19:23,750 --> 01:19:26,720
if the instructions are deterministic between the point,

1365
01:19:26,780 --> 01:19:29,630
where the backup did not receive messages

1366
01:19:29,870 --> 01:19:32,630
until the point where we have an output operation,

1367
01:19:32,900 --> 01:19:35,840
do we still run into the problem of the inconsistency?

1368
01:19:36,280 --> 01:19:38,650
Yeah, because the client might observe that, right,

1369
01:19:38,650 --> 01:19:41,890
the client might have observed that actually value is now 11.

1370
01:19:43,600 --> 01:19:48,430
And so when it actually talks to the backup after the primary has failed,

1371
01:19:48,430 --> 01:19:50,350
you know then the value should only 10,

1372
01:19:51,180 --> 01:19:52,560
and you know that can't be true,

1373
01:19:53,490 --> 01:19:57,300
so that you know that reveals that is not behaving like a single system.

1374
01:19:58,300 --> 01:19:58,750
I see.

1375
01:19:59,450 --> 01:20:04,130
It's the external thing you know the external client that will observe something wrong,

1376
01:20:04,130 --> 01:20:05,870
and this is why the output rule exists,

1377
01:20:06,200 --> 01:20:07,670
in any replication system,

1378
01:20:07,670 --> 01:20:08,780
that we'll see this semester

1379
01:20:08,810 --> 01:20:10,670
has something like the output rule.

1380
01:20:11,160 --> 01:20:12,150
And it turns out to be,

1381
01:20:12,150 --> 01:20:16,980
you know for example you'll see in the, even in the raft paper,

1382
01:20:17,010 --> 01:20:19,410
but also in the zookeeper,

1383
01:20:19,410 --> 01:20:20,790
there's sort of this notion,

1384
01:20:20,790 --> 01:20:24,540
that you know sometimes you want to like respond to reads immediately,

1385
01:20:24,540 --> 01:20:25,860
but you can't really do that,

1386
01:20:25,860 --> 01:20:27,300
because you run this risk

1387
01:20:27,300 --> 01:20:29,700
and sort of an equivalent of an output rule,

1388
01:20:29,820 --> 01:20:33,030
that tries to avoid you know problems like like that.

1389
01:20:35,770 --> 01:20:40,120
So does the client re-execute the command,

1390
01:20:40,750 --> 01:20:42,940
like do they get some sort of signal that,

1391
01:20:43,460 --> 01:20:47,000
because the command was never ack by the backup.

1392
01:20:47,540 --> 01:20:51,680
Okay, okay so let's say we did not get the ack, right,

1393
01:20:52,890 --> 01:20:54,840
so, I've got to backup but not to the ack,

1394
01:20:55,650 --> 01:20:58,200
then the client will not

1395
01:20:58,930 --> 01:21:02,050
you know this response would have not been sent to the client yet, right,

1396
01:21:02,930 --> 01:21:04,580
the backup will take over,

1397
01:21:04,670 --> 01:21:06,200
the client presumably will timeout,

1398
01:21:06,230 --> 01:21:07,760
and do whatever it needs to do,

1399
01:21:07,790 --> 01:21:09,290
either you know does nothing,

1400
01:21:09,350 --> 01:21:11,930
you know if you know that's part of their,

1401
01:21:11,930 --> 01:21:14,390
that's part of the protocol between servers and clients,

1402
01:21:14,420 --> 01:21:18,680
most likely the client will re-send the TCP connection,

1403
01:21:18,680 --> 01:21:21,560
the response packet didn't get received,

1404
01:21:21,560 --> 01:21:24,680
and so it will you know try to re-send,

1405
01:21:25,340 --> 01:21:26,930
and so it will re-send to backup,

1406
01:21:28,020 --> 01:21:29,160
and then finish the operation,

1407
01:21:30,530 --> 01:21:32,390
but it won't observe an old value.

1408
01:21:38,390 --> 01:21:39,020
Okay?

1409
01:21:50,850 --> 01:21:56,040
Okay, now I want to talk one thing a little bit,

1410
01:21:56,040 --> 01:21:59,160
then so this system I think it's actually very cool,

1411
01:21:59,160 --> 01:22:05,100
it's a very clean version of state machine replication,

1412
01:22:05,370 --> 01:22:08,130
it brings out this issue of non-determinism,

1413
01:22:08,130 --> 01:22:09,900
the issues like the output rule,

1414
01:22:09,900 --> 01:22:11,940
that we'll see in a version of that,

1415
01:22:11,940 --> 01:22:16,800
we'll see a similar in in other systems,

1416
01:22:16,950 --> 01:22:18,960
but I want to talk a little bit about performance,

1417
01:22:18,960 --> 01:22:23,160
because like one downside of this system is,

1418
01:22:23,160 --> 01:22:24,600
you know because you're doing things

1419
01:22:24,600 --> 01:22:28,470
at the level of the machine instructions or level interrupts,

1420
01:22:28,710 --> 01:22:32,070
there you pay performance hit.

1421
01:22:32,980 --> 01:22:36,880
So like 1 and 2 tables that are in the paper,

1422
01:22:37,660 --> 01:22:40,210
and one the first thing to observe is that,

1423
01:22:40,210 --> 01:22:42,550
actually the left table is extremely good,

1424
01:22:43,420 --> 01:22:45,430
so the backup and the primary,

1425
01:22:45,430 --> 01:22:48,430
you run the backup primary performance was very close to

1426
01:22:48,430 --> 01:22:51,130
as if you were not running with a backup,

1427
01:22:51,130 --> 01:22:52,870
which is very very impressive,

1428
01:22:52,870 --> 01:22:55,420
and in fact including the fact that you're running a virtual machine,

1429
01:22:56,300 --> 01:23:03,210
the more, the more troublesome part is this side of things,

1430
01:23:03,210 --> 01:23:07,380
where if you don't run in a primary/backup mode,

1431
01:23:07,380 --> 01:23:10,650
you know like your bandwidth and receiving and sending actually pretty high,

1432
01:23:10,650 --> 01:23:12,780
you know at least in the particular experiment they did.

1433
01:23:13,310 --> 01:23:15,350
But you know when you're running the backup mode,

1434
01:23:15,500 --> 01:23:17,060
things are actually not so good, right,

1435
01:23:17,060 --> 01:23:18,980
you know these numbers are quite different,

1436
01:23:19,130 --> 01:23:22,550
in fact like 30% reduction in performance.

1437
01:23:23,190 --> 01:23:24,780
And where is that 30% coming from,

1438
01:23:24,780 --> 01:23:26,370
like why, why is that the case.

1439
01:23:34,240 --> 01:23:38,260
Because the primary is actually the one receiving inputs from outside.

1440
01:23:39,080 --> 01:23:41,240
Yeah, I think there's two cases,

1441
01:23:41,240 --> 01:23:43,250
in on receiving a case,

1442
01:23:43,250 --> 01:23:45,620
where the primary receiving input from the outside,

1443
01:23:45,620 --> 01:23:46,700
where does that need to go.

1444
01:23:48,020 --> 01:23:51,170
If you see a packet from the from the client,

1445
01:23:51,170 --> 01:23:57,930
so that packet has to be sent to the to the backup, sort of.

1446
01:23:57,930 --> 01:24:03,630
Wait, but the primary is also the one sending output back to the clients,

1447
01:24:03,630 --> 01:24:05,190
so is that what's using the bandwidth.

1448
01:24:05,660 --> 01:24:10,580
Yeah, well, there's that one reason,

1449
01:24:10,580 --> 01:24:12,770
but the real thing I think is going on here is that,

1450
01:24:12,770 --> 01:24:15,290
the primary has to wait

1451
01:24:15,320 --> 01:24:17,990
until it can send a response to a client

1452
01:24:17,990 --> 01:24:20,000
until the backup actually has acknowledged it.

1453
01:24:20,960 --> 01:24:23,150
And so just came like process packets,

1454
01:24:23,150 --> 01:24:25,790
the same speed as good without actually backup.

1455
01:24:27,500 --> 01:24:30,470
And therefore we should see a reduction in performance.

1456
01:24:32,230 --> 01:24:34,030
Nevertheless, this performance is pretty impressive,

1457
01:24:34,030 --> 01:24:36,940
but you know there's a performance cost.

1458
01:24:37,500 --> 01:24:38,340
And this is one reason,

1459
01:24:38,340 --> 01:24:43,830
that people play this game replicated state machines not at the instruction level,

1460
01:24:43,830 --> 01:24:45,480
but at the application level,

1461
01:24:45,540 --> 01:24:48,420
and basically be able to get higher performance,

1462
01:24:48,510 --> 01:24:50,970
but that requires modification to the applications,

1463
01:24:50,970 --> 01:24:52,200
as we saw in GFS.

1464
01:24:56,380 --> 01:24:58,270
Okay, I think I'm running a little bit over time,

1465
01:24:58,270 --> 01:24:59,410
so I'm gonna stop right now,

1466
01:24:59,410 --> 01:25:03,940
so I hope people that actually needed to leave already left,

1467
01:25:03,940 --> 01:25:05,410
but I'll stick around,

1468
01:25:05,470 --> 01:25:07,030
and see if people have more questions,

1469
01:25:07,030 --> 01:25:10,930
I'll be happy to answer those.

1470
01:25:12,550 --> 01:25:13,960
And I'll talk to you on Tuesday.

1471
01:25:14,540 --> 01:25:14,930
Thank you.

1472
01:25:18,320 --> 01:25:23,570
I had a question about the previous image,

1473
01:25:23,660 --> 01:25:27,030
that you drew with, with the,

1474
01:25:27,060 --> 01:25:28,530
yeah that one,

1475
01:25:28,590 --> 01:25:31,110
I was confused because,

1476
01:25:31,740 --> 01:25:33,720
wasn't it the case that,

1477
01:25:34,420 --> 01:25:37,660
if that number 10, it just sits in the memory,

1478
01:25:37,690 --> 01:25:39,520
then we do an increment,

1479
01:25:40,220 --> 01:25:44,400
we don't need to send anything to the backup right.

1480
01:25:45,730 --> 01:25:47,860
There, okay, so there's two things going on here,

1481
01:25:47,860 --> 01:25:48,730
so we do see,

1482
01:25:48,730 --> 01:25:50,890
at the at the point that the message comes in,

1483
01:25:51,010 --> 01:25:54,910
like this increment comes in from the client,

1484
01:25:55,270 --> 01:26:00,460
arrives at the FT at the hyper, the primary hypervisor,

1485
01:26:01,150 --> 01:26:06,070
it needs to forward that message to the backup FT,

1486
01:26:06,070 --> 01:26:07,660
so that it can process,

1487
01:26:07,660 --> 01:26:10,030
it needs to be processed when it needs to be processed,

1488
01:26:10,120 --> 01:26:15,320
when it processes exactly the same point in this instruction stream, right.

1489
01:26:16,710 --> 01:26:17,850
So it sends it off,

1490
01:26:17,880 --> 01:26:19,890
and then you know delivers it to the primary,

1491
01:26:19,980 --> 01:26:21,930
and then the primary goes up and does its thing,

1492
01:26:22,080 --> 01:26:24,570
primary you know may respond with a message,

1493
01:26:24,930 --> 01:26:27,120
and so if the primary responds with a message,

1494
01:26:27,150 --> 01:26:29,760
the output of that message is stop

1495
01:26:29,760 --> 01:26:36,120
or hold until the backup as acknowledged the reception of this increment,

1496
01:26:39,860 --> 01:26:42,410
which will ensure that if the backup has to take over,

1497
01:26:42,410 --> 01:26:44,690
whatever it will process that increment first,

1498
01:26:44,690 --> 01:26:47,990
and it also will be 11 before response sent.

1499
01:26:52,140 --> 01:26:54,720
Okay, okay, thank you.

1500
01:26:55,430 --> 01:26:58,520
One thing I'm confused about is,

1501
01:26:58,520 --> 01:27:05,320
is the goal of the system to to help with like bucking up an actual server,

1502
01:27:05,320 --> 01:27:10,270
where because it's not easy to handle the interrupt without a hypervisor

1503
01:27:10,270 --> 01:27:15,680
or is it actually to help distribute virtual machines themselves.

1504
01:27:16,350 --> 01:27:17,970
And it's purely to make an app,

1505
01:27:18,000 --> 01:27:21,090
like you have a business application that runs on a single machine,

1506
01:27:21,510 --> 01:27:23,010
and you want to make it more fault tolerance,

1507
01:27:23,500 --> 01:27:27,040
and the what this scheme does is,

1508
01:27:27,040 --> 01:27:29,260
it makes it fault tolerance for you transparently,

1509
01:27:30,140 --> 01:27:34,790
you run the business applications and both machines on the on the FT hypervisor

1510
01:27:34,940 --> 01:27:37,130
and FT hypervisor will ensure that,

1511
01:27:37,130 --> 01:27:41,060
you know basically these applications more or less not literally running lockstep,

1512
01:27:41,090 --> 01:27:45,680
but basically you know fault tolerance replicated.

1513
01:27:46,820 --> 01:27:49,850
So the VM using the VM itself is kind of a design decision.

1514
01:27:49,970 --> 01:27:53,270
Yes, and that is a good design decision,

1515
01:27:53,270 --> 01:27:56,900
because it allows you to do this replication at a transparent level.

1516
01:27:57,650 --> 01:27:58,580
Got it, thanks so much.

1517
01:27:59,200 --> 01:27:59,680
You're welcome.

1518
01:28:02,730 --> 01:28:04,110
Yeah, the question in the chat,

1519
01:28:04,110 --> 01:28:06,630
about can be a the output rule,

1520
01:28:06,630 --> 01:28:08,850
is it possible that the client sees the same response twice.

1521
01:28:08,850 --> 01:28:09,720
And the answer is yes,

1522
01:28:10,600 --> 01:28:11,770
it's absolutely possible,

1523
01:28:11,770 --> 01:28:15,310
that the client will see you get the response twice,

1524
01:28:15,310 --> 01:28:18,670
and basically what they argue that's okay,

1525
01:28:18,820 --> 01:28:21,640
because in sort of the fault tolerant model of the network,

1526
01:28:21,670 --> 01:28:25,420
it is always assumed the network can actually duplicate messages anyway,

1527
01:28:25,840 --> 01:28:30,520
and so protocols like TCP are totally designed to deal with duplicate messages.

1528
01:28:32,180 --> 01:28:34,640
So yes, it's okay, because TCP,

1529
01:28:35,430 --> 01:28:39,270
or whatever replication duplication scheme,

1530
01:28:39,270 --> 01:28:41,430
the application uses, where the client uses.

1531
01:28:42,950 --> 01:28:45,410
I was curious about [] question,

1532
01:28:45,440 --> 01:28:50,030
which is primary like sort of goes down for a few minutes,

1533
01:28:50,600 --> 01:28:52,310
backup goes live,

1534
01:28:52,340 --> 01:28:56,330
then sets up its its own backup,

1535
01:28:56,630 --> 01:29:01,510
you know switches the bit back to 0,

1536
01:29:01,810 --> 01:29:07,710
and then suddenly somehow the first primary goes back,

1537
01:29:07,710 --> 01:29:08,610
like goes back.

1538
01:29:08,610 --> 01:29:10,290
Yeah, I think we're going to have the case,

1539
01:29:10,290 --> 01:29:12,060
that first primary is definitely terminated,

1540
01:29:12,060 --> 01:29:14,790
it's cleaned up and gone.

1541
01:29:15,410 --> 01:29:19,310
Hmm, nice, thanks.

1542
01:29:21,860 --> 01:29:24,230
To ask a question something similar,

1543
01:29:24,230 --> 01:29:25,430
may be too broad question,

1544
01:29:25,430 --> 01:29:28,700
but like will you ever need to store more things

1545
01:29:28,700 --> 01:29:32,000
besides an arbitration flag and the server,

1546
01:29:32,000 --> 01:29:35,780
I mean besides the flag an arbitration server,

1547
01:29:36,560 --> 01:29:40,840
if you have like multiple like backups.

1548
01:29:41,530 --> 01:29:45,130
Oh yeah, like this is a scheme [] to at one backup,

1549
01:29:45,130 --> 01:29:46,240
not more than one backup,

1550
01:29:46,240 --> 01:29:47,320
so if you had more backups,

1551
01:29:47,320 --> 01:29:51,690
you know, you know, there's other issues that we need to resolve,

1552
01:29:51,690 --> 01:29:53,880
in fact we'll come back to this, on Tuesday,

1553
01:29:53,880 --> 01:29:55,680
you know with more sophisticated protocols,

1554
01:29:55,680 --> 01:29:57,570
that handle those cases much cleaner.

1555
01:29:58,440 --> 01:30:01,230
Okay, that was just perfect cool, thank you.

1556
01:30:04,100 --> 01:30:06,410
I have one question about the performance,

1557
01:30:07,600 --> 01:30:10,570
so can you go back to that table?

1558
01:30:10,630 --> 01:30:11,950
Yes, my question is,

1559
01:30:12,250 --> 01:30:16,000
is it the delay only be viewed on the first packet,

1560
01:30:16,000 --> 01:30:17,260
like after the first packet,

1561
01:30:17,260 --> 01:30:19,630
it will just flow through the channel,

1562
01:30:19,630 --> 01:30:23,050
and there's no extra delay on the link,

1563
01:30:23,080 --> 01:30:26,380
so the bandwidth should be roughly the same, or no.

1564
01:30:26,380 --> 01:30:29,770
No, okay for every packet received correctly by the primary,

1565
01:30:29,770 --> 01:30:32,170
you know that packet has to be forwarded to the backup,

1566
01:30:33,040 --> 01:30:35,470
for every response you know backup the left wait

1567
01:30:35,500 --> 01:30:36,370
for the primary has to wait

1568
01:30:36,370 --> 01:30:38,410
until the output rule is satisfied,

1569
01:30:38,410 --> 01:30:39,850
then it can send a response.

1570
01:30:41,850 --> 01:30:46,140
So there's some lag processing on the backups,

1571
01:30:46,230 --> 01:30:49,380
backup server to before getting back to the primary.

1572
01:30:49,380 --> 01:30:51,630
Yeah, so they talk a little bit about that, correctly,

1573
01:30:51,630 --> 01:30:53,370
the particular processing that needs to be done is,

1574
01:30:53,370 --> 01:30:57,780
actually acknowledging the reception of the packet on the logging channel.

1575
01:30:58,320 --> 01:31:02,160
And they talk a little bit about how to reduce the delay

1576
01:31:02,460 --> 01:31:05,250
to make sure that sort of acknowledgment is very quick.

1577
01:31:06,700 --> 01:31:09,310
I see, I see okay, thank you.

1578
01:31:09,520 --> 01:31:12,610
I have a question about the logging channel,

1579
01:31:12,640 --> 01:31:15,880
so they they mentioned that they use UDP,

1580
01:31:15,910 --> 01:31:18,670
and I assume that's mostly for performance,

1581
01:31:19,000 --> 01:31:23,860
but then so basically if a single failure happens, the primary,

1582
01:31:24,360 --> 01:31:26,850
if a single packet is unacknowledged,

1583
01:31:27,120 --> 01:31:29,220
then it assumes that the backup failed,

1584
01:31:29,490 --> 01:31:31,080
without any like retransmission.

1585
01:31:31,290 --> 01:31:35,220
No, no, yeah, because there's a timer interrupt,

1586
01:31:35,690 --> 01:31:39,290
and the timer interrupt goes off like every ten milliseconds or something,

1587
01:31:39,680 --> 01:31:42,980
there's always multiple packet,

1588
01:31:43,280 --> 01:31:44,270
one packet sent,

1589
01:31:44,270 --> 01:31:47,570
that packet doesn't get no heartbeat coming back,

1590
01:31:47,900 --> 01:31:50,390
then it will do a couple of these time interrupt,

1591
01:31:50,390 --> 01:31:51,170
before it gives up.

1592
01:31:52,000 --> 01:31:56,910
Okay, and the heartbeats, are they [] from the primary

1593
01:31:56,910 --> 01:32:00,270
or it was going to apply it from somewhere else in the system.

1594
01:32:00,420 --> 01:32:01,920
Well, they sort of come from the timer,

1595
01:32:01,920 --> 01:32:05,340
when the heartbeat basically an indirect side effect,

1596
01:32:05,340 --> 01:32:06,750
because every ten milliseconds,

1597
01:32:06,750 --> 01:32:09,720
you're gonna send an interrupt message to the over logging channel anyway.

1598
01:32:12,440 --> 01:32:14,060
I see, okay.

1599
01:32:16,020 --> 01:32:17,160
Alright, thank you.

1600
01:32:17,490 --> 01:32:18,120
You're welcome.

1601
01:32:21,570 --> 01:32:23,490
Actually I wanted to follow up on that,

1602
01:32:23,490 --> 01:32:27,960
I think it said that it's gonna wait a couple a few seconds.

1603
01:32:28,450 --> 01:32:30,580
Yeah, yeah, it can wait a while,

1604
01:32:30,580 --> 01:32:32,830
you know they do a couple of heartbeats and wait a while,

1605
01:32:32,830 --> 01:32:34,690
and if they're really, none of them come through,

1606
01:32:34,720 --> 01:32:35,530
then it will stop.

1607
01:32:36,590 --> 01:32:40,610
Okay, and is a few seconds that's a lot, right.

1608
01:32:41,180 --> 01:32:42,800
I don't remember exactly all the numbers,

1609
01:32:42,860 --> 01:32:44,480
so you could be right in a few seconds,

1610
01:32:44,480 --> 01:32:46,610
I would imagine a bit shorter, but maybe it's not.

1611
01:32:47,250 --> 01:32:51,390
I think, I'd like something in the order of a few seconds,

1612
01:32:51,390 --> 01:32:53,480
but is it bad?

1613
01:32:53,510 --> 01:32:55,880
That much longer for the cloning,

1614
01:32:56,870 --> 01:32:59,660
but you know I can't remember it like.

