1
00:00:05,230 --> 00:00:07,390
Alright, well, it's five after,

2
00:00:07,390 --> 00:00:09,070
so I'll just go ahead started.

3
00:00:09,310 --> 00:00:13,600
So today's lecture is the Q&A on the first lab,

4
00:00:13,600 --> 00:00:14,620
the MapReduce lab,

5
00:00:14,920 --> 00:00:19,480
and also some just general coding Q&As for Go programming,

6
00:00:19,480 --> 00:00:21,010
that might help in future labs.

7
00:00:21,100 --> 00:00:23,110
So feel free to stop at any time

8
00:00:23,110 --> 00:00:24,430
or put questions in the chat,

9
00:00:24,430 --> 00:00:26,620
and I'll be checking it occasionally,

10
00:00:27,280 --> 00:00:31,000
and I'm sure like other [] can also help as well,

11
00:00:31,570 --> 00:00:33,970
if you are unmuted and typing,

12
00:00:34,340 --> 00:00:35,480
it would be helpful if you muted,

13
00:00:37,760 --> 00:00:38,660
but yeah.

14
00:00:38,750 --> 00:00:41,000
Alright, so the agenda for today,

15
00:00:41,000 --> 00:00:42,440
the first thing I'm going to do is,

16
00:00:42,440 --> 00:00:44,600
actually walk through a solution of lab 1,

17
00:00:44,900 --> 00:00:47,330
and this is my personal solution,

18
00:00:47,330 --> 00:00:49,370
it's probably not perfect,

19
00:00:49,370 --> 00:00:52,040
but it's an example of what you could have done,

20
00:00:52,460 --> 00:00:56,150
second, we're going to discuss some alternative solution designs,

21
00:00:56,810 --> 00:01:00,740
someone is still typing.

22
00:01:00,740 --> 00:01:01,550
[], stop typing.

23
00:01:02,980 --> 00:01:07,000
Alright, it's helpful to, [],

24
00:01:07,300 --> 00:01:12,250
third, we're going to discuss some of the common design mistakes and some of the bugs,

25
00:01:12,250 --> 00:01:14,620
that you guys had in your solutions,

26
00:01:14,980 --> 00:01:17,770
four, just over some general tips,

27
00:01:17,770 --> 00:01:22,180
and then finally we're going to, if there's time, go to some Q&As,

28
00:01:22,180 --> 00:01:24,730
both questions you might have right now

29
00:01:24,790 --> 00:01:30,660
and also questions that you submitted before lecture.

30
00:01:31,750 --> 00:01:35,590
So first for the lab solution walkthrough,

31
00:01:35,680 --> 00:01:38,800
let me know if the fonts too small,

32
00:01:38,800 --> 00:01:40,210
I'll just stick with this.

33
00:01:40,950 --> 00:01:46,400
Alright, so I basically, one step by step,

34
00:01:46,400 --> 00:01:48,500
and I'll show how I developed my solution.

35
00:01:48,770 --> 00:01:51,530
So the first thing I did was,

36
00:01:51,800 --> 00:01:53,630
this is rpc.go,

37
00:01:53,960 --> 00:01:56,960
and the first thing I did was figure out the API,

38
00:01:56,960 --> 00:01:59,840
in which I wanted my worker and coordinator to communicate,

39
00:02:00,530 --> 00:02:06,050
and so the first thing I did was define what types of tasks there are,

40
00:02:06,470 --> 00:02:08,300
and so there Map and Reduce tasks,

41
00:02:08,300 --> 00:02:10,430
and in order to signal that,

42
00:02:10,550 --> 00:02:14,390
the coordinator has, things the is done, is the Done task,

43
00:02:14,940 --> 00:02:17,130
and so, these are the types of task.

44
00:02:17,820 --> 00:02:21,570
Zoom in a bit, can you zoom in a bit, the files?

45
00:02:21,570 --> 00:02:24,330
Yeah, is that okay?

46
00:02:26,410 --> 00:02:28,090
Yeah, thanks.

47
00:02:29,060 --> 00:02:32,750
Cool, yeah, it's hard for me to tell how it looked,

48
00:02:33,740 --> 00:02:35,930
yeah, so I hopefully this is good.

49
00:02:36,200 --> 00:02:42,550
And so the there two RPCs I decided to implement,

50
00:02:42,730 --> 00:02:46,390
the first is a worker asking the coordinator to give it a task,

51
00:02:46,540 --> 00:02:49,960
so one of Map Reduce or Done in please exit,

52
00:02:50,290 --> 00:02:53,830
and basically there's like the argument,

53
00:02:53,830 --> 00:02:57,400
you know don't really have any arguments or just asking for a task,

54
00:02:57,430 --> 00:03:01,420
and the coordinator replies with what task is this,

55
00:03:01,450 --> 00:03:04,240
which task of that type should you do,

56
00:03:05,240 --> 00:03:10,220
and also some extra data that's needed for the Map or Reduce tasks,

57
00:03:10,220 --> 00:03:12,590
such as the number of Map tasks in the system

58
00:03:12,680 --> 00:03:14,300
or the number of Reduce tasks.

59
00:03:15,380 --> 00:03:19,040
And the second RPC is a finished task RPC,

60
00:03:19,070 --> 00:03:21,680
that the worker uses to notify the coordinator,

61
00:03:21,980 --> 00:03:23,660
that it has finished the task,

62
00:03:23,720 --> 00:03:27,860
and it passes as arguments which task has finished,

63
00:03:28,450 --> 00:03:31,150
and they don't actually really need to get a reply for this.

64
00:03:32,000 --> 00:03:34,820
So that's the first step of the implementation,

65
00:03:38,390 --> 00:03:39,350
so [].

66
00:03:40,190 --> 00:03:42,320
Alright, so as a second step,

67
00:03:42,350 --> 00:03:45,740
what I did is implement the handlers for all these RPCs,

68
00:03:45,980 --> 00:03:47,900
and so that's in coordinator,

69
00:03:49,070 --> 00:03:53,870
so, first I had to actually populate the coordinator with the coordinator state

70
00:03:54,200 --> 00:03:57,830
and so there's the Mutex, which protects the state from concurrent access,

71
00:03:57,830 --> 00:04:01,880
because the coordinator will have multiple threads running concurrently,

72
00:04:02,180 --> 00:04:07,880
then the second part is to keep track of just like the files that we need for Map task,

73
00:04:08,030 --> 00:04:09,860
and the number of Map and Reduce tasks,

74
00:04:10,510 --> 00:04:16,780
and this metadata is used to track which tasks have we issued,

75
00:04:16,930 --> 00:04:18,580
and which tasks have finished,

76
00:04:18,880 --> 00:04:23,050
the once that we've issued, we keep track of the timestamps,

77
00:04:23,050 --> 00:04:26,320
that we know if these tasks haven't completed within a certain amount of time,

78
00:04:26,320 --> 00:04:27,520
to reissue them,

79
00:04:28,390 --> 00:04:32,500
and finally we have the, like has all,

80
00:04:32,680 --> 00:04:35,050
has a coordinator finished boolean.

81
00:04:36,780 --> 00:04:40,320
So to handle the GetTask RPC, we have a handler,

82
00:04:40,590 --> 00:04:44,310
that essentially what it does is,

83
00:04:44,430 --> 00:04:46,380
it will set the reply fields,

84
00:04:46,650 --> 00:04:51,540
right now, I haven't yet implemented the part, that actually issues the task,

85
00:04:51,990 --> 00:04:55,050
and if all the Map and Reduce tasks are done,

86
00:04:55,140 --> 00:04:58,230
it will send a Done task to the worker and exit.

87
00:04:59,190 --> 00:05:05,520
And then we have the the handler for the FinishedTask RPC,

88
00:05:05,820 --> 00:05:07,080
and what this does is,

89
00:05:07,080 --> 00:05:10,290
it basically depending on what task it was,

90
00:05:10,920 --> 00:05:13,980
set that flag to true,

91
00:05:13,980 --> 00:05:16,410
that has that task has finished.

92
00:05:17,550 --> 00:05:19,020
So that's the second step,

93
00:05:19,020 --> 00:05:21,240
which is implementing the handlers with RPCs.

94
00:05:24,120 --> 00:05:28,890
So the third step I have is actually sending the RPCs,

95
00:05:29,610 --> 00:05:33,890
and so that happened is the work here.

96
00:05:35,930 --> 00:05:41,690
So, top of this is,

97
00:05:41,990 --> 00:05:44,000
we provided what it does is,

98
00:05:44,000 --> 00:05:45,200
it starts up this loop,

99
00:05:45,560 --> 00:05:48,320
that basically for every loop,

100
00:05:48,320 --> 00:05:52,160
it calls the handler for GetTask in the coordinator,

101
00:05:52,760 --> 00:05:54,470
and depending on what task it gets,

102
00:05:54,470 --> 00:05:58,430
it will either perform Map task with the relevant data

103
00:05:58,430 --> 00:06:01,310
or metadata that needs perform the Reduce task,

104
00:06:01,310 --> 00:06:02,990
or in the case of done, it will exit.

105
00:06:03,570 --> 00:06:05,670
And so it's very simple,

106
00:06:05,670 --> 00:06:06,960
and once it's finished that task,

107
00:06:07,170 --> 00:06:11,070
it will send a FinishedTask RPC to the coordinator.

108
00:06:11,620 --> 00:06:17,650
So this is just the skeleton code for the worker sending RPCs.

109
00:06:19,100 --> 00:06:21,950
Alright, so we have RPCs, we have handlers, we have the senders,

110
00:06:22,160 --> 00:06:24,800
and so now, let's actually implement some stuff.

111
00:06:25,220 --> 00:06:29,900
So in step four,

112
00:06:29,930 --> 00:06:35,990
it's I just added a ton of handlers to manage this intermediate file,

113
00:06:36,590 --> 00:06:38,780
which a lot of you also did,

114
00:06:39,200 --> 00:06:41,990
and basically it uses like os.Rename,

115
00:06:41,990 --> 00:06:43,730
it gets a temporary file,

116
00:06:44,900 --> 00:06:46,550
so it's not too interesting,

117
00:06:47,150 --> 00:06:48,530
and then the next step,

118
00:06:48,560 --> 00:06:51,890
let's actually implement some of the worker functionality.

119
00:06:52,430 --> 00:06:54,930
So, we're back in the worker,

120
00:06:55,900 --> 00:06:58,930
and now let's implement the performMap function,

121
00:07:00,270 --> 00:07:04,740
and what this does is, as many you have to do is

122
00:07:04,770 --> 00:07:07,650
read the file, map them to keys,

123
00:07:07,710 --> 00:07:12,360
and then create temporary files, write them to the intermediate files,

124
00:07:12,360 --> 00:07:15,000
and then we use an atomic rename

125
00:07:15,030 --> 00:07:17,520
to ensure that maps aren't conflicting

126
00:07:17,520 --> 00:07:19,590
as they process the keys and write them.

127
00:07:20,550 --> 00:07:25,410
So this is pretty much taken from the sequential implementation

128
00:07:25,440 --> 00:07:27,390
and how you would apply the Map function.

129
00:07:28,590 --> 00:07:34,590
And then similarly, we implement the Reduce function,

130
00:07:34,860 --> 00:07:36,780
so here's a performMap,

131
00:07:36,900 --> 00:07:38,640
and then we have performReduce,

132
00:07:39,000 --> 00:07:40,440
and so what that does is,

133
00:07:40,440 --> 00:07:44,040
it gets all the intermediate files with the appropriate,

134
00:07:44,340 --> 00:07:47,850
from all the Map tasks, for this Reduce tasks,

135
00:07:48,510 --> 00:07:54,640
and sorts them, so sorting happens in the, in the worker,

136
00:07:54,670 --> 00:07:56,710
because the worker needs,

137
00:07:56,800 --> 00:08:00,070
the reducer needs access to all keys of that type,

138
00:08:00,100 --> 00:08:01,840
and then to sort them.

139
00:08:03,240 --> 00:08:04,770
It wouldn't make sense for the mapper,

140
00:08:04,770 --> 00:08:05,880
just sort them before,

141
00:08:05,910 --> 00:08:08,940
because the mapper only has access some the keys.

142
00:08:10,440 --> 00:08:13,860
And then we apply the reduce function to all values of the same key,

143
00:08:13,860 --> 00:08:19,080
and then we atomically rename the temporary reduce file to the final reduce file.

144
00:08:20,470 --> 00:08:24,370
So, now this loop we've implemented basically,

145
00:08:25,000 --> 00:08:27,190
the actual perform the task,

146
00:08:27,220 --> 00:08:30,670
and we're basically done with the worker implementation.

147
00:08:31,820 --> 00:08:33,350
So one last step remains,

148
00:08:33,410 --> 00:08:35,390
and that's actually implementing,

149
00:08:35,390 --> 00:08:39,260
how this coordinator tells the worker which tasks to do,

150
00:08:39,620 --> 00:08:41,030
and this is probably

151
00:08:41,030 --> 00:08:46,940
where you ran into the most complexity with synchronization in the coordinator.

152
00:08:49,040 --> 00:08:50,450
So, go back to the coordinator,

153
00:08:51,500 --> 00:08:54,590
so nothing has changed in the state,

154
00:08:55,010 --> 00:08:56,720
so, but now what we've done is,

155
00:08:56,720 --> 00:08:58,700
we've added a loop in the coordinator,

156
00:08:58,730 --> 00:09:01,310
that handles sending the task to the worker.

157
00:09:02,720 --> 00:09:07,170
And when we're issuing the Map task,

158
00:09:07,170 --> 00:09:09,420
so first we want to issue all the Map task,

159
00:09:09,780 --> 00:09:14,010
and so essentially what this loop does here is,

160
00:09:14,040 --> 00:09:16,650
until there's a task to issue,

161
00:09:16,830 --> 00:09:21,930
the coordinator will just iterate to this loop,

162
00:09:22,200 --> 00:09:23,910
and if we're done with all the Map tasks,

163
00:09:23,910 --> 00:09:24,990
that will break out the loop,

164
00:09:26,730 --> 00:09:28,560
and then, if all the Map tasks are done,

165
00:09:28,560 --> 00:09:30,150
then we issue Reduce task,

166
00:09:31,080 --> 00:09:32,310
which is what's in here.

167
00:09:35,380 --> 00:09:40,750
So, yeah, I have, I guess I have one last step,

168
00:09:40,750 --> 00:09:43,390
which is actually what we do,

169
00:09:43,390 --> 00:09:48,070
when the maps or reduces, when there's no task to issue

170
00:09:48,100 --> 00:09:49,960
and so we want to do then,

171
00:09:50,050 --> 00:09:53,680
is the coordinator should just wait for a task issue,

172
00:09:53,950 --> 00:09:56,920
and once it, there's a task issue,

173
00:09:56,920 --> 00:09:58,690
or to another issue iteration the loop

174
00:09:58,720 --> 00:10:00,940
and then actually issue the task.

175
00:10:01,650 --> 00:10:05,010
I'll continue until all the Map were all Reduce tasks are done,

176
00:10:06,720 --> 00:10:08,550
and after done, I'll return again,

177
00:10:08,580 --> 00:10:10,380
so let me go to.

178
00:10:13,620 --> 00:10:18,360
Right, so in order to support that waiting,

179
00:10:19,640 --> 00:10:23,360
what my solution does is it uses a condition variable,

180
00:10:24,610 --> 00:10:29,650
and essentially what that does is,

181
00:10:29,890 --> 00:10:32,890
if there are no Map task issue,

182
00:10:33,250 --> 00:10:37,690
but the mappers, but there,

183
00:10:37,840 --> 00:10:40,360
because we've assigned all of them, for example,

184
00:10:40,390 --> 00:10:41,470
and we're waiting for them,

185
00:10:41,500 --> 00:10:43,360
and they haven't timed out yet,

186
00:10:43,450 --> 00:10:45,610
then we want to do is wait,

187
00:10:45,670 --> 00:10:49,210
because we cannot issue a Reduce task,

188
00:10:49,210 --> 00:10:50,740
if all the mappers have not finished,

189
00:10:51,040 --> 00:10:53,290
so we're just going to wait here,

190
00:10:53,410 --> 00:10:56,410
and then once we get some type of signal,

191
00:10:56,470 --> 00:10:58,780
we're just going to go back to the top of this loop,

192
00:10:59,130 --> 00:11:01,050
and check whether we can issue a task again.

193
00:11:02,510 --> 00:11:06,170
Similarly, if all the reducers aren't done,

194
00:11:06,170 --> 00:11:08,990
but we can't actually issue the worker a task,

195
00:11:09,020 --> 00:11:12,680
we're going to wait for there to be some type of signals,

196
00:11:12,680 --> 00:11:14,810
so when does the signal actually happen?

197
00:11:15,380 --> 00:11:19,250
Well, we want to signal any time

198
00:11:19,400 --> 00:11:23,300
either a task has done or for too long and we haven't heard back,

199
00:11:23,300 --> 00:11:24,710
so there might have been a failure,

200
00:11:25,430 --> 00:11:29,960
or if the, if a worker has actually completed a task,

201
00:11:29,960 --> 00:11:33,050
because for example that might mean all the Map tasks has finished,

202
00:11:33,050 --> 00:11:34,580
we can move on to a Reduce task.

203
00:11:35,430 --> 00:11:39,210
So in order to do that,

204
00:11:39,210 --> 00:11:41,610
what we have are,

205
00:11:45,020 --> 00:11:46,490
we have a goroutine here,

206
00:11:46,520 --> 00:11:53,370
that's kind of spawn off immediately as the coordinator starts,

207
00:11:53,490 --> 00:11:56,400
and what this does is every once in awhile,

208
00:11:56,700 --> 00:12:00,780
after some you know maybe every second or so,

209
00:12:00,810 --> 00:12:02,820
when a task might have finished,

210
00:12:03,310 --> 00:12:05,260
or maybe this is ten seconds, I can't remeber,

211
00:12:05,380 --> 00:12:06,880
actually it doesn't really matter,

212
00:12:06,910 --> 00:12:09,370
it just wants to wake up the coordinator every so often,

213
00:12:09,370 --> 00:12:11,710
so the coordinator will do another check

214
00:12:11,860 --> 00:12:13,960
to see whether there is a task to issue,

215
00:12:14,110 --> 00:12:15,640
and so it just loops around,

216
00:12:15,850 --> 00:12:19,690
and every second it will broadcast to wake up the coordinator.

217
00:12:22,620 --> 00:12:26,550
And the other time we want to signal when a task is finished,

218
00:12:26,970 --> 00:12:30,840
so that's actually going to happen in this HandleFinishedTask,

219
00:12:30,870 --> 00:12:37,140
which is called when a worker like [] FinishedTask task RPC,

220
00:12:37,680 --> 00:12:40,650
and so here we have a Broadcast

221
00:12:40,650 --> 00:12:47,250
right after we set the [] to done or to complete it to done,

222
00:12:47,730 --> 00:12:52,520
and when the coordinator goes back to go check one of these loops,

223
00:12:52,520 --> 00:12:54,950
and see whether there's a task to finish,

224
00:12:54,980 --> 00:12:58,070
it will see that updated Done status.

225
00:12:59,120 --> 00:13:02,240
So that's essentially my solution,

226
00:13:02,510 --> 00:13:09,680
it uses cond vars and Mutex to protect shared state of coordinator.

227
00:13:11,000 --> 00:13:12,920
So this is only one possible solution

228
00:13:13,520 --> 00:13:16,280
and I'll get back to here,

229
00:13:16,880 --> 00:13:21,920
and so this is the kind of layout of the steps I took.

230
00:13:22,860 --> 00:13:27,330
Are there any questions on that particular solution before I move on?

231
00:13:30,910 --> 00:13:35,200
Can you please elaborate a little more on the conditional variable?

232
00:13:36,770 --> 00:13:47,060
Sure, so, what exactly, I guess like a conditional variable is,

233
00:13:47,730 --> 00:13:48,930
very useful,

234
00:13:48,930 --> 00:13:54,870
for when you want to wait for a particular predicate or particular condition to become true,

235
00:13:55,080 --> 00:14:00,590
so in this case, condition variable is a natural,

236
00:14:00,740 --> 00:14:04,490
let me just go to where I use,

237
00:14:05,300 --> 00:14:10,970
is a natural way to implement waiting for there to be a task available,

238
00:14:11,060 --> 00:14:14,360
because you know it's a particular condition,

239
00:14:14,630 --> 00:14:19,210
and it occurs asynchronously,

240
00:14:19,210 --> 00:14:22,240
so for example a task is available,

241
00:14:22,270 --> 00:14:25,180
when a worker has finished a task,

242
00:14:25,510 --> 00:14:33,910
or task might be available when the, when a failure occurs,

243
00:14:33,910 --> 00:14:35,710
and we need to reissue the task,

244
00:14:35,800 --> 00:14:37,540
so you can think of,

245
00:14:38,140 --> 00:14:44,790
any case in which, you need to wait for a particular condition,

246
00:14:44,820 --> 00:14:48,000
that's where condition variables become very helpful.

247
00:14:48,840 --> 00:14:51,000
Does that help a little bit?

248
00:14:51,970 --> 00:14:53,080
Yeah, thank you.

249
00:14:56,000 --> 00:14:57,110
You can also,

250
00:14:57,170 --> 00:15:00,590
like all of these higher level,

251
00:15:00,590 --> 00:15:03,110
like channels, condition variables,

252
00:15:03,110 --> 00:15:05,600
all these higher level synchronization primitives actually,

253
00:15:05,600 --> 00:15:07,730
they're built on top of locks,

254
00:15:07,850 --> 00:15:10,040
so they're all implemented using locks,

255
00:15:10,040 --> 00:15:11,420
is just there,

256
00:15:12,430 --> 00:15:15,400
kind of a higher level way of thinking about synchronization,

257
00:15:15,400 --> 00:15:18,130
that allows you to [reason] for example about conditions.

258
00:15:22,050 --> 00:15:24,330
Would that have the same effect,

259
00:15:24,330 --> 00:15:27,870
as for example sleeping in that loop,

260
00:15:27,870 --> 00:15:31,710
that you have in the GetTask function

261
00:15:31,710 --> 00:15:35,100
instead of like having a condition variable,

262
00:15:35,850 --> 00:15:39,420
that makes the loop run every second,

263
00:15:40,250 --> 00:15:40,700
I guess.

264
00:15:40,700 --> 00:15:45,860
Yeah, so, it it is, like it's essentially the same as sleeping,

265
00:15:45,890 --> 00:15:54,780
the, so the loop here, the timeout loop here,

266
00:15:55,780 --> 00:15:57,940
the difference is that,

267
00:15:58,970 --> 00:16:01,700
for example, the condition variable,

268
00:16:01,700 --> 00:16:05,600
or you could be woken up by a task that has completed,

269
00:16:06,140 --> 00:16:10,880
where in a loop, in which you sleep for example a second every single loop,

270
00:16:11,210 --> 00:16:13,220
you have to wait a second,

271
00:16:13,830 --> 00:16:15,750
whereas with a condition variable,

272
00:16:15,750 --> 00:16:19,250
you could be woken up after you know like ten milliseconds,

273
00:16:19,250 --> 00:16:21,380
because the worker has completed a task,

274
00:16:21,650 --> 00:16:25,760
so it potentially has better liveness properties.

275
00:16:27,800 --> 00:16:30,200
By this case, we do like say,

276
00:16:30,200 --> 00:16:35,230
if every task always takes over like five seconds or something,

277
00:16:35,290 --> 00:16:41,830
then yes, this is essentially very similar to sleeping for one second every loop.

278
00:16:43,680 --> 00:16:45,930
I have a question,

279
00:16:45,930 --> 00:16:47,880
I think I missed the part where you run,

280
00:16:48,580 --> 00:16:52,960
how you handle, when a request comes for a task,

281
00:16:52,960 --> 00:16:55,870
but you're like there's no tasks to give out currently,

282
00:16:55,870 --> 00:17:00,070
like you, how do you tell the worker to like sort of either come back

283
00:17:00,070 --> 00:17:01,720
or do you keep them waiting

284
00:17:01,750 --> 00:17:04,960
and sort of [tangentially] to that,

285
00:17:05,860 --> 00:17:10,030
I'm curious why you chose this like sleep way of doing it,

286
00:17:10,030 --> 00:17:14,920
instead of just like checking the time when you get request for tasks,

287
00:17:14,920 --> 00:17:17,520
and seeing, like when you get a request,

288
00:17:17,520 --> 00:17:19,470
what has timed out and reissuing it,

289
00:17:20,320 --> 00:17:23,500
then instead of like constanly checking.

290
00:17:24,160 --> 00:17:26,050
Yeah, okay, so,

291
00:17:26,790 --> 00:17:29,940
yeah, so I'll just your first question first,

292
00:17:30,330 --> 00:17:36,150
so basically how I handle the completed the task,

293
00:17:37,020 --> 00:17:42,260
is once all Map tasks have finished,

294
00:17:42,260 --> 00:17:44,750
once all Reduce tasks have finished,

295
00:17:44,810 --> 00:17:48,680
then the task that we return to the worker,

296
00:17:48,830 --> 00:17:52,160
because the worker has called us task for task

297
00:17:52,190 --> 00:17:55,670
is this extra task type, that I called Done,

298
00:17:56,680 --> 00:18:01,510
and then I also set that the coordinator isDone to true,

299
00:18:02,230 --> 00:18:03,730
and so in the workers,

300
00:18:03,730 --> 00:18:04,390
I'll go to the worker,

301
00:18:05,530 --> 00:18:09,940
and the worker we have this loop,

302
00:18:09,940 --> 00:18:13,540
that basically as the worker is asking for tasks,

303
00:18:13,930 --> 00:18:18,250
if it that returned tasks is a Done task, then it exits.

304
00:18:18,680 --> 00:18:21,950
So that's how I handle conveying to the worker,

305
00:18:21,950 --> 00:18:23,540
that it should exit.

306
00:18:23,570 --> 00:18:25,280
I guess I was asking like,

307
00:18:25,310 --> 00:18:30,110
sorry, if you know let's say you're still finishing up on your Map tasks,

308
00:18:30,560 --> 00:18:32,780
and you get requests for a task,

309
00:18:33,170 --> 00:18:35,210
and you still can't give out your Reduce tasks,

310
00:18:35,630 --> 00:18:37,160
how do you tell the worker?

311
00:18:38,060 --> 00:18:42,850
Oh, so, a lot of you are,

312
00:18:43,000 --> 00:18:45,760
an alternative design is to,

313
00:18:45,850 --> 00:18:49,120
basically if the worker, if there's no task to give the worker,

314
00:18:49,570 --> 00:18:54,130
then the coordinator returns a reply to the worker immediately,

315
00:18:54,370 --> 00:18:56,470
and the worker sleeps in its loop,

316
00:18:56,770 --> 00:18:58,990
but you can see here, right,

317
00:18:58,990 --> 00:19:00,820
the worker loop, there is no sleep,

318
00:19:01,820 --> 00:19:03,260
and the reason for this is,

319
00:19:03,260 --> 00:19:08,150
because this call will block until the coordinator replies,

320
00:19:09,130 --> 00:19:10,420
and in my solution,

321
00:19:11,490 --> 00:19:13,200
going back to the coordinator,

322
00:19:13,560 --> 00:19:15,900
for example like if you look at mapDone,

323
00:19:17,180 --> 00:19:25,040
in this solution, the coordinator handler will not return that reply to that call,

324
00:19:25,250 --> 00:19:28,430
unless it has a task to return,

325
00:19:28,820 --> 00:19:33,710
so it's, we're waiting in the coordinator rather than in the worker.

326
00:19:34,660 --> 00:19:37,180
So the coordinator is the one,

327
00:19:37,360 --> 00:19:42,280
that is constantly checking to see whether there's a task and sleeping,

328
00:19:42,400 --> 00:19:46,720
whereas the worker just simply blocks on this call,

329
00:19:47,220 --> 00:19:49,080
until the coordinator returns to it.

330
00:19:49,690 --> 00:19:54,700
Is there any advantage to doing it in the coordinator?

331
00:19:59,550 --> 00:20:02,670
So I think one advantage is that,

332
00:20:04,940 --> 00:20:09,330
all the workers aren't constantly sending RPCs,

333
00:20:09,600 --> 00:20:10,590
you send an RPC,

334
00:20:10,590 --> 00:20:13,290
it's one RPC per task, right,

335
00:20:13,920 --> 00:20:18,180
whereas if the worker is constantly looping and sleeping and constantly reply,

336
00:20:18,180 --> 00:20:19,890
you have a lot more network traffic.

337
00:20:20,660 --> 00:20:21,260
Okay.

338
00:20:21,620 --> 00:20:26,510
Yeah, I think that's, but definitely both solutions are feasible,

339
00:20:26,510 --> 00:20:27,710
and they both work.

340
00:20:28,510 --> 00:20:29,260
Great.

341
00:20:29,580 --> 00:20:32,130
I had one other question,

342
00:20:32,130 --> 00:20:38,640
which is I I I see you use a defer for the locking quite a bit,

343
00:20:39,930 --> 00:20:41,880
while I was doing my implementation,

344
00:20:41,880 --> 00:20:43,050
I I realized,

345
00:20:43,050 --> 00:20:45,450
I mean in a straightforward function,

346
00:20:45,450 --> 00:20:47,140
it, it's clear,

347
00:20:47,170 --> 00:20:49,630
when it gives up control of the lock,

348
00:20:50,210 --> 00:20:59,210
but for example if you, like have a goroutine created from within the function,

349
00:21:00,020 --> 00:21:03,680
it's not very clear, when it gives up control.

350
00:21:05,100 --> 00:21:07,770
So, a goroutine runs on a separate thread,

351
00:21:07,770 --> 00:21:11,220
so the goroutine never starts with the lock acquired,

352
00:21:11,220 --> 00:21:14,370
even if you spin off the goroutine, while you hold the lock.

353
00:21:14,640 --> 00:21:15,570
Okay.

354
00:21:15,870 --> 00:21:16,560
Yeah.

355
00:21:16,920 --> 00:21:21,030
If we, if we issue like a Go, if we create a goroutine,

356
00:21:21,090 --> 00:21:22,890
it'll just spin up a thread,

357
00:21:23,040 --> 00:21:26,340
and from the beginning, it won't have a lock, right?

358
00:21:26,340 --> 00:21:28,680
Yeah, it's actually just like,

359
00:21:29,150 --> 00:21:30,620
you know you think about another thread

360
00:21:30,620 --> 00:21:34,160
just starting to run that Go, like Go func, that function.

361
00:21:35,720 --> 00:21:36,950
Yeah.

362
00:21:37,700 --> 00:21:38,240
Yeah, go ahead.

363
00:21:38,480 --> 00:21:44,090
And then defer unlocks at any return, like any return statement there?

364
00:21:44,730 --> 00:21:47,340
Yep, yeah, it's pushed onto a,

365
00:21:47,490 --> 00:21:51,840
like basically like the functions to run when the,

366
00:21:52,380 --> 00:21:53,730
there's a stack of functions,

367
00:21:53,730 --> 00:21:58,610
that the returning from like HandleGetTask will run,

368
00:21:59,060 --> 00:22:01,940
so, I also have this in the slides,

369
00:22:01,940 --> 00:22:03,530
so you'll be able to refer to this later,

370
00:22:03,830 --> 00:22:07,400
but defer just ensures that when this function exits,

371
00:22:07,760 --> 00:22:09,680
you over you around unlock,

372
00:22:09,710 --> 00:22:16,280
and then I could also do something, like unlocking,

373
00:22:17,240 --> 00:22:24,510
and like I could just do something, like before the last printf or println,

374
00:22:25,110 --> 00:22:28,110
so these are all pushed onto a stack,

375
00:22:28,140 --> 00:22:32,640
and then they're popped off in FIFO order, no, LIFO order.

376
00:22:33,470 --> 00:22:35,420
What FIFO?

377
00:22:36,490 --> 00:22:44,240
First in first out, no they're run in last in first out, yeah,

378
00:22:44,720 --> 00:22:45,800
so it's a stack right,

379
00:22:45,800 --> 00:22:50,440
so this will run before unlocking,

380
00:22:50,440 --> 00:22:53,230
which will actually run before the lock,

381
00:22:53,260 --> 00:22:55,360
so if you're ready to use multiple defers,

382
00:22:55,360 --> 00:22:57,340
be careful in the order, then use them,

383
00:22:57,550 --> 00:23:01,720
but defer the unlock at least is a very useful strategy,

384
00:23:03,260 --> 00:23:04,280
that will come in handy.

385
00:23:05,040 --> 00:23:08,250
Okay, so the last thing is,

386
00:23:08,280 --> 00:23:16,730
if we call a function within within our our function,

387
00:23:16,760 --> 00:23:18,200
where we acquire the lock,

388
00:23:18,320 --> 00:23:20,720
it doesn't return the lock, right,

389
00:23:21,170 --> 00:23:23,360
when it goes to the other function,

390
00:23:23,780 --> 00:23:25,820
the other function returns to this function,

391
00:23:26,600 --> 00:23:32,690
and then until we, like the thread keeps a lock, like through like jumping around.

392
00:23:34,880 --> 00:23:36,380
Yeah, so like a function,

393
00:23:36,380 --> 00:23:39,260
that's just like a normal function call within one thread,

394
00:23:39,350 --> 00:23:42,050
will be called with the lock out, yes.

395
00:23:43,570 --> 00:23:44,470
Cool, thanks.

396
00:23:46,360 --> 00:23:46,750
Yep.

397
00:23:48,540 --> 00:23:50,940
Alright, so you guys have already kind of discussed

398
00:23:50,940 --> 00:23:53,130
some of the alternate synchronization designs,

399
00:23:53,520 --> 00:23:56,370
like waiting in the worker rather than the coordinator,

400
00:23:56,370 --> 00:23:58,410
and we've talked about some of the pros and cons of that,

401
00:23:58,900 --> 00:24:00,040
using time,

402
00:24:00,070 --> 00:24:02,800
actually I think already covered all of these except for channels maybe,

403
00:24:04,640 --> 00:24:06,950
so there's one thing I wanted to know,

404
00:24:06,950 --> 00:24:08,810
because there are a couple questions about this,

405
00:24:09,020 --> 00:24:11,630
so waiting for map has to be done

406
00:24:11,630 --> 00:24:15,050
or like any synchronization that we've shown

407
00:24:15,350 --> 00:24:17,150
is on a single server,

408
00:24:17,210 --> 00:24:21,470
so cross-server communication between the worker and the coordinator,

409
00:24:22,250 --> 00:24:25,340
they're only, it's only done ever by RPCs,

410
00:24:25,520 --> 00:24:27,920
so for example like locking in the coordinator

411
00:24:27,920 --> 00:24:29,930
has nothing to do with locking on the worker,

412
00:24:30,110 --> 00:24:33,560
or on interactive implementation locking on different servers,

413
00:24:33,980 --> 00:24:36,170
like don't interfere with each other,

414
00:24:37,110 --> 00:24:38,490
I just want to be clear about that.

415
00:24:39,270 --> 00:24:42,510
So one thing I thought would be interesting is,

416
00:24:42,510 --> 00:24:47,150
for you to see a kind of an example using channels,

417
00:24:47,150 --> 00:24:50,780
because there are also some questions using channels, about using channels.

418
00:24:51,680 --> 00:24:54,200
So this is kind of,

419
00:24:54,200 --> 00:24:59,600
is a not complete implementation of using channels,

420
00:24:59,810 --> 00:25:02,690
but it's a potential way to,

421
00:25:03,160 --> 00:25:06,310
but you could think about having used channels in MapReduce.

422
00:25:06,910 --> 00:25:09,160
And so in this example,

423
00:25:09,340 --> 00:25:12,910
the input to the coordinator actually includes a channel,

424
00:25:13,530 --> 00:25:18,840
in which the coordinator is told of what workers exist,

425
00:25:19,140 --> 00:25:25,480
and this is to handle the possibility that workers are failing,

426
00:25:25,510 --> 00:25:28,690
and then some client is telling the coordinator,

427
00:25:28,690 --> 00:25:30,850
hey, this other worker joined our cluster,

428
00:25:30,880 --> 00:25:33,100
here's a new worker, that you can give tasks to,

429
00:25:33,310 --> 00:25:36,970
so it's slightly different than what we had in the lab.

430
00:25:37,950 --> 00:25:41,820
So the coordinator has two channels,

431
00:25:42,440 --> 00:25:47,480
one in which it will send tasks to workers

432
00:25:47,600 --> 00:25:50,150
or it won't send tasks to workers,

433
00:25:50,150 --> 00:25:54,110
will send tasks to a thread, that will issue tasks to workers,

434
00:25:54,860 --> 00:25:56,810
and then it has a done channel.

435
00:25:57,310 --> 00:26:00,190
So again, just like,

436
00:26:01,080 --> 00:26:03,570
I I know I said something a little strange,

437
00:26:03,570 --> 00:26:06,660
which I was like you can send tasks to workers over the channel,

438
00:26:06,660 --> 00:26:07,650
but you actually can't,

439
00:26:07,770 --> 00:26:10,860
the channel is only on the coordinator on your server,

440
00:26:11,070 --> 00:26:12,660
and we'll see how that works in a second.

441
00:26:13,660 --> 00:26:18,310
So the first thread of the coordinator that we create is a goroutine,

442
00:26:18,310 --> 00:26:25,480
that basically will for every worker, start the issueWorkerTaskThread.

443
00:26:25,980 --> 00:26:28,480
So, what this does is,

444
00:26:28,480 --> 00:26:31,360
as workers are you know coming and going,

445
00:26:31,360 --> 00:26:33,430
because they're failing and then restarting,

446
00:26:33,610 --> 00:26:35,200
this channel basically says,

447
00:26:35,200 --> 00:26:37,720
okay, we want to, for any of these workers,

448
00:26:38,020 --> 00:26:41,260
start a thread that will issue this worker tasks.

449
00:26:41,960 --> 00:26:45,200
So this is one goroutine here,

450
00:26:46,620 --> 00:26:49,020
then the coordinator what it does is it,

451
00:26:49,440 --> 00:26:50,760
for all the tasks that were giving,

452
00:26:50,760 --> 00:26:53,680
it just push those tasks onto this tasks channel,

453
00:26:54,590 --> 00:26:56,420
and this tasks channel,

454
00:26:56,420 --> 00:26:58,490
we actually made it a buffer channel,

455
00:26:58,730 --> 00:27:02,270
so that we know it will hold exactly numTask tasks,

456
00:27:02,270 --> 00:27:06,440
which are the that's the limit of the number of tasks,

457
00:27:06,470 --> 00:27:08,150
that will exist on the system,

458
00:27:08,150 --> 00:27:10,370
so what this also means is that,

459
00:27:10,370 --> 00:27:17,060
we can push the numTask tasks onto this channel without blocking,

460
00:27:17,240 --> 00:27:21,170
so the coordinator will not block on pushing task to the tasks channel.

461
00:27:22,170 --> 00:27:27,000
And then the coordinator will read from this done channel

462
00:27:27,030 --> 00:27:31,020
until it has done so numTask times,

463
00:27:31,200 --> 00:27:33,660
in which case, it knows it's done,

464
00:27:33,660 --> 00:27:37,080
in this case, where I'm not separating map or reduce tasks,

465
00:27:37,080 --> 00:27:38,520
let's just imagine that there are,

466
00:27:38,550 --> 00:27:41,610
some number of tasks that the coordinator needs to run.

467
00:27:42,700 --> 00:27:46,270
And once it knows that tasks, all the tasks have finished,

468
00:27:46,270 --> 00:27:52,450
it closes the tasks channel, and then basically will exit.

469
00:27:53,520 --> 00:27:58,740
And so the, where some of the interesting part comes in is,

470
00:27:58,980 --> 00:28:00,840
these worker task threads,

471
00:28:00,840 --> 00:28:03,540
which I've separated out and just function here.

472
00:28:04,420 --> 00:28:07,390
So, these all run on sub goroutines,

473
00:28:07,910 --> 00:28:11,360
and what it does is for,

474
00:28:11,990 --> 00:28:14,540
as long as there are tasks in the task queue,

475
00:28:14,990 --> 00:28:16,700
it will pull a task out,

476
00:28:17,180 --> 00:28:20,390
and then oops, I didn't mean to that,

477
00:28:20,540 --> 00:28:25,680
and then call basically an RPC,

478
00:28:25,680 --> 00:28:27,600
that will send the task to the worker,

479
00:28:27,990 --> 00:28:29,460
so note that,

480
00:28:29,460 --> 00:28:34,230
this channel actually is talking to another thread of the coordinator,

481
00:28:34,290 --> 00:28:40,980
and that thread is actually the one that's in charge of calling the worker,

482
00:28:42,020 --> 00:28:45,620
and then once it's done with the task, it says it's done,

483
00:28:46,620 --> 00:28:49,590
if it's not able to, if the call fails,

484
00:28:49,590 --> 00:28:51,870
for some reason, for example it times out,

485
00:28:51,990 --> 00:28:54,570
then, what this loop does is,

486
00:28:54,570 --> 00:28:57,480
it'll push that task back onto the tasks channel,

487
00:28:57,690 --> 00:29:02,010
so another worker or potentially this thread again could pick up that task.

488
00:29:03,360 --> 00:29:07,200
So just to clarify how the channel communication works,

489
00:29:07,200 --> 00:29:09,840
so the worker sends tasks on the tasks channel,

490
00:29:09,840 --> 00:29:11,550
which is read through these loops,

491
00:29:12,680 --> 00:29:18,500
and this loop will exit when the coordinator closes the channel,

492
00:29:20,090 --> 00:29:24,830
done, it's sent on these worker, issue worker threads,

493
00:29:25,940 --> 00:29:29,540
and it's read by the coordinator, the original coordinator thread

494
00:29:30,320 --> 00:29:33,020
and this exit equals true,

495
00:29:33,020 --> 00:29:35,540
will basically tell the coordinator,

496
00:29:35,540 --> 00:29:39,590
like, oh, I don't need to listen for any more workers coming or workers starting up,

497
00:29:40,020 --> 00:29:43,800
so it will cause this other goroutine to exit.

498
00:29:44,850 --> 00:29:47,370
So I know that this is a pretty complex example,

499
00:29:47,370 --> 00:29:51,570
it's also not quite what we specified in the lab,

500
00:29:51,570 --> 00:29:54,000
but as an example of how channels can be used,

501
00:29:54,060 --> 00:29:57,780
to implement something like MapReduce or something similar to MapReduce.

502
00:30:00,380 --> 00:30:02,810
There is a question in the chat,

503
00:30:02,810 --> 00:30:05,270
about where's exit define in this code?

504
00:30:08,640 --> 00:30:10,380
That is a good question,

505
00:30:10,380 --> 00:30:11,130
it's not,

506
00:30:12,060 --> 00:30:15,570
so it'll, it'll be exactly the same thing is done,

507
00:30:16,230 --> 00:30:21,970
it will just be another channel that's a boolean, yeah,

508
00:30:23,160 --> 00:30:25,620
that's a good, a good catch.

509
00:30:27,020 --> 00:30:27,740
Oh, can I?

510
00:30:27,740 --> 00:30:28,790
I've seen.

511
00:30:28,970 --> 00:30:31,640
How do you add things to the workers channel,

512
00:30:31,640 --> 00:30:33,110
or when you add things to the workers channel,

513
00:30:33,110 --> 00:30:34,730
like how do you handle them in this case?

514
00:30:35,410 --> 00:30:37,180
Yeah, so in this case,

515
00:30:37,420 --> 00:30:41,320
worker, the workers channel is provided to the coordinator,

516
00:30:41,410 --> 00:30:43,690
so imagine that, for example,

517
00:30:43,690 --> 00:30:46,780
and you know how your Coordinator

518
00:30:46,810 --> 00:30:54,930
was actually called or created by the MR coordinator in main,

519
00:30:54,960 --> 00:30:57,150
in the that [],

520
00:30:57,270 --> 00:31:01,230
so we would imagine that in MR coordinator,

521
00:31:01,230 --> 00:31:03,630
we would create a workers channel,

522
00:31:04,460 --> 00:31:08,990
and MR coordinator would basically be in charged of tracking,

523
00:31:09,140 --> 00:31:12,440
when workers crash and when workers join,

524
00:31:12,470 --> 00:31:15,170
so this is for example in a case,

525
00:31:15,170 --> 00:31:20,390
where you know maybe new servers are added to our cluster at some later point

526
00:31:20,450 --> 00:31:23,060
or some worker crashed and then came back,

527
00:31:23,090 --> 00:31:26,450
and MR coordinator would be constantly sending,

528
00:31:26,510 --> 00:31:30,230
like these worker ids to our Coordinator,

529
00:31:30,960 --> 00:31:33,480
in order to tell it, hey, like there's new worker,

530
00:31:33,480 --> 00:31:35,370
you should start issuing it tasks,

531
00:31:36,090 --> 00:31:37,620
so that part is not shown.

532
00:31:38,350 --> 00:31:41,950
Got it, yeah, I just I just wondering like,

533
00:31:41,980 --> 00:31:43,690
so that's really cool,

534
00:31:43,690 --> 00:31:47,020
I was just wondering inside the lab 1,

535
00:31:47,020 --> 00:31:51,220
like how I think it's like call worker and you've sends RPC to the worker,

536
00:31:51,700 --> 00:31:54,490
if if that's something we could have done in lab 1?

537
00:31:57,100 --> 00:31:58,900
It's possible it,

538
00:31:58,900 --> 00:32:01,810
but it definitely was not what we pushed you toward,

539
00:32:02,020 --> 00:32:04,060
because you would basically,

540
00:32:04,060 --> 00:32:07,450
instead of setting up the coordinator as being RPC server,

541
00:32:07,450 --> 00:32:11,050
you would have to set up like RPC servers on the workers,

542
00:32:11,440 --> 00:32:13,510
you can also think of,

543
00:32:13,540 --> 00:32:19,850
in this implementation, call_worker could have handlers actually for each worker,

544
00:32:20,210 --> 00:32:25,790
and each worker could be sending the coordinator like that task RPCs,

545
00:32:25,820 --> 00:32:30,350
but a little, that's a little [],

546
00:32:30,350 --> 00:32:33,230
so in this example is actually more natural to imagine,

547
00:32:33,260 --> 00:32:36,470
that call_worker, the coordinator is a client,

548
00:32:36,470 --> 00:32:40,940
and the workers are the ones that are handling that RPCs.

549
00:32:41,510 --> 00:32:43,820
Yeah, okay, thanks, very cool.

550
00:32:45,230 --> 00:32:46,850
I have two questions,

551
00:32:47,150 --> 00:32:49,340
first is just a generally Go question,

552
00:32:49,340 --> 00:32:52,760
so in that second for loop on the left, at the bottom,

553
00:32:53,700 --> 00:32:58,340
if you don't use i, will Go complain for, in a for loop?

554
00:32:59,480 --> 00:33:04,400
So I run like all the Go linter and all that stuff

555
00:33:04,580 --> 00:33:07,550
and it's fine, I think,

556
00:33:07,580 --> 00:33:12,940
like, in this case, you do you need to have i,

557
00:33:12,970 --> 00:33:18,880
because you're incremented and keeping the state of i around through the.

558
00:33:19,420 --> 00:33:20,530
Can you do the same thing,

559
00:33:20,530 --> 00:33:23,560
with like a like a while loop,

560
00:33:23,560 --> 00:33:26,410
like just for empty for loop with a select,

561
00:33:27,430 --> 00:33:31,540
where it's like popping off of done.

562
00:33:32,250 --> 00:33:37,580
So, you can't actually,

563
00:33:37,580 --> 00:33:42,950
well, you still need to keep track of how many times you've read from done, right,

564
00:33:42,950 --> 00:33:46,100
because you can't just read once,

565
00:33:46,130 --> 00:33:48,770
you have to read numTask times.

566
00:33:52,070 --> 00:33:52,490
I see, okay.

567
00:33:52,490 --> 00:33:59,260
Yeah, yeah, so you do need some type of state that will track that.

568
00:34:02,800 --> 00:34:05,170
And then for for the one on the right,

569
00:34:05,170 --> 00:34:08,140
like where you're reading from tasks and re-populating it,

570
00:34:08,170 --> 00:34:11,500
is there like any downside to that,

571
00:34:12,530 --> 00:34:16,610
if you're like just constantly reading and adding back and forth to the same channel?

572
00:34:19,740 --> 00:34:22,910
I don't, I can't think of that the top my head,

573
00:34:22,910 --> 00:34:25,580
so in this case, at least you won't block,

574
00:34:25,910 --> 00:34:27,590
because every time you read it,

575
00:34:27,590 --> 00:34:29,990
you're popping something off the channel,

576
00:34:30,020 --> 00:34:32,990
every time you add it, you're pushing something,

577
00:34:33,170 --> 00:34:38,120
so because we have that the tasks is a buffer channel,

578
00:34:38,150 --> 00:34:40,010
but you'll never block on that.

579
00:34:41,160 --> 00:34:45,010
So, in terms of like performance,

580
00:34:45,430 --> 00:34:49,400
I think, I mean channels are built using locks,

581
00:34:49,400 --> 00:34:51,890
so locks are usually more lightweight,

582
00:34:52,430 --> 00:34:57,620
but I don't think, I don't think, you'll see a huge performance in fact,

583
00:34:57,890 --> 00:34:59,120
doing something like this.

584
00:34:59,630 --> 00:35:01,400
Okay, I guess, I've like a,

585
00:35:01,640 --> 00:35:04,250
sorry, just like a general question of like,

586
00:35:04,860 --> 00:35:06,450
what's your like calculus for choosing

587
00:35:06,450 --> 00:35:10,580
between Mutex and channels or like a hybrid,

588
00:35:11,380 --> 00:35:12,340
at the very beginning.

589
00:35:13,560 --> 00:35:19,140
Yeah, so Mutex are very natural for just protecting a piece of state,

590
00:35:19,230 --> 00:35:23,880
so like your Coordinator or like your Raft servers have a log,

591
00:35:24,030 --> 00:35:26,820
I want to protect everytime I append the log,

592
00:35:26,910 --> 00:35:32,730
that seems very difficult or it seems very unnatural

593
00:35:32,730 --> 00:35:34,260
to try and do using channels,

594
00:35:34,470 --> 00:35:37,440
because essentially, you'd be using the channels lock,

595
00:35:37,500 --> 00:35:41,190
you'd want to ensure that no one else is modifying the state,

596
00:35:41,190 --> 00:35:42,360
while you're modifying it,

597
00:35:42,600 --> 00:35:45,990
and then you would have to essentially before you modify it,

598
00:35:46,020 --> 00:35:48,660
try to read on the channel to ensure that no one else,

599
00:35:48,920 --> 00:35:51,470
alright, like someone would have to send something on the channel,

600
00:35:51,470 --> 00:35:52,640
just show that they've done,

601
00:35:52,700 --> 00:35:55,730
they've been finished modifying so and so forth.

602
00:35:55,760 --> 00:36:00,520
So, in that case, it's actually very hard to imagine how you do channel,

603
00:36:00,520 --> 00:36:03,700
where Mutex would make that completely straightforward,

604
00:36:05,260 --> 00:36:08,350
where channels come in very handy is,

605
00:36:08,380 --> 00:36:12,580
like I think our implementation already has this apply channel,

606
00:36:12,850 --> 00:36:15,400
is where you have to wait for,

607
00:36:16,640 --> 00:36:22,670
in some ways, it's almost like a specific instance of a condition variable,

608
00:36:22,730 --> 00:36:25,850
in which you want to wait for something to be ready,

609
00:36:26,030 --> 00:36:34,980
or a, like a very specific type of command to be finished,

610
00:36:35,010 --> 00:36:40,590
so for something like issuing tasks is actually not a bad example

611
00:36:41,730 --> 00:36:46,650
or something like blocking until you have something on a queue,

612
00:36:46,710 --> 00:36:49,650
like is you can almost think of it as like a queuing system,

613
00:36:50,100 --> 00:36:52,230
or at least that's how I like to think about it,

614
00:36:52,230 --> 00:36:56,140
but, for almost all modifications to shared state,

615
00:36:56,140 --> 00:37:02,790
like the race conditions [], encounter locks are much simpler

616
00:37:02,790 --> 00:37:04,920
and in some ways, a lot easier to reason about,

617
00:37:07,990 --> 00:37:09,750
but, yeah.

618
00:37:09,780 --> 00:37:10,410
Thank you.

619
00:37:11,580 --> 00:37:15,270
Sorry, I have a follow up question to this slide,

620
00:37:15,360 --> 00:37:17,370
what happens if the,

621
00:37:17,370 --> 00:37:20,310
so you call the Go issueWorkerTaskThread,

622
00:37:20,310 --> 00:37:22,920
which spins up another goroutine,

623
00:37:22,950 --> 00:37:25,500
I mean, it goes through all the tasks in the channel,

624
00:37:25,500 --> 00:37:27,610
what if it fails,

625
00:37:27,610 --> 00:37:29,860
when it's what if the goroutine fails,

626
00:37:29,860 --> 00:37:32,590
when it's sitting on the if call_worker.

627
00:37:34,550 --> 00:37:39,560
So, if it fails,

628
00:37:40,520 --> 00:37:47,150
then I guess you've taken a task out and not put back,

629
00:37:48,860 --> 00:37:52,520
I'm actually not sure, that seems like,

630
00:37:53,980 --> 00:37:54,850
like you're not,

631
00:37:54,880 --> 00:37:59,930
you're saying like the entire thread crashes, rather than as call_worker,

632
00:37:59,960 --> 00:38:02,420
not like returning fails or something.

633
00:38:02,690 --> 00:38:05,390
Yeah, like the goroutine crashes,

634
00:38:06,010 --> 00:38:09,760
or is that possible for a single goroutine to fail

635
00:38:09,760 --> 00:38:12,070
or would like the entire thing just blow up?

636
00:38:14,180 --> 00:38:14,900
Hey, Frans, you know?

637
00:38:14,900 --> 00:38:16,940
I think the model you should have is that,

638
00:38:16,940 --> 00:38:20,090
if a goroutine crashes, the process crashes.

639
00:38:21,580 --> 00:38:22,930
Yeah, that would solve it.

640
00:38:25,580 --> 00:38:29,930
Sorry, so if just the worker crashes,

641
00:38:30,440 --> 00:38:34,250
then you pick a different task,

642
00:38:34,250 --> 00:38:36,200
but, should you,

643
00:38:36,470 --> 00:38:40,470
I guess you would still have the same worker,

644
00:38:40,500 --> 00:38:42,860
like worker number,

645
00:38:44,660 --> 00:38:49,280
so you still connect to the same worker, even though they have failed.

646
00:38:49,910 --> 00:38:51,080
Yeah, so in this case,

647
00:38:51,080 --> 00:38:54,620
basically call_worker would just continue returning false,

648
00:38:55,100 --> 00:38:59,990
and you know this goroutine that's specific for this worker,

649
00:38:59,990 --> 00:39:02,240
we just continue to loop,

650
00:39:03,420 --> 00:39:06,540
and eventually when the map,

651
00:39:06,540 --> 00:39:09,990
when the coordinator has determined that all the tasks have finished,

652
00:39:09,990 --> 00:39:12,510
it'll close the channel and then this goroutine will exit.

653
00:39:13,220 --> 00:39:15,560
So there could potentially like,

654
00:39:15,560 --> 00:39:18,290
if all your workers continue crashing,

655
00:39:18,290 --> 00:39:20,450
you have like hundreds of new workers joining,

656
00:39:20,600 --> 00:39:23,660
like you could potentially have a lot of goroutines just there,

657
00:39:23,660 --> 00:39:25,130
just like I can't contact my worker,

658
00:39:25,130 --> 00:39:26,540
I can't contact my worker,

659
00:39:26,840 --> 00:39:28,850
but once the task is finished,

660
00:39:28,850 --> 00:39:31,950
this all of them will exit properly.

661
00:39:39,440 --> 00:39:40,400
Cool, alright,

662
00:39:40,430 --> 00:39:42,980
so that's an example with channels,

663
00:39:43,280 --> 00:39:46,010
and now let's move on to some of the

664
00:39:46,600 --> 00:39:49,810
more like your questions and bugs and things like that.

665
00:39:49,810 --> 00:39:52,690
So some common but passing design mistakes that we saw

666
00:39:52,900 --> 00:39:55,630
was pushing too much work to the coordinator,

667
00:39:55,900 --> 00:39:58,450
so essentially making the coordinator bottleneck,

668
00:39:58,540 --> 00:40:01,900
and this included both the coordinator [],

669
00:40:02,590 --> 00:40:06,790
sorting the results or the coordinator reading file contents,

670
00:40:06,820 --> 00:40:11,630
whereas a lot of the kind of beauty of MapReduce is that,

671
00:40:12,170 --> 00:40:16,790
all the state, all the computation happens on the workers.

672
00:40:17,660 --> 00:40:22,250
And another con, it's not really a mistake,

673
00:40:22,250 --> 00:40:24,230
but potentially something to think about is,

674
00:40:24,260 --> 00:40:26,030
how many RPCs are you sending,

675
00:40:26,030 --> 00:40:30,530
and like, do you really need to send that many RPCs.

676
00:40:30,800 --> 00:40:35,270
So for example sending an RPC to check whether there's a Map task available,

677
00:40:35,330 --> 00:40:38,660
and then sending another RPC to ask like give me a task,

678
00:40:38,690 --> 00:40:40,810
is a little redundant

679
00:40:40,810 --> 00:40:45,190
and you want to try and reduce the number and types of,

680
00:40:45,280 --> 00:40:49,480
like reduce the API between the master, the coordinator and the worker,

681
00:40:50,460 --> 00:40:53,280
but these were, like they were passed the test,

682
00:40:53,280 --> 00:40:55,650
and it's just things we wanted to point out.

683
00:40:57,610 --> 00:41:01,630
So now, okay cool, what about like how I do lecture.

684
00:41:01,690 --> 00:41:05,850
So, for the next, say like 5 6 minutes,

685
00:41:06,180 --> 00:41:07,950
what we're going to do breakout rooms,

686
00:41:07,950 --> 00:41:10,410
let let me stop sharing actually,

687
00:41:11,040 --> 00:41:12,360
alright, so do breakout rooms,

688
00:41:12,780 --> 00:41:18,490
and oh shoot, let's see,

689
00:41:21,690 --> 00:41:23,400
I think Zoom just crashed on me.

690
00:41:28,050 --> 00:41:29,580
We could still hear and see you.

691
00:41:30,030 --> 00:41:31,380
Alright, I'm back,

692
00:41:31,380 --> 00:41:35,160
yeah, I upgraded Zoom before this lecture,

693
00:41:35,160 --> 00:41:36,090
that was a bad idea,

694
00:41:36,270 --> 00:41:38,310
but, alright, for the next 5 or 6 minutes,

695
00:41:38,370 --> 00:41:41,130
you should talk about just like

696
00:41:41,460 --> 00:41:45,240
you know any interesting bugs or observations, you had about lab,

697
00:41:45,630 --> 00:41:49,350
or you could you know complain about how long it took you to find a certain bug

698
00:41:49,710 --> 00:41:51,420
or ask questions to each other,

699
00:41:51,750 --> 00:41:54,750
and then we'll come back and go over some of your questions.

700
00:41:55,940 --> 00:41:56,510
Alright.

701
00:42:00,910 --> 00:42:01,630
Okay.

702
00:42:03,060 --> 00:42:04,380
Alright, see you in a bit.

703
00:42:27,340 --> 00:42:29,020
Oh, so with Frans,

704
00:42:29,020 --> 00:42:30,430
do you want me to [] somewhere else?

705
00:42:30,610 --> 00:42:33,220
Probably best, but let me see if I can do it myself.

706
00:42:33,790 --> 00:42:36,380
Okay, I'm going to be right back.

707
00:49:37,790 --> 00:49:41,810
Alright, are we mostly back, I think.

708
00:49:43,880 --> 00:49:44,570
Alright cool.

709
00:49:46,680 --> 00:49:49,110
Okay, so I hope that was pretty fun

710
00:49:49,110 --> 00:49:52,380
or at least you got to talk about some of your frustrations during the lab.

711
00:49:53,610 --> 00:49:55,950
Yeah, so for the rest of the lecture,

712
00:49:55,950 --> 00:49:57,150
we're going to go to,

713
00:49:57,990 --> 00:49:59,340
first, before questions,

714
00:49:59,340 --> 00:50:00,630
take some general tips,

715
00:50:00,630 --> 00:50:03,030
that you'll want to look out for for future labs.

716
00:50:03,510 --> 00:50:05,400
So first of all,

717
00:50:05,430 --> 00:50:10,410
the one thing you'll find very handy for debugging is just

718
00:50:10,470 --> 00:50:11,850
you know classic printfs

719
00:50:11,940 --> 00:50:14,250
and so you can have conditional printfs,

720
00:50:14,250 --> 00:50:17,070
which only print when you want to debug,

721
00:50:17,070 --> 00:50:19,080
so for example you don't have to go through your code

722
00:50:19,080 --> 00:50:20,520
and comment them all out,

723
00:50:20,520 --> 00:50:21,960
before you submit or something like that,

724
00:50:22,380 --> 00:50:24,540
and so in the Raft lab,

725
00:50:24,750 --> 00:50:28,680
we provide this DPrintf in the util.go file,

726
00:50:29,290 --> 00:50:35,170
and you can modify that to for example also print out like the server ID,

727
00:50:35,170 --> 00:50:38,020
every single time you call DPrintf or something like that,

728
00:50:38,140 --> 00:50:40,840
so, yeah, I customize it

729
00:50:40,840 --> 00:50:44,170
to you know print out different colors for different RPCs,

730
00:50:44,170 --> 00:50:44,620
like that,

731
00:50:45,390 --> 00:50:48,750
and also like redirecting your output files,

732
00:50:48,810 --> 00:50:51,630
just so you can like search the files will come in handly.

733
00:50:52,620 --> 00:50:56,650
Another trick that you probably want to keep in mind is,

734
00:50:56,650 --> 00:50:59,130
you can look at all the goroutines

735
00:50:59,130 --> 00:51:03,180
to see where and their execution, they're running,

736
00:51:03,420 --> 00:51:07,200
and so just type Ctrl-\ in order to do that.

737
00:51:08,260 --> 00:51:12,040
And the final thing which already sort of talked about are these defers,

738
00:51:12,040 --> 00:51:14,110
and these slides will be uploaded also,

739
00:51:14,110 --> 00:51:15,370
so you can refer back to them,

740
00:51:15,700 --> 00:51:20,440
but actually you can push multiple functions

741
00:51:20,440 --> 00:51:23,350
to run right before the function returns

742
00:51:23,650 --> 00:51:26,530
and they just be careful of the ordering.

743
00:51:27,920 --> 00:51:31,220
Alright, so now let's get to some of your questions,

744
00:51:32,720 --> 00:51:35,360
a lot of you submitted also questions about Raft,

745
00:51:35,360 --> 00:51:38,630
so those will get to for the Raft Q&A

746
00:51:38,630 --> 00:51:40,760
or maybe office hours

747
00:51:40,760 --> 00:51:41,720
or you can put that on Piazza.

748
00:51:41,720 --> 00:51:45,020
I'm going to focus mostly on the ones from MapReduce

749
00:51:45,050 --> 00:51:47,990
or maybe have time, then we can also get Raft questions.

750
00:51:49,950 --> 00:51:53,810
Alright, so the first category of questions

751
00:51:53,810 --> 00:51:59,060
kind of falls under questions specifically about MapReduce,

752
00:51:59,090 --> 00:52:03,620
so some more complex tasks that you might want to use MapReduce for,

753
00:52:03,830 --> 00:52:08,690
it's actually used a lot in ML, or like data mining, statistical applications,

754
00:52:08,810 --> 00:52:12,250
I linked here to Hadoop,

755
00:52:12,250 --> 00:52:15,010
which is implements MapReduce,

756
00:52:15,010 --> 00:52:17,770
a lot of people use it to run these types of tasks.

757
00:52:18,250 --> 00:52:22,800
And for example, here's a simple,

758
00:52:23,160 --> 00:52:24,750
or maybe not so simple,

759
00:52:24,750 --> 00:52:27,990
but basically matrix multiplication example,

760
00:52:27,990 --> 00:52:30,060
of how you would [] that using MapReduce.

761
00:52:31,340 --> 00:52:35,660
Second, like you for fault tolerance of the coordinator,

762
00:52:35,660 --> 00:52:41,710
the paper proposes a very simple checkpointing mechanism,

763
00:52:41,710 --> 00:52:44,500
in which you'll just start up a new coordinator,

764
00:52:44,500 --> 00:52:46,360
using the last checkpoint state,

765
00:52:46,810 --> 00:52:50,170
and in some ways, this is a very natural design for MapReduce,

766
00:52:50,170 --> 00:52:52,300
because everything is deterministic,

767
00:52:52,300 --> 00:52:53,140
there's no,

768
00:52:53,500 --> 00:52:56,530
the coordinator really doesn't have that much state to hold,

769
00:52:56,530 --> 00:52:57,460
all I need to know is

770
00:52:57,460 --> 00:52:59,470
which have finished and which has happened.

771
00:53:01,210 --> 00:53:05,860
So you could use Raft of course to enable fault tolerance,

772
00:53:05,860 --> 00:53:08,740
and have a set of coordinators,

773
00:53:08,740 --> 00:53:13,720
that all agree on the commands issued so far and the current state,

774
00:53:13,750 --> 00:53:21,050
but in some ways, it seems a little overkill for the coordinator,

775
00:53:21,530 --> 00:53:23,000
for something that's more stateful,

776
00:53:23,000 --> 00:53:25,850
it's like a key value store or something,

777
00:53:25,850 --> 00:53:28,460
it's much more natural to use a Raft.

778
00:53:30,400 --> 00:53:33,280
So some other questions about MapReduce,

779
00:53:33,280 --> 00:53:34,960
the shuffle or combiner step,

780
00:53:35,050 --> 00:53:37,120
when does it happen and what does it do,

781
00:53:37,120 --> 00:53:41,170
so combining occurs like right after the Map functions applied,

782
00:53:41,170 --> 00:53:44,710
for example, in combining the word counts of a particular word,

783
00:53:44,830 --> 00:53:46,300
because having a lot of entries,

784
00:53:46,300 --> 00:53:50,830
that you know like the one you could you know combine them,

785
00:53:50,830 --> 00:53:56,280
and then write only that to the mediate file, intermediate file,

786
00:53:56,730 --> 00:53:58,590
sorting occurs at the reduce,

787
00:53:58,590 --> 00:54:02,310
after all the outputs of the map are read by the reducer.

788
00:54:03,540 --> 00:54:04,500
Let's see,

789
00:54:04,500 --> 00:54:05,820
is successor to MapReduce,

790
00:54:05,820 --> 00:54:08,640
yeah, so actually, I'm not super familiar with it,

791
00:54:08,640 --> 00:54:11,550
but you can look at stuff like Google Cloud Dataflow,

792
00:54:11,790 --> 00:54:16,140
and other sort of directed graph computations,

793
00:54:16,200 --> 00:54:18,900
where inputs flow into a node,

794
00:54:18,900 --> 00:54:20,340
so you can think of as graph,

795
00:54:20,340 --> 00:54:22,830
and then they might flow out to other nodes,

796
00:54:22,860 --> 00:54:27,240
and that node in the middle [] performs for example map computation,

797
00:54:27,240 --> 00:54:28,890
and produces intermediate data,

798
00:54:29,070 --> 00:54:31,980
is then sent to other like reducer that in the graph,

799
00:54:32,130 --> 00:54:35,410
so it's a interesting way,

800
00:54:35,410 --> 00:54:38,950
it's like a data dataflow way to think about MapReduce.

801
00:54:39,900 --> 00:54:41,730
And I'm sure that there's others that,

802
00:54:41,760 --> 00:54:43,950
I'm not [] like that where.

803
00:54:44,430 --> 00:54:47,490
I did, one, maybe one of them Spark,

804
00:54:47,490 --> 00:54:48,780
which we'll read later about.

805
00:54:52,700 --> 00:54:57,440
Yeah, so, but I I like the graph way of thinking about MapReduce,

806
00:54:57,470 --> 00:55:00,980
because right now we're only really thinking about a two-step operation,

807
00:55:00,980 --> 00:55:04,940
where it could actually be like you know many many steps.

808
00:55:06,260 --> 00:55:09,050
Oh, yeah, then how input partitioned in practice,

809
00:55:09,050 --> 00:55:15,350
so, usually, because the input space is very application specific,

810
00:55:15,350 --> 00:55:17,900
and output space is also application specific,

811
00:55:17,930 --> 00:55:21,470
it's really up to the programmer to specify,

812
00:55:21,860 --> 00:55:30,710
there's sometimes a natural division,

813
00:55:30,710 --> 00:55:34,310
for example make a local matrix computation,

814
00:55:34,310 --> 00:55:37,340
then you want to combine them or so on so forth,

815
00:55:37,370 --> 00:55:43,700
or you could if it's just like an enormous document or like enormous text text files,

816
00:55:43,760 --> 00:55:46,100
you can just split it up into a reasonable size of work,

817
00:55:46,100 --> 00:55:49,790
so you know like applying the map function is going to take []

818
00:55:49,940 --> 00:55:52,670
and also depends on the size of your cluster,

819
00:55:52,670 --> 00:55:53,810
so how many workers you have.

820
00:55:57,300 --> 00:55:59,370
So some further MapReduce questions,

821
00:55:59,700 --> 00:56:01,410
why do mapper store files locally,

822
00:56:01,410 --> 00:56:02,670
so in the paper,

823
00:56:02,700 --> 00:56:07,560
this is because at that time, the network bandwidth was their bottleneck,

824
00:56:09,180 --> 00:56:10,680
that's why they don't use GFS,

825
00:56:10,680 --> 00:56:13,680
they only use GFS to write the,

826
00:56:16,240 --> 00:56:17,950
yeah, to write the output files.

827
00:56:18,760 --> 00:56:21,400
Are leaders necessary for distributed systems,

828
00:56:21,490 --> 00:56:23,260
not necessarily,

829
00:56:24,260 --> 00:56:27,980
there, like, think of Bitcoin, like other decentralized systems,

830
00:56:27,980 --> 00:56:30,440
in which all the nodes sort of perform competition,

831
00:56:30,440 --> 00:56:33,470
and some random node or like some node in the network

832
00:56:33,470 --> 00:56:35,450
is responsible for committing that,

833
00:56:35,450 --> 00:56:38,150
so there are definitely more like egalitarian designs.

834
00:56:38,910 --> 00:56:41,490
Oh, yeah, our challenge was

835
00:56:41,490 --> 00:56:44,910
actually to run MapReduce on like actual different servers

836
00:56:44,910 --> 00:56:49,260
rather than what we kind of had you do in the lab,

837
00:56:49,680 --> 00:56:51,840
and so in order to do this,

838
00:56:51,840 --> 00:56:52,650
like you just,

839
00:56:53,040 --> 00:56:57,600
instead of using sockets to communicate over for like RPCs,

840
00:56:57,840 --> 00:57:00,120
you would use like TCP/IP,

841
00:57:00,120 --> 00:57:05,380
basically like normal, like over the network communication,

842
00:57:05,830 --> 00:57:09,370
and you would use a shared file system like GFS,

843
00:57:09,370 --> 00:57:13,000
so the [] I think all of you have access to Athena,

844
00:57:13,120 --> 00:57:14,770
if at least at MIT,

845
00:57:14,800 --> 00:57:18,220
and you know ssh to multiple Athena machines,

846
00:57:18,220 --> 00:57:22,300
and use AFS which is the file, shared file system,

847
00:57:22,300 --> 00:57:23,980
I think Athena uses too,

848
00:57:24,950 --> 00:57:28,400
basically, you can access your files on Athena from any machine,

849
00:57:28,910 --> 00:57:34,340
similarly you could do the same thing by rent AWS instances and using S3,

850
00:57:34,940 --> 00:57:40,100
but we didn't expect you to spend any money to run our lab.

851
00:57:43,180 --> 00:57:46,660
Right, so some questions that came about, just like general code design,

852
00:57:46,660 --> 00:57:49,210
so we've some of these we've discussed as well,

853
00:57:49,630 --> 00:57:52,060
so lab 1 was pretty small,

854
00:57:52,090 --> 00:57:55,180
lab 2 is going to be much larger,

855
00:57:55,210 --> 00:57:57,460
especially as you get to the later stages,

856
00:57:57,520 --> 00:58:01,030
and as lab 3 and lab 4 come along as well.

857
00:58:01,690 --> 00:58:05,810
And one thing that I personally find very handy is,

858
00:58:05,810 --> 00:58:09,610
just separate different chunks of code by their purpose,

859
00:58:09,700 --> 00:58:16,190
so, and also in how I implement each step of my code,

860
00:58:16,280 --> 00:58:17,870
so separating them out by,

861
00:58:17,870 --> 00:58:21,560
for example RPCs and the senders and handlers,

862
00:58:21,890 --> 00:58:26,780
and feel free to actually separate these out physically in different files,

863
00:58:26,900 --> 00:58:27,950
that won't,

864
00:58:28,100 --> 00:58:29,870
like that's fine for a test,

865
00:58:29,870 --> 00:58:32,030
and it will probably help you,

866
00:58:32,420 --> 00:58:36,470
like not have thousands of lines of code in one gigantic file.

867
00:58:38,280 --> 00:58:42,420
I I personally like to put all definitions of state together,

868
00:58:42,420 --> 00:58:46,500
and then functions are like sort of separate,

869
00:58:46,500 --> 00:58:48,540
but that's my personal preference,

870
00:58:49,910 --> 00:58:53,750
factoring out common pieces of code into functions will also be very helpful,

871
00:58:53,780 --> 00:58:57,860
for example every single RPC, you will get in Raft,

872
00:58:57,860 --> 00:58:59,330
you need to check for stale term,

873
00:58:59,450 --> 00:59:01,520
so putting all that logic,

874
00:59:01,520 --> 00:59:04,160
so that resets all the state properly and everything

875
00:59:04,160 --> 00:59:06,050
into one function, that you just call,

876
00:59:06,320 --> 00:59:07,670
will help,

877
00:59:07,670 --> 00:59:10,340
because you know you don't want to accidentally forget to

878
00:59:10,550 --> 00:59:15,320
reset your election timer or like reset votedFor or something,

879
00:59:16,890 --> 00:59:18,570
although you shouldn't reset the election timer,

880
00:59:18,570 --> 00:59:19,500
so don't do that,

881
00:59:19,530 --> 00:59:22,860
that was an example I pulled off the top of my head.

882
00:59:23,250 --> 00:59:25,950
And also finally have a good environment

883
00:59:25,950 --> 00:59:30,360
with like autocomplete or like being able to search for certain keywords in your code,

884
00:59:30,360 --> 00:59:33,270
and so forth can help a lot.

885
00:59:33,770 --> 00:59:35,840
So if you need any help setting this,

886
00:59:35,840 --> 00:59:37,190
like come to office hours

887
00:59:37,190 --> 00:59:39,320
or there's tons of tutorials online,

888
00:59:39,350 --> 00:59:41,630
you can look up a good editor,

889
00:59:41,900 --> 00:59:44,600
but it's not necessary, it's definitely not necessary,

890
00:59:44,600 --> 00:59:46,370
but it could it does help.

891
00:59:48,020 --> 00:59:52,910
And then, oh yeah, so has using Go decrease the amount of time students spend debugging,

892
00:59:53,120 --> 00:59:55,910
so I've never actually implemented the labs in C++,

893
00:59:55,910 --> 00:59:57,410
but according to Frans, like,

894
00:59:58,080 --> 01:00:03,300
well, the one huge advantage of Go is its memory management,

895
01:00:03,510 --> 01:00:05,070
so uses garbage collection,

896
01:00:05,070 --> 01:00:06,180
and don't have to deal with,

897
01:00:06,180 --> 01:00:09,420
like you know there are pointers,

898
01:00:09,420 --> 01:00:12,870
but you don't have to deal with them in the same way you would see your C++,

899
01:00:13,320 --> 01:00:17,720
so like, I don't know how many of you run into segfaults so far,

900
01:00:17,720 --> 01:00:19,670
but I'm guessing very few of you

901
01:00:19,670 --> 01:00:21,320
or they were very easy to fix,

902
01:00:21,590 --> 01:00:26,410
and this definitely makes it easier to debug,

903
01:00:26,560 --> 01:00:29,320
or they're just certain types of bugs that you don't need to worry about.

904
01:00:30,710 --> 01:00:31,670
Sorry, I have a question.

905
01:00:32,120 --> 01:00:32,600
Yeah.

906
01:00:32,720 --> 01:00:35,960
This is like a more Go specific question,

907
01:00:35,960 --> 01:00:39,170
but when you have a function that can take in,

908
01:00:39,200 --> 01:00:42,980
let's say you have like a, you have a appendEntries arg,

909
01:00:42,980 --> 01:00:46,310
and you also have like a requestVote arg,

910
01:00:46,310 --> 01:00:48,680
both of them have a term variable inside,

911
01:00:48,710 --> 01:00:50,450
but when you pass it to a function,

912
01:00:50,960 --> 01:00:52,730
how do you tell the function,

913
01:00:52,730 --> 01:00:57,080
that's like, hey I expect a struct, that has a term field,

914
01:01:00,270 --> 01:01:01,410
is that possible?

915
01:01:02,200 --> 01:01:05,530
So you define the types right,

916
01:01:05,590 --> 01:01:09,540
so it's like any other type,

917
01:01:09,540 --> 01:01:11,550
when you pass into the function,

918
01:01:11,550 --> 01:01:14,670
the function expects an argument of a particular type,

919
01:01:15,190 --> 01:01:16,930
and that's type.

920
01:01:17,050 --> 01:01:17,800
Yeah.

921
01:01:17,950 --> 01:01:21,370
Yeah, let's say I want to share one function across both types.

922
01:01:22,120 --> 01:01:24,250
I believe you can use an interface,

923
01:01:24,250 --> 01:01:25,660
but I'm not sure.

924
01:01:26,570 --> 01:01:29,810
So I tried to, but when I do .term,

925
01:01:29,810 --> 01:01:32,210
it says I don't know this field

926
01:01:32,330 --> 01:01:33,530
or like it doesn't exists.

927
01:01:34,010 --> 01:01:35,510
I think you need to convert it

928
01:01:35,630 --> 01:01:38,180
or you need to just give a casting,

929
01:01:38,180 --> 01:01:38,840
I can't remember,

930
01:01:38,870 --> 01:01:41,270
but there's a way to coerce.

931
01:01:41,570 --> 01:01:43,040
You have to type cast it back,

932
01:01:43,040 --> 01:01:46,180
you know to whatever struct you want access.

933
01:01:46,900 --> 01:01:50,290
Like you basically need to talk Go,

934
01:01:50,620 --> 01:01:53,980
that by the time, I actually use this variable,

935
01:01:53,980 --> 01:01:55,690
it is of a particular type.

936
01:01:56,630 --> 01:01:57,620
Got it, thank you.

937
01:01:57,650 --> 01:02:01,490
So one thing if you want to reuse the function for multiple different types,

938
01:02:01,700 --> 01:02:03,440
you can pass in an interface,

939
01:02:03,470 --> 01:02:05,570
but you might also need to pass in,

940
01:02:05,570 --> 01:02:11,710
for example, like you know more [] something that tells it,

941
01:02:11,830 --> 01:02:13,540
like, hey this is going to be this type,

942
01:02:13,540 --> 01:02:17,620
and then you need to cast that interface into the right type, before you use it.

943
01:02:19,540 --> 01:02:20,260
Okay.

944
01:02:21,080 --> 01:02:22,820
I think the way people usually handle this is,

945
01:02:22,820 --> 01:02:26,030
by putting setters and getters in the interface,

946
01:02:26,210 --> 01:02:30,170
you don't actually know which type it is in actuality,

947
01:02:30,170 --> 01:02:32,870
you just access the variable using interface.

948
01:02:34,330 --> 01:02:34,750
Yeah.

949
01:02:38,260 --> 01:02:39,790
Yeah, I don't think it,

950
01:02:40,120 --> 01:02:44,440
you shouldn't need to use interfaces that much in Raft,

951
01:02:44,440 --> 01:02:45,850
I don't think I used it all,

952
01:02:45,850 --> 01:02:48,850
other than the command which is provided.

953
01:02:53,410 --> 01:02:57,160
Yeah, like, I guess factoring out common pieces of code is good,

954
01:02:57,160 --> 01:02:59,200
unless it adds additional complexity,

955
01:03:02,220 --> 01:03:05,460
like I wouldn't try and force your types,

956
01:03:05,460 --> 01:03:08,370
to all be able to run on the same function,

957
01:03:08,370 --> 01:03:10,140
like it might just be similar type,

958
01:03:10,260 --> 01:03:12,270
two slightly different functions.

959
01:03:13,150 --> 01:03:15,640
Or, if the only like shared piece you're using is the term,

960
01:03:15,640 --> 01:03:18,430
you can have the same function taken just the term,

961
01:03:18,430 --> 01:03:22,810
and in both cases, pass in the .term of the struct using.

962
01:03:27,020 --> 01:03:29,840
Alright, some other code design questions?

963
01:03:30,530 --> 01:03:35,870
Once when separating the code into multiple files,

964
01:03:35,870 --> 01:03:39,080
is there naming conventional like required,

965
01:03:39,080 --> 01:03:40,910
because when we make the lab,

966
01:03:40,940 --> 01:03:43,250
it seems like it's copying the source file,

967
01:03:43,250 --> 01:03:45,020
so is there any naming convention?

968
01:03:46,060 --> 01:03:50,170
I mean, I would put them in raft, the raft folder,

969
01:03:50,200 --> 01:03:52,060
but there's no naming convention,

970
01:03:52,060 --> 01:03:53,890
like you can name your files whatever you want.

971
01:03:55,220 --> 01:03:58,340
Okay, our grading scripts will replace anything,

972
01:03:58,340 --> 01:04:02,630
that's necessary for or anything that belongs to the testing framework,

973
01:04:02,750 --> 01:04:07,070
so the config file or like the test file,

974
01:04:07,190 --> 01:04:09,770
anything that you change in there will be wiped out.

975
01:04:12,540 --> 01:04:13,170
Yeah.

976
01:04:14,550 --> 01:04:19,350
Like also be slightly careful about using external dependencies,

977
01:04:20,220 --> 01:04:24,190
I ran into a couple issues with grading some scripts,

978
01:04:24,190 --> 01:04:26,140
I had external dependencies,

979
01:04:26,140 --> 01:04:29,500
like using some github package, Go package,

980
01:04:29,530 --> 01:04:32,740
but those were I was able to fix it,

981
01:04:32,740 --> 01:04:34,600
just be a little careful, if you do that.

982
01:04:35,130 --> 01:04:39,060
But, yeah, create as many .go files in raft as you want.

983
01:04:42,110 --> 01:04:47,270
Yeah, so pointer versus a value, while passing by reference can be cheaper,

984
01:04:47,300 --> 01:04:50,090
because Go won't just copy the struct,

985
01:04:50,420 --> 01:04:53,280
this was, this question was asked

986
01:04:53,310 --> 01:04:58,170
in particular for why call takes the arguments

987
01:04:58,170 --> 01:05:00,840
and the reply as pointers,

988
01:05:01,200 --> 01:05:04,560
and so yeah those could be potentially extremely large,

989
01:05:04,560 --> 01:05:07,320
and so Go doesn't have to copy them, when you call the function,

990
01:05:07,320 --> 01:05:08,430
that's the main reason.

991
01:05:08,880 --> 01:05:10,860
Using both locks and channels are possible?

992
01:05:10,860 --> 01:05:13,350
Yes, you'll give them both in Raft,

993
01:05:13,740 --> 01:05:15,990
so you will definitely see how it's possible.

994
01:05:18,560 --> 01:05:21,260
Oh yeah, and then we're getting a lot of questions about timeouts,

995
01:05:21,290 --> 01:05:25,040
so in map, in the MapReduce lab,

996
01:05:25,070 --> 01:05:26,330
the timeout was sort of,

997
01:05:26,390 --> 01:05:30,170
well, we gave you a 10 seconds for the worker tasks when they [],

998
01:05:30,230 --> 01:05:32,300
but in terms of how long do you sleep,

999
01:05:32,300 --> 01:05:35,000
and that were pretty much able to choose anything other that.

1000
01:05:35,610 --> 01:05:38,970
For Raft, you have to choose timeout a little more carefully,

1001
01:05:39,000 --> 01:05:43,980
and our tests are like kind of sensitive, but not super sensitive,

1002
01:05:44,100 --> 01:05:45,900
like you'll be [] for example,

1003
01:05:45,900 --> 01:05:50,010
probably be within a range of one to 100, to 200 milliseconds,

1004
01:05:50,010 --> 01:05:51,630
and be fine.

1005
01:05:52,460 --> 01:05:55,860
Yeah, in terms of choosing them,

1006
01:05:58,470 --> 01:06:02,400
probably helps to first think about why you're waiting at all,

1007
01:06:03,440 --> 01:06:06,800
and for example in the, for Raft,

1008
01:06:06,830 --> 01:06:08,810
your leader is sending heartbeat,

1009
01:06:09,330 --> 01:06:13,200
and your timeout is to detect when the leader is dead,

1010
01:06:14,620 --> 01:06:18,730
so, you kind of want to give the leader a couple chances

1011
01:06:18,730 --> 01:06:20,440
to tell you that it's alive,

1012
01:06:20,560 --> 01:06:24,700
otherwise you know you'll just continuously think it's dead,

1013
01:06:24,910 --> 01:06:28,900
so depending on what you set your heartbeat timeout to be

1014
01:06:28,990 --> 01:06:30,640
or your heartbeat interval to be,

1015
01:06:30,760 --> 01:06:32,260
which I think will give you some guidelines of,

1016
01:06:32,260 --> 01:06:36,550
it can't be ten more than ten times per second or something like that,

1017
01:06:37,640 --> 01:06:39,980
depending on what you set your heartbeat,

1018
01:06:40,010 --> 01:06:42,560
you'll want your timeout to be something, like pretty reasonable,

1019
01:06:42,560 --> 01:06:46,130
like maybe allow for the chance to get two to three heartbeats,

1020
01:06:46,790 --> 01:06:50,810
and then you'll have to randomize some like range,

1021
01:06:50,840 --> 01:06:54,380
because you don't want all your servers start elections at the same time,

1022
01:06:54,920 --> 01:06:58,580
and to do that, you can you know like a range of,

1023
01:06:59,650 --> 01:07:03,610
maybe like two to five heartbeats,

1024
01:07:04,240 --> 01:07:07,030
some timeout between there is reasonable,

1025
01:07:07,630 --> 01:07:10,090
but in terms of the test,

1026
01:07:10,090 --> 01:07:13,120
you'll see whether you're sending too many RPCs

1027
01:07:13,390 --> 01:07:15,100
or too many bits are going over the network

1028
01:07:15,100 --> 01:07:18,700
as the test go in later labs,

1029
01:07:18,820 --> 01:07:21,040
and you can tweak your timeout very easily,

1030
01:07:21,100 --> 01:07:24,910
it's slightly implementation dependent,

1031
01:07:25,090 --> 01:07:29,640
so, I can't tell you like what's the perfect number for you,

1032
01:07:29,970 --> 01:07:34,440
but thinking of it, in terms of why am I timing out in the first place,

1033
01:07:34,560 --> 01:07:39,360
and how many RPCs do I want to get from like other servers before timeout,

1034
01:07:39,390 --> 01:07:41,520
is a good metric to keep in mind,

1035
01:07:43,390 --> 01:07:45,790
hopefully, that helps a lot of timeouts.

1036
01:07:46,900 --> 01:07:49,870
Okay, yeah, so some implementation questions,

1037
01:07:49,870 --> 01:07:53,320
that came up about the MapReduce lab,

1038
01:07:53,320 --> 01:07:54,790
and also the labs in general.

1039
01:07:55,400 --> 01:08:00,150
So, some people actually did implement backup tasks,

1040
01:08:00,150 --> 01:08:01,110
which is pretty cool,

1041
01:08:01,110 --> 01:08:04,020
and we definitely did not require that for this lab,

1042
01:08:04,410 --> 01:08:09,290
and I think something that was important to keep in mind is that,

1043
01:08:09,290 --> 01:08:14,690
the paper has makes a distinction between starting, restarting a task,

1044
01:08:15,140 --> 01:08:16,610
because a worker has failed,

1045
01:08:17,250 --> 01:08:20,280
and issuing the task again,

1046
01:08:20,520 --> 01:08:22,860
to speed up a lagging task,

1047
01:08:22,860 --> 01:08:24,960
that the worker hasn't failed,

1048
01:08:25,380 --> 01:08:27,930
but you want the task to complete faster,

1049
01:08:28,290 --> 01:08:30,840
and so backup tasks are used for the lagger,

1050
01:08:30,990 --> 01:08:32,640
when tasks are haven't failed yet,

1051
01:08:32,640 --> 01:08:36,450
but there's there just slow and timeout,

1052
01:08:36,820 --> 01:08:37,900
we start task,

1053
01:08:37,900 --> 01:08:40,240
when workers are actually detect to fail.

1054
01:08:40,330 --> 01:08:41,950
So when the paper,

1055
01:08:41,950 --> 01:08:45,220
the coordinator actually gets heartbeats from the workers,

1056
01:08:45,340 --> 01:08:49,540
whereas in the design that we propose for your lab,

1057
01:08:49,660 --> 01:08:54,010
we use timeouts both to detect that worker has probably failed

1058
01:08:54,070 --> 01:08:56,500
and also to detect slow tasks,

1059
01:08:56,590 --> 01:09:00,520
so in some ways, we make that we don't have that distinction,

1060
01:09:00,730 --> 01:09:02,080
we just assume that,

1061
01:09:02,110 --> 01:09:05,080
if this task hasn't been completed in this set of time,

1062
01:09:05,140 --> 01:09:07,480
that you know like probably the worker has failed

1063
01:09:07,480 --> 01:09:08,860
or maybe it's just insanely slow,

1064
01:09:08,860 --> 01:09:10,000
and let's reissue it,

1065
01:09:10,240 --> 01:09:15,460
so that's why our labs don't really mention backup tasks.

1066
01:09:16,630 --> 01:09:21,850
So, and then, yeah so there, this is again going back to the confusion,

1067
01:09:21,850 --> 01:09:25,480
the next question, about like synchronization,

1068
01:09:25,480 --> 01:09:26,980
if the servers are on different machines,

1069
01:09:26,980 --> 01:09:29,380
so the servers are on different machines,

1070
01:09:29,410 --> 01:09:32,260
and they only communicate using RPCs,

1071
01:09:32,350 --> 01:09:37,480
all synchronization is just protecting or synchronizing the threads on one server,

1072
01:09:38,080 --> 01:09:40,990
I just want to emphasize that one more time.

1073
01:09:43,190 --> 01:09:47,450
Common source of race conditions, just you know logging,

1074
01:09:49,570 --> 01:09:51,930
I, in some ways I think,

1075
01:09:51,930 --> 01:09:53,850
someone's talking about,

1076
01:09:53,850 --> 01:09:56,010
like you know how do you know when to lock,

1077
01:09:56,010 --> 01:09:59,070
and how do you know when to use synchronization,

1078
01:09:59,310 --> 01:10:04,410
so anytime you're modifying the state of the file,

1079
01:10:04,410 --> 01:10:06,480
like your Raft server or the coordinator,

1080
01:10:06,720 --> 01:10:08,490
anytime you modify the state,

1081
01:10:09,020 --> 01:10:10,010
you want to lock,

1082
01:10:10,430 --> 01:10:12,740
and what you'll notice is that,

1083
01:10:13,960 --> 01:10:18,220
for almost every function in your Raft implementation, for example,

1084
01:10:18,250 --> 01:10:20,260
you will have a lock

1085
01:10:20,260 --> 01:10:22,990
and then a defer unlock, like right after that.

1086
01:10:23,940 --> 01:10:27,720
The only time you need to make sure that you're not lock is,

1087
01:10:27,720 --> 01:10:29,370
when you make a call on might block,

1088
01:10:29,520 --> 01:10:32,100
so sending an RPC,

1089
01:10:32,220 --> 01:10:35,790
you know sending something over channel,

1090
01:10:36,090 --> 01:10:38,400
those type of operations, you shouldn't lock around,

1091
01:10:38,400 --> 01:10:41,460
because then you're, you're that thread will just be blocked on that,

1092
01:10:41,580 --> 01:10:44,460
and hold the lock and stop the server,

1093
01:10:44,460 --> 01:10:46,590
any thread on the server from making progress.

1094
01:10:47,720 --> 01:10:50,720
Yeah, and then there are some questions about like,

1095
01:10:51,670 --> 01:10:54,160
there are some data races they're benign,

1096
01:10:54,160 --> 01:10:57,430
like for example you could set isDone to be true,

1097
01:10:57,430 --> 01:11:00,190
and you know like you don't really need to lock around that,

1098
01:11:00,190 --> 01:11:01,810
but the race detector is complaining,

1099
01:11:02,050 --> 01:11:04,720
you could use an atomic []

1100
01:11:04,720 --> 01:11:08,560
which has the same behavior, like locking before unlocking after,

1101
01:11:09,580 --> 01:11:12,910
but even though you might think this data race is benign,

1102
01:11:13,060 --> 01:11:14,890
it's undefined behavior,

1103
01:11:15,010 --> 01:11:19,360
so it just so happens, that you know eventually the next read,

1104
01:11:19,660 --> 01:11:22,510
like your read might miss the fact, that isDone,

1105
01:11:22,510 --> 01:11:25,060
but the next time you call isDone, it will say true,

1106
01:11:25,060 --> 01:11:26,020
and then you're fine,

1107
01:11:26,200 --> 01:11:31,660
but undefined behavior could technically be implemented as anything,

1108
01:11:31,720 --> 01:11:34,210
like it just so happens that your compiler

1109
01:11:34,450 --> 01:11:36,910
and your processor does something reasonable,

1110
01:11:36,970 --> 01:11:38,410
when there's a data race,

1111
01:11:38,530 --> 01:11:41,740
so you should handle them especially when they're simple,

1112
01:11:42,100 --> 01:11:45,160
and they don't really affect performance that much.

1113
01:11:45,900 --> 01:11:47,940
Another thing is,

1114
01:11:48,550 --> 01:11:54,920
well, in in theory, you could have this like is [] data race,

1115
01:11:54,920 --> 01:11:58,490
could potentially mean that your process would never exit,

1116
01:11:58,550 --> 01:12:02,630
because you know the write to isDone, setting it to true,

1117
01:12:02,720 --> 01:12:05,990
might ever actually propagate to the thread that's reading,

1118
01:12:06,020 --> 01:12:08,030
what whether it's true or not,

1119
01:12:08,030 --> 01:12:11,360
because it could be stored in some like buffer and never flushed,

1120
01:12:11,390 --> 01:12:13,700
what locks ensure is that,

1121
01:12:13,700 --> 01:12:18,290
your write the next thread that reads is done,

1122
01:12:18,710 --> 01:12:22,730
will see the last write isDone,

1123
01:12:22,760 --> 01:12:23,990
and actually flush it,

1124
01:12:23,990 --> 01:12:27,860
from for example a potential buffer that the write could be stored.

1125
01:12:28,400 --> 01:12:30,980
So, yeah, that's just emphasizing,

1126
01:12:30,980 --> 01:12:32,840
like you don't want data races,

1127
01:12:32,840 --> 01:12:34,730
even if you think that they're really friendly.

1128
01:12:35,590 --> 01:12:37,630
Clean way to exit?

1129
01:12:38,230 --> 01:12:43,810
So sending an exit RPC from coordinator to worker, workers,

1130
01:12:43,990 --> 01:12:47,800
also like the quote unquote like messy Exit,

1131
01:12:47,800 --> 01:12:51,100
where the worker tries to send RPCs,

1132
01:12:51,100 --> 01:12:52,240
the socket is closed,

1133
01:12:52,270 --> 01:12:54,190
like those are also fine,

1134
01:12:56,080 --> 01:13:00,700
like most solutions are equally acceptable.

1135
01:13:01,780 --> 01:13:04,300
And then unexpected EOF errors,

1136
01:13:04,300 --> 01:13:07,740
so, you can look I have a link here,

1137
01:13:07,740 --> 01:13:09,990
that it shows when it's invoked the client,

1138
01:13:09,990 --> 01:13:14,640
but it's a little confusing as to when that actually happens,

1139
01:13:14,640 --> 01:13:17,310
so I would not worry about it too much,

1140
01:13:17,370 --> 01:13:19,230
if any one has insights into,

1141
01:13:21,340 --> 01:13:25,390
if they got this error at a very strange moment,

1142
01:13:25,390 --> 01:13:26,770
then we could look into it,

1143
01:13:26,860 --> 01:13:29,290
but I think it's very specific on your implementation,

1144
01:13:29,290 --> 01:13:31,360
so I would have to look at that, in particular,

1145
01:13:31,660 --> 01:13:33,310
but we got a bunch of questions about that.

1146
01:13:34,810 --> 01:13:39,700
Yeah, I think so that's basically most of the questions that came up,

1147
01:13:39,700 --> 01:13:45,250
and I think now if you have any questions about you know Go, MapReduce

1148
01:13:45,250 --> 01:13:48,400
or if you want to ask staff about the labs.

1149
01:13:48,930 --> 01:13:53,040
I had a question about the clean way to exit.

1150
01:13:53,870 --> 01:13:58,070
So you're saying like something Exit RPC,

1151
01:13:58,160 --> 01:13:59,630
I was just wondering if there were like,

1152
01:13:59,630 --> 01:14:01,790
if there was like a case,

1153
01:14:02,030 --> 01:14:08,600
where a worker for some reason just takes a very long time to reach the server, right,

1154
01:14:08,600 --> 01:14:10,670
like how like how does the server know,

1155
01:14:11,170 --> 01:14:14,170
like when to like shutdown,

1156
01:14:14,410 --> 01:14:18,490
because, because because the coordinator shutdown at some point, correct,

1157
01:14:18,490 --> 01:14:22,390
when, when, when it says like done, when done returns true,

1158
01:14:22,970 --> 01:14:27,710
it shutdown and so it stops replying to the workers,

1159
01:14:28,280 --> 01:14:30,680
how does it decide when to do that,

1160
01:14:30,680 --> 01:14:36,430
if it's waiting for, for workers to shutdown themselves.

1161
01:14:37,570 --> 01:14:41,830
Oh, so in this case, the coordinator isn't,

1162
01:14:42,540 --> 01:14:43,380
oh I guess,

1163
01:14:43,380 --> 01:14:45,330
so send is probably the wrong word,

1164
01:14:45,360 --> 01:14:47,820
the coordinator isn't waiting for the workers to respond,

1165
01:14:47,970 --> 01:14:53,970
the coordinator is not sending it's replying to the request from workers,

1166
01:14:53,970 --> 01:14:57,120
with a, like the task is done, please exit,

1167
01:14:57,420 --> 01:14:58,530
the worker isn't,

1168
01:14:58,680 --> 01:15:01,740
the coordinator isn't actually waiting for the workers at all,

1169
01:15:01,770 --> 01:15:02,790
and so in this case,

1170
01:15:02,790 --> 01:15:06,420
the coordinator could actually still exit before the workers,

1171
01:15:06,480 --> 01:15:08,700
and cause the workers to like,

1172
01:15:09,300 --> 01:15:13,170
you know have a disconnected socket error and exit.

1173
01:15:14,130 --> 01:15:16,350
Yeah, I I guess, that was my question really,

1174
01:15:16,350 --> 01:15:19,530
like like if if it I could though,

1175
01:15:20,040 --> 01:15:23,130
coordinator replying to workers, right,

1176
01:15:23,130 --> 01:15:27,990
that are like potentially like asking for get task,

1177
01:15:28,320 --> 01:15:32,070
but what happens if the worker shutdown,

1178
01:15:32,310 --> 01:15:34,200
or sorry the coordinator shutdown,

1179
01:15:34,200 --> 01:15:40,050
before it gets, get get task RPC from the worker.

1180
01:15:40,900 --> 01:15:43,990
Oh, then the next time the worker tries to contact the coordinator,

1181
01:15:43,990 --> 01:15:46,840
the worker will see that the connection is closed and then exit.

1182
01:15:48,340 --> 01:15:48,850
Yeah.

1183
01:15:49,000 --> 01:15:52,780
That's as clean shutdown as we'll get.

1184
01:15:56,060 --> 01:15:58,730
Essentially, I mean you could imagine that,

1185
01:15:59,480 --> 01:16:03,260
you know you could set up the workers to be RPC servers,

1186
01:16:03,260 --> 01:16:07,820
then you would actually have the coordinator be sending these, like please exit,

1187
01:16:07,820 --> 01:16:09,920
the coordinator will have to wait for the workers to exit,

1188
01:16:10,070 --> 01:16:11,000
but it's not,

1189
01:16:15,340 --> 01:16:18,250
or it doesn't seem like you won't get any utility out that.

1190
01:16:20,530 --> 01:16:21,070
Thanks.

1191
01:16:21,340 --> 01:16:22,540
Yeah.

1192
01:16:22,750 --> 01:16:25,630
Kat, I see you have your hands.

1193
01:16:26,240 --> 01:16:29,420
Yeah, something that I was wondering about is,

1194
01:16:29,420 --> 01:16:32,150
for the future labs, are we allowed to have more files,

1195
01:16:32,150 --> 01:16:34,040
I think explicitly in the MapReduce lab,

1196
01:16:34,040 --> 01:16:35,240
we were only supposed to have three,

1197
01:16:36,700 --> 01:16:39,520
and it didn't read something where it was like,

1198
01:16:39,580 --> 01:16:42,400
hey, you should have all of your stuff contained in one.

1199
01:16:43,540 --> 01:16:46,510
Oh, yeah, so you can definitely add more files,

1200
01:16:47,440 --> 01:16:51,280
that's like I would almost encourage that,

1201
01:16:52,240 --> 01:16:54,310
I, did we say that about MapReduce,

1202
01:16:55,160 --> 01:16:56,900
I I don't, I can't remember whether.

1203
01:16:56,900 --> 01:17:00,740
What you saying, you couldn't edit any of the other main files,

1204
01:17:00,740 --> 01:17:01,130
it like.

1205
01:17:01,130 --> 01:17:03,920
Yeah, you couldn't edit the [], yeah.

1206
01:17:03,920 --> 01:17:05,660
Okay, I misread that, thanks,

1207
01:17:05,660 --> 01:17:07,370
this makes me feel a lot better.

1208
01:17:07,610 --> 01:17:14,160
Yeah, yeah, but definitely like bring your code will be useful.

1209
01:17:16,300 --> 01:17:19,690
I have a question about the benign data races,

1210
01:17:21,100 --> 01:17:21,850
I guess like,

1211
01:17:22,630 --> 01:17:24,550
because sometimes there's for example raft,

1212
01:17:24,550 --> 01:17:29,500
you just want to read the current state of the of the Raft server,

1213
01:17:29,590 --> 01:17:34,930
why would multiple write, multiple threads writing to it and one reading,

1214
01:17:34,960 --> 01:17:38,350
so why would a read and write to the same variable,

1215
01:17:38,380 --> 01:17:40,780
end up cause undefined behavior,

1216
01:17:40,780 --> 01:17:43,090
because it read comes before or after the write.

1217
01:17:44,020 --> 01:17:47,700
So, one thing that can happen,

1218
01:17:47,700 --> 01:17:50,640
and most processors don't do this,

1219
01:17:50,670 --> 01:17:55,120
but, every time you have a,

1220
01:17:56,140 --> 01:18:00,100
like so these any thread can run on a separate core,

1221
01:18:00,700 --> 01:18:05,080
and every core has a buffer,

1222
01:18:05,230 --> 01:18:07,840
for the data that it's reading or writing,

1223
01:18:08,470 --> 01:18:10,300
or writing, I guess like a store buffer,

1224
01:18:10,360 --> 01:18:16,920
so for example thread 1 could write one value to the state,

1225
01:18:17,280 --> 01:18:19,500
and thread 2 could try to read it,

1226
01:18:19,680 --> 01:18:21,750
or like multiple threads can be writing,

1227
01:18:22,290 --> 01:18:25,110
and thread 1 without a lock,

1228
01:18:25,110 --> 01:18:27,990
so locks essentially flush the buffer,

1229
01:18:29,370 --> 01:18:30,870
without that lock,

1230
01:18:31,340 --> 01:18:36,560
this write might just like stay in thread 1's, like store for forever,

1231
01:18:37,040 --> 01:18:41,990
and the read will never return the updated value,

1232
01:18:42,320 --> 01:18:46,990
so this behavior doesn't quite happen in practice,

1233
01:18:46,990 --> 01:18:48,850
but it's an allowable behavior,

1234
01:18:48,880 --> 01:18:50,230
because you do not have a lot.

1235
01:18:51,240 --> 01:18:53,460
Sorry, so what happens if the write has a lock,

1236
01:18:53,460 --> 01:18:54,720
but the read doesn't,

1237
01:18:55,380 --> 01:18:57,960
like does the read always need a lock?

1238
01:19:02,970 --> 01:19:12,280
Yes, because, I think of it.

1239
01:19:13,970 --> 01:19:15,350
I I googled a little bit,

1240
01:19:15,350 --> 01:19:19,910
and people are like, yeah, don't, don't even try lock-less share data,

1241
01:19:19,910 --> 01:19:22,550
but I don't really understand why that would be a problem.

1242
01:19:23,270 --> 01:19:23,690
So it's.

1243
01:19:23,690 --> 01:19:24,560
You could like.

1244
01:19:25,490 --> 01:19:26,060
Go ahead.

1245
01:19:27,140 --> 01:19:29,900
You could like be doing something that assumes the thing was true,

1246
01:19:29,900 --> 01:19:31,130
and then like when you read,

1247
01:19:31,160 --> 01:19:32,780
it's not actually true yet,

1248
01:19:32,960 --> 01:19:34,850
like there might be multiple things, right,

1249
01:19:36,620 --> 01:19:38,510
that's why you don't want to lock this read.

1250
01:19:39,340 --> 01:19:45,580
So the only time you might be able to even get away with this is,

1251
01:19:45,580 --> 01:19:48,340
if you only read a single word,

1252
01:19:48,610 --> 01:19:50,710
and that's all the thread does,

1253
01:19:50,710 --> 01:19:52,870
and it never does multiple reads,

1254
01:19:54,050 --> 01:19:58,160
but I think you still have some issues with.

1255
01:20:01,150 --> 01:20:03,610
One of the other things is,

1256
01:20:04,300 --> 01:20:06,400
if you're reading more than one piece of data,

1257
01:20:06,490 --> 01:20:10,570
like if on one thread, you take lock, assign a assign b,

1258
01:20:10,690 --> 01:20:13,810
another thread, it doesn't take a lock,

1259
01:20:13,840 --> 01:20:16,930
might see b, the new value of b,

1260
01:20:16,930 --> 01:20:18,610
before it sees the new value of a,

1261
01:20:18,790 --> 01:20:20,110
the ordering that you messed up,

1262
01:20:20,110 --> 01:20:25,750
and so if you read like a term from one that, from one variable

1263
01:20:25,750 --> 01:20:29,140
and like whether not the leader from another variable,

1264
01:20:29,440 --> 01:20:33,370
you might read a pair of values that never actually existed,

1265
01:20:33,580 --> 01:20:36,780
because there aren't the guarantees,

1266
01:20:36,810 --> 01:20:39,300
like when you're [] to concrete systems,

1267
01:20:39,510 --> 01:20:44,700
you need to build everything based off what the guarantees are the platform provides you,

1268
01:20:44,700 --> 01:20:45,660
and if you don't,

1269
01:20:45,660 --> 01:20:49,740
there's all kinds of weird edge cases that can throw you off,

1270
01:20:49,950 --> 01:20:52,260
and yeah.

1271
01:20:52,640 --> 01:20:55,640
Yes, so I think the only case in which you can even,

1272
01:20:55,970 --> 01:20:57,920
like try to reason about this,

1273
01:20:57,950 --> 01:21:03,200
is this, is this there's only ever one like you know word in the system,

1274
01:21:03,200 --> 01:21:05,270
that you're ever trying to read and write to,

1275
01:21:05,360 --> 01:21:11,660
as soon as you try to write or read multiple pieces of data,

1276
01:21:11,660 --> 01:21:16,040
then it's like you won't be able to reason about anything without locks.

1277
01:21:17,480 --> 01:21:20,450
Basically, if you want to play games with this,

1278
01:21:20,450 --> 01:21:23,540
you have to really understand the compiler,

1279
01:21:23,540 --> 01:21:25,790
the whole [] language and memory model,

1280
01:21:25,850 --> 01:21:27,470
the processor you're using

1281
01:21:27,470 --> 01:21:30,200
and it's like memory consistency system,

1282
01:21:31,130 --> 01:21:34,130
it gets complicated, incredibly [].

1283
01:21:34,800 --> 01:21:37,620
Yeah, it's also like, I mean this is all undefined behavior,

1284
01:21:37,620 --> 01:21:39,030
so even if it works now,

1285
01:21:39,270 --> 01:21:42,690
like you know I could, someone could write a new compiler,

1286
01:21:42,690 --> 01:21:46,410
and then you're, like that's where the whole thing about,

1287
01:21:46,410 --> 01:21:48,360
like demons can fly out of your nose,

1288
01:21:48,360 --> 01:21:51,120
like it can literally do anything, if you have a data,

1289
01:21:51,120 --> 01:21:54,700
it's because like other programs like, doesn't have any semantic,

1290
01:21:54,700 --> 01:21:57,160
so we can like go crazy,

1291
01:21:57,580 --> 01:22:00,070
so I would I would not risk it.

1292
01:22:01,860 --> 01:22:03,240
Okay, it makes sense, thank you.

1293
01:22:04,270 --> 01:22:07,090
So, so even when we're accessing like anything,

1294
01:22:07,090 --> 01:22:09,310
just reading, let's say Raft server state,

1295
01:22:09,370 --> 01:22:11,530
we should still wrap it in a lock.

1296
01:22:12,280 --> 01:22:13,180
Yeah.

1297
01:22:13,180 --> 01:22:14,560
It just gets annoying sometimes,

1298
01:22:14,560 --> 01:22:15,460
because you have to like,

1299
01:22:16,120 --> 01:22:19,570
wrap the single read in a lock and unlock,

1300
01:22:19,570 --> 01:22:22,880
but I'm not sure like knows [].

1301
01:22:24,540 --> 01:22:27,960
That shouldn't happen super often,

1302
01:22:29,640 --> 01:22:33,450
like I mean, maybe if you want to for example check you're still a leader,

1303
01:22:33,480 --> 01:22:35,310
if you're not exit or something like that,

1304
01:22:35,880 --> 01:22:42,990
but, yeah, I don't, like, I forget,

1305
01:22:42,990 --> 01:22:47,400
do you use like atomic bools for like killed state for example,

1306
01:22:49,440 --> 01:22:51,570
that like you could use a [],

1307
01:22:51,570 --> 01:22:56,830
which essentially is like locking and unlocking right before accessing it and right after,

1308
01:22:58,520 --> 01:23:00,660
but, yeah,

1309
01:23:03,900 --> 01:23:09,090
I think you'll like having in some ways very coarse-grain locks,

1310
01:23:09,090 --> 01:23:12,270
and knowing that you're the only one touching a piece of state,

1311
01:23:12,270 --> 01:23:16,530
will become very handy as you reason about your implementations.

1312
01:23:17,860 --> 01:23:18,490
Thank you.

1313
01:23:21,930 --> 01:23:24,780
I have a question about the channels,

1314
01:23:24,780 --> 01:23:27,090
so when you make a channel,

1315
01:23:27,090 --> 01:23:30,120
it's only between two threads, right,

1316
01:23:30,120 --> 01:23:31,890
or it can be between multiple threads,

1317
01:23:31,890 --> 01:23:37,200
but like if you not, if you don't have buffered,

1318
01:23:37,350 --> 01:23:39,870
it can potentially just lock and block forever, right,

1319
01:23:39,870 --> 01:23:42,690
so, for example, if you want to do something in Raft,

1320
01:23:42,690 --> 01:23:44,430
and then you have an election,

1321
01:23:45,010 --> 01:23:46,270
you have a channel that like,

1322
01:23:46,840 --> 01:23:48,730
does something about election timeouts,

1323
01:23:48,730 --> 01:23:50,230
you will need a buffer channel,

1324
01:23:50,530 --> 01:23:53,230
that's like the size of the amount of servers, correct,

1325
01:23:53,230 --> 01:23:56,860
because you could like send something and then like it blocks,

1326
01:23:56,860 --> 01:23:58,870
because, you can be,

1327
01:23:58,870 --> 01:24:02,200
you can have multiple like election things,

1328
01:24:02,230 --> 01:24:06,320
election messages sent between the channels, correct,

1329
01:24:06,320 --> 01:24:08,030
so if you want a unbuffered channel,

1330
01:24:08,030 --> 01:24:12,530
it should only be between, it should only be between two threads only, correct?

1331
01:24:13,420 --> 01:24:14,950
I mean not necessarily,

1332
01:24:14,950 --> 01:24:16,420
like if two threads are consumers,

1333
01:24:16,420 --> 01:24:17,440
and one thread is producer,

1334
01:24:17,440 --> 01:24:18,040
that the.

1335
01:24:20,070 --> 01:24:24,180
Okay, but multiple producers, I guess you would need that, correct?

1336
01:24:25,790 --> 01:24:27,170
Well, not necessarily,

1337
01:24:27,170 --> 01:24:29,210
I mean, if the consumer is,

1338
01:24:29,360 --> 01:24:31,400
you know just doing a loop and constantly reading,

1339
01:24:31,400 --> 01:24:34,820
then all the producers would just,

1340
01:24:35,850 --> 01:24:39,350
like, I guess it depends on how they schedule,

1341
01:24:39,770 --> 01:24:41,090
by if,

1342
01:24:41,640 --> 01:24:45,300
you're like you would eventually have someone reading from the channel,

1343
01:24:45,750 --> 01:24:48,660
so you can have multiple producers and one consumer.

1344
01:24:51,040 --> 01:24:53,800
Actually, does anyone know about the, like Frans,

1345
01:24:54,550 --> 01:24:56,680
do you know about the ordering guarantees of channels,

1346
01:24:56,710 --> 01:24:59,230
like is their [] guarantee on you,

1347
01:25:02,620 --> 01:25:04,420
I feel like there is an [] guarantee,

1348
01:25:04,420 --> 01:25:05,620
so I guess if you have,

1349
01:25:06,220 --> 01:25:08,050
it's kind of like lock, right,

1350
01:25:08,230 --> 01:25:10,150
like if you're always trying to acquire the lock,

1351
01:25:10,150 --> 01:25:13,270
another thread is also spinning and trying to acquire the lock,

1352
01:25:13,300 --> 01:25:17,290
there's no guarantee that you will ever require it,

1353
01:25:17,350 --> 01:25:21,040
which is why like randomization might be necessary in that case,

1354
01:25:26,040 --> 01:25:29,610
also I realized I think this lecture is technically over,

1355
01:25:29,700 --> 01:25:31,650
I am holding the office hours right now,

1356
01:25:31,650 --> 01:25:33,450
so if you have questions along to

1357
01:25:33,450 --> 01:25:35,160
or want to continue asking questions,

1358
01:25:35,160 --> 01:25:35,790
I'll be there

1359
01:25:36,090 --> 01:25:37,950
and I think maybe Frans,

1360
01:25:37,950 --> 01:25:41,270
if you want to stick around or other, others.

1361
01:25:42,060 --> 01:25:45,030
But I will move to the office hours, now,

1362
01:25:46,620 --> 01:25:50,060
so, thank you all so much for coming.

1363
01:25:50,420 --> 01:25:51,080
Thank you.

1364
01:25:52,820 --> 01:25:53,630
Thank you.

1365
01:25:59,590 --> 01:26:01,810
Oh, can I just ask a quick question?

1366
01:26:03,440 --> 01:26:05,270
Yeah, alright, Frans, you're the host now,

1367
01:26:05,270 --> 01:26:07,610
so I'm going to just hop off to my office hour.

1368
01:26:07,610 --> 01:26:10,250
And what is the theme of the your Vim?

1369
01:26:11,600 --> 01:26:14,060
Oh, what's the scheme, like my color scheme.

1370
01:26:14,360 --> 01:26:14,810
Yeah.

1371
01:26:16,180 --> 01:26:17,260
That's a good question,

1372
01:26:17,260 --> 01:26:20,710
I'm not actually sure, let me check.

1373
01:26:24,620 --> 01:26:26,030
[].

1374
01:26:27,440 --> 01:26:29,000
Sorry?

1375
01:26:29,000 --> 01:26:30,170
I'll type in the chat.

1376
01:26:30,200 --> 01:26:30,980
Ha ha.

