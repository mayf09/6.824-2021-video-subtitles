1
00:00:05,230 --> 00:00:07,390
Alright, well, it's five after,

2
00:00:07,390 --> 00:00:09,070
so I'll just go ahead started,

3
00:00:09,310 --> 00:00:13,600
so today's lecture is a Q and A on the first lab,

4
00:00:13,600 --> 00:00:14,620
the mapreduce lab,

5
00:00:14,920 --> 00:00:21,010
and also some just general coding Q&As for Go programming that might help in future labs.

6
00:00:21,100 --> 00:00:23,110
So feel free to stop at any time

7
00:00:23,110 --> 00:00:24,430
or put questions in the chat

8
00:00:24,430 --> 00:00:26,620
and I'll be checking it occasionally,

9
00:00:27,280 --> 00:00:31,000
and I'm sure like other kids can also help as well,

10
00:00:31,570 --> 00:00:33,970
if you are unmuted and typing,

11
00:00:34,340 --> 00:00:35,480
it would be helpful if you [],

12
00:00:37,760 --> 00:00:38,660
but yeah.

13
00:00:38,750 --> 00:00:41,000
Alright, so the agenda for today,

14
00:00:41,000 --> 00:00:42,440
the first thing I'm going to do is,

15
00:00:42,440 --> 00:00:44,600
actually walk through a solution of lab 1

16
00:00:44,900 --> 00:00:47,330
and this is my personal solution,

17
00:00:47,330 --> 00:00:49,370
it's probably not perfect,

18
00:00:49,370 --> 00:00:52,040
but it's an example of what you could have done,

19
00:00:52,460 --> 00:01:00,740
second, we're going to discuss some alternative solution designs [] typing.

20
00:01:00,740 --> 00:01:01,550
[] typing.

21
00:01:02,980 --> 00:01:05,470
Alright, it's helpful to you,

22
00:01:06,520 --> 00:01:12,250
[] third, we're going to discuss some of the common design mistakes and some of the bugs,

23
00:01:12,250 --> 00:01:14,620
that you guys had in your solutions,

24
00:01:14,980 --> 00:01:17,770
for just over some general tips

25
00:01:17,770 --> 00:01:22,180
and then finally we're going to, if there's time, go to some Q&As,

26
00:01:22,180 --> 00:01:24,730
both questions you might have right now

27
00:01:24,790 --> 00:01:30,660
and also questions that you submitted, before lecture.

28
00:01:31,750 --> 00:01:35,590
So first for the lab solution walkthrough,

29
00:01:35,680 --> 00:01:38,800
let me know if the fonts too small,

30
00:01:38,800 --> 00:01:40,210
I'll just stick with this.

31
00:01:40,950 --> 00:01:46,400
Alright, so I basically, one step by step,

32
00:01:46,400 --> 00:01:48,500
and I'll show how I developed my solution,

33
00:01:48,770 --> 00:01:51,530
so the first thing I did was,

34
00:01:51,800 --> 00:01:53,630
this is rpc.go

35
00:01:53,960 --> 00:01:56,960
and the first thing I did was figure out the API

36
00:01:56,960 --> 00:01:59,840
in which I wanted my worker and coordinator to communicate,

37
00:02:00,530 --> 00:02:06,050
and so the first thing I did was define what types of tasks there are

38
00:02:06,470 --> 00:02:08,300
and so there map and reduce tasks

39
00:02:08,300 --> 00:02:14,390
and in order to signal that the coordinator has things the job is done, is the done task,

40
00:02:14,940 --> 00:02:17,130
and so, these are the types of task.

41
00:02:17,820 --> 00:02:21,570
Zoom in a bit, can you zoom in a bit, flies.

42
00:02:21,570 --> 00:02:24,330
Yeah, is that okay?

43
00:02:26,410 --> 00:02:28,090
Yeah, thanks.

44
00:02:29,060 --> 00:02:32,750
Cool, yeah, it's hard for me to tell how it looked.

45
00:02:33,740 --> 00:02:35,930
Yeah, so hopefully this is good,

46
00:02:36,200 --> 00:02:42,550
and so the there two RPCs I decided to implement,

47
00:02:42,730 --> 00:02:46,390
the first is a worker asking the coordinator to give it a task,

48
00:02:46,540 --> 00:02:49,960
so one of mapreduce or done in please exit

49
00:02:50,290 --> 00:02:53,830
and basically there's like the argument,

50
00:02:53,830 --> 00:02:57,400
you don't really have any arguments or just asking for a task

51
00:02:57,430 --> 00:03:01,420
and the coordinator replies with what task is this,

52
00:03:01,450 --> 00:03:04,240
which task of that type should you do,

53
00:03:05,240 --> 00:03:10,220
and also some extra data that's needed for the map or reduce tasks,

54
00:03:10,220 --> 00:03:12,590
such as the number of map tasks in the system

55
00:03:12,680 --> 00:03:14,300
or the number reduce tasks.

56
00:03:15,380 --> 00:03:19,040
And the second RPC is a finished task RPC,

57
00:03:19,070 --> 00:03:21,680
that the worker uses to notify the coordinator,

58
00:03:21,980 --> 00:03:23,660
that it has finished the task

59
00:03:23,720 --> 00:03:27,860
and it passes as arguments which task has finished,

60
00:03:28,450 --> 00:03:31,150
and they don't actually really need to get a reply for this.

61
00:03:32,000 --> 00:03:34,820
So that's the first step of the implementation,

62
00:03:38,390 --> 00:03:39,350
so hi.

63
00:03:40,190 --> 00:03:42,320
Alright, so as a second step,

64
00:03:42,350 --> 00:03:45,740
what I did is implement the handlers for all these RPCs

65
00:03:45,980 --> 00:03:47,900
and so that's in coordinator,

66
00:03:49,070 --> 00:03:53,870
so, first I had to actually populate the coordinator with the coordinator state

67
00:03:54,200 --> 00:03:57,830
and so there's the mutexes which protects the state from concurrent access,

68
00:03:57,830 --> 00:04:01,880
because the coordinator will have multiple threads running concurrently,

69
00:04:02,180 --> 00:04:07,880
then the second part is to keep track of just like the files that we need for map task

70
00:04:08,030 --> 00:04:09,860
and the number of map and reduce tasks,

71
00:04:10,510 --> 00:04:16,780
and this metadata is used to track which tasks have we issued

72
00:04:16,930 --> 00:04:18,580
and which tasks have finished,

73
00:04:18,880 --> 00:04:23,050
the once that we've issued we keep track of our timestamps,

74
00:04:23,050 --> 00:04:27,520
that we know if these tasks have been completed within a certain amount of time to reissue them,

75
00:04:28,390 --> 00:04:31,000
and finally we have the,

76
00:04:31,120 --> 00:04:35,050
like has all, has a coordinator finished boolean.

77
00:04:36,780 --> 00:04:40,320
So to handle the get task RPC, we have a handler,

78
00:04:40,590 --> 00:04:44,310
that essentially what it does is,

79
00:04:44,430 --> 00:04:46,380
it will set the reply fields,

80
00:04:46,650 --> 00:04:51,540
right now, I haven't yet implemented the part, that actually issues the task,

81
00:04:51,990 --> 00:04:55,050
and if all the map and reduce tasks are done,

82
00:04:55,140 --> 00:04:58,230
it will send a done task to the worker and exit.

83
00:04:59,190 --> 00:05:05,520
And then we have the the handler for the finished task RPC

84
00:05:05,820 --> 00:05:07,080
and what this does is,

85
00:05:07,080 --> 00:05:10,290
it basically depending on what task it was,

86
00:05:10,920 --> 00:05:13,980
set that flag to true,

87
00:05:13,980 --> 00:05:16,410
that has that task has finished.

88
00:05:17,550 --> 00:05:19,020
So that's the second step,

89
00:05:19,020 --> 00:05:21,240
which is implementing the handlers with RPCs.

90
00:05:24,120 --> 00:05:28,890
So the third step I have is actually sending the RPCs

91
00:05:29,610 --> 00:05:33,890
and so that happened is the work here.

92
00:05:35,930 --> 00:05:41,690
So, top of this is,

93
00:05:41,990 --> 00:05:44,000
we provided what it does is,

94
00:05:44,000 --> 00:05:45,200
it starts up this loop,

95
00:05:45,560 --> 00:05:48,320
that basically for every loop,

96
00:05:48,320 --> 00:05:52,160
it calls the handler for get task in the coordinator

97
00:05:52,760 --> 00:05:54,470
and depending on what task it gets,

98
00:05:54,470 --> 00:05:58,430
it will either perform map task with the relevant data

99
00:05:58,430 --> 00:06:01,310
or metadata that needs perform the reduce task

100
00:06:01,310 --> 00:06:02,990
or in the case of done, it will exit.

101
00:06:03,570 --> 00:06:05,670
And so it's very simple

102
00:06:05,670 --> 00:06:06,960
and once it's finished that task,

103
00:06:07,170 --> 00:06:11,070
it will send a finished task RPC to the coordinator.

104
00:06:11,620 --> 00:06:17,650
So this is just the skeleton code for the worker sending RPCs.

105
00:06:19,100 --> 00:06:21,950
Alright, so we have RPCs, we have handlers, we have the senders,

106
00:06:22,160 --> 00:06:24,800
and so now, let's actually implement some stuff.

107
00:06:25,220 --> 00:06:35,990
So in step four, it's I just added a ton of handlers to manage this intermediate file,

108
00:06:36,590 --> 00:06:38,780
which a lot of you also did

109
00:06:39,200 --> 00:06:41,990
and basically it uses like os.Rename,

110
00:06:41,990 --> 00:06:43,730
it gets a temporary file,

111
00:06:44,900 --> 00:06:46,550
so it's not too interesting

112
00:06:47,150 --> 00:06:51,890
and then the next step, let's actually implement some of the worker functionality.

113
00:06:52,430 --> 00:06:54,930
So, we're back in the worker,

114
00:06:55,900 --> 00:06:58,930
and now let's implement the performMap function,

115
00:07:00,270 --> 00:07:04,740
and what this does is as many you have to do is

116
00:07:04,770 --> 00:07:07,650
read the file, map them to keys

117
00:07:07,710 --> 00:07:12,360
and then create temporary files, write them to the intermediate files,

118
00:07:12,360 --> 00:07:15,000
and then we use an atomic rename

119
00:07:15,030 --> 00:07:19,590
to ensure that maps aren't conflicting as they process the keys and write them.

120
00:07:20,550 --> 00:07:25,410
So this is pretty much taken from the sequential implementation

121
00:07:25,440 --> 00:07:27,390
and how you would apply the map function.

122
00:07:28,590 --> 00:07:34,590
And then similarly, we implement the reduce function,

123
00:07:34,860 --> 00:07:38,640
so here's a performMap, and then we have performReduce

124
00:07:39,000 --> 00:07:40,440
and so what that does is,

125
00:07:40,440 --> 00:07:44,040
it gets all the intermediate files with the appropriate,

126
00:07:44,340 --> 00:07:47,850
from all the map tasks, for this reduced task

127
00:07:48,510 --> 00:07:54,640
and sorts them, so sorting happens in the, in the worker,

128
00:07:54,670 --> 00:08:00,070
because the worker needs, the reducer needs access to all keys of that type

129
00:08:00,100 --> 00:08:01,840
and then to sort them.

130
00:08:03,240 --> 00:08:04,770
It wouldn't make sense for the mapper,

131
00:08:04,770 --> 00:08:05,880
just sort them before,

132
00:08:05,910 --> 00:08:08,940
because the mapper only has access to the keys.

133
00:08:10,440 --> 00:08:13,860
And then we apply the reduce function to all values of the same key,

134
00:08:13,860 --> 00:08:19,080
and then we atomically rename the temporary reduce file to the final reduce file.

135
00:08:20,470 --> 00:08:24,370
So, now this loop we've implemented basically,

136
00:08:25,000 --> 00:08:27,190
the actual performance of the task

137
00:08:27,220 --> 00:08:30,670
and we're basically done with the worker implementation.

138
00:08:31,820 --> 00:08:33,350
So one last step remains

139
00:08:33,410 --> 00:08:39,260
and that's actually implementing how this coordinator tells the worker which tasks to do

140
00:08:39,620 --> 00:08:46,940
and this is probably where you ran into the most complexity with synchronization in the coordinator.

141
00:08:49,040 --> 00:08:50,450
So go back to the coordinator,

142
00:08:51,500 --> 00:08:54,590
so nothing has changed in the state,

143
00:08:55,010 --> 00:08:56,720
so, but now what we've done is,

144
00:08:56,720 --> 00:08:58,700
we've added a loop in the coordinator,

145
00:08:58,730 --> 00:09:01,310
that handles sending the task to the worker.

146
00:09:02,720 --> 00:09:07,170
And when we're issuing the map task,

147
00:09:07,170 --> 00:09:09,420
so first we want to issue all the map task

148
00:09:09,780 --> 00:09:14,010
and so essentially what this loop does here is

149
00:09:14,040 --> 00:09:16,650
until there's a task to issue,

150
00:09:16,830 --> 00:09:21,930
the coordinator will just iterate through this loop,

151
00:09:22,200 --> 00:09:23,910
and if we're done with all the map tasks,

152
00:09:23,910 --> 00:09:24,990
that will break out the loop,

153
00:09:26,730 --> 00:09:28,560
and then, if all the map tasks are done,

154
00:09:28,560 --> 00:09:30,150
then we issue reduce task,

155
00:09:31,080 --> 00:09:32,310
which is what's in here.

156
00:09:35,380 --> 00:09:40,750
So, yeah, I have, I guess I have one last step,

157
00:09:40,750 --> 00:09:45,430
which is actually what we do, when the maps or reduces,

158
00:09:45,640 --> 00:09:48,070
when there's no task to issue

159
00:09:48,100 --> 00:09:49,960
and so we want to do then,

160
00:09:50,050 --> 00:09:53,680
is the coordinator should just wait for a task issue

161
00:09:53,950 --> 00:09:56,920
and once it, there's a task issue,

162
00:09:56,920 --> 00:09:58,690
another issue through the loop

163
00:09:58,720 --> 00:10:00,940
and then actually issue the task.

164
00:10:01,650 --> 00:10:05,010
I'll continue until all the map were all reduced tests are done.

165
00:10:06,720 --> 00:10:08,550
And after done, I'll return again,

166
00:10:08,580 --> 00:10:10,380
so let me go.

167
00:10:13,620 --> 00:10:18,360
Right, so in order to support that waiting,

168
00:10:19,640 --> 00:10:23,360
what my solution does is it uses a condition variable,

169
00:10:24,610 --> 00:10:29,650
and essentially what that does is,

170
00:10:29,890 --> 00:10:32,890
if there are no map task issue,

171
00:10:33,250 --> 00:10:40,360
but the mappers, but there, because we've assigned all of them, for example

172
00:10:40,390 --> 00:10:41,470
and we're waiting for them

173
00:10:41,500 --> 00:10:43,360
and they haven't timed out yet,

174
00:10:43,450 --> 00:10:45,610
then we want to do is wait,

175
00:10:45,670 --> 00:10:49,210
because we cannot issue a reduce task,

176
00:10:49,210 --> 00:10:50,740
if all the mappers have not finished,

177
00:10:51,040 --> 00:10:53,290
so we're just going to wait here

178
00:10:53,410 --> 00:10:56,410
and then once we get some type of signal,

179
00:10:56,470 --> 00:10:58,780
we're just going to go back to the top of this loop,

180
00:10:59,130 --> 00:11:01,050
and check whether we can issue a task again.

181
00:11:02,510 --> 00:11:06,170
Similarly, if all the reducers aren't done,

182
00:11:06,170 --> 00:11:08,990
but we can't actually issue the worker a task,

183
00:11:09,020 --> 00:11:12,680
we're going to wait for there to be some type of signals,

184
00:11:12,680 --> 00:11:14,810
so when does the signal actually happen.

185
00:11:15,380 --> 00:11:22,340
Well, we want to signal any time either a task has gone on for too long

186
00:11:22,340 --> 00:11:23,300
and we haven't heard back,

187
00:11:23,300 --> 00:11:24,710
so there might have been a failure

188
00:11:25,430 --> 00:11:29,960
or if the, if a worker has actually completed a task,

189
00:11:29,960 --> 00:11:33,050
because for example that might mean all the map tasks has finished,

190
00:11:33,050 --> 00:11:34,580
we can move on to a reduce task.

191
00:11:35,430 --> 00:11:39,210
So in order to do that,

192
00:11:39,210 --> 00:11:41,610
what we have are,

193
00:11:45,020 --> 00:11:46,490
we have a Go routine here,

194
00:11:46,520 --> 00:11:53,370
that's kind of [spun] off immediately as the coordinator starts

195
00:11:53,490 --> 00:11:56,400
and what this does is every once in awhile,

196
00:11:56,700 --> 00:12:00,780
after some you know maybe every second or so,

197
00:12:00,810 --> 00:12:02,820
when a task might have finished,

198
00:12:03,310 --> 00:12:05,260
or maybe this is ten seconds, I can't remeber,

199
00:12:05,380 --> 00:12:06,880
actually it doesn't really matter,

200
00:12:06,910 --> 00:12:09,370
it just wants to wake up the coordinator every so often,

201
00:12:09,370 --> 00:12:11,710
so the coordinator will do another check

202
00:12:11,860 --> 00:12:13,960
to see whether there is a task to issue

203
00:12:14,110 --> 00:12:15,640
and so it just loops around

204
00:12:15,850 --> 00:12:19,690
and every second it will broadcast to wake up the coordinator.

205
00:12:22,620 --> 00:12:26,550
And the other time we want to signal when a task is finished,

206
00:12:26,970 --> 00:12:30,840
so that's actually going to happen in this handle finish task,

207
00:12:30,870 --> 00:12:37,140
which is called when a worker like [] finished the task RPC

208
00:12:37,680 --> 00:12:47,250
and so here we have a broadcast right after we set the [] to done or to complete it to done

209
00:12:47,730 --> 00:12:52,520
and when the coordinator goes back to go check one of these loops

210
00:12:52,520 --> 00:12:54,950
and see whether there's a task to finish,

211
00:12:54,980 --> 00:12:58,070
it will see that updated done status.

212
00:12:59,120 --> 00:13:02,240
So that's essentially my solution,

213
00:13:02,510 --> 00:13:09,680
it gives cond vars and mutexes to protect shared state of coordinator.

214
00:13:11,000 --> 00:13:12,920
So this is only one possible solution

215
00:13:13,520 --> 00:13:16,280
and I'll get back to here

216
00:13:16,880 --> 00:13:21,920
and so this is the kind of layout of the steps I took.

217
00:13:22,860 --> 00:13:27,330
Are there any questions on that particular solution before I move on?

218
00:13:30,910 --> 00:13:35,200
Can you please elaborate a little more on the conditional variable?

219
00:13:36,770 --> 00:13:47,060
Sure, so, what exactly, I guess like a conditional variable is,

220
00:13:47,730 --> 00:13:54,870
very useful for when you want to wait for a particular predicate or particular condition to become true,

221
00:13:55,080 --> 00:14:00,590
so in this case, condition variable is a natural,

222
00:14:00,740 --> 00:14:04,490
let me just go to wherever I use,

223
00:14:05,300 --> 00:14:10,970
is a natural way to implement waiting for there to be a task available,

224
00:14:11,060 --> 00:14:14,360
because you know it's a particular condition

225
00:14:14,630 --> 00:14:19,210
and it occurs asynchronously,

226
00:14:19,210 --> 00:14:22,240
so for example a task is available,

227
00:14:22,270 --> 00:14:25,180
when a worker has finished a task

228
00:14:25,510 --> 00:14:33,910
or task might be available when the, when a failure occurs

229
00:14:33,910 --> 00:14:35,710
and we need to reissue the task,

230
00:14:35,800 --> 00:14:44,790
so you can think of, any case in which, you need to wait for a particular condition,

231
00:14:44,820 --> 00:14:48,000
that's where condition variables become very helpful.

232
00:14:48,840 --> 00:14:51,000
Does that help a little bit?

233
00:14:51,970 --> 00:14:53,080
Yeah, thank you.

234
00:14:56,000 --> 00:14:57,110
You can also,

235
00:14:57,170 --> 00:15:03,110
like all of these higher level like channels condition variables,

236
00:15:03,110 --> 00:15:05,600
all these higher level synchronization primitives actually,

237
00:15:05,600 --> 00:15:07,730
they're built on top of locks,

238
00:15:07,850 --> 00:15:10,550
so they're all implemented using locks is just,

239
00:15:10,550 --> 00:15:15,400
there, kind of a higher level way of thinking about synchronization,

240
00:15:15,400 --> 00:15:18,130
that allows you to reason for example about conditions.

241
00:15:22,050 --> 00:15:27,870
Would that have the same effect, as for example sleeping in that loop,

242
00:15:27,870 --> 00:15:31,710
that you have in the get task function

243
00:15:31,710 --> 00:15:39,420
instead of like having a condition variable, that makes the loop run every second,

244
00:15:40,250 --> 00:15:40,700
I guess.

245
00:15:40,700 --> 00:15:45,860
Yeah, so, it it is, like it's essentially the same as sleeping,

246
00:15:45,890 --> 00:15:54,780
the, so the loop here, the timeout loop here,

247
00:15:55,780 --> 00:15:57,940
the difference is that,

248
00:15:58,970 --> 00:16:01,700
for example, the condition variable,

249
00:16:01,700 --> 00:16:05,600
or you could be woken up by a task that has completed,

250
00:16:06,140 --> 00:16:10,880
where in a loop in which you sleep, for example a second every single loop,

251
00:16:11,210 --> 00:16:13,220
you have to wait a second,

252
00:16:13,830 --> 00:16:15,750
whereas with a condition variable,

253
00:16:15,750 --> 00:16:19,250
you could be woken up after you know like ten milliseconds,

254
00:16:19,250 --> 00:16:21,380
because the worker has completed a task,

255
00:16:21,650 --> 00:16:25,760
so it potentially has better liveness properties.

256
00:16:27,800 --> 00:16:30,200
By this case, we do like say,

257
00:16:30,200 --> 00:16:35,230
if every task always takes over like five seconds or something,

258
00:16:35,290 --> 00:16:41,830
then yes, this is essentially very similar to sleeping for one second every loop.

259
00:16:43,680 --> 00:16:45,930
I have a question,

260
00:16:45,930 --> 00:16:47,880
I think I missed the part where you run,

261
00:16:48,580 --> 00:16:52,960
how you handle, when a request comes for a task,

262
00:16:52,960 --> 00:16:55,870
but you're like there's no tasks to give out currently,

263
00:16:55,870 --> 00:17:00,070
like you, how do you tell the worker to like sort of either come back

264
00:17:00,070 --> 00:17:01,720
or do you keep them waiting

265
00:17:01,750 --> 00:17:04,960
and sort of [tangentially] to that,

266
00:17:05,860 --> 00:17:10,030
I'm curious why you chose this like sleep way of doing it

267
00:17:10,030 --> 00:17:14,920
instead of just like checking the time when you get request for tasks

268
00:17:14,920 --> 00:17:17,520
and seeing, like when you get a request,

269
00:17:17,520 --> 00:17:19,470
what has timed out and reissuing it,

270
00:17:20,320 --> 00:17:23,500
then instead of like constanly checking.

271
00:17:24,160 --> 00:17:26,050
Yeah, okay, so,

272
00:17:26,790 --> 00:17:29,940
yeah, so I'll just your first question first,

273
00:17:30,330 --> 00:17:36,150
so basically how I handle the I've completed the task,

274
00:17:37,020 --> 00:17:42,260
is once all map tasks have finished,

275
00:17:42,260 --> 00:17:44,750
once all reduce tasks have finished,

276
00:17:44,810 --> 00:17:48,680
then the task that we return to the worker,

277
00:17:48,830 --> 00:17:55,670
because the worker has called us task for, task is this extra task type that I called done,

278
00:17:56,680 --> 00:18:01,510
and then I also said that the coordinator is done to true

279
00:18:02,230 --> 00:18:04,390
and so in the workers, I'll go to the worker

280
00:18:05,530 --> 00:18:09,940
and the worker we have this loop,

281
00:18:09,940 --> 00:18:13,540
that basically as the worker is asking for tasks,

282
00:18:13,930 --> 00:18:18,250
if it gets returned tasks is a done task, then it exits.

283
00:18:18,680 --> 00:18:21,950
So that's how I handle conveying to the worker,

284
00:18:21,950 --> 00:18:23,540
that it should exit.

285
00:18:23,570 --> 00:18:25,280
I guess I was asking like,

286
00:18:25,310 --> 00:18:30,110
sorry, if you know let's say you're still finishing up on your map tasks,

287
00:18:30,560 --> 00:18:32,780
and you get requests for a task

288
00:18:33,170 --> 00:18:35,210
and you still can't give out your reduce tasks,

289
00:18:35,630 --> 00:18:37,160
how do you tell the worker?

290
00:18:38,060 --> 00:18:45,760
Oh, so, a lot of you are, an alternative design is to

291
00:18:45,850 --> 00:18:49,120
basically if the worker, if there's no task to give the worker,

292
00:18:49,570 --> 00:18:54,130
then the coordinator returns a reply to the worker immediately

293
00:18:54,370 --> 00:18:56,470
and the worker sleeps in its loop,

294
00:18:56,770 --> 00:18:58,990
but you can see here right,

295
00:18:58,990 --> 00:19:00,820
the worker loop, there is no sleep,

296
00:19:01,820 --> 00:19:03,260
and the reason for this is,

297
00:19:03,260 --> 00:19:08,150
because this call will block until the coordinator replies,

298
00:19:09,130 --> 00:19:10,420
and in my solution,

299
00:19:11,490 --> 00:19:13,200
going back to the coordinator,

300
00:19:13,560 --> 00:19:15,900
for example like if you look at [] done,

301
00:19:17,180 --> 00:19:25,040
in this solution, the coordinator handler will not return that reply to that call,

302
00:19:25,250 --> 00:19:28,430
unless it has a task to return,

303
00:19:28,820 --> 00:19:33,710
so it's, we're waiting in the coordinator rather than in the worker.

304
00:19:34,660 --> 00:19:37,180
So the coordinator is the one

305
00:19:37,360 --> 00:19:42,280
that is constantly checking to see whether there's a task and sleeping,

306
00:19:42,400 --> 00:19:46,720
whereas the worker just simply blocks on this call,

307
00:19:47,220 --> 00:19:49,080
until the coordinator returns to it.

308
00:19:49,690 --> 00:19:54,700
Is there any advantage to doing it in the coordinator?

309
00:19:59,550 --> 00:20:02,670
So I think one advantage is that,

310
00:20:04,940 --> 00:20:09,330
all the workers aren't constantly sending RPCs,

311
00:20:09,600 --> 00:20:10,590
you send an RPC,

312
00:20:10,590 --> 00:20:13,290
it's one RPC per task, right,

313
00:20:13,920 --> 00:20:18,180
whereas if the worker is constantly looping and sleeping and constantly reply,

314
00:20:18,180 --> 00:20:19,890
you have a lot more network traffic.

315
00:20:20,660 --> 00:20:21,260
Okay.

316
00:20:21,620 --> 00:20:26,510
Yeah, I think that's, but definitely both solutions are feasible,

317
00:20:26,510 --> 00:20:27,710
and they both work.

318
00:20:28,510 --> 00:20:29,260
Great.

319
00:20:29,580 --> 00:20:32,130
I had one other question,

320
00:20:32,130 --> 00:20:38,640
which is I I I see you use a defer for the locking quite a bit,

321
00:20:39,930 --> 00:20:41,880
while I was doing my implementation,

322
00:20:41,880 --> 00:20:43,050
I I realized,

323
00:20:43,050 --> 00:20:45,450
I mean in a straightforward function,

324
00:20:45,450 --> 00:20:47,140
it, it's clear,

325
00:20:47,170 --> 00:20:49,630
when it gives up control of the lock,

326
00:20:50,210 --> 00:20:59,210
when but for example if you, like have a Go routine created from within the function,

327
00:21:00,020 --> 00:21:03,680
it's not very clear, when it gives up control.

328
00:21:05,100 --> 00:21:07,770
So a Go routine runs on a separate thread,

329
00:21:07,770 --> 00:21:11,220
so the Go routine never starts with the lock acquired,

330
00:21:11,220 --> 00:21:14,370
even if you spin off the routine, while you hold the lock.

331
00:21:14,640 --> 00:21:15,570
Okay.

332
00:21:15,870 --> 00:21:16,560
Yeah.

333
00:21:16,920 --> 00:21:21,030
If we, if we issue like a Go, if we create a Go routine,

334
00:21:21,090 --> 00:21:22,890
it'll just spin up a thread

335
00:21:23,040 --> 00:21:26,340
and from the beginning, it won't have a lock, right?

336
00:21:26,340 --> 00:21:28,680
Yeah, it's actually just like,

337
00:21:29,150 --> 00:21:34,160
you know you think about another thread just starting to run that Go like Go func, that function.

338
00:21:35,720 --> 00:21:36,950
Yeah.

339
00:21:37,700 --> 00:21:38,240
Yeah.

340
00:21:38,480 --> 00:21:44,090
And then defer unlocks at any return, like any return statement there.

341
00:21:44,730 --> 00:21:47,340
Yep, yeah, it's pushed onto a,

342
00:21:47,490 --> 00:21:51,840
like basically like the functions to run when the,

343
00:21:52,380 --> 00:21:58,610
there's a stack of functions that the returning from like handle get task will run,

344
00:21:59,060 --> 00:22:01,940
so, I also have this in the slides,

345
00:22:01,940 --> 00:22:03,530
so you'll be able to refer to this later,

346
00:22:03,830 --> 00:22:07,400
but defer just ensures that when this function exits,

347
00:22:07,760 --> 00:22:09,680
you over you around a lock

348
00:22:09,710 --> 00:22:16,280
and then I could also do something, like unlocking

349
00:22:17,240 --> 00:22:24,510
and like I could just do something like before the last print or [],

350
00:22:25,110 --> 00:22:28,110
so these are all pushed onto a stack,

351
00:22:28,140 --> 00:22:32,640
and then they're popped off in FIFO order, no LIFO order.

352
00:22:33,470 --> 00:22:44,240
What FIFO? First in first out, no they're run in last in out, yeah,

353
00:22:44,720 --> 00:22:45,800
so it's a stack right,

354
00:22:45,800 --> 00:22:50,440
so this will run before unlocking,

355
00:22:50,440 --> 00:22:53,230
which will actually run before the lock,

356
00:22:53,260 --> 00:22:55,360
so if you're ready to use multiple defers,

357
00:22:55,360 --> 00:22:57,340
be careful in the order, then use them,

358
00:22:57,550 --> 00:23:01,720
but deferring the unlock at least is a very useful strategy,

359
00:23:03,260 --> 00:23:04,280
that will come in handy.

360
00:23:05,040 --> 00:23:08,250
OK, so the last thing is,

361
00:23:08,280 --> 00:23:16,730
if we call a function within within our our function,

362
00:23:16,760 --> 00:23:18,200
where we acquire the lock,

363
00:23:18,320 --> 00:23:20,720
it doesn't return the lock, right,

364
00:23:21,170 --> 00:23:23,360
when it goes to the other function,

365
00:23:23,780 --> 00:23:25,820
the other function returns to this function,

366
00:23:26,600 --> 00:23:32,690
and then until we like the thread keeps a lock, like through like jumping around.

367
00:23:34,880 --> 00:23:36,380
Yeah, so like a function,

368
00:23:36,380 --> 00:23:39,260
that's just like a normal function call within one thread

369
00:23:39,350 --> 00:23:42,050
will be called with the lock out yes.

370
00:23:43,570 --> 00:23:44,470
Cool, thanks.

371
00:23:46,360 --> 00:23:46,750
Yeah.

372
00:23:48,540 --> 00:23:53,130
Alright, so you guys have already kind of discussed some of the alternate synchronization designs,

373
00:23:53,520 --> 00:23:56,370
like waiting in the worker rather than the coordinator

374
00:23:56,370 --> 00:24:00,040
and we've talked about some of the pros and cons of that, using time,

375
00:24:00,070 --> 00:24:02,800
actually I think you covered all of these except for channels, maybe,

376
00:24:04,640 --> 00:24:06,950
so there's one thing I wanted to know,

377
00:24:06,950 --> 00:24:08,810
because there are a couple questions about this,

378
00:24:09,020 --> 00:24:11,630
so waiting for map has to be done

379
00:24:11,630 --> 00:24:17,150
or like any synchronization that we've shown is on a single server,

380
00:24:17,210 --> 00:24:21,470
so cross server communication between the worker and the coordinator,

381
00:24:22,250 --> 00:24:25,340
they're only it's only done ever by RPCs,

382
00:24:25,520 --> 00:24:29,930
so for example like locking in the coordinator has nothing to do with locking on the worker

383
00:24:30,110 --> 00:24:33,560
or on interactive implementation locking on different servers,

384
00:24:33,980 --> 00:24:36,170
like don't interfere with each other,

385
00:24:37,110 --> 00:24:38,490
I just want to be clear about that.

386
00:24:39,270 --> 00:24:42,510
So one thing I thought would be interesting is

387
00:24:42,510 --> 00:24:47,150
for you to see a kind of an example using channels,

388
00:24:47,150 --> 00:24:50,780
because there are also some questions using channels, about using channels.

389
00:24:51,680 --> 00:24:59,600
So this is kind of, is a not complete implementation of using channels,

390
00:24:59,810 --> 00:25:02,690
but it's a potential way to,

391
00:25:03,160 --> 00:25:06,310
but you could think about having used channels in mapreduce.

392
00:25:06,910 --> 00:25:09,160
And so in this example,

393
00:25:09,340 --> 00:25:12,910
the input to the coordinator actually includes a channel,

394
00:25:13,530 --> 00:25:18,840
in which the coordinator is told of what workers exist,

395
00:25:19,140 --> 00:25:25,480
and this is to handle the possibility that workers are failing,

396
00:25:25,510 --> 00:25:28,690
and then some client is telling the coordinator,

397
00:25:28,690 --> 00:25:30,850
hey, this other worker joined our cluster,

398
00:25:30,880 --> 00:25:33,100
here's a new worker that you can give tasks to,

399
00:25:33,310 --> 00:25:36,970
so it's slightly different than what we had in the lab.

400
00:25:37,950 --> 00:25:41,820
So the coordinator has two channels,

401
00:25:42,440 --> 00:25:47,480
one in which it will send tasks to workers

402
00:25:47,600 --> 00:25:50,150
or it won't send tasks to workers,

403
00:25:50,150 --> 00:25:54,110
will send tasks to a thread, that will issue tasks to workers

404
00:25:54,860 --> 00:25:56,810
and then it has a done channel.

405
00:25:57,310 --> 00:26:00,190
So again, just like,

406
00:26:01,080 --> 00:26:03,570
I I know I said something a little strange,

407
00:26:03,570 --> 00:26:07,650
which I was like you can send tasks to workers over the channel, but you actually can't,

408
00:26:07,770 --> 00:26:10,860
the channel is only on the coordinate your server,

409
00:26:11,070 --> 00:26:12,660
and we'll see how that works in a second.

410
00:26:13,660 --> 00:26:18,310
So the first thread of the coordinator that we create is a Go routine,

411
00:26:18,310 --> 00:26:25,480
that basically will for every worker start the issue worker task thread.

412
00:26:25,980 --> 00:26:28,480
So, what this does is,

413
00:26:28,480 --> 00:26:31,360
as workers are you know coming and going,

414
00:26:31,360 --> 00:26:33,430
because they're failing and then restarting,

415
00:26:33,610 --> 00:26:35,200
this channel basically says,

416
00:26:35,200 --> 00:26:37,720
okay, we want to for any of these workers,

417
00:26:38,020 --> 00:26:41,260
start a thread that will issue this worker tasks.

418
00:26:41,960 --> 00:26:45,200
So this is one Go routine here,

419
00:26:46,620 --> 00:26:48,360
then the coordinator what it does,

420
00:26:48,360 --> 00:26:50,760
is it for all the tasks that were giving,

421
00:26:50,760 --> 00:26:53,680
it just push those tasks onto this tasks channel.

422
00:26:54,590 --> 00:26:58,490
And this tasks channel, we actually made it a buffer channel,

423
00:26:58,730 --> 00:27:02,270
so that we know it will hold exactly numTask tasks,

424
00:27:02,270 --> 00:27:06,440
which are the that's the limit of the number of tasks,

425
00:27:06,470 --> 00:27:08,150
that will exist on the system,

426
00:27:08,150 --> 00:27:10,370
so what this also means is that,

427
00:27:10,370 --> 00:27:17,060
we can push the number of tasks task onto this channel without blocking,

428
00:27:17,240 --> 00:27:21,170
so the coordinator will not block on pushing task to the tasks channel.

429
00:27:22,170 --> 00:27:27,000
And then the coordinator will read from this done channel

430
00:27:27,030 --> 00:27:31,020
until it has done so number of task times,

431
00:27:31,200 --> 00:27:33,660
in which case, it knows it's done,

432
00:27:33,660 --> 00:27:37,080
in this case, where I'm not separating map or reduce tasks,

433
00:27:37,080 --> 00:27:38,520
let's just imagine that there are,

434
00:27:38,550 --> 00:27:41,610
some number of tasks that the coordinator needs to run.

435
00:27:42,700 --> 00:27:46,270
And once it knows that tasks, all the tasks have finished,

436
00:27:46,270 --> 00:27:52,450
it closes the tasks channel, and then basically will exit.

437
00:27:53,520 --> 00:27:58,740
And so the, where some of the interesting part comes in is,

438
00:27:58,980 --> 00:28:00,840
these worker task threads,

439
00:28:00,840 --> 00:28:03,540
which I've separated out and just function here.

440
00:28:04,420 --> 00:28:07,390
So, these all run on separate Go routines,

441
00:28:07,910 --> 00:28:11,360
and what it does is for,

442
00:28:11,990 --> 00:28:14,540
as long as there are tasks in the task queue,

443
00:28:14,990 --> 00:28:16,700
it will pull a task out

444
00:28:17,180 --> 00:28:20,390
and then oops, I didn't mean to that,

445
00:28:20,540 --> 00:28:25,680
and then call basically an RPC,

446
00:28:25,680 --> 00:28:27,600
that will send the task to the worker,

447
00:28:27,990 --> 00:28:34,230
so note that this channel actually is talking to another thread of the coordinator

448
00:28:34,290 --> 00:28:40,980
and that thread is actually the one that's in charge of calling the worker,

449
00:28:42,020 --> 00:28:45,620
and then once it's done with a task, it says it's done.

450
00:28:46,620 --> 00:28:51,870
If it's not able to if the call fails, for some reason, for example it turns out,

451
00:28:51,990 --> 00:28:54,570
then, what this loop does is,

452
00:28:54,570 --> 00:28:57,480
it'll push that task back onto the task channel,

453
00:28:57,690 --> 00:29:02,010
so another worker or potentially this thread again could pick up that task.

454
00:29:03,360 --> 00:29:07,200
So just to clarify how the channel communication works,

455
00:29:07,200 --> 00:29:09,840
so the worker says tasks on the tasks channel,

456
00:29:09,840 --> 00:29:11,550
which is read through these loops,

457
00:29:12,680 --> 00:29:18,500
and this loop will exit when the coordinator closes the channel,

458
00:29:20,090 --> 00:29:24,830
done, it's sent on these worker, issue worker threads

459
00:29:25,940 --> 00:29:29,540
and it's read by the coordinator, the original coordinator thread

460
00:29:30,320 --> 00:29:33,020
and this exit equals true,

461
00:29:33,020 --> 00:29:35,540
will basically tell the coordinator,

462
00:29:35,540 --> 00:29:39,590
like, oh, I don't need to listen for any more workers coming or workers starting up.

463
00:29:40,020 --> 00:29:43,800
So it will cause this other Go routine to exit,

464
00:29:44,850 --> 00:29:47,370
so I know that this is a pretty complex example,

465
00:29:47,370 --> 00:29:51,570
it's also not quite what we specified in the lab,

466
00:29:51,570 --> 00:29:54,000
but as an example of how channels can be used

467
00:29:54,060 --> 00:29:57,780
to implement something like mapreduce or something similar to mapreduce.

468
00:30:00,380 --> 00:30:02,810
There is a question in the chat,

469
00:30:02,810 --> 00:30:05,270
about where's exit define in this code?

470
00:30:08,640 --> 00:30:10,380
That is a good question,

471
00:30:10,380 --> 00:30:11,130
it's not,

472
00:30:12,060 --> 00:30:15,570
so it'll, it'll be exactly the same thing is done,

473
00:30:16,230 --> 00:30:21,970
it will just be another channel that's a boolean, yeah,

474
00:30:23,160 --> 00:30:25,620
that's a good, a good cache.

475
00:30:27,020 --> 00:30:27,740
Oh, can I.

476
00:30:27,740 --> 00:30:28,790
I've seen.

477
00:30:28,970 --> 00:30:31,640
How do you add things to the workers channel

478
00:30:31,640 --> 00:30:33,110
or when you add things to the workers channel,

479
00:30:33,110 --> 00:30:34,730
like how do you handle them in this case?

480
00:30:35,410 --> 00:30:37,180
Yeah, so in this case,

481
00:30:37,420 --> 00:30:41,320
worker the workers channel is provided to the coordinator,

482
00:30:41,410 --> 00:30:48,520
so imagine that for example and you know how your coordinator was actually called

483
00:30:48,550 --> 00:30:57,150
or created by the MR coordinator in main, in the that folder,

484
00:30:57,270 --> 00:31:01,230
so we would imagine that in MR coordinator,

485
00:31:01,230 --> 00:31:03,630
we would create a worker's channel,

486
00:31:04,460 --> 00:31:08,990
and MR coordinator would basically be in charged of tracking,

487
00:31:09,140 --> 00:31:12,440
when workers crash and when workers join,

488
00:31:12,470 --> 00:31:15,170
so this is for example in a case,

489
00:31:15,170 --> 00:31:20,390
where you know maybe new servers are added to our cluster at some later point

490
00:31:20,450 --> 00:31:23,060
or some worker crashed and then came back,

491
00:31:23,090 --> 00:31:26,450
and MR coordinator would be constantly sending,

492
00:31:26,510 --> 00:31:30,230
like these worker ids to [our] coordinator,

493
00:31:30,960 --> 00:31:33,480
in order to tell it, hey, like there's new worker,

494
00:31:33,480 --> 00:31:35,370
you should start issuing it tasks,

495
00:31:36,090 --> 00:31:37,620
so that part is not shown.

496
00:31:38,350 --> 00:31:41,950
God, yeah, I just I just wondering like,

497
00:31:41,980 --> 00:31:43,690
so that's really cool,

498
00:31:43,690 --> 00:31:47,020
I was just wondering inside the lab 1,

499
00:31:47,020 --> 00:31:51,220
like how I think it's like [call] worker and you've defended RPC to the worker,

500
00:31:51,700 --> 00:31:54,490
if if that's something we could have done in lab 1?

501
00:31:57,100 --> 00:31:58,900
It's possible it,

502
00:31:58,900 --> 00:32:01,810
but it definitely was not what we pushed you toward,

503
00:32:02,020 --> 00:32:07,450
because you would basically, instead of setting up the coordinator as being RPC server,

504
00:32:07,450 --> 00:32:11,050
you would have to set up like RPC servers on the workers,

505
00:32:11,440 --> 00:32:19,850
you can also think of, in this implementation call_worker could have handlers actually for each worker

506
00:32:20,210 --> 00:32:25,790
and each worker could be sending the coordinator like get task RPCs,

507
00:32:25,820 --> 00:32:30,350
but a little, that's a little funky,

508
00:32:30,350 --> 00:32:33,230
so in this example is actually more natural to imagine,

509
00:32:33,260 --> 00:32:36,470
that call_worker, the coordinator is a client

510
00:32:36,470 --> 00:32:40,940
and the workers are the ones that are handling that RPCs.

511
00:32:41,510 --> 00:32:43,820
Yeah, okay, thanks, very cool.

512
00:32:45,230 --> 00:32:46,850
I have two questions,

513
00:32:47,150 --> 00:32:49,340
first is just a generally Go question,

514
00:32:49,340 --> 00:32:52,760
so in that second for loop on the left, at the bottom,

515
00:32:53,700 --> 00:32:58,340
if you don't use i, will Go complain or in a for loop.

516
00:32:59,480 --> 00:33:04,400
So I run like all the Go linter and all that stuff

517
00:33:04,580 --> 00:33:07,550
and it's fine, I think,

518
00:33:07,580 --> 00:33:12,940
like, in this case, you, do you need to have i,

519
00:33:12,970 --> 00:33:18,880
because you're incremented and keeping the state of i around through the.

520
00:33:19,420 --> 00:33:20,530
Couldn't you do the same thing,

521
00:33:20,530 --> 00:33:23,560
with like a like a while loop,

522
00:33:23,560 --> 00:33:26,410
like just for empty for loop with a select,

523
00:33:27,430 --> 00:33:31,540
where it's like popping off of done.

524
00:33:32,250 --> 00:33:37,580
So, you can't actually,

525
00:33:37,580 --> 00:33:42,950
well, you still need to keep track of how many times you've read from done, right,

526
00:33:42,950 --> 00:33:46,100
because you can't just read once,

527
00:33:46,130 --> 00:33:48,770
you have to read number of task times.

528
00:33:52,070 --> 00:33:52,490
I see okay.

529
00:33:52,490 --> 00:33:59,260
Yeah, yeah, so you do need some type of state that will track that.

530
00:34:02,800 --> 00:34:05,170
And then for for the one on the right,

531
00:34:05,170 --> 00:34:08,140
like where you're reading from ask and re-populating it,

532
00:34:08,170 --> 00:34:11,500
is there like any downside to that,

533
00:34:12,530 --> 00:34:16,610
if you're like just constantly reading and adding back and forth to the same channel.

534
00:34:19,740 --> 00:34:22,910
I don't, I can't think of that the top my head,

535
00:34:22,910 --> 00:34:25,580
so in this case, at least you won't block,

536
00:34:25,910 --> 00:34:27,590
because every time you read it,

537
00:34:27,590 --> 00:34:29,990
you're popping something off the channel,

538
00:34:30,020 --> 00:34:32,990
every time you add it, you're pushing something,

539
00:34:33,170 --> 00:34:38,120
so because we have that the task is a buffer channel,

540
00:34:38,150 --> 00:34:40,010
but you'll never block on that.

541
00:34:41,160 --> 00:34:45,010
So, in terms of like performance,

542
00:34:45,430 --> 00:34:49,400
I think, I mean channels are built using locks,

543
00:34:49,400 --> 00:34:51,890
so locks are usually more lightweight,

544
00:34:52,430 --> 00:34:57,620
but I don't think, I don't think, you'll see a huge performance in fact,

545
00:34:57,890 --> 00:34:59,120
doing something like this.

546
00:34:59,630 --> 00:35:01,400
Okay, I guess, I've like a,

547
00:35:01,640 --> 00:35:04,250
sorry, just like a general question of like,

548
00:35:04,860 --> 00:35:10,580
what's your like calculus for choosing between mutexes and channels or like a hybrid,

549
00:35:11,380 --> 00:35:12,340
at the very beginning.

550
00:35:13,560 --> 00:35:19,140
Yeah, so mutexes are very natural for just protecting a piece of state,

551
00:35:19,230 --> 00:35:23,880
so like your coordinator or like your raft servers have a log,

552
00:35:24,030 --> 00:35:26,820
I want to protect everytime I append the log,

553
00:35:26,910 --> 00:35:31,080
that seems very difficult,

554
00:35:31,110 --> 00:35:34,260
or it seems very unnatural to try and do using channels,

555
00:35:34,470 --> 00:35:37,440
because essentially, you'd be using the channels lock,

556
00:35:37,500 --> 00:35:41,190
you'd want to ensure that no one else is modifying the state,

557
00:35:41,190 --> 00:35:42,360
while you're modifying it,

558
00:35:42,600 --> 00:35:45,990
and then you would have to essentially before you modify it,

559
00:35:46,020 --> 00:35:48,660
try to read on the channel to ensure that no one else,

560
00:35:48,920 --> 00:35:51,470
alright, like someone would have to send something on the channel,

561
00:35:51,470 --> 00:35:52,640
just show that they've done,

562
00:35:52,700 --> 00:35:55,730
they've been finished modifying so and so forth.

563
00:35:55,760 --> 00:36:00,520
So, in that case, it's actually very hard to imagine how you do channel,

564
00:36:00,520 --> 00:36:03,700
where mutexes would make that completely straightforward,

565
00:36:05,260 --> 00:36:08,350
where channels come in very handy is,

566
00:36:08,380 --> 00:36:12,580
like I think our implementation already has this apply channel,

567
00:36:12,850 --> 00:36:15,400
is where you have to wait for,

568
00:36:16,640 --> 00:36:22,670
in some ways, it's almost like a specific instance of a condition variable,

569
00:36:22,730 --> 00:36:25,850
in which you want to wait for something to be ready,

570
00:36:26,030 --> 00:36:34,980
or a, like a very specific type of command to be finished,

571
00:36:35,010 --> 00:36:40,590
so for something like issuing tasks is actually not a bad example

572
00:36:41,730 --> 00:36:46,650
or something like, blocking until you have something on a queue,

573
00:36:46,710 --> 00:36:49,650
like is you can almost think of it as like a queuing system,

574
00:36:50,100 --> 00:36:52,230
or at least that's how I like to think about it,

575
00:36:52,230 --> 00:36:56,140
but, for almost all modifications to shared state,

576
00:36:56,140 --> 00:37:02,790
like the race conditions, encounter locks are much simpler

577
00:37:02,790 --> 00:37:04,920
and in some ways, a lot easier to reason about,

578
00:37:07,990 --> 00:37:09,750
but, yeah.

579
00:37:09,780 --> 00:37:10,410
Thank you.

580
00:37:11,580 --> 00:37:15,270
Sorry, I have a follow up question to this slide,

581
00:37:15,360 --> 00:37:17,370
what happens if the,

582
00:37:17,370 --> 00:37:22,920
so you call the Go issueWorkerTaskThread which spins up another Go routine,

583
00:37:22,950 --> 00:37:25,500
I mean, it goes through all the tasks in the channel,

584
00:37:25,500 --> 00:37:27,610
what is it fails,

585
00:37:27,610 --> 00:37:29,860
when it's what if the Go routine fails,

586
00:37:29,860 --> 00:37:32,590
when it's sitting on the if call_worker.

587
00:37:34,550 --> 00:37:39,560
So, if it fails,

588
00:37:40,520 --> 00:37:47,150
then I guess you've taken a task out and not put back.

589
00:37:48,860 --> 00:37:51,110
I'm actually not sure,

590
00:37:51,140 --> 00:37:52,520
that seems like,

591
00:37:53,980 --> 00:37:59,930
like you're not, you're saying like the entire thread crashes, rather than as call_worker,

592
00:37:59,960 --> 00:38:02,420
not like returning falls or something.

593
00:38:02,690 --> 00:38:05,390
Yeah, like the Go routine crashes

594
00:38:06,010 --> 00:38:09,760
or is that possible for a single Go routine to fail

595
00:38:09,760 --> 00:38:12,070
or would like the entire thing just blow up.

596
00:38:14,180 --> 00:38:14,900
Hey, Frans you know?

597
00:38:14,900 --> 00:38:16,940
I think the model you should have is that,

598
00:38:16,940 --> 00:38:20,090
if a Go routine crashes, the process crashes.

599
00:38:21,580 --> 00:38:22,930
Yeah, that would solve it.

600
00:38:25,580 --> 00:38:29,930
Sorry, so if just the worker crashes,

601
00:38:30,440 --> 00:38:34,250
then you pick a different task,

602
00:38:34,250 --> 00:38:42,860
but, should you, I guess you would still have the same worker like worker number,

603
00:38:44,660 --> 00:38:49,280
so you still connect to the same worker, even though they have failed.

604
00:38:49,910 --> 00:38:51,080
Yeah, so in this case,

605
00:38:51,080 --> 00:38:54,620
basically call_worker would just continue returning false

606
00:38:55,100 --> 00:38:59,990
and you know this Go routine that's a specific for this worker,

607
00:38:59,990 --> 00:39:02,240
we just continue to loop,

608
00:39:03,420 --> 00:39:09,990
and eventually when the map, when the coordinator has determined that all the tasks have finished,

609
00:39:09,990 --> 00:39:12,510
it'll close the channel and then like Go routine will exit.

610
00:39:13,220 --> 00:39:15,560
So there could potentially like,

611
00:39:15,560 --> 00:39:18,290
if all your workers continue crashing,

612
00:39:18,290 --> 00:39:20,450
you have like hundreds of new workers joining,

613
00:39:20,600 --> 00:39:23,660
like you could potentially have a lot of Go routines just there,

614
00:39:23,660 --> 00:39:25,130
just like I can't contact my work

615
00:39:25,130 --> 00:39:26,540
or I can't contact my worker,

616
00:39:26,840 --> 00:39:28,850
but once the task is finished,

617
00:39:28,850 --> 00:39:31,950
this all of them will exit properly.

618
00:39:39,440 --> 00:39:42,980
Cool, alright, so that's an example with channels

619
00:39:43,280 --> 00:39:49,810
and now let's move on to some of the more like your questions and bugs and things like that,

620
00:39:49,810 --> 00:39:52,690
so some common but passing design mistakes that we saw

621
00:39:52,900 --> 00:39:55,630
was pushing too much work to the coordinator,

622
00:39:55,900 --> 00:39:58,450
so essentially making the coordinator bottleneck

623
00:39:58,540 --> 00:40:04,150
and this included both the coordinator and sorting the results

624
00:40:04,240 --> 00:40:06,790
or the coordinator reading file contents

625
00:40:06,820 --> 00:40:11,630
whereas a lot of the kind of beauty of mapreduce is that,

626
00:40:12,170 --> 00:40:16,790
all the state all the computation happens on the workers.

627
00:40:17,660 --> 00:40:22,250
And another con, it's not really a mistake,

628
00:40:22,250 --> 00:40:24,230
but potentially something to think about is,

629
00:40:24,260 --> 00:40:26,030
how many RPCs are you sending

630
00:40:26,030 --> 00:40:30,530
and like, do you really need to send that many RPCs,

631
00:40:30,800 --> 00:40:35,270
so for example sending an RPC to check whether there's a map task available

632
00:40:35,330 --> 00:40:38,660
and then sending another RPC to ask like give me a task,

633
00:40:38,690 --> 00:40:40,810
is little redundant

634
00:40:40,810 --> 00:40:45,190
and you want to try and reduce the number and types of,

635
00:40:45,280 --> 00:40:49,480
like reduce the API between the master or the coordinator and the worker,

636
00:40:50,460 --> 00:40:53,280
but these were, like they were passed the test

637
00:40:53,280 --> 00:40:55,650
and it's just things we wanted to point out.

638
00:40:57,610 --> 00:41:01,630
So now okay cool, what about like how I do lecture.

639
00:41:01,690 --> 00:41:05,850
So, for the next, say like five six minutes,

640
00:41:06,180 --> 00:41:07,950
what we're going to do breakout rooms,

641
00:41:07,950 --> 00:41:10,410
let let me stop sharing actually,

642
00:41:11,040 --> 00:41:12,360
alright, so do breakout rooms,

643
00:41:12,780 --> 00:41:23,400
and oh shoot, let's see, I think Zoom just crashed on me.

644
00:41:28,050 --> 00:41:29,580
We could still hear and see you.

645
00:41:30,030 --> 00:41:35,160
Alright, I'm back, yeah I upgraded Zoom before this lecture,

646
00:41:35,160 --> 00:41:36,090
that was a bad idea,

647
00:41:36,270 --> 00:41:38,310
but, alright, for the next five or six minutes,

648
00:41:38,370 --> 00:41:45,240
you should talk about just like you know any interesting bugs or observations, you had about lab,

649
00:41:45,630 --> 00:41:49,350
or you could you know complain about how long it took you to find a certain bug

650
00:41:49,710 --> 00:41:51,420
or ask questions to each other

651
00:41:51,750 --> 00:41:54,750
and then we'll come back and go over some of your questions.

652
00:41:55,940 --> 00:41:56,510
Alright.

653
00:42:00,910 --> 00:42:01,630
Okay.

654
00:42:03,060 --> 00:42:04,380
Alright, see you in a bit.

655
00:42:27,340 --> 00:42:29,020
Oh, so I find here with Frans,

656
00:42:29,020 --> 00:42:30,430
do you want me to review somewhere else.

657
00:42:30,610 --> 00:42:33,220
Probably best, but let me see if I can do it myself.

658
00:42:33,790 --> 00:42:36,380
Okay, I'm going to be right back.

659
00:49:37,790 --> 00:49:41,810
Alright, are we mostly back, I think.

660
00:49:43,880 --> 00:49:44,570
Alright cool.

661
00:49:46,680 --> 00:49:49,110
Okay, so I hope that was pretty fun

662
00:49:49,110 --> 00:49:52,380
or at least you got to talk about some of your frustrations during the live.

663
00:49:53,610 --> 00:49:55,950
Yeah, so for the rest of the lecture,

664
00:49:55,950 --> 00:49:57,150
we're going to go through,

665
00:49:57,990 --> 00:50:00,630
first before questions, take some general tips,

666
00:50:00,630 --> 00:50:03,030
that you'll want to look out for for future labs.

667
00:50:03,510 --> 00:50:10,410
So first of all, the one thing you'll find very handy for debugging is just

668
00:50:10,470 --> 00:50:11,850
you know classic printfs

669
00:50:11,940 --> 00:50:14,250
and so you can have conditional printfs,

670
00:50:14,250 --> 00:50:17,070
which only print when you want to debug,

671
00:50:17,070 --> 00:50:19,080
so for example you don't have to go through your code

672
00:50:19,080 --> 00:50:21,960
and comment them all out, before you submit or something like that,

673
00:50:22,380 --> 00:50:24,540
and so in the raft lab,

674
00:50:24,750 --> 00:50:28,680
we provide this DPrintf and the util.go file,

675
00:50:29,290 --> 00:50:35,170
and you can modify that to for example also printout like the server id,

676
00:50:35,170 --> 00:50:38,020
every single time you called DPrintf or something like that,

677
00:50:38,140 --> 00:50:44,620
so, yeah, I customize it to you know print out different colors for different RPCs like that,

678
00:50:45,390 --> 00:50:48,750
and also like redirecting your output files,

679
00:50:48,810 --> 00:50:51,630
just so you can like search the files will come in handly.

680
00:50:52,620 --> 00:50:56,650
Another trick that you probably want to keep in mind is

681
00:50:56,650 --> 00:50:59,130
you can look at all the goroutines

682
00:50:59,130 --> 00:51:03,180
to see where and their execution, they're running

683
00:51:03,420 --> 00:51:07,200
and so just type control backlash in order to do that.

684
00:51:08,260 --> 00:51:12,040
And the final thing which already sort of talked about are these defers

685
00:51:12,040 --> 00:51:14,110
and these slides will be uploaded also,

686
00:51:14,110 --> 00:51:15,370
so you can refer back to them,

687
00:51:15,700 --> 00:51:23,350
but essentially you can push multiple functions to run right before the function returns

688
00:51:23,650 --> 00:51:26,530
and they just be careful of the ordering.

689
00:51:27,920 --> 00:51:31,220
Alright, so now let's get to some of your questions,

690
00:51:32,720 --> 00:51:35,360
a lot of you submitted also questions about raft,

691
00:51:35,360 --> 00:51:38,630
so those will get to for the Q&A

692
00:51:38,630 --> 00:51:41,720
or maybe office hours or you can put that on Piazza.

693
00:51:41,720 --> 00:51:45,020
I'm going to focus mostly on the ones from mapreduce

694
00:51:45,050 --> 00:51:47,990
or maybe have time then we can also get raft questions.

695
00:51:49,950 --> 00:51:59,060
Alright, so the first category of questions kind of falls under questions specifically about mapreduce,

696
00:51:59,090 --> 00:52:03,620
so some more complex tasks that you might want to use mapreduce for,

697
00:52:03,830 --> 00:52:08,690
it's actually used a lot in ML, or like data mining, statistical applications,

698
00:52:08,810 --> 00:52:12,250
I linked here to hadoop,

699
00:52:12,250 --> 00:52:17,770
which is implements mapreduce a lot of people use it to run these types of tasks.

700
00:52:18,250 --> 00:52:24,750
And for example, here's a simple, or maybe not so simple,

701
00:52:24,750 --> 00:52:27,990
but basically matrix multiplication example

702
00:52:27,990 --> 00:52:30,060
of how you would read that using mapreduce.

703
00:52:31,340 --> 00:52:35,660
Second, like you for fault tolerance of the coordinator,

704
00:52:35,660 --> 00:52:41,710
the paper proposes a very simple a checkpointing mechanism,

705
00:52:41,710 --> 00:52:46,360
in which you'll just start up a new coordinator using the last checkpointed state

706
00:52:46,810 --> 00:52:50,170
and in some ways this is a very natural design for mapreduce,

707
00:52:50,170 --> 00:52:52,300
because everything is deterministic,

708
00:52:52,300 --> 00:52:56,530
there's no, the coordinator really doesn't have that much state to hold,

709
00:52:56,530 --> 00:52:59,470
all I need to know is which have finished and which has happened.

710
00:53:01,210 --> 00:53:05,860
So you could use raft of course, to enable fault tolerance

711
00:53:05,860 --> 00:53:12,070
and have a set of coordinators that all agree on the commands issued so far

712
00:53:12,070 --> 00:53:13,720
and the current state,

713
00:53:13,750 --> 00:53:21,050
but in some ways, it seems a little overkill for the coordinator,

714
00:53:21,530 --> 00:53:23,000
for something that's more stateful,

715
00:53:23,000 --> 00:53:25,850
it's like a key value store or something,

716
00:53:25,850 --> 00:53:28,460
it's much more natural to use a raft.

717
00:53:30,400 --> 00:53:33,280
So some other questions about mapreduce,

718
00:53:33,280 --> 00:53:34,960
the shuffle or combine with that,

719
00:53:35,050 --> 00:53:37,120
when does it happen and what does it do,

720
00:53:37,120 --> 00:53:40,720
so combining occurs like right after the map functions,

721
00:53:40,720 --> 00:53:44,710
applied for example in combining the word counts of a particular word,

722
00:53:44,830 --> 00:53:46,300
because having a lot of entries,

723
00:53:46,300 --> 00:53:50,830
that you know like the one you could you know combine them

724
00:53:50,830 --> 00:53:56,280
and then write only that to the immediate file, or intermediate file,

725
00:53:56,730 --> 00:53:58,590
sorting occurs at the reduce,

726
00:53:58,590 --> 00:54:02,310
after all the outputs of the map are read by the producer.

727
00:54:03,540 --> 00:54:04,500
Let's see,

728
00:54:04,500 --> 00:54:05,820
successors mapreduce,

729
00:54:05,820 --> 00:54:08,640
yeah, so actually, I'm not super familiar with it,

730
00:54:08,640 --> 00:54:11,550
but you can look at stuff like Google cloud data flow

731
00:54:11,790 --> 00:54:16,140
and other sort of directed graph computations,

732
00:54:16,200 --> 00:54:18,900
where inputs flow into a node,

733
00:54:18,900 --> 00:54:20,340
so you can think of as graph

734
00:54:20,340 --> 00:54:22,830
and then they might flow out to other nodes

735
00:54:22,860 --> 00:54:27,240
and that node in the middle of that performs for example map computation

736
00:54:27,240 --> 00:54:28,890
and produces intermediate data,

737
00:54:29,070 --> 00:54:31,980
is then sent to other like reduce or that in the graph,

738
00:54:32,130 --> 00:54:35,410
so it's a interesting way,

739
00:54:35,410 --> 00:54:38,950
it's like a data data flow way to think about mapreduce.

740
00:54:39,900 --> 00:54:41,730
And I'm sure that there's others that,

741
00:54:41,760 --> 00:54:44,880
I'm not necessarily like that, where I did.

742
00:54:44,880 --> 00:54:47,490
Actually, one maybe one of them Spark,

743
00:54:47,490 --> 00:54:48,780
which will read later about.

744
00:54:52,700 --> 00:54:57,440
Yeah, so, but I I like the graph way of thinking about mapreduce,

745
00:54:57,470 --> 00:55:00,980
because right now we're only really thinking about a two-step operation

746
00:55:00,980 --> 00:55:04,940
where it could actually be like you know many many steps.

747
00:55:06,260 --> 00:55:09,050
Oh yeah, then how input partitioned in practice,

748
00:55:09,050 --> 00:55:15,350
so, usually, because the input space is very application specific

749
00:55:15,350 --> 00:55:17,900
and output space is also application specific,

750
00:55:17,930 --> 00:55:21,470
it's really up to the programmer to specify,

751
00:55:21,860 --> 00:55:24,560
there's sometimes a,

752
00:55:30,050 --> 00:55:34,310
natural, for example make a local a matrix computation,

753
00:55:34,310 --> 00:55:37,340
then you want to combine them or so on so forth,

754
00:55:37,370 --> 00:55:43,700
or you could if it's just like an enormous document or like enormous text text files,

755
00:55:43,760 --> 00:55:46,100
you can just split it up into a reasonable size of work,

756
00:55:46,100 --> 00:55:49,790
so you know like applying the map function is going to take forever

757
00:55:49,940 --> 00:55:52,670
and also depends on the size of your cluster,

758
00:55:52,670 --> 00:55:53,810
so how many workers you have.

759
00:55:57,300 --> 00:55:59,370
So some further mapreduce questions,

760
00:55:59,700 --> 00:56:01,410
why do mapreduce files locally,

761
00:56:01,410 --> 00:56:02,670
so in the paper,

762
00:56:02,700 --> 00:56:07,560
this is because at that time, the network bandwidth was their bottleneck,

763
00:56:09,180 --> 00:56:10,680
that's why they don't use GFS,

764
00:56:10,680 --> 00:56:17,950
they only use GFS to write the, yeah, to write the output files.

765
00:56:18,760 --> 00:56:21,400
Are leaders necessary for distributed systems,

766
00:56:21,490 --> 00:56:23,260
not necessarily,

767
00:56:24,260 --> 00:56:27,980
they're like, think of Bitcoin like other decentralized systems,

768
00:56:27,980 --> 00:56:30,440
in which all the nodes sort of perform competition

769
00:56:30,440 --> 00:56:33,470
and some random node or like some node in the network

770
00:56:33,470 --> 00:56:35,450
is responsible for committing that,

771
00:56:35,450 --> 00:56:38,150
so there are definitely more like egalitarian designs,

772
00:56:38,910 --> 00:56:44,910
oh yeah, our challenge was actually to run mapreduce on like actual different servers

773
00:56:44,910 --> 00:56:49,260
rather than what we kind of had you do in the lab

774
00:56:49,680 --> 00:56:51,840
and so in order to do this,

775
00:56:51,840 --> 00:56:57,600
like you just, instead of using sockets to communicate over for like RPCs,

776
00:56:57,840 --> 00:57:00,120
you would use like TCP idea,

777
00:57:00,120 --> 00:57:05,380
basically like normal, like over the network communication

778
00:57:05,830 --> 00:57:09,370
and you would use a shared file system like GFS,

779
00:57:09,370 --> 00:57:13,000
so the [equivalent] I think all of you have access to Athena,

780
00:57:13,120 --> 00:57:14,770
if at least at MIT

781
00:57:14,800 --> 00:57:18,220
and you know ssh to multiple Athena machines

782
00:57:18,220 --> 00:57:22,300
and use AFS which is the file share files,

783
00:57:22,300 --> 00:57:23,980
I think Athena uses too,

784
00:57:24,950 --> 00:57:28,400
basically, you can access your files on Athena from any machine,

785
00:57:28,910 --> 00:57:34,340
similarly you could do the same thing by [wrenching] AWS instances and using S3,

786
00:57:34,940 --> 00:57:40,100
but we didn't expect you to spend any money to run our lab.

787
00:57:43,180 --> 00:57:46,660
Right, so some questions that came about just like general code design,

788
00:57:46,660 --> 00:57:49,210
so we've some of these we've discussed as well,

789
00:57:49,630 --> 00:57:52,060
so lab 1 was pretty small,

790
00:57:52,090 --> 00:57:55,180
lab 2 is going to be much larger,

791
00:57:55,210 --> 00:57:57,460
especially as you get to the later stages

792
00:57:57,520 --> 00:58:01,030
and as lab 3 and lab 4 come along as well.

793
00:58:01,690 --> 00:58:05,810
And one thing that I personally find very handy is

794
00:58:05,810 --> 00:58:09,610
just separate different chunks of code by their purpose,

795
00:58:09,700 --> 00:58:16,190
so, and also in how I implement each step of my code,

796
00:58:16,280 --> 00:58:19,520
so separating them out by for example RPCs

797
00:58:19,520 --> 00:58:21,560
and the senders and handlers

798
00:58:21,890 --> 00:58:26,780
and feel free to actually separate these out physically in different files,

799
00:58:26,900 --> 00:58:27,950
that won't,

800
00:58:28,100 --> 00:58:29,870
like that's fine for a test

801
00:58:29,870 --> 00:58:32,030
and it will probably help you,

802
00:58:32,420 --> 00:58:36,470
like not have thousands of lines of code in one gigantic file.

803
00:58:38,280 --> 00:58:42,420
I I personally like to put all definitions of state together

804
00:58:42,420 --> 00:58:46,500
and then functions are like sort of separate,

805
00:58:46,500 --> 00:58:48,540
but that's my personal preference,

806
00:58:49,910 --> 00:58:53,750
factoring out common pieces of code into functions will also be very helpful,

807
00:58:53,780 --> 00:58:56,300
for example every single RPC,

808
00:58:56,720 --> 00:58:57,860
you will get in raft,

809
00:58:57,860 --> 00:58:59,330
you need to check for [] term,

810
00:58:59,450 --> 00:59:01,520
so putting all that logic,

811
00:59:01,520 --> 00:59:03,650
so that resets all the state properly

812
00:59:03,650 --> 00:59:07,670
and everything into one function, that you just call will help,

813
00:59:07,670 --> 00:59:12,380
because you know you don't want to accidentally forget to reset your election time

814
00:59:12,380 --> 00:59:15,320
or like reset voted for something,

815
00:59:16,890 --> 00:59:18,570
although you should reset the election time,

816
00:59:18,570 --> 00:59:19,500
so don't do that,

817
00:59:19,530 --> 00:59:22,860
that was an example I pulled off the top of my head.

818
00:59:23,250 --> 00:59:27,090
And also finally have a good environment with auto complete

819
00:59:27,090 --> 00:59:30,360
or like being able to search for certain keywords in your code,

820
00:59:30,360 --> 00:59:33,270
and so forth can help a lot.

821
00:59:33,770 --> 00:59:35,840
So if you need any help setting this,

822
00:59:35,840 --> 00:59:37,190
like come to office hours

823
00:59:37,190 --> 00:59:39,320
or there's tons of tutorials online,

824
00:59:39,350 --> 00:59:41,630
you can look up a good editor,

825
00:59:41,900 --> 00:59:44,600
but it's not necessary, it's definitely not necessary,

826
00:59:44,600 --> 00:59:46,370
but it could it does help.

827
00:59:48,020 --> 00:59:52,910
And then, yeah so has using Go decrease the amount of time students spend debugging,

828
00:59:53,120 --> 00:59:55,910
so I've never actually implemented the labs in C++,

829
00:59:55,910 --> 00:59:57,410
but according to Frans like,

830
00:59:58,080 --> 01:00:03,300
well, the one huge advantage of Go is its memory management,

831
01:00:03,510 --> 01:00:05,070
so uses garbage collection

832
01:00:05,070 --> 01:00:06,180
and you'll have to deal with,

833
01:00:06,180 --> 01:00:09,420
like you know there are pointers,

834
01:00:09,420 --> 01:00:12,870
but you don't have to deal with them in the same way you would see your C++,

835
01:00:13,320 --> 01:00:17,720
so like, I don't know how many of you run into segfaults so far,

836
01:00:17,720 --> 01:00:19,670
but I'm guessing very few of you

837
01:00:19,670 --> 01:00:21,320
or they were very easy to fix,

838
01:00:21,590 --> 01:00:26,410
and this definitely makes it easier to debug

839
01:00:26,560 --> 01:00:29,320
or they're just certain types of bugs that you don't need to worry about.

840
01:00:30,710 --> 01:00:31,670
Sorry, I have a question.

841
01:00:32,120 --> 01:00:32,600
Yeah.

842
01:00:32,720 --> 01:00:35,960
This is like a more Go specific question,

843
01:00:35,960 --> 01:00:39,170
but when you have a function that can take in,

844
01:00:39,200 --> 01:00:42,980
let's say you have like a, you have a append entries are

845
01:00:42,980 --> 01:00:45,980
and you also have like a request vote,

846
01:00:45,980 --> 01:00:48,680
both of them have a term variable inside,

847
01:00:48,710 --> 01:00:50,450
but when you pass it to a function,

848
01:00:50,960 --> 01:00:52,730
how do you tell the function,

849
01:00:52,730 --> 01:00:57,080
that's like hey I expect a struct, that has a term field,

850
01:01:00,270 --> 01:01:01,410
is that possible?

851
01:01:02,200 --> 01:01:05,530
So you define the types right,

852
01:01:05,590 --> 01:01:09,540
so it's like any other type,

853
01:01:09,540 --> 01:01:11,550
your when you pass into the function,

854
01:01:11,550 --> 01:01:14,670
the function expects an argument of a particular type,

855
01:01:15,190 --> 01:01:16,930
and that's type of.

856
01:01:17,050 --> 01:01:17,800
Yeah.

857
01:01:17,950 --> 01:01:21,370
Yeah, let's say I want to share one function across both types.

858
01:01:22,120 --> 01:01:24,250
I believe he can use an interface,

859
01:01:24,250 --> 01:01:25,660
but I'm not sure.

860
01:01:26,570 --> 01:01:29,810
So I tried to, but when I do dot term,

861
01:01:29,810 --> 01:01:32,210
it says I don't know this field

862
01:01:32,330 --> 01:01:33,530
or like it doesn't exists.

863
01:01:34,010 --> 01:01:35,510
I think you need to convert it

864
01:01:35,630 --> 01:01:38,840
or you need to still have casting, I can't remember,

865
01:01:38,870 --> 01:01:41,270
but there's a way to coerce.

866
01:01:41,570 --> 01:01:43,040
You have to type cast it back,

867
01:01:43,040 --> 01:01:46,180
you know to whatever structure you want access.

868
01:01:46,900 --> 01:01:50,290
Like you basically need to talk Go,

869
01:01:50,620 --> 01:01:53,980
that by the time, I actually use this variable,

870
01:01:53,980 --> 01:01:55,690
it is of a particular type.

871
01:01:56,630 --> 01:01:57,620
Got it, thank you.

872
01:01:57,650 --> 01:02:01,490
So one thing if you want to reuse the function for multiple different types,

873
01:02:01,700 --> 01:02:03,440
you can pass in an interface,

874
01:02:03,470 --> 01:02:06,470
but you might also need to pass in for example,

875
01:02:07,120 --> 01:02:11,710
like you know more board something that tells it,

876
01:02:11,830 --> 01:02:13,540
like hey this is going to be this type,

877
01:02:13,540 --> 01:02:17,620
and then you need to cast that interface into the right type, before you use it.

878
01:02:19,540 --> 01:02:20,260
Okay.

879
01:02:21,080 --> 01:02:22,820
I think the way people usually handle this is

880
01:02:22,820 --> 01:02:26,030
by putting setters and getters in the interface,

881
01:02:26,210 --> 01:02:30,170
you don't actually know which type it is in actuality,

882
01:02:30,170 --> 01:02:32,870
you just access the variable using interface.

883
01:02:34,330 --> 01:02:34,750
Yeah.

884
01:02:38,260 --> 01:02:39,790
Yeah, I don't think it,

885
01:02:40,120 --> 01:02:44,440
you should need to use interfaces that much in raft,

886
01:02:44,440 --> 01:02:45,850
I don't think I used it all,

887
01:02:45,850 --> 01:02:48,850
other than the command which is provided.

888
01:02:53,410 --> 01:02:57,160
Yeah, like, I guess factoring out common pieces of code is good,

889
01:02:57,160 --> 01:02:59,200
unless it adds additional complexity.

890
01:03:02,220 --> 01:03:05,460
Like I wouldn't try and force your types,

891
01:03:05,460 --> 01:03:08,370
to all be able to run on the same function,

892
01:03:08,370 --> 01:03:12,270
like it might just be simpler to two slightly different functions.

893
01:03:13,150 --> 01:03:15,640
Or, if the only like shared piece you're using is the term,

894
01:03:15,640 --> 01:03:18,430
you can have the same function taken just the term

895
01:03:18,430 --> 01:03:22,810
and in both cases pass in the dot term of the structure using.

896
01:03:27,020 --> 01:03:29,840
Alright, some other code design questions?

897
01:03:30,530 --> 01:03:35,870
Once when separating the code into multiple files,

898
01:03:35,870 --> 01:03:39,080
is there naming conventional like required,

899
01:03:39,080 --> 01:03:43,250
because when we make the lab, it seems like it's copying the source file,

900
01:03:43,250 --> 01:03:45,020
so is there any naming convention?

901
01:03:46,060 --> 01:03:50,170
I mean I would put them in raft, the raft folder,

902
01:03:50,200 --> 01:03:52,060
but there's no naming convention,

903
01:03:52,060 --> 01:03:53,890
like you can name your files whatever you want.

904
01:03:55,220 --> 01:03:58,340
Okay, our grading scripts will replace anything

905
01:03:58,340 --> 01:04:02,630
that's necessary for or anything that belongs to the testing framework,

906
01:04:02,750 --> 01:04:07,070
so the config file or like the test file,

907
01:04:07,190 --> 01:04:09,770
anything that you change in there will be wiped out.

908
01:04:12,540 --> 01:04:13,170
Yeah.

909
01:04:14,550 --> 01:04:19,350
Like also be slightly careful about using external dependencies,

910
01:04:20,220 --> 01:04:26,140
I ran into a couple issues with grading some scripts I had external dependencies,

911
01:04:26,140 --> 01:04:29,500
like using some github package Go package,

912
01:04:29,530 --> 01:04:32,740
but those were I was able to fix it,

913
01:04:32,740 --> 01:04:34,600
just be a little careful, if you do that.

914
01:04:35,130 --> 01:04:39,060
But, yeah, create as many .go files and raft as you want.

915
01:04:42,110 --> 01:04:47,270
Yeah, so pointer versus a value while passing by reference can be cheaper,

916
01:04:47,300 --> 01:04:50,090
because Go won't just copy the structure,

917
01:04:50,420 --> 01:04:58,170
this was, this question was asked in particular for why call takes the arguments

918
01:04:58,170 --> 01:05:00,840
and the reply as pointers

919
01:05:01,200 --> 01:05:04,560
and so yeah those could be potentially extremely large

920
01:05:04,560 --> 01:05:07,320
and so good doesn't have to copy them, when you call the function,

921
01:05:07,320 --> 01:05:08,430
that's the main reason.

922
01:05:08,880 --> 01:05:10,860
Using blocks and channels are possible?

923
01:05:10,860 --> 01:05:13,350
Yes, you'll give them both in raft,

924
01:05:13,740 --> 01:05:15,990
so you will definitely see how it's possible.

925
01:05:18,560 --> 01:05:21,260
Oh yeah, and then we're getting a lot of questions about timeouts,

926
01:05:21,290 --> 01:05:25,040
so in map, in the mapreduce lab,

927
01:05:25,070 --> 01:05:26,330
the timeout was,

928
01:05:26,390 --> 01:05:30,170
well, we gave you a set ten seconds for the worker tasks when they fail,

929
01:05:30,230 --> 01:05:32,300
but in terms of how long do you sleep

930
01:05:32,300 --> 01:05:35,000
and stuff were pretty much able to choose anything under that.

931
01:05:35,610 --> 01:05:38,970
For raft, you have to choose timeout a little more carefully

932
01:05:39,000 --> 01:05:43,980
and our tests are like kind of sensitive, but not super sensitive,

933
01:05:44,100 --> 01:05:50,010
like you'll be opposite for example probably be within a range of one to 100,to 200 milliseconds

934
01:05:50,010 --> 01:05:51,630
and be fine.

935
01:05:52,460 --> 01:05:55,860
Yeah, in terms of choosing them,

936
01:05:58,470 --> 01:06:02,400
probably helps to first think about why you're waiting at all,

937
01:06:03,440 --> 01:06:06,800
and for example in the for aft,

938
01:06:06,830 --> 01:06:08,810
your leader is sending heartbeat,

939
01:06:09,330 --> 01:06:13,200
and your timeout is to detect when the leader is dead,

940
01:06:14,620 --> 01:06:20,440
so, you kind of want to give the leader a couple chances to tell you that it's alive,

941
01:06:20,560 --> 01:06:24,700
otherwise you know you'll just continuously think it's dead,

942
01:06:24,910 --> 01:06:28,900
so depending on what you set your heartbeat timeout to be

943
01:06:28,990 --> 01:06:30,640
or your heartbeat interval to be,

944
01:06:30,760 --> 01:06:32,260
which I think will give you some guidelines of,

945
01:06:32,260 --> 01:06:36,550
it can't be ten more than ten times per second or something like that,

946
01:06:37,640 --> 01:06:39,980
depending on what you set your heartbeat,

947
01:06:40,010 --> 01:06:42,560
you'll want your timeout to be something, like pretty reasonable,

948
01:06:42,560 --> 01:06:46,130
like maybe allow for the chance to get two to three heartbeats

949
01:06:46,790 --> 01:06:50,810
and then you'll have to randomize some like range,

950
01:06:50,840 --> 01:06:54,380
because you don't want all your service start elections at the same time

951
01:06:54,920 --> 01:06:58,580
and to do that you can you know like a range of,

952
01:06:59,650 --> 01:07:03,610
maybe like two to five heartbeats,

953
01:07:04,240 --> 01:07:07,030
sometime out between there is reasonable,

954
01:07:07,630 --> 01:07:10,090
but in terms of the test,

955
01:07:10,090 --> 01:07:13,120
you'll see whether you're sending too many RPCs

956
01:07:13,390 --> 01:07:18,700
or too many bits are going over the network as the test go in later labs

957
01:07:18,820 --> 01:07:21,040
and you can tweat your timeout very easily,

958
01:07:21,100 --> 01:07:24,910
it's slightly implementation dependent,

959
01:07:25,090 --> 01:07:29,640
so, I can't tell you like what's the perfect number for you,

960
01:07:29,970 --> 01:07:34,440
but thinking of it in terms of why am I timing out in the first place

961
01:07:34,560 --> 01:07:39,360
and how many RPCs do I want to get from like other servers before timeout,

962
01:07:39,390 --> 01:07:41,520
is a good metric to keep in mind,

963
01:07:43,390 --> 01:07:45,790
hopefully, that helps a lot of timeouts.

964
01:07:46,900 --> 01:07:53,320
Okay, yeah, so some implementation questions that a came up about the mapreduce lab

965
01:07:53,320 --> 01:07:54,790
and also the labs in general.

966
01:07:55,400 --> 01:08:00,150
So, some people actually did implement backup tasks,

967
01:08:00,150 --> 01:08:01,110
which is pretty cool

968
01:08:01,110 --> 01:08:04,020
and we definitely did not require that for this lab

969
01:08:04,410 --> 01:08:09,290
and I think something that was important to keep in mind is that,

970
01:08:09,290 --> 01:08:14,690
the paper has makes a distinction between starting restarting a task,

971
01:08:15,140 --> 01:08:16,610
because a work has failed,

972
01:08:17,250 --> 01:08:22,860
and issuing the task again, to speed up a lagging task,

973
01:08:22,860 --> 01:08:24,960
that the worker hasn't failed,

974
01:08:25,380 --> 01:08:27,930
but you want the task to complete faster

975
01:08:28,290 --> 01:08:30,840
and so backup tasks are used for the ladder,

976
01:08:30,990 --> 01:08:32,640
when tasks are haven't failed, yet,

977
01:08:32,640 --> 01:08:34,830
but there's there just slow

978
01:08:35,370 --> 01:08:37,900
and timeout we start task,

979
01:08:37,900 --> 01:08:40,240
when workers are actually detected to fail.

980
01:08:40,330 --> 01:08:45,220
So when the paper, the coordinator actually gets heartbeats from the workers,

981
01:08:45,340 --> 01:08:49,540
whereas in the design that we propose for your lab,

982
01:08:49,660 --> 01:08:54,010
we use timeouts both to detect that worker has probably failed

983
01:08:54,070 --> 01:08:56,500
and also to detect slow tasks,

984
01:08:56,590 --> 01:09:00,520
so in some ways we make that we don't have that distinction,

985
01:09:00,730 --> 01:09:05,080
we just assume that if this task has been completed in this set of time,

986
01:09:05,140 --> 01:09:07,480
that you know like probably the worker has failed

987
01:09:07,480 --> 01:09:08,860
or maybe it's just insanely slow

988
01:09:08,860 --> 01:09:10,000
and let's reissue it,

989
01:09:10,240 --> 01:09:15,460
so that's why our labs don't really mention backup tasks.

990
01:09:16,630 --> 01:09:21,850
So, and then, yeah so there, this is again going back to the confusion,

991
01:09:21,850 --> 01:09:25,480
the next question, about like synchronization,

992
01:09:25,480 --> 01:09:26,980
if the servers are on different machines,

993
01:09:26,980 --> 01:09:29,380
so the servers are on different machines

994
01:09:29,410 --> 01:09:32,260
and they only communicate using RPCs,

995
01:09:32,350 --> 01:09:37,480
all synchronization is just protecting or synchronizing the threads on one server,

996
01:09:38,080 --> 01:09:40,990
I just want to emphasize that one more time.

997
01:09:43,190 --> 01:09:47,450
Common source of race conditions, just you know logging,

998
01:09:49,570 --> 01:09:51,930
I in some ways I think,

999
01:09:51,930 --> 01:09:56,010
someone's talking about like you know how do you know when to lock

1000
01:09:56,010 --> 01:09:59,070
and how do you know when to use synchronization,

1001
01:09:59,310 --> 01:10:04,410
so anytime you're modifying the state of the file,

1002
01:10:04,410 --> 01:10:06,480
like your raft server or the coordinator,

1003
01:10:06,720 --> 01:10:08,490
anytime you modify the state,

1004
01:10:09,020 --> 01:10:10,010
you want to lock

1005
01:10:10,430 --> 01:10:12,740
and what you'll notice is that,

1006
01:10:13,960 --> 01:10:18,220
for almost every function in your raft implementation, for example,

1007
01:10:18,250 --> 01:10:21,880
you will have a lock and then a defer unlock,

1008
01:10:21,880 --> 01:10:22,990
like right after that.

1009
01:10:23,940 --> 01:10:27,720
The only time you need to make sure that you're not locked is,

1010
01:10:27,720 --> 01:10:29,370
when you make a call on might block,

1011
01:10:29,520 --> 01:10:32,100
so sending an RPC,

1012
01:10:32,220 --> 01:10:35,790
you know sending something over channel,

1013
01:10:36,090 --> 01:10:38,400
those type of operations, you shouldn't lock around,

1014
01:10:38,400 --> 01:10:41,460
because then you're you're that thread will just be blocked on that

1015
01:10:41,580 --> 01:10:44,460
and hold the lock and stop the server,

1016
01:10:44,460 --> 01:10:46,590
any thread on the server from making progress.

1017
01:10:47,720 --> 01:10:50,720
Yeah, and then there are some questions about like,

1018
01:10:51,670 --> 01:10:54,160
there are some data races they're benign,

1019
01:10:54,160 --> 01:10:57,430
like for example you could say is done to be true

1020
01:10:57,430 --> 01:11:00,190
and you know like you don't really need to lock around that,

1021
01:11:00,190 --> 01:11:01,810
but the race detector is complaining,

1022
01:11:02,050 --> 01:11:04,720
you could use an atomic []

1023
01:11:04,720 --> 01:11:08,560
which has the same behavior like locking before unlocking after,

1024
01:11:09,580 --> 01:11:12,910
but even though you might think this data race is benign,

1025
01:11:13,060 --> 01:11:14,890
it's undefined behavior,

1026
01:11:15,010 --> 01:11:19,360
so it just so happens that you know eventually the next read,

1027
01:11:19,660 --> 01:11:22,510
like your read might miss the fact, that it's done,

1028
01:11:22,510 --> 01:11:25,060
but the next time you call is done, it will say true

1029
01:11:25,060 --> 01:11:26,020
and then you're fine,

1030
01:11:26,200 --> 01:11:31,660
but undefined behavior could technically be implemented as anything,

1031
01:11:31,720 --> 01:11:34,210
like it just so happens that your compiler

1032
01:11:34,450 --> 01:11:36,910
and your processor does something reasonable,

1033
01:11:36,970 --> 01:11:38,410
when there's a data race,

1034
01:11:38,530 --> 01:11:41,740
so you should handle them especially when they're simple,

1035
01:11:42,100 --> 01:11:45,160
and they don't really affect performance that much.

1036
01:11:45,900 --> 01:11:54,920
Another thing is, well, in in theory, you could have this like is [] data race,

1037
01:11:54,920 --> 01:11:58,490
could potentially mean that your process would never exit,

1038
01:11:58,550 --> 01:12:02,630
because you know the write to is done, setting it to true,

1039
01:12:02,720 --> 01:12:08,030
might ever actually propagate to the thread that's reading, what whether it's true or not,

1040
01:12:08,030 --> 01:12:11,360
because it could be stored in some like buffer and never flushed,

1041
01:12:11,390 --> 01:12:18,290
what locks ensure is that you're write the next thread that reads is done,

1042
01:12:18,710 --> 01:12:22,730
we'll see the last write is done

1043
01:12:22,760 --> 01:12:24,440
and I'll actually flush it from,

1044
01:12:24,530 --> 01:12:27,860
for example a potential buffer that the write could be stored.

1045
01:12:28,400 --> 01:12:32,840
So, yeah, that's just emphasizing, like you don't want data races,

1046
01:12:32,840 --> 01:12:34,730
even if you think that they're really friendly.

1047
01:12:35,590 --> 01:12:37,630
Clean way to exit,

1048
01:12:38,230 --> 01:12:43,810
so sending an exit RPC from coordination worker, workers,

1049
01:12:43,990 --> 01:12:47,800
also like the quote unquote like messy exit,

1050
01:12:47,800 --> 01:12:51,100
where the worker tries to send RPCs,

1051
01:12:51,100 --> 01:12:54,190
the socket is closed, like those are also fine,

1052
01:12:56,080 --> 01:13:00,700
like most solutions are equally acceptable.

1053
01:13:01,780 --> 01:13:04,300
And then unexpected end of file errors,

1054
01:13:04,300 --> 01:13:07,740
so, you can look I have a link here,

1055
01:13:07,740 --> 01:13:09,990
that it shows when it's invoked the client,

1056
01:13:09,990 --> 01:13:14,640
but it's a little confusing as to when that actually happens,

1057
01:13:14,640 --> 01:13:17,310
so I would not worry about it too much,

1058
01:13:17,370 --> 01:13:19,230
if any one has insights into,

1059
01:13:21,340 --> 01:13:25,390
if they got this error at a very strange moment,

1060
01:13:25,390 --> 01:13:26,770
then we could look into it,

1061
01:13:26,860 --> 01:13:29,290
but I think it's very specific on your implementation,

1062
01:13:29,290 --> 01:13:31,360
so I would have to look at that, in particular,

1063
01:13:31,660 --> 01:13:33,310
but we got a bunch of questions about.

1064
01:13:34,810 --> 01:13:39,700
Yeah, I think so that's basically most of the questions that came up

1065
01:13:39,700 --> 01:13:45,250
and I think now if you have any questions about you know Go mapreduce

1066
01:13:45,250 --> 01:13:48,400
or if you want to ask staff about the labs.

1067
01:13:48,930 --> 01:13:53,040
I had a question about the clean way to exit.

1068
01:13:53,870 --> 01:13:58,070
So you're saying like something send RPC,

1069
01:13:58,160 --> 01:13:59,630
I was just wondering if there were like,

1070
01:13:59,630 --> 01:14:01,790
if there was like a case,

1071
01:14:02,030 --> 01:14:08,600
where a worker for some reason just takes a very long time to reach the server, right,

1072
01:14:08,600 --> 01:14:10,670
like how like how does the server know,

1073
01:14:11,170 --> 01:14:14,170
like when to like shutdown,

1074
01:14:14,410 --> 01:14:18,490
because, because because the coordinator shutdown at some point, I think,

1075
01:14:18,490 --> 01:14:22,390
when when when it says like done, when done returns true,

1076
01:14:22,970 --> 01:14:27,710
it shutdown and so it stops replying to the workers,

1077
01:14:28,280 --> 01:14:30,680
how does it decide when to do that,

1078
01:14:30,680 --> 01:14:36,430
if it's waiting for, for workers to shutdown themselves.

1079
01:14:37,570 --> 01:14:41,830
Oh, so in this case, the coordinator isn't,

1080
01:14:42,540 --> 01:14:43,380
oh I guess,

1081
01:14:43,380 --> 01:14:45,330
so send is probably the wrong word,

1082
01:14:45,360 --> 01:14:47,820
the coordinator isn't waiting for the workers to respond,

1083
01:14:47,970 --> 01:14:53,970
the coordinator is not sending it's replying to the request from workers,

1084
01:14:53,970 --> 01:14:57,120
with a like the task is done, please exit,

1085
01:14:57,420 --> 01:15:01,740
the worker isn't, the coordinator isn't actually waiting for the workers at all,

1086
01:15:01,770 --> 01:15:06,420
and so in this case, the coordinator could actually still exit before the workers

1087
01:15:06,480 --> 01:15:08,700
and cause the workers to like,

1088
01:15:09,300 --> 01:15:13,170
you have a disconnected socket error and exit.

1089
01:15:14,130 --> 01:15:16,350
Yeah I I guess, that was my question really,

1090
01:15:16,350 --> 01:15:19,530
like like if if it I could though,

1091
01:15:20,040 --> 01:15:23,130
coordinators replying to workers, right,

1092
01:15:23,130 --> 01:15:27,990
that are like potentially like asking for get task,

1093
01:15:28,320 --> 01:15:32,070
but what happens if the worker shutdown

1094
01:15:32,310 --> 01:15:40,050
or sorry the coordinator shutdown before it gets, I get I get task RPC from the worker.

1095
01:15:40,900 --> 01:15:43,990
Oh, then the next time the worker tries to contact the coordinator,

1096
01:15:43,990 --> 01:15:46,840
the worker will see that the connection is closed and then exit.

1097
01:15:48,340 --> 01:15:48,850
Yeah.

1098
01:15:49,000 --> 01:15:52,780
That's as clean shutdown as we'll get.

1099
01:15:56,060 --> 01:15:58,730
Essentially, I mean you could imagine that,

1100
01:15:59,480 --> 01:16:03,260
you know you could set up the workers to be RPC servers,

1101
01:16:03,260 --> 01:16:06,410
then you would actually have the coordinator be sending these,

1102
01:16:06,410 --> 01:16:09,920
like please exit, the coordinator you'll have to wait for the workers to exit,

1103
01:16:10,070 --> 01:16:18,250
but it's not, it doesn't seem like you won't get any utility out that.

1104
01:16:20,530 --> 01:16:21,070
Thanks.

1105
01:16:21,340 --> 01:16:22,540
Yeah.

1106
01:16:22,750 --> 01:16:25,630
Kat, I see you have your hands.

1107
01:16:26,240 --> 01:16:29,420
Yeah, something that I was wondering about is,

1108
01:16:29,420 --> 01:16:32,150
for the future labs are we allowed to have more files,

1109
01:16:32,150 --> 01:16:34,040
I think explicitly in the mapreduce lab,

1110
01:16:34,040 --> 01:16:35,240
we were only supposed to have three,

1111
01:16:36,700 --> 01:16:39,520
and it didn't read something where it was like,

1112
01:16:39,580 --> 01:16:42,400
hey you should have all of your stuff contained in one.

1113
01:16:43,540 --> 01:16:46,510
Oh yeah, so you can definitely add more files,

1114
01:16:47,440 --> 01:16:51,280
that's like I would almost encourage that,

1115
01:16:52,240 --> 01:16:54,310
I did we say that about mapreduce,

1116
01:16:55,160 --> 01:16:56,900
I I don't, I can't remember whether.

1117
01:16:56,900 --> 01:17:00,740
What you saying you couldn't edit any of the other main files,

1118
01:17:00,740 --> 01:17:01,130
it like.

1119
01:17:01,130 --> 01:17:02,660
Yeah, you couldn't edit the [].

1120
01:17:02,750 --> 01:17:05,660
Yeah, okay, I misread that, thanks,

1121
01:17:05,660 --> 01:17:07,370
this makes me feel a lot better.

1122
01:17:07,610 --> 01:17:14,160
Yeah, yeah, but definitely like bring your code will be useful.

1123
01:17:16,300 --> 01:17:19,690
I have a question about the benign data races,

1124
01:17:21,100 --> 01:17:24,550
I guess like, because sometimes there's for example raft,

1125
01:17:24,550 --> 01:17:29,500
you just want to read the current state of the of the raft server,

1126
01:17:29,590 --> 01:17:34,930
why would multiple write, multiple threads writing to it and one reading,

1127
01:17:34,960 --> 01:17:38,350
so why would a read and write to the same variable

1128
01:17:38,380 --> 01:17:40,780
end up cause undefined behavior,

1129
01:17:40,780 --> 01:17:43,090
because it read comes before or after the write.

1130
01:17:44,020 --> 01:17:47,700
So, one thing that can happen

1131
01:17:47,700 --> 01:17:50,640
and most processors don't do this,

1132
01:17:50,670 --> 01:17:55,120
but, every time you have a,

1133
01:17:56,140 --> 01:18:00,100
like so these any thread can run on a separate core,

1134
01:18:00,700 --> 01:18:05,080
and every core has a buffer,

1135
01:18:05,230 --> 01:18:07,840
for the data that it's reading or writing,

1136
01:18:08,470 --> 01:18:10,300
or writing I guess like a store buffer,

1137
01:18:10,360 --> 01:18:16,920
so for example thread one could write one value to the state

1138
01:18:17,280 --> 01:18:19,500
and thread two could try to read it,

1139
01:18:19,680 --> 01:18:21,750
or like multiple threads can be writing

1140
01:18:22,290 --> 01:18:25,110
and thread one without a lock,

1141
01:18:25,110 --> 01:18:30,870
so locks essentially flush the buffer without that lock,

1142
01:18:31,340 --> 01:18:34,850
this write might just like stay in thread one's,

1143
01:18:34,910 --> 01:18:36,560
like store for forever

1144
01:18:37,040 --> 01:18:41,990
and the read will never return the updated value,

1145
01:18:42,320 --> 01:18:46,990
so this behavior doesn't quite happen in practice,

1146
01:18:46,990 --> 01:18:48,850
but it's an allowable behavior,

1147
01:18:48,880 --> 01:18:50,230
because you do not have a lot.

1148
01:18:51,240 --> 01:18:53,460
Sorry, so what happens if the write has a lock,

1149
01:18:53,460 --> 01:18:54,720
but the reed doesn't,

1150
01:18:55,380 --> 01:18:57,960
like does the read always need a lock?

1151
01:19:02,970 --> 01:19:12,280
Yes, because, I think of it.

1152
01:19:13,970 --> 01:19:15,350
I I googled a little bit

1153
01:19:15,350 --> 01:19:19,910
and people are like, yeah, don't don't even try lock less shared data,

1154
01:19:19,910 --> 01:19:22,550
but I don't really understand why that would be a problem.

1155
01:19:23,270 --> 01:19:23,690
So it's.

1156
01:19:23,690 --> 01:19:24,560
You could like.

1157
01:19:25,490 --> 01:19:26,060
Go ahead.

1158
01:19:27,140 --> 01:19:29,900
You could like be doing something that assumes the thing was true,

1159
01:19:29,900 --> 01:19:31,130
and then like when you read,

1160
01:19:31,160 --> 01:19:32,780
it's not actually true yet,

1161
01:19:32,960 --> 01:19:34,850
like there might be multiple things right,

1162
01:19:36,620 --> 01:19:38,510
that's why you don't want to lock this read.

1163
01:19:39,340 --> 01:19:45,580
So the only time you might be able to even get away with this is

1164
01:19:45,580 --> 01:19:48,340
if you only read a single word

1165
01:19:48,610 --> 01:19:50,710
and that's all the thread does

1166
01:19:50,710 --> 01:19:52,870
and it never does multiple reads,

1167
01:19:54,050 --> 01:19:58,160
but I think you still have some issues with.

1168
01:20:01,150 --> 01:20:03,610
One of the other things is,

1169
01:20:04,300 --> 01:20:06,400
if you're reading more than one piece of data,

1170
01:20:06,490 --> 01:20:10,570
like if on one thread, you take lock, assign a assign b,

1171
01:20:10,690 --> 01:20:13,810
another thread, it doesn't take a lock,

1172
01:20:13,840 --> 01:20:16,930
might see b, the new value of b,

1173
01:20:16,930 --> 01:20:18,610
before it sees the new value of a,

1174
01:20:18,790 --> 01:20:20,110
the ordering that you messed up

1175
01:20:20,110 --> 01:20:24,400
and so if you read like a term from one that,

1176
01:20:24,580 --> 01:20:29,140
from one variable and like whether not the leader for another variable,

1177
01:20:29,440 --> 01:20:33,370
you might read a pair of values that never actually existed,

1178
01:20:33,580 --> 01:20:36,780
because there aren't the guarantees,

1179
01:20:36,810 --> 01:20:39,300
like when you're wishing to concrete systems,

1180
01:20:39,510 --> 01:20:44,700
you need to build everything based off what the guarantees are the platform provides you

1181
01:20:44,700 --> 01:20:45,660
and if you don't,

1182
01:20:45,660 --> 01:20:49,740
there's all kinds of weird edge cases that can throw you off,

1183
01:20:49,950 --> 01:20:52,260
and yeah.

1184
01:20:52,640 --> 01:20:55,640
Yes, so I think the only case in which you can even,

1185
01:20:55,970 --> 01:20:57,920
like try to reason about this,

1186
01:20:57,950 --> 01:21:01,460
is this is this there's only ever one like you know,

1187
01:21:01,610 --> 01:21:05,270
word in the system that you're ever trying to read and write to,

1188
01:21:05,360 --> 01:21:11,660
as soon as you try to write or read multiple pieces of data,

1189
01:21:11,660 --> 01:21:16,040
then it's like you won't be able to reason about anything without locks.

1190
01:21:17,480 --> 01:21:20,450
Basically, if you want to play games with this,

1191
01:21:20,450 --> 01:21:23,540
you have to really understand the compiler,

1192
01:21:23,540 --> 01:21:25,790
the whole putting language and memory model,

1193
01:21:25,850 --> 01:21:27,470
the processor you're using

1194
01:21:27,470 --> 01:21:30,200
and it's like memory coherency system,

1195
01:21:31,130 --> 01:21:34,130
it gets awfully complicated incredibly quickly.

1196
01:21:34,800 --> 01:21:37,620
Yeah, it's also like, I mean this is all undefined behavior,

1197
01:21:37,620 --> 01:21:39,030
so even if it works now,

1198
01:21:39,270 --> 01:21:40,740
like you know I could,

1199
01:21:40,800 --> 01:21:42,690
someone could write a new compiler

1200
01:21:42,690 --> 01:21:46,200
and then you're like that's where the whole thing

1201
01:21:46,200 --> 01:21:48,360
about like demons can fly on your nose,

1202
01:21:48,360 --> 01:21:51,120
like it can literally do anything if you have a data,

1203
01:21:51,120 --> 01:21:52,860
it's because like other programs like,

1204
01:21:53,320 --> 01:21:54,700
doesn't have any semantic,

1205
01:21:54,700 --> 01:21:57,160
so we can like go crazy,

1206
01:21:57,580 --> 01:22:00,070
so I would I would not risk it.

1207
01:22:01,860 --> 01:22:03,240
Okay, it makes sense, thank you.

1208
01:22:04,270 --> 01:22:07,090
So, so even when we're accessing like anything,

1209
01:22:07,090 --> 01:22:09,310
just reading let's say raft server state,

1210
01:22:09,370 --> 01:22:11,530
we should still wrap it in a lock.

1211
01:22:12,280 --> 01:22:14,560
Yeah, it just gets annoying sometimes,

1212
01:22:14,560 --> 01:22:19,570
because you have to like, wrap the single read in a lock and unlock,

1213
01:22:19,570 --> 01:22:22,880
but I'm not sure like knows anything.

1214
01:22:24,540 --> 01:22:27,960
That shouldn't happen super often,

1215
01:22:29,640 --> 01:22:33,450
like I mean maybe if you want to for example check you're still a leader,

1216
01:22:33,480 --> 01:22:35,310
if you're not exit or something like that,

1217
01:22:35,880 --> 01:22:42,180
but, yeah, I don't like,

1218
01:22:42,180 --> 01:22:47,400
I forget, do you use like atomic pools for like killed state for example,

1219
01:22:49,440 --> 01:22:54,540
that like you could use a [typo] which essentially is like locking and unlocking right before,

1220
01:22:54,630 --> 01:22:56,830
accessing it and right after,

1221
01:22:58,520 --> 01:23:09,090
but, yeah, I think you'll like having in some ways very coarse grain locks

1222
01:23:09,090 --> 01:23:12,270
and knowing that you're the only one touching a piece of state,

1223
01:23:12,270 --> 01:23:16,530
will become very handy as you reason about your implementations.

1224
01:23:17,860 --> 01:23:18,490
Thank you.

1225
01:23:21,930 --> 01:23:24,780
I have a question about the channels,

1226
01:23:24,780 --> 01:23:27,090
so when you make a channel,

1227
01:23:27,090 --> 01:23:30,120
it's only between two threads, right,

1228
01:23:30,120 --> 01:23:31,890
or it can be between multiple threads,

1229
01:23:31,890 --> 01:23:37,200
but like if you not, if you don't have buffered,

1230
01:23:37,350 --> 01:23:39,870
it can potentially just lock and block forever right,

1231
01:23:39,870 --> 01:23:42,690
so, for example if you want to do something raft

1232
01:23:42,690 --> 01:23:44,430
and then you have an election,

1233
01:23:45,010 --> 01:23:46,270
you have a channel that like,

1234
01:23:46,840 --> 01:23:48,730
does something about election timeouts,

1235
01:23:48,730 --> 01:23:50,230
you will need a buffer channel,

1236
01:23:50,530 --> 01:23:53,230
that's like the size of the amount of servers, correct,

1237
01:23:53,230 --> 01:23:56,860
because you could like send something and then like it blocks,

1238
01:23:56,860 --> 01:24:02,200
because, you can be, you can have multiple like election things,

1239
01:24:02,230 --> 01:24:06,320
election messages sent between the channels, correct,

1240
01:24:06,320 --> 01:24:08,030
so if you want a buffered channel,

1241
01:24:08,030 --> 01:24:12,530
it should only be between, it should only be between two threads only, correct.

1242
01:24:13,420 --> 01:24:14,950
I mean not necessarily,

1243
01:24:14,950 --> 01:24:16,420
like if two threads are consumers

1244
01:24:16,420 --> 01:24:18,040
and one threads are produced at the back.

1245
01:24:20,070 --> 01:24:24,180
Okay, but multiple producers, I guess you would need that correct.

1246
01:24:25,790 --> 01:24:27,170
Well, not necessarily,

1247
01:24:27,170 --> 01:24:30,230
I mean if the consumer is you know just doing a loop

1248
01:24:30,230 --> 01:24:31,400
and constantly reading,

1249
01:24:31,400 --> 01:24:34,820
then all the producers would just,

1250
01:24:35,850 --> 01:24:40,430
like, I guess it depends on how they schedule by,

1251
01:24:40,430 --> 01:24:45,300
if you're like you would eventually have someone reading from the channel,

1252
01:24:45,750 --> 01:24:48,660
so you can have multiple producers and one consumer.

1253
01:24:51,040 --> 01:24:53,800
Actually, does anyone know about the [],

1254
01:24:54,550 --> 01:24:56,680
do you know about the ordering guarantees of channels,

1255
01:24:56,710 --> 01:24:59,230
like is their aliveness guarantee or you,

1256
01:25:02,620 --> 01:25:04,420
I feel like there is an aliveness guarantee,

1257
01:25:04,420 --> 01:25:05,620
so I guess if you have,

1258
01:25:06,220 --> 01:25:08,050
it's kind of like lock, right,

1259
01:25:08,230 --> 01:25:10,150
like if you're always trying to acquire the lock,

1260
01:25:10,150 --> 01:25:11,980
another thread is also spending

1261
01:25:11,980 --> 01:25:13,270
and trying to acquire the lock,

1262
01:25:13,300 --> 01:25:17,290
there's no guarantee that you will ever require it,

1263
01:25:17,350 --> 01:25:21,040
which is why like randomization might be necessary in that case,

1264
01:25:26,040 --> 01:25:29,610
also I realized I think this lecture is technically over,

1265
01:25:29,700 --> 01:25:31,650
I am holding the office hours right now,

1266
01:25:31,650 --> 01:25:33,450
so if you have questions along to

1267
01:25:33,450 --> 01:25:35,160
or want to continue asking questions,

1268
01:25:35,160 --> 01:25:35,790
I'll be there

1269
01:25:36,090 --> 01:25:37,950
and I think maybe Frans,

1270
01:25:37,950 --> 01:25:41,270
if you want to stick around or other, others.

1271
01:25:42,060 --> 01:25:45,030
But I will move to the office hours, now,

1272
01:25:46,620 --> 01:25:50,060
so, thank you all so much for coming.

1273
01:25:50,420 --> 01:25:51,080
Thank you.

1274
01:25:52,820 --> 01:25:53,630
Thank you.

1275
01:25:59,590 --> 01:26:01,810
Oh, can I just ask a quick question?

1276
01:26:03,440 --> 01:26:05,270
Yeah, alright, Frans, you're the host now,

1277
01:26:05,270 --> 01:26:07,610
so I'm going to just hop off to my office.

1278
01:26:07,610 --> 01:26:10,250
And [] what is the theme of the your vim?

1279
01:26:11,600 --> 01:26:14,060
Oh, what's the scheme, like my color scheme.

1280
01:26:14,360 --> 01:26:14,810
Yeah.

1281
01:26:16,180 --> 01:26:17,260
That's a good question,

1282
01:26:17,260 --> 01:26:20,710
I'm not actually sure, let me check.

1283
01:26:24,620 --> 01:26:26,030
[].

1284
01:26:27,440 --> 01:26:29,000
Sorry?

1285
01:26:29,000 --> 01:26:30,170
I'll type in the chat.

1286
01:26:30,200 --> 01:26:30,980
Ha ha.

