1
00:00:03,200 --> 00:00:07,820
好的，下午好，早上好，晚上好，无论你在哪里。

2
00:00:08,820 --> 00:00:12,300
今天我想谈谈主/备复制，

3
00:00:12,330 --> 00:00:15,570
是对主/备应用程序的介绍。

4
00:00:16,350 --> 00:00:20,520
我们将在本学期的多节课中讨论这一点，

5
00:00:20,910 --> 00:00:28,650
但这是[]或 VMware 容错论文，

6
00:00:28,650 --> 00:00:31,620
是一个非常好的介绍，引出了很多问题，

7
00:00:31,830 --> 00:00:34,560
在整个学期都会出现这样的问题。

8
00:00:35,860 --> 00:00:38,410
今天课程的计划如下。

9
00:00:41,170 --> 00:00:43,090
我想谈谈失败，

10
00:00:43,090 --> 00:00:48,580
你可能希望使用主/备复制来容错，

11
00:00:48,580 --> 00:00:51,310
而有些你可能做不到。

12
00:00:51,990 --> 00:00:54,570
然后我想谈谈主要挑战，

13
00:00:54,960 --> 00:00:57,630
关于备份的方案，

14
00:00:58,980 --> 00:01:00,570
从广义上来讲。

15
00:01:00,570 --> 00:01:06,500
然后谈谈两种主要方法，两种应用，

16
00:01:08,300 --> 00:01:12,980
一种是通常称为状态转移复制，

17
00:01:15,330 --> 00:01:18,420
第二个通常称为复制状态机。

18
00:01:24,980 --> 00:01:29,060
今天的论文是复制状态机方法的一个例子，

19
00:01:29,450 --> 00:01:32,480
实际上，实验 2 或实验 3 ，实验 4 ，

20
00:01:32,480 --> 00:01:34,940
也将使用复制状态机方法，

21
00:01:34,940 --> 00:01:39,470
以及 GFS 论文复制块

22
00:01:39,530 --> 00:01:41,510
也是使用复制状态机方法。

23
00:01:42,160 --> 00:01:44,020
因为这是一种相当常见的方法。

24
00:01:44,290 --> 00:01:46,930
然后为了让事情更具体，

25
00:01:46,930 --> 00:01:49,270
通过观察这个案例研究，

26
00:01:52,140 --> 00:01:59,160
VMware 容错方案或实施或系统。

27
00:02:00,020 --> 00:02:03,020
在我开始之前有什么问题吗，

28
00:02:03,020 --> 00:02:04,490
只是为了，

29
00:02:04,490 --> 00:02:09,380
我试着回答你们通过电子邮件发送的所有问题，

30
00:02:10,040 --> 00:02:12,620
在前半夜之前来的，

31
00:02:12,620 --> 00:02:15,290
一般都会在后半夜回答，

32
00:02:15,290 --> 00:02:17,360
尽可能多地回答，

33
00:02:17,810 --> 00:02:19,520
但如果我没有回答你的问题，

34
00:02:19,520 --> 00:02:23,240
然后，这个话题在上课时或任何时候出现，

35
00:02:23,240 --> 00:02:25,610
可以随意打断，然后提问。

36
00:02:26,920 --> 00:02:29,710
好了，在我们开始之前，有什么问题吗？

37
00:02:41,740 --> 00:02:45,550
所以，让我们从非常广泛的意义上讨论失败，

38
00:02:45,790 --> 00:02:46,600
你可以大致了解

39
00:02:46,600 --> 00:02:50,470
我们希望复制方案能够处理的（失败）。

40
00:02:58,610 --> 00:03:00,740
所以，首先，通常情况下，

41
00:03:00,740 --> 00:03:03,680
论文中所要构建的系统，

42
00:03:03,890 --> 00:03:06,020
只会处理一些事情，

43
00:03:06,020 --> 00:03:09,140
通常称为 fail-stop 失败，

44
00:03:14,250 --> 00:03:15,510
基本的想法是，

45
00:03:15,510 --> 00:03:16,710
基础设施故障

46
00:03:16,710 --> 00:03:18,960
或计算机组件不能很好地工作，

47
00:03:19,470 --> 00:03:21,810
使计算机停止运行，

48
00:03:28,120 --> 00:03:29,140
所以假设是，

49
00:03:29,140 --> 00:03:33,190
计算机瞬间从工作到不工作，

50
00:03:33,370 --> 00:03:35,230
它不会产生奇怪的结果，

51
00:03:35,230 --> 00:03:37,240
因为计算机不能正常工作。

52
00:03:37,270 --> 00:03:39,730
所以跟据这个协议，

53
00:03:39,730 --> 00:03:43,210
当你对寄存器值相加，

54
00:03:43,210 --> 00:03:45,370
它会产生相加值，

55
00:03:45,700 --> 00:03:47,530
所以我们假设，

56
00:03:47,530 --> 00:03:49,840
当计算机工作时，它就会正确工作，

57
00:03:49,840 --> 00:03:52,120
当有失败的时候，它就会停止。

58
00:03:53,030 --> 00:03:55,520
这会包括许多情况，

59
00:03:55,580 --> 00:04:00,020
比如，无论计算机风扇出现故障，

60
00:04:00,020 --> 00:04:01,460
计算机过热，

61
00:04:01,490 --> 00:04:03,440
然后计算机自动关机，

62
00:04:04,080 --> 00:04:09,870
其他情况是有人跨过电源线，

63
00:04:10,020 --> 00:04:12,000
然后突然，整个电脑都消失了，

64
00:04:12,090 --> 00:04:14,370
或者切断网络连接，

65
00:04:14,400 --> 00:04:15,840
在这个时刻，

66
00:04:15,840 --> 00:04:17,880
计算机保持运行，

67
00:04:17,880 --> 00:04:20,370
但完全断开了连接。

68
00:04:21,780 --> 00:04:25,170
有时计算机本身的系统或软件，

69
00:04:25,170 --> 00:04:29,820
最好的做法是将部分故障转变为 fail-stop 失败，

70
00:04:30,240 --> 00:04:33,480
例如，软件计算数据的校验和，

71
00:04:33,480 --> 00:04:36,120
然后，如果它发现校验和不正确，

72
00:04:36,120 --> 00:04:38,160
可以直接停止计算机。

73
00:04:39,080 --> 00:04:42,290
所以这些都是很常见的，

74
00:04:42,290 --> 00:04:43,430
要做到这一点，

75
00:04:43,430 --> 00:04:45,200
这个词的意思是，

76
00:04:45,620 --> 00:04:47,540
计算机正常工作，然后计算停止。

77
00:04:48,810 --> 00:04:50,130
那么，这排除了什么，

78
00:04:50,160 --> 00:04:52,920
有一大堆的失败被排除了，

79
00:04:52,920 --> 00:04:56,400
例如，它不能很好地处理逻辑错误，

80
00:04:57,140 --> 00:04:59,180
比如，如果你的软件有错误，

81
00:04:59,180 --> 00:05:01,220
无论你除以零，

82
00:05:01,220 --> 00:05:04,580
或者你不应该有的错误，

83
00:05:04,940 --> 00:05:06,380
然后非常可能，

84
00:05:06,380 --> 00:05:08,210
备份也会做同样的事情，

85
00:05:08,270 --> 00:05:10,130
因为其中一个软件是坏的，

86
00:05:10,130 --> 00:05:13,400
所以，它在主机上出现故障，也在备份机上出现故障，

87
00:05:13,550 --> 00:05:17,270
所以，复制不能

88
00:05:17,270 --> 00:05:18,710
不能为你解决这类问题。

89
00:05:19,520 --> 00:05:22,190
类似地，如果你有配置错误，

90
00:05:26,150 --> 00:05:29,120
主/备不会为你解决这类问题，

91
00:05:29,240 --> 00:05:35,000
如果你指定的文件，复制说不正确，

92
00:05:35,030 --> 00:05:37,430
那么系统将不能正常工作。

93
00:05:38,030 --> 00:05:41,000
同样，我们不在这节课上，

94
00:05:41,000 --> 00:05:43,160
我们会在学期末讨论，

95
00:05:43,160 --> 00:05:46,400
但我们不能处理恶意错误，

96
00:05:48,170 --> 00:05:53,420
所以不能处理试图伪造协议的攻击者，

97
00:05:53,420 --> 00:05:56,660
运行服务器发送错误消息，

98
00:05:56,840 --> 00:05:59,300
并试图戏弄整个系统，

99
00:05:59,420 --> 00:06:00,920
这不在我们考虑之列。

100
00:06:00,920 --> 00:06:03,260
所以在这学期的大部分时间里，

101
00:06:03,320 --> 00:06:05,420
我们假设软件工作正常，

102
00:06:05,450 --> 00:06:06,860
没有逻辑错误，

103
00:06:06,890 --> 00:06:08,420
没有配置错误，

104
00:06:08,510 --> 00:06:11,450
我们关注的事情是处理停止失败。

105
00:06:12,950 --> 00:06:15,350
有一些失败，

106
00:06:15,530 --> 00:06:21,770
是可以使用主备复制处理的，

107
00:06:22,010 --> 00:06:23,240
或者不可以，

108
00:06:23,540 --> 00:06:26,570
比如，你可能会想到地震，

109
00:06:29,690 --> 00:06:33,260
如果主备在物理上是分开的，

110
00:06:33,410 --> 00:06:35,240
在完全不同的地方，

111
00:06:35,240 --> 00:06:38,030
在不同的大陆或同一大陆的不同部分，

112
00:06:38,300 --> 00:06:39,800
在这种情况下，你可能会希望，

113
00:06:39,800 --> 00:06:41,090
你可能会希望，

114
00:06:41,090 --> 00:06:43,550
备机可以接管，

115
00:06:43,550 --> 00:06:46,580
如果主机因为地震发生故障，

116
00:06:46,760 --> 00:06:50,900
但是其他一些复制方案，

117
00:06:50,900 --> 00:06:52,160
情况不会是这样的，

118
00:06:52,160 --> 00:06:55,250
主备在同一个数据中心，

119
00:06:55,250 --> 00:06:57,260
整个数据中心都会消失，

120
00:06:57,470 --> 00:06:59,060
那么故事就结束了。

121
00:07:00,220 --> 00:07:00,850
好的?

122
00:07:01,060 --> 00:07:02,830
希望这能给你一些背景知识，

123
00:07:02,830 --> 00:07:05,500
关于你试图解决的失败类型。

124
00:07:06,510 --> 00:07:11,130
即使只关注 fail-stop 故障，

125
00:07:11,340 --> 00:07:14,880
也很难建立容错系统，

126
00:07:15,060 --> 00:07:18,120
我们将讨论一下会出现的一般性问题，

127
00:07:18,120 --> 00:07:22,350
如果我们要建立一个主备系统，

128
00:07:25,040 --> 00:07:30,350
在 VM FT 论文中有具体的这些问题。

129
00:07:31,010 --> 00:07:33,980
所以一个挑战是，

130
00:07:33,980 --> 00:07:36,410
如果失败发生，

131
00:07:36,560 --> 00:07:38,810
主机真的失败了吗？

132
00:07:47,690 --> 00:07:50,570
让这件事变得具有挑战性的一个问题是，

133
00:07:50,570 --> 00:07:51,470
在分布式系统中，

134
00:07:51,470 --> 00:07:54,410
你无法区分网络分区和机器故障，

135
00:07:54,410 --> 00:07:55,850
所以完全有可能，

136
00:07:55,850 --> 00:07:59,300
网络， primary 还在运行，初选还在继续，

137
00:07:59,300 --> 00:08:01,940
但是有些计算机不能与 primary 交互，

138
00:08:01,940 --> 00:08:04,310
因为网络已经分区，

139
00:08:04,310 --> 00:08:06,230
比如， backup 可能会决定，

140
00:08:06,230 --> 00:08:07,490
primary 已经失效，

141
00:08:07,490 --> 00:08:08,660
因为网络分区，

142
00:08:08,840 --> 00:08:10,340
但是实际上 primary 并没有，

143
00:08:10,700 --> 00:08:13,280
也许有些客户端还能访问 primary ，

144
00:08:13,400 --> 00:08:14,930
所以你必须有一些[故事]

145
00:08:15,080 --> 00:08:20,720
来确保你不会陷入有两个 primary 的情况。

146
00:08:21,360 --> 00:08:24,240
同样地，我们上一次讨论了，

147
00:08:24,240 --> 00:08:25,470
它再次出现在这篇论文中，

148
00:08:25,470 --> 00:08:26,970
下周也会出现，

149
00:08:27,120 --> 00:08:29,820
我们想要避免陷入这样的境地，

150
00:08:29,820 --> 00:08:31,740
有一个脑裂系统，

151
00:08:35,090 --> 00:08:37,460
我们有两个 primary ，

152
00:08:37,460 --> 00:08:40,160
一个客户端子集访问一个 primary ，

153
00:08:40,160 --> 00:08:42,050
另一个客户端子集访问另一个 primary ，

154
00:08:42,320 --> 00:08:46,160
很明显这会产生系统状态的分歧，

155
00:08:46,280 --> 00:08:50,840
当网络恢复时，我们处于错误的状态，

156
00:08:50,990 --> 00:08:53,000
所以，我们必须不惜一切代价避免这种情况。

157
00:08:54,230 --> 00:08:57,500
第二个挑战是，

158
00:08:57,830 --> 00:09:00,260
我们如何才能保持，

159
00:09:00,290 --> 00:09:03,620
如何使主备保持同步。

160
00:09:14,000 --> 00:09:15,350
我们的目标是，

161
00:09:15,350 --> 00:09:17,570
如果 primary 出现故障，

162
00:09:17,570 --> 00:09:20,390
然后，我们可以正常地切换到 backup ，

163
00:09:20,390 --> 00:09:23,240
backup 在 primary 停止的地方重新开始，

164
00:09:23,920 --> 00:09:26,350
这要求 backup 总是最新的，

165
00:09:26,350 --> 00:09:31,480
有 primary 已经写入的最新状态，

166
00:09:31,480 --> 00:09:33,580
以便操作可以无缝进行，

167
00:09:33,580 --> 00:09:38,470
而不会向客户端返回错误或无法响应，

168
00:09:38,980 --> 00:09:40,270
从客户的角度来看，

169
00:09:40,360 --> 00:09:41,440
真正看起来，

170
00:09:41,440 --> 00:09:43,450
即使它是复制的，

171
00:09:43,570 --> 00:09:44,650
就像一台计算机，

172
00:09:44,680 --> 00:09:47,230
只是比一台计算机具有更强的容错能力。

173
00:09:48,680 --> 00:09:50,690
事实证明，这是困难的，

174
00:09:50,720 --> 00:09:51,710
首先，

175
00:09:51,710 --> 00:09:54,560
我们必须确保我们应用所有的变更，

176
00:09:54,560 --> 00:09:56,450
我们必须按正确的顺序应用变更，

177
00:10:01,880 --> 00:10:05,600
在连续性问题中，

178
00:10:05,990 --> 00:10:08,180
我们必须避免非决定论，

179
00:10:08,660 --> 00:10:10,880
或者我们必须解决非决定论，

180
00:10:13,610 --> 00:10:17,540
我的意思是，相同的更改在 primary 的行为与在 backup 上的不同，

181
00:10:17,540 --> 00:10:19,580
因为出于某种原因，这样并不好，

182
00:10:19,610 --> 00:10:20,780
我们必须确保，

183
00:10:20,780 --> 00:10:22,490
我们在主备上做的变更，

184
00:10:22,490 --> 00:10:25,790
对主备有完全相同的作用。

185
00:10:27,740 --> 00:10:30,710
一个经常出现的问题，

186
00:10:30,710 --> 00:10:32,390
一个挑战就是故障转移，

187
00:10:35,460 --> 00:10:37,740
你的主机出现故障，

188
00:10:37,740 --> 00:10:39,870
我们需要切换到备机，

189
00:10:40,110 --> 00:10:42,150
当然我们必须确保，

190
00:10:42,600 --> 00:10:45,180
其他主机已经停机，

191
00:10:45,390 --> 00:10:49,500
但是，比如主机可能在操作过程中，

192
00:10:49,500 --> 00:10:52,290
它即将发送一个数据包，

193
00:10:52,290 --> 00:10:53,580
对客户端进行回复，

194
00:10:53,760 --> 00:10:54,630
也可能不是，

195
00:10:54,900 --> 00:10:56,370
所以我们要弄清楚，

196
00:10:56,370 --> 00:10:58,290
响应已经发送或没有发送，

197
00:10:58,320 --> 00:11:00,120
或者我们可以再发一次。

198
00:11:04,300 --> 00:11:05,890
聊天中有一个问题，

199
00:11:05,890 --> 00:11:07,840
什么时候需要进行故障转移，

200
00:11:07,840 --> 00:11:10,360
当主机停机后需要故障转移，

201
00:11:10,540 --> 00:11:12,970
因为我们想要故障转移到备机，

202
00:11:12,970 --> 00:11:14,500
这取决于你的使用。

203
00:11:16,860 --> 00:11:19,710
然后，另一个故障转移的问题是，

204
00:11:19,830 --> 00:11:22,080
我们有多个备份，

205
00:11:22,080 --> 00:11:23,820
不是今天论文中的情况，

206
00:11:23,880 --> 00:11:25,740
是的，我们要问的是最新的[阶段]，

207
00:11:25,740 --> 00:11:28,650
比如，可能在一些操作后，它们都会崩溃，

208
00:11:28,650 --> 00:11:29,520
它们回来，

209
00:11:29,550 --> 00:11:33,720
我们要确保，

210
00:11:33,720 --> 00:11:36,060
我们与有最新的状态服务器交互，

211
00:11:36,060 --> 00:11:38,400
这不是今天的一个问题，

212
00:11:38,640 --> 00:11:40,140
我们稍后会知道为什么，

213
00:11:40,200 --> 00:11:42,930
但我们之后会在其他复制协议中介绍。

214
00:11:45,640 --> 00:11:48,190
是的，所以故障转移意味着备机接管。

215
00:11:51,280 --> 00:11:55,030
好的，这就是主要失败，

216
00:11:55,030 --> 00:11:59,320
我们希望处理的失败类型和主要挑战，

217
00:11:59,320 --> 00:12:02,770
随着我们继续，将会深入讨论这些挑战。

218
00:12:03,070 --> 00:12:06,160
我想谈谈两种主要的方法，

219
00:12:06,190 --> 00:12:07,630
我们将在一个学期内看到，

220
00:12:07,780 --> 00:12:10,990
用于处理主备复制。

221
00:12:19,000 --> 00:12:23,050
一个是我前面提到的状态转移，

222
00:12:27,780 --> 00:12:30,510
这些从高层来说是非常直截了当的，

223
00:12:30,510 --> 00:12:31,740
我们有主机，

224
00:12:32,360 --> 00:12:35,060
如果客户端与主机交互，

225
00:12:35,390 --> 00:12:37,310
主机更新状态，

226
00:12:37,310 --> 00:12:40,310
响应于客户端请求而更新状态，

227
00:12:40,400 --> 00:12:42,650
每隔一段时间，会有一个检查点，

228
00:12:48,240 --> 00:12:57,330
每隔一段时间，检查点将状态给备机，

229
00:13:01,120 --> 00:13:04,510
当然，如果我们希望备机和主机同步，

230
00:13:04,510 --> 00:13:07,450
这意味着每次主机执行操作，

231
00:13:07,750 --> 00:13:09,730
在响应客户端之前，

232
00:13:09,790 --> 00:13:14,350
它必须传输操作所做的状态变更到备机。

233
00:13:15,480 --> 00:13:17,580
所以这是一个方案。

234
00:13:17,970 --> 00:13:22,140
另一种高级别的方法，第二种方法是，

235
00:13:22,140 --> 00:13:28,980
称为复制状态机，状态机复制，

236
00:13:32,920 --> 00:13:35,110
通常简称为 RSM 。

237
00:13:36,180 --> 00:13:39,690
在这里，图片是，

238
00:13:39,750 --> 00:13:40,920
我们仍然有主机，

239
00:13:40,920 --> 00:13:43,080
我们有客户端访问主机，

240
00:13:43,320 --> 00:13:45,600
当然，我们有主机与备机交互，

241
00:13:45,600 --> 00:13:46,830
以保持备备机同步，

242
00:13:47,040 --> 00:13:52,320
但是不是发送状态变更，

243
00:13:52,320 --> 00:13:53,310
从主机到备机，

244
00:13:53,400 --> 00:13:56,940
而是发送操作给备机，

245
00:13:58,990 --> 00:14:01,570
所以，在主机响应客户端之前，

246
00:14:01,570 --> 00:14:03,100
执行它的操作，

247
00:14:03,310 --> 00:14:06,700
我们将客户端发送给我们的操作发送给备机，

248
00:14:06,880 --> 00:14:09,070
备机也可以执行操作，

249
00:14:09,370 --> 00:14:12,160
更新状态，向主机确认，

250
00:14:12,160 --> 00:14:13,810
主机也更新它的状态，

251
00:14:13,810 --> 00:14:15,220
执行操作，

252
00:14:15,220 --> 00:14:17,770
然后将响应发送回客户端。

253
00:14:19,500 --> 00:14:24,810
所以在所有这两种方法中，

254
00:14:24,870 --> 00:14:28,050
计划是主机有一些状态，

255
00:14:28,410 --> 00:14:30,690
我们应用变更到这些状态，

256
00:14:31,020 --> 00:14:33,870
我们对备机做完全相同的操作，

257
00:14:33,870 --> 00:14:36,660
备机与主机有相同的开始状态，

258
00:14:36,720 --> 00:14:38,460
我们将同样的变更应用于状态，

259
00:14:38,460 --> 00:14:40,500
通过操作状态转移，

260
00:14:40,530 --> 00:14:41,760
我们最终进入了一个新的状态，

261
00:14:41,880 --> 00:14:44,610
并且该状态必须与主机的状态相同。

262
00:14:45,200 --> 00:14:47,270
所以，如果失败了，

263
00:14:47,450 --> 00:14:50,300
我们故障切换到备份时，

264
00:14:50,300 --> 00:14:52,520
它与主机的状态完全相同，

265
00:14:52,520 --> 00:14:53,900
所以，它可以接管。

266
00:14:57,190 --> 00:15:00,040
我们会看到这是一种挑战，

267
00:15:00,040 --> 00:15:01,420
但这是基本的计划，

268
00:15:01,990 --> 00:15:07,600
两种方法都是很受欢迎的，

269
00:15:07,600 --> 00:15:11,020
状态转移方法的主要缺点是，

270
00:15:11,020 --> 00:15:13,870
如果一个操作生成很多状态，

271
00:15:13,870 --> 00:15:15,070
那就会很昂贵了，

272
00:15:15,640 --> 00:15:17,530
对于单个操作写入千兆字节的数据，

273
00:15:17,530 --> 00:15:21,670
然后千兆字节的数据需要传输到备机，

274
00:15:21,820 --> 00:15:25,090
而且它可能要昂贵得多，便宜得多，

275
00:15:25,090 --> 00:15:27,520
只把操作发送给备机，

276
00:15:27,670 --> 00:15:29,410
备机就可以执行操作。

277
00:15:30,710 --> 00:15:34,880
我们讨论的许多系统，

278
00:15:34,880 --> 00:15:36,800
它们使用第二种方法，

279
00:15:37,010 --> 00:15:40,220
它们发送操作，而不是状态转移。

280
00:15:41,080 --> 00:15:45,580
事实上，如果你想一想 GFS ，

281
00:15:45,640 --> 00:15:47,980
上周讨论的，

282
00:15:48,130 --> 00:15:49,210
我们可以看到，

283
00:15:49,210 --> 00:15:54,970
主机发送追加操作或写入操作给备机，

284
00:15:55,090 --> 00:15:58,600
不是执行追加操作，然后将结果发送到备机，

285
00:15:58,600 --> 00:16:00,010
它实际上发送操作，

286
00:16:00,010 --> 00:16:03,070
所以这是复制状态机方法的一个示例，

287
00:16:03,160 --> 00:16:04,660
我们将发送操作。

288
00:16:05,060 --> 00:16:08,720
今天的论文也遵循了复制状态机的方法，

289
00:16:08,720 --> 00:16:11,750
操作不是追加和写入，

290
00:16:12,050 --> 00:16:14,150
文件系统附加，文件系统写入，

291
00:16:14,180 --> 00:16:16,670
而是这些操作是 x86 指令，

292
00:16:16,670 --> 00:16:19,040
我们稍后会看到，

293
00:16:19,640 --> 00:16:23,000
但它们都是发送操作。

294
00:16:24,560 --> 00:16:27,140
在实验中，正如我前面提到的，

295
00:16:27,140 --> 00:16:32,300
实验 3 和实验 4 也是复制状态机方法，

296
00:16:32,300 --> 00:16:35,120
我们发送操作从主机到备机。

297
00:16:40,710 --> 00:16:41,550
作为。

298
00:16:47,330 --> 00:16:48,350
聊天中有个问题，

299
00:16:48,350 --> 00:16:52,100
为什么客户端不需要发送数据给备机，

300
00:16:52,100 --> 00:16:53,240
在我们的复制状态机中，

301
00:16:53,240 --> 00:16:57,530
因为这个想法是这些操作是确定性的，

302
00:16:57,560 --> 00:16:59,690
所以主机，你记得，

303
00:16:59,690 --> 00:17:01,250
我们会更详细地讨论这个，

304
00:17:01,250 --> 00:17:03,140
但是主备处于相同的状态，

305
00:17:03,140 --> 00:17:05,940
相同的状态，

306
00:17:06,330 --> 00:17:08,820
如果操作是确定性的，

307
00:17:08,850 --> 00:17:10,500
你把它应用于相同的状态，

308
00:17:10,500 --> 00:17:12,690
它们最终会和主机处于相同的状态，

309
00:17:13,400 --> 00:17:16,640
所以，应用程序、客户端没有理由发送数据，

310
00:17:16,670 --> 00:17:17,270
在这种情况下，

311
00:17:17,270 --> 00:17:19,940
因为只要发送这个确定性的操作，

312
00:17:20,060 --> 00:17:21,200
就可以保证，

313
00:17:21,200 --> 00:17:23,000
操作将生成相同的数据。

314
00:17:26,800 --> 00:17:28,270
所以接下来的问题是，

315
00:17:28,270 --> 00:17:30,490
怎么知道所有程序和操作，

316
00:17:30,490 --> 00:17:32,500
它们是确定性的还是非确定性的，

317
00:17:32,620 --> 00:17:34,870
知道需要发送哪些信息。

318
00:17:34,870 --> 00:17:37,960
所以在复制状态机方法中的典型做法是，

319
00:17:37,960 --> 00:17:39,850
使所有操作都是确定性的，

320
00:17:40,320 --> 00:17:42,510
不允许非确定性操作，

321
00:17:42,600 --> 00:17:44,220
我们很快会看到如何做到这个。

322
00:17:48,650 --> 00:17:53,270
好的，在你知道更多细节之前，

323
00:17:54,660 --> 00:17:56,100
有一种混合方法，

324
00:17:56,280 --> 00:17:59,160
是的，有一种混合方法，

325
00:17:59,160 --> 00:18:01,080
例如，你可以运行

326
00:18:01,080 --> 00:18:05,670
默认情况下以复制状态机方法，

327
00:18:05,670 --> 00:18:08,610
实际上，这篇论文在某些方面做了这一点，

328
00:18:08,730 --> 00:18:13,350
如果备机失败或主机失败，

329
00:18:13,350 --> 00:18:14,850
你回到一台单独的机器，

330
00:18:15,030 --> 00:18:17,310
然后，你需要创建一个新副本，

331
00:18:17,340 --> 00:18:19,380
通常对于你创建的新副本，

332
00:18:19,380 --> 00:18:23,160
它是通过转移现有副本的状态，

333
00:18:23,160 --> 00:18:25,800
或复制现有副本的状态到新的副本，

334
00:18:26,990 --> 00:18:29,780
不是那么频繁的操作。

335
00:18:30,760 --> 00:18:32,080
然后在，

336
00:18:32,080 --> 00:18:37,150
然后频繁地复制你正在做的操作。

337
00:18:39,810 --> 00:18:43,410
同时可以实时自由地提问，

338
00:18:43,410 --> 00:18:45,300
而不是在聊天中打字，

339
00:18:45,330 --> 00:18:46,980
哪种方式都可以，但是。

340
00:18:48,080 --> 00:18:50,510
好的，正如我提到的，

341
00:18:50,600 --> 00:18:52,460
使用这种复制状态机方法，

342
00:18:52,640 --> 00:18:53,840
有一个问题，

343
00:18:53,960 --> 00:18:58,340
执行什么级别的复制，

344
00:18:58,340 --> 00:19:05,130
或要复制什么级别的操作。

345
00:19:12,540 --> 00:19:17,940
一种可能是应用程序级别的操作，

346
00:19:35,600 --> 00:19:37,310
所以我的意思是，

347
00:19:37,310 --> 00:19:39,590
回想一下 GFS ，

348
00:19:39,770 --> 00:19:47,520
比如它的文件追加或写入。

349
00:19:50,900 --> 00:19:54,620
另一方面，好的，

350
00:19:54,950 --> 00:19:57,650
如果你玩一个复制状态机的游戏，

351
00:19:57,650 --> 00:19:59,810
在应用程序级别的操作上，

352
00:19:59,810 --> 00:20:01,760
这意味着必须涉及到应用程序，

353
00:20:01,820 --> 00:20:04,760
因为它知道这些操作的语义是什么。

354
00:20:05,280 --> 00:20:07,770
它知道追加实际应该做什么，

355
00:20:08,190 --> 00:20:09,990
或者写入应该做什么，

356
00:20:09,990 --> 00:20:13,320
所以，如果你使用复制状态机方法，

357
00:20:13,320 --> 00:20:15,360
在应用程序级别，

358
00:20:15,390 --> 00:20:17,550
那么需要修改应用程序本身

359
00:20:17,550 --> 00:20:22,020
以执行或作为复制状态机方法的一部分。

360
00:20:22,740 --> 00:20:25,980
今天我们看的论文，有一件很酷的事情，

361
00:20:26,370 --> 00:20:29,040
今天看的是，

362
00:20:29,340 --> 00:20:32,010
在机器层面的操作，

363
00:20:32,660 --> 00:20:34,790
或处理器级别或计算机级别，

364
00:20:35,270 --> 00:20:42,410
所以状态是 x86 寄存器，内存状态，

365
00:20:42,830 --> 00:20:48,200
操作是传统的计算机指令，

366
00:20:48,230 --> 00:20:51,440
通过在这个级别进行复制，

367
00:20:51,530 --> 00:20:57,340
可以使你的应用程序完全透明，

368
00:20:57,820 --> 00:20:59,140
因为你可以使用一台计算机，

369
00:20:59,140 --> 00:21:01,990
在它上面运行应用程序和操作系统，

370
00:21:01,990 --> 00:21:04,360
只是运行 x86 指令，

371
00:21:04,720 --> 00:21:06,970
并且这个复制状态机方法

372
00:21:07,180 --> 00:21:13,090
自动创建特定执行的备份，

373
00:21:13,090 --> 00:21:15,100
所以应用程序根本不需要修改，

374
00:21:15,100 --> 00:21:19,030
实际上，在这个论文中，操作系统并没有被修改，

375
00:21:19,060 --> 00:21:20,470
应用程序没有被修改，

376
00:21:20,560 --> 00:21:22,120
你可以使用普通的应用程序，

377
00:21:22,120 --> 00:21:24,640
甚至在编写时都不用考虑容错，

378
00:21:24,880 --> 00:21:29,950
使用这种机器级或指令级复制，

379
00:21:30,040 --> 00:21:32,860
它可以透明地复制。

380
00:21:33,210 --> 00:21:34,560
一件非常酷的事情，

381
00:21:34,560 --> 00:21:37,740
关于今天的论文，它是完全透明的。

382
00:21:42,350 --> 00:21:47,430
这让你想知道怎么去做，

383
00:21:47,430 --> 00:21:48,480
因为会发生什么，

384
00:21:48,480 --> 00:21:49,860
如果你查看机器，

385
00:21:49,860 --> 00:21:51,270
一个中断发生，

386
00:21:51,510 --> 00:21:57,060
那个中断需要以某种方式直接传播到备份，

387
00:21:57,060 --> 00:21:59,520
因为如果你考虑 x86 机器，

388
00:21:59,700 --> 00:22:02,640
当然，应用程序执行的常规指令，

389
00:22:02,790 --> 00:22:08,430
比如加法，除法，条件分支过程调用，

390
00:22:08,460 --> 00:22:11,010
但是还有其他事件，比如中断，

391
00:22:11,010 --> 00:22:13,320
它们也需要被处理，

392
00:22:13,380 --> 00:22:14,250
那么你如何做到这个。

393
00:22:15,020 --> 00:22:21,890
所以，一种传统的进行机器级别复制的方式，

394
00:22:22,100 --> 00:22:24,140
使用起来相当昂贵，

395
00:22:24,140 --> 00:22:25,730
从某种意义上说，

396
00:22:25,760 --> 00:22:28,700
你可以购买计算机或者处理器，

397
00:22:28,700 --> 00:22:30,860
可能复制两到三次，

398
00:22:31,100 --> 00:22:34,820
硬件本身会组织这些处理器，

399
00:22:34,820 --> 00:22:37,040
完全同步地运行，

400
00:22:38,080 --> 00:22:41,710
有很多硬件设备可以实现这一点，

401
00:22:41,710 --> 00:22:44,530
这篇论文有一个很酷的观察，

402
00:22:44,830 --> 00:22:48,760
你并不需要进行真正的硬件复制，

403
00:22:48,820 --> 00:22:51,250
相反，你可以使用虚拟机，

404
00:22:57,520 --> 00:22:58,750
这就是他们的做法，

405
00:22:59,360 --> 00:23:02,270
纯硬件复制也会发生，

406
00:23:02,300 --> 00:23:11,270
例如，在[]或[]中，

407
00:23:11,300 --> 00:23:13,700
硬件模块通常是

408
00:23:13,700 --> 00:23:17,930
双重复制或三重复制，

409
00:23:17,930 --> 00:23:19,520
并且有使硬件表决方案，

410
00:23:20,030 --> 00:23:22,820
使处理器保持同步以检测故障，

411
00:23:22,970 --> 00:23:24,950
但是这种级别的容错，

412
00:23:24,950 --> 00:23:33,410
不是 VM-FT 论文所讨论的级别，

413
00:23:33,530 --> 00:23:34,850
考虑一下，

414
00:23:34,850 --> 00:23:39,440
你在计算机上运行商业应用程序，

415
00:23:39,440 --> 00:23:42,110
你希望使业务应用程序具有更强的容错能力，

416
00:23:42,560 --> 00:23:46,010
而采取的方法是利用虚拟化。

417
00:23:48,550 --> 00:23:55,880
所以， VM-FT 的情况是利用虚拟化，

418
00:23:55,940 --> 00:24:01,080
这是主要的想法，

419
00:24:01,080 --> 00:24:03,630
他们为解决这个问题而提出的，

420
00:24:03,630 --> 00:24:04,950
通过这样做，

421
00:24:04,950 --> 00:24:08,340
他们可以使复制对应用程序透明。

422
00:24:16,580 --> 00:24:17,870
当然，你不需要设计，

423
00:24:17,870 --> 00:24:21,050
比如应用程序的复制方案，

424
00:24:21,050 --> 00:24:26,210
例如在 GFS 中的复制方式，

425
00:24:26,510 --> 00:24:29,240
使用这个方案，

426
00:24:29,240 --> 00:24:32,150
VM-FT 使用的复制方案，

427
00:24:32,390 --> 00:24:36,510
呈现给客户端，

428
00:24:37,560 --> 00:24:39,300
服务器是单独一台机器，

429
00:24:44,430 --> 00:24:47,520
意思是，我们稍后会看到是怎么回事，

430
00:24:47,520 --> 00:24:49,920
但它们会提供非常强的一致性，

431
00:24:49,920 --> 00:24:53,070
外部的客户端甚至看不出来。

432
00:24:53,560 --> 00:24:57,310
而且，这篇论文是很酷的论文，

433
00:24:57,310 --> 00:24:59,740
因为它是一个真正的产品，

434
00:25:04,210 --> 00:25:05,770
而且它还在使用中，

435
00:25:06,160 --> 00:25:12,940
如果你愿意的话，可以获得这种支持。

436
00:25:13,730 --> 00:25:16,970
我认为目前的产品有些不同，

437
00:25:16,970 --> 00:25:19,610
与我们在论文上看到的，

438
00:25:19,610 --> 00:25:21,710
但是在高的级别上，

439
00:25:21,740 --> 00:25:23,690
这些问题非常相似，

440
00:25:24,170 --> 00:25:28,070
事实上，最大的缺点之一，

441
00:25:28,070 --> 00:25:29,720
就像你们中的许多人在问题中指出的那样，

442
00:25:29,960 --> 00:25:33,200
论文中的一个[]，

443
00:25:33,200 --> 00:25:35,150
这是一个单核心解决方案，

444
00:25:35,450 --> 00:25:37,100
所以不存在多核支持，

445
00:25:37,310 --> 00:25:41,120
所以一台计算机上的多个程序或多个线程不能并行运行，

446
00:25:41,600 --> 00:25:42,680
稍后我们将会讨论，

447
00:25:42,680 --> 00:25:44,630
为什么这个解决方案不支持，

448
00:25:44,870 --> 00:25:50,510
我想后来的 FT 版本可以支持，

449
00:25:50,540 --> 00:25:56,270
但是没有论文详细描述它，

450
00:25:56,300 --> 00:25:57,260
但是我认为，

451
00:25:57,260 --> 00:26:00,110
不是使用复制状态机方法，

452
00:26:00,110 --> 00:26:02,240
而是使用状态转移方法，

453
00:26:02,920 --> 00:26:06,100
但是我也不知道任何细节。

454
00:26:07,420 --> 00:26:09,820
我们将重点介绍复制状态机方法，

455
00:26:09,820 --> 00:26:11,440
因为我喜欢这篇论文的一个原因是，

456
00:26:11,440 --> 00:26:15,520
因为它以一种非常清晰的方式说明了复制状态机方法，

457
00:26:15,730 --> 00:26:20,170
所有后续的复制方案，

458
00:26:20,170 --> 00:26:21,160
我们要看的（复制方案）

459
00:26:21,190 --> 00:26:23,620
都是复制状态机方法。

460
00:26:26,290 --> 00:26:36,530
好的，让我们来描述这个系统的概况。

461
00:26:37,250 --> 00:26:41,030
所以首先要注意的是，

462
00:26:41,030 --> 00:26:43,610
有一个虚拟机监控器，

463
00:26:43,700 --> 00:26:45,170
那么什么是虚拟机监控器，

464
00:26:45,410 --> 00:26:48,380
虚拟机监控器使用一块硬件，

465
00:26:48,470 --> 00:26:53,930
并产生 n 块硬件，

466
00:26:54,760 --> 00:26:58,630
如果我们看一下 x86 盒子，

467
00:26:58,630 --> 00:27:01,330
我们可以在它上面运行一个虚拟机监视器，

468
00:27:03,280 --> 00:27:05,830
在它之上，我们可以有虚拟机，

469
00:27:06,310 --> 00:27:09,370
我们有多个虚拟机，

470
00:27:09,370 --> 00:27:11,710
尽管篇论文的大部分内容我们讨论的是，

471
00:27:11,710 --> 00:27:14,470
在虚拟机监视器之上运行一个虚拟机。

472
00:27:15,320 --> 00:27:19,250
例如，我们可能有一个 Linux 操作系统

473
00:27:19,250 --> 00:27:23,030
和它的应用程序一起运行在虚拟机上。

474
00:27:28,260 --> 00:27:30,720
这里是实际的硬件。

475
00:27:31,920 --> 00:27:35,700
为什么虚拟机，

476
00:27:35,880 --> 00:27:38,940
这里使用的术语有时称为 hypervisor ，

477
00:27:38,940 --> 00:27:40,560
它被称为虚拟机监控器，

478
00:27:40,830 --> 00:27:45,390
在我们的例子中，这里的虚拟机监视器，

479
00:27:45,390 --> 00:27:47,730
实际上就是 VM-FT ，

480
00:27:50,400 --> 00:27:51,900
它是经过修改的虚拟机监视器程序，

481
00:27:51,900 --> 00:27:56,340
包括 VM-FT 的想法。

482
00:27:57,570 --> 00:27:58,440
为什么这很酷，

483
00:27:58,440 --> 00:28:00,240
这很酷的原因是，

484
00:28:00,240 --> 00:28:02,970
或者对复制状态机很有用的原因是，

485
00:28:02,970 --> 00:28:05,880
因为即使一个硬件中断发生，

486
00:28:06,120 --> 00:28:09,030
硬件中断不会直接到 Linux ，

487
00:28:09,030 --> 00:28:11,730
事实上，硬件中断首先通过虚拟机监视器，

488
00:28:12,500 --> 00:28:14,090
虚拟机监视器决定

489
00:28:14,090 --> 00:28:17,150
什么时候将中断传递给 Linux 。

490
00:28:17,800 --> 00:28:24,040
所以，任何外部事件在被虚拟机观察到之前，

491
00:28:24,100 --> 00:28:28,000
可以由虚拟机监视器捕获。

492
00:28:28,650 --> 00:28:31,110
所以这让我们摆脱了这个困境，

493
00:28:31,140 --> 00:28:33,180
就像我刚才提到的，

494
00:28:33,180 --> 00:28:36,570
如果有外部中断会发生什么，

495
00:28:36,570 --> 00:28:38,340
我们如何才能复制它，

496
00:28:38,640 --> 00:28:41,160
我们要在这里复制的方式是，

497
00:28:41,160 --> 00:28:43,350
因为虚拟机监视器会控制它。

498
00:28:44,480 --> 00:28:47,900
我们会看到一个非常强大的工具

499
00:28:47,930 --> 00:28:52,130
真正使指令具有确定性，

500
00:28:52,130 --> 00:28:54,680
处理外部操作，等等。

501
00:28:55,620 --> 00:28:56,640
所以基本的计划是，

502
00:28:56,640 --> 00:28:59,480
如果出现中断，

503
00:28:59,510 --> 00:29:01,640
无论是从网络来的中断，

504
00:29:01,640 --> 00:29:07,790
或者来自硬件本身，比如定时器中断，

505
00:29:08,090 --> 00:29:13,310
基本上定时器中断被传送到虚拟机监视器，

506
00:29:13,340 --> 00:29:17,510
然后在 VM-FT 的情况下，虚拟机监视器会做两件事，

507
00:29:17,510 --> 00:29:20,360
不仅会在某个时刻把它传递给应用程序，

508
00:29:20,480 --> 00:29:24,260
它还通过日志通道将其发送到备份计算机，

509
00:29:25,130 --> 00:29:28,250
备份计算机与硬件相同的方式构建，

510
00:29:28,580 --> 00:29:32,840
它有一个虚拟机监视器，

511
00:29:32,840 --> 00:29:35,690
所以还有另一个 VM-FT ，

512
00:29:35,870 --> 00:29:38,270
在它上面是一台虚拟机，

513
00:29:38,270 --> 00:29:41,570
是运行的确定的软件，比如 Linux ，

514
00:29:41,900 --> 00:29:43,040
相同版本的 Linux ，

515
00:29:43,040 --> 00:29:45,200
以及不管什么应用程序。

516
00:29:47,840 --> 00:29:48,740
好的?

517
00:29:49,560 --> 00:29:55,470
如你所知，这些机器在网络上都使用日志通道，

518
00:29:58,180 --> 00:30:03,460
也许你的客户端和硬件交互，

519
00:30:03,460 --> 00:30:06,430
通过网络发送数据包，

520
00:30:06,700 --> 00:30:10,000
实际的硬件会收到那个数据包，

521
00:30:10,480 --> 00:30:14,590
然后，它会发送它，

522
00:30:14,620 --> 00:30:18,190
虚拟机监视器获得控制权并发送它，

523
00:30:18,190 --> 00:30:20,230
硬件发送给虚拟机监视器，

524
00:30:20,230 --> 00:30:22,210
虚拟机监视器获得它。

525
00:30:22,900 --> 00:30:26,260
所以，如果你仔细想想，

526
00:30:26,260 --> 00:30:32,340
这个数据包结果是中断，

527
00:30:32,340 --> 00:30:34,050
发送给虚拟机监控器，

528
00:30:34,110 --> 00:30:37,530
虚拟机监视器将发送中断，

529
00:30:37,620 --> 00:30:38,700
你会在稍后看到，

530
00:30:38,700 --> 00:30:40,440
然后发送给备机，

531
00:30:41,380 --> 00:30:46,360
也将它发送给本地虚拟机。

532
00:30:47,120 --> 00:30:49,610
本地虚拟机只是在运行 Linux ，

533
00:30:49,610 --> 00:30:50,810
它看到我被中断了，

534
00:30:50,840 --> 00:30:52,430
所以它会进行正常的处理，

535
00:30:52,430 --> 00:30:53,900
它总是会处理中断，

536
00:30:53,930 --> 00:30:57,290
在某个时刻，它可能会产生回应，

537
00:30:57,720 --> 00:31:00,780
例如，可以写入网卡，

538
00:31:00,810 --> 00:31:03,630
或者至少它认为写入网卡，

539
00:31:03,840 --> 00:31:06,510
但它实际上是一个虚拟网卡，

540
00:31:06,510 --> 00:31:10,320
是由虚拟机监视器模拟的，

541
00:31:10,320 --> 00:31:16,620
所以，当写入很多指令到这个虚拟网卡时，

542
00:31:16,680 --> 00:31:19,230
实际写入到虚拟机监视器，

543
00:31:19,230 --> 00:31:21,090
而虚拟机监控器会看到，

544
00:31:21,090 --> 00:31:24,480
这是操作系统想要发送数据包，

545
00:31:25,190 --> 00:31:27,410
然后，虚拟机监视器可以

546
00:31:27,410 --> 00:31:29,540
将数据包发送到操作系统之外，

547
00:31:29,540 --> 00:31:31,250
通过对真实硬件进行编程，

548
00:31:31,520 --> 00:31:34,310
然后是真正的硬件发送响应给客户端。

549
00:31:36,140 --> 00:31:38,390
这是一次正常的执行，

550
00:31:38,390 --> 00:31:42,470
这里是主机，这里是备机，

551
00:31:44,820 --> 00:31:46,590
基本上，在备机上也会发生同样的事，

552
00:31:46,590 --> 00:31:49,950
如果机器在完全相同的状态下启动，

553
00:31:49,950 --> 00:31:52,860
它们同时接收中断，

554
00:31:52,860 --> 00:31:55,650
虚拟机监视器控制何时中断，

555
00:31:55,650 --> 00:31:57,390
它可以安排来确保，

556
00:31:57,390 --> 00:31:59,910
中断在完全相同的时间发送，

557
00:31:59,910 --> 00:32:02,940
以主机得到的完全相同的指令（发送）。

558
00:32:03,270 --> 00:32:05,760
所以，它会将中断发送到，

559
00:32:05,760 --> 00:32:07,560
将从主机接收到中断，

560
00:32:07,710 --> 00:32:09,150
可能会缓冲一段时间，

561
00:32:09,150 --> 00:32:13,590
直到备机随后得到主机同样的指令，

562
00:32:13,680 --> 00:32:16,020
然后将中断发送给 Linux ，

563
00:32:16,110 --> 00:32:17,580
Linux 是一种常见的方式，

564
00:32:17,580 --> 00:32:18,150
它会，

565
00:32:18,180 --> 00:32:20,910
因为它和主机的状态完全一样，

566
00:32:20,910 --> 00:32:23,250
它将与主机做完全相同的事情，

567
00:32:23,400 --> 00:32:24,930
在某个时刻，它会，

568
00:32:25,460 --> 00:32:29,450
编程虚拟网卡发送响应数据包，

569
00:32:29,840 --> 00:32:31,370
所有这些事情都会发生，

570
00:32:31,520 --> 00:32:33,590
在某些情况下，发送一个数据包，

571
00:32:33,680 --> 00:32:36,680
虚拟机监视器将获得控制，

572
00:32:36,920 --> 00:32:38,000
它知道自己的备机，

573
00:32:38,000 --> 00:32:39,440
所以它什么也不做，

574
00:32:39,440 --> 00:32:41,360
它并不会向网络上发送数据包，

575
00:32:41,390 --> 00:32:42,320
因为这是备机。

576
00:32:43,170 --> 00:32:46,240
好的，这是基本的计划，

577
00:32:46,900 --> 00:32:50,650
然后，这个故事还有一个组成部分，

578
00:32:50,650 --> 00:32:51,910
认识到这一点很重要，

579
00:32:51,910 --> 00:32:54,700
那就是在一边，

580
00:32:56,130 --> 00:32:57,420
在机器网络上，

581
00:32:58,140 --> 00:32:59,400
有一台存储服务器，

582
00:33:07,730 --> 00:33:10,310
你可以把它想象成硬盘，

583
00:33:10,460 --> 00:33:14,420
对于这两个虚拟机，

584
00:33:14,420 --> 00:33:17,900
当应用程序写入文件时，

585
00:33:17,900 --> 00:33:21,770
它会变成，内核将会，

586
00:33:22,040 --> 00:33:27,440
文件系统可能会挂载在本地 Linux 操作系统上，

587
00:33:27,440 --> 00:33:30,260
Linux 操作系统认为这是一个远程磁盘，

588
00:33:30,500 --> 00:33:32,060
将会格式化数据包，

589
00:33:32,060 --> 00:33:34,280
并将数据包发送给，

590
00:33:34,700 --> 00:33:36,710
让我使用不同的颜色画一下，

591
00:33:36,710 --> 00:33:40,160
将会发送数据包到虚拟机监视器，

592
00:33:40,160 --> 00:33:42,170
虚拟机监控器将它发送出去，

593
00:33:42,170 --> 00:33:44,210
虚拟机监视器发送，

594
00:33:44,210 --> 00:33:46,700
通过网络将它发送到存储服务器，

595
00:33:48,300 --> 00:33:50,400
存储服务器将在某个时刻响应，

596
00:33:50,400 --> 00:33:52,650
在某些方面，这种通信是一样的，

597
00:33:52,650 --> 00:33:55,410
就像有一个客户端在网络的另一边，

598
00:33:55,980 --> 00:33:56,970
唯一的区别是，

599
00:33:56,970 --> 00:34:03,150
在存储服务器的情况下， Linux 启动通信，

600
00:34:03,150 --> 00:34:05,280
而在其他情况下，客户端启动通信，

601
00:34:06,280 --> 00:34:09,160
绿色箭头表示与存储服务器的通信，

602
00:34:09,160 --> 00:34:10,750
所以一个网络数据包发送

603
00:34:10,750 --> 00:34:14,830
通过 Linux ，再通过虚拟机监视器到存储服务器。

604
00:34:15,660 --> 00:34:19,530
所以，应用程序向文件写入，

605
00:34:19,530 --> 00:34:21,150
会导致这些消息，

606
00:34:21,150 --> 00:34:23,820
然后更新任何状态，

607
00:34:23,820 --> 00:34:27,990
在存储服务器上持久化状态。

608
00:34:30,040 --> 00:34:31,300
正如我们在论文中看到的，

609
00:34:31,360 --> 00:34:35,020
存储服务器扮演一个额外的角色，

610
00:34:35,050 --> 00:34:40,280
在存储服务器的基础上，

611
00:34:40,310 --> 00:34:44,810
也就是，这里有一个特殊的标志在旁边，

612
00:34:45,170 --> 00:34:47,240
或者在存储服务器上有一个块，

613
00:34:48,030 --> 00:34:54,300
它用来仲裁失败后谁将成为主机。

614
00:34:55,190 --> 00:34:59,180
所以，这一切都归结为，

615
00:34:59,180 --> 00:35:01,250
这是失败转移计划的一部分，

616
00:35:01,640 --> 00:35:06,020
所以，我们看看日志通道中断，

617
00:35:06,020 --> 00:35:11,030
或者到虚拟机监视器的方法是，

618
00:35:11,120 --> 00:35:14,390
它定期通过日志通道发送数据包，

619
00:35:14,540 --> 00:35:19,960
而且它没有从另一边得到任何回应，

620
00:35:20,020 --> 00:35:23,380
然后假设另一边，有一个问题，

621
00:35:23,500 --> 00:35:25,120
当然，它不能决定，

622
00:35:25,150 --> 00:35:27,430
只是网络不工作，

623
00:35:27,460 --> 00:35:31,930
或者是计算机真的崩溃了。

624
00:35:32,440 --> 00:35:33,340
如果它真的崩溃了，

625
00:35:33,340 --> 00:35:35,230
当然，你应该接手，

626
00:35:35,410 --> 00:35:36,670
如果它没有真的崩溃，

627
00:35:36,670 --> 00:35:38,740
那么我们需要某种方式来仲裁，

628
00:35:38,740 --> 00:35:41,050
确保他们中只有一个继续。

629
00:35:41,540 --> 00:35:43,190
让我们假设网络分区，

630
00:35:44,520 --> 00:35:47,190
当网络分区时，这是一个更困难的情况，

631
00:35:47,250 --> 00:35:49,470
比起它们中的一个崩溃，

632
00:35:49,680 --> 00:35:51,510
所以，这里发生网络分区，

633
00:35:52,010 --> 00:35:55,880
但是注意到这两个仍然可以通信，

634
00:35:55,880 --> 00:35:58,640
主机和备机都可以与存储服务器通信。

635
00:35:59,610 --> 00:36:01,500
所以在这种特殊情况下，

636
00:36:01,530 --> 00:36:02,460
接下来会发生的是，

637
00:36:02,460 --> 00:36:03,360
它们会注意到，

638
00:36:03,360 --> 00:36:04,830
双方都会注意到，

639
00:36:04,830 --> 00:36:06,180
主机和备机将注意到，

640
00:36:06,510 --> 00:36:07,650
这里有些问题，

641
00:36:07,650 --> 00:36:10,650
我不能与主机通信，

642
00:36:11,010 --> 00:36:12,240
所以在某种程度上，

643
00:36:12,240 --> 00:36:14,520
另一个服务器很可能已经崩溃了，

644
00:36:14,520 --> 00:36:16,860
我想把自己提升为主机，

645
00:36:16,860 --> 00:36:19,170
所以备机想把自己提升为主机，

646
00:36:19,380 --> 00:36:24,900
或者主机说只想继续为客户端请求提供服务，

647
00:36:24,900 --> 00:36:27,300
现在只想忽略备机。

648
00:36:27,970 --> 00:36:31,210
这就是他们所说的继续存活，

649
00:36:32,910 --> 00:36:35,190
我们会回到单一模式，

650
00:36:35,220 --> 00:36:37,440
我们想要一个主机。

651
00:36:38,440 --> 00:36:40,510
所以，发生这种情况的方式是，

652
00:36:40,510 --> 00:36:43,000
它们两个都会试着读取，

653
00:36:43,060 --> 00:36:45,820
它们称为 test-and-set 操作。

654
00:36:49,340 --> 00:36:50,930
我会更详细地谈一谈，

655
00:36:50,930 --> 00:36:53,330
但两者都连接到存储服务器，

656
00:36:53,360 --> 00:36:56,360
并试着写入一个标志，比如 1 ，

657
00:36:57,340 --> 00:37:00,730
如果该标志已经被设置为 1 ，

658
00:37:00,850 --> 00:37:02,140
然后就结束了，

659
00:37:02,140 --> 00:37:04,540
因为另一个写入 1 更早，

660
00:37:04,720 --> 00:37:06,280
从 0 到 1 。

661
00:37:07,040 --> 00:37:09,080
它们都试图以原子的方式来做这件事，

662
00:37:09,290 --> 00:37:10,700
其中一个首先完成，

663
00:37:10,760 --> 00:37:13,160
将成功地设置为 1 ，

664
00:37:13,160 --> 00:37:15,440
我们可以返回到旧值 0 ，

665
00:37:15,530 --> 00:37:19,550
所以它知道没有其他人成功地写入 1 ，

666
00:37:19,610 --> 00:37:22,430
因此，我应该成为主机，让它继续运行。

667
00:37:23,370 --> 00:37:25,830
主备的第二个，

668
00:37:25,830 --> 00:37:27,810
来的第二个服务器，

669
00:37:27,930 --> 00:37:28,530
我们会看到，

670
00:37:28,530 --> 00:37:29,910
我们尝试将标志设置为 1 ，

671
00:37:29,910 --> 00:37:30,990
已经设置为 1 ，

672
00:37:30,990 --> 00:37:32,190
返回值将是 1 ，

673
00:37:32,190 --> 00:37:33,450
因为这是旧的值，

674
00:37:33,660 --> 00:37:36,330
当进行 test-and-set 操作时，

675
00:37:36,510 --> 00:37:37,740
因此，它将决定，

676
00:37:37,740 --> 00:37:38,910
好的，我要放弃，

677
00:37:38,940 --> 00:37:42,930
因为已经有人接替我了，

678
00:37:43,840 --> 00:37:47,530
正如论文中所说的，它们会终止自己。

679
00:37:49,990 --> 00:37:50,560
好的?

680
00:37:51,080 --> 00:37:54,110
所以这是一种高级别的操作，

681
00:37:54,170 --> 00:37:58,070
故障高级操作。

682
00:37:58,160 --> 00:38:00,890
在聊天中有一个问题，是一个好问题，

683
00:38:01,190 --> 00:38:02,750
标志何时重置为 0 。

684
00:38:03,490 --> 00:38:06,130
嗯，这是一个完全不同的故事，

685
00:38:06,160 --> 00:38:08,860
我还在讨论，会逐渐看到，

686
00:38:09,100 --> 00:38:11,830
就是一旦主机运行，

687
00:38:11,860 --> 00:38:14,740
当我们有一个服务器运行时，

688
00:38:14,980 --> 00:38:17,320
会做第二个备份，

689
00:38:17,350 --> 00:38:20,560
所以我们又有一个备机，

690
00:38:20,560 --> 00:38:21,940
我们必须做修复，

691
00:38:21,970 --> 00:38:23,200
因为我们不做修复，

692
00:38:23,320 --> 00:38:25,630
那么从两台计算机开始，

693
00:38:25,630 --> 00:38:27,220
一台计算机出现故障，我们就只有一台计算机，

694
00:38:27,250 --> 00:38:28,210
然后过一会儿，

695
00:38:28,210 --> 00:38:30,190
一台计算机可能出现故障，那么我们就没有计算机了。

696
00:38:30,720 --> 00:38:31,770
所以必须是这样，

697
00:38:31,770 --> 00:38:33,240
必须有一个修复方案，

698
00:38:33,690 --> 00:38:37,470
在 VMFT 中，修复方案是人工执行的，

699
00:38:37,620 --> 00:38:44,010
如果有人收到监控的通知，

700
00:38:44,010 --> 00:38:46,320
然后创建一个新的复制，

701
00:38:46,500 --> 00:38:50,610
或者基于第一个虚拟机镜像，

702
00:38:50,880 --> 00:38:53,340
确保它们同步，

703
00:38:53,460 --> 00:38:56,940
然后它会重置标志，

704
00:38:56,940 --> 00:39:00,120
当日志重新开始时，

705
00:39:00,120 --> 00:39:01,560
然后标志会重置，

706
00:39:01,560 --> 00:39:04,230
当第二个主机完成备份，

707
00:39:04,530 --> 00:39:09,060
跟据协议，标志就重置了。

708
00:39:09,690 --> 00:39:10,200
好的?

709
00:39:13,590 --> 00:39:15,120
好的。

710
00:39:17,550 --> 00:39:18,750
好的，有一个好问题，

711
00:39:18,750 --> 00:39:21,450
比如可能日志通道中断，

712
00:39:21,450 --> 00:39:27,930
可能通道到服务器也中断了，

713
00:39:28,110 --> 00:39:31,770
所以我们不会得到回应，

714
00:39:32,160 --> 00:39:34,530
这就是系统停止的时刻，

715
00:39:34,560 --> 00:39:37,170
直到某些东西修复，

716
00:39:37,530 --> 00:39:38,820
因为什么都做不了，

717
00:39:38,850 --> 00:39:40,020
所以从那时起，

718
00:39:40,020 --> 00:39:41,850
没有客户端请求处理，

719
00:39:42,180 --> 00:39:44,910
因为我们不知道我们是什么状态，

720
00:39:46,300 --> 00:39:49,810
也许在某个时刻，网络连接得到修复，

721
00:39:49,810 --> 00:39:52,270
那么事情又开始向前发展，

722
00:39:52,660 --> 00:39:54,340
所以这是一个灾难案例，

723
00:39:54,370 --> 00:39:56,740
灾难案例是，

724
00:39:56,740 --> 00:39:59,380
主备都在运行，

725
00:39:59,380 --> 00:40:00,730
但是所有网线都断了。

726
00:40:01,230 --> 00:40:03,330
与这个案例有些相似，

727
00:40:03,330 --> 00:40:05,400
主备同时失败的情况。

728
00:40:09,090 --> 00:40:09,420
好的。

729
00:40:09,420 --> 00:40:12,810
问题，你能再解释一遍吗，

730
00:40:12,810 --> 00:40:15,960
当客户端从存储服务器读取数据时。

731
00:40:16,540 --> 00:40:18,520
客户端完全不从存储服务器读取数据，

732
00:40:18,550 --> 00:40:21,550
可能是 Linux ，

733
00:40:21,550 --> 00:40:22,990
或者在 Linux 上运行的应用程序

734
00:40:22,990 --> 00:40:24,430
可能从存储服务器运行，

735
00:40:24,460 --> 00:40:25,450
这是一种情况。

736
00:40:25,450 --> 00:40:26,320
第二种情况，

737
00:40:26,530 --> 00:40:28,780
VM-FT 可能从存储服务器运行，

738
00:40:28,780 --> 00:40:31,030
以读取 test-and-set 标志。

739
00:40:31,690 --> 00:40:33,160
所以底部的绿色箭头，

740
00:40:33,160 --> 00:40:37,930
从存储服务器到 C ，是。

741
00:40:38,140 --> 00:40:41,980
抱歉，那个绿色的，是个错误的绿色箭头，

742
00:40:41,980 --> 00:40:43,330
应该一直到这里的。

743
00:40:43,690 --> 00:40:44,800
好的，谢谢。

744
00:40:45,040 --> 00:40:46,180
只是通过网络，

745
00:40:46,180 --> 00:40:47,320
并不打算去 C ，

746
00:40:47,320 --> 00:40:48,640
它是打算通过网络。

747
00:40:49,820 --> 00:40:53,000
谢谢你澄清这一点，认识到这一点。

748
00:40:53,180 --> 00:40:54,830
好的，所以。

749
00:40:56,950 --> 00:40:58,480
所以我想，

750
00:40:58,510 --> 00:41:02,350
也许我们可以中断一下，

751
00:41:02,530 --> 00:41:03,730
或者一个分组会议室，

752
00:41:03,880 --> 00:41:06,370
特别想请大家做的，

753
00:41:06,370 --> 00:41:08,320
讨论一下家庭作业的问题，

754
00:41:08,620 --> 00:41:12,610
我们在这里谈到了，

755
00:41:12,730 --> 00:41:14,440
但是我想你好好想想，

756
00:41:15,990 --> 00:41:17,640
理解或互相讨论，

757
00:41:17,640 --> 00:41:19,050
说服自己，

758
00:41:19,050 --> 00:41:24,480
这个方案避免了[]，

759
00:41:24,480 --> 00:41:25,860
脑裂问题，

760
00:41:25,860 --> 00:41:28,320
永远不会出现两个主机。

761
00:41:28,760 --> 00:41:31,580
第二件事要讨论的是，

762
00:41:31,700 --> 00:41:32,990
这是一个合理的设计，

763
00:41:32,990 --> 00:41:34,700
因为看起来我们所做的是，

764
00:41:34,700 --> 00:41:38,240
我们把真正的硬容错部分都放到了存储服务器中，

765
00:41:38,300 --> 00:41:39,350
事实并非如此，

766
00:41:39,350 --> 00:41:40,430
为什么不是这样？

767
00:41:40,820 --> 00:41:44,420
所以这是我想让你们讨论的两件事，

768
00:41:44,540 --> 00:41:45,980
在分组会议室里。

769
00:41:46,010 --> 00:41:47,420
所以我要停止分享。

770
00:41:50,530 --> 00:41:55,980
我要做的参与，

771
00:41:56,040 --> 00:41:58,170
我要让 Lily 来主持，

772
00:41:59,210 --> 00:42:01,730
这样你们可以设置分组会议室，

773
00:42:03,490 --> 00:42:05,860
享受互相讨论。

774
00:42:08,180 --> 00:42:09,890
Lily ，控制权交给你了。

775
00:46:19,440 --> 00:46:22,650
测试看看我能不能加入不同的房间，

776
00:46:28,000 --> 00:46:29,080
情况看起来并不乐观。

777
00:47:04,190 --> 00:47:06,140
是的，我被困在这里了。

778
00:49:54,720 --> 00:49:55,740
又是屏幕，

779
00:50:01,020 --> 00:50:02,430
大家能看到我的屏幕吗？

780
00:50:06,380 --> 00:50:06,860
是的。

781
00:50:07,420 --> 00:50:09,070
好的，很好。

782
00:50:09,640 --> 00:50:11,260
所以我希望你们讨论得很愉快，

783
00:50:11,290 --> 00:50:16,990
希望班上有比以前更多的新学生。

784
00:50:17,580 --> 00:50:19,530
让我们继续，

785
00:50:19,800 --> 00:50:27,760
讨论一下 VM-FT 的设计，

786
00:50:27,760 --> 00:50:29,980
并且快速总结。

787
00:50:30,310 --> 00:50:34,000
抱歉，您能重复一下标志是什么时候设置为 0 吗，

788
00:50:34,000 --> 00:50:36,580
我觉得我们中的一些人可能错过了解释。

789
00:50:36,610 --> 00:50:39,950
好的，很好。

790
00:50:39,950 --> 00:50:40,730
好的，让我，

791
00:50:41,240 --> 00:50:43,850
好的，让我们再画一遍，

792
00:50:43,850 --> 00:50:45,080
这是类似的方式，

793
00:50:45,080 --> 00:50:48,350
这是我们的主机虚拟机，所有东西都在其中，

794
00:50:48,350 --> 00:50:51,030
这是备机，以及里面的所有东西，

795
00:50:51,060 --> 00:50:53,310
日志频道在中间，

796
00:50:53,550 --> 00:50:55,590
连接到一个存储服务器。

797
00:50:55,890 --> 00:50:57,810
有一件事需要考虑一下，

798
00:50:57,810 --> 00:50:59,880
存储服务器扮演两个角色，

799
00:50:59,910 --> 00:51:02,200
所以让我们把这两个角色分开，

800
00:51:02,230 --> 00:51:04,570
一个是存储，

801
00:51:04,630 --> 00:51:07,600
用于主机和备机的磁盘，

802
00:51:07,600 --> 00:51:09,100
我们可以拆分它们，

803
00:51:09,130 --> 00:51:11,500
并将磁盘连接到主备机，

804
00:51:11,950 --> 00:51:16,120
然后另一个角色是仲裁服务器，

805
00:51:20,440 --> 00:51:22,090
它有一个标志，

806
00:51:24,010 --> 00:51:26,050
标志最初是 0 ，

807
00:51:26,050 --> 00:51:27,310
所以现在假设，

808
00:51:27,310 --> 00:51:29,860
主备之间有一个分区，

809
00:51:29,860 --> 00:51:33,310
不能再相互通信，

810
00:51:33,310 --> 00:51:34,870
所以它们要访问仲裁服务器，

811
00:51:34,870 --> 00:51:39,700
试着提高自己作为单独存活的服务器，

812
00:51:39,700 --> 00:51:42,430
作为单台服务器为客户端请求提供服务。

813
00:51:43,470 --> 00:51:46,290
所以它们都将数据包发送到 test-and-set 操作，

814
00:51:46,530 --> 00:51:47,850
一个得到 0 ，

815
00:51:47,850 --> 00:51:48,960
另一个得到 1 ，

816
00:51:48,960 --> 00:51:52,110
得到 1 的知道它是第二个尝试的，

817
00:51:52,440 --> 00:51:56,550
然后，第一个会成功，并继续存活，

818
00:51:56,550 --> 00:51:58,050
所以让我们假设这个存活，

819
00:51:58,770 --> 00:52:00,630
然后这个就消失了，

820
00:52:01,210 --> 00:52:05,560
虚拟机会自己终止，然后完成，

821
00:52:06,890 --> 00:52:08,870
现在标志设置为 1 。

822
00:52:12,020 --> 00:52:13,010
当然，在这一点上，

823
00:52:13,010 --> 00:52:14,600
不再需要仲裁了，

824
00:52:14,600 --> 00:52:16,340
因为没有第二个复制，

825
00:52:16,370 --> 00:52:17,570
根本没有备机，

826
00:52:17,930 --> 00:52:20,360
所以真正的问题是接下来会发生什么，

827
00:52:20,660 --> 00:52:22,010
在修复方面，

828
00:52:22,010 --> 00:52:22,910
会是这种情况，

829
00:52:22,910 --> 00:52:26,120
第二个新的备机拉起存活，

830
00:52:26,120 --> 00:52:29,660
这篇论文的 3.1 节对此进行了详细的讨论，

831
00:52:30,230 --> 00:52:32,360
它的工作方式是，

832
00:52:32,360 --> 00:52:34,130
在用户接口上，

833
00:52:34,130 --> 00:52:36,380
对于系统来说， VMware VMotion ，

834
00:52:36,620 --> 00:52:37,880
你是在说，

835
00:52:37,880 --> 00:52:39,620
嘿，我想复制这个主机，

836
00:52:39,680 --> 00:52:44,360
复制操作会，

837
00:52:45,620 --> 00:52:48,230
停止处理客户端，

838
00:52:48,890 --> 00:52:51,860
在复制过程中，主机不需要担心，

839
00:52:51,860 --> 00:52:53,120
只有一个运行的系统，

840
00:52:53,270 --> 00:52:55,130
一个服务于任何客户端请求，

841
00:52:55,280 --> 00:53:01,340
VMotion 复制虚拟机，

842
00:53:01,430 --> 00:53:05,420
将虚拟机的状态复制到备机，

843
00:53:05,690 --> 00:53:09,410
所以，这里我们有一个完全相同的主机的复制，

844
00:53:09,410 --> 00:53:10,280
它成为备机，

845
00:53:10,810 --> 00:53:13,480
所以，虚拟机的状态是相同的。

846
00:53:14,040 --> 00:53:16,950
一旦发生了复制操作，

847
00:53:17,340 --> 00:53:18,630
然后它可以自由地，

848
00:53:18,630 --> 00:53:23,010
用户接口也可以自由地将这个（标志）设置为 0 ，

849
00:53:24,480 --> 00:53:26,400
客户端请求仍未得到处理，

850
00:53:26,760 --> 00:53:28,380
当这种情况真的发生时，

851
00:53:28,380 --> 00:53:30,420
这个系统就可以重新开始工作了，

852
00:53:30,420 --> 00:53:33,690
但现在有两台机器，一台主机，一台备机，

853
00:53:33,810 --> 00:53:35,790
并且处理客户端请求，

854
00:53:35,790 --> 00:53:37,740
它们通过通道发送，

855
00:53:37,770 --> 00:53:38,970
所以我们又回到运行中。

856
00:53:40,120 --> 00:53:41,170
所以回答了你的问题吗？

857
00:53:47,960 --> 00:53:48,590
我希望是这样的。

858
00:53:49,490 --> 00:53:52,220
如果不是，我很乐意重温这一点，

859
00:53:52,220 --> 00:53:54,590
也许在讲座的最后仍然令人困惑。

860
00:53:55,560 --> 00:53:56,370
好的。

861
00:53:56,670 --> 00:53:57,720
好的，很好。

862
00:53:58,200 --> 00:54:00,000
好的，现在我想回到

863
00:54:00,000 --> 00:54:03,390
这个系统的整体架构，

864
00:54:03,630 --> 00:54:06,030
现在我想更深入一点，

865
00:54:06,030 --> 00:54:09,030
我们决定考虑，

866
00:54:09,060 --> 00:54:13,080
这个仲裁方案至少可以让你指出脑裂问题，

867
00:54:13,380 --> 00:54:16,020
但这种更大的问题，

868
00:54:16,020 --> 00:54:17,940
如果有两台机器在运行，

869
00:54:18,590 --> 00:54:20,270
我们的目标是，

870
00:54:22,870 --> 00:54:24,730
像一台机器一样运行。

871
00:54:29,950 --> 00:54:31,210
所以从客户的角度来看，

872
00:54:31,210 --> 00:54:34,150
应该不可能辨别出，

873
00:54:34,180 --> 00:54:37,330
或者至少在某种程度上证明了这一点，

874
00:54:37,330 --> 00:54:40,270
我们实际上有两台机器。

875
00:54:40,630 --> 00:54:42,670
所以回退一步，

876
00:54:42,880 --> 00:54:44,950
如果我们在非常高的级别考虑，

877
00:54:44,950 --> 00:54:46,540
这里我们有主机，

878
00:54:46,720 --> 00:54:51,910
它有虚拟机寄存器，

879
00:54:51,910 --> 00:54:52,720
这里有内存，

880
00:54:53,020 --> 00:54:56,170
我们的基本方案是，

881
00:54:56,170 --> 00:54:59,380
确保执行完全相同的指令。

882
00:55:02,980 --> 00:55:05,470
砰，砰，砰，这是我们的，

883
00:55:05,470 --> 00:55:08,360
这是备机，这是主机，

884
00:55:08,690 --> 00:55:14,240
基本上当主机，

885
00:55:14,240 --> 00:55:16,070
所以我们开始在相同的状态下映射，

886
00:55:16,070 --> 00:55:17,660
然后它们开始执行指令，

887
00:55:17,900 --> 00:55:19,700
例如，可能第一条指令是 inc ，

888
00:55:20,210 --> 00:55:21,620
第二条指令是 dec ，

889
00:55:22,010 --> 00:55:24,080
第三条指令是 branch ，

890
00:55:24,970 --> 00:55:27,940
如果它们都是从相同的状态开始，

891
00:55:27,940 --> 00:55:29,560
第三条指令是 branch ，

892
00:55:29,560 --> 00:55:31,120
它将 branch 向同一个方向，

893
00:55:31,420 --> 00:55:33,730
也许 branch 到一些指令，

894
00:55:33,760 --> 00:55:38,500
然后比如下一条指令是 divide 等等。

895
00:55:39,600 --> 00:55:41,760
所有这些指令都是确定性的，

896
00:55:41,760 --> 00:55:43,560
所以这是非常直截了当的，

897
00:55:43,560 --> 00:55:46,440
比如如果我们都是从同一个状态开始，

898
00:55:46,440 --> 00:55:50,910
它们以相同的顺序执行完全相同的指令集，

899
00:55:51,060 --> 00:55:53,610
然后我们到达状态 S' ，

900
00:55:54,080 --> 00:55:58,040
这两个状态肯定是相同的。

901
00:55:58,800 --> 00:56:04,110
现在，在设计中遇到的挑战是，

902
00:56:04,110 --> 00:56:06,360
任何种类的复制方案都是，

903
00:56:06,420 --> 00:56:08,790
可能会有差异来源，

904
00:56:08,790 --> 00:56:13,890
我们的目标是让它们完全一样的状态 S' ，

905
00:56:13,950 --> 00:56:16,770
但是会有差异来源。

906
00:56:22,760 --> 00:56:25,250
这是很明显的，

907
00:56:25,280 --> 00:56:28,760
例如，不确定的指令就是我们的问题，

908
00:56:35,300 --> 00:56:38,780
那么非确定性指令的例子是什么？

909
00:56:42,410 --> 00:56:43,640
获取时间。

910
00:56:44,200 --> 00:56:46,270
是的，获取时间，为什么它是不确定的？

911
00:56:47,360 --> 00:56:48,500
因为它没有，

912
00:56:50,280 --> 00:56:59,250
比如备机没有执行。

913
00:57:00,050 --> 00:57:02,360
是的，这里的问题是，

914
00:57:02,360 --> 00:57:05,120
如果有主机和备机，

915
00:57:05,120 --> 00:57:08,150
在某一时刻，会执行这个获取时间的指令，

916
00:57:08,150 --> 00:57:08,750
如果你愿意，

917
00:57:08,960 --> 00:57:11,480
它们可能不在同一时间执行，

918
00:57:11,480 --> 00:57:16,070
所以指令返回的值将会不同，

919
00:57:16,070 --> 00:57:22,460
所以，这是可能的差异来源，

920
00:57:22,460 --> 00:57:23,720
我们需要控制的。

921
00:57:24,240 --> 00:57:24,630
事实上，

922
00:57:24,630 --> 00:57:28,980
我们要把每一条非确定性指令变成确定性指令，

923
00:57:29,040 --> 00:57:31,680
我们稍后会看到如何做到这一点。

924
00:57:32,800 --> 00:57:36,420
同样，数据包输入，

925
00:57:36,420 --> 00:57:38,370
例如当数据包通过网络到达时，

926
00:57:38,610 --> 00:57:39,720
你知道主机，

927
00:57:40,050 --> 00:57:42,060
我们必须确保，

928
00:57:42,060 --> 00:57:45,840
数据包执行或处理，

929
00:57:46,550 --> 00:57:50,030
数据包带来的中断传送

930
00:57:50,030 --> 00:57:52,700
与指令流中完全相同。

931
00:57:52,700 --> 00:57:55,370
所以，我们回到上一页，

932
00:57:55,550 --> 00:57:58,280
备机也会执行这些指令，

933
00:57:59,140 --> 00:58:01,060
和 dec 等等，

934
00:58:01,060 --> 00:58:02,410
完全相同的顺序，

935
00:58:02,440 --> 00:58:04,150
所以如果主机，

936
00:58:04,330 --> 00:58:07,900
我们得到中断传送在指令 1 2 之间，

937
00:58:08,020 --> 00:58:09,040
我们必须确保，

938
00:58:09,040 --> 00:58:11,500
备机也在 1 和 2 之间传送，

939
00:58:12,040 --> 00:58:15,790
因为它在指令流中以相同方式传送，

940
00:58:15,850 --> 00:58:18,490
中断处理程序将运行，

941
00:58:18,490 --> 00:58:20,500
它们都会再次执行相同的指令。

942
00:58:22,030 --> 00:58:25,990
不过，备机会执行

943
00:58:26,020 --> 00:58:29,410
这个时钟中断或数据包到达中断，

944
00:58:29,410 --> 00:58:31,390
稍晚一些在另一个流中（执行），

945
00:58:31,420 --> 00:58:33,370
然后系统的状态可能会有所不同，

946
00:58:33,490 --> 00:58:36,280
所以计算结果可能会有所不同，

947
00:58:36,520 --> 00:58:37,510
所以我们不能这样，

948
00:58:37,510 --> 00:58:38,860
所以，它必须是，

949
00:58:38,950 --> 00:58:44,500
数据包或时钟中断都会同时传送，

950
00:58:45,140 --> 00:58:46,910
与指令流的输入一样，

951
00:58:47,240 --> 00:58:51,940
所以输入数据包或计时器中断，

952
00:58:56,380 --> 00:58:59,230
需要在指令流中的同一点上传送。

953
00:59:02,940 --> 00:59:05,070
所以这些都是差异的来源，

954
00:59:05,190 --> 00:59:06,330
我们需要处理的，

955
00:59:06,330 --> 00:59:08,160
还有其他差异来源吗？

956
00:59:09,440 --> 00:59:12,590
所以我想论文中提到过，

957
00:59:12,590 --> 00:59:15,080
并发也会产生非确定性，

958
00:59:15,350 --> 00:59:17,150
但据我所知，

959
00:59:17,150 --> 00:59:19,520
由于管理程序控制中断，

960
00:59:19,730 --> 00:59:21,530
因为我们有单独的处理器，

961
00:59:21,770 --> 00:59:26,600
线程切换不是管理程序通过中断进行的吗，

962
00:59:26,600 --> 00:59:27,950
所以如果我们控制中断，

963
00:59:27,950 --> 00:59:31,790
我们可以准确地将它们传输到正确的位置，

964
00:59:32,030 --> 00:59:35,000
我们不是也可以控制并发的非确定性吗？

965
00:59:35,450 --> 00:59:37,280
是的，我认为这是一个很好的观察，

966
00:59:37,280 --> 00:59:37,760
所以让我来，

967
00:59:37,760 --> 00:59:39,770
这是一种可能的差异，

968
00:59:39,800 --> 00:59:40,460
好的，首先，

969
00:59:40,460 --> 00:59:44,780
让我们首先同意这是一个可能的差异来源，

970
00:59:44,780 --> 00:59:46,310
多核。

971
00:59:49,120 --> 00:59:49,810
我们看到，

972
00:59:49,810 --> 00:59:53,770
这篇论文中的解决方案，

973
00:59:53,770 --> 00:59:55,060
避免这个问题是，

974
00:59:55,060 --> 00:59:59,780
这是不允许的，不允许有（多核），

975
01:00:00,020 --> 01:00:02,000
所以，只有单个处理器，

976
01:00:02,180 --> 01:00:03,800
假设我们有多核，

977
01:00:04,160 --> 01:00:07,460
为了确保我们了解问题所在，

978
01:00:07,640 --> 01:00:08,720
这里的问题是，

979
01:00:08,720 --> 01:00:11,450
我们有两个线程在同一处理器上运行，

980
01:00:12,040 --> 01:00:13,510
在不同的核心上，

981
01:00:13,930 --> 01:00:16,690
它们抢夺一把锁，

982
01:00:17,630 --> 01:00:19,040
它们中的一个会赢，

983
01:00:19,370 --> 01:00:21,680
这就是接下来要运行的线程，

984
01:00:21,710 --> 01:00:23,780
而另一个会暂停一段时间，

985
01:00:24,300 --> 01:00:26,850
如果我们想要在备机执行这种复制状态机方法，

986
01:00:26,850 --> 01:00:28,860
同样的事情也必须发生，

987
01:00:28,860 --> 01:00:33,030
如果两个线程运行，同时争夺锁，

988
01:00:33,180 --> 01:00:36,330
然后我们必须安排在主机的胜者，

989
01:00:36,330 --> 01:00:37,530
也是备机的胜者。

990
01:00:38,310 --> 01:00:40,860
所以，这需要很多机制，

991
01:00:40,890 --> 01:00:44,220
额外的机制复杂性，

992
01:00:44,220 --> 01:00:46,440
这篇论文显然不想处理，

993
01:00:46,440 --> 01:00:47,610
或者不知道该如何处理，

994
01:00:47,910 --> 01:00:48,990
只是说，

995
01:00:48,990 --> 01:00:52,230
好的，我们只是排除这种差异的可能性，

996
01:00:52,230 --> 01:00:55,050
只是宣布处理器为单处理器。

997
01:00:55,660 --> 01:00:58,300
然后线程切换和诸如此类的事情就不再重要了，

998
01:00:58,300 --> 01:01:01,570
总是一种计算在计算机、处理器上运行，

999
01:01:01,780 --> 01:01:03,220
它会切换，

1000
01:01:03,250 --> 01:01:05,230
如果主机切换到不同的线程，

1001
01:01:05,290 --> 01:01:08,020
备机也会切换到不同的线程，

1002
01:01:08,020 --> 01:01:09,280
因为这是单一的指令，

1003
01:01:09,850 --> 01:01:12,400
它们同时获得外部输入。

1004
01:01:15,640 --> 01:01:16,270
这能理解吗?

1005
01:01:17,760 --> 01:01:19,170
所以在某些方面有点差劲，

1006
01:01:19,170 --> 01:01:20,700
他们放弃了多核。

1007
01:01:21,980 --> 01:01:24,440
正如我提到的，后来的系统，

1008
01:01:24,590 --> 01:01:29,240
在这个产品的较新系统中，可以处理多核。

1009
01:01:29,780 --> 01:01:33,200
我想讨论一下，

1010
01:01:33,200 --> 01:01:35,540
我并不完全知道他们是如何做到的，

1011
01:01:35,540 --> 01:01:38,060
可能是不同的方案，

1012
01:01:38,060 --> 01:01:39,140
你可以想到去做的事情，

1013
01:01:39,140 --> 01:01:42,770
人们进行了多核重播，

1014
01:01:42,770 --> 01:01:44,720
我想是一件必要的事情，

1015
01:01:44,810 --> 01:01:46,520
但我也不是很清楚，

1016
01:01:46,520 --> 01:01:48,110
我不会再谈论这个，

1017
01:01:48,230 --> 01:01:51,140
我只想把重点放在前三项上，

1018
01:01:51,440 --> 01:01:54,020
看看他们在这件事上，是怎么处理的。

1019
01:01:58,130 --> 01:02:00,150
好的，有什么问题吗？

1020
01:02:02,760 --> 01:02:04,170
哦，抱歉，只是确认一下，

1021
01:02:04,200 --> 01:02:11,430
它只传输应用程序发出的指令，

1022
01:02:11,430 --> 01:02:16,330
它不会传输 Linux 生成的指令。

1023
01:02:17,010 --> 01:02:18,180
是的，没错，

1024
01:02:18,240 --> 01:02:20,790
这是我们接下来会看到的有趣的事情，

1025
01:02:21,000 --> 01:02:24,000
但让我现在说得更清楚，

1026
01:02:24,210 --> 01:02:27,800
实际上，这些指令 inc dec branch

1027
01:02:27,800 --> 01:02:30,320
不会发送到主机或备机，

1028
01:02:30,320 --> 01:02:31,880
它们都有自己的复制，

1029
01:02:31,880 --> 01:02:34,430
我们只是在程序中的同一时间点启动它们，

1030
01:02:34,430 --> 01:02:37,220
所以，它们的运行完全是步调一致的，

1031
01:02:37,220 --> 01:02:39,590
几乎没有步调一致，

1032
01:02:39,620 --> 01:02:41,060
但它们以相同的顺序执行这些命令，

1033
01:02:41,900 --> 01:02:43,640
只有发生一些特殊的事情，

1034
01:02:43,640 --> 01:02:46,400
在那些可能的差异点上，

1035
01:02:47,140 --> 01:02:49,480
这篇论文假设，

1036
01:02:49,480 --> 01:02:51,280
大多数指令都是确定性的，

1037
01:02:51,280 --> 01:02:52,450
所以我们不需要做什么事情，

1038
01:02:52,840 --> 01:02:55,900
只有可能出错的指令，

1039
01:02:55,900 --> 01:02:56,740
我们得做点什么。

1040
01:02:56,740 --> 01:02:59,980
可能出现问题的来源之一就是中断。

1041
01:03:01,590 --> 01:03:03,210
所以，让我们来谈谈中断的问题。

1042
01:03:10,880 --> 01:03:14,450
所以，这里虚拟机用来

1043
01:03:14,450 --> 01:03:18,390
修复和解决这个问题，

1044
01:03:18,390 --> 01:03:21,390
我们假设这里有虚拟机管理程序，

1045
01:03:22,800 --> 01:03:25,380
中断发生时，

1046
01:03:25,530 --> 01:03:27,900
中断将出现在管理程序中，

1047
01:03:28,860 --> 01:03:31,020
并且管理程序确切地知道，

1048
01:03:31,020 --> 01:03:34,080
应用程序在什么指令上，

1049
01:03:34,080 --> 01:03:35,790
或在这种级别上，虚拟机（在什么指令上），

1050
01:03:36,120 --> 01:03:38,340
这里， Linux 在这个虚拟机中运行，

1051
01:03:38,580 --> 01:03:39,990
中断发生，

1052
01:03:40,110 --> 01:03:46,470
当然管理程序已经接管了控制权，

1053
01:03:46,500 --> 01:03:50,070
它知道在什么地方停止 Linux ，以接受中断。

1054
01:03:50,070 --> 01:03:51,780
也许执行它，

1055
01:03:52,780 --> 01:03:55,210
到目前为止，它已经执行了 100 条指令，

1056
01:03:56,160 --> 01:03:58,050
然后这个中断进来了，

1057
01:03:58,260 --> 01:04:00,090
管理程序想要

1058
01:04:00,270 --> 01:04:03,570
传递中断在 100 指令之后，

1059
01:04:04,220 --> 01:04:05,510
在此之前，

1060
01:04:05,510 --> 01:04:07,250
它只是通过记录通道发送，

1061
01:04:07,430 --> 01:04:08,840
一条信息给备机，

1062
01:04:10,390 --> 01:04:12,910
这是备机 FT ，

1063
01:04:13,240 --> 01:04:14,110
在那条消息中，

1064
01:04:14,110 --> 01:04:16,840
它会说在指令 100 ，

1065
01:04:17,440 --> 01:04:18,880
当你到达指令 100 时，

1066
01:04:19,150 --> 01:04:20,710
传递这个中断，

1067
01:04:20,740 --> 01:04:23,350
以及可能与该中断相关的一些数据。

1068
01:04:24,860 --> 01:04:26,870
所以这是两件中断发生的事情，

1069
01:04:26,900 --> 01:04:28,250
查看指令号是多少，

1070
01:04:28,250 --> 01:04:29,840
然后给备份发送这条消息，

1071
01:04:29,840 --> 01:04:31,730
说，在某个时候，

1072
01:04:31,730 --> 01:04:33,050
当你到了指令 100 ，

1073
01:04:33,050 --> 01:04:35,210
执行这个中断。

1074
01:04:36,800 --> 01:04:41,270
过了一会儿，中断 1 和中断 2 进来，

1075
01:04:41,570 --> 01:04:46,040
管理程序又是完全相同的事情，

1076
01:04:46,810 --> 01:04:51,640
它们会发出这是指令 200 ，

1077
01:04:51,640 --> 01:04:54,400
可能发送一条消息 200 中断，

1078
01:04:54,400 --> 01:04:57,760
以及任何与中断有关的数据到 FT ，

1079
01:04:59,590 --> 01:05:04,790
所以，当备机收到第一条消息时，

1080
01:05:04,790 --> 01:05:06,020
只需缓冲消息，

1081
01:05:06,890 --> 01:05:09,950
因为它不知道在这条消息之后会运行多长时间，

1082
01:05:09,950 --> 01:05:13,970
直到它知道下一步必须交付一些东西。

1083
01:05:14,900 --> 01:05:16,880
所以在第二条消息进来的时候，

1084
01:05:16,910 --> 01:05:17,990
对于第二次中断，

1085
01:05:18,080 --> 01:05:21,230
启动一台计算机是完全正常的，

1086
01:05:21,620 --> 01:05:24,200
指令 100 传送中断，

1087
01:05:24,350 --> 01:05:26,840
并且继续运行到指令 200 。

1088
01:05:28,360 --> 01:05:28,990
它说做的方式，

1089
01:05:28,990 --> 01:05:31,120
大多数处理器都有这个，

1090
01:05:31,120 --> 01:05:32,740
x86 也有这个，

1091
01:05:32,800 --> 01:05:34,810
你可以对 x86 进行编程，

1092
01:05:34,810 --> 01:05:38,200
表示你应该在执行 100 指令后停止，

1093
01:05:38,500 --> 01:05:41,980
所以，处理器会在执行 100 条指令后停止，

1094
01:05:42,010 --> 01:05:44,800
将控制权交还给操作系统，

1095
01:05:44,800 --> 01:05:46,540
在这种情况下，就是虚拟机监视器。

1096
01:05:47,720 --> 01:05:50,570
所以，这是我们的方案，

1097
01:05:50,570 --> 01:05:54,080
这是 VM-FT 使用的方案，

1098
01:05:54,110 --> 01:05:56,240
用来传递中断，

1099
01:05:56,270 --> 01:05:58,460
在主机和备机上，

1100
01:05:58,490 --> 01:06:00,200
完全按照同样的指令，

1101
01:06:00,260 --> 01:06:02,780
这样它们完全相同，

1102
01:06:02,780 --> 01:06:04,880
按照相同的顺序执行指令。

1103
01:06:06,250 --> 01:06:06,880
要安排这一点，

1104
01:06:06,880 --> 01:06:14,870
当然备机会落后一条消息。

1105
01:06:19,870 --> 01:06:20,530
好的?

1106
01:06:23,970 --> 01:06:25,080
所以我只想确认，

1107
01:06:25,080 --> 01:06:27,060
确定性操作不会

1108
01:06:27,210 --> 01:06:29,460
不会通过日志通道进行通信，

1109
01:06:29,460 --> 01:06:33,700
只是可能出现差异的操作。

1110
01:06:33,970 --> 01:06:34,660
没错。

1111
01:06:34,660 --> 01:06:35,290
通常都是这样。

1112
01:06:35,650 --> 01:06:36,730
确实是这样做的，

1113
01:06:36,760 --> 01:06:39,220
所以让我们再来看看[]，

1114
01:06:39,220 --> 01:06:39,940
然后我们再讨论。

1115
01:06:40,150 --> 01:06:41,650
好的，继续。

1116
01:06:41,830 --> 01:06:44,740
抱歉，所以确定性操作，

1117
01:06:44,920 --> 01:06:47,800
不需要通过日志通道吗？

1118
01:06:48,040 --> 01:06:49,540
是的，它们不需要，

1119
01:06:49,870 --> 01:06:53,980
因为它们都有一份所有指令的复制，

1120
01:06:53,980 --> 01:06:56,500
比如二进制，比如 Linux 运行的任何东西，

1121
01:06:56,830 --> 01:07:00,310
但是指令不是通过日志通道通信的，

1122
01:07:00,310 --> 01:07:02,050
只有非确定性的（指令）需要。

1123
01:07:02,400 --> 01:07:05,370
就像这个中断，我们一会儿会看到，

1124
01:07:05,370 --> 01:07:09,480
这里我们来谈谈第二个问题，非确定性指令，

1125
01:07:11,190 --> 01:07:13,410
比如定时器。

1126
01:07:14,260 --> 01:07:15,550
所以工作的方式是，

1127
01:07:16,060 --> 01:07:19,300
这里我们有 Linux 在虚拟机上运行，

1128
01:07:19,330 --> 01:07:21,040
我们有 FT 运行，

1129
01:07:22,000 --> 01:07:27,130
这个 Linux 使用一个镜像，

1130
01:07:27,310 --> 01:07:29,170
Linux 运行的程序镜像，

1131
01:07:29,530 --> 01:07:32,710
也许这里有一些非确定性的指令，

1132
01:07:33,830 --> 01:07:36,290
基本上 FT 所做的，

1133
01:07:36,500 --> 01:07:38,390
在启动 Linux 之前，

1134
01:07:38,450 --> 01:07:40,880
你浏览 Linux 二进制文件，

1135
01:07:40,910 --> 01:07:43,520
找到所有不确定的指令，

1136
01:07:43,520 --> 01:07:44,720
比如获取时间，

1137
01:07:45,050 --> 01:07:48,650
确保把它们转为无效指令，

1138
01:07:49,010 --> 01:07:53,180
所以当 Linux 执行这些非确定性指令时，

1139
01:07:53,390 --> 01:07:57,200
它将控制权交给管理程序，

1140
01:07:57,610 --> 01:07:58,840
这就是 trap 。

1141
01:07:59,600 --> 01:08:01,340
现在监控程序知道，

1142
01:08:01,340 --> 01:08:04,430
好的，这是指令 341 ，

1143
01:08:04,730 --> 01:08:07,220
我知道这是一个非确定性指令，

1144
01:08:07,220 --> 01:08:10,760
因为我写了导致 trap 的位，

1145
01:08:11,030 --> 01:08:13,700
它会模拟这条指令，

1146
01:08:13,880 --> 01:08:16,910
所以，它会实现执行的所有效果，

1147
01:08:16,970 --> 01:08:19,640
但是记录下效果的结果，

1148
01:08:19,670 --> 01:08:24,170
例如，我们记录下执行指令结果，

1149
01:08:24,170 --> 01:08:27,020
结果放到 a0 ，

1150
01:08:27,020 --> 01:08:28,730
它记录值 a0 ，

1151
01:08:28,760 --> 01:08:30,530
然后发送到备机，

1152
01:08:32,020 --> 01:08:34,360
那个指令的输出，

1153
01:08:34,360 --> 01:08:38,890
比如它在 a0 中的值是 221 ，

1154
01:08:39,160 --> 01:08:40,780
然后所有发送回，

1155
01:08:40,780 --> 01:08:43,210
表示有不确定的指令，

1156
01:08:43,720 --> 01:08:46,120
它的结果是 221 ，

1157
01:08:47,600 --> 01:08:48,560
在某个时刻，

1158
01:08:48,560 --> 01:08:50,330
备机是落后的，

1159
01:08:50,870 --> 01:08:53,540
它会执行，

1160
01:08:53,570 --> 01:08:56,870
因为它以相同的顺序，以相同的方式执行这些指令，

1161
01:08:56,930 --> 01:08:59,750
它也会执行非确定性指令，

1162
01:08:59,780 --> 01:09:01,310
会 trap 到内核，

1163
01:09:01,870 --> 01:09:03,490
这通常会等待，

1164
01:09:03,490 --> 01:09:05,650
因为落后，

1165
01:09:05,650 --> 01:09:07,360
直到收到消息，

1166
01:09:07,510 --> 01:09:10,720
确保它使用相同的值，

1167
01:09:10,750 --> 01:09:14,710
返回与主机上的相同的值。

1168
01:09:14,710 --> 01:09:17,260
所以，这就是非确定性指令的处理方式。

1169
01:09:21,160 --> 01:09:23,800
抱歉，这种情况发生在，

1170
01:09:23,890 --> 01:09:25,870
比如修改二进制文件，

1171
01:09:25,870 --> 01:09:30,070
发生在当它创建虚拟机时？

1172
01:09:30,070 --> 01:09:33,190
是的，我们认为是在引导虚拟机的时候。

1173
01:09:33,890 --> 01:09:34,700
好的。

1174
01:09:35,580 --> 01:09:42,240
但是备机重新执行非确定性指令，

1175
01:09:42,240 --> 01:09:44,250
然后只是验证结果？

1176
01:09:44,460 --> 01:09:45,870
不，它实际上做的是，

1177
01:09:45,870 --> 01:09:50,250
如果虚拟机监视器执行该指令，

1178
01:09:51,000 --> 01:09:53,070
然后你知道，

1179
01:09:53,100 --> 01:09:55,650
虚拟机监视器根本不会执行该指令，

1180
01:09:55,860 --> 01:09:59,340
它知道需要执行这个指令，

1181
01:09:59,550 --> 01:10:01,380
它知道事情会发生什么变化，

1182
01:10:01,380 --> 01:10:03,120
比如哪些寄存器需要更新，

1183
01:10:03,120 --> 01:10:05,250
作为这个指令的结果，

1184
01:10:05,340 --> 01:10:09,150
它将消息中的值放到寄存器中，

1185
01:10:09,180 --> 01:10:12,000
所以，在备机上运行的 Linux

1186
01:10:12,000 --> 01:10:15,600
与主机上运行的 Linux 的效果完全相同。

1187
01:10:20,560 --> 01:10:23,500
所以，这样假设管理程序事先做一些工作，

1188
01:10:23,500 --> 01:10:26,380
在启动虚拟机之前，

1189
01:10:26,380 --> 01:10:29,110
找出这些不确定（指令）的位置。

1190
01:10:29,260 --> 01:10:31,180
是的，管理程序执行这些[]。

1191
01:10:32,920 --> 01:10:34,570
所以这是一个标准的管理程序，

1192
01:10:34,570 --> 01:10:36,880
对于 FT 没有什么新的，

1193
01:10:37,210 --> 01:10:40,750
除了这些人拥有丰富的管理程序经验，

1194
01:10:40,750 --> 01:10:41,740
因为 VMware ，

1195
01:10:42,100 --> 01:10:45,400
所以他们明白这需要什么，

1196
01:10:45,940 --> 01:10:48,340
以及哪些指令是非确定性的。

1197
01:10:51,420 --> 01:10:52,410
好的，所以。

1198
01:10:52,410 --> 01:10:55,740
我还有一个问题，

1199
01:10:55,740 --> 01:11:01,830
如果这是一个完全确定性指令的程序，

1200
01:11:02,400 --> 01:11:07,090
备机能不能比主机运行得更快。

1201
01:11:08,180 --> 01:11:11,240
好的，论文中有一个完整的讨论，

1202
01:11:11,240 --> 01:11:13,340
关于主备的速度，

1203
01:11:13,340 --> 01:11:15,740
确保它们以大致相同的速度运行，

1204
01:11:15,740 --> 01:11:19,190
因为你不想领先太多或落后太多，

1205
01:11:19,610 --> 01:11:21,470
我认为你应该考虑，

1206
01:11:21,470 --> 01:11:23,150
它们在相同的硬件上运行，

1207
01:11:23,150 --> 01:11:24,860
所以它们以大致相同的速度运行。

1208
01:11:25,300 --> 01:11:27,580
事实也是这样的，

1209
01:11:28,160 --> 01:11:31,400
在这个通道上总会有一些通信，

1210
01:11:31,460 --> 01:11:35,120
因为中断是周期性发生的，

1211
01:11:35,480 --> 01:11:39,050
比如每几毫秒，

1212
01:11:39,050 --> 01:11:41,150
或者可能是一百毫秒或十毫秒，

1213
01:11:41,150 --> 01:11:45,110
根据 Linux 编程硬件定时器的速率，

1214
01:11:45,170 --> 01:11:46,610
会有一个定时器中断，

1215
01:11:46,790 --> 01:11:50,120
定时器中断会传送到备机，

1216
01:11:50,120 --> 01:11:51,740
如果你愿意，也可以说是同步点。

1217
01:11:53,630 --> 01:11:55,910
是的，但我的问题是，

1218
01:11:56,150 --> 01:12:00,470
比如，你有一堆确定性的指令，

1219
01:12:00,590 --> 01:12:02,870
通过日志通道发送指令，

1220
01:12:03,800 --> 01:12:07,610
这意味着主机和备机

1221
01:12:07,610 --> 01:12:10,850
可以按照自己的速度运行这些指令，对吗？

1222
01:12:11,090 --> 01:12:11,420
是的。

1223
01:12:11,630 --> 01:12:13,610
所以，我的意思是，

1224
01:12:13,610 --> 01:12:14,900
我不知道这是否会发生，

1225
01:12:14,900 --> 01:12:19,310
但是比如 100 条指令，

1226
01:12:19,310 --> 01:12:23,300
并且主机转到指令 50 ，

1227
01:12:23,570 --> 01:12:26,420
并获得定时器中断，

1228
01:12:26,880 --> 01:12:30,420
但是备机已经是 60 的定时器了，

1229
01:12:30,450 --> 01:12:31,290
这有可能吗。

1230
01:12:31,620 --> 01:12:32,790
这是不可能的，

1231
01:12:32,790 --> 01:12:36,030
因为记得备机落后一个消息。

1232
01:12:38,400 --> 01:12:42,540
所以，在主机完成之前，备机不会开始执行下一个日志。

1233
01:12:42,990 --> 01:12:43,530
好的。

1234
01:12:44,380 --> 01:12:46,960
这就是为什么它落后一个（消息）。

1235
01:12:47,560 --> 01:12:48,520
好的。

1236
01:12:51,440 --> 01:12:55,610
确认备份落后一条指令，

1237
01:12:55,610 --> 01:12:56,660
这就意味着。

1238
01:12:56,660 --> 01:12:59,150
不，不是一条指令，是通道上的一条消息。

1239
01:13:00,180 --> 01:13:01,890
但中断是中断，

1240
01:13:01,890 --> 01:13:02,550
所以，如果我们有，

1241
01:13:02,550 --> 01:13:05,610
如你所说，如果我们有 100 行指令，

1242
01:13:06,200 --> 01:13:09,800
然后在备份和主机上运行。

1243
01:13:09,800 --> 01:13:12,440
备机还不会开始，

1244
01:13:12,440 --> 01:13:14,780
所以主机运行 200 条指令，

1245
01:13:14,990 --> 01:13:16,310
备机会等待，

1246
01:13:16,310 --> 01:13:21,860
直到主机完成这 100 条指令，

1247
01:13:21,920 --> 01:13:24,260
在它开始运行这 100 条指令之前。

1248
01:13:25,580 --> 01:13:26,990
所以有一种方式可以考虑，

1249
01:13:26,990 --> 01:13:29,000
它总是落后了一个时期。

1250
01:13:29,360 --> 01:13:32,240
哦，所以这是一种分批计划。

1251
01:13:33,110 --> 01:13:33,500
是的。

1252
01:13:33,500 --> 01:13:33,830
好的，谢谢。

1253
01:13:34,670 --> 01:13:36,890
好的，我想谈一谈关于失败的问题，

1254
01:13:36,890 --> 01:13:38,240
因为有几件有趣的事，

1255
01:13:38,240 --> 01:13:40,280
还有一条规则需要确保，

1256
01:13:40,280 --> 01:13:42,950
我们得到正确的行为。

1257
01:13:43,500 --> 01:13:46,980
所以，让我们来看看一些场景，

1258
01:13:46,980 --> 01:13:48,000
这是主机，

1259
01:13:48,330 --> 01:13:50,670
这是我们的管理程序 FT ，

1260
01:13:51,240 --> 01:13:55,440
这是我们的日志通道 FT ，

1261
01:13:55,740 --> 01:13:57,090
它们都在网络上，

1262
01:13:57,090 --> 01:13:57,990
这里有一个客户端，

1263
01:13:59,430 --> 01:14:01,080
这是我们的备机。

1264
01:14:04,010 --> 01:14:06,410
接下来我要讲几个场景，

1265
01:14:06,830 --> 01:14:10,850
所以第一种情况是正常的情况，

1266
01:14:10,850 --> 01:14:16,000
客户端向主机发送消息，

1267
01:14:16,000 --> 01:14:17,980
在主机上运行的服务器，

1268
01:14:17,980 --> 01:14:21,260
当然是送到主机的，

1269
01:14:21,260 --> 01:14:23,420
也在通道上发送。

1270
01:14:24,000 --> 01:14:26,040
让我们假设一下，

1271
01:14:26,040 --> 01:14:30,810
消息到达了管理程序，

1272
01:14:30,810 --> 01:14:32,940
所以它知道这是一个中断，

1273
01:14:32,940 --> 01:14:34,200
一些数据包到达，

1274
01:14:35,640 --> 01:14:40,350
所以现在让我们假设主机发回响应，

1275
01:14:41,030 --> 01:14:43,340
在这个时刻，计算机崩溃了，

1276
01:14:44,860 --> 01:14:46,120
所以主机出现故障，

1277
01:14:46,120 --> 01:14:47,710
客户端尚未收到响应。

1278
01:14:48,900 --> 01:14:51,210
现在，这是非常好的，

1279
01:14:51,210 --> 01:14:53,970
因为在备机真正接管之前，

1280
01:14:53,970 --> 01:14:58,920
它首先处理所有收到的消息，

1281
01:14:58,920 --> 01:15:01,350
因为像我们之前说的，落后一个（消息），

1282
01:15:01,650 --> 01:15:04,980
所以这个东西是要传送。

1283
01:15:04,980 --> 01:15:06,750
它会，抱歉。

1284
01:15:12,640 --> 01:15:15,490
好的，让我再小心一点，

1285
01:15:15,490 --> 01:15:18,310
好的，它被传送到主备机，

1286
01:15:18,310 --> 01:15:20,230
但它不会发出任何回应，

1287
01:15:20,930 --> 01:15:21,740
因为它仍然，

1288
01:15:21,740 --> 01:15:24,800
做主机所做的事情，

1289
01:15:25,010 --> 01:15:26,930
通过那个点，然后停下来。

1290
01:15:27,610 --> 01:15:29,110
然后那个点[]，

1291
01:15:29,110 --> 01:15:31,150
或者备机成为主机，

1292
01:15:31,150 --> 01:15:32,590
通过仲裁服务器，

1293
01:15:32,980 --> 01:15:35,140
客户端将会超时并重试，

1294
01:15:35,200 --> 01:15:37,600
因为就像 TCP 包，然后得到响应，

1295
01:15:37,600 --> 01:15:39,430
所以重试把事情做得完美。

1296
01:15:41,100 --> 01:15:42,510
有趣的案例是，

1297
01:15:42,660 --> 01:15:45,890
在以下情况下会发生什么，

1298
01:15:45,920 --> 01:15:51,000
客户端发送请求的情况下，

1299
01:15:51,150 --> 01:15:52,410
它可以到达主机，

1300
01:15:52,410 --> 01:15:54,660
主机进行操作，

1301
01:15:54,660 --> 01:15:56,430
或者客户端请求的任何流程，

1302
01:15:56,490 --> 01:15:58,590
因为消息是给容错服务器的，

1303
01:15:58,710 --> 01:16:00,450
与此同时，

1304
01:16:00,450 --> 01:16:02,790
好的，它也会发送给日志通道，

1305
01:16:02,910 --> 01:16:04,290
但是假设我们运气不好，

1306
01:16:04,440 --> 01:16:06,990
这条消息从未通过日志通道，

1307
01:16:07,860 --> 01:16:09,600
同时，

1308
01:16:12,520 --> 01:16:16,750
但是主机发送响应，

1309
01:16:16,750 --> 01:16:23,000
在发送响应之前，然后它失败了，

1310
01:16:23,000 --> 01:16:24,170
比如，

1311
01:16:24,170 --> 01:16:28,580
可能这个请求是将变量从 10 增加到 11 ，

1312
01:16:28,580 --> 01:16:36,640
所以 inc ，旧的状态是 10 ，现在新的状态是 11 ，

1313
01:16:38,300 --> 01:16:40,640
这种情况有问题吗？

1314
01:16:41,810 --> 01:16:44,720
是的，因为当备机接手的时候，

1315
01:16:44,720 --> 01:16:49,680
它不知道这个增长，

1316
01:16:49,710 --> 01:16:53,580
所以，它将继续执行，就像它没有发生一样，

1317
01:16:53,580 --> 01:16:58,920
我想这会造成不一致的输出，

1318
01:16:58,920 --> 01:17:02,130
对于外部的世界。

1319
01:17:02,370 --> 01:17:03,540
是的，没错，

1320
01:17:03,540 --> 01:17:05,820
因为备机将会接管，

1321
01:17:05,820 --> 01:17:07,140
而值仍是 10 ，

1322
01:17:07,410 --> 01:17:09,810
现在如果客户端执行 inc ，

1323
01:17:09,810 --> 01:17:11,730
它会得到 11 ，

1324
01:17:11,730 --> 01:17:14,290
而不是 12 。

1325
01:17:14,590 --> 01:17:15,550
所以这是不好的，

1326
01:17:16,000 --> 01:17:17,830
那么如何避免这个问题呢？

1327
01:17:18,570 --> 01:17:23,790
主机将数据发送到备机，

1328
01:17:23,790 --> 01:17:25,410
然后等待确认，

1329
01:17:25,410 --> 01:17:28,590
一旦接收到确认，

1330
01:17:28,590 --> 01:17:31,140
它可以发送输出，

1331
01:17:31,590 --> 01:17:35,040
备机是否运行该命令并不重要，

1332
01:17:35,040 --> 01:17:36,840
它只是必须拥有它，

1333
01:17:36,870 --> 01:17:40,470
如果它需要接手主机的工作，

1334
01:17:40,470 --> 01:17:41,880
它有它的日志，

1335
01:17:41,880 --> 01:17:46,150
在成为主机之前，它会赶上。

1336
01:17:46,150 --> 01:17:48,760
完全正确，这就是所谓的输出规则，

1337
01:17:51,520 --> 01:17:54,190
规则是在你可以输出之前，

1338
01:17:54,520 --> 01:17:56,260
你必须确保，

1339
01:17:56,260 --> 01:18:00,070
前面发送给备机的消息，

1340
01:18:00,070 --> 01:18:01,810
已经在备机接收到了。

1341
01:18:02,610 --> 01:18:05,580
所以我刚才提出的这个场景实际上不会发生，

1342
01:18:06,220 --> 01:18:07,630
因为在这一点上，

1343
01:18:07,630 --> 01:18:10,840
主机想要在网络上发送响应，

1344
01:18:11,290 --> 01:18:14,200
主机 FT 将会等待

1345
01:18:14,200 --> 01:18:18,460
直到该消息已经被备机接收到，

1346
01:18:18,960 --> 01:18:24,890
并且仅当它从备机 FT 收到确认时，

1347
01:18:25,190 --> 01:18:30,830
现在知道备机有一份这个输入的副本，

1348
01:18:31,450 --> 01:18:34,030
所以不管它失败了，

1349
01:18:34,030 --> 01:18:36,910
备机会执行那个输入，

1350
01:18:36,910 --> 01:18:40,060
并且得到一台与主机处于相同状态的计算机，

1351
01:18:40,240 --> 01:18:43,870
所以在这一时刻，发出回应是安全的。

1352
01:18:45,080 --> 01:18:46,580
这就是输出规则，

1353
01:18:46,580 --> 01:18:48,560
就是你不会输出，

1354
01:18:48,560 --> 01:18:52,760
直到前面所有你通过日志通道发送的消息

1355
01:18:52,790 --> 01:18:54,770
已经被备机接收到。

1356
01:18:55,760 --> 01:18:57,050
我想确认一下，

1357
01:18:57,050 --> 01:19:02,120
看起来输出规则就是用来解决这种不一致的，

1358
01:19:02,120 --> 01:19:04,580
如果我们有一些非确定性的，

1359
01:19:04,880 --> 01:19:09,380
比如，我们的输出操作是指令 60 ，

1360
01:19:09,740 --> 01:19:13,400
而且我们没有输出规则，

1361
01:19:13,580 --> 01:19:15,770
所以备机实际上并没有，

1362
01:19:15,800 --> 01:19:19,940
假设由于某种原因没有接收到输出操作，

1363
01:19:20,210 --> 01:19:23,570
或者直到输出操作才接收到，

1364
01:19:23,750 --> 01:19:26,720
如果指令在点之间是确定性的，

1365
01:19:26,780 --> 01:19:29,630
备机没有收到消息，

1366
01:19:29,870 --> 01:19:32,630
直到我们进行输出操作时，

1367
01:19:32,900 --> 01:19:35,840
我们还会遇到不一致的问题吗？

1368
01:19:36,280 --> 01:19:38,650
是的，因为客户端可能会注意到这一点，

1369
01:19:38,650 --> 01:19:41,890
客户端可能会注意到现在的值是 11 。

1370
01:19:43,600 --> 01:19:48,430
所以，当它在主机发生故障后，访问备机时，

1371
01:19:48,430 --> 01:19:50,350
值应该只是 10 ，

1372
01:19:51,180 --> 01:19:52,560
那是不可能的，

1373
01:19:53,490 --> 01:19:57,300
这显示它的行为不像一个单一的系统。

1374
01:19:58,300 --> 01:19:58,750
我明白了。

1375
01:19:59,450 --> 01:20:04,130
外部客户端会观察到一些错误，

1376
01:20:04,130 --> 01:20:05,870
这就是输出规则存在的原因，

1377
01:20:06,200 --> 01:20:07,670
在任何复制系统中，

1378
01:20:07,670 --> 01:20:08,780
我们在这学期会看到的，

1379
01:20:08,810 --> 01:20:10,670
都有类似输出规则的东西。

1380
01:20:11,160 --> 01:20:12,150
结果是，

1381
01:20:12,150 --> 01:20:16,980
比如，你会在 raft 论文中看到，

1382
01:20:17,010 --> 01:20:19,410
也在 zookeeper 中，

1383
01:20:19,410 --> 01:20:20,790
有这样一种概念，

1384
01:20:20,790 --> 01:20:24,540
有时你想直接回复读取，

1385
01:20:24,540 --> 01:20:25,860
但你不能这么做，

1386
01:20:25,860 --> 01:20:27,300
因为你冒着这种风险，

1387
01:20:27,300 --> 01:20:29,700
相当于一条输出规则，

1388
01:20:29,820 --> 01:20:33,030
试图避免像这样的问题。

1389
01:20:35,770 --> 01:20:40,120
因此客户端会重新执行该命令吗，

1390
01:20:40,750 --> 01:20:42,940
比如它们会不会得到某种信号，

1391
01:20:43,460 --> 01:20:47,000
因为备机从未确认过该命令。

1392
01:20:47,540 --> 01:20:51,680
好的，我们假设没有收到确认，

1393
01:20:52,890 --> 01:20:54,840
所以，我回到备机没有确认，

1394
01:20:55,650 --> 01:20:58,200
那么客户端不会，

1395
01:20:58,930 --> 01:21:02,050
这个响应还没有发送到客户端，

1396
01:21:02,930 --> 01:21:04,580
备机将会接管，

1397
01:21:04,670 --> 01:21:06,200
客户端可能会超时，

1398
01:21:06,230 --> 01:21:07,760
做任何它需要做的事，

1399
01:21:07,790 --> 01:21:09,290
要么什么都不做，

1400
01:21:09,350 --> 01:21:11,930
如果这是它们的一部分，

1401
01:21:11,930 --> 01:21:14,390
这是服务器和客户端之间协议的一部分，

1402
01:21:14,420 --> 01:21:18,680
最有可能的是，客户端会重新发送 TCP 连接，

1403
01:21:18,680 --> 01:21:21,560
没有收到响应包，

1404
01:21:21,560 --> 01:21:24,680
所以它会试着重新发送，

1405
01:21:25,340 --> 01:21:26,930
所以它会重新发送到备机，

1406
01:21:28,020 --> 01:21:29,160
然后完成操作，

1407
01:21:30,530 --> 01:21:32,390
但它不会观察到旧的值。

1408
01:21:38,390 --> 01:21:39,020
好的?

1409
01:21:50,850 --> 01:21:56,040
好了，现在我想说一件事，

1410
01:21:56,040 --> 01:21:59,160
所以我认为这个系统非常酷，

1411
01:21:59,160 --> 01:22:05,100
这是一个非常清楚的状态机复制版本，

1412
01:22:05,370 --> 01:22:08,130
它解决了非确定性的问题，

1413
01:22:08,130 --> 01:22:09,900
像输出规则这样的问题，

1414
01:22:09,900 --> 01:22:11,940
我们将在一个版本中看到，

1415
01:22:11,940 --> 01:22:16,800
我们将在其他系统中看到类似的情况，

1416
01:22:16,950 --> 01:22:18,960
但我想谈一谈性能，

1417
01:22:18,960 --> 01:22:23,160
因为这个系统的一个缺点是，

1418
01:22:23,160 --> 01:22:24,600
因为你做事情

1419
01:22:24,600 --> 01:22:28,470
在机器指令或中断的级别上，

1420
01:22:28,710 --> 01:22:32,070
你会付出性能的代价。

1421
01:22:32,980 --> 01:22:36,880
所以像论文中的表格 1 和 2 ，

1422
01:22:37,660 --> 01:22:40,210
首先要观察的一件事是，

1423
01:22:40,210 --> 01:22:42,550
左边的表格非常好，

1424
01:22:43,420 --> 01:22:45,430
所以备机和主机，

1425
01:22:45,430 --> 01:22:48,430
运行备机和主机的性能非常接近于，

1426
01:22:48,430 --> 01:22:51,130
像没有使用备机运行，

1427
01:22:51,130 --> 01:22:52,870
这非常令人印象深刻，

1428
01:22:52,870 --> 01:22:55,420
包括你运行的是一台虚拟机，

1429
01:22:56,300 --> 01:23:03,210
更麻烦的部分是这边的事情，

1430
01:23:03,210 --> 01:23:07,380
如果你不在主/备模式下运行，

1431
01:23:07,380 --> 01:23:10,650
比如你的带宽和收发相当高，

1432
01:23:10,650 --> 01:23:12,780
至少在他们所做的实验中。

1433
01:23:13,310 --> 01:23:15,350
但是当你运行备机模式时，

1434
01:23:15,500 --> 01:23:17,060
其实不是很好，

1435
01:23:17,060 --> 01:23:18,980
这些数字有很大的不同，

1436
01:23:19,130 --> 01:23:22,550
事实上，性能下降了 30% 。

1437
01:23:23,190 --> 01:23:24,780
这 30% 是从哪里来的，

1438
01:23:24,780 --> 01:23:26,370
为什么会这样。

1439
01:23:34,240 --> 01:23:38,260
因为主机是接受外部输入的。

1440
01:23:39,080 --> 01:23:41,240
是的，我想有两种情况，

1441
01:23:41,240 --> 01:23:43,250
在接收的情况下，

1442
01:23:43,250 --> 01:23:45,620
主机接收来自外部的输入，

1443
01:23:45,620 --> 01:23:46,700
这需要放在哪里。

1444
01:23:48,020 --> 01:23:51,170
如果你看到来自客户端的数据包，

1445
01:23:51,170 --> 01:23:57,930
数据包必须发送到备机。

1446
01:23:57,930 --> 01:24:03,630
等等，但是主机也是将输出发送回客户端的服务器，

1447
01:24:03,630 --> 01:24:05,190
所以这就是使用带宽的原因。

1448
01:24:05,660 --> 01:24:10,580
是的，这是一个原因，

1449
01:24:10,580 --> 01:24:12,770
但我认为这里真正发生的事情是，

1450
01:24:12,770 --> 01:24:15,290
主机必须等待，

1451
01:24:15,320 --> 01:24:17,990
直到它可以向客户端发送响应，

1452
01:24:17,990 --> 01:24:20,000
直到备份确认该响应。

1453
01:24:20,960 --> 01:24:23,150
所以处理数据包，

1454
01:24:23,150 --> 01:24:25,790
可以获得没有备机相同的速度。

1455
01:24:27,500 --> 01:24:30,470
所以，我们会看到性能下降。

1456
01:24:32,230 --> 01:24:34,030
尽管如此，性能还是相当令人印象深刻，

1457
01:24:34,030 --> 01:24:36,940
但这是有性能代价的。

1458
01:24:37,500 --> 01:24:38,340
这是一个原因，

1459
01:24:38,340 --> 01:24:43,830
人们不在指令层面上使用复制状态机，

1460
01:24:43,830 --> 01:24:45,480
而是在应用程序级别，

1461
01:24:45,540 --> 01:24:48,420
能够获得更高的性能，

1462
01:24:48,510 --> 01:24:50,970
但这需要修改应用程序，

1463
01:24:50,970 --> 01:24:52,200
就像我们在 GFS 中看到的那样。

1464
01:24:56,380 --> 01:24:58,270
好的，我想我有点超时了，

1465
01:24:58,270 --> 01:24:59,410
所以我现在要停止了，

1466
01:24:59,410 --> 01:25:03,940
所以我希望需要离开的人已经离开了，

1467
01:25:03,940 --> 01:25:05,410
但我会留下来，

1468
01:25:05,470 --> 01:25:07,030
看大家有更多的问题，

1469
01:25:07,030 --> 01:25:10,930
我很乐意回答。

1470
01:25:12,550 --> 01:25:13,960
我周二再跟你们讨论。

1471
01:25:14,540 --> 01:25:14,930
谢谢。

1472
01:25:18,320 --> 01:25:23,570
我对之前的图像有一个问题，

1473
01:25:23,660 --> 01:25:27,030
你画的那个，

1474
01:25:27,060 --> 01:25:28,530
是的，就是那个，

1475
01:25:28,590 --> 01:25:31,110
我很困惑，因为，

1476
01:25:31,740 --> 01:25:33,720
不是这种情况，

1477
01:25:37,690 --> 01:25:39,520
然后我们做一个增加，

1478
01:25:40,220 --> 01:25:44,400
我们不需要发送任何东西给备机，对吗。

1479
01:25:45,730 --> 01:25:47,860
好的，这里有两件事，

1480
01:25:47,860 --> 01:25:48,730
所以我们看到，

1481
01:25:48,730 --> 01:25:50,890
在消息到达的时刻，

1482
01:25:51,010 --> 01:25:54,910
比如来自客户端的这个增加，

1483
01:25:55,270 --> 01:26:00,460
到达主机管理程序的 FT ，

1484
01:26:01,150 --> 01:26:06,070
它需要将该消息转发到备机 FT ，

1485
01:26:06,070 --> 01:26:07,660
这样它才能处理，

1486
01:26:07,660 --> 01:26:10,030
当它需要处理的时候，

1487
01:26:10,120 --> 01:26:15,320
它处理这个指令流中的完全相同的点。

1488
01:26:16,710 --> 01:26:17,850
所以它发送出去，

1489
01:26:17,880 --> 01:26:19,890
然后把它发送到主机，

1490
01:26:19,980 --> 01:26:21,930
然后主机上线，做它自己的事情，

1491
01:26:22,080 --> 01:26:24,570
主机回复一个消息，

1492
01:26:24,930 --> 01:26:27,120
所以，如果主机回复了一条消息，

1493
01:26:27,150 --> 01:26:29,760
消息输出会停止，

1494
01:26:29,760 --> 01:26:36,120
或者直到备机确认这个增加的回复，

1495
01:26:39,860 --> 01:26:42,410
这将确保如果备机必须接管，

1496
01:26:42,410 --> 01:26:44,690
它会首先处理这个增加，

1497
01:26:44,690 --> 01:26:47,990
它也会是 11 ，在发送回复之前。

1498
01:26:52,140 --> 01:26:54,720
好的，好的，谢谢。

1499
01:26:55,430 --> 01:26:58,520
我搞不懂的一件事是，

1500
01:26:58,520 --> 01:27:05,320
系统的目标是帮助提高服务器的性能吗，

1501
01:27:05,320 --> 01:27:10,270
因为在没有管理程序的情况下处理中断并不简单，

1502
01:27:10,270 --> 01:27:15,680
或者它是为了帮助分发虚拟机本身。

1503
01:27:16,350 --> 01:27:17,970
它纯粹是为了让应用程序，

1504
01:27:18,000 --> 01:27:21,090
比如你有一个在一台机器上运行的业务应用程序，

1505
01:27:21,510 --> 01:27:23,010
你想让它具有更强的容错性，

1506
01:27:23,500 --> 01:27:27,040
而这一方案的作用是，

1507
01:27:27,040 --> 01:27:29,260
它透明地为你提供容错功能，

1508
01:27:30,140 --> 01:27:34,790
你在 FT 虚拟机管理程序上运行业务应用程序和虚拟机，

1509
01:27:34,940 --> 01:27:37,130
FT 管理程序将确保，

1510
01:27:37,130 --> 01:27:41,060
这些应用程序不是按字面意思同步运行，

1511
01:27:41,090 --> 01:27:45,680
基本上是容错复制的。

1512
01:27:46,820 --> 01:27:49,850
所以，使用虚拟机本身在某种程度上是一个设计决策。

1513
01:27:49,970 --> 01:27:53,270
是的，这是一个很好的设计决策，

1514
01:27:53,270 --> 01:27:56,900
因为它允许你在透明级别执行复制。

1515
01:27:57,650 --> 01:27:58,580
明白了，非常感谢。

1516
01:27:59,200 --> 01:27:59,680
不客气。

1517
01:28:02,730 --> 01:28:04,110
是的，聊天中的问题，

1518
01:28:04,110 --> 01:28:06,630
关于输出规则，

1519
01:28:06,630 --> 01:28:08,850
客户端是否可能看到相同的响应两次。

1520
01:28:08,850 --> 01:28:09,720
答案是肯定的，

1521
01:28:10,600 --> 01:28:11,770
这是可能的，

1522
01:28:11,770 --> 01:28:15,310
客户端完全有可能收到两次回复，

1523
01:28:15,310 --> 01:28:18,670
他们说是可以的，

1524
01:28:18,820 --> 01:28:21,640
因为在网络的容错模型中，

1525
01:28:21,670 --> 01:28:25,420
总是假设网络可能重复消息，

1526
01:28:25,840 --> 01:28:30,520
所以，像 TCP 这样的协议完全是为处理重复消息而设计的。

1527
01:28:32,180 --> 01:28:34,640
所以，是的，因为 TCP ，

1528
01:28:35,430 --> 01:28:39,270
或任何复制方案，

1529
01:28:39,270 --> 01:28:41,430
应用程序使用，客户端使用的。

1530
01:28:42,950 --> 01:28:45,410
我对[]问题很好奇，

1531
01:28:45,440 --> 01:28:50,030
比如主机停机了几分钟，

1532
01:28:50,600 --> 01:28:52,310
备机开始运行，

1533
01:28:52,340 --> 01:28:56,330
然后建立自己的备机，

1534
01:28:56,630 --> 01:29:01,510
把标志位换回 0 ，

1535
01:29:01,810 --> 01:29:07,710
然后突然第一个主机又回来了，

1536
01:29:07,710 --> 01:29:08,610
比如，回来。

1537
01:29:08,610 --> 01:29:10,290
是的，我想我们会有这种情况，

1538
01:29:10,290 --> 01:29:12,060
第一个主机肯定会被终止，

1539
01:29:12,060 --> 01:29:14,790
它被清理干净，然后就消失了。

1540
01:29:15,410 --> 01:29:19,310
嗯，好的，谢谢。

1541
01:29:21,860 --> 01:29:24,230
问一个类似的问题，

1542
01:29:24,230 --> 01:29:25,430
可能是个过于宽泛的问题，

1543
01:29:25,430 --> 01:29:28,700
你是否需要保存更多东西，

1544
01:29:28,700 --> 01:29:32,000
除了仲裁标志和服务器之外，

1545
01:29:32,000 --> 01:29:35,780
我的意思是除了仲裁服务器标志位之外，

1546
01:29:36,560 --> 01:29:40,840
如果你有多个备机。

1547
01:29:41,530 --> 01:29:45,130
是的，这是一个方案[]对于一个备机，

1548
01:29:45,130 --> 01:29:46,240
不会超过一个备机，

1549
01:29:46,240 --> 01:29:47,320
所以如果你有更多的备机，

1550
01:29:47,320 --> 01:29:51,690
我们还有其他问题需要解决，

1551
01:29:51,690 --> 01:29:53,880
事实上，我们将在周二回到这个问题上，

1552
01:29:53,880 --> 01:29:55,680
使用更复杂的协议，

1553
01:29:55,680 --> 01:29:57,570
更干净地处理这些情况。

1554
01:29:58,440 --> 01:30:01,230
好的，这太酷了，谢谢。

1555
01:30:04,100 --> 01:30:06,410
我有一个关于性能的问题，

1556
01:30:07,600 --> 01:30:10,570
所以你能回到那个表格吗？

1557
01:30:10,630 --> 01:30:11,950
好的，我的问题是，

1558
01:30:12,250 --> 01:30:16,000
是不是只在第一个数据包上才能看到延迟，

1559
01:30:16,000 --> 01:30:17,260
在第一个数据包之后，

1560
01:30:17,260 --> 01:30:19,630
它只会流过通道，

1561
01:30:19,630 --> 01:30:23,050
链路上没有额外的延迟，

1562
01:30:23,080 --> 01:30:26,380
所以，带宽应该大致相同，或者不是。

1563
01:30:26,380 --> 01:30:29,770
不是，对于主机接收到的每个数据包，

1564
01:30:29,770 --> 01:30:32,170
数据包必须被转发到备机，

1565
01:30:33,040 --> 01:30:35,470
对于每个响应，备机等待，

1566
01:30:35,500 --> 01:30:36,370
主机必须等待，

1567
01:30:36,370 --> 01:30:38,410
直到满足输出规则，

1568
01:30:38,410 --> 01:30:39,850
然后它就可以发送响应。

1569
01:30:41,850 --> 01:30:46,140
所以在备机上会有一些延迟处理，

1570
01:30:46,230 --> 01:30:49,380
在返回到主机之前。

1571
01:30:49,380 --> 01:30:51,630
是的，他们稍微讨论了一下，

1572
01:30:51,630 --> 01:30:53,370
需要完成的处理是，

1573
01:30:53,370 --> 01:30:57,780
确认在日志通道上数据包的接收。

1574
01:30:58,320 --> 01:31:02,160
他们还谈了一些如何减少延迟，

1575
01:31:02,460 --> 01:31:05,250
以确保这种确认是非常迅速的。

1576
01:31:06,700 --> 01:31:09,310
我明白了，好的，谢谢。

1577
01:31:09,520 --> 01:31:12,610
我有一个关于日志通道的问题，

1578
01:31:12,640 --> 01:31:15,880
所以他们提到他们使用的 UDP ，

1579
01:31:15,910 --> 01:31:18,670
我想这主要是为了性能，

1580
01:31:19,000 --> 01:31:23,860
但是，如果发生一次故障，

1581
01:31:24,360 --> 01:31:26,850
如果单个数据包未被确认，

1582
01:31:27,120 --> 01:31:29,220
然后，它假设备机失败，

1583
01:31:29,490 --> 01:31:31,080
没有任何重播。

1584
01:31:31,290 --> 01:31:35,220
不，不，是的，因为有计时器中断，

1585
01:31:35,690 --> 01:31:39,290
定时器中断大约每 10 毫秒或更长时间触发一次，

1586
01:31:39,680 --> 01:31:42,980
总是有多个数据包，

1587
01:31:43,280 --> 01:31:44,270
发送一个数据包，

1588
01:31:44,270 --> 01:31:47,570
那个数据包不会收到任何心跳，

1589
01:31:47,900 --> 01:31:50,390
然后它会中断几次这样的时间，

1590
01:31:50,390 --> 01:31:51,170
在它放弃之前。

1591
01:31:52,000 --> 01:31:56,910
好的，心跳是从主机开始[]的吗，

1592
01:31:56,910 --> 01:32:00,270
或者它将从系统中的其他地方应用它。

1593
01:32:00,420 --> 01:32:01,920
好的，它们从某种程度上来说来自定时器，

1594
01:32:01,920 --> 01:32:05,340
心跳是间接的作用，

1595
01:32:05,340 --> 01:32:06,750
因为每隔 10 毫秒，

1596
01:32:06,750 --> 01:32:09,720
你会通过日志通道发送一条中断消息。

1597
01:32:12,440 --> 01:32:14,060
我明白了，好的。

1598
01:32:16,020 --> 01:32:17,160
好的，谢谢。

1599
01:32:17,490 --> 01:32:18,120
不用谢。

1600
01:32:21,570 --> 01:32:23,490
我想要跟进这件事，

1601
01:32:23,490 --> 01:32:27,960
我想它说的是要等几秒钟。

1602
01:32:28,450 --> 01:32:30,580
是的，可以等待一段时间，

1603
01:32:30,580 --> 01:32:32,830
他们会做几次心跳，然后等一段时间，

1604
01:32:32,830 --> 01:32:34,690
如果没有一个能通过，

1605
01:32:34,720 --> 01:32:35,530
然后它就会停止。

1606
01:32:36,590 --> 01:32:40,610
好的，几秒钟够多了吧。

1607
01:32:41,180 --> 01:32:42,800
我记不清所有的数字了，

1608
01:32:42,860 --> 01:32:44,480
所以可能是几秒钟，

1609
01:32:44,480 --> 01:32:46,610
我想可能会短一点，但也许不是。

1610
01:32:47,250 --> 01:32:51,390
我想几秒钟左右的东西，

1611
01:32:51,390 --> 01:32:53,480
但它是坏的吗？

1612
01:32:53,510 --> 01:32:55,880
复制的时间要更长，

1613
01:32:56,870 --> 01:32:59,660
但我记不起来了。

