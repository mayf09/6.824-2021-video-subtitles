1
00:00:00,000 --> 00:00:02,190
下午好，傍晚好，晚上好，早上好，

2
00:00:02,190 --> 00:00:05,040
无论你在哪里或者无论你什么时候看。

3
00:00:05,580 --> 00:00:11,310
所以今天我想谈谈 Spanner ，

4
00:00:11,820 --> 00:00:14,220
是一篇 2012 年的论文，

5
00:00:14,220 --> 00:00:17,340
但 Spanner 系统仍在使用中，

6
00:00:17,340 --> 00:00:20,100
而且还在不断地开发中，

7
00:00:20,970 --> 00:00:22,410
所以这是一个真正的系统。

8
00:00:23,130 --> 00:00:26,520
主要主题和为什么 Spanner 很有趣，

9
00:00:26,550 --> 00:00:28,710
是支持[广域]事务，

10
00:00:38,400 --> 00:00:42,510
这是一个非常强大的编程模型，

11
00:00:42,510 --> 00:00:44,550
所以即使数据，

12
00:00:44,820 --> 00:00:47,790
数据可能分片在多个服务器上，

13
00:00:47,790 --> 00:00:49,740
服务器位于不同的数据中心，

14
00:00:49,740 --> 00:00:52,590
在地球上的不同地方，

15
00:00:52,950 --> 00:00:54,990
你可以运行事务，

16
00:00:54,990 --> 00:00:58,560
它们有 ACID 语义，

17
00:00:58,560 --> 00:01:00,570
以及失败的原子性，

18
00:01:00,570 --> 00:01:02,130
所有的写入都发生，或者一个也没有，

19
00:01:02,430 --> 00:01:04,650
并且它们提供了可串行化。

20
00:01:05,230 --> 00:01:09,790
所以这是一个非常强大的编程抽象，

21
00:01:10,060 --> 00:01:13,690
当然，挑战在于如何有效地实施它，

22
00:01:13,750 --> 00:01:16,510
其中一个很大的挑战是，

23
00:01:16,510 --> 00:01:18,550
物理定律光速，

24
00:01:18,550 --> 00:01:20,200
从一端发送一个包，

25
00:01:20,890 --> 00:01:22,810
在美国的一个地方到美国的另一个地方，

26
00:01:22,810 --> 00:01:24,040
或者去另一个大陆，

27
00:01:24,160 --> 00:01:25,210
这需要很长时间，

28
00:01:25,420 --> 00:01:28,000
我们谈论的是几十毫秒。

29
00:01:28,870 --> 00:01:32,080
所以，我们在这篇论文中看到的是，

30
00:01:32,080 --> 00:01:36,280
读写事务确实是相当昂贵的，

31
00:01:36,520 --> 00:01:42,940
但他们非常努力地让只读事务变得非常便宜。

32
00:01:43,780 --> 00:01:52,690
读写事务由两阶段提交实现，

33
00:01:53,810 --> 00:01:55,580
正如我们上周所谈到的，

34
00:01:55,580 --> 00:01:56,900
以及两阶段锁，

35
00:01:57,260 --> 00:02:01,130
其中有趣的一件事是，

36
00:02:01,460 --> 00:02:05,600
这个协议的参与者都是 Paxos 组。

37
00:02:11,400 --> 00:02:17,590
只读事务可以在任何数据中心执行，

38
00:02:19,570 --> 00:02:21,070
它们会运行得很快，

39
00:02:21,070 --> 00:02:24,370
事实上，你可以看看论文后面的表六，

40
00:02:24,490 --> 00:02:26,320
你将看到只读事务

41
00:02:26,320 --> 00:02:29,050
大约比读写事务快十倍。

42
00:02:29,630 --> 00:02:31,430
这里有两个关键的想法，

43
00:02:31,550 --> 00:02:33,110
我们将在这节课上讨论，

44
00:02:33,110 --> 00:02:36,470
一个是快照隔离，

45
00:02:36,950 --> 00:02:39,440
这是一个标准的数据库概念，

46
00:02:39,440 --> 00:02:43,430
但在这里使用它为了让读取更快，

47
00:02:43,430 --> 00:02:46,340
特别是，让它运行良好，

48
00:02:46,370 --> 00:02:48,290
在分布式广域环境中，

49
00:02:48,380 --> 00:02:51,530
它们依赖同步时钟，

50
00:02:54,300 --> 00:02:56,460
那些时钟是完全同步的，

51
00:02:56,970 --> 00:03:00,570
所以，他们的事务方案必须处理

52
00:03:00,570 --> 00:03:05,280
一点[]或漂移或错误容限，

53
00:03:05,310 --> 00:03:08,310
知道 TrueTime 是什么。

54
00:03:09,590 --> 00:03:11,300
正如我所说的被广泛使用，

55
00:03:14,460 --> 00:03:16,290
无论是在 Google 内部，

56
00:03:16,380 --> 00:03:20,280
但作为 Google 的客户，你也可以使用它，

57
00:03:20,280 --> 00:03:21,930
Spanner 是一项云服务，

58
00:03:21,930 --> 00:03:24,600
你可以作为 Google 客户使用，

59
00:03:24,600 --> 00:03:26,850
如果你使用 Gmail ，

60
00:03:26,850 --> 00:03:30,780
很可能你的电子邮件或部分电子邮件系统是通过 Spanner 的。

61
00:03:32,520 --> 00:03:36,510
也许在深入讨论更多细节之前，

62
00:03:36,840 --> 00:03:39,690
我想做一个逻辑上的解释，

63
00:03:39,720 --> 00:03:41,580
与 Spanner 无关，

64
00:03:41,760 --> 00:03:44,550
正如你可能已经看到的，

65
00:03:44,580 --> 00:03:49,950
我们对即将到来的长周末做了一些调整，

66
00:03:50,220 --> 00:03:56,010
首先，实验 4a 的工作量不像其他实验那么重，

67
00:03:56,010 --> 00:03:57,810
希望能少花点时间，

68
00:03:58,050 --> 00:04:00,180
我们还取消了下周的课程，

69
00:04:00,180 --> 00:04:04,620
这样你就可以把它当做 4a 的工作时间，

70
00:04:04,860 --> 00:04:07,950
我们把 4a 的最后期限改得更灵活了，

71
00:04:07,980 --> 00:04:10,380
所以下个星期五对你来说很方便，

72
00:04:10,620 --> 00:04:14,040
你可以选择晚些时候

73
00:04:14,130 --> 00:04:15,840
晚点提交它，

74
00:04:16,870 --> 00:04:21,130
希望这能让你享受这个长周末，

75
00:04:21,130 --> 00:04:23,080
也许可以睡一觉，

76
00:04:23,080 --> 00:04:28,060
或者做些别的事情，而不是调试你的实验。

77
00:04:29,100 --> 00:04:32,580
我想说的第二点是与 Spanner 直接相关的，

78
00:04:32,730 --> 00:04:34,950
你们中的一些人注意到了这一点，

79
00:04:34,950 --> 00:04:37,650
并通过提问，

80
00:04:37,830 --> 00:04:39,870
这篇论文很复杂，

81
00:04:40,530 --> 00:04:43,020
它之所以复杂，原因有很多，

82
00:04:43,020 --> 00:04:44,460
但其中一个原因是，

83
00:04:44,460 --> 00:04:46,500
有很多事情正在发生，

84
00:04:47,370 --> 00:04:48,600
这是一个强大的系统，

85
00:04:48,600 --> 00:04:50,310
有很多不同的组件，

86
00:04:50,550 --> 00:04:54,630
不同组件之间的相互作用很重要，

87
00:04:54,990 --> 00:04:59,130
这篇论文中有很多材料，

88
00:04:59,130 --> 00:05:01,650
尽管我会在这节课中努力做到，

89
00:05:01,650 --> 00:05:03,000
试图说的更清楚，

90
00:05:03,210 --> 00:05:05,910
通过关注这篇论文的几个方面，

91
00:05:05,910 --> 00:05:08,970
我不打算对这篇论文做一个全面的处理，

92
00:05:09,210 --> 00:05:12,840
但是当然我认为最重要的想法，

93
00:05:12,840 --> 00:05:14,970
以及为什么我们会在 6.824 阅读它，

94
00:05:15,830 --> 00:05:19,340
这花了我一些时间，

95
00:05:19,340 --> 00:05:23,870
或者几年的时间来弄清楚如何展示这篇论文，

96
00:05:23,870 --> 00:05:28,550
或者用一种我认为更容易理解的方式来解释，

97
00:05:28,550 --> 00:05:31,700
如果对于 6.824 的概念。

98
00:05:32,210 --> 00:05:34,370
好的，但还是像往常一样问问题。

99
00:05:36,650 --> 00:05:42,410
好的，让我们深入讨论一下高层组织架构。

100
00:05:49,430 --> 00:05:51,620
从更多的角度来看，

101
00:05:51,620 --> 00:05:55,520
从我想在这节课中谈论 Spanner 的方式来看。

102
00:05:56,240 --> 00:05:57,470
所以，有多个数据中心，

103
00:05:57,470 --> 00:06:01,130
为了方便起见，

104
00:06:01,130 --> 00:06:05,510
只考虑三个数据中心， A B 和 C ，

105
00:06:08,900 --> 00:06:10,670
它可以在世界的任何地方，

106
00:06:12,480 --> 00:06:14,610
目标是，

107
00:06:14,610 --> 00:06:16,440
数据会是，

108
00:06:16,440 --> 00:06:19,020
我们数据在分片中，

109
00:06:19,020 --> 00:06:23,790
包含一些数据库行或一些键值对，

110
00:06:24,350 --> 00:06:26,270
在分片中，

111
00:06:26,840 --> 00:06:29,630
也许它有键 a 到 m ，

112
00:06:31,080 --> 00:06:34,830
基本的想法是在数据中心之间复制这个分片，

113
00:06:37,440 --> 00:06:41,100
目标是即使整个数据中心出现故障，

114
00:06:41,890 --> 00:06:44,350
我们可以继续，

115
00:06:44,350 --> 00:06:46,060
我们安排的方式，

116
00:06:46,060 --> 00:06:47,740
我们将能够继续进行的是，

117
00:06:47,890 --> 00:06:51,160
这些分片将形成，

118
00:06:52,380 --> 00:06:56,730
这些复制位于不同数据中心将组成一个 Paxos 组，

119
00:07:03,520 --> 00:07:04,960
所以如果你考虑这个，

120
00:07:04,960 --> 00:07:07,690
我们试着从实验 3 的角度来考虑，

121
00:07:07,840 --> 00:07:09,250
然后你可以考虑，

122
00:07:09,250 --> 00:07:11,020
我们有一个键值存储，

123
00:07:11,140 --> 00:07:15,370
键值服务器分布在不同的数据中心，

124
00:07:15,610 --> 00:07:18,490
键被更新，

125
00:07:18,490 --> 00:07:23,440
[]Raft写入，通过 Raft 日志，

126
00:07:23,590 --> 00:07:26,590
然后我们到不同的 kv ，

127
00:07:26,680 --> 00:07:27,880
更新它们的状态，

128
00:07:28,750 --> 00:07:31,660
所以你可以想象实验 3 在这里，

129
00:07:31,660 --> 00:07:35,080
不是在你的机器上运行 3 台 kv 服务器，

130
00:07:35,080 --> 00:07:39,580
你将在不同的数据中心运行 kv 服务器。

131
00:07:42,080 --> 00:07:43,670
好的?

132
00:07:44,170 --> 00:07:48,550
所以，然后每个分片有一个 Paxos 组，

133
00:07:48,550 --> 00:07:51,340
所以，

134
00:07:54,570 --> 00:07:55,800
可能是其他分片，

135
00:07:55,800 --> 00:08:02,320
持有其他部分的键值空间或数据库行，

136
00:08:02,680 --> 00:08:04,810
假设我们只有两个分片，

137
00:08:04,810 --> 00:08:06,280
对于这个数据库，

138
00:08:06,490 --> 00:08:08,680
分片包含 a 到 m ，

139
00:08:08,680 --> 00:08:10,210
然后其他分片包含 n 到 z ，

140
00:08:11,280 --> 00:08:14,280
然后它们组成自己的 Paxos 组。

141
00:08:17,110 --> 00:08:21,550
我们想要获得多个分片的原因是为了获得并行性，

142
00:08:31,110 --> 00:08:35,490
这样如果事务涉及不同的分片，

143
00:08:35,490 --> 00:08:38,310
一组不相连的分片，

144
00:08:38,580 --> 00:08:39,810
它们可以不相交，

145
00:08:39,810 --> 00:08:41,340
可以完全并行地进行。

146
00:08:42,860 --> 00:08:44,120
所以，正如前面提到的，

147
00:08:44,120 --> 00:08:54,120
我们每个分片有 Paxos 组，用于复制，

148
00:08:54,120 --> 00:08:59,160
但是， Paxos 实际上给我们提供了额外的好处，

149
00:08:59,850 --> 00:09:01,620
这个通信成本，

150
00:09:01,620 --> 00:09:04,680
从 a 到 b 或从 b 到 c 的可能非常昂贵，

151
00:09:04,890 --> 00:09:07,770
看起来 Paxos 允许继续，

152
00:09:07,770 --> 00:09:10,230
或者 Raft 允许我们在只有多数的情况下继续，

153
00:09:10,380 --> 00:09:14,370
速度较慢的机器可能不会对性能产生太大影响，

154
00:09:14,730 --> 00:09:18,750
所以我们可以很容易地容忍速度慢的机器，

155
00:09:18,780 --> 00:09:22,110
或者一个数据中心停机，

156
00:09:22,830 --> 00:09:26,970
所以，多数原则在两个方面帮助了我们，

157
00:09:27,700 --> 00:09:31,300
我们有了数据中心容错能力，

158
00:09:35,920 --> 00:09:37,570
并且绕过慢的（机器）。

159
00:09:41,480 --> 00:09:46,700
我们将更详细地看到的最终目标是，

160
00:09:46,940 --> 00:09:51,710
一个 Spanner 的客户端，

161
00:09:51,800 --> 00:09:55,510
假设这里有一些使用 Spanner 的服务器，

162
00:09:55,780 --> 00:09:57,460
希望是这样的，

163
00:09:57,460 --> 00:10:00,430
这台服务器可以使用近距离的 replica ，

164
00:10:01,200 --> 00:10:07,290
所以， replica 通常放的很近，

165
00:10:07,320 --> 00:10:10,170
靠近使用它们的客户端。

166
00:10:11,760 --> 00:10:12,990
事实上，我们将看到，

167
00:10:13,230 --> 00:10:18,150
只读事务可以由本地 replica 执行，

168
00:10:18,300 --> 00:10:21,480
不用与其他数据中心进行任何通信。

169
00:10:22,210 --> 00:10:23,530
当我谈到客户端时，

170
00:10:23,620 --> 00:10:24,280
这里，

171
00:10:24,580 --> 00:10:30,940
这通常是一些 Google 服务的后端服务器，

172
00:10:30,970 --> 00:10:33,670
例如，这可能是 Gmail 服务器，

173
00:10:33,670 --> 00:10:37,360
它也位于某个数据中心，

174
00:10:37,360 --> 00:10:38,920
也许是同一个数据中心，

175
00:10:38,920 --> 00:10:41,260
并与那个数据中心中的 replica 进行通信，

176
00:10:41,710 --> 00:10:43,660
当然，再外面是真正的客户端，

177
00:10:43,660 --> 00:10:47,860
比如读取邮件的用户。

178
00:10:48,860 --> 00:10:53,000
好的，关于这个高层组织架构，有什么问题吗？

179
00:11:01,470 --> 00:11:06,420
好的，让我来列出一些挑战，

180
00:11:06,420 --> 00:11:10,170
我在这节课中想要关注的，

181
00:11:10,820 --> 00:11:14,870
所以，有三个主要挑战。

182
00:11:17,490 --> 00:11:21,360
一是，就像我说的那样，

183
00:11:21,360 --> 00:11:23,340
我们希望只读事务，

184
00:11:23,340 --> 00:11:26,730
不需要与任何其他服务器通信，

185
00:11:26,970 --> 00:11:30,390
但我们要确保读取看到最新的写入，

186
00:11:47,960 --> 00:11:50,930
这种我们以前见过的典型的挑战，

187
00:11:50,930 --> 00:11:52,100
比如 zookeeper ，

188
00:11:52,100 --> 00:11:56,180
zookeeper 并没有真正直接面对挑战，

189
00:11:56,180 --> 00:11:57,890
只是弱一致性，

190
00:11:58,340 --> 00:12:00,470
但在这个设计中，

191
00:12:00,470 --> 00:12:02,030
我们希望以一种方式安排，

192
00:12:02,030 --> 00:12:04,610
它仍然保持线性一致性，

193
00:12:04,610 --> 00:12:09,530
事实上， Spanner 追求的是比线性一致性更强的性质。

194
00:12:10,940 --> 00:12:11,870
第二件事是，

195
00:12:11,960 --> 00:12:13,130
我们希望支持，

196
00:12:13,160 --> 00:12:16,340
Spanner 想要支持跨分片的事务，

197
00:12:21,240 --> 00:12:23,940
所以即使我们执行一个银行转账，

198
00:12:23,940 --> 00:12:26,070
一个账户在一个分片中，

199
00:12:26,070 --> 00:12:28,440
另一个账户，目标帐户，在另一个分片中，

200
00:12:28,650 --> 00:12:29,610
我们想安排它，

201
00:12:29,610 --> 00:12:35,670
它仍然可以像事务一样执行，并且具有 ACID 语义。

202
00:12:36,960 --> 00:12:43,470
最后，只读和读写的事务都必须是串行化的，

203
00:12:45,420 --> 00:12:47,820
事实上，比可串行化的要强一点。

204
00:12:53,150 --> 00:12:56,060
我们会看到，

205
00:12:56,210 --> 00:13:00,920
对于读写事务，

206
00:13:00,920 --> 00:13:03,110
我们将使用两阶段锁，两阶段提交，

207
00:13:03,470 --> 00:13:09,350
我们在上一节课中谈到的两个协议。

208
00:13:10,300 --> 00:13:14,920
所以我首先想做的是谈谈读写事务，

209
00:13:15,190 --> 00:13:20,650
然后更详细地讨论只读事务如何执行，

210
00:13:20,650 --> 00:13:24,190
它们可以非常高效地运行。

211
00:13:27,370 --> 00:13:29,020
好的，所以读写事务是

212
00:13:29,020 --> 00:13:32,080
两阶段锁和两阶段提交。

213
00:13:33,300 --> 00:13:37,260
所以希望这很容易理解，

214
00:13:42,650 --> 00:13:45,650
这将涉及到这些复杂的时序图，

215
00:13:45,650 --> 00:13:48,350
我们在上周看到的。

216
00:13:49,070 --> 00:13:51,710
所以它的设置方式，

217
00:13:51,860 --> 00:13:53,870
我要简化一下，

218
00:13:53,900 --> 00:13:56,900
看看在 Spanner 中的设置方式，

219
00:13:56,990 --> 00:13:58,850
我们有客户端，

220
00:13:59,450 --> 00:14:02,690
客户端在某种程度上负责运行事务，

221
00:14:02,870 --> 00:14:06,290
使用事务 manager ，事务库，

222
00:14:06,620 --> 00:14:09,920
运行在客户端机器上，

223
00:14:10,550 --> 00:14:15,870
负责安排这个事务，

224
00:14:15,930 --> 00:14:20,100
再次，这里的客户端不是用户 Web 浏览器或 Gmail ，

225
00:14:20,100 --> 00:14:25,080
而是数据中心的 Gmail 服务器，

226
00:14:25,200 --> 00:14:26,850
这是 Spanner 的客户端。

227
00:14:28,100 --> 00:14:30,350
所以让我们把这图简单一点，

228
00:14:30,380 --> 00:14:34,040
所以我们有两个分片而不是三、五个，

229
00:14:34,310 --> 00:14:36,980
所以我们有分片 A 和分片 B 。

230
00:14:38,000 --> 00:14:42,890
假设我们执行转账事务，

231
00:14:42,890 --> 00:14:43,880
和前面一样，

232
00:14:43,880 --> 00:14:45,980
我们要从一个账户中减去一些钱，

233
00:14:45,980 --> 00:14:47,270
然后把它加到另一个账户上。

234
00:14:48,690 --> 00:14:51,510
首先，我在没有时间戳的情况下讨论这个问题，

235
00:14:57,690 --> 00:15:00,750
在某些方面，这么做的一个原因是，

236
00:15:00,750 --> 00:15:04,050
对于读写事务，时间戳并不是很重要，

237
00:15:04,560 --> 00:15:07,740
时间戳主要用于只读事务，

238
00:15:07,890 --> 00:15:10,740
它们需要对读写事务进行一些调整

239
00:15:10,740 --> 00:15:13,230
去支持只读事务，

240
00:15:13,230 --> 00:15:19,560
所以，时间戳在某种程度上也能漂移到读写事务，

241
00:15:19,590 --> 00:15:22,440
但在本质上，读写事务是

242
00:15:22,440 --> 00:15:25,350
直接的两阶段锁和两阶段提交。

243
00:15:26,610 --> 00:15:28,740
所以，客户端将读取这些帐户，

244
00:15:28,740 --> 00:15:32,370
假设读取 x ，

245
00:15:33,220 --> 00:15:35,650
所以我们只需要做转账事务，

246
00:15:35,650 --> 00:15:38,740
转移钱，把 1 加到 x ，

247
00:15:38,740 --> 00:15:42,580
x 中减去 1 美元，

248
00:15:42,580 --> 00:15:44,470
y 中加入 1 美元，

249
00:15:44,920 --> 00:15:45,910
它将是 x ，

250
00:15:45,910 --> 00:15:48,190
我们假设 x 位于一个分片中，

251
00:15:48,460 --> 00:15:51,040
所以，这将是一个跨分片事务，

252
00:15:51,400 --> 00:15:55,270
你必须读取 y ，

253
00:15:55,770 --> 00:16:00,600
将会有，

254
00:16:00,630 --> 00:16:04,770
当客户端执行这些读取操作时，

255
00:16:04,770 --> 00:16:09,060
它们去分片，而分片保持着锁表，

256
00:16:10,090 --> 00:16:12,820
所以它们记录了这个事务，

257
00:16:12,850 --> 00:16:15,790
我们假设这个事务 TID ，

258
00:16:16,620 --> 00:16:21,180
它们会记录下来， x 被拥有，

259
00:16:22,050 --> 00:16:24,420
锁表实际上由客户端拥有，

260
00:16:24,420 --> 00:16:27,390
y 由客户端拥有，

261
00:16:28,110 --> 00:16:31,890
这是一种我们之前见过的标准。

262
00:16:32,630 --> 00:16:35,480
这里略有不同，

263
00:16:35,480 --> 00:16:38,990
在这里没有完全画出来的是，

264
00:16:39,200 --> 00:16:41,240
当我们说分片 A 时，

265
00:16:41,300 --> 00:16:44,360
分片 A 是这些 Paxos 组的一个，

266
00:16:44,800 --> 00:16:47,830
所以，它有三个，

267
00:16:48,100 --> 00:16:51,640
在这种情况下，一个三节点的组，

268
00:16:51,970 --> 00:16:58,450
所以， SA 是一个复制服务器，包含多个节点，

269
00:16:58,900 --> 00:17:01,390
在执行只读事务时，

270
00:17:01,540 --> 00:17:03,880
我们要访问那些节点的领导者，

271
00:17:03,880 --> 00:17:05,440
所以，如果你从 Raft 的角度考虑，

272
00:17:05,440 --> 00:17:06,370
你可以想一想，

273
00:17:06,610 --> 00:17:12,850
读请求到达 Paxos 组的领导者。

274
00:17:13,760 --> 00:17:16,070
还有另一个，

275
00:17:16,100 --> 00:17:22,040
所以每次我在这里为 SA 或 SB 画一个箭头，

276
00:17:22,100 --> 00:17:25,250
这是一个复杂得多的故事，

277
00:17:25,250 --> 00:17:26,660
尤其是当涉及到写入时，

278
00:17:26,810 --> 00:17:30,200
因为写入要经过 Paxos 或 Raft 组。

279
00:17:33,100 --> 00:17:37,180
只读或锁表不是复制的，

280
00:17:37,270 --> 00:17:42,610
它存储在 Paxos 组的领导者处，

281
00:17:43,090 --> 00:17:46,090
如果领导者在事务过程中停机，

282
00:17:46,330 --> 00:17:50,170
那么事务必须重新开始，

283
00:17:50,170 --> 00:17:51,730
事务将被中止，

284
00:17:51,910 --> 00:17:54,160
因为锁信息丢失了。

285
00:17:55,320 --> 00:18:03,620
这些锁表不是复制的原因，

286
00:18:03,620 --> 00:18:05,000
这使读操作很快。

287
00:18:05,840 --> 00:18:13,320
好的，一旦客户端得到了 x 和 y 的值，

288
00:18:13,320 --> 00:18:16,710
它去掉锁，使用两阶段锁的风格，

289
00:18:16,890 --> 00:18:24,000
它将从 x 减去 1 ， y 加上 1 ，

290
00:18:24,240 --> 00:18:26,640
然后提交这个事务。

291
00:18:27,430 --> 00:18:30,670
所以，所有写入都在客户端本地完成，

292
00:18:30,670 --> 00:18:33,700
同样，这是 Gmail 服务器，

293
00:18:33,700 --> 00:18:35,590
一件[]事是，

294
00:18:35,590 --> 00:18:37,990
当客户端完成事务时，

295
00:18:37,990 --> 00:18:41,590
它将事务提交给 Spanner ，

296
00:18:42,320 --> 00:18:46,340
它提交给事务协调者，

297
00:18:48,600 --> 00:18:53,190
所以，一些服务器或一些机器，

298
00:18:53,190 --> 00:18:55,170
你选择作为事务协调者，

299
00:18:55,380 --> 00:18:58,110
同样，事务协调者也是 Paxos 组，

300
00:18:58,560 --> 00:19:02,970
如我所说，它是在不同数据中心的多个节点。

301
00:19:03,890 --> 00:19:07,760
我们希望这是一个 Paxos 组的一个原因是，

302
00:19:07,760 --> 00:19:10,190
正如我们之前看到的，

303
00:19:10,190 --> 00:19:12,680
在两阶段协议或两阶段提交中，

304
00:19:12,830 --> 00:19:15,290
如果协调者失败了，

305
00:19:15,560 --> 00:19:19,130
它可能会阻止参与者，

306
00:19:19,130 --> 00:19:23,030
如果参与者已经准备好并同意进行事务，

307
00:19:23,240 --> 00:19:24,560
但如果协调者失败了，

308
00:19:24,560 --> 00:19:27,110
这些参与者必须持有它们的锁，

309
00:19:27,290 --> 00:19:30,740
必须等到协调者回来，

310
00:19:30,800 --> 00:19:33,920
通过使用 Paxos 复制协调者，

311
00:19:34,130 --> 00:19:37,160
我们使协调者高可用，

312
00:19:37,160 --> 00:19:42,050
从而避免那种灾难情景。

313
00:19:43,340 --> 00:19:43,880
好的?

314
00:19:44,420 --> 00:19:46,190
所以，事务协调者，

315
00:19:46,190 --> 00:19:49,250
负责运行两阶段提交协议，

316
00:19:49,550 --> 00:19:57,580
它将发送 x 和 y 的更新到分片 A 的领导者，

317
00:19:57,670 --> 00:20:01,420
（发送） x y 到分片 B 的领导者，

318
00:20:03,390 --> 00:20:05,370
它们获取锁，

319
00:20:05,370 --> 00:20:06,360
在这种情况下，

320
00:20:06,360 --> 00:20:09,120
它们已经持有锁，

321
00:20:09,120 --> 00:20:11,730
或升级为读写锁，

322
00:20:12,150 --> 00:20:15,900
准备事务，

323
00:20:15,900 --> 00:20:17,340
所以它们还没有执行它，

324
00:20:17,340 --> 00:20:21,540
只是，通常使用预写式日志，

325
00:20:21,540 --> 00:20:23,400
准备修改，

326
00:20:23,730 --> 00:20:25,320
如果一切都好的话，

327
00:20:25,380 --> 00:20:29,400
然后，它们提交事务，

328
00:20:29,400 --> 00:20:32,280
通过进入这种准备状态，

329
00:20:35,460 --> 00:20:36,960
这是一个重要的时刻，

330
00:20:37,750 --> 00:20:39,220
因为在这一点上，

331
00:20:39,430 --> 00:20:41,380
事务出现，

332
00:20:41,380 --> 00:20:44,590
当参与者提交给这个事务时，

333
00:20:44,590 --> 00:20:46,390
我们从上节课中知道，

334
00:20:46,390 --> 00:20:49,510
参与者必须记录状态，

335
00:20:49,660 --> 00:20:51,910
如果它们失败了，它们又回来，

336
00:20:51,910 --> 00:20:54,940
它们可以恢复从它们停止的地方重新开始，

337
00:20:55,420 --> 00:20:57,700
所以，在准备状态下，

338
00:20:57,700 --> 00:21:00,310
这会导致 Paxos 写入，

339
00:21:04,370 --> 00:21:13,220
记录事务状态和 2PC 状态，

340
00:21:13,220 --> 00:21:18,470
以及参与者持有的日志，等等，

341
00:21:18,500 --> 00:21:20,690
所以这个 Paxos 写入，

342
00:21:20,960 --> 00:21:23,030
所以这个分片的领导者，

343
00:21:23,030 --> 00:21:28,070
有一个推 Paxos 写入到组中的不同节点，

344
00:21:28,280 --> 00:21:31,760
以确保状态复制，具有容错能力，

345
00:21:33,480 --> 00:21:40,380
所以一旦参与者准备好，同意准备好，

346
00:21:40,650 --> 00:21:42,810
然后它们发回 ok ，

347
00:21:42,840 --> 00:21:48,860
ok 跟我们之前讨论的两阶段协议很像，

348
00:21:49,190 --> 00:21:52,340
在这一点上，协调者可以提交，

349
00:21:55,180 --> 00:21:56,770
当然，要提交的点，

350
00:21:56,920 --> 00:22:00,520
具有一些记录的协调者做出提交的决定，

351
00:22:00,550 --> 00:22:02,830
因为参与者可能晚些时候回来，

352
00:22:02,830 --> 00:22:04,420
知道并发现这一点，

353
00:22:04,420 --> 00:22:05,770
我们可能会失败，

354
00:22:06,220 --> 00:22:10,570
所以， Paxos 状态或两阶段提交状态

355
00:22:10,690 --> 00:22:17,470
写入使用 Paxos ，复制使用 Paxos 。

356
00:22:18,790 --> 00:22:21,130
从整个介绍来看，

357
00:22:21,130 --> 00:22:22,510
你可以把 Paxos 看作是

358
00:22:22,510 --> 00:22:25,330
Raft 的完全替代品或等价物，

359
00:22:25,360 --> 00:22:29,770
Spanner 在 Raft 之前，

360
00:22:29,770 --> 00:22:33,640
但是从感觉上，[]，

361
00:22:33,640 --> 00:22:35,470
对于这篇论文来说，基本上是一样的。

362
00:22:38,150 --> 00:22:40,070
所以这一点提交，

363
00:22:40,070 --> 00:22:41,750
这个是提交，

364
00:22:42,080 --> 00:22:47,600
一旦事务协调器写下事务已提交，

365
00:22:47,900 --> 00:22:50,330
这就是提交点，

366
00:22:50,330 --> 00:22:52,520
然后通知它们的参与者，

367
00:22:52,520 --> 00:22:56,230
这发生了，

368
00:22:58,650 --> 00:23:02,610
它们将回复 ok ，事务已经提交，

369
00:23:02,610 --> 00:23:04,890
事务协调器可以清理它的状态，

370
00:23:05,220 --> 00:23:10,080
在之后的某个时刻，分片也可以清理它们的状态，

371
00:23:10,290 --> 00:23:14,760
在提交时，参与者释放它们的锁。

372
00:23:25,860 --> 00:23:30,900
好的，这是读写事务的基本情况，

373
00:23:30,990 --> 00:23:33,270
对此有什么问题吗？

374
00:23:34,250 --> 00:23:36,500
我认为简单的思考方式是，

375
00:23:36,530 --> 00:23:39,080
这是两阶段提交，两阶段锁，

376
00:23:39,350 --> 00:23:42,710
与我们上周谈到的主要区别，

377
00:23:42,710 --> 00:23:44,330
这周的是，

378
00:23:44,510 --> 00:23:50,570
事务协调者，参与者都是 Paxos 组，参与者都是帕克索斯团体，

379
00:23:50,570 --> 00:23:52,640
它们复制高可用，

380
00:23:52,730 --> 00:23:57,080
上次我们谈到的两阶段提交的一些问题

381
00:23:57,080 --> 00:23:59,420
在这里不太相关，

382
00:23:59,420 --> 00:24:02,540
因为参与者的可用性要高得多。

383
00:24:04,420 --> 00:24:09,550
所以，每个分片是否都复制了锁表？

384
00:24:10,410 --> 00:24:12,690
是的，好的，它不是在复制锁表，

385
00:24:12,690 --> 00:24:15,840
它复制准备好后持有的锁。

386
00:24:17,000 --> 00:24:19,430
所以只有当它持有锁时。

387
00:24:20,360 --> 00:24:22,760
是的，它需要执行两阶段提交时。

388
00:24:25,870 --> 00:24:30,700
所以，如果当前一些事务的锁

389
00:24:30,700 --> 00:24:33,680
没有达到准备阶段，

390
00:24:33,710 --> 00:24:35,960
它们会丢失吗？

391
00:24:36,390 --> 00:24:38,550
它们会丢失，然后事务中止，

392
00:24:38,580 --> 00:24:40,350
参与者不参与，

393
00:24:41,710 --> 00:24:44,980
告诉协调者，我的锁丢失了，不能这么做。

394
00:24:47,100 --> 00:24:48,060
谢谢。

395
00:24:50,230 --> 00:24:54,820
好的，这节课剩下的部分是关于只读事务的，

396
00:24:55,350 --> 00:25:07,710
这些事务只进行读而不进行写，

397
00:25:09,360 --> 00:25:10,980
它们是很常见的，

398
00:25:11,220 --> 00:25:14,460
所以，其中一个目标是让它们变得非常快。

399
00:25:18,560 --> 00:25:24,890
他们实现高性能的方式是

400
00:25:24,920 --> 00:25:26,270
它们安排读取，

401
00:25:26,720 --> 00:25:27,950
Spanner 的性能很高，

402
00:25:27,950 --> 00:25:30,830
因为读取只对本地分片，

403
00:25:38,040 --> 00:25:40,800
而且它们没有锁，

404
00:25:43,040 --> 00:25:44,030
没有锁是好的，

405
00:25:44,030 --> 00:25:47,750
因为这意味着读写事务可以阻塞读写事务，

406
00:25:47,750 --> 00:25:51,710
或者另一种说法是，只读事务不会阻塞读写事务，

407
00:25:52,370 --> 00:25:55,610
并且没有两阶段提交，

408
00:25:56,900 --> 00:25:59,630
所以，这也意味着不需要广域通信，

409
00:25:59,750 --> 00:26:03,830
所以，读取操作可以从本地 replica 执行。

410
00:26:05,320 --> 00:26:07,330
当然，也会看到，

411
00:26:07,330 --> 00:26:09,550
这是从本地分片读取的数据，

412
00:26:09,550 --> 00:26:12,040
这里真正的挑战是，

413
00:26:12,040 --> 00:26:17,190
如何仍然获得一致性或者串行化，

414
00:26:18,010 --> 00:26:20,410
但重要的是要指出，

415
00:26:20,440 --> 00:26:22,570
但有一段时间假设，

416
00:26:22,570 --> 00:26:23,830
我们知道怎么做，

417
00:26:23,830 --> 00:26:24,760
你知道我们可以，

418
00:26:25,150 --> 00:26:31,270
仅从本地分片读取，不持有锁，不执行两阶段提交，

419
00:26:31,270 --> 00:26:33,070
意味着所有通信都是本地的

420
00:26:33,070 --> 00:26:35,590
在一个数据中心内，

421
00:26:35,980 --> 00:26:38,230
而且它可以非常快，

422
00:26:38,230 --> 00:26:43,090
如果你看一下论文中表 3 和表 6 ，

423
00:26:45,260 --> 00:26:46,940
你可以看到，

424
00:26:46,970 --> 00:26:49,940
基本上只读事务

425
00:26:52,070 --> 00:26:56,200
比读写事务快十倍，

426
00:26:56,350 --> 00:26:59,170
读写事务在数百毫秒的量级，

427
00:26:59,290 --> 00:27:00,310
这在某种程度上说得通，

428
00:27:00,310 --> 00:27:03,610
因为它们要远距离通信，

429
00:27:03,850 --> 00:27:10,150
但是只读事务在 5 到 10 毫秒的数量级。

430
00:27:12,940 --> 00:27:15,790
好的，所以关键的挑战当然是，

431
00:27:15,820 --> 00:27:19,570
我们执行本地副本，如何获得正确性。

432
00:27:21,240 --> 00:27:22,590
所以让我稍微谈谈，

433
00:27:22,590 --> 00:27:26,640
因为它与我们以前看到的略有不同，

434
00:27:26,790 --> 00:27:28,920
所以，正确性在这里意味着两件事，

435
00:27:28,920 --> 00:27:31,140
一个是，事务是可串行化的，

436
00:27:32,860 --> 00:27:35,320
所以它们必须按某种顺序执行，

437
00:27:35,500 --> 00:27:36,550
所以如果你仔细想想，

438
00:27:36,550 --> 00:27:38,080
我们有一个读写事务，

439
00:27:39,220 --> 00:27:42,130
我们有另一个读写事务，

440
00:27:42,550 --> 00:27:44,350
然后我们有一个只读事务，

441
00:27:44,590 --> 00:27:45,790
只读事务必须

442
00:27:45,790 --> 00:27:48,610
介于两个读写事务之间，

443
00:27:48,850 --> 00:27:51,280
只读事务不应该观察到

444
00:27:51,370 --> 00:27:55,180
读写事务的某些部分，

445
00:27:55,180 --> 00:27:58,030
所以读写事务进行多次写入，像第一次那样，

446
00:27:58,800 --> 00:28:02,100
然后，只读事务看到所有这些写入或没有一个，

447
00:28:03,190 --> 00:28:05,560
与[]的那个类似。

448
00:28:05,800 --> 00:28:06,490
好的?

449
00:28:06,940 --> 00:28:08,260
第二，

450
00:28:08,260 --> 00:28:12,100
这是我们上周谈到的标准问题，可串行化，

451
00:28:12,100 --> 00:28:14,440
然后他们会选择更强的东西吗，

452
00:28:14,950 --> 00:28:17,110
他们所说的外部一致性，

453
00:28:24,900 --> 00:28:26,970
外部一致性意味着，

454
00:28:26,970 --> 00:28:34,450
如果事务 2 在事务 1 提交之后开始，

455
00:28:35,820 --> 00:28:43,730
那么 T2 必须看到 T1 的写入。

456
00:28:48,250 --> 00:28:50,470
所以，我们回到之前的这张图片，

457
00:28:50,470 --> 00:28:52,210
如果只读事务，

458
00:28:52,630 --> 00:28:57,190
这个在第一个事务提交之后开始，

459
00:28:57,310 --> 00:29:04,000
那么这个只读事务必须看到事务 T1 的写入，

460
00:29:05,080 --> 00:29:10,000
所以想法是，如果你想想这个，

461
00:29:10,030 --> 00:29:12,970
这种外部一致性意味着

462
00:29:12,970 --> 00:29:15,880
可串行化加上这种实时需求，

463
00:29:16,270 --> 00:29:20,170
事实上，它与线性一致性非常相似，

464
00:29:28,560 --> 00:29:32,760
除了一种方式

465
00:29:32,760 --> 00:29:38,340
用于对比事务的外部一致性和线性一致性的是，

466
00:29:38,340 --> 00:29:41,100
外部一致性是事务级别的属性，

467
00:29:41,400 --> 00:29:44,370
到目前为止，我们谈论线性一致性的方式，

468
00:29:44,490 --> 00:29:47,010
总是单独的读写，

469
00:29:47,410 --> 00:29:51,100
但对于第一[层次]来说，

470
00:29:51,100 --> 00:29:53,410
我认为你应该以完全相同的方式思考。

471
00:29:54,340 --> 00:29:56,440
和线性一致性一样，

472
00:29:56,440 --> 00:29:58,630
外部一致性对于程序员来说也是令人愉快的，

473
00:29:59,290 --> 00:30:04,240
是非常强的一致性。

474
00:30:06,200 --> 00:30:06,950
好的，有什么问题吗，

475
00:30:06,950 --> 00:30:08,690
关于这里的正确性定义

476
00:30:08,690 --> 00:30:12,140
或者 Spanner 拥有的正确性目标？

477
00:30:17,900 --> 00:30:18,440
好的。

478
00:30:18,980 --> 00:30:20,150
好的，那么我们来谈谈，

479
00:30:20,150 --> 00:30:23,300
如何实现只读事务的这种正确性。

480
00:30:23,780 --> 00:30:28,070
让我首先解释一个实际上不工作的坏的方案，

481
00:30:28,490 --> 00:30:31,220
然后我们将讨论一个更好的方案。

482
00:30:33,520 --> 00:30:34,780
所以坏的方案是，

483
00:30:34,840 --> 00:30:36,250
我们将读取，

484
00:30:37,360 --> 00:30:39,880
我们安排总是读取最新提交的值，

485
00:30:43,550 --> 00:30:46,940
这是关于写入的，

486
00:30:47,030 --> 00:30:51,560
因为我们必须安排，如果 T2 在 T1 提交之后开始，

487
00:30:51,560 --> 00:30:53,270
你必须看到它的写入，

488
00:30:53,270 --> 00:30:55,340
所以为什么不读取最新的提交值，

489
00:30:55,340 --> 00:30:56,870
我们可能是好的。

490
00:30:58,270 --> 00:30:59,320
所以这是，

491
00:30:59,350 --> 00:31:02,530
问题当然是，它实际上并不起作用，

492
00:31:03,120 --> 00:31:12,980
所以 T1 ，可能 T1 写入 x ，写入 y ，并提交转账，

493
00:31:13,670 --> 00:31:17,090
那么我们有另一个事务，

494
00:31:17,090 --> 00:31:18,620
我们有事务 T3 ，

495
00:31:18,620 --> 00:31:20,420
或者 T3 是只读操作，

496
00:31:20,450 --> 00:31:22,220
它读取 x ，

497
00:31:22,850 --> 00:31:24,290
所以这是一种实时的，

498
00:31:24,560 --> 00:31:27,140
然后在 T2 之后，

499
00:31:27,380 --> 00:31:29,480
然后在 T1 T3 开始之后，

500
00:31:29,480 --> 00:31:32,930
T2 运行，

501
00:31:32,930 --> 00:31:36,170
写入 x ，写入 y ，提交，

502
00:31:36,440 --> 00:31:38,450
然后 T3 有一点延迟，

503
00:31:38,450 --> 00:31:41,000
然后第二次读取 y ，

504
00:31:42,510 --> 00:31:46,410
时间像往常一样，是这个方向。

505
00:31:50,100 --> 00:31:56,160
如果你遵守读取最新的提交值（的规则），

506
00:31:56,160 --> 00:31:58,200
那么这会返回什么，

507
00:31:58,470 --> 00:32:01,860
它会返回事务 T1 的值，

508
00:32:02,360 --> 00:32:07,070
这个读取将返回来自这个事务的 y 的值，

509
00:32:07,070 --> 00:32:09,230
因为这是最新提交值。

510
00:32:09,910 --> 00:32:11,680
这是不对的，对吧，

511
00:32:19,360 --> 00:32:20,980
因为现在我们处于一种情况，

512
00:32:20,980 --> 00:32:26,020
T3 观察到来自不同事务的写入，

513
00:32:26,080 --> 00:32:27,760
而不是得到一致的[]。

514
00:32:29,620 --> 00:32:32,740
所以这个规则还不够好，

515
00:32:33,080 --> 00:32:38,750
为了避免这个问题，不使用这个糟糕的方案，

516
00:32:38,900 --> 00:32:40,880
Spanner 使用了不同的方案，

517
00:32:41,480 --> 00:32:45,320
这一方案称为快照隔离，

518
00:32:53,520 --> 00:32:56,580
这是一个标准的数据库概念，

519
00:32:56,670 --> 00:33:02,580
主要是一些本地数据库，

520
00:33:02,580 --> 00:33:04,800
并不是在广域内，

521
00:33:05,820 --> 00:33:10,560
我们稍后讨论广域方面，

522
00:33:10,560 --> 00:33:13,410
但首先让我解释一下什么是快照隔离。

523
00:33:14,230 --> 00:33:16,390
所以，快照隔离所做的是，

524
00:33:16,450 --> 00:33:23,580
我们为事务分配一个时间戳，

525
00:33:26,930 --> 00:33:32,510
我们分配时间戳，有两个不同的点，

526
00:33:32,570 --> 00:33:37,880
对于读写事务，是提交开始提交的时候，

527
00:33:40,690 --> 00:33:46,030
对于只读事务，是事务开始的时候，

528
00:33:48,900 --> 00:33:58,860
然后我们将按时间戳顺序执行所有事务，

529
00:34:01,950 --> 00:34:04,560
我一会儿再解释，但是这个意思，

530
00:34:05,180 --> 00:34:08,840
能够按时间戳顺序执行所有操作，

531
00:34:09,080 --> 00:34:10,040
每个 replica ，

532
00:34:11,750 --> 00:34:15,140
每个键保存一个值，

533
00:34:15,560 --> 00:34:20,840
replica 保存多个键的值以及它们的时间戳，

534
00:34:34,670 --> 00:34:36,500
例如，在一个 replica 中，

535
00:34:36,500 --> 00:34:39,920
我们可以说，请给我在时间 10 的 x 的值，

536
00:34:39,980 --> 00:34:44,390
或者给我时间戳 20 的 x 的值，

537
00:34:44,840 --> 00:34:50,030
有时这被称为多版本数据库或多版本存储，

538
00:34:50,030 --> 00:34:51,140
保存，

539
00:34:51,140 --> 00:34:54,950
对于每次更新，保存数据项的一个版本，

540
00:34:54,950 --> 00:34:56,240
这样你可以回到过去。

541
00:34:58,340 --> 00:35:03,350
所以，这解决了我在第一种情况中展示的问题，

542
00:35:03,350 --> 00:35:04,730
因为将要发生的事情，

543
00:35:04,730 --> 00:35:06,440
让我们再看看这三个事务，

544
00:35:06,560 --> 00:35:11,860
我们有 T1 ，我们有 T2 ，我们有 T3 ，

545
00:35:12,190 --> 00:35:19,060
T1 写入 x ，写入 y ，以及提交，

546
00:35:19,300 --> 00:35:23,290
我们假设提交发生在 10 ，

547
00:35:24,220 --> 00:35:27,220
所以这个事务在时间戳 10 运行，

548
00:35:27,970 --> 00:35:30,850
然后在某个时刻，

549
00:35:31,500 --> 00:35:32,970
我们读取 x ，

550
00:35:33,030 --> 00:35:35,370
我们稍后会谈到这一点，

551
00:35:35,370 --> 00:35:37,470
在这里我们有另一个事务，

552
00:35:37,470 --> 00:35:39,450
我们有写入 y ，

553
00:35:39,990 --> 00:35:44,250
写入 x ，写入 y ，并提交，

554
00:35:44,520 --> 00:35:46,980
假设这个事务在时间戳 20 提交，

555
00:35:47,580 --> 00:35:52,980
在这个时间戳运行，

556
00:35:53,340 --> 00:35:54,420
然后我们有读取 x ，

557
00:35:54,420 --> 00:35:55,500
我们有读取 y ，

558
00:35:56,250 --> 00:35:58,140
现在当读取 x 发生时，

559
00:35:58,470 --> 00:36:02,250
它将被分配一个时间戳，事务开始的时间，

560
00:36:02,280 --> 00:36:03,780
所以开始的时间，

561
00:36:03,780 --> 00:36:07,080
假设这个事务的开始时间是 15 ，

562
00:36:07,670 --> 00:36:11,510
所以 T2 的运行在 15 ，

563
00:36:12,940 --> 00:36:16,000
所以当执行读取 x 时，

564
00:36:16,000 --> 00:36:25,420
它需要读取 15 之前的 x 的最新值，

565
00:36:25,720 --> 00:36:32,410
对于时间戳 15 的最新提交值，

566
00:36:32,410 --> 00:36:37,540
在时间戳 15 之前是来自这个时间这个事务的值。

567
00:36:38,720 --> 00:36:41,390
所以读取 x 读取事务 1 的值，

568
00:36:41,750 --> 00:36:47,030
当然，读取 y 也将在事务开始的时间戳执行，

569
00:36:47,030 --> 00:36:50,300
所以它也会读取时间 15 的 y ，

570
00:36:50,660 --> 00:36:54,260
在时间戳 15 ， y 只有一个值，

571
00:36:54,290 --> 00:36:57,980
也就是由事务 T1 产生的，

572
00:36:57,980 --> 00:37:03,590
所以读取 y 也会从 T1 开始，

573
00:37:03,590 --> 00:37:06,350
所以，我们避免了之前遇到的这个问题，

574
00:37:06,530 --> 00:37:09,650
那个我们从不同的事务中读取。

575
00:37:10,590 --> 00:37:15,540
所以，这提供了我们寻找的线性一致性或串行化，

576
00:37:15,780 --> 00:37:19,080
所有事务都以全局时间戳顺序执行。

577
00:37:22,770 --> 00:37:23,550
这能理解吗？

578
00:37:25,670 --> 00:37:26,930
所以你可以考虑的是，

579
00:37:26,930 --> 00:37:28,880
每个 replica 有一个表，

580
00:37:30,700 --> 00:37:33,100
写入值和时间戳，

581
00:37:33,100 --> 00:37:39,190
所以我们有 x 值为 9@10 ，

582
00:37:39,520 --> 00:37:44,230
以及 x 值为 8@20 。

583
00:37:45,260 --> 00:37:48,140
所以当读取到达一个 replica 时，

584
00:37:48,290 --> 00:37:49,400
读取 15 进来，

585
00:37:49,400 --> 00:37:54,110
我可以挑选它的时间戳之前的最新的写入。

586
00:37:56,690 --> 00:37:57,560
所以我有一个问题，

587
00:37:57,560 --> 00:37:59,870
当我们读取 x 的时候，

588
00:37:59,930 --> 00:38:01,580
假设我们只关注读取 x ，

589
00:38:01,910 --> 00:38:05,000
x 本身存在于一些分片上，

590
00:38:05,000 --> 00:38:08,020
被复制在 Paxos 组上，

591
00:38:08,020 --> 00:38:12,220
假设有三台服务器复制 x ，

592
00:38:12,580 --> 00:38:13,690
当你读取 x 时，

593
00:38:13,690 --> 00:38:16,150
因为我们希望只读事务非常快，

594
00:38:16,150 --> 00:38:19,000
我们只从本地 replica 中读取，

595
00:38:19,060 --> 00:38:21,190
它不一定是领导者，

596
00:38:22,240 --> 00:38:25,030
那么，我们如何保证我们不会读到旧的，

597
00:38:25,570 --> 00:38:27,430
我们如何不获取旧的？

598
00:38:28,190 --> 00:38:29,690
好问题，

599
00:38:29,720 --> 00:38:33,710
这正是我接下来想要谈论的话题。

600
00:38:34,520 --> 00:38:38,060
正如你所指出的问题，

601
00:38:38,060 --> 00:38:39,650
这里有一个挑战，

602
00:38:39,650 --> 00:38:41,420
replica 可能没有看到，

603
00:38:45,920 --> 00:38:52,800
没有看到写入 x 在时间戳 10 ，

604
00:38:54,500 --> 00:39:00,950
在 Spanner 中解决这个问题的方法，

605
00:39:00,950 --> 00:39:03,710
解决方案他们称为 "safe time" ，

606
00:39:09,560 --> 00:39:12,950
所以，这个结果是这样的，

607
00:39:12,950 --> 00:39:21,670
Paxos 或 Raft 也按时间戳顺序发送所有写入，

608
00:39:25,280 --> 00:39:25,910
所以没有，

609
00:39:25,910 --> 00:39:30,110
你可以考虑总顺序是一个计数，

610
00:39:30,110 --> 00:39:35,810
类似比如在实验 3 中，

611
00:39:35,840 --> 00:39:37,520
但它实际上是一个时间戳，

612
00:39:37,610 --> 00:39:40,370
由于时间戳形成了全局顺序，

613
00:39:40,640 --> 00:39:44,150
时间戳的全局顺序足够对所有写入进行排序。

614
00:39:45,000 --> 00:39:47,160
然后有一条规则，

615
00:39:47,160 --> 00:39:48,780
对于读取，还有一个额外的规则，

616
00:39:49,800 --> 00:39:51,300
在你读取之前，

617
00:39:52,980 --> 00:40:00,640
所以在读取时间戳 15 的 x 之前，

618
00:40:00,820 --> 00:40:10,020
replica 必须等待时间戳大于 15 的写入，

619
00:40:11,810 --> 00:40:14,570
看到时间戳大于 15 的写入，

620
00:40:14,810 --> 00:40:17,780
它就知道在 15 之前不会再有写入，

621
00:40:18,300 --> 00:40:22,740
所以安全地在时间戳 15 执行读取，

622
00:40:23,270 --> 00:40:25,550
并且知道需要返回什么值。

623
00:40:26,520 --> 00:40:28,500
所以，对于服务而言，

624
00:40:28,770 --> 00:40:29,520
所以，这意味着，

625
00:40:29,520 --> 00:40:32,610
读取可能必须稍微延迟一点，直到下一次写入，

626
00:40:32,610 --> 00:40:34,050
当然，对于忙的服务器，

627
00:40:34,050 --> 00:40:36,090
这些写入一直到来，

628
00:40:36,300 --> 00:40:40,050
所以，等待可能不存在或几乎不存在。

629
00:40:40,930 --> 00:40:41,530
好的?

630
00:40:41,830 --> 00:40:43,630
但这是需要遵循的规则，

631
00:40:43,630 --> 00:40:45,430
为了确保（避免）这个问题，

632
00:40:45,730 --> 00:40:51,010
没有看到写入的 write 返回错误的值。

633
00:40:52,250 --> 00:40:54,110
真正的情况要稍微复杂一些，

634
00:40:54,470 --> 00:40:56,450
你也必须等待，

635
00:40:57,260 --> 00:41:00,620
还要等待已准备好但未提交的事务，

636
00:41:19,410 --> 00:41:24,480
例如，这个事务已经准备好了，在时间戳 14 ，

637
00:41:24,690 --> 00:41:29,910
但它可能还没有提交写入到键值存储，

638
00:41:30,090 --> 00:41:31,410
所以，我们要确保，

639
00:41:31,410 --> 00:41:37,140
任何在我们读取时间戳前准备好的事务，

640
00:41:37,170 --> 00:41:40,890
必须在我们返回读取值之前提交。

641
00:41:40,920 --> 00:41:41,520
好的?

642
00:41:44,050 --> 00:41:44,920
这能理解吗？

643
00:41:46,510 --> 00:41:50,710
不同的分片是否也是这样，

644
00:41:50,710 --> 00:41:53,830
我们是否单独考虑不同的分片？

645
00:41:55,770 --> 00:42:04,470
读取只命中本地的分片，本地的 replica ，

646
00:42:05,090 --> 00:42:07,670
所以我不是百分之百确定你问我的问题。

647
00:42:07,880 --> 00:42:09,950
我想我的问题是，

648
00:42:10,310 --> 00:42:15,770
正确性保证适用于跨分片吗？

649
00:42:16,830 --> 00:42:19,860
是的，它们适用于事务级别，

650
00:42:19,860 --> 00:42:23,520
如果只读读取本地 replica ，

651
00:42:23,580 --> 00:42:27,360
我们仍然需要确保事务的一致性，

652
00:42:27,810 --> 00:42:30,360
通过遵循这些规则，我们实现了这个目标。

653
00:42:31,910 --> 00:42:33,770
好的，理解了，谢谢。

654
00:42:37,150 --> 00:42:46,270
好的，现在，我们要看 Spanner 论文的核心部分，

655
00:42:46,270 --> 00:42:47,410
这将是，

656
00:42:47,410 --> 00:42:50,110
我们想要理解时间，比如时间戳，

657
00:42:50,700 --> 00:42:52,980
在这种情况下，时钟，

658
00:42:52,980 --> 00:43:00,870
不同服务器的时钟必须准确，

659
00:43:01,140 --> 00:43:01,950
它必须是完美的，

660
00:43:02,070 --> 00:43:06,330
不同的参与者必须就时间戳顺序达成一致，

661
00:43:06,450 --> 00:43:09,450
如果事务使用特定的时间戳，

662
00:43:09,690 --> 00:43:13,200
在系统的中任何地方，时间戳都必须是相同的，

663
00:43:14,060 --> 00:43:21,200
所以，就像我在之前的幻灯片中描述的那样，

664
00:43:21,200 --> 00:43:24,830
参与者选择读取事务，

665
00:43:24,920 --> 00:43:27,170
分配一个像 15 这样的时间戳，

666
00:43:27,440 --> 00:43:28,970
可能往回一点，

667
00:43:29,210 --> 00:43:33,200
这里，我们为这些事务分配时间戳，

668
00:43:33,500 --> 00:43:34,910
最好是这种情况，

669
00:43:34,910 --> 00:43:38,540
T1 T2 T3 就这些时间戳达成一致，

670
00:43:39,650 --> 00:43:41,420
而且它们具有可比性，

671
00:43:42,170 --> 00:43:46,880
我们稍后会看到，

672
00:43:47,120 --> 00:43:50,600
这只对只读事务非常重要，

673
00:44:05,250 --> 00:44:08,550
我们可以考虑这两种情况，

674
00:44:08,550 --> 00:44:09,900
会发生什么，

675
00:44:09,930 --> 00:44:11,490
我们想问的问题是，

676
00:44:11,640 --> 00:44:15,570
如果一个 replica 或服务器时间错误会发生什么，

677
00:44:16,400 --> 00:44:19,490
所以它与其他服务器的时间不一致，

678
00:44:20,120 --> 00:44:23,240
会带来什么样的问题，

679
00:44:23,240 --> 00:44:24,830
那么我们先来考虑一下这种情况，

680
00:44:25,160 --> 00:44:26,930
如果时间戳太大了，会怎么样？

681
00:44:32,740 --> 00:44:37,180
例如，我们回到这里的版本，

682
00:44:37,180 --> 00:44:38,530
在这种情况下，

683
00:44:38,860 --> 00:44:42,910
假设只读事务开始读取，

684
00:44:43,150 --> 00:44:48,940
它读取不是 15 ，

685
00:44:48,940 --> 00:44:53,420
也许实际上返回的值是 25 ，

686
00:44:55,630 --> 00:44:57,250
会发生什么，

687
00:44:58,930 --> 00:45:01,420
或者让它简单一点 18 ，

688
00:45:04,310 --> 00:45:05,360
为了减少混乱，

689
00:45:06,210 --> 00:45:10,050
时间戳偏差的结果是什么，

690
00:45:10,050 --> 00:45:12,540
但是偏差往大的方向。

691
00:45:15,780 --> 00:45:17,280
它仍然小于 25 ，

692
00:45:17,280 --> 00:45:20,160
如果它仍然读取[]于 20 ，

693
00:45:20,190 --> 00:45:22,980
它仍然读取第一个，

694
00:45:22,980 --> 00:45:23,790
但是如果晚一点，

695
00:45:23,790 --> 00:45:25,500
它将读取第二个。

696
00:45:25,680 --> 00:45:27,570
是的，两个都没问题，

697
00:45:27,570 --> 00:45:30,180
这里真正的关键问题是，

698
00:45:31,200 --> 00:45:35,550
在读取之前，你必须等到看到写入，

699
00:45:35,550 --> 00:45:36,360
如果你是，

700
00:45:36,450 --> 00:45:38,760
那么如果你的时间戳太大，会发生什么，

701
00:45:40,220 --> 00:45:41,900
我们偏差往太大的方向。

702
00:45:42,370 --> 00:45:44,830
你得等待。

703
00:45:44,860 --> 00:45:47,230
是的，你必须等待，

704
00:45:47,230 --> 00:45:47,320
也许再多等一会儿，

705
00:45:48,740 --> 00:45:49,940
不会出什么问题。

706
00:45:54,920 --> 00:45:57,950
所以现在另一个问题是，

707
00:45:57,950 --> 00:46:00,710
如果时间戳太小，会怎么样，

708
00:46:04,010 --> 00:46:05,630
比如，读取，

709
00:46:05,750 --> 00:46:09,620
当执行 T3 的机器询问时间时，

710
00:46:09,620 --> 00:46:14,150
不是时间 10 ，而是 9 ，

711
00:46:14,150 --> 00:46:17,990
这是课程问题的一个变体，

712
00:46:17,990 --> 00:46:21,080
T3 在时间 9 运行。

713
00:46:22,840 --> 00:46:26,470
也许这是一个很好的时机开始一个分组讨论室，

714
00:46:26,710 --> 00:46:30,250
你们可以思考和争论，结果是什么，

715
00:46:30,430 --> 00:46:32,020
潜在的结果是什么，

716
00:46:32,020 --> 00:46:33,610
或者会出什么问题，

717
00:46:33,730 --> 00:46:40,300
如果 T3 分配的时间戳是 9 而不是 10 。

718
00:46:43,630 --> 00:46:45,070
所以也许我们可以进行一个分组会议室，

719
00:46:45,100 --> 00:46:46,330
Lily ，可以吗，

720
00:46:49,270 --> 00:46:51,040
好的，我想 Lily 很快就会回来，

721
00:46:59,210 --> 00:47:00,620
稍等片刻。

722
00:47:18,080 --> 00:47:21,020
好了，还有其他人听到那个噪音吗？

723
00:53:42,920 --> 00:53:44,990
好了，大家回来，大家能听到我说话吗？

724
00:53:46,800 --> 00:53:47,700
是的。

725
00:53:51,630 --> 00:53:52,200
我们都是好的吗？

726
00:53:57,090 --> 00:53:58,770
假设我们都是好的。

727
00:54:00,090 --> 00:54:01,110
是的，是的，我们是好的。

728
00:54:01,260 --> 00:54:02,100
我们都是好的。

729
00:54:04,250 --> 00:54:08,690
好的，所以回到这个问题，

730
00:54:08,690 --> 00:54:13,070
我们调查，我们依靠的方案，

731
00:54:13,070 --> 00:54:16,400
不同机器上的时钟是完全同步的，

732
00:54:16,400 --> 00:54:20,540
正如我所提到的，这只影响只读事务，

733
00:54:20,540 --> 00:54:22,910
因为读写事务会抓取日志

734
00:54:22,970 --> 00:54:25,280
并使用两阶段锁来获得整体顺序，

735
00:54:25,870 --> 00:54:30,790
所以它们执行一些可串行化的，外部一致顺序，

736
00:54:31,090 --> 00:54:36,160
我们看到，对于只读事务，时间戳至关重要，

737
00:54:36,640 --> 00:54:38,170
至少，我们认为是至关重要的，

738
00:54:38,170 --> 00:54:39,400
如果它们太大，

739
00:54:39,400 --> 00:54:41,950
可能不是，只是负面影响性能，

740
00:54:42,130 --> 00:54:45,580
但问题是，如果时间戳太小，会发生什么，

741
00:54:45,880 --> 00:54:49,570
所以我们要问的具体问题是，

742
00:54:49,570 --> 00:54:50,980
会发生什么，

743
00:54:51,160 --> 00:54:58,140
如果我们稍后会看到的场景，

744
00:54:58,140 --> 00:55:00,360
我们有事务 T1 ，

745
00:55:00,510 --> 00:55:04,050
这里写错了，是 T2 和 T3 ，

746
00:55:04,350 --> 00:55:05,850
T3 正在进行读取，

747
00:55:06,120 --> 00:55:12,330
这个读取不是发生在 15 ，

748
00:55:12,360 --> 00:55:14,010
它实际上发生在，

749
00:55:14,010 --> 00:55:16,890
因为 3 的时钟是错的，

750
00:55:16,920 --> 00:55:18,210
它实际发生在 9 ，

751
00:55:19,800 --> 00:55:22,170
那会有多糟糕？

752
00:55:27,830 --> 00:55:29,630
破坏我们的串行化。

753
00:55:30,820 --> 00:55:31,540
有人知道吗？

754
00:55:32,270 --> 00:55:33,740
好的，看起来，

755
00:55:34,320 --> 00:55:35,820
好的，抱歉，我没听到你说的，

756
00:55:35,820 --> 00:55:39,000
因为我这边今晚出了点问题，

757
00:55:39,000 --> 00:55:40,740
我想我能听到你的声音，

758
00:55:40,800 --> 00:55:41,970
你能重复一下答案吗？

759
00:55:42,330 --> 00:55:44,790
抱歉，我说它会破坏可串行化。

760
00:55:45,000 --> 00:55:45,690
是的，为什么？

761
00:55:46,440 --> 00:55:50,040
因为这里读取会发生，

762
00:55:50,400 --> 00:55:53,730
会假设发生在最新的写入之后，

763
00:55:53,820 --> 00:55:57,150
然后会发生在你没有写入之前。

764
00:55:57,420 --> 00:55:59,820
是的，所以把故事说完整，

765
00:55:59,820 --> 00:56:04,530
T3 实际上在 15 执行，

766
00:56:04,920 --> 00:56:08,370
在 T2 T1 提交之后，

767
00:56:08,710 --> 00:56:11,830
所以， T3 必须看到 T1 的写入，

768
00:56:11,980 --> 00:56:13,540
但是如果时钟错误，

769
00:56:13,570 --> 00:56:18,160
时间戳 9 分配给 T3 ，

770
00:56:18,310 --> 00:56:25,330
T3 将在执行事务 T1 之前读取 x 的值，

771
00:56:25,570 --> 00:56:26,860
这将是错误的，

772
00:56:26,860 --> 00:56:30,170
这将打破外部一致性。

773
00:56:32,630 --> 00:56:33,170
好的?

774
00:56:34,100 --> 00:56:35,060
大家都清楚了吗？

775
00:56:50,590 --> 00:56:53,740
好的，所以很明显我们想避免这种情况，

776
00:56:54,190 --> 00:56:58,090
还有一些核心问题，

777
00:56:58,090 --> 00:57:02,110
问题是我们如何获得时钟，

778
00:57:02,140 --> 00:57:03,670
我们如何保持时钟同步。

779
00:57:04,330 --> 00:57:06,670
哦，稍等，我还有一个问题。

780
00:57:07,180 --> 00:57:09,790
所以这种情况是可以发生的，

781
00:57:09,790 --> 00:57:18,220
因为总是由协调者为读写事务分配时间戳，

782
00:57:18,250 --> 00:57:21,700
所以，即使读取发生在本地，

783
00:57:21,730 --> 00:57:25,150
所以，机器可能落后，

784
00:57:25,390 --> 00:57:30,180
有一个对于本地时钟的未来的版本。

785
00:57:30,570 --> 00:57:34,120
是的，或者是在过去，是在未来，是的。

786
00:57:35,620 --> 00:57:36,640
好的，这是可能发生的，

787
00:57:36,640 --> 00:57:40,120
因为不是在决定时间戳的机器上。

788
00:57:40,870 --> 00:57:43,450
不，好的，忘了是哪台机器，

789
00:57:43,450 --> 00:57:48,460
T3 会决定事务的时间戳，

790
00:57:48,460 --> 00:57:50,080
我们回到这张图片上，

791
00:57:50,790 --> 00:57:52,320
所以这里我们有 T3 ，

792
00:57:52,900 --> 00:57:56,170
T3 开始，

793
00:57:56,170 --> 00:58:03,520
原则上， T3 开始绝对时间是在 10 之后的，

794
00:58:03,520 --> 00:58:05,350
因为 T3 开始在 T1 之后，

795
00:58:05,350 --> 00:58:06,520
正如我们在这张图片中看到的，

796
00:58:08,100 --> 00:58:10,500
所以这个读取 x ，

797
00:58:10,500 --> 00:58:13,500
所以，我们将时间戳分配给只读事务，

798
00:58:13,500 --> 00:58:16,320
我们将时间戳分配给只读事务，

799
00:58:16,320 --> 00:58:18,150
在事务开始的时刻，

800
00:58:18,620 --> 00:58:21,710
所以读取 x 是 T3 的事务的开始，

801
00:58:22,130 --> 00:58:24,590
T3 需要得到时间戳，

802
00:58:24,590 --> 00:58:27,440
所以它会说，请给我时钟当前的值，

803
00:58:28,110 --> 00:58:31,980
如果时钟是可靠和准确的，

804
00:58:31,980 --> 00:58:35,490
它当然会给出一个 10 之后的时间，

805
00:58:35,520 --> 00:58:38,220
因为 T3 是在 10 之后开始的，

806
00:58:39,210 --> 00:58:43,950
但是我们假设 T3 的时钟不是，

807
00:58:43,980 --> 00:58:46,140
[]准确同步的，

808
00:58:46,410 --> 00:58:48,330
时钟实际上返回了 9 ，

809
00:58:49,210 --> 00:58:54,070
现在事务 3 将执行时间戳 9 ，

810
00:58:54,190 --> 00:58:58,030
这将导致你读取 T1 之前的值，

811
00:58:58,030 --> 00:59:01,450
这将打破外部一致性。

812
00:59:03,520 --> 00:59:07,020
好的，但是如果，

813
00:59:08,340 --> 00:59:14,130
如果我们执行 T3 的 replica 有，

814
00:59:17,460 --> 00:59:23,490
它可能有版本 10 的变量 x ，对吧？

815
00:59:24,750 --> 00:59:29,310
它可能会，但它在时间 9 执行事务，

816
00:59:29,310 --> 00:59:32,250
所以我们会得到 10 之前的值，这个版本的[内存]。

817
00:59:32,250 --> 00:59:32,850
是的，是的。

818
00:59:33,330 --> 00:59:33,750
是吗？

819
00:59:35,510 --> 00:59:35,750
是的。

820
00:59:35,750 --> 00:59:37,340
这是一个很好的问题，

821
00:59:37,340 --> 00:59:40,880
我认为这一点非常重要，让我们清楚地知道这里发生了什么。

822
00:59:42,790 --> 00:59:46,120
好的，所以我希望我们现在达成一致，

823
00:59:46,120 --> 00:59:48,160
这是非常重要的，

824
00:59:48,160 --> 00:59:51,520
这些在不同机器上的时钟是完全同步的，

825
00:59:52,030 --> 00:59:56,680
当然，你知道不可能实现完美的时钟同步，

826
00:59:56,680 --> 00:59:58,120
有一些困难，

827
01:00:01,590 --> 01:00:03,600
很难实现时钟同步，

828
01:00:03,660 --> 01:00:06,060
因为时钟会自然漂移，

829
01:00:09,160 --> 01:00:11,410
所以当你认为，

830
01:00:11,410 --> 01:00:14,500
它是晚上 10 点加上 1 毫秒，

831
01:00:14,500 --> 01:00:16,570
我的机器可能会认为，

832
01:00:16,570 --> 01:00:20,560
它是晚上 10 点加上 2 微秒，

833
01:00:20,830 --> 01:00:25,570
这是因为在你的机器或服务器中，

834
01:00:25,570 --> 01:00:28,270
振荡器跟踪时间，

835
01:00:28,420 --> 01:00:33,040
它们以特定的频率运行，

836
01:00:33,040 --> 01:00:35,170
但是它的频率并不完美，

837
01:00:35,380 --> 01:00:37,120
更好的时钟，

838
01:00:37,120 --> 01:00:43,360
原子钟有更好的振荡器，更精确，

839
01:00:43,360 --> 01:00:47,770
作为 Spanner 依赖的那种时钟，

840
01:00:47,770 --> 01:00:49,510
相当高的精确度，

841
01:00:49,630 --> 01:00:51,400
但是他们仍然需要

842
01:00:51,460 --> 01:00:55,000
偶尔与通用全球时间同步，

843
01:00:56,340 --> 01:00:59,070
为了避免漂移的问题，

844
01:00:59,070 --> 01:01:02,730
非常精确的时钟，他们使用原子钟，

845
01:01:04,600 --> 01:01:07,780
比你的计算机里的时钟更精确，

846
01:01:08,200 --> 01:01:11,290
然后它们与全球时间同步，

847
01:01:13,750 --> 01:01:19,330
为了确保所有时钟在全球时间上一致，

848
01:01:19,330 --> 01:01:21,220
它们保持滴答滴答滴答，

849
01:01:21,520 --> 01:01:23,320
然后周期性地重新同步，

850
01:01:25,040 --> 01:01:28,280
同步时钟，使用全球时间，

851
01:01:28,280 --> 01:01:34,400
他们使用 GPS 全球定位系统广播时间，

852
01:01:34,400 --> 01:01:38,210
作为同步不同原子钟的一种方式，

853
01:01:38,210 --> 01:01:40,310
然后保持它们同步运行。

854
01:01:41,210 --> 01:01:42,860
所以看起来，

855
01:01:42,890 --> 01:01:47,540
这篇论文并没有太多地谈到真实时间系统是如何工作的，

856
01:01:47,780 --> 01:01:48,590
但看起来是，

857
01:01:48,590 --> 01:01:53,060
他们的每个数据中心可能有少量的或一个原子钟，

858
01:01:53,570 --> 01:01:55,190
服务器同步，

859
01:01:55,190 --> 01:01:57,920
使用这个，时间服务器常规地

860
01:01:58,880 --> 01:02:02,210
与时间 master 同步它们的本地时间，

861
01:02:02,720 --> 01:02:04,820
在不同数据中心的不同时间 master ，

862
01:02:04,820 --> 01:02:09,800
通过 GPS 系统进行同步。

863
01:02:11,260 --> 01:02:13,510
但结果就是，

864
01:02:13,510 --> 01:02:17,110
位于不同的服务器上的时钟非常接近，

865
01:02:17,260 --> 01:02:20,320
他们谈论的 ε ，

866
01:02:20,320 --> 01:02:21,880
也就是错误率是，

867
01:02:21,880 --> 01:02:25,000
似乎他们时钟的 ε ，

868
01:02:25,000 --> 01:02:27,520
你可以在论文结尾看到一个表，

869
01:02:27,580 --> 01:02:32,250
只有几微秒到几毫秒的量级。

870
01:02:35,440 --> 01:02:37,750
所以，当机器到达，

871
01:02:37,780 --> 01:02:41,890
问操作系统，请告诉我现在的时间，

872
01:02:42,220 --> 01:02:48,130
返回的当前时间可能与实际时间相差几微秒，

873
01:02:48,160 --> 01:02:50,680
或者甚至比真实时间差几毫秒。

874
01:02:53,160 --> 01:02:53,820
好的?

875
01:02:55,110 --> 01:02:55,800
所以，这有一点。

876
01:02:55,800 --> 01:02:57,840
[]，是的，请继续。

877
01:02:58,200 --> 01:03:01,380
是的，所以，比如在论文中，

878
01:03:01,380 --> 01:03:03,720
就像你提到的，我们并没有深入这一点，

879
01:03:03,720 --> 01:03:06,810
但就像同步时钟

880
01:03:06,810 --> 01:03:09,420
甚至测量它们有多不同。

881
01:03:09,420 --> 01:03:09,810
是的。

882
01:03:09,960 --> 01:03:13,920
我的意思是，我们不应该也考虑到信息传递的时间吗。

883
01:03:13,920 --> 01:03:16,350
是的，我想这就是他们的意思，

884
01:03:16,350 --> 01:03:17,700
抱歉，我没说太多，

885
01:03:17,700 --> 01:03:18,540
但这就是他们的意思，

886
01:03:18,540 --> 01:03:21,390
所以他们对自己的想法保持着持续的估计，

887
01:03:21,390 --> 01:03:24,630
例如，与时间 master 同步，

888
01:03:24,840 --> 01:03:28,440
本地计算机上的时间库

889
01:03:28,440 --> 01:03:31,890
可能会跟踪开始时间以进行估计，

890
01:03:31,890 --> 01:03:35,520
平均延迟或正常延迟是多少，

891
01:03:35,520 --> 01:03:38,100
向时间 master 发送或接收消息，

892
01:03:38,700 --> 01:03:43,920
用它来纠正任何小错误，

893
01:03:45,300 --> 01:03:49,020
他们协议也支持离散值，

894
01:03:49,020 --> 01:03:50,460
所以[]离群值，

895
01:03:50,460 --> 01:03:51,990
我是说网络中发生的不好的事情，

896
01:03:51,990 --> 01:03:55,020
因此你的时间戳延迟了很多，

897
01:03:55,110 --> 01:03:57,030
所以你不应该包括那些，

898
01:03:57,150 --> 01:03:58,980
我想还有第三个问题，

899
01:03:58,980 --> 01:04:02,490
有时这些振荡器会失灵，

900
01:04:02,580 --> 01:04:05,460
不再是正确的了，

901
01:04:05,610 --> 01:04:08,010
它们可能返回不正确的值，

902
01:04:08,010 --> 01:04:12,300
所以再次，他们没有谈论大量的细节，

903
01:04:12,300 --> 01:04:16,230
但它们似乎使用了 ntp 类似的技术，

904
01:04:16,410 --> 01:04:18,030
来处理这类问题。

905
01:04:19,680 --> 01:04:20,550
我明白了，谢谢。

906
01:04:23,600 --> 01:04:26,420
所以如果你对这类东西感兴趣，

907
01:04:26,420 --> 01:04:27,980
有一种称为 ntp 的协议，

908
01:04:27,980 --> 01:04:30,470
当你的计算机和[]用来

909
01:04:30,470 --> 01:04:34,370
将它的时钟与全球时间同步，

910
01:04:34,670 --> 01:04:38,780
ntp 有所有这些内置的机制，

911
01:04:39,020 --> 01:04:40,160
但 ntp 不是，

912
01:04:40,160 --> 01:04:44,660
它没有相同的位置，也没有同样的小差值，

913
01:04:44,930 --> 01:04:47,240
就是真正的时间，

914
01:04:49,390 --> 01:04:51,580
所以我认为 ntp 可能是，你应该认为，

915
01:04:51,580 --> 01:04:56,140
这些错误率是从几毫秒到十毫秒的数量级，

916
01:04:56,140 --> 01:04:58,510
它主要与往返时间有关。

917
01:05:03,060 --> 01:05:04,320
对于这个，还有其他问题吗？

918
01:05:07,600 --> 01:05:10,840
好吧，所以时钟并不是完全同步的，

919
01:05:10,870 --> 01:05:13,300
有一个误差范围，

920
01:05:13,720 --> 01:05:16,780
true time 所做的是，

921
01:05:16,780 --> 01:05:21,250
true time 给出一个答案，

922
01:05:21,250 --> 01:05:23,230
它会给你最佳估计值，

923
01:05:23,230 --> 01:05:26,050
当前的绝对时间或真实时间是什么，

924
01:05:26,290 --> 01:05:29,470
加上机器的误差范围。

925
01:05:30,400 --> 01:05:40,840
所以解决这个时钟漂移的办法，

926
01:05:40,840 --> 01:05:45,940
不使用真实时间的时间戳，

927
01:05:45,940 --> 01:05:47,650
或者仅仅是纯粹的时间戳，

928
01:05:47,830 --> 01:05:50,320
而是时间戳是时间间隔。

929
01:06:00,120 --> 01:06:06,840
所以每个从当前时间返回的值，

930
01:06:07,080 --> 01:06:12,550
包含最早的和最晚的，

931
01:06:15,190 --> 01:06:18,160
例如，我们询问当前时间，

932
01:06:18,370 --> 01:06:23,020
它的真实时间是上午 10 点或下午 2 点，

933
01:06:23,140 --> 01:06:25,210
它可能返回间隔，

934
01:06:25,210 --> 01:06:30,820
最早的可能是下午 1:59 ，

935
01:06:31,340 --> 01:06:37,730
59 秒以及 20 微秒，

936
01:06:38,030 --> 01:06:44,000
最晚的可能是下午 2 点加上 2 微秒，

937
01:06:45,340 --> 01:06:48,280
有些机器可能不止几微秒，

938
01:06:48,280 --> 01:06:50,020
有些机器甚至可能有几毫秒，

939
01:06:50,380 --> 01:06:52,390
我猜论文中的一些东西，

940
01:06:52,390 --> 01:06:56,530
误差有时是 10 毫秒或多毫秒的量级，

941
01:06:57,490 --> 01:06:59,230
但它给出了一个间隔，

942
01:06:59,320 --> 01:07:02,830
而且可以保证真实时间在这个时间间隔内。

943
01:07:04,110 --> 01:07:07,530
时间间隔是 ε 还是 2ε ？

944
01:07:11,560 --> 01:07:13,060
论文并没有谈到这一点，

945
01:07:13,060 --> 01:07:14,200
从这个意义上说，

946
01:07:14,320 --> 01:07:17,800
这只是对误差范围的估计，

947
01:07:22,170 --> 01:07:25,380
我认为如果你看一下协议的细节，

948
01:07:25,380 --> 01:07:27,960
通常，这个误差范围[] 2ε 。

949
01:07:32,570 --> 01:07:33,110
好的?

950
01:07:34,840 --> 01:07:35,680
现在，为了解决，

951
01:07:35,680 --> 01:07:39,580
所以现在我们需要调整我们的协议，

952
01:07:39,580 --> 01:07:41,320
因为我们的协议有一些规则，

953
01:07:41,320 --> 01:07:45,760
来设置时间戳的开始时间，

954
01:07:45,790 --> 01:07:49,300
或者使用时间戳设置事务的开始时间，

955
01:07:49,690 --> 01:07:57,820
读取下一个写入的规则，

956
01:07:58,000 --> 01:07:58,630
我们会看到，

957
01:07:58,630 --> 01:08:01,060
有几条规则需要改变，

958
01:08:01,090 --> 01:08:06,760
处理时间间隔而不是真正的时间。

959
01:08:08,030 --> 01:08:11,770
首先，开始规则是不同的，

960
01:08:14,480 --> 01:08:20,270
所以开始规则是，

961
01:08:20,270 --> 01:08:21,170
当前时间，

962
01:08:21,890 --> 01:08:24,530
我们问计算机，请告诉当前时间，

963
01:08:24,530 --> 01:08:25,610
获得时间间隔，

964
01:08:25,880 --> 01:08:29,660
然后我们选择的开始时间是 latest ，

965
01:08:32,690 --> 01:08:34,460
所以这意味着，

966
01:08:34,460 --> 01:08:38,240
无论时间戳是什么，开始规则是[]，

967
01:08:38,270 --> 01:08:41,390
肯定在真实时间之后，

968
01:08:42,540 --> 01:08:44,430
我们知道真实时间在过去，

969
01:08:45,300 --> 01:08:46,980
对于只读事务，

970
01:08:47,130 --> 01:08:49,920
这被分配到事务的开始处，

971
01:08:53,180 --> 01:08:55,070
对于读写交易，

972
01:08:55,070 --> 01:08:58,100
像之前一样，它是在提交开始时，

973
01:09:00,250 --> 01:09:01,660
所以这一部分不会改变，

974
01:09:01,720 --> 01:09:03,550
唯一改变的是，

975
01:09:03,670 --> 01:09:05,170
你得到时间间隔的终点，

976
01:09:06,050 --> 01:09:07,730
我们可以得到时间间隔的终点，

977
01:09:07,730 --> 01:09:12,740
所以，至少真正的时间已经过去了。

978
01:09:13,480 --> 01:09:18,100
好的，还有第二条我们以前没有的规则，

979
01:09:18,700 --> 01:09:20,140
那就是提交等待规则，

980
01:09:21,260 --> 01:09:24,020
我们会在事务中推迟，

981
01:09:24,020 --> 01:09:28,340
所以，如果事务在提交时获得某个时间戳，

982
01:09:28,580 --> 01:09:30,350
使用提交的开始，

983
01:09:30,350 --> 01:09:32,750
然后我们到达提交的末尾，

984
01:09:33,310 --> 01:09:35,170
然后我们将推迟这一提交，

985
01:09:36,260 --> 01:09:43,010
延迟提交直到在提交开始时分配的时间戳，

986
01:09:43,520 --> 01:09:50,450
是过去的，

987
01:09:50,450 --> 01:09:52,160
哦，我的笔记错了，

988
01:09:52,160 --> 01:09:53,000
稍等一下，

989
01:10:11,180 --> 01:10:20,580
我们要推迟到时间戳早于 now.earliest ，

990
01:10:26,390 --> 01:10:28,940
我们知道这肯定在真实时间之前。

991
01:10:32,180 --> 01:10:36,830
好的，这就是对协议的修改，

992
01:10:36,830 --> 01:10:38,450
让我们看看这是如何工作的，

993
01:10:38,450 --> 01:10:39,800
举个简单的例子，

994
01:10:39,800 --> 01:10:41,870
对此有更多的感受。

995
01:10:48,890 --> 01:10:52,100
例如，我将使用比前一个简单的，

996
01:10:52,100 --> 01:10:54,770
我将只关注写入 x 的事务，

997
01:10:55,750 --> 01:10:58,000
我们还是有 3 个事务，

998
01:10:58,730 --> 01:11:00,410
所以这是 T1 ，

999
01:11:01,110 --> 01:11:05,140
T1 执行写入 x ，然后提交，

1000
01:11:05,560 --> 01:11:09,130
我们并不太关心这些事务，

1001
01:11:09,130 --> 01:11:13,500
所以我们假设提交在 1 ，真实时间 1 ，

1002
01:11:14,950 --> 01:11:17,350
所以现在我们将运行事务 T2 ，

1003
01:11:17,920 --> 01:11:19,810
它会写入，

1004
01:11:21,020 --> 01:11:24,350
是的，事务 T2 当然在 T1 之后运行，

1005
01:11:25,900 --> 01:11:28,720
它写入比如 x2 ，

1006
01:11:29,280 --> 01:11:30,840
所以这里写入 x1 ，

1007
01:11:30,840 --> 01:11:32,910
将 2 写入 x ，

1008
01:11:32,910 --> 01:11:35,400
它开始准备，这是提交的开始，

1009
01:11:35,860 --> 01:11:40,480
所以在提交开始时，请求一个时间，

1010
01:11:41,320 --> 01:11:44,290
它将得到一个时间间隔，

1011
01:11:44,770 --> 01:11:49,600
我们知道真实时间会回来，

1012
01:11:49,600 --> 01:11:52,420
作为[]在时间间隔中，

1013
01:11:52,540 --> 01:11:54,160
但在时间间隔的某个时候，

1014
01:11:54,340 --> 01:11:58,300
所以，时间间隔可能开始在真实时间之前，

1015
01:11:58,690 --> 01:12:01,720
比如时间间隔开始于 1 ，

1016
01:12:01,960 --> 01:12:04,450
与事务 T1 重叠，

1017
01:12:04,720 --> 01:12:09,670
也许时间间隔的最新值是 10 ，

1018
01:12:09,850 --> 01:12:11,620
这就是它得到的，

1019
01:12:11,800 --> 01:12:15,220
我们要选择作为时间戳的是，

1020
01:12:15,220 --> 01:12:16,930
选择这个值 10 ，

1021
01:12:19,930 --> 01:12:22,180
我们想要选择最新的值，

1022
01:12:22,180 --> 01:12:24,310
因为我们想绝对确定，

1023
01:12:24,340 --> 01:12:29,740
如果有一个事务在真实时间之前开始，

1024
01:12:29,890 --> 01:12:34,150
我们选的时间肯定是在真实时间之后，

1025
01:12:34,150 --> 01:12:36,790
所以我们选择 10 ，绝对超过 1 ，

1026
01:12:37,030 --> 01:12:40,000
我们永远不会对之前的事务感到困惑，

1027
01:12:41,460 --> 01:12:42,600
然后，在某个时刻，

1028
01:12:43,270 --> 01:12:46,570
这个事务选择了时间戳 10 ，

1029
01:12:46,570 --> 01:12:50,740
10 可能比真实时间更远一点，

1030
01:12:51,370 --> 01:12:54,250
所以，事务不会准备，

1031
01:12:54,250 --> 01:12:57,520
或者两阶段提交所需的工作，

1032
01:12:57,520 --> 01:12:59,170
（直到）到达真正的提交点，

1033
01:13:00,160 --> 01:13:04,120
那里，可能需要等待，

1034
01:13:04,120 --> 01:13:05,620
因为这是提交规则，

1035
01:13:05,620 --> 01:13:07,270
我们得等一会儿，

1036
01:13:07,300 --> 01:13:12,400
直到我们确定 10 已经过去，

1037
01:13:13,280 --> 01:13:15,740
所以，这就是提交时间，

1038
01:13:15,740 --> 01:13:20,330
事务协调者所要做的是，

1039
01:13:20,330 --> 01:13:21,080
查看提交时间，

1040
01:13:21,110 --> 01:13:22,850
继续读取它的本地时钟，

1041
01:13:23,120 --> 01:13:26,120
我们会继续读取它的本地时钟，直到获得时间间隔，

1042
01:13:26,360 --> 01:13:29,540
那里的 earliest 时间已经过了 10 ，

1043
01:13:30,870 --> 01:13:33,690
所以也许在某一时刻，读取，

1044
01:13:33,690 --> 01:13:35,250
读取获得时间间隔，

1045
01:13:35,250 --> 01:13:39,030
然后时间间隔从 9 或 7 开始，

1046
01:13:39,150 --> 01:13:44,430
它一直读取，直到得到一个大于 10 的值，

1047
01:13:44,580 --> 01:13:50,160
然后我们确定真正的时间已经过去了，

1048
01:13:50,370 --> 01:13:53,850
它是安全的来提交事务，

1049
01:13:55,550 --> 01:13:59,480
所以现在 T3 之后运行的任何事务

1050
01:13:59,480 --> 01:14:03,170
都必须在真实时间 10 之后运行。

1051
01:14:05,660 --> 01:14:10,630
假设事务 3 在某个时间点开始，

1052
01:14:11,020 --> 01:14:14,560
并且事务 3 在 T2 之后开始，

1053
01:14:14,590 --> 01:14:16,780
所以我们现在绝对确定，

1054
01:14:16,780 --> 01:14:19,720
我们读到 x 是 2 ，

1055
01:14:19,990 --> 01:14:22,240
所以它将是读取 x ，

1056
01:14:23,020 --> 01:14:30,470
我们将询问当前时间，

1057
01:14:30,710 --> 01:14:33,380
可能会得到一个时间间隔，

1058
01:14:34,070 --> 01:14:39,050
时间间隔可能稍微重叠 T2 ，

1059
01:14:39,410 --> 01:14:45,230
但是这个时钟的真实时间可能是相当精确的，

1060
01:14:45,230 --> 01:14:47,780
时间间隔是从 10 到 12 ，

1061
01:14:47,810 --> 01:14:49,970
所以，真实时间是在 10 到 12 之间，

1062
01:14:50,980 --> 01:14:53,890
我们知道必须超过 10 ，

1063
01:14:53,890 --> 01:14:59,620
因为我们定义 T3 读取在 T2 之后，

1064
01:15:00,170 --> 01:15:02,570
这会正常的，

1065
01:15:02,570 --> 01:15:07,400
因为 T3 将选择它的时间戳，

1066
01:15:07,610 --> 01:15:09,950
时间间隔的结束，根据最新的规则，

1067
01:15:10,430 --> 01:15:15,440
所以， T3 会运行时间戳真实时间 12 ，

1068
01:15:15,650 --> 01:15:18,380
这将保证，

1069
01:15:18,380 --> 01:15:23,300
这个时间间隔我们知道一定会超过真实时间 10 ，

1070
01:15:23,780 --> 01:15:27,950
所以当 T3 读取时，读到 x 是 2 ，

1071
01:15:30,140 --> 01:15:33,830
因为它会观察到事务 2 的值，

1072
01:15:33,830 --> 01:15:38,540
因为它的读取超过了真实时间，

1073
01:15:39,260 --> 01:15:41,120
这肯定要付出一点延迟的代价，

1074
01:15:41,180 --> 01:15:43,550
但如果时钟相当精确，

1075
01:15:43,640 --> 01:15:45,500
正如我们之前所说的，

1076
01:15:45,500 --> 01:15:47,030
这个延迟是很小的。

1077
01:15:51,290 --> 01:15:52,130
这能理解吗？

1078
01:15:57,390 --> 01:15:59,040
抱歉，我有个问题，

1079
01:15:59,160 --> 01:16:06,570
如果 T2 表示它将在时间 10 开始一个事务，

1080
01:16:06,720 --> 01:16:11,160
然后当我们读到某个东西，

1081
01:16:11,190 --> 01:16:12,360
在同一个事务中，

1082
01:16:12,360 --> 01:16:16,170
我们还需要确保 10 在外面吗，

1083
01:16:16,170 --> 01:16:20,380
在 now 时间间隔之前。

1084
01:16:21,040 --> 01:16:22,360
这个问题是，

1085
01:16:22,360 --> 01:16:24,340
假设 T2 所做的不仅是写入，

1086
01:16:24,340 --> 01:16:25,960
进行读或写，

1087
01:16:26,260 --> 01:16:29,020
T2 应该观察到它自己的写入，

1088
01:16:29,440 --> 01:16:30,730
这是你要问的问题吗？

1089
01:16:32,030 --> 01:16:36,170
T2，当我们读取的时候，

1090
01:16:36,170 --> 01:16:39,200
比如，读取 y 。

1091
01:16:39,260 --> 01:16:42,020
是的，所以我们把这个加进去。

1092
01:16:46,810 --> 01:16:49,030
是的，或者在那之后。

1093
01:16:49,030 --> 01:16:53,650
是的，你的方式，在准备好之前是读取 y 。

1094
01:16:54,820 --> 01:17:00,150
好的，让我来，好的。

1095
01:17:03,330 --> 01:17:07,050
然后，哦，

1096
01:17:09,530 --> 01:17:11,780
好的，这可能是。

1097
01:17:11,780 --> 01:17:14,600
原因是读写事务并不那么关心，

1098
01:17:14,900 --> 01:17:17,870
如果你回到刚开始，

1099
01:17:18,630 --> 01:17:22,040
在这张图片上，

1100
01:17:22,310 --> 01:17:24,920
如果读写事务进行读取，

1101
01:17:24,950 --> 01:17:31,580
读取将发送给分片 master 或分片领导者，

1102
01:17:31,580 --> 01:17:33,350
如果你取消读取锁，

1103
01:17:33,820 --> 01:17:37,750
读取会，

1104
01:17:37,750 --> 01:17:40,930
客户端在本地执行所有操作，

1105
01:17:40,990 --> 01:17:42,940
它会获得读取值，

1106
01:17:42,970 --> 01:17:46,480
我们会读到最新的读取值，

1107
01:17:46,480 --> 01:17:51,920
在我们获得锁之后，

1108
01:17:52,250 --> 01:17:54,620
所以，在读写事务中，

1109
01:17:55,040 --> 01:17:57,410
锁完成了所有的全局排序，

1110
01:17:58,040 --> 01:18:00,230
两阶段锁确保全局排序，

1111
01:18:02,280 --> 01:18:04,800
所以真正有趣的互动是，

1112
01:18:04,920 --> 01:18:07,980
只读事务之间的交互，

1113
01:18:08,400 --> 01:18:12,720
即 T3 和读取事务之间。

1114
01:18:14,170 --> 01:18:16,840
一个是 T2 实际提交，

1115
01:18:17,140 --> 01:18:19,970
我们在它提交之前读取。

1116
01:18:20,760 --> 01:18:23,850
是的，所以读写事务中的协议是，

1117
01:18:23,850 --> 01:18:26,790
我们首先完成所有工作，

1118
01:18:27,400 --> 01:18:29,170
然后我们进入提交阶段，

1119
01:18:29,200 --> 01:18:31,240
所以这里是提交点，

1120
01:18:31,630 --> 01:18:35,410
或者这里是客户端提交事务的地方，

1121
01:18:35,890 --> 01:18:37,660
并将其发送给事务协调者，

1122
01:18:37,660 --> 01:18:40,960
然后事务协调者运行两阶段提交协议。

1123
01:18:42,250 --> 01:18:44,740
但是所有的分片，

1124
01:18:44,740 --> 01:18:46,150
需要锁，

1125
01:18:46,210 --> 01:18:50,020
事务实际使用的值（的锁）。

1126
01:19:02,340 --> 01:19:02,940
好的?

1127
01:19:10,860 --> 01:19:11,520
好的。

1128
01:19:12,280 --> 01:19:15,940
好的，让我们试着总结一下。

1129
01:19:23,560 --> 01:19:31,040
所以，读写事务是全局有序的，

1130
01:19:31,040 --> 01:19:35,510
或可串行化加上外部一致性，

1131
01:19:35,660 --> 01:19:40,340
因为它们执行两阶段提交加上两阶段锁，

1132
01:19:42,760 --> 01:19:45,670
只读事务比较特殊，

1133
01:19:46,450 --> 01:19:49,900
因为它们只联系本地 replica ，

1134
01:19:50,050 --> 01:19:53,620
而它们能看到正确的值的原因是，

1135
01:19:53,620 --> 01:19:55,090
因为快照隔离，

1136
01:19:59,950 --> 01:20:04,210
每个数据项都是版本化的，

1137
01:20:04,390 --> 01:20:08,920
并加了修改过的时间戳，

1138
01:20:09,340 --> 01:20:14,170
所以，你可以使用快照隔离读取过去的内容，

1139
01:20:14,680 --> 01:20:16,450
然后为了确保，

1140
01:20:16,450 --> 01:20:20,590
所以，快照隔离为我们提供了可串行化，

1141
01:20:25,090 --> 01:20:28,690
但是， Spanner 是为了更强的东西，

1142
01:20:28,720 --> 01:20:32,440
也就是，它是为了外部一致性属性，

1143
01:20:32,440 --> 01:20:33,880
就像是线性一致性，

1144
01:20:33,880 --> 01:20:35,890
所以它有一个实时的组件，

1145
01:20:38,990 --> 01:20:43,640
为了确保我们得到外部一致性，

1146
01:20:43,880 --> 01:20:47,600
我们按时间戳顺序执行只读操作，

1147
01:20:52,890 --> 01:20:55,530
因为时间戳顺序，

1148
01:20:55,530 --> 01:20:58,740
它需要完全同步的时钟，

1149
01:20:59,010 --> 01:21:02,730
Spanner 有点[依赖]规则

1150
01:21:02,940 --> 01:21:08,100
通过使用时间间隔，

1151
01:21:14,520 --> 01:21:16,830
而整个目标，

1152
01:21:16,920 --> 01:21:18,780
通过使用这些技术，

1153
01:21:18,900 --> 01:21:22,500
结果是，只读事务非常快，

1154
01:21:24,840 --> 01:21:28,350
读写事务不是特别快，

1155
01:21:28,350 --> 01:21:30,360
如果你看一下表 6 ，

1156
01:21:30,360 --> 01:21:33,900
读写事务的时间是 100 毫秒，

1157
01:21:33,900 --> 01:21:36,630
也就是说每秒只能做 10 个事务，

1158
01:21:36,810 --> 01:21:38,340
这真的不算多，

1159
01:21:38,640 --> 01:21:41,430
但只读事务速度很快。

1160
01:21:42,450 --> 01:21:44,850
现在，情况就是这样，

1161
01:21:45,090 --> 01:21:48,990
尽管读写事务可能没有那么快，

1162
01:21:49,080 --> 01:21:50,790
它们非常强大，

1163
01:21:50,850 --> 01:21:56,220
你是在跨多个分片执行事务性操作，

1164
01:21:56,220 --> 01:21:59,100
位于世界不同地区的不同数据中心，

1165
01:21:59,700 --> 01:22:04,260
对于程序员来说，这是一个非常方便和强大的工具，

1166
01:22:04,470 --> 01:22:11,790
你可以在世界各地复制跨分片的 ACID 语义。

1167
01:22:15,900 --> 01:22:18,870
所以，这是我想说的关于 Spanner 的所有事情，

1168
01:22:18,870 --> 01:22:21,360
我希望这是有帮助的，

1169
01:22:21,360 --> 01:22:25,650
你也许更少困惑或更多困惑，

1170
01:22:25,650 --> 01:22:27,210
因为这次课程，

1171
01:22:27,210 --> 01:22:30,300
但是，如果你有问题，请随意留在这里，

1172
01:22:30,300 --> 01:22:34,950
我很乐意讨论这一点或 Spanner 的任何其他方面。

1173
01:22:37,240 --> 01:22:39,130
祝你好运完成 3b ，

1174
01:22:39,160 --> 01:22:42,910
我希望你有时间享受这个长周末。

1175
01:22:47,560 --> 01:22:48,580
谢谢。

1176
01:22:51,000 --> 01:22:53,850
所以我有一个问题，也许在前面的幻灯片，

1177
01:22:53,850 --> 01:22:58,260
当你有两阶段提交的图表时，

1178
01:22:58,260 --> 01:23:00,360
对于读写事务，

1179
01:23:00,600 --> 01:23:07,280
所以在我们与 TC 通信之前，

1180
01:23:07,340 --> 01:23:09,170
TC 表示协调者吗？

1181
01:23:09,230 --> 01:23:11,240
是的，表示协调者，是的。

1182
01:23:11,390 --> 01:23:14,060
好的，所以在我们和事务协调者通信之前，

1183
01:23:14,060 --> 01:23:16,550
当我们最初读取 x 和 y 时，

1184
01:23:16,790 --> 01:23:19,940
我们不和 TC 做任何通信，

1185
01:23:21,440 --> 01:23:24,260
所以我的问题是，这些读取的本质是什么，

1186
01:23:24,260 --> 01:23:26,180
我们是否将它们视为只读的，

1187
01:23:26,210 --> 01:23:28,220
所以我们从离我们最近的 replica 中读取，

1188
01:23:28,220 --> 01:23:32,210
或者我们执行大多数类型的通信。

1189
01:23:32,870 --> 01:23:37,460
我们是去找参与者的领导者，

1190
01:23:37,760 --> 01:23:39,110
去找 Paxos 领导者。

1191
01:23:40,610 --> 01:23:41,810
我明白了，所以是这样的，

1192
01:23:41,840 --> 01:23:43,790
好的，就像实验 3 一样。

1193
01:23:45,160 --> 01:23:45,640
抱歉?

1194
01:23:45,910 --> 01:23:51,160
所以，这里的读取 x 和实验 3 中的一样，

1195
01:23:51,160 --> 01:23:52,210
所以它通过领导者，

1196
01:23:52,210 --> 01:23:54,400
它会复制到整个。

1197
01:23:54,430 --> 01:23:56,800
不，它是，没有，

1198
01:23:56,800 --> 01:24:01,360
我相信没有读取通过 Paxos ，

1199
01:24:01,360 --> 01:24:06,280
通过事务领导者，抱歉， Paxos 领导者，

1200
01:24:06,280 --> 01:24:09,340
Paxos 领导者当然知道上一次写的是什么。

1201
01:24:09,840 --> 01:24:12,360
但是，如果，比如，我们有一些失败，

1202
01:24:12,360 --> 01:24:14,520
领导者认为它是领导者，

1203
01:24:14,520 --> 01:24:15,570
但是在某些分区中，

1204
01:24:15,570 --> 01:24:17,160
它更新了信息。

1205
01:24:18,800 --> 01:24:20,390
我不太清楚，

1206
01:24:20,390 --> 01:24:21,950
他们是怎么处理这种情况的。

1207
01:24:21,950 --> 01:24:24,680
我认为租约让这变得不可能。

1208
01:24:24,710 --> 01:24:29,420
是的，所以他们有，

1209
01:24:29,810 --> 01:24:32,330
所以每个领导者在一段时间内是领导者，

1210
01:24:33,460 --> 01:24:36,520
在那段时间里，

1211
01:24:36,520 --> 01:24:37,840
没有其他领导者可以成为领导者。

1212
01:24:38,560 --> 01:24:40,720
好的，我明白了，太棒了，谢谢。

1213
01:24:42,360 --> 01:24:43,830
谢谢你提醒。

1214
01:24:44,860 --> 01:24:49,270
我对上一张时间间隔的图有个问题，

1215
01:24:51,160 --> 01:24:55,900
我在想如果读取 T3 ，

1216
01:24:56,050 --> 01:24:58,720
或者假设 T2 中的写入，

1217
01:24:59,110 --> 01:25:01,750
时间间隔也从 1 到 12 ，

1218
01:25:01,780 --> 01:25:05,320
这样， T2 的写入发生在 12 ，

1219
01:25:05,320 --> 01:25:07,300
而 T3 读取也发生在 12 ，

1220
01:25:07,300 --> 01:25:08,710
在这种情况下会发生什么？

1221
01:25:09,710 --> 01:25:13,520
好的，如果你[说更多]。

1222
01:25:13,520 --> 01:25:16,550
好的，所以对于 T2 ，

1223
01:25:16,550 --> 01:25:18,650
现在的写入，是从 1 到 10 ，

1224
01:25:19,010 --> 01:25:21,920
然后在 12 会发生什么，

1225
01:25:21,920 --> 01:25:24,680
它与事务 3 一样。

1226
01:25:24,950 --> 01:25:26,660
12 不是 2 。

1227
01:25:27,160 --> 01:25:30,400
我想的是 12 ，抱歉，我的意思是。

1228
01:25:31,800 --> 01:25:35,040
所以如果这个，

1229
01:25:35,070 --> 01:25:42,510
所以，事务 2 会使用 12 作为开始时间，

1230
01:25:43,240 --> 01:25:47,530
在读写事务的情况下，

1231
01:25:48,010 --> 01:25:54,960
它将等待，直到在时间间隔中出现 12 ，然后提交，

1232
01:25:55,740 --> 01:25:58,320
所以，真实时间在 1 到 12 之间，

1233
01:25:58,380 --> 01:26:01,590
至少要等到 13 ，

1234
01:26:01,590 --> 01:26:04,890
真实时间现在肯定已经过了 12 。

1235
01:26:05,250 --> 01:26:05,760
是的。

1236
01:26:06,000 --> 01:26:10,470
现在我们知道 T3 在 T2 之后开始，

1237
01:26:11,060 --> 01:26:13,970
它永远不会返回这个时间间隔，

1238
01:26:13,970 --> 01:26:17,210
因为真正的时间已经过了 13 ，

1239
01:26:18,020 --> 01:26:20,000
或者已经过了 12 ，

1240
01:26:21,420 --> 01:26:24,390
所以当这个现在读取它的时钟时，

1241
01:26:24,630 --> 01:26:26,790
我们知道会有一个时间间隔，

1242
01:26:27,090 --> 01:26:28,920
也许还包括 10 ，

1243
01:26:29,190 --> 01:26:34,170
但是将包括 14 或 13 ，

1244
01:26:35,540 --> 01:26:37,820
我们会选择 latest 值，

1245
01:26:37,970 --> 01:26:39,590
所以我们假设选择 14 ，

1246
01:26:40,540 --> 01:26:43,600
所以它会在 14 做时间戳。

1247
01:26:46,230 --> 01:26:49,650
所以，这种情况就不会发生，

1248
01:26:49,650 --> 01:26:53,970
因为时间间隔可以保证最早的和最晚的。

1249
01:26:54,150 --> 01:26:57,450
是的，这是 T3 肯定是在 T2 之后开始的情况，

1250
01:26:59,340 --> 01:27:00,390
根据定义，

1251
01:27:00,390 --> 01:27:01,980
这就是我们建立示例的方式。

1252
01:27:02,980 --> 01:27:05,080
然后如果，

1253
01:27:05,170 --> 01:27:08,800
读取发生在提交的同一时间，

1254
01:27:08,800 --> 01:27:10,360
不一定是在严格的之后，

1255
01:27:10,360 --> 01:27:14,080
在这种情况下，有什么保证，

1256
01:27:14,440 --> 01:27:16,810
比如它有没有。

1257
01:27:17,080 --> 01:27:18,070
好问题，

1258
01:27:18,070 --> 01:27:20,380
所以记得线性一致性的定义，

1259
01:27:20,380 --> 01:27:23,890
如果 T2 和 T3 几乎同时运行，

1260
01:27:23,890 --> 01:27:25,570
真的同时运行，

1261
01:27:26,500 --> 01:27:27,850
也没有关系，

1262
01:27:27,850 --> 01:27:30,400
T3 可以在 T2 之前或之后。

1263
01:27:32,200 --> 01:27:32,950
好的。

1264
01:27:33,850 --> 01:27:36,130
那么可串行化方面呢，

1265
01:27:36,400 --> 01:27:38,020
如果它们再次执行，

1266
01:27:38,020 --> 01:27:40,480
可能不一定是相同的顺序。

1267
01:27:41,880 --> 01:27:44,460
以一个整体顺序执行，

1268
01:27:44,460 --> 01:27:48,840
T3 或者在 T2 之前或者在 T2 之后，

1269
01:27:49,320 --> 01:27:51,090
但这两种顺序都没问题，

1270
01:27:51,090 --> 01:27:54,210
两者都是可串行化或线性一致性所允许的，

1271
01:27:54,330 --> 01:27:56,280
因为执行是真正同时进行的，

1272
01:27:57,030 --> 01:28:01,470
T3 在 T2 提交之前开始。

1273
01:28:02,200 --> 01:28:04,150
明白了，然后对于 T3 来说，

1274
01:28:04,150 --> 01:28:06,610
如果提交和读取同时发生，

1275
01:28:06,670 --> 01:28:09,010
T3 会读到什么，

1276
01:28:09,040 --> 01:28:12,970
将取决于 replica 是否读取到那个提交。

1277
01:28:14,980 --> 01:28:15,070
是的。

1278
01:28:15,070 --> 01:28:16,030
非常感谢。

1279
01:28:16,360 --> 01:28:17,770
不用谢，好问题。

1280
01:28:19,240 --> 01:28:21,730
我有一个问题，

1281
01:28:22,360 --> 01:28:26,600
如果我在这张图片上看到，

1282
01:28:26,660 --> 01:28:30,080
而当它试图提交 12 的时候，并不在那里，

1283
01:28:30,080 --> 01:28:32,930
它会重试并再次等待。

1284
01:28:33,050 --> 01:28:34,430
好的。

1285
01:28:34,430 --> 01:28:38,240
它继续读取时钟直到获得时间间隔，

1286
01:28:38,240 --> 01:28:43,280
earliest 已经超过了它的时间戳。

1287
01:28:44,640 --> 01:28:49,440
好的，我还要确认一下，

1288
01:28:49,830 --> 01:28:52,020
它提供的保证是，

1289
01:28:52,350 --> 01:28:56,760
如果在时间戳 x ，

1290
01:28:57,740 --> 01:29:03,320
当 x 在 now 时间间隔之前，

1291
01:29:04,550 --> 01:29:11,130
这个机器或 Paxos 组将看到一切正常，

1292
01:29:11,130 --> 01:29:14,280
我想机器已经看到了发生的一切，

1293
01:29:15,740 --> 01:29:19,570
在 x 之前，对吗？

1294
01:29:20,050 --> 01:29:21,640
是的，我想或多或少是这样的，

1295
01:29:21,640 --> 01:29:24,070
我没听说过，在你提问之前，

1296
01:29:24,070 --> 01:29:26,410
但我们获得时间间隔，

1297
01:29:26,410 --> 01:29:27,580
我们所知道的是，

1298
01:29:27,580 --> 01:29:29,500
真正的时间是在这个时间间隔的某个地方，

1299
01:29:30,600 --> 01:29:31,770
所以这是真正的时间，

1300
01:29:34,610 --> 01:29:36,470
所以当我们开始准备的时候，

1301
01:29:36,590 --> 01:29:40,070
真正的时间没有超过 12 ，

1302
01:29:40,760 --> 01:29:43,160
但它在 1 到 12 之间，

1303
01:29:43,400 --> 01:29:44,720
所以当我们提交的时候，

1304
01:29:44,750 --> 01:29:45,920
我们必须确保，

1305
01:29:45,920 --> 01:29:48,530
提交确实发生在真实时间之后，

1306
01:29:49,160 --> 01:29:50,840
所以我们要再等一段时间，

1307
01:29:50,840 --> 01:29:53,570
所以我们知道我们大于 12 ，

1308
01:29:53,720 --> 01:29:57,260
我们等到时钟给出一个时间间隔，

1309
01:29:57,410 --> 01:30:00,110
真实时间肯定过了 12 。

1310
01:30:03,040 --> 01:30:05,530
我想我想问的是，

1311
01:30:05,620 --> 01:30:06,730
如果你选择 12 ，

1312
01:30:06,760 --> 01:30:11,020
然后你的时间间隔返回了 13 到 20 ，

1313
01:30:11,080 --> 01:30:13,960
你知道任何，

1314
01:30:14,800 --> 01:30:18,820
例如小于或等于 12 的时间戳，

1315
01:30:19,060 --> 01:30:21,430
对这些事务的更改，

1316
01:30:21,430 --> 01:30:23,740
你就能看到它们了。

1317
01:30:23,830 --> 01:30:24,430
是的。

1318
01:30:25,250 --> 01:30:25,760
好的。

1319
01:30:27,140 --> 01:30:30,060
好的，理解了，谢谢。

1320
01:30:32,710 --> 01:30:36,700
所以我不完全理解提交等待的是什么，

1321
01:30:37,090 --> 01:30:39,010
因为看起来是，

1322
01:30:39,040 --> 01:30:42,280
提交等待发生在你选择了时间戳之后，

1323
01:30:42,280 --> 01:30:44,680
对于你感兴趣的事务，

1324
01:30:45,010 --> 01:30:47,800
你只需推迟真实时间，

1325
01:30:47,800 --> 01:30:51,600
这让你提交只是为了确保。

1326
01:30:51,600 --> 01:30:55,200
不，但是提交时间，你已经开始更新数据库。

1327
01:30:56,500 --> 01:30:57,220
嗯。

1328
01:30:57,220 --> 01:30:59,650
所以在提交的时候，你必须提交，

1329
01:30:59,650 --> 01:31:03,670
比如 T3 不会运行直到 C 之后。

1330
01:31:04,680 --> 01:31:05,460
是的。

1331
01:31:05,940 --> 01:31:07,500
因为这是我们的定义，

1332
01:31:07,500 --> 01:31:09,690
T3 在 T2 提交之后开始。

1333
01:31:10,250 --> 01:31:11,300
是的，

1334
01:31:11,540 --> 01:31:13,250
如果不这样，会发生什么，

1335
01:31:13,250 --> 01:31:14,240
你会失去什么，

1336
01:31:14,240 --> 01:31:15,950
如果你没有。

1337
01:31:16,250 --> 01:31:18,050
那么， T3 将与 T2 同时运行。

1338
01:31:20,980 --> 01:31:21,610
好的，稍等。

1339
01:31:21,640 --> 01:31:22,630
我明白了。

1340
01:31:22,930 --> 01:31:25,300
我不确定你想探索哪种场景，

1341
01:31:25,300 --> 01:31:29,980
但是，如果我们允许 T3 在 C 之前开始，

1342
01:31:30,470 --> 01:31:32,960
那么我们的故事完全不同了，

1343
01:31:32,960 --> 01:31:34,340
因为没什么好讨论的，

1344
01:31:34,370 --> 01:31:36,590
因为 T3 与 T2 同时运行，

1345
01:31:36,590 --> 01:31:39,410
它可以观察到 T 或不会，然后结束。

1346
01:31:39,800 --> 01:31:42,740
好的，我明白了。

1347
01:31:43,620 --> 01:31:45,540
所以 C 的时间戳，

1348
01:31:45,540 --> 01:31:46,680
我们在等待那些，

1349
01:31:46,680 --> 01:31:48,480
我们传递真实时间，

1350
01:31:49,060 --> 01:31:54,100
我们得到准备好的编号的开始，

1351
01:31:54,190 --> 01:31:57,460
所以我们知道真实时间已经过去了。

1352
01:31:58,270 --> 01:31:59,230
这是。

1353
01:31:59,230 --> 01:32:04,000
T3 永远不会选择一个真实时间，

1354
01:32:04,000 --> 01:32:08,860
在 T2 提交之前。

1355
01:32:11,610 --> 01:32:15,530
我明白了，好的。

1356
01:32:15,890 --> 01:32:19,190
我想像是一切都已经是版本了，

1357
01:32:19,190 --> 01:32:21,770
如果你修改数据，

1358
01:32:21,770 --> 01:32:24,830
你修改了之前的数据，这是可以的，

1359
01:32:24,830 --> 01:32:27,560
因为每样东西都有时间戳，

1360
01:32:27,560 --> 01:32:28,310
所以没有，

1361
01:32:28,640 --> 01:32:32,000
从很远的地方看，这似乎是不做错事，

1362
01:32:32,330 --> 01:32:37,040
比如查看他们定义的外部一致性，

1363
01:32:37,250 --> 01:32:40,250
我不明白它和线性一致性有什么相似之处，

1364
01:32:40,250 --> 01:32:41,150
因为它只是说，

1365
01:32:41,550 --> 01:32:44,910
如果一个事务在另一个事务开始之前提交，

1366
01:32:45,090 --> 01:32:48,630
然后第一个会有比后一个较小的时间戳，

1367
01:32:48,780 --> 01:32:50,700
这在某种程度上也隐含了，

1368
01:32:50,970 --> 01:32:54,930
事务按其时间戳顺序执行。

1369
01:32:54,930 --> 01:32:58,590
是的，也许我的短暂[]没那么好，

1370
01:32:58,950 --> 01:33:01,920
但是，是的，当然，

1371
01:33:01,920 --> 01:33:03,780
真正的要求是，

1372
01:33:03,990 --> 01:33:07,790
如果事务在之后开始，

1373
01:33:07,790 --> 01:33:10,280
如果 T2 在 T1 提交之后开始，

1374
01:33:10,820 --> 01:33:14,330
T2 必须观察到 T1 的所有写入。

1375
01:33:14,690 --> 01:33:16,580
嗯，是的。

1376
01:33:19,250 --> 01:33:19,760
我明白了，

1377
01:33:19,760 --> 01:33:21,560
我想时间，

1378
01:33:21,560 --> 01:33:25,610
知道 T2 的时间戳大于 T1 会告诉你，

1379
01:33:25,610 --> 01:33:28,070
你将会观察到 T1 的所有东西。

1380
01:33:28,250 --> 01:33:29,720
好的，我明白了，理解了。

1381
01:33:29,720 --> 01:33:30,440
好的。

1382
01:33:30,940 --> 01:33:31,630
好的，谢谢。

1383
01:33:31,960 --> 01:33:32,500
不用谢。

1384
01:33:40,240 --> 01:33:43,570
还有没有其他问题，如果还有人的话。

1385
01:33:46,820 --> 01:33:52,010
我对 4.2.3 部分有一个问题，

1386
01:33:52,430 --> 01:33:54,710
事务模式更改一节。

1387
01:33:54,710 --> 01:33:57,080
是的，我没有讲这个。

1388
01:33:58,070 --> 01:33:59,660
我只是好奇，

1389
01:33:59,690 --> 01:34:03,140
因为，他们谈论的预测提交的时间。

1390
01:34:05,490 --> 01:34:06,720
好的，可能是，

1391
01:34:06,720 --> 01:34:07,500
让我想想,

1392
01:34:07,500 --> 01:34:09,360
我会告诉你我怎么想的，

1393
01:34:09,540 --> 01:34:13,500
然后你可以告诉我困惑在哪里，

1394
01:34:13,770 --> 01:34:16,170
所以模式更改意味着，

1395
01:34:16,170 --> 01:34:20,010
向表中添加列或删除表中的列，

1396
01:34:20,010 --> 01:34:21,090
或这些行的其他内容，

1397
01:34:21,120 --> 01:34:26,160
所以它改变了数据库的布局，

1398
01:34:26,750 --> 01:34:31,070
模式更改通常代价高昂，

1399
01:34:31,070 --> 01:34:33,560
他们确保原子的，

1400
01:34:33,560 --> 01:34:35,000
在遥远的未来运行，

1401
01:34:36,080 --> 01:34:38,210
所以他们使用时间戳，

1402
01:34:38,210 --> 01:34:39,800
超越了当前的时间，

1403
01:34:40,600 --> 01:34:43,900
所以我想事务做自己的事，

1404
01:34:43,900 --> 01:34:47,800
因为其他所有事务都使用版本内存，

1405
01:34:47,950 --> 01:34:51,550
他们创建版本内存直到遥远的未来，

1406
01:34:52,240 --> 01:34:55,060
所以，它不会影响当前运行的任何事务，

1407
01:34:56,250 --> 01:35:02,370
现在通信要花很长时间，

1408
01:35:02,370 --> 01:35:08,580
在他们想要提交模式迁移部分时，

1409
01:35:08,910 --> 01:35:11,220
那里的事务，

1410
01:35:11,220 --> 01:35:17,280
他们开始[]迁移事务开始的时间，

1411
01:35:18,540 --> 01:35:21,420
所以那些事务是按时间前进的，

1412
01:35:21,420 --> 01:35:22,800
我们执行事务，

1413
01:35:23,160 --> 01:35:25,950
然后规则是任何读写事务

1414
01:35:25,950 --> 01:35:29,520
或者任何只读或任何事务都必须停止，

1415
01:35:31,620 --> 01:35:37,410
直到迁移事务完成，

1416
01:35:39,220 --> 01:35:44,080
因为迁移事务时间戳是新值，

1417
01:35:44,080 --> 01:35:45,250
有它的时间戳。

1418
01:35:46,820 --> 01:35:50,660
所以，当有迁移请求时，

1419
01:35:52,020 --> 01:35:56,220
它选择一个遥远的未来的提交时间，并且。

1420
01:35:56,430 --> 01:36:01,780
你希望那个事务也提交了。

1421
01:36:01,780 --> 01:36:03,220
是的，到那时。

1422
01:36:04,150 --> 01:36:11,200
所以，在此之前的任何读取都是从当前提供的。

1423
01:36:11,230 --> 01:36:13,210
所有的本地的 replica ，

1424
01:36:13,210 --> 01:36:15,280
因为它们已经看到写入了。

1425
01:36:16,940 --> 01:36:20,450
好的，这是个很酷的技巧，

1426
01:36:20,450 --> 01:36:21,560
如果你有版本内存，

1427
01:36:21,560 --> 01:36:23,120
你可以把事情安排在未来。

1428
01:36:24,020 --> 01:36:24,890
是的，这是个很酷的技巧，

1429
01:36:24,890 --> 01:36:25,520
我只是在想，

1430
01:36:25,520 --> 01:36:31,330
他们到底是怎么想出未来的这一点的。

1431
01:36:32,790 --> 01:36:37,890
是的，可能是[]或什么东西，好的。

1432
01:36:38,390 --> 01:36:39,470
所以，但从本质上说，

1433
01:36:39,470 --> 01:36:45,580
如果你不选择一个足够远的时间，

1434
01:36:46,360 --> 01:36:48,070
那你就得冒着风险。

1435
01:36:48,190 --> 01:36:49,030
没错。

1436
01:36:49,120 --> 01:36:51,430
好的，那么会有错误的结果。

1437
01:36:52,270 --> 01:36:56,110
为避免错误结果的风险，这会阻塞。

1438
01:36:56,730 --> 01:37:00,500
是的，我明白了，好的。

1439
01:37:01,060 --> 01:37:02,560
太棒了，非常感谢。

1440
01:37:02,920 --> 01:37:03,490
不用谢。

1441
01:37:03,640 --> 01:37:04,000
再见。

