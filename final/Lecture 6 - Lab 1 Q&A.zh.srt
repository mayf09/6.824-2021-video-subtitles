1
00:00:05,230 --> 00:00:07,390
好的，已经五点了，

2
00:00:07,390 --> 00:00:09,070
所以我就开始了。

3
00:00:09,310 --> 00:00:13,600
所以今天的课程是第一个实验的问答，

4
00:00:13,600 --> 00:00:14,620
MapReduce 实验，

5
00:00:14,920 --> 00:00:19,480
还有一些关于 Go 编程的通用编码问答，

6
00:00:19,480 --> 00:00:21,010
可能会对未来的实验有所帮助。

7
00:00:21,100 --> 00:00:23,110
所以你可以随时停下来，

8
00:00:23,110 --> 00:00:24,430
或者在聊天中提出问题，

9
00:00:24,430 --> 00:00:26,620
我会偶尔检查一下，

10
00:00:27,280 --> 00:00:31,000
我相信其他[]也能提供帮助，

11
00:00:31,570 --> 00:00:33,970
如果你未静音并且正在打字，

12
00:00:34,340 --> 00:00:35,480
如果你静音，会很有帮助，

13
00:00:37,760 --> 00:00:38,660
不过，是的。

14
00:00:38,750 --> 00:00:41,000
好的，那么今天的议程，

15
00:00:41,000 --> 00:00:42,440
我要做的第一件事是，

16
00:00:42,440 --> 00:00:44,600
演示实验 1 的解决方案，

17
00:00:44,900 --> 00:00:47,330
这是我个人的解决方案，

18
00:00:47,330 --> 00:00:49,370
它可能并不完美，

19
00:00:49,370 --> 00:00:52,040
但这是你可以做的一个例子，

20
00:00:52,460 --> 00:00:56,150
第二，我们将讨论一些替代的解决方案设计，

21
00:00:56,810 --> 00:01:00,740
还有人在打字。

22
00:01:00,740 --> 00:01:01,550
[]，停止打字。

23
00:01:02,980 --> 00:01:07,000
好的，很有帮助，

24
00:01:07,300 --> 00:01:12,250
第三，我们将讨论一些常见的设计错误和一些 bug ，

25
00:01:12,250 --> 00:01:14,620
在你们的解决方案中，

26
00:01:14,980 --> 00:01:17,770
第四，一些一般性的提示，

27
00:01:17,770 --> 00:01:22,180
最后，如果有时间，我们会进行一些问答，

28
00:01:22,180 --> 00:01:24,730
你现在可能会有的问题，

29
00:01:24,790 --> 00:01:30,660
还有你在讲课前提交的问题。

30
00:01:31,750 --> 00:01:35,590
所以，首先是实验解决方案演示，

31
00:01:35,680 --> 00:01:38,800
如果字体太小，请告诉我，

32
00:01:38,800 --> 00:01:40,210
我还是放在这里。

33
00:01:40,950 --> 00:01:46,400
好的，所以我基本上一步一步地，

34
00:01:46,400 --> 00:01:48,500
我将展示我是如何开发我的解决方案的。

35
00:01:48,770 --> 00:01:51,530
所以我做的第一件事是，

36
00:01:51,800 --> 00:01:53,630
这是 rpc.go ，

37
00:01:53,960 --> 00:01:56,960
我做的第一件事就是弄清楚 API ，

38
00:01:56,960 --> 00:01:59,840
我想让 worker 和 coordinator 进行交流，

39
00:02:00,530 --> 00:02:06,050
所以我做的第一件事就是定义有哪些类型的任务，

40
00:02:06,470 --> 00:02:08,300
所以这里有 Map 和 Reduce 任务，

41
00:02:08,300 --> 00:02:10,430
并且为了表示，

42
00:02:10,550 --> 00:02:14,390
coordinator 任务已完成，是 Done 任务，

43
00:02:14,940 --> 00:02:17,130
所以，这些都是任务的类型。

44
00:02:17,820 --> 00:02:21,570
你能放大一点吗，这个文件？

45
00:02:21,570 --> 00:02:24,330
好的，这样可以吗？

46
00:02:26,410 --> 00:02:28,090
好的，谢谢。

47
00:02:29,060 --> 00:02:32,750
酷，是的，我很难确定它看起来是什么样子，

48
00:02:33,740 --> 00:02:35,930
好的，我希望这是好的。

49
00:02:36,200 --> 00:02:42,550
所以，我决定实现这两个 RPC ，

50
00:02:42,730 --> 00:02:46,390
第一个是 worker 请求 coordinator 给它一个任务，

51
00:02:46,540 --> 00:02:49,960
Map Reduce 中的一个或 Done 用来退出，

52
00:02:50,290 --> 00:02:53,830
基本上就是这些参数，

53
00:02:53,830 --> 00:02:57,400
并没有参数，只是请求一个任务，

54
00:02:57,430 --> 00:03:01,420
coordinator 回答这是什么任务，

55
00:03:01,450 --> 00:03:04,240
你应该做哪种类型的任务，

56
00:03:05,240 --> 00:03:10,220
还有一些 Map 或 Reduce 任务需要的额外数据，

57
00:03:10,220 --> 00:03:12,590
例如系统中 Map 任务的数量，

58
00:03:12,680 --> 00:03:14,300
或者 Reduce 任务的数量。

59
00:03:15,380 --> 00:03:19,040
第二个 RPC 是完成任务的 RPC ，

60
00:03:19,070 --> 00:03:21,680
worker 用它来通知 coordinator ，

61
00:03:21,980 --> 00:03:23,660
它已经完成了任务，

62
00:03:23,720 --> 00:03:27,860
它将哪项任务已完成作为参数传递，

63
00:03:28,450 --> 00:03:31,150
它们并不需要得到回复。

64
00:03:32,000 --> 00:03:34,820
所以这是实现的第一步，

65
00:03:38,390 --> 00:03:39,350
所以。

66
00:03:40,190 --> 00:03:42,320
好的，作为第二步，

67
00:03:42,350 --> 00:03:45,740
我所做的是为所有这些 RPC 实现处理程序，

68
00:03:45,980 --> 00:03:47,900
所以这在 coordinator 中，

69
00:03:49,070 --> 00:03:53,870
因此，首先我必须用 coordinator 状态填充 coordinator ，

70
00:03:54,200 --> 00:03:57,830
这里有一个 Mutex 保护状态的并发访问，

71
00:03:57,830 --> 00:04:01,880
因为 coordinator 将有多个并发运行的线程，

72
00:04:02,180 --> 00:04:07,880
第二部分是跟踪我们在 Map 任务所需要的文件，

73
00:04:08,030 --> 00:04:09,860
以及 Map 和 Reduce 任务的数量，

74
00:04:10,510 --> 00:04:16,780
这些元数据被用来跟踪我们发出了哪些任务，

75
00:04:16,930 --> 00:04:18,580
以及哪些任务已经完成，

76
00:04:18,880 --> 00:04:23,050
一旦我们发布，我们会跟踪时间戳，

77
00:04:23,050 --> 00:04:26,320
我们知道如果这些任务没有在一定的时间内完成，

78
00:04:26,320 --> 00:04:27,520
就重新发布它们，

79
00:04:28,390 --> 00:04:32,500
最后，我们有，有所有的，

80
00:04:32,680 --> 00:04:35,050
有一个 coordinator 完成的布尔值。

81
00:04:36,780 --> 00:04:40,320
所以，为了处理 GetTask RPC ，我们有一个处理程序，

82
00:04:40,590 --> 00:04:44,310
从本质上讲，它所做的是，

83
00:04:44,430 --> 00:04:46,380
它会设置 reply 字段，

84
00:04:46,650 --> 00:04:51,540
现在，我还没有实现发布任务的部分，

85
00:04:51,990 --> 00:04:55,050
如果所有的 Map 和 Reduce 任务都完成了，

86
00:04:55,140 --> 00:04:58,230
它将发送一个 Done 任务给 worker 并退出。

87
00:04:59,190 --> 00:05:05,520
然后我们有 FinishedTask RPC 的处理程序，

88
00:05:05,820 --> 00:05:07,080
这个所做的是，

89
00:05:07,080 --> 00:05:10,290
它取决于是什么任务，

90
00:05:10,920 --> 00:05:13,980
将那个标志设置为 true ，

91
00:05:13,980 --> 00:05:16,410
那个任务已经完成。

92
00:05:17,550 --> 00:05:19,020
这就是第二步，

93
00:05:19,020 --> 00:05:21,240
实现 RPC 的处理程序。

94
00:05:24,120 --> 00:05:28,890
所以，我的第三步是发送 RPC ，

95
00:05:29,610 --> 00:05:33,890
就是这里的工作。

96
00:05:35,930 --> 00:05:41,690
所以，这个最上面，

97
00:05:41,990 --> 00:05:44,000
我们提供的是，

98
00:05:44,000 --> 00:05:45,200
它启动这个循环，

99
00:05:45,560 --> 00:05:48,320
在每个循环中，

100
00:05:48,320 --> 00:05:52,160
它调用在 coordinator 中 GetTask 的处理程序，

101
00:05:52,760 --> 00:05:54,470
根据它获得的任务的不同，

102
00:05:54,470 --> 00:05:58,430
它将使用相关数据执行 Map 任务，

103
00:05:58,430 --> 00:06:01,310
或需要执行 Reduce 任务的元数据，

104
00:06:01,310 --> 00:06:02,990
或者在 Done 的情况下，它将退出。

105
00:06:03,570 --> 00:06:05,670
所以这很简单，

106
00:06:05,670 --> 00:06:06,960
一旦它完成了这项任务，

107
00:06:07,170 --> 00:06:11,070
它将发送一个 FinishedTask RPC 给 coordinator 。

108
00:06:11,620 --> 00:06:17,650
所以，这只是 worker 发送 RPC 的框架代码。

109
00:06:19,100 --> 00:06:21,950
好的，我们有 RPC ，我们有处理程序，我们有发送者，

110
00:06:22,160 --> 00:06:24,800
所以现在，让我们来实现一些东西。

111
00:06:25,220 --> 00:06:29,900
所以在第四步中，

112
00:06:29,930 --> 00:06:35,990
我只是添加了大量的处理程序来管理这个中间文件，

113
00:06:36,590 --> 00:06:38,780
你们中的许多人也这样做了，

114
00:06:39,200 --> 00:06:41,990
基本上它使用了比如 os.Rename ，

115
00:06:41,990 --> 00:06:43,730
它会得到一个临时文件，

116
00:06:44,900 --> 00:06:46,550
所以这并不太有趣，

117
00:06:47,150 --> 00:06:48,530
然后，下一步，

118
00:06:48,560 --> 00:06:51,890
让我们实现一些 worker 的功能。

119
00:06:52,430 --> 00:06:54,930
所以，我们又回到了 worker ，

120
00:06:55,900 --> 00:06:58,930
现在让我们实现 PerformMap 函数，

121
00:07:00,270 --> 00:07:04,740
这样做的目的是，你们中许多已经做的是，

122
00:07:04,770 --> 00:07:07,650
读取文件，将它们映射到键上，

123
00:07:07,710 --> 00:07:12,360
然后创建临时文件，将它们写入中间文件，

124
00:07:12,360 --> 00:07:15,000
然后我们使用原子重命名，

125
00:07:15,030 --> 00:07:17,520
以确保映射不会冲突

126
00:07:17,520 --> 00:07:19,590
在处理键和写入键时。

127
00:07:20,550 --> 00:07:25,410
所以这在很大程度上是从顺序实现中提取出来的，

128
00:07:25,440 --> 00:07:27,390
以及如何应用 Map 函数。

129
00:07:28,590 --> 00:07:34,590
然后，类似地，我们实现 Reduce 函数，

130
00:07:34,860 --> 00:07:36,780
这里有一个 performMap ，

131
00:07:36,900 --> 00:07:38,640
然后我们有一个 performReduce ，

132
00:07:39,000 --> 00:07:40,440
所以它所做的就是，

133
00:07:40,440 --> 00:07:44,040
它会获取所有中间文件，

134
00:07:44,340 --> 00:07:47,850
从所有 Map 任务，到这个 Reduce 任务，

135
00:07:48,510 --> 00:07:54,640
并对它们进行排序，排序发生在 worker 上，

136
00:07:54,670 --> 00:07:56,710
因为 worker 需要，

137
00:07:56,800 --> 00:08:00,070
reducer 需要访问这个类型的所有键，

138
00:08:00,100 --> 00:08:01,840
然后对它们进行排序。

139
00:08:03,240 --> 00:08:04,770
对于 mapper 是没有意义的，

140
00:08:04,770 --> 00:08:05,880
在之前对它们进行排序，

141
00:08:05,910 --> 00:08:08,940
因为 mapper 只访问一些键。

142
00:08:10,440 --> 00:08:13,860
然后我们对同一个键的所有值应用 reduce 函数，

143
00:08:13,860 --> 00:08:19,080
然后，我们将临时 reduce 文件原子重命名为最终的 reduce 文件。

144
00:08:20,470 --> 00:08:24,370
所以，现在我们实现的这个循环，

145
00:08:25,000 --> 00:08:27,190
执行任务，

146
00:08:27,220 --> 00:08:30,670
我们基本上完成了 worker 的实现。

147
00:08:31,820 --> 00:08:33,350
所以还剩下最后一步，

148
00:08:33,410 --> 00:08:35,390
这是实现，

149
00:08:35,390 --> 00:08:39,260
coordinator 如何告诉 worker 要做哪些任务，

150
00:08:39,620 --> 00:08:41,030
这可能是，

151
00:08:41,030 --> 00:08:46,940
你在 coordinator 中遇到的最复杂的同步问题。

152
00:08:49,040 --> 00:08:50,450
所以，回到 coordinator ，

153
00:08:51,500 --> 00:08:54,590
所以这个状态什么都没有改变，

154
00:08:55,010 --> 00:08:56,720
但现在我们所做的是，

155
00:08:56,720 --> 00:08:58,700
我们在 coordinate 中添加了一个循环，

156
00:08:58,730 --> 00:09:01,310
它负责将任务发送给 worker 。

157
00:09:02,720 --> 00:09:07,170
当我们发布 Map 任务时，

158
00:09:07,170 --> 00:09:09,420
所以首先我们想要发布所有的 Map 任务，

159
00:09:09,780 --> 00:09:14,010
基本上这个循环在这里所做的是，

160
00:09:14,040 --> 00:09:16,650
在有任务要发布之前，

161
00:09:16,830 --> 00:09:21,930
coordinator 只是迭代这个循环，

162
00:09:22,200 --> 00:09:23,910
如果我们完成了所有的 Map 任务，

163
00:09:23,910 --> 00:09:24,990
这将打破这个循环，

164
00:09:26,730 --> 00:09:28,560
然后，如果所有 Map 任务都完成了，

165
00:09:28,560 --> 00:09:30,150
然后我们发布 Reduce 任务，

166
00:09:31,080 --> 00:09:32,310
就是这里的东西。

167
00:09:35,380 --> 00:09:40,750
所以，是的，我想我还有最后一步，

168
00:09:40,750 --> 00:09:43,390
就是我们所做的，

169
00:09:43,390 --> 00:09:48,070
当 maps 或 reduces ，当没有任务要发布时，

170
00:09:48,100 --> 00:09:49,960
所以我们想做的是，

171
00:09:50,050 --> 00:09:53,680
coordinator 应该等待任务发布，

172
00:09:53,950 --> 00:09:56,920
一旦发生，就会出现任务发布，

173
00:09:56,920 --> 00:09:58,690
或者到另一个发布循环的迭代，

174
00:09:58,720 --> 00:10:00,940
然后发布任务。

175
00:10:01,650 --> 00:10:05,010
我将继续，直到所有的 Map 或 Reduce 任务完成，

176
00:10:06,720 --> 00:10:08,550
完成后，我会再回来，

177
00:10:08,580 --> 00:10:10,380
所以让我去。

178
00:10:13,620 --> 00:10:18,360
所以为了支持那个等待，

179
00:10:19,640 --> 00:10:23,360
我的解决方案是使用条件变量，

180
00:10:24,610 --> 00:10:29,650
从本质上讲，它所做的是，

181
00:10:29,890 --> 00:10:32,890
如果没有 Map 任务发布，

182
00:10:33,250 --> 00:10:37,690
但是 mappers ，但是这里，

183
00:10:37,840 --> 00:10:40,360
因为我们已经分配了它们所有，

184
00:10:40,390 --> 00:10:41,470
我们在们它们，

185
00:10:41,500 --> 00:10:43,360
它们还没有超时，

186
00:10:43,450 --> 00:10:45,610
那么我们要做的就是等待，

187
00:10:45,670 --> 00:10:49,210
因为我们不能发布 Reduce 任务，

188
00:10:49,210 --> 00:10:50,740
如果所有的 mappers 都没有完成，

189
00:10:51,040 --> 00:10:53,290
所以我们就在这里等着，

190
00:10:53,410 --> 00:10:56,410
一旦我们收到某种信号，

191
00:10:56,470 --> 00:10:58,780
我们回到这个循环的顶端，

192
00:10:59,130 --> 00:11:01,050
检查我们是否可以再次发布任务。

193
00:11:02,510 --> 00:11:06,170
同样，如果所有 reducers 都没有完成，

194
00:11:06,170 --> 00:11:08,990
我们不能给 worker 发布任务，

195
00:11:09,020 --> 00:11:12,680
我们要等待出现某种信号，

196
00:11:12,680 --> 00:11:14,810
那么信号到底是什么时候出现？

197
00:11:15,380 --> 00:11:19,250
好的，我们想要在任何时候发出信号，

198
00:11:19,400 --> 00:11:23,300
无论任务完成或时间太长，我们没有收到回复，

199
00:11:23,300 --> 00:11:24,710
所以可能会有失败，

200
00:11:25,430 --> 00:11:29,960
或者如果一个 worker 完成了一项任务，

201
00:11:29,960 --> 00:11:33,050
因为这可能意味着所有 Map 任务都已经完成，

202
00:11:33,050 --> 00:11:34,580
我们可以继续执行一项 Reduce 任务。

203
00:11:35,430 --> 00:11:39,210
所以，为了做到这一点，

204
00:11:39,210 --> 00:11:41,610
我们有的是，

205
00:11:45,020 --> 00:11:46,490
我们这里有一个 goroutine ，

206
00:11:46,520 --> 00:11:53,370
这是当 coordinator 开始时发出的，

207
00:11:53,490 --> 00:11:56,400
它所做的是每隔一段时间，

208
00:11:56,700 --> 00:12:00,780
在一些或许每秒，

209
00:12:00,810 --> 00:12:02,820
当一项任务可能已经完成时，

210
00:12:03,310 --> 00:12:05,260
或许这是十秒，我记不清了，

211
00:12:05,380 --> 00:12:06,880
事实上，这并不重要，

212
00:12:06,910 --> 00:12:09,370
它只是时不时地唤醒 coordinator ，

213
00:12:09,370 --> 00:12:11,710
所以 coordinator 会再做一次检查，

214
00:12:11,860 --> 00:12:13,960
查看是否有要发布的任务，

215
00:12:14,110 --> 00:12:15,640
所以它就这样循环着，

216
00:12:15,850 --> 00:12:19,690
每一秒它都会广播唤醒 coordinator 。

217
00:12:22,620 --> 00:12:26,550
另一个我们想要在任务完成时发出信号，

218
00:12:26,970 --> 00:12:30,840
所以，这将在这个 HandleFinishedTask 中发生，

219
00:12:30,870 --> 00:12:37,140
当一个 worker FinishedTask 任务 RPC 完成时，

220
00:12:37,680 --> 00:12:40,650
所以，在这里有一个 Broadcast ，

221
00:12:40,650 --> 00:12:47,250
在我们将[]设置为 Done 之后，

222
00:12:47,730 --> 00:12:52,520
当 coordinator 回去检查其中一个循环时，

223
00:12:52,520 --> 00:12:54,950
看看有没有任务要完成，

224
00:12:54,980 --> 00:12:58,070
它将看到更新后 Done 状态。

225
00:12:59,120 --> 00:13:02,240
所以这就是我的解决方案，

226
00:13:02,510 --> 00:13:09,680
它使用条件变量和 Mutex 来保护 coordinator 的共享状态。

227
00:13:11,000 --> 00:13:12,920
所以这只是一种可能的解决方案，

228
00:13:13,520 --> 00:13:16,280
然后我会回到这里，

229
00:13:16,880 --> 00:13:21,920
这就是我采取的步骤的布局。

230
00:13:22,860 --> 00:13:27,330
在我继续之前，对这个解决方案，有什么问题吗？

231
00:13:30,910 --> 00:13:35,200
你能更详细地说明一下条件变量吗？

232
00:13:36,770 --> 00:13:47,060
当然，所以，我想条件变量是，

233
00:13:47,730 --> 00:13:48,930
非常有用，

234
00:13:48,930 --> 00:13:54,870
当你想要等待特定断言或特定条件变为真时，

235
00:13:55,080 --> 00:14:00,590
所以在这种情况下，条件变量是自然的，

236
00:14:00,740 --> 00:14:04,490
让我到我用到的地方，

237
00:14:05,300 --> 00:14:10,970
是实现等待可用任务的自然方式，

238
00:14:11,060 --> 00:14:14,360
因为这是一种特殊的条件，

239
00:14:14,630 --> 00:14:19,210
而且它是异步发生的，

240
00:14:19,210 --> 00:14:22,240
例如，有一项任务可用时，

241
00:14:22,270 --> 00:14:25,180
当 worker 完成一项任务时，

242
00:14:25,510 --> 00:14:33,910
或任务可能可用，在发生故障时，

243
00:14:33,910 --> 00:14:35,710
我们需要重新发布这项任务，

244
00:14:35,800 --> 00:14:37,540
所以你可以想到，

245
00:14:38,140 --> 00:14:44,790
在任何情况下，你需要等待特定的条件，

246
00:14:44,820 --> 00:14:48,000
这就是条件变量非常有用的地方。

247
00:14:48,840 --> 00:14:51,000
这会有一点帮助吗？

248
00:14:51,970 --> 00:14:53,080
是的，谢谢。

249
00:14:56,000 --> 00:14:57,110
你也可以，

250
00:14:57,170 --> 00:15:00,590
比如所有这些更高级的，

251
00:15:00,590 --> 00:15:03,110
比如通道、条件变量，

252
00:15:03,110 --> 00:15:05,600
所有这些更高级的同步原语，

253
00:15:05,600 --> 00:15:07,730
它们都是构建在锁上的，

254
00:15:07,850 --> 00:15:10,040
所以它们都是使用锁实现的，

255
00:15:10,040 --> 00:15:11,420
是一种，

256
00:15:12,430 --> 00:15:15,400
一种更高层次的思考同步的方式，

257
00:15:15,400 --> 00:15:18,130
这让你可以推断条件。

258
00:15:22,050 --> 00:15:24,330
这会有同样的效果吗，

259
00:15:24,330 --> 00:15:27,870
比如在那个循环里，

260
00:15:27,870 --> 00:15:31,710
你在 GetTask 函数中，

261
00:15:31,710 --> 00:15:35,100
不是使用条件变量，

262
00:15:35,850 --> 00:15:39,420
它使循环每秒运行一次，

263
00:15:40,250 --> 00:15:40,700
我想。

264
00:15:40,700 --> 00:15:45,860
是的，所以，它本质上和睡眠一样，

265
00:15:45,890 --> 00:15:54,780
这里的超时循环，

266
00:15:55,780 --> 00:15:57,940
不同的是，

267
00:15:58,970 --> 00:16:01,700
例如，条件变量，

268
00:16:01,700 --> 00:16:05,600
你可能被一项已经完成的任务唤醒，

269
00:16:06,140 --> 00:16:10,880
在循环中，例如睡眠每秒循环一次，

270
00:16:11,210 --> 00:16:13,220
你必须等待一秒，

271
00:16:13,830 --> 00:16:15,750
而对于条件变量，

272
00:16:15,750 --> 00:16:19,250
你可会在大约 10 毫秒后被唤醒，

273
00:16:19,250 --> 00:16:21,380
因为 worker 已经完成了一项任务，

274
00:16:21,650 --> 00:16:25,760
所以，它可能具有更好的灵活性。

275
00:16:27,800 --> 00:16:30,200
在这种情况下，我们使用，

276
00:16:30,200 --> 00:16:35,230
如果每项任务总是占用 5 秒左右的时间，

277
00:16:35,290 --> 00:16:41,830
那么，是的，这本质上非常类似于每个循环睡眠一秒。

278
00:16:43,680 --> 00:16:45,930
我有个问题，

279
00:16:45,930 --> 00:16:47,880
我想我错过了你运行的部分，

280
00:16:48,580 --> 00:16:52,960
当任务请求到来时，你如何处理，

281
00:16:52,960 --> 00:16:55,870
但你目前没有任务要分配，

282
00:16:55,870 --> 00:17:00,070
你怎么告诉 worker 要么回来

283
00:17:00,070 --> 00:17:01,720
还是让它们等待，

284
00:17:01,750 --> 00:17:04,960
一带而过地，

285
00:17:05,860 --> 00:17:10,030
我很好奇，你为什么选择这种睡眠的方式，

286
00:17:10,030 --> 00:17:14,920
而不是收到任务请求时查看时间，

287
00:17:14,920 --> 00:17:17,520
比如当你收到请求时，

288
00:17:17,520 --> 00:17:19,470
已经超时，并重新发布它，

289
00:17:20,320 --> 00:17:23,500
而不是不间断的检查。

290
00:17:24,160 --> 00:17:26,050
是的，好的，所以，

291
00:17:26,790 --> 00:17:29,940
是的，所以我先问你的第一个问题，

292
00:17:30,330 --> 00:17:36,150
所以我是如何处理已经完成的任务的，

293
00:17:37,020 --> 00:17:42,260
是一旦所有的 Map 任务完成，

294
00:17:42,260 --> 00:17:44,750
一旦所有 Reduce 任务都已完成，

295
00:17:44,810 --> 00:17:48,680
然后我们返回给 worker 的任务，

296
00:17:48,830 --> 00:17:52,160
因为 worker 调用的任务，

297
00:17:52,190 --> 00:17:55,670
是这个额外的我称为 Done 的任务类型，

298
00:17:56,680 --> 00:18:01,510
然后我设置 coordinator 的 isDone 为 true ，

299
00:18:02,230 --> 00:18:03,730
所以在 worker 中，

300
00:18:03,730 --> 00:18:04,390
我现在去 worker 中，

301
00:18:05,530 --> 00:18:09,940
worker 中我们有这个循环，

302
00:18:09,940 --> 00:18:13,540
当 worker 要求任务时，

303
00:18:13,930 --> 00:18:18,250
如果返回的任务是 Done 任务，它就退出。

304
00:18:18,680 --> 00:18:21,950
所以这就是我向 worker 传达信息的方式，

305
00:18:21,950 --> 00:18:23,540
它应该退出。

306
00:18:23,570 --> 00:18:25,280
我想我是在问，

307
00:18:25,310 --> 00:18:30,110
抱歉，比如你还在完成 Map 任务，

308
00:18:30,560 --> 00:18:32,780
你收到任务的请求，

309
00:18:33,170 --> 00:18:35,210
你仍然不能给出你的 Reduce 任务，

310
00:18:35,630 --> 00:18:37,160
你怎么告诉 worker 呢？

311
00:18:38,060 --> 00:18:42,850
哦，所以，你们中的很多人都是，

312
00:18:43,000 --> 00:18:45,760
另一种设计是，

313
00:18:45,850 --> 00:18:49,120
如果没有任务给 worker ，

314
00:18:49,570 --> 00:18:54,130
然后 coordinator 立即向 worker 返回回复，

315
00:18:54,370 --> 00:18:56,470
而 worker 在它的循环中睡眠，

316
00:18:56,770 --> 00:18:58,990
但你可以在这里看到，

317
00:18:58,990 --> 00:19:00,820
worker 循环，没有睡眠，

318
00:19:01,820 --> 00:19:03,260
其中的原因是，

319
00:19:03,260 --> 00:19:08,150
因为这个调用会阻塞直到 coordinator 回复，

320
00:19:09,130 --> 00:19:10,420
在我的解决方案中，

321
00:19:11,490 --> 00:19:13,200
回到 coordinator ，

322
00:19:13,560 --> 00:19:15,900
例如，如果你查看 mapDone ，

323
00:19:17,180 --> 00:19:25,040
在这个解决方案中， coordinator 处理程序不会向那个调用返回回复，

324
00:19:25,250 --> 00:19:28,430
除非它有任务要返回，

325
00:19:28,820 --> 00:19:33,710
所以，我们是在 coordinator 那里等待，而不是在 worker 那里。

326
00:19:34,660 --> 00:19:37,180
所以 coordinator 就是那个，

327
00:19:37,360 --> 00:19:42,280
不断地检查是否有任务和睡眠，

328
00:19:42,400 --> 00:19:46,720
而 worker 只是简单地阻塞在这个调用上，

329
00:19:47,220 --> 00:19:49,080
直到 coordinator 返回给它。

330
00:19:49,690 --> 00:19:54,700
在 coordinator 中这样做，有什么好处吗？

331
00:19:59,550 --> 00:20:02,670
所以我认为一个优势是，

332
00:20:04,940 --> 00:20:09,330
并不是所有的 worker 都不断地发送 RPC ，

333
00:20:09,600 --> 00:20:10,590
你发送一个 RPC ，

334
00:20:10,590 --> 00:20:13,290
这是每个任务一个 RPC ，

335
00:20:13,920 --> 00:20:18,180
而如果 worker 不断地循环和睡眠，并且不断地回答，

336
00:20:18,180 --> 00:20:19,890
你会有更多的网络流量。

337
00:20:20,660 --> 00:20:21,260
好的。

338
00:20:21,620 --> 00:20:26,510
是的，我认为这是，但这两种解决方案都是可行的，

339
00:20:26,510 --> 00:20:27,710
它们都是可工作的。

340
00:20:28,510 --> 00:20:29,260
太棒了。

341
00:20:29,580 --> 00:20:32,130
我还有一个问题，

342
00:20:32,130 --> 00:20:38,640
我看到你经常对锁使用 defer ，

343
00:20:39,930 --> 00:20:41,880
当我在做我的实现时，

344
00:20:41,880 --> 00:20:43,050
我意识到，

345
00:20:43,050 --> 00:20:45,450
我的意思是，在一个简单的函数中，

346
00:20:45,450 --> 00:20:47,140
它很明显，

347
00:20:47,170 --> 00:20:49,630
什么时候放弃对锁的控制，

348
00:20:50,210 --> 00:20:59,210
但是如果你有一个从函数内部创建的 goroutine ，

349
00:21:00,020 --> 00:21:03,680
就不是很清楚，何时放弃控制。

350
00:21:05,100 --> 00:21:07,770
所以，一个 goroutine 在单独的线程上运行，

351
00:21:07,770 --> 00:21:11,220
goroutine 永远不会从获取的锁开始，

352
00:21:11,220 --> 00:21:14,370
即使当你持有锁时，开始那个 goroutine 。

353
00:21:14,640 --> 00:21:15,570
好的。

354
00:21:15,870 --> 00:21:16,560
嗯。

355
00:21:16,920 --> 00:21:21,030
如果我们创建一个 goroutine ，

356
00:21:21,090 --> 00:21:22,890
它只会在一个线程中旋转，

357
00:21:23,040 --> 00:21:26,340
而且从一开始，它就不会有锁，对吗？

358
00:21:26,340 --> 00:21:28,680
是的，实际上就像，

359
00:21:29,150 --> 00:21:30,620
你认为另一个线程

360
00:21:30,620 --> 00:21:34,160
开始运行 Go 函数。

361
00:21:35,720 --> 00:21:36,950
嗯。

362
00:21:37,700 --> 00:21:38,240
好的，继续。

363
00:21:38,480 --> 00:21:44,090
然后 defer 在任何 return 语句解锁？

364
00:21:44,730 --> 00:21:47,340
是的，它推到一个，

365
00:21:47,490 --> 00:21:51,840
比如函数运行，

366
00:21:52,380 --> 00:21:53,730
有一个函数的堆栈，

367
00:21:53,730 --> 00:21:58,610
比如 HandleGetTask 运行返回，

368
00:21:59,060 --> 00:22:01,940
所以，我在幻灯片中也有这个，

369
00:22:01,940 --> 00:22:03,530
所以你稍后可以看的这个，

370
00:22:03,830 --> 00:22:07,400
但 defer 只是确保当这个函数退出时，

371
00:22:07,760 --> 00:22:09,680
你使用解锁，

372
00:22:09,710 --> 00:22:16,280
我还可以做一些事情，比如 unlocking ，

373
00:22:17,240 --> 00:22:24,510
我也可以做一些事情，比如 before the last println ，

374
00:22:25,110 --> 00:22:28,110
所以这些都被压到一个堆栈上，

375
00:22:28,140 --> 00:22:32,640
然后它们按先进先出的顺序弹出，不，是后进先出的顺序。

376
00:22:33,470 --> 00:22:35,420
什么 FIFO ？

377
00:22:36,490 --> 00:22:44,240
先入先出，不，它们是后进先出，是的，

378
00:22:44,720 --> 00:22:45,800
所以这是一个堆栈，

379
00:22:45,800 --> 00:22:50,440
所以这将在解锁之前运行，

380
00:22:50,440 --> 00:22:53,230
在锁之前运行，

381
00:22:53,260 --> 00:22:55,360
如果你准备使用多个 defer ，

382
00:22:55,360 --> 00:22:57,340
注意顺序，然后使用它们，

383
00:22:57,550 --> 00:23:01,720
但 defer unlock 是一个非常有用的策略，

384
00:23:03,260 --> 00:23:04,280
这会派上用场的。

385
00:23:05,040 --> 00:23:08,250
好的，那么最后一件事是，

386
00:23:08,280 --> 00:23:16,730
如果我们在函数内调用函数，

387
00:23:16,760 --> 00:23:18,200
在那里我们获得了锁，

388
00:23:18,320 --> 00:23:20,720
它不会返回锁，对吧，

389
00:23:21,170 --> 00:23:23,360
当它转到另一个函数时，

390
00:23:23,780 --> 00:23:25,820
另一函数返回到这个函数，

391
00:23:26,600 --> 00:23:32,690
然后，比如线程保持者锁，通过跳来跳去。

392
00:23:34,880 --> 00:23:36,380
是的，一个函数，

393
00:23:36,380 --> 00:23:39,260
就像一个线程中的普通函数调用，

394
00:23:39,350 --> 00:23:42,050
将在锁的情况下被调用，是的。

395
00:23:43,570 --> 00:23:44,470
好的，谢谢。

396
00:23:46,360 --> 00:23:46,750
好的。

397
00:23:48,540 --> 00:23:50,940
好的，你们已经讨论了

398
00:23:50,940 --> 00:23:53,130
一些备用的同步设计，

399
00:23:53,520 --> 00:23:56,370
比如在 worker 而不是在 coordinator 等待，

400
00:23:56,370 --> 00:23:58,410
我们讨论了这样做的一些利弊，

401
00:23:58,900 --> 00:24:00,040
使用 time ，

402
00:24:00,070 --> 00:24:02,800
事实上，我认为已经涵盖了所有这些，可能除了通道，

403
00:24:04,640 --> 00:24:06,950
所以有一件事我想知道，

404
00:24:06,950 --> 00:24:08,810
因为对此有几个问题，

405
00:24:09,020 --> 00:24:11,630
所以等待 map 完成，

406
00:24:11,630 --> 00:24:15,050
或者我们展示的任何同步

407
00:24:15,350 --> 00:24:17,150
都在一台服务器上，

408
00:24:17,210 --> 00:24:21,470
所以 worker 和 coordinator 之间的跨服务器通信，

409
00:24:22,250 --> 00:24:25,340
它们只是通过 RPC ，

410
00:24:25,520 --> 00:24:27,920
例如，在 coordinator 的锁，

411
00:24:27,920 --> 00:24:29,930
与 worker 的锁无关，

412
00:24:30,110 --> 00:24:33,560
或者在不同服务器上的交互实现锁上，

413
00:24:33,980 --> 00:24:36,170
不会互相干扰，

414
00:24:37,110 --> 00:24:38,490
我只想澄清这一点。

415
00:24:39,270 --> 00:24:42,510
所以我觉得有一件事会很有趣的是，

416
00:24:42,510 --> 00:24:47,150
为了让你看到一种使用通道的例子，

417
00:24:47,150 --> 00:24:50,780
因为这里也有一些问题关于使用通道。

418
00:24:51,680 --> 00:24:54,200
所以这是一种，

419
00:24:54,200 --> 00:24:59,600
不是一种完全使用通道的实现，

420
00:24:59,810 --> 00:25:02,690
但这是一种潜在的方式，

421
00:25:03,160 --> 00:25:06,310
你可以考虑在 MapReduce 中使用通道。

422
00:25:06,910 --> 00:25:09,160
所以在这个例子中，

423
00:25:09,340 --> 00:25:12,910
到 coordinator 的输入包含一个通道，

424
00:25:13,530 --> 00:25:18,840
其中 coordinator 被告知哪些 worker 存在，

425
00:25:19,140 --> 00:25:25,480
这是为了应对 worker 失败的可能性，

426
00:25:25,510 --> 00:25:28,690
然后某个客户端告诉 coordinator ，

427
00:25:28,690 --> 00:25:30,850
嘿，另一个 worker 加入了我们的集群，

428
00:25:30,880 --> 00:25:33,100
这是一个新 worker ，你可以给它分配任务，

429
00:25:33,310 --> 00:25:36,970
所以，这与我们在实验中的略有不同。

430
00:25:37,950 --> 00:25:41,820
所以 coordinator 有两个通道，

431
00:25:42,440 --> 00:25:47,480
其中一个，它会发送任务给 worker ，

432
00:25:47,600 --> 00:25:50,150
或者它不向 worker 发送任务，

433
00:25:50,150 --> 00:25:54,110
将任务发送到线程，线程将向 worker 发送任务，

434
00:25:54,860 --> 00:25:56,810
然后它有一个 done 通道。

435
00:25:57,310 --> 00:26:00,190
所以再一次，

436
00:26:01,080 --> 00:26:03,570
我知道我说了一些奇怪的话，

437
00:26:03,570 --> 00:26:06,660
你可以通过通道向 worker 发送任务，

438
00:26:06,660 --> 00:26:07,650
但实际上不能，

439
00:26:07,770 --> 00:26:10,860
通道只在你的服务器上的 coordinator ，

440
00:26:11,070 --> 00:26:12,660
稍后我们再来看它是如何工作的。

441
00:26:13,660 --> 00:26:18,310
所以，我们创建的 coordinator 的第一个线程是 goroutine ，

442
00:26:18,310 --> 00:26:25,480
对于每一个 worker ，开始 issueWorkerTaskThread 。

443
00:26:25,980 --> 00:26:28,480
所以，这样做的目的是，

444
00:26:28,480 --> 00:26:31,360
作为 worker 来来去去，

445
00:26:31,360 --> 00:26:33,430
因为它们失败了，然后又重启，

446
00:26:33,610 --> 00:26:35,200
这个通道表示，

447
00:26:35,200 --> 00:26:37,720
好的，我们想要，对于任何一个 worker ，

448
00:26:38,020 --> 00:26:41,260
启动一个将会发布这个 worker 任务的线程。

449
00:26:41,960 --> 00:26:45,200
所以这里一个 goroutine ，

450
00:26:46,620 --> 00:26:49,020
然后 coordinator 所做的是，

451
00:26:49,440 --> 00:26:50,760
对于所有给出的任务，

452
00:26:50,760 --> 00:26:53,680
它只是将这些任务推到这个 tasks 通道，

453
00:26:54,590 --> 00:26:56,420
而这个 tasks 通道，

454
00:26:56,420 --> 00:26:58,490
我们让它是一个缓冲通道，

455
00:26:58,730 --> 00:27:02,270
这样我们知道它能准确地容纳 numTask 个任务，

456
00:27:02,270 --> 00:27:06,440
这就是任务数量，

457
00:27:06,470 --> 00:27:08,150
将存在于系统中的，

458
00:27:08,150 --> 00:27:10,370
所以这也意味着，

459
00:27:10,370 --> 00:27:17,060
我们可以在不阻塞的情况下将 numTask 个任务推到通道，

460
00:27:17,240 --> 00:27:21,170
所以， coordinator 不会阻塞将任务推送到 tasks 通道。

461
00:27:22,170 --> 00:27:27,000
然后 coordinator 将从这个 done 通道读取，

462
00:27:27,030 --> 00:27:31,020
直到它完成 numTask 次，

463
00:27:31,200 --> 00:27:33,660
在这种情况下，它知道它已经完成了，

464
00:27:33,660 --> 00:27:37,080
在这个例子中，我没有区分 map 或 reduce 任务，

465
00:27:37,080 --> 00:27:38,520
想象一下它们在那里，

466
00:27:38,550 --> 00:27:41,610
coordinator 的一些任务需要运行。

467
00:27:42,700 --> 00:27:46,270
一旦它知道所有的任务都完成了，

468
00:27:46,270 --> 00:27:52,450
它关闭 tasks 通道，然后将退出。

469
00:27:53,520 --> 00:27:58,740
所以，其中一些有趣的部分是，

470
00:27:58,980 --> 00:28:00,840
这些 worker 任务线程，

471
00:28:00,840 --> 00:28:03,540
我把它们拿出来，放在这里。

472
00:28:04,420 --> 00:28:07,390
所以，这些都是在子 goroutine 上运行，

473
00:28:07,910 --> 00:28:11,360
它所做的是为了，

474
00:28:11,990 --> 00:28:14,540
只要 task 队列中有任务，

475
00:28:14,990 --> 00:28:16,700
它将拉出一项任务，

476
00:28:17,180 --> 00:28:20,390
然后，哦，我不是故意的，

477
00:28:20,540 --> 00:28:25,680
然后调用一个 RPC ，

478
00:28:25,680 --> 00:28:27,600
它会将任务发送给 worker ，

479
00:28:27,990 --> 00:28:29,460
所以注意到，

480
00:28:29,460 --> 00:28:34,230
这个通道正在与 coordinator 的另一个线程交互，

481
00:28:34,290 --> 00:28:40,980
而那个线程是负责调用 worker 的那个线程，

482
00:28:42,020 --> 00:28:45,620
然后一旦它完成了任务，它就会说已经完成了，

483
00:28:46,620 --> 00:28:49,590
如果它不能，如果调用失败，

484
00:28:49,590 --> 00:28:51,870
因为某些原因，比如它超时了，

485
00:28:51,990 --> 00:28:54,570
然后，这个循环所做的是，

486
00:28:54,570 --> 00:28:57,480
它会将该任务推回到 tasks 频道，

487
00:28:57,690 --> 00:29:02,010
所以，另一个 worker 或这个线程可能会再次执行这个任务。

488
00:29:03,360 --> 00:29:07,200
因此，为了说明通道通信是如何工作的，

489
00:29:07,200 --> 00:29:09,840
所以 worker 发送任务到 tasks 通道，

490
00:29:09,840 --> 00:29:11,550
通过这些循环读取，

491
00:29:12,680 --> 00:29:18,500
这个循环将在 coordinator 关闭信道时退出，

492
00:29:20,090 --> 00:29:24,830
done ，它被发送到这些发送的 worker 线程，

493
00:29:25,940 --> 00:29:29,540
它被原始的 coordinator 线程读取，

494
00:29:30,320 --> 00:29:33,020
这个 exit 等于 true ，

495
00:29:33,020 --> 00:29:35,540
将会告诉 coordinator ，

496
00:29:35,540 --> 00:29:39,590
哦，我不需要听更多的 worker 到来或 worker 开始，

497
00:29:40,020 --> 00:29:43,800
所以它会导致另一个 goroutine 退出。

498
00:29:44,850 --> 00:29:47,370
我知道这是一个相当复杂的例子，

499
00:29:47,370 --> 00:29:51,570
这也完全不是我们在实验里指定的，

500
00:29:51,570 --> 00:29:54,000
但是作为如何使用通道的一个例子，

501
00:29:54,060 --> 00:29:57,780
来实现 MapReduce 或类似 MapReduce 的东西。

502
00:30:00,380 --> 00:30:02,810
聊天中有一个问题，

503
00:30:02,810 --> 00:30:05,270
关于 exit 在代码中的哪里定义？

504
00:30:08,640 --> 00:30:10,380
这是个好问题，

505
00:30:10,380 --> 00:30:11,130
它没有，

506
00:30:12,060 --> 00:30:15,570
它会跟 done 一样，

507
00:30:16,230 --> 00:30:21,970
它将是另一个布尔值的通道，是的，

508
00:30:23,160 --> 00:30:25,620
这是一个很好的发现。

509
00:30:27,020 --> 00:30:27,740
哦，我可以？

510
00:30:27,740 --> 00:30:28,790
我看到。

511
00:30:28,970 --> 00:30:31,640
如何将东西添加到 workers 通道，

512
00:30:31,640 --> 00:30:33,110
或者当你向 workers 通道添加东西时，

513
00:30:33,110 --> 00:30:34,730
在这种情况下，你是怎么处理它们的？

514
00:30:35,410 --> 00:30:37,180
是的，所以在这种情况下，

515
00:30:37,420 --> 00:30:41,320
workers 通道提供给 coordinator ，

516
00:30:41,410 --> 00:30:43,690
想象一下，举个例子，

517
00:30:43,690 --> 00:30:46,780
你的 Coordinator

518
00:30:46,810 --> 00:30:54,930
是被 main 中的 MR coordinator 调用或创建的，

519
00:30:54,960 --> 00:30:57,150
在那个[]中，

520
00:30:57,270 --> 00:31:01,230
所以，我们可以想象，在 MR coordinator 中，

521
00:31:01,230 --> 00:31:03,630
我们会创建一个 workers 通道，

522
00:31:04,460 --> 00:31:08,990
MR coordinator 将负责跟踪，

523
00:31:09,140 --> 00:31:12,440
什么时候 workers 崩溃，什么时候 workers 加入，

524
00:31:12,470 --> 00:31:15,170
所以这是一个例子，

525
00:31:15,170 --> 00:31:20,390
可能稍后会有新服务器添加到我们的集群中，

526
00:31:20,450 --> 00:31:23,060
或者某个 worker 崩溃，然后又回来了，

527
00:31:23,090 --> 00:31:26,450
而 MR coordinator 会不断地发送，

528
00:31:26,510 --> 00:31:30,230
这些 worker id 给我们的 Coordinator ，

529
00:31:30,960 --> 00:31:33,480
为了告诉它，嘿，这里有一个新的 worker ，

530
00:31:33,480 --> 00:31:35,370
你应该给它发布任务，

531
00:31:36,090 --> 00:31:37,620
这部分没有显示出来。

532
00:31:38,350 --> 00:31:41,950
明白了，是的，我只是在想，

533
00:31:41,980 --> 00:31:43,690
所以这真的很酷，

534
00:31:43,690 --> 00:31:47,020
我只是想在实验 1 中，

535
00:31:47,020 --> 00:31:51,220
我想调用 worker ，你发送 RPC 给 worker ，

536
00:31:51,700 --> 00:31:54,490
我们在实验 1 中可以这么做吗？

537
00:31:57,100 --> 00:31:58,900
这是可能的，

538
00:31:58,900 --> 00:32:01,810
但这绝对不是我们让你们去做的，

539
00:32:02,020 --> 00:32:04,060
因为需要，

540
00:32:04,060 --> 00:32:07,450
不是将 coordinator 设置为 RPC 服务器，

541
00:32:07,450 --> 00:32:11,050
你必须在 worker 是设置 RPC 服务器，

542
00:32:11,440 --> 00:32:13,510
你可以认为，

543
00:32:13,540 --> 00:32:19,850
在这个实现中， call_worker 可以为每个 worker 设置处理程序，

544
00:32:20,210 --> 00:32:25,790
每个 worker 可以发送 task RPC 给 coordinator ，

545
00:32:25,820 --> 00:32:30,350
但这有点[]，

546
00:32:30,350 --> 00:32:33,230
所以在这个例子中，可以更自然的想象，

547
00:32:33,260 --> 00:32:36,470
那个 call_worker ， coordinator 是一个客户端，

548
00:32:36,470 --> 00:32:40,940
而 worker 就是处理那个 RPC 的人。

549
00:32:41,510 --> 00:32:43,820
好的，谢谢，很酷。

550
00:32:45,230 --> 00:32:46,850
我有两个问题，

551
00:32:47,150 --> 00:32:49,340
首先，这只是一个一般性的 Go 问题，

552
00:32:49,340 --> 00:32:52,760
所以，在左侧底部第二个 for 循环中，

553
00:32:53,700 --> 00:32:58,340
如果你不使用 i ， Go 会在 for 循环中抱怨吗？

554
00:32:59,480 --> 00:33:04,400
所以我运行了所有的 Go linter 以及类似的东西，

555
00:33:04,580 --> 00:33:07,550
我觉得这是可以的，

556
00:33:07,580 --> 00:33:12,940
在这种情况下，你需要 i ，

557
00:33:12,970 --> 00:33:18,880
因为你是递增的，在整个过程中保持 i 的状态。

558
00:33:19,420 --> 00:33:20,530
你能做同样的事情，

559
00:33:20,530 --> 00:33:23,560
比如一个 while 循环，

560
00:33:23,560 --> 00:33:26,410
比如空的 for 循环加上一个 select ，

561
00:33:27,430 --> 00:33:31,540
在那里弹出 done 。

562
00:33:32,250 --> 00:33:37,580
所以，你不能，

563
00:33:37,580 --> 00:33:42,950
好的，你还是需要记录一下你读了多少次 done ，

564
00:33:42,950 --> 00:33:46,100
因为你不能只读一次，

565
00:33:46,130 --> 00:33:48,770
你必须读取 numTask 次。

566
00:33:52,070 --> 00:33:52,490
我明白了，好的。

567
00:33:52,490 --> 00:33:59,260
是的，所以你需要某种类型的状态来追踪这个。

568
00:34:02,800 --> 00:34:05,170
然后对于右边的那个，

569
00:34:05,170 --> 00:34:08,140
你从 tasks 中读取并重新添加它，

570
00:34:08,170 --> 00:34:11,500
这有什么不好的地方吗，

571
00:34:12,530 --> 00:34:16,610
如果你不断地读取和添加到同一个通道？

572
00:34:19,740 --> 00:34:22,910
我想不出来，

573
00:34:22,910 --> 00:34:25,580
所以在这种情况下，至少你不会阻塞，

574
00:34:25,910 --> 00:34:27,590
因为每次你读到它，

575
00:34:27,590 --> 00:34:29,990
你会在通道上弹出一些东西，

576
00:34:30,020 --> 00:34:32,990
每次你添加它，你推送一些东西，

577
00:34:33,170 --> 00:34:38,120
因为我们有 tasks 是一个缓冲通道，

578
00:34:38,150 --> 00:34:40,010
但你永远不会阻塞这个。

579
00:34:41,160 --> 00:34:45,010
所以，对于性能方面，

580
00:34:45,430 --> 00:34:49,400
我的意思是，通道是用锁建造的，

581
00:34:49,400 --> 00:34:51,890
所以锁通常更轻，

582
00:34:52,430 --> 00:34:57,620
但我不认为，你会看到一个大的性能，

583
00:34:57,890 --> 00:34:59,120
做这样的事。

584
00:34:59,630 --> 00:35:01,400
好的，我想，比如，

585
00:35:01,640 --> 00:35:04,250
抱歉，比如一个一般的问题，

586
00:35:04,860 --> 00:35:06,450
你是如何计算并选择，

587
00:35:06,450 --> 00:35:10,580
在 Mutex 和通道或混合之间，

588
00:35:11,380 --> 00:35:12,340
在最开始的时候。

589
00:35:13,560 --> 00:35:19,140
是的，所以 Mutex 对于保护一个状态来说是非常自然的，

590
00:35:19,230 --> 00:35:23,880
比如你的 Coordinator 或你的 Raft 服务器有日志，

591
00:35:24,030 --> 00:35:26,820
我想在每次添加日志时保护，

592
00:35:26,910 --> 00:35:32,730
这看起来很难或很不自然，

593
00:35:32,730 --> 00:35:34,260
在这里尝试使用通道，

594
00:35:34,470 --> 00:35:37,440
因为从本质上讲，你使用通道锁，

595
00:35:37,500 --> 00:35:41,190
你想要确保没有其他人在修改状态，

596
00:35:41,190 --> 00:35:42,360
当你修改它的时候，

597
00:35:42,600 --> 00:35:45,990
然后在你修改它之前，

598
00:35:46,020 --> 00:35:48,660
试着从通道读取，确认也没有人，

599
00:35:48,920 --> 00:35:51,470
好的，比如某些人必须发送东西给通道，

600
00:35:51,470 --> 00:35:52,640
只是表示它们已经完成，

601
00:35:52,700 --> 00:35:55,730
它们已经完成了这样或那样的修改。

602
00:35:55,760 --> 00:36:00,520
所以，在这种情况下，很难想象你如何使用通道，

603
00:36:00,520 --> 00:36:03,700
Mutex 会让这个变得非常简单，

604
00:36:05,260 --> 00:36:08,350
通道非常方便的地方是，

605
00:36:08,380 --> 00:36:12,580
我认为我们的实现已经有了 apply 通道，

606
00:36:12,850 --> 00:36:15,400
是你必须等待的地方，

607
00:36:16,640 --> 00:36:22,670
在某些方面，它就像条件变量的特定实例，

608
00:36:22,730 --> 00:36:25,850
在这种情况下，你想要等待什么东西准备好，

609
00:36:26,030 --> 00:36:34,980
或者像是一种要完成的非常具体的命令，

610
00:36:35,010 --> 00:36:40,590
所以，对于像发布任务这样的事情来说，是一个不错的例子，

611
00:36:41,730 --> 00:36:46,650
或者诸如阻塞在一个队列上，

612
00:36:46,710 --> 00:36:49,650
你可以把它想象成一个队列系统，

613
00:36:50,100 --> 00:36:52,230
或者至少我是这么想的，

614
00:36:52,230 --> 00:36:56,140
但是，对于共享状态的几乎所有修改，

615
00:36:56,140 --> 00:37:02,790
比如竞争条件，遇到锁要简单得多，

616
00:37:02,790 --> 00:37:04,920
在某些方面，推理要容易得多，

617
00:37:07,990 --> 00:37:09,750
但是，是的。

618
00:37:09,780 --> 00:37:10,410
谢谢。

619
00:37:11,580 --> 00:37:15,270
抱歉，我有一个关于这张幻灯片的后续问题，

620
00:37:15,360 --> 00:37:17,370
如果，会发生什么，

621
00:37:17,370 --> 00:37:20,310
所以，你调用 Go issueWorkerTaskThread ，

622
00:37:20,310 --> 00:37:22,920
它会启动另一个 goroutine ，

623
00:37:22,950 --> 00:37:25,500
我的意思是，它遍历通道中的所有任务，

624
00:37:25,500 --> 00:37:27,610
如果它失败了，

625
00:37:27,610 --> 00:37:29,860
如果 goroutine 失败了，

626
00:37:29,860 --> 00:37:32,590
当它位于 if call_worker 时。

627
00:37:34,550 --> 00:37:39,560
所以，如果它失败了，

628
00:37:40,520 --> 00:37:47,150
那么我想你拿出了一个任务，没有把它放回去，

629
00:37:48,860 --> 00:37:52,520
其实我也不确定，这看起来像是，

630
00:37:53,980 --> 00:37:54,850
比如你不是，

631
00:37:54,880 --> 00:37:59,930
你说的是整个线程崩溃，而不是 call_worker ，

632
00:37:59,960 --> 00:38:02,420
不是返回失败或什么东西。

633
00:38:02,690 --> 00:38:05,390
是的，比如 goroutine 崩溃，

634
00:38:06,010 --> 00:38:09,760
或者单个 goroutine 可能失败吗，

635
00:38:09,760 --> 00:38:12,070
或者整个事情都没了？

636
00:38:14,180 --> 00:38:14,900
嘿， Frans ，你知道吗？

637
00:38:14,900 --> 00:38:16,940
我认为你应该拥有的模型是，

638
00:38:16,940 --> 00:38:20,090
如果 goroutine 崩溃，那么进程也会崩溃。

639
00:38:21,580 --> 00:38:22,930
是的，这样就能解决了。

640
00:38:25,580 --> 00:38:29,930
抱歉，如果只有 worker 崩溃了，

641
00:38:30,440 --> 00:38:34,250
然后你选择一个不同的任务，

642
00:38:34,250 --> 00:38:36,200
但是，如果你，

643
00:38:36,470 --> 00:38:40,470
我想你仍然会有相同的 worker ，

644
00:38:40,500 --> 00:38:42,860
比如 worker 编号，

645
00:38:44,660 --> 00:38:49,280
所以，你仍然连接相同的 worker ，即使它们崩溃了。

646
00:38:49,910 --> 00:38:51,080
是的，所以在这种情况下，

647
00:38:51,080 --> 00:38:54,620
call_worker 只会继续返回 false ，

648
00:38:55,100 --> 00:38:59,990
这个 worker 专门的 goroutine ，

649
00:38:59,990 --> 00:39:02,240
我们只是继续循环，

650
00:39:03,420 --> 00:39:06,540
最终，当 map ，

651
00:39:06,540 --> 00:39:09,990
当 coordinator 确定所有任务都已完成时，

652
00:39:09,990 --> 00:39:12,510
它将关闭通道，然后这个 goroutine 将退出。

653
00:39:13,220 --> 00:39:15,560
所以有这种可能性，

654
00:39:15,560 --> 00:39:18,290
如果你所有的 worker 持续崩溃，

655
00:39:18,290 --> 00:39:20,450
你有数以百计的 worker 加入，

656
00:39:20,600 --> 00:39:23,660
你可以会在这里有很多 goroutine ，

657
00:39:23,660 --> 00:39:25,130
我不能联系我的 worker ，

658
00:39:25,130 --> 00:39:26,540
我不能联系我的 worker ，

659
00:39:26,840 --> 00:39:28,850
但是一旦任务完成，

660
00:39:28,850 --> 00:39:31,950
这一切都将正常退出。

661
00:39:39,440 --> 00:39:40,400
酷，好的，

662
00:39:40,430 --> 00:39:42,980
这是一个通道的例子，

663
00:39:43,280 --> 00:39:46,010
现在让我们转到一些

664
00:39:46,600 --> 00:39:49,810
你们的问题和错误之类的事情上。

665
00:39:49,810 --> 00:39:52,690
所以，我们看到的一些常见但通过的设计错误

666
00:39:52,900 --> 00:39:55,630
是把太多的工作交给了 coordinator ，

667
00:39:55,900 --> 00:39:58,450
这会使 coordinator 成为瓶颈，

668
00:39:58,540 --> 00:40:01,900
这包括 coordinator [] ，

669
00:40:02,590 --> 00:40:06,790
对结果排序或 coordinator 读取文件内容，

670
00:40:06,820 --> 00:40:11,630
然而， MapReduce 的许多优点在于，

671
00:40:12,170 --> 00:40:16,790
所有的状态，所有的计算都发生在 worker 上。

672
00:40:17,660 --> 00:40:22,250
还有另一个缺点，这并不是一个真正的错误，

673
00:40:22,250 --> 00:40:24,230
但潜在的需要考虑的是，

674
00:40:24,260 --> 00:40:26,030
你要发送多少 RPC ，

675
00:40:26,030 --> 00:40:30,530
你是否真的需要发送那么多 RPC 。

676
00:40:30,800 --> 00:40:35,270
例如，发送 RPC 检查是否有可用的 Map 任务，

677
00:40:35,330 --> 00:40:38,660
然后发送另一个 RPC 要求给我一个任务，

678
00:40:38,690 --> 00:40:40,810
是有点多余的

679
00:40:40,810 --> 00:40:45,190
你想试着减少，

680
00:40:45,280 --> 00:40:49,480
减少 coordinator 和 worker 之间的 API ，

681
00:40:50,460 --> 00:40:53,280
但这些，它们通过了测试，

682
00:40:53,280 --> 00:40:55,650
这只是我们想指出的一些事情。

683
00:40:57,610 --> 00:41:01,630
所以，现在，好的，酷，我接下来的课程。

684
00:41:01,690 --> 00:41:05,850
所以，接下来，比如 5 6 分钟，

685
00:41:06,180 --> 00:41:07,950
我们要做的是分组会议室，

686
00:41:07,950 --> 00:41:10,410
让我来停止分享，

687
00:41:11,040 --> 00:41:12,360
好的，开始分组会议室，

688
00:41:12,780 --> 00:41:18,490
哦，糟糕，让我看看，

689
00:41:21,690 --> 00:41:23,400
我想我的 Zoom 刚刚崩溃了。

690
00:41:28,050 --> 00:41:29,580
我们仍然可以听到和看到你。

691
00:41:30,030 --> 00:41:31,380
好了，我回来了，

692
00:41:31,380 --> 00:41:35,160
是的，我在这节课之前升级了 Zoom ，

693
00:41:35,160 --> 00:41:36,090
这不是个好主意，

694
00:41:36,270 --> 00:41:38,310
但是，好的，在接下来的五六分钟里，

695
00:41:38,370 --> 00:41:41,130
你应该讨论，

696
00:41:41,460 --> 00:41:45,240
你在实验中任何有趣的 bug 或观察，

697
00:41:45,630 --> 00:41:49,350
或者你可以抱怨你花了太长时间才找到某个漏洞，

698
00:41:49,710 --> 00:41:51,420
或者互相提问，

699
00:41:51,750 --> 00:41:54,750
然后我们会回来，讨论你们的一些问题。

700
00:41:55,940 --> 00:41:56,510
好的。

701
00:42:00,910 --> 00:42:01,630
好的。

702
00:42:03,060 --> 00:42:04,380
好的，待会见。

703
00:42:27,340 --> 00:42:29,020
哦， [] 和 Frans 一起，

704
00:42:29,020 --> 00:42:30,430
你想让我重新分到别的组吗？

705
00:42:30,610 --> 00:42:33,220
也许是最好的，但让我看看我自己能不能做到。

706
00:42:33,790 --> 00:42:36,380
好的，我马上回来。

707
00:49:37,790 --> 00:49:41,810
好的，我想我们差不多都回来了。

708
00:49:43,880 --> 00:49:44,570
好的，酷。

709
00:49:46,680 --> 00:49:49,110
好的，我希望这很有趣，

710
00:49:49,110 --> 00:49:52,380
或者至少你可以谈谈你在实验中的一些挫败感。

711
00:49:53,610 --> 00:49:55,950
是的，对于剩下的课程，

712
00:49:55,950 --> 00:49:57,150
我们要去，

713
00:49:57,990 --> 00:49:59,340
首先，在提问之前，

714
00:49:59,340 --> 00:50:00,630
给出一些一般的提示，

715
00:50:00,630 --> 00:50:03,030
你要在未来的实验中注意。

716
00:50:03,510 --> 00:50:05,400
所以，首先，

717
00:50:05,430 --> 00:50:10,410
你会发现调试非常方便的一件事是，

718
00:50:10,470 --> 00:50:11,850
经典的 printf ，

719
00:50:11,940 --> 00:50:14,250
你可以使用有条件的 printf ，

720
00:50:14,250 --> 00:50:17,070
只有当你想 debug 时打印，

721
00:50:17,070 --> 00:50:19,080
所以，你不必遍历代码，

722
00:50:19,080 --> 00:50:20,520
把它们都注释掉，

723
00:50:20,520 --> 00:50:21,960
在你提交或做类似的东西之前，

724
00:50:22,380 --> 00:50:24,540
所以在 Raft 实验里，

725
00:50:24,750 --> 00:50:28,680
我们提供了 DPrintf 在 util.go 文件中，

726
00:50:29,290 --> 00:50:35,170
你可以对其修改，打印出比如 server ID ，

727
00:50:35,170 --> 00:50:38,020
每次你调用 DPrintf 或类似的地方，

728
00:50:38,140 --> 00:50:40,840
所以，是的，我定制了它

729
00:50:40,840 --> 00:50:44,170
用不同的颜色来打印不同 RPC ，

730
00:50:44,170 --> 00:50:44,620
就像这样，

731
00:50:45,390 --> 00:50:48,750
还可以重定向你的输出文件，

732
00:50:48,810 --> 00:50:51,630
如果你需要搜索就会很方便。

733
00:50:52,620 --> 00:50:56,650
另一个你可能要记住的技巧是，

734
00:50:56,650 --> 00:50:59,130
你可以查看所有 goroutine ，

735
00:50:59,130 --> 00:51:03,180
看看它们在哪里运行，

736
00:51:03,420 --> 00:51:07,200
只需要输入 Ctrl-\ 来做到这个。

737
00:51:08,260 --> 00:51:12,040
最后一个是我们已经谈到过的 defer ，

738
00:51:12,040 --> 00:51:14,110
这些幻灯片也将被上传，

739
00:51:14,110 --> 00:51:15,370
所以你可以回来参考它们，

740
00:51:15,700 --> 00:51:20,440
但是你可以推入多个函数，

741
00:51:20,440 --> 00:51:23,350
在函数返回之前运行，

742
00:51:23,650 --> 00:51:26,530
只是要注意它们的顺序。

743
00:51:27,920 --> 00:51:31,220
好的，现在来回答你们的一些问题，

744
00:51:32,720 --> 00:51:35,360
你们中的许多人也提交了关于 Raft 的问题，

745
00:51:35,360 --> 00:51:38,630
这些会放到 Raft 的问答，

746
00:51:38,630 --> 00:51:40,760
或者办公时间

747
00:51:40,760 --> 00:51:41,720
或者你可以把它放在 Piazza 上。

748
00:51:41,720 --> 00:51:45,020
我将主要集中在 MapReduce 中的那些，

749
00:51:45,050 --> 00:51:47,990
或者，也许有时间，我们也可以看一些 Raft 问题。

750
00:51:49,950 --> 00:51:53,810
好的，第一类问题，

751
00:51:53,810 --> 00:51:59,060
是专门关于 MapReduce 的问题，

752
00:51:59,090 --> 00:52:03,620
所以，你可能需要使用 MapReduce 来执行一些更复杂的任务，

753
00:52:03,830 --> 00:52:08,690
它在机器学习、数据挖掘、统计应用中被大量使用，

754
00:52:08,810 --> 00:52:12,250
我在这里链接到 Hadoop ，

755
00:52:12,250 --> 00:52:15,010
它实现了 MapReduce ，

756
00:52:15,010 --> 00:52:17,770
很多人使用它来运行这些类型的任务。

757
00:52:18,250 --> 00:52:22,800
例如，这是一个简单的，

758
00:52:23,160 --> 00:52:24,750
也可能不是那么简单的，

759
00:52:24,750 --> 00:52:27,990
但是矩阵乘法的例子，

760
00:52:27,990 --> 00:52:30,060
你如何使用 MapReduce 来[]它。

761
00:52:31,340 --> 00:52:35,660
第二，对于 coordinator 的容错，

762
00:52:35,660 --> 00:52:41,710
论文提出了一种非常简单的检查点机制，

763
00:52:41,710 --> 00:52:44,500
你只需要启动一个新的 coordinator ，

764
00:52:44,500 --> 00:52:46,360
使用最新的检查点状态，

765
00:52:46,810 --> 00:52:50,170
在某些方面，这是 MapReduce 非常自然的设计，

766
00:52:50,170 --> 00:52:52,300
因为一切都是确定性的，

767
00:52:52,300 --> 00:52:53,140
这里没有，

768
00:52:53,500 --> 00:52:56,530
coordinator 没有那么多的状态要保持，

769
00:52:56,530 --> 00:52:57,460
我所需要知道的是

770
00:52:57,460 --> 00:52:59,470
哪些已经结束，哪些已经发生。

771
00:53:01,210 --> 00:53:05,860
当然，你可以使用 Raft 来实现容错，

772
00:53:05,860 --> 00:53:08,740
并拥有一组 coordinator ，

773
00:53:08,740 --> 00:53:13,720
这些 coordinator 都同意之前的命令和当前状态，

774
00:53:13,750 --> 00:53:21,050
但在某些方面，这对 coordinator 来说有点过了，

775
00:53:21,530 --> 00:53:23,000
对于更有状态的东西，

776
00:53:23,000 --> 00:53:25,850
比如键值存储或其他什么东西，

777
00:53:25,850 --> 00:53:28,460
使用 Raft 要自然得多。

778
00:53:30,400 --> 00:53:33,280
所以关于 MapReduce 的其他一些问题，

779
00:53:33,280 --> 00:53:34,960
shuffle 或组合器步骤，

780
00:53:35,050 --> 00:53:37,120
它在什么时候发生，它是做什么的，

781
00:53:37,120 --> 00:53:41,170
组合就发生在 Map 函数应用之后，

782
00:53:41,170 --> 00:53:44,710
例如，组合特定单词的单词计数，

783
00:53:44,830 --> 00:53:46,300
因为有很多条目，

784
00:53:46,300 --> 00:53:50,830
你可以把它们组合在一起，

785
00:53:50,830 --> 00:53:56,280
然后将其写入中间文件，

786
00:53:56,730 --> 00:53:58,590
排序在 reduce 时进行，

787
00:53:58,590 --> 00:54:02,310
在 reducer 读取了 map 的所有输出之后。

788
00:54:03,540 --> 00:54:04,500
让我们看看,

789
00:54:04,500 --> 00:54:05,820
是否有 MapReduce 的后继者，

790
00:54:05,820 --> 00:54:08,640
是的，我不是很熟悉，

791
00:54:08,640 --> 00:54:11,550
但你可以看看比如 Google Cloud Dataflow ，

792
00:54:11,790 --> 00:54:16,140
以及其他的有向图计算，

793
00:54:16,200 --> 00:54:18,900
在输入流入节点的情况下，

794
00:54:18,900 --> 00:54:20,340
所以你可以把它想象成一张图，

795
00:54:20,340 --> 00:54:22,830
然后它们可能会流向其他节点，

796
00:54:22,860 --> 00:54:27,240
中间的节点执行 map 计算，

797
00:54:27,240 --> 00:54:28,890
并产生中间数据，

798
00:54:29,070 --> 00:54:31,980
然后发送到其他图中的 reducer ，

799
00:54:32,130 --> 00:54:35,410
所以这是一种有趣的方式，

800
00:54:35,410 --> 00:54:38,950
是一种数据流的方式来思考 MapReduce 。

801
00:54:39,900 --> 00:54:41,730
我相信还会有其他的，

802
00:54:41,760 --> 00:54:43,950
我不知道在哪里。

803
00:54:44,430 --> 00:54:47,490
我知道，可能其中一个是 Spark ，

804
00:54:47,490 --> 00:54:48,780
我们将在后面读到。

805
00:54:52,700 --> 00:54:57,440
是的，但是我喜欢用图的方式来思考 MapReduce ，

806
00:54:57,470 --> 00:55:00,980
因为现在我们考虑的只是两步操作，

807
00:55:00,980 --> 00:55:04,940
在那里，它可能是很多很多步。

808
00:55:06,260 --> 00:55:09,050
哦，是的，那么在实践中输入是如何划分的，

809
00:55:09,050 --> 00:55:15,350
通常情况下，因为输入空间是特定于应用程序的，

810
00:55:15,350 --> 00:55:17,900
并且输出空间也是特定于应用的，

811
00:55:17,930 --> 00:55:21,470
这是要由程序员来指定，

812
00:55:21,860 --> 00:55:30,710
有时会有自然划分，

813
00:55:30,710 --> 00:55:34,310
比如做一个本地的矩阵计算，

814
00:55:34,310 --> 00:55:37,340
然后你想把它们组合起来，等等，

815
00:55:37,370 --> 00:55:43,700
或者，如果它只是一个巨大的文档或巨大的文本文件，

816
00:55:43,760 --> 00:55:46,100
你可以把它分成合理大小的工作，

817
00:55:46,100 --> 00:55:49,790
所以应用 map 函数会[]，

818
00:55:49,940 --> 00:55:52,670
还取决于你的集群的大小，

819
00:55:52,670 --> 00:55:53,810
你有多少 worker 。

820
00:55:57,300 --> 00:55:59,370
还有一些关于 MapReduce 的问题，

821
00:55:59,700 --> 00:56:01,410
为什么 mapper 在本地保存文件，

822
00:56:01,410 --> 00:56:02,670
所以在这篇论文中，

823
00:56:02,700 --> 00:56:07,560
这是因为在当时，网络带宽是他们的瓶颈，

824
00:56:09,180 --> 00:56:10,680
这就是为什么他们不使用 GFS ，

825
00:56:10,680 --> 00:56:13,680
他们只使用 GFS 写入，

826
00:56:16,240 --> 00:56:17,950
是的，写入输出文件。

827
00:56:18,760 --> 00:56:21,400
领导者是分布式系统所必需的吗，

828
00:56:21,490 --> 00:56:23,260
不一定，

829
00:56:24,260 --> 00:56:27,980
考虑比特币，其他去中心化系统，

830
00:56:27,980 --> 00:56:30,440
其中所有节点都进行了竞争，

831
00:56:30,440 --> 00:56:33,470
网络中的某个随机节点或某个节点，

832
00:56:33,470 --> 00:56:35,450
负责提交它们，

833
00:56:35,450 --> 00:56:38,150
所以肯定有更平等主义的设计。

834
00:56:38,910 --> 00:56:41,490
哦，是的，我们的挑战是

835
00:56:41,490 --> 00:56:44,910
在不同的服务器上运行 MapReduce ，

836
00:56:44,910 --> 00:56:49,260
而不是我们让你在实验里所做的，

837
00:56:49,680 --> 00:56:51,840
所以，为了做到这一点，

838
00:56:51,840 --> 00:56:52,650
你需要，

839
00:56:53,040 --> 00:56:57,600
不是使用 sockets 来为 RPC 通信，

840
00:56:57,840 --> 00:57:00,120
你应该使用 TCP/IP ，

841
00:57:00,120 --> 00:57:05,380
正常地通过网络进行通信，

842
00:57:05,830 --> 00:57:09,370
你可以使用像 GFS 这样的共享文件系统，

843
00:57:09,370 --> 00:57:13,000
我认为你们所有人都可以访问 Athena ，

844
00:57:13,120 --> 00:57:14,770
至少在麻省理工学院，

845
00:57:14,800 --> 00:57:18,220
ssh 到多台 Athena 机器，

846
00:57:18,220 --> 00:57:22,300
并使用 AFS 文件共享系统，

847
00:57:22,300 --> 00:57:23,980
我想 Athena 也用了，

848
00:57:24,950 --> 00:57:28,400
基本上，你可以从任何机器访问你在 Athena 上的文件，

849
00:57:28,910 --> 00:57:34,340
同样，你也可以通过租用 AWS 实例并使用 S3 来做同样的事情。

850
00:57:34,940 --> 00:57:40,100
但我们没想到你会花钱来运行我们的实验。

851
00:57:43,180 --> 00:57:46,660
好的，有一些问题，比如通用代码设计，

852
00:57:46,660 --> 00:57:49,210
所以我们也讨论了其中的一些，

853
00:57:49,630 --> 00:57:52,060
所以实验 1 很小，

854
00:57:52,090 --> 00:57:55,180
实验 2 将变得更大，

855
00:57:55,210 --> 00:57:57,460
尤其是当你进入后期阶段时，

856
00:57:57,520 --> 00:58:01,030
实验 3 和实验 4 也是一样。

857
00:58:01,690 --> 00:58:05,810
我个人觉得很方便的一件事是，

858
00:58:05,810 --> 00:58:09,610
按其用途分隔不同的代码块，

859
00:58:09,700 --> 00:58:16,190
在我如何实现代码的每一步时，

860
00:58:16,280 --> 00:58:17,870
所以把它们分开，

861
00:58:17,870 --> 00:58:21,560
比如 RPC ，以及发送者和操作者，

862
00:58:21,890 --> 00:58:26,780
可以自由地将它们物理地分开放在不同的文件中，

863
00:58:26,900 --> 00:58:27,950
那不会，

864
00:58:28,100 --> 00:58:29,870
这对测试来说也是可以的，

865
00:58:29,870 --> 00:58:32,030
它可能会对你有所帮助，

866
00:58:32,420 --> 00:58:36,470
不会在一个巨大的文件中有数千行代码。

867
00:58:38,280 --> 00:58:42,420
我个人喜欢把所有状态的定义放在一起，

868
00:58:42,420 --> 00:58:46,500
然后，函数是分开的，

869
00:58:46,500 --> 00:58:48,540
但这是我的个人喜好，

870
00:58:49,910 --> 00:58:53,750
将常见的代码片段分解为函数也将非常有用，

871
00:58:53,780 --> 00:58:57,860
例如你在 Raft 中的每个单独的 RPC ，

872
00:58:57,860 --> 00:58:59,330
你需要检查过期的 term ，

873
00:58:59,450 --> 00:59:01,520
所以将所有的逻辑，

874
00:59:01,520 --> 00:59:04,160
把重置所有状态和所有东西

875
00:59:04,160 --> 00:59:06,050
放到你要调用的一个函数中，

876
00:59:06,320 --> 00:59:07,670
将会有所帮助，

877
00:59:07,670 --> 00:59:10,340
因为你不想不小心忘记

878
00:59:10,550 --> 00:59:15,320
重置选举定时器或重置 votedFor 或某些东西，

879
00:59:16,890 --> 00:59:18,570
虽然你不应该重置选举定时器，

880
00:59:18,570 --> 00:59:19,500
所以不要那么做，

881
00:59:19,530 --> 00:59:22,860
这只是我脑海中浮现的一个例子。

882
00:59:23,250 --> 00:59:25,950
最后有一个好的环境，

883
00:59:25,950 --> 00:59:30,360
比如 autocomplete 或者能够在代码中搜索某些关键字，

884
00:59:30,360 --> 00:59:33,270
这样的事情会有很大帮助。

885
00:59:33,770 --> 00:59:35,840
所以如果你需要任何帮助来设置这个，

886
00:59:35,840 --> 00:59:37,190
可以在工作时间来，

887
00:59:37,190 --> 00:59:39,320
或者网上有大量的教程，

888
00:59:39,350 --> 00:59:41,630
你可以找一个好的编辑器，

889
00:59:41,900 --> 00:59:44,600
但这不是必要的，绝对不是必要的，

890
00:59:44,600 --> 00:59:46,370
但这可能会有所帮助。

891
00:59:48,020 --> 00:59:52,910
然后，是的，使用 Go 减少了学生花在调试上的时间，

892
00:59:53,120 --> 00:59:55,910
所以我从来没有用 C++ 实现过这些实验，

893
00:59:55,910 --> 00:59:57,410
但根据 Frans 的说法，

894
00:59:58,080 --> 01:00:03,300
Go 的一个巨大优势是它的内存管理，

895
01:00:03,510 --> 01:00:05,070
使用垃圾收集，

896
01:00:05,070 --> 01:00:06,180
你不需要处理，

897
01:00:06,180 --> 01:00:09,420
这里有指针，

898
01:00:09,420 --> 01:00:12,870
但你不必像 C++ 那样处理它们，

899
01:00:13,320 --> 01:00:17,720
我不知道你们中有多少人遇到了分段错误，

900
01:00:17,720 --> 01:00:19,670
但我猜你们中很少人，

901
01:00:19,670 --> 01:00:21,320
或者它们很容易修复，

902
01:00:21,590 --> 01:00:26,410
这无疑使调试变得更容易，

903
01:00:26,560 --> 01:00:29,320
或者它们是你不需要担心的特定类型的 bug 。

904
01:00:30,710 --> 01:00:31,670
抱歉，我有个问题。

905
01:00:32,120 --> 01:00:32,600
好的。

906
01:00:32,720 --> 01:00:35,960
这是一个 Go 的问题，

907
01:00:35,960 --> 01:00:39,170
但当你有一个可以接受的函数时，

908
01:00:39,200 --> 01:00:42,980
假设你有一个 appendEntries 参数，

909
01:00:42,980 --> 01:00:46,310
而且你也有一个 requestVote 参数，

910
01:00:46,310 --> 01:00:48,680
它们里面都有一个 term 变量，

911
01:00:48,710 --> 01:00:50,450
但当你将其传递给函数时，

912
01:00:50,960 --> 01:00:52,730
你怎么告诉这个函数，

913
01:00:52,730 --> 01:00:57,080
比如，我想要一个结构，它有一个 term 字段，

914
01:01:00,270 --> 01:01:01,410
这有可能吗？

915
01:01:02,200 --> 01:01:05,530
所以，你定义了类型，

916
01:01:05,590 --> 01:01:09,540
它就像任何其他类型，

917
01:01:09,540 --> 01:01:11,550
当你传递到函数中时，

918
01:01:11,550 --> 01:01:14,670
函数需要特定类型的参数，

919
01:01:15,190 --> 01:01:16,930
这是类型。

920
01:01:17,050 --> 01:01:17,800
嗯。

921
01:01:17,950 --> 01:01:21,370
是的，假设我想在这两种类型之间共享一个函数。

922
01:01:22,120 --> 01:01:24,250
我相信你可以使用 interface ，

923
01:01:24,250 --> 01:01:25,660
但我不确定。

924
01:01:26,570 --> 01:01:29,810
所以我试过了，但当我做 .term 时，

925
01:01:29,810 --> 01:01:32,210
它说我不知道这个字段，

926
01:01:32,330 --> 01:01:33,530
或者它不存在。

927
01:01:34,010 --> 01:01:35,510
我想你需要转换它，

928
01:01:35,630 --> 01:01:38,180
或者你需要转换，

929
01:01:38,180 --> 01:01:38,840
我想不起来了，

930
01:01:38,870 --> 01:01:41,270
但有一种方法可以强制。

931
01:01:41,570 --> 01:01:43,040
你必须对它进行类型转换，

932
01:01:43,040 --> 01:01:46,180
到你想要访问的 struct 。

933
01:01:46,900 --> 01:01:50,290
比如你需要高数 Go ，

934
01:01:50,620 --> 01:01:53,980
这个时间，我使用这个变量，

935
01:01:53,980 --> 01:01:55,690
它是一种特定的类型。

936
01:01:56,630 --> 01:01:57,620
知道了，谢谢。

937
01:01:57,650 --> 01:02:01,490
所以，如果你想对多个不同类型重复使用该函数，

938
01:02:01,700 --> 01:02:03,440
你可以传入一个接口，

939
01:02:03,470 --> 01:02:05,570
但你可能还需要传递，

940
01:02:05,570 --> 01:02:11,710
例如，比如某些东西来告诉它，

941
01:02:11,830 --> 01:02:13,540
嘿，这将是这种类型的，

942
01:02:13,540 --> 01:02:17,620
在使用它之前，需要将该接口转换为正确的类型。

943
01:02:19,540 --> 01:02:20,260
好的。

944
01:02:21,080 --> 01:02:22,820
我认为人们通常处理这件事的方式是，

945
01:02:22,820 --> 01:02:26,030
通过在接口中放置 setter 和 getter ，

946
01:02:26,210 --> 01:02:30,170
你不知道它是哪种类型的，

947
01:02:30,170 --> 01:02:32,870
你只需使用接口访问变量。

948
01:02:34,330 --> 01:02:34,750
嗯。

949
01:02:38,260 --> 01:02:39,790
是的，我不这么认为，

950
01:02:40,120 --> 01:02:44,440
你不应该在 Raft 中使用很多 interface ，

951
01:02:44,440 --> 01:02:45,850
我不认为我使用了它，

952
01:02:45,850 --> 01:02:48,850
除了已经提供的命令。

953
01:02:53,410 --> 01:02:57,160
是的，我想分解出常见的代码片段是很好的，

954
01:02:57,160 --> 01:02:59,200
除非它增加了额外的复杂性，

955
01:03:02,220 --> 01:03:05,460
我不会试着强迫你的类型，

956
01:03:05,460 --> 01:03:08,370
为了所有都能够在相同的函数上运行，

957
01:03:08,370 --> 01:03:10,140
它可能是相似的类型，

958
01:03:10,260 --> 01:03:12,270
两个略有不同的函数。

959
01:03:13,150 --> 01:03:15,640
或者，如果你使用的唯一分享是 term ，

960
01:03:15,640 --> 01:03:18,430
你可以有相同的函数只接受 term ，

961
01:03:18,430 --> 01:03:22,810
在这两种情况下，都传入 struct 的 .term 。

962
01:03:27,020 --> 01:03:29,840
好的，还有其他代码设计问题吗？

963
01:03:30,530 --> 01:03:35,870
当将代码分成多个文件时，

964
01:03:35,870 --> 01:03:39,080
有没有按要求命名的惯例，

965
01:03:39,080 --> 01:03:40,910
因为当我们做实验的时候，

966
01:03:40,940 --> 01:03:43,250
它是复制源文件，

967
01:03:43,250 --> 01:03:45,020
那么有没有什么命名约定呢？

968
01:03:46,060 --> 01:03:50,170
我的意思是，我会把它们放在 raft 文件夹中，

969
01:03:50,200 --> 01:03:52,060
但没有命名约定，

970
01:03:52,060 --> 01:03:53,890
你可以随意地命名你的文件。

971
01:03:55,220 --> 01:03:58,340
好的，我们的评分脚本将替换任何东西，

972
01:03:58,340 --> 01:04:02,630
属于测试框架的任何东西，

973
01:04:02,750 --> 01:04:07,070
所以，配置文件或测试文件，

974
01:04:07,190 --> 01:04:09,770
你在里面修改的任何东西都会被抹去。

975
01:04:12,540 --> 01:04:13,170
嗯。

976
01:04:14,550 --> 01:04:19,350
在使用外部依赖时也要稍加小心，

977
01:04:20,220 --> 01:04:24,190
一些评分脚本，我遇到一些问题，

978
01:04:24,190 --> 01:04:26,140
我有外部依赖时，

979
01:04:26,140 --> 01:04:29,500
比如使用一些 gitHub Go 包，

980
01:04:29,530 --> 01:04:32,740
但这些都是我能修好的，

981
01:04:32,740 --> 01:04:34,600
如果你这么做了，要小心一点。

982
01:04:35,130 --> 01:04:39,060
但是，是的，创建你所需要的 .go 文件。

983
01:04:42,110 --> 01:04:47,270
是的，所以指针和值比较，传递引用会更便宜，

984
01:04:47,300 --> 01:04:50,090
因为 Go 不会复制那个 struct ，

985
01:04:50,420 --> 01:04:53,280
这个问题被问到，

986
01:04:53,310 --> 01:04:58,170
特别是为什么调用使用参数，

987
01:04:58,170 --> 01:05:00,840
而回复使用指针，

988
01:05:01,200 --> 01:05:04,560
是的，这些可能是非常大的，

989
01:05:04,560 --> 01:05:07,320
所以 Go 不需要复制它们，当你调用函数时，

990
01:05:07,320 --> 01:05:08,430
这是主要原因。

991
01:05:08,880 --> 01:05:10,860
可以同时使用锁和通道吗？

992
01:05:10,860 --> 01:05:13,350
是的，你可以在 Raft 中同时是因为它们，

993
01:05:13,740 --> 01:05:15,990
所以你肯定会看到这是如何可能的。

994
01:05:18,560 --> 01:05:21,260
哦，是的，然后我们收到了很多关于超时的问题，

995
01:05:21,290 --> 01:05:25,040
所以在 MapReduce 实验里，

996
01:05:25,070 --> 01:05:26,330
超时时间是，

997
01:05:26,390 --> 01:05:30,170
我们给 worker 任务 10 秒钟时间，

998
01:05:30,230 --> 01:05:32,300
但对于睡眠时间来说，

999
01:05:32,300 --> 01:05:35,000
可以选择其他的任何时间。

1000
01:05:35,610 --> 01:05:38,970
对于 Raft ，你必须更仔细地选择超时，

1001
01:05:39,000 --> 01:05:43,980
我们的测试有点敏感，但不是非常敏感，

1002
01:05:44,100 --> 01:05:45,900
例如，你可能[]，

1003
01:05:45,900 --> 01:05:50,010
可能在 100 到 200 毫秒的范围内，

1004
01:05:50,010 --> 01:05:51,630
都是可以的。

1005
01:05:52,460 --> 01:05:55,860
是的，对选择它们来说，

1006
01:05:58,470 --> 01:06:02,400
可能会有帮助，先想想你为什么需要等待，

1007
01:06:03,440 --> 01:06:06,800
例如，对于 Raft ，

1008
01:06:06,830 --> 01:06:08,810
你的领导者发送心跳，

1009
01:06:09,330 --> 01:06:13,200
你的超时用来检测领导者停机，

1010
01:06:14,620 --> 01:06:18,730
所以，你想给领导者几次机会

1011
01:06:18,730 --> 01:06:20,440
告诉你它还活着，

1012
01:06:20,560 --> 01:06:24,700
否则你会一直认为它已经死了，

1013
01:06:24,910 --> 01:06:28,900
所以，根据你设置的心跳超时，

1014
01:06:28,990 --> 01:06:30,640
或者你的心跳间隔，

1015
01:06:30,760 --> 01:06:32,260
我认为这会给你一些指导，

1016
01:06:32,260 --> 01:06:36,550
它每秒不可能超过十次，或者类似的东西，

1017
01:06:37,640 --> 01:06:39,980
取决于你设定的心跳，

1018
01:06:40,010 --> 01:06:42,560
你会希望你的超时时间是合理的，

1019
01:06:42,560 --> 01:06:46,130
也许可以有机会得到两到三次心跳，

1020
01:06:46,790 --> 01:06:50,810
然后你必须随机化一些范围，

1021
01:06:50,840 --> 01:06:54,380
因为你不想让你所有的服务器同时开始选举，

1022
01:06:54,920 --> 01:06:58,580
要做到这一点，你可以有一个范围，

1023
01:06:59,650 --> 01:07:03,610
可能有两到五次心跳，

1024
01:07:04,240 --> 01:07:07,030
在这两者之间的某个超时时间是合理的，

1025
01:07:07,630 --> 01:07:10,090
但是对于测试，

1026
01:07:10,090 --> 01:07:13,120
你将看到是否发送了太多的 RPC ，

1027
01:07:13,390 --> 01:07:15,100
或者网络上传输的比特太多，

1028
01:07:15,100 --> 01:07:18,700
随着测试在后面的实验中，

1029
01:07:18,820 --> 01:07:21,040
你可以很容易地调整你的超时时间，

1030
01:07:21,100 --> 01:07:24,910
它稍微依赖于实现，

1031
01:07:25,090 --> 01:07:29,640
所以，我不能告诉你最适合你的数字是多少，

1032
01:07:29,970 --> 01:07:34,440
但考虑，为什么我要超时，

1033
01:07:34,560 --> 01:07:39,360
在超时之前，我希望其他服务器获得多少 RPC ，

1034
01:07:39,390 --> 01:07:41,520
是一个值得牢记的好的指标，

1035
01:07:43,390 --> 01:07:45,790
希望这对超时有很大帮助。

1036
01:07:46,900 --> 01:07:49,870
好的，是的，所以一些实现的问题，

1037
01:07:49,870 --> 01:07:53,320
关于 MapReduce 实验，

1038
01:07:53,320 --> 01:07:54,790
还有一般的实验。

1039
01:07:55,400 --> 01:08:00,150
所以，有些人实现了备份任务，

1040
01:08:00,150 --> 01:08:01,110
这是相当酷的，

1041
01:08:01,110 --> 01:08:04,020
我们在这个实验中绝对不需要这样做，

1042
01:08:04,410 --> 01:08:09,290
我认为需要记住的重要一点是，

1043
01:08:09,290 --> 01:08:14,690
论文对开始任务和重启任务做了区分，

1044
01:08:15,140 --> 01:08:16,610
因为一个 worker 失败了，

1045
01:08:17,250 --> 01:08:20,280
并再次发布任务，

1046
01:08:20,520 --> 01:08:22,860
加快滞后任务的速度，

1047
01:08:22,860 --> 01:08:24,960
worker 并没有失败，

1048
01:08:25,380 --> 01:08:27,930
但是你希望更快地完成任务，

1049
01:08:28,290 --> 01:08:30,840
所以，备份任务用于落后者，

1050
01:08:30,990 --> 01:08:32,640
当任务还没有失败时，

1051
01:08:32,640 --> 01:08:36,450
但是速度很慢并超时，

1052
01:08:36,820 --> 01:08:37,900
我们开始任务，

1053
01:08:37,900 --> 01:08:40,240
当 worker 检测到失败时。

1054
01:08:40,330 --> 01:08:41,950
所以，在论文中，

1055
01:08:41,950 --> 01:08:45,220
coordinator 从 worker 那里得到心跳，

1056
01:08:45,340 --> 01:08:49,540
而在我们为你的实验提出的设计中，

1057
01:08:49,660 --> 01:08:54,010
我们使用超时来检测 worker 可能出现失败，

1058
01:08:54,070 --> 01:08:56,500
同时还检测缓慢的任务，

1059
01:08:56,590 --> 01:09:00,520
所以，在某些方面，我们没有这种区别，

1060
01:09:00,730 --> 01:09:02,080
我们只是假设，

1061
01:09:02,110 --> 01:09:05,080
如果在这段时间内没有完成这项任务，

1062
01:09:05,140 --> 01:09:07,480
可能是 worker 失败了，

1063
01:09:07,480 --> 01:09:08,860
或许它只是慢得让人抓狂，

1064
01:09:08,860 --> 01:09:10,000
让我们重新发布它，

1065
01:09:10,240 --> 01:09:15,460
这就是为什么我们的实验没有提到备份任务。

1066
01:09:16,630 --> 01:09:21,850
所以，然后，是的，所以，这又回到了困惑，

1067
01:09:21,850 --> 01:09:25,480
下一个问题，关于同步，

1068
01:09:25,480 --> 01:09:26,980
如果服务器位于不同的机器上，

1069
01:09:26,980 --> 01:09:29,380
所以，服务器位于不同的计算机上，

1070
01:09:29,410 --> 01:09:32,260
而且它们只使用 RPC 进行通信，

1071
01:09:32,350 --> 01:09:37,480
所有同步只是同步一台服务器上的线程，

1072
01:09:38,080 --> 01:09:40,990
我只想再强调一次。

1073
01:09:43,190 --> 01:09:47,450
通常的代码竞态条件，比如日志，

1074
01:09:49,570 --> 01:09:51,930
在某些方面我认为，

1075
01:09:51,930 --> 01:09:53,850
有人在说，

1076
01:09:53,850 --> 01:09:56,010
什么时候使用锁，

1077
01:09:56,010 --> 01:09:59,070
以及什么时候使用同步，

1078
01:09:59,310 --> 01:10:04,410
所以，每当你修改文件的状态时，

1079
01:10:04,410 --> 01:10:06,480
比如 Raft 服务器或 coordinator ，

1080
01:10:06,720 --> 01:10:08,490
任何时候你修改状态时，

1081
01:10:09,020 --> 01:10:10,010
你需要加锁，

1082
01:10:10,430 --> 01:10:12,740
你会注意到，

1083
01:10:13,960 --> 01:10:18,220
例如，对于你的 Raft 实现中的几乎每个函数，

1084
01:10:18,250 --> 01:10:20,260
你会有一个锁，

1085
01:10:20,260 --> 01:10:22,990
然后在那之后，一个 defer unlock 。

1086
01:10:23,940 --> 01:10:27,720
你唯一需要确保你没有被锁的时候是，

1087
01:10:27,720 --> 01:10:29,370
当你在可能阻塞的地方调用时，

1088
01:10:29,520 --> 01:10:32,100
所以，发送 RPC ，

1089
01:10:32,220 --> 01:10:35,790
通过通道发送一些东西，

1090
01:10:36,090 --> 01:10:38,400
那些类型的操作，你不应该锁在那里，

1091
01:10:38,400 --> 01:10:41,460
因为然后那个线程会被阻塞，

1092
01:10:41,580 --> 01:10:44,460
然后持有锁并停止服务器，

1093
01:10:44,460 --> 01:10:46,590
服务器上的任何线程都不会取得进展。

1094
01:10:47,720 --> 01:10:50,720
是的，然后有一些问题，

1095
01:10:51,670 --> 01:10:54,160
有些数据竞争是良性的，

1096
01:10:54,160 --> 01:10:57,430
例如，你可以设置 isDone 为 true ，

1097
01:10:57,430 --> 01:11:00,190
你并不需要把对它加锁，

1098
01:11:00,190 --> 01:11:01,810
但是竞争检测器会抱怨，

1099
01:11:02,050 --> 01:11:04,720
你可以使用原子[]，

1100
01:11:04,720 --> 01:11:08,560
它具有相同的行为，先锁定后解锁，

1101
01:11:09,580 --> 01:11:12,910
但是，即使你认为这个数据竞争是良性的，

1102
01:11:13,060 --> 01:11:14,890
这是一种未定义的行为，

1103
01:11:15,010 --> 01:11:19,360
所以碰巧的是，最终下一次读取，

1104
01:11:19,660 --> 01:11:22,510
你的读取会忽略 isDone 的事实，

1105
01:11:22,510 --> 01:11:25,060
但下次你调用 isDone 时，它会说是 true ，

1106
01:11:25,060 --> 01:11:26,020
然后你就好了，

1107
01:11:26,200 --> 01:11:31,660
但从技术上讲，未定义的行为可以实现为任何东西，

1108
01:11:31,720 --> 01:11:34,210
比如碰巧你的编译器，

1109
01:11:34,450 --> 01:11:36,910
你的处理器会做一些合理的事情，

1110
01:11:36,970 --> 01:11:38,410
当出现数据竞争时，

1111
01:11:38,530 --> 01:11:41,740
所以你应该处理它们，特别是当它们很简单的时候，

1112
01:11:42,100 --> 01:11:45,160
而且它们对性能的影响并不是很大。

1113
01:11:45,900 --> 01:11:47,940
另一件事是，

1114
01:11:48,550 --> 01:11:54,920
嗯，在理论上，这种[]数据竞争，

1115
01:11:54,920 --> 01:11:58,490
可能意味着你的进程永远不会退出，

1116
01:11:58,550 --> 01:12:02,630
因为写入到 isDone ，将它设置为 true ，

1117
01:12:02,720 --> 01:12:05,990
可能会传播到正在读取的线程，

1118
01:12:06,020 --> 01:12:08,030
无论它是否为 true ，

1119
01:12:08,030 --> 01:12:11,360
因为它可以存储在某种缓冲区中，并且永远不会被刷新，

1120
01:12:11,390 --> 01:12:13,700
锁确保的是，

1121
01:12:13,700 --> 01:12:18,290
你的写入，下一个读取的 isDone ，

1122
01:12:18,710 --> 01:12:22,730
将看到最新的写入 isDone ，

1123
01:12:22,760 --> 01:12:23,990
并且刷新它，

1124
01:12:23,990 --> 01:12:27,860
从写入可以保存的可能的缓存区中。

1125
01:12:28,400 --> 01:12:30,980
所以，是的，这只是强调，

1126
01:12:30,980 --> 01:12:32,840
你不想要数据竞争，

1127
01:12:32,840 --> 01:12:34,730
即使你认为它们很友好。

1128
01:12:35,590 --> 01:12:37,630
干净的退出方法？

1129
01:12:38,230 --> 01:12:43,810
所以，发送一个 exit RPC 从 coordinator 到 worker ，

1130
01:12:43,990 --> 01:12:47,800
也像引号中的 Exit ，

1131
01:12:47,800 --> 01:12:51,100
worker 尝试发送 RPC ，

1132
01:12:51,100 --> 01:12:52,240
socket 已经关闭，

1133
01:12:52,270 --> 01:12:54,190
这也是可以的，

1134
01:12:56,080 --> 01:13:00,700
大多数解决方案也是可以接受的。

1135
01:13:01,780 --> 01:13:04,300
然后是意外的 EOF 错误，

1136
01:13:04,300 --> 01:13:07,740
所以，你可以看到，我在这里有一个链接，

1137
01:13:07,740 --> 01:13:09,990
当它被客户端调用时它会显示，

1138
01:13:09,990 --> 01:13:14,640
但这让人有点困惑，在什么时候发生，

1139
01:13:14,640 --> 01:13:17,310
所以我不会太担心，

1140
01:13:17,370 --> 01:13:19,230
如果有人能观察到，

1141
01:13:21,340 --> 01:13:25,390
如果他们在一个非常奇怪的时刻得到这个错误，

1142
01:13:25,390 --> 01:13:26,770
然后我们可以调查一下，

1143
01:13:26,860 --> 01:13:29,290
但我认为这对你的实现是非常具体的，

1144
01:13:29,290 --> 01:13:31,360
所以我必须专门看一下，

1145
01:13:31,660 --> 01:13:33,310
我们有一堆问题是关于它的。

1146
01:13:34,810 --> 01:13:39,700
是的，我想这就是出现的大多数问题，

1147
01:13:39,700 --> 01:13:45,250
我想现在如果你有任何关于 Go MapReduce 的问题，

1148
01:13:45,250 --> 01:13:48,400
或者如果你想向工作人员询问实验的情况。

1149
01:13:48,930 --> 01:13:53,040
我有一个关于干净退出方式的问题。

1150
01:13:53,870 --> 01:13:58,070
所以你说 Exit RPC ，

1151
01:13:58,160 --> 01:13:59,630
我只是想知道有没有，

1152
01:13:59,630 --> 01:14:01,790
是否有这种情况，

1153
01:14:02,030 --> 01:14:08,600
worker 出于某种原因需要很长时间才能到达服务器，

1154
01:14:08,600 --> 01:14:10,670
服务器如何知道，

1155
01:14:11,170 --> 01:14:14,170
比如什么时候关闭，

1156
01:14:14,410 --> 01:14:18,490
因为 coordinator 在某个时候关闭，

1157
01:14:18,490 --> 01:14:22,390
当它说 done ， done 返回 true 时，

1158
01:14:22,970 --> 01:14:27,710
它关闭，停止回复 worker ，

1159
01:14:28,280 --> 01:14:30,680
它如何决定什么时候这样做，

1160
01:14:30,680 --> 01:14:36,430
如果它在等待 worker 自己关闭。

1161
01:14:37,570 --> 01:14:41,830
哦，所以在这种情况下， coordinator 不会，

1162
01:14:42,540 --> 01:14:43,380
哦，我想，

1163
01:14:43,380 --> 01:14:45,330
所以发送可能是个错误的词，

1164
01:14:45,360 --> 01:14:47,820
coordinator 不是在等待 worker 回复，

1165
01:14:47,970 --> 01:14:53,970
coordinator 没有回复 worker 的请求，

1166
01:14:53,970 --> 01:14:57,120
比如任务已经完成，请退出，

1167
01:14:57,420 --> 01:14:58,530
worker 不是，

1168
01:14:58,680 --> 01:15:01,740
coordinator 根本不是在等待 worker ，

1169
01:15:01,770 --> 01:15:02,790
所以，在这种情况下，

1170
01:15:02,790 --> 01:15:06,420
coordinator 仍然可以在 worker 之前退出，

1171
01:15:06,480 --> 01:15:08,700
并让 worker ，

1172
01:15:09,300 --> 01:15:13,170
出现套接字断开错误并退出。

1173
01:15:14,130 --> 01:15:16,350
是的，我想我的问题是，

1174
01:15:16,350 --> 01:15:19,530
如果我可以的话，

1175
01:15:20,040 --> 01:15:23,130
coordinator 回复 worker ，

1176
01:15:23,130 --> 01:15:27,990
可能在请求任务，

1177
01:15:28,320 --> 01:15:32,070
但如果 worker 关机会发生什么，

1178
01:15:32,310 --> 01:15:34,200
或者抱歉， coordinator 关闭，

1179
01:15:34,200 --> 01:15:40,050
在它从 worker 获得 RPC 之前。

1180
01:15:40,900 --> 01:15:43,990
哦，那么下一次 worker 试图联系 coordinator 时，

1181
01:15:43,990 --> 01:15:46,840
worker 将看到连接已关闭，然后退出。

1182
01:15:48,340 --> 01:15:48,850
嗯。

1183
01:15:49,000 --> 01:15:52,780
这是我们能得到的最干净的关闭了。

1184
01:15:56,060 --> 01:15:58,730
基本上，我的意思是你可以想象，

1185
01:15:59,480 --> 01:16:03,260
您可以将 worker 设置为 RPC 服务器，

1186
01:16:03,260 --> 01:16:07,820
然后 coordinator 会发送这些，比如请退出，

1187
01:16:07,820 --> 01:16:09,920
coordinator 必须等待 worker 退出，

1188
01:16:10,070 --> 01:16:11,000
但它不是，

1189
01:16:15,340 --> 01:16:18,250
看起来你不会从中得到任何效用。

1190
01:16:20,530 --> 01:16:21,070
谢谢。

1191
01:16:21,340 --> 01:16:22,540
嗯。

1192
01:16:22,750 --> 01:16:25,630
Kat ，我看到你举手了。

1193
01:16:26,240 --> 01:16:29,420
是的，我想知道的是，

1194
01:16:29,420 --> 01:16:32,150
对于未来的实验室，我们允许有更多的文件，

1195
01:16:32,150 --> 01:16:34,040
我认为在 MapReduce 实验中，

1196
01:16:34,040 --> 01:16:35,240
我们只有三个，

1197
01:16:36,700 --> 01:16:39,520
它并没有读到像这样的东西，

1198
01:16:39,580 --> 01:16:42,400
嘿，你应该把你所有的东西都放在一个里面。

1199
01:16:43,540 --> 01:16:46,510
哦，是的，你肯定可以添加更多的文件，

1200
01:16:47,440 --> 01:16:51,280
我会鼓励你那样做，

1201
01:16:52,240 --> 01:16:54,310
我们有没有说过这个，关于 MapReduce ，

1202
01:16:55,160 --> 01:16:56,900
我不记得有没有。

1203
01:16:56,900 --> 01:17:00,740
你说你不能编辑其他任何主文件，

1204
01:17:00,740 --> 01:17:01,130
它就像是。

1205
01:17:01,130 --> 01:17:03,920
是的，你不能编辑[]，是的。

1206
01:17:03,920 --> 01:17:05,660
好的，我理解错了，谢谢，

1207
01:17:05,660 --> 01:17:07,370
这让我感觉好多了。

1208
01:17:07,610 --> 01:17:14,160
是的，但是带上你的代码肯定是有用的。

1209
01:17:16,300 --> 01:17:19,690
我有一个关于良性数据竞争的问题，

1210
01:17:21,100 --> 01:17:21,850
我想是这样的，

1211
01:17:22,630 --> 01:17:24,550
因为有时候比如 Raft ，

1212
01:17:24,550 --> 01:17:29,500
你只需要读取 Raft 服务器的当前状态，

1213
01:17:29,590 --> 01:17:34,930
为什么多个线程写入和一个读取，

1214
01:17:34,960 --> 01:17:38,350
那么为什么对同一变量的读取和写入，

1215
01:17:38,380 --> 01:17:40,780
最终导致未定义的行为，

1216
01:17:40,780 --> 01:17:43,090
因为它在写入之前或之后读取。

1217
01:17:44,020 --> 01:17:47,700
所以，有一件事可能会发生，

1218
01:17:47,700 --> 01:17:50,640
大多数处理器不会这样做，

1219
01:17:50,670 --> 01:17:55,120
但是，每次你有一个，

1220
01:17:56,140 --> 01:18:00,100
比如，任何线程都可以在单独的核心上运行，

1221
01:18:00,700 --> 01:18:05,080
每个核心都有一个缓冲区，

1222
01:18:05,230 --> 01:18:07,840
对于它读取或写入的数据，

1223
01:18:08,470 --> 01:18:10,300
或者写入，我想是一个存储缓冲区，

1224
01:18:10,360 --> 01:18:16,920
所以，例如线程 1 可以向状态写入一个值，

1225
01:18:17,280 --> 01:18:19,500
线程 2 可以尝试读取它，

1226
01:18:19,680 --> 01:18:21,750
或者多个线程可以写入，

1227
01:18:22,290 --> 01:18:25,110
线程 1 没有使用锁，

1228
01:18:25,110 --> 01:18:27,990
锁会刷新缓冲区，

1229
01:18:29,370 --> 01:18:30,870
而没有锁，

1230
01:18:31,340 --> 01:18:36,560
这个写入会永远停留在线程 1 的存储，

1231
01:18:37,040 --> 01:18:41,990
而读取将永远不会返回更新值，

1232
01:18:42,320 --> 01:18:46,990
这种行为在实践中并不经常发生，

1233
01:18:46,990 --> 01:18:48,850
但这是一种允许的行为，

1234
01:18:48,880 --> 01:18:50,230
因为你拥有的并不多。

1235
01:18:51,240 --> 01:18:53,460
抱歉，如果写操作有锁会发生什么，

1236
01:18:53,460 --> 01:18:54,720
但是读取没有，

1237
01:18:55,380 --> 01:18:57,960
比如，读取总是需要锁吗？

1238
01:19:02,970 --> 01:19:12,280
是的，因为，我想是的。

1239
01:19:13,970 --> 01:19:15,350
我用谷歌搜索了一下，

1240
01:19:15,350 --> 01:19:19,910
人们会想，是的，不要尝试无锁共享数据，

1241
01:19:19,910 --> 01:19:22,550
但我真的不明白为什么这会是个问题。

1242
01:19:23,270 --> 01:19:23,690
所以，它是。

1243
01:19:23,690 --> 01:19:24,560
你可能会。

1244
01:19:25,490 --> 01:19:26,060
继续。

1245
01:19:27,140 --> 01:19:29,900
你可能做一些假设事情是 true 的事情，

1246
01:19:29,900 --> 01:19:31,130
然后当你读取时，

1247
01:19:31,160 --> 01:19:32,780
它还不是 true ，

1248
01:19:32,960 --> 01:19:34,850
这里可能有多个事情，

1249
01:19:36,620 --> 01:19:38,510
这就是你为什么不对读取加锁。

1250
01:19:39,340 --> 01:19:45,580
所以你能避免这个的机会是，

1251
01:19:45,580 --> 01:19:48,340
如果你只读取一个字，

1252
01:19:48,610 --> 01:19:50,710
这就是线程所做的一切，

1253
01:19:50,710 --> 01:19:52,870
它不进行多次读取，

1254
01:19:54,050 --> 01:19:58,160
但我认为你还是有一些问题。

1255
01:20:01,150 --> 01:20:03,610
另一件事是，

1256
01:20:04,300 --> 01:20:06,400
如果你读取多个数据，

1257
01:20:06,490 --> 01:20:10,570
比如在一个线程上，你获取锁，分配 a ，分配 b ，

1258
01:20:10,690 --> 01:20:13,810
另一个线程，它没有获取锁，

1259
01:20:13,840 --> 01:20:16,930
可能会看到 b 的新值，

1260
01:20:16,930 --> 01:20:18,610
在它看到 a 的新值之前，

1261
01:20:18,790 --> 01:20:20,110
你弄乱了顺序，

1262
01:20:20,110 --> 01:20:25,750
所以，如果你从一个变量中读取 term ，

1263
01:20:25,750 --> 01:20:29,140
而领导者从另一个变量中读取，

1264
01:20:29,440 --> 01:20:33,370
你可能会读到一对根本不存在的值，

1265
01:20:33,580 --> 01:20:36,780
因为没有保证，

1266
01:20:36,810 --> 01:20:39,300
当你[]具体的系统时，

1267
01:20:39,510 --> 01:20:44,700
你需要基于平台提供的保证来构建所有内容，

1268
01:20:44,700 --> 01:20:45,660
如果你不这么做，

1269
01:20:45,660 --> 01:20:49,740
有各种各样奇怪的边缘情况会让你不知所措，

1270
01:20:49,950 --> 01:20:52,260
而且，是的。

1271
01:20:52,640 --> 01:20:55,640
是的，所以我认为唯一能让你，

1272
01:20:55,970 --> 01:20:57,920
比如对此进行推理，

1273
01:20:57,950 --> 01:21:03,200
就是系统中只有一个字，

1274
01:21:03,200 --> 01:21:05,270
你试图读写的，

1275
01:21:05,360 --> 01:21:11,660
只要你尝试写入或读取多个数据片段，

1276
01:21:11,660 --> 01:21:16,040
如果没有锁，你就不能对任何事情进行推理。

1277
01:21:17,480 --> 01:21:20,450
基本上，如果你想玩这个游戏，

1278
01:21:20,450 --> 01:21:23,540
你必须真正理解编译器，

1279
01:21:23,540 --> 01:21:25,790
整个[]语言和内存模型，

1280
01:21:25,850 --> 01:21:27,470
你正在使用的处理器，

1281
01:21:27,470 --> 01:21:30,200
比如内存一致性系统，

1282
01:21:31,130 --> 01:21:34,130
它变得极其复杂。

1283
01:21:34,800 --> 01:21:37,620
是的，这也是，我是说，这都是不确定的行为，

1284
01:21:37,620 --> 01:21:39,030
所以即使它现在起作用了，

1285
01:21:39,270 --> 01:21:42,690
比如，我可以，有人可以编写一个新的编译器，

1286
01:21:42,690 --> 01:21:46,410
然后整件事，

1287
01:21:46,410 --> 01:21:48,360
就像恶魔可以从你的鼻子飞出（http://catb.org/jargon/html/N/nasal-demons.html），

1288
01:21:48,360 --> 01:21:51,120
比如它可以做任何事情，如果你有数据的话，

1289
01:21:51,120 --> 01:21:54,700
因为其他程序没有任何语义，

1290
01:21:54,700 --> 01:21:57,160
所以我们可能导致疯狂，

1291
01:21:57,580 --> 01:22:00,070
所以我不会冒险。

1292
01:22:01,860 --> 01:22:03,240
好的，理解了，谢谢。

1293
01:22:04,270 --> 01:22:07,090
所以，即使当我们读取任何东西时，

1294
01:22:07,090 --> 01:22:09,310
比如只是读取 Raft 服务器的状态，

1295
01:22:09,370 --> 01:22:11,530
我们还是应该对它加锁。

1296
01:22:12,280 --> 01:22:13,180
是的。

1297
01:22:13,180 --> 01:22:14,560
有时候会很烦人，

1298
01:22:14,560 --> 01:22:15,460
因为你必须，

1299
01:22:16,120 --> 01:22:19,570
把单个读取放在 lock 和 unlock 之间，

1300
01:22:19,570 --> 01:22:22,880
但我不确定[]。

1301
01:22:24,540 --> 01:22:27,960
这种情况不应该经常发生，

1302
01:22:29,640 --> 01:22:33,450
我的意思是，也许如果你想确认你仍然是领导者，

1303
01:22:33,480 --> 01:22:35,310
如果你不退出或诸如此类的，

1304
01:22:35,880 --> 01:22:42,990
但是，是的，我不是，

1305
01:22:42,990 --> 01:22:47,400
你是不是用原子布尔型表示杀死状态，

1306
01:22:49,440 --> 01:22:51,570
你可以使用[]，

1307
01:22:51,570 --> 01:22:56,830
在访问它之前和之后，加锁和解锁，

1308
01:22:58,520 --> 01:23:00,660
但是，是的，

1309
01:23:03,900 --> 01:23:09,090
我想在某些方面有非常粗粒度的锁，

1310
01:23:09,090 --> 01:23:12,270
知道你是唯一访问状态的那个，

1311
01:23:12,270 --> 01:23:16,530
将在你对实现进行推理时变得非常方便。

1312
01:23:17,860 --> 01:23:18,490
谢谢。

1313
01:23:21,930 --> 01:23:24,780
我有一个关于通道的问题，

1314
01:23:24,780 --> 01:23:27,090
所以当你制作一个通道时，

1315
01:23:27,090 --> 01:23:30,120
它只是在两个线程之间，

1316
01:23:30,120 --> 01:23:31,890
或者它可以在多个线程之间，

1317
01:23:31,890 --> 01:23:37,200
但是如果你没有缓冲，

1318
01:23:37,350 --> 01:23:39,870
它可能会永远阻塞，

1319
01:23:39,870 --> 01:23:42,690
所以，比如，如果你想在 Raft 中做一件事，

1320
01:23:42,690 --> 01:23:44,430
然后你有一个选举，

1321
01:23:45,010 --> 01:23:46,270
你有一个通道，

1322
01:23:46,840 --> 01:23:48,730
做一些关于选举超时的事情，

1323
01:23:48,730 --> 01:23:50,230
你需要一个缓冲通道，

1324
01:23:50,530 --> 01:23:53,230
就是服务器数量的大小，

1325
01:23:53,230 --> 01:23:56,860
因为你可以发送一些东西，然后它会阻塞，

1326
01:23:56,860 --> 01:23:58,870
因为，你可以，

1327
01:23:58,870 --> 01:24:02,200
你可以有多个像选举这样的东西，

1328
01:24:02,230 --> 01:24:06,320
在通道之间发送的选举信息，

1329
01:24:06,320 --> 01:24:08,030
所以如果你想要一个没有缓冲的通道，

1330
01:24:08,030 --> 01:24:12,530
它应该只在两个线程之间，是吗？

1331
01:24:13,420 --> 01:24:14,950
我的意思是不需要，

1332
01:24:14,950 --> 01:24:16,420
例如，如果两个线程是消费者，

1333
01:24:16,420 --> 01:24:17,440
一个线程是生产者，

1334
01:24:17,440 --> 01:24:18,040
那是。

1335
01:24:20,070 --> 01:24:24,180
好的，但是多个生产者，我想你需要，是吗？

1336
01:24:25,790 --> 01:24:27,170
嗯，不需要，

1337
01:24:27,170 --> 01:24:29,210
我的意思是，如果消费者只是，

1338
01:24:29,360 --> 01:24:31,400
在做一个循环，并不断读取，

1339
01:24:31,400 --> 01:24:34,820
然后所有的生产者都会，

1340
01:24:35,850 --> 01:24:39,350
我想这取决于它们是怎么调度的，

1341
01:24:39,770 --> 01:24:41,090
如果，

1342
01:24:41,640 --> 01:24:45,300
最终会有人从通道上读出，

1343
01:24:45,750 --> 01:24:48,660
所以你可以有多个生产者和一个消费者。

1344
01:24:51,040 --> 01:24:53,800
有没有人知道，比如 Frans ，

1345
01:24:54,550 --> 01:24:56,680
你知道通道的顺序保证吗，

1346
01:24:56,710 --> 01:24:59,230
是否有[]保证给你，

1347
01:25:02,620 --> 01:25:04,420
我觉得有一个[]保证，

1348
01:25:04,420 --> 01:25:05,620
所以我想如果你有，

1349
01:25:06,220 --> 01:25:08,050
有点像锁，

1350
01:25:08,230 --> 01:25:10,150
比如，你总是试图获取锁，

1351
01:25:10,150 --> 01:25:13,270
另一个线程也试图获取锁，

1352
01:25:13,300 --> 01:25:17,290
不能保证你会获取它，

1353
01:25:17,350 --> 01:25:21,040
这就是为什么在这种情况下随机化可能是必要的，

1354
01:25:26,040 --> 01:25:29,610
我意识到，我认为这节课从技术上讲已经结束了，

1355
01:25:29,700 --> 01:25:31,650
我现在继续在办公时间，

1356
01:25:31,650 --> 01:25:33,450
所以如果你有问题要问，

1357
01:25:33,450 --> 01:25:35,160
或者想继续提问，

1358
01:25:35,160 --> 01:25:35,790
我会在那里，

1359
01:25:36,090 --> 01:25:37,950
我想也许 Frans ，

1360
01:25:37,950 --> 01:25:41,270
如果你想留下来或其他人。

1361
01:25:42,060 --> 01:25:45,030
但我现在要去办公时间了，

1362
01:25:46,620 --> 01:25:50,060
所以，非常感谢你们的到来。

1363
01:25:50,420 --> 01:25:51,080
谢谢。

1364
01:25:52,820 --> 01:25:53,630
谢谢。

1365
01:25:59,590 --> 01:26:01,810
哦，我能问个简单的问题吗？

1366
01:26:03,440 --> 01:26:05,270
是的，好的， Frans ，你现在是主持人了，

1367
01:26:05,270 --> 01:26:07,610
我要去我的办公时间了。

1368
01:26:07,610 --> 01:26:10,250
你的 Vim 的主题是什么？

1369
01:26:11,600 --> 01:26:14,060
哦，方案是什么，我的配色方案。

1370
01:26:14,360 --> 01:26:14,810
嗯。

1371
01:26:16,180 --> 01:26:17,260
这是个好问题，

1372
01:26:17,260 --> 01:26:20,710
我不太确定，让我检查一下。

1373
01:26:24,620 --> 01:26:26,030
[]。

1374
01:26:27,440 --> 01:26:29,000
抱歉?

1375
01:26:29,000 --> 01:26:30,170
我会输入到聊天内容中。

1376
01:26:30,200 --> 01:26:30,980
哈哈。

