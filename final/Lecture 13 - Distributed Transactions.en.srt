1
00:00:00,540 --> 00:00:01,440
Okay, thank you.

2
00:00:02,130 --> 00:00:05,670
Okay, so good afternoon, good evening, good morning, good night, wherever you are,

3
00:00:05,850 --> 00:00:08,940
we're going to talk today about transactions.

4
00:00:09,720 --> 00:00:11,760
And you probably noticed,

5
00:00:11,760 --> 00:00:15,330
the reading material for today a little bit more tutorial in nature,

6
00:00:15,360 --> 00:00:17,520
we're not studying a particular system,

7
00:00:17,520 --> 00:00:23,280
and see how a set of ideas are implemented in that system,

8
00:00:23,280 --> 00:00:29,520
instead what we're gonna be doing is talking about just the concept of transactions,

9
00:00:29,520 --> 00:00:33,570
because it it shows up in the next two papers,

10
00:00:33,570 --> 00:00:36,060
that we'll be studying those two papers,

11
00:00:36,060 --> 00:00:39,450
have a quite a lot of material in them,

12
00:00:39,450 --> 00:00:42,810
and assume familiar with transactions,

13
00:00:42,930 --> 00:00:48,390
in particular that you're familiar with the two core ideas that we'll see the today's lecture,

14
00:00:48,390 --> 00:00:57,950
namely 2-phase locking and 2-phase commit,

15
00:01:06,430 --> 00:01:10,390
and sometimes they are abbreviated as you know 2PC for 2-phase commit

16
00:01:10,390 --> 00:01:13,060
and 2PL for 2-phase locking,

17
00:01:13,750 --> 00:01:15,730
one point of confusion,

18
00:01:16,030 --> 00:01:19,090
the two terms really don't have to do much,

19
00:01:19,090 --> 00:01:20,590
don't have to, don't do,

20
00:01:21,380 --> 00:01:23,000
really not much related,

21
00:01:23,030 --> 00:01:28,670
you know they happen to have both words two words 2-phase in it,

22
00:01:28,910 --> 00:01:31,610
but you know they show completely different problems,

23
00:01:31,640 --> 00:01:35,930
they they have to also show up on typically in the context of transactions,

24
00:01:36,110 --> 00:01:38,300
but there are even outside of transactions,

25
00:01:38,300 --> 00:01:41,900
they are good ideas or worthwhile ideas,

26
00:01:42,420 --> 00:01:46,410
and so don't let your self confused by the fact that they both have 2-phase in it,

27
00:01:46,620 --> 00:01:48,540
they're pretty unrelated.

28
00:01:50,090 --> 00:01:52,370
Okay, so I'm just gonna dive in a little bit

29
00:01:52,370 --> 00:01:54,860
and start talking about transactions in general,

30
00:01:55,220 --> 00:02:01,610
and the reason that we're going to care about transactions a lot is,

31
00:02:01,640 --> 00:02:05,330
that we want to be able to do cross-machine operations.

32
00:02:06,360 --> 00:02:08,700
So the problem that we're going to try to tackle

33
00:02:11,220 --> 00:02:14,190
in this lecture as well as in the two upcoming papers

34
00:02:14,460 --> 00:02:22,030
is cross-machine atomic ops.

35
00:02:25,890 --> 00:02:28,530
And so for example just to make it a little bit concrete,

36
00:02:28,560 --> 00:02:30,570
let's say we have a client,

37
00:02:31,250 --> 00:02:34,040
we have two,

38
00:02:34,700 --> 00:02:36,710
we have a sharded key value server,

39
00:02:36,770 --> 00:02:40,580
so some of the keys are on key value server 1,

40
00:02:41,840 --> 00:02:44,060
some are on key value server 2,

41
00:02:44,830 --> 00:02:46,750
so the keys are split across them,

42
00:02:46,750 --> 00:02:51,340
so for example, maybe kv1 has x, kv2 has y,

43
00:02:51,940 --> 00:02:56,080
and we want to basically want to atomic operation across those two keys,

44
00:02:56,080 --> 00:03:00,820
and the easy way or the classic example in the context of transactions

45
00:03:01,000 --> 00:03:02,500
is always doing a transfer.

46
00:03:03,290 --> 00:03:08,030
So let's say the client wants to do a transfer from x to y,

47
00:03:09,140 --> 00:03:10,190
here's our client,

48
00:03:10,580 --> 00:03:15,920
and it's gonna do basically put you know to x,

49
00:03:15,920 --> 00:03:21,080
to maybe add or subtract from the account,

50
00:03:21,080 --> 00:03:22,460
so let's do x,-1

51
00:03:23,090 --> 00:03:28,370
and then the client is going to do put of y,+1,

52
00:03:29,430 --> 00:03:34,470
transfer namely one dollar from you know the account x to the account y.

53
00:03:35,460 --> 00:03:37,590
And our goal is basically going to be,

54
00:03:40,300 --> 00:03:50,020
you know we want atomicity with respect to failures and concurrency.

55
00:03:55,540 --> 00:04:00,310
So even if you know [] kv,

56
00:04:00,310 --> 00:04:03,730
the first key value server fails after the put,

57
00:04:04,030 --> 00:04:07,030
then we want like to arrange it,

58
00:04:07,030 --> 00:04:08,860
basically the transfer didn't happen at all,

59
00:04:08,890 --> 00:04:11,380
so generally the semantics that we're looking for is that,

60
00:04:11,410 --> 00:04:14,620
both operations happen or neither one of them happens.

61
00:04:15,190 --> 00:04:17,500
And so, similarly from concurrency perspective,

62
00:04:17,500 --> 00:04:19,030
if another client is running

63
00:04:19,030 --> 00:04:21,070
and also tries to inspect these accounts,

64
00:04:21,160 --> 00:04:23,260
now what we would like to be the case is that,

65
00:04:23,260 --> 00:04:25,930
both puts show atomically,

66
00:04:25,930 --> 00:04:30,100
and so other transaction cannot observe intermediate results,

67
00:04:30,100 --> 00:04:31,420
where intermediate result,

68
00:04:31,420 --> 00:04:33,670
for example, the money is deducted from x,

69
00:04:33,700 --> 00:04:35,260
that hasn't been added to y yet.

70
00:04:36,070 --> 00:04:38,740
So, these are the type of things we want to do

71
00:04:38,920 --> 00:04:41,170
and it's complete common in distributed systems,

72
00:04:41,170 --> 00:04:45,490
you know that you would like to do operation across shards.

73
00:04:48,130 --> 00:04:52,630
So that's sort of the context of what we'd like to do

74
00:04:52,930 --> 00:04:57,610
and the general plan for doing this is comes directly from the database community,

75
00:04:58,030 --> 00:05:00,790
this general plan is transactions.

76
00:05:09,780 --> 00:05:13,650
And what we'd like to do is basically group these operations,

77
00:05:13,650 --> 00:05:15,360
for example in the case with the transfer,

78
00:05:15,360 --> 00:05:18,120
two put operations into a single transaction.

79
00:05:18,700 --> 00:05:23,320
And, we like, then the property that this transaction executes atomically,

80
00:05:23,530 --> 00:05:26,950
so you know typically this requires some program annotations,

81
00:05:28,820 --> 00:05:34,850
so begin_x to indicate that the client wants to start a transaction,

82
00:05:34,880 --> 00:05:41,320
you know may be then you know the operations like add, you know add x -1

83
00:05:41,680 --> 00:05:45,550
and then add y you know +1,

84
00:05:46,570 --> 00:05:50,110
and then you have to indicate when the transaction is completed

85
00:05:51,250 --> 00:05:55,450
and so typically we come to make a commit.

86
00:05:56,410 --> 00:06:00,430
And, and so the semantics that we're looking for is that,

87
00:06:00,430 --> 00:06:03,490
these operations are executed atomically

88
00:06:03,520 --> 00:06:06,520
with respect to concurrency and respect to failure.

89
00:06:07,060 --> 00:06:08,860
And just to make it a little bit more exciting,

90
00:06:08,860 --> 00:06:10,360
let's look at second transaction,

91
00:06:10,360 --> 00:06:12,910
so that we can look at some case studies

92
00:06:12,910 --> 00:06:15,160
about how transactions actually interact,

93
00:06:15,370 --> 00:06:19,240
we might have a second transaction begin_x,

94
00:06:19,960 --> 00:06:23,560
which reads actually these accounts,

95
00:06:24,460 --> 00:06:30,870
so t1 gets x, and then t2 you know gets y,

96
00:06:33,120 --> 00:06:37,770
and print t1 and t2,

97
00:06:37,950 --> 00:06:42,000
and then end or commit.

98
00:06:47,590 --> 00:06:48,850
So we have a second transaction,

99
00:06:48,850 --> 00:06:51,880
that basically reads the account x and y and prints the values.

100
00:06:52,180 --> 00:06:55,420
And one reason that we have two transactions,

101
00:06:55,420 --> 00:06:57,370
so that we can look from the concurrency perspective,

102
00:06:57,580 --> 00:06:59,860
how these transactions actually ordered,

103
00:06:59,860 --> 00:07:02,650
what are legal outcome and what are illegal outcomes.

104
00:07:03,540 --> 00:07:09,540
Transactions turned out to be a general, almost like a piece of magic,

105
00:07:09,570 --> 00:07:14,940
basically programmers can annotate these begin and end operations,

106
00:07:15,060 --> 00:07:17,850
and it takes a whole group of operations together,

107
00:07:17,850 --> 00:07:18,750
make them atomic

108
00:07:18,870 --> 00:07:20,640
and use the system will take care of everything,

109
00:07:20,640 --> 00:07:22,050
it will take care of the locking,

110
00:07:22,200 --> 00:07:23,730
will take care of the recovery,

111
00:07:23,790 --> 00:07:25,980
it's all like the programmer doesn't have to worry about it,

112
00:07:26,160 --> 00:07:30,210
the transactions is a very very powerful construct,

113
00:07:30,980 --> 00:07:34,460
and they're useful in non distributed systems,

114
00:07:34,460 --> 00:07:38,600
you know you have a single database machine or multi-core database machine,

115
00:07:38,600 --> 00:07:40,610
and clients are submitting transactions to it,

116
00:07:41,000 --> 00:07:43,730
then the transaction system will execute these transactions

117
00:07:43,730 --> 00:07:46,190
as much as concurrently as possible,

118
00:07:46,190 --> 00:07:48,980
but also even if machine fails, it comes back up,

119
00:07:49,010 --> 00:07:53,330
you know you can actually expect the results to be there.

120
00:07:54,080 --> 00:07:58,550
And our focus of course is going to be distributed transactions,

121
00:08:02,430 --> 00:08:05,190
you know what I had the previous slide,

122
00:08:05,250 --> 00:08:09,860
namely one example across shards,

123
00:08:09,860 --> 00:08:13,220
which is a common case in data centers.

124
00:08:14,220 --> 00:08:18,450
The typical API of transaction also has one more operation

125
00:08:18,450 --> 00:08:19,800
that I didn't list here,

126
00:08:19,950 --> 00:08:21,210
and that is abort,

127
00:08:23,700 --> 00:08:26,670
so the two transactions shown here are both committing,

128
00:08:26,670 --> 00:08:29,610
but you could immediately have transaction that decides to abort,

129
00:08:29,640 --> 00:08:33,870
you know for example you might discover that,

130
00:08:33,930 --> 00:08:37,230
for example transaction T1 might check

131
00:08:37,230 --> 00:08:39,690
the x has sufficient money in it in the account,

132
00:08:39,960 --> 00:08:42,720
and if the account doesn't have sufficient money,

133
00:08:42,840 --> 00:08:45,690
instead of calling commit, it would call abort,

134
00:08:45,840 --> 00:08:49,680
and at that point the transaction would be cancelled,

135
00:08:50,010 --> 00:08:53,370
and even if the transaction aborts you know sort of halfway through,

136
00:08:53,430 --> 00:08:55,920
and maybe has done some put operations,

137
00:08:55,920 --> 00:08:57,270
the still the semantics should be,

138
00:08:57,270 --> 00:08:59,790
that none of those put operations actually happened.

139
00:09:00,730 --> 00:09:04,540
So in all cases where it's abort or commit,

140
00:09:04,690 --> 00:09:07,240
either all of them happen or none of them happen,

141
00:09:07,510 --> 00:09:08,830
never partial result,

142
00:09:09,710 --> 00:09:14,030
abort also might be called by the transaction system itself,

143
00:09:14,270 --> 00:09:16,250
for example as we'll see later,

144
00:09:16,250 --> 00:09:20,840
if a there's a, there's a deadlock between two transactions,

145
00:09:20,990 --> 00:09:24,020
then the transaction system actually can abort one of the transactions,

146
00:09:24,170 --> 00:09:25,460
in the,

147
00:09:25,550 --> 00:09:27,320
so that the other transaction continue

148
00:09:27,320 --> 00:09:30,200
and maybe retry later the transaction that was abort.

149
00:09:31,870 --> 00:09:34,330
Okay, so this is sort of primitives,

150
00:09:34,330 --> 00:09:41,170
you know begin_x commit and abort, three key interface operations.

151
00:09:41,560 --> 00:09:45,670
And then the semantics of transactions

152
00:09:45,670 --> 00:09:50,730
are typically summarized by a single word, namely ACID,

153
00:09:53,570 --> 00:09:58,370
and that stands for four key properties with transactions.

154
00:09:58,400 --> 00:10:01,210
One, it's atomic,

155
00:10:04,640 --> 00:10:07,100
and here really atomic refers to the case,

156
00:10:07,100 --> 00:10:09,650
where we have two transactions running,

157
00:10:09,650 --> 00:10:13,850
and one transaction does multiple put operations or multiple add operations,

158
00:10:13,970 --> 00:10:15,410
all those results will be,

159
00:10:15,410 --> 00:10:18,920
all visible to the other transaction or none of them will be visible,

160
00:10:19,660 --> 00:10:21,160
so that's one aspect,

161
00:10:21,460 --> 00:10:28,550
sorry, I say this, I said this is wrong,

162
00:10:28,550 --> 00:10:30,890
so the atomic actually means to crash recovery case,

163
00:10:31,130 --> 00:10:35,900
so, if a transaction actually multiple put operations,

164
00:10:35,960 --> 00:10:38,990
the transaction crashes halfway,

165
00:10:39,560 --> 00:10:42,650
the rule is that all the writes are visible,

166
00:10:42,680 --> 00:10:44,990
all writes around a stable storage or none of them,

167
00:10:45,760 --> 00:10:48,430
was the atomic sort of respect to crash recovery.

168
00:10:49,060 --> 00:10:52,150
The C stands for consistent,

169
00:10:53,090 --> 00:10:55,430
which is something we're mostly not going to talk about,

170
00:10:55,700 --> 00:10:57,920
it's more related to databases,

171
00:10:58,100 --> 00:11:01,130
it's often the case that database have internal variants,

172
00:11:01,130 --> 00:11:04,310
like referential integrity, is one of them,

173
00:11:04,460 --> 00:11:09,560
and the transaction is supposed to maintain that consistency,

174
00:11:10,320 --> 00:11:12,270
and so no internal consistencies,

175
00:11:12,720 --> 00:11:14,880
this is going to be less of a topic for us today.

176
00:11:15,180 --> 00:11:18,930
The three is isolated, the I stands for isolated,

177
00:11:23,100 --> 00:11:25,140
and isolated was,

178
00:11:25,170 --> 00:11:27,300
what I just said earlier incorrectly,

179
00:11:27,300 --> 00:11:28,590
isolated actually refers to the case,

180
00:11:28,590 --> 00:11:30,000
we're running two transactions,

181
00:11:30,270 --> 00:11:32,730
and they don't see,

182
00:11:32,730 --> 00:11:34,860
they should not observe intermediate results from each other,

183
00:11:34,890 --> 00:11:38,610
so again all the writes are applied,

184
00:11:39,600 --> 00:11:43,650
all or nothing with respect to [] to another transactions.

185
00:11:44,500 --> 00:11:47,110
And finally, the D stands for durable,

186
00:11:49,410 --> 00:11:51,270
meaning that if the transaction commits,

187
00:11:51,760 --> 00:11:54,970
then the results are written to a stable storage,

188
00:11:54,970 --> 00:11:57,520
so that if the system crashes, comes back up later,

189
00:11:57,700 --> 00:12:01,360
the latest writes or the latest transactions,

190
00:12:01,360 --> 00:12:05,260
the latest committed transactions are actually recorded on stable storage.

191
00:12:08,420 --> 00:12:12,110
Any questions about quick introduction to transactions?

192
00:12:22,210 --> 00:12:27,910
Okay, so I'm gonna talk basically about two topics quite a bit,

193
00:12:27,910 --> 00:12:32,950
namely the A part of the transactions and the I part of transactions.

194
00:12:33,070 --> 00:12:35,840
We're gonna start with the I part,

195
00:12:36,230 --> 00:12:40,040
and talk a little bit about what actually correct isolation means.

196
00:12:44,420 --> 00:12:47,150
So basically what we're looking for is a definition

197
00:12:47,480 --> 00:12:51,770
for correct execution of multiple transactions or concurrency transactions,

198
00:12:52,330 --> 00:12:56,920
in the typical definition or [] standard in the database literature,

199
00:12:57,040 --> 00:13:06,370
is called serializable or serializability,

200
00:13:08,980 --> 00:13:10,450
and what that means is that,

201
00:13:10,450 --> 00:13:13,120
if you have two transactions or many transactions,

202
00:13:13,120 --> 00:13:14,530
they execute concurrently,

203
00:13:14,890 --> 00:13:19,030
then the outcome has to be some serial order,

204
00:13:20,080 --> 00:13:27,910
so either t1 executes before t2 or t2 executes before t1,

205
00:13:27,910 --> 00:13:30,790
there's some serial or serial order,

206
00:13:35,910 --> 00:13:44,320
and the serial order has to produce the same outcome as the concurrent execution,

207
00:13:44,320 --> 00:13:47,260
so you get run two transaction concurrently,

208
00:13:47,260 --> 00:13:48,430
they produce some outcome,

209
00:13:48,550 --> 00:13:51,760
that outcome is only valid or legal or correct,

210
00:13:51,940 --> 00:13:56,260
if it could have been the result of a serial execution.

211
00:13:57,500 --> 00:14:00,470
So just to make concrete, for example,

212
00:14:00,530 --> 00:14:05,150
let's say in the account case x starts out as being 10,

213
00:14:05,300 --> 00:14:07,160
y starts out as being 10,

214
00:14:07,850 --> 00:14:09,830
we run these two transactions,

215
00:14:09,830 --> 00:14:11,570
that we had earlier on the board,

216
00:14:12,080 --> 00:14:13,940
here might be what the two transactions are,

217
00:14:14,300 --> 00:14:18,200
and one basically moves one between two accounts

218
00:14:18,200 --> 00:14:19,790
and the other one prints the results of the two.

219
00:14:21,400 --> 00:14:23,140
So if you think a little bit about it,

220
00:14:23,140 --> 00:14:24,370
if t1 goes first,

221
00:14:24,860 --> 00:14:28,280
then the outcome is gonna be 9,10,

222
00:14:29,720 --> 00:14:33,170
and the print statement is going to be,

223
00:14:40,240 --> 00:14:42,370
yeah, and the print statement,

224
00:14:42,460 --> 00:14:45,220
actually there's 9,10, sorry 9,11,

225
00:14:45,280 --> 00:14:46,450
that's why I got confused,

226
00:14:47,540 --> 00:14:49,760
and the print statement is also going to say,

227
00:14:50,240 --> 00:14:53,300
x was the one that was substract, so 9 11,

228
00:14:54,570 --> 00:14:56,640
so we get the string 9,11 out

229
00:14:56,700 --> 00:15:00,330
and two value of the accounts are 9,11,

230
00:15:00,420 --> 00:15:03,510
if two t2 goes first,

231
00:15:03,600 --> 00:15:06,570
then the outcome is you know 10,10,

232
00:15:06,690 --> 00:15:08,430
because nothing no money has moved yet,

233
00:15:08,790 --> 00:15:12,000
and then t1 goes,

234
00:15:12,000 --> 00:15:13,470
so that's a possible outcome.

235
00:15:14,960 --> 00:15:18,380
And so that's the two legal outcomes of the two transaction,

236
00:15:18,380 --> 00:15:20,630
that we're actually,

237
00:15:20,960 --> 00:15:23,450
if we executed the two transactions concurrently

238
00:15:23,450 --> 00:15:26,960
and the system guarantees serializability.

239
00:15:27,690 --> 00:15:32,940
Now you notice that serializability has probably a lot of flavor,

240
00:15:32,940 --> 00:15:36,360
of like the terminology that we used before namely linearizability,

241
00:15:36,950 --> 00:15:40,640
the key difference between serializability and linearizability is that,

242
00:15:40,640 --> 00:15:44,480
in linearizability, there's a real-time, a real-time component,

243
00:15:44,480 --> 00:15:49,430
that if transaction t2 start after t1 ends,

244
00:15:49,520 --> 00:15:52,940
then t2 has to show up later in the total order,

245
00:15:52,970 --> 00:15:53,900
in the serial order,

246
00:15:54,200 --> 00:15:56,390
in serializability, that is not required,

247
00:15:56,420 --> 00:15:58,040
so even if transaction started

248
00:15:58,280 --> 00:16:03,080
were clock time a little bit later than another transaction stopped or finished,

249
00:16:03,290 --> 00:16:06,740
and the system is still allowed to reorder it,

250
00:16:07,980 --> 00:16:12,510
so serializability in some ways a little bit weaker than linearizability.

251
00:16:13,610 --> 00:16:18,920
Nevertheless, serializability is a very convenient programming [idea], right,

252
00:16:18,920 --> 00:16:21,440
because from programming perspective,

253
00:16:21,590 --> 00:16:25,100
you could always think about transactions executing in some serial order,

254
00:16:25,990 --> 00:16:28,900
and you don't have to consider all kinds of interleavings.

255
00:16:31,330 --> 00:16:37,540
Okay, so even though serializability slightly weaker than linearizability,

256
00:16:37,630 --> 00:16:42,220
it actually disallows a whole bunch of problematic cases.

257
00:16:43,630 --> 00:16:45,760
So let me talk a little bit about that,

258
00:16:45,760 --> 00:16:50,370
just to make clear what actually serializability means,

259
00:16:51,680 --> 00:16:54,890
and what sort of executions,

260
00:16:54,890 --> 00:16:58,640
the transactions, the transaction system actually has to forbid?

261
00:17:00,730 --> 00:17:03,490
And, so let's, you know two cases,

262
00:17:03,490 --> 00:17:07,630
like here we have the first transaction,

263
00:17:07,630 --> 00:17:10,000
we have the second transaction running,

264
00:17:11,270 --> 00:17:13,550
so t1 runs, t2,

265
00:17:14,090 --> 00:17:16,850
and you know one outcome that we could have,

266
00:17:16,850 --> 00:17:21,020
is like one possible execution that might happen is,

267
00:17:21,020 --> 00:17:23,240
if we if we don't do something special,

268
00:17:23,390 --> 00:17:26,660
you know t1 gets x,

269
00:17:28,790 --> 00:17:31,070
you know here the transfer happens,

270
00:17:31,100 --> 00:17:33,380
so the updates x y happen,

271
00:17:35,290 --> 00:17:39,040
and then you know t2 does get y,

272
00:17:40,240 --> 00:17:43,060
and you know is this illegal

273
00:17:43,060 --> 00:17:46,600
or is this a serializable, is this a serializable execution?

274
00:17:47,260 --> 00:17:49,120
That's sort of question we have to ask,

275
00:17:49,690 --> 00:17:51,430
and what is the answer to that one?

276
00:17:54,420 --> 00:17:56,370
This is not serializable.

277
00:17:57,220 --> 00:17:59,440
Yeah, and because you know the outcome,

278
00:17:59,440 --> 00:18:01,450
you know if we write down what the outcome is, correct,

279
00:18:01,450 --> 00:18:04,510
then the outcome is gonna be 9,11 here,

280
00:18:04,630 --> 00:18:10,150
and this is going to write down a 10,11, right.

281
00:18:11,490 --> 00:18:12,240
I think so.

282
00:18:12,860 --> 00:18:15,050
And if we go back to our previous slides,

283
00:18:15,050 --> 00:18:17,780
that is not one of the two legal outcomes, right,

284
00:18:17,960 --> 00:18:19,490
so this is not good.

285
00:18:20,330 --> 00:18:23,600
So when we think about the implications of transaction system,

286
00:18:23,900 --> 00:18:25,070
it has to be the case,

287
00:18:25,070 --> 00:18:29,060
that it forbids this particular execution schedule,

288
00:18:29,860 --> 00:18:31,360
you know this is a simple version,

289
00:18:31,540 --> 00:18:33,880
transactions for these two examples are not so complicated,

290
00:18:33,880 --> 00:18:35,770
so there not that many interleavings you have to,

291
00:18:36,190 --> 00:18:38,440
you, you could consider that could go wrong.

292
00:18:38,590 --> 00:18:40,390
But there's at least one, other one,

293
00:18:40,420 --> 00:18:43,720
that can result in not an incorrect outcome,

294
00:18:43,900 --> 00:18:48,230
which is we do the put x first,

295
00:18:50,040 --> 00:18:51,660
so here we go,

296
00:18:52,550 --> 00:18:55,550
then you know we actually print the two,

297
00:18:55,580 --> 00:19:00,410
do two gets, get(x) get(y),

298
00:19:02,520 --> 00:19:07,080
and we do the put(y),

299
00:19:07,080 --> 00:19:10,080
is this a serializable execution,

300
00:19:22,180 --> 00:19:26,500
is this an execution that we should be forbidden by the serializable transaction system,

301
00:19:26,500 --> 00:19:28,510
or is it okay execution?

302
00:19:30,800 --> 00:19:31,640
It should be forbidden.

303
00:19:32,280 --> 00:19:33,270
It should be forbidden, correct,

304
00:19:33,270 --> 00:19:34,650
because as an outcome,

305
00:19:34,800 --> 00:19:36,000
that could not have happened,

306
00:19:36,000 --> 00:19:39,630
if we executed t1 first followed by t2

307
00:19:39,660 --> 00:19:42,150
or t2 first followed by t1, right.

308
00:19:43,900 --> 00:19:46,360
Okay, so what we clearly see is that,

309
00:19:46,360 --> 00:19:50,980
you know serializability excludes you know executions,

310
00:19:50,980 --> 00:19:55,270
and just do, in order to actually make it easier for programmers

311
00:19:55,270 --> 00:19:57,820
to think about actually what database does.

312
00:19:58,480 --> 00:20:04,480
And there are two broad approaches to forbidding executions,

313
00:20:05,300 --> 00:20:08,060
and in these approaches,

314
00:20:08,060 --> 00:20:12,380
the approach forbidding is called concurrency control.

315
00:20:22,020 --> 00:20:24,450
In the first approach,

316
00:20:24,450 --> 00:20:27,600
for the first category of solutions is,

317
00:20:27,600 --> 00:20:29,490
what is called pessimistic solutions,

318
00:20:35,400 --> 00:20:37,980
and the pessimistic solution basically involve locks,

319
00:20:40,350 --> 00:20:41,760
so the idea is that,

320
00:20:41,760 --> 00:20:44,490
when the transaction runs or starts,

321
00:20:44,580 --> 00:20:50,640
it requires necessary, necessary locks to maintain serializability,

322
00:20:50,790 --> 00:20:54,930
and only release the locks when it's guaranteed,

323
00:20:54,930 --> 00:20:58,710
that the executions will result in a serializable execution,

324
00:20:59,450 --> 00:21:00,650
so that's one approach

325
00:21:00,650 --> 00:21:02,450
and we're going to talk a little bit more about in a second.

326
00:21:03,100 --> 00:21:07,150
The second approach is is is optimistic,

327
00:21:12,050 --> 00:21:15,020
and in the optimistic approach, there was basically no locks,

328
00:21:16,730 --> 00:21:19,640
and optimistic approach, you just assume things are gonna work out,

329
00:21:20,960 --> 00:21:23,390
and basically when you get to the commit point,

330
00:21:24,130 --> 00:21:27,880
you know the [] system sort of ask yourself the question,

331
00:21:27,910 --> 00:21:31,660
well, you know all the given the operation I've done in the past,

332
00:21:31,660 --> 00:21:35,920
is that actually could that be a the result of a linearizable execution,

333
00:21:36,280 --> 00:21:39,190
or could that be the result of a serializable execution,

334
00:21:39,890 --> 00:21:43,340
if so, things are fine, no problem at all,

335
00:21:43,790 --> 00:21:45,290
then you know we're good,

336
00:21:45,320 --> 00:21:49,730
if it is result this doesn't correspond to a single execution,

337
00:21:49,850 --> 00:21:51,170
they were basically just abort,

338
00:22:01,560 --> 00:22:05,610
and maybe and it will retry probably.

339
00:22:06,150 --> 00:22:08,010
And so we'll see,

340
00:22:08,040 --> 00:22:11,880
I'm not gonna talk much about optimistic concurrency control right now,

341
00:22:12,120 --> 00:22:14,220
but next week or two weeks from now,

342
00:22:14,220 --> 00:22:15,840
after reading the FaRM paper,

343
00:22:16,260 --> 00:22:21,300
and you'll see an optimistic transaction system, distributed transaction system

344
00:22:21,300 --> 00:22:22,860
of the type that we're considering,

345
00:22:22,980 --> 00:22:28,110
that uses an optimistic, optimistic control concurrency control approach,

346
00:22:28,870 --> 00:22:31,660
but the focus for today is going to be pessimistic.

347
00:22:33,700 --> 00:22:38,770
And one you know sort of the [flip way],

348
00:22:38,770 --> 00:22:42,460
that these two approaches are described a in literature often is,

349
00:22:42,460 --> 00:22:43,930
sort of pessimistic is,

350
00:22:44,140 --> 00:22:47,680
you know you ask for permission first and then you do your operations,

351
00:22:48,070 --> 00:22:50,410
and the optimistic sort the other way around,

352
00:22:50,470 --> 00:22:52,840
you just go ahead and do your operations,

353
00:22:52,870 --> 00:22:55,480
and it turns out to be wrong, you just apologize later.

354
00:22:56,520 --> 00:23:01,470
So that is sort of analogy if you will,

355
00:23:01,950 --> 00:23:03,900
between the two different approaches.

356
00:23:05,200 --> 00:23:06,910
And now within each approach,

357
00:23:06,940 --> 00:23:08,770
whether it's pessimistic or optimistic,

358
00:23:08,830 --> 00:23:13,030
there are many different concurrency control plans,

359
00:23:13,030 --> 00:23:15,880
you know to either increase their concurrency

360
00:23:15,880 --> 00:23:19,510
or provide weaker consistency and with more concurrency,

361
00:23:19,660 --> 00:23:22,240
and so there's like a, there's a [huge literature].

362
00:23:22,900 --> 00:23:29,400
And I'm just gonna talk about one particular approach,

363
00:23:30,020 --> 00:23:31,340
which is very popular,

364
00:23:31,490 --> 00:23:34,580
particularly if you want to achieve serializability,

365
00:23:34,580 --> 00:23:35,600
it turns out that not,

366
00:23:35,660 --> 00:23:38,930
alrough I said like serializability is a gold standard for databases,

367
00:23:39,080 --> 00:23:44,090
it's often [] that databases offer multiple degrees of isolation,

368
00:23:44,120 --> 00:23:45,320
so you know as a programmer,

369
00:23:45,320 --> 00:23:48,500
you can sort of pick you know the degree of isolation that you like,

370
00:23:48,800 --> 00:23:52,160
and the reason you may want to pick a weaker degree of isolation,

371
00:23:52,160 --> 00:23:53,600
so that you can get more concurrency.

372
00:23:54,540 --> 00:23:57,810
Now we're going to stick to the gold standard of concurrency,

373
00:23:57,960 --> 00:23:59,580
which is namely serializability,

374
00:23:59,730 --> 00:24:01,470
and if you do serializability,

375
00:24:01,530 --> 00:24:04,620
then a common approache is 2-phase locking,

376
00:24:15,090 --> 00:24:19,140
in 2-phase locking, basically sort of lock per record,

377
00:24:21,100 --> 00:24:24,370
that's the starting point for database record,

378
00:24:24,370 --> 00:24:26,320
and you know in our little example,

379
00:24:26,530 --> 00:24:31,390
that would be sort of a lock for variable,

380
00:24:31,390 --> 00:24:33,430
and lock for x and lock for y.

381
00:24:34,430 --> 00:24:36,080
And there's basically two rules,

382
00:24:36,590 --> 00:24:46,980
one, transaction requires a lock before using,

383
00:24:52,020 --> 00:24:53,370
and so the idea is,

384
00:24:53,370 --> 00:24:57,420
before you know you can read or write you know to x y,

385
00:24:57,510 --> 00:24:59,520
you first have to obtain the lock,

386
00:24:59,520 --> 00:25:01,380
and the transaction system will do this for you,

387
00:25:03,470 --> 00:25:07,490
two, the T holds a lock,

388
00:25:07,730 --> 00:25:08,990
once you're acquired,

389
00:25:09,720 --> 00:25:15,790
you're not allowed to release it until commit or abort,

390
00:25:15,880 --> 00:25:19,140
whatever, whatever is the end of the transaction.

391
00:25:20,260 --> 00:25:22,300
Okay, and so in our particular case,

392
00:25:22,300 --> 00:25:27,190
if we have like T1 running and we have T2 running,

393
00:25:27,840 --> 00:25:30,840
and T1 locks x first,

394
00:25:31,290 --> 00:25:33,870
and then you know lock y,

395
00:25:34,020 --> 00:25:36,060
and it has to maintain those locks

396
00:25:36,060 --> 00:25:37,830
until it actually reaches commit points,

397
00:25:40,520 --> 00:25:43,910
so T2 runs at the same time or roughly at the same time,

398
00:25:44,060 --> 00:25:46,730
if T2 starts a little bit later,

399
00:25:46,940 --> 00:25:49,010
and it tries to grab the lock in x,

400
00:25:49,460 --> 00:25:51,020
t1 will have it,

401
00:25:51,170 --> 00:25:52,850
if T2 started a little bit later,

402
00:25:53,030 --> 00:25:55,940
and at that point, basically T2 has to wait,

403
00:25:58,140 --> 00:26:00,390
sort of standard locking protocol.

404
00:26:00,810 --> 00:26:03,330
And the basic idea 2-phase locking is that,

405
00:26:03,690 --> 00:26:08,850
it's sort of a refinement or improvement over this simple locking scheme,

406
00:26:08,850 --> 00:26:11,040
that is described in the document

407
00:26:11,040 --> 00:26:15,090
and which sometimes are called simple locking or strict locking,

408
00:26:15,180 --> 00:26:17,010
where basically at the beginning of the transaction,

409
00:26:17,070 --> 00:26:19,890
you grab all of the locks you need for the whole transaction,

410
00:26:19,950 --> 00:26:21,990
you hold them until the end and then you release them,

411
00:26:22,620 --> 00:26:25,650
and 2-phase locking is a little bit more fine-grained,

412
00:26:25,890 --> 00:26:29,940
in that, even if the transactions [],

413
00:26:32,440 --> 00:26:34,240
and they are not required to lock immediately

414
00:26:34,240 --> 00:26:35,770
all at the same time at the beginning,

415
00:26:36,620 --> 00:26:40,550
instead, they require the locks incrementally as the transaction runs,

416
00:26:40,730 --> 00:26:45,590
which allows certain concurrency patterns that are disallowed by strict lock.

417
00:26:47,320 --> 00:26:50,320
Now, the first rule seems pretty clear,

418
00:26:50,350 --> 00:26:51,250
why you need it,

419
00:26:51,580 --> 00:26:55,180
the second rule might be, maybe less obvious,

420
00:26:55,510 --> 00:26:57,580
and so it's a probably a good idea

421
00:26:57,580 --> 00:27:00,160
to actually see what goes wrong,

422
00:27:00,160 --> 00:27:01,960
if you did not maintain the second rule.

423
00:27:02,900 --> 00:27:06,650
And so, let's say talk a little bit about until commit,

424
00:27:12,250 --> 00:27:15,370
and so here we have our two transactions,

425
00:27:16,310 --> 00:27:21,460
T1 and T2 you know the transfer and the print statement,

426
00:27:21,850 --> 00:27:23,350
and so let's say you know,

427
00:27:23,350 --> 00:27:25,180
here we do our put of x,

428
00:27:25,750 --> 00:27:28,090
and so that means before the put x,

429
00:27:28,090 --> 00:27:30,130
transaction system locks x,

430
00:27:31,480 --> 00:27:34,630
and let's say that we're not following the 2-phase locking rule,

431
00:27:34,900 --> 00:27:39,700
and we actually release the lock x right after the put,

432
00:27:39,700 --> 00:27:40,600
because we're done with it,

433
00:27:40,600 --> 00:27:43,390
actually doesn't show up in transaction t1 anymore,

434
00:27:43,510 --> 00:27:45,640
there will be a later put, for us put to y,

435
00:27:47,660 --> 00:27:48,440
and let's assume that,

436
00:27:48,440 --> 00:27:53,420
before actually get to the locking of y, T2 runs,

437
00:27:53,540 --> 00:27:57,320
and actually T2 basically the whole,

438
00:27:57,960 --> 00:28:03,060
you know the two gets, you get of x and get y run,

439
00:28:03,990 --> 00:28:07,410
and so since you know T1 release the lock x,

440
00:28:07,410 --> 00:28:09,000
you know it can get the lock x,

441
00:28:09,450 --> 00:28:13,260
since T1 hasn't done to the put yet,

442
00:28:13,260 --> 00:28:15,510
you know it can also get the lock on y

443
00:28:15,840 --> 00:28:17,790
and so you know print x and y,

444
00:28:18,720 --> 00:28:22,160
and reset and then release locks.

445
00:28:26,180 --> 00:28:36,180
So, is this, would this be a serializable execution?

446
00:28:41,010 --> 00:28:42,750
No, it's the same as before.

447
00:28:42,810 --> 00:28:44,820
Yeah, exactly the same as before, right,

448
00:28:44,820 --> 00:28:48,450
because basically the print statements like here,

449
00:28:48,510 --> 00:28:51,750
they sort of slipped in between the two put in x and y,

450
00:28:51,810 --> 00:28:53,880
between the two put of the x and y,

451
00:28:54,240 --> 00:28:55,740
and we already concluded earlier,

452
00:28:55,740 --> 00:28:58,830
that is not a serializable conclusion, serializable execution.

453
00:28:59,540 --> 00:29:00,560
So this is wrong,

454
00:29:00,890 --> 00:29:02,810
and so this is a good example of demonstrating,

455
00:29:02,810 --> 00:29:04,640
that if you release the lock too early,

456
00:29:04,700 --> 00:29:08,660
in this case T1 release the x too early,

457
00:29:08,810 --> 00:29:11,030
you're not gonna get a serializable execution.

458
00:29:12,390 --> 00:29:14,220
And one way to think about it basically is that,

459
00:29:14,280 --> 00:29:19,620
whatever there's sort of an intersection between you know two lock sets,

460
00:29:19,620 --> 00:29:21,510
so T1 has a lock set of x and y,

461
00:29:21,510 --> 00:29:24,960
T2 has a lock set of x y too,

462
00:29:25,080 --> 00:29:27,300
it is important that,

463
00:29:27,300 --> 00:29:31,530
you know during, these two transactions can order in a particular way,

464
00:29:31,530 --> 00:29:34,560
that means that if the locks intersect,

465
00:29:34,710 --> 00:29:37,080
you know we have to make ensure some total ordering,

466
00:29:37,470 --> 00:29:39,030
and that means that we actually have to

467
00:29:39,030 --> 00:29:41,820
hold the lock to the end until the commit point,

468
00:29:42,100 --> 00:29:46,480
so that no intermediate results of the transaction are actually visible to other transactions,

469
00:29:47,530 --> 00:29:49,600
and we release locks before the commit point,

470
00:29:49,840 --> 00:29:52,240
we might actually make a result visible,

471
00:29:52,330 --> 00:29:55,390
even though you know may be later it's actually even abort, right,

472
00:29:55,390 --> 00:29:56,980
and then the whole change will go away,

473
00:29:58,610 --> 00:30:01,490
so this is the reason why the locks must be held to the end.

474
00:30:03,670 --> 00:30:06,910
Now, an obvious problem that many of you asked about,

475
00:30:07,300 --> 00:30:09,850
in 2-phase locking,

476
00:30:09,850 --> 00:30:12,430
is there is a, is there a chance of deadlock,

477
00:30:14,200 --> 00:30:18,920
if you're requiring the locks as the transactions execute.

478
00:30:19,430 --> 00:30:20,090
And so let's,

479
00:30:20,090 --> 00:30:21,830
this is absolutely the case,

480
00:30:22,010 --> 00:30:25,940
and so for example, let's modify T2 slightly,

481
00:30:26,480 --> 00:30:27,770
so T2 used to be,

482
00:30:27,770 --> 00:30:29,990
you know t1 gets x,

483
00:30:30,260 --> 00:30:33,560
instead we're going to do with in the opposite order refers to get y,

484
00:30:34,380 --> 00:30:38,550
and t2 gets x,

485
00:30:39,060 --> 00:30:41,730
and we remain we keep T1 the same, right,

486
00:30:41,730 --> 00:30:45,030
so T1 actually still the first put to x and then put to y,

487
00:30:45,540 --> 00:30:47,880
so now we can easily get into trouble,

488
00:30:48,850 --> 00:30:50,530
so this is T2 prime,

489
00:30:51,060 --> 00:30:54,630
and this is just the ordinary T1 that we already have,

490
00:30:54,990 --> 00:30:56,340
it does put of x,

491
00:30:57,340 --> 00:30:58,870
you know before doing the put of x

492
00:30:58,870 --> 00:31:01,390
and needs to get the lock on x,

493
00:31:01,390 --> 00:31:03,220
so L locks Lx.

494
00:31:04,000 --> 00:31:07,990
Now let's say that the ordering works out as follows,

495
00:31:07,990 --> 00:31:11,350
you know the same time to T2' runs,

496
00:31:11,590 --> 00:31:14,050
it does get y,

497
00:31:14,950 --> 00:31:17,500
so that means you've got the lock on y,

498
00:31:18,490 --> 00:31:20,920
and now you can easily see what goes wrong here,

499
00:31:21,040 --> 00:31:25,990
now t1 is gonna do put of y or wants to do put y,

500
00:31:26,530 --> 00:31:29,350
so we need to get the lock on y,

501
00:31:29,680 --> 00:31:31,720
but you can't get it,

502
00:31:31,720 --> 00:31:35,200
because you know T2' actually has the lock,

503
00:31:35,200 --> 00:31:37,480
so it has to wait here and the block,

504
00:31:38,280 --> 00:31:40,560
you know same thing is gonna happen of course on the other side,

505
00:31:40,560 --> 00:31:43,740
you know when before doing the get of x,

506
00:31:44,130 --> 00:31:47,970
T2 will need to get the lock of x,

507
00:31:48,450 --> 00:31:51,120
and you know it can't get the lock of x,

508
00:31:51,120 --> 00:31:52,410
because T1 has it,

509
00:31:52,680 --> 00:31:55,230
and so this has to wait too,

510
00:31:57,200 --> 00:32:01,580
and now we have you know T1 waiting T2',

511
00:32:01,580 --> 00:32:03,680
and we have T2' waiting T1,

512
00:32:03,740 --> 00:32:05,030
we basically have a deadlock.

513
00:32:08,670 --> 00:32:12,210
Now, what is the cool part about transaction systems is that,

514
00:32:12,210 --> 00:32:13,560
we have the abort operation,

515
00:32:14,380 --> 00:32:18,700
and so if the transaction system could detect a deadlock,

516
00:32:18,730 --> 00:32:20,920
could use abort one of the two transactions,

517
00:32:21,420 --> 00:32:23,010
let the other one proceed,

518
00:32:23,160 --> 00:32:25,830
and hopefully that will actually get to the end and commit

519
00:32:26,280 --> 00:32:28,380
and abort the other one,

520
00:32:28,440 --> 00:32:31,590
and then the client or the application can decide

521
00:32:31,590 --> 00:32:33,300
what to do with abort of transactions,

522
00:32:33,300 --> 00:32:34,530
it can actually retry it,

523
00:32:34,530 --> 00:32:36,810
you know may be so wait a little bit and then retry,

524
00:32:37,260 --> 00:32:41,220
in the hope at that point you're not going to run into a deadlock.

525
00:32:42,470 --> 00:32:46,040
And so one way to think a little bit about 2-phase locking is that,

526
00:32:46,040 --> 00:32:49,910
it has a little bit of optimistic you know flavor to it,

527
00:32:49,910 --> 00:32:50,810
in the sense that,

528
00:32:51,140 --> 00:32:52,250
it's not guaranteed,

529
00:32:52,250 --> 00:32:53,840
it won't run into problems,

530
00:32:53,870 --> 00:32:55,640
but even if it runs into problems,

531
00:32:55,670 --> 00:32:59,750
you know you can always abort and then recover from that problem.

532
00:33:03,060 --> 00:33:04,410
Any questions about this?

533
00:33:10,530 --> 00:33:13,350
So you say how do you, how do you find the deadlock?

534
00:33:13,500 --> 00:33:16,440
That's exactly I was hoping that somebody was asking that question.

535
00:33:16,770 --> 00:33:21,090
So the way, there's sort of two broad approaches that people use,

536
00:33:21,360 --> 00:33:23,550
one is,

537
00:33:23,580 --> 00:33:26,010
yeah, one is not solid as well,

538
00:33:26,010 --> 00:33:31,530
one is basically on a timeout basis,

539
00:33:31,530 --> 00:33:34,530
like if the transaction running for a long time,

540
00:33:34,530 --> 00:33:36,720
and you know they don't seem to make forward progress,

541
00:33:36,960 --> 00:33:38,910
you just abort one of them,

542
00:33:39,700 --> 00:33:41,020
and so this timeout based,

543
00:33:41,680 --> 00:33:44,830
the more systematic sort of way of thinking about it is,

544
00:33:44,830 --> 00:33:47,440
to construct an wait-for graph,

545
00:33:47,620 --> 00:33:50,650
as the transaction systems you know are moving,

546
00:33:50,650 --> 00:33:53,920
so for example if t1 runs,

547
00:33:53,950 --> 00:33:55,540
so a in the wait-for graph,

548
00:33:55,540 --> 00:33:56,890
the transactions are nodes,

549
00:33:56,920 --> 00:33:58,600
so we got a node T1

550
00:33:58,930 --> 00:34:00,490
and we make a node T2,

551
00:34:00,490 --> 00:34:01,360
when they start,

552
00:34:01,360 --> 00:34:02,710
with T2' if you will,

553
00:34:03,190 --> 00:34:06,550
and when T1 runs you know gets x, [] [],

554
00:34:06,580 --> 00:34:08,320
then gets to the lock of y,

555
00:34:08,320 --> 00:34:09,250
it can't do it,

556
00:34:09,520 --> 00:34:14,380
so we'll make an arrow from T1 to T2'

557
00:34:14,380 --> 00:34:16,960
to indicate that T1 is waiting for T2',

558
00:34:17,740 --> 00:34:19,600
then at some point, like you know T2 running,

559
00:34:19,600 --> 00:34:23,560
you know T2 hits this, T2' hits this point,

560
00:34:23,680 --> 00:34:25,870
where it want to lock x, it can't do it.

561
00:34:26,460 --> 00:34:28,020
So we'll look at,

562
00:34:28,020 --> 00:34:30,150
what's waiting for, who's holding the lock,

563
00:34:30,150 --> 00:34:31,200
well, it's t1,

564
00:34:31,440 --> 00:34:34,830
so we'll put an edge you know in the wait-for graph

565
00:34:34,830 --> 00:34:38,280
from T2 to T2' to T1,

566
00:34:38,580 --> 00:34:40,560
and now we see there's a cycle,

567
00:34:41,660 --> 00:34:43,310
and whenever there's a cycle,

568
00:34:43,310 --> 00:34:44,510
that means there's a deadlock,

569
00:34:44,840 --> 00:34:46,490
because one is waiting on the other,

570
00:34:46,550 --> 00:34:48,350
and the other is waiting on the first.

571
00:34:49,040 --> 00:34:53,870
And so, the transaction system can construct these graphs on the fly,

572
00:34:53,960 --> 00:34:57,170
detect when there's a cycle in the graph,

573
00:34:57,230 --> 00:35:00,620
and then for example either abort T1 or abort T2'.

574
00:35:02,650 --> 00:35:07,130
It's call the wait-for graph.

575
00:35:13,170 --> 00:35:14,610
What happens after the abort?

576
00:35:16,080 --> 00:35:20,130
Well, so let's say we have abort T2,

577
00:35:20,770 --> 00:35:22,510
just for as an experiment,

578
00:35:23,300 --> 00:35:25,010
so we're gonna kill this guy,

579
00:35:25,040 --> 00:35:29,660
so T2 basically the transaction system is going to arrange,

580
00:35:29,660 --> 00:35:30,620
so we'll see in a second,

581
00:35:31,100 --> 00:35:33,770
it's going to arrange that basically none results of T2

582
00:35:33,770 --> 00:35:35,630
or t2 is visible,

583
00:35:35,960 --> 00:35:38,720
at that point, the lock is released,

584
00:35:39,080 --> 00:35:43,610
the abort will force the lock release of the y,

585
00:35:43,610 --> 00:35:45,440
because t2 is backing out,

586
00:35:45,860 --> 00:35:50,150
that means that you know T1 can get the lock on y and proceed to finish,

587
00:35:50,740 --> 00:35:54,340
the client that called T2' is going to learn,

588
00:35:54,340 --> 00:35:55,510
that the transaction abort it,

589
00:35:55,810 --> 00:35:58,360
and for general you can just choose to rerun it again.

590
00:36:04,570 --> 00:36:05,410
Does it makes sense?

591
00:36:10,910 --> 00:36:14,690
Okay, so this is sort of the first part,

592
00:36:14,690 --> 00:36:17,480
and you know actually what I wanted to say about 2-phase locking,

593
00:36:17,570 --> 00:36:21,530
except I wanted to address the sort of homework assignment again,

594
00:36:21,680 --> 00:36:23,810
which is like in what situations,

595
00:36:23,810 --> 00:36:27,710
does 2-phase locking allow for more concurrency than strict locking,

596
00:36:27,740 --> 00:36:30,050
where strict locking was the protocol,

597
00:36:30,050 --> 00:36:34,360
where the transaction acquires all the locks in advance,

598
00:36:34,950 --> 00:36:37,440
and this requires that the programmer

599
00:36:37,440 --> 00:36:39,570
or like the beginning of the transaction basically declares

600
00:36:39,570 --> 00:36:41,760
which locks the transaction actually needs,

601
00:36:42,300 --> 00:36:44,940
sort of slightly indesirable, less programmer friendly,

602
00:36:45,210 --> 00:36:46,650
but it has the advantage,

603
00:36:46,650 --> 00:36:48,360
that you know you don't actually,

604
00:36:48,390 --> 00:36:49,950
you can run into these,

605
00:36:51,340 --> 00:36:54,400
you don't have to abort transaction at the end,

606
00:36:54,580 --> 00:36:56,320
in case you run into a deadlock.

607
00:36:57,060 --> 00:37:01,350
So 2-phase locking allow for more concurrency in principle,

608
00:37:01,350 --> 00:37:02,910
or should allow for more concurrency

609
00:37:03,120 --> 00:37:06,810
than the strict locking or simple locking scheme.

610
00:37:06,840 --> 00:37:10,230
And so I would like to do is a quick breakout room

611
00:37:10,230 --> 00:37:12,690
for a couple minutes like five minutes again,

612
00:37:12,960 --> 00:37:17,160
and you know convince yourself or constructing case,

613
00:37:17,190 --> 00:37:21,120
where simple locking which disallows some concurrency,

614
00:37:21,180 --> 00:37:24,450
that 2-phase locking is actually able to exploit.

615
00:37:26,730 --> 00:37:29,940
Cool, all right, let's do breakout rooms.

616
00:37:34,410 --> 00:37:36,330
Okay, see you in five minutes.

617
00:44:07,130 --> 00:44:08,150
We can't hear you.

618
00:44:17,730 --> 00:44:19,080
I think you're muted.

619
00:44:36,180 --> 00:44:40,710
I have a question about one of the previous slides that you're talking about.

620
00:44:40,740 --> 00:44:43,410
Hold on, let me double check if everybody can hear me now.

621
00:44:44,330 --> 00:44:44,870
Yes.

622
00:44:45,110 --> 00:44:49,060
Okay, good, go ahead.

623
00:44:50,620 --> 00:44:54,040
On one of your previous or I guess this is just a general question,

624
00:44:54,040 --> 00:44:57,100
but is the lock point always the same as the commit point,

625
00:44:57,370 --> 00:45:01,480
or is it possible to start relinquishing locks before your commit point.

626
00:45:01,540 --> 00:45:04,390
Okay, this is a very good question,

627
00:45:04,420 --> 00:45:06,160
so depends,

628
00:45:06,190 --> 00:45:09,280
so if you only do exclusive locking,

629
00:45:09,280 --> 00:45:11,530
as we've done so far,

630
00:45:11,530 --> 00:45:12,640
at least in my examples,

631
00:45:12,640 --> 00:45:14,500
then commit point is similar to the,

632
00:45:15,060 --> 00:45:17,820
the lock point is similar to the commit point and the abort point,

633
00:45:17,910 --> 00:45:19,830
if you have read write locking,

634
00:45:19,980 --> 00:45:24,570
the locks that allow both read locks and write locks,

635
00:45:24,870 --> 00:45:30,480
then, it's possible to release read locks earlier with some restrictions.

636
00:45:32,540 --> 00:45:33,230
Okay.

637
00:45:34,780 --> 00:45:39,710
Okay, so can somebody give me one example

638
00:45:39,710 --> 00:45:44,360
of where 2-phase locking is allowing for more concurrency than simple locking,

639
00:45:45,380 --> 00:45:47,540
just to make sure we're all on the same page.

640
00:45:52,360 --> 00:45:54,400
The audit function example,

641
00:45:54,400 --> 00:46:00,870
like you can release the lock as soon as you read this person's amount,

642
00:46:00,900 --> 00:46:03,120
like you don't have to wait until you read everyone's.

643
00:46:04,120 --> 00:46:07,210
This is an example of exploiting the read read locks,

644
00:46:07,210 --> 00:46:08,200
if you have read locks.

645
00:46:15,060 --> 00:46:16,080
Any other examples?

646
00:46:19,930 --> 00:46:21,280
If you have a transaction,

647
00:46:21,280 --> 00:46:26,320
where there's a condition that only rarely like is true,

648
00:46:26,320 --> 00:46:28,510
and you read a piece of data when it's true,

649
00:46:28,510 --> 00:46:31,750
so, at the beginning, you don't need to acquire the lock for that,

650
00:46:31,750 --> 00:46:33,340
only when you actually need to read it.

651
00:46:33,640 --> 00:46:34,780
Yeah, that's a great example,

652
00:46:34,780 --> 00:46:36,460
I personally like that example a lot,

653
00:46:36,490 --> 00:46:37,210
that's a great one.

654
00:46:38,960 --> 00:46:40,310
Good, okay, good,

655
00:46:40,310 --> 00:46:44,420
so let's move on basically down to the second topic of this lecture,

656
00:46:44,420 --> 00:46:45,890
which is 2-phase commit,

657
00:46:49,420 --> 00:46:51,190
this is really dealing with crashes,

658
00:46:53,670 --> 00:46:56,190
switch back to blue and on the white.

659
00:47:01,910 --> 00:47:04,640
We can't see the slides either yet.

660
00:47:05,120 --> 00:47:09,860
Oh, let me fix that,

661
00:47:10,970 --> 00:47:12,590
and hold on,

662
00:47:15,030 --> 00:47:20,190
share screen, step to share,

663
00:47:21,390 --> 00:47:22,620
how about now?

664
00:47:23,180 --> 00:47:23,690
Okay.

665
00:47:24,020 --> 00:47:25,910
Good, thank you.

666
00:47:26,800 --> 00:47:35,980
Alright, so 2-phase commit or 2PC that's popular called,

667
00:47:36,220 --> 00:47:41,590
again this is a very well-known popular protocol,

668
00:47:41,890 --> 00:47:43,690
I'm going to talk about that,

669
00:47:43,690 --> 00:47:49,060
base sort of simple straightforward or the most common version of the protocol,

670
00:47:49,090 --> 00:47:51,430
they're all kinds of variations of it,

671
00:47:51,640 --> 00:47:58,100
but you know in they also have the same underlying idea.

672
00:47:58,840 --> 00:48:02,530
And so again, typically in 2-phase protocol,

673
00:48:02,530 --> 00:48:06,550
and I'm going to do it in the context of the transfer transaction,

674
00:48:07,000 --> 00:48:09,970
so a client that actually wants to do a transfer,

675
00:48:10,090 --> 00:48:15,070
you know basically submits the transfer transaction to transaction system,

676
00:48:15,430 --> 00:48:21,070
and the the machine sort of receive transaction is called the coordinator,

677
00:48:23,490 --> 00:48:31,290
and that machine is in charge of running the transaction through the transaction system,

678
00:48:31,860 --> 00:48:35,910
and so the coordinator will talk in our case to two different machines,

679
00:48:37,100 --> 00:48:38,180
A and B,

680
00:48:38,960 --> 00:48:43,160
where A holds you know x and B holds y.

681
00:48:45,150 --> 00:48:52,910
And and basically you know one way that this typically goes is that,

682
00:48:52,910 --> 00:48:55,340
the coordinator for a sort of does the whole transaction,

683
00:48:55,340 --> 00:48:57,140
but in a tentative way,

684
00:48:57,200 --> 00:49:02,400
so, the put x you know results in a message to A,

685
00:49:02,430 --> 00:49:06,210
you know locking A, modifying A,

686
00:49:06,300 --> 00:49:09,690
you know put x, except,

687
00:49:09,690 --> 00:49:12,540
the put is not actually visible yet in the database,

688
00:49:12,630 --> 00:49:15,510
what what's done is putting a log,

689
00:49:15,780 --> 00:49:19,170
very much like in sort of in the Frangipani style,

690
00:49:19,170 --> 00:49:20,670
where we have to write ahead log,

691
00:49:20,940 --> 00:49:21,750
all the operations,

692
00:49:21,750 --> 00:49:24,780
that we at some point, one of [materialize] in the database itself,

693
00:49:24,810 --> 00:49:26,190
we first put in the log,

694
00:49:26,310 --> 00:49:29,250
until later, in the particular case until we hit commit,

695
00:49:29,340 --> 00:49:32,610
and then we actually will install everything in the database.

696
00:49:33,280 --> 00:49:37,360
So we do put, we do second put you know to y,

697
00:49:39,810 --> 00:49:42,120
in another same thing happens there,

698
00:49:42,120 --> 00:49:44,880
you know we got a lock on y,

699
00:49:44,910 --> 00:49:46,590
okay, so this sort of being lock on x,

700
00:49:47,080 --> 00:49:49,240
and we do a put on y,

701
00:49:50,800 --> 00:49:55,840
and again we're gonna not actually you know really put the value in the database,

702
00:49:55,840 --> 00:49:56,770
we're gonna using log,

703
00:49:56,890 --> 00:49:58,630
so we're log y

704
00:49:58,840 --> 00:50:00,070
and here we log x.

705
00:50:01,400 --> 00:50:02,060
Okay?

706
00:50:03,440 --> 00:50:07,490
And now the coordinator is done two you know the transactions,

707
00:50:07,490 --> 00:50:11,810
that two of main operations now so ready to commit,

708
00:50:12,020 --> 00:50:14,660
and here's where the 2-phase part comes in.

709
00:50:15,390 --> 00:50:19,680
And so the coordinator will send a prepare message,

710
00:50:20,410 --> 00:50:22,600
and first gonna describe this protocol,

711
00:50:22,600 --> 00:50:25,600
indicates there's no failures and everything works out,

712
00:50:26,140 --> 00:50:30,670
you know just sort of the easy cases as will,

713
00:50:31,240 --> 00:50:32,950
sends a prepare message,

714
00:50:33,490 --> 00:50:36,070
sends a prepare message to,

715
00:50:37,080 --> 00:50:41,250
to prepare A, you know prepare B,

716
00:50:45,310 --> 00:50:48,730
and the prepare message of course includes the transaction ID,

717
00:50:48,730 --> 00:50:51,130
that actually used for this transaction,

718
00:50:51,130 --> 00:50:53,560
so every transaction has a transaction ID,

719
00:50:54,130 --> 00:50:57,100
and all the message are tag with the transaction ID,

720
00:50:57,100 --> 00:50:59,830
so we always know about which transaction we're talking about,

721
00:51:00,880 --> 00:51:04,750
when A and B receives prepare messages,

722
00:51:05,110 --> 00:51:07,000
you know they look at their state,

723
00:51:07,060 --> 00:51:11,500
you know see if they indeed can actually execute the transaction,

724
00:51:11,500 --> 00:51:14,410
you know they're holding the lock on x in this case,

725
00:51:14,590 --> 00:51:16,660
the x is actually the log

726
00:51:16,810 --> 00:51:17,770
and so they sent back,

727
00:51:17,770 --> 00:51:21,160
you know saying yeah I'm ready to commit,

728
00:51:21,990 --> 00:51:25,330
So, yes, yes,

729
00:51:27,200 --> 00:51:31,610
and at this particular point, use the crucial step is,

730
00:51:31,850 --> 00:51:37,940
the coordinator now knows that basically both A and B are prepared to commit,

731
00:51:38,240 --> 00:51:44,480
and so and I have basically promised to commit by actually responding y,

732
00:51:44,660 --> 00:51:49,320
and at this point the coordinator commits,

733
00:51:49,930 --> 00:51:55,030
and then you know sends messages you know again to the A,

734
00:51:55,030 --> 00:51:59,260
saying commits you know the transaction TID,

735
00:51:59,960 --> 00:52:04,070
similar message to B you know commit TID,

736
00:52:07,190 --> 00:52:08,360
and at this particular point,

737
00:52:08,660 --> 00:52:11,420
A and B actually perform the operation,

738
00:52:11,420 --> 00:52:13,610
so they basically install,

739
00:52:14,160 --> 00:52:19,650
at this point, you know they install you know the log version of y,

740
00:52:19,980 --> 00:52:26,270
here again, this transaction, this participants installs the x,

741
00:52:26,300 --> 00:52:27,770
and then release the locks,

742
00:52:28,100 --> 00:52:32,210
so release y and here the release of x,

743
00:52:33,010 --> 00:52:37,330
then they respond back you know to the coordinator,

744
00:52:37,420 --> 00:52:39,400
saying like yep all done,

745
00:52:40,600 --> 00:52:45,790
and at that point, the transaction is completely done,

746
00:52:45,790 --> 00:52:47,800
in fact coordinator doesn't really have to

747
00:52:47,800 --> 00:52:49,960
remember anything anymore about this particular transaction.

748
00:52:50,740 --> 00:52:52,810
And also see later,

749
00:52:52,810 --> 00:52:55,690
you know A and B you know need to remember that state a little longer

750
00:52:55,690 --> 00:52:57,490
until they hear about the next transaction.

751
00:52:58,410 --> 00:53:01,830
Okay, so this is a core basic case,

752
00:53:01,830 --> 00:53:03,300
when there's absolutely no failures,

753
00:53:03,630 --> 00:53:07,980
and we see what we actually get the desired outcome, correct,

754
00:53:08,370 --> 00:53:10,500
you know when does the coordinator commits,

755
00:53:10,740 --> 00:53:23,650
coordinator commits only if A and B agree.

756
00:53:28,890 --> 00:53:30,600
Okay, it could be the case,

757
00:53:30,600 --> 00:53:34,500
that you know for example when the coordinator sends a message to B,

758
00:53:34,500 --> 00:53:38,550
and B decides, well, I can't really commit,

759
00:53:38,580 --> 00:53:41,670
maybe sort of could be multiple reasons for it,

760
00:53:42,030 --> 00:53:45,540
maybe the B actually is in a situation,

761
00:53:45,540 --> 00:53:48,120
where there's a deadlock with y,

762
00:53:48,590 --> 00:53:52,280
or you know there's no space in the log anymore,

763
00:53:52,280 --> 00:53:55,010
or there's not enough money in the account of y

764
00:53:55,430 --> 00:54:00,050
and, and so you know B could respond with an no,

765
00:54:00,320 --> 00:54:02,120
let's say in this,

766
00:54:02,330 --> 00:54:04,070
so the other possible outcome is

767
00:54:04,070 --> 00:54:06,950
you know the prepare message can actually send a no back,

768
00:54:07,490 --> 00:54:08,840
and in that case,

769
00:54:08,990 --> 00:54:13,580
the coordinator gets one yes you know from A, a no from B,

770
00:54:13,580 --> 00:54:15,230
and so both do not agree,

771
00:54:15,440 --> 00:54:16,070
and in that case,

772
00:54:16,070 --> 00:54:18,320
you know the coordinator cannot commit the transaction,

773
00:54:18,320 --> 00:54:19,910
and then it would actually abort the transaction,

774
00:54:22,600 --> 00:54:24,670
and then sends the abort messages to A and B,

775
00:54:24,670 --> 00:54:28,450
basically discontinuing the transaction,

776
00:54:28,480 --> 00:54:30,100
so those are the two possible outcomes,

777
00:54:30,100 --> 00:54:31,960
one is the commit case, one is the abort case,

778
00:54:32,110 --> 00:54:34,090
and when it is always the case,

779
00:54:34,090 --> 00:54:35,770
that the transaction only commits,

780
00:54:36,010 --> 00:54:37,600
the top level transaction only commits,

781
00:54:37,600 --> 00:54:41,620
both the participants that are involved in the transaction agreed to do so.

782
00:54:44,720 --> 00:54:49,040
Now, that's sort of the outline of the protocols,

783
00:54:49,040 --> 00:54:51,110
I want to now go through a couple of cases

784
00:54:51,110 --> 00:54:54,890
you know sort of to understand you know what can go wrong,

785
00:54:54,890 --> 00:54:56,900
and how we do, how we deal,

786
00:54:56,930 --> 00:55:01,580
how 2-phase commit arranges that actually still the right thing happens.

787
00:55:01,970 --> 00:55:03,530
Actually I have a question, yeah.

788
00:55:03,710 --> 00:55:07,850
So we said that, like B might decide that it needs to abort,

789
00:55:08,480 --> 00:55:09,590
sends back no message,

790
00:55:09,590 --> 00:55:14,300
what if it decides it needs to abort after it replied yes,

791
00:55:14,390 --> 00:55:15,740
would that ever be possible?

792
00:55:16,040 --> 00:55:18,110
No, we'll talk about in a second,

793
00:55:18,110 --> 00:55:19,790
but that's absolutely not possible,

794
00:55:19,940 --> 00:55:23,060
if you promise to commit, you have to commit.

795
00:55:25,520 --> 00:55:27,290
Or you have to be ready to commit.

796
00:55:27,350 --> 00:55:28,640
You have to be ready to commit,

797
00:55:28,640 --> 00:55:29,630
you don't commit right away,

798
00:55:29,630 --> 00:55:31,670
you have to wait until the commit message of course,

799
00:55:31,670 --> 00:55:33,260
but you can not [] out anyone,

800
00:55:33,410 --> 00:55:35,150
so until the prepare,

801
00:55:35,730 --> 00:55:38,520
the B can unilaterally abort the transaction,

802
00:55:39,100 --> 00:55:40,780
once promise yes,

803
00:55:40,930 --> 00:55:43,420
it cannot unilaterally abort the transaction anymore.

804
00:55:44,580 --> 00:55:47,220
So, is it possible where you in deadlock,

805
00:55:47,250 --> 00:55:48,870
but you can't get out of the deadlock,

806
00:55:48,870 --> 00:55:54,460
because everyone in that cycle has agreed to prepare commit.

807
00:55:55,680 --> 00:55:57,390
If everybody agrees to prepare,

808
00:55:57,390 --> 00:55:59,340
they can definitely commit, then they will commit,

809
00:56:00,660 --> 00:56:02,040
and you're still holding locks.

810
00:56:02,710 --> 00:56:04,090
Right, but what if you're in a deadlock,

811
00:56:04,090 --> 00:56:05,230
because we mentioned before,

812
00:56:05,230 --> 00:56:07,840
one of the reasons why you might want to abort.

813
00:56:07,840 --> 00:56:09,940
You would find it out before to prepare,

814
00:56:11,240 --> 00:56:12,800
if you get the locks of y,

815
00:56:13,040 --> 00:56:16,400
if you did not succeed in getting those necessary locks for the transaction,

816
00:56:16,550 --> 00:56:18,890
then you know at that point.

817
00:56:19,990 --> 00:56:20,800
Right, thank you.

818
00:56:22,680 --> 00:56:25,650
Okay, so this is exactly the kind of discussion is going to come up,

819
00:56:25,680 --> 00:56:30,330
I'm gonna, I'm gonna take the same board and replicate it,

820
00:56:30,690 --> 00:56:33,030
and consider a bunch of different cases,

821
00:56:33,960 --> 00:56:36,480
so here's the same board again,

822
00:56:36,810 --> 00:56:39,900
nothing has changed so far, it's identical,

823
00:56:40,230 --> 00:56:41,940
and so let's the first to sort of

824
00:56:41,940 --> 00:56:45,210
follow up on this question that we're just ask,

825
00:56:45,240 --> 00:56:52,520
let's first consider the case where B is in the prepared state,

826
00:56:54,180 --> 00:56:56,400
and then crashes right after,

827
00:56:58,050 --> 00:56:59,610
so it is prepared,

828
00:57:02,220 --> 00:57:07,060
it pointed back, send back to coordinator,

829
00:57:07,060 --> 00:57:10,750
that actually is agreeing to go along,

830
00:57:11,320 --> 00:57:16,450
and then right after it sends actually the prepare message ok message,

831
00:57:16,450 --> 00:57:17,590
it actually crashes,

832
00:57:19,040 --> 00:57:20,000
what does that mean,

833
00:57:22,500 --> 00:57:23,520
what needs to happen,

834
00:57:23,520 --> 00:57:25,170
how we're going to resolve this,

835
00:57:25,730 --> 00:57:26,870
or what is the risk,

836
00:57:28,220 --> 00:57:29,990
so basically if B crashes.

837
00:57:31,260 --> 00:57:33,990
If B crashes, we need to abort the whole thing, right.

838
00:57:34,710 --> 00:57:36,390
Now, we cannot abort anymore, right,

839
00:57:36,390 --> 00:57:38,340
because you know B already promised,

840
00:57:39,060 --> 00:57:39,990
that is going to commit.

841
00:57:41,540 --> 00:57:43,160
We're going to use the log?

842
00:57:44,410 --> 00:57:46,660
Yeah, well, okay, so B is gonna crash,

843
00:57:46,660 --> 00:57:48,550
at some point is going to come back up, right,

844
00:57:49,100 --> 00:57:50,540
it's going to recover hopefully.

845
00:57:51,210 --> 00:57:54,870
And what state does need to remember across crashes?

846
00:57:59,130 --> 00:58:01,410
A needs to remember that prepared.

847
00:58:01,800 --> 00:58:04,380
Yeah, and need to remember correct,

848
00:58:04,380 --> 00:58:07,500
that it prepared for transaction ID, whatever the TID was,

849
00:58:08,370 --> 00:58:11,010
and that is holding the lock on y.

850
00:58:12,930 --> 00:58:14,370
And so when it comes back up,

851
00:58:14,730 --> 00:58:17,910
the first thing it has to do sort of look, saying like how,

852
00:58:17,910 --> 00:58:23,490
was I in the middle of a participant in a distributed transaction,

853
00:58:23,490 --> 00:58:24,990
and if you look at the state,

854
00:58:24,990 --> 00:58:25,800
and you'll see that,

855
00:58:25,800 --> 00:58:29,580
it was actually prepared for transaction ID, TID,

856
00:58:29,580 --> 00:58:33,120
and it was and it must hold the lock for Ly,

857
00:58:33,270 --> 00:58:35,280
but the lock for y before it does anything else,

858
00:58:35,280 --> 00:58:37,350
you know before talking to anything,

859
00:58:37,350 --> 00:58:39,330
once it is in that state,

860
00:58:39,600 --> 00:58:41,850
then it as if it didn't crash, right,

861
00:58:41,940 --> 00:58:44,340
and things are back to normal,

862
00:58:44,490 --> 00:58:49,020
and hopefully at some point the coordinated will retry the commit message,

863
00:58:49,140 --> 00:58:53,070
the B will get up commit message for this transaction ID,

864
00:58:53,130 --> 00:58:55,290
sees that, yeah I'm indeed prepared,

865
00:58:55,380 --> 00:58:57,450
and I hope the lock at y,

866
00:58:57,450 --> 00:59:00,300
and so it goes along and installs y and etc,

867
00:59:00,300 --> 00:59:01,380
finishes the transaction.

868
00:59:04,190 --> 00:59:04,940
Is that makes sense?

869
00:59:05,700 --> 00:59:08,700
So basically you know there's a little bit of refinement here,

870
00:59:08,730 --> 00:59:13,860
that we actually have to write some stable you know data to stable storage,

871
00:59:13,860 --> 00:59:15,390
you know as part of the transaction,

872
00:59:16,340 --> 00:59:17,990
and which was part of 2-phase commit,

873
00:59:18,170 --> 00:59:20,720
this is one of the reasons the 2-phase commit is a little bit expensive,

874
00:59:20,870 --> 00:59:24,110
because not only we have to send sort of multiple round messages,

875
00:59:24,320 --> 00:59:30,170
but also participant actually has to write things to stable storage,

876
00:59:30,560 --> 00:59:32,300
and as we've talked about before,

877
00:59:32,300 --> 00:59:34,970
writing to stable storage, it's quite expensive, right,

878
00:59:34,970 --> 00:59:37,640
like could be easily a couple milliseconds,

879
00:59:37,640 --> 00:59:40,820
you know let's say one millisecond optimistically,

880
00:59:40,910 --> 00:59:41,840
that means basically,

881
00:59:41,840 --> 00:59:44,630
that were immediately limited to a thousand transaction per second,

882
00:59:44,930 --> 00:59:45,620
no more.

883
00:59:48,080 --> 00:59:50,240
Okay, let's consider another case,

884
00:59:51,750 --> 00:59:54,630
and so let me duplicate this slide again,

885
01:00:01,780 --> 01:00:06,040
and consider yet another case.

886
01:00:06,700 --> 01:00:12,700
Let's say, we the coordinator crashes,

887
01:00:12,730 --> 01:00:17,750
and so you know here's red again, which pencil,

888
01:00:18,110 --> 01:00:23,030
and you know we got like one, we got prepared messages,

889
01:00:23,330 --> 01:00:26,510
and the coordinator maybe you know send one commit message,

890
01:00:26,750 --> 01:00:28,700
and then crashes right here,

891
01:00:29,880 --> 01:00:34,290
you know what, what do we need to arrange

892
01:00:34,320 --> 01:00:36,300
to make sure that the whole plan works out.

893
01:00:42,210 --> 01:00:47,400
So the coordinator needs to store in a persistent storage what are what are the commands,

894
01:00:47,400 --> 01:00:49,830
that were promised to be committed, but we're not committed yet.

895
01:00:50,430 --> 01:00:56,460
Yeah, so the coordinator is almost the same as analysis, analysts to B's case, correct,

896
01:00:56,670 --> 01:00:58,170
if we commit a transaction,

897
01:00:58,200 --> 01:00:59,580
we need to write to stable storage,

898
01:00:59,580 --> 01:01:00,960
that we're actually committing the transaction,

899
01:01:00,960 --> 01:01:03,960
so we need to write to stable storage you know commit TID,

900
01:01:05,660 --> 01:01:08,630
so that when the coordinator comes back up,

901
01:01:08,960 --> 01:01:11,450
then it can actually finish the transaction

902
01:01:11,450 --> 01:01:15,590
until actually the A and B indeed transaction is committed,

903
01:01:15,620 --> 01:01:16,970
because A and B are waiting, right,

904
01:01:16,970 --> 01:01:19,910
A and B says, like yeah we're happy to go along,

905
01:01:20,150 --> 01:01:21,980
and they're waiting waiting

906
01:01:21,980 --> 01:01:25,670
until actually they hear from the coordinator to decide what's done,

907
01:01:25,670 --> 01:01:29,600
because once they decided, once they went along,

908
01:01:29,600 --> 01:01:31,310
once they agreed to go along,

909
01:01:31,370 --> 01:01:34,580
you know they cannot unilaterally anymore [], correct,

910
01:01:34,580 --> 01:01:39,140
because, let's say they actually both said that they agreed at all,

911
01:01:39,140 --> 01:01:40,790
then it means that the coordinator

912
01:01:40,790 --> 01:01:43,070
and they don't know they made,

913
01:01:43,070 --> 01:01:46,780
the coordinator send a commit message to for example A

914
01:01:46,780 --> 01:01:48,460
and actually has commit transaction,

915
01:01:48,730 --> 01:01:49,780
B hasn't heard yet,

916
01:01:49,780 --> 01:01:52,930
maybe the message got delayed, then the coordinator got crash,

917
01:01:53,080 --> 01:01:54,430
and you know that point,

918
01:01:54,550 --> 01:01:57,760
it would be totally wrong for B to abort the transaction,

919
01:01:57,940 --> 01:02:01,150
it really has to wait until the coordinator comes back

920
01:02:01,240 --> 01:02:04,060
to tell what actually the outcome is of the transaction.

921
01:02:07,880 --> 01:02:08,600
Okay?

922
01:02:12,880 --> 01:02:13,780
So only,

923
01:02:13,780 --> 01:02:19,060
sorry, the only message that the coordinator is not going to resend is prepare,

924
01:02:19,820 --> 01:02:23,540
that one if it gets, like doesn't get a yes, it'll just abort?

925
01:02:24,150 --> 01:02:27,180
Yeah, it was the next example, so let's do that.

926
01:02:28,010 --> 01:02:30,470
Let me duplicate this board again,

927
01:02:31,520 --> 01:02:33,830
and talk about that case.

928
01:02:33,830 --> 01:02:37,470
So, just for [], let's move it down,

929
01:02:37,800 --> 01:02:39,000
so [],

930
01:02:39,000 --> 01:02:43,710
let's say you know following thing happens,

931
01:02:44,270 --> 01:02:48,450
the this prepare message never makes it, right,

932
01:02:49,400 --> 01:02:56,510
and then you know the coordinator can unilaterally decide to abort, right,

933
01:02:57,800 --> 01:03:00,290
and in fact you can tell B you know to abort,

934
01:03:00,410 --> 01:03:04,160
and A doesn't really need to know anything about it [],

935
01:03:04,490 --> 01:03:10,790
the someone later you know will come up and ask the coordinator,

936
01:03:10,790 --> 01:03:13,460
the coordinator doesn't know anything about any more about this transaction,

937
01:03:13,670 --> 01:03:16,490
you can just tell A, that transaction is actually abort,

938
01:03:16,520 --> 01:03:18,650
because I don't have a commit record anymore,

939
01:03:18,650 --> 01:03:20,990
I was not waiting to inform anybody.

940
01:03:22,930 --> 01:03:24,370
So in that case, we can do an abort,

941
01:03:25,520 --> 01:03:27,860
and that means that B can release the locks, correct

942
01:03:27,860 --> 01:03:29,630
and B can just proceed,

943
01:03:29,990 --> 01:03:35,870
you know happily trying to the other transactions that might involve y.

944
01:03:38,630 --> 01:03:39,260
Okay?

945
01:03:40,680 --> 01:03:44,640
Sorry, so what will happen if the message to A gets lost,

946
01:03:44,880 --> 01:03:46,500
the coordinator aborts,

947
01:03:47,110 --> 01:03:48,550
and then B crashes,

948
01:03:48,700 --> 01:03:50,080
but then when it comes up

949
01:03:50,110 --> 01:03:54,460
is going to wait for commit message from coordinator,

950
01:03:54,520 --> 01:03:56,620
but the transaction has aborted already.

951
01:03:56,650 --> 01:03:59,980
Yeah, or yeah so either these two cases,

952
01:04:00,010 --> 01:04:04,750
you know presumably you know the most protocols actually B will ping the coordinator,

953
01:04:04,750 --> 01:04:06,190
because it knows who's the coordinator,

954
01:04:06,850 --> 01:04:09,460
and ask what's the outcome of that transaction.

955
01:04:15,840 --> 01:04:18,060
Okay, so one more case, I want to return to one case,

956
01:04:18,060 --> 01:04:21,030
there's actually sort of the most interesting case,

957
01:04:21,420 --> 01:04:24,090
one of the more tricky cases.

958
01:04:24,240 --> 01:04:26,790
So I just have a brief question.

959
01:04:26,790 --> 01:04:28,050
Yeah, hold on one second.

960
01:04:28,200 --> 01:04:28,500
Sorry.

961
01:04:28,800 --> 01:04:29,340
Yeah.

962
01:04:29,700 --> 01:04:31,800
Yeah, so the first question is that,

963
01:04:32,010 --> 01:04:35,820
so let's B let's say holds the lock on y,

964
01:04:36,090 --> 01:04:39,540
all the way through between putting y into the log,

965
01:04:39,570 --> 01:04:43,020
and so installing y to [].

966
01:04:43,020 --> 01:04:43,260
Yes.

967
01:04:43,320 --> 01:04:43,620
Okay.

968
01:04:44,080 --> 01:04:45,610
And then the second question,

969
01:04:45,610 --> 01:04:48,190
so the locks here are distributed,

970
01:04:48,550 --> 01:04:50,200
because we are dealing with across servers,

971
01:04:50,200 --> 01:04:53,530
or I mean if y only exist on the server B,

972
01:04:53,530 --> 01:04:55,300
then maybe we don't need this to be locking,

973
01:04:55,360 --> 01:04:56,830
I'm just curious of what the setup.

974
01:04:56,950 --> 01:04:58,330
Yeah, the setup is here basically,

975
01:04:58,330 --> 01:05:01,780
that A maintains the lock for all the shards that it has,

976
01:05:01,870 --> 01:05:04,120
for all the variables, all the records that it has,

977
01:05:04,120 --> 01:05:06,730
B maintained the lock for all the records it has.

978
01:05:07,440 --> 01:05:08,310
Okay, but if we,

979
01:05:08,310 --> 01:05:10,530
for example have y being on multiple servers,

980
01:05:10,530 --> 01:05:12,270
then we need some sort of distributed lock?

981
01:05:12,720 --> 01:05:15,780
Yeah, like we were talking about the sharded case, right,

982
01:05:15,780 --> 01:05:18,210
where the accounts are sharded across multiple servers,

983
01:05:18,360 --> 01:05:20,250
and only one server has a particular account.

984
01:05:22,560 --> 01:05:23,280
Awesome, thank you.

985
01:05:23,370 --> 01:05:25,830
I'm Come back to this later, actually one more time.

986
01:05:27,060 --> 01:05:29,910
So the first thing I wanted to point out is,

987
01:05:29,910 --> 01:05:36,400
just go back to sort of the, the case,

988
01:05:36,400 --> 01:05:47,070
where B or A you know said yes and then crashes, correct,

989
01:05:47,600 --> 01:05:50,030
or actually yeah, let me see if that's the case,

990
01:05:50,610 --> 01:05:52,740
no, I want the case of following case, right,

991
01:05:53,570 --> 01:05:56,060
fix this line,

992
01:05:56,620 --> 01:05:58,750
so A and B promised their thing,

993
01:05:59,050 --> 01:06:02,080
but I want to go back to the case,

994
01:06:02,080 --> 01:06:03,700
where that we already discussed,

995
01:06:03,820 --> 01:06:07,270
which is right after the commit point,

996
01:06:07,950 --> 01:06:09,180
the coordinator crashes.

997
01:06:10,490 --> 01:06:10,940
Okay.

998
01:06:11,510 --> 01:06:18,400
And, and we know correct this interval of time from here to there,

999
01:06:18,400 --> 01:06:23,230
basically B cannot unilaterally abort anymore, right,

1000
01:06:23,230 --> 01:06:25,720
because it promised to go along,

1001
01:06:25,900 --> 01:06:28,090
and it might have been the case,

1002
01:06:28,090 --> 01:06:31,180
that actually A did actually already did commit,

1003
01:06:31,830 --> 01:06:35,280
and so it cannot unilaterally abort anymore,

1004
01:06:35,550 --> 01:06:37,980
and so there's only one option in this case,

1005
01:06:37,980 --> 01:06:38,970
what is that one option?

1006
01:06:52,380 --> 01:06:53,760
We just wait.

1007
01:06:54,030 --> 01:06:57,600
Yeah, it's unfortunate but true,

1008
01:06:59,250 --> 01:07:00,840
the only thing that we can do is wait,

1009
01:07:01,650 --> 01:07:04,530
and it's still holding the lock on y, correct,

1010
01:07:04,530 --> 01:07:05,250
so that means that,

1011
01:07:05,250 --> 01:07:08,820
any other transaction that involves y you know cannot proceed,

1012
01:07:09,240 --> 01:07:13,680
one has to wait you know until the coordinator comes back,

1013
01:07:14,010 --> 01:07:18,000
and announces or re-announces whatever decision was,

1014
01:07:18,000 --> 01:07:20,130
that actually was the outcome for that particular transaction.

1015
01:07:21,160 --> 01:07:24,310
This is one of the sort of the two aspects,

1016
01:07:24,310 --> 01:07:27,400
you know this one of these aspects of 2-phase commit,

1017
01:07:27,760 --> 01:07:31,120
that are been desirable, right,

1018
01:07:31,120 --> 01:07:37,990
where the protocol might just block until a machine comes back.

1019
01:07:40,450 --> 01:07:41,350
Does that make sense?

1020
01:07:45,720 --> 01:07:48,390
So how do people deal with this in practice,

1021
01:07:48,390 --> 01:07:50,650
well, it's a little bit unfortunate,

1022
01:07:50,950 --> 01:07:55,210
but the here's were some of our techniques from the past can come to rescue,

1023
01:07:55,240 --> 01:07:57,190
you know what could we do with the coordinator,

1024
01:07:58,610 --> 01:08:00,560
to make this scenario unlikely.

1025
01:08:06,420 --> 01:08:08,310
So we can make it fault tolerant, like.

1026
01:08:08,310 --> 01:08:10,530
Yeah, make fault tolerant, how could we do it?

1027
01:08:13,110 --> 01:08:15,570
Well, there are multiple approaches, but,

1028
01:08:17,170 --> 01:08:19,030
you can do it maybe through raft.

1029
01:08:19,700 --> 01:08:22,610
Yeah, you know run raft

1030
01:08:22,610 --> 01:08:26,540
to basically basically run the coordinator not on a single machine,

1031
01:08:26,540 --> 01:08:29,960
we basically have a replicated state machine that implements the coordinator,

1032
01:08:30,350 --> 01:08:32,060
and you know we use raft

1033
01:08:32,060 --> 01:08:36,140
to sort of keep the replicated state machine

1034
01:08:36,140 --> 01:08:38,840
and implement the coordinator in sync,

1035
01:08:39,200 --> 01:08:43,340
and then if one of the machines that forms the coordinator fails,

1036
01:08:43,340 --> 01:08:45,200
hopefully the two others are still there,

1037
01:08:45,380 --> 01:08:47,720
and so we can still proceed, right,

1038
01:08:49,260 --> 01:08:52,920
and so it's potentially possible to basically

1039
01:08:52,920 --> 01:08:54,570
you know replicate the coordinator

1040
01:08:54,570 --> 01:08:57,540
or actually any of the participants to you know using raft.

1041
01:08:59,170 --> 01:09:00,190
So let me actually,

1042
01:09:01,200 --> 01:09:04,560
so discuss this a little bit and talk a little bit more,

1043
01:09:10,010 --> 01:09:10,970
a couple of discussion points,

1044
01:09:10,970 --> 01:09:13,340
which is you know we could use Raft

1045
01:09:17,480 --> 01:09:23,170
to make a coordinator fault tolerant or available, if you will,

1046
01:09:24,480 --> 01:09:26,190
it's really property we care about.

1047
01:09:31,210 --> 01:09:32,110
Does that make sense?

1048
01:09:36,450 --> 01:09:37,710
In fact, you will see,

1049
01:09:37,740 --> 01:09:40,320
if you do lab 4 instead of a project,

1050
01:09:40,620 --> 01:09:42,690
this is exactly what lab 4 does,

1051
01:09:43,020 --> 01:09:45,960
lab 4 actually has a similar scheme,

1052
01:09:45,960 --> 01:09:49,380
where there's a form of 2-phase commit,

1053
01:09:49,380 --> 01:09:56,970
that you implement and move the the master shard or the master coordinator,

1054
01:09:57,150 --> 01:10:01,710
and then rebalances shards across shard servers,

1055
01:10:02,040 --> 01:10:04,230
uses Raft replicated to actually replicate itself,

1056
01:10:04,230 --> 01:10:07,200
to shard servers itself, also replicated itself using Raft,

1057
01:10:07,260 --> 01:10:10,920
and so where many, many Raft groups running in parallel,

1058
01:10:12,220 --> 01:10:14,290
and also the essence of lab 4,

1059
01:10:14,500 --> 01:10:16,750
and so this is like typically way,

1060
01:10:16,750 --> 01:10:19,240
you know if you're concerned about

1061
01:10:19,240 --> 01:10:22,270
having the system being blocked for a long period of time,

1062
01:10:22,270 --> 01:10:23,140
one way to do it is

1063
01:10:23,140 --> 01:10:26,710
basically make the coordinator fault tolerance.

1064
01:10:31,460 --> 01:10:33,590
So that [] brings me to something else,

1065
01:10:33,590 --> 01:10:35,630
which a lot of people ask about,

1066
01:10:35,870 --> 01:10:42,010
you know is Raft, are Raft and 2-phase commits sort of similar things,

1067
01:10:46,000 --> 01:10:48,190
or could you do 2-phase commit with raft

1068
01:10:48,190 --> 01:10:52,900
or you need to have a little bit of a parallel, correct,

1069
01:10:52,900 --> 01:10:56,470
like one thing is called coordinator, raft called the leader,

1070
01:10:56,740 --> 01:11:01,570
we gotta participants, you know maybe we can figure out these as followers,

1071
01:11:01,930 --> 01:11:05,050
so you know seems to have some similarities,

1072
01:11:05,050 --> 01:11:06,160
like how do we think about it,

1073
01:11:06,160 --> 01:11:09,370
what's the relationship between Raft and 2PC?

1074
01:11:12,060 --> 01:11:13,620
The difference is that,

1075
01:11:13,740 --> 01:11:16,830
in Raft the coordinator can change essentially,

1076
01:11:17,070 --> 01:11:20,520
otherwise it's like the single point of failure.

1077
01:11:20,670 --> 01:11:23,080
Yep, good point, any?

1078
01:11:24,900 --> 01:11:26,580
So another difference is that,

1079
01:11:26,580 --> 01:11:29,160
the Raft basically depends on the concept of a majority,

1080
01:11:29,160 --> 01:11:30,690
whereas in 2-phase commit coordinator,

1081
01:11:30,690 --> 01:11:34,530
it needs to get a response from every single other server,

1082
01:11:34,530 --> 01:11:35,970
that is involved in the.

1083
01:11:37,620 --> 01:11:38,070
Yeah, good point,

1084
01:11:38,070 --> 01:11:40,950
so these are almost like critical differences, right,

1085
01:11:41,310 --> 01:11:44,160
and you know we're wondering if we get to a point,

1086
01:11:44,160 --> 01:11:45,960
where like if there's a conceptual difference,

1087
01:11:45,960 --> 01:11:48,590
like do they solve the same problem?

1088
01:11:49,730 --> 01:11:52,820
Oh, Raft is for replicating the same thing,

1089
01:11:53,420 --> 01:11:56,330
and 2-phase commit, when you do the opposite,

1090
01:11:56,330 --> 01:12:00,770
when you instead of having one thing you spread across different servers,

1091
01:12:00,800 --> 01:12:03,200
then you have to deal with the problem.

1092
01:12:03,680 --> 01:12:08,190
Exactly, in Raft, all servers do the same thing,

1093
01:12:13,880 --> 01:12:16,040
implementing replicate state machine, right,

1094
01:12:18,150 --> 01:12:23,460
and in 2PC, actually servers were all servers operate on different data,

1095
01:12:35,300 --> 01:12:38,630
the first participant was actually operating on x,

1096
01:12:38,630 --> 01:12:40,700
and second participate was operating on y,

1097
01:12:41,380 --> 01:12:45,610
so in 2PC, really you know solve a completely different problem than Raft,

1098
01:12:45,610 --> 01:12:48,130
Raft is really all about high availability,

1099
01:12:54,860 --> 01:13:00,110
and 2PC is really about atomic operations across servers,

1100
01:13:07,640 --> 01:13:10,220
across data that's living on different servers.

1101
01:13:10,760 --> 01:13:11,660
Does that make sense?

1102
01:13:13,700 --> 01:13:18,140
So even though like maybe they have some internal techniques that look very similar,

1103
01:13:18,350 --> 01:13:22,550
the two protocols you knwo are designed for completely different problems,

1104
01:13:23,940 --> 01:13:25,020
and not directly related,

1105
01:13:25,020 --> 01:13:26,190
now it's interesting to see, correct,

1106
01:13:26,190 --> 01:13:27,660
but we could make Raft,

1107
01:13:27,900 --> 01:13:30,120
we can use Raft to make the coordinator more fault tolerant,

1108
01:13:30,120 --> 01:13:32,730
or participants made more highly available,

1109
01:13:33,000 --> 01:13:36,270
but they basically essentially solve different problems.

1110
01:13:43,860 --> 01:13:46,470
With that, I actually wanted to end this lecture,

1111
01:13:46,500 --> 01:13:49,440
I'm happy to entertain more questions,

1112
01:13:49,710 --> 01:13:53,310
hopefully this will very helpful in the next two papers,

1113
01:13:53,340 --> 01:13:57,000
so the next two papers are both two transaction systems,

1114
01:13:57,180 --> 01:14:00,990
one and one from Google,

1115
01:14:00,990 --> 01:14:02,400
one from Microsoft research,

1116
01:14:02,700 --> 01:14:06,330
and second one uses optimistic transactions,

1117
01:14:06,630 --> 01:14:09,090
and you'll see when you read these papers,

1118
01:14:09,090 --> 01:14:11,970
there's a lot of machinery, are pretty complex systems,

1119
01:14:12,210 --> 01:14:15,780
but hopefully at least some of the parts that will be described,

1120
01:14:15,990 --> 01:14:17,130
you will now understand,

1121
01:14:17,130 --> 01:14:18,720
because you know what 2-phase commit is

1122
01:14:18,720 --> 01:14:19,950
and you know what two-phase locking is.

1123
01:14:21,560 --> 01:14:23,810
Okay, with that, I'll end,

1124
01:14:23,840 --> 01:14:26,540
and everybody needs to go can go,

1125
01:14:26,540 --> 01:14:28,220
and anybody wants to ask questions,

1126
01:14:28,220 --> 01:14:29,750
you know please feel free to do so.

1127
01:14:36,720 --> 01:14:41,360
Sorry, this might be a little, a strange question,

1128
01:14:41,360 --> 01:14:43,640
but for 2-phase locking,

1129
01:14:44,030 --> 01:14:46,730
it is also about atomic operations,

1130
01:14:46,730 --> 01:14:53,920
but there it is about one, not across servers, but across one server,

1131
01:14:54,580 --> 01:14:56,620
and 2-phase across multiple servers.

1132
01:14:56,620 --> 01:14:59,770
Yeah, 2-phase locking is relevant too, if you have a single machine,

1133
01:14:59,770 --> 01:15:01,030
like a multi-core machine,

1134
01:15:01,480 --> 01:15:04,570
and you're implementing a transaction system on a multi-core machine,

1135
01:15:04,810 --> 01:15:08,590
you will have to lock you know the records that are involved in the transaction,

1136
01:15:08,920 --> 01:15:11,830
and 2-phase locking is a perfectly good protocol for doing so,

1137
01:15:16,200 --> 01:15:18,540
where 2-phase commit is really about the distributed systems.

1138
01:15:20,770 --> 01:15:25,190
I guess my question was is 2-phase 2-phase locking,

1139
01:15:25,580 --> 01:15:28,640
can it be part of 2-phase commit?

1140
01:15:30,140 --> 01:15:33,020
I'm not sure I know what that means,

1141
01:15:33,020 --> 01:15:34,490
the way I think about is that,

1142
01:15:34,490 --> 01:15:36,020
you solve two different problems.

1143
01:15:38,470 --> 01:15:39,100
Okay.

1144
01:15:39,460 --> 01:15:40,570
It's the case that,

1145
01:15:40,570 --> 01:15:42,670
you know you you maybe this is what you mean,

1146
01:15:42,910 --> 01:15:46,810
it is a case where that you know there's a coordinator,

1147
01:15:47,110 --> 01:15:50,710
or as part of the initial setup,

1148
01:15:50,710 --> 01:15:52,960
when the initial puts are done by the transaction,

1149
01:15:53,260 --> 01:15:55,870
the that transaction will follow 2-phase locking,

1150
01:15:57,080 --> 01:16:00,740
here to lock on x required, to lock on B required,

1151
01:16:01,880 --> 01:16:04,640
so the lock y is required,

1152
01:16:04,640 --> 01:16:07,880
and so does the transaction does that in the 2-phase locking style,

1153
01:16:08,000 --> 01:16:09,890
it could have done using strict locking too,

1154
01:16:09,890 --> 01:16:13,820
but you know from the 2-phase commit point of view,

1155
01:16:14,270 --> 01:16:15,290
it doesn't really matter,

1156
01:16:15,290 --> 01:16:18,710
at some point, you know the transaction is [] to be executed

1157
01:16:19,070 --> 01:16:22,640
and the 2-phase commit is really about reaching agreement,

1158
01:16:22,940 --> 01:16:25,910
that all parties agreed to go along.

1159
01:16:28,350 --> 01:16:30,060
Yeah, that makes sense, thank you.

1160
01:16:30,240 --> 01:16:30,810
You're welcome.

1161
01:16:31,290 --> 01:16:34,560
Is 2-phase commit exclusively for like sharded data?

1162
01:16:35,100 --> 01:16:38,760
No, actually it came out,

1163
01:16:39,150 --> 01:16:41,850
well, oh, yes or no,

1164
01:16:42,150 --> 01:16:46,920
the original sort of 2-phase commit came out of the case,

1165
01:16:46,920 --> 01:16:49,620
where like you have different organizations,

1166
01:16:49,620 --> 01:16:51,150
and they need to agree to do something,

1167
01:16:51,150 --> 01:16:55,950
like you know you book on a travel website,

1168
01:16:55,950 --> 01:16:57,690
you know you book a trip,

1169
01:16:57,690 --> 01:16:59,880
and another thing you book a hotel,

1170
01:17:00,180 --> 01:17:03,420
and you want to commit to the whole trip,

1171
01:17:03,420 --> 01:17:12,600
if you both hotel website and the travel website agreed to go along,

1172
01:17:12,900 --> 01:17:14,010
sort of committed to the transaction

1173
01:17:14,610 --> 01:17:18,510
and that sort of deciding where sort of this deciding where,

1174
01:17:18,510 --> 01:17:20,940
came up which really you know you have different organizations,

1175
01:17:21,150 --> 01:17:26,690
they need to commit to a particular operation,

1176
01:17:26,690 --> 01:17:28,940
and for the reasons that,

1177
01:17:29,000 --> 01:17:34,490
that that setting actually basically people don't really want to use 2-phase commit,

1178
01:17:34,940 --> 01:17:36,950
because that would mean that,

1179
01:17:37,280 --> 01:17:42,980
the travel agency website is dependent on the hotel reservation websites,

1180
01:17:42,980 --> 01:17:45,560
and these are from different organizations,

1181
01:17:45,560 --> 01:17:48,200
and you know people who know the organization don't really trust each other,

1182
01:17:48,410 --> 01:17:50,690
and if one goes down,

1183
01:17:50,690 --> 01:17:53,930
then there's actually can't proceed and that seems all bad,

1184
01:17:54,380 --> 01:17:58,490
so, in fact, 2-phase commit have a bit of a negative reputation,

1185
01:17:58,860 --> 01:18:00,840
because really you know,

1186
01:18:01,980 --> 01:18:04,830
one of the original goals of 2-phase commit to solve that problem,

1187
01:18:04,830 --> 01:18:07,350
that problem here, people don't really want to solve with 2-phase commit,

1188
01:18:07,860 --> 01:18:10,770
however in the context where you have a data center,

1189
01:18:10,770 --> 01:18:13,380
it's a single organization and the databases sharded,

1190
01:18:13,590 --> 01:18:17,620
2-phase commit is widely popular and typical use.

1191
01:18:21,000 --> 01:18:21,900
Awesome, thank you.

1192
01:18:22,410 --> 01:18:23,130
You're welcome.

1193
01:18:24,210 --> 01:18:26,760
Could you go back to the first failure case,

1194
01:18:26,760 --> 01:18:28,500
that we talked about with 2-phase commit,

1195
01:18:28,500 --> 01:18:33,960
where it fails, B fails after responding prepare ok.

1196
01:18:34,140 --> 01:18:35,700
Yeah, is this one?

1197
01:18:36,250 --> 01:18:38,770
Yeah, I guess.

1198
01:18:39,560 --> 01:18:41,690
I talked twice about this case, but like.

1199
01:18:41,690 --> 01:18:45,230
Yeah, I guess I was wondering,

1200
01:18:45,740 --> 01:18:48,530
why B needs to persist

1201
01:18:48,530 --> 01:18:52,910
or like why needs to remember that it received prepare,

1202
01:18:53,450 --> 01:18:55,700
I guess my thinking was,

1203
01:18:56,260 --> 01:18:57,670
when it comes back up,

1204
01:18:58,060 --> 01:19:01,360
if it receives A commit message from the coordinator,

1205
01:19:01,360 --> 01:19:04,510
couldn't it just assumed that it was prepared,

1206
01:19:04,510 --> 01:19:06,400
I guess where does it use that information.

1207
01:19:06,790 --> 01:19:10,840
Yeah, well, it could have abort right before the crash,

1208
01:19:12,030 --> 01:19:13,650
and B needs to remember what it did.

1209
01:19:14,430 --> 01:19:15,360
Okay.

1210
01:19:15,690 --> 01:19:18,300
So there's another slight variation with this protocol,

1211
01:19:18,300 --> 01:19:21,660
where where you assume that you always commit,

1212
01:19:21,660 --> 01:19:25,110
so presume commit one of the messages slightly different,

1213
01:19:25,200 --> 01:19:28,230
and you know there's an optimization that you could consider,

1214
01:19:28,560 --> 01:19:31,260
and would make sense in some settings,

1215
01:19:31,940 --> 01:19:35,000
I I didn't really talk about that particular protocol,

1216
01:19:35,000 --> 01:19:35,990
but just a slight different,

1217
01:19:35,990 --> 01:19:37,010
you know sort of variation,

1218
01:19:37,010 --> 01:19:38,990
there's quite a number of variations for 2-phase commit,

1219
01:19:39,880 --> 01:19:42,040
they change in minor ways.

1220
01:19:45,190 --> 01:19:45,760
Make sense?

1221
01:19:46,030 --> 01:19:46,930
Yep, thank you.

1222
01:19:54,270 --> 01:19:55,260
Is that it for today?

1223
01:19:57,430 --> 01:19:59,110
Sorry, you said that it can,

1224
01:19:59,140 --> 01:20:02,410
it could have aborted the transaction,

1225
01:20:02,410 --> 01:20:06,190
but if it did, that it will never receive the commit.

1226
01:20:07,380 --> 01:20:09,390
You mean in response to the last question?

1227
01:20:09,570 --> 01:20:11,310
Yeah.

1228
01:20:11,310 --> 01:20:12,540
You know the the question was,

1229
01:20:12,540 --> 01:20:15,720
like why does B have to record on stable storage,

1230
01:20:15,720 --> 01:20:16,770
what decided to do.

1231
01:20:17,580 --> 01:20:21,600
And the injury is that when B comes up,

1232
01:20:21,600 --> 01:20:24,360
it knows it needs to know whether actually commit, agreed to commit,

1233
01:20:24,390 --> 01:20:25,800
or going to agree to abort,

1234
01:20:26,760 --> 01:20:31,090
and it doesn't write anything, it doesn't know to what agree.

1235
01:20:35,030 --> 01:20:36,800
Because it could have been abort, after.

1236
01:20:36,830 --> 01:20:37,430
Yep.

1237
01:20:37,810 --> 01:20:38,830
Yeah.

1238
01:20:40,540 --> 01:20:41,710
I need to know that,

1239
01:20:41,710 --> 01:20:44,560
you know what to do in the recovery stage, I see.

1240
01:20:44,860 --> 01:20:45,400
Yes, exactly.

1241
01:20:52,260 --> 01:20:54,330
It also needs to record what it does,

1242
01:20:54,330 --> 01:20:56,900
because if it like aborts,

1243
01:20:56,930 --> 01:20:58,940
but the message never gets to the coordinator,

1244
01:20:58,970 --> 01:21:02,420
needs to resend the same message, right.

1245
01:21:02,420 --> 01:21:06,080
Yeah, well, it need to record that actually abort that transaction ID,

1246
01:21:06,080 --> 01:21:08,990
so when the coordinator asks you know what did you do,

1247
01:21:09,230 --> 01:21:10,820
that actually responds with a no.

1248
01:21:11,940 --> 01:21:12,870
Got it, thank you.

1249
01:21:17,530 --> 01:21:18,250
Thank you.

1250
01:21:18,910 --> 01:21:19,420
You're welcome.

1251
01:21:20,790 --> 01:21:21,720
Thank you.

1252
01:21:24,010 --> 01:21:25,540
Alright, see you all next week.

