1
00:00:01,290 --> 00:00:05,680
Okay, good afternoon, can everybody hear me?

2
00:00:08,160 --> 00:00:08,820
Yep.

3
00:00:09,130 --> 00:00:10,090
Okay, thank you,

4
00:00:10,360 --> 00:00:13,390
yes I will post the lecture notes at the end of lecture,

5
00:00:14,320 --> 00:00:18,240
response to the chat.

6
00:00:18,330 --> 00:00:27,400
Okay, so, today basically I want to start a new topic in in 6.824,

7
00:00:27,580 --> 00:00:31,270
and sort of last topic that will be discussing,

8
00:00:31,510 --> 00:00:33,790
the topic is really decentralized systems.

9
00:00:45,490 --> 00:00:49,360
And these are typically decentralized really refers to the fact,

10
00:00:49,360 --> 00:00:53,590
that there's no single authority that is in control of the system,

11
00:00:54,320 --> 00:00:56,750
a lot of the systems that we've seen so far,

12
00:00:56,930 --> 00:00:59,870
all the machines and servers sort of cooperate,

13
00:01:00,110 --> 00:01:05,030
and on the under control of a single institution or any single authority.

14
00:01:05,850 --> 00:01:09,030
And since a lot of you ask questions,

15
00:01:09,030 --> 00:01:10,500
about like how would it work,

16
00:01:10,500 --> 00:01:13,920
if there's no central point of trust.

17
00:01:14,770 --> 00:01:18,290
And so, from now on,

18
00:01:18,290 --> 00:01:20,720
the three systems or three papers were going to be discussing,

19
00:01:20,720 --> 00:01:23,210
all sit in this form of decentralized systems,

20
00:01:23,420 --> 00:01:27,860
and decentralized systems are harder to build

21
00:01:27,890 --> 00:01:30,230
than the sort of single trust systems,

22
00:01:30,650 --> 00:01:34,910
because you know you might have to account for byzantine failures

23
00:01:34,910 --> 00:01:36,920
or byzantine participants,

24
00:01:45,540 --> 00:01:48,810
and these are participants that you know sometimes follow the protocol,

25
00:01:48,810 --> 00:01:50,370
and sometimes they don't follow the protocol,

26
00:01:50,970 --> 00:01:52,890
so again really think about it,

27
00:01:52,890 --> 00:01:54,540
they are basically adversaries,

28
00:01:54,780 --> 00:02:02,820
and they may try to abuse or trick other participants in systems,

29
00:02:02,820 --> 00:02:03,840
you know for their own goods,

30
00:02:03,840 --> 00:02:05,220
but not maybe for others.

31
00:02:05,800 --> 00:02:10,930
And so that makes actually system design,

32
00:02:10,930 --> 00:02:13,630
which distributed system designs much more challenging,

33
00:02:13,660 --> 00:02:15,610
and much more difficult to reason about,

34
00:02:16,030 --> 00:02:19,510
you know like in the last you know 18 whatever lectures,

35
00:02:19,720 --> 00:02:22,300
mostly when we talk about,

36
00:02:22,300 --> 00:02:24,520
when we design protocol or we thought about Raft,

37
00:02:24,730 --> 00:02:25,900
and we just assume that

38
00:02:25,900 --> 00:02:29,950
actually every participant in the protocol follows the rules,

39
00:02:30,400 --> 00:02:33,160
and in the byzantine with byzantine participants,

40
00:02:33,160 --> 00:02:34,480
that is not the case anymore,

41
00:02:35,440 --> 00:02:37,840
you know the participants can cook up new messages,

42
00:02:37,840 --> 00:02:39,580
you know send messages out of order,

43
00:02:39,580 --> 00:02:42,010
trick other participants,

44
00:02:42,310 --> 00:02:46,930
and so the we thinking about those kind of protocols is much more difficult,

45
00:02:46,990 --> 00:02:51,150
because we have to consider what, what the adversary could do,

46
00:02:51,210 --> 00:02:53,430
to sort of make our [],

47
00:02:54,010 --> 00:02:57,400
to break basically the properties of the protocols, that we're shooting for,

48
00:02:58,000 --> 00:03:00,610
so this tends to be made the problem much harder.

49
00:03:03,790 --> 00:03:08,140
And really you know where what this sort of topic is,

50
00:03:08,140 --> 00:03:11,860
so sits on the intersection of distributed systems and security.

51
00:03:16,120 --> 00:03:20,740
And as we'll see in the next this paper, next three papers,

52
00:03:21,160 --> 00:03:24,970
you know cryptography or security ideas, like signing and hashing,

53
00:03:24,970 --> 00:03:29,680
and are going to play a crucial role to actually make [] progress.

54
00:03:31,140 --> 00:03:34,320
In fact, you know the paper actually that we're reading for today is also,

55
00:03:34,320 --> 00:03:37,500
is a paper that we use in the 6.858,

56
00:03:38,250 --> 00:03:41,400
taking maybe 6.858 last Spring,

57
00:03:41,580 --> 00:03:44,040
we talked about this paper too,

58
00:03:44,040 --> 00:03:46,800
although then for mostly from the perspective of security,

59
00:03:46,890 --> 00:03:49,380
and today I'm going to mostly focuses on

60
00:03:49,380 --> 00:03:52,500
the perspective of distributed systems,

61
00:03:53,100 --> 00:03:58,290
the SUNDR itself, a lot of people ask,

62
00:03:58,320 --> 00:04:02,520
a lot of you ask you know SUNDR being used,

63
00:04:02,520 --> 00:04:04,230
and as far as I know,

64
00:04:04,230 --> 00:04:08,700
there's actually no systems that actually implement SUNDR directly

65
00:04:08,700 --> 00:04:10,650
or based directly based SUNDR,

66
00:04:10,740 --> 00:04:14,760
other than lab 4 in 6.858,

67
00:04:14,820 --> 00:04:20,670
in lab 4, what if you do lab 4, the default project,

68
00:04:20,670 --> 00:04:22,050
lab 4 at 6.858,

69
00:04:22,170 --> 00:04:24,840
then you actually implement SUNDR.

70
00:04:26,000 --> 00:04:32,090
Now, the reason, so you might wonder why we are studying this paper at all,

71
00:04:32,270 --> 00:04:33,350
the reason we're studying it,

72
00:04:33,350 --> 00:04:34,820
because it actually proposes a number of

73
00:04:34,820 --> 00:04:37,040
very powerful techniques or powerful ideas,

74
00:04:40,400 --> 00:04:42,860
and so particularly the signed log,

75
00:04:43,640 --> 00:04:47,720
even though is a strong design conceptual design,

76
00:04:47,990 --> 00:04:50,000
is incredibly powerful,

77
00:04:50,180 --> 00:04:51,800
and you see back

78
00:04:51,830 --> 00:04:55,610
same idea appear in lots of other decentralized systems,

79
00:04:55,880 --> 00:05:01,280
you know ranging from systems like Git to you know systems like Bitcoin

80
00:05:01,280 --> 00:05:03,530
or any other sort of cryptographic ledger,

81
00:05:03,770 --> 00:05:07,430
we're gonna be talking about Monday or next Tuesday,

82
00:05:07,610 --> 00:05:13,880
I know one system actually is directly influenced by SUNDR,

83
00:05:13,880 --> 00:05:15,650
which is a system called Keybase,

84
00:05:16,430 --> 00:05:20,090
Keybase uses SUNDR techniques,

85
00:05:20,090 --> 00:05:22,190
and and many more,

86
00:05:22,190 --> 00:05:23,990
if you're not familiar with Keybase,

87
00:05:23,990 --> 00:05:26,870
actually was originally acquired by Zoom,

88
00:05:27,500 --> 00:05:29,630
which was only all familiar with.

89
00:05:32,180 --> 00:05:36,950
Okay, so that's sort of for the quick intro to this paper,

90
00:05:37,040 --> 00:05:39,230
before I dive into more of the setting,

91
00:05:39,230 --> 00:05:40,700
any sort of questions

92
00:05:40,700 --> 00:05:44,060
before diving a little bit deeper in the paper.

93
00:05:50,710 --> 00:05:52,360
Okay.

94
00:05:52,950 --> 00:05:56,310
So let's talk a little bit about the setting of this paper

95
00:05:56,310 --> 00:05:59,670
or the motivation of this paper.

96
00:05:59,670 --> 00:06:03,720
So the setting in the,

97
00:06:03,720 --> 00:06:07,050
that the [] set forward is a network file system,

98
00:06:11,240 --> 00:06:14,270
and, you can think about this a little bit,

99
00:06:14,270 --> 00:06:19,250
in the style of earlier paper, that we've read Frangipani,

100
00:06:19,430 --> 00:06:24,170
where the topic also was to implement consistent network file system.

101
00:06:25,070 --> 00:06:27,590
So we have a file server,

102
00:06:30,770 --> 00:06:33,770
we have clients that interact with the file server,

103
00:06:34,850 --> 00:06:37,280
somebody might actually create a file f,

104
00:06:39,470 --> 00:06:43,220
and maybe read f on another client.

105
00:06:45,860 --> 00:06:49,520
And you know the setting we're in,

106
00:06:49,520 --> 00:06:54,950
is that basically the file server as opposed to in the Frangipani,

107
00:06:55,100 --> 00:06:57,950
the file server are actually can be Byzantine.

108
00:07:02,790 --> 00:07:07,290
And Byzantine really increasing extremely powerful threat model,

109
00:07:07,290 --> 00:07:10,560
or you know gives the attacker an incredible amount of power.

110
00:07:10,920 --> 00:07:16,140
So in Byzantine you know the server might send different RPCs back,

111
00:07:16,140 --> 00:07:25,470
you know cook up its own RPCs, the the, takeover the machine,

112
00:07:25,470 --> 00:07:27,240
you know bribe the administrator,

113
00:07:27,240 --> 00:07:30,810
and for everything is basically the way to think about is that,

114
00:07:31,110 --> 00:07:34,290
the adversary gets complete control of the file server.

115
00:07:36,130 --> 00:07:39,670
And so this covers sort of wide range

116
00:07:39,700 --> 00:07:42,010
of you know sort of more common attacks

117
00:07:42,010 --> 00:07:45,010
or like the typical attacks you might see in a real system,

118
00:07:45,010 --> 00:07:47,890
so real attacks one bug in software,

119
00:07:51,920 --> 00:07:54,680
so if you know there's a bug in the software,

120
00:07:54,680 --> 00:07:56,630
then you know the adversary can exploit,

121
00:07:56,630 --> 00:08:00,920
that [] maybe to obtain privileges

122
00:08:00,920 --> 00:08:05,270
and you know that Byzantine model you know completely passes,

123
00:08:05,270 --> 00:08:14,750
that or you know system administrator might have a weak, with weak password,

124
00:08:16,460 --> 00:08:20,540
if the attacker [] and then they take control over the system,

125
00:08:20,540 --> 00:08:23,780
you know that's also covered by Byzantine physical breaking,

126
00:08:28,150 --> 00:08:32,500
maybe the attacker [] you know get access to the physical machine,

127
00:08:32,770 --> 00:08:38,200
and you know can therefore control the physical part of the machine,

128
00:08:38,290 --> 00:08:41,320
again it's all covered by this you know Byzantine threat model,

129
00:08:41,710 --> 00:08:51,690
or even you know, maybe you know the the attacker bribes an operator

130
00:08:54,540 --> 00:08:59,760
or colludes you know with a malicious client,

131
00:08:59,760 --> 00:09:01,710
you know that is also covered by this model,

132
00:09:01,770 --> 00:09:02,910
so this is a threat model,

133
00:09:02,910 --> 00:09:07,290
that is a very very gives a lot of power to the adversary,

134
00:09:08,060 --> 00:09:09,920
it covers a lot of standard attacks.

135
00:09:10,400 --> 00:09:13,940
And and you know the first thing sort of observed,

136
00:09:13,940 --> 00:09:20,570
you know again that SUNDR [place] is that,

137
00:09:20,660 --> 00:09:22,610
instead of actually you know sort of

138
00:09:22,610 --> 00:09:25,970
maintaining the whole file system on the file server,

139
00:09:25,970 --> 00:09:28,190
the file server is as simple as possible,

140
00:09:28,670 --> 00:09:32,690
and in fact you know the file servers very much like almost like Pedal,

141
00:09:32,930 --> 00:09:35,600
it's almost like a block device with a little bit more.

142
00:09:39,120 --> 00:09:42,180
So there's a central place where all the blocks are stored,

143
00:09:43,200 --> 00:09:47,040
and but the clients really implement the file system,

144
00:09:47,040 --> 00:09:51,930
so it's not really you know that the client sends, create for file actually,

145
00:09:52,360 --> 00:09:57,260
you know sends blocks and reads blocks, from the block server,

146
00:09:57,530 --> 00:10:02,330
and basically constructs you know from the blocks with reads or writes,

147
00:10:02,330 --> 00:10:04,550
you know its own view of the file system,

148
00:10:04,550 --> 00:10:07,130
and serve you know a file system operations,

149
00:10:07,130 --> 00:10:08,750
basically on the straight on the client

150
00:10:08,990 --> 00:10:15,200
and so here really, we create you know f, read f, etc.

151
00:10:16,430 --> 00:10:18,860
So very very similar to the Frangipani,

152
00:10:19,280 --> 00:10:21,770
except the big difference of Frangipani is,

153
00:10:21,770 --> 00:10:24,200
that Pedal and all clients were completely trusted,

154
00:10:24,530 --> 00:10:25,850
and in this setting,

155
00:10:26,030 --> 00:10:27,470
the clients are not trusted,

156
00:10:27,680 --> 00:10:29,750
and the file servers,

157
00:10:29,750 --> 00:10:33,380
it can be also, is also not trusted.

158
00:10:34,140 --> 00:10:34,680
Okay?

159
00:10:41,410 --> 00:10:46,690
Okay, so the paper focused on a particular set of security properties,

160
00:10:46,930 --> 00:10:51,160
and focus is really on,

161
00:10:54,660 --> 00:10:57,840
the focus is on what's called integrity properties,

162
00:11:00,550 --> 00:11:02,950
and in contrast to confidentiality,

163
00:11:03,040 --> 00:11:05,590
confidentiality about protecting data from them,

164
00:11:05,590 --> 00:11:06,850
so that nobody else can read it,

165
00:11:07,150 --> 00:11:11,770
integrity is just ensuring that the system structure is correct,

166
00:11:11,770 --> 00:11:16,660
and the modifications, illegal modifications to the data are being detected,

167
00:11:16,750 --> 00:11:18,460
and whether the data is public or not public,

168
00:11:18,460 --> 00:11:20,590
you know that sort of besides the point here.

169
00:11:21,330 --> 00:11:23,670
To make a little bit more concrete,

170
00:11:23,670 --> 00:11:27,450
you know there sort of, the thing that happens in our minds is,

171
00:11:27,450 --> 00:11:29,580
we have a set of, we have developers,

172
00:11:32,410 --> 00:11:36,310
you know we have dev1, you know dev2,

173
00:11:36,730 --> 00:11:39,820
they may share some machine,

174
00:11:39,850 --> 00:11:45,760
that contains the source code repository of some source of project,

175
00:11:45,760 --> 00:11:48,700
the developers you know are collaborating on that project,

176
00:11:49,090 --> 00:11:53,860
and and so think about this as a example,

177
00:11:53,860 --> 00:11:55,000
the paper mentions is,

178
00:11:55,000 --> 00:11:58,210
in the paper, maybe this is the development machines,

179
00:11:58,210 --> 00:12:01,390
and the server for a Debian Linux,

180
00:12:02,500 --> 00:12:07,150
and what they want to defend against is trapdoor,

181
00:12:07,420 --> 00:12:13,280
trapdoor, you know trapdoor in the software.

182
00:12:16,890 --> 00:12:22,170
So the you know the attacker you know takes over control,

183
00:12:22,170 --> 00:12:25,800
breaks into the machine, that contains the source repo,

184
00:12:25,830 --> 00:12:28,680
modifies the software [],

185
00:12:28,920 --> 00:12:31,710
and then it's going out of that software gets deployed,

186
00:12:31,740 --> 00:12:34,560
you know for example Debian Linux gets deployed to lots of machines,

187
00:12:34,980 --> 00:12:40,560
and now the attacker has control over those machines,

188
00:12:40,590 --> 00:12:42,570
because it's gonna exploit the trapdoor.

189
00:12:43,210 --> 00:12:46,330
The the paper talks about this attack,

190
00:12:46,360 --> 00:12:50,470
this particular instance in Debian Linux in 2003,

191
00:12:50,590 --> 00:12:55,660
where the attack was able to compromise

192
00:12:55,660 --> 00:12:58,750
you know the development server or cluster,

193
00:12:59,110 --> 00:13:02,830
in recovering from these kinds of attacks very painful,

194
00:13:02,920 --> 00:13:05,530
in fact, in 2003 you know they report,

195
00:13:05,530 --> 00:13:09,790
that the Debian Linux which froze development for a couple days,

196
00:13:09,790 --> 00:13:11,560
and while they were trying to sort out

197
00:13:11,830 --> 00:13:15,070
which parts of their source repo was still correct,

198
00:13:15,070 --> 00:13:17,680
and which parts were actually modified by the attacker,

199
00:13:18,250 --> 00:13:20,770
and these attacks happens periodically,

200
00:13:20,770 --> 00:13:22,540
I think last year,

201
00:13:22,540 --> 00:13:27,700
you know Ubuntu had a similar type of problem in in 2018 or 2019,

202
00:13:27,700 --> 00:13:28,840
I can't remember exactly,

203
00:13:29,020 --> 00:13:30,580
and it was a similar case,

204
00:13:30,580 --> 00:13:36,790
where one of the core development servers was broken into,

205
00:13:37,440 --> 00:13:39,480
you know they have to sort out,

206
00:13:39,720 --> 00:13:45,420
what see which software which files got infected

207
00:13:45,420 --> 00:13:46,980
and affected by that breaking.

208
00:13:48,510 --> 00:13:52,710
Okay, so that's sort of the setting of the paper,

209
00:13:52,710 --> 00:13:54,690
and I'm going to make a little bit more concrete,

210
00:13:54,720 --> 00:13:56,460
a little bit of a toy example,

211
00:13:56,550 --> 00:13:59,940
to help us you know go through the techniques,

212
00:13:59,940 --> 00:14:01,470
that this paper actually uses.

213
00:14:03,420 --> 00:14:06,240
So the example that I'm gonna use,

214
00:14:06,810 --> 00:14:10,260
partially inspired by 6.858,

215
00:14:10,440 --> 00:14:14,220
is, let's say you know we have a file system,

216
00:14:14,760 --> 00:14:17,700
there's, you're doing the,

217
00:14:18,880 --> 00:14:20,290
and the file system contains

218
00:14:20,290 --> 00:14:26,950
you know the source code for this application of using 6.858 zoobar,

219
00:14:26,950 --> 00:14:32,110
and zoobar is a sort of a virtual bank type application,

220
00:14:32,110 --> 00:14:34,990
where users of the system,

221
00:14:35,020 --> 00:14:38,650
registered users of the system can transfer zoobars to each other,

222
00:14:39,100 --> 00:14:44,800
and so it has a file called auth.py, you know does authentication,

223
00:14:45,220 --> 00:14:49,930
and have a file that basically you know influence bank, bank.py.

224
00:14:51,170 --> 00:14:55,550
And, so, let's consider the case

225
00:14:55,550 --> 00:14:58,970
where you know have a new set of developers, A B and C,

226
00:14:59,240 --> 00:15:05,060
and they decided that they wanted to increase the usability of zoobar,

227
00:15:05,210 --> 00:15:08,360
actually deployed for real and make it real,

228
00:15:08,360 --> 00:15:11,300
basically you know they decide to divide the work as follows,

229
00:15:11,480 --> 00:15:17,260
A, is gonna modify auth.py

230
00:15:20,560 --> 00:15:27,020
to support MIT certificates or MIT certs,

231
00:15:28,630 --> 00:15:31,090
kerberos tickets or certificates,

232
00:15:31,360 --> 00:15:33,910
and with the idea that,

233
00:15:33,910 --> 00:15:35,050
what we're gonna do is,

234
00:15:36,220 --> 00:15:39,040
we're gonna auth.py is going to be modified,

235
00:15:39,040 --> 00:15:43,420
so that only legit MIT community members

236
00:15:43,420 --> 00:15:45,280
actually can log into the file server,

237
00:15:45,520 --> 00:15:47,530
file server or into zoobar,

238
00:15:47,590 --> 00:15:50,350
and sort of we actually know who it actually really is,

239
00:15:50,410 --> 00:15:53,320
that is associated with that particular MIT certificate.

240
00:15:53,920 --> 00:15:55,930
And then you know to make a little bit more useful,

241
00:15:55,930 --> 00:15:58,150
you know B can actually modify the bank.py

242
00:15:58,150 --> 00:16:04,760
to actually link it you know to cash tag for TechCash.

243
00:16:06,380 --> 00:16:09,200
And so, you know the idea that

244
00:16:09,200 --> 00:16:12,620
basically we can actually use this zoobar system do that,

245
00:16:12,620 --> 00:16:16,700
like we can use the zoobar system to actually transfer money,

246
00:16:16,700 --> 00:16:19,160
you know real money instead of zoobars,

247
00:16:19,220 --> 00:16:24,710
between users that are registered with this servers,

248
00:16:25,040 --> 00:16:26,750
that this sounds of course like a crazy idea,

249
00:16:26,750 --> 00:16:27,740
you don't really do it,

250
00:16:27,740 --> 00:16:29,960
but it's not completely ridiculous,

251
00:16:29,960 --> 00:16:34,190
you know, because you know the auth.py really checks who would actually is,

252
00:16:34,310 --> 00:16:36,170
based on the MIT certificate,

253
00:16:36,470 --> 00:16:38,660
and so maybe it's not unreasonable that

254
00:16:38,660 --> 00:16:41,990
we could connect you know bank.py to actually TechCash.

255
00:16:43,750 --> 00:16:48,250
And then basically C in our scenario is going to be that person,

256
00:16:48,250 --> 00:16:49,870
that's actually going to deploy the software,

257
00:16:53,880 --> 00:16:57,030
find machine, takes software installs it and runs it,

258
00:16:57,390 --> 00:17:00,330
and it opens it up to the MIT community.

259
00:17:00,860 --> 00:17:03,620
Now, in the case,

260
00:17:03,620 --> 00:17:04,820
now let's consider,

261
00:17:04,820 --> 00:17:07,550
what you know what could happen, what could go wrong,

262
00:17:07,850 --> 00:17:10,760
if actually the file server was compromised,

263
00:17:10,760 --> 00:17:12,110
and so was byzantine.

264
00:17:16,640 --> 00:17:19,010
Well, the obvious you know problems,

265
00:17:19,010 --> 00:17:22,490
a couple of obvious problems you know bad outcomes possible,

266
00:17:23,420 --> 00:17:25,010
let's consider them,

267
00:17:27,820 --> 00:17:29,380
you know that outcome one,

268
00:17:29,380 --> 00:17:31,480
which is the one thing we should be talking about,

269
00:17:31,480 --> 00:17:32,950
and also in the previous examples,

270
00:17:33,250 --> 00:17:37,300
it is basically the adversary gives arbitrary code to C,

271
00:17:38,540 --> 00:17:50,450
adversary provides own code to C,

272
00:17:53,430 --> 00:17:54,960
and you know that sort of

273
00:17:55,050 --> 00:17:59,880
maybe that adversary slightly subtle about it or clever about it,

274
00:17:59,880 --> 00:18:02,640
you know whatever makes it a little bit hard to spot,

275
00:18:02,640 --> 00:18:05,370
then actually modified auth.py,

276
00:18:05,940 --> 00:18:07,650
for example to delete the MIT certificates,

277
00:18:08,010 --> 00:18:11,160
but they're basically you know there's really no way for C to check,

278
00:18:11,400 --> 00:18:14,580
that actually got the software that A and B produced

279
00:18:14,580 --> 00:18:17,490
and without any modifications from the adversary.

280
00:18:17,490 --> 00:18:20,430
So that's sort of the obvious problem we're going to talk a lot about,

281
00:18:20,430 --> 00:18:23,370
then there's a second sort of that outcome,

282
00:18:23,370 --> 00:18:24,780
which may be a little more subtle,

283
00:18:25,410 --> 00:18:35,320
which is that the adversary provides the changes you know to bank.py,

284
00:18:37,960 --> 00:18:44,900
without changes to auth.py.

285
00:18:47,970 --> 00:18:51,120
And so at this point, this is pretty problematic, correct,

286
00:18:51,120 --> 00:18:54,120
because you know bank.py link to TechCash now,

287
00:18:54,390 --> 00:18:59,130
but we actually don't have appropriate authentication to users anymore,

288
00:18:59,340 --> 00:19:02,550
in fact anybody that actually creates zoobar account

289
00:19:02,550 --> 00:19:05,070
can now actually interact with the techcash,

290
00:19:05,550 --> 00:19:08,490
and so you know clearly very very undesirable,

291
00:19:08,760 --> 00:19:11,460
and harder to spot,

292
00:19:11,610 --> 00:19:15,810
because basically the adversary actually doesn't really modify any software,

293
00:19:15,810 --> 00:19:19,350
just selectively you know presents you take pieces of it

294
00:19:19,350 --> 00:19:21,030
and present that to C,

295
00:19:21,030 --> 00:19:22,830
who then actually goes off and deployed.

296
00:19:24,610 --> 00:19:29,770
And so it's really you know the attacks

297
00:19:29,770 --> 00:19:34,540
the paper considers of course the attack 1 and 2,

298
00:19:34,780 --> 00:19:36,850
but there are a lot of some of the subtle issues

299
00:19:36,850 --> 00:19:39,520
actually are brought out by the second case,

300
00:19:39,520 --> 00:19:41,080
that will be talking about.

301
00:19:44,250 --> 00:19:45,510
Any questions so far,

302
00:19:47,950 --> 00:19:50,440
you know about the setting, about the motivation,

303
00:19:53,220 --> 00:19:55,950
before we're going to try to discuss solutions.

304
00:19:57,080 --> 00:19:59,210
So the problem with the second case is that,

305
00:19:59,270 --> 00:20:05,210
the user that the authentication does not authenticate?

306
00:20:05,420 --> 00:20:08,240
Yeah, it doesn't use MIT certificates anymore,

307
00:20:08,600 --> 00:20:10,730
and so we don't really know actually who logs in.

308
00:20:12,840 --> 00:20:13,770
Thank you.

309
00:20:15,020 --> 00:20:22,400
What about the case where A or like B won't see is like the fork?

310
00:20:25,310 --> 00:20:26,450
Let's assume for a second,

311
00:20:26,450 --> 00:20:29,510
that A and B actually have talked to each other and divide up the work,

312
00:20:29,510 --> 00:20:32,540
so they know they're supposed to be doing it together.

313
00:20:33,390 --> 00:20:33,870
Right.

314
00:20:35,510 --> 00:20:36,590
May form a team,

315
00:20:37,260 --> 00:20:40,110
they're in close collaboration, in contact,

316
00:20:40,110 --> 00:20:42,930
you know and they've divided up the work,

317
00:20:42,930 --> 00:20:45,120
and so they know you know B tells A,

318
00:20:45,120 --> 00:20:46,230
when B done, tells A,

319
00:20:46,230 --> 00:20:48,030
when they done and then they tell C,

320
00:20:48,030 --> 00:20:48,990
go ahead, we all done.

321
00:20:49,760 --> 00:20:50,390
Okay?

322
00:20:52,190 --> 00:20:57,340
Okay, so, let's start with considering a simple design,

323
00:20:57,340 --> 00:20:59,590
that is too simple, meaning it doesn't work,

324
00:21:00,370 --> 00:21:08,140
but it gives us some starting points for more sophisticated design,

325
00:21:08,290 --> 00:21:09,310
hopefully might work,

326
00:21:10,180 --> 00:21:12,400
and so the simple point is that

327
00:21:12,700 --> 00:21:16,150
A and B or any,

328
00:21:16,150 --> 00:21:20,740
all the files are going to be signed with person who modified,

329
00:21:20,770 --> 00:21:25,880
so when like A modifies you know auth.py,

330
00:21:29,200 --> 00:21:32,230
A actually produces a signature,

331
00:21:32,530 --> 00:21:36,490
and signed with the public key,

332
00:21:39,270 --> 00:21:42,840
which signature signed to the public key of A,

333
00:21:43,470 --> 00:21:48,480
and you know that signature covers the data of the file,

334
00:21:51,500 --> 00:21:57,170
and so when C downloads you know the auth.py,

335
00:21:57,440 --> 00:21:59,420
you know check the signature,

336
00:22:05,100 --> 00:22:06,480
and if the signature checks out,

337
00:22:06,480 --> 00:22:09,480
you know then that C knows that actually this file was produced,

338
00:22:09,480 --> 00:22:12,090
you know this file was produced by A,

339
00:22:12,330 --> 00:22:16,680
and you know might all believe that things are good.

340
00:22:17,300 --> 00:22:18,290
And that's the basic plan,

341
00:22:18,380 --> 00:22:21,680
and we'll talk a little bit about where the keys are coming from,

342
00:22:21,680 --> 00:22:26,780
although you know the issue of public key distribution is really an 6.858 topics,

343
00:22:26,780 --> 00:22:27,980
so I'm not going to talk too much about it,

344
00:22:28,250 --> 00:22:29,570
but just assume for now,

345
00:22:29,570 --> 00:22:34,490
that every user has a key, public private key pair,

346
00:22:34,610 --> 00:22:39,710
and the private keys are secret and the public keys are public,

347
00:22:39,980 --> 00:22:43,370
and every user knows whose public key belongs to who.

348
00:22:45,170 --> 00:22:49,700
So now let's consider attacks

349
00:22:51,020 --> 00:22:53,300
and see which one sort of you know fail,

350
00:22:53,300 --> 00:22:55,550
which ones you know work.

351
00:22:56,020 --> 00:22:58,240
So, of course the obvious attack number one,

352
00:22:58,240 --> 00:23:00,370
that we talked about on the previous slide,

353
00:23:00,430 --> 00:23:03,780
is S modifies file,

354
00:23:05,940 --> 00:23:07,560
and that's not a little bit,

355
00:23:07,560 --> 00:23:13,080
that's not directly S modified auth.py,

356
00:23:13,500 --> 00:23:16,560
that's not really going to be possible anymore,

357
00:23:16,740 --> 00:23:21,240
because when C downloads you know the file and the signature,

358
00:23:21,330 --> 00:23:22,440
and checks it

359
00:23:22,590 --> 00:23:24,840
and it will see that the signature rejection check,

360
00:23:24,840 --> 00:23:27,000
because the data that actually was signed

361
00:23:27,330 --> 00:23:31,350
is different than the data that actually the server produced,

362
00:23:31,530 --> 00:23:36,510
and so it's not really possible for the server really to modify auth.py,

363
00:23:36,510 --> 00:23:39,690
without actually being attack or without actually being attack.

364
00:23:40,470 --> 00:23:44,430
So you know this is we're sort of in good shape here on this attack,

365
00:23:44,460 --> 00:23:46,590
and that's sort of the core attack, right.

366
00:23:47,210 --> 00:23:50,780
But there's a lot of other things that S still could do,

367
00:23:51,110 --> 00:23:54,350
so let's consider some of the other things,

368
00:23:55,040 --> 00:23:59,810
S you know could actually, we describe S send another file,

369
00:24:00,710 --> 00:24:02,780
and pretends to be auth.py,

370
00:24:05,450 --> 00:24:08,780
and because the signature doesn't really say,

371
00:24:08,810 --> 00:24:11,570
you know which actually file the data belongs to,

372
00:24:12,020 --> 00:24:16,790
and so S could you know produce some other files,

373
00:24:16,790 --> 00:24:19,160
like oh yeah see this is actually auth.py,

374
00:24:19,460 --> 00:24:21,530
you can believe me in here,

375
00:24:21,530 --> 00:24:24,860
the sign the signature which of course produced by S,

376
00:24:25,370 --> 00:24:27,800
so of course this could be fixed,

377
00:24:27,830 --> 00:24:31,010
you know maybe the signature should not only include data,

378
00:24:31,010 --> 00:24:33,170
but also probably should include the file name,

379
00:24:35,340 --> 00:24:38,130
so you know maybe not too, too bad in something,

380
00:24:38,130 --> 00:24:39,750
that you could be addressed.

381
00:24:41,950 --> 00:24:44,740
Third, you know another yet another possibility is,

382
00:24:44,740 --> 00:24:53,200
to for S to basically send the contents of old files, old content,

383
00:24:54,970 --> 00:24:55,960
maybe some new,

384
00:25:03,460 --> 00:25:05,260
and it does a bit more difficult now,

385
00:25:05,260 --> 00:25:09,070
for us to handle correct this to simple plan,

386
00:25:09,220 --> 00:25:12,700
because you know there there's no way

387
00:25:12,700 --> 00:25:16,660
you know basically the files individually authenticated, but not together,

388
00:25:16,660 --> 00:25:21,610
and it's not C gets a consistent picture of the file system,

389
00:25:21,610 --> 00:25:23,200
it just gets like sign files,

390
00:25:23,470 --> 00:25:27,880
and how do sign files relate to each other in terms of histories,

391
00:25:28,090 --> 00:25:30,670
is completely not covered in these too simple design.

392
00:25:31,380 --> 00:25:34,890
This is exactly of course gonna issue there's more subtle attack,

393
00:25:34,890 --> 00:25:37,350
that now couldn't just completely work out, correct,

394
00:25:37,350 --> 00:25:40,380
because you know S could send the,

395
00:25:40,710 --> 00:25:44,340
could send the old version of auth.py,

396
00:25:44,430 --> 00:25:46,410
it will completely checkout,

397
00:25:46,740 --> 00:25:52,830
and then send the new version of the of the bank.py,

398
00:25:52,860 --> 00:25:55,350
which actually talks is linked to techcash,

399
00:25:55,470 --> 00:25:58,530
and now exactly back in there's a worse some case,

400
00:25:58,710 --> 00:26:01,500
where you know with an old version of auth.py

401
00:26:01,500 --> 00:26:03,210
or not to change to auth.py,

402
00:26:03,210 --> 00:26:05,370
not the certificate changes to auth.py,

403
00:26:05,610 --> 00:26:09,570
and the new version that actually link to TechCash.

404
00:26:09,960 --> 00:26:11,730
And so this is not so good,

405
00:26:12,150 --> 00:26:14,490
so and the simple point that we have here,

406
00:26:14,490 --> 00:26:16,020
just doesn't deal with this.

407
00:26:17,420 --> 00:26:19,850
There's a similar sort of another version of this,

408
00:26:19,850 --> 00:26:24,110
that where you know of course you know S can also just claim that the file doesn't exist,

409
00:26:31,530 --> 00:26:37,260
and C doesn't really have any way of checking whether that's actually true or not,

410
00:26:37,260 --> 00:26:39,360
because again they should have a global picture,

411
00:26:39,480 --> 00:26:42,000
where it's a consistent view of the file system,

412
00:26:42,330 --> 00:26:45,330
nobody knows about signatures for each file.

413
00:26:46,740 --> 00:26:50,280
And so you see that the simple design may be a good starting point,

414
00:26:50,280 --> 00:26:54,000
but we need something more, more complete,

415
00:26:54,030 --> 00:26:58,500
and I think we need something that really ties all the file systems,

416
00:26:58,500 --> 00:26:59,520
all the files together,

417
00:26:59,520 --> 00:27:00,810
that ties directories together,

418
00:27:00,810 --> 00:27:03,450
the content of the directories together,

419
00:27:03,450 --> 00:27:06,270
and and we have to be able to decide in some way,

420
00:27:06,270 --> 00:27:09,690
what is the latest version of the file system,

421
00:27:09,930 --> 00:27:14,430
so that C can't be tricked into in this sort of problematic case,

422
00:27:14,430 --> 00:27:18,000
where one file is installed and the other file is not installed.

423
00:27:18,930 --> 00:27:22,800
So that's really what the SUNDR paper tries to address,

424
00:27:23,070 --> 00:27:30,510
and the big idea in the in the paper,

425
00:27:30,720 --> 00:27:33,810
and it just turns out to be just a big idea in general,

426
00:27:35,220 --> 00:27:36,990
and it's a conceptual idea,

427
00:27:36,990 --> 00:27:40,710
even though the paper actually doesn't really implement this big idea directly,

428
00:27:40,830 --> 00:27:42,630
implement it in a more indirect way,

429
00:27:42,840 --> 00:27:46,200
it is an incredibly powerful idea.

430
00:27:47,130 --> 00:27:56,040
So the big idea is to have signed log of operations.

431
00:28:01,340 --> 00:28:04,460
And of course you're well familiar with logs of operations,

432
00:28:04,700 --> 00:28:07,100
and you and you know you can,

433
00:28:07,100 --> 00:28:09,890
and this is basically a sort of [beefed] up version of it,

434
00:28:10,190 --> 00:28:12,590
where there signatures on log entries,

435
00:28:12,590 --> 00:28:16,460
that both consider cover the entry as well as preceding entries.

436
00:28:17,150 --> 00:28:20,210
And this turns out to be,

437
00:28:20,240 --> 00:28:25,430
as we've seen in all the previous distributed systems and failure recovery protocols,

438
00:28:25,430 --> 00:28:28,730
we talk about the log is actually very powerful idea

439
00:28:28,730 --> 00:28:31,670
to think about the correctness of the system,

440
00:28:31,910 --> 00:28:38,270
and in the same way that idea is carried for here in this Byzantine context.

441
00:28:38,880 --> 00:28:42,630
And so let me draw a simple log,

442
00:28:45,660 --> 00:28:48,090
so captures this in the paper,

443
00:28:48,300 --> 00:28:50,160
so log whatever have some entries,

444
00:28:50,160 --> 00:28:54,090
and let's say you know we're coming up we are talking about,

445
00:28:54,090 --> 00:28:55,770
so it's modification,

446
00:28:56,220 --> 00:29:03,850
you know mod you know auth.py by A, signed by A,

447
00:29:05,760 --> 00:29:06,990
you know there's a mod,

448
00:29:07,620 --> 00:29:08,670
if everything goes well,

449
00:29:08,670 --> 00:29:17,730
you know there's a mod of the bank.py signed by B.

450
00:29:20,630 --> 00:29:22,280
And as we'll talk about in a second,

451
00:29:22,280 --> 00:29:26,980
you know it turns out that not only are the modifications in the log,

452
00:29:26,980 --> 00:29:29,950
but also the fetch of the read operations,

453
00:29:32,050 --> 00:29:41,780
so fetch, fetch the log you know signed by C, auth.py,

454
00:29:43,750 --> 00:29:49,850
and then fetch of bank.py, singed by C.

455
00:29:52,620 --> 00:29:56,310
We'll talk about those operations, so the fetch operations, a little bit,

456
00:29:56,490 --> 00:29:57,720
I first want to talk about,

457
00:29:57,720 --> 00:30:01,890
how to operate the preceding operations for modifications.

458
00:30:05,200 --> 00:30:08,770
So, first of all, the what's important to realize is that,

459
00:30:08,770 --> 00:30:14,350
this signature that is in the record not only covers the current records,

460
00:30:14,530 --> 00:30:16,570
but it also covers all the records before.

461
00:30:23,590 --> 00:30:25,000
Let me stop for a second here,

462
00:30:25,000 --> 00:30:28,420
because I'm not a hundred percent sure if can everybody still hear me.

463
00:30:30,220 --> 00:30:31,000
Yeah.

464
00:30:31,030 --> 00:30:31,240
Yes.

465
00:30:31,240 --> 00:30:35,500
Okay, I got my iPad and I walked out of the Zoom session,

466
00:30:35,500 --> 00:30:40,390
I always login twice and my iPad logged out,

467
00:30:40,420 --> 00:30:41,980
so I just want to make sure,

468
00:30:41,980 --> 00:30:44,050
I'm still talking to you and you can hear me,

469
00:30:46,140 --> 00:30:47,520
and start that is the case.

470
00:30:47,730 --> 00:30:51,270
Okay, so let's just proceed, the.

471
00:30:52,030 --> 00:30:52,600
So, actually.

472
00:31:20,620 --> 00:31:22,120
I think we lost Frans.

473
00:32:05,030 --> 00:32:09,530
Can people hear me now, does anybody hear me?

474
00:32:11,620 --> 00:32:12,340
Yes.

475
00:32:12,370 --> 00:32:13,330
Okay.

476
00:32:13,780 --> 00:32:16,510
Okay, I don't know if anything weird happens on your end,

477
00:32:16,510 --> 00:32:18,040
but my end,

478
00:32:18,900 --> 00:32:21,870
I got logged out of Zoom and log back in,

479
00:32:24,340 --> 00:32:28,480
maybe there's a Byzantine server at work.

480
00:32:29,440 --> 00:32:35,060
Okay, let me, hold on one second, and get myself.

481
00:32:49,800 --> 00:32:52,440
And let me see, that video goes off.

482
00:33:07,420 --> 00:33:11,380
Camera, okay, let me know if I'm good.

483
00:33:14,280 --> 00:33:15,720
Okay, good.

484
00:33:15,720 --> 00:33:17,340
No screen sharing yet, but yeah.

485
00:33:17,460 --> 00:33:20,790
Okay, I hope this works better.

486
00:33:20,820 --> 00:33:24,180
Okay, so it was at this very important point,

487
00:33:24,180 --> 00:33:28,140
where the signature just not cover the log entry itself,

488
00:33:28,230 --> 00:33:30,870
but also covers all the preceding log entries.

489
00:33:31,480 --> 00:33:38,740
And so when you know A as this modification to auth.py to the log,

490
00:33:38,800 --> 00:33:42,490
it signs the log records itself plus the preceding log record,

491
00:33:42,490 --> 00:33:43,360
so you can think about this,

492
00:33:43,360 --> 00:33:46,270
that the preceding log is may be represented by,

493
00:33:46,300 --> 00:33:50,590
the content of the preceding log is cryptographic hash,

494
00:33:50,620 --> 00:33:56,350
and in the record, basically modification to auth.py,

495
00:33:56,350 --> 00:34:01,210
you know the the cryptographic hash the preceding part of the log

496
00:34:01,210 --> 00:34:03,940
is included and covered by the signature.

497
00:34:04,150 --> 00:34:06,760
Just to be clear, we still can't see the screen.

498
00:34:07,330 --> 00:34:11,460
You can't see the screen, screen hasn't changed,

499
00:34:11,460 --> 00:34:16,300
but, let me see if I can do something about that.

500
00:34:17,340 --> 00:34:19,200
And [] I guess,

501
00:34:21,180 --> 00:34:23,250
Zoom still thinks there's actually sharing the screen,

502
00:34:23,250 --> 00:34:25,500
but it doesn't look like actually is.

503
00:34:35,230 --> 00:34:35,950
How about this?

504
00:34:37,680 --> 00:34:38,550
Yep, I can see now.

505
00:34:39,030 --> 00:34:39,780
Okay, thank you.

506
00:34:40,620 --> 00:34:42,450
Okay, so I didn't change anything yet,

507
00:34:42,510 --> 00:34:44,430
other than I think I was going to draw the next arrow,

508
00:34:44,430 --> 00:34:46,560
which basically when these signs

509
00:34:46,590 --> 00:34:49,110
you know it's actually covered all the preceding entries too.

510
00:34:50,320 --> 00:34:51,700
And this is good, correct,

511
00:34:51,700 --> 00:34:58,540
because when client you know C actually receives

512
00:34:58,540 --> 00:35:01,240
you know or gets actually sees the log entry for B,

513
00:35:01,570 --> 00:35:08,260
then it's impossible for the server to drop the log entry of A,

514
00:35:08,350 --> 00:35:10,570
because you know that will be detected,

515
00:35:10,570 --> 00:35:13,960
when C actually detect signature on the log entry of B.

516
00:35:14,810 --> 00:35:17,810
And so we really made a big step forward,

517
00:35:17,810 --> 00:35:19,550
in the sense that,

518
00:35:19,550 --> 00:35:24,410
it's much harder for the server now to selectively drop log entries.

519
00:35:25,590 --> 00:35:27,930
So that's so we're pretty good pretty good,

520
00:35:28,320 --> 00:35:30,600
you know the servers cannot drop A,

521
00:35:36,540 --> 00:35:41,150
and keep these modifications.

522
00:35:44,250 --> 00:35:46,860
So that's actually a big big step forward,

523
00:35:47,190 --> 00:35:49,110
so let's look a little bit more in detail,

524
00:35:49,110 --> 00:35:50,640
how this actually is going to play out.

525
00:35:50,850 --> 00:35:52,590
So we're a client C

526
00:35:53,700 --> 00:35:56,520
and you know we're fetching the log

527
00:35:56,520 --> 00:35:59,580
to basically rollout you know the distribution of the software

528
00:35:59,580 --> 00:36:01,140
to install on a particular machine,

529
00:36:01,470 --> 00:36:03,120
the first thing the client does,

530
00:36:03,120 --> 00:36:05,950
you know it actually check all the signatures,

531
00:36:13,990 --> 00:36:16,390
and you know always the question of course is like,

532
00:36:16,390 --> 00:36:19,060
when you know you want to check the signature log entry

533
00:36:19,060 --> 00:36:21,700
you know which public key do you use,

534
00:36:21,700 --> 00:36:24,370
and because you want to make sure that,

535
00:36:24,910 --> 00:36:30,180
you're not being tricked in accepting [] modification by A,

536
00:36:30,180 --> 00:36:32,790
but it turns out that actually A was not the person actually signed it,

537
00:36:33,350 --> 00:36:40,820
and it turns out basically to figure out which key to use to actually verify the signature,

538
00:36:41,000 --> 00:36:44,360
the key uses the owner of the file,

539
00:36:45,250 --> 00:36:49,460
so the public key need to correspond to the owner of the file,

540
00:36:50,840 --> 00:36:53,900
and ignoring groups for now,

541
00:36:53,900 --> 00:36:57,110
you know basically only the owner of the file was allowed to modify a file.

542
00:36:57,880 --> 00:37:00,940
So for simple for slightly simplified,

543
00:37:00,940 --> 00:37:04,270
we can think about it auth.py is owned by A,

544
00:37:04,600 --> 00:37:07,360
and the id of the file is basically the public key of A,

545
00:37:07,930 --> 00:37:12,280
and so we know which public key to use

546
00:37:12,490 --> 00:37:17,170
and can verify the signature with it,

547
00:37:17,170 --> 00:37:20,800
and so if somebody else makes a modification that pretends to be A,

548
00:37:20,950 --> 00:37:22,480
that actually is not going to check out.

549
00:37:23,560 --> 00:37:25,990
So it's really only A can connects and make modifications,

550
00:37:25,990 --> 00:37:26,620
similar for B.

551
00:37:28,540 --> 00:37:33,160
So that's part of the you know one thing that's actually clever about SUNDR,

552
00:37:33,310 --> 00:37:34,810
I'm not really going to be talking about,

553
00:37:35,020 --> 00:37:38,260
some since the file system is actually doubling both as a file system,

554
00:37:38,260 --> 00:37:45,280
as a public key public key infrastructure or distribution infrastructure,

555
00:37:45,550 --> 00:37:48,580
and so it's actually possible to use SUNDR,

556
00:37:48,580 --> 00:37:52,150
basically why we determine like which user has which public key.

557
00:37:53,380 --> 00:37:55,120
But I'm not really gonna talk about this,

558
00:37:55,120 --> 00:37:57,610
I really want to focus on the consistency aspects

559
00:37:57,610 --> 00:38:00,070
and the more distributed systems aspects.

560
00:38:00,990 --> 00:38:07,720
The second thing that the client does is check its own last entry.

561
00:38:13,410 --> 00:38:18,270
And this is to protect clients from actually being rolled back by the server in time,

562
00:38:18,270 --> 00:38:21,990
so the server can actually by the client checks always last entry,

563
00:38:22,440 --> 00:38:24,300
if its last entries in the log steal,

564
00:38:24,450 --> 00:38:28,590
then you know the only way for the attacker

565
00:38:28,620 --> 00:38:32,070
is to actually roll the file system, for A can roll backwards,

566
00:38:32,370 --> 00:38:35,520
so C will check whether the any of its previous operations are in it,

567
00:38:35,880 --> 00:38:38,070
and confirm that they're still in it,

568
00:38:39,600 --> 00:38:42,360
actually it's last entries still in it.

569
00:38:42,360 --> 00:38:43,620
Is the question here,

570
00:38:44,070 --> 00:38:50,100
this only I think this attack from the server to rollback,

571
00:38:50,100 --> 00:38:55,530
would only work if no other client wrote to the log,

572
00:38:56,860 --> 00:39:00,430
like after this client's last entry, right,

573
00:39:00,430 --> 00:39:04,150
because otherwise checking signatures would figure that out.

574
00:39:04,800 --> 00:39:09,390
Yeah, although you know let's talk about in a second,

575
00:39:09,390 --> 00:39:11,490
maybe I mean you could always play a fork attack,

576
00:39:11,550 --> 00:39:15,840
so you can always split you know the use of the file system in multiple users,

577
00:39:16,050 --> 00:39:18,690
but you can at least not roll back the client,

578
00:39:18,690 --> 00:39:21,090
once the client saw a particular file system,

579
00:39:21,450 --> 00:39:22,770
you can't go backwards in time,

580
00:39:24,150 --> 00:39:27,360
the client could, the server it can present different file systems in future,

581
00:39:27,390 --> 00:39:28,860
but you can't roll back.

582
00:39:32,280 --> 00:39:34,470
Third part,

583
00:39:35,100 --> 00:39:38,130
the third part with the [] is a [constructive] file system,

584
00:39:41,930 --> 00:39:46,670
so after you know, it knows actually it's not rolled past version of the file system,

585
00:39:46,760 --> 00:39:49,220
it basically applies all the modifications,

586
00:39:49,220 --> 00:39:52,460
basically builds a file system tree you know on the client,

587
00:39:52,940 --> 00:39:56,300
and and then before whatever operation it is,

588
00:39:56,300 --> 00:39:57,110
it wants to perform,

589
00:39:57,110 --> 00:40:00,080
so let's say in the case of C,

590
00:40:00,170 --> 00:40:01,790
what it will do is,

591
00:40:01,790 --> 00:40:04,550
you know it will read you know auth.py

592
00:40:04,760 --> 00:40:14,720
and append an entry to the log and sign it,

593
00:40:17,330 --> 00:40:19,280
so in the case when it reads auth.py,

594
00:40:19,280 --> 00:40:24,110
it will, it produce basically a signature or an entry for this log entry.

595
00:40:25,150 --> 00:40:29,110
And basically then and then the final step in this protocol is,

596
00:40:29,110 --> 00:40:31,810
it uploads the log to the file server,

597
00:40:37,770 --> 00:40:41,160
and you know clearly this protocol imcompletely in practical,

598
00:40:41,250 --> 00:40:43,710
and and really what it is,

599
00:40:43,710 --> 00:40:45,150
it's sort of more conceptual protocol

600
00:40:45,150 --> 00:40:46,320
to help us understand

601
00:40:46,710 --> 00:40:50,610
why eventually we might even be successful in achieving security,

602
00:40:50,610 --> 00:40:54,930
in the context of Byzantine server.

603
00:40:55,540 --> 00:40:59,560
Because if we're ridiculous correct to download the log for every operation,

604
00:40:59,770 --> 00:41:03,520
and the log contains the history of all the operations ever happened to the file system,

605
00:41:03,730 --> 00:41:04,690
in step three,

606
00:41:04,690 --> 00:41:07,180
you know the client actually constructs file system

607
00:41:07,180 --> 00:41:10,840
and all the, all operations ever performance since the beginning of time,

608
00:41:11,110 --> 00:41:12,670
and then finally in step five,

609
00:41:12,670 --> 00:41:15,880
upload the whole log back to the server, seems completely ridiculous,

610
00:41:16,090 --> 00:41:18,640
and it is ridiculous, in terms of performance,

611
00:41:18,730 --> 00:41:21,940
but it will help us understand

612
00:41:21,940 --> 00:41:25,810
you know when we look at the implementation of the scheme,

613
00:41:25,930 --> 00:41:28,750
when it actually has the same set of properties,

614
00:41:28,750 --> 00:41:31,390
that they sort of conceptual design has

615
00:41:31,870 --> 00:41:35,140
and we'll see later you know for example, in the case of Bitcoin,

616
00:41:35,230 --> 00:41:37,390
that literally does actually have a log,

617
00:41:37,390 --> 00:41:39,790
and since the beginning of time, with all operations in it

618
00:41:39,970 --> 00:41:43,120
and so, maybe it was a crazy idea,

619
00:41:43,120 --> 00:41:44,350
maybe in the context of 2004,

620
00:41:44,350 --> 00:41:46,720
but you know people actually do

621
00:41:46,720 --> 00:41:49,900
have these sign logs and really maintained it.

622
00:41:50,680 --> 00:41:51,670
And so in that sense,

623
00:41:51,820 --> 00:41:54,040
you know it's not only a big conceptual idea,

624
00:41:54,070 --> 00:41:55,540
that some people do it in practice.

625
00:41:58,340 --> 00:41:59,450
Any questions so far?

626
00:42:04,290 --> 00:42:04,980
Okay.

627
00:42:07,270 --> 00:42:10,870
The one thing you know that you're probably wondering about,

628
00:42:10,870 --> 00:42:16,110
it was proposed as question for the reading today,

629
00:42:16,320 --> 00:42:18,510
is what is up with these fetches,

630
00:42:18,510 --> 00:42:21,690
you know why are the fetches in the log too,

631
00:42:21,900 --> 00:42:26,160
and and the because you might think,

632
00:42:26,160 --> 00:42:28,260
well, you know the only thing I really care about,

633
00:42:28,260 --> 00:42:31,500
if we think about, really care about is

634
00:42:31,710 --> 00:42:33,600
only the modifications you have to be in the log,

635
00:42:33,600 --> 00:42:35,940
because there are actually things actually modify the file system,

636
00:42:35,940 --> 00:42:37,830
reads don't really modify this file system,

637
00:42:37,830 --> 00:42:40,680
so what's the what's the problem.

638
00:42:41,280 --> 00:42:44,250
And so I think I wanna do a quick breakout room here,

639
00:42:44,250 --> 00:42:46,110
and I'm sure if you can bring some of each other,

640
00:42:46,110 --> 00:42:48,870
what you thought the answer to this particular question was,

641
00:42:49,050 --> 00:42:56,140
and hopefully maybe this initial coverage like SUNDR

642
00:42:56,140 --> 00:42:58,360
you know maybe how to improve your understanding,

643
00:42:58,660 --> 00:43:01,390
and you know you can sort of figure out what the answer is,

644
00:43:01,390 --> 00:43:02,530
or talking about something else,

645
00:43:02,740 --> 00:43:06,850
so I would like to take, maybe do a five minutes breakout room.

646
00:49:18,650 --> 00:49:20,690
Okay, just checking everybody back?

647
00:49:21,860 --> 00:49:22,520
Looks like it.

648
00:49:22,940 --> 00:49:24,020
Good, thank you.

649
00:49:24,810 --> 00:49:25,380
Okay, so what,

650
00:49:25,380 --> 00:49:28,020
I guess, let's start with the homework questions,

651
00:49:28,490 --> 00:49:32,150
with [] question why, why are the fetches in the log?

652
00:49:38,260 --> 00:49:38,950
Anybody?

653
00:49:41,230 --> 00:49:43,870
If you have a read-only server,

654
00:49:44,110 --> 00:49:45,340
if there are no fetches,

655
00:49:45,340 --> 00:49:48,040
this file system can give it anything.

656
00:49:48,630 --> 00:49:49,170
Can it?

657
00:49:49,970 --> 00:49:51,650
Can give it, because it,

658
00:49:51,830 --> 00:49:53,780
because there are no fetches in the log,

659
00:49:53,780 --> 00:49:58,060
that would mean that there are,

660
00:49:58,180 --> 00:50:04,680
there be read-only servers would not be doing a lot of the checks,

661
00:50:04,680 --> 00:50:05,970
that we talked about before,

662
00:50:05,970 --> 00:50:09,000
so they they go back in time,

663
00:50:09,000 --> 00:50:10,860
for example might maybe not work,

664
00:50:10,860 --> 00:50:13,850
because it did not put anything in the log,

665
00:50:13,970 --> 00:50:15,500
because it only fetches.

666
00:50:15,740 --> 00:50:16,760
Yeah, okay, good,

667
00:50:16,760 --> 00:50:19,640
okay, so I think you're totally on the right track,

668
00:50:19,910 --> 00:50:23,780
it was like trying to make it a little bit more precise or make more concrete,

669
00:50:23,810 --> 00:50:25,250
and I think you know that is correct.

670
00:50:25,310 --> 00:50:27,050
So let's assume this is the log looks like,

671
00:50:27,050 --> 00:50:28,880
and the C's fetches are not in it.

672
00:50:29,480 --> 00:50:31,190
And let's you know,

673
00:50:31,190 --> 00:50:35,450
so this is the log before actually C downloads log,

674
00:50:35,720 --> 00:50:44,190
so let's say you know where C fetches, fetches auth.py, correct,

675
00:50:44,190 --> 00:50:45,990
the file that was modified by A,

676
00:50:46,830 --> 00:50:49,140
and basically what the server does,

677
00:50:49,380 --> 00:50:55,290
the server instead of actually providing both the modifications A and B,

678
00:50:55,290 --> 00:50:56,070
because it has it,

679
00:50:56,880 --> 00:50:59,280
which A and B were done with its modifications,

680
00:50:59,610 --> 00:51:06,330
it sends the C basically prefix,

681
00:51:08,880 --> 00:51:15,840
since the prefix that excludes the modifications to A and B,

682
00:51:16,900 --> 00:51:22,690
so we have mods A and B, right,

683
00:51:22,690 --> 00:51:24,820
and so C you know fetches this file,

684
00:51:24,970 --> 00:51:26,650
it fetches the log,

685
00:51:26,800 --> 00:51:30,460
and so this basically is this part of the log prefix,

686
00:51:32,540 --> 00:51:36,470
you know the C checks you know the signature,

687
00:51:36,470 --> 00:51:38,960
checks whether it's proceeding operations are in it,

688
00:51:39,290 --> 00:51:40,640
you know and they're all there,

689
00:51:40,640 --> 00:51:42,590
because C hasn't done any other operation yet,

690
00:51:42,920 --> 00:51:44,750
and so basically it will accept the log,

691
00:51:44,750 --> 00:51:47,450
and the log as it is or the prefix as it is,

692
00:51:47,810 --> 00:51:52,310
and basically returns you know auth.py to whatever application,

693
00:51:52,860 --> 00:51:55,290
that is copying this software into the machine,

694
00:51:55,290 --> 00:51:57,390
that actually run the installed software.

695
00:51:58,130 --> 00:52:05,230
So then C fetches bank.py,

696
00:52:08,590 --> 00:52:14,230
and this time around, the server sends the whole log,

697
00:52:19,460 --> 00:52:25,550
and you know the C, C looks at these entries,

698
00:52:25,550 --> 00:52:27,770
and it's a valid log,

699
00:52:27,770 --> 00:52:30,740
in the operations are presumably the prefix,

700
00:52:31,310 --> 00:52:33,470
since we didn't care about fetches,

701
00:52:33,470 --> 00:52:34,970
you know its all caught in the log,

702
00:52:35,210 --> 00:52:38,270
and so everything looks you know good,

703
00:52:38,270 --> 00:52:39,800
you know these are valid modifications,

704
00:52:39,800 --> 00:52:41,900
the nothing has been changed,

705
00:52:42,410 --> 00:52:47,450
and and so you know C you know without the fetches in the log,

706
00:52:47,600 --> 00:52:50,240
C will actually accept this log,

707
00:52:50,450 --> 00:52:52,670
and basically build a file system,

708
00:52:52,670 --> 00:52:58,490
that has, that deploy includes modifications to A and B

709
00:52:58,640 --> 00:53:02,930
and returns the results you know to the application for bank.py.

710
00:53:05,490 --> 00:53:07,050
So that it can install the machine,

711
00:53:07,050 --> 00:53:09,030
that actually is going to run the servers

712
00:53:09,360 --> 00:53:12,630
and as you can see you know we're sort of in a bad situation, right,

713
00:53:12,630 --> 00:53:17,080
because we took the old version of auth.py

714
00:53:18,220 --> 00:53:21,010
and the new version of bank.py,

715
00:53:22,940 --> 00:53:25,460
and the one way you can think about this is that,

716
00:53:25,640 --> 00:53:27,650
you know from you know C's perspective,

717
00:53:27,890 --> 00:53:33,110
what really seemed to have happened is that,

718
00:53:34,110 --> 00:53:37,260
while you know it was reading auth.py,

719
00:53:37,380 --> 00:53:40,320
you know there were concurrent modifications to A and B,

720
00:53:40,320 --> 00:53:42,240
and just happened basically at the same time

721
00:53:42,240 --> 00:53:45,120
or at least the server is pretending it happened at the same time,

722
00:53:45,600 --> 00:53:48,180
and so and so it gets confused,

723
00:53:48,550 --> 00:53:50,620
or can't detect the fact,

724
00:53:50,620 --> 00:53:53,770
that these applications were did happen before any time.

725
00:53:55,060 --> 00:53:56,920
So this is the, this is the problem,

726
00:53:56,920 --> 00:54:00,700
that you know basically putting the fetches in the log [],

727
00:54:01,090 --> 00:54:06,010
is like let's make that actually just also concrete,

728
00:54:08,200 --> 00:54:13,300
and so see why actually this problem is solved in that case.

729
00:54:14,260 --> 00:54:16,030
Professor, I I had a question.

730
00:54:16,090 --> 00:54:20,590
Yeah, so I I'm having a little trouble understand,

731
00:54:20,590 --> 00:54:26,410
like understanding what the, like sort of like the interface,

732
00:54:26,410 --> 00:54:30,550
for like for fetch and modify is like what,

733
00:54:31,350 --> 00:54:35,670
I I thought you fetched pretty much like the whole tree,

734
00:54:35,700 --> 00:54:37,800
and had to rebuild the whole file system,

735
00:54:37,860 --> 00:54:39,600
basic example,

736
00:54:39,900 --> 00:54:44,610
but this slide before you're fetching specific files.

737
00:54:44,850 --> 00:54:49,170
The server is the one that returns the log, correct,

738
00:54:49,890 --> 00:54:52,260
so the server can decide what entries to include.

739
00:54:52,640 --> 00:54:53,240
Yeah.

740
00:54:53,240 --> 00:54:54,470
And we're already seeing that,

741
00:54:54,470 --> 00:54:57,230
it can't really delete anything out in the middle of the log,

742
00:54:57,260 --> 00:54:58,790
and that's not really possible,

743
00:54:59,090 --> 00:55:01,130
it's always send a prefix of the log,

744
00:55:01,160 --> 00:55:03,740
because the prefix is always consistent with itself.

745
00:55:04,670 --> 00:55:08,100
And so in this first case, correct,

746
00:55:08,100 --> 00:55:09,150
it sends the prefix,

747
00:55:09,510 --> 00:55:11,280
and in the second case, sends the whole log.

748
00:55:11,370 --> 00:55:12,750
Yeah.

749
00:55:12,750 --> 00:55:14,130
So the server can decide to do that,

750
00:55:14,130 --> 00:55:16,230
but there's nothing that the client can,

751
00:55:16,260 --> 00:55:17,670
or at least it like so far,

752
00:55:17,730 --> 00:55:19,950
you know discuss there's nothing that the client,

753
00:55:19,950 --> 00:55:21,030
how the client could detect,

754
00:55:21,030 --> 00:55:22,680
that it did get like the whole log.

755
00:55:22,950 --> 00:55:26,160
Right, I I my question is more towards,

756
00:55:26,160 --> 00:55:29,400
like what the interface is for clients to use,

757
00:55:29,400 --> 00:55:31,770
like fetch and modify, like,

758
00:55:32,070 --> 00:55:33,750
because I thought, initially I thought,

759
00:55:33,750 --> 00:55:36,870
okay, fetch fetch is like the whole file system.

760
00:55:36,900 --> 00:55:38,970
No, no, fetch is a single file.

761
00:55:39,210 --> 00:55:39,870
Okay.

762
00:55:40,440 --> 00:55:42,750
And and so basically what the fetch does,

763
00:55:42,750 --> 00:55:44,640
it get to the log, like modifications,

764
00:55:45,150 --> 00:55:47,760
modifications are all the operations that modify a file,

765
00:55:48,180 --> 00:55:50,970
and like if you go back to a slide a little bit earlier,

766
00:55:51,000 --> 00:55:52,530
you know in the modification record,

767
00:55:52,530 --> 00:55:55,140
it says explicitly which file is being modified,

768
00:55:56,310 --> 00:55:58,380
and you know what's being said is,

769
00:55:58,380 --> 00:55:59,460
similarly in the fetch,

770
00:55:59,460 --> 00:56:01,680
it says which file like this client saw.

771
00:56:03,400 --> 00:56:04,150
Okay.

772
00:56:04,640 --> 00:56:08,480
And then, so so, so for fetch,

773
00:56:08,510 --> 00:56:11,330
like a client goes through the log,

774
00:56:11,330 --> 00:56:12,500
but only looks at.

775
00:56:13,130 --> 00:56:16,070
Yeah, feath a thing that does actually read the file that actually is looking for.

776
00:56:16,550 --> 00:56:20,840
Okay, but does it check every single entry in the log anyways for the signature.

777
00:56:20,840 --> 00:56:25,250
Yeah, okay, the first step is always check the whole log,

778
00:56:25,400 --> 00:56:29,870
go for and make sure that your last you know operations in it,

779
00:56:29,870 --> 00:56:31,280
whether it's a fetch or modify,

780
00:56:31,520 --> 00:56:35,780
although in this broken scheme, you know we drop the fetches,

781
00:56:36,230 --> 00:56:39,650
it applies all the checks, all the signatures,

782
00:56:39,920 --> 00:56:42,380
and then it builds up the file system,

783
00:56:42,970 --> 00:56:45,160
by replaying the log from the beginning of time,

784
00:56:45,160 --> 00:56:46,120
get a file system,

785
00:56:46,210 --> 00:56:47,770
and then it does its operation,

786
00:56:47,830 --> 00:56:48,700
and so in this case,

787
00:56:48,700 --> 00:56:51,880
the operation is certainly fetched auth.py, is basically reading it.

788
00:56:52,520 --> 00:56:53,030
Okay.

789
00:56:53,180 --> 00:56:55,940
The reason you know basically that we talk about fetch and modify is,

790
00:56:55,940 --> 00:56:58,850
because all operations are basically following one or two [],

791
00:56:58,850 --> 00:57:03,110
either to fetch or it is a modification operation,

792
00:57:03,110 --> 00:57:04,970
like writing a file, creating a file,

793
00:57:04,970 --> 00:57:07,040
there's all modification operations,

794
00:57:07,130 --> 00:57:12,410
the fetch operations are reading a file, maybe [] directory status file,

795
00:57:12,410 --> 00:57:13,010
that kind of thing.

796
00:57:13,730 --> 00:57:15,920
Okay, and then the modify is also,

797
00:57:16,130 --> 00:57:21,790
like a modify, like doesn't fetch the,

798
00:57:21,790 --> 00:57:23,230
okay, also fetches the log,

799
00:57:23,230 --> 00:57:26,170
but then builds the file system.

800
00:57:26,200 --> 00:57:28,630
Yeah, so maybe the fetches here, I'm using fetch,

801
00:57:28,630 --> 00:57:29,650
I guess in two ways,

802
00:57:29,680 --> 00:57:31,900
one describe read-only operations,

803
00:57:32,080 --> 00:57:35,680
and actually to obtain or receive the log from the server.

804
00:57:36,170 --> 00:57:39,980
Okay, but then modify modifies also one single file.

805
00:57:40,310 --> 00:57:43,250
Yes, yeah, for every modification in the file system,

806
00:57:43,250 --> 00:57:44,360
you're gonna have a log entry.

807
00:57:44,900 --> 00:57:45,470
Okay, thanks.

808
00:57:47,900 --> 00:57:50,660
Sorry, I also have a question,

809
00:57:50,660 --> 00:57:56,150
I I don't really understand why this scenario is a problem,

810
00:57:56,750 --> 00:57:58,370
because as you said,

811
00:57:58,970 --> 00:58:00,260
it's it's possible,

812
00:58:00,260 --> 00:58:01,940
like from the perspective of the client,

813
00:58:01,940 --> 00:58:03,050
it may well be that,

814
00:58:03,230 --> 00:58:09,530
A and B got created or modified, for the last fetch.

815
00:58:09,650 --> 00:58:11,510
Yeah, in principle, it could have happen, correct,

816
00:58:11,510 --> 00:58:12,800
that was [recovering] modification,

817
00:58:12,980 --> 00:58:13,850
we do know,

818
00:58:13,850 --> 00:58:16,880
because like we were sort of look from the top,

819
00:58:17,120 --> 00:58:21,470
and we know that basically C you read the file, after A and B modified,

820
00:58:22,860 --> 00:58:26,100
but the server can pretend as if it actually happened concurrently,

821
00:58:26,160 --> 00:58:28,200
and in the second, we'll see that,

822
00:58:28,200 --> 00:58:30,000
if we stick the fetches in the log,

823
00:58:30,060 --> 00:58:31,590
server can not pretend to do that.

824
00:58:33,240 --> 00:58:36,480
Okay, but even if the server pretends that,

825
00:58:36,510 --> 00:58:40,450
does it, is that even a problem,

826
00:58:40,450 --> 00:58:41,590
does it break anything,

827
00:58:41,590 --> 00:58:41,890
because.

828
00:58:41,890 --> 00:58:46,090
Yeah, this is a example where it shows how to break something, correct,

829
00:58:46,360 --> 00:58:50,100
like step one, you know C fetches auth.py,

830
00:58:50,250 --> 00:58:51,870
the server gave it one,

831
00:58:52,110 --> 00:58:55,530
you know as far as the fetch, it gave the prefix,

832
00:58:56,260 --> 00:58:58,030
and so the client constructed file system,

833
00:58:58,030 --> 00:58:59,230
executing the operation,

834
00:58:59,230 --> 00:59:02,080
returned auth.py to the application,

835
00:59:02,080 --> 00:59:03,820
and install the software on the machine,

836
00:59:03,880 --> 00:59:05,680
just to make it very [],

837
00:59:05,860 --> 00:59:09,580
so now the first, you're reading auth.py that operation is done,

838
00:59:10,000 --> 00:59:11,680
finished already executed,

839
00:59:11,920 --> 00:59:16,900
and has installed the old version of auth.py on the machine,

840
00:59:18,700 --> 00:59:22,240
then the client you know can fetch is bank.py,

841
00:59:23,050 --> 00:59:28,690
now the server actually, the client the application want to read bank.py,

842
00:59:28,810 --> 00:59:30,970
so the client fetches the log from the server

843
00:59:31,180 --> 00:59:33,310
or ask the server, please give me the log,

844
00:59:33,670 --> 00:59:35,710
the server this time around gives the whole log,

845
00:59:36,240 --> 00:59:37,620
and not just the prefix.

846
00:59:38,010 --> 00:59:38,610
Yeah, but.

847
00:59:38,610 --> 00:59:41,040
The [] that builds up the whole file system

848
00:59:41,070 --> 00:59:43,890
and returns bank.py to the application.

849
00:59:44,830 --> 00:59:50,230
But in like, wouldn't this happen in an incorrect implementation of the client,

850
00:59:50,230 --> 00:59:53,680
because if the client finds that receives the log,

851
00:59:53,770 --> 00:59:56,770
and it sees an additional modification on A,

852
00:59:56,980 --> 01:00:02,050
if the client knows that its logic depends on A and B being in sync,

853
01:00:02,050 --> 01:00:03,640
it would also fetch A again.

854
01:00:04,600 --> 01:00:06,670
Okay, so there's a question,

855
01:00:06,940 --> 01:00:08,830
C doesn't know, correct,

856
01:00:08,830 --> 01:00:13,330
that, is C,

857
01:00:13,360 --> 01:00:17,580
okay, in this particular scenario,

858
01:00:18,390 --> 01:00:21,540
the we're trying to establish whether actually,

859
01:00:21,540 --> 01:00:22,470
you know C can determine

860
01:00:22,470 --> 01:00:26,160
whether actually modification happens concurrently or in the past,

861
01:00:26,160 --> 01:00:26,820
before reading,

862
01:00:27,480 --> 01:00:28,740
you know we want to be in the case,

863
01:00:28,740 --> 01:00:29,970
that actually happened in the past,

864
01:00:29,970 --> 01:00:31,800
because actually really happened in the past,

865
01:00:32,110 --> 01:00:35,170
but you know what this you know server does,

866
01:00:35,200 --> 01:00:38,710
it just pretends that the modification actually happened concurrently,

867
01:00:38,770 --> 01:00:40,930
with actually sees operations,

868
01:00:41,860 --> 01:00:45,520
and C doesn't really have any way to detect that,

869
01:00:45,610 --> 01:00:48,580
other than a new you know maybe A,

870
01:00:48,580 --> 01:00:51,010
you know there should have been a modification for A and B together,

871
01:00:51,500 --> 01:00:53,210
but that only could have known,

872
01:00:53,210 --> 01:00:55,700
if there were sort of communication between C and A and B,

873
01:00:55,730 --> 01:00:57,770
and second, let's talk about that in a second,

874
01:00:57,770 --> 01:00:59,960
but if C had not talked to A and B

875
01:01:00,170 --> 01:01:03,200
and you know yeah it could have gotten,

876
01:01:03,230 --> 01:01:05,360
could end up in this scenario,

877
01:01:05,360 --> 01:01:08,540
where it installed the old version in auth.py,

878
01:01:08,540 --> 01:01:09,950
the new version of bank.py.

879
01:01:10,640 --> 01:01:11,540
And we'll see in the second,

880
01:01:11,540 --> 01:01:12,950
if we stick the fetches in,

881
01:01:13,010 --> 01:01:14,510
then this probably cannot happen.

882
01:01:17,720 --> 01:01:19,970
Somebody asked, if we timestamp everything,

883
01:01:19,970 --> 01:01:21,560
then we could detect things,

884
01:01:21,590 --> 01:01:22,790
hold that thought for a second.

885
01:01:25,450 --> 01:01:29,560
Okay, let's look at the with fetches scenario, right,

886
01:01:29,770 --> 01:01:32,140
so see what actually happens in that case,

887
01:01:32,260 --> 01:01:38,860
so client fetches, what is the fetches of auth.py.

888
01:01:41,740 --> 01:01:42,940
Oops, what happened now.

889
01:01:48,660 --> 01:01:53,030
Hold on a second, something wrong.

890
01:01:53,780 --> 01:01:56,390
I presumably nobody can see my screen.

891
01:02:03,010 --> 01:02:03,820
It's black.

892
01:02:03,850 --> 01:02:06,040
Yeah, yeah, coming back, hold on a second.

893
01:02:10,850 --> 01:02:15,620
I definitely feel today, there's a Byzantine component to 6.824.

894
01:02:32,480 --> 01:02:34,490
Okay, I need to stop sharing screen for a second.

895
01:03:21,610 --> 01:03:23,080
Alright, we're back hopefully.

896
01:03:24,730 --> 01:03:25,900
Okay.

897
01:03:32,090 --> 01:03:36,440
Okay, so back to this example,

898
01:03:36,470 --> 01:03:38,180
where now the fetches are in the log,

899
01:03:38,180 --> 01:03:40,220
C fetches the auth.py.

900
01:03:42,300 --> 01:03:46,830
So let me continue, right then,

901
01:03:48,960 --> 01:03:50,250
save this for just.

902
01:03:51,730 --> 01:03:54,010
C fetches auth.py,

903
01:03:54,100 --> 01:03:57,280
the server sends the prefix,

904
01:04:03,180 --> 01:04:06,870
so basically sends you know these modifications, correct,

905
01:04:06,870 --> 01:04:09,900
the server can just return whatever it likes,

906
01:04:09,930 --> 01:04:13,110
then you know in this new plan, correct,

907
01:04:13,110 --> 01:04:15,270
where the fetches are being log,

908
01:04:15,540 --> 01:04:20,100
then, C constructs file system using A and B,

909
01:04:20,310 --> 01:04:24,900
and then returns of course you know auth.py to the client,

910
01:04:24,900 --> 01:04:27,570
to the client or to the application,

911
01:04:27,810 --> 01:04:33,450
and then it adds a fetch to the log,

912
01:04:35,720 --> 01:04:43,100
and uploads that log to the server,

913
01:04:43,340 --> 01:04:49,270
and then you know the, that does a fetch of you know bank.py,

914
01:04:51,760 --> 01:04:54,220
and you know the server,

915
01:04:54,220 --> 01:04:57,340
you know in previous example,

916
01:04:57,640 --> 01:05:00,760
first, it sends just a prefix,

917
01:05:01,730 --> 01:05:02,870
so here's like prefix,

918
01:05:05,050 --> 01:05:10,350
now you know sends, now the client sends the whole thing, right,

919
01:05:10,350 --> 01:05:12,450
so sends the whole log,

920
01:05:13,440 --> 01:05:18,300
and it, but if modifications are in it,

921
01:05:18,810 --> 01:05:20,880
so and we'll have to send the whole log,

922
01:05:20,880 --> 01:05:21,810
we'll send the whole log

923
01:05:21,810 --> 01:05:24,720
and must include the fetch from C, right,

924
01:05:25,080 --> 01:05:32,250
and so,, if it doesn't you know sends fetch C,

925
01:05:32,250 --> 01:05:39,000
it actually, C is, C is actually not there, the read operation,

926
01:05:39,330 --> 01:05:44,580
and basically the client will reject the log,

927
01:05:44,580 --> 01:05:47,130
because actually it's own fetch operation is actually not in it,

928
01:05:47,340 --> 01:05:52,080
so it's not possible for the server to pretend

929
01:05:52,080 --> 01:05:54,540
you know that to send the log later on,

930
01:05:54,540 --> 01:05:58,230
because actually the new log should have included that fetch operation,

931
01:05:58,530 --> 01:06:01,800
that was in it and update the C,

932
01:06:01,800 --> 01:06:05,160
or the server cannot twice that fetch operation into here,

933
01:06:05,580 --> 01:06:08,940
to make it consistent what actually happened before,

934
01:06:09,120 --> 01:06:10,890
because that would be detected,

935
01:06:10,920 --> 01:06:14,370
because you know the modifications on the records of A and B are not,

936
01:06:14,370 --> 01:06:15,630
wouldn't check out.

937
01:06:18,420 --> 01:06:22,800
Okay, so basically what this really does is to sort of step back,

938
01:06:22,920 --> 01:06:24,720
is that you can think about this attack,

939
01:06:24,720 --> 01:06:29,910
that the server sort of pretends that the modification of A and B happen concurrently,

940
01:06:30,120 --> 01:06:31,950
with the C reading it,

941
01:06:32,100 --> 01:06:34,530
even though we know that actually it's not the case,

942
01:06:34,530 --> 01:06:36,150
and by speaking the fetches in it,

943
01:06:36,360 --> 01:06:38,820
that attack cannot happen.

944
01:06:43,440 --> 01:06:46,020
I have two questions,

945
01:06:46,080 --> 01:06:47,970
maybe first just,

946
01:06:48,120 --> 01:06:52,920
if you could like define fork consistency and the fetch modify consistency.

947
01:06:52,920 --> 01:06:54,030
And then the second is,

948
01:06:54,360 --> 01:06:55,680
in this example,

949
01:06:55,710 --> 01:07:03,580
so what exactly is stopping the server from placing the fetch in the right place of the log?

950
01:07:03,820 --> 01:07:09,030
Because remember every log entry covers all its proceeding entries.

951
01:07:09,660 --> 01:07:10,530
Okay, so if.

952
01:07:10,530 --> 01:07:14,070
The server could not slice that,

953
01:07:14,070 --> 01:07:17,910
you know fetch you know after the prefix before the modification of A and B.

954
01:07:18,860 --> 01:07:21,260
So let's say it only wants to send the modification of A,

955
01:07:21,260 --> 01:07:24,650
it knows the hash of the modification of A and everything preceding it,

956
01:07:25,040 --> 01:07:27,680
and then it could insert the fetch to C there,

957
01:07:27,680 --> 01:07:28,610
because it knows that,

958
01:07:29,180 --> 01:07:31,100
it's a hash of that, and.

959
01:07:31,100 --> 01:07:32,240
Then they couldn't send.

960
01:07:32,270 --> 01:07:34,340
Yeah, but then they couldn't send the modification to B,

961
01:07:36,410 --> 01:07:39,560
because the modification to B you know is directly after A,

962
01:07:39,590 --> 01:07:40,700
and so A must,

963
01:07:40,700 --> 01:07:43,100
and so it can't slice it between A and B either.

964
01:07:44,490 --> 01:07:45,450
I see, okay.

965
01:07:49,580 --> 01:07:53,270
Sorry, what was a problem with having it where it is in the picture?

966
01:07:55,470 --> 01:07:57,300
Well, where it is, now the picture is perfect,

967
01:07:57,360 --> 01:07:58,650
that's fine, right,

968
01:07:58,710 --> 01:08:00,630
in fact you know this basically suggests

969
01:08:00,630 --> 01:08:04,620
you know that the fetch of C actually included the modification of A and B,

970
01:08:04,620 --> 01:08:06,000
like the blue was the real log,

971
01:08:06,760 --> 01:08:09,160
and we have the fetch to C in it,

972
01:08:09,160 --> 01:08:11,680
and you know the everything to be perfect.

973
01:08:18,660 --> 01:08:21,570
So just to clarify the definition of fork consistent.

974
01:08:21,570 --> 01:08:23,940
Yeah, hold on, hold on a second, because I haven't talked the slide,

975
01:08:25,650 --> 01:08:27,720
I haven't talked about the definition of fork consistency,

976
01:08:27,720 --> 01:08:28,710
I'm gonna do that right now.

977
01:08:30,450 --> 01:08:30,990
Okay?

978
01:08:32,860 --> 01:08:35,050
So we're going to talk about fork consistency.

979
01:08:43,980 --> 01:08:47,640
So, so what we've seen so far is that,

980
01:08:47,640 --> 01:08:50,700
the server cannot really manipulate the log,

981
01:08:50,700 --> 01:08:53,580
it can only send prefixes or can hide parts,

982
01:08:53,580 --> 01:08:57,930
you can hide, it can send prefix back to the client,

983
01:08:58,110 --> 01:09:00,000
but it can't really modify the log,

984
01:09:00,030 --> 01:09:01,650
so just basically have an opportunity

985
01:09:01,650 --> 01:09:06,450
to you know sort of show different logs to different clients,

986
01:09:06,450 --> 01:09:10,020
and that is basically what fork consistency is.

987
01:09:10,320 --> 01:09:12,870
And so it cannot provide you know the kind of,

988
01:09:13,050 --> 01:09:15,450
the server cannot provide the type of consistency

989
01:09:15,450 --> 01:09:16,860
that we've seen so far in the past,

990
01:09:16,860 --> 01:09:19,920
name likely linearizability and external consistency and things like that,

991
01:09:19,920 --> 01:09:21,000
that's just not possible,

992
01:09:21,450 --> 01:09:22,620
but it can provide this,

993
01:09:22,620 --> 01:09:26,220
what this what the paper calls or introduces is fork consistency.

994
01:09:26,490 --> 01:09:30,090
And let me abstract a little bit away and to explain what that is.

995
01:09:30,620 --> 01:09:32,450
So let's say we have client A,

996
01:09:32,780 --> 01:09:34,520
we have the server S,

997
01:09:35,280 --> 01:09:37,290
and it has a log,

998
01:09:39,150 --> 01:09:41,550
and let's say I'm just gonna extract everything away,

999
01:09:41,550 --> 01:09:43,440
it has entries A B C and D and E,

1000
01:09:45,540 --> 01:09:50,310
and you know A you know whatever maybe you know append entry to the log

1001
01:09:50,460 --> 01:09:56,220
and you know and that's basically [].

1002
01:09:56,490 --> 01:09:58,890
And maybe we have another client B,

1003
01:10:00,830 --> 01:10:03,710
and what the server can do

1004
01:10:03,830 --> 01:10:07,880
is sort of give the other client a completely different view of the world,

1005
01:10:07,940 --> 01:10:10,220
by basically have another copy of the log

1006
01:10:11,340 --> 01:10:12,150
or its own copy

1007
01:10:12,150 --> 01:10:14,040
or give a different copy of the log,

1008
01:10:14,040 --> 01:10:16,650
for example, maybe that log contains the record A,

1009
01:10:17,150 --> 01:10:19,610
but then every operation of B does,

1010
01:10:19,730 --> 01:10:22,790
goes into this log you know B1 B2,

1011
01:10:22,820 --> 01:10:25,940
maybe even some operations from other clients, that also get this view

1012
01:10:26,030 --> 01:10:27,170
and end up in this log,

1013
01:10:27,320 --> 01:10:29,390
but they're not actually shown to A,

1014
01:10:29,880 --> 01:10:34,020
you know A basically A may actually also add more entries to log,

1015
01:10:34,020 --> 01:10:35,850
like maybe it had B C and E,

1016
01:10:36,090 --> 01:10:39,270
and those are not actually shown to B,

1017
01:10:39,600 --> 01:10:43,590
so these two logs to the [] view of A,

1018
01:10:43,590 --> 01:10:45,060
you know it's completely consistent,

1019
01:10:45,120 --> 01:10:47,430
because it's unaware of any of these changes,

1020
01:10:48,000 --> 01:10:50,640
and to B you know this log looks completely consistent,

1021
01:10:50,640 --> 01:10:53,250
because they don't aware of any A changes, right,

1022
01:10:54,330 --> 01:10:55,890
in this model of the world,

1023
01:10:55,980 --> 01:11:00,240
the only sort shared communication place that is, there is the server,

1024
01:11:00,270 --> 01:11:01,500
you know that is sort of the,

1025
01:11:01,740 --> 01:11:04,650
you know the thing that you know shows

1026
01:11:04,650 --> 01:11:06,780
you know what actually is the state of the system.

1027
01:11:07,600 --> 01:11:09,940
And one way you can think about is,

1028
01:11:09,940 --> 01:11:12,070
like in terms that we've talked about before,

1029
01:11:12,100 --> 01:11:13,540
this is sort of like a split brain,

1030
01:11:16,720 --> 01:11:21,760
you know basically you know A gets see one view of the world,

1031
01:11:21,760 --> 01:11:25,990
you know cooked up by by log that's consistent with A view,

1032
01:11:26,230 --> 01:11:28,690
and you know B you know it's another view of the world,

1033
01:11:29,330 --> 01:11:32,690
and basically the servers sort of keeps them to carefully separate,

1034
01:11:32,900 --> 01:11:36,260
and and therefore can pretend that,

1035
01:11:36,260 --> 01:11:40,130
you know A is looking one, sees the left side of split brain,

1036
01:11:40,160 --> 01:11:42,800
B is actually the right side of split brain.

1037
01:11:43,930 --> 01:11:44,980
Okay?

1038
01:11:45,900 --> 01:11:46,650
Does that make sense?

1039
01:11:50,220 --> 01:11:52,230
So that's sort of what you know basically they're saying is,

1040
01:11:52,230 --> 01:11:55,230
like you know we can't really do better than fork consistency,

1041
01:11:55,260 --> 01:12:02,130
because it's always possible for the server to to basically make a copy of the log,

1042
01:12:02,400 --> 01:12:06,840
and then from then on, you know present different views for these clients.

1043
01:12:07,300 --> 01:12:10,780
Now, S could not merge the two logs again, correct,

1044
01:12:10,810 --> 01:12:13,600
these logs have to be separate, you know for A and B,

1045
01:12:13,900 --> 01:12:14,920
because it could be,

1046
01:12:14,920 --> 01:12:18,340
it's impossible for S to sort of take you know the logs,

1047
01:12:18,340 --> 01:12:19,720
let them go for a while,

1048
01:12:19,840 --> 01:12:22,420
and then basically splice these two logs together again,

1049
01:12:23,040 --> 01:12:28,200
because you know the, because these entries should protect all these preceding entries,

1050
01:12:28,200 --> 01:12:30,660
these entries protect all the preceding entries with those

1051
01:12:30,840 --> 01:12:32,880
and so you can't put them back together,

1052
01:12:34,000 --> 01:12:35,620
and because the signatures wouldn't check out,

1053
01:12:35,620 --> 01:12:38,980
because the signatures always covered the current entry for all the preceding entries.

1054
01:12:40,470 --> 01:12:42,630
And so the only thing they are basically do,

1055
01:12:42,630 --> 01:12:44,310
the server can do

1056
01:12:44,340 --> 01:12:50,010
basically split the world, fork the world into different into two different logs,

1057
01:12:51,060 --> 01:12:52,830
they might have a common log at the beginning,

1058
01:12:52,890 --> 01:12:54,360
then to sort of fork them,

1059
01:12:54,480 --> 01:12:57,690
now that you know A and B basically operate in different worlds.

1060
01:13:01,500 --> 01:13:04,320
So, and that's sort of the definition fork consistency,

1061
01:13:04,320 --> 01:13:05,700
and that's basically the best

1062
01:13:05,700 --> 01:13:09,120
you know this particular file system, this particular system can do,

1063
01:13:09,180 --> 01:13:12,600
if there's, the only communication actually happens between S.

1064
01:13:15,270 --> 01:13:16,680
Notice is actually by the way,

1065
01:13:16,860 --> 01:13:18,780
that's sort of fork consistency is good enough

1066
01:13:18,780 --> 01:13:20,910
for our particular applications zookeeper, correct,

1067
01:13:21,330 --> 01:13:28,290
because the, either the server shows the old version, you know without A B,

1068
01:13:28,710 --> 01:13:33,930
or you know the server shows the S you know the modification with A and B.

1069
01:13:37,530 --> 01:13:39,060
Okay, so what do you do,

1070
01:13:39,330 --> 01:13:41,580
it seems like you know maybe this is actually problem,

1071
01:13:41,580 --> 01:13:43,800
how do you detect forks

1072
01:13:44,580 --> 01:13:53,110
and how could you, so how do you detect fork.

1073
01:13:53,110 --> 01:13:57,400
Well, there's two schemes, that paper mentions,

1074
01:13:57,730 --> 01:14:00,340
one is out-of-band communication,

1075
01:14:10,320 --> 01:14:11,580
it is pretty straightforward,

1076
01:14:12,150 --> 01:14:15,780
you know if you know A and B ever talk to each other,

1077
01:14:16,530 --> 01:14:17,940
for example ask each other,

1078
01:14:17,970 --> 01:14:19,800
hey, what did your last entry in the log,

1079
01:14:20,220 --> 01:14:21,840
and they get different answers,

1080
01:14:22,540 --> 01:14:25,660
they know you know that they have been fork,

1081
01:14:25,690 --> 01:14:28,750
because either they could have different answers,

1082
01:14:28,750 --> 01:14:31,930
but at least then one should be the prefix of the other,

1083
01:14:32,430 --> 01:14:34,140
and if that's not the case,

1084
01:14:34,200 --> 01:14:37,530
then they know that they're actually being exactly fork.

1085
01:14:40,760 --> 01:14:45,710
So, that's one possible scenario, that they discussed in the paper,

1086
01:14:45,710 --> 01:14:51,830
basically share the clients periodically exchange the last log entries,

1087
01:14:52,730 --> 01:14:54,410
the last entry in their log.

1088
01:14:54,560 --> 01:14:58,850
Another solution which actually has mentioned in the chat is,

1089
01:14:59,800 --> 01:15:02,440
you know introduce what they call sort of trusted machine,

1090
01:15:02,740 --> 01:15:06,370
that is time stamp box,

1091
01:15:08,500 --> 01:15:10,870
and basically like every few seconds,

1092
01:15:10,870 --> 01:15:14,650
you know it actually ends adds a time stamp to the log,

1093
01:15:14,920 --> 01:15:20,560
and and every client knows that you know basically it's a file,

1094
01:15:20,560 --> 01:15:23,590
in the file system that contains you know the current time,

1095
01:15:23,710 --> 01:15:26,080
everytime the time stamp box,

1096
01:15:26,080 --> 01:15:29,260
you know every couple seconds time stamp box updates that file,

1097
01:15:29,470 --> 01:15:31,180
the clients read that file,

1098
01:15:31,270 --> 01:15:34,390
and they know there should be a new modification like every couple seconds,

1099
01:15:35,170 --> 01:15:37,930
and that basically you know that that fork,

1100
01:15:37,960 --> 01:15:41,290
that contains the time stamp box is sort of the fork,

1101
01:15:41,290 --> 01:15:47,920
the the clients, the server actually has to present to the clients.

1102
01:15:51,800 --> 01:15:52,430
Okay?

1103
01:15:53,720 --> 01:15:56,150
So that's the two things that actually the paper discusses,

1104
01:15:56,360 --> 01:15:58,970
and what's sort of interesting and we'll see on Tuesday,

1105
01:15:59,090 --> 01:16:03,680
is this, this whole fork detection in fork resolution approach

1106
01:16:03,680 --> 01:16:05,960
is sort of a key problem basically in Bitcoin,

1107
01:16:06,920 --> 01:16:08,810
and we will talking Tuesday,

1108
01:16:08,810 --> 01:16:13,130
but Bitcoin you know we see a way basically to settle on the fork,

1109
01:16:15,650 --> 01:16:18,230
so even if the file system or the servers,

1110
01:16:18,230 --> 01:16:21,530
the Byzantine servers actually have created a fork,

1111
01:16:21,800 --> 01:16:24,560
you know Bitcoin basically has a way of deciding,

1112
01:16:24,560 --> 01:16:26,330
well, we're gonna reads the consensus

1113
01:16:26,330 --> 01:16:28,340
on like which fork we're going to actually proceed with.

1114
01:16:29,480 --> 01:16:32,960
So we'll leave that up to Tuesday,

1115
01:16:32,960 --> 01:16:38,120
but here sort of a connection between you know SUNDR and actually Bitcoin.

1116
01:16:40,940 --> 01:16:41,870
Any questions about this?

1117
01:16:50,050 --> 01:16:50,590
Okay.

1118
01:16:51,640 --> 01:16:53,170
Okay, I want to talk very quickly,

1119
01:16:53,170 --> 01:16:54,580
because I got three minutes left,

1120
01:16:54,610 --> 01:16:59,400
about the other,

1121
01:16:59,400 --> 01:17:01,590
so I think the key thing I'll get the paper is

1122
01:17:01,590 --> 01:17:04,350
actually this log conceptual view of the world,

1123
01:17:05,100 --> 01:17:08,160
of course the impractical as I mentioned earlier,

1124
01:17:08,310 --> 01:17:10,980
and so some directly has a proposal for how to do better,

1125
01:17:11,250 --> 01:17:14,760
even though like other systems like going actually do maintain the whole log,

1126
01:17:14,850 --> 01:17:18,030
and so what does somebody do things better,

1127
01:17:18,210 --> 01:17:19,800
instead of actually maintaining a log,

1128
01:17:19,800 --> 01:17:21,480
you know that's actually snapshots,

1129
01:17:22,240 --> 01:17:24,850
that's similar to sort of snapshots,

1130
01:17:24,850 --> 01:17:26,800
that we've seen before, in Raft,

1131
01:17:26,800 --> 01:17:30,340
where we construct the part of the world based on log,

1132
01:17:30,340 --> 01:17:31,420
we take a snapshot,

1133
01:17:31,420 --> 01:17:34,210
and that actually forms the the current state,

1134
01:17:34,390 --> 01:17:37,540
in fact, really what the SUNDR does,

1135
01:17:37,540 --> 01:17:39,580
it actually doesn't really literally make snapshot,

1136
01:17:39,580 --> 01:17:42,430
it really maintains a snapshot view of the file system,

1137
01:17:42,550 --> 01:17:43,720
and does it per user.

1138
01:17:46,200 --> 01:17:47,520
So one way to think about it is that,

1139
01:17:47,520 --> 01:17:49,920
that file systems is sharded by user,

1140
01:17:49,980 --> 01:17:52,980
every user has its own view snapshot of the world,

1141
01:17:53,310 --> 01:17:55,200
and you know there's a little bit of protocol

1142
01:17:55,200 --> 01:18:00,420
to make sure that these different snapshots and different users are actually consistent.

1143
01:18:00,420 --> 01:18:04,650
And let me talk a little bit about,

1144
01:18:04,710 --> 01:18:08,520
how actually SUNDR actually has makes the snapshot.

1145
01:18:10,050 --> 01:18:12,780
Basically in SUNDR,

1146
01:18:15,310 --> 01:18:17,860
and SUNDR basically there's something that's called the user i-handle,

1147
01:18:18,680 --> 01:18:22,880
and the user i-handle basically uniquely identifies snapshot in the file system,

1148
01:18:23,150 --> 01:18:27,250
and basically is a cryptographic hash of the i-table,

1149
01:18:27,250 --> 01:18:29,560
which completes all the inodes in the system,

1150
01:18:29,890 --> 01:18:33,190
and you know and for every inode,

1151
01:18:33,190 --> 01:18:34,330
there's a hash inode,

1152
01:18:34,330 --> 01:18:38,500
it would basically covers all the data, all the blocks belong to that particular inode,

1153
01:18:39,270 --> 01:18:45,960
so, for example, when say A modifies auth.py in my write one block,

1154
01:18:46,290 --> 01:18:50,160
the client re-computes the hash of this block,

1155
01:18:50,190 --> 01:18:55,260
updates the entry here, updates the entry here, updates the entry here,

1156
01:18:55,320 --> 01:18:57,240
and that's basically a new handle,

1157
01:18:57,420 --> 01:19:01,800
that describes basically the the capture you know the complete file system,

1158
01:19:02,070 --> 01:19:06,660
we're going to ignore the group in the directory block for a second,

1159
01:19:06,660 --> 01:19:09,990
so this basically gives you complete checkpoint,

1160
01:19:09,990 --> 01:19:14,460
where snapshot of user to view of the file system.

1161
01:19:16,780 --> 01:19:19,780
Now and then to deal with this issue,

1162
01:19:19,780 --> 01:19:23,740
of how to get a sort of consistency across users,

1163
01:19:24,070 --> 01:19:26,650
they have this notion of version vectors.

1164
01:19:33,840 --> 01:19:36,030
What version vector is pretty straightforward,

1165
01:19:36,630 --> 01:19:39,240
every version vector has an i-handle,

1166
01:19:39,240 --> 01:19:40,860
like A has i-handle is in it

1167
01:19:41,100 --> 01:19:46,900
after it modified say auth.py

1168
01:19:46,960 --> 01:19:49,960
and then for every user in the system,

1169
01:19:50,080 --> 01:19:53,260
the version vector has a counter for the number of modifications,

1170
01:19:53,260 --> 01:19:54,310
that were made by that user,

1171
01:19:54,400 --> 01:19:57,400
so if A made updated auth.py,

1172
01:19:57,610 --> 01:19:58,840
that counter is set to 1,

1173
01:19:59,110 --> 01:20:01,270
you know B didn't make any modifications,

1174
01:20:01,270 --> 01:20:02,890
you know C didn't make any modifications,

1175
01:20:03,190 --> 01:20:04,420
0 0,

1176
01:20:04,420 --> 01:20:06,130
and this whole thing is signed.

1177
01:20:09,620 --> 01:20:12,050
And so when B makes modifications,

1178
01:20:12,050 --> 01:20:13,640
so we use the version vector for B,

1179
01:20:14,240 --> 01:20:17,270
A version vector, B version vector,

1180
01:20:17,900 --> 01:20:19,340
it creates a new handle,

1181
01:20:20,030 --> 01:20:24,650
that includes of course all the modification, represents all the modifications,

1182
01:20:25,070 --> 01:20:26,480
and in its version handle,

1183
01:20:26,600 --> 01:20:28,220
it actually opened its version vector,

1184
01:20:28,250 --> 01:20:31,760
it includes which how many operations are read by a user,

1185
01:20:31,760 --> 01:20:33,020
so it will record the fact,

1186
01:20:33,020 --> 01:20:36,530
for example that it actually saw A's modification,

1187
01:20:36,800 --> 01:20:40,160
it updates B is to be 1, C is 0,

1188
01:20:40,370 --> 01:20:41,960
and basically signed to this whole thing.

1189
01:20:44,740 --> 01:20:49,300
You know C, when C actually does an operation,

1190
01:20:49,300 --> 01:20:51,400
want to read you know auth.py

1191
01:20:51,400 --> 01:20:57,220
and fetch you know and bank.py,

1192
01:20:57,280 --> 01:21:00,760
it basically downloads all the version vectors from every user,

1193
01:21:00,790 --> 01:21:02,590
you know and in this case,

1194
01:21:02,590 --> 01:21:05,230
it will get the version vector for A and B,

1195
01:21:06,250 --> 01:21:08,860
takes the latest one, which in this case is B,

1196
01:21:09,250 --> 01:21:12,730
because actually it includes all the operations of A in it,

1197
01:21:13,180 --> 01:21:16,000
and that's basically represented version of the file system,

1198
01:21:16,000 --> 01:21:20,920
from that version, it reads you know auth.py and bank.py,

1199
01:21:24,280 --> 01:21:27,400
note, you know that basically it's impossible for the server

1200
01:21:27,640 --> 01:21:34,420
to basically present bank.py, not auth.py,

1201
01:21:34,420 --> 01:21:36,160
because you know it cannot,

1202
01:21:36,250 --> 01:21:39,640
you know it can only to sort of version vector can return is,

1203
01:21:39,640 --> 01:21:41,590
this version vector or this version vector,

1204
01:21:41,710 --> 01:21:46,690
version vector A doesn't include actually the changes of bank.py,

1205
01:21:46,870 --> 01:21:50,350
if C actually does get versions of bank.py,

1206
01:21:50,500 --> 01:21:54,520
it must actually have the versions, the modification A is made,

1207
01:21:54,790 --> 01:21:56,980
because the version vectors are constructed in that way.

1208
01:21:58,840 --> 01:22:03,100
And so that's basically the way for using version vectors

1209
01:22:03,160 --> 01:22:07,600
to detect the S doesn't drop changes,

1210
01:22:07,720 --> 01:22:10,540
as we as the same way that the logging system is done.

1211
01:22:12,120 --> 01:22:14,370
Okay, so that's the essence of the version vector plan.

1212
01:22:16,770 --> 01:22:18,480
So, summary.

1213
01:22:22,870 --> 01:22:28,330
Okay, Byzantine participants you know sort of a problem

1214
01:22:28,330 --> 01:22:31,960
you have to handle in decentralized systems,

1215
01:22:34,040 --> 01:22:37,640
because there's no single institution that sort of,

1216
01:22:37,640 --> 01:22:39,290
it can be source of trust,

1217
01:22:40,520 --> 01:22:42,650
and we've seen this notion of signed logs,

1218
01:22:42,800 --> 01:22:48,830
it's a very powerful tool to deal with malicious servers.

1219
01:22:49,490 --> 01:22:52,670
And, as I said, on on Tuesday,

1220
01:22:52,670 --> 01:22:54,350
we're going to continue this discussion,

1221
01:22:54,560 --> 01:22:58,880
and you'll see how this design logs are used in Bitcoin,

1222
01:22:58,940 --> 01:23:01,130
in particular like how fork consistency,

1223
01:23:01,130 --> 01:23:05,210
where how the fact that forks are sort of being created,

1224
01:23:05,240 --> 01:23:07,910
are being resolved in the case of Bitcoin.

1225
01:23:08,700 --> 01:23:12,900
Okay, so that was it for an introduction to the decentralized systems,

1226
01:23:13,230 --> 01:23:17,880
and I hope the paper a little bit more understandable,

1227
01:23:17,880 --> 01:23:23,130
than maybe when before you start reading it earlier this week or today.

1228
01:23:23,530 --> 01:23:25,510
Okay, see you on Tuesday.

1229
01:23:26,960 --> 01:23:31,130
And of course, there's questions, feel free, please feel free to hang around,

1230
01:23:31,400 --> 01:23:34,670
if you need to go somewhere else, absolutely go somewhere else.

1231
01:23:36,020 --> 01:23:38,720
I have a question about the data structure,

1232
01:23:38,720 --> 01:23:42,650
that they use the B+ tree or whatever,

1233
01:23:42,650 --> 01:23:45,020
like what's the difference between that and like,

1234
01:23:45,930 --> 01:23:48,330
yeah, like the Merkle, for example.

1235
01:23:48,450 --> 01:23:49,710
Using Merkle data structure,

1236
01:23:49,920 --> 01:23:54,810
you know I think the person who sort of credited with his id is Merkle,

1237
01:23:55,360 --> 01:23:58,150
and that's why it called the Merkle data tree?

1238
01:24:00,180 --> 01:24:01,620
So this is the same thing?

1239
01:24:03,180 --> 01:24:03,750
Okay.

1240
01:24:04,230 --> 01:24:05,790
SUNDR basically uses a Merkle tree.

1241
01:24:11,900 --> 01:24:18,010
Sorry, when when you are verifying the the signatures,

1242
01:24:18,250 --> 01:24:19,330
doesn't mean you have to,

1243
01:24:19,330 --> 01:24:22,520
like, basically, as you go,

1244
01:24:22,520 --> 01:24:25,820
if you're a hundred entries into the log,

1245
01:24:26,210 --> 01:24:31,400
you have to compute the hash of all the 100 entries

1246
01:24:31,400 --> 01:24:34,780
concatenated and then compute, and.

1247
01:24:34,780 --> 01:24:36,790
Yeah, you need to keep a running hash,

1248
01:24:36,820 --> 01:24:38,410
okay, let's go back to verify,

1249
01:24:45,650 --> 01:24:47,870
okay, so here is probably a good place to talk about it.

1250
01:24:48,580 --> 01:24:52,880
So, so here,

1251
01:24:53,410 --> 01:24:56,080
so let's say, let's take the last entry, correct,

1252
01:24:57,560 --> 01:25:02,390
the last entry will have a hash of the preceding entries,

1253
01:25:03,890 --> 01:25:06,350
so everything you know from the like whatever records,

1254
01:25:06,470 --> 01:25:10,640
let's say this is 0 1 and 2, 0 1 and 2,

1255
01:25:12,000 --> 01:25:18,500
where basically has the hash of the previous entry number 2 in it,

1256
01:25:18,500 --> 01:25:21,890
and that needs to be, that needs to be checked.

1257
01:25:22,640 --> 01:25:27,440
And the way that being checked is,

1258
01:25:27,440 --> 01:25:30,590
you know in principle, if you start really from the beginning of the world,

1259
01:25:30,800 --> 01:25:33,470
and you would have to compute the hash with record 0,

1260
01:25:33,590 --> 01:25:34,940
you find out what the hash is,

1261
01:25:35,240 --> 01:25:40,550
and double check that corresponds to the entry,

1262
01:25:40,550 --> 01:25:44,490
that's in here and that the signature is valid, etc, etc.

1263
01:25:46,160 --> 01:25:47,990
Of course, you know in the real system,

1264
01:25:47,990 --> 01:25:49,610
you can remember most of the log

1265
01:25:50,000 --> 01:25:51,560
and just double check that,

1266
01:25:51,560 --> 01:25:53,630
like whatever and start from there.

1267
01:25:56,140 --> 01:25:58,920
Oh, it's inefficient, okay.

1268
01:25:59,530 --> 01:26:01,300
Yeah, you have to replay from the beginning of time,

1269
01:26:01,300 --> 01:26:04,270
you basically have to really validate the whole log from the beginning of time.

1270
01:26:06,760 --> 01:26:08,290
Thank you, it makes sense.

1271
01:26:08,350 --> 01:26:10,120
You'll see this in the Bitcoin paper.

1272
01:26:11,040 --> 01:26:15,030
So are the hash is like, almost like a Merkle chain, like.

1273
01:26:15,030 --> 01:26:15,510
Yes.

1274
01:26:15,900 --> 01:26:16,500
Okay.

1275
01:26:17,010 --> 01:26:17,760
Same idea.

1276
01:26:18,780 --> 01:26:20,880
So, are they,

1277
01:26:22,870 --> 01:26:29,650
like if like leaf in the sort of tree or chain,

1278
01:26:29,680 --> 01:26:32,920
like an entire file or like blocks of a file.

1279
01:26:32,950 --> 01:26:34,210
This is a block, one block,

1280
01:26:34,210 --> 01:26:36,370
so this 4096 bytes,

1281
01:26:43,680 --> 01:26:45,300
and all the other hashes don't change, correct,

1282
01:26:45,300 --> 01:26:47,580
so it's actually not that inefficient.

1283
01:26:48,150 --> 01:26:50,010
Because if you only change part of the file,

1284
01:26:50,010 --> 01:26:51,510
that only rehashes that part.

1285
01:26:51,540 --> 01:26:52,740
Yeah, you just have to rehash that one,

1286
01:26:52,740 --> 01:26:55,260
and then you have to re-compute the hash of the tree,

1287
01:26:56,590 --> 01:26:58,090
all the way to the users i-handle.

1288
01:27:02,760 --> 01:27:03,570
The paper talks about,

1289
01:27:03,570 --> 01:27:06,180
there's a sort of optimization to make this more efficient,

1290
01:27:06,240 --> 01:27:09,000
but hashing is generally not that expensive,

1291
01:27:09,000 --> 01:27:11,250
signing is a more expensive operation.

1292
01:27:18,480 --> 01:27:20,190
I had a question about version vectors,

1293
01:27:21,270 --> 01:27:23,010
so we use version vectors

1294
01:27:23,010 --> 01:27:25,560
to make sure that the system can't return like an old state,

1295
01:27:25,800 --> 01:27:29,850
why can't the, why can't the system just return the old state and the old version vector,

1296
01:27:29,850 --> 01:27:31,470
if it keeps a second copy.

1297
01:27:32,040 --> 01:27:34,210
Yeah, got fork, right?

1298
01:27:34,210 --> 01:27:36,370
So we only have fork consistency, then.

1299
01:27:36,520 --> 01:27:38,950
Yeah, version vectors only fork consistent,

1300
01:27:39,220 --> 01:27:40,930
SUNDR fork consistent, no more.

1301
01:27:47,460 --> 01:27:50,100
So fork consistency, you need the timestamp?

1302
01:27:50,530 --> 01:27:52,330
The fork consistency, I mean,

1303
01:27:52,360 --> 01:27:59,680
you know the server can fork the log at any particular point in time,

1304
01:28:00,900 --> 01:28:05,550
present a consistent view of the what they can merge logs back together.

1305
01:28:07,850 --> 01:28:10,430
So, really this picture,

1306
01:28:11,290 --> 01:28:15,970
that the server can actually construct you know different views of the world,

1307
01:28:16,210 --> 01:28:18,910
and split you know the world, the multiple world,

1308
01:28:19,210 --> 01:28:24,450
but can emerge the world back together undetectably.

1309
01:28:27,170 --> 01:28:31,520
So, the best we can do is fork consistency,

1310
01:28:31,610 --> 01:28:33,200
which allows for forking,

1311
01:28:33,260 --> 01:28:34,850
but we can detect forking.

1312
01:28:36,090 --> 01:28:37,620
So if we detect forking,

1313
01:28:38,360 --> 01:28:40,970
can we then get something stronger than fork consistency?

1314
01:28:40,970 --> 01:28:43,640
Well, yep, well, we can settle on a fork,

1315
01:28:43,820 --> 01:28:44,870
we're gonna have forks,

1316
01:28:44,960 --> 01:28:48,560
we can try to settle like pick one forks one to go forward with.

1317
01:28:49,540 --> 01:28:50,320
Okay,

1318
01:28:51,370 --> 01:28:54,310
but SUNDR doesn't have a way to do that.

1319
01:29:00,230 --> 01:29:04,010
I mean SUNDR does propose some some methods now?

1320
01:29:04,340 --> 01:29:05,600
Methods to detect

1321
01:29:05,630 --> 01:29:11,420
and basically you know basically proposes like you use the timestamp box to use that one.

1322
01:29:17,210 --> 01:29:17,870
Thanks.

1323
01:29:18,200 --> 01:29:18,740
You're welcome.

1324
01:29:20,740 --> 01:29:25,660
The timestamp, timestamp box just a server that appends entries?

1325
01:29:25,660 --> 01:29:30,100
Yeah, and is trusted, it was not under control of the adversary.

1326
01:29:35,380 --> 01:29:36,100
Thank you.

1327
01:29:38,150 --> 01:29:40,490
Can I also ask one final question

1328
01:29:40,490 --> 01:29:43,250
about the Debian example, you set up in beginning,

1329
01:29:43,730 --> 01:29:46,970
can you say again what happened there?

1330
01:29:47,120 --> 01:29:48,230
Yeah, sure,

1331
01:29:48,830 --> 01:29:51,230
so basically the,

1332
01:29:51,290 --> 01:29:58,040
this is the source repo or develop machines for Debian Linux in 2003,

1333
01:29:58,040 --> 01:30:03,590
an attacker compromised broke into this machines and modified files,

1334
01:30:05,430 --> 01:30:07,890
and this is the distribution that has been sort of handed off,

1335
01:30:07,890 --> 01:30:09,960
you know which you know if you're on Debian Linux,

1336
01:30:09,960 --> 01:30:11,040
you know you're you're,

1337
01:30:11,660 --> 01:30:15,050
anybody who got like the Debian linux after attack,

1338
01:30:15,050 --> 01:30:17,150
you've got maybe a compromise Debian Linux.

1339
01:30:17,870 --> 01:30:19,730
And so when they soon as they discovered this,

1340
01:30:19,730 --> 01:30:22,610
they didn't do any further development,

1341
01:30:22,940 --> 01:30:24,440
and they were defer to distributions,

1342
01:30:24,440 --> 01:30:26,840
sorted out like they went to backups,

1343
01:30:26,840 --> 01:30:31,250
you know started comparing files from backups with files that they have,

1344
01:30:31,250 --> 01:30:34,010
and you know basically double check that all the changes

1345
01:30:34,010 --> 01:30:36,500
that were in the repo are actually legit.

1346
01:30:38,170 --> 01:30:38,500
Okay.

1347
01:30:38,500 --> 01:30:40,780
Rollback and rollback any changes are not legit.

1348
01:30:42,400 --> 01:30:44,620
That's pretty bad.

1349
01:30:44,770 --> 01:30:46,600
Yeah, that's pretty bad,

1350
01:30:46,600 --> 01:30:47,560
it occasionally happens,

1351
01:30:47,560 --> 01:30:48,490
this is a real problem,

1352
01:30:49,760 --> 01:30:51,020
that's a real problem in practice.

1353
01:30:52,330 --> 01:30:55,000
Thank you so much that was very interesting lecture, thank you.

1354
01:30:55,000 --> 01:30:55,450
You're welcome.

1355
01:30:56,910 --> 01:30:57,600
Thank you.

