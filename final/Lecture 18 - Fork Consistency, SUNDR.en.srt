1
00:00:01,290 --> 00:00:05,680
Okay, good afternoon, can everybody hear me?

2
00:00:08,160 --> 00:00:08,820
Yep.

3
00:00:09,130 --> 00:00:10,090
Okay, thank you,

4
00:00:10,360 --> 00:00:13,390
yes I will post the lecture notes at the end of lecture,

5
00:00:14,320 --> 00:00:18,240
response to the chat.

6
00:00:18,330 --> 00:00:27,400
Okay, so, today basically I want to start a new topic in in 6.824,

7
00:00:27,580 --> 00:00:31,270
and sort of last topic that will be discussing,

8
00:00:31,510 --> 00:00:33,790
the topic is really decentralized systems.

9
00:00:45,490 --> 00:00:49,360
And these are typically decentralized really refers to the fact,

10
00:00:49,360 --> 00:00:53,590
that there's no single authority that is in control of the system,

11
00:00:54,320 --> 00:00:56,750
a lot of the systems that we've seen so far,

12
00:00:56,930 --> 00:00:59,870
all the machines and servers sort of cooperate

13
00:01:00,110 --> 00:01:05,030
and on the under control of a single institution or any single authority.

14
00:01:05,850 --> 00:01:09,030
And systems are a lot of you ask questions,

15
00:01:09,030 --> 00:01:10,500
about like how would it work,

16
00:01:10,500 --> 00:01:13,920
if there's no central point of trust.

17
00:01:14,770 --> 00:01:20,720
And so, from now on, the three systems or three papers were going to be discussing,

18
00:01:20,720 --> 00:01:23,210
all sit in this form of decentralized systems

19
00:01:23,420 --> 00:01:30,230
and decentralized systems are harder to build than the sort of single trust systems,

20
00:01:30,650 --> 00:01:36,920
because you know you might have to account for byzantine failures or byzantine participants.

21
00:01:45,540 --> 00:01:48,810
And these are participants that you know sometimes follow the protocol

22
00:01:48,810 --> 00:01:50,370
and sometimes they don't follow the protocol,

23
00:01:50,970 --> 00:01:52,890
so again they really they think about it,

24
00:01:52,890 --> 00:01:54,540
they are basically adversaries,

25
00:01:54,780 --> 00:02:02,820
and they may try to abuse or trick other participants in systems,

26
00:02:02,820 --> 00:02:05,220
you know for their own goods, but not maybe for others.

27
00:02:05,800 --> 00:02:10,930
And so that makes actually system design,

28
00:02:10,930 --> 00:02:13,630
which distributed system designs much more challenging

29
00:02:13,660 --> 00:02:15,610
and much more difficult to reason about,

30
00:02:16,030 --> 00:02:19,510
[] feel like in the last you know 18 whatever lectures,

31
00:02:19,720 --> 00:02:24,520
mostly when we talk about, when we design protocol or we thought about raft,

32
00:02:24,730 --> 00:02:29,950
and we just assume that actually every participant in the protocol follows the rules

33
00:02:30,400 --> 00:02:34,480
and in the byzantine with byzantine participants, that is not the case anymore,

34
00:02:35,440 --> 00:02:37,840
you know the participants can cook up new messages,

35
00:02:37,840 --> 00:02:39,580
you know send messages out of order,

36
00:02:39,580 --> 00:02:42,010
trick other participants

37
00:02:42,310 --> 00:02:46,930
and so the we thinking about those kind of protocols is much more difficult,

38
00:02:46,990 --> 00:02:51,150
because we have to consider what, what the adversary could do,

39
00:02:51,210 --> 00:02:57,400
to sort of make our life to break basically the properties of the protocols, that we're shooting for,

40
00:02:58,000 --> 00:03:00,610
so this tends to be made the problem much harder.

41
00:03:03,790 --> 00:03:08,140
And really you know where what this sort of topic is,

42
00:03:08,140 --> 00:03:11,860
so sits on the intersection of distributed systems and security.

43
00:03:16,120 --> 00:03:20,740
And as we'll see in the next this the next three papers,

44
00:03:21,160 --> 00:03:23,710
you know cryptography or security ideas,

45
00:03:23,710 --> 00:03:24,970
like signing and hashing

46
00:03:24,970 --> 00:03:29,680
and are going to play a crucial role to actually make [forward] progress.

47
00:03:31,140 --> 00:03:34,320
In fact, you know the paper actually that we're reading for today is also

48
00:03:34,320 --> 00:03:37,500
is a paper that we use in the 6.858,

49
00:03:38,250 --> 00:03:41,400
taking maybe 6.858 last Spring,

50
00:03:41,580 --> 00:03:44,040
we talked about this paper too,

51
00:03:44,040 --> 00:03:46,800
although then for mostly from the perspective of security

52
00:03:46,890 --> 00:03:52,500
and today I'm going to mostly focuses on the perspective of distributed systems,

53
00:03:53,100 --> 00:03:58,290
the SUNDR itself, a lot of people ask,

54
00:03:58,320 --> 00:04:02,520
a lot of you ask you know SUNDR being used,

55
00:04:02,520 --> 00:04:04,230
and as far as I know,

56
00:04:04,230 --> 00:04:10,650
there's actually no systems that actually implement SUNDR directly or based directly based SUNDR,

57
00:04:10,740 --> 00:04:14,760
other than lab 4 in 6.858,

58
00:04:14,820 --> 00:04:20,670
in lab 4, what if you do lab 4, the default project,

59
00:04:20,670 --> 00:04:22,050
lab 4 at 6.858,

60
00:04:22,170 --> 00:04:24,840
then you actually implement SUNDR.

61
00:04:26,000 --> 00:04:32,090
Now, the reason, so you might wonder why we are studying this paper at all,

62
00:04:32,270 --> 00:04:33,350
the reason we're studying it,

63
00:04:33,350 --> 00:04:37,040
because it actually proposes a number of very powerful, techniques are powerful ideas.

64
00:04:40,400 --> 00:04:42,860
and so particularly the signed log,

65
00:04:43,640 --> 00:04:47,720
even though is a strong design conceptual design,

66
00:04:47,990 --> 00:04:50,000
is incredibly powerful

67
00:04:50,180 --> 00:04:55,610
and you see back same idea appear in lots of other decentralized systems,

68
00:04:55,880 --> 00:05:01,280
you know ranging from systems like git to you know systems like Bitcoin

69
00:05:01,280 --> 00:05:03,530
or any other sort of cryptographic ledger,

70
00:05:03,770 --> 00:05:07,430
we're gonna be talking about Monday or next Tuesday,

71
00:05:07,610 --> 00:05:13,880
I know one system actually is directly influenced by SUNDR,

72
00:05:13,880 --> 00:05:15,650
which is a system called keybase,

73
00:05:16,430 --> 00:05:20,090
I mean keybase uses SUNDR techniques,

74
00:05:20,090 --> 00:05:22,190
and and many more,

75
00:05:22,190 --> 00:05:23,990
if you're not familiar with keybase,

76
00:05:23,990 --> 00:05:26,870
actually was originally acquired by zoom,

77
00:05:27,500 --> 00:05:29,630
which was only all familiar with.

78
00:05:32,180 --> 00:05:36,950
Okay, so that's sort of for the quick intro to this paper,

79
00:05:37,040 --> 00:05:39,230
before I dive into more of the setting,

80
00:05:39,230 --> 00:05:44,060
any sort of questions before diving a little bit deeper in the paper.

81
00:05:50,710 --> 00:05:52,360
Okay.

82
00:05:52,950 --> 00:05:59,670
So let's talk a little bit about the setting of this paper or the motivation of this paper.

83
00:05:59,670 --> 00:06:07,050
So the setting in the [hour] that the [officer] set forward is a network file system,

84
00:06:11,240 --> 00:06:16,820
and, you can think about this a little bit in the style of earlier paper,

85
00:06:16,820 --> 00:06:19,250
that we've read Frangipani,

86
00:06:19,430 --> 00:06:24,170
where the topic also was to implement and consistent network file system.

87
00:06:25,070 --> 00:06:27,590
So we have a file server,

88
00:06:30,770 --> 00:06:33,770
we have clients that interact with the file server,

89
00:06:34,850 --> 00:06:37,280
somebody might actually create a file f,

90
00:06:39,470 --> 00:06:43,220
and maybe read f on another client.

91
00:06:45,860 --> 00:06:49,520
And you know the setting we're in,

92
00:06:49,520 --> 00:06:54,950
is that basically the file server as opposed to in the Frangipani,

93
00:06:55,100 --> 00:06:57,950
the file server are actually can be Byzantine.

94
00:07:02,790 --> 00:07:07,290
And Byzantine really increasing extremely powerful threat model

95
00:07:07,290 --> 00:07:10,560
or you know gives the attacker an incredible amount of power.

96
00:07:10,920 --> 00:07:16,140
So in Byzantine you know the server might send different RPCs back,

97
00:07:16,140 --> 00:07:25,470
you cook up its own RPCs, the the, takeover the machine,

98
00:07:25,470 --> 00:07:27,240
you know bribe the administrator

99
00:07:27,240 --> 00:07:30,810
and for everything is basically the way to think about is that,

100
00:07:31,110 --> 00:07:34,290
the adversary gets complete control of the file server.

101
00:07:36,130 --> 00:07:42,010
And so this covers sort of wide range of you know sort of more common attacks

102
00:07:42,010 --> 00:07:45,010
or like the typical attacks you might see in a real system,

103
00:07:45,010 --> 00:07:47,890
so real attacks one bug in software,

104
00:07:51,920 --> 00:07:54,680
so if you know there's a bug in the software,

105
00:07:54,680 --> 00:07:56,630
then you know the adversary can exploit,

106
00:07:56,630 --> 00:08:03,800
that [] maybe to obtain privileges and you know that Byzantine model,

107
00:08:03,800 --> 00:08:07,550
you know completely compasses that organise system,

108
00:08:07,550 --> 00:08:14,750
administrator might have a weak, with weak password,

109
00:08:16,460 --> 00:08:20,540
if the attacker compromises and then they take control over the system,

110
00:08:20,540 --> 00:08:23,780
you know that's also covered by Byzantine physical breaking,

111
00:08:28,150 --> 00:08:32,500
maybe the attacker rangers you know get access to the physical machine,

112
00:08:32,770 --> 00:08:38,200
and you know can therefore control the physical part of the machine,

113
00:08:38,290 --> 00:08:41,320
again it's all covered by this you know Byzantine threat model

114
00:08:41,710 --> 00:08:51,690
or even you know, maybe you know the the attacker bribes an operator

115
00:08:54,540 --> 00:08:59,760
or colludes you know with a malicious client,

116
00:08:59,760 --> 00:09:01,710
you know that is also covered by this model,

117
00:09:01,770 --> 00:09:02,910
so this is a threat model,

118
00:09:02,910 --> 00:09:07,290
that is a very very gives a lot of power to the adversary,

119
00:09:08,060 --> 00:09:09,920
it covers a lot of standard attacks.

120
00:09:10,400 --> 00:09:13,940
And and you know the first thing sort of observed,

121
00:09:13,940 --> 00:09:20,570
you know again that SUNDR place is that,

122
00:09:20,660 --> 00:09:25,970
instead of actually you know sort of maintaining the whole file system on the file server,

123
00:09:25,970 --> 00:09:28,190
the file server is as simple as possible,

124
00:09:28,670 --> 00:09:32,690
and in fact you know the file servers very much like almost like Pedal,

125
00:09:32,930 --> 00:09:35,600
it's almost like a block device with a little bit more.

126
00:09:39,120 --> 00:09:42,180
So there's a central place where all the blocks are stored

127
00:09:43,200 --> 00:09:47,040
and but the clients really implement the file system,

128
00:09:47,040 --> 00:09:51,930
so it's not really, you know that the client sends, create for file actually,

129
00:09:52,360 --> 00:09:57,260
you know sends blocks and reads blocks, from the block server

130
00:09:57,530 --> 00:10:02,330
and basically constructs you know from the blocks with reads or writes,

131
00:10:02,330 --> 00:10:04,550
you know its own view of the file system

132
00:10:04,550 --> 00:10:07,130
and serve a file system operations,

133
00:10:07,130 --> 00:10:08,750
basically on the straight on the client

134
00:10:08,990 --> 00:10:15,200
and so here really, we create you know f, read f etc.

135
00:10:16,430 --> 00:10:18,860
So very very similar to the Frangipani,

136
00:10:19,280 --> 00:10:24,200
except the big difference of Frangipani is that Pedal and all clients were completely trusted.

137
00:10:24,530 --> 00:10:25,850
And in this setting,

138
00:10:26,030 --> 00:10:27,470
the clients are not trusted

139
00:10:27,680 --> 00:10:33,380
and the file servers, it can be also, is also not trusted.

140
00:10:34,140 --> 00:10:34,680
Okay?

141
00:10:41,410 --> 00:10:46,690
Okay, so the paper focused on a particular set of security properties,

142
00:10:46,930 --> 00:10:57,840
and focus is really on, the focus is on what's called integrity properties.

143
00:11:00,550 --> 00:11:02,950
And in contrast to confidentiality,

144
00:11:03,040 --> 00:11:05,590
confidentiality about protecting data from them,

145
00:11:05,590 --> 00:11:06,850
so that nobody else can read it,

146
00:11:07,150 --> 00:11:11,770
integrity is just ensuring that the system structure is correct

147
00:11:11,770 --> 00:11:16,660
and the modifications, illegal modifications to the data are being detected

148
00:11:16,750 --> 00:11:18,460
and whether the data is public or not public,

149
00:11:18,460 --> 00:11:20,590
you know that sort of besides the point here.

150
00:11:21,330 --> 00:11:23,670
To make a little bit more concrete,

151
00:11:23,670 --> 00:11:27,450
you know there sort of, the thing that happens in our minds is,

152
00:11:27,450 --> 00:11:29,580
we have a set of, we have developers,

153
00:11:32,410 --> 00:11:36,310
you know we have dev1, you know dev2,

154
00:11:36,730 --> 00:11:39,820
they may share some machine,

155
00:11:39,850 --> 00:11:45,760
that contains the source code repository of some source of project,

156
00:11:45,760 --> 00:11:48,700
the developers you know are collaborating on that project,

157
00:11:49,090 --> 00:11:53,860
and and so think about this as a example,

158
00:11:53,860 --> 00:11:55,000
the paper mentions is,

159
00:11:55,000 --> 00:11:58,210
in the paper maybe this is the development machines

160
00:11:58,210 --> 00:12:01,390
and the server for a debian Linux

161
00:12:02,500 --> 00:12:08,440
and what they want to again, defend against is trap or trapdoor,

162
00:12:11,900 --> 00:12:13,280
you know trapdoor in the software.

163
00:12:16,890 --> 00:12:22,170
So the you know the attacker, you know takes over control,

164
00:12:22,170 --> 00:12:25,800
breaks into the machine, that contains the source repo,

165
00:12:25,830 --> 00:12:28,680
modifies the software [noticed]

166
00:12:28,920 --> 00:12:31,710
and then it's going out of that software gets deployed,

167
00:12:31,740 --> 00:12:34,560
you know for example debian Linux gets deployed to lots of machines

168
00:12:34,980 --> 00:12:40,560
and now the attacker has control over those machines,

169
00:12:40,590 --> 00:12:42,570
because it's gonna exploit the trapdoor.

170
00:12:43,210 --> 00:12:46,330
The the paper talks about this attack,

171
00:12:46,360 --> 00:12:50,470
this particular instance in debian Linux in 2003,

172
00:12:50,590 --> 00:12:58,750
where the attack was able to compromise you know the development server or cluster,

173
00:12:59,110 --> 00:13:02,830
in recovering from these kinds of attacks very painful,

174
00:13:02,920 --> 00:13:05,530
in fact in 2003 you know they report,

175
00:13:05,530 --> 00:13:09,790
that the debian Linux which froze development for a couple days,

176
00:13:09,790 --> 00:13:15,070
and while they were trying to sort out which parts of their source repo was still correct

177
00:13:15,070 --> 00:13:17,680
and which parts were actually modified by the attacker

178
00:13:18,250 --> 00:13:20,770
and these attacks happens periodically,

179
00:13:20,770 --> 00:13:27,700
I think last year you know Ubuntu had a similar type of problem in in 2018 or 2019,

180
00:13:27,700 --> 00:13:28,840
I can't remember exactly,

181
00:13:29,020 --> 00:13:30,580
and it was a similar case,

182
00:13:30,580 --> 00:13:36,790
where one of the core development servers was broken into,

183
00:13:37,440 --> 00:13:39,480
you know they have to sort out,

184
00:13:39,720 --> 00:13:46,980
what we're see which software which files got infected and affected by that breaking.

185
00:13:48,510 --> 00:13:52,710
Okay, so that's sort of the setting of the paper,

186
00:13:52,710 --> 00:13:54,690
and I'm going to make a little bit more concrete,

187
00:13:54,720 --> 00:13:56,460
a little bit of a toy example,

188
00:13:56,550 --> 00:14:01,470
to help us, you know go through the techniques, that this paper actually uses.

189
00:14:03,420 --> 00:14:06,240
So the example that I'm gonna use,

190
00:14:06,810 --> 00:14:10,260
partially inspired by 6.858,

191
00:14:10,440 --> 00:14:14,220
is, let's say you know we have a file system,

192
00:14:14,760 --> 00:14:17,700
there's, you're doing the,

193
00:14:18,880 --> 00:14:26,950
and the file system contains you know the source code for this application of using 6.858 zoobar

194
00:14:26,950 --> 00:14:32,110
and zoobar is a sort of a virtual bank type application,

195
00:14:32,110 --> 00:14:38,650
where users of the system, registered users of the system can transfer zoobars to each other

196
00:14:39,100 --> 00:14:44,800
and so it has a file called auth.py, you know does authentication

197
00:14:45,220 --> 00:14:49,930
and that's a file that basically you know influence bank, bank.py.

198
00:14:51,170 --> 00:14:58,970
And, so, let's consider the case where a you have a new set of developers, A B and C

199
00:14:59,240 --> 00:15:05,060
and they decided that they wanted to increase the usability of zoobar,

200
00:15:05,210 --> 00:15:08,360
actually deployed for real and make it real,

201
00:15:08,360 --> 00:15:11,300
basically you know they decide to divide the work as follows,

202
00:15:11,480 --> 00:15:27,020
A, is gonna modify auth.py to support MIT certificates or MIT certs,

203
00:15:28,630 --> 00:15:31,090
kerberos tickets or certificates,

204
00:15:31,360 --> 00:15:35,050
and with the idea that, what we're gonna do is,

205
00:15:36,220 --> 00:15:39,040
we're gonna auth.py is going to be modified,

206
00:15:39,040 --> 00:15:45,280
so that only legit MIT community members actually can log into the file server,

207
00:15:45,520 --> 00:15:47,530
file server or into zoobar,

208
00:15:47,590 --> 00:15:50,350
instead we actually know who it actually really is,

209
00:15:50,410 --> 00:15:53,320
that is associated with that particular MIT certificate

210
00:15:53,920 --> 00:15:55,930
and then you have to make a little bit more useful.

211
00:15:55,930 --> 00:16:04,760
You know B can actually modify the bank.py to actually link it you know to cash tag for techcash.

212
00:16:06,380 --> 00:16:12,620
And so, you know the idea that basically we can actually use this zoobar system do that,

213
00:16:12,620 --> 00:16:16,700
like we can use the zoobar system to actually transfer money,

214
00:16:16,700 --> 00:16:19,160
you know real money instead of zoobars,

215
00:16:19,220 --> 00:16:24,710
between users that are registered with this servers,

216
00:16:25,040 --> 00:16:26,750
that this sounds of course like a crazy idea,

217
00:16:26,750 --> 00:16:27,740
you don't really do it,

218
00:16:27,740 --> 00:16:29,960
but it's not completely ridiculous,

219
00:16:29,960 --> 00:16:34,190
you know, because you know the auth.py really checks who would actually is

220
00:16:34,310 --> 00:16:36,170
based on the MIT certificate

221
00:16:36,470 --> 00:16:41,990
and so maybe it's not unreasonable that we could connect you know bank.py to actually techcash.

222
00:16:43,750 --> 00:16:48,250
And then basically C in our scenario is going to be that person,

223
00:16:48,250 --> 00:16:49,870
that's actually going to deploy the software,

224
00:16:53,880 --> 00:16:57,030
find machine takes software installs it and runs it

225
00:16:57,390 --> 00:17:00,330
and it opens it up to the MIT community.

226
00:17:00,860 --> 00:17:03,620
Now, in the case,

227
00:17:03,620 --> 00:17:07,550
now let's consider what you know what could happen, what could go wrong,

228
00:17:07,850 --> 00:17:10,760
if actually the file server was compromised

229
00:17:10,760 --> 00:17:12,110
and so was byzantine.

230
00:17:16,640 --> 00:17:22,490
Well, the obvious you know problems, a couple of obvious problems, you know bad outcomes possible,

231
00:17:23,420 --> 00:17:25,010
let's consider them,

232
00:17:27,820 --> 00:17:31,480
you know that outcome one which is the one thing we should be talking about

233
00:17:31,480 --> 00:17:32,950
and also in the previous examples,

234
00:17:33,250 --> 00:17:37,300
it is basically the adversary gives arbitrary code to C,

235
00:17:38,540 --> 00:17:50,450
adversary provides own code to C.

236
00:17:53,430 --> 00:17:59,880
And you know that sort of maybe that adversary slightly subtle about it or clever about it,

237
00:17:59,880 --> 00:18:02,640
you know whatever makes it a little bit hard to spot,

238
00:18:02,640 --> 00:18:07,650
then actually modified auth.py for example to delete the MIT certificates,

239
00:18:08,010 --> 00:18:11,160
but they're basically you know there's really no way for C to check,

240
00:18:11,400 --> 00:18:14,580
that actually got the software that A and B produced

241
00:18:14,580 --> 00:18:17,490
and without any modifications from the adversary.

242
00:18:17,490 --> 00:18:20,430
So that's sort of the obvious problem we're going to talk a lot about,

243
00:18:20,430 --> 00:18:24,780
it there's a second sort of that outcome which may be a little more subtle,

244
00:18:25,410 --> 00:18:35,320
which is that the adversary provides the changes you know to bank.py,

245
00:18:37,960 --> 00:18:44,900
without changes to auth.py.

246
00:18:47,970 --> 00:18:51,120
And so at this point,this is pretty problematic, correct,

247
00:18:51,120 --> 00:18:54,120
because you know bank.py link to techcash now,

248
00:18:54,390 --> 00:18:59,130
but we actually don't have appropriate authentication to users anymore,

249
00:18:59,340 --> 00:19:05,070
in fact anybody that actually creates zoobar account can now actually interact with the techcash,

250
00:19:05,550 --> 00:19:11,460
and so you know clearly very very undesirable, and harder to spot,

251
00:19:11,610 --> 00:19:15,810
because basically the adversary actually doesn't really modify any software,

252
00:19:15,810 --> 00:19:19,350
just selectively you know presents you take pieces of it

253
00:19:19,350 --> 00:19:22,830
and present that to see who then actually goes off and deployed.

254
00:19:24,610 --> 00:19:34,540
And so it's really you know the attacks the paper considers of course the attack number one to two,

255
00:19:34,780 --> 00:19:39,520
but there are a lot of some of the subtle issues actually are brought out by the second case,

256
00:19:39,520 --> 00:19:41,080
that will be talking about.

257
00:19:44,250 --> 00:19:45,510
Any questions so far,

258
00:19:47,950 --> 00:19:50,440
you know about the setting by the motivation,

259
00:19:53,220 --> 00:19:55,950
before we're going to try to discuss solutions.

260
00:19:57,080 --> 00:19:59,210
So the problem with the second case is that

261
00:19:59,270 --> 00:20:05,210
the user that the authentication does not authenticate.

262
00:20:05,420 --> 00:20:08,240
Yeah, it doesn't use MIT certificates anymore

263
00:20:08,600 --> 00:20:10,730
and so we don't really know actually who logs in.

264
00:20:12,840 --> 00:20:13,770
Thank you.

265
00:20:15,020 --> 00:20:22,400
What about the case where A like B won't see is like the fork.

266
00:20:25,310 --> 00:20:29,510
Let's assume for a second that A and B actually I have talked to each other and divide up the work,

267
00:20:29,510 --> 00:20:32,540
so they know they're supposed to be doing it together.

268
00:20:33,390 --> 00:20:33,870
Right.

269
00:20:35,510 --> 00:20:40,110
May form a team, they're in close collaboration in contact,

270
00:20:40,110 --> 00:20:42,930
you know and they've divided up the work

271
00:20:42,930 --> 00:20:45,120
and so they know you know B tells A,

272
00:20:45,120 --> 00:20:46,230
when B done, tells A,

273
00:20:46,230 --> 00:20:48,990
when they done and then they tell C go ahead, we all done.

274
00:20:49,760 --> 00:20:50,390
Okay?

275
00:20:52,190 --> 00:20:57,340
Okay, so, let's start with considering a simple design,

276
00:20:57,340 --> 00:20:59,590
that is too simple, meaning it doesn't work,

277
00:21:00,370 --> 00:21:08,140
but it gives us some starting points for more sophisticated design,

278
00:21:08,290 --> 00:21:09,310
hopefully might work

279
00:21:10,180 --> 00:21:12,400
and so the simple point is that

280
00:21:12,700 --> 00:21:16,150
A and b or any,

281
00:21:16,150 --> 00:21:20,740
all the files are going to be signed with person who modified,

282
00:21:20,770 --> 00:21:25,880
so when like A modifies you know auth.py,

283
00:21:29,200 --> 00:21:32,230
A actually produces a signature,

284
00:21:32,530 --> 00:21:36,490
and signed with the public key,

285
00:21:39,270 --> 00:21:42,840
which signature signed to the public key of A,

286
00:21:43,470 --> 00:21:48,480
and you know that signature covers the data of the file.

287
00:21:51,500 --> 00:21:57,170
And so when C downloads, you know the auth.py,

288
00:21:57,440 --> 00:21:59,420
you know check the signature,

289
00:22:05,100 --> 00:22:06,480
and if the signature checks out,

290
00:22:06,480 --> 00:22:09,480
you know then that C knows that actually this file was produced,

291
00:22:09,480 --> 00:22:12,090
you know this file was produced by A

292
00:22:12,330 --> 00:22:16,680
and you know might all believe that things are good.

293
00:22:17,300 --> 00:22:18,290
And that's the basic plan

294
00:22:18,380 --> 00:22:21,680
and we'll talk a little bit about where the keys are coming from,

295
00:22:21,680 --> 00:22:26,780
although you know the issue of public key distribution is really an 6.858 topics,

296
00:22:26,780 --> 00:22:27,980
so I'm not going to talk too much about it,

297
00:22:28,250 --> 00:22:29,570
but just assume for now,

298
00:22:29,570 --> 00:22:34,490
that every user has a key, public private key pair

299
00:22:34,610 --> 00:22:39,710
and the private keys are secret and the public keys are public,

300
00:22:39,980 --> 00:22:43,370
and every user knows whose public key belongs to who.

301
00:22:45,170 --> 00:22:53,300
So now let's consider attacks and see which one sort of you know fail,

302
00:22:53,300 --> 00:22:55,550
which ones you know work.

303
00:22:56,020 --> 00:22:58,240
So, of course the obvious attack was number one,

304
00:22:58,240 --> 00:23:00,370
that we talked about on the previous slide,

305
00:23:00,430 --> 00:23:03,780
this S modifies file,

306
00:23:05,940 --> 00:23:07,560
and that's not a little bit,

307
00:23:07,560 --> 00:23:13,080
that's not directly S modified auth.py,

308
00:23:13,500 --> 00:23:16,560
that's not really going to be possible anymore,

309
00:23:16,740 --> 00:23:21,240
because when C downloads you know the file and the signature,

310
00:23:21,330 --> 00:23:24,840
and checks it and it will see that the signature rejection check,

311
00:23:24,840 --> 00:23:31,350
because the data that actually was signed is different than the data that actually the server produced

312
00:23:31,530 --> 00:23:36,510
and so it's not really possible for the server really to modify auth.py,

313
00:23:36,510 --> 00:23:39,690
without actually being attacked or without actually being detected.

314
00:23:40,470 --> 00:23:44,430
So you know this is we're sort of in good shape here on this attacks

315
00:23:44,460 --> 00:23:46,590
and that's sort of the core attack, right.

316
00:23:47,210 --> 00:23:50,780
But there's a lot of other things that S still could do,

317
00:23:51,110 --> 00:23:54,350
so let's consider some of the other things,

318
00:23:55,040 --> 00:23:59,810
S you know could actually, we describe S send another file,

319
00:24:00,710 --> 00:24:02,780
and pretends to be auth.py,

320
00:24:05,450 --> 00:24:08,780
and because the signature doesn't really say

321
00:24:08,810 --> 00:24:11,570
you know which actually file the data belongs to

322
00:24:12,020 --> 00:24:16,790
and so S you know produce some other files,

323
00:24:16,790 --> 00:24:19,160
like oh yeah see this is actually auth.py,

324
00:24:19,460 --> 00:24:21,530
you can believe me in here,

325
00:24:21,530 --> 00:24:24,860
the sign the signature which of course produced by S,

326
00:24:25,370 --> 00:24:27,800
so of course this could be fixed,

327
00:24:27,830 --> 00:24:31,010
you know maybe the signature should not only include data,

328
00:24:31,010 --> 00:24:33,170
but also probably should include the file name,

329
00:24:35,340 --> 00:24:39,750
so you know maybe not too, too bad in something that you could be addressed.

330
00:24:41,950 --> 00:24:44,740
Third, you know another yet another possibility is

331
00:24:44,740 --> 00:24:53,200
to for S to basically send the contents of old files, old content,

332
00:24:54,970 --> 00:24:55,960
maybe some new.

333
00:25:03,460 --> 00:25:05,260
And it does a bit more difficult now

334
00:25:05,260 --> 00:25:09,070
for us to handle correct this to simple plan,

335
00:25:09,220 --> 00:25:16,660
because you know there there's no way you know basically the files individually authenticated, but not together

336
00:25:16,660 --> 00:25:21,610
and it's not C, gets a consistent picture of the file system,

337
00:25:21,610 --> 00:25:23,200
it just gets like sign files,

338
00:25:23,470 --> 00:25:27,880
and how do sign files relate to each other in terms of their histories,

339
00:25:28,090 --> 00:25:30,670
is completely not covered in these two simple design.

340
00:25:31,380 --> 00:25:33,540
This is exactly of course gonna issue,

341
00:25:33,540 --> 00:25:37,350
there's more subtle attack that now could just completely work out, correct,

342
00:25:37,350 --> 00:25:40,380
because you know S could send the,

343
00:25:40,710 --> 00:25:44,340
could send the old version of auth.py,

344
00:25:44,430 --> 00:25:46,410
it will completely check out,

345
00:25:46,740 --> 00:25:52,830
and then send the new version of the of the bank.py,

346
00:25:52,860 --> 00:25:55,350
which actually talks is linked to techcash,

347
00:25:55,470 --> 00:25:58,530
and now exactly back in there's a worse some case,

348
00:25:58,710 --> 00:26:01,500
were you know with an old version of auth.py

349
00:26:01,500 --> 00:26:03,210
or not to change to auth.py,

350
00:26:03,210 --> 00:26:05,370
not the certificate changes to auth.py,

351
00:26:05,610 --> 00:26:09,570
and the new version that actually link to techcash.

352
00:26:09,960 --> 00:26:11,730
And so this is not so good,

353
00:26:12,150 --> 00:26:16,020
so and the simple point that we have here, just doesn't deal with this.

354
00:26:17,420 --> 00:26:19,850
There's a similar sort of another version of this,

355
00:26:19,850 --> 00:26:24,110
that where you know of course you know S can also just claim that the file doesn't exist,

356
00:26:31,530 --> 00:26:37,260
and C doesn't really have any way of checking whether that's actually true or not,

357
00:26:37,260 --> 00:26:42,000
because again they should have a global picture where it's a consistent view of the file system,

358
00:26:42,330 --> 00:26:45,330
nobody knows about signatures for each file.

359
00:26:46,740 --> 00:26:50,280
And so you see that the simple design may be a good starting point,

360
00:26:50,280 --> 00:26:54,000
but we need something more, more complete

361
00:26:54,030 --> 00:26:59,520
and I think we need something that really ties all the file systems, all the files together,

362
00:26:59,520 --> 00:27:03,450
that ties directories together, the content of the directories together,

363
00:27:03,450 --> 00:27:06,270
and and we have to be able to decide in some way,

364
00:27:06,270 --> 00:27:09,690
what is the latest version of the file system,

365
00:27:09,930 --> 00:27:14,430
so that C can't be tricked into in this sort of problematic case,

366
00:27:14,430 --> 00:27:18,000
where one file is installed and the other file is not installed.

367
00:27:18,930 --> 00:27:22,800
So that's really what the SUNDR paper tries to address

368
00:27:23,070 --> 00:27:30,510
and the big idea in the in the paper,

369
00:27:30,720 --> 00:27:33,810
and it just turns out to be just a big idea in general,

370
00:27:35,220 --> 00:27:36,990
and it's a conceptual idea,

371
00:27:36,990 --> 00:27:40,710
even though the paper actually doesn't really implement this big idea directly,

372
00:27:40,830 --> 00:27:42,630
implement it in a more indirect way,

373
00:27:42,840 --> 00:27:46,200
it is an incredibly powerful idea.

374
00:27:47,130 --> 00:27:56,040
So the big idea is to have signed log of operations.

375
00:28:01,340 --> 00:28:04,460
And of course you're well familiar with logs of operations,

376
00:28:04,700 --> 00:28:07,100
and you and you know you can

377
00:28:07,100 --> 00:28:09,890
and this is basically a sort of [beefed] up version of it,

378
00:28:10,190 --> 00:28:12,590
where there signatures on log entries,

379
00:28:12,590 --> 00:28:16,460
that both consider cover the entry as well as preceding entries.

380
00:28:17,150 --> 00:28:25,430
And this turns out to be as we've seen in all the previous distributed systems and failure recovery protocols,

381
00:28:25,430 --> 00:28:31,670
we talk about the log is actually very powerful idea to think about the correctness of the system

382
00:28:31,910 --> 00:28:38,270
and in the same way that idea is carried for here in this Byzantine context.

383
00:28:38,880 --> 00:28:42,630
And so let me draw a simple log,

384
00:28:45,660 --> 00:28:48,090
so captures this in the paper,

385
00:28:48,300 --> 00:28:50,160
so log whatever have some entries

386
00:28:50,160 --> 00:28:54,090
and let's say you know we're coming up we are talking about,

387
00:28:54,090 --> 00:29:00,090
so it's modification, a mod, you know auth.py,

388
00:29:01,330 --> 00:29:03,850
by A, signed by A,

389
00:29:05,760 --> 00:29:06,990
you know there's a mod,

390
00:29:07,620 --> 00:29:17,730
if everything goes well, you know there's a mod of the bank.py signed by B.

391
00:29:20,630 --> 00:29:22,280
And as we'll talk about in a second

392
00:29:22,280 --> 00:29:26,980
you know it turns out that not only are the modifications in the log,

393
00:29:26,980 --> 00:29:29,950
but also the fetch of the read operations.

394
00:29:32,050 --> 00:29:41,780
So fetch fetch the log you know signed by C, auth.py,

395
00:29:43,750 --> 00:29:49,850
and then fetch of bank.py, singed by C.

396
00:29:52,620 --> 00:29:56,310
We'll talk about those operations, so the fetch operations, a little bit,

397
00:29:56,490 --> 00:30:01,890
I first want to talk about how to operate the preceding operations for modifications.

398
00:30:05,200 --> 00:30:08,770
So, first of all, the what's important to realize is that,

399
00:30:08,770 --> 00:30:14,350
this signature that is in the record not only covers the current records,

400
00:30:14,530 --> 00:30:16,570
but it also covers all the records before.

401
00:30:23,590 --> 00:30:25,000
Let me stop for a second here,

402
00:30:25,000 --> 00:30:28,420
because I'm not a hundred percent sure if can everybody still hear me.

403
00:30:30,220 --> 00:30:31,000
Yeah.

404
00:30:31,030 --> 00:30:31,240
Yes.

405
00:30:31,240 --> 00:30:35,500
Okay, I got my ipad and I walked out of the zoom session,

406
00:30:35,500 --> 00:30:40,390
I always walking twice and my ipad logged out,

407
00:30:40,420 --> 00:30:44,050
so I just want to make sure I'm still talking to you and you can hear me,

408
00:30:46,140 --> 00:30:47,520
and start that is the case.

409
00:30:47,730 --> 00:30:51,270
Okay, so let's just proceed the.

410
00:30:52,030 --> 00:30:52,600
So, actually.

411
00:31:20,620 --> 00:31:22,120
I think we lost Frans.

412
00:32:05,030 --> 00:32:09,530
Can people hear me now, Does anybody hear me.

413
00:32:11,620 --> 00:32:12,340
Yes.

414
00:32:12,370 --> 00:32:13,330
Okay.

415
00:32:13,780 --> 00:32:16,510
Okay, I don't know if anything weird happens on your end,

416
00:32:16,510 --> 00:32:21,870
but my end, I got logged out of Zoom and log back in.

417
00:32:24,340 --> 00:32:28,480
Maybe there's a Byzantine server at work.

418
00:32:29,440 --> 00:32:35,060
Okay, let me hold on one second, and get myself in.

419
00:32:49,800 --> 00:32:52,440
And let me see, that video goes off.

420
00:33:07,420 --> 00:33:11,380
Camera, okay, let me know if I'm good.

421
00:33:14,280 --> 00:33:15,720
Okay, good.

422
00:33:15,720 --> 00:33:17,340
No screen sharing yet, but yeah.

423
00:33:17,460 --> 00:33:20,790
Okay, I hope this works better,

424
00:33:20,820 --> 00:33:24,180
okay, so it was at this very important point,

425
00:33:24,180 --> 00:33:28,140
where the signature just not cover the log entry itself,

426
00:33:28,230 --> 00:33:30,870
but also covers all the preceding log entries.

427
00:33:31,480 --> 00:33:38,740
And so when you know A as this modification to auth.py to the log,

428
00:33:38,800 --> 00:33:42,490
it signs the log records itself plus the preceding log record,

429
00:33:42,490 --> 00:33:43,360
so you can think about this,

430
00:33:43,360 --> 00:33:46,270
that the preceding log is may be represented by,

431
00:33:46,300 --> 00:33:50,590
the content of the preceding log is cryptographic hash,

432
00:33:50,620 --> 00:33:56,350
and a in the record, basically modification to auth.py,

433
00:33:56,350 --> 00:34:01,210
you know the the cryptographic hash the preceding part of the log

434
00:34:01,210 --> 00:34:03,940
is included and covered by the signature.

435
00:34:04,150 --> 00:34:06,760
Just to be clear, we still can't see the screen.

436
00:34:07,330 --> 00:34:11,460
You can't see the screen, screen hasn't changed,

437
00:34:11,460 --> 00:34:16,300
but, let me see if I can do something about that.

438
00:34:17,340 --> 00:34:19,200
And [] I guess,

439
00:34:21,180 --> 00:34:23,250
Zoom still thinks there's actually sharing the screen,

440
00:34:23,250 --> 00:34:25,500
but it doesn't look like actually is.

441
00:34:35,230 --> 00:34:35,950
How about this?

442
00:34:37,680 --> 00:34:38,550
Yep, I can see now.

443
00:34:39,030 --> 00:34:39,780
Okay, thank you.

444
00:34:40,620 --> 00:34:42,450
Okay, so I didn't change anything yet,

445
00:34:42,510 --> 00:34:44,430
other than I think I was going to draw the next arrow,

446
00:34:44,430 --> 00:34:49,110
which basically when these signs you know it's actually covered all the preceding entries too.

447
00:34:50,320 --> 00:34:51,700
And this is a good, correct,

448
00:34:51,700 --> 00:35:01,240
because when client you know C actually receives you know or gets actually sees the log entry for B,

449
00:35:01,570 --> 00:35:08,260
then it's impossible for the server to drop the log entry of A,

450
00:35:08,350 --> 00:35:13,960
because you know that will be detected when C actually detect signature on the log entry of B.

451
00:35:14,810 --> 00:35:17,810
And so we really made a big step forward,

452
00:35:17,810 --> 00:35:24,410
in the sense that it's much harder for the server now to selectively drop log entries.

453
00:35:25,590 --> 00:35:30,600
So that's so we're pretty good pretty good, you know the servers cannot drop A,

454
00:35:36,540 --> 00:35:41,150
and keep these modifications.

455
00:35:44,250 --> 00:35:46,860
So that's actually a big big step forward,

456
00:35:47,190 --> 00:35:49,110
so let's look a little bit more in detail,

457
00:35:49,110 --> 00:35:50,640
how this actually is going to play out,

458
00:35:50,850 --> 00:35:59,580
so we're a client C and you know we're fetching the log to basically pull out you know the distribution of the software

459
00:35:59,580 --> 00:36:01,140
to install on a particular machine,

460
00:36:01,470 --> 00:36:03,120
the first thing the client does,

461
00:36:03,120 --> 00:36:05,950
you know it actually check all the signatures.

462
00:36:13,990 --> 00:36:16,390
And you know always the question of course is like,

463
00:36:16,390 --> 00:36:21,700
when you know you want to check the signature log entry you know which public key do you use,

464
00:36:21,700 --> 00:36:24,370
and because you want to make sure that,

465
00:36:24,910 --> 00:36:30,180
you're not being tricked in accepting [] modification by A,

466
00:36:30,180 --> 00:36:32,790
but it turns out that actually A was not the person actually signed it.

467
00:36:33,350 --> 00:36:40,820
And it turns out basically to figure out which key to use to actually verify the signature,

468
00:36:41,000 --> 00:36:44,360
the key uses the owner of the file,

469
00:36:45,250 --> 00:36:49,460
so the public key need to correspond to the owner of the file

470
00:36:50,840 --> 00:36:53,900
and ignoring groups for now,

471
00:36:53,900 --> 00:36:57,110
you know basically only the owner of the file was allowed to modify a file.

472
00:36:57,880 --> 00:37:00,940
So for simple for slightly simplified,

473
00:37:00,940 --> 00:37:04,270
we can think about it auth.py is owned by A

474
00:37:04,600 --> 00:37:07,360
and the id of the file is basically the public key of A

475
00:37:07,930 --> 00:37:17,170
and so we know which public key to use and can verify the signature with it,

476
00:37:17,170 --> 00:37:20,800
and so if somebody else makes a modification that pretends to be A,

477
00:37:20,950 --> 00:37:22,480
that actually is not going to check out.

478
00:37:23,560 --> 00:37:26,620
So it's really only A can connects and make modifications similar for B.

479
00:37:28,540 --> 00:37:33,160
So that's part of the you know one thing that's actually clever about SUNDR,

480
00:37:33,310 --> 00:37:34,810
I'm not really going to be talking about,

481
00:37:35,020 --> 00:37:38,260
some since the file system is actually doubling both as a file system,

482
00:37:38,260 --> 00:37:45,280
as a public key public key infrastructure or distribution infrastructure,

483
00:37:45,550 --> 00:37:52,150
and so it's actually possible to something basically why we determine like which user has which public key.

484
00:37:53,380 --> 00:37:55,120
But I'm not really gonna talk about this,

485
00:37:55,120 --> 00:37:57,610
I really want to focus on the consistency aspects

486
00:37:57,610 --> 00:38:00,070
and the more distributed systems aspects.

487
00:38:00,990 --> 00:38:07,720
The second thing that the client does is check its own last entry.

488
00:38:13,410 --> 00:38:18,270
And this is to protect clients from actually being rolled back by the server in time,

489
00:38:18,270 --> 00:38:21,990
so the server can actually by the client checks always last entry,

490
00:38:22,440 --> 00:38:24,300
if its last entries in the log steal,

491
00:38:24,450 --> 00:38:32,070
then you know the only way forward for the attacker is to actually roll the file system for A can roll backwards,

492
00:38:32,370 --> 00:38:35,520
so C will check whether the [] of its previous operations are in it

493
00:38:35,880 --> 00:38:38,070
and confirm that they're still in it,

494
00:38:39,600 --> 00:38:42,360
actually it's last entries still in it.

495
00:38:42,360 --> 00:38:43,620
Is the question here,

496
00:38:44,070 --> 00:38:50,100
this only I think this attack from the server to rollback,

497
00:38:50,100 --> 00:38:55,530
would only work if no other client wrote to the log,

498
00:38:56,860 --> 00:39:00,430
like after this client's last entry, right,

499
00:39:00,430 --> 00:39:04,150
because otherwise checking signatures would figure that out.

500
00:39:04,800 --> 00:39:09,390
Yeah, although you know let's talk about in a second,

501
00:39:09,390 --> 00:39:11,490
maybe I mean you could always play a fork attack,

502
00:39:11,550 --> 00:39:15,840
so you can always split you know the use of the file system in multiple users,

503
00:39:16,050 --> 00:39:18,690
but you can at least not roll back the client,

504
00:39:18,690 --> 00:39:21,090
once the client saw a particular file system,

505
00:39:21,450 --> 00:39:22,770
you can't go backwards in time.

506
00:39:24,150 --> 00:39:27,360
The client could, the server it can present different file systems in future,

507
00:39:27,390 --> 00:39:28,860
but you can't roll back.

508
00:39:32,280 --> 00:39:38,130
Third part, the first place with the [] industry is a [constructive] file system.

509
00:39:41,930 --> 00:39:46,670
So after you know, it knows actually it's not rolled past version of the file system,

510
00:39:46,760 --> 00:39:49,220
it basically applies all the modifications,

511
00:39:49,220 --> 00:39:52,460
basically builds a file system tree you know on the client

512
00:39:52,940 --> 00:39:56,300
and and then before whatever operation it is,

513
00:39:56,300 --> 00:39:57,110
it wants to perform,

514
00:39:57,110 --> 00:40:00,080
so let's say in the case of C,

515
00:40:00,170 --> 00:40:01,790
what it will do is,

516
00:40:01,790 --> 00:40:14,720
you know it will read you know auth.py and append an entry to the log and sign it.

517
00:40:17,330 --> 00:40:19,280
So in the case when it reads auth.py,

518
00:40:19,280 --> 00:40:24,110
it will, it produce basically a signature or an entry for this log entry.

519
00:40:25,150 --> 00:40:29,110
And basically then and then the final step in this protocol is,

520
00:40:29,110 --> 00:40:31,810
it uploads the log to the file server.

521
00:40:37,770 --> 00:40:41,160
And you know clearly this protocol is completely in practical,

522
00:40:41,250 --> 00:40:43,710
and and really what it is,

523
00:40:43,710 --> 00:40:45,150
it's sort of more conceptual protocol

524
00:40:45,150 --> 00:40:50,610
to help us understand why eventually we might even be successful in achieving security

525
00:40:50,610 --> 00:40:54,930
in the context of Byzantine server.

526
00:40:55,540 --> 00:40:59,560
Because if we're ridiculous correct to download the log for every operation

527
00:40:59,770 --> 00:41:03,520
and the log contains the history of all the operations ever happened to the file system,

528
00:41:03,730 --> 00:41:10,840
in step three, you know the client actually constructs file system at all the, all operations ever performance since the beginning of time,

529
00:41:11,110 --> 00:41:12,670
and then finally in step five,

530
00:41:12,670 --> 00:41:15,880
upload the whole log back to the server, seems completely ridiculous

531
00:41:16,090 --> 00:41:17,170
and it is ridiculous,

532
00:41:17,380 --> 00:41:18,640
in terms of performance,

533
00:41:18,730 --> 00:41:21,940
but it will help us understand

534
00:41:21,940 --> 00:41:25,810
you know when we look at the implementation of the scheme,

535
00:41:25,930 --> 00:41:28,750
when it actually has the same set of properties,

536
00:41:28,750 --> 00:41:31,390
that they sort of conceptual design has

537
00:41:31,870 --> 00:41:35,140
and we'll see later example, in the case of Bitcoin,

538
00:41:35,230 --> 00:41:37,390
that literally does actually have a log

539
00:41:37,390 --> 00:41:39,790
and since the beginning of time, with all operations in it

540
00:41:39,970 --> 00:41:43,120
and so, maybe it was a crazy idea,

541
00:41:43,120 --> 00:41:44,350
maybe in the context of 2004,

542
00:41:44,350 --> 00:41:49,900
but you know people actually do have these sign logs and really maintained it.

543
00:41:50,680 --> 00:41:51,670
And so in that sense,

544
00:41:51,820 --> 00:41:54,040
you know it's not only a big conceptual idea,

545
00:41:54,070 --> 00:41:55,540
that some people do it in practice.

546
00:41:58,340 --> 00:41:59,450
Any questions so far?

547
00:42:04,290 --> 00:42:04,980
Okay.

548
00:42:07,270 --> 00:42:10,870
The one thing you know that you're probably wondering about,

549
00:42:10,870 --> 00:42:16,110
it was proposed as question for the reading today,

550
00:42:16,320 --> 00:42:18,510
is what is up with these fetches,

551
00:42:18,510 --> 00:42:21,690
you know why are the fetches in the log too,

552
00:42:21,900 --> 00:42:26,160
and and the because you might think,

553
00:42:26,160 --> 00:42:28,260
well you know the only thing I really care about,

554
00:42:28,260 --> 00:42:32,700
if we think about, we care about is only the modifications,

555
00:42:32,700 --> 00:42:33,600
you have to be in the log,

556
00:42:33,600 --> 00:42:35,940
because there are actually things, actually modify the file system,

557
00:42:35,940 --> 00:42:37,830
reads don't really modify this file system,

558
00:42:37,830 --> 00:42:40,680
so what's the what's the problem.

559
00:42:41,280 --> 00:42:44,250
And so I think I wanna do a quick breakout here

560
00:42:44,250 --> 00:42:46,110
and I'm sure if you can bring some of each other,

561
00:42:46,110 --> 00:42:48,870
but what you thought the answer to this particular question was

562
00:42:49,050 --> 00:42:58,360
and hopefully maybe this initial coverage like SUNDR you know maybe how to improve your understanding

563
00:42:58,660 --> 00:43:01,390
and you know you can sort of figure out what the answer is,

564
00:43:01,390 --> 00:43:02,530
or talking about something else,

565
00:43:02,740 --> 00:43:06,850
so I would like to take, maybe do a five minutes breakout room.

566
00:49:18,650 --> 00:49:20,690
Okay, just double checking everybody back.

567
00:49:21,860 --> 00:49:22,520
Looks like it.

568
00:49:22,940 --> 00:49:24,020
Good, thank you.

569
00:49:24,810 --> 00:49:25,380
Okay, so what,

570
00:49:25,380 --> 00:49:28,020
I guess, let's start with the homework questions,

571
00:49:28,490 --> 00:49:32,150
with no more question why, why are the fetches in the log.

572
00:49:38,260 --> 00:49:38,950
Anybody?

573
00:49:41,230 --> 00:49:43,870
If you have a read-only server,

574
00:49:44,110 --> 00:49:45,340
if there are no fetches,

575
00:49:45,340 --> 00:49:48,040
this file system can give it anything.

576
00:49:48,630 --> 00:49:49,170
Can it?

577
00:49:49,970 --> 00:49:51,650
Can give it, because it,

578
00:49:51,830 --> 00:49:53,780
because there are no fetches in the log,

579
00:49:53,780 --> 00:50:04,680
that would mean that there are, there be read-only servers would not be doing a lot of the checks,

580
00:50:04,680 --> 00:50:05,970
that we talked about before,

581
00:50:05,970 --> 00:50:09,000
so they they go back in time,

582
00:50:09,000 --> 00:50:10,860
for example might maybe not work,

583
00:50:10,860 --> 00:50:13,850
because, it did not put anything in the log,

584
00:50:13,970 --> 00:50:15,500
because it only fetches.

585
00:50:15,740 --> 00:50:16,760
Yeah, okay good,

586
00:50:16,760 --> 00:50:19,640
okay, so I think you're totally on the right track,

587
00:50:19,910 --> 00:50:23,780
it was like trying to make it a little bit more precise or make more concrete

588
00:50:23,810 --> 00:50:25,250
and I think you know that is correct.

589
00:50:25,310 --> 00:50:27,050
So let's assume this is the log looks like

590
00:50:27,050 --> 00:50:28,880
and the C's fetches are not in it.

591
00:50:29,480 --> 00:50:31,190
And let's you know,

592
00:50:31,190 --> 00:50:35,450
so this is the log before actually C downloads log,

593
00:50:35,720 --> 00:50:44,190
so let's say you know where C fetches fetches auth.py, correct,

594
00:50:44,190 --> 00:50:45,990
the file that was modified by A

595
00:50:46,830 --> 00:50:49,140
and basically what the server does,

596
00:50:49,380 --> 00:50:55,290
the server instead of actually providing both the modifications A and B,

597
00:50:55,290 --> 00:50:56,070
because it has it,

598
00:50:56,880 --> 00:50:59,280
which A and B were done with its modifications,

599
00:50:59,610 --> 00:51:06,330
it sends the C basically prefix,

600
00:51:08,880 --> 00:51:15,840
since the prefix that excludes the modifications to A and B,

601
00:51:16,900 --> 00:51:22,690
so we have mods A and B right,

602
00:51:22,690 --> 00:51:24,820
and so C you know fetches this file,

603
00:51:24,970 --> 00:51:26,650
it fetches the log

604
00:51:26,800 --> 00:51:30,460
and so this basically is this part of the log prefix,

605
00:51:32,540 --> 00:51:36,470
you know the C checks you know the signature,

606
00:51:36,470 --> 00:51:38,960
checks whether it's proceeding operations are in it,

607
00:51:39,290 --> 00:51:40,640
you know and they're all there,

608
00:51:40,640 --> 00:51:42,590
because C hasn't done any other operation yet

609
00:51:42,920 --> 00:51:44,750
and so basically it will accept the log

610
00:51:44,750 --> 00:51:47,450
and the log as it is or the prefix as it is,

611
00:51:47,810 --> 00:51:52,310
and basically returns you know auth.py to whatever application,

612
00:51:52,860 --> 00:51:55,290
that is copying this software into the machine,

613
00:51:55,290 --> 00:51:57,390
that actually run the installed software.

614
00:51:58,130 --> 00:52:05,230
So then C fetches bank.py,

615
00:52:08,590 --> 00:52:14,230
and this time around, the server sends the whole log.

616
00:52:19,460 --> 00:52:25,550
And you know the C, C looks at these entries

617
00:52:25,550 --> 00:52:27,770
and it's a valid log,

618
00:52:27,770 --> 00:52:30,740
in the operations are presumably the prefix,

619
00:52:31,310 --> 00:52:33,470
since we didn't care about fetches,

620
00:52:33,470 --> 00:52:34,970
you know its all caught in the log

621
00:52:35,210 --> 00:52:38,270
and so everything looks you know good,

622
00:52:38,270 --> 00:52:39,800
you know these are valid modifications,

623
00:52:39,800 --> 00:52:41,900
the nothing has been changed

624
00:52:42,410 --> 00:52:47,450
and and so you know C, you know without the fetches in the log,

625
00:52:47,600 --> 00:52:50,240
C will actually accept this log

626
00:52:50,450 --> 00:52:52,670
and basically build a file system,

627
00:52:52,670 --> 00:52:58,490
that has, that deploy includes modifications to A and B

628
00:52:58,640 --> 00:53:02,930
and returns the results you know to the application for bank.py.

629
00:53:05,490 --> 00:53:07,050
So that it can install the machine,

630
00:53:07,050 --> 00:53:09,030
that actually is going to run the servers

631
00:53:09,360 --> 00:53:12,630
and as you can see you know we're sort of in a bad situation, right,

632
00:53:12,630 --> 00:53:17,080
because we took the old version of auth.py

633
00:53:18,220 --> 00:53:21,010
and the new version of bank.py,

634
00:53:22,940 --> 00:53:25,460
and the one way you can think about this is that,

635
00:53:25,640 --> 00:53:27,650
you know from you know C's perspective,

636
00:53:27,890 --> 00:53:30,500
what really seemed to have happened is that,

637
00:53:30,500 --> 00:53:37,260
while you know it was reading auth.py,

638
00:53:37,380 --> 00:53:40,320
you know there were concurrent modifications to A and B,

639
00:53:40,320 --> 00:53:42,240
and just happened basically at the same time

640
00:53:42,240 --> 00:53:43,830
or at least the server is pretending,

641
00:53:43,830 --> 00:53:45,120
it happened at the same time

642
00:53:45,600 --> 00:53:48,180
and so and so it gets confused,

643
00:53:48,550 --> 00:53:53,770
or can't detect the fact, that these applications were did happen before any time.

644
00:53:55,060 --> 00:53:56,920
So this is the, this is the problem,

645
00:53:56,920 --> 00:54:00,700
that you know basically putting the fetches in the log source,

646
00:54:01,090 --> 00:54:06,010
is like let's make that actually just also concrete,

647
00:54:08,200 --> 00:54:13,300
and so see why actually this problem is solved in that case.

648
00:54:14,260 --> 00:54:16,030
Professor, I I had a question.

649
00:54:16,090 --> 00:54:20,590
Yeah, so I I'm having a little trouble understand,

650
00:54:20,590 --> 00:54:26,410
like understanding what the, like sort of like the interface,

651
00:54:26,410 --> 00:54:30,550
for like for fetch and modify is like what,

652
00:54:31,350 --> 00:54:35,670
I I thought you fetched pretty much like the whole tree

653
00:54:35,700 --> 00:54:37,800
and had to rebuild the whole file system,

654
00:54:37,860 --> 00:54:39,600
basic example,

655
00:54:39,900 --> 00:54:44,610
but this slide before you're fetching specific files.

656
00:54:44,850 --> 00:54:49,170
The server is the one that returns the log correct,

657
00:54:49,890 --> 00:54:52,260
so the server can decide what entries to include.

658
00:54:52,640 --> 00:54:57,230
Yeah, and we're already seeing that it can't really delete anything out in the middle of the log

659
00:54:57,260 --> 00:54:58,790
and that's not really possible,

660
00:54:59,090 --> 00:55:01,130
it's always send a prefix of the log,

661
00:55:01,160 --> 00:55:03,740
because the prefix is always consistent with itself.

662
00:55:04,670 --> 00:55:08,100
And so in this first case, correct,

663
00:55:08,100 --> 00:55:09,150
it sends the prefix

664
00:55:09,510 --> 00:55:11,280
and in the second case, sends the whole log.

665
00:55:11,370 --> 00:55:12,750
Yeah.

666
00:55:12,750 --> 00:55:14,130
So the server can decide to do that,

667
00:55:14,130 --> 00:55:17,670
but there's nothing that the client can or at least it like so far,

668
00:55:17,730 --> 00:55:19,950
you know, discuss there's nothing that the client,

669
00:55:19,950 --> 00:55:21,030
how the client could detect,

670
00:55:21,030 --> 00:55:22,680
that it didn't get like the whole log.

671
00:55:22,950 --> 00:55:26,160
Right, I I my question is more towards,

672
00:55:26,160 --> 00:55:29,400
like what the interface is for clients to use,

673
00:55:29,400 --> 00:55:31,770
like fetch and modify, like,

674
00:55:32,070 --> 00:55:33,750
because I thought, initially I thought,

675
00:55:33,750 --> 00:55:36,870
okay fetch fetch is like the whole file system.

676
00:55:36,900 --> 00:55:38,970
No, no, fetch is a single file.

677
00:55:39,210 --> 00:55:39,870
Okay.

678
00:55:40,440 --> 00:55:42,750
And and so basically what the fetch does,

679
00:55:42,750 --> 00:55:44,640
it get to the log, like modifications,

680
00:55:45,150 --> 00:55:47,760
modifications are all the operations that modify a file,

681
00:55:48,180 --> 00:55:50,970
and like if you go back to a slide a little bit earlier,

682
00:55:51,000 --> 00:55:52,530
you know in the modification record,

683
00:55:52,530 --> 00:55:55,140
it says explicitly which file is being modified

684
00:55:56,310 --> 00:55:58,380
and you know what's being said is,

685
00:55:58,380 --> 00:56:01,680
similarly in the fetch, it says which file like this client saw.

686
00:56:03,400 --> 00:56:04,150
Okay.

687
00:56:04,640 --> 00:56:11,330
And then, so so, so for fetch like a client goes through the log,

688
00:56:11,330 --> 00:56:12,500
but only looks at.

689
00:56:13,130 --> 00:56:16,070
Yeah, feath a thing that does actually read the file that actually is looking for.

690
00:56:16,550 --> 00:56:20,840
Okay, but does it check every single entry in the log anyways for the signature.

691
00:56:20,840 --> 00:56:25,250
Yeah, okay, the first step is always check the whole log,

692
00:56:25,400 --> 00:56:29,870
go for and make sure that your last you know operations in it,

693
00:56:29,870 --> 00:56:31,280
whether it's a [] or modify,

694
00:56:31,520 --> 00:56:35,780
although in this broken scheme, you know we drop the fetches,

695
00:56:36,230 --> 00:56:39,650
it applies all the checks, all the signatures

696
00:56:39,920 --> 00:56:42,380
and then it builds up the file system,

697
00:56:42,970 --> 00:56:45,160
by replaying the log from the beginning of time,

698
00:56:45,160 --> 00:56:46,120
get a file system

699
00:56:46,210 --> 00:56:47,770
and then it does its operation,

700
00:56:47,830 --> 00:56:51,880
and so in this case, the operation is certainly fetched auth.py, is basically reading it.

701
00:56:52,520 --> 00:56:53,030
Okay.

702
00:56:53,180 --> 00:56:55,940
The reason you know basically that we talk about fetch and modify is,

703
00:56:55,940 --> 00:57:03,110
because all operations are basically following one or two [catch], either to fetch or it is a modification operation,

704
00:57:03,110 --> 00:57:04,970
like writing a file, creating a file,

705
00:57:04,970 --> 00:57:07,040
there's all modification operations,

706
00:57:07,130 --> 00:57:09,380
the fetch operations are reading a file,

707
00:57:09,380 --> 00:57:13,010
maybe [] directory status file, that kind of thing.

708
00:57:13,730 --> 00:57:15,920
Okay, and then the modify is also,

709
00:57:16,130 --> 00:57:23,230
like a modify, like doesn't fetch the, okay also fetches the log,

710
00:57:23,230 --> 00:57:26,170
but then builds the file system.

711
00:57:26,200 --> 00:57:29,650
Yeah, so maybe the fetches here I'm using fetch I guess in two ways,

712
00:57:29,680 --> 00:57:31,900
one describe read-only operations

713
00:57:32,080 --> 00:57:35,680
and actually to obtain or receive the log from the server.

714
00:57:36,170 --> 00:57:39,980
Okay, but then modified, modifies also one single file.

715
00:57:40,310 --> 00:57:43,250
Yes, yeah, for every modification in the file system,

716
00:57:43,250 --> 00:57:44,360
you're gonna have a log entry.

717
00:57:44,900 --> 00:57:45,470
Okay thanks.

718
00:57:47,900 --> 00:57:50,660
Sorry, I also have a question,

719
00:57:50,660 --> 00:57:56,150
I I don't really understand why this scenario is a problem,

720
00:57:56,750 --> 00:57:58,370
because as you said,

721
00:57:58,970 --> 00:58:00,260
it's it's possible,

722
00:58:00,260 --> 00:58:01,940
like from the perspective of the client,

723
00:58:01,940 --> 00:58:09,530
it may well be that A and B got created or modified, for the last fetch.

724
00:58:09,650 --> 00:58:11,510
Yeah, in principle, it could have happened, correct,

725
00:58:11,510 --> 00:58:12,800
that was recovering modification,

726
00:58:12,980 --> 00:58:16,880
we do know, because like we were sort of look from the top

727
00:58:17,120 --> 00:58:21,470
and we know that basically C you read the file after A and B modified,

728
00:58:22,860 --> 00:58:26,100
but the server can pretend as if it actually happened concurrently

729
00:58:26,160 --> 00:58:30,000
and in the second, we'll see that, if we stick the fetches in the log,

730
00:58:30,060 --> 00:58:31,590
server can not pretend to do that.

731
00:58:33,240 --> 00:58:36,480
Okay, but even if the server pretends that,

732
00:58:36,510 --> 00:58:40,450
does it, is that even a problem,

733
00:58:40,450 --> 00:58:41,590
does it break anything,

734
00:58:41,590 --> 00:58:41,890
because.

735
00:58:41,890 --> 00:58:46,090
Yeah, this is a example where it shows how to break something, correct,

736
00:58:46,360 --> 00:58:50,100
like step one, you know C fetches auth.py,

737
00:58:50,250 --> 00:58:54,000
the server gave it one you know as far as the fetch,

738
00:58:54,030 --> 00:58:55,530
it gave the prefix.

739
00:58:56,260 --> 00:58:58,030
And so the client constructed file system,

740
00:58:58,030 --> 00:59:02,080
executing the operation returned auth.py to the application

741
00:59:02,080 --> 00:59:03,820
and install the software on the machine,

742
00:59:03,880 --> 00:59:05,680
just to make it very [],

743
00:59:05,860 --> 00:59:09,580
so now the first, you're reading auth.py that operation is done,

744
00:59:10,000 --> 00:59:11,680
finished already executed

745
00:59:11,920 --> 00:59:16,900
and has installed the old version of auth.py on the machine.

746
00:59:18,700 --> 00:59:22,240
Then the client you know can fetch is bank.py,

747
00:59:23,050 --> 00:59:28,690
now the server actually the client the application want to read bank.py,

748
00:59:28,810 --> 00:59:32,230
so the client fetches the log from the server or ask the server,

749
00:59:32,230 --> 00:59:33,310
please give me the log,

750
00:59:33,670 --> 00:59:35,710
the server this time around, gives the whole log,

751
00:59:36,240 --> 00:59:37,620
and not just the prefix.

752
00:59:38,010 --> 00:59:38,610
Yeah but.

753
00:59:38,610 --> 00:59:41,040
The [] that builds up the whole file system

754
00:59:41,070 --> 00:59:43,890
and returns bank.py to the application.

755
00:59:44,830 --> 00:59:50,230
But in like, I wouldn't this happen in an incorrect implementation of the client,

756
00:59:50,230 --> 00:59:53,680
because if the client finds that receives the log

757
00:59:53,770 --> 00:59:56,770
and it sees an additional modification on A,

758
00:59:56,980 --> 01:00:02,050
if the client knows that its logic depends on A and B being in sync,

759
01:00:02,050 --> 01:00:03,640
it would also fetch A again.

760
01:00:04,600 --> 01:00:06,670
Okay, so there's a question,

761
01:00:06,940 --> 01:00:08,830
C doesn't know, correct,

762
01:00:08,830 --> 01:00:13,330
that is C,

763
01:00:13,360 --> 01:00:17,580
okay, in this particular scenario,

764
01:00:18,390 --> 01:00:21,540
the we're trying to establish whether actually,

765
01:00:21,540 --> 01:00:26,820
you know C can determine whether actually modification happens concurrently or in the past, before reading.

766
01:00:27,480 --> 01:00:28,740
You know we want to be in the case,

767
01:00:28,740 --> 01:00:29,970
that actually happened in the past,

768
01:00:29,970 --> 01:00:31,800
because actually really happened in the past.

769
01:00:32,110 --> 01:00:35,170
But you know what this you know server does,

770
01:00:35,200 --> 01:00:38,710
it just pretends that the modification actually happened concurrently,

771
01:00:38,770 --> 01:00:40,930
we've actually sees operations,

772
01:00:41,860 --> 01:00:45,520
and C doesn't really have any way to detect that,

773
01:00:45,610 --> 01:00:51,010
other than a new you know maybe A you know there should have been a modification for A and B together.

774
01:00:51,500 --> 01:00:53,210
But that only could have known,

775
01:00:53,210 --> 01:00:55,700
if there were sort of communication between C and A and B,

776
01:00:55,730 --> 01:00:57,770
and second, let's talk about that in a second,

777
01:00:57,770 --> 01:00:59,960
but if C had not talked to A and B

778
01:01:00,170 --> 01:01:05,360
and you know yeah it could have gotten, could end up in this scenario,

779
01:01:05,360 --> 01:01:09,950
where it installed the old version in auth.py, the new version of bank.py.

780
01:01:10,640 --> 01:01:11,540
And we'll see in the second,

781
01:01:11,540 --> 01:01:12,950
if we stick the fetches in,

782
01:01:13,010 --> 01:01:14,510
then this probably cannot happen.

783
01:01:17,720 --> 01:01:19,970
Somebody asked if we timestamp everything,

784
01:01:19,970 --> 01:01:22,790
then we could detect things all that thought for a second.

785
01:01:25,450 --> 01:01:29,560
Okay, let's look at the with fetches scenario, right,

786
01:01:29,770 --> 01:01:32,140
so see what actually happens in that case,

787
01:01:32,260 --> 01:01:38,860
so client fetches, what is the fetches of auth.py.

788
01:01:41,740 --> 01:01:42,940
Oops, what happened now.

789
01:01:48,660 --> 01:01:53,030
Hold on a second, something wrong.

790
01:01:53,780 --> 01:01:56,390
I presumably nobody can see my screen yet.

791
01:02:03,010 --> 01:02:03,820
It's black.

792
01:02:03,850 --> 01:02:06,040
Yeah yeah coming back hold on a second.

793
01:02:10,850 --> 01:02:15,620
I definitely feel today, there's a Byzantine component to 6.824.

794
01:02:32,480 --> 01:02:34,490
Okay, I need to stop sharing screen for a second.

795
01:03:21,610 --> 01:03:23,080
Allright, we're back hopefully.

796
01:03:24,730 --> 01:03:25,900
Okay.

797
01:03:32,090 --> 01:03:36,440
Okay, so back to this example,

798
01:03:36,470 --> 01:03:38,180
we're now the features are in the log,

799
01:03:38,180 --> 01:03:40,220
C fetches the auth.py.

800
01:03:42,300 --> 01:03:46,830
So let me continue, right then,

801
01:03:48,960 --> 01:03:50,250
save this for just,

802
01:03:51,730 --> 01:03:54,010
it fetches auth.py,

803
01:03:54,100 --> 01:03:57,280
the server since the prefix,

804
01:04:03,180 --> 01:04:06,870
so basically sends you know these modifications, correct,

805
01:04:06,870 --> 01:04:09,900
the server can just return whatever it likes,

806
01:04:09,930 --> 01:04:13,110
then, you know, in this new plan, correct,

807
01:04:13,110 --> 01:04:15,270
where the fetches are being log,

808
01:04:15,540 --> 01:04:20,100
then, C constructs file system, using A and B,

809
01:04:20,310 --> 01:04:27,570
and then returns of course you know auth.py to the client, to the client or to the application

810
01:04:27,810 --> 01:04:33,450
and then it adds a fetch to the log,

811
01:04:35,720 --> 01:04:43,100
and uploads that log to the server,

812
01:04:43,340 --> 01:04:49,270
and then you know the, that does a fetch of you know bank.py,

813
01:04:51,760 --> 01:04:57,340
and you know the server, you know in previous example,

814
01:04:57,640 --> 01:05:00,760
first it sends just a prefix,

815
01:05:01,730 --> 01:05:02,870
so here's like prefix,

816
01:05:05,050 --> 01:05:10,350
now you know sends, now the client sends the whole thing, right,

817
01:05:10,350 --> 01:05:12,450
so sends the whole log

818
01:05:13,440 --> 01:05:18,300
and it, but if modifications are not in it,

819
01:05:18,810 --> 01:05:20,880
so and we'll have to send the whole log,

820
01:05:20,880 --> 01:05:21,810
well to send the whole log

821
01:05:21,810 --> 01:05:24,720
and must include the fetch from C, right,

822
01:05:25,080 --> 01:05:32,250
and so, if it doesn't, you know sends [] to see,

823
01:05:32,250 --> 01:05:39,000
it actually, sees C is actually not there, the read operation

824
01:05:39,330 --> 01:05:44,580
and basically the client will reject the log,

825
01:05:44,580 --> 01:05:47,130
because actually it's own fetch operation is actually not in it,

826
01:05:47,340 --> 01:05:52,080
so it's not possible for the server to pretend

827
01:05:52,080 --> 01:05:54,540
you know that to send the log later on,

828
01:05:54,540 --> 01:05:58,230
because actually the new log should have included that fetch operation,

829
01:05:58,530 --> 01:06:01,800
that was in it and update the C

830
01:06:01,800 --> 01:06:05,160
or the server cannot twice that fetch operation into here,

831
01:06:05,580 --> 01:06:08,940
to make it consistent what actually happened before,

832
01:06:09,120 --> 01:06:10,890
because that would be detected,

833
01:06:10,920 --> 01:06:15,630
because you know the modifications on the records of A and B are not, wouldn't check out.

834
01:06:18,420 --> 01:06:22,800
Okay, so basically what this really does is to sort of step back,

835
01:06:22,920 --> 01:06:24,720
is that you can think about this attack,

836
01:06:24,720 --> 01:06:29,910
that the server sort of pretends that the modification of A and B happen concurrently,

837
01:06:30,120 --> 01:06:31,950
with the C reading it,

838
01:06:32,100 --> 01:06:34,530
even though we know that actually it's not the case

839
01:06:34,530 --> 01:06:36,150
and by speaking the fetches in it,

840
01:06:36,360 --> 01:06:38,820
that attack cannot happen.

841
01:06:43,440 --> 01:06:46,020
I have two questions,

842
01:06:46,080 --> 01:06:52,920
maybe first just, if you could like define fork consistency and the fetch modify consistency,

843
01:06:52,920 --> 01:06:54,030
and then the second is,

844
01:06:54,360 --> 01:07:03,580
in this example, so what exactly is stopping the server from placing the fetch in the right place of the log.

845
01:07:03,820 --> 01:07:09,030
Because remember every log entry covers all its proceeding entries.

846
01:07:09,660 --> 01:07:10,530
Okay, so if.

847
01:07:10,530 --> 01:07:17,910
The server could not [slice] that, you know fetch you know after the prefix before the modification of A and B.

848
01:07:18,860 --> 01:07:21,260
So let's say it only wants to send the modification of A,

849
01:07:21,260 --> 01:07:24,650
it knows the hash of the modification of A and everything preceding it,

850
01:07:25,040 --> 01:07:27,680
and then it could insert the fetch to C there,

851
01:07:27,680 --> 01:07:28,610
because it knows that,

852
01:07:29,180 --> 01:07:31,100
it's a hash of that, and.

853
01:07:31,100 --> 01:07:32,240
Then they couldn't send that.

854
01:07:32,270 --> 01:07:34,340
Yeah but then they couldn't send the modification to B,

855
01:07:36,410 --> 01:07:39,560
because the modification would B you know is directly after A

856
01:07:39,590 --> 01:07:43,100
and so any must yeah and so it can't [splice] it between A and B either.

857
01:07:44,490 --> 01:07:45,450
I see, okay.

858
01:07:49,580 --> 01:07:53,270
Sorry, what was a problem with having it where it is in the picture?

859
01:07:55,470 --> 01:07:57,300
Well, where it is, now the picture is perfect,

860
01:07:57,360 --> 01:07:58,650
that's fine right,

861
01:07:58,710 --> 01:08:04,620
in fact you know this basically suggests you know that the fetch of C actually included the modification of A and B,

862
01:08:04,620 --> 01:08:06,000
like the blue was the real log.

863
01:08:06,760 --> 01:08:09,160
And we have the fetch to C in it

864
01:08:09,160 --> 01:08:11,680
and you know the everything to be perfect.

865
01:08:18,660 --> 01:08:21,570
So just to clarify the definition of fork consistent.

866
01:08:21,570 --> 01:08:23,940
Yeah, hold on, hold on a second because,I haven't talked this slide,

867
01:08:25,650 --> 01:08:27,720
I haven't talked about the definition of fork consistency,

868
01:08:27,720 --> 01:08:28,710
I'm gonna do that right now.

869
01:08:30,450 --> 01:08:30,990
Okay?

870
01:08:32,860 --> 01:08:35,050
So we're talking about fork consistency.

871
01:08:43,980 --> 01:08:47,640
So, so what we've seen so far is that,

872
01:08:47,640 --> 01:08:50,700
the server cannot really manipulate the log,

873
01:08:50,700 --> 01:08:53,580
it can only send prefixes or can hide parts,

874
01:08:53,580 --> 01:08:57,930
you can hide, it can send prefix back to the client,

875
01:08:58,110 --> 01:09:00,000
but it can't really modify the log,

876
01:09:00,030 --> 01:09:06,450
so just basically have an opportunity to you know sort of show different logs to different clients,

877
01:09:06,450 --> 01:09:10,020
and that is basically what fork consistency is.

878
01:09:10,320 --> 01:09:12,870
And so it cannot provide you know the kind of,

879
01:09:13,050 --> 01:09:16,860
the server cannot provide the type of persistence that we've seen so far in the past,

880
01:09:16,860 --> 01:09:19,920
name likely linearizability and external persistency and things like that,

881
01:09:19,920 --> 01:09:21,000
that's just not possible,

882
01:09:21,450 --> 01:09:22,620
but it can provide this,

883
01:09:22,620 --> 01:09:26,220
what this what the paper calls or introduces is fork consistency.

884
01:09:26,490 --> 01:09:30,090
And let me abstract a little bit away and to explain what that is.

885
01:09:30,620 --> 01:09:32,450
So let's say we have client A,

886
01:09:32,780 --> 01:09:34,520
we have the server S,

887
01:09:35,280 --> 01:09:37,290
and it has a log,

888
01:09:39,150 --> 01:09:41,550
and let's say I'm just gonna extract everything away,

889
01:09:41,550 --> 01:09:43,440
it has entries A B C and D and E,

890
01:09:45,540 --> 01:09:50,310
and, you know A you know whatever maybe you know [] entry to the log

891
01:09:50,460 --> 01:09:56,220
and you know, and that's basically [].

892
01:09:56,490 --> 01:09:58,890
And maybe we have another client B,

893
01:10:00,830 --> 01:10:07,880
and, what the server can do is sort of give the other client a completely different view of the world,

894
01:10:07,940 --> 01:10:12,150
by basically have another copy of the log or its own copy

895
01:10:12,150 --> 01:10:14,040
or give a different copy of the log,

896
01:10:14,040 --> 01:10:16,650
for example, maybe that log contains the record A,

897
01:10:17,150 --> 01:10:19,610
but then every operation of B does,

898
01:10:19,730 --> 01:10:22,790
goes into this log you know B1 B2,

899
01:10:22,820 --> 01:10:25,940
maybe even some operations from other clients, that also get this view

900
01:10:26,030 --> 01:10:27,170
and end up in this log,

901
01:10:27,320 --> 01:10:29,390
but they're not actually shown to A,

902
01:10:29,880 --> 01:10:34,020
you know A basically A may actually also add more entries to log,

903
01:10:34,020 --> 01:10:35,850
like maybe it had B C and E,

904
01:10:36,090 --> 01:10:39,270
and those are not actually shown to D,

905
01:10:39,600 --> 01:10:43,590
so these two logs to the [] view of A,

906
01:10:43,590 --> 01:10:45,060
you know it's completely consistent,

907
01:10:45,120 --> 01:10:47,430
because it's unaware of any of these changes,

908
01:10:48,000 --> 01:10:50,640
and to B you know this log looks completely consistent,

909
01:10:50,640 --> 01:10:53,250
because they're really aware of any A changes right,

910
01:10:54,330 --> 01:10:55,890
in this model of the world,

911
01:10:55,980 --> 01:11:00,240
the only sure shared communication place that is, there is the server,

912
01:11:00,270 --> 01:11:01,500
you know that is sort of the,

913
01:11:01,740 --> 01:11:06,780
you know the thing that you know shows you know what actually is the state of the system.

914
01:11:07,600 --> 01:11:09,940
And one way you can think about is,

915
01:11:09,940 --> 01:11:12,070
like in terms that we've talked about before,

916
01:11:12,100 --> 01:11:13,540
this is sort of like a split brain,

917
01:11:16,620 --> 01:11:21,660
you know basically you know A gets C1 view of the world,

918
01:11:21,660 --> 01:11:25,890
you know cooked up by by log that's consistent with A view

919
01:11:26,130 --> 01:11:28,590
and you know B you know it's another view of the world.

920
01:11:29,230 --> 01:11:32,590
And basically the servers sort of keeps them to carefully separate

921
01:11:32,800 --> 01:11:37,750
and and therefore can pretend that you know A is looking one,

922
01:11:38,200 --> 01:11:40,030
sees the left side of split brain,

923
01:11:40,060 --> 01:11:42,700
B is actually the right side of split brain.

924
01:11:43,830 --> 01:11:46,550
Okay? Does that make sense.

925
01:11:50,120 --> 01:11:52,130
So that's sort of what you know basically they're saying is,

926
01:11:52,130 --> 01:11:55,130
like you know we can't really do better than fork consistency,

927
01:11:55,160 --> 01:12:02,030
because it's always possible for the server to to basically make a copy of the log

928
01:12:02,300 --> 01:12:06,740
and then from then on, you know present different views for these clients.

929
01:12:07,200 --> 01:12:10,680
Now, S could not merge the two logs again, correct,

930
01:12:10,710 --> 01:12:12,450
these logs have to be separate,

931
01:12:12,450 --> 01:12:13,500
you know for A and B,

932
01:12:13,800 --> 01:12:14,820
because it could be,

933
01:12:14,820 --> 01:12:18,240
it's impossible for S to sort of take you know the logs,

934
01:12:18,240 --> 01:12:19,620
let them grow for a while

935
01:12:19,740 --> 01:12:22,320
and then basically splice these two logs together again.

936
01:12:22,940 --> 01:12:28,100
Because you know the, because these entries should protect all these preceding entries,

937
01:12:28,100 --> 01:12:30,560
these entries protect all the preceding entries with those

938
01:12:30,740 --> 01:12:32,780
and so you can't put them back together.

939
01:12:33,900 --> 01:12:35,520
And because the signatures wouldn't check out,

940
01:12:35,520 --> 01:12:38,880
because the signatures always covered the current entry for all the preceding entries.

941
01:12:40,370 --> 01:12:42,530
And so the only thing they are basically do,

942
01:12:42,530 --> 01:12:49,910
the server can do basically split the world, fork the world into different into two different logs,

943
01:12:50,960 --> 01:12:52,730
they might have a common log at the beginning,

944
01:12:52,790 --> 01:12:54,260
then to sort of fork them,

945
01:12:54,380 --> 01:12:57,590
now that you know A and B basically operate in different worlds.

946
01:13:01,400 --> 01:13:04,220
So, and that's sort of the definition fork consistency

947
01:13:04,220 --> 01:13:09,020
and that's basically the best you know this particular file system, this particular system can do,

948
01:13:09,080 --> 01:13:12,500
if there's, the only communication actually happens between S.

949
01:13:15,170 --> 01:13:16,580
Notice is actually by the way,

950
01:13:16,760 --> 01:13:20,810
that's sort of fork consistency is good enough for our particular applications zookeeper correct,

951
01:13:21,230 --> 01:13:28,190
because the, either the server shows the old version, you know without A B,

952
01:13:28,610 --> 01:13:31,730
or you know the server shows the S,

953
01:13:31,730 --> 01:13:33,830
you know the modification with A and B.

954
01:13:37,430 --> 01:13:38,960
Okay, so what do you do,

955
01:13:39,230 --> 01:13:41,480
it seems like you know maybe this is actually [],

956
01:13:41,480 --> 01:13:45,350
how do you detect forks and how could you.

957
01:13:52,050 --> 01:13:53,010
So how do you detect fork,

958
01:13:53,010 --> 01:13:57,300
well there's two schemes, that paper mentions,

959
01:13:57,630 --> 01:14:00,240
one is out-of-band communication,

960
01:14:10,220 --> 01:14:11,480
it is pretty straightforward,

961
01:14:12,050 --> 01:14:15,680
you know if you know A and B ever talk to each other,

962
01:14:16,430 --> 01:14:17,840
for example ask each other,

963
01:14:17,870 --> 01:14:19,700
hey, what did your last entry in the log

964
01:14:20,120 --> 01:14:21,740
and they get different answers,

965
01:14:22,440 --> 01:14:25,560
they know you know that they have been fork,

966
01:14:25,590 --> 01:14:28,650
because either they could have different answers,

967
01:14:28,650 --> 01:14:31,830
but at least then one should be the prefix of the other,

968
01:14:32,330 --> 01:14:34,040
and if that's not the case,

969
01:14:34,100 --> 01:14:37,430
then they know that they're actually being exactly fork.

970
01:14:40,660 --> 01:14:45,610
So, that's one possible scenario, that they discussed in the paper,

971
01:14:45,610 --> 01:14:51,730
basically share the clients periodically exchange during the last log entries,

972
01:14:52,630 --> 01:14:54,310
the last entry in their log.

973
01:14:54,460 --> 01:14:58,750
Another solution which actually has mentioned in the chat is,

974
01:14:59,700 --> 01:15:02,340
you know introduce what they call sort of trusted machine,

975
01:15:02,640 --> 01:15:06,270
that is time stamp box

976
01:15:08,400 --> 01:15:10,770
and basically like every few seconds,

977
01:15:10,770 --> 01:15:14,550
you know it actually ends adds a time stamp to the log

978
01:15:14,820 --> 01:15:20,460
and in every client, knows that you know, basically it's a file,

979
01:15:20,460 --> 01:15:23,490
in the file system that contains you know the current time,

980
01:15:23,610 --> 01:15:25,980
everytime the time stamp box,

981
01:15:25,980 --> 01:15:29,160
you know every couple seconds time stamp box updates that file,

982
01:15:29,370 --> 01:15:31,080
the clients read that file

983
01:15:31,170 --> 01:15:34,290
and they know there should be a new modification like every couple seconds.

984
01:15:35,070 --> 01:15:44,280
And that basically you know that that fork that contains the time stamp box is sort of the fork the the clients,

985
01:15:44,880 --> 01:15:47,820
the server actually has to present to the clients.

986
01:15:51,700 --> 01:15:52,330
Okay?

987
01:15:53,620 --> 01:15:56,050
So that's the two things that actually the paper discusses

988
01:15:56,260 --> 01:15:58,870
and what's sort of interesting and we'll see on Tuesday,

989
01:15:58,990 --> 01:16:03,580
is this, this whole fork detection in fork resolution approach

990
01:16:03,580 --> 01:16:05,860
is sort of a key problem basically in Bitcoin,

991
01:16:06,820 --> 01:16:08,710
and we will talking Tuesday,

992
01:16:08,710 --> 01:16:13,030
but Bitcoin you know we see a way basically to settle on a fork.

993
01:16:15,550 --> 01:16:18,130
So even if the file system or the servers,

994
01:16:18,130 --> 01:16:21,430
the Byzantine servers actually have created a fork,

995
01:16:21,700 --> 01:16:24,460
you know Bitcoin basically has a way of deciding,

996
01:16:24,460 --> 01:16:28,240
well we're gonna reads the [consensus] on like which fork we're going to actually proceed with.

997
01:16:29,380 --> 01:16:32,860
So we'll leave that up to Tuesday,

998
01:16:32,860 --> 01:16:38,020
but here sort of a connection between you know SUNDR and actually Bitcoin.

999
01:16:40,840 --> 01:16:41,770
Any questions about this?

1000
01:16:49,950 --> 01:16:50,490
Okay.

1001
01:16:51,540 --> 01:16:53,070
Okay, I want to talk very quickly,

1002
01:16:53,070 --> 01:16:54,480
because I got three minutes left,

1003
01:16:54,510 --> 01:16:59,300
about the other,

1004
01:16:59,300 --> 01:17:04,250
so I think the key thing I'll get the paper is actually this log conceptual view of the world,

1005
01:17:05,000 --> 01:17:08,060
of course the impractical as I mentioned earlier

1006
01:17:08,210 --> 01:17:10,880
and so some directly has a proposal for how to do better,

1007
01:17:11,150 --> 01:17:14,660
even though like other systems like going actually do maintain the whole log

1008
01:17:14,750 --> 01:17:17,930
and so what does somebody do things better,

1009
01:17:18,110 --> 01:17:19,700
instead of actually maintaining a log,

1010
01:17:19,700 --> 01:17:21,380
you know that's actually snapshots.

1011
01:17:22,140 --> 01:17:24,750
That's similar to sort of snapshots,

1012
01:17:24,750 --> 01:17:26,700
that we've seen before, in a raft,

1013
01:17:26,700 --> 01:17:30,240
where we construct the part of the world based on log,

1014
01:17:30,240 --> 01:17:31,320
we take a snapshot

1015
01:17:31,320 --> 01:17:34,110
and that actually forms the the current state,

1016
01:17:34,290 --> 01:17:37,440
in fact, really what the SUNDR does,

1017
01:17:37,440 --> 01:17:39,480
it actually doesn't really literally [take] snapshot,

1018
01:17:39,480 --> 01:17:42,330
it really maintains a snapshot view of the file system

1019
01:17:42,450 --> 01:17:43,620
and does it per user.

1020
01:17:46,100 --> 01:17:47,420
So one way to think about it is that,

1021
01:17:47,420 --> 01:17:49,820
that file systems is sharded by user,

1022
01:17:49,880 --> 01:17:52,880
every user has its own view snapshot of the world

1023
01:17:53,210 --> 01:17:55,100
and you know there's a little bit of protocol

1024
01:17:55,100 --> 01:18:00,320
to make sure that these different snapshots and different users are actually consistent.

1025
01:18:00,320 --> 01:18:04,550
And let me, talk a little bit about,

1026
01:18:04,610 --> 01:18:08,420
how actually SUNDR actually has makes the snapshot.

1027
01:18:09,950 --> 01:18:12,680
Basically in SUNDR,

1028
01:18:15,210 --> 01:18:17,760
and SUNDR basically there's something that's called the user i-handle,

1029
01:18:18,580 --> 01:18:22,780
and the user i-handle basically uniquely identifies snapshot in the file system

1030
01:18:23,050 --> 01:18:27,150
and basically is a cryptographic hash of the i-table,

1031
01:18:27,150 --> 01:18:29,460
which completes all the inodes in the system,

1032
01:18:29,790 --> 01:18:33,090
and you know and for every inode,

1033
01:18:33,090 --> 01:18:34,230
there's a hash inode,

1034
01:18:34,230 --> 01:18:38,400
it would basically covers all the data, all the blocks belong to that particular inode.

1035
01:18:39,170 --> 01:18:45,860
So, for example, when say A modifies auth.py in my write one block,

1036
01:18:46,190 --> 01:18:50,060
the client re-computes the hash of this block,

1037
01:18:50,090 --> 01:18:55,160
updates the entry here, updates the entry here, updates the entry here

1038
01:18:55,220 --> 01:18:57,140
and that's basically a new handle,

1039
01:18:57,320 --> 01:19:01,700
that describes basically the the capture you know the complete file system,

1040
01:19:01,970 --> 01:19:06,560
we're going to ignore the group in the directory block for a second,

1041
01:19:06,560 --> 01:19:09,890
so this basically gives you complete checkpoint,

1042
01:19:09,890 --> 01:19:14,360
where a snapshot of user to view of the file system,

1043
01:19:16,680 --> 01:19:19,680
now and then to deal with this issue,

1044
01:19:19,680 --> 01:19:23,640
of how to get a sort of consistency across users,

1045
01:19:23,970 --> 01:19:26,550
they have this notion of version vectors.

1046
01:19:33,740 --> 01:19:35,930
What version vector is pretty straightforward,

1047
01:19:36,530 --> 01:19:39,140
every version vector has, an i-handle,

1048
01:19:39,140 --> 01:19:46,800
like A has i-handle is in it after it modified, say auth.py

1049
01:19:46,860 --> 01:19:49,860
and then for every user in the system,

1050
01:19:49,980 --> 01:19:54,210
the version vector has a counter for the number of modifications, that were made by that user,

1051
01:19:54,300 --> 01:19:58,740
so if A made updated auth.py, that counter is set to one,

1052
01:19:59,010 --> 01:20:01,170
you know B didn't make any modifications,

1053
01:20:01,170 --> 01:20:04,320
you know C didn't make any modifications, zero zero,

1054
01:20:04,320 --> 01:20:06,030
and this whole thing is silent.

1055
01:20:09,520 --> 01:20:11,950
And so when B makes modifications,

1056
01:20:11,950 --> 01:20:17,170
so we use the version vector for B, A version vector, B version vector,

1057
01:20:17,800 --> 01:20:19,240
it creates a new handle,

1058
01:20:19,930 --> 01:20:24,550
that includes of course, all the modification, represents all the medications

1059
01:20:24,970 --> 01:20:26,380
and in its version handle,

1060
01:20:26,500 --> 01:20:28,120
it actually opened its version vector,

1061
01:20:28,150 --> 01:20:31,660
it includes which how many operations are read by [] user,

1062
01:20:31,660 --> 01:20:36,430
so it will record the fact, for example that it actually saw A's modification,

1063
01:20:36,700 --> 01:20:40,060
it updates B is to be 1, C is 0,

1064
01:20:40,270 --> 01:20:41,860
and basically signed to this whole thing.

1065
01:20:44,640 --> 01:20:49,200
You know C, when C actually does an operation,

1066
01:20:49,200 --> 01:20:51,300
want to read you know auth.py

1067
01:20:51,300 --> 01:20:57,120
and fetch you know and bank.py,

1068
01:20:57,180 --> 01:21:00,660
it basically downloads all the version vectors from every user,

1069
01:21:00,690 --> 01:21:02,490
you know and in this case,

1070
01:21:02,490 --> 01:21:05,130
it will get the first version vector for A and B,

1071
01:21:06,150 --> 01:21:08,760
takes the latest one, which in this case is B,

1072
01:21:09,150 --> 01:21:12,630
because actually it includes all the operations of A in it

1073
01:21:13,080 --> 01:21:15,900
and that's basically represented version of the file system,

1074
01:21:15,900 --> 01:21:20,820
from that version it reads you know auth.py and bank.py.

1075
01:21:24,180 --> 01:21:34,320
Note, you know that basically it's impossible for the server to basically present bank.py, not auth.py,

1076
01:21:34,320 --> 01:21:36,060
because you know it cannot,

1077
01:21:36,150 --> 01:21:39,540
you know it can only to sort of version factors can return is,

1078
01:21:39,540 --> 01:21:41,490
this version vector or this version vector,

1079
01:21:41,610 --> 01:21:46,590
version vector A doesn't include actually the changes of bank.py,

1080
01:21:46,770 --> 01:21:50,250
if C actually does get versions of bank.py,

1081
01:21:50,400 --> 01:21:54,420
it must actually have the versions, the modification A is made,

1082
01:21:54,690 --> 01:21:56,880
because the version vectors are constructed in that way.

1083
01:21:58,740 --> 01:22:03,000
And so that's basically the way for using version vectors

1084
01:22:03,060 --> 01:22:07,500
to detect the S doesn't drop changes,

1085
01:22:07,620 --> 01:22:10,440
as we as the same way that the logging system is done.

1086
01:22:12,020 --> 01:22:14,270
Okay, so that's the essence of the version vector plan.

1087
01:22:16,670 --> 01:22:18,380
So, in summary.

1088
01:22:22,770 --> 01:22:31,860
Okay, Byzantine participants you know sort of a problem you have to handle in decentralized systems,

1089
01:22:33,940 --> 01:22:37,540
because there's no single institution that sort of,

1090
01:22:37,540 --> 01:22:39,190
it can be source of trust

1091
01:22:40,420 --> 01:22:42,550
and we've seen this notion of signed logs,

1092
01:22:42,700 --> 01:22:48,730
it's a very powerful tool to deal with malicious servers.

1093
01:22:49,390 --> 01:22:52,570
And, as I said, on on Tuesday,

1094
01:22:52,570 --> 01:22:54,250
we're going to continue this discussion

1095
01:22:54,460 --> 01:22:58,780
and you'll see how this design logs are used in Bitcoin,

1096
01:22:58,840 --> 01:23:01,030
in particular like how fork consistency,

1097
01:23:01,030 --> 01:23:05,110
where how the fact that forks are sort of being created,

1098
01:23:05,140 --> 01:23:07,810
are being resolved in the case of Bitcoin.

1099
01:23:08,600 --> 01:23:12,800
Okay, so that was it for an introduction to the decentralized systems,

1100
01:23:13,130 --> 01:23:17,780
and I hope the paper a little bit more understandable

1101
01:23:17,780 --> 01:23:23,030
than maybe when before you start reading it earlier this week or today.

1102
01:23:23,430 --> 01:23:25,410
Okay, see you on Tuesday.

1103
01:23:26,860 --> 01:23:31,030
And of course, there's questions, feel free, please feel free to hang around,

1104
01:23:31,300 --> 01:23:34,570
if you need to go somewhere else, absolutely go somewhere else.

1105
01:23:35,920 --> 01:23:38,620
I have a question about the data structure,

1106
01:23:38,620 --> 01:23:42,550
that they use the B+ tree or whatever,

1107
01:23:42,550 --> 01:23:44,920
like what's the difference between that and like,

1108
01:23:45,830 --> 01:23:48,230
yeah, like the [] log, for example.

1109
01:23:48,350 --> 01:23:49,610
Using a [] data structure,

1110
01:23:49,820 --> 01:23:54,710
you know I think the person who sort of credited with his id is [],

1111
01:23:55,260 --> 01:23:58,050
and that's why it called the miracle data tree.

1112
01:24:00,080 --> 01:24:01,520
So this is the same thing?

1113
01:24:03,080 --> 01:24:03,650
Okay.

1114
01:24:04,130 --> 01:24:05,690
SUNDR basically uses a [] tree.

1115
01:24:11,800 --> 01:24:17,910
Sorry, when when you are verifying the the signatures,

1116
01:24:18,150 --> 01:24:19,230
doesn't mean you have to,

1117
01:24:19,230 --> 01:24:22,420
like, basically, as you go,

1118
01:24:22,420 --> 01:24:25,720
if you're a hundred entries into the log,

1119
01:24:26,110 --> 01:24:34,680
you have to compute the hash of all the 100 entries concatenated and then compute, and.

1120
01:24:34,680 --> 01:24:36,690
Yeah, you need to keep a running hash,

1121
01:24:36,720 --> 01:24:38,310
okay, let's go back to verify,

1122
01:24:45,550 --> 01:24:47,770
okay, so here is probably a good place to talk about it.

1123
01:24:48,480 --> 01:24:55,980
So, so here, so let's say, let's take the last entry, correct,

1124
01:24:57,460 --> 01:25:02,290
the last century will have a hash of the preceding entries,

1125
01:25:03,790 --> 01:25:06,250
so everything you know from the like whatever records,

1126
01:25:06,370 --> 01:25:18,400
let's say this is zero one and two 0 1 and 2, where basically has the hash of the previous entry number 2 in it,

1127
01:25:18,400 --> 01:25:21,790
and that needs to be, that needs to be checked.

1128
01:25:22,540 --> 01:25:27,340
And the way now this being checked is,

1129
01:25:27,340 --> 01:25:30,490
you know in principle, if you start really from the beginning of the world

1130
01:25:30,700 --> 01:25:33,370
and you would have to compute the hash with record 0,

1131
01:25:33,490 --> 01:25:34,840
you find out what the hash is

1132
01:25:35,140 --> 01:25:41,170
and double check that corresponds to the entry, that's in here

1133
01:25:41,170 --> 01:25:44,390
and that the signature is valid, etc, etc.

1134
01:25:46,060 --> 01:25:47,890
Of course, you know in the real system,

1135
01:25:47,890 --> 01:25:49,510
you can remember most of the log

1136
01:25:49,900 --> 01:25:51,460
and just double check that,

1137
01:25:51,460 --> 01:25:53,530
like whatever and start from there.

1138
01:25:56,040 --> 01:25:58,820
Oh, it's inefficient, okay.

1139
01:25:59,430 --> 01:26:01,200
Yeah, you have to replay from the beginning of time,

1140
01:26:01,200 --> 01:26:04,170
you basically have to really validate the whole log from the beginning of time.

1141
01:26:06,660 --> 01:26:08,190
Thank you, it makes sense.

1142
01:26:08,250 --> 01:26:10,020
You'll see this in the Bitcoin paper.

1143
01:26:10,940 --> 01:26:12,680
So are the hash is like,

1144
01:26:12,740 --> 01:26:14,930
almost like a [merkle] chain, like.

1145
01:26:14,930 --> 01:26:15,410
Yes.

1146
01:26:15,800 --> 01:26:17,660
Okay, same idea.

1147
01:26:18,680 --> 01:26:29,550
So, are they, like if like leaf in the sort of tree or chain,

1148
01:26:29,580 --> 01:26:32,820
like an entire file or like blocks of a file.

1149
01:26:32,850 --> 01:26:34,110
This is a block, one block,

1150
01:26:34,110 --> 01:26:36,270
so this 4096 bytes,

1151
01:26:43,580 --> 01:26:45,200
and all the other hashes don't change, correct,

1152
01:26:45,200 --> 01:26:47,480
so it's actually not that efficient inefficient.

1153
01:26:48,050 --> 01:26:49,910
Because if you only change part of the file,

1154
01:26:49,910 --> 01:26:51,410
that only rehashes that part.

1155
01:26:51,440 --> 01:26:52,640
Yeah you just have to rehash that one

1156
01:26:52,640 --> 01:26:55,160
and then you have to re-compute the hash of the tree,

1157
01:26:56,490 --> 01:26:57,990
all the way to the users i-handle.

1158
01:27:02,660 --> 01:27:06,080
The paper talks about, there's a sort of optimization to make this more efficient,

1159
01:27:06,140 --> 01:27:08,900
but hashing is generally not that expensive,

1160
01:27:08,900 --> 01:27:11,150
signing is a more expensive operation.

1161
01:27:18,380 --> 01:27:20,090
I had a question about version vectors,

1162
01:27:21,170 --> 01:27:25,460
so we use version vectors to make sure that the system can't return like an old state,

1163
01:27:25,700 --> 01:27:29,750
why can't the, why can't the system just return the old state and the old version vector,

1164
01:27:29,750 --> 01:27:31,370
if it keeps a second copy.

1165
01:27:31,940 --> 01:27:34,110
Yeah, got fork, right?

1166
01:27:34,110 --> 01:27:36,270
So we only have fork consistency, then.

1167
01:27:36,420 --> 01:27:40,830
Yeah, your version vectors only fork consistent, SUNDR fork consistent, no more.

1168
01:27:47,360 --> 01:27:50,000
So fork consistency, you need the timestamp?

1169
01:27:50,430 --> 01:27:59,580
The fork consistency, I mean, you know, the server can fork the log at any particular point in time,

1170
01:28:00,800 --> 01:28:05,450
present a consistent view of the what they can merge logs back together.

1171
01:28:07,750 --> 01:28:15,870
So, really this picture, that the server can actually construct you know different views of the world

1172
01:28:16,110 --> 01:28:18,810
and split you know the world, the multiple world,

1173
01:28:19,110 --> 01:28:24,350
but can emerge the world back together undetectably.

1174
01:28:27,070 --> 01:28:31,420
So, the best we can do is fork consistency,

1175
01:28:31,510 --> 01:28:33,100
which allows for forking,

1176
01:28:33,160 --> 01:28:34,750
but we can detect forking.

1177
01:28:35,990 --> 01:28:37,520
So if we detect forking,

1178
01:28:38,260 --> 01:28:40,870
can we then get something stronger than fork consistency?

1179
01:28:40,870 --> 01:28:43,540
Well, yep, well, we can settle on a fork,

1180
01:28:43,720 --> 01:28:44,770
we're gonna have forks,

1181
01:28:44,860 --> 01:28:48,460
we can try to settle like pick one forks one to go forward with.

1182
01:28:49,440 --> 01:28:50,220
Okay,

1183
01:28:51,270 --> 01:28:54,210
but SUNDR doesn't have a way to do that.

1184
01:29:00,130 --> 01:29:03,910
I mean SUNDR does propose some some methods now?

1185
01:29:04,240 --> 01:29:11,320
Methods to detect and basically you know basically proposes like you use the timestamp box to use that one.

1186
01:29:17,110 --> 01:29:17,770
Thanks.

1187
01:29:18,100 --> 01:29:18,640
You're welcome.

1188
01:29:20,640 --> 01:29:25,560
The timestamp timestamp box just a server that appends entries.

1189
01:29:25,560 --> 01:29:30,000
And is trusted, it was not under control of the adversary.

1190
01:29:35,280 --> 01:29:36,000
Thank you.

1191
01:29:38,050 --> 01:29:43,150
Can I also ask one final question about the debian example, you set up in beginning,

1192
01:29:43,630 --> 01:29:46,870
can you say again what happened there.

1193
01:29:47,020 --> 01:29:48,130
Yeah, sure,

1194
01:29:48,730 --> 01:29:57,940
so basically the this is the source repo or develop machines for debian Linux in 2003,

1195
01:29:57,940 --> 01:30:03,490
an attacker compromised broke into this machines and modified files,

1196
01:30:05,330 --> 01:30:09,860
and this is the distribution that has been sort of handed off you know which you know if you're on debian Linux,

1197
01:30:09,860 --> 01:30:10,940
you know you're you're,

1198
01:30:11,560 --> 01:30:14,950
anybody who got like the debian linux after attack,

1199
01:30:14,950 --> 01:30:17,050
you've got maybe a compromise debian Linux.

1200
01:30:17,770 --> 01:30:19,630
And so when they soon as they discovered this,

1201
01:30:19,630 --> 01:30:22,510
they didn't do any further development

1202
01:30:22,840 --> 01:30:24,340
and they were refer to distributions,

1203
01:30:24,340 --> 01:30:26,740
sorted out like they went to backups,

1204
01:30:26,740 --> 01:30:31,150
you know started comparing files from backups, with files that they have,

1205
01:30:31,150 --> 01:30:36,400
and you know basically double check that all the changes that were in the repo are actually legit.

1206
01:30:38,070 --> 01:30:38,400
Okay.

1207
01:30:38,400 --> 01:30:40,680
Rollback and rollback any changes are not legit.

1208
01:30:42,300 --> 01:30:44,520
That's pretty bad.

1209
01:30:44,670 --> 01:30:46,500
Yeah, that's pretty bad,

1210
01:30:46,500 --> 01:30:47,460
it occasionally happens,

1211
01:30:47,460 --> 01:30:48,390
this is a real problem,

1212
01:30:49,660 --> 01:30:50,920
that's a real problem in practice.

1213
01:30:52,230 --> 01:30:54,900
Thank you so much that was very interesting lecture, thank you.

1214
01:30:54,900 --> 01:30:55,350
You're welcome.

1215
01:30:56,810 --> 01:30:57,500
Thank you.

