1
00:00:00,000 --> 00:00:02,790
傍晚好，晚上好，无论你在哪里，

2
00:00:02,820 --> 00:00:03,780
我们开始吧。

3
00:00:04,440 --> 00:00:08,310
今天，我想谈谈链式复制，

4
00:00:08,310 --> 00:00:12,450
今天的论文来自 2004 ，

5
00:00:12,450 --> 00:00:14,280
在深入研究这篇论文之前，

6
00:00:14,280 --> 00:00:18,270
我想提醒你几件后勤上的事，

7
00:00:18,810 --> 00:00:22,530
一是我们周四有个测验，

8
00:00:23,830 --> 00:00:28,600
测验的所有主题说明

9
00:00:28,600 --> 00:00:29,770
都在课程表页面上，

10
00:00:29,800 --> 00:00:34,480
我们会在 Piazza 上发布公告，包含更多细节，

11
00:00:34,780 --> 00:00:37,720
关于我们怎么做测验，

12
00:00:38,020 --> 00:00:39,700
它将在[年级范围]内，

13
00:00:39,730 --> 00:00:44,380
是在上课时间 80 分钟，

14
00:00:44,470 --> 00:00:48,130
以及后续更多细节。

15
00:00:49,010 --> 00:00:55,340
第二个我想提醒大家的是项目，

16
00:00:56,790 --> 00:00:59,730
如果你想做一个项目而不是实验 4 ，

17
00:01:00,120 --> 00:01:05,090
那么你可以这么做，

18
00:01:05,090 --> 00:01:07,880
但你应该提交一份项目建议书，

19
00:01:07,880 --> 00:01:12,920
使用几个段落，通过提交网站提交，

20
00:01:12,950 --> 00:01:14,840
这样我们就可以给你反馈，

21
00:01:14,840 --> 00:01:19,790
告诉你这个项目是否适合 6.824 的期末项目，

22
00:01:20,300 --> 00:01:22,310
如果你只是计划去做实验 4 ，

23
00:01:22,340 --> 00:01:23,930
你不需要做任何事情。

24
00:01:25,240 --> 00:01:31,830
对这两个[后勤点]，有什么问题吗？

25
00:01:36,270 --> 00:01:41,040
好的，那么，让我转移到另一点，

26
00:01:41,040 --> 00:01:41,910
我想提出，

27
00:01:41,910 --> 00:01:50,550
就是之前课程的正确性，

28
00:01:50,760 --> 00:01:53,670
我们演练了 Go 代码

29
00:01:53,670 --> 00:01:57,570
关于我的 raft 实现 2a 2b ，

30
00:01:57,840 --> 00:02:02,010
我们谈了关于 Go defer 语句的事情，

31
00:02:02,400 --> 00:02:04,260
我提到过，

32
00:02:04,260 --> 00:02:07,470
你可以将 defer 语句放在基本块中，

33
00:02:07,530 --> 00:02:09,300
这是正确的，

34
00:02:09,750 --> 00:02:11,970
我认为可能是 Felipe 提出了这个问题，

35
00:02:11,970 --> 00:02:14,880
这个到底是什么时候执行的，

36
00:02:14,880 --> 00:02:16,680
我对这个问题的回答有误，

37
00:02:17,040 --> 00:02:19,230
defer 语句被执行

38
00:02:19,230 --> 00:02:21,150
在从函数返回时，

39
00:02:21,150 --> 00:02:22,920
而不是在基础块返回的时候，

40
00:02:23,350 --> 00:02:26,860
所以，我对任何引起的疑惑表示抱歉。

41
00:02:29,980 --> 00:02:34,390
对于这个澄清，有什么问题吗？

42
00:02:37,610 --> 00:02:38,270
好的？

43
00:02:38,870 --> 00:02:40,130
好的，有两个主题，

44
00:02:40,130 --> 00:02:41,900
都是技术讨论，

45
00:02:41,900 --> 00:02:44,330
今天我想谈的是 zookeeper 的锁，

46
00:02:44,450 --> 00:02:47,450
上次我没能完成，

47
00:02:48,250 --> 00:02:50,770
然后我将讨论链式复制。

48
00:02:51,790 --> 00:02:52,390
好的？

49
00:02:52,900 --> 00:02:56,770
对于链式复制和 zookeeper 来说，

50
00:02:56,770 --> 00:03:01,060
我们仍然处在和以前一样的环境中，

51
00:03:01,610 --> 00:03:05,660
也就是，我们在做复制状态机。

52
00:03:07,240 --> 00:03:09,700
这是一张常见的图，

53
00:03:10,270 --> 00:03:12,370
我们有服务器，

54
00:03:12,370 --> 00:03:17,950
它运行一些复制库，比如 ZAB 或 Raft ，

55
00:03:20,220 --> 00:03:22,950
我们有客户端与服务器交互，

56
00:03:22,950 --> 00:03:25,680
例如在 zookeeper 的情况中，

57
00:03:25,740 --> 00:03:27,480
可能发送 create 调用，

58
00:03:28,440 --> 00:03:31,890
zookeeper 内部有一些状态，一些 znode ，

59
00:03:31,890 --> 00:03:34,470
它们是以树的形式存在的，

60
00:03:34,860 --> 00:03:36,480
所以，当一个操作进来时，

61
00:03:36,480 --> 00:03:41,910
zookeeper 把这个操作转发给 ZAB 库，

62
00:03:41,910 --> 00:03:43,830
它会来回聊天，

63
00:03:44,240 --> 00:03:46,280
为了获得服务器的大多数，

64
00:03:46,280 --> 00:03:48,830
为了接受那个命令，

65
00:03:49,070 --> 00:03:50,000
然后在某个时刻，

66
00:03:50,000 --> 00:03:52,430
一旦它被接受，它出来了，

67
00:03:52,430 --> 00:03:54,320
服务器应用了操作，

68
00:03:54,530 --> 00:03:56,390
并将响应发送回客户端，

69
00:03:56,690 --> 00:03:59,450
所以这是复制状态机的标准故事，

70
00:03:59,450 --> 00:04:00,170
如果你启动，

71
00:04:00,440 --> 00:04:02,930
所有复制状态机都会以相同的状态启动，

72
00:04:02,930 --> 00:04:05,120
你以相同的顺序应用相同的操作，

73
00:04:05,180 --> 00:04:06,950
然后你就会以同样的状态结束，

74
00:04:06,950 --> 00:04:09,770
所以，如果有必要，任何一台机器都可以接管。

75
00:04:11,430 --> 00:04:15,630
现在，关于 zookeeper 有趣的事情之一是，

76
00:04:15,630 --> 00:04:20,610
读操作可有由任何服务器提供，

77
00:04:20,820 --> 00:04:23,340
对于任何节点或任何一个服务器，

78
00:04:23,790 --> 00:04:26,280
这使得 zookeeper 拥有极高的性能，

79
00:04:26,280 --> 00:04:31,650
因为你可以通过扩展服务器的数量来扩展读操作的数量，

80
00:04:32,190 --> 00:04:34,320
作为它的另一面，

81
00:04:34,350 --> 00:04:36,870
zookeeper 放弃了，

82
00:04:36,870 --> 00:04:39,150
在特定场景下，

83
00:04:39,150 --> 00:04:40,650
放弃了线性一致性。

84
00:04:49,920 --> 00:04:52,530
因为我们知道，比如在 Raft 中，

85
00:04:52,530 --> 00:04:56,430
我们不能从任何服务器进行读取，

86
00:04:56,550 --> 00:05:00,900
因为我还没有看到最新的更新，

87
00:05:00,900 --> 00:05:02,250
所以在 zookeeper 的情况下，

88
00:05:02,250 --> 00:05:04,080
这是[]，

89
00:05:04,260 --> 00:05:08,940
读操作不是，

90
00:05:08,940 --> 00:05:13,200
或者 zookeeper 定义的操作不提供线性化的接口。

91
00:05:13,960 --> 00:05:17,050
尽管如此，我们看到是，

92
00:05:17,080 --> 00:05:20,770
它提供了一种与线性一致性略微不同的正确性保证，

93
00:05:21,070 --> 00:05:25,390
而且这种正确性保证是有用的，

94
00:05:25,600 --> 00:05:28,750
并且足够有用，能够编写实际的程序，

95
00:05:28,750 --> 00:05:34,570
zookeeper 所关注的特定程序是，

96
00:05:34,600 --> 00:05:43,760
他们称为配置或协调程序。

97
00:05:52,220 --> 00:05:53,780
所以想一想这件事，

98
00:05:53,780 --> 00:05:56,630
过去我们看到了很多系统，

99
00:05:56,630 --> 00:05:58,850
它们通常有一些复制的故事，

100
00:05:58,850 --> 00:06:05,090
它们有 coordinator master 用来协调组，

101
00:06:05,090 --> 00:06:08,750
zookeeper 想要的是作为一个服务，

102
00:06:08,750 --> 00:06:12,560
对于那种 master 或 coordinator 的角色，

103
00:06:12,770 --> 00:06:16,280
它提供了一系列原语来实现这一点，

104
00:06:16,370 --> 00:06:22,670
我们上周讨论了原子增加，

105
00:06:22,670 --> 00:06:24,860
和一些其他服务，

106
00:06:24,860 --> 00:06:28,130
想通过谈论锁来结束。

107
00:06:28,840 --> 00:06:31,840
第一，因为有很多关于它的问题，

108
00:06:31,840 --> 00:06:33,310
第二，它是非常有趣的，

109
00:06:33,760 --> 00:06:36,370
这里有两种不同的锁实现。

110
00:06:36,370 --> 00:06:38,050
首先我想谈谈简单的那个，

111
00:06:38,290 --> 00:06:42,700
让我写下伪代码，

112
00:06:42,820 --> 00:06:45,460
然后我们可以谈谈细节，

113
00:06:45,670 --> 00:06:51,700
所以锁的伪代码是像这样，

114
00:06:51,700 --> 00:06:54,130
acquire ，在一个无限循环中，

115
00:06:54,400 --> 00:06:56,410
试着创建锁文件，

116
00:07:01,190 --> 00:07:05,310
命名为 lf ，并将 ephmeral 设置为 true ，

117
00:07:11,460 --> 00:07:13,110
我们稍后会讨论为什么。

118
00:07:13,170 --> 00:07:15,300
如果创建成功，

119
00:07:16,120 --> 00:07:18,730
然后那个进程，

120
00:07:18,730 --> 00:07:21,160
第一个创建文件的客户端，

121
00:07:21,160 --> 00:07:23,860
成功地获得了锁

122
00:07:23,860 --> 00:07:26,080
所以，它打破 for 循环并返回。

123
00:07:26,980 --> 00:07:31,160
如果客户端没有，

124
00:07:31,190 --> 00:07:32,630
创建一个文件，

125
00:07:32,630 --> 00:07:34,340
然后它调用 exists ，

126
00:07:34,920 --> 00:07:39,060
调用 exists 并不是为了看它是否存在，

127
00:07:39,060 --> 00:07:41,010
因为它并不存在，

128
00:07:41,310 --> 00:07:43,020
就是设置一个 watch ，

129
00:07:47,420 --> 00:07:51,230
想法是， watch 会触发，

130
00:07:51,230 --> 00:07:52,940
如果文件消失了，

131
00:07:53,900 --> 00:07:55,850
如果它消失了，

132
00:07:55,850 --> 00:07:57,860
客户端会收到通知，

133
00:07:57,860 --> 00:08:00,380
所以我们在这里要做的是

134
00:08:00,380 --> 00:08:01,640
等待通知。

135
00:08:09,390 --> 00:08:11,490
所以这是 acquire 操作，

136
00:08:11,640 --> 00:08:14,790
然后 release 就很简单了。

137
00:08:17,080 --> 00:08:19,180
release 基本上不做任何其他事情，

138
00:08:19,180 --> 00:08:22,600
只是发送 delete 操作到 zookeeper 服务，

139
00:08:22,810 --> 00:08:24,640
对于锁文件来说，

140
00:08:25,440 --> 00:08:26,880
在这种情况下是 lf 。

141
00:08:27,800 --> 00:08:29,030
那么这是做什么，

142
00:08:29,030 --> 00:08:32,540
如果 delete 发送给 zookeeper 服务，

143
00:08:32,540 --> 00:08:36,650
zookeeper 服务执行 delete 操作，

144
00:08:37,010 --> 00:08:42,020
这将会让文件消失，

145
00:08:42,140 --> 00:08:44,000
会通知 watch ，

146
00:08:44,150 --> 00:08:46,490
所以每个在等待的客户端，

147
00:08:46,490 --> 00:08:48,920
对于通知，

148
00:08:48,920 --> 00:08:50,060
将会收到一条通知，

149
00:08:50,300 --> 00:08:51,440
然后它们会去重试，

150
00:08:52,100 --> 00:08:55,190
它们中的一个将在重试中成功，

151
00:08:55,190 --> 00:08:57,290
将获取锁文件或创建锁文件，

152
00:08:57,350 --> 00:08:58,160
然后继续，

153
00:08:58,340 --> 00:09:01,850
然后其他的又回到那里，

154
00:09:02,060 --> 00:09:06,080
调用 exists 并等待通知。

155
00:09:07,280 --> 00:09:10,460
zookeeper 语义足够好，

156
00:09:10,490 --> 00:09:15,290
对写操作的线性一致性，

157
00:09:15,350 --> 00:09:18,590
加上通知发出的规则，

158
00:09:18,650 --> 00:09:21,770
足够强，来实现一个[]锁，

159
00:09:21,950 --> 00:09:23,630
只有一个客户端，

160
00:09:23,630 --> 00:09:25,820
如果同时有多个客户端试图获取锁，

161
00:09:25,820 --> 00:09:26,840
只有一个会得到它。

162
00:09:27,260 --> 00:09:29,870
当 release 完成时，

163
00:09:29,870 --> 00:09:31,670
或者当文件被删除时，

164
00:09:31,730 --> 00:09:33,860
在下一轮中只有一个能拿到它。

165
00:09:34,620 --> 00:09:36,510
所以这有点酷，

166
00:09:36,900 --> 00:09:38,220
它是有趣的，

167
00:09:38,220 --> 00:09:42,480
你可以构建某种基础原语，

168
00:09:42,570 --> 00:09:45,600
使用 zookeeper 提供的原语。

169
00:09:46,280 --> 00:09:47,930
你看这两个角色，

170
00:09:47,960 --> 00:09:52,910
watch 和第二个角色 ephemeral ，

171
00:09:52,910 --> 00:09:54,770
ephemeral 在这里，

172
00:09:54,770 --> 00:09:59,090
因为，如果客户端失败或崩溃，

173
00:09:59,090 --> 00:10:00,440
在它调用 release 之前，

174
00:10:00,680 --> 00:10:03,740
ephemeral 文件的语义，

175
00:10:03,740 --> 00:10:05,630
zookeeper 服务将会，

176
00:10:05,840 --> 00:10:07,370
如果它确定客户端已经崩溃，

177
00:10:07,370 --> 00:10:09,740
它会执行操作，

178
00:10:09,740 --> 00:10:13,250
它将删除代表客户端的文件，

179
00:10:13,340 --> 00:10:16,460
所以，即使客户端出现故障或崩溃，

180
00:10:16,760 --> 00:10:18,230
zookeeper 服务[]，

181
00:10:18,230 --> 00:10:19,910
某个时刻，客户端掉线，

182
00:10:20,060 --> 00:10:22,520
这将删除文件锁 f ，

183
00:10:22,580 --> 00:10:24,710
这将导致发送通知

184
00:10:24,710 --> 00:10:26,570
到等待它的其他客户端。

185
00:10:27,450 --> 00:10:30,960
所以，这是一组很酷的原语，

186
00:10:30,960 --> 00:10:34,680
构建在应用程序中有用的强大[抽象]。

187
00:10:35,870 --> 00:10:40,830
这个实现的一个缺点是，

188
00:10:41,100 --> 00:10:43,110
它具有所谓的羊群效应，

189
00:10:43,470 --> 00:10:46,860
也就是说，假设你有一千个客户端，

190
00:10:46,860 --> 00:10:50,670
想要获取锁文件或创建锁文件，

191
00:10:50,670 --> 00:10:51,750
获取锁，

192
00:10:51,960 --> 00:10:54,210
一个会成功，

193
00:10:54,360 --> 00:10:59,190
999 将调用 exists 并等待通知，

194
00:10:59,700 --> 00:11:04,860
然后当第一个客户端删除文件或释放文件锁时，

195
00:11:05,940 --> 00:11:10,110
999 将尝试获取锁，

196
00:11:10,750 --> 00:11:12,460
当然，只有一个会成功，

197
00:11:12,460 --> 00:11:15,010
998 将会等待通知，

198
00:11:15,790 --> 00:11:18,400
但你知道这个，

199
00:11:18,400 --> 00:11:20,500
每一个随机消失，

200
00:11:20,500 --> 00:11:21,760
会产生巨大的流量，

201
00:11:21,910 --> 00:11:26,290
基本上就是轰炸 zookeeper 服务器，

202
00:11:27,220 --> 00:11:30,250
999 尝试重新执行，

203
00:11:30,340 --> 00:11:33,880
除了一个，所有都会失败。

204
00:11:34,610 --> 00:11:40,490
所以这是不受欢迎的性质，这种羊群效应，

205
00:11:40,490 --> 00:11:42,260
这在实践中是一个真正的问题，

206
00:11:42,260 --> 00:11:45,950
在小规模的多核机器上移动，

207
00:11:45,950 --> 00:11:47,810
当然还有像这样的设置，

208
00:11:47,810 --> 00:11:50,090
网络消息不是免费的。

209
00:11:51,390 --> 00:11:54,540
所以，有趣的是， zookeeper 提供了足够的原语，

210
00:11:54,540 --> 00:11:56,070
你可以做得更好，

211
00:11:56,070 --> 00:11:57,390
你可以创建一个锁，

212
00:11:57,480 --> 00:12:00,420
不会受到羊群效应的影响。

213
00:12:01,310 --> 00:12:02,660
所以更好的锁，

214
00:12:08,950 --> 00:12:10,180
它是非常有趣的，

215
00:12:10,180 --> 00:12:14,560
让我找出这个的伪代码，

216
00:12:15,180 --> 00:12:16,260
在论文中，

217
00:12:16,290 --> 00:12:17,790
这样我们就能看到它了，

218
00:12:18,730 --> 00:12:21,250
并讨论为什么这个锁更好，

219
00:12:21,940 --> 00:12:24,550
我们看到的是这个锁更好，

220
00:12:24,550 --> 00:12:28,130
因为这里没有重试，

221
00:12:28,130 --> 00:12:33,740
所有未成功获取锁的客户端都将重试获取，

222
00:12:33,770 --> 00:12:37,700
相反，所有的客户端都排成一条线，

223
00:12:37,850 --> 00:12:40,280
它们可以一个接一个地获取锁。

224
00:12:40,900 --> 00:12:44,740
你可以 zookeeper 原语编程的方式，

225
00:12:44,950 --> 00:12:46,990
像这个伪代码一样。

226
00:12:47,740 --> 00:12:51,310
这与上一个有些不同，

227
00:12:51,730 --> 00:12:53,680
首先，这个，

228
00:12:56,180 --> 00:13:00,200
这有一个额外的传递给 create 的标志，即 SEQUENTIAL ，

229
00:13:00,560 --> 00:13:02,030
这意味着，

230
00:13:02,030 --> 00:13:04,490
当创建这些文件时，

231
00:13:04,520 --> 00:13:06,320
锁文件被创建，

232
00:13:06,320 --> 00:13:10,160
但它将被创建为，第一个将是 lock-0 ，

233
00:13:10,190 --> 00:13:12,980
下一个将是 lock-1 ，依此类推。

234
00:13:16,920 --> 00:13:18,780
所以，我们有一千个客户端

235
00:13:18,780 --> 00:13:22,170
争先恐后地到服务上试图获取锁，

236
00:13:22,260 --> 00:13:24,540
基本上会创建一千个文件，

237
00:13:24,570 --> 00:13:27,420
所有的数字是从 0 到 999 。

238
00:13:28,750 --> 00:13:31,030
然后，那么。

239
00:13:31,600 --> 00:13:33,370
所以，我将成功创建一个文件，

240
00:13:33,400 --> 00:13:39,940
创建者返回你得到的数字，

241
00:13:39,940 --> 00:13:41,140
所以如果客户端 0 ，

242
00:13:41,140 --> 00:13:44,680
如果第一个客户端创建了 lock-0 ，

243
00:13:44,770 --> 00:13:46,480
那么它将获得 0 ，

244
00:13:46,510 --> 00:13:48,760
第二个将得到 1 ，依此类推。

245
00:13:49,780 --> 00:13:51,910
然后伪代码要求，

246
00:13:51,910 --> 00:13:55,240
获取这个目录中的所有子项，

247
00:13:55,270 --> 00:13:57,100
那些文件被创建的，

248
00:13:57,130 --> 00:13:57,970
所以在这种情况下，

249
00:13:57,970 --> 00:14:01,840
可能有一千个子节点，一千个 znode ，

250
00:14:02,200 --> 00:14:04,990
然后你可以查看 n ，

251
00:14:05,480 --> 00:14:08,210
看看你的 n ，

252
00:14:08,270 --> 00:14:11,240
在这种情况下， 0 是要查看的最小 znode ，

253
00:14:11,240 --> 00:14:13,370
如果是这样的话，就意味着你拿到了锁。

254
00:14:13,880 --> 00:14:15,020
所以这完全有道理，

255
00:14:15,020 --> 00:14:17,780
第一行得到了 0 ，

256
00:14:17,780 --> 00:14:19,280
所有其他客户端都有更高的数字，

257
00:14:19,280 --> 00:14:20,540
因为它们是按顺序编号的，

258
00:14:20,840 --> 00:14:23,120
所以，第一个客户端将成功地获得它，

259
00:14:23,120 --> 00:14:26,240
而所有其他，它们要做的是，

260
00:14:26,420 --> 00:14:27,860
它们会查看，

261
00:14:27,860 --> 00:14:29,420
它们会找到 p ，

262
00:14:29,810 --> 00:14:31,760
这个数字正好在它前面，

263
00:14:31,790 --> 00:14:33,530
例如，如果这是客户端，

264
00:14:33,950 --> 00:14:36,320
它获得 lock-10 ，

265
00:14:36,410 --> 00:14:40,340
它将查找 znode 9 ， lock-9 ，

266
00:14:40,400 --> 00:14:42,260
在那个文件上放一个 watch ，

267
00:14:45,760 --> 00:14:50,680
这意味着每个客户端都有一个 watch 在它的前一个节点，

268
00:14:50,770 --> 00:14:53,950
所以所有的客户都排成一条线，

269
00:14:54,250 --> 00:15:00,260
然后，客户端等待通知发出。

270
00:15:00,850 --> 00:15:05,110
这意味着，例如，当客户端 0 得到 0 ，

271
00:15:05,110 --> 00:15:06,790
释放锁，

272
00:15:06,820 --> 00:15:07,960
它将删除 n ，

273
00:15:08,470 --> 00:15:12,220
文件 1 将收到通知发出，

274
00:15:13,010 --> 00:15:15,860
所以，客户端正在等待该通知，

275
00:15:15,860 --> 00:15:18,260
然后运行，

276
00:15:18,500 --> 00:15:20,540
但它是唯一可以运行的，

277
00:15:20,840 --> 00:15:24,050
而且它会成功。

278
00:15:25,330 --> 00:15:26,440
所以我们在这里看到，

279
00:15:26,440 --> 00:15:29,500
这有时是一种更简单的锁，称为标签锁，

280
00:15:30,640 --> 00:15:32,500
在多核编程中，

281
00:15:32,500 --> 00:15:33,520
如果你对它们很熟悉，

282
00:15:33,670 --> 00:15:37,600
它们在某种程度上与标签锁是相同的想法，

283
00:15:37,600 --> 00:15:41,890
你将使用 zookeeper 原语构建这个。

284
00:15:42,580 --> 00:15:44,830
再说一次，有趣的是，

285
00:15:45,190 --> 00:15:47,170
这些原语足够强大，

286
00:15:47,170 --> 00:15:48,850
你可以创建这种锁。

287
00:15:51,260 --> 00:15:52,370
对于这个，有什么问题吗？

288
00:15:57,840 --> 00:16:01,410
好的，关于这些锁，我想再说一句，

289
00:16:01,620 --> 00:16:05,070
在进入链式复制之前。

290
00:16:05,340 --> 00:16:06,540
我们在聊天中有一个问题。

291
00:16:06,690 --> 00:16:08,430
好的，聊天中的问题是什么？

292
00:16:08,430 --> 00:16:11,550
第 4 行的 watch 是做什么的？

293
00:16:12,140 --> 00:16:15,230
好的，回去，在这个第 4 行吗？

294
00:16:17,480 --> 00:16:18,560
是的，我想这就是问题。

295
00:16:19,580 --> 00:16:23,060
好的，这个 watch ，我的注释，

296
00:16:23,060 --> 00:16:25,940
这个 watch 应该在第 5 行，

297
00:16:26,500 --> 00:16:28,540
所以在第 4 行没有 watch ，

298
00:16:29,590 --> 00:16:34,090
第 4 行只是查找 p ，你的 n 之前的数字，

299
00:16:39,850 --> 00:16:41,050
如果这没有回答问题，

300
00:16:41,050 --> 00:16:42,880
你可以晚点再提问，也可以。

301
00:16:43,570 --> 00:16:45,220
事实上，我还有一个问题。

302
00:16:45,370 --> 00:16:45,910
嗯。

303
00:16:45,910 --> 00:16:48,040
我想回退几张幻灯片，

304
00:16:48,040 --> 00:16:51,430
但是 zookeeper 如何确定客户失败，

305
00:16:51,430 --> 00:16:53,440
从而释放 ephemeral 锁，

306
00:16:53,740 --> 00:16:56,980
比如通常只是短暂出现分区。

307
00:16:57,440 --> 00:17:00,650
是的，所以这是可能的，

308
00:17:00,650 --> 00:17:01,820
所以客户端可能会，

309
00:17:01,820 --> 00:17:05,600
客户端有一个与 zookeeper 服务交互的 session ，

310
00:17:06,020 --> 00:17:08,480
客户端需要，

311
00:17:08,480 --> 00:17:12,890
zookeeper 和客户端互相发送心跳，

312
00:17:12,890 --> 00:17:17,450
如果 zookeeper 服务一段时间没有收到客户端的心跳，

313
00:17:17,540 --> 00:17:20,510
然后，它决定客户端掉线并关闭会话。

314
00:17:21,600 --> 00:17:24,450
客户端尝试在会话上发送消息，

315
00:17:24,450 --> 00:17:26,010
但是会话已经关闭，已经消失，

316
00:17:26,550 --> 00:17:28,470
任何被创建的文件，

317
00:17:28,470 --> 00:17:32,700
这个会话期间创建的 ephemeral 文件会被删除，

318
00:17:34,860 --> 00:17:39,780
如果网络恢复，

319
00:17:39,870 --> 00:17:42,780
客户端尝试通过那个 session 发送消息，

320
00:17:42,780 --> 00:17:46,590
zookeeper 服务会说那个 session 已经不存在了，

321
00:17:47,370 --> 00:17:49,470
你必须重试或重新开始一个新的 session 。

322
00:17:50,830 --> 00:17:51,700
知道了，谢谢。

323
00:17:53,470 --> 00:17:56,500
好的，有一点很重要，

324
00:17:56,500 --> 00:17:59,860
我称为  zlock ， zookeeper 锁，

325
00:18:00,850 --> 00:18:05,110
它们并不相同或具有相似的语义，

326
00:18:05,110 --> 00:18:08,080
你正在使用的锁， Go 锁或 mutex 。

327
00:18:09,360 --> 00:18:11,400
这是一个需要注意的重要问题，

328
00:18:11,400 --> 00:18:12,960
即使它们不同，

329
00:18:12,960 --> 00:18:14,490
我们一会儿就会知道，它们仍然很有用，

330
00:18:14,490 --> 00:18:17,610
但它们不像 Go 锁那样强，

331
00:18:18,090 --> 00:18:20,490
尤其是有趣的是，

332
00:18:20,490 --> 00:18:22,020
当锁的持有者失败时，

333
00:18:23,360 --> 00:18:25,070
如果锁持有者失败了，

334
00:18:27,930 --> 00:18:31,200
zookeeper 确认锁持有者失败了，

335
00:18:31,200 --> 00:18:32,400
正如我们刚才所讨论的，

336
00:18:32,520 --> 00:18:34,560
那是可能的，

337
00:18:34,650 --> 00:18:37,050
我们会看到一些中间状态。

338
00:18:42,820 --> 00:18:45,100
记得锁的整个规则是，

339
00:18:45,100 --> 00:18:46,600
它是临界区间，

340
00:18:46,600 --> 00:18:48,580
一些不变量是 true ，

341
00:18:48,610 --> 00:18:51,160
当你通过临界区间的时候，

342
00:18:51,160 --> 00:18:52,600
所以这可能不是 true ，

343
00:18:52,600 --> 00:18:54,820
但到了最后，你会重建不变量。

344
00:18:56,320 --> 00:18:58,210
在这里，情况就是这样，

345
00:18:58,210 --> 00:18:59,350
它获取锁，

346
00:18:59,350 --> 00:19:01,210
客户端获取锁，执行一些步骤，

347
00:19:01,240 --> 00:19:02,890
然后 zookeeper 决定，

348
00:19:02,890 --> 00:19:05,200
如果客户端崩溃，

349
00:19:05,260 --> 00:19:07,600
然后撤销锁，

350
00:19:07,750 --> 00:19:09,010
但是你知道状态，

351
00:19:09,010 --> 00:19:11,440
系统可能在某种中间状态，

352
00:19:11,440 --> 00:19:14,080
返回不变量不是 true ，

353
00:19:14,080 --> 00:19:15,280
所以不是这种情况，

354
00:19:15,280 --> 00:19:19,990
这些日志保证临界区间的[坚固性]。

355
00:19:21,180 --> 00:19:26,490
那么，它们做什么，它们有什么用处，

356
00:19:29,510 --> 00:19:31,010
是出于其他目的，

357
00:19:33,640 --> 00:19:35,860
事实上，有两种主要用例，

358
00:19:35,860 --> 00:19:37,810
一个，我认为是领导者选举，

359
00:19:43,380 --> 00:19:46,560
所以如果我们需要一组客户端，

360
00:19:46,560 --> 00:19:48,090
需要从它们当中选出领导者，

361
00:19:48,090 --> 00:19:52,140
它们可以尝试创建锁文件，

362
00:19:52,170 --> 00:19:53,490
其中一个成功了，

363
00:19:53,520 --> 00:19:55,170
成为领导者，

364
00:19:55,860 --> 00:20:00,660
如果有必要，领导者可以清理任何中间状态，

365
00:20:02,070 --> 00:20:04,800
或者做这些原子更新，

366
00:20:04,800 --> 00:20:05,790
使用 ready 的技巧，

367
00:20:05,820 --> 00:20:08,370
你对某个文件执行一些写入操作，

368
00:20:08,370 --> 00:20:10,500
但只在最后[展示]文件，

369
00:20:10,500 --> 00:20:13,560
通过这种方式进行一组写操作

370
00:20:13,560 --> 00:20:15,810
是更具事务性的工作。

371
00:20:16,390 --> 00:20:19,090
所以，这是这类锁的一个使用案例，

372
00:20:19,240 --> 00:20:22,630
第二个用例是我所说的软锁，

373
00:20:27,260 --> 00:20:30,380
你可以考虑软锁是，

374
00:20:30,560 --> 00:20:34,250
假设我们有一个 mapreduce 式的 worker ，

375
00:20:34,340 --> 00:20:35,150
而且 map ，

376
00:20:35,150 --> 00:20:38,750
我想安排每个 worker

377
00:20:38,750 --> 00:20:43,310
只执行一次特定的 map 任务，

378
00:20:43,460 --> 00:20:45,200
所以，要做到这个的一种方法，

379
00:20:45,200 --> 00:20:46,760
我们从外面获取一个锁，

380
00:20:46,760 --> 00:20:49,640
对于特定的输入文件，

381
00:20:49,880 --> 00:20:52,010
执行计算，

382
00:20:52,160 --> 00:20:55,070
然后，一旦 map 完成，

383
00:20:55,070 --> 00:20:56,450
然后释放锁文件，

384
00:20:56,600 --> 00:21:03,650
所以，通常情况下，执行特定任务只需花费一个 mapper ，

385
00:21:04,070 --> 00:21:06,800
而这正是我们想要的，

386
00:21:06,800 --> 00:21:09,440
当然，如果 mapper 失败，

387
00:21:09,440 --> 00:21:10,910
那么锁就会被释放，

388
00:21:11,060 --> 00:21:13,490
然后我们可能会再执行一次，

389
00:21:13,490 --> 00:21:15,740
因为其他人会试图获取锁，

390
00:21:16,040 --> 00:21:17,000
所以在这种情况下，

391
00:21:17,000 --> 00:21:19,430
对于 mapreduce 的情况，这是非常好的，

392
00:21:19,640 --> 00:21:22,700
这个任务执行两次也没关系，

393
00:21:24,870 --> 00:21:26,280
如果发生两次。

394
00:21:29,680 --> 00:21:31,240
在某些方面，它到底是什么，

395
00:21:31,240 --> 00:21:32,590
更多的性能优化，

396
00:21:32,590 --> 00:21:34,300
在通常的情况下，你想要，

397
00:21:34,510 --> 00:21:36,970
你想要只执行一次，

398
00:21:37,120 --> 00:21:38,920
但是如果失败了，

399
00:21:38,920 --> 00:21:39,670
情况可能是这样的，

400
00:21:39,670 --> 00:21:41,440
你执行了两次 map 作业，

401
00:21:41,740 --> 00:21:43,660
然后那个东西， mapreduce 意味着

402
00:21:43,660 --> 00:21:46,660
你以这种方式设置，是可以的。

403
00:21:47,870 --> 00:21:48,890
所以，在这些情况下，

404
00:21:48,890 --> 00:21:51,170
这种锁也很有用。

405
00:21:52,780 --> 00:21:57,240
关于这个，有什么问题吗，关于锁的这个观点，

406
00:21:57,240 --> 00:21:59,970
zookeeper 锁与 Go 锁不太一样，

407
00:21:59,970 --> 00:22:02,340
这是一件需要记住的重要事情。

408
00:22:03,760 --> 00:22:03,970
噢。

409
00:22:03,970 --> 00:22:06,820
好的，继续， Alexander 。

410
00:22:06,850 --> 00:22:08,830
是的，我有个问题，

411
00:22:08,830 --> 00:22:12,100
你说过，其中一个区别是，

412
00:22:12,850 --> 00:22:20,730
在 zlock 中，如果持有锁的服务器宕机，

413
00:22:20,730 --> 00:22:22,770
那么锁就可以被撤销，

414
00:22:22,800 --> 00:22:27,300
但是，如果你不通过，是不是仍然会发生，

415
00:22:27,540 --> 00:22:32,140
因为有一个标志是 EPHEMERAL 。

416
00:22:32,140 --> 00:22:35,800
EPHEMERAL ，是的，只有 ephemeral 文件才会发生这种情况。

417
00:22:36,350 --> 00:22:42,080
是的，所以我们能不能通过不传递 EPHEMERAL 来模拟 Go 锁。

418
00:22:46,570 --> 00:22:47,470
好的，接下来会发生什么，

419
00:22:47,470 --> 00:22:48,490
你创建了一个永久文件，

420
00:22:49,040 --> 00:22:50,240
客户端宕机。

421
00:22:51,400 --> 00:22:52,510
你是说锁？

422
00:22:53,640 --> 00:22:57,570
锁将继续存在，没有人会释放它，

423
00:22:58,450 --> 00:22:59,950
我们会陷入死锁，

424
00:23:02,050 --> 00:23:07,350
因为唯一可以释放它的已经宕机，或者崩溃，

425
00:23:09,000 --> 00:23:11,340
这就是为什么会有 EPHEMERAL 。

426
00:23:13,350 --> 00:23:18,450
它真的是唯一可以释放它的吗，

427
00:23:18,450 --> 00:23:20,430
因为任何人都可以删除那个文件，

428
00:23:20,850 --> 00:23:22,890
你有[后台]，比如。

429
00:23:23,220 --> 00:23:25,080
这将破坏，

430
00:23:25,080 --> 00:23:26,730
可能另一个客户端仍在运行，

431
00:23:26,730 --> 00:23:28,650
并且仍然认为它持有锁。

432
00:23:32,370 --> 00:23:33,000
好的。

433
00:23:33,750 --> 00:23:36,390
你会得到，

434
00:23:36,390 --> 00:23:38,400
这又是一个共识问题。

435
00:23:39,350 --> 00:23:41,480
你知道我们，

436
00:23:44,820 --> 00:23:47,460
所以，这是一种获得大部分信息的简单的方式，

437
00:23:47,760 --> 00:23:49,110
但不是全部，

438
00:23:49,530 --> 00:23:50,250
如果你愿意的话，

439
00:23:50,490 --> 00:23:52,380
我想如果你想让东西变的原子化，

440
00:23:52,380 --> 00:23:55,350
让一组写入原子化，

441
00:23:55,530 --> 00:23:58,740
所以你使用这个技巧，

442
00:24:01,540 --> 00:24:03,610
使用这个技巧， ready 技巧，

443
00:24:03,610 --> 00:24:06,070
执行很多写入，但是[同时]展示它们。

444
00:24:10,640 --> 00:24:13,100
你能再解释一下那些软锁吗？

445
00:24:13,640 --> 00:24:17,510
好的，软锁意味着一个操作可以发生两次。

446
00:24:18,200 --> 00:24:20,120
在常见的情况下，

447
00:24:20,120 --> 00:24:21,110
如果没有崩溃，

448
00:24:21,110 --> 00:24:22,220
它只会发生一次，

449
00:24:22,220 --> 00:24:24,710
因为客户端用一个锁，

450
00:24:24,710 --> 00:24:26,180
会进行释放操作，

451
00:24:26,720 --> 00:24:31,280
但是如果客户端在半路失败了，

452
00:24:31,280 --> 00:24:34,280
然后锁将由 zookeeper 自动释放，

453
00:24:34,280 --> 00:24:37,640
然后可能是第二个客户端执行相同的 map 任务。

454
00:24:41,710 --> 00:24:43,720
所以在领导者选举的例子中，

455
00:24:43,720 --> 00:24:46,660
在这里可以暴露的中间状态是什么，

456
00:24:47,080 --> 00:24:48,430
这似乎是第一个。

457
00:24:49,090 --> 00:24:52,090
好的，纯粹的领导人选举不会有中间状态，

458
00:24:52,090 --> 00:24:54,940
但是通常领导者会创建配置文件，

459
00:24:55,090 --> 00:24:56,440
像我们在 zookeeper 中看到的那样，

460
00:24:56,440 --> 00:24:58,720
使用 ready 技巧。

461
00:25:00,060 --> 00:25:02,040
我明白了，所以你把整个文件都写好了，

462
00:25:02,040 --> 00:25:03,960
然后原子地进行转换，使用重命名。

463
00:25:03,960 --> 00:25:04,710
是的。

464
00:25:06,870 --> 00:25:12,240
抱歉，你能具体解释一下 ready 技巧是什么吗？

465
00:25:13,830 --> 00:25:15,300
我希望不用，我想我们上次谈过了。

466
00:25:15,660 --> 00:25:17,010
抱歉。

467
00:25:17,010 --> 00:25:20,310
所以也许你可以保持这个问题，

468
00:25:20,310 --> 00:25:22,230
我很高兴在课程结束后再讲一次，

469
00:25:25,980 --> 00:25:29,640
否则，我很少有时间来谈论链式复制。

470
00:25:35,560 --> 00:25:37,870
还有其他问题吗？

471
00:25:40,290 --> 00:25:44,550
好的，让我设置一下链式复制的状态，

472
00:25:44,550 --> 00:25:47,910
有时也会回到 zookeeper ，

473
00:25:47,910 --> 00:25:50,070
事实证明，

474
00:25:50,100 --> 00:25:54,030
有两种常见的方法来构建复制状态机，

475
00:25:54,330 --> 00:25:56,730
我们还没有提出这两种方法，

476
00:25:56,850 --> 00:25:58,020
我们见过它们，

477
00:25:58,020 --> 00:25:59,700
但我很明确地谈到了它们，

478
00:25:59,700 --> 00:26:01,470
我想这次是明确的。

479
00:26:01,960 --> 00:26:02,530
所以。

480
00:26:05,790 --> 00:26:07,860
因为有一些有趣的观察

481
00:26:08,640 --> 00:26:11,280
用来构建复制状态机的方法。

482
00:26:14,550 --> 00:26:20,040
第一个是我们在实验中看到的那个，

483
00:26:20,100 --> 00:26:26,610
也就是运行所有操作通过 Raft ，

484
00:26:30,330 --> 00:26:32,970
Raft zookeeper 或者 Paxos ，

485
00:26:32,970 --> 00:26:37,840
无论使用什么共识算法，

486
00:26:38,350 --> 00:26:41,470
这有点像键值存储，

487
00:26:41,500 --> 00:26:44,590
在实验 3 中，你执行 put get 操作，

488
00:26:44,590 --> 00:26:47,020
你通过 Raft 执行所有 put get 操作，

489
00:26:47,170 --> 00:26:51,900
服务更新键值存储状态，

490
00:26:51,900 --> 00:26:55,410
当操作进入 apply channel 时，

491
00:26:56,060 --> 00:27:00,140
我们有自己的复制状态，

492
00:27:00,710 --> 00:27:02,990
这就是实验 3 的工作方式。

493
00:27:05,960 --> 00:27:10,100
事实证明， Raft 使用的这种风格，

494
00:27:10,100 --> 00:27:13,550
运行所有操作的情况并不常见，

495
00:27:14,030 --> 00:27:16,730
我们将在本学期晚些时候看到一些其他设计来实现这一点，

496
00:27:16,730 --> 00:27:17,930
比如 Spanner 实现了，

497
00:27:18,200 --> 00:27:21,380
但这并不完全是标准的方法，

498
00:27:21,380 --> 00:27:25,790
或者更常见的方法是有一个配置服务器，

499
00:27:25,820 --> 00:27:34,470
比如 zookeeper 服务，

500
00:27:34,860 --> 00:27:42,930
配置服务内部可能使用 Paxos Raft ZAB 或任何其他，

501
00:27:43,230 --> 00:27:50,010
配置服务扮演着 coordinator 或 master 的角色，

502
00:27:50,010 --> 00:27:51,570
就像 GFS master ，

503
00:27:52,140 --> 00:27:55,920
配置服务除了

504
00:27:55,920 --> 00:28:01,050
使用 Raft Paxos 算法实现，

505
00:28:01,230 --> 00:28:04,680
你也可以运行主备复制。

506
00:28:12,680 --> 00:28:15,200
所以考虑 GFS ，

507
00:28:15,230 --> 00:28:17,240
我们在本学期早些时候看到的，

508
00:28:17,300 --> 00:28:18,650
有这种结构，

509
00:28:18,650 --> 00:28:20,270
就像在 GFS 中有一个 master ，

510
00:28:20,480 --> 00:28:24,770
这决定了哪组服务器保存特定的块，

511
00:28:25,070 --> 00:28:27,860
确定区块的复制组，

512
00:28:28,250 --> 00:28:33,020
然后复制块组组执行主备复制，

513
00:28:33,170 --> 00:28:35,210
其中一块是主节点，

514
00:28:35,330 --> 00:28:36,740
另一个是备份，

515
00:28:36,740 --> 00:28:40,100
它们有一个用于主备复制的协议。

516
00:28:41,140 --> 00:28:43,900
你可以考虑 VM-FT 使用类似的形式，

517
00:28:43,900 --> 00:28:46,510
其中配置服务器是 test-and-set 服务器，

518
00:28:46,600 --> 00:28:49,000
它记录了谁是主节点，

519
00:28:49,270 --> 00:28:51,250
然后主备有一个协议，

520
00:28:51,250 --> 00:28:54,370
发送[通道操作]到通道，

521
00:28:54,550 --> 00:28:58,180
因此，主备大致同步，

522
00:28:58,210 --> 00:29:01,360
实现复制状态机。

523
00:29:02,540 --> 00:29:05,930
这种方法往往是一种更常见的方法，

524
00:29:10,230 --> 00:29:13,680
虽然第一种方法也会发生。

525
00:29:14,250 --> 00:29:16,950
一种思考这个问题的方法，

526
00:29:16,950 --> 00:29:21,250
如果 Raft 状态，

527
00:29:21,250 --> 00:29:24,100
比如，我们在实验 3 的键值服务器将是巨大的，

528
00:29:24,100 --> 00:29:26,260
有大量的这种状态，

529
00:29:26,290 --> 00:29:28,510
数 TB 的键值服务器，

530
00:29:28,810 --> 00:29:32,110
对于这种应用， Raft 会是非常好的匹配吗，

531
00:29:34,740 --> 00:29:35,940
或者风险是什么，

532
00:29:38,610 --> 00:29:39,900
或者潜在的问题？

533
00:29:47,380 --> 00:29:50,470
我们经常刷新日志，

534
00:29:50,470 --> 00:29:53,360
所以，这可能会带来问题。

535
00:29:53,750 --> 00:29:54,890
可能会有问题，

536
00:29:54,890 --> 00:29:57,920
检查点的大小是多少，

537
00:29:59,740 --> 00:30:02,080
如果我们的键值服务器非常大。

538
00:30:04,930 --> 00:30:07,450
它与键值服务器的大小成正比。

539
00:30:07,450 --> 00:30:09,550
是的，所以这也可能是巨大的，

540
00:30:09,640 --> 00:30:12,790
所以在任何时候，检查点必须被发送，

541
00:30:12,820 --> 00:30:14,320
这将是一个很大的检查点。

542
00:30:14,900 --> 00:30:17,150
所以 Raft 并不是设置好的，

543
00:30:17,150 --> 00:30:20,780
主节点需要通信，

544
00:30:20,780 --> 00:30:23,270
新的主节点将与快照通信，

545
00:30:23,270 --> 00:30:24,530
你在实验 2d 中所做的，

546
00:30:24,530 --> 00:30:25,910
到备节点，

547
00:30:25,910 --> 00:30:27,020
它们会很大。

548
00:30:27,760 --> 00:30:31,210
所以你想要更聪明的方案，

549
00:30:31,390 --> 00:30:34,840
重新同步新服务器，

550
00:30:35,020 --> 00:30:37,930
所以，一个原因，

551
00:30:37,930 --> 00:30:40,840
这些东西通常被分成两个不同的部分，

552
00:30:40,840 --> 00:30:44,290
其中配置服务在状态方面很小，

553
00:30:44,590 --> 00:30:49,450
然后，主备方案可能复制大量数据。

554
00:30:50,390 --> 00:30:53,510
这就是为什么，你看到这两种方法的一个原因。

555
00:30:54,920 --> 00:30:55,640
这能理解吗？

556
00:30:57,620 --> 00:30:59,630
我会在课程结束时再讲到这一点，

557
00:30:59,690 --> 00:31:01,820
但重要的是要记住这一点。

558
00:31:02,470 --> 00:31:06,130
那么，方案 1 比 2 有什么好处呢？

559
00:31:07,360 --> 00:31:10,150
你不需要有它们两个，

560
00:31:10,150 --> 00:31:12,160
在 1 中，你有 Raft ，

561
00:31:12,160 --> 00:31:15,520
你运行[]操作，然后也为你进行配置，

562
00:31:15,880 --> 00:31:19,450
所以，所有的东西都在一个单一的组件中，

563
00:31:20,320 --> 00:31:22,690
在 2 中，我们有两个组件，

564
00:31:22,690 --> 00:31:25,600
我们有一个配置服务，包括 Raft ，

565
00:31:25,690 --> 00:31:27,820
而且我们有一个主备方案。

566
00:31:30,400 --> 00:31:32,290
所以，这个可能会变得更加清楚，

567
00:31:32,290 --> 00:31:33,820
当我们讨论链式复制时。

568
00:31:36,480 --> 00:31:37,470
嗯。

569
00:31:37,470 --> 00:31:39,150
我有一个非常简短的问题，

570
00:31:39,180 --> 00:31:41,070
所以第二个，

571
00:31:41,400 --> 00:31:45,270
优势是什么，

572
00:31:45,270 --> 00:31:47,250
如果通过领导者达成共识，

573
00:31:47,370 --> 00:31:49,320
领导者永远不会失败，对吧。

574
00:31:50,220 --> 00:31:52,110
是的，所以第二个的优势是，

575
00:31:52,110 --> 00:31:54,720
正如我们随后会在链式复制中看到的，

576
00:31:54,720 --> 00:31:57,840
有一个单独的进程负责配置部分，

577
00:31:57,870 --> 00:32:01,710
你不必担心你的主备份复制方案。

578
00:32:02,600 --> 00:32:05,270
这就像 GFS 一样决定了，

579
00:32:05,270 --> 00:32:06,290
比如 master ，

580
00:32:06,290 --> 00:32:07,760
它决定这里的几个，

581
00:32:07,760 --> 00:32:10,100
设置服务形成特定复制组，

582
00:32:10,620 --> 00:32:14,610
而主备协议不用考虑这个。

583
00:32:16,240 --> 00:32:16,690
谢谢。

584
00:32:17,370 --> 00:32:20,790
这是对链式复制的一个很好的介绍，

585
00:32:20,790 --> 00:32:22,770
因为链式复制正是

586
00:32:22,950 --> 00:32:30,030
方法 2 的主备复制方案。

587
00:32:35,650 --> 00:32:38,980
就是说，链式复制假设，

588
00:32:39,010 --> 00:32:41,980
有一个配置服务，

589
00:32:42,430 --> 00:32:45,010
我想他们在论文中成为 master 。

590
00:32:45,880 --> 00:32:47,950
然后链式复制本身，

591
00:32:47,950 --> 00:32:50,050
有几个很酷的属性。

592
00:32:50,580 --> 00:32:58,670
一，读操作或者他们称为查询操作只涉及一个服务器，

593
00:33:01,430 --> 00:33:04,490
也就是我们随后会看到的 tail 。

594
00:33:07,120 --> 00:33:11,620
链式复制的另一个很好的特性是具有非常简单的恢复方案。

595
00:33:13,510 --> 00:33:15,940
我随后将更详细地讨论这些。

596
00:33:18,910 --> 00:33:21,040
很可能一些事情开始，

597
00:33:21,220 --> 00:33:23,890
你理解这个事实，

598
00:33:23,890 --> 00:33:25,780
在 Raft 上能有多复杂。

599
00:33:26,230 --> 00:33:33,610
而且它提供了很强的性质，即线性一致性，

600
00:33:34,550 --> 00:33:36,140
如果我们进行 put 和 get 操作。

601
00:33:36,650 --> 00:33:38,960
最后，很多人问到，

602
00:33:38,960 --> 00:33:41,180
是一个合理的有影响力的设计，

603
00:33:43,020 --> 00:33:45,180
并被很多系统使用，

604
00:33:46,640 --> 00:33:48,530
所以这些都是在实践中使用的。

605
00:33:50,080 --> 00:33:52,210
这将讨论这些组件中的每一个，

606
00:33:52,210 --> 00:33:53,470
我们会得到更多细节，

607
00:33:53,710 --> 00:33:57,220
然后我们将回到方法一对比方法二。

608
00:34:00,250 --> 00:34:02,050
所以从总体上来说，

609
00:34:07,060 --> 00:34:07,510
糟糕，

610
00:34:07,630 --> 00:34:09,880
一个概述，

611
00:34:10,210 --> 00:34:12,460
新的[]类型，

612
00:34:12,490 --> 00:34:19,230
这里有一个大的进程或一个配置服务，

613
00:34:23,820 --> 00:34:25,200
然后跟踪

614
00:34:25,230 --> 00:34:29,640
哪台服务器属于特定的链。

615
00:34:30,320 --> 00:34:32,660
所以 S1 S2 S3 ，

616
00:34:32,660 --> 00:34:34,850
有一个关于是什么链的记录，

617
00:34:34,970 --> 00:34:37,130
谁是头，谁是尾，

618
00:34:37,160 --> 00:34:39,440
所以这可能是配置服务，

619
00:34:39,440 --> 00:34:41,750
在这里，我们有我们的服务，

620
00:34:41,750 --> 00:34:47,120
S1 S2 S3 ，

621
00:34:49,870 --> 00:34:52,920
其中一个是头部，

622
00:34:53,190 --> 00:34:55,770
通常是数字较小的那个，

623
00:34:55,770 --> 00:34:57,570
一个是尾部。

624
00:35:00,160 --> 00:35:01,780
所以我们有一个客户端，

625
00:35:03,190 --> 00:35:05,590
客户端可以访问配置服务器，

626
00:35:05,590 --> 00:35:08,860
它是链的一部分，

627
00:35:09,130 --> 00:35:12,700
然后它向头部发送写请求，

628
00:35:13,370 --> 00:35:15,770
所以这是一种链式复制协议，

629
00:35:15,770 --> 00:35:19,960
写请求总是发送到头部，

630
00:35:20,230 --> 00:35:22,360
头部所做的，头部推送，

631
00:35:22,360 --> 00:35:25,780
头部对它的状态进行操作，

632
00:35:25,780 --> 00:35:28,030
也许它有一个关联的磁盘，

633
00:35:28,030 --> 00:35:30,250
键值服务在上面，

634
00:35:30,790 --> 00:35:33,130
然后它发送更新，

635
00:35:33,160 --> 00:35:40,910
所有的操作在链上按照先进先出的顺序可靠地进行，

636
00:35:41,090 --> 00:35:44,450
所以， S1 发送更新给 S2 ，

637
00:35:44,810 --> 00:35:46,520
S2 有自己的磁盘，

638
00:35:46,550 --> 00:35:51,050
将操作或状态更改应用于它的状态，

639
00:35:51,500 --> 00:35:53,300
一旦它应用了它，

640
00:35:53,510 --> 00:35:58,400
它会把它发送到链中的最后一个节点，

641
00:35:58,400 --> 00:36:00,560
因为在这个链中只有三个节点，

642
00:36:00,560 --> 00:36:02,300
你可以有更长的链，

643
00:36:02,750 --> 00:36:04,070
如果你想要更多的可用性，

644
00:36:04,690 --> 00:36:10,270
当最后一个节点收到状态改变的消息，

645
00:36:10,360 --> 00:36:12,640
它应用于它的状态，

646
00:36:13,510 --> 00:36:18,700
然后这是向客户端发回确认的[时机]，

647
00:36:20,440 --> 00:36:22,660
所以是尾部发回确认信息。

648
00:36:25,180 --> 00:36:28,810
所以，考虑这一问题的一种方式是，

649
00:36:28,810 --> 00:36:33,700
当尾部或在这种情况下 S3 应用了状态变化，

650
00:36:33,730 --> 00:36:35,080
这就是提交点。

651
00:36:39,080 --> 00:36:40,760
之所以这是提交点，

652
00:36:40,760 --> 00:36:44,660
是因为后续读取总是从尾部获取，

653
00:36:44,720 --> 00:36:50,010
所以，如果任何客户端执行读操作，

654
00:36:50,010 --> 00:36:51,300
它们总是到尾部，

655
00:36:52,160 --> 00:36:54,500
尾部会立即对它们做出反应。

656
00:36:55,360 --> 00:36:57,160
所以读操作到尾部，

657
00:36:57,190 --> 00:36:59,320
这是客户端 1 ，这是客户端 2 ，

658
00:36:59,560 --> 00:37:01,720
客户端 2 进行读操作，

659
00:37:01,720 --> 00:37:03,490
它到达尾部，

660
00:37:03,490 --> 00:37:04,960
尾部做出响应，就是这样。

661
00:37:06,630 --> 00:37:09,030
所以有几件事我想指出，

662
00:37:09,270 --> 00:37:12,960
其中一个有趣的问题是，

663
00:37:12,960 --> 00:37:16,400
读操作只涉及一台服务器，

664
00:37:16,400 --> 00:37:18,950
如果记得实验 3 ，

665
00:37:18,980 --> 00:37:20,120
或者如果你有任何进展，

666
00:37:20,120 --> 00:37:21,860
我们已经开始实验 3 ，

667
00:37:21,950 --> 00:37:23,870
读操作涉及，

668
00:37:24,020 --> 00:37:30,140
在我们的实现中，读取操作通过 Raft 日志，

669
00:37:30,140 --> 00:37:31,220
以及所有东西，

670
00:37:31,610 --> 00:37:34,310
论文讨论了一个优化，

671
00:37:34,550 --> 00:37:36,800
但读取操作始终由领导者执行，

672
00:37:36,800 --> 00:37:39,950
而领导者首先必须联系大多数服务器，

673
00:37:39,950 --> 00:37:41,990
在执行操作之前。

674
00:37:42,410 --> 00:37:44,180
所以你在这里看到的是，

675
00:37:44,330 --> 00:37:46,100
读操作通过尾部，

676
00:37:46,100 --> 00:37:49,910
写操作从不同的服务器，

677
00:37:49,910 --> 00:37:53,480
所以，读写工作负载至少分布在两台服务器上，

678
00:37:54,360 --> 00:37:58,560
对于更多读操作只设计一台服务器，

679
00:37:58,560 --> 00:38:01,260
不需要与任何其他服务器交互，

680
00:38:01,260 --> 00:38:02,250
它可以立即做出响应，

681
00:38:02,400 --> 00:38:03,600
我们稍后会看到，

682
00:38:03,810 --> 00:38:06,180
为什么这很重要，

683
00:38:06,180 --> 00:38:07,080
或者为什么，

684
00:38:07,080 --> 00:38:09,360
这允许什么更多的优化。

685
00:38:10,400 --> 00:38:12,170
所以提交点是，

686
00:38:12,170 --> 00:38:15,650
写入发生在尾部的点，

687
00:38:15,800 --> 00:38:19,640
因为在那一点，写操作可以被读取者看见，

688
00:38:19,640 --> 00:38:21,500
而不是在任何其他点之前。

689
00:38:22,780 --> 00:38:26,260
这也提供了线性一致性，

690
00:38:26,260 --> 00:38:27,580
所以很容易看到，

691
00:38:27,580 --> 00:38:28,990
在没有崩溃的情况下，

692
00:38:29,560 --> 00:38:31,270
这个方案保证了线性一致性，

693
00:38:31,270 --> 00:38:34,840
因为写入都是按整体顺序在头部应用，

694
00:38:35,380 --> 00:38:40,150
当尾部收到更新时，

695
00:38:40,180 --> 00:38:41,800
这是提交点，

696
00:38:41,800 --> 00:38:44,800
它想要响应客户端并发回请求。

697
00:38:45,240 --> 00:38:48,150
如果同一客户端立即执行读取操作，

698
00:38:48,270 --> 00:38:49,710
它会到尾部，

699
00:38:49,710 --> 00:38:51,600
它将观察到最后一次变化。

700
00:38:52,200 --> 00:38:55,140
所以，在单个客户端中，

701
00:38:55,140 --> 00:38:57,030
所有的操作都是完全有序的，

702
00:38:57,760 --> 00:38:59,830
在客户端上很容易看出，

703
00:38:59,830 --> 00:39:04,810
如果在客户端 2 读操作开始在客户端 1 操作完成之后，

704
00:39:05,020 --> 00:39:07,810
当它完成时，当尾部做出响应时，

705
00:39:07,990 --> 00:39:11,020
所以，任何开始在写操作之后的读操作，

706
00:39:11,290 --> 00:39:15,070
将观察到最后一次或最近一次写入的结果，

707
00:39:15,460 --> 00:39:17,680
所以这里很容易得到一个直觉，

708
00:39:17,680 --> 00:39:20,230
这将为我们提供线性一致性。

709
00:39:22,050 --> 00:39:22,650
好的?

710
00:39:23,460 --> 00:39:28,410
我现在想要开始一个快速分组会议室，

711
00:39:28,410 --> 00:39:32,130
我想让你们讨论一下这个问题，

712
00:39:32,130 --> 00:39:33,570
在课程中贴出的，

713
00:39:33,720 --> 00:39:35,010
会出什么问题，

714
00:39:35,010 --> 00:39:38,400
或者什么打破线性一致性，

715
00:39:38,400 --> 00:39:42,030
如果不是让尾部响应客户端，

716
00:39:42,330 --> 00:39:45,510
让头部立即响应客户端，

717
00:39:45,510 --> 00:39:50,070
在收到写请求之后，

718
00:39:51,360 --> 00:39:53,040
也许这些都是很好的话题，

719
00:39:53,040 --> 00:39:54,630
或者可以稍微辩论一下，

720
00:39:54,630 --> 00:39:56,100
如果你想从任何角度

721
00:39:56,100 --> 00:39:58,470
谈论链式复制，当然欢迎，

722
00:39:58,470 --> 00:40:00,090
也许这是一个开始。

723
00:40:00,720 --> 00:40:02,550
所以让我们来个五分钟的分组会议室，

724
00:40:02,550 --> 00:40:06,760
然后我们这样做并想想，

725
00:40:07,280 --> 00:40:08,480
让我看看，

726
00:40:08,480 --> 00:40:09,500
Jose 你来做吗？

727
00:40:10,320 --> 00:40:13,530
好的。

728
00:40:13,530 --> 00:40:15,120
你得给做点什么，或者。

729
00:40:15,120 --> 00:40:16,860
我不认为这是必要的。

730
00:40:17,460 --> 00:40:19,440
我认为是 Zoom 变化，

731
00:40:19,440 --> 00:40:20,790
所以在那里也是可能的。

732
00:40:24,760 --> 00:40:28,260
Zoom ，是的，没错。

733
00:40:31,810 --> 00:40:33,250
好的，好的。

734
00:47:43,180 --> 00:47:44,740
Jose ，我们回来了。

735
00:47:45,250 --> 00:47:46,810
好的，你什么时候。

736
00:47:46,990 --> 00:47:47,770
我准备好了。

737
00:47:48,100 --> 00:47:51,160
好的，我想我可以关闭到 Zoom 。

738
00:48:57,530 --> 00:48:59,240
好的，我们回来了。

739
00:49:07,090 --> 00:49:11,710
好的，所以简单概括一下，

740
00:49:11,740 --> 00:49:15,370
为什么这会打破线性一致性，

741
00:49:15,400 --> 00:49:21,280
协议更改传播到，

742
00:49:21,280 --> 00:49:24,130
继续传播到 S1 S2 S3 ，

743
00:49:24,310 --> 00:49:27,250
但是一旦 S1 完成了，

744
00:49:27,310 --> 00:49:31,120
消息传播，返回给客户端，

745
00:49:31,720 --> 00:49:34,930
显然，这将会打破线性一致性，

746
00:49:34,930 --> 00:49:37,810
假设客户端 1 写入，

747
00:49:37,810 --> 00:49:40,420
从 S1 得到确认，

748
00:49:40,480 --> 00:49:43,990
当然写入会继续到 S2 S3 ，

749
00:49:44,110 --> 00:49:47,620
但也许在 S2 与 S3 相关之前，

750
00:49:47,620 --> 00:49:52,400
客户端向 S3 发送一个读操作，

751
00:49:52,550 --> 00:49:56,990
当然，现在它将返回写入完成之前的值，

752
00:49:56,990 --> 00:49:59,810
客户端甚至不能观察到自己的写入，

753
00:49:59,810 --> 00:50:02,660
所以很明显打破了线性一致性，

754
00:50:03,020 --> 00:50:04,310
所以这非常重要，

755
00:50:04,490 --> 00:50:05,960
正如我前面所说的，

756
00:50:05,960 --> 00:50:11,870
是尾部发送确认给客户端，

757
00:50:12,110 --> 00:50:17,120
因为一旦尾部处理了写操作，

758
00:50:17,120 --> 00:50:19,430
那就是提交点。

759
00:50:22,200 --> 00:50:23,370
对于这个，有什么问题吗？

760
00:50:28,400 --> 00:50:31,040
好的，所以这是正常的操作，

761
00:50:31,370 --> 00:50:33,860
让我来谈谈崩溃，

762
00:50:35,870 --> 00:50:37,550
因为它是 6.824 分布式系统，

763
00:50:37,550 --> 00:50:40,220
所以所有都是当失败发生时。

764
00:50:42,850 --> 00:50:47,260
链式复制最酷的一点是，

765
00:50:47,290 --> 00:50:50,140
失败场景的数量是相当有限的。

766
00:50:50,810 --> 00:50:54,230
所以，让我来看三种情况，

767
00:50:54,230 --> 00:50:58,250
头部故障，中间服务器之一故障或尾部故障。

768
00:50:58,760 --> 00:51:01,580
所以让我们来看看这些情况中的每一个，

769
00:51:01,580 --> 00:51:06,080
这是一种情况，头部是 S1 ，

770
00:51:06,320 --> 00:51:11,500
假设它应用了 U1 U2 U3 三个更新，

771
00:51:12,330 --> 00:51:14,100
与 S2 交互，

772
00:51:15,050 --> 00:51:18,620
也许 S2 完成了 U2 和 U1 ，

773
00:51:19,930 --> 00:51:23,320
这里我们有 S3 ，也就是尾部，

774
00:51:23,940 --> 00:51:26,130
到目前为止，它只完成了 U1 ，

775
00:51:26,310 --> 00:51:30,420
所以，对于正在访问 S1 的客户端，

776
00:51:31,500 --> 00:51:35,220
我们现在考虑会发生什么，

777
00:51:35,220 --> 00:51:38,130
以及在其中一次崩溃中需要发生什么。

778
00:51:38,310 --> 00:51:42,180
所以让我们从头部崩溃的情况开始，

779
00:51:42,730 --> 00:51:45,370
所以头部崩溃时，需要做什么，

780
00:51:47,530 --> 00:51:50,020
这是一件容易的事还是一件难事？

781
00:51:53,070 --> 00:51:53,850
简单的。

782
00:51:54,060 --> 00:51:55,980
我希望是简单的情况，为什么？

783
00:51:56,780 --> 00:52:00,050
你可以删除头部，

784
00:52:00,470 --> 00:52:02,390
哦，抱歉，是的，头部，

785
00:52:02,390 --> 00:52:05,900
现在让 S2 成为头部。

786
00:52:06,170 --> 00:52:10,070
是的，所以会发生的事情是，

787
00:52:10,070 --> 00:52:12,590
配置服务发现 S1 不见了，

788
00:52:13,080 --> 00:52:14,610
当确定 S1 不见了，

789
00:52:14,880 --> 00:52:23,880
然后可以在后续操作中提升 S2 为头部，

790
00:52:24,120 --> 00:52:26,970
未来的客户端访问这个节点，

791
00:52:27,120 --> 00:52:28,440
为什么这是正确的,

792
00:52:29,690 --> 00:52:31,400
那么我们丢掉了什么操作？

793
00:52:33,100 --> 00:52:34,630
我们失去了 U3 。

794
00:52:34,720 --> 00:52:36,130
是的，这有什么问题吗？

795
00:52:36,840 --> 00:52:39,150
丢失操作是合法的。

796
00:52:39,360 --> 00:52:42,690
是的，丢失 U3 是合理的，

797
00:52:42,720 --> 00:52:44,370
U3 尚未提交，

798
00:52:44,400 --> 00:52:46,500
因为只有尾部的操作才会提交，

799
00:52:46,980 --> 00:52:49,290
所以，就像操作从未发生，

800
00:52:49,290 --> 00:52:51,420
客户端甚至不会注意到，

801
00:52:51,450 --> 00:52:55,890
这个 U2 或 U3 发生了，

802
00:52:55,890 --> 00:52:56,820
或者 U3 应该发生。

803
00:52:57,310 --> 00:52:57,790
好的？

804
00:52:57,820 --> 00:53:00,010
所以这么做完全没问题，

805
00:53:00,130 --> 00:53:03,580
为什么配置服务涉及这里是重要的，

806
00:53:03,580 --> 00:53:06,610
S2 可以自己决定成为领导者吗，

807
00:53:07,380 --> 00:53:09,150
我们假设可以， U2 告诉任何节点，

808
00:53:09,150 --> 00:53:11,160
决定无论如何，我要成为头部，

809
00:53:11,780 --> 00:53:12,680
这是合法的吗？

810
00:53:14,770 --> 00:53:18,790
那就像是创造分裂。

811
00:53:18,940 --> 00:53:22,270
是的，那会造成脑裂，

812
00:53:22,270 --> 00:53:25,750
因为 S2 可能与 S1 分区，

813
00:53:26,140 --> 00:53:27,940
所以现在两个都是头部，

814
00:53:28,210 --> 00:53:30,100
也许两者都在处理命令，

815
00:53:30,100 --> 00:53:31,870
将会是违规行为，

816
00:53:32,170 --> 00:53:37,000
全部[]都有整体顺序，

817
00:53:38,190 --> 00:53:38,550
我们现在可以。

818
00:53:38,550 --> 00:53:43,440
同时， S2 知道 S1 是头部吗，

819
00:53:43,560 --> 00:53:45,660
因为它只是接受。

820
00:53:46,360 --> 00:53:49,900
你可能是从以前的配置信息中得到，

821
00:53:50,350 --> 00:53:53,620
比如当配置服务决定新配置时，

822
00:53:53,620 --> 00:53:54,700
它们可以告诉所有的服务器

823
00:53:54,700 --> 00:53:57,010
和任何关心的客户端，

824
00:53:57,040 --> 00:53:58,300
这是新的配置。

825
00:54:00,090 --> 00:54:03,870
这是否仅在 S1 到 S2 连接断开时发生，

826
00:54:03,870 --> 00:54:06,870
或者是什么导致了脑裂？

827
00:54:07,760 --> 00:54:08,750
脑裂发生在，

828
00:54:08,750 --> 00:54:12,650
如果 S2 自己决定 S1 失败并成为头部，

829
00:54:13,220 --> 00:54:15,290
所以我们不允许这样的事情发生，

830
00:54:15,290 --> 00:54:18,440
在实践中，实现的方法是，

831
00:54:18,440 --> 00:54:19,790
这里有一个配置服务器，

832
00:54:20,030 --> 00:54:22,610
它决定了当前的配置是什么，

833
00:54:23,300 --> 00:54:26,810
如果它确定 S1 已经宕机，

834
00:54:27,170 --> 00:54:29,630
然后它可以通知 S2 S3 ，

835
00:54:29,630 --> 00:54:34,310
说你们现在是新的链了， S2 是头部，

836
00:54:35,030 --> 00:54:36,590
当这种变化发生时，

837
00:54:36,590 --> 00:54:38,660
所以在这种情况下，会丢弃 S1 ，

838
00:54:38,690 --> 00:54:40,850
不会有其他事情发生，

839
00:54:40,850 --> 00:54:43,310
因为 S2 有，

840
00:54:43,550 --> 00:54:45,170
我们丢失的唯一更新，

841
00:54:45,170 --> 00:54:46,730
并没有进行提交，

842
00:54:46,730 --> 00:54:48,320
所以没有什么需要进一步修复的。

843
00:54:49,990 --> 00:54:53,530
所以从这个三个复制的设置开始，

844
00:54:53,560 --> 00:54:56,620
丢弃头部是相当简单的操作。

845
00:55:00,140 --> 00:55:00,950
好的?

846
00:55:01,450 --> 00:55:03,640
教授，我有一个问题，

847
00:55:03,640 --> 00:55:06,400
所以这里有一个假设，

848
00:55:06,400 --> 00:55:10,720
就像命令一样，

849
00:55:10,720 --> 00:55:17,620
离开 S1 将按顺序到达 S2 ，

850
00:55:17,950 --> 00:55:21,530
这是不是一个合理的假设，比如。

851
00:55:21,830 --> 00:55:23,450
好的，我认为它们的方式，

852
00:55:23,480 --> 00:55:24,470
所以他们说，

853
00:55:24,470 --> 00:55:28,070
我们需要在 S1 和 S2 之间一个可靠地先入先出，

854
00:55:28,070 --> 00:55:29,000
以及 S2 到 S3 ，

855
00:55:29,060 --> 00:55:32,330
我想他们实现的方式很可能是使用 TCP 连接。

856
00:55:36,470 --> 00:55:36,980
好的，谢谢。

857
00:55:37,620 --> 00:55:39,690
好的，让我们来看第二种情况。

858
00:55:40,200 --> 00:55:47,510
所以我们有 S1 S2 S3 ，

859
00:55:47,660 --> 00:55:50,060
当然，链中可能会有更多的服务器，

860
00:55:50,060 --> 00:55:53,480
但是三个足够我们考虑所有的情况，

861
00:55:54,020 --> 00:55:57,950
所以现在我们想要做的是，中间的一个崩溃了，

862
00:55:58,790 --> 00:55:59,720
这个崩溃了。

863
00:56:00,780 --> 00:56:05,760
所以，配置服务在某一时刻决定 S2 崩溃，

864
00:56:05,760 --> 00:56:10,050
通知 S1 S3 ，它们形成新的链，

865
00:56:10,730 --> 00:56:14,660
我们想知道，还有什么事情需要发生？

866
00:56:16,010 --> 00:56:17,180
我们在第一种情况中看到，

867
00:56:17,180 --> 00:56:20,000
丢弃头部，就没什么好做的了，

868
00:56:20,000 --> 00:56:21,260
除了更新链之外，

869
00:56:21,260 --> 00:56:22,400
现在我们更新链，

870
00:56:22,400 --> 00:56:24,740
问题是，有什么事情需要发生？

871
00:56:26,850 --> 00:56:29,880
S1 需要发送给 S3 ，

872
00:56:29,880 --> 00:56:31,650
发送给 S2 的请求，

873
00:56:31,650 --> 00:56:37,770
但没发给 S3 。

874
00:56:38,220 --> 00:56:41,400
是的，我们有 U1 U2 U3 ，

875
00:56:41,400 --> 00:56:43,410
这个看到 U1 和 U2 ，

876
00:56:43,920 --> 00:56:45,630
这个看到 U1 ，

877
00:56:45,630 --> 00:56:47,280
U2 正在进行，

878
00:56:47,280 --> 00:56:52,440
我丢失了 S2 ，

879
00:56:52,440 --> 00:56:54,900
S1 必须使 S3 保持最新，

880
00:56:54,930 --> 00:56:57,030
向前推进 U2 和 U3 。

881
00:56:58,120 --> 00:57:00,430
好的，这需要做一些工作，

882
00:57:00,700 --> 00:57:03,900
让我们来考虑最后一种情况，尾部。

883
00:57:04,820 --> 00:57:06,890
所以我们又来了，

884
00:57:06,920 --> 00:57:08,090
我们有三种情况，

885
00:57:09,200 --> 00:57:14,540
三个服务器 S1 S2 S3 。

886
00:57:16,240 --> 00:57:21,820
让我们看看，尾部崩溃了。

887
00:57:22,990 --> 00:57:25,300
所以，在某个时间点，

888
00:57:25,300 --> 00:57:30,730
配置服务通知决定新的链将是 S1 和 S2 ，

889
00:57:30,730 --> 00:57:33,220
告诉 S1 和 S2 它们是新链的一部分，

890
00:57:33,670 --> 00:57:36,370
还有其他需要发生的事情吗？

891
00:57:38,240 --> 00:57:39,770
好的，让我们写下来，

892
00:57:40,160 --> 00:57:44,710
我们知道，这个看到 U1 U2 U3 ，

893
00:57:44,710 --> 00:57:46,750
这个看过 U1 U2 ，

894
00:57:48,040 --> 00:57:50,710
那么，在这种情况下，谁将成为新的尾部？

895
00:57:51,990 --> 00:57:52,590
S2 。

896
00:57:52,860 --> 00:57:54,480
是的， S2 成为新的尾部，

897
00:57:54,690 --> 00:57:56,340
还有其他需要发生的事情吗？

898
00:57:57,380 --> 00:58:01,850
我想客户端需要被告知 S2 是。

899
00:58:02,300 --> 00:58:04,970
是的，客户端可以从配置服务获取。

900
00:58:05,750 --> 00:58:08,120
所以是的，但没有其他事情要发生，

901
00:58:08,120 --> 00:58:12,050
因为，所有提交的，

902
00:58:12,050 --> 00:58:14,900
没有提交的操作会丢失，

903
00:58:15,080 --> 00:58:20,150
由于我们仍然，

904
00:58:20,150 --> 00:58:23,810
仍然需要传播到 S2 会发生。

905
00:58:24,740 --> 00:58:26,750
好的，所以丢弃尾部也是直截了当的。

906
00:58:26,750 --> 00:58:29,300
所以丢弃尾部，头部是很直截了当的，

907
00:58:29,510 --> 00:58:31,460
丢弃中间那个更复杂一些，

908
00:58:31,670 --> 00:58:33,050
但并不是很复杂。

909
00:58:33,320 --> 00:58:37,270
我在这里想强调的关键是，

910
00:58:37,420 --> 00:58:40,600
这与 Raft 论文上的图 7 和图 8 相比如何？

911
00:58:49,080 --> 00:58:49,770
也许是为了。

912
00:58:50,550 --> 00:58:51,180
好的，继续。

913
00:58:52,620 --> 00:59:02,700
问题，所以，

914
00:59:02,700 --> 00:59:05,280
这些新的操作都是自动的。

915
00:59:06,210 --> 00:59:08,100
抱歉，我没有听到你说的话，

916
00:59:08,130 --> 00:59:11,520
你那里的连接相当嘈杂。

917
00:59:12,890 --> 00:59:16,970
好的，我刚才说， S2 变成了新的尾部，

918
00:59:17,360 --> 00:59:19,910
不必向客户端发回确认吗，

919
00:59:19,910 --> 00:59:22,310
还有一些条目是自动提交的。

920
00:59:23,810 --> 00:59:25,430
是的，可能是这样的，

921
00:59:25,430 --> 00:59:29,390
客户端可能发生的事情是重试，

922
00:59:29,870 --> 00:59:35,240
我们必须有一个像实验 3 中的独立的重复检测方案，

923
00:59:36,470 --> 00:59:39,920
有几种不同的方法可以做到这一点，

924
00:59:39,920 --> 00:59:42,170
论文并没有说明它使用哪一个。

925
00:59:43,610 --> 00:59:44,660
好的，我明白了，谢谢。

926
00:59:45,660 --> 00:59:47,850
是的，就像这种情况，

927
00:59:47,850 --> 00:59:49,470
论文不是说了，

928
00:59:50,120 --> 00:59:51,590
它可能会，

929
00:59:52,160 --> 00:59:53,480
即使它没有回应，

930
00:59:53,480 --> 00:59:55,460
可能成功，也可能不成功。

931
00:59:57,950 --> 00:59:59,930
好的，回到我原来的问题，

932
00:59:59,930 --> 01:00:02,090
这个对比如何，

933
01:00:02,090 --> 01:00:05,720
我在这个白板上画的图，

934
01:00:05,720 --> 01:00:07,490
对比图 7 和图 8 ，有什么不同？

935
01:00:08,610 --> 01:00:09,240
更简单。

936
01:00:09,780 --> 01:00:13,200
是的，这就是我想要表达的重点，

937
01:00:13,200 --> 01:00:15,810
这里要考虑的情况并不多，

938
01:00:15,810 --> 01:00:16,920
只有三种情况，

939
01:00:17,280 --> 01:00:23,400
比 Raft 论文的情况要简单得多，

940
01:00:23,400 --> 01:00:26,910
要考虑的情况很多，场景很复杂，

941
01:00:27,060 --> 01:00:30,510
部分原因是这是一条链，

942
01:00:30,510 --> 01:00:36,420
事情以一种非常直截了当的方式推下来，

943
01:00:36,420 --> 01:00:37,710
向复制链的下方，

944
01:00:38,070 --> 01:00:39,540
当然，部分原因是，

945
01:00:39,540 --> 01:00:43,800
配置部分外包给配置管理器。

946
01:00:44,540 --> 01:00:48,260
但是对于主备部分的恢复方案，

947
01:00:48,320 --> 01:00:49,490
这是直截了当的，

948
01:00:49,520 --> 01:00:51,800
只有三种配置需要考虑。

949
01:00:54,920 --> 01:00:56,690
我还想提出一个点，

950
01:00:56,690 --> 01:00:58,400
就是如何添加复制，

951
01:00:58,520 --> 01:01:01,820
因为这里的任何系统都会实时运行，

952
01:01:01,820 --> 01:01:05,410
在某些时候，你需要添加一个新的，

953
01:01:05,680 --> 01:01:07,930
因为否则你会丢失，

954
01:01:07,930 --> 01:01:08,800
你开始有三个，

955
01:01:08,800 --> 01:01:10,720
然后你有两个，然后有一个，然后就没有了，

956
01:01:10,720 --> 01:01:11,680
然后你就[]。

957
01:01:11,710 --> 01:01:15,520
所以，你必须添加新的复制，

958
01:01:15,520 --> 01:01:17,170
所以让我们来考虑一下这个情况，

959
01:01:17,620 --> 01:01:20,200
这是 S1 ，它是头部，

960
01:01:21,820 --> 01:01:23,170
假设我们在一种情景中，

961
01:01:23,170 --> 01:01:26,710
我们有 S1 S2 ， S2 是尾部，

962
01:01:26,710 --> 01:01:29,800
我们想要添加 S3 ，

963
01:01:32,190 --> 01:01:34,200
事实证明，正如论文所描述的那样，

964
01:01:34,200 --> 01:01:40,080
在它的尾部做这件事是最方便的，

965
01:01:40,260 --> 01:01:44,490
所以创建新的服务器，新的尾部。

966
01:01:45,170 --> 01:01:46,970
所以，我们继续进行的方式是，

967
01:01:46,970 --> 01:01:48,380
比如客户端在这里，

968
01:01:48,740 --> 01:01:50,750
访问 S2 ，

969
01:01:50,750 --> 01:01:52,430
因为这是当前的尾部，

970
01:01:52,550 --> 01:01:54,020
S3 出现，

971
01:01:54,140 --> 01:01:55,610
它做的第一件事是

972
01:01:55,610 --> 01:01:59,090
将 S3 中的旧状态复制到，

973
01:01:59,180 --> 01:02:00,080
从 S2 到 S3 。

974
01:02:01,040 --> 01:02:03,170
所以这可能需要几个小时，

975
01:02:03,170 --> 01:02:06,680
几十分钟，甚至几个小时，

976
01:02:06,680 --> 01:02:11,360
你将从 S2 向 S3 复制数 GB 或数 TB 的数据，

977
01:02:11,630 --> 01:02:12,830
但当这一切发生的时候，

978
01:02:12,830 --> 01:02:16,220
S2 S3 能服务于请求，

979
01:02:16,880 --> 01:02:23,690
当然，它必须记住哪些是在 S3 开始复制之后进入的，

980
01:02:23,720 --> 01:02:27,500
所以保持一份所有发生更新的列表，

981
01:02:27,500 --> 01:02:29,780
但还没有传播到 S3 ，

982
01:02:29,900 --> 01:02:32,900
在某个时刻， S3 完成了所有复制，

983
01:02:33,080 --> 01:02:34,460
告诉 S2 ，

984
01:02:34,460 --> 01:02:37,310
好的，伙计，我准备好了，成为尾部，

985
01:02:37,310 --> 01:02:38,330
我得到了所有状态，

986
01:02:38,660 --> 01:02:43,310
S2 ，发送邮件，发送消息给 S2 ，

987
01:02:43,310 --> 01:02:46,580
说，好的，我想成为尾部，

988
01:02:46,610 --> 01:02:48,860
S2 回应，比如，是的，可以，

989
01:02:48,980 --> 01:02:52,130
但是一旦你应用了所有的更新。

990
01:02:54,030 --> 01:02:57,930
所以， S2 发送更新响应这个，

991
01:02:57,930 --> 01:03:02,330
我想继续一个尾部请求，

992
01:03:02,330 --> 01:03:05,000
作为对 S3 响应，

993
01:03:05,090 --> 01:03:06,530
S3 回复更新，

994
01:03:06,710 --> 01:03:09,140
然后变成尾部，

995
01:03:09,650 --> 01:03:12,200
正在与 S2 交互的客户端，

996
01:03:12,200 --> 01:03:13,670
S2 可以告诉客户端，

997
01:03:13,670 --> 01:03:15,320
从现在开始，我不再是尾部了，

998
01:03:15,320 --> 01:03:16,220
你应该访问 S3 ，

999
01:03:16,310 --> 01:03:18,860
所以它们可以切换方向。

1000
01:03:19,470 --> 01:03:23,820
所以，这就是将复制添加到链中的方法。

1001
01:03:26,160 --> 01:03:28,020
所以关于这个的问题，

1002
01:03:28,140 --> 01:03:30,300
你不会遇到这样的无限循环问题吗，

1003
01:03:30,300 --> 01:03:32,340
S2 将更新发送到 S3 ，

1004
01:03:32,340 --> 01:03:36,360
当 S3 更新时，它也服务于更多的请求，

1005
01:03:36,360 --> 01:03:37,620
由于更多的更新，

1006
01:03:37,650 --> 01:03:39,660
它需要来回发送？

1007
01:03:40,280 --> 01:03:43,940
不，一旦 S2 发送了更新，

1008
01:03:43,940 --> 01:03:47,120
S3 还没有见过，到 S3 ，

1009
01:03:47,240 --> 01:03:49,730
然后从那时起，正常的链式复制，

1010
01:03:49,730 --> 01:03:51,620
每当 S2 收到请求时，

1011
01:03:51,620 --> 01:03:52,910
来自 S1 的更新，

1012
01:03:53,090 --> 01:03:54,590
它将它推给 S3 。

1013
01:03:57,400 --> 01:03:59,380
是的，但是 S3 可以成为尾部

1014
01:03:59,380 --> 01:04:02,110
直到它成功处理了所有更新。

1015
01:04:02,110 --> 01:04:05,980
哦，是的，所以，一旦它建立了 TCP 通道，

1016
01:04:05,980 --> 01:04:08,140
S2 可以说，

1017
01:04:08,320 --> 01:04:09,910
一旦你处理完这些，

1018
01:04:09,940 --> 01:04:10,930
你可以成为尾部，

1019
01:04:10,930 --> 01:04:11,950
因为你看过所有东西。

1020
01:04:12,310 --> 01:04:12,850
我是说。

1021
01:04:12,850 --> 01:04:15,760
后面的所有东西都可以按顺序排序，

1022
01:04:15,760 --> 01:04:17,170
在同一个 TCP 通道中。

1023
01:04:19,040 --> 01:04:22,010
它可以变成尾部，

1024
01:04:22,040 --> 01:04:23,870
甚至在处理更新之前，

1025
01:04:23,870 --> 01:04:26,180
只要它不服务于请求。

1026
01:04:26,660 --> 01:04:28,670
只要它不服务请求，是的，

1027
01:04:28,670 --> 01:04:30,110
它只需要处理所有更新，

1028
01:04:30,110 --> 01:04:32,000
S2 收到的 S3 没有，

1029
01:04:32,390 --> 01:04:33,680
一旦我们更新了这些，

1030
01:04:33,680 --> 01:04:37,280
然后它变成尾部，并开始处理请求。

1031
01:04:38,780 --> 01:04:41,600
我明白了，所以暂时阻塞请求，

1032
01:04:41,600 --> 01:04:43,550
当它处理新的更新时。

1033
01:04:48,820 --> 01:04:49,420
好的?

1034
01:04:52,900 --> 01:04:58,090
好的，现在我想回到很多人问的问题上，

1035
01:04:58,090 --> 01:05:00,340
这个比较起来怎么样，

1036
01:05:01,270 --> 01:05:04,660
CR 属性，链式复制属性，

1037
01:05:04,810 --> 01:05:06,370
它是如何比较的，

1038
01:05:07,700 --> 01:05:09,770
其中一个好的属性，

1039
01:05:09,770 --> 01:05:13,430
大多数与 Raft 进行比较。

1040
01:05:15,320 --> 01:05:16,910
当然，我得说，

1041
01:05:16,910 --> 01:05:22,520
当然，链式复制只影响主备方案，

1042
01:05:22,520 --> 01:05:24,350
而不是配置服务，

1043
01:05:24,470 --> 01:05:26,270
所以我们会更详细地谈到这一点，

1044
01:05:26,270 --> 01:05:27,470
但有几件事我们可以知道，

1045
01:05:27,470 --> 01:05:31,610
我们只比较方式，

1046
01:05:31,610 --> 01:05:34,910
Raft 协议和链式复制协议的工作方式。

1047
01:05:35,480 --> 01:05:37,430
首先，我们可以得到，

1048
01:05:37,430 --> 01:05:40,010
链式复制的积极方面是，

1049
01:05:40,100 --> 01:05:52,810
客户端的 RPC 拆分到头部和尾部，

1050
01:05:56,600 --> 01:06:00,200
为任何客户端操作提供服务的负载

1051
01:06:00,200 --> 01:06:02,120
可以在它们两个之间拆分，

1052
01:06:02,210 --> 01:06:05,420
它们不必像在 Raft 中那样通过领导者。

1053
01:06:06,410 --> 01:06:12,060
此外，头部发送更新一次，

1054
01:06:12,600 --> 01:06:14,070
所以不同于 Raft ，

1055
01:06:14,460 --> 01:06:18,510
头部或领导者发送更新，

1056
01:06:18,510 --> 01:06:21,240
（发送）日志条目到每个节点，

1057
01:06:21,330 --> 01:06:22,680
在这个方案中，

1058
01:06:22,680 --> 01:06:27,870
头部总是只发送一个 RPC ，

1059
01:06:28,580 --> 01:06:30,470
因此涉及的信息更少。

1060
01:06:31,220 --> 01:06:42,160
读取操作只涉及尾部，

1061
01:06:43,160 --> 01:06:44,510
与 Raft 不同，

1062
01:06:44,510 --> 01:06:48,950
即使你实现了只读优化，

1063
01:06:49,130 --> 01:06:55,070
读操作通过日志，

1064
01:06:55,220 --> 01:06:57,740
并附加到所有节点的日志中，

1065
01:06:57,920 --> 01:07:02,960
但这仍然需要领导者与大多数节点联系，

1066
01:07:03,020 --> 01:07:08,180
来决定它是不是可以服务的操作。

1067
01:07:09,820 --> 01:07:14,830
另一个[]的积极方面是简单的崩溃恢复，

1068
01:07:14,830 --> 01:07:15,730
正如我们所说的。

1069
01:07:23,620 --> 01:07:28,150
但是与 Raft 方案相比，它的一个主要缺点是，

1070
01:07:28,180 --> 01:07:35,890
你有一个故障就需要重新配置，

1071
01:07:44,720 --> 01:07:48,230
需要重新配置的原因是，

1072
01:07:48,230 --> 01:07:51,740
因为写入必须通过整个链，

1073
01:07:52,340 --> 01:07:54,740
所以，写操作无法确认，

1074
01:07:54,740 --> 01:07:58,250
直到链中的每台服务器都已经执行。

1075
01:07:58,880 --> 01:08:00,440
这略有不同，

1076
01:08:00,440 --> 01:08:01,640
在 Raft 中，如你所知，

1077
01:08:01,790 --> 01:08:05,210
因为假设大多数节点，

1078
01:08:05,210 --> 01:08:08,750
接收写操作，追加到它们的日志中，

1079
01:08:08,750 --> 01:08:10,040
系统就可以继续运行，

1080
01:08:10,640 --> 01:08:13,010
所以根本没有中断，

1081
01:08:13,010 --> 01:08:15,050
如果一台服务器出现故障，

1082
01:08:16,120 --> 01:08:18,220
如果剩余的服务器仍然构成大多数，

1083
01:08:18,580 --> 01:08:20,170
而在链式复制中，

1084
01:08:20,260 --> 01:08:22,150
如果一台服务器发生故障，

1085
01:08:22,210 --> 01:08:24,490
一些重新配置必须发生，

1086
01:08:24,490 --> 01:08:29,000
这意味着可能会有一段很短的停机时间。

1087
01:08:29,540 --> 01:08:30,260
这能理解吗？

1088
01:08:35,010 --> 01:08:37,050
现在我想再提出一点，

1089
01:08:37,050 --> 01:08:42,300
相比 Raft 复制方案是这样的，

1090
01:08:42,600 --> 01:08:45,150
因为读取操作仅涉及一个服务器，

1091
01:08:45,150 --> 01:08:48,400
有一个很酷的扩展，

1092
01:08:48,400 --> 01:08:50,980
如果你愿意，它会获得非常高的读取性能，

1093
01:08:51,160 --> 01:08:53,470
所以基本思想是这样的，

1094
01:09:10,550 --> 01:09:13,040
基本的想法是拆分，

1095
01:09:13,070 --> 01:09:17,470
拆分对象或他们在论文中所说的 volume ，

1096
01:09:17,500 --> 01:09:21,000
将对象拆分到多个链中。

1097
01:09:27,360 --> 01:09:30,780
不是像我在以前的板上做的只有一个链，

1098
01:09:30,780 --> 01:09:32,250
我们将有多条链。

1099
01:09:32,430 --> 01:09:37,560
比如我们可能有链 1 ， CH1 ，

1100
01:09:37,740 --> 01:09:42,600
S1 是头部， S2 是中间的， S3 是尾部。

1101
01:09:43,260 --> 01:09:47,720
链 2 ，我们旋转物体，

1102
01:09:47,780 --> 01:09:51,920
S2 是头部 ， S3 是中间的，

1103
01:09:51,950 --> 01:09:56,960
糟糕， S3 是中间的， S1 是尾部。

1104
01:09:57,630 --> 01:10:02,550
链 3 ，我们会安排 S3 作为头部，

1105
01:10:02,550 --> 01:10:08,760
S2 是，糟糕， S1 是中间的， S2 是尾部。

1106
01:10:09,710 --> 01:10:10,730
我们要做的是，

1107
01:10:10,730 --> 01:10:13,730
我们将把对象分成多个链，

1108
01:10:13,730 --> 01:10:15,980
所以配置服务有一个映射，

1109
01:10:15,980 --> 01:10:18,140
比如分片 1 ，

1110
01:10:18,140 --> 01:10:20,300
在分片 1 中的对象到链 1 ，

1111
01:10:20,540 --> 01:10:23,810
分片 2 中的对象到链 2 ，

1112
01:10:23,810 --> 01:10:25,910
分片 3 中的对象到链 3 。

1113
01:10:27,140 --> 01:10:29,600
它最酷的地方是，

1114
01:10:29,870 --> 01:10:32,540
我们有多个尾部,

1115
01:10:32,930 --> 01:10:35,600
S3 是某个链的尾部，

1116
01:10:35,630 --> 01:10:38,600
S1 是某个链的尾部，

1117
01:10:38,690 --> 01:10:40,520
S2 是某个链的尾部，

1118
01:10:41,030 --> 01:10:43,670
到不同链的读操作

1119
01:10:43,790 --> 01:10:46,340
现在可以完全并行执行，

1120
01:10:46,400 --> 01:10:49,910
所以，如果读操作命中不同的分片，

1121
01:10:50,120 --> 01:10:51,740
均匀的分布，

1122
01:10:51,740 --> 01:10:55,190
我们的读吞吐量会线性增加

1123
01:10:55,190 --> 01:10:57,230
随着我们拥有的尾部数量，

1124
01:10:57,260 --> 01:10:58,580
在这种情况下，我们有三个尾部，

1125
01:10:58,580 --> 01:11:00,230
所以我们获得三倍的读性能。

1126
01:11:01,260 --> 01:11:02,580
所以我们做了同样的事情，

1127
01:11:02,580 --> 01:11:05,460
所以我们得到了一些 zookeeper 拥有的相同的属性，

1128
01:11:05,730 --> 01:11:07,680
读性能可以很好，

1129
01:11:08,070 --> 01:11:09,630
随着服务器数量的增加而扩展，

1130
01:11:09,990 --> 01:11:12,090
但我们得到的不仅是这些，

1131
01:11:12,090 --> 01:11:13,470
我们得到了扩展部分，

1132
01:11:13,980 --> 01:11:15,990
并且我们保持了线性一致性，

1133
01:11:17,880 --> 01:11:20,790
在这个方案中，我们不必放弃线性一致性。

1134
01:11:22,580 --> 01:11:26,030
所以我们得到两个好的性质，

1135
01:11:26,030 --> 01:11:29,330
良好的读取性能和随服务器数量的有效扩展，

1136
01:11:29,720 --> 01:11:32,660
至少对于读取不同的链，

1137
01:11:32,660 --> 01:11:35,990
并且我们保持了线性一致性。

1138
01:11:43,420 --> 01:11:44,440
关于这个，有什么问题吗？

1139
01:11:49,540 --> 01:11:50,350
抱歉，在这种情况下，

1140
01:11:50,350 --> 01:11:55,840
客户端什么时候决定从哪个链进行读取，

1141
01:11:56,260 --> 01:12:00,580
它们能够自己决定吗，

1142
01:12:00,580 --> 01:12:04,810
或者它们是否需要联系配置服务器来决定。

1143
01:12:05,140 --> 01:12:06,760
是的，所以这是一个很好的问题，

1144
01:12:06,760 --> 01:12:10,480
所以通常情况下，这篇论文并没有明确地说明这一点，

1145
01:12:10,480 --> 01:12:14,890
它们谈到也许可以通过代理访问服务器，

1146
01:12:15,160 --> 01:12:16,810
你在实验 4 中要做的是

1147
01:12:16,810 --> 01:12:18,610
你会下载配置，

1148
01:12:18,850 --> 01:12:21,430
配置包含分片分配，

1149
01:12:21,880 --> 01:12:24,880
然后你从配置服务器下载。

1150
01:12:28,820 --> 01:12:29,960
你需要注意

1151
01:12:29,960 --> 01:12:32,240
如何对每个链中的服务器进行排序，

1152
01:12:32,240 --> 01:12:35,120
防止某个链过饱和，

1153
01:12:35,300 --> 01:12:37,550
或两个服务器之间的特定[链路]。

1154
01:12:38,140 --> 01:12:42,490
是的，这个方案没有考虑到这一点，

1155
01:12:42,490 --> 01:12:46,150
你可以想象配置方案或配置管理器

1156
01:12:46,150 --> 01:12:49,510
拥有网络布局的复杂模型，

1157
01:12:49,510 --> 01:12:51,970
可以非常小心地注意链是如何做的，

1158
01:12:53,810 --> 01:12:56,060
可能更多的分片在一条链上，

1159
01:12:56,060 --> 01:12:57,740
而更少的分片在另一条链上，

1160
01:12:57,740 --> 01:12:59,540
所有的事情原则上都是可能的，

1161
01:12:59,630 --> 01:13:03,380
因为配置管理可以计算任何东西，

1162
01:13:03,380 --> 01:13:05,510
并且说这是分配。

1163
01:13:08,220 --> 01:13:08,670
谢谢。

1164
01:13:09,030 --> 01:13:10,860
如果它想的话，甚至可以重新平衡。

1165
01:13:18,560 --> 01:13:19,190
回答问题，

1166
01:13:19,190 --> 01:13:22,550
你能再解释一下线性一致性是如何在这个扩展下保持的吗？

1167
01:13:22,550 --> 01:13:24,620
好的，什么都没有真正改变，

1168
01:13:24,650 --> 01:13:27,800
我们仍在使用链进行主备，

1169
01:13:28,070 --> 01:13:35,690
所以，我们从单链延续了线性一致性，

1170
01:13:35,720 --> 01:13:36,440
就是这样。

1171
01:13:42,470 --> 01:13:44,180
这可能是猜测的，

1172
01:13:44,180 --> 01:13:45,830
但这个相比，

1173
01:13:47,020 --> 01:13:51,430
我想这可能相当于每个链接有一组服务器，

1174
01:13:51,790 --> 01:13:53,500
而不是重复使用相同的那个，

1175
01:13:53,530 --> 01:13:54,820
或者不是针对每个链接，

1176
01:13:54,820 --> 01:13:58,330
而是针对链中的每一步，

1177
01:13:58,330 --> 01:14:00,400
所以，就像 S1 有三台服务器，

1178
01:14:00,400 --> 01:14:01,750
S2 有三台服务器，

1179
01:14:02,050 --> 01:14:03,910
而不是重复使用相同的那个，

1180
01:14:04,180 --> 01:14:05,650
从不同的角度进入。

1181
01:14:06,190 --> 01:14:11,260
是的，你想象的那个方案有什么好处？

1182
01:14:11,260 --> 01:14:12,850
我的意思是，为了可扩展性，

1183
01:14:14,860 --> 01:14:17,320
同时保持线性一致性。

1184
01:14:17,530 --> 01:14:20,680
好的，这个方案有吸引力的原因是，

1185
01:14:20,680 --> 01:14:22,630
因为我们尾部可能有相当多的负载，

1186
01:14:22,630 --> 01:14:23,770
但中间的那个不会，

1187
01:14:23,800 --> 01:14:26,110
通过这样的安排，

1188
01:14:26,230 --> 01:14:28,150
我们将负载分散到所有服务器上。

1189
01:14:30,910 --> 01:14:31,810
我明白了，好的。

1190
01:14:40,090 --> 01:14:40,750
好的，很好。

1191
01:14:41,450 --> 01:14:43,790
所以也许我在这里总结一下，

1192
01:14:47,850 --> 01:14:50,220
然后稍微讨论一下，

1193
01:14:50,220 --> 01:14:51,720
所以我们看到了方法 1 ，

1194
01:14:52,830 --> 01:14:56,810
我们在实验 3 所做的，

1195
01:14:56,810 --> 01:14:59,990
运行所有的操作通过 Raft ，

1196
01:14:59,990 --> 01:15:07,040
或者配置和复制都是使用 Raft 构建的，

1197
01:15:07,040 --> 01:15:08,360
而且没有牵涉其他东西，

1198
01:15:08,660 --> 01:15:10,430
然后是方法 2 ，

1199
01:15:10,460 --> 01:15:13,970
是这篇论文的主题，

1200
01:15:13,970 --> 01:15:16,340
有一个配置服务器，

1201
01:15:16,400 --> 01:15:21,380
可能使用 Raft 或 Paxos 或其他，

1202
01:15:21,620 --> 01:15:24,710
以及一个主备复制方案，

1203
01:15:26,010 --> 01:15:32,410
同时主备使用链式复制。

1204
01:15:39,690 --> 01:15:40,890
你可以看到，

1205
01:15:40,890 --> 01:15:43,170
希望这里更清楚，

1206
01:15:43,170 --> 01:15:45,660
方法 2 有一些吸引人的性质，

1207
01:15:45,990 --> 01:15:47,610
从某种意义上说，

1208
01:15:47,940 --> 01:15:50,250
你可以获得可扩展的读取性能，

1209
01:15:50,370 --> 01:15:52,530
在主备上，

1210
01:15:52,830 --> 01:15:54,510
当然不在配置服务器上，

1211
01:15:54,510 --> 01:15:56,850
因为它运行 Raft ，

1212
01:15:56,850 --> 01:15:58,620
你在使用方法 1 ，

1213
01:15:58,950 --> 01:16:00,300
但你至少可以，

1214
01:16:00,300 --> 01:16:03,990
可能对复制上的操作扩展读性能，

1215
01:16:03,990 --> 01:16:06,240
或者在主备方案中，

1216
01:16:06,270 --> 01:16:07,470
put 和 get 操作。

1217
01:16:08,270 --> 01:16:12,290
这个的另一个好处是，

1218
01:16:12,770 --> 01:16:15,710
如果数据非常大，

1219
01:16:15,740 --> 01:16:20,600
你可以有更专业的同步，

1220
01:16:20,600 --> 01:16:25,580
或者将状态从一台机器复制到另一台机器的方案。

1221
01:16:26,180 --> 01:16:30,650
链式复制或任何类型的主备方案，

1222
01:16:30,650 --> 01:16:32,360
与配置服务器分开，

1223
01:16:32,390 --> 01:16:33,710
使你可以轻松地做到这一点。

1224
01:16:34,500 --> 01:16:36,000
所示，这是很常见的，

1225
01:16:36,000 --> 01:16:39,360
人们在实践中使用方法 2 ，

1226
01:16:39,600 --> 01:16:41,760
尽管也不是不可能，

1227
01:16:41,760 --> 01:16:46,710
对复制状态机使用方法 1 ，

1228
01:16:46,710 --> 01:16:51,330
包括像 put get 操作这样的服务操作，

1229
01:16:51,330 --> 01:16:53,220
实际上，实验 3 会这样做，

1230
01:16:53,220 --> 01:16:57,090
我们将在本学期晚些时候看到论文 Spanner ，

1231
01:16:57,150 --> 01:17:00,780
它也使用 Paxos 来完成操作。

1232
01:17:03,780 --> 01:17:05,010
这里还有什么问题吗？

1233
01:17:14,710 --> 01:17:15,220
如果没有，

1234
01:17:15,220 --> 01:17:18,340
那么我祝大家在周四的期中考试中好运，

1235
01:17:18,610 --> 01:17:23,260
我会在下周当面见你，虚拟的当面。

1236
01:17:28,780 --> 01:17:29,950
如果你有任何问题，

1237
01:17:30,100 --> 01:17:32,110
请随意留在这里，

1238
01:17:32,560 --> 01:17:35,500
我会尽最大的努力回答他们。

1239
01:17:36,520 --> 01:17:41,740
我有一个关于你提到的关于 Raft 的问题，

1240
01:17:41,740 --> 01:17:45,730
你提到，所有的读取都必须通过大多数服务器，

1241
01:17:45,880 --> 01:17:47,710
但我不太明白为什么，

1242
01:17:47,710 --> 01:17:51,940
因为领导者有所有提交的条目，对吧。

1243
01:17:51,940 --> 01:17:53,590
是的，有两个方案，

1244
01:17:53,620 --> 01:17:56,350
如果领导者，

1245
01:17:56,470 --> 01:17:58,360
所以要么你遇到这样一种情况，

1246
01:17:58,360 --> 01:18:01,860
所有最近的写入都由领导者提供服务，

1247
01:18:02,440 --> 01:18:05,200
或者从原则上讲，

1248
01:18:05,200 --> 01:18:07,060
读操作由其他节点提供服务，

1249
01:18:07,060 --> 01:18:10,960
然后你必须首先联系大多数服务器，

1250
01:18:10,960 --> 01:18:13,180
以确保大多数有最近的操作。

1251
01:18:14,990 --> 01:18:15,410
明白了,

1252
01:18:15,410 --> 01:18:17,270
所以，这个需求是，

1253
01:18:17,270 --> 01:18:21,230
如果我们想要将所有读取分布在每个节点上。

1254
01:18:21,230 --> 01:18:23,000
我们必须更老练一些，

1255
01:18:23,240 --> 01:18:25,220
我们不能靠自己做到这一点，

1256
01:18:25,220 --> 01:18:27,260
因为这肯定会破坏线性一致性。

1257
01:18:28,450 --> 01:18:30,400
是的，但如果一切都通过领导者。

1258
01:18:30,640 --> 01:18:32,560
然后当你到达那里的时候，

1259
01:18:32,560 --> 01:18:34,300
你必须使用这个技巧，

1260
01:18:34,300 --> 01:18:37,210
你要求一个空的[同意]，

1261
01:18:37,210 --> 01:18:39,340
在每个新 term 开始的时候，

1262
01:18:41,120 --> 01:18:43,040
只是为了确保你确实是最新的。

1263
01:18:45,710 --> 01:18:46,760
好的，谢谢。

1264
01:18:48,130 --> 01:18:50,890
你能不能，再快速地说一下，

1265
01:18:51,010 --> 01:18:53,620
当你在尾部添加新服务器时，

1266
01:18:54,360 --> 01:18:56,610
所以为了确保我明白，

1267
01:18:56,610 --> 01:18:59,400
所以，实质上，它启动了这个过程，

1268
01:18:59,400 --> 01:19:01,860
将所有数据从 S2 复制到 S3 ，

1269
01:19:02,430 --> 01:19:05,340
然后，如果它接收到对任何数据的请求，

1270
01:19:05,340 --> 01:19:08,030
在这种情况仍在发生的时候，

1271
01:19:08,030 --> 01:19:12,710
然后， S3 将直接向 S2 索要其仍有的任何东西，

1272
01:19:12,710 --> 01:19:14,330
它会得到，然后做出响应。

1273
01:19:14,600 --> 01:19:15,080
是的。

1274
01:19:15,600 --> 01:19:16,620
然后它继续这样做，

1275
01:19:16,620 --> 01:19:19,590
直到它获得 S2 不再有的数据，

1276
01:19:19,590 --> 01:19:21,210
然后它就直接上线了。

1277
01:19:21,540 --> 01:19:23,310
是的，或者你可以稍微改变一下，

1278
01:19:23,310 --> 01:19:29,610
你可以让 S3 告诉 S2 ，

1279
01:19:31,820 --> 01:19:35,630
S3 可以成为领导者，抱歉，尾部，

1280
01:19:35,660 --> 01:19:40,310
不要处理来自客户端的任何操作，

1281
01:19:40,310 --> 01:19:44,450
直到它收到来自 S2 的剩余操作。

1282
01:19:47,140 --> 01:19:49,690
哦，那么在这种情况下， S2 仍然是尾部。

1283
01:19:50,970 --> 01:19:51,870
是的。

1284
01:19:51,870 --> 01:19:53,490
直到 S3 得到一切。

1285
01:19:53,730 --> 01:19:54,180
是的。

1286
01:19:56,910 --> 01:20:00,180
基本上，这篇论文描述了一种特殊的方法，

1287
01:20:00,180 --> 01:20:01,620
有几种方法可以做到这一点。

1288
01:20:04,000 --> 01:20:05,710
但如果你这么做了，

1289
01:20:06,430 --> 01:20:11,260
那么你要等多久才能获得所有东西，

1290
01:20:13,140 --> 01:20:15,570
我想我也有和其他人一样的困惑。

1291
01:20:15,570 --> 01:20:18,690
你知道转换发生的顺序，

1292
01:20:18,690 --> 01:20:24,840
举个例子，假设 S2 有 100 的运算，

1293
01:20:25,460 --> 01:20:26,870
你开始复制操作，

1294
01:20:26,870 --> 01:20:28,700
就像 Raft 中的快照，

1295
01:20:28,970 --> 01:20:30,320
你开始复制操作，

1296
01:20:30,320 --> 01:20:31,880
所以，当复制操作完成时，

1297
01:20:31,880 --> 01:20:34,900
S3 更新到 100 ，

1298
01:20:36,390 --> 01:20:39,900
然后也许 S2 已经多了 10 个操作，

1299
01:20:39,930 --> 01:20:43,530
所以它有 101 102 和 103 ，

1300
01:20:44,220 --> 01:20:48,240
S3 可以联系 S2 ，

1301
01:20:48,240 --> 01:20:50,520
说，把你剩余的操作给我，

1302
01:20:50,520 --> 01:20:53,850
S2 说，好的，剩余的操作是 101 到 110 ，

1303
01:20:55,000 --> 01:20:56,770
作为连带的效果，

1304
01:20:56,770 --> 01:21:00,460
S3 也告诉 S2 不要再做尾部了，

1305
01:21:01,540 --> 01:21:04,900
S2 使用这些操作做出响应，

1306
01:21:05,140 --> 01:21:08,740
S3 应用这些操作从 101 到 110 ，

1307
01:21:08,890 --> 01:21:12,190
然后告诉客户端它是尾部，

1308
01:21:12,190 --> 01:21:14,500
但它还不能处理来自客户端的任何命令，

1309
01:21:14,770 --> 01:21:16,060
或来自客户端的读操作，

1310
01:21:16,060 --> 01:21:18,400
直到它处理了 101 到 110 。

1311
01:21:21,380 --> 01:21:25,620
好的，好的，我明白了，理解了。

1312
01:21:26,850 --> 01:21:28,410
我还有一个问题，

1313
01:21:29,280 --> 01:21:29,970
哦，抱歉。

1314
01:21:31,560 --> 01:21:32,730
不，继续，继续。

1315
01:21:33,000 --> 01:21:39,900
好的，我的问题和他说到的扩展有些类似，

1316
01:21:40,660 --> 01:21:42,640
我在想，

1317
01:21:42,790 --> 01:21:46,990
你能不能使用一个树而不是一个链，所以。

1318
01:21:47,630 --> 01:21:51,500
我认为有，

1319
01:21:52,100 --> 01:21:54,290
还有其他可能的数据结构，

1320
01:21:54,320 --> 01:21:58,340
例如，很多人在电子邮件中建议，

1321
01:21:58,520 --> 01:22:00,020
你可以有 S1 ，

1322
01:22:00,140 --> 01:22:04,010
然后你可以有 S3 4 5 ，所有都是中间的，

1323
01:22:04,010 --> 01:22:07,430
S1 与所有中间的并行交互，

1324
01:22:07,430 --> 01:22:11,810
中间的与尾部交互，

1325
01:22:12,320 --> 01:22:14,810
你说的树是这个意思吗？

1326
01:22:15,080 --> 01:22:20,210
我的意思是更多，

1327
01:22:20,780 --> 01:22:23,230
比如很多叶子节点，

1328
01:22:23,230 --> 01:22:26,230
它们的高度大致相同，

1329
01:22:26,260 --> 01:22:27,580
就像一棵平衡树，

1330
01:22:27,790 --> 01:22:31,840
然后叶子会有一条链穿过它们，

1331
01:22:33,400 --> 01:22:39,370
我认为线性一致性在这里可以被打破，

1332
01:22:39,430 --> 01:22:43,360
如果你仔细考虑一下，

1333
01:22:43,360 --> 01:22:45,910
但它将拥有好的性质，

1334
01:22:45,910 --> 01:22:46,960
你不需要，

1335
01:22:46,990 --> 01:22:51,960
现在的传播延迟可以是[对数式的]，

1336
01:22:51,990 --> 01:22:53,850
而不是这里的线性的，

1337
01:22:53,850 --> 01:22:55,380
你可以从所有的叶子节点读取。

1338
01:22:55,380 --> 01:22:58,290
好的，从所有的叶子节点读取是危险的，

1339
01:22:58,290 --> 01:23:00,240
因为它们可能有，

1340
01:23:00,270 --> 01:23:04,050
一个客户端可能早些时候访问过另一个叶子节点，

1341
01:23:04,080 --> 01:23:05,910
叶子节点可能不同步，

1342
01:23:06,770 --> 01:23:11,240
所以我觉得这听起来有危险，

1343
01:23:11,240 --> 01:23:14,870
也许你的方案比我想象的更复杂，

1344
01:23:15,470 --> 01:23:18,920
树的深度或者链条的深度

1345
01:23:18,920 --> 01:23:23,270
是由失败之间的时间决定的，

1346
01:23:23,890 --> 01:23:25,780
如果你在，

1347
01:23:26,020 --> 01:23:28,600
如果你通常运行 3 台服务器， 3 到 5 台服务器，

1348
01:23:28,600 --> 01:23:32,080
因为这对你的高可用性来说已经足够好了，

1349
01:23:32,200 --> 01:23:35,740
然后，因为你可以从 4 台服务器恢复，

1350
01:23:35,740 --> 01:23:37,390
在整件事完成之前，

1351
01:23:37,780 --> 01:23:42,640
然后这就覆盖了链的深度，

1352
01:23:43,260 --> 01:23:46,260
是的，我们会引入一些延迟。

1353
01:23:49,770 --> 01:23:51,630
好的，有道理，谢谢。

1354
01:23:51,630 --> 01:23:53,280
链一般都是短的。

1355
01:23:53,930 --> 01:23:56,780
好的，有道理，谢谢。

1356
01:23:57,260 --> 01:23:57,740
不用谢。

1357
01:23:59,030 --> 01:24:02,030
这是唯一整个链宕机的情况吗，

1358
01:24:02,580 --> 01:24:04,920
如果链中的所有服务器都宕机了？

1359
01:24:05,190 --> 01:24:05,610
是的。

1360
01:24:07,370 --> 01:24:07,820
谢谢。

1361
01:24:09,640 --> 01:24:14,050
我也很好奇如何保持强一致性，

1362
01:24:14,050 --> 01:24:19,750
在这个幻灯片中， S1 S2 S3 都可以进行读取。

1363
01:24:21,340 --> 01:24:25,990
你可以获得每个分片或每个对象的强一致性，

1364
01:24:25,990 --> 01:24:27,670
这是分配给链的，对吧。

1365
01:24:28,520 --> 01:24:32,570
所以如果写入一个对象，

1366
01:24:32,780 --> 01:24:35,060
你写入对象一，你读取对象一，

1367
01:24:35,210 --> 01:24:37,280
所有这些操作都经过相同的链，

1368
01:24:37,280 --> 01:24:40,070
所以，对于那个特定的对象，你会得到强一致性。

1369
01:24:40,610 --> 01:24:41,810
哦，知道了。

1370
01:24:41,900 --> 01:24:42,860
但情况可能并非如此，

1371
01:24:43,280 --> 01:24:45,560
在所有的对象上，我们都有强一致性。

1372
01:24:45,770 --> 01:24:52,340
不，我不，让我犹豫一下。

1373
01:24:57,270 --> 01:24:57,900
让我犹豫一下，

1374
01:24:57,900 --> 01:25:00,630
我想这可能需要更多的机制。

1375
01:25:00,990 --> 01:25:02,310
那么，这是什么意思，

1376
01:25:02,340 --> 01:25:05,130
所有的对象获得强一致性。

1377
01:25:05,220 --> 01:25:08,460
我认为你读写对象一，

1378
01:25:08,910 --> 01:25:10,590
你读或写对象二，

1379
01:25:11,150 --> 01:25:14,810
然后一些客户端读取对象一，

1380
01:25:15,620 --> 01:25:17,300
你会获得，

1381
01:25:18,210 --> 01:25:20,730
基本上，如果你有一个客户端读取这两个对象，

1382
01:25:20,730 --> 01:25:24,300
你能不能保证看到整体顺序和线性一致性。

1383
01:25:24,300 --> 01:25:26,310
这类似于可串行化吗？

1384
01:25:27,030 --> 01:25:28,890
可串行化略有不同，

1385
01:25:28,950 --> 01:25:31,860
也许，我们不要讨论可串行化，

1386
01:25:31,860 --> 01:25:34,230
我们会回来，我们会在几周后讨论。

1387
01:25:34,680 --> 01:25:36,510
嗯。

1388
01:25:40,740 --> 01:25:43,290
我现在[]做出承诺，

1389
01:25:43,500 --> 01:25:44,940
我需要考虑一下。

1390
01:25:45,300 --> 01:25:46,290
好的，这完全可以。

1391
01:25:48,280 --> 01:25:50,170
所以问题是这样的，

1392
01:25:50,440 --> 01:25:54,880
你具有单个客户端读取和写入的一致性或线性一致性，

1393
01:25:55,210 --> 01:25:58,450
但不是针对多个对象。

1394
01:25:58,630 --> 01:26:01,930
你有多个客户端访问这个，

1395
01:26:01,930 --> 01:26:04,510
在同一个对象上执行操作，

1396
01:26:04,510 --> 01:26:07,060
在这个方案中，具有强一致性，

1397
01:26:07,420 --> 01:26:08,410
问题是，

1398
01:26:08,470 --> 01:26:12,040
我们也可以有跨对象的线性一致性。

1399
01:26:13,410 --> 01:26:15,540
但是，为什么这很重要，

1400
01:26:15,960 --> 01:26:20,040
我没有看出，这在哪里是重要的，

1401
01:26:21,600 --> 01:26:28,060
因为你，你不能对操作进行分组，

1402
01:26:28,180 --> 01:26:30,850
就像一次写入和一次写入。

1403
01:26:31,000 --> 01:26:32,740
我的意思是你读取对象一，

1404
01:26:32,740 --> 01:26:34,510
你写入对象一，你读取对象一，

1405
01:26:34,510 --> 01:26:36,730
你读取对象二，你写入对象二，

1406
01:26:37,030 --> 01:26:41,600
问题是，

1407
01:26:41,600 --> 01:26:45,410
在线性一致性中，这些操作需要是完全有序的，

1408
01:26:45,740 --> 01:26:51,020
它们需要保持这种属性的实时性。

1409
01:26:52,740 --> 01:26:54,540
因为你有不同的链，

1410
01:26:54,540 --> 01:26:56,280
这可能不会发生，

1411
01:26:56,280 --> 01:26:58,170
但我不想承诺，

1412
01:26:58,200 --> 01:27:00,900
不确定关于所有链的[声明]。

1413
01:27:01,380 --> 01:27:04,020
链保证了线性一致性，

1414
01:27:04,020 --> 01:27:05,370
即使你有不同的对象。

1415
01:27:08,290 --> 01:27:09,970
在论文中，我有一些事情不明白，

1416
01:27:09,970 --> 01:27:13,330
就是更新传播不变量，

1417
01:27:14,110 --> 01:27:17,170
就像是，

1418
01:27:17,760 --> 01:27:20,820
在这个链的顺序中。

1419
01:27:21,030 --> 01:27:21,570
是的。

1420
01:27:21,630 --> 01:27:27,630
提交是每个后续提交的前缀，

1421
01:27:28,920 --> 01:27:33,870
这是不是保证[完整传递]通过链？

1422
01:27:34,620 --> 01:27:35,700
不，它总是真的，

1423
01:27:35,700 --> 01:27:38,070
比如你再看这张图片，

1424
01:27:42,020 --> 01:27:44,390
我认为他们做了一个非常简单的观察，

1425
01:27:44,390 --> 01:27:46,580
让我们看看，能不能找到那张图片，

1426
01:27:47,960 --> 01:27:49,670
我可能什么都胡乱写下来了，

1427
01:27:49,670 --> 01:27:52,250
所以它可能不是那么干净，

1428
01:27:52,730 --> 01:27:54,140
基本上他们说的是，

1429
01:27:54,140 --> 01:27:55,700
如果你看这个图，

1430
01:27:55,970 --> 01:28:00,240
S3 总是具有前缀 S2 ，

1431
01:28:00,240 --> 01:28:02,070
并且 S2 总是具有前缀 S1 ，

1432
01:28:05,960 --> 01:28:08,840
这是唯一一件不变量的事情。

1433
01:28:09,440 --> 01:28:13,180
哦，那么 i 和 j ，

1434
01:28:13,210 --> 01:28:16,630
那么后继者的前缀是前缀吗？

1435
01:28:16,660 --> 01:28:18,820
是的，这有点让人困惑，

1436
01:28:18,820 --> 01:28:20,020
我后来才意识到，

1437
01:28:20,020 --> 01:28:22,360
在别人问了这个问题之后，

1438
01:28:22,720 --> 01:28:28,960
在定义中， i 和 j 是两种不同的方式，

1439
01:28:29,020 --> 01:28:30,430
嗯，没有什么不同的方式，

1440
01:28:30,430 --> 01:28:31,630
一个是定义，

1441
01:28:32,100 --> 01:28:35,460
一个是不变量，

1442
01:28:36,030 --> 01:28:38,970
你要小心一点，

1443
01:28:39,060 --> 01:28:42,630
i 和 j 在链中的角色。

1444
01:28:42,630 --> 01:28:43,230
这有点绕。

1445
01:28:43,260 --> 01:28:44,250
是的，就是这样。

1446
01:28:44,250 --> 01:28:45,030
这怎么可能。

1447
01:28:45,780 --> 01:28:46,650
没错。

1448
01:28:47,140 --> 01:28:47,740
谢谢。

1449
01:28:48,100 --> 01:28:48,670
不用谢。

1450
01:28:50,060 --> 01:28:51,620
我是，糟糕。

1451
01:28:52,070 --> 01:28:53,150
嗯。

1452
01:28:54,390 --> 01:28:55,500
我只是想问，

1453
01:28:55,500 --> 01:28:59,610
当你有一个网络分区而不是崩溃时会发生什么，

1454
01:28:59,790 --> 01:29:03,210
如果看崩溃的幻灯片，

1455
01:29:03,610 --> 01:29:04,810
链发生了什么，

1456
01:29:04,810 --> 01:29:06,100
如果有网络分区，

1457
01:29:06,100 --> 01:29:08,290
所以也许可以问这样的问题，

1458
01:29:08,410 --> 01:29:11,200
比如 S2 实际上还活着，

1459
01:29:11,380 --> 01:29:15,640
但是在配置管理器和 S2 或其他什么之间有一个分区，

1460
01:29:15,880 --> 01:29:18,700
所以现在 S1 和 S2 都指向 S3 。

1461
01:29:20,130 --> 01:29:23,220
不，是的，

1462
01:29:23,280 --> 01:29:26,010
好的，显然会有一些，

1463
01:29:26,010 --> 01:29:28,200
当我想人们在谈论这件事时，

1464
01:29:28,200 --> 01:29:31,800
但我假设所有的配置都有编号，比如[]编号，

1465
01:29:32,100 --> 01:29:35,880
S3 不会接受任何来自 S2 的命令，

1466
01:29:35,880 --> 01:29:38,010
如果[]编号不匹配。

1467
01:29:39,560 --> 01:29:40,790
哦，理解了，谢谢。

1468
01:29:41,410 --> 01:29:43,090
与这个有关，

1469
01:29:43,090 --> 01:29:44,290
我不能理解的一件事是，

1470
01:29:44,290 --> 01:29:47,230
即使有类似的配置编号或其他东西，

1471
01:29:47,230 --> 01:29:49,870
你如何确保当你丢失尾部时，

1472
01:29:49,870 --> 01:29:51,370
就像你画的第三个场景，

1473
01:29:51,610 --> 01:29:52,900
当你丢失尾部时，

1474
01:29:52,900 --> 01:29:55,540
可能所有发出读取命令的客户端

1475
01:29:55,780 --> 01:29:57,850
都知道这台旧服务器不再。

1476
01:29:58,270 --> 01:30:00,940
客户端，我认为你做的方式是，

1477
01:30:00,940 --> 01:30:04,990
当客户端从配置管理器下载配置时，

1478
01:30:04,990 --> 01:30:06,430
它们还包括[]编号，

1479
01:30:06,670 --> 01:30:08,770
每个操作都包括[]编号，

1480
01:30:08,770 --> 01:30:13,350
S3 会说，这是一个旧的[]编号，

1481
01:30:13,470 --> 01:30:14,520
不要访问。

1482
01:30:14,850 --> 01:30:19,440
我想，当客户端访问配置获得[]编号，

1483
01:30:19,440 --> 01:30:20,820
我首先从一个客户端开始，

1484
01:30:21,030 --> 01:30:21,780
它有一个老的。

1485
01:30:21,780 --> 01:30:26,160
例如， S2 可以重试，

1486
01:30:26,490 --> 01:30:30,690
然后客户端返回到配置服务器并重新读取状态。

1487
01:30:32,380 --> 01:30:33,910
我想我担心的是，

1488
01:30:33,910 --> 01:30:38,680
比如 S3 与协调器网络分区，

1489
01:30:38,770 --> 01:30:41,260
所以协调器从尾部去掉 S3 ，

1490
01:30:41,260 --> 01:30:42,580
并增加版本号，

1491
01:30:42,850 --> 01:30:46,150
但是有些客户端并没有发现版本号增加了，

1492
01:30:46,210 --> 01:30:47,800
并且仍然认为 S3 是尾部，

1493
01:30:47,830 --> 01:30:49,450
访问 S3 不要读取，

1494
01:30:49,570 --> 01:30:51,910
同时人们对 S1 S2 进行写入，

1495
01:30:51,910 --> 01:30:55,420
它们还没有看到这个。

1496
01:30:55,800 --> 01:30:59,190
是的，这可能就是为什么论文中通过代理。

1497
01:31:01,870 --> 01:31:05,250
我明白了，好的。

1498
01:31:07,460 --> 01:31:10,160
我有一个问题，回到那个问题上来，

1499
01:31:10,520 --> 01:31:12,530
没有回答的问题，

1500
01:31:13,600 --> 01:31:16,750
比如跨对象线性一致性，

1501
01:31:16,990 --> 01:31:19,180
我想，

1502
01:31:20,440 --> 01:31:23,830
这是不是[]我们还没有谈论过的，

1503
01:31:23,830 --> 01:31:25,510
如果你想做的话，

1504
01:31:25,540 --> 01:31:26,500
我不知道什么是正确的术语，

1505
01:31:26,500 --> 01:31:31,780
但是比如事务，跨多个部分状态，

1506
01:31:31,780 --> 01:31:34,860
例如，如果尝试实现一项操作，

1507
01:31:34,860 --> 01:31:37,110
你把 a 设置为 1 ， b 设置为 2 ，

1508
01:31:37,110 --> 01:31:39,660
你应该一起看到它们，或者根本看不到，

1509
01:31:39,660 --> 01:31:40,890
就像[]那样，

1510
01:31:40,920 --> 01:31:44,100
我们有没有讨论过在以前见过的任何东西。

1511
01:31:44,220 --> 01:31:46,200
不，我们会在后面几个星期讨论，

1512
01:31:47,040 --> 01:31:48,450
这将是一个大话题，

1513
01:31:48,570 --> 01:31:50,250
就是怎么做事务。

1514
01:31:50,740 --> 01:31:53,140
好的，很高兴知道，谢谢。

1515
01:31:54,980 --> 01:31:57,260
你可以回去看第三张幻灯片吗？

1516
01:31:58,100 --> 01:31:58,580
是的。

1517
01:32:00,050 --> 01:32:01,430
我可以去看第三张幻灯片，

1518
01:32:03,580 --> 01:32:05,620
也许不是，第四张幻灯片，

1519
01:32:09,110 --> 01:32:11,210
哦，是第五张幻灯片，抱歉，

1520
01:32:12,410 --> 01:32:13,940
所以我有点困惑，

1521
01:32:13,970 --> 01:32:17,570
你提到，如果锁持有者在中间状态失败，

1522
01:32:17,840 --> 01:32:21,470
这张幻灯片上的哪些内容适用于 zlock ，

1523
01:32:21,470 --> 01:32:23,090
哪些适用于 Go 锁。

1524
01:32:24,160 --> 01:32:27,640
这些几乎都是关于 zlock 的语句。

1525
01:32:29,760 --> 01:32:32,730
所以是否第一个语句，如果锁持有者失败，

1526
01:32:32,730 --> 01:32:36,180
那么中间状态不被清除，或者被清除。

1527
01:32:36,270 --> 01:32:39,270
不，中间状态是可见的，

1528
01:32:39,540 --> 01:32:41,760
但如果你有一个领导者选举，

1529
01:32:41,760 --> 01:32:43,350
你可以清理中间状态，

1530
01:32:43,350 --> 01:32:47,230
这就是重点所在。

1531
01:32:47,230 --> 01:32:49,090
哦，所以有了 Go 锁，

1532
01:32:49,090 --> 01:32:50,410
难道不也是这样吗，

1533
01:32:50,410 --> 01:32:52,480
例如，如果有一台机器持有 Go 锁，

1534
01:32:52,720 --> 01:32:53,650
它正在做一些事情，

1535
01:32:53,680 --> 01:32:56,020
然后所有突然宕机，

1536
01:32:56,170 --> 01:32:58,330
中间状态是否仍然可见。

1537
01:32:59,410 --> 01:33:02,170
好的，我想我说的 Go 锁，

1538
01:33:02,170 --> 01:33:05,110
是一个关于多个线程的语句，

1539
01:33:05,110 --> 01:33:06,700
在同一台计算机上运行，

1540
01:33:07,000 --> 01:33:10,150
所以如果 Go 锁消失了，

1541
01:33:10,150 --> 01:33:11,020
因为机器崩溃了，

1542
01:33:11,020 --> 01:33:12,790
那台机器上的所有线程也会崩溃。

1543
01:33:20,680 --> 01:33:26,740
是的，但是，当你说中间状态对其他人是可见的，

1544
01:33:27,430 --> 01:33:29,620
这对于 Go 锁来说，仍然是正确的。

1545
01:33:30,640 --> 01:33:34,420
如果它们将持久状态写入磁盘，

1546
01:33:34,420 --> 01:33:36,100
或某个共享文件系统，

1547
01:33:36,100 --> 01:33:37,210
不，机器已经不在了，

1548
01:33:37,210 --> 01:33:38,590
磁盘不见了，一切都不见了。

1549
01:33:40,220 --> 01:33:41,390
哦，知道了，好的，

1550
01:33:41,420 --> 01:33:42,260
所以这就是说，

1551
01:33:42,260 --> 01:33:45,980
比如中间状态持久化。

1552
01:33:46,010 --> 01:33:48,620
zookeeper 中间状态可能是可见的，

1553
01:33:48,650 --> 01:33:51,920
我们要删除可能创建了更多文件的，

1554
01:33:51,920 --> 01:33:53,480
这些都是可见的。

1555
01:33:54,550 --> 01:33:56,320
好的，我明白了，谢谢。

1556
01:33:56,740 --> 01:33:58,390
所以只是继续这个，

1557
01:33:58,390 --> 01:34:03,520
如果 goroutine 在持有锁的过程中死亡，

1558
01:34:04,100 --> 01:34:06,260
整个 Go 程序肯定也死了。

1559
01:34:07,820 --> 01:34:10,880
你永远不会有持有锁的 goroutine 死亡，

1560
01:34:10,970 --> 01:34:13,220
并继续其他部分的程序。

1561
01:34:14,000 --> 01:34:14,330
好的。

1562
01:34:15,070 --> 01:34:17,230
goroutine 崩溃，应用程序崩溃。

