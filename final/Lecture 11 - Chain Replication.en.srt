1
00:00:00,000 --> 00:00:02,790
Good evening or good night wherever you are,

2
00:00:02,820 --> 00:00:03,780
let's get started.

3
00:00:04,440 --> 00:00:08,310
So today, I wanna talk a little bit about chain replication,

4
00:00:08,310 --> 00:00:12,450
the paper aside for today from 2004,

5
00:00:12,450 --> 00:00:14,280
before diving into the paper,

6
00:00:14,280 --> 00:00:18,270
a couple quick logistic things I just want to remind you of,

7
00:00:18,810 --> 00:00:22,530
one is we have a quiz on Thursday,

8
00:00:23,830 --> 00:00:28,600
and you know the instructions of topics that actually being covered all the quiz

9
00:00:28,600 --> 00:00:29,770
are on the schedule page,

10
00:00:29,800 --> 00:00:34,480
we'll try to send out an announcement of Piazza for more details

11
00:00:34,780 --> 00:00:37,720
about exactly how we'll do the quiz,

12
00:00:38,020 --> 00:00:39,700
it's going to be in grade scope,

13
00:00:39,730 --> 00:00:44,380
and it's basically during class hours 80 minutes,

14
00:00:44,470 --> 00:00:48,130
and more details to follow.

15
00:00:49,010 --> 00:00:55,340
The second you know I want to remind people of is projects,

16
00:00:56,790 --> 00:00:59,730
if you'd like to do a project instead of lab 4,

17
00:01:00,120 --> 00:01:05,090
then you can do so,

18
00:01:05,090 --> 00:01:07,880
but you should submit a proposal for a project,

19
00:01:07,880 --> 00:01:12,920
and use a couple paragraphs to through the submission website,

20
00:01:12,950 --> 00:01:14,840
so that we can give you feedback,

21
00:01:14,840 --> 00:01:19,790
and to tell you what this project actually appropriate for a final project in 6.824,

22
00:01:20,300 --> 00:01:22,310
if you're just planning to lab 4,

23
00:01:22,340 --> 00:01:23,930
there's absolutely nothing you have to do at all.

24
00:01:25,240 --> 00:01:31,830
Any questions about these two logistical points?

25
00:01:36,270 --> 00:01:41,040
Okay, then, let me move on to one other point,

26
00:01:41,040 --> 00:01:41,910
I wanted to bring up,

27
00:01:41,910 --> 00:01:50,550
which is the sort of correction from a lecture a little while ago,

28
00:01:50,760 --> 00:01:53,670
we, we walked through the Go code

29
00:01:53,670 --> 00:01:57,570
for the raft implementation of 2a 2b that I had,

30
00:01:57,840 --> 00:02:02,010
and we talked a little bit about the go defer statement,

31
00:02:02,400 --> 00:02:04,260
and I mentioned that,

32
00:02:04,260 --> 00:02:07,470
you can actually have the defer statement inside of a base block,

33
00:02:07,530 --> 00:02:09,300
and that is correct,

34
00:02:09,750 --> 00:02:11,970
and I think maybe it was Felipe who asked the question,

35
00:02:11,970 --> 00:02:14,880
what is exactly when is that get executed

36
00:02:14,880 --> 00:02:16,680
and I answered that question incorrectly,

37
00:02:17,040 --> 00:02:19,230
you know the defer statement that gets executed

38
00:02:19,230 --> 00:02:21,150
at the point that gets return out of the function,

39
00:02:21,150 --> 00:02:22,920
not in return out of the base block,

40
00:02:23,350 --> 00:02:26,860
and so that my apologizes that caused any confusion.

41
00:02:29,980 --> 00:02:34,390
Any questions about the that clarification?

42
00:02:37,610 --> 00:02:38,270
Okay?

43
00:02:38,870 --> 00:02:40,130
Good, there's sort of two topics

44
00:02:40,130 --> 00:02:41,900
and really talk to technical talks,

45
00:02:41,900 --> 00:02:44,330
I want to talk about today is the zookeeper locks,

46
00:02:44,450 --> 00:02:47,450
which I didn't get to finish the last time,

47
00:02:48,250 --> 00:02:50,770
and then I'll talk about chain replication.

48
00:02:51,790 --> 00:02:52,390
Okay?

49
00:02:52,900 --> 00:02:56,770
So both for chain replication and zookeeper,

50
00:02:56,770 --> 00:03:01,060
you know we're sort of still in the same context as before,

51
00:03:01,610 --> 00:03:05,660
namely we're doing you know replicated state machine.

52
00:03:07,240 --> 00:03:09,700
And you know just a usual diagram,

53
00:03:10,270 --> 00:03:12,370
you know we have servers,

54
00:03:12,370 --> 00:03:17,950
you know that runs on some replication libraries, like ZAB or Raft,

55
00:03:20,220 --> 00:03:22,950
we have clients talking to the servers,

56
00:03:22,950 --> 00:03:25,680
for example in the case of zookeeper,

57
00:03:25,740 --> 00:03:27,480
might actually send to create call,

58
00:03:28,440 --> 00:03:31,890
you know zookeeper internally how some states, you know some znodes,

59
00:03:31,890 --> 00:03:34,470
you know that are hanging off in a form of tree,

60
00:03:34,860 --> 00:03:36,480
and so when an operation comes in,

61
00:03:36,480 --> 00:03:41,910
you know zookeeper you know forwards that operation basically to the Raft ZAB library,

62
00:03:41,910 --> 00:03:43,830
it does some chatting back and forth,

63
00:03:44,240 --> 00:03:46,280
and to get a majority of the servers

64
00:03:46,280 --> 00:03:48,830
to accept you know that command,

65
00:03:49,070 --> 00:03:50,000
and then at some point,

66
00:03:50,000 --> 00:03:52,430
you know once it's accepted, it comes out,

67
00:03:52,430 --> 00:03:54,320
the servers applies the operation,

68
00:03:54,530 --> 00:03:56,390
and sends a response back to the client,

69
00:03:56,690 --> 00:03:59,450
so the standard story of replicated state machine,

70
00:03:59,450 --> 00:04:00,170
if you start,

71
00:04:00,440 --> 00:04:02,930
all the replicated state machine starting the same state,

72
00:04:02,930 --> 00:04:05,120
you apply the same operation in the same order,

73
00:04:05,180 --> 00:04:06,950
then you will end up in the same state,

74
00:04:06,950 --> 00:04:09,770
and so any of the machines can take over if necessary.

75
00:04:11,430 --> 00:04:15,630
Now, one of the things that was cool, about interesting, about zookeeper is that,

76
00:04:15,630 --> 00:04:20,610
you know read operations can be served for any servers,

77
00:04:20,820 --> 00:04:23,340
for any of the peers or any of the one of the servers,

78
00:04:23,790 --> 00:04:26,280
and this allows zookeeper to extremely high performance,

79
00:04:26,280 --> 00:04:31,650
because you can actually scale the number of read operations with the number of servers,

80
00:04:32,190 --> 00:04:34,320
as a flip side of that,

81
00:04:34,350 --> 00:04:36,870
you know zookeeper actually gave up,

82
00:04:36,870 --> 00:04:39,150
on that particular scenario,

83
00:04:39,150 --> 00:04:40,650
gave up on linearizability.

84
00:04:49,920 --> 00:04:52,530
Because we know from for example in Raft,

85
00:04:52,530 --> 00:04:56,430
we can't actually arbitrary server read from any server,

86
00:04:56,550 --> 00:05:00,900
because I have not seen the latest update yet,

87
00:05:00,900 --> 00:05:02,250
and so in case of zookeeper,

88
00:05:02,250 --> 00:05:04,080
that is a [],

89
00:05:04,260 --> 00:05:08,940
and, and so read operations are not you know,

90
00:05:08,940 --> 00:05:13,200
or the operation zookeeper defines don't provide a linearizable interface.

91
00:05:13,960 --> 00:05:17,050
But nevertheless you know we saw that actually is,

92
00:05:17,080 --> 00:05:20,770
it provides a slightly different sort of correctness guarantee that linearizability,

93
00:05:21,070 --> 00:05:25,390
and that actually correctness guarantee is useful,

94
00:05:25,600 --> 00:05:28,750
and useful enough to be able to write actually programs,

95
00:05:28,750 --> 00:05:34,570
and the particular set of programs that you know zookeeper was you know focusing on is,

96
00:05:34,600 --> 00:05:43,760
these what they call configuration or coordination programs.

97
00:05:52,220 --> 00:05:53,780
And so the thing to think about it,

98
00:05:53,780 --> 00:05:56,630
there's a lot of systems that we looked at in the past,

99
00:05:56,630 --> 00:05:58,850
they typically have some replication story,

100
00:05:58,850 --> 00:06:05,090
and they have coordinator master that sort of coordinates the the group,

101
00:06:05,090 --> 00:06:08,750
and zookeeper really intended you know for as a service,

102
00:06:08,750 --> 00:06:12,560
for that kind of you know master or coordinator role,

103
00:06:12,770 --> 00:06:16,280
and it provides a bunch of primitives you know to make that doable,

104
00:06:16,370 --> 00:06:22,670
and the two the you know we talked a little bit about atomic increment last week,

105
00:06:22,670 --> 00:06:24,860
and with some the other service

106
00:06:24,860 --> 00:06:28,130
and want to finish off you know talking about locks.

107
00:06:28,840 --> 00:06:31,840
One, because there were a lot of questions about it,

108
00:06:31,840 --> 00:06:33,310
and two, actually is quite interesting,

109
00:06:33,760 --> 00:06:36,370
and there's sort of two different lock in implementation.

110
00:06:36,370 --> 00:06:38,050
And first I want to talk about the simple one,

111
00:06:38,290 --> 00:06:42,700
namely where, let me write down the pseudo code,

112
00:06:42,820 --> 00:06:45,460
then we can talk about it again a little bit in detail,

113
00:06:45,670 --> 00:06:51,700
so the pseudo code for the lock was something like this,

114
00:06:51,700 --> 00:06:54,130
you know acquire, in an infinite loop,

115
00:06:54,400 --> 00:06:56,410
you know try to create the lock file,

116
00:07:01,190 --> 00:07:05,310
name lf, and set ephemeral to true,

117
00:07:11,460 --> 00:07:13,110
and we'll talk about that in a second why.

118
00:07:13,170 --> 00:07:15,300
You know if the create succeeds,

119
00:07:16,120 --> 00:07:18,730
then you know the that process,

120
00:07:18,730 --> 00:07:21,160
where the client was the first one to create that file,

121
00:07:21,160 --> 00:07:23,860
and basically successfully gets the lock

122
00:07:23,860 --> 00:07:26,080
and so it breaks out of the for loop and returns.

123
00:07:26,980 --> 00:07:31,160
If the client did not,

124
00:07:31,190 --> 00:07:32,630
you know be able to create a file,

125
00:07:32,630 --> 00:07:34,340
then it calles exists,

126
00:07:34,920 --> 00:07:39,060
and the call exists is not really for you know see if it exists or not,

127
00:07:39,060 --> 00:07:41,010
because you know it doesn't exist,

128
00:07:41,310 --> 00:07:43,020
basically set a watch,

129
00:07:47,420 --> 00:07:51,230
and the idea is that you know the watch will go off,

130
00:07:51,230 --> 00:07:52,940
if actually the file disappears,

131
00:07:53,900 --> 00:07:55,850
and if it disappears,

132
00:07:55,850 --> 00:07:57,860
then you know the client will get a notification,

133
00:07:57,860 --> 00:08:00,380
so basically we're going to be doing here is

134
00:08:00,380 --> 00:08:01,640
just wait for that notification.

135
00:08:09,390 --> 00:08:11,490
So that's sort of the acquire operation,

136
00:08:11,640 --> 00:08:14,790
then the release is very simple.

137
00:08:17,080 --> 00:08:19,180
The release actually is that does nothing else

138
00:08:19,180 --> 00:08:22,600
than sending the delete operation to the zookeeper service,

139
00:08:22,810 --> 00:08:24,640
you know for the for the lock file,

140
00:08:25,440 --> 00:08:26,880
so lf in this case.

141
00:08:27,800 --> 00:08:29,030
And so what does that do,

142
00:08:29,030 --> 00:08:32,540
well if the delete you know sent to the zookeeper service,

143
00:08:32,540 --> 00:08:36,650
you know the zookeeper service perform delete operation,

144
00:08:37,010 --> 00:08:42,020
that will actually, that that make the file would go away,

145
00:08:42,140 --> 00:08:44,000
that will fire to watch,

146
00:08:44,150 --> 00:08:46,490
and so every client that actually is waiting,

147
00:08:46,490 --> 00:08:48,920
you know for the notification,

148
00:08:48,920 --> 00:08:50,060
will get a notification,

149
00:08:50,300 --> 00:08:51,440
and then they go retry,

150
00:08:52,100 --> 00:08:55,190
and you know one of them will be successful in the retry,

151
00:08:55,190 --> 00:08:57,290
will get the lock file or create a lock file,

152
00:08:57,350 --> 00:08:58,160
and then proceed,

153
00:08:58,340 --> 00:09:01,850
and then the others one go back into there,

154
00:09:02,060 --> 00:09:06,080
call exists and going to wait for notification.

155
00:09:07,280 --> 00:09:10,460
And the zookeeper semantics you know good enough,

156
00:09:10,490 --> 00:09:15,290
you know the strong the linearizability for write operations,

157
00:09:15,350 --> 00:09:18,590
plus you know the rules for when notifications go off

158
00:09:18,650 --> 00:09:21,770
are strong enough, that basically this actually implements a [] lock,

159
00:09:21,950 --> 00:09:23,630
where only one client,

160
00:09:23,630 --> 00:09:25,820
if there are many clients at the same time trying to get the lock,

161
00:09:25,820 --> 00:09:26,840
only one will get it.

162
00:09:27,260 --> 00:09:29,870
And when the release is done

163
00:09:29,870 --> 00:09:31,670
or when the file has been deleted,

164
00:09:31,730 --> 00:09:33,860
only one in the next round will get it.

165
00:09:34,620 --> 00:09:36,510
So that's sort of cool,

166
00:09:36,900 --> 00:09:38,220
and it's interesting,

167
00:09:38,220 --> 00:09:42,480
that you could build you know sort of sort of the foundational primitive

168
00:09:42,570 --> 00:09:45,600
on using the primitives that the zookeeper offers.

169
00:09:46,280 --> 00:09:47,930
And you see here, both the role,

170
00:09:47,960 --> 00:09:52,910
of the you know the the watch and then there's the second role for the ephemeral,

171
00:09:52,910 --> 00:09:54,770
you know the ephemeral is there,

172
00:09:54,770 --> 00:09:59,090
because, what happens if a client fails or crash,

173
00:09:59,090 --> 00:10:00,440
before it calls release,

174
00:10:00,680 --> 00:10:03,740
and the semantics of the ephemeral files,

175
00:10:03,740 --> 00:10:05,630
that zookeeper service will,

176
00:10:05,840 --> 00:10:07,370
if it decides that the client has crashed,

177
00:10:07,370 --> 00:10:09,740
it will do the operation,

178
00:10:09,740 --> 00:10:13,250
it will remove the file on behalf of the client,

179
00:10:13,340 --> 00:10:16,460
so even if the client fails or crashes,

180
00:10:16,760 --> 00:10:18,230
zookeeper service the [site],

181
00:10:18,230 --> 00:10:19,910
at some point the client is down,

182
00:10:20,060 --> 00:10:22,520
and that will remove the file lock f,

183
00:10:22,580 --> 00:10:24,710
which will cause notifications to be sent

184
00:10:24,710 --> 00:10:26,570
to other clients actually are waiting for it.

185
00:10:27,450 --> 00:10:30,960
So, it's a cool set of primitives

186
00:10:30,960 --> 00:10:34,680
to build powerful abstraction that can be useful in applications.

187
00:10:35,870 --> 00:10:40,830
One downside of this particular implementation is that,

188
00:10:41,100 --> 00:10:43,110
it has what's called a herding effect,

189
00:10:43,470 --> 00:10:46,860
namely you know let's say you have a thousand clients,

190
00:10:46,860 --> 00:10:50,670
you know want to go grab the lock file or make the lock file,

191
00:10:50,670 --> 00:10:51,750
acquire the lock,

192
00:10:51,960 --> 00:10:54,210
you know one is going to succeed,

193
00:10:54,360 --> 00:10:59,190
and 999 are going to call exists and wait for notification,

194
00:10:59,700 --> 00:11:04,860
then when the first client deletes the file or releases the file lock,

195
00:11:05,940 --> 00:11:10,110
999 are going to try to actually acquire the lock,

196
00:11:10,750 --> 00:11:12,460
and of course only one is going to succeed,

197
00:11:12,460 --> 00:11:15,010
and 998 are going to be sitting for a notification,

198
00:11:15,790 --> 00:11:18,400
but you know the this,

199
00:11:18,400 --> 00:11:20,500
you know every sort of random disappearance,

200
00:11:20,500 --> 00:11:21,760
a huge amount of traffic,

201
00:11:21,910 --> 00:11:26,290
and you know basically bombarding you know the zookeeper server,

202
00:11:27,220 --> 00:11:30,250
999 to try to do it again,

203
00:11:30,340 --> 00:11:33,880
you know all but one are are gonna fail.

204
00:11:34,610 --> 00:11:40,490
And so that's a little bit of undesirable property, this herding effect,

205
00:11:40,490 --> 00:11:42,260
and it's a real problem in practice,

206
00:11:42,260 --> 00:11:45,950
you know move on a small scale multi-core machines

207
00:11:45,950 --> 00:11:47,810
as well as of course setting like this,

208
00:11:47,810 --> 00:11:50,090
where network messages are not free.

209
00:11:51,390 --> 00:11:54,540
So it's interesting that, actually zookeeper provides enough primitives,

210
00:11:54,540 --> 00:11:56,070
that you could actually do quite a bit better,

211
00:11:56,070 --> 00:11:57,390
and you can actually build a lock,

212
00:11:57,480 --> 00:12:00,420
that doesn't have suffered from the herding effect.

213
00:12:01,310 --> 00:12:02,660
So a better lock,

214
00:12:08,950 --> 00:12:10,180
and it's very interesting,

215
00:12:10,180 --> 00:12:14,560
let me a pull out the pseudo code for this,

216
00:12:15,180 --> 00:12:16,260
which is in the paper,

217
00:12:16,290 --> 00:12:17,790
so we can look at it,

218
00:12:18,730 --> 00:12:21,250
and discuss you know why you know this lock is better,

219
00:12:21,940 --> 00:12:24,550
and particularly what we'll see is that this lock is better,

220
00:12:24,550 --> 00:12:28,130
because basically there's no, there's no retry,

221
00:12:28,130 --> 00:12:33,740
where all clients that didn't succeed getting the lock will retry to try to get,

222
00:12:33,770 --> 00:12:37,700
instead you know basically the all the clients are sort of for a line,

223
00:12:37,850 --> 00:12:40,280
and they get the lock one by one.

224
00:12:40,900 --> 00:12:44,740
And the way you know that you can program that using zookeeper's primitives

225
00:12:44,950 --> 00:12:46,990
as in this particular pseudo code.

226
00:12:47,740 --> 00:12:51,310
And there are a couple differences that compared to the previous one,

227
00:12:51,730 --> 00:12:53,680
first of all, the,

228
00:12:56,180 --> 00:13:00,200
there's an additional flag you know pass to create, namely SEQUENTIAL,

229
00:13:00,560 --> 00:13:02,030
which basically means that,

230
00:13:02,030 --> 00:13:04,490
as these files are created,

231
00:13:04,520 --> 00:13:06,320
the lock file is created,

232
00:13:06,320 --> 00:13:10,160
but it will be created as, the first one, it will be lock-0,

233
00:13:10,190 --> 00:13:12,980
then the next one will be lock-1, etc.

234
00:13:16,920 --> 00:13:18,780
So we have like a thousand clients

235
00:13:18,780 --> 00:13:22,170
rushing you know to the service to actually try to acquire to lock,

236
00:13:22,260 --> 00:13:24,540
basically a thousand files will be created,

237
00:13:24,570 --> 00:13:27,420
all numbered from 0 to 999.

238
00:13:28,750 --> 00:13:31,030
Then, so.

239
00:13:31,600 --> 00:13:33,370
So, I'll succeed creating a file,

240
00:13:33,400 --> 00:13:39,940
the creator returns actually the number that that you got,

241
00:13:39,940 --> 00:13:41,140
so if the client 0,

242
00:13:41,140 --> 00:13:44,680
if the first client gets you know lock, creates lock-0,

243
00:13:44,770 --> 00:13:46,480
then it will get 0 back,

244
00:13:46,510 --> 00:13:48,760
and the second will get 1 back, etc, etc.

245
00:13:49,780 --> 00:13:51,910
Then you know the pseudo code basically ask

246
00:13:51,910 --> 00:13:55,240
you know to get all the children in that directory

247
00:13:55,270 --> 00:13:57,100
you know which you know these files are created,

248
00:13:57,130 --> 00:13:57,970
and so in this case,

249
00:13:57,970 --> 00:14:01,840
maybe that would be a thousand children and thousand znodes,

250
00:14:02,200 --> 00:14:04,990
and then you can just look at the n,

251
00:14:05,480 --> 00:14:08,210
and see if your n,

252
00:14:08,270 --> 00:14:11,240
in this case, 0 is the lowest znode to see,

253
00:14:11,240 --> 00:14:13,370
and if that's the case, that means you got the lock.

254
00:14:13,880 --> 00:14:15,020
And so that makes total sense,

255
00:14:15,020 --> 00:14:17,780
but the first line gets actually 0 back,

256
00:14:17,780 --> 00:14:19,280
all the other clients have a higher number,

257
00:14:19,280 --> 00:14:20,540
because they're sequentially numbered,

258
00:14:20,840 --> 00:14:23,120
and so the first client will succeed in getting it,

259
00:14:23,120 --> 00:14:26,240
and all the other ones, what they're gonna do is,

260
00:14:26,420 --> 00:14:27,860
they're going to look at,

261
00:14:27,860 --> 00:14:29,420
they're going to find the p,

262
00:14:29,810 --> 00:14:31,760
you know the number that is right in front of there,

263
00:14:31,790 --> 00:14:33,530
so for example if this is client,

264
00:14:33,950 --> 00:14:36,320
that got back you know lock-10,

265
00:14:36,410 --> 00:14:40,340
it's going to look you know for znode 9 you know lock-9,

266
00:14:40,400 --> 00:14:42,260
and basically put a watch on that file,

267
00:14:45,760 --> 00:14:50,680
so this means that every client will have a watch basically on its predecessor,

268
00:14:50,770 --> 00:14:53,950
so it goes to see that's all the clients form a line,

269
00:14:54,250 --> 00:15:00,260
and and then you know the client just gonna wait for that notification to go off.

270
00:15:00,850 --> 00:15:05,110
And so that means for example when client 0 you know we got 0 back,

271
00:15:05,110 --> 00:15:06,790
you know releases the lock,

272
00:15:06,820 --> 00:15:07,960
it will delete n,

273
00:15:08,470 --> 00:15:12,220
this will get a notification to go off for the file one,

274
00:15:13,010 --> 00:15:15,860
and so the client is actually waiting for that particular notification,

275
00:15:15,860 --> 00:15:18,260
then will run,

276
00:15:18,500 --> 00:15:20,540
but it's the only one that runs,

277
00:15:20,840 --> 00:15:24,050
and a it will succeed.

278
00:15:25,330 --> 00:15:26,440
And so here we see,

279
00:15:26,440 --> 00:15:29,500
you know this is sometimes easier type of locks, called ticket locks,

280
00:15:30,640 --> 00:15:32,500
in multi-core programming,

281
00:15:32,500 --> 00:15:33,520
if you're familiar with them,

282
00:15:33,670 --> 00:15:37,600
and they are sort of the same same idea of ticket locks,

283
00:15:37,600 --> 00:15:41,890
actually you're building into this, using zookeeper primitives.

284
00:15:42,580 --> 00:15:44,830
Again, what is interesting about it is that,

285
00:15:45,190 --> 00:15:47,170
you know these primitives are powerful enough,

286
00:15:47,170 --> 00:15:48,850
that you can actually build these kind of locks.

287
00:15:51,260 --> 00:15:52,370
Any questions about this?

288
00:15:57,840 --> 00:16:01,410
Okay, I want to make one more comment you know about the these locks,

289
00:16:01,620 --> 00:16:05,070
before moving onto chain replication.

290
00:16:05,340 --> 00:16:06,540
We have a question in the chat.

291
00:16:06,690 --> 00:16:08,430
Yeah, okay, what's the question in chat?

292
00:16:08,430 --> 00:16:11,550
What is the watch for on line 4?

293
00:16:12,140 --> 00:16:15,230
Good, go back, on this one line 4?

294
00:16:17,480 --> 00:16:18,560
Yeah, I think that's the question.

295
00:16:19,580 --> 00:16:23,060
Yeah, well, that watch my comment,

296
00:16:23,060 --> 00:16:25,940
the watch actually should go with you know line 5,

297
00:16:26,500 --> 00:16:28,540
so there's no watch on line 4, right,

298
00:16:29,590 --> 00:16:34,090
line 4 just finds p, you know the numbers right before your n,

299
00:16:39,850 --> 00:16:41,050
if that doesn't answer the question,

300
00:16:41,050 --> 00:16:42,880
please, if you come back later and that's fine.

301
00:16:43,570 --> 00:16:45,220
Actually, I have another question.

302
00:16:45,370 --> 00:16:45,910
Yeah.

303
00:16:45,910 --> 00:16:48,040
This is going actually I think back a few slides,

304
00:16:48,040 --> 00:16:51,430
but how does zookeeper determine that a client has failed,

305
00:16:51,430 --> 00:16:53,440
and thus release the ephemeral lock,

306
00:16:53,740 --> 00:16:56,980
like often, it's just like partitions for a moment.

307
00:16:57,440 --> 00:17:00,650
Yeah, so, well, yeah so that could happen,

308
00:17:00,650 --> 00:17:01,820
so the client might actually,

309
00:17:01,820 --> 00:17:05,600
so the client has a session right with the zookeeper service,

310
00:17:06,020 --> 00:17:08,480
and the client needs to,

311
00:17:08,480 --> 00:17:12,890
actually the zookeeper and client basically sends heartbeats to each other,

312
00:17:12,890 --> 00:17:17,450
if zookeeper service doesn't hear from a client for a little while,

313
00:17:17,540 --> 00:17:20,510
then it's just desides that client is down and close the session.

314
00:17:21,600 --> 00:17:24,450
And so the client is trying to send messages on the session,

315
00:17:24,450 --> 00:17:26,010
but the session is just closed, is gone,

316
00:17:26,550 --> 00:17:28,470
and any files that were created in the,

317
00:17:28,470 --> 00:17:32,700
ephemeral files that were created during that session are basically deleted,

318
00:17:34,860 --> 00:17:39,780
and so if the network reconvenes or [],

319
00:17:39,870 --> 00:17:42,780
then the client will try to send messages over that session,

320
00:17:42,780 --> 00:17:46,590
and basically zookeeper service say like that session doesn't exist anymore,

321
00:17:47,370 --> 00:17:49,470
you gotta retry or restart a new session.

322
00:17:50,830 --> 00:17:51,700
Got it, thank you.

323
00:17:53,470 --> 00:17:56,500
Okay good, so there's one important point about this,

324
00:17:56,500 --> 00:17:59,860
I'll call zlocks, where zookeeper locks,

325
00:18:00,850 --> 00:18:05,110
and that is they're not the same or have similar semantics,

326
00:18:05,110 --> 00:18:08,080
like the locks that you were using or Go locks or mutex.

327
00:18:09,360 --> 00:18:11,400
And it's sort of an important point to realize,

328
00:18:11,400 --> 00:18:12,960
you know even though they're different,

329
00:18:12,960 --> 00:18:14,490
we'll see in a second, they're still useful,

330
00:18:14,490 --> 00:18:17,610
but they're not as strong as sort of the Go locks,

331
00:18:18,090 --> 00:18:20,490
in particular the case is that is interesting is,

332
00:18:20,490 --> 00:18:22,020
like when the lock holder fails,

333
00:18:23,360 --> 00:18:25,070
so if lock holder fails,

334
00:18:27,930 --> 00:18:31,200
basically zookeeper decides that lock holder has failed, correct,

335
00:18:31,200 --> 00:18:32,400
as we just discussed,

336
00:18:32,520 --> 00:18:34,560
then it is possible,

337
00:18:34,650 --> 00:18:37,050
that we're going to see some intermediate state.

338
00:18:42,820 --> 00:18:45,100
And remember like the whole rule that locks is,

339
00:18:45,100 --> 00:18:46,600
like it's critical section,

340
00:18:46,600 --> 00:18:48,580
you know you're some invariant is true,

341
00:18:48,610 --> 00:18:51,160
while you're going through the critical section,

342
00:18:51,160 --> 00:18:52,600
so that it might not be true,

343
00:18:52,600 --> 00:18:54,820
but then at the end, you reestablish [invariant].

344
00:18:56,320 --> 00:18:58,210
In here, it's the case,

345
00:18:58,210 --> 00:18:59,350
like it required lock,

346
00:18:59,350 --> 00:19:01,210
client requires lock, does some steps,

347
00:19:01,240 --> 00:19:02,890
and then you know maybe zookeeper decides

348
00:19:02,890 --> 00:19:05,200
if the client decides the client crash

349
00:19:05,260 --> 00:19:07,600
and basically revokes lock,

350
00:19:07,750 --> 00:19:09,010
but you know the state,

351
00:19:09,010 --> 00:19:11,440
you know the system might actually be some intermediate state,

352
00:19:11,440 --> 00:19:14,080
return invariant was not true, right,

353
00:19:14,080 --> 00:19:15,280
so it's not the case,

354
00:19:15,280 --> 00:19:19,990
that basically these logs guarantee adamicity of the critical section.

355
00:19:21,180 --> 00:19:26,490
So what, so what they do, what they useful for,

356
00:19:29,510 --> 00:19:31,010
is for some other purposes,

357
00:19:33,640 --> 00:19:35,860
in fact sort of two primary use cases,

358
00:19:35,860 --> 00:19:37,810
one, I think is leader election,

359
00:19:43,380 --> 00:19:46,560
so basically if we need a set of clients,

360
00:19:46,560 --> 00:19:48,090
that need to select the leader among them,

361
00:19:48,090 --> 00:19:52,140
you know they can all try to basically create the lock file,

362
00:19:52,170 --> 00:19:53,490
one of them succeed,

363
00:19:53,520 --> 00:19:55,170
that's basically then becomes a leader,

364
00:19:55,860 --> 00:20:00,660
and that leader could clean up any intermediate states if possible if necessary,

365
00:20:02,070 --> 00:20:04,800
or you know do these atomic updates,

366
00:20:04,800 --> 00:20:05,790
using the ready trick,

367
00:20:05,820 --> 00:20:08,370
where basically you do a bunch of writes to some file,

368
00:20:08,370 --> 00:20:10,500
but then you expose the file only at the very end,

369
00:20:10,500 --> 00:20:13,560
and that way make a set of writes

370
00:20:13,560 --> 00:20:15,810
actually are more transactional work.

371
00:20:16,390 --> 00:20:19,090
So that's one use case for these kind of locks,

372
00:20:19,240 --> 00:20:22,630
the second use case is what I call soft locks,

373
00:20:27,260 --> 00:20:30,380
the soft locks you know the way to think about is that,

374
00:20:30,560 --> 00:20:34,250
let's say we have a worker in the mapreduce style,

375
00:20:34,340 --> 00:20:35,150
and the map,

376
00:20:35,150 --> 00:20:38,750
I want to basically arrange that you know every worker

377
00:20:38,750 --> 00:20:43,310
executes a particular map task only once,

378
00:20:43,460 --> 00:20:45,200
and so the one way to do that,

379
00:20:45,200 --> 00:20:46,760
we basically take a lock out,

380
00:20:46,760 --> 00:20:49,640
you know for that particular input file,

381
00:20:49,880 --> 00:20:52,010
run you know the computation,

382
00:20:52,160 --> 00:20:55,070
and then you know once the map is done,

383
00:20:55,070 --> 00:20:56,450
then you release the lock file,

384
00:20:56,600 --> 00:21:03,650
so this will cost only one mapper to the common case to execute a particular task,

385
00:21:04,070 --> 00:21:06,800
and and that's exactly what we want,

386
00:21:06,800 --> 00:21:09,440
but of course you know if the mapper would fail,

387
00:21:09,440 --> 00:21:10,910
then the lock will be release,

388
00:21:11,060 --> 00:21:13,490
and then we might execute it a second time,

389
00:21:13,490 --> 00:21:15,740
because somebody else will try to acquire a lock,

390
00:21:16,040 --> 00:21:17,000
and so in that case,

391
00:21:17,000 --> 00:21:19,430
you know for the case of mapreduce, that's perfectly fine, right,

392
00:21:19,640 --> 00:21:22,700
the, it's okay if the task is executed twice,

393
00:21:24,870 --> 00:21:26,280
if happens twice.

394
00:21:29,680 --> 00:21:31,240
And in some ways what it really is,

395
00:21:31,240 --> 00:21:32,590
it's more performance optimization,

396
00:21:32,590 --> 00:21:34,300
in the usual case, you wanted to,

397
00:21:34,510 --> 00:21:36,970
you wanted that actually is execute the only once,

398
00:21:37,120 --> 00:21:38,920
but you know if there's a failure,

399
00:21:38,920 --> 00:21:39,670
it might be the case,

400
00:21:39,670 --> 00:21:41,440
that you're executing a map job twice,

401
00:21:41,740 --> 00:21:43,660
then that thing, you know the mapreduce means

402
00:21:43,660 --> 00:21:46,660
you set up in such a way, that actually that's okay.

403
00:21:47,870 --> 00:21:48,890
And so in those cases,

404
00:21:48,890 --> 00:21:51,170
these sort of locks are really useful, too.

405
00:21:52,780 --> 00:21:57,240
Any questions about this, about this perspective for locks,

406
00:21:57,240 --> 00:21:59,970
you know the zookeeper locks are not exactly like the Go locks,

407
00:21:59,970 --> 00:22:02,340
and it's just an important thing to keep in mind.

408
00:22:03,760 --> 00:22:03,970
Oh.

409
00:22:03,970 --> 00:22:06,820
Yeah, go ahead, Alexander.

410
00:22:06,850 --> 00:22:08,830
Yeah, I had a question,

411
00:22:08,830 --> 00:22:12,100
you said that, one of the differences is that,

412
00:22:12,850 --> 00:22:20,730
in zlocks, the, if, if the, if the server holding the lock dies,

413
00:22:20,730 --> 00:22:22,770
then the lock can be revoked,

414
00:22:22,800 --> 00:22:27,300
but, does that still happen if you don't pass the,

415
00:22:27,540 --> 00:22:32,140
because there's that flag called EPHEMERAL.

416
00:22:32,140 --> 00:22:35,800
EPHEMERAL, yeah, it only happens with the ephemeral file.

417
00:22:36,350 --> 00:22:42,080
Right, so can we just like emulate the Go locks by not passing EPHEMERAL.

418
00:22:46,570 --> 00:22:47,470
Okay, good, what would happen then,

419
00:22:47,470 --> 00:22:48,490
you create basically a persistent file,

420
00:22:49,040 --> 00:22:50,240
the client dies.

421
00:22:51,400 --> 00:22:52,510
You said the lock?

422
00:22:53,640 --> 00:22:57,570
And so the lock will keep on existing and nobody will release it,

423
00:22:58,450 --> 00:22:59,950
and we have a deadlock,

424
00:23:02,050 --> 00:23:07,350
because the one person that could release it is dead or crashed,

425
00:23:09,000 --> 00:23:11,340
and in fact, this is why EPHEMERAL [] there.

426
00:23:13,350 --> 00:23:18,450
Is, is it actually the only, the only person who could release it,

427
00:23:18,450 --> 00:23:20,430
because anyone can delete that file, right,

428
00:23:20,850 --> 00:23:22,890
you have a background, like.

429
00:23:23,220 --> 00:23:25,080
That will break,

430
00:23:25,080 --> 00:23:26,730
you know maybe the other client is still running,

431
00:23:26,730 --> 00:23:28,650
and also still thinks it holds a lock.

432
00:23:32,370 --> 00:23:33,000
Sure.

433
00:23:33,750 --> 00:23:36,390
You get are getting sort of, basically you're,

434
00:23:36,390 --> 00:23:38,400
this is consensus problem all over again, right.

435
00:23:39,350 --> 00:23:41,480
And you know we,

436
00:23:44,820 --> 00:23:47,460
so this is sort of a clean way to get most of it,

437
00:23:47,760 --> 00:23:49,110
but not all of it,

438
00:23:49,530 --> 00:23:50,250
if you will,

439
00:23:50,490 --> 00:23:52,380
and I think if you want to make things atomic,

440
00:23:52,380 --> 00:23:55,350
across a number of a set of writes atomic,

441
00:23:55,530 --> 00:23:58,740
so you basically use this trick of,

442
00:24:01,540 --> 00:24:03,610
use this trick, basically the ready trick,

443
00:24:03,610 --> 00:24:06,070
where you do a bunch of writes and expose them at the same time.

444
00:24:10,640 --> 00:24:13,100
Could you explain those soft locks again?

445
00:24:13,640 --> 00:24:17,510
Okay, soft locks means that basically an operation can happen twice.

446
00:24:18,200 --> 00:24:20,120
And so in the common case,

447
00:24:20,120 --> 00:24:21,110
if there's no crashes,

448
00:24:21,110 --> 00:24:22,220
you know it will happen once,

449
00:24:22,220 --> 00:24:24,710
you know because you know the client will take a lock out,

450
00:24:24,710 --> 00:24:26,180
will do the operation release,

451
00:24:26,720 --> 00:24:31,280
and, but if there client failed, halfway through,

452
00:24:31,280 --> 00:24:34,280
for example, then the lock would be automatically released by zookeeper,

453
00:24:34,280 --> 00:24:37,640
and then maybe a second client will execute the same map task.

454
00:24:41,710 --> 00:24:43,720
So in the case of leader election,

455
00:24:43,720 --> 00:24:46,660
what's the intermediate state could get exposed here,

456
00:24:47,080 --> 00:24:48,430
it seems that first.

457
00:24:49,090 --> 00:24:52,090
Okay, pure leader election there would be no intermediate state,

458
00:24:52,090 --> 00:24:54,940
but typically the leader will create a configuration file, right,

459
00:24:55,090 --> 00:24:56,440
as we saw in zookeeper,

460
00:24:56,440 --> 00:24:58,720
where you know using the ready trick.

461
00:25:00,060 --> 00:25:02,040
I see, and so you just write the whole file,

462
00:25:02,040 --> 00:25:03,960
and then convert it atomic, use rename.

463
00:25:03,960 --> 00:25:04,710
Yep.

464
00:25:06,870 --> 00:25:12,240
Sorry, could you explain what the ready trick is, exactly?

465
00:25:13,830 --> 00:25:15,300
I was hoping not to, I think we talked about last time.

466
00:25:15,660 --> 00:25:17,010
Sorry.

467
00:25:17,010 --> 00:25:20,310
So so maybe we, you can hold that question,

468
00:25:20,310 --> 00:25:22,230
well I'm happy to do it at the end of the lecture again,

469
00:25:25,980 --> 00:25:29,640
because otherwise I have little time to actually talk about chain replication.

470
00:25:35,560 --> 00:25:37,870
Any other [] questions?

471
00:25:40,290 --> 00:25:44,550
Okay, let me set the states where chain replication a little bit,

472
00:25:44,550 --> 00:25:47,910
and then we'll also come back to zookeeper in some sense,

473
00:25:47,910 --> 00:25:50,070
and basically turns out,

474
00:25:50,100 --> 00:25:54,030
there's sort of two common approaches to build replicated state machines,

475
00:25:54,330 --> 00:25:56,730
and we really haven't called out these two approaches,

476
00:25:56,850 --> 00:25:58,020
and we've seen them,

477
00:25:58,020 --> 00:25:59,700
but I really talked explicitly about them,

478
00:25:59,700 --> 00:26:01,470
I want to do this, this time explicitly.

479
00:26:01,960 --> 00:26:02,530
So.

480
00:26:05,790 --> 00:26:07,860
Because there's some interesting observations to be made

481
00:26:08,640 --> 00:26:11,280
approaches to building replicated state machines.

482
00:26:14,550 --> 00:26:20,040
And the first one is the one we've basically seen the labs,

483
00:26:20,100 --> 00:26:26,610
which is you run all operations you know through raft,

484
00:26:30,330 --> 00:26:32,970
Raft, zookeeper Raft or you know Paxos,

485
00:26:32,970 --> 00:26:37,840
whatever you know consensus you know the consensus algorithm you're using,

486
00:26:38,350 --> 00:26:41,470
and so this is sort of like the key value store, right,

487
00:26:41,500 --> 00:26:44,590
in lab 3, where you do put and get operation,

488
00:26:44,590 --> 00:26:47,020
you run all the put and get operation through Raft,

489
00:26:47,170 --> 00:26:51,900
and you know the service basically update you know the key value store state

490
00:26:51,900 --> 00:26:55,410
as the operations are coming in on the apply channel,

491
00:26:56,060 --> 00:27:00,140
and you know and basically we have our replicated states,

492
00:27:00,710 --> 00:27:02,990
so this is how lab 3 works.

493
00:27:05,960 --> 00:27:10,100
It turns out that style where basically Raft is used,

494
00:27:10,100 --> 00:27:13,550
the also run all the operations is actually not that common,

495
00:27:14,030 --> 00:27:16,730
we'll see some other designs later in the semester to do that too,

496
00:27:16,730 --> 00:27:17,930
like Spanner does it,

497
00:27:18,200 --> 00:27:21,380
but it's not actually completely the standard approach

498
00:27:21,380 --> 00:27:25,790
or more common approach actually is to have a configuration server,

499
00:27:25,820 --> 00:27:34,470
like zookeeper service,

500
00:27:34,860 --> 00:27:42,930
and the configuration service itself internally might use Paxos Raft or or ZAB or whatever,

501
00:27:43,230 --> 00:27:50,010
and really the configuration service really plays the role of the coordinator or the master,

502
00:27:50,010 --> 00:27:51,570
like the GFS master,

503
00:27:52,140 --> 00:27:55,920
and in addition to basically having configuration service

504
00:27:55,920 --> 00:28:01,050
actually implemented using one of these Raft Paxos algorithms,

505
00:28:01,230 --> 00:28:04,680
you actually run primary backup replication.

506
00:28:12,680 --> 00:28:15,200
And so we think about GFS,

507
00:28:15,230 --> 00:28:17,240
you know we saw early in the semester,

508
00:28:17,300 --> 00:28:18,650
has that sort of structure,

509
00:28:18,650 --> 00:28:20,270
like in the GFS was a master,

510
00:28:20,480 --> 00:28:24,770
and that basically determines which set of servers hold particular chunk,

511
00:28:25,070 --> 00:28:27,860
so basically determined the replica group for a chunk,

512
00:28:28,250 --> 00:28:33,020
and then the replica chunk group basically executed the primary backup replication,

513
00:28:33,170 --> 00:28:35,210
one of the chunks was the primary

514
00:28:35,330 --> 00:28:36,740
and the other ones were the backups,

515
00:28:36,740 --> 00:28:40,100
and they basically had a protocol that they use for primary backup replication.

516
00:28:41,140 --> 00:28:43,900
You can think about VM-FT in a similar style,

517
00:28:43,900 --> 00:28:46,510
where configuration server is basically test-and-set server,

518
00:28:46,600 --> 00:28:49,000
which basically recorded who was actually the primary,

519
00:28:49,270 --> 00:28:51,250
and then the primary backup have a protocol,

520
00:28:51,250 --> 00:28:54,370
to basically send you know channel operation down to channel,

521
00:28:54,550 --> 00:28:58,180
and so the primary backup is roughly in sync

522
00:28:58,210 --> 00:29:01,360
and implement replicated state machine.

523
00:29:02,540 --> 00:29:05,930
And this approach tends to be serve a more common approach,

524
00:29:10,230 --> 00:29:13,680
although the approach number one also happens.

525
00:29:14,250 --> 00:29:16,950
One one way to think about this,

526
00:29:16,950 --> 00:29:21,250
is that you know if the Raft states,

527
00:29:21,250 --> 00:29:24,100
like for example our key value server in lab 3 would be gigantic,

528
00:29:24,100 --> 00:29:26,260
you know have a huge amount of this state,

529
00:29:26,290 --> 00:29:28,510
you know terabytes of key value server,

530
00:29:28,810 --> 00:29:32,110
would Raft be very good match for that kind of application,

531
00:29:34,740 --> 00:29:35,940
or what is the risk,

532
00:29:38,610 --> 00:29:39,900
or the potential problem?

533
00:29:47,380 --> 00:29:50,470
We flush the log very often,

534
00:29:50,470 --> 00:29:53,360
so maybe that could be problematic.

535
00:29:53,750 --> 00:29:54,890
Could be problematic,

536
00:29:54,890 --> 00:29:57,920
what how what's the size of the checkpoint,

537
00:29:59,740 --> 00:30:02,080
if our key value server is really big.

538
00:30:04,930 --> 00:30:07,450
It's linear in the size of the key value server.

539
00:30:07,450 --> 00:30:09,550
Yeah, so that could also be gigantic,

540
00:30:09,640 --> 00:30:12,790
so at any you know any time the checkpoint has to be sent,

541
00:30:12,820 --> 00:30:14,320
you know it's going to be a big checkpoint.

542
00:30:14,900 --> 00:30:17,150
And so the Raft it's not really sort of set up,

543
00:30:17,150 --> 00:30:20,780
you know so the primary is going to communicate,

544
00:30:20,780 --> 00:30:23,270
you know the new primary is going to communicate [] snapshots,

545
00:30:23,270 --> 00:30:24,530
you did in lab 2d,

546
00:30:24,530 --> 00:30:25,910
you know to the the backups,

547
00:30:25,910 --> 00:30:27,020
they're gonna be big.

548
00:30:27,760 --> 00:30:31,210
And so you often want to be a little bit more clever plan

549
00:30:31,390 --> 00:30:34,840
to synchronize and re-synchronize new servers,

550
00:30:35,020 --> 00:30:37,930
and so and one reason that,

551
00:30:37,930 --> 00:30:40,840
basically often these things are split into two different pieces,

552
00:30:40,840 --> 00:30:44,290
where the configuration service that basically small in terms of state,

553
00:30:44,590 --> 00:30:49,450
and then you know primary backup plan actually may replicate huge amount of data.

554
00:30:50,390 --> 00:30:53,510
And so this is why, one reason you see sort of both approaches.

555
00:30:54,920 --> 00:30:55,640
Does that make sense?

556
00:30:57,620 --> 00:30:59,630
I'll come back to that at the end of the lecture again,

557
00:30:59,690 --> 00:31:01,820
but it's important to keep this in mind.

558
00:31:02,470 --> 00:31:06,130
So what approach or what benefits does 1 give over 2?

559
00:31:07,360 --> 00:31:10,150
You don't have to have two of them, right,

560
00:31:10,150 --> 00:31:12,160
in one, you basically have Raft,

561
00:31:12,160 --> 00:31:15,520
you run the operations for [] and then does the configuration for you too,

562
00:31:15,880 --> 00:31:19,450
so everything is in a single, single component,

563
00:31:20,320 --> 00:31:22,690
and here in number two, we have two components,

564
00:31:22,690 --> 00:31:25,600
you know we have a configuration service, that includes Raft,

565
00:31:25,690 --> 00:31:27,820
and we have a primary backup scheme.

566
00:31:30,400 --> 00:31:32,290
So maybe this will become more clear,

567
00:31:32,290 --> 00:31:33,820
as we talk about chain replication.

568
00:31:36,480 --> 00:31:37,470
Yeah.

569
00:31:37,470 --> 00:31:39,150
I had a really quick question,

570
00:31:39,180 --> 00:31:41,070
so I [] for two,

571
00:31:41,400 --> 00:31:45,270
I guess would like what the advantage being that you have like,

572
00:31:45,270 --> 00:31:47,250
if consensus reached through the leader

573
00:31:47,370 --> 00:31:49,320
and the leader never fails, right, like.

574
00:31:50,220 --> 00:31:52,110
Yeah, so the advantage of two is that,

575
00:31:52,110 --> 00:31:54,720
as we see in second in chain replication is,

576
00:31:54,720 --> 00:31:57,840
there's a separate process that takes care of the configuration part,

577
00:31:57,870 --> 00:32:01,710
and you don't have to worry about in terms of your primary backup replication scheme.

578
00:32:02,600 --> 00:32:05,270
And that just decides like GFS,

579
00:32:05,270 --> 00:32:06,290
that's sort of like the master,

580
00:32:06,290 --> 00:32:07,760
it just decides for a couple of here,

581
00:32:07,760 --> 00:32:10,100
set up have the service to form this particular replica group,

582
00:32:10,620 --> 00:32:14,610
and backup primary backup protocol doesn't have to think about this.

583
00:32:16,240 --> 00:32:16,690
Thanks.

584
00:32:17,370 --> 00:32:20,790
And so this is a good introduction to chain replication,

585
00:32:20,790 --> 00:32:22,770
because the chain replication is exactly

586
00:32:22,950 --> 00:32:30,030
that sort of a primary backup replication scheme for approach 2.

587
00:32:35,650 --> 00:32:38,980
And that is to say that you know chain replication assumes,

588
00:32:39,010 --> 00:32:41,980
there is a configuration service,

589
00:32:42,430 --> 00:32:45,010
and I think they called the master process in paper.

590
00:32:45,880 --> 00:32:47,950
Then chain replication themselves,

591
00:32:47,950 --> 00:32:50,050
there's a couple of cool properties.

592
00:32:50,580 --> 00:32:58,670
One, read operations or as they call them query operations involve only one server,

593
00:33:01,430 --> 00:33:04,490
namely the tail as we've seen in a second.

594
00:33:07,120 --> 00:33:11,620
Another nice property about chain replication that has a very simple recovery plan.

595
00:33:13,510 --> 00:33:15,940
I'm going to talk about all of these in more detail in the second.

596
00:33:18,910 --> 00:33:21,040
And presumably something that you started,

597
00:33:21,220 --> 00:33:23,890
have you you appreciate given the fact

598
00:33:23,890 --> 00:33:25,780
how complicated can be in Raft.

599
00:33:26,230 --> 00:33:33,610
And it provides actually strong strong properties, namely linearizability,

600
00:33:34,550 --> 00:33:36,140
if we put and get operations.

601
00:33:36,650 --> 00:33:38,960
And finally just a lot of people askes,

602
00:33:38,960 --> 00:33:41,180
you know actually a reasonable influential design,

603
00:33:43,020 --> 00:33:45,180
and used by quite a number of systems,

604
00:33:46,640 --> 00:33:48,530
so these are used in practice.

605
00:33:50,080 --> 00:33:52,210
This is going to talk about each of these components,

606
00:33:52,210 --> 00:33:53,470
and we'll get more detail,

607
00:33:53,710 --> 00:33:57,220
and then we'll come back to this sort of approach one versus approach two.

608
00:34:00,250 --> 00:34:02,050
So in terms of an overview,

609
00:34:07,060 --> 00:34:07,510
oops,

610
00:34:07,630 --> 00:34:09,880
in terms of an overview,

611
00:34:10,210 --> 00:34:12,460
new sort of [] of the land,

612
00:34:12,490 --> 00:34:19,230
you know there is a massive process or a configuration service,

613
00:34:23,820 --> 00:34:25,200
and then basically keep track

614
00:34:25,230 --> 00:34:29,640
you know which server you know belong to a particular chain.

615
00:34:30,320 --> 00:34:32,660
So S1 S2 S3

616
00:34:32,660 --> 00:34:34,850
you know basically have a record of what the chain is,

617
00:34:34,970 --> 00:34:37,130
who the head is and who the tail is,

618
00:34:37,160 --> 00:34:39,440
and so that could be configuration service,

619
00:34:39,440 --> 00:34:41,750
and here we do actually have our service,

620
00:34:41,750 --> 00:34:47,120
you know S1 S2 S3,

621
00:34:49,870 --> 00:34:52,920
and one of them is the head,

622
00:34:53,190 --> 00:34:55,770
typically the one with the smaller number,

623
00:34:55,770 --> 00:34:57,570
and one is the tail.

624
00:35:00,160 --> 00:35:01,780
And so we have a client,

625
00:35:03,190 --> 00:35:05,590
the client may talk to the configuration server,

626
00:35:05,590 --> 00:35:08,860
who are actually part of the chain,

627
00:35:09,130 --> 00:35:12,700
and then it sends a write request to the head,

628
00:35:13,370 --> 00:35:15,770
so this is a protocol in chain replication,

629
00:35:15,770 --> 00:35:19,960
the write request always goes to the, the head,

630
00:35:20,230 --> 00:35:22,360
and what the head does, the head basically pushes,

631
00:35:22,360 --> 00:35:25,780
you know the head actually applies the operation on its state,

632
00:35:25,780 --> 00:35:28,030
and maybe it has a disk associated with it,

633
00:35:28,030 --> 00:35:30,250
whatever the key value service on it,

634
00:35:30,790 --> 00:35:33,130
and then it sends the update,

635
00:35:33,160 --> 00:35:40,910
you know there's all of the operation down the chain in FIFO order and reliably,

636
00:35:41,090 --> 00:35:44,450
so S1 will send the update to S2,

637
00:35:44,810 --> 00:35:46,520
S2 it has make its own disk,

638
00:35:46,550 --> 00:35:51,050
apply the operation or the state change to its state,

639
00:35:51,500 --> 00:35:53,300
once it actually applyed it,

640
00:35:53,510 --> 00:35:58,400
you know it will forward it to the last node in the chain,

641
00:35:58,400 --> 00:36:00,560
in this, because there are only three nodes in this particular chain,

642
00:36:00,560 --> 00:36:02,300
you could have chains are longer,

643
00:36:02,750 --> 00:36:04,070
if you want more availability,

644
00:36:04,690 --> 00:36:10,270
and when the last node gets the message with state change,

645
00:36:10,360 --> 00:36:12,640
it applies to its state,

646
00:36:13,510 --> 00:36:18,700
and then this is the charge actually sending an acknowledgment back to the client,

647
00:36:20,440 --> 00:36:22,660
so it's the tail who sends the acknowledgement back.

648
00:36:25,180 --> 00:36:28,810
And so one way to think about this is that,

649
00:36:28,810 --> 00:36:33,700
when the tail or in this case S3 you know actually applies to state change,

650
00:36:33,730 --> 00:36:35,080
that's sort of the commit point.

651
00:36:39,080 --> 00:36:40,760
And the reason that this is the commit point

652
00:36:40,760 --> 00:36:44,660
is because subsequent reads always come from the tail,

653
00:36:44,720 --> 00:36:50,010
so if anybody or any other client you know does a read operation,

654
00:36:50,010 --> 00:36:51,300
they always go to the tail,

655
00:36:52,160 --> 00:36:54,500
and the tail basically responds immediately back to them.

656
00:36:55,360 --> 00:36:57,160
So read operations go to the tail,

657
00:36:57,190 --> 00:36:59,320
so here's client 1, here is client 2,

658
00:36:59,560 --> 00:37:01,720
client 2 does read operation,

659
00:37:01,720 --> 00:37:03,490
it goes to the tail,

660
00:37:03,490 --> 00:37:04,960
the tail responds and that's it.

661
00:37:06,630 --> 00:37:09,030
And so there's a couple things that I wanted to point out,

662
00:37:09,270 --> 00:37:12,960
the one of the interesting points out is that,

663
00:37:12,960 --> 00:37:16,400
the read operations just involve one server, right,

664
00:37:16,400 --> 00:37:18,950
like if you remember from lab 3,

665
00:37:18,980 --> 00:37:20,120
or if you have any progress,

666
00:37:20,120 --> 00:37:21,860
we've started to do lab 3,

667
00:37:21,950 --> 00:37:23,870
read operations actually involved,

668
00:37:24,020 --> 00:37:30,140
you know in our implementation, read operation go through the Raft log,

669
00:37:30,140 --> 00:37:31,220
and all that kind of stuff,

670
00:37:31,610 --> 00:37:34,310
the paper discusses an optimization,

671
00:37:34,550 --> 00:37:36,800
but the read operation always goes to the leader,

672
00:37:36,800 --> 00:37:39,950
and the leader first has to contact the majority of the servers,

673
00:37:39,950 --> 00:37:41,990
before it can execute the operation local.

674
00:37:42,410 --> 00:37:44,180
So what you see here is that,

675
00:37:44,330 --> 00:37:46,100
the read operation actually go through tail,

676
00:37:46,100 --> 00:37:49,910
so that different server from write operations,

677
00:37:49,910 --> 00:37:53,480
so the read and write workload is excellent spread at least over two servers,

678
00:37:54,360 --> 00:37:58,560
for more read operation involves only one server,

679
00:37:58,560 --> 00:38:01,260
there's never, doesn't have to talk to any other server,

680
00:38:01,260 --> 00:38:02,250
it can just respond immediately,

681
00:38:02,400 --> 00:38:03,600
and we'll see a little bit later,

682
00:38:03,810 --> 00:38:06,180
why this is actually important,

683
00:38:06,180 --> 00:38:07,080
or why this is actually,

684
00:38:07,080 --> 00:38:09,360
what further optimization this allows.

685
00:38:10,400 --> 00:38:12,170
So the commit point is really

686
00:38:12,170 --> 00:38:15,650
you know the point that the write actually happens at the tail end,

687
00:38:15,800 --> 00:38:19,640
because at that point, the write operation is visible to readers

688
00:38:19,640 --> 00:38:21,500
and not before any other points.

689
00:38:22,780 --> 00:38:26,260
And this also you know provides this linearizability,

690
00:38:26,260 --> 00:38:27,580
so it's pretty easy to see that,

691
00:38:27,580 --> 00:38:28,990
in the case of no crashes,

692
00:38:29,560 --> 00:38:31,270
scheme guarantees linearizability,

693
00:38:31,270 --> 00:38:34,840
because the writes are all applied in sum total order at the head,

694
00:38:35,380 --> 00:38:40,150
and when the tail receives you know that update,

695
00:38:40,180 --> 00:38:41,800
it's, it's the commit point,

696
00:38:41,800 --> 00:38:44,800
it wants to respond to the client and sent the request back.

697
00:38:45,240 --> 00:38:48,150
If you know that same client immediately does a read operation,

698
00:38:48,270 --> 00:38:49,710
it will go to the tail,

699
00:38:49,710 --> 00:38:51,600
and it will observe the last change.

700
00:38:52,200 --> 00:38:55,140
So, certainly within a single client,

701
00:38:55,140 --> 00:38:57,030
basically all operations are totally ordered,

702
00:38:57,760 --> 00:38:59,830
it's pretty easy to see that in client,

703
00:38:59,830 --> 00:39:04,810
if client 2 start to read operation after client 1 operation is finished,

704
00:39:05,020 --> 00:39:07,810
and when it finished, when the tail has responded,

705
00:39:07,990 --> 00:39:11,020
so any read operation that starts after a write operation

706
00:39:11,290 --> 00:39:15,070
will observe you know the last or the result of the most recent write,

707
00:39:15,460 --> 00:39:17,680
and so it's pretty easy to get an intuition here,

708
00:39:17,680 --> 00:39:20,230
that you know this is going to provide us with linearizability.

709
00:39:22,050 --> 00:39:22,650
Okay?

710
00:39:23,460 --> 00:39:28,410
So, what I like to do now is actually to take a quick breakout room section,

711
00:39:28,410 --> 00:39:32,130
and I would like you to discuss the question,

712
00:39:32,130 --> 00:39:33,570
that was was post in lecture,

713
00:39:33,720 --> 00:39:35,010
you know what could go wrong

714
00:39:35,010 --> 00:39:38,400
or like what breaking linearizability,

715
00:39:38,400 --> 00:39:42,030
if instead of having the tail responds to the client,

716
00:39:42,330 --> 00:39:45,510
have the head responded to the client immediately

717
00:39:45,510 --> 00:39:50,070
after it is received you know the write request,

718
00:39:51,360 --> 00:39:53,040
nd maybe those are good topics

719
00:39:53,040 --> 00:39:54,630
or to debate a little bit,

720
00:39:54,630 --> 00:39:56,100
and if you want to go in any other direction

721
00:39:56,100 --> 00:39:58,470
to talk about chain replication of course welcome,

722
00:39:58,470 --> 00:40:00,090
maybe that's something to start with.

723
00:40:00,720 --> 00:40:02,550
So let's take a five minute breakout room,

724
00:40:02,550 --> 00:40:06,760
and then we'll do this and think,

725
00:40:07,280 --> 00:40:08,480
let me see,

726
00:40:08,480 --> 00:40:09,500
Jose, are you going to do it?

727
00:40:10,320 --> 00:40:13,530
And yeah and okay.

728
00:40:13,530 --> 00:40:15,120
You have to make you something, or.

729
00:40:15,120 --> 00:40:16,860
I don't think it's necessary.

730
00:40:17,460 --> 00:40:19,440
I think it Zoom change,

731
00:40:19,440 --> 00:40:20,790
so it should be possible there, too.

732
00:40:24,760 --> 00:40:28,260
Zoom, yep, that's right.

733
00:40:31,810 --> 00:40:33,250
Yep, okay.

734
00:47:43,180 --> 00:47:44,740
Jose, we're coming back.

735
00:47:45,250 --> 00:47:46,810
Yeah, whenever you.

736
00:47:46,990 --> 00:47:47,770
I'm ready.

737
00:47:48,100 --> 00:47:51,160
Okay, I mean I think I can close to Zoom.

738
00:48:57,530 --> 00:48:59,240
Alright, we're back.

739
00:49:07,090 --> 00:49:11,710
Okay, so you know just quickly to summarize,

740
00:49:11,740 --> 00:49:15,370
why you know that would break the linearizability,

741
00:49:15,400 --> 00:49:21,280
so protocol change, change that was propagating was to

742
00:49:21,280 --> 00:49:24,130
you know both keep propagating to S1 and S2 S3,

743
00:49:24,310 --> 00:49:27,250
but you know as soon as S1 actually has done,

744
00:49:27,310 --> 00:49:31,120
which propagation as it responds back to a client,

745
00:49:31,720 --> 00:49:34,930
and clearly this will break the linearizability,

746
00:49:34,930 --> 00:49:37,810
because, let's say the client 1 did write,

747
00:49:37,810 --> 00:49:40,420
got the acknowledgement back you know from S1,

748
00:49:40,480 --> 00:49:43,990
S1 of course has the write also in progress S2 and S3,

749
00:49:44,110 --> 00:49:47,620
but maybe before you know S2 actually context S3,

750
00:49:47,620 --> 00:49:52,400
the client actually sends a read operation you know to S3,

751
00:49:52,550 --> 00:49:56,990
and of course, now it will return a value from before the write is done,

752
00:49:56,990 --> 00:49:59,810
so the client doesn't even observe its own write,

753
00:49:59,810 --> 00:50:02,660
and so clearly break linearizability,

754
00:50:03,020 --> 00:50:04,310
and so it's very important,

755
00:50:04,490 --> 00:50:05,960
that you know as I said earlier,

756
00:50:05,960 --> 00:50:11,870
that's the tail actually sends the acknowledgement back to the client,

757
00:50:12,110 --> 00:50:17,120
because really the once the tail has processed the write operation,

758
00:50:17,120 --> 00:50:19,430
that is actually really what the commit point is.

759
00:50:22,200 --> 00:50:23,370
Any questions about that?

760
00:50:28,400 --> 00:50:31,040
Okay, so this was sort of normal operations,

761
00:50:31,370 --> 00:50:33,860
and let me talk a little bit about crashes,

762
00:50:35,870 --> 00:50:37,550
since it's 6.824 distributed systems,

763
00:50:37,550 --> 00:50:40,220
so all the actually is where when the failures happen.

764
00:50:42,850 --> 00:50:47,260
And one of the things that is cool about chain replication is,

765
00:50:47,290 --> 00:50:50,140
you know the number of failure scenarios is actually quite limited.

766
00:50:50,810 --> 00:50:54,230
And so, let me, basically three cases,

767
00:50:54,230 --> 00:50:58,250
namely the head fails, the one of the intermediate server fails, or tail fails.

768
00:50:58,760 --> 00:51:01,580
So let's look at one of each one of each of those cases,

769
00:51:01,580 --> 00:51:06,080
so here's are you know the case we have a head S1,

770
00:51:06,320 --> 00:51:11,500
let's say that it applied U1, U2 and U3 sort three updates,

771
00:51:12,330 --> 00:51:14,100
talks to S2,

772
00:51:15,050 --> 00:51:18,620
maybe S2 has done U2 and U1,

773
00:51:19,930 --> 00:51:23,320
and you know here we have S3 which is the tail,

774
00:51:23,940 --> 00:51:26,130
and it only has done U1 so far,

775
00:51:26,310 --> 00:51:30,420
and so the client client was talking to S1,

776
00:51:31,500 --> 00:51:35,220
and we now want to think about what happens,

777
00:51:35,220 --> 00:51:38,130
and what needs to happen in one of these crashes.

778
00:51:38,310 --> 00:51:42,180
So let's start with the case that the head crashes,

779
00:51:42,730 --> 00:51:45,370
and so the head crashes, what needs to be done,

780
00:51:47,530 --> 00:51:50,020
this is an easy case or hard case?

781
00:51:53,070 --> 00:51:53,850
Easier.

782
00:51:54,060 --> 00:51:55,980
I hope in easy case, why?

783
00:51:56,780 --> 00:52:00,050
You can just cut off the head,

784
00:52:00,470 --> 00:52:02,390
oh, sorry, the yeah, the head,

785
00:52:02,390 --> 00:52:05,900
and you know make S2 the head now.

786
00:52:06,170 --> 00:52:10,070
Yeah, you know, so what's going to happen correct is,

787
00:52:10,070 --> 00:52:12,590
the configuration service discovers that S1 is gone,

788
00:52:13,080 --> 00:52:14,610
when decides if S1 is gone,

789
00:52:14,880 --> 00:52:23,880
and then basically can promote S2 to be the head in the subsequent operations,

790
00:52:24,120 --> 00:52:26,970
and clients now in the future and talk to this guy,

791
00:52:27,120 --> 00:52:28,440
and why is this correct,

792
00:52:29,690 --> 00:52:31,400
so what operation have we lost?

793
00:52:33,100 --> 00:52:34,630
We lost U3.

794
00:52:34,720 --> 00:52:36,130
Yeah, is that a problem?

795
00:52:36,840 --> 00:52:39,150
That's valid to lose operations.

796
00:52:39,360 --> 00:52:42,690
Yeah, yeah, it's fair game to lose U3,

797
00:52:42,720 --> 00:52:44,370
U3 has not been committed,

798
00:52:44,400 --> 00:52:46,500
because only operations at the tail committed,

799
00:52:46,980 --> 00:52:49,290
and so just as if the operation never happens,

800
00:52:49,290 --> 00:52:51,420
you know the client could not even have observed,

801
00:52:51,450 --> 00:52:55,890
you know that actually U this U2 or U3 actually it happens,

802
00:52:55,890 --> 00:52:56,820
or U3 it should happen.

803
00:52:57,310 --> 00:52:57,790
Okay?

804
00:52:57,820 --> 00:53:00,010
So it's perfectly fine to do this,

805
00:53:00,130 --> 00:53:03,580
why is it important configuration service actually involved here,

806
00:53:03,580 --> 00:53:06,610
could like S2 decide on its own to become the head,

807
00:53:07,380 --> 00:53:09,150
let's say yes, U2 talk to anyone anymore,

808
00:53:09,150 --> 00:53:11,160
and decides like whatever I want to become head,

809
00:53:11,780 --> 00:53:12,680
would that be valid?

810
00:53:14,770 --> 00:53:18,790
What is that, like maybe create a split.

811
00:53:18,940 --> 00:53:22,270
Yeah, yeah, that would create a split-brain, right,

812
00:53:22,270 --> 00:53:25,750
because it might, S2 might just be partitioned from S1,

813
00:53:26,140 --> 00:53:27,940
and so now both are heads,

814
00:53:28,210 --> 00:53:30,100
maybe both are processing commands,

815
00:53:30,100 --> 00:53:31,870
will be you know violate are,

816
00:53:32,170 --> 00:53:37,000
you know basically the sort of the whole [] having the total order,

817
00:53:38,190 --> 00:53:38,550
we can now.

818
00:53:38,550 --> 00:53:43,440
Also, does S2 even know that S1 is a head,

819
00:53:43,560 --> 00:53:45,660
because it just receives.

820
00:53:46,360 --> 00:53:49,900
You probably got it from the configuration information in previous time,

821
00:53:50,350 --> 00:53:53,620
like when configuration service decides a new configuration,

822
00:53:53,620 --> 00:53:54,700
they can tell all the servers

823
00:53:54,700 --> 00:53:57,010
and whatever and the clients actually care,

824
00:53:57,040 --> 00:53:58,300
you know here's the new configuration.

825
00:54:00,090 --> 00:54:03,870
Does this only happen when S1 to S2 connection is separate

826
00:54:03,870 --> 00:54:06,870
or wait what, what causes the split-brain again?

827
00:54:07,760 --> 00:54:08,750
Split-brain would happen,

828
00:54:08,750 --> 00:54:12,650
if S2 on its own decided that S1 has failed and became the head,

829
00:54:13,220 --> 00:54:15,290
so we're not allowed to have that happen,

830
00:54:15,290 --> 00:54:18,440
and the way actually the work out in practice is that,

831
00:54:18,440 --> 00:54:19,790
there is a configuration server,

832
00:54:20,030 --> 00:54:22,610
that actually decides what is actually the current configuration,

833
00:54:23,300 --> 00:54:26,810
and so if it decides that S1 is dead,

834
00:54:27,170 --> 00:54:29,630
then it can inform S2 S3,

835
00:54:29,630 --> 00:54:34,310
saying like hey you guys are now the new chain and S2 the head,

836
00:54:35,030 --> 00:54:36,590
and when that change happens,

837
00:54:36,590 --> 00:54:38,660
so in this case, basically S1 is dropped,

838
00:54:38,690 --> 00:54:40,850
nothing else has to happen,

839
00:54:40,850 --> 00:54:43,310
because S2 has,

840
00:54:43,550 --> 00:54:45,170
the only update that we lost,

841
00:54:45,170 --> 00:54:46,730
the one actually was not committed anyway,

842
00:54:46,730 --> 00:54:48,320
so there's nothing to be repaired further.

843
00:54:49,990 --> 00:54:53,530
So making this go from this setting from three replica

844
00:54:53,560 --> 00:54:56,620
with the dropping the head is basically pretty straightforward operation.

845
00:55:00,140 --> 00:55:00,950
Okay?

846
00:55:01,450 --> 00:55:03,640
Professor, I have a question,

847
00:55:03,640 --> 00:55:06,400
so there's there's an assumption here,

848
00:55:06,400 --> 00:55:10,720
that like the commands that,

849
00:55:10,720 --> 00:55:17,620
like like leave S1 like will arrive in order at S2,

850
00:55:17,950 --> 00:55:21,530
is that like, is that a reasonable assumption, for like.

851
00:55:21,830 --> 00:55:23,450
Well, I think the way they,

852
00:55:23,480 --> 00:55:24,470
so they basically say,

853
00:55:24,470 --> 00:55:28,070
we need a reliable FIFO between S1 and S2, right,

854
00:55:28,070 --> 00:55:29,000
S2 to S3,

855
00:55:29,060 --> 00:55:32,330
and I think the way they implement, that is probably using TCP connection.

856
00:55:36,470 --> 00:55:36,980
Okay, thanks.

857
00:55:37,620 --> 00:55:39,690
Okay, so let's look at the second case.

858
00:55:40,200 --> 00:55:47,510
So we're have you know S1, you know S2, S3,

859
00:55:47,660 --> 00:55:50,060
and of course there could be more you know servers into chain,

860
00:55:50,060 --> 00:55:53,480
but like you know three enough for us to consider all the cases,

861
00:55:54,020 --> 00:55:57,950
and so now what we want to do take the case, where a middle one crashes,

862
00:55:58,790 --> 00:55:59,720
this one crashes.

863
00:56:00,780 --> 00:56:05,760
And so the configuration service at some point decides S2 crash,

864
00:56:05,760 --> 00:56:10,050
you know informs S1 S3, that basically they form the new chain,

865
00:56:10,730 --> 00:56:14,660
and we're wondering about like what else needs to happen?

866
00:56:16,010 --> 00:56:17,180
We saw in the first case,

867
00:56:17,180 --> 00:56:20,000
the head drops, then nothing really has to be done,

868
00:56:20,000 --> 00:56:21,260
other than updating the chain,

869
00:56:21,260 --> 00:56:22,400
now we're updating the chain,

870
00:56:22,400 --> 00:56:24,740
the question is, is anything needs to happen?

871
00:56:26,850 --> 00:56:29,880
The S1 needs to send to S3,

872
00:56:29,880 --> 00:56:31,650
the request that it sent to S2,

873
00:56:31,650 --> 00:56:37,770
but didn't make it to S3.

874
00:56:38,220 --> 00:56:41,400
Yes, we have you know U1 U2 U3,

875
00:56:41,400 --> 00:56:43,410
this guy had see U1 and U2,

876
00:56:43,920 --> 00:56:45,630
and this guy see U1,

877
00:56:45,630 --> 00:56:47,280
and the U2 that's actually in progress,

878
00:56:47,280 --> 00:56:52,440
you know the I got lost S2,

879
00:56:52,440 --> 00:56:54,900
basically S1 has to bring S3 up to date,

880
00:56:54,930 --> 00:56:57,030
basically forward U2 and U3.

881
00:56:58,120 --> 00:57:00,430
Okay, so that's a little bit of work involved,

882
00:57:00,700 --> 00:57:03,900
let's consider the final case, the tail.

883
00:57:04,820 --> 00:57:06,890
So here we go again,

884
00:57:06,920 --> 00:57:08,090
we have three cases,

885
00:57:09,200 --> 00:57:14,540
S1, three servers S2, the third one S3.

886
00:57:16,240 --> 00:57:21,820
And, let's see, so the tail crashes.

887
00:57:22,990 --> 00:57:25,300
And so at some point in time,

888
00:57:25,300 --> 00:57:30,730
the configuration service notices decides that the new chain is going to be S1 and S2,

889
00:57:30,730 --> 00:57:33,220
tells S1 and S2 that they are part of the new chain,

890
00:57:33,670 --> 00:57:36,370
and what else needs to happen?

891
00:57:38,240 --> 00:57:39,770
Well, let's write down,

892
00:57:40,160 --> 00:57:44,710
we know, this guy have seen U1 U2 and U3,

893
00:57:44,710 --> 00:57:46,750
this guy have seen U1 U2,

894
00:57:48,040 --> 00:57:50,710
so who becomes the new tail in this scenario?

895
00:57:51,990 --> 00:57:52,590
S2.

896
00:57:52,860 --> 00:57:54,480
Yes, S2 becomes new tail,

897
00:57:54,690 --> 00:57:56,340
and anything else that needs to happen?

898
00:57:57,380 --> 00:58:01,850
I guess the client needs to be informed that S2 is the.

899
00:58:02,300 --> 00:58:04,970
Yeah, that's the client might learn from the configuration service, correct.

900
00:58:05,750 --> 00:58:08,120
And so yeah, but nothing else has to happen, right,

901
00:58:08,120 --> 00:58:12,050
because the, all the committed,

902
00:58:12,050 --> 00:58:14,900
you know the no committed operations are lost,

903
00:58:15,080 --> 00:58:20,150
and you know, and as we are still in

904
00:58:20,150 --> 00:58:23,810
needs to still be actually propagated to S2 will be just happening.

905
00:58:24,740 --> 00:58:26,750
Okay, so dropping the tail is also reasonable straightforward.

906
00:58:26,750 --> 00:58:29,300
So dropping the tail, the head is a reasonable straightforward,

907
00:58:29,510 --> 00:58:31,460
dropping the middle one is a bit more complicated,

908
00:58:31,670 --> 00:58:33,050
but not much more complicated.

909
00:58:33,320 --> 00:58:37,270
And the key thing go I want to sort of emphasize here is,

910
00:58:37,420 --> 00:58:40,600
how does this compare to figure 7 and 8 in the Raft paper?

911
00:58:49,080 --> 00:58:49,770
Maybe to.

912
00:58:50,550 --> 00:58:51,180
Yeah, go ahead.

913
00:58:52,620 --> 00:59:02,700
Question, so,

914
00:59:02,700 --> 00:59:05,280
that these new operations have been automatically.

915
00:59:06,210 --> 00:59:08,100
Um, sorry, I didn't hear you,

916
00:59:08,130 --> 00:59:11,520
you were pretty pretty noisy connection there.

917
00:59:12,890 --> 00:59:16,970
Yeah, like I'm just saying, that S2 becomes new tail,

918
00:59:17,360 --> 00:59:19,910
don't have to send acknowledgment back to the client,

919
00:59:19,910 --> 00:59:22,310
and there are some entries that have been automatically committed.

920
00:59:23,810 --> 00:59:25,430
Yeah, that might be the case,

921
00:59:25,430 --> 00:59:29,390
that what happens is the client is probably going to retry, right,

922
00:59:29,870 --> 00:59:35,240
and we have to have a separate duplication scheme like in lab 3 anyway,

923
00:59:36,470 --> 00:59:39,920
and so there's kind of a couple different ways about how to do it,

924
00:59:39,920 --> 00:59:42,170
the paper are not particularly clear which one it will take.

925
00:59:43,610 --> 00:59:44,660
Okay, I see, thank you.

926
00:59:45,660 --> 00:59:47,850
Yeah, like in that in that case,

927
00:59:47,850 --> 00:59:49,470
didn't the paper just say like,

928
00:59:50,120 --> 00:59:51,590
you know it might like,

929
00:59:52,160 --> 00:59:53,480
even if it doesn't respond it,

930
00:59:53,480 --> 00:59:55,460
could or could not have succeeded.

931
00:59:57,950 --> 00:59:59,930
Okay, so back to my actual original question,

932
00:59:59,930 --> 01:00:02,090
which is like, you know how does this contrast,

933
01:00:02,090 --> 01:00:05,720
this picture of my my drawn picture here on this white board,

934
01:00:05,720 --> 01:00:07,490
how does that contrast to figure 7 and 8?

935
01:00:08,610 --> 01:00:09,240
Simpler.

936
01:00:09,780 --> 01:00:13,200
Yeah, I mean that's the key point I wanted to get across, right,

937
01:00:13,200 --> 01:00:15,810
you know there's not that many cases to consider here,

938
01:00:15,810 --> 01:00:16,920
basically three cases,

939
01:00:17,280 --> 01:00:23,400
which is like slightly you know quite a bit simpler than the case of the Raft paper,

940
01:00:23,400 --> 01:00:26,910
where the many to consider, the scenarios are quite complicated,

941
01:00:27,060 --> 01:00:30,510
now part of that is because you know it's a chain, right,

942
01:00:30,510 --> 01:00:36,420
you know things are pushed down in a very sort of straightforward manner,

943
01:00:36,420 --> 01:00:37,710
down the replication chain,

944
01:00:38,070 --> 01:00:39,540
and part of that is, of course,

945
01:00:39,540 --> 01:00:43,800
the configuration part is sort of outsource to configuration manager manager.

946
01:00:44,540 --> 01:00:48,260
But for the primary backup part of the recovery plan,

947
01:00:48,320 --> 01:00:49,490
that's a reasonable straightforward,

948
01:00:49,520 --> 01:00:51,800
there are only three configurations to consider.

949
01:00:54,920 --> 01:00:56,690
One more point I want to make,

950
01:00:56,690 --> 01:00:58,400
which is like how to add a replica,

951
01:00:58,520 --> 01:01:01,820
because any system you know that here going to run for real time,

952
01:01:01,820 --> 01:01:05,410
really at some point you gotta add a new one in,

953
01:01:05,680 --> 01:01:07,930
because otherwise you're gonna lose,

954
01:01:07,930 --> 01:01:08,800
you start the three,

955
01:01:08,800 --> 01:01:10,720
then you have two, then get one and then you have zero,

956
01:01:10,720 --> 01:01:11,680
and then you're on the [].

957
01:01:11,710 --> 01:01:15,520
So, you know you have to add new replica,

958
01:01:15,520 --> 01:01:17,170
so let's to consider the case,

959
01:01:17,620 --> 01:01:20,200
so here's S1, it is the head,

960
01:01:21,820 --> 01:01:23,170
let's say we're in a scenario,

961
01:01:23,170 --> 01:01:26,710
where you know we have S1 and S2 who's the tail,

962
01:01:26,710 --> 01:01:29,800
and basically we want to bring up S3,

963
01:01:32,190 --> 01:01:34,200
and it turns out you know as the paper described,

964
01:01:34,200 --> 01:01:40,080
it was most convenient to actually do this at the tail end of it,

965
01:01:40,260 --> 01:01:44,490
so basically make the new server, the new tail.

966
01:01:45,170 --> 01:01:46,970
And so the way that we proceed is,

967
01:01:46,970 --> 01:01:48,380
like the client is here,

968
01:01:48,740 --> 01:01:50,750
talking to S2,

969
01:01:50,750 --> 01:01:52,430
because that's the current tail,

970
01:01:52,550 --> 01:01:54,020
S3 comes up,

971
01:01:54,140 --> 01:01:55,610
and basically the first thing it does is,

972
01:01:55,610 --> 01:01:59,090
it actually copies you know old state from S3 to,

973
01:01:59,180 --> 01:02:00,080
from S2 to S3.

974
01:02:01,040 --> 01:02:03,170
And so this may take hours, right,

975
01:02:03,170 --> 01:02:06,680
where you know tens of minutes or maybe indeed multiple hours,

976
01:02:06,680 --> 01:02:11,360
you're going to copying gigabytes of data or terabytes of data from S2 to S3,

977
01:02:11,630 --> 01:02:12,830
but while that's happening,

978
01:02:12,830 --> 01:02:16,220
you know S2 and S3 can just serve request,

979
01:02:16,880 --> 01:02:23,690
of course it does have to remember which ones are came in after S3 start copy,

980
01:02:23,720 --> 01:02:27,500
so keep a list of all the updates that are sort of happened,

981
01:02:27,500 --> 01:02:29,780
but there have not been propagated to S3 yet,

982
01:02:29,900 --> 01:02:32,900
at some point S3 done with all the copying,

983
01:02:33,080 --> 01:02:34,460
and basically tells S2,

984
01:02:34,460 --> 01:02:37,310
okay, man, I'm ready you know to become the tail,

985
01:02:37,310 --> 01:02:38,330
I got all the state,

986
01:02:38,660 --> 01:02:43,310
S2, so sends an email, sends email, sends message to S2,

987
01:02:43,310 --> 01:02:46,580
saying, okay, I want to be the tail,

988
01:02:46,610 --> 01:02:48,860
S2 responses, like yeah that's okay,

989
01:02:48,980 --> 01:02:52,130
but once your applied all the updates.

990
01:02:54,030 --> 01:02:57,930
And so basically S2 sends the updates in response to this,

991
01:02:57,930 --> 01:03:02,330
I want to go on to come to a tail request,

992
01:03:02,330 --> 01:03:05,000
in response that to S3,

993
01:03:05,090 --> 01:03:06,530
S3 replies the updates,

994
01:03:06,710 --> 01:03:09,140
and then becomes you know the tail,

995
01:03:09,650 --> 01:03:12,200
and you know clients that we're talking to S2,

996
01:03:12,200 --> 01:03:13,670
and S2 can tell the client,

997
01:03:13,670 --> 01:03:15,320
you know from now on, I'm not tail anymore,

998
01:03:15,320 --> 01:03:16,220
you should talk to S3,

999
01:03:16,310 --> 01:03:18,860
and so they can swap you know that direction.

1000
01:03:19,470 --> 01:03:23,820
And so that's the way to add a replica into a chain.

1001
01:03:26,160 --> 01:03:28,020
So question on this,

1002
01:03:28,140 --> 01:03:30,300
don't you run into this like infinite loop problem,

1003
01:03:30,300 --> 01:03:32,340
where S2 sends updates to S3,

1004
01:03:32,340 --> 01:03:36,360
and when S3 is like updating, its also serving more requests,

1005
01:03:36,360 --> 01:03:37,620
so as more updates,

1006
01:03:37,650 --> 01:03:39,660
that needs to send and goes back and forth?

1007
01:03:40,280 --> 01:03:43,940
No, no, once S2 have sent the updates,

1008
01:03:43,940 --> 01:03:47,120
S3 have not seen yet, you know to S2 to S3,

1009
01:03:47,240 --> 01:03:49,730
then from then on the normal chain replication,

1010
01:03:49,730 --> 01:03:51,620
whenever S2 gets a request,

1011
01:03:51,620 --> 01:03:52,910
you know update from S1,

1012
01:03:53,090 --> 01:03:54,590
it forwards it to S3.

1013
01:03:57,400 --> 01:03:59,380
Right, but S3 can become the tail

1014
01:03:59,380 --> 01:04:02,110
until it is successfully processed all the updates.

1015
01:04:02,110 --> 01:04:05,980
Oh, yeah so, yeah, once it sets up the TCP channel,

1016
01:04:05,980 --> 01:04:08,140
basically S2 can just say like for,

1017
01:04:08,320 --> 01:04:09,910
once you've processed these guys,

1018
01:04:09,940 --> 01:04:10,930
you can become the tail,

1019
01:04:10,930 --> 01:04:11,950
because you've seen everything.

1020
01:04:12,310 --> 01:04:12,850
I mean.

1021
01:04:12,850 --> 01:04:15,760
And everything else you can be pipelined after that, right,

1022
01:04:15,760 --> 01:04:17,170
in the same TCP channel.

1023
01:04:19,040 --> 01:04:22,010
It could become the tail, right, right after,

1024
01:04:22,040 --> 01:04:23,870
like even before it processes the update,

1025
01:04:23,870 --> 01:04:26,180
as long as it doesn't serve requests.

1026
01:04:26,660 --> 01:04:28,670
As long as it doesn't serve requests exactly, right,

1027
01:04:28,670 --> 01:04:30,110
it just has to process all the updates,

1028
01:04:30,110 --> 01:04:32,000
that S2 is received S3 not,

1029
01:04:32,390 --> 01:04:33,680
once we updated those,

1030
01:04:33,680 --> 01:04:37,280
then it becomes tail and start processing request.

1031
01:04:38,780 --> 01:04:41,600
I see, so blocks like requests for a moment,

1032
01:04:41,600 --> 01:04:43,550
while it processes new update.

1033
01:04:48,820 --> 01:04:49,420
Okay?

1034
01:04:52,900 --> 01:04:58,090
Okay, so now I wanna come back you know to basically questions lots of people ask,

1035
01:04:58,090 --> 01:05:00,340
how this contrast to sort of,

1036
01:05:01,270 --> 01:05:04,660
how are the CR properties, chain replication properties,

1037
01:05:04,810 --> 01:05:06,370
how do how does it compare,

1038
01:05:07,700 --> 01:05:09,770
and one of the good, one of the good properties

1039
01:05:09,770 --> 01:05:13,430
and mostly with [respectful] in comparison to Raft.

1040
01:05:15,320 --> 01:05:16,910
And of course I got to say,

1041
01:05:16,910 --> 01:05:22,520
of course like the chain replication just influence the primary backup scheme,

1042
01:05:22,520 --> 01:05:24,350
but not the configuration service,

1043
01:05:24,470 --> 01:05:26,270
so we'll come back to that a little bit more in detail,

1044
01:05:26,270 --> 01:05:27,470
but a couple things that we can know,

1045
01:05:27,470 --> 01:05:31,610
we just compare sort of the way,

1046
01:05:31,610 --> 01:05:34,910
the Raft protocol works with the chain replication protocol.

1047
01:05:35,480 --> 01:05:37,430
And first of all you know we can achieve,

1048
01:05:37,430 --> 01:05:40,010
positive aspect you know chain replication is that

1049
01:05:40,100 --> 01:05:52,810
the client RPCs are you know split between to the head and the tail,

1050
01:05:56,600 --> 01:06:00,200
that's a load of actually serving any client operation

1051
01:06:00,200 --> 01:06:02,120
that can be split actually between two of them,

1052
01:06:02,210 --> 01:06:05,420
they don't have to run through the leader as in in Raft.

1053
01:06:06,410 --> 01:06:12,060
Furthermore, the head sends the update once,

1054
01:06:12,600 --> 01:06:14,070
so unlike in Raft,

1055
01:06:14,460 --> 01:06:18,510
where the head or the leader basically sends updates,

1056
01:06:18,510 --> 01:06:21,240
the log entry to every peer,

1057
01:06:21,330 --> 01:06:22,680
in this particular scheme,

1058
01:06:22,680 --> 01:06:27,870
actually it's only happened the head always sends one basically RPC,

1059
01:06:28,580 --> 01:06:30,470
and so there are fewer messages involved.

1060
01:06:31,220 --> 01:06:42,160
Reads or query operations involve only, only the tail,

1061
01:06:43,160 --> 01:06:44,510
unlike in the Raft,

1062
01:06:44,510 --> 01:06:48,950
you know the if you, even if you implement the read-only optimization,

1063
01:06:49,130 --> 01:06:55,070
the read-only optimization avoid, having read operation go through the log

1064
01:06:55,220 --> 01:06:57,740
and being appended to all the logs to peers,

1065
01:06:57,920 --> 01:07:02,960
but it still requires that the leader actually contact the majority of the peers

1066
01:07:03,020 --> 01:07:08,180
to decide when it's actually an operation can be served.

1067
01:07:09,820 --> 01:07:14,830
So another positive aspect of this [] is a simple crash recovery,

1068
01:07:14,830 --> 01:07:15,730
as we talked about.

1069
01:07:23,620 --> 01:07:28,150
But you know a major downside compared to sort of the Raft scheme

1070
01:07:28,180 --> 01:07:35,890
is that you have one failure requires reconfiguration,

1071
01:07:44,720 --> 01:07:48,230
and the reason now that the reconfiguration required is,

1072
01:07:48,230 --> 01:07:51,740
because like write actually have to go through the whole chain,

1073
01:07:52,340 --> 01:07:54,740
and so, and the write cannot acknowledge

1074
01:07:54,740 --> 01:07:58,250
until that every server in the chain actually has processes.

1075
01:07:58,880 --> 01:08:00,440
And that is actually slightly different, correct,

1076
01:08:00,440 --> 01:08:01,640
in Raft, as you well know,

1077
01:08:01,790 --> 01:08:05,210
because assume it's basically majority the peers

1078
01:08:05,210 --> 01:08:08,750
actually accepted the particular write operation, appended to their logs,

1079
01:08:08,750 --> 01:08:10,040
the system can just proceed,

1080
01:08:10,640 --> 01:08:13,010
and so there's actually no interruption at all,

1081
01:08:13,010 --> 01:08:15,050
if one server fails, for example,

1082
01:08:16,120 --> 01:08:18,220
if the remaining servers still form a majority,

1083
01:08:18,580 --> 01:08:20,170
while in chain replication,

1084
01:08:20,260 --> 01:08:22,150
if one server would fail,

1085
01:08:22,210 --> 01:08:24,490
then you know some reconfiguration actually has to happen,

1086
01:08:24,490 --> 01:08:29,000
which means there's gonna be a short period probably downtime, right.

1087
01:08:29,540 --> 01:08:30,260
Does that make sense?

1088
01:08:35,010 --> 01:08:37,050
Now I want to make one more point

1089
01:08:37,050 --> 01:08:42,300
sort of in contrast you know to sort of the Raft replication scheme is this,

1090
01:08:42,600 --> 01:08:45,150
because the read operations involve only one server,

1091
01:08:45,150 --> 01:08:48,400
there's a cool extension,

1092
01:08:48,400 --> 01:08:50,980
if you will, that actually gets really high read performance,

1093
01:08:51,160 --> 01:08:53,470
and so the basic idea is as follows,

1094
01:09:10,550 --> 01:09:13,040
the basic idea is basically to split,

1095
01:09:13,070 --> 01:09:17,470
you know the split objects or they call volumes in the paper,

1096
01:09:17,500 --> 01:09:21,000
split the objects across multiple chains.

1097
01:09:27,360 --> 01:09:30,780
So instead of having one chain that I've done in the previous boards,

1098
01:09:30,780 --> 01:09:32,250
we're going to have multiple chains.

1099
01:09:32,430 --> 01:09:37,560
And so for example, we might have CH1 in chain 1,

1100
01:09:37,740 --> 01:09:42,600
S1 is the head, S2 is the middle guy and S3 is the tail.

1101
01:09:43,260 --> 01:09:47,720
And chain 2, you know we're going to rotate things around,

1102
01:09:47,780 --> 01:09:51,920
S2 as the head, S3 is the middle guy,

1103
01:09:51,950 --> 01:09:56,960
oops, S3 is the middle guy and S1 is the tail.

1104
01:09:57,630 --> 01:10:02,550
And chain 3, we're going to arrange basically S3 as the head guy,

1105
01:10:02,550 --> 01:10:08,760
S2 as, oops S1 the middle guy and S2 is the tail.

1106
01:10:09,710 --> 01:10:10,730
Basically we're gonna do is,

1107
01:10:10,730 --> 01:10:13,730
we're going to split objects across these multiple chains,

1108
01:10:13,730 --> 01:10:15,980
so the configuration service basically has a map,

1109
01:10:15,980 --> 01:10:18,140
you know saying like you know shard 1,

1110
01:10:18,140 --> 01:10:20,300
you know objects in shard one go to chain 1,

1111
01:10:20,540 --> 01:10:23,810
object in shard 2 go to chain 2,

1112
01:10:23,810 --> 01:10:25,910
objects in shard 3 you know go to chain 3.

1113
01:10:27,140 --> 01:10:29,600
And what is the cool part about it is that,

1114
01:10:29,870 --> 01:10:32,540
you know we have multiple tails,

1115
01:10:32,930 --> 01:10:35,600
and S1, S3 is tail for some chain,

1116
01:10:35,630 --> 01:10:38,600
S1 is a tail for some chain,

1117
01:10:38,690 --> 01:10:40,520
S2 is a tail for some chain,

1118
01:10:41,030 --> 01:10:43,670
and basically read operations to different chain

1119
01:10:43,790 --> 01:10:46,340
can now be completely executed in parallel,

1120
01:10:46,400 --> 01:10:49,910
so if the read operations hit all the different shards,

1121
01:10:50,120 --> 01:10:51,740
sort of uniform spread,

1122
01:10:51,740 --> 01:10:55,190
basically you know our read throughput is going to increase linearly

1123
01:10:55,190 --> 01:10:57,230
with the number of tails that we have,

1124
01:10:57,260 --> 01:10:58,580
and in this case, we have three tails,

1125
01:10:58,580 --> 01:11:00,230
so we get three times to read performance.

1126
01:11:01,260 --> 01:11:02,580
So we did basically sort the same,

1127
01:11:02,580 --> 01:11:05,460
so we get a little bit of the same properties the zookeeper had,

1128
01:11:05,730 --> 01:11:07,680
where the read performance can be excellent,

1129
01:11:08,070 --> 01:11:09,630
scale with the number of servers,

1130
01:11:09,990 --> 01:11:12,090
but we also get not only that,

1131
01:11:12,090 --> 01:11:13,470
we get the scale part,

1132
01:11:13,980 --> 01:11:15,990
and we maintain the linearizability,

1133
01:11:17,880 --> 01:11:20,790
in this scheme, we don't have to actually give up on linearizability.

1134
01:11:22,580 --> 01:11:26,030
So we get to two nice properties,

1135
01:11:26,030 --> 01:11:29,330
namely good read performance and effective scaling with the number of servers,

1136
01:11:29,720 --> 01:11:32,660
at least for reads to different chains,

1137
01:11:32,660 --> 01:11:35,990
and we got actually and we maintain linearizability.

1138
01:11:43,420 --> 01:11:44,440
Any questions about this?

1139
01:11:49,540 --> 01:11:50,350
Sorry, in this case,

1140
01:11:50,350 --> 01:11:55,840
the client when they are deciding which chain to read from,

1141
01:11:56,260 --> 01:12:00,580
would they be able to, to do like to decide themselves

1142
01:12:00,580 --> 01:12:04,810
or do they need to contact the configuration server to decide.

1143
01:12:05,140 --> 01:12:06,760
Yeah, so this is a great question,

1144
01:12:06,760 --> 01:12:10,480
so typically and the paper actually doesn't really explicit about it,

1145
01:12:10,480 --> 01:12:14,890
you know they talk about maybe talking through proxy to servers,

1146
01:12:15,160 --> 01:12:16,810
what you will do in lab 4 is

1147
01:12:16,810 --> 01:12:18,610
basically you will download the configuration,

1148
01:12:18,850 --> 01:12:21,430
the configuration will include the shard assignment,

1149
01:12:21,880 --> 01:12:24,880
and you download that from the configuration server.

1150
01:12:28,820 --> 01:12:29,960
You need to be careful about

1151
01:12:29,960 --> 01:12:32,240
how you order the servers in each of the chains,

1152
01:12:32,240 --> 01:12:35,120
prevent like a particular chain from being oversaturated

1153
01:12:35,300 --> 01:12:37,550
or particular [link] between like two servers.

1154
01:12:38,140 --> 01:12:42,490
Yeah, this, this, this, this scheme doesn't really take that into account,

1155
01:12:42,490 --> 01:12:46,150
you can imagine like the configuration plan or the configuration manager

1156
01:12:46,150 --> 01:12:49,510
has a sophisticated model of actually how the network is laid out,

1157
01:12:49,510 --> 01:12:51,970
and you know can be very careful about how the chains are done,

1158
01:12:53,810 --> 01:12:56,060
maybe even shard more shards to one chain,

1159
01:12:56,060 --> 01:12:57,740
you know fewer shards to another chain,

1160
01:12:57,740 --> 01:12:59,540
all the stuff is in principle possible,

1161
01:12:59,630 --> 01:13:03,380
because the configuration manage can just compute anything it likes,

1162
01:13:03,380 --> 01:13:05,510
and basically says here's the assignment.

1163
01:13:08,220 --> 01:13:08,670
Thank you.

1164
01:13:09,030 --> 01:13:10,860
Can even rebalance, if it wants to.

1165
01:13:18,560 --> 01:13:19,190
Answer the question,

1166
01:13:19,190 --> 01:13:22,550
could you explain again how linearizability is kept under this extension?

1167
01:13:22,550 --> 01:13:24,620
Well, nothing has really changed,

1168
01:13:24,650 --> 01:13:27,800
we're still doing primary backup using a chain,

1169
01:13:28,070 --> 01:13:35,690
and and so you know we basically carry over the linearizability from the single chain

1170
01:13:35,720 --> 01:13:36,440
and that's it.

1171
01:13:42,470 --> 01:13:44,180
This might be like speculative,

1172
01:13:44,180 --> 01:13:45,830
but how this compared to,

1173
01:13:47,020 --> 01:13:51,430
I guess maybe it's equivalent of just having groups of servers for each like link,

1174
01:13:51,790 --> 01:13:53,500
instead of having reusing the same ones,

1175
01:13:53,530 --> 01:13:54,820
or not for each link,

1176
01:13:54,820 --> 01:13:58,330
but for each step in the chain,

1177
01:13:58,330 --> 01:14:00,400
so like S1 is like three servers,

1178
01:14:00,400 --> 01:14:01,750
S2 has three servers,

1179
01:14:02,050 --> 01:14:03,910
instead of reusing the same one

1180
01:14:04,180 --> 01:14:05,650
and entering from different points.

1181
01:14:06,190 --> 01:14:11,260
Yeah yeah, what would be the advantage of that scheme that you imagine?

1182
01:14:11,260 --> 01:14:12,850
I mean just for scalability,

1183
01:14:14,860 --> 01:14:17,320
while also maintain linearizability.

1184
01:14:17,530 --> 01:14:20,680
Well, the the reason that this scheme is attractive is that,

1185
01:14:20,680 --> 01:14:22,630
because we have the tail might have quite a bit of load,

1186
01:14:22,630 --> 01:14:23,770
but the middle guy doesn't,

1187
01:14:23,800 --> 01:14:26,110
and you know by having sort of this arrangement,

1188
01:14:26,230 --> 01:14:28,150
we spread the load across all servers.

1189
01:14:30,910 --> 01:14:31,810
I see, okay.

1190
01:14:40,090 --> 01:14:40,750
Okay, good.

1191
01:14:41,450 --> 01:14:43,790
So maybe I want to summarize here,

1192
01:14:47,850 --> 01:14:50,220
and sort of talk a little bit about,

1193
01:14:50,220 --> 01:14:51,720
so we saw the approach 1,

1194
01:14:52,830 --> 01:14:56,810
which we're do in lab, which we do in lab 3,

1195
01:14:56,810 --> 01:14:59,990
which is run all the operations through Raft,

1196
01:14:59,990 --> 01:15:07,040
and or the replication, you know the configuration and replication is all built using Raft

1197
01:15:07,040 --> 01:15:08,360
and nothing else is involved,

1198
01:15:08,660 --> 01:15:10,430
and then sort of this approach 2,

1199
01:15:10,460 --> 01:15:13,970
you know which is the topic of this particular paper,

1200
01:15:13,970 --> 01:15:16,340
where there's a configuration server,

1201
01:15:16,400 --> 01:15:21,380
perhaps built using Raft or Paxos anyone

1202
01:15:21,620 --> 01:15:24,710
and a primary backup replication scheme,

1203
01:15:26,010 --> 01:15:32,410
and primary backup using chain replication.

1204
01:15:39,690 --> 01:15:40,890
And you can see,

1205
01:15:40,890 --> 01:15:43,170
you know hopefully there's a little clear,

1206
01:15:43,170 --> 01:15:45,660
there's some attractive properties to approach 2,

1207
01:15:45,990 --> 01:15:47,610
in the sense that,

1208
01:15:47,940 --> 01:15:50,250
you can get scalable read performance,

1209
01:15:50,370 --> 01:15:52,530
on the primary backups,

1210
01:15:52,830 --> 01:15:54,510
of course not on the configuration server,

1211
01:15:54,510 --> 01:15:56,850
because it runs Raft,

1212
01:15:56,850 --> 01:15:58,620
like you know you're doing approach 1,

1213
01:15:58,950 --> 01:16:00,300
but you can at least you know,

1214
01:16:00,300 --> 01:16:03,990
maybe scale read performance for actual operations on the replicas

1215
01:16:03,990 --> 01:16:06,240
or on the primary backup scheme,

1216
01:16:06,270 --> 01:16:07,470
put and get operations.

1217
01:16:08,270 --> 01:16:12,290
The other thing that is nice about this is that,

1218
01:16:12,770 --> 01:16:15,710
the if you have data is very very large,

1219
01:16:15,740 --> 01:16:20,600
you know you can have more specialized synchronization

1220
01:16:20,600 --> 01:16:25,580
or scheme to basically copy the state from one machine to another machine.

1221
01:16:26,180 --> 01:16:30,650
And you know the chain replication or when any sort of primary backup schemes,

1222
01:16:30,650 --> 01:16:32,360
sort of separated from the configuration server,

1223
01:16:32,390 --> 01:16:33,710
allows you to do that easily.

1224
01:16:34,500 --> 01:16:36,000
And so it's quite common,

1225
01:16:36,000 --> 01:16:39,360
that you know the practice you know people for approach 2,

1226
01:16:39,600 --> 01:16:41,760
although it is also not impossible

1227
01:16:41,760 --> 01:16:46,710
to actually use approach 1 for your replicated state machine,

1228
01:16:46,710 --> 01:16:51,330
including serving operations like put get operations,

1229
01:16:51,330 --> 01:16:53,220
and in fact, the lab 3 would do it,

1230
01:16:53,220 --> 01:16:57,090
we will see later paper in this semester Spanner,

1231
01:16:57,150 --> 01:17:00,780
and that actually uses Paxos to actually also do the operations.

1232
01:17:03,780 --> 01:17:05,010
Any further questions here?

1233
01:17:14,710 --> 01:17:15,220
If not,

1234
01:17:15,220 --> 01:17:18,340
then I wish you all good luck on the mid-term on Thursday,

1235
01:17:18,610 --> 01:17:23,260
and I'll see you in person, well, virtually in person next week.

1236
01:17:28,780 --> 01:17:29,950
And if you have any questions,

1237
01:17:30,100 --> 01:17:32,110
please feel free to hang around,

1238
01:17:32,560 --> 01:17:35,500
and I'll do my best to answer them.

1239
01:17:36,520 --> 01:17:41,740
I have a question about something that you mentioned about Raft,

1240
01:17:41,740 --> 01:17:45,730
so you mentioned that all the reads have to go through the majority of servers,

1241
01:17:45,880 --> 01:17:47,710
but I'm not quite sure I understand why,

1242
01:17:47,710 --> 01:17:51,940
because the leader has all of the committed entries, right.

1243
01:17:51,940 --> 01:17:53,590
Yeah, there's two two schemes,

1244
01:17:53,620 --> 01:17:56,350
if the leader,

1245
01:17:56,470 --> 01:17:58,360
so either you run into a situation,

1246
01:17:58,360 --> 01:18:01,860
where all recent writes are served by the leader, right,

1247
01:18:02,440 --> 01:18:05,200
or you know there's a possibility to serve from principle

1248
01:18:05,200 --> 01:18:07,060
and read operation from another peer,

1249
01:18:07,060 --> 01:18:10,960
but then you have to contact first majority of the servers

1250
01:18:10,960 --> 01:18:13,180
to make actually majority that you have the last operation.

1251
01:18:14,990 --> 01:18:15,410
Got it,

1252
01:18:15,410 --> 01:18:17,270
so that that requirement is,

1253
01:18:17,270 --> 01:18:21,230
if we want to spread all the reads across every peer.

1254
01:18:21,230 --> 01:18:23,000
We have to be more sophisticated

1255
01:18:23,240 --> 01:18:25,220
and we cannot do it on our own,

1256
01:18:25,220 --> 01:18:27,260
because that would definitely break linearizability.

1257
01:18:28,450 --> 01:18:30,400
Right, but if everything goes to the leader.

1258
01:18:30,640 --> 01:18:32,560
Then when you're going there, correct,

1259
01:18:32,560 --> 01:18:34,300
except you have to do this trick,

1260
01:18:34,300 --> 01:18:37,210
where you ask for an empty agreement,

1261
01:18:37,210 --> 01:18:39,340
at the beginning of every new term,

1262
01:18:41,120 --> 01:18:43,040
just to make sure that you actually are up to date.

1263
01:18:45,710 --> 01:18:46,760
Okay, thank you.

1264
01:18:48,130 --> 01:18:50,890
Could you, quickly go over again,

1265
01:18:51,010 --> 01:18:53,620
when you're adding a new server at the tail,

1266
01:18:54,360 --> 01:18:56,610
so just to make sure I understand,

1267
01:18:56,610 --> 01:18:59,400
so essentially it starts this process

1268
01:18:59,400 --> 01:19:01,860
for copying all the data from S2 to S3

1269
01:19:02,430 --> 01:19:05,340
and then if it receives requests for any of that data,

1270
01:19:05,340 --> 01:19:08,030
while that is still happening,

1271
01:19:08,030 --> 01:19:12,710
then S3 is going to ask S2 for anything that it still has directly,

1272
01:19:12,710 --> 01:19:14,330
and it's going to get it and then respond.

1273
01:19:14,600 --> 01:19:15,080
Yep.

1274
01:19:15,600 --> 01:19:16,620
And then it keeps doing that,

1275
01:19:16,620 --> 01:19:19,590
until it gets data that S2 no longer has,

1276
01:19:19,590 --> 01:19:21,210
and then it just goes live essentially.

1277
01:19:21,540 --> 01:19:23,310
Yeah, or you could do slightly differently,

1278
01:19:23,310 --> 01:19:29,610
you know you could actually have S3 could basically tell S2,

1279
01:19:31,820 --> 01:19:35,630
S3 can become the leader, oh, sorry, the tail,

1280
01:19:35,660 --> 01:19:40,310
and basically don't process any common operations from the client yet,

1281
01:19:40,310 --> 01:19:44,450
until it actually has has received the remaining operations from S2.

1282
01:19:47,140 --> 01:19:49,690
Oh, so in that case, S2 is still the tail.

1283
01:19:50,970 --> 01:19:51,870
Yeah.

1284
01:19:51,870 --> 01:19:53,490
Until S3 gets everything.

1285
01:19:53,730 --> 01:19:54,180
Yeah.

1286
01:19:56,910 --> 01:20:00,180
Basically, the paper describes one particular way of doing it,

1287
01:20:00,180 --> 01:20:01,620
you know there's a couple ways of doing it.

1288
01:20:04,000 --> 01:20:05,710
But if you do that then,

1289
01:20:06,430 --> 01:20:11,260
like how long do you wait to get everything,

1290
01:20:13,140 --> 01:20:15,570
I think I also had the same confusion as someone else.

1291
01:20:15,570 --> 01:20:18,690
You know, you know in what order the switch is happening, correct,

1292
01:20:18,690 --> 01:20:24,840
so for example like S3, so S2 let's say maybe has a big operations through hundreds,

1293
01:20:25,460 --> 01:20:26,870
you start to copy operations,

1294
01:20:26,870 --> 01:20:28,700
like with snapshots with a Raft,

1295
01:20:28,970 --> 01:20:30,320
you start the copy operation,

1296
01:20:30,320 --> 01:20:31,880
so when the copy operation is done,

1297
01:20:31,880 --> 01:20:34,900
S3 is up to data until hundred, right,

1298
01:20:36,390 --> 01:20:39,900
then you know maybe S2 already has 10 more operations,

1299
01:20:39,930 --> 01:20:43,530
so it has 101 102 and 103, right,

1300
01:20:44,220 --> 01:20:48,240
and basically S3 can you know contact S2,

1301
01:20:48,240 --> 01:20:50,520
say give me your remaining operations,

1302
01:20:50,520 --> 01:20:53,850
and S2 says, like well remaining operations 101 to 110,

1303
01:20:55,000 --> 01:20:56,770
and as a side effect,

1304
01:20:56,770 --> 01:21:00,460
you know S3 also tells S2 like stop being the tail,

1305
01:21:01,540 --> 01:21:04,900
and S2 response with those operations,

1306
01:21:05,140 --> 01:21:08,740
S3 applies there operation 101 to 110,

1307
01:21:08,890 --> 01:21:12,190
and then tells client it means it is tail,

1308
01:21:12,190 --> 01:21:14,500
but it doesn't process any commands from clients yet

1309
01:21:14,770 --> 01:21:16,060
or read operation from client yet,

1310
01:21:16,060 --> 01:21:18,400
until it actually process 101 to 110.

1311
01:21:21,380 --> 01:21:25,620
Okay, okay, I see, I see, okay, understand.

1312
01:21:26,850 --> 01:21:28,410
I have another question,

1313
01:21:29,280 --> 01:21:29,970
oh sorry.

1314
01:21:31,560 --> 01:21:32,730
No, go ahead, go ahead.

1315
01:21:33,000 --> 01:21:39,900
Okay, my question was a little similar to the extension that he talked about,

1316
01:21:40,660 --> 01:21:42,640
I thought, I thought about,

1317
01:21:42,790 --> 01:21:46,990
could you could you do a tree instead of a chain, so.

1318
01:21:47,630 --> 01:21:51,500
I think there's the,

1319
01:21:52,100 --> 01:21:54,290
there's other data structures possible,

1320
01:21:54,320 --> 01:21:58,340
like for example, you know number of people in email proposed,

1321
01:21:58,520 --> 01:22:00,020
that you could have S1,

1322
01:22:00,140 --> 01:22:04,010
then you could have like S3 4 5, all the intermediate ones,

1323
01:22:04,010 --> 01:22:07,430
you know S1 talks to them in parallel to all the intermediate ones

1324
01:22:07,430 --> 01:22:11,810
and the intermediate ones talk all to the tail,

1325
01:22:12,320 --> 01:22:14,810
is that what you mean with a tree?

1326
01:22:15,080 --> 01:22:20,210
I meant more if there would be,

1327
01:22:20,780 --> 01:22:23,230
like a number of leaves,

1328
01:22:23,230 --> 01:22:26,230
there would be at all roughly the same height,

1329
01:22:26,260 --> 01:22:27,580
so like a balanced tree,

1330
01:22:27,790 --> 01:22:31,840
and then the leaves will have like a chain going through them,

1331
01:22:33,400 --> 01:22:39,370
and I think the linearizability can be broken here,

1332
01:22:39,430 --> 01:22:43,360
if you like, oh, if you'd think harder about it,

1333
01:22:43,360 --> 01:22:45,910
but it would have the nice property,

1334
01:22:45,910 --> 01:22:46,960
that you wouldn't,

1335
01:22:46,990 --> 01:22:51,960
like the the propagation can delay would be like [logarithmic]

1336
01:22:51,990 --> 01:22:53,850
instead of linear as here,

1337
01:22:53,850 --> 01:22:55,380
and you could read from all the leaves.

1338
01:22:55,380 --> 01:22:58,290
Yeah, okay, reading from all the leaves is dangerous, right,

1339
01:22:58,290 --> 01:23:00,240
because they might have,

1340
01:23:00,270 --> 01:23:04,050
you know one client might have talked to another leaf earlier

1341
01:23:04,080 --> 01:23:05,910
and leaves might not be in sync,

1342
01:23:06,770 --> 01:23:11,240
so that sounds dangerous to me,

1343
01:23:11,240 --> 01:23:14,870
maybe your your scheme is a little bit more sophisticated than I'm thinking,

1344
01:23:15,470 --> 01:23:18,920
the depth of the tree or the depth of the chain

1345
01:23:18,920 --> 01:23:23,270
really govern by the meantime between failure, right,

1346
01:23:23,890 --> 01:23:25,780
if you're on the,

1347
01:23:26,020 --> 01:23:28,600
if you typically run with 3 servers, 3 to 5 servers,

1348
01:23:28,600 --> 01:23:32,080
because that's good enough for your high availability,

1349
01:23:32,200 --> 01:23:35,740
then because you can recover from 4 servers,

1350
01:23:35,740 --> 01:23:37,390
before the whole thing is done,

1351
01:23:37,780 --> 01:23:42,640
then that really covers the depth of the chain,

1352
01:23:43,260 --> 01:23:46,260
and yeah we'll introduce some latency.

1353
01:23:49,770 --> 01:23:51,630
Okay, that make sence, thank you.

1354
01:23:51,630 --> 01:23:53,280
Chain will generally be short.

1355
01:23:53,930 --> 01:23:56,780
Okay, okay, that makes sense, thanks.

1356
01:23:57,260 --> 01:23:57,740
You're welcome.

1357
01:23:59,030 --> 01:24:02,030
Is this the only case where the entire chain would go down,

1358
01:24:02,580 --> 01:24:04,920
if all the servers in the chain went down?

1359
01:24:05,190 --> 01:24:05,610
Yeah.

1360
01:24:07,370 --> 01:24:07,820
Thank you.

1361
01:24:09,640 --> 01:24:14,050
I also was curious how you know maintain the strong consistency,

1362
01:24:14,050 --> 01:24:19,750
when like S1 S2 and S3 can all do the read in this slide.

1363
01:24:21,340 --> 01:24:25,990
You get strong consistency per per shard or per object,

1364
01:24:25,990 --> 01:24:27,670
you know that's assigned to the chain, right.

1365
01:24:28,520 --> 01:24:32,570
So if here read, you write one object,

1366
01:24:32,780 --> 01:24:35,060
you write object one, you read object one,

1367
01:24:35,210 --> 01:24:37,280
all those operations are going to go through the same chain,

1368
01:24:37,280 --> 01:24:40,070
and so you get strong consistency for that particular object.

1369
01:24:40,610 --> 01:24:41,810
Oh, got it.

1370
01:24:41,900 --> 01:24:42,860
But it may not be the case,

1371
01:24:43,280 --> 01:24:45,560
across all the objects, we have strong consistency.

1372
01:24:45,770 --> 01:24:52,340
No, I don't, I will, let me hesitate that.

1373
01:24:57,270 --> 01:24:57,900
Let me hesitate,

1374
01:24:57,900 --> 01:25:00,630
I think you know that requires maybe more machinery.

1375
01:25:00,990 --> 01:25:02,310
Well, what does that mean,

1376
01:25:02,340 --> 01:25:05,130
like across all the objects getting strong consistency.

1377
01:25:05,220 --> 01:25:08,460
I think, the you read write object one,

1378
01:25:08,910 --> 01:25:10,590
you read or write object two,

1379
01:25:11,150 --> 01:25:14,810
and then some client read object one,

1380
01:25:15,620 --> 01:25:17,300
are you going to yet,

1381
01:25:18,210 --> 01:25:20,730
basically you know if you have a client to read both objects,

1382
01:25:20,730 --> 01:25:24,300
are you are guaranteed to see total order and linearizability.

1383
01:25:24,300 --> 01:25:26,310
Is that like serializability?

1384
01:25:27,030 --> 01:25:28,890
Serializability slightly different,

1385
01:25:28,950 --> 01:25:31,860
you know maybe, let's not talk about serializability,

1386
01:25:31,860 --> 01:25:34,230
we'll come back, we'll get that later in a couple weeks.

1387
01:25:34,680 --> 01:25:36,510
Yeah, and.

1388
01:25:40,740 --> 01:25:43,290
I [] to actually make a commitment right now,

1389
01:25:43,500 --> 01:25:44,940
I need to think a little bit about it.

1390
01:25:45,300 --> 01:25:46,290
Okay, that's totally fair.

1391
01:25:48,280 --> 01:25:50,170
So the question is like,

1392
01:25:50,440 --> 01:25:54,880
you know you have consistency or linearizability for a single client reading and writing,

1393
01:25:55,210 --> 01:25:58,450
but not for multiple, on multiple objects.

1394
01:25:58,630 --> 01:26:01,930
You have even multiple clients talking to this,

1395
01:26:01,930 --> 01:26:04,510
you know are doing operations on the same object,

1396
01:26:04,510 --> 01:26:07,060
have strongly linearizability correct in this scheme,

1397
01:26:07,420 --> 01:26:08,410
the question is,

1398
01:26:08,470 --> 01:26:12,040
we have linearizability across objects too.

1399
01:26:13,410 --> 01:26:15,540
But, why is that important

1400
01:26:15,960 --> 01:26:20,040
and I don't see where like where that would be important like,

1401
01:26:21,600 --> 01:26:28,060
because you, you gonna like, you can't group operations, right,

1402
01:26:28,180 --> 01:26:30,850
so like a write and a write.

1403
01:26:31,000 --> 01:26:32,740
I mean you read object one,

1404
01:26:32,740 --> 01:26:34,510
you write object one, you read object one,

1405
01:26:34,510 --> 01:26:36,730
you read object two, you write object two,

1406
01:26:37,030 --> 01:26:41,600
and you know the, the question is,

1407
01:26:41,600 --> 01:26:45,410
you know in linearizability, you know those operations need to be total order,

1408
01:26:45,740 --> 01:26:51,020
and they need to preserve this property of real time.

1409
01:26:52,740 --> 01:26:54,540
And since you have different chains,

1410
01:26:54,540 --> 01:26:56,280
that might actually not happen,

1411
01:26:56,280 --> 01:26:58,170
but I don't want to commit to,

1412
01:26:58,200 --> 01:27:00,900
no [statement] about all across chains.

1413
01:27:01,380 --> 01:27:04,020
You know with the chain is actually guaranteed to linearizability,

1414
01:27:04,020 --> 01:27:05,370
even if you have different objects.

1415
01:27:08,290 --> 01:27:09,970
There's something I don't understand in the paper,

1416
01:27:09,970 --> 01:27:13,330
which is the update propagation invariant,

1417
01:27:14,110 --> 01:27:17,170
where like sort of the,

1418
01:27:17,760 --> 01:27:20,820
for in this order of the chain.

1419
01:27:21,030 --> 01:27:21,570
Yep.

1420
01:27:21,630 --> 01:27:27,630
The like commits are prefix of each successor's commits,

1421
01:27:28,920 --> 01:27:33,870
is that guaranteed after like a full pass has gone through the chain?

1422
01:27:34,620 --> 01:27:35,700
No, it's always true, right,

1423
01:27:35,700 --> 01:27:38,070
like you know you go back to this picture here,

1424
01:27:42,020 --> 01:27:44,390
I think they make a very simple observation,

1425
01:27:44,390 --> 01:27:46,580
which is, let's see if we can find that picture,

1426
01:27:47,960 --> 01:27:49,670
I probably scribbled over everything,

1427
01:27:49,670 --> 01:27:52,250
so it's gonna be maybe not as clean,

1428
01:27:52,730 --> 01:27:54,140
basically what they're saying,

1429
01:27:54,140 --> 01:27:55,700
like if you look at this figure, correct,

1430
01:27:55,970 --> 01:28:00,240
that S3 always has a prefix of S2

1431
01:28:00,240 --> 01:28:02,070
and S2 always has a prefix of S1,

1432
01:28:05,960 --> 01:28:08,840
and that's the only thing that basically that's invariant says.

1433
01:28:09,440 --> 01:28:13,180
Oh, so i and j,

1434
01:28:13,210 --> 01:28:16,630
so the one out the successor has the prefix of the predecessor?

1435
01:28:16,660 --> 01:28:18,820
Yeah, and this is slightly confusing,

1436
01:28:18,820 --> 01:28:20,020
I just realized that later,

1437
01:28:20,020 --> 01:28:22,360
after somebody else asked this question,

1438
01:28:22,720 --> 01:28:28,960
in the definition, the i and j is in two different ways,

1439
01:28:29,020 --> 01:28:30,430
well, not really different ways,

1440
01:28:30,430 --> 01:28:31,630
one is definition,

1441
01:28:32,100 --> 01:28:35,460
and one is actually the invariant,

1442
01:28:36,030 --> 01:28:38,970
and you're gonna be a little careful,

1443
01:28:39,060 --> 01:28:42,630
the role of i and j in the chain.

1444
01:28:42,630 --> 01:28:43,230
That sort of around.

1445
01:28:43,260 --> 01:28:44,250
Yeah exactly.

1446
01:28:44,250 --> 01:28:45,030
How is that possible.

1447
01:28:45,780 --> 01:28:46,650
Exactly.

1448
01:28:47,140 --> 01:28:47,740
Thank you.

1449
01:28:48,100 --> 01:28:48,670
You're welcome.

1450
01:28:50,060 --> 01:28:51,620
I was, oops.

1451
01:28:52,070 --> 01:28:53,150
Yeah.

1452
01:28:54,390 --> 01:28:55,500
I was just gonna ask,

1453
01:28:55,500 --> 01:28:59,610
what happens when you have a network partition instead of crash,

1454
01:28:59,790 --> 01:29:03,210
so if you go to the crash slide,

1455
01:29:03,610 --> 01:29:04,810
what happens to the chain,

1456
01:29:04,810 --> 01:29:06,100
if there's a network partition,

1457
01:29:06,100 --> 01:29:08,290
so maybe ask something like,

1458
01:29:08,410 --> 01:29:11,200
like S2 is actually still alive,

1459
01:29:11,380 --> 01:29:15,640
but there's a partition between the configuration manager and S2 or something,

1460
01:29:15,880 --> 01:29:18,700
and so now both S1 and S2 are pointing to S3.

1461
01:29:20,130 --> 01:29:23,220
No, no, yeah, yeah,

1462
01:29:23,280 --> 01:29:26,010
okay, there's gonna be some obviously,

1463
01:29:26,010 --> 01:29:28,200
when I I think people are talking about this,

1464
01:29:28,200 --> 01:29:31,800
but I presume that all configurations are numbered, like [] number

1465
01:29:32,100 --> 01:29:35,880
and S3 will not accept any commands from S2,

1466
01:29:35,880 --> 01:29:38,010
if the [] numbers don't match.

1467
01:29:39,560 --> 01:29:40,790
Oh, you got it, thank you.

1468
01:29:41,410 --> 01:29:43,090
So related to that,

1469
01:29:43,090 --> 01:29:44,290
one thing I couldn't figure out is,

1470
01:29:44,290 --> 01:29:47,230
even with like configuration numbers or something,

1471
01:29:47,230 --> 01:29:49,870
how do you make sure that when you get rid of the tail,

1472
01:29:49,870 --> 01:29:51,370
in like the third scenario you drawn,

1473
01:29:51,610 --> 01:29:52,900
when you get rid of the tail,

1474
01:29:52,900 --> 01:29:55,540
that all the clients that might issue a read

1475
01:29:55,780 --> 01:29:57,850
are aware that this old server no longer.

1476
01:29:58,270 --> 01:30:00,940
Clients, I think the way you would do is,

1477
01:30:00,940 --> 01:30:04,990
that the configuration, when the client download the configuration from configuration manager,

1478
01:30:04,990 --> 01:30:06,430
they also include the [] number

1479
01:30:06,670 --> 01:30:08,770
and every operation includes the [] number

1480
01:30:08,770 --> 01:30:13,350
and S3 will say hi, that's an old [] number,

1481
01:30:13,470 --> 01:30:14,520
don't talk to.

1482
01:30:14,850 --> 01:30:19,440
I guess, when the clients talk the configurations over to get [] numbers,

1483
01:30:19,440 --> 01:30:20,820
I'm going to start with is a client,

1484
01:30:21,030 --> 01:30:21,780
that has an old.

1485
01:30:21,780 --> 01:30:26,160
You know, so for example, the S2 could just say retry

1486
01:30:26,490 --> 01:30:30,690
and the client then go back to the configuration server and reread the state.

1487
01:30:32,380 --> 01:30:33,910
I guess what I'm worried about is,

1488
01:30:33,910 --> 01:30:38,680
like S3 has been network partitioned away from from the coordinator,

1489
01:30:38,770 --> 01:30:41,260
and so the coordinator gets rid of S3 from the tail

1490
01:30:41,260 --> 01:30:42,580
and increase the version number,

1491
01:30:42,850 --> 01:30:46,150
but some client out there doesn't find out that the version numbers increase

1492
01:30:46,210 --> 01:30:47,800
and still think S3 is the tail,

1493
01:30:47,830 --> 01:30:49,450
talks to S3 doesn't read,

1494
01:30:49,570 --> 01:30:51,910
meanwhile people are do write to S1 S2,

1495
01:30:51,910 --> 01:30:55,420
and they have haven't seen that basically.

1496
01:30:55,800 --> 01:30:59,190
Yeah, this is probably the reason why the paper go through the proxy.

1497
01:31:01,870 --> 01:31:05,250
I see, okay.

1498
01:31:07,460 --> 01:31:10,160
I have a question kind of going back to that,

1499
01:31:10,520 --> 01:31:12,530
like unanswered questions about,

1500
01:31:13,600 --> 01:31:16,750
kind of like cross object linearizability,

1501
01:31:16,990 --> 01:31:19,180
I guess like,

1502
01:31:20,440 --> 01:31:23,830
is that a whole other can of [] that we haven't really talked about,

1503
01:31:23,830 --> 01:31:25,510
which is like if you want to do,

1504
01:31:25,540 --> 01:31:26,500
I don't know what the right term is,

1505
01:31:26,500 --> 01:31:31,780
but like transactions, that like cross multiple pieces of state,

1506
01:31:31,780 --> 01:31:34,860
like, if you're trying to implement an operation,

1507
01:31:34,860 --> 01:31:37,110
where it's like you're setting a to 1 and b to 2

1508
01:31:37,110 --> 01:31:39,660
and you should only see those together or not at all,

1509
01:31:39,660 --> 01:31:40,890
like [] of that,

1510
01:31:40,920 --> 01:31:44,100
have we talked about that in any of the things we've seen before.

1511
01:31:44,220 --> 01:31:46,200
No and we'll talk about a couple weeks,

1512
01:31:47,040 --> 01:31:48,450
it going to be a big topic,

1513
01:31:48,570 --> 01:31:50,250
basically how to do transactions.

1514
01:31:50,740 --> 01:31:53,140
Okay, that's good to know, thanks.

1515
01:31:54,980 --> 01:31:57,260
You mind going back to like the third slide?

1516
01:31:58,100 --> 01:31:58,580
Yep.

1517
01:32:00,050 --> 01:32:01,430
I can go to the third slide,

1518
01:32:03,580 --> 01:32:05,620
maybe not, fourth slide,

1519
01:32:09,110 --> 01:32:11,210
oh, it's fifth slide, sorry,

1520
01:32:12,410 --> 01:32:13,940
so I was a little bit confused,

1521
01:32:13,970 --> 01:32:17,570
when you mention like if lock holder failed intermediate stage stuff,

1522
01:32:17,840 --> 01:32:21,470
what exactly on this slide applies to zlocks,

1523
01:32:21,470 --> 01:32:23,090
and what applies to the Go locks again.

1524
01:32:24,160 --> 01:32:27,640
The these almost all statements about zlocks.

1525
01:32:29,760 --> 01:32:32,730
So is the first statement, that if the lock holder fails,

1526
01:32:32,730 --> 01:32:36,180
then the intermediate state is not cleaned up, or is cleaned up.

1527
01:32:36,270 --> 01:32:39,270
No, intermediate state is visible,

1528
01:32:39,540 --> 01:32:41,760
but then generally you have a leader election,

1529
01:32:41,760 --> 01:32:43,350
you could clean up the intermediate state,

1530
01:32:43,350 --> 01:32:47,230
that was just like the point.

1531
01:32:47,230 --> 01:32:49,090
Oh, so with with Go locks,

1532
01:32:49,090 --> 01:32:50,410
is that also not the case

1533
01:32:50,410 --> 01:32:52,480
like if there's a machine that's holding a Go lock,

1534
01:32:52,720 --> 01:32:53,650
that's doing stuff,

1535
01:32:53,680 --> 01:32:56,020
and then all of sudden dies,

1536
01:32:56,170 --> 01:32:58,330
isn't still the intermediate state visible.

1537
01:32:59,410 --> 01:33:02,170
Okay, I I think what I'm talking about Go locks,

1538
01:33:02,170 --> 01:33:05,110
you know is something that's a statement about multiple threads

1539
01:33:05,110 --> 01:33:06,700
running on the same machine, right,

1540
01:33:07,000 --> 01:33:10,150
and so if the Go lock disappears,

1541
01:33:10,150 --> 01:33:11,020
because machine crashes,

1542
01:33:11,020 --> 01:33:12,790
all the threads on that machine crash too.

1543
01:33:20,680 --> 01:33:26,740
Right, but, when you say that the intermediate state is visible to other people,

1544
01:33:27,430 --> 01:33:29,620
that's still true for Go locks, right.

1545
01:33:30,640 --> 01:33:34,420
You know if they written persistent state to disk,

1546
01:33:34,420 --> 01:33:36,100
or into some shared file system,

1547
01:33:36,100 --> 01:33:37,210
like no, the machine is gone,

1548
01:33:37,210 --> 01:33:38,590
the disk is gone, everything is gone.

1549
01:33:40,220 --> 01:33:41,390
Oh, got it, okay,

1550
01:33:41,420 --> 01:33:42,260
so it's saying that,

1551
01:33:42,260 --> 01:33:45,980
the like the persistent, like intermediate state persistent.

1552
01:33:46,010 --> 01:33:48,620
Zookeeper intermediate state might be visible,

1553
01:33:48,650 --> 01:33:51,920
we're gonna delete the guy might have created some more files

1554
01:33:51,920 --> 01:33:53,480
and those are visible now.

1555
01:33:54,550 --> 01:33:56,320
Okay I see, thank you.

1556
01:33:56,740 --> 01:33:58,390
So just follow that,

1557
01:33:58,390 --> 01:34:03,520
since the implementation that if a goroutine ever dies while holding the lock,

1558
01:34:04,100 --> 01:34:06,260
the entire Go program must have died too.

1559
01:34:07,820 --> 01:34:10,880
And as you can never have a goroutine die holding a lock with that,

1560
01:34:10,970 --> 01:34:13,220
and have other parts of the program continuously.

1561
01:34:14,000 --> 01:34:14,330
Okay.

1562
01:34:15,070 --> 01:34:17,230
The goroutine crashes, the application crashes.

