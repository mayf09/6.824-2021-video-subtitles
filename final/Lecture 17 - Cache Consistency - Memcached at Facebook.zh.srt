1
00:00:00,210 --> 00:00:03,450
所以今天我想讨论一下 memcache ，

2
00:00:03,450 --> 00:00:08,100
这是一篇来自 Facebook 的 2013 年的论文，

3
00:00:08,740 --> 00:00:12,820
memcache 在很多网站中使用，

4
00:00:12,820 --> 00:00:15,400
或者大型网站使用的，

5
00:00:15,400 --> 00:00:19,030
与它的想法或架构很相似。

6
00:00:19,420 --> 00:00:22,420
这篇论文是一篇经验论文，

7
00:00:30,200 --> 00:00:31,910
所以，这篇论文的目的并不是

8
00:00:31,910 --> 00:00:38,120
介绍构建系统的新思想，新概念或新的创新方式，

9
00:00:38,120 --> 00:00:43,820
这更多是构建系统的实践经验的总结，

10
00:00:43,820 --> 00:00:45,320
在这种情况下，

11
00:00:45,320 --> 00:00:50,300
可以支持每秒 10 亿个请求或每秒数十亿个请求。

12
00:00:51,070 --> 00:00:54,190
这里有三个经验，

13
00:00:54,220 --> 00:00:57,430
你可以从论文中学到的。

14
00:01:01,060 --> 00:01:05,170
一是他们获得了令人印象深刻的性能，

15
00:01:05,650 --> 00:01:11,560
使用现成组件构建的系统，

16
00:01:16,300 --> 00:01:20,140
系统由标准的开放软件组成，

17
00:01:20,140 --> 00:01:22,660
比如 MySQL memcached ，

18
00:01:22,870 --> 00:01:24,580
他们把它们结合在一起，

19
00:01:24,640 --> 00:01:26,740
构建了一个系统，

20
00:01:26,740 --> 00:01:27,910
或者向外扩展了一个系统，

21
00:01:27,910 --> 00:01:30,430
支持每秒 10 亿个请求。

22
00:01:31,030 --> 00:01:34,360
正如你所看到的，正如我们在这节课中所看到的，

23
00:01:34,360 --> 00:01:43,480
在性能和一致性之间有一种持续的紧张关系，

24
00:01:48,760 --> 00:01:50,110
正如你将在这篇论文中看到的，

25
00:01:50,110 --> 00:01:54,040
这个设计主要受性能驱动，

26
00:01:54,040 --> 00:01:59,680
他们想要找到某种程度的一致性，

27
00:01:59,680 --> 00:02:01,540
某种程度上增加，

28
00:02:01,540 --> 00:02:06,490
使系统至少对 Facebook 使用的应用可用，

29
00:02:06,700 --> 00:02:09,490
事实上，这里的一致性模型

30
00:02:09,490 --> 00:02:12,520
与我们以前看到的一致性模型有很大不同，

31
00:02:12,610 --> 00:02:15,250
我们到目前为止讨论的大多数系统

32
00:02:15,250 --> 00:02:18,910
要么提供外部一致性，要么提供线性一致性，

33
00:02:19,180 --> 00:02:21,850
它们在一致性方面非常强大，

34
00:02:22,030 --> 00:02:24,310
在 Facebook 的案例中，

35
00:02:25,000 --> 00:02:28,870
它们的应用程序并不真正需要线性一致性，

36
00:02:28,870 --> 00:02:31,540
如果用户阅读新闻文章，

37
00:02:31,720 --> 00:02:34,360
而新闻消息落后了几秒钟，

38
00:02:34,450 --> 00:02:35,530
这真的不重要，

39
00:02:35,800 --> 00:02:38,950
所以，它们的目标不是

40
00:02:38,950 --> 00:02:43,420
提供某种线性一致性或严格的一致性，

41
00:02:44,360 --> 00:02:46,880
所以，这是一件需要记住的重要事情。

42
00:02:48,150 --> 00:02:51,390
尽管他们不是在追求强一致性，

43
00:02:51,420 --> 00:02:55,810
在论文中仍然有一些警示故事，

44
00:02:55,810 --> 00:03:01,120
添加一致性度量并不容易，

45
00:03:01,120 --> 00:03:05,530
你不需要，为它的开始做好准备，

46
00:03:06,380 --> 00:03:12,440
但无论如何，你不能对这个系统的成功提出异议，

47
00:03:12,560 --> 00:03:15,020
它真的非常成功，

48
00:03:15,380 --> 00:03:20,000
允许 Facebook 网站的跟随者，

49
00:03:20,030 --> 00:03:21,680
有很多使用相同策略，

50
00:03:21,830 --> 00:03:24,710
能够扩大大量的用户。

51
00:03:28,260 --> 00:03:31,260
所以我这次课程的计划是先谈谈性能，

52
00:03:31,260 --> 00:03:34,950
因为性能才是这个设计背后的驱动力，

53
00:03:35,190 --> 00:03:38,670
然后在最后更多地谈论一致性。

54
00:03:39,690 --> 00:03:41,310
在开始之前，

55
00:03:41,430 --> 00:03:43,530
有什么问题吗？

56
00:03:50,010 --> 00:03:55,620
好的，让我从[]性能介绍开始，

57
00:03:55,740 --> 00:03:59,580
谈谈网站的演变。

58
00:04:05,930 --> 00:04:08,960
我相信你们中的许多人建立过网站，

59
00:04:09,410 --> 00:04:11,420
如果你一开始，

60
00:04:11,420 --> 00:04:12,620
你没有任何用户，

61
00:04:12,620 --> 00:04:13,910
这很简单，

62
00:04:15,410 --> 00:04:18,830
在 Amazon 或其他任何地方购买或运行一台机器，

63
00:04:19,070 --> 00:04:21,980
你基本上只需要三个组件，

64
00:04:21,980 --> 00:04:25,280
你需要网络服务器，比如 Apache ，

65
00:04:27,230 --> 00:04:31,820
你需要一个应用程序框架来构建你的网站，

66
00:04:32,090 --> 00:04:34,430
可能是 PHP ，可能是 Python ，

67
00:04:34,430 --> 00:04:38,990
在 Facebook 的情况下，我想他们使用的是 PHP ，

68
00:04:39,770 --> 00:04:45,070
你需要一个数据库来存储你网站的数据，

69
00:04:45,340 --> 00:04:47,680
比如使用 MySQL ，

70
00:04:48,850 --> 00:04:49,450
这是 FaceBook 所使用的。

71
00:04:50,960 --> 00:04:54,050
客户端连接到你的网站，

72
00:04:54,110 --> 00:04:57,980
运行应用程序代码，

73
00:04:58,010 --> 00:05:01,310
或者网站提供的任何应用程序服务，

74
00:05:01,610 --> 00:05:05,440
并使用数据库存储和查找数据，

75
00:05:05,440 --> 00:05:07,840
数据库提供事务，

76
00:05:07,990 --> 00:05:10,000
它有 SQL ，

77
00:05:10,000 --> 00:05:15,070
所以，它可以很容易地以不同的方式查询数据，

78
00:05:15,070 --> 00:05:17,710
所有持久化状态都存储在数据库中，

79
00:05:17,710 --> 00:05:19,750
为了备份数据库，

80
00:05:19,750 --> 00:05:23,020
你会有一个很好的容错方案。

81
00:05:23,830 --> 00:05:26,650
这在某种程度上，对于任何网站来说，

82
00:05:26,650 --> 00:05:29,140
对于少量的用户是完全足够的，

83
00:05:29,260 --> 00:05:32,350
许多网站的构建方式，

84
00:05:32,470 --> 00:05:36,790
但是当用户数量增加的时候，

85
00:05:36,880 --> 00:05:40,060
你可能需要进行更复杂的设计。

86
00:05:40,710 --> 00:05:43,050
所以这是演化的第一步。

87
00:05:43,260 --> 00:05:45,150
在第二步中，

88
00:05:50,990 --> 00:05:54,410
为了解决我们面临的第一个瓶颈问题，

89
00:05:54,560 --> 00:05:56,480
当你的用户数量较多时，

90
00:05:56,480 --> 00:05:58,940
通常你遇到的瓶颈，

91
00:05:59,120 --> 00:06:02,990
是应用程序使用的计算周期，

92
00:06:02,990 --> 00:06:06,380
如果你有数千名用户同时在网站上运行，

93
00:06:06,650 --> 00:06:09,710
或 10,000 或任何数量的用户，

94
00:06:09,710 --> 00:06:12,800
运行应用程序代码

95
00:06:12,980 --> 00:06:15,320
在单个 CPU 或单个计算机上，

96
00:06:15,440 --> 00:06:21,710
导致 CPU 负载到 200% ，

97
00:06:21,710 --> 00:06:23,270
你就不能支持更多了。

98
00:06:23,940 --> 00:06:27,600
幸运的是，这很容易解决，

99
00:06:27,810 --> 00:06:31,290
因为数据库具有所有持久状态，

100
00:06:31,830 --> 00:06:33,870
所以通常你解决这个问题的方法是，

101
00:06:33,870 --> 00:06:36,750
你保持一台机器运行数据库，

102
00:06:36,750 --> 00:06:38,070
保持数据库机器，

103
00:06:38,280 --> 00:06:41,070
然后为前端买一些机器，

104
00:06:41,100 --> 00:06:43,350
我说的到前端，是一种东西，

105
00:06:43,710 --> 00:06:49,320
网站、 Apache 加上一些应用程序代码，

106
00:06:49,320 --> 00:06:53,070
如果你有更多的用户，你买更多的机器，

107
00:07:00,350 --> 00:07:03,290
它们都连接到数据库来获取数据，

108
00:07:03,530 --> 00:07:08,300
实际上，这个设计效果非常好，

109
00:07:08,330 --> 00:07:12,970
因为前端是无状态的，

110
00:07:13,210 --> 00:07:15,460
所有这些数据都在数据库里，

111
00:07:15,790 --> 00:07:18,820
添加一台新服务器是微不足道的，

112
00:07:18,940 --> 00:07:22,420
所有前端都会看到最新的写入，

113
00:07:22,420 --> 00:07:24,520
因为所有数据都存储在数据库中，

114
00:07:24,610 --> 00:07:26,140
所以不存在一致性问题，

115
00:07:26,470 --> 00:07:28,120
在容错方面很容易，

116
00:07:28,120 --> 00:07:29,500
如果其中一台机器出现故障，

117
00:07:29,500 --> 00:07:30,670
完全没有问题，

118
00:07:30,910 --> 00:07:34,180
可能机器必须接管负载，

119
00:07:34,420 --> 00:07:36,640
或者你必须起一台机器给前端，

120
00:07:36,640 --> 00:07:38,290
但是你不需要做任何事情，

121
00:07:38,290 --> 00:07:43,240
在复杂的数据恢复方面，

122
00:07:43,240 --> 00:07:45,280
因为所有数据都在数据库中。

123
00:07:46,540 --> 00:07:47,590
所以这是，

124
00:07:47,590 --> 00:07:51,010
好的，发生的第一件事，

125
00:07:51,280 --> 00:07:53,170
随着网站规模发展。

126
00:07:55,340 --> 00:07:59,480
当然，随着你的网站规模进一步扩大，

127
00:07:59,840 --> 00:08:03,350
你需要支持超过，

128
00:08:03,350 --> 00:08:06,410
比如，一个简单的 MySQL 设置

129
00:08:06,410 --> 00:08:13,100
可能支持每秒十万的简单读事务或简单读查询，

130
00:08:13,580 --> 00:08:17,330
可能支持上千的写事务，

131
00:08:17,570 --> 00:08:23,300
如果来自你的用户的请求总数超过十万，

132
00:08:23,680 --> 00:08:25,720
然后，你需要一个不同的方案。

133
00:08:26,530 --> 00:08:30,130
所以，下一个方案是分片。

134
00:08:38,270 --> 00:08:41,360
到目前为止，这一切都是相当标准的，

135
00:08:41,360 --> 00:08:42,380
所以你要做的是，

136
00:08:42,380 --> 00:08:46,790
把存储机器分为多台机器，

137
00:08:49,730 --> 00:08:51,530
前端保持不变，

138
00:08:51,530 --> 00:08:54,500
我们仍然有很多前端机器，

139
00:09:02,070 --> 00:09:05,670
这里我们有分片数据库，

140
00:09:07,940 --> 00:09:11,600
一些键位于，

141
00:09:11,600 --> 00:09:17,060
可能 1 到 40 位于分片 1 ，

142
00:09:17,150 --> 00:09:21,500
可能 40 到 70 位于分片 2 ，

143
00:09:21,500 --> 00:09:25,700
进一步， 70 到 100 位于分片 3 ，

144
00:09:25,700 --> 00:09:29,840
你获取数据库中的表或数据库中的行，

145
00:09:29,840 --> 00:09:31,430
并按键进行分片。

146
00:09:32,440 --> 00:09:34,750
所以，前端需要知道，

147
00:09:34,750 --> 00:09:36,310
哪个数据库，

148
00:09:36,490 --> 00:09:41,560
它需要获取键 32 ，会去分片 1 ，

149
00:09:41,560 --> 00:09:44,680
它需要获取键 50 ，会去分片 2 。

150
00:09:46,340 --> 00:09:50,240
所以，这为我们提供了数据库并行性，

151
00:09:56,310 --> 00:10:02,580
所以大多数请求都在两个不同分片上，

152
00:10:02,580 --> 00:10:06,510
而不是被一台机器所限制，

153
00:10:06,510 --> 00:10:08,160
我们得到的吞吐量，

154
00:10:08,160 --> 00:10:09,810
一台机器比如是十万，

155
00:10:09,840 --> 00:10:11,850
乘以我们有的机器数量。

156
00:10:13,540 --> 00:10:18,220
所以这是下一步，

157
00:10:18,220 --> 00:10:19,840
当然这是，

158
00:10:19,930 --> 00:10:23,290
这一步比第一步更困难，

159
00:10:23,560 --> 00:10:28,030
因为现在你可能有跨分片事务，

160
00:10:28,150 --> 00:10:28,960
如果你需要它们，

161
00:10:29,350 --> 00:10:30,490
或者如果你想避免它们，

162
00:10:30,490 --> 00:10:35,710
你可以对键分组放在同一台机器上，

163
00:10:35,800 --> 00:10:40,450
否则，你需要一些两阶段提交协议，

164
00:10:40,600 --> 00:10:42,820
如果使用事跨分片事务，

165
00:10:42,820 --> 00:10:47,380
所以，这一步从设计二到设计三，

166
00:10:47,530 --> 00:10:51,040
是非常重要的一步。

167
00:10:54,390 --> 00:10:57,780
现在，如果你扩展更大，

168
00:10:57,960 --> 00:10:59,070
你可能会说，

169
00:10:59,070 --> 00:11:01,590
你可以把数据库分片更多，

170
00:11:01,890 --> 00:11:04,410
每台服务器的键更少，

171
00:11:04,470 --> 00:11:08,160
但这增加了风险，

172
00:11:08,160 --> 00:11:12,000
你必须进行跨分片事务。

173
00:11:12,680 --> 00:11:15,110
还有一条路可以走，

174
00:11:15,110 --> 00:11:17,270
观察到，比如，

175
00:11:17,300 --> 00:11:18,770
也许这并不重要，

176
00:11:18,830 --> 00:11:22,760
数据库支持读取，

177
00:11:22,760 --> 00:11:25,760
我们可以从数据库中卸载读取，

178
00:11:25,970 --> 00:11:28,550
数据库只进行写操作，

179
00:11:28,670 --> 00:11:31,670
那么也许我们可以获得很大的性能提升。

180
00:11:32,380 --> 00:11:37,120
所以，这是网站采取的下一个常见步骤，

181
00:11:37,180 --> 00:11:38,230
如果它们扩展，

182
00:11:38,410 --> 00:11:41,170
添加缓存，

183
00:11:51,660 --> 00:11:54,990
它可以是 memcached 或 redis 的形式，

184
00:11:55,380 --> 00:12:00,000
一种流行的用于缓存的开源软件。

185
00:12:00,390 --> 00:12:02,460
然后基本的计划是，

186
00:12:02,460 --> 00:12:04,800
大致是这样的，

187
00:12:04,800 --> 00:12:07,230
跟前面一样，你有很多前端，

188
00:12:13,720 --> 00:12:16,840
我们在边上有一些缓存，

189
00:12:16,990 --> 00:12:19,570
稍后我们会更详细地讨论这一点，

190
00:12:19,810 --> 00:12:25,180
在这种情况下，我们有缓存层，

191
00:12:26,650 --> 00:12:28,630
缓存 1 ，缓存 2 ，缓存 3 ，

192
00:12:28,810 --> 00:12:31,450
在 Facebook 的案例中，这些被称为，

193
00:12:31,900 --> 00:12:35,050
每个单独的服务器被称为 memcached 守护进程，

194
00:12:35,260 --> 00:12:39,280
整个缓存集群称为 memcache 。

195
00:12:43,520 --> 00:12:45,440
我们的数据库仍然存在，

196
00:12:45,590 --> 00:12:50,930
分片在多台机器上，

197
00:12:52,690 --> 00:12:54,310
这是一个存储层。

198
00:12:57,800 --> 00:13:01,610
所以想法很简单，

199
00:13:01,910 --> 00:13:06,350
如果前端需要读取特定的键，

200
00:13:06,470 --> 00:13:07,910
首先从缓存读取，

201
00:13:10,120 --> 00:13:12,370
希望会命中缓存，

202
00:13:12,370 --> 00:13:17,490
从缓存中得到一个快速的回复，

203
00:13:17,490 --> 00:13:18,750
如果它不在缓存中，

204
00:13:18,750 --> 00:13:22,470
它可以从存储系统中获取数据，

205
00:13:22,650 --> 00:13:25,560
然后把数据安装到缓存中，

206
00:13:26,490 --> 00:13:30,660
写数据会直接发送到存储服务器。

207
00:13:36,440 --> 00:13:39,920
这个设计，

208
00:13:39,950 --> 00:13:41,960
稍后我们将更详细地讨论它，

209
00:13:41,960 --> 00:13:44,330
但是这种带有缓存层的设计

210
00:13:44,420 --> 00:13:46,940
非常适合重读的工作负载，

211
00:13:46,940 --> 00:13:48,680
如果你想一想 Facebook ，

212
00:13:48,830 --> 00:13:51,920
将是很多用户，

213
00:13:52,250 --> 00:13:55,610
他们所做的就是阅读人们的帖子，

214
00:13:55,610 --> 00:13:57,440
查看时间线，

215
00:13:57,440 --> 00:14:00,440
也许查看照片，

216
00:14:00,650 --> 00:14:05,150
阅读新闻、文章等，

217
00:14:05,150 --> 00:14:13,400
所以它是面向读取的繁重的工作负载，

218
00:14:15,050 --> 00:14:17,060
在这种情况下，

219
00:14:17,060 --> 00:14:19,310
读取几乎都是来自缓存的，

220
00:14:19,310 --> 00:14:21,230
这些缓存可能非常简单。

221
00:14:23,410 --> 00:14:27,040
想像一下缓存，

222
00:14:27,040 --> 00:14:29,140
你在实验 3 中构建的键值服务器，

223
00:14:29,320 --> 00:14:32,650
键值服务器本身只是一个哈希表，

224
00:14:32,650 --> 00:14:35,350
也许你想要聪明一点，

225
00:14:35,770 --> 00:14:37,420
对[]加上锁，

226
00:14:37,420 --> 00:14:41,710
所以，你在缓存服务器中有并发性，

227
00:14:41,980 --> 00:14:44,110
或者键值服务器，

228
00:14:44,170 --> 00:14:46,060
但它是相当简单的。

229
00:14:50,160 --> 00:14:54,570
随之而来的是两个挑战，

230
00:14:54,600 --> 00:14:56,550
其中的主要挑战是，

231
00:14:56,730 --> 00:15:03,660
如何保持数据库和缓存的一致性。

232
00:15:09,360 --> 00:15:10,830
这是第一个挑战，

233
00:15:10,920 --> 00:15:15,480
很多论文都致力于谈论这一点。

234
00:15:15,970 --> 00:15:20,320
第二个挑战，

235
00:15:20,590 --> 00:15:22,720
也是这个论文的主题，

236
00:15:22,720 --> 00:15:25,030
如何确保数据库不会超载。

237
00:15:35,970 --> 00:15:38,610
这里的问题是，

238
00:15:38,940 --> 00:15:40,830
一旦你扩展到，

239
00:15:40,830 --> 00:15:45,030
通过使用缓存扩展到例如每秒 10 亿次，

240
00:15:45,030 --> 00:15:46,980
如果任何缓存出现故障，

241
00:15:47,100 --> 00:15:52,080
负载将从前台转移到数据库，

242
00:15:52,470 --> 00:15:56,730
当然，数据库完全不是设计，

243
00:15:56,730 --> 00:15:58,380
来支持这种工作负载，

244
00:15:58,500 --> 00:15:59,760
基本上会倒下。

245
00:16:00,140 --> 00:16:05,360
所以整个课程中的一个关键挑战，

246
00:16:05,360 --> 00:16:07,850
你从这篇论文中学到的，

247
00:16:07,940 --> 00:16:11,600
是避免访问数据库的技术，

248
00:16:11,600 --> 00:16:15,530
所以，没有使数据库过载的风险。

249
00:16:19,520 --> 00:16:21,140
好的，到目前为止，还有其他问题吗？

250
00:16:27,310 --> 00:16:30,040
让我简单地说一下一致性，

251
00:16:30,100 --> 00:16:31,480
因为那会是，

252
00:16:31,480 --> 00:16:33,070
虽然我将主要讨论性能，

253
00:16:33,070 --> 00:16:35,560
记住这一点很重要，

254
00:16:35,560 --> 00:16:38,890
甚至在关于性能的部分。

255
00:16:39,760 --> 00:16:42,130
哦，我有个小问题，抱歉，

256
00:16:42,520 --> 00:16:48,630
回到比如客户端是无状态的，

257
00:16:49,520 --> 00:16:50,630
那么,

258
00:16:50,630 --> 00:16:53,330
是的，在网站解决方案的第二部分，

259
00:16:53,330 --> 00:16:56,390
为什么客户端必须是无状态的？

260
00:16:56,780 --> 00:16:59,180
这使得复制变得很容易，

261
00:16:59,180 --> 00:17:01,610
客户端不用，你不用复制数据，

262
00:17:01,610 --> 00:17:03,110
所以，你不必保持数据的一致性，

263
00:17:04,480 --> 00:17:06,250
所有的数据都在一个地方，

264
00:17:06,880 --> 00:17:08,350
也许这里有一个数据库服务器。

265
00:17:09,300 --> 00:17:11,100
好的，所以这个想法是，

266
00:17:11,100 --> 00:17:14,730
任何客户都可以失败，这并不重要。

267
00:17:14,910 --> 00:17:15,840
是的，这不重要，

268
00:17:15,840 --> 00:17:18,630
继续进行计算，

269
00:17:18,690 --> 00:17:21,690
你不必担心保持数据的一致性，

270
00:17:21,690 --> 00:17:23,130
因为数据只在一个地方，

271
00:17:25,300 --> 00:17:27,490
我们这学期谈到的很多事情，

272
00:17:27,490 --> 00:17:29,680
在这个设计中没有体现出来。

273
00:17:32,820 --> 00:17:33,660
好的?

274
00:17:35,730 --> 00:17:37,860
好了，让我们回到，

275
00:17:37,860 --> 00:17:40,620
一旦你缓存了数据，

276
00:17:40,620 --> 00:17:42,330
你就有了一致性问题，

277
00:17:42,810 --> 00:17:46,650
所以当前的问题是，

278
00:17:46,650 --> 00:17:49,200
Facebook 的目标是什么。

279
00:17:49,770 --> 00:17:52,170
一些东西被称为，

280
00:17:52,170 --> 00:17:54,000
它被称为最终一致性，

281
00:17:54,000 --> 00:17:55,380
这是一个相当模糊的术语，

282
00:17:55,740 --> 00:17:59,460
但是也许是为了对比一下，

283
00:17:59,460 --> 00:18:02,640
可以说，它并不追求线性一致性，

284
00:18:03,480 --> 00:18:07,680
事实上，他们所追求的是，

285
00:18:07,680 --> 00:18:09,720
他们想要按顺序写入，

286
00:18:14,670 --> 00:18:18,300
写入是以某种一致的整体顺序来应用的，

287
00:18:18,300 --> 00:18:21,930
你不会在时间问题上感到奇怪，

288
00:18:22,140 --> 00:18:24,570
这些都是由数据库完成的，

289
00:18:28,180 --> 00:18:33,250
对于 memcache 层来说，这并不是一个大问题。

290
00:18:34,350 --> 00:18:38,670
在读取方面，如果读取落后也没关系，

291
00:18:48,590 --> 00:18:51,080
这就是应用程序的属性，

292
00:18:51,080 --> 00:18:52,760
Facebook 想要支持的应用程序，

293
00:18:53,030 --> 00:18:57,740
再次，这些缓存中的数据，

294
00:18:57,740 --> 00:18:59,630
用户使用的数据，

295
00:18:59,900 --> 00:19:08,290
网页、帖子时间表、朋友列表和所有类似的东西，或状态，

296
00:19:08,410 --> 00:19:13,150
对于用户来说，这些都不是那么重要，

297
00:19:13,150 --> 00:19:16,510
更新你的照片，

298
00:19:16,510 --> 00:19:19,660
它稍微晚了一两秒，

299
00:19:19,660 --> 00:19:20,650
一点问题都没有,

300
00:19:21,070 --> 00:19:23,860
当然会落后几百毫秒的时间，

301
00:19:24,100 --> 00:19:25,540
用户甚至不会注意到，

302
00:19:25,540 --> 00:19:26,980
不会察觉到，

303
00:19:27,400 --> 00:19:29,380
所以落后也没关系，

304
00:19:29,380 --> 00:19:31,720
当然你不想落后几个小时，

305
00:19:31,720 --> 00:19:33,400
用户可能会注意到，

306
00:19:33,610 --> 00:19:35,890
但在一小段时间内落后，

307
00:19:35,890 --> 00:19:37,840
这并不是什么特别大的事情。

308
00:19:38,660 --> 00:19:43,400
所以他们的不是为了线性一致性，

309
00:19:43,400 --> 00:19:45,290
读取观察到最新的写入，

310
00:19:45,500 --> 00:19:48,560
如果[]写入，这是可以的。

311
00:19:49,140 --> 00:19:51,150
但有一个例外，

312
00:19:51,360 --> 00:19:53,610
那就是他们想要安排，

313
00:19:53,610 --> 00:19:56,400
客户端读取自己的写入，

314
00:20:06,760 --> 00:20:13,690
这意味着如果一个客户端更新键 k

315
00:20:13,900 --> 00:20:16,150
然后立即读取键 k ，

316
00:20:16,240 --> 00:20:21,520
非常希望客户端观察自身的写入，

317
00:20:21,610 --> 00:20:24,010
因为这让事情变得更加复杂，

318
00:20:24,010 --> 00:20:26,980
否则，[]可能会更加复杂。

319
00:20:27,670 --> 00:20:29,980
所以，这就是他们要争取的目标，

320
00:20:30,760 --> 00:20:33,850
只是稍微弱了一点，

321
00:20:33,880 --> 00:20:36,190
比我们以前见过的一些模型，

322
00:20:36,490 --> 00:20:40,390
让我想起 Zookeeper ，

323
00:20:40,390 --> 00:20:44,770
可以提供的合约风格。

324
00:20:48,320 --> 00:20:50,690
好的，还有一件事我想说，

325
00:20:50,690 --> 00:20:51,800
往回一点，

326
00:20:52,130 --> 00:20:54,860
我们需要将数据库保存在缓存中，

327
00:20:54,860 --> 00:20:57,170
以某种方式保持缓存一致性。

328
00:20:57,950 --> 00:21:03,020
好的， Facebook 的基本方案是，

329
00:21:05,490 --> 00:21:10,310
是缓存失效方案。

330
00:21:16,780 --> 00:21:20,200
我们会在后面的课程中看到，为什么是这样，

331
00:21:20,260 --> 00:21:23,770
发生的是，如果前端执行写入，

332
00:21:25,650 --> 00:21:28,230
它进入数据库，

333
00:21:30,200 --> 00:21:31,490
这是 MySQL ，

334
00:21:35,000 --> 00:21:39,440
但他们在数据库旁边运行另一个程序，

335
00:21:40,280 --> 00:21:41,690
称为 squeal ，

336
00:21:45,170 --> 00:21:47,900
它会查看事务日志，

337
00:21:48,650 --> 00:21:52,700
MySQL 维护事务日志以实现事务，

338
00:21:52,940 --> 00:21:58,190
squeal 查看这个事务日志，看看什么东西被修改了，

339
00:21:58,430 --> 00:22:04,530
如果有一个键被修改，

340
00:22:04,530 --> 00:22:06,630
它看到键 k 被修改了，

341
00:22:06,690 --> 00:22:09,360
它向缓存发送失效消息，

342
00:22:09,450 --> 00:22:16,010
删除，它只是发送一个删除键 k ，

343
00:22:16,160 --> 00:22:17,750
到合适的缓存，

344
00:22:17,780 --> 00:22:19,850
这样数据将被删除，

345
00:22:20,060 --> 00:22:21,350
然后在之后的某个时候，

346
00:22:22,030 --> 00:22:26,810
当客户端出现，执行读取，

347
00:22:27,380 --> 00:22:32,440
它不会在缓存命中，

348
00:22:32,620 --> 00:22:38,900
读取从这里查找数据，

349
00:22:39,020 --> 00:22:40,340
所以这里是 get ，

350
00:22:40,340 --> 00:22:41,660
让我把这称为 get ，

351
00:22:41,810 --> 00:22:44,390
这里有一个 read ，从 read 获取数据，

352
00:22:44,390 --> 00:22:46,430
然后安装到缓存中。

353
00:22:48,100 --> 00:22:49,450
所以，你可能会想，

354
00:22:49,450 --> 00:22:55,090
为什么应用程序自己将数据安装到缓存中，

355
00:22:55,120 --> 00:22:55,960
所以它执行 put ，

356
00:22:56,860 --> 00:22:59,860
这与这些缓存有关，

357
00:22:59,860 --> 00:23:02,110
他们所说的旁路缓存，

358
00:23:05,090 --> 00:23:06,770
它们是旁路的原因是，

359
00:23:06,770 --> 00:23:08,780
因为通常应用程序所做的，

360
00:23:08,780 --> 00:23:10,970
数据从数据库中读取，实际从数据库中读取的数据，

361
00:23:11,120 --> 00:23:12,470
这有一点[]，

362
00:23:12,470 --> 00:23:13,670
它上面有一些计算，

363
00:23:13,730 --> 00:23:15,920
它将获取页面的文本，

364
00:23:15,920 --> 00:23:19,190
将其转换为 HTML 页面或 HTML5 ，

365
00:23:19,490 --> 00:23:24,320
然后将页面的 HTML 版本的结果存储到缓存中，

366
00:23:24,560 --> 00:23:26,930
或者可能读取很多记录，

367
00:23:26,960 --> 00:23:28,820
聚合一些数据，

368
00:23:28,910 --> 00:23:31,640
并将聚合结果放入缓存中。

369
00:23:32,150 --> 00:23:34,280
所以，应用程序控制，

370
00:23:34,370 --> 00:23:35,930
在这个设计中，

371
00:23:35,960 --> 00:23:37,190
将什么放入缓存中，

372
00:23:37,220 --> 00:23:42,080
这给前端或应用程序增加了负担，

373
00:23:42,080 --> 00:23:43,460
或者在这种情况下，在客户端中，

374
00:23:43,730 --> 00:23:45,800
但它有一个优势，

375
00:23:45,800 --> 00:23:47,990
你可以做一些预处理，

376
00:23:47,990 --> 00:23:50,000
在把东西放入缓存之前。

377
00:23:50,690 --> 00:23:53,000
在这个对比中，缓存是透明的，

378
00:23:53,000 --> 00:23:56,660
缓存位于前端和存储服务器之间，

379
00:23:56,690 --> 00:23:57,770
如果你错过了缓存，

380
00:23:57,770 --> 00:23:58,910
然后缓存将选择数据，

381
00:24:00,130 --> 00:24:01,930
当然，数据库中的缓存

382
00:24:01,930 --> 00:24:04,660
不知道应用程序到底在缓存中存储什么，

383
00:24:04,990 --> 00:24:06,670
所以，在旁路设计中，

384
00:24:06,910 --> 00:24:11,290
是应用程序在控制缓存。

385
00:24:14,540 --> 00:24:15,800
所以更详细一点，

386
00:24:15,800 --> 00:24:18,530
我们可以看看这个图片，

387
00:24:18,530 --> 00:24:22,550
看看读或写是如何实现的。

388
00:24:23,090 --> 00:24:24,140
所以这是读取，

389
00:24:24,970 --> 00:24:28,450
糟糕，抱歉，

390
00:24:39,590 --> 00:24:43,910
这是论文中的图 2 ，

391
00:24:47,230 --> 00:24:49,690
这是我们的网络服务器或客户端，

392
00:24:51,950 --> 00:24:55,820
客户端从 memcache 获取 k ，

393
00:24:55,940 --> 00:24:56,900
我们稍后会看到，

394
00:24:56,900 --> 00:25:00,500
它们通常会请求很多键，

395
00:25:00,500 --> 00:25:01,460
这并不少见，

396
00:25:01,460 --> 00:25:05,720
网络服务器要求 20 到 100 个键，

397
00:25:05,720 --> 00:25:07,880
开始计算一些网页，

398
00:25:07,880 --> 00:25:11,990
网页包含来自许多不同地方的聚合数据，

399
00:25:12,020 --> 00:25:13,340
对于每一条数据，

400
00:25:13,340 --> 00:25:15,710
需要放到那个网页上，

401
00:25:15,860 --> 00:25:18,020
客户发出，

402
00:25:18,020 --> 00:25:21,980
我们发出的 get 请求可能有很多很多键，

403
00:25:23,660 --> 00:25:25,520
它们会到 memcache ，

404
00:25:25,820 --> 00:25:27,080
它获取结果，

405
00:25:27,110 --> 00:25:30,050
当发送那个 get 到 memcache ，

406
00:25:30,050 --> 00:25:33,350
可能会联系许多 memcached 服务器，

407
00:25:33,930 --> 00:25:35,910
结果返回到网络服务器，

408
00:25:36,150 --> 00:25:39,330
如果有什么东西没有命中，

409
00:25:39,330 --> 00:25:40,350
可以处理那些，

410
00:25:40,350 --> 00:25:42,420
返回[]结果，

411
00:25:42,420 --> 00:25:43,770
我们会得到 nil ，

412
00:25:43,830 --> 00:25:50,520
然后客户端向数据库 SELECT ，

413
00:25:50,520 --> 00:25:52,080
运行 SQL 查询，

414
00:25:52,230 --> 00:25:55,770
它返回一些数据和结果，

415
00:25:55,770 --> 00:25:59,370
客户端可能会进行一些计算，

416
00:25:59,550 --> 00:26:01,830
然后安装进程，

417
00:26:01,830 --> 00:26:05,940
从 SELECT 获得的值到 memcache ，

418
00:26:06,410 --> 00:26:07,700
这就是读取的方面。

419
00:26:07,850 --> 00:26:09,950
再一次，你可以在这里看到，

420
00:26:09,980 --> 00:26:13,640
这个设计的旁路属性或方面，

421
00:26:13,790 --> 00:26:17,600
memcache 并不是直接位于网络服务器和数据库之间，

422
00:26:17,600 --> 00:26:18,770
而是在旁边，

423
00:26:19,160 --> 00:26:20,360
由客户端管理。

424
00:26:22,390 --> 00:26:25,090
所以这是写入端，

425
00:26:28,130 --> 00:26:34,370
例如，如果网络服务器或应用程序需要添加帖子，

426
00:26:34,610 --> 00:26:39,560
或者在帖子中放一张图片，

427
00:26:39,560 --> 00:26:42,850
服务器进行更新，

428
00:26:42,850 --> 00:26:46,480
将更新发送到数据库，

429
00:26:46,780 --> 00:26:50,140
就像正常的事务一样执行，

430
00:26:50,410 --> 00:26:53,050
当然，在数据库旁边，

431
00:26:53,110 --> 00:26:54,400
像我们之前看到的，

432
00:26:54,610 --> 00:26:56,020
将会导致失效，

433
00:26:56,050 --> 00:27:00,640
使用 squeal 守护程序，

434
00:27:02,110 --> 00:27:06,520
有了那个 squeal 守护程序，你可以异步操作，

435
00:27:13,240 --> 00:27:13,960
糟糕，抱歉，

436
00:27:18,920 --> 00:27:23,450
客户端，写入者等待失效发生，

437
00:27:23,450 --> 00:27:25,190
一旦事务中的更新，

438
00:27:25,490 --> 00:27:27,230
一旦数据库中的更新完成，

439
00:27:27,230 --> 00:27:30,500
事务完成，并返回给客户端，

440
00:27:30,710 --> 00:27:35,240
然后同时 squeal 会看到失效，

441
00:27:36,020 --> 00:27:42,140
因为 squeal 以异步方式执行无效操作，

442
00:27:42,380 --> 00:27:45,920
网络服务器执行[]，

443
00:27:45,980 --> 00:27:49,790
立即删除缓存中的键，

444
00:27:50,270 --> 00:27:53,210
这个删除的原因是，

445
00:27:53,300 --> 00:27:56,120
因为我们想要读取自己的写入。

446
00:28:08,060 --> 00:28:11,150
所以，当网络服务器查找键 k 时，

447
00:28:11,390 --> 00:28:13,580
就在它更新之后，

448
00:28:13,730 --> 00:28:16,280
然后它将在 memcached 中丢失，

449
00:28:16,370 --> 00:28:21,050
它将获取新的值，然后安装它，

450
00:28:21,050 --> 00:28:22,520
但是只是这种情况，

451
00:28:22,520 --> 00:28:26,420
网络服务器立即读取它自己的，

452
00:28:26,420 --> 00:28:30,560
读取刚刚更新的 key k 。

453
00:28:33,080 --> 00:28:33,740
好的?

454
00:28:33,980 --> 00:28:37,310
原则上不需要执行这个删除，

455
00:28:37,310 --> 00:28:40,850
失效在某个时刻会发生，

456
00:28:40,850 --> 00:28:43,730
将 key k 从缓存中删除，

457
00:28:44,030 --> 00:28:46,610
对于其他客户端来说，这是可以的，

458
00:28:46,610 --> 00:28:47,870
但是对于这个客户端，

459
00:28:47,870 --> 00:28:51,440
我们希望确保它能读取自己的写入。

460
00:28:53,250 --> 00:28:54,180
我有个问题，

461
00:28:55,020 --> 00:28:59,400
为什么不在删除后进行设置呢？

462
00:29:00,080 --> 00:29:01,850
是的，这是个好问题，

463
00:29:01,850 --> 00:29:03,830
为什么不立即更新，

464
00:29:04,590 --> 00:29:10,350
我认为这就是所谓的更新方案，

465
00:29:10,350 --> 00:29:12,360
原则上这在这里也是可能的，

466
00:29:12,570 --> 00:29:15,000
但我认为这对他们来说有点困难，

467
00:29:15,000 --> 00:29:17,340
因为我认为这需要一些合作，

468
00:29:17,340 --> 00:29:20,250
在数据库、缓存和客户端之间。

469
00:29:20,670 --> 00:29:23,010
我认为问题是这样的，

470
00:29:23,310 --> 00:29:26,250
假设我们有一个客户端 C1 ，

471
00:29:27,160 --> 00:29:28,630
我们有一个客户端 C2 ，

472
00:29:29,560 --> 00:29:32,950
我们会看到类似的类型出现，

473
00:29:32,950 --> 00:29:35,080
假设客户端 x 1 ，

474
00:29:35,620 --> 00:29:38,380
将 x 设置为 1 并将其发送到数据库，

475
00:29:41,860 --> 00:29:44,470
然后，比如，

476
00:29:44,470 --> 00:29:47,170
这是一个假设的更新方案，

477
00:29:50,320 --> 00:29:53,620
这张幻灯片的重点是，

478
00:29:53,620 --> 00:29:55,600
或者这个白板讨论，

479
00:29:55,600 --> 00:29:58,090
执行更新不是无关紧要的，

480
00:29:58,540 --> 00:30:00,640
假设同时客户端 2 ，

481
00:30:00,640 --> 00:30:02,050
我们运行它，

482
00:30:02,050 --> 00:30:05,170
将 x 设为 2 ，将其发送到数据库，

483
00:30:06,570 --> 00:30:09,690
假设客户端 1 有一点延迟，

484
00:30:10,140 --> 00:30:12,360
所以我们实施你的方案，

485
00:30:12,360 --> 00:30:16,380
然后我们立即执行设置 k 为 2 ，

486
00:30:17,960 --> 00:30:20,570
假设 k 在开始时是 0 ，

487
00:30:21,010 --> 00:30:23,530
所以，这将更新 memcached ，

488
00:30:23,530 --> 00:30:29,050
缓存现在将有一个值 k 为 2 ，

489
00:30:29,170 --> 00:30:34,090
然后客户端 1 执行它的设置，

490
00:30:34,360 --> 00:30:36,700
所以，它会放在这里 set 或 put ，

491
00:30:37,900 --> 00:30:42,760
set put ，糟糕，设置 k 为 1 ，

492
00:30:44,240 --> 00:30:46,100
这将覆盖 2 ，

493
00:30:46,190 --> 00:30:52,530
现在我们在缓存中有一个旧的值，

494
00:30:53,760 --> 00:31:00,960
更糟糕的是，这个值是一直过时的，

495
00:31:01,200 --> 00:31:05,220
任何之后的 get 将看到旧的值。

496
00:31:05,900 --> 00:31:07,760
所以，这不是所希望的，

497
00:31:08,180 --> 00:31:09,440
所以你想避免这种情况

498
00:31:09,500 --> 00:31:12,470
当然，你可以让更新方案起作用，

499
00:31:12,680 --> 00:31:16,580
比如，对时间戳排序，

500
00:31:16,580 --> 00:31:19,430
或者为更新分配序列号，

501
00:31:19,760 --> 00:31:21,440
然后通过数据库，

502
00:31:21,440 --> 00:31:25,370
然后键值服务器或 memcached

503
00:31:25,370 --> 00:31:29,750
可以不执行顺序之外的更新，

504
00:31:30,240 --> 00:31:33,750
但这样的方案需要数据库的一些参与，

505
00:31:33,780 --> 00:31:36,570
我的意思是对 MySQL 进行必要的修改，

506
00:31:36,690 --> 00:31:40,230
他们的目标之一是从现成的组件构建所有东西，

507
00:31:41,180 --> 00:31:44,510
所以他们更喜欢这个失效方案，

508
00:31:44,660 --> 00:31:47,030
我认为这实施起来更简单，

509
00:31:47,360 --> 00:31:51,620
因为你的数据库唯一要做的，

510
00:31:51,710 --> 00:31:54,980
是这个额外的进程在旁边，

511
00:31:55,220 --> 00:31:58,940
并使用标准的删除操作，

512
00:31:59,120 --> 00:32:01,610
memcached 已经支持的。

513
00:32:04,620 --> 00:32:05,130
谢谢。

514
00:32:05,550 --> 00:32:06,240
这能理解吗？

515
00:32:08,620 --> 00:32:11,590
我们稍后会看到类似的问题再次出现，

516
00:32:11,590 --> 00:32:15,490
因为，你还记得从论文上看到，

517
00:32:15,550 --> 00:32:18,670
有一些关于 token 或租约的讨论，

518
00:32:18,850 --> 00:32:20,500
为了处理陈旧的值，

519
00:32:20,500 --> 00:32:21,220
但这将是，

520
00:32:21,220 --> 00:32:24,100
我们将看到，旧值在读方面，

521
00:32:24,250 --> 00:32:30,730
或者读取者和写入者之间交互的旧值，

522
00:32:30,910 --> 00:32:34,600
但是完全可以在 memcached 的上下文中解决，

523
00:32:34,600 --> 00:32:36,760
无需对数据库做任何修改。

524
00:32:37,910 --> 00:32:42,800
为什么我们要有一个单独的程序来发布失效，

525
00:32:42,980 --> 00:32:45,200
我想它被称为 squeal ，

526
00:32:45,740 --> 00:32:48,080
所以为什么我们有这个程序，

527
00:32:48,080 --> 00:32:52,640
如果前端本身发出删除 k ？

528
00:32:53,390 --> 00:32:56,060
我们稍后会看到，

529
00:32:56,060 --> 00:32:57,680
为什么这是非常有用的，

530
00:32:58,100 --> 00:33:00,380
尤其是我们要做的是，

531
00:33:00,380 --> 00:33:02,120
我们将看到，缓存被复制，

532
00:33:02,570 --> 00:33:04,910
我们需要发送失效给每个复制。

533
00:33:05,330 --> 00:33:06,350
好的，我明白了，谢谢。

534
00:33:07,590 --> 00:33:13,260
好的， squeal 不会发送删除到每个复制吧？

535
00:33:14,120 --> 00:33:15,260
squeal ，是的，

536
00:33:15,260 --> 00:33:16,130
我们一会儿会看到，

537
00:33:16,130 --> 00:33:17,840
稍等，我们马上就会看到。

538
00:33:19,250 --> 00:33:24,080
事实上，我现在就要谈谈这件事。

539
00:33:25,350 --> 00:33:30,150
到目前为止，大部分故事都是相当标准的，

540
00:33:30,330 --> 00:33:33,330
这里的变化很小，

541
00:33:33,510 --> 00:33:36,120
我们到目前为止谈过的，

542
00:33:36,540 --> 00:33:39,180
没有什么特别的，

543
00:33:39,480 --> 00:33:42,120
在这之后事情就变得更有趣了，

544
00:33:42,360 --> 00:33:45,240
所以，我们更深入地了解

545
00:33:45,240 --> 00:33:49,230
Facebook 特定的优化或性能技巧。

546
00:33:49,850 --> 00:33:55,070
我们要看到的第一件事是，

547
00:33:55,070 --> 00:33:59,760
让我把这个整理好，[]放回去，

548
00:33:59,880 --> 00:34:02,250
第一件事是，

549
00:34:02,250 --> 00:34:03,750
通常情况下，

550
00:34:03,750 --> 00:34:07,530
Facebook 复制一个完整的数据中心，

551
00:34:07,950 --> 00:34:09,900
在编写这个论文的时候，

552
00:34:09,900 --> 00:34:11,460
有两个数据中心，

553
00:34:11,810 --> 00:34:13,370
一个在西海岸，

554
00:34:13,580 --> 00:34:15,710
我们换回蓝色，

555
00:34:16,760 --> 00:34:17,960
数据中心 1 ，

556
00:34:18,440 --> 00:34:19,580
他们称为区域，

557
00:34:22,630 --> 00:34:24,070
这是数据中心 2 ，

558
00:34:25,980 --> 00:34:33,260
它们都有都有客户端层，

559
00:34:34,900 --> 00:34:36,430
所以有很多前端，

560
00:34:43,290 --> 00:34:45,150
也许这是西海岸的那个，

561
00:34:48,580 --> 00:34:51,640
然后这是 memcached 或 memcache 层，

562
00:34:52,520 --> 00:34:55,370
它们都有自己的 memcache 层，

563
00:34:56,180 --> 00:35:00,220
所以这里也是前端，很多前端，

564
00:35:00,730 --> 00:35:03,010
这里是很多 memcached ，

565
00:35:05,360 --> 00:35:06,290
很多 memcached ，

566
00:35:06,290 --> 00:35:09,020
这里有很多 memcached ，

567
00:35:09,380 --> 00:35:11,420
然后这是存储层，

568
00:35:11,570 --> 00:35:15,620
它是一种分片的数据库，

569
00:35:18,410 --> 00:35:20,090
这里也有很多机器，

570
00:35:22,140 --> 00:35:26,880
数据中心 2 在东海岸，

571
00:35:27,240 --> 00:35:30,840
是西海岸那个的直接复制品，

572
00:35:31,340 --> 00:35:35,660
它们用来写入的方案，

573
00:35:36,080 --> 00:35:38,690
因为现在我们有两个数据副本，

574
00:35:38,690 --> 00:35:41,120
数据库的数据存储在两个地方，

575
00:35:41,270 --> 00:35:44,630
所以我们需要以某种方式保持这两个副本同步，

576
00:35:45,050 --> 00:35:48,560
基本的方案至少在右边是，

577
00:35:48,710 --> 00:35:50,840
所有写入都通过 primary ，

578
00:35:50,990 --> 00:35:53,630
其中一个区域是 primary ，另一个是 backup 区域，

579
00:35:54,250 --> 00:35:55,540
这是区域 2 ，

580
00:35:56,440 --> 00:35:59,440
事实上，我想论文说西海岸是 primary ，

581
00:36:02,060 --> 00:36:05,450
东海岸是 backup ，

582
00:36:06,470 --> 00:36:13,400
所以，所有写入都要通过 primary 的存储层，

583
00:36:13,400 --> 00:36:17,690
所以即使是东海岸的前端发布的写入，

584
00:36:17,690 --> 00:36:20,390
会去这里的数据库，

585
00:36:20,390 --> 00:36:24,050
primary 上的数据库运行事务，

586
00:36:24,350 --> 00:36:29,030
传播这些失效消息，

587
00:36:29,030 --> 00:36:33,040
首先，在这边获取日志，

588
00:36:33,490 --> 00:36:37,180
然后复制或传输到另一边，

589
00:36:37,920 --> 00:36:39,660
这就是 squeal 进程，

590
00:36:39,660 --> 00:36:41,670
它执行，

591
00:36:41,700 --> 00:36:45,690
这个进程将日志应用于

592
00:36:45,690 --> 00:36:47,790
另一边数据库中的存储，

593
00:36:48,150 --> 00:36:50,490
使两个数据库保持同步，

594
00:36:50,730 --> 00:36:51,960
并且作为连带作用，

595
00:36:51,960 --> 00:36:56,940
它可能发送失效消息或删除消息给 k ，

596
00:37:01,040 --> 00:37:02,720
所以你可能会想，

597
00:37:02,720 --> 00:37:03,890
为什么要这样做，

598
00:37:03,890 --> 00:37:06,140
为什么不把所有东西放在西海岸，

599
00:37:06,260 --> 00:37:11,300
而是两倍的 memcache 和所有东西。

600
00:37:11,720 --> 00:37:14,330
这样做的一个主要原因是，

601
00:37:14,330 --> 00:37:20,290
对于用户来说，这种良好的读取性能，

602
00:37:21,600 --> 00:37:24,360
对于在东海岸的用户来说，读取性能很好，

603
00:37:24,890 --> 00:37:28,550
他们会连接这些中的一个，

604
00:37:28,730 --> 00:37:32,330
他们在缓存中查找数据，

605
00:37:32,360 --> 00:37:34,550
他们的 memcache 在东海岸，

606
00:37:34,550 --> 00:37:36,770
直接从 memcache 中返回数据，

607
00:37:37,090 --> 00:37:39,370
所以我们会得到好的，

608
00:37:39,370 --> 00:37:41,320
一个是，我们得到好的读取性能，

609
00:37:41,380 --> 00:37:43,360
我们还可以获得低延迟，

610
00:37:43,360 --> 00:37:46,840
因为我们从附近的一个复制中读取数据，

611
00:37:48,280 --> 00:37:53,140
当然，这些缓存可能会有一点不同步，

612
00:37:53,170 --> 00:37:55,090
比起在一个数据中心，

613
00:37:55,090 --> 00:37:57,610
因为像整个更新和失效，

614
00:37:57,760 --> 00:37:59,200
都是异步发生的，

615
00:38:05,230 --> 00:38:07,210
但是，这是可以的，

616
00:38:07,210 --> 00:38:09,460
因为我们已经说过，

617
00:38:09,460 --> 00:38:14,500
我们不是在寻找严格的一致性或串行化。

618
00:38:15,120 --> 00:38:17,670
我有个问题，

619
00:38:17,700 --> 00:38:23,170
如果某人在东海岸，

620
00:38:23,170 --> 00:38:25,120
东海岸的客户端写入，

621
00:38:25,240 --> 00:38:30,040
它会直接写到西海岸的存储，对吗？

622
00:38:30,760 --> 00:38:31,390
是的。

623
00:38:31,540 --> 00:38:35,380
但这并不会失效。

624
00:38:35,590 --> 00:38:40,270
好的，这个会对每个缓存执行失效操作。

625
00:38:41,770 --> 00:38:43,660
哦，但我们说过，

626
00:38:43,660 --> 00:38:44,410
但我们说过，

627
00:38:44,440 --> 00:38:49,330
客户端读取自己的写入。

628
00:38:49,330 --> 00:38:51,430
是的，那么这个会去哪里，

629
00:38:51,430 --> 00:38:52,150
当然会去这里。

630
00:38:52,150 --> 00:38:55,300
是的，理解了，好的。

631
00:38:57,340 --> 00:38:58,060
好的。

632
00:38:59,090 --> 00:38:59,840
好的?

633
00:38:59,930 --> 00:39:01,880
我也有个问题，

634
00:39:03,200 --> 00:39:07,290
客户端是不是总是访问，

635
00:39:07,380 --> 00:39:10,860
比如，给定的客户端是否总是访问相同的 memcache 服务器？

636
00:39:11,890 --> 00:39:16,610
不，我往回一点，

637
00:39:16,820 --> 00:39:18,050
我们稍后会讨论这个问题，

638
00:39:18,050 --> 00:39:21,680
因为正如我们将看到的，这是一个问题，

639
00:39:21,830 --> 00:39:24,140
所以，前端访问，

640
00:39:24,140 --> 00:39:28,040
键分片在 memcache 服务器上，

641
00:39:28,640 --> 00:39:31,010
比如键 k1 ，

642
00:39:31,010 --> 00:39:32,210
k1 在 C1 上，

643
00:39:32,210 --> 00:39:34,070
k2 在 C2 上，等等，

644
00:39:34,600 --> 00:39:38,470
当它需要组成一个网页时，

645
00:39:38,470 --> 00:39:40,000
它需要很多键，

646
00:39:40,390 --> 00:39:47,260
同时发送这些请求到不同的 memcached ，

647
00:39:47,260 --> 00:39:48,850
然后获得所有的回复，

648
00:39:49,610 --> 00:39:53,300
所以事实上，

649
00:39:53,300 --> 00:39:58,340
前端很可能会访问系统中每个 memcached 。

650
00:39:59,860 --> 00:40:02,470
我明白了，如果对于一个给定的键，

651
00:40:02,470 --> 00:40:04,000
是否总是访问相同的服务器。

652
00:40:04,030 --> 00:40:08,020
是的，他们使用了一致性哈希，

653
00:40:08,530 --> 00:40:12,010
我们稍后会多谈一点，

654
00:40:12,010 --> 00:40:14,620
如果一个 memcached 服务器出现故障，

655
00:40:14,920 --> 00:40:16,390
它就不能访问那个了，

656
00:40:16,630 --> 00:40:18,670
所以，随着时间的推移，

657
00:40:18,670 --> 00:40:23,530
从分片到服务器的分配可能会发生一些变化。

658
00:40:26,010 --> 00:40:27,780
抱歉，我想跟进一下，

659
00:40:27,990 --> 00:40:31,950
所以客户端需要读取自己的写入内容，

660
00:40:32,360 --> 00:40:35,720
像是一种弱的保证，

661
00:40:35,720 --> 00:40:38,570
因为如果它从中删除的服务器停机，

662
00:40:38,810 --> 00:40:41,240
然后它必须从不同的复制中读取，

663
00:40:41,240 --> 00:40:42,860
它可能最终不能读取自己的写入内容，

664
00:40:43,520 --> 00:40:45,410
如果在出现故障时。

665
00:40:45,470 --> 00:40:48,380
稍等一下，好吗，

666
00:40:49,050 --> 00:40:51,630
我们会看到有一些[]或竞争，

667
00:40:51,630 --> 00:40:54,510
他们有不同的技术来解决这些竞争问题。

668
00:40:55,150 --> 00:40:57,160
哦，抱歉，最后一个问题。

669
00:40:57,910 --> 00:41:01,030
是的，最后一个，继续。

670
00:41:01,990 --> 00:41:06,370
哦，所以我们在做，

671
00:41:06,860 --> 00:41:09,560
我们为了读取自己的写入，

672
00:41:09,770 --> 00:41:12,980
我们确保直接访问存储服务器，

673
00:41:12,980 --> 00:41:15,230
正好在后面，对吗？

674
00:41:15,230 --> 00:41:15,650
是的。

675
00:41:15,680 --> 00:41:17,000
不在缓存中，

676
00:41:17,180 --> 00:41:20,630
但你也说过。

677
00:41:20,660 --> 00:41:21,650
不，稍等，

678
00:41:22,430 --> 00:41:23,450
当你执行写入时，

679
00:41:23,480 --> 00:41:25,160
你在数据库中进行更新。

680
00:41:25,190 --> 00:41:25,520
是的。

681
00:41:25,520 --> 00:41:29,270
然后你从你的系统中删除键，

682
00:41:29,270 --> 00:41:31,250
例如，在这个案例中，

683
00:41:32,300 --> 00:41:36,440
你会写入到 primary ，

684
00:41:36,650 --> 00:41:39,770
从你的本地缓存中删除键 k ，

685
00:41:39,830 --> 00:41:42,170
所以当你下一次执行 get 时，

686
00:41:42,170 --> 00:41:45,710
你将再次从存储服务器读取。

687
00:41:45,770 --> 00:41:50,800
是的，没错，但我很好奇，

688
00:41:50,800 --> 00:41:52,960
所以你也说过，

689
00:41:52,960 --> 00:41:56,590
对存储的写入是异步进行的，对吗？

690
00:41:57,450 --> 00:42:02,220
这个复制是异步进行的，

691
00:42:02,220 --> 00:42:04,110
失效是异步进行的，

692
00:42:04,140 --> 00:42:05,010
而不是写入。

693
00:42:05,190 --> 00:42:06,750
好的，写入是同步的。

694
00:42:07,660 --> 00:42:09,640
所以，你在完成写入后执行删除。

695
00:42:09,790 --> 00:42:11,500
好的，很好，谢谢。

696
00:42:12,720 --> 00:42:14,430
有一个问题，

697
00:42:14,910 --> 00:42:17,620
所以如果你执行写入，

698
00:42:17,860 --> 00:42:19,360
而你来自，

699
00:42:20,080 --> 00:42:22,780
你不是来自 primary 区域，

700
00:42:22,810 --> 00:42:25,840
你向主存储执行写入操作，

701
00:42:25,900 --> 00:42:28,060
然后你失效你的 memcache ，

702
00:42:28,060 --> 00:42:29,530
然后进行读取，

703
00:42:29,620 --> 00:42:31,540
但是从你的存储中读取，

704
00:42:31,540 --> 00:42:34,720
也许你的存储还不是最新的。

705
00:42:35,410 --> 00:42:36,400
是的，所以有风险，

706
00:42:36,430 --> 00:42:37,720
所以，我们将看他们如何解决这个问题的。

707
00:42:38,290 --> 00:42:38,800
好的。

708
00:42:40,750 --> 00:42:41,260
没错，

709
00:42:41,740 --> 00:42:43,450
但首先让我们更多地谈谈性能，

710
00:42:43,450 --> 00:42:45,340
因为这对他们来说还不够好，

711
00:42:45,370 --> 00:42:46,570
他们想要更高的性能。

712
00:42:48,320 --> 00:42:52,370
所以如果从广义上说，

713
00:42:52,400 --> 00:42:55,310
有两种策略可以获得性能。

714
00:42:55,770 --> 00:42:58,470
我往后退一点，

715
00:43:05,940 --> 00:43:09,600
我们已经在高级别上看到了它们。

716
00:43:09,600 --> 00:43:11,280
所以有两个方案，

717
00:43:11,370 --> 00:43:15,000
一个是分区或分片，

718
00:43:23,060 --> 00:43:24,290
这很酷，

719
00:43:24,290 --> 00:43:26,390
因为我们看到这使用在

720
00:43:26,390 --> 00:43:29,090
存储层和 memcache 层上，

721
00:43:29,270 --> 00:43:31,730
如果你需要更多容量，

722
00:43:31,910 --> 00:43:34,010
你应该再买一台服务器，

723
00:43:34,010 --> 00:43:37,070
修改散列函数，

724
00:43:37,370 --> 00:43:40,070
这样你的 memcached 中有了更多的容量，

725
00:43:40,070 --> 00:43:41,990
你可以保存更多的数据，

726
00:43:42,290 --> 00:43:44,300
并且数据可以被并行访问，

727
00:43:44,890 --> 00:43:46,630
所以我们得到很大的容量，

728
00:43:53,310 --> 00:43:55,590
很大的容量，很大的并行性，

729
00:43:59,400 --> 00:44:03,240
但是，如果你有非常热的键，

730
00:44:03,480 --> 00:44:07,620
很多客户端都需要获取那个键，

731
00:44:07,620 --> 00:44:10,170
无论是 Facebook 的特殊的人，

732
00:44:10,170 --> 00:44:13,140
有一个每个人都关注的时间线，

733
00:44:13,320 --> 00:44:16,680
然后那个键会命中很多次，

734
00:44:17,010 --> 00:44:18,660
它被提供服务，

735
00:44:18,840 --> 00:44:21,420
在这种情况下，可能由两个不同的服务器提供服务，

736
00:44:21,420 --> 00:44:23,520
一个在西海岸，一个在东海岸，

737
00:44:23,790 --> 00:44:27,030
但是东海岸和西海岸的很多客户端，

738
00:44:27,030 --> 00:44:28,230
将会命中相同的，

739
00:44:28,380 --> 00:44:29,160
或者两个，

740
00:44:29,400 --> 00:44:31,320
西海岸的 memcached 服务器，

741
00:44:31,320 --> 00:44:32,880
和东海岸的 memcached 服务器，

742
00:44:32,880 --> 00:44:33,570
持有那个键，

743
00:44:34,410 --> 00:44:36,930
那就不太好了，

744
00:44:36,930 --> 00:44:40,260
因为单个服务器可能会超载，

745
00:44:40,380 --> 00:44:43,830
事实证明，键分发的差异很大，

746
00:44:44,770 --> 00:44:45,820
所以这并不是很好。

747
00:44:45,820 --> 00:44:47,530
所以，要解决这样的问题，

748
00:44:47,620 --> 00:44:53,670
第二种方法是复制，复制数据，

749
00:44:54,170 --> 00:44:57,680
这里是分区数据，然后是复制数据，

750
00:44:59,460 --> 00:45:01,590
这对热的键来说很好，

751
00:45:03,610 --> 00:45:07,420
如果你可以使相同的键扩展到不同的 memcached 服务器，

752
00:45:07,630 --> 00:45:09,550
然后，所有命中这个键的客户端

753
00:45:09,550 --> 00:45:11,980
都可以分布在这些 memcached 服务器上，

754
00:45:11,980 --> 00:45:13,660
并且并行地获得键，

755
00:45:14,370 --> 00:45:18,300
所以，这对热键很有效。

756
00:45:20,100 --> 00:45:22,140
它并不能增加容量，

757
00:45:22,260 --> 00:45:25,230
所以你需要更多的，

758
00:45:27,240 --> 00:45:29,520
在某些方面，我们可以在上一张图片中看到，

759
00:45:29,520 --> 00:45:31,170
我们在这里进行了复制，

760
00:45:31,200 --> 00:45:33,480
我们复制了一个数据中心，

761
00:45:33,600 --> 00:45:35,940
从西海岸到东海岸，

762
00:45:36,090 --> 00:45:40,650
这并没有增加 memcached 的总容量，

763
00:45:40,650 --> 00:45:47,160
由于两个 memcache 层都存储了相同数量的数据，

764
00:45:47,190 --> 00:45:49,710
没有增加 memcache 层的容量，

765
00:45:50,220 --> 00:45:55,320
但是你允许读取两个不同的 memcache 层，

766
00:45:55,320 --> 00:45:56,640
并行的从东海岸和西海岸（读取）。

767
00:45:57,850 --> 00:45:58,420
好的?

768
00:45:58,900 --> 00:46:01,240
所以我们看到了一种复制的小型形式，

769
00:46:01,600 --> 00:46:04,900
你可能会想，还有什么事情要做吗？

770
00:46:05,590 --> 00:46:09,160
这就涉及到了之前提出的一个问题，

771
00:46:09,220 --> 00:46:11,860
比如，你需要更多的容量，

772
00:46:11,860 --> 00:46:14,830
所以，一个更多容量的解决方案，

773
00:46:14,830 --> 00:46:15,940
即使在单个数据中心，

774
00:46:15,940 --> 00:46:17,350
所以忘了有两个数据中心，

775
00:46:17,350 --> 00:46:20,350
只从单个数据中心的角度来看，

776
00:46:20,410 --> 00:46:21,580
我们想要更大的容量，

777
00:46:21,790 --> 00:46:23,920
一个选择是，

778
00:46:23,920 --> 00:46:26,320
你购买更多的 memcached 服务器，

779
00:46:26,590 --> 00:46:27,880
并继续购买更多的服务器，

780
00:46:29,220 --> 00:46:33,980
这里有一个小问题，

781
00:46:33,980 --> 00:46:36,980
这里有问题的一个原因是，

782
00:46:36,980 --> 00:46:43,850
因为这些前端与每个 memcache 服务器交互，

783
00:46:46,020 --> 00:46:46,770
所以它们，

784
00:46:46,800 --> 00:46:49,650
至少在写入方面，

785
00:46:49,680 --> 00:46:51,750
我们知道 TCP 连接打开，

786
00:46:51,990 --> 00:46:54,960
所以这里有大量的 TCP 连接，

787
00:46:55,750 --> 00:47:00,280
此外，正如我之前所说的，

788
00:47:00,280 --> 00:47:03,160
如果一个键命中很多，

789
00:47:03,370 --> 00:47:09,030
这没有被分片解决，

790
00:47:09,980 --> 00:47:11,600
你可以买更多的机器，

791
00:47:11,600 --> 00:47:13,760
但是一个热键在一台机器里，

792
00:47:13,760 --> 00:47:15,800
这不会提高你的性能。

793
00:47:16,650 --> 00:47:21,600
所以，他们在性能改进方面的下一步，

794
00:47:21,840 --> 00:47:26,340
是在单个数据中心内进行复制。

795
00:47:26,640 --> 00:47:33,030
更高的性能，这就是集群的概念，

796
00:47:35,810 --> 00:47:37,880
这是一个关于复制的故事。

797
00:47:40,960 --> 00:47:42,880
所以他们做的是，

798
00:47:42,880 --> 00:47:44,440
如果我们查看单个数据中心，

799
00:47:46,970 --> 00:47:49,070
我们有自己的存储层，

800
00:47:53,400 --> 00:47:54,990
然后在存储层内，

801
00:47:55,510 --> 00:47:59,050
我们要复制一组前端，

802
00:47:59,780 --> 00:48:01,250
这是前端层，

803
00:48:01,550 --> 00:48:04,940
这是我们的 memcache 层，

804
00:48:08,110 --> 00:48:13,080
我要把它复制多次，

805
00:48:15,720 --> 00:48:17,340
他们称为集群。

806
00:48:21,040 --> 00:48:24,430
这个好的原因是，

807
00:48:24,430 --> 00:48:27,910
很好地解决了，对热门键有好处，

808
00:48:31,560 --> 00:48:35,520
热门的键，它可能被复制到多个集群，

809
00:48:35,880 --> 00:48:39,060
所以这很好，

810
00:48:39,330 --> 00:48:42,090
第二，它减少了连接的数量，

811
00:48:47,790 --> 00:48:51,360
有多个原因为什么这很重要，

812
00:48:51,630 --> 00:48:54,780
它避免了，他们所说的，

813
00:48:57,000 --> 00:49:01,200
避免 incast 拥塞问题，

814
00:49:04,640 --> 00:49:05,540
就像我之前说的，

815
00:49:05,540 --> 00:49:10,130
其中一个前端必须获取 500 ，

816
00:49:10,130 --> 00:49:13,430
几十到上百的键，

817
00:49:13,640 --> 00:49:17,000
它会并行地发送它们，

818
00:49:17,000 --> 00:49:20,150
到所有重要的 memcache ，

819
00:49:20,150 --> 00:49:21,230
它们都会做出响应，

820
00:49:22,060 --> 00:49:26,680
当然，我们有很多的 memcache ，

821
00:49:26,770 --> 00:49:28,540
我们将会有更多的并行性，

822
00:49:28,570 --> 00:49:31,420
很多包同时返回，

823
00:49:31,600 --> 00:49:34,660
它们可以很容易地进入队列，

824
00:49:35,080 --> 00:49:38,410
队列超载或队列已满，

825
00:49:38,410 --> 00:49:39,790
因此包被丢弃，

826
00:49:40,480 --> 00:49:42,610
所以，通过减少连接数量，

827
00:49:42,610 --> 00:49:44,230
不是每个前端都访问，

828
00:49:44,230 --> 00:49:46,390
减少回来的响应，

829
00:49:46,660 --> 00:49:49,720
我们避免了这个 incast 拥堵问题，

830
00:49:50,580 --> 00:49:53,340
总的来说，这减轻了网络压力，

831
00:49:55,600 --> 00:49:59,440
很难建立具有双向带宽的网络，

832
00:49:59,440 --> 00:50:01,930
可以承受巨大的负载，

833
00:50:02,110 --> 00:50:05,260
这里通过使用复制，

834
00:50:05,380 --> 00:50:10,240
一个集群的网络很好地支持了这个集群。

835
00:50:17,110 --> 00:50:19,780
现在，这一切都很好，

836
00:50:19,810 --> 00:50:22,450
当然，这个设计的缺点，

837
00:50:22,450 --> 00:50:23,110
也就是，

838
00:50:23,110 --> 00:50:24,760
如果你有不受欢迎的键，

839
00:50:25,060 --> 00:50:29,620
不受欢迎的键将被存储在多个区域，

840
00:50:29,620 --> 00:50:31,210
基本上什么都不做，

841
00:50:31,690 --> 00:50:35,200
或者[]对性能的提高做出贡献，

842
00:50:35,500 --> 00:50:37,960
所以，他们所做的是，

843
00:50:37,960 --> 00:50:41,170
他们还有一个额外的池，

844
00:50:41,500 --> 00:50:43,360
他们称为区域池，

845
00:50:46,010 --> 00:50:49,340
应用程序可以决定

846
00:50:50,720 --> 00:50:55,780
保存不是很受欢迎的键到区域池，

847
00:50:56,250 --> 00:50:57,900
把它放在里面，

848
00:50:57,960 --> 00:51:00,180
所以这些，

849
00:51:00,180 --> 00:51:06,210
所以它们不会在时间上跨所有集群复制，

850
00:51:06,210 --> 00:51:09,870
你可以考虑区域池在多个集群之间共享，

851
00:51:10,080 --> 00:51:14,340
用于不太受欢迎的键或不太频繁使用的键。

852
00:51:15,370 --> 00:51:16,090
好的?

853
00:51:17,900 --> 00:51:20,870
那么，这会对流行的键有帮助吗，

854
00:51:20,870 --> 00:51:26,040
因为每个集群都会有自己的 memcache 。

855
00:51:26,160 --> 00:51:28,830
是的，每个集群都有自己的 memcache ，

856
00:51:31,580 --> 00:51:33,350
有自己的前端，

857
00:51:33,380 --> 00:51:34,940
有自己的 memcache ，

858
00:51:37,720 --> 00:51:39,280
基本上用户，

859
00:51:39,280 --> 00:51:44,470
用户是负载均衡到所有这些集群的。

860
00:51:45,890 --> 00:51:48,560
但这仍然不能增加容量，对吗？

861
00:51:49,330 --> 00:51:51,220
这没有增加容量，

862
00:51:51,220 --> 00:51:55,060
如果您想要增加容量，

863
00:51:55,060 --> 00:51:57,310
你，

864
00:51:57,790 --> 00:52:00,130
好的，它稍微增加了一些容量，

865
00:52:00,130 --> 00:52:02,860
因为所有不受欢迎的内容都不在额外的缓存，

866
00:52:02,860 --> 00:52:04,150
并被困在区域池中，

867
00:52:05,560 --> 00:52:08,650
所以，这些空间现在可以存储其他键。

868
00:52:14,490 --> 00:52:16,860
所以为了避免 incast 拥塞，

869
00:52:16,890 --> 00:52:20,550
它们还会减少每个集群的分片数量，对吗？

870
00:52:20,700 --> 00:52:23,130
是的，不增加，他们不会增加它，

871
00:52:25,090 --> 00:52:27,430
替代方案不是引入集群，

872
00:52:27,550 --> 00:52:31,870
但会继续增加 memcache 分片，

873
00:52:31,870 --> 00:52:34,720
在单个 memcache 中的分片数量，

874
00:52:35,900 --> 00:52:38,300
它有自己的限制。

875
00:52:39,830 --> 00:52:40,880
理解了，谢谢。

876
00:52:46,640 --> 00:52:53,030
好的，这是基本的设计，

877
00:52:53,150 --> 00:52:57,200
除了他们必须解决的各种各样的性能挑战，

878
00:52:57,470 --> 00:53:01,280
大多数这些性能挑战必须解决，

879
00:53:01,280 --> 00:53:03,950
我认为考虑的方式是保护数据库。

880
00:53:22,270 --> 00:53:24,190
所以，回到这张图片，

881
00:53:24,190 --> 00:53:28,420
我们现在的设计显然能支持每秒数十亿次请求，

882
00:53:29,340 --> 00:53:33,990
但是存储层本身是分片的，

883
00:53:34,260 --> 00:53:38,070
因为肯定不能承受每秒支持数十亿次请求，

884
00:53:38,610 --> 00:53:40,800
这会是一个灾难，

885
00:53:40,860 --> 00:53:44,550
假设所有的 memcache 都以这样或那样的方式失败了，

886
00:53:44,730 --> 00:53:45,930
或整个集群出现故障，

887
00:53:46,080 --> 00:53:48,810
所有前端都会命中存储服务器，

888
00:53:49,110 --> 00:53:51,540
那么存储服务器会崩溃，

889
00:53:51,570 --> 00:53:53,460
不能处理这种负载，

890
00:53:53,670 --> 00:53:59,730
所以他们必须非常非常小心做任何事情，

891
00:53:59,790 --> 00:54:02,610
需要在存储服务器上加载更多负载（的事情）。

892
00:54:03,890 --> 00:54:06,470
所以，比如一个挑战，

893
00:54:06,470 --> 00:54:07,910
我要谈的是，

894
00:54:08,210 --> 00:54:10,220
建立一个新的集群，

895
00:54:15,280 --> 00:54:17,200
建立一个新集群的简单方法，

896
00:54:17,200 --> 00:54:20,800
就是建立一个集群，

897
00:54:20,800 --> 00:54:25,270
打开机器，安装软件，然后就完成了，

898
00:54:25,630 --> 00:54:28,390
基于这样一个事实，

899
00:54:28,390 --> 00:54:31,030
如果数据不在缓存中，

900
00:54:31,030 --> 00:54:32,410
你会不命中，

901
00:54:32,590 --> 00:54:34,210
未命中会进入数据库，

902
00:54:34,210 --> 00:54:36,100
收集必要的数据，

903
00:54:37,080 --> 00:54:41,190
这种设计有什么问题吗？

904
00:54:45,510 --> 00:54:47,430
它会有很多缓存未命中，

905
00:54:47,430 --> 00:54:49,050
因为缓存里什么都没有。

906
00:54:49,620 --> 00:54:52,320
是的，假设你有一个集群，

907
00:54:52,890 --> 00:54:54,540
你有第二个集群，

908
00:54:54,540 --> 00:54:57,690
你把一半的用户移动到第二个集群，

909
00:54:57,690 --> 00:55:02,070
那么 50% 的请求将在缓存中丢失，

910
00:55:02,220 --> 00:55:03,600
它们会命中数据库，

911
00:55:03,980 --> 00:55:05,960
数据库就会崩溃。

912
00:55:07,070 --> 00:55:09,140
那么，他们是如何处理这一问题的呢？

913
00:55:11,700 --> 00:55:12,510
Gutter ？

914
00:55:13,400 --> 00:55:15,200
不，不是 Gutter ，这是。

915
00:55:17,030 --> 00:55:20,570
我认为他们让新集群

916
00:55:20,570 --> 00:55:24,770
从旧集群的缓存中读取一些条目。

917
00:55:24,860 --> 00:55:26,750
是的，从新的集群获取，

918
00:55:27,880 --> 00:55:29,350
如果它们在新集群中未命中，

919
00:55:29,350 --> 00:55:32,350
它们会转向旧的集群，从已经存在的那个，

920
00:55:36,250 --> 00:55:40,570
然后它们在新集群中设置，

921
00:55:42,310 --> 00:55:44,110
所以考虑的一种方式是，

922
00:55:44,110 --> 00:55:47,920
它们填充新的集群或预热新的集群，

923
00:55:48,190 --> 00:55:51,910
通过从现有集群中读取，

924
00:55:52,060 --> 00:55:55,270
所以，这可能会稍微增加现有集群上的负载，

925
00:55:55,600 --> 00:55:58,930
但至少不会给数据库带来太大压力，

926
00:56:00,080 --> 00:56:01,880
我们稍后会看到，

927
00:56:02,000 --> 00:56:05,240
这再次带来了一些一致性问题，

928
00:56:05,420 --> 00:56:08,180
我们稍后会看到这个。

929
00:56:09,060 --> 00:56:09,570
好的？

930
00:56:10,070 --> 00:56:14,540
所以这是一个解决性能挑战的例子，

931
00:56:15,080 --> 00:56:17,840
另一个性能是在受欢迎的术语，

932
00:56:18,800 --> 00:56:22,100
在很多上下文中，称为惊群问题，

933
00:56:25,460 --> 00:56:26,930
什么是惊群问题？

934
00:56:31,070 --> 00:56:35,300
我想，当有大量的读写操作

935
00:56:35,480 --> 00:56:37,520
大致同时发生，

936
00:56:37,520 --> 00:56:40,100
因为有大量的写操作，

937
00:56:40,100 --> 00:56:43,730
数据将多次失效，

938
00:56:43,820 --> 00:56:48,020
数据库将受到请求的攻击。

939
00:56:48,020 --> 00:56:50,270
是的，你可以让它变得简单，

940
00:56:50,270 --> 00:56:54,290
单次写入导致一个键无效，

941
00:56:54,850 --> 00:56:58,990
任何在它之后读取键的客户端，

942
00:56:58,990 --> 00:57:00,760
所以，可能会出现以下情况，

943
00:57:00,940 --> 00:57:02,410
你有一个非常受欢迎的键，

944
00:57:02,620 --> 00:57:05,560
你使键失效，

945
00:57:05,590 --> 00:57:07,090
所以你从缓存中删除键，

946
00:57:07,240 --> 00:57:13,330
所有在前端遇到流行键的机器

947
00:57:13,420 --> 00:57:14,920
会执行一次获取那个键，

948
00:57:15,130 --> 00:57:16,390
所有都得到 nil ，

949
00:57:16,450 --> 00:57:20,140
然后它们都想从数据库中读取 SELECT ，

950
00:57:20,930 --> 00:57:25,160
这可能给数据库带来很大的压力，

951
00:57:25,580 --> 00:57:28,580
所以，他们想要避免这个问题，

952
00:57:28,580 --> 00:57:29,600
那么他们如何做的，

953
00:57:30,130 --> 00:57:31,750
他们如何避免这个问题？

954
00:57:33,080 --> 00:57:34,490
他们用了租约。

955
00:57:34,550 --> 00:57:38,780
是的，没错，继续，多说一点。

956
00:57:38,780 --> 00:57:41,300
是的，我想他们给了一段时间，

957
00:57:41,330 --> 00:57:45,050
为用户指定的键，

958
00:57:45,050 --> 00:57:47,120
然后在某个时刻，

959
00:57:47,120 --> 00:57:49,130
据我所知，就像一把锁，

960
00:57:49,130 --> 00:57:54,050
如果另一个用户试图使用它，

961
00:57:54,350 --> 00:57:55,460
它们会等待，

962
00:57:55,460 --> 00:57:57,980
然后希望它能足够快地更新，

963
00:57:57,980 --> 00:57:59,960
在下一次重试时，他们就会得到它。

964
00:58:02,770 --> 00:58:05,200
如果你执行获取，你会获得 nil ，

965
00:58:06,310 --> 00:58:07,420
你有两种情况，

966
00:58:07,420 --> 00:58:11,340
要么你获取一个租约，

967
00:58:11,340 --> 00:58:13,680
第一行没有得到和未命中，

968
00:58:13,680 --> 00:58:15,570
从 memcached 中获取释放，

969
00:58:15,930 --> 00:58:19,440
而 memcached 至少给你更新的权限，

970
00:58:19,890 --> 00:58:20,760
或者告诉客户端，

971
00:58:20,760 --> 00:58:22,710
比如你要负责更新，

972
00:58:23,160 --> 00:58:25,920
如果你不这么做，

973
00:58:25,950 --> 00:58:26,940
你知道第一个，

974
00:58:27,060 --> 00:58:33,280
你会收到一条重试消息或结果，

975
00:58:33,280 --> 00:58:36,370
这告诉客户端，你应该尽快重试，

976
00:58:36,370 --> 00:58:38,710
不会立即出现，可能会扩散一点，

977
00:58:39,100 --> 00:58:41,980
他们可能会做一些二进制备份类型的事情，

978
00:58:42,310 --> 00:58:44,080
我们试着获取，

979
00:58:44,470 --> 00:58:47,620
在大多数情况下，客户端，

980
00:58:47,620 --> 00:58:49,540
未命中的第一行

981
00:58:49,810 --> 00:58:53,980
很快地更新键 k ，

982
00:58:53,980 --> 00:58:55,750
在毫秒量级上，

983
00:58:56,080 --> 00:58:59,530
然后这些重试成功，

984
00:58:59,530 --> 00:59:02,620
这里没有爆炸式增长，

985
00:59:02,620 --> 00:59:04,660
对数据库的请求数量，

986
00:59:04,660 --> 00:59:05,320
在这种方案下。

987
00:59:06,260 --> 00:59:07,460
当然，它引入了，

988
00:59:07,460 --> 00:59:10,310
正如我们稍后将看到的，更多的竞态条件，

989
00:59:10,670 --> 00:59:15,140
但是，首先让我们继续关注性能。

990
00:59:18,450 --> 00:59:20,460
租约还有另一件事，

991
00:59:20,490 --> 00:59:26,160
它们适合，比如地址仍然固定。

992
00:59:26,250 --> 00:59:28,650
是的，所以租约形成了两个角色，

993
00:59:28,830 --> 00:59:30,120
我们稍后将看到，

994
00:59:30,120 --> 00:59:32,430
一个是一致性，一个是性能，

995
00:59:32,670 --> 00:59:34,080
这个是用来性能的，

996
00:59:35,870 --> 00:59:37,430
我们将在稍后讨论一致性，

997
00:59:37,430 --> 00:59:38,750
我会看到第二次讨论，

998
00:59:38,840 --> 00:59:40,910
作为解决这些竞争情况的一种方法。

999
00:59:46,390 --> 00:59:49,060
好的，论文上还有更多，

1000
00:59:49,090 --> 00:59:50,950
还有一件有趣的事，

1001
00:59:50,950 --> 00:59:53,410
至少我觉得有趣，

1002
00:59:53,920 --> 00:59:58,960
如果 memcached 或 memcache 服务器出现故障，会发生什么情况？

1003
01:00:08,750 --> 01:00:09,500
那得看情况,

1004
01:00:09,500 --> 01:00:12,170
如果是整个数据中心，

1005
01:00:12,170 --> 01:00:16,190
整个 memcache 服务器集合都发生了故障。

1006
01:00:17,450 --> 01:00:20,050
只要考虑一个，我想要做的。

1007
01:00:20,080 --> 01:00:22,570
之前有人提到过，

1008
01:00:23,620 --> 01:00:26,680
故障的 memcache ，

1009
01:00:27,040 --> 01:00:29,980
但他们不会删除它们。

1010
01:00:30,460 --> 01:00:32,770
是的，所以看看这个场景，

1011
01:00:32,770 --> 01:00:35,890
有问题的情况是 memcached 服务器出现故障，

1012
01:00:36,340 --> 01:00:39,310
这将导致一系列未命中，

1013
01:00:39,310 --> 01:00:40,900
这些未命中将进入数据库，

1014
01:00:40,900 --> 01:00:43,090
他们想避免命中数据库，

1015
01:00:43,660 --> 01:00:46,330
任何在这些服务器中具有键的客户端，

1016
01:00:46,660 --> 01:00:50,740
试图获取键将会失败，

1017
01:00:50,740 --> 01:00:52,270
然后必须做点什么。

1018
01:00:53,260 --> 01:00:55,180
所以当它失败的时候，

1019
01:00:56,890 --> 01:00:59,890
简单的解决办法就是去数据库，

1020
01:00:59,920 --> 01:01:02,350
但我们想要保护数据库，

1021
01:01:02,620 --> 01:01:04,840
所以这看起来不是个好主意，

1022
01:01:04,990 --> 01:01:05,740
所以，他们所做的是，

1023
01:01:05,740 --> 01:01:08,560
拥有一个小型的其他集群或另一个池，

1024
01:01:08,560 --> 01:01:11,020
比如区域池或者他们叫 Gutter 池，

1025
01:01:15,070 --> 01:01:19,750
Gutter 池就是一些 memcached 机器，

1026
01:01:19,870 --> 01:01:21,010
这只是可用的，

1027
01:01:21,370 --> 01:01:25,300
它们的使用时间很短，

1028
01:01:25,510 --> 01:01:28,360
系统在重新配置和修复自身，

1029
01:01:28,360 --> 01:01:30,190
添加新的 memcached 服务器，

1030
01:01:30,190 --> 01:01:32,170
替换失败的那个。

1031
01:01:32,930 --> 01:01:34,280
但在那段时间里，

1032
01:01:34,280 --> 01:01:37,280
有一个新的[顺序]，或者可能更多一点，

1033
01:01:37,370 --> 01:01:40,760
它们不想收到请求，

1034
01:01:40,760 --> 01:01:42,560
或 SELECT 转到数据库，

1035
01:01:42,680 --> 01:01:44,660
不是它们在失败时所做的事情，

1036
01:01:44,810 --> 01:01:46,820
你先去试试 Gutter 池，

1037
01:01:47,540 --> 01:01:49,820
Gutter 池将会，

1038
01:01:50,060 --> 01:01:55,610
第一个命中 Gutter 池的会失败或未命中，

1039
01:01:55,820 --> 01:01:57,560
执行 SELECT 数据库，

1040
01:01:57,560 --> 01:01:59,570
将结果放入 Gutter 池，

1041
01:01:59,600 --> 01:02:04,310
然后，后面的请求或获取将从 Gutter 池中得到答复，

1042
01:02:04,700 --> 01:02:08,690
在某个时刻， memcached 机器扩展，

1043
01:02:08,720 --> 01:02:12,320
它或者被另一台机器替换或者恢复，

1044
01:02:12,650 --> 01:02:16,940
然后，负载将转移回 memcached 服务器和 Gutter 池，

1045
01:02:16,940 --> 01:02:18,200
它又一次在边上，

1046
01:02:18,440 --> 01:02:21,260
在这些过渡期之间进行。

1047
01:02:23,610 --> 01:02:24,090
好的？

1048
01:02:25,120 --> 01:02:28,750
这就是我们今天的阅读问题，

1049
01:02:28,750 --> 01:02:30,130
就像你刚才提到的，

1050
01:02:30,310 --> 01:02:34,180
你不在 Gutter 池执行删除，

1051
01:02:34,870 --> 01:02:38,260
并且失效也不会被发送到 Gutter 池，

1052
01:02:38,710 --> 01:02:43,630
问题是为什么，或者我们可以推测为什么，

1053
01:02:43,720 --> 01:02:46,210
所以也许这是一个快速分组会议室的时间，

1054
01:02:46,450 --> 01:02:47,200
用几分钟时间，

1055
01:02:47,200 --> 01:02:50,950
要么讨论一下 memcached 设计的其他方面，

1056
01:02:50,950 --> 01:02:53,710
或者你想要讨论这个问题的答案是什么。

1057
01:02:56,080 --> 01:02:57,310
所以或许我们中断一下，

1058
01:02:57,310 --> 01:02:58,540
是的，谢谢， Lily 。

1059
01:09:03,340 --> 01:09:04,570
好的，大家都回来了吗？

1060
01:09:10,310 --> 01:09:11,210
是的，看起来是的。

1061
01:09:11,980 --> 01:09:12,880
是的，好的。

1062
01:09:13,490 --> 01:09:15,290
好的，有人知道，

1063
01:09:15,350 --> 01:09:17,960
这篇论文没有非常准确地回答这个问题，

1064
01:09:17,960 --> 01:09:20,000
但是有人想大胆猜测

1065
01:09:20,000 --> 01:09:22,660
删除的答案是什么，

1066
01:09:23,520 --> 01:09:26,700
没有删除，没有失效到 Gutter 集群。

1067
01:09:27,830 --> 01:09:29,570
哦，那个。

1068
01:09:29,990 --> 01:09:30,440
继续。

1069
01:09:31,550 --> 01:09:33,650
哦，我们说的是，

1070
01:09:34,450 --> 01:09:35,200
如果你这样做了，

1071
01:09:35,200 --> 01:09:38,050
那么你会对 Gutter 池施加很大的压力，

1072
01:09:38,050 --> 01:09:39,760
因为只有很少的机器，

1073
01:09:40,030 --> 01:09:41,620
对于每个缓存未命中，

1074
01:09:41,770 --> 01:09:45,460
有两个对缓存的请求，

1075
01:09:45,610 --> 01:09:46,810
所以，如果你这样做，

1076
01:09:46,960 --> 01:09:50,260
在每次写入之后，你都会有一个额外的请求，

1077
01:09:50,540 --> 01:09:52,340
在 Gutter 池上，它太小了，

1078
01:09:52,340 --> 01:09:53,570
所以你不会想这么做的，

1079
01:09:53,570 --> 01:09:56,600
此外，你还应该保护数据库，

1080
01:09:56,600 --> 01:10:01,640
因为你会在写入请求后不断地查询它。

1081
01:10:02,750 --> 01:10:06,800
是的，删除消息需要去两个池，

1082
01:10:06,800 --> 01:10:08,330
原始的 memcached 池，

1083
01:10:08,630 --> 01:10:11,390
所有 memcached 池，并将其在 Gutter 失效，

1084
01:10:11,750 --> 01:10:14,360
所以，删除流量也翻了一番，

1085
01:10:14,480 --> 01:10:15,800
所以我认为这是一个完美的，

1086
01:10:16,220 --> 01:10:18,380
我想这就是原因，

1087
01:10:18,440 --> 01:10:19,820
这是一组很小的机器，

1088
01:10:19,820 --> 01:10:21,920
只是在那里

1089
01:10:22,220 --> 01:10:27,710
完成从已删除的 memcached 服务器的转换，

1090
01:10:27,770 --> 01:10:30,920
从出现故障的 memcached 服务器到新的 memcached 服务器。

1091
01:10:32,200 --> 01:10:32,620
好的。

1092
01:10:33,120 --> 01:10:36,810
好了，关于性能，我想说的就是这些，

1093
01:10:36,840 --> 01:10:39,480
尽管论文中有更多关于性能的内容，

1094
01:10:39,480 --> 01:10:43,680
相反，我想谈谈这些竞争，

1095
01:10:43,890 --> 01:10:45,690
它们来自，

1096
01:10:45,690 --> 01:10:49,290
因为这个试图获得高性能，

1097
01:10:49,290 --> 01:10:50,640
我们已经讨论过的。

1098
01:10:51,170 --> 01:10:53,330
我想谈论的有三个竞争，

1099
01:10:53,510 --> 01:10:56,360
我认为你已经确认的三个，

1100
01:10:57,100 --> 01:11:00,430
大多数讨论都是关于，

1101
01:11:00,730 --> 01:11:03,850
他们是如何躲避它们的。

1102
01:11:05,300 --> 01:11:08,780
所以竞争 1 是他们所说的旧配置，

1103
01:11:08,810 --> 01:11:12,080
场景如下，

1104
01:11:12,440 --> 01:11:15,290
我们有客户端 1 ，使用一个区域，

1105
01:11:15,320 --> 01:11:19,010
一个集群，没什么特别的设置，

1106
01:11:19,660 --> 01:11:23,680
所以客户端 1 执行获取 k ，

1107
01:11:24,370 --> 01:11:28,090
在这种情况下，结果是 nil ，

1108
01:11:28,090 --> 01:11:30,820
它将从数据库中读取值，

1109
01:11:32,130 --> 01:11:35,220
也许这是获得 token 的客户端，

1110
01:11:35,610 --> 01:11:39,660
它是被允许设置的那个，

1111
01:11:40,080 --> 01:11:42,330
但在它设置之前，

1112
01:11:42,360 --> 01:11:44,310
另一个客户端进来了，

1113
01:11:44,310 --> 01:11:49,560
并将 k 为 2 写入数据库，

1114
01:11:50,160 --> 01:11:53,850
然后有一个 put(k,2) ，

1115
01:11:55,650 --> 01:11:59,580
然后其他客户端，

1116
01:11:59,580 --> 01:12:02,400
终于等到执行 put ，

1117
01:12:02,400 --> 01:12:07,170
它执行 put(k, v1) ，

1118
01:12:07,760 --> 01:12:09,410
好的， ,v1 ，

1119
01:12:10,100 --> 01:12:15,430
现在，我们在缓存中有一个旧的值，

1120
01:12:15,430 --> 01:12:18,280
而且在那里旧的值是持久性的，

1121
01:12:19,150 --> 01:12:20,890
在其他人更新之前，

1122
01:12:21,460 --> 01:12:22,090
好的,

1123
01:12:22,390 --> 01:12:23,800
这是不希望的，

1124
01:12:23,800 --> 01:12:26,890
这破坏了与应用程序的契约，

1125
01:12:27,130 --> 01:12:28,660
它们不想回到过去，

1126
01:12:28,810 --> 01:12:33,280
用户观察到它们，将是[]，

1127
01:12:33,280 --> 01:12:34,690
所以试图避免这种情况。

1128
01:12:35,650 --> 01:12:39,550
那么他们做了什么，他们如何解决这个问题？

1129
01:12:42,630 --> 01:12:43,590
使用租约吗？

1130
01:12:44,740 --> 01:12:47,410
是的，有人说是租约的帮助，

1131
01:12:47,410 --> 01:12:48,490
它们已经有了租约，

1132
01:12:48,490 --> 01:12:50,170
因为这个已经有了租约，

1133
01:12:51,290 --> 01:12:52,220
已经获得租约，

1134
01:12:52,220 --> 01:12:54,620
否则它就不会从数据库中读取数据，

1135
01:12:55,040 --> 01:12:59,030
所以，在客户端 1 在 put 上面加上租约，

1136
01:13:02,010 --> 01:13:04,740
或者可以在 put 上加上租约，

1137
01:13:04,770 --> 01:13:06,690
事实上，它会，

1138
01:13:06,690 --> 01:13:09,330
还有额外的步骤是什么？

1139
01:13:15,140 --> 01:13:18,950
检查这个没有过期或者什么，

1140
01:13:18,950 --> 01:13:22,100
因为如果另一个客户能够。

1141
01:13:23,000 --> 01:13:25,910
抱歉，我刚意识到我犯了个错误，

1142
01:13:26,150 --> 01:13:28,700
这就是为什么这个问题不是很好，

1143
01:13:28,850 --> 01:13:31,700
让我看看，客户端 2 不会执行 put ，

1144
01:13:32,090 --> 01:13:33,560
这是无效一致性，

1145
01:13:34,090 --> 01:13:35,380
我在这里把自己搞糊涂了，

1146
01:13:35,380 --> 01:13:37,270
那么客户端 2 做了什么，

1147
01:13:38,920 --> 01:13:40,510
在它设置数据库之后。

1148
01:13:44,080 --> 01:13:44,860
回去。

1149
01:13:44,860 --> 01:13:45,490
删除？

1150
01:13:45,550 --> 01:13:46,780
是的，它执行删除，

1151
01:13:47,920 --> 01:13:49,810
基于我们之前谈到的原因，

1152
01:13:49,810 --> 01:13:51,040
所以它执行删除 k ，

1153
01:13:51,760 --> 01:13:53,200
那么连带作用是什么，

1154
01:13:53,200 --> 01:13:56,140
删除 k ，租约会发生什么？

1155
01:13:59,420 --> 01:14:02,690
它不会验证，或者它不会。

1156
01:14:03,320 --> 01:14:06,110
是的，删除的连带作用是，

1157
01:14:06,140 --> 01:14:11,060
租约失效，

1158
01:14:12,420 --> 01:14:14,100
所以，它使租约失效，

1159
01:14:17,590 --> 01:14:19,240
所以当 put 出现时，

1160
01:14:19,270 --> 01:14:20,770
我的时间线有点，

1161
01:14:20,770 --> 01:14:25,210
这个发生在之前，

1162
01:14:25,210 --> 01:14:28,120
所以， put 在 delete 之后发生，

1163
01:14:28,120 --> 01:14:31,000
put 将带上 get 的租约，

1164
01:14:31,000 --> 01:14:33,760
但是租约已经因为删除而失效，

1165
01:14:33,760 --> 01:14:35,800
所以这个 put 被拒绝了。

1166
01:14:41,520 --> 01:14:43,740
所以考虑这个问题的一种方式是，

1167
01:14:43,740 --> 01:14:48,750
他们利用租约机制来避免惊群问题，

1168
01:14:48,780 --> 01:14:54,870
也避免了这个旧设置的问题。

1169
01:14:58,280 --> 01:14:59,150
这能理解吗？

1170
01:15:01,490 --> 01:15:07,670
所以，即使我们没有这个租约失效机制，

1171
01:15:07,760 --> 01:15:10,430
我们仍然会服从弱一致性，

1172
01:15:10,430 --> 01:15:14,720
你会获得在过去的某个时间发生的顺序写入，

1173
01:15:14,720 --> 01:15:15,590
但我相信，

1174
01:15:15,590 --> 01:15:18,560
这件事可以确保你观察到自己的写入，对吗？

1175
01:15:19,520 --> 01:15:20,690
你是对的，

1176
01:15:20,690 --> 01:15:22,700
它们还能确保你不会回到过去，

1177
01:15:23,820 --> 01:15:25,230
比如，如果你读到一些东西，

1178
01:15:25,680 --> 01:15:31,650
任何比客户端 2 更晚的客户端，

1179
01:15:31,650 --> 01:15:33,930
将会看到旧的 v1 ，

1180
01:15:34,020 --> 01:15:36,090
客户端可能会远远落后于，

1181
01:15:36,180 --> 01:15:39,240
很长一段时间都看不到新的写入，

1182
01:15:39,240 --> 01:15:40,830
事实上，可能一直看不到。

1183
01:15:41,440 --> 01:15:44,800
是的，但是，我是说，这会回到过去吗，

1184
01:15:44,800 --> 01:15:47,920
因为客户端没有读取之后的东西。

1185
01:15:48,100 --> 01:15:50,320
或许回到过去是个错误的词，

1186
01:15:50,350 --> 01:15:53,410
但它在很长一段时间内不会观察到 v2 。

1187
01:15:53,740 --> 01:15:55,150
我明白了，好的。

1188
01:15:55,150 --> 01:15:56,890
这不是我们想要发生的事情，

1189
01:15:58,400 --> 01:15:59,570
有一点是可以的，

1190
01:15:59,570 --> 01:16:01,100
但在很长一段时间是不可以的。

1191
01:16:03,030 --> 01:16:07,740
好的，第二个竞争已经有人提过了，

1192
01:16:07,740 --> 01:16:09,840
已经被确认了，

1193
01:16:10,590 --> 01:16:15,360
因为很多实验调试的优势，

1194
01:16:15,360 --> 01:16:16,860
都是关于竞争的，

1195
01:16:18,050 --> 01:16:21,890
竞争 2 ，这是冷集群竞争，

1196
01:16:25,460 --> 01:16:27,110
风格也差不多，

1197
01:16:27,350 --> 01:16:29,990
我们有两个客户端，

1198
01:16:30,640 --> 01:16:33,220
客户端 1 ，客户端 2 。

1199
01:16:37,300 --> 01:16:41,470
假设 k 最初是 v1 ，

1200
01:16:41,470 --> 01:16:43,960
两个客户端都在冷集群中，

1201
01:16:44,640 --> 01:16:51,650
客户端 1 在数据库中将 k 设置为新值，

1202
01:16:53,070 --> 01:16:59,160
删除冷集群中的 k ，

1203
01:16:59,160 --> 01:17:00,390
当前集群所在的，

1204
01:17:01,200 --> 01:17:08,230
然后这个客户端在冷集群中执行获取，

1205
01:17:10,600 --> 01:17:15,700
看到它不在那里，

1206
01:17:16,150 --> 01:17:17,740
接下来要做的是，

1207
01:17:17,740 --> 01:17:24,630
从暖集群中获取，获取值，

1208
01:17:26,870 --> 01:17:29,150
我的意思是，从那里获取，

1209
01:17:29,150 --> 01:17:35,670
在冷集群或暖集群更新之前。

1210
01:17:36,290 --> 01:17:41,910
现在，它将执行设置 k v1 ，

1211
01:17:41,910 --> 01:17:44,250
或者 put ，抱歉，让我修改一下，

1212
01:17:44,280 --> 01:17:50,490
在冷集群中将 k 设置为 v1 ，

1213
01:17:50,640 --> 01:17:53,850
现在我们有和以前一样的情况，

1214
01:17:53,850 --> 01:18:01,370
我们在冷集群中有一个永久的旧的值。

1215
01:18:07,070 --> 01:18:09,500
他们如何解决这个问题？

1216
01:18:15,810 --> 01:18:16,800
有人记得吗？

1217
01:18:27,590 --> 01:18:31,010
他们有一个小的扩展来避免这个问题，

1218
01:18:31,800 --> 01:18:33,330
猜猜是什么。

1219
01:18:38,780 --> 01:18:41,630
C1 是暖集群还是冷集群？

1220
01:18:41,630 --> 01:18:42,650
两个都是冷集群。

1221
01:18:47,070 --> 01:18:50,490
它们在不同的冷集群中，对吗？

1222
01:18:50,940 --> 01:18:53,610
我不确定这有什么关系。

1223
01:18:54,600 --> 01:18:56,310
是的，没什么关系。

1224
01:19:29,900 --> 01:19:30,560
有人知道吗？

1225
01:19:52,340 --> 01:19:55,250
我想他们提到过要推迟两秒钟，

1226
01:19:55,250 --> 01:19:58,520
尽管完全分享了所有的细节。

1227
01:20:01,680 --> 01:20:08,280
是的，这导致了推迟，

1228
01:20:09,030 --> 01:20:11,250
他们称之为推迟两秒，

1229
01:20:15,510 --> 01:20:18,000
任何对这个键的设置，

1230
01:20:18,000 --> 01:20:23,100
在你从冷群集中删除之后，

1231
01:20:23,100 --> 01:20:25,800
你在两秒钟内不能对那个键做任何设置，

1232
01:20:26,400 --> 01:20:29,010
所以，这个 put 会被拒绝，

1233
01:20:31,790 --> 01:20:34,160
这只是在预热阶段，

1234
01:20:34,160 --> 01:20:36,500
当集群出现时，它是冷的，

1235
01:20:36,740 --> 01:20:38,900
在几个小时的运行之后，

1236
01:20:38,900 --> 01:20:40,550
开始预热，

1237
01:20:40,550 --> 01:20:42,230
并将其内容就位，

1238
01:20:42,500 --> 01:20:45,140
一旦热身完成，

1239
01:20:45,320 --> 01:20:47,360
他们就不再使用这个技巧了，

1240
01:20:47,510 --> 01:20:52,520
但是,针对这个问题，

1241
01:20:52,610 --> 01:20:55,610
他们认为两秒钟足够了，

1242
01:20:56,340 --> 01:21:02,670
这也足以让写入传播到冷数据库。

1243
01:21:05,090 --> 01:21:05,690
好的？

1244
01:21:09,240 --> 01:21:11,940
但还有一个写入问题是，

1245
01:21:11,940 --> 01:21:13,140
让我快速说一下，

1246
01:21:13,140 --> 01:21:14,640
因为你们已经提到了，

1247
01:21:15,060 --> 01:21:18,960
所以他们在论文中讨论的竞争 3 ，

1248
01:21:18,960 --> 01:21:19,860
我相信还有更多，

1249
01:21:19,860 --> 01:21:21,030
但是他们说的那个，

1250
01:21:21,030 --> 01:21:22,920
在论文中说的那个，

1251
01:21:23,190 --> 01:21:25,500
这是在不同区域之间，

1252
01:21:26,730 --> 01:21:29,760
它必须处理主备问题，

1253
01:21:30,030 --> 01:21:30,960
主备。

1254
01:21:32,200 --> 01:21:33,790
这是一个类似的问题，

1255
01:21:36,560 --> 01:21:42,980
客户端 1 写入到数据库，

1256
01:21:45,310 --> 01:21:46,270
数据库，

1257
01:21:47,350 --> 01:21:48,730
这是在 backup 的一个客户端，

1258
01:21:48,790 --> 01:21:51,310
这是在备区的客户端，

1259
01:21:51,310 --> 01:21:55,480
它写入主区域的数据库，

1260
01:21:55,980 --> 01:22:03,780
继续，然后删除这个键，

1261
01:22:04,080 --> 01:22:05,790
当然在备区域中，

1262
01:22:06,380 --> 01:22:07,760
从它的缓存中，

1263
01:22:08,180 --> 01:22:12,170
然后它会立即起作用，

1264
01:22:12,170 --> 01:22:13,730
你们中的一个提到了，

1265
01:22:13,730 --> 01:22:16,490
你可以获取那个 k ，

1266
01:22:16,880 --> 01:22:24,620
然后，不会看到，将从取回，

1267
01:22:27,120 --> 01:22:30,630
是的，它不会看到那个写入的结果，

1268
01:22:30,990 --> 01:22:34,560
所以我们不会看到它自己的写入，

1269
01:22:34,590 --> 01:22:38,610
因为写入还在到主或备的路上，

1270
01:22:38,610 --> 01:22:45,120
primary 通过 squeal 发送，

1271
01:22:45,120 --> 01:22:49,710
将更新传播到备区域中的数据库，

1272
01:22:49,710 --> 01:22:53,730
只有到那时，备区域，

1273
01:22:53,730 --> 01:22:55,950
在备区域中将看到 k 的变化，

1274
01:22:56,310 --> 01:22:58,350
所以我们这里有个问题，

1275
01:22:58,350 --> 01:23:04,140
如果这个 k 在没有任何修改的情况下继续，

1276
01:23:04,230 --> 01:23:07,440
那么，我们就看不到自己的写入了。

1277
01:23:07,930 --> 01:23:10,210
有人记得，他们是怎么解决这个问题的吗？

1278
01:23:13,630 --> 01:23:16,150
是远程标记吗？

1279
01:23:16,180 --> 01:23:17,650
是的，它是，

1280
01:23:17,650 --> 01:23:20,260
所以当他们删除键 k 时，

1281
01:23:20,590 --> 01:23:25,630
他们可能把它保存在 backup 的 memcached 中，

1282
01:23:25,630 --> 01:23:27,160
并将其标记为远程，

1283
01:23:30,490 --> 01:23:34,210
所以，当客户端 1 执行 get ，

1284
01:23:34,330 --> 01:23:37,330
它们会知道，嘿，我要获取，

1285
01:23:37,360 --> 01:23:41,680
从它的本地内存缓存远程取回，

1286
01:23:41,920 --> 01:23:49,200
然后从主区域获取它。

1287
01:23:54,910 --> 01:23:55,540
好的？

1288
01:23:59,220 --> 01:24:03,220
但之后远程标记将被移除，

1289
01:24:03,220 --> 01:24:06,130
当可以安全地从 backup 中读取时。

1290
01:24:06,160 --> 01:24:08,200
是的，我认为其中一个数据库，

1291
01:24:08,200 --> 01:24:12,160
备数据库从主数据库获取数据，

1292
01:24:12,220 --> 01:24:13,840
它可以移除标记，

1293
01:24:17,590 --> 01:24:21,280
因为这样就可以安全地从备数据库读取。

1294
01:24:24,430 --> 01:24:25,240
这能理解吗？

1295
01:24:28,000 --> 01:24:30,280
好的，让我做个简短的总结，

1296
01:24:32,160 --> 01:24:35,310
因为我已经有点超时了，

1297
01:24:35,310 --> 01:24:38,960
快速总结一下，缓存是至关重要的，

1298
01:24:42,100 --> 01:24:46,270
我们所讨论的这篇论文的能力，

1299
01:24:46,270 --> 01:24:48,850
每秒数十亿次操作，

1300
01:24:49,480 --> 01:24:52,990
有两种策略可以获得这种很高的能力，

1301
01:24:52,990 --> 01:24:54,040
一个是分区，

1302
01:24:57,990 --> 01:25:00,420
给你带来了并行性或分片，

1303
01:25:03,550 --> 01:25:06,160
另一种策略是复制，

1304
01:25:06,220 --> 01:25:07,840
对热键来说很好，

1305
01:25:08,970 --> 01:25:12,030
被很多客户端请求的键，

1306
01:25:12,120 --> 01:25:15,480
键被复制到多个机器上。

1307
01:25:16,350 --> 01:25:23,550
我们还看到，有很多特别的技术，

1308
01:25:23,550 --> 01:25:30,120
为了绕过一些出现的严重的一致性问题，

1309
01:25:30,150 --> 01:25:33,510
即使系统被设计成提供弱一致性，

1310
01:25:33,840 --> 01:25:36,060
所以，整个一致性，

1311
01:25:36,060 --> 01:25:46,040
在数据库和缓存 memcache 之间的是困难的，

1312
01:25:46,070 --> 01:25:48,980
可能比你想象的要复杂得多，

1313
01:25:49,220 --> 01:25:53,060
因为缓存可能成为问题，

1314
01:25:53,180 --> 01:25:55,700
正如你所看到的，这是相当困难的，

1315
01:25:55,790 --> 01:26:00,050
事实上，有更多的研究正在进行，

1316
01:26:00,050 --> 01:26:01,790
试图解决怎样才能做得更好。

1317
01:26:03,070 --> 01:26:04,660
好了，这是我想总结的，

1318
01:26:04,660 --> 01:26:06,580
那些需要走的人，可以走，

1319
01:26:06,580 --> 01:26:08,680
去参加他们的下一个 Zoom 会议，

1320
01:26:09,100 --> 01:26:10,690
我们会再见，

1321
01:26:10,750 --> 01:26:13,780
或者回答任何问题，如果你有任何问题，

1322
01:26:14,630 --> 01:26:17,840
否则，我们周四见，谢谢。

1323
01:26:21,780 --> 01:26:23,970
抱歉，我有个问题，

1324
01:26:24,870 --> 01:26:29,970
对于我们讨论的最后一件事，远程标记，

1325
01:26:30,850 --> 01:26:36,150
他们怎么知道这是一个相关的数据竞争，

1326
01:26:36,710 --> 01:26:38,300
或者他们是如何决定，

1327
01:26:38,420 --> 01:26:45,470
做这些额外的远程标记会更有用，

1328
01:26:45,590 --> 01:26:47,930
而不是只获取旧数据。

1329
01:26:47,990 --> 01:26:51,320
好的，我想这是因为他们事先有这个要求，

1330
01:26:51,320 --> 01:26:54,710
尽管论文并没有明确规定，

1331
01:26:55,070 --> 01:26:57,290
他们真的很想要这个，

1332
01:26:59,570 --> 01:27:04,700
比如，用户在他们的时间线上添加一些东西，

1333
01:27:05,180 --> 01:27:07,040
再读一遍，它不在那里了，

1334
01:27:07,640 --> 01:27:12,230
所以，这是用户可以直接观察到的东西，

1335
01:27:12,230 --> 01:27:14,420
奇怪的，不一致，

1336
01:27:14,420 --> 01:27:16,640
他们想要避免这种情况。

1337
01:27:19,600 --> 01:27:21,460
好的，理解了，理解了。

1338
01:27:21,670 --> 01:27:22,810
我的另一个问题是，

1339
01:27:22,810 --> 01:27:29,890
在最初的一张 memcache 失效的幻灯片上。

1340
01:27:30,100 --> 01:27:31,720
让我找找，我把它放在哪里了。

1341
01:27:34,140 --> 01:27:36,870
哦，这里。

1342
01:27:37,290 --> 01:27:41,640
是的，这是那个幻灯片，有一点乱。

1343
01:27:42,090 --> 01:27:44,940
哦，不是，是后面那一张。

1344
01:27:45,900 --> 01:27:48,960
有一些无效，或者它没有。

1345
01:27:50,550 --> 01:27:51,780
也许是下一张。

1346
01:27:52,440 --> 01:27:52,920
好的。

1347
01:27:52,950 --> 01:28:02,990
是的，所以客户端仅为本区域设置无效，

1348
01:28:02,990 --> 01:28:05,450
squeal 会取执行，

1349
01:28:06,080 --> 01:28:09,960
转移到非本地。

1350
01:28:09,990 --> 01:28:10,440
是的。

1351
01:28:10,850 --> 01:28:14,370
好的，理解了，非常感谢。

1352
01:28:14,400 --> 01:28:14,970
不用谢。

1353
01:28:16,620 --> 01:28:18,870
教授，我有两个。

1354
01:28:18,870 --> 01:28:20,790
你问了你的最后一个问题，

1355
01:28:22,350 --> 01:28:27,930
抱歉，抱歉，请继续提问。

1356
01:28:28,860 --> 01:28:30,270
这些都是课后的。

1357
01:28:30,540 --> 01:28:32,370
它们不算数。

1358
01:28:33,420 --> 01:28:39,420
所以，对于区域中分配的服务器，

1359
01:28:39,420 --> 01:28:42,720
当我们有集群时，每个都分配到集群中，是吗？

1360
01:28:43,430 --> 01:28:47,600
是的，每个集群都复制了。

1361
01:28:48,170 --> 01:28:49,550
好的，很好，是的。

1362
01:28:49,790 --> 01:28:54,610
我的意思是，服务器被分配给一个复制。

1363
01:28:56,110 --> 01:29:02,020
好的，然后第二个是论文中很明确，

1364
01:29:02,020 --> 01:29:05,950
但它说的，好的，这里，

1365
01:29:06,680 --> 01:29:10,670
我想，在第二页的通用缓存页中，

1366
01:29:11,090 --> 01:29:17,540
它说使用 memcache 作为更通用的键值存储，

1367
01:29:17,630 --> 01:29:19,130
特别说到，

1368
01:29:19,160 --> 01:29:24,500
新服务利用现有的基础设施只需付出很小的努力，

1369
01:29:24,500 --> 01:29:29,390
而没有调整、优化、配置、维护大型服务器集群的负担，

1370
01:29:29,390 --> 01:29:31,070
我不确定，我看了看，

1371
01:29:31,070 --> 01:29:34,880
我找不到现有的基础设施是什么。

1372
01:29:34,970 --> 01:29:37,280
我其实不知道他们指的是什么，所以。

1373
01:29:37,310 --> 01:29:41,380
好的，好的，谢谢。

1374
01:29:42,430 --> 01:29:42,850
[]。

1375
01:29:43,460 --> 01:29:44,780
再见。

1376
01:29:49,200 --> 01:29:51,330
我想问一个问题，

1377
01:29:51,330 --> 01:29:54,720
我想你说了某种失败模式，

1378
01:29:54,840 --> 01:29:57,570
如果 memcached 服务器出现故障，

1379
01:29:58,540 --> 01:30:00,520
我觉得，

1380
01:30:00,520 --> 01:30:03,520
我在想哪张幻灯片会对我有所帮助，

1381
01:30:05,100 --> 01:30:08,100
早一点，

1382
01:30:08,220 --> 01:30:09,930
也许是刚才那个，

1383
01:30:11,240 --> 01:30:12,950
任何显示 memcached 的，

1384
01:30:12,950 --> 01:30:15,410
我想是整个系统图。

1385
01:30:15,470 --> 01:30:17,390
好的，有多个[]，

1386
01:30:18,200 --> 01:30:22,010
但如果你愿意的话，你可以认为这是一个集群。

1387
01:30:22,070 --> 01:30:22,910
好的，好的。

1388
01:30:23,660 --> 01:30:25,520
好的。

1389
01:30:25,520 --> 01:30:26,780
查找另一个，

1390
01:30:26,780 --> 01:30:28,700
但我认为这可能已经足够了。

1391
01:30:29,180 --> 01:30:30,830
是的，我觉得这很好，

1392
01:30:32,620 --> 01:30:35,590
是的，我想这个问题是，

1393
01:30:36,310 --> 01:30:40,360
所以，试着，

1394
01:30:40,480 --> 01:30:42,310
但这就像是，

1395
01:30:42,460 --> 01:30:47,080
如果客户端前端写入，

1396
01:30:48,540 --> 01:30:51,930
是的，如果客户端向它的 memcached 服务器写入，

1397
01:30:52,140 --> 01:30:54,810
然后那个 memcached 服务器崩溃，

1398
01:30:54,870 --> 01:30:56,790
然后客户端立即尝试，

1399
01:30:56,820 --> 01:31:00,660
然后可能会切换到另一台 memcached 服务器，

1400
01:31:00,660 --> 01:31:01,890
然后再次读取，

1401
01:31:02,780 --> 01:31:07,250
什么机制确保它不会看到它之前写入的结果。

1402
01:31:07,250 --> 01:31:10,130
我认为发生的事情是，我们很可能会去 Gutter ，

1403
01:31:12,500 --> 01:31:14,660
当 memcached 失败时，

1404
01:31:14,660 --> 01:31:17,210
客户端将不会收到响应，

1405
01:31:17,940 --> 01:31:21,390
当没有回应的时候，

1406
01:31:21,390 --> 01:31:22,620
它会去 Gutter ，

1407
01:31:22,620 --> 01:31:23,910
里面什么都没有，

1408
01:31:24,270 --> 01:31:26,460
可能在第一次尝试时，

1409
01:31:26,670 --> 01:31:28,920
将从数据库中读取它。

1410
01:31:31,230 --> 01:31:34,620
哦，好的，理解了。

1411
01:31:35,410 --> 01:31:36,760
是的，这有一点不清楚，

1412
01:31:36,760 --> 01:31:38,890
当添加一台新机器时到底会发生什么，

1413
01:31:38,920 --> 01:31:41,020
他们并没有在论文中谈论太多，

1414
01:31:41,740 --> 01:31:45,130
我认为这是一致性部分，

1415
01:31:45,160 --> 01:31:49,000
其中键自动从一台机器转移到另一台机器。

1416
01:31:51,530 --> 01:31:56,340
我想，如果有多个集群，

1417
01:31:56,730 --> 01:31:58,470
难道不是，

1418
01:31:58,650 --> 01:32:00,330
或许我只需要从 Gutter 中读取，

1419
01:32:00,330 --> 01:32:03,330
但它会不会潜在地转移到另一个 memcached ，

1420
01:32:03,330 --> 01:32:05,280
哦，是的。

1421
01:32:05,280 --> 01:32:08,040
我想每次 get 失败时，

1422
01:32:08,570 --> 01:32:09,770
客户端去 Gutter 。

1423
01:32:10,460 --> 01:32:11,330
好的。

1424
01:32:12,120 --> 01:32:14,670
好的，是的，这些集群是自己管理的，

1425
01:32:15,000 --> 01:32:16,440
每个都有 memcached 。

1426
01:32:16,650 --> 01:32:20,600
好的，好的，理解了，谢谢。

1427
01:32:20,900 --> 01:32:21,320
不用谢。

1428
01:32:21,320 --> 01:32:23,180
跟进这个问题，

1429
01:32:23,210 --> 01:32:24,680
当它到 Gutter 时，

1430
01:32:24,680 --> 01:32:27,830
如果两个不同的集群，

1431
01:32:27,950 --> 01:32:30,890
它们的 memcache 服务器同时出现故障，

1432
01:32:30,890 --> 01:32:32,450
所以它们都去了 Gutter ，

1433
01:32:32,660 --> 01:32:35,360
现在对 Gutter 进行并发写入，

1434
01:32:35,840 --> 01:32:39,410
我们如何确保这些写入不会打乱顺序？

1435
01:32:40,870 --> 01:32:43,270
它们执行设置，

1436
01:32:43,990 --> 01:32:51,480
写操作总是到数据库到 primary ，

1437
01:32:51,480 --> 01:32:52,800
primary 对它们进行排序，

1438
01:32:55,260 --> 01:32:56,910
我想写入总是有顺序的，

1439
01:32:58,930 --> 01:33:03,110
客户端可能会做的唯一一件事是

1440
01:33:03,110 --> 01:33:06,620
set 或 put 一个值到 kv 服务器，

1441
01:33:07,710 --> 01:33:10,920
但它们必须之后从数据库读取。

1442
01:33:13,370 --> 01:33:17,420
好的，如果有人执行一个读取，

1443
01:33:17,900 --> 01:33:20,390
然后他们将其设置到数据库中，

1444
01:33:20,390 --> 01:33:23,840
假设两个不同的集群失败，

1445
01:33:23,990 --> 01:33:27,410
我不确定这是否可能，

1446
01:33:27,410 --> 01:33:33,020
但是假如集群 1 首先读取键，获取到值，

1447
01:33:33,110 --> 01:33:34,940
然后在中间有一个写入，

1448
01:33:35,150 --> 01:33:37,580
然后，第二个集群读取，

1449
01:33:37,610 --> 01:33:40,280
然后它们都试着放入它们的 memcache 服务器，

1450
01:33:40,700 --> 01:33:44,990
但是，假设这些服务器出了故障。

1451
01:33:44,990 --> 01:33:46,370
是的，也许，也许，

1452
01:33:46,370 --> 01:33:48,470
是的，这是个好问题，

1453
01:33:48,470 --> 01:33:50,060
我认为有各种各样的边界情况，

1454
01:33:50,060 --> 01:33:51,380
没有描述这个情况，

1455
01:33:51,470 --> 01:33:53,390
我觉得租约也许能帮上忙，

1456
01:33:53,390 --> 01:33:57,620
因为你要设置的服务器有租约，

1457
01:33:57,860 --> 01:34:03,710
我们第一次拿回了设置的租约，

1458
01:34:04,210 --> 01:34:09,220
在此期间，

1459
01:34:09,220 --> 01:34:10,420
服务器被替换，

1460
01:34:10,630 --> 01:34:14,320
替换的服务器不知道租约已被授予，

1461
01:34:14,740 --> 01:34:16,300
因此会拒绝设置，

1462
01:34:18,410 --> 01:34:19,640
我只是在猜测。

1463
01:34:19,940 --> 01:34:23,030
好的，是的，所以对于 Gutter 来说，

1464
01:34:23,030 --> 01:34:24,980
它是如何控制租约的？

1465
01:34:25,460 --> 01:34:26,330
我不知道。

1466
01:34:26,630 --> 01:34:28,280
好的，我明白了。

1467
01:34:28,830 --> 01:34:31,500
抱歉，我可以推测，

1468
01:34:31,500 --> 01:34:34,500
但是，其实我不知道。

1469
01:34:36,430 --> 01:34:38,260
如果让你去推测，你会怎么说？

1470
01:34:39,100 --> 01:34:41,380
好的，我得先去坐下来，

1471
01:34:41,380 --> 01:34:42,490
好好想一想。

1472
01:34:43,270 --> 01:34:46,210
好的，有道理，是的，谢谢。

1473
01:34:49,120 --> 01:34:50,770
我有一个离题的问题，

1474
01:34:50,770 --> 01:34:53,440
我认为这很酷，

1475
01:34:53,440 --> 01:34:57,250
他们对 get 请求使用 UDP ，对其他请求使用 TCP ，

1476
01:34:57,250 --> 01:34:58,960
我想知道这有多普遍，

1477
01:34:58,960 --> 01:35:02,380
这是一件非常标准的事情吗？

1478
01:35:02,500 --> 01:35:05,380
是的，是的，也不是，

1479
01:35:06,320 --> 01:35:11,120
它是，我认为人们通常更喜欢使用 TCP

1480
01:35:11,300 --> 01:35:13,820
提供可靠性排序和所有好的东西，

1481
01:35:14,030 --> 01:35:15,710
但它有开销，

1482
01:35:15,740 --> 01:35:19,580
需要维护连接的状态，

1483
01:35:19,580 --> 01:35:20,690
对于连接，

1484
01:35:20,960 --> 01:35:22,790
所以总会有一些挣扎，

1485
01:35:22,790 --> 01:35:26,090
当机器有大量传入的 TCP 连接时，

1486
01:35:26,090 --> 01:35:27,800
有很多出站连接，

1487
01:35:27,800 --> 01:35:29,150
这总会带来问题，

1488
01:35:29,660 --> 01:35:34,070
在默认情况下，如果你遇到这个问题，

1489
01:35:34,070 --> 01:35:35,690
基本上是做 UDP 类型的东西。

1490
01:35:38,580 --> 01:35:39,090
有时候。

1491
01:35:39,090 --> 01:35:41,250
这篇论文中的是正常的吗？

1492
01:35:41,610 --> 01:35:44,040
不，不是从这篇论文。

1493
01:35:45,990 --> 01:35:50,250
有些人喜欢在 UDP 上使用他们自己的类似可靠传输协议的技术。

1494
01:35:51,040 --> 01:35:51,940
比如 QUIC ？

1495
01:35:52,460 --> 01:35:53,810
是的，是个例子。

1496
01:35:55,800 --> 01:36:01,590
因为他们提到他们也做了 UDP 连接的序列号。

1497
01:36:02,960 --> 01:36:06,620
但毫无疑问地[]拥塞窗口和所有其他扩展，

1498
01:36:06,620 --> 01:36:08,990
以及 TCP 拥有的所有其他 TCP 功能。

1499
01:36:10,650 --> 01:36:11,640
谢谢。

1500
01:36:11,940 --> 01:36:12,570
不用谢。

1501
01:36:18,300 --> 01:36:20,900
所以，另一个，糟糕，抱歉，请继续。

1502
01:36:25,180 --> 01:36:29,200
好的，我想，我是想快速问一下

1503
01:36:29,850 --> 01:36:32,460
不同集群之间的复制，

1504
01:36:32,670 --> 01:36:35,730
但是，它们不会进行任何正式的复制。

1505
01:36:35,730 --> 01:36:36,630
是的，没错，

1506
01:36:36,660 --> 01:36:41,670
好的，不，好的，是或不是，

1507
01:36:41,670 --> 01:36:44,340
因为数据库需要更新，

1508
01:36:45,120 --> 01:36:45,960
等等，等等，

1509
01:36:45,960 --> 01:36:47,130
让我回去一下，

1510
01:36:47,130 --> 01:36:49,530
确保知道你在说什么。

1511
01:36:51,070 --> 01:36:52,330
让我们来看看集群，

1512
01:36:54,120 --> 01:36:55,380
是的，我们有多个集群，

1513
01:36:55,530 --> 01:36:58,110
是的，集群之间没有真正的复制，

1514
01:36:58,110 --> 01:36:59,790
因为只有一个存储。

1515
01:37:01,890 --> 01:37:06,780
好的，所以有一些类似于根据这些租约

1516
01:37:06,780 --> 01:37:09,570
来保持缓存最新或者。

1517
01:37:10,260 --> 01:37:12,540
每个集群都是完全独立的，

1518
01:37:13,380 --> 01:37:14,730
它们之间没有任何关系，

1519
01:37:15,820 --> 01:37:19,120
用户根据这些[]拆分，

1520
01:37:20,280 --> 01:37:22,260
所以，一个用户访问一个集群，

1521
01:37:22,260 --> 01:37:29,250
然后在集群内部，他们使用租约或，

1522
01:37:31,630 --> 01:37:35,110
这个数据库使租约和键无效。

1523
01:37:36,650 --> 01:37:37,610
好的，明白了，好的，

1524
01:37:37,640 --> 01:37:40,430
是的，所以就像 squeal 和存储。

1525
01:37:41,570 --> 01:37:45,380
是的，所有的写入都会通过这个存储，

1526
01:37:45,740 --> 01:37:47,180
所有的写入都要经过这里，

1527
01:37:49,240 --> 01:37:50,410
它们被排序了，

1528
01:37:51,260 --> 01:37:54,080
它们会发出失效消息。

1529
01:37:57,660 --> 01:37:59,160
明白了，谢谢。

1530
01:38:03,320 --> 01:38:04,940
好的，继续。

1531
01:38:04,970 --> 01:38:09,320
是的，所以这个离题的问题，

1532
01:38:10,400 --> 01:38:11,810
我想我不确定，

1533
01:38:11,810 --> 01:38:15,230
因为我们在课堂上展示论文的方式，

1534
01:38:15,350 --> 01:38:18,080
但这看起来有点像，

1535
01:38:18,780 --> 01:38:21,750
这些系统的开发方式是，

1536
01:38:21,750 --> 01:38:25,360
比如，好的，我们有这样的系统，

1537
01:38:25,360 --> 01:38:27,130
我们的需求在继续扩大，

1538
01:38:27,130 --> 01:38:30,580
所以我们，也许这也不是一个准确的表达，

1539
01:38:30,580 --> 01:38:35,430
但这听起来像是，让我们再增加一层来处理这个负载，

1540
01:38:35,430 --> 01:38:37,380
或者缓存的东西，

1541
01:38:37,380 --> 01:38:40,380
或者在它上面增加另一层复杂性，

1542
01:38:40,980 --> 01:38:43,110
这样说是否公平，

1543
01:38:43,110 --> 01:38:45,360
系统开发通常是这样的，

1544
01:38:45,540 --> 01:38:48,480
让我们再加一层来处理。

1545
01:38:48,920 --> 01:38:50,690
是或不是，

1546
01:38:50,750 --> 01:38:53,990
我认为设计者采取了非常务实的方式，

1547
01:38:53,990 --> 01:38:57,620
弄清楚遇到了真正的问题，解决真正的问题，

1548
01:38:58,280 --> 01:39:03,050
从根本上来说，并不是很多额外的机制，

1549
01:39:03,860 --> 01:39:05,480
才能让这一切正常工作，

1550
01:39:05,780 --> 01:39:07,250
所以从这个角度来说，

1551
01:39:07,760 --> 01:39:11,900
我的意思是，这种性能是非常令人印象深刻的，

1552
01:39:11,900 --> 01:39:13,430
使用现成的组件，

1553
01:39:14,090 --> 01:39:18,680
当然，人们也会偶尔回去，

1554
01:39:18,680 --> 01:39:22,640
我该如何设计一个系统来获得更好的性能，

1555
01:39:22,910 --> 01:39:26,480
不会有数据库和缓存之间的这种不一致，

1556
01:39:27,120 --> 01:39:32,010
这实际上是一个研究问题，

1557
01:39:32,370 --> 01:39:34,590
因为人们知道如何做到这一点，

1558
01:39:34,590 --> 01:39:38,250
你会看到描述替代解决方案的最新研究论文，

1559
01:39:39,680 --> 01:39:41,630
或解决方案的新组件，

1560
01:39:41,630 --> 01:39:44,780
因为我所知道的[]，

1561
01:39:45,080 --> 01:39:47,210
不能支持每秒 10 亿次操作。

1562
01:39:47,770 --> 01:39:49,030
是的，好的。

1563
01:39:50,880 --> 01:39:52,800
好的，这很有趣，谢谢。

1564
01:39:52,950 --> 01:39:54,750
是的，这是很吸引人的东西，

1565
01:39:54,900 --> 01:39:57,780
这是一个真实世界的系统设计。

1566
01:39:59,040 --> 01:40:01,110
如果你不介意的话，我还有一个问题。

1567
01:40:01,290 --> 01:40:02,340
是的，继续。

1568
01:40:02,370 --> 01:40:05,160
所以在这里的设计中，

1569
01:40:05,160 --> 01:40:07,320
它们在不同的地区复制，

1570
01:40:07,470 --> 01:40:11,160
抱歉，我要确认第一个问题是，

1571
01:40:11,190 --> 01:40:13,170
当它们在不同的区域表现良好时，

1572
01:40:13,200 --> 01:40:16,680
每个区域都有一堆内部集群，对吧。

1573
01:40:17,880 --> 01:40:21,330
然后，我的后续问题是，

1574
01:40:21,360 --> 01:40:22,650
看起来一切都是，

1575
01:40:22,650 --> 01:40:24,960
是的，所有东西都在访问主存储，

1576
01:40:25,500 --> 01:40:27,540
假设我们想要扩大规模，

1577
01:40:27,540 --> 01:40:31,140
这样我们不会让所有写操作都命中主存储，

1578
01:40:31,680 --> 01:40:33,900
你将如何着手设计。

1579
01:40:33,930 --> 01:40:36,420
是的，我的想法是，

1580
01:40:36,420 --> 01:40:39,540
它们是一种设计描述，

1581
01:40:39,540 --> 01:40:41,870
好的，这里有很多要点，

1582
01:40:41,870 --> 01:40:43,940
关于这个主题还有一整篇论文

1583
01:40:43,940 --> 01:40:45,650
是关于如何进行复制的，

1584
01:40:46,340 --> 01:40:49,640
这并不是 Facebook 上唯一一篇关于扩大规模的论文，

1585
01:40:49,670 --> 01:40:53,270
有一个系统是在 2015 年或[]发布的，

1586
01:40:53,850 --> 01:40:58,860
他们有一个可扩展的设计来传播这些写入，

1587
01:40:59,220 --> 01:41:01,680
我的想法也是，

1588
01:41:01,680 --> 01:41:08,130
他们会根据用户分片到不同的区域，

1589
01:41:08,620 --> 01:41:13,300
并使一些区域作为那些用户的 primary 。

1590
01:41:16,040 --> 01:41:20,360
我明白了，所以他们为不同的分片分配了不同的区域 primary 。

1591
01:41:20,570 --> 01:41:21,470
是的，我想是的，

1592
01:41:21,620 --> 01:41:23,330
这是我会做的，尝试做的，

1593
01:41:24,370 --> 01:41:26,020
我在这里推测。

1594
01:41:28,170 --> 01:41:32,910
像跨存储层的共识协议是不是明智的决定，

1595
01:41:32,910 --> 01:41:35,610
或者会不会太高了。

1596
01:41:35,610 --> 01:41:38,040
你可以这样做，比如 Spanner 这样做了。

1597
01:41:39,410 --> 01:41:39,920
是的。

1598
01:41:40,280 --> 01:41:41,540
Spanner 有多快？

1599
01:41:43,140 --> 01:41:43,860
挺快的。

1600
01:41:44,570 --> 01:41:47,600
你回取看看，看看表格，

1601
01:41:47,870 --> 01:41:49,640
每秒可以处理多少事务？

1602
01:41:51,040 --> 01:41:54,070
我记不清确切的数字了。

1603
01:41:54,560 --> 01:41:55,700
我想大概有一百个。

1604
01:41:57,690 --> 01:41:58,260
哦，哦。

1605
01:41:58,260 --> 01:42:00,300
事实上，我想写入是 10 。

1606
01:42:01,400 --> 01:42:03,740
是的，这是写入事务。

1607
01:42:04,010 --> 01:42:06,770
是的，写入事务很慢。

1608
01:42:11,550 --> 01:42:14,910
抱歉，我想我意识到，

1609
01:42:14,910 --> 01:42:17,220
我不理解竞争 1 。

1610
01:42:17,710 --> 01:42:21,190
好的，让我看看能不能复制它，

1611
01:42:22,960 --> 01:42:25,480
让我们看看竞争 1 在哪里。

1612
01:42:27,490 --> 01:42:30,520
我想我只是搞不懂什么是 v2 。

1613
01:42:32,350 --> 01:42:34,300
v2 是右边这个，

1614
01:42:35,660 --> 01:42:36,800
稍等，我来做个记号。

1615
01:42:39,360 --> 01:42:39,960
好的。

1616
01:42:42,430 --> 01:42:43,900
问题是，

1617
01:42:43,900 --> 01:42:48,280
它是夹在第一个中间。

1618
01:42:51,810 --> 01:42:52,470
好的。

1619
01:42:55,100 --> 01:42:59,990
好的，我们想把它删除，

1620
01:42:59,990 --> 01:43:02,510
以便下一个人可以读取，

1621
01:43:03,400 --> 01:43:04,930
从数据库中刷新它，

1622
01:43:04,960 --> 01:43:07,120
但现在它仍然保持着旧的值。

1623
01:43:07,150 --> 01:43:09,370
是的，所以我们有一个永久稳定的值，

1624
01:43:09,400 --> 01:43:11,320
真正的问题是这个永久的[业务]，

1625
01:43:13,090 --> 01:43:15,010
或者带引号的 permanent ，

1626
01:43:15,010 --> 01:43:16,150
因为这是个缓存，

1627
01:43:16,390 --> 01:43:19,570
但是这个 put ，

1628
01:43:20,060 --> 01:43:28,670
之后 k 被更新为 v2 ，

1629
01:43:28,670 --> 01:43:30,980
所以我们这里有 k 2 ，

1630
01:43:30,980 --> 01:43:32,390
这是正确的值，

1631
01:43:32,780 --> 01:43:34,640
这里实际上是 v1 ，

1632
01:43:34,640 --> 01:43:35,870
所以我们假设只有 1 ，

1633
01:43:36,440 --> 01:43:37,460
我们在这里所做的是，

1634
01:43:37,460 --> 01:43:41,150
我们 put(k,1) 之后，

1635
01:43:43,220 --> 01:43:44,660
这不是一件正确的事情，

1636
01:43:47,440 --> 01:43:52,060
每个这个之后的，执行 get k ，

1637
01:43:52,060 --> 01:43:53,680
会获得 1 而不是 2 。

1638
01:43:54,540 --> 01:43:55,890
好的，理解了，好的。

1639
01:43:55,890 --> 01:43:58,860
包括客户端 2 ，这将是奇怪的。

1640
01:43:59,770 --> 01:44:03,550
好的，好的，理解了，非常感谢。

1641
01:44:03,610 --> 01:44:04,210
不用谢。

1642
01:44:04,950 --> 01:44:07,890
我想开始关于进化的部分，

1643
01:44:07,890 --> 01:44:10,260
我认为也很有帮助。

1644
01:44:10,290 --> 01:44:11,670
好的，很好。

1645
01:44:11,760 --> 01:44:13,320
非常感谢。

1646
01:44:13,380 --> 01:44:14,100
不用谢。

