1
00:00:00,450 --> 00:00:01,290
谢谢。

2
00:00:01,470 --> 00:00:05,400
好的，下午好，早上好，傍晚好，晚上好，无论你在哪里，

3
00:00:06,180 --> 00:00:10,230
所以今天我想谈谈 zookeeper ，

4
00:00:10,230 --> 00:00:12,690
以及它的背景，

5
00:00:12,720 --> 00:00:15,300
我们今天布置的论文，

6
00:00:15,300 --> 00:00:16,770
是 2010 年的。

7
00:00:17,890 --> 00:00:23,710
所以我们会回顾上几节课的内容，

8
00:00:23,710 --> 00:00:26,170
我想我们在 raft 上了解相当多的细节，

9
00:00:26,170 --> 00:00:29,530
包括查看代码，

10
00:00:29,560 --> 00:00:32,530
从现在开始的课程将更加概念化，

11
00:00:32,800 --> 00:00:38,170
探索分布式系统 zookeeper 的想法，

12
00:00:38,740 --> 00:00:43,000
而 zookeeper 是与我们有关系的，

13
00:00:43,300 --> 00:00:46,360
因为它有一点关系

14
00:00:46,360 --> 00:00:47,920
正如我们将在实验 3 中看到的。

15
00:00:48,970 --> 00:00:52,420
所以，它允许我们讨论实验 3 的一些属性，

16
00:00:52,420 --> 00:00:54,130
特别是线性一致性，

17
00:00:54,760 --> 00:00:57,580
但 zookeeper 更重要的，

18
00:00:57,580 --> 00:00:58,270
它很有趣，

19
00:00:58,270 --> 00:01:05,350
因为它是一个在实践中广泛使用的系统，

20
00:01:07,700 --> 00:01:12,350
来自 Apache ，来自雅虎，

21
00:01:12,350 --> 00:01:15,200
是一个开源的 Apache 项目，

22
00:01:15,200 --> 00:01:17,120
它仍然是活跃的。

23
00:01:17,910 --> 00:01:21,660
对我们来说特别有趣的是，

24
00:01:21,870 --> 00:01:24,480
在今天这样的课程中，是高性能，

25
00:01:25,110 --> 00:01:26,700
高性能，我的意思是，

26
00:01:26,820 --> 00:01:31,770
比实验 3 要高得多的性能。

27
00:01:32,840 --> 00:01:36,020
关于这一点，我会详细地谈一谈，

28
00:01:36,380 --> 00:01:39,260
它之所以高性能，有两个原因，

29
00:01:39,260 --> 00:01:42,740
一个是，它的客户端操作是异步的，

30
00:01:47,180 --> 00:01:49,610
这里高性能的意思是，

31
00:01:49,610 --> 00:01:54,020
系统每秒可以处理更多的操作，

32
00:01:54,020 --> 00:01:55,940
所以它是一个吞吐量指标，

33
00:01:56,480 --> 00:01:59,990
第二个高性能的原因是，

34
00:01:59,990 --> 00:02:02,510
它没有提供强一致性，

35
00:02:02,540 --> 00:02:10,900
它有一个有趣的一致性定义，

36
00:02:11,500 --> 00:02:12,850
它给了我们一些自由

37
00:02:12,880 --> 00:02:16,240
可以在任何复制上执行读取操作，

38
00:02:16,420 --> 00:02:18,250
因此读取[]是可以扩展的。

39
00:02:19,700 --> 00:02:23,030
然后 zookeeper 有趣的第二个方面是，

40
00:02:23,030 --> 00:02:24,680
除了高性能之外，

41
00:02:24,890 --> 00:02:26,390
它是一种通用的，

42
00:02:26,390 --> 00:02:28,310
他们称之为协调服务，

43
00:02:35,260 --> 00:02:37,330
这里的重点是，

44
00:02:37,330 --> 00:02:39,220
有很多应用程序，

45
00:02:39,550 --> 00:02:44,920
你需要跟踪哪些是这个集群的一部分，

46
00:02:44,920 --> 00:02:46,210
以及谁是 master ，

47
00:02:46,750 --> 00:02:50,920
所以想想 mapreduce 或 GFS ，

48
00:02:50,920 --> 00:02:53,410
GFS 中的 master 需要跟踪

49
00:02:53,410 --> 00:02:54,670
或者每个块，

50
00:02:54,820 --> 00:02:56,950
谁是服务的服务器，

51
00:02:56,950 --> 00:03:00,130
那个服务块是 master ，

52
00:03:00,820 --> 00:03:03,760
所以跟踪配置信息，

53
00:03:03,760 --> 00:03:06,490
来自许多不同的分布式应用程序中，

54
00:03:06,730 --> 00:03:09,970
zookeeper 是为了支持这种东西而设计的，

55
00:03:09,970 --> 00:03:14,260
所以你可以把所有的配置管理交给 zookeeper ，

56
00:03:14,560 --> 00:03:18,910
然后专注于你的应用程序其他部分的开发，

57
00:03:18,910 --> 00:03:21,880
你的分布式系统的其他方面。

58
00:03:22,860 --> 00:03:25,470
好的，这是一个简短的介绍，

59
00:03:25,470 --> 00:03:28,080
我们要讨论的话题。

60
00:03:30,350 --> 00:03:32,960
像往常一样，你可以随时打断我，

61
00:03:33,470 --> 00:03:37,130
或者在聊天中发布一些东西，

62
00:03:37,190 --> 00:03:38,930
让我来调出聊天。

63
00:03:40,670 --> 00:03:48,440
好的，我们从 zookeeper 的基础开始，复制状态机，

64
00:03:58,730 --> 00:04:02,450
像我们所看到的复制状态机一样。

65
00:04:02,750 --> 00:04:05,900
所以，让我们来画一个通常的图，

66
00:04:06,110 --> 00:04:07,580
我们有一些服务器，

67
00:04:07,700 --> 00:04:08,480
在这种情况下，

68
00:04:08,480 --> 00:04:10,790
它将是 zookeeper ZK 。

69
00:04:11,670 --> 00:04:14,850
它接收来自客户端的请求，

70
00:04:14,850 --> 00:04:17,790
创建 znode ，

71
00:04:17,850 --> 00:04:25,590
它分发这些操作的方式，

72
00:04:25,590 --> 00:04:27,480
它有一个独立的库，

73
00:04:27,480 --> 00:04:30,030
把这个想象成跟 raft 库类似，

74
00:04:30,480 --> 00:04:32,370
在他们的情况下，它被称为 ZAB 。

75
00:04:34,620 --> 00:04:39,960
基本上，领导者把操作放入

76
00:04:39,960 --> 00:04:42,480
相当于 raft 库的地方，

77
00:04:42,480 --> 00:04:49,020
与其他库或其他节点进行交互，

78
00:04:49,440 --> 00:04:52,500
这创建一个日志，

79
00:04:52,830 --> 00:04:56,010
通过所有这些操作和这些机器，

80
00:04:56,820 --> 00:05:00,570
然后操作的日志返回给[]，

81
00:05:00,570 --> 00:05:05,070
在我们的示例中，通过 apply channel 给服务，

82
00:05:05,070 --> 00:05:07,260
服务应用该操作以响应客户端，

83
00:05:07,290 --> 00:05:10,300
所以，我们有不同的[]在运行。

84
00:05:11,090 --> 00:05:16,670
到目前为止，在实验里，主要专注于，

85
00:05:16,670 --> 00:05:19,040
实验 2 是关于这一部分，

86
00:05:21,000 --> 00:05:24,390
在我们的示例中，实现 raft ，而不是 ZAB ，

87
00:05:24,690 --> 00:05:27,810
从一个很高的级别来看，

88
00:05:27,810 --> 00:05:31,950
你可以把 ZAB 当成另一个 raft ，

89
00:05:31,950 --> 00:05:34,500
提供类似的保证，

90
00:05:34,500 --> 00:05:36,450
但是实现方式不同，

91
00:05:36,750 --> 00:05:41,400
它提供了所有操作的顺序，

92
00:05:41,460 --> 00:05:45,150
[]故障，网络分区等等，

93
00:05:45,180 --> 00:05:47,280
不会有脑裂的问题，

94
00:05:47,280 --> 00:05:51,120
都是与 raft 库联系在一起的东西。

95
00:05:51,900 --> 00:05:56,970
我们在实验 3 要关注的是，

96
00:05:56,970 --> 00:05:58,650
在它上面实现一个服务，

97
00:05:58,890 --> 00:06:03,750
这篇论文讨论的了 zookeeper 协调服务，

98
00:06:03,780 --> 00:06:06,480
我们将在实验 3 中实现键值存储，

99
00:06:12,400 --> 00:06:15,760
数据结构只是从键到值的映射。

100
00:06:16,690 --> 00:06:20,530
所以我们在那里支持的操作是 put 和 get ，

101
00:06:22,650 --> 00:06:26,400
所以客户端可能发送 put get 操作给服务，

102
00:06:26,400 --> 00:06:28,290
服务通过 raft 运行，

103
00:06:28,590 --> 00:06:31,950
然后将它们逐个应用到键值存储。

104
00:06:32,810 --> 00:06:35,930
在 zookeeper 中，结构略有不同，

105
00:06:35,930 --> 00:06:37,730
这里有一个 znode 组成的树，

106
00:06:38,180 --> 00:06:40,700
但基本的操作是应用相同的，

107
00:06:40,700 --> 00:06:45,450
下层的 ZAB 库，

108
00:06:45,450 --> 00:06:47,370
ZAB 库对所有操作进行排序，

109
00:06:47,370 --> 00:06:49,740
以相同的顺序应用到所有的副本，

110
00:06:49,920 --> 00:06:51,960
因为它们都以相同的顺序应用，

111
00:06:51,960 --> 00:06:53,520
没有非确定性的（操作），

112
00:06:53,820 --> 00:06:57,360
每个副本上的结果状态将是相同的。

113
00:07:00,480 --> 00:07:01,080
好的?

114
00:07:01,980 --> 00:07:06,480
这是这篇论文的基本背景，

115
00:07:06,600 --> 00:07:09,240
也是它们之间的关系，

116
00:07:09,240 --> 00:07:13,620
实验 3 和 zookeeper 服务之间的（关系）。

117
00:07:14,280 --> 00:07:16,320
在这节课中，主要讨论的是

118
00:07:16,320 --> 00:07:18,360
关注 zookeeper 本身，

119
00:07:18,360 --> 00:07:19,920
不讨论 ZAB ，

120
00:07:20,280 --> 00:07:21,780
因为你会认为，

121
00:07:21,780 --> 00:07:25,620
它和我们在实验 2 做的事情很相似。

122
00:07:28,370 --> 00:07:31,340
好的，我们稍微谈谈，

123
00:07:31,490 --> 00:07:34,730
你会看到什么样的性能，

124
00:07:34,820 --> 00:07:37,040
如果完成实验 3 ，

125
00:07:37,650 --> 00:07:42,690
并且测量每秒通过的 put 或 get 操作，

126
00:07:42,780 --> 00:07:47,370
因为这篇论文的一个成功就是高性能。

127
00:07:47,760 --> 00:07:49,260
所以让我们稍微想一想，

128
00:07:49,650 --> 00:07:52,290
我们假设有一个 put 操作进来，

129
00:07:54,360 --> 00:07:56,490
并且 put 操作是由领导者进来的，

130
00:07:56,490 --> 00:07:58,320
所以我们选择正常的情况，

131
00:07:58,320 --> 00:08:00,060
比如标准的情况，一切都正常，

132
00:08:00,060 --> 00:08:01,770
没有网络故障，分区，没有任何事情，

133
00:08:01,800 --> 00:08:03,120
一切都很完美。

134
00:08:03,570 --> 00:08:04,620
这是领导者，

135
00:08:04,710 --> 00:08:06,000
我们有两个跟随者。

136
00:08:09,390 --> 00:08:13,320
现在可能协议[完全地]，

137
00:08:13,590 --> 00:08:15,060
第一件事当然是，

138
00:08:15,060 --> 00:08:17,340
领导者调用 start ，

139
00:08:17,840 --> 00:08:26,080
start 写入 put 操作到领导者的日志，

140
00:08:26,260 --> 00:08:30,670
然后领导者将它的日志传播给其他跟随者，

141
00:08:31,360 --> 00:08:34,210
在它并行发生前，

142
00:08:34,810 --> 00:08:35,890
发送那个参数，

143
00:08:35,980 --> 00:08:37,660
让我稍微重画一下，

144
00:08:40,020 --> 00:08:46,650
它几乎同时向不同的跟随者发出一系列 RPC ，

145
00:08:46,950 --> 00:08:50,340
当然，每个跟随者将条目附加到它的日志中，

146
00:08:50,340 --> 00:08:53,760
所以需要向持久存储写入，

147
00:08:53,760 --> 00:08:54,840
这里也是一样的，

148
00:08:54,870 --> 00:08:56,160
然后它们会做出响应。

149
00:08:57,110 --> 00:08:59,090
所以这是响应，

150
00:08:59,360 --> 00:09:02,210
在这种情况下，大多数都做出了响应，

151
00:09:02,540 --> 00:09:04,820
领导者可以接受操作，

152
00:09:05,000 --> 00:09:09,140
领导者在这里对[]应用操作，

153
00:09:10,000 --> 00:09:14,680
执行 put 并将响应发送回客户端。

154
00:09:15,580 --> 00:09:16,990
令人好奇的是，

155
00:09:16,990 --> 00:09:21,010
我们每秒能得到多少次 put ，

156
00:09:21,040 --> 00:09:25,340
在这个背景下。

157
00:09:26,170 --> 00:09:28,330
考虑一下，

158
00:09:28,330 --> 00:09:32,770
当你做[]估算，

159
00:09:32,770 --> 00:09:35,920
我们并不关心确切的数字，

160
00:09:35,920 --> 00:09:37,990
但是一次往返，

161
00:09:38,410 --> 00:09:41,770
我们至少需要一次往返才能找到大多数，

162
00:09:41,800 --> 00:09:45,160
领导者需要与至少一个访问跟随者以保持多数，

163
00:09:45,160 --> 00:09:47,800
所以，我们至少需要一条往返消息。

164
00:09:52,340 --> 00:09:57,920
然后，你需要看对稳定存储的写入，

165
00:09:57,920 --> 00:09:59,510
因为那些往往很昂贵，

166
00:09:59,840 --> 00:10:01,280
在这种情况下，我们会看到，

167
00:10:01,280 --> 00:10:02,270
我们将有两次写入，

168
00:10:02,270 --> 00:10:03,950
因为会有一个写入到领导者，

169
00:10:03,950 --> 00:10:05,270
一次写入到跟随者，

170
00:10:05,270 --> 00:10:08,360
在这一点上，我们至少有两个节点具有副本，

171
00:10:08,540 --> 00:10:10,100
所以那个消息将会提交，

172
00:10:10,430 --> 00:10:13,340
如果没有更多故障，

173
00:10:13,520 --> 00:10:18,640
所以至少我们需要 2 次写入。

174
00:10:20,590 --> 00:10:23,110
所以这是你能做的最好的，

175
00:10:23,110 --> 00:10:26,080
在我们在这里讨论的这个简单的方案中，

176
00:10:26,500 --> 00:10:28,720
在某种程度上，我们可以考虑成本是多少，

177
00:10:29,260 --> 00:10:31,360
在一个往返中，

178
00:10:31,360 --> 00:10:32,860
也许这些运行在数据中心，

179
00:10:32,860 --> 00:10:34,420
网络不通过互联网，

180
00:10:34,630 --> 00:10:37,270
这个可以降到 1 毫秒，

181
00:10:40,080 --> 00:10:42,180
我们大概在附近 1 毫秒，

182
00:10:42,180 --> 00:10:43,110
可能会快一点，

183
00:10:43,110 --> 00:10:44,220
但我们并不关心，

184
00:10:44,310 --> 00:10:45,330
只是使用 1 毫秒。

185
00:10:45,890 --> 00:10:48,020
我们将行两次写入到稳定存储，

186
00:10:48,830 --> 00:10:51,590
写入稳定存储似乎很昂贵，

187
00:10:51,590 --> 00:10:55,910
取决于使用什么介质和什么技术来做稳定存储，

188
00:10:55,970 --> 00:10:59,300
假设我们使用固态硬盘，这是很典型的，

189
00:10:59,450 --> 00:11:03,260
那么可能一次顺序写入需要 2 毫秒，

190
00:11:03,260 --> 00:11:07,280
我们必须确保写入最终会在固态硬盘，

191
00:11:07,280 --> 00:11:10,070
所以，我们可能必须进行同步写入，

192
00:11:10,990 --> 00:11:13,960
所以这意味着一次写入需要 2 毫秒，

193
00:11:13,960 --> 00:11:17,140
所以两次写入大约是 4 毫秒。

194
00:11:19,110 --> 00:11:21,990
所以我们结束了，将有 5 毫秒。

195
00:11:24,270 --> 00:11:26,070
那么，每秒有多少次操作？

196
00:11:28,100 --> 00:11:29,660
只是想看看有没有人还醒着。

197
00:11:33,880 --> 00:11:35,200
200 。

198
00:11:35,200 --> 00:11:37,450
是的，所以每秒会有 200 次 put 。

199
00:11:41,040 --> 00:11:42,810
对这个有什么问题吗，能理解吗？

200
00:11:46,010 --> 00:11:49,040
好的，现在让我们来看看 zookeeper 。

201
00:11:49,070 --> 00:11:51,080
写入的往返是什么，

202
00:11:51,080 --> 00:11:52,250
抱歉，我错过了。

203
00:11:53,300 --> 00:11:56,900
写入没有往返，

204
00:11:56,900 --> 00:11:58,070
有一个往返，

205
00:11:58,070 --> 00:11:59,600
领导者访问跟随者，

206
00:11:59,600 --> 00:12:00,410
以及两个写入，

207
00:12:00,410 --> 00:12:02,480
一个是在领导的稳定存储，

208
00:12:02,570 --> 00:12:05,600
一个是在跟随者的稳定存储，

209
00:12:07,340 --> 00:12:09,170
两次写入最终是 4 ，

210
00:12:09,200 --> 00:12:11,060
往返大约 1 毫秒，

211
00:12:11,060 --> 00:12:13,840
所以一次 put 的总计是 5 毫秒。

212
00:12:17,160 --> 00:12:19,320
好的，让我们来看看 zookeeper ，

213
00:12:27,920 --> 00:12:32,390
再说一次，论文感兴趣的指标是吞吐量指标，

214
00:12:32,390 --> 00:12:35,360
你有很多客户端，

215
00:12:35,630 --> 00:12:45,800
它们发出很多请求到 zookeeper ，

216
00:12:45,980 --> 00:12:49,220
并积极地[输送]它们。

217
00:12:49,930 --> 00:12:54,520
让我们来看看结果是什么，

218
00:12:54,790 --> 00:13:00,570
所以让我拿出论文的图，

219
00:13:04,260 --> 00:13:07,890
稍微看一下论文，这张图。

220
00:13:10,240 --> 00:13:12,760
有几件事应该是要注意的，

221
00:13:12,760 --> 00:13:15,850
x 轴上是读请求百分比，

222
00:13:15,850 --> 00:13:16,900
我们很快会看到，

223
00:13:16,900 --> 00:13:21,310
区分读操作或写操作非常重要，

224
00:13:21,310 --> 00:13:23,710
写操作是修改的操作，

225
00:13:23,710 --> 00:13:25,840
任何写操作都会修改状态，

226
00:13:26,140 --> 00:13:28,990
读操作是完全不修改状态的操作，

227
00:13:29,260 --> 00:13:31,510
在我们实验的三个术语中，

228
00:13:31,510 --> 00:13:33,550
put 是写操作，

229
00:13:33,550 --> 00:13:35,380
get 是读操作。

230
00:13:36,340 --> 00:13:39,820
在 y 轴上是每秒的操作次数，

231
00:13:39,820 --> 00:13:41,860
让我们来看看 3 台服务器的情况，

232
00:13:42,130 --> 00:13:46,510
你注意到的第一件事是没有读，

233
00:13:46,510 --> 00:13:50,260
只有写操作，它会修改状态，

234
00:13:50,440 --> 00:13:58,930
我们得到大约每秒 21k 次操作的吞吐量，

235
00:13:59,260 --> 00:14:03,910
如果系统只有读，

236
00:14:04,240 --> 00:14:05,380
它得到了更多，

237
00:14:05,380 --> 00:14:10,270
到达 60-70 的区域，

238
00:14:10,570 --> 00:14:12,880
实际上发生的是，

239
00:14:12,880 --> 00:14:14,080
读次数，

240
00:14:14,930 --> 00:14:17,990
读吞吐量与服务器数量成正比。

241
00:14:25,510 --> 00:14:29,740
所以，如果你有 3 台服务器，

242
00:14:29,740 --> 00:14:32,740
你可以得到一台服务器的读性能的 3 倍，

243
00:14:32,740 --> 00:14:33,610
如果你有 5 台服务器，

244
00:14:33,610 --> 00:14:37,720
你可以得到一台服务器的读性能的 5 倍。

245
00:14:38,200 --> 00:14:39,730
当然对于写不是这样的，

246
00:14:39,730 --> 00:14:41,470
如果你看这张图，

247
00:14:41,500 --> 00:14:44,260
你可以看到，如果有更多的服务器，

248
00:14:44,290 --> 00:14:45,880
写入性能实际上会下降。

249
00:14:46,460 --> 00:14:49,400
这样的原因大概是，

250
00:14:49,400 --> 00:14:52,850
领导者必须访问更多服务器，

251
00:14:52,850 --> 00:14:54,260
让操作可以通过。

252
00:14:54,980 --> 00:14:57,980
所以，当我们只进行写操作时，

253
00:14:58,100 --> 00:14:59,900
我们是有限的，

254
00:14:59,900 --> 00:15:02,390
我们不能期望比单台服务器更高的性能，

255
00:15:02,390 --> 00:15:05,570
实际上，增加服务器将降低性能。

256
00:15:07,540 --> 00:15:09,850
所以，这个 21k 每秒，

257
00:15:09,850 --> 00:15:12,520
即使对于单台（服务器），

258
00:15:13,060 --> 00:15:17,740
对于配置 3 台服务器的写操作，

259
00:15:17,740 --> 00:15:18,700
是一个令人印象深刻的数字，

260
00:15:18,820 --> 00:15:24,160
比我们在实验 3 中的简单[]要高得多，

261
00:15:24,160 --> 00:15:27,880
实验 3 完全不会靠近这个数字。

262
00:15:28,570 --> 00:15:31,180
所以我们想要了解，

263
00:15:31,390 --> 00:15:33,700
你想在这个设计中看到，

264
00:15:33,730 --> 00:15:36,910
设计者做了什么，获得这样的性能。

265
00:15:41,950 --> 00:15:43,600
我之前提到的，

266
00:15:43,600 --> 00:15:45,820
有两个关键的想法，

267
00:15:45,820 --> 00:15:48,010
1 ，任何东西都是异步的，

268
00:15:48,040 --> 00:15:56,270
或者客户端可以一次向 zookeeper 提交多个操作，

269
00:15:56,750 --> 00:15:58,010
它们排队，

270
00:15:58,010 --> 00:16:02,090
考虑 zookeeper 客户端的方式，

271
00:16:02,090 --> 00:16:05,150
说，请开始执行这个 put ，

272
00:16:05,150 --> 00:16:08,360
但是不等待 put 的响应，

273
00:16:08,390 --> 00:16:10,760
直接发送第二个 put ，

274
00:16:10,760 --> 00:16:12,230
然后是第三个，第四个，第五个，

275
00:16:12,750 --> 00:16:15,660
比如，很多 put 放在一起，

276
00:16:15,660 --> 00:16:19,650
也许只有一条消息传递给领导者，

277
00:16:19,650 --> 00:16:22,230
领导者将同时应用所有它们，

278
00:16:22,500 --> 00:16:26,670
事实上，领导者只向持久久存储写入一次，

279
00:16:26,670 --> 00:16:28,380
对于批量的操作，

280
00:16:28,380 --> 00:16:31,530
所以，不是每个操作一次写入，

281
00:16:31,560 --> 00:16:34,950
而是多个操作一次磁盘写入，

282
00:16:35,190 --> 00:16:36,420
这是一个原因，

283
00:16:36,420 --> 00:16:41,160
他们在写入操作上获得非常好的性能。

284
00:16:41,710 --> 00:16:43,720
第二件事是，

285
00:16:43,900 --> 00:16:47,470
他们为读操作做了一些特殊的事情，

286
00:16:47,530 --> 00:16:52,590
他们允许读操作在任何服务器处理。

287
00:16:57,200 --> 00:16:59,600
所以，不是通过领导者来执行所有的操作，

288
00:16:59,990 --> 00:17:04,730
他们允许任何服务器处理操作。

289
00:17:06,060 --> 00:17:06,840
所以。

290
00:17:07,840 --> 00:17:11,560
我们想要更多地谈论它。

291
00:17:11,800 --> 00:17:15,130
我想我们可以做些类似的事情，

292
00:17:15,130 --> 00:17:16,870
比如，我们想要在实验 3 中做的，

293
00:17:20,570 --> 00:17:22,700
我们做相同的事，

294
00:17:22,700 --> 00:17:24,530
这里我们想要的是

295
00:17:24,560 --> 00:17:32,840
从任何机器或任何节点读取。

296
00:17:36,760 --> 00:17:38,680
所以，图片如下所示，

297
00:17:38,680 --> 00:17:39,730
我们有一个领导者，

298
00:17:40,750 --> 00:17:42,310
我们有两个跟随者，

299
00:17:42,910 --> 00:17:45,070
我们使用 3 个节点的情况，

300
00:17:46,950 --> 00:17:48,240
我们有一个客户端。

301
00:17:49,980 --> 00:17:54,330
我们考虑可能发生的事情，

302
00:17:55,110 --> 00:17:58,020
如果我们遵循这个策略，

303
00:17:58,020 --> 00:17:59,340
我们将从任何地方阅读，

304
00:17:59,340 --> 00:18:00,270
我们使用客户端，

305
00:18:01,310 --> 00:18:03,260
领导者当我们执行 put 时，

306
00:18:03,260 --> 00:18:05,030
它们都通过领导者，

307
00:18:06,150 --> 00:18:08,250
客户端执行读取，

308
00:18:08,610 --> 00:18:11,580
假设这个 put 已经完成，

309
00:18:12,310 --> 00:18:15,610
与此同时，几乎在 put 完成时，

310
00:18:15,610 --> 00:18:17,470
客户端发出一个 get ，

311
00:18:18,510 --> 00:18:21,300
并访问任意一个跟随者，

312
00:18:21,300 --> 00:18:24,000
我们使用这个，它没有访问领导者，

313
00:18:24,210 --> 00:18:28,770
然后跟随者回应，

314
00:18:29,040 --> 00:18:32,910
问题是， get 观察到的值是什么。

315
00:18:35,320 --> 00:18:38,050
那么客户端可能得到的值是什么，

316
00:18:38,080 --> 00:18:42,010
比如，我们读取键 x ，

317
00:18:42,010 --> 00:18:44,410
x 的初始值是 0 ，

318
00:18:44,590 --> 00:18:46,780
而这个 put 使 x 变为 1 。

319
00:18:48,240 --> 00:18:51,120
那么 x 返回的值是什么，

320
00:18:51,150 --> 00:18:53,100
如果我们不做任何特别的事情。

321
00:18:56,520 --> 00:18:58,110
所以有一个关于设置的问题，

322
00:18:58,110 --> 00:19:01,560
所以如果我们假设 raft 是这里的基础设施，

323
00:19:01,620 --> 00:19:03,300
而 get 是另一个命令，

324
00:19:03,420 --> 00:19:06,990
那么跟随者会不会将应用重定向到领导者，

325
00:19:07,020 --> 00:19:12,420
put 或 get 请求到领导者。

326
00:19:12,420 --> 00:19:13,440
不，[]，我们可以做的事情很多，

327
00:19:13,440 --> 00:19:16,350
但我们想要获得这种完美的可扩展性，

328
00:19:16,850 --> 00:19:18,530
所以，为了获得完美的可扩展性，

329
00:19:18,770 --> 00:19:22,130
对于读操作，跟随者不能访问领导者，

330
00:19:22,130 --> 00:19:27,740
所以读操作是由单个跟随者直接执行的，

331
00:19:27,890 --> 00:19:28,910
没有沟通，

332
00:19:29,060 --> 00:19:31,160
我们获得完美的可扩展性。

333
00:19:31,340 --> 00:19:33,230
所以，这里甚至没有通信。

334
00:19:34,490 --> 00:19:36,410
是的，我只是在按计划行事，

335
00:19:36,410 --> 00:19:38,540
我们的目标是获得完美的可扩展性，

336
00:19:38,810 --> 00:19:40,310
就像 zookeeper 所做的，

337
00:19:40,610 --> 00:19:43,190
我们想要理解的这是困难的还是容易的，

338
00:19:43,400 --> 00:19:44,780
或者这到底是什么意思，

339
00:19:44,960 --> 00:19:46,790
所以，首先要做的是，

340
00:19:46,790 --> 00:19:49,760
领导者和跟随者什么都不做，

341
00:19:50,060 --> 00:19:53,390
跟随者执行读操作并返回值。

342
00:19:55,060 --> 00:19:55,870
什么能，

343
00:19:55,870 --> 00:19:56,620
所以另一个问题是，

344
00:19:56,620 --> 00:20:01,810
这张图中，客户端可以观察到什么值。

345
00:20:01,930 --> 00:20:02,950
可以是任何一种，

346
00:20:02,950 --> 00:20:04,750
因为可能你执行 put ，

347
00:20:04,840 --> 00:20:07,900
然后它们会通过领导者的磁盘。

348
00:20:08,110 --> 00:20:09,340
是的，它可以是任何一种，

349
00:20:09,340 --> 00:20:13,060
所以要么返回 0 ，要么返回 1 。

350
00:20:14,180 --> 00:20:18,080
所以它可能返回过时的数据。

351
00:20:19,330 --> 00:20:22,270
假设我们做，

352
00:20:22,300 --> 00:20:24,250
假设返回 1 ，

353
00:20:25,270 --> 00:20:28,540
对于[]实验，这个 get 返回 1 ，

354
00:20:28,540 --> 00:20:30,880
然后客户端执行另一个 get ，

355
00:20:33,680 --> 00:20:35,930
现在 get 会得到什么，

356
00:20:36,380 --> 00:20:43,530
但是，我们可以看到什么值，

357
00:20:44,750 --> 00:20:45,920
对这个 get 的回应。

358
00:20:46,840 --> 00:20:49,510
假设没有其他写入，这应该是 1 ，对吧。

359
00:20:50,820 --> 00:20:51,780
是的，不幸的是，

360
00:20:51,810 --> 00:20:53,730
因为我有 3 台服务器，

361
00:20:53,850 --> 00:20:55,110
如果我有 5 台服务器呢？

362
00:21:00,660 --> 00:21:03,570
为什么会不同？

363
00:21:03,600 --> 00:21:05,460
好的，我们让它不同。

364
00:21:07,200 --> 00:21:11,010
所以肯定会返回 1 ，我们同意，

365
00:21:11,250 --> 00:21:14,760
因为如果跟随者响应第二个 get 请求，

366
00:21:14,760 --> 00:21:20,970
访问一个看到过 put 操作的跟随者，

367
00:21:21,150 --> 00:21:23,280
它们中的大多数都看到过 put 操作，

368
00:21:23,280 --> 00:21:24,780
我们会到到 1 ，对吧。

369
00:21:25,920 --> 00:21:28,500
真正的问题是，它能不能看到 0 ，

370
00:21:31,670 --> 00:21:33,650
尽管它早些时候观察到了 1 。

371
00:21:34,930 --> 00:21:36,370
我想你可以看到 0 ，

372
00:21:36,370 --> 00:21:38,470
即使在 3 台服务器的情况下，

373
00:21:38,470 --> 00:21:41,260
因为假设你拥有大多数服务器。

374
00:21:41,260 --> 00:21:43,990
让我来做前 5 个的情况，因为它更容易看到。

375
00:21:46,750 --> 00:21:51,280
我们是否假设客户端总是请求相同的节点？

376
00:21:51,550 --> 00:21:56,320
不，可能会有一小段时间的网络分区或断线，

377
00:21:56,320 --> 00:21:59,440
所以你不需要访问上次一样的节点，对吧。

378
00:22:00,070 --> 00:22:03,700
是的，所以在这种情况下，它可以访问不同的节点，

379
00:22:03,700 --> 00:22:08,500
那个节点可能返回 0 。

380
00:22:08,500 --> 00:22:09,490
所以，这是可能的，

381
00:22:09,910 --> 00:22:12,670
所以我们会有一些奇怪的行为，

382
00:22:12,670 --> 00:22:16,000
在这配置中，你可能会看到最近的，

383
00:22:16,030 --> 00:22:17,380
在第一种情况下，

384
00:22:17,380 --> 00:22:18,940
我们可能会看到最近的值，

385
00:22:19,030 --> 00:22:22,030
然后我们读到一些过去的东西。

386
00:22:28,090 --> 00:22:28,900
是的。

387
00:22:30,080 --> 00:22:32,030
所以我们没做什么特别的事，

388
00:22:32,180 --> 00:22:35,510
只是天真地从任何节点读取，

389
00:22:35,510 --> 00:22:37,610
我们有两种不同[类型]的问题，

390
00:22:37,610 --> 00:22:40,040
get 可以返回过时的数据，

391
00:22:40,460 --> 00:22:43,550
get 返回过去的数据。

392
00:22:44,840 --> 00:22:45,590
所以。

393
00:22:46,290 --> 00:22:49,890
抱歉，这不是 3 个跟随者也可能的吗，

394
00:22:49,890 --> 00:22:52,380
因为大多数是领导者和一个跟随者，

395
00:22:52,380 --> 00:22:53,820
你可以访问另一个（跟随者）。

396
00:22:55,520 --> 00:22:57,230
如果你见过那个，

397
00:22:57,230 --> 00:23:00,650
是的，这绝对是有可能的，

398
00:23:00,710 --> 00:23:02,150
3 个也是可能的，

399
00:23:02,150 --> 00:23:03,590
我认为 5 要更清楚，

400
00:23:03,590 --> 00:23:04,490
这是可能的。

401
00:23:09,520 --> 00:23:10,570
好的，所以。

402
00:23:12,660 --> 00:23:13,980
所以，现在我们要回去，

403
00:23:13,980 --> 00:23:16,140
稍微考虑一下这种行为，

404
00:23:16,260 --> 00:23:19,500
返回那些值，可以吗？

405
00:23:20,170 --> 00:23:22,300
这是一个非常有趣的问题，

406
00:23:22,330 --> 00:23:24,820
这取决于你说的正确是什么意思。

407
00:23:25,740 --> 00:23:28,380
如果某件事是正确的，

408
00:23:28,380 --> 00:23:30,330
取决于我们的正确定义是什么。

409
00:23:31,050 --> 00:23:33,990
我们所说的正确性的定义，

410
00:23:33,990 --> 00:23:37,230
在学期开始的前几节课中，

411
00:23:37,230 --> 00:23:39,300
是线性一致性的概念。

412
00:23:45,760 --> 00:23:48,610
它的意思是，

413
00:23:49,110 --> 00:23:52,590
我在一周前谈过这件事，

414
00:23:52,680 --> 00:23:54,780
行为像一台机器，

415
00:23:57,460 --> 00:24:01,750
这是我们从学期开始一直使用的直觉，

416
00:24:02,920 --> 00:24:06,790
但是线性一致性的定义要更精确一点，

417
00:24:07,000 --> 00:24:10,960
试图确定像一台机器是什么意思，

418
00:24:10,990 --> 00:24:13,480
所以，当某个东西表现得像一台机器时，

419
00:24:13,480 --> 00:24:15,130
首先，必须是这样的情况，

420
00:24:15,130 --> 00:24:17,350
即使操作实际上同时进行，

421
00:24:17,380 --> 00:24:19,510
你可以按整体顺序对它们进行排序，

422
00:24:20,300 --> 00:24:25,010
所以，可以构建所有操作的整体顺序，

423
00:24:25,250 --> 00:24:26,900
因为归根结底，这是一台机器，

424
00:24:26,900 --> 00:24:28,880
它的行为像一台机器，

425
00:24:28,880 --> 00:24:30,110
只有一台机器，

426
00:24:30,140 --> 00:24:36,380
虚拟机器可以以整体顺序执行操作，

427
00:24:37,370 --> 00:24:40,970
关于整体顺序有一些属性是真的。

428
00:24:41,700 --> 00:24:44,460
所以，一个必须为真的属性是，

429
00:24:44,460 --> 00:24:46,320
顺序与真实时间匹配，

430
00:24:51,950 --> 00:24:54,140
真实时间我的意思是，

431
00:24:54,140 --> 00:24:57,140
如果操作在另一个开始前完成，

432
00:24:58,930 --> 00:25:04,090
那么，在整体顺序中，第一个操作必须在第二个操作之前。

433
00:25:05,870 --> 00:25:07,100
然后是第三个属性，

434
00:25:07,900 --> 00:25:16,310
读操作返回最后写入的值。

435
00:25:23,620 --> 00:25:26,140
这是线性一致性的官方定义，

436
00:25:26,140 --> 00:25:27,220
你可以认为这是

437
00:25:27,220 --> 00:25:31,030
一种更精确的定义，更准确的表述，

438
00:25:31,030 --> 00:25:32,800
对于第一个直觉，

439
00:25:32,920 --> 00:25:35,470
也就是整个行为像一台机器。

440
00:25:37,370 --> 00:25:38,570
现在我们回来，

441
00:25:38,690 --> 00:25:42,140
想一下这种场景，

442
00:25:42,140 --> 00:25:44,600
刚才在白板上的，

443
00:25:44,630 --> 00:25:47,870
也就是两种情况，过时的数据和时间回退，

444
00:25:48,080 --> 00:25:53,190
想想线性一致性是否允许它们。

445
00:25:53,400 --> 00:25:56,250
所以，我们首先关注第一个问题，

446
00:25:56,430 --> 00:25:58,410
所以我们有一个客户端 1 ，

447
00:25:58,410 --> 00:26:00,450
你把它画出来的方式，

448
00:26:00,450 --> 00:26:02,100
合理的线性一致性是，

449
00:26:02,100 --> 00:26:04,020
你可以使用这种形式画一张图，

450
00:26:04,350 --> 00:26:07,290
左边是操作的开始，

451
00:26:07,290 --> 00:26:11,250
右边是对执行操作的客户端的确认，

452
00:26:11,640 --> 00:26:12,420
在这种情况下，

453
00:26:12,420 --> 00:26:17,370
比如 put 到 x ， put 值 1 。

454
00:26:18,170 --> 00:26:21,560
然后我们有另一个客户端或者同一个客户端，

455
00:26:22,040 --> 00:26:23,690
我们画其他客户端，

456
00:26:23,690 --> 00:26:25,010
执行读取，

457
00:26:25,040 --> 00:26:30,080
读取在 put 操作之后很久才开始，

458
00:26:30,080 --> 00:26:31,700
有一个 get x ，

459
00:26:32,220 --> 00:26:35,880
我们有一种情况，get 返回 0 ，

460
00:26:35,910 --> 00:26:38,040
这是第一种可能性。

461
00:26:39,820 --> 00:26:43,180
这就是上一张白板发生的事情，

462
00:26:43,180 --> 00:26:44,620
现在我们想考虑一下，

463
00:26:44,620 --> 00:26:47,650
这种执行是线性一致性允许的吗，

464
00:26:47,740 --> 00:26:50,560
这是我们正在寻找的正确性的定义，

465
00:26:50,680 --> 00:26:53,170
然后我们看这个执行，

466
00:26:53,170 --> 00:26:56,410
实际发生的操作的顺序，

467
00:26:56,410 --> 00:26:58,690
至少我们看这在实践中是可能的，

468
00:26:58,690 --> 00:27:00,430
这是线性一致性允许的吗，

469
00:27:00,430 --> 00:27:01,780
是不是我们的正确性标准。

470
00:27:03,360 --> 00:27:06,600
这是线性一致性允许的吗？

471
00:27:11,980 --> 00:27:12,370
不是。

472
00:27:12,880 --> 00:27:14,260
不，为什么不是？

473
00:27:14,620 --> 00:27:20,170
因为 C2 操作是在 C1 完成之后开始的，

474
00:27:20,170 --> 00:27:21,550
所以在整体顺序中，

475
00:27:21,550 --> 00:27:23,320
你有 put x 1 ，

476
00:27:23,320 --> 00:27:25,150
所以 get x 必须是 1 ，

477
00:27:25,150 --> 00:27:26,530
因为它应该读取最后一次写入。

478
00:27:27,070 --> 00:27:29,530
是的，所以在构建的整体顺序中，

479
00:27:29,890 --> 00:27:30,850
这个（操作），

480
00:27:30,850 --> 00:27:33,670
这个操作必须在那个操作之后，

481
00:27:34,340 --> 00:27:35,570
因为它开始得比较晚。

482
00:27:36,150 --> 00:27:39,660
你可以看到，这违反了规则 3 ，

483
00:27:40,220 --> 00:27:42,500
操作返回最后一次写入的值，

484
00:27:42,500 --> 00:27:43,520
实际上并不是这样，

485
00:27:43,520 --> 00:27:45,560
返回的是前面的值，

486
00:27:45,590 --> 00:27:47,000
所以这是不可线性化的。

487
00:27:49,790 --> 00:27:50,630
这能理解吗？

488
00:27:53,060 --> 00:27:55,190
当然，这完全符合我们的直觉，

489
00:27:55,190 --> 00:27:57,500
因为任何一台机器都不可能发生，

490
00:27:57,560 --> 00:28:00,140
你写入一个值到一台机器，

491
00:28:00,140 --> 00:28:01,130
然后你再读取，

492
00:28:01,400 --> 00:28:02,690
它肯定不是其他值，

493
00:28:02,690 --> 00:28:03,710
而是之前的值，

494
00:28:03,710 --> 00:28:04,610
所以这是不允许的。

495
00:28:06,220 --> 00:28:08,590
好的，让我们再看另一个示例，

496
00:28:08,590 --> 00:28:10,360
所以我们又有了一个客户端 1 ，

497
00:28:10,390 --> 00:28:11,260
只是 put ，

498
00:28:12,120 --> 00:28:14,520
画得更紧凑一点，

499
00:28:14,520 --> 00:28:15,960
因为我没有太多的空间。

500
00:28:16,620 --> 00:28:18,690
我们执行一个 put ，

501
00:28:18,690 --> 00:28:22,740
然后我们做，一个读取或 get ，

502
00:28:23,320 --> 00:28:24,640
get 返回 1 ，

503
00:28:24,700 --> 00:28:26,620
所以我们不是在第一种情况下，

504
00:28:26,620 --> 00:28:28,690
而是第二个，另一个案例中，

505
00:28:28,930 --> 00:28:32,800
然后，我们 get 得到 0 。

506
00:28:35,860 --> 00:28:39,550
这是我们看到的第二种情况，

507
00:28:39,550 --> 00:28:42,880
在这张图片中，时间倒流的情况。

508
00:28:43,580 --> 00:28:45,470
我们再次问自己同样的问题，

509
00:28:46,350 --> 00:28:49,170
它是否是线性一致性所允许的？

510
00:28:53,350 --> 00:28:58,750
不是，因为 read 不是返回最后一次写入的值。

511
00:28:58,780 --> 00:29:01,720
是的，这是相当直截的观察，

512
00:29:01,720 --> 00:29:02,950
不是那种情况，

513
00:29:02,950 --> 00:29:04,630
事实上，与第一种情况类似，

514
00:29:04,630 --> 00:29:07,540
因为这些操作必须按这个顺序进行，

515
00:29:07,780 --> 00:29:10,840
但这是不可能发生的，

516
00:29:10,840 --> 00:29:13,870
这违反了规则 3 。

517
00:29:16,120 --> 00:29:20,650
好的，这给了你关于线性一致性含义的感觉，

518
00:29:20,650 --> 00:29:21,880
你如何考虑它，

519
00:29:21,880 --> 00:29:25,120
基本上，如果我们不做任何特别的事情，

520
00:29:25,300 --> 00:29:27,520
我们做这个天真的方案，

521
00:29:27,640 --> 00:29:29,650
如果你在实现实验 3 ，

522
00:29:29,650 --> 00:29:31,600
你遵循这个天真的方案，

523
00:29:31,810 --> 00:29:34,090
那么你不会通过测试，

524
00:29:34,090 --> 00:29:37,600
因为测试假设或实验 3 的目标是，

525
00:29:37,600 --> 00:29:40,000
对 put 和 get 提供线性一致性。

526
00:29:40,320 --> 00:29:43,020
所以像这样的场景是不允许的，

527
00:29:43,050 --> 00:29:46,110
你的实现必须以一种方式，

528
00:29:46,110 --> 00:29:48,600
这些结果不会出现。

529
00:29:50,400 --> 00:29:51,150
这能理解吗？

530
00:29:53,150 --> 00:29:57,740
所以我们要做实验 3 是关于线性一致性的尝试，

531
00:29:58,100 --> 00:30:00,560
什么是获得线性一致性的简单方法，

532
00:30:02,680 --> 00:30:06,400
我们如何确保 put 或 get 操作是可线性化的。

533
00:30:08,800 --> 00:30:11,530
我的意思是，如果你真的用一台机器，

534
00:30:12,080 --> 00:30:14,000
那么它就是可线性化的，对吧。

535
00:30:14,330 --> 00:30:15,950
是的，那么什么是简单的解决方案，

536
00:30:16,070 --> 00:30:18,710
我们所有读取都通过领导者运行。

537
00:30:19,600 --> 00:30:22,870
所以，获得线性一致性的简单解决方案，

538
00:30:22,870 --> 00:30:24,880
事实上，这就是我们在实验室 3 中要做的事情，

539
00:30:25,440 --> 00:30:29,700
实验 3 要做的是，

540
00:30:31,080 --> 00:30:36,410
读取或 get 操作操作要通过日志，

541
00:30:37,400 --> 00:30:38,960
通过 raft ，

542
00:30:42,470 --> 00:30:43,520
正如你所观察到的，

543
00:30:43,520 --> 00:30:46,640
如果它们都通过一台机器，

544
00:30:46,640 --> 00:30:48,980
它们可能不是通过一台机器，

545
00:30:49,190 --> 00:30:50,630
领导者可能会随着时间而改变，

546
00:30:51,050 --> 00:30:53,540
我们知道领导者总是有整体顺序，

547
00:30:53,540 --> 00:30:54,830
日志是有整体顺序的，

548
00:30:55,100 --> 00:30:58,190
所以我们能够构建一个整体顺序，

549
00:30:58,190 --> 00:31:00,980
顺序与真实时间匹配，

550
00:31:00,980 --> 00:31:03,800
每个读取的返回值是最后一次写入的。

551
00:31:04,340 --> 00:31:07,610
因为 raft 协议将保证，

552
00:31:07,610 --> 00:31:12,530
日志中的所有条目都是按整体顺序排列的。

553
00:31:13,320 --> 00:31:15,540
当然 raft 协议做了大量的工作，

554
00:31:15,540 --> 00:31:16,830
才能真正实现这一切，

555
00:31:16,980 --> 00:31:20,460
尽管网络故障，

556
00:31:20,460 --> 00:31:24,570
尽管网络分裂，

557
00:31:24,690 --> 00:31:27,510
raft 协议会保证我们，

558
00:31:27,600 --> 00:31:30,810
所有的操作都是按整体顺序进行。

559
00:31:31,390 --> 00:31:35,170
事实上，整个复制状态机方法都是基于这个想法的，

560
00:31:35,170 --> 00:31:36,880
所有操作在一个整体顺序中，

561
00:31:36,880 --> 00:31:38,890
并以相同的顺序在所有节点应用，

562
00:31:38,890 --> 00:31:42,760
结果，看起来像一台机器。

563
00:31:43,420 --> 00:31:45,850
所以，解决这个问题的简单方法就是

564
00:31:45,850 --> 00:31:49,270
通过领导者运行所有读取，

565
00:31:49,720 --> 00:31:51,760
无论领导者在哪个时间点，

566
00:31:51,760 --> 00:31:53,230
这会给我们线性一致性。

567
00:31:57,830 --> 00:32:00,080
让我暂停一下，有什么问题吗？

568
00:32:02,210 --> 00:32:04,520
抱歉，匹配真实时间是意味着，

569
00:32:04,520 --> 00:32:07,100
如果操作 1 在操作 2 开始之前结束，

570
00:32:07,130 --> 00:32:08,060
那么 1 在 2 前面。

571
00:32:08,560 --> 00:32:12,730
是的，对于 raft ，

572
00:32:12,730 --> 00:32:15,310
你会看到这是自动发生的，

573
00:32:15,310 --> 00:32:20,350
因为如果操作完全结束，

574
00:32:20,350 --> 00:32:21,490
肯定是这种情况，

575
00:32:21,490 --> 00:32:24,220
领导者响应给一个客户端，

576
00:32:24,220 --> 00:32:26,290
如果客户端开始操作较晚，

577
00:32:26,410 --> 00:32:28,630
一定在领导者的日志中较晚。

578
00:32:30,720 --> 00:32:32,400
所以这是[真的]。

579
00:32:33,500 --> 00:32:36,590
而且，只是确认一下，也许重复了，

580
00:32:36,590 --> 00:32:37,850
在实验 3 中，

581
00:32:37,850 --> 00:32:40,980
所有客户端请求都是同步的？

582
00:32:40,980 --> 00:32:42,510
是的，确实是。

583
00:32:44,830 --> 00:32:45,490
好的，很好，

584
00:32:45,700 --> 00:32:48,550
所以，[]所说的这个方案，

585
00:32:48,550 --> 00:32:50,230
我们回去，

586
00:32:50,230 --> 00:32:51,940
如果你很仔细地看 raft 论文，

587
00:32:51,940 --> 00:32:54,280
有一个针对只读操作的优化，

588
00:32:54,640 --> 00:32:59,800
但这个优化，也需要一些通信。

589
00:33:00,530 --> 00:33:02,900
所以，如果我们遵循这个天真的（想法），

590
00:33:02,930 --> 00:33:06,770
这个方案的[技巧]来获得线性一致性。

591
00:33:07,360 --> 00:33:10,510
这对性能意味着什么，

592
00:33:10,510 --> 00:33:14,050
往回考虑一下对比 zookeeper ，

593
00:33:20,350 --> 00:33:21,610
比如，

594
00:33:21,610 --> 00:33:24,340
读操作的数量是否随着服务器数量的增加而增加？

595
00:33:26,660 --> 00:33:30,410
不，因为现在所有的东西都要经过领导者。

596
00:33:30,440 --> 00:33:32,180
没错，所有东西也要通过领导者，

597
00:33:32,180 --> 00:33:33,590
所以我们再一次，

598
00:33:33,590 --> 00:33:35,120
这不是我们希望的。

599
00:33:35,840 --> 00:33:37,520
所以它给了你一个即时的问题是，

600
00:33:37,520 --> 00:33:39,380
这怎么可能，

601
00:33:39,380 --> 00:33:42,110
当你使用 zookeeper 时，

602
00:33:42,110 --> 00:33:43,670
zookeeper 有很好的性能，

603
00:33:43,700 --> 00:33:46,670
因为我们看到的这个简单方案并不起作用，

604
00:33:47,550 --> 00:33:49,350
或者至少违反了线性一致性。

605
00:33:50,310 --> 00:33:52,980
所以我们想讨论一下，

606
00:33:52,980 --> 00:33:56,160
理解 zookeeper 是如何做到的。

607
00:33:56,910 --> 00:33:59,940
所以首先要注意的是，

608
00:33:59,940 --> 00:34:01,380
可能是最重要的部分，

609
00:34:02,040 --> 00:34:06,880
就是 zookeeper 没有提供线性一致性，

610
00:34:08,350 --> 00:34:10,690
它改变了正确性的定义。

611
00:34:22,740 --> 00:34:24,990
所以 zookeeper 服务，

612
00:34:25,200 --> 00:34:27,570
它的行为不像一台机器一样，

613
00:34:27,690 --> 00:34:32,610
它会产生在一台机器永远不会发生的结果。

614
00:34:33,450 --> 00:34:37,380
所以，它是什么，它提供了什么。

615
00:34:37,380 --> 00:34:41,190
它提供了线性化的写入，

616
00:34:51,880 --> 00:34:56,710
所以所有的写入操作都要通过领导者，

617
00:34:56,710 --> 00:34:59,200
通过日志，

618
00:34:59,440 --> 00:35:02,590
以相同的顺序写入到每个节点的日志中，

619
00:35:02,590 --> 00:35:04,720
所以，它们也将以相同的顺序应用，

620
00:35:04,720 --> 00:35:08,950
所以我们仍然有这个复制状态机方案，

621
00:35:08,950 --> 00:35:11,110
应用所有写入操作，

622
00:35:11,110 --> 00:35:17,920
（应用）修改数据的操作以一个整体顺序。

623
00:35:18,680 --> 00:35:22,490
但是，它还有几个特性。

624
00:35:23,040 --> 00:35:25,740
但是它不提供读取的线性一致性，

625
00:35:25,920 --> 00:35:28,980
而是提供了两种不同属性，

626
00:35:29,220 --> 00:35:38,640
所有操作以 FIFO 客户端顺序出现，

627
00:35:40,440 --> 00:35:42,210
这在一定程度上与异步有关，

628
00:35:42,990 --> 00:35:47,220
客户端可能会一个接一个地提交多个请求，

629
00:35:47,400 --> 00:35:49,950
而不等待回复。

630
00:35:50,100 --> 00:35:52,710
zookeeper 会保证，

631
00:35:52,710 --> 00:35:56,130
如果客户端 1 提交了请求，

632
00:35:56,580 --> 00:35:58,920
然后客户端 1 提交了另一个请求，

633
00:35:59,040 --> 00:36:02,850
那么第二个请求将会较晚出现，

634
00:36:02,880 --> 00:36:06,990
（第二次）结果会观察到第一次操作的结果。

635
00:36:08,740 --> 00:36:13,420
所以，写入使用客户端顺序，

636
00:36:23,600 --> 00:36:29,270
然后读取是我们感兴趣的性质，

637
00:36:32,430 --> 00:36:34,560
读取观察到最后一次写入，

638
00:36:34,620 --> 00:36:41,910
好的，读取观察到同一客户端的最后一次写入。

639
00:36:51,050 --> 00:36:52,130
所以这是有意义的，

640
00:36:52,130 --> 00:36:55,460
就像读取你自己写的东西，

641
00:36:55,730 --> 00:36:57,170
如果你执行写入操作，

642
00:36:57,170 --> 00:36:58,760
你立即执行读取操作，

643
00:36:58,760 --> 00:37:01,370
你至少可以看到自己写入的结果。

644
00:37:02,380 --> 00:37:06,160
但是，对于来自其他操作的，来自其他客户端的的写入，

645
00:37:06,250 --> 00:37:09,340
zookeeper 不保证那个[性质]，

646
00:37:09,340 --> 00:37:11,350
相反，它所保证的是，

647
00:37:11,470 --> 00:37:17,710
读取会观察到日志的某些前缀。

648
00:37:20,920 --> 00:37:25,660
这意味着你可以看到旧的数据，

649
00:37:29,620 --> 00:37:31,840
可能从一个跟随者读取，

650
00:37:31,870 --> 00:37:34,630
那个跟随者有一个日志的前缀，

651
00:37:34,780 --> 00:37:36,940
但没有日志中的最新条目，

652
00:37:36,940 --> 00:37:40,390
因为也许稍微落后了一点，

653
00:37:40,390 --> 00:37:45,700
尽管如此，跟随者允许返回一个值，

654
00:37:45,850 --> 00:37:50,020
因为 zookeeper 唯一保证的事，

655
00:37:50,020 --> 00:37:53,050
读取可以观察到日志的前缀。

656
00:37:54,680 --> 00:37:56,660
所以现在操作可以不按顺序进行，

657
00:37:56,810 --> 00:37:58,310
一旦它们在日志中，

658
00:37:58,310 --> 00:37:59,270
你不能，

659
00:37:59,270 --> 00:38:03,680
读取操作可以不按顺序，

660
00:38:03,710 --> 00:38:05,930
它真的是一个日志的前缀。

661
00:38:07,070 --> 00:38:08,600
然后还有第二个要求，

662
00:38:08,840 --> 00:38:11,600
你不能从过去读取，

663
00:38:18,250 --> 00:38:21,130
这意味着如果你看到了前缀 1 ，

664
00:38:22,900 --> 00:38:25,600
然后你发出读取前缀 1 ，

665
00:38:25,600 --> 00:38:27,340
然后你执行第二次读取，

666
00:38:27,700 --> 00:38:31,570
那么第二次读取必须至少看到前缀 1 或更多。

667
00:38:34,780 --> 00:38:37,240
它可能只是前缀 1 ，

668
00:38:37,300 --> 00:38:38,740
但不能回到过去，

669
00:38:38,740 --> 00:38:42,670
所以它不能看到比前缀 1 更小的前缀。

670
00:38:44,120 --> 00:38:45,470
所以这个，

671
00:38:45,470 --> 00:38:47,420
所以如果我们看回这张图，

672
00:38:49,690 --> 00:38:52,630
在某些情况下， zookeeper 允许这样做，

673
00:38:52,630 --> 00:38:55,510
也就是说，如果两个客户端不同，

674
00:38:56,060 --> 00:38:58,630
但它不允许这样，

675
00:38:58,630 --> 00:39:00,820
你永远不能回到过去。

676
00:39:01,700 --> 00:39:02,390
好的?

677
00:39:04,690 --> 00:39:07,210
所以我有一个概念性的问题，

678
00:39:07,270 --> 00:39:09,640
所以我们有两个一致性保证，

679
00:39:09,640 --> 00:39:12,430
可线性化写入和 FIFO 客户端顺序，

680
00:39:12,640 --> 00:39:15,100
如果我们暂时忽略第二个约束，

681
00:39:15,100 --> 00:39:16,750
如果我们只关注第一个问题，

682
00:39:17,110 --> 00:39:20,920
可线性化写入的定义真的有意义吗，

683
00:39:20,920 --> 00:39:22,870
因为线性化的定义

684
00:39:22,900 --> 00:39:26,320
取决于具有读操作和写操作。

685
00:39:26,530 --> 00:39:30,430
稍等一下，

686
00:39:30,460 --> 00:39:35,090
因为，他们定义可线性化写入的方式

687
00:39:35,090 --> 00:39:36,950
不是写入在整体顺序，

688
00:39:37,040 --> 00:39:39,440
但是在读取和写入之间存在关系，

689
00:39:39,440 --> 00:39:41,300
所以稍等一下，

690
00:39:42,160 --> 00:39:43,180
我们会回来，

691
00:39:43,180 --> 00:39:45,190
我们马上就到了，

692
00:39:45,220 --> 00:39:46,360
比如一个幻灯片，

693
00:39:46,660 --> 00:39:48,880
我想再说一个幻灯片，好吗？

694
00:39:50,020 --> 00:39:50,620
听起来不错。

695
00:39:52,180 --> 00:39:54,430
好的，就像，

696
00:39:54,430 --> 00:39:56,830
让我们来看看，

697
00:39:56,830 --> 00:40:00,310
zookeeper 是如何提供这些保证的。

698
00:40:00,890 --> 00:40:05,480
凭直觉来看，

699
00:40:06,350 --> 00:40:07,700
你如何实现这个，

700
00:40:07,970 --> 00:40:11,240
论文没有非常明确地说明他们是如何实现这个的，

701
00:40:11,420 --> 00:40:13,970
我会给你们一个大概最好的猜测。

702
00:40:14,640 --> 00:40:18,510
所以，这是一个 zookeeper 客户端，

703
00:40:21,150 --> 00:40:22,380
它在客户端机器上运行，

704
00:40:22,500 --> 00:40:25,020
在实验 3 中，我们称它为 clerk ，

705
00:40:25,050 --> 00:40:26,760
所以这是一个软件库的部分，

706
00:40:26,760 --> 00:40:29,280
与服务进行协作。

707
00:40:30,360 --> 00:40:33,750
在 zookeeper 论文术语中，

708
00:40:33,750 --> 00:40:35,610
它是有个 session 的东西，

709
00:40:36,030 --> 00:40:37,710
所以，当你加入时，

710
00:40:37,710 --> 00:40:39,990
当客户端想要连接 zookeeper 服务时，

711
00:40:39,990 --> 00:40:41,010
它会创建了一个 session ，

712
00:40:41,010 --> 00:40:44,460
它使用 session 信息连接到领导者，

713
00:40:44,460 --> 00:40:47,190
并在整个 session 期间维护状态。

714
00:40:48,050 --> 00:40:51,410
所以我们在 zookeeper 中有一个领导者，

715
00:40:51,410 --> 00:40:53,570
还有跟随者，

716
00:40:53,570 --> 00:40:55,580
基本上这有些相似，

717
00:40:56,100 --> 00:40:58,920
与我们在实验 2 中所做的，

718
00:40:59,250 --> 00:41:03,150
zookeeper 客户端发出一个写入到领导者，

719
00:41:03,180 --> 00:41:05,520
因为写入是可线性化的，

720
00:41:05,520 --> 00:41:07,260
事实上，写入基本上遵循

721
00:41:07,260 --> 00:41:11,190
与 raft 库中大致相同的策略，

722
00:41:11,190 --> 00:41:12,870
所以，会有一个日志，

723
00:41:13,110 --> 00:41:14,760
在日志中，

724
00:41:14,760 --> 00:41:17,970
所有写入都会被记录到插槽中，

725
00:41:18,000 --> 00:41:23,370
假设领导者将写入放到这个索引中，

726
00:41:23,790 --> 00:41:25,440
所以这有一个索引，

727
00:41:25,530 --> 00:41:29,880
在论文中，他们将这个索引称为 zxid ，

728
00:41:31,260 --> 00:41:35,220
所以，我认为你可以将 zxid 视为日志中的索引。

729
00:41:36,760 --> 00:41:40,570
当领导者提交时，

730
00:41:40,630 --> 00:41:44,200
一个条目写入到日志中，

731
00:41:44,200 --> 00:41:47,230
它将 zxid 返回给客户端，

732
00:41:47,530 --> 00:41:49,240
所以，客户端维护该状态，

733
00:41:50,550 --> 00:41:56,580
所以与 session 相关联的是上次写入时的 zxid 。

734
00:41:59,540 --> 00:42:00,260
好的?

735
00:42:02,060 --> 00:42:05,390
当客户端稍后读取时，

736
00:42:06,200 --> 00:42:08,120
读取不一定要到领导者，

737
00:42:08,120 --> 00:42:10,310
因为这是获得更高性能的目标，

738
00:42:10,310 --> 00:42:14,660
所以，读取可能会到其中一个跟随者，

739
00:42:16,180 --> 00:42:20,380
但是，读取将使用 zxid 标记，

740
00:42:20,380 --> 00:42:23,320
那个客户端上次写入完成的（zxid）。

741
00:42:24,930 --> 00:42:26,520
那么这意味着什么，

742
00:42:26,520 --> 00:42:28,830
好的，假设这个在后面，

743
00:42:28,830 --> 00:42:31,230
它有两个条目，

744
00:42:31,230 --> 00:42:33,660
但还没有观察到那个写入，

745
00:42:33,660 --> 00:42:36,420
因为领导者可能通过其他跟随者提交它。

746
00:42:37,560 --> 00:42:39,210
在这种情况下发生的是，

747
00:42:39,300 --> 00:42:43,350
这个跟随者的读取不会立即返回，

748
00:42:43,350 --> 00:42:48,480
而是等待相同的 zxid ，

749
00:42:49,660 --> 00:42:51,400
一旦我们看到了 zxid ，

750
00:42:51,400 --> 00:42:52,630
它会做出回应。

751
00:42:56,620 --> 00:42:58,390
当然还会有另一个客户端，

752
00:42:59,050 --> 00:43:02,380
也许在某个时候，这个写入会通过，

753
00:43:02,920 --> 00:43:07,900
可能那个客户端会执行另一个读取，

754
00:43:07,960 --> 00:43:11,110
所以它没有看到过其他的 zxid ，

755
00:43:11,530 --> 00:43:14,590
让我再画一个跟随者，

756
00:43:15,430 --> 00:43:16,960
假设这里有另一个跟随者，

757
00:43:16,960 --> 00:43:20,590
它还没有观察到最后一次写入，

758
00:43:21,340 --> 00:43:21,910
让我。

759
00:43:22,870 --> 00:43:24,220
所以还会有另一个，

760
00:43:24,220 --> 00:43:26,140
假设还有另一个客户端，

761
00:43:26,170 --> 00:43:27,640
它执行其他一些写入，

762
00:43:27,850 --> 00:43:29,440
这是我想要谈论的情景，

763
00:43:29,560 --> 00:43:33,880
还有另一个客户端将 w 附加在 cxid 之后，

764
00:43:33,880 --> 00:43:36,280
就在这里，

765
00:43:36,280 --> 00:43:38,320
但还没有观察到那个写入，

766
00:43:38,320 --> 00:43:39,730
我们在这里的，

767
00:43:40,140 --> 00:43:46,980
我们有两个插槽，

768
00:43:46,980 --> 00:43:47,790
我们要写入，

769
00:43:47,790 --> 00:43:51,870
但是绿色文字还没有出现在这个跟随者上，

770
00:43:52,170 --> 00:43:55,050
所以，如果客户端现在发出第二个读取，

771
00:43:55,050 --> 00:43:56,730
也许它会传给另一个跟随者，

772
00:43:57,350 --> 00:43:59,060
这是相同的 zxid ，

773
00:43:59,060 --> 00:44:01,010
因为它没有看到任何新的，

774
00:44:01,070 --> 00:44:03,620
那么客户端没有发出任何新的写入，

775
00:44:04,100 --> 00:44:05,150
它会到达那里，

776
00:44:05,180 --> 00:44:09,500
而那个（跟随者）允许立即做出回应，

777
00:44:10,600 --> 00:44:15,520
因为它已经看到了[]的 zxid ，

778
00:44:15,520 --> 00:44:18,130
已经看到那个客户端的 zxid ，

779
00:44:18,430 --> 00:44:20,470
当然，它遗漏了一些写入，

780
00:44:20,470 --> 00:44:22,030
来自其他客户端的，

781
00:44:22,030 --> 00:44:25,150
已经由大多数服务器处理的，

782
00:44:25,240 --> 00:44:27,460
但它不需要返回那个数据，

783
00:44:27,670 --> 00:44:28,870
所以它可以直接返回。

784
00:44:29,770 --> 00:44:32,980
所以，这可能返回旧的值，

785
00:44:33,640 --> 00:44:38,200
但这是 zookeeper 正确性保证定义所允许的。

786
00:44:39,040 --> 00:44:41,140
教授，我有个问题。

787
00:44:41,170 --> 00:44:41,620
好的。

788
00:44:42,010 --> 00:44:46,000
首先，我想，我不确定，但是，

789
00:44:46,520 --> 00:44:51,380
我知道客户端读取， session 读取是有粘性的，

790
00:44:51,800 --> 00:44:54,410
所以通常它们会去一样的（节点）。

791
00:44:54,970 --> 00:45:00,430
是的，但是，当然可能会有一点，

792
00:45:00,430 --> 00:45:04,450
可能有一个快速网络分区或类似的事情，

793
00:45:04,450 --> 00:45:06,340
所以在这中间，

794
00:45:06,760 --> 00:45:08,680
它可能已经切换到另一台服务器。

795
00:45:09,740 --> 00:45:12,320
好的，然后。

796
00:45:12,320 --> 00:45:15,620
另外， zookeeper 做了一些负载均衡，

797
00:45:16,370 --> 00:45:19,910
但是无论如何，这是会发生的。

798
00:45:20,510 --> 00:45:21,080
是的。

799
00:45:21,690 --> 00:45:23,100
另一件事是，

800
00:45:23,100 --> 00:45:29,490
你说写入总是到领导者，

801
00:45:29,920 --> 00:45:34,570
然后领导者用 zxid 回应，

802
00:45:34,630 --> 00:45:40,420
是不是领导者在回应之前必须先达成共识，

803
00:45:41,120 --> 00:45:41,990
或者类似。

804
00:45:42,980 --> 00:45:47,120
好的，我想是的，

805
00:45:47,990 --> 00:45:52,040
它提交了，否则就没有提交，

806
00:45:52,040 --> 00:45:54,380
我认为确切的协议，

807
00:45:54,680 --> 00:45:58,010
我在协议的细节上做了一点抽象，

808
00:45:58,010 --> 00:46:00,230
我只是大概描述一下它是如何工作的。

809
00:46:00,780 --> 00:46:02,310
我相信你是对的，

810
00:46:02,310 --> 00:46:04,620
它很可能返回，

811
00:46:04,620 --> 00:46:06,750
在条目真正提交之后。

812
00:46:08,310 --> 00:46:10,020
然后，抱歉，最后一件事，

813
00:46:10,080 --> 00:46:13,290
你说过它总是到领导者，

814
00:46:13,320 --> 00:46:16,410
但我认为论文描述它可能会到跟随者，

815
00:46:16,410 --> 00:46:18,180
写入到跟随者，然后读取。

816
00:46:18,300 --> 00:46:20,430
但是最后回到领导者，对吧，

817
00:46:21,630 --> 00:46:23,010
所以最终会到领导者。

818
00:46:23,850 --> 00:46:24,780
谢谢。

819
00:46:25,200 --> 00:46:25,590
好的。

820
00:46:26,460 --> 00:46:27,510
只是确认一下，

821
00:46:27,510 --> 00:46:29,970
当你说等待 zxid 时，

822
00:46:30,000 --> 00:46:32,850
比如第二个跟随者，

823
00:46:32,850 --> 00:46:34,200
当我们等待 zxid 时，

824
00:46:34,200 --> 00:46:36,030
我们实际上是在等待它被提交，

825
00:46:36,210 --> 00:46:38,490
仅仅[]是不够的。

826
00:46:38,490 --> 00:46:39,780
是的，它必须被提交。

827
00:46:40,340 --> 00:46:40,760
明白了。

828
00:46:42,960 --> 00:46:44,910
等等，但是，

829
00:46:45,240 --> 00:46:47,880
那时它已经提交了，

830
00:46:47,910 --> 00:46:52,500
比如一个客户端不会得到一个未提交的 zxid ，

831
00:46:52,740 --> 00:46:53,640
像以前一样。

832
00:46:53,640 --> 00:46:55,620
哦，是的，但这是正确的，

833
00:46:55,980 --> 00:46:59,310
所以如果这个点，

834
00:47:01,260 --> 00:47:04,470
在这点上，跟随者看到 zxid ，

835
00:47:04,470 --> 00:47:07,380
写入在这个 zxid ，

836
00:47:07,410 --> 00:47:08,760
现在它肯定已经提交了，

837
00:47:08,760 --> 00:47:11,340
因为客户端不可能获取那个 zxid ，

838
00:47:11,340 --> 00:47:14,280
除非那个 zxid 已经提交。

839
00:47:17,350 --> 00:47:17,800
谢谢。

840
00:47:18,760 --> 00:47:24,940
另外，你说读取到旧数据，

841
00:47:24,940 --> 00:47:27,130
就像最后一个箭头那样，

842
00:47:27,370 --> 00:47:30,220
但是在读请求中的客户端，

843
00:47:30,220 --> 00:47:32,380
它在提供了这些 zxid ，

844
00:47:32,410 --> 00:47:38,560
就像客户端想要日志中的那个位置一样，

845
00:47:38,990 --> 00:47:41,540
它以 zxid 为索引，

846
00:47:41,990 --> 00:47:46,910
那么它不是故意请求日志特定前缀吗？

847
00:47:47,120 --> 00:47:50,480
不是，但是这个 zxid 实际上说的是，

848
00:47:50,480 --> 00:47:54,080
它是时间倒流的计数器，

849
00:47:55,320 --> 00:47:58,260
所以，你拥有的 zxid ，

850
00:47:58,290 --> 00:48:01,050
作为跟随者，你必须返回到你的结果，

851
00:48:01,080 --> 00:48:05,190
至少通过 zxid [结束]了日志的前缀，

852
00:48:05,490 --> 00:48:07,680
你可能会有更多，那也没问题，

853
00:48:07,740 --> 00:48:09,180
但至少到 zxid ，

854
00:48:09,180 --> 00:48:11,820
这阻止了你读取过去的情况。

855
00:48:13,280 --> 00:48:13,670
好的，太棒了，谢谢。

856
00:48:16,090 --> 00:48:18,610
好的，所以现在你可能会想，

857
00:48:19,680 --> 00:48:22,470
这显然不能提供线性一致性，

858
00:48:22,470 --> 00:48:24,900
人们对线性一致性感到兴奋的一个原因是，

859
00:48:24,900 --> 00:48:26,340
因为它的行为像一台机器，

860
00:48:26,340 --> 00:48:27,330
所以它更容易编程，

861
00:48:27,420 --> 00:48:30,000
你执行 put ，你执行 get ，

862
00:48:30,000 --> 00:48:31,080
你大概知道你会得到什么，

863
00:48:31,610 --> 00:48:33,530
没有双关的（返回），

864
00:48:33,800 --> 00:48:38,330
但在这里，你有一个编程模型，

865
00:48:38,330 --> 00:48:39,770
不同于单一的机器，

866
00:48:40,560 --> 00:48:43,770
所以，你如何对这个东西进行编程。

867
00:48:44,700 --> 00:48:46,320
事实证明，

868
00:48:46,320 --> 00:48:47,790
这里的规则，

869
00:48:47,820 --> 00:48:50,850
zookeeper 使用的正确性定义，

870
00:48:51,240 --> 00:48:53,910
你可以把它想象成，

871
00:48:53,940 --> 00:48:58,950
它足够好来达到帮助编程的目的。

872
00:48:59,720 --> 00:49:01,760
所以，我想谈一谈这一点。

873
00:49:12,470 --> 00:49:14,090
所以真正的问题是，

874
00:49:14,360 --> 00:49:16,010
有了线性一致性，

875
00:49:16,010 --> 00:49:19,010
很明显这有助于编程，

876
00:49:19,010 --> 00:49:20,900
以及编写直观的程序，

877
00:49:21,020 --> 00:49:22,580
你的想法会有一点不同，

878
00:49:22,790 --> 00:49:23,930
我们想要了解，

879
00:49:23,930 --> 00:49:26,690
如果事情进展顺利，

880
00:49:26,690 --> 00:49:29,810
它是否像[]程序中的[]一样，

881
00:49:29,810 --> 00:49:31,250
是完全无法使用的。

882
00:49:32,280 --> 00:49:37,860
所以，让我们来看看这篇论文中提到的一个关键例子。

883
00:49:38,500 --> 00:49:41,500
我想做的第一件事是，

884
00:49:41,500 --> 00:49:43,330
忽略同步操作，

885
00:49:43,330 --> 00:49:48,340
因为你可以通过使用 sync 使每个操作线性化，

886
00:49:48,840 --> 00:49:50,340
在你读取之前，

887
00:49:50,700 --> 00:49:53,550
但这当然会让一切再次变得缓慢，

888
00:49:53,550 --> 00:49:54,810
我们得不到我们的性能，

889
00:49:55,050 --> 00:49:58,650
所以我们想要避免使用 sync ，

890
00:49:58,650 --> 00:50:00,150
所以我要忽略 sync ，

891
00:50:00,150 --> 00:50:02,760
像我们没有 sync 那样编程。

892
00:50:04,200 --> 00:50:06,270
那么让我们来看一下以下操作，

893
00:50:06,270 --> 00:50:08,220
所以这是写入的顺序，

894
00:50:13,220 --> 00:50:14,450
一些操作，

895
00:50:14,450 --> 00:50:16,160
这是准备好的 ready 文件，

896
00:50:16,160 --> 00:50:21,520
我们发出对 ready 文件的 delete ，

897
00:50:23,420 --> 00:50:28,760
比如说，这是一个新的 master ，

898
00:50:28,760 --> 00:50:34,730
成为新的领导者，

899
00:50:34,940 --> 00:50:38,960
所以需要在里面写入一个配置信息，

900
00:50:38,960 --> 00:50:43,940
比如谁是复制状态机的一部分，

901
00:50:43,940 --> 00:50:44,990
以及谁是领导者，

902
00:50:44,990 --> 00:50:47,360
所以它写入一些配置文件，

903
00:50:47,390 --> 00:50:58,580
write f1 ， write f2 ，然后 create ready ，

904
00:51:02,420 --> 00:51:03,980
然后其他跟随者，

905
00:51:04,560 --> 00:51:07,080
其他可能是读取顺序，

906
00:51:11,430 --> 00:51:18,830
它们可以调用 exists ready ，

907
00:51:22,650 --> 00:51:24,900
所以 zookeeper 执行 exists ，

908
00:51:24,900 --> 00:51:28,980
如果 ready 已经存在，

909
00:51:28,980 --> 00:51:31,770
那么这会是 true ，

910
00:51:31,770 --> 00:51:35,130
否则不是，你必须等待，

911
00:51:35,520 --> 00:51:37,560
所以让我们暂时忽略这个案例，

912
00:51:37,560 --> 00:51:40,110
假设第二个客户端，

913
00:51:40,110 --> 00:51:43,080
这是一个客户端执行写入操作，

914
00:51:43,080 --> 00:51:44,550
第二个客户端执行读取操作，

915
00:51:45,000 --> 00:51:46,590
如果它存在，

916
00:51:46,590 --> 00:51:51,500
然后，客户端读取 f1 ，然后读取 f2 。

917
00:51:55,200 --> 00:51:59,490
所以我们想要了解的事情，

918
00:51:59,490 --> 00:52:03,360
f1 这个 read 可以返回什么值。

919
00:52:11,850 --> 00:52:14,100
我们考虑的事情是，

920
00:52:14,100 --> 00:52:18,510
它可能会返回之前写入的结果，

921
00:52:18,510 --> 00:52:20,160
比这里还早的（写入），

922
00:52:25,750 --> 00:52:27,460
或者必须注意到这个写入。

923
00:52:33,230 --> 00:52:34,940
我想论文中提到了，

924
00:52:34,970 --> 00:52:38,630
读取可以 watch 某些内容，

925
00:52:38,630 --> 00:52:41,390
并在变化时得到通知。

926
00:52:41,810 --> 00:52:43,610
是的，我们假设文件确实存在，

927
00:52:43,610 --> 00:52:45,410
所以 create 是立即成功的，

928
00:52:45,440 --> 00:52:47,420
我们稍后再来讨论通知。

929
00:52:49,300 --> 00:52:51,820
所以这个 exists 立即返回，

930
00:52:52,530 --> 00:52:54,810
没有使用 watch ，只是使用 exists ，

931
00:52:55,260 --> 00:52:57,660
然后第二个客户端执行读取 f1 。

932
00:52:59,510 --> 00:53:03,350
我认为它应该读取第一个客户端写的东西，

933
00:53:03,350 --> 00:53:05,480
因为操作是按 FIFO 顺序进行的。

934
00:53:06,250 --> 00:53:08,230
是的，

935
00:53:08,260 --> 00:53:11,830
所以我认为真正的事情。

936
00:53:14,020 --> 00:53:16,000
如果我们看到了这个值，

937
00:53:16,000 --> 00:53:17,290
对于前面的写入，

938
00:53:17,290 --> 00:53:19,750
这意味着我们在回到过去，对吧。

939
00:53:20,600 --> 00:53:22,310
这是不允许的，

940
00:53:22,340 --> 00:53:24,470
规则是禁止的，

941
00:53:25,160 --> 00:53:31,220
这个读取必须观察到这个写入的值，

942
00:53:31,220 --> 00:53:35,690
因为这个 read 前的 exists 观察到这个写入，

943
00:53:35,690 --> 00:53:39,140
所以我们知道这个 exists id

944
00:53:39,140 --> 00:53:42,620
一定看到了这个 create 对应的 zxid ，

945
00:53:43,580 --> 00:53:44,420
也就是说，

946
00:53:44,420 --> 00:53:52,270
这个读取操作必须看到最后一次写入操作，

947
00:53:52,270 --> 00:53:54,010
这是按照总的顺序进行的，

948
00:53:54,010 --> 00:53:55,960
执行这个 create ，

949
00:53:55,960 --> 00:53:59,860
所以最后一个写入的关键顺序，

950
00:53:59,860 --> 00:54:02,110
在它之前是这个写入，

951
00:54:02,200 --> 00:54:04,060
因为所有写入都是线性化的。

952
00:54:05,280 --> 00:54:06,330
所以，必须是这种情况，

953
00:54:06,330 --> 00:54:09,600
这个 read f1 观察到 write f1 的结果。

954
00:54:10,240 --> 00:54:11,440
所以这很好，对吧，

955
00:54:11,440 --> 00:54:15,700
因为如果某个新领导着成为了 primary ，

956
00:54:15,700 --> 00:54:17,500
得到一个配置文件，

957
00:54:17,590 --> 00:54:18,730
我们肯定知道，

958
00:54:18,730 --> 00:54:21,370
我们将会看到最新的配置文件，

959
00:54:21,370 --> 00:54:23,620
由新领导者创建的。

960
00:54:26,020 --> 00:54:27,370
所以我们在这里看到了一个例子，

961
00:54:27,370 --> 00:54:29,410
这些规则是经过精心挑选的，

962
00:54:29,770 --> 00:54:31,900
一些你可能关心的事情，

963
00:54:31,930 --> 00:54:33,940
如果你编写一个配置服务器，

964
00:54:33,940 --> 00:54:35,320
那么它确实是可行的。

965
00:54:38,140 --> 00:54:41,680
抱歉，我之前可能没听懂你在说什么，

966
00:54:41,680 --> 00:54:44,410
但在这种情况下，如果它存在，

967
00:54:44,470 --> 00:54:45,940
如果检查 exists ready ，

968
00:54:46,060 --> 00:54:49,720
read stuff 不能在 delete ready 之前吗？

969
00:54:52,270 --> 00:54:53,770
好的，所有写入都是按整体顺序的，

970
00:54:53,800 --> 00:54:54,940
这些写入按整体顺序，

971
00:54:54,940 --> 00:54:56,050
那个写入按整体顺序，

972
00:54:56,050 --> 00:54:57,250
那个 create 按整体顺序，

973
00:54:58,150 --> 00:55:01,150
所以这个在另一边的 read 观察到那个 create ，

974
00:55:02,020 --> 00:55:03,730
所以不管 read 要做什么，

975
00:55:03,730 --> 00:55:05,200
往回走，在整体顺序中，

976
00:55:05,200 --> 00:55:08,500
在整体顺序中观察到的最后一次写入，

977
00:55:08,500 --> 00:55:10,240
而最后写入 f1 就是这个。

978
00:55:10,510 --> 00:55:12,640
但是 exists 是写入吗？

979
00:55:13,300 --> 00:55:14,230
不， exists 是读取，

980
00:55:14,260 --> 00:55:16,150
但是 exists 观察到了这个写入。

981
00:55:16,780 --> 00:55:18,250
哦，你是说。

982
00:55:18,250 --> 00:55:20,590
你不能读取回到过去，对吧，

983
00:55:20,590 --> 00:55:21,760
那是总的目标。

984
00:55:21,880 --> 00:55:26,440
是的，但我们怎么知道它观察到了，那个 exists 。

985
00:55:26,440 --> 00:55:27,220
我告诉你，

986
00:55:27,250 --> 00:55:28,780
我说就像文件存在，

987
00:55:28,780 --> 00:55:30,520
所以，它一定是观察到了，

988
00:55:31,520 --> 00:55:32,750
exists 会返回 true 。

989
00:55:32,990 --> 00:55:35,690
但是它存在在删除它之前，是吧。

990
00:55:37,720 --> 00:55:38,560
是的，

991
00:55:38,560 --> 00:55:41,320
但是，好的，我们一会儿回去，

992
00:55:41,320 --> 00:55:42,760
好的，这是第二种情况，

993
00:55:42,760 --> 00:55:43,600
这是很好的观点，

994
00:55:43,600 --> 00:55:45,370
让我来谈谈这一点，

995
00:55:45,370 --> 00:55:47,380
所以还有另一种情况，

996
00:55:47,380 --> 00:55:49,720
我想这就是你所担心的可能会发生的事情，

997
00:55:50,050 --> 00:55:51,760
这就是通知的作用。

998
00:55:52,900 --> 00:55:55,780
所以至少同意这是对的，是不。

999
00:55:56,340 --> 00:55:59,740
所以第二种情况，更多规则，

1000
00:56:01,570 --> 00:56:02,950
这是很有趣的。

1001
00:56:04,450 --> 00:56:06,520
我认为你所担心的情况是，

1002
00:56:07,100 --> 00:56:09,170
这是我们的读取者，

1003
00:56:09,260 --> 00:56:10,490
这是我们的写入者，

1004
00:56:10,940 --> 00:56:16,430
读取者调用 exists ready ，

1005
00:56:18,600 --> 00:56:22,620
除非文件在那里，

1006
00:56:22,620 --> 00:56:24,750
执行 read f1 。

1007
00:56:26,470 --> 00:56:28,900
好的，我们几乎和上一个场景一样，

1008
00:56:29,410 --> 00:56:32,200
现在，领导权发生了变化，

1009
00:56:32,200 --> 00:56:36,310
这里有一个崩溃，恢复，

1010
00:56:36,310 --> 00:56:37,600
所以这类事情发生，

1011
00:56:37,900 --> 00:56:40,540
所以有一个新的 primary ，

1012
00:56:40,990 --> 00:56:42,970
它执行 delete ready ，

1013
00:56:46,170 --> 00:56:52,640
write f1 和 write f2 ，

1014
00:56:54,520 --> 00:57:02,260
它像以前一样 create ready 。

1015
00:57:05,440 --> 00:57:08,170
我们假设这个读取有一点延迟，

1016
00:57:08,200 --> 00:57:10,060
这台机器上还发生了其他事情，

1017
00:57:10,770 --> 00:57:12,990
现在执行 read f2 。

1018
00:57:15,480 --> 00:57:17,910
我想这就是你所问的问题，

1019
00:57:17,910 --> 00:57:19,380
因为这是[]的事，

1020
00:57:19,620 --> 00:57:23,040
因为现在有了配置变化，

1021
00:57:23,250 --> 00:57:26,940
如果这个配置更改在中间被[淹没]，

1022
00:57:27,060 --> 00:57:31,860
这个 read f2 会返回新的配置，

1023
00:57:31,860 --> 00:57:35,310
相反， read f1 会返回旧的配置，

1024
00:57:35,370 --> 00:57:37,440
显然事情会变得一团糟，

1025
00:57:38,200 --> 00:57:40,510
这不是我们想要的情景，

1026
00:57:40,510 --> 00:57:41,770
所以结果很糟糕。

1027
00:57:42,870 --> 00:57:46,920
那么，这是如何得到纠正的，

1028
00:57:46,920 --> 00:57:49,320
或者 zookeeper 是如何处理这件事的。

1029
00:57:49,320 --> 00:57:51,900
好的，这就是 watch 的用处，

1030
00:57:52,320 --> 00:57:56,310
我在之前的白板上画的并不完全正确，

1031
00:57:56,340 --> 00:58:00,090
除了调用 exists ready ，

1032
00:58:00,090 --> 00:58:01,710
还要设置 watch 为 true 。

1033
00:58:08,370 --> 00:58:12,240
这意味着，

1034
00:58:12,240 --> 00:58:16,790
这个 delete 修改 ready 文件，

1035
00:58:16,790 --> 00:58:19,130
我们现在设置了 watch 在 ready 文件上，

1036
00:58:19,610 --> 00:58:25,760
所以，当 ready 文件被该新的 primary 删除时，

1037
00:58:25,790 --> 00:58:27,530
这会导致一个通知。

1038
00:58:34,780 --> 00:58:36,580
这个通知有一条规则，

1039
00:58:37,000 --> 00:58:38,890
通知的规则是，

1040
00:58:38,890 --> 00:58:45,040
每个通知都在它之后的 write 之前发送。

1041
00:58:46,320 --> 00:58:48,060
那么情况会是，

1042
00:58:48,060 --> 00:58:54,690
这个通知将在 write f1 之前发送。

1043
00:58:56,320 --> 00:58:58,570
所以，这里有两种情况，

1044
00:58:58,570 --> 00:59:00,520
如果通知在这里发送，

1045
00:59:02,130 --> 00:59:05,460
或者通知在 read f2 之后发送。

1046
00:59:06,420 --> 00:59:08,820
让我把 read f1 往上移一点，

1047
00:59:12,310 --> 00:59:13,390
或者是的，

1048
00:59:13,930 --> 00:59:14,860
所以，它仍然发生，

1049
00:59:14,860 --> 00:59:18,010
从时间上来说，在 write 操作之后，

1050
00:59:18,310 --> 00:59:21,580
但根据延误情况，通知在这里送达，

1051
00:59:21,760 --> 00:59:23,200
或者它会在这里送达。

1052
00:59:23,930 --> 00:59:28,280
抱歉，允许这种情况发生的具体规定是什么？

1053
00:59:30,260 --> 00:59:32,900
基本上，我认为一种方式来考虑它，

1054
00:59:32,900 --> 00:59:35,270
通知就像是一个写入操作，

1055
00:59:36,200 --> 00:59:38,630
跟随者实现了，

1056
00:59:38,720 --> 00:59:44,300
如果发生改变， delete 通知发出，

1057
00:59:44,300 --> 00:59:47,840
通知会和 zxid 一起发送给客户端。

1058
00:59:51,010 --> 00:59:54,220
是的，但我还是不明白为什么这能保证，

1059
00:59:54,220 --> 01:00:00,270
它能到达之前，

1060
01:00:00,850 --> 01:00:03,280
等等，所以它的有效位置是，

1061
01:00:03,310 --> 01:00:10,720
在 write f1 之前，也可以在 write f2 之后，对吗？

1062
01:00:11,340 --> 01:00:15,720
通知在 delete ready 之后发送，

1063
01:00:16,260 --> 01:00:17,610
并且在写入之前，

1064
01:00:17,610 --> 01:00:19,770
在写入 f1 和 f2 之前，

1065
01:00:20,340 --> 01:00:22,260
或者在 create 。

1066
01:00:23,540 --> 01:00:24,260
哦，我明白了。

1067
01:00:30,230 --> 01:00:32,870
这只是一个规则， zookeeper 必须保证这一点。

1068
01:00:33,480 --> 01:00:34,230
好的。

1069
01:00:34,800 --> 01:00:37,140
好的，所以这意味着有两种情况，

1070
01:00:37,140 --> 01:00:38,730
通知发送，

1071
01:00:38,730 --> 01:00:41,220
在 read f1 之前或 read f1 之后。

1072
01:00:42,560 --> 01:00:46,790
如果它在 read f2 之后发送，

1073
01:00:47,030 --> 01:00:48,020
会有问题吗？

1074
01:00:50,920 --> 01:00:51,400
没有。

1075
01:00:51,430 --> 01:00:54,340
没有，因为读操作就发生在写操作之前。

1076
01:00:54,610 --> 01:00:55,420
所以一切都很好，

1077
01:00:55,450 --> 01:00:59,470
这整个块都发生在 read f2 之后，是可以的，

1078
01:00:59,470 --> 01:01:00,220
那么在这里呢？

1079
01:01:03,270 --> 01:01:08,610
教授，你是说 watch 就像写入某些东西吗？

1080
01:01:09,450 --> 01:01:11,640
你可以考虑一下，

1081
01:01:11,640 --> 01:01:13,020
watch 不是写操作，

1082
01:01:13,020 --> 01:01:14,490
我并不是想表示这个，

1083
01:01:14,490 --> 01:01:18,420
watch 执行使用合适的 zxid ，

1084
01:01:18,600 --> 01:01:21,420
与这个修改有关。

1085
01:01:21,940 --> 01:01:23,800
这些是本地的，对吗， watch 。

1086
01:01:23,800 --> 01:01:25,240
是的， watch 是本地的，

1087
01:01:25,240 --> 01:01:26,410
当它们在执行时，

1088
01:01:26,590 --> 01:01:32,110
保证它们发生在写入时，

1089
01:01:32,410 --> 01:01:34,000
当观察到写入，

1090
01:01:34,300 --> 01:01:35,740
或者客户端发现[]，

1091
01:01:35,740 --> 01:01:38,350
watch 传播 zxid 到客户端，

1092
01:01:38,350 --> 01:01:39,820
并确保执行它。

1093
01:01:41,070 --> 01:01:41,550
谢谢。

1094
01:01:44,200 --> 01:01:47,080
再说一次，论文有点模糊，关于它是如何实现的，

1095
01:01:47,110 --> 01:01:48,790
但你可以想象不同的情景，

1096
01:01:50,170 --> 01:01:52,330
但重要的是这些规则是保证的。

1097
01:01:52,420 --> 01:01:54,940
好的，那么如果通知送到这里，会发生什么？

1098
01:01:58,140 --> 01:01:59,730
客户端正在运行，

1099
01:01:59,730 --> 01:02:01,110
exists ， read f1 ，

1100
01:02:01,110 --> 01:02:02,640
现在通知来了。

1101
01:02:06,020 --> 01:02:07,520
那么，你可能必须重新启动。

1102
01:02:07,520 --> 01:02:08,960
是的，你必须重新启动。

1103
01:02:14,800 --> 01:02:18,800
好的？所以我们在这里看到的是，

1104
01:02:18,830 --> 01:02:23,150
这个规则肯定会让编程变得更加困难，

1105
01:02:23,360 --> 01:02:25,250
但并不是不可能，

1106
01:02:25,840 --> 01:02:28,930
只要稍加小心的编程，

1107
01:02:28,930 --> 01:02:31,000
理解这些规则，

1108
01:02:31,000 --> 01:02:33,670
你可以得到想要的结果，

1109
01:02:33,670 --> 01:02:35,620
可能是应用程序想要的。

1110
01:02:36,080 --> 01:02:38,150
read f1 发生了什么？

1111
01:02:39,480 --> 01:02:41,040
read f1 会发生什么？

1112
01:02:41,220 --> 01:02:42,570
你得从头开始。

1113
01:02:43,110 --> 01:02:44,190
包括这一点。

1114
01:02:44,250 --> 01:02:44,850
是的。

1115
01:02:47,780 --> 01:02:48,410
好的?

1116
01:02:50,120 --> 01:02:51,410
你会发现这是一个技巧，

1117
01:02:51,410 --> 01:02:53,180
在[]中表现得很明显，

1118
01:02:53,210 --> 01:02:58,640
就像这个想法，跳出并重新开始。

1119
01:02:59,820 --> 01:03:03,870
好的，希望这能给你两件事的感觉，

1120
01:03:04,110 --> 01:03:07,230
尽管人们，

1121
01:03:07,230 --> 01:03:09,300
人们喜欢线性一致性的一个原因是

1122
01:03:09,300 --> 01:03:10,440
因为它非常直观，

1123
01:03:10,470 --> 01:03:11,790
非常容易编程，

1124
01:03:11,790 --> 01:03:13,350
因为每件事都像一台机器一样。

1125
01:03:13,800 --> 01:03:16,770
但是如果你想要容错，可伸缩性，

1126
01:03:16,860 --> 01:03:18,570
很难得到好的性能，

1127
01:03:18,570 --> 01:03:20,520
所以，获得良好性能的一种方法是

1128
01:03:20,520 --> 01:03:22,830
在一致性保证上妥协，

1129
01:03:23,100 --> 01:03:24,210
在这种情况下，

1130
01:03:24,210 --> 01:03:26,130
对线性一致性妥协，

1131
01:03:26,250 --> 01:03:28,080
并提供一些其他的一致性保证，

1132
01:03:28,080 --> 01:03:29,010
正如我们所看到的，

1133
01:03:29,130 --> 01:03:33,930
这让用户体验，程序员的体验变得复杂，

1134
01:03:34,020 --> 01:03:37,500
但是， zookeeper 中的这些规则是经过精心挑选的，

1135
01:03:37,620 --> 01:03:39,690
所以，事情仍然是可以解决的，

1136
01:03:41,320 --> 01:03:42,910
它是可行的。

1137
01:03:43,650 --> 01:03:46,950
所以，它可能获得某种程度上的写入保证。

1138
01:03:48,300 --> 01:03:51,330
所以，现在这个编程模型还有另一个方面，

1139
01:03:51,360 --> 01:03:52,980
然后现在我想谈一谈，

1140
01:03:52,980 --> 01:03:55,440
这与协调服务部分有关。

1141
01:04:05,830 --> 01:04:10,330
比如，你需要，

1142
01:04:10,330 --> 01:04:12,760
一个协调服务指的是什么。

1143
01:04:13,460 --> 01:04:18,650
一个很好的例子是虚拟机容错论文，

1144
01:04:18,650 --> 01:04:20,420
我们不久前读过的，

1145
01:04:20,720 --> 01:04:23,570
它有这个 test-and-set 操作，

1146
01:04:27,520 --> 01:04:29,620
test-and-set 操作的目标是

1147
01:04:29,620 --> 01:04:31,570
确保没有脑裂，

1148
01:04:31,570 --> 01:04:33,310
因为会有两个客户端运行，

1149
01:04:33,700 --> 01:04:36,430
一个会赢得 test-and-set ，而另一个不会，

1150
01:04:36,430 --> 01:04:39,040
结果是赢得 test-and-set 的那个

1151
01:04:39,160 --> 01:04:42,490
可以得出结论，它会是 primary 。

1152
01:04:43,130 --> 01:04:45,620
所以，这是一个例子，

1153
01:04:45,620 --> 01:04:50,060
关于协调服务应该提供的特性。

1154
01:04:51,520 --> 01:04:56,290
我想让你，让它更具体一点，

1155
01:04:56,320 --> 01:04:58,990
让我们来考虑一个实验 3 ，

1156
01:04:59,020 --> 01:05:01,030
你能在实验 3 中获得它吗，

1157
01:05:01,810 --> 01:05:04,690
一种 test-and-set 类型的东西。

1158
01:05:04,690 --> 01:05:09,780
好的，我们来做一个非常简单的案例，

1159
01:05:09,780 --> 01:05:12,690
假设我们有，

1160
01:05:12,690 --> 01:05:14,850
这是 test-and-set 的简单实现，

1161
01:05:17,400 --> 01:05:20,580
在实验 3 中，我们只有 put 和 get 操作，

1162
01:05:20,580 --> 01:05:22,230
没有其他操作，

1163
01:05:22,230 --> 01:05:23,460
这是两个操作，

1164
01:05:23,460 --> 01:05:25,020
所以你如何编写这个，

1165
01:05:25,020 --> 01:05:32,000
可能执行 put 到一个 key 中，比如 master ，

1166
01:05:34,760 --> 01:05:36,560
把我的 IP 地址放进去，

1167
01:05:36,920 --> 01:05:38,780
调用放的 IP 地址，

1168
01:05:40,490 --> 01:05:42,110
然后你执行 get ，

1169
01:05:42,290 --> 01:05:50,960
我们说如果 get master 等于我的 IP 地址，

1170
01:05:55,520 --> 01:05:59,510
然后知道作为 master 或者作为领导者。

1171
01:06:02,550 --> 01:06:05,130
实际上，这是我们天真的实现，

1172
01:06:05,160 --> 01:06:07,110
我们没有别的选择，

1173
01:06:07,110 --> 01:06:09,420
因为我们只有 put 和 get ，

1174
01:06:09,810 --> 01:06:11,190
这就是我们可以实现这个的方式。

1175
01:06:13,150 --> 01:06:15,130
这会带来我们想要的结果吗？

1176
01:06:23,240 --> 01:06:26,960
哦，在 put 和 get 之间没有原子性，

1177
01:06:26,960 --> 01:06:29,030
所以，也许有些事情发生了变化。

1178
01:06:29,420 --> 01:06:31,610
对的，所以可以有两个客户端，对吧，

1179
01:06:31,610 --> 01:06:34,220
两个可以同时执行 put ，

1180
01:06:36,440 --> 01:06:41,270
然后观察，

1181
01:06:41,860 --> 01:06:45,790
大体上，它们可以同时做这件事，

1182
01:06:45,790 --> 01:06:47,950
而交错涉及到

1183
01:06:47,950 --> 01:06:50,800
get 返回它们的 IP 地址，

1184
01:06:51,190 --> 01:06:53,170
这样我们就得到两个领导者了。

1185
01:06:57,240 --> 01:06:58,560
当然不是我们想要的，

1186
01:06:58,560 --> 01:07:00,630
所以这件事的要点是，

1187
01:07:00,630 --> 01:07:03,870
比如，你只有 put 和 get ，

1188
01:07:04,140 --> 01:07:06,720
要实现 test-and-set 是非常困难的。

1189
01:07:07,580 --> 01:07:10,010
事实证明，这是可能的，但非常复杂，

1190
01:07:10,040 --> 01:07:12,980
使用 bakery 算法，你可能能做到，

1191
01:07:12,980 --> 01:07:14,360
但这是可笑的，

1192
01:07:14,360 --> 01:07:15,980
在分布式系统中这样做，

1193
01:07:17,090 --> 01:07:20,000
所以， zookeeper 所做的，

1194
01:07:20,210 --> 01:07:24,410
它提供了一些额外的帮助，

1195
01:07:24,710 --> 01:07:27,050
来构建[]原语，

1196
01:07:27,710 --> 01:07:28,640
我们一会儿会看到。

1197
01:07:31,120 --> 01:07:33,280
另一件事是你想知道的，

1198
01:07:33,310 --> 01:07:36,460
实验 3 没有提供任何支持，

1199
01:07:36,460 --> 01:07:39,580
对你的配置服务或协调服务，

1200
01:07:39,580 --> 01:07:41,770
你想知道当一些机器宕机时，

1201
01:07:42,190 --> 01:07:43,630
例如，你想要观察，

1202
01:07:43,630 --> 01:07:44,980
比如领导者宕机，

1203
01:07:44,980 --> 01:07:47,620
一些其他部分需要知道，

1204
01:07:47,620 --> 01:07:49,060
领导者宕机了，

1205
01:07:49,060 --> 01:07:50,830
我们就可以在需要的时候选择一个新的，

1206
01:07:51,810 --> 01:07:56,580
至少在使用服务构建的应用上是这样的。

1207
01:07:57,330 --> 01:08:00,390
好吧，我们有两个东西是真正想要的，

1208
01:08:00,420 --> 01:08:03,720
一个是试图使这个获得原子性的方式，

1209
01:08:04,780 --> 01:08:07,840
这就是我们在 zookeeper 设计中寻找的，

1210
01:08:07,840 --> 01:08:10,930
然后我们在 zookeeper 设计中寻找的第二个是，

1211
01:08:10,930 --> 01:08:15,100
让应用程序了解某个节点是否宕机。

1212
01:08:16,680 --> 01:08:19,620
所以，让我们来看一下 zookeeper API ，

1213
01:08:19,620 --> 01:08:22,740
我们真正想要了解的是 znode API 。

1214
01:08:27,360 --> 01:08:28,200
你会再次看到，

1215
01:08:28,200 --> 01:08:29,880
这是精心设计的，

1216
01:08:29,880 --> 01:08:31,050
让它是可能的，

1217
01:08:31,050 --> 01:08:34,320
做我们正在寻找的事情。

1218
01:08:34,980 --> 01:08:37,650
好的，所以这个系统的组织方式是，

1219
01:08:37,650 --> 01:08:39,840
这里有一个 znodes 树，

1220
01:08:40,200 --> 01:08:46,260
通常情况下，有一个 app1 作为 znode ，

1221
01:08:46,290 --> 01:08:47,430
可能有一些子项，

1222
01:08:47,430 --> 01:08:51,720
与 app1 中的机器相对应，

1223
01:08:52,190 --> 01:08:56,480
比如机器 1 ， 机器2 ，

1224
01:08:56,480 --> 01:08:59,180
比如 IP 地址或 DNS 名称，

1225
01:08:59,540 --> 01:09:00,560
机器 3 ，

1226
01:09:01,080 --> 01:09:04,110
它们可能有关联的版本号，

1227
01:09:04,710 --> 01:09:06,000
或者相关联的序列号。

1228
01:09:06,330 --> 01:09:09,720
基本上， znode 有三种类型，

1229
01:09:10,450 --> 01:09:11,710
一，它们可以是常规的，

1230
01:09:13,030 --> 01:09:15,970
所以它们的容错复制了所有这类东西。

1231
01:09:16,240 --> 01:09:18,100
然后它们可能是临时的，

1232
01:09:21,220 --> 01:09:25,960
而临时意味着节点将会自动消失，

1233
01:09:25,960 --> 01:09:31,750
当机器 3 的 session 离开时，

1234
01:09:32,380 --> 01:09:34,390
要么是因为网络分区，

1235
01:09:34,390 --> 01:09:37,300
机器 3 没有更多心跳，

1236
01:09:37,630 --> 01:09:40,810
但在某个时候， zookeeper 认为时间已经到了，

1237
01:09:41,050 --> 01:09:44,710
然后它会自动删除那个节点，

1238
01:09:46,040 --> 01:09:47,750
这就是临时节点。

1239
01:09:49,400 --> 01:09:52,040
然后第三个是顺序的，

1240
01:09:52,930 --> 01:09:54,220
糟糕，返回，

1241
01:09:54,220 --> 01:09:59,370
第三个类型是顺序节点，

1242
01:09:59,370 --> 01:10:00,420
这意味着，

1243
01:10:00,420 --> 01:10:03,750
它们名字中与它们相关联的版本号，

1244
01:10:04,140 --> 01:10:10,080
它们是在特定的 znode 下一个接一个创建的，

1245
01:10:10,170 --> 01:10:15,000
所有的子节点都在它们的名字中有一个序列号，

1246
01:10:15,000 --> 01:10:17,370
并且节点按序列号排序，

1247
01:10:19,400 --> 01:10:21,200
这个可能是有序列号 1 ，

1248
01:10:21,200 --> 01:10:22,400
这个可能有序列号 2 ，

1249
01:10:22,400 --> 01:10:23,870
这个可能有序列号 3 ，

1250
01:10:23,870 --> 01:10:27,080
而新创建的将会有大于 3 的序列号。

1251
01:10:29,480 --> 01:10:32,990
好的，有一个与之相关的 API ，

1252
01:10:32,990 --> 01:10:34,490
我想谈一谈，

1253
01:10:34,490 --> 01:10:38,270
有一个 create ，我们之前提到过，

1254
01:10:38,760 --> 01:10:43,140
使用一个 path ，一些 data 和 flags ，

1255
01:10:43,800 --> 01:10:46,740
flags 对应于三种情况。

1256
01:10:47,850 --> 01:10:48,960
然后有一个 delete ，

1257
01:10:50,390 --> 01:10:52,850
在上一张幻灯片中，有一点误导，

1258
01:10:52,850 --> 01:10:55,850
delete 使用一个 path ，以及一个版本号。

1259
01:10:57,980 --> 01:11:02,930
exists 使用一个 path 和 watch 。

1260
01:11:05,240 --> 01:11:09,000
然后是一个 getData 原语，

1261
01:11:09,030 --> 01:11:11,400
使用一个 path 和版本号，

1262
01:11:14,290 --> 01:11:16,360
我们会看到这些版本号就是技巧，

1263
01:11:16,420 --> 01:11:18,430
是获得原子性的关键。

1264
01:11:18,700 --> 01:11:24,240
然后 setData 有一个 path data 和版本号。

1265
01:11:26,130 --> 01:11:28,320
还有一个 getChildren 的调用，

1266
01:11:28,350 --> 01:11:32,220
可以获得特定 znode 的子节点，

1267
01:11:32,460 --> 01:11:36,370
它使用一个 path 和 watch 。

1268
01:11:38,710 --> 01:11:41,530
还有同步调用操作，

1269
01:11:41,530 --> 01:11:43,000
为了确保，

1270
01:11:43,330 --> 01:11:45,910
如果你真的需要强线性一致性。

1271
01:11:47,450 --> 01:11:50,150
好的，所以我想讨论一下，

1272
01:11:50,150 --> 01:11:53,540
为什么这个版本号是方便的，

1273
01:11:53,570 --> 01:11:58,430
所以，让我们来看这个简单的例子，

1274
01:11:58,430 --> 01:12:00,710
我通常想出一个实现计数器。

1275
01:12:07,090 --> 01:12:10,810
所以你编写的方式，

1276
01:12:11,560 --> 01:12:13,360
如果你编写，

1277
01:12:13,360 --> 01:12:15,760
好的，首先是写入方案，

1278
01:12:15,760 --> 01:12:18,160
所以 while true ，

1279
01:12:19,450 --> 01:12:21,160
你实现增量的方式，

1280
01:12:21,460 --> 01:12:24,490
所以这里是这个计数器递增的伪代码，

1281
01:12:24,670 --> 01:12:32,410
你使用 x,v = getData 计数器，

1282
01:12:34,720 --> 01:12:37,090
getData count ，

1283
01:12:39,160 --> 01:12:48,770
然后，如果 setData count ，

1284
01:12:50,470 --> 01:12:57,820
x+1 以及版本号，

1285
01:12:59,100 --> 01:13:01,680
如果是这种情况，然后 break 。

1286
01:13:03,920 --> 01:13:05,990
好的，让我快速回顾一下，

1287
01:13:06,170 --> 01:13:12,710
所以， getData 返回当前版本号和 key 的值，

1288
01:13:13,280 --> 01:13:15,170
所以 key 或 path ，

1289
01:13:15,170 --> 01:13:16,400
对于文件数量，

1290
01:13:16,400 --> 01:13:18,950
它返回当时的值和版本号，

1291
01:13:18,950 --> 01:13:19,880
当它们读取时，

1292
01:13:20,480 --> 01:13:23,660
然后你调用， setData 接受三个参数，

1293
01:13:23,660 --> 01:13:26,180
path ，更新值，

1294
01:13:26,180 --> 01:13:27,560
在这种情况下，它是 x+1 ，

1295
01:13:27,560 --> 01:13:29,690
因为我们希望将值递增 1 ，

1296
01:13:29,930 --> 01:13:32,360
然后它传入版本号，

1297
01:13:32,450 --> 01:13:36,360
setData 的语义是，

1298
01:13:36,360 --> 01:13:39,300
如果版本号仍然相同，

1299
01:13:40,330 --> 01:13:43,420
那么 setData 发生，否则不发生。

1300
01:13:44,770 --> 01:13:46,510
那么，这能防止什么呢？

1301
01:13:49,740 --> 01:13:55,260
这可以防止你交错 get-and-set 。

1302
01:13:56,400 --> 01:14:00,300
所以，如果两个客户端在同一时间执行 get ，

1303
01:14:00,510 --> 01:14:02,220
它们会读到，

1304
01:14:03,980 --> 01:14:05,660
它们在同一时间执行 get ，

1305
01:14:06,640 --> 01:14:12,700
它们都会获得比如 x 0 ，版本号 0 ，

1306
01:14:13,090 --> 01:14:15,400
x 0 ，版本号 0 ，

1307
01:14:16,170 --> 01:14:18,750
然后它们都执行 put ，

1308
01:14:19,020 --> 01:14:20,550
就像本例中的 setData ，

1309
01:14:22,400 --> 01:14:28,570
所以， setData 使用 x 1 ，版本号 0 ，

1310
01:14:29,260 --> 01:14:30,940
这个也做了同样的事情，

1311
01:14:30,970 --> 01:14:34,130
set 1 0 。

1312
01:14:35,480 --> 01:14:37,130
你知道为什么，

1313
01:14:37,130 --> 01:14:40,670
所以两个客户端发出两个 set 操作，

1314
01:14:40,670 --> 01:14:42,380
两个 set 操作[]？

1315
01:14:50,590 --> 01:14:51,280
没有。

1316
01:14:51,900 --> 01:14:52,770
是的，为什么不。

1317
01:14:53,660 --> 01:14:56,270
因为其中一个版本号将是错误的。

1318
01:14:56,960 --> 01:14:59,570
是的，两个中的一个先执行，

1319
01:14:59,600 --> 01:15:01,400
为什么两个中的一个会执行？

1320
01:15:02,440 --> 01:15:04,660
因为所有写入都是线性化的。

1321
01:15:04,720 --> 01:15:05,950
是的，所有的写入都是线性化的，

1322
01:15:05,950 --> 01:15:07,450
它们使用一个整体顺序，

1323
01:15:07,480 --> 01:15:08,890
所以我们可以选一个，

1324
01:15:08,890 --> 01:15:10,240
所以我们假设这个先执行，

1325
01:15:10,240 --> 01:15:11,710
或者这个操作先执行，

1326
01:15:12,300 --> 01:15:14,700
所以这会增加，

1327
01:15:14,880 --> 01:15:21,330
这会增加值到 1 ，

1328
01:15:21,330 --> 01:15:22,560
从 0 到 1 ，

1329
01:15:22,560 --> 01:15:25,080
而且也会执行，

1330
01:15:25,080 --> 01:15:26,700
因为版本号是匹配的，

1331
01:15:26,700 --> 01:15:29,370
因为版本号 0 就是当前的版本号，

1332
01:15:29,760 --> 01:15:32,370
所以版本号匹配，增加会发生，

1333
01:15:32,490 --> 01:15:34,770
并且 setData 返回 true 。

1334
01:15:35,360 --> 01:15:36,620
第二个会发生什么，

1335
01:15:36,620 --> 01:15:38,420
第二个，版本号将不匹配，

1336
01:15:38,420 --> 01:15:40,220
因为版本号会增加，

1337
01:15:40,220 --> 01:15:42,530
由于之前的 setData 操作，

1338
01:15:42,710 --> 01:15:45,020
所以第二个 setData 操作将会失败，

1339
01:15:45,410 --> 01:15:48,410
然后客户端将会循环并重试，

1340
01:15:48,410 --> 01:15:53,780
试着再做一次，执行增加。

1341
01:15:54,480 --> 01:15:57,540
所以在这种情况下发生的事情，

1342
01:15:57,540 --> 01:16:02,130
即使两个客户端同时执行这个操作，

1343
01:16:02,130 --> 01:16:03,540
如果交错不好，

1344
01:16:03,540 --> 01:16:06,360
这段代码会执行写入，

1345
01:16:06,360 --> 01:16:07,740
第二个客户端将重试，

1346
01:16:07,830 --> 01:16:09,270
结果就是，

1347
01:16:09,810 --> 01:16:14,190
最终的值会是 2 而不是 1 。

1348
01:16:14,990 --> 01:16:15,710
好的?

1349
01:16:19,430 --> 01:16:20,210
这能理解吗？

1350
01:16:23,860 --> 01:16:26,980
如果你在过去做过任何类型的无锁编程，

1351
01:16:27,070 --> 01:16:29,410
那么你现在可能看起来很熟了，

1352
01:16:29,500 --> 01:16:31,690
所以这种无锁的风格

1353
01:16:31,690 --> 01:16:35,440
zookeeper 鼓励这种无锁的编程风格。

1354
01:16:44,840 --> 01:16:48,890
好的，我想做的是，

1355
01:16:49,010 --> 01:16:50,420
因为我快没时间了，

1356
01:16:50,420 --> 01:16:52,250
最后时间，

1357
01:16:52,250 --> 01:16:56,060
我想谈几点关于日志的问题，

1358
01:16:56,420 --> 01:16:58,970
但我会在下次这么做，

1359
01:16:59,450 --> 01:17:01,820
下一节课。

1360
01:17:02,000 --> 01:17:05,000
现在让我来总结一下，我们到目前为止所学到的东西，

1361
01:17:05,000 --> 01:17:08,690
然后我将在下一节课中更多地谈论 zookeeper 。

1362
01:17:10,560 --> 01:17:13,260
所以，作为总结，

1363
01:17:15,550 --> 01:17:18,910
所以这是一个非常成功的设计，

1364
01:17:25,300 --> 01:17:26,230
被广泛使用，

1365
01:17:26,260 --> 01:17:29,230
你可以在 gitHub 上下载，

1366
01:17:29,230 --> 01:17:31,330
如果你想的话，你可以玩它，

1367
01:17:31,690 --> 01:17:34,030
其中有趣的一点是，

1368
01:17:34,330 --> 01:17:36,340
与我们目前看到的所有系统相比，

1369
01:17:36,520 --> 01:17:38,650
它的一致性较弱，

1370
01:17:38,650 --> 01:17:42,280
较弱的一致性，我的意思是，它不提供线性一致性，

1371
01:17:44,350 --> 01:17:50,020
我们看到一个精心设计的 API ，

1372
01:17:50,020 --> 01:17:52,900
至少我们已经看到了精心设计的 API 的某些方面，

1373
01:17:52,900 --> 01:17:55,960
尽管它具有弱的一致性，

1374
01:17:56,020 --> 01:17:57,190
你仍然可以使用它，

1375
01:17:57,190 --> 01:18:00,970
事实上，你可以把它用在非常重要的应用上，

1376
01:18:00,970 --> 01:18:04,060
你可以将 zookeeper 用作配置服务，

1377
01:18:04,540 --> 01:18:07,240
比如它的主要目的是跟踪，

1378
01:18:07,240 --> 01:18:13,210
比如谁是 primary ，什么是复制等等，

1379
01:18:13,420 --> 01:18:16,510
所以，对于这种作为配置服务的关键操作，

1380
01:18:16,510 --> 01:18:17,500
这必须是正确的，

1381
01:18:17,500 --> 01:18:19,750
因为否则我们就会有脑裂的问题，

1382
01:18:20,020 --> 01:18:22,090
API 精心设计，

1383
01:18:22,090 --> 01:18:24,340
所以，如果你正确使用 API ，

1384
01:18:24,580 --> 01:18:30,040
你仍然可以在其上实现这个关键的应用程序，

1385
01:18:30,570 --> 01:18:33,480
尽管这提供了弱一致性。

1386
01:18:34,420 --> 01:18:36,460
最酷的是，

1387
01:18:36,520 --> 01:18:37,870
这种区别，

1388
01:18:37,930 --> 01:18:40,960
精心设计的 API 和弱一致性，

1389
01:18:41,050 --> 01:18:43,750
允许 zookeeper 获得高性能。

1390
01:18:49,400 --> 01:18:51,320
我们将在后面的课程中看到，

1391
01:18:51,380 --> 01:18:53,480
更多这种技巧，

1392
01:18:53,510 --> 01:18:57,050
试着减弱一致性保证，

1393
01:18:57,050 --> 01:19:01,010
为了获得更好的性能，

1394
01:19:01,010 --> 01:19:07,310
或者即使网络分区，也能够继续。

1395
01:19:09,810 --> 01:19:10,950
好的，让我停在这里，

1396
01:19:10,980 --> 01:19:15,130
然后我会继续一段时间，

1397
01:19:15,720 --> 01:19:17,430
下一次[]课程。

1398
01:19:19,280 --> 01:19:20,090
有什么问题吗？

1399
01:19:21,280 --> 01:19:22,960
像往常一样，

1400
01:19:22,960 --> 01:19:25,270
如果你一定要走，请随意，

1401
01:19:25,270 --> 01:19:27,370
如果你想留下来问更多的问题，

1402
01:19:27,370 --> 01:19:29,560
也请随意提问。

1403
01:19:41,940 --> 01:19:48,630
抱歉，你能看一下幻灯片，

1404
01:19:49,140 --> 01:19:54,370
test-and-set 的失败的例子，

1405
01:19:55,380 --> 01:19:57,660
我想是倒退两张幻灯片。

1406
01:19:57,750 --> 01:19:58,320
这一张?

1407
01:19:59,160 --> 01:20:03,280
是的，所以新的设计，

1408
01:20:03,960 --> 01:20:06,660
它能够修复那个写入。

1409
01:20:07,020 --> 01:20:10,980
是的，我的意思是 zookeeper 提供的 API 。

1410
01:20:14,700 --> 01:20:16,050
在[]版本写入。

1411
01:20:16,380 --> 01:20:18,750
是的，如果你必须这么做，

1412
01:20:19,110 --> 01:20:20,730
我没有这么做，

1413
01:20:20,730 --> 01:20:23,370
但这将在课程的其余部分讨论，

1414
01:20:23,370 --> 01:20:26,010
如何使用版本号实现 test-and-set 。

1415
01:20:27,100 --> 01:20:30,250
很明显，增量表明你可以，

1416
01:20:30,250 --> 01:20:31,900
因为这是相同的序列。

1417
01:20:33,940 --> 01:20:34,420
是的。

1418
01:20:35,830 --> 01:20:38,440
哦，这和 master 是一回事，好的。

1419
01:20:38,440 --> 01:20:40,240
是的，就是这样。

1420
01:20:41,060 --> 01:20:42,260
好的，非常感谢。

1421
01:20:42,260 --> 01:20:42,800
不客气。

1422
01:20:44,780 --> 01:20:49,760
我有一个关于防止锁的版本，

1423
01:20:50,000 --> 01:20:52,070
为了实现无锁编程，

1424
01:20:52,070 --> 01:20:55,340
这是不是像更高效的无锁编程，

1425
01:20:55,340 --> 01:20:57,590
因为你还需要读取，

1426
01:20:57,890 --> 01:20:59,630
反复尝试那个操作，

1427
01:20:59,630 --> 01:21:00,950
直到它成功写入。

1428
01:21:01,640 --> 01:21:05,630
是的，这个 test-and-set 有类似的属性，

1429
01:21:05,630 --> 01:21:06,830
如果 test-and-set 失败了，

1430
01:21:06,890 --> 01:21:08,810
你想增加，

1431
01:21:08,810 --> 01:21:09,740
你必须再做一次，

1432
01:21:09,770 --> 01:21:11,520
所以，通常是这种情况，

1433
01:21:11,520 --> 01:21:12,960
在这种无锁风格的编程中，

1434
01:21:12,960 --> 01:21:15,030
你有这些循环，用来重试。

1435
01:21:16,420 --> 01:21:17,920
所以，如果有很多[争论]，

1436
01:21:18,310 --> 01:21:19,630
你会有很多次重试，

1437
01:21:19,750 --> 01:21:21,730
因为没有争用，所以没有重试，

1438
01:21:22,210 --> 01:21:25,960
通常情况下，这些无锁算法都很小心，

1439
01:21:25,960 --> 01:21:27,250
在如何进行后退方面，

1440
01:21:27,610 --> 01:21:29,170
所以它们不会立即重试，

1441
01:21:29,170 --> 01:21:30,370
他们有后备计划。

1442
01:21:32,150 --> 01:21:36,440
好的，但这比标准锁有什么好处，

1443
01:21:36,530 --> 01:21:38,960
因为无论哪种方式，如果你有很多争论，

1444
01:21:38,960 --> 01:21:42,020
你会在那里并反复尝试。

1445
01:21:42,170 --> 01:21:43,160
是的，所以让我们，

1446
01:21:43,160 --> 01:21:44,570
是的，所以，

1447
01:21:44,660 --> 01:21:48,230
所以，增量计数器是一个例子，

1448
01:21:48,230 --> 01:21:52,400
隐式地执行锁，

1449
01:21:52,400 --> 01:21:56,430
因为如果我们在 zookeeper 中实现锁，

1450
01:21:56,430 --> 01:22:00,990
使用 zookeeper API 实现锁，

1451
01:22:01,170 --> 01:22:02,700
如果你用这个愚蠢的锁，

1452
01:22:02,730 --> 01:22:04,710
你也可能会有这个争执的问题，

1453
01:22:05,220 --> 01:22:07,830
当然，有可以实现更智能的锁的方法，

1454
01:22:07,830 --> 01:22:10,560
他们无伤大雅地谈论着，

1455
01:22:10,560 --> 01:22:12,240
然后你可以做得更好，

1456
01:22:12,830 --> 01:22:16,760
所以我希望下一次能谈到。

1457
01:22:18,690 --> 01:22:19,590
好的，谢谢。

1458
01:22:20,040 --> 01:22:22,110
我认为真正的问题是，

1459
01:22:22,110 --> 01:22:24,720
你可以使用这些原语来进行无锁编程，

1460
01:22:25,740 --> 01:22:29,250
而使用实验 3 提供的接口是不可能的。

1461
01:22:31,820 --> 01:22:32,960
理解了，谢谢。

1462
01:22:42,960 --> 01:22:43,980
还有什么问题吗？

