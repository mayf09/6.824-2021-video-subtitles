1
00:00:00,120 --> 00:00:00,840
好的，谢谢。

2
00:00:01,820 --> 00:00:03,350
好的，就是，

3
00:00:03,350 --> 00:00:05,720
下午好，早上好，傍晚好，晚上安，

4
00:00:05,720 --> 00:00:06,410
无论你在哪里，

5
00:00:06,530 --> 00:00:10,580
我想欢迎来到本学期的最后一周，

6
00:00:10,880 --> 00:00:12,650
所以还有两节课，

7
00:00:12,950 --> 00:00:15,440
今天我们将要讨论的是 Blockstack ，

8
00:00:15,980 --> 00:00:21,800
周四，我们收到一份来自不同项目的报告，

9
00:00:21,800 --> 00:00:24,800
来自多个 6.824 项目组。

10
00:00:25,590 --> 00:00:29,670
所以，今天是最后一次论文讨论。

11
00:00:30,950 --> 00:00:33,560
所以主题是，

12
00:00:33,560 --> 00:00:37,340
分配给我们的主题，

13
00:00:37,520 --> 00:00:39,020
分配给我们阅读的，是 Blockstack ，

14
00:00:39,940 --> 00:00:43,180
Blockstack 表示的是，

15
00:00:43,180 --> 00:00:50,210
一种构建去中心化应用程序的方式，

16
00:00:53,570 --> 00:00:56,840
对于去中心化，我们这里的意思是，

17
00:00:57,110 --> 00:01:00,680
与中心化的网站不同，这个网站拥有数据，

18
00:01:00,680 --> 00:01:03,080
而去中心化的应用，

19
00:01:03,080 --> 00:01:05,300
系统以一种方式设置，

20
00:01:05,300 --> 00:01:09,200
用户控制数据而不是网站。

21
00:01:09,750 --> 00:01:12,750
这是最后一个[趋势]，

22
00:01:12,750 --> 00:01:17,790
是关于去中心化化分布式系统的三节课的最后一课，

23
00:01:17,790 --> 00:01:22,260
我们谈到日志和日志签名，

24
00:01:22,260 --> 00:01:25,590
是构建这种去中心化的日志存储系统的一种方式，

25
00:01:25,650 --> 00:01:29,010
我们看到比特币，作为一个例子，

26
00:01:29,010 --> 00:01:33,360
如何在去中心化系统中达成一致，

27
00:01:33,360 --> 00:01:36,420
与不信任的参与者或拜占庭参与者。

28
00:01:36,750 --> 00:01:39,360
所以今天我们向前更进一步，

29
00:01:39,360 --> 00:01:42,810
解如何实际构建完整的应用程序，

30
00:01:42,870 --> 00:01:45,930
而不仅仅是加密货币应用。

31
00:01:47,010 --> 00:01:48,960
去中心化应用有很长的历史，

32
00:01:49,260 --> 00:01:53,250
在 2000 年早期， 90 年代末，

33
00:01:53,250 --> 00:01:56,550
有很多点对点应用程序，

34
00:01:57,090 --> 00:02:01,650
它有一个分散的架构， Napster ，

35
00:02:01,650 --> 00:02:05,400
最近，你可能对 Keybase 比较熟悉，

36
00:02:05,790 --> 00:02:07,980
它有一个去中心化的设计，

37
00:02:08,070 --> 00:02:09,900
或者 Solid(https://solidproject.org/) ，

38
00:02:10,020 --> 00:02:12,840
当然还有 Blockstack ，

39
00:02:13,110 --> 00:02:15,720
有相当多的活动，

40
00:02:15,720 --> 00:02:18,300
在这个去中心化应用程序的领域中。

41
00:02:19,200 --> 00:02:21,690
Blockstack 很有趣，

42
00:02:21,720 --> 00:02:24,930
从去中心化应用程序的角度来看，

43
00:02:25,230 --> 00:02:29,130
但也是一种非货币使用的例子，

44
00:02:29,160 --> 00:02:36,510
非货币使用比特币区块链。

45
00:02:44,990 --> 00:02:46,880
我们会看到，

46
00:02:46,880 --> 00:02:50,180
Blockstack 有很多有趣的方面，

47
00:02:50,180 --> 00:02:54,650
但这篇论文关注的关键是命名，

48
00:02:54,830 --> 00:02:59,630
如何在构建一个分布式去中心化命名系统。

49
00:03:00,080 --> 00:03:02,810
当然，命名系统也被广泛使用，

50
00:03:02,810 --> 00:03:04,280
想想 DNS ，

51
00:03:04,280 --> 00:03:07,880
想想 Kerberos ，

52
00:03:07,880 --> 00:03:11,060
有很多不同的命名系统，

53
00:03:11,060 --> 00:03:12,350
它们被广泛使用，

54
00:03:12,560 --> 00:03:13,940
这是一种不同的设计，

55
00:03:13,940 --> 00:03:17,090
其中最有趣的部分是，它是去中心化的。

56
00:03:22,180 --> 00:03:24,580
这节课有一点不同，

57
00:03:24,580 --> 00:03:27,700
与许多之前的课，

58
00:03:27,700 --> 00:03:29,770
前面的很多课都是，

59
00:03:29,770 --> 00:03:31,120
这是一个困难的技术问题，

60
00:03:31,210 --> 00:03:33,520
这是解决这个问题的解决方案，

61
00:03:34,000 --> 00:03:37,210
这里我们的情况略有不同，

62
00:03:37,390 --> 00:03:39,370
有一个困难的技术问题，

63
00:03:39,370 --> 00:03:41,320
我们必须构建去中心化的应用程序，

64
00:03:41,560 --> 00:03:44,470
但是不是，百分百清楚的是，

65
00:03:44,470 --> 00:03:47,260
正确构建去中心化应用，

66
00:03:47,260 --> 00:03:48,700
是非常[]，

67
00:03:49,210 --> 00:03:53,620
还不清楚 Blockstack 是否是正确的解决方案，

68
00:03:54,310 --> 00:03:56,680
它更具实验性，

69
00:03:56,740 --> 00:03:59,800
Blockstack 有一个用户社区，

70
00:03:59,800 --> 00:04:03,520
但这还不是压倒性的成功，

71
00:04:03,520 --> 00:04:06,520
并证明这是一条正确的道路。

72
00:04:06,550 --> 00:04:09,400
所以，从某种意义上说，

73
00:04:09,790 --> 00:04:13,420
这是一篇更发人深省的论文，

74
00:04:13,690 --> 00:04:18,010
而不是对一个特定的技术问题给出明确的答案。

75
00:04:18,130 --> 00:04:24,010
所以，这个更重要的主题是，

76
00:04:24,010 --> 00:04:30,010
让我们参与一场关于这种设计的不同观点的讨论。

77
00:04:30,490 --> 00:04:32,560
所以在讲课的时候，

78
00:04:32,560 --> 00:04:36,040
如果我们有，

79
00:04:36,040 --> 00:04:39,460
有相当多的讨论不同的方面，

80
00:04:39,460 --> 00:04:41,530
我认为不会有一个正确的答案。

81
00:04:43,120 --> 00:04:46,660
所以，任何时候你有问题，

82
00:04:46,660 --> 00:04:50,560
或者对这些去中心化应用设计的方面有什么看法，

83
00:04:50,560 --> 00:04:51,880
你可以说出来。

84
00:04:54,460 --> 00:05:00,190
好的，也许在讨论去中心化的应用程序之前，

85
00:05:00,190 --> 00:05:01,660
快速回顾一下，

86
00:05:01,780 --> 00:05:03,670
什么是常见范式，

87
00:05:03,670 --> 00:05:06,100
来构建网站或构建网络应用。

88
00:05:06,100 --> 00:05:09,620
这就是使用中心化网站，

89
00:05:13,170 --> 00:05:16,890
网站可能分布在世界各地的多个数据中心，

90
00:05:17,070 --> 00:05:20,160
但网站的设计架构是集中式的，

91
00:05:20,160 --> 00:05:24,240
我们有，这是典型的网站，

92
00:05:24,750 --> 00:05:27,090
它的代码中有一些应用，

93
00:05:27,090 --> 00:05:31,470
无论是 Gmail Twitter Facebook ，

94
00:05:31,770 --> 00:05:35,880
它在数据库上运行，

95
00:05:36,600 --> 00:05:39,180
其中包含用户数据。

96
00:05:42,890 --> 00:05:44,930
然后我们可能有不同的用户，

97
00:05:44,930 --> 00:05:51,710
使用网络浏览器进行交互， U1 U2 ，

98
00:05:52,040 --> 00:05:55,400
他们通过应用程序与网站进行交互，

99
00:05:55,400 --> 00:05:58,820
他们创建数据，他们存储在数据库中，

100
00:05:59,060 --> 00:06:01,340
其他用户可以查看数据，

101
00:06:01,400 --> 00:06:06,290
应用程序将这些数据显示在网络浏览器中。

102
00:06:06,940 --> 00:06:18,900
数据可能是博客帖子，推文， Piazza 帖子，照片，

103
00:06:20,700 --> 00:06:27,620
也许甚至更敏感的，医疗记录，等等。

104
00:06:29,910 --> 00:06:32,280
我们在网站上运行的应用程序，

105
00:06:32,280 --> 00:06:35,280
转换来自所有不同用户的数据，

106
00:06:35,400 --> 00:06:37,740
变成一些有趣的东西，

107
00:06:37,740 --> 00:06:41,910
比如其中集成了许多用户的时间线，

108
00:06:41,910 --> 00:06:45,090
进入一个时间线并展示给用户，

109
00:06:45,090 --> 00:06:46,440
我们要发表推文，

110
00:06:46,440 --> 00:06:49,200
上传和下载，等等。

111
00:06:50,070 --> 00:06:56,250
这个设计的一个显著特点是，

112
00:06:56,430 --> 00:06:58,410
数据的应用被捆绑在一起，

113
00:06:58,410 --> 00:07:01,440
它们只是由应用程序网站所控制，

114
00:07:01,440 --> 00:07:04,620
无论是 Facebook Twitter Google 还是任何网站，

115
00:07:04,620 --> 00:07:06,780
用户之间的界面，

116
00:07:06,780 --> 00:07:11,210
或者用户和网站之间的分界线，

117
00:07:11,210 --> 00:07:13,700
是 HTML 或 UI ，

118
00:07:17,580 --> 00:07:21,210
应用程序计算出用户将要看到的内容，

119
00:07:21,210 --> 00:07:23,130
它将通过浏览器显示，

120
00:07:23,520 --> 00:07:26,400
当然，应用程序可能在浏览器内部运行，

121
00:07:26,490 --> 00:07:27,900
比如 Javascript ，

122
00:07:27,900 --> 00:07:30,960
但与这个讨论并不相关，

123
00:07:31,230 --> 00:07:35,040
仍然是应用程序在网站的控制之下，

124
00:07:35,040 --> 00:07:37,560
网站的程序员编写应用程序，

125
00:07:37,830 --> 00:07:40,650
应用程序操作 DOM ，

126
00:07:40,680 --> 00:07:42,540
填充到浏览器中。

127
00:07:43,270 --> 00:07:44,800
所以从用户的角度来看，

128
00:07:45,040 --> 00:07:48,160
交互，界面，

129
00:07:48,160 --> 00:07:54,940
网站和浏览器之间的界面仍然是 HTML 。

130
00:07:57,720 --> 00:08:01,560
所以这种设计显然是压倒性的成功，

131
00:08:01,800 --> 00:08:04,830
可能大多数网站，

132
00:08:04,830 --> 00:08:07,140
可能你使用的所有网站

133
00:08:07,140 --> 00:08:09,780
都遵循这种设计。

134
00:08:10,570 --> 00:08:14,560
这个非常成功的设计的一个原因是，

135
00:08:14,560 --> 00:08:15,790
我们稍后会讨论，

136
00:08:15,910 --> 00:08:18,880
因为应用和数据紧密结合，

137
00:08:18,880 --> 00:08:20,290
来自用户的数据，

138
00:08:20,290 --> 00:08:24,610
应用程序可以轻松访问来自不同用户的所有用户数据，

139
00:08:24,610 --> 00:08:26,860
把它融合在一起，创造出创造性和趣味性的方式。

140
00:08:27,490 --> 00:08:32,410
但这种设计并不是完美的，

141
00:08:32,410 --> 00:08:36,850
你可能会希望能做得更好。

142
00:08:37,650 --> 00:08:38,940
在某种意义上，

143
00:08:38,940 --> 00:08:42,480
去中心化应用是对这些事情的一种回应，

144
00:08:42,480 --> 00:08:45,060
它可能不是百分百想要的。

145
00:08:45,860 --> 00:08:49,250
所以，首先，有一个非常简单的观察，

146
00:08:49,250 --> 00:08:51,620
你不能创建另一个应用程序，

147
00:08:51,950 --> 00:08:55,340
网站决定了应用程序的外观，

148
00:08:55,340 --> 00:08:57,140
就是你会得到的用户界面，

149
00:08:57,560 --> 00:09:01,610
这很不同，

150
00:09:01,700 --> 00:09:05,930
比如，你自己笔记本的自己的应用，

151
00:09:05,930 --> 00:09:08,450
你想修改，编辑一个文本文件，

152
00:09:08,600 --> 00:09:11,270
你可以选择要使用的浏览器或编辑器，

153
00:09:11,270 --> 00:09:13,700
你可以使用 Emacs Vim ，

154
00:09:13,700 --> 00:09:15,380
各种各样的文化战争，

155
00:09:15,380 --> 00:09:16,790
关于哪一个比另一个更好，

156
00:09:16,970 --> 00:09:20,120
但你有权选择你想要使用哪个。

157
00:09:20,450 --> 00:09:22,250
在这种情况下，情况并非如此，

158
00:09:22,250 --> 00:09:24,110
你使用 Gmail ，

159
00:09:25,730 --> 00:09:26,990
Gmail 不是最好的例子，

160
00:09:26,990 --> 00:09:27,530
但是 Twitter ，

161
00:09:27,530 --> 00:09:30,110
Twitter 会决定应用程序的外观，

162
00:09:31,420 --> 00:09:33,220
Gmail 可能不是最好的例子的原因是，

163
00:09:33,220 --> 00:09:36,220
因为你可以通过 IMAP 下载你的电子邮件，

164
00:09:36,220 --> 00:09:39,040
然后运行自己的电子邮件程序，

165
00:09:39,340 --> 00:09:40,630
但对于许多网站来说，

166
00:09:40,630 --> 00:09:43,000
用户应用程序数据非常受控制，

167
00:09:43,000 --> 00:09:44,410
你无法控制它。

168
00:09:47,040 --> 00:09:52,290
网站可能会修改谁可以查看哪些数据的规则，

169
00:09:52,470 --> 00:09:54,870
它可能并没有告诉你，

170
00:09:54,960 --> 00:09:59,250
所以你没有完全控制谁能看到你的数据，

171
00:09:59,460 --> 00:10:04,500
另外，网站可能会使用你的数据产生收入，

172
00:10:04,500 --> 00:10:07,620
无论是显示哪些广告，

173
00:10:07,620 --> 00:10:11,220
并且窥探你的数据，

174
00:10:11,760 --> 00:10:14,430
或者在更糟糕的情况下，可能一个糟糕的员工，

175
00:10:14,430 --> 00:10:16,620
它窥探你的数据。

176
00:10:17,300 --> 00:10:19,130
这在某种程度上是你无法控制的，

177
00:10:19,130 --> 00:10:20,750
你真的无能为力，

178
00:10:20,750 --> 00:10:23,090
你把数据给了网站，现在是他们的了。

179
00:10:24,230 --> 00:10:29,840
所以这是一个痛点，

180
00:10:29,840 --> 00:10:31,280
这会让人想知道，

181
00:10:31,280 --> 00:10:34,310
是否有一种设计系统的方式，

182
00:10:34,520 --> 00:10:37,970
它不遵循这种模式，

183
00:10:37,970 --> 00:10:40,640
而是遵循去中心化应用程序的模式。

184
00:10:55,970 --> 00:10:59,420
所以在这个世界中，

185
00:10:59,630 --> 00:11:02,060
我们仍然在互联网中，

186
00:11:02,090 --> 00:11:04,520
但我们有存储提供商，

187
00:11:05,850 --> 00:11:12,540
存储提供商不是什么真正复杂的词，

188
00:11:12,840 --> 00:11:14,400
它们并不运行应用程序代码，

189
00:11:14,640 --> 00:11:16,710
它们只是纯粹地提供存储，

190
00:11:16,800 --> 00:11:22,740
比如 Google Drive 或 Amazon S3 等，

191
00:11:22,860 --> 00:11:26,760
但它们都是大的持有者，

192
00:11:27,730 --> 00:11:31,000
可能用户想要加密数据，

193
00:11:31,120 --> 00:11:33,430
但这才是我们的真正目标，

194
00:11:33,430 --> 00:11:36,820
用户决定数据所在的存储位置，

195
00:11:37,120 --> 00:11:38,770
并且使它们处于用户的控制之下，

196
00:11:39,360 --> 00:11:41,070
所以不管什么存储提供商，

197
00:11:41,310 --> 00:11:43,590
S3 可能会有用户 1 的数据，

198
00:11:46,970 --> 00:11:49,460
另一个供应商可能有 U2 的数据，

199
00:11:49,460 --> 00:11:52,820
或者保存 U2 的数据，

200
00:11:53,090 --> 00:11:55,700
U2 可能对它进行加密，

201
00:11:55,700 --> 00:11:57,860
使存储提供商不能读取它，

202
00:12:00,170 --> 00:12:03,200
并控制着谁可以对数据进行解密。

203
00:12:03,680 --> 00:12:10,250
然后应用程序是在用户自己的控制之下，

204
00:12:10,520 --> 00:12:12,530
所以这里的用户，

205
00:12:13,070 --> 00:12:17,300
U1 工作站或笔记本，它运行一个应用程序，

206
00:12:18,600 --> 00:12:21,630
这是 U2 ，

207
00:12:22,640 --> 00:12:25,880
也有另一个应用程序可能查看相同的数据，

208
00:12:25,880 --> 00:12:28,070
但是一个稍有不同版本的应用程序，

209
00:12:28,070 --> 00:12:31,160
比如一个照片查看器和另一个照片查看器，

210
00:12:32,080 --> 00:12:36,940
为了构建显示给用户的是什么，

211
00:12:37,090 --> 00:12:41,470
应用程序将从不同的用户那里获取数据，

212
00:12:41,470 --> 00:12:45,910
例如， U2 与 U1 共享照片，

213
00:12:46,120 --> 00:12:50,860
然后应用程序整合 U1 U2 的照片，

214
00:12:50,980 --> 00:12:58,030
通过从不同存储提供商获取照片。

215
00:12:58,660 --> 00:13:02,290
在这里，分界线在用户之间，

216
00:13:02,620 --> 00:13:08,170
分界线是这样的，

217
00:13:09,830 --> 00:13:12,410
在应用程序和存储之间有一条分界线，

218
00:13:12,410 --> 00:13:14,630
所以有一个存储 API ，

219
00:13:15,770 --> 00:13:17,660
你有统一的，

220
00:13:17,660 --> 00:13:21,140
因为许多不同的应用程序使用相同的存储[]，

221
00:13:21,140 --> 00:13:23,630
也许这个应用程序创建 todo 列表，

222
00:13:24,020 --> 00:13:25,760
可能是一个照片列表，

223
00:13:25,760 --> 00:13:28,280
也许这是 Twitter 的克隆，

224
00:13:28,280 --> 00:13:30,470
检索来自不同用户的推文，

225
00:13:30,470 --> 00:13:33,020
并将它们整合在一起呈现给用户。

226
00:13:33,580 --> 00:13:38,830
它是一种单一存储 API ，

227
00:13:38,830 --> 00:13:42,460
这提供了分界线，

228
00:13:42,460 --> 00:13:45,820
在应用程序和数据之间，

229
00:13:46,550 --> 00:13:48,710
当然，存储 API 必须是非常通用的，

230
00:13:48,710 --> 00:13:50,180
可以支持多个应用程序，

231
00:13:50,210 --> 00:13:51,920
而且还必须允许共享，

232
00:13:51,920 --> 00:13:55,490
在不同用户和不同应用之间，

233
00:13:55,610 --> 00:13:57,260
模块或权限。

234
00:13:59,210 --> 00:14:06,380
假设你想要建立一个 todo 列表，

235
00:14:12,560 --> 00:14:15,260
在 U1 和 U2 之间，

236
00:14:15,260 --> 00:14:19,010
我们从 U1 的角度来看，

237
00:14:19,250 --> 00:14:21,350
可能会有一些操作

238
00:14:21,440 --> 00:14:24,290
或在 U2 U1 一些共享操作，

239
00:14:24,290 --> 00:14:28,340
比如我的 todo list 的名字，

240
00:14:28,640 --> 00:14:34,730
U1 可以下载 U2 的 todo 列表，

241
00:14:35,030 --> 00:14:38,690
也许会检查文件上的签名，

242
00:14:38,690 --> 00:14:41,810
来验证数据数据是 U2 写的，

243
00:14:42,230 --> 00:14:44,390
然后整合它，

244
00:14:44,420 --> 00:14:47,060
我们有自己的 todo 列表，

245
00:14:47,060 --> 00:14:50,270
展示 U1 或共享 todo 列表，

246
00:14:50,270 --> 00:14:53,630
包含 U1 和 U2 的 todo 列表。

247
00:14:56,420 --> 00:14:59,780
这是一般的角度，

248
00:14:59,780 --> 00:15:04,970
用来构建去中心化架构的应用程序。

249
00:15:07,010 --> 00:15:08,120
到目前为止，有什么问题吗？

250
00:15:21,330 --> 00:15:23,460
好的，到目前为止，

251
00:15:23,460 --> 00:15:24,750
我们希望已经收到了，

252
00:15:24,750 --> 00:15:30,540
这个集中化方法的主要痛点之一，

253
00:15:30,570 --> 00:15:33,750
用户仍然控制着数据，

254
00:15:33,750 --> 00:15:36,060
它不再属于某个特定的站点，

255
00:15:36,060 --> 00:15:38,520
用户决定谁，

256
00:15:38,520 --> 00:15:41,370
哪些应用程序和谁获得数据访问权限。

257
00:15:42,120 --> 00:15:45,720
我想这是想要的属性。

258
00:15:46,330 --> 00:15:50,860
但是，整个设计也面临着一系列独特的挑战，

259
00:15:50,980 --> 00:15:52,930
所以让我把它们中的一些列出来，

260
00:15:53,170 --> 00:15:56,260
我们将在 Blockstack 的上下文中重点介绍其中的几个。

261
00:16:01,010 --> 00:16:04,520
所以有两大类的挑战，

262
00:16:04,730 --> 00:16:06,770
一个是商业方面的，

263
00:16:07,190 --> 00:16:08,510
盈利模式是什么，

264
00:16:10,700 --> 00:16:15,260
有人会让这些应用程序被采用，

265
00:16:15,260 --> 00:16:18,440
付钱让人们开发应用程序，

266
00:16:18,710 --> 00:16:22,400
所以它们变得非常好，

267
00:16:22,400 --> 00:16:26,720
人们很乐意去使用它们。

268
00:16:27,320 --> 00:16:30,590
我不想谈这个，

269
00:16:31,280 --> 00:16:34,400
相反，我最关注的是技术挑战。

270
00:16:43,460 --> 00:16:45,590
这里有几个（技术挑战），

271
00:16:46,160 --> 00:16:50,690
我们先回来看看这张图片，

272
00:16:50,840 --> 00:16:55,160
存储 API 是关键接口，

273
00:16:55,160 --> 00:16:57,830
而且接口是最小的，

274
00:16:57,830 --> 00:17:00,290
而且它必须是足够通用的，

275
00:17:00,560 --> 00:17:02,750
但在通常情况下，它是，

276
00:17:02,750 --> 00:17:06,380
它与这里的 API 不是一回事，

277
00:17:08,310 --> 00:17:10,560
在应用程序和数据库之间。

278
00:17:11,000 --> 00:17:13,520
所以让我们这样做，稍等一下。

279
00:17:41,280 --> 00:17:44,250
好的，希望每个人都能再次看到白板的屏幕？

280
00:17:44,400 --> 00:17:44,850
好的。

281
00:17:48,000 --> 00:17:50,730
所以，有几个挑战，

282
00:17:50,730 --> 00:17:52,260
我要指出的是，

283
00:17:52,260 --> 00:17:55,710
存储 API 通常不那么强大，

284
00:17:55,890 --> 00:18:00,180
文件系统 API 不如 SQL 强大，

285
00:18:01,740 --> 00:18:06,420
此外，并不是所有的数据，

286
00:18:06,420 --> 00:18:09,330
都放在一个地方，

287
00:18:09,330 --> 00:18:11,790
你可以运行任意查询，

288
00:18:11,910 --> 00:18:15,090
以任何应用程序的方式集成它。

289
00:18:15,840 --> 00:18:18,030
所以这是一种挑战，

290
00:18:18,030 --> 00:18:21,090
应用程序依赖于这种能力，

291
00:18:21,300 --> 00:18:24,480
能够对所有用户数据任意查询，

292
00:18:24,480 --> 00:18:26,790
这在去中心化应用中更难实现，

293
00:18:26,790 --> 00:18:30,780
因为数据可能分散在很多不同的存储服务器上。

294
00:18:31,780 --> 00:18:34,270
还有一些功能可能更难实现，

295
00:18:34,600 --> 00:18:39,160
例如，如果你想实现 eBay ，

296
00:18:39,190 --> 00:18:45,190
然后要提交某种出价，

297
00:18:45,190 --> 00:18:47,680
我们想马上下载那些出价，

298
00:18:47,950 --> 00:18:50,890
所以必须要有某些可信的方面，

299
00:18:50,890 --> 00:18:52,540
来整合了这些出价，

300
00:18:52,540 --> 00:18:54,520
然后决定谁是赢家，

301
00:18:55,160 --> 00:18:58,880
而不会事先透露这些信息。

302
00:18:59,030 --> 00:19:03,740
同样，管理方面也存在挑战，

303
00:19:03,890 --> 00:19:09,290
通常，这些去中心化应用涉及加密密钥，

304
00:19:11,230 --> 00:19:15,850
所以，这通常是一种[]情景，

305
00:19:16,120 --> 00:19:17,800
一些用户丢失了他们的私钥，

306
00:19:17,800 --> 00:19:21,550
然后你不能再得到你的数据了，

307
00:19:21,970 --> 00:19:24,970
或者有人偷了你的私钥，

308
00:19:24,970 --> 00:19:27,040
然后他们就可以获取你的数据。

309
00:19:27,940 --> 00:19:31,480
所以有一系列的技术挑战，

310
00:19:31,480 --> 00:19:33,670
要让这件事真正工作，

311
00:19:33,910 --> 00:19:36,340
其中一个，剩下的一个，

312
00:19:36,340 --> 00:19:39,010
也是这节课的主题，就是命名。

313
00:19:42,740 --> 00:19:46,070
所以，更广泛的挑战是，

314
00:19:46,070 --> 00:19:50,240
我想是对任何类型的去中心化应用基础架构的挑战，

315
00:19:50,450 --> 00:19:53,900
当然在 Blockstack 的上下文中也是如此，

316
00:19:54,200 --> 00:19:55,700
但是在 Blockstack 情况下，

317
00:19:55,730 --> 00:19:59,120
我们会看到名字的重要性，

318
00:19:59,270 --> 00:20:02,330
以及为什么命名是一个挑战。

319
00:20:03,380 --> 00:20:05,030
好的，在继续之前，

320
00:20:05,030 --> 00:20:06,770
我只想在这里停一下，

321
00:20:06,770 --> 00:20:09,050
只是给那些想问任何问题的人，

322
00:20:09,050 --> 00:20:14,300
对比这两种不同的构建应用程序的方式，

323
00:20:14,300 --> 00:20:17,120
无论是像传统模式那样的集中化，

324
00:20:17,120 --> 00:20:18,530
我们可能都很熟悉，

325
00:20:18,950 --> 00:20:21,860
或者这种去中心化的模式。

326
00:20:22,890 --> 00:20:25,380
所以，出价有什么挑战？

327
00:20:26,600 --> 00:20:27,620
挑战是什么呢？

328
00:20:28,230 --> 00:20:29,100
通过出价。

329
00:20:30,200 --> 00:20:33,920
哦，你需要一个，

330
00:20:33,920 --> 00:20:36,290
应用程序需要能够访问用户出价，

331
00:20:36,530 --> 00:20:39,470
但不应该将它们透露给其他应用程序，

332
00:20:39,500 --> 00:20:41,150
这就意味着，

333
00:20:41,540 --> 00:20:44,540
应用程序看起来是，

334
00:20:44,540 --> 00:20:46,730
我是 U1 ，我提交了出价，

335
00:20:47,000 --> 00:20:48,830
我得到了 U2 的出价，

336
00:20:48,920 --> 00:20:51,920
但我的应用将 U2 的出价直接给我，

337
00:20:51,920 --> 00:20:53,240
因为这不公平，

338
00:20:53,790 --> 00:20:55,530
那么你将如何做到这一点，

339
00:20:55,530 --> 00:20:59,310
所以你需要受信任的一方或任何协议，

340
00:20:59,310 --> 00:21:00,300
让这一切发生。

341
00:21:03,700 --> 00:21:04,210
谢谢。

342
00:21:06,840 --> 00:21:08,940
如果应用程序模型在你的工作站上运行，

343
00:21:08,940 --> 00:21:10,920
你可以修改应用程序，对吧。

344
00:21:14,080 --> 00:21:17,830
抱歉，在上一张幻灯片中，我想你也提到了，

345
00:21:18,490 --> 00:21:20,290
应用 1 不同于，

346
00:21:20,320 --> 00:21:23,680
两个应用是不同的，

347
00:21:24,150 --> 00:21:25,770
你是什么意思？

348
00:21:25,920 --> 00:21:28,590
好的，举个例子，为了让比喻非常简单，

349
00:21:28,590 --> 00:21:31,510
这可能是 Vim ，这可能是 Emacs ，

350
00:21:31,900 --> 00:21:33,820
U1 和 U2 可以决定，

351
00:21:33,820 --> 00:21:37,570
使用哪个应用来修改它们的数据，

352
00:21:38,350 --> 00:21:41,380
今天在一个集中化的模式中，

353
00:21:41,440 --> 00:21:42,880
这是不可能的，

354
00:21:42,910 --> 00:21:45,520
你不可能有两个 Twitter 应用程序，

355
00:21:45,520 --> 00:21:47,800
U1 与 Twitter 应用程序交互的一种方式，

356
00:21:47,800 --> 00:21:49,570
其他人用不同的方式来做，

357
00:21:50,970 --> 00:21:52,290
这就是 Twitter 应用程序。

358
00:21:53,230 --> 00:21:54,310
我明白了，谢谢。

359
00:21:54,960 --> 00:22:00,810
我有一个问题，关于去中心化模型的设计，

360
00:22:00,900 --> 00:22:04,590
这个应用程序是否需要一个客户端，

361
00:22:04,590 --> 00:22:05,580
或者能不能，

362
00:22:05,640 --> 00:22:11,220
能不能有集中式应用在互联网上的标志。

363
00:22:11,340 --> 00:22:13,290
原则上，你可以在互联网上，

364
00:22:13,290 --> 00:22:14,610
关键的问题，

365
00:22:14,610 --> 00:22:16,950
它不一定要在用户的工作站上运行，

366
00:22:17,670 --> 00:22:18,480
可以在任何地方运行，

367
00:22:18,540 --> 00:22:20,100
但是在用户的控制中，

368
00:22:21,170 --> 00:22:22,400
当然，如果编写它，

369
00:22:22,550 --> 00:22:25,940
但用户可以决定运行哪个应用来处理哪些数据。

370
00:22:26,830 --> 00:22:30,700
好的，所以这里最重要的是，

371
00:22:30,940 --> 00:22:34,150
应用选择你，你应该选择应用，

372
00:22:34,150 --> 00:22:37,780
重要的是，应用程序可以访问任何存储提供商。

373
00:22:40,100 --> 00:22:40,610
谢谢。

374
00:22:46,130 --> 00:22:47,450
好的，还有其他问题吗？

375
00:22:52,240 --> 00:22:54,280
好的，那么名字，

376
00:22:54,810 --> 00:22:57,540
这会更深入了解 Blockstack 。

377
00:23:08,070 --> 00:23:12,630
让我来列出命名扮演的角色，

378
00:23:12,900 --> 00:23:14,760
首先，你有 todo 列表，

379
00:23:14,760 --> 00:23:16,290
你想和别人分享它，

380
00:23:16,290 --> 00:23:18,780
你必须能够命名要与其共享的用户，

381
00:23:19,650 --> 00:23:22,170
所以有一个从名字到用户的映射，

382
00:23:24,040 --> 00:23:25,210
这是一个重要的角色，

383
00:23:25,900 --> 00:23:29,710
存在从名字到数据位置的映射。

384
00:23:35,990 --> 00:23:37,490
所以如果我的 todo 列表应用，

385
00:23:37,490 --> 00:23:42,350
用户 1 和用户 2 分享 todo 列表，

386
00:23:42,350 --> 00:23:48,110
然后，用户 1 想要用户 2 的数据，

387
00:23:48,320 --> 00:23:52,730
需要有一种命名用户 2 的 todo 列表，

388
00:23:52,970 --> 00:23:54,110
并且获取它。

389
00:23:55,000 --> 00:23:56,530
然后有一种方法，

390
00:23:56,530 --> 00:24:01,570
有一个名字到公钥的映射，

391
00:24:01,990 --> 00:24:06,820
当我成功获取用户 2 的数据，

392
00:24:07,000 --> 00:24:10,690
可能想要验证它，是由用户 2 编写的，

393
00:24:10,930 --> 00:24:16,390
因此可能使用用户 2 的公钥来验证获取的数据的完整性，

394
00:24:16,420 --> 00:24:20,170
因为存储提供商可能不是可信任的，

395
00:24:20,620 --> 00:24:22,600
这就要求，

396
00:24:22,600 --> 00:24:27,820
我能够以可靠的方式确定用户 2 的公钥。

397
00:24:29,380 --> 00:24:32,770
所以，你应该考虑到，

398
00:24:32,770 --> 00:24:36,430
在这些去中心化的应用程序的每一步中，

399
00:24:36,550 --> 00:24:38,860
名字起着至关重要的作用。

400
00:24:39,710 --> 00:24:42,440
通用的名称给出

401
00:24:42,440 --> 00:24:46,460
从名称到密钥的映射，

402
00:24:46,460 --> 00:24:48,080
至关重要的密钥，

403
00:24:48,320 --> 00:24:51,080
称为公钥基础设施。

404
00:25:02,250 --> 00:25:07,910
构建任何公钥基础设施都是相当具有挑战性的，

405
00:25:08,090 --> 00:25:11,060
你可能对 DNSSec 很熟悉，

406
00:25:11,090 --> 00:25:14,660
在万维网上有一种特殊的方式，

407
00:25:14,870 --> 00:25:17,630
证书具有完整的公钥基础设施，

408
00:25:17,750 --> 00:25:22,400
Kerberos 是公钥基础设施的一个示例，

409
00:25:22,760 --> 00:25:23,930
在某些方面，这个论文，

410
00:25:23,930 --> 00:25:26,000
这篇论文所做的是，

411
00:25:26,000 --> 00:25:28,400
你将获得另一个公共基础设施，

412
00:25:28,430 --> 00:25:30,500
这是完全去中心化的。

413
00:25:36,490 --> 00:25:41,860
这是一个关键的方面，

414
00:25:41,860 --> 00:25:47,020
Blockstack 中命名方案有趣的地方，

415
00:25:47,050 --> 00:25:49,780
这提供了去中心化的公钥基础设施。

416
00:25:51,060 --> 00:25:54,300
让我试着解释一下，为什么这是具有挑战性的，

417
00:25:55,690 --> 00:26:01,760
论文在几个地方提到了这一点，

418
00:26:02,000 --> 00:26:04,700
有三个方面是你想要的，

419
00:26:04,760 --> 00:26:08,300
如果你想要一个一般目的的命名基础设施，

420
00:26:08,570 --> 00:26:10,610
你想要有唯一的名字，

421
00:26:11,470 --> 00:26:14,800
每个用户都有一个唯一的名字，

422
00:26:17,700 --> 00:26:18,960
这样你就可以识别

423
00:26:18,960 --> 00:26:23,850
你所说的那个 John 或那个 Joe 。

424
00:26:24,960 --> 00:26:29,520
人类可读的名字，

425
00:26:32,970 --> 00:26:34,350
所以可以很容易记住。

426
00:26:34,620 --> 00:26:37,170
在这种情况下，

427
00:26:37,470 --> 00:26:42,060
Blockstack 也想要的是去中心化。

428
00:26:46,840 --> 00:26:49,630
这篇论文的观点是，

429
00:26:49,630 --> 00:26:52,390
很容易能得到三个中的两个，

430
00:26:52,390 --> 00:26:55,120
但是很难得到全部三个，

431
00:26:55,120 --> 00:26:56,110
也许，

432
00:26:56,140 --> 00:26:57,760
让我们来看看几个命名系统，

433
00:26:57,760 --> 00:27:00,070
看看他们得到了哪两个。

434
00:27:00,310 --> 00:27:02,200
让我们来考虑一下电子邮件地址。

435
00:27:13,120 --> 00:27:17,240
好的，电子邮件地址，它们是唯一的名字吗？

436
00:27:22,140 --> 00:27:22,770
是的。

437
00:27:23,130 --> 00:27:24,540
它们是人类可读的吗？

438
00:27:25,350 --> 00:27:25,680
是的。

439
00:27:25,680 --> 00:27:27,720
它们是去中心化的吗？

440
00:27:28,140 --> 00:27:28,770
不是。

441
00:27:28,980 --> 00:27:31,470
不，所以这个得到这两个，

442
00:27:31,470 --> 00:27:32,400
但没有第三个。

443
00:27:33,260 --> 00:27:36,350
随机公钥怎么样，

444
00:27:36,560 --> 00:27:40,280
或者论文使用文件内容的哈希值，

445
00:27:40,280 --> 00:27:43,190
来获取[]的名字，

446
00:27:43,190 --> 00:27:46,640
所以，随机的公钥，

447
00:27:48,060 --> 00:27:50,130
意味着公钥是随机的，

448
00:27:55,180 --> 00:27:57,160
那么公钥，它们是唯一的吗？

449
00:27:59,290 --> 00:27:59,950
是的。

450
00:28:00,010 --> 00:28:00,760
是的。

451
00:28:00,790 --> 00:28:02,980
是的，它们是人类可读的吗？

452
00:28:03,280 --> 00:28:03,910
不是。

453
00:28:03,940 --> 00:28:05,620
不，它们是去中心化的吗？

454
00:28:05,980 --> 00:28:06,610
是的。

455
00:28:06,640 --> 00:28:09,070
是的，你可以生成它们，

456
00:28:09,070 --> 00:28:12,040
以一种独特的、完全去中心化的方式。

457
00:28:13,860 --> 00:28:18,390
事实上，你在实验 3 中用这个生成 clerk id ，

458
00:28:18,420 --> 00:28:21,390
所以我们得到了三个中的两个，

459
00:28:21,420 --> 00:28:22,710
但没有人类可读的那个。

460
00:28:23,010 --> 00:28:26,370
让我们来看看，我们能获得人类可读和去中心化吗？

461
00:28:27,920 --> 00:28:29,180
你能想出一个例子吗？

462
00:28:34,800 --> 00:28:37,740
这是不是比如点对点文件共享？

463
00:28:39,360 --> 00:28:40,890
嗯。

464
00:28:40,890 --> 00:28:42,510
这些文件不是唯一的，

465
00:28:42,540 --> 00:28:44,670
但它们是人类可读的，而且是去中心化的。

466
00:28:44,880 --> 00:28:46,020
是的，想得简单一点，

467
00:28:46,170 --> 00:28:48,750
想想你的手机，

468
00:28:54,170 --> 00:28:55,940
对我来说，这个例子是很好的，

469
00:28:55,940 --> 00:28:57,260
看看你的联系人列表，

470
00:29:02,370 --> 00:29:06,030
你的联系人的名字是人类可读的，

471
00:29:06,030 --> 00:29:08,970
你可以有 John ，

472
00:29:09,000 --> 00:29:11,760
John 的条目有一个手机号，

473
00:29:11,760 --> 00:29:15,240
我可以在我的 John 条目有另一个手机号码，

474
00:29:15,540 --> 00:29:16,920
他们可能是不同的人，

475
00:29:17,100 --> 00:29:21,060
但我可以以去中心化的的方式选择名字，

476
00:29:21,640 --> 00:29:23,200
而且它们当然是可读的，

477
00:29:23,200 --> 00:29:23,920
它们是唯一的吗？

478
00:29:27,340 --> 00:29:28,270
不是，

479
00:29:28,600 --> 00:29:31,480
你有你的名字列表，

480
00:29:31,480 --> 00:29:32,500
我有我的名字列表，

481
00:29:32,500 --> 00:29:33,790
它们可能会重叠，

482
00:29:33,790 --> 00:29:35,230
仍然谈论不同的人。

483
00:29:36,600 --> 00:29:39,300
所以这是论文试图得到的东西，

484
00:29:39,570 --> 00:29:41,010
实际上是三个中的两个，

485
00:29:41,220 --> 00:29:44,760
这很常见，或者很容易，

486
00:29:44,820 --> 00:29:47,430
但是获取所有三个，很难做到。

487
00:29:49,010 --> 00:29:53,810
在论文中，它就像，

488
00:29:53,810 --> 00:29:56,420
我们实现了这三个目标，

489
00:29:56,750 --> 00:30:00,020
我们得到唯一的名称，用户可读的和去中心化的。

490
00:30:01,670 --> 00:30:04,970
他们得到这个的方法是，

491
00:30:05,030 --> 00:30:09,350
利用区块链。

492
00:30:15,100 --> 00:30:16,510
所以 Blockstack 方法，

493
00:30:27,450 --> 00:30:30,450
而且[]他们是公平的，

494
00:30:30,480 --> 00:30:33,660
这实际上不叫 Blockstack 方式，

495
00:30:33,660 --> 00:30:38,850
他们采用的是 namecoins 方法。

496
00:30:39,730 --> 00:30:41,800
基本的想法很简单，

497
00:30:41,830 --> 00:30:43,810
我们将利用这个优势，

498
00:30:43,810 --> 00:30:49,450
比特币区块区块链的存在，

499
00:30:49,450 --> 00:30:51,490
当然，你也可以使用任何其他的区块链，

500
00:30:51,490 --> 00:30:52,990
但只是为了具体，

501
00:30:53,260 --> 00:30:55,600
我们考虑比特币的。

502
00:30:56,080 --> 00:30:58,120
所以这里有我们的链，

503
00:30:59,710 --> 00:31:02,770
在比特币中的交易，

504
00:31:03,890 --> 00:31:06,800
随着时间的推移，

505
00:31:06,860 --> 00:31:08,930
矿工增加了新的交易，

506
00:31:09,260 --> 00:31:12,800
我们要创建命名系统的方法是，

507
00:31:12,800 --> 00:31:17,150
我们将发布不同类型的交易，

508
00:31:17,150 --> 00:31:18,830
他们都自称一个名字。

509
00:31:19,350 --> 00:31:24,240
例如，我们可能有特殊的交易，

510
00:31:24,760 --> 00:31:29,740
因为比特币中的每一笔交易都有一个元数据字段，

511
00:31:29,740 --> 00:31:32,380
你可以将任何内容放入到元数据字段中，

512
00:31:32,680 --> 00:31:36,130
所以我们要放入的是一个名字记录。

513
00:31:36,650 --> 00:31:37,910
所以我们要做一些交易，

514
00:31:37,910 --> 00:31:39,770
然后我们在那里记下名字记录，

515
00:31:41,510 --> 00:31:42,950
你稍后会看到，

516
00:31:42,950 --> 00:31:44,960
但是这个名字记录的细节是，

517
00:31:45,230 --> 00:31:46,790
但在 Blockstack 的情况下，

518
00:31:46,790 --> 00:31:50,780
它基本上是一个像 6.824 这样的名字，

519
00:31:51,900 --> 00:31:54,120
然后，也许正如我们稍后看到的，

520
00:31:54,120 --> 00:31:55,380
一个区域文件的哈希值。

521
00:31:56,190 --> 00:32:00,870
在这个方案中的基本规则是，

522
00:32:01,260 --> 00:32:14,550
第一个用户，第一个名字记录会赢，

523
00:32:14,550 --> 00:32:15,660
所以稍后可能，

524
00:32:15,660 --> 00:32:18,660
有其他人创造了名字 6.824 ，

525
00:32:18,810 --> 00:32:25,400
但因为 6.824 出现较晚，

526
00:32:25,400 --> 00:32:28,940
在比特币区块链中，

527
00:32:29,000 --> 00:32:31,010
我们会忽略这一点，

528
00:32:31,520 --> 00:32:38,200
只考虑有效的 6.824 名字记录，

529
00:32:39,220 --> 00:32:41,920
这完全是基于这样一个事实，

530
00:32:41,920 --> 00:32:49,330
区块链是所有发生过的操作的日志，

531
00:32:49,330 --> 00:32:51,310
它们是有序的，它们是有共识的，

532
00:32:51,310 --> 00:32:52,660
以它们发生的顺序，

533
00:32:53,050 --> 00:32:54,670
从这个开始，

534
00:32:54,670 --> 00:32:58,450
我们已经构建了一个类似数据库，

535
00:32:58,480 --> 00:33:00,370
一个按顺序列出所有名字的数据库，

536
00:33:00,400 --> 00:33:02,830
从一开始就通过区块链，

537
00:33:03,070 --> 00:33:07,240
查找有效的交易，名字交易，

538
00:33:07,540 --> 00:33:13,690
并使用它来构建所有有效名称的数据库。

539
00:33:14,220 --> 00:33:17,940
在某些方面，一些人指出了这一点，

540
00:33:17,940 --> 00:33:20,910
这不正是我们实验 3 所做的吗，

541
00:33:20,940 --> 00:33:24,690
我们有日志， Raft 提供了日志，

542
00:33:24,690 --> 00:33:26,250
我们把操作记录在日志里，

543
00:33:26,250 --> 00:33:29,850
我们执行操作，

544
00:33:30,120 --> 00:33:32,940
这构建了状态，

545
00:33:32,970 --> 00:33:35,670
状态在这种情况下将是命名数据库，

546
00:33:35,850 --> 00:33:38,910
我认为这是那种风格，

547
00:33:39,090 --> 00:33:42,840
相同的想法，除了这里的微小区别，

548
00:33:42,840 --> 00:33:44,550
我们不是使用 Raft 获得共识，

549
00:33:44,550 --> 00:33:50,160
我们再次使用比特币或中本聪共识，

550
00:33:50,160 --> 00:33:53,880
实现一个区块链。

551
00:33:54,560 --> 00:33:58,760
但在本质上，是的，这非常相似。

552
00:34:01,660 --> 00:34:04,900
好的，让我们想一想，

553
00:34:04,900 --> 00:34:07,510
我们的三个属性，

554
00:34:07,510 --> 00:34:11,620
首先，我们有唯一的名字吗？

555
00:34:18,010 --> 00:34:18,640
是的。

556
00:34:18,880 --> 00:34:20,350
是的，我们有唯一的名字，

557
00:34:20,350 --> 00:34:21,730
因为第一个会赢。

558
00:34:24,730 --> 00:34:27,070
它是去中心化的吗？

559
00:34:28,860 --> 00:34:29,280
是的。

560
00:34:29,790 --> 00:34:33,180
是的，按比特币的方式去中心化，

561
00:34:36,580 --> 00:34:39,700
共识和日志确保了，

562
00:34:39,700 --> 00:34:42,310
我们可以确定第一个名字是什么，

563
00:34:42,310 --> 00:34:43,810
我们就可以选择一个唯一的名字。

564
00:34:45,080 --> 00:34:46,130
它是人类可读的吗？

565
00:34:47,720 --> 00:34:48,410
可以的。

566
00:34:49,370 --> 00:34:50,840
是的，没错，是的，

567
00:34:53,160 --> 00:34:57,330
当然，我的[流] 6.824 是用户可读的。

568
00:35:02,170 --> 00:35:06,730
好的，所以它看起来第一次带来了三个，

569
00:35:06,730 --> 00:35:10,660
看起来我们得到了三个属性，

570
00:35:11,310 --> 00:35:14,070
我们有用户可读，我们有唯一性，我们有去中心化。

571
00:35:14,950 --> 00:35:19,660
我想 Namecoin 是第一个命名系统，

572
00:35:19,690 --> 00:35:22,780
证明了可以通过这种方式实现。

573
00:35:23,460 --> 00:35:26,250
现在，它并不是完美的，

574
00:35:26,730 --> 00:35:31,500
例如，即使我们有一些唯一的名称和用户可读的，

575
00:35:31,590 --> 00:35:34,920
我们不知道 6.824 到底是什么意思，

576
00:35:35,370 --> 00:35:38,790
6.824 ， 6.824 指的是什么，

577
00:35:38,790 --> 00:35:40,950
是一个章节编号，

578
00:35:40,950 --> 00:35:43,800
或者是班级编号或其他什么，

579
00:35:43,800 --> 00:35:45,750
我们不知道如何解释名字，

580
00:35:45,750 --> 00:35:47,520
但它们仍然是人类可读的，

581
00:35:47,520 --> 00:35:48,660
它不是完美的，

582
00:35:48,660 --> 00:35:52,380
它不是唯一地识别世界上的某个用户，

583
00:35:53,100 --> 00:35:55,920
甚至就像你执行[]，

584
00:35:55,920 --> 00:35:59,970
这并不能唯一地识别一个人，

585
00:35:59,970 --> 00:36:01,380
所以当你看到一个名字的时候，

586
00:36:01,380 --> 00:36:05,250
仍然有一个问题，比如它到底是谁。

587
00:36:07,540 --> 00:36:12,130
另外，还有一个类似的相关问题，

588
00:36:12,130 --> 00:36:13,630
为什么它不是完美的，

589
00:36:13,630 --> 00:36:14,920
这就像是，

590
00:36:15,280 --> 00:36:17,710
你怎么找到某人的名字，

591
00:36:17,950 --> 00:36:22,090
你如何找到[]名字，

592
00:36:22,120 --> 00:36:26,080
你如何找到它，

593
00:36:26,080 --> 00:36:29,200
你如何知道哪条记录与哪个用户匹配，

594
00:36:29,230 --> 00:36:34,450
所以虽然这个系统很酷，

595
00:36:34,450 --> 00:36:38,440
因为它有这些去中心化的，唯一的和人类可读的方面，

596
00:36:38,740 --> 00:36:39,970
这并不是完美的，

597
00:36:39,970 --> 00:36:43,150
这些是通用命名系统的问题，

598
00:36:43,270 --> 00:36:44,920
但在这里也是如此，

599
00:36:45,220 --> 00:36:46,150
所以不是这种情况，

600
00:36:46,150 --> 00:36:49,240
我们应该解决所有的命名问题，

601
00:36:49,360 --> 00:36:51,430
一气呵成，

602
00:36:51,430 --> 00:36:55,840
我们有很好的立足点可以合作，

603
00:36:55,840 --> 00:36:58,900
但这并不是百分之百成功。

604
00:37:01,900 --> 00:37:05,380
所以，问题，所以， Namecoin ，

605
00:37:05,380 --> 00:37:11,890
他们所做的是将这条记录添加到交易中？

606
00:37:12,160 --> 00:37:15,730
嗯，我想我们做得更多，

607
00:37:15,730 --> 00:37:19,280
他们运行自己的区块链，独立于比特币，

608
00:37:19,640 --> 00:37:24,620
使用区块链，有很多，

609
00:37:25,360 --> 00:37:27,550
他们还有一系列的规则，

610
00:37:27,550 --> 00:37:31,480
比如，你要付多少 Namecoin ，

611
00:37:31,480 --> 00:37:32,680
来得到特定的名字，

612
00:37:32,680 --> 00:37:35,170
还有各种各样的其他扩展，

613
00:37:35,530 --> 00:37:39,340
我还没有提到，

614
00:37:39,340 --> 00:37:41,710
但他们遵循了这种方法，

615
00:37:42,140 --> 00:37:43,580
是第一个这样做的，

616
00:37:46,630 --> 00:37:49,780
在论文涉及的许多务实问题中，

617
00:37:49,930 --> 00:37:51,550
我还没有提到。

618
00:37:56,060 --> 00:37:56,990
还有其他问题吗？

619
00:38:04,300 --> 00:38:09,430
好的，让我们稍微深入到一些实际问题上，

620
00:38:09,730 --> 00:38:11,650
尽管性质略有不同，

621
00:38:11,650 --> 00:38:13,000
我们想要讨论，

622
00:38:13,000 --> 00:38:14,140
它是通过，

623
00:38:15,940 --> 00:38:21,580
如何实现去中心化的应用程序和命名系统，

624
00:38:21,880 --> 00:38:24,760
通过利用比特币。

625
00:38:42,020 --> 00:38:47,780
这里有一些很简单的务实问题，

626
00:38:47,990 --> 00:38:50,060
数据量是有限制的，

627
00:38:50,060 --> 00:38:56,990
你可以在交易中放的数据大小。

628
00:38:59,120 --> 00:39:02,270
所以，尽管也许有个名字是很好的，

629
00:39:02,300 --> 00:39:08,660
值绑定进入比特币交易，

630
00:39:08,900 --> 00:39:11,930
我们不能把我们的 todo 列表放在那笔交易中，

631
00:39:11,930 --> 00:39:13,850
所以我们得有个方案，

632
00:39:14,150 --> 00:39:17,780
这部分是如何工作的。

633
00:39:18,590 --> 00:39:19,940
它的写入速度很慢，

634
00:39:21,570 --> 00:39:23,220
我们从上一节课上知道，

635
00:39:23,400 --> 00:39:27,810
它需要一段时间写入交易传播，

636
00:39:28,140 --> 00:39:31,620
在它们决定稳定之前，

637
00:39:31,620 --> 00:39:34,080
它不能再分叉，

638
00:39:34,200 --> 00:39:39,150
我们谈论的可能是链后面的四五六个区块，

639
00:39:39,150 --> 00:39:40,650
每个区块 10 分钟，

640
00:39:40,650 --> 00:39:42,270
所以是一小时之后，

641
00:39:42,810 --> 00:39:44,430
所以这不是很酷，

642
00:39:44,430 --> 00:39:48,810
如果我们也将 todo 列表放在区块链内部，

643
00:39:48,810 --> 00:39:52,800
因为我修改我的区块链，修改我的 todo 列表，

644
00:39:52,800 --> 00:39:54,780
大概一个小时后，也许观察到了它，

645
00:39:54,780 --> 00:39:56,190
所以这看起来不太好，

646
00:39:56,190 --> 00:39:58,950
你想要更积极的应用程序，

647
00:39:58,950 --> 00:40:01,470
有更多的数据需要操作，

648
00:40:01,710 --> 00:40:04,560
当然是一个问题，

649
00:40:04,800 --> 00:40:07,470
类似的，除了慢，

650
00:40:07,470 --> 00:40:09,870
还有慢吞吐量，慢带宽，

651
00:40:15,650 --> 00:40:20,520
在[]中，每秒只有几笔交易，

652
00:40:20,520 --> 00:40:23,550
我们有很多写入到文件中，

653
00:40:23,550 --> 00:40:24,900
很多时候，我们也，

654
00:40:24,900 --> 00:40:29,220
我们将通过区块链运行文件操作，

655
00:40:29,220 --> 00:40:32,610
所以，很明显，我们必须要有一点，

656
00:40:32,610 --> 00:40:39,360
如果我们想为去中心化的应用程序构建通用的基础设施，

657
00:40:39,360 --> 00:40:41,760
将是一个更完整的故事，

658
00:40:41,760 --> 00:40:45,150
这允许我们得到快速的写入，

659
00:40:45,150 --> 00:40:46,380
高带宽写入，

660
00:40:46,380 --> 00:40:50,850
不在区块链中运行所有东西。

661
00:40:51,660 --> 00:40:53,760
这篇论文还讨论了另一个最后的问题，

662
00:40:53,760 --> 00:40:55,830
账本，[增长]账本，

663
00:40:56,600 --> 00:41:01,160
我不会花太多时间来谈论这一点，

664
00:41:01,370 --> 00:41:03,080
但它也会发出，

665
00:41:03,110 --> 00:41:05,660
如果你，[]在论文中，

666
00:41:05,660 --> 00:41:08,720
你将启动一个 Blockstack 节点，

667
00:41:08,720 --> 00:41:11,630
如果你采用传统的比特币风格，

668
00:41:11,630 --> 00:41:14,750
你要逐一检查所有的交易，

669
00:41:14,810 --> 00:41:15,710
这将需要一段时间，

670
00:41:15,710 --> 00:41:18,230
才能建立起完整的命名记录，

671
00:41:18,910 --> 00:41:20,980
特别是，在 Blockstack 的情况下有点烦人，

672
00:41:20,980 --> 00:41:24,010
因为区块链中的很多交易

673
00:41:24,010 --> 00:41:25,930
与 Blockstack 完全无关，

674
00:41:25,930 --> 00:41:29,320
在那里，交易是一个完全不同的目的，

675
00:41:29,500 --> 00:41:33,520
与 Blockstack 方法无关，

676
00:41:33,520 --> 00:41:34,390
Blockstack ，

677
00:41:34,390 --> 00:41:39,010
如果你使用比特币区块链作为你的基础，

678
00:41:39,010 --> 00:41:40,930
你必须通过一个解释器，

679
00:41:40,930 --> 00:41:42,730
看看哪些会应用。

680
00:41:45,100 --> 00:41:49,690
好的，我们将更多地关注前几个挑战，

681
00:41:49,690 --> 00:41:52,540
我们想做的是，

682
00:41:52,540 --> 00:41:55,990
最大限度地减少区块链的使用，

683
00:41:56,320 --> 00:42:02,050
所以我们可以获得高性能写入或[]。

684
00:42:05,160 --> 00:42:05,850
这能理解吗？

685
00:42:11,370 --> 00:42:14,910
好的，这就是这个论文的核心，

686
00:42:15,090 --> 00:42:16,980
也就是，

687
00:42:17,890 --> 00:42:19,540
让我们调出图，

688
00:42:19,540 --> 00:42:20,680
这样我们就能看到它了，

689
00:42:23,320 --> 00:42:24,640
就是这张图。

690
00:42:25,380 --> 00:42:29,160
这是对一般方法的描述，

691
00:42:29,610 --> 00:42:32,460
这篇论文应对这个挑战，

692
00:42:32,460 --> 00:42:34,800
我刚刚在上一块白板上展示的。

693
00:42:39,050 --> 00:42:40,760
好的，这是一张复杂的图，

694
00:42:40,820 --> 00:42:43,370
所以让我们一层一层地看，

695
00:42:43,370 --> 00:42:45,710
试着了解事情是如何工作的。

696
00:42:50,440 --> 00:42:51,880
所以在底部，

697
00:42:53,100 --> 00:42:56,870
这是比特币链，

698
00:43:02,040 --> 00:43:06,660
在比特币链中，有很多交易，

699
00:43:06,720 --> 00:43:13,080
而这些交易中的许多与 Blockstack 完全没有任何关系。

700
00:43:13,080 --> 00:43:14,280
在这里写下 Blockstack 。

701
00:43:18,680 --> 00:43:21,710
Blockstack 位于

702
00:43:21,710 --> 00:43:24,380
区块链中的特定区块，

703
00:43:25,700 --> 00:43:28,550
然后这是第二层，

704
00:43:28,550 --> 00:43:30,170
也就是 Blockstack 节点，

705
00:43:30,320 --> 00:43:33,650
它们读取了所有这些交易，

706
00:43:33,770 --> 00:43:37,490
找出那些与 Blockstack 相关的，

707
00:43:37,700 --> 00:43:40,400
解释这些操作，

708
00:43:40,670 --> 00:43:44,300
构建一个带有名称的 Blockstack 数据库

709
00:43:44,330 --> 00:43:47,150
转换为区域文件哈希值。

710
00:43:47,720 --> 00:43:49,550
所以我们看看这些操作，

711
00:43:49,550 --> 00:43:50,660
这里面的，

712
00:43:50,660 --> 00:43:53,270
所以在每一个比特币交易中，

713
00:43:53,270 --> 00:43:55,160
正如我之前所说的，你可以有一些元数据，

714
00:43:55,190 --> 00:43:58,220
在所谓的 OP_RETRUN 字段，

715
00:43:58,520 --> 00:44:00,860
在 OP_RETURN 字段中，

716
00:44:01,130 --> 00:44:10,260
有一个名字，比如 x 加上区域文件的哈希值，

717
00:44:15,980 --> 00:44:20,360
这是某种绑定，位于比特币中，

718
00:44:20,360 --> 00:44:23,660
Blockstack 使用比特币，

719
00:44:23,660 --> 00:44:30,890
使从名称到区域文件的绑定是唯一的，

720
00:44:30,890 --> 00:44:33,800
并以一种去中心化的方式。

721
00:44:34,550 --> 00:44:39,950
所以，像在实验 3 或任何其他类型的记录系统中一样，

722
00:44:40,160 --> 00:44:48,380
Blockstack 节点解释这些特定的名称交易，

723
00:44:48,410 --> 00:44:49,670
查看 OP 字段，

724
00:44:49,910 --> 00:44:52,100
看到这个 OP 字段，

725
00:44:52,100 --> 00:44:54,080
例如创建了一个特定的名称，

726
00:44:54,170 --> 00:44:56,360
并存储在数据库中，

727
00:44:56,360 --> 00:45:02,450
从名称 x 到区域文件哈希的绑定，

728
00:45:03,480 --> 00:45:06,090
一旦，我们稍后会看到，

729
00:45:06,120 --> 00:45:07,950
通常想要更新区域文件，

730
00:45:08,070 --> 00:45:11,070
你可能会看到 zone 的多个交易，

731
00:45:11,280 --> 00:45:14,340
用户更新那个 zonefile 的哈希值。

732
00:45:15,240 --> 00:45:18,840
当然，我们希望最大限度地减少这些变化，

733
00:45:18,840 --> 00:45:22,380
因为每一次更改都需要，

734
00:45:22,410 --> 00:45:26,610
需要修改或发布比特币交易，

735
00:45:26,790 --> 00:45:30,150
在上一张幻灯片中，由于许多原因，这是很慢的，

736
00:45:30,150 --> 00:45:31,440
应该尽量避免它，

737
00:45:31,530 --> 00:45:33,300
而且，这会花费一些钱，

738
00:45:33,710 --> 00:45:36,860
我的意思是，这些交易需要一个过程。

739
00:45:38,400 --> 00:45:43,960
所以基本的方案，

740
00:45:43,960 --> 00:45:47,590
所以这个节点层，虚拟链层，

741
00:45:47,590 --> 00:45:53,380
建立了从名称到 zonefile 哈希的映射数据库，

742
00:45:53,380 --> 00:45:57,310
当然，还可以过滤掉所有无效的交易，

743
00:45:57,340 --> 00:46:00,940
或者，新的 x 在第一个之后被创造出来。

744
00:46:01,540 --> 00:46:06,160
然后，使用 zonefile 的哈希，

745
00:46:06,160 --> 00:46:07,540
我们得到的，

746
00:46:07,870 --> 00:46:13,540
应用程序可以定位 zonefile ，

747
00:46:13,540 --> 00:46:15,460
并且 zonefile 可以来自任何地方，

748
00:46:15,640 --> 00:46:18,190
因为我们必须对 zonefile 进行哈希，

749
00:46:18,280 --> 00:46:20,890
当我们收到一个声称是 zonefile 的文件时，

750
00:46:20,890 --> 00:46:22,270
我们可以重新计算哈希，

751
00:46:22,330 --> 00:46:27,010
如果哈希与我们通过比特币交互获得的哈希相同，

752
00:46:27,130 --> 00:46:31,390
那么我们可以确定，这就是与 x 对应的 zonefile 。

753
00:46:33,370 --> 00:46:36,460
所以， zonefile 里是什么，

754
00:46:36,760 --> 00:46:41,020
在 zonefile 中是另一张表，

755
00:46:41,050 --> 00:46:44,800
是名字到 URI 的映射，

756
00:46:44,830 --> 00:46:47,140
例如，你可能有一个 zonefile ，

757
00:46:47,140 --> 00:46:50,080
它可能是一个 todo 应用程序，

758
00:46:50,470 --> 00:46:55,370
这是一个 todo 条目，它指向一个 URI ，

759
00:46:56,500 --> 00:47:00,130
todo 列表数据位于这里。

760
00:47:00,930 --> 00:47:04,950
这里有两种类型的 zonefile ，

761
00:47:04,950 --> 00:47:07,560
一个是可变的，一个是不变的，

762
00:47:08,130 --> 00:47:11,650
可变的具有 URI 和公钥，

763
00:47:15,280 --> 00:47:17,830
所以，这是公钥，

764
00:47:17,830 --> 00:47:19,780
是用来验证的密钥，

765
00:47:20,050 --> 00:47:24,130
文件是否由用户 x 写入，

766
00:47:24,130 --> 00:47:27,400
所以用户 x 通过这个 zonefile 发布，

767
00:47:27,400 --> 00:47:29,410
他或她自己的公钥，

768
00:47:29,830 --> 00:47:34,270
稍后，当用户 2 想要查找用户 x 时，

769
00:47:34,270 --> 00:47:36,160
从 zonefile 中得到哈希值，

770
00:47:36,370 --> 00:47:39,940
哈希查找 zonefile ，检查 zonefile ，

771
00:47:39,940 --> 00:47:42,430
哈希值是正确的，

772
00:47:42,460 --> 00:47:45,790
查看 zonefile 内部，

773
00:47:45,820 --> 00:47:48,730
查找的 x 的公钥，

774
00:47:48,790 --> 00:47:52,600
以及 todo 文件的 URI ，

775
00:47:52,780 --> 00:47:57,040
通常 URI 来获取真正的 todo 文件，

776
00:47:57,190 --> 00:48:01,060
使用公钥检查获取文件的签名，

777
00:48:01,240 --> 00:48:02,440
所有都检查了，

778
00:48:02,440 --> 00:48:04,780
然后用户 2 知道，

779
00:48:04,780 --> 00:48:09,640
我得到了用户 x 的 zonefile 。

780
00:48:10,390 --> 00:48:13,750
然后可能像 zonefile 中的其他名字，

781
00:48:13,750 --> 00:48:19,660
无论用户访问推文，还是时间线，等等，

782
00:48:19,780 --> 00:48:22,120
对于每个应用程序可能都是一个条目，

783
00:48:22,120 --> 00:48:24,850
应用程序可能会达成一致，

784
00:48:24,850 --> 00:48:27,040
比如一个名称用于特定的应用程序。

785
00:48:29,240 --> 00:48:33,440
我们不会失去数据的不变性保证，

786
00:48:33,440 --> 00:48:35,300
这些数据可能会被删除，

787
00:48:35,300 --> 00:48:38,320
然后你就不会有数据的哈希值，可能会丢失。

788
00:48:38,860 --> 00:48:41,710
你是什么意思， zonefile 丢失吗？

789
00:48:42,580 --> 00:48:45,310
是的，在链中，你不能丢失数据，

790
00:48:45,340 --> 00:48:46,660
因为它会被复制到足够多的地方，

791
00:48:46,660 --> 00:48:48,280
但在这里，这不是被保证的。

792
00:48:48,280 --> 00:48:51,610
所以， zonefile 也被广泛复制，

793
00:48:51,640 --> 00:48:53,740
在 Blockstack 的核心，

794
00:48:53,740 --> 00:48:56,620
复制了 zonefile 给每个人，

795
00:48:57,010 --> 00:49:00,880
zonefile 是很小的，

796
00:49:00,880 --> 00:49:03,700
例如千字节或什么，

797
00:49:03,910 --> 00:49:05,350
所以它们可以被复制到任何地方，

798
00:49:05,620 --> 00:49:06,130
好的？

799
00:49:06,460 --> 00:49:10,870
然后对于 todo 列表， todo 文件 URI ，

800
00:49:11,080 --> 00:49:13,000
基本的想法是，

801
00:49:13,000 --> 00:49:17,140
你可以将相同的数据存储在多个提供商中，

802
00:49:17,140 --> 00:49:20,380
例如，你可能希望将其复制到 S3 ，

803
00:49:20,710 --> 00:49:23,110
也许你也会把它放在 Google Drive 上，

804
00:49:25,060 --> 00:49:31,210
Blockstack 拥有存储服务器的一个原因是，

805
00:49:31,300 --> 00:49:33,160
不是因为它们存储数据，

806
00:49:33,190 --> 00:49:37,060
而是为所有这些不同的存储提供商提供统一的 API 。

807
00:49:43,890 --> 00:49:44,490
好的，就是这样。

808
00:49:46,010 --> 00:49:46,730
这能理解吗？

809
00:49:50,330 --> 00:49:54,380
好的，我提到 zonefile 有两种方式，

810
00:49:54,380 --> 00:49:57,110
还有一种称为不可变存储，

811
00:49:57,110 --> 00:50:01,820
它包含了 URI 、名称 ，

812
00:50:03,170 --> 00:50:14,600
URI 、公钥和文件数据的哈希值。

813
00:50:16,680 --> 00:50:18,390
所以你可以检查，

814
00:50:18,420 --> 00:50:21,930
这是否是文件的最新版本，

815
00:50:22,290 --> 00:50:25,230
因为在这个方案中，你可以更新，

816
00:50:25,230 --> 00:50:26,760
x 可以更新文件，

817
00:50:26,760 --> 00:50:29,220
但对用户 2 来说，很难区分，

818
00:50:29,220 --> 00:50:31,170
这是不是最新版本，

819
00:50:31,500 --> 00:50:32,640
这篇论文提到，

820
00:50:32,640 --> 00:50:34,860
可能版本号在其中，

821
00:50:35,130 --> 00:50:38,820
但如果你想保证是某个名字的最新版本，

822
00:50:39,030 --> 00:50:41,280
如果使用的是不可变存储，

823
00:50:41,280 --> 00:50:44,490
不变的存储包含文件的哈希，

824
00:50:44,790 --> 00:50:48,990
它唯一地标识特定文件的特定版本。

825
00:50:49,640 --> 00:50:53,120
这意味着，如果你更新这个记录，

826
00:50:54,010 --> 00:50:57,100
然后，这意味着你更新 zonefile ，

827
00:50:57,370 --> 00:50:58,030
这意味着，

828
00:50:58,030 --> 00:51:02,980
你必须在比特币链中重新发布或重新创建一个日志条目，

829
00:51:03,070 --> 00:51:07,510
将 x 映射到一个新的哈希 zonefile 。

830
00:51:11,420 --> 00:51:16,580
好的，这就是这个系统的总体情况，

831
00:51:16,850 --> 00:51:17,990
正如你所看到的，

832
00:51:17,990 --> 00:51:22,220
使用 todo 列表网站，

833
00:51:23,070 --> 00:51:29,880
用户 x 可以更新它的 todo 列表，

834
00:51:30,150 --> 00:51:35,580
不必在比特币链中发布新的记录，

835
00:51:36,060 --> 00:51:39,600
事实上，比特币链条中唯一需要创造的东西是

836
00:51:39,750 --> 00:51:41,340
只有 x 的名字，

837
00:51:41,610 --> 00:51:43,980
当然， x 可能还有很多其他的名字，

838
00:51:43,980 --> 00:51:45,450
它们位于 zonefile 中，

839
00:51:45,630 --> 00:51:50,250
但是你知道，

840
00:51:51,910 --> 00:51:56,920
这个系统并不依赖于区块链上的每个操作，

841
00:51:57,750 --> 00:52:00,870
它绕过了许多这样的问题，

842
00:52:00,870 --> 00:52:03,510
如低速率、低带宽，

843
00:52:03,810 --> 00:52:05,400
以及限制，

844
00:52:06,500 --> 00:52:10,310
以及对交易记录中出现的数据的限制，

845
00:52:10,310 --> 00:52:13,070
因为只有数据必须出现在交易记录中，

846
00:52:13,310 --> 00:52:15,770
就是这个名字加上 zonefile 的哈希值。

847
00:52:19,990 --> 00:52:23,830
抱歉，我们如何找到 zonefile ，如果只有哈希值？

848
00:52:24,310 --> 00:52:25,810
这是一个非常好的问题，

849
00:52:25,840 --> 00:52:28,600
我们并不关心，它来自哪里，

850
00:52:28,600 --> 00:52:31,060
所以他们把这叫做路由层，

851
00:52:31,690 --> 00:52:33,460
基本上，你告诉路由层，

852
00:52:33,490 --> 00:52:36,670
嘿，我在找一个具有以下哈希值的文件，

853
00:52:38,000 --> 00:52:41,990
然后路由层会产生那个文件，

854
00:52:41,990 --> 00:52:44,090
你可以检查是否获得了正确的文件，

855
00:52:44,120 --> 00:52:45,380
通过重新计算哈希，

856
00:52:45,380 --> 00:52:47,600
看看是不是你要的那个。

857
00:52:58,400 --> 00:52:59,690
对于这个，还有其他问题吗？

858
00:53:05,210 --> 00:53:07,250
抱歉，只是为了确认一下，

859
00:53:07,310 --> 00:53:11,390
文件存储或 zonefile 中的操作

860
00:53:11,390 --> 00:53:14,330
仍然受到底层区块链的限制，对吗？

861
00:53:14,970 --> 00:53:18,840
是或不是，你是怎么想的？

862
00:53:21,860 --> 00:53:27,650
或者因为对文件的修改或更改需要新的哈希，

863
00:53:27,650 --> 00:53:30,590
因此在区块链内形成新的日志条目，

864
00:53:30,710 --> 00:53:34,880
所以你仍然需要等待“被接受”，

865
00:53:34,910 --> 00:53:36,230
大概是一个小时，对吧。

866
00:53:36,760 --> 00:53:38,740
是的，没错，

867
00:53:38,740 --> 00:53:40,840
当你对 zonefile 进行更改时，

868
00:53:40,870 --> 00:53:43,990
它必须通过 txn ，

869
00:53:44,260 --> 00:53:46,180
例如更新 todo 列表，

870
00:53:46,450 --> 00:53:49,930
不需要比特币交易，

871
00:53:53,550 --> 00:53:55,770
你根本没有更新 zonefile ，

872
00:53:55,800 --> 00:53:58,470
你只是更新 todo 列表文件，

873
00:53:58,470 --> 00:54:03,270
zonefile 只包含 todo 的名字、 URI 和公钥，

874
00:54:03,270 --> 00:54:04,770
但你没有更新其中的任何一个。

875
00:54:08,290 --> 00:54:12,220
我明白了，但是我们不是也存储文件的哈希值吗，

876
00:54:12,250 --> 00:54:13,870
如果我们改变内容。

877
00:54:13,990 --> 00:54:14,830
这只是，

878
00:54:14,830 --> 00:54:15,730
有两种情况，

879
00:54:15,730 --> 00:54:19,120
有可变的存储和不变的存储，

880
00:54:19,900 --> 00:54:23,410
他们提出的是，

881
00:54:23,410 --> 00:54:25,810
对于不变存储，你不更新，

882
00:54:25,810 --> 00:54:27,670
你可以把文件的哈希值放在那里，

883
00:54:27,670 --> 00:54:31,450
但对于可变存储，将会看到大量写入，

884
00:54:31,540 --> 00:54:34,070
你不应该那样做，你应该用这个密钥。

885
00:54:36,860 --> 00:54:39,440
我明白了，那么如何确认

886
00:54:39,440 --> 00:54:41,990
使用可变存储，你获得了正确的数据。

887
00:54:42,200 --> 00:54:44,540
是的，这是一个非常好的问题，

888
00:54:44,540 --> 00:54:46,730
好的，你可以验证，

889
00:54:46,730 --> 00:54:49,310
你是否得到了，是否是由 x 产生的，

890
00:54:49,340 --> 00:54:50,840
因为你有 x 的公钥，

891
00:54:50,840 --> 00:54:54,320
你可以验证 todo 文件上的签名，

892
00:54:54,440 --> 00:54:57,380
用 x 的公钥进行验证，

893
00:54:57,710 --> 00:55:00,370
所以你至少知道是 x 写的，

894
00:55:00,400 --> 00:55:02,410
你可能不知道这个最新版本，

895
00:55:02,410 --> 00:55:06,790
所以论文没有详细地讨论这些，

896
00:55:06,790 --> 00:55:07,450
在基本系统中，

897
00:55:07,450 --> 00:55:09,520
我们可能必须在其中插入版本号，

898
00:55:09,520 --> 00:55:12,310
至少你可以检测到回滚，

899
00:55:12,520 --> 00:55:14,140
这有点困难，

900
00:55:14,140 --> 00:55:16,690
我也不知道该怎么做，

901
00:55:18,880 --> 00:55:20,860
你不能确定你得到了最新的版本。

902
00:55:21,990 --> 00:55:25,710
但是对可变存储的修改来自哪里？

903
00:55:26,700 --> 00:55:28,440
你的 todo 文件在这里，

904
00:55:28,470 --> 00:55:30,570
比如这里， todo 文件，

905
00:55:32,020 --> 00:55:33,700
如果一个应用程序，

906
00:55:33,700 --> 00:55:36,340
可能是 todo 列表应用程序想要更新 todo 文件，

907
00:55:36,340 --> 00:55:37,360
只管去做就行了，

908
00:55:38,020 --> 00:55:42,010
然后使用公钥对其进行签名，

909
00:55:42,010 --> 00:55:49,250
并将其给指定的 URI 。

910
00:55:50,400 --> 00:55:53,850
这是否也通过路由层来完成，

911
00:55:53,850 --> 00:55:56,880
因为你想找出存储在什么地方。

912
00:55:57,120 --> 00:56:01,110
是的，所以用户 2 将获取 x 的 zonefile ，

913
00:56:01,680 --> 00:56:03,720
一旦它有了 x 的 zonefile ，

914
00:56:03,720 --> 00:56:07,440
它知道 todo 文件的位置，

915
00:56:07,440 --> 00:56:09,900
因为这里有 URI 在 zonefile 中。

916
00:56:12,610 --> 00:56:17,170
再次，他们可以取回它并检查签名。

917
00:56:18,220 --> 00:56:19,840
关于这里的 URI ，

918
00:56:20,110 --> 00:56:26,110
在 zonefile 中，每个名字只有一个 URI 吗？

919
00:56:26,800 --> 00:56:30,490
我不知道，不清楚它到底是怎么工作的，

920
00:56:30,550 --> 00:56:34,210
抱歉，我需要检查一下源代码，

921
00:56:34,210 --> 00:56:37,480
并查看特定格式的 zonefile 。

922
00:56:42,440 --> 00:56:45,500
由于我们发布公钥

923
00:56:45,920 --> 00:56:49,310
与 zonefile 中的所有其他数据一起，

924
00:56:49,310 --> 00:56:53,840
是不是意味着我可以编造一个私钥，

925
00:56:54,290 --> 00:56:56,810
匹配公钥，

926
00:56:57,170 --> 00:57:00,320
在其中插入一些东西，然后说我是用户，

927
00:57:01,240 --> 00:57:05,430
因为它们提供了公钥，

928
00:57:05,430 --> 00:57:07,770
所以我能不能撒谎？

929
00:57:08,520 --> 00:57:10,860
嗯，你不能篡改 zonefile ，

930
00:57:11,410 --> 00:57:14,260
因为 zonefile 的哈希值

931
00:57:14,260 --> 00:57:16,600
必须与区块链中的哈希值匹配，

932
00:57:23,890 --> 00:57:29,840
所以，只有进入区块链记录的版本

933
00:57:30,080 --> 00:57:32,900
将 x 映射到哈希 zonefile ，

934
00:57:32,960 --> 00:57:35,930
只有那个人才能产生那个 zonefile 。

935
00:57:37,690 --> 00:57:39,670
我明白了，谢谢。

936
00:57:45,060 --> 00:57:45,690
好的?

937
00:57:46,620 --> 00:57:48,660
好的，所以这是一幅大的图景，

938
00:57:48,690 --> 00:57:51,690
如果你得到了这个部分，

939
00:57:51,690 --> 00:57:54,270
然后其他一些细节，

940
00:57:54,300 --> 00:57:57,540
重要或不那么重要的，

941
00:57:57,540 --> 00:57:59,580
这是要理解的关键事情。

942
00:58:01,740 --> 00:58:05,410
好的，有几件事我想说一下，

943
00:58:05,410 --> 00:58:08,290
我特别想更多地讨论一下名字创造，

944
00:58:08,290 --> 00:58:10,720
因为有几个小细节，很有趣。

945
00:58:19,260 --> 00:58:25,320
命名有两个部分，

946
00:58:25,410 --> 00:58:28,020
首先，用户当然需要一些比特币，

947
00:58:28,020 --> 00:58:28,890
因为你需要支付，

948
00:58:37,450 --> 00:58:38,920
你必须拥有一些比特币的原因是，

949
00:58:38,920 --> 00:58:42,820
因为你必须说服其中一个矿工

950
00:58:42,820 --> 00:58:46,030
将你的交易纳入比特币账本。

951
00:58:46,600 --> 00:58:51,130
所以你创建的每个名字都有两笔交易，

952
00:58:55,130 --> 00:58:59,540
一种是预购交易，

953
00:59:02,300 --> 00:59:03,800
在预购交易中，

954
00:59:03,890 --> 00:59:05,420
你不会把名字列出来，

955
00:59:05,420 --> 00:59:07,130
而是名字的哈希值，

956
00:59:11,730 --> 00:59:13,950
所以，任何收到预购交易的人，

957
00:59:13,950 --> 00:59:15,030
不知道名字是什么，

958
00:59:15,030 --> 00:59:17,760
但是知道这个名字的哈希值是什么。

959
00:59:18,080 --> 00:59:21,860
然后是第二个交易真正注册名字，

960
00:59:24,280 --> 00:59:27,730
它包含了实际的名字，

961
00:59:28,890 --> 00:59:33,210
我们首先发布 zonefile 的哈希值。

962
00:59:41,380 --> 00:59:45,460
那么为什么要这样做，

963
00:59:45,460 --> 00:59:47,680
这实际上是 Namecoin 所做的，

964
00:59:47,680 --> 00:59:50,110
他们在这里采用 Namecoin ，

965
00:59:50,110 --> 00:59:51,340
为什么要这样做？

966
00:59:54,240 --> 00:59:56,340
因为如果你直接宣布名字，

967
00:59:56,340 --> 00:59:58,230
然后其他人可以[]你，

968
00:59:58,230 --> 01:00:02,010
并尝试在你之前注册这个名字。

969
01:00:02,310 --> 01:00:06,960
是的，这是一个常见的问题，从前面开始的问题。

970
01:00:09,310 --> 01:00:11,050
糟糕，又来了，抱歉。

971
01:00:33,790 --> 01:00:37,570
所以领跑者问题准确地描述了，

972
01:00:37,570 --> 01:00:40,570
假设你尝试注册 google.com ，

973
01:00:40,900 --> 01:00:43,750
如果有人看到你这么做，

974
01:00:43,750 --> 01:00:45,340
你当然会提交一笔交易，

975
01:00:45,340 --> 01:00:46,510
还没有进入区块链，

976
01:00:46,750 --> 01:00:48,730
例如，一个矿工看到，

977
01:00:48,730 --> 01:00:52,390
或者其他在比特币网络中的人，

978
01:00:52,720 --> 01:00:54,250
并决定领先，

979
01:00:54,250 --> 01:00:55,480
并试图获得我的交易，

980
01:00:55,480 --> 01:01:00,550
在你之前，声称 google.com 进入比特币，

981
01:01:00,790 --> 01:01:03,130
现在我拥有 google.com ，

982
01:01:03,370 --> 01:01:05,380
所以，为了避免这个问题，

983
01:01:05,560 --> 01:01:09,370
你首先必须将哈希值输入比特币链中，

984
01:01:09,640 --> 01:01:13,150
然后你等待一段时间以确保，

985
01:01:13,650 --> 01:01:17,610
这一记录位于比特币区块链中，

986
01:01:17,760 --> 01:01:20,310
你有六个或十个区块，

987
01:01:20,490 --> 01:01:22,200
然后，在你确定之后，

988
01:01:22,200 --> 01:01:27,390
你将名字刻在区块链中，

989
01:01:27,630 --> 01:01:30,210
在这一点上，你进行真正的注册。

990
01:01:31,770 --> 01:01:33,240
关于这一点，我有一个问题。

991
01:01:35,070 --> 01:01:36,090
所以，什么，

992
01:01:36,270 --> 01:01:38,280
为什么攻击者不可能

993
01:01:38,280 --> 01:01:41,850
预先计算 google.com 的哈希值，

994
01:01:41,880 --> 01:01:43,920
然后查看区块链，

995
01:01:43,920 --> 01:01:45,870
看看有没有人发布了 google 的哈希值。

996
01:01:46,080 --> 01:01:47,580
是的，绝对是，

997
01:01:47,580 --> 01:01:50,910
是的，所以绝对比这个稍微复杂一点，

998
01:01:50,910 --> 01:01:52,320
只是纯粹的哈希，

999
01:01:52,320 --> 01:01:54,150
还有很多参数进入，

1000
01:01:54,150 --> 01:01:55,410
它包括 nonce 或其他东西，

1001
01:01:58,330 --> 01:02:00,070
否则，你可以创建一个字典。

1002
01:02:06,870 --> 01:02:09,000
在某些方面，这不是他们的发明，

1003
01:02:09,000 --> 01:02:11,310
就像我之前说的，

1004
01:02:11,310 --> 01:02:16,370
它来自于 Namecoin 。

1005
01:02:22,880 --> 01:02:28,880
好的，让我们回到协作应用程序，

1006
01:02:28,880 --> 01:02:38,090
对于协作性去中心化的应用程序。

1007
01:02:47,430 --> 01:02:50,070
以我们的 todo 列表为例，

1008
01:02:50,400 --> 01:02:53,220
看看它到底是怎么工作的，

1009
01:02:53,250 --> 01:02:56,160
所以再次勾勒出来，它是如何工作的，

1010
01:02:56,550 --> 01:02:59,010
所以有两个用户，

1011
01:02:59,070 --> 01:03:01,470
运行 todo 列表应用程序，

1012
01:03:06,030 --> 01:03:08,400
这里是 U1 ，这里是 U2 ，

1013
01:03:14,110 --> 01:03:17,290
它们互相交换了一些信息，

1014
01:03:17,410 --> 01:03:19,330
使用某种方法，

1015
01:03:19,330 --> 01:03:21,490
U1 已经知道了 U2 的名字，

1016
01:03:21,490 --> 01:03:23,410
U2 也知道了 U1 的名字。

1017
01:03:25,120 --> 01:03:27,790
当然，这一步必须要发生，

1018
01:03:27,790 --> 01:03:29,350
它必须安全地发生，

1019
01:03:29,350 --> 01:03:32,890
U1 需要知道 U2 的名字，

1020
01:03:33,190 --> 01:03:33,820
然后它们可以，

1021
01:03:34,500 --> 01:03:39,570
U1 可以查询 U2 的名字，

1022
01:03:42,900 --> 01:03:44,730
获取它的 zonefile ，

1023
01:03:47,470 --> 01:03:51,100
在 zonefile 中找到 todo 列表条目，

1024
01:03:54,220 --> 01:03:57,400
zonefile 也包含公钥，

1025
01:04:00,550 --> 01:04:01,780
这可能不是，

1026
01:04:01,780 --> 01:04:05,410
U2 可能有许多公钥、私钥，

1027
01:04:05,440 --> 01:04:08,530
因为你可能不想拥有一个主私钥，

1028
01:04:08,530 --> 01:04:09,520
用在所有地方，

1029
01:04:09,520 --> 01:04:11,980
因为如果你使用那个主私钥，

1030
01:04:11,980 --> 01:04:14,080
或者一些人是不好的，

1031
01:04:14,380 --> 01:04:16,570
所以，通常我认为在区块链中，

1032
01:04:16,570 --> 01:04:19,780
每个应用程序都应该有一个私钥。

1033
01:04:20,560 --> 01:04:25,870
所以， U1 在 zonefile 中查找 U2 的名字，

1034
01:04:25,870 --> 01:04:29,380
以及 todo 列表公钥和 URI ，

1035
01:04:31,420 --> 01:04:34,540
通过 Blockstack 文件系统，

1036
01:04:34,690 --> 01:04:37,480
它跟踪不同的存储提供商，

1037
01:04:37,480 --> 01:04:42,070
并获取实际名称、实际文件，

1038
01:04:43,990 --> 01:04:45,640
检查文件上的签名，

1039
01:04:45,640 --> 01:04:46,870
也许是版本号，

1040
01:04:46,930 --> 01:04:54,220
然后用它来构建 U2 中的 todo 列表，

1041
01:04:54,220 --> 01:04:55,720
并与 U1 的一起起作用，

1042
01:04:55,720 --> 01:04:58,990
同样地， U2 也是一样的方式，

1043
01:04:58,990 --> 01:05:00,430
U1 的名字，

1044
01:05:02,120 --> 01:05:07,940
然后继续，是 U1 的 todo 列表，

1045
01:05:07,940 --> 01:05:13,040
通过这种方式，他们可以拥有一个协作应用程序，

1046
01:05:13,280 --> 01:05:17,270
所以，当 U2 更新它的文件时，

1047
01:05:17,270 --> 01:05:21,530
然后， U1 的应用程序定期，

1048
01:05:21,530 --> 01:05:25,310
获取新的 todo 列表，

1049
01:05:25,310 --> 01:05:26,900
看看有没有什么更新。

1050
01:05:30,870 --> 01:05:31,890
这能理解吗？

1051
01:05:34,670 --> 01:05:35,480
你看这里，

1052
01:05:35,480 --> 01:05:39,260
我认为这是去中心化应用程序的中心点之一，

1053
01:05:39,560 --> 01:05:44,090
这种应用程序构建使用一种很不同的方式，

1054
01:05:44,090 --> 01:05:46,970
而不是我们之前谈到的，

1055
01:05:46,970 --> 01:05:50,990
如果我们回到这张集中式站点的图片，

1056
01:05:51,140 --> 01:05:54,740
我们构建了一个 todo 列表应用程序，

1057
01:05:54,740 --> 01:06:03,940
在数据库中，有 U1 的 todo 列表和 U2 的 todo 列表，

1058
01:06:08,440 --> 01:06:10,870
以及 todo 列表应用程序，

1059
01:06:11,170 --> 01:06:15,250
获取这些 todo 列表的内容，

1060
01:06:15,250 --> 01:06:16,690
使用一个简单的 SQL 查询，

1061
01:06:16,960 --> 01:06:19,570
然后把它们放在一起，呈现给用户，

1062
01:06:19,990 --> 01:06:23,050
当我们看到在这个去中心化的方案中，

1063
01:06:23,200 --> 01:06:25,420
这涉及到更多的机制，

1064
01:06:25,420 --> 01:06:26,560
才能实现这一点，

1065
01:06:26,800 --> 01:06:28,390
在程序中，

1066
01:06:28,390 --> 01:06:35,980
它没有与集中式案例相同的简单的 SQL 接口。

1067
01:06:36,840 --> 01:06:41,010
所以我认为这可能是症结之一，

1068
01:06:41,010 --> 01:06:42,600
这些去中心化应用程序，

1069
01:06:42,630 --> 01:06:46,440
如何才能简单编写去中心化版本。

1070
01:06:52,490 --> 01:06:54,590
好的，我想留点时间，

1071
01:06:54,590 --> 01:06:55,850
进行分组会议室，

1072
01:06:55,880 --> 01:07:00,230
留下一些时间提问或讨论，

1073
01:07:00,440 --> 01:07:05,780
但因为这是一种更发人深省的练习，

1074
01:07:05,780 --> 01:07:08,240
比起一个练习，

1075
01:07:08,270 --> 01:07:10,100
这是一个棘手的技术问题，

1076
01:07:10,100 --> 01:07:11,240
这是正确的解决方案，

1077
01:07:11,240 --> 01:07:12,560
这是了解正确解决方案，

1078
01:07:12,560 --> 01:07:13,220
然后使用它。

1079
01:07:13,980 --> 01:07:19,320
所以，想听听人们的意见或问题，

1080
01:07:19,320 --> 01:07:23,730
关于这些去中心化应用程序与中心化应用程序的任何方面，

1081
01:07:23,730 --> 01:07:27,700
然后是 Blockstack 的设计或任何其他问题，

1082
01:07:27,700 --> 01:07:29,260
我们可以一起讨论。

1083
01:07:32,280 --> 01:07:35,670
等等，最大的困难是什么，

1084
01:07:35,670 --> 01:07:41,940
使用文件系统 API 而不是使用关系数据库？

1085
01:07:42,740 --> 01:07:43,490
好的，你怎么写，

1086
01:07:43,490 --> 01:07:47,990
你怎么呈现全球关系数据库，

1087
01:07:48,920 --> 01:07:51,080
所有这些用户文件，

1088
01:07:51,650 --> 01:07:53,000
所有这些文件将是不同的用户，

1089
01:07:53,000 --> 01:07:56,990
在各种不同的存储提供商中，

1090
01:07:56,990 --> 01:08:01,160
你不能做任何事，

1091
01:08:01,160 --> 01:08:05,000
你不能在所有存储提供商之间进行 select ，

1092
01:08:05,000 --> 01:08:05,870
这太疯狂了，

1093
01:08:07,850 --> 01:08:10,910
你也不能把所有的用户数据下载到你的计算机上，

1094
01:08:10,910 --> 01:08:12,230
因为那太昂贵了。

1095
01:08:12,960 --> 01:08:19,700
关联数据库，会怎么样？

1096
01:08:20,120 --> 01:08:27,650
我想这是[]研究人员要去追求的，

1097
01:08:27,650 --> 01:08:33,750
但你可以构建一种可伸缩的数据库基础设施，

1098
01:08:33,750 --> 01:08:36,840
其中用户仍然控制位于不同位置的自己的数据，

1099
01:08:36,840 --> 01:08:39,660
并提供一种关系型数据类型接口，

1100
01:08:41,250 --> 01:08:43,590
显然， Blockstack 不能提供给你。

1101
01:08:48,190 --> 01:08:49,660
是的，另一个问题是，

1102
01:08:49,750 --> 01:08:55,750
这种去中心化的 PKI 与信任网络 PKI 相比有什么好处，

1103
01:08:55,750 --> 01:08:57,460
我想它也是去中心化的。

1104
01:08:57,520 --> 01:09:02,920
是的，所以其他，也许是这里的一些要点，

1105
01:09:03,190 --> 01:09:07,150
还有其他信任网络 PKI ，

1106
01:09:07,150 --> 01:09:12,710
信任网络 PKI ，

1107
01:09:13,100 --> 01:09:21,350
我最熟悉的是 Keybase ，

1108
01:09:24,970 --> 01:09:26,770
我想我们在之前提到过几次，

1109
01:09:26,860 --> 01:09:32,410
Keybase ，我们没有详细讨论过这个，

1110
01:09:32,410 --> 01:09:35,800
但是，同样挑战这类系统的一件事是，

1111
01:09:35,800 --> 01:09:37,960
你如何表示用户组，

1112
01:09:38,350 --> 01:09:40,420
比如我们在 SUNDR 的论文中看到的，

1113
01:09:40,600 --> 01:09:44,050
有组名，组名的公钥，

1114
01:09:44,050 --> 01:09:47,020
如何创建和管理它们，如何将它们插入其中，

1115
01:09:47,020 --> 01:09:52,990
如何将这些合并到名称记录链中，

1116
01:09:53,170 --> 01:09:56,350
Keybase 是一个为此而战的故事，

1117
01:09:56,860 --> 01:10:01,750
非常令人印象深刻的真相，

1118
01:10:02,220 --> 01:10:08,130
可能是最好的去中心化的 PKI ，

1119
01:10:09,150 --> 01:10:10,170
最深思熟虑的是，

1120
01:10:10,170 --> 01:10:11,640
它们可能是使用最广泛的。

1121
01:10:18,440 --> 01:10:21,830
那么像 Blockstack 这样做有什么好处吗，

1122
01:10:21,830 --> 01:10:23,930
或者它只是更具可扩展性？

1123
01:10:23,930 --> 01:10:26,900
好的， Blockstack 得到的一件事情是，

1124
01:10:26,900 --> 01:10:29,420
是这个唯一的特性，

1125
01:10:29,420 --> 01:10:32,720
因为信任网络，没有一个全球命名系统，

1126
01:10:32,720 --> 01:10:36,500
比如我的 todo 列表或者我的联系人列表，

1127
01:10:36,950 --> 01:10:40,100
不管怎么命名，

1128
01:10:40,790 --> 01:10:44,270
如果我对某个公钥有一个名字 John ，那就是我的 John ，

1129
01:10:44,570 --> 01:10:49,010
如果发送 John 给你，比如字符串 John ，

1130
01:10:49,010 --> 01:10:53,960
它在你的联系人列表中的解析可能与我的不同。

1131
01:10:55,280 --> 01:10:59,390
所以，事实上， Keybase 更多是去中心化的，

1132
01:10:59,390 --> 01:11:03,020
但它并不适用于全球唯一的名称，

1133
01:11:03,930 --> 01:11:06,960
这种情况下， Keybase 偶尔发布，

1134
01:11:06,960 --> 01:11:09,450
所有名称的哈希，

1135
01:11:09,480 --> 01:11:15,300
以及区块链中所有名称的完整的 Merkle 树，

1136
01:11:15,300 --> 01:11:18,810
这样你可以确认 Keybase 不是玩那个游戏，

1137
01:11:19,230 --> 01:11:22,950
但是，还有更多，

1138
01:11:22,950 --> 01:11:24,600
它没有全球唯一的名称。

1139
01:11:30,000 --> 01:11:31,890
抱歉，我只想确认一个问题，

1140
01:11:31,920 --> 01:11:33,600
在课程的前面部分，

1141
01:11:33,600 --> 01:11:36,090
你提到了用户如何拥有，

1142
01:11:36,300 --> 01:11:39,150
他们可以选择向谁显示他们的数据，

1143
01:11:39,390 --> 01:11:43,470
或者他们允许谁访问他们的数据，

1144
01:11:43,740 --> 01:11:45,480
但我不太确定我看到了，

1145
01:11:45,480 --> 01:11:48,600
这是如何在那个系统中实现的。

1146
01:11:50,750 --> 01:11:52,790
好的，这里有方法，

1147
01:11:52,790 --> 01:11:53,780
有一种做的方法，

1148
01:11:53,780 --> 01:11:57,590
我不确定 Blockstack 是怎么做的，

1149
01:11:57,590 --> 01:12:01,280
你为不同的用户加密相同的数据，

1150
01:12:01,310 --> 01:12:06,620
如果你只想与用户 1 或用户 2 共享数据，

1151
01:12:07,050 --> 01:12:12,720
然后，你使用用户 1 和用户 2 的公钥进行加密，

1152
01:12:13,080 --> 01:12:15,240
然后只有这两个可以解密它，

1153
01:12:18,960 --> 01:12:20,850
这就为你提供了访问控制表。

1154
01:12:25,850 --> 01:12:30,050
我明白了，所以对于每个你想要提供数据的人，

1155
01:12:30,050 --> 01:12:32,780
你必须用他们的公钥对其加密。

1156
01:12:34,240 --> 01:12:36,280
你可以在这方面变得更复杂，

1157
01:12:36,280 --> 01:12:37,960
你可以拥有组密钥，

1158
01:12:38,350 --> 01:12:42,940
给一组用户一个秘钥，

1159
01:12:43,330 --> 01:12:45,700
其中包含组密钥，

1160
01:12:45,700 --> 01:12:50,470
使用不同用户的公钥增加密钥盒，

1161
01:12:50,470 --> 01:12:52,570
然后他们访问那个密钥盒，

1162
01:12:52,570 --> 01:12:53,650
他们从里面拿到了密钥，

1163
01:12:53,650 --> 01:12:54,970
然后他们可以对密钥解密，

1164
01:12:54,970 --> 01:12:59,410
所以，你只需对数据加密一次，而不是多次，

1165
01:13:00,320 --> 01:13:03,470
你必须对密钥盒加密多次。

1166
01:13:04,540 --> 01:13:05,200
谢谢。

1167
01:13:08,040 --> 01:13:12,990
这将降低 zonefile 的内容级别，对吗？

1168
01:13:13,770 --> 01:13:15,870
是的，可能是，

1169
01:13:15,870 --> 01:13:20,280
或者 zonefile 的密钥是密钥盒的，

1170
01:13:22,200 --> 01:13:24,360
同样，我不是百分之百确定

1171
01:13:24,360 --> 01:13:34,600
Blockstack 文件系统如何控制，

1172
01:13:34,600 --> 01:13:35,440
它所做的一切，

1173
01:13:37,340 --> 01:13:39,860
但其他人做过这样的设计。

1174
01:13:41,930 --> 01:13:46,280
你认为这样的系统能够与集中式模式竞争吗，

1175
01:13:46,310 --> 01:13:48,950
在性能或可伸缩性方面，

1176
01:13:49,160 --> 01:13:50,030
那要付出什么代价。

1177
01:13:50,750 --> 01:13:55,140
我不知道，好问题，

1178
01:13:55,200 --> 01:13:57,240
我不知道答案，

1179
01:13:57,240 --> 01:13:58,020
它是这种情况，

1180
01:13:58,020 --> 01:14:00,840
即使最简单的规模也不是那么容易扩展的，

1181
01:14:00,870 --> 01:14:03,420
我们已经读了相当多的论文，

1182
01:14:03,420 --> 01:14:08,790
了解如何让它们在数百万用户之间进行扩展，

1183
01:14:09,150 --> 01:14:13,400
所以你知道两个，

1184
01:14:13,400 --> 01:14:17,060
要让大量的用户获得任何东西并不容易，

1185
01:14:17,630 --> 01:14:22,970
当然，在去中心化应用程序的情况下，

1186
01:14:22,970 --> 01:14:24,110
这也不容易，

1187
01:14:24,110 --> 01:14:26,570
但另一方面，如果不是通过共享，

1188
01:14:26,900 --> 01:14:30,440
比如用户 1 只需要分享给其他 10 个用户，

1189
01:14:30,950 --> 01:14:32,660
这可能不是什么大问题，

1190
01:14:32,690 --> 01:14:35,720
在某些方面，你可以认为去中心化的体系结构

1191
01:14:35,750 --> 01:14:37,190
是按用户划分的，

1192
01:14:42,280 --> 01:14:45,580
每个应用程序都在用户的一台计算机上运行，

1193
01:14:46,380 --> 01:14:51,080
所以，你不需要数据中心的缓存，

1194
01:14:57,370 --> 01:14:59,230
所以我不知道这个问题的答案是什么，

1195
01:15:00,850 --> 01:15:02,680
我不能给你一个确定的答案。

1196
01:15:07,120 --> 01:15:08,980
很明显，人们已经证明了

1197
01:15:08,980 --> 01:15:14,200
这些集中式设计具有更大的可扩展性，

1198
01:15:14,200 --> 01:15:17,050
至少到目前为止，我们看到去中心化的一次，

1199
01:15:17,050 --> 01:15:18,580
但其中一个原因当然是

1200
01:15:18,580 --> 01:15:23,170
集中式设计被广泛使用，

1201
01:15:23,170 --> 01:15:26,800
最受欢迎，部署最多的案例。

1202
01:15:28,430 --> 01:15:33,170
我想，对我来说，去中心化设计是有趣的设计，

1203
01:15:33,590 --> 01:15:36,140
而且可以让它发挥作用，

1204
01:15:36,140 --> 01:15:37,250
这会很酷。

1205
01:15:45,980 --> 01:15:52,940
大家还有什么想法，或想讨论的？

1206
01:15:59,330 --> 01:16:04,480
我仍然觉得在存储方面是，

1207
01:16:04,510 --> 01:16:07,990
就像 William 指出的那样，

1208
01:16:07,990 --> 01:16:13,960
比如你可能有一个不变的文件，它是用户信息，

1209
01:16:13,960 --> 01:16:17,200
但是你在其他地方拥有的可变文件，

1210
01:16:17,650 --> 01:16:21,430
这是个大问题吗，

1211
01:16:22,160 --> 01:16:22,880
在这种情况下，

1212
01:16:22,880 --> 01:16:25,400
我真的不明白，

1213
01:16:25,730 --> 01:16:27,980
如何确保冗余，

1214
01:16:27,980 --> 01:16:33,650
对于你可能拥有的大量可变存储。

1215
01:16:34,100 --> 01:16:38,120
是的，我认为冗余的答案可能不是那么困难，

1216
01:16:38,150 --> 01:16:40,640
我认为用户对冗余负责，

1217
01:16:41,030 --> 01:16:45,470
所以，如果你拥有 todo 列表文件，

1218
01:16:45,780 --> 01:16:48,330
你的工作是多次复制它，

1219
01:16:48,330 --> 01:16:51,810
所以 Blockstack 服务器可以为你做到这一点，

1220
01:16:52,050 --> 01:16:56,520
但你必须安排空间

1221
01:16:56,520 --> 01:17:00,540
和不同的存储提供商来做到这一点。

1222
01:17:01,450 --> 01:17:02,470
所以我认为在论文中，

1223
01:17:02,470 --> 01:17:03,040
他们谈论的是，

1224
01:17:03,040 --> 01:17:06,760
你可能复制到 Google Drive 和 S3 ，

1225
01:17:07,640 --> 01:17:10,430
可能 S3 内部也有自己的复制，

1226
01:17:10,430 --> 01:17:12,920
所以希望，也许只考虑 S3 ，

1227
01:17:12,920 --> 01:17:14,180
它应该是相当可靠的，

1228
01:17:14,890 --> 01:17:18,070
可能比将数据存储在固态硬盘上更可靠，在你的笔记本电脑上。

1229
01:17:22,080 --> 01:17:23,370
zonefile 很小，

1230
01:17:23,370 --> 01:17:24,990
所以它们被广泛复制，

1231
01:17:25,050 --> 01:17:27,900
你不必信任存储提供商。

1232
01:17:54,240 --> 01:17:55,260
还有其他想法吗？

1233
01:17:58,090 --> 01:18:00,100
我在想，这有点浪费，

1234
01:18:00,100 --> 01:18:02,440
为了注册一个名字，

1235
01:18:02,440 --> 01:18:05,350
要使用这个名字系统，你必须付费，

1236
01:18:07,440 --> 01:18:12,810
是的，所以我是在考虑基于区块链的系统，

1237
01:18:12,810 --> 01:18:14,940
你必须激励矿工，

1238
01:18:14,940 --> 01:18:18,390
但也许还有一种不同的更便宜的方式。

1239
01:18:19,600 --> 01:18:22,450
是的，我不确定，

1240
01:18:22,480 --> 01:18:25,870
在某种程度上，它是一种货币，

1241
01:18:25,870 --> 01:18:29,080
这在某种程度上是非常[]的，

1242
01:18:29,440 --> 01:18:31,480
因为你提到的原因，

1243
01:18:31,480 --> 01:18:34,270
因为你有矿工，你必须激励他们，

1244
01:18:35,060 --> 01:18:37,640
我认为总的来说，这些交易都很便宜，

1245
01:18:37,670 --> 01:18:40,190
你只需要付足够的钱，

1246
01:18:40,190 --> 01:18:43,190
矿工们愿意把你的交易包括在内，

1247
01:18:44,300 --> 01:18:46,740
你知道，在今天，

1248
01:18:46,740 --> 01:18:51,270
如果你想在 DNS 中注册一个名字，你也需要付费，

1249
01:18:51,270 --> 01:18:54,970
是相当多的钱，不是免费的，

1250
01:18:58,410 --> 01:19:00,750
我不知道经济学到底会如何运作，

1251
01:19:00,750 --> 01:19:03,870
但很明显，

1252
01:19:03,870 --> 01:19:05,640
这是一种成本更高的方式，

1253
01:19:05,670 --> 01:19:08,550
除了也许你用电力燃烧地球之外，

1254
01:19:09,430 --> 01:19:10,840
至少在比特币的例子中。

1255
01:19:10,870 --> 01:19:16,840
也许你应该使用一个权益工作账本，

1256
01:19:16,840 --> 01:19:18,880
而不是，

1257
01:19:20,360 --> 01:19:26,380
好的，权益证明而不是工作量证明账本。

1258
01:19:29,960 --> 01:19:33,740
把它替换掉是可能的，替换。

1259
01:19:33,770 --> 01:19:37,460
我想这是论文所讨论的，

1260
01:19:37,460 --> 01:19:42,290
他们的设计不是很依赖于底层的区块链，

1261
01:19:42,290 --> 01:19:44,270
他们可以很容易地切换到另一个区块链，

1262
01:19:44,270 --> 01:19:46,790
事实上，这是第二个工作的区块链，

1263
01:19:46,790 --> 01:19:49,490
他们首先使用 Namecoin ，然后改用比特币，

1264
01:19:50,120 --> 01:19:51,200
我认为论文中的论点是，

1265
01:19:51,200 --> 01:19:54,590
我们可以切换到另一个我们想使用的区块链。

1266
01:20:10,080 --> 01:20:12,540
名字历史中具体存储了什么？

1267
01:20:14,570 --> 01:20:15,260
在,

1268
01:20:16,610 --> 01:20:19,760
抱歉，问题到底是什么？

1269
01:20:20,230 --> 01:20:23,080
哦，抱歉， Blockstack 数据库中的名字历史记录。

1270
01:20:23,790 --> 01:20:24,510
是的，这个，

1271
01:20:24,510 --> 01:20:27,510
是的，我不是说这三个。

1272
01:20:28,100 --> 01:20:28,820
是的。

1273
01:20:28,820 --> 01:20:30,170
zonefile 的不同版本。

1274
01:20:31,610 --> 01:20:34,190
哦，所以就像版本号一样。

1275
01:20:34,310 --> 01:20:36,350
是的，我想是的，我不是百分之百确定，

1276
01:20:37,190 --> 01:20:37,790
但是，

1277
01:20:38,590 --> 01:20:41,560
但这些对应于 zonefile 的三个更新，

1278
01:20:41,560 --> 01:20:43,090
这是第一个，这是第二个，

1279
01:20:45,350 --> 01:20:47,630
也许他们继续使用 zonefile 的版本。

1280
01:20:59,720 --> 01:21:03,410
大家还想提出其他什么话题吗？

1281
01:21:09,300 --> 01:21:11,340
好的，我们要结束这段时间，

1282
01:21:11,760 --> 01:21:13,260
好的，让我们在这里停止，

1283
01:21:13,260 --> 01:21:15,840
所以人们需要离开就离开，

1284
01:21:15,870 --> 01:21:19,650
我希望周四能见到大家，

1285
01:21:19,650 --> 01:21:24,150
我要去看八个，我们有八个设计，八个项目，

1286
01:21:24,150 --> 01:21:28,230
八个团队将在周四展示他们所做的，

1287
01:21:28,740 --> 01:21:32,080
而不是实验 4 ，

1288
01:21:32,140 --> 01:21:35,710
项目非常酷和有趣，

1289
01:21:35,710 --> 01:21:39,220
所以希望你能从中得到乐趣，

1290
01:21:39,220 --> 01:21:41,380
这就是这节课的总结，

1291
01:21:41,380 --> 01:21:45,790
希望一点，目标就是一点[]，

1292
01:21:45,790 --> 01:21:51,160
讨论了去中心化设计，

1293
01:21:51,160 --> 01:21:53,770
可能是用户在他们的数据上，

1294
01:21:54,100 --> 01:21:58,030
我们看了 Blockstack ，

1295
01:21:58,030 --> 01:22:00,130
至少一个特定的设计，

1296
01:22:00,370 --> 01:22:02,560
他们是如何以某种方式命名的，

1297
01:22:02,560 --> 01:22:07,310
给出了全球名称，唯一名称和人类可读，

1298
01:22:08,030 --> 01:22:08,540
好的？

1299
01:22:08,630 --> 01:22:10,220
这节课到此结束，

1300
01:22:10,250 --> 01:22:11,990
希望周四能见到你，

1301
01:22:12,230 --> 01:22:13,790
将是我们最后一次课程。

1302
01:22:18,300 --> 01:22:21,510
如果你有任何问题，请随时留下来，

1303
01:22:22,290 --> 01:22:23,910
你可以谈论。

1304
01:22:24,500 --> 01:22:27,590
教授，对于演示，

1305
01:22:27,860 --> 01:22:31,190
我们是不是做一些更多的演示，

1306
01:22:31,190 --> 01:22:34,580
或者我们应该准备幻灯片，或者两者都有。

1307
01:22:34,610 --> 01:22:40,310
是的，我们贴了一些说明，

1308
01:22:42,320 --> 01:22:45,410
你可以自由地去做你想做的，

1309
01:22:45,410 --> 01:22:48,860
你想做的是说服全班同学，

1310
01:22:48,890 --> 01:22:52,340
做了什么，为什么很酷，

1311
01:22:52,950 --> 01:22:54,660
演示 demo 是个好主意，

1312
01:22:54,930 --> 01:22:57,150
你的时间不多，

1313
01:22:57,150 --> 01:22:58,920
所以我认为最典型的做法是，

1314
01:22:58,920 --> 01:23:02,250
人们有几张幻灯片来解释他们所做的，

1315
01:23:02,250 --> 01:23:03,930
然后可能还会制作 demo ，

1316
01:23:03,930 --> 01:23:05,790
看看它是如何实现的。

1317
01:23:06,980 --> 01:23:08,930
好的，好的，谢谢。

1318
01:23:11,640 --> 01:23:12,750
是的，我们不指望你，

1319
01:23:12,750 --> 01:23:15,180
在几个小时内为这个做准备，

1320
01:23:15,660 --> 01:23:18,030
试着分享你所做的。

1321
01:23:20,540 --> 01:23:23,780
好的，谢谢。

1322
01:23:25,060 --> 01:23:27,520
我只想问一下，

1323
01:23:27,670 --> 01:23:32,480
所以这是什么原因，

1324
01:23:32,720 --> 01:23:38,600
使用比特币相同的区块链，

1325
01:23:39,120 --> 01:23:44,270
把命名的交易记录放在那里，

1326
01:23:44,720 --> 01:23:47,510
再加上其他所有的东西。

1327
01:23:48,650 --> 01:23:53,870
我想这些论文，

1328
01:23:53,870 --> 01:23:56,000
他们开始在 Namecoin 上构建，

1329
01:23:56,490 --> 01:23:58,740
这是一种用于命名的特殊用途的账本，

1330
01:23:59,190 --> 01:24:03,750
他们发现了，

1331
01:24:04,380 --> 01:24:08,250
Namecoin 的安全问题，

1332
01:24:08,250 --> 01:24:11,340
其中一个是矿工并不多，

1333
01:24:12,410 --> 01:24:17,240
它观察到有一些矿工池，

1334
01:24:17,240 --> 01:24:24,940
有 50% 以上的工作容量，

1335
01:24:24,940 --> 01:24:26,950
因此可以做他们想做的任何事情，

1336
01:24:26,950 --> 01:24:28,690
到账本上，

1337
01:24:29,750 --> 01:24:34,220
所以他们在被广泛使用的区块链上，

1338
01:24:34,220 --> 01:24:36,680
不容易被对手超越。

1339
01:24:38,410 --> 01:24:41,950
好的，我记得那 51% 。

1340
01:24:42,940 --> 01:24:44,290
好的，理解了。

1341
01:24:44,680 --> 01:24:47,860
我还想问一下，

1342
01:24:48,540 --> 01:24:54,390
zonefile 存储系统的 URI ，

1343
01:24:54,390 --> 01:24:58,180
不是 S3 之类的东西。

1344
01:24:58,210 --> 01:24:58,930
可能会是，

1345
01:24:58,960 --> 01:25:01,420
问题可能更普遍，

1346
01:25:01,420 --> 01:25:07,960
因为它是由 Blockstack 文件系统解释的，

1347
01:25:07,960 --> 01:25:12,100
Blockstack 文件系统有用于不同存储提供商的后端，

1348
01:25:12,100 --> 01:25:14,890
不管是 S3 还是 Google Drive 还是什么，

1349
01:25:15,370 --> 01:25:17,830
所以有一些命名方案，

1350
01:25:17,830 --> 01:25:22,720
Blockstack 文件系统可以解释，

1351
01:25:22,720 --> 01:25:28,960
然后找出如何从正确的后端检索正确的文件。

1352
01:25:31,130 --> 01:25:33,560
这只是为了让它们变得一样。

1353
01:25:33,650 --> 01:25:37,280
是的，没错，通常应用程序编写者并不在乎，

1354
01:25:37,280 --> 01:25:39,170
无论是存储的 S3 还是 Google Drive ，

1355
01:25:39,170 --> 01:25:41,660
或者[]必须处理这个。

1356
01:25:43,180 --> 01:25:44,650
非常感谢。

1357
01:25:45,860 --> 01:25:46,460
不用谢。

1358
01:25:47,350 --> 01:25:48,250
我有一个问题，

1359
01:25:48,250 --> 01:25:52,300
为什么 Zooko 三角是，

1360
01:25:52,930 --> 01:25:54,430
我认为人们想的很多，

1361
01:25:54,430 --> 01:25:59,590
似乎你可以有一个客户端来解释人类没有意义的数据，

1362
01:25:59,950 --> 01:26:02,050
你可以让所有的数据对人类有意义，

1363
01:26:02,260 --> 01:26:04,450
在客户端侧到用户，

1364
01:26:04,830 --> 01:26:07,740
所以我不能完全确定，

1365
01:26:08,780 --> 01:26:11,000
这里的创新之处是什么，

1366
01:26:11,000 --> 01:26:14,660
或者为什么这是一种权衡。

1367
01:26:15,410 --> 01:26:19,010
是的，我想这是，我能给你的最好的幻灯片，

1368
01:26:19,010 --> 01:26:21,050
我能给你举一大堆命名的例子，

1369
01:26:21,050 --> 01:26:22,820
三个中的两个，但不是所有的三个，

1370
01:26:23,680 --> 01:26:27,610
例如，

1371
01:26:27,610 --> 01:26:32,420
我们讨论过 Keybase ，

1372
01:26:32,420 --> 01:26:36,350
去中心化的，不是唯一的，

1373
01:26:38,680 --> 01:26:39,730
现在你会争论，

1374
01:26:39,730 --> 01:26:42,130
什么时候拥有全球唯一的名称很重要，

1375
01:26:42,710 --> 01:26:44,750
一个全球唯一的名字，

1376
01:26:44,750 --> 01:26:46,700
比如 6.824 是什么意思，

1377
01:26:47,780 --> 01:26:49,040
以及与之相关的人，

1378
01:26:49,160 --> 01:26:50,690
所以如果你是从那个角度来看，

1379
01:26:50,690 --> 01:26:52,040
我认为这是一个非常合理的问题。

1380
01:26:57,190 --> 01:26:57,670
谢谢。

1381
01:26:59,940 --> 01:27:03,180
有一件事一直困扰着我，

1382
01:27:03,180 --> 01:27:06,090
当我们读这些区块链类型的论文时，

1383
01:27:06,270 --> 01:27:08,160
比如一百年后会发生什么，

1384
01:27:08,160 --> 01:27:12,120
当账本得到数万亿，

1385
01:27:12,240 --> 01:27:15,120
数万亿字节或什么东西。

1386
01:27:18,320 --> 01:27:19,010
嗯。

1387
01:27:19,010 --> 01:27:21,230
我们是不是没有避免方案，

1388
01:27:21,230 --> 01:27:22,730
接下来会发生什么？

1389
01:27:23,620 --> 01:27:25,210
我不知道，

1390
01:27:26,490 --> 01:27:30,510
很难推测未来的一百年，

1391
01:27:30,690 --> 01:27:32,010
我想，你可以做的，

1392
01:27:32,010 --> 01:27:34,110
所以你设置一个检查点，

1393
01:27:34,620 --> 01:27:38,340
是的，我能想象出多种摆脱困境的方案，

1394
01:27:38,340 --> 01:27:41,800
一个你可以在状态设置一个检查点，

1395
01:27:41,800 --> 01:27:43,120
建立在账本上，

1396
01:27:43,120 --> 01:27:46,210
并将检查点的哈希值包括到帐本中，

1397
01:27:46,210 --> 01:27:50,530
然后，只要你可以广泛复制检查点，

1398
01:27:50,950 --> 01:27:53,560
然后你可以从检查点开始运行，

1399
01:27:53,560 --> 01:27:54,580
截去开头的部分，

1400
01:27:55,300 --> 01:27:57,550
这与你在实验中做的一样，

1401
01:27:57,790 --> 01:27:59,320
Raft 所做的。

1402
01:28:01,370 --> 01:28:04,640
这样做的一方是必须得到信任还是？

1403
01:28:05,830 --> 01:28:08,920
我们所做的，

1404
01:28:10,790 --> 01:28:13,220
想必客户 1 必须跟着走，

1405
01:28:14,380 --> 01:28:17,200
意识到他们到达那个检查点，

1406
01:28:17,200 --> 01:28:20,020
你将能够构建世界的当前状态，

1407
01:28:20,880 --> 01:28:24,690
我假设这需要一些关键的改变，可能需要一些分叉。

1408
01:28:28,990 --> 01:28:30,520
这不是什么大问题，

1409
01:28:31,180 --> 01:28:32,320
通常比特币的汇率，

1410
01:28:32,320 --> 01:28:33,940
因为交易数量，

1411
01:28:33,940 --> 01:28:36,610
每秒钟你可以做的很少，

1412
01:28:37,090 --> 01:28:38,650
如果你还记得比特币论文上的内容，

1413
01:28:38,650 --> 01:28:42,160
有一些计算，比如总的大小是多少，

1414
01:28:42,190 --> 01:28:43,000
如果你这样做，

1415
01:28:43,550 --> 01:28:47,480
另外，你还记得在比特币论文上，

1416
01:28:47,480 --> 01:28:48,680
有很多优化，

1417
01:28:48,920 --> 01:28:54,290
你不必记住每一枚币的每一笔交易，

1418
01:28:54,290 --> 01:28:57,770
你必须记住每一枚币的最后一笔交易，

1419
01:28:58,100 --> 01:28:59,240
你可以这样做，

1420
01:28:59,240 --> 01:29:03,600
只记住区块头而不是完整的区块，

1421
01:29:06,970 --> 01:29:09,670
所以，比特币对这个问题有某种内置的解决方案。

1422
01:29:10,860 --> 01:29:15,180
我明白了，所以主要的瓶颈是当新机器出现时，

1423
01:29:15,180 --> 01:29:16,800
它们需要验证[]，

1424
01:29:17,130 --> 01:29:21,030
但在那之后，事情就相对更优化了。

1425
01:29:23,170 --> 01:29:23,710
谢谢。

1426
01:29:35,760 --> 01:29:37,050
好的，这就是今天的，

1427
01:29:39,270 --> 01:29:40,620
谢谢大家，周四见。

