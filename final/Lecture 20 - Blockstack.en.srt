1
00:00:00,120 --> 00:00:00,840
Okay, thank you.

2
00:00:01,820 --> 00:00:03,350
Okay, so that's,

3
00:00:03,350 --> 00:00:05,720
good afternoon, good morning, good evening, good night,

4
00:00:05,720 --> 00:00:06,410
wherever you are,

5
00:00:06,530 --> 00:00:10,580
and I guess welcome to the last week of the semester,

6
00:00:10,880 --> 00:00:12,650
so there's two more class meetings,

7
00:00:12,950 --> 00:00:15,440
today which we're gonna be talking about Blockstack,

8
00:00:15,980 --> 00:00:21,800
and on Thursday, we we get a report from a different projects,

9
00:00:21,800 --> 00:00:24,800
from the number of the project groups in 6.824.

10
00:00:25,590 --> 00:00:29,670
And so, today is basically the last paper discussion.

11
00:00:30,950 --> 00:00:33,560
So the topic is,

12
00:00:33,560 --> 00:00:37,340
you know the system that we're assigned for,

13
00:00:37,520 --> 00:00:39,020
assigned for reading, which is Blockstack,

14
00:00:39,940 --> 00:00:43,180
and really Blockstack that represents is

15
00:00:43,180 --> 00:00:50,210
an approach to building decentralized applications,

16
00:00:53,570 --> 00:00:56,840
and with decentralized, what we mean here is that,

17
00:00:57,110 --> 00:01:00,680
unlike centralized websites, that sort of website owns the data,

18
00:01:00,680 --> 00:01:03,080
and decentralized application, application,

19
00:01:03,080 --> 00:01:05,300
the system is set up in a way,

20
00:01:05,300 --> 00:01:09,200
that the users actually keep control over the data and not the website.

21
00:01:09,750 --> 00:01:12,750
So this form sort of a trend, in the last,

22
00:01:12,750 --> 00:01:17,790
is the final lecture series of three lectures on decentralized distributed systems,

23
00:01:17,790 --> 00:01:22,260
we talk about logs and signing or sign log

24
00:01:22,260 --> 00:01:25,590
is a way of constructing this decentralized log storage systems,

25
00:01:25,650 --> 00:01:29,010
we saw Bitcoin to see as an example of,

26
00:01:29,010 --> 00:01:33,360
how you can achieve consensus in decentralized systems

27
00:01:33,360 --> 00:01:36,420
with untrusted participants or Byzantine participants.

28
00:01:36,750 --> 00:01:39,360
And so today we're taking one more step up

29
00:01:39,360 --> 00:01:42,810
and actually look at how you can actually build complete applications

30
00:01:42,870 --> 00:01:45,930
other than just crypto currency applications.

31
00:01:47,010 --> 00:01:48,960
The decentralized application has a long history,

32
00:01:49,260 --> 00:01:53,250
in the early 2000, late 90s,

33
00:01:53,250 --> 00:01:56,550
there was a lot to do around peer-to-peer applications,

34
00:01:57,090 --> 00:02:01,650
which had a decentralized architecture, Napster,

35
00:02:01,650 --> 00:02:05,400
you know more recently you know probably familiar with Keybase,

36
00:02:05,790 --> 00:02:07,980
which has a decentralized design,

37
00:02:08,070 --> 00:02:09,900
or Solid,

38
00:02:10,020 --> 00:02:12,840
you know and of course Blockstack,

39
00:02:13,110 --> 00:02:15,720
so there's you know quite a bit of activity,

40
00:02:15,720 --> 00:02:18,300
in this space of decentralized applications.

41
00:02:19,200 --> 00:02:21,690
The Blockstack is interesting,

42
00:02:21,720 --> 00:02:24,930
from from the perspective of decentralized applications,

43
00:02:25,230 --> 00:02:29,130
but also is an example of sort of a non-currency use

44
00:02:29,160 --> 00:02:36,510
non-money use of Bitcoin of the blockchain, the Bitcoin blockchain.

45
00:02:44,990 --> 00:02:46,880
And we'll see,

46
00:02:46,880 --> 00:02:50,180
you know there are a number of aspects, that are interesting to Blockstack,

47
00:02:50,180 --> 00:02:54,650
but the key thing that the paper focuses on is actually naming,

48
00:02:54,830 --> 00:02:59,630
how to sort of build a distributed decentralized naming system.

49
00:03:00,080 --> 00:03:02,810
And of course the naming systems are widely used,

50
00:03:02,810 --> 00:03:04,280
you know think of DNS,

51
00:03:04,280 --> 00:03:07,880
think about where you know Kerberos,

52
00:03:07,880 --> 00:03:11,060
you know there's tons and tons of different naming systems

53
00:03:11,060 --> 00:03:12,350
out there you know widely used,

54
00:03:12,560 --> 00:03:13,940
and this is just a different design,

55
00:03:13,940 --> 00:03:17,090
where the most interesting part of it, again is it's decentralized.

56
00:03:22,180 --> 00:03:24,580
You know this lecture is a little bit different

57
00:03:24,580 --> 00:03:27,700
than the preceding lectures or many of the preceding lectures,

58
00:03:27,700 --> 00:03:29,770
many preceding lectures sort of have to flavor,

59
00:03:29,770 --> 00:03:31,120
here's a hard technical problem,

60
00:03:31,210 --> 00:03:33,520
here's the solution to solve that particular problem,

61
00:03:34,000 --> 00:03:37,210
and here we are in a slightly sort of different position,

62
00:03:37,390 --> 00:03:39,370
there's a hard technical problem,

63
00:03:39,370 --> 00:03:41,320
that we have to build decentralized applications,

64
00:03:41,560 --> 00:03:44,470
but it's not, you know a hundred percent clear,

65
00:03:44,470 --> 00:03:47,260
there's exactly the right thing to do to build decentralized applications

66
00:03:47,260 --> 00:03:48,700
and is extremely [],

67
00:03:49,210 --> 00:03:53,620
and it's not clear like Blockstack is just the right solution to do so,

68
00:03:54,310 --> 00:03:56,680
and so it's much more experimental,

69
00:03:56,740 --> 00:03:59,800
Blockstack does actually have a user community,

70
00:03:59,800 --> 00:04:03,520
and but it's not yet an overwhelming success,

71
00:04:03,520 --> 00:04:06,520
and a demonstration that this is a right way to go.

72
00:04:06,550 --> 00:04:09,400
So in that sense,

73
00:04:09,790 --> 00:04:13,420
this is a paper in some sense more thought provoking,

74
00:04:13,690 --> 00:04:18,010
than giving actually a definite answer to a particular technical problem.

75
00:04:18,130 --> 00:04:24,010
And so, some ways you know this is more of topic is sort of,

76
00:04:24,010 --> 00:04:30,010
lends ourself to a debate about you know different views on this kind of, kind of design.

77
00:04:30,490 --> 00:04:32,560
So when during lecture,

78
00:04:32,560 --> 00:04:36,040
if we get, to be preferred to find actually,

79
00:04:36,040 --> 00:04:39,460
to have quite a bit of discussion different aspects,

80
00:04:39,460 --> 00:04:41,530
and I don't think there's going to be one right answer.

81
00:04:43,120 --> 00:04:46,660
And so anytime you have a question about

82
00:04:46,660 --> 00:04:50,560
or what are you about a particular aspect of these decentralized app designs,

83
00:04:50,560 --> 00:04:51,880
you know speak up.

84
00:04:54,460 --> 00:05:00,190
Okay, so maybe before you know talking about decentralized apps,

85
00:05:00,190 --> 00:05:01,660
you know just quickly revisit

86
00:05:01,780 --> 00:05:03,670
you know actually what sort of an common paradigm

87
00:05:03,670 --> 00:05:06,100
to actually build websites or build web applications, right.

88
00:05:06,100 --> 00:05:09,620
That is really using centralized websites,

89
00:05:13,170 --> 00:05:16,890
sites may itself might be distributed across multiple data centers across the world,

90
00:05:17,070 --> 00:05:20,160
but the architecture of the design the site is centralized,

91
00:05:20,160 --> 00:05:24,240
where we have, you know here's typical website,

92
00:05:24,750 --> 00:05:27,090
it has some applications in the code,

93
00:05:27,090 --> 00:05:31,470
whatever you know Gmail, whatever Twitter Facebook,

94
00:05:31,770 --> 00:05:35,880
and that operates on a database,

95
00:05:36,600 --> 00:05:39,180
that contains you know user data.

96
00:05:42,890 --> 00:05:44,930
Then we might actually has different users

97
00:05:44,930 --> 00:05:51,710
interacting with sitting by a web browser and U1, U2,

98
00:05:52,040 --> 00:05:55,400
they interact through the application to the website,

99
00:05:55,400 --> 00:05:58,820
you know they create data, they stored in the database,

100
00:05:59,060 --> 00:06:01,340
other users may view the data,

101
00:06:01,400 --> 00:06:06,290
and the application displays basically that data to inside of the web browser.

102
00:06:06,940 --> 00:06:18,900
And you know the data might be a blog posts, tweets, Piazza posts, photos,

103
00:06:20,700 --> 00:06:27,620
perhaps even more sort of sensitive, medical records, medical records, etc.

104
00:06:29,910 --> 00:06:32,280
And basically you know the application we're running on the site

105
00:06:32,280 --> 00:06:35,280
to transform that data from all the different users,

106
00:06:35,400 --> 00:06:37,740
into something that interesting to look at,

107
00:06:37,740 --> 00:06:41,910
where basically integrating for example the timeline of many users

108
00:06:41,910 --> 00:06:45,090
into a single timeline present to the user,

109
00:06:45,090 --> 00:06:46,440
you know we're going to tweets

110
00:06:46,440 --> 00:06:49,200
you know do ups and downloads, etc, etc.

111
00:06:50,070 --> 00:06:56,250
And you know one sort of distinguishing feature of this design is that,

112
00:06:56,430 --> 00:06:58,410
the application of the data are bundled,

113
00:06:58,410 --> 00:07:01,440
they are only the control of the application site,

114
00:07:01,440 --> 00:07:04,620
whether it's Facebook Twitter or Google or any website,

115
00:07:04,620 --> 00:07:06,780
and really the interface between the user

116
00:07:06,780 --> 00:07:11,210
or the dividing line between the user and the website

117
00:07:11,210 --> 00:07:13,700
is basically you know html or the UI,

118
00:07:17,580 --> 00:07:21,210
and the application basically computes you know whatever a user going to see,

119
00:07:21,210 --> 00:07:23,130
and that's going to be displayed inside the browser,

120
00:07:23,520 --> 00:07:26,400
of course, the application might actually run inside of the browser,

121
00:07:26,490 --> 00:07:27,900
you know like Javascript,

122
00:07:27,900 --> 00:07:30,960
but actually not really pertinent to this particular discussion,

123
00:07:31,230 --> 00:07:35,040
you know it's still the application is under control of the website,

124
00:07:35,040 --> 00:07:37,560
you know the programmers of the website write the application,

125
00:07:37,830 --> 00:07:40,650
and the application basically manipulates the DOM,

126
00:07:40,680 --> 00:07:42,540
fill from inside of the web browser.

127
00:07:43,270 --> 00:07:44,800
And so from the user point of view,

128
00:07:45,040 --> 00:07:48,160
interaction, interface you know between the,

129
00:07:48,160 --> 00:07:54,940
defining interface between website and and the browser still sort of html.

130
00:07:57,720 --> 00:08:01,560
And so this kind of design clearly is overwhelmingly successful,

131
00:08:01,800 --> 00:08:04,830
you know most websites probably,

132
00:08:04,830 --> 00:08:07,140
that's probably all of the websites you probably use

133
00:08:07,140 --> 00:08:09,780
are sort of following this particular design.

134
00:08:10,570 --> 00:08:14,560
And one reason for you know this very successful design is,

135
00:08:14,560 --> 00:08:15,790
we'll talk a little bit more later is,

136
00:08:15,910 --> 00:08:18,880
because of the tight integration between the application and the data

137
00:08:18,880 --> 00:08:20,290
and the data from the user,

138
00:08:20,290 --> 00:08:24,610
so the application is easy access to all the user data from different users

139
00:08:24,610 --> 00:08:26,860
and integrate it, to make creative and interesting ways.

140
00:08:27,490 --> 00:08:32,410
But there are you know it's not completely perfect, you know this designing,

141
00:08:32,410 --> 00:08:36,850
sort of things, that you might you might wish could be slightly better.

142
00:08:37,650 --> 00:08:38,940
And in some sense,

143
00:08:38,940 --> 00:08:42,480
decentralized applications is a is a response to those sort of things,

144
00:08:42,480 --> 00:08:45,060
that not might be one hundred percent desirable.

145
00:08:45,860 --> 00:08:49,250
And so for one, there's a very simple observation,

146
00:08:49,250 --> 00:08:51,620
you can really not create another application,

147
00:08:51,950 --> 00:08:55,340
so the site decides actually how the app looks like,

148
00:08:55,340 --> 00:08:57,140
you know that's the UI you're gonna get,

149
00:08:57,560 --> 00:09:01,610
and which is sort of very different than,

150
00:09:01,700 --> 00:09:05,930
let's see, your own application on your laptop, for example,

151
00:09:05,930 --> 00:09:08,450
you want to modify, edit a text file,

152
00:09:08,600 --> 00:09:11,270
but you get to choose which browser or editor you're gonna use,

153
00:09:11,270 --> 00:09:13,700
you know what are you gonna use Emacs, you know Vim,

154
00:09:13,700 --> 00:09:15,380
you know all kinds of culture wars

155
00:09:15,380 --> 00:09:16,790
about which one is better than the other,

156
00:09:16,970 --> 00:09:20,120
but you get an option to choose which one you want to use.

157
00:09:20,450 --> 00:09:22,250
And in this case, you know that's just not the case,

158
00:09:22,250 --> 00:09:24,110
you're using Gmail,

159
00:09:25,730 --> 00:09:26,990
Gmail is not the best example,

160
00:09:26,990 --> 00:09:27,530
but Twitter,

161
00:09:27,530 --> 00:09:30,110
you know Twitter is going to decide actually how the application is going to look like,

162
00:09:31,420 --> 00:09:33,220
the reason why Gmail might not be the best example is,

163
00:09:33,220 --> 00:09:36,220
because you can actually download your email maybe you know through IMAP,

164
00:09:36,220 --> 00:09:39,040
and then run your own email program,

165
00:09:39,340 --> 00:09:40,630
but for many websites,

166
00:09:40,630 --> 00:09:43,000
you know the user application data very control,

167
00:09:43,000 --> 00:09:44,410
that you have no control over it.

168
00:09:47,040 --> 00:09:52,290
The website you know may change the rules on who can see what data,

169
00:09:52,470 --> 00:09:54,870
and it might actually do without really telling you,

170
00:09:54,960 --> 00:09:59,250
and so you don't have full control over actually who, who sees your data,

171
00:09:59,460 --> 00:10:04,500
furthermore, the website actually might use it, you know your data to generate revenue,

172
00:10:04,500 --> 00:10:07,620
whatever decide which ads actually display,

173
00:10:07,620 --> 00:10:11,220
and you know basically snooping over your data, right,

174
00:10:11,760 --> 00:10:14,430
or in the worse case, maybe a bad employee,

175
00:10:14,430 --> 00:10:16,620
it actually it just snoop over your data.

176
00:10:17,300 --> 00:10:19,130
And that's really sort of outside of your control,

177
00:10:19,130 --> 00:10:20,750
there's nothing really you can do about it,

178
00:10:20,750 --> 00:10:23,090
you gave the website the data, it's theirs now.

179
00:10:24,230 --> 00:10:29,840
And so this is sort of sort of pain points,

180
00:10:29,840 --> 00:10:31,280
you know it makes people wonder,

181
00:10:31,280 --> 00:10:34,310
you know is a way of designing systems,

182
00:10:34,520 --> 00:10:37,970
that are really not, don't follow this paradigm,

183
00:10:37,970 --> 00:10:40,640
but follow the paradigm of decentralized applications.

184
00:10:55,970 --> 00:10:59,420
And so in in this world view,

185
00:10:59,630 --> 00:11:02,060
we're still in our Internet cloud,

186
00:11:02,090 --> 00:11:04,520
but you know we have storage providers,

187
00:11:05,850 --> 00:11:12,540
and storage providers are basically nothing really sophisticated word,

188
00:11:12,840 --> 00:11:14,400
they don't really rung app code,

189
00:11:14,640 --> 00:11:16,710
they just purely provide storage,

190
00:11:16,800 --> 00:11:22,740
ways of maybe it's like Google drive or whatever or Amazon S3,

191
00:11:22,860 --> 00:11:26,760
but basically they're sort of [] you know big holders,

192
00:11:27,730 --> 00:11:31,000
the data maybe you know users probably want to encrypt data,

193
00:11:31,120 --> 00:11:33,430
but this is what the real goal here is that,

194
00:11:33,430 --> 00:11:36,820
the user decides you know which store for where the data lives,

195
00:11:37,120 --> 00:11:38,770
and it keeps them under control of the user,

196
00:11:39,360 --> 00:11:41,070
so whatever you know storage provider,

197
00:11:41,310 --> 00:11:43,590
S3 might have you know user 1 data,

198
00:11:46,970 --> 00:11:49,460
another store provider might actually have U2's data,

199
00:11:49,460 --> 00:11:52,820
or stores you know data [] of U2,

200
00:11:53,090 --> 00:11:55,700
U2 and user may actually encrypt it,

201
00:11:55,700 --> 00:11:57,860
so that the storage provider can actually not read it,

202
00:12:00,170 --> 00:12:03,200
and control like who can actually decrypt the data.

203
00:12:03,680 --> 00:12:10,250
And then you know the applications really are in control of the user themselves,

204
00:12:10,520 --> 00:12:12,530
so you know might user here,

205
00:12:13,070 --> 00:12:17,300
U1 workstation or laptop, it runs an application,

206
00:12:18,600 --> 00:12:21,630
and you know here's U2,

207
00:12:22,640 --> 00:12:25,880
there's also another application may actually looking at maybe the same data,

208
00:12:25,880 --> 00:12:28,070
but like a slightly different version of the application,

209
00:12:28,070 --> 00:12:31,160
whatever one photo viewer and another photo viewer,

210
00:12:32,080 --> 00:12:36,940
and basically to construct you knows what is actually shown to the user,

211
00:12:37,090 --> 00:12:41,470
that the application will fetches data you know from different users,

212
00:12:41,470 --> 00:12:45,910
for example, U2 share the photos with U1,

213
00:12:46,120 --> 00:12:50,860
then the applications to integrate the photos U1 to U2,

214
00:12:50,980 --> 00:12:58,030
by extracting or retrieving the, the photos from the different storage providers.

215
00:12:58,660 --> 00:13:02,290
And here really what the sort of dividing line is between users

216
00:13:02,620 --> 00:13:08,170
and the dividing line is is really this,

217
00:13:09,830 --> 00:13:12,410
there's sort of a dividing line between the application and storage,

218
00:13:12,410 --> 00:13:14,630
and so there's a storage API,

219
00:13:15,770 --> 00:13:17,660
you have sort of the uniform,

220
00:13:17,660 --> 00:13:21,140
because there are many different applications are going to use the same storage API,

221
00:13:21,140 --> 00:13:23,630
you know maybe this application it creates todo list,

222
00:13:24,020 --> 00:13:25,760
maybe it's a photo list,

223
00:13:25,760 --> 00:13:28,280
maybe it's a Twitter clone,

224
00:13:28,280 --> 00:13:30,470
this retrives tweets from different users

225
00:13:30,470 --> 00:13:33,020
and integrates them and present them to the user.

226
00:13:33,580 --> 00:13:38,830
And it's really that sort of single storage API,

227
00:13:38,830 --> 00:13:42,460
and that actually provides you know the dividing line

228
00:13:42,460 --> 00:13:45,820
between the applications and the data,

229
00:13:46,550 --> 00:13:48,710
of course, that storage API has to be quite general purpose,

230
00:13:48,710 --> 00:13:50,180
can support multiple applications,

231
00:13:50,210 --> 00:13:51,920
but also has to allow sharing

232
00:13:51,920 --> 00:13:55,490
between different, between different users and different applications,

233
00:13:55,610 --> 00:13:57,260
the module or the permissions.

234
00:13:59,210 --> 00:14:06,380
And so let's say you wanted to build sort of you know todo list,

235
00:14:12,560 --> 00:14:15,260
then you know between U1 and U2,

236
00:14:15,260 --> 00:14:19,010
then let's look at this from the perspective of U1,

237
00:14:19,250 --> 00:14:21,350
you know probably there would be some operation

238
00:14:21,440 --> 00:14:24,290
or some sharing operations between U2 and U1,

239
00:14:24,290 --> 00:14:28,340
saying like yeah, you know the names of the my todo list,

240
00:14:28,640 --> 00:14:34,730
and you know U1 can then download you know the U2's todo list,

241
00:14:35,030 --> 00:14:38,690
maybe check you know the signature on the file

242
00:14:38,690 --> 00:14:41,810
to verify the data was indeed written by U2

243
00:14:42,230 --> 00:14:44,390
and then you know integrate you know that,

244
00:14:44,420 --> 00:14:47,060
we have it's own todo list,

245
00:14:47,060 --> 00:14:50,270
and present the U1 or share todo list,

246
00:14:50,270 --> 00:14:53,630
that contains both U1's and U2's todo items.

247
00:14:56,420 --> 00:14:59,780
Sort of sort of the general view

248
00:14:59,780 --> 00:15:04,970
of actually buildings decentralized architecture for applications.

249
00:15:07,010 --> 00:15:08,120
Any questions so far?

250
00:15:21,330 --> 00:15:23,460
Okay, so so far,

251
00:15:23,460 --> 00:15:24,750
we've hopefully received you know

252
00:15:24,750 --> 00:15:30,540
this addresses one of the major you know pain point for the centralized approach,

253
00:15:30,570 --> 00:15:33,750
that basically the users you know still in control of the data,

254
00:15:33,750 --> 00:15:36,060
it's not owned by a particular site anymore,

255
00:15:36,060 --> 00:15:38,520
and users decide who,

256
00:15:38,520 --> 00:15:41,370
which applications and who actually get access to data,

257
00:15:42,120 --> 00:15:45,720
I think those are desirable property.

258
00:15:46,330 --> 00:15:50,860
But you know the this whole design is also with its unique set of challenges,

259
00:15:50,980 --> 00:15:52,930
and so let me lay out some of them,

260
00:15:53,170 --> 00:15:56,260
and we'll focus on a few of them in the context of Blockstack.

261
00:16:01,010 --> 00:16:04,520
And so there's sort of two [] broad categories of challenges,

262
00:16:04,730 --> 00:16:06,770
one sort of on the business side,

263
00:16:07,190 --> 00:16:08,510
what is the revenue model,

264
00:16:10,700 --> 00:16:15,260
you know one will get these applications actually being adopted,

265
00:16:15,260 --> 00:16:18,440
and you know pay people money to actually develop the applications,

266
00:16:18,710 --> 00:16:22,400
and so they actually become really good,

267
00:16:22,400 --> 00:16:26,720
and people are excited by using them.

268
00:16:27,320 --> 00:16:30,590
I'm not really gonna talk about that at all,

269
00:16:31,280 --> 00:16:34,400
but instead you know what I most focus on the technical challenges.

270
00:16:43,460 --> 00:16:45,590
And there's several of them,

271
00:16:46,160 --> 00:16:50,690
one is going to go back to this picture here before,

272
00:16:50,840 --> 00:16:55,160
you know the storage API sort of the key interface,

273
00:16:55,160 --> 00:16:57,830
and you know interfaces to be minimal,

274
00:16:57,830 --> 00:17:00,290
and it has to be general purpose enough,

275
00:17:00,560 --> 00:17:02,750
but in typically, it's actually,

276
00:17:02,750 --> 00:17:06,380
you know it's not the same thing as the API that sits here,

277
00:17:08,310 --> 00:17:10,560
between the application and the database.

278
00:17:11,000 --> 00:17:13,520
So let's do that, hold on a second.

279
00:17:41,280 --> 00:17:44,250
Okay, hopefully everyone can seen screen of board again?

280
00:17:44,400 --> 00:17:44,850
Good.

281
00:17:48,000 --> 00:17:50,730
The, so there's a couple of challenges,

282
00:17:50,730 --> 00:17:52,260
you know what I was going to point out is,

283
00:17:52,260 --> 00:17:55,710
that storage API is typically not as powerful,

284
00:17:55,890 --> 00:18:00,180
where that file system API is not as powerful as SQL,

285
00:18:01,740 --> 00:18:06,420
and futhermore, you know not all the data,

286
00:18:06,420 --> 00:18:09,330
sort of all uses like handy in a single place,

287
00:18:09,330 --> 00:18:11,790
you can run arbitrary queries on,

288
00:18:11,910 --> 00:18:15,090
to integrate it in whatever application specific manners.

289
00:18:15,840 --> 00:18:18,030
Yeah, so that's sort of a challenge,

290
00:18:18,030 --> 00:18:21,090
that applications rely on the power

291
00:18:21,300 --> 00:18:24,480
of being able to run arbitrary queries over all the user data,

292
00:18:24,480 --> 00:18:26,790
that is in decentralized application will be harder to achieve,

293
00:18:26,790 --> 00:18:30,780
because the data is spread out over many maybe different storage servers.

294
00:18:31,780 --> 00:18:34,270
There's also features that might be harder to implement,

295
00:18:34,600 --> 00:18:39,160
like for example if you want implement like eBay,

296
00:18:39,190 --> 00:18:45,190
then usually have to submit sort of bids,

297
00:18:45,190 --> 00:18:47,680
but you know we want to download those bids immediately,

298
00:18:47,950 --> 00:18:50,890
so there has to be some trusted aspect

299
00:18:50,890 --> 00:18:52,540
to that actually integrates these bids,

300
00:18:52,540 --> 00:18:54,520
and then decides you know actually who's the winner,

301
00:18:55,160 --> 00:18:58,880
without disclosing those beforehand.

302
00:18:59,030 --> 00:19:03,740
Similarly, there's challenges around management,

303
00:19:03,890 --> 00:19:09,290
typically these decentralized applications, you know involve crypto keys,

304
00:19:11,230 --> 00:19:15,850
and so, there has to be sort of you know that's often a [] scenario,

305
00:19:16,120 --> 00:19:17,800
some user loses their private key,

306
00:19:17,800 --> 00:19:21,550
and then you know you can't use your, can't get your data anymore,

307
00:19:21,970 --> 00:19:24,970
and or somebody actually steals your private key

308
00:19:24,970 --> 00:19:27,040
and then they can get your data.

309
00:19:27,940 --> 00:19:31,480
So there's a series of technical challenge,

310
00:19:31,480 --> 00:19:33,670
you know to make this actually work,

311
00:19:33,910 --> 00:19:36,340
and one of them, the one remaining one,

312
00:19:36,340 --> 00:19:39,010
which is mostly the topic of this lecture is naming.

313
00:19:42,740 --> 00:19:46,070
So sort of broader challenges are basically,

314
00:19:46,070 --> 00:19:50,240
I think you know challenge for any sort of decentralized application infrastructure,

315
00:19:50,450 --> 00:19:53,900
and certainly also in the context of Blockstack,

316
00:19:54,200 --> 00:19:55,700
but in the case of Blockstack,

317
00:19:55,730 --> 00:19:59,120
we're gone mostly you know we'll see actually the importance of names

318
00:19:59,270 --> 00:20:02,330
and why naming actually is a challenge.

319
00:20:03,380 --> 00:20:05,030
Okay, so before continue,

320
00:20:05,030 --> 00:20:06,770
I just want to stop here for a second,

321
00:20:06,770 --> 00:20:09,050
just sort of give people trying to ask any questions

322
00:20:09,050 --> 00:20:14,300
to contrast sort of these two different ways of building applications,

323
00:20:14,300 --> 00:20:17,120
whether it's centralized as in sort of traditional model,

324
00:20:17,120 --> 00:20:18,530
that we're probably all familiar with,

325
00:20:18,950 --> 00:20:21,860
or this decentralized model.

326
00:20:22,890 --> 00:20:25,380
So what's the challenge exactly with bids?

327
00:20:26,600 --> 00:20:27,620
So which is the challenge?

328
00:20:28,230 --> 00:20:29,100
With bids.

329
00:20:30,200 --> 00:20:33,920
Oh, you know you need an,

330
00:20:33,920 --> 00:20:36,290
application needs to have access to the user bids,

331
00:20:36,530 --> 00:20:39,470
but shouldn't disclose them, right, to other applications

332
00:20:39,500 --> 00:20:41,150
and so that means that,

333
00:20:41,540 --> 00:20:44,540
the application that looks like,

334
00:20:44,540 --> 00:20:46,730
I'm U1, I'm submitting a bid,

335
00:20:47,000 --> 00:20:48,830
I get U2's bid,

336
00:20:48,920 --> 00:20:51,920
but my application isn't really to close U2's bid immediately to me,

337
00:20:51,920 --> 00:20:53,240
because it wouldn't be fair,

338
00:20:53,790 --> 00:20:55,530
and so how would you do that,

339
00:20:55,530 --> 00:20:59,310
so you just perform with a trusted party or whatever some protocol,

340
00:20:59,310 --> 00:21:00,300
that actually makes that happen.

341
00:21:03,700 --> 00:21:04,210
Thank you.

342
00:21:06,840 --> 00:21:08,940
If the application runs your models on your workstation,

343
00:21:08,940 --> 00:21:10,920
you can modify the work, the application, right.

344
00:21:14,080 --> 00:21:17,830
Sorry, in the previous slide, I think you mentioned also,

345
00:21:18,490 --> 00:21:20,290
app one being different from,

346
00:21:20,320 --> 00:21:23,680
like the two apps being different,

347
00:21:24,150 --> 00:21:25,770
what do you mean exactly?

348
00:21:25,920 --> 00:21:28,590
Well, example, just made the analogy is very crisp,

349
00:21:28,590 --> 00:21:31,510
this could be Vim, this could be Emacs,

350
00:21:31,900 --> 00:21:33,820
and U1 U2 get to decide

351
00:21:33,820 --> 00:21:37,570
which applications are going to use to actually modify their data, right,

352
00:21:38,350 --> 00:21:41,380
and you know today in a centralized model,

353
00:21:41,440 --> 00:21:42,880
and that not really possible,

354
00:21:42,910 --> 00:21:45,520
you know you can't have basically two Twitter apps,

355
00:21:45,520 --> 00:21:47,800
where U1 one way of interacting with the Twitter app

356
00:21:47,800 --> 00:21:49,570
and somebody else you know do it in a different way,

357
00:21:50,970 --> 00:21:52,290
that's just do Twitter app.

358
00:21:53,230 --> 00:21:54,310
I see, thank you.

359
00:21:54,960 --> 00:22:00,810
I I had a question just about the design of the decentralized like model,

360
00:22:00,900 --> 00:22:04,590
is it necessary for the app to be like a client side

361
00:22:04,590 --> 00:22:05,580
or could you know,

362
00:22:05,640 --> 00:22:11,220
could you have like these like the centralized apps on the Internet sign.

363
00:22:11,340 --> 00:22:13,290
You can have in principle the Internet,

364
00:22:13,290 --> 00:22:14,610
like the key issue,

365
00:22:14,610 --> 00:22:16,950
it doesn't really have to run on the user's workstation,

366
00:22:17,670 --> 00:22:18,480
can run anywhere,

367
00:22:18,540 --> 00:22:20,100
but it is on the users control,

368
00:22:21,170 --> 00:22:22,400
of course, if somebody writes it,

369
00:22:22,550 --> 00:22:25,940
but the user gets to decide which app to run over what data.

370
00:22:26,830 --> 00:22:30,700
Right, so the so so the important thing here is, is that,

371
00:22:30,940 --> 00:22:34,150
you know app choose you, you should choose the app,

372
00:22:34,150 --> 00:22:37,780
and importantly the app has access to any storage provider.

373
00:22:40,100 --> 00:22:40,610
Thanks.

374
00:22:46,130 --> 00:22:47,450
Okay, any other questions?

375
00:22:52,240 --> 00:22:54,280
Okay, so names,

376
00:22:54,810 --> 00:22:57,540
so this is getting a little bit more into Blockstack.

377
00:23:08,070 --> 00:23:12,630
And then let me sort of layout like the role the names play,

378
00:23:12,900 --> 00:23:14,760
first of all, you have todo list,

379
00:23:14,760 --> 00:23:16,290
and you want to share it with somebody else,

380
00:23:16,290 --> 00:23:18,780
you know have to be able to name that user for whom you're sharing,

381
00:23:19,650 --> 00:23:22,170
and so there's a sort of mapping from name to user,

382
00:23:24,040 --> 00:23:25,210
that's an important role,

383
00:23:25,900 --> 00:23:29,710
there's mapping for name to location of data.

384
00:23:35,990 --> 00:23:37,490
So if my todo list app,

385
00:23:37,490 --> 00:23:42,350
share you know todo list of user 1 with user 2,

386
00:23:42,350 --> 00:23:48,110
and then you know what actually retrieve user one want user two's data,

387
00:23:48,320 --> 00:23:52,730
there needs to be a way of actually naming user 2 todo list,

388
00:23:52,970 --> 00:23:54,110
and actually retrieving it.

389
00:23:55,000 --> 00:23:56,530
And then you know there's a certain way,

390
00:23:56,530 --> 00:24:01,570
there's a name to public key mapping,

391
00:24:01,990 --> 00:24:06,820
you know when I do you know successfully retrieve user 2 data,

392
00:24:07,000 --> 00:24:10,690
you know probably want to verify it, actually was written by user 2,

393
00:24:10,930 --> 00:24:16,390
and so probably user 2's public key to verify the integrity of the data retrieved,

394
00:24:16,420 --> 00:24:20,170
because the storage providers might be, can then be untrusted,

395
00:24:20,620 --> 00:24:22,600
and that requires that,

396
00:24:22,600 --> 00:24:27,820
I can establish what actually user 2's public key is in a reliable manner.

397
00:24:29,380 --> 00:24:32,770
And so you should think about

398
00:24:32,770 --> 00:24:36,430
in every step of these decentralized applications,

399
00:24:36,550 --> 00:24:38,860
you know the name plays a crucial role.

400
00:24:39,710 --> 00:24:42,440
And and the common name given

401
00:24:42,440 --> 00:24:46,460
the particular for you know the mapping from names to keys,

402
00:24:46,460 --> 00:24:48,080
which is a crucial keys

403
00:24:48,320 --> 00:24:51,080
is to be called public key infrastructure.

404
00:25:02,250 --> 00:25:07,910
And that is you know building actually any public key infrastructure is quite challenging,

405
00:25:08,090 --> 00:25:11,060
you know you might be familiar like DNSSec,

406
00:25:11,090 --> 00:25:14,660
there's are a particular way of course on the world wide web has,

407
00:25:14,870 --> 00:25:17,630
certificate has a whole public key infrastructure,

408
00:25:17,750 --> 00:25:22,400
Kerberos you know an example of public key infrastructure,

409
00:25:22,760 --> 00:25:23,930
and in some ways,

410
00:25:23,930 --> 00:25:26,000
with you know this paper actually do is

411
00:25:26,000 --> 00:25:28,400
you will get another public infrastructure,

412
00:25:28,430 --> 00:25:30,500
that is completely decentralized.

413
00:25:36,490 --> 00:25:41,860
And that's sort of a key aspect,

414
00:25:41,860 --> 00:25:47,020
you know what interesting about this naming scheme in the, in blockstack,

415
00:25:47,050 --> 00:25:49,780
that's actually provides decentralized public key infrastructure.

416
00:25:51,060 --> 00:25:54,300
Let me try to explain a little bit why this is challenging,

417
00:25:55,690 --> 00:26:01,760
so, the paper refers to this in a couple places,

418
00:26:02,000 --> 00:26:04,700
and says like you know there's, there's three aspects that you want,

419
00:26:04,760 --> 00:26:08,300
if you want a general purpose for naming infrastructure,

420
00:26:08,570 --> 00:26:10,610
you want to be able to have unique names,

421
00:26:11,470 --> 00:26:14,800
you know have a unique name for every user,

422
00:26:17,700 --> 00:26:18,960
so that you can identify

423
00:26:18,960 --> 00:26:23,850
you know the particular John or particular Joe, you're talking about that.

424
00:26:24,960 --> 00:26:29,520
Human human readable names,

425
00:26:32,970 --> 00:26:34,350
so it's easy to remember.

426
00:26:34,620 --> 00:26:37,170
And then in this case,

427
00:26:37,470 --> 00:26:42,060
what Blockstack also wants is decentralized.

428
00:26:46,840 --> 00:26:49,630
And you know the paper sort of makes the point that,

429
00:26:49,630 --> 00:26:52,390
it's easy to get two of the three,

430
00:26:52,390 --> 00:26:55,120
it's very difficult to get all three of them,

431
00:26:55,120 --> 00:26:56,110
and you know maybe,

432
00:26:56,140 --> 00:26:57,760
let's look at a couple naming systems,

433
00:26:57,760 --> 00:27:00,070
to see which two they do get.

434
00:27:00,310 --> 00:27:02,200
So let's think about like email addresses.

435
00:27:13,120 --> 00:27:17,240
Okay, email addresses, are they unique names?

436
00:27:22,140 --> 00:27:22,770
Yes.

437
00:27:23,130 --> 00:27:24,540
Are they human readable?

438
00:27:25,350 --> 00:27:25,680
Yeah.

439
00:27:25,680 --> 00:27:27,720
Are they decentralized?

440
00:27:28,140 --> 00:27:28,770
No.

441
00:27:28,980 --> 00:27:31,470
No, so this get two of these guys, correct,

442
00:27:31,470 --> 00:27:32,400
but not the third one.

443
00:27:33,260 --> 00:27:36,350
How about random public keys,

444
00:27:36,560 --> 00:27:40,280
or maybe like the paper uses hash of the file contents

445
00:27:40,280 --> 00:27:43,190
to actually get a name, correct, for the [],

446
00:27:43,190 --> 00:27:46,640
so basically okay so random public keys,

447
00:27:48,060 --> 00:27:50,130
which means public keys get random,

448
00:27:55,180 --> 00:27:57,160
so public keys, are they unique?

449
00:27:59,290 --> 00:27:59,950
Yep.

450
00:28:00,010 --> 00:28:00,760
Yeah.

451
00:28:00,790 --> 00:28:02,980
Yep, are they human readable?

452
00:28:03,280 --> 00:28:03,910
No.

453
00:28:03,940 --> 00:28:05,620
No, are they decentralized?

454
00:28:05,980 --> 00:28:06,610
Yes.

455
00:28:06,640 --> 00:28:09,070
Yeah yeah, you can generate them

456
00:28:09,070 --> 00:28:12,040
high probability in a unique manner completely decentralized.

457
00:28:13,860 --> 00:28:18,390
So in fact, you sort of done that more in lab 3 with these clerk ids,

458
00:28:18,420 --> 00:28:21,390
so here we got, like we got two of the three,

459
00:28:21,420 --> 00:28:22,710
but not the human readable one.

460
00:28:23,010 --> 00:28:26,370
Let's see, can we actually get human readable and decentralized?

461
00:28:27,920 --> 00:28:29,180
Can you think of an example?

462
00:28:34,800 --> 00:28:37,740
Is it like a peer to peer file sharing?

463
00:28:39,360 --> 00:28:40,890
Yeah.

464
00:28:40,890 --> 00:28:42,510
It not unique, the files,

465
00:28:42,540 --> 00:28:44,670
but they're human readable and decentralized.

466
00:28:44,880 --> 00:28:46,020
Yeah, think simpler,

467
00:28:46,170 --> 00:28:48,750
you know think about your phone,

468
00:28:54,170 --> 00:28:55,940
the example for me always is a good one,

469
00:28:55,940 --> 00:28:57,260
it looks like your contact list,

470
00:29:02,370 --> 00:29:06,030
the names of your contact human readable you know implies,

471
00:29:06,030 --> 00:29:08,970
you know you could have John,

472
00:29:09,000 --> 00:29:11,760
you know the entry for John one phone number,

473
00:29:11,760 --> 00:29:15,240
and I can have another phone number or my John entry,

474
00:29:15,540 --> 00:29:16,920
they're probably different people,

475
00:29:17,100 --> 00:29:21,060
but you know I can pick the names in decentralized manner,

476
00:29:21,640 --> 00:29:23,200
and they're certainly readable,

477
00:29:23,200 --> 00:29:23,920
are they unique?

478
00:29:27,340 --> 00:29:28,270
No, correct,

479
00:29:28,600 --> 00:29:31,480
this is like you have your list of names,

480
00:29:31,480 --> 00:29:32,500
I have my list of names,

481
00:29:32,500 --> 00:29:33,790
and they may actually overlap,

482
00:29:33,790 --> 00:29:35,230
and still talk about different people.

483
00:29:36,600 --> 00:29:39,300
So here's sort of what the paper trying to get at,

484
00:29:39,570 --> 00:29:41,010
actually getting two out of three,

485
00:29:41,220 --> 00:29:44,760
you know it's quite common or actually easy,

486
00:29:44,820 --> 00:29:47,430
but actually getting all three of them is hard.

487
00:29:49,010 --> 00:29:53,810
And in the paper, so it's like,

488
00:29:53,810 --> 00:29:56,420
well, we actually, we achieve all three of them,

489
00:29:56,750 --> 00:30:00,020
then we get the unique names, user readable and decentralized.

490
00:30:01,670 --> 00:30:04,970
And in the way, in some ways they they get this is

491
00:30:05,030 --> 00:30:09,350
basically exploited blockchain.

492
00:30:15,100 --> 00:30:16,510
So Blockstack approach,

493
00:30:27,450 --> 00:30:30,450
and really [] they be fair,

494
00:30:30,480 --> 00:30:33,660
it's really not Blockstack approaches,

495
00:30:33,660 --> 00:30:38,850
really namecoins approach, that they sort of adopted.

496
00:30:39,730 --> 00:30:41,800
The basic idea is very simple,

497
00:30:41,830 --> 00:30:43,810
we're going to take advantage

498
00:30:43,810 --> 00:30:49,450
of the existence of the Bitcoin blockstack, with Bitcoin blockchain

499
00:30:49,450 --> 00:30:51,490
and of course you can use any other blockchain,

500
00:30:51,490 --> 00:30:52,990
but like just for concreteness,

501
00:30:53,260 --> 00:30:55,600
we're going to think about the Bitcoin one.

502
00:30:56,080 --> 00:30:58,120
And so here we got our chain,

503
00:30:59,710 --> 00:31:02,770
you know transactions that in Bitcoin,

504
00:31:03,890 --> 00:31:06,800
and you know grows over time,

505
00:31:06,860 --> 00:31:08,930
you know miners add new transactions,

506
00:31:09,260 --> 00:31:12,800
and the way we're gonna basically create naming system is,

507
00:31:12,800 --> 00:31:17,150
we're going to just post transactions that sort of different type,

508
00:31:17,150 --> 00:31:18,830
they basically claim a name.

509
00:31:19,350 --> 00:31:24,240
And so, for example you know we might actually have special transactions,

510
00:31:24,760 --> 00:31:29,740
because every transaction actually turns out in Bitcoin has a metadata field,

511
00:31:29,740 --> 00:31:32,380
that you can basically stick anything in the metadata fields you want,

512
00:31:32,680 --> 00:31:36,130
and so what we're going to stick in there is a name record.

513
00:31:36,650 --> 00:31:37,910
So we're gonna have some transaction,

514
00:31:37,910 --> 00:31:39,770
and then we're going to take a name record in there,

515
00:31:41,510 --> 00:31:42,950
you'll see a little in the second,

516
00:31:42,950 --> 00:31:44,960
but exactly the details of this name record is,

517
00:31:45,230 --> 00:31:46,790
but in the case of Blockstack,

518
00:31:46,790 --> 00:31:50,780
you know it's basically a name like 6.824,

519
00:31:51,900 --> 00:31:54,120
and then maybe as we see later,

520
00:31:54,120 --> 00:31:55,380
a hash of the zone file.

521
00:31:56,190 --> 00:32:00,870
And you know the basic rule in the in this scheme is going to be that,

522
00:32:01,260 --> 00:32:14,550
the first one, the first user, first name record basically wins, right,

523
00:32:14,550 --> 00:32:15,660
so there might be a second,

524
00:32:15,660 --> 00:32:18,660
you know somebody else creates in the name 6.824 later,

525
00:32:18,810 --> 00:32:25,400
but because you know the 6.824 shows up later in

526
00:32:25,400 --> 00:32:28,940
or in the Bitcoin blockchain,

527
00:32:29,000 --> 00:32:31,010
we're gonna basically ignore that one,

528
00:32:31,520 --> 00:32:38,200
and you know only you know consider that valid name record for 6.824,

529
00:32:39,220 --> 00:32:41,920
and this completely you know plays off on the fact,

530
00:32:41,920 --> 00:32:49,330
that there's basically blockchain is a log of all the operations ever happened,

531
00:32:49,330 --> 00:32:51,310
they're in order, they're consensus,

532
00:32:51,310 --> 00:32:52,660
in what order they happened,

533
00:32:53,050 --> 00:32:54,670
and so from that,

534
00:32:54,670 --> 00:32:58,450
we've been basically construct, if you will, like a database,

535
00:32:58,480 --> 00:33:00,370
a database with all the names in the order,

536
00:33:00,400 --> 00:33:02,830
you know just go through the blockchain from beginning of time,

537
00:33:03,070 --> 00:33:07,240
find the valid transactions, name transactions,

538
00:33:07,540 --> 00:33:13,690
and use that to construct database with all the, with all the valid names.

539
00:33:14,220 --> 00:33:17,940
In some ways, a number number of people sort of pointed this out,

540
00:33:17,940 --> 00:33:20,910
like isn't this exactly what we've been doing lab 3,

541
00:33:20,940 --> 00:33:24,690
where you know we have log, like Raft provides to log,

542
00:33:24,690 --> 00:33:26,250
we stick up operations in the log,

543
00:33:26,250 --> 00:33:29,850
you know we run you know the operations,

544
00:33:30,120 --> 00:33:32,940
and that constructs you know the state,

545
00:33:32,970 --> 00:33:35,670
where the state in this case would be a naming database,

546
00:33:35,850 --> 00:33:38,910
and there's you know, I think it's exactly that kind of style,

547
00:33:39,090 --> 00:33:42,840
in the same idea, except the small differences here,

548
00:33:42,840 --> 00:33:44,550
we're not using Raft to get the consensus,

549
00:33:44,550 --> 00:33:50,160
we're again using Bitcoin or Nakamoto or to get to Nakamoto consensus

550
00:33:50,160 --> 00:33:53,880
to actually achieve one single blockchain.

551
00:33:54,560 --> 00:33:58,760
But in spirit, you know, yes you know it's very similar.

552
00:34:01,660 --> 00:34:04,900
Okay, so let's think a little bit about it,

553
00:34:04,900 --> 00:34:07,510
you know our three properties,

554
00:34:07,510 --> 00:34:11,620
you know first of all, you know, do we do get unique names?

555
00:34:18,010 --> 00:34:18,640
Yes.

556
00:34:18,880 --> 00:34:20,350
Yeah, we got to unique names, correct,

557
00:34:20,350 --> 00:34:21,730
because the first one wins.

558
00:34:24,730 --> 00:34:27,070
Is it decentralized?

559
00:34:28,860 --> 00:34:29,280
Yes.

560
00:34:29,790 --> 00:34:33,180
Yeah, decentralized by sort of Bitcoin, right,

561
00:34:36,580 --> 00:34:39,700
and the consensus and the log basically makes sure that,

562
00:34:39,700 --> 00:34:42,310
we can actually identify what the first name is,

563
00:34:42,310 --> 00:34:43,810
so that we can actually pick a unique name.

564
00:34:45,080 --> 00:34:46,130
Is it human readable?

565
00:34:47,720 --> 00:34:48,410
Can be.

566
00:34:49,370 --> 00:34:50,840
Yeah, exactly, yeah,

567
00:34:53,160 --> 00:34:57,330
certainly, my stream 6.824 hopefully user readable.

568
00:35:02,170 --> 00:35:06,730
Okay, so it seems like it's sort of first brought you know three,

569
00:35:06,730 --> 00:35:10,660
you know it looks like indeed you know we got the three properties, right,

570
00:35:11,310 --> 00:35:14,070
we got user readable, we got the uniqueness, we got decentralized.

571
00:35:14,950 --> 00:35:19,660
And I think that really Namecoin was sort of the first naming system

572
00:35:19,690 --> 00:35:22,780
demonstrated that could be that could be achieved in this way.

573
00:35:23,460 --> 00:35:26,250
Now, it's not completely perfect, right,

574
00:35:26,730 --> 00:35:31,500
like for example even though we got sort of unique names and user readable,

575
00:35:31,590 --> 00:35:34,920
we don't really know like what 6.824 really means, correct,

576
00:35:35,370 --> 00:35:38,790
6.824 and what does 6.824 refer to,

577
00:35:38,790 --> 00:35:40,950
is like a a part number,

578
00:35:40,950 --> 00:35:43,800
or is it a class number or anything,

579
00:35:43,800 --> 00:35:45,750
we don't really know how interpret names,

580
00:35:45,750 --> 00:35:47,520
but you know they still human readable,

581
00:35:47,520 --> 00:35:48,660
its not completely perfect,

582
00:35:48,660 --> 00:35:52,380
it's not identifying uniquely some user in the world, right,

583
00:35:53,100 --> 00:35:55,920
and even like whatever you were done [],

584
00:35:55,920 --> 00:35:59,970
that doesn't really uniquely identify one person, right,

585
00:35:59,970 --> 00:36:01,380
so whenever you see a name,

586
00:36:01,380 --> 00:36:05,250
there's still the issue of like who it actually really is.

587
00:36:07,540 --> 00:36:12,130
And also, there's sort of a similar you know related issue,

588
00:36:12,130 --> 00:36:13,630
why it's not completely perfect,

589
00:36:13,630 --> 00:36:14,920
which is like,

590
00:36:15,280 --> 00:36:17,710
how, how do you find somebody's name,

591
00:36:17,950 --> 00:36:22,090
and you know how do you find actually you know what [] name,

592
00:36:22,120 --> 00:36:26,080
how do and how do you find that,

593
00:36:26,080 --> 00:36:29,200
how do you know which record actually goes with, which particular user,

594
00:36:29,230 --> 00:36:34,450
so although although the system is quite cool,

595
00:36:34,450 --> 00:36:38,440
because it has these decentralized, unique and human readable aspects to it,

596
00:36:38,740 --> 00:36:39,970
you know it's not completely perfect,

597
00:36:39,970 --> 00:36:43,150
and these are generally issues with general naming systems,

598
00:36:43,270 --> 00:36:44,920
but certainly true here too,

599
00:36:45,220 --> 00:36:46,150
so it's not the case that,

600
00:36:46,150 --> 00:36:49,240
you know we we should have solved all naming problems,

601
00:36:49,360 --> 00:36:51,430
in one single swoop,

602
00:36:51,430 --> 00:36:55,840
we do have a good good standing position to work with,

603
00:36:55,840 --> 00:36:58,900
but it's not completely hundred percent hit.

604
00:37:01,900 --> 00:37:05,380
So question, so Namecoin,

605
00:37:05,380 --> 00:37:11,890
all they did was add essentially this record to the the like transaction?

606
00:37:12,160 --> 00:37:15,730
Well, I think we did a little bit more, correct,

607
00:37:15,730 --> 00:37:19,280
they run their own blockchain, independent of Bitcoin,

608
00:37:19,640 --> 00:37:24,620
and used blockchain, there purely for many,

609
00:37:25,360 --> 00:37:27,550
and they had also a bunch of rules about,

610
00:37:27,550 --> 00:37:31,480
like how much money, how many namecoins you have to pay

611
00:37:31,480 --> 00:37:32,680
to get a particular name,

612
00:37:32,680 --> 00:37:35,170
and there's all kinds of other extensions,

613
00:37:35,530 --> 00:37:39,340
that I really discussed yet were mentioned,

614
00:37:39,340 --> 00:37:41,710
but they sort of followed this particular approach,

615
00:37:42,140 --> 00:37:43,580
and were the first to do so,

616
00:37:46,630 --> 00:37:49,780
in many pragmatic issues paper touches on,

617
00:37:49,930 --> 00:37:51,550
when I haven't mentioned at all yet.

618
00:37:56,060 --> 00:37:56,990
Any other questions?

619
00:38:04,300 --> 00:38:09,430
Okay, so let's actually dive in a little bit on the sort of the practical issues,

620
00:38:09,730 --> 00:38:11,650
although there's a slightly different nature,

621
00:38:11,650 --> 00:38:13,000
we want to we just talked about,

622
00:38:13,000 --> 00:38:14,140
it really is by the,

623
00:38:15,940 --> 00:38:21,580
how to actually implement decentralized apps and naming system,

624
00:38:21,880 --> 00:38:24,760
by leveraging Bitcoin.

625
00:38:42,020 --> 00:38:47,780
And there's a bunch of, a bunch of very short just pragmatic issues,

626
00:38:47,990 --> 00:38:50,060
there are limits on the amount of data,

627
00:38:50,060 --> 00:38:56,990
you can put in on data size in a transaction.

628
00:38:59,120 --> 00:39:02,270
So, although maybe it's perfectly fine to have a name,

629
00:39:02,300 --> 00:39:08,660
value binding into the, into the, into the Bitcoin transaction,

630
00:39:08,900 --> 00:39:11,930
and we can't put our todo list inside of that transaction,

631
00:39:11,930 --> 00:39:13,850
and so you know we've got to have some plan,

632
00:39:14,150 --> 00:39:17,780
if we're actually how that part is going to work out.

633
00:39:18,590 --> 00:39:19,940
It has slow writes,

634
00:39:21,570 --> 00:39:23,220
we know from the last lecture,

635
00:39:23,400 --> 00:39:27,810
it takes a while for write actually or transactions to propagate,

636
00:39:28,140 --> 00:39:31,620
and before they decided to be really stable,

637
00:39:31,620 --> 00:39:34,080
it cannot be forked off anymore,

638
00:39:34,200 --> 00:39:39,150
you know we might be talking about like you know four five six blocks later in the chain,

639
00:39:39,150 --> 00:39:40,650
you know any blocks ten minutes,

640
00:39:40,650 --> 00:39:42,270
so you know an hour later, right,

641
00:39:42,810 --> 00:39:44,430
and so it's really not so cool,

642
00:39:44,430 --> 00:39:48,810
if we're stick our todo list inside of the blockchain too,

643
00:39:48,810 --> 00:39:52,800
because you know I modify my block, my chain, I modify my todo list,

644
00:39:52,800 --> 00:39:54,780
you know like an hour later, maybe actually observe it,

645
00:39:54,780 --> 00:39:56,190
so that seems not so good,

646
00:39:56,190 --> 00:39:58,950
and you want to go to more aggressive applications,

647
00:39:58,950 --> 00:40:01,470
where there's much more data that's manipulated,

648
00:40:01,710 --> 00:40:04,560
you know certainly a problem,

649
00:40:04,800 --> 00:40:07,470
in a similar, in addition are slow, right,

650
00:40:07,470 --> 00:40:09,870
so there's also low throughput, low bandwidth,

651
00:40:15,650 --> 00:40:20,520
in the [], there's only a few transactions per second, correct,

652
00:40:20,520 --> 00:40:23,550
so we're gonna do a lot of writes you know to file,

653
00:40:23,550 --> 00:40:24,900
and many times we're also,

654
00:40:24,900 --> 00:40:29,220
we're going running the file operations through blockchain,

655
00:40:29,220 --> 00:40:32,610
so, so clearly you know we've got to be a little bit,

656
00:40:32,610 --> 00:40:39,360
if we want to really build a general purpose infrastructure for decentralized applications,

657
00:40:39,360 --> 00:40:41,760
it's going to be a more complete story,

658
00:40:41,760 --> 00:40:45,150
that actually allows us to get like fast writes,

659
00:40:45,150 --> 00:40:46,380
you know high bandwidth writes,

660
00:40:46,380 --> 00:40:50,850
and gets around you know basically not running everything in the blockchain.

661
00:40:51,660 --> 00:40:53,760
The paper also talks about one other final problem,

662
00:40:53,760 --> 00:40:55,830
the ledger, ever growing ledger,

663
00:40:56,600 --> 00:41:01,160
I'm not actually spend much time about talking about that at all,

664
00:41:01,370 --> 00:41:03,080
but it's going to also issue,

665
00:41:03,110 --> 00:41:05,660
if you want to do, as [] in the paper,

666
00:41:05,660 --> 00:41:08,720
you are going to boot up a Blockstack node,

667
00:41:08,720 --> 00:41:11,630
if you do sort of a traditional Bitcoin style,

668
00:41:11,630 --> 00:41:14,750
where you're gonna run through all the transactions one by one,

669
00:41:14,810 --> 00:41:15,710
that will take a while,

670
00:41:15,710 --> 00:41:18,230
before you actually build up a complete naming record,

671
00:41:18,910 --> 00:41:20,980
in particular, in the case of Blockstack is a little bit annoying,

672
00:41:20,980 --> 00:41:24,010
because a lot of the transactions that are in the blockchain

673
00:41:24,010 --> 00:41:25,930
are completely irrelevant to Blockstack, right,

674
00:41:25,930 --> 00:41:29,320
there there whatever transaction is actually a completely different purpose,

675
00:41:29,500 --> 00:41:33,520
and have nothing to do with Blockstack approach,

676
00:41:33,520 --> 00:41:34,390
you know Blockstack,

677
00:41:34,390 --> 00:41:39,010
if you literally using the Bitcoin blockchain as your fundamental thing,

678
00:41:39,010 --> 00:41:40,930
you would have to go through an interpreter

679
00:41:40,930 --> 00:41:42,730
and see which ones actually going to apply.

680
00:41:45,100 --> 00:41:49,690
Okay, so we're going to focus more on some of these first couple of challenges,

681
00:41:49,690 --> 00:41:52,540
which is like you know basically what we wanna do is

682
00:41:52,540 --> 00:41:55,990
minimized the use of blockchain,

683
00:41:56,320 --> 00:42:02,050
you know so we get high performance writes or [].

684
00:42:05,160 --> 00:42:05,850
Does that make sense?

685
00:42:11,370 --> 00:42:14,910
Good, that's what gets you the core of the paper,

686
00:42:15,090 --> 00:42:16,980
which is like,

687
00:42:17,890 --> 00:42:19,540
we pull up the diagram,

688
00:42:19,540 --> 00:42:20,680
so we can look at it,

689
00:42:23,320 --> 00:42:24,640
that's basically this diagram.

690
00:42:25,380 --> 00:42:29,160
And that sort of description of the general approach,

691
00:42:29,610 --> 00:42:32,460
the paper takes to address the challenges,

692
00:42:32,460 --> 00:42:34,800
that I just laid out on the previous board.

693
00:42:39,050 --> 00:42:40,760
Okay, so this is a complicated picture

694
00:42:40,820 --> 00:42:43,370
and so let's go for layer by layer,

695
00:42:43,370 --> 00:42:45,710
and try to understand actually how things work.

696
00:42:50,440 --> 00:42:51,880
So at the bottom,

697
00:42:53,100 --> 00:42:56,870
here is the, you know is the Bitcoin chain,

698
00:43:02,040 --> 00:43:06,660
and in in the Bitcoin chain, there's a lot of transactions,

699
00:43:06,720 --> 00:43:13,080
and many of these transactions have absolutely nothing to do with Blockstack, right.

700
00:43:13,080 --> 00:43:14,280
Write down Blockstack here.

701
00:43:18,680 --> 00:43:21,710
And the Blockstack transactions are sort of sitting in

702
00:43:21,710 --> 00:43:24,380
you know a particular blocks in the blockchain,

703
00:43:25,700 --> 00:43:28,550
and then there's a second layer,

704
00:43:28,550 --> 00:43:30,170
which really is the Blockstack nodes,

705
00:43:30,320 --> 00:43:33,650
that basically read all these transactions,

706
00:43:33,770 --> 00:43:37,490
fish out the ones that are actually related to Blockstack,

707
00:43:37,700 --> 00:43:40,400
interpret those operations

708
00:43:40,670 --> 00:43:44,300
and you know build up a Blockstack database with names

709
00:43:44,330 --> 00:43:47,150
to what turns out to be zone file hashes.

710
00:43:47,720 --> 00:43:49,550
So we look at these operations,

711
00:43:49,550 --> 00:43:50,660
when the ones in there,

712
00:43:50,660 --> 00:43:53,270
so in every Bitcoin transactions,

713
00:43:53,270 --> 00:43:55,160
as I mentioned early, you can have some metadata,

714
00:43:55,190 --> 00:43:58,220
that's in the what's called the OP_RETURN field,

715
00:43:58,520 --> 00:44:00,860
and in the OP_RETRUN field,

716
00:44:01,130 --> 00:44:10,260
there's basically a name, say x plus you know the hash of zone file,

717
00:44:15,980 --> 00:44:20,360
and that's sort of the binding, that sits in a Bitcoin,

718
00:44:20,360 --> 00:44:23,660
and basically Blockstack that uses Bitcoin

719
00:44:23,660 --> 00:44:30,890
to basically make that binding from from name to zone file unique,

720
00:44:30,890 --> 00:44:33,800
and in a decentralized manner.

721
00:44:34,550 --> 00:44:39,950
So as, you know, like in lab 3 or in any other sort of logging system,

722
00:44:40,160 --> 00:44:48,380
the Blockstack nodes interpret these particular name transactions,

723
00:44:48,410 --> 00:44:49,670
look at OP field,

724
00:44:49,910 --> 00:44:52,100
see that this OP field,

725
00:44:52,100 --> 00:44:54,080
is for example to create a particular name,

726
00:44:54,170 --> 00:44:56,360
and basically store in the database,

727
00:44:56,360 --> 00:45:02,450
the binding from name x you know to the hash of the zone file,

728
00:45:03,480 --> 00:45:06,090
and once a while, as we've seen in the second,

729
00:45:06,120 --> 00:45:07,950
usually want to update zone file,

730
00:45:08,070 --> 00:45:11,070
so you might see multiple transactions for the zone,

731
00:45:11,280 --> 00:45:14,340
user updating basically hash the zonefile.

732
00:45:15,240 --> 00:45:18,840
Of course, we want to minimize you know these changes,

733
00:45:18,840 --> 00:45:22,380
because every change to the, would require,

734
00:45:22,410 --> 00:45:26,610
would require modification or posting a Bitcoin transaction,

735
00:45:26,790 --> 00:45:30,150
and you know for many reasons on the previous slide, that's slow,

736
00:45:30,150 --> 00:45:31,440
which would like to try to avoid it,

737
00:45:31,530 --> 00:45:33,300
futhermore, it will cost a little bit of money,

738
00:45:33,710 --> 00:45:36,860
I mean, there's these transactions need to be a process.

739
00:45:38,400 --> 00:45:43,960
And so, so the basic plan,

740
00:45:43,960 --> 00:45:47,590
so this this node layer, virtual chain layer,

741
00:45:47,590 --> 00:45:53,380
basically built this database of mapping from name to hash zonefile,

742
00:45:53,380 --> 00:45:57,310
you know of course also filters out all the transactions that are invalid

743
00:45:57,340 --> 00:46:00,940
or like you know new x are being created after the first one.

744
00:46:01,540 --> 00:46:06,160
And then, using the hash at the zonefile,

745
00:46:06,160 --> 00:46:07,540
you know which we got,

746
00:46:07,870 --> 00:46:13,540
it locates, an application could locate the zonefile,

747
00:46:13,540 --> 00:46:15,460
and the zonefile can come from anywhere,

748
00:46:15,640 --> 00:46:18,190
and because we have to hash with the zonefile,

749
00:46:18,280 --> 00:46:20,890
when we retrieve a file that claims to be the zonefile,

750
00:46:20,890 --> 00:46:22,270
we can re-compute the hash,

751
00:46:22,330 --> 00:46:27,010
if the hash is identical to the one that we got through interactive through Bitcoin,

752
00:46:27,130 --> 00:46:31,390
then we know for sure, that is the zonefile that goes with x.

753
00:46:33,370 --> 00:46:36,460
So, okay, what is that in a zonefiles,

754
00:46:36,760 --> 00:46:41,020
well, in zonefile is for yet another table,

755
00:46:41,050 --> 00:46:44,800
if you will, of mapping names to URIs,

756
00:46:44,830 --> 00:46:47,140
so for example, you might have a zonefile,

757
00:46:47,140 --> 00:46:50,080
which has like maybe for a todo app,

758
00:46:50,470 --> 00:46:55,370
that's an entry todo, and thit points to a URI,

759
00:46:56,500 --> 00:47:00,130
where actually the data is located for you know todo list.

760
00:47:00,930 --> 00:47:04,950
And there's sort of two types of zonefiles,

761
00:47:04,950 --> 00:47:07,560
and one is what's called is mutable and one is immutable,

762
00:47:08,130 --> 00:47:11,650
the mutable ones have URI plus a public key,

763
00:47:15,280 --> 00:47:17,830
so, and this is public key,

764
00:47:17,830 --> 00:47:19,780
is the key to actually validate,

765
00:47:20,050 --> 00:47:24,130
whether whether the file was written by the user x,

766
00:47:24,130 --> 00:47:27,400
so basically the user x you know publishes through this zonefile,

767
00:47:27,400 --> 00:47:29,410
public key for him or herself,

768
00:47:29,830 --> 00:47:34,270
and later on, when user 2 want to look up user x,

769
00:47:34,270 --> 00:47:36,160
you know gets the hash at the zonefile,

770
00:47:36,370 --> 00:47:39,940
the hash finds the zonefile, double checks that the zonefile,

771
00:47:39,940 --> 00:47:42,430
you know hash is to the right value,

772
00:47:42,460 --> 00:47:45,790
looks inside the zonefile,

773
00:47:45,820 --> 00:47:48,730
finds the you know the public key of x

774
00:47:48,790 --> 00:47:52,600
and the URI you know for the todo file,

775
00:47:52,780 --> 00:47:57,040
usually the URI to fetch the actual todo file,

776
00:47:57,190 --> 00:48:01,060
check you know the signature on the receive file with the public key,

777
00:48:01,240 --> 00:48:02,440
and it all checks out,

778
00:48:02,440 --> 00:48:04,780
then basically user 2 knows,

779
00:48:04,780 --> 00:48:09,640
you know I got you know user x zonefile.

780
00:48:10,390 --> 00:48:13,750
And then it might be also like other names in this zonefile,

781
00:48:13,750 --> 00:48:19,660
like whatever user access tweets, etc, timeline whatever,

782
00:48:19,780 --> 00:48:22,120
you know for every application is probably an entry,

783
00:48:22,120 --> 00:48:24,850
and you know probably the applications sort agree on

784
00:48:24,850 --> 00:48:27,040
like one name to use for a particular application.

785
00:48:29,240 --> 00:48:33,440
So don't we lose the like data immutability guarantees,

786
00:48:33,440 --> 00:48:35,300
where it's possible this data could be deleted,

787
00:48:35,300 --> 00:48:38,320
and then you wouldn't have the hash of data, could be lost.

788
00:48:38,860 --> 00:48:41,710
So what do you mean, like the zonefile get lost?

789
00:48:42,580 --> 00:48:45,310
Right, like like with the chain, you can't lose data,

790
00:48:45,340 --> 00:48:46,660
because it'll be replicated enough places,

791
00:48:46,660 --> 00:48:48,280
but here, that's not to guaranteed.

792
00:48:48,280 --> 00:48:51,610
So, turns out zonefiles also replicated widely,

793
00:48:51,640 --> 00:48:53,740
on basically there's a core in a Blockstack,

794
00:48:53,740 --> 00:48:56,620
all replicated a zonefiles to everybody,

795
00:48:57,010 --> 00:49:00,880
and the zonefile reasonable small,

796
00:49:00,880 --> 00:49:03,700
like for kilobyte or something in that order,

797
00:49:03,910 --> 00:49:05,350
and so they can be replicated everywhere,

798
00:49:05,620 --> 00:49:06,130
okay?

799
00:49:06,460 --> 00:49:10,870
Then for the todo list, todo file URI,

800
00:49:11,080 --> 00:49:13,000
the basic idea is that,

801
00:49:13,000 --> 00:49:17,140
you might store the same data at multiple providers,

802
00:49:17,140 --> 00:49:20,380
for example you might want to have replicated it S3,

803
00:49:20,710 --> 00:49:23,110
and maybe you also stick it in Google Drive,

804
00:49:25,060 --> 00:49:31,210
and one reason that actually Blockstack that has storage servers is,

805
00:49:31,300 --> 00:49:33,160
not because actually they store data,

806
00:49:33,190 --> 00:49:37,060
but basically providing uniform API to all these different storage providers.

807
00:49:43,890 --> 00:49:44,490
Okay, so there.

808
00:49:46,010 --> 00:49:46,730
Does that make sense?

809
00:49:50,330 --> 00:49:54,380
Okay, so there's a, I mentioned zonefiles in two ways,

810
00:49:54,380 --> 00:49:57,110
there's another which are called immutable storage,

811
00:49:57,110 --> 00:50:01,820
and that actually contains the URI, name,

812
00:50:03,170 --> 00:50:14,600
URI, public key, and the hash of the data of the file.

813
00:50:16,680 --> 00:50:18,390
So you can basically verify,

814
00:50:18,420 --> 00:50:21,930
you know, is this indeed the latest version of the file,

815
00:50:22,290 --> 00:50:25,230
because in this scheme, you get to update,

816
00:50:25,230 --> 00:50:26,760
you know x can update the file,

817
00:50:26,760 --> 00:50:29,220
but it's hard to tell, for user 2,

818
00:50:29,220 --> 00:50:31,170
whether that is actually the latest version,

819
00:50:31,500 --> 00:50:32,640
the paper mentions that,

820
00:50:32,640 --> 00:50:34,860
there you know probably the version numbers in it,

821
00:50:35,130 --> 00:50:38,820
but if you really want to guarantee to be sort of latest version for a particular name,

822
00:50:39,030 --> 00:50:41,280
if you're using immutable storage,

823
00:50:41,280 --> 00:50:44,490
you know then, the immutable storage contains the hash of the file,

824
00:50:44,790 --> 00:50:48,990
and that uniquely identifies a particular version of that particular file.

825
00:50:49,640 --> 00:50:53,120
That does mean, like if you update this record,

826
00:50:54,010 --> 00:50:57,100
then, that really means you update the zonefile,

827
00:50:57,370 --> 00:50:58,030
so that means,

828
00:50:58,030 --> 00:51:02,980
you have to republish or re-create a log entry in the Bitcoin chain,

829
00:51:03,070 --> 00:51:07,510
mapping you know x to a new a hash hash zonefile.

830
00:51:11,420 --> 00:51:16,580
Okay, so this is the overall picture for for the system,

831
00:51:16,850 --> 00:51:17,990
and as you can see,

832
00:51:17,990 --> 00:51:22,220
you know particular like you know use todo list site,

833
00:51:23,070 --> 00:51:29,880
you know the user x can actually update it's is todo list,

834
00:51:30,150 --> 00:51:35,580
without actually having to publish a new record in the in the Bitcoin chain,

835
00:51:36,060 --> 00:51:39,600
in fact, the only thing that really has to be created in the Bitcoin chain is

836
00:51:39,750 --> 00:51:41,340
just you know x's name,

837
00:51:41,610 --> 00:51:43,980
and x of course might have many other names,

838
00:51:43,980 --> 00:51:45,450
that are sitting in the zonefiles,

839
00:51:45,630 --> 00:51:50,250
in, and but you know the the,

840
00:51:51,910 --> 00:51:56,920
this system doesn't rely on for every operation on the, on the blockchain,

841
00:51:57,750 --> 00:52:00,870
which gets around, gets around a lot of these problems

842
00:52:00,870 --> 00:52:03,510
of slow rates, low bandwidth,

843
00:52:03,810 --> 00:52:05,400
and the limits of that,

844
00:52:06,500 --> 00:52:10,310
and limits on the on the data that actually appear in a transaction record,

845
00:52:10,310 --> 00:52:13,070
because the only data really has to appear in this transaction record,

846
00:52:13,310 --> 00:52:15,770
is this name plus the hash of the zonefile.

847
00:52:19,990 --> 00:52:23,830
Sorry, how can we find the zonefile, if you only have the hash.

848
00:52:24,310 --> 00:52:25,810
It's a very good question,

849
00:52:25,840 --> 00:52:28,600
we don't really care, where it comes from,

850
00:52:28,600 --> 00:52:31,060
and so you know they call this the routing layer,

851
00:52:31,690 --> 00:52:33,460
basically you tell the routing layer,

852
00:52:33,490 --> 00:52:36,670
hey, I'm looking for a file that has the following hash,

853
00:52:38,000 --> 00:52:41,990
and then the routing layer has to produce that file,

854
00:52:41,990 --> 00:52:44,090
and you can check whether you got the right file,

855
00:52:44,120 --> 00:52:45,380
like re-computing the hash

856
00:52:45,380 --> 00:52:47,600
and see you match the one that you're asking for.

857
00:52:58,400 --> 00:52:59,690
Any other questions about this?

858
00:53:05,210 --> 00:53:07,250
So sorry, just to clarify,

859
00:53:07,310 --> 00:53:11,390
operations within this file storage or the zonefiles

860
00:53:11,390 --> 00:53:14,330
is still limited by the underlying blockchain though, right?

861
00:53:14,970 --> 00:53:18,840
Yes or no, what are you thinking?

862
00:53:21,860 --> 00:53:27,650
Or just like, because modifications or changes to like the file will need a new hash,

863
00:53:27,650 --> 00:53:30,590
and therefore a new log entry within the blockchain,

864
00:53:30,710 --> 00:53:34,880
so you still have to wait for that to be quote unquote accepted,

865
00:53:34,910 --> 00:53:36,230
which is like an hour, right.

866
00:53:36,760 --> 00:53:38,740
Yeah, though, absolutely true,

867
00:53:38,740 --> 00:53:40,840
so when you make a change to the zonefile,

868
00:53:40,870 --> 00:53:43,990
that has to run through the txn,

869
00:53:44,260 --> 00:53:46,180
for example updating todo list,

870
00:53:46,450 --> 00:53:49,930
wouldn't have to require a Bitcoin transaction,

871
00:53:53,550 --> 00:53:55,770
you don't really update the zonefile at all,

872
00:53:55,800 --> 00:53:58,470
you know you're just updating todo list file,

873
00:53:58,470 --> 00:54:03,270
and the zonefile only contains the name todo and URI plus the public key,

874
00:54:03,270 --> 00:54:04,770
but you're not updating any of those.

875
00:54:08,290 --> 00:54:12,220
I see, but doesn't, don't we store also the hash of the file,

876
00:54:12,250 --> 00:54:13,870
so if we change the content.

877
00:54:13,990 --> 00:54:14,830
That's only,

878
00:54:14,830 --> 00:54:15,730
there are two cases,

879
00:54:15,730 --> 00:54:19,120
there's a mutable storage and immutable storage,

880
00:54:19,900 --> 00:54:23,410
and what they propose is that,

881
00:54:23,410 --> 00:54:25,810
for immutable storage like storage, you don't update,

882
00:54:25,810 --> 00:54:27,670
you can actually stick the hash of the file in there,

883
00:54:27,670 --> 00:54:31,450
but for mutable storage, you know that's going to see a lot of writes,

884
00:54:31,540 --> 00:54:34,070
you shouldn't do that, you should use this key.

885
00:54:36,860 --> 00:54:39,440
I see, and then how is it possible to validate

886
00:54:39,440 --> 00:54:41,990
with mutable storage that you're getting the right data, then.

887
00:54:42,200 --> 00:54:44,540
Yeah, so presumably a very good question,

888
00:54:44,540 --> 00:54:46,730
well, you can validate,

889
00:54:46,730 --> 00:54:49,310
whether you actually obtain and actually was produced by x,

890
00:54:49,340 --> 00:54:50,840
because you have the public key for x,

891
00:54:50,840 --> 00:54:54,320
and you can verify what actually the signature on the todo file,

892
00:54:54,440 --> 00:54:57,380
indeed checks out with the public key of x,

893
00:54:57,710 --> 00:55:00,370
so you at least know that x has written it, right,

894
00:55:00,400 --> 00:55:02,410
you may not know this most recent version,

895
00:55:02,410 --> 00:55:06,790
and so the paper sort of, they don't talk about these are you know in detail,

896
00:55:06,790 --> 00:55:07,450
the basic system,

897
00:55:07,450 --> 00:55:09,520
we probably have to stick version numbers in it,

898
00:55:09,520 --> 00:55:12,310
and so at least you can detect rollback,

899
00:55:12,520 --> 00:55:14,140
there's a little trick,

900
00:55:14,140 --> 00:55:16,690
actually I don't know how to how to actually,

901
00:55:18,880 --> 00:55:20,860
you can't really be sure that you actually got the latest version.

902
00:55:21,990 --> 00:55:25,710
But to where the modifications to a mutable storage coming into?

903
00:55:26,700 --> 00:55:28,440
Your todo file is here,

904
00:55:28,470 --> 00:55:30,570
like in here, like todo file,

905
00:55:32,020 --> 00:55:33,700
and if an application,

906
00:55:33,700 --> 00:55:36,340
might todo list application want to update todo file,

907
00:55:36,340 --> 00:55:37,360
just goes ahead and does it,

908
00:55:38,020 --> 00:55:42,010
and, and then signs it using the public key,

909
00:55:42,010 --> 00:55:49,250
and sticks it in the, and sticks in for the given URI.

910
00:55:50,400 --> 00:55:53,850
And would that be done through the routing layer as well,

911
00:55:53,850 --> 00:55:56,880
because you want to find where in the storage.

912
00:55:57,120 --> 00:56:01,110
Yeah, so user 2 will retrieve x's zonefile, right,

913
00:56:01,680 --> 00:56:03,720
and once it has x's zonefile,

914
00:56:03,720 --> 00:56:07,440
it knows where the file, the todo file is,

915
00:56:07,440 --> 00:56:09,900
because there's the URI sits in the zonefile.

916
00:56:12,610 --> 00:56:17,170
So again, they could retrieve it and a check the signature.

917
00:56:18,220 --> 00:56:19,840
About the URI, are there,

918
00:56:20,110 --> 00:56:26,110
it is it only one URI per name in the zonefile, or.

919
00:56:26,800 --> 00:56:30,490
I don't know, unclear exactly how it works,

920
00:56:30,550 --> 00:56:34,210
I'm sorry, I'm not you know, I need to check out the source code

921
00:56:34,210 --> 00:56:37,480
and look at the specific format zonefiles.

922
00:56:42,440 --> 00:56:45,500
Since we're publishing the public key

923
00:56:45,920 --> 00:56:49,310
together with all the rest of the data in the zone file,

924
00:56:49,310 --> 00:56:53,840
doesn't mean I could just make up a private key,

925
00:56:54,290 --> 00:56:56,810
make like matching public key

926
00:56:57,170 --> 00:57:00,320
and just stick something in there and say I'm user,

927
00:57:01,240 --> 00:57:05,430
because, because they do provide public key,

928
00:57:05,430 --> 00:57:07,770
so can I now just lie?

929
00:57:08,520 --> 00:57:10,860
Well, you can't falsify the zone file, correct,

930
00:57:11,410 --> 00:57:14,260
because the zonefile, the hash of the zonefile

931
00:57:14,260 --> 00:57:16,600
must match the hash that sits in the blockchain,

932
00:57:23,890 --> 00:57:29,840
so only the version that actually entered the blockchain record

933
00:57:30,080 --> 00:57:32,900
mapping x you know to that hash zonefile,

934
00:57:32,960 --> 00:57:35,930
only that person could have produce that zonefiles.

935
00:57:37,690 --> 00:57:39,670
I see, thank you.

936
00:57:45,060 --> 00:57:45,690
Okay?

937
00:57:46,620 --> 00:57:48,660
Well, so this is basically the big picture,

938
00:57:48,690 --> 00:57:51,690
and if you got this, if you got this part,

939
00:57:51,690 --> 00:57:54,270
then basically the rest of sort of details

940
00:57:54,300 --> 00:57:57,540
and important or maybe less important,

941
00:57:57,540 --> 00:57:59,580
this is the key thing to understand.

942
00:58:01,740 --> 00:58:05,410
Okay, there's a couple things I want to go over,

943
00:58:05,410 --> 00:58:08,290
I particularly want to talk a little bit more about name creation,

944
00:58:08,290 --> 00:58:10,720
because there's a couple little details, that are actually interesting.

945
00:58:19,260 --> 00:58:25,320
So turns out name creation actually has two part to it,

946
00:58:25,410 --> 00:58:28,020
the first of all, the user needs to have of course some Bitcoins,

947
00:58:28,020 --> 00:58:28,890
because you gotta pay,

948
00:58:37,450 --> 00:58:38,920
the reason you have to have some Bitcoins,

949
00:58:38,920 --> 00:58:42,820
because you gotta convince one of the miners

950
00:58:42,820 --> 00:58:46,030
to actually include your transaction in the Bitcoin ledger.

951
00:58:46,600 --> 00:58:51,130
And so it turns out there are two transactions for every name that you create,

952
00:58:55,130 --> 00:58:59,540
and one is a basically a pre-order transaction,

953
00:59:02,300 --> 00:59:03,800
and in the pre-order transaction,

954
00:59:03,890 --> 00:59:05,420
you don't really list the name,

955
00:59:05,420 --> 00:59:07,130
but actually the hash of the name,

956
00:59:11,730 --> 00:59:13,950
so, anybody who receives the pre-order transaction,

957
00:59:13,950 --> 00:59:15,030
doesn't know what the name is,

958
00:59:15,030 --> 00:59:17,760
but you know does know what the hash with the name is.

959
00:59:18,080 --> 00:59:21,860
And then there's the second transaction really registers the name,

960
00:59:24,280 --> 00:59:27,730
and that basically contains the actual name,

961
00:59:28,890 --> 00:59:33,210
which we first published the hash, the hash of the zonefile.

962
00:59:41,380 --> 00:59:45,460
And so why, why, why is this done,

963
00:59:45,460 --> 00:59:47,680
this is actually something that Namecoin did,

964
00:59:47,680 --> 00:59:50,110
and they adopted from Namecoin here,

965
00:59:50,110 --> 00:59:51,340
why do it in this way?

966
00:59:54,240 --> 00:59:56,340
Because if you directly announce the name,

967
00:59:56,340 --> 00:59:58,230
then someone else can raise you

968
00:59:58,230 --> 01:00:02,010
and try to register that name before you.

969
01:00:02,310 --> 01:00:06,960
Yeah, this is a common problems go from front problem.

970
01:00:09,310 --> 01:00:11,050
Oops, there we go again, sorry.

971
01:00:33,790 --> 01:00:37,570
So front runner problem exactly describe,

972
01:00:37,570 --> 01:00:40,570
let's say you're trying to register google.com,

973
01:00:40,900 --> 01:00:43,750
and somebody sees you doing that,

974
01:00:43,750 --> 01:00:45,340
of course you submit a transaction, correct,

975
01:00:45,340 --> 01:00:46,510
not in the blockchain yet,

976
01:00:46,750 --> 01:00:48,730
for example a miner might actually see

977
01:00:48,730 --> 01:00:52,390
or somebody else that actually sits in the Bitcoin network,

978
01:00:52,720 --> 01:00:54,250
and decide going to running ahead

979
01:00:54,250 --> 01:00:55,480
and trying to get my transaction

980
01:00:55,480 --> 01:01:00,550
to claiming you know google.com into the Bitcoin before you,

981
01:01:00,790 --> 01:01:03,130
and now then I own google.com,

982
01:01:03,370 --> 01:01:05,380
and so to avoid that problem,

983
01:01:05,560 --> 01:01:09,370
you first actually have to enter the hash into the Bitcoin chain,

984
01:01:09,640 --> 01:01:13,150
then you wait a while to make sure that the,

985
01:01:13,650 --> 01:01:17,610
that that record sits in the Bitcoin blockchain,

986
01:01:17,760 --> 01:01:20,310
you know have six whatever ten blocks

987
01:01:20,490 --> 01:01:22,200
and then after that you sure,

988
01:01:22,200 --> 01:01:27,390
like you burn the name in the, as they call in the blockchain,

989
01:01:27,630 --> 01:01:30,210
at that point you actually do the actual registration.

990
01:01:31,770 --> 01:01:33,240
I've got a question regarding that.

991
01:01:35,070 --> 01:01:36,090
So what, what,

992
01:01:36,270 --> 01:01:38,280
why is it not possible for an attacker

993
01:01:38,280 --> 01:01:41,850
to say pre-compute [] with the hash of google.com,

994
01:01:41,880 --> 01:01:43,920
and then look through the blockchain,

995
01:01:43,920 --> 01:01:45,870
and see if someone posted a hash of google.

996
01:01:46,080 --> 01:01:47,580
Yeah, yeah absolutely,

997
01:01:47,580 --> 01:01:50,910
yeah, so absolutely you know there's slightly more sophisticated than this,

998
01:01:50,910 --> 01:01:52,320
you know just purely hash,

999
01:01:52,320 --> 01:01:54,150
presumably a bunch of other arguments that go into,

1000
01:01:54,150 --> 01:01:55,410
it including a nonce or something,

1001
01:01:58,330 --> 01:02:00,070
otherwise, you could make a dictionary, right.

1002
01:02:06,870 --> 01:02:09,000
In some ways, this is really not their invention,

1003
01:02:09,000 --> 01:02:11,310
but as I said before,

1004
01:02:11,310 --> 01:02:16,370
it came out of, came out of a Namecoin.

1005
01:02:22,880 --> 01:02:28,880
Okay, so let's you know go back to the sort of collaborative apps,

1006
01:02:28,880 --> 01:02:38,090
for collaborative, collaborative decentralized applications.

1007
01:02:47,430 --> 01:02:50,070
So just go back to our todo list as an example,

1008
01:02:50,400 --> 01:02:53,220
and just to see you know how it really would work,

1009
01:02:53,250 --> 01:02:56,160
you know so sketch out again, how it would work,

1010
01:02:56,550 --> 01:02:59,010
so basically with two users, correct,

1011
01:02:59,070 --> 01:03:01,470
running you know the todo list app,

1012
01:03:06,030 --> 01:03:08,400
here U1, here U2,

1013
01:03:14,110 --> 01:03:17,290
and they basically exchanged some information with each other,

1014
01:03:17,410 --> 01:03:19,330
basically saying are in some way,

1015
01:03:19,330 --> 01:03:21,490
U1 has learned about U2's name,

1016
01:03:21,490 --> 01:03:23,410
and U2 has learned about U1's name.

1017
01:03:25,120 --> 01:03:27,790
And then sort of that step, of course has to happen,

1018
01:03:27,790 --> 01:03:29,350
it has to happen securely,

1019
01:03:29,350 --> 01:03:32,890
in the sense, that U1 really need to know that actually is U2's name,

1020
01:03:33,190 --> 01:03:33,820
then they can,

1021
01:03:34,500 --> 01:03:39,570
U1, U1 can look up U2's name,

1022
01:03:42,900 --> 01:03:44,730
you know get its zonefile for that,

1023
01:03:47,470 --> 01:03:51,100
find the entry for say the todo list in the zonefile,

1024
01:03:54,220 --> 01:03:57,400
you know zonefile also contains you know the public key,

1025
01:04:00,550 --> 01:04:01,780
and this might be not,

1026
01:04:01,780 --> 01:04:05,410
like you know U2 might have many public keys, private keys,

1027
01:04:05,440 --> 01:04:08,530
because you probably don't want to have one master private key,

1028
01:04:08,530 --> 01:04:09,520
that you use for everything,

1029
01:04:09,520 --> 01:04:11,980
because if you use that one master private key

1030
01:04:11,980 --> 01:04:14,080
or somebody still you're in bad shape,

1031
01:04:14,380 --> 01:04:16,570
so typically I think in a block, in blockchain,

1032
01:04:16,570 --> 01:04:19,780
there should have a private key per application.

1033
01:04:20,560 --> 01:04:25,870
So you know U1 basically look at U2's name, looks up in zonefile,

1034
01:04:25,870 --> 01:04:29,380
but todo list public key and URI

1035
01:04:31,420 --> 01:04:34,540
you know through the Blockstack file system,

1036
01:04:34,690 --> 01:04:37,480
which tracks away the different storage providers,

1037
01:04:37,480 --> 01:04:42,070
and actually retrieve you know the actual name, the actual file,

1038
01:04:43,990 --> 01:04:45,640
you know check the signature on the file,

1039
01:04:45,640 --> 01:04:46,870
maybe version numbers,

1040
01:04:46,930 --> 01:04:54,220
and and then basically use that to construct you know the todo list from U2,

1041
01:04:54,220 --> 01:04:55,720
and worked out with U1's,

1042
01:04:55,720 --> 01:04:58,990
and similarly you know you basically U2 is exactly the same way thing,

1043
01:04:58,990 --> 01:05:00,430
you know as U1's name,

1044
01:05:02,120 --> 01:05:07,940
and [] goes off and you know which is U1's todo list,

1045
01:05:07,940 --> 01:05:13,040
and you know that way, they can have a collaborative application,

1046
01:05:13,280 --> 01:05:17,270
and so for example when U2 updates its file,

1047
01:05:17,270 --> 01:05:21,530
then, you know periodically U1's app you know goes

1048
01:05:21,530 --> 01:05:25,310
and retrieves the new, retrieves the todo list,

1049
01:05:25,310 --> 01:05:26,900
and just see if there are any updates.

1050
01:05:30,870 --> 01:05:31,890
Does this sort of makes sense?

1051
01:05:34,670 --> 01:05:35,480
You see here,

1052
01:05:35,480 --> 01:05:39,260
I think there's like one of these central points of decentralized applications,

1053
01:05:39,560 --> 01:05:44,090
this applications is building you know quite a different way,

1054
01:05:44,090 --> 01:05:46,970
than the ones that we're talking about very early on, correct,

1055
01:05:46,970 --> 01:05:50,990
if we go back to this picture of the centralized site,

1056
01:05:51,140 --> 01:05:54,740
that we're building a todo list application, correct,

1057
01:05:54,740 --> 01:06:03,940
in the database, have the U1's todo list and U2's todo list,

1058
01:06:08,440 --> 01:06:10,870
and yeah you know like the todo list app,

1059
01:06:11,170 --> 01:06:15,250
you know basically you know retrieve these the content todo list

1060
01:06:15,250 --> 01:06:16,690
with a simple SQL query,

1061
01:06:16,960 --> 01:06:19,570
and you know put them together, actually presented to the user,

1062
01:06:19,990 --> 01:06:23,050
when we see that in this decentralized scheme,

1063
01:06:23,200 --> 01:06:25,420
and it was quite a bit more mechanism involved,

1064
01:06:25,420 --> 01:06:26,560
to actually make this happen,

1065
01:06:26,800 --> 01:06:28,390
and in the program,

1066
01:06:28,390 --> 01:06:35,980
it doesn't really have the same easy SQL interface as the centralized case.

1067
01:06:36,840 --> 01:06:41,010
So I think this is one of sort of maybe the sticking points

1068
01:06:41,010 --> 01:06:42,600
with these decentralized applications,

1069
01:06:42,630 --> 01:06:46,440
how can you make them as easy to write as decentralized versions.

1070
01:06:52,490 --> 01:06:54,590
Okay, so I want to leave some time this time around,

1071
01:06:54,590 --> 01:06:55,850
instead of do breakout rooms,

1072
01:06:55,880 --> 01:07:00,230
leave some time around time for questions or discussion,

1073
01:07:00,440 --> 01:07:05,780
but since this is a little bit more of sort of provoking type exercise,

1074
01:07:05,780 --> 01:07:08,240
than an exercise in,

1075
01:07:08,270 --> 01:07:10,100
well, here's a hard technical problem,

1076
01:07:10,100 --> 01:07:11,240
here's the right solution,

1077
01:07:11,240 --> 01:07:12,560
here's learn the right solution,

1078
01:07:12,560 --> 01:07:13,220
and then use it.

1079
01:07:13,980 --> 01:07:19,320
So, you know just want to hear people's opinion or questions

1080
01:07:19,320 --> 01:07:23,730
about any aspect of these decentralized applications versus centralized,

1081
01:07:23,730 --> 01:07:27,700
then or the particular design for Blockstack or any other issue,

1082
01:07:27,700 --> 01:07:29,260
and we can debate it together.

1083
01:07:32,280 --> 01:07:35,670
Wait, so what's the main difficulty in,

1084
01:07:35,670 --> 01:07:41,940
instead of using like a file system API to use like a relational database?

1085
01:07:42,740 --> 01:07:43,490
Well, how do you write,

1086
01:07:43,490 --> 01:07:47,990
how do you present the world wide relational database,

1087
01:07:48,920 --> 01:07:51,080
all these user files,

1088
01:07:51,650 --> 01:07:53,000
all these files will be different users,

1089
01:07:53,000 --> 01:07:56,990
live in all kinds of different storage providers,

1090
01:07:56,990 --> 01:08:01,160
and you know you can't like do whatever,

1091
01:08:01,160 --> 01:08:05,000
you can't do select across all the storage providers,

1092
01:08:05,000 --> 01:08:05,870
that be crazy,

1093
01:08:07,850 --> 01:08:10,910
you couldn't also download all the user data to your computer,

1094
01:08:10,910 --> 01:08:12,230
because that would be too expensive.

1095
01:08:12,960 --> 01:08:19,700
What about like, like a linked data database?

1096
01:08:20,120 --> 01:08:27,650
I think this is [] researcher actually to pursue, right,

1097
01:08:27,650 --> 01:08:33,750
but you could actually built sort of scalable database infrastructure,

1098
01:08:33,750 --> 01:08:36,840
where users still control their own data having different locations again,

1099
01:08:36,840 --> 01:08:39,660
and provide sort of relational data type interface,

1100
01:08:41,250 --> 01:08:43,590
certainly Blockstack Blockstack doesn't offer to you.

1101
01:08:48,190 --> 01:08:49,660
Yes, another question is,

1102
01:08:49,750 --> 01:08:55,750
like what are the benefits of this decentralized PKI versus like web of trust PKI,

1103
01:08:55,750 --> 01:08:57,460
which I guess is also decentralized.

1104
01:08:57,520 --> 01:09:02,920
Yeah, so other, maybe some points here, correct,

1105
01:09:03,190 --> 01:09:07,150
you know there's other Web of trust PKI,

1106
01:09:07,150 --> 01:09:12,710
Web of trust PKIs,

1107
01:09:13,100 --> 01:09:21,350
you know, I mean the one, I'm most familiar with is is Keybase,

1108
01:09:24,970 --> 01:09:26,770
I think we should mention a couple of times before,

1109
01:09:26,860 --> 01:09:32,410
and you know Keybase actually we haven't talked to this in great detail,

1110
01:09:32,410 --> 01:09:35,800
but one of the things that's also challenging these kind of systems,

1111
01:09:35,800 --> 01:09:37,960
is like how do you represent groups of users,

1112
01:09:38,350 --> 01:09:40,420
like we saw a little bit in the SUNDR paper,

1113
01:09:40,600 --> 01:09:44,050
where gonna have group names, public keys for the group names,

1114
01:09:44,050 --> 01:09:47,020
and how to create them and manage them and actually stick them in,

1115
01:09:47,020 --> 01:09:52,990
how do you incorporate those in a in the chain of records, name records,

1116
01:09:53,170 --> 01:09:56,350
and Keybase is really really fought out story for that,

1117
01:09:56,860 --> 01:10:01,750
and you know actually a very impressive probably you know the truth,

1118
01:10:02,220 --> 01:10:08,130
probably, probably considered the best sort of decentralized you know PKI out there,

1119
01:10:09,150 --> 01:10:10,170
and the most thought out,

1120
01:10:10,170 --> 01:10:11,640
they're probably most widely used.

1121
01:10:18,440 --> 01:10:21,830
So are there any benefits of doing it of like Blockstack method,

1122
01:10:21,830 --> 01:10:23,930
or is it just more extensible?

1123
01:10:23,930 --> 01:10:26,900
Well, one of the things that actually Blockstack get correct is,

1124
01:10:26,900 --> 01:10:29,420
is this uniqueness properties,

1125
01:10:29,420 --> 01:10:32,720
because the Web of trust, there's basically not a global naming system,

1126
01:10:32,720 --> 01:10:36,500
you know like you know it is like my todo list or my contact list,

1127
01:10:36,950 --> 01:10:40,100
and you know whatever who I name,

1128
01:10:40,790 --> 01:10:44,270
if I have a name John for some particular public key, that is my John,

1129
01:10:44,570 --> 01:10:49,010
and if I sent John to you is like string John,

1130
01:10:49,010 --> 01:10:53,960
and it probably resolve different differently in your contact list than mine.

1131
01:10:55,280 --> 01:10:59,390
So, in fact, so Keybase much more is decentralized,

1132
01:10:59,390 --> 01:11:03,020
but it doesn't really go for these global unique names,

1133
01:11:03,930 --> 01:11:06,960
this case, that you know Keybase once in a while publishes,

1134
01:11:06,960 --> 01:11:09,450
the hash of all the names,

1135
01:11:09,480 --> 01:11:15,300
of the complete Merkle tree of all names in in blockchain too,

1136
01:11:15,300 --> 01:11:18,810
so you can verify what the Keybase actually is not playing the games,

1137
01:11:19,230 --> 01:11:22,950
but you know, it's much more,

1138
01:11:22,950 --> 01:11:24,600
it doesn't really have globally unique names.

1139
01:11:30,000 --> 01:11:31,890
Sorry, just a clarification question,

1140
01:11:31,920 --> 01:11:33,600
earlier on in the lecture,

1141
01:11:33,600 --> 01:11:36,090
you mentioned how users have the,

1142
01:11:36,300 --> 01:11:39,150
basically they can choose who to show their data to

1143
01:11:39,390 --> 01:11:43,470
or who they give access to their data to,

1144
01:11:43,740 --> 01:11:45,480
but I'm not quite sure I see,

1145
01:11:45,480 --> 01:11:48,600
how that's implemented within that system.

1146
01:11:50,750 --> 01:11:52,790
Yeah, there are the way,

1147
01:11:52,790 --> 01:11:53,780
one way to do it

1148
01:11:53,780 --> 01:11:57,590
and I don't know exactly what to Blockstack that does is,

1149
01:11:57,590 --> 01:12:01,280
that you encrypt the same data for different users,

1150
01:12:01,310 --> 01:12:06,620
so if you wanna share your data only with user 1 or user 2,

1151
01:12:07,050 --> 01:12:12,720
then, you encrypt you know with the public keys of user 1 user 2,

1152
01:12:13,080 --> 01:12:15,240
and then those are the only two that can decrypt it,

1153
01:12:18,960 --> 01:12:20,850
and so that gives you access control lists.

1154
01:12:25,850 --> 01:12:30,050
I see, so you'd have to for each person you wanted to give the data to,

1155
01:12:30,050 --> 01:12:32,780
you have to encrypt it with their public key.

1156
01:12:34,240 --> 01:12:36,280
And you can get more sophisticated about this,

1157
01:12:36,280 --> 01:12:37,960
you know you can actually have group keys,

1158
01:12:38,350 --> 01:12:42,940
and you know give a group of users you know actually have a lock box,

1159
01:12:43,330 --> 01:12:45,700
that has a group key in it,

1160
01:12:45,700 --> 01:12:50,470
and you increase the lock box with the different users you know public keys,

1161
01:12:50,470 --> 01:12:52,570
and then they get access to that lock box,

1162
01:12:52,570 --> 01:12:53,650
they get the key out of it,

1163
01:12:53,650 --> 01:12:54,970
and then they can decrypt the key,

1164
01:12:54,970 --> 01:12:59,410
so you only have to encrypt the data only once instead of multiple times,

1165
01:13:00,320 --> 01:13:03,470
and you have to decrypt, the encrypt lock box multiple times.

1166
01:13:04,540 --> 01:13:05,200
Thank you.

1167
01:13:08,040 --> 01:13:12,990
That would be down at the level of the content of the zonefile, right?

1168
01:13:13,770 --> 01:13:15,870
Yeah, presumably

1169
01:13:15,870 --> 01:13:20,280
or may be the key that zonefiles you know the key for the lock box, if you will,

1170
01:13:22,200 --> 01:13:24,360
and again I'm not actually a hundred percent sure exactly

1171
01:13:24,360 --> 01:13:34,600
how Blockstack Blockstack file system does actually control,

1172
01:13:34,600 --> 01:13:35,440
what it does it all,

1173
01:13:37,340 --> 01:13:39,860
but other people have done these kinds of designs.

1174
01:13:41,930 --> 01:13:46,280
Do you think system like this be able to compete with like the centralized model

1175
01:13:46,310 --> 01:13:48,950
in terms of performance or scalability,

1176
01:13:49,160 --> 01:13:50,030
and what would it take.

1177
01:13:50,750 --> 01:13:55,140
I, I don't know, good question,

1178
01:13:55,200 --> 01:13:57,240
I don't really know the answer,

1179
01:13:57,240 --> 01:13:58,020
it's the case, correct,

1180
01:13:58,020 --> 01:14:00,840
like even the simplest size is not that easy to scale,

1181
01:14:00,870 --> 01:14:03,420
you know we've read quite a number of papers, right

1182
01:14:03,420 --> 01:14:08,790
to see how, how to make them scale between millions of users,

1183
01:14:09,150 --> 01:14:13,400
and so you know both,

1184
01:14:13,400 --> 01:14:17,060
it's getting anything to a large large number of users is not easy,

1185
01:14:17,630 --> 01:14:22,970
and certainly in the case with decentralized apps,

1186
01:14:22,970 --> 01:14:24,110
not gonna be easy either,

1187
01:14:24,110 --> 01:14:26,570
but on the other hand, like if there's not by sharing,

1188
01:14:26,900 --> 01:14:30,440
like the user 1 actually only have to share to do 10 other users,

1189
01:14:30,950 --> 01:14:32,660
that's probably not be a big issue, correct,

1190
01:14:32,690 --> 01:14:35,720
in some ways, you can think about the decentralized architecture

1191
01:14:35,750 --> 01:14:37,190
is basically sharded by user,

1192
01:14:42,280 --> 01:14:45,580
and each app you know runs in one of user's computers,

1193
01:14:46,380 --> 01:14:51,080
so you don't need maybe data centers of caches,

1194
01:14:57,370 --> 01:14:59,230
so I don't know what the answer to that question actually is,

1195
01:15:00,850 --> 01:15:02,680
I will not be able to give you a definitely answer.

1196
01:15:07,120 --> 01:15:08,980
It's clearly the case that people have demonstrated

1197
01:15:08,980 --> 01:15:14,200
bigger scalability of those centralized designs,

1198
01:15:14,200 --> 01:15:17,050
at least so far, we've seen in the decentralized once,

1199
01:15:17,050 --> 01:15:18,580
but one reason of that of course is

1200
01:15:18,580 --> 01:15:23,170
that the centralized designs are widely used,

1201
01:15:23,170 --> 01:15:26,800
the most popular, the most deployed cases.

1202
01:15:28,430 --> 01:15:33,170
I think the, to me the decentralized design is just intriguing design,

1203
01:15:33,590 --> 01:15:36,140
and that it could make to work,

1204
01:15:36,140 --> 01:15:37,250
you know it would be pretty cool.

1205
01:15:45,980 --> 01:15:52,940
Any other thoughts that people might have for, or like to argue about?

1206
01:15:59,330 --> 01:16:04,480
I still feel like the storage aspect is,

1207
01:16:04,510 --> 01:16:07,990
like the thing that that William was pointing out,

1208
01:16:07,990 --> 01:16:13,960
where like you maybe have an immutable file, that's the the user information,

1209
01:16:13,960 --> 01:16:17,200
but the mutable file that you have somewhere else,

1210
01:16:17,650 --> 01:16:21,430
is like a huge problem,

1211
01:16:22,160 --> 01:16:22,880
in so much that,

1212
01:16:22,880 --> 01:16:25,400
like I I don't really understand,

1213
01:16:25,730 --> 01:16:27,980
how you can assure redundancy

1214
01:16:27,980 --> 01:16:33,650
for a large amount of mutable storage that you might have.

1215
01:16:34,100 --> 01:16:38,120
Yeah, I think the answer the redundancy maybe not that tough,

1216
01:16:38,150 --> 01:16:40,640
and I think the user is responsible for redundancy,

1217
01:16:41,030 --> 01:16:45,470
so if you like to use, you own it todo list file,

1218
01:16:45,780 --> 01:16:48,330
and your job to replicate it you know multiple times,

1219
01:16:48,330 --> 01:16:51,810
so the Blockstack storage servers do that for you,

1220
01:16:52,050 --> 01:16:56,520
but you got to arrange you know basically for space

1221
01:16:56,520 --> 01:17:00,540
and a different storage providers to do that.

1222
01:17:01,450 --> 01:17:02,470
And so I think in the paper,

1223
01:17:02,470 --> 01:17:03,040
they talk about like,

1224
01:17:03,040 --> 01:17:06,760
oh you replicated that maybe Google Drive and S3,

1225
01:17:07,640 --> 01:17:10,430
and presumably S3 internally does its own replication, right,

1226
01:17:10,430 --> 01:17:12,920
so hopefully you know maybe just actually thought only S3,

1227
01:17:12,920 --> 01:17:14,180
and it should be pretty reliable,

1228
01:17:14,890 --> 01:17:18,070
probably more reliable than storing data on your SSD, in your laptop.

1229
01:17:22,080 --> 01:17:23,370
The zonefiles are small,

1230
01:17:23,370 --> 01:17:24,990
so they're just widely replicated,

1231
01:17:25,050 --> 01:17:27,900
and you don't have to trust the storage provider.

1232
01:17:54,240 --> 01:17:55,260
Any other thoughts?

1233
01:17:58,090 --> 01:18:00,100
I was thinking it's a little bit wasteful,

1234
01:18:00,100 --> 01:18:02,440
that you have in order to register a name,

1235
01:18:02,440 --> 01:18:05,350
and to use this name system, you have to pay,

1236
01:18:07,440 --> 01:18:12,810
yeah, so I was thinking obviously on a blockchain based system,

1237
01:18:12,810 --> 01:18:14,940
you have to incentivize the miners,

1238
01:18:14,940 --> 01:18:18,390
but maybe there's a different cheaper way.

1239
01:18:19,600 --> 01:18:22,450
Yeah, yeah, I I'm not sure,

1240
01:18:22,480 --> 01:18:25,870
it seems in some way, that sort of the currency,

1241
01:18:25,870 --> 01:18:29,080
and this is sort of very [],

1242
01:18:29,440 --> 01:18:31,480
so a reason, exactly for the reason you mentioned,

1243
01:18:31,480 --> 01:18:34,270
because you have miners and you have to incentivize them,

1244
01:18:35,060 --> 01:18:37,640
I think in general with these transactions are pretty cheap,

1245
01:18:37,670 --> 01:18:40,190
you know basically you know you have to just pay enough, correct,

1246
01:18:40,190 --> 01:18:43,190
the miners willing to include your transaction,

1247
01:18:44,300 --> 01:18:46,740
and you know today,

1248
01:18:46,740 --> 01:18:51,270
you also pay for if you want to register a name in in DNS,

1249
01:18:51,270 --> 01:18:54,970
you know actually quite a bit of money, not free,

1250
01:18:58,410 --> 01:19:00,750
I don't know exactly how economics would work out,

1251
01:19:00,750 --> 01:19:03,870
but the obviously clear that,

1252
01:19:03,870 --> 01:19:05,640
this is actually a much more expensive way of doing it,

1253
01:19:05,670 --> 01:19:08,550
other than maybe you burning the planet within electricity,

1254
01:19:09,430 --> 01:19:10,840
at least in the Bitcoin case,

1255
01:19:10,870 --> 01:19:16,840
but maybe you should use a one of the stake-of-work ledgers,

1256
01:19:16,840 --> 01:19:18,880
instead of the,

1257
01:19:20,360 --> 01:19:26,380
okay, proof-of-stake instead of these proof-of-work ledgers.

1258
01:19:29,960 --> 01:19:33,740
It will be possible just to swap it out, in place of.

1259
01:19:33,770 --> 01:19:37,460
I think I think this is what the papers argue, correct,

1260
01:19:37,460 --> 01:19:42,290
their particular design is really not very dependent on the underlying blockchain,

1261
01:19:42,290 --> 01:19:44,270
and they could easily switch to another blockchain,

1262
01:19:44,270 --> 01:19:46,790
in fact this is the second blockchain that worked out, correct,

1263
01:19:46,790 --> 01:19:49,490
they first use Namecoin and then they switch to Bitcoin,

1264
01:19:50,120 --> 01:19:51,200
and I think the argument in the paper is

1265
01:19:51,200 --> 01:19:54,590
making we could actually switch to another blockchain, we wanted to.

1266
01:20:10,080 --> 01:20:12,540
What in particular is stored in the name history?

1267
01:20:14,570 --> 01:20:15,260
In the,

1268
01:20:16,610 --> 01:20:19,760
sorry, what, what's the question really?

1269
01:20:20,230 --> 01:20:23,080
Oh, sorry, the name history in the Blockstack database.

1270
01:20:23,790 --> 01:20:24,510
Yeah, this, this,

1271
01:20:24,510 --> 01:20:27,510
yeah I don't really mean like these three different guys.

1272
01:20:28,100 --> 01:20:28,820
Yeah.

1273
01:20:28,820 --> 01:20:30,170
Different versions of the zonefile.

1274
01:20:31,610 --> 01:20:34,190
Oh, so just like version numbers.

1275
01:20:34,310 --> 01:20:36,350
Yeah, I think so, I'm not hundred percent sure,

1276
01:20:37,190 --> 01:20:37,790
but the,

1277
01:20:38,590 --> 01:20:41,560
but like these correspond to the three updates to the zonefile, correct,

1278
01:20:41,560 --> 01:20:43,090
here's number one, here's number two,

1279
01:20:45,350 --> 01:20:47,630
maybe they keep using version of zonefile around.

1280
01:20:59,720 --> 01:21:03,410
Any other topics that people want to bring up?

1281
01:21:09,300 --> 01:21:11,340
Okay, so we end the sort of time anyway,

1282
01:21:11,760 --> 01:21:13,260
okay, so let's say why don't we stop here,

1283
01:21:13,260 --> 01:21:15,840
so people need to need to leave can leave,

1284
01:21:15,870 --> 01:21:19,650
and I'll see hopefully everybody on Thursday,

1285
01:21:19,650 --> 01:21:24,150
I'm going to see eight, we have eight design, eight projects,

1286
01:21:24,150 --> 01:21:28,230
and so the eight teams will present the on Thursday what they've done,

1287
01:21:28,740 --> 01:21:32,080
instead of lab lab 4,

1288
01:21:32,140 --> 01:21:35,710
and it should be and the the projects quite cool and interesting,

1289
01:21:35,710 --> 01:21:39,220
so hopefully you will be entertained,

1290
01:21:39,220 --> 01:21:41,380
and that makes concludes this lecture,

1291
01:21:41,380 --> 01:21:45,790
hopefully a bit of goal is a little bit [],

1292
01:21:45,790 --> 01:21:51,160
and you know sort of talk about designs, decentralized designs,

1293
01:21:51,160 --> 01:21:53,770
to the has, that's probably the user on their data,

1294
01:21:54,100 --> 01:21:58,030
and you know and we look in the context of Blockstack,

1295
01:21:58,030 --> 01:22:00,130
at least one particular design,

1296
01:22:00,370 --> 01:22:02,560
how they did naming in a way,

1297
01:22:02,560 --> 01:22:07,310
that gives global names, unique names, and human readable,

1298
01:22:08,030 --> 01:22:08,540
okay?

1299
01:22:08,630 --> 01:22:10,220
So that's the end of this lecture,

1300
01:22:10,250 --> 01:22:11,990
and then hopefully see you on Thursday,

1301
01:22:12,230 --> 01:22:13,790
which is going to be our final class meeting.

1302
01:22:18,300 --> 01:22:21,510
And if you have any questions, please feel free to stick around,

1303
01:22:22,290 --> 01:22:23,910
you can talk.

1304
01:22:24,500 --> 01:22:27,590
Professor, for presentation,

1305
01:22:27,860 --> 01:22:31,190
are we supposed to do something more of a demo,

1306
01:22:31,190 --> 01:22:34,580
or should we have slides prepared or combination both.

1307
01:22:34,610 --> 01:22:40,310
Yeah, we post some instructions,

1308
01:22:42,320 --> 01:22:45,410
you're pretty free to do so, what you wanna do,

1309
01:22:45,410 --> 01:22:48,860
you know the things you want to do is to convince you know the class,

1310
01:22:48,890 --> 01:22:52,340
you know what [] did and why is cool,

1311
01:22:52,950 --> 01:22:54,660
show demo is a good idea,

1312
01:22:54,930 --> 01:22:57,150
you don't have a ton of time,

1313
01:22:57,150 --> 01:22:58,920
so I think the typical thing to do is,

1314
01:22:58,920 --> 01:23:02,250
people have a few slides for explaining what they did,

1315
01:23:02,250 --> 01:23:03,930
and then maybe cook demos

1316
01:23:03,930 --> 01:23:05,790
to see how it actually materialized.

1317
01:23:06,980 --> 01:23:08,930
Great, okay, thanks.

1318
01:23:11,640 --> 01:23:12,750
Yeah, we don't expect you to

1319
01:23:12,750 --> 01:23:15,180
whatever in hours preparing for this, correct,

1320
01:23:15,660 --> 01:23:18,030
do we try to share what you've done.

1321
01:23:20,540 --> 01:23:23,780
Okay, thank you.

1322
01:23:25,060 --> 01:23:27,520
I just wanted to ask,

1323
01:23:27,670 --> 01:23:32,480
so it's like what is the reasoning behind,

1324
01:23:32,720 --> 01:23:38,600
just having just using the same Bitcoin the blockchain,

1325
01:23:39,120 --> 01:23:44,270
and just putting the, the transactions for the naming on there,

1326
01:23:44,720 --> 01:23:47,510
together with all the rest of the things, right.

1327
01:23:48,650 --> 01:23:53,870
I I think these are the papers,

1328
01:23:53,870 --> 01:23:56,000
so they started out building on top of Namecoin,

1329
01:23:56,490 --> 01:23:58,740
which is a special purpose ledger for naming,

1330
01:23:59,190 --> 01:24:03,750
and, and they discovered basically the,

1331
01:24:04,380 --> 01:24:08,250
[], what the security issues with namecoin,

1332
01:24:08,250 --> 01:24:11,340
one of them being actually not many miners,

1333
01:24:12,410 --> 01:24:17,240
so, it observes that basically there are miner pools

1334
01:24:17,240 --> 01:24:24,940
and basically have more than 50% of the capacity, and work capacity,

1335
01:24:24,940 --> 01:24:26,950
therefore you could do anything they wanted to do,

1336
01:24:26,950 --> 01:24:28,690
to the principle to the ledger,

1337
01:24:29,750 --> 01:24:34,220
and so they wanted ton sit on a blockchain that is widely used very popular,

1338
01:24:34,220 --> 01:24:36,680
and not easy to overtake by the adversary.

1339
01:24:38,410 --> 01:24:41,950
Okay, I remember the 51% yeah, remember.

1340
01:24:42,940 --> 01:24:44,290
Okay, makes sense.

1341
01:24:44,680 --> 01:24:47,860
And I also wanted to ask about,

1342
01:24:48,540 --> 01:24:54,390
the URIs, there URIs to, to the zonefile storage system

1343
01:24:54,390 --> 01:24:58,180
not just like S3 something something, right.

1344
01:24:58,210 --> 01:24:58,930
There could be,

1345
01:24:58,960 --> 01:25:01,420
the problem is something a little bit more general,

1346
01:25:01,420 --> 01:25:07,960
because it's actually interpreted by by Blockstack file system,

1347
01:25:07,960 --> 01:25:12,100
so and the Blockstack file system has backends for the different storage provider,

1348
01:25:12,100 --> 01:25:14,890
where S3 or Google Drive or whatever,

1349
01:25:15,370 --> 01:25:17,830
and so there's some naming schemes,

1350
01:25:17,830 --> 01:25:22,720
the Blockstack file system can interpret,

1351
01:25:22,720 --> 01:25:28,960
and then figure out how to retrieve the right file from the the correct backend.

1352
01:25:31,130 --> 01:25:33,560
This is just to make them the same.

1353
01:25:33,650 --> 01:25:37,280
Yeah, excally, usually an application writer doesn't really want doesn't care,

1354
01:25:37,280 --> 01:25:39,170
whether it's stored S3 or Google Drive,

1355
01:25:39,170 --> 01:25:41,660
or we should you where [] have to deal with that.

1356
01:25:43,180 --> 01:25:44,650
Thank you so much.

1357
01:25:45,860 --> 01:25:46,460
You're welcome.

1358
01:25:47,350 --> 01:25:48,250
I had a question about

1359
01:25:48,250 --> 01:25:52,300
why Zooko's triangle is kind of like,

1360
01:25:52,930 --> 01:25:54,430
I think that people think about a lot like,

1361
01:25:54,430 --> 01:25:59,590
it seems that you can have a client side interpret the human non meaningful data,

1362
01:25:59,950 --> 01:26:02,050
that you can make kind of all the data human meaningful,

1363
01:26:02,260 --> 01:26:04,450
on the client side to the to the user,

1364
01:26:04,830 --> 01:26:07,740
and so I wasn't completely sure like what,

1365
01:26:08,780 --> 01:26:11,000
like what the innovation here is

1366
01:26:11,000 --> 01:26:14,660
or why people, why this is a trade off.

1367
01:26:15,410 --> 01:26:19,010
Yeah, well, I guess this is the best slide, I can give you,

1368
01:26:19,010 --> 01:26:21,050
were I can give you a whole bunch of naming examples,

1369
01:26:21,050 --> 01:26:22,820
basically two of three, but not all three,

1370
01:26:23,680 --> 01:26:27,610
and sort of for example like you know,

1371
01:26:27,610 --> 01:26:32,420
the you know we talked about Keybase, correct,

1372
01:26:32,420 --> 01:26:36,350
decentralized, you knew over not unique,

1373
01:26:38,680 --> 01:26:39,730
and now you're gonna argue,

1374
01:26:39,730 --> 01:26:42,130
when it's that important to have globally unique names,

1375
01:26:42,710 --> 01:26:44,750
it's like whatever it's a globally unique name,

1376
01:26:44,750 --> 01:26:46,700
like 6.824 what does it mean,

1377
01:26:47,780 --> 01:26:49,040
and who's associated with it,

1378
01:26:49,160 --> 01:26:50,690
so if you're coming from that angle,

1379
01:26:50,690 --> 01:26:52,040
I think that's a very valid question.

1380
01:26:57,190 --> 01:26:57,670
Thank you.

1381
01:26:59,940 --> 01:27:03,180
So one of the things that has always kind of bothered me,

1382
01:27:03,180 --> 01:27:06,090
when we're reading through these blockchain type of papers is,

1383
01:27:06,270 --> 01:27:08,160
like what happens in a hundred years,

1384
01:27:08,160 --> 01:27:12,120
when the ledger gets to like multiple tera,

1385
01:27:12,240 --> 01:27:15,120
I don't know if, yeah like multiple terabytes or something.

1386
01:27:18,320 --> 01:27:19,010
Yeah.

1387
01:27:19,010 --> 01:27:21,230
Do we not, do we not having escape plan,

1388
01:27:21,230 --> 01:27:22,730
like what's gonna happen then?

1389
01:27:23,620 --> 01:27:25,210
I don't know,

1390
01:27:26,490 --> 01:27:30,510
hard to speculate on the hundred years out into the future,

1391
01:27:30,690 --> 01:27:32,010
I presume, what would you do,

1392
01:27:32,010 --> 01:27:34,110
so you put a checkpoint in the,

1393
01:27:34,620 --> 01:27:38,340
yeah, I can imagine multiple schemes for getting out of this,

1394
01:27:38,340 --> 01:27:41,800
one you could make a checkpoint of the state,

1395
01:27:41,800 --> 01:27:43,120
you know build on the ledger,

1396
01:27:43,120 --> 01:27:46,210
and include the hash that checkpoint into the ledger,

1397
01:27:46,210 --> 01:27:50,530
and then as long as you can replicate the checkpoint widely,

1398
01:27:50,950 --> 01:27:53,560
and then you can basically start running from the checkpoint

1399
01:27:53,560 --> 01:27:54,580
to cut out the beginning,

1400
01:27:55,300 --> 01:27:57,550
this is like like you were doing in lab,

1401
01:27:57,790 --> 01:27:59,320
you know Raft doing, correct.

1402
01:28:01,370 --> 01:28:04,640
Would the party that does that have to be trusted or?

1403
01:28:05,830 --> 01:28:08,920
What we did,

1404
01:28:10,790 --> 01:28:13,220
presumably client 1 go have to go along,

1405
01:28:14,380 --> 01:28:17,200
and realize that they should get that checkpoint,

1406
01:28:17,200 --> 01:28:20,020
you'll be able to construct you know the current state of the world,

1407
01:28:20,880 --> 01:28:24,690
so I presume that which requires some critical changes, probably some fork.

1408
01:28:28,990 --> 01:28:30,520
This is not a huge issue, correct,

1409
01:28:31,180 --> 01:28:32,320
usually the rate of Bitcoin,

1410
01:28:32,320 --> 01:28:33,940
because like you know the number of transactions

1411
01:28:33,940 --> 01:28:36,610
for seconds you can do is actually small,

1412
01:28:37,090 --> 01:28:38,650
like if you remember from the Bitcoin paper,

1413
01:28:38,650 --> 01:28:42,160
there's some calculation like you know what the total size would be,

1414
01:28:42,190 --> 01:28:43,000
if you do this,

1415
01:28:43,550 --> 01:28:47,480
furthermore and you remember correctly from the Bitcoin paper,

1416
01:28:47,480 --> 01:28:48,680
there's a bunch of optimizations,

1417
01:28:48,920 --> 01:28:54,290
where you don't really have to remember every transaction for every coin,

1418
01:28:54,290 --> 01:28:57,770
you basically have to remember the last transaction for every coin,

1419
01:28:58,100 --> 01:28:59,240
and you could do that

1420
01:28:59,240 --> 01:29:03,600
by just remembering the block headers instead of the complete block,

1421
01:29:06,970 --> 01:29:09,670
so Bitcoin have sort of a built-in solution to this problem.

1422
01:29:10,860 --> 01:29:15,180
I see, so the main bottleneck is more or less when new machines come up,

1423
01:29:15,180 --> 01:29:16,800
they need to verify the [],

1424
01:29:17,130 --> 01:29:21,030
but after that, then things are relatively more optimized.

1425
01:29:23,170 --> 01:29:23,710
Thank you.

1426
01:29:35,760 --> 01:29:37,050
Okay, that for today,

1427
01:29:39,270 --> 01:29:40,620
thank you all, see you Thursday.

