1
00:00:00,000 --> 00:00:03,420
下午好，傍晚好，晚上好，无论你在哪里。

2
00:00:03,870 --> 00:00:06,450
所以今天我想谈谈 FaRM ，

3
00:00:06,570 --> 00:00:09,150
这是一篇 2015 年的论文，

4
00:00:09,150 --> 00:00:10,890
是比较近的一篇论文，

5
00:00:11,250 --> 00:00:12,690
这是一篇研究论文，

6
00:00:12,720 --> 00:00:15,210
这个研究论文的主题是，

7
00:00:15,210 --> 00:00:18,330
试图探索一些想法和技术

8
00:00:18,330 --> 00:00:20,430
来获得高性能的事务，

9
00:00:31,700 --> 00:00:33,410
高性能，

10
00:00:33,410 --> 00:00:37,520
为了确保我们，是我们想要的，

11
00:00:37,700 --> 00:00:39,590
高性能意味着，

12
00:00:39,590 --> 00:00:44,730
他们获得 1.4 亿个事务每秒，

13
00:00:44,790 --> 00:00:52,060
在 TATP 基准上，使用 90 台机器，

14
00:00:58,620 --> 00:01:01,410
所以这个数字是否令人印象深刻，

15
00:01:01,410 --> 00:01:03,480
当然取决于你知道的数字，

16
00:01:03,480 --> 00:01:05,010
有人还记得，

17
00:01:05,010 --> 00:01:07,050
Spanner 每秒能处理多少事务吗？

18
00:01:16,220 --> 00:01:16,970
有人知道吗？

19
00:01:27,130 --> 00:01:29,200
所以如果我们记得那篇论文，

20
00:01:29,200 --> 00:01:31,690
那里发生多少事务，

21
00:01:31,960 --> 00:01:32,890
取决于你所做的，

22
00:01:32,890 --> 00:01:35,290
10 到 100 毫秒，

23
00:01:35,290 --> 00:01:41,800
所以每秒 10 到 100 个事务。

24
00:01:41,800 --> 00:01:46,210
所以， FaRM 可以处理的事务数量是

25
00:01:46,210 --> 00:01:48,490
在一个完全不同的数量级。

26
00:01:49,050 --> 00:01:52,200
部分是因为它们是完全不同的系统，

27
00:01:52,200 --> 00:01:56,550
Spanner 试图在全球范围内进行同步复制，

28
00:01:56,820 --> 00:02:00,240
而 FaRM 的一切都在一个数据中心运行。

29
00:02:04,560 --> 00:02:09,990
所以， FaRM 和 Spanner 针对的应用程序完全不同，

30
00:02:10,080 --> 00:02:16,500
Spanner 针对不能容忍数据中心崩溃的应用程序，

31
00:02:16,650 --> 00:02:20,730
比如 F1 广告服务数据库，

32
00:02:20,850 --> 00:02:23,490
Spanner 非常好，

33
00:02:23,520 --> 00:02:25,500
FaRM 更针对

34
00:02:25,500 --> 00:02:27,930
比如你是所有 MySQL

35
00:02:27,930 --> 00:02:32,310
或某种其他类型的应用数据库系统，

36
00:02:32,460 --> 00:02:36,090
你想要更高性能的事务，

37
00:02:36,300 --> 00:02:40,710
那么 FaRM 是一种可能的设计或可能的选择。

38
00:02:41,950 --> 00:02:44,590
它们提供了严格的可串行化，

39
00:02:48,370 --> 00:02:56,160
类似于 Spanner 提供的外部一致性。

40
00:02:56,990 --> 00:02:58,880
所以，整个目标是获得高性能，

41
00:02:58,880 --> 00:03:02,720
有很多想法会实现高性能。

42
00:03:02,930 --> 00:03:04,940
一个是，他们分片，

43
00:03:05,470 --> 00:03:09,600
这可能是他们使用的主要标准技术，

44
00:03:09,600 --> 00:03:11,130
这将给我们带来性能，

45
00:03:11,130 --> 00:03:15,450
例如，如果不同的记录在不同的分片上，

46
00:03:15,450 --> 00:03:18,300
事务触及不同的分片，

47
00:03:18,300 --> 00:03:20,940
然后这些事务可以并行运行，

48
00:03:21,030 --> 00:03:23,730
所以，如果你有 90 台机器，

49
00:03:23,730 --> 00:03:27,930
获得一台机器的性能的 90 倍。

50
00:03:28,520 --> 00:03:30,380
所以分片是一个起点，

51
00:03:30,890 --> 00:03:33,110
但他们走得更远，

52
00:03:33,350 --> 00:03:37,430
他们使用非易失性 DRAM ，

53
00:03:39,560 --> 00:03:45,620
这是为了避免不得不写入稳定存储设备的瓶颈，

54
00:03:45,620 --> 00:03:47,030
所以在他们的设计中，

55
00:03:47,030 --> 00:03:51,560
你不必写入关键路径到固态硬盘或磁盘，

56
00:03:51,650 --> 00:03:55,760
所以，他们避免了这样做的全部花费，

57
00:03:55,880 --> 00:03:57,290
这可能相当昂贵，

58
00:03:57,320 --> 00:04:02,500
例如，你可以考虑你的 Raft 实现，

59
00:04:02,500 --> 00:04:07,870
他们存储或者使数据持久化，

60
00:04:07,870 --> 00:04:11,410
通常情况下，在稳定的存储设备上进行持久化，

61
00:04:11,410 --> 00:04:15,940
几百毫秒的量级，

62
00:04:16,510 --> 00:04:21,250
几毫秒到十毫秒，

63
00:04:21,250 --> 00:04:22,900
如果你使用磁盘，

64
00:04:23,460 --> 00:04:26,400
一个 SSD 有几毫秒，

65
00:04:27,120 --> 00:04:29,880
所以，考虑到它们运作的时间，

66
00:04:29,880 --> 00:04:31,560
这种方式花费太高了。

67
00:04:31,590 --> 00:04:34,380
所以他们使用一些人称为非易失性 DRAM ，

68
00:04:34,380 --> 00:04:35,550
我们稍后会谈到这一点，

69
00:04:36,420 --> 00:04:41,730
这样就消除了存储访问成本。

70
00:04:41,940 --> 00:04:45,720
他们要解决的下两个瓶颈是

71
00:04:45,750 --> 00:04:48,780
CPU 瓶颈和网络瓶颈，

72
00:04:49,200 --> 00:04:52,740
要实现这一点，需要使用一种称为内核旁路的技术，

73
00:04:57,010 --> 00:05:01,360
这避免了操作系统与网卡交互，

74
00:05:01,600 --> 00:05:06,610
然后他们使用具有 RDMA 特殊功能的网卡，

75
00:05:10,530 --> 00:05:14,730
这允许网卡从远程服务器读取内存，

76
00:05:14,730 --> 00:05:17,820
而不必中断远程服务器，

77
00:05:18,420 --> 00:05:20,400
所以，这为我们提供了

78
00:05:20,400 --> 00:05:26,920
对远程服务器或远程内存的低延迟网络访问，

79
00:05:26,950 --> 00:05:29,260
这就是 FaRM 名称的来源,

80
00:05:29,260 --> 00:05:33,250
R 代表远程， M 代表内存， Fa 代表快速。

81
00:05:34,810 --> 00:05:39,370
所以，这些就是他们使用的技术，

82
00:05:39,430 --> 00:05:43,180
然后，为了能够真正利用这些技术，

83
00:05:43,360 --> 00:05:45,040
驱动他们设计，

84
00:05:45,040 --> 00:05:46,810
使用乐观并发控制，

85
00:05:47,220 --> 00:05:51,510
或 OCC ，这个的缩写，乐观的，

86
00:05:56,230 --> 00:05:59,380
与我们到目前为止看到的许多设计相比，

87
00:05:59,380 --> 00:06:04,030
它们使用通常被称为悲观并发控制方案，

88
00:06:04,030 --> 00:06:07,630
悲观控制方案获得锁

89
00:06:07,720 --> 00:06:13,030
在事务接触到对象时，

90
00:06:13,270 --> 00:06:16,570
所以当它们到达提交时间时，

91
00:06:16,720 --> 00:06:19,510
它们拥有所有相关对象的所有锁，

92
00:06:19,510 --> 00:06:21,430
继续并提交，

93
00:06:21,580 --> 00:06:24,520
而使用乐观并发控制，

94
00:06:24,520 --> 00:06:26,650
你不需要获取锁，

95
00:06:26,650 --> 00:06:28,030
特别是在 FaRM 中，

96
00:06:28,030 --> 00:06:31,840
你不需要在读事务中获取锁，

97
00:06:32,720 --> 00:06:35,300
当你执行提交的时候，

98
00:06:35,300 --> 00:06:36,410
你必须验证，

99
00:06:36,410 --> 00:06:40,340
你读取最近的对象，

100
00:06:40,550 --> 00:06:42,560
如果是这样，你可以提交，

101
00:06:42,560 --> 00:06:44,450
如果不是，你必须中止，

102
00:06:44,450 --> 00:06:45,680
也许还会再试一次。

103
00:06:46,530 --> 00:06:49,500
他们使用乐观并发控制的原因，

104
00:06:49,500 --> 00:06:50,400
我们稍后将会看到，

105
00:06:50,400 --> 00:06:53,580
是由他们想要使用 RDMA 这一事实驱动的。

106
00:06:56,820 --> 00:06:59,610
好的，那么最后一个部分是概述，

107
00:06:59,610 --> 00:07:01,140
这是一个研究原型，

108
00:07:05,250 --> 00:07:10,110
与 Spanner 不同，是已部署的系统，

109
00:07:10,170 --> 00:07:14,010
它一直在活跃地使用，

110
00:07:14,040 --> 00:07:17,850
FARM 是微软研究的产品，

111
00:07:18,120 --> 00:07:21,300
微软研究试图探索新想法，

112
00:07:21,480 --> 00:07:25,620
看看什么能获得更高的

113
00:07:25,740 --> 00:07:27,660
或很高的性能的事务系统，

114
00:07:27,660 --> 00:07:29,670
这是一项非常活跃的研究，

115
00:07:29,700 --> 00:07:34,050
人们喜欢拥有事务的力量，

116
00:07:34,230 --> 00:07:36,720
但是也想要性能。

117
00:07:40,430 --> 00:07:42,440
好的，这是一个简短的介绍，

118
00:07:42,440 --> 00:07:43,580
到目前为止，有什么问题吗？

119
00:07:49,860 --> 00:08:00,020
好的，让我们来谈谈 FaRM 的设置。

120
00:08:00,510 --> 00:08:11,710
所以这里有 90 台机器，

121
00:08:11,710 --> 00:08:15,310
它们通过高速数据中心网络连接，

122
00:08:15,340 --> 00:08:17,290
看其中一个，

123
00:08:17,590 --> 00:08:20,410
我把它画成一条线，

124
00:08:20,410 --> 00:08:22,630
当然，内部是一个交换网络，

125
00:08:23,020 --> 00:08:27,280
然后分片，

126
00:08:27,430 --> 00:08:31,480
数据分片在这些不同的机器上，

127
00:08:31,690 --> 00:08:36,970
根据分片的级别，一些也称为区域，

128
00:08:37,800 --> 00:08:42,380
所以区域是 2G 字节，

129
00:08:44,730 --> 00:08:46,290
这些区域分片在

130
00:08:46,290 --> 00:08:49,790
不同的网络，不同的机器上，

131
00:08:49,790 --> 00:08:51,620
区域在内存中，

132
00:08:52,010 --> 00:08:53,390
所以这是 DRAM ，

133
00:08:56,490 --> 00:08:59,730
而不是在磁盘上，

134
00:08:59,760 --> 00:09:04,920
所以，你的数据库的全部数据集

135
00:09:04,920 --> 00:09:09,240
必须与你使用的机器的联合 DRAM 相适应，

136
00:09:09,240 --> 00:09:11,580
如果你的数据集大于你当前的计算机集，

137
00:09:11,580 --> 00:09:13,620
你必须购买更多机器，拥有更多 DRAM ，

138
00:09:13,620 --> 00:09:14,550
这样它们才能适合。

139
00:09:16,150 --> 00:09:19,780
他们想使用 DRAM 的原因是，

140
00:09:19,780 --> 00:09:26,100
他们想要[]存储设备性能方面的瓶颈，

141
00:09:26,280 --> 00:09:29,880
当然，机器可能出现故障，

142
00:09:29,880 --> 00:09:32,730
如果机器出现故障，它会丢失 DRAM ，

143
00:09:32,850 --> 00:09:35,040
所以，他们使用复制，

144
00:09:35,250 --> 00:09:38,460
他们在多台机器上复制区域，

145
00:09:38,790 --> 00:09:41,910
一台机器是一个区域的 primary ，

146
00:09:42,210 --> 00:09:46,050
使区域可能被复制到另一台机器上，

147
00:09:46,230 --> 00:09:47,160
在备机上，

148
00:09:47,160 --> 00:09:52,690
所以使用主备进行复制，

149
00:09:52,900 --> 00:09:57,000
所以这是区域 1 ，区域 2 ，

150
00:09:57,000 --> 00:10:00,390
（2的）备份可能在（1的）主机的同一台机器上，

151
00:10:00,390 --> 00:10:02,730
作为区域 2 的备份，

152
00:10:03,090 --> 00:10:05,700
这里我们有区域 2 的主机。

153
00:10:06,710 --> 00:10:08,900
所以这决定了，

154
00:10:08,900 --> 00:10:11,390
一台机器出现内核 panic ，

155
00:10:11,390 --> 00:10:13,160
或者某个设备死机，

156
00:10:13,160 --> 00:10:16,250
或者只是因为其他原因而崩溃，

157
00:10:16,460 --> 00:10:19,130
然后还有第二台机器，

158
00:10:19,130 --> 00:10:22,220
它有数据的复制，并从那里继续进行。

159
00:10:23,120 --> 00:10:26,450
当然，我们需要某种方法来跟踪

160
00:10:26,450 --> 00:10:32,780
区域到主机和备机的映射，

161
00:10:32,780 --> 00:10:35,780
所以，他们使用配置管理器，

162
00:10:36,790 --> 00:10:38,680
一个 CM 在这里，

163
00:10:39,370 --> 00:10:44,140
CM 本身与我们之前看过的 zookeeper 相结合，

164
00:10:45,780 --> 00:10:50,610
zookeeper 和配置管理器跟踪，

165
00:10:50,610 --> 00:11:02,110
从区域编号到主机和备机的映射，

166
00:11:04,530 --> 00:11:05,610
对于每个区域。

167
00:11:06,390 --> 00:11:08,880
好的?

168
00:11:09,690 --> 00:11:13,440
当然，现在这里有一个严重的问题，

169
00:11:13,440 --> 00:11:14,430
我讨论过，

170
00:11:14,430 --> 00:11:16,950
使用主备方案，

171
00:11:16,950 --> 00:11:18,060
我们会有故障，

172
00:11:18,180 --> 00:11:20,190
一台机器可能会出故障，

173
00:11:20,190 --> 00:11:21,330
现在机器可以接手，

174
00:11:21,570 --> 00:11:24,300
除了一种棘手的情况，

175
00:11:24,300 --> 00:11:27,240
到目前为止这个方案不能处理，

176
00:11:27,390 --> 00:11:29,040
当出现相关的故障时，

177
00:11:29,040 --> 00:11:31,290
例如，数据中心停电，

178
00:11:31,590 --> 00:11:33,510
所有的机器都会停机，

179
00:11:34,190 --> 00:11:35,690
为了处理这种情况，

180
00:11:35,840 --> 00:11:40,610
DRAM 位于 UPS 上，

181
00:11:40,610 --> 00:11:43,940
每台机器都有一个不间断的电源，

182
00:11:44,360 --> 00:11:47,600
所以我要画一个大电池放在边上，

183
00:11:54,520 --> 00:11:58,930
电池或者 UPS 提供足够的能量，

184
00:11:58,930 --> 00:12:02,260
如果发生全局停电，

185
00:12:02,500 --> 00:12:04,900
机器会继续运转一小段时间，

186
00:12:04,900 --> 00:12:06,220
这一小段时间，

187
00:12:06,490 --> 00:12:08,410
机器可以存储，

188
00:12:08,680 --> 00:12:12,790
FaRM 将数据存储在 SSD 上，

189
00:12:12,790 --> 00:12:16,570
或者只是刷新它的内存中的内容，

190
00:12:16,600 --> 00:12:23,560
所有区域，所有事务状态，所有事务日志，

191
00:12:23,770 --> 00:12:25,600
将它们刷新到 SSD 上，

192
00:12:25,630 --> 00:12:29,590
所以，如果整个数据中心完全停电，

193
00:12:29,680 --> 00:12:31,990
数据中心将在某个时间恢复运行，

194
00:12:32,080 --> 00:12:37,690
它们可以从 SSD 中加载机器的内存内容，

195
00:12:37,840 --> 00:12:39,670
重新开始运行，

196
00:12:40,560 --> 00:12:44,700
这是唯一使用 SSD 的地方，

197
00:12:45,000 --> 00:12:50,490
为了处理数据中心内的多台机器的相关故障。

198
00:12:53,750 --> 00:12:55,220
到目前为止，有什么问题吗？

199
00:13:03,180 --> 00:13:05,790
好的，让我简单介绍一下软件，

200
00:13:05,880 --> 00:13:07,560
所以在区域里，

201
00:13:07,650 --> 00:13:09,150
我们在这里有一个区域，

202
00:13:09,740 --> 00:13:12,230
在区域中有一些对象，

203
00:13:13,390 --> 00:13:17,650
所以你可以把区域想象成一个字节数组，

204
00:13:17,650 --> 00:13:18,880
2G 字节，

205
00:13:19,240 --> 00:13:21,910
在字节对象数组中，有一些对象，

206
00:13:22,800 --> 00:13:30,390
对象有唯一的标识符 oid ，

207
00:13:31,550 --> 00:13:34,100
对象 oid 不是别的，

208
00:13:34,100 --> 00:13:41,660
它是[]区域编号和区域内的地址，

209
00:13:48,860 --> 00:13:52,340
与每个对象绑定，

210
00:13:52,340 --> 00:13:55,700
这里有一些对象的元数据，

211
00:13:56,090 --> 00:14:01,850
对象头部包含一个 64 位数字，

212
00:14:05,870 --> 00:14:15,070
该数字包含底部 63 位版本号，

213
00:14:15,070 --> 00:14:20,350
然后是一个锁位，我们会在顶部看到，

214
00:14:21,330 --> 00:14:25,500
所以每个对象都有这个 64 位数字，

215
00:14:25,500 --> 00:14:27,600
称为版本号，

216
00:14:27,840 --> 00:14:32,220
然后我们将看到它在乐观并发控制中起重要作用。

217
00:14:33,720 --> 00:14:40,460
应用程序使用这个系统的方式，

218
00:14:40,460 --> 00:14:42,050
让我稍微说一下，

219
00:14:42,050 --> 00:14:44,330
应用程序编程接口是什么。

220
00:14:53,060 --> 00:14:54,440
所以 API 是，

221
00:14:54,440 --> 00:14:55,910
你启动事务，

222
00:15:00,080 --> 00:15:01,760
读取一些对象，

223
00:15:05,490 --> 00:15:07,560
这是 read 调用，

224
00:15:07,560 --> 00:15:10,590
read 调用将 oid 作为参数，

225
00:15:11,580 --> 00:15:16,360
然后，应用程序可以操作，

226
00:15:16,360 --> 00:15:19,690
修改对象中的字段，

227
00:15:19,690 --> 00:15:21,100
不管什么，比如加 1 ，

228
00:15:22,270 --> 00:15:28,680
然后在某个时刻写入对象，

229
00:15:31,660 --> 00:15:34,570
使用 write 调用更新对象自己，

230
00:15:34,570 --> 00:15:38,200
然后使用 txcommit 提交它。

231
00:15:41,310 --> 00:15:43,890
也可能是这种情况，

232
00:15:43,890 --> 00:15:47,130
事务需要中止，

233
00:15:47,130 --> 00:15:48,780
因为是乐观并发控制，

234
00:15:48,780 --> 00:15:52,920
在这种情况下，应用程序将重试事务，

235
00:15:53,830 --> 00:15:58,360
所以，在这里显示的事务中，

236
00:15:58,360 --> 00:15:59,890
只有一个对象操作，

237
00:15:59,980 --> 00:16:02,680
但它实际操作很多对象，

238
00:16:02,680 --> 00:16:05,440
这些对象可能位于不同的区域，

239
00:16:05,800 --> 00:16:09,010
所以它们必须有一些方案，

240
00:16:09,010 --> 00:16:09,670
我们将会看到，

241
00:16:09,700 --> 00:16:14,650
我们使用类似两阶段提交的协议来执行原子操作，

242
00:16:14,650 --> 00:16:18,310
跨不同地区的对象。

243
00:16:20,210 --> 00:16:24,760
关于 API 和设置，有什么问题吗？

244
00:16:29,910 --> 00:16:36,480
抱歉，地址 oid ，是在机器本身的地址吗？

245
00:16:36,870 --> 00:16:40,860
是的，是那个区域内的偏移量。

246
00:16:46,300 --> 00:16:46,990
好的？

247
00:16:48,380 --> 00:16:49,700
区域可以移动，

248
00:16:49,790 --> 00:16:54,680
复制或配置管理器[]映射，

249
00:16:55,040 --> 00:16:58,340
对象可能更改的地址，

250
00:16:58,580 --> 00:17:00,740
所以这是一个区域编号加上一个偏移量，

251
00:17:02,130 --> 00:17:04,230
在这里，我应该设置偏移量。

252
00:17:09,920 --> 00:17:12,770
抱歉，我也有一个问题，

253
00:17:13,010 --> 00:17:18,410
创建全局地址空间背后的设计选择或设计思想是什么？

254
00:17:19,280 --> 00:17:23,210
把所有东西都放在内存中，

255
00:17:26,480 --> 00:17:29,330
我不确定这是否回答了你的问题，但是，

256
00:17:32,120 --> 00:17:36,200
它们的全部目标是在内存数据库上运行事务，

257
00:17:36,230 --> 00:17:38,390
这是数据库的整体趋势，

258
00:17:38,390 --> 00:17:41,480
所有数据始终在内存中，称为内存数据库，

259
00:17:41,990 --> 00:17:44,930
因为 DRAM 很便宜，

260
00:17:45,230 --> 00:17:48,230
这将允许你运行事务，

261
00:17:48,230 --> 00:17:50,750
不需要访问持久化存储，

262
00:17:50,750 --> 00:17:57,120
他们跳上了内存数据库。

263
00:17:58,310 --> 00:18:02,150
我明白了，这需要它们共享一个全局地址空间。

264
00:18:02,680 --> 00:18:05,020
地址空间是按机器的，

265
00:18:05,020 --> 00:18:09,130
每台机器都有自己的地址空间，从 0 到任何东西，

266
00:18:09,520 --> 00:18:18,970
这些对象是全球编号或全局名称。

267
00:18:22,070 --> 00:18:22,820
谢谢。

268
00:18:26,450 --> 00:18:28,010
好的，很好。

269
00:18:28,340 --> 00:18:30,230
那么我们谈到目前为止，

270
00:18:30,350 --> 00:18:33,170
我认为我们已经建立了

271
00:18:33,170 --> 00:18:36,740
他们已经排除了稳定的存储设备，

272
00:18:37,160 --> 00:18:42,110
所以，读写存储设备不存在瓶颈，

273
00:18:42,110 --> 00:18:43,700
因为他们没有使用它们，

274
00:18:43,970 --> 00:18:47,990
一个例外的情况是电源故障。

275
00:18:48,690 --> 00:18:51,690
他们关注的下一组事情是是，

276
00:18:51,690 --> 00:18:56,070
试图降低 CPU 使用率

277
00:18:56,070 --> 00:18:57,870
或者试图高效地使用 CPU

278
00:18:57,900 --> 00:18:59,430
并且在网络方面非常高效。

279
00:19:00,830 --> 00:19:04,310
这里有两个关键的想法，

280
00:19:04,310 --> 00:19:05,960
是众所周知的。

281
00:19:06,380 --> 00:19:08,510
第一个是内核旁路，

282
00:19:20,460 --> 00:19:24,900
这个故事很简单，

283
00:19:25,020 --> 00:19:27,900
我们 FaRM 作为用户进程运行，

284
00:19:31,880 --> 00:19:34,880
在 Windows 操作系统上面，

285
00:19:34,880 --> 00:19:36,350
这是操作系统，

286
00:19:37,040 --> 00:19:38,390
让我们往边上移一点，

287
00:19:38,420 --> 00:19:39,860
所以这是操作系统，

288
00:19:40,340 --> 00:19:41,510
操作系统当然，

289
00:19:41,510 --> 00:19:45,560
有所有的功能，进程调度，虚拟内存，

290
00:19:45,770 --> 00:19:47,780
标准的操作系统，

291
00:19:48,050 --> 00:19:52,190
它也有硬件设备的驱动程序，

292
00:19:52,370 --> 00:19:56,540
并且其中一个硬件设备是网卡，

293
00:20:00,560 --> 00:20:04,550
通常操作系统驱动程序在里面，

294
00:20:05,140 --> 00:20:09,940
对那个网卡编程，

295
00:20:09,940 --> 00:20:14,410
所以读写网卡上的寄存器发送包，

296
00:20:14,770 --> 00:20:17,920
或者重新配置网卡，等等。

297
00:20:18,870 --> 00:20:25,080
应用程序与网卡交互的通常方式是，

298
00:20:25,080 --> 00:20:27,960
它们对内核进行系统调用，

299
00:20:27,960 --> 00:20:30,840
要求内核发送一个包，

300
00:20:31,750 --> 00:20:34,810
这涉及操作系统，

301
00:20:34,810 --> 00:20:37,090
涉及到 TCP 栈，网络栈，

302
00:20:37,270 --> 00:20:39,580
它往往相当昂贵，

303
00:20:40,120 --> 00:20:44,740
所以他们想要避免这个开销，

304
00:20:44,740 --> 00:20:47,680
进入内核，运行 TCP 等，

305
00:20:47,920 --> 00:20:51,340
他们这样做的方式是一种被称为内核旁路的技术，

306
00:20:51,340 --> 00:20:56,770
网卡是网卡和操作系统之间的协作，

307
00:20:57,100 --> 00:20:58,930
它所做的是，

308
00:20:58,930 --> 00:21:01,150
它对网卡的队列排序，

309
00:21:01,570 --> 00:21:04,810
这是一些队列，比如发送队列和接收队列，

310
00:21:05,170 --> 00:21:10,930
这些队列直接映射或进入应用程序的地址空间，

311
00:21:11,410 --> 00:21:14,230
所以，应用程序可以请求操作系统，

312
00:21:14,230 --> 00:21:18,460
请取出网卡所有的一些队列，

313
00:21:18,550 --> 00:21:20,830
并将它们映射到应用程序的地址空间中，

314
00:21:21,280 --> 00:21:23,410
所以，你可以考虑这些队列，

315
00:21:23,410 --> 00:21:28,270
可以从用户级应用程序直接访问，

316
00:21:28,270 --> 00:21:31,150
所以用户应用程序现在可以，

317
00:21:31,150 --> 00:21:35,050
读写命令或包到网卡，

318
00:21:35,110 --> 00:21:39,100
而不需要涉及到操作系统。

319
00:21:39,310 --> 00:21:41,740
所以这把整个操作系统都排除在外了，

320
00:21:41,920 --> 00:21:45,310
大大提高了性能。

321
00:21:46,180 --> 00:21:47,560
在 FaRM 的情况下，

322
00:21:47,710 --> 00:21:49,390
他们也不想使用中断，

323
00:21:49,420 --> 00:21:51,700
一种传递包的方式是，

324
00:21:51,700 --> 00:21:52,390
当包进入的时候，

325
00:21:52,390 --> 00:21:55,510
网卡向操作系统发送中断，

326
00:21:55,510 --> 00:22:00,520
然后操作系统告诉应用包已经到达，

327
00:22:00,760 --> 00:22:03,550
试图避免这一成本，

328
00:22:03,550 --> 00:22:04,870
避免这一成本的方法是

329
00:22:04,870 --> 00:22:08,730
他们轮询接收队列。

330
00:22:09,840 --> 00:22:12,150
所以有一个用户级别的线程，

331
00:22:12,180 --> 00:22:15,690
它位于 FaRM 应用程序中，

332
00:22:15,900 --> 00:22:20,100
除了读取接收队列之外，什么也不做，

333
00:22:20,100 --> 00:22:21,780
查看包是否可用。

334
00:22:23,520 --> 00:22:26,340
所以这需要一个[]，

335
00:22:26,340 --> 00:22:28,530
这就避免了中断的使用，

336
00:22:28,800 --> 00:22:33,600
有一个轮询线程的代价，

337
00:22:33,600 --> 00:22:36,660
在那里，除了轮询什么也不做，

338
00:22:37,410 --> 00:22:41,310
FaRM 这个线程来回切换，

339
00:22:41,310 --> 00:22:45,270
在运行应用程序代码和轮询网卡之间。

340
00:22:46,640 --> 00:22:48,440
所以这是内核旁路，

341
00:22:48,890 --> 00:22:51,200
这是一个[合理的标准]，

342
00:22:51,200 --> 00:22:59,660
你们中的一些人可能熟悉 DPDK ，

343
00:23:01,570 --> 00:23:04,030
它是数据平面开发工具包，

344
00:23:04,420 --> 00:23:09,940
是一个可以利用内核旁路的开发工具包。

345
00:23:10,710 --> 00:23:12,030
这是一个合理的标准，

346
00:23:12,950 --> 00:23:15,830
在许多操作系统上都可以使用。

347
00:23:16,720 --> 00:23:20,200
下一个他们使用的技术，

348
00:23:20,200 --> 00:23:24,520
有一点，但也是众所周知，广泛和标准化的，

349
00:23:24,520 --> 00:23:26,860
许多网卡支持，

350
00:23:26,890 --> 00:23:29,950
或者更高端的网卡支持，

351
00:23:30,250 --> 00:23:31,990
这就是所谓的 RDMA ，

352
00:23:36,210 --> 00:23:42,260
它表示远程直接内存访问。

353
00:23:51,030 --> 00:23:51,960
基本的想法是，

354
00:23:51,990 --> 00:23:57,780
这需要网卡理解 RDMA ，

355
00:23:57,930 --> 00:24:00,300
这里有电缆，

356
00:24:00,330 --> 00:24:02,220
另一边有网卡，

357
00:24:02,790 --> 00:24:05,010
操作系统可能在它的上面，

358
00:24:05,550 --> 00:24:07,290
这里我们有 FaRM ，

359
00:24:12,850 --> 00:24:19,360
应用程序在旁边，

360
00:24:19,600 --> 00:24:24,010
可以把特定的包放入发送队列，

361
00:24:24,280 --> 00:24:28,150
发送 RDMA 包，

362
00:24:28,540 --> 00:24:32,260
在数据包的头部有一位，

363
00:24:32,260 --> 00:24:34,150
表示，我是个 RDMA 包，

364
00:24:34,780 --> 00:24:39,130
然后网卡会将其发送到目标网卡，

365
00:24:39,400 --> 00:24:43,510
目标网卡看出这是一个特殊的包，一个 RDMA 包，

366
00:24:43,870 --> 00:24:47,590
并查看与 RDMA 包一起的指令，

367
00:24:47,920 --> 00:24:49,030
这个指令可能是，

368
00:24:49,240 --> 00:24:52,630
读取特定内存位置或写入特定内存位置，

369
00:24:53,170 --> 00:24:54,610
举个例子，

370
00:24:54,610 --> 00:24:56,110
假设这是一个读操作，

371
00:24:59,390 --> 00:25:02,300
读取操作将安全地获取地址，

372
00:25:03,670 --> 00:25:05,950
并且它允许网卡，

373
00:25:06,070 --> 00:25:10,930
直接从内存中读取地址，

374
00:25:11,110 --> 00:25:14,140
假设这里有我们的区域，

375
00:25:15,690 --> 00:25:17,040
里面有对象，

376
00:25:18,120 --> 00:25:25,320
发送 FaRM 应用程序可以说，

377
00:25:25,380 --> 00:25:30,180
好的，我想读取这个特定地址，

378
00:25:30,180 --> 00:25:33,690
对应于这个对象 o 的地址，

379
00:25:34,020 --> 00:25:38,190
将向另一端的网卡发送 RDMA 数据包，

380
00:25:39,830 --> 00:25:41,750
网卡是有一个 RDMA 数据包，

381
00:25:42,170 --> 00:25:45,920
从内存中读取，

382
00:25:46,100 --> 00:25:48,650
存储在特定位置的值，

383
00:25:48,890 --> 00:25:53,210
然后直接把它们送回源头。

384
00:25:54,260 --> 00:25:58,160
这项技术的酷的地方在于，

385
00:25:58,160 --> 00:25:59,180
网卡可以做这个，

386
00:25:59,240 --> 00:26:04,010
根本不需要中断或干扰服务器，

387
00:26:04,490 --> 00:26:06,320
它不需要产生中断，

388
00:26:06,320 --> 00:26:11,120
不需要在处理器上运行任何代码，

389
00:26:11,120 --> 00:26:13,220
运行操作系统，应用程序，

390
00:26:13,430 --> 00:26:18,290
相反，网卡具有固件执行这些命令，

391
00:26:18,470 --> 00:26:22,790
加载存储在这些内存中的值，

392
00:26:22,790 --> 00:26:26,270
请求内存地址直接进入响应包，

393
00:26:26,270 --> 00:26:27,680
并发回数据包，

394
00:26:27,920 --> 00:26:29,840
当然，在接收端，

395
00:26:30,200 --> 00:26:32,450
这将显示在接收队列中，

396
00:26:32,600 --> 00:26:34,460
到目前为止，在某个点上，

397
00:26:34,460 --> 00:26:38,750
持有接收队列，并看到 RDMA 的结果。

398
00:26:41,820 --> 00:26:45,120
我在这里描述的这个版本，

399
00:26:45,120 --> 00:26:49,470
论文将其称为单边 RDMA ，

400
00:26:53,280 --> 00:26:59,100
这通常指的是读取操作。

401
00:27:02,500 --> 00:27:03,190
教授。

402
00:27:03,700 --> 00:27:04,420
好的，继续。

403
00:27:04,420 --> 00:27:05,290
抱歉，教授，

404
00:27:05,320 --> 00:27:07,210
你能重复一下，

405
00:27:07,210 --> 00:27:13,810
客户端的网卡队列是如何工作的，

406
00:27:13,870 --> 00:27:15,460
或者，是的。

407
00:27:16,380 --> 00:27:18,000
这几乎没有什么，

408
00:27:18,060 --> 00:27:25,080
客户端只有一个读取特定内存位置的线程，

409
00:27:25,500 --> 00:27:28,710
表示数据包是否已经到达，

410
00:27:29,300 --> 00:27:34,100
当网卡接收到包，放入接收队列中，

411
00:27:34,340 --> 00:27:36,740
作为接收队列中设置的一侧，

412
00:27:36,740 --> 00:27:40,520
标志位变为 1 ，

413
00:27:40,760 --> 00:27:43,520
应用程序知道那里有一个包。

414
00:27:46,060 --> 00:27:50,200
是不是一个特殊的线程轮询？

415
00:27:50,380 --> 00:27:53,350
是的，他们的系统里，有特定的线程，

416
00:27:53,350 --> 00:27:57,160
专门用于轮询队列。

417
00:27:58,220 --> 00:27:59,910
好的，谢谢。

418
00:28:01,540 --> 00:28:02,770
抱歉，这里我也比较疑惑，

419
00:28:02,770 --> 00:28:06,400
那么，网卡是否与系统合作，正常工作，

420
00:28:06,520 --> 00:28:08,620
就像普通的网卡一样。

421
00:28:09,500 --> 00:28:14,060
好的，这不是普通网卡，

422
00:28:14,360 --> 00:28:20,570
这个网卡同时支持内核旁路和远程直接内存访问 RDMA ，

423
00:28:21,230 --> 00:28:26,900
通常，网卡为了支持内核旁路，

424
00:28:26,900 --> 00:28:29,900
这意味着它必须有多个接收和发送队列，

425
00:28:30,140 --> 00:28:33,290
它只向应用程序提供一对发送或接收队列，

426
00:28:34,980 --> 00:28:35,970
它不能，

427
00:28:35,970 --> 00:28:36,510
当然，

428
00:28:36,510 --> 00:28:40,860
你不能让计算机上运行的每个进程都有一个发送接收队列，

429
00:28:41,130 --> 00:28:43,890
所以它们通常是 16 个或者 32 个，

430
00:28:44,160 --> 00:28:47,160
把其中的一些放到特定的操作系统上，

431
00:28:47,160 --> 00:28:51,690
允许一些应用程序拥有发送接收队列。

432
00:28:52,880 --> 00:28:53,810
非常感谢。

433
00:28:55,060 --> 00:28:59,170
这也意味着有对 RDMA 的支持，并使它正常工作，

434
00:29:00,050 --> 00:29:03,830
所以它需要一个相当复杂的网卡，

435
00:29:03,830 --> 00:29:05,600
尽管如今这是一个合理的标准。

436
00:29:07,070 --> 00:29:10,010
好的，这是 RDMA 的一个方面，

437
00:29:10,010 --> 00:29:13,610
它们还使用 RDMA 进行写入，

438
00:29:13,880 --> 00:29:16,040
真正实现 RPC ，

439
00:29:16,280 --> 00:29:23,470
他们在论文中把这个称为 写 RDMA ，

440
00:29:24,520 --> 00:29:25,930
基本上是相同的事情，

441
00:29:27,970 --> 00:29:32,500
除了发送方可以放入 RDMA 包，

442
00:29:32,500 --> 00:29:34,390
说这是一个写操作，

443
00:29:34,390 --> 00:29:38,020
将以下字节写入特定地址，

444
00:29:38,290 --> 00:29:42,730
这篇论文使用了两个地方或两个东西，

445
00:29:42,730 --> 00:29:44,530
这些地方用到了写入，

446
00:29:44,770 --> 00:29:48,580
直接用 RDMA 写入，

447
00:29:48,700 --> 00:29:52,960
但还有另外两个数据结构使用 写RDMA 写入，

448
00:29:52,990 --> 00:29:54,220
一个是日志，

449
00:29:56,200 --> 00:29:58,600
稍后你会看到日志的规则，

450
00:30:00,440 --> 00:30:02,420
这是一个事务，

451
00:30:02,420 --> 00:30:06,440
所以它有提交记录，日志记录，等等，

452
00:30:06,650 --> 00:30:12,080
所以，如果源头将日志记录附加到这个日志，

453
00:30:12,080 --> 00:30:14,480
我可以执行 写RDMA ，

454
00:30:14,690 --> 00:30:18,050
然后，接收网卡会

455
00:30:18,050 --> 00:30:23,870
将日志中的新条目添加到指定位置。

456
00:30:24,970 --> 00:30:25,660
好的?

457
00:30:26,680 --> 00:30:29,350
所以这意味着就像发送者，

458
00:30:29,350 --> 00:30:34,450
每个发送方和接收方对都有一个队列和一个日志，

459
00:30:34,540 --> 00:30:36,490
所以发送者可以管理和知道

460
00:30:36,490 --> 00:30:38,290
日志开头和结尾是什么。

461
00:30:40,020 --> 00:30:42,150
然后，除此之外，

462
00:30:42,150 --> 00:30:49,590
有一些消息队列也是每对一个，

463
00:30:51,340 --> 00:30:54,970
这些用于实现 RPC ，

464
00:30:55,270 --> 00:30:57,940
所以，如果你想要进行远程过程调用，

465
00:30:58,090 --> 00:31:04,330
客户端，发送方制作 写RDMA 包，

466
00:31:04,630 --> 00:31:09,190
将数据，消息写入远程消息队列，

467
00:31:09,580 --> 00:31:13,990
在目标一侧也有一个线程，

468
00:31:13,990 --> 00:31:18,430
轮询消息队列或轮询所有消息队列，

469
00:31:18,760 --> 00:31:21,280
如果它看到一条消息，它会处理消息，

470
00:31:21,430 --> 00:31:25,850
然后可以使用 写RDMA 发回响应，

471
00:31:32,530 --> 00:31:38,050
使用 RDMA 实现远程过程调用更[便宜]，

472
00:31:38,200 --> 00:31:43,330
它比使用某种标准 RPC 包更[便宜]，

473
00:31:43,450 --> 00:31:49,930
数据包使用普通网卡，但没有 RDMA ，

474
00:31:50,170 --> 00:31:53,140
在另一边有一个线程响应。

475
00:31:54,190 --> 00:31:54,820
好的?

476
00:31:56,450 --> 00:31:58,250
这里是否有任何验证步骤，

477
00:31:58,250 --> 00:32:01,760
为了确保你只写入内存区域，

478
00:32:01,760 --> 00:32:04,250
这是明确允许 RDMA 的，

479
00:32:04,250 --> 00:32:07,700
不要写到应用程序内存或其他什么地方。

480
00:32:07,820 --> 00:32:09,380
是的，有各种各样的，

481
00:32:09,380 --> 00:32:12,080
这是一种高层次的想法，

482
00:32:12,140 --> 00:32:13,610
在这里讨论详细信息，

483
00:32:14,090 --> 00:32:18,590
所以，当你设置这些 RDMA 时，

484
00:32:18,590 --> 00:32:24,230
为了做这种单边 RDMA 或写入 RDMA ，

485
00:32:24,320 --> 00:32:26,180
你首先必须进行连接设置，

486
00:32:26,390 --> 00:32:31,730
在发送者和接收者之间有一个协商步骤来设置，

487
00:32:31,730 --> 00:32:34,310
它就像一个 TCP 通道，

488
00:32:34,310 --> 00:32:36,950
除了 RDMA 不使用 TCP ，

489
00:32:37,070 --> 00:32:43,640
但是它建立了面向连接的可靠、有序的通道，

490
00:32:46,080 --> 00:32:48,810
所以，安全检查和访问控制检查

491
00:32:48,810 --> 00:32:50,220
是在设置时进行的。

492
00:32:53,190 --> 00:32:56,280
那么，你需要在每一对机器之间执行这个操作吗？

493
00:32:56,280 --> 00:32:56,790
是的。

494
00:32:58,600 --> 00:33:00,790
所以这将变得非常昂贵的添加，

495
00:33:00,820 --> 00:33:04,000
比如一台机器对一个大集群，是吗？

496
00:33:04,330 --> 00:33:07,090
你有 n 的平方个连接，

497
00:33:08,300 --> 00:33:10,550
否则我们将有 n 的平方个 TCP 连接，

498
00:33:11,650 --> 00:33:14,590
不清楚是不是有很大的区别。

499
00:33:18,040 --> 00:33:19,720
为了确认一下，

500
00:33:19,720 --> 00:33:21,700
日志中的信息，

501
00:33:21,700 --> 00:33:24,340
它们也在内存中，

502
00:33:24,340 --> 00:33:27,100
它们只是在与对象不同的地方。

503
00:33:27,430 --> 00:33:28,120
是的，没错，

504
00:33:28,180 --> 00:33:28,990
所以如果你这样做，

505
00:33:28,990 --> 00:33:30,760
那么这就是右边的这个，

506
00:33:31,150 --> 00:33:35,530
是 FaRM 进程的内存布局图片，

507
00:33:35,530 --> 00:33:39,100
有一个区域表或一个对象表，

508
00:33:39,100 --> 00:33:42,850
在服务器的内存中有区域，

509
00:33:43,090 --> 00:33:45,820
这些区域中有对象，

510
00:33:46,090 --> 00:33:47,590
除了这些区域之外，

511
00:33:47,590 --> 00:33:50,290
还有消息队列和日志。

512
00:33:51,900 --> 00:33:52,440
我明白了，

513
00:33:52,560 --> 00:33:56,460
而且为了让网卡支持从内存直接访问，

514
00:33:56,460 --> 00:33:59,280
由于我们在这里没有涉及任何软件，

515
00:33:59,280 --> 00:34:02,730
网卡可以直接访问内存，

516
00:34:02,730 --> 00:34:06,900
甚至不需要通知应用或操作系统，

517
00:34:07,110 --> 00:34:09,690
不应该在硬件层面上进行一些协调，

518
00:34:09,690 --> 00:34:16,830
或者至少从处理器支持这个特性。

519
00:34:17,190 --> 00:34:19,380
是的，所以，

520
00:34:19,380 --> 00:34:26,380
网卡可以原子地读写缓存行，

521
00:34:26,680 --> 00:34:28,810
为了支持这一点，

522
00:34:28,810 --> 00:34:33,940
有一个接口在内存系统和网卡之间，

523
00:34:33,940 --> 00:34:37,150
必须在操作系统仔细设置，

524
00:34:37,150 --> 00:34:38,920
当连接设置完成时。

525
00:34:40,710 --> 00:34:41,520
我明白了，谢谢。

526
00:34:43,780 --> 00:34:48,850
抱歉，右侧的 写入RDMA 是红色的，

527
00:34:49,750 --> 00:34:50,890
那里发生了什么？

528
00:34:52,120 --> 00:34:57,760
所以，发送者，左边的机器可以执行 写入RDMA ，

529
00:34:58,090 --> 00:35:00,430
发送 写入RDMA 包到右侧，

530
00:35:00,730 --> 00:35:03,880
到右边的目标，

531
00:35:04,180 --> 00:35:07,960
网卡会看到这是一个 写入RDMA 包，

532
00:35:08,380 --> 00:35:10,900
并将写入网络来的内容，

533
00:35:11,110 --> 00:35:15,190
写入 RDMA 命令中指定的地址。

534
00:35:18,950 --> 00:35:20,240
但这将是。

535
00:35:20,750 --> 00:35:22,700
所以有一台远程机器，

536
00:35:22,700 --> 00:35:27,230
可以写入内存地址在目标机器上，

537
00:35:27,230 --> 00:35:30,770
在没有服务器参与的情况下，

538
00:35:31,670 --> 00:35:33,110
当然，除了设置之外。

539
00:35:33,860 --> 00:35:34,940
谢谢。

540
00:35:37,030 --> 00:35:38,110
所以，我有个小问题，

541
00:35:38,110 --> 00:35:45,900
所以队列和网卡只用于读 RDMA ，

542
00:35:46,290 --> 00:35:50,700
（因为）写入直接到接收者的内存。

543
00:35:51,500 --> 00:35:52,730
是的，在，

544
00:35:52,790 --> 00:35:54,920
好的，在写入 RDMA 中，

545
00:35:54,920 --> 00:35:56,630
你可能在报纸上注意到的，

546
00:35:56,750 --> 00:35:58,790
可能会有确认，

547
00:35:59,400 --> 00:36:04,110
所以，如果发送方发送写入 RDMA ，

548
00:36:04,200 --> 00:36:08,490
它可以等待来自接收网卡的确认，

549
00:36:08,640 --> 00:36:11,340
表示执行了写入 RDMA 。

550
00:36:13,550 --> 00:36:15,080
好的，谢谢。

551
00:36:16,630 --> 00:36:18,370
这将发挥重要作用。

552
00:36:21,300 --> 00:36:23,910
关于这一部分，还有什么问题吗？

553
00:36:25,430 --> 00:36:27,590
这是一种很酷的技术，

554
00:36:27,590 --> 00:36:33,320
在过去的十年里，这种情况相当普遍地出现，

555
00:36:33,650 --> 00:36:35,690
他们想要利用这一点，

556
00:36:37,620 --> 00:36:42,000
因为这让他们获得延迟，

557
00:36:42,000 --> 00:36:46,710
进行单边 RDMA 约为 5 微秒，

558
00:36:49,000 --> 00:36:51,280
所以非常低的延迟，

559
00:36:54,010 --> 00:36:55,840
非常快，

560
00:36:55,840 --> 00:36:57,490
例如，读取或写入磁盘，

561
00:36:57,790 --> 00:37:04,570
比写入你自己的内存慢不了多少，

562
00:37:04,660 --> 00:37:06,310
非常快，

563
00:37:08,020 --> 00:37:12,700
因为它允许你做一微秒，每秒一百万个包，

564
00:37:14,150 --> 00:37:15,050
令人印象深刻。

565
00:37:17,450 --> 00:37:17,990
好的?

566
00:37:19,320 --> 00:37:21,780
到目前为止，这是标准技术，

567
00:37:21,810 --> 00:37:27,130
前沿的，但是标准的。

568
00:37:27,990 --> 00:37:34,580
所以，这篇论文解决的真正挑战是，

569
00:37:36,800 --> 00:37:40,520
是如何使用 RDMA ，

570
00:37:41,030 --> 00:37:45,800
写入 RDMA 和单边 RDMA 进行事务，

571
00:37:45,800 --> 00:37:50,000
所以，论文所解决的挑战是事务使用 RDMA 。

572
00:37:59,210 --> 00:38:03,140
你可以看到这是一个挑战，

573
00:38:03,140 --> 00:38:04,700
我们必须考虑一下，

574
00:38:04,700 --> 00:38:06,770
到目前为止我们看到的所有协议，

575
00:38:07,130 --> 00:38:18,560
事务的协议，两阶段提交等，

576
00:38:18,710 --> 00:38:23,060
所有这些协议都需要服务器端参与，

577
00:38:33,290 --> 00:38:37,070
例如，我的意思是，

578
00:38:37,070 --> 00:38:41,300
客户端发送请求到事务协调者，

579
00:38:41,300 --> 00:38:43,130
发送请求到其中一个参与者，

580
00:38:43,490 --> 00:38:47,840
比如获取某个对象的锁，

581
00:38:48,020 --> 00:38:52,790
等待服务器或接收者，

582
00:38:52,790 --> 00:38:54,890
直到锁变得可用，

583
00:38:55,400 --> 00:39:00,200
或者服务器运行一些验证步骤，

584
00:39:00,200 --> 00:39:05,720
查看事务是否能被提交，

585
00:39:06,230 --> 00:39:08,810
所以在所有这些情况中，

586
00:39:08,930 --> 00:39:11,090
如果你有一些服务器端参与，

587
00:39:11,090 --> 00:39:13,550
意味着你必须在服务器上运行代码，

588
00:39:22,550 --> 00:39:27,230
这与 RDMA 给你带来的是相反的，

589
00:39:27,230 --> 00:39:33,110
RDMA 没有为你提供在服务器上运行代码的能力，

590
00:39:33,170 --> 00:39:36,740
所以，这篇论文的设计者或作者

591
00:39:36,740 --> 00:39:38,540
必须想出一种协议，

592
00:39:38,750 --> 00:39:43,700
允许你实现两阶段提交和事务

593
00:39:43,820 --> 00:39:48,530
不使用或试着减少服务器端参与，

594
00:39:49,480 --> 00:39:52,840
他们可以重用 RDMA 进行某些操作，

595
00:39:53,020 --> 00:39:56,200
有些使用远程过程调用，

596
00:39:56,230 --> 00:39:57,910
像传统做法一样，

597
00:39:57,910 --> 00:40:01,660
在过去的几周里我们看到的传统设计。

598
00:40:02,430 --> 00:40:07,980
这就是这篇论文的核心挑战，

599
00:40:07,980 --> 00:40:13,500
这促使他们朝着这个方向去解决这个问题，

600
00:40:13,830 --> 00:40:17,310
他们使用的高级策略是，

601
00:40:21,220 --> 00:40:26,290
使用的高级策略是乐观并发控制。

602
00:40:30,750 --> 00:40:37,050
他们真正的闪光点是在读取操作上，

603
00:40:37,320 --> 00:40:41,040
因为基本计划是读取对象，

604
00:40:42,340 --> 00:40:46,600
这些是不需要锁的事务部分，

605
00:40:51,240 --> 00:40:56,580
例如，需要锁，这意味着可能会中断服务器，

606
00:40:56,580 --> 00:40:58,080
服务器必须做一些工作，

607
00:40:58,080 --> 00:41:00,540
可能会阻止客户端，

608
00:41:00,540 --> 00:41:03,900
直到锁可用，然后返回对象，

609
00:41:03,900 --> 00:41:12,870
这与 RDMA 并不是很合适，

610
00:41:12,960 --> 00:41:15,720
所以，他们将采取乐观的方案，

611
00:41:15,810 --> 00:41:19,110
其中读取对象不需要任何锁，

612
00:41:19,140 --> 00:41:22,800
你获取一个对象并开始使用它，

613
00:41:22,800 --> 00:41:24,300
正如我们将看到的，

614
00:41:24,390 --> 00:41:26,790
当然你需要一些机制

615
00:41:26,790 --> 00:41:29,400
来发现读取的是旧版本还是新版本，

616
00:41:29,580 --> 00:41:32,130
这就是版本号将发挥重要作用的地方。

617
00:41:39,130 --> 00:41:41,950
所以当你读取 FaRM 中的一个对象，

618
00:41:41,950 --> 00:41:42,970
你把对象拿回来，

619
00:41:42,970 --> 00:41:45,370
你也把那个对象的版本号拿回来，

620
00:41:45,880 --> 00:41:49,210
然后基本的想法是，

621
00:41:49,210 --> 00:41:50,290
在提交的时候，

622
00:41:50,810 --> 00:41:54,410
我们要做一个验证步骤，

623
00:41:56,300 --> 00:42:02,930
检查事务开始时写入的对象，

624
00:42:02,930 --> 00:42:04,160
已经被修改了。

625
00:42:04,580 --> 00:42:06,680
所以，在验证检查步骤期间，

626
00:42:06,800 --> 00:42:08,720
我们要检查冲突，

627
00:42:15,860 --> 00:42:17,270
冲突是，

628
00:42:17,270 --> 00:42:20,090
如果版本号已递增，

629
00:42:20,240 --> 00:42:25,190
从协调者读取了对象，

630
00:42:25,370 --> 00:42:26,990
所以如果版本号是不同的，

631
00:42:30,720 --> 00:42:35,930
是不同的，则事务中止，

632
00:42:39,760 --> 00:42:41,740
如果仍然是一样的，

633
00:42:41,740 --> 00:42:48,010
这意味着没有其他事务修改了对象，

634
00:42:48,250 --> 00:42:50,350
然后我们可以继续并提交。

635
00:42:52,860 --> 00:42:54,690
当然，在中止的情况下，

636
00:42:54,690 --> 00:42:56,280
通常会发生的情况是，

637
00:42:56,280 --> 00:43:00,900
客户端可能会再次运行整个事务，

638
00:43:01,400 --> 00:43:04,700
也许在开始之前等一段时间，

639
00:43:04,730 --> 00:43:06,500
一段随机的时间。

640
00:43:07,730 --> 00:43:10,250
所以这就是基本的计划，

641
00:43:10,250 --> 00:43:12,260
这是一个乐观的方案，

642
00:43:12,350 --> 00:43:16,340
这样读取可以完全利用 RDMA ，

643
00:43:16,610 --> 00:43:18,020
正如我们将看到的，

644
00:43:18,020 --> 00:43:23,570
读取不需要服务器上的任何状态变化。

645
00:43:25,500 --> 00:43:30,120
所以这是图 4 背后的基本思想，

646
00:43:31,710 --> 00:43:33,420
除了，我们很快就会看到，

647
00:43:33,420 --> 00:43:35,460
这件事要复杂得多。

648
00:43:36,190 --> 00:43:40,120
所以这也是，我想我用过了这个短语，

649
00:43:40,120 --> 00:43:41,110
几节课前，

650
00:43:41,230 --> 00:43:44,800
乐观方案与悲观方案相反的是，

651
00:43:44,950 --> 00:43:48,520
你假设你被允许执行操作，

652
00:43:48,760 --> 00:43:51,880
如果你不被允许，只需要道歉和中止，

653
00:43:52,150 --> 00:43:53,650
在悲观的情况下，

654
00:43:53,650 --> 00:43:57,790
你首先通过获取锁来请求批准进行操作，

655
00:43:57,940 --> 00:43:59,680
然后你被保证，

656
00:43:59,680 --> 00:44:01,660
在提交时，你可以提交。

657
00:44:02,480 --> 00:44:03,050
好的?

658
00:44:04,920 --> 00:44:08,610
对于高级别的乐观并发控制，有什么问题吗？

659
00:44:10,670 --> 00:44:12,470
只是一个关于版本号的问题，

660
00:44:12,470 --> 00:44:14,840
他们如何确保两个不同的[]，

661
00:44:14,840 --> 00:44:18,500
两个不同的对象之间具有一致性，

662
00:44:18,770 --> 00:44:22,970
你先读取一个对象，然后再读取另一个对象，

663
00:44:22,970 --> 00:44:27,080
但是一个事务修改了其中的一些。

664
00:44:27,350 --> 00:44:29,810
是的，这是个很好的问题，

665
00:44:29,960 --> 00:44:32,960
所以，我想我们要离开了，

666
00:44:32,960 --> 00:44:35,180
只需要深入到图 4 ，

667
00:44:35,890 --> 00:44:38,200
我认为这是论文的核心。

668
00:44:39,440 --> 00:44:42,470
让我们看一下图 4 ，

669
00:44:43,310 --> 00:44:51,940
糟糕，不是那个。

670
00:44:56,630 --> 00:44:57,800
好的，这是图 4 ，

671
00:45:00,160 --> 00:45:03,550
我们将花相当多的时间来讨论图 4 。

672
00:45:04,960 --> 00:45:10,540
所以图 4 中的第一个东西，

673
00:45:10,570 --> 00:45:13,150
我们看到，

674
00:45:17,910 --> 00:45:22,920
所以我们有一个事务协调者，这里的 C ，

675
00:45:23,190 --> 00:45:26,700
事务协调者是一个应用程序，

676
00:45:26,730 --> 00:45:29,040
应用程序运行在相同的机器上，

677
00:45:29,040 --> 00:45:30,540
是 90 台机器中的一台，

678
00:45:30,810 --> 00:45:32,670
但我会这样考虑，

679
00:45:32,850 --> 00:45:34,140
对于剩余的课程，

680
00:45:34,140 --> 00:45:35,490
它在一台单独的机器上运行，

681
00:45:35,490 --> 00:45:37,920
我不太关心它，好吗？

682
00:45:38,620 --> 00:45:40,900
然后，有不同的分片，

683
00:45:41,200 --> 00:45:45,310
在这种情况下，有 3 个分片， 1 2 和 3 ，

684
00:45:45,640 --> 00:45:48,250
每个分片被复制两次，

685
00:45:48,250 --> 00:45:49,840
一个在主服务器，一个在备服务器。

686
00:45:51,050 --> 00:45:54,260
然后我们会看到，

687
00:45:54,260 --> 00:45:56,150
这是事务的执行阶段，

688
00:45:56,150 --> 00:45:57,920
所以事务有两个阶段，

689
00:45:58,040 --> 00:46:02,030
一个是执行阶段，然后是提交阶段，

690
00:46:02,030 --> 00:46:04,190
在执行阶段期间，

691
00:46:04,190 --> 00:46:05,990
这是事务运行的地方，

692
00:46:05,990 --> 00:46:08,330
那么它执行开始，执行读取，

693
00:46:08,600 --> 00:46:11,720
例如，在这种情况中， 3 个对象被读取，

694
00:46:11,870 --> 00:46:14,960
一个位于，它的主服务器，

695
00:46:15,050 --> 00:46:17,270
一个对象在分片 1 ，

696
00:46:17,420 --> 00:46:19,370
一个对象在分片 3 ，

697
00:46:19,370 --> 00:46:22,950
一个对象在分片 2 ，区域 2 。

698
00:46:23,550 --> 00:46:27,660
我们可以看到，

699
00:46:27,660 --> 00:46:29,310
我们向前看一点，

700
00:46:29,640 --> 00:46:31,290
我们将会看到，

701
00:46:31,830 --> 00:46:35,130
两个对象正在被写入，

702
00:46:35,130 --> 00:46:36,690
一个正在被读取，

703
00:46:36,960 --> 00:46:40,350
所以，来自分片 3 的对象，

704
00:46:40,410 --> 00:46:41,730
这是一个读操作，

705
00:46:41,820 --> 00:46:43,440
这些是写操作，

706
00:46:43,890 --> 00:46:45,000
或者这些是读操作，

707
00:46:45,000 --> 00:46:47,400
但这些对象将被修改。

708
00:46:48,270 --> 00:46:50,550
所以，随着事务的运行，

709
00:46:50,550 --> 00:46:55,050
它从不同的机器获取对象，在本地修改它们，

710
00:46:55,230 --> 00:47:00,360
然后在提交阶段，应用更改，

711
00:47:00,510 --> 00:47:03,180
当然，这里的整个挑战是，

712
00:47:03,180 --> 00:47:07,560
最终，我们希望实现严格的可串行化。

713
00:47:18,740 --> 00:47:24,800
在某些方面，协议，

714
00:47:24,800 --> 00:47:29,150
至少写入的协议总是遵循非常类似的两阶段提交协议，

715
00:47:29,150 --> 00:47:30,260
这是我们过去看到的，

716
00:47:30,260 --> 00:47:31,730
在细节上有所不同，

717
00:47:31,880 --> 00:47:34,610
但基本策略是相同的，

718
00:47:34,610 --> 00:47:36,110
我们可以，

719
00:47:36,200 --> 00:47:39,920
我们假设我们已经完成了执行阶段，

720
00:47:39,920 --> 00:47:42,260
所以我们在事务的末尾，

721
00:47:42,260 --> 00:47:43,940
事务将尝试提交，

722
00:47:44,250 --> 00:47:45,990
事务可能会有两种结果，

723
00:47:45,990 --> 00:47:48,690
成功提交或中止，

724
00:47:49,420 --> 00:47:52,870
中止是因为其他事务同时运行，

725
00:47:52,990 --> 00:47:54,400
并且修改了其中一个对象，

726
00:47:54,400 --> 00:47:56,680
我们写入或想要写入。

727
00:47:59,190 --> 00:48:01,170
所以，第一件事，

728
00:48:01,170 --> 00:48:05,190
协议的提交阶段有 5 个步骤，

729
00:48:05,190 --> 00:48:08,190
加锁步骤，验证步骤，

730
00:48:08,220 --> 00:48:10,500
提交备份步骤，提交 primary 步骤，

731
00:48:10,590 --> 00:48:11,400
然后是截断，

732
00:48:11,400 --> 00:48:15,900
截断运行得[很慢]，

733
00:48:15,900 --> 00:48:17,670
所以这并不是很重要，

734
00:48:17,880 --> 00:48:19,320
从我们的角度来看，

735
00:48:19,320 --> 00:48:23,310
有趣的事情停止的地方就是这里，

736
00:48:23,370 --> 00:48:26,160
这就是事务的结束。

737
00:48:27,820 --> 00:48:31,540
好的，这些对象之前都说过，

738
00:48:31,570 --> 00:48:33,430
当你读到它们，有一个版本号，

739
00:48:33,430 --> 00:48:35,050
这是一个版本号，

740
00:48:37,290 --> 00:48:41,370
在本地修改它们，

741
00:48:41,370 --> 00:48:42,480
然后在这一点上，

742
00:48:42,480 --> 00:48:44,580
这是提交点，

743
00:48:44,940 --> 00:48:47,280
当应用调用结束事务时，

744
00:48:47,550 --> 00:48:52,470
整个提交阶段协议才起作用。

745
00:48:53,550 --> 00:48:56,550
所以它做的第一件事是，

746
00:48:56,550 --> 00:48:59,070
所谓的锁步骤，步骤 1 ，

747
00:48:59,280 --> 00:49:01,470
这一步的目标是，

748
00:49:01,470 --> 00:49:05,370
获取正在写入的所有对象的锁，

749
00:49:06,110 --> 00:49:08,660
所以我们可以看到，根据这张图，

750
00:49:08,660 --> 00:49:12,260
显然有两个对象正在被写入，

751
00:49:12,290 --> 00:49:16,710
即这个对象，

752
00:49:16,710 --> 00:49:20,760
因为上下文是分片 1 ，区域 1 ，

753
00:49:20,910 --> 00:49:22,740
然后这个对象被读取，

754
00:49:22,800 --> 00:49:26,160
它位于区域 2 ，

755
00:49:26,490 --> 00:49:29,880
显然，我们读取第三个对象是 primary 3 的，

756
00:49:30,240 --> 00:49:32,430
它没有被写入，

757
00:49:32,430 --> 00:49:36,120
因为它不参与锁阶段。

758
00:49:36,700 --> 00:49:38,560
所以在锁阶段，

759
00:49:40,400 --> 00:49:43,490
箭头有各种不同的含义。

760
00:49:43,610 --> 00:49:48,230
所以这些虚线箭头是单面 RDMA ，

761
00:49:57,100 --> 00:49:59,530
这些对象是使用 RDMA 读取的，

762
00:49:59,530 --> 00:50:02,920
它们从远程内存位置获取，

763
00:50:02,980 --> 00:50:09,400
[]本地到应用程序或协调者的内存。

764
00:50:14,620 --> 00:50:17,170
实线的是写入 RDMA ，

765
00:50:17,960 --> 00:50:22,830
在这个案例中，

766
00:50:26,350 --> 00:50:34,500
它们依赖于主服务器的锁条目，

767
00:50:34,500 --> 00:50:35,910
所以主服务器有一个日志，

768
00:50:36,030 --> 00:50:37,500
每个主服务器都有一个日志，

769
00:50:37,530 --> 00:50:39,150
所以我画成这样，

770
00:50:39,980 --> 00:50:43,580
使用不同的颜色，

771
00:50:43,940 --> 00:50:47,210
所以这里我们有 Pi 日志，

772
00:50:49,380 --> 00:50:57,100
协调者，这是一个提交记录，

773
00:50:58,270 --> 00:51:07,060
不是，抱歉，锁记录到日志中，

774
00:51:07,090 --> 00:51:08,440
我让它是一个大的记录，

775
00:51:08,440 --> 00:51:09,910
我可以写下里面的东西，

776
00:51:10,330 --> 00:51:13,780
它是版本号，读写时间，

777
00:51:13,780 --> 00:51:14,890
当对象被读取时，

778
00:51:14,890 --> 00:51:16,750
版本号从这里出来，

779
00:51:18,690 --> 00:51:21,270
回到日志记录中的，

780
00:51:21,450 --> 00:51:26,490
读取的对象 id 和对象的新值，

781
00:51:29,560 --> 00:51:34,210
所以，这条记录追加到

782
00:51:34,690 --> 00:51:40,300
primary 1 和 primary 2 的日志，

783
00:51:40,480 --> 00:51:42,580
使用写入 RDMA ，

784
00:51:43,360 --> 00:51:46,690
所以这些机器上有一些线程，

785
00:51:46,780 --> 00:51:49,480
查看这些日志，然后执行一些操作，

786
00:51:50,190 --> 00:51:51,780
所以在这个案例中，

787
00:51:51,780 --> 00:51:56,250
有线程在 P1 P2 上，

788
00:51:56,250 --> 00:52:00,510
监控、旋转或轮询这个日志，

789
00:52:00,690 --> 00:52:02,370
看到有一个新的日志记录，

790
00:52:02,370 --> 00:52:04,950
然后在这种情况下，它会做什么，

791
00:52:05,010 --> 00:52:07,260
它将尝试获取对象的锁，

792
00:52:07,260 --> 00:52:15,050
在事务中列出的，

793
00:52:15,050 --> 00:52:16,400
在某个地方，有一个对象，

794
00:52:18,300 --> 00:52:20,310
对象中包含一些数据，

795
00:52:20,310 --> 00:52:22,860
它里面有这些锁位和版本号。

796
00:52:25,240 --> 00:52:27,730
所以 P1 有一个对象，

797
00:52:27,730 --> 00:52:32,440
这是由协调者修改的，

798
00:52:32,440 --> 00:52:35,290
P2 有另一个对象，由协调者修改，

799
00:52:35,620 --> 00:52:44,590
primary 尝试获取对象的锁，

800
00:52:44,590 --> 00:52:45,850
使用 test-and-set 指令，

801
00:52:46,540 --> 00:52:49,720
所以，它将尝试设置锁位，

802
00:52:52,050 --> 00:52:54,090
使用 test-and-set 指令，

803
00:52:54,300 --> 00:52:57,930
如果锁位为 0 ，

804
00:52:57,930 --> 00:53:03,030
锁位是 0 ，

805
00:53:03,030 --> 00:53:04,920
并成功地将位设置为 1 ，

806
00:53:05,190 --> 00:53:10,680
然后 primary 知道获取了锁，

807
00:53:10,830 --> 00:53:14,970
在这种情况下，我们将发回一条 RDMA 消息，

808
00:53:15,000 --> 00:53:18,900
将消息附加到协调者的消息队列，

809
00:53:18,900 --> 00:53:24,520
说好的，你成功地获得了这些对象的锁。

810
00:53:26,060 --> 00:53:32,420
如果锁已经被另一个事务获取，

811
00:53:32,750 --> 00:53:34,550
然后在那个时间点，

812
00:53:34,550 --> 00:53:36,320
事务被中止，

813
00:53:36,500 --> 00:53:40,910
所以当 primary i 试图获取锁的时候，

814
00:53:40,940 --> 00:53:42,650
发现锁已经设置好了，

815
00:53:42,800 --> 00:53:44,690
使用 test-and-set 指令，

816
00:53:44,780 --> 00:53:48,620
然后试着获取锁会失败，

817
00:53:51,060 --> 00:53:56,820
primary 将添加一条消息

818
00:53:56,820 --> 00:54:01,350
到协调者的队列中，

819
00:54:01,380 --> 00:54:04,350
说，我不能获取锁，

820
00:54:04,530 --> 00:54:07,890
在这种情况下，协调者将中止事务。

821
00:54:10,060 --> 00:54:11,260
到目前为止，还有什么问题吗？

822
00:54:13,040 --> 00:54:16,040
这些锁是如何获取的，通过 zookeeper 吗？

823
00:54:16,600 --> 00:54:19,990
不，是另一套锁使用 zookeeper ，

824
00:54:19,990 --> 00:54:21,610
是为了进行配置管理，

825
00:54:21,610 --> 00:54:29,420
比如区域编号到 primary 和 backup 的映射，

826
00:54:29,480 --> 00:54:34,550
这些只是内存锁，由 primary 维护，

827
00:54:34,550 --> 00:54:36,320
所以在地址空间中，

828
00:54:36,320 --> 00:54:38,330
稍微向后一点，

829
00:54:38,690 --> 00:54:40,310
回到这张图片上，

830
00:54:40,460 --> 00:54:42,680
有一个区域有对象，

831
00:54:42,710 --> 00:54:45,950
每个对象都有一些数据和头部，

832
00:54:46,160 --> 00:54:49,490
在那个头部中，有一个 64 位编号，

833
00:54:49,730 --> 00:54:52,580
最高位是锁位，

834
00:54:52,580 --> 00:54:55,310
其他 63 位是版本编号。

835
00:54:56,010 --> 00:54:58,470
哦，如果 primary 停机怎么办，

836
00:54:58,470 --> 00:55:01,080
backup 是否有与 primary 相同的锁？

837
00:55:01,780 --> 00:55:03,160
如果 primary 停机，

838
00:55:03,160 --> 00:55:06,400
接下来会发生的是，

839
00:55:06,400 --> 00:55:08,260
有一个完整的重新配置协议，

840
00:55:08,290 --> 00:55:11,110
在一个新的恢复协议中，

841
00:55:11,780 --> 00:55:13,550
其最终结果是，

842
00:55:13,550 --> 00:55:17,150
在这种情况下，我们希望事务会中止，

843
00:55:17,150 --> 00:55:18,920
因为它不会到达最后。

844
00:55:19,720 --> 00:55:22,150
我们稍后会讨论容错，

845
00:55:22,150 --> 00:55:23,410
所以让我们来，

846
00:55:23,590 --> 00:55:26,290
我会再讨论几个白板，

847
00:55:26,290 --> 00:55:27,580
我会谈到容错。

848
00:55:27,730 --> 00:55:28,150
谢谢。

849
00:55:31,210 --> 00:55:34,570
所以版本号是每个对象的，对吧？

850
00:55:35,260 --> 00:55:36,730
当然，每个对象的，是的。

851
00:55:38,620 --> 00:55:39,250
[]。

852
00:55:42,080 --> 00:55:46,180
好的，那么，好的。

853
00:55:46,180 --> 00:55:47,200
我能问个问题吗，

854
00:55:48,130 --> 00:55:50,860
为什么他们选择中止事务，

855
00:55:50,860 --> 00:55:53,680
而不是阻塞并等待锁被释放？

856
00:55:54,660 --> 00:55:57,090
因为它们读到了旧的[材料]，

857
00:55:57,920 --> 00:56:00,950
它们没有读到最新的值，

858
00:56:01,190 --> 00:56:03,500
所以，事务必须中止。

859
00:56:04,940 --> 00:56:05,510
哦，我明白了，

860
00:56:05,510 --> 00:56:08,780
因为锁意味着下一次它会改变。

861
00:56:08,810 --> 00:56:13,360
好的，它们在写完对象后才要求加锁，

862
00:56:13,570 --> 00:56:17,290
协调者基于某个版本号修改对象，

863
00:56:17,650 --> 00:56:19,570
提交了一些写入，

864
00:56:19,840 --> 00:56:22,420
假设写入最新的版本号，

865
00:56:22,780 --> 00:56:28,390
这个时刻，提交开始，

866
00:56:28,390 --> 00:56:29,740
然后你试图获取锁，

867
00:56:29,980 --> 00:56:31,720
你发现另一个已经获取了锁，

868
00:56:31,720 --> 00:56:33,310
这意味着其他人已经修改它了，

869
00:56:33,610 --> 00:56:36,610
所以这会违反串行化。

870
00:56:37,820 --> 00:56:38,840
是的，谢谢。

871
00:56:39,110 --> 00:56:41,420
所以，你在这里得到锁的时候，

872
00:56:41,780 --> 00:56:44,450
这在某种程度上是写事务的串行化点，

873
00:56:45,700 --> 00:56:49,210
在这个点，事务已经获取了所有锁，

874
00:56:49,210 --> 00:56:50,950
对于所有被修改的对象，

875
00:56:51,160 --> 00:56:55,120
在这个时间点上，其他人都不能修改，

876
00:56:55,300 --> 00:56:58,660
这在某种程度上是事务的写入部分的串行化点。

877
00:57:02,180 --> 00:57:02,690
能理解吗?

878
00:57:04,480 --> 00:57:05,380
是的，谢谢。

879
00:57:07,060 --> 00:57:10,780
好的，现在你可能会觉得，

880
00:57:10,780 --> 00:57:14,440
为什么不对读取做同样的事情，

881
00:57:14,440 --> 00:57:17,260
获取读取对象的锁，

882
00:57:17,260 --> 00:57:19,210
从读取的对象中获取锁，

883
00:57:19,210 --> 00:57:21,220
检查版本号[]。

884
00:57:21,860 --> 00:57:25,700
原因是这是一个独立的阶段，

885
00:57:25,700 --> 00:57:27,110
即验证阶段，

886
00:57:27,530 --> 00:57:32,000
是为了避免这些昂贵的写入 RDMA ，

887
00:57:32,270 --> 00:57:33,710
如果你看这个竖直的步骤，

888
00:57:33,710 --> 00:57:35,210
你将看到有一个写入 RDMA ，

889
00:57:35,390 --> 00:57:37,400
服务器必须运行一些东西，

890
00:57:37,430 --> 00:57:40,190
基本上是获取锁，

891
00:57:40,580 --> 00:57:42,560
然后用另一个写入 RDMA 进行响应。

892
00:57:42,560 --> 00:57:44,840
所以这是一个完整的 RPC ，

893
00:57:46,480 --> 00:57:48,610
需要服务器的参与，

894
00:57:49,360 --> 00:57:50,740
正如我们稍后将看到的，

895
00:57:50,980 --> 00:57:55,300
为了处理对象已被读取，

896
00:57:55,570 --> 00:58:00,160
FaRM 使用这个校验步骤，

897
00:58:00,160 --> 00:58:03,310
在验证步骤中，仅使用了单边 RDMA ，

898
00:58:03,460 --> 00:58:06,340
所以，不需要真正的服务器参与。

899
00:58:12,080 --> 00:58:12,650
好的?

900
00:58:13,900 --> 00:58:16,060
所以，发生了什么，

901
00:58:16,060 --> 00:58:19,150
所以我们在这一点上，

902
00:58:19,150 --> 00:58:22,660
事务协调者具有写锁，

903
00:58:22,870 --> 00:58:24,070
现在它唯一做的就是，

904
00:58:24,070 --> 00:58:27,820
它验证读锁或读版本号，

905
00:58:28,480 --> 00:58:33,070
所以，对于每个已读取但未修改的对象，

906
00:58:33,130 --> 00:58:34,420
在我们的示例中，

907
00:58:34,420 --> 00:58:35,710
只有一个对象，

908
00:58:35,710 --> 00:58:37,240
这是那个被读取的，

909
00:58:37,880 --> 00:58:40,690
区域 3 的那个，

910
00:58:41,020 --> 00:58:46,810
所以它是单边 RDMA 读取版本编号，

911
00:58:46,810 --> 00:58:50,620
那个正在读取的对象的 64 位编号。

912
00:58:51,770 --> 00:58:55,400
当它回来这里的时候，

913
00:58:55,700 --> 00:58:57,200
它检查两件事，

914
00:58:57,660 --> 00:59:01,200
如果锁被获取，锁位被设置，

915
00:59:01,260 --> 00:59:05,790
这意味着一些并发事务正在试图修改，

916
00:59:06,090 --> 00:59:07,710
所以在这一点上，就中止，

917
00:59:08,260 --> 00:59:10,540
所有事务再次中止，

918
00:59:11,540 --> 00:59:15,710
如果第一个数字是[相同的]且未锁定，

919
00:59:15,830 --> 00:59:19,370
这意味着在此特定时间点没有使用其他事务，

920
00:59:19,610 --> 00:59:23,960
事务可以继续进行，

921
00:59:23,990 --> 00:59:27,260
所有读取和修改的对象，

922
00:59:27,560 --> 00:59:30,230
在事务开始时具有版本号，

923
00:59:30,650 --> 00:59:32,630
一切都还没有改变，

924
00:59:32,780 --> 00:59:35,150
所以，事务提交是可以的，

925
00:59:35,210 --> 00:59:37,730
它是真正的串行化点。

926
00:59:38,600 --> 00:59:40,610
而且由于事务编号

927
00:59:40,610 --> 00:59:42,710
在开始时需要版本号，

928
00:59:42,710 --> 00:59:44,150
在事务开始时，

929
00:59:44,390 --> 00:59:48,710
事务将按照版本号的顺序提交，

930
00:59:48,890 --> 00:59:53,510
它们将获得严格的可串行化，

931
00:59:54,540 --> 00:59:58,350
因为在你的事务提交后启动的任何事务

932
00:59:58,350 --> 00:59:59,760
都将具有更高的版本号，

933
00:59:59,790 --> 01:00:01,230
所以，它也会晚点提交。

934
01:00:04,710 --> 01:00:07,050
好的，这就是那个点，

935
01:00:07,050 --> 01:00:09,960
事务协调者说，

936
01:00:10,260 --> 01:00:12,900
在这一点上，

937
01:00:14,230 --> 01:00:17,650
我们知道我们必须获得锁，

938
01:00:17,650 --> 01:00:21,970
我们已验证读取对象的版本号，

939
01:00:21,970 --> 01:00:27,170
所以，这是提交点或提交点的开始，

940
01:00:27,170 --> 01:00:29,660
所以这一点是在说，

941
01:00:29,930 --> 01:00:32,210
好的，我要提交了。

942
01:00:34,120 --> 01:00:38,200
提交点需要多条消息，

943
01:00:38,200 --> 01:00:39,100
我们一会儿就会看到，

944
01:00:39,100 --> 01:00:41,650
这些主要是出于容错的原因。

945
01:00:44,400 --> 01:00:45,930
所以在这一点上，

946
01:00:45,930 --> 01:00:49,680
只有 primary 已经，

947
01:00:49,980 --> 01:00:56,730
只有 primary 已经联系正被修改的对象，

948
01:00:56,730 --> 01:00:57,750
但不包括 backup 。

949
01:00:58,120 --> 01:01:01,180
当然，我们想要确保这一点，并写下，

950
01:01:01,180 --> 01:01:05,680
一旦你提交，就能容忍 f 个故障，

951
01:01:05,680 --> 01:01:08,800
系统设计为处理 f+1 个故障，

952
01:01:09,460 --> 01:01:13,330
在我们的设计中，有一个备份，

953
01:01:13,330 --> 01:01:15,430
所以它只能容忍一个故障。

954
01:01:16,930 --> 01:01:20,740
所以发生在最后一个阶段，提交备份阶段，

955
01:01:20,800 --> 01:01:26,650
是我们要写入备份的日志，

956
01:01:26,650 --> 01:01:29,440
所以备份有日志，

957
01:01:30,210 --> 01:01:31,710
所以这是 Bi ，

958
01:01:31,770 --> 01:01:33,660
类似的，里面有一个日志条目，

959
01:01:34,290 --> 01:01:38,520
我们要做的是，

960
01:01:38,670 --> 01:01:41,520
写下所谓的提交备份记录，

961
01:01:50,500 --> 01:01:56,650
提交备份记录与锁记录相同的信息，

962
01:01:56,650 --> 01:01:57,520
我们之前看到的，

963
01:01:57,520 --> 01:02:04,300
所以，它将包含版本号 oid 和新值。

964
01:02:07,870 --> 01:02:08,650
好的？

965
01:02:09,580 --> 01:02:16,030
像之前一样，这是使用写入 RDMA ，

966
01:02:21,190 --> 01:02:25,060
现在，备份在这一点上并不需要执行任何操作，

967
01:02:25,060 --> 01:02:27,730
备份服务器端不需要运行任何东西，

968
01:02:27,820 --> 01:02:32,620
所以这是这个技巧，

969
01:02:32,710 --> 01:02:36,160
发送者等待网卡的确认，

970
01:02:36,800 --> 01:02:42,560
所以这不是单方面的，也不是写入 RDMA ，

971
01:02:42,680 --> 01:02:45,950
这只是确认它已获得写入 RDMA ，

972
01:02:45,950 --> 01:02:47,870
并且已经执行了写入 RDMA 。

973
01:02:48,380 --> 01:02:49,910
所以，这是在确认，

974
01:02:49,910 --> 01:02:52,670
当我们在协议中这一点时，

975
01:02:52,880 --> 01:02:54,710
事务协调者知道，

976
01:02:54,860 --> 01:02:58,790
对象在所有 primary 的日志中，

977
01:02:59,150 --> 01:03:01,970
以及对象在所有备份日志中。

978
01:03:02,420 --> 01:03:05,390
所以现在我们在容错性方面处于有利地位，

979
01:03:05,390 --> 01:03:09,170
因为如果两者中的任何一个失败了，

980
01:03:09,260 --> 01:03:11,720
另一个可以应用写操作。

981
01:03:13,870 --> 01:03:18,670
然后还有一个步骤需要执行，

982
01:03:18,940 --> 01:03:21,880
那就是提交 primary ，

983
01:03:21,910 --> 01:03:24,190
稍后我会更详细地谈到，

984
01:03:24,400 --> 01:03:26,950
但这是最后一步，

985
01:03:26,950 --> 01:03:30,010
更多日志记录写入，

986
01:03:30,010 --> 01:03:32,890
在 primary 中，也就是提交记录，

987
01:03:38,620 --> 01:03:42,910
提交记录是正在提交的事务 id 。

988
01:03:44,390 --> 01:03:46,220
所以像每个，

989
01:03:46,220 --> 01:03:48,080
我没有把它写在其他记录里，

990
01:03:48,080 --> 01:03:49,730
但是每个记录都有一个事务 id ，

991
01:03:49,730 --> 01:03:51,710
我们知道我们谈论的是哪一个事务。

992
01:03:53,380 --> 01:03:57,700
同样，这也使用了相同的策略，

993
01:03:57,700 --> 01:04:08,590
有一个写入 RDMA 要附加到日志，

994
01:04:08,890 --> 01:04:16,240
有一个网卡确认写入 RDMA ，

995
01:04:16,270 --> 01:04:18,700
但它不需要任何中断，

996
01:04:19,030 --> 01:04:22,540
或者没有服务器，本身不受干扰，

997
01:04:22,630 --> 01:04:25,510
只有网卡参与了这两个操作。

998
01:04:26,800 --> 01:04:33,560
一旦其中一个网卡确认提交记录，

999
01:04:33,560 --> 01:04:34,910
在一个 primary 上，

1000
01:04:35,000 --> 01:04:36,620
在那个时间点，

1001
01:04:36,710 --> 01:04:38,510
它是真正提交的，

1002
01:04:39,000 --> 01:04:40,650
所以这是真正的提交点，

1003
01:04:43,820 --> 01:04:45,350
提交从这里开始，

1004
01:04:45,350 --> 01:04:47,090
这是实际的提交点，

1005
01:04:47,360 --> 01:04:48,860
在这个特定时间点上，

1006
01:04:49,010 --> 01:04:51,890
事务协调者通知应用程序，

1007
01:04:51,980 --> 01:04:55,430
是的，你的事务已经提交，并且已经完成。

1008
01:04:57,470 --> 01:04:59,150
当然，稍后某个时刻，

1009
01:04:59,150 --> 01:05:02,750
日志需要清理、缩短和截断，诸如此类的事情，

1010
01:05:02,750 --> 01:05:05,480
这就是截断阶段，

1011
01:05:05,690 --> 01:05:10,220
这是[]后面的锁阶段和验证阶段，

1012
01:05:10,950 --> 01:05:13,380
所以我不会讨论它，

1013
01:05:13,380 --> 01:05:15,960
但是，它们必须截断日志，

1014
01:05:15,960 --> 01:05:17,580
这样它们不会无限生长。

1015
01:05:23,640 --> 01:05:27,960
抱歉，硬件会起作用，

1016
01:05:27,960 --> 01:05:34,400
它们只是直接进入协调者的网卡？

1017
01:05:34,400 --> 01:05:37,970
是的，让我们回到 RDMA 的图片上，

1018
01:05:38,360 --> 01:05:40,250
如果发生写入 RDMA ，

1019
01:05:41,090 --> 01:05:43,100
所以这是写入 RDMA ，

1020
01:05:43,250 --> 01:05:46,160
发送者协调者在这里运行，

1021
01:05:46,190 --> 01:05:48,800
这可能是 primary 和 backup 之一，

1022
01:05:49,600 --> 01:05:52,180
所以写入 RDMA 进入，

1023
01:05:52,210 --> 01:05:54,970
可能写入一个条目到日志中，

1024
01:05:54,970 --> 01:05:58,150
网卡发回一个确认，

1025
01:06:00,170 --> 01:06:03,410
协调者将在接收队列中看到确认，

1026
01:06:07,180 --> 01:06:13,150
一旦协调者看到它的写入 RDMA 的 ack ，

1027
01:06:13,300 --> 01:06:15,520
它可以继续，

1028
01:06:16,380 --> 01:06:18,390
并且知道写入 RDMA 成功了。

1029
01:06:23,920 --> 01:06:28,300
所以写入 RDMA 只是写入日志，它们。

1030
01:06:28,930 --> 01:06:30,850
它们用在两种情况下，

1031
01:06:30,910 --> 01:06:37,060
它们用于这些消息队列和日志追加。

1032
01:06:41,620 --> 01:06:45,040
所以，当我们说已经执行了写入 RDMA 时，

1033
01:06:45,040 --> 01:06:47,020
我们的意思是它已被附加到日志中，

1034
01:06:47,050 --> 01:06:49,990
并不一定由应用程序实际执行。

1035
01:06:50,050 --> 01:06:52,030
对，对，

1036
01:06:52,030 --> 01:06:53,440
例如，

1037
01:06:53,440 --> 01:06:58,840
例如，备份执行对象的更新，

1038
01:06:58,840 --> 01:07:01,870
你需要读取日志条目，然后应用更新。

1039
01:07:03,730 --> 01:07:04,090
我明白了，

1040
01:07:04,090 --> 01:07:06,850
还有每个对象的锁位，

1041
01:07:06,850 --> 01:07:08,830
由于一切都驻留在内存中，

1042
01:07:08,830 --> 01:07:12,250
我们有 64 位的版本号加上锁位，

1043
01:07:12,430 --> 01:07:15,700
所以我想它可以放入一个单一的内存地址，

1044
01:07:15,910 --> 01:07:17,500
但我们仍然会有这样的问题，

1045
01:07:17,500 --> 01:07:21,880
假设处理器将该内存地址提取到寄存器中，

1046
01:07:22,150 --> 01:07:25,600
然后，如果我们有一台多核计算机，

1047
01:07:25,600 --> 01:07:29,440
然后另一个内核获取相同的地址，

1048
01:07:29,440 --> 01:07:32,140
然后它们都从 0 翻到 1 ，

1049
01:07:32,500 --> 01:07:35,800
所以我假设有一些来自硬件的支持？

1050
01:07:35,920 --> 01:07:38,050
是的，就像我之前提到的，

1051
01:07:38,050 --> 01:07:39,550
当 primary 获取，

1052
01:07:39,550 --> 01:07:45,160
primary 涉及到，

1053
01:07:45,160 --> 01:07:46,540
所以协调者发送，

1054
01:07:46,540 --> 01:07:50,380
所以在锁阶段，这个阶段一，

1055
01:07:50,590 --> 01:07:57,940
primary 或 coordinator 发送写入 RDMA 到 primary ，

1056
01:07:57,970 --> 01:08:02,220
要求 primary 将对象加锁，

1057
01:08:02,730 --> 01:08:07,830
primary 用一条信息明确地回答，然后回复，

1058
01:08:08,220 --> 01:08:11,580
所以发生的这一关键步骤是，

1059
01:08:11,580 --> 01:08:13,680
当 primary 试着获取锁，

1060
01:08:14,010 --> 01:08:16,380
锁已经设置了，

1061
01:08:16,410 --> 01:08:19,500
这是一个单一的 64 位数字的原因，

1062
01:08:19,620 --> 01:08:21,630
是因为你可以使用 test-and-set 指令，

1063
01:08:21,780 --> 01:08:24,180
它是原子地设置锁。

1064
01:08:25,640 --> 01:08:29,420
所以，永远不会有这种情况，

1065
01:08:29,420 --> 01:08:33,410
当两个 test-and-set 指令完全同时运行，

1066
01:08:33,500 --> 01:08:35,390
一个会赢，另一个会输。

1067
01:08:36,500 --> 01:08:37,400
我明白了，谢谢。

1068
01:08:38,090 --> 01:08:39,920
这是一个关键点。

1069
01:08:42,350 --> 01:08:46,370
我有一个关于蓝色提交点的问题。

1070
01:08:47,190 --> 01:08:48,180
嗯。

1071
01:08:49,220 --> 01:08:50,420
它不会，所以。

1072
01:08:50,660 --> 01:08:52,100
我应该，让我，

1073
01:08:52,100 --> 01:08:55,730
也许再打开一张带有图片的新幻灯片更好，

1074
01:08:55,730 --> 01:08:59,030
不是在这个上面继续涂鸦，

1075
01:08:59,490 --> 01:09:01,110
我是说，我们再来一张图，

1076
01:09:01,110 --> 01:09:03,270
这样我们就可以讨论其他场景了，

1077
01:09:14,240 --> 01:09:15,350
我想再大一点，

1078
01:09:15,530 --> 01:09:17,150
我认为应该这么做。

1079
01:09:18,410 --> 01:09:21,910
好的，所以你担心的是，

1080
01:09:21,940 --> 01:09:22,720
让我看一下。

1081
01:09:23,590 --> 01:09:27,520
是的，那个提交点在步骤 2 和步骤 3 之间。

1082
01:09:27,670 --> 01:09:30,370
是的，这是[决定点]。

1083
01:09:30,370 --> 01:09:30,760
是的。

1084
01:09:31,240 --> 01:09:36,210
开始提交，然后是实际提交点。

1085
01:09:37,090 --> 01:09:41,140
好的，我想我是在想这个场景，

1086
01:09:41,140 --> 01:09:47,440
对于一个完全独立的并发事务是否可能，

1087
01:09:47,830 --> 01:09:51,820
只写入 P3 进行交错，

1088
01:09:51,850 --> 01:09:55,390
在那个空间里开始和完成，

1089
01:09:55,840 --> 01:09:56,890
然后这样不是？

1090
01:09:57,450 --> 01:09:58,170
不，[]，

1091
01:09:58,170 --> 01:10:01,290
是的，我们有问题，但不能，

1092
01:10:01,290 --> 01:10:02,160
因为当它写入时，

1093
01:10:02,160 --> 01:10:03,660
它在某个点上获得锁，

1094
01:10:04,580 --> 01:10:05,960
当我们获得锁时，

1095
01:10:05,960 --> 01:10:07,580
我们检查版本号和锁位。

1096
01:10:10,580 --> 01:10:14,630
但是，读取 P3 会影响版本号和锁位吗？

1097
01:10:15,290 --> 01:10:17,450
不，它只获取版本号。

1098
01:10:19,350 --> 01:10:23,370
但如果你，让我保留这个问题，

1099
01:10:23,370 --> 01:10:24,570
你会回到这个问题上。

1100
01:10:25,250 --> 01:10:27,470
好的，我们看看会发生什么？

1101
01:10:28,820 --> 01:10:29,570
好的，谢谢。

1102
01:10:31,640 --> 01:10:32,630
还有其他问题吗？

1103
01:10:34,930 --> 01:10:36,490
这可能像是一个单独的场景，

1104
01:10:36,490 --> 01:10:41,410
但如果你在执行阶段之后，会发生什么，

1105
01:10:41,980 --> 01:10:45,160
它试图获取一个锁，

1106
01:10:45,190 --> 01:10:47,530
然后就在那之后崩溃了，

1107
01:10:47,800 --> 01:10:49,120
锁已经被获取，

1108
01:10:49,120 --> 01:10:50,830
但在那之后，其他任何人都无法获得它。

1109
01:10:51,830 --> 01:10:55,730
是的，好的，首先，机器从地球上消失了，

1110
01:10:55,730 --> 01:10:57,320
内存内容也消息了，

1111
01:10:59,200 --> 01:11:02,470
在整个恢复协议中，

1112
01:11:02,470 --> 01:11:05,170
在论文的下一节描述的，

1113
01:11:05,760 --> 01:11:09,690
协议最终中止了事务，

1114
01:11:17,640 --> 01:11:19,380
所以，它将得到清理。

1115
01:11:26,440 --> 01:11:27,670
再问一个问题，

1116
01:11:27,700 --> 01:11:33,190
所以这里协调者是客户端，就像应用程序一样。

1117
01:11:33,190 --> 01:11:35,800
是的。

1118
01:11:36,010 --> 01:11:38,800
所以客户端做所有的步骤，

1119
01:11:38,800 --> 01:11:40,390
比如 lock 。

1120
01:11:40,630 --> 01:11:42,850
是的，所以你可以考虑

1121
01:11:42,850 --> 01:11:45,760
应用程序在 90 台机器上运行，

1122
01:11:45,760 --> 01:11:48,370
运行这个事务，

1123
01:11:48,550 --> 01:11:51,220
很显然，写入两个对象，读取一个，

1124
01:11:51,520 --> 01:11:53,740
并且运行这个协议。

1125
01:11:54,540 --> 01:11:58,080
所以，我想令人困惑的是，

1126
01:11:58,260 --> 01:12:02,760
所以 primary 并不直接与 backup 通信吗，它是。

1127
01:12:02,790 --> 01:12:04,830
不，是这样的，

1128
01:12:04,830 --> 01:12:06,930
primary 不直接与 backup 通信。

1129
01:12:07,720 --> 01:12:08,320
我明白了。

1130
01:12:09,980 --> 01:12:11,630
除了在恢复协议期间，

1131
01:12:11,630 --> 01:12:13,040
有各种各样的通信发生，

1132
01:12:13,040 --> 01:12:14,060
但并没有在这里展示。

1133
01:12:18,590 --> 01:12:22,340
所以，协调者使用来 zookeeper 的配置？

1134
01:12:22,340 --> 01:12:26,090
是的，回到第一张图片，

1135
01:12:26,540 --> 01:12:29,690
有各种各样的事情和这个有关，

1136
01:12:29,690 --> 01:12:33,320
我不是在谈论，这种精确的关系之类的事情，

1137
01:12:33,650 --> 01:12:37,310
但是由 zookeepr 和连接管理者决定，

1138
01:12:37,310 --> 01:12:40,820
这是我们运行的当前配置，

1139
01:12:41,120 --> 01:12:42,380
这些是区域，

1140
01:12:42,380 --> 01:12:45,320
它们如何映射主备份和所有这些内容，

1141
01:12:46,600 --> 01:12:48,070
在任何失败发生时，

1142
01:12:48,070 --> 01:12:51,190
有一个完整的重新配置进程并恢复。

1143
01:12:53,370 --> 01:12:54,180
我明白了，谢谢。

1144
01:13:00,820 --> 01:13:05,320
好的，也许我会跳过分组会议室，

1145
01:13:05,320 --> 01:13:08,260
所以我可以走得更远，

1146
01:13:08,380 --> 01:13:10,540
我想要回答的问题，

1147
01:13:10,540 --> 01:13:14,230
在课程中贴出的，

1148
01:13:14,230 --> 01:13:15,790
课程问题，

1149
01:13:15,790 --> 01:13:19,660
我将通过谈论一个事务的例子来回答，

1150
01:13:19,660 --> 01:13:21,700
这也涉及到之前的问题，

1151
01:13:22,090 --> 01:13:23,350
会发生什么，

1152
01:13:23,350 --> 01:13:26,440
两个事务运行并读取一个版本，

1153
01:13:26,440 --> 01:13:29,320
然后它提交了，等等，这些东西。

1154
01:13:29,350 --> 01:13:32,470
所以这是我们要讨论的话题，

1155
01:13:32,470 --> 01:13:34,420
我们是否得到了严格的可串行化？

1156
01:13:39,620 --> 01:13:40,730
我要做的是，

1157
01:13:40,730 --> 01:13:43,760
我不会给你严格串行化的证据，

1158
01:13:43,760 --> 01:13:44,810
相反，我要做的是，

1159
01:13:44,810 --> 01:13:46,520
我来举一两个例子，

1160
01:13:47,100 --> 01:13:48,900
建立一些直觉，

1161
01:13:49,500 --> 01:13:51,570
希望直觉能让你确信，

1162
01:13:51,570 --> 01:13:53,520
事情可能是好的。

1163
01:13:54,370 --> 01:13:56,680
那么让我们来看下面的事务，

1164
01:13:56,740 --> 01:13:57,940
我们有 TxnBegin ，

1165
01:13:59,740 --> 01:14:00,700
这个事务是，

1166
01:14:00,700 --> 01:14:03,940
在一开始，它读取一个对象，

1167
01:14:08,620 --> 01:14:18,930
加 1 ，然后写入对象，

1168
01:14:20,040 --> 01:14:24,410
提交或以失败提交结束，

1169
01:14:26,030 --> 01:14:27,140
所以这是一个事务。

1170
01:14:27,810 --> 01:14:30,900
我们想问你自己，

1171
01:14:30,900 --> 01:14:32,220
合法的结果是什么，

1172
01:14:32,220 --> 01:14:34,260
正确的结果是什么。

1173
01:14:42,100 --> 01:14:45,880
那么，这个事务可能的结果是什么，

1174
01:14:47,290 --> 01:14:48,400
会是什么状态，

1175
01:14:48,490 --> 01:14:50,740
假设 x 从 0 开始，

1176
01:14:50,860 --> 01:14:55,540
我们运行两个事务， T1 和 T2 ，

1177
01:14:57,530 --> 01:15:00,920
有哪些可能的结果是好的。

1178
01:15:04,080 --> 01:15:06,330
它们中的一个可以提交，

1179
01:15:06,330 --> 01:15:07,590
或者它们两个都可以提交？

1180
01:15:08,260 --> 01:15:12,040
是的，所以我们可以得到 x=2 ，两个都提交，

1181
01:15:12,930 --> 01:15:16,650
x=1 ，可能一个提交，另一个中止。

1182
01:15:16,650 --> 01:15:18,630
一般是两个同时运行，

1183
01:15:19,360 --> 01:15:21,370
还有其他可能的结果吗？

1184
01:15:23,940 --> 01:15:24,360
0 。

1185
01:15:24,930 --> 01:15:26,400
是的， 0 ，

1186
01:15:26,430 --> 01:15:28,470
如果两个都中止了，

1187
01:15:28,560 --> 01:15:29,760
也许崩溃了。

1188
01:15:30,920 --> 01:15:33,020
好的，这就是三种合法的结果，

1189
01:15:33,620 --> 01:15:37,130
你必须确保是这样的。

1190
01:15:37,130 --> 01:15:40,910
假设 T1 运行，执行一个读取操作，

1191
01:15:41,360 --> 01:15:43,760
将 x 从版本 0 取回，

1192
01:15:44,120 --> 01:15:49,600
T2 也是一样，它读取 x0 ，

1193
01:15:49,690 --> 01:15:53,050
所以它是真正地同时运行，

1194
01:15:53,410 --> 01:15:56,470
这是我们问的问题，

1195
01:15:56,470 --> 01:15:57,070
那个锁的问题，

1196
01:15:57,070 --> 01:15:59,410
我们执行对 x 加锁，我们执行对 x 加锁，

1197
01:16:00,140 --> 01:16:04,190
这是关键的一步，

1198
01:16:04,190 --> 01:16:06,470
因为在这个时刻，

1199
01:16:06,560 --> 01:16:10,160
我们试图获取对象 0 的锁，

1200
01:16:10,370 --> 01:16:12,860
两个都能成功吗？

1201
01:16:14,860 --> 01:16:15,610
在读取中吗？

1202
01:16:16,090 --> 01:16:17,260
在获取 x 锁的过程中。

1203
01:16:18,610 --> 01:16:19,930
哦，在获取锁的时候，

1204
01:16:19,960 --> 01:16:21,850
不是在同一时间。

1205
01:16:22,480 --> 01:16:24,790
所以一个会成功。

1206
01:16:25,440 --> 01:16:28,200
我们假设第一个成功，并获得了锁，

1207
01:16:28,820 --> 01:16:30,380
这意味着它可以提交，

1208
01:16:31,430 --> 01:16:32,630
所以这个会提交，

1209
01:16:33,290 --> 01:16:36,170
那个第二个会发生什么？

1210
01:16:36,870 --> 01:16:40,560
第二个，如果它同时试图获取锁，

1211
01:16:40,560 --> 01:16:41,820
第一个持有锁，

1212
01:16:41,820 --> 01:16:42,900
它将中止并停止，

1213
01:16:43,320 --> 01:16:47,160
如果第一个事务通过并且锁被释放，

1214
01:16:47,430 --> 01:16:48,960
然后它将获得锁，

1215
01:16:48,960 --> 01:16:54,120
然后检查 x 的版本是否仍然正确，

1216
01:16:54,210 --> 01:16:57,180
它会发现版本已经被更改，

1217
01:16:57,180 --> 01:16:58,020
然后它会中止。

1218
01:16:58,350 --> 01:17:02,040
是的，是这两种情况。

1219
01:17:02,160 --> 01:17:05,040
所以让我稍后来谈谈验证案例，

1220
01:17:05,040 --> 01:17:07,020
使用一个稍有不同的例子，也许更有趣，

1221
01:17:07,320 --> 01:17:09,810
但这就是结果。

1222
01:17:11,520 --> 01:17:15,600
很好，所以即使这张图中的事务，

1223
01:17:15,600 --> 01:17:17,580
同时运行，

1224
01:17:17,610 --> 01:17:19,860
它们也是排序的，

1225
01:17:20,040 --> 01:17:21,690
一个赢了，另一个输了，

1226
01:17:21,930 --> 01:17:24,150
这意味着另一个输了的可以再次运行，

1227
01:17:24,390 --> 01:17:28,590
然后它将读取 Rx1 ，然后希望在重试中成功。

1228
01:17:29,370 --> 01:17:30,030
好的?

1229
01:17:32,710 --> 01:17:34,000
好的，所以。

1230
01:17:39,910 --> 01:17:41,800
好的，让我举个例子，

1231
01:17:41,800 --> 01:17:45,760
然后我会停下来，在周四继续，

1232
01:17:46,760 --> 01:17:48,500
现在时间是 24 分。

1233
01:17:48,530 --> 01:17:49,910
让我停在这里，

1234
01:17:50,120 --> 01:17:52,340
然后我会做第二个例子，

1235
01:17:52,340 --> 01:17:54,620
回答前面的问题，

1236
01:17:54,740 --> 01:17:59,330
在周四，也会讨论一下容错。

1237
01:18:00,120 --> 01:18:02,340
我不想超过太多时间，

1238
01:18:03,940 --> 01:18:06,520
任何人必须离开，请随意离开，

1239
01:18:06,550 --> 01:18:09,310
我们周四见，

1240
01:18:09,310 --> 01:18:13,030
如果有人想问更多的问题，

1241
01:18:13,030 --> 01:18:14,590
可以继续停留，

1242
01:18:14,590 --> 01:18:16,540
我会尽最大努力回答它们，

1243
01:18:16,990 --> 01:18:19,300
如你所见，这是一篇复杂的论文，

1244
01:18:19,570 --> 01:18:22,780
我很高兴我们，

1245
01:18:22,780 --> 01:18:25,090
我们能够深入，并试图理解，

1246
01:18:25,090 --> 01:18:29,060
至少是正常操作的协议。

1247
01:18:32,490 --> 01:18:34,800
说到这里，我想结束这节课，

1248
01:18:34,830 --> 01:18:36,840
周四再见，

1249
01:18:36,840 --> 01:18:38,730
或者如果你有任何问题，请留下来。

1250
01:18:40,680 --> 01:18:44,190
我有两个高级别问题，

1251
01:18:44,190 --> 01:18:50,900
一个是，他们使用的这个整个硬件结构，

1252
01:18:51,020 --> 01:18:53,000
它是否有用，

1253
01:18:53,000 --> 01:18:55,910
如果你将它与悲观并发控制一起使用？

1254
01:18:56,680 --> 01:19:00,640
是的，我相信你也可以让悲观协议变得更好，

1255
01:19:00,640 --> 01:19:03,160
因为 RPC 更便宜，

1256
01:19:03,640 --> 01:19:07,180
但真正的东西，我还没能指出这一点，

1257
01:19:07,180 --> 01:19:08,650
但我试过了，

1258
01:19:08,650 --> 01:19:09,640
我现在可以做，

1259
01:19:09,880 --> 01:19:13,060
如果你看一下这里的只读事务，

1260
01:19:13,740 --> 01:19:15,720
只读事务，

1261
01:19:16,350 --> 01:19:20,670
如果这里的事务只读取一个对象或多个对象，

1262
01:19:24,920 --> 01:19:26,480
性能会怎么样，会有多好，

1263
01:19:26,510 --> 01:19:28,070
它的表现会有多好？

1264
01:19:30,520 --> 01:19:34,990
可能很好，因为你只做单边的（RDMA）。

1265
01:19:35,350 --> 01:19:40,900
是的，如果你看一下保存在区域 3 的对象，

1266
01:19:40,900 --> 01:19:42,310
它是被读取的对象，

1267
01:19:42,460 --> 01:19:50,090
唯一发生的事情是单边读取或单边 RDMA ，

1268
01:19:51,410 --> 01:19:56,570
没有写入，什么都没有，

1269
01:19:56,630 --> 01:20:01,280
所以，因为这个，

1270
01:20:02,670 --> 01:20:05,220
因为读取操作不需要锁，

1271
01:20:05,220 --> 01:20:06,300
没有什么可写，

1272
01:20:06,600 --> 01:20:09,690
唯一需要做的就是这个验证步骤，

1273
01:20:09,720 --> 01:20:11,550
也是单边 RDMA ，

1274
01:20:11,990 --> 01:20:15,380
所以只读事务，你可以只使用两个单边 RDMA 运行，

1275
01:20:16,180 --> 01:20:18,850
这就是好处的来源，

1276
01:20:19,420 --> 01:20:21,790
而这一点的原因是，

1277
01:20:21,790 --> 01:20:23,800
因为是乐观并发控制。

1278
01:20:24,400 --> 01:20:28,480
所以我认为利用 RDMA []，

1279
01:20:28,480 --> 01:20:31,780
我试着让只读交易变得非常快，

1280
01:20:32,170 --> 01:20:36,310
它们必须是乐观并发控制。

1281
01:20:38,390 --> 01:20:40,880
好的，我明白了，有道理。

1282
01:20:41,090 --> 01:20:43,610
另一个问题是关于安全的，

1283
01:20:43,640 --> 01:20:47,100
这东西安全吗，如果它是，

1284
01:20:48,770 --> 01:20:50,900
我想已经有人已经问过这件事，

1285
01:20:50,900 --> 01:20:55,300
但是网卡读取内存的那部分，

1286
01:20:55,420 --> 01:20:56,830
这看起来有点吓人，所以。

1287
01:20:56,950 --> 01:20:58,810
是的，真的很吓人，

1288
01:20:59,410 --> 01:21:03,250
所以，有一系列的交互，

1289
01:21:03,250 --> 01:21:05,530
当设置 RDMA 时，

1290
01:21:05,680 --> 01:21:07,570
在操作系统和应用程序之间，

1291
01:21:09,780 --> 01:21:14,130
所以，操作系统不允许网卡写入任何任意位置，

1292
01:21:14,130 --> 01:21:16,410
会告诉它，这里的地址，

1293
01:21:16,410 --> 01:21:19,830
这是你可以写入的虚拟内存地址。

1294
01:21:21,230 --> 01:21:24,140
好的，所以你可以让它[]。

1295
01:21:24,790 --> 01:21:25,090
好的。

1296
01:21:25,090 --> 01:21:25,510
没错。

1297
01:21:26,150 --> 01:21:29,210
关于性能的问题，

1298
01:21:29,930 --> 01:21:33,320
所以读取是很快的，

1299
01:21:33,320 --> 01:21:35,780
因为单边的 RDMA ，

1300
01:21:36,560 --> 01:21:38,720
但如果你有大量的写入，

1301
01:21:38,720 --> 01:21:40,580
比如大量的数据和争执。

1302
01:21:40,700 --> 01:21:41,900
是的。

1303
01:21:41,900 --> 01:21:43,370
所以这种情况，还是。

1304
01:21:43,430 --> 01:21:45,860
不，如果有争执会发生什么，

1305
01:21:45,980 --> 01:21:48,200
我们在这个案例中看到了，

1306
01:21:49,590 --> 01:21:53,790
如果我们有很多争执，

1307
01:21:53,790 --> 01:21:55,440
其中一个事务将中止，

1308
01:21:57,310 --> 01:21:59,650
所以这是对事务有好处的，

1309
01:21:59,650 --> 01:22:03,850
不[]或不写入相同记录或相同对象。

1310
01:22:05,200 --> 01:22:06,580
甚至是读取，是吗？

1311
01:22:07,510 --> 01:22:08,380
是的，即使是读取，

1312
01:22:08,380 --> 01:22:10,030
因为版本号可能会改变。

1313
01:22:13,200 --> 01:22:16,440
那么，我想主要的用例是什么？

1314
01:22:17,030 --> 01:22:20,690
有很多研究独立于这个论文，

1315
01:22:20,690 --> 01:22:23,030
关于悲观与乐观并发控制，

1316
01:22:23,640 --> 01:22:26,910
从这两个基准中，

1317
01:22:26,910 --> 01:22:29,850
他们在论文中使用的，比如 TPC-C 和 TATP ，

1318
01:22:30,000 --> 01:22:33,030
没有太多的冲突，

1319
01:22:35,670 --> 01:22:38,700
所以可能是由不同的用户或不同的客户端提交的，

1320
01:22:38,700 --> 01:22:40,320
它们接触的是不同的[表]。

1321
01:22:45,650 --> 01:22:47,180
我有一个问题，

1322
01:22:47,210 --> 01:22:54,550
如果有多个客户端在同一对象上执行事务，

1323
01:22:55,170 --> 01:23:00,240
它们想要执行写入 RDMA ，写入到日志，

1324
01:23:02,960 --> 01:23:05,480
有没有可能会发生冲突，

1325
01:23:05,480 --> 01:23:08,630
比如其中一个会重写另一个日志，或者。

1326
01:23:08,630 --> 01:23:11,180
不，不，每对都有一把锁，

1327
01:23:11,860 --> 01:23:13,600
每对都有一把锁，好的。

1328
01:23:13,630 --> 01:23:15,670
所以，这正是原因所在。

1329
01:23:17,040 --> 01:23:21,600
然后，但是在事务中，比如时间，

1330
01:23:21,630 --> 01:23:25,710
它是否提供可串行化，

1331
01:23:26,070 --> 01:23:28,740
时间基于什么？

1332
01:23:29,260 --> 01:23:30,190
基于版本号。

1333
01:23:31,940 --> 01:23:34,280
这里没有 TrueTime 或类似的东西，

1334
01:23:34,740 --> 01:23:37,710
这些逻辑编号，就像实验 3 中一样，

1335
01:23:37,710 --> 01:23:39,840
你有逻辑编号，

1336
01:23:40,670 --> 01:23:42,710
用于实现键值存储，

1337
01:23:43,460 --> 01:23:45,470
这些编号起到了同样的作用。

1338
01:23:53,940 --> 01:23:58,500
如果两个事务得到了相同的编号，

1339
01:23:58,500 --> 01:24:02,520
那么只有先到达提交点的那个才会。

1340
01:24:02,940 --> 01:24:03,780
好的。

1341
01:24:04,640 --> 01:24:05,900
是的，就是这个案例，

1342
01:24:06,770 --> 01:24:08,570
一个中止，另一个成功。

1343
01:24:11,880 --> 01:24:12,810
好的。

1344
01:24:13,470 --> 01:24:17,460
如果在每一对之间建立了消息队列，

1345
01:24:17,730 --> 01:24:19,350
那你怎么知道，

1346
01:24:19,800 --> 01:24:24,030
你将拥有多个消息队列，给 primary ，

1347
01:24:24,030 --> 01:24:25,830
你怎么知道读取这些东西的顺序，

1348
01:24:25,830 --> 01:24:28,170
而且不会乱读它们的顺序。

1349
01:24:28,650 --> 01:24:35,370
你以相同的顺序读取同一来源的所有消息，

1350
01:24:35,370 --> 01:24:37,500
因为它们都会在一个队列里，

1351
01:24:37,810 --> 01:24:39,520
所以一个来源写入一个队列，

1352
01:24:40,240 --> 01:24:46,450
多台机器同时写入不同的队列，

1353
01:24:46,690 --> 01:24:48,760
你不知道顺序是什么，

1354
01:24:49,770 --> 01:24:52,830
所以，它不能影响协议的正确性。

1355
01:24:54,270 --> 01:24:58,860
我明白了，所以我们不依赖于传入并发消息的顺序。

1356
01:24:58,890 --> 01:25:00,900
没错，你是按一定的顺序轮询的，

1357
01:25:00,900 --> 01:25:02,730
然后你按一定的顺序轮询队列，

1358
01:25:02,730 --> 01:25:05,190
这就是要处理的方式。

1359
01:25:06,950 --> 01:25:07,490
明白了，

1360
01:25:07,550 --> 01:25:10,130
还有一个更具体的问题，

1361
01:25:10,400 --> 01:25:15,380
论文中的一部分提供了无锁读取，

1362
01:25:15,380 --> 01:25:16,730
也就是我们刚才谈到的，

1363
01:25:17,090 --> 01:25:21,680
但它也表示，它还提供了本地线索，

1364
01:25:21,830 --> 01:25:27,290
使程序员能够将同一组机器上的相关对象相互关联。

1365
01:25:27,320 --> 01:25:27,860
是的。

1366
01:25:28,040 --> 01:25:29,510
我不理解那个，

1367
01:25:29,820 --> 01:25:32,070
句子的后半部分。

1368
01:25:32,550 --> 01:25:35,790
好的，我得查一下细节是什么，

1369
01:25:35,790 --> 01:25:37,380
但我想你指的是，

1370
01:25:37,380 --> 01:25:41,160
如果你的对象在各种不同的区域，

1371
01:25:41,160 --> 01:25:42,870
比如，让我们看看这张图片，

1372
01:25:43,230 --> 01:25:47,070
然后你必须和很多不同的 primary 进行交互，

1373
01:25:47,070 --> 01:25:49,680
如果对象 1 在这个 primary ，

1374
01:25:49,710 --> 01:25:51,330
对象 2 在这个 primary ，

1375
01:25:51,630 --> 01:25:53,550
如果你接触到很多，

1376
01:25:53,550 --> 01:25:56,400
如果你总是接触一个集群的对象，

1377
01:25:56,490 --> 01:25:59,310
这是好的，如果所有对象集群都在同一个 primary 上，

1378
01:25:59,910 --> 01:26:02,310
所以你只需联系一个 primary ，而不是多个。

1379
01:26:05,520 --> 01:26:06,720
我明白了，谢谢。

1380
01:26:13,170 --> 01:26:14,400
还有什么问题吗？

1381
01:26:18,180 --> 01:26:23,940
所以 FaRM 不是很适合长的事务，

1382
01:26:23,970 --> 01:26:26,220
因为大多数。

1383
01:26:27,240 --> 01:26:30,150
是的，你担心长的事务会导致冲突。

1384
01:26:32,290 --> 01:26:36,910
我的意思是，我猜只读交易，

1385
01:26:36,910 --> 01:26:39,430
因为我们为它们做了优化。

1386
01:26:39,490 --> 01:26:41,410
是的，当然，

1387
01:26:41,410 --> 01:26:43,420
很多事务人们都在研究，

1388
01:26:43,420 --> 01:26:45,760
你在 Spanner 论文上也看到了，

1389
01:26:46,250 --> 01:26:49,700
其中很大一部分事务是只读事务，

1390
01:26:53,710 --> 01:26:55,300
但这显然是工作量所致。

1391
01:27:01,300 --> 01:27:05,240
我想回到我之前的问题，

1392
01:27:05,240 --> 01:27:11,540
我想我意识到，我误解了严格串行化的基础，

1393
01:27:12,950 --> 01:27:15,740
是不是，严格，

1394
01:27:15,740 --> 01:27:17,750
好的，这是一个情况，

1395
01:27:18,350 --> 01:27:21,650
假设有一个事务先开始，

1396
01:27:21,650 --> 01:27:26,060
它写入分片 1 ， 分片 2 以及读取分片 3 ，

1397
01:27:27,700 --> 01:27:29,890
所以像第一次那样开始。

1398
01:27:30,010 --> 01:27:32,290
写入对象。

1399
01:27:33,100 --> 01:27:34,300
写入 0 。

1400
01:27:34,480 --> 01:27:38,470
写入 x0 ，写入 y0 。

1401
01:27:38,560 --> 01:27:39,850
然后读取 z 。

1402
01:27:40,150 --> 01:27:42,400
好的，读取 z0 。

1403
01:27:43,180 --> 01:27:49,660
然后，假设有第二个事务在事务 1 开始后开始。

1404
01:27:49,990 --> 01:27:50,980
比如在这里？

1405
01:27:51,520 --> 01:27:54,540
是的，它写入 z 。

1406
01:27:55,670 --> 01:27:57,890
所以在写入 z 之前，

1407
01:27:57,890 --> 01:27:59,360
必须读取 z 。

1408
01:27:59,690 --> 01:28:00,710
是的。

1409
01:28:00,740 --> 01:28:03,860
所以读取 z ，它读取的版本号是什么？

1410
01:28:07,260 --> 01:28:10,410
一样的。

1411
01:28:10,650 --> 01:28:13,440
然后尝试写入 z ，

1412
01:28:16,500 --> 01:28:19,980
然后加入 T2 在 T1 提交之前提交。

1413
01:28:23,860 --> 01:28:25,870
好的，所以这个提交。

1414
01:28:26,600 --> 01:28:28,940
然后 T1 在 T2 提交之后提交。

1415
01:28:28,940 --> 01:28:30,650
我们试着提交，

1416
01:28:30,830 --> 01:28:35,630
现在，我们将持有锁，为了验证，等等，

1417
01:28:36,750 --> 01:28:40,440
所以什么会发生，

1418
01:28:40,440 --> 01:28:42,360
我要给你举这个例子，

1419
01:28:42,420 --> 01:28:44,550
这是我在下一节课上讲的一个例子，

1420
01:28:44,550 --> 01:28:48,750
但是发生的是， z 会获得，

1421
01:28:48,810 --> 01:28:49,950
z 会获得 1 ，

1422
01:28:50,970 --> 01:28:54,030
在这一点上， z 是版本 1 ，

1423
01:28:54,630 --> 01:28:56,730
所以，验证阶段将在提交之后运行，

1424
01:28:56,730 --> 01:28:57,540
这就是你说的。

1425
01:28:57,990 --> 01:28:58,410
是的。

1426
01:28:58,740 --> 01:29:00,510
所以这里是对 z 的验证，

1427
01:29:01,220 --> 01:29:03,320
它有 0 ，

1428
01:29:03,500 --> 01:29:06,650
现在是 1 ，事务将被中止。

1429
01:29:07,130 --> 01:29:09,110
好的，这就是我想知道的，

1430
01:29:09,110 --> 01:29:13,010
因为在验证阶段过去之后，

1431
01:29:13,160 --> 01:29:14,600
有一段时间，

1432
01:29:16,190 --> 01:29:18,740
在验证阶段过去之后，

1433
01:29:18,740 --> 01:29:20,420
经过一段时间，它提交，

1434
01:29:20,600 --> 01:29:24,140
如果验证发生在 T2 提交之前，

1435
01:29:24,140 --> 01:29:26,450
所以它仍然是旧的版本号。

1436
01:29:26,950 --> 01:29:28,000
这不可能发生，

1437
01:29:28,000 --> 01:29:30,520
因为在验证之后，

1438
01:29:30,520 --> 01:29:34,990
在提交完成之后，

1439
01:29:35,470 --> 01:29:38,260
提交备份已经记录，

1440
01:29:38,260 --> 01:29:40,870
primary 必须做出改变，

1441
01:29:42,200 --> 01:29:44,240
在应用程序返回之前，

1442
01:29:44,240 --> 01:29:45,590
在应用程序返回之前，

1443
01:29:45,590 --> 01:29:46,580
z 已经更新。

1444
01:29:51,130 --> 01:29:52,750
会不会，我想我要说的是，

1445
01:29:52,750 --> 01:29:58,120
T1 的验证阶段是否有可能发生在，

1446
01:29:58,450 --> 01:30:00,190
或者我想说的是，

1447
01:30:00,190 --> 01:30:03,580
是否可能 T2 的提交发生在，

1448
01:30:03,580 --> 01:30:10,120
发生在 T1 验证之后提交之前？T1之后发生的情况在t1提交之前进行验证。

1449
01:30:13,680 --> 01:30:23,140
显然，这是有风险的，必须排除，

1450
01:30:23,140 --> 01:30:25,480
所以，你是在担心，

1451
01:30:26,340 --> 01:30:27,480
让我来解释这个案例，

1452
01:30:27,480 --> 01:30:28,980
也许我们下周回来，

1453
01:30:28,980 --> 01:30:30,420
我们讨论一下，

1454
01:30:30,450 --> 01:30:32,220
但我觉得你担心的，

1455
01:30:32,460 --> 01:30:33,750
可以回到这张图片，

1456
01:30:34,110 --> 01:30:36,750
这里，我们做了，

1457
01:30:38,530 --> 01:30:42,250
这个提交了，

1458
01:30:42,520 --> 01:30:44,260
所以你是在做提交阶段，

1459
01:30:44,260 --> 01:30:50,310
这是 T1 ，应该是 T2 ，

1460
01:30:51,290 --> 01:30:55,610
所以 T2 在这里，

1461
01:30:56,060 --> 01:31:02,090
然后 T1 在一切发生之前进来，

1462
01:31:02,120 --> 01:31:03,500
在 T2 完成之前。

1463
01:31:04,480 --> 01:31:05,080
是的。

1464
01:31:05,810 --> 01:31:08,480
所以， T1 也从这里进来，

1465
01:31:09,110 --> 01:31:09,980
所以也许，

1466
01:31:09,980 --> 01:31:11,000
好的，让我重写一遍，

1467
01:31:11,000 --> 01:31:11,750
我会回复你。

1468
01:31:11,750 --> 01:31:13,190
好的。

1469
01:31:13,670 --> 01:31:15,350
这正是我想要谈的。

1470
01:31:15,650 --> 01:31:16,850
好的，谢谢。

1471
01:31:18,140 --> 01:31:19,010
所以想确认一下，

1472
01:31:19,010 --> 01:31:23,300
你问的是 T2 在 T1 的第二阶段和第三阶段之间？

1473
01:31:23,300 --> 01:31:24,650
是的。

1474
01:31:26,880 --> 01:31:27,870
但在这种情况下，

1475
01:31:27,870 --> 01:31:33,030
我们可以串行化，让 T2 在 T1 之前。

1476
01:31:33,300 --> 01:31:33,690
是的。

1477
01:31:35,550 --> 01:31:38,880
所以，让我们在周四回到这个话题上，

1478
01:31:39,330 --> 01:31:42,600
我有一个例子可以说明这一点。

1479
01:31:46,330 --> 01:31:52,540
抱歉，在验证阶段，你只读取版本号？

1480
01:31:53,480 --> 01:31:53,750
是的。

1481
01:31:53,750 --> 01:31:54,140
好的。

1482
01:31:58,180 --> 01:32:01,900
可串行化使我们能够对事务重新排序。

1483
01:32:01,930 --> 01:32:03,910
是的，但严格的可串行化不会，

1484
01:32:04,060 --> 01:32:07,480
严格串行化要求，

1485
01:32:07,480 --> 01:32:10,180
如果事务在某个提交之后开始，

1486
01:32:10,330 --> 01:32:12,550
事务也要在那个事务之后提交。

1487
01:32:14,200 --> 01:32:14,560
是的。

1488
01:32:14,560 --> 01:32:16,420
这是协议保证的，

1489
01:32:16,420 --> 01:32:18,600
因为版本号。

1490
01:32:19,830 --> 01:32:20,790
知道了，谢谢。

1491
01:32:21,980 --> 01:32:24,110
但严格的可串行化不是，

1492
01:32:24,650 --> 01:32:26,360
如果我得到 T2 结束，

1493
01:32:27,000 --> 01:32:31,830
它不是 T1 在 T2 结束之后结束，

1494
01:32:32,400 --> 01:32:34,590
T1 必须已经开始，

1495
01:32:34,620 --> 01:32:36,510
或许我需要考虑一下这个问题，

1496
01:32:36,510 --> 01:32:38,790
但我觉得这把我弄糊涂了，

1497
01:32:38,790 --> 01:32:42,600
这里也有一个关于事务开始的规则。

1498
01:32:42,600 --> 01:32:45,870
是的，好的，在真实生活中会发生什么，

1499
01:32:45,870 --> 01:32:48,180
准确地从某个特定的时间点开始，

1500
01:32:48,180 --> 01:32:53,940
如果 T2 在 T1 提交后开始。

1501
01:32:56,250 --> 01:32:56,610
是的。

1502
01:32:56,700 --> 01:32:58,830
所以，肯定是这样的，

1503
01:32:58,830 --> 01:33:02,520
T2 观察到 T1 的改变，

1504
01:33:02,550 --> 01:33:03,870
这就是严格可串行化。

1505
01:33:04,700 --> 01:33:05,240
是的。

1506
01:33:05,790 --> 01:33:09,930
但如果 T2 发生的[]，会怎么样？

1507
01:33:10,170 --> 01:33:12,570
那么并发事务，任何一个结果都是好的。

1508
01:33:12,870 --> 01:33:13,380
好的。

1509
01:33:13,590 --> 01:33:17,730
这回答了你的问题吗？

1510
01:33:17,730 --> 01:33:19,200
是的，我想这就是我困惑的，所以。

1511
01:33:19,410 --> 01:33:24,450
确切地说，当 T2 在 T1 提交之前开始时，

1512
01:33:24,570 --> 01:33:26,160
它被认为是并发事务，

1513
01:33:27,200 --> 01:33:30,380
所以 T1 或 T2 可以观察到彼此，

1514
01:33:30,380 --> 01:33:32,780
可以排序在前或在后，没有关系。

1515
01:33:32,990 --> 01:33:34,250
好的，好的。

1516
01:33:34,810 --> 01:33:35,830
好的，谢谢。

1517
01:33:35,830 --> 01:33:37,930
我认为这也是你的例子的答案。

1518
01:33:38,170 --> 01:33:40,240
是的，好的，谢谢。

1519
01:33:40,270 --> 01:33:42,520
好的，我们已经得到了结果。

1520
01:33:44,230 --> 01:33:50,650
你是说，如果 T2 开始于 T1 开始和提交之间。

1521
01:33:50,680 --> 01:33:53,560
是的，可以在前面或后面，没有关系。

1522
01:33:56,010 --> 01:33:58,170
我能问个后勤问题吗，

1523
01:33:58,230 --> 01:34:04,350
我记得在 6.S081 ，你也贴了这些幻灯片。

1524
01:34:05,160 --> 01:34:08,250
是的，我没有在这里做，

1525
01:34:08,700 --> 01:34:10,800
你想它在网站上吗？

1526
01:34:11,290 --> 01:34:12,520
我想幻灯片是有用的，

1527
01:34:12,520 --> 01:34:15,790
如果你只需要看幻灯片，

1528
01:34:15,790 --> 01:34:17,950
你需要滚动浏览视频。

1529
01:34:18,040 --> 01:34:22,420
好的，你是第一个问的，为什么我没有这么做，

1530
01:34:23,080 --> 01:34:25,570
是的，我很乐意这么做，

1531
01:34:25,570 --> 01:34:27,820
我把它们保存下来。

1532
01:34:29,690 --> 01:34:30,680
非常感谢,

1533
01:34:30,710 --> 01:34:33,140
谢谢你的有趣的课程。

1534
01:34:33,700 --> 01:34:34,300
不用谢。

