1
00:00:06,030 --> 00:00:07,350
Okay, good afternoon,

2
00:00:08,470 --> 00:00:11,080
sound check sound checking,

3
00:00:12,790 --> 00:00:13,690
people can hear me?

4
00:00:16,760 --> 00:00:18,170
Yeah.

5
00:00:18,230 --> 00:00:18,920
Thank you,

6
00:00:19,460 --> 00:00:23,240
okay, good, so good afternoon, good evening, good morning, good night, wherever you are,

7
00:00:23,570 --> 00:00:25,970
I'm going to talk today more about raft

8
00:00:27,110 --> 00:00:30,560
and we want to cover following different topics,

9
00:00:30,860 --> 00:00:34,100
which are going to be relevant to labs.

10
00:00:34,790 --> 00:00:38,180
So, first of all, I want to talk a little bit more about log divergence,

11
00:00:39,120 --> 00:00:42,300
we sort of had a cliffhanger at the end of last lecture,

12
00:00:42,330 --> 00:00:44,160
where we got in a discussion that figure six,

13
00:00:44,160 --> 00:00:46,080
I want to resume that discussion.

14
00:00:46,710 --> 00:00:50,250
I want to talk about log catch up and what happens,

15
00:00:50,280 --> 00:00:54,350
if how do followers catch up,

16
00:00:54,980 --> 00:01:00,170
then a little bit of a persistence like what state must be,

17
00:01:01,240 --> 00:01:03,700
what's raft state must be persistent in storage

18
00:01:03,700 --> 00:01:07,720
which is really relevant for 2c and 2d,

19
00:01:07,720 --> 00:01:11,800
and also talk about [] out to snapshots.

20
00:01:13,580 --> 00:01:16,860
Yeah, if there's any questions, please feel free to ask

21
00:01:17,940 --> 00:01:19,770
and then finally I want to talk about linearizability

22
00:01:19,770 --> 00:01:24,870
and correct criterion that comes up quite often in the paper

23
00:01:24,870 --> 00:01:26,700
used also in a bunch of places,

24
00:01:27,300 --> 00:01:31,650
and this will allow us to talk a little bit again about how does this server use raft.

25
00:01:32,490 --> 00:01:35,910
So, those are the topics we plan to talk about,

26
00:01:36,000 --> 00:01:38,970
you have any questions right now, please feel free to ask,

27
00:01:39,520 --> 00:01:41,770
and of course always jump in at any point.

28
00:01:47,470 --> 00:01:51,010
Okay, so, so we saw it last week,

29
00:01:51,010 --> 00:01:52,330
we started talking about raft,

30
00:01:52,330 --> 00:01:59,080
you know we saw that the leader has served this job of replicating its log onto the onto followers

31
00:01:59,440 --> 00:02:03,700
and but you know due to crashes in leader election,

32
00:02:03,880 --> 00:02:08,950
the state of the system, you know the logs can actually quite can diverse quite quite a bit,

33
00:02:11,280 --> 00:02:14,130
in figure six is an illustration,

34
00:02:14,760 --> 00:02:18,090
you know why, how, how that could happen,

35
00:02:18,090 --> 00:02:20,370
you know the leaders can go down,

36
00:02:20,370 --> 00:02:21,810
they may append some more entries

37
00:02:21,810 --> 00:02:24,090
and so there's a whole bunch of different scenarios,

38
00:02:24,420 --> 00:02:27,720
yeah that our system can end up in

39
00:02:27,720 --> 00:02:32,160
and so the figure six, six, seven actually shows a bunch of those

40
00:02:32,280 --> 00:02:38,020
and the, and the main reason, for the figure is that,

41
00:02:38,020 --> 00:02:42,010
it actually sharpens up the leader election rule,

42
00:02:49,940 --> 00:02:51,710
so once the leader goes down

43
00:02:51,710 --> 00:02:54,110
and we need to elect a new leader,

44
00:02:54,110 --> 00:02:57,530
there's actually some restrictions that must be applied

45
00:02:57,770 --> 00:03:03,380
to actually make sure that we can get converged on the right log in the end.

46
00:03:04,040 --> 00:03:05,030
And so, first of all,

47
00:03:05,060 --> 00:03:09,280
one part of that is that any leader need to achieve a majority,

48
00:03:10,620 --> 00:03:12,390
and this is a part of the idea

49
00:03:12,390 --> 00:03:17,280
to actually avoid just brain split syndrome or split brain syndrome,

50
00:03:17,310 --> 00:03:19,230
sort of we can actually make sure that

51
00:03:19,230 --> 00:03:22,140
you know in any two subsequent elections,

52
00:03:22,380 --> 00:03:24,090
there's going to be at least one node,

53
00:03:24,150 --> 00:03:28,350
that participated in both majorities,

54
00:03:28,350 --> 00:03:31,680
because you can only do two majority must overlap

55
00:03:31,710 --> 00:03:37,680
and that node must actually have you know operations from a recent, from the recent term.

56
00:03:38,520 --> 00:03:39,570
The majority is important,

57
00:03:39,630 --> 00:03:42,210
but turns out it's actually a little bit more shuttle,

58
00:03:42,600 --> 00:03:47,400
you might think that like the longest log that should be sufficient,

59
00:03:47,400 --> 00:03:50,040
because the longest log has most information,

60
00:03:50,040 --> 00:03:52,320
so we're just picked out as the next leader

61
00:03:52,320 --> 00:03:53,640
and then we're in good shape

62
00:03:53,880 --> 00:03:55,950
and that turns out to be not the case.

63
00:03:56,300 --> 00:04:02,420
And and so, and leader rules a little bit more subtle,

64
00:04:02,420 --> 00:04:11,250
you know actually majority plus at least as of date, at-least but up to date.

65
00:04:15,430 --> 00:04:22,420
So, so to you know the leader election is running a follower,

66
00:04:22,420 --> 00:04:25,630
so the candidate is starting to run leader election approaches,

67
00:04:25,630 --> 00:04:26,830
bunch of followers

68
00:04:27,190 --> 00:04:32,110
and the followers response with a positive vote,

69
00:04:32,110 --> 00:04:36,700
if the candidate actually is at least up to date as they are.

70
00:04:37,480 --> 00:04:38,860
And what that means is that,

71
00:04:38,950 --> 00:04:43,900
the last log entry must actually have the same term

72
00:04:44,110 --> 00:04:47,920
or in if they actually have the same term,

73
00:04:47,950 --> 00:04:50,590
the longest one sort of wins.

74
00:04:51,680 --> 00:04:58,070
And so, so that the leader the election rule you know we look at this problem last week

75
00:04:58,100 --> 00:04:59,420
as part of the homework

76
00:04:59,420 --> 00:05:06,080
and what happens if you know this note you know what's worse about the leader actually is dead,

77
00:05:06,080 --> 00:05:06,890
it's gone,

78
00:05:07,070 --> 00:05:08,810
you know and who could become leaders,

79
00:05:09,590 --> 00:05:11,570
and you know quickly discovered that,

80
00:05:11,600 --> 00:05:14,720
you know there there's a bunch of them that cannot become leader,

81
00:05:14,720 --> 00:05:18,890
but then there's potentially a number of scenarios in which some can become leaders.

82
00:05:19,430 --> 00:05:23,150
And so, in particular, you know we identify that a can become leader,

83
00:05:23,420 --> 00:05:26,840
c can become leader, and d can became leader.

84
00:05:28,700 --> 00:05:34,280
And so then, and so there's probably the most important part of this whole discussion, right,

85
00:05:34,280 --> 00:05:35,510
who can become leader.

86
00:05:35,540 --> 00:05:37,010
[] there's question.

87
00:05:37,310 --> 00:05:39,680
There, let me hold on.

88
00:05:43,110 --> 00:05:43,620
Okay.

89
00:05:44,160 --> 00:05:46,320
So who becomes that's the most important part,

90
00:05:46,320 --> 00:05:48,030
so there's a bunch of different scenarios,

91
00:05:48,030 --> 00:05:49,740
in which a can become a leader,

92
00:05:49,770 --> 00:05:51,600
there's a scenario where c become a leader,

93
00:05:51,600 --> 00:05:53,430
in the scenario where d become a leader.

94
00:05:54,580 --> 00:05:56,170
Then the discussion focus a little bit,

95
00:05:56,170 --> 00:05:59,410
like well at least there's one particular scenario,

96
00:05:59,410 --> 00:06:00,880
in which one of these becomes leader,

97
00:06:00,940 --> 00:06:03,940
others multiple scenarios in which take over the leader,

98
00:06:03,940 --> 00:06:07,090
particularly focus this discussion focused on a,

99
00:06:09,060 --> 00:06:11,880
because like one way that a can become a leader

100
00:06:11,880 --> 00:06:21,900
is when c and d are down, right,

101
00:06:21,900 --> 00:06:23,790
because c and d are down,

102
00:06:24,060 --> 00:06:30,930
a will talk to b e and f form a majority with 4,

103
00:06:31,230 --> 00:06:34,350
it has the most up to date log,

104
00:06:34,410 --> 00:06:37,860
you notice that you know even though f is a longer log,

105
00:06:38,190 --> 00:06:40,890
that actually is not the most up to date one,

106
00:06:41,100 --> 00:06:44,040
so a actual succeed in becoming the leader,

107
00:06:44,590 --> 00:06:46,090
and then things proceed from there.

108
00:06:47,170 --> 00:06:49,450
But there was an interesting question that came up is

109
00:06:49,450 --> 00:06:52,960
are other scenarios in which a can become a leader in particular,

110
00:06:52,990 --> 00:06:56,440
or is there scenario where even if c and d are up,

111
00:06:59,270 --> 00:07:01,430
or reachable or participate,

112
00:07:01,520 --> 00:07:03,710
is it possibility a becomes a leader,

113
00:07:05,140 --> 00:07:07,300
so we see c and d up

114
00:07:07,300 --> 00:07:10,690
and so the question is does c and d always vote for a,

115
00:07:10,690 --> 00:07:11,920
if a is the candidate.

116
00:07:12,810 --> 00:07:16,350
And it turns out is actually slightly complicated,

117
00:07:16,350 --> 00:07:18,090
it is not completely straightforward,

118
00:07:18,510 --> 00:07:20,670
so if a starts this election,

119
00:07:20,700 --> 00:07:23,910
presumably it will start the election in term 7.

120
00:07:27,310 --> 00:07:31,840
And so if context c and d you know c will be perfectly fine with that,

121
00:07:31,840 --> 00:07:36,700
because the a is at least up to date,

122
00:07:40,250 --> 00:07:43,820
and so we'll be able to achieve a majority,

123
00:07:43,820 --> 00:07:46,430
but you know it is possible correct d,

124
00:07:46,670 --> 00:07:52,820
there's one additional rule that if d actually has,

125
00:07:52,820 --> 00:07:58,250
if follower follower has a higher term as c in higher term,

126
00:07:58,280 --> 00:08:00,020
its current term is higher,

127
00:08:00,440 --> 00:08:04,850
then the or the candidate then actually it can stop the election,

128
00:08:04,850 --> 00:08:10,430
because it will respond saying like hey my term is higher than your higher my term,

129
00:08:10,490 --> 00:08:12,350
my current term is higher than your term

130
00:08:12,470 --> 00:08:14,180
and so therefore you have to become a follower,

131
00:08:14,210 --> 00:08:18,260
so a will then be changed back from candidate to follower.

132
00:08:18,760 --> 00:08:19,990
And this can happen correctly,

133
00:08:19,990 --> 00:08:24,280
in case of d, this d might actually have seen term a

134
00:08:24,310 --> 00:08:26,050
and we can't really tell from this picture,

135
00:08:26,050 --> 00:08:27,640
what actually the outcome is going to be,

136
00:08:27,850 --> 00:08:29,440
let's assume that example,

137
00:08:29,650 --> 00:08:38,530
you know the it has run once and has increases term to 8,

138
00:08:38,620 --> 00:08:40,690
it didn't become succeeded leader

139
00:08:40,750 --> 00:08:42,190
and then its current term will 8

140
00:08:42,190 --> 00:08:46,490
and so it will vote when a ask to for its vote,

141
00:08:46,640 --> 00:08:47,780
you know d will say no,

142
00:08:47,780 --> 00:08:48,830
I won't vote for you,

143
00:08:49,010 --> 00:08:51,140
and furthermore by current term is a,

144
00:08:51,260 --> 00:08:52,730
so a will see that message,

145
00:08:52,730 --> 00:08:54,290
it's higher than a 7

146
00:08:54,440 --> 00:08:57,200
and so a will actually step down

147
00:08:57,200 --> 00:08:58,280
and become just a follower

148
00:08:58,370 --> 00:08:59,420
and then at some point later,

149
00:08:59,420 --> 00:09:03,380
presumably you know d will run its election timer will go off

150
00:09:03,380 --> 00:09:04,460
and actually it will run.

151
00:09:05,740 --> 00:09:09,610
And so the short story of this you know morale is gonna,

152
00:09:09,610 --> 00:09:10,930
really this picture is that,

153
00:09:11,230 --> 00:09:12,640
it's absolutely possible,

154
00:09:12,640 --> 00:09:15,790
that a c and d can become leader in different types of scenarios,

155
00:09:16,060 --> 00:09:19,240
and that's probably the main thing to get out of this.

156
00:09:19,660 --> 00:09:20,950
Professor.

157
00:09:21,100 --> 00:09:22,210
Yeah.

158
00:09:22,570 --> 00:09:25,270
So, I I just want to ask,

159
00:09:25,270 --> 00:09:27,970
because I think I I'm not sure if I understood correctly,

160
00:09:27,970 --> 00:09:31,480
but then you said a might be elected in terms 7,

161
00:09:31,900 --> 00:09:36,460
it is not true that it cannot for any reason be elected in terms 7,

162
00:09:37,580 --> 00:09:40,820
even if d was down, right,

163
00:09:40,820 --> 00:09:48,310
because people like like d, like already got a majority, right, in 7.

164
00:09:50,260 --> 00:09:56,080
d got a majority in 7, because it actually was able to get something done,

165
00:09:56,080 --> 00:09:57,790
so presumably right, you're right,

166
00:09:57,790 --> 00:10:00,040
you know the good observation,

167
00:10:00,340 --> 00:10:01,690
so it has to be the case that,

168
00:10:01,690 --> 00:10:04,210
there's a number of people that actually already in term 7,

169
00:10:05,800 --> 00:10:07,630
and the picture is incomplete,

170
00:10:07,660 --> 00:10:09,910
we don't really know what the current term is,

171
00:10:09,910 --> 00:10:11,200
that people have seen so far.

172
00:10:11,720 --> 00:10:12,230
Yeah.

173
00:10:12,850 --> 00:10:13,300
Right.

174
00:10:14,340 --> 00:10:23,100
Well, yeah, I mean the only thing is like, I think like a majority of the servers already voted for someone in term 7, so.

175
00:10:23,100 --> 00:10:25,380
Absolutely, a will go to term 8,

176
00:10:25,950 --> 00:10:29,370
and you know we'll run the election for 8,

177
00:10:29,580 --> 00:10:32,760
but you know for the same reason, d might already be in 9, right

178
00:10:32,760 --> 00:10:36,720
and so it all depends on what the current term is,

179
00:10:36,720 --> 00:10:38,580
what these actually these participants are in.

180
00:10:40,910 --> 00:10:44,090
But the main conclusion, correct the main top level conclusion is that,

181
00:10:44,330 --> 00:10:47,870
a can become leader certainly when c and d are offline,

182
00:10:48,420 --> 00:10:51,180
c can become leader and d can become a leader.

183
00:10:54,100 --> 00:10:54,760
Thanks.

184
00:10:57,430 --> 00:11:07,130
Okay, then, let's so so we now know that the raft can sort of ended in states,

185
00:11:07,130 --> 00:11:10,190
where the logs are diverged

186
00:11:10,250 --> 00:11:12,590
and so that needs to be repaired

187
00:11:12,620 --> 00:11:16,130
and it's like one a key component of the raft protocol is

188
00:11:16,130 --> 00:11:19,370
to do the that log catch up as they call it,

189
00:11:20,280 --> 00:11:22,860
so I talked a little bit about that.

190
00:11:30,700 --> 00:11:36,670
And this is basically what you're sort of have to deal with in part b of the lab.

191
00:11:37,560 --> 00:11:42,030
So I may be easier to illustrate with this picture,

192
00:11:43,590 --> 00:11:46,020
so let's, it's going to make it a little bit simple,

193
00:11:46,320 --> 00:11:47,880
let's have 3 servers,

194
00:11:49,790 --> 00:11:56,960
here's S1, it has, you know. term 3 in index 10,

195
00:11:57,170 --> 00:12:04,210
the index 11, has no entries in [] and 11 12 13,

196
00:12:04,210 --> 00:12:13,650
here we have S2, S2 has entries you know 3 3 5,

197
00:12:15,380 --> 00:12:21,560
and so this is index 10 11 12 and 13 13 used to make it complete,

198
00:12:22,280 --> 00:12:26,160
and here is S4, oh sorry S3,

199
00:12:26,980 --> 00:12:34,700
and let's do where in the scenario 3 3 4, and 10 11 12 13.

200
00:12:36,080 --> 00:12:38,750
And I'm not showing like the indexes before 10,

201
00:12:40,190 --> 00:12:41,540
they're not be very relevant.

202
00:12:42,280 --> 00:12:46,120
Yeah, you know use the timeline, these different servers.

203
00:12:46,710 --> 00:12:49,050
And just let's start out assuming that,

204
00:12:49,050 --> 00:12:50,460
the S2 becomes the leader,

205
00:12:51,460 --> 00:12:52,960
because it has the highest,

206
00:12:54,300 --> 00:12:56,250
it is mostly to date,

207
00:12:56,280 --> 00:12:59,220
it has the highest term number in the last log entry,

208
00:12:59,220 --> 00:13:00,210
so it becomes leader.

209
00:13:00,750 --> 00:13:06,540
And now, when you need to understand how about the protocol is to synchronize these particular logs,

210
00:13:06,930 --> 00:13:12,450
in the way you know this almost happens is sort of a side effect of you know either the append entries,

211
00:13:12,480 --> 00:13:15,420
because new log entries are appended or because of heartbeats,

212
00:13:15,420 --> 00:13:19,200
which basically are append entries with zero new entries.

213
00:13:19,600 --> 00:13:21,970
So let's assume that the leader actually sends heartbeat out,

214
00:13:21,970 --> 00:13:23,080
in fact it does it correct,

215
00:13:23,080 --> 00:13:25,420
the election immediately sends out a heartbeat,

216
00:13:25,980 --> 00:13:27,630
and so it will sends out the heartbeat,

217
00:13:28,240 --> 00:13:30,910
and the heartbeat basically has no log entries,

218
00:13:31,630 --> 00:13:35,170
but it also indicates two other pieces of information,

219
00:13:35,260 --> 00:13:36,760
namely the previous term,

220
00:13:37,820 --> 00:13:41,360
so the previous term, which in this case it's going to be 5 right

221
00:13:42,830 --> 00:13:46,700
and the previous index, it's gonna be 12.

222
00:13:47,960 --> 00:13:52,010
So it sends it off to the leader S2 sends to S3

223
00:13:52,010 --> 00:13:53,180
and S3 looks at this

224
00:13:53,540 --> 00:13:56,390
and says well look my previous terms,

225
00:13:56,390 --> 00:14:01,190
actually is not 5, it's actually 4,

226
00:14:01,850 --> 00:14:05,480
and so, it actually sends back a message saying no,

227
00:14:06,990 --> 00:14:09,570
you know I'm I'm alive in principle,

228
00:14:09,570 --> 00:14:12,480
but you know I I know I cannot do your append,

229
00:14:13,280 --> 00:14:14,780
so I'm not up to date.

230
00:14:15,340 --> 00:14:20,440
And now S2 have some information to actually bring it up to date

231
00:14:20,590 --> 00:14:23,050
and the way it works is,

232
00:14:23,050 --> 00:14:25,390
there's sort of two variables that are of importance,

233
00:14:25,450 --> 00:14:32,350
one for every node, S2 for, keeps a variable next index,

234
00:14:36,760 --> 00:14:40,300
and next index when it initialize it, becomes leader,

235
00:14:40,450 --> 00:14:43,580
it is sort of an optimistic variable,

236
00:14:44,030 --> 00:14:47,180
it just assumes that the logs are actually up to date.

237
00:14:47,900 --> 00:14:51,650
And so, when S2 becomes a leader,

238
00:14:51,680 --> 00:14:53,240
it actually just sets it to 13,

239
00:14:53,800 --> 00:14:56,650
you know the same value that actually it has for itself.

240
00:14:57,870 --> 00:14:59,010
That's perfectly fine,

241
00:14:59,310 --> 00:15:00,810
because it's just a guess,

242
00:15:00,840 --> 00:15:03,630
if one actually the where S3 might be

243
00:15:03,630 --> 00:15:04,800
and that we might be behind,

244
00:15:04,800 --> 00:15:07,020
and then you know because there's no message,

245
00:15:07,290 --> 00:15:09,480
the leader actually learns that.

246
00:15:10,130 --> 00:15:12,410
And so, in fact you know when it gets there's no message,

247
00:15:13,740 --> 00:15:16,020
in the unoptimized version,

248
00:15:16,110 --> 00:15:18,510
so I'm going to first talk about the unoptimized version,

249
00:15:22,650 --> 00:15:25,710
the leader just decrements the next index by one

250
00:15:25,830 --> 00:15:28,170
and so it decrements 13 to 12,

251
00:15:29,060 --> 00:15:32,390
and then we got some point will send another append entries,

252
00:15:33,170 --> 00:15:37,160
and this time around you know it will actually say okay we'll make next in this 12,

253
00:15:37,190 --> 00:15:39,590
you know got a send you know log in 3 5,

254
00:15:40,880 --> 00:15:46,080
and you know the previous term, it's gonna be 3,

255
00:15:47,160 --> 00:15:51,780
and the previous index is going to be 11.

256
00:15:53,700 --> 00:15:58,020
And so when S3 actually received this message,

257
00:15:58,020 --> 00:15:59,790
you know check the previous term 3,

258
00:15:59,790 --> 00:16:01,080
the previous index is 11,

259
00:16:01,080 --> 00:16:02,040
that all works out,

260
00:16:02,370 --> 00:16:04,320
it seems that it has append 5

261
00:16:04,350 --> 00:16:08,880
and so it will erase the 4 and stick a 5 in there

262
00:16:09,300 --> 00:16:13,090
and basically respond saying yep, good.

263
00:16:16,300 --> 00:16:23,280
So at this point, the leader knows that actually the log is up to date,

264
00:16:23,280 --> 00:16:25,740
because you've got an okay message back,

265
00:16:27,340 --> 00:16:31,000
then there's the second variable that plays an important role in all this,

266
00:16:31,240 --> 00:16:36,660
which is match index, which raft also maintains for,

267
00:16:36,690 --> 00:16:39,750
leader also maintains for every follower.

268
00:16:40,440 --> 00:16:42,540
So there's an next index you know for S3,

269
00:16:42,540 --> 00:16:43,830
here's next index for S1,

270
00:16:43,830 --> 00:16:45,360
and similar there's a match index,

271
00:16:45,360 --> 00:16:47,460
you know for S1 S2 S3 too.

272
00:16:48,560 --> 00:16:53,540
And this one is sort of, if you think about this as pessimistic or lower bound,

273
00:16:55,140 --> 00:16:58,470
so when the leader actually you know becomes leader,

274
00:16:58,500 --> 00:17:00,360
it actually sets the value just 0,

275
00:17:01,850 --> 00:17:09,200
and to indicate that basically as far as knows S3 doesn't really have any log entries at all,

276
00:17:09,840 --> 00:17:15,270
and so it hasn't delivered any log entries to the application,

277
00:17:15,570 --> 00:17:20,220
and so for S2 also has to be very careful about what actually it can be delivered to the application,

278
00:17:20,340 --> 00:17:22,290
there goes if he needs to know,

279
00:17:22,290 --> 00:17:27,690
that at least a majority of the followers actually has a copy of a particular log entry, before it can deliver.

280
00:17:29,460 --> 00:17:33,060
So just start to be pessimistic,

281
00:17:33,360 --> 00:17:42,180
but then once it learns you know that for example once it learns actually got the follower is okay

282
00:17:42,180 --> 00:17:44,370
and we've gotten okay the append message,

283
00:17:44,400 --> 00:17:47,130
it can actually update you know the pessimistic,

284
00:17:47,130 --> 00:17:52,350
lower bound or the match index from 0 to actually 13,

285
00:17:52,650 --> 00:17:59,890
because it has learned that the follower is actually up to date till 13,

286
00:17:59,890 --> 00:18:02,860
and that's the next index that expect is you know 13.

287
00:18:03,770 --> 00:18:05,210
And at this point in time,

288
00:18:05,210 --> 00:18:07,340
basically it has learned from two different,

289
00:18:07,760 --> 00:18:13,880
knows that, that particular log entry 5 is actually now replicated at least in two nodes.

290
00:18:16,780 --> 00:18:18,520
And so you might think well good,

291
00:18:18,550 --> 00:18:20,380
it has been replicated in two nodes,

292
00:18:20,530 --> 00:18:22,240
we can deliver to the application,

293
00:18:22,240 --> 00:18:24,010
because the majority clearly has it,

294
00:18:24,370 --> 00:18:26,500
and we're in good shape.

295
00:18:27,410 --> 00:18:31,100
And unfortunately, that actually turned out not to be the case,

296
00:18:31,160 --> 00:18:33,560
it's close to true, but not completely true,

297
00:18:34,280 --> 00:18:37,730
and this actually has to do with figure 8,

298
00:18:38,210 --> 00:18:39,830
so I want to talk a little bit about figure 8

299
00:18:39,830 --> 00:18:43,070
and the real reason what's going on here to make this slightly complicated

300
00:18:43,070 --> 00:18:45,200
and you also should think a little bit fishy.

301
00:18:45,670 --> 00:18:52,900
So this leader S2 just erased the value out of the log of S3

302
00:18:52,900 --> 00:18:54,640
and you know somebody put that in,

303
00:18:55,200 --> 00:18:57,510
and you know raising it,

304
00:18:57,510 --> 00:19:00,720
you know, yeah it seems a little bit you know dangerous

305
00:19:00,720 --> 00:19:06,240
and as in and so it turns out there is a corner case,

306
00:19:06,240 --> 00:19:09,600
where you have to be a bit careful,

307
00:19:09,600 --> 00:19:13,590
by when you deliver when you declare a message actually committed.

308
00:19:14,740 --> 00:19:21,130
And it turns out that basically, yeah, if figure 8 illustrates that.

309
00:19:22,210 --> 00:19:27,420
So let me talk a little bit about this erasing log entries.

310
00:19:31,430 --> 00:19:37,550
And we will see is that the rule for actually when the message can be delivered to the application is

311
00:19:37,940 --> 00:19:44,060
is slightly more subtle than just counting the replicates.

312
00:19:47,100 --> 00:19:49,770
Let's see actually gets figure 8 load it in.

313
00:19:50,800 --> 00:19:55,660
Okay so here's figure 8 and so as usual structure.

314
00:19:58,810 --> 00:20:04,450
Okay, let me get back to the question in the in the chat in a second,

315
00:20:04,960 --> 00:20:07,360
so here's figure 8

316
00:20:07,360 --> 00:20:10,510
and so let's walk through what the scenario here is,

317
00:20:10,510 --> 00:20:16,030
correct in figure a you know what log entry one has been committed by everybody,

318
00:20:16,360 --> 00:20:24,730
you know the S1 or S2 became leader in entry in term 2,

319
00:20:25,060 --> 00:20:28,720
they committed or they started appending an entry 2,

320
00:20:29,180 --> 00:20:30,830
hasn't been committed yet,

321
00:20:30,860 --> 00:20:32,900
because it's not a majority for sure,

322
00:20:33,260 --> 00:20:35,000
then indeed what actually happens,

323
00:20:35,000 --> 00:20:38,540
you know S5 wasn't disconnected has word of this term 2,

324
00:20:38,900 --> 00:20:40,880
became a leader in term 3,

325
00:20:40,910 --> 00:20:43,910
appended an entry to each log,

326
00:20:44,180 --> 00:20:45,440
that certainly is not committed,

327
00:20:45,440 --> 00:20:46,550
because there's no majority,

328
00:20:46,730 --> 00:20:48,740
then we end up in c,

329
00:20:48,770 --> 00:20:52,810
maybe the S5 actually got disconnected again,

330
00:20:53,020 --> 00:20:56,830
S1 becomes a leader in term 4,

331
00:20:56,980 --> 00:21:01,780
it starts replicating you know entry, this log entry 2 to other nodes.

332
00:21:02,620 --> 00:21:05,500
And, in fact you know deliver it,

333
00:21:05,500 --> 00:21:07,180
you know it gets back,

334
00:21:07,180 --> 00:21:09,070
you know like shown in the previous slide,

335
00:21:09,430 --> 00:21:13,090
in those actually on S2 and those actually use S3.

336
00:21:14,230 --> 00:21:18,940
And it turns out you know that actually you might think,

337
00:21:18,940 --> 00:21:27,730
okay, well you know S1 knows you know that actually 3 3 nodes actually have a copy of this particular entry

338
00:21:27,730 --> 00:21:29,290
and so I might be able to deliver it

339
00:21:29,290 --> 00:21:31,270
and it turns out that's not true,

340
00:21:32,000 --> 00:21:40,300
and there's more subtle reasoning that needs to happen to actually commit

341
00:21:40,300 --> 00:21:42,220
and namely you can only commit.

342
00:21:42,370 --> 00:21:56,310
Oops, sorry, you can commit after the leader has committed,

343
00:22:00,240 --> 00:22:03,820
one entry in its own term.

344
00:22:09,990 --> 00:22:12,330
And if we think about this number 2,

345
00:22:12,570 --> 00:22:15,510
it actually isn't from leaders in term 4

346
00:22:15,750 --> 00:22:24,030
and and so the the the commit rule wouldn't allow actually commit 2 immediately to the servers,

347
00:22:24,240 --> 00:22:28,440
because that actually is one from a previous term and not from the current term

348
00:22:28,560 --> 00:22:33,990
and so for example your code to decide whether actually something can be delivered on the applied channel

349
00:22:33,990 --> 00:22:35,430
needs to take to this account.

350
00:22:35,900 --> 00:22:38,750
And the reason you need take to account is illustrated by d and e,

351
00:22:39,510 --> 00:22:42,420
basically what can happen is that,

352
00:22:42,980 --> 00:22:50,570
you know for S1 actually might might actually end up in a different situation,

353
00:22:50,570 --> 00:22:55,010
where d actually becomes the,

354
00:22:56,440 --> 00:23:06,180
after, d actually becomes the leader, for example S1 example is particularly disconnected,

355
00:23:06,420 --> 00:23:09,300
and it might actually start connecting,

356
00:23:09,300 --> 00:23:10,890
it can form a majority

357
00:23:11,040 --> 00:23:16,800
and actually it starts copying its particular, its entries to actually,

358
00:23:17,350 --> 00:23:20,380
yeah, all right, it erases you know the 2s

359
00:23:20,440 --> 00:23:27,010
and actually copies it's 3 in the entry for each term 3 into whatever used to be 2

360
00:23:27,070 --> 00:23:30,220
and this is erasing that we talked about on the previous slide.

361
00:23:33,660 --> 00:23:38,280
And so we'll see, actually though even though it was on the majority of the nodes, right,

362
00:23:38,280 --> 00:23:40,470
on the majority of nodes, that got erased.

363
00:23:41,370 --> 00:23:45,210
And so the rule and therefore the rules as I stated here,

364
00:23:45,330 --> 00:23:49,920
because now 1s you know this is illustrated by e,

365
00:23:50,160 --> 00:23:55,080
1s actually S3 S1 commits an entry in its own term,

366
00:23:55,830 --> 00:24:00,060
and so it knows that every no there's a majority in its own term,

367
00:24:00,210 --> 00:24:04,170
so at this point, it can actually deliver 4 you know to the application

368
00:24:04,560 --> 00:24:06,030
and as a result of that,

369
00:24:06,090 --> 00:24:11,910
you know any nodes that were committed in previous terms can also be delivered to the application.

370
00:24:13,040 --> 00:24:15,710
So you see here that this erasing of log entries,

371
00:24:15,740 --> 00:24:19,910
that basic commits makes the commit rule quite slightly more complicated.

372
00:24:20,460 --> 00:24:25,770
And that's just the design decisions that the designers of raft made,

373
00:24:25,770 --> 00:24:27,210
you know they could have done it differently,

374
00:24:27,450 --> 00:24:28,770
they could have counted

375
00:24:28,860 --> 00:24:32,100
and made basically 2 survive, if they wanted to,

376
00:24:32,220 --> 00:24:35,130
but they decided to go for this particular approach on the grounds,

377
00:24:35,130 --> 00:24:36,090
that they think it's simpler.

378
00:24:39,600 --> 00:24:43,050
Okay, so this is suddenly that will show up,

379
00:24:43,080 --> 00:24:45,840
you know in a test cases for the labs,

380
00:24:46,080 --> 00:24:49,440
so you have to be a little bit of careful with your commit rule.

381
00:24:51,860 --> 00:24:53,030
And then you implement it correctly.

382
00:24:55,910 --> 00:25:02,600
Okay, so, so far, you know if you go back to this particular picture,

383
00:25:02,600 --> 00:25:11,120
the an optimized version of this protocol is a little bit of bummer, right,

384
00:25:11,120 --> 00:25:13,970
like if you think a little bit about this,

385
00:25:14,000 --> 00:25:18,410
let's look at actually what happens with S1.

386
00:25:19,230 --> 00:25:22,920
So let's see, let me switch things,

387
00:25:22,920 --> 00:25:25,470
let's see S2 tries bring S1 up to date,

388
00:25:25,470 --> 00:25:26,700
will do the same thing,

389
00:25:27,210 --> 00:25:30,300
you know send append entries, you know with nil entries,

390
00:25:30,540 --> 00:25:33,960
past term previous term to be 5,

391
00:25:36,400 --> 00:25:39,610
and previous index 12,

392
00:25:40,160 --> 00:25:42,440
it will say no, right,

393
00:25:43,340 --> 00:25:48,410
actually the index you know previous index is actually a 10 with term 3,

394
00:25:48,410 --> 00:25:55,880
so it will, this guy will decrease its next index go from 13 to 12,

395
00:25:56,730 --> 00:25:58,650
then we'll do the same thing again,

396
00:25:59,130 --> 00:26:04,350
you know sent I guess it's gonna send 5, the log entry 5,

397
00:26:04,350 --> 00:26:06,570
it will set the previous term to be 3,

398
00:26:07,220 --> 00:26:09,890
and index previous index 11,

399
00:26:10,740 --> 00:26:12,120
it's going to get a no back,

400
00:26:13,050 --> 00:26:15,780
you know, then the index goes to from 12 to 11,

401
00:26:16,880 --> 00:26:19,070
and now basically it's going to work

402
00:26:19,100 --> 00:26:22,370
and so we'll see hear that basically for every log entry,

403
00:26:22,400 --> 00:26:25,280
we're going to have a round trip for sort of append entries.

404
00:26:26,020 --> 00:26:29,590
And it turns out that that can be expensive, and like,

405
00:26:29,590 --> 00:26:34,030
and and the real question is like you can follower be far far behind.

406
00:26:35,310 --> 00:26:38,010
And let me ask that we're [] for a second,

407
00:26:38,010 --> 00:26:40,770
so you can reflect and think about that case,

408
00:26:41,070 --> 00:26:45,690
is it possible that a follower can be far far behind for a given leader.

409
00:26:49,110 --> 00:26:51,510
If a new machine joins the cluster?

410
00:26:52,060 --> 00:26:55,930
Yeah, new join cluster is a good example, any other cases?

411
00:26:57,820 --> 00:27:01,510
A machine crashed and is only coming back online after several terms.

412
00:27:01,630 --> 00:27:04,420
Yeah, exactly, it comes back after a date,

413
00:27:04,990 --> 00:27:06,460
it might be far behind,

414
00:27:06,940 --> 00:27:12,370
so that would mean like in the protocol and unoptimized version that you're gonna go back one by one from the log entries.

415
00:27:13,260 --> 00:27:14,490
So that's a little bit expensive

416
00:27:14,850 --> 00:27:18,330
and so the paper actually discusses an optimization,

417
00:27:18,330 --> 00:27:19,590
so to catch up quickly.

418
00:27:30,740 --> 00:27:34,860
And, and the idea basically is

419
00:27:34,860 --> 00:27:39,510
instead of like backing off as I said earlier,

420
00:27:39,510 --> 00:27:42,600
the next index is basically optimistic, just guess right

421
00:27:42,600 --> 00:27:45,330
and it doesn't really have to be that accurate,

422
00:27:45,660 --> 00:27:48,330
and and so the observation is that

423
00:27:48,330 --> 00:27:50,850
you know we don't really have to go one by one back,

424
00:27:50,880 --> 00:27:53,370
you know it's perfectly fine for example to go a whole term back.

425
00:27:53,810 --> 00:27:55,700
And in fact there's a logical

426
00:27:55,700 --> 00:27:59,750
maybe that's just a node you know you know it's a couple of terms back

427
00:27:59,750 --> 00:28:01,220
and we back off a couple of terms

428
00:28:01,220 --> 00:28:03,260
and then we'll scan from there.

429
00:28:04,050 --> 00:28:06,570
Alright, so to illustrate a little bit how it works,

430
00:28:06,930 --> 00:28:09,030
let me use the full example,

431
00:28:09,330 --> 00:28:11,730
and I'm just gonna do two servers,

432
00:28:11,880 --> 00:28:14,910
even though they might be you know need 3 to sort of have a majority,

433
00:28:14,910 --> 00:28:16,920
but let's assume there's a third one

434
00:28:16,920 --> 00:28:18,480
and it just plays happily along.

435
00:28:19,260 --> 00:28:21,840
So, here's S1, here's S2,

436
00:28:23,320 --> 00:28:29,650
and let's see you know we this guy has 5 5 5,

437
00:28:33,640 --> 00:28:38,470
and this is 1 2 3 4 5 indexes,

438
00:28:39,070 --> 00:28:41,170
and you know let's say,

439
00:28:42,090 --> 00:28:47,080
S2 has 4, basically all 6s,

440
00:28:47,260 --> 00:28:50,440
so basically S1 is you know quite behind,

441
00:28:50,470 --> 00:28:57,730
because that's the only place where they actually line up is in the first entry, in first which is term 4.

442
00:28:58,390 --> 00:29:00,370
So in the unoptimized scheme,

443
00:29:00,370 --> 00:29:03,550
we would back off one by one, one by one until we finally got there.

444
00:29:04,860 --> 00:29:09,660
And to optimize this, the paper describes an optimization,

445
00:29:09,840 --> 00:29:15,030
unfortunately the opposition is not as described in the same amount of detail as figure 2

446
00:29:15,030 --> 00:29:19,170
and so in fact you will in the for 2c actually pass through c,

447
00:29:19,170 --> 00:29:20,610
you do actually have to have,

448
00:29:21,100 --> 00:29:24,910
and this optimization, a form of this optimization implemented,

449
00:29:25,090 --> 00:29:26,950
your reasonable free actually how to implement it,

450
00:29:26,950 --> 00:29:28,960
because paper doesn't describe very precisely,

451
00:29:28,960 --> 00:29:30,340
you know which how you should do it,

452
00:29:30,340 --> 00:29:31,810
then you have to do a little bit of work,

453
00:29:32,020 --> 00:29:34,660
but the basic idea is as follows.

454
00:29:35,060 --> 00:29:40,310
And just instead of just voting or just saying no or yes, as we know on the previous slide,

455
00:29:40,460 --> 00:29:44,480
the rejection, so you say no,

456
00:29:45,150 --> 00:29:47,310
the rejection includes a little bit of more information

457
00:29:47,580 --> 00:29:51,930
and then that information is going to help the leader to basically back off quicker,

458
00:29:52,700 --> 00:29:57,560
and so includes something what they call the conflicting term,

459
00:29:58,940 --> 00:30:01,070
in response the conflicting index.

460
00:30:03,920 --> 00:30:09,650
And the, the conflicting term is basically the,

461
00:30:09,800 --> 00:30:13,040
you know if let me actually make this a more clear,

462
00:30:13,040 --> 00:30:16,880
let's say here's S1 timeline, here's S2,

463
00:30:17,620 --> 00:30:21,580
so S2 sends you know elected leader in 7, correct,

464
00:30:21,580 --> 00:30:23,410
because it has the most up to date,

465
00:30:23,440 --> 00:30:27,790
a log it sends a message to S1 you know a heartbeat,

466
00:30:28,220 --> 00:30:29,990
and, in a heartbeat,

467
00:30:29,990 --> 00:30:35,600
it will say you know the previous term was 6

468
00:30:36,080 --> 00:30:40,760
and previous index was 5,

469
00:30:42,620 --> 00:30:47,960
and now, when this one gets this you know looks at this log and sees that actually the previous term was 5,

470
00:30:48,840 --> 00:30:52,590
and so instead of actually and so it will include in response

471
00:30:52,590 --> 00:30:57,960
you know conflicting term term conflicts on in that index and that was 5.

472
00:30:58,630 --> 00:30:59,860
We're going to the final entry

473
00:31:00,190 --> 00:31:05,410
and then it also includes what the first index of that term is in this log,

474
00:31:05,440 --> 00:31:08,380
so we look at this term like 5 5 5

475
00:31:08,380 --> 00:31:12,010
and the first time like the index 5 showed up its log is at index 2

476
00:31:12,070 --> 00:31:13,690
and so we'll include that too,

477
00:31:14,020 --> 00:31:16,930
and we'll send that back you know to the leader,

478
00:31:16,930 --> 00:31:18,820
so here's S2 was leader,

479
00:31:19,160 --> 00:31:23,670
and so we're going to send back you know 5 comma 2,

480
00:31:23,790 --> 00:31:25,650
that's the conflicting information

481
00:31:26,070 --> 00:31:31,620
and leader uses that information to basically skip backward further,

482
00:31:31,620 --> 00:31:33,660
in fact it skips back from,

483
00:31:33,660 --> 00:31:42,140
so initially it's guess was next index for S1 was 6.

484
00:31:42,680 --> 00:31:44,210
And based on this information

485
00:31:44,210 --> 00:31:46,220
and it actually scales back to 2,

486
00:31:46,310 --> 00:31:47,690
so it turns it into 2

487
00:31:48,020 --> 00:31:52,590
and then the next append entries is going to include everything from 2.

488
00:31:53,820 --> 00:31:56,640
So its gonna to include you know 5 5 5,

489
00:31:58,140 --> 00:32:02,730
and previous term is 4 and previous index is 1,

490
00:32:04,650 --> 00:32:07,350
and now S1 can one [] [] [],

491
00:32:07,350 --> 00:32:13,020
basically copy you know the new log entries over the entries 2 3 4 or 5 actually back up to date.

492
00:32:14,200 --> 00:32:17,500
So this basically reduces the number of heartbeats,

493
00:32:17,500 --> 00:32:23,020
you know to catch up follower by one per term instead of one per entry.

494
00:32:30,850 --> 00:32:31,690
Any questions?

495
00:32:33,430 --> 00:32:37,360
How do we make sure that we don't you know overload the bandwidth,

496
00:32:37,360 --> 00:32:42,370
because imagine if you have like, you're trying to send back all of these log entries

497
00:32:42,370 --> 00:32:45,490
cause that caused problems in terms of like packets that are too large.

498
00:32:46,060 --> 00:32:47,290
Yeah, so a great question,

499
00:32:47,290 --> 00:32:51,820
like and because it sort of indicates an alternative scheme, right,

500
00:32:51,820 --> 00:32:54,400
but you know the go back here,

501
00:32:54,820 --> 00:32:57,940
is that instead of actually making this optimistic guess

502
00:32:57,940 --> 00:32:59,380
you know why make a guess at all,

503
00:32:59,500 --> 00:33:03,550
just send everything you know the leader could have send like though it's whole log,

504
00:33:03,670 --> 00:33:04,750
it would be perfectly fine

505
00:33:04,750 --> 00:33:09,130
and then basically you know any of the followers can fish out the ones they need, right,

506
00:33:10,850 --> 00:33:14,180
and that would be an alternative implementation

507
00:33:14,180 --> 00:33:16,670
and presumably we don't like the implementation,

508
00:33:16,850 --> 00:33:18,560
because the log might be large

509
00:33:18,770 --> 00:33:21,410
and that would be problematic.

510
00:33:22,260 --> 00:33:25,830
So I think you know the basic guess here that's going on is

511
00:33:25,830 --> 00:33:30,540
that in enormous typical situations,

512
00:33:30,570 --> 00:33:34,200
the followers or you know hopefully reasonable close together

513
00:33:34,200 --> 00:33:36,990
and so backing off a couple entries is actually sufficient.

514
00:33:37,630 --> 00:33:42,730
And if not, then we might go back one term, but not all terms.

515
00:33:43,340 --> 00:33:46,490
And so we'll send the log entries for one term

516
00:33:46,490 --> 00:33:48,020
and that might be a lot, right,

517
00:33:48,050 --> 00:33:48,830
that might be a lot

518
00:33:48,830 --> 00:33:50,750
and we'll see in a second, like how we get around that,

519
00:33:51,470 --> 00:33:56,300
snapshot is going to help you know reducing the number of log entries, that we have to send.

520
00:33:59,460 --> 00:34:05,040
There was a question do you need to implement this sort of version of these optimization scheme in lab 2c,

521
00:34:05,040 --> 00:34:05,820
and the answer is yes.

522
00:34:06,860 --> 00:34:11,750
At least I believe, I haven't been able to pass the test without implementing some optimization.

523
00:34:13,970 --> 00:34:15,230
So I have a question,

524
00:34:15,260 --> 00:34:17,480
so I in my code,

525
00:34:17,480 --> 00:34:21,440
I did the optimization by backing off to the commit,

526
00:34:21,650 --> 00:34:26,270
so I made the the reply include the last commit index

527
00:34:26,270 --> 00:34:27,650
and then I started from there,

528
00:34:28,920 --> 00:34:31,020
is that much worse.

529
00:34:31,020 --> 00:34:32,370
You might run into trouble

530
00:34:32,370 --> 00:34:37,410
and so the the test keep track of how many bytes you sent,

531
00:34:37,880 --> 00:34:38,930
and gives you a budget

532
00:34:38,930 --> 00:34:44,090
and if you're like go across the budget you know by too much,

533
00:34:44,360 --> 00:34:46,160
then the testing will say,

534
00:34:46,160 --> 00:34:48,380
well, you're just sending too much data,

535
00:34:50,800 --> 00:34:52,540
because your scheme it might be the case,

536
00:34:52,540 --> 00:34:55,180
that I think you will send more data than really necessary,

537
00:34:55,750 --> 00:34:57,400
whatever necessary means, but.

538
00:35:00,990 --> 00:35:02,460
There is a question in chat.

539
00:35:02,790 --> 00:35:05,940
Yeah, and did I said draw the wrong thing,

540
00:35:05,940 --> 00:35:09,160
yeah 6 6 6 6 sorry, thank you,

541
00:35:10,490 --> 00:35:18,920
6 6 6, I don't want to follower overriding the leader's log entries,

542
00:35:19,220 --> 00:35:21,230
sorry about that, good catch.

543
00:35:24,880 --> 00:35:25,630
Any questions?

544
00:35:32,510 --> 00:35:33,110
Okay.

545
00:35:40,300 --> 00:35:43,900
Okay, so let me talk a little bit about the persistence,

546
00:35:45,370 --> 00:35:47,590
we have one question in the chat, first.

547
00:35:48,010 --> 00:35:48,700
Okay.

548
00:35:48,700 --> 00:35:55,080
They're wondering why does the rejection has to send back the rejected term number as well as the index.

549
00:35:58,640 --> 00:36:02,600
Well, that depends very much how you actually implement the,

550
00:36:02,600 --> 00:36:05,810
how what kind of state you maintain on the leader

551
00:36:05,810 --> 00:36:08,000
and how the leader decides to back off,

552
00:36:10,180 --> 00:36:12,790
do you need to know send some terms back,

553
00:36:12,790 --> 00:36:17,440
because you need a [] in response get delayed for a long period of time,

554
00:36:17,440 --> 00:36:22,060
you certainly should reject you know information from terms that are completely not relevant anymore.

555
00:36:25,410 --> 00:36:27,240
I know this is slightly vague answer,

556
00:36:27,240 --> 00:36:30,330
but it's really very much dependent on exactly how you implement it.

557
00:36:37,480 --> 00:36:39,940
Okay, persistence,

558
00:36:45,970 --> 00:36:48,790
we talked about the persistence a little bit,

559
00:36:49,370 --> 00:36:51,950
in last raft of, the first raft lecture,

560
00:36:51,950 --> 00:36:55,340
where you know we noted that you know the

561
00:36:55,370 --> 00:36:59,330
and follower can only vote for one candidate per term

562
00:36:59,330 --> 00:37:03,410
and therefore it needs to remember it's who'd voted for

563
00:37:03,410 --> 00:37:04,850
and what actually the current term is,

564
00:37:05,590 --> 00:37:11,530
but there's a larger issue around persistence

565
00:37:11,740 --> 00:37:14,260
and that came up in one of the questions,

566
00:37:14,260 --> 00:37:15,220
one of you just asked,

567
00:37:15,220 --> 00:37:18,010
which is, you know what happens on reboot.

568
00:37:21,640 --> 00:37:24,640
And there's sort of two possible strategy you can think of,

569
00:37:24,670 --> 00:37:26,710
like one strategy is,

570
00:37:30,470 --> 00:37:32,120
what strategy 1 is,

571
00:37:32,790 --> 00:37:36,930
you know basically the node joins sort of freshly,

572
00:37:37,830 --> 00:37:44,640
so joins basically when a node crashes and comes back up,

573
00:37:44,640 --> 00:37:46,080
it just doesn't participate anymore,

574
00:37:46,080 --> 00:37:48,330
it has to rejoin you know the,

575
00:37:49,880 --> 00:37:51,650
rejoin the raft cluster,

576
00:37:52,410 --> 00:37:59,240
and that means you know when rejoins you should you have to replay the log,

577
00:37:59,270 --> 00:38:02,180
where basically has to receive every entry in the log

578
00:38:02,300 --> 00:38:04,900
and then replay that.

579
00:38:05,680 --> 00:38:10,150
And of course you know like if a node has been down,

580
00:38:10,150 --> 00:38:13,270
for a node crashes down for a day or two days

581
00:38:13,270 --> 00:38:15,730
or even if it just goes down for a second,

582
00:38:16,300 --> 00:38:18,910
but you know the system has been up for a year,

583
00:38:19,000 --> 00:38:22,150
that number means you have to replay a lot of log entries,

584
00:38:22,360 --> 00:38:23,650
so there's a little bit annoying.

585
00:38:23,650 --> 00:38:27,880
And so people prefer that strategy 2 which is,

586
00:38:28,960 --> 00:38:30,220
you know you can back up,

587
00:38:31,820 --> 00:38:34,010
and you just basically participate again,

588
00:38:35,070 --> 00:38:39,840
so you catch up from basically you start from your persistent state,

589
00:38:49,460 --> 00:38:53,300
the idea being that you know it's just a quick reboot

590
00:38:53,330 --> 00:38:56,600
you crash you can back up whatever quick network failure,

591
00:38:56,840 --> 00:39:00,530
and so maybe you know the rest can move one term along,

592
00:39:00,710 --> 00:39:02,840
you basically have all the state

593
00:39:02,990 --> 00:39:05,570
and you should be used for quick catch up.

594
00:39:06,070 --> 00:39:07,120
So then, the real question is,

595
00:39:07,120 --> 00:39:11,980
what needs to be at what state needs to be persisted across reboots.

596
00:39:12,870 --> 00:39:15,330
You know where he talked about voting for,

597
00:39:15,690 --> 00:39:17,280
that needs to be persistent,

598
00:39:19,510 --> 00:39:25,510
because you are not allowed to vote for another candidate in the same term,

599
00:39:26,260 --> 00:39:30,070
and but the raft contains a little bit more information

600
00:39:30,190 --> 00:39:35,020
and also maintains the log on disk or in persistent state,

601
00:39:35,560 --> 00:39:37,630
and the current term.

602
00:39:42,820 --> 00:39:45,460
And for each one we should ask ourselves the question,

603
00:39:47,210 --> 00:39:49,730
why maintain a persistent state,

604
00:39:49,730 --> 00:39:53,090
because it means that whenever we update that state,

605
00:39:53,090 --> 00:39:55,850
whenever we append an entry to the log,

606
00:39:55,940 --> 00:39:58,070
whenever we increment the term

607
00:39:58,280 --> 00:40:00,680
or whenever we change forward,

608
00:40:00,680 --> 00:40:03,770
we actually have to write to disk or to stable storage

609
00:40:03,770 --> 00:40:05,420
and stable storage is expensive

610
00:40:05,600 --> 00:40:14,120
and so, it's very likely the example, the the writing or to stable storage could be the could become a bottleneck.

611
00:40:15,800 --> 00:40:17,180
So we're only talking about votedFor,

612
00:40:17,180 --> 00:40:18,200
so I'm going [],

613
00:40:18,200 --> 00:40:19,820
but let's talk about the log,

614
00:40:19,820 --> 00:40:22,700
why does the log have to be written to persistent storage,

615
00:40:24,580 --> 00:40:25,780
can we reintegrate.

616
00:40:38,760 --> 00:40:39,810
Another way, you've got a question,

617
00:40:39,810 --> 00:40:41,610
let's say we don't try to use stable storage,

618
00:40:41,610 --> 00:40:42,420
what would break.

619
00:40:55,300 --> 00:40:58,960
Yeah, there's someone in the chat to answer this question,

620
00:40:58,960 --> 00:41:01,750
which you could lose the majority on the commit write entries, right.

621
00:41:02,420 --> 00:41:05,030
So here's the scenario,

622
00:41:05,060 --> 00:41:12,230
we're, the raft replicated, the operation on a majority of the nodes,

623
00:41:12,780 --> 00:41:16,980
so somebody you know majority nodes it's actually committed

624
00:41:17,010 --> 00:41:22,920
to actually delivering have delivered having accepted that log entry,

625
00:41:23,570 --> 00:41:26,630
so the leader sees the commits,

626
00:41:26,840 --> 00:41:30,830
it delivers the message when their operation on the applied channel to the servers,

627
00:41:31,010 --> 00:41:33,320
servers executes the operation

628
00:41:33,470 --> 00:41:36,020
and lets the client know the operation has succeeded.

629
00:41:37,550 --> 00:41:40,250
So now you know basically exposed the fact,

630
00:41:40,250 --> 00:41:44,720
that the actually operation was actually replicated the majority of nodes to the client.

631
00:41:45,390 --> 00:41:47,220
And so if we're not,

632
00:41:47,220 --> 00:41:49,890
if the followers that actually received that entry,

633
00:41:49,890 --> 00:41:51,810
did not put it on put on disk

634
00:41:52,050 --> 00:41:56,070
and so that when the reboot they still have it,

635
00:41:56,460 --> 00:41:57,930
we could run into the case,

636
00:41:57,930 --> 00:41:59,910
the exactly that's the answer in the chat,

637
00:41:59,910 --> 00:42:02,790
that we lose the majority on committed entry

638
00:42:02,790 --> 00:42:08,400
and that entry will not be delivered on the remaining replicas to the servers

639
00:42:08,400 --> 00:42:10,350
and so the client will see something strange,

640
00:42:10,350 --> 00:42:14,310
where it sees that an operation that it did actually happen a little bit later,

641
00:42:14,400 --> 00:42:16,830
actually goes into the operation hasn't happened.

642
00:42:17,700 --> 00:42:18,900
And so it actually is important,

643
00:42:18,900 --> 00:42:20,520
that this actually isn't stable storage,

644
00:42:20,520 --> 00:42:23,310
we basically promised the leader to commit,

645
00:42:28,490 --> 00:42:30,320
and we cannot back out of that promise.

646
00:42:33,420 --> 00:42:33,960
Okay?

647
00:42:34,930 --> 00:42:36,100
Any questions about this?

648
00:42:43,660 --> 00:42:47,380
Why do we need to remember the current term for on disk,

649
00:42:47,380 --> 00:42:49,360
does it does not need to be stored stably?

650
00:42:53,020 --> 00:42:59,300
Well, the term, you vote for a different person in every term,

651
00:42:59,300 --> 00:43:01,160
so if you don't keep track of what term it is,

652
00:43:01,160 --> 00:43:04,760
then you don't really, you don't actually know who you voted for, right.

653
00:43:04,790 --> 00:43:06,860
Yeah, exactly, you know you voted for,

654
00:43:06,860 --> 00:43:09,680
that's one problem also current terms always have to go up,

655
00:43:10,070 --> 00:43:11,810
you cannot go down in term,

656
00:43:12,080 --> 00:43:18,380
because you're going to use that to detect rpcs from stale leaders and stale candidates,

657
00:43:19,790 --> 00:43:21,020
but it always has to go up.

658
00:43:30,690 --> 00:43:31,320
Okay?

659
00:43:34,550 --> 00:43:36,110
Any questions about persistence?

660
00:43:45,360 --> 00:43:52,950
Yeah, which is more about the way you laid out stuff,

661
00:43:52,950 --> 00:43:55,320
but you say there's two strategies, right,

662
00:43:55,560 --> 00:44:01,260
they need a log, and starting from a persistent state.

663
00:44:01,710 --> 00:44:08,250
Yeah, and so I mean the way you describe starting from a persistent state,

664
00:44:11,030 --> 00:44:17,320
do you like, do you are replay like,

665
00:44:18,600 --> 00:44:21,270
like I guess it doesn't say in this slide,

666
00:44:21,270 --> 00:44:28,700
like if you have does that assume you also have like a snapshot of obviously.

667
00:44:29,180 --> 00:44:31,280
I have not talked about snapshots at all yet,

668
00:44:31,310 --> 00:44:32,660
which we'll talk about in a second,

669
00:44:32,690 --> 00:44:34,550
it's actually the next topic.

670
00:44:35,080 --> 00:44:35,830
Okay, but.

671
00:44:35,830 --> 00:44:39,820
The point is, okay, the two strategys after a node crashes,

672
00:44:39,850 --> 00:44:41,830
there's two ways to treat that node,

673
00:44:41,920 --> 00:44:45,700
one has a complete new node, that never existed in the system ever

674
00:44:46,090 --> 00:44:49,450
and so when it comes up you know you added to the cluster

675
00:44:49,450 --> 00:44:50,590
as if it's a new node,

676
00:44:50,590 --> 00:44:52,210
so basically the cluster goes from,

677
00:44:52,830 --> 00:44:55,320
you know, let's say you started with seven nodes,

678
00:44:55,350 --> 00:44:57,690
one guy crashes, the cluster has six nodes,

679
00:44:57,840 --> 00:44:59,100
it just happily proceed,

680
00:44:59,100 --> 00:45:02,430
you know, whatever the other nodes do their application and all that kind of stuff

681
00:45:02,580 --> 00:45:05,850
and then the second node actually comes back up.

682
00:45:06,360 --> 00:45:09,270
And so there's two ways you know then join,

683
00:45:09,270 --> 00:45:12,420
one way is to say like well I just forget everything I did ever,

684
00:45:12,600 --> 00:45:15,030
I'll join the cluster again

685
00:45:15,030 --> 00:45:16,950
and the other six nodes will bring me up to date

686
00:45:17,070 --> 00:45:20,280
and they'll send the log to me and I'll redo operations,

687
00:45:21,700 --> 00:45:24,310
and that can be costly, even with snapshots.

688
00:45:25,080 --> 00:45:27,060
So the second strategy is to say,

689
00:45:27,060 --> 00:45:30,330
well you know if the same node seven comes back up again,

690
00:45:30,540 --> 00:45:34,860
it tries to reintegrate with its with its persistent state that it has,

691
00:45:35,960 --> 00:45:42,710
you know basically the hope that you know example you went down for a couple nanoseconds or microseconds or milliseconds,

692
00:45:42,950 --> 00:45:44,870
there's basically not much catching up to do at all,

693
00:45:44,870 --> 00:45:46,700
because it already has on the state.

694
00:45:48,700 --> 00:45:51,540
But it would like,

695
00:45:52,160 --> 00:45:54,530
the aside from the log,

696
00:45:54,530 --> 00:45:56,120
there's also a state machine, right,

697
00:45:56,120 --> 00:45:58,490
that you've been like apply changes too.

698
00:45:58,520 --> 00:46:01,280
Yeah yeah, so yeah let's talk about that,

699
00:46:01,280 --> 00:46:02,810
so there's nothing, that's the next topic.

700
00:46:05,610 --> 00:46:06,720
I think, yeah,

701
00:46:06,720 --> 00:46:09,270
so now what about service recovery.

702
00:46:16,120 --> 00:46:18,850
Sorry, I actually have another question on persistence.

703
00:46:19,210 --> 00:46:20,440
Yep.

704
00:46:20,500 --> 00:46:23,410
When does the server decide to persist?

705
00:46:24,170 --> 00:46:26,630
Good, great question,

706
00:46:26,630 --> 00:46:27,470
you know what you think,

707
00:46:28,790 --> 00:46:29,900
I'm sure you've thought about this.

708
00:46:33,190 --> 00:46:39,580
I mean, I think a simple answer would be every time one of these variables changes,

709
00:46:39,580 --> 00:46:43,720
but that seems like a very costly thing to do.

710
00:46:44,080 --> 00:46:45,910
I I think that is the correct answer,

711
00:46:46,770 --> 00:46:48,570
whenever one of these variable changes,

712
00:46:48,570 --> 00:46:51,540
you actually flush to disk or write to,

713
00:46:51,540 --> 00:46:56,280
in our case correct in labs you write to the persistent module.

714
00:46:57,960 --> 00:46:58,680
Okay, and.

715
00:46:58,950 --> 00:47:02,160
So for example when the leader you know accepts an entry,

716
00:47:02,160 --> 00:47:03,120
you know through start

717
00:47:03,480 --> 00:47:06,330
and appends to its local its log,

718
00:47:06,360 --> 00:47:08,700
it actually has to persist that entry.

719
00:47:13,480 --> 00:47:16,990
Right, and so does the persisting work incrementally,

720
00:47:17,020 --> 00:47:19,600
so it like once you get a new log entry,

721
00:47:19,840 --> 00:47:23,090
you append or to take the entire state

722
00:47:23,090 --> 00:47:24,830
and like rewrite it into the file.

723
00:47:24,830 --> 00:47:27,590
But, okay, in real life, you append, right,

724
00:47:27,590 --> 00:47:29,270
then you would not rewrite the whole log,

725
00:47:29,270 --> 00:47:31,100
you would just append one entry to the log

726
00:47:31,100 --> 00:47:33,260
and that's actually one of the reasons that logs are cool,

727
00:47:33,500 --> 00:47:38,030
because you know you can just append at the end and incrementally,

728
00:47:38,480 --> 00:47:41,210
in our lab,

729
00:47:41,210 --> 00:47:42,260
the whole thing is fake,

730
00:47:42,290 --> 00:47:44,780
the persistent actually doesn't really persist,

731
00:47:45,080 --> 00:47:50,840
you know it keeps the object around in between crashes,

732
00:47:50,840 --> 00:47:52,640
because crashes are also sort of fake,

733
00:47:52,640 --> 00:47:56,060
you know the tester basically stops nodes, restart them

734
00:47:56,060 --> 00:47:57,620
and basically gives them the new state,

735
00:47:59,840 --> 00:48:02,210
but in the real system, you would append,

736
00:48:02,970 --> 00:48:04,440
so the log would be a file,

737
00:48:04,470 --> 00:48:06,030
and you would append an entry to the file.

738
00:48:07,500 --> 00:48:08,010
Thank you.

739
00:48:14,260 --> 00:48:16,660
And yes, you know we actually you will have to,

740
00:48:16,660 --> 00:48:19,390
a real system, if you append the log entry,

741
00:48:19,390 --> 00:48:21,670
your first append log entry, then you response,

742
00:48:21,880 --> 00:48:23,170
so in the append entries,

743
00:48:23,350 --> 00:48:25,540
if you update the log append,

744
00:48:25,840 --> 00:48:28,790
so if append entries on the follower,

745
00:48:28,820 --> 00:48:30,590
receives a new set of log entries,

746
00:48:30,590 --> 00:48:33,680
it appends them to its local persistent log

747
00:48:33,740 --> 00:48:34,970
and then it can respond,

748
00:48:34,970 --> 00:48:38,540
because you would be bad to respond before appending,

749
00:48:38,540 --> 00:48:41,660
because then you might lose you know the,

750
00:48:41,930 --> 00:48:47,420
if you responded before appending, you might be running a situation where just before actually the actual append happens,

751
00:48:47,420 --> 00:48:48,080
you crashes,

752
00:48:48,290 --> 00:48:51,020
and so you actually did not persist log entries

753
00:48:51,200 --> 00:48:55,340
and so you would you know, you could lose committed entries.

754
00:49:00,250 --> 00:49:00,790
Okay?

755
00:49:02,620 --> 00:49:04,690
Okay, so how about service recovery,

756
00:49:05,170 --> 00:49:07,300
so the service keeps its own state,

757
00:49:07,330 --> 00:49:10,930
like for example in lab 3, you're implementing a key-value store

758
00:49:11,320 --> 00:49:17,800
and so the key-value store maintains basically hash map from a key to a value

759
00:49:17,950 --> 00:49:20,590
and you need to replay that state.

760
00:49:21,160 --> 00:49:25,480
And again there are two possible ways of going about it,

761
00:49:25,870 --> 00:49:30,970
one strategy one is to replay the log to actually reconstruct that state.

762
00:49:34,190 --> 00:49:40,220
So basically if you're sort of similar to the strategy one on the previous slide,

763
00:49:40,490 --> 00:49:44,630
you just take the log use replay all the entries in the log

764
00:49:44,630 --> 00:49:48,140
and should basically create exactly the same state,

765
00:49:48,500 --> 00:49:52,400
as if as before,

766
00:49:52,430 --> 00:49:57,440
because you know the whole point of this replicated state machine approach is that,

767
00:49:57,830 --> 00:50:01,670
the all the operations are executed in total order,

768
00:50:01,670 --> 00:50:03,080
operations have no side effect,

769
00:50:03,170 --> 00:50:05,270
so if you start in the same stage with nothing,

770
00:50:05,510 --> 00:50:07,520
and you replay all the operations,

771
00:50:07,520 --> 00:50:09,410
you should end up exactly the same state,

772
00:50:09,530 --> 00:50:10,880
is any other node,

773
00:50:12,480 --> 00:50:13,890
and so that's one possible,

774
00:50:14,100 --> 00:50:16,980
and so that was one way to recreate the state.

775
00:50:24,400 --> 00:50:26,260
And you know obviously this is expensive,

776
00:50:26,320 --> 00:50:30,100
you know if the service actually has been running for a couple years

777
00:50:30,460 --> 00:50:33,040
and then you have to replay the logs,

778
00:50:33,040 --> 00:50:34,540
you know from the beginning of time

779
00:50:34,540 --> 00:50:36,970
you know that is not you know so desirable.

780
00:50:37,570 --> 00:50:42,190
And so you know people do don't really follow strategy one,

781
00:50:42,310 --> 00:50:43,840
gonna follow another strategy

782
00:50:43,840 --> 00:50:46,450
and we just basically making periodic snapshots.

783
00:50:47,350 --> 00:50:49,240
And there are two reasons for doing that,

784
00:50:49,510 --> 00:50:53,530
one basically will reconstruct you know the service date in the past manner

785
00:50:53,650 --> 00:50:55,180
and the second reason to do that is

786
00:50:55,180 --> 00:50:58,420
to be able to compact the log,

787
00:50:58,450 --> 00:51:07,240
you know even the raft state itself can be cut off from the front of the prefix can be cut off.

788
00:51:07,830 --> 00:51:09,480
And the basic observation is that,

789
00:51:09,780 --> 00:51:12,570
if the application is running for a while,

790
00:51:12,570 --> 00:51:16,590
then it has it the first thousand operations or the first million operations,

791
00:51:16,830 --> 00:51:20,100
then the state does construct that point,

792
00:51:21,420 --> 00:51:29,440
the states will contain all ops you know c through [i],

793
00:51:30,900 --> 00:51:34,680
where i maybe a thousand or a million whatever you whatever you,

794
00:51:35,070 --> 00:51:38,070
so, so one way to think about is

795
00:51:38,070 --> 00:51:45,240
that there's a duality between state replication and log replication or replay,

796
00:51:45,330 --> 00:51:49,710
the you could save the state after a thousand operations

797
00:51:49,710 --> 00:51:56,580
and then you've got exactly the same thing as actually re-applying redoing every operation from 0 to the fast.

798
00:51:57,640 --> 00:51:59,770
And so this means that,

799
00:51:59,770 --> 00:52:01,030
once you have a snapshot,

800
00:52:01,030 --> 00:52:04,780
you stored snapshots tabling on disk in persistent state,

801
00:52:05,110 --> 00:52:13,170
you can cut off, you can log, you can cut the log you know through i.

802
00:52:16,790 --> 00:52:19,700
And so, this allows you to control the size of the log,

803
00:52:19,760 --> 00:52:25,460
basically by periodicly asking the servers to actually take snapshots

804
00:52:25,460 --> 00:52:29,630
and then service telling the raft library yes, I've taken a snapshot through i,

805
00:52:29,660 --> 00:52:34,940
then raft can say okay good, I just know we have to remember anything from i or until i,

806
00:52:35,580 --> 00:52:38,850
that means of course that the snapshot has to be stored on stable storage.

807
00:52:45,050 --> 00:52:46,730
And this is also good for recovery, correct

808
00:52:46,730 --> 00:52:49,040
and so it makes our recovery scheme slightly more complicated

809
00:52:49,040 --> 00:52:50,900
than I just described in the previous slide,

810
00:52:50,900 --> 00:52:52,490
what it has to happen is that

811
00:52:52,880 --> 00:52:58,580
when a follower comes back up after a quick reboot,

812
00:52:58,580 --> 00:53:03,950
it loads its persistent state you know that includes you know the persistent state that we talked about on the previous slide,

813
00:53:03,950 --> 00:53:05,060
you know this information,

814
00:53:05,600 --> 00:53:14,240
but also its last you know snapshot installs that last basically loads that snapshot into memory, the service does.

815
00:53:14,720 --> 00:53:17,570
And then we can replay any log entries

816
00:53:17,570 --> 00:53:19,460
to basically bring the follower up to date.

817
00:53:20,630 --> 00:53:21,410
Okay?

818
00:53:29,350 --> 00:53:30,460
Any questions about this?

819
00:53:31,560 --> 00:53:34,440
I have one question,

820
00:53:34,440 --> 00:53:37,350
I'm not sure if I'm gonna be able phrase super clearly,

821
00:53:37,650 --> 00:53:41,560
I guess, like I was under impression,

822
00:53:41,560 --> 00:53:46,120
so I guess like does this not break some layer of abstraction,

823
00:53:46,600 --> 00:53:51,520
that previously existed between the application on top of raft and raft itself,

824
00:53:51,520 --> 00:53:54,730
for it now needs to understand how the state machine,

825
00:53:54,820 --> 00:53:56,800
like how to apply commands to the state machine

826
00:53:56,800 --> 00:54:01,390
instead of just like giving commands to some external state machine.

827
00:54:01,570 --> 00:54:12,960
Yeah, great observation, clearly, we have to play to get the raft library in the service,

828
00:54:13,520 --> 00:54:19,190
because first of all the service lies about it gives the wrong information about how far it has to apply,

829
00:54:19,190 --> 00:54:21,380
then we getting inconsistent results,

830
00:54:21,380 --> 00:54:23,870
but anyway so we don't assume liers anyway,

831
00:54:23,870 --> 00:54:25,310
but it's clearly the case,

832
00:54:25,430 --> 00:54:29,540
that the service and raft library we have to cooperate.

833
00:54:30,240 --> 00:54:34,230
And, you can go with an abstraction violation,

834
00:54:34,230 --> 00:54:41,250
I think the reason they do it is to limit the amount of state of the raft library we have to maintain,

835
00:54:41,790 --> 00:54:44,820
otherwise, the raft library wouldn't know when it can cut the log.

836
00:54:45,560 --> 00:54:47,630
And so there's basically no way around it,

837
00:54:47,630 --> 00:54:49,400
that the servers actually tells it,

838
00:54:49,400 --> 00:54:51,680
like well I got a snapchat through i

839
00:54:51,710 --> 00:54:55,790
and so it's okay for you to remove log entry from 0 to i.

840
00:54:57,840 --> 00:54:58,920
And you'll see that

841
00:54:58,920 --> 00:55:03,750
and so this will mean a good point this is going to come up in 2d, right,

842
00:55:03,750 --> 00:55:10,080
lab 2d is gonna is all about snapshots and log compassion

843
00:55:10,080 --> 00:55:11,460
as it's also called in the paper.

844
00:55:11,940 --> 00:55:19,200
There there has to be some API between the servers and raft to be able to collaborate

845
00:55:19,230 --> 00:55:23,880
and basically in 2a and 2b that API in fact even to see,

846
00:55:23,880 --> 00:55:25,470
that API is extremely simple,

847
00:55:25,770 --> 00:55:31,520
the only API that exists is this delivering log message on the apply channel, right,

848
00:55:31,520 --> 00:55:34,910
and almost nothing flows down from the service to raft,

849
00:55:34,910 --> 00:55:37,100
like other than the service may start

850
00:55:37,370 --> 00:55:42,740
and raft trying to append an entry to the log using where i start.

851
00:55:43,440 --> 00:55:45,660
And you know and so in 2d,

852
00:55:45,810 --> 00:55:52,410
there has to be a little bit more of an API between service and raft library,

853
00:55:53,040 --> 00:55:57,030
and it turns out, you can design that API in any possible way,

854
00:55:57,030 --> 00:55:58,500
there are quite a number of ways of doing it,

855
00:55:58,530 --> 00:55:59,790
there's no particular one

856
00:55:59,790 --> 00:56:03,600
and the paper doesn't lay out what API you should use,

857
00:56:03,600 --> 00:56:05,790
the papers actually just nothing about this

858
00:56:06,240 --> 00:56:09,720
and so it's up to you to sometimes up to us,

859
00:56:09,720 --> 00:56:10,920
you know to figure out the APIs

860
00:56:10,920 --> 00:56:14,220
and to be able to do 2d,

861
00:56:14,220 --> 00:56:18,150
you know, we have to declare an API between the servers and raft.

862
00:56:18,650 --> 00:56:19,970
And you know you'll see,

863
00:56:19,970 --> 00:56:23,960
what you do today, you know that the API,

864
00:56:23,960 --> 00:56:29,210
you have some funny you might be a little bit more different than you might expect,

865
00:56:29,960 --> 00:56:39,950
and you know we had to pick one particular API in in that APIs as an operation called conditional install,

866
00:56:40,190 --> 00:56:46,970
that you know has semantics that you know allows you to change the raft state

867
00:56:46,970 --> 00:56:49,970
and the server state atomically in one single operation.

868
00:56:51,060 --> 00:56:55,380
And and that partly you know that operation exists,

869
00:56:55,620 --> 00:57:01,060
yeah you try to limit the abstraction [batteries].

870
00:57:03,300 --> 00:57:03,810
Okay?

871
00:57:04,460 --> 00:57:06,050
And it turns out you can do it in different ways,

872
00:57:06,050 --> 00:57:06,860
you don't really need,

873
00:57:06,890 --> 00:57:08,990
you could have written it in different ways,

874
00:57:08,990 --> 00:57:12,680
but you know we are performing is actually one of the more simple ways of doing it.

875
00:57:13,550 --> 00:57:15,380
But it will become more clear in 2d

876
00:57:15,380 --> 00:57:20,810
and you'll see indeed that there's sort of an interaction between the servers and raft,

877
00:57:20,810 --> 00:57:22,400
in a way that they have to play along.

878
00:57:28,700 --> 00:57:32,240
How could you repeat when raft communicates with the servers in the snapshot process,

879
00:57:32,480 --> 00:57:36,380
so the snapshots are driven by the servers.

880
00:57:37,020 --> 00:57:39,660
So the server just says once in a while to raft,

881
00:57:40,050 --> 00:57:41,370
I've made a snapshot,

882
00:57:41,370 --> 00:57:42,480
here's my snapshot,

883
00:57:42,840 --> 00:57:46,050
and this is a snapshot includes all the operations through i,

884
00:57:46,800 --> 00:57:52,650
and then raft you know writes the snapshots and truncates log you know to i

885
00:57:52,800 --> 00:57:55,500
and writes all that information to the disk.

886
00:57:57,500 --> 00:58:03,410
And that's basically all what happens sort of, sort of regular operation periodically snapshots happen snapshot happens.

887
00:58:04,130 --> 00:58:06,020
Then there's the other case,

888
00:58:06,020 --> 00:58:09,140
you have to consider is like when reboot happens.

889
00:58:09,650 --> 00:58:11,360
And so when a follower reboots,

890
00:58:11,360 --> 00:58:15,680
it actually reboots from its persistent state

891
00:58:15,680 --> 00:58:17,360
and so including its snapshot,

892
00:58:18,080 --> 00:58:20,480
and so when the follower reboots,

893
00:58:20,480 --> 00:58:24,950
you know basically loads, you know snapshot from from a persistent disk

894
00:58:24,950 --> 00:58:28,280
and actually reconstructs the application state, the key-value store

895
00:58:28,490 --> 00:58:29,960
and you'll do this in lab 3,

896
00:58:29,960 --> 00:58:31,430
this is not going to be an issue of lab 2.

897
00:58:32,140 --> 00:58:35,320
The only thing that there's going to be an issue lab 2 is that,

898
00:58:35,350 --> 00:58:44,660
because the followers, because the, because the log has been cut, right,

899
00:58:44,660 --> 00:58:48,710
like you know instead of like having all the entries from 0 to i in the log,

900
00:58:49,260 --> 00:58:56,130
plus more, so i you know n the log is being cut you know from i to n, right,

901
00:58:57,760 --> 00:59:00,520
and those are part of the log compation,

902
00:59:01,030 --> 00:59:04,870
but that also means that if a follower is far behind,

903
00:59:04,900 --> 00:59:07,180
like for example new node joins the system

904
00:59:07,360 --> 00:59:12,760
and doesn't actually have the beginning of the log nor the snapshots,

905
00:59:13,350 --> 00:59:18,600
then the raft has to communicate the snapshot to that follower.

906
00:59:19,460 --> 00:59:20,990
So in the case that the follower is

907
00:59:20,990 --> 00:59:27,530
you know before i because we rejoined lab and rejoins the raft cluster,

908
00:59:27,650 --> 00:59:33,660
the leader actually has to set the snapshot you know to the follower

909
00:59:33,660 --> 00:59:35,310
and the follower basically start from there.

910
00:59:36,280 --> 00:59:37,780
And that will show up in 2d

911
00:59:37,780 --> 00:59:45,070
and so there's an additional rpc called the snapshot rpc or install snapshot rpc

912
00:59:45,070 --> 00:59:46,690
and that's described in the paper,

913
00:59:46,720 --> 00:59:48,790
and then you will have to implement in 2d.

914
00:59:49,810 --> 00:59:53,420
In fact, which brings me to a good point,

915
00:59:54,040 --> 00:59:57,230
actually, let me go to [consumer],

916
00:59:57,230 --> 00:59:59,060
basically brings me to the homework question,

917
00:59:59,210 --> 01:00:10,240
which is here's the install snapshot rpc for equivalent figure 2,

918
01:00:10,240 --> 01:00:12,490
would then just snapshot rpc

919
01:00:12,490 --> 01:00:17,200
and you actually have to implement that in 2d

920
01:00:17,560 --> 01:00:23,620
and one issue that came up in the which was the homework question for today is,

921
01:00:23,770 --> 01:00:29,500
is every possible in raft, what avoids it it's not possible,

922
01:00:29,650 --> 01:00:31,810
that the state machine rolls back.

923
01:00:32,290 --> 01:00:33,430
Yeah, so for example,

924
01:00:33,430 --> 01:00:38,620
leader since maybe you know maybe an old snapshot shows up you know at a follower,

925
01:00:39,010 --> 01:00:43,810
is it possible that you know if it's possible,

926
01:00:43,810 --> 01:00:46,690
if that follower would install the snapshot

927
01:00:46,690 --> 01:00:49,690
and then implicitly basically roll back the state machine,

928
01:00:49,750 --> 01:00:51,790
maybe it already has seen more information,

929
01:00:52,390 --> 01:00:54,610
you know clear that seems not right

930
01:00:54,610 --> 01:00:58,390
and so the question is you know how does raft around it

931
01:00:58,720 --> 01:01:03,460
and so maybe this is a great place actually do a quick break out,

932
01:01:03,460 --> 01:01:09,370
and you can debate that homework question for a couple minutes, five minutes

933
01:01:09,580 --> 01:01:10,930
and then we'll come back

934
01:01:11,110 --> 01:01:14,620
and we'll talk about a little bit more about snapshots.

935
01:01:16,790 --> 01:01:18,560
Lily, will be like?

936
01:01:19,470 --> 01:01:24,090
No lily, how about I try, you can.

937
01:01:24,360 --> 01:01:32,620
Hold on, I'll probably have to make you host

938
01:01:32,650 --> 01:01:33,610
and then you can do it,

939
01:01:35,320 --> 01:01:36,670
okay, you should be host now.

940
01:01:37,060 --> 01:01:38,320
Awesome.

941
01:02:06,930 --> 01:02:08,310
Alright, it should be.

942
01:02:08,400 --> 01:02:10,560
Okay, thank you, [] thank you to do it.

943
01:08:06,790 --> 01:08:09,790
And I'll go ahead and make you make you host again.

944
01:08:09,820 --> 01:08:11,110
That'd be great, thank you.

945
01:08:35,730 --> 01:08:37,320
Let me see, I share my screen.

946
01:08:54,160 --> 01:08:56,230
Okay, everybody back online,

947
01:08:59,980 --> 01:09:00,790
we're good to go,

948
01:09:00,820 --> 01:09:03,100
can somebody can respond would be great.

949
01:09:05,080 --> 01:09:07,210
Okay I can hear.

950
01:09:07,630 --> 01:09:11,050
Okay, great, I hear it you know sometimes people,

951
01:09:11,050 --> 01:09:12,280
because of the breakout rooms here

952
01:09:12,280 --> 01:09:15,910
just learning dropped out soon, unfortunately,

953
01:09:18,330 --> 01:09:21,140
past rooms break up,

954
01:09:21,140 --> 01:09:24,700
but hopefully and I don't know exactly what to do about that,

955
01:09:25,450 --> 01:09:29,050
I guess work of fault tolerance is a little bit unfortunate,

956
01:09:29,050 --> 01:09:30,520
that people could just drop.

957
01:09:32,590 --> 01:09:39,520
Okay, so any I think the homework question this time around was reasonable sort of straightforward,

958
01:09:39,520 --> 01:09:44,620
you know it has to be the case that you know you cannot install an old snapshot,

959
01:09:44,650 --> 01:09:48,940
because you know a service that might have had a more recent snapshot,

960
01:09:48,940 --> 01:09:50,320
might have responded to the client,

961
01:09:50,320 --> 01:09:52,090
saying, yeah the operation succeeded,

962
01:09:52,640 --> 01:09:55,310
and then if you would restore an old snapshot,

963
01:09:55,310 --> 01:09:57,590
then you basically back out to the state

964
01:09:57,590 --> 01:10:00,170
and the client would see there's certainly an old version of the server,

965
01:10:00,170 --> 01:10:02,060
so that's certainly not a legit,

966
01:10:02,810 --> 01:10:04,490
and so there's a little bit,

967
01:10:04,550 --> 01:10:06,260
you should definitely reject all snapshots,

968
01:10:06,260 --> 01:10:08,540
but you have to be a little bit careful,

969
01:10:08,540 --> 01:10:12,950
if you know the follower has a log that goes beyond the snapshot,

970
01:10:12,950 --> 01:10:17,390
you have to keep that remained part of the log,

971
01:10:17,720 --> 01:10:20,510
because basically you have promised to a leader,

972
01:10:20,510 --> 01:10:22,220
that you have accepted a message

973
01:10:22,220 --> 01:10:29,990
and so you can't delete you know the rest of the log, that was not covered by the snapshot.

974
01:10:30,710 --> 01:10:31,220
Okay?

975
01:10:35,210 --> 01:10:38,210
Okay, so then let me return.

976
01:10:41,220 --> 01:10:42,960
We had a question, actually.

977
01:10:42,990 --> 01:10:44,280
okay, go ahead.

978
01:10:44,890 --> 01:10:47,860
So it says, it says in the paper right,

979
01:10:47,890 --> 01:10:50,290
if the follower receives a snapshot,

980
01:10:50,470 --> 01:10:52,360
that's a prefix of its log,

981
01:10:53,620 --> 01:10:58,900
the log entries covered by the snapshot are deleted,

982
01:10:58,900 --> 01:10:59,950
but the rest are kept.

983
01:11:00,010 --> 01:11:00,880
Yep.

984
01:11:01,150 --> 01:11:09,250
In that case, it is the state machine wouldn't be overwritten, right, in this case.

985
01:11:09,920 --> 01:11:11,480
Okay, so the interesting question is,

986
01:11:11,480 --> 01:11:17,630
like how does a snapshot get communicated to the state machine

987
01:11:17,630 --> 01:11:19,640
and as you'll see in lab 3

988
01:11:19,640 --> 01:11:20,990
and it goes over the applied channel,

989
01:11:22,080 --> 01:11:26,640
and so the state machine will get a snapshot over the applied channel

990
01:11:27,090 --> 01:11:29,850
and then it's up to it to do the right thing.

991
01:11:32,030 --> 01:11:32,570
Okay.

992
01:11:33,060 --> 01:11:33,420
Okay?

993
01:11:34,350 --> 01:11:35,010
Oops.

994
01:11:36,370 --> 01:11:37,150
Okay good.

995
01:11:37,240 --> 01:11:39,970
So just a follow-up on that, sorry,

996
01:11:40,270 --> 01:11:41,740
though I was a little bit,

997
01:11:41,740 --> 01:11:43,000
so that makes sense to me,

998
01:11:43,060 --> 01:11:44,650
the part that I was confused by is,

999
01:11:44,650 --> 01:11:51,970
in the, in the figure 13 like the box that describes install snapshot rpc,

1000
01:11:53,000 --> 01:11:59,480
on 6, it's says if existing log entry has the same index as the term snapshot last include entry,

1001
01:12:04,890 --> 01:12:07,900
well, hold on, I may have just misread it.

1002
01:12:08,050 --> 01:12:09,910
Okay, why do you keep thinking about it,

1003
01:12:09,910 --> 01:12:10,450
look if.

1004
01:12:10,450 --> 01:12:13,360
I have a question, I'll ask you.

1005
01:12:13,360 --> 01:12:15,670
I'll take it offline and we'll do it right after lecture, if you want to.

1006
01:12:16,900 --> 01:12:19,360
Okay, I want to go back actually for a couple minutes,

1007
01:12:19,360 --> 01:12:22,420
you know that we have remaining and talk about actually using raft,

1008
01:12:22,780 --> 01:12:28,820
which is sort of a discussion that we're already basically having here for servers

1009
01:12:28,940 --> 01:12:31,850
and so again I'm going to focus on the replicated key-value service,

1010
01:12:31,850 --> 01:12:33,440
that's going to be the topic of lab 3.

1011
01:12:34,130 --> 01:12:38,570
And so just to go back to almost like one of the first board

1012
01:12:38,570 --> 01:12:41,660
that I drew at the beginning of the raft lectures,

1013
01:12:41,660 --> 01:12:46,760
here's like our boxes, you know that correspond to the three replicas,

1014
01:12:48,680 --> 01:12:54,330
and each replica correct you know has a sort of split two pieces,

1015
01:12:54,330 --> 01:12:55,650
one is the service part,

1016
01:13:01,180 --> 01:13:04,280
and one is the raft library, right,

1017
01:13:04,280 --> 01:13:08,210
then we know that basically they communicate these two through the apply channel

1018
01:13:08,660 --> 01:13:12,930
unless the way that information flows from raft to service servers.

1019
01:13:16,000 --> 01:13:22,140
And so clients you know interact you know with the servers, you not directly the raft,

1020
01:13:22,440 --> 01:13:24,030
so we have a client here,

1021
01:13:24,580 --> 01:13:28,570
you know that sends you an operation like a put operate or get operation for the service,

1022
01:13:28,720 --> 01:13:30,970
the service receives this operation

1023
01:13:31,120 --> 01:13:36,660
and it basically calls start you know for that operation,

1024
01:13:36,660 --> 01:13:42,060
quick raft does it chit chat you know with you know the other raft libraries,

1025
01:13:42,600 --> 01:13:45,990
you know messages can flow back in at some point the operation is committed

1026
01:13:45,990 --> 01:13:48,360
and then it actually is you know raft will say,

1027
01:13:48,360 --> 01:13:50,850
okay this operation is ready to be committed,

1028
01:13:51,060 --> 01:13:52,560
sends it on the applied channel

1029
01:13:52,680 --> 01:13:56,880
and service then basically execute the operation and send the response back,

1030
01:13:56,880 --> 01:13:59,670
after it executed the operation, response back to the client,

1031
01:13:59,670 --> 01:14:05,460
saying well the value or the get you know key 20 you know is this, right,

1032
01:14:05,460 --> 01:14:08,280
so this is a get operation or put,

1033
01:14:09,500 --> 01:14:14,090
and this is basically the value for the get or you know okay would succeeded.

1034
01:14:14,660 --> 01:14:15,050
Okay?

1035
01:14:15,750 --> 01:14:17,820
And we also discovered in the last lecture,

1036
01:14:18,300 --> 01:14:20,280
it might be the case,

1037
01:14:20,280 --> 01:14:25,920
that the client sends an rpc to the service and the rpc disappears,

1038
01:14:26,040 --> 01:14:27,930
so the client must yeah must resend,

1039
01:14:28,420 --> 01:14:30,370
and by the time the resends actually,

1040
01:14:30,370 --> 01:14:32,350
you know the leader might not be the leader anymore.

1041
01:14:33,080 --> 01:14:34,160
And so in that case,

1042
01:14:34,160 --> 01:14:36,560
it has to sort of redirect itself to another leader,

1043
01:14:37,070 --> 01:14:38,930
so basically when there is a little bit of code

1044
01:14:38,930 --> 01:14:40,130
with a way to think about this.

1045
01:14:40,620 --> 01:14:42,570
There's a little bit of code at the client side,

1046
01:14:42,690 --> 01:14:46,410
sort of understands replicated state machines a little bit,

1047
01:14:46,410 --> 01:14:48,060
and it maintains some information,

1048
01:14:48,060 --> 01:14:49,680
it maintains like who's the leader

1049
01:14:49,980 --> 01:14:52,020
and who are the other followers,

1050
01:14:52,540 --> 01:14:56,020
and so that can switch between them, if necessary.

1051
01:14:57,690 --> 01:15:00,990
We also, last time we talked a little bit about its possible,

1052
01:15:00,990 --> 01:15:03,270
that you know operation can be duplicated, right,

1053
01:15:03,270 --> 01:15:09,050
because you know the, the client may send an operation put operation to the service,

1054
01:15:09,350 --> 01:15:14,210
in the you know the client doesn't get a response,

1055
01:15:14,450 --> 01:15:16,100
but the servers actually received,

1056
01:15:16,100 --> 01:15:20,750
so it went through, you know went through the whole operation sequence,

1057
01:15:20,750 --> 01:15:26,600
you know starting the raft appends can go through the raft motion

1058
01:15:26,600 --> 01:15:28,310
and then basically sending it out to apply channel.

1059
01:15:28,890 --> 01:15:31,620
And so basically the client actually might send a second one,

1060
01:15:33,240 --> 01:15:36,540
and you know the basically for the repetition,

1061
01:15:36,540 --> 01:15:40,860
you know that might actually go through you know the raft library too,

1062
01:15:40,860 --> 01:15:42,030
comes out in the apply channel

1063
01:15:42,030 --> 01:15:44,850
and so you know have to do some duplicate detection and detection

1064
01:15:44,850 --> 01:15:46,140
and multiple ways of doing it,

1065
01:15:46,140 --> 01:15:47,850
but either way you have to duplicate detection.

1066
01:15:48,520 --> 01:15:54,220
So, in addition to a sort of maintain state about like what the leader

1067
01:15:54,220 --> 01:15:57,850
and the followers are put and get also actually have an idea,

1068
01:15:58,340 --> 01:15:59,990
you know an id associated with it

1069
01:15:59,990 --> 01:16:02,840
and we're going to maintain what is the last id,

1070
01:16:02,840 --> 01:16:04,580
that it actually is trying to get through

1071
01:16:04,730 --> 01:16:07,160
and that is used to actually duplicate detection.

1072
01:16:08,560 --> 01:16:11,110
And this little piece of code is often called a clerk,

1073
01:16:11,880 --> 01:16:14,760
you know the clerk that interacts with the service

1074
01:16:14,760 --> 01:16:18,510
and it does a little bit of work to collaborate with the service you actually get the writing done

1075
01:16:18,510 --> 01:16:20,220
and so we have multiple clients,

1076
01:16:20,870 --> 01:16:27,320
all half a clerk of library if you will, which is Go package,

1077
01:16:27,560 --> 01:16:33,120
and you know the clients basically talk puts and gets you know over that interface

1078
01:16:33,120 --> 01:16:35,850
and inside of the clerk actually maintains these ids

1079
01:16:36,150 --> 01:16:38,370
or maintains one idea for the outstanding

1080
01:16:38,370 --> 01:16:40,950
you know put get operation as well as some information

1081
01:16:40,950 --> 01:16:42,510
about who's part of the cluster.

1082
01:16:43,060 --> 01:16:43,540
Okay?

1083
01:16:44,560 --> 01:16:45,340
Does that make sense?

1084
01:16:46,090 --> 01:16:47,710
So that's sort of the basic structure, correct,

1085
01:16:47,710 --> 01:16:50,260
like how raft fits into a larger picture.

1086
01:16:51,520 --> 01:16:54,820
The one question that comes always up is

1087
01:16:54,820 --> 01:16:59,950
what you know what is the guarantees you know that the servers and the clerk together make

1088
01:17:00,250 --> 01:17:03,220
to the clients about these put and get operations.

1089
01:17:05,040 --> 01:17:07,800
So this really means what is the correctness criteria.

1090
01:17:11,940 --> 01:17:15,570
And the way, we always have described so far,

1091
01:17:15,570 --> 01:17:17,010
we've been reasonable [sloppy] about it,

1092
01:17:17,190 --> 01:17:18,840
I've been sloppy about it,

1093
01:17:19,200 --> 01:17:23,770
and maybe I've said is like well should behave like a single machine.

1094
01:17:32,820 --> 01:17:35,370
But even that there's a little bit of an imprecise definition,

1095
01:17:35,370 --> 01:17:40,290
because what happens if two clients basically at the same time you know execute a put or a get operation

1096
01:17:40,290 --> 01:17:43,740
and what actually is the correct outcome of these operations,

1097
01:17:43,740 --> 01:17:45,960
so we really need to sort a little bit more preciser,

1098
01:17:45,990 --> 01:17:48,390
you know I think like maybe like a single machine,

1099
01:17:48,390 --> 01:17:52,050
the right intuition, but we need a little bit preciser definition.

1100
01:17:52,500 --> 01:17:56,370
And this definition you saw the term used in the paper,

1101
01:17:56,460 --> 01:17:59,100
this definition is called linearizability,

1102
01:18:04,410 --> 01:18:11,340
linearizability basically spec specification of what values put and get operations can return,

1103
01:18:11,870 --> 01:18:16,550
particularly those in put operations really what get can actually return.

1104
01:18:17,250 --> 01:18:18,450
And it basically successfully,

1105
01:18:18,450 --> 01:18:20,730
what are allowed things to be returned,

1106
01:18:20,730 --> 01:18:22,680
what are things that are not allowed to be returned,

1107
01:18:22,710 --> 01:18:24,570
independent by actually how you implement it,

1108
01:18:24,840 --> 01:18:26,550
it's just like purely specification.

1109
01:18:27,660 --> 01:18:30,540
And it basically has three components to linearizability,

1110
01:18:31,530 --> 01:18:35,670
linearizability says, if you have look at some sequence of operations

1111
01:18:35,700 --> 01:18:37,590
and some of them executed currently,

1112
01:18:37,890 --> 01:18:38,820
it has to be the case,

1113
01:18:38,820 --> 01:18:39,930
that there's a total order,

1114
01:18:40,080 --> 01:18:42,990
so you can arrange all the operation in some total order,

1115
01:18:52,350 --> 01:18:53,670
put or set operations.

1116
01:18:55,730 --> 01:18:59,720
Two, it has to match real-time.

1117
01:19:06,260 --> 01:19:11,690
With that, I mean that if an operation completed before the second operation started,

1118
01:19:12,520 --> 01:19:15,400
even if those operations are different machines,

1119
01:19:15,400 --> 01:19:17,740
it has to be the case that in this total order,

1120
01:19:17,950 --> 01:19:21,160
the first operation shows up before the second operation.

1121
01:19:24,280 --> 01:19:25,420
And that sort of makes sense, right,

1122
01:19:25,420 --> 01:19:26,950
like if it behaves like a single machine,

1123
01:19:26,950 --> 01:19:29,590
and you start an operation after another operation,

1124
01:19:29,860 --> 01:19:34,300
then the single machine would always return the results of the first operation so

1125
01:19:34,630 --> 01:19:36,370
and finally a read operation,

1126
01:19:37,090 --> 01:19:40,450
so this is like in out case, key-value server only has one read operation,

1127
01:19:40,450 --> 01:19:41,140
then we get,

1128
01:19:41,560 --> 01:19:50,190
but the read operation should always return the results of the last write.

1129
01:19:56,040 --> 01:20:02,190
So in our case, you know we do get operation and the put operation,

1130
01:20:02,430 --> 01:20:04,530
happened well before it

1131
01:20:04,530 --> 01:20:12,540
and completed well before then that get operation should observe the last, should observe the last put.

1132
01:20:12,940 --> 01:20:13,480
Okay?

1133
01:20:14,020 --> 01:20:17,560
So this sort of, these are three conditions,

1134
01:20:17,560 --> 01:20:21,340
you know that whether to determine whether system actually linearizability.

1135
01:20:21,990 --> 01:20:25,860
And you can think about the linearizability as well, just behave like a single machine.

1136
01:20:26,530 --> 01:20:28,510
So let me make a little bit more concrete,

1137
01:20:28,510 --> 01:20:29,830
because there's a little bit abstract.

1138
01:20:30,610 --> 01:20:35,260
And the way basically people think about linearizability

1139
01:20:35,260 --> 01:20:40,360
or argue that the system has linearizability is looking at particular histories or executions

1140
01:20:40,630 --> 01:20:46,230
and then see if you can use histories,

1141
01:20:46,230 --> 01:20:48,150
if you can turn that into total order,

1142
01:20:48,180 --> 01:20:52,110
even though the operations actually might have actually executed concurrently.

1143
01:20:52,790 --> 01:20:55,970
So let me give you one example, a trivial example,

1144
01:20:56,690 --> 01:21:00,920
so let's say we have three clients C1 C2 C3

1145
01:21:01,250 --> 01:21:02,780
and they do a bunch of puts and gets,

1146
01:21:03,390 --> 01:21:05,730
so you know typically the way you know,

1147
01:21:05,730 --> 01:21:09,150
basically it has to be some start point where the operation started,

1148
01:21:09,900 --> 01:21:12,360
and there's some endpoint where the operation ends.

1149
01:21:12,960 --> 01:21:18,060
So, for example when actually the client actually gets the return from the servers,

1150
01:21:18,840 --> 01:21:23,070
and so let's say this write operation you know to value to the variable x,

1151
01:21:23,560 --> 01:21:24,670
and we write one to it.

1152
01:21:25,830 --> 01:21:30,060
So the client one started at some point in the write operation to the variable x the write 1

1153
01:21:30,390 --> 01:21:32,580
and ends at some point here.

1154
01:21:33,330 --> 01:21:40,080
Maybe the second one and write to it,

1155
01:21:40,600 --> 01:21:45,490
and then maybe we have all the action and with linearizability is when operation happens concurrently,

1156
01:21:45,490 --> 01:21:49,120
so all operations starts before another one actually finishes,

1157
01:21:49,120 --> 01:21:53,440
so for example we might have the following operation client 2 does a read operation,

1158
01:21:53,440 --> 01:21:54,910
in our case would be a get,

1159
01:21:55,600 --> 01:21:57,790
and there's a read of x

1160
01:21:57,790 --> 01:21:59,980
and the value returned by this operation is 2.

1161
01:22:00,940 --> 01:22:03,670
And then we have a similar sort of situation

1162
01:22:03,670 --> 01:22:06,640
where clieng 3 it actually starts an operation a read operation,

1163
01:22:07,290 --> 01:22:09,960
and reads x and it returns 1.

1164
01:22:11,370 --> 01:22:13,980
Let me make this a little bit more clean,

1165
01:22:15,660 --> 01:22:21,910
the read operation actually returns before you know the write 2 operation starts or ends,

1166
01:22:22,180 --> 01:22:24,100
and same from [] one

1167
01:22:24,100 --> 01:22:27,910
and then the question that always comes up is this linearizability,

1168
01:22:27,910 --> 01:22:29,410
this linearizability execution.

1169
01:22:30,800 --> 01:22:35,720
And if linearizability, then basically it means like this could happen on a single machine, too.

1170
01:22:37,000 --> 01:22:38,920
So could this happen on a single machine.

1171
01:22:39,940 --> 01:22:42,910
We can just like abstract and think about it without actually having,

1172
01:22:45,220 --> 01:22:50,980
is this legit outcome from basically we need to look at is the outcomes of r2 and for c2 and c3,

1173
01:22:51,220 --> 01:22:53,710
you know is this a legit execution.

1174
01:22:54,520 --> 01:23:01,420
I'm not sure, I don't really know what it means for right to take like a long time.

1175
01:23:03,030 --> 01:23:05,400
Well. Take a long time for that matter.

1176
01:23:06,070 --> 01:23:09,820
If you think about the from the client perspective,

1177
01:23:09,820 --> 01:23:12,490
it sends a request to the service,

1178
01:23:12,490 --> 01:23:13,960
so that's the starting of the write,

1179
01:23:14,550 --> 01:23:18,450
and I've got a return value at some point from the service

1180
01:23:18,450 --> 01:23:19,650
and that's the end of the write.

1181
01:23:20,960 --> 01:23:22,910
And so in between all kinds of stuff happens, right,

1182
01:23:22,910 --> 01:23:24,290
it actually to the servers,

1183
01:23:24,290 --> 01:23:25,940
the servers put into raft,

1184
01:23:25,940 --> 01:23:28,370
raft went to apply channel blah blah blah,

1185
01:23:28,400 --> 01:23:29,270
lots of stuff happened,

1186
01:23:29,300 --> 01:23:32,720
we really care about exactly what the implementation does at some point a response.

1187
01:23:34,120 --> 01:23:35,290
And so you can think about this,

1188
01:23:35,290 --> 01:23:37,450
you know there's basically three concurrent clients,

1189
01:23:37,450 --> 01:23:39,850
you know they issued concurrent operations

1190
01:23:39,850 --> 01:23:41,980
and we are wondering if this is actually legit outcome.

1191
01:23:44,900 --> 01:23:48,440
I don't think this could happen on a single machine,

1192
01:23:48,440 --> 01:23:56,990
because the write for for 2 it finishes, after the restart.

1193
01:23:57,750 --> 01:23:59,850
Oh, sorry, yeah yeah that's right,

1194
01:23:59,940 --> 01:24:03,780
but it seems like the write should happen before the read.

1195
01:24:04,350 --> 01:24:06,960
And in this situation,

1196
01:24:09,130 --> 01:24:12,010
it couldn't happen if the write started after,

1197
01:24:12,580 --> 01:24:16,060
if the write finished after the write restart,

1198
01:24:16,060 --> 01:24:16,540
yeah.

1199
01:24:16,930 --> 01:24:20,950
Yeah, so one would think one way to think about is that,

1200
01:24:21,160 --> 01:24:24,370
we can move you know we have to construct a total order

1201
01:24:24,700 --> 01:24:28,240
and we can construct a total order where all the operations line up,

1202
01:24:28,480 --> 01:24:30,820
then you know it's a valid linearizable history.

1203
01:24:31,290 --> 01:24:33,870
And so, so let's construct a total order

1204
01:24:33,990 --> 01:24:36,150
and then go back to this question you just asked,

1205
01:24:36,840 --> 01:24:40,470
so a total order, here's a total order that I gonna,

1206
01:24:41,240 --> 01:24:43,310
so I'm going to do first the write operation,

1207
01:24:43,520 --> 01:24:47,330
then read x1, then the write x2,

1208
01:24:48,060 --> 01:24:52,160
and then rx read x2, right.

1209
01:24:52,720 --> 01:24:53,620
It's a total order,

1210
01:24:53,620 --> 01:24:56,020
all the operations are now happening sequentially.

1211
01:24:56,660 --> 01:25:00,620
And you know we need to check whether a total order is correct,

1212
01:25:00,980 --> 01:25:03,290
corresponding to the linearizability definitions,

1213
01:25:03,500 --> 01:25:06,080
well, it has to be the case that operations that start,

1214
01:25:06,700 --> 01:25:10,060
if an operation starts after some other operation,

1215
01:25:10,060 --> 01:25:12,280
ends it needs to be after in the total order,

1216
01:25:12,280 --> 01:25:13,840
and so we look at this.

1217
01:25:14,370 --> 01:25:16,140
Let's look at the issue, this one,

1218
01:25:16,740 --> 01:25:19,050
must start after wx1

1219
01:25:19,050 --> 01:25:21,630
and that is true correct, this totally order,

1220
01:25:23,210 --> 01:25:29,170
Rx1 must you start after Wx1,

1221
01:25:29,170 --> 01:25:31,690
because it actually returns you know the value, right,

1222
01:25:31,690 --> 01:25:34,300
then exactly in total order, that is also the case,

1223
01:25:35,360 --> 01:25:38,210
Rx2 you know must start Wx2,

1224
01:25:38,210 --> 01:25:41,760
because it observes the result of this write

1225
01:25:41,790 --> 01:25:43,920
and you know that's perfectly fine too, right,

1226
01:25:44,750 --> 01:25:47,120
we can basically, one way to think about it is that

1227
01:25:47,120 --> 01:25:49,190
you know even though they executed this way,

1228
01:25:49,190 --> 01:25:53,420
we've got to rearrange things to sort of fit the total order.

1229
01:25:54,140 --> 01:25:56,390
And so, if we think about this,

1230
01:25:56,510 --> 01:25:59,540
then this is a totally legit and execution,

1231
01:26:00,140 --> 01:26:02,840
where you know the operation for much of the order

1232
01:26:02,930 --> 01:26:05,360
and so this is like what a single machine would do,

1233
01:26:05,360 --> 01:26:08,810
so a single machine could be executed write Rx1 read x 1,

1234
01:26:08,840 --> 01:26:11,660
write x2, read x2 and real perfectly fine.

1235
01:26:14,390 --> 01:26:14,990
Okay?

1236
01:26:15,710 --> 01:26:19,850
So let me make it helpful to think about history that is not linearizable.

1237
01:26:20,720 --> 01:26:22,340
So let me look at the second one.

1238
01:26:29,360 --> 01:26:32,750
And I'm gonna come back on this on the first day anyway,

1239
01:26:32,750 --> 01:26:35,720
so don't worry if this a lot makes sense yet,

1240
01:26:35,960 --> 01:26:37,160
but here's another one,

1241
01:26:37,520 --> 01:26:39,170
I got C1,

1242
01:26:40,060 --> 01:26:43,240
same thing write x1,

1243
01:26:43,840 --> 01:26:48,670
I got a c and here write x2

1244
01:26:48,670 --> 01:26:56,750
and and there's gonna be a read that actually goes in x1,

1245
01:26:57,730 --> 01:26:59,980
and I'm sorry read x2,

1246
01:27:00,950 --> 01:27:04,100
and then I got C2 C3

1247
01:27:04,670 --> 01:27:12,340
and the C3 start after the other read and returns 1.

1248
01:27:14,610 --> 01:27:16,860
And the client here is that,

1249
01:27:17,310 --> 01:27:22,920
it's not possible to construct a total order you know matches linearizability,

1250
01:27:23,480 --> 01:27:29,930
and, in one way one indication of this is that this read returned x1,

1251
01:27:30,050 --> 01:27:33,110
started after the read that returned 2,

1252
01:27:33,790 --> 01:27:35,890
and I will make this a little bit more precise later,

1253
01:27:35,890 --> 01:27:39,130
but in a real you know single machine system,

1254
01:27:39,160 --> 01:27:40,750
that could have never happened right,

1255
01:27:40,750 --> 01:27:46,150
because that would have meant that the value changed between Rx2 and Rx1

1256
01:27:46,450 --> 01:27:50,830
and and you know with these few operations that we have on the board,

1257
01:27:50,920 --> 01:27:52,270
that has to be the case that,

1258
01:27:53,090 --> 01:27:56,150
this Rx1 what happened after that write,

1259
01:27:57,260 --> 01:28:01,820
and this write must have happened after that write,

1260
01:28:02,090 --> 01:28:07,490
because they're in total, there, we have to respect you know the ordering of the single of C1.

1261
01:28:08,360 --> 01:28:12,950
And so there's no way to basically slot you know Rx1 in the total order

1262
01:28:13,010 --> 01:28:15,410
you know according to this picture,

1263
01:28:15,590 --> 01:28:18,860
it should go after Rx1,

1264
01:28:19,420 --> 01:28:23,230
and but that can really not be true,

1265
01:28:23,560 --> 01:28:26,260
because if it got Rx after Rx1

1266
01:28:26,260 --> 01:28:28,480
that names also after Wx2,

1267
01:28:28,510 --> 01:28:32,590
so that must have write 2 and not 1.

1268
01:28:33,740 --> 01:28:39,580
So this is not a linearizability, not a linearizable history in execution.

1269
01:28:45,820 --> 01:28:47,410
Another way of saying that is that,

1270
01:28:47,590 --> 01:28:53,430
this is what, what is Rxn in returning here, really returning stale value, right,

1271
01:28:53,430 --> 01:28:54,690
and that is not allowed,

1272
01:28:57,940 --> 01:28:59,620
if the machine behaves like a single machine

1273
01:28:59,620 --> 01:29:01,600
or replicated server behaves like a single machine.

1274
01:29:02,520 --> 01:29:04,140
And so I'm gonna go back you know this,

1275
01:29:04,140 --> 01:29:06,660
to on the lecture when next week,

1276
01:29:06,660 --> 01:29:07,890
when we talk about zookeeper,

1277
01:29:08,160 --> 01:29:10,260
because this is going to be very important,

1278
01:29:10,260 --> 01:29:11,730
this notion of linearizability,

1279
01:29:11,730 --> 01:29:14,400
sort of thing that shows up probably in the paper,

1280
01:29:14,550 --> 01:29:17,640
and this notion of stale values also shows up probably.

1281
01:29:19,800 --> 01:29:20,940
And since I'm running out of time

1282
01:29:20,940 --> 01:29:23,370
and you're gonna I'll resume that next week.

1283
01:29:24,540 --> 01:29:25,230
Okay?

1284
01:29:29,260 --> 01:29:30,520
Any further questions

1285
01:29:30,520 --> 01:29:32,920
and people need to leave, please feel free to leave,

1286
01:29:33,040 --> 01:29:34,900
in fact I hope you did,

1287
01:29:35,320 --> 01:29:39,100
I want to make responsible that you miss other classes.

1288
01:29:40,230 --> 01:29:47,430
Is this a consider, like what type of consistency is considered to be strong consistency.

1289
01:29:47,640 --> 01:29:51,630
This considered to be basically strong consistency,

1290
01:29:52,360 --> 01:29:57,280
and what it really is sort of a precise definition of what strong consistency is,

1291
01:29:58,360 --> 01:30:03,040
so like our intuition about what strong consistency is namely behaving like a single machine,

1292
01:30:03,040 --> 01:30:07,300
that the precise definition that people use in the technical literature is linearizability.

1293
01:30:12,420 --> 01:30:17,010
How did they decide to have that property,

1294
01:30:17,010 --> 01:30:19,590
like why did they decide to have that property.

1295
01:30:19,830 --> 01:30:21,270
There's a couple things,

1296
01:30:21,270 --> 01:30:23,940
one reason, the reason,

1297
01:30:23,940 --> 01:30:25,590
okay, so it makes sort of sense,

1298
01:30:25,590 --> 01:30:27,780
you know if you think from this point of view,

1299
01:30:28,730 --> 01:30:35,290
like you want to behave, you want to make a replicated system behave like a single machine or replicated machine

1300
01:30:35,290 --> 01:30:39,970
and you want to only allow outcomes that actually correspond to executions that the single machine could have done,

1301
01:30:40,210 --> 01:30:44,260
the next linearizability are very intuitive definition for that.

1302
01:30:45,020 --> 01:30:49,280
The database world has also some other terminology like serializability,

1303
01:30:49,280 --> 01:30:52,550
this is also a term that will show up in the term later

1304
01:30:52,910 --> 01:30:57,440
and basically the only difference between sort of linearizability and serializability

1305
01:30:57,440 --> 01:31:01,010
is that serializability doesn't require that matches real-time.

1306
01:31:02,980 --> 01:31:06,310
And so people have different definitions of strong consistency,

1307
01:31:06,310 --> 01:31:10,540
if you will and the one that we'll see most probably is linearizability,

1308
01:31:10,540 --> 01:31:15,160
which corresponds closest to like the machine behaves that replicates or behaves like a single machine.

1309
01:31:20,750 --> 01:31:21,590
Thank you.

1310
01:31:21,770 --> 01:31:22,430
You're welcome.

1311
01:31:24,760 --> 01:31:30,860
I have a question about what happens during a network partition,

1312
01:31:31,880 --> 01:31:35,780
so I know like so if a leader gets partitioned completely on their own,

1313
01:31:36,020 --> 01:31:37,340
they'll eventually climb out,

1314
01:31:37,340 --> 01:31:42,350
but if they have sort of like a few followers with them,

1315
01:31:42,380 --> 01:31:43,910
they'll stay the leader,

1316
01:31:44,480 --> 01:31:45,830
and they won't be able to commit anything,

1317
01:31:45,830 --> 01:31:47,030
because they'll be in a minority

1318
01:31:47,450 --> 01:31:48,410
and they'll be a new leader

1319
01:31:48,410 --> 01:31:48,890
and they'll be,

1320
01:31:48,980 --> 01:31:55,420
so will that leader ever sort of recognize that maybe it's a stale leader

1321
01:31:55,630 --> 01:31:59,620
or do we just assume that eventually if the partition goes away,

1322
01:32:01,820 --> 01:32:02,810
it'll figure out,

1323
01:32:02,810 --> 01:32:05,600
because I'm worried if there's a client that's talking to the stale leader,

1324
01:32:06,320 --> 01:32:07,550
what does that client do.

1325
01:32:09,450 --> 01:32:11,430
The no,

1326
01:32:11,430 --> 01:32:14,040
okay so this is a great question with this picture here,

1327
01:32:14,040 --> 01:32:14,940
hopefully it will help,

1328
01:32:15,560 --> 01:32:19,010
so the client talks to talk to this guy, correct,

1329
01:32:19,010 --> 01:32:19,970
like who's the leader,

1330
01:32:20,640 --> 01:32:21,480
you see the picture,

1331
01:32:21,510 --> 01:32:23,010
I just double check, you can see.

1332
01:32:23,010 --> 01:32:24,270
I can see it.

1333
01:32:24,360 --> 01:32:26,670
So let's say you know this first box is the leader,

1334
01:32:26,790 --> 01:32:28,110
client talks to that leader,

1335
01:32:28,320 --> 01:32:30,840
the leader can't commit any operations, right,

1336
01:32:31,690 --> 01:32:34,810
and so it will commit anything on the apply channel

1337
01:32:34,810 --> 01:32:37,210
and so it will never respond to the client, right,

1338
01:32:37,540 --> 01:32:40,960
because there's no operation actually its operations are not being executed,

1339
01:32:41,660 --> 01:32:44,780
so the client will just retry, just keep retrying forever,

1340
01:32:46,230 --> 01:32:54,700
until you know until the client actually maybe tries another, you know, one of the other followers, correct,

1341
01:32:54,700 --> 01:32:58,540
that maintains you know who else is actually in the group,

1342
01:32:58,880 --> 01:33:03,320
or until the network heals,

1343
01:33:04,660 --> 01:33:06,790
and the leader actually commit an operation.

1344
01:33:06,970 --> 01:33:10,540
Gotcha, wait, so doesn't doesn't the leader immediately reply those,

1345
01:33:10,540 --> 01:33:14,240
saying I got your request or does it wait until committed.

1346
01:33:14,870 --> 01:33:20,030
No in lab 3, it doesn't know commit with a client until who actually has processed the request,

1347
01:33:20,640 --> 01:33:23,850
and which means that the operation actually has run through raft

1348
01:33:23,850 --> 01:33:25,260
and come out of the applied channel

1349
01:33:25,260 --> 01:33:26,940
and ask executed by the servers.

1350
01:33:27,630 --> 01:33:28,290
Okay.

1351
01:33:33,330 --> 01:33:33,750
Does that makes sense.

1352
01:33:33,750 --> 01:33:36,450
Yeah, so the client could just implement a timeout,

1353
01:33:36,450 --> 01:33:39,930
where like if a certain amount of time and they haven't received the commit,

1354
01:33:40,020 --> 01:33:42,420
assume that maybe I should try a different node,

1355
01:33:42,600 --> 01:33:46,020
and then if it gets the new leader or follower of the new leader,

1356
01:33:46,200 --> 01:33:48,570
it'll be back to normal.

1357
01:33:48,570 --> 01:33:52,260
For example, this clerk that's exactly what this clerk does,

1358
01:33:52,780 --> 01:33:56,470
you know the place along with the servers to actually do what you just said.

1359
01:33:56,950 --> 01:34:00,460
Got it, okay, thank you.

1360
01:34:01,070 --> 01:34:01,580
You're welcome.

1361
01:34:02,410 --> 01:34:04,480
Sorry, can you repeat again, what the clerk does.

1362
01:34:05,640 --> 01:34:08,070
The clerk is a little bit of a stub,

1363
01:34:08,070 --> 01:34:10,050
where like a little library,

1364
01:34:10,050 --> 01:34:11,130
that the client links with,

1365
01:34:11,400 --> 01:34:12,840
and the client calls puts and gets

1366
01:34:13,170 --> 01:34:16,410
and the clerk actually is the interface that it talks to

1367
01:34:16,410 --> 01:34:18,090
and the clerk can keep some information,

1368
01:34:18,630 --> 01:34:22,410
like who's part of the raft cluster

1369
01:34:22,560 --> 01:34:25,170
and so we're only who's the leader and who are the followers,

1370
01:34:25,170 --> 01:34:27,360
at least what it thinks is the leader and the followers,

1371
01:34:28,210 --> 01:34:33,400
and when it sends in rpc you know to the service is not sensitive to the leader,

1372
01:34:33,400 --> 01:34:34,720
what it thinks is the current leader,

1373
01:34:35,580 --> 01:34:38,790
and the servers in the, whatever thinks the current leader,

1374
01:34:38,790 --> 01:34:40,080
the leader might actually respond saying,

1375
01:34:40,080 --> 01:34:42,300
like hey I'm not the leader, should send somewhere else,

1376
01:34:42,910 --> 01:34:46,060
and then it will try one of the others and updates its information.

1377
01:34:46,640 --> 01:34:51,230
And also we'll tag every put and get operation,

1378
01:34:51,230 --> 01:34:52,550
that it receives from the client

1379
01:34:52,550 --> 01:34:54,710
and that sends to the server with a unique id,

1380
01:34:55,130 --> 01:34:58,430
so that the service can do duplicate detection.x

1381
01:34:59,460 --> 01:35:00,900
And this all comes up in lab 3,

1382
01:35:00,900 --> 01:35:03,690
so you know you'll see there,

1383
01:35:04,690 --> 01:35:06,520
in lab 2, there's no real clerk,

1384
01:35:07,070 --> 01:35:10,820
because the tester basically sort of sits on top of the directly of the raft interface

1385
01:35:10,820 --> 01:35:13,130
and doesn't really interact through the clerk,

1386
01:35:13,130 --> 01:35:15,200
but in lab 3 will interact through the clerk.

1387
01:35:16,320 --> 01:35:19,470
So how do the clients generate unique ids,

1388
01:35:20,100 --> 01:35:21,930
I think they conflict with each other.

1389
01:35:22,050 --> 01:35:24,000
Random, big random numbers.

1390
01:35:25,660 --> 01:35:27,520
Alright, so we're just guessing and hoping,

1391
01:35:27,550 --> 01:35:31,090
rather than actually guaranteeing some sort of like incremental.

1392
01:35:31,300 --> 01:35:33,130
One way to make it more guaranteed,

1393
01:35:33,130 --> 01:35:37,030
for example, take your IP address and append a random number.

1394
01:35:41,070 --> 01:35:43,440
A question about the homework question.

1395
01:35:43,560 --> 01:35:43,980
Yeah.

1396
01:35:44,250 --> 01:35:46,530
So I thought that it could go backwards in time,

1397
01:35:46,530 --> 01:35:47,700
like I read the paper

1398
01:35:47,700 --> 01:35:51,420
and it says on page 12 [],

1399
01:35:51,420 --> 01:35:54,300
it said that if there's a conflict, right,

1400
01:35:54,300 --> 01:35:56,880
then the follower just discards its entire log

1401
01:35:56,880 --> 01:35:58,920
and it's also preceded by the snapshot,

1402
01:36:00,110 --> 01:36:02,210
so I wonder why.

1403
01:36:02,330 --> 01:36:06,290
Again, let me, let me guess,

1404
01:36:06,290 --> 01:36:08,450
I I don't really know exactly this is,

1405
01:36:08,450 --> 01:36:09,170
what you're referring to,

1406
01:36:09,170 --> 01:36:10,160
I have to look it up again.

1407
01:36:10,460 --> 01:36:12,320
Oh, it's on page 12,

1408
01:36:12,320 --> 01:36:16,040
it's at the it's towards the end of page 12 the second column here,

1409
01:36:16,040 --> 01:36:17,750
so the second to last paragraph.

1410
01:36:18,230 --> 01:36:21,290
So the log can go back, right, but not the state machine.

1411
01:36:21,500 --> 01:36:25,340
Not, oh, the log can't, the log can go back, but not the state machine,

1412
01:36:25,460 --> 01:36:28,910
what was the state machine, like what you the committed entries, right.

1413
01:36:30,320 --> 01:36:32,690
Yeah, the yes, the log can't go back,

1414
01:36:32,690 --> 01:36:36,140
because of the uncommitted entries we can go back,

1415
01:36:36,140 --> 01:36:38,630
this is like this whole erase stuff that we talked about earlier.

1416
01:36:40,560 --> 01:36:45,180
Okay, so actually the log can go back, not the state machine,

1417
01:36:45,180 --> 01:36:48,150
which is basically what you committed already.

1418
01:36:48,390 --> 01:36:50,280
Yeah and the log can never go,

1419
01:36:50,280 --> 01:36:53,700
will never go back, never bailout of committed operations, correct,

1420
01:36:53,700 --> 01:36:56,760
it can only bailout erased uncommitted operations.

1421
01:36:56,790 --> 01:36:59,490
Yes, that's right, okay.

1422
01:36:59,580 --> 01:37:00,930
So that's what you ask question.

1423
01:37:01,620 --> 01:37:04,200
Can I ask a question about the third slide.

1424
01:37:04,380 --> 01:37:04,860
Yeah.

1425
01:37:04,860 --> 01:37:06,660
The one right before this one,

1426
01:37:08,050 --> 01:37:12,100
so could you just walk me through real quick,

1427
01:37:12,100 --> 01:37:14,830
what match index is doing on the write,

1428
01:37:14,860 --> 01:37:17,320
like when S2 is communicating with S3.

1429
01:37:17,960 --> 01:37:18,320
Okay.

1430
01:37:18,350 --> 01:37:20,990
So it starts out as 0.

1431
01:37:21,230 --> 01:37:24,290
Yep, so S2 is communicating with who.

1432
01:37:24,970 --> 01:37:25,720
S3.

1433
01:37:25,930 --> 01:37:27,040
Yeah, so basically okay,

1434
01:37:27,040 --> 01:37:30,160
so here match index is 0 right,

1435
01:37:30,160 --> 01:37:32,470
like so and when you write it down is 0.

1436
01:37:33,350 --> 01:37:33,980
Yeah.

1437
01:37:34,460 --> 01:37:36,020
Okay, then you get to know back,

1438
01:37:36,020 --> 01:37:37,700
so match index stays 0, right.

1439
01:37:38,940 --> 01:37:39,510
Okay.

1440
01:37:40,280 --> 01:37:42,470
Nothing there, but now it's an okay back,

1441
01:37:42,470 --> 01:37:43,520
so what does that imply,

1442
01:37:45,800 --> 01:37:52,700
that implies that you know what did it send that send heartbeat correct with for index 13,

1443
01:37:53,290 --> 01:38:02,390
and including and the S3 responded okay

1444
01:38:02,780 --> 01:38:07,340
and so it means that basically S3 is up to date through until 13, correct,

1445
01:38:07,340 --> 01:38:10,670
that is next index that it actually has and expects 14.

1446
01:38:11,500 --> 01:38:18,520
And so the S2 knows now that it's log matches until 13 after this message.

1447
01:38:19,880 --> 01:38:21,920
Is it until 13 or until 12.

1448
01:38:22,370 --> 01:38:24,410
It matches till 13,

1449
01:38:24,410 --> 01:38:28,040
so the next thing that will be sent will be going index 13.

1450
01:38:28,940 --> 01:38:33,110
So, so the next index and match index are going to be 13.

1451
01:38:33,200 --> 01:38:35,120
Yeah, the next index is not used yet, right,

1452
01:38:35,120 --> 01:38:35,780
means empty.

1453
01:38:37,290 --> 01:38:37,980
Okay.

1454
01:38:38,560 --> 01:38:40,450
Yeah, so basically the the way you know

1455
01:38:40,450 --> 01:38:43,330
they they you can do either way correct,

1456
01:38:43,330 --> 01:38:46,450
you can either save the last one or you know first that's gonna be,

1457
01:38:46,630 --> 01:38:49,030
for the first next to you know one,

1458
01:38:49,030 --> 01:38:51,430
in this case they go by the first next one.

1459
01:38:53,410 --> 01:38:57,400
So in this case, both of them are 13 for the next one.

1460
01:38:57,610 --> 01:39:00,100
Yeah, so basically you can think about this,

1461
01:39:00,100 --> 01:39:03,100
this stage before, like all the green stuff has happened,

1462
01:39:03,490 --> 01:39:14,740
the match index for 3 is 13,

1463
01:39:15,300 --> 01:39:22,030
and the match index for itself 2 is also 13.

1464
01:39:24,280 --> 01:39:28,860
Got it, awesome, thank you.

1465
01:39:28,950 --> 01:39:29,490
You're welcome.

1466
01:39:31,840 --> 01:39:34,780
Actually, can I ask a follow-up from that,

1467
01:39:34,960 --> 01:39:39,610
so when it sees something matches,

1468
01:39:39,820 --> 01:39:43,510
for example here on position 11,

1469
01:39:43,660 --> 01:39:45,160
it saw that matches,

1470
01:39:45,220 --> 01:39:51,290
then it is guarantee that everything before that matches too.

1471
01:39:51,680 --> 01:39:55,340
Yes, right, because, hold on let me double check you're talking about this message.

1472
01:39:56,920 --> 01:39:59,920
Yeah, about like when it says okay if you check.

1473
01:40:00,160 --> 01:40:08,290
Yeah, yeah, because that is the whole reason that the previous term or previous index or communicated correct to the follower,

1474
01:40:08,650 --> 01:40:11,860
to make double check that it can only respond to okay,

1475
01:40:12,040 --> 01:40:16,900
if indeed is the case that in the previous index 11 actually turn free,

1476
01:40:18,200 --> 01:40:19,040
and if that's true,

1477
01:40:19,040 --> 01:40:21,440
that means that basically everything before that must match

1478
01:40:21,560 --> 01:40:22,400
and this is like this,

1479
01:40:22,400 --> 01:40:26,540
whatever their whatever their statement they call,

1480
01:40:28,100 --> 01:40:30,200
this invariant initially maintained that,

1481
01:40:30,200 --> 01:40:32,330
like if something matches at like one index,

1482
01:40:32,330 --> 01:40:34,550
then everything before that match too.

1483
01:40:36,320 --> 01:40:38,330
Oh, okay, okay, this is [] to me.

1484
01:40:40,530 --> 01:40:44,730
Oh, and I had another follow-up question was related to the question,

1485
01:40:44,730 --> 01:40:48,180
on the lecture question that I wrote,

1486
01:40:48,450 --> 01:40:53,160
I asked about the copy-on-write for snapshots,

1487
01:40:53,250 --> 01:40:57,000
I think I don't really understand what is being copied,

1488
01:40:57,000 --> 01:41:00,480
is it, is it the page tables or is it something.

1489
01:41:00,480 --> 01:41:03,900
I think I responded to your email.

1490
01:41:04,110 --> 01:41:06,210
Yeah, I got email, but.

1491
01:41:06,750 --> 01:41:11,370
Okay, okay, okay, hold on a second,

1492
01:41:11,850 --> 01:41:14,970
[], the,

1493
01:41:15,670 --> 01:41:21,820
so okay, the scenario is snapshot can be expensive,

1494
01:41:21,850 --> 01:41:25,090
because snapchat might be large gigabytes,

1495
01:41:25,090 --> 01:41:32,740
you know key-value page table, sorry, [] it was a gigabyte key-value store,

1496
01:41:33,290 --> 01:41:36,860
then you know you need to write that gigabyte to disk, right,

1497
01:41:37,710 --> 01:41:39,330
and while you're writing into disk,

1498
01:41:39,540 --> 01:41:41,130
if you don't do anything clever,

1499
01:41:41,310 --> 01:41:44,040
you cannot process any other put and get operations,

1500
01:41:44,370 --> 01:41:48,270
that come in through the channels,

1501
01:41:48,270 --> 01:41:51,420
let me actually popup this picture.

1502
01:41:52,010 --> 01:41:55,880
Great, so basically servers decides at some point to take a checkpoint to gigabyte,

1503
01:41:55,880 --> 01:41:57,260
you have to write a gigabyte to disk,

1504
01:41:57,260 --> 01:41:57,920
that's expensive.

1505
01:41:58,510 --> 01:42:02,770
So the plan you know I think the plan that the papers hinting at,

1506
01:42:03,340 --> 01:42:05,620
is that what the service does,

1507
01:42:06,320 --> 01:42:07,940
it you know calls fork,

1508
01:42:10,880 --> 01:42:14,060
so when it wants to make a checkpoint, it calls fork,

1509
01:42:15,080 --> 01:42:17,570
and fork case a copy of that process, right,

1510
01:42:17,570 --> 01:42:20,210
now we have the operating system running,

1511
01:42:21,070 --> 01:42:23,770
and we have now basically two processes,

1512
01:42:24,100 --> 01:42:29,680
that correspond to this application servers raft, service raft,

1513
01:42:30,930 --> 01:42:33,420
and this is the copy, the child,

1514
01:42:34,520 --> 01:42:36,590
the operating system uses copy-on-write,

1515
01:42:38,040 --> 01:42:40,230
so when it made a copy of that second process,

1516
01:42:40,680 --> 01:42:43,890
and just copy the page table, didn't copy physical memory,

1517
01:42:45,220 --> 01:42:48,730
so basically these two processes share the same physical memory,

1518
01:42:52,420 --> 01:42:55,270
which holds you know the our key-value store, right.

1519
01:42:56,540 --> 01:42:58,760
And so now the idea is that,

1520
01:42:58,760 --> 01:43:00,260
the child when it starts running,

1521
01:43:00,350 --> 01:43:03,770
it starts making a checkpoint or snapshot,

1522
01:43:03,980 --> 01:43:06,770
I can just write out you know the key-value sort of,

1523
01:43:07,880 --> 01:43:10,070
the key-value store to disk.

1524
01:43:11,430 --> 01:43:18,880
And in parallel, you know the parent can you start processing new you know get and put operations,

1525
01:43:21,860 --> 01:43:23,630
because if it does put operation,

1526
01:43:24,220 --> 01:43:25,180
and it wants to modify,

1527
01:43:25,180 --> 01:43:31,620
it will write you know to pages that correspond to the key-value store,

1528
01:43:31,650 --> 01:43:33,270
that will result in a page fault, right,

1529
01:43:33,270 --> 01:43:34,950
and so the OS will get a page fault

1530
01:43:34,950 --> 01:43:38,820
and so the OS will copy that page at that point

1531
01:43:39,060 --> 01:43:42,330
and then you know the first pair process can updated,

1532
01:43:42,960 --> 01:43:44,790
this is all transparent to the child,

1533
01:43:44,820 --> 01:43:48,660
which the child had a consistent snapshot of the whole address space

1534
01:43:48,660 --> 01:43:49,620
at the point of the fork.

1535
01:43:50,790 --> 01:43:54,060
So, this allows basically the parent and child run concurrently

1536
01:43:54,060 --> 01:43:56,310
still make a consistent snapshot

1537
01:43:56,580 --> 01:44:00,150
and the parents actually make process new put and get operations.

1538
01:44:02,340 --> 01:44:03,870
Is that more clear, okay?

1539
01:44:03,870 --> 01:44:05,040
Oh, yeah, okay I see,

1540
01:44:05,040 --> 01:44:10,890
so the copy-on-write the memory that holds the key-value store,

1541
01:44:11,730 --> 01:44:13,440
okay, okay, okay I see,

1542
01:44:13,440 --> 01:44:14,910
yeah, this makes it very clear,

1543
01:44:14,910 --> 01:44:15,870
thank you so much.

1544
01:44:16,170 --> 01:44:16,800
You're welcome.

1545
01:44:20,920 --> 01:44:21,790
Any more questions?

1546
01:44:23,750 --> 01:44:25,850
Yeah, I have a,

1547
01:44:25,880 --> 01:44:29,000
I guess this is sort of a weird scenario,

1548
01:44:29,000 --> 01:44:30,230
I'm not sure if this could actually,

1549
01:44:31,390 --> 01:44:32,680
but what if,

1550
01:44:32,740 --> 01:44:35,140
so imagine that we're always in the same term,

1551
01:44:35,720 --> 01:44:41,420
and then you get to a point where some nodes have disconnected,

1552
01:44:41,420 --> 01:44:42,770
but they're still the same term,

1553
01:44:42,860 --> 01:44:44,360
the leader is still in the same term

1554
01:44:44,510 --> 01:44:49,870
and then at some point they will, they will do a snapshot

1555
01:44:50,230 --> 01:44:52,540
and then all the logs will be compressed,

1556
01:44:53,120 --> 01:44:54,620
and then they keep going forward

1557
01:44:54,620 --> 01:44:57,350
and now the logs are being populated again

1558
01:44:57,350 --> 01:45:01,980
and then, let's just say 15 logs have been added,

1559
01:45:02,280 --> 01:45:05,760
and then after 10, they compress them

1560
01:45:06,030 --> 01:45:08,670
and then they are at index index 5 again

1561
01:45:08,670 --> 01:45:10,830
and then the other nodes joined back in

1562
01:45:11,010 --> 01:45:13,170
and they're also at index 5 of the same term.

1563
01:45:14,870 --> 01:45:16,280
Is that a problem,

1564
01:45:16,280 --> 01:45:17,510
like how, how does,

1565
01:45:18,500 --> 01:45:22,670
it's almost like they're on a snapshot epoch of some sort.

1566
01:45:23,350 --> 01:45:26,770
Okay, so old snapshots correspond to an index, right, so.

1567
01:45:26,860 --> 01:45:27,250
Yeah.

1568
01:45:27,460 --> 01:45:30,970
So okay, let's draw out like maybe draw your scenario,

1569
01:45:30,970 --> 01:45:34,180
so we got a server gonna have some log,

1570
01:45:35,780 --> 01:45:38,480
and you know maybe I think you know you talk about 10

1571
01:45:38,780 --> 01:45:40,370
and it took a snapshot at 10.

1572
01:45:41,380 --> 01:45:42,160
Yeah.

1573
01:45:43,080 --> 01:45:44,820
Yeah, so let's say, let's say that basically,

1574
01:45:44,820 --> 01:45:49,860
yeah so basically the first 9 operations are maybe including 10 are in the snapshot.

1575
01:45:52,490 --> 01:45:58,600
And then okay, so there's another node is same term,

1576
01:45:59,220 --> 01:46:01,320
so all these entries have the same term, right,

1577
01:46:01,320 --> 01:46:06,350
whatever, you know 1 1 1 1 1 1 1 1 1.

1578
01:46:06,380 --> 01:46:07,340
Yep.

1579
01:46:07,840 --> 01:46:10,960
And, so this node actually,

1580
01:46:10,960 --> 01:46:14,080
but this node has only through 10, then this guy through 15,

1581
01:46:14,770 --> 01:46:15,490
let's see,

1582
01:46:16,380 --> 01:46:17,340
I think that's what you're saying,

1583
01:46:17,340 --> 01:46:19,650
here's 1, here's 1.

1584
01:46:24,430 --> 01:46:27,940
Well, I think my my thought is,

1585
01:46:28,000 --> 01:46:29,800
well here's here's a question I can answer,

1586
01:46:29,950 --> 01:46:33,640
when you take a snapshot do you reset your index or do you keep counting? You keep counting.

1587
01:46:35,280 --> 01:46:36,330
Oh, okay,

1588
01:46:37,050 --> 01:46:38,700
I was imagining it was like an array,

1589
01:46:39,030 --> 01:46:41,670
and you saw your index goes backwards,

1590
01:46:42,180 --> 01:46:48,690
so that it would be possible for you to have two different entries in the same term with the same index.

1591
01:46:48,690 --> 01:46:50,580
Yeah, that's not allowed.

1592
01:46:50,580 --> 01:46:52,920
Right yeah, okay, I I see.

1593
01:46:53,540 --> 01:46:56,810
So, okay, okay, that makes sense.

1594
01:46:56,810 --> 01:46:58,790
When you remember reset the index.

1595
01:46:58,820 --> 01:47:01,190
When you cut like this part of the log,

1596
01:47:01,580 --> 01:47:03,020
in the index stays at 10.

1597
01:47:03,700 --> 01:47:04,660
Got it, got it.

1598
01:47:04,960 --> 01:47:07,120
And so in fact when you do this in 2d,

1599
01:47:07,120 --> 01:47:08,620
this is gonna be slightly annoying,

1600
01:47:09,100 --> 01:47:13,360
because you presumably take advantage in fact the start of log is 0

1601
01:47:13,690 --> 01:47:15,340
and what you're now going to get is that

1602
01:47:15,340 --> 01:47:17,620
the start of the layer of 0 might be 10,

1603
01:47:18,430 --> 01:47:21,370
people have to.

1604
01:47:21,370 --> 01:47:22,690
You have an offset of some sort.

1605
01:47:22,780 --> 01:47:25,870
Yeah, you have to add that offset everywhere.

1606
01:47:26,550 --> 01:47:29,010
Yeah, and then and then last thing really quickly,

1607
01:47:29,010 --> 01:47:35,790
I think the reason I was confused earlier was in the in the code for lab 2.

1608
01:47:35,940 --> 01:47:36,240
Yeah.

1609
01:47:36,240 --> 01:47:37,590
There's a comment that says,

1610
01:47:37,590 --> 01:47:41,500
we're supposed to return immediately from start.

1611
01:47:41,830 --> 01:47:44,170
Yeah yeah, well you, oh yes.

1612
01:47:45,240 --> 01:47:48,600
I mean, okay, so let me go back to this picture here.

1613
01:47:49,310 --> 01:47:51,710
Yeah, hopefully, it's getting really crowded,

1614
01:47:53,510 --> 01:47:55,610
so we get an operation correct

1615
01:47:55,610 --> 01:47:58,250
and we do the start operation, we call start.

1616
01:47:59,480 --> 01:48:02,930
Oh, return immediately doesn't necessarily mean reply, is that.

1617
01:48:02,930 --> 01:48:05,270
Yeah, exactly,

1618
01:48:05,270 --> 01:48:07,880
it just means reply back to return to the servers,

1619
01:48:07,910 --> 01:48:08,810
not to the client.

1620
01:48:10,450 --> 01:48:14,650
I see, I see, okay, totcha,

1621
01:48:14,680 --> 01:48:20,080
yeah, I guess operating under the assumption that return always is necessarily reply,

1622
01:48:20,110 --> 01:48:21,850
but that's not that's not always the case.

1623
01:48:21,850 --> 01:48:22,840
No, that's not the case,

1624
01:48:22,840 --> 01:48:26,470
I think this will become more clear in lap 3 than they you know lab 2,

1625
01:48:26,800 --> 01:48:30,130
lab 2 living wired, no application.

1626
01:48:31,100 --> 01:48:34,670
Yeah, okay, well, thank you,

1627
01:48:34,700 --> 01:48:35,990
this was really helpful.

1628
01:48:35,990 --> 01:48:37,310
You re welcome.

1629
01:48:37,310 --> 01:48:37,940
Appreciate it.

1630
01:48:40,120 --> 01:48:41,140
Have a rest.

1631
01:48:41,140 --> 01:48:41,560
You too.

1632
01:48:42,040 --> 01:48:42,370
Bye.

1633
01:48:42,550 --> 01:48:43,420
Good luck for the lab.

