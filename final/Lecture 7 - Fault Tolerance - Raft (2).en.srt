1
00:00:06,030 --> 00:00:07,350
Okay, good afternoon,

2
00:00:08,470 --> 00:00:11,080
sound check sound checking,

3
00:00:12,790 --> 00:00:13,690
people can hear me?

4
00:00:16,760 --> 00:00:18,170
Yeah.

5
00:00:18,230 --> 00:00:18,920
Thank you,

6
00:00:19,460 --> 00:00:20,150
okay, good,

7
00:00:20,150 --> 00:00:23,240
so good afternoon, good evening, good morning, good night, wherever you are,

8
00:00:23,570 --> 00:00:25,970
I'm going to talk today more about raft

9
00:00:27,110 --> 00:00:30,560
and we want to cover following different topics,

10
00:00:30,860 --> 00:00:34,100
which are going to be relevant to labs.

11
00:00:34,790 --> 00:00:38,180
So, first of all, I want to talk a little bit more about log divergence,

12
00:00:39,120 --> 00:00:42,300
we sort of had a cliffhanger at the end of last lecture,

13
00:00:42,330 --> 00:00:44,160
where we got in a discussion that figure 6,

14
00:00:44,160 --> 00:00:46,080
I want to resume that discussion.

15
00:00:46,710 --> 00:00:50,250
I want to talk about log catch up and what happens,

16
00:00:50,280 --> 00:00:54,350
if how do followers catch up,

17
00:00:54,980 --> 00:01:00,170
then a little bit of a persistence, like what state must be,

18
00:01:01,240 --> 00:01:03,700
what's raft state must be persistent in storage,

19
00:01:03,700 --> 00:01:07,720
which is really relevant for 2c and 2d,

20
00:01:07,720 --> 00:01:11,800
and also talk about state out to snapshots.

21
00:01:13,580 --> 00:01:16,860
Yeah, if there's any questions, please feel free to ask.

22
00:01:17,940 --> 00:01:19,770
And then finally I want to talk about linearizability

23
00:01:19,770 --> 00:01:24,870
and correct criterion that comes up quite often in the paper,

24
00:01:24,870 --> 00:01:26,700
used also in a bunch of places,

25
00:01:27,300 --> 00:01:29,520
and this will allow us to talk a little bit again

26
00:01:29,520 --> 00:01:31,650
about how does those servers use raft.

27
00:01:32,490 --> 00:01:35,910
So, those are the topics we plan to talk about,

28
00:01:36,000 --> 00:01:38,970
you have any questions right now, please feel free to ask,

29
00:01:39,520 --> 00:01:41,770
and of course always jump in at any point.

30
00:01:47,470 --> 00:01:51,010
Okay, so, so we saw it last week,

31
00:01:51,010 --> 00:01:52,330
we started talking about raft,

32
00:01:52,330 --> 00:01:54,550
you know we saw that the leader has served this job

33
00:01:54,550 --> 00:01:59,080
of replicating its log onto the onto followers,

34
00:01:59,440 --> 00:02:03,700
and but you know due to crashes in leader election,

35
00:02:03,880 --> 00:02:05,440
the state of the system,

36
00:02:05,440 --> 00:02:08,950
you know the logs can actually quite, can diverse quite quite a bit,

37
00:02:11,280 --> 00:02:14,130
and figure 6 is an illustration,

38
00:02:14,760 --> 00:02:18,090
you know why, how, how that could happen,

39
00:02:18,090 --> 00:02:20,370
you know the leaders can go down,

40
00:02:20,370 --> 00:02:21,810
they may append some more entries,

41
00:02:21,810 --> 00:02:24,090
and so there's a whole bunch of different scenarios,

42
00:02:24,420 --> 00:02:27,720
that our system can end up in,

43
00:02:27,720 --> 00:02:32,160
and so the figure 6, figure 7 actually shows a bunch of those,

44
00:02:32,280 --> 00:02:38,020
and the, and the main reason for the figure is that,

45
00:02:38,020 --> 00:02:42,010
it actually sharpens up the leader election rule,

46
00:02:49,940 --> 00:02:51,710
so once the leader goes down,

47
00:02:51,710 --> 00:02:54,110
and we need to elect a new leader,

48
00:02:54,110 --> 00:02:57,530
there's actually some restrictions that must be applied

49
00:02:57,770 --> 00:03:03,380
to actually make sure that we can get converged on the right log in the end.

50
00:03:04,040 --> 00:03:05,030
And so, first of all,

51
00:03:05,060 --> 00:03:06,200
one part of that is,

52
00:03:06,200 --> 00:03:09,280
that any leader need to achieve a majority,

53
00:03:10,620 --> 00:03:12,390
and this is a part of the idea,

54
00:03:12,390 --> 00:03:17,280
to actually avoid [] brain split syndrome or split brain syndrome,

55
00:03:17,310 --> 00:03:19,230
sort of we can actually make sure that,

56
00:03:19,230 --> 00:03:22,140
you know in any two subsequent elections,

57
00:03:22,380 --> 00:03:24,090
there's going to be at least one node,

58
00:03:24,150 --> 00:03:28,350
that participated in both majorities,

59
00:03:28,350 --> 00:03:31,680
because you can only two majority must overlap

60
00:03:31,710 --> 00:03:33,840
and that node must actually have

61
00:03:33,870 --> 00:03:37,680
you know operations from the recent, from the recent term.

62
00:03:38,520 --> 00:03:39,570
The majority is important,

63
00:03:39,630 --> 00:03:42,210
but turns out it's actually a little bit more subtle,

64
00:03:42,600 --> 00:03:45,000
you might think that,

65
00:03:45,000 --> 00:03:47,400
like the longest log that should be sufficient,

66
00:03:47,400 --> 00:03:50,040
because the longest log has most information,

67
00:03:50,040 --> 00:03:52,320
so we're just picked that as the next leader,

68
00:03:52,320 --> 00:03:53,640
and then we're in good shape.

69
00:03:53,880 --> 00:03:55,950
And that turns out to be not the case,

70
00:03:56,300 --> 00:04:02,420
and and so, and leader rules a little bit more subtle,

71
00:04:02,420 --> 00:04:07,130
you know actually majority plus at least as up to date,

72
00:04:07,130 --> 00:04:11,250
at-least up-to-date.

73
00:04:15,430 --> 00:04:19,390
So, so to you know the leader election is running,

74
00:04:19,600 --> 00:04:22,420
the follower,

75
00:04:22,420 --> 00:04:24,790
so the candidate is starting to run leader election

76
00:04:24,790 --> 00:04:26,830
approaches bunch of followers,

77
00:04:27,190 --> 00:04:32,110
and the followers response with a positive vote,

78
00:04:32,110 --> 00:04:36,700
if the candidate actually is at least up to date as they are.

79
00:04:37,480 --> 00:04:38,860
And what that means is that,

80
00:04:38,950 --> 00:04:43,900
the last log entry must actually have the same term

81
00:04:44,110 --> 00:04:47,920
or in if they actually have the same term,

82
00:04:47,950 --> 00:04:50,590
the longest one sort of wins.

83
00:04:51,680 --> 00:04:55,520
And so, so that the leader the election rule

84
00:04:55,520 --> 00:04:58,070
you know we look at this problem last week

85
00:04:58,100 --> 00:04:59,420
as part of the homework,

86
00:04:59,420 --> 00:05:00,350
and what happens,

87
00:05:00,350 --> 00:05:02,450
if you know this node

88
00:05:02,450 --> 00:05:06,080
you know what's worse about the leader actually is dead,

89
00:05:06,080 --> 00:05:06,890
it's gone,

90
00:05:07,070 --> 00:05:08,810
you know and who could become leaders,

91
00:05:09,590 --> 00:05:11,570
and you know quickly discovered that,

92
00:05:11,600 --> 00:05:14,720
you know there there's a bunch of them that cannot become leader,

93
00:05:14,720 --> 00:05:17,030
but then there's potentially a number of scenarios

94
00:05:17,030 --> 00:05:18,890
in which some can become leaders.

95
00:05:19,430 --> 00:05:20,780
And so, in particular,

96
00:05:20,780 --> 00:05:23,150
you know we identify that a can become leader,

97
00:05:23,420 --> 00:05:25,550
c can become leader,

98
00:05:25,610 --> 00:05:26,840
and d can became leader.

99
00:05:28,700 --> 00:05:30,890
And so then,

100
00:05:30,890 --> 00:05:34,280
and so there's probably the most important part of this whole discussion, right,

101
00:05:34,280 --> 00:05:35,510
who can become leader.

102
00:05:35,540 --> 00:05:37,010
[] there's question.

103
00:05:37,310 --> 00:05:39,680
There, let me hold on.

104
00:05:43,110 --> 00:05:43,620
Okay.

105
00:05:44,160 --> 00:05:46,320
So who becomes that's the most important part,

106
00:05:46,320 --> 00:05:49,740
so there's a bunch of different scenarios, in which a can become a leader,

107
00:05:49,770 --> 00:05:51,600
there's a scenario, where c become a leader,

108
00:05:51,600 --> 00:05:53,430
in the scenario where d become a leader.

109
00:05:54,580 --> 00:05:56,170
Then the discussion focus a little bit,

110
00:05:56,170 --> 00:05:59,410
like well at least there's one particular scenario,

111
00:05:59,410 --> 00:06:00,880
in which one of these becomes leader,

112
00:06:00,940 --> 00:06:03,940
others, multiple scenarios in which take over the leader,

113
00:06:03,940 --> 00:06:07,090
particularly focus this discussion focused on a,

114
00:06:09,060 --> 00:06:12,600
because like one way that a can become a leader is,

115
00:06:12,600 --> 00:06:17,240
when c and d are down,

116
00:06:21,540 --> 00:06:23,790
right, because c and d are down,

117
00:06:24,060 --> 00:06:28,020
a will talk to b e and f

118
00:06:28,020 --> 00:06:30,930
form a majority with 4,

119
00:06:31,230 --> 00:06:34,650
it has the most up to date log,

120
00:06:34,650 --> 00:06:37,860
notice that you know even though f is a longer log,

121
00:06:38,190 --> 00:06:40,890
that actually is not the most up to date one,

122
00:06:41,100 --> 00:06:44,040
so a actual succeed in becoming the leader,

123
00:06:44,590 --> 00:06:46,090
and then things proceed from there.

124
00:06:47,170 --> 00:06:49,450
But there was an interesting question that came up is,

125
00:06:49,450 --> 00:06:52,960
are other scenarios in which a can become a leader in particular,

126
00:06:52,990 --> 00:06:56,440
or is there scenario where even if c and d are up,

127
00:06:59,270 --> 00:07:01,430
or reachable or participate,

128
00:07:01,520 --> 00:07:03,710
is it possibility a becomes a leader,

129
00:07:05,140 --> 00:07:07,300
so when c and d up,

130
00:07:07,300 --> 00:07:10,690
and so the question is does c and d always vote for a,

131
00:07:10,690 --> 00:07:11,920
if a is the candidate.

132
00:07:12,810 --> 00:07:16,350
And it turns out is actually slightly complicated,

133
00:07:16,350 --> 00:07:18,090
it is not completely straightforward,

134
00:07:18,510 --> 00:07:20,670
so if a starts this election,

135
00:07:20,700 --> 00:07:23,910
presumably it will start the election in term 7,

136
00:07:27,310 --> 00:07:29,530
and so if it contact c and d,

137
00:07:29,590 --> 00:07:31,840
you know c will be perfectly fine with that,

138
00:07:31,840 --> 00:07:36,700
because the a is at least up to date,

139
00:07:40,250 --> 00:07:43,820
and so we'll be able to achieve a majority,

140
00:07:43,820 --> 00:07:46,430
but you know it is possible correct d,

141
00:07:46,670 --> 00:07:48,650
there's one additional rule,

142
00:07:48,650 --> 00:07:52,820
that if d actually has,

143
00:07:52,820 --> 00:07:56,930
if follower, follower has a higher term,

144
00:07:56,930 --> 00:07:58,250
as [sit] in higher term,

145
00:07:58,280 --> 00:08:00,020
its current term is higher,

146
00:08:00,440 --> 00:08:02,420
then the or the candidate,

147
00:08:02,540 --> 00:08:04,850
then actually it can stop the election,

148
00:08:04,850 --> 00:08:07,400
because it will respond saying,

149
00:08:07,400 --> 00:08:10,430
like hey my term is higher than your higher my term,

150
00:08:10,490 --> 00:08:12,350
my current term is higher than your term,

151
00:08:12,470 --> 00:08:14,180
and so therefore you have to become a follower,

152
00:08:14,210 --> 00:08:18,260
so a will then be changed back from candidate to follower.

153
00:08:18,760 --> 00:08:19,990
And this can happen correctly,

154
00:08:19,990 --> 00:08:20,920
in case of d,

155
00:08:21,190 --> 00:08:24,280
this d might actually have seen term a,

156
00:08:24,310 --> 00:08:26,050
and we can't really tell from this picture,

157
00:08:26,050 --> 00:08:27,640
what actually the outcome is going to be,

158
00:08:27,850 --> 00:08:29,440
let's assume that example,

159
00:08:29,650 --> 00:08:38,530
you know the it has run once and has increases term to 8,

160
00:08:38,620 --> 00:08:40,690
it didn't become succeeded leader,

161
00:08:40,750 --> 00:08:42,190
and then its current term will 8,

162
00:08:42,190 --> 00:08:46,490
and so it will vote when a ask to for its vote,

163
00:08:46,640 --> 00:08:48,830
you know d will say no, I won't vote for you,

164
00:08:49,010 --> 00:08:51,140
and furthermore by current term is a,

165
00:08:51,260 --> 00:08:52,730
so a will see that message,

166
00:08:52,730 --> 00:08:54,290
it's higher than 7,

167
00:08:54,440 --> 00:08:58,280
and so a will actually step down and become just a follower,

168
00:08:58,370 --> 00:08:59,420
and then at some point later,

169
00:08:59,420 --> 00:09:03,380
presumably you know d will run its election timer will go off

170
00:09:03,380 --> 00:09:04,460
and actually it will run.

171
00:09:05,740 --> 00:09:09,610
And so the short story of this you know [] is gonna,

172
00:09:09,610 --> 00:09:10,930
really this picture is that,

173
00:09:11,230 --> 00:09:12,640
it's absolutely possible,

174
00:09:12,640 --> 00:09:15,790
that a c and d can become leader in different types of scenarios,

175
00:09:16,060 --> 00:09:19,240
and that's probably the main thing to get out of this.

176
00:09:19,660 --> 00:09:20,950
Professor.

177
00:09:21,100 --> 00:09:22,210
Yeah.

178
00:09:22,570 --> 00:09:25,270
So, I I just want to ask,

179
00:09:25,270 --> 00:09:27,970
because I think I I'm not sure if I understood correctly,

180
00:09:27,970 --> 00:09:31,480
but you said a might be elected in term 7,

181
00:09:31,900 --> 00:09:36,460
it is not true that it cannot for any reason be elected in term 7,

182
00:09:37,580 --> 00:09:40,820
even if d was down, right,

183
00:09:40,820 --> 00:09:48,310
because people like like d, like already got a majority, right, in 7.

184
00:09:50,260 --> 00:09:52,240
d got a majority in 7,

185
00:09:52,240 --> 00:09:56,080
because it actually was able to get something done,

186
00:09:56,080 --> 00:09:57,790
so presumably right, you're right,

187
00:09:57,790 --> 00:10:00,040
you know the good observation,

188
00:10:00,340 --> 00:10:01,690
so it has to be the case that,

189
00:10:01,690 --> 00:10:04,210
there's a number of people that actually already in term 7,

190
00:10:05,800 --> 00:10:07,630
and the picture is incomplete,

191
00:10:07,660 --> 00:10:09,910
we don't really know what the current term is,

192
00:10:09,910 --> 00:10:11,200
that people have seen so far.

193
00:10:11,720 --> 00:10:12,230
Yeah.

194
00:10:12,850 --> 00:10:13,300
Right?

195
00:10:14,340 --> 00:10:17,190
Well, yeah, I mean the only thing is like,

196
00:10:17,370 --> 00:10:22,770
I think like a majority of the servers already voted for someone in term 7,

197
00:10:22,770 --> 00:10:23,100
so.

198
00:10:23,100 --> 00:10:25,380
Absolutely, a will go to term 8,

199
00:10:25,950 --> 00:10:29,370
and you know we'll run the election for term 8,

200
00:10:29,580 --> 00:10:30,840
but you know for the same reason,

201
00:10:30,840 --> 00:10:32,760
d might already be in 9, right,

202
00:10:32,760 --> 00:10:36,720
and so it all depends on what the current term is,

203
00:10:36,720 --> 00:10:38,580
what these actually these participants are in.

204
00:10:40,910 --> 00:10:42,350
But the main conclusion, correct,

205
00:10:42,350 --> 00:10:44,090
the main top level conclusion is that,

206
00:10:44,330 --> 00:10:47,870
a can become leader certainly, when c and d are offline,

207
00:10:48,420 --> 00:10:51,180
c can become leader and d can become a leader.

208
00:10:54,100 --> 00:10:54,760
Thanks.

209
00:10:57,430 --> 00:11:03,080
Okay, then, so so we now know,

210
00:11:03,080 --> 00:11:10,190
that the raft can sort of ended in states where the logs are diverged,

211
00:11:10,250 --> 00:11:12,590
and so that needs to be repaired,

212
00:11:12,620 --> 00:11:16,130
and it's like one a key component of the raft protocol is,

213
00:11:16,130 --> 00:11:19,370
to do the that log catch up as they call it,

214
00:11:20,280 --> 00:11:22,860
so I talked a little bit about that.

215
00:11:30,700 --> 00:11:36,670
And this is basically what you're sort of have to deal with in part b of the lab.

216
00:11:37,560 --> 00:11:42,030
So I may be easier to illustrate with this picture,

217
00:11:43,590 --> 00:11:46,020
so let's, it's going to make it a little bit simple,

218
00:11:46,320 --> 00:11:47,880
let's have 3 servers,

219
00:11:49,790 --> 00:11:56,960
here's S1, it has you know term 3 in index 10,

220
00:11:57,170 --> 00:12:04,210
the index 11 has no entries in [] and 11 12,

221
00:12:04,210 --> 00:12:06,100
here we have S2,

222
00:12:09,270 --> 00:12:13,650
S2 has entries you know 3 3 5,

223
00:12:15,380 --> 00:12:21,560
and so this is index 10 11 12 and 13, 13 to make it complete,

224
00:12:22,280 --> 00:12:26,160
and here is S4, oh sorry S3,

225
00:12:26,980 --> 00:12:34,700
and let's do where in the scenario 3 3 4, and 10 11 12 13,

226
00:12:36,080 --> 00:12:38,750
and I'm not showing like the indexes before 10,

227
00:12:40,190 --> 00:12:41,540
they're not be very relevant.

228
00:12:42,280 --> 00:12:46,120
And you know use the timeline, these different servers.

229
00:12:46,710 --> 00:12:49,050
And just let's start out assuming that,

230
00:12:49,050 --> 00:12:50,460
the S2 becomes the leader,

231
00:12:51,460 --> 00:12:56,250
because it has the highest, it is most up to date,

232
00:12:56,280 --> 00:12:59,220
it has the highest term number in the last log entry,

233
00:12:59,220 --> 00:13:00,210
so it becomes leader.

234
00:13:00,750 --> 00:13:04,620
And now we need to understand how about the protocol is

235
00:13:04,620 --> 00:13:06,540
to synchronize these particular logs,

236
00:13:06,930 --> 00:13:10,080
in the way you know this almost happens is sort of send [] of,

237
00:13:10,200 --> 00:13:12,450
you know either the append entries,

238
00:13:12,480 --> 00:13:14,310
because new log entries are appended,

239
00:13:14,310 --> 00:13:15,420
or because of heartbeats,

240
00:13:15,420 --> 00:13:19,200
which basically are append entries with zero new entries.

241
00:13:19,600 --> 00:13:21,970
So let's assume that the leader actually sends heartbeat out,

242
00:13:21,970 --> 00:13:23,080
in fact, it does it correct,

243
00:13:23,080 --> 00:13:25,420
the election immediately sends out a heartbeat,

244
00:13:25,980 --> 00:13:27,630
and so it will sends out the heartbeat,

245
00:13:28,240 --> 00:13:30,910
and the heartbeat basically has no log entries,

246
00:13:31,630 --> 00:13:35,170
but it also indicates two other pieces of information,

247
00:13:35,260 --> 00:13:36,760
namely the previous term,

248
00:13:37,820 --> 00:13:41,360
so the previous term, which in this case it's going to be 5, right,

249
00:13:42,830 --> 00:13:46,700
and the previous index, it's gonna be 12.

250
00:13:47,960 --> 00:13:52,010
So it sends it off to the leader S2, sends to S3

251
00:13:52,010 --> 00:13:53,180
and S3 looks at this,

252
00:13:53,540 --> 00:13:56,390
and says well look my previous term,

253
00:13:56,390 --> 00:14:01,190
actually is not 5, it's actually 4,

254
00:14:01,850 --> 00:14:05,480
and so, it actually sends back a message saying no,

255
00:14:06,990 --> 00:14:09,570
you know I'm I'm alive in principle,

256
00:14:09,570 --> 00:14:12,480
but you know I I know I cannot do your append,

257
00:14:13,280 --> 00:14:14,780
so I'm not up to date.

258
00:14:15,340 --> 00:14:20,440
And now S2 have some information to actually bring it up to date,

259
00:14:20,590 --> 00:14:23,050
and the way it works is,

260
00:14:23,050 --> 00:14:25,390
there's sort of two variables that are of importance,

261
00:14:25,450 --> 00:14:32,350
one, for every node, S2 for keeps a variable nextIndex,

262
00:14:36,760 --> 00:14:40,300
and nextIndex when it initialize it, becomes leader,

263
00:14:40,450 --> 00:14:43,580
it is sort of an optimistic variable,

264
00:14:44,030 --> 00:14:47,180
it just assumes that the logs are actually up to date,

265
00:14:47,900 --> 00:14:51,650
and so when S2 becomes a leader,

266
00:14:51,680 --> 00:14:53,240
it actually just sets it to 13,

267
00:14:53,800 --> 00:14:56,650
you know the same value that actually it has for itself.

268
00:14:57,870 --> 00:14:59,010
That's perfectly fine,

269
00:14:59,310 --> 00:15:00,810
because it's just a guess,

270
00:15:00,840 --> 00:15:03,630
if one actually the where S3 might be,

271
00:15:03,630 --> 00:15:04,800
and S3 might be behind,

272
00:15:04,800 --> 00:15:07,020
and then you know because there's no message,

273
00:15:07,290 --> 00:15:09,480
the leader actually learns that.

274
00:15:10,130 --> 00:15:12,410
And so, in fact you know when it gets there's no message,

275
00:15:13,740 --> 00:15:16,020
in the unoptimized version,

276
00:15:16,110 --> 00:15:18,510
so I'm going to first talk about the unoptimized version,

277
00:15:22,650 --> 00:15:25,710
the leader just decrements the nextIndex by one,

278
00:15:25,830 --> 00:15:28,170
and so it decrements 13 to 12,

279
00:15:29,060 --> 00:15:32,390
and then we got some point will send another append entries,

280
00:15:33,170 --> 00:15:34,190
and this time around,

281
00:15:34,190 --> 00:15:35,690
you know it will actually say,

282
00:15:35,690 --> 00:15:37,160
okay, we'll make nextIndex this 12,

283
00:15:37,190 --> 00:15:39,590
you know got a send you know log entry 5,

284
00:15:40,880 --> 00:15:46,080
and you know the previous term, it's gonna be 3,

285
00:15:47,160 --> 00:15:51,780
and the previous index is going to be 11.

286
00:15:53,700 --> 00:15:58,020
And so when S3 actually received this message,

287
00:15:58,020 --> 00:15:59,790
you know check the previous term 3,

288
00:15:59,790 --> 00:16:01,080
the previous index is 11,

289
00:16:01,080 --> 00:16:02,040
that all works out,

290
00:16:02,370 --> 00:16:04,320
it sees that it has append 5,

291
00:16:04,350 --> 00:16:08,880
and so it will erase the 4 and stick a 5 in there,

292
00:16:09,300 --> 00:16:13,090
and basically respond saying yep, good.

293
00:16:16,300 --> 00:16:17,980
So at this point,

294
00:16:18,010 --> 00:16:23,280
the leader knows that actually the log is up to date,

295
00:16:23,280 --> 00:16:25,740
because you've got an ok message back.

296
00:16:27,340 --> 00:16:31,000
Then there's the second variable that plays an important role in all this,

297
00:16:31,240 --> 00:16:36,660
which is matchIndex, which raft also maintains for,

298
00:16:36,690 --> 00:16:39,750
leader also maintains for every follower.

299
00:16:40,440 --> 00:16:42,540
So there's an nextIndex you know for S3,

300
00:16:42,540 --> 00:16:43,830
there's nextIndex for S1,

301
00:16:43,830 --> 00:16:47,460
and similar there's a matchIndex you know for S1 S2 S3 too,

302
00:16:48,560 --> 00:16:49,310
and this one is sort of,

303
00:16:49,310 --> 00:16:53,540
you can think about this as pessimistic or lower bound,

304
00:16:55,140 --> 00:16:58,470
so when the leader actually you know becomes leader,

305
00:16:58,500 --> 00:17:00,360
it actually sets the value just 0,

306
00:17:01,850 --> 00:17:04,580
and to indicate that basically as far as knows,

307
00:17:04,790 --> 00:17:09,200
S3 doesn't really have any log entries at all,

308
00:17:09,840 --> 00:17:15,270
and so it hasn't delivered any log entries to the application,

309
00:17:15,570 --> 00:17:18,120
and so for S2 also has to be very careful about,

310
00:17:18,120 --> 00:17:20,220
what actually it can be delivered to the application,

311
00:17:20,340 --> 00:17:22,290
there goes, if it needs to know,

312
00:17:22,290 --> 00:17:24,750
that at least a majority of the followers

313
00:17:24,750 --> 00:17:26,790
actually has a copy of a particular log entry,

314
00:17:26,790 --> 00:17:27,690
before it can deliver.

315
00:17:29,460 --> 00:17:33,060
So just start to be pessimistic,

316
00:17:33,360 --> 00:17:35,070
but then once it learns,

317
00:17:35,070 --> 00:17:42,180
you know that for example, once it learns actually that the follower is okay,

318
00:17:42,180 --> 00:17:44,370
and we've gotten okay the append message,

319
00:17:44,400 --> 00:17:49,410
it can actually update you know the pessimistic, lower bound the matchIndex

320
00:17:49,740 --> 00:17:52,350
you know from 0 to actually 13,

321
00:17:52,650 --> 00:17:54,450
because it has learned that,

322
00:17:54,450 --> 00:17:59,890
the follower is actually up to date till 13,

323
00:17:59,890 --> 00:18:02,860
and that's the nextIndex that expect is you know 13.

324
00:18:03,770 --> 00:18:05,210
And at this point in time,

325
00:18:05,210 --> 00:18:08,840
basically it has learned from two different, knows that,

326
00:18:08,840 --> 00:18:13,880
that particular log entry 5 is actually now replicated at least in two nodes.

327
00:18:16,780 --> 00:18:18,520
And so you might think well good,

328
00:18:18,550 --> 00:18:20,380
it has been replicated in two nodes,

329
00:18:20,530 --> 00:18:22,240
we can deliver to the application,

330
00:18:22,240 --> 00:18:24,010
because the majority clearly has it,

331
00:18:24,370 --> 00:18:26,500
and we're in good shape.

332
00:18:27,410 --> 00:18:31,100
And unfortunately, that actually turned out not to be the case,

333
00:18:31,160 --> 00:18:33,560
it's close to true, but not completely true,

334
00:18:34,280 --> 00:18:37,730
and this actually has to do with figure 8,

335
00:18:38,210 --> 00:18:39,830
so I want to talk a little bit about figure 8,

336
00:18:39,830 --> 00:18:43,070
and the real reason what's going on here to make this slightly complicated

337
00:18:43,070 --> 00:18:45,200
and you also should think a little bit fishy.

338
00:18:45,670 --> 00:18:52,900
So this leader S2 just erased the value out of the log of S3,

339
00:18:52,900 --> 00:18:54,640
and you know somebody put that in,

340
00:18:55,200 --> 00:18:57,510
and you know erase it,

341
00:18:57,510 --> 00:19:00,720
you know yeah it seems a little bit you know dangerous,

342
00:19:00,720 --> 00:19:06,240
and as and so it turns out there is a corner case,

343
00:19:06,240 --> 00:19:09,600
where you have to be a bit careful,

344
00:19:09,600 --> 00:19:11,310
by when you deliver,

345
00:19:11,340 --> 00:19:13,590
when you declare a message actually committed.

346
00:19:14,740 --> 00:19:16,360
And it turns out that basically,

347
00:19:16,720 --> 00:19:21,130
you know figure 8 illustrates that.

348
00:19:22,210 --> 00:19:27,420
So let me talk a little bit about this erasing log entries.

349
00:19:31,430 --> 00:19:33,410
And we will see is that the rule

350
00:19:33,410 --> 00:19:37,550
for actually when the message can be delivered to the application is,

351
00:19:37,940 --> 00:19:44,060
is slightly more subtle than just counting the replicates.

352
00:19:47,100 --> 00:19:49,770
Let's see, actually gets figure 8, load it in.

353
00:19:50,800 --> 00:19:51,940
Okay, so here's figure 8

354
00:19:52,000 --> 00:19:55,660
and so as usual structure.

355
00:19:58,810 --> 00:20:04,450
Okay, let me get back to the question in the in the chat in a second,

356
00:20:04,960 --> 00:20:07,360
so here's figure 8,

357
00:20:07,360 --> 00:20:10,510
and so let's walk through what the scenario here is,

358
00:20:10,510 --> 00:20:16,030
correct, in figure a, you know log entry 1 has been committed by everybody,

359
00:20:16,360 --> 00:20:24,730
you know the S1 or S2 became leader in [] in term 2,

360
00:20:25,060 --> 00:20:28,720
they committed or they started appending an entry 2,

361
00:20:29,180 --> 00:20:30,830
hasn't been committed yet,

362
00:20:30,860 --> 00:20:32,900
because it's not a majority for sure,

363
00:20:33,260 --> 00:20:35,000
then indeed what actually happens,

364
00:20:35,000 --> 00:20:38,540
you know S5 must disconnected, has [] of this term 2,

365
00:20:38,900 --> 00:20:40,880
became a leader in term 3,

366
00:20:40,910 --> 00:20:43,910
appended an entry to its log,

367
00:20:44,180 --> 00:20:45,440
that certainly is not committed,

368
00:20:45,440 --> 00:20:46,550
because there's no majority,

369
00:20:46,730 --> 00:20:48,740
then we end up in c,

370
00:20:48,770 --> 00:20:52,810
maybe the S5 actually got disconnected again,

371
00:20:53,020 --> 00:20:56,830
S1 becomes a leader in term 4,

372
00:20:56,980 --> 00:21:01,780
it starts replicating you know entry, this log entry 2 to other nodes,

373
00:21:02,620 --> 00:21:05,500
and in fact you know deliver it,

374
00:21:05,500 --> 00:21:07,180
you know it gets back,

375
00:21:07,180 --> 00:21:09,070
you know like shown in the previous slide,

376
00:21:09,430 --> 00:21:13,090
in those actually on S2 and those actually on S3.

377
00:21:14,230 --> 00:21:18,940
And it turns out you know that actually you might think,

378
00:21:18,940 --> 00:21:21,490
okay, well you know S1 knows,

379
00:21:21,490 --> 00:21:27,730
you know that actually 3 3 nodes actually have a copy of this particular entry,

380
00:21:27,730 --> 00:21:29,290
and so I might be able to deliver it,

381
00:21:29,290 --> 00:21:31,270
and it turns out that's not true,

382
00:21:32,000 --> 00:21:40,300
and there's more subtle reasoning that needs to happen to actually commit,

383
00:21:40,300 --> 00:21:42,220
and namely you can only commit.

384
00:21:42,370 --> 00:21:43,150
Oops, sorry,

385
00:21:46,750 --> 00:21:47,680
you can commit

386
00:21:50,230 --> 00:22:03,820
after the leader has committed one entry in its own term.

387
00:22:09,990 --> 00:22:12,330
And if we think about this number 2,

388
00:22:12,570 --> 00:22:15,510
it actually isn't from leaders in term 4,

389
00:22:15,750 --> 00:22:20,490
and and so the the the commit rule wouldn't allow

390
00:22:20,490 --> 00:22:24,030
actually commit 2 immediately to the servers,

391
00:22:24,240 --> 00:22:27,420
because that actually is one from a previous term

392
00:22:27,420 --> 00:22:28,440
and not from the current term,

393
00:22:28,560 --> 00:22:31,350
and so for example your code to decide

394
00:22:31,350 --> 00:22:33,990
whether actually something can be delivered on the apply channel,

395
00:22:33,990 --> 00:22:35,430
needs to take to this account.

396
00:22:35,900 --> 00:22:38,750
And the reason you need take to account is illustrated by d and e,

397
00:22:39,510 --> 00:22:42,420
basically what can happen is that,

398
00:22:42,980 --> 00:22:50,570
you know for S1 actually might might actually end up in a different situation,

399
00:22:50,570 --> 00:22:55,010
where d actually becomes the,

400
00:22:56,440 --> 00:23:02,850
after, d actually becomes the leader,

401
00:23:02,910 --> 00:23:06,180
for example S1 example is particularly disconnected,

402
00:23:06,420 --> 00:23:09,300
and it might actually start connecting,

403
00:23:09,300 --> 00:23:10,890
it can form a majority,

404
00:23:11,040 --> 00:23:16,800
and actually it starts copying its particular, its entries to actually,

405
00:23:17,350 --> 00:23:20,380
yeah, okay, it erases you know the 2s,

406
00:23:20,440 --> 00:23:22,600
and actually copies it's 3 in,

407
00:23:22,660 --> 00:23:27,010
the entry for its term 3 into whatever used to be 2,

408
00:23:27,070 --> 00:23:30,220
and this is erasing that we talked about on the previous slide.

409
00:23:33,660 --> 00:23:34,290
And so we'll see,

410
00:23:34,290 --> 00:23:38,280
actually though even though it was on the majority of the nodes, right,

411
00:23:38,280 --> 00:23:39,300
on the majority of nodes,

412
00:23:39,330 --> 00:23:40,470
that got erased.

413
00:23:41,370 --> 00:23:45,210
And so the rule and therefore the rules as I stated here,

414
00:23:45,330 --> 00:23:49,920
because now once you know this is illustrated by e,

415
00:23:50,160 --> 00:23:55,080
once sactually S3 S1 commits an entry in its own term,

416
00:23:55,830 --> 00:23:58,020
and so it knows that every,

417
00:23:58,050 --> 00:24:00,060
you know there's a majority in its own term,

418
00:24:00,210 --> 00:24:01,200
so at this point,

419
00:24:01,200 --> 00:24:04,170
it can actually deliver 4 you know to the application,

420
00:24:04,560 --> 00:24:06,030
and as a result of that,

421
00:24:06,090 --> 00:24:08,850
you know any nodes that were committed in previous terms

422
00:24:08,880 --> 00:24:11,910
can also be delivered to the application.

423
00:24:13,040 --> 00:24:15,710
So you see here that this erasing of log entries,

424
00:24:15,740 --> 00:24:19,910
that basic commits makes the commit rule quite slightly more complicated.

425
00:24:20,460 --> 00:24:25,770
And that's just the design decisions that the designers of raft made,

426
00:24:25,770 --> 00:24:27,210
you know they could have done it differently,

427
00:24:27,450 --> 00:24:28,770
they could have counted,

428
00:24:28,860 --> 00:24:32,100
and made basically 2 survive, if they wanted to,

429
00:24:32,220 --> 00:24:34,320
but they decided to go for this particular approach,

430
00:24:34,320 --> 00:24:36,090
on the grounds, that they think it's simpler.

431
00:24:39,600 --> 00:24:43,050
Okay, so this is suddenly that will show up,

432
00:24:43,080 --> 00:24:45,840
you know in the test cases for the labs,

433
00:24:46,080 --> 00:24:49,440
so you have to be a little bit of careful with your commit rule,

434
00:24:51,860 --> 00:24:53,030
and then you implement it correctly.

435
00:24:55,910 --> 00:25:00,350
Okay, so, so far,

436
00:25:00,380 --> 00:25:02,600
you know if you go back to this particular picture,

437
00:25:02,600 --> 00:25:11,120
the an optimized version of this protocol is a little bit of bummer, right,

438
00:25:11,120 --> 00:25:13,970
like if you think a little bit about this,

439
00:25:14,000 --> 00:25:18,410
let's look at actually what happens with S1.

440
00:25:19,230 --> 00:25:22,920
So let's see, let me switch things,

441
00:25:22,920 --> 00:25:25,470
let's see S2 tries bring S1 up to date,

442
00:25:25,470 --> 00:25:26,700
will do the same thing,

443
00:25:27,210 --> 00:25:30,300
you know send append entries, you know with nil entries,

444
00:25:30,540 --> 00:25:33,960
past term previous term to be 5,

445
00:25:36,400 --> 00:25:39,610
and previous index 12,

446
00:25:40,160 --> 00:25:42,440
it will say no, right,

447
00:25:43,340 --> 00:25:48,410
actually the index you know previous index is actually a 10 with term 3,

448
00:25:48,410 --> 00:25:49,880
so it will,

449
00:25:50,450 --> 00:25:55,880
this guy will decrease its next index go from 13 to 12,

450
00:25:56,730 --> 00:25:58,650
then we'll do the same thing again,

451
00:25:59,130 --> 00:26:04,350
you know sent I guess it's gonna send 5, the log entry 5,

452
00:26:04,350 --> 00:26:06,570
it will set the previous term to be 3,

453
00:26:07,220 --> 00:26:09,890
and index previous index to be 11,

454
00:26:10,740 --> 00:26:12,120
it's going to get a no back,

455
00:26:13,050 --> 00:26:15,780
you know, then the index goes to from 12 to 11,

456
00:26:16,880 --> 00:26:19,070
and now basically it's going to work,

457
00:26:19,100 --> 00:26:20,120
and so we'll see here,

458
00:26:20,120 --> 00:26:22,370
that basically for every log entry,

459
00:26:22,400 --> 00:26:25,280
we're going to have a round trip you know sort of append entries,

460
00:26:26,020 --> 00:26:28,930
and it turns out that that can be expensive,

461
00:26:28,960 --> 00:26:29,590
and like,

462
00:26:29,590 --> 00:26:31,330
and and the real question is

463
00:26:31,330 --> 00:26:34,030
like you can follower be far far behind?

464
00:26:35,310 --> 00:26:36,810
And let me ask that,

465
00:26:36,810 --> 00:26:38,010
we're pause for a second,

466
00:26:38,010 --> 00:26:40,770
so you can reflect and think about that case,

467
00:26:41,070 --> 00:26:45,690
is it possible that a follower can be far far behind for a given leader?

468
00:26:49,110 --> 00:26:51,510
If a new machine joins the cluster?

469
00:26:52,060 --> 00:26:55,930
Yeah, new join to cluster is a good example, any other cases?

470
00:26:57,820 --> 00:27:01,510
A machine crashed and is only coming back online after several terms.

471
00:27:01,630 --> 00:27:04,420
Yeah, exactly, it comes back after a day,

472
00:27:04,990 --> 00:27:06,460
it might be far behind,

473
00:27:06,940 --> 00:27:08,110
so that would mean,

474
00:27:08,110 --> 00:27:10,300
like in the protocol at unoptimized version,

475
00:27:10,300 --> 00:27:12,370
that you're gonna go back one by one for the log entries.

476
00:27:13,260 --> 00:27:14,490
So that's a little bit expensive,

477
00:27:14,850 --> 00:27:18,330
and so the paper actually discusses an optimization,

478
00:27:18,330 --> 00:27:19,590
so to catch up quickly.

479
00:27:30,740 --> 00:27:34,860
And, and the idea basically is,

480
00:27:34,860 --> 00:27:39,510
instead of like backing off as I said earlier,

481
00:27:39,510 --> 00:27:42,600
the nextIndex is basically optimistic, just guess right,

482
00:27:42,600 --> 00:27:45,330
and it doesn't really have to be that accurate,

483
00:27:45,660 --> 00:27:48,330
and and so the observation is that,

484
00:27:48,330 --> 00:27:50,850
you know we don't really have to go one by one back,

485
00:27:50,880 --> 00:27:53,370
you know it's perfectly fine for example to go a whole term back.

486
00:27:53,810 --> 00:27:55,700
And in fact there's a logical,

487
00:27:55,700 --> 00:27:57,470
maybe that's just a node,

488
00:27:57,470 --> 00:27:59,750
you know you know it's a couple of terms back,

489
00:27:59,750 --> 00:28:01,220
and we back off a couple of terms

490
00:28:01,220 --> 00:28:03,260
and then we'll scan from there.

491
00:28:04,050 --> 00:28:06,570
Alright, so to illustrate a little bit how it works,

492
00:28:06,930 --> 00:28:09,030
let me use the full example,

493
00:28:09,330 --> 00:28:11,730
and I'm just gonna do two servers,

494
00:28:11,880 --> 00:28:14,910
even though they might be you know need 3 to sort of have a majority,

495
00:28:14,910 --> 00:28:16,920
but let's assume there's a third one,

496
00:28:16,920 --> 00:28:18,480
and it just plays happily along.

497
00:28:19,260 --> 00:28:21,840
So, here's S1, here's S2,

498
00:28:23,320 --> 00:28:29,650
and let's say you know we this guy has 5 5 5,

499
00:28:33,640 --> 00:28:38,470
and this is 1 2 3 4 5 indexes,

500
00:28:39,070 --> 00:28:47,080
and you know let's say this S2 has 4, basically all 6s,

501
00:28:47,260 --> 00:28:50,440
so basically S1 is you know quite behind,

502
00:28:50,470 --> 00:28:54,460
because that's the only place where they actually line up is in the first entry,

503
00:28:55,030 --> 00:28:57,730
in first which is term 4.

504
00:28:58,390 --> 00:29:00,370
So in the unoptimized scheme,

505
00:29:00,370 --> 00:29:01,930
we would back off one by one,

506
00:29:01,930 --> 00:29:03,550
one by one until we finally got there.

507
00:29:04,860 --> 00:29:07,410
And to optimize this,

508
00:29:07,410 --> 00:29:09,660
the paper describes an optimization,

509
00:29:09,840 --> 00:29:12,900
unfortunately the optimization is not described

510
00:29:12,900 --> 00:29:15,030
in the same amount of detail as figure 2,

511
00:29:15,030 --> 00:29:15,720
and so in fact,

512
00:29:15,720 --> 00:29:19,170
you will in the for 2c actually pass 2c,

513
00:29:19,170 --> 00:29:22,840
you do actually have to have this optimization,

514
00:29:22,840 --> 00:29:24,910
a form of this optimization implemented,

515
00:29:25,090 --> 00:29:26,950
your reasonable free actually how to implement it,

516
00:29:26,950 --> 00:29:28,960
because paper doesn't describe very precisely,

517
00:29:28,960 --> 00:29:30,340
you know which how you should do it,

518
00:29:30,340 --> 00:29:31,810
then you have to do a little bit of work.

519
00:29:32,020 --> 00:29:34,660
But the basic idea is as follows,

520
00:29:35,060 --> 00:29:38,570
and just instead of just voting or just saying no or yes,

521
00:29:38,570 --> 00:29:40,310
as we know on the previous slide,

522
00:29:40,460 --> 00:29:44,480
the rejection, so you say no,

523
00:29:45,150 --> 00:29:47,310
the rejection includes a little bit of more information,

524
00:29:47,580 --> 00:29:49,470
and then that information is going to

525
00:29:49,470 --> 00:29:51,930
help the leader to basically back off quicker,

526
00:29:52,700 --> 00:29:57,560
and so includes something what they call the conflicting term,

527
00:29:58,940 --> 00:30:01,070
in response the conflicting index.

528
00:30:03,920 --> 00:30:09,650
And the, the conflicting term is basically the,

529
00:30:09,800 --> 00:30:13,040
you know if let me actually make this a more clear,

530
00:30:13,040 --> 00:30:16,880
let's say here's S1 timeline, here's S2,

531
00:30:17,620 --> 00:30:21,580
so S2 sends you know elected leader in 7, correct,

532
00:30:21,580 --> 00:30:24,220
because it has the most up to date log,

533
00:30:24,670 --> 00:30:27,790
it sends a message to S1 you know a heartbeat,

534
00:30:28,220 --> 00:30:29,990
and in a heartbeat,

535
00:30:29,990 --> 00:30:35,600
it will say you know the previous term was 6

536
00:30:36,080 --> 00:30:40,760
and previous index was 5,

537
00:30:42,620 --> 00:30:44,360
and now when S1 gets this,

538
00:30:44,390 --> 00:30:47,960
you know looks at this log, and sees that actually the previous term was 5,

539
00:30:48,840 --> 00:30:50,640
and so instead of actually,

540
00:30:50,640 --> 00:30:53,820
and so it will include in response you know conflicting term,

541
00:30:53,910 --> 00:30:57,960
term conflicts on in that index and that was 5,

542
00:30:58,630 --> 00:30:59,860
we're going to find entry,

543
00:31:00,190 --> 00:31:05,410
and then it also includes what the first index of that term is in this log,

544
00:31:05,440 --> 00:31:08,380
so we look at this term like 5 5 5,

545
00:31:08,380 --> 00:31:12,010
and the first time like the index 5 showed up its log is at index 2,

546
00:31:12,070 --> 00:31:13,690
and so we'll include that too,

547
00:31:14,020 --> 00:31:16,930
and we'll send that back you know to the leader,

548
00:31:16,930 --> 00:31:18,820
so here's S2 was leader,

549
00:31:19,160 --> 00:31:23,670
and so we're going to send back you know 5 2,

550
00:31:23,790 --> 00:31:25,650
that's the conflicting information,

551
00:31:26,070 --> 00:31:31,620
and leader uses that information to basically skip backward further,

552
00:31:31,620 --> 00:31:33,660
in fact it skips back from,

553
00:31:33,660 --> 00:31:42,140
so initially it's guess was nextIndex for S1 was 6,

554
00:31:42,680 --> 00:31:44,210
and based on this information,

555
00:31:44,210 --> 00:31:46,220
and it actually [scales] back to 2,

556
00:31:46,310 --> 00:31:47,690
so it turns it into 2,

557
00:31:48,020 --> 00:31:52,590
and then the next append entries is going to include everything from 2,

558
00:31:53,820 --> 00:31:56,640
so its gonna to include you know 5 5 5,

559
00:31:58,140 --> 00:32:02,730
and previous term is 4 and previous index is 1,

560
00:32:04,650 --> 00:32:07,350
and now S1 can one [] [] [],

561
00:32:07,350 --> 00:32:09,540
basically copy you know the new log entries

562
00:32:09,540 --> 00:32:13,020
over the entries 2 3 4 or 5 actually back up to date.

563
00:32:14,200 --> 00:32:17,500
So this basically reduces the number of heartbeats,

564
00:32:17,500 --> 00:32:20,350
you know to catch up follower

565
00:32:20,380 --> 00:32:23,020
by one per term instead of one per entry.

566
00:32:30,850 --> 00:32:31,690
Any questions?

567
00:32:33,430 --> 00:32:37,360
How do we make sure that we don't you know overload the bandwidth,

568
00:32:37,360 --> 00:32:38,860
because imagine if you have like,

569
00:32:38,860 --> 00:32:42,490
you're trying to send back all of these log entries,

570
00:32:42,490 --> 00:32:45,490
that cause problems in terms of like packets that are too large.

571
00:32:46,060 --> 00:32:47,290
Yeah, so a great question,

572
00:32:47,290 --> 00:32:51,820
like and because it sort of indicates an alternative scheme, right,

573
00:32:51,820 --> 00:32:54,400
but you know the go back here,

574
00:32:54,820 --> 00:32:57,940
is that instead of actually making this optimistic guess

575
00:32:57,940 --> 00:32:59,380
you know why make a guess at all,

576
00:32:59,500 --> 00:33:00,580
just send everything,

577
00:33:00,820 --> 00:33:03,550
you know the leader could have send like though it's whole log,

578
00:33:03,670 --> 00:33:04,750
it would be perfectly fine,

579
00:33:04,750 --> 00:33:09,130
and then basically you know any of the followers can fish out the ones they need, right,

580
00:33:10,850 --> 00:33:14,180
and that would be an alternative implementation,

581
00:33:14,180 --> 00:33:16,670
and presumably we don't like the implementation,

582
00:33:16,850 --> 00:33:18,560
because the log might be large,

583
00:33:18,770 --> 00:33:21,410
and that would be problematic.

584
00:33:22,260 --> 00:33:26,190
So I think you know the basic guess here that's going on is that,

585
00:33:26,460 --> 00:33:30,540
in the normal typical situations,

586
00:33:30,570 --> 00:33:34,200
the followers or you know hopefully reasonable close together,

587
00:33:34,200 --> 00:33:36,990
and so backing off a couple entries is actually sufficient,

588
00:33:37,630 --> 00:33:41,050
and if not, then we might go back one term,

589
00:33:41,380 --> 00:33:42,730
but not all terms.

590
00:33:43,340 --> 00:33:46,490
And so we'll send the log entries for one term,

591
00:33:46,490 --> 00:33:48,020
and that might be a lot, right,

592
00:33:48,050 --> 00:33:48,830
that might be a lot,

593
00:33:48,830 --> 00:33:50,750
and we'll see in a second, like how we get around that,

594
00:33:51,470 --> 00:33:53,360
snapshot is going to help

595
00:33:53,360 --> 00:33:56,300
you know reducing the number of log entries that we have to send.

596
00:33:59,460 --> 00:34:00,210
There was a question,

597
00:34:00,210 --> 00:34:05,040
do need to implement this sort of version of these optimization scheme in lab 2c,

598
00:34:05,040 --> 00:34:05,820
and the answer is yes.

599
00:34:06,860 --> 00:34:08,390
At least I believe,

600
00:34:08,390 --> 00:34:11,750
I haven't been able to pass the test without implementing some optimization.

601
00:34:13,970 --> 00:34:15,230
So I have a question,

602
00:34:15,260 --> 00:34:17,480
so I in my code,

603
00:34:17,480 --> 00:34:21,440
I did the optimization by backing off to the commit,

604
00:34:21,650 --> 00:34:26,270
so I made the the reply include the last commit index,

605
00:34:26,270 --> 00:34:27,650
and then I started from there,

606
00:34:28,920 --> 00:34:31,020
is that much worse?

607
00:34:31,020 --> 00:34:32,370
You might run into trouble,

608
00:34:32,370 --> 00:34:37,410
and so the the test keep track of how many bytes you sent,

609
00:34:37,880 --> 00:34:38,930
and gives you a budget,

610
00:34:38,930 --> 00:34:44,090
and if you're like go across the budget you know by too much,

611
00:34:44,360 --> 00:34:46,160
then the testing will say,

612
00:34:46,160 --> 00:34:48,380
well, you're just sending too much data,

613
00:34:50,800 --> 00:34:52,540
because your scheme it might be the case,

614
00:34:52,540 --> 00:34:55,180
that I think you will send more data than really necessary,

615
00:34:55,750 --> 00:34:57,400
whatever necessary means, but.

616
00:35:00,990 --> 00:35:02,460
There is a question in chat.

617
00:35:02,790 --> 00:35:05,940
Yeah, and did I said draw the wrong thing,

618
00:35:05,940 --> 00:35:09,160
yeah 6 6 6 6 sorry, thank you,

619
00:35:10,490 --> 00:35:18,920
6 6 6, I don't want to follower overriding the leader's log entries,

620
00:35:19,220 --> 00:35:19,970
sorry about that,

621
00:35:20,540 --> 00:35:21,230
good catch.

622
00:35:24,880 --> 00:35:25,630
Any questions?

623
00:35:32,510 --> 00:35:33,110
Okay.

624
00:35:40,300 --> 00:35:43,900
Okay, so let me talk a little bit about the persistence.

625
00:35:45,370 --> 00:35:47,590
We have one question in the chat, first.

626
00:35:48,010 --> 00:35:48,700
Okay.

627
00:35:48,700 --> 00:35:51,540
They're wondering why does the rejection has to

628
00:35:51,540 --> 00:35:55,080
send back the rejected term number as well as the index?

629
00:35:58,640 --> 00:36:02,600
Well, that depends very much how you actually implement the,

630
00:36:02,600 --> 00:36:05,810
how what kind of state you maintain on the leader,

631
00:36:05,810 --> 00:36:08,000
and how the leader decides to back off,

632
00:36:10,180 --> 00:36:12,790
do you need to know send some terms back,

633
00:36:12,790 --> 00:36:14,080
because you need [],

634
00:36:14,290 --> 00:36:17,440
in response get delayed for a long period of time,

635
00:36:17,440 --> 00:36:18,640
you certainly should reject

636
00:36:18,640 --> 00:36:22,060
you know information from terms that are completely not relevant anymore.

637
00:36:25,410 --> 00:36:27,240
I know this is slightly vague answer,

638
00:36:27,240 --> 00:36:30,330
but it's really very much dependent on exactly how you implement it.

639
00:36:37,480 --> 00:36:39,940
Okay, persistence,

640
00:36:45,970 --> 00:36:48,790
we talked about the persistence a little bit,

641
00:36:49,370 --> 00:36:51,950
in last raft of, the first raft lecture,

642
00:36:51,950 --> 00:36:55,340
where you know we noted that you know the,

643
00:36:55,370 --> 00:36:59,330
and follower can only vote for one candidate per term,

644
00:36:59,330 --> 00:37:03,410
and therefore it needs to remember it's who'd voted for,

645
00:37:03,410 --> 00:37:04,850
and what actually the current term is,

646
00:37:05,590 --> 00:37:11,530
but there's a larger issue around persistence,

647
00:37:11,740 --> 00:37:14,260
and that came up in one of the questions,

648
00:37:14,260 --> 00:37:15,220
one of you just asked,

649
00:37:15,220 --> 00:37:18,010
which is, you know what happens on reboot?

650
00:37:21,640 --> 00:37:24,640
And there's sort of two possible strategy you can think of,

651
00:37:24,670 --> 00:37:26,710
like one strategy is,

652
00:37:30,470 --> 00:37:32,120
what strategy 1 is,

653
00:37:32,790 --> 00:37:36,930
you know basically the node joins sort of freshly,

654
00:37:37,830 --> 00:37:44,640
so joins, basically when a node crashes and comes back up,

655
00:37:44,640 --> 00:37:46,080
it just doesn't participate anymore,

656
00:37:46,080 --> 00:37:51,650
it has to rejoin you know the, rejoin the raft cluster,

657
00:37:52,410 --> 00:37:54,480
and that means you know,

658
00:37:54,570 --> 00:37:59,240
when rejoins you should you have to replay the log,

659
00:37:59,270 --> 00:38:02,180
where basically has to receive every entry in the log

660
00:38:02,300 --> 00:38:04,900
and then replay that.

661
00:38:05,680 --> 00:38:10,150
And of course you know like if a node has been down,

662
00:38:10,150 --> 00:38:13,270
or node crashes down for a day or two days,

663
00:38:13,270 --> 00:38:15,730
or even if it just goes down for a second,

664
00:38:16,300 --> 00:38:18,910
but you know the system has been up for a year,

665
00:38:19,000 --> 00:38:22,150
that number means you have to replay a lot of log entries,

666
00:38:22,360 --> 00:38:23,650
so there's a little bit annoying.

667
00:38:23,650 --> 00:38:26,950
And so people prefer that strategy 2,

668
00:38:27,040 --> 00:38:30,220
which is you know you can back up,

669
00:38:31,820 --> 00:38:34,010
and you just basically participate again,

670
00:38:35,070 --> 00:38:36,900
so you catch up from,

671
00:38:37,080 --> 00:38:39,840
basically you start from your persistent state,

672
00:38:49,460 --> 00:38:53,300
the idea being that you know it's just a quick reboot,

673
00:38:53,330 --> 00:38:56,600
you crash you can back up whatever quick network failure,

674
00:38:56,840 --> 00:39:00,530
and so maybe you know the rest can move one term along,

675
00:39:00,710 --> 00:39:02,840
you basically have all the state,

676
00:39:02,990 --> 00:39:05,570
and you know should be used for quick catch up.

677
00:39:06,070 --> 00:39:07,120
So then the real question is,

678
00:39:07,120 --> 00:39:08,380
what needs to be,

679
00:39:08,530 --> 00:39:11,980
at what state needs to be persisted across reboots.

680
00:39:12,870 --> 00:39:15,330
You know we already talked about voting for,

681
00:39:15,690 --> 00:39:17,280
that needs to be persistent,

682
00:39:19,510 --> 00:39:25,510
because you are not allowed to vote for another candidate in the same term,

683
00:39:26,260 --> 00:39:30,070
and but the raft contains a little bit more information,

684
00:39:30,190 --> 00:39:35,020
and also maintains the log on disk or in persistent state,

685
00:39:35,560 --> 00:39:37,630
and the current term.

686
00:39:42,820 --> 00:39:45,460
And for each one, we should ask ourselves the question,

687
00:39:47,210 --> 00:39:49,730
why maintain persistent state,

688
00:39:49,730 --> 00:39:53,090
because it means that whenever we update that state,

689
00:39:53,090 --> 00:39:55,850
whenever we append an entry to the log,

690
00:39:55,940 --> 00:39:58,070
whenever we increment the term,

691
00:39:58,280 --> 00:40:00,680
or whenever we change votedFor,

692
00:40:00,680 --> 00:40:03,770
we actually have to write to disk or to stable storage,

693
00:40:03,770 --> 00:40:05,420
and stable storage is expensive,

694
00:40:05,600 --> 00:40:07,580
and so, it's very likely,

695
00:40:07,580 --> 00:40:14,120
the example, the the writing to stable storage could be the, could become a bottleneck.

696
00:40:15,800 --> 00:40:17,180
So we already talking about votedFor,

697
00:40:17,180 --> 00:40:19,820
so I'm going to talk, let's talk about the log,

698
00:40:19,820 --> 00:40:22,700
why does the log have to be written to persistent storage,

699
00:40:24,580 --> 00:40:25,780
can we reintegrate.

700
00:40:38,760 --> 00:40:39,810
Another way, you've got a question,

701
00:40:39,810 --> 00:40:41,610
let's say we don't write to the stable storage,

702
00:40:41,610 --> 00:40:42,420
what would break?

703
00:40:55,300 --> 00:40:58,960
Yeah, there's somebody in the chat to answer this question,

704
00:40:58,960 --> 00:41:01,750
which you could lose the majority on the commit write entries, right.

705
00:41:02,420 --> 00:41:05,030
So here's the scenario,

706
00:41:05,060 --> 00:41:12,230
where the raft replicated the operation on a majority of the nodes,

707
00:41:12,780 --> 00:41:16,980
so somebody you know majority nodes it's actually committed

708
00:41:17,010 --> 00:41:22,920
to actually delivering have delivered having accepted that log entry,

709
00:41:23,570 --> 00:41:26,630
so the leader sees the commits,

710
00:41:26,840 --> 00:41:30,830
it delivers the message with operation on the apply channel to the servers,

711
00:41:31,010 --> 00:41:33,320
servers executes the operation,

712
00:41:33,470 --> 00:41:36,020
and lets the client know the operation has succeeded.

713
00:41:37,550 --> 00:41:40,250
So now you know basically exposed the fact,

714
00:41:40,250 --> 00:41:44,720
that the [] operation was actually replicated the majority of nodes to the client.

715
00:41:45,390 --> 00:41:47,220
And so if we're not,

716
00:41:47,220 --> 00:41:49,890
if the followers that actually received that entry,

717
00:41:49,890 --> 00:41:51,810
did not put it on put on disk,

718
00:41:52,050 --> 00:41:56,070
and so that when the reboot they still have it,

719
00:41:56,460 --> 00:41:57,930
we could run into the case,

720
00:41:57,930 --> 00:41:59,910
the exactly that's the answer in the chat,

721
00:41:59,910 --> 00:42:02,790
that we lose the majority on committed entry,

722
00:42:02,790 --> 00:42:08,400
and that entry will not be delivered on the remaining replicas to the servers,

723
00:42:08,400 --> 00:42:10,350
and so the client will see something strange,

724
00:42:10,350 --> 00:42:14,310
where it sees that an operation that it did actually happen a little bit later,

725
00:42:14,400 --> 00:42:16,830
actually does the operation hasn't happened.

726
00:42:17,700 --> 00:42:18,900
And so it actually is important,

727
00:42:18,900 --> 00:42:20,520
that this actually on stable storage,

728
00:42:20,520 --> 00:42:23,310
we basically promised the leader to commit,

729
00:42:28,490 --> 00:42:30,320
and we cannot back out of that promise.

730
00:42:33,420 --> 00:42:33,960
Okay?

731
00:42:34,930 --> 00:42:36,100
Any questions about this?

732
00:42:43,660 --> 00:42:47,380
Why do we need to remember the current term or on disk,

733
00:42:47,380 --> 00:42:49,360
why does that need to be stored stably?

734
00:42:53,020 --> 00:42:54,790
Well, the term,

735
00:42:57,320 --> 00:42:59,300
you vote for a different person in every term,

736
00:42:59,300 --> 00:43:01,160
so if you don't keep track of what term it is,

737
00:43:01,160 --> 00:43:02,300
then you don't really,

738
00:43:02,570 --> 00:43:04,760
you don't actually know who you voted for, right.

739
00:43:04,790 --> 00:43:05,660
Yeah, exactly,

740
00:43:05,660 --> 00:43:06,860
you know you voted for,

741
00:43:06,860 --> 00:43:09,680
that's one problem also current terms always have to go up,

742
00:43:10,070 --> 00:43:11,810
you cannot go down in term,

743
00:43:12,080 --> 00:43:13,520
because you're going to use that

744
00:43:13,520 --> 00:43:18,380
to detect RPCs from stale leaders and stale candidates,

745
00:43:19,790 --> 00:43:21,020
it always has to go up.

746
00:43:30,690 --> 00:43:31,320
Okay?

747
00:43:34,550 --> 00:43:36,110
Any questions about persistence?

748
00:43:45,360 --> 00:43:52,950
Yeah, which is more about the way you laid out stuff,

749
00:43:52,950 --> 00:43:55,320
but you say there's two strategies, right,

750
00:43:55,560 --> 00:43:57,420
they need a log,

751
00:43:57,990 --> 00:44:01,260
and starting from a persistent state.

752
00:44:01,710 --> 00:44:02,670
Yeah.

753
00:44:03,180 --> 00:44:08,250
And so I mean the way you describe starting from a persistent state,

754
00:44:11,030 --> 00:44:17,320
do you like, do you on replay like,

755
00:44:18,600 --> 00:44:21,270
like I guess it doesn't say in this slide,

756
00:44:21,270 --> 00:44:23,550
like if you have does that assume,

757
00:44:23,550 --> 00:44:28,700
you also have like a snapshot of obviously.

758
00:44:29,180 --> 00:44:31,280
I have not talked about snapshots at all yet,

759
00:44:31,310 --> 00:44:32,660
which we'll talk about in a second,

760
00:44:32,690 --> 00:44:34,550
it's actually the next topic.

761
00:44:35,080 --> 00:44:35,830
Okay, but.

762
00:44:35,830 --> 00:44:36,700
The point is,

763
00:44:36,820 --> 00:44:39,820
okay, the two strategies after a node crashes,

764
00:44:39,850 --> 00:44:41,830
there's two ways to treat that node,

765
00:44:41,920 --> 00:44:43,420
one has a complete new node,

766
00:44:43,450 --> 00:44:45,700
that never existed in the system ever,

767
00:44:46,090 --> 00:44:47,050
and so when it comes up,

768
00:44:47,050 --> 00:44:49,450
you know you add it to the cluster,

769
00:44:49,450 --> 00:44:50,590
as if it's a new node,

770
00:44:50,590 --> 00:44:52,210
so basically the cluster goes from,

771
00:44:52,830 --> 00:44:55,320
you know let's say you started with seven nodes,

772
00:44:55,350 --> 00:44:57,690
one guy crashes, the cluster has six nodes,

773
00:44:57,840 --> 00:44:59,100
it just happily proceed,

774
00:44:59,100 --> 00:45:02,430
you know whatever the other nodes do their application and all that kind of stuff,

775
00:45:02,580 --> 00:45:05,850
and then the second node actually comes back up.

776
00:45:06,360 --> 00:45:09,270
And so there's two ways you know then join,

777
00:45:09,270 --> 00:45:10,110
one way is to say,

778
00:45:10,110 --> 00:45:12,420
like well I just forget everything I did ever,

779
00:45:12,600 --> 00:45:15,030
I'll join the cluster again,

780
00:45:15,030 --> 00:45:16,950
and the other six nodes will bring me up to date,

781
00:45:17,070 --> 00:45:20,280
and they'll send the log to me and I'll redo operations,

782
00:45:21,700 --> 00:45:24,310
and that can be costly, even with snapshots.

783
00:45:25,080 --> 00:45:27,060
So the second strategy is to say,

784
00:45:27,060 --> 00:45:30,330
well you know if the same node seven comes back up again,

785
00:45:30,540 --> 00:45:34,860
it tries to reintegrate with its with its persistent state that it has,

786
00:45:35,960 --> 00:45:38,240
you know basically the hope that,

787
00:45:38,240 --> 00:45:42,710
you know for example, did went down for a couple nanoseconds or microseconds or milliseconds,

788
00:45:42,950 --> 00:45:44,870
there's basically not much catching up to do at all,

789
00:45:44,870 --> 00:45:46,700
because it already has on the state.

790
00:45:48,700 --> 00:45:51,540
But it would like,

791
00:45:52,160 --> 00:45:54,530
the aside from the log,

792
00:45:54,530 --> 00:45:56,120
there's also a state machine, right,

793
00:45:56,120 --> 00:45:58,490
that you've been like apply changes to.

794
00:45:58,520 --> 00:46:01,280
Yeah yeah, so yeah, let's talk about that,

795
00:46:01,280 --> 00:46:02,810
so there's something, that's the next topic.

796
00:46:05,610 --> 00:46:06,720
I think here,

797
00:46:06,720 --> 00:46:09,270
so now what about service recovery?

798
00:46:16,120 --> 00:46:18,850
Sorry, I actually have another question on persistence.

799
00:46:19,210 --> 00:46:20,440
Yep.

800
00:46:20,500 --> 00:46:23,410
When does the server decide to persist?

801
00:46:24,170 --> 00:46:26,630
Good, great question,

802
00:46:26,630 --> 00:46:27,470
you know what you think,

803
00:46:28,790 --> 00:46:29,900
I'm sure you've thought about this.

804
00:46:33,190 --> 00:46:36,700
I mean, I think a simple answer would be

805
00:46:36,700 --> 00:46:39,580
every time one of these variables changes,

806
00:46:39,580 --> 00:46:43,720
but that seems like a very costly thing to do.

807
00:46:44,080 --> 00:46:45,910
I I think that is the correct answer,

808
00:46:46,770 --> 00:46:48,570
whenever one of these variable changes,

809
00:46:48,570 --> 00:46:51,540
you actually flush to disk or write to,

810
00:46:51,540 --> 00:46:53,580
in our case correct in labs,

811
00:46:53,580 --> 00:46:56,280
you write to the persistent module.

812
00:46:57,960 --> 00:46:58,680
Okay, and.

813
00:46:58,950 --> 00:47:03,120
So for example when the leader you know accepts an entry you know through start

814
00:47:03,480 --> 00:47:06,330
and appends to its local its log,

815
00:47:06,360 --> 00:47:08,700
it actually has to persist that entry.

816
00:47:13,480 --> 00:47:16,990
Okay, and so does the persisting work incrementally,

817
00:47:17,020 --> 00:47:19,600
so it like once you get a new log entry,

818
00:47:19,840 --> 00:47:23,090
you append or to take the [entire] state

819
00:47:23,090 --> 00:47:24,830
and like rewrite it into the file.

820
00:47:24,830 --> 00:47:27,590
Okay, in real life, you append, right,

821
00:47:27,590 --> 00:47:29,270
then you would not rewrite the whole log,

822
00:47:29,270 --> 00:47:31,100
you would just append one entry to the log,

823
00:47:31,100 --> 00:47:33,260
and that's actually one of the reasons that logs are cool,

824
00:47:33,500 --> 00:47:38,030
because you know you can just append at the end incrementally,

825
00:47:38,480 --> 00:47:41,210
in our lab,

826
00:47:41,210 --> 00:47:42,260
the whole thing is fake,

827
00:47:42,290 --> 00:47:44,780
the persistent actually doesn't really persist,

828
00:47:45,080 --> 00:47:50,840
you know it keeps the object around in between crashes,

829
00:47:50,840 --> 00:47:52,640
because crashes are also sort of fake,

830
00:47:52,640 --> 00:47:56,060
you know the tester basically stops nodes, restart them,

831
00:47:56,060 --> 00:47:57,620
and basically gives them the new state,

832
00:47:59,840 --> 00:48:02,210
but in the real system, you would append,

833
00:48:02,970 --> 00:48:04,440
so the log would be a file,

834
00:48:04,470 --> 00:48:06,030
and you would append an entry to the file.

835
00:48:07,500 --> 00:48:08,010
Thank you.

836
00:48:14,260 --> 00:48:16,660
And yes, you know we actually you will have to,

837
00:48:16,660 --> 00:48:19,390
a real system, if you append the log entry,

838
00:48:19,390 --> 00:48:21,670
your first append log entry, then you response,

839
00:48:21,880 --> 00:48:23,170
so in the append entries,

840
00:48:23,350 --> 00:48:25,540
if you update the log append,

841
00:48:25,840 --> 00:48:28,790
so if append entries on the follower,

842
00:48:28,820 --> 00:48:30,590
receives a new set of log entries,

843
00:48:30,590 --> 00:48:33,680
it appends them to its local persistent log,

844
00:48:33,740 --> 00:48:34,970
and then it can respond,

845
00:48:34,970 --> 00:48:38,540
because you would be bad to respond before appending,

846
00:48:38,540 --> 00:48:41,660
because then you might lose you know the,

847
00:48:41,930 --> 00:48:43,190
if you respond before appending,

848
00:48:43,190 --> 00:48:44,480
you might be running a situation,

849
00:48:44,480 --> 00:48:47,420
where just before actually the actual append happens,

850
00:48:47,420 --> 00:48:48,080
you crashes,

851
00:48:48,290 --> 00:48:51,020
and so you actually did not persist log entries,

852
00:48:51,200 --> 00:48:52,820
and so you would you know,

853
00:48:52,940 --> 00:48:55,340
you could lose committed entries.

854
00:49:00,250 --> 00:49:00,790
Okay?

855
00:49:02,620 --> 00:49:04,690
Okay, so how about service recovery,

856
00:49:05,170 --> 00:49:07,300
so the service keeps its own state,

857
00:49:07,330 --> 00:49:09,190
like for example in lab 3,

858
00:49:09,190 --> 00:49:10,930
you're implementing a key-value store,

859
00:49:11,320 --> 00:49:17,800
and so the key-value store maintains basically hash map from a key to a value,

860
00:49:17,950 --> 00:49:20,590
and you need to replay that state.

861
00:49:21,160 --> 00:49:25,480
And again, there are two possible ways of going about it,

862
00:49:25,870 --> 00:49:30,970
one, strategy 1 is to replay the log to actually reconstruct that state,

863
00:49:34,190 --> 00:49:37,550
so basically you're

864
00:49:37,700 --> 00:49:40,220
this is sort of similar to the strategy 1 on the previous slide,

865
00:49:40,490 --> 00:49:41,960
you know you take the log,

866
00:49:41,990 --> 00:49:44,630
use replay all the entries in the log,

867
00:49:44,630 --> 00:49:48,140
that should basically create exactly the same state,

868
00:49:48,500 --> 00:49:52,400
as if as before,

869
00:49:52,430 --> 00:49:57,440
because you know the whole point of this replicated state machine approach is that,

870
00:49:57,830 --> 00:50:01,670
the all the operations are executed in total order,

871
00:50:01,670 --> 00:50:03,080
operations have no side effect,

872
00:50:03,170 --> 00:50:05,270
so if you start in the same state with nothing,

873
00:50:05,510 --> 00:50:07,520
and you replay all the operations,

874
00:50:07,520 --> 00:50:09,410
you should end up exactly the same state,

875
00:50:09,530 --> 00:50:10,880
is any other node,

876
00:50:12,480 --> 00:50:13,890
and so that's one possible,

877
00:50:14,100 --> 00:50:16,980
and so that was one way to recreate the state.

878
00:50:24,400 --> 00:50:26,260
And you know obviously this is expensive,

879
00:50:26,320 --> 00:50:30,100
you know if the service actually has been running for a couple years,

880
00:50:30,460 --> 00:50:34,540
and then you have to replay the logs you know from the beginning of time,

881
00:50:34,540 --> 00:50:36,970
you know that is not you know so desirable.

882
00:50:37,570 --> 00:50:42,190
And so you know people do don't really follow strategy 1,

883
00:50:42,310 --> 00:50:43,840
gonna follow another strategy,

884
00:50:43,840 --> 00:50:46,450
and we just basically making periodic snapshots.

885
00:50:47,350 --> 00:50:49,240
And there are two reasons for doing that,

886
00:50:49,510 --> 00:50:53,530
one basically will reconstruct you know the service state in the past manner,

887
00:50:53,650 --> 00:50:55,180
and the second reason to do that is

888
00:50:55,180 --> 00:50:58,420
to be able to compact the log,

889
00:50:58,450 --> 00:51:04,960
you know even the raft state itself can be cut off,

890
00:51:05,050 --> 00:51:07,240
from the of the prefix can be cut off.

891
00:51:07,830 --> 00:51:09,480
And the basic [] is that,

892
00:51:09,780 --> 00:51:12,570
if the application is running for a while,

893
00:51:12,570 --> 00:51:16,590
and it has apply the first thousand operations or the first million operations,

894
00:51:16,830 --> 00:51:20,100
then the state does construct that point,

895
00:51:21,420 --> 00:51:29,440
the states will contain all ops you know through i,

896
00:51:30,900 --> 00:51:34,680
where i maybe a thousand or a million whatever you whatever you,

897
00:51:35,070 --> 00:51:38,070
so, so one way to think about is,

898
00:51:38,070 --> 00:51:45,240
that there's a duality between state replication and log replication or replay,

899
00:51:45,330 --> 00:51:49,710
the you could save the state after a thousand operations,

900
00:51:49,710 --> 00:51:51,360
and then you got exactly the same thing

901
00:51:51,360 --> 00:51:56,580
as actually re-applying redoing every operation from 0 to the [].

902
00:51:57,640 --> 00:51:59,770
And so this means that,

903
00:51:59,770 --> 00:52:01,030
once you have a snapshot,

904
00:52:01,030 --> 00:52:04,780
you stored snapshots [] on disk in persistent state,

905
00:52:05,110 --> 00:52:08,380
you can cut off, you can log,

906
00:52:08,380 --> 00:52:13,170
you can cut the log you know through i.

907
00:52:16,790 --> 00:52:19,700
And so, this allows you to control the size of the log,

908
00:52:19,760 --> 00:52:25,460
basically by periodicly asking the servers to actually take snapshots,

909
00:52:25,460 --> 00:52:27,560
and then you know service telling the raft library,

910
00:52:27,560 --> 00:52:29,630
yes, I've taken a snapshot through i,

911
00:52:29,660 --> 00:52:31,190
then raft can say okay good,

912
00:52:31,250 --> 00:52:34,940
I just know we have to remember anything from i or until i,

913
00:52:35,580 --> 00:52:38,850
that means of course that the snapshot has to be stored on stable storage.

914
00:52:45,050 --> 00:52:46,730
And this is also good for recovery, correct,

915
00:52:46,730 --> 00:52:49,040
and so it makes our recovery scheme slightly more complicated,

916
00:52:49,040 --> 00:52:50,900
than I just described in the previous slide,

917
00:52:50,900 --> 00:52:52,490
what it has to happen is that,

918
00:52:52,880 --> 00:52:58,580
when a follower comes back up after a quick reboot,

919
00:52:58,580 --> 00:53:00,440
it loads its persistent state,

920
00:53:00,440 --> 00:53:02,300
you know that includes you know the persistent state,

921
00:53:02,300 --> 00:53:03,950
that we talked about on the previous slide,

922
00:53:03,950 --> 00:53:05,060
you know this information,

923
00:53:05,600 --> 00:53:09,650
but also its last you know snapshot,

924
00:53:10,040 --> 00:53:13,370
installs that last, basically loads that snapshot into memory,

925
00:53:13,370 --> 00:53:14,240
the service does.

926
00:53:14,720 --> 00:53:17,570
And then you know we can replay any log entries

927
00:53:17,570 --> 00:53:19,460
to basically bring the follower up to date.

928
00:53:20,630 --> 00:53:21,410
Okay?

929
00:53:29,350 --> 00:53:30,460
Any questions about this?

930
00:53:31,560 --> 00:53:34,440
I have one question,

931
00:53:34,440 --> 00:53:37,350
I'm not sure if I'm gonna be able phrase super clearly,

932
00:53:37,650 --> 00:53:41,560
but I guess, like I was under impression,

933
00:53:41,560 --> 00:53:46,120
so I guess like does this not break some layer of abstraction,

934
00:53:46,600 --> 00:53:51,520
that previously existed between the application on top of raft and raft itself,

935
00:53:51,520 --> 00:53:54,730
for it now needs to understand how the state machine,

936
00:53:54,820 --> 00:53:56,800
like how to apply commands to the state machine,

937
00:53:56,800 --> 00:54:01,390
instead of just like giving commands to some external state machine.

938
00:54:01,570 --> 00:54:04,330
Yeah, great observation,

939
00:54:04,360 --> 00:54:09,190
clearly, you know there's some,

940
00:54:10,140 --> 00:54:12,960
they have to play together right, the raft library and the service,

941
00:54:13,520 --> 00:54:16,310
because first of all the service lies about,

942
00:54:16,310 --> 00:54:19,190
it gives the wrong information about how far it has to apply,

943
00:54:19,190 --> 00:54:21,380
then we getting inconsistent results,

944
00:54:21,380 --> 00:54:23,870
but anyway, so we don't assume liers anyway,

945
00:54:23,870 --> 00:54:25,310
but it's clearly the case,

946
00:54:25,430 --> 00:54:29,540
that the service and raft library we have to cooperate.

947
00:54:30,240 --> 00:54:34,230
And you can go with an abstraction [violation],

948
00:54:34,230 --> 00:54:37,230
I think the reason they do it is

949
00:54:37,230 --> 00:54:41,250
to limit the amount of state of the raft library we have to maintain,

950
00:54:41,790 --> 00:54:44,820
otherwise the raft library wouldn't know when it can cut the log.

951
00:54:45,560 --> 00:54:47,630
And so there's basically no way around it,

952
00:54:47,630 --> 00:54:49,400
that the service actually tells it,

953
00:54:49,400 --> 00:54:51,680
like well I got a snapchat through i,

954
00:54:51,710 --> 00:54:55,790
and so it's okay for you to remove log entry from 0 to i.

955
00:54:57,840 --> 00:54:58,920
And you'll see that,

956
00:54:58,920 --> 00:55:01,710
and so this maybe a good point,

957
00:55:01,710 --> 00:55:03,750
this is going to come up in 2d, right,

958
00:55:03,750 --> 00:55:10,080
lab 2d is gonna is all about snapshots and log compaction,

959
00:55:10,080 --> 00:55:11,460
as it's also called in the paper.

960
00:55:11,940 --> 00:55:15,990
The there has to be some API

961
00:55:16,020 --> 00:55:19,200
between the service and raft to be able to collaborate,

962
00:55:19,230 --> 00:55:21,720
and basically in 2a and 2b,

963
00:55:21,720 --> 00:55:23,880
that API in fact even 2c,

964
00:55:23,880 --> 00:55:25,470
that API is extremely simple,

965
00:55:25,770 --> 00:55:28,080
the only API that exists is

966
00:55:28,080 --> 00:55:31,520
this delivering log message on the apply channel, right,

967
00:55:31,520 --> 00:55:34,910
and almost nothing flows down from the service to raft,

968
00:55:34,910 --> 00:55:37,100
like other than the service may start,

969
00:55:37,370 --> 00:55:42,740
and raft trying to append an entry to the log using start.

970
00:55:43,440 --> 00:55:45,660
And you know and so in 2d,

971
00:55:45,810 --> 00:55:49,200
there has to be a little bit more of an API

972
00:55:49,200 --> 00:55:52,410
between service and raft library,

973
00:55:53,040 --> 00:55:54,090
and it turns out,

974
00:55:54,330 --> 00:55:57,030
you can design that API in many possible way,

975
00:55:57,030 --> 00:55:58,500
there are quite a number of ways of doing it,

976
00:55:58,530 --> 00:55:59,790
there's a number of particular ways,

977
00:55:59,790 --> 00:56:03,600
and the paper doesn't lay out what API you should use,

978
00:56:03,600 --> 00:56:05,790
the papers actually just nothing about this,

979
00:56:06,240 --> 00:56:08,610
and so it's up to you to,

980
00:56:08,730 --> 00:56:09,720
sometimes up to us,

981
00:56:09,720 --> 00:56:10,920
you know to figure out the APIs,

982
00:56:10,920 --> 00:56:14,220
and to be able to do 2d,

983
00:56:14,220 --> 00:56:18,150
you know we have to declare an API between the service and raft.

984
00:56:18,650 --> 00:56:19,970
And you know you'll see,

985
00:56:19,970 --> 00:56:21,470
what you do today,

986
00:56:21,470 --> 00:56:25,160
you know that the API you know have some [],

987
00:56:25,160 --> 00:56:29,210
might be a little bit more different than you might expect,

988
00:56:29,960 --> 00:56:33,320
and you know we had to pick one particular API,

989
00:56:33,320 --> 00:56:39,950
in in that API, as an operation called [conditional install],

990
00:56:40,190 --> 00:56:43,310
that you know has semantics,

991
00:56:43,310 --> 00:56:48,650
that you know allows you to change the raft state and the service state atomically

992
00:56:48,650 --> 00:56:49,970
in one single operation.

993
00:56:51,060 --> 00:56:55,380
And and that partly you know that operation exists,

994
00:56:55,620 --> 00:57:01,060
try to limit the abstraction [boundaries].

995
00:57:03,300 --> 00:57:03,810
Okay?

996
00:57:04,460 --> 00:57:06,050
And it turns out you can do it in different ways,

997
00:57:06,050 --> 00:57:06,860
you don't really need,

998
00:57:06,890 --> 00:57:08,990
you could have written it in different ways,

999
00:57:08,990 --> 00:57:09,950
but you know we,

1000
00:57:10,310 --> 00:57:12,680
[] is actually one of the more simple ways of doing it.

1001
00:57:13,550 --> 00:57:15,380
But it will become more clear in 2d

1002
00:57:15,380 --> 00:57:16,400
and you'll see indeed that,

1003
00:57:16,400 --> 00:57:20,810
there's sort of an interaction between the service and raft,

1004
00:57:20,810 --> 00:57:22,400
in a way that they have to play along.

1005
00:57:28,700 --> 00:57:29,390
How could you repeat,

1006
00:57:29,390 --> 00:57:32,240
when raft communicates with the service in the snapshot process,

1007
00:57:32,480 --> 00:57:36,380
so the snapshots are driven by the service,

1008
00:57:37,020 --> 00:57:39,660
so the service just says once in a while to raft,

1009
00:57:40,050 --> 00:57:42,480
I've made a snapshot, here's my snapshot,

1010
00:57:42,840 --> 00:57:46,050
and this is a snapshot includes all the operations through i,

1011
00:57:46,800 --> 00:57:52,650
and then raft you know writes the snapshots and truncates log you know to i,

1012
00:57:52,800 --> 00:57:55,500
and writes all that information to the disk.

1013
00:57:57,500 --> 00:58:00,920
And that's basically all what happens sort of, sort of regular operation,

1014
00:58:01,040 --> 00:58:03,410
periodically snapshots happen snapshot happens.

1015
00:58:04,130 --> 00:58:06,020
Then there's the other case,

1016
00:58:06,020 --> 00:58:09,140
you have to consider is like when reboot happens.

1017
00:58:09,650 --> 00:58:11,360
And so when a follower reboots,

1018
00:58:11,360 --> 00:58:15,680
it actually reboots from its persistent state,

1019
00:58:15,680 --> 00:58:17,360
and so including its snapshot,

1020
00:58:18,080 --> 00:58:20,480
and so when the follower reboots,

1021
00:58:20,480 --> 00:58:24,950
you know basically loads you know snapshot from from a persistent disk

1022
00:58:24,950 --> 00:58:28,280
and actually reconstructs the application state, the key-value store,

1023
00:58:28,490 --> 00:58:29,960
and you'll do this in lab 3,

1024
00:58:29,960 --> 00:58:31,430
this is not going to be an issue of lab 2.

1025
00:58:32,140 --> 00:58:35,320
The only thing that there's going to be an issue lab 2 is that,

1026
00:58:35,350 --> 00:58:38,950
because the followers, because the,

1027
00:58:42,290 --> 00:58:44,660
because the log has been cut, right,

1028
00:58:44,660 --> 00:58:48,710
like you know instead of like having all the entries from 0 to i in the log,

1029
00:58:49,260 --> 00:58:52,020
plus more, so i you know n,

1030
00:58:52,680 --> 00:58:56,130
the log is being cut you know from i to n, right,

1031
00:58:57,760 --> 00:59:00,520
and that are part of the log compation,

1032
00:59:01,030 --> 00:59:02,860
but that also means that,

1033
00:59:02,890 --> 00:59:04,870
if a follower is far behind,

1034
00:59:04,900 --> 00:59:07,180
like for example new node joins the system,

1035
00:59:07,360 --> 00:59:12,760
and doesn't actually have the beginning of the log nor the snapshots,

1036
00:59:13,350 --> 00:59:18,600
then the raft has to communicate the snapshot to that follower,

1037
00:59:19,460 --> 00:59:20,210
so in the case that,

1038
00:59:20,210 --> 00:59:22,280
the follower is you know before i,

1039
00:59:22,610 --> 00:59:27,530
because rejoin the lab and rejoin the raft cluster,

1040
00:59:27,650 --> 00:59:33,660
the leader actually has to set the snapshot you know to the follower,

1041
00:59:33,660 --> 00:59:35,310
and the follower basically start from there.

1042
00:59:36,280 --> 00:59:37,780
And that will show up in 2d

1043
00:59:37,780 --> 00:59:40,510
and so there's an additional RPC,

1044
00:59:40,540 --> 00:59:45,070
called the snapshot RPC or install snapshot RPC,

1045
00:59:45,070 --> 00:59:46,690
and that's described in the paper,

1046
00:59:46,720 --> 00:59:48,790
and then you will have to implement in 2d.

1047
00:59:49,810 --> 00:59:53,420
In fact, which brings me to a good point,

1048
00:59:54,040 --> 00:59:57,230
actually, let me go to [],

1049
00:59:57,230 --> 00:59:59,060
basically brings me to the homework question,

1050
00:59:59,210 --> 01:00:10,240
which is here's the install snapshot rpc for equivalent figure 2,

1051
01:00:10,240 --> 01:00:12,490
would then just snapshot RPC,

1052
01:00:12,490 --> 01:00:17,200
and you actually have to implement that in 2d,

1053
01:00:17,560 --> 01:00:19,780
and one issue that came up

1054
01:00:19,780 --> 01:00:23,620
in the which was the homework question for today is,

1055
01:00:23,770 --> 01:00:26,530
is ever possible in raft,

1056
01:00:26,530 --> 01:00:29,500
what avoids it it's not possible,

1057
01:00:29,650 --> 01:00:31,810
that the state machine rolls back,

1058
01:00:32,290 --> 01:00:34,990
you know so for example, leader sends maybe,

1059
01:00:34,990 --> 01:00:38,620
you know maybe an old snapshot shows up you know at a follower,

1060
01:00:39,010 --> 01:00:43,810
is it possible that you know if it's possible,

1061
01:00:43,810 --> 01:00:46,690
if that follower would install that snapshot

1062
01:00:46,690 --> 01:00:49,690
and then implicitly basically roll back the state machine,

1063
01:00:49,750 --> 01:00:51,790
maybe it already has seen more information,

1064
01:00:52,390 --> 01:00:54,610
you know clear that seen not right,

1065
01:00:54,610 --> 01:00:55,990
and so the question is,

1066
01:00:56,290 --> 01:00:58,390
you know how does raft around it,

1067
01:00:58,720 --> 01:01:03,460
and so maybe this is a great place actually do a quick break out,

1068
01:01:03,460 --> 01:01:09,370
and you can debate that homework question for a couple minutes, 5 minutes,

1069
01:01:09,580 --> 01:01:10,930
and then we'll come back,

1070
01:01:11,110 --> 01:01:14,620
and we'll talk about a little bit more about snapshots.

1071
01:01:16,790 --> 01:01:18,560
Lily, will be like?

1072
01:01:19,470 --> 01:01:24,090
No Lily, how about I try, you can.

1073
01:01:24,360 --> 01:01:32,620
Hold on, I'll probably have to make you host,

1074
01:01:32,650 --> 01:01:33,610
and then you can do it,

1075
01:01:35,320 --> 01:01:36,670
okay, you should be host now.

1076
01:01:37,060 --> 01:01:38,320
Awesome.

1077
01:02:06,930 --> 01:02:08,310
Alright, it should be.

1078
01:02:08,400 --> 01:02:10,560
Okay, thank you, thank you [].

1079
01:08:06,790 --> 01:08:09,790
And I'll go ahead and make you, make you host again.

1080
01:08:09,820 --> 01:08:11,110
That'd be great, thank you.

1081
01:08:35,730 --> 01:08:37,320
Let me see, share my screen.

1082
01:08:54,160 --> 01:08:56,230
Okay, everybody back online,

1083
01:08:59,980 --> 01:09:00,880
we're good to go,

1084
01:09:00,880 --> 01:09:03,100
somebody can respond would be great.

1085
01:09:05,080 --> 01:09:07,210
Okay I can hear.

1086
01:09:07,630 --> 01:09:08,200
Okay, great,

1087
01:09:08,260 --> 01:09:11,050
I hear it you know sometimes people,

1088
01:09:11,050 --> 01:09:12,280
because of the breakout rooms here,

1089
01:09:12,280 --> 01:09:14,050
just [] dropped out soon,

1090
01:09:15,280 --> 01:09:22,040
unfortunately, TAs [past] rooms break up hopefully,

1091
01:09:23,080 --> 01:09:24,700
and I don't know exactly what to do about that,

1092
01:09:25,450 --> 01:09:29,050
I guess class of fault tolerance is a little bit unfortunate,

1093
01:09:29,050 --> 01:09:30,520
that people could just drop.

1094
01:09:32,590 --> 01:09:35,320
Okay, so any,

1095
01:09:35,320 --> 01:09:39,520
I think the homework question this time around was reasonable sort of straightforward,

1096
01:09:39,520 --> 01:09:40,840
you know it has to be the case,

1097
01:09:40,840 --> 01:09:44,620
that you know you cannot install an old snapshot,

1098
01:09:44,650 --> 01:09:48,940
because you know service that might have had a more recent snapshot,

1099
01:09:48,940 --> 01:09:50,320
might have responded to the client,

1100
01:09:50,320 --> 01:09:52,090
saying, yeah the operation succeeded,

1101
01:09:52,640 --> 01:09:55,310
and then if you would restore an old snapshot,

1102
01:09:55,310 --> 01:09:57,590
then you basically back out to the state

1103
01:09:57,590 --> 01:09:58,340
and the client would see,

1104
01:09:58,340 --> 01:10:00,170
there's certainly an old version of the server,

1105
01:10:00,170 --> 01:10:02,060
so that's certainly not a legit,

1106
01:10:02,810 --> 01:10:04,490
and so there's a little bit,

1107
01:10:04,550 --> 01:10:06,260
you should definitely reject all snapshots,

1108
01:10:06,260 --> 01:10:08,540
but you have to be a little bit careful,

1109
01:10:08,540 --> 01:10:12,950
if you know the follower has a log that goes beyond the snapshot,

1110
01:10:12,950 --> 01:10:17,390
you have to keep that remained part of the log,

1111
01:10:17,720 --> 01:10:20,510
because basically you have promised to a leader,

1112
01:10:20,510 --> 01:10:22,220
that you have accepted a message,

1113
01:10:22,220 --> 01:10:25,970
and so you can't delete you know the rest of the log,

1114
01:10:25,970 --> 01:10:29,990
that was not covered by the snapshot.

1115
01:10:30,710 --> 01:10:31,220
Okay?

1116
01:10:35,210 --> 01:10:38,210
Okay, so then let me return.

1117
01:10:41,220 --> 01:10:42,960
We had a question, actually.

1118
01:10:42,990 --> 01:10:44,280
Okay, go ahead.

1119
01:10:44,890 --> 01:10:47,860
So it says, it says in the paper, right,

1120
01:10:47,890 --> 01:10:50,290
if the follower receives a snapshot,

1121
01:10:50,470 --> 01:10:52,360
that's a prefix of its log,

1122
01:10:53,620 --> 01:10:58,900
the log entries covered by the snapshot are deleted,

1123
01:10:58,900 --> 01:10:59,950
but the rest are kept.

1124
01:11:00,010 --> 01:11:00,880
Yep.

1125
01:11:01,150 --> 01:11:03,250
In that case,

1126
01:11:04,480 --> 01:11:09,250
is, is the state machine wouldn't be overwrite, right, in this case.

1127
01:11:09,920 --> 01:11:11,480
Okay, so the interesting question is,

1128
01:11:11,480 --> 01:11:17,630
like how does a snapshot get communicated to the state machine,

1129
01:11:17,630 --> 01:11:19,640
and as you'll see in lab 3,

1130
01:11:19,640 --> 01:11:20,990
and it goes over the apply channel,

1131
01:11:22,080 --> 01:11:26,640
and so the state machine will get a snapshot over the apply channel

1132
01:11:27,090 --> 01:11:29,850
and then it's up to it to do the right thing.

1133
01:11:32,030 --> 01:11:32,570
Okay.

1134
01:11:33,060 --> 01:11:33,420
Okay?

1135
01:11:36,370 --> 01:11:37,150
Okay, good.

1136
01:11:37,240 --> 01:11:39,970
So just a follow-up on that, sorry,

1137
01:11:40,270 --> 01:11:41,740
though I was a little bit,

1138
01:11:41,740 --> 01:11:43,000
so that makes sense to me,

1139
01:11:43,060 --> 01:11:44,650
the part that I was confused by is,

1140
01:11:44,650 --> 01:11:51,970
in the, in the figure 13, like the box that describes install snapshot RPC,

1141
01:11:53,000 --> 01:11:54,860
on 6, it's says,

1142
01:11:54,890 --> 01:11:59,480
if existing log entry has the same index and the term as snapshot last included entry,

1143
01:12:04,890 --> 01:12:07,900
well, hold on, I may have just misread it.

1144
01:12:08,050 --> 01:12:10,450
Okay, how about you keep thinking about it, look if.

1145
01:12:10,450 --> 01:12:13,360
I have a question, I'll ask you.

1146
01:12:13,360 --> 01:12:14,080
I'll take it offline

1147
01:12:14,080 --> 01:12:15,670
and we'll do it right after lecture, if you want to.

1148
01:12:16,900 --> 01:12:19,360
Okay, I want to go back actually for a couple minutes,

1149
01:12:19,360 --> 01:12:20,350
you know that we have remaining

1150
01:12:20,350 --> 01:12:22,420
and talk about actually using raft,

1151
01:12:22,780 --> 01:12:25,690
which is sort of a discussion that we're already basically having here,

1152
01:12:27,500 --> 01:12:28,820
for servers,

1153
01:12:28,940 --> 01:12:31,850
and so again I'm going to focus on the replicated key-value service,

1154
01:12:31,850 --> 01:12:33,440
that's going to be the topic of lab 3.

1155
01:12:34,130 --> 01:12:38,570
And so just to go back to almost like one of the first board,

1156
01:12:38,570 --> 01:12:41,660
that I drew at the beginning of the raft lectures,

1157
01:12:41,660 --> 01:12:46,760
here's like our boxes, you know that correspond to the three replicas,

1158
01:12:48,680 --> 01:12:54,330
and each replica correct you know has a sort of split two pieces,

1159
01:12:54,330 --> 01:12:55,650
one is the service part,

1160
01:13:01,180 --> 01:13:04,280
and one is the raft library, right,

1161
01:13:04,280 --> 01:13:08,210
then we know that basically this communicate these two through the apply channel,

1162
01:13:08,660 --> 01:13:12,930
unless the way that information flows from raft to service, service.

1163
01:13:16,000 --> 01:13:20,730
And so clients you know interact you know with the service,

1164
01:13:20,730 --> 01:13:22,140
you not directly the raft,

1165
01:13:22,440 --> 01:13:24,030
so we have a client here,

1166
01:13:24,580 --> 01:13:26,200
you know that sends you know operation,

1167
01:13:26,200 --> 01:13:28,570
like a put operation or get operation to the service,

1168
01:13:28,720 --> 01:13:30,970
the service receives this operation,

1169
01:13:31,120 --> 01:13:36,660
and it basically calls start you know for that operation,

1170
01:13:36,660 --> 01:13:42,060
then raft does it chit chat you know with you know the other raft libraries,

1171
01:13:42,600 --> 01:13:44,340
you know messages can flow back,

1172
01:13:44,340 --> 01:13:45,990
in at some point the operation is committed

1173
01:13:45,990 --> 01:13:48,360
and then it actually is you know raft will say,

1174
01:13:48,360 --> 01:13:50,850
okay, this operation is ready to be committed,

1175
01:13:51,060 --> 01:13:52,560
sends it on the apply channel,

1176
01:13:52,680 --> 01:13:56,880
and service then basically execute the operation and send the response back,

1177
01:13:56,880 --> 01:13:59,670
after it executed the operation, response back to the client,

1178
01:13:59,670 --> 01:14:05,460
saying well, the value or the get you know key 20 you know is this, right,

1179
01:14:05,460 --> 01:14:08,280
so this is a get operation or put,

1180
01:14:09,500 --> 01:14:11,780
and this is basically the value for the get

1181
01:14:11,810 --> 01:14:14,090
or you know ok put succeeded.

1182
01:14:14,660 --> 01:14:15,050
Okay?

1183
01:14:15,750 --> 01:14:17,820
And we also discovered in the last lecture,

1184
01:14:18,300 --> 01:14:20,280
it might be the case,

1185
01:14:20,280 --> 01:14:24,060
that the client sends an RPC to the service

1186
01:14:24,060 --> 01:14:25,920
and the RPC disappears,

1187
01:14:26,040 --> 01:14:27,930
so the client must yeah must resend,

1188
01:14:28,420 --> 01:14:30,370
and by the time the resends actually,

1189
01:14:30,370 --> 01:14:32,350
you know the leader might not be the leader anymore.

1190
01:14:33,080 --> 01:14:34,160
And so in that case,

1191
01:14:34,160 --> 01:14:36,560
it has to sort of redirect itself to another leader,

1192
01:14:37,070 --> 01:14:38,930
so basically there is a little bit of code

1193
01:14:38,930 --> 01:14:40,130
you know the way to think about this.

1194
01:14:40,620 --> 01:14:42,570
There's a little bit of code at the client side,

1195
01:14:42,690 --> 01:14:46,410
sort of understands replicated state machines a little bit,

1196
01:14:46,410 --> 01:14:48,060
and it maintains some information,

1197
01:14:48,060 --> 01:14:49,680
it maintains like who's the leader,

1198
01:14:49,980 --> 01:14:52,020
and who are the other followers,

1199
01:14:52,540 --> 01:14:56,020
and so that can switch between them, if necessary.

1200
01:14:57,690 --> 01:14:58,320
We also,

1201
01:14:58,320 --> 01:15:00,990
last time we talked a little bit about its possible,

1202
01:15:00,990 --> 01:15:03,270
that you know operation can be duplicated, right,

1203
01:15:03,270 --> 01:15:09,050
because you know the, the client may send an operation put operation to the service,

1204
01:15:09,350 --> 01:15:14,210
in the you know the client doesn't get a response,

1205
01:15:14,450 --> 01:15:16,100
but the service actually received,

1206
01:15:16,100 --> 01:15:20,750
so it went through, you know went through the whole operation sequence,

1207
01:15:20,750 --> 01:15:24,530
you know starting the raft appends,

1208
01:15:24,530 --> 01:15:26,600
you know go through the raft [motion],

1209
01:15:26,600 --> 01:15:28,310
and then basically sending it out to apply channel.

1210
01:15:28,890 --> 01:15:31,620
And so basically the client actually might send a second one,

1211
01:15:33,240 --> 01:15:36,540
and you know the basically for the repetition,

1212
01:15:36,540 --> 01:15:40,860
you know that might actually go through you know the raft library too,

1213
01:15:40,860 --> 01:15:42,030
comes out in the apply channel,

1214
01:15:42,030 --> 01:15:44,850
and so you know have to do some duplicate detection, detection

1215
01:15:44,850 --> 01:15:46,140
and there multiple ways of doing it,

1216
01:15:46,140 --> 01:15:47,850
but either way you have to duplicate detection.

1217
01:15:48,520 --> 01:15:51,910
So, in addition to a sort of maintain state,

1218
01:15:51,910 --> 01:15:55,180
about like what the leader and the followers are,

1219
01:15:55,330 --> 01:15:57,850
put and get also actually have an id,

1220
01:15:58,340 --> 01:15:59,990
you know an id associated with it,

1221
01:15:59,990 --> 01:16:02,840
and we're going to maintain what is the last id,

1222
01:16:02,840 --> 01:16:04,580
that it actually is trying to get through,

1223
01:16:04,730 --> 01:16:07,160
and that is used to actually duplicate detection.

1224
01:16:08,560 --> 01:16:11,110
And this little piece of code is often called a clerk,

1225
01:16:11,880 --> 01:16:14,760
you know the clerk that interacts with the service,

1226
01:16:14,760 --> 01:16:16,110
and it does a little bit of work

1227
01:16:16,110 --> 01:16:18,510
to collaborate with the service you actually get the [] done,

1228
01:16:18,510 --> 01:16:20,220
and so we have multiple clients,

1229
01:16:20,870 --> 01:16:27,320
all have clerk of library, if you will, just Go package,

1230
01:16:27,560 --> 01:16:33,120
and you know the clients basically talk puts and gets you know over that interface,

1231
01:16:33,120 --> 01:16:35,850
and inside of the clerk actually maintains these ids

1232
01:16:36,150 --> 01:16:39,720
or maintains one id for the outstanding you know put get operation

1233
01:16:39,720 --> 01:16:42,510
as well as some information about who's part of the cluster.

1234
01:16:43,060 --> 01:16:43,540
Okay?

1235
01:16:44,560 --> 01:16:45,340
Does that make sense?

1236
01:16:46,090 --> 01:16:47,710
So that's sort of the basic structure, correct,

1237
01:16:47,710 --> 01:16:50,260
like how raft fits into a larger picture.

1238
01:16:51,520 --> 01:16:54,820
The one question that comes always up is,

1239
01:16:54,820 --> 01:16:56,950
what you know what is the guarantees

1240
01:16:56,980 --> 01:17:01,660
you know that the service and the clerk together make to the clients

1241
01:17:01,660 --> 01:17:03,220
about these put and get operations.

1242
01:17:05,040 --> 01:17:07,800
So this really means what is the correctness criteria.

1243
01:17:11,940 --> 01:17:15,570
And the way, we always have described so far,

1244
01:17:15,570 --> 01:17:17,010
we've been reasonable [sloppy] about it,

1245
01:17:17,190 --> 01:17:18,840
or I sloppy about it,

1246
01:17:19,200 --> 01:17:20,820
and basically I said is like,

1247
01:17:20,820 --> 01:17:23,770
well, should behave like a single machine,

1248
01:17:32,820 --> 01:17:35,370
even that, there's a little bit of an imprecise definition,

1249
01:17:35,370 --> 01:17:36,180
because what happens,

1250
01:17:36,180 --> 01:17:40,290
if two clients basically at the same time you know execute a put or a get operation,

1251
01:17:40,290 --> 01:17:43,740
and what actually is the correct outcome of these operations,

1252
01:17:43,740 --> 01:17:45,960
so we really need to sort of a little bit more preciser,

1253
01:17:45,990 --> 01:17:46,860
you know I think like,

1254
01:17:47,190 --> 01:17:49,320
maybe like a single machine is the right intuition,

1255
01:17:49,320 --> 01:17:52,050
but we need a little bit preciser definition.

1256
01:17:52,500 --> 01:17:56,370
And this definition you saw the term used in the paper,

1257
01:17:56,460 --> 01:17:59,100
this definition is called linearizability,

1258
01:18:04,410 --> 01:18:07,290
linearizability basically spec specification

1259
01:18:07,290 --> 01:18:11,340
of what values put and get operations can return,

1260
01:18:11,870 --> 01:18:15,260
particularly those in since put realy return operations really,

1261
01:18:15,260 --> 01:18:16,550
what get can actually return,

1262
01:18:17,250 --> 01:18:20,730
and it basically says, what are allowed things to be return,

1263
01:18:20,730 --> 01:18:22,680
what are things that are not allowed to be return,

1264
01:18:22,710 --> 01:18:24,570
independent by actually how you implement it,

1265
01:18:24,840 --> 01:18:26,550
it's just like purely specification.

1266
01:18:27,660 --> 01:18:30,540
And it basically has three components you know linearizability,

1267
01:18:31,530 --> 01:18:33,390
linearizability says,

1268
01:18:33,390 --> 01:18:35,670
if you have look at some sequence of operations,

1269
01:18:35,700 --> 01:18:37,590
and some of them executed currently,

1270
01:18:37,890 --> 01:18:38,820
it has to be the case,

1271
01:18:38,820 --> 01:18:39,930
that there's a total order,

1272
01:18:40,080 --> 01:18:42,990
so you can arrange all the operation in some total order,

1273
01:18:52,350 --> 01:18:53,670
put or set operations.

1274
01:18:55,730 --> 01:18:59,720
Two, it has to match real-time,

1275
01:19:06,260 --> 01:19:07,580
with that, I mean that,

1276
01:19:07,580 --> 01:19:11,690
if an operation completed before the second operation started,

1277
01:19:12,520 --> 01:19:15,400
even if those operations are on different machines,

1278
01:19:15,400 --> 01:19:17,740
it has to be the case that in this total order,

1279
01:19:17,950 --> 01:19:21,160
the first operation shows up before the second operation,

1280
01:19:24,280 --> 01:19:25,420
and that sort of makes sense, right,

1281
01:19:25,420 --> 01:19:26,950
like if it behaves like a single machine,

1282
01:19:26,950 --> 01:19:29,590
and you start an operation after another operation,

1283
01:19:29,860 --> 01:19:34,300
then the single machine would always return the results of the first operation, so.

1284
01:19:34,630 --> 01:19:36,370
And finally the read operation,

1285
01:19:37,090 --> 01:19:38,320
so this is like in our case,

1286
01:19:38,320 --> 01:19:41,140
key-value server only has one read operation [] get,

1287
01:19:41,560 --> 01:19:50,190
but the read operation should always return the results of the last write.

1288
01:19:56,040 --> 01:19:57,360
So in our case,

1289
01:19:57,360 --> 01:19:59,280
you know we do get operation

1290
01:19:59,280 --> 01:20:04,530
and the put operation happened well before it

1291
01:20:04,530 --> 01:20:06,210
and completed well before,

1292
01:20:06,210 --> 01:20:12,540
then that get operation should observe the last, should observe the last put.

1293
01:20:12,940 --> 01:20:13,480
Okay?

1294
01:20:14,020 --> 01:20:17,560
So this sort of, these are three conditions,

1295
01:20:17,560 --> 01:20:21,340
you know that will determine whether system actually linearizability.

1296
01:20:21,990 --> 01:20:24,510
And you can think about the linearizability as well,

1297
01:20:24,510 --> 01:20:25,860
just behave like a single machine.

1298
01:20:26,530 --> 01:20:28,510
So let me make a little bit more concrete,

1299
01:20:28,510 --> 01:20:29,830
because there's a little bit abstract.

1300
01:20:30,610 --> 01:20:35,260
And the way basically people think about linearizability

1301
01:20:35,260 --> 01:20:37,420
or argue that the system has linearizability

1302
01:20:37,420 --> 01:20:40,360
is looking at particular histories or executions

1303
01:20:40,630 --> 01:20:46,230
and then see if you can use histories,

1304
01:20:46,230 --> 01:20:48,150
if you can turn that into total order,

1305
01:20:48,180 --> 01:20:52,110
even though the operations actually might have actually executed concurrently.

1306
01:20:52,790 --> 01:20:55,970
So let me give you one example, a trivial example,

1307
01:20:56,690 --> 01:21:00,920
so let's say we have three clients C1 C2 C3,

1308
01:21:01,250 --> 01:21:02,780
and they do a bunch of puts and gets,

1309
01:21:03,390 --> 01:21:05,730
so you know typically the way you know,

1310
01:21:05,730 --> 01:21:09,150
basically it has to be some start point where the operation started,

1311
01:21:09,900 --> 01:21:12,360
and there's some endpoint where the operation ends.

1312
01:21:12,960 --> 01:21:18,060
So, for example when actually the client actually gets the return from the service,

1313
01:21:18,840 --> 01:21:23,070
and so let's say this write operation you know to value to the variable x,

1314
01:21:23,560 --> 01:21:24,670
and we write 1 to it.

1315
01:21:25,830 --> 01:21:27,540
So the client 1 started at some point,

1316
01:21:27,540 --> 01:21:30,060
the write operation to the variable x to write 1,

1317
01:21:30,390 --> 01:21:32,580
and ends at some point here.

1318
01:21:33,330 --> 01:21:40,080
Maybe the second one and write 2 to it.

1319
01:21:40,600 --> 01:21:42,610
And then maybe we have all the action

1320
01:21:42,610 --> 01:21:44,020
and with linearizability is,

1321
01:21:44,020 --> 01:21:45,490
when operation happens concurrently,

1322
01:21:45,490 --> 01:21:49,120
so some operations starts before another one actually finishes,

1323
01:21:49,120 --> 01:21:52,090
so for example we might have the following operation,

1324
01:21:52,090 --> 01:21:53,440
client 2 does a read operation,

1325
01:21:53,440 --> 01:21:54,910
in our case, would be a get,

1326
01:21:55,600 --> 01:21:57,790
and there's a read of x,

1327
01:21:57,790 --> 01:21:59,980
and the value returned by this operation is 2.

1328
01:22:00,940 --> 01:22:03,670
And then we have a similar sort of situation,

1329
01:22:03,670 --> 01:22:05,620
where client 3 it actually starts an operation,

1330
01:22:05,620 --> 01:22:09,960
a read operation, and reads x and it returns 1,

1331
01:22:11,370 --> 01:22:13,980
let me make this a little bit more clean,

1332
01:22:15,660 --> 01:22:18,460
the read operation actually returns

1333
01:22:18,460 --> 01:22:21,910
before you know the write 2 operation starts or ends,

1334
01:22:22,180 --> 01:22:24,100
and same from Rx1,

1335
01:22:24,100 --> 01:22:25,780
and then the question that always comes up,

1336
01:22:26,020 --> 01:22:29,410
is this linearizability, is this linearizability execution.

1337
01:22:30,800 --> 01:22:32,480
And if linearizability,

1338
01:22:32,480 --> 01:22:33,680
then basically it means like,

1339
01:22:33,710 --> 01:22:35,720
this could happen on a single machine too.

1340
01:22:37,000 --> 01:22:38,920
So could this happen on a single machine?

1341
01:22:39,940 --> 01:22:41,770
We can just like abstract think about it,

1342
01:22:41,770 --> 01:22:42,910
without actually having,

1343
01:22:45,220 --> 01:22:46,600
is this legit outcome from,

1344
01:22:46,600 --> 01:22:50,980
basically we need to look at is the outcomes of R2 and C2 and C3,

1345
01:22:51,220 --> 01:22:53,710
you know is this a legit execution.

1346
01:22:54,520 --> 01:22:56,500
I'm not sure,

1347
01:22:56,500 --> 01:22:57,580
I don't really know what it means

1348
01:22:57,580 --> 01:23:01,420
for write to take like a long time.

1349
01:23:03,030 --> 01:23:03,390
Well.

1350
01:23:03,390 --> 01:23:05,400
Take a long time for that matter.

1351
01:23:06,070 --> 01:23:09,820
If you think about the from the client perspective,

1352
01:23:09,820 --> 01:23:12,490
it sends a request to the service,

1353
01:23:12,490 --> 01:23:13,960
so that's the starting of the write,

1354
01:23:14,550 --> 01:23:18,450
and I've got a return value at some point from the service

1355
01:23:18,450 --> 01:23:19,650
and that's the end of the write.

1356
01:23:20,960 --> 01:23:22,910
And so in between all kinds of stuff happens, right,

1357
01:23:22,910 --> 01:23:24,290
it actually to the service,

1358
01:23:24,290 --> 01:23:25,940
the service put into raft,

1359
01:23:25,940 --> 01:23:28,370
raft went to apply channel blah blah blah,

1360
01:23:28,400 --> 01:23:29,270
lots of stuff happened,

1361
01:23:29,300 --> 01:23:30,470
we really care about exactly,

1362
01:23:30,470 --> 01:23:32,720
what the implementation does at some point a response.

1363
01:23:34,120 --> 01:23:35,290
And so you can think about this,

1364
01:23:35,290 --> 01:23:37,450
you know there's basically three concurrent clients,

1365
01:23:37,450 --> 01:23:39,850
you know they issued concurrent operations,

1366
01:23:39,850 --> 01:23:41,980
and we are wondering if this is actually legit outcome.

1367
01:23:44,900 --> 01:23:48,440
I don't think this could happen on a single machine,

1368
01:23:48,440 --> 01:23:56,990
because the write for 2 it finishes after the read start,

1369
01:23:57,750 --> 01:23:59,850
oh, sorry, yeah yeah that's right,

1370
01:23:59,940 --> 01:24:03,780
but it seems like the write should happen before the read,

1371
01:24:04,350 --> 01:24:06,960
and in this situation,

1372
01:24:09,130 --> 01:24:12,010
it couldn't happen, if the write started after,

1373
01:24:12,580 --> 01:24:16,540
if the write finished after the read start, yeah.

1374
01:24:16,930 --> 01:24:20,950
Yeah, so one would think, one way to think about is that,

1375
01:24:21,160 --> 01:24:22,120
we can move,

1376
01:24:22,150 --> 01:24:24,370
you know we have to construct a total order,

1377
01:24:24,700 --> 01:24:26,230
and we can construct a total order,

1378
01:24:26,230 --> 01:24:28,240
where all the operations line up,

1379
01:24:28,480 --> 01:24:30,820
then you know it's a valid linearizable history.

1380
01:24:31,290 --> 01:24:33,870
And so, so let's construct a total order,

1381
01:24:33,990 --> 01:24:36,150
and then go back to this question you just asked,

1382
01:24:36,840 --> 01:24:40,470
so a total order, here's a total order, that I gonna,

1383
01:24:41,240 --> 01:24:43,310
so I'm going to do first the write operation,

1384
01:24:43,520 --> 01:24:52,160
then Rx1, then the Wx2, and then Rx Rx2, right.

1385
01:24:52,720 --> 01:24:53,620
It's a total order,

1386
01:24:53,620 --> 01:24:56,020
all the operations are now happening sequentially,

1387
01:24:56,660 --> 01:25:00,620
and you know we need to check whether this total order is correct,

1388
01:25:00,980 --> 01:25:03,290
corresponding to the linearizability definitions,

1389
01:25:03,500 --> 01:25:04,580
well, it has to be the case,

1390
01:25:04,580 --> 01:25:06,080
that operations that start,

1391
01:25:06,700 --> 01:25:10,060
if an operation starts after some other operation,

1392
01:25:10,060 --> 01:25:12,280
ends it needs to be after in the total order.

1393
01:25:12,280 --> 01:25:13,840
And so we look at this,

1394
01:25:14,370 --> 01:25:15,240
let's look at the this,

1395
01:25:15,240 --> 01:25:19,050
this one must start after Wx1,

1396
01:25:19,050 --> 01:25:21,630
and that is true correct in this totally order,

1397
01:25:23,210 --> 01:25:29,170
Rx1 must you start after Wx1,

1398
01:25:29,170 --> 01:25:31,690
because it actually returns you know the value, right,

1399
01:25:31,690 --> 01:25:34,300
then exactly in total order, that is also the case,

1400
01:25:35,360 --> 01:25:38,210
Rx2 you know must start after Wx2,

1401
01:25:38,210 --> 01:25:41,760
because it observes the result of this write,

1402
01:25:41,790 --> 01:25:43,920
and you know that's perfectly fine too, right,

1403
01:25:44,750 --> 01:25:45,560
we can basically,

1404
01:25:45,560 --> 01:25:47,120
one way to think about it is that,

1405
01:25:47,120 --> 01:25:49,190
you know even though they executed this way,

1406
01:25:49,190 --> 01:25:50,600
we've got to rearrange things

1407
01:25:50,600 --> 01:25:53,420
to sort of fit the total order.

1408
01:25:54,140 --> 01:25:56,390
And so, if we think about this,

1409
01:25:56,510 --> 01:25:59,540
then this is a totally legit execution,

1410
01:26:00,140 --> 01:26:02,840
where you know the operation [] of the order,

1411
01:26:02,930 --> 01:26:05,360
and so this is like what a single machine would do,

1412
01:26:05,360 --> 01:26:10,160
so a single machine could executed Wx1, Rx1, Wx2, Rx2

1413
01:26:10,460 --> 01:26:11,660
and all perfectly fine.

1414
01:26:14,390 --> 01:26:14,990
Okay?

1415
01:26:15,710 --> 01:26:17,960
So let me make it helpful to think about

1416
01:26:17,960 --> 01:26:19,850
history that is not linearizable.

1417
01:26:20,720 --> 01:26:22,340
So let me look at the second one,

1418
01:26:29,360 --> 01:26:32,750
and I'm gonna come back on this on the first one anyway,

1419
01:26:32,750 --> 01:26:35,720
so don't worry if this not makes sense yet,

1420
01:26:35,960 --> 01:26:37,160
but here's another one.

1421
01:26:37,520 --> 01:26:39,170
I got C1,

1422
01:26:40,060 --> 01:26:43,240
same thing Wx1,

1423
01:26:43,840 --> 01:26:48,670
I got and here Wx2

1424
01:26:48,670 --> 01:26:56,750
and and there's gonna be a read that actually goes in x1,

1425
01:26:57,730 --> 01:26:59,980
and I'm sorry Rx2,

1426
01:27:00,950 --> 01:27:04,100
and then I got C2 C3

1427
01:27:04,670 --> 01:27:12,340
and the C3 start after the other read and returns 1.

1428
01:27:14,610 --> 01:27:16,860
And the [] here is that,

1429
01:27:17,310 --> 01:27:20,250
it's not possible to construct a total order

1430
01:27:20,280 --> 01:27:22,920
you know matches linearizability,

1431
01:27:23,480 --> 01:27:26,120
and in one way,

1432
01:27:26,120 --> 01:27:29,930
one indication of this is that this read returned x1,

1433
01:27:30,050 --> 01:27:33,110
started after the read that returned 2,

1434
01:27:33,790 --> 01:27:35,890
and I will make this a little bit more precise later,

1435
01:27:35,890 --> 01:27:39,130
but in a real you know single machine system,

1436
01:27:39,160 --> 01:27:40,750
that could have never happened, right,

1437
01:27:40,750 --> 01:27:42,730
because that would have meant,

1438
01:27:42,730 --> 01:27:46,150
that the value changed between Rx2 and Rx1,

1439
01:27:46,450 --> 01:27:50,830
and and you know with these few operations that we have on the board,

1440
01:27:50,920 --> 01:27:52,270
that has to be the case that,

1441
01:27:53,090 --> 01:27:56,150
this Rx1 happened after that write,

1442
01:27:57,260 --> 01:28:01,820
and this write must have happened after that write,

1443
01:28:02,090 --> 01:28:03,200
because they're in total,

1444
01:28:03,200 --> 01:28:07,490
there, we have to respect you know the ordering of the single of C1,

1445
01:28:08,360 --> 01:28:12,950
and so there's no way to basically slot you know Rx1 in the total order,

1446
01:28:13,010 --> 01:28:18,860
you know according to this picture, it should go after Rx1,

1447
01:28:19,420 --> 01:28:23,230
and but that can really not be true,

1448
01:28:23,560 --> 01:28:26,260
because if it got after Rx1,

1449
01:28:26,260 --> 01:28:28,480
that names also after Wx2,

1450
01:28:28,510 --> 01:28:32,590
so that must have write 2 and not 1.

1451
01:28:33,740 --> 01:28:35,690
So this is not a linearizability,

1452
01:28:35,720 --> 01:28:39,580
not a linearizable history in execution.

1453
01:28:45,820 --> 01:28:47,410
Another way of saying that is that,

1454
01:28:47,590 --> 01:28:50,080
this is what, what is Rx in returning here,

1455
01:28:50,110 --> 01:28:53,430
really returning stale value, right,

1456
01:28:53,430 --> 01:28:54,690
and that is not allowed,

1457
01:28:57,940 --> 01:28:59,620
if the machine behaves like a single machine

1458
01:28:59,620 --> 01:29:01,600
or replicated server behaves like a single machine.

1459
01:29:02,520 --> 01:29:04,140
And so I'm gonna go back you know this,

1460
01:29:04,140 --> 01:29:06,660
to on the lecture when next week,

1461
01:29:06,660 --> 01:29:07,890
when we talk about zookeeper,

1462
01:29:08,160 --> 01:29:10,260
because this is going to be very important,

1463
01:29:10,260 --> 01:29:11,730
this notion of linearizability,

1464
01:29:11,730 --> 01:29:14,400
sort of thing that shows up [] in the paper,

1465
01:29:14,550 --> 01:29:17,640
and this notion of stale values also shows up [].

1466
01:29:19,800 --> 01:29:21,600
And since I'm running out of time and [],

1467
01:29:21,600 --> 01:29:23,370
I'll resume that next week.

1468
01:29:24,540 --> 01:29:25,230
Okay?

1469
01:29:29,260 --> 01:29:30,520
Any further questions

1470
01:29:30,520 --> 01:29:32,920
and people need to leave, please feel free to leave,

1471
01:29:33,040 --> 01:29:34,900
in fact I hope you did,

1472
01:29:35,320 --> 01:29:39,100
I don't want to make responsible that you miss other classes.

1473
01:29:40,230 --> 01:29:42,560
Is this a consider,

1474
01:29:42,560 --> 01:29:47,430
like what type of consistency is considered to be strong consistency.

1475
01:29:47,640 --> 01:29:51,630
This considered to be basically strong consistency,

1476
01:29:52,360 --> 01:29:57,280
and what it really is sort of a precise definition of what strong consistency is,

1477
01:29:58,360 --> 01:30:01,150
so like our intuition about what strong consistency is,

1478
01:30:01,150 --> 01:30:03,040
namely behaving like a single machine,

1479
01:30:03,040 --> 01:30:07,300
that the precise definition that people use in the technical literature is linearizability.

1480
01:30:12,420 --> 01:30:17,010
How did they decide to have that property,

1481
01:30:17,010 --> 01:30:19,590
like why did they decide to have that property?

1482
01:30:19,830 --> 01:30:21,270
There's a couple things,

1483
01:30:21,270 --> 01:30:23,940
one reason, the reason,

1484
01:30:23,940 --> 01:30:25,590
okay, so it makes sort of sense,

1485
01:30:25,590 --> 01:30:27,780
you know if you think from this point of view,

1486
01:30:28,730 --> 01:30:29,780
like you want to behave,

1487
01:30:29,780 --> 01:30:32,900
you want to make a replicated system behave like a single machine

1488
01:30:33,700 --> 01:30:35,290
or replicated machine,

1489
01:30:35,290 --> 01:30:36,910
and you want to only allow outcomes

1490
01:30:36,910 --> 01:30:39,970
that actually correspond to executions that the single machine could have done,

1491
01:30:40,210 --> 01:30:44,260
the [] linearizability are very intuitive definition for that.

1492
01:30:45,020 --> 01:30:49,280
The database world has also some other terminology like serializability,

1493
01:30:49,280 --> 01:30:52,550
this is also a term that will show up in the term later,

1494
01:30:52,910 --> 01:30:57,560
and basically the only difference between sort of linearizability and serializability is

1495
01:30:57,560 --> 01:31:01,010
that serializability doesn't require that matches real-time.

1496
01:31:02,980 --> 01:31:06,310
And so people have different definitions of strong consistency,

1497
01:31:06,310 --> 01:31:10,540
if you will and the one that we'll see most probably is linearizability,

1498
01:31:10,540 --> 01:31:13,150
which corresponds closest to like the machine behaves,

1499
01:31:13,150 --> 01:31:15,160
that replicates server behaves like a single machine.

1500
01:31:20,750 --> 01:31:21,590
Thank you.

1501
01:31:21,770 --> 01:31:22,430
You're welcome.

1502
01:31:24,760 --> 01:31:25,900
I have a question about,

1503
01:31:27,530 --> 01:31:30,860
what happens during a network partition,

1504
01:31:31,880 --> 01:31:35,780
so I know like so if a leader gets partitioned completely on their own,

1505
01:31:36,020 --> 01:31:37,340
they'll eventually climb out,

1506
01:31:37,340 --> 01:31:42,350
but if they have sort of like a few followers with them,

1507
01:31:42,380 --> 01:31:43,910
they'll stay the leader,

1508
01:31:44,480 --> 01:31:45,830
and they won't be able to commit anything,

1509
01:31:45,830 --> 01:31:47,030
because they'll be in a minority,

1510
01:31:47,450 --> 01:31:48,410
and they'll be a new leader,

1511
01:31:48,410 --> 01:31:48,890
and they'll be,

1512
01:31:48,980 --> 01:31:53,770
so will that leader ever sort of recognize,

1513
01:31:53,770 --> 01:31:55,420
that maybe it's a stale leader,

1514
01:31:55,630 --> 01:31:57,100
or do we just assume that,

1515
01:31:57,310 --> 01:31:59,620
eventually if the partition goes away,

1516
01:32:01,820 --> 01:32:02,810
it'll figure out,

1517
01:32:02,810 --> 01:32:05,600
because I'm worried if there's a client that's talking to the stale leader,

1518
01:32:06,320 --> 01:32:07,550
what does that client do.

1519
01:32:09,450 --> 01:32:11,430
The no,

1520
01:32:11,430 --> 01:32:14,040
okay so this is a great question with this picture here,

1521
01:32:14,040 --> 01:32:14,940
hopefully it will help,

1522
01:32:15,560 --> 01:32:19,010
so the client talks to talk to this guy, correct,

1523
01:32:19,010 --> 01:32:19,970
like who's the leader,

1524
01:32:20,640 --> 01:32:21,480
you see the picture,

1525
01:32:21,510 --> 01:32:23,010
I just double check, you can see.

1526
01:32:23,010 --> 01:32:24,270
I can see it.

1527
01:32:24,360 --> 01:32:26,670
So let's say you know this first box is the leader,

1528
01:32:26,790 --> 01:32:28,110
client talks to that leader,

1529
01:32:28,320 --> 01:32:30,840
the leader can't commit any operations, right,

1530
01:32:31,690 --> 01:32:34,810
and so it won't commit anything on the apply channel,

1531
01:32:34,810 --> 01:32:37,210
and so it will never respond to the client, right,

1532
01:32:37,540 --> 01:32:40,960
because there's no operation, actually its operations are not being executed,

1533
01:32:41,660 --> 01:32:44,780
so the client will just retry, just keep retrying forever,

1534
01:32:46,230 --> 01:32:50,460
until, you know until the client actually maybe tries another,

1535
01:32:50,460 --> 01:32:54,700
you know one of the other followers, correct,

1536
01:32:54,700 --> 01:32:58,540
that maintains you know who else is actually in the group,

1537
01:32:58,880 --> 01:33:03,320
or until the network heals,

1538
01:33:04,660 --> 01:33:06,790
and the leader actually commit an operation.

1539
01:33:06,970 --> 01:33:07,510
Gotcha,

1540
01:33:07,540 --> 01:33:10,540
wait, so doesn't doesn't the leader immediately reply those,

1541
01:33:10,540 --> 01:33:12,040
saying I got your request

1542
01:33:12,680 --> 01:33:14,240
or does it wait until committed.

1543
01:33:14,870 --> 01:33:18,140
No in lab 3, it doesn't commit with a client

1544
01:33:18,140 --> 01:33:20,030
until that actually has processed the request,

1545
01:33:20,640 --> 01:33:23,850
and which means that the operation actually has run through raft,

1546
01:33:23,850 --> 01:33:25,260
and come out of the apply channel

1547
01:33:25,260 --> 01:33:26,940
and [] executed by the service.

1548
01:33:27,630 --> 01:33:28,290
Okay.

1549
01:33:33,330 --> 01:33:33,750
Does that makes sense?

1550
01:33:33,750 --> 01:33:36,450
Yeah, so the client could just implement a timeout,

1551
01:33:36,450 --> 01:33:38,340
where like if a certain amount of time

1552
01:33:38,340 --> 01:33:39,930
and they haven't received the commit,

1553
01:33:40,020 --> 01:33:42,420
assume that maybe I should try a different node,

1554
01:33:42,600 --> 01:33:44,430
and then if it gets the new leader

1555
01:33:44,430 --> 01:33:46,020
or follower of the new leader,

1556
01:33:46,200 --> 01:33:48,570
it'll be back to normal.

1557
01:33:48,570 --> 01:33:52,260
For example, this clerk that's exactly what this clerk does,

1558
01:33:52,780 --> 01:33:56,470
you know the place along with the service to actually do what you just said.

1559
01:33:56,950 --> 01:34:00,460
Got it, okay, thank you.

1560
01:34:01,070 --> 01:34:01,580
You're welcome.

1561
01:34:02,410 --> 01:34:04,480
Sorry, can you repeat again, what the clerk does?

1562
01:34:05,640 --> 01:34:08,070
The clerk is a little bit of a stub,

1563
01:34:08,070 --> 01:34:11,130
where like a little library that the client links with,

1564
01:34:11,400 --> 01:34:12,840
and the client calls puts and gets,

1565
01:34:13,170 --> 01:34:16,410
and the clerk actually is the interface that it talks to

1566
01:34:16,410 --> 01:34:18,090
and the clerk can keep some information,

1567
01:34:18,630 --> 01:34:22,410
like who's part of the raft cluster,

1568
01:34:22,560 --> 01:34:25,170
and so where who's the leader and who are the followers,

1569
01:34:25,170 --> 01:34:27,360
at least what it thinks is the leader and the followers,

1570
01:34:28,210 --> 01:34:32,260
and when it sends an RPC you know to the service,

1571
01:34:32,260 --> 01:34:33,400
you know sends to the leader,

1572
01:34:33,400 --> 01:34:34,720
what it thinks is the current leader,

1573
01:34:35,580 --> 01:34:38,790
and the service in the, whatever thinks the current leader,

1574
01:34:38,790 --> 01:34:40,080
the leader might actually respond saying,

1575
01:34:40,080 --> 01:34:42,300
like hey, I'm not the leader, should send somewhere else,

1576
01:34:42,910 --> 01:34:46,060
and then it will try one of the others and updates its information.

1577
01:34:46,640 --> 01:34:51,230
And also we'll tag every put and get operation,

1578
01:34:51,230 --> 01:34:52,550
that it receives from the client,

1579
01:34:52,550 --> 01:34:54,710
and that sends to the service with a unique id,

1580
01:34:55,130 --> 01:34:58,430
so that the service can do duplicate detection.

1581
01:34:59,460 --> 01:35:00,900
And this all comes up in lab 3,

1582
01:35:00,900 --> 01:35:03,690
so you know you'll see there,

1583
01:35:04,690 --> 01:35:06,520
in lab 2, there's no real clerk,

1584
01:35:07,070 --> 01:35:10,820
because the tester basically sort of sits on top of the directly of the raft interface,

1585
01:35:10,820 --> 01:35:13,130
and doesn't really interact through the clerk,

1586
01:35:13,130 --> 01:35:15,200
but in lab 3 will interact through the clerk.

1587
01:35:16,320 --> 01:35:19,470
So how do the clients generate unique ids,

1588
01:35:20,100 --> 01:35:21,930
I think they conflict with each other.

1589
01:35:22,050 --> 01:35:24,000
Random, big random numbers.

1590
01:35:25,660 --> 01:35:27,520
Alright, so we're just guessing and hoping,

1591
01:35:27,550 --> 01:35:31,090
rather than actually guaranteeing, some sort of like incremental.

1592
01:35:31,300 --> 01:35:33,130
One way to make it more guaranteed,

1593
01:35:33,130 --> 01:35:37,030
for example, take your IP address and append a random number.

1594
01:35:41,070 --> 01:35:43,440
A question about the homework question?

1595
01:35:43,560 --> 01:35:43,980
Yeah.

1596
01:35:44,250 --> 01:35:46,530
So I thought that it could go backwards in time,

1597
01:35:46,530 --> 01:35:47,700
like I read the paper,

1598
01:35:47,700 --> 01:35:51,420
and it says on page 12 [],

1599
01:35:51,420 --> 01:35:54,300
it said that if there's a conflict, right,

1600
01:35:54,300 --> 01:35:56,880
then the follower just discards its entire log

1601
01:35:56,880 --> 01:35:58,920
and it's also preceded by the snapshot,

1602
01:36:00,110 --> 01:36:02,210
so I wonder why.

1603
01:36:02,330 --> 01:36:06,290
Again, let me, let me guess,

1604
01:36:06,290 --> 01:36:09,170
I I don't really know exactly [] what you're referring to,

1605
01:36:09,170 --> 01:36:10,160
I have to look it up again.

1606
01:36:10,460 --> 01:36:12,320
Oh, it's on page 12,

1607
01:36:12,320 --> 01:36:16,040
it's at the it's towards the end of page 12 the second column here,

1608
01:36:16,040 --> 01:36:17,750
so the second to last paragraph.

1609
01:36:18,230 --> 01:36:21,290
So the log can go back, right, but not the state machine.

1610
01:36:21,500 --> 01:36:25,340
Not, oh, the log can, the log can go back, but not the state machine,

1611
01:36:25,460 --> 01:36:28,910
oh, the state machine like what you the committed entries, right.

1612
01:36:30,320 --> 01:36:32,690
Yeah, the yes, the log can go back,

1613
01:36:32,690 --> 01:36:36,140
because of the uncommitted entries we can go back,

1614
01:36:36,140 --> 01:36:38,630
this is like this whole erase stuff that we talked about earlier.

1615
01:36:40,560 --> 01:36:45,180
Okay, so actually the log can go back, not the state machine,

1616
01:36:45,180 --> 01:36:48,150
which is basically what you committed already.

1617
01:36:48,390 --> 01:36:51,390
Yeah and the log can never go, will never go back,

1618
01:36:51,420 --> 01:36:53,700
never [] of committed operations, right,

1619
01:36:53,700 --> 01:36:56,760
it can only [] erased uncommitted operations.

1620
01:36:56,790 --> 01:36:59,490
Yes, that's right, okay.

1621
01:36:59,580 --> 01:37:00,930
So that's what you ask question.

1622
01:37:01,620 --> 01:37:04,200
Can I ask a question about the third slide.

1623
01:37:04,380 --> 01:37:04,860
Yeah.

1624
01:37:04,860 --> 01:37:06,660
The one right before this one,

1625
01:37:08,050 --> 01:37:12,100
so could you just walk through real quick,

1626
01:37:12,100 --> 01:37:14,830
what matchIndex is doing on the write,

1627
01:37:14,860 --> 01:37:17,320
like when S2 is communicating with S3.

1628
01:37:17,960 --> 01:37:18,320
Okay.

1629
01:37:18,350 --> 01:37:20,990
So it starts out as 0.

1630
01:37:21,230 --> 01:37:24,290
Yep, so S2 is communicating with who?

1631
01:37:24,970 --> 01:37:25,720
S3.

1632
01:37:25,930 --> 01:37:27,040
Yeah, so basically okay,

1633
01:37:27,040 --> 01:37:30,160
so here matchIndex is 0, right,

1634
01:37:30,160 --> 01:37:32,470
like so and m you write it down is 0.

1635
01:37:33,350 --> 01:37:33,980
Yeah.

1636
01:37:34,460 --> 01:37:36,020
Okay, then you get to know back,

1637
01:37:36,020 --> 01:37:37,700
so matchIndex stays 0, right.

1638
01:37:38,940 --> 01:37:39,510
Okay.

1639
01:37:40,280 --> 01:37:42,470
Nothing there, but now it's an okay back,

1640
01:37:42,470 --> 01:37:43,520
so what does that imply,

1641
01:37:45,800 --> 01:37:48,380
that implies that you know what did it send,

1642
01:37:48,380 --> 01:37:52,700
that send heartbeat correct with for index 13,

1643
01:37:53,290 --> 01:38:02,390
and including and the S3 responded ok,

1644
01:38:02,780 --> 01:38:03,710
and so it means that,

1645
01:38:03,710 --> 01:38:07,340
basically S3 is up to date through until 13, correct,

1646
01:38:07,340 --> 01:38:10,670
that is nextIndex that it actually has and expects 14.

1647
01:38:11,500 --> 01:38:14,020
And so the S2 knows now,

1648
01:38:14,020 --> 01:38:18,520
that it's log matches until 13 after this message.

1649
01:38:19,880 --> 01:38:21,920
Is it until 13 or until 12?

1650
01:38:22,370 --> 01:38:24,410
It matches till 13,

1651
01:38:24,410 --> 01:38:28,040
so the next thing that will be sent will be going index 13.

1652
01:38:28,940 --> 01:38:33,110
So, so the nextIndex and matchIndex are going to be 13?

1653
01:38:33,200 --> 01:38:35,780
Yeah, the nextIndex is not used yet, right, means empty.

1654
01:38:37,290 --> 01:38:37,980
Okay.

1655
01:38:38,560 --> 01:38:40,450
So basically the the way you know,

1656
01:38:40,450 --> 01:38:43,330
they they you can do either way correct,

1657
01:38:43,330 --> 01:38:44,500
you can either save the last one

1658
01:38:44,500 --> 01:38:46,450
or you know first that's gonna be,

1659
01:38:46,630 --> 01:38:49,030
or the first next to you know 1,

1660
01:38:49,030 --> 01:38:51,430
in this case, they go by the first next one.

1661
01:38:53,410 --> 01:38:54,190
So in this case,

1662
01:38:54,190 --> 01:38:57,400
both of them are 13 for the next one.

1663
01:38:57,610 --> 01:39:00,970
Yeah, so basically you can think about this, this stage,

1664
01:39:00,970 --> 01:39:03,100
before like all the green stuff has happened,

1665
01:39:03,490 --> 01:39:14,740
the matchIndex for 3 is 13,

1666
01:39:15,300 --> 01:39:22,030
and the matchIndex for itself 2 is also 13.

1667
01:39:24,280 --> 01:39:28,860
Got it, awesome, thank you.

1668
01:39:28,950 --> 01:39:29,490
You're welcome.

1669
01:39:31,840 --> 01:39:34,780
Actually, can I ask a follow-up from that,

1670
01:39:34,960 --> 01:39:39,610
so when it sees something matches,

1671
01:39:39,820 --> 01:39:43,510
for example here on position 11,

1672
01:39:43,660 --> 01:39:45,160
it saw that matches,

1673
01:39:45,220 --> 01:39:51,290
then it is guarantee that everything before that matches too.

1674
01:39:51,680 --> 01:39:52,700
Yes, right, because,

1675
01:39:52,700 --> 01:39:55,340
hold on, let me double check you're talking about this message.

1676
01:39:56,920 --> 01:39:59,920
Yeah, about like when it says ok, if you check.

1677
01:40:00,160 --> 01:40:02,710
Yeah, yeah,

1678
01:40:02,710 --> 01:40:04,210
because that is the whole reason,

1679
01:40:04,210 --> 01:40:08,290
that the previous term or previous index all communicated correct to the follower,

1680
01:40:08,650 --> 01:40:11,860
to make double check that it can only respond ok,

1681
01:40:12,040 --> 01:40:13,210
if indeed is the case,

1682
01:40:13,210 --> 01:40:16,900
that in the previous index 11 actually return 3,

1683
01:40:18,200 --> 01:40:19,040
and if that's true,

1684
01:40:19,040 --> 01:40:21,440
that means that basically everything before that must match,

1685
01:40:21,560 --> 01:40:22,400
and this is like this,

1686
01:40:22,400 --> 01:40:26,540
whatever their whatever their statement they call,

1687
01:40:28,100 --> 01:40:30,200
this [invariant] initially maintained that,

1688
01:40:30,200 --> 01:40:32,330
like if something matches at like one index,

1689
01:40:32,330 --> 01:40:34,550
then everything before that match too.

1690
01:40:36,320 --> 01:40:38,330
Oh, okay, okay, this is [] to me.

1691
01:40:40,530 --> 01:40:44,730
Oh, and I had another follow-up question was related to the question,

1692
01:40:44,730 --> 01:40:48,180
on the lecture question that I wrote,

1693
01:40:48,450 --> 01:40:53,160
I asked about the copy-on-write for snapshots,

1694
01:40:53,250 --> 01:40:57,000
I think I don't really understand what is being copied,

1695
01:40:57,000 --> 01:41:00,480
is it, is it the page tables or is it something.

1696
01:41:00,480 --> 01:41:03,900
I think I responded to your email.

1697
01:41:04,110 --> 01:41:06,210
Yeah, I got email, but.

1698
01:41:06,750 --> 01:41:11,370
Okay, okay, okay, hold on a second,

1699
01:41:11,850 --> 01:41:14,970
[], the,

1700
01:41:15,670 --> 01:41:21,820
so okay, the scenario is snapshot can be expensive,

1701
01:41:21,850 --> 01:41:23,860
because snapchat might be large,

1702
01:41:24,280 --> 01:41:28,600
gigabytes you know key-value page table,

1703
01:41:28,600 --> 01:41:32,740
sorry, [] it was a gigabyte key-value store,

1704
01:41:33,290 --> 01:41:36,860
then you know you need to write that gigabyte to disk, right,

1705
01:41:37,710 --> 01:41:39,330
and while you're writing into disk,

1706
01:41:39,540 --> 01:41:41,130
if you don't do anything clever,

1707
01:41:41,310 --> 01:41:44,040
you cannot process any other put and get operations,

1708
01:41:44,370 --> 01:41:48,270
that come in through the channels,

1709
01:41:48,270 --> 01:41:51,420
let me actually [popup] this picture.

1710
01:41:52,010 --> 01:41:55,070
Great, so basically service decides at some point to take a checkpoint,

1711
01:41:55,070 --> 01:41:57,260
so gigabyte you have to write a gigabyte to disk,

1712
01:41:57,260 --> 01:41:57,920
that's expensive.

1713
01:41:58,510 --> 01:42:02,770
So the plan, you know I think the plan that the papers hinting at,

1714
01:42:03,340 --> 01:42:05,620
is that what the service does,

1715
01:42:06,320 --> 01:42:07,940
it you know calls fork,

1716
01:42:10,880 --> 01:42:14,060
so when it wants to make a checkpoint, it calls fork,

1717
01:42:15,080 --> 01:42:17,570
and fork case a copy of that process, right,

1718
01:42:17,570 --> 01:42:20,210
now we have the operating system running,

1719
01:42:21,070 --> 01:42:23,770
and we have now basically two processes,

1720
01:42:24,100 --> 01:42:27,250
that correspond to this application,

1721
01:42:27,580 --> 01:42:29,680
service raft, service raft,

1722
01:42:30,930 --> 01:42:33,420
and this is the copy, the child,

1723
01:42:34,520 --> 01:42:36,590
the operating system uses copy-on-write,

1724
01:42:38,040 --> 01:42:40,230
so when it made a copy of that second process,

1725
01:42:40,680 --> 01:42:43,890
and just copy the page table, didn't copy physical memory,

1726
01:42:45,220 --> 01:42:48,730
so basically these two processes share the same physical memory,

1727
01:42:52,420 --> 01:42:55,270
which holds you know the our key-value store, right.

1728
01:42:56,540 --> 01:42:58,760
And so now the idea is that,

1729
01:42:58,760 --> 01:43:00,260
the child when it starts running,

1730
01:43:00,350 --> 01:43:03,770
it starts making a checkpoint or snapshot,

1731
01:43:03,980 --> 01:43:06,770
I can just write out you know the key-value sort of,

1732
01:43:07,880 --> 01:43:10,070
the key-value store to disk.

1733
01:43:11,430 --> 01:43:15,090
And in parallel, you know the parent can just start

1734
01:43:15,090 --> 01:43:18,880
processing new you know get and put operations,

1735
01:43:21,860 --> 01:43:23,630
because if it does put operation,

1736
01:43:24,220 --> 01:43:25,180
and it wants to modify,

1737
01:43:25,180 --> 01:43:31,620
it will write you know to pages that correspond to the key-value store,

1738
01:43:31,650 --> 01:43:33,270
that will result in a page fault, right,

1739
01:43:33,270 --> 01:43:34,950
and so the OS will get a page fault,

1740
01:43:34,950 --> 01:43:38,820
and so the OS will copy that page at that point,

1741
01:43:39,060 --> 01:43:42,330
and then you know the first [] process can updated,

1742
01:43:42,960 --> 01:43:44,790
this is all transparent to the child,

1743
01:43:44,820 --> 01:43:48,660
which the child had a consistent snapshot of the whole address space

1744
01:43:48,660 --> 01:43:49,620
at the point of the fork.

1745
01:43:50,790 --> 01:43:54,060
So, this allows basically the parent and child run concurrently,

1746
01:43:54,060 --> 01:43:56,310
still make a consistent snapshot,

1747
01:43:56,580 --> 01:44:00,150
and the parent actually make process new put and get operations.

1748
01:44:02,340 --> 01:44:03,870
Is that more clear, okay?

1749
01:44:03,870 --> 01:44:05,040
Oh, yeah, okay I see,

1750
01:44:05,040 --> 01:44:10,890
so the copy-on-write, the memory that holds the key-value store,

1751
01:44:11,730 --> 01:44:13,440
okay, okay, okay I see,

1752
01:44:13,440 --> 01:44:14,910
yeah, this makes it very clear,

1753
01:44:14,910 --> 01:44:15,870
thank you so much.

1754
01:44:16,170 --> 01:44:16,800
You're welcome.

1755
01:44:20,920 --> 01:44:21,790
Any more questions?

1756
01:44:23,750 --> 01:44:25,850
Yeah, I have a,

1757
01:44:25,880 --> 01:44:29,000
I guess this is sort of a weird scenario,

1758
01:44:29,000 --> 01:44:30,230
I'm not sure if this could actually,

1759
01:44:31,390 --> 01:44:32,680
but what if,

1760
01:44:32,740 --> 01:44:35,140
so imagine that we're always in the same term,

1761
01:44:35,720 --> 01:44:41,420
and then you get to a point where some nodes have disconnected,

1762
01:44:41,420 --> 01:44:42,770
but they're still the same term,

1763
01:44:42,860 --> 01:44:44,360
the leader is still in the same term,

1764
01:44:44,510 --> 01:44:49,870
and then at some point, they will, they will do a snapshot,

1765
01:44:50,230 --> 01:44:52,540
and then all the logs will be compressed,

1766
01:44:53,120 --> 01:44:54,620
and then they keep going forward,

1767
01:44:54,620 --> 01:44:57,350
and now the logs are being populated again,

1768
01:44:57,350 --> 01:45:01,980
and then, let's just say 15 logs have been added,

1769
01:45:02,280 --> 01:45:05,760
and then after 10, they compress them,

1770
01:45:06,030 --> 01:45:08,670
and then they are at index index 5 again,

1771
01:45:08,670 --> 01:45:10,830
and then the other nodes joined back in,

1772
01:45:11,010 --> 01:45:13,170
and they're also at index 5 of the same term.

1773
01:45:14,870 --> 01:45:16,280
Is that a problem,

1774
01:45:16,280 --> 01:45:17,510
like how, how does,

1775
01:45:18,500 --> 01:45:22,670
it's almost like they're on a snapshot [] or some sort.

1776
01:45:23,350 --> 01:45:26,770
Okay, so old snapshots correspond to an index, right, so.

1777
01:45:26,860 --> 01:45:27,250
Yeah.

1778
01:45:27,460 --> 01:45:30,970
So okay, let's draw out like maybe draw your scenario,

1779
01:45:30,970 --> 01:45:34,180
so we got a server gonna have some log,

1780
01:45:35,780 --> 01:45:38,480
and you know maybe I think you know you talk about 10,

1781
01:45:38,780 --> 01:45:40,370
and it took a snapshot at 10.

1782
01:45:41,380 --> 01:45:42,160
Yeah.

1783
01:45:43,080 --> 01:45:44,820
Yeah, so let's say, let's say that basically,

1784
01:45:44,820 --> 01:45:49,860
yeah, so basically the first 9 operations are maybe including 10 are in the snapshot.

1785
01:45:52,490 --> 01:45:58,600
And then okay, so there's another node is same term,

1786
01:45:59,220 --> 01:46:01,320
so all these entries have the same term, right,

1787
01:46:01,320 --> 01:46:06,350
whatever, you know 1 1 1 1 1 1 1 1 1.

1788
01:46:06,380 --> 01:46:07,340
Yep.

1789
01:46:07,840 --> 01:46:10,960
And, so this node actually,

1790
01:46:10,960 --> 01:46:12,610
but this node has only until 10,

1791
01:46:12,610 --> 01:46:14,080
then this guy [through] 15.

1792
01:46:14,770 --> 01:46:15,490
Let's see,

1793
01:46:16,380 --> 01:46:17,340
I think that's what you're saying,

1794
01:46:17,340 --> 01:46:19,650
here's 1, here's 1.

1795
01:46:24,430 --> 01:46:27,940
Well, I think my my thought is,

1796
01:46:28,000 --> 01:46:29,800
well here's here's a question I can answer,

1797
01:46:29,950 --> 01:46:31,090
when you take a snapshot,

1798
01:46:31,090 --> 01:46:32,980
do you reset your index or do you keep counting?

1799
01:46:32,980 --> 01:46:33,640
You keep counting.

1800
01:46:35,280 --> 01:46:36,330
Oh, okay,

1801
01:46:37,050 --> 01:46:38,700
I was imagining it was like an array,

1802
01:46:39,030 --> 01:46:41,670
and you saw your index goes backwards,

1803
01:46:42,180 --> 01:46:44,970
so that it would be possible for you to have

1804
01:46:45,000 --> 01:46:48,690
two different entries in the same term with the same index.

1805
01:46:48,690 --> 01:46:50,580
Yeah, that's not allowed.

1806
01:46:50,580 --> 01:46:52,920
Right yeah, okay, I I see.

1807
01:46:53,540 --> 01:46:56,810
So, okay, okay, that makes sense.

1808
01:46:56,810 --> 01:46:58,790
When you remember reset the index.

1809
01:46:58,820 --> 01:47:01,190
When you cut like this part of the log,

1810
01:47:01,580 --> 01:47:03,020
in the index stays at 10.

1811
01:47:03,700 --> 01:47:04,660
Got it, got it.

1812
01:47:04,960 --> 01:47:07,120
And so in fact, when you do this in 2d,

1813
01:47:07,120 --> 01:47:08,620
this is gonna be slightly annoying,

1814
01:47:09,100 --> 01:47:13,360
because you presumably take advantage in fact the start of log is 0

1815
01:47:13,690 --> 01:47:15,340
and what you're now going to get is that,

1816
01:47:15,340 --> 01:47:17,620
the start of the [] of 0 might be 10,

1817
01:47:18,430 --> 01:47:21,370
people have to.

1818
01:47:21,370 --> 01:47:22,690
You have an offset of some sort.

1819
01:47:22,780 --> 01:47:25,870
Yeah, you have to add that offset everywhere.

1820
01:47:26,550 --> 01:47:29,010
Yeah, and then and then last thing really quickly,

1821
01:47:29,010 --> 01:47:30,990
I think the reason I was confused earlier

1822
01:47:31,080 --> 01:47:35,790
was in the in the code for lab 2.

1823
01:47:35,940 --> 01:47:36,240
Yeah.

1824
01:47:36,240 --> 01:47:37,590
There's a comment that says,

1825
01:47:37,590 --> 01:47:41,500
we're supposed to return immediately from start.

1826
01:47:41,830 --> 01:47:44,170
Yeah, yeah, well you, oh yes.

1827
01:47:45,240 --> 01:47:46,410
I mean,

1828
01:47:46,500 --> 01:47:48,600
okay, so let me go back to this picture here.

1829
01:47:49,310 --> 01:47:51,710
Yeah, hopefully, it's getting really crowded,

1830
01:47:53,510 --> 01:47:55,610
so we get an operation, correct,

1831
01:47:55,610 --> 01:47:58,250
and we do the start operation, we call start.

1832
01:47:59,480 --> 01:48:02,930
Oh, return immediately doesn't necessarily mean reply, is that.

1833
01:48:02,930 --> 01:48:05,270
Yeah, exactly,

1834
01:48:05,270 --> 01:48:07,880
it just means reply back to return to the service,

1835
01:48:07,910 --> 01:48:08,810
not to the client.

1836
01:48:10,450 --> 01:48:14,650
I see, I see, okay, gotcha,

1837
01:48:14,680 --> 01:48:20,080
yeah, I guess operating under the assumption that return always is necessarily reply,

1838
01:48:20,110 --> 01:48:21,850
but that's not that's not always the case.

1839
01:48:21,850 --> 01:48:22,840
No, that's not the case,

1840
01:48:22,840 --> 01:48:25,030
I think this will become more clear in lab 3

1841
01:48:25,030 --> 01:48:26,470
than they you know lab 2,

1842
01:48:26,800 --> 01:48:30,130
lab 2 a little bit weird, no application.

1843
01:48:31,100 --> 01:48:34,670
Yeah, okay, well, thank you,

1844
01:48:34,700 --> 01:48:35,990
this was really helpful.

1845
01:48:35,990 --> 01:48:37,310
You're welcome.

1846
01:48:37,310 --> 01:48:37,940
Appreciate it.

1847
01:48:40,120 --> 01:48:41,140
Have a rest.

1848
01:48:41,140 --> 01:48:41,560
You too.

1849
01:48:42,040 --> 01:48:42,370
Bye.

1850
01:48:42,550 --> 01:48:43,420
Good luck for the lab.

