1
00:00:03,550 --> 00:00:07,030
好的，下午好，早上好或晚上好，

2
00:00:07,900 --> 00:00:10,600
我们开始吧,

3
00:00:11,020 --> 00:00:13,540
今天我想谈谈比特币。

4
00:00:14,110 --> 00:00:17,080
我想谈这件事的原因是，

5
00:00:17,080 --> 00:00:18,910
它解决了一个困难的问题，

6
00:00:18,940 --> 00:00:31,640
也就是与拜占庭参与者达成共识。

7
00:00:41,300 --> 00:00:42,920
我想它解决了，

8
00:00:43,040 --> 00:00:45,440
所以拜占庭参与者是，

9
00:00:45,440 --> 00:00:48,050
它可能是恶意的或敌意的，

10
00:00:48,440 --> 00:00:53,210
它在一个完全开放的系统中解决了这个问题，

11
00:00:53,210 --> 00:00:56,720
人们可以随意加入和离开这个系统，

12
00:00:56,900 --> 00:01:00,110
其中一些可能是恶意的，

13
00:01:00,110 --> 00:01:06,710
并在事务发生的顺序上达成共识。

14
00:01:06,740 --> 00:01:08,600
这是一个非常具有挑战性的情况，

15
00:01:08,600 --> 00:01:13,160
是涉及到钱的。

16
00:01:13,780 --> 00:01:21,550
这个设计有点像 SUNDR 的一些方面，

17
00:01:21,640 --> 00:01:22,180
在这个意义上，

18
00:01:22,180 --> 00:01:26,330
有一个有签名的操作日志，

19
00:01:26,360 --> 00:01:27,860
在这个事务的例子中。

20
00:01:28,400 --> 00:01:34,790
我们知道在 SUNDR 中，可以处理 fork ，

21
00:01:39,140 --> 00:01:43,970
所以，关于比特币的大部分，很多有趣的方面，

22
00:01:44,150 --> 00:01:45,650
我主要将重点放在

23
00:01:45,650 --> 00:01:49,580
这篇论文的分布式系统方面。

24
00:01:50,150 --> 00:01:54,560
这篇论文有点不同寻常，或者说相当不同寻常，

25
00:01:55,310 --> 00:01:59,720
首先，这不是一篇来自科学文献的论文，

26
00:01:59,720 --> 00:02:01,070
目前为止我所读过的，

27
00:02:01,250 --> 00:02:04,310
它来自世界上不同的地方，

28
00:02:04,400 --> 00:02:07,460
它是匿名的，

29
00:02:14,510 --> 00:02:20,570
而且它有特别的[]，对于一家金融机构，

30
00:02:20,570 --> 00:02:23,510
你可以有各种各样的意见，

31
00:02:23,540 --> 00:02:27,470
关于通常的比特币和加密货币，

32
00:02:27,740 --> 00:02:30,260
但从分布式系统的角度来看，

33
00:02:30,260 --> 00:02:32,090
这是一个[]成功的系统，

34
00:02:32,360 --> 00:02:35,990
这是一个真正开放的系统，

35
00:02:36,050 --> 00:02:39,410
可以容忍拜占庭参与者，并达成共识。

36
00:02:39,740 --> 00:02:41,570
所以这节课的重点，

37
00:02:41,570 --> 00:02:43,160
你在试图理解，

38
00:02:43,160 --> 00:02:46,490
如何实现这一特定方面。

39
00:02:49,920 --> 00:02:52,350
有任何问题吗，在开始讨论之前？

40
00:03:00,570 --> 00:03:03,390
好的，就像我刚才提到的，

41
00:03:03,390 --> 00:03:08,040
这里的背景是金融交易。

42
00:03:09,050 --> 00:03:12,530
所以，这里有一个压倒一切的担忧，

43
00:03:12,530 --> 00:03:15,110
当涉及到交易时，

44
00:03:15,110 --> 00:03:16,430
在涉及金钱交易时，

45
00:03:16,700 --> 00:03:20,360
首先，当然担心完全的伪造，

46
00:03:25,520 --> 00:03:30,020
人们凭空捏造交易，

47
00:03:30,050 --> 00:03:31,880
并将它们输入到日志中，

48
00:03:31,880 --> 00:03:35,690
试图误导其他参与者，

49
00:03:35,690 --> 00:03:38,090
实际上他们是在花自己的钱，

50
00:03:38,660 --> 00:03:40,640
同时花别人的钱，

51
00:03:40,820 --> 00:03:43,910
这个问题很容易解决，

52
00:03:43,910 --> 00:03:46,340
以一种非常短的类似于 SUNDR 的风格，

53
00:03:46,370 --> 00:03:52,740
从根本上说，签名操作使伪造变得困难，

54
00:03:52,770 --> 00:03:54,810
事实上，这里的大体情况，

55
00:03:54,810 --> 00:03:56,040
它和 SUNDR 是一样的，

56
00:03:56,040 --> 00:04:00,810
拜占庭参与者非常强大，

57
00:04:00,840 --> 00:04:01,800
我们将假设

58
00:04:01,800 --> 00:04:06,300
密码系统是工作的，不会被攻破。

59
00:04:06,840 --> 00:04:11,370
所以，许多核心功能或基础，

60
00:04:11,370 --> 00:04:12,810
我们可能会包括，

61
00:04:12,810 --> 00:04:15,030
一切都很安全，一切是好的，

62
00:04:15,300 --> 00:04:18,990
基于基础密码学是正确的这一事实，

63
00:04:20,780 --> 00:04:22,190
所以这是一个挑战。

64
00:04:22,740 --> 00:04:24,660
第二个挑战是，

65
00:04:24,660 --> 00:04:28,140
论文花了很多时间讨论的是双重花费，

66
00:04:33,780 --> 00:04:38,340
所以你有一些比特币，你积累的，

67
00:04:38,730 --> 00:04:46,410
一个拜占庭参与者试图花费同一个比特币两次，

68
00:04:46,410 --> 00:04:49,590
当然，我们想要避免那个特别的问题，

69
00:04:50,070 --> 00:04:52,260
我们将看到的主要想法是

70
00:04:52,260 --> 00:04:57,860
所有交易的公共账本或公共日志，

71
00:04:57,860 --> 00:05:00,050
所以你可以看到交易是否，

72
00:05:00,050 --> 00:05:02,750
没有钱已经在早期的交易花费，

73
00:05:03,200 --> 00:05:07,070
并试图在日志中的内容达成共识，

74
00:05:07,130 --> 00:05:09,440
是这篇论文的核心。

75
00:05:10,470 --> 00:05:14,070
当然除了这两个之外，

76
00:05:14,070 --> 00:05:16,230
另一个显而易见的问题，

77
00:05:16,230 --> 00:05:18,000
但论文没有太多地谈到，

78
00:05:18,000 --> 00:05:19,890
我们也不会谈论太多，

79
00:05:19,890 --> 00:05:21,000
也就是偷窃，

80
00:05:21,750 --> 00:05:26,430
有人偷了别人的私钥，

81
00:05:26,430 --> 00:05:29,700
因此可以花钱或使用比特币，

82
00:05:29,730 --> 00:05:31,380
使用这个特定私钥，

83
00:05:31,380 --> 00:05:34,050
这是一个严重的问题，

84
00:05:34,260 --> 00:05:40,440
人们将他们的钱包和他们的签名密钥存储在计算机上，

85
00:05:40,440 --> 00:05:42,030
电脑可以被破解，

86
00:05:42,030 --> 00:05:46,290
因此，人们可以打破它，偷窃别人的钱。

87
00:05:47,050 --> 00:05:50,320
我认为这在实践中是一个严重的问题，

88
00:05:50,470 --> 00:05:52,900
我不会花太多时间谈论这件事，

89
00:05:53,320 --> 00:05:56,230
再一次，我想集中讨论分布式系统方面。

90
00:05:59,210 --> 00:06:00,470
对这些挑战，有什么问题吗？

91
00:06:06,460 --> 00:06:08,350
好的，我们来看看交易，

92
00:06:09,040 --> 00:06:10,900
它里面是什么。

93
00:06:11,650 --> 00:06:13,690
所以这是什么在账本中，

94
00:06:21,530 --> 00:06:24,860
我将大大简化这一过程，

95
00:06:26,640 --> 00:06:28,980
因为一些细节对讨论不重要，

96
00:06:28,980 --> 00:06:29,790
我们将要进行的（讨论），

97
00:06:30,090 --> 00:06:32,760
你能想到的第一个[顺序]是，

98
00:06:32,970 --> 00:06:36,540
每一笔交易都是一个记录，

99
00:06:36,540 --> 00:06:38,520
并且记录具有公钥，

100
00:06:43,830 --> 00:06:48,030
对于持有钱的用户，

101
00:06:48,030 --> 00:06:49,800
所以这就是目的，

102
00:06:51,260 --> 00:06:57,960
之前交易的哈希，

103
00:06:57,990 --> 00:06:59,640
对于这种特殊的比特币来说，

104
00:07:00,660 --> 00:07:06,880
以及签名，我们有私钥，

105
00:07:11,060 --> 00:07:17,540
U2 是这个比特币的前所有者，

106
00:07:17,900 --> 00:07:21,500
在这种情况下，你可以认为这是来源，

107
00:07:21,560 --> 00:07:23,450
所以 U2 操作，

108
00:07:23,450 --> 00:07:27,860
同意将比特币从 U2 转移到 U1 ，

109
00:07:28,340 --> 00:07:30,020
这样 U1 可以花掉它们。

110
00:07:30,780 --> 00:07:32,910
当然，里面还有很多其他的东西，

111
00:07:32,910 --> 00:07:34,230
比如有一个金额，

112
00:07:34,830 --> 00:07:36,000
一个零钱金额，

113
00:07:36,360 --> 00:07:39,540
可能有许多目的地和许多来源，

114
00:07:39,540 --> 00:07:40,980
有很多进出，

115
00:07:43,330 --> 00:07:44,920
我们都会忽略它，

116
00:07:44,920 --> 00:07:48,640
只专注于一种简化的描述，

117
00:07:48,940 --> 00:07:51,760
事实证明，交易也是编码的，

118
00:07:51,760 --> 00:07:54,010
而不是某种被动记录，

119
00:07:54,010 --> 00:07:56,620
但是一种小的脚本语言，

120
00:07:56,860 --> 00:08:00,790
也会忽略所有这些方面。

121
00:08:01,550 --> 00:08:04,070
我将开始专注于这件事，

122
00:08:04,070 --> 00:08:06,830
然后讨论，展示一个小例子，

123
00:08:07,100 --> 00:08:08,510
所以我们得到一点了解，

124
00:08:08,510 --> 00:08:11,510
我们所看到的就是这一挑战。

125
00:08:15,480 --> 00:08:17,730
所以，我们将查看一个示例账本，

126
00:08:17,730 --> 00:08:19,290
试图理解，

127
00:08:19,290 --> 00:08:23,160
比特币意味着什么或者币是什么，

128
00:08:23,430 --> 00:08:26,700
这不是一件单一的事情，

129
00:08:26,700 --> 00:08:28,710
这可以归结为

130
00:08:28,710 --> 00:08:31,950
上一笔交易的 sha1 ，

131
00:08:31,950 --> 00:08:33,360
这就是硬币的本质。

132
00:08:33,950 --> 00:08:40,940
所以，假设 y 有一枚币，从 x 那里收到，

133
00:08:41,390 --> 00:08:44,030
所以这意味着在账本的某个地方，

134
00:08:44,030 --> 00:08:45,530
这个交易，

135
00:08:45,530 --> 00:08:50,750
转移钱或币或币的一部分给 y ，

136
00:08:50,840 --> 00:08:51,740
让我们看看，

137
00:08:51,740 --> 00:08:55,490
在某个地方，可能有一个条目在账本中，

138
00:08:55,490 --> 00:09:03,290
在一段时间内， x 收到了一些比特币，

139
00:09:03,800 --> 00:09:10,580
现在已经把它给了 y 。

140
00:09:11,430 --> 00:09:14,160
所以在账本上还有另一笔交易，

141
00:09:14,160 --> 00:09:16,140
记录了这样一个事实，

142
00:09:16,140 --> 00:09:19,620
所以它可能有 y 的公钥，

143
00:09:20,220 --> 00:09:23,970
目的地交易 6 的哈希值，

144
00:09:26,280 --> 00:09:28,920
所以这唯一标记了标志，

145
00:09:28,920 --> 00:09:31,740
唯一标识交易 6 ，

146
00:09:32,040 --> 00:09:35,310
所以我们有交易 6 的账本或记录，

147
00:09:35,310 --> 00:09:37,500
现在我们可以重新计算这个交易的哈希值，

148
00:09:37,500 --> 00:09:40,260
与存储交易 7 相比，

149
00:09:40,410 --> 00:09:44,280
确定了事务 6 ，

150
00:09:44,310 --> 00:09:46,890
这笔交易的来源是什么，

151
00:09:47,450 --> 00:09:51,740
或者它是基于之前交易 6 ，对于这个币，

152
00:09:51,980 --> 00:09:56,480
它是由 x 签名的。

153
00:09:57,380 --> 00:10:00,410
现在，这是一种情况，

154
00:10:00,410 --> 00:10:06,830
y 从 x 获取一些比特币，

155
00:10:07,100 --> 00:10:08,930
y 想要花掉，

156
00:10:08,930 --> 00:10:12,230
例如，也许 y 想从 z 买一杯拿铁，

157
00:10:12,440 --> 00:10:17,870
所以它向 z 的转一笔钱，

158
00:10:17,870 --> 00:10:20,690
所以也许我们会在账本上看到另一笔交易，

159
00:10:20,690 --> 00:10:22,190
这将是一种形式，

160
00:10:22,220 --> 00:10:24,440
这是 y 要加上，

161
00:10:29,160 --> 00:10:36,930
pub(z) ，上一个币的哈希值，

162
00:10:37,510 --> 00:10:40,240
那枚币的最后一笔交易，是 T7 ，

163
00:10:40,540 --> 00:10:41,770
并由 y 签名。

164
00:10:45,100 --> 00:10:48,010
z 想做的，

165
00:10:48,010 --> 00:10:50,770
在 z 把拿铁给了 y 之前，

166
00:10:50,950 --> 00:10:52,660
z 需要做一些验证

167
00:10:52,930 --> 00:10:57,040
以确保这是合法的交易，

168
00:10:57,040 --> 00:11:01,390
所以查看交易 7 ，

169
00:11:01,720 --> 00:11:05,800
计算哈希值，进行检查，

170
00:11:05,800 --> 00:11:07,720
哈希值对应于

171
00:11:07,720 --> 00:11:12,610
交易 8 中列出的哈希值，

172
00:11:12,730 --> 00:11:15,280
如果哈希值已通过，

173
00:11:15,280 --> 00:11:16,750
所以这是交易 7 ，

174
00:11:16,750 --> 00:11:21,550
我们相信交易 8 所指的，

175
00:11:21,550 --> 00:11:28,000
z 在交易 7 中查找 y 的公钥，

176
00:11:28,000 --> 00:11:30,070
通常是公钥 y ，

177
00:11:30,310 --> 00:11:32,710
然后验证使用这个公钥

178
00:11:32,710 --> 00:11:36,010
来验证这个交易的签名，

179
00:11:36,010 --> 00:11:39,280
签名当然涵盖了整个交易，

180
00:11:39,490 --> 00:11:40,960
如果签名通过了，

181
00:11:40,960 --> 00:11:44,530
然后 z 可以自信地，

182
00:11:44,530 --> 00:11:49,030
账本包含一个交易，

183
00:11:49,030 --> 00:11:53,320
将一些钱从 y 转移到 z ，

184
00:11:53,350 --> 00:11:57,370
所以在这一点上， z 验证了，

185
00:11:57,730 --> 00:12:04,720
如果它是好的，给出拿铁，

186
00:12:05,580 --> 00:12:09,270
如果不是，就拒绝，

187
00:12:12,620 --> 00:12:15,800
又一次，就像在 SUNDR 中，

188
00:12:15,800 --> 00:12:19,430
所有这些方案都在这里，

189
00:12:19,430 --> 00:12:24,080
y 很小心地使用它的私钥，

190
00:12:30,980 --> 00:12:33,620
所以我们必须假设，

191
00:12:33,680 --> 00:12:41,270
y 没有以任何方式透露它的私钥，

192
00:12:43,850 --> 00:12:46,100
因为如果有人知道这个私钥，

193
00:12:46,100 --> 00:12:48,470
那么任何人都可以签名，

194
00:12:48,680 --> 00:12:51,500
他可以花掉 y 的钱，

195
00:12:53,780 --> 00:12:56,000
虽然可能从接受者的角度来看，并不是真的在乎。

196
00:12:57,870 --> 00:13:03,130
好的，所以，这是一个基本的计划，

197
00:13:03,220 --> 00:13:05,920
就有记录而言，

198
00:13:06,570 --> 00:13:09,030
我是说，这很好，

199
00:13:09,090 --> 00:13:14,760
我是说，有交易的记录，

200
00:13:14,820 --> 00:13:16,830
当 z 接收到交易，

201
00:13:16,830 --> 00:13:19,470
可以检查这是否是有效的交易，

202
00:13:19,770 --> 00:13:22,680
这允许决定，

203
00:13:22,680 --> 00:13:25,470
接受资金和交付货物。

204
00:13:26,620 --> 00:13:33,060
所以，其中一个关键挑战，

205
00:13:33,930 --> 00:13:35,010
所说的，

206
00:13:35,070 --> 00:13:38,910
我们看到完全伪造是很困难的，

207
00:13:40,810 --> 00:13:43,030
但我们需要考虑一下双重花费，

208
00:13:43,270 --> 00:13:46,030
所以，双重花费问题如下所示。

209
00:13:46,090 --> 00:13:49,240
假设不是创建一个记录，

210
00:13:49,240 --> 00:13:52,060
在这个交易 8 的例子中，

211
00:13:52,300 --> 00:13:55,900
z 创建了， y 创建了两个记录，

212
00:14:07,190 --> 00:14:13,340
一个记录是你看到的那个 T8 ，

213
00:14:14,480 --> 00:14:17,450
y 到 z ，以及 T7 的哈希值。

214
00:14:19,990 --> 00:14:20,710
让我们来看看，

215
00:14:20,710 --> 00:14:25,570
让我们假设 y 试图双重花费它的钱，

216
00:14:25,810 --> 00:14:28,540
所以它创建了第二个交易 T8' ，

217
00:14:28,810 --> 00:14:31,690
记录基本上是一样的，

218
00:14:31,690 --> 00:14:34,000
除了钱流向了 Q ，

219
00:14:34,270 --> 00:14:37,270
它有 T7 的哈希，

220
00:14:38,090 --> 00:14:40,460
当然也有 y 的签名，

221
00:14:41,120 --> 00:14:42,200
由 y 签名。

222
00:14:45,960 --> 00:14:50,940
现在，假设 q 和 z 都是拿铁咖啡店，

223
00:14:51,270 --> 00:14:56,550
如果 z 接受了 T8 ，

224
00:14:56,550 --> 00:14:57,150
它会这么做，

225
00:14:57,150 --> 00:14:58,950
因为一切检查都通过了，

226
00:14:58,950 --> 00:15:00,570
正如我们在上一张幻灯片中所看到的，

227
00:15:01,020 --> 00:15:03,330
然后 z 会把一杯拿铁给 y ，

228
00:15:03,540 --> 00:15:06,240
q 不知道任何事情，

229
00:15:06,240 --> 00:15:08,310
可能关于另一笔 T8 交易，

230
00:15:08,520 --> 00:15:10,680
因为这个 T8 交易，

231
00:15:10,860 --> 00:15:11,850
检查这个，

232
00:15:11,850 --> 00:15:12,810
确实是这样，

233
00:15:12,810 --> 00:15:16,320
T7 中的钱被转移到了 y ，

234
00:15:16,470 --> 00:15:20,010
检查了 y 的签名，

235
00:15:20,010 --> 00:15:22,200
如果有效，会说好的，很好，

236
00:15:22,200 --> 00:15:24,450
哦，谢谢你的钱，

237
00:15:24,450 --> 00:15:25,710
我也会给你一杯拿铁，

238
00:15:25,740 --> 00:15:28,380
现在我们的处境很糟糕，

239
00:15:28,500 --> 00:15:34,980
因为 y 成功双重花费并得到两杯拿铁，

240
00:15:35,070 --> 00:15:35,850
这是那个问题，

241
00:15:35,850 --> 00:15:40,260
论文致力于解决的问题。

242
00:15:44,610 --> 00:15:47,370
基本的方法是，

243
00:15:49,210 --> 00:15:52,390
有点类似于做过的事情，

244
00:15:52,390 --> 00:15:54,760
我们记录所有的交易日志，

245
00:15:54,760 --> 00:15:55,990
从它们一开始，

246
00:16:01,840 --> 00:16:13,330
在日志中包含所有交易，包括顺序，

247
00:16:13,330 --> 00:16:14,890
所以，让我们看看，

248
00:16:14,890 --> 00:16:17,410
所以我们把交易放进去，

249
00:16:17,800 --> 00:16:22,000
我们这里有 T6 ，这里有 T7 ，

250
00:16:22,600 --> 00:16:24,790
所以如果有公共记录，

251
00:16:24,790 --> 00:16:26,260
它对所有交易进行排序，

252
00:16:26,260 --> 00:16:28,330
T8 或 T8' 先开始，

253
00:16:28,330 --> 00:16:29,560
假设 T8 先开始，

254
00:16:30,660 --> 00:16:33,180
然后 T8' 进入日志中，

255
00:16:34,530 --> 00:16:36,900
这会发生，

256
00:16:37,140 --> 00:16:39,630
那么你一点问题都没有，

257
00:16:39,630 --> 00:16:43,740
因为这是从 y 到 z 的交易，

258
00:16:43,860 --> 00:16:46,200
这是从 y 到 q 的交易，

259
00:16:47,100 --> 00:16:52,200
当 Q 确认的时候，

260
00:16:52,200 --> 00:16:53,970
当 z 确认交易时，

261
00:16:53,970 --> 00:16:55,980
一切看起来都和以前一样完美，

262
00:16:56,250 --> 00:16:58,080
当 Q 确认交易时，

263
00:16:58,200 --> 00:17:00,270
除了检查，我们查看，

264
00:17:00,510 --> 00:17:02,820
它在日志中查找，

265
00:17:02,970 --> 00:17:04,350
Q 在日志中查找，

266
00:17:07,520 --> 00:17:10,280
看到 T7 已经花掉了，

267
00:17:21,620 --> 00:17:26,090
当然，你后退日志，遇到 T8 ，

268
00:17:26,090 --> 00:17:28,340
看到钱已经花掉了，

269
00:17:28,580 --> 00:17:32,320
所以，它将拒绝 T8' 。

270
00:17:33,910 --> 00:17:34,480
好吗？

271
00:17:35,750 --> 00:17:38,060
所以，这就是基本计划，

272
00:17:38,120 --> 00:17:40,460
所以产生了一个问题，

273
00:17:40,460 --> 00:17:44,060
比如我们如何确保，

274
00:17:45,260 --> 00:17:48,710
系统中的所有参与者都同意这个日志，

275
00:17:48,710 --> 00:17:52,310
所有的交易都在同一个位置，

276
00:17:52,610 --> 00:17:55,970
包含相同的内容、相同的散列、相同的签名，

277
00:17:56,240 --> 00:17:58,850
所以，我们可以验证交易，

278
00:17:58,850 --> 00:18:03,080
使用这个幻灯片中列出的方案。

279
00:18:03,930 --> 00:18:08,370
这就是共识问题的作用，

280
00:18:08,640 --> 00:18:11,880
有时，人们将这一解决方案

281
00:18:11,880 --> 00:18:14,340
称为中本聪共识协议。

282
00:18:15,610 --> 00:18:17,710
现在，在深入研究协议之前，

283
00:18:17,950 --> 00:18:23,200
我想勾勒出可能的解决方案，

284
00:18:23,200 --> 00:18:24,820
它们是行不通的，

285
00:18:25,090 --> 00:18:27,010
只是为了得到更好的感觉，

286
00:18:27,010 --> 00:18:28,660
比如挑战是什么，

287
00:18:28,660 --> 00:18:33,370
这种中本聪共识所解决的。

288
00:18:35,860 --> 00:18:37,960
所以设计 1 ，

289
00:18:39,720 --> 00:18:41,520
这并不是真正的设计，

290
00:18:41,520 --> 00:18:45,210
它更像是一种考虑的方法，然后拒绝，

291
00:18:45,660 --> 00:18:49,200
设计 1 可能是最简单的设计，

292
00:18:49,290 --> 00:18:52,280
假设我们有服务器 S ，

293
00:18:52,400 --> 00:18:54,230
而且服务器是受信任的，

294
00:18:58,120 --> 00:19:00,130
然后我们有客户端，

295
00:19:00,130 --> 00:19:03,790
有一些交易，不管是 T6 ，

296
00:19:08,590 --> 00:19:12,070
1 2 ， x y z ，

297
00:19:12,370 --> 00:19:18,310
它们只是把这些交易提交给可信服务器，

298
00:19:18,400 --> 00:19:22,000
所有的客户端都信任这个服务器，

299
00:19:22,000 --> 00:19:24,490
服务器可以生成一个日志，

300
00:19:24,490 --> 00:19:25,720
有所有的交易，

301
00:19:27,220 --> 00:19:30,100
对它们进行排序，等等。

302
00:19:31,810 --> 00:19:34,450
所以，如果我们假设有一个受信任的服务器，

303
00:19:34,450 --> 00:19:36,850
这个问题很容易解决，

304
00:19:36,850 --> 00:19:38,260
我们所处的环境，

305
00:19:38,260 --> 00:19:39,310
我们处于很好的状态，

306
00:19:39,850 --> 00:19:44,950
可能使用某种 Raft 类型的协议复制服务器，

307
00:19:45,310 --> 00:19:48,490
我们会有一个容错服务器，

308
00:19:48,580 --> 00:19:52,840
这个特殊过程的唯一缺点是，

309
00:19:52,840 --> 00:19:56,590
如果客户端不能同意单个可信服务器，

310
00:19:57,070 --> 00:19:59,590
以比特币为例，

311
00:19:59,590 --> 00:20:01,150
当你想做交易的时候，

312
00:20:01,420 --> 00:20:03,040
也许，

313
00:20:03,070 --> 00:20:07,180
世界其他国家会信任美国政府，

314
00:20:07,180 --> 00:20:11,200
正确地实现服务器并生成日志，

315
00:20:11,230 --> 00:20:17,140
在这种情况下，我们有多个不同的客户端，

316
00:20:17,140 --> 00:20:19,570
因为你无法同意一个受信任的服务器，

317
00:20:19,570 --> 00:20:22,370
然后这个解决方案，这个服务就不管用了。

318
00:20:24,100 --> 00:20:25,930
所以这是一种解决方案，

319
00:20:25,930 --> 00:20:27,940
这是简单的一个，

320
00:20:27,940 --> 00:20:30,670
但在去中心化设计的情况下，

321
00:20:30,670 --> 00:20:33,430
没有信任的任何核心组件，

322
00:20:33,580 --> 00:20:36,220
这不是一个可行的解决方案。

323
00:20:36,220 --> 00:20:42,020
所以，现在我们考虑使用像 SUNDR 的方法，

324
00:20:42,680 --> 00:20:44,480
对方案稍加修改，

325
00:20:44,480 --> 00:20:45,620
然后说，好的，好的，

326
00:20:45,620 --> 00:20:48,290
我们知道如何处理不可信的服务器，

327
00:20:48,320 --> 00:20:50,240
事实上，我们上周读了关于它的论文。

328
00:20:50,540 --> 00:20:54,080
所以，让我们假设这些服务器是不受信任的，

329
00:20:55,200 --> 00:20:58,050
你玩的是 SUNDR 的游戏，

330
00:20:58,200 --> 00:21:01,890
客户端生成日志，从服务器读取日志，

331
00:21:01,890 --> 00:21:05,250
将记录追加到日志中，

332
00:21:05,370 --> 00:21:07,290
将其提交回服务器，

333
00:21:07,380 --> 00:21:09,600
所以，服务器基本上不做其他任何事情，

334
00:21:09,600 --> 00:21:12,390
它在不同的客户端之间转发日志，

335
00:21:13,220 --> 00:21:15,290
我们上周已经看到，

336
00:21:15,290 --> 00:21:17,750
这种方法确实效果很好，

337
00:21:18,080 --> 00:21:20,240
它可以被使用，

338
00:21:20,240 --> 00:21:24,350
但是，正如我们所见，它有一个缺点，

339
00:21:24,380 --> 00:21:29,180
也就是说，服务器可以呈现两种不同的世界观，

340
00:21:29,210 --> 00:21:31,040
通过 fork 日志，

341
00:21:31,250 --> 00:21:33,140
所以也许日志有一些前缀，

342
00:21:33,380 --> 00:21:35,720
T1 T2 到 T5 T6 T7 ，

343
00:21:35,900 --> 00:21:38,840
但现在这里有 T8 ，

344
00:21:39,050 --> 00:21:40,610
还有另一个日志，

345
00:21:41,250 --> 00:21:46,380
包含 T7 ... 和 T8' 。

346
00:21:47,280 --> 00:21:50,670
所以在一个 fork ，我们得到 T8 ，

347
00:21:50,700 --> 00:21:52,590
在另一个 fork ，我们有 T8' ，

348
00:21:52,920 --> 00:22:00,120
现在我们选择一个 fork ，

349
00:22:00,150 --> 00:22:04,590
服务器将这两个世界分开，

350
00:22:04,590 --> 00:22:07,800
比如 z 在一个世界，

351
00:22:07,830 --> 00:22:09,060
Q 在另一个世界，

352
00:22:09,480 --> 00:22:12,480
y 总是得到第一个日志，

353
00:22:12,480 --> 00:22:16,650
z 总是得到第二个日志，正好相反，

354
00:22:16,950 --> 00:22:19,290
然后，你知道，

355
00:22:19,650 --> 00:22:21,390
然后它们会假装，好的，好的，

356
00:22:21,390 --> 00:22:26,250
是的，在这个日志中没有之前花费 T7 ，

357
00:22:26,250 --> 00:22:28,770
所以 Q 中的 T8 会接受，

358
00:22:28,980 --> 00:22:31,650
在这个世界的 T8' ，

359
00:22:31,920 --> 00:22:34,470
这里 z 将接受 T8 ，

360
00:22:34,590 --> 00:22:36,900
所以， y 成功地实现了双重花费。

361
00:22:38,570 --> 00:22:41,510
所以，这个设计不能工作，

362
00:22:41,690 --> 00:22:44,090
对于这个问题，

363
00:22:44,270 --> 00:22:46,100
我们需要一些解决方案，

364
00:22:46,100 --> 00:22:47,510
这也是共识的地方。

365
00:22:47,660 --> 00:22:48,710
我们需要一些解决方案，

366
00:22:48,710 --> 00:22:51,320
让不受信任的客户端

367
00:22:51,500 --> 00:22:55,430
能够解决它们在哪个 fork 。

368
00:22:57,800 --> 00:23:01,750
好的，所以，让我们稍微想一想，

369
00:23:01,750 --> 00:23:04,660
所以想一想更加去中心化的设计，

370
00:23:04,660 --> 00:23:08,140
我们将用计算机网络取代服务器。

371
00:23:09,110 --> 00:23:10,100
所以，在那里，

372
00:23:10,900 --> 00:23:14,650
这离比特币设计更近，

373
00:23:14,650 --> 00:23:19,150
那里有一个节点网络，

374
00:23:19,150 --> 00:23:21,580
所有这些都在某种程度上合作，

375
00:23:21,580 --> 00:23:25,690
以提供这个单一日志，

376
00:23:25,720 --> 00:23:28,390
尽管有些参与者可能是恶意的，

377
00:23:28,390 --> 00:23:29,770
尝试做一些不同的事情。

378
00:23:29,980 --> 00:23:31,240
所以我们的想法是，

379
00:23:31,240 --> 00:23:35,410
当客户端创建交易时，

380
00:23:36,100 --> 00:23:41,440
然后交易在节点网络中分发，

381
00:23:42,470 --> 00:23:44,480
事实上，客户端 1 自己可能是一个节点，

382
00:23:44,990 --> 00:23:47,090
所以，交易将传播到各处，

383
00:23:50,720 --> 00:23:55,700
网络中的每个节点都维护着一个日志，

384
00:23:56,360 --> 00:23:59,270
并将交易附加到它的日志中。

385
00:24:03,760 --> 00:24:07,270
我们剩下的问题是，

386
00:24:07,270 --> 00:24:08,770
如何就顺序达成一致。

387
00:24:20,440 --> 00:24:24,400
我们以前见过这样的系统，

388
00:24:24,400 --> 00:24:25,660
比如在 Raft 中，

389
00:24:25,660 --> 00:24:27,040
我们有多个计算机，

390
00:24:27,100 --> 00:24:29,350
它们能够就顺序达成一致，

391
00:24:29,350 --> 00:24:32,620
基本的技巧，在其中使用的是，

392
00:24:32,620 --> 00:24:35,470
计算某个大多数，

393
00:24:35,470 --> 00:24:37,720
有大多数节点达成一致，

394
00:24:37,990 --> 00:24:41,530
插槽 6 是事务 T8 ，

395
00:24:41,530 --> 00:24:44,410
在插槽 7 中，将是 T8' 。

396
00:24:46,040 --> 00:24:50,330
而且，这很有效，

397
00:24:50,330 --> 00:24:53,900
如果我们确切地知道系统中有多少个节点，

398
00:24:54,660 --> 00:24:56,880
我们知道系统中有 5 个节点，

399
00:24:57,210 --> 00:24:59,970
然后大多数是 3 ，

400
00:24:59,970 --> 00:25:03,210
我们收到了 3 个参与者的回复，

401
00:25:03,420 --> 00:25:06,030
我们知道，好的，我们可以提交那个位置。

402
00:25:06,630 --> 00:25:08,160
这里真正的问题是，

403
00:25:08,160 --> 00:25:10,860
这是一个去中心化的系统，这是完全开放的，

404
00:25:12,980 --> 00:25:18,440
系统节点甚至可能在任何时间离开、到来，

405
00:25:18,440 --> 00:25:21,530
在系统中没有所有参与者的列表，

406
00:25:21,800 --> 00:25:26,870
所以，也不清楚在这样的系统中到底什么是多数，

407
00:25:29,280 --> 00:25:32,340
因为它是完全开放的，

408
00:25:32,550 --> 00:25:35,250
所以大多数的概念能够找到。

409
00:25:36,590 --> 00:25:41,090
所以我们需要一些像往常一样的游戏，

410
00:25:41,090 --> 00:25:43,610
对大多数进行投票，

411
00:25:43,610 --> 00:25:47,900
然后接受多数人的结果是不会奏效的，

412
00:25:47,990 --> 00:25:51,230
这是 Raft 的游戏，

413
00:25:51,230 --> 00:25:54,200
即使这是一个共识协议，也不会奏效，

414
00:25:54,200 --> 00:25:57,920
因为我们在处理的环境是

415
00:25:57,920 --> 00:26:00,170
一个去中心化的开放分布式系统，

416
00:26:00,380 --> 00:26:03,410
而不是像 Raft 设置中的封闭系统。

417
00:26:07,520 --> 00:26:09,260
到目前为止，能理解吗？

418
00:26:10,800 --> 00:26:11,850
让我暂停一下，

419
00:26:11,850 --> 00:26:13,890
在进入更技术性的部分之前。

420
00:26:20,980 --> 00:26:21,490
好的？

421
00:26:26,060 --> 00:26:29,870
好的，那么比特币是如何解决这个问题的？

422
00:26:34,270 --> 00:26:38,830
关键的想法是所谓的工作量证明，

423
00:26:44,980 --> 00:26:49,750
基本上规则是，

424
00:26:50,940 --> 00:26:54,890
一个节点需要完成大量的工作，

425
00:26:54,890 --> 00:26:57,800
才能扩展日志，

426
00:26:58,280 --> 00:27:02,360
在基本规则中，你知道的工作机器证明中的赢家

427
00:27:02,360 --> 00:27:07,450
工作量证明的胜利者，

428
00:27:09,670 --> 00:27:11,740
机器能够解决那个难题，

429
00:27:12,040 --> 00:27:15,610
首先，它决定下一个日志条目，

430
00:27:25,590 --> 00:27:28,290
基本的想法，

431
00:27:28,290 --> 00:27:30,270
这可能会让你得到一些直觉，

432
00:27:30,270 --> 00:27:31,710
为什么这个操作有效，

433
00:27:32,010 --> 00:27:34,860
因为很难冒充获胜者，

434
00:27:44,460 --> 00:27:48,510
解决这个特殊的工作量证明难题，

435
00:27:48,630 --> 00:27:51,480
需要能够添加到日志中，

436
00:27:51,600 --> 00:27:53,250
实际上需要一台计算机，

437
00:27:53,400 --> 00:27:57,300
在一个月的计算时间，

438
00:27:57,540 --> 00:27:59,820
来解决这个问题，

439
00:27:59,910 --> 00:28:02,670
所以，如果你能解决，并证明你解决了问题，

440
00:28:02,670 --> 00:28:05,760
可以肯定的是，有人花了一个月的时间去做，

441
00:28:06,510 --> 00:28:14,010
这在某种程度上足以让你相信系统的其余部分，

442
00:28:14,010 --> 00:28:19,980
需要花费真正的资源，

443
00:28:20,250 --> 00:28:24,120
以便能够追加到日志条目，

444
00:28:24,690 --> 00:28:27,570
也许你可以想到其他类似的方案，

445
00:28:27,570 --> 00:28:31,530
比如唯一的 IP 地址或类似的东西，

446
00:28:31,530 --> 00:28:34,140
但所有这些东西都很容易被篡改，

447
00:28:34,530 --> 00:28:39,570
所以工作量证明的想法是核心，

448
00:28:39,870 --> 00:28:45,450
为了证明，花了一个月的时间，

449
00:28:45,450 --> 00:28:49,560
计算出下一个[]，

450
00:28:49,560 --> 00:28:53,730
能够将日志条目追加到日志中。

451
00:28:57,070 --> 00:28:59,770
一个，这个方法，

452
00:28:59,770 --> 00:29:03,890
这种工作证明方法的一个缺点是，

453
00:29:03,890 --> 00:29:05,330
它在浪费能量，

454
00:29:11,150 --> 00:29:14,990
事实上，比特币会如此成功，

455
00:29:15,050 --> 00:29:17,060
很多人都在下面，

456
00:29:17,060 --> 00:29:19,310
挖掘和做这项工作量证明，

457
00:29:19,670 --> 00:29:22,910
能量账单或者能量消耗，

458
00:29:23,180 --> 00:29:28,610
所有矿工统计在一起是难以置信的大，

459
00:29:28,730 --> 00:29:30,590
它很大，

460
00:29:31,010 --> 00:29:36,500
所以，这种方法的负面影响是浪费能源。

461
00:29:37,800 --> 00:29:44,880
近年来，出现了其他加密货币或其他设计，

462
00:29:44,970 --> 00:29:46,800
基于不同的想法，

463
00:29:46,800 --> 00:29:47,790
不是工作量证明，

464
00:29:47,790 --> 00:29:50,040
而是基于称为权益证明的东西，

465
00:29:56,560 --> 00:29:59,020
这是一种游戏，

466
00:29:59,020 --> 00:30:03,250
假设你拥有 3% 的货币，

467
00:30:03,460 --> 00:30:05,560
然后你可以，

468
00:30:05,650 --> 00:30:07,990
因为你拥有 3% ，

469
00:30:07,990 --> 00:30:12,550
你可以决定 3% 的日志条目，

470
00:30:12,550 --> 00:30:14,380
哪个可以被追加。

471
00:30:15,600 --> 00:30:18,810
所以，这是一种完全不同的方法，

472
00:30:18,810 --> 00:30:23,580
这不需要解决计算密集型难题，

473
00:30:23,820 --> 00:30:29,940
它似乎得到了相当多的关注，

474
00:30:29,940 --> 00:30:32,670
而且有使用它的加密货币，

475
00:30:33,060 --> 00:30:38,250
事实上，看起来以太坊是最重要的一个，

476
00:30:38,250 --> 00:30:41,550
正在使用权益证明的方法。

477
00:30:42,080 --> 00:30:45,410
但是比特币使用的是工作量证明方法，

478
00:30:45,960 --> 00:30:48,900
所以，我们将继续进行这个设计。

479
00:30:51,920 --> 00:30:52,730
有什么问题吗？

480
00:30:54,720 --> 00:30:57,870
所以，我只是在想，

481
00:30:57,870 --> 00:31:00,240
冒充获胜者有多难，

482
00:31:00,270 --> 00:31:03,840
假设我们有服务器 A 和服务器 B ，

483
00:31:03,840 --> 00:31:07,500
服务器 A 想要附加条目 e1 ，

484
00:31:07,500 --> 00:31:09,660
服务器 B 想要附加条目 e2 ，

485
00:31:09,750 --> 00:31:14,400
所以服务器 A 解决了这个难题，并发布了解决方案，

486
00:31:14,400 --> 00:31:16,500
我假设解决方案很容易检查，

487
00:31:16,830 --> 00:31:22,080
然后服务器 B 看到解决方案，并检查其是正确的，

488
00:31:22,580 --> 00:31:25,040
所以它不能工作，

489
00:31:25,130 --> 00:31:29,360
服务器 B 只是简单地用它自己的名字重新发布解决方案，

490
00:31:29,360 --> 00:31:31,220
并用自己的名字签名，

491
00:31:31,220 --> 00:31:34,790
因为 e2 的难题和 e1 的难题是不同的，对吗？

492
00:31:34,790 --> 00:31:36,890
是的，好的，就是这样，

493
00:31:36,890 --> 00:31:39,650
我们会看到，我们将在稍后看到更多细节。

494
00:31:40,700 --> 00:31:42,800
当然，在这里，这是一种基本的了解，

495
00:31:42,980 --> 00:31:44,030
当然，这还不够。

496
00:31:45,290 --> 00:31:48,650
但是，这足以决定在哪一个 fork 上，

497
00:31:48,710 --> 00:31:49,970
所以我们要接受，

498
00:31:49,970 --> 00:31:50,780
它们会 fork ，

499
00:31:50,780 --> 00:31:51,800
然后我们会有，

500
00:31:51,800 --> 00:31:55,610
比特币会接受他们的 fork ，像 SUNDR 一样，

501
00:31:55,640 --> 00:31:58,730
然后有一种决定选择哪一个 fork 的方法。

502
00:32:01,920 --> 00:32:05,760
是的，所以我有一个关于网络分区的问题，

503
00:32:06,930 --> 00:32:09,390
我想知道如何，

504
00:32:09,930 --> 00:32:14,190
如果你能在互联网上创建一个分区，

505
00:32:14,190 --> 00:32:16,830
这可能是不合理的，

506
00:32:16,830 --> 00:32:20,370
但是你可以划分整个互联网，

507
00:32:20,640 --> 00:32:22,890
你不能说服，

508
00:32:23,040 --> 00:32:28,050
某人双重花费，

509
00:32:28,050 --> 00:32:31,020
通过在分区的两边花费。

510
00:32:31,560 --> 00:32:33,090
是的，分区永远不会恢复吗？

511
00:32:35,550 --> 00:32:39,270
最终，如果你认为它会恢复，

512
00:32:39,270 --> 00:32:44,020
但到那时，你可能已经发送东西了。

513
00:32:44,200 --> 00:32:45,850
是的，所以通常我们会看到，

514
00:32:45,850 --> 00:32:47,530
我们会更多地谈论它，

515
00:32:47,530 --> 00:32:51,280
有各种各样的创建 fork 的方法，

516
00:32:51,280 --> 00:32:52,210
你所描述的是

517
00:32:52,210 --> 00:32:54,130
因为它会持续很长一段时间，

518
00:32:54,730 --> 00:32:59,020
你会看到，

519
00:32:59,350 --> 00:33:04,690
比特币基本上每十分钟产生一次交易日志，

520
00:33:04,990 --> 00:33:07,330
如果你非常保守，

521
00:33:07,330 --> 00:33:13,420
或者你想小心得避免双重花费，

522
00:33:13,420 --> 00:33:15,550
或者确保没有任何双重花费，

523
00:33:15,550 --> 00:33:20,110
你通常会等待多个这样的日志显示，比如 5 6 个，

524
00:33:20,110 --> 00:33:21,400
所以基本上是一个小时，

525
00:33:21,460 --> 00:33:23,650
在真正决定接受之前，

526
00:33:23,650 --> 00:33:26,800
说是的，我在正确的 fork 上。

527
00:33:29,370 --> 00:33:30,000
谢谢。

528
00:33:38,950 --> 00:33:39,850
好的，所以。

529
00:33:40,900 --> 00:33:44,650
让我们来看看这些部分如何在一起，

530
00:33:45,190 --> 00:33:46,810
所以事实证明，

531
00:33:46,840 --> 00:33:49,240
做交易的工作量证明，

532
00:33:49,240 --> 00:33:50,500
它会很疯狂，

533
00:33:50,530 --> 00:33:53,320
因为你要花费大量的常规的能量，

534
00:33:53,500 --> 00:33:55,180
为了放入一个单一的事务，

535
00:33:55,180 --> 00:33:58,660
这将限制你每秒钟执行的交易的数量，

536
00:33:58,960 --> 00:34:01,600
所以，完成此操作的一种方式是

537
00:34:01,600 --> 00:34:04,510
以块为单位对组进行交易处理，

538
00:34:04,630 --> 00:34:09,490
工作量证明以一个块为基础。

539
00:34:10,080 --> 00:34:11,730
所以我们有自己的网络，

540
00:34:14,780 --> 00:34:16,310
它的工作方式是，

541
00:34:16,310 --> 00:34:18,200
我们不会创建很多块，

542
00:34:18,200 --> 00:34:20,840
但我们做很多交易，

543
00:34:20,840 --> 00:34:22,520
我们创建了很多区块，

544
00:34:22,520 --> 00:34:24,620
也就是区块链。

545
00:34:28,460 --> 00:34:31,130
所以我们有了自己的网络，

546
00:34:31,130 --> 00:34:33,290
在世界各地有节点，

547
00:34:33,960 --> 00:34:39,180
这里的日志是一系列的块。

548
00:34:42,720 --> 00:34:44,910
所以节点有这些的副本，

549
00:34:45,030 --> 00:34:47,130
可能会创建新的，

550
00:34:47,130 --> 00:34:50,190
追加它们，分发它们在网络中。

551
00:34:51,690 --> 00:34:56,510
所以，在非常高的级别上，块中有什么，

552
00:34:57,470 --> 00:35:00,530
再次，有很多细节我会忽略，

553
00:35:00,680 --> 00:35:03,080
它是上一个区块的哈希，

554
00:35:03,110 --> 00:35:06,730
所以 B-1 ，

555
00:35:07,450 --> 00:35:09,040
如果这是区块 5 ，

556
00:35:09,040 --> 00:35:14,590
这将是 B4 ，所以 B-1 ，

557
00:35:14,590 --> 00:35:19,030
链中前一个块的唯一标识符，

558
00:35:19,180 --> 00:35:21,520
交易属于这个区块，

559
00:35:23,150 --> 00:35:27,570
然后是一个 nonce ，我们稍后会谈到，

560
00:35:27,570 --> 00:35:32,490
但这是一个在难题中发挥关键作用的东西，

561
00:35:32,670 --> 00:35:34,230
和时间戳，

562
00:35:38,960 --> 00:35:41,930
这是典型的，

563
00:35:41,930 --> 00:35:43,760
你稍后会看到，

564
00:35:43,760 --> 00:35:48,190
考虑这些大约是一个 MB 的块，

565
00:35:48,190 --> 00:35:50,440
所以这个游戏是

566
00:35:50,440 --> 00:35:54,130
收集交易的节点，

567
00:35:54,340 --> 00:35:58,240
然后解决这个难题，

568
00:35:58,750 --> 00:36:00,820
一旦他们解决了难题，

569
00:36:00,850 --> 00:36:05,200
他们会把这个区块发送给网络中的每个人，

570
00:36:05,650 --> 00:36:09,730
每个人都可以检查节点是否真的正确地解决了难题，

571
00:36:10,000 --> 00:36:14,050
如果难题在交易检查中正确，

572
00:36:14,050 --> 00:36:15,850
哈希检查，

573
00:36:16,030 --> 00:36:19,210
然后它们会接受这个区块作为链中的下一个区块。

574
00:36:22,540 --> 00:36:24,070
所以说得更详细一点，

575
00:36:25,570 --> 00:36:33,570
当获胜者到达下一个区块，

576
00:36:33,570 --> 00:36:35,580
所以我们有了一个新的区块，

577
00:36:39,720 --> 00:36:42,480
这将是工作量证明，

578
00:36:42,480 --> 00:36:45,990
通常做工作量证明的一方被称为矿工，

579
00:36:47,240 --> 00:36:48,620
我们很快会知道为什么。

580
00:36:51,410 --> 00:36:56,660
我们要玩的游戏是，

581
00:37:01,370 --> 00:37:04,970
矿工必须计算这个新数据块的哈希，

582
00:37:05,440 --> 00:37:12,800
为了包含 n 个前导零。

583
00:37:17,510 --> 00:37:21,620
所以，矿工可以做到的方式是，

584
00:37:21,620 --> 00:37:23,930
通过改变 nonce ，

585
00:37:23,930 --> 00:37:27,320
所以矿工对 nonce 进行随机猜测，

586
00:37:27,710 --> 00:37:32,240
计算哈希并检查前导零的个数，

587
00:37:32,240 --> 00:37:36,170
如果前导零的数量越大，

588
00:37:36,230 --> 00:37:39,080
那么这个块是会被接受。

589
00:37:40,080 --> 00:37:41,490
你可以考虑的唯一办法是，

590
00:37:41,490 --> 00:37:48,870
哈希值低于某个特定难度的值，

591
00:37:49,780 --> 00:37:52,870
这个 N 可以随着时间的推移而改变，

592
00:37:52,870 --> 00:37:54,100
正如我们将在后面看到的，

593
00:37:54,220 --> 00:37:56,950
来调整难度，

594
00:37:57,160 --> 00:38:05,130
但平均而言，矿工工作是必须的，

595
00:38:05,130 --> 00:38:07,800
所以他们的目标是

596
00:38:07,800 --> 00:38:11,220
大约一个月的 CPU 计算。

597
00:38:12,740 --> 00:38:14,150
它并不是以这种方式表达的，

598
00:38:14,150 --> 00:38:16,760
是用每秒可以执行的哈希数来表示的，

599
00:38:17,120 --> 00:38:21,050
但归根结底，这是一种数字。

600
00:38:21,780 --> 00:38:24,420
当然，很多节点同时做这个，

601
00:38:24,630 --> 00:38:27,630
我认为网络目前大约有 10,000 个节点，

602
00:38:27,630 --> 00:38:28,920
可能有 10,000 个节点，

603
00:38:28,920 --> 00:38:30,420
可能会有更多的矿工，

604
00:38:30,840 --> 00:38:33,810
我认为数十万矿工，

605
00:38:33,990 --> 00:38:35,880
他们可能会幸运，

606
00:38:35,880 --> 00:38:38,940
很快找到了正确的 nonce ，

607
00:38:39,210 --> 00:38:43,230
他们中的一些人快一点，

608
00:38:43,230 --> 00:38:45,630
所以，他们的目标是，

609
00:38:45,630 --> 00:38:48,450
第一个解决这个难题，

610
00:38:48,570 --> 00:38:49,980
大约需要十分钟。

611
00:38:54,440 --> 00:38:57,350
我的意思是，通过调整难度，

612
00:38:57,590 --> 00:39:01,970
或者[]应该只是时间，

613
00:39:02,060 --> 00:39:06,860
其中计算这些散列能量之一所需的时间，

614
00:39:06,860 --> 00:39:09,800
只有这样才能真正解开这个难题。

615
00:39:11,060 --> 00:39:17,430
所以，无论哪个矿工首先解决了这个难题，

616
00:39:17,580 --> 00:39:21,000
就在整个网络中传播数据块，

617
00:39:21,210 --> 00:39:24,030
这么做大概需要十分钟，

618
00:39:24,030 --> 00:39:27,030
所以，十分钟的一个原因是，

619
00:39:27,210 --> 00:39:30,660
移动 1MB 数据块需要一点时间，

620
00:39:30,660 --> 00:39:33,330
通过整个网络中的很多节点，

621
00:39:33,720 --> 00:39:35,940
而且，你要确保，

622
00:39:35,940 --> 00:39:41,960
有足够的时间将区块提供给许多节点，

623
00:39:42,200 --> 00:39:44,330
这样你就可以避免 fork ，

624
00:39:44,330 --> 00:39:45,350
我们一会儿就会看到，

625
00:39:46,620 --> 00:39:49,770
在其他人也解决了这个难题之前。

626
00:39:51,170 --> 00:39:52,520
嗯，教授，

627
00:39:53,210 --> 00:39:58,940
所以需要一些前导零，

628
00:39:58,940 --> 00:40:03,380
哈希值需要被节点接受，

629
00:40:03,410 --> 00:40:06,530
它是每个节点单独设置的数字吗？

630
00:40:06,530 --> 00:40:08,480
不，不，这是协议的难题，

631
00:40:08,480 --> 00:40:09,590
一个商定的难题。

632
00:40:09,890 --> 00:40:11,240
但是，但是。

633
00:40:11,240 --> 00:40:12,920
这是关于 N 的共识。

634
00:40:13,850 --> 00:40:15,920
但我的意思是，

635
00:40:15,920 --> 00:40:18,320
这是协议的难题，但是，

636
00:40:21,340 --> 00:40:22,930
所以，所以，所以。

637
00:40:22,930 --> 00:40:24,520
你可以改变，也会随着时间的推移而改变。

638
00:40:25,090 --> 00:40:27,100
行为良好的节点将跟随它，

639
00:40:27,100 --> 00:40:30,160
但是谁计算，

640
00:40:30,160 --> 00:40:35,620
一个中央服务器计算出 N 并将它发到所有地方。

641
00:40:35,650 --> 00:40:37,060
不，不，我们稍后会看到的，

642
00:40:37,060 --> 00:40:38,380
它是如何计算的，

643
00:40:38,770 --> 00:40:42,520
我可以给你一个关于它是如何计算的提示，

644
00:40:42,670 --> 00:40:45,520
时间戳在里的原因之一，

645
00:40:46,270 --> 00:40:50,950
如果一个块之间的时间变得太短，

646
00:40:51,190 --> 00:40:52,870
然后难度就上升了。

647
00:40:54,710 --> 00:40:58,130
当然，这些时间戳是使用哈希值进行验证的，

648
00:40:58,130 --> 00:41:00,110
所有这些东西都在区块链中，

649
00:41:00,110 --> 00:41:01,670
每个人都看到相同的区块链，

650
00:41:02,120 --> 00:41:05,150
所以，它们将计算时间戳之间的相同差值，

651
00:41:05,150 --> 00:41:07,850
并在难度方面做出同样的调整。

652
00:41:08,660 --> 00:41:09,560
好的。

653
00:41:09,710 --> 00:41:11,180
这是一个很酷的部分，

654
00:41:11,180 --> 00:41:12,920
有一个任何东西的日志，

655
00:41:12,920 --> 00:41:14,330
如果你有一些确定性的，

656
00:41:14,330 --> 00:41:17,990
你可以对日志的内容计算任何确定性函数。

657
00:41:18,680 --> 00:41:20,460
好的，好的，

658
00:41:20,490 --> 00:41:23,640
所以这将是一个确定性函数，

659
00:41:23,640 --> 00:41:24,630
但归根结底，

660
00:41:24,630 --> 00:41:32,190
比如，如果我尝试发送少于 N 个零，

661
00:41:32,400 --> 00:41:36,690
然后网络中的每个节点都会把我赶出来。

662
00:41:36,750 --> 00:41:38,130
是的，它们会拒绝你的解决方案，

663
00:41:38,190 --> 00:41:39,810
因为你没有真正的解决方案。

664
00:41:40,710 --> 00:41:42,060
好的，谢谢。

665
00:41:42,780 --> 00:41:44,640
那么，是什么阻止攻击者

666
00:41:44,640 --> 00:41:47,970
不断地向网络发送错误的解决方案？

667
00:41:48,500 --> 00:41:50,030
是的，拒绝服务攻击，

668
00:41:50,060 --> 00:41:55,670
幸运地是检查解决方案非常容易，

669
00:41:55,700 --> 00:41:58,730
所以，很容易迅速拒绝一个不正确的解决方案。

670
00:42:01,370 --> 00:42:01,850
谢谢。

671
00:42:02,620 --> 00:42:05,410
如何确定时间戳，

672
00:42:05,680 --> 00:42:08,830
比如每个块设置自己的时间戳。

673
00:42:09,430 --> 00:42:13,480
是的，成功开采的矿工在块中设置时间戳。

674
00:42:14,660 --> 00:42:20,540
如果他们将时间戳设置为比所用时间更长的时间，

675
00:42:20,720 --> 00:42:22,250
这样就不那么困难了。

676
00:42:22,250 --> 00:42:23,750
它不能说谎太多，

677
00:42:23,750 --> 00:42:24,890
他们有 10 分钟的时间，

678
00:42:24,890 --> 00:42:26,120
所以粗略地说，

679
00:42:26,120 --> 00:42:28,580
我不知道时间戳是如何检查的，

680
00:42:28,580 --> 00:42:32,800
我不知道，也许可以想象这是可以解决的。

681
00:42:36,080 --> 00:42:40,700
获得交易的节点想要附加到块中。

682
00:42:42,440 --> 00:42:42,830
谢谢，这是下一行。

683
00:42:44,560 --> 00:42:47,150
所以，所以块和交易，

684
00:42:57,310 --> 00:42:59,170
所以让我们假设有一些

685
00:42:59,260 --> 00:43:02,410
B5 被计算出来了，

686
00:43:02,410 --> 00:43:06,610
在日志中的，指向 B4 ，

687
00:43:07,940 --> 00:43:09,470
我们是一个矿工，

688
00:43:09,500 --> 00:43:11,180
我们工作在，

689
00:43:11,690 --> 00:43:13,520
我们有一个区块，

690
00:43:13,850 --> 00:43:15,860
这是一种提醒，

691
00:43:15,860 --> 00:43:18,720
所以它有一些交易，

692
00:43:18,720 --> 00:43:24,360
我们试着计算这个难题的答案，

693
00:43:24,660 --> 00:43:26,490
所以新的交易来了，

694
00:43:26,490 --> 00:43:27,390
它们到了，

695
00:43:28,450 --> 00:43:31,810
新的交易调用内存缓冲区，

696
00:43:31,810 --> 00:43:33,790
一个缓冲，你需要一些缓冲，

697
00:43:34,150 --> 00:43:39,130
它们会到下一个区块，

698
00:43:39,190 --> 00:43:42,160
在某个时刻，

699
00:43:42,370 --> 00:43:45,550
这个人，假设这是一个矿工 i ，

700
00:43:46,850 --> 00:43:49,580
好的，我们看到矿工 i 是幸运的，

701
00:43:49,610 --> 00:43:55,100
矿工 i 计算出新的 B6 。

702
00:43:56,140 --> 00:43:58,270
在某个时刻， B6 ，

703
00:43:58,780 --> 00:44:02,980
这是日志的新的下一个头部，

704
00:44:03,010 --> 00:44:05,230
包含一堆交易，

705
00:44:05,830 --> 00:44:08,980
所以，当矿工 i 试着哈希，

706
00:44:09,010 --> 00:44:13,150
计算很多哈希才能解决这个难题，

707
00:44:13,210 --> 00:44:14,410
新的交易进来，

708
00:44:14,650 --> 00:44:19,150
在矿工 i 完成 B6 时，

709
00:44:19,210 --> 00:44:22,330
它选择交易数量，

710
00:44:22,390 --> 00:44:24,760
将一个新的块放在一起，部分块，

711
00:44:24,790 --> 00:44:26,470
这还不是那个解决的问题，

712
00:44:27,650 --> 00:44:29,300
来自[池]的交易，

713
00:44:29,690 --> 00:44:33,080
更新，无论[]需要更新，

714
00:44:33,080 --> 00:44:36,680
然后对这个进行哈希并希望解决它，

715
00:44:36,680 --> 00:44:40,070
所以，可以在之后的某个时间将其添加到交易日志中。

716
00:44:40,070 --> 00:44:41,030
如果它成功了。

717
00:44:41,760 --> 00:44:48,150
当然，如果其他人在矿工 i 之前成功解决了 B7 ，

718
00:44:48,240 --> 00:44:50,550
矿工 i 将转向 B7 ，

719
00:44:50,670 --> 00:44:55,680
那个块删除已在 B7 中结束所有交易，

720
00:44:55,770 --> 00:44:59,130
并继续处理剩下的，还不在 B7 中的交易。

721
00:45:01,170 --> 00:45:04,190
好的，这就是方案，

722
00:45:04,370 --> 00:45:09,730
关于各个区块如何交互的，在高级别上。

723
00:45:12,470 --> 00:45:16,720
所以，随着交易的到来，

724
00:45:17,050 --> 00:45:21,190
试着计算区块的 nonce ，

725
00:45:21,580 --> 00:45:25,570
这会给你 N 个前导零，

726
00:45:25,810 --> 00:45:29,020
新的交易会进来。

727
00:45:29,020 --> 00:45:31,390
因为它们[]，不是那个区块的一部分，

728
00:45:31,420 --> 00:45:33,730
它们将在旁边，它们是下一个区块的。

729
00:45:34,250 --> 00:45:34,850
好的。

730
00:45:36,210 --> 00:45:40,860
你能不能把它们加到。

731
00:45:40,860 --> 00:45:42,030
那会改变哈希值。

732
00:45:43,040 --> 00:45:45,200
是的，但我的意思是，

733
00:45:45,650 --> 00:45:48,920
你只需要继续获取一个 nonce 。

734
00:45:48,920 --> 00:45:51,500
但你也有块大小的限制，

735
00:45:51,800 --> 00:45:53,780
区块大小不能大于，

736
00:45:53,780 --> 00:45:56,810
协议规定的某个预定义常量，

737
00:45:57,110 --> 00:45:59,600
是的，还有一堆其他原因，

738
00:45:59,600 --> 00:46:01,760
一旦[]交易的区块，

739
00:46:01,760 --> 00:46:05,180
你继续计算哈希，直到你找到解决方案。

740
00:46:05,670 --> 00:46:06,210
好的。

741
00:46:07,130 --> 00:46:09,290
或者你会得到。

742
00:46:09,290 --> 00:46:11,150
或者你收到一个新的，然后你拒绝，

743
00:46:11,150 --> 00:46:13,700
继续去做下一个。

744
00:46:15,020 --> 00:46:15,530
好的，谢谢。

745
00:46:16,340 --> 00:46:20,210
所以当矿工输了的时候，

746
00:46:20,390 --> 00:46:21,740
他们是不是，

747
00:46:22,480 --> 00:46:25,660
比如矿工永远不会从中获利，

748
00:46:25,660 --> 00:46:27,310
因为他们一直在输，

749
00:46:27,310 --> 00:46:28,390
因为他们没有足够的计算。

750
00:46:28,420 --> 00:46:29,920
是的，当然，

751
00:46:29,920 --> 00:46:32,800
如果我开始用我的笔记本电脑挖矿，

752
00:46:32,800 --> 00:46:34,060
我很肯定它不会赚到钱。

753
00:46:37,100 --> 00:46:40,280
交易池，它是本地的吗？

754
00:46:41,100 --> 00:46:44,880
是的，每个节点都维护着一个交易池，

755
00:46:44,880 --> 00:46:50,460
当它们从网络中的其他节点接收交易时，

756
00:46:50,460 --> 00:46:52,200
交易池，

757
00:46:52,200 --> 00:46:55,800
他们使用交易池来使下一个区块失败。

758
00:46:57,430 --> 00:46:57,790
所以。

759
00:46:57,790 --> 00:46:59,230
以及各种各样的规则，

760
00:46:59,230 --> 00:47:01,390
比如你如何选择交易，

761
00:47:01,480 --> 00:47:02,620
我不打算谈论这一点。

762
00:47:02,890 --> 00:47:06,640
好的，所以要追加，你需要把你的交易告诉每个人。

763
00:47:07,780 --> 00:47:11,260
是的，或者你告诉一群节点，

764
00:47:11,260 --> 00:47:13,090
它们会把它传播给其他节点，

765
00:47:13,210 --> 00:47:14,380
到网络的其余部分。

766
00:47:18,100 --> 00:47:19,510
所以，根据我的理解，

767
00:47:19,510 --> 00:47:27,640
当一名矿工成功挖掘或核实一笔交易时，他们会得到奖励。

768
00:47:27,760 --> 00:47:28,360
是的。

769
00:47:28,390 --> 00:47:30,280
他们做了这个核实，

770
00:47:30,340 --> 00:47:33,580
但当涉及到时间戳时，他们也可以撒谎，

771
00:47:33,670 --> 00:47:35,560
假设你有两个验证者，

772
00:47:35,560 --> 00:47:37,240
并且它们都在同一块上工作，

773
00:47:37,450 --> 00:47:40,960
而且它们几乎同时核实，

774
00:47:41,140 --> 00:47:44,710
但其中一个，它们撒谎了，

775
00:47:44,770 --> 00:47:47,440
它们把时间戳做得更早了一点，

776
00:47:47,620 --> 00:47:50,380
所以有点像。

777
00:47:50,380 --> 00:47:52,480
困难[]一段时间，

778
00:47:52,870 --> 00:47:55,570
比如在接下来的二十年里，

779
00:47:55,570 --> 00:47:57,040
它只会周期性地变化，

780
00:47:57,460 --> 00:47:58,930
你不能随意改变它。

781
00:47:59,880 --> 00:48:02,460
所以是什么，抱歉，我想我错过了这句话。

782
00:48:02,820 --> 00:48:06,480
难度并不是在每个区块改变，

783
00:48:06,900 --> 00:48:09,000
它会定期更改，

784
00:48:09,000 --> 00:48:11,850
在一定数量的区块计算出来之后。

785
00:48:12,480 --> 00:48:14,280
所以它是在后面完成的，

786
00:48:14,280 --> 00:48:16,560
每个人都能看到这些时间戳是什么，

787
00:48:16,650 --> 00:48:20,880
我想每个[]有确切数量的区块，

788
00:48:20,880 --> 00:48:24,270
当难度调整后。

789
00:48:25,140 --> 00:48:25,650
我明白了。

790
00:48:27,970 --> 00:48:30,760
在这一点上，你已经同意了过去所有的区块，

791
00:48:30,790 --> 00:48:34,180
所以每个人都达成了一致，时间戳是什么，

792
00:48:34,180 --> 00:48:37,390
我们用来计算一个新的合法的区块。

793
00:48:39,530 --> 00:48:46,760
所以，我有一个关于达成共识的问题，

794
00:48:46,760 --> 00:48:50,480
我想所有这一切都依赖于，

795
00:48:50,970 --> 00:48:54,750
几乎每个节点都运行相同的代码，

796
00:48:54,750 --> 00:48:58,710
或者至少非常精确地遵守规则，

797
00:48:59,550 --> 00:49:02,190
如果我的代码中有 bug ，会发生什么，

798
00:49:02,250 --> 00:49:03,330
我正在运行的代码，

799
00:49:03,750 --> 00:49:08,130
也许有一个 bug 在一堆不同的节点上，

800
00:49:09,590 --> 00:49:14,720
这是不是抛出了一致性的概念。

801
00:49:15,560 --> 00:49:18,710
是的，只要大多数人是，

802
00:49:18,710 --> 00:49:19,970
我们会更多地讨论这个问题，

803
00:49:19,970 --> 00:49:23,030
拥有大多数节点运行正确的代码，

804
00:49:23,030 --> 00:49:24,200
就能正常工作。

805
00:49:24,440 --> 00:49:28,380
但如果代码里有后门，

806
00:49:28,380 --> 00:49:29,760
是的，你会遇到麻烦，

807
00:49:29,760 --> 00:49:32,100
比如，如果 Linux 中有后门，那么你也会有问题。

808
00:49:33,940 --> 00:49:39,280
所以，每个节点运行相同的代码，或者是。

809
00:49:39,280 --> 00:49:41,770
有几个不同的比特币版本，

810
00:49:41,770 --> 00:49:43,300
稍后我们会更详细地讨论，

811
00:49:43,390 --> 00:49:48,100
但它们有一个主要的核心，

812
00:49:48,100 --> 00:49:50,470
有一个开源项目，

813
00:49:50,470 --> 00:49:51,550
像 Linux 一样，

814
00:49:51,550 --> 00:49:55,630
它有维护者，代码审查和所有类似的事情。

815
00:49:56,860 --> 00:50:00,610
而大多数钱包和大多数节点

816
00:50:00,610 --> 00:50:03,640
都会运行其中一个标准化版本。

817
00:50:04,560 --> 00:50:05,100
谢谢。

818
00:50:11,070 --> 00:50:12,390
好了， forks 。

819
00:50:13,740 --> 00:50:17,550
所以，我们现在知道规则是什么，

820
00:50:17,550 --> 00:50:23,310
谁可以扩展日志或链，

821
00:50:23,370 --> 00:50:24,480
你也可以有分叉。

822
00:50:25,230 --> 00:50:31,160
好的，这是我们新的链， B5 B6 ，

823
00:50:31,580 --> 00:50:35,210
我们，有人可能真的会很幸运，

824
00:50:35,240 --> 00:50:39,020
几乎在同一时间计算出 B7 ，

825
00:50:39,050 --> 00:50:41,240
所以你有 B7' ，

826
00:50:41,770 --> 00:50:43,510
我们这里有 B7'' ，

827
00:50:45,910 --> 00:50:48,580
这对我们来说是有问题的，

828
00:50:48,580 --> 00:50:53,230
因为这条链中可能有一条交易，

829
00:50:53,230 --> 00:50:56,980
从 y 到 z ，

830
00:50:57,950 --> 00:51:00,200
也许这个是 y 到 Q ，

831
00:51:02,400 --> 00:51:04,200
我们在某种程度上确定，

832
00:51:04,200 --> 00:51:06,120
我们会位于一条链上。

833
00:51:07,080 --> 00:51:09,670
这一变化可能会[]的原因有两个，

834
00:51:10,120 --> 00:51:16,500
一个是参与者找到，

835
00:51:17,140 --> 00:51:18,700
同时找到了 nonce ，

836
00:51:22,510 --> 00:51:23,890
或者大致在同一时间，

837
00:51:24,440 --> 00:51:26,000
第二个是，

838
00:51:26,000 --> 00:51:27,560
可能存在速度较慢的网络，

839
00:51:30,940 --> 00:51:35,290
一个节点可能会从两个节点接收，

840
00:51:35,290 --> 00:51:36,520
从不同的网络上，

841
00:51:36,520 --> 00:51:38,350
在某一点上，有两个新的解决方案，

842
00:51:39,080 --> 00:51:43,730
当一个节点在这种情况下结束时，

843
00:51:43,760 --> 00:51:44,720
什么都不做，

844
00:51:44,900 --> 00:51:46,640
像往常一样，继续保留 fork ，

845
00:51:46,910 --> 00:51:49,910
等待那个 fork 会扩展，

846
00:51:50,300 --> 00:51:51,950
也许这个会工作，

847
00:51:51,950 --> 00:51:55,070
下面这个会扩展， B8 ，

848
00:51:55,610 --> 00:51:57,320
然后规则非常简单，

849
00:51:57,410 --> 00:52:05,700
节点切换到最长的 fork ，

850
00:52:11,690 --> 00:52:15,890
所以，基本上，

851
00:52:15,890 --> 00:52:18,260
所有交易都会知道，

852
00:52:18,260 --> 00:52:20,600
在这个 fork ，上面这个 fork 中，

853
00:52:20,720 --> 00:52:21,740
就这么消失了，

854
00:52:21,770 --> 00:52:24,650
这个在系统里不会有什么问题，

855
00:52:24,920 --> 00:52:26,150
因为最终，

856
00:52:26,210 --> 00:52:29,780
所有这些好的节点都会在最长的链上达成一致，

857
00:52:30,020 --> 00:52:33,830
沿着最长的链进行采矿。

858
00:52:35,010 --> 00:52:35,970
这是基本的方案，

859
00:52:36,510 --> 00:52:38,250
所以，让我们来看看，

860
00:52:38,250 --> 00:52:41,640
这将如何解决我们的双重花费问题。

861
00:52:43,880 --> 00:52:47,090
稍等，我对你的幻灯片有个问题。

862
00:52:47,510 --> 00:52:50,210
是的，我将在这张幻灯片继续上一张幻灯片。

863
00:52:50,690 --> 00:52:52,550
哦，好的，那么。

864
00:52:52,580 --> 00:52:54,080
如果你有任何问题，那么。

865
00:52:54,840 --> 00:52:59,610
所以，即使在第二个原因中，比如网络速度慢，

866
00:53:00,150 --> 00:53:02,490
你能不能检测到，

867
00:53:02,490 --> 00:53:05,640
如果矿工包含的时间戳，

868
00:53:05,640 --> 00:53:07,770
当他们找到解决方案时？

869
00:53:08,930 --> 00:53:13,670
是的，好的。

870
00:53:14,660 --> 00:53:17,750
你可能已经心存疑虑或者可能同意，

871
00:53:17,750 --> 00:53:20,750
什么是下一个正确的链，

872
00:53:20,780 --> 00:53:24,050
但这将在之后的区块得到确认，

873
00:53:24,800 --> 00:53:28,370
而你使用的未来的区块确实最长的链是什么。

874
00:53:30,630 --> 00:53:31,140
好的。

875
00:53:34,060 --> 00:53:37,660
好的，双重花费，

876
00:53:37,660 --> 00:53:40,150
那么让我们来谈谈两个案例，

877
00:53:40,150 --> 00:53:42,310
第一个很容易，

878
00:53:42,310 --> 00:53:49,900
y 发送 ， y 到 z ， y 到 Q ，

879
00:53:50,950 --> 00:53:52,780
给某个节点，

880
00:53:54,950 --> 00:53:57,470
在这种情况下会发生的是，

881
00:53:57,470 --> 00:53:58,670
它是一个正常的节点，

882
00:53:58,670 --> 00:53:59,660
你会看到，实际上我花了两次相同的钱的交易将被拒绝，

883
00:53:59,660 --> 00:54:06,290
花费相同钱两次的交易会被拒绝，

884
00:54:06,320 --> 00:54:09,170
收到的节点试着，

885
00:54:09,170 --> 00:54:11,540
或者一个矿工组件区块，

886
00:54:11,600 --> 00:54:13,400
它验证所有交易，

887
00:54:13,400 --> 00:54:14,840
在把它们放入区块之前。

888
00:54:15,610 --> 00:54:18,460
所以这不会奏效，

889
00:54:18,460 --> 00:54:20,230
好的矿工会拒绝。

890
00:54:24,310 --> 00:54:26,710
好的，第二个问题，更有趣，

891
00:54:26,710 --> 00:54:34,120
y 发送， y 到 z ，给一些节点，

892
00:54:35,980 --> 00:54:40,530
然后 y 到 Q ，到另一组节点。

893
00:54:47,160 --> 00:54:51,210
然后可能，

894
00:54:51,240 --> 00:54:54,570
也许一个池比另一个大，

895
00:54:54,780 --> 00:54:56,970
但它可能会是一种情况，

896
00:54:56,970 --> 00:54:59,940
像之前一样，我们得到了链，

897
00:55:00,330 --> 00:55:06,390
一旦它出现计算哈希值，

898
00:55:06,390 --> 00:55:08,250
其中包括 y 到 Q ，

899
00:55:09,000 --> 00:55:12,750
另一个计算包含 y 到 z 的块。

900
00:55:13,740 --> 00:55:16,560
所以这看起来像是双重花费的事情，

901
00:55:16,710 --> 00:55:18,570
所以如果你是 z ，

902
00:55:18,570 --> 00:55:20,730
z 是做决定的人，

903
00:55:20,730 --> 00:55:23,100
是否接受这笔交易，

904
00:55:23,100 --> 00:55:26,130
并发出拿铁，

905
00:55:26,250 --> 00:55:28,620
你要做的就是等待，

906
00:55:29,380 --> 00:55:31,030
你要等到直到

907
00:55:31,210 --> 00:55:33,820
有很多块在它后面，

908
00:55:33,880 --> 00:55:37,180
所以通常是 5 6 ，

909
00:55:37,510 --> 00:55:38,830
对于一个非常有价值的交易，

910
00:55:38,830 --> 00:55:39,790
可能不是一杯拿铁，

911
00:55:39,790 --> 00:55:41,110
但如果你要买车，

912
00:55:41,380 --> 00:55:43,420
你真的想要确定，

913
00:55:43,420 --> 00:55:44,650
你会拿到你的钱，

914
00:55:44,890 --> 00:55:48,730
而且 y 没有双重花费他的钱，

915
00:55:49,270 --> 00:55:53,860
所以，你可能等待一段时间，

916
00:55:54,370 --> 00:55:56,500
直到新的哈希结束，

917
00:55:56,620 --> 00:56:00,220
到一个新的区块扩展到区块链，

918
00:56:00,340 --> 00:56:02,410
一旦你有 5 6 个，

919
00:56:02,500 --> 00:56:05,200
论文做了一些计算，

920
00:56:05,230 --> 00:56:08,260
你会非常自信，

921
00:56:08,560 --> 00:56:15,070
攻击者计算出一条新链，

922
00:56:15,280 --> 00:56:18,730
并且超过更长的链，

923
00:56:18,730 --> 00:56:20,170
假设这是攻击者，

924
00:56:20,380 --> 00:56:22,480
攻击者的计算能力较弱，

925
00:56:22,510 --> 00:56:25,390
他们在论文的假设中，

926
00:56:25,390 --> 00:56:27,520
弱于所有好人的计算能力，

927
00:56:27,850 --> 00:56:31,030
所以，如果好人有更多的计算能力，

928
00:56:31,060 --> 00:56:33,730
对于攻击者来说，这是不可能的，

929
00:56:34,120 --> 00:56:37,660
不太可能，或者不可能

930
00:56:37,660 --> 00:56:40,510
或不太可能让攻击者计算得更快，

931
00:56:40,660 --> 00:56:43,510
做出一个比好链更长的链。

932
00:56:44,580 --> 00:56:48,210
所以，这是这一切背后的关键假设，

933
00:56:48,270 --> 00:56:51,930
这其中原因。

934
00:56:53,560 --> 00:56:56,830
所以 z 只需要等待一段时间，

935
00:56:56,950 --> 00:57:00,430
在好人延长到足够长的链条之前，

936
00:57:00,430 --> 00:57:02,710
z 完全相信，

937
00:57:02,740 --> 00:57:05,950
攻击者是不可能的，

938
00:57:05,950 --> 00:57:08,950
算力超过好人。

939
00:57:10,440 --> 00:57:13,890
在这一点上， z 可以接受交易，

940
00:57:14,220 --> 00:57:16,080
然后说，这是合法的交易，

941
00:57:16,080 --> 00:57:17,370
如果其他一切都没问题，

942
00:57:17,670 --> 00:57:24,480
然后把拿铁或者车交给 z ，或交给 y 。

943
00:57:26,150 --> 00:57:29,180
抱歉，一个小问题，谁分发这些难题的？

944
00:57:30,520 --> 00:57:36,010
没有必要分配难题，

945
00:57:37,570 --> 00:57:39,970
难题是预先确定的，

946
00:57:40,030 --> 00:57:40,900
这个难题是，

947
00:57:40,900 --> 00:57:45,730
你必须通过块计算出一个哈希值，有足够的前导零，

948
00:57:49,160 --> 00:57:51,230
所以没有难题的分发，

949
00:57:51,230 --> 00:57:53,090
唯一被分发的东西可能是它的难度，

950
00:57:53,090 --> 00:57:54,470
但正如我们之前所说的，

951
00:57:54,470 --> 00:57:57,320
这种情况通过时间以一种确定性的方式进行调整。

952
00:57:58,780 --> 00:57:59,500
谢谢。

953
00:58:00,500 --> 00:58:03,980
所以所有这些发生的交易，

954
00:58:03,980 --> 00:58:07,010
然后通过一些 gossip 协议或者别的什么，

955
00:58:07,070 --> 00:58:09,080
交易被分发给所有节点，

956
00:58:09,540 --> 00:58:14,720
然后达成一致，

957
00:58:14,900 --> 00:58:17,540
哪些交易打包成一个块，

958
00:58:17,540 --> 00:58:20,120
每个人都对区块达成了一致。

959
00:58:20,650 --> 00:58:26,080
不，不出，矿工收到交易，

960
00:58:27,260 --> 00:58:29,390
我们到这里，它在哪里，

961
00:58:31,300 --> 00:58:34,090
区块，有一些幻灯片。

962
00:58:34,090 --> 00:58:35,830
我想是下一个。

963
00:58:37,870 --> 00:58:39,070
是的，交易中的块，

964
00:58:39,100 --> 00:58:43,850
所以矿工，可能是矿工 i 通过网络接收交易，

965
00:58:43,850 --> 00:58:46,430
它决定将哪些交易放在该块中，

966
00:58:46,980 --> 00:58:48,690
然后它开始计算，

967
00:58:48,690 --> 00:58:49,710
如果它赢了，

968
00:58:49,740 --> 00:58:51,720
这就是进入那个区块的交易。

969
00:58:52,670 --> 00:58:53,300
我明白了。

970
00:58:54,020 --> 00:58:55,490
所以这决定了总的顺序，

971
00:58:55,940 --> 00:58:58,640
总顺序是由之前的块分发的，

972
00:58:58,640 --> 00:59:00,740
可以接近这个新的块，

973
00:59:00,770 --> 00:59:02,810
矿工 i 决定什么东西进去，

974
00:59:03,230 --> 00:59:04,640
而且还有一些复杂的规则，

975
00:59:04,640 --> 00:59:06,740
矿工们应该遵循的，

976
00:59:06,800 --> 00:59:09,110
但是，矿工可以做出决定。

977
00:59:10,840 --> 00:59:11,680
谢谢。

978
00:59:16,400 --> 00:59:19,070
而且有一定的激励制度让矿工们做正确的事情。

979
00:59:20,480 --> 00:59:22,400
所以让我谈一下这个问题，

980
00:59:22,400 --> 00:59:28,400
到目前为止，我们看到了这个难题，

981
00:59:28,400 --> 00:59:30,710
这是工作量证明想法的核心，

982
00:59:30,710 --> 00:59:33,980
是真正达成共识的核心，

983
00:59:34,280 --> 00:59:39,710
但是这需要矿工们做相当多的工作，

984
00:59:39,740 --> 00:59:43,670
他们必须计算哈希，拥有一台好的计算机，

985
00:59:43,820 --> 00:59:45,980
我们看到大约一个月的工作，

986
00:59:46,670 --> 00:59:48,110
那么为什么一个矿工要这么做，

987
00:59:48,530 --> 00:59:50,120
所以，有一个激励系统

988
00:59:50,120 --> 00:59:53,210
来鼓励矿工扮演这个角色。

989
01:00:02,510 --> 01:00:04,220
这里有一条规则，

990
01:00:04,580 --> 01:00:09,350
有一些比特币保留在池中，

991
01:00:09,380 --> 01:00:13,340
比如第一批比特币交易被创建时，

992
01:00:13,820 --> 01:00:17,990
矿工们从池子里拿到了奖励，

993
01:00:18,110 --> 01:00:19,940
所以这是第一笔交易，

994
01:00:23,070 --> 01:00:28,860
区块中的交易是对矿工的奖励。

995
01:00:33,260 --> 01:00:35,960
所以矿工可以插入交易

996
01:00:35,960 --> 01:00:39,830
在第一个[]交易中的块，第一个插槽，

997
01:00:40,160 --> 01:00:43,640
这是矿工的公钥，

998
01:00:43,820 --> 01:00:48,450
把钱从池中转到他自己身上。

999
01:00:48,990 --> 01:00:53,520
这就是矿工可以，

1000
01:00:53,520 --> 01:00:59,280
他们所做的工作得到某种回报或奖励，

1001
01:00:59,640 --> 01:01:02,400
这种奖励会随着时间的推移而变化，

1002
01:01:02,460 --> 01:01:05,040
现在我想是，

1003
01:01:05,070 --> 01:01:08,460
今天我想是 6.25 比特币，

1004
01:01:10,100 --> 01:01:12,020
才能真正开采一个区块，

1005
01:01:12,650 --> 01:01:14,480
但随着时间的推移，这种情况会发生变化，

1006
01:01:14,480 --> 01:01:16,130
它有一个减半规则，

1007
01:01:16,400 --> 01:01:19,700
减少一半，

1008
01:01:19,700 --> 01:01:23,600
几年前，是 12.5 比特币，

1009
01:01:23,930 --> 01:01:26,300
在一段时间之后，

1010
01:01:26,300 --> 01:01:29,300
三点几， 6.25 的一半，

1011
01:01:29,300 --> 01:01:35,240
我记得每 21 万个区块，

1012
01:01:35,510 --> 01:01:36,920
这个数字减半，

1013
01:01:37,430 --> 01:01:47,000
直到它遇到了最可接受的比特币分母，

1014
01:01:47,000 --> 01:01:48,560
然后就会停下来。

1015
01:01:49,310 --> 01:01:50,600
但我们还有一段时间，

1016
01:01:50,630 --> 01:01:52,520
在这种情况之前，

1017
01:01:52,670 --> 01:01:53,840
如果发生这种情况，

1018
01:01:53,960 --> 01:01:56,210
然后，想法是，

1019
01:01:56,210 --> 01:01:59,420
为了挖一个区块，每一个交易都需要支付一点费用，

1020
01:01:59,780 --> 01:02:04,550
矿工收取区块所有交易的费用，

1021
01:02:04,760 --> 01:02:08,840
并用这些费用奖励矿工，

1022
01:02:09,140 --> 01:02:10,520
即使是现在也有一些费用，

1023
01:02:10,550 --> 01:02:13,910
但要确保做到这一点，

1024
01:02:13,910 --> 01:02:15,830
这些交易并不是[]，

1025
01:02:16,160 --> 01:02:22,040
所以实际上矿工的收入不仅是 6.25 ，

1026
01:02:22,040 --> 01:02:24,920
但是费用，

1027
01:02:24,920 --> 01:02:28,730
还有伴随交易而来的费用。

1028
01:02:31,830 --> 01:02:33,540
好的，这是次要的激励。

1029
01:02:34,160 --> 01:02:38,660
比特币已经变得如此成功，

1030
01:02:38,660 --> 01:02:41,600
是一种矿工的军备竞赛，

1031
01:02:44,500 --> 01:02:45,490
这就像是，

1032
01:02:45,490 --> 01:02:47,530
如果我想参与，

1033
01:02:47,530 --> 01:02:49,960
当他们赚到一些钱，

1034
01:02:50,110 --> 01:02:51,130
我就要输钱，

1035
01:02:51,160 --> 01:02:57,610
因为好的矿工更擅长计算哈希，

1036
01:02:57,610 --> 01:02:58,780
效率非常高，

1037
01:02:59,500 --> 01:03:01,570
比你的标准笔记本能做到的。

1038
01:03:02,160 --> 01:03:04,980
所以，在这场军备竞赛中，发生了几件事，

1039
01:03:05,010 --> 01:03:07,500
首先是，矿工池，

1040
01:03:13,290 --> 01:03:14,280
所以基本的想法是，

1041
01:03:14,280 --> 01:03:16,020
矿工们彼此合作，

1042
01:03:16,230 --> 01:03:18,330
并相互分享收入，

1043
01:03:18,360 --> 01:03:21,000
所以如果你的池有很多很多节点，

1044
01:03:21,210 --> 01:03:25,020
也许来自不同的人们，

1045
01:03:25,020 --> 01:03:26,430
来自不同人的许多电脑，

1046
01:03:26,700 --> 01:03:30,180
人们可以分享采矿带来的收入流，

1047
01:03:30,180 --> 01:03:33,090
因为它们是作为一个池来做的，

1048
01:03:33,240 --> 01:03:36,720
他们更有可能赢，

1049
01:03:36,900 --> 01:03:40,350
当然从概率上讲，他们有一些获胜的机会，

1050
01:03:40,590 --> 01:03:44,070
通过收入流传播

1051
01:03:44,070 --> 01:03:47,640
以更稳定的形式在单一池中的所有矿工之间分配。

1052
01:03:48,430 --> 01:03:51,520
所以，如果你今天在网上看的话，

1053
01:03:51,700 --> 01:03:54,760
有一些非常大的池，

1054
01:03:55,000 --> 01:03:57,880
而且没有什么比得上三大池，

1055
01:03:58,090 --> 01:04:03,490
贡献出 50% 以上的采矿算力。

1056
01:04:06,330 --> 01:04:07,950
抱歉，为什么，

1057
01:04:08,520 --> 01:04:14,220
这就是你说的为什么每个块都需要大约 10 分钟的时间来挖掘，

1058
01:04:14,220 --> 01:04:17,070
尽管它需要一个月的 CPU 能力。

1059
01:04:17,340 --> 01:04:20,640
是的，平均一个月，

1060
01:04:20,640 --> 01:04:21,930
但你会有一些幸运的，

1061
01:04:21,930 --> 01:04:23,100
你选择了 nonce ，

1062
01:04:23,100 --> 01:04:27,240
很幸运，选择了 nonce ，

1063
01:04:27,240 --> 01:04:29,640
可以让你更快地解决问题，

1064
01:04:29,640 --> 01:04:30,810
总是有一个概率，

1065
01:04:30,810 --> 01:04:32,190
nonce 是某些大数，

1066
01:04:32,760 --> 01:04:34,110
如果你选对了数字，

1067
01:04:34,110 --> 01:04:35,520
你可以很幸运，

1068
01:04:35,520 --> 01:04:37,560
有很多矿工这样做，

1069
01:04:37,830 --> 01:04:38,880
是有可能的，

1070
01:04:38,880 --> 01:04:43,740
你只需要不到一个月的时间，

1071
01:04:43,740 --> 01:04:46,020
这就是十分钟的由来。

1072
01:04:46,360 --> 01:04:50,860
等等，是一个月更重要还是十分钟更重要，

1073
01:04:50,860 --> 01:04:53,830
因为如果只有一个矿工，

1074
01:04:53,920 --> 01:04:55,930
预计是一个月，

1075
01:04:56,580 --> 01:04:58,680
平均下来要一个月，对吧？

1076
01:04:58,680 --> 01:05:01,680
是的，但是有很多很多矿工。

1077
01:05:02,210 --> 01:05:04,610
但如果有，

1078
01:05:04,610 --> 01:05:06,410
如果有很多矿工，

1079
01:05:06,440 --> 01:05:09,020
矿工的能力是显而易见的。

1080
01:05:09,380 --> 01:05:11,900
有很多变量，但平均是 10 分钟，

1081
01:05:11,900 --> 01:05:15,590
[]的平均时间是十分钟。

1082
01:05:16,090 --> 01:05:16,600
好的。

1083
01:05:18,150 --> 01:05:21,120
有没有可能，难题是不可能的？

1084
01:05:23,180 --> 01:05:27,770
不，我不这么认为，可能要花很长时间。

1085
01:05:29,080 --> 01:05:31,000
将会有，

1086
01:05:34,020 --> 01:05:36,510
好的，你可以选择 nonce ，

1087
01:05:37,050 --> 01:05:39,180
会有这种情况，

1088
01:05:39,180 --> 01:05:44,280
哈希将落在 N 个前导零之内。

1089
01:05:47,670 --> 01:05:48,630
所以如何，

1090
01:05:48,630 --> 01:05:53,370
由于比特币的价值实际上非常不稳定，

1091
01:05:56,340 --> 01:05:58,050
那么我们如何才能确保

1092
01:05:58,050 --> 01:06:01,260
矿工的激励制度仍然足以

1093
01:06:01,260 --> 01:06:03,060
让这件事在未来继续下去，

1094
01:06:03,800 --> 01:06:07,160
我的意思是因为奖励数量是预先确定的，

1095
01:06:07,160 --> 01:06:08,930
假设是 6.25 比特币，

1096
01:06:09,110 --> 01:06:11,630
如果由于某种原因，比特币的价值下跌了，

1097
01:06:11,630 --> 01:06:13,490
然后，对矿工来说，激励措施不够好，

1098
01:06:13,490 --> 01:06:14,600
所以我只是觉得。

1099
01:06:14,750 --> 01:06:18,080
是的，矿工们这样做没有任何价值，

1100
01:06:18,080 --> 01:06:20,300
然后比特币网络崩溃了，

1101
01:06:20,300 --> 01:06:22,760
假设这件事会解决的，

1102
01:06:22,760 --> 01:06:24,530
就是交易费用上涨。

1103
01:06:25,770 --> 01:06:27,720
但如果交易费用上涨，

1104
01:06:27,720 --> 01:06:31,950
那么，对于可能使用它的人来说，这将是一种相反的激励。

1105
01:06:31,950 --> 01:06:34,950
是的，但是如果每个人都在比特币网络上，

1106
01:06:34,950 --> 01:06:36,960
如果你想交易商品，

1107
01:06:36,960 --> 01:06:39,510
你必须与比特币网络上的某个人交易，

1108
01:06:39,780 --> 01:06:43,200
所以有各种各样的复杂分析，

1109
01:06:43,200 --> 01:06:46,740
我不想预测结果会是什么。

1110
01:06:47,990 --> 01:06:48,440
我明白了，好的。

1111
01:06:48,740 --> 01:06:51,320
我想在 2140 年，

1112
01:06:51,770 --> 01:06:54,800
这是奖励制度用尽的时候，

1113
01:06:54,800 --> 01:06:58,730
将完全基于交易费用，按照目前的速率。

1114
01:06:59,390 --> 01:07:00,500
我明白了，谢谢。

1115
01:07:04,010 --> 01:07:06,620
好的，另一件事是，

1116
01:07:06,620 --> 01:07:08,780
人们建造特殊的硬件，

1117
01:07:09,260 --> 01:07:12,140
有一些公司发布板，

1118
01:07:12,140 --> 01:07:13,910
它们很擅长快速计算哈希，

1119
01:07:14,450 --> 01:07:17,330
这些是矿工池使用的，

1120
01:07:17,870 --> 01:07:22,280
他们有到许多节点的高速链路，

1121
01:07:23,000 --> 01:07:24,380
所以如果他们找到了一个区块，

1122
01:07:24,380 --> 01:07:26,360
他们可以先把它拿出来，

1123
01:07:26,390 --> 01:07:28,920
所以他们赢了，等等。

1124
01:07:28,950 --> 01:07:32,490
如果你对这个感兴趣的话，

1125
01:07:32,490 --> 01:07:35,670
你可以在网上读到很多关于它的信息，

1126
01:07:35,670 --> 01:07:38,910
这些系统仍然是在一起的。

1127
01:07:43,240 --> 01:07:47,770
好的，让我来谈谈一大堆实际问题，

1128
01:07:47,770 --> 01:07:48,700
我有点忽略了，

1129
01:07:48,700 --> 01:07:50,020
尽管我们略有触及。

1130
01:07:57,560 --> 01:08:00,230
所以，首先是十分钟，

1131
01:08:03,320 --> 01:08:07,980
我认为 10 分钟是[]时间的上限，

1132
01:08:07,980 --> 01:08:15,130
大概十次传播到网络的时间。

1133
01:08:20,590 --> 01:08:24,970
所以比特币试图避免一种特权，

1134
01:08:25,180 --> 01:08:28,450
特权分叉，

1135
01:08:28,480 --> 01:08:31,750
两个节点几乎同时计算，

1136
01:08:31,990 --> 01:08:36,250
大致同时扩展一条链，

1137
01:08:36,400 --> 01:08:38,230
想要尽量避免这样，

1138
01:08:38,230 --> 01:08:40,870
所以，避免这种情况的一种方法是，

1139
01:08:40,870 --> 01:08:42,940
为了给节点留出足够的时间，

1140
01:08:42,940 --> 01:08:48,390
让区块到达很多节点，

1141
01:08:48,540 --> 01:08:50,340
让大多数节点都知道它，

1142
01:08:51,110 --> 01:08:54,890
这就是十分钟的由来。

1143
01:08:57,840 --> 01:09:06,300
当然，区块大小决定了每秒的交易，

1144
01:09:08,790 --> 01:09:10,800
区块大约是兆字节，

1145
01:09:10,800 --> 01:09:18,760
所以，大约每隔 10 分钟做一个区块，

1146
01:09:18,910 --> 01:09:23,260
然后交易的数量被限制为，

1147
01:09:23,560 --> 01:09:29,200
能够容纳在单个数据块中交易数量，

1148
01:09:29,700 --> 01:09:31,920
这是你可以做到的交易数量。

1149
01:09:32,750 --> 01:09:39,950
在今天，交易的数量是，

1150
01:09:39,950 --> 01:09:43,160
每秒几千次的速度计算出数字，

1151
01:09:43,160 --> 01:09:44,000
这就足够了，

1152
01:09:44,150 --> 01:09:46,550
例如，有一个类比，

1153
01:09:46,550 --> 01:09:49,430
人们使它比 Visa 网络更大，

1154
01:09:49,430 --> 01:09:51,200
Visa 可以处理更多的交易，

1155
01:09:51,500 --> 01:09:53,570
可能还不够大，

1156
01:09:53,570 --> 01:10:00,650
运行世界各地的所有货币交易。

1157
01:10:03,340 --> 01:10:06,580
另一个大的，我稍后会回到这个问题上来，

1158
01:10:06,910 --> 01:10:10,180
另一个大问题是，

1159
01:10:10,210 --> 01:10:15,790
改变协议，改变需要达成共识，

1160
01:10:21,580 --> 01:10:25,390
在某些情况下，这很容易，

1161
01:10:26,880 --> 01:10:28,170
有些改变是很容易的，

1162
01:10:31,840 --> 01:10:33,280
有一个简单的变化，

1163
01:10:33,280 --> 01:10:34,930
例如前导零的数量，

1164
01:10:35,710 --> 01:10:39,140
有一种确定性的算法

1165
01:10:39,470 --> 01:10:43,100
根据过去的日志条目进行计算，

1166
01:10:43,100 --> 01:10:47,000
对于未来的难题来说，难度是什么。

1167
01:10:47,570 --> 01:10:51,650
由于这将是日志的函数的确定性，

1168
01:10:51,650 --> 01:10:53,330
没有什么能改变，

1169
01:10:53,330 --> 01:10:54,650
一个简单的，

1170
01:10:54,650 --> 01:10:56,930
在协议中还有一堆其他参数，

1171
01:10:56,930 --> 01:10:57,920
但是另一种风格。

1172
01:11:00,000 --> 01:11:02,580
一些变化导致了软工作，

1173
01:11:10,350 --> 01:11:11,790
我们稍微谈了一下，

1174
01:11:12,000 --> 01:11:16,350
比如，主要软件，主要发布，

1175
01:11:16,350 --> 01:11:19,380
比特币的核心发布做出改变，

1176
01:11:19,380 --> 01:11:21,330
有一些不相容的，

1177
01:11:21,780 --> 01:11:24,090
然后，你会有旧客户端

1178
01:11:24,210 --> 01:11:26,040
或使用旧软件运行的客户端，

1179
01:11:26,040 --> 01:11:29,160
运行旧软件的节点和新软件的新节点，

1180
01:11:29,580 --> 01:11:32,700
这会暂时产生一些分叉，

1181
01:11:33,090 --> 01:11:36,060
当然，有一些通信正在进行，

1182
01:11:36,060 --> 01:11:38,250
从长远来看，

1183
01:11:38,250 --> 01:11:42,720
人们很可能会选择安装了新软件的新分叉。

1184
01:11:44,790 --> 01:11:47,010
有些变化导致硬分叉，

1185
01:11:57,390 --> 01:12:00,150
例如，几年前，

1186
01:12:00,150 --> 01:12:02,550
有很多关于这个块大小的讨论，

1187
01:12:03,480 --> 01:12:04,950
社区里的一些人，

1188
01:12:04,950 --> 01:12:06,360
社区想要增加区块大小，

1189
01:12:06,360 --> 01:12:08,220
其他人不想增加块大小，

1190
01:12:08,670 --> 01:12:11,190
然后他们分裂了，

1191
01:12:11,340 --> 01:12:17,490
对应于两个比特币分叉，

1192
01:12:22,560 --> 01:12:24,180
事实上，可能不止两个，

1193
01:12:24,420 --> 01:12:27,990
但那次解决的硬分叉。

1194
01:12:28,930 --> 01:12:32,290
所以，有一个有趣的方面，

1195
01:12:32,290 --> 01:12:34,030
共识进入这些系统，

1196
01:12:34,030 --> 01:12:37,390
你会遇到这样的实际问题，

1197
01:12:37,390 --> 01:12:41,260
它可以导致软分叉或硬分叉，

1198
01:12:41,260 --> 01:12:43,660
因为人们不想在特定的形式上进行合作。

1199
01:12:46,280 --> 01:12:47,570
对此有什么问题吗？

1200
01:12:50,070 --> 01:12:53,280
在硬分叉上，发生了什么？

1201
01:12:53,830 --> 01:12:56,380
你有两个不同的区块链，

1202
01:12:57,460 --> 01:12:59,680
客户端必须选择他们想要跟随哪个分叉。

1203
01:13:01,060 --> 01:13:01,720
有意思。

1204
01:13:03,310 --> 01:13:06,190
或者在这两个都发布他们的交易，我不知道。

1205
01:13:07,020 --> 01:13:11,700
我的意思是，假如我有几个比特币，

1206
01:13:12,720 --> 01:13:16,020
我会在两个分叉都有几个比特币，

1207
01:13:16,020 --> 01:13:18,330
我可以开始花费它们，

1208
01:13:19,010 --> 01:13:20,480
或者，比如。

1209
01:13:20,540 --> 01:13:24,860
好的，你有那些前缀的比特币，

1210
01:13:24,860 --> 01:13:27,350
所以两个分叉都有前缀，

1211
01:13:27,410 --> 01:13:29,390
所以你不能重复花钱。

1212
01:13:30,760 --> 01:13:31,510
什么？

1213
01:13:31,930 --> 01:13:34,180
那么，在这种情况下，

1214
01:13:34,180 --> 01:13:36,460
当比特币有一个硬分叉，

1215
01:13:36,460 --> 01:13:40,180
其中一个新的分叉被称为比特币现金，

1216
01:13:40,180 --> 01:13:46,810
所有代币都是在代币的价值内复制的，

1217
01:13:47,250 --> 01:13:49,470
你没有双倍你的价值，

1218
01:13:49,470 --> 01:13:51,570
比特币所减少的价值，

1219
01:13:51,570 --> 01:13:55,890
然后减少的差额是比特币现金的价值，

1220
01:13:56,310 --> 01:13:59,440
所以，可以把它想象成股票拆分，

1221
01:13:59,440 --> 01:14:01,150
你得到了更多的代币，

1222
01:14:01,150 --> 01:14:04,240
但实际价值保持不变，

1223
01:14:04,300 --> 01:14:06,460
因为增加了代币的供应。

1224
01:14:06,920 --> 01:14:07,430
好的，很好。

1225
01:14:08,920 --> 01:14:09,610
谢谢。

1226
01:14:12,310 --> 01:14:13,270
还有其他问题吗？

1227
01:14:19,380 --> 01:14:21,510
好的，现在让我来总结一下。

1228
01:14:28,210 --> 01:14:32,560
所以，我们在这里看到的是分步共识，

1229
01:14:36,640 --> 01:14:42,880
具有潜在拜占庭参与者的开放分布式系统，

1230
01:14:43,030 --> 01:14:47,500
让我看看，我的程序是否崩溃了，稍等一下。

1231
01:15:10,480 --> 01:15:14,890
所以，这种共识是潜在的拜占庭参与者的共识。

1232
01:15:23,020 --> 01:15:27,730
事情达到共识，

1233
01:15:27,730 --> 01:15:30,850
在这个公开账本或公开日志上，

1234
01:15:33,710 --> 01:15:37,220
从时间开始以来的所有交易，

1235
01:15:37,550 --> 01:15:45,500
并允许人们检查每个公钥的余额是多少，

1236
01:15:45,710 --> 01:15:49,100
并避免重复花费，

1237
01:15:49,520 --> 01:15:53,660
这里特别酷的想法是，

1238
01:15:53,660 --> 01:15:57,710
工作量证明的想法，

1239
01:15:57,710 --> 01:16:03,680
确定允许谁扩展区块链。

1240
01:16:05,030 --> 01:16:05,660
好的？

1241
01:16:06,420 --> 01:16:08,790
所以这就是我想说的，

1242
01:16:08,820 --> 01:16:12,810
所以如果你需要离开，

1243
01:16:12,840 --> 01:16:14,310
请随意离开，

1244
01:16:14,310 --> 01:16:15,840
这节课到此结束，

1245
01:16:16,260 --> 01:16:18,330
任何人想留下来问更多问题，

1246
01:16:18,330 --> 01:16:20,130
请留下来，

1247
01:16:20,130 --> 01:16:23,070
星期四没有课，它是黑客日，

1248
01:16:23,070 --> 01:16:25,590
如你所知，周五是最后期限，

1249
01:16:25,770 --> 01:16:30,030
对于最后的项目或你选择的实验 4 。

1250
01:16:30,030 --> 01:16:33,150
所以，祝你好运，努力完成这个工作。

1251
01:16:33,440 --> 01:16:37,700
我们将在下周二讨论下一节课。

1252
01:16:39,120 --> 01:16:39,840
好的，谢谢。

1253
01:16:43,650 --> 01:16:47,490
哦，你能不能再多谈一点关于权益证明？

1254
01:16:48,440 --> 01:16:53,510
当然，我不知道该怎么说，

1255
01:16:56,250 --> 01:16:58,650
如果你想知道更多细节，

1256
01:16:58,650 --> 01:17:00,150
只需要谷歌 proof-of-stake ，

1257
01:17:00,180 --> 01:17:03,390
你会发现一种不同的比特币货币使用它，

1258
01:17:03,390 --> 01:17:06,930
会告诉你更多细节，

1259
01:17:07,740 --> 01:17:12,240
但基本上网络中的权力，

1260
01:17:12,240 --> 01:17:14,040
与网络中的权益证明成正比，

1261
01:17:15,240 --> 01:17:16,950
基本的想法是，

1262
01:17:16,950 --> 01:17:20,730
如果你拥有所有比特币的 3% 或 10% ，

1263
01:17:20,730 --> 01:17:25,290
你能决定 10% 的新区块，

1264
01:17:25,470 --> 01:17:29,100
你会得到激励，更多的权益，

1265
01:17:29,100 --> 01:17:32,220
更高的激励来玩这个游戏。

1266
01:17:35,110 --> 01:17:38,770
所以，在这种情况下，斗争变得更具确定性，对吗？

1267
01:17:40,500 --> 01:17:44,610
所有都取决于协议的细节，

1268
01:17:45,940 --> 01:17:49,390
在算法方面，有一个周期性的领导者，

1269
01:17:49,390 --> 01:17:50,860
还有一个委员会选举，

1270
01:17:50,860 --> 01:17:54,040
然后委员会决定下一个区块是什么，

1271
01:17:54,040 --> 01:17:55,540
然后有一个新的领导者，

1272
01:17:55,540 --> 01:17:57,670
以及新的委员会选举，等等。

1273
01:17:58,820 --> 01:18:04,340
其中的许多方面，可能是固定的和随机的，

1274
01:18:04,670 --> 01:18:07,160
所以攻击者可能赢得游戏。

1275
01:18:15,170 --> 01:18:17,360
这些协议是相当复杂的。

1276
01:18:26,110 --> 01:18:29,080
另外，为了能够挖掘，

1277
01:18:29,080 --> 01:18:35,180
你必须拥有日志来验证交易，对吧？

1278
01:18:35,760 --> 01:18:36,270
是的。

1279
01:18:37,010 --> 01:18:40,430
是的，矿工复制了整个日志， GB 级别。

1280
01:18:42,080 --> 01:18:43,460
是不是太多了？

1281
01:18:43,970 --> 01:18:48,470
对于一台合理的计算机来说，这是完全可行的。

1282
01:18:49,100 --> 01:18:51,920
好的，谢谢。

1283
01:18:52,440 --> 01:18:53,070
不用谢。

1284
01:18:59,310 --> 01:19:01,050
这与课程无关，

1285
01:19:01,050 --> 01:19:02,940
但是你认为是否有可能

1286
01:19:02,940 --> 01:19:05,640
在课堂上谈论，

1287
01:19:05,640 --> 01:19:09,990
比如助教对实验 3 和 4 的设计，

1288
01:19:10,020 --> 01:19:12,960
因为有更多的开放式，所以。

1289
01:19:12,960 --> 01:19:15,420
是的，当然更多的是开放式的。

1290
01:19:16,340 --> 01:19:18,140
我没打算这么做，

1291
01:19:18,140 --> 01:19:20,720
我不知道我们还有时间这么做，

1292
01:19:21,110 --> 01:19:23,930
首先，并不是每个人都做过实验 4 ，

1293
01:19:24,230 --> 01:19:28,160
所以我目前没有这样做的打算，

1294
01:19:28,160 --> 01:19:30,560
当然，你可以到我们的办公时间，

1295
01:19:30,560 --> 01:19:33,380
和助教谈谈，

1296
01:19:33,380 --> 01:19:35,060
或者稍后再联系我，

1297
01:19:35,330 --> 01:19:37,760
我们可以讨论实验 3 和实验 4 。

1298
01:19:38,850 --> 01:19:39,990
听起来不错，谢谢。

1299
01:19:45,100 --> 01:19:49,060
所以，我有个问题，

1300
01:19:49,670 --> 01:19:56,430
就像论文中说的，或者，抱歉，

1301
01:19:57,280 --> 01:20:03,310
一旦硬币中最新的交易放在足够的区块中，

1302
01:20:03,820 --> 01:20:08,020
它之前花费的交易可以放弃来节省磁盘空间。

1303
01:20:10,560 --> 01:20:15,630
我知道区块链，

1304
01:20:16,310 --> 01:20:21,380
从来不会丢弃交易，

1305
01:20:21,380 --> 01:20:23,900
它保存着所有交易的完整日志，

1306
01:20:24,380 --> 01:20:28,430
为什么要在实践中这样做。

1307
01:20:28,860 --> 01:20:34,440
因为为了节省空间，

1308
01:20:34,470 --> 01:20:40,300
允许矿工节点上的空间压缩。

1309
01:20:41,100 --> 01:20:45,210
所以，他们不必跟踪日志中的每一笔交易，

1310
01:20:45,210 --> 01:20:46,800
每一个比特币，

1311
01:20:46,890 --> 01:20:51,720
他们必须跟踪最后一个，并且足够，

1312
01:20:52,020 --> 01:20:53,640
所以，一种考虑的方法是，

1313
01:20:53,640 --> 01:21:00,330
你可以按时间计算出所有点所有值的快照，

1314
01:21:00,330 --> 01:21:03,390
然后你就不需要记住所有过去了。

1315
01:21:03,720 --> 01:21:05,760
那么谁会保留整个过去呢？

1316
01:21:07,040 --> 01:21:09,500
是的，有两件事，

1317
01:21:09,500 --> 01:21:13,280
一个是，当你检查交易是否有效时，

1318
01:21:13,280 --> 01:21:14,630
去扫描整个日志，

1319
01:21:14,660 --> 01:21:16,670
人们不会这么做，

1320
01:21:16,850 --> 01:21:19,700
而构建一个数据结构没有太大的影响，

1321
01:21:19,700 --> 01:21:26,720
有每一个没有花掉的硬币的最后一笔交易，

1322
01:21:27,140 --> 01:21:31,700
你完全可以下载整个日志，

1323
01:21:31,730 --> 01:21:34,220
从互联网上，

1324
01:21:34,220 --> 01:21:37,460
它被维护，并由节点保存，

1325
01:21:38,120 --> 01:21:40,190
他们会丢失所有的数据，

1326
01:21:40,190 --> 01:21:42,680
他们可以计算出所有的余额，

1327
01:21:42,680 --> 01:21:45,200
从一开始就运行所有的交易。

1328
01:21:47,910 --> 01:21:54,260
但是，如果人们，谁维护整个区块，

1329
01:21:54,290 --> 01:21:56,150
整个交易。

1330
01:21:56,150 --> 01:21:58,010
复制到任何地方，

1331
01:21:58,010 --> 01:22:00,650
每个想得到日志的人。

1332
01:22:01,610 --> 01:22:02,390
是的。

1333
01:22:02,860 --> 01:22:06,730
但是，如果大多数人都截断交易，

1334
01:22:06,940 --> 01:22:10,840
为什么有人会一直保持。

1335
01:22:10,840 --> 01:22:13,600
这还不够好，真正跟踪，

1336
01:22:13,660 --> 01:22:15,100
这让你可以决定

1337
01:22:15,310 --> 01:22:18,880
交易在过去发生在哪里，

1338
01:22:18,880 --> 01:22:20,770
但它不允许你验证交易，

1339
01:22:20,770 --> 01:22:23,020
所以，你想要验证，就必须保留过去的交易。

1340
01:22:23,390 --> 01:22:27,840
好的，好的，谢谢。

1341
01:22:28,020 --> 01:22:28,590
不用谢。

1342
01:22:32,810 --> 01:22:33,950
还有什么问题吗？

1343
01:22:36,960 --> 01:22:38,340
好的，谢谢。

