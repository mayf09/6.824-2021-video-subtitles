1
00:00:09,730 --> 00:00:13,000
只要你想做好准备，就可以开始了。

2
00:00:19,430 --> 00:00:21,470
好的，那我们开始吧。

3
00:00:22,560 --> 00:00:23,130
请。

4
00:00:24,420 --> 00:00:27,240
好了，大家好，我是 Felipe ，

5
00:00:27,240 --> 00:00:28,770
我和 Caralina 一起工作，

6
00:00:28,770 --> 00:00:30,360
今天，我们将介绍

7
00:00:30,690 --> 00:00:33,750
我们的分布式私有电子投票项目。

8
00:00:34,400 --> 00:00:39,260
所以这个项目的动机其实很简单，

9
00:00:39,290 --> 00:00:41,990
给出当前的事件和选举，

10
00:00:41,990 --> 00:00:44,090
必须在[秘密的]限制下发生，

11
00:00:44,330 --> 00:00:46,100
所以，我们提出了这个问题，

12
00:00:46,100 --> 00:00:49,190
[]投票将如何运作？

13
00:00:49,760 --> 00:00:55,480
我们特别关注维护选民隐私，

14
00:00:55,970 --> 00:00:58,460
或者让投票保密。

15
00:00:59,010 --> 00:01:03,150
以下是投票系统的工作原理，

16
00:01:03,520 --> 00:01:06,100
你有一些选民，

17
00:01:06,160 --> 00:01:07,840
在这种情况下，有五个，

18
00:01:08,110 --> 00:01:10,600
然后是一个计票器，

19
00:01:10,600 --> 00:01:13,450
选民把他们的选票送到机票器，

20
00:01:14,060 --> 00:01:16,520
而计票器是，

21
00:01:16,520 --> 00:01:20,840
也许他们会加密发送，或者某种安全措施，

22
00:01:20,870 --> 00:01:23,060
机票器解密它们，

23
00:01:23,060 --> 00:01:25,370
确保每个选民最多投票一次，

24
00:01:25,670 --> 00:01:26,870
并计算出获胜者。

25
00:01:27,590 --> 00:01:32,540
所以这里要注意的关键是，

26
00:01:32,600 --> 00:01:38,360
为了使计票器确定每个选民最多投一次票，

27
00:01:38,360 --> 00:01:42,170
每一张选票都必须以某种方式与选民联系在一起，

28
00:01:42,500 --> 00:01:43,940
这很危险。

29
00:01:43,970 --> 00:01:45,740
我们将在这里解释我们的威胁模型，

30
00:01:46,040 --> 00:01:50,570
也就是我们给了攻击者两种能力，

31
00:01:50,570 --> 00:01:52,400
或者两种力量，

32
00:01:52,490 --> 00:01:55,940
第一种是制造崩溃停止失败，

33
00:01:56,000 --> 00:01:57,800
但不是拜占庭式的失败，

34
00:01:57,800 --> 00:02:00,530
这样攻击者就可以使服务器崩溃，

35
00:02:00,620 --> 00:02:04,580
但它不能让它行为不端。

36
00:02:04,930 --> 00:02:08,380
这是否有一个合理的假设是另一个问题，

37
00:02:08,830 --> 00:02:11,890
但我们认为还有其他协议可以处理这个问题，

38
00:02:11,980 --> 00:02:14,590
我们不是在处理拜占庭式的失败。

39
00:02:15,090 --> 00:02:18,240
我们给他们的第二种力量是，

40
00:02:18,240 --> 00:02:21,720
监视计票器上的人，

41
00:02:21,840 --> 00:02:23,280
所以这是有问题的，

42
00:02:23,280 --> 00:02:26,970
因为正如我们所说，选票与他们的选民是联系在一起的，

43
00:02:26,970 --> 00:02:28,530
所以，一个被动的攻击者，

44
00:02:28,530 --> 00:02:31,530
对服务器的间谍活动，

45
00:02:31,560 --> 00:02:33,600
可以在某种程度上取消这些投票的匿名性。

46
00:02:33,840 --> 00:02:36,900
这就是我们的用武之地，

47
00:02:36,900 --> 00:02:39,330
并展示我们的分布式投票设计，

48
00:02:39,510 --> 00:02:42,360
我们要处理第一个问题，

49
00:02:42,450 --> 00:02:46,500
也就是对手使服务器崩溃，

50
00:02:46,500 --> 00:02:50,370
我们将有几个投票器，

51
00:02:50,460 --> 00:02:52,380
我们的想法是，

52
00:02:52,410 --> 00:02:56,700
每个投票者都会把其他选票送到所有的投票器，

53
00:02:57,030 --> 00:03:02,520
而计票器将使用与之前相同的协议

54
00:03:02,550 --> 00:03:03,630
来计算获胜者，

55
00:03:04,170 --> 00:03:06,330
[]获胜者，抱歉，

56
00:03:06,480 --> 00:03:08,760
这很好，

57
00:03:08,760 --> 00:03:11,280
因为再加上一个崩溃，

58
00:03:11,310 --> 00:03:14,310
比如 n-1 个计票器，

59
00:03:14,310 --> 00:03:16,890
只要其中一个还在运行，

60
00:03:17,070 --> 00:03:18,810
我们就能够计算出获胜者。

61
00:03:19,320 --> 00:03:24,660
然而，这是非常不安全的，

62
00:03:24,900 --> 00:03:26,340
对于第二种类型的攻击来说，

63
00:03:26,340 --> 00:03:27,990
这是被动的[很好]，

64
00:03:28,020 --> 00:03:32,460
因为作为一个对手，

65
00:03:32,460 --> 00:03:36,000
攻击者甚至可以危害一台服务器，

66
00:03:36,090 --> 00:03:38,490
它可以取消匿名投票，

67
00:03:38,490 --> 00:03:40,710
这就是我们要介绍 Shamir 秘密共享，

68
00:03:41,370 --> 00:03:44,310
对于 Shamir 秘密共享，我们有一个投票器，

69
00:03:44,460 --> 00:03:48,450
这将是，选择一个投票 0 或 1 ，

70
00:03:48,820 --> 00:03:49,690
我们会，

71
00:03:49,690 --> 00:03:52,750
我不会解释 Shamir 是如何工作的，

72
00:03:52,750 --> 00:03:54,610
它是一种加密协议，

73
00:03:54,640 --> 00:03:58,180
但我们要展示它允许我们做什么，

74
00:03:58,420 --> 00:04:01,060
你通过 Shamir 传递投票，

75
00:04:01,090 --> 00:04:02,980
给它两个参数， n 和 k ，

76
00:04:03,070 --> 00:04:06,730
它将产生 n 个部分，

77
00:04:06,880 --> 00:04:10,420
允许你重新计算选票，

78
00:04:10,450 --> 00:04:12,250
这 n 个部分可以完全随机，

79
00:04:12,280 --> 00:04:14,710
事实上，最强大的是，

80
00:04:14,710 --> 00:04:18,550
但是 Shamir 即使是 k-1 个部分

81
00:04:18,550 --> 00:04:21,550
也不会给你提供任何关于原始投票的信息，

82
00:04:21,580 --> 00:04:24,340
但如果有 k 或更多的部分，

83
00:04:24,370 --> 00:04:27,070
你可以使用 Shamir 重新计算那个选票。

84
00:04:29,780 --> 00:04:31,700
所以，我们将展示 Shamir 投票方案。

85
00:04:32,570 --> 00:04:36,290
所以，现在，对于 Shamir 投票方案，

86
00:04:36,290 --> 00:04:39,410
首先，所有的选民要选择他们的选票，

87
00:04:39,410 --> 00:04:41,690
并共享部分计票器，

88
00:04:41,690 --> 00:04:44,330
以及对不同部分的完整投票，

89
00:04:44,720 --> 00:04:47,990
两个计票器都将接收部分，

90
00:04:47,990 --> 00:04:50,180
当它们得到所有选民的部分时，

91
00:04:50,610 --> 00:04:52,410
它们将这些部分相加，

92
00:04:52,650 --> 00:04:54,690
并将 SUM 分享给机票器，

93
00:04:54,780 --> 00:04:56,820
所以这里需要注意的是，

94
00:04:56,820 --> 00:04:59,190
这个 SUM 看起来完全是随机的，

95
00:04:59,280 --> 00:05:01,440
所以，通过与两个计数器共享它，

96
00:05:01,560 --> 00:05:03,150
其他两个计票器，

97
00:05:03,150 --> 00:05:07,440
它们无法了解任何关于 a 收到的部分的信息，

98
00:05:07,680 --> 00:05:12,450
所以，这保证了选民的隐私得到维护，

99
00:05:13,970 --> 00:05:16,010
所以他们交换了他们的选票，

100
00:05:16,100 --> 00:05:19,100
当机票器收到 SUM 时，

101
00:05:19,370 --> 00:05:22,700
来自其他选民的包括他们的一部分，

102
00:05:22,730 --> 00:05:24,740
他们最终可以计算出获胜者，

103
00:05:24,980 --> 00:05:28,340
所以再次使用 Shamir 秘密共享，黑色盒子，

104
00:05:28,460 --> 00:05:31,520
它会像重新计算 sum ，

105
00:05:31,760 --> 00:05:34,850
如果我们得到的选票超过选民总数的一半，

106
00:05:34,850 --> 00:05:35,960
那么获胜者就是 1 ，

107
00:05:35,960 --> 00:05:38,120
如果小于，则获胜者是 0 ，

108
00:05:38,420 --> 00:05:40,910
是的，我们最终有了获胜者。

109
00:05:41,680 --> 00:05:44,860
现在，我们方案的一些假设是，

110
00:05:44,860 --> 00:05:47,890
首先，选民和计票器都表现良好，

111
00:05:47,890 --> 00:05:49,030
并遵循协议，

112
00:05:49,180 --> 00:05:53,920
或他们的部分听起来是善意的，

113
00:05:53,950 --> 00:05:59,470
我们使用这个方案只处理故障停止失败。

114
00:05:59,920 --> 00:06:02,410
所以，现在来处理一些情况，

115
00:06:02,410 --> 00:06:07,620
首先，如果我们有一个不可靠的网络方案，

116
00:06:07,620 --> 00:06:12,240
我们在服务器中发送的所有 RPC 都将定期发送，

117
00:06:12,240 --> 00:06:15,450
直到我们收到它已被接收的确认，

118
00:06:17,130 --> 00:06:19,620
然后为了处理选民失败，

119
00:06:19,710 --> 00:06:22,980
所以我们需要持久化所有选民，

120
00:06:23,010 --> 00:06:26,040
比如持久化他们计算的部分和他们的投票，

121
00:06:26,130 --> 00:06:29,280
因为如果我们重新计算部分，

122
00:06:29,280 --> 00:06:31,380
然后计票器有不同的部分，

123
00:06:31,380 --> 00:06:33,180
那么方案的正确性就会消失，

124
00:06:33,180 --> 00:06:34,800
他们将不能修正 sum ，

125
00:06:34,950 --> 00:06:39,720
所以，重要的是始终共享来自同一计算的部分，

126
00:06:39,720 --> 00:06:41,660
而不修改部分，

127
00:06:42,500 --> 00:06:45,560
最后，为了处理计票器失败，

128
00:06:45,560 --> 00:06:49,580
这里我们依赖于 Shamir 秘密共享方案，

129
00:06:49,670 --> 00:06:51,140
正如我们之前提到的，

130
00:06:51,140 --> 00:06:54,260
我们只需要 k 个服务器来计算获胜者，

131
00:06:54,530 --> 00:06:59,540
所以，系统[] n-k 个计票器崩溃。

132
00:07:00,480 --> 00:07:01,950
现在是演示时间，

133
00:07:01,980 --> 00:07:05,580
所以，我停止共享屏幕，并共享另一个屏幕。

134
00:07:08,520 --> 00:07:11,190
这是我们的 demo ，

135
00:07:11,310 --> 00:07:13,920
我们这里有 5 名选民，

136
00:07:13,920 --> 00:07:16,470
我们有 3 个投票器，5个投票者，

137
00:07:16,470 --> 00:07:18,120
而且 k 等于 2 ，

138
00:07:18,710 --> 00:07:22,100
这意味着网络是不可靠的，

139
00:07:22,280 --> 00:07:23,480
现在如果我们运行它，

140
00:07:26,000 --> 00:07:27,860
在这里，我们有 3 个，

141
00:07:27,860 --> 00:07:30,470
我们得到的获胜者是 1 ，

142
00:07:30,860 --> 00:07:32,900
我们也可以让其中一台服务器崩溃，

143
00:07:33,530 --> 00:07:35,060
因为 k 等于 2 ，

144
00:07:35,060 --> 00:07:39,050
我们仍然可以通过只有两台服务器运行来计算获胜者，

145
00:07:39,230 --> 00:07:40,640
所以现在如果我们运行它，

146
00:07:40,970 --> 00:07:44,090
我们得到的选举获胜者还是 1 ，

147
00:07:44,210 --> 00:07:46,370
我们的展示到此结束，

148
00:07:46,370 --> 00:07:47,810
非常感谢你的收听，

149
00:07:47,810 --> 00:07:49,130
我们将回答一些问题。

150
00:08:03,940 --> 00:08:05,320
请随意提问。

151
00:08:12,130 --> 00:08:15,160
好奇的是，你测试这个系统的范围有多广，

152
00:08:15,430 --> 00:08:19,660
比如，你有没有尝试过不同的其他配置，

153
00:08:19,720 --> 00:08:21,430
你们有性能数字吗？

154
00:08:22,680 --> 00:08:29,190
当然，我们确实有不同大小的，

155
00:08:29,220 --> 00:08:30,660
我们创建了一整套测试套件，

156
00:08:30,690 --> 00:08:36,120
确保测试投票者故障，服务器故障有不同的大小，

157
00:08:36,360 --> 00:08:39,990
我们没有性能数据，

158
00:08:40,110 --> 00:08:41,160
我们没有测试过，

159
00:08:41,190 --> 00:08:43,620
但就失败而言，

160
00:08:43,620 --> 00:08:47,220
以及不同数量的投票者，投票器，

161
00:08:47,220 --> 00:08:49,410
是的，我们有一套完整的测试套件，

162
00:08:49,410 --> 00:08:52,440
我们应该把链接放到 github 上，

163
00:08:52,440 --> 00:08:55,810
但是我们可以把它发给你，如果你想要的话，

164
00:08:55,810 --> 00:09:00,690
你可以在测试中检查查看实现。

165
00:09:09,490 --> 00:09:13,070
好的，还有问题吗？

166
00:09:13,070 --> 00:09:16,220
你能说点比如 6.824 的想法吗，

167
00:09:16,220 --> 00:09:18,290
你在这个系统里应用的，

168
00:09:20,390 --> 00:09:22,100
而不是使用测试框架。

169
00:09:24,170 --> 00:09:26,810
当然， Caro 你想要说这个，还是我来？

170
00:09:27,340 --> 00:09:30,730
当然，所以在这里，

171
00:09:30,730 --> 00:09:33,640
我想，这个游戏来自

172
00:09:33,640 --> 00:09:35,830
密码学课上的披萨，

173
00:09:35,860 --> 00:09:39,310
所以，从不同的角度来看它是很有趣的，

174
00:09:39,310 --> 00:09:43,150
现在我们关注安全问题，

175
00:09:43,150 --> 00:09:46,720
我需要，如果个别的服务器会发生什么，

176
00:09:46,720 --> 00:09:47,620
如果它们失败了，

177
00:09:47,650 --> 00:09:53,950
无论是处理投票者故障、处理投票器故障，

178
00:09:54,040 --> 00:09:55,690
还是网络问题，

179
00:09:55,720 --> 00:09:59,020
我想我们没有解决分区问题，

180
00:09:59,020 --> 00:10:04,120
因为它的工作原理类似于投票器，

181
00:10:04,150 --> 00:10:08,740
但是，从不同的角度来看待这个问题是很有趣的。

182
00:10:11,300 --> 00:10:13,460
好的，谢谢。

183
00:10:14,300 --> 00:10:15,470
除非你有话要说，

184
00:10:15,500 --> 00:10:16,610
我们有点超时了，所以，

185
00:10:17,940 --> 00:10:21,000
好的，酷，干得好，谢谢分享。

186
00:10:21,360 --> 00:10:24,960
好的，我们有一个关于私有分析的演讲。

187
00:10:27,830 --> 00:10:30,380
如果 Kevin 准备好分享，太棒了，

188
00:10:30,900 --> 00:10:31,950
请开始，我会准备好的。

189
00:10:34,150 --> 00:10:36,940
好的，你们能听到我的声音吗，你们能看到我的鼠标吗？

190
00:10:37,420 --> 00:10:37,930
是的。

191
00:10:38,440 --> 00:10:39,940
好的，酷，

192
00:10:40,390 --> 00:10:41,470
各位好，我是 Kevin ，

193
00:10:41,470 --> 00:10:45,010
今天，我将介绍这个非常有创意的命名为 Sys 的系统，

194
00:10:45,310 --> 00:10:49,750
这是一种以保护隐私的方式收集汇总统计数据的系统，

195
00:10:50,440 --> 00:10:53,320
所以上一个演示很好地引导了我的项目，

196
00:10:53,350 --> 00:10:55,480
在 6.824 的大部分时间里，

197
00:10:55,780 --> 00:10:56,380
我们已经讨论了，

198
00:10:56,380 --> 00:11:00,880
如何在拜占庭或[]故障的情况下建立可靠的系统，

199
00:11:01,030 --> 00:11:02,080
所以服务器可能会崩溃，

200
00:11:02,080 --> 00:11:03,820
客户端通常都表现得很好，

201
00:11:04,030 --> 00:11:05,110
但从这次演讲来看，

202
00:11:05,110 --> 00:11:06,610
我希望你能学到一些新概念，

203
00:11:06,610 --> 00:11:11,200
关于我们如何在出现拜占庭式故障的情况下建立具有强大保障的系统，

204
00:11:11,440 --> 00:11:13,690
代表系统内的客户端和服务器。

205
00:11:14,450 --> 00:11:16,460
我们要使用的主要工具

206
00:11:16,460 --> 00:11:18,770
用来实现这些保证的是加密原语，

207
00:11:18,770 --> 00:11:21,770
例如多方计算和零知识证明，

208
00:11:21,860 --> 00:11:24,470
以及广播之类的分布式计算原语，比如广播。

209
00:11:27,040 --> 00:11:28,210
好的，为了简单起见，

210
00:11:28,240 --> 00:11:30,670
假设我们想建立一个计算和的系统，

211
00:11:30,820 --> 00:11:32,350
所以，我们将拥有一个聚合服务器，

212
00:11:32,350 --> 00:11:34,210
存储键值存储，

213
00:11:34,450 --> 00:11:37,720
键将成为某些统计数据的索引，

214
00:11:37,780 --> 00:11:39,910
值将是和的元组，

215
00:11:40,850 --> 00:11:42,350
我们会有一堆客户端，

216
00:11:42,440 --> 00:11:44,330
所以每个客户端都会有一些身份，

217
00:11:44,330 --> 00:11:45,980
比如它的客户端 IP 地址，

218
00:11:46,380 --> 00:11:48,930
它会有他们想要增加的统计数据的索引，

219
00:11:49,230 --> 00:11:51,570
而且它也将有它的私有输入，

220
00:11:52,040 --> 00:11:53,480
所以最直接的做法就是，

221
00:11:53,480 --> 00:11:57,230
我们可以让所有客户端按原样将其输入发送到服务器，

222
00:11:57,230 --> 00:11:58,430
它们可以计算和，

223
00:11:59,120 --> 00:11:59,990
但显然这很糟糕，

224
00:11:59,990 --> 00:12:02,180
因为现在这引领了一切，

225
00:12:02,330 --> 00:12:04,010
服务器将获知客户端的身份，

226
00:12:04,130 --> 00:12:05,570
它将获得发出的索引，

227
00:12:05,750 --> 00:12:07,580
它将获得它们的私有输入。

228
00:12:09,130 --> 00:12:10,330
所以我们可以做得更好一点，

229
00:12:10,420 --> 00:12:12,220
我们可以私下计算这些和，

230
00:12:12,340 --> 00:12:14,800
如果我们部署到非合谋服务器，

231
00:12:15,070 --> 00:12:16,810
然后，我们将让每个客户端

232
00:12:16,840 --> 00:12:19,180
秘密地将它们的输入共享到每个服务器，

233
00:12:19,620 --> 00:12:21,570
正如我们在上一次演示中所说的，

234
00:12:21,570 --> 00:12:26,730
每个服务器、每个签名本身都不会泄露有关客户端私有输入的信息，

235
00:12:27,000 --> 00:12:29,760
但服务器仍然可以将这些份额相加，

236
00:12:29,760 --> 00:12:33,000
并计算出一个键值存储的本地版本，

237
00:12:33,660 --> 00:12:36,720
然后稍后当服务器想要恢复实际和时，

238
00:12:36,810 --> 00:12:38,760
它们可以合并它们本地的键值存储

239
00:12:38,760 --> 00:12:40,860
重建全局键值存储，

240
00:12:42,120 --> 00:12:43,140
这个好了一点，

241
00:12:43,140 --> 00:12:45,660
至少如果这些服务器中有一个是诚实的，

242
00:12:45,810 --> 00:12:48,030
那么服务器仍然会获知客户的身份，

243
00:12:48,060 --> 00:12:50,310
它们仍将获取客户的索引，

244
00:12:50,370 --> 00:12:53,040
但现在不是获得每个客户端的输入，

245
00:12:53,130 --> 00:12:56,220
它们将获得所有客户端的和和输入，

246
00:12:56,880 --> 00:12:57,780
好的，这样好多了，

247
00:12:57,780 --> 00:12:59,220
但这仍然是个问题，

248
00:12:59,220 --> 00:13:03,690
也就是，这个身份索引关系仍然可以泄露大量信息。

249
00:13:04,510 --> 00:13:05,620
那么我们如何才能解决这个问题，

250
00:13:05,680 --> 00:13:07,120
我们可以让事情匿名，

251
00:13:07,330 --> 00:13:10,300
所以，我们仍将调整[]的设置，

252
00:13:10,510 --> 00:13:13,990
现在我们给每台服务器提供一个公钥用于加密，

253
00:13:14,840 --> 00:13:17,840
并且每个客户端都将对其每个份额进行加密，

254
00:13:18,380 --> 00:13:21,380
并且不是让客户端将它们的份额直接发送到服务器，

255
00:13:21,410 --> 00:13:24,050
现在，我们将在两者之间设置一层转发代理，

256
00:13:24,980 --> 00:13:25,880
所以接下来会发生的是，

257
00:13:25,880 --> 00:13:31,520
客户端将通过广播将其加密的共享发送到这些代理，

258
00:13:31,700 --> 00:13:35,570
并且代理将每个共享发送到它们各自的服务器，

259
00:13:36,160 --> 00:13:39,490
然后聚合可以像解释的那样进行，

260
00:13:40,720 --> 00:13:42,370
那么，这里的隐私保障是什么，

261
00:13:42,670 --> 00:13:44,860
如果这些[财产]中至少有一个是诚实的，

262
00:13:44,950 --> 00:13:47,380
代理仍将获知客户端的身份，

263
00:13:47,650 --> 00:13:49,210
它会获得一些计时信息，

264
00:13:49,210 --> 00:13:51,430
基于客户端何时设置共享，

265
00:13:52,100 --> 00:13:52,940
但没别的了，

266
00:13:52,940 --> 00:13:55,400
因为共享被加密到服务器，

267
00:13:55,400 --> 00:13:56,930
所以它们没有从中获得任何东西，

268
00:13:58,100 --> 00:14:00,980
如果这些服务器中至少有一个是诚实的，

269
00:14:01,010 --> 00:14:03,230
服务器也会获得一些计时信息，

270
00:14:03,260 --> 00:14:04,700
基于代理转发它的时间，

271
00:14:05,180 --> 00:14:07,400
它还会获得统计的指标，

272
00:14:07,490 --> 00:14:08,510
并获得和，

273
00:14:09,260 --> 00:14:10,610
但最重要的是，

274
00:14:11,060 --> 00:14:15,470
只要代理和服务器不是同时受到危害，

275
00:14:15,590 --> 00:14:18,830
然后，这个设计将身份与被导出的索引解除链接，

276
00:14:18,830 --> 00:14:21,000
这正是我们想要的，

277
00:14:21,000 --> 00:14:21,840
所以这很棒，

278
00:14:21,960 --> 00:14:24,210
但这也导致了另一个问题，

279
00:14:24,300 --> 00:14:27,540
也就是说，现在客户端可以躲在隐私后面，

280
00:14:27,540 --> 00:14:31,230
以及匿名保证系统发送错误的输入。

281
00:14:31,230 --> 00:14:34,590
假设系统预期客户端输入为 0 和 1 ，

282
00:14:34,710 --> 00:14:36,300
在这种隐私的后面，

283
00:14:36,330 --> 00:14:39,600
现在客户端可以通过系统发送 10 亿的签名，

284
00:14:39,750 --> 00:14:42,450
现在它可以在无法察觉的情况下扭曲这个和，

285
00:14:42,840 --> 00:14:44,190
所以，很明显，这很糟糕。

286
00:14:45,280 --> 00:14:45,970
我们来解决这件事，

287
00:14:45,970 --> 00:14:47,680
我们想让这个系统更强大，

288
00:14:47,830 --> 00:14:49,510
所以我们要做的是，

289
00:14:50,320 --> 00:14:51,640
我们将让每个客户生成，

290
00:14:51,640 --> 00:14:54,610
所谓的对它们分享的零知识证明，

291
00:14:54,610 --> 00:14:55,930
并将这些发送到服务器，

292
00:14:56,680 --> 00:14:59,500
许多服务器收集这些零知识证明，

293
00:14:59,590 --> 00:15:03,250
它们可以交互地检查客户端的输入，

294
00:15:03,250 --> 00:15:07,930
实际上，客户端共享重建为一些格式良好的输入，

295
00:15:08,640 --> 00:15:10,920
因为这个证明是零知识的，

296
00:15:11,010 --> 00:15:13,920
它没有留下任何关于输入的内容，

297
00:15:13,950 --> 00:15:15,420
除了它是格式良好的，

298
00:15:16,160 --> 00:15:18,080
所以我们的隐私属性又一次保持不变，

299
00:15:18,080 --> 00:15:20,120
代理仍会获得客户端的身份，

300
00:15:20,210 --> 00:15:21,950
仍能获得一些定时信息，

301
00:15:22,340 --> 00:15:23,600
服务器获知定时信息，

302
00:15:23,600 --> 00:15:25,130
它获得索引和获得和，

303
00:15:25,510 --> 00:15:28,330
但现在我们已经保护系统不受恶意客户端的攻击，

304
00:15:28,480 --> 00:15:30,670
因为它只接受格式良好的输入，

305
00:15:31,610 --> 00:15:32,570
所以这很棒，

306
00:15:32,720 --> 00:15:34,460
还有另一个问题，

307
00:15:34,460 --> 00:15:36,050
就是服务器可能会崩溃，

308
00:15:36,260 --> 00:15:37,190
我们可能会丢失数据，

309
00:15:37,220 --> 00:15:39,290
所以，我们显然需要两台服务器都在线，

310
00:15:39,290 --> 00:15:42,200
以便重建全局键值存储。

311
00:15:42,840 --> 00:15:44,550
所以，如果我们想让系统更可靠，

312
00:15:44,550 --> 00:15:47,700
我们可以做我们最了解的事情，即复制服务器，

313
00:15:47,850 --> 00:15:49,890
所以我们可以使用 Raft 风格的复制，

314
00:15:49,890 --> 00:15:52,500
或者，我们也可以使用主备份式复制。

315
00:15:53,340 --> 00:15:54,240
现在的问题是，

316
00:15:54,240 --> 00:15:57,090
好的，所有这些复制，所有这些加密机制，

317
00:15:57,120 --> 00:15:58,110
在这条消息路由上，

318
00:15:58,110 --> 00:16:00,090
我们还能实现很好的吞吐量吗，

319
00:16:01,180 --> 00:16:03,970
事实证明，我们可以在这里并行服务器步骤，

320
00:16:04,000 --> 00:16:05,740
提供证明验证[]，

321
00:16:05,770 --> 00:16:07,900
这很可能是系统的瓶颈，

322
00:16:08,260 --> 00:16:09,490
接下来会发生的是，

323
00:16:09,490 --> 00:16:11,380
代理要对分区进行哈希，

324
00:16:11,410 --> 00:16:13,030
它们对每台服务器的输入，

325
00:16:13,300 --> 00:16:15,580
然后这些服务器中的每一个都处于 reduce 步骤中，

326
00:16:15,610 --> 00:16:17,740
将合并它们的中间键值存储，

327
00:16:17,800 --> 00:16:20,950
以重建包含所有和的全局键值存储。

328
00:16:21,910 --> 00:16:22,420
好的？

329
00:16:23,200 --> 00:16:24,400
所以现在最后一个问题是，

330
00:16:24,400 --> 00:16:26,230
我是不是在到期日之前实现了这个，

331
00:16:27,040 --> 00:16:27,730
很遗憾，没有,

332
00:16:27,730 --> 00:16:29,950
但我确实走了很远的路，

333
00:16:29,950 --> 00:16:31,750
所以，我将展示一个简单的 domo ，

334
00:16:31,870 --> 00:16:34,090
它的非复制、非并行版本。

335
00:16:34,700 --> 00:16:37,580
所以我要快速切换到我的另一台笔记本电脑，

336
00:16:42,520 --> 00:16:44,080
我得先停止分享这个。

337
00:16:46,630 --> 00:16:53,040
是的，酷，

338
00:16:53,070 --> 00:16:54,840
好的，太棒了，

339
00:16:55,430 --> 00:16:57,800
所以，在这两个右侧的终端上将安装服务器，

340
00:16:57,800 --> 00:16:58,700
所以我要运行它们，

341
00:17:00,640 --> 00:17:02,080
它是用 Rust 实现的，

342
00:17:02,200 --> 00:17:05,020
现在我要把中间的这两个代理连接起来，

343
00:17:07,420 --> 00:17:08,410
然后在左边的终端，

344
00:17:08,410 --> 00:17:10,720
我只想模拟一千个诚实的客户端。

345
00:17:11,820 --> 00:17:14,970
现在的情况是，所有的客户端都在生成它们的输入共享，

346
00:17:14,970 --> 00:17:16,380
以及生成零知识证明，

347
00:17:16,440 --> 00:17:17,910
并通过代理发送它们，

348
00:17:18,320 --> 00:17:20,780
而代理只是将它们转发到服务器，

349
00:17:21,280 --> 00:17:22,930
最后，在服务器端，

350
00:17:22,930 --> 00:17:24,520
它们会检查所有的证明，

351
00:17:24,610 --> 00:17:26,830
如果这些输入是格式良好的，

352
00:17:26,830 --> 00:17:29,170
它将把它添加到本地键值存储中，

353
00:17:29,560 --> 00:17:30,490
然后在一段时间之后，

354
00:17:30,490 --> 00:17:33,040
当服务器想要重建最终统计数据时，

355
00:17:33,040 --> 00:17:35,620
它们只需结合它们的键值存储来恢复和。

356
00:17:36,760 --> 00:17:38,740
我的演讲到此结束，

357
00:17:38,740 --> 00:17:40,090
我很乐意回答任何问题。

358
00:17:45,830 --> 00:17:47,300
观众有什么问题吗？

359
00:17:54,380 --> 00:17:55,490
我想我有个问题，

360
00:17:55,550 --> 00:17:58,130
所以你到目前为止实现的那样，

361
00:17:58,220 --> 00:18:03,020
比如什么你会接受，

362
00:18:03,230 --> 00:18:05,510
什么容错，类似的东西，

363
00:18:05,510 --> 00:18:10,730
我可以谈谈你当前实现的可靠性。

364
00:18:11,640 --> 00:18:15,690
是的，所以现在实现的可靠性不是很高，

365
00:18:16,050 --> 00:18:18,270
主要是因为服务器没有被复制，

366
00:18:18,720 --> 00:18:19,770
所以对于代理来说，

367
00:18:19,770 --> 00:18:23,100
因为，客户广播代理，

368
00:18:23,100 --> 00:18:25,830
你所需要的就是其中一个代理启动，

369
00:18:26,540 --> 00:18:27,560
如果我们有两个代理，

370
00:18:27,650 --> 00:18:29,990
我们可以容忍一个代理失败，

371
00:18:29,990 --> 00:18:33,110
我们仍然会获得到服务器的消息，

372
00:18:33,380 --> 00:18:35,270
但如果任何一台服务器出现故障，

373
00:18:35,300 --> 00:18:38,030
那么你就不能根据这些数据进行重建了。

374
00:18:41,670 --> 00:18:43,410
这只是对于和吗，

375
00:18:43,410 --> 00:18:48,630
或者，你是否实现了对所有这些输入进行操作的任何通用函数？

376
00:18:49,620 --> 00:18:52,770
是的，目前，我只实现了和，

377
00:18:52,770 --> 00:18:55,320
但使用这种相加的秘密共享方案，

378
00:18:55,350 --> 00:18:58,260
你可以计算任何你想要的线性函数，

379
00:18:59,000 --> 00:19:00,770
也许更复杂的问题是可能的，

380
00:19:00,770 --> 00:19:02,960
但我还没有探索过这些，

381
00:19:04,100 --> 00:19:06,020
事实证明，至少在实践中，

382
00:19:06,020 --> 00:19:08,540
和可能会达到 90% 的水平。

383
00:19:10,350 --> 00:19:13,830
那么，你的性能数据是什么样子的？

384
00:19:14,790 --> 00:19:15,990
性能数字，是的，

385
00:19:16,080 --> 00:19:18,330
所以我们想要衡量的主要事情是，

386
00:19:18,420 --> 00:19:21,750
对于客户端，计算和客户端带宽，

387
00:19:22,080 --> 00:19:23,310
我有一些数字，

388
00:19:23,310 --> 00:19:24,600
至少对于客户端计算而言，

389
00:19:24,690 --> 00:19:28,650
这些共享，而这些证明只需不到几毫秒，

390
00:19:28,650 --> 00:19:30,270
所以它非常轻，

391
00:19:30,450 --> 00:19:32,340
带宽只有几千字节，

392
00:19:32,840 --> 00:19:36,020
然后对于服务器端的吞吐量，

393
00:19:36,140 --> 00:19:37,400
我是在使用 EC2 ，

394
00:19:37,400 --> 00:19:40,880
但我只给每台服务器分配了四个核心，

395
00:19:41,090 --> 00:19:42,350
因为我只有 64 个核心，

396
00:19:42,350 --> 00:19:43,820
我希望它们中的大多数都在客户端上，

397
00:19:43,820 --> 00:19:45,530
这样我就能消除这个瓶颈，

398
00:19:45,680 --> 00:19:46,790
所以，在四个核心上，

399
00:19:46,790 --> 00:19:49,930
我想，那是什么，

400
00:19:49,930 --> 00:19:52,420
可能每秒有一千个查询，

401
00:19:52,780 --> 00:19:58,300
然后估计，我猜如果每台机器并行 20 台服务器，

402
00:19:58,360 --> 00:20:02,680
它们可能每秒可以实现近 22000 次查询，

403
00:20:03,110 --> 00:20:05,390
但这些都是在同一个数据中心运行的，

404
00:20:05,390 --> 00:20:07,520
所以，它不会影响延迟，

405
00:20:07,550 --> 00:20:10,100
实际数字可能会比这个数字低一点。

406
00:20:12,040 --> 00:20:14,050
我对你的实现有一个问题，

407
00:20:14,170 --> 00:20:15,310
你如何，

408
00:20:16,010 --> 00:20:21,080
你如何实现的知识证明代码，不是理论上的。

409
00:20:21,770 --> 00:20:23,780
是的，这是个很好的问题，

410
00:20:24,170 --> 00:20:28,130
我可以把我实现的论文发送给你，

411
00:20:28,950 --> 00:20:31,350
但这并不太复杂，

412
00:20:31,350 --> 00:20:33,870
基本上，它只是一堆有限域运算，

413
00:20:33,870 --> 00:20:35,400
如果你找到你的文件库，

414
00:20:35,400 --> 00:20:37,560
只要按照论文，遵循步骤，

415
00:20:37,920 --> 00:20:40,510
从这一点上来说，这是非常简单的，

416
00:20:40,660 --> 00:20:43,300
只要你能解密那个论文。

417
00:20:44,020 --> 00:20:47,560
好的，有没有可能测试它，

418
00:20:48,100 --> 00:20:51,620
你怎么知道它起作用了还是没有起作用。

419
00:20:52,070 --> 00:20:52,850
是的，所以我想，

420
00:20:52,880 --> 00:20:55,760
是的，我只展示了诚实的客户端模拟，

421
00:20:55,760 --> 00:20:59,990
但是，你也可以生成与提交错误证据的客户的模拟，

422
00:20:59,990 --> 00:21:02,300
然后你可以看到它们被拒绝了。

423
00:21:02,960 --> 00:21:04,520
好的，是的，有道理，谢谢。

424
00:21:04,550 --> 00:21:04,940
好的。

425
00:21:10,280 --> 00:21:12,530
好的，谢谢，很[]，

426
00:21:12,920 --> 00:21:15,170
下一组准备好了吗？

427
00:21:22,300 --> 00:21:27,280
大家好，我是 Shannen 和 Nik Johan ，

428
00:21:27,280 --> 00:21:29,680
所以 Johan 请开始。

429
00:21:32,850 --> 00:21:33,750
谢谢， Shannen ，

430
00:21:33,900 --> 00:21:35,520
所以我们将谈论 BukaDocs ，

431
00:21:35,550 --> 00:21:38,010
BukaDocs 是一个分布式协同编辑器，

432
00:21:38,340 --> 00:21:39,540
它类似于 Google Docs ，

433
00:21:39,540 --> 00:21:40,560
只是稍微好一点，

434
00:21:41,130 --> 00:21:44,400
所以，进入下一张幻灯片，

435
00:21:45,090 --> 00:21:46,410
你能看到下一个吗？

436
00:21:47,140 --> 00:21:49,390
好的，就像你们在这节课上看到的，

437
00:21:49,390 --> 00:21:52,720
在分布式系统中实现一致性是非常困难的，

438
00:21:53,140 --> 00:21:56,050
一致性可能会在很多方面出错，

439
00:21:56,440 --> 00:21:58,360
所以一个非常简单的例子是，

440
00:21:58,360 --> 00:22:02,800
如果你在每个节点中收到 RPC 的顺序不同，

441
00:22:02,950 --> 00:22:04,990
你可能会得到一个不一致的状态，

442
00:22:06,100 --> 00:22:10,600
还有一种叫做 CRDT 的数据结构，

443
00:22:10,600 --> 00:22:14,860
我们在我们的系统中使用它来缓解这个问题，

444
00:22:14,890 --> 00:22:18,850
CRDT 实现最终一致性，

445
00:22:19,300 --> 00:22:22,810
通过对文档进行每一次操作，

446
00:22:22,930 --> 00:22:27,160
全局唯一的，不仅对每个节点唯一，而是全局唯一的，

447
00:22:27,250 --> 00:22:29,560
所以如果我在编辑器输入字母 a ，

448
00:22:29,860 --> 00:22:33,160
不同于 Shannen 或 Nik 在他们的编辑器输入字母 a ，

449
00:22:34,280 --> 00:22:38,550
所以，举个例子，在底部这里，

450
00:22:38,550 --> 00:22:42,300
例如，这里将一个新的海龟添加到文档中，

451
00:22:43,260 --> 00:22:48,030
即使它们接收到来自其他两个节点的移除请求，

452
00:22:48,090 --> 00:22:50,460
它们永远不会移走金海龟，

453
00:22:50,790 --> 00:22:54,330
因为这个操作本身不同于删除，

454
00:22:54,510 --> 00:22:58,740
所以移除绿海龟和移除金海龟是不同的。

455
00:22:59,980 --> 00:23:02,860
这就是我们实现最终一致性的方式，

456
00:23:03,220 --> 00:23:04,150
所以从这里开始，

457
00:23:04,150 --> 00:23:07,510
我相信 Nik 会更多地谈一谈这里的情况，

458
00:23:07,510 --> 00:23:08,890
我们如何实现第三种方式。

459
00:23:09,600 --> 00:23:13,440
是的，所以对于 BukaDocs ，

460
00:23:13,440 --> 00:23:15,960
我们选择了一种名为 LSEQ 的 CRDT ，

461
00:23:16,020 --> 00:23:20,250
表示具有可变长度密钥的元素序列，

462
00:23:20,430 --> 00:23:21,780
所以我们的目标是，

463
00:23:21,900 --> 00:23:24,720
假设我们想要一个表示字母表的序列，

464
00:23:24,720 --> 00:23:26,850
到目前为止，我们有字母 a 和 c ，

465
00:23:27,460 --> 00:23:31,480
一位编辑者可能会选择尝试在它们之间添加字母 b ，

466
00:23:31,720 --> 00:23:35,470
而另一编辑者可以选择尝试在 c 之后添加字母 d ，

467
00:23:35,890 --> 00:23:38,770
目标是最终的一致性，

468
00:23:38,770 --> 00:23:42,010
最终会到达状态 a b c d ，

469
00:23:42,040 --> 00:23:43,930
所以， LSEQ 实现这一点的方式是，

470
00:23:43,930 --> 00:23:45,880
通过使用开始和结束 token ，

471
00:23:46,350 --> 00:23:50,670
然后它给文档中的每个字符一个单独的 token ，

472
00:23:50,670 --> 00:23:52,260
在 START 和 END 之间，

473
00:23:52,560 --> 00:23:55,020
所以我们可以在 START 和 END 之间插入 h ，

474
00:23:55,350 --> 00:23:57,540
如果我们想要 i 在 h 之后，

475
00:23:57,630 --> 00:23:59,160
我们可以把它插入到 7 ，

476
00:23:59,160 --> 00:24:00,600
在 4 和 8 之间，

477
00:24:01,060 --> 00:24:05,440
现在，如果我们想在 i 和文档末尾之间插入一个感叹号，

478
00:24:05,680 --> 00:24:08,230
我们可以把它插入到键 7,2 ，

479
00:24:08,410 --> 00:24:10,660
因此我们增加键[]到 2 ，

480
00:24:10,690 --> 00:24:14,440
在相邻两个其他键之间创建键，

481
00:24:14,890 --> 00:24:18,790
通过这种方式，我们始终可以在任何两个其他键之间创建一个键，

482
00:24:19,000 --> 00:24:20,800
所以我们可以随时插入，

483
00:24:21,540 --> 00:24:24,780
现在 LSEQ 很好地形成了，

484
00:24:24,780 --> 00:24:28,860
它以很少的协调努力达到了最终的一致性，

485
00:24:29,280 --> 00:24:31,560
它还进行了一些优化，

486
00:24:31,560 --> 00:24:35,010
导致键的长度增长很慢。

487
00:24:36,000 --> 00:24:39,030
然而，一些缺点是，

488
00:24:39,060 --> 00:24:41,370
为了支持删除这些元素，

489
00:24:41,370 --> 00:24:45,120
它依赖于因果交付和恰好一次交付，

490
00:24:45,120 --> 00:24:46,710
我们并不想实现这个，

491
00:24:46,710 --> 00:24:49,050
因为它是给予其他一些工作的，

492
00:24:49,420 --> 00:24:51,340
所以我们使用一种稍微简单一些的方法，

493
00:24:51,580 --> 00:24:53,140
也就是删除集，

494
00:24:53,660 --> 00:24:56,300
这是一个仅增长的集合，我们在其中添加元素，

495
00:24:56,510 --> 00:24:59,090
所以，例如删除字母 h 和 i ，

496
00:24:59,090 --> 00:25:01,850
我们会把 4 7 添加到这个删除集中，

497
00:25:02,580 --> 00:25:07,440
然后，整个状态相当于只需要 START 和 END token ，

498
00:25:07,440 --> 00:25:09,810
感叹号在键 7,2 。

499
00:25:14,820 --> 00:25:16,740
所以我们建立了 Buka Docs 服务，

500
00:25:16,770 --> 00:25:19,290
类似于我们实现 kv Raft 的方式，

501
00:25:19,290 --> 00:25:21,600
我们有多个服务器，多个客户端，

502
00:25:21,600 --> 00:25:25,080
多个客户端，它们一次只与一台服务器通信，

503
00:25:25,080 --> 00:25:28,200
它们不断尝试操作，

504
00:25:28,200 --> 00:25:31,020
直到从服务器获得成功回复，

505
00:25:34,320 --> 00:25:39,450
客户端和服务器都维护文档中的字符的 AVL 树，

506
00:25:39,450 --> 00:25:43,260
以及我们自己删除的删除键集合，

507
00:25:43,260 --> 00:25:46,710
我们选择将字符存储在 AVL 树中，

508
00:25:46,710 --> 00:25:48,870
我猜是出于性能原因，

509
00:25:50,340 --> 00:25:52,290
事件的链条大概是这样的，

510
00:25:52,290 --> 00:25:55,530
客户端将向服务器发送插入和删除，

511
00:25:55,860 --> 00:26:00,240
服务器将更新其自己的 AVL 树和删除集，并持久化保存，

512
00:26:00,630 --> 00:26:03,300
对于所有其他服务器和客户端的更新，

513
00:26:03,300 --> 00:26:06,630
然后服务器会向客户端响应成功。

514
00:26:07,870 --> 00:26:10,660
所以我们要演示一下，

515
00:26:11,200 --> 00:26:15,640
我们在这里为它构建了一个非常简单的用户界面，

516
00:26:15,940 --> 00:26:17,350
所以让我来，

517
00:26:18,350 --> 00:26:23,900
Johan 和 Nik 现在也在从不同的客户访问这个，

518
00:26:24,230 --> 00:26:27,170
所以你可以看到他们的输入，

519
00:26:27,170 --> 00:26:28,580
你可以输入其他内容，

520
00:26:29,330 --> 00:26:30,740
我在这里输入，

521
00:26:34,210 --> 00:26:37,750
我想 Johan 是在输入 hi ，

522
00:26:38,710 --> 00:26:40,810
Nik 在输入一些东西，

523
00:26:53,360 --> 00:26:57,310
我们还可以编辑彼此的文本。

524
00:27:02,930 --> 00:27:08,010
那么，是的，这就是 Buka Docs ，

525
00:27:12,770 --> 00:27:16,700
我们很乐意回答任何问题。

526
00:27:21,550 --> 00:27:22,600
我有一个问题，

527
00:27:23,050 --> 00:27:25,150
我很喜欢海龟的主题，

528
00:27:25,150 --> 00:27:26,380
你们想出了这个，

529
00:27:26,380 --> 00:27:29,680
我只是想知道海龟的主题是从哪里来的？

530
00:27:30,930 --> 00:27:37,170
哦，是的，海龟是 Nik Johan 和我通过网络讨论课程，

531
00:27:37,170 --> 00:27:40,170
海龟是我们课程的吉祥物，

532
00:27:40,170 --> 00:27:42,510
我们受到启发，构建 Buka Docs ，

533
00:27:42,510 --> 00:27:45,870
因为我们使用的 Google Docs 是一个问题文档，

534
00:27:45,870 --> 00:27:47,100
针对学生提问，

535
00:27:47,100 --> 00:27:51,270
它无法同时处理超过 75 个用户的输入，

536
00:27:51,570 --> 00:27:53,610
Buka Docs 就是这样诞生的。

537
00:27:54,560 --> 00:27:55,670
谢谢你的提问。

538
00:27:56,360 --> 00:27:56,840
那很酷。

539
00:27:58,060 --> 00:27:59,560
我有一个简短的问题，

540
00:27:59,740 --> 00:28:02,590
所以首先，我调用了这个演示，

541
00:28:02,590 --> 00:28:04,180
抱歉，如果你提到这一点，你可能已经，

542
00:28:04,210 --> 00:28:09,280
但首先，第一个问题是，为了确保我理解正确，

543
00:28:09,280 --> 00:28:11,800
这些数据结构非常有趣，

544
00:28:11,800 --> 00:28:13,390
它们存储在客户端或服务器上，

545
00:28:14,090 --> 00:28:14,930
如果它们被存储了，

546
00:28:14,930 --> 00:28:16,850
我想现在服务器没有复制，

547
00:28:16,850 --> 00:28:18,260
但这是你可以很容易做到的事情，

548
00:28:18,290 --> 00:28:21,050
但如果它们存储在客户端上，

549
00:28:21,500 --> 00:28:23,180
如果其中一个客户端出现故障会发生什么情况？

550
00:28:24,500 --> 00:28:28,820
所以，数据结构存储在所有客户端和所有服务器上，

551
00:28:29,660 --> 00:28:33,020
现在，我们假设客户端是完全值得信任的，

552
00:28:33,230 --> 00:28:35,690
所以，如果客户端出现故障，

553
00:28:35,690 --> 00:28:38,330
它们没有发送到服务器的任何编辑，

554
00:28:38,360 --> 00:28:40,340
会一直在它们那边，

555
00:28:40,340 --> 00:28:41,690
在它们重新上线之前，

556
00:28:41,690 --> 00:28:43,580
在这种情况下，它们可以发送

557
00:28:43,580 --> 00:28:45,890
它将实现最终的一致性。

558
00:28:47,180 --> 00:28:48,380
很有趣，谢谢。

559
00:28:49,850 --> 00:28:50,930
哦，我有个问题，

560
00:28:50,990 --> 00:28:53,840
为什么 LSEQ 胜过其他 CRDT ？

561
00:28:58,460 --> 00:29:01,520
是的，我们选择 LSEQ 主要是因为，

562
00:29:01,520 --> 00:29:03,260
这是我们最先发现的，

563
00:29:03,260 --> 00:29:04,400
我们想要开始，

564
00:29:04,580 --> 00:29:08,900
因为在实现可变长度键的逻辑之后，

565
00:29:08,900 --> 00:29:10,790
没有太多我们需要做的，

566
00:29:10,790 --> 00:29:11,900
以确保，

567
00:29:11,900 --> 00:29:13,880
客户端和服务器保持一致。

568
00:29:15,610 --> 00:29:16,930
哦，好的，谢谢。

569
00:29:16,930 --> 00:29:19,060
除此之外，它就像是消息传递，

570
00:29:19,060 --> 00:29:20,860
并确保每个人都收到了所有的信息。

571
00:29:22,100 --> 00:29:23,300
好的，谢谢。

572
00:29:24,780 --> 00:29:27,120
那么，在这个示例中，你运行了多少台服务器，

573
00:29:27,120 --> 00:29:28,590
是只有一个还是多个？

574
00:29:30,080 --> 00:29:32,480
有三台服务器和三台客户端，

575
00:29:32,510 --> 00:29:35,960
每个客户端都连接到自己已知的服务器。

576
00:29:37,070 --> 00:29:43,760
所以，你使用服务器用于扩展或容错，还是两者都有？

577
00:29:44,900 --> 00:29:46,190
两者都有，

578
00:29:46,190 --> 00:29:48,530
当我们运行性能指标时，

579
00:29:49,040 --> 00:29:53,510
通过将客户端请求的负载分布在多个服务器上，

580
00:29:53,510 --> 00:29:56,120
你可以处理稍微多一点的带宽请求，

581
00:29:56,740 --> 00:29:58,780
然而，这是一种权衡，

582
00:29:58,810 --> 00:30:01,390
因为最终一致性将需要更多的时间，

583
00:30:01,390 --> 00:30:05,780
因为服务器将必须发送 RPC 到每一台其他服务器，

584
00:30:06,680 --> 00:30:09,890
所以在我们的论文上，我们有一个完整的图表，但是。

585
00:30:12,770 --> 00:30:14,900
好的，它的规模有多大，

586
00:30:14,930 --> 00:30:16,640
随着你添加更多的服务器。

587
00:30:17,220 --> 00:30:20,460
是的，我的另一个屏幕上有指标，

588
00:30:20,640 --> 00:30:24,630
所以它能够处理，

589
00:30:25,920 --> 00:30:32,100
如果我们将其分配给五个客户端和五个服务器上的 3000 个请求，

590
00:30:32,550 --> 00:30:34,980
它在三秒内实现了最终一致性，

591
00:30:34,980 --> 00:30:38,820
但这主要是因为它在计算机上，

592
00:30:38,820 --> 00:30:41,010
在本地主机上， RPC 速度非常快。

593
00:30:42,460 --> 00:30:45,730
然而，这也意味着所有的计算机都在一台机器上运行，

594
00:30:45,730 --> 00:30:49,300
所以，当我们把它放在真正的硬件上时，是两种方式。

595
00:30:54,080 --> 00:30:56,570
是的，还有一件事是，

596
00:30:57,170 --> 00:31:00,290
如果你一次提出太多请求，

597
00:31:00,680 --> 00:31:04,460
最终一致性很难实现，

598
00:31:04,520 --> 00:31:10,730
例如，我们试图一次进行 19000 次编辑，

599
00:31:10,760 --> 00:31:13,070
通过 100 个客户端和 5 台服务器，

600
00:31:13,400 --> 00:31:16,670
它花了大约 32 秒才达到最终一致性，

601
00:31:17,480 --> 00:31:21,260
然而，如果我们只在 100 个客户端和 5 个服务器上进行 3000 次编辑，

602
00:31:21,260 --> 00:31:22,670
这只花了大约三秒钟。

603
00:31:25,740 --> 00:31:28,860
当你说你做了 19000 或其他的事，

604
00:31:28,860 --> 00:31:30,660
就是一次发送所有这些信息，

605
00:31:30,660 --> 00:31:32,520
或者它是随着时间的推移而扩散的。

606
00:31:33,210 --> 00:31:34,290
每一个单独发送，

607
00:31:34,290 --> 00:31:37,160
每个编辑并行发送，至少在测试时。

608
00:31:38,990 --> 00:31:39,440
有意思。

609
00:31:42,580 --> 00:31:43,750
我有一个简短的问题，

610
00:31:43,750 --> 00:31:45,460
所以其中一个激励因素，

611
00:31:45,460 --> 00:31:48,070
像 Google Docs 这样的协作文本编辑器

612
00:31:48,580 --> 00:31:52,840
不能支持大规模更新和并发更新，

613
00:31:52,960 --> 00:31:56,590
所以你认为他们为什么不采用你们所提议的方法？

614
00:31:59,650 --> 00:32:03,610
我认为 Google Docs 使用了一种类似的方法，称为操作转换，

615
00:32:03,640 --> 00:32:07,150
我不确定，它是否也可以并行，

616
00:32:07,600 --> 00:32:08,740
他们可能不想这么做，

617
00:32:08,740 --> 00:32:10,630
因为他们不想提供那么多的服务器能力，

618
00:32:12,320 --> 00:32:15,260
这可能只是为了成本效益，

619
00:32:15,290 --> 00:32:15,890
我猜。

620
00:32:18,950 --> 00:32:21,470
是的，我只是，怎么说，

621
00:32:21,980 --> 00:32:25,100
我不认为上百个人编辑一个文档的情况，

622
00:32:25,100 --> 00:32:26,360
出现得很频繁，

623
00:32:26,960 --> 00:32:30,170
至少在 Google Docs 的使用中，

624
00:32:31,290 --> 00:32:33,930
所以，可能不想在这方面花费额外的工程时间。

625
00:32:39,200 --> 00:32:41,420
好的，谢谢，很酷的 demo 。

626
00:32:41,990 --> 00:32:44,150
所以接下来，我们有 eggscrambler ，

627
00:32:44,150 --> 00:32:44,780
如果你们准备好了。

628
00:32:51,910 --> 00:32:54,580
好的，大家好，我叫 Arvid ，

629
00:32:54,580 --> 00:32:56,860
和 Arman 和 Wendy 一起，

630
00:32:56,860 --> 00:32:58,360
我们研究的是 eggscrambler ，

631
00:32:58,360 --> 00:33:02,350
这是使用交换加密的匿名广播。

632
00:33:02,350 --> 00:33:05,020
所以让我们从一个动机问题开始，

633
00:33:05,470 --> 00:33:07,840
我们都喜欢 MIT Confessions ，

634
00:33:07,840 --> 00:33:11,560
假设班上有一个人想要提交一个 confession ，

635
00:33:11,560 --> 00:33:13,840
告诉人们他们有多喜欢这门课，

636
00:33:13,930 --> 00:33:14,890
那么他们会做些什么，

637
00:33:14,890 --> 00:33:17,890
他们把这个 confession 提交给 Google Forms ，

638
00:33:18,010 --> 00:33:21,860
然后交给 MIT Confessions 管理员，

639
00:33:21,860 --> 00:33:24,380
然后这些信息可能进入 Facebook 页面。

640
00:33:24,560 --> 00:33:26,360
但现在让我们来考虑一个场景，

641
00:33:26,360 --> 00:33:29,420
confessions 管理员是 MIT 的教授，

642
00:33:29,570 --> 00:33:32,300
特别是对于另一门经典课程来说，

643
00:33:32,300 --> 00:33:35,270
所以很明显他们不希望这个 confession 被贴出来，

644
00:33:35,670 --> 00:33:38,370
所以他们会审查它，因为他们可以，

645
00:33:38,670 --> 00:33:39,900
但更糟糕的是，

646
00:33:39,900 --> 00:33:42,810
因为他们可以，作为 MIT 的教授，

647
00:33:42,810 --> 00:33:45,900
这样他们可以去 Google 查看他们的网络流量，

648
00:33:45,900 --> 00:33:47,790
他们可以查看 MIT WiFi 网络流量，

649
00:33:47,880 --> 00:33:50,220
这样他们就能找出是谁发的这个，

650
00:33:50,610 --> 00:33:54,330
很明显，他们想在班上给那个人打个 F- ，

651
00:33:54,600 --> 00:33:55,950
这太可怕了。

652
00:33:55,950 --> 00:33:56,970
那么我们想要做什么，

653
00:33:56,970 --> 00:34:00,240
我们想要匿名广播，

654
00:34:00,240 --> 00:34:02,610
这看起来是今天的一个共同主题，

655
00:34:02,640 --> 00:34:04,680
那么什么是匿名广播，

656
00:34:04,680 --> 00:34:10,590
我们把它定义为向每个人广播消息的协议，

657
00:34:10,620 --> 00:34:12,510
在没有透露消息来自谁的情况下，

658
00:34:12,790 --> 00:34:14,590
所以，我们进一步的工作，

659
00:34:14,590 --> 00:34:18,250
我会让 Wendy 说说我们是怎么做的。

660
00:34:20,540 --> 00:34:23,720
所以，我们设计的两个主要特点是，

661
00:34:23,720 --> 00:34:26,600
它是去中心化的，并使用密码学，

662
00:34:26,630 --> 00:34:29,960
尤其是，交换加密是必要，

663
00:34:29,960 --> 00:34:32,000
因为否则描述顺序

664
00:34:32,000 --> 00:34:34,850
将揭示消息发送者的原始身份。

665
00:34:36,880 --> 00:34:40,150
是的，所以这就是我们要实现的协议，

666
00:34:40,210 --> 00:34:42,430
确保参与者加入网络，

667
00:34:42,580 --> 00:34:44,560
加密和提交他们的消息，

668
00:34:44,560 --> 00:34:48,880
它在加密阶段中由所有参与者恰好加密一次，

669
00:34:49,060 --> 00:34:51,100
加扰阶段提供匿名性，

670
00:34:51,100 --> 00:34:52,870
因为正如突出显示的那样，

671
00:34:53,110 --> 00:34:56,940
因为每个参与者都对消息进行加密，

672
00:34:56,940 --> 00:34:58,620
随机化是有秩序的，

673
00:34:59,070 --> 00:35:02,310
最后，解密会得到所需的消息列表，

674
00:35:02,310 --> 00:35:04,950
这些消息来自与身份无关的所有参与者。

675
00:35:08,340 --> 00:35:11,100
所以，如果所有参与者都是诚实的，

676
00:35:11,100 --> 00:35:14,070
这个协议成功地导致了匿名性，

677
00:35:14,940 --> 00:35:18,570
虽然恶意用户可能确定消息的发送者，

678
00:35:18,570 --> 00:35:21,690
我们相信这样的行为是可以检测到的，

679
00:35:21,810 --> 00:35:23,430
如果人们感兴趣，

680
00:35:23,430 --> 00:35:25,320
对于这个问题还有其他解决方案，

681
00:35:25,320 --> 00:35:27,270
例如混合网络和DC网络，

682
00:35:27,390 --> 00:35:31,050
接下来， Arman 将描述实现的结构。

683
00:35:34,800 --> 00:35:38,040
所以，首先，看看这个假设，

684
00:35:38,840 --> 00:35:41,000
我们看到的是高级别接口，

685
00:35:41,030 --> 00:35:43,610
有人试图提交消息，与我们服务器的交互，

686
00:35:43,640 --> 00:35:46,340
假设你是那个想要提交 confession 的人，

687
00:35:46,370 --> 00:35:47,750
你是这个应用程序客户端，

688
00:35:48,170 --> 00:35:51,680
所以你要做的第一件事就是发送一条 Start 消息，

689
00:35:51,710 --> 00:35:55,070
这表明你想要开始新的广播，

690
00:35:55,820 --> 00:35:58,610
Service 将询问所有人，

691
00:35:58,610 --> 00:36:01,160
谁是这轮的参与者，通过一个信息，

692
00:36:02,050 --> 00:36:03,730
然后它将运行这个协议，

693
00:36:04,090 --> 00:36:07,450
然后它会将结果发送给所有参与的人，

694
00:36:07,480 --> 00:36:10,270
或者如果是 confession 发布它，

695
00:36:11,140 --> 00:36:13,570
在这一点上，它将是匿名的，

696
00:36:14,440 --> 00:36:16,120
但这是一个非常简单的观点，

697
00:36:16,120 --> 00:36:17,170
事实上，

698
00:36:17,470 --> 00:36:21,970
我们是在实验的 Raft 实现的基础上构建这个。

699
00:36:22,390 --> 00:36:24,610
所以我们使用实验 Raft 的原因是两个，

700
00:36:24,700 --> 00:36:28,210
第一，我们将协议实现为状态机，

701
00:36:28,980 --> 00:36:34,260
所以， Raft 是运行这个协议的众多实例之一，

702
00:36:34,350 --> 00:36:36,540
Raft 用来复制这种状态，

703
00:36:37,020 --> 00:36:38,940
然后第二，当我们做打乱阶段时，

704
00:36:38,940 --> 00:36:42,630
我们需要确保每个参与者都以特定的顺序进行打乱，

705
00:36:42,630 --> 00:36:45,660
所以我们使用 Raft 作为一种协调机制，

706
00:36:45,660 --> 00:36:46,830
做这个 test-and-set ，

707
00:36:47,220 --> 00:36:49,350
在那里，它们以单一的顺序进行，

708
00:36:49,980 --> 00:36:52,440
所以类似于 kv 存储，

709
00:36:52,440 --> 00:36:54,030
我们有状态机服务器，

710
00:36:54,030 --> 00:36:56,940
它读取 Raft 的更新，并更新状态机，

711
00:36:57,450 --> 00:36:59,490
使用他们们商定的任何状态，

712
00:36:59,970 --> 00:37:02,310
我们还添加了状态机客户端，

713
00:37:02,310 --> 00:37:04,410
它读取状态机是如何改变的，

714
00:37:04,770 --> 00:37:07,410
然后这个客户真正采取行动

715
00:37:07,410 --> 00:37:10,290
以某种方式推进协议，

716
00:37:11,640 --> 00:37:14,430
然后，就像在 kv 存储中，

717
00:37:14,980 --> 00:37:17,680
为了推进协议，

718
00:37:17,680 --> 00:37:21,100
这个客户端将联系 Leader 服务器，

719
00:37:21,370 --> 00:37:24,280
使用对状态机更新的请求，

720
00:37:24,900 --> 00:37:28,410
然后我们还实现了 raft 配置变更 RPC ，

721
00:37:28,870 --> 00:37:32,710
服务器可以在配置中添加或删除自身，

722
00:37:32,770 --> 00:37:33,700
这意味着，

723
00:37:34,090 --> 00:37:37,180
新人可以加入随后的几轮广播，

724
00:37:37,570 --> 00:37:38,920
然后，如果出现故障，

725
00:37:38,920 --> 00:37:40,870
我们可以把某人从配置中删除，

726
00:37:40,900 --> 00:37:43,450
这样下一轮广播才能继续进行，

727
00:37:43,780 --> 00:37:48,200
因为我们的协议要求每个人都是活跃的，

728
00:37:48,200 --> 00:37:49,580
为了完成这轮（广播）。

729
00:37:51,380 --> 00:37:52,940
然后我们终于有了应用程序，

730
00:37:52,940 --> 00:37:56,840
客户端就像是在你手机上运行的 confession ，

731
00:37:57,200 --> 00:37:59,750
会将这些广播消息发送给客户端，

732
00:38:00,080 --> 00:38:02,960
然后它会收到更新，

733
00:38:02,960 --> 00:38:04,850
一旦协议完成。

734
00:38:05,950 --> 00:38:09,190
所以，我们将播放一段录制的快速演示，

735
00:38:09,220 --> 00:38:11,950
如果你听不到的话，就告诉我。

736
00:38:16,730 --> 00:38:17,810
现在我们来看演示，

737
00:38:17,810 --> 00:38:20,750
我们现在开始在 Wendy 的计算机上工作，

738
00:38:21,080 --> 00:38:23,870
她将启动应用程序，

739
00:38:23,870 --> 00:38:26,990
所以她在计算机上启动一个实例，并尝试，

740
00:38:27,080 --> 00:38:32,860
她正在将她的配置链接发送到 Zoom 聊天中，

741
00:38:32,890 --> 00:38:33,850
正如我们在这里看到的，

742
00:38:35,210 --> 00:38:37,670
所以现在我们要进入 Arvid 的计算机，

743
00:38:37,670 --> 00:38:38,870
他会利用这个链接，

744
00:38:38,870 --> 00:38:41,720
并像 Wendy 一样，加入同样的配置，

745
00:38:43,110 --> 00:38:44,130
所以他这么做了，

746
00:38:44,520 --> 00:38:47,310
现在他要开始这一轮，

747
00:38:48,540 --> 00:38:50,700
好的，可以发送他们的信息，

748
00:38:53,220 --> 00:38:54,990
我们的这一轮已经成功了。

749
00:38:55,470 --> 00:38:58,740
现在我们要展示可以无缝添加新客户端，

750
00:38:58,740 --> 00:39:00,780
所以这两个都会发出一条信息，

751
00:39:00,810 --> 00:39:02,970
一个全新的 Raft 实例，

752
00:39:03,390 --> 00:39:04,170
所以我们在这里看到，

753
00:39:04,170 --> 00:39:08,510
这个新实例很快就赶上了左边的那个，

754
00:39:08,660 --> 00:39:12,290
现在他们三人都将为下一轮传递一个信息，

755
00:39:15,980 --> 00:39:18,230
我们收到了所有三条信息，

756
00:39:18,260 --> 00:39:21,500
所以我们演示了我们可以通过网络进行广播

757
00:39:21,950 --> 00:39:25,400
还可以随意添加客户。

758
00:39:30,260 --> 00:39:33,670
是的，这是 eggscrambler 的演示，

759
00:39:33,760 --> 00:39:36,010
有没有人有什么问题？

760
00:39:39,610 --> 00:39:41,140
这是一张非常快的一个，

761
00:39:41,170 --> 00:39:44,620
首先，这是一个非常酷的系统，

762
00:39:44,920 --> 00:39:52,780
那么，应用程序与客户端 Raft 状态机是分开的，对吗？

763
00:39:53,660 --> 00:39:54,140
是的。

764
00:39:54,260 --> 00:39:56,150
这就像是两个不同的设备，

765
00:39:56,740 --> 00:39:58,600
所以我想我的问题是，

766
00:39:58,750 --> 00:40:01,570
你如何部署这个东西的整体图景，

767
00:40:01,570 --> 00:40:02,410
为什么会这样呢，

768
00:40:02,710 --> 00:40:04,600
我的意思是，我想象你可以

769
00:40:04,870 --> 00:40:07,480
运行一个 Raft 状态机，使用一堆手机，

770
00:40:07,940 --> 00:40:10,670
它可能可用性较差，

771
00:40:10,670 --> 00:40:13,220
但你已经实现了配置更改，

772
00:40:13,220 --> 00:40:14,420
所以原则上可以这样做，

773
00:40:15,290 --> 00:40:17,390
真的，我只是想弄清楚客户端的角色是什么，

774
00:40:17,390 --> 00:40:17,840
在这整个过程中，

775
00:40:17,840 --> 00:40:19,580
服务器是一个服务器集群，

776
00:40:19,580 --> 00:40:21,320
应用程序也有意义，但是。

777
00:40:22,270 --> 00:40:23,650
所以客户端，

778
00:40:23,680 --> 00:40:28,660
这是编写实现的一种不错的方式，

779
00:40:28,930 --> 00:40:30,460
所以服务器和客户端，

780
00:40:30,460 --> 00:40:32,110
你可以把它想象成一台服务器，

781
00:40:32,260 --> 00:40:35,080
在我们的实现中，

782
00:40:35,080 --> 00:40:38,500
创造这个抽象概念是有意义的，是的。

783
00:40:38,940 --> 00:40:40,110
好的，谢谢。

784
00:40:43,760 --> 00:40:45,500
为了让这轮取得进展，

785
00:40:45,500 --> 00:40:48,650
所有节点必须从所有其他节点接收消息，

786
00:40:48,650 --> 00:40:50,090
也就是 n-1 个节点，

787
00:40:50,300 --> 00:40:52,940
所以如果你有一些非常奇怪的分区，

788
00:40:52,940 --> 00:40:56,660
某些子集不能与其余部分子集交互，

789
00:40:56,720 --> 00:40:58,970
这个问题将如何在这里解决？

790
00:41:01,640 --> 00:41:04,850
是的，所以如果分区在，

791
00:41:04,850 --> 00:41:09,440
小于，比如，如果每个都是少数，

792
00:41:09,470 --> 00:41:11,900
然后它就会永远卡住，

793
00:41:12,080 --> 00:41:14,090
直到你找到多数，

794
00:41:14,090 --> 00:41:15,650
一旦你获得了多数，

795
00:41:15,650 --> 00:41:18,770
它们会自动提交，

796
00:41:18,770 --> 00:41:21,410
比如删除服务器 RPC ，

797
00:41:21,500 --> 00:41:24,110
当它们得不到某人的回应时，

798
00:41:24,110 --> 00:41:26,120
然后，集群会缩小，

799
00:41:26,150 --> 00:41:29,870
直到没有响应的节点消失。

800
00:41:34,130 --> 00:41:36,950
我注意到在你给出的演示示例中，

801
00:41:37,010 --> 00:41:40,430
你有一个写了两条信息，

802
00:41:40,490 --> 00:41:44,810
另一个写了第三条信息，

803
00:41:44,840 --> 00:41:45,830
这意味着你可以，

804
00:41:45,890 --> 00:41:47,210
写两条信息的人，

805
00:41:47,210 --> 00:41:50,300
总是能确定第三个人分享了什么，

806
00:41:50,360 --> 00:41:53,000
这是不是有点违背了你的协议的目的？

807
00:41:55,040 --> 00:41:58,640
是的，所以为什么它是两条信息，

808
00:41:58,640 --> 00:42:00,470
因为我们运行，

809
00:42:01,280 --> 00:42:04,190
我们在同一台计算机上运行这两个实例，

810
00:42:04,750 --> 00:42:07,930
这是一个攻击，在那里，

811
00:42:08,050 --> 00:42:09,130
你拥有它，

812
00:42:09,160 --> 00:42:14,320
你从一个人被所有人控制的地方开始，

813
00:42:14,350 --> 00:42:16,240
比如五台服务器，

814
00:42:16,240 --> 00:42:18,460
其中五个提交信息的人被每个人控制，

815
00:42:18,460 --> 00:42:20,260
你知道最后一个人是谁，

816
00:42:20,950 --> 00:42:25,970
但是，我认为我们目前认为

817
00:42:25,970 --> 00:42:29,180
这是非拜占庭式的失败，

818
00:42:29,180 --> 00:42:30,920
所以客户端的行为是诚实的，

819
00:42:30,920 --> 00:42:34,850
它们并没有试图在系统中获得不公平的优势，

820
00:42:35,120 --> 00:42:38,720
以及攻击者或监听所有网络流量的人。

821
00:42:39,950 --> 00:42:43,910
好的，所以你并不担心系统中涉及的人破坏它，

822
00:42:44,030 --> 00:42:45,680
你只会担心那些人

823
00:42:45,680 --> 00:42:49,070
窥视系统并驾驶它的人。

824
00:42:50,610 --> 00:42:51,210
是的。

825
00:42:51,210 --> 00:42:51,990
或者就像是，

826
00:42:51,990 --> 00:42:55,140
所以我认为我们很有信心，

827
00:42:55,140 --> 00:42:58,620
如果他们是拜占庭式的参与者，

828
00:42:58,620 --> 00:43:02,340
然后，协议将失败，它会失败，

829
00:43:02,430 --> 00:43:04,860
明确地，比如，我们，

830
00:43:04,860 --> 00:43:07,320
但有一些不同的，

831
00:43:07,320 --> 00:43:09,660
不确定是不是这样，

832
00:43:09,870 --> 00:43:10,770
但我们认为是这样，

833
00:43:10,800 --> 00:43:12,090
但这就像是。

834
00:43:12,090 --> 00:43:14,550
所以对于当时讨论的袭击，

835
00:43:14,580 --> 00:43:17,190
其中有人控制了集群，

836
00:43:17,220 --> 00:43:20,160
但它接管了所有，

837
00:43:20,160 --> 00:43:24,300
基本上是所有的客户端，除了它们中的一个，

838
00:43:24,390 --> 00:43:26,040
如果你是领导者，你可以控制，

839
00:43:26,040 --> 00:43:28,830
大概控制谁从组中添加或删除，

840
00:43:28,830 --> 00:43:30,360
你可以做到这一点，

841
00:43:31,660 --> 00:43:34,870
你们目前的系统能检测到吗？

842
00:43:35,490 --> 00:43:38,370
不，不，当它是 n-1 的时候不会，

843
00:43:38,460 --> 00:43:40,560
所以我们至少需要两个，

844
00:43:40,590 --> 00:43:43,260
如果我们有两个诚实的人，

845
00:43:43,500 --> 00:43:44,940
那就足够了，

846
00:43:44,970 --> 00:43:46,290
因为它们会，

847
00:43:46,350 --> 00:43:48,570
如果它们彼此断开，

848
00:43:48,570 --> 00:43:49,830
他们可能知道这个。

849
00:43:50,300 --> 00:43:51,080
是的。

850
00:43:53,810 --> 00:43:54,740
好的，很好，谢谢。

851
00:43:57,960 --> 00:43:59,850
超出时间，谢谢，很酷，

852
00:43:59,880 --> 00:44:02,280
也许 MIT confession 会出现。

853
00:44:02,940 --> 00:44:08,290
让我们来听听容错项目，

854
00:44:09,550 --> 00:44:11,350
也许这是一种糟糕的总结方式。

855
00:44:12,370 --> 00:44:12,880
别担心。

856
00:44:13,840 --> 00:44:15,310
好的，大家好，我是 Ariel ，

857
00:44:15,340 --> 00:44:18,220
我做这个项目[]已经有一段时间了，

858
00:44:18,220 --> 00:44:20,140
让我们看看我能不能分享屏幕。

859
00:44:22,050 --> 00:44:25,590
所以，是的，正如你在这里看到的，

860
00:44:25,590 --> 00:44:29,670
项目涉及在 9P 接口上免费提供容错，

861
00:44:29,670 --> 00:44:33,990
并详细分析这意味着什么和额外的幻灯片。

862
00:44:33,990 --> 00:44:36,270
我们先来看看无服务计算，

863
00:44:36,270 --> 00:44:40,020
如果你听说过 AWS Lambda

864
00:44:40,110 --> 00:44:44,730
或 Google Cloud Functions ，

865
00:44:44,880 --> 00:44:47,700
从本质上讲，它所做的是，

866
00:44:47,700 --> 00:44:51,720
不是必须设置一堆虚拟机，并扩展，

867
00:44:51,720 --> 00:44:53,460
根据客户的请求，加载所有内容，

868
00:44:53,460 --> 00:44:56,100
你可以只编写一个小的无状态函数，

869
00:44:56,430 --> 00:44:59,640
通过一堆小的无状态函数来开发你的应用程序，

870
00:44:59,640 --> 00:45:01,680
通过 HTTP 请求触发，

871
00:45:01,920 --> 00:45:07,140
然后， AWS 或 Google 云或你的服务提供商

872
00:45:07,140 --> 00:45:10,410
将负责扩展，并为你提供所有基础设施管理，

873
00:45:10,880 --> 00:45:11,750
这很好，

874
00:45:11,750 --> 00:45:15,680
因为理论上运营商可以更有效地平衡资源，

875
00:45:15,680 --> 00:45:17,960
它们可以获得很高的利用率，

876
00:45:18,380 --> 00:45:20,960
从理论上，这对开发人员来说也更容易，

877
00:45:20,960 --> 00:45:21,860
你所要做的就是，

878
00:45:22,490 --> 00:45:25,880
你不必担心所有这些基础设施管理，

879
00:45:25,880 --> 00:45:30,050
并且有足够的[净空]数量虚拟机或任何东西，

880
00:45:30,050 --> 00:45:32,930
处理客户负载激增等问题的一切措施。

881
00:45:34,440 --> 00:45:38,100
然而，现实并不像理论那么美好，

882
00:45:38,280 --> 00:45:42,000
也就是说，到最后，

883
00:45:42,350 --> 00:45:44,150
在当前的实现中，

884
00:45:44,210 --> 00:45:48,650
构建这些复杂的应用程序是相当困难的，

885
00:45:49,450 --> 00:45:53,050
将它们分解成这些无状态函数相当困难，

886
00:45:53,050 --> 00:45:55,090
因为这些 Lambdas ，

887
00:45:55,090 --> 00:45:59,500
这些无状态函数缺乏丰富的通信原语，

888
00:46:00,220 --> 00:46:03,880
这是构建复杂应用程序的重要支持，

889
00:46:03,910 --> 00:46:07,120
所以它们不能直接通信，

890
00:46:07,720 --> 00:46:10,750
因此，试图利用无服务器函数的系统，

891
00:46:10,780 --> 00:46:15,520
不得不构建自己的定制通信解决方案，

892
00:46:15,550 --> 00:46:18,310
比如把两端放在边上，

893
00:46:18,310 --> 00:46:19,780
他们围着那个通信，

894
00:46:19,780 --> 00:46:22,840
或者通过存储系统进行通信，比如 S3 ，

895
00:46:22,840 --> 00:46:24,010
这使得它们变得低效，

896
00:46:24,010 --> 00:46:27,700
开发人员很难以合理的方式将它们组合在一起，

897
00:46:29,290 --> 00:46:33,580
所有这些复杂性导致数据中心管理资源相当糟糕，

898
00:46:33,610 --> 00:46:39,160
问题是，

899
00:46:39,430 --> 00:46:42,640
我们仍然将所有这些数据中心资源

900
00:46:42,640 --> 00:46:45,340
划分为一组本地名称空间，

901
00:46:45,340 --> 00:46:46,420
它们是[]，

902
00:46:46,420 --> 00:46:49,480
你不能在它们之间共享资源。

903
00:46:50,790 --> 00:46:53,190
所以，我们正在研究的是

904
00:46:53,190 --> 00:46:59,160
[]过去几十年的一些工作，称为 Plan9 ，

905
00:46:59,250 --> 00:47:04,260
Plan9 提供了统一数据中心资源的方案，

906
00:47:04,320 --> 00:47:06,390
并提供单个系统映像，

907
00:47:06,920 --> 00:47:09,140
这意味着，当你编写你的应用程序时，

908
00:47:09,170 --> 00:47:11,780
你不必担心什么东西在什么机器上运行，

909
00:47:11,780 --> 00:47:14,900
关于调配虚拟机或类似的内容，

910
00:47:15,170 --> 00:47:20,600
或确保某些 VM 上的应用程序的某些部分，

911
00:47:20,600 --> 00:47:25,680
对于你的应用程序，它看起来就像一个巨大的命名空间，

912
00:47:25,800 --> 00:47:29,910
所以，你的应用程序完全不知道它运行在什么硬件上，

913
00:47:29,910 --> 00:47:33,210
或者在数据中心的其他服务，

914
00:47:33,450 --> 00:47:35,820
实现的方式是

915
00:47:35,850 --> 00:47:40,380
应用服务通过全局分层命名空间进行通信，

916
00:47:40,970 --> 00:47:46,820
服务和资源暴露统一的文件系统类接口，

917
00:47:47,090 --> 00:47:52,190
你不必担心实现和调用定制 RPC 。

918
00:47:52,190 --> 00:47:55,590
例如，在这棵树上，

919
00:47:55,590 --> 00:47:56,670
你可以在这里看到，

920
00:47:56,700 --> 00:48:01,560
我们有顶级的根级名称空间，

921
00:48:01,560 --> 00:48:04,620
然后我们有三个注册的服务，

922
00:48:04,620 --> 00:48:06,180
我们有 S3 服务，

923
00:48:06,180 --> 00:48:11,010
你可以用来把你的 Lambdas 连接到 S3 ，

924
00:48:11,010 --> 00:48:15,440
你可以通过它访问 S3 键和值，

925
00:48:15,440 --> 00:48:18,800
我们还有内存中的文件系统（memfs）和 sched ，

926
00:48:19,010 --> 00:48:20,980
所以，很快地。

927
00:48:21,790 --> 00:48:28,290
是的，这就是典型的 9P 名称空间是什么样子。

928
00:48:29,550 --> 00:48:32,970
我们已经做了一些工作来实现

929
00:48:32,970 --> 00:48:37,410
比如，这个 9P 架构，

930
00:48:37,590 --> 00:48:40,620
我们有一个类似 Zookeeper 的配置服务，

931
00:48:40,620 --> 00:48:42,510
它有顶级名称空间，

932
00:48:42,630 --> 00:48:47,520
我们有一个调度器和一堆 9P 服务器，

933
00:48:47,880 --> 00:48:48,900
它们所做的是，

934
00:48:48,900 --> 00:48:51,990
它们暴露资源和函数，比如，

935
00:48:52,050 --> 00:48:53,280
如果我们回到这里，

936
00:48:53,370 --> 00:48:55,140
这个命名空间的 S3 部分，

937
00:48:55,140 --> 00:49:00,120
你可以编写连接 S3 存储的服务，

938
00:49:00,120 --> 00:49:02,010
并将其暴露给 9P ，

939
00:49:02,010 --> 00:49:03,780
这将是一个 9P 服务器。

940
00:49:05,250 --> 00:49:08,890
那些 RPC 或操作

941
00:49:08,890 --> 00:49:12,670
用来于与这些不同服务交互，

942
00:49:12,670 --> 00:49:15,310
都是 9P 操作，

943
00:49:15,310 --> 00:49:19,060
所以这是一个非常小的，定义很好的一组操作，

944
00:49:19,060 --> 00:49:21,160
你可以在这里看到它们中的一些，

945
00:49:21,160 --> 00:49:24,490
例如 Read Write Remove Stat ，

946
00:49:24,490 --> 00:49:27,820
较少规范文件系统操作。

947
00:49:29,470 --> 00:49:31,510
我快速展示一下它是什么样子，

948
00:49:31,630 --> 00:49:34,930
例如，在这里，

949
00:49:34,930 --> 00:49:36,850
我可以启动基础设施。

950
00:49:40,690 --> 00:49:42,130
这样我可以查看，

951
00:49:42,160 --> 00:49:45,010
你可以将这个名称空间映射到 Linux 中，

952
00:49:45,670 --> 00:49:49,060
这样我就能看到一些服务，

953
00:49:49,060 --> 00:49:53,140
以及我们在这里挂载的不同的名称空间，

954
00:49:53,140 --> 00:49:55,150
例如，如果我看一下 S3 ，

955
00:49:58,610 --> 00:50:03,410
这连接到我们拥有的 S3 存储桶，

956
00:50:03,980 --> 00:50:09,440
你看到 S3 桶里的键了吗，

957
00:50:09,440 --> 00:50:11,210
就像文件系统中的文件一样，

958
00:50:11,510 --> 00:50:14,600
这是 S3 桶在这里，

959
00:50:14,960 --> 00:50:18,410
所以如果我想创建，写入一个新的键，

960
00:50:18,590 --> 00:50:24,620
我所要做的就是 cat ， echo 到，

961
00:50:30,090 --> 00:50:35,250
所以，不必使用 AWS 定制库，

962
00:50:35,250 --> 00:50:37,680
为了写入 S3 ，

963
00:50:37,680 --> 00:50:40,350
我可以只写入一个文件系统，

964
00:50:40,350 --> 00:50:43,050
执行一个文件系统操作来创建文件并写入它，

965
00:50:43,350 --> 00:50:48,140
然后在 S3 ，现在应该显示一个新的键，

966
00:50:49,600 --> 00:50:52,030
所以我们有了 test456 ，我们刚刚写的。

967
00:50:56,630 --> 00:50:59,810
那么，这里容错部分是什么意思，

968
00:50:59,870 --> 00:51:01,490
就像我之前提到的，

969
00:51:01,490 --> 00:51:05,510
所有这些 9P 服务都具有定义良好的统一接口，

970
00:51:05,540 --> 00:51:07,370
没有定制的 RPC ，

971
00:51:07,370 --> 00:51:10,400
这给了我们一个非常独特的机会，

972
00:51:10,400 --> 00:51:16,460
我们可以在这个 9P 接口上切片，用来复制未修改的服务，

973
00:51:16,490 --> 00:51:23,540
所以，如果我能够将所有这些操作复制到不同服务器实例，

974
00:51:23,540 --> 00:51:29,210
然后服务器可以自由复制，根本不需要修改它，

975
00:51:29,270 --> 00:51:30,080
这就是我们所做的，

976
00:51:30,080 --> 00:51:31,040
当我工作的时候，

977
00:51:31,040 --> 00:51:39,460
我实现了基于链式复制的容错方案，

978
00:51:39,880 --> 00:51:44,920
我使用 named ，是一种配置服务，

979
00:51:44,920 --> 00:51:47,110
你可以认为它类似 Zookeeper ，

980
00:51:47,140 --> 00:51:51,430
我复制了 2 个不同的服务，没有任何修改，

981
00:51:51,430 --> 00:51:52,690
内存中文件系统（memfsd）

982
00:51:52,690 --> 00:51:59,410
和从本地机器暴露持久存储的服务（npuxd），

983
00:51:59,530 --> 00:52:02,560
所以我会很快地向展示它们。

984
00:52:03,460 --> 00:52:05,350
所以让我停止这个，

985
00:52:05,380 --> 00:52:05,890
让我们看看。

986
00:52:08,180 --> 00:52:12,980
所以，比如，我可以，

987
00:52:20,000 --> 00:52:21,770
所以我可以开始一系列的复制，

988
00:52:32,840 --> 00:52:36,710
所以，如果我看一下 Linux 中的 9P 名称空间模块，

989
00:52:36,980 --> 00:52:38,780
你可以看到这个 memfs-replica ，

990
00:52:39,200 --> 00:52:41,600
这是这些复制注册它们自己的地方，

991
00:52:44,590 --> 00:52:45,520
所以我们可以看到，

992
00:52:45,520 --> 00:52:47,590
我们有五个这样的复制，

993
00:52:47,620 --> 00:52:49,600
我可以写入它们中的一个。

994
00:52:53,640 --> 00:52:54,210
糟糕。

995
00:52:58,110 --> 00:53:00,240
好的，我可以写入复制中的一个，

996
00:53:00,450 --> 00:53:02,190
然后我可以从另一组中读取，

997
00:53:02,190 --> 00:53:06,880
因为我们应该得到相同的结果，

998
00:53:06,880 --> 00:53:11,520
写入小的字符串到第一个副本的文件，

999
00:53:11,550 --> 00:53:12,990
你可以从最后一个副本中读取，

1000
00:53:13,020 --> 00:53:14,220
应该能获得相同的东西，

1001
00:53:14,610 --> 00:53:19,170
甚至可以使副本崩溃，因为，

1002
00:53:22,590 --> 00:53:26,070
所以，让我们杀死其中一个，

1003
00:53:32,960 --> 00:53:34,250
我们可以看到，

1004
00:53:37,650 --> 00:53:40,440
现在名字空间里只剩下四个副本了，

1005
00:53:40,770 --> 00:53:45,570
然后向这个文件写入不同的字符串，

1006
00:53:48,910 --> 00:53:51,460
而且，我应该，

1007
00:53:52,300 --> 00:53:57,490
是的，所以，所以现在，尽管一个失败了，

1008
00:53:57,520 --> 00:53:59,320
服务自动重新配置，

1009
00:53:59,800 --> 00:54:05,620
以及基于的内存中文件系统服务，

1010
00:54:05,620 --> 00:54:06,880
根本不需要修改，

1011
00:54:06,880 --> 00:54:09,430
你只需插入任何你想要的新服务，

1012
00:54:09,430 --> 00:54:11,290
实现 9P 接口的，

1013
00:54:11,290 --> 00:54:13,120
而且它应该开箱即用。

1014
00:54:15,100 --> 00:54:17,890
所以，我认为这是，

1015
00:54:18,460 --> 00:54:22,150
我想我的演示到此结束了，

1016
00:54:22,150 --> 00:54:23,950
我很乐意回答更多的问题，

1017
00:54:24,430 --> 00:54:25,210
你们可能有的。

1018
00:54:33,330 --> 00:54:35,730
我后悔这次没有穿我的 Plan9 衣服，

1019
00:54:37,530 --> 00:54:38,190
我应该这么做的，

1020
00:54:38,250 --> 00:54:39,270
不过我很好奇，

1021
00:54:39,450 --> 00:54:43,050
这学期早些时候我在做一些类似的东西，

1022
00:54:43,050 --> 00:54:45,180
只是没有复制，

1023
00:54:45,180 --> 00:54:48,360
它只是 Linux 机器下的 9P 服务，

1024
00:54:48,420 --> 00:54:50,820
为什么，这是一个即兴的问题，

1025
00:54:50,820 --> 00:54:51,900
为什么链式复制，

1026
00:54:52,580 --> 00:54:55,070
我想还有其他的复制方案，

1027
00:54:55,490 --> 00:54:58,100
在这类事情上是可用的，

1028
00:54:58,100 --> 00:54:59,630
从理论上讲，因为这是 9P ，

1029
00:54:59,630 --> 00:55:02,330
你可能会把所有这些副本都绑定在同一个命名空间，

1030
00:55:02,330 --> 00:55:03,440
它们看起来像是一台机器，

1031
00:55:03,440 --> 00:55:05,120
但为什么是链式复制？

1032
00:55:06,480 --> 00:55:08,040
是的，是的，好问题，

1033
00:55:08,040 --> 00:55:10,950
理论上，你可以做任何你想做的复制方案，

1034
00:55:10,980 --> 00:55:12,120
在底层，

1035
00:55:12,210 --> 00:55:14,310
我做了链式复制，

1036
00:55:14,820 --> 00:55:18,560
因为它看起来像一个简单的起点，我想，

1037
00:55:18,560 --> 00:55:21,380
我也可以把这个放在 Raft 实现上，

1038
00:55:21,380 --> 00:55:23,120
比如条目或类似的东西，

1039
00:55:24,530 --> 00:55:26,120
这是关于选择的一些基本问题。

1040
00:55:31,840 --> 00:55:36,550
你的系统是否支持在启动后添加其他副本？

1041
00:55:36,880 --> 00:55:38,140
是的，好问题，

1042
00:55:38,170 --> 00:55:43,300
所以你已经知道，这是一项正在进行的工作，

1043
00:55:44,060 --> 00:55:50,030
但是，是的，目前我们不支持添加额外的副本。

1044
00:55:56,500 --> 00:55:57,640
这是一个开放的问题，

1045
00:55:57,640 --> 00:55:59,530
比如你可能不知道这个，

1046
00:55:59,530 --> 00:56:01,090
这不是目的的明确意图，

1047
00:56:01,090 --> 00:56:04,060
但 Plan9 和 9P 真正酷的一点是，

1048
00:56:04,270 --> 00:56:06,640
你也将网络连接视为它们的文件，

1049
00:56:06,850 --> 00:56:08,980
所以你有 memfs ，

1050
00:56:08,980 --> 00:56:11,680
从我看到的，你已经实现了一个调度器队列，

1051
00:56:11,680 --> 00:56:12,550
只是一些文件，

1052
00:56:14,330 --> 00:56:16,280
你是否，这是一个开放的问题，

1053
00:56:16,280 --> 00:56:19,640
因为文件接口上的网络是否存在问题，

1054
00:56:19,640 --> 00:56:21,890
可伸缩性很难回答，

1055
00:56:21,920 --> 00:56:25,130
但你是否也以这种方式实现这一点，

1056
00:56:25,130 --> 00:56:27,770
或者你是否使用更传统的[]接口，

1057
00:56:27,920 --> 00:56:29,450
当客户端使用这个东西时，

1058
00:56:29,450 --> 00:56:32,300
它们认为它们使用传统的套接字和东西进行通信。

1059
00:56:33,400 --> 00:56:35,110
是的，是的，好问题，

1060
00:56:35,110 --> 00:56:36,790
所以，是的，所有的东西，

1061
00:56:36,820 --> 00:56:42,910
所以目前所有的客户端和服务都是通过 TCP 通信的，

1062
00:56:44,250 --> 00:56:46,440
是的，这是一个很好的问题，

1063
00:56:46,440 --> 00:56:48,930
9P 命名空间是否性能足够好，

1064
00:56:48,930 --> 00:56:50,100
我们要用它来做什么，

1065
00:56:50,190 --> 00:56:52,200
就我们现在所能看到的，

1066
00:56:52,230 --> 00:56:53,970
没有，

1067
00:56:55,050 --> 00:56:57,660
所以我们做了一些性能基准测试，

1068
00:56:57,660 --> 00:57:04,020
来了解我们在 9P 上编写的调度器有多好，

1069
00:57:04,640 --> 00:57:08,150
我们已经做了一些性能基准测试，看看它的表现如何，

1070
00:57:08,150 --> 00:57:10,280
目前它似乎并没有增加太多的开销，

1071
00:57:10,280 --> 00:57:15,250
但是，我们可以想象不同类型的服务的权衡会发生变化，

1072
00:57:15,430 --> 00:57:18,850
并且调度器或多或少变得超额订阅。

1073
00:57:20,750 --> 00:57:21,950
我想澄清一下，

1074
00:57:21,950 --> 00:57:24,410
很抱歉我占用了你很多时间，

1075
00:57:24,410 --> 00:57:27,110
但只是简单地说，整个 9P ，

1076
00:57:27,110 --> 00:57:29,120
如果你如果你能够，

1077
00:57:29,120 --> 00:57:30,350
这也是非常开放的，

1078
00:57:30,350 --> 00:57:32,510
但如果你能够把网络连接当成文件，

1079
00:57:32,510 --> 00:57:34,220
你就有了副本，

1080
00:57:34,250 --> 00:57:36,690
你可以为每一个网卡准备一些东西，

1081
00:57:36,690 --> 00:57:38,850
然后在这些网卡上分片网络流量，

1082
00:57:38,850 --> 00:57:40,710
我想这是无服务器的，

1083
00:57:40,710 --> 00:57:42,720
所以这可能不会有太大不同，

1084
00:57:42,840 --> 00:57:43,500
是的，算了，

1085
00:57:45,900 --> 00:57:48,480
因为你已经有自己的处理了。

1086
00:57:50,440 --> 00:57:51,340
谢谢。

1087
00:57:52,150 --> 00:57:52,870
谢谢。

1088
00:57:54,130 --> 00:57:57,940
好的，让我们来听一些关于验证的东西，如果你准备好了。

1089
00:58:02,730 --> 00:58:03,870
你们能听到我说话吗？

1090
00:58:04,490 --> 00:58:04,940
是的。

1091
00:58:05,590 --> 00:58:06,820
好的，太好了，

1092
00:58:07,090 --> 00:58:10,090
所以，我要和你们谈谈我的项目，

1093
00:58:10,090 --> 00:58:13,540
它专注于分布式系统的模块化验证。

1094
00:58:13,870 --> 00:58:17,650
所以让我们从回答这个显而易见的问题开始，

1095
00:58:17,650 --> 00:58:20,440
为什么关心这个东西，

1096
00:58:20,560 --> 00:58:24,070
我认为任何完成 6.824 实验的人，

1097
00:58:24,070 --> 00:58:25,420
一定是在某个时候发现，

1098
00:58:25,420 --> 00:58:28,660
让这种[]变得正确是困难的，

1099
00:58:28,660 --> 00:58:32,380
并发和网络故障导致了大量的不确定性，

1100
00:58:32,470 --> 00:58:35,770
这使得测试变得非常困难，

1101
00:58:35,770 --> 00:58:37,630
为了确保没有边界 bug ，

1102
00:58:38,680 --> 00:58:44,140
验证是获得正确性的另一种方法测试，

1103
00:58:44,230 --> 00:58:47,200
理论上，它可以完全排除 bug ，

1104
00:58:47,440 --> 00:58:50,710
通过验证，你已经对系统进行了数学建模，

1105
00:58:50,890 --> 00:58:53,290
并改进了关于该模型的一些定理，

1106
00:58:53,910 --> 00:58:57,600
验证的一个缺点是，

1107
00:58:57,600 --> 00:58:59,100
需要做相当多的工作，

1108
00:58:59,280 --> 00:59:01,170
在这些正式证明过程中，

1109
00:59:01,170 --> 00:59:02,310
绝非易事，

1110
00:59:02,610 --> 00:59:04,860
即使这很容易，

1111
00:59:04,860 --> 00:59:07,320
验证仍然不是完美的银弹，

1112
00:59:07,590 --> 00:59:11,400
对于一个验证，你必须确保你的规格是正确的，

1113
00:59:11,640 --> 00:59:14,700
如果你用你的系统证明的数学定理

1114
00:59:14,760 --> 00:59:17,610
并没有说出你真正想说的，

1115
00:59:17,640 --> 00:59:19,290
那么你所证明的一切都是无用的，

1116
00:59:19,380 --> 00:59:21,030
与之相关的是，

1117
00:59:21,030 --> 00:59:24,600
你必须确保你必须[]模型也是完整的，

1118
00:59:24,930 --> 00:59:29,460
如果你不能对现实中可能发生的一些执行进行建模，

1119
00:59:29,460 --> 00:59:30,690
但你不考虑，

1120
00:59:30,690 --> 00:59:33,870
那么你的定理不会适用于现实世界。

1121
00:59:35,190 --> 00:59:39,210
你们中的一些人熟悉一些分布式验证工作，

1122
00:59:39,210 --> 00:59:42,150
可能会说，我们不是已经知道怎么做了吗，

1123
00:59:42,150 --> 00:59:44,100
事实上，分布式系统一直很难实现，

1124
00:59:44,100 --> 00:59:47,430
人们最近致力于一个项目，

1125
00:59:47,430 --> 00:59:50,670
试图验证分布式系统的实现，

1126
00:59:51,000 --> 00:59:53,670
其中一些项目包括 IronFleet 和 Verdi ，

1127
00:59:54,210 --> 00:59:58,380
然而，这些项目并没有太多地关注模块化，

1128
00:59:58,710 --> 01:00:02,520
或者试图证明系统组件的可重用规范，

1129
01:00:02,580 --> 01:00:04,680
试图用它们来建造更复杂的系统，

1130
01:00:05,400 --> 01:00:09,180
我认为这就是分布式系统的实际构建方式，

1131
01:00:09,300 --> 01:00:11,850
构建分布式系统的方法是通过

1132
01:00:11,850 --> 01:00:14,070
通常使用构建块，

1133
01:00:14,190 --> 01:00:17,850
比如键值服务、锁服务或 Zookeeper ，

1134
01:00:17,880 --> 01:00:19,230
将它们放在一起，

1135
01:00:19,230 --> 01:00:22,080
与一些添加的代码和新的功能，

1136
01:00:22,170 --> 01:00:24,570
为了建立更有趣、更有用的系统，

1137
01:00:25,840 --> 01:00:28,180
这是一种论题，

1138
01:00:28,300 --> 01:00:33,160
验证可以而且应该利用这种构成性，

1139
01:00:33,190 --> 01:00:35,110
作为一种有针对性的目标，

1140
01:00:35,110 --> 01:00:38,350
我们的目标是证明客户端系统的规格，

1141
01:00:38,650 --> 01:00:41,470
之前的工作，比如 IronFleet Verdi 简单地推理，

1142
01:00:41,470 --> 01:00:44,530
实际服务器端的行为是什么，

1143
01:00:44,680 --> 01:00:46,420
没有显式地建模

1144
01:00:46,420 --> 01:00:49,210
或证明任何关于客户端程序所做的事情，

1145
01:00:49,270 --> 01:00:51,220
而且通常情况下，客户端上有一些逻辑，

1146
01:00:51,400 --> 01:00:53,380
这对于获得正确的结果至关重要，

1147
01:00:53,920 --> 01:00:55,780
我们使用的方法是

1148
01:00:55,780 --> 01:00:58,660
使用并行分离逻辑中的先进技术，

1149
01:00:58,960 --> 01:01:02,140
它是关于并发程序的推理的组合手段，

1150
01:01:02,140 --> 01:01:05,920
它最近变得流行起来，

1151
01:01:05,920 --> 01:01:08,740
证明成功地提出了关于推理真正的代码。

1152
01:01:09,800 --> 01:01:12,230
所以我们研究的第一个例子，

1153
01:01:12,230 --> 01:01:15,080
是验证一个分片的键值系统，

1154
01:01:15,080 --> 01:01:18,770
其中的键是静态分成不同的分片，

1155
01:01:19,040 --> 01:01:22,490
并且分片本身可以在分片服务器之间移动，

1156
01:01:22,700 --> 01:01:25,670
它与 6.824 的实验 4 非常相似，

1157
01:01:25,730 --> 01:01:27,650
只是它不是复制的，

1158
01:01:27,650 --> 01:01:29,360
所以这里面没有 Raft ，

1159
01:01:29,480 --> 01:01:31,130
而且，它纯粹是在内存中。

1160
01:01:31,520 --> 01:01:36,140
除此之外，我们的系统还具有分片服务器和协调服务器，

1161
01:01:36,140 --> 01:01:38,960
协调器是通知其他分片服务器，

1162
01:01:38,960 --> 01:01:40,700
在分片之间移动，

1163
01:01:40,700 --> 01:01:43,490
在想加入或需要重新平衡时，

1164
01:01:44,360 --> 01:01:46,970
我们提供的高级别的库，

1165
01:01:46,970 --> 01:01:49,610
我们想要证明的规范是，

1166
01:01:49,610 --> 01:01:51,110
我们称之为 KVClerk ，

1167
01:01:51,110 --> 01:01:54,080
它是一个用户可以使用的客户端对象，

1168
01:01:54,080 --> 01:01:56,000
我们调用这三个函数

1169
01:01:56,090 --> 01:01:57,980
来与服务器交互，

1170
01:01:57,980 --> 01:02:00,830
有一个 Put ，你要把什么值放入键中，

1171
01:02:00,860 --> 01:02:03,080
有一个 Get ，它将返回键中的当前值，

1172
01:02:03,320 --> 01:02:04,610
然后有一个 ConditionalPut ，

1173
01:02:04,640 --> 01:02:09,140
它只会放入新值，如果旧值是期望值，

1174
01:02:10,020 --> 01:02:15,270
我们的目标是实现一个可线性化的键值服务，

1175
01:02:15,270 --> 01:02:18,300
并批准规范，显示可线性化，

1176
01:02:18,750 --> 01:02:22,320
你执行这个，使用分离逻辑方式，

1177
01:02:22,320 --> 01:02:25,320
是通过编写一个看起来很像这样的规范，

1178
01:02:25,680 --> 01:02:30,870
这基本上是说，如果对象 ck 是一个 KVClerk ，

1179
01:02:31,140 --> 01:02:35,070
然后你就有了 Put 和 Get 函数的规范，

1180
01:02:35,310 --> 01:02:39,420
例如，如果你开始运行 Put 函数，

1181
01:02:39,510 --> 01:02:43,860
在键 k 具有值 w 的前提下，

1182
01:02:43,980 --> 01:02:48,030
然后在它结束时，键 k 是值 v ，

1183
01:02:48,720 --> 01:02:51,720
同样，如果你执行一个 Get ，

1184
01:02:51,720 --> 01:02:54,540
键 k 在开始时的值是 v ，

1185
01:02:54,540 --> 01:02:56,250
那么这就是要返回的东西，

1186
01:02:56,460 --> 01:02:58,650
你仍然会知道这就是键的值，

1187
01:02:59,160 --> 01:03:01,380
尽管这些规范看起来很简单，

1188
01:03:01,380 --> 01:03:04,200
您可能会想，键值服务当然会，

1189
01:03:04,350 --> 01:03:05,340
这就是关键，

1190
01:03:05,340 --> 01:03:09,390
这些高级别客户端规范尽可能简单，

1191
01:03:09,390 --> 01:03:12,360
并且隐藏了事实的所有细节，

1192
01:03:12,360 --> 01:03:14,130
有多个分片服务器，

1193
01:03:14,130 --> 01:03:17,910
这个 Clerk 库可能需要与服务器多次交互，

1194
01:03:17,910 --> 01:03:19,680
它可能需要刷新它的信息，

1195
01:03:19,800 --> 01:03:22,500
关于哪个服务器拥有那个键，

1196
01:03:22,650 --> 01:03:27,150
我们基本上证明了，让你忘记这一切，

1197
01:03:27,150 --> 01:03:29,940
使用键值服务，只需要调用 Put 和 Get ，

1198
01:03:30,060 --> 01:03:31,350
有了这个理想化的概念，

1199
01:03:31,350 --> 01:03:33,990
关于键值映射是什么样的。

1200
01:03:34,750 --> 01:03:36,430
所以我不会太详细地谈论

1201
01:03:36,430 --> 01:03:38,020
实际的证据是什么，

1202
01:03:38,230 --> 01:03:40,270
相反，要把重点放在，

1203
01:03:40,390 --> 01:03:43,420
我们感兴趣的下一件事上，

1204
01:03:43,600 --> 01:03:46,990
做一些容错性的事情。

1205
01:03:47,050 --> 01:03:50,080
所以如我所说，键值本身不是复制的，

1206
01:03:50,080 --> 01:03:51,430
并且不能容错，

1207
01:03:51,580 --> 01:03:53,350
所以，我们开始尝试找出

1208
01:03:53,350 --> 01:03:57,550
如何验证最简单的容错协议，

1209
01:03:57,640 --> 01:04:00,550
我们从单决议 Paxos 开始，

1210
01:04:00,730 --> 01:04:04,630
单决议 Paxos 是用于在单个值获取共识的经典协议，

1211
01:04:05,060 --> 01:04:06,290
与 Raft 相比，

1212
01:04:06,380 --> 01:04:08,870
你可以复制整个日志，

1213
01:04:08,870 --> 01:04:10,460
你不停地在日志中添加新的条目，

1214
01:04:10,490 --> 01:04:13,820
单决议 Paxos 是多 Paxos 的[]，

1215
01:04:13,820 --> 01:04:16,160
基本上一次写入寄存器的功能，

1216
01:04:16,280 --> 01:04:19,220
如果要将值设置为某个值，

1217
01:04:19,250 --> 01:04:21,320
你可以尝试对其进行写入，

1218
01:04:21,590 --> 01:04:22,760
如果有人打败了你，

1219
01:04:22,760 --> 01:04:24,830
那对你来说太糟糕了，

1220
01:04:24,830 --> 01:04:26,180
现在值已经确定了，

1221
01:04:26,180 --> 01:04:27,350
它再也不会改变了。

1222
01:04:28,080 --> 01:04:32,700
所以，我们实现并部分验证了单决议 Paxos 实现，

1223
01:04:32,790 --> 01:04:36,600
证明了它是一次写入寄存器的规范，

1224
01:04:37,560 --> 01:04:41,520
规范和证明中的关键思想是，

1225
01:04:41,550 --> 01:04:44,610
当你在单决议 Paxos 中提交一个值，

1226
01:04:44,850 --> 01:04:48,840
你得到了不可撤销的知识关于提交的值是什么，

1227
01:04:48,900 --> 01:04:50,790
你知道，从现在开始，

1228
01:04:50,790 --> 01:04:53,430
如果其他人看到任何提交的值，

1229
01:04:53,550 --> 01:04:56,160
这将是你现在看到的完全相同的东西。

1230
01:04:57,190 --> 01:05:00,400
在我们研究了它的证明之后，考虑这个问题，

1231
01:05:00,910 --> 01:05:02,740
我们想到，

1232
01:05:02,800 --> 01:05:03,970
我们注意到，

1233
01:05:03,970 --> 01:05:07,240
你可以对单决议 Paxos 做一个轻微的概括，

1234
01:05:07,240 --> 01:05:10,900
我们称为单调的 Paxos ，因为没有更好的名字，

1235
01:05:11,320 --> 01:05:12,370
这个想法是，

1236
01:05:12,370 --> 01:05:16,210
不是在提交时获得关于确切值的知识，

1237
01:05:16,480 --> 01:05:19,450
我们可以修改协议，

1238
01:05:19,630 --> 01:05:22,930
这样你就只能获得关于值的下界的知识，

1239
01:05:23,570 --> 01:05:27,410
所以，当你提交一个值时，

1240
01:05:27,470 --> 01:05:30,410
例如，你提交数字 15 到这个写入一次寄存器，

1241
01:05:30,500 --> 01:05:32,960
不是知道 15 是唯一的值，

1242
01:05:32,960 --> 01:05:34,550
任何人在未来会看到的，

1243
01:05:34,760 --> 01:05:37,130
人们在未来看到的任何值，

1244
01:05:37,130 --> 01:05:40,100
提交的至少是 15 ，

1245
01:05:40,100 --> 01:05:42,470
当然，要做到这一点，需要一些概念，

1246
01:05:42,470 --> 01:05:45,200
对于值类型，大于的含义。

1247
01:05:45,550 --> 01:05:48,790
关键思想是

1248
01:05:48,940 --> 01:05:53,320
副本总是可以找到最新提交的值是多少，

1249
01:05:53,410 --> 01:05:54,670
并选择增加它，

1250
01:05:54,850 --> 01:05:57,070
而其他副本可以不断地找出

1251
01:05:57,070 --> 01:06:00,970
到目前为止越来越大的下界的值，

1252
01:06:01,680 --> 01:06:05,700
一旦我们想出了单调 Paxos 的想法，

1253
01:06:05,760 --> 01:06:07,530
我们立刻意识到，

1254
01:06:07,530 --> 01:06:09,780
我们可以用它来进行日志复制，

1255
01:06:10,200 --> 01:06:13,020
所以这组值 V ，

1256
01:06:13,050 --> 01:06:15,600
我们可以简单地选择为所有的日志，

1257
01:06:15,630 --> 01:06:18,540
你可能希望复制你的操作日志，

1258
01:06:18,660 --> 01:06:21,060
我们可以定义一个日志大于另一个，

1259
01:06:21,060 --> 01:06:25,110
如果较小的是，如果 l1 是 l2 的前缀，

1260
01:06:26,820 --> 01:06:29,040
这让我们知道，

1261
01:06:29,040 --> 01:06:31,770
这就产生了一种你必须信任的协议，

1262
01:06:31,770 --> 01:06:33,000
我现在给你们看的代码，

1263
01:06:33,300 --> 01:06:38,070
你可以在其中获取有关日志前缀的信息，

1264
01:06:38,340 --> 01:06:40,560
随着时间的推移，你可以向日志中添加新的内容，

1265
01:06:40,560 --> 01:06:41,790
通过让它变得越来越大，

1266
01:06:41,790 --> 01:06:43,500
这几乎就是我们的意思，

1267
01:06:43,500 --> 01:06:44,580
当我们说到日志复制时。

1268
01:06:45,380 --> 01:06:48,500
这个协议的问题是，

1269
01:06:48,500 --> 01:06:52,790
我们实现了单调 Paxos 最幼稚的版本，

1270
01:06:53,000 --> 01:06:56,060
你需要在每个 RPC 上发送完整的日志，

1271
01:06:56,300 --> 01:06:57,320
在单决议 Paxos 中，

1272
01:06:57,320 --> 01:07:00,320
你在所有 RPC 上发送完整的值，

1273
01:07:00,410 --> 01:07:04,490
在 Paxos 中的微不足道的概括

1274
01:07:04,490 --> 01:07:05,840
将不得不被发送到整个日志，

1275
01:07:06,080 --> 01:07:08,990
这并不是真正有用的，日志变得越来越大，

1276
01:07:08,990 --> 01:07:11,930
并且日志开始时，与时间无关，

1277
01:07:11,930 --> 01:07:13,070
每个人都同意提交，

1278
01:07:13,070 --> 01:07:13,880
所有这些，

1279
01:07:14,150 --> 01:07:17,810
所以你可以尝试通过传递日志的后缀来优化它，

1280
01:07:18,170 --> 01:07:21,860
事实上，有一个完整的优化序列，

1281
01:07:21,860 --> 01:07:25,100
你可以对这种基于单调 Paxos 的日志进行复制，

1282
01:07:25,460 --> 01:07:27,770
当你开始做越来越多这样的事情时，

1283
01:07:27,770 --> 01:07:30,470
你会意识到这看起来和 Raft 很像。

1284
01:07:31,010 --> 01:07:36,350
事实上，我们的目标是利用我们的 Monotone Paxos ，

1285
01:07:36,380 --> 01:07:38,930
不是实现新的复制协议，

1286
01:07:38,990 --> 01:07:42,050
而是验证一个类似 Raft 的系统，

1287
01:07:42,320 --> 01:07:44,330
所以我们有这个单决议 Paxos 的证明，

1288
01:07:44,450 --> 01:07:47,120
我们对这种单调 Paxos 有一个明确的概括，

1289
01:07:47,690 --> 01:07:50,120
我们的希望是，我们可以利用单调 Paxos 想法，

1290
01:07:50,120 --> 01:07:52,910
直接验证 Raft ，

1291
01:07:52,970 --> 01:07:57,800
不同于依赖 Raft 的更为复杂的正确性争论，

1292
01:07:58,010 --> 01:08:01,670
已经在某种其他状态机类型的样式中进行了描述。

1293
01:08:02,220 --> 01:08:04,740
所以这是我们未来的工作，

1294
01:08:05,010 --> 01:08:09,960
我想告诉你们的关键一点是，

1295
01:08:10,020 --> 01:08:13,470
关于分布式系统的正式和非正式推理，

1296
01:08:13,710 --> 01:08:15,840
应该像编写代码一样进行组合，

1297
01:08:16,230 --> 01:08:18,030
编写代码的扩展方式是模块化的，

1298
01:08:18,030 --> 01:08:20,070
这就是推理也应该进行扩展的方式。

1299
01:08:21,680 --> 01:08:24,530
我的演讲到此结束，

1300
01:08:24,530 --> 01:08:26,090
我很乐意回答大家的提问。

1301
01:08:35,610 --> 01:08:36,810
如果答案太长，

1302
01:08:36,810 --> 01:08:38,190
你可以在聊天中看到我，

1303
01:08:38,190 --> 01:08:38,850
但我很好奇，

1304
01:08:38,850 --> 01:08:39,840
我知道有个[]，

1305
01:08:39,840 --> 01:08:40,710
你有没有什么资源，

1306
01:08:40,710 --> 01:08:44,400
提供给有兴趣从软件的角度进入的人，

1307
01:08:44,400 --> 01:08:46,050
任何简短的建议。

1308
01:08:46,780 --> 01:08:51,130
你是，所以，是的，我想我不是很确定，

1309
01:08:51,780 --> 01:08:53,100
那么，你有没有兴趣，

1310
01:08:53,100 --> 01:08:54,450
我应该在之后发消息，

1311
01:08:54,450 --> 01:08:55,500
但如果你感兴趣的话，

1312
01:08:55,500 --> 01:08:59,550
我想，在某种最轻量级的验证版本中，

1313
01:08:59,670 --> 01:09:01,350
我认为 Dafny 是一个很好的学习工具，

1314
01:09:01,350 --> 01:09:03,720
因为这是一个非常简单的起点，

1315
01:09:03,720 --> 01:09:06,540
你可以编写真正的代码，并对事物有感觉，

1316
01:09:06,630 --> 01:09:09,360
我认为很多的验证都是相当学术的，

1317
01:09:09,360 --> 01:09:13,500
在像这样的验证中并不是非常有用，

1318
01:09:13,740 --> 01:09:16,440
所以我不确定它到底有多大用处，

1319
01:09:16,470 --> 01:09:17,850
真正的软件目前还没有，

1320
01:09:18,060 --> 01:09:19,830
所以，人们希望有一天它会成为现实。

1321
01:09:20,840 --> 01:09:21,230
谢谢。

1322
01:09:24,670 --> 01:09:29,260
你有没有实现你所说的这个版本的 Paxos ？

1323
01:09:29,770 --> 01:09:31,330
这个单调 Paxos 东西。

1324
01:09:32,500 --> 01:09:34,120
所以，是的，我实现了，

1325
01:09:34,120 --> 01:09:36,610
不是实现了通用的单调 Paxos ，

1326
01:09:36,610 --> 01:09:38,440
这没有意义，

1327
01:09:38,470 --> 01:09:42,400
我直接实现了单调 Paxos 上的日志复制，

1328
01:09:42,430 --> 01:09:46,000
所以，在单调日志应用程序中，

1329
01:09:46,000 --> 01:09:47,650
所有 RPC 发送整个日志，

1330
01:09:47,800 --> 01:09:49,750
如果你运行了很长时间变得太慢，

1331
01:09:49,750 --> 01:09:51,640
因为 RPC 发送了太多的东西，

1332
01:09:51,640 --> 01:09:52,900
是的，我确实实现了，

1333
01:09:52,900 --> 01:09:56,080
我认为我们正在努力试图对它进行推理。

1334
01:09:57,490 --> 01:10:02,890
你有没有[]弄清楚它的性能，

1335
01:10:02,890 --> 01:10:04,960
或者它在实践中是如何运作的？

1336
01:10:06,040 --> 01:10:10,630
所以我认为我们现在所拥有的代码并不是你想要运行的代码，

1337
01:10:10,630 --> 01:10:12,070
而我的，

1338
01:10:12,970 --> 01:10:15,370
在某种意义上，它应该有 Raft 一样的性能，

1339
01:10:15,370 --> 01:10:18,190
我们并没有真正优化的实现，

1340
01:10:18,190 --> 01:10:20,650
我根本没有去获取它的性能数据，

1341
01:10:22,200 --> 01:10:23,940
它可能相当慢，不是很确定。

1342
01:10:29,930 --> 01:10:30,770
好的，谢谢，

1343
01:10:30,950 --> 01:10:33,440
是的，即使我们验证了我的程序，

1344
01:10:33,440 --> 01:10:35,060
我肯定日志在某个地方，

1345
01:10:35,630 --> 01:10:39,480
但现在让我们来听听 PP2 。

1346
01:10:51,340 --> 01:10:52,120
好的，大家都能看到吗？

1347
01:10:54,150 --> 01:10:54,600
好的。

1348
01:10:54,990 --> 01:10:59,970
我们是[]协议团队，我， Jay 和 Timmy ，

1349
01:10:59,970 --> 01:11:02,520
我们展示一个简单的分布式文件系统，

1350
01:11:03,120 --> 01:11:05,520
我们选择分布式文件系统的原因是，

1351
01:11:05,520 --> 01:11:07,980
用户经常希望对数据进行私有排序，

1352
01:11:07,980 --> 01:11:09,150
以一种真正可访问的方式，

1353
01:11:09,180 --> 01:11:11,130
在使用云公司的影响，

1354
01:11:11,130 --> 01:11:12,600
你不拥有你自己的数据。

1355
01:11:13,500 --> 01:11:15,120
所以我们想要创造一个解决方案，

1356
01:11:15,120 --> 01:11:16,500
你托管自己的数据

1357
01:11:16,530 --> 01:11:19,920
在商用硬件上以容错分布式方式，

1358
01:11:20,690 --> 01:11:23,600
我们的文件系统非常类似于 Frangipani ，

1359
01:11:23,600 --> 01:11:25,580
除了它使用 Raft 而不是 Petal ，

1360
01:11:25,610 --> 01:11:28,820
并且文件系统在服务器上，而不是客户端上。

1361
01:11:29,420 --> 01:11:30,980
在文件系统参数方面，

1362
01:11:30,980 --> 01:11:33,920
我们还有一个 4096 字节的数据块大小，

1363
01:11:33,920 --> 01:11:36,440
和 2M 字节的最大文件大小，

1364
01:11:36,950 --> 01:11:40,100
理论上我们有 32G 的最大磁盘容量，

1365
01:11:40,280 --> 01:11:42,080
然而，这受到你的 RAM 的限制，

1366
01:11:42,080 --> 01:11:44,300
如果你只有 8G 的 RAM ，

1367
01:11:44,300 --> 01:11:45,050
你会有，

1368
01:11:45,440 --> 01:11:49,340
无论你的系统占用了多少所剩下的。

1369
01:11:50,140 --> 01:11:54,220
我们在合理范围内支持尽可能多的服务器和客户端，

1370
01:11:54,250 --> 01:11:58,090
显然，你向锁争用中添加的服务器和客户端越多，

1371
01:11:58,090 --> 01:12:00,040
性能将会降低，

1372
01:12:00,040 --> 01:12:02,980
当你开始一遍又一遍地访问同一文件时。

1373
01:12:03,690 --> 01:12:06,060
就性能而言，

1374
01:12:06,060 --> 01:12:09,660
我们非常关注可用性和崩溃恢复，

1375
01:12:09,660 --> 01:12:11,970
我们没有测量性能，

1376
01:12:11,970 --> 01:12:13,230
我们认为情况可能相当糟糕，

1377
01:12:13,230 --> 01:12:15,510
因为我们的系统是建立在 Raft 上的，

1378
01:12:15,510 --> 01:12:18,990
这并不是已知的系统中性能最好的。

1379
01:12:19,890 --> 01:12:21,780
所以，轮到 Jay 了。

1380
01:12:22,760 --> 01:12:25,700
所以，再说一次，性能不是我们最重要的东西，

1381
01:12:25,700 --> 01:12:28,610
但我们确实有非常强大的一致性保证，

1382
01:12:28,670 --> 01:12:30,860
特别是，我们强制执行 POSIX 一致性，

1383
01:12:30,860 --> 01:12:32,720
这是一种强一致性的形式，

1384
01:12:32,720 --> 01:12:34,610
我们通常在本地文件系统上看到，

1385
01:12:34,820 --> 01:12:36,530
所以我们强制了不变量，

1386
01:12:36,530 --> 01:12:39,170
在你成功完成文件写入之后，

1387
01:12:39,530 --> 01:12:42,290
从任何地方读取你之前写入的字节，

1388
01:12:42,290 --> 01:12:44,540
将返回之前写入的数据，

1389
01:12:44,720 --> 01:12:47,840
类似地，对该数据的任何新写入

1390
01:12:47,870 --> 01:12:50,360
都将导致数据的可视重写，

1391
01:12:50,610 --> 01:12:52,170
从其他读取者的角度来看。

1392
01:12:52,650 --> 01:12:54,360
所以，为了实现这个，

1393
01:12:54,360 --> 01:12:55,500
我们有一个数据模式日志，

1394
01:12:55,500 --> 01:12:57,450
它构建在数据块层，

1395
01:12:57,600 --> 01:13:00,660
它是 Raft 分布式的并复制，

1396
01:13:00,840 --> 01:13:03,000
实际上是预写日志，

1397
01:13:03,000 --> 01:13:06,630
保证了在存在崩溃的情况下强语义的写入原子性，

1398
01:13:06,690 --> 01:13:08,160
和 Raft 差不多，

1399
01:13:08,400 --> 01:13:11,340
以及我们上面提供的一致性模型。

1400
01:13:11,660 --> 01:13:13,880
所以，服务器也为了帮助实现这一点，

1401
01:13:13,880 --> 01:13:15,080
我们发布分布式锁，

1402
01:13:15,080 --> 01:13:17,030
这样我们可以拥有这个非常原始的块缓存，

1403
01:13:17,060 --> 01:13:18,800
正如你在本地文件系统中看到的，

1404
01:13:19,100 --> 01:13:21,110
我们也有租约，

1405
01:13:21,110 --> 01:13:23,690
以确保有相互排斥的访问所有这些区块。

1406
01:13:27,520 --> 01:13:30,190
所以为了允许我们的客户端使用我们的文件系统，

1407
01:13:30,190 --> 01:13:32,140
我们创建了一个类 POSIX 的接口，

1408
01:13:32,140 --> 01:13:34,000
用户可以与文件交互，

1409
01:13:34,240 --> 01:13:37,300
我们主要四个函数， Open Close Read Write ，

1410
01:13:37,450 --> 01:13:40,240
Open 和 Close 很容易解释，

1411
01:13:40,240 --> 01:13:43,360
它们只是打开和关闭我们文件系统上的文件描述符，

1412
01:13:44,020 --> 01:13:46,360
Read ，它只需要一个文件描述符，

1413
01:13:46,360 --> 01:13:49,900
并在当前文件位置读取固定数量的字节，

1414
01:13:50,260 --> 01:13:51,970
Write 也获取文件描述符，并且读刷新是，

1415
01:13:51,970 --> 01:13:54,190
Read 刷新是，

1416
01:13:54,340 --> 01:13:57,970
抱歉， Write 操作需要文件描述符，

1417
01:13:57,970 --> 01:14:01,660
并将数据写入文件，

1418
01:14:01,780 --> 01:14:05,380
但它的方式与正常的 POSIX 写入方式不同，

1419
01:14:05,380 --> 01:14:09,940
因为不是刷新文件的缓冲复制，

1420
01:14:09,940 --> 01:14:11,800
然后在上面追加新的数据，

1421
01:14:12,310 --> 01:14:14,260
所以，与正常的 POSIX 写入不同，

1422
01:14:14,260 --> 01:14:17,750
我们只需使用缓冲区写入文件描述符，

1423
01:14:17,750 --> 01:14:20,840
而要写入的字节数，正如我刚才所说的那样。

1424
01:14:21,020 --> 01:14:25,160
我们有一个演示来演示客户端与系统的交互。

1425
01:14:28,290 --> 01:14:30,450
所以，这是我们的文件系统的快速演示，

1426
01:14:30,450 --> 01:14:32,670
在串行和并行运行的情况下，

1427
01:14:32,670 --> 01:14:35,130
在控制台一中发生的是，

1428
01:14:35,130 --> 01:14:36,900
或者我应该说左控制台，

1429
01:14:36,930 --> 01:14:41,040
将打开一个名为 tt 的文件，只是测试一下，

1430
01:14:42,670 --> 01:14:44,230
它会在文件中写入一些内容，

1431
01:14:44,230 --> 01:14:46,810
然后右边的控制台随后将读取它，

1432
01:14:47,020 --> 01:14:48,490
根据一致性模型，

1433
01:14:48,520 --> 01:14:51,820
它们应该看到与左侧控制台所写的相同的内容，

1434
01:14:51,820 --> 01:14:57,630
事实上，一分钟后，我们就看到了这个。

1435
01:14:57,840 --> 01:15:00,390
好的，接下来会发生的事情是，

1436
01:15:00,570 --> 01:15:03,000
控制台一和控制台而都将尝试

1437
01:15:03,000 --> 01:15:06,870
同时刷新文件的本地复制，

1438
01:15:06,990 --> 01:15:08,970
这不是传统的 POSIX 写入，

1439
01:15:09,180 --> 01:15:11,730
它们都有它们拥有的文件的复制，

1440
01:15:11,730 --> 01:15:13,710
并试图同时将它们放到磁盘上，

1441
01:15:14,140 --> 01:15:16,810
所以从偏移量零开始的两次写入，

1442
01:15:17,140 --> 01:15:18,550
其中一个会赢，

1443
01:15:19,060 --> 01:15:21,550
我们可以查看左侧控制台上的日志，

1444
01:15:21,550 --> 01:15:22,210
因为它提交，

1445
01:15:22,210 --> 01:15:24,820
过一会儿，你会看到，

1446
01:15:25,520 --> 01:15:28,070
两个事务同时运行，

1447
01:15:28,160 --> 01:15:29,960
它们都占据了日志的不同部分，

1448
01:15:30,050 --> 01:15:31,250
但归根结底，

1449
01:15:31,370 --> 01:15:34,130
左侧控制台事务将获胜，

1450
01:15:34,520 --> 01:15:37,370
所以，它完全是原子的，一切都是有效的。

1451
01:15:41,450 --> 01:15:41,960
所以，这是。

1452
01:15:48,950 --> 01:15:49,970
我想你被静音了。

1453
01:15:51,110 --> 01:15:52,160
抱歉，我静音了，

1454
01:15:52,550 --> 01:15:53,810
由于时间的原因，还有更多的，

1455
01:15:53,840 --> 01:15:56,810
我们可以向我们的文件系统添加一些限制和功能，

1456
01:15:57,020 --> 01:16:00,440
首先，我们只有一个根目录，

1457
01:16:00,440 --> 01:16:02,600
所以增加更多肯定会是一个加分，

1458
01:16:02,990 --> 01:16:04,760
接下来，我们只是，

1459
01:16:05,210 --> 01:16:08,240
我们将数据块持久存储到磁盘而不是 RAM ，

1460
01:16:08,240 --> 01:16:09,770
因为这就是我们目前正在做的事情，

1461
01:16:09,890 --> 01:16:13,190
但我们也应该考虑到我们正在做的事情，

1462
01:16:13,190 --> 01:16:14,120
有很多写入，

1463
01:16:14,120 --> 01:16:15,680
所以情况可能会很糟糕，

1464
01:16:15,680 --> 01:16:16,940
如果我们继续写下去，

1465
01:16:17,310 --> 01:16:19,740
一次操作就有大量写入，

1466
01:16:19,950 --> 01:16:22,230
我们也只有直接 inode 块，

1467
01:16:22,230 --> 01:16:25,860
而不是间接 inode ，

1468
01:16:25,860 --> 01:16:27,510
所以这将是一个加号，

1469
01:16:27,510 --> 01:16:28,410
其次，

1470
01:16:28,470 --> 01:16:32,850
应该有更好的方式让客户端与这个文件系统交互，

1471
01:16:32,850 --> 01:16:34,080
所以可能有一个 FUSE 层，

1472
01:16:34,080 --> 01:16:36,660
或者，它们可能是更好的 POSIX 兼容。

1473
01:16:38,700 --> 01:16:40,050
我们的演讲结束了。

1474
01:16:48,300 --> 01:16:50,760
你想谈谈你是如何测试这个的吗？

1475
01:16:52,290 --> 01:16:55,410
当然，所以我们有一个，在你的推荐下，

1476
01:16:55,410 --> 01:16:56,820
我们有一套相当广泛的测试，

1477
01:16:56,820 --> 01:16:58,650
开始每个组件，

1478
01:16:58,650 --> 01:17:00,870
所以每个块层，

1479
01:17:00,870 --> 01:17:02,220
单独的 Raft 键值，

1480
01:17:02,220 --> 01:17:03,150
我们有日志，

1481
01:17:03,240 --> 01:17:04,380
我们有所有这些东西，

1482
01:17:04,410 --> 01:17:06,720
我们 mock 了下面的每一层，

1483
01:17:06,750 --> 01:17:09,420
我们测试的每一层，

1484
01:17:09,420 --> 01:17:10,890
做了一些单元测试，

1485
01:17:10,890 --> 01:17:12,870
你不能把它叫做单元测试，一旦你达到了足够高的程度，

1486
01:17:13,160 --> 01:17:16,670
因为你太依赖较低层次的正确性，

1487
01:17:16,670 --> 01:17:18,620
但我们尽了最大努力，

1488
01:17:18,620 --> 01:17:20,210
从那里我们进行了集成测试，

1489
01:17:20,210 --> 01:17:22,550
写出了一组分区，

1490
01:17:22,550 --> 01:17:24,860
其中一个分区就是你刚才看到的，

1491
01:17:25,010 --> 01:17:26,090
其中最有趣的是，

1492
01:17:26,090 --> 01:17:26,930
这里有五个，

1493
01:17:26,930 --> 01:17:29,060
你可以在我们的 Git 仓库中看到它们，

1494
01:17:29,360 --> 01:17:31,760
然后我们也，在多大程度上，我们可以，

1495
01:17:31,760 --> 01:17:33,860
所以这并不一定完全奏效，

1496
01:17:33,860 --> 01:17:35,960
因为我们有一些时间限制，

1497
01:17:35,960 --> 01:17:38,630
但我们也试图做一些压力测试，

1498
01:17:38,660 --> 01:17:40,220
显然，性能数据并不是很好，

1499
01:17:40,430 --> 01:17:42,020
因为这不应该是很棒的，

1500
01:17:42,020 --> 01:17:43,820
但是，尽我们所能，

1501
01:17:43,820 --> 01:17:46,490
因此，我们非常确定这至少是在这里得到证实的。

1502
01:18:02,790 --> 01:18:03,930
一件有趣的事情是，

1503
01:18:03,930 --> 01:18:07,800
你们在追求稍微更强的一致性属性，

1504
01:18:07,800 --> 01:18:09,090
比 POSIX 所需要的，

1505
01:18:09,510 --> 01:18:13,080
两个进程写入到一个文件中，

1506
01:18:13,080 --> 01:18:14,310
实际上并没有太多，

1507
01:18:14,340 --> 01:18:17,070
写入，我们必须要做的。

1508
01:18:17,880 --> 01:18:21,150
是的，那是一种意外，

1509
01:18:21,180 --> 01:18:22,320
但我们是，

1510
01:18:22,500 --> 01:18:24,060
所以它更强了。

1511
01:18:24,240 --> 01:18:24,810
是的。

1512
01:18:24,810 --> 01:18:26,550
这是意外，但它确实发生了，

1513
01:18:26,550 --> 01:18:28,680
所以我们认为酷，它起作用了。

1514
01:18:30,480 --> 01:18:33,210
服务器，我的意思是，我认为发生的一部分是，

1515
01:18:33,210 --> 01:18:34,650
我们保证，

1516
01:18:34,650 --> 01:18:36,210
我肯定我说过的话，

1517
01:18:36,210 --> 01:18:38,730
但我们也保证块写入都是原子的，

1518
01:18:38,760 --> 01:18:42,900
我认为这就是为什么我们会得到这种更强的一致性，

1519
01:18:42,900 --> 01:18:44,250
因为日志这件事，

1520
01:18:44,250 --> 01:18:46,050
是的，你可以让你的写入被覆盖，

1521
01:18:46,050 --> 01:18:47,070
如果你同时这么做，

1522
01:18:47,070 --> 01:18:48,090
但它总是[干净的]。

1523
01:18:51,740 --> 01:18:53,150
如果你有主动缓存，

1524
01:18:53,150 --> 01:18:57,080
你可能会遇到，不立即写入日志，

1525
01:18:57,080 --> 01:18:59,120
那么你可能会得到不同的行为。

1526
01:19:00,370 --> 01:19:01,840
这就是为什么我们不积极地缓存，

1527
01:19:01,870 --> 01:19:04,240
我们有一个大小为 1 的数据块缓存。

1528
01:19:10,890 --> 01:19:12,300
太棒了，谢谢，很酷，

1529
01:19:12,660 --> 01:19:15,870
好的，我们的最后一组展示一个游戏框架，

1530
01:19:16,430 --> 01:19:17,780
只要你准备好了，就可以开始。

1531
01:19:21,660 --> 01:19:23,280
好的，我们相信，

1532
01:19:23,280 --> 01:19:26,190
你们中的很多人在隔离时都玩过多人游戏，

1533
01:19:26,220 --> 01:19:26,850
当你无聊的时候。

1534
01:19:27,660 --> 01:19:29,070
所以让我们想象一下，

1535
01:19:29,070 --> 01:19:31,740
你是一家小型独立游戏开发公司，

1536
01:19:32,190 --> 01:19:34,140
你试图开发一款多玩家的游戏，

1537
01:19:34,170 --> 01:19:37,770
可能有几个不同的房间，

1538
01:19:37,770 --> 01:19:38,910
比如聊天企鹅，

1539
01:19:38,910 --> 01:19:41,220
你可能会和同一个房间里的其他玩家互动，

1540
01:19:41,370 --> 01:19:42,990
或者可能是匹配的情况，

1541
01:19:42,990 --> 01:19:45,420
你和其他几个玩家在大厅里。

1542
01:19:45,930 --> 01:19:48,600
所以传统上，这些是如何工作的，

1543
01:19:48,690 --> 01:19:51,810
每件事都访问一台中央服务器上的进程，

1544
01:19:52,050 --> 01:19:54,210
但中央服务器是一个瓶颈，

1545
01:19:54,450 --> 01:19:58,590
如果每个玩家都必须连接到那个服务器来处理游戏逻辑，

1546
01:19:58,650 --> 01:20:02,550
那个服务器因通过的请求数量而开始出现瓶颈，

1547
01:20:02,910 --> 01:20:04,560
而且，如果服务器出现故障，

1548
01:20:05,070 --> 01:20:05,970
这就是[]。

1549
01:20:06,760 --> 01:20:10,060
所以，我们的计划是创建一个分布式游戏框架，

1550
01:20:10,060 --> 01:20:12,700
这也是容错的，

1551
01:20:12,940 --> 01:20:16,210
所以，不是将所有处理都放在中央服务器上，

1552
01:20:16,210 --> 01:20:20,410
我们将游戏逻辑处理分布到几个不同的工作服务器上，

1553
01:20:20,980 --> 01:20:22,030
但最重要的是，

1554
01:20:22,560 --> 01:20:23,880
为了实现容错，

1555
01:20:23,880 --> 01:20:26,340
当这些工作服务器中的一个出现故障时，

1556
01:20:26,370 --> 01:20:29,010
我们需要能够处理这种游戏逻辑，

1557
01:20:29,010 --> 01:20:32,550
并将玩家转移到其他一些工作服务器上，

1558
01:20:32,850 --> 01:20:34,470
所以，作为其中的一部分，

1559
01:20:34,470 --> 01:20:37,200
我们需要平衡延迟和容错，

1560
01:20:37,200 --> 01:20:40,050
因为如果我们让一切保持容错，

1561
01:20:40,170 --> 01:20:44,880
我们可能会遇到，每个移动需要很长时间才能处理。

1562
01:20:46,080 --> 01:20:47,820
这就是为什么我们要介绍 Pinguino ，

1563
01:20:48,060 --> 01:20:49,860
这是我们的容错游戏框架，

1564
01:20:49,860 --> 01:20:53,880
这解决了之前分布式网络的所有问题。

1565
01:20:59,160 --> 01:21:01,680
为了深入了解我们框架的系统，

1566
01:21:01,710 --> 01:21:03,690
让我们想象一下游戏俱乐部企鹅，

1567
01:21:04,050 --> 01:21:05,160
在企鹅俱乐部，

1568
01:21:05,190 --> 01:21:08,340
用户分配到一个房间或一个区域，

1569
01:21:08,580 --> 01:21:11,940
它只关心与其他用户交谈和互动，

1570
01:21:11,940 --> 01:21:14,610
以及那个房间里的物品，

1571
01:21:14,640 --> 01:21:16,170
他们不需要关心

1572
01:21:16,200 --> 01:21:17,940
在另一个房间里发生的任何其他事情，

1573
01:21:18,440 --> 01:21:20,210
所以，没有理由让

1574
01:21:20,510 --> 01:21:24,140
每个用户的请求都由一个集中的服务器处理，

1575
01:21:24,530 --> 01:21:25,910
所以，我们决定，

1576
01:21:25,910 --> 01:21:30,320
在多个工作进程中处理所有这些请求，

1577
01:21:30,470 --> 01:21:31,730
为了做到这一点，

1578
01:21:31,760 --> 01:21:34,550
我们有分配到不同地区的 worker ，

1579
01:21:34,550 --> 01:21:36,560
所以，如果玩家在一个地区，

1580
01:21:36,680 --> 01:21:40,280
他们可能正在与分配到那个区域的 worker 交谈，

1581
01:21:40,280 --> 01:21:41,510
例如，在这里，

1582
01:21:41,630 --> 01:21:43,070
企鹅在 worker 中，

1583
01:21:43,160 --> 01:21:45,320
它被分配给区域的 worker 2 ，

1584
01:21:45,320 --> 01:21:46,850
我们只和 worker 2 交互，

1585
01:21:46,940 --> 01:21:50,510
然后在 worker n 的会与 worker n 交互。

1586
01:21:51,210 --> 01:21:52,680
此外，我们还提到，

1587
01:21:52,680 --> 01:21:56,940
我们认为这不会影响 worker 和地区之间的关系，

1588
01:21:56,940 --> 01:21:59,100
不一定是一对一的映射，

1589
01:21:59,490 --> 01:22:02,760
对于一些可能不太受欢迎和流量较少的房间，

1590
01:22:02,790 --> 01:22:06,390
一个 worker 可能处理多个，

1591
01:22:06,510 --> 01:22:08,580
所以有这样一种关系，

1592
01:22:08,820 --> 01:22:09,960
我们需要追踪的。

1593
01:22:10,540 --> 01:22:12,040
所以，为了跟踪这一点，

1594
01:22:12,040 --> 01:22:13,870
我们确实需要一台中央服务器，

1595
01:22:13,870 --> 01:22:15,160
这就是 coordinator ，

1596
01:22:15,370 --> 01:22:18,250
所以， coordinator 将跟踪所有这些映射，

1597
01:22:18,580 --> 01:22:22,510
一些映射包括区域到 worker 的关系，

1598
01:22:22,540 --> 01:22:28,370
以及区域， worker 和它们的副本的关系，

1599
01:22:28,370 --> 01:22:30,650
以及玩家本身，

1600
01:22:30,860 --> 01:22:33,350
所处，在容错方面，

1601
01:22:33,380 --> 01:22:36,620
我们有，每个 worker 有两个复制，

1602
01:22:36,650 --> 01:22:39,440
[]将更多地谈论一下

1603
01:22:39,470 --> 01:22:42,350
哪种信息发送给 worker ，

1604
01:22:42,680 --> 01:22:45,050
到[]。

1605
01:22:45,610 --> 01:22:47,470
另外， coordinator ，

1606
01:22:47,470 --> 01:22:49,330
因为它是一台集中式服务器，

1607
01:22:49,330 --> 01:22:51,970
它也是一个可能的故障点，

1608
01:22:51,970 --> 01:22:53,590
所以我们有一个 coordinator 备份，

1609
01:22:53,650 --> 01:22:56,560
这里 coordinator 的主要角色是，

1610
01:22:56,560 --> 01:22:59,980
只是为了跟踪所有这些游戏状态的关系，

1611
01:23:00,100 --> 01:23:04,660
所以有关为这些关系更改的 coordinator 的信息

1612
01:23:04,690 --> 01:23:06,370
将被发送到 coordinator 备份，

1613
01:23:06,370 --> 01:23:10,270
在处理完成之前。

1614
01:23:10,690 --> 01:23:13,960
所以现在有了这个，虽然我们只有一台服务器，

1615
01:23:14,320 --> 01:23:16,990
游戏的大部分流量通常是

1616
01:23:16,990 --> 01:23:20,050
玩家进行移动并发送请求处理这些移动，

1617
01:23:20,170 --> 01:23:23,020
这些被分配给多个 worker ，

1618
01:23:23,020 --> 01:23:25,360
而 coordinator 负责映射，

1619
01:23:25,360 --> 01:23:28,900
并发送心跳，以确保 worker 存活，

1620
01:23:28,930 --> 01:23:31,270
可以处理任何故障情况。

1621
01:23:33,210 --> 01:23:35,640
是的，所以在 worker 倒下的情况下，

1622
01:23:35,730 --> 01:23:38,730
我们让协调员来处理重新分配

1623
01:23:38,730 --> 01:23:41,310
那个在 worker 的玩家，

1624
01:23:41,670 --> 01:23:44,880
并且因为 coordinator 仅管理区域映射，

1625
01:23:44,880 --> 01:23:47,550
对于我们来说，在不同地区之间移动也很容易

1626
01:23:47,550 --> 01:23:51,070
当比如一个 worker 超载时，

1627
01:23:51,070 --> 01:23:53,500
这允许我们执行一定的负载平衡，

1628
01:23:54,380 --> 01:23:55,460
正如我们之前提到的。

1629
01:23:56,400 --> 01:23:59,790
酷，所以我将继续开发者 API 是什么样子的，

1630
01:23:59,790 --> 01:24:02,550
因为我们想要的另一个关键功能是，

1631
01:24:02,580 --> 01:24:04,170
为了使框架易于使用，

1632
01:24:04,170 --> 01:24:07,290
对于试图在其中编写新游戏代码的开发人员来说，

1633
01:24:07,530 --> 01:24:10,200
所以，我们将游戏视为一个状态机，

1634
01:24:10,410 --> 01:24:12,720
所以玩家的任何移动，

1635
01:24:12,840 --> 01:24:15,060
属于两种不同类型的动作之一，

1636
01:24:15,330 --> 01:24:16,470
所以我之前提到过，

1637
01:24:16,470 --> 01:24:20,220
我们试图在延迟和容错之间取得平衡，

1638
01:24:20,520 --> 01:24:24,540
所以为了给开发者提供一种选择，

1639
01:24:24,540 --> 01:24:28,260
我们向开发人员开放了两个单独的命令，

1640
01:24:28,350 --> 01:24:30,120
第一个是 sendFastMove ，

1641
01:24:30,240 --> 01:24:32,550
所以，这个快速移动确保

1642
01:24:32,550 --> 01:24:34,890
移动尽快到达副本，

1643
01:24:34,890 --> 01:24:38,220
以便在 worker 上尽可能快地处理移动，

1644
01:24:39,090 --> 01:24:41,490
另一方面，我们有 sendStableMove ，

1645
01:24:41,580 --> 01:24:44,520
这是一个容错能力更强的移动，

1646
01:24:44,520 --> 01:24:46,200
我们向开发人员公开的，

1647
01:24:46,350 --> 01:24:47,580
这确保了，

1648
01:24:47,580 --> 01:24:50,850
这主要用于游戏关键逻辑改变，

1649
01:24:50,850 --> 01:24:52,200
例如交易，

1650
01:24:52,530 --> 01:24:54,540
所以如果你要买什么东西，你不想，

1651
01:24:55,090 --> 01:24:56,950
比如，如果你已经花了那笔钱，

1652
01:24:56,950 --> 01:24:57,760
你想确保，

1653
01:24:57,760 --> 01:25:00,730
你在游戏上花的钱都能得到，

1654
01:25:01,030 --> 01:25:03,790
所以我们保证，

1655
01:25:03,790 --> 01:25:07,660
如果移动得到完全处理，并在游戏中，

1656
01:25:07,870 --> 01:25:10,800
它存储在两个副本上，

1657
01:25:10,950 --> 01:25:14,460
这确保了如果与你交谈的 worker 倒下，

1658
01:25:14,460 --> 01:25:16,350
然后玩家被转移到新的 worker 那里，

1659
01:25:16,620 --> 01:25:19,110
新的 worker 将能够重建游戏，

1660
01:25:19,110 --> 01:25:20,490
包括那笔交易，

1661
01:25:20,670 --> 01:25:22,890
这一保证不是为快速移动而做的，

1662
01:25:22,890 --> 01:25:25,290
对延迟方面进行了优先排序，

1663
01:25:25,590 --> 01:25:26,940
但你也可以在这里看到，

1664
01:25:26,940 --> 01:25:31,560
开发人员定义的 Move 结构非常通用，

1665
01:25:31,560 --> 01:25:33,660
所以，在游戏中，

1666
01:25:33,810 --> 01:25:38,010
我们开发了一个我们框架的玩具演示，

1667
01:25:38,310 --> 01:25:40,380
这是一种聊天企鹅式的界面。

1668
01:25:40,580 --> 01:25:45,350
所以每个玩家在几个不同的房间里，

1669
01:25:45,650 --> 01:25:47,360
所以在每个房间里，

1670
01:25:47,360 --> 01:25:48,380
有一个聊天窗口，

1671
01:25:48,380 --> 01:25:51,230
你可以通过它与其他玩家交互，

1672
01:25:51,620 --> 01:25:53,450
所以两种主要的移动，

1673
01:25:53,450 --> 01:25:55,940
你可以在这个游戏中使用的是[]移动，

1674
01:25:56,030 --> 01:25:58,220
开发人员只需定义

1675
01:25:58,250 --> 01:26:01,400
移动玩家的 X Y 和 Username ，

1676
01:26:01,670 --> 01:26:04,070
所以 ChatMessage 是一种，

1677
01:26:04,070 --> 01:26:07,130
像你发送到窗口的聊天消息一样。

1678
01:26:07,760 --> 01:26:10,600
所以，在我们的游戏中，

1679
01:26:10,600 --> 01:26:13,180
我们让聊天消息成为一个稳定的移动，

1680
01:26:13,180 --> 01:26:14,950
像快速移动一样移动，

1681
01:26:15,160 --> 01:26:17,530
所以即使一个移动被放弃了，

1682
01:26:17,530 --> 01:26:18,040
也是可以的,

1683
01:26:18,040 --> 01:26:19,720
如果你是一种新的[]，

1684
01:26:19,750 --> 01:26:23,860
但是，我们不希望聊天消息随机消失，

1685
01:26:23,860 --> 01:26:25,420
因为它们可能是重要的信息。

1686
01:26:26,080 --> 01:26:28,690
到此为止，我将继续演示，

1687
01:26:28,720 --> 01:26:30,070
这只是一个小的 demo ，

1688
01:26:30,070 --> 01:26:32,380
但应该展示一下它的功能。

1689
01:26:40,500 --> 01:26:42,960
所以我们有极简的前端，

1690
01:26:44,690 --> 01:26:46,430
所以当我们绕着企鹅走的时候，

1691
01:26:46,430 --> 01:26:47,270
我们可以看到，

1692
01:26:47,270 --> 01:26:48,770
它首先发送快速移动，

1693
01:26:48,980 --> 01:26:53,630
发送给另一个副本的相同的移动，

1694
01:26:53,630 --> 01:26:54,710
分配给主要的 worker ，

1695
01:26:54,710 --> 01:26:56,120
所以现在，我们在 worker 0 ，

1696
01:26:56,300 --> 01:26:58,340
它被复制成 worker 1 和 worker 2 ，

1697
01:26:58,370 --> 01:26:59,480
所以我们有两份复制，

1698
01:26:59,870 --> 01:27:03,140
然后游戏服务器接收那个改变，

1699
01:27:03,140 --> 01:27:04,790
这样它们就可以在本地处理这些信息，

1700
01:27:05,300 --> 01:27:08,150
如果我们发送一条聊天消息，

1701
01:27:09,460 --> 01:27:11,890
我们还有玩家用户名，

1702
01:27:11,890 --> 01:27:13,600
用所发送的聊天消息标识，

1703
01:27:13,660 --> 01:27:15,610
但这是一个稳定的移动，

1704
01:27:15,790 --> 01:27:18,340
所以它在日志中是不可见的，

1705
01:27:18,340 --> 01:27:19,840
但稳定的移动要等到

1706
01:27:19,840 --> 01:27:23,170
这些移动真正复制到 worker 上，

1707
01:27:23,170 --> 01:27:24,280
在这里看起来并不容易，

1708
01:27:24,280 --> 01:27:27,820
因为通常情况下可能会有一些滞后，

1709
01:27:28,530 --> 01:27:31,320
但当我们在网络中引入一定数量的滞后时，

1710
01:27:31,350 --> 01:27:33,420
那个移动要花更长的时间，

1711
01:27:34,160 --> 01:27:38,630
现在移动到我们想要实现的一些未来工作中。

1712
01:27:44,060 --> 01:27:45,080
在后台方面，

1713
01:27:45,080 --> 01:27:47,480
我们还想做一件事是，

1714
01:27:47,480 --> 01:27:50,540
允许用户在不同的房间之间移动，

1715
01:27:50,660 --> 01:27:53,570
所以现在，当用户加入游戏时，

1716
01:27:53,570 --> 01:27:54,740
它会被初始化，

1717
01:27:54,740 --> 01:27:56,240
他们被分配到一个房间，

1718
01:27:56,300 --> 01:27:58,910
但理想情况下，如果他们想要移动到那里去，

1719
01:27:58,940 --> 01:28:00,590
如果他们想换个房间，

1720
01:28:00,620 --> 01:28:02,360
然后他们应该能够与 coordinator 交互，

1721
01:28:02,360 --> 01:28:05,030
嘿，我现在要去这个地区了，

1722
01:28:05,030 --> 01:28:08,390
你可以从那个区域加载游戏状态信息，

1723
01:28:08,390 --> 01:28:11,060
然后，现在我要开始和一个新的 worker 交互。

1724
01:28:11,620 --> 01:28:13,900
另外，我们早些时候也暗示过，

1725
01:28:14,200 --> 01:28:17,380
我们希望处理基于区域的 worker 负载平衡，

1726
01:28:17,470 --> 01:28:19,150
所以我们拥有它的原因是，

1727
01:28:19,180 --> 01:28:23,590
为什么我们不采用 worker 到地区的一对一映射，

1728
01:28:23,590 --> 01:28:26,320
是为了让这项未来的工作，

1729
01:28:26,320 --> 01:28:27,640
我们希望能够做到这一点，

1730
01:28:27,640 --> 01:28:32,890
控制每个 worker 将承担多少负载。

1731
01:28:44,260 --> 01:28:46,900
抱歉，我有个问题，

1732
01:28:46,960 --> 01:28:48,970
所以，你的，

1733
01:28:49,880 --> 01:28:54,170
同样，你有两个动作来发送消息和移动，

1734
01:28:54,200 --> 01:28:57,170
所以，这些动作都是原子的，

1735
01:28:57,260 --> 01:28:57,920
它们是不是。

1736
01:28:59,640 --> 01:29:01,170
是的。

1737
01:29:03,000 --> 01:29:04,230
它们会被按顺序处理，

1738
01:29:04,230 --> 01:29:06,120
因为它们是单独的移动，

1739
01:29:06,120 --> 01:29:10,260
大多数情况下，他们只修改一些变量，

1740
01:29:10,260 --> 01:29:12,810
它们在移动之前对这些变量加锁。

1741
01:29:16,350 --> 01:29:17,790
所以你之前说过，

1742
01:29:17,790 --> 01:29:20,700
你有一个 coordinator 和一个 coordinator 备份，

1743
01:29:20,880 --> 01:29:24,360
副本可以与它们中的任何一个交互，

1744
01:29:24,660 --> 01:29:27,810
如果你有一个网络分区，

1745
01:29:28,020 --> 01:29:31,260
分开 coordinator 和一些副本，

1746
01:29:31,380 --> 01:29:34,080
coordinator 备份和其他一些副本，

1747
01:29:37,900 --> 01:29:41,320
所以 coordinator 备份，在网络分区的情况下，

1748
01:29:41,560 --> 01:29:44,530
worker 会丢失 coordinator ，

1749
01:29:44,530 --> 01:29:48,880
worker 与 coordinator 或 coordinator 备份交互，

1750
01:29:48,880 --> 01:29:51,280
它们只能与 coordinator 交互，

1751
01:29:51,310 --> 01:29:52,990
如果 coordinator 倒下了，

1752
01:29:52,990 --> 01:29:57,040
然后备份被启动开始处理，

1753
01:29:57,070 --> 01:29:58,900
所以，在网络分区情况下，

1754
01:29:58,900 --> 01:30:00,550
我不认为我们会。

1755
01:30:00,930 --> 01:30:04,950
与 coordinator 分开的 worker

1756
01:30:05,010 --> 01:30:07,020
将无法处理，

1757
01:30:07,020 --> 01:30:09,810
与协调者本身，

1758
01:30:09,900 --> 01:30:11,580
结果发现在用户端，

1759
01:30:12,070 --> 01:30:13,150
它仍然可以被处理，

1760
01:30:13,150 --> 01:30:16,270
因为玩家只需要继续与那个 worker 交互，

1761
01:30:16,330 --> 01:30:18,940
如果这个区域有任何变化，

1762
01:30:19,270 --> 01:30:21,670
比如整个游戏的状态，

1763
01:30:21,700 --> 01:30:23,080
它还会被处理。

1764
01:30:23,500 --> 01:30:25,360
是的，另外我还想确认一下，

1765
01:30:25,570 --> 01:30:27,520
如果我们有一个分区，

1766
01:30:27,550 --> 01:30:29,710
coordinator 备份作为一个 coordinator ，

1767
01:30:29,710 --> 01:30:31,810
对于它可以交互的所有 worker ，

1768
01:30:31,990 --> 01:30:33,010
这很好，

1769
01:30:33,010 --> 01:30:36,430
因为我们希望游戏仍然在所有地区运行，

1770
01:30:36,430 --> 01:30:38,620
在 coordinator 备份正在交互的 worker 中，

1771
01:30:38,740 --> 01:30:40,510
这主要成了一个问题，

1772
01:30:40,510 --> 01:30:42,340
当它们重聚的时候，

1773
01:30:42,370 --> 01:30:48,520
在这种情况下， coordinator 备份获取其所有数据，

1774
01:30:48,520 --> 01:30:49,990
并且它可以将其发送给 coordinator ，

1775
01:30:49,990 --> 01:30:51,880
coordinator 可以本地解决该问题，

1776
01:30:51,910 --> 01:30:55,720
因为有一种原始 coordinator 和 coordinator 备份，

1777
01:30:55,720 --> 01:30:59,410
它们知道 coordinator 备份，

1778
01:30:59,440 --> 01:31:00,700
因为它是本地储存的。

1779
01:31:02,330 --> 01:31:05,690
但是如果 coordinator 备份称为 coordinator ，

1780
01:31:05,720 --> 01:31:07,040
那不是，

1781
01:31:07,280 --> 01:31:09,800
例如说，哦，我需要确保，

1782
01:31:09,800 --> 01:31:13,610
我们有活跃的复制对所有的房间，

1783
01:31:13,610 --> 01:31:16,190
它们位于分区的另一边，

1784
01:31:16,250 --> 01:31:19,370
你不会在两边分区都有相同的房间，

1785
01:31:19,370 --> 01:31:20,810
并且会发散。

1786
01:31:23,820 --> 01:31:28,560
不，因为每个房间只属于一个 worker ，

1787
01:31:28,830 --> 01:31:30,210
所以，比如，

1788
01:31:30,920 --> 01:31:34,220
所以我想，每个房间，比如不能，

1789
01:31:34,960 --> 01:31:37,840
比如房间的副本会被放弃，

1790
01:31:37,840 --> 01:31:39,250
所以从本质上讲，发生的是，

1791
01:31:39,250 --> 01:31:40,420
如果一个 worker ，

1792
01:31:40,600 --> 01:31:41,860
在分区的情况下，

1793
01:31:41,860 --> 01:31:44,980
coordinator 无法访问另一个分区中的 worker ，

1794
01:31:45,130 --> 01:31:46,810
所以发生的事情是，

1795
01:31:47,290 --> 01:31:49,930
我觉得它们把副本移动，

1796
01:31:50,220 --> 01:31:53,760
但因为玩家也不能联系 worker ，

1797
01:31:54,590 --> 01:31:56,510
所有移动都不会被处理，

1798
01:31:56,570 --> 01:32:01,910
因此在分区修复之后，较新的副本将被优先处理，

1799
01:32:01,910 --> 01:32:03,140
在修复那个网络的时候。

1800
01:32:08,590 --> 01:32:12,280
你为什么决定使用带有 Move 的 API

1801
01:32:12,310 --> 01:32:14,380
以及发出一条信息？

1802
01:32:16,330 --> 01:32:19,660
所以针对这个 API ，

1803
01:32:19,690 --> 01:32:22,510
我们想要两种不同类型的移动，

1804
01:32:22,510 --> 01:32:23,590
两种截然不同的移动，

1805
01:32:23,860 --> 01:32:26,980
一个是快速移动，一个是稳定移动，

1806
01:32:26,980 --> 01:32:30,850
理想情况下，稳定移动使用很少，

1807
01:32:30,850 --> 01:32:32,590
并更多地用于交易，

1808
01:32:32,590 --> 01:32:34,630
在那里花更长的时间是可以的，

1809
01:32:34,630 --> 01:32:36,850
我们不想被丢弃，

1810
01:32:37,090 --> 01:32:41,200
在一个简单的前端复制它的最简单的方法是通过聊天消息，

1811
01:32:41,650 --> 01:32:42,610
所以这有点武断，

1812
01:32:43,670 --> 01:32:45,170
移动当然应该是快的，

1813
01:32:45,170 --> 01:32:48,380
因为我们不想，

1814
01:32:48,380 --> 01:32:49,760
因为玩家经常移动。

1815
01:32:52,390 --> 01:32:53,200
谢谢。

1816
01:32:59,650 --> 01:33:00,700
太棒了，非常感谢，

1817
01:33:00,730 --> 01:33:02,500
演讲到此结束，

1818
01:33:02,500 --> 01:33:03,190
大家都干得很好，

1819
01:33:03,190 --> 01:33:04,450
这真是激动人心。

1820
01:33:05,800 --> 01:33:10,330
我还有一个关于[]演示的问题，如果可能的话。

1821
01:33:10,820 --> 01:33:11,750
好的，继续。

1822
01:33:12,420 --> 01:33:14,040
所以对于领导者来说，

1823
01:33:14,070 --> 01:33:17,490
抱歉，对于分布式选举系统，

1824
01:33:19,680 --> 01:33:22,110
我对密码学不是很熟悉，

1825
01:33:22,110 --> 01:33:28,230
但我想系统对所有选举结果相加，

1826
01:33:28,590 --> 01:33:31,080
在一个投票器服务器上，

1827
01:33:31,680 --> 01:33:34,110
这个不是那个[]团队袭击，

1828
01:33:34,110 --> 01:33:36,480
例如，如果我有两台服务器，

1829
01:33:36,480 --> 01:33:39,750
然后我在两台服务器上投票给不同的人，

1830
01:33:39,750 --> 01:33:41,850
但之后我会和其他人协调，

1831
01:33:42,000 --> 01:33:44,520
以另一种方式投票，

1832
01:33:44,610 --> 01:33:47,100
最终将获得相同的投票因素，

1833
01:33:47,550 --> 01:33:50,460
但我会恶意地认为它反对，

1834
01:33:50,460 --> 01:33:55,420
我想这种情况下，不会改变投票结果，

1835
01:33:55,420 --> 01:33:56,830
或者选举结果，

1836
01:33:56,830 --> 01:33:59,350
但我想我的行为是错误的，

1837
01:33:59,350 --> 01:34:03,310
所以，是否有检查以确保每个服务器上的每个人都正确投票。

1838
01:34:03,860 --> 01:34:05,930
是的。

1839
01:34:07,430 --> 01:34:11,840
抱歉，我们实际上不处理恶意投票，

1840
01:34:11,840 --> 01:34:14,420
这是一件很大的事情，

1841
01:34:14,870 --> 01:34:19,640
对于现实世界的投票系统来说，非常重要，

1842
01:34:20,130 --> 01:34:25,950
但是，我想我们的项目的范围，

1843
01:34:25,950 --> 01:34:26,940
我们出发了，

1844
01:34:27,210 --> 01:34:30,630
它有点太复杂了，

1845
01:34:31,090 --> 01:34:33,850
所以我们，是的。

1846
01:34:33,880 --> 01:34:37,540
我认为我们更关注分布式系统部分，

1847
01:34:37,600 --> 01:34:40,360
但如果我们想提供更多的安全保障，

1848
01:34:40,360 --> 01:34:41,470
比如为了安全，

1849
01:34:41,800 --> 01:34:44,320
使用一个我们认为的想法，

1850
01:34:44,320 --> 01:34:46,390
但后来决定不这样做，

1851
01:34:46,390 --> 01:34:48,220
我有一个公共账本，

1852
01:34:48,220 --> 01:34:51,220
你可以在那里给我们知识证明，

1853
01:34:51,220 --> 01:34:54,340
你发的帖子加起来，

1854
01:34:54,340 --> 01:34:56,080
这就是你所说的，

1855
01:34:56,080 --> 01:34:59,800
想到这些事情来处理恶意参与者。

1856
01:35:02,170 --> 01:35:03,340
好的。

1857
01:35:03,550 --> 01:35:05,170
所以我们有点晚了，

1858
01:35:05,170 --> 01:35:07,540
原则上，在课程中，

1859
01:35:07,540 --> 01:35:09,130
如果有人想提问，

1860
01:35:09,130 --> 01:35:10,120
可以随意留下来，

1861
01:35:10,390 --> 01:35:12,280
我想说一两件事，

1862
01:35:12,280 --> 01:35:14,530
在最后一节课结束之前，

1863
01:35:14,890 --> 01:35:17,530
首先，我想感谢你们的参与，

1864
01:35:17,530 --> 01:35:19,360
即使又是一个 covid 学期，

1865
01:35:19,540 --> 01:35:21,220
我觉得我已经和你们中的许多人互动过了，

1866
01:35:21,220 --> 01:35:24,400
通过电子邮件，我们间接地，

1867
01:35:24,400 --> 01:35:25,900
并交换大量的信息，

1868
01:35:25,900 --> 01:35:27,820
我也很想在某个时候见到你本人，

1869
01:35:28,270 --> 01:35:29,770
真正知道你是谁，

1870
01:35:29,980 --> 01:35:33,940
但是，我很感谢大家的参与。

1871
01:35:34,410 --> 01:35:36,150
第二件事，是我想感谢助教，

1872
01:35:36,180 --> 01:35:39,270
这是很棒的助教，

1873
01:35:39,270 --> 01:35:42,360
你可能意识到，可能对很多人来说，

1874
01:35:42,360 --> 01:35:43,650
他们找出了一些 bug ，

1875
01:35:43,680 --> 01:35:45,390
帮你通过实验，

1876
01:35:46,260 --> 01:35:49,740
所以我为助教们鼓掌，

1877
01:35:50,250 --> 01:35:53,400
非常幸运，有这样的品质。

1878
01:35:54,460 --> 01:35:57,280
我想我要说的最后一句话，

1879
01:35:57,280 --> 01:35:58,060
我想祝你在期末考试中好运，

1880
01:35:58,630 --> 01:36:01,210
希望不会太糟，

1881
01:36:01,210 --> 01:36:04,540
我希望你在 6.824 学到了一些东西，

1882
01:36:04,540 --> 01:36:06,130
并同时享受它。

1883
01:36:07,320 --> 01:36:08,460
任何想留下来的人，

1884
01:36:08,460 --> 01:36:09,270
请留下来，

1885
01:36:09,270 --> 01:36:13,230
你想问不同团队更多的问题，

1886
01:36:13,230 --> 01:36:15,930
如果这团队还在，就很好，

1887
01:36:15,930 --> 01:36:17,580
否则，这就结束了，

1888
01:36:17,970 --> 01:36:19,980
至少 6.824 的课程。

1889
01:36:20,950 --> 01:36:21,640
谢谢大家。

1890
01:36:24,180 --> 01:36:24,900
谢谢。

1891
01:36:25,080 --> 01:36:26,550
非常感谢。

1892
01:36:26,550 --> 01:36:27,090
谢谢。

1893
01:36:27,270 --> 01:36:28,170
谢谢。

1894
01:36:28,530 --> 01:36:29,700
非常感谢。

1895
01:36:40,260 --> 01:36:41,850
抱歉，我有个小问题。

1896
01:36:42,180 --> 01:36:43,350
好的。

1897
01:36:43,380 --> 01:36:47,220
现在是最后一个问题了，

1898
01:36:48,480 --> 01:36:53,880
哦，我在想考试的后勤，

1899
01:36:54,630 --> 01:36:56,970
我给你发了电子邮件。

1900
01:36:57,000 --> 01:37:00,600
是的，我们还没到那个时间点，

1901
01:37:00,600 --> 01:37:02,430
我们正在处理考试的后勤。

1902
01:37:02,460 --> 01:37:02,910
好的。

1903
01:37:03,000 --> 01:37:07,440
一对，两、三个。

1904
01:37:07,530 --> 01:37:11,070
我们有计划，我们还没有执行，

1905
01:37:11,070 --> 01:37:12,690
不会分享任何细节。

1906
01:37:13,340 --> 01:37:13,910
好的。

1907
01:37:14,060 --> 01:37:14,810
但这是会发生的。

1908
01:37:15,260 --> 01:37:16,730
听起来不错。

1909
01:37:16,970 --> 01:37:20,030
你不需要我，确保在聊天中。

1910
01:37:20,030 --> 01:37:25,040
好的，太好了，

1911
01:37:25,040 --> 01:37:26,750
非常感谢你所做的一切，

1912
01:37:26,780 --> 01:37:28,970
对于班级和助教。

1913
01:37:30,740 --> 01:37:33,970
非常感谢你的所有课程，

1914
01:37:33,970 --> 01:37:37,530
非常有趣，我学到了很多。

1915
01:37:38,060 --> 01:37:39,860
谢谢你们，感谢你们的参与，

1916
01:37:40,100 --> 01:37:41,180
提出了所有这些问题，

1917
01:37:41,300 --> 01:37:41,870
我很感激。

1918
01:37:44,080 --> 01:37:44,620
好的，谢谢,

1919
01:37:44,620 --> 01:37:45,790
这是一门很棒的课，

1920
01:37:45,790 --> 01:37:46,540
我真的很感激。

1921
01:37:47,860 --> 01:37:50,710
上课时一切都很活跃。

1922
01:37:53,920 --> 01:37:55,840
好的，我想那可能是，

1923
01:37:55,870 --> 01:37:59,440
所以我想我们停止录制。

