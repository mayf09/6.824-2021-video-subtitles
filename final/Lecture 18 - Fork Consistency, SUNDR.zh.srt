1
00:00:01,290 --> 00:00:05,680
好的，下午好，大家能听到我说话吗？

2
00:00:08,160 --> 00:00:08,820
是的。

3
00:00:09,130 --> 00:00:10,090
好的，谢谢，

4
00:00:10,360 --> 00:00:13,390
是的，我会在课程结束后贴上讲稿，

5
00:00:14,320 --> 00:00:18,240
作为对聊天的回应。

6
00:00:18,330 --> 00:00:27,400
好的，今天我想在 6.824 开始一个新的话题，

7
00:00:27,580 --> 00:00:31,270
这是最后一个要讨论的话题，

8
00:00:31,510 --> 00:00:33,790
主题是去中心化的系统。

9
00:00:45,490 --> 00:00:49,360
去中心化指的是，

10
00:00:49,360 --> 00:00:53,590
没有单一的权威机构来控制这个系统，

11
00:00:54,320 --> 00:00:56,750
到目前为止，我们看到了很多系统，

12
00:00:56,930 --> 00:00:59,870
所有的机器和服务器都在某种程度上合作，

13
00:01:00,110 --> 00:01:05,030
在单一机构或任何单一当局的控制下。

14
00:01:05,850 --> 00:01:09,030
因为有很多人提问，

15
00:01:09,030 --> 00:01:10,500
关于它是如何工作的，

16
00:01:10,500 --> 00:01:13,920
如果没有中心信任点的话。

17
00:01:14,770 --> 00:01:18,290
所以，从现在开始，

18
00:01:18,290 --> 00:01:20,720
三个系统或三个论文要讨论，

19
00:01:20,720 --> 00:01:23,210
都是以这种去中心化系统的形式存在的，

20
00:01:23,420 --> 00:01:27,860
去中心化的系统更难建立，

21
00:01:27,890 --> 00:01:30,230
比单一信任系统，

22
00:01:30,650 --> 00:01:34,910
因为你可能不得不解释拜占庭失败

23
00:01:34,910 --> 00:01:36,920
或拜占庭参与者，

24
00:01:45,540 --> 00:01:48,810
这些参与者有时会遵守协议，

25
00:01:48,810 --> 00:01:50,370
有时他们不遵守协议，

26
00:01:50,970 --> 00:01:52,890
所以再一次考虑这个，

27
00:01:52,890 --> 00:01:54,540
他们基本上是对手，

28
00:01:54,780 --> 00:02:02,820
他们可能会试图伤害或欺骗系统中的其他参与者，

29
00:02:02,820 --> 00:02:03,840
为了自己的财产，

30
00:02:03,840 --> 00:02:05,220
但可能不是为了其他人。

31
00:02:05,800 --> 00:02:10,930
所以，这使系统设计，

32
00:02:10,930 --> 00:02:13,630
分布式系统设计更具挑战性，

33
00:02:13,660 --> 00:02:15,610
更难理解，

34
00:02:16,030 --> 00:02:19,510
在过去的 18 节课中，

35
00:02:19,720 --> 00:02:22,300
大多数时候，当我们谈到，

36
00:02:22,300 --> 00:02:24,520
当我们设计协议或我们考虑 Raft ，

37
00:02:24,730 --> 00:02:25,900
我们只是假设

38
00:02:25,900 --> 00:02:29,950
协议中的每个参与者都遵守规则，

39
00:02:30,400 --> 00:02:33,160
在拜占庭和拜占庭参与者之间，

40
00:02:33,160 --> 00:02:34,480
情况不再是这样了，

41
00:02:35,440 --> 00:02:37,840
参与者可以编造新的消息，

42
00:02:37,840 --> 00:02:39,580
发送无序的消息，

43
00:02:39,580 --> 00:02:42,010
欺骗其他参与者，

44
00:02:42,310 --> 00:02:46,930
所以，我们考虑这类协议要困难得多，

45
00:02:46,990 --> 00:02:51,150
因为我们必须考虑对手能做什么，

46
00:02:51,210 --> 00:02:53,430
来创建[]，

47
00:02:54,010 --> 00:02:57,400
打破我们所追求的协议的属性，

48
00:02:58,000 --> 00:03:00,610
所以，这会使问题变得更加困难。

49
00:03:03,790 --> 00:03:08,140
这类话题在哪里，

50
00:03:08,140 --> 00:03:11,860
它位于分布式系统和安全性的交汇点上。

51
00:03:16,120 --> 00:03:20,740
正如我们将在接下来的三篇论文中看到的，

52
00:03:21,160 --> 00:03:24,970
密码学或安全理念，比如签名和哈希，

53
00:03:24,970 --> 00:03:29,680
在取得进展方面发挥了关键作用。

54
00:03:31,140 --> 00:03:34,320
事实上，我们今天读的这篇论文也是，

55
00:03:34,320 --> 00:03:37,500
是我们在 6.858 中使用的一篇论文，

56
00:03:38,250 --> 00:03:41,400
去年春天，参加了 6.858 ，

57
00:03:41,580 --> 00:03:44,040
我们也谈到了这篇论文，

58
00:03:44,040 --> 00:03:46,800
尽管主要是从安全的角度，

59
00:03:46,890 --> 00:03:49,380
今天，我将主要集中在

60
00:03:49,380 --> 00:03:52,500
分布式系统的角度，

61
00:03:53,100 --> 00:03:58,290
很多人都会问 SUNDR 本身，

62
00:03:58,320 --> 00:04:02,520
你们中的许多人问 SUNDR 在使用吗，

63
00:04:02,520 --> 00:04:04,230
据我所知，

64
00:04:04,230 --> 00:04:08,700
没有任何系统直接实现 SUNDR ，

65
00:04:08,700 --> 00:04:10,650
或者直接基于 SUNDR ，

66
00:04:10,740 --> 00:04:14,760
除了 6.858 中的实验 4 ，

67
00:04:14,820 --> 00:04:20,670
在实验 4 中，如果你做实验 4 ，默认项目，

68
00:04:20,670 --> 00:04:22,050
实验 4 在 6.858 ，

69
00:04:22,170 --> 00:04:24,840
然后，你实现了 SUNDR 。

70
00:04:26,000 --> 00:04:32,090
现在，所以你可能会想我们为什么要研究这篇论文，

71
00:04:32,270 --> 00:04:33,350
我们之所以要研究它，

72
00:04:33,350 --> 00:04:34,820
因为它提出了一些

73
00:04:34,820 --> 00:04:37,040
非常强大的技术或强大的想法，

74
00:04:40,400 --> 00:04:42,860
特别是 signed log ，

75
00:04:43,640 --> 00:04:47,720
尽管这是一个很强的设计，概念设计，

76
00:04:47,990 --> 00:04:50,000
令人难以置信的强大，

77
00:04:50,180 --> 00:04:51,800
你可以看到，

78
00:04:51,830 --> 00:04:55,610
同样的想法也出现在许多其他去中心化的系统中，

79
00:04:55,880 --> 00:05:01,280
从 Git 这样的系统到比特币这样的系统，

80
00:05:01,280 --> 00:05:03,530
或任何其他类型的加密账本，

81
00:05:03,770 --> 00:05:07,430
我们会在周一或下周二讨论，

82
00:05:07,610 --> 00:05:13,880
我知道有一个系统直接受到 SUNDR 的影响，

83
00:05:13,880 --> 00:05:15,650
是一个被称为 Keybase 的系统，

84
00:05:16,430 --> 00:05:20,090
Keybase 使用了 SUNDR 的技术，

85
00:05:20,090 --> 00:05:22,190
还有更多的，

86
00:05:22,190 --> 00:05:23,990
如果你不熟悉 Keybase ，

87
00:05:23,990 --> 00:05:26,870
[最初]被 Zoom 收购，

88
00:05:27,500 --> 00:05:29,630
是大家都很熟悉的。

89
00:05:32,180 --> 00:05:36,950
好了，这是这篇论文的简短介绍，

90
00:05:37,040 --> 00:05:39,230
在我深入到更多背景之前，

91
00:05:39,230 --> 00:05:40,700
有任何的问题，

92
00:05:40,700 --> 00:05:44,060
在深入到论文之前。

93
00:05:50,710 --> 00:05:52,360
好的。

94
00:05:52,950 --> 00:05:56,310
所以，让我们来谈谈这篇论文的背景

95
00:05:56,310 --> 00:05:59,670
或者这篇论文的动机。

96
00:05:59,670 --> 00:06:03,720
所以设置，

97
00:06:03,720 --> 00:06:07,050
[]的设置是网络文件系统，

98
00:06:11,240 --> 00:06:14,270
你可以虑这个，

99
00:06:14,270 --> 00:06:19,250
以我们之前读过的 Frangipani 论文的风格，

100
00:06:19,430 --> 00:06:24,170
其中的主题也是实现一致的网络文件系统。

101
00:06:25,070 --> 00:06:27,590
所以我们有一台文件服务器，

102
00:06:30,770 --> 00:06:33,770
我们有与文件服务器交互的客户端，

103
00:06:34,850 --> 00:06:37,280
有些人可能创建了一个文件 f ，

104
00:06:39,470 --> 00:06:43,220
可能在另一个客户端上读取 f 。

105
00:06:45,860 --> 00:06:49,520
我们所处的环境，

106
00:06:49,520 --> 00:06:54,950
文件服务器对比 Frangipani ，

107
00:06:55,100 --> 00:06:57,950
文件服务器可以是拜占庭式的。

108
00:07:02,790 --> 00:07:07,290
拜占庭增加了非常强大的威胁模型，

109
00:07:07,290 --> 00:07:10,560
或者给了攻击者难以置信的力量。

110
00:07:10,920 --> 00:07:16,140
所以在拜占庭中，服务器可能会发回不同的 RPC ，

111
00:07:16,140 --> 00:07:25,470
编造自己的 RPC ，接管机器，

112
00:07:25,470 --> 00:07:27,240
[贿赂]管理员，

113
00:07:27,240 --> 00:07:30,810
所有事情考虑的方式，

114
00:07:31,110 --> 00:07:34,290
对手获得文件服务器的完全控制权。

115
00:07:36,130 --> 00:07:39,670
所以，这涵盖了一系列

116
00:07:39,700 --> 00:07:42,010
更常见的攻击，

117
00:07:42,010 --> 00:07:45,010
或者你可能在真实系统中看到的典型攻击，

118
00:07:45,010 --> 00:07:47,890
所以攻击了软件中的一个漏洞，

119
00:07:51,920 --> 00:07:54,680
如果软件中有漏洞，

120
00:07:54,680 --> 00:07:56,630
那么对手可以利用，

121
00:07:56,630 --> 00:08:00,920
可能获得特权，

122
00:08:00,920 --> 00:08:05,270
而拜占庭模式完全通过，

123
00:08:05,270 --> 00:08:14,750
或者系统管理员可能有一个弱密码，

124
00:08:16,460 --> 00:08:20,540
如果攻击者[]，然后他们控制了系统，

125
00:08:20,540 --> 00:08:23,780
这也在拜占庭式的物理突破之中，

126
00:08:28,150 --> 00:08:32,500
也许的攻击者可以进入物理机器，

127
00:08:32,770 --> 00:08:38,200
因此可以控制机器的物理部分，

128
00:08:38,290 --> 00:08:41,320
这些都涵盖在拜占庭威胁模型中，

129
00:08:41,710 --> 00:08:51,690
或者甚至攻击者贿赂操作者，

130
00:08:54,540 --> 00:08:59,760
或者与恶意客户端勾结，

131
00:08:59,760 --> 00:09:01,710
这也涵盖在这个模型中，

132
00:09:01,770 --> 00:09:02,910
这是一个威胁模型，

133
00:09:02,910 --> 00:09:07,290
给了对手很大的权力，

134
00:09:08,060 --> 00:09:09,920
它涵盖了许多标准攻击。

135
00:09:10,400 --> 00:09:13,940
首先观察到的是，

136
00:09:13,940 --> 00:09:20,570
再一次， SUNDR 是这样的，

137
00:09:20,660 --> 00:09:22,610
实际上不是

138
00:09:22,610 --> 00:09:25,970
在文件服务器上维护整个文件系统，

139
00:09:25,970 --> 00:09:28,190
文件服务器尽可能简单，

140
00:09:28,670 --> 00:09:32,690
文件服务器非常类似于 Pedal ，

141
00:09:32,930 --> 00:09:35,600
它几乎就像一个块设备。

142
00:09:39,120 --> 00:09:42,180
所以有一个中央位置，所有块都存储在那里，

143
00:09:43,200 --> 00:09:47,040
但是客户端真正实现了文件系统，

144
00:09:47,040 --> 00:09:51,930
所以它不是客户端发送、创建文件，

145
00:09:52,360 --> 00:09:57,260
从数据块服务器发送数据块和读取数据块，

146
00:09:57,530 --> 00:10:02,330
通过读或写来构建数据块，

147
00:10:02,330 --> 00:10:04,550
它自己对文件系统的看法，

148
00:10:04,550 --> 00:10:07,130
并服务于文件系统操作，

149
00:10:07,130 --> 00:10:08,750
直接对于客户端，

150
00:10:08,990 --> 00:10:15,200
所以在这里，我们创建 f ，读取 f 等。

151
00:10:16,430 --> 00:10:18,860
所以非常类似于 Frangipani ，

152
00:10:19,280 --> 00:10:21,770
除了 Frangipani 最大的不同之处在于，

153
00:10:21,770 --> 00:10:24,200
Pedal 和所有客户端是完全信任的，

154
00:10:24,530 --> 00:10:25,850
在这种情况下，

155
00:10:26,030 --> 00:10:27,470
客户端不受信任，

156
00:10:27,680 --> 00:10:29,750
而文件服务器，

157
00:10:29,750 --> 00:10:33,380
它也可以是不可信的。

158
00:10:34,140 --> 00:10:34,680
好的?

159
00:10:41,410 --> 00:10:46,690
好的，所以这篇论文集中在一些安全属性上，

160
00:10:46,930 --> 00:10:51,160
重点是，

161
00:10:54,660 --> 00:10:57,840
重点是所谓的完整性属性，

162
00:11:00,550 --> 00:11:02,950
与保密性相反，

163
00:11:03,040 --> 00:11:05,590
保密性关于保护数据，

164
00:11:05,590 --> 00:11:06,850
让别人看不到它，

165
00:11:07,150 --> 00:11:11,770
完整性只是确保系统结构是正确的，

166
00:11:11,770 --> 00:11:16,660
对数据非法修改被检测到，

167
00:11:16,750 --> 00:11:18,460
无论数据是否公开，

168
00:11:18,460 --> 00:11:20,590
这有点超出了这里的重点。

169
00:11:21,330 --> 00:11:23,670
说得更具体一点，

170
00:11:23,670 --> 00:11:27,450
在我们的脑海中发生的事情是，

171
00:11:27,450 --> 00:11:29,580
我们有开发人员，

172
00:11:32,410 --> 00:11:36,310
我们有 dev1 ， dev2 ，

173
00:11:36,730 --> 00:11:39,820
他们可能会共用一些机器，

174
00:11:39,850 --> 00:11:45,760
包含某个项目的源代码库，

175
00:11:45,760 --> 00:11:48,700
开发人员为这个项目进行合作，

176
00:11:49,090 --> 00:11:53,860
所以把这个当作一个例子，

177
00:11:53,860 --> 00:11:55,000
论文提到的是，

178
00:11:55,000 --> 00:11:58,210
在论文中，这个是开发机器，

179
00:11:58,210 --> 00:12:01,390
是一个 Debian Linux 服务器，

180
00:12:02,500 --> 00:12:07,150
他们想要防御的是后门，

181
00:12:07,420 --> 00:12:13,280
后门，软件中的后门。

182
00:12:16,890 --> 00:12:22,170
所以攻击者接管了控制权，

183
00:12:22,170 --> 00:12:25,800
侵入包含源代码库的机器，

184
00:12:25,830 --> 00:12:28,680
修改软件，

185
00:12:28,920 --> 00:12:31,710
然后软件部署出来，

186
00:12:31,740 --> 00:12:34,560
例如， Debian Linux 被部署到很多机器上，

187
00:12:34,980 --> 00:12:40,560
现在攻击者控制了这些机器，

188
00:12:40,590 --> 00:12:42,570
因为它会利用这个后门。

189
00:12:43,210 --> 00:12:46,330
论文谈到了这个攻击，

190
00:12:46,360 --> 00:12:50,470
2003 年 Debian Linux 的这个特定实例，

191
00:12:50,590 --> 00:12:55,660
攻击能够危害

192
00:12:55,660 --> 00:12:58,750
开发服务器或集群，

193
00:12:59,110 --> 00:13:02,830
从这种攻击中恢复非常痛苦，

194
00:13:02,920 --> 00:13:05,530
事实上，在 2003 年，他们报告说，

195
00:13:05,530 --> 00:13:09,790
Debian Linux 开发冻结了几天，

196
00:13:09,790 --> 00:13:11,560
当他们试图找出

197
00:13:11,830 --> 00:13:15,070
源代码库中的哪些部分仍然是正确的，

198
00:13:15,070 --> 00:13:17,680
以及哪些部分被攻击者修改了，

199
00:13:18,250 --> 00:13:20,770
这些攻击会周期性地发生，

200
00:13:20,770 --> 00:13:22,540
我想在去年，

201
00:13:22,540 --> 00:13:27,700
Ubuntu 在 2018 年或 2019 年也有类似的问题，

202
00:13:27,700 --> 00:13:28,840
我记不清了，

203
00:13:29,020 --> 00:13:30,580
这是一个类似的案例，

204
00:13:30,580 --> 00:13:36,790
其中一台核心开发服务器被入侵，

205
00:13:37,440 --> 00:13:39,480
他们必须解决，

206
00:13:39,720 --> 00:13:45,420
查找哪些软件哪些文件被感染，

207
00:13:45,420 --> 00:13:46,980
受到入侵的影响。

208
00:13:48,510 --> 00:13:52,710
好的，这就是论文的背景，

209
00:13:52,710 --> 00:13:54,690
我要说得更具体一点，

210
00:13:54,720 --> 00:13:56,460
一个小例子，

211
00:13:56,550 --> 00:13:59,940
为了帮助我们通过技术，

212
00:13:59,940 --> 00:14:01,470
这篇论文所使用的。

213
00:14:03,420 --> 00:14:06,240
所以我要用的例子，

214
00:14:06,810 --> 00:14:10,260
部分灵感来自 6.858 ，

215
00:14:10,440 --> 00:14:14,220
假设我们有一个文件系统，

216
00:14:14,760 --> 00:14:17,700
你在做，

217
00:14:18,880 --> 00:14:20,290
文件系统包含

218
00:14:20,290 --> 00:14:26,950
使用 6.858 zoobar 应用程序的源代码，

219
00:14:26,950 --> 00:14:32,110
而 zoobar 是一个虚拟银行类型的应用程序，

220
00:14:32,110 --> 00:14:34,990
系统的用户，

221
00:14:35,020 --> 00:14:38,650
系统的注册用户可以相互转移 zoobar ，

222
00:14:39,100 --> 00:14:44,800
它有一个名为 auth.py 的文件，进行身份验证，

223
00:14:45,220 --> 00:14:49,930
有一个影响银行的文件， bank.py 。

224
00:14:51,170 --> 00:14:55,550
所以，让我们考虑这样的情况，

225
00:14:55,550 --> 00:14:58,970
有一组新的开发人员， A B C ，

226
00:14:59,240 --> 00:15:05,060
他们决定增加 zoobar 的可用性，

227
00:15:05,210 --> 00:15:08,360
真正地部署，使其成为现实，

228
00:15:08,360 --> 00:15:11,300
他们决定按如下方式划分工作，

229
00:15:11,480 --> 00:15:17,260
A 将修改 auth.py

230
00:15:20,560 --> 00:15:27,020
以支持 MIT 证书，

231
00:15:28,630 --> 00:15:31,090
kerberos ticket 或证书，

232
00:15:31,360 --> 00:15:33,910
有了这个想法，

233
00:15:33,910 --> 00:15:35,050
我们要做的是，

234
00:15:36,220 --> 00:15:39,040
我们将修改 auth.py ，

235
00:15:39,040 --> 00:15:43,420
只有合法的 MIT 社区成员

236
00:15:43,420 --> 00:15:45,280
才能登录到文件服务器，

237
00:15:45,520 --> 00:15:47,530
文件服务器或到 zoobar 中，

238
00:15:47,590 --> 00:15:50,350
我们知道它到底是谁，

239
00:15:50,410 --> 00:15:53,320
与特定的 MIT 证书相关联。

240
00:15:53,920 --> 00:15:55,930
然后为了让它变得更有用一点，

241
00:15:55,930 --> 00:15:58,150
B 可以修改 bank.py ，

242
00:15:58,150 --> 00:16:04,760
将它链接到 TechCash 的 cash 标记。

243
00:16:06,380 --> 00:16:09,200
所以，这个想法，

244
00:16:09,200 --> 00:16:12,620
我们可以使用 zoobar 系统来做到这个，

245
00:16:12,620 --> 00:16:16,700
比如我们可以使用 zoobar 系统来转账，

246
00:16:16,700 --> 00:16:19,160
真正的钱，而不是 zoobar ，

247
00:16:19,220 --> 00:16:24,710
在该服务器注册的用户之间，

248
00:16:25,040 --> 00:16:26,750
当然，这听起来像是一个疯狂的想法，

249
00:16:26,750 --> 00:16:27,740
你并不会真的这么做，

250
00:16:27,740 --> 00:16:29,960
但这并不是完全荒谬的，

251
00:16:29,960 --> 00:16:34,190
因为 auth.py 会检查是谁，

252
00:16:34,310 --> 00:16:36,170
基于 MIT 证书，

253
00:16:36,470 --> 00:16:38,660
也许这不是不合理，

254
00:16:38,660 --> 00:16:41,990
我们可以将 bank.py 连接到 TechCash 。

255
00:16:43,750 --> 00:16:48,250
在我们的场景中， C 是那个人，

256
00:16:48,250 --> 00:16:49,870
将会部署软件，

257
00:16:53,880 --> 00:16:57,030
寻找机器，安装软件，运行软件，

258
00:16:57,390 --> 00:17:00,330
它向 MIT 社区开放。

259
00:17:00,860 --> 00:17:03,620
现在，在这种情况下，

260
00:17:03,620 --> 00:17:04,820
现在让我们考虑一下，

261
00:17:04,820 --> 00:17:07,550
可能发生什么，什么可能会出错，

262
00:17:07,850 --> 00:17:10,760
如果文件服务器受到了威胁，

263
00:17:10,760 --> 00:17:12,110
所以是拜占庭式的。

264
00:17:16,640 --> 00:17:19,010
好的，很明显的一些问题，

265
00:17:19,010 --> 00:17:22,490
有几个明显的问题，可能会有糟糕的结果，

266
00:17:23,420 --> 00:17:25,010
让我们来考虑一下，

267
00:17:27,820 --> 00:17:29,380
结果 1 ，

268
00:17:29,380 --> 00:17:31,480
这是我们应该谈论的一件事，

269
00:17:31,480 --> 00:17:32,950
同样在前面的例子中，

270
00:17:33,250 --> 00:17:37,300
对手把任意代码给 C ，

271
00:17:38,540 --> 00:17:50,450
对手提供自己的代码给 C ，

272
00:17:53,430 --> 00:17:54,960
这有点，

273
00:17:55,050 --> 00:17:59,880
也许对手有点微妙或聪明，

274
00:17:59,880 --> 00:18:02,640
让它变得有点难以辨认，

275
00:18:02,640 --> 00:18:05,370
修改了 auth.py ，

276
00:18:05,940 --> 00:18:07,650
例如删除 MIT 证书，

277
00:18:08,010 --> 00:18:11,160
但是对于 C 来说没有办法检查，

278
00:18:11,400 --> 00:18:14,580
得到 A 和 B 生产的软件，

279
00:18:14,580 --> 00:18:17,490
没有对手的任何修改。

280
00:18:17,490 --> 00:18:20,430
这是我们将要讨论的一个显而易见的问题，

281
00:18:20,430 --> 00:18:23,370
然后有第二种结果，

282
00:18:23,370 --> 00:18:24,780
可能会更微妙一些，

283
00:18:25,410 --> 00:18:35,320
对手修改了 bank.py ，

284
00:18:37,960 --> 00:18:44,900
而不修改 auth.py 。

285
00:18:47,970 --> 00:18:51,120
所以，在这一点上，这是相当有问题的，

286
00:18:51,120 --> 00:18:54,120
因为现在 bank.py 链接在 TechCash 上，

287
00:18:54,390 --> 00:18:59,130
但我们不再对用户进行适当的身份验证，

288
00:18:59,340 --> 00:19:02,550
事实上，任何创建 zoobar 账户的人

289
00:19:02,550 --> 00:19:05,070
现在都可以与 TechCash 互动，

290
00:19:05,550 --> 00:19:08,490
所以非常不受欢迎，

291
00:19:08,760 --> 00:19:11,460
也更难被发现，

292
00:19:11,610 --> 00:19:15,810
因为对手并没有修改任何软件，

293
00:19:15,810 --> 00:19:19,350
只是有选择地你拿走它的部分，

294
00:19:19,350 --> 00:19:21,030
并展示给 C ，

295
00:19:21,030 --> 00:19:22,830
然后继续并部署。

296
00:19:24,610 --> 00:19:29,770
所以这些攻击，

297
00:19:29,770 --> 00:19:34,540
论文当然考虑了攻击 1 和 2 ，

298
00:19:34,780 --> 00:19:36,850
但有很多微妙的问题

299
00:19:36,850 --> 00:19:39,520
是由第二个案例带来的，

300
00:19:39,520 --> 00:19:41,080
这将是谈论的话题。

301
00:19:44,250 --> 00:19:45,510
到目前为止，有什么问题吗，

302
00:19:47,950 --> 00:19:50,440
关于背景，关于动机，

303
00:19:53,220 --> 00:19:55,950
在我们尝试讨论解决方案之前。

304
00:19:57,080 --> 00:19:59,210
所以第二种情况的问题是，

305
00:19:59,270 --> 00:20:05,210
身份验证不进行身份验证？

306
00:20:05,420 --> 00:20:08,240
是的，它不再使用 MIT 证书了，

307
00:20:08,600 --> 00:20:10,730
所以，我们并不知道是谁登录的。

308
00:20:12,840 --> 00:20:13,770
谢谢。

309
00:20:15,020 --> 00:20:22,400
A 和 B 看不见，就像 fork ，会怎么样？

310
00:20:25,310 --> 00:20:26,450
让我们假设，

311
00:20:26,450 --> 00:20:29,510
A 和 B 已经彼此交谈过，并划分了工作，

312
00:20:29,510 --> 00:20:32,540
所以他们知道他们应该一起做这件事。

313
00:20:33,390 --> 00:20:33,870
好的。

314
00:20:35,510 --> 00:20:36,590
可能组成一个团队，

315
00:20:37,260 --> 00:20:40,110
他们密切合作，保持联系，

316
00:20:40,110 --> 00:20:42,930
他们已经把工作分了，

317
00:20:42,930 --> 00:20:45,120
所以他们知道， B 告诉 A ，

318
00:20:45,120 --> 00:20:46,230
当 B 完成后，告诉 A ，

319
00:20:46,230 --> 00:20:48,030
当他们做完了，然后他们告诉 C ，

320
00:20:48,030 --> 00:20:48,990
继续，我们都做完了。

321
00:20:49,760 --> 00:20:50,390
好的?

322
00:20:52,190 --> 00:20:57,340
好的，让我们从一个简单的设计开始，

323
00:20:57,340 --> 00:20:59,590
它太简单了，它不能工作，

324
00:21:00,370 --> 00:21:08,140
但它为我们提供了一些更复杂的设计的起点，

325
00:21:08,290 --> 00:21:09,310
希望能工作，

326
00:21:10,180 --> 00:21:12,400
所以简单的点是，

327
00:21:12,700 --> 00:21:16,150
A 和 B 或任何，

328
00:21:16,150 --> 00:21:20,740
所有文件都将被修改人签名，

329
00:21:20,770 --> 00:21:25,880
所以，当 A 修改 auth.py 时，

330
00:21:29,200 --> 00:21:32,230
A 产生一个签名，

331
00:21:32,530 --> 00:21:36,490
并用公钥签名，

332
00:21:39,270 --> 00:21:42,840
签名签署到 A 的公钥，

333
00:21:43,470 --> 00:21:48,480
这个签名涵盖了文件的数据，

334
00:21:51,500 --> 00:21:57,170
所以当 C 下载 auth.py 时，

335
00:21:57,440 --> 00:21:59,420
检查签名，

336
00:22:05,100 --> 00:22:06,480
如果签名通过了，

337
00:22:06,480 --> 00:22:09,480
然后 C 知道这个文件生成，

338
00:22:09,480 --> 00:22:12,090
这个文件是由 A 产生的，

339
00:22:12,330 --> 00:22:16,680
可能相信事情都是好的。

340
00:22:17,300 --> 00:22:18,290
这是基本的计划，

341
00:22:18,380 --> 00:22:21,680
我们会稍微谈谈密钥来自哪里，

342
00:22:21,680 --> 00:22:26,780
虽然公钥分发的问题是一个 6.858 个主题，

343
00:22:26,780 --> 00:22:27,980
所以我不会说太多，

344
00:22:28,250 --> 00:22:29,570
但现在先假设一下，

345
00:22:29,570 --> 00:22:34,490
每个用户都有密钥，公钥和私钥对，

346
00:22:34,610 --> 00:22:39,710
私钥是秘密的，而公钥是公开的，

347
00:22:39,980 --> 00:22:43,370
每个用户都知道谁的公钥属于谁。

348
00:22:45,170 --> 00:22:49,700
现在让我们考虑一下攻击，

349
00:22:51,020 --> 00:22:53,300
看看哪种攻击会失败，

350
00:22:53,300 --> 00:22:55,550
哪种攻击会成功。

351
00:22:56,020 --> 00:22:58,240
当然，最明显的攻击 1 ，

352
00:22:58,240 --> 00:23:00,370
我们在上一张幻灯片中谈到的，

353
00:23:00,430 --> 00:23:03,780
是 S 修改文件，

354
00:23:05,940 --> 00:23:07,560
这不是，

355
00:23:07,560 --> 00:23:13,080
这不是直接由 S 修改 auth.py ，

356
00:23:13,500 --> 00:23:16,560
这不可能了，

357
00:23:16,740 --> 00:23:21,240
因为当 C 下载文件和签名时，

358
00:23:21,330 --> 00:23:22,440
并检查它，

359
00:23:22,590 --> 00:23:24,840
它将看到签名拒绝检查，

360
00:23:24,840 --> 00:23:27,000
因为实际签名的数据

361
00:23:27,330 --> 00:23:31,350
与服务器生成的数据不同，

362
00:23:31,530 --> 00:23:36,510
所以，服务器不可能修改 auth.py ，

363
00:23:36,510 --> 00:23:39,690
没有被攻击。

364
00:23:40,470 --> 00:23:44,430
所以我们在这次攻击中是好的，

365
00:23:44,460 --> 00:23:46,590
这是核心攻击。

366
00:23:47,210 --> 00:23:50,780
但是 S 还有很多其他的事情可以做，

367
00:23:51,110 --> 00:23:54,350
所以让我们来考虑一些其他的事情，

368
00:23:55,040 --> 00:23:59,810
假设 S 发送另一个文件，

369
00:24:00,710 --> 00:24:02,780
并假装是 auth.py ，

370
00:24:05,450 --> 00:24:08,780
因为签名并没有说，

371
00:24:08,810 --> 00:24:11,570
数据属于哪个文件，

372
00:24:12,020 --> 00:24:16,790
所以 S 可以产生一些其他的文件，

373
00:24:16,790 --> 00:24:19,160
比如看到这个是 auth.py ，

374
00:24:19,460 --> 00:24:21,530
你可以相信我，

375
00:24:21,530 --> 00:24:24,860
签名当然是由 S 制作的签名，

376
00:24:25,370 --> 00:24:27,800
这当然是可以修复的，

377
00:24:27,830 --> 00:24:31,010
也许签名不应该只包括数据，

378
00:24:31,010 --> 00:24:33,170
但也可能应该包括文件名，

379
00:24:35,340 --> 00:24:38,130
所以在一些事情上也许不是太糟糕，

380
00:24:38,130 --> 00:24:39,750
你可以处理。

381
00:24:41,950 --> 00:24:44,740
第三，另一种可能性是，

382
00:24:44,740 --> 00:24:53,200
S 发送旧文件的内容，

383
00:24:54,970 --> 00:24:55,960
也许有些新的，

384
00:25:03,460 --> 00:25:05,260
现在确实更难了，

385
00:25:05,260 --> 00:25:09,070
我们用简单的方案来处理这件事，

386
00:25:09,220 --> 00:25:12,700
因为没有方法，

387
00:25:12,700 --> 00:25:16,660
这些文件是单独认证的，而不是一起认证的，

388
00:25:16,660 --> 00:25:21,610
而且 C 不能得到文件系统的一致性图片，

389
00:25:21,610 --> 00:25:23,200
它只得到了签名文件，

390
00:25:23,470 --> 00:25:27,880
签名文件在它们的历史方面是如何相互关联的，

391
00:25:28,090 --> 00:25:30,670
没有覆盖在这个很简单的设计中。

392
00:25:31,380 --> 00:25:34,890
当然还有更多微妙的攻击，

393
00:25:34,890 --> 00:25:37,350
现在不能完全解决，

394
00:25:37,350 --> 00:25:40,380
因为 S 可以发送，

395
00:25:40,710 --> 00:25:44,340
可以发送旧版本的 auth.py ，

396
00:25:44,430 --> 00:25:46,410
它会完全通过检查，

397
00:25:46,740 --> 00:25:52,830
然后发送新版本的 bank.py ，

398
00:25:52,860 --> 00:25:55,350
它与 TechCash 有关，

399
00:25:55,470 --> 00:25:58,530
现在又回到了一个更糟糕的案例中，

400
00:25:58,710 --> 00:26:01,500
有一个旧版本的 auth.py ，

401
00:26:01,500 --> 00:26:03,210
或者不更改 auth.py ，

402
00:26:03,210 --> 00:26:05,370
不是修改 auth.py 的证书，

403
00:26:05,610 --> 00:26:09,570
以及链接到 TechCash 的新版本。

404
00:26:09,960 --> 00:26:11,730
所以这不是很好，

405
00:26:12,150 --> 00:26:14,490
所以我们这里的简单点，

406
00:26:14,490 --> 00:26:16,020
不涉及这个问题。

407
00:26:17,420 --> 00:26:19,850
还有类似的另一种版本，

408
00:26:19,850 --> 00:26:24,110
当然 S 也可以声明文件不存在，

409
00:26:31,530 --> 00:26:37,260
而 C 没有任何方法来检查这是否是真的，

410
00:26:37,260 --> 00:26:39,360
因为它们同样应该有一个全局图片，

411
00:26:39,480 --> 00:26:42,000
其中是文件系统的一致视图，

412
00:26:42,330 --> 00:26:45,330
没有人知道每个文件的签名。

413
00:26:46,740 --> 00:26:50,280
所以你可以看到，简单的设计可能是一个很好的起点，

414
00:26:50,280 --> 00:26:54,000
但我们需要更完整的东西，

415
00:26:54,030 --> 00:26:58,500
我认为我们需要一个将所有文件系统捆绑，

416
00:26:58,500 --> 00:26:59,520
所有文件一起，

417
00:26:59,520 --> 00:27:00,810
将目录捆绑在一起，

418
00:27:00,810 --> 00:27:03,450
将目录的内容捆绑在一起，

419
00:27:03,450 --> 00:27:06,270
我们必须能够以某种方式做出决定，

420
00:27:06,270 --> 00:27:09,690
文件系统的最新版本是什么，

421
00:27:09,930 --> 00:27:14,430
所以在这种有问题的情况下， C 不会被骗，

422
00:27:14,430 --> 00:27:18,000
其中安装了一个文件，而没有安装另一个文件。

423
00:27:18,930 --> 00:27:22,800
所以这就是 SUNDR 论文试图解决的问题，

424
00:27:23,070 --> 00:27:30,510
论文中的大的想法，

425
00:27:30,720 --> 00:27:33,810
这只是一个普遍的大的想法，

426
00:27:35,220 --> 00:27:36,990
这是一个概念性的想法，

427
00:27:36,990 --> 00:27:40,710
尽管论文并没有直接实现这个大的想法，

428
00:27:40,830 --> 00:27:42,630
以一种更间接的方式实现它，

429
00:27:42,840 --> 00:27:46,200
这是一个令人难以置信的强大的想法。

430
00:27:47,130 --> 00:27:56,040
所以大想法是对操作的日志签名。

431
00:28:01,340 --> 00:28:04,460
当然，你对操作日志很熟悉，

432
00:28:04,700 --> 00:28:07,100
你可以，

433
00:28:07,100 --> 00:28:09,890
这是它的一种[增强]版本，

434
00:28:10,190 --> 00:28:12,590
在日志条目上有签名的情况下，

435
00:28:12,590 --> 00:28:16,460
涵盖了条目以及之前的条目。

436
00:28:17,150 --> 00:28:20,210
这就是，

437
00:28:20,240 --> 00:28:25,430
我们在之前的所有分布式系统和故障恢复协议中看到的，

438
00:28:25,430 --> 00:28:28,730
我们说过日志是一个非常强大的想法，

439
00:28:28,730 --> 00:28:31,670
来考虑系统的正确性，

440
00:28:31,910 --> 00:28:38,270
同样地，这个想法也是在这个拜占庭式的背景下进行的。

441
00:28:38,880 --> 00:28:42,630
所以，让我画一个简单的日志，

442
00:28:45,660 --> 00:28:48,090
从论文中拿出这个，

443
00:28:48,300 --> 00:28:50,160
所以日志有一些条目，

444
00:28:50,160 --> 00:28:54,090
比如，我们已经讨论过的，

445
00:28:54,090 --> 00:28:55,770
所以它是修改，

446
00:28:56,220 --> 00:29:03,850
由 A 修改 auth.py ，由 A 签名，

447
00:29:05,760 --> 00:29:06,990
这里有个 mod ，

448
00:29:07,620 --> 00:29:08,670
如果一切顺利，

449
00:29:08,670 --> 00:29:17,730
这里有一个 bank.py ，由 B 签名。

450
00:29:20,630 --> 00:29:22,280
正如我们稍后要谈到的，

451
00:29:22,280 --> 00:29:26,980
不仅日志中的修改，

452
00:29:26,980 --> 00:29:29,950
还包括读取操作的获取，

453
00:29:32,050 --> 00:29:41,780
所以，获取 C 签名的日志， auth.py ，

454
00:29:43,750 --> 00:29:49,850
然后获取由 C 签名的 bank.py .

455
00:29:52,620 --> 00:29:56,310
我们将讨论这些操作，取回操作，

456
00:29:56,490 --> 00:29:57,720
我首先想讨论，

457
00:29:57,720 --> 00:30:01,890
如何操作前面的操作进行修改。

458
00:30:05,200 --> 00:30:08,770
所以，首先，重要的是要认识到，

459
00:30:08,770 --> 00:30:14,350
记录中的签名不仅覆盖当前记录，

460
00:30:14,530 --> 00:30:16,570
它也涵盖了以前的所有记录。

461
00:30:23,590 --> 00:30:25,000
让我在这里停一下，

462
00:30:25,000 --> 00:30:28,420
因为我不能百分之百确定是否每个人都能听到我。

463
00:30:30,220 --> 00:30:31,000
是的。

464
00:30:31,030 --> 00:30:31,240
是的。

465
00:30:31,240 --> 00:30:35,500
好了，我拿了我的 iPad ，走出了 Zoom ，

466
00:30:35,500 --> 00:30:40,390
我登录了两次，然后我的 iPad 退出了，

467
00:30:40,420 --> 00:30:41,980
所以我只想确定，

468
00:30:41,980 --> 00:30:44,050
我还在和你说话，你能听到我说话，

469
00:30:46,140 --> 00:30:47,520
情况就是这样。

470
00:30:47,730 --> 00:30:51,270
好的，那我们开始。

471
00:30:52,030 --> 00:30:52,600
所以，实际上。

472
00:31:20,620 --> 00:31:22,120
我想我们丢了 Frans 。

473
00:32:05,030 --> 00:32:09,530
现在大家能听到我说话吗，有人能听到我说话吗？

474
00:32:11,620 --> 00:32:12,340
是的。

475
00:32:12,370 --> 00:32:13,330
好的。

476
00:32:13,780 --> 00:32:16,510
好的，我不知道你那边有没有发生什么奇怪的事，

477
00:32:16,510 --> 00:32:18,040
但在我这一边，

478
00:32:18,900 --> 00:32:21,870
我退出了 Zoom ，然后重新登录，

479
00:32:24,340 --> 00:32:28,480
也许有个拜占庭式的服务器在工作。

480
00:32:29,440 --> 00:32:35,060
好的，让我，稍等片刻，然后我自己。

481
00:32:49,800 --> 00:32:52,440
让我看看，视频开始播放了。

482
00:33:07,420 --> 00:33:11,380
摄像机，好的，如果我好了就告诉我。

483
00:33:14,280 --> 00:33:15,720
好的，很好。

484
00:33:15,720 --> 00:33:17,340
还不能分享屏幕，但是。

485
00:33:17,460 --> 00:33:20,790
好的，我希望这能更好地工作。

486
00:33:20,820 --> 00:33:24,180
好的，在这个非常重要的时刻，

487
00:33:24,180 --> 00:33:28,140
签名不只覆盖日志条目本身，

488
00:33:28,230 --> 00:33:30,870
而且还覆盖了所有之前的日志条目。

489
00:33:31,480 --> 00:33:38,740
所以，当 A 对 auth.py 的日志修改时，

490
00:33:38,800 --> 00:33:42,490
它对日志记录本身以及之前的日志记录进行签名，

491
00:33:42,490 --> 00:33:43,360
所以你可以想一想，

492
00:33:43,360 --> 00:33:46,270
之前的日志可以表示为，

493
00:33:46,300 --> 00:33:50,590
之前日志的内容是加密哈希，

494
00:33:50,620 --> 00:33:56,350
在记录中，修改 auth.py ，

495
00:33:56,350 --> 00:34:01,210
日志的前面部分的加密散列是

496
00:34:01,210 --> 00:34:03,940
包括并覆盖在签名中。

497
00:34:04,150 --> 00:34:06,760
确认一下，我们还是看不到屏幕。

498
00:34:07,330 --> 00:34:11,460
你看不到屏幕，屏幕没有改变，

499
00:34:11,460 --> 00:34:16,300
但是，让我看看我能不能做点什么。

500
00:34:17,340 --> 00:34:19,200
我想，

501
00:34:21,180 --> 00:34:23,250
Zoom 仍然认为这是在分享屏幕，

502
00:34:23,250 --> 00:34:25,500
但它看起来并不是。

503
00:34:35,230 --> 00:34:35,950
这个怎么样？

504
00:34:37,680 --> 00:34:38,550
是的，我现在能看到了。

505
00:34:39,030 --> 00:34:39,780
好的，谢谢。

506
00:34:40,620 --> 00:34:42,450
好的，所以我什么都没改，

507
00:34:42,510 --> 00:34:44,430
除了我画了一个箭头，

508
00:34:44,430 --> 00:34:46,560
这些签名，

509
00:34:46,590 --> 00:34:49,110
它也涵盖了前面的所有条目。

510
00:34:50,320 --> 00:34:51,700
这很好，

511
00:34:51,700 --> 00:34:58,540
因为当客户端 C 接收到

512
00:34:58,540 --> 00:35:01,240
获得 B 的日志条目时，

513
00:35:01,570 --> 00:35:08,260
服务器不可能丢弃 A 的日志条目，

514
00:35:08,350 --> 00:35:10,570
因为这会被检测到，

515
00:35:10,570 --> 00:35:13,960
当 C 检测 B 的日志条目的签名时。

516
00:35:14,810 --> 00:35:17,810
所以，我们向前迈出了一大步，

517
00:35:17,810 --> 00:35:19,550
从这个意义上说，

518
00:35:19,550 --> 00:35:24,410
服务器现在更难有选择地删除日志条目。

519
00:35:25,590 --> 00:35:27,930
所以这非常好，

520
00:35:28,320 --> 00:35:30,600
服务器不能丢弃 A ，

521
00:35:36,540 --> 00:35:41,150
并保留这些修改。

522
00:35:44,250 --> 00:35:46,860
所以这是向前迈出的一大步，

523
00:35:47,190 --> 00:35:49,110
所以让我们更详细地看一下，

524
00:35:49,110 --> 00:35:50,640
这件事到底会如何发展。

525
00:35:50,850 --> 00:35:52,590
我们是客户端 C ，

526
00:35:53,700 --> 00:35:56,520
我们获取日志，

527
00:35:56,520 --> 00:35:59,580
为了[]软件的分发版本，

528
00:35:59,580 --> 00:36:01,140
在特定机器上安装，

529
00:36:01,470 --> 00:36:03,120
客户端做的第一件事，

530
00:36:03,120 --> 00:36:05,950
它检查所有的签名，

531
00:36:13,990 --> 00:36:16,390
问题总是这样的，

532
00:36:16,390 --> 00:36:19,060
当你要检查签名日志条目，

533
00:36:19,060 --> 00:36:21,700
使用哪个公钥，

534
00:36:21,700 --> 00:36:24,370
因为你想要确保，

535
00:36:24,910 --> 00:36:30,180
你没有被骗，接受 A 的修改，

536
00:36:30,180 --> 00:36:32,790
但是 A 并不是对它签名的人，

537
00:36:33,350 --> 00:36:40,820
为了找出使用哪个密钥来验证签名，

538
00:36:41,000 --> 00:36:44,360
密钥使用文件的所有者，

539
00:36:45,250 --> 00:36:49,460
所以，公钥需要与文件的所有者相对应，

540
00:36:50,840 --> 00:36:53,900
暂时忽略组，

541
00:36:53,900 --> 00:36:57,110
只有文件的所有者才能修改文件。

542
00:36:57,880 --> 00:37:00,940
因此，稍微简化一下，

543
00:37:00,940 --> 00:37:04,270
我们可以认为 auth.py 是 A 所有的，

544
00:37:04,600 --> 00:37:07,360
文件的 id 是 A 的公钥，

545
00:37:07,930 --> 00:37:12,280
所以，我们知道要使用哪个公钥，

546
00:37:12,490 --> 00:37:17,170
并可以用它验证签名，

547
00:37:17,170 --> 00:37:20,800
所以，如果其他人做了一个伪装成 A 的修改，

548
00:37:20,950 --> 00:37:22,480
这是不会通过检验的。

549
00:37:23,560 --> 00:37:25,990
所以，只有 A 可以连接并修改，

550
00:37:25,990 --> 00:37:26,620
B 也是一样。

551
00:37:28,540 --> 00:37:33,160
这是 SUNDR 聪明之处的一部分，

552
00:37:33,310 --> 00:37:34,810
我不是要讨论，

553
00:37:35,020 --> 00:37:38,260
因为文件系统是文件系统的两倍，

554
00:37:38,260 --> 00:37:45,280
作为公钥公钥基础设施或分发基础设施，

555
00:37:45,550 --> 00:37:48,580
所以，使用 SUNDR 是可能的，

556
00:37:48,580 --> 00:37:52,150
我们确定哪个用户拥有哪个公钥。

557
00:37:53,380 --> 00:37:55,120
但我不想讨论这个，

558
00:37:55,120 --> 00:37:57,610
我想专注于一致性方面，

559
00:37:57,610 --> 00:38:00,070
以及更多的分布式系统方面。

560
00:38:00,990 --> 00:38:07,720
客户端做的第二件事是，检查它自己的最后一个条目。

561
00:38:13,410 --> 00:38:18,270
这是为了保护客户端不会被服务器回滚，

562
00:38:18,270 --> 00:38:21,990
所以服务器总是检查最后一个条目，

563
00:38:22,440 --> 00:38:24,300
如果它在日志中的最后条目被窃取，

564
00:38:24,450 --> 00:38:28,590
然后，对于攻击者的唯一方法，

565
00:38:28,620 --> 00:38:32,070
回滚文件系统，因为 A 可以回滚，

566
00:38:32,370 --> 00:38:35,520
所以， C 将检查它之前的任何操作是否在其中，

567
00:38:35,880 --> 00:38:38,070
并确认它们还在里面，

568
00:38:39,600 --> 00:38:42,360
它的最后一个条目还在里面。

569
00:38:42,360 --> 00:38:43,620
这里的问题是，

570
00:38:44,070 --> 00:38:50,100
我觉得这个攻击是从服务器回滚，

571
00:38:50,100 --> 00:38:55,530
只有在没有其他客户端写入日志的情况下才能工作，

572
00:38:56,860 --> 00:39:00,430
在这个客户端最后一个条目之后，

573
00:39:00,430 --> 00:39:04,150
因为否则检查签名就会知道了。

574
00:39:04,800 --> 00:39:09,390
是的，我们待会再谈，

575
00:39:09,390 --> 00:39:11,490
我的意思是你总是可以使用 fork 攻击，

576
00:39:11,550 --> 00:39:15,840
你可以拆分文件系统在多个用户中的使用，

577
00:39:16,050 --> 00:39:18,690
但你至少可以不回滚客户端，

578
00:39:18,690 --> 00:39:21,090
一旦客户端看到特定的文件系统，

579
00:39:21,450 --> 00:39:22,770
你不能在时间上倒退，

580
00:39:24,150 --> 00:39:27,360
客户端可以呈现未来的不同文件系统的服务器，

581
00:39:27,390 --> 00:39:28,860
但你不能倒退。

582
00:39:32,280 --> 00:39:34,470
第三部分，

583
00:39:35,100 --> 00:39:38,130
第三部分[]是一个[建设性的]文件系统，

584
00:39:41,930 --> 00:39:46,670
它知道它没有滚动到文件系统的之前版本，

585
00:39:46,760 --> 00:39:49,220
它应用所有的修改，

586
00:39:49,220 --> 00:39:52,460
基本上在客户机上构建文件系统树，

587
00:39:52,940 --> 00:39:56,300
然后在做任何操作之前，

588
00:39:56,300 --> 00:39:57,110
它想要[]，

589
00:39:57,110 --> 00:40:00,080
我们假设在 C 的情况下，

590
00:40:00,170 --> 00:40:01,790
它将会做的是，

591
00:40:01,790 --> 00:40:04,550
它将读取 auth.py ，

592
00:40:04,760 --> 00:40:14,720
并在日志中附加一个条目，并对其进行签名，

593
00:40:17,330 --> 00:40:19,280
所以，在读取 auth.py 的情况下，

594
00:40:19,280 --> 00:40:24,110
它将产生这个日志条目签名。

595
00:40:25,150 --> 00:40:29,110
然后这个协议的最后一步是，

596
00:40:29,110 --> 00:40:31,810
它将日志上传到文件服务器，

597
00:40:37,770 --> 00:40:41,160
这个协议在现实中是未完成的，

598
00:40:41,250 --> 00:40:43,710
它实际上是，

599
00:40:43,710 --> 00:40:45,150
这是一种更具概念性的协议，

600
00:40:45,150 --> 00:40:46,320
帮助我们理解

601
00:40:46,710 --> 00:40:50,610
为什么我们最终可能成功地实现安全，

602
00:40:50,610 --> 00:40:54,930
在拜占庭服务器的上下文中。

603
00:40:55,540 --> 00:40:59,560
因为如果我们激进地下载每个操作的日志，

604
00:40:59,770 --> 00:41:03,520
并且日志包含发生在文件系统上的所有操作的历史，

605
00:41:03,730 --> 00:41:04,690
在第三步中，

606
00:41:04,690 --> 00:41:07,180
客户端构建了文件系统，

607
00:41:07,180 --> 00:41:10,840
所有操作从一开始就执行，

608
00:41:11,110 --> 00:41:12,670
最后在第五步，

609
00:41:12,670 --> 00:41:15,880
将整个日志上传回服务器，看起来非常荒谬，

610
00:41:16,090 --> 00:41:18,640
这很荒谬，在性能方面，

611
00:41:18,730 --> 00:41:21,940
但这将帮助我们理解，

612
00:41:21,940 --> 00:41:25,810
当我们观察这个方案的实现时，

613
00:41:25,930 --> 00:41:28,750
当它具有相同的属性时，

614
00:41:28,750 --> 00:41:31,390
他们的概念设计所有的，

615
00:41:31,870 --> 00:41:35,140
我们将看到，在比特币的情况下，

616
00:41:35,230 --> 00:41:37,390
从字面上看，它确实有一个日志，

617
00:41:37,390 --> 00:41:39,790
从一开始，所有的操作都在其中，

618
00:41:39,970 --> 00:41:43,120
所以，也许这是一个疯狂的想法，

619
00:41:43,120 --> 00:41:44,350
也许在 2004 年的背景下，

620
00:41:44,350 --> 00:41:46,720
但是人们确实做了，

621
00:41:46,720 --> 00:41:49,900
对日志进行签名，并维护它。

622
00:41:50,680 --> 00:41:51,670
所以，从这个意义上说，

623
00:41:51,820 --> 00:41:54,040
这不仅是一个大的概念，

624
00:41:54,070 --> 00:41:55,540
一些人在实践中这样做了。

625
00:41:58,340 --> 00:41:59,450
到目前为止，有什么问题吗？

626
00:42:04,290 --> 00:42:04,980
好的。

627
00:42:07,270 --> 00:42:10,870
你可能在想的一件事，

628
00:42:10,870 --> 00:42:16,110
这是作为今天阅读的议题提出的，

629
00:42:16,320 --> 00:42:18,510
就是这些获取有什么问题，

630
00:42:18,510 --> 00:42:21,690
为什么也要获取日志，

631
00:42:21,900 --> 00:42:26,160
因为你可能会想，

632
00:42:26,160 --> 00:42:28,260
我唯一真正关心的是，

633
00:42:28,260 --> 00:42:31,500
如果我们想一想，关心的是，

634
00:42:31,710 --> 00:42:33,600
只有在日志中的修改，

635
00:42:33,600 --> 00:42:35,940
因为有一些东西修改了文件系统，

636
00:42:35,940 --> 00:42:37,830
读取并不会修改文件系统，

637
00:42:37,830 --> 00:42:40,680
所以，到底是什么问题。

638
00:42:41,280 --> 00:42:44,250
所以我想在这里做一个快速分组会议室，

639
00:42:44,250 --> 00:42:46,110
我相信如果你们能互相讨论一下，

640
00:42:46,110 --> 00:42:48,870
你认为这个问题的答案是什么，

641
00:42:49,050 --> 00:42:56,140
希望像 SUNDR 这样的[初始报道]

642
00:42:56,140 --> 00:42:58,360
可能会提高你的理解，

643
00:42:58,660 --> 00:43:01,390
你可以弄清楚答案是什么

644
00:43:01,390 --> 00:43:02,530
或者谈论一些其他的事情，

645
00:43:02,740 --> 00:43:06,850
所以我想，也许做一个五分钟的分组会议室。

646
00:49:18,650 --> 00:49:20,690
好的，检查一下所有人回来了吗？

647
00:49:21,860 --> 00:49:22,520
看起来是的。

648
00:49:22,940 --> 00:49:24,020
很好，谢谢。

649
00:49:24,810 --> 00:49:25,380
好的，那么，

650
00:49:25,380 --> 00:49:28,020
我想，让我们从家庭作业的问题开始，

651
00:49:28,490 --> 00:49:32,150
为什么获取要在日志中？

652
00:49:38,260 --> 00:49:38,950
有人知道吗？

653
00:49:41,230 --> 00:49:43,870
如果你有只读服务器，

654
00:49:44,110 --> 00:49:45,340
如果没有获取，

655
00:49:45,340 --> 00:49:48,040
这个文件系统可以为它提供任何东西。

656
00:49:48,630 --> 00:49:49,170
可以吗？

657
00:49:49,970 --> 00:49:51,650
可以，因为它，

658
00:49:51,830 --> 00:49:53,780
因为在日志中没有提取，

659
00:49:53,780 --> 00:49:58,060
这意味着，

660
00:49:58,180 --> 00:50:04,680
只读服务器不会进行大量的检查，

661
00:50:04,680 --> 00:50:05,970
我们之前谈过的，

662
00:50:05,970 --> 00:50:09,000
所以它们回到过去，

663
00:50:09,000 --> 00:50:10,860
可能不起作用，

664
00:50:10,860 --> 00:50:13,850
因为它没有在日志中放任何东西，

665
00:50:13,970 --> 00:50:15,500
因为它只获取。

666
00:50:15,740 --> 00:50:16,760
是的，好的，很好，

667
00:50:16,760 --> 00:50:19,640
好的，所以我想你完全是对的，

668
00:50:19,910 --> 00:50:23,780
试图让它变得更精确一点或更具体，

669
00:50:23,810 --> 00:50:25,250
我想这是正确的。

670
00:50:25,310 --> 00:50:27,050
我们假设这是如下所示的日志，

671
00:50:27,050 --> 00:50:28,880
而且 C 的获取不在里面。

672
00:50:29,480 --> 00:50:31,190
让我们，

673
00:50:31,190 --> 00:50:35,450
这是 C 下载之前的日志，

674
00:50:35,720 --> 00:50:44,190
假设 C 获取 auth.py ，

675
00:50:44,190 --> 00:50:45,990
A 修改的文件，

676
00:50:46,830 --> 00:50:49,140
服务器所做的，

677
00:50:49,380 --> 00:50:55,290
服务器不是提供 A 和 B 的修改，

678
00:50:55,290 --> 00:50:56,070
因为它拥有它，

679
00:50:56,880 --> 00:50:59,280
A 和 B 对其进行了修改，

680
00:50:59,610 --> 00:51:06,330
它发送给 C 前缀，

681
00:51:08,880 --> 00:51:15,840
因为前缀排除了 A 和 B 的修改，

682
00:51:16,900 --> 00:51:22,690
所以我们有 mod A 和 B ，

683
00:51:22,690 --> 00:51:24,820
所以 C 获取文件，

684
00:51:24,970 --> 00:51:26,650
它获取日志，

685
00:51:26,800 --> 00:51:30,460
这是日志前缀的这一部分，

686
00:51:32,540 --> 00:51:36,470
C 检查签名，

687
00:51:36,470 --> 00:51:38,960
检查进行的操作是否在其中，

688
00:51:39,290 --> 00:51:40,640
它们都在那里，

689
00:51:40,640 --> 00:51:42,590
因为 C 还没有做任何其他的操作，

690
00:51:42,920 --> 00:51:44,750
所以它会接受日志，

691
00:51:44,750 --> 00:51:47,450
原样的日志或原样的前缀，

692
00:51:47,810 --> 00:51:52,310
并且返回 auth.py 给应用程序，

693
00:51:52,860 --> 00:51:55,290
将这个软件复制到机器中，

694
00:51:55,290 --> 00:51:57,390
运行安装的软件。

695
00:51:58,130 --> 00:52:05,230
然后 C 获取 bank.py ，

696
00:52:08,590 --> 00:52:14,230
这一次，服务器发送整个日志，

697
00:52:19,460 --> 00:52:25,550
C 查看这些条目，

698
00:52:25,550 --> 00:52:27,770
这是一份有效的日志，

699
00:52:27,770 --> 00:52:30,740
操作的前缀，

700
00:52:31,310 --> 00:52:33,470
因为我们不关心获取，

701
00:52:33,470 --> 00:52:34,970
这些都在日志中，

702
00:52:35,210 --> 00:52:38,270
所以一切看起来都很好，

703
00:52:38,270 --> 00:52:39,800
这些都是有效的修改，

704
00:52:39,800 --> 00:52:41,900
什么都没有改变，

705
00:52:42,410 --> 00:52:47,450
所以 C 没有从日志中获取，

706
00:52:47,600 --> 00:52:50,240
C 会接受这个日志，

707
00:52:50,450 --> 00:52:52,670
建立一个文件系统，

708
00:52:52,670 --> 00:52:58,490
包括对 A 和 B 修改，

709
00:52:58,640 --> 00:53:02,930
并且返回 bank.py 应用程序的结果。

710
00:53:05,490 --> 00:53:07,050
这样它可以安装机器，

711
00:53:07,050 --> 00:53:09,030
运行服务器，

712
00:53:09,360 --> 00:53:12,630
如你所见，我们的处境很糟糕，

713
00:53:12,630 --> 00:53:17,080
因为我们使用了旧版本的 auth.py ，

714
00:53:18,220 --> 00:53:21,010
以及新版本的 bank.py ，

715
00:53:22,940 --> 00:53:25,460
你能想到的一种方式是，

716
00:53:25,640 --> 00:53:27,650
从 C 的角度来看，

717
00:53:27,890 --> 00:53:33,110
真正发生的事情是，

718
00:53:34,110 --> 00:53:37,260
虽然它读取 auth.py ，

719
00:53:37,380 --> 00:53:40,320
对 A 和 B 的修改是同时进行的，

720
00:53:40,320 --> 00:53:42,240
基本上是同时发生的，

721
00:53:42,240 --> 00:53:45,120
或者至少服务器认为它是同时发生的，

722
00:53:45,600 --> 00:53:48,180
所以，它被搞糊涂了，

723
00:53:48,550 --> 00:53:50,620
或者无法察觉这样一个事实，

724
00:53:50,620 --> 00:53:53,770
这些应用程序在之前就已经发生了。

725
00:53:55,060 --> 00:53:56,920
所以这就是问题所在，

726
00:53:56,920 --> 00:54:00,700
把获取放在日志中，

727
00:54:01,090 --> 00:54:06,010
让我们把它变得更加具体，

728
00:54:08,200 --> 00:54:13,300
看看为什么在这种情况下，这个问题得到了解决。

729
00:54:14,260 --> 00:54:16,030
教授，我有个问题。

730
00:54:16,090 --> 00:54:20,590
是的，所以我有点理解不了，

731
00:54:20,590 --> 00:54:26,410
比如理解接口，

732
00:54:26,410 --> 00:54:30,550
对于获取和修改，

733
00:54:31,350 --> 00:54:35,670
我想你获取了大概整个树，

734
00:54:35,700 --> 00:54:37,800
不得不重建整个文件系统，

735
00:54:37,860 --> 00:54:39,600
基本的例子，

736
00:54:39,900 --> 00:54:44,610
但在幻灯片中，获取特定文件之前。

737
00:54:44,850 --> 00:54:49,170
服务器是返回日志的服务器，

738
00:54:49,890 --> 00:54:52,260
所以服务器就可以决定要包括哪些条目。

739
00:54:52,640 --> 00:54:53,240
是的。

740
00:54:53,240 --> 00:54:54,470
我们已经看到，

741
00:54:54,470 --> 00:54:57,230
它不能删除日志中间的任何内容，

742
00:54:57,260 --> 00:54:58,790
这是不可能的，

743
00:54:59,090 --> 00:55:01,130
它总是发送日志的前缀，

744
00:55:01,160 --> 00:55:03,740
因为前缀总是与其本身一致。

745
00:55:04,670 --> 00:55:08,100
所以在第一种情况下，

746
00:55:08,100 --> 00:55:09,150
它发送前缀，

747
00:55:09,510 --> 00:55:11,280
在第二种情况下，发送整个日志。

748
00:55:11,370 --> 00:55:12,750
是的。

749
00:55:12,750 --> 00:55:14,130
所以服务器可以决定这样做，

750
00:55:14,130 --> 00:55:16,230
但客户没有任何可以，

751
00:55:16,260 --> 00:55:17,670
或至少到目前为止，

752
00:55:17,730 --> 00:55:19,950
讨论客户端没有，

753
00:55:19,950 --> 00:55:21,030
客户如何检测到，

754
00:55:21,030 --> 00:55:22,680
它获得了整个日志。

755
00:55:22,950 --> 00:55:26,160
是的，我的问题更多的是针对，

756
00:55:26,160 --> 00:55:29,400
比如客户端使用的接口，

757
00:55:29,400 --> 00:55:31,770
比如获取和修改，

758
00:55:32,070 --> 00:55:33,750
因为我想，一开始我想，

759
00:55:33,750 --> 00:55:36,870
好的，获取整个文件系统。

760
00:55:36,900 --> 00:55:38,970
不，获取是一个单独的文件。

761
00:55:39,210 --> 00:55:39,870
好的。

762
00:55:40,440 --> 00:55:42,750
所以，获取所做的是，

763
00:55:42,750 --> 00:55:44,640
它获取日志，比如修改，

764
00:55:45,150 --> 00:55:47,760
修改是修改文件的所有操作，

765
00:55:48,180 --> 00:55:50,970
如果你回到稍微早一点的幻灯片上，

766
00:55:51,000 --> 00:55:52,530
在修改记录中，

767
00:55:52,530 --> 00:55:55,140
它明确说明修改的是哪个文件，

768
00:55:56,310 --> 00:55:58,380
它所说的是，

769
00:55:58,380 --> 00:55:59,460
类似在获取中，

770
00:55:59,460 --> 00:56:01,680
它说哪个文件客户端会看到。

771
00:56:03,400 --> 00:56:04,150
好的。

772
00:56:04,640 --> 00:56:08,480
然后，所以对于获取，

773
00:56:08,510 --> 00:56:11,330
客户端通过日志，

774
00:56:11,330 --> 00:56:12,500
但只看了。

775
00:56:13,130 --> 00:56:16,070
是的，获取所做的是读取它要查看的文件。

776
00:56:16,550 --> 00:56:20,840
好的，但它会检查日志中的每一项签名吗？

777
00:56:20,840 --> 00:56:25,250
是的，好的，第一步总是检查整个日志，

778
00:56:25,400 --> 00:56:29,870
确保你的最后一次操作在其中，

779
00:56:29,870 --> 00:56:31,280
无论是获取还是修改，

780
00:56:31,520 --> 00:56:35,780
尽管在这个失败的方案中，我们放弃了获取，

781
00:56:36,230 --> 00:56:39,650
它应用所有的检查，所有的签名，

782
00:56:39,920 --> 00:56:42,380
然后它构建文件系统，

783
00:56:42,970 --> 00:56:45,160
通过从头开始重放日志，

784
00:56:45,160 --> 00:56:46,120
获取文件系统，

785
00:56:46,210 --> 00:56:47,770
然后它开始执行操作，

786
00:56:47,830 --> 00:56:48,700
所以在本例中，

787
00:56:48,700 --> 00:56:51,880
操作当然是读取 auth.py ，是读取它。

788
00:56:52,520 --> 00:56:53,030
好的。

789
00:56:53,180 --> 00:56:55,940
我们讨论 fetch 和 modify 的原因是，

790
00:56:55,940 --> 00:56:58,850
因为所有操作都是在一个或两个[]，

791
00:56:58,850 --> 00:57:03,110
要么是获取，要么是修改操作，

792
00:57:03,110 --> 00:57:04,970
比如写入文件，创建文件，

793
00:57:04,970 --> 00:57:07,040
都是修改操作，

794
00:57:07,130 --> 00:57:12,410
获取操作是读取文件，[]目录状态文件，

795
00:57:12,410 --> 00:57:13,010
这种之类的东西。

796
00:57:13,730 --> 00:57:15,920
好的，然后 modify 也是，

797
00:57:16,130 --> 00:57:21,790
modify 不会获取，

798
00:57:21,790 --> 00:57:23,230
好的，也会获取日志，

799
00:57:23,230 --> 00:57:26,170
然后构建文件系统。

800
00:57:26,200 --> 00:57:28,630
是的，所以我在这里使用的 fetch ，

801
00:57:28,630 --> 00:57:29,650
我想有两种方式，

802
00:57:29,680 --> 00:57:31,900
一个是只读操作，

803
00:57:32,080 --> 00:57:35,680
并且从服务器获取或接收日志。

804
00:57:36,170 --> 00:57:39,980
好的，然后 modify 修改一个单独的文件。

805
00:57:40,310 --> 00:57:43,250
是的，对于文件系统的每一次修改，

806
00:57:43,250 --> 00:57:44,360
你会有一个日志条目。

807
00:57:44,900 --> 00:57:45,470
好的，谢谢。

808
00:57:47,900 --> 00:57:50,660
抱歉，我也有一个问题，

809
00:57:50,660 --> 00:57:56,150
我真的不明白为什么这个场景是个问题，

810
00:57:56,750 --> 00:57:58,370
因为就像你说的，

811
00:57:58,970 --> 00:58:00,260
这是可能的，

812
00:58:00,260 --> 00:58:01,940
从客户端的角度来看，

813
00:58:01,940 --> 00:58:03,050
很可能是，

814
00:58:03,230 --> 00:58:09,530
A 和 B 创建或修改了最后一次 fetch 。

815
00:58:09,650 --> 00:58:11,510
是的，原则上，这是有可能发生的，

816
00:58:11,510 --> 00:58:12,800
这是[恢复的]修改，

817
00:58:12,980 --> 00:58:13,850
我们知道，

818
00:58:13,850 --> 00:58:16,880
因为我们是从上面看的，

819
00:58:17,120 --> 00:58:21,470
我们知道，在 A 和 B 修改后， C 读取了文件，

820
00:58:22,860 --> 00:58:26,100
但服务器可以认为它同时发生，

821
00:58:26,160 --> 00:58:28,200
稍后我们将看到，

822
00:58:28,200 --> 00:58:30,000
如果我们把 fetch 放在日志中，

823
00:58:30,060 --> 00:58:31,590
服务器不能认为是这样的。

824
00:58:33,240 --> 00:58:36,480
好的，但是即使服务器认为是这样，

825
00:58:36,510 --> 00:58:40,450
这是个问题吗，

826
00:58:40,450 --> 00:58:41,590
它有没有打破什么东西，

827
00:58:41,590 --> 00:58:41,890
因为。

828
00:58:41,890 --> 00:58:46,090
是的，这是一个展示如何打破东西的例子，

829
00:58:46,360 --> 00:58:50,100
比如第一步， C 获取的是 auth.py ，

830
00:58:50,250 --> 00:58:51,870
服务器给了它一个，

831
00:58:52,110 --> 00:58:55,530
关于获取，它给了前缀，

832
00:58:56,260 --> 00:58:58,030
所以客户端构建了文件系统，

833
00:58:58,030 --> 00:58:59,230
执行该操作，

834
00:58:59,230 --> 00:59:02,080
将 auth.py 返回给应用程序，

835
00:59:02,080 --> 00:59:03,820
并在机器上安装软件，

836
00:59:03,880 --> 00:59:05,680
为了让它非常[]，

837
00:59:05,860 --> 00:59:09,580
所以现在第一个，读取 auth.py 已经完成，

838
00:59:10,000 --> 00:59:11,680
完成已执行，

839
00:59:11,920 --> 00:59:16,900
在计算机上安装了旧版本的 auth.py ，

840
00:59:18,700 --> 00:59:22,240
然后客户端可以获取 bank.py ，

841
00:59:23,050 --> 00:59:28,690
现在服务器，客户端应用程序想要读取 bank.py ，

842
00:59:28,810 --> 00:59:30,970
所以客户端从服务器获取日志，

843
00:59:31,180 --> 00:59:33,310
或者要求服务器，请把日志给我，

844
00:59:33,670 --> 00:59:35,710
这一次，服务器给出了整个日志，

845
00:59:36,240 --> 00:59:37,620
而不仅是前缀。

846
00:59:38,010 --> 00:59:38,610
是的，但是。

847
00:59:38,610 --> 00:59:41,040
[]构建整个文件系统，

848
00:59:41,070 --> 00:59:43,890
并将 bank.py 返回给应用程序。

849
00:59:44,830 --> 00:59:50,230
但是，这不会在不正确的客户端实现中发生吗，

850
00:59:50,230 --> 00:59:53,680
因为如果客户端发现收到日志，

851
00:59:53,770 --> 00:59:56,770
它看到了对 A 的额外修改，

852
00:59:56,980 --> 01:00:02,050
如果客户端知道逻辑依赖于 A 和 B 同步，

853
01:00:02,050 --> 01:00:03,640
它还会再次获取 A 。

854
01:00:04,600 --> 01:00:06,670
好的，有个问题，

855
01:00:06,940 --> 01:00:08,830
C 不知道，

856
01:00:08,830 --> 01:00:13,330
C 是，

857
01:00:13,360 --> 01:00:17,580
好的，在这个特殊的场景中，

858
01:00:18,390 --> 01:00:21,540
我们试图确定是否，

859
01:00:21,540 --> 01:00:22,470
C 可以确定，

860
01:00:22,470 --> 01:00:26,160
修改是同时发生的还是在过去发生的，

861
01:00:26,160 --> 01:00:26,820
在读取之前，

862
01:00:27,480 --> 01:00:28,740
我们想是这种情况，

863
01:00:28,740 --> 01:00:29,970
这在过去发生过，

864
01:00:29,970 --> 01:00:31,800
因为确实发生在过去，

865
01:00:32,110 --> 01:00:35,170
但是这个服务器所做的，

866
01:00:35,200 --> 01:00:38,710
它只是认为修改是同时进行的，

867
01:00:38,770 --> 01:00:40,930
看到了操作，

868
01:00:41,860 --> 01:00:45,520
C 没有任何方法可以检测到这一点，

869
01:00:45,610 --> 01:00:48,580
除了一个新的也许 A ，

870
01:00:48,580 --> 01:00:51,010
A 和 B 应该一起修改，

871
01:00:51,500 --> 01:00:53,210
但这只有可能知道，

872
01:00:53,210 --> 01:00:55,700
如果 C 和 A B 之间有某种通信，

873
01:00:55,730 --> 01:00:57,770
我们待会再谈这个问题，

874
01:00:57,770 --> 01:00:59,960
但是如果 C 没有和 A B 通信，

875
01:01:00,170 --> 01:01:03,200
它可能会，

876
01:01:03,230 --> 01:01:05,360
可能会是这种情况，

877
01:01:05,360 --> 01:01:08,540
它安装了旧版本的 auth.py ，

878
01:01:08,540 --> 01:01:09,950
新版本的 bank.py 。

879
01:01:10,640 --> 01:01:11,540
我们稍后会看到，

880
01:01:11,540 --> 01:01:12,950
如果我们把 fetch 放进去，

881
01:01:13,010 --> 01:01:14,510
那么这种情况不会发生。

882
01:01:17,720 --> 01:01:19,970
有人问，如果给每个东西都加了时间戳，

883
01:01:19,970 --> 01:01:21,560
然后我们检测东西，

884
01:01:21,590 --> 01:01:22,790
这个想法先稍等一下。

885
01:01:25,450 --> 01:01:29,560
好的，让我们看看包含 fetch 的场景，

886
01:01:29,770 --> 01:01:32,140
所以看看在这种情况下会发生什么，

887
01:01:32,260 --> 01:01:38,860
所以，客户端获取 auth.py 。

888
01:01:41,740 --> 01:01:42,940
糟糕，现在发生了什么。

889
01:01:48,660 --> 01:01:53,030
稍等一下，出了点问题。

890
01:01:53,780 --> 01:01:56,390
我想现在没人能看到我的屏幕。

891
01:02:03,010 --> 01:02:03,820
它是黑的。

892
01:02:03,850 --> 01:02:06,040
是的，稍等一下，回来。

893
01:02:10,850 --> 01:02:15,620
我今天绝对觉得， 6.824 有一个拜占庭的成分。

894
01:02:32,480 --> 01:02:34,490
好的，我需要暂停一下分享屏幕。

895
01:03:21,610 --> 01:03:23,080
好的，希望我们回来了。

896
01:03:24,730 --> 01:03:25,900
好的。

897
01:03:32,090 --> 01:03:36,440
好的，回到这个例子，

898
01:03:36,470 --> 01:03:38,180
现在 fetch 在日志中，

899
01:03:38,180 --> 01:03:40,220
C 获取 auth.py 。

900
01:03:42,300 --> 01:03:46,830
所以让我继续，

901
01:03:48,960 --> 01:03:50,250
把这个保存下来。

902
01:03:51,730 --> 01:03:54,010
C 获取 auth.py ，

903
01:03:54,100 --> 01:03:57,280
服务器发送前缀，

904
01:04:03,180 --> 01:04:06,870
所以发送这些修改，

905
01:04:06,870 --> 01:04:09,900
服务器可以返回它想返回的任何内容，

906
01:04:09,930 --> 01:04:13,110
然后，在这个新的方案中，

907
01:04:13,110 --> 01:04:15,270
fetch 是日志，

908
01:04:15,540 --> 01:04:20,100
然后， C 使用 A 和 B 构建文件系统，

909
01:04:20,310 --> 01:04:24,900
然后将 auth.py 返回给客户端，

910
01:04:24,900 --> 01:04:27,570
客户端或应用程序，

911
01:04:27,810 --> 01:04:33,450
然后它向日志中添加一个 fetch ，

912
01:04:35,720 --> 01:04:43,100
并将那个日志上传到服务器，

913
01:04:43,340 --> 01:04:49,270
然后是一个获取 bank.py ，

914
01:04:51,760 --> 01:04:54,220
服务器，

915
01:04:54,220 --> 01:04:57,340
在前面的例子中，

916
01:04:57,640 --> 01:05:00,760
首先，它只发送一个前缀，

917
01:05:01,730 --> 01:05:02,870
所以这里是前缀，

918
01:05:05,050 --> 01:05:10,350
现在客户端发送整个东西，

919
01:05:10,350 --> 01:05:12,450
发送整个日志，

920
01:05:13,440 --> 01:05:18,300
但是如果修改在，

921
01:05:18,810 --> 01:05:20,880
我们必须发送整个日志，

922
01:05:20,880 --> 01:05:21,810
我们发送整个日志，

923
01:05:21,810 --> 01:05:24,720
并且必须包括 fetch C ，

924
01:05:25,080 --> 01:05:32,250
如果它没有发送 fetch C ，

925
01:05:32,250 --> 01:05:39,000
那么 C 的读取操作不在那里，

926
01:05:39,330 --> 01:05:44,580
客户端将会拒绝该日志，

927
01:05:44,580 --> 01:05:47,130
因为它自己的 fetch 操作不在其中，

928
01:05:47,340 --> 01:05:52,080
所以服务器不可能认为，

929
01:05:52,080 --> 01:05:54,540
为了稍后发送日志，

930
01:05:54,540 --> 01:05:58,230
因为新日志应该包括那个 fetch 操作，

931
01:05:58,530 --> 01:06:01,800
它在里面，并更新 C ，

932
01:06:01,800 --> 01:06:05,160
或者服务器不能将该 fetch 操作加倍到这里，

933
01:06:05,580 --> 01:06:08,940
为了让它与之前发生的保持一致，

934
01:06:09,120 --> 01:06:10,890
因为这会被检测到，

935
01:06:10,920 --> 01:06:14,370
因为 A 和 B 记录上的修改不是，

936
01:06:14,370 --> 01:06:15,630
不会检查出来。

937
01:06:18,420 --> 01:06:22,800
好的，所以这是在退后一步，

938
01:06:22,920 --> 01:06:24,720
你可以考虑这次攻击，

939
01:06:24,720 --> 01:06:29,910
服务器会认为 A 和 B 的修改同时发生，

940
01:06:30,120 --> 01:06:31,950
当 C 读取它时，

941
01:06:32,100 --> 01:06:34,530
即使我们事实并非如此，

942
01:06:34,530 --> 01:06:36,150
通过说 fetch 在它里面，

943
01:06:36,360 --> 01:06:38,820
这种攻击不能发生。

944
01:06:43,440 --> 01:06:46,020
我有两个问题，

945
01:06:46,080 --> 01:06:47,970
首先，

946
01:06:48,120 --> 01:06:52,920
如果你可以定义 fork 一致性和 fetch modify 一致性。

947
01:06:52,920 --> 01:06:54,030
然后第二个是，

948
01:06:54,360 --> 01:06:55,680
在这个例子中，

949
01:06:55,710 --> 01:07:03,580
是什么阻止服务器将 fetch 放在日志的正确位置？

950
01:07:03,820 --> 01:07:09,030
因为记得每个日志条目都包含其之前的所有条目。

951
01:07:09,660 --> 01:07:10,530
好的，那么如果。

952
01:07:10,530 --> 01:07:14,070
服务器不能切片，

953
01:07:14,070 --> 01:07:17,910
fetch 在修改 A 和 B 之前的前缀之后。

954
01:07:18,860 --> 01:07:21,260
所以，假设它只想发送 A 的修改，

955
01:07:21,260 --> 01:07:24,650
它知道 A 的修改和它之前的所有内容的哈希，

956
01:07:25,040 --> 01:07:27,680
然后它可以把 fetch C 插入到那里，

957
01:07:27,680 --> 01:07:28,610
因为它知道，

958
01:07:29,180 --> 01:07:31,100
这是一个哈希。

959
01:07:31,100 --> 01:07:32,240
然后他们就不能发送。

960
01:07:32,270 --> 01:07:34,340
是的，然后他们就不能发送 B 的修改，

961
01:07:36,410 --> 01:07:39,560
因为 B 的修改直接在 A 之后，

962
01:07:39,590 --> 01:07:40,700
所以 A 必须，

963
01:07:40,700 --> 01:07:43,100
所以它也不能切分 A 和 B 。

964
01:07:44,490 --> 01:07:45,450
我明白了，好的。

965
01:07:49,580 --> 01:07:53,270
抱歉，图片上有什么问题吗？

966
01:07:55,470 --> 01:07:57,300
好的，现在的图片是完美的，

967
01:07:57,360 --> 01:07:58,650
它是好的，

968
01:07:58,710 --> 01:08:00,630
事实上，这表明，

969
01:08:00,630 --> 01:08:04,620
fetch C 已经包括 A 和 B 的修改，

970
01:08:04,620 --> 01:08:06,000
蓝色的是真正的日志，

971
01:08:06,760 --> 01:08:09,160
我们在其中有 fetch C ，

972
01:08:09,160 --> 01:08:11,680
一切都是完美的。

973
01:08:18,660 --> 01:08:21,570
所以我想确认一下 fork 一致性的定义。

974
01:08:21,570 --> 01:08:23,940
好的，等一下，因为我还没讲过这张幻灯片，

975
01:08:25,650 --> 01:08:27,720
我还没有谈到 fork 一致性的定义，

976
01:08:27,720 --> 01:08:28,710
我现在就要这么做。

977
01:08:30,450 --> 01:08:30,990
好的?

978
01:08:32,860 --> 01:08:35,050
所以我们将谈论 fork 一致性。

979
01:08:43,980 --> 01:08:47,640
所以，到目前为止我们所看到的是，

980
01:08:47,640 --> 01:08:50,700
服务器不能真正操作日志，

981
01:08:50,700 --> 01:08:53,580
它只能发送前缀或隐藏部分，

982
01:08:53,580 --> 01:08:57,930
它可以将前缀发送回客户端，

983
01:08:58,110 --> 01:09:00,000
但它并不能修改日志，

984
01:09:00,030 --> 01:09:01,650
所以有机会

985
01:09:01,650 --> 01:09:06,450
向不同客户端显示不同的日志，

986
01:09:06,450 --> 01:09:10,020
这就是 fork 一致性的含义。

987
01:09:10,320 --> 01:09:12,870
所以它不能提供那种，

988
01:09:13,050 --> 01:09:15,450
服务器不能提供那种一致性，

989
01:09:15,450 --> 01:09:16,860
我们在过去看到的那种，

990
01:09:16,860 --> 01:09:19,920
也就是线性一致性和外部一致性等东西，

991
01:09:19,920 --> 01:09:21,000
这是不可能的，

992
01:09:21,450 --> 01:09:22,620
但它可以提供这个，

993
01:09:22,620 --> 01:09:26,220
这就是本文所说的或介绍的是 fork 一致性。

994
01:09:26,490 --> 01:09:30,090
让我稍微抽象一下，来解释一下这是什么。

995
01:09:30,620 --> 01:09:32,450
假设我们有客户端 A ，

996
01:09:32,780 --> 01:09:34,520
我们有服务器 S ，

997
01:09:35,280 --> 01:09:37,290
它有一个日志，

998
01:09:39,150 --> 01:09:41,550
比如，我要把所有东西列出来，

999
01:09:41,550 --> 01:09:43,440
它有条目 A B C D 和 E ，

1000
01:09:45,540 --> 01:09:50,310
A 追加条目到日志中，

1001
01:09:50,460 --> 01:09:56,220
这基本上就是[]。

1002
01:09:56,490 --> 01:09:58,890
也许我们还有另一个客户端 B ，

1003
01:10:00,830 --> 01:10:03,710
服务器所能做的

1004
01:10:03,830 --> 01:10:07,880
让另一个客户端看到一个完全不同的世界，

1005
01:10:07,940 --> 01:10:10,220
通过日志的另一个副本

1006
01:10:11,340 --> 01:10:12,150
或者它自己的副本

1007
01:10:12,150 --> 01:10:14,040
或者给出一个不同的日志副本，

1008
01:10:14,040 --> 01:10:16,650
例如，日志可能包含记录 A ，

1009
01:10:17,150 --> 01:10:19,610
但 B 做的每一次操作，

1010
01:10:19,730 --> 01:10:22,790
进入这个日志， B1 B2 ，

1011
01:10:22,820 --> 01:10:25,940
可能来自其他客户端的一些操作，也会获得这个，

1012
01:10:26,030 --> 01:10:27,170
最后出现在这个日志中，

1013
01:10:27,320 --> 01:10:29,390
但是它们并没有展示给 A ，

1014
01:10:29,880 --> 01:10:34,020
A 也可能添加更多的条目到日志中，

1015
01:10:34,020 --> 01:10:35,850
比如它可能有 B C 和 E ，

1016
01:10:36,090 --> 01:10:39,270
而这些并没有显示给 B ，

1017
01:10:39,600 --> 01:10:43,590
所以这两个日志到 A 的视图，

1018
01:10:43,590 --> 01:10:45,060
是完全一致的，

1019
01:10:45,120 --> 01:10:47,430
因为它没有意识到任何这些变化，

1020
01:10:48,000 --> 01:10:50,640
对于 B ，这个日志看起来完全一致，

1021
01:10:50,640 --> 01:10:53,250
因为它们没有意识到任何 A 的变化，

1022
01:10:54,330 --> 01:10:55,890
在这个世界模型中，

1023
01:10:55,980 --> 01:11:00,240
唯一的共享通信的地方是服务器，

1024
01:11:00,270 --> 01:11:01,500
这是一种，

1025
01:11:01,740 --> 01:11:04,650
展示的东西，

1026
01:11:04,650 --> 01:11:06,780
什么是系统的状态。

1027
01:11:07,600 --> 01:11:09,940
你可以考虑的一种方式是，

1028
01:11:09,940 --> 01:11:12,070
就像我们之前讨论过的那样，

1029
01:11:12,100 --> 01:11:13,540
这有点像脑裂，

1030
01:11:16,720 --> 01:11:21,760
A 可以看到一个世界，

1031
01:11:21,760 --> 01:11:25,990
这与 A 的视角是一致的，

1032
01:11:26,230 --> 01:11:28,690
对于 B ，是另一个世界视角，

1033
01:11:29,330 --> 01:11:32,690
服务器小心地把它们分开，

1034
01:11:32,900 --> 01:11:36,260
因此可以认为，

1035
01:11:36,260 --> 01:11:40,130
A 看到脑裂的左侧，

1036
01:11:40,160 --> 01:11:42,800
B 看到是脑裂的右侧。

1037
01:11:43,930 --> 01:11:44,980
好的？

1038
01:11:45,900 --> 01:11:46,650
这能理解吗？

1039
01:11:50,220 --> 01:11:52,230
这就是他们所说的，

1040
01:11:52,230 --> 01:11:55,230
我们不能做得比 fork 一致性更好，

1041
01:11:55,260 --> 01:12:02,130
因为服务器总是有可能复制一份日志，

1042
01:12:02,400 --> 01:12:06,840
然后从那时起，为这些客户端提供不同的视角。

1043
01:12:07,300 --> 01:12:10,780
现在， S 无法再次合并这两个日志，

1044
01:12:10,810 --> 01:12:13,600
对于 A 和 B ，这些日志必须分开，

1045
01:12:13,900 --> 01:12:14,920
因为这可能，

1046
01:12:14,920 --> 01:12:18,340
S 不可能使用日志，

1047
01:12:18,340 --> 01:12:19,720
让它们更长一点，

1048
01:12:19,840 --> 01:12:22,420
然后再把这两个日志拼接在一起，

1049
01:12:23,040 --> 01:12:28,200
因为这些条目应该保护所有前面的条目，

1050
01:12:28,200 --> 01:12:30,660
使用这些条目保护前面的所有条目，

1051
01:12:30,840 --> 01:12:32,880
所以你不能把它们放在一起，

1052
01:12:34,000 --> 01:12:35,620
因为签名不能通过，

1053
01:12:35,620 --> 01:12:38,980
因为签名总是覆盖当前条目和所有之前条目。

1054
01:12:40,470 --> 01:12:42,630
所以，他们要做的唯一一件事，

1055
01:12:42,630 --> 01:12:44,310
服务器可以

1056
01:12:44,340 --> 01:12:50,010
将世界分成两个不同的日志，

1057
01:12:51,060 --> 01:12:52,830
它们可能在开始时有一个共同的日志，

1058
01:12:52,890 --> 01:12:54,360
然后 fork 它们，

1059
01:12:54,480 --> 01:12:57,690
现在， A 和 B 在不同的世界运行。

1060
01:13:01,500 --> 01:13:04,320
所以，这就是 fork 一致性的定义，

1061
01:13:04,320 --> 01:13:05,700
这基本上是最好的，

1062
01:13:05,700 --> 01:13:09,120
这个文件系所能做的，

1063
01:13:09,180 --> 01:13:12,600
唯一的通信发生在 S 之间。

1064
01:13:15,270 --> 01:13:16,680
顺便说一句，

1065
01:13:16,860 --> 01:13:18,780
这种 fork 一致性足够，

1066
01:13:18,780 --> 01:13:20,910
对于我们的特定应用程序 zookeeper ，

1067
01:13:21,330 --> 01:13:28,290
因为，要么服务器显示旧版本，没有 A B ，

1068
01:13:28,710 --> 01:13:33,930
或者服务器显示 S 的 A 和 B 的修改。

1069
01:13:37,530 --> 01:13:39,060
好的，那你要怎么做，

1070
01:13:39,330 --> 01:13:41,580
这看起来是个问题，

1071
01:13:41,580 --> 01:13:43,800
你如何检测 fork ，

1072
01:13:44,580 --> 01:13:53,110
如何检测 fork 。

1073
01:13:53,110 --> 01:13:57,400
这篇论文提到了两个方案，

1074
01:13:57,730 --> 01:14:00,340
一种是带外通信，

1075
01:14:10,320 --> 01:14:11,580
这很简单，

1076
01:14:12,150 --> 01:14:15,780
如果 A 和 B 互相通信，

1077
01:14:16,530 --> 01:14:17,940
比如询问对方，

1078
01:14:17,970 --> 01:14:19,800
你在日志里的最后一条记录是什么，

1079
01:14:20,220 --> 01:14:21,840
它们得到不同的答案，

1080
01:14:22,540 --> 01:14:25,660
它们知道他们被分叉了，

1081
01:14:25,690 --> 01:14:28,750
因为它们可能会有不同的答案，

1082
01:14:28,750 --> 01:14:31,930
但至少其中一个应该是另一个的前缀，

1083
01:14:32,430 --> 01:14:34,140
如果不是这样的话，

1084
01:14:34,200 --> 01:14:37,530
然后它们就会知道它们分叉了。

1085
01:14:40,760 --> 01:14:45,710
所以，这是他们在论文中讨论的一种可能的情况，

1086
01:14:45,710 --> 01:14:51,830
客户端定期交换的最新的日志条目，

1087
01:14:52,730 --> 01:14:54,410
它们日志中的最后一条记录。

1088
01:14:54,560 --> 01:14:58,850
聊天中已经提到的另一个解决方案是，

1089
01:14:59,800 --> 01:15:02,440
引入了他们所说的某种受信任的机器，

1090
01:15:02,740 --> 01:15:06,370
也就是时间戳机器，

1091
01:15:08,500 --> 01:15:10,870
基本上每隔几秒钟，

1092
01:15:10,870 --> 01:15:14,650
它将时间戳添加到日志中，

1093
01:15:14,920 --> 01:15:20,560
每个客户端知道它是一个文件，

1094
01:15:20,560 --> 01:15:23,590
在文件系统中，包含当前时间，

1095
01:15:23,710 --> 01:15:26,080
每次时间戳机器，

1096
01:15:26,080 --> 01:15:29,260
每隔几秒时间戳机器就会更新一次文件，

1097
01:15:29,470 --> 01:15:31,180
客户端读取该文件，

1098
01:15:31,270 --> 01:15:34,390
它们知道每隔几秒钟就会有一次新的修改，

1099
01:15:35,170 --> 01:15:37,930
基本上这个 fork ，

1100
01:15:37,960 --> 01:15:41,290
包含时间戳盒的是那个 fork ，

1101
01:15:41,290 --> 01:15:47,920
客户端，服务器呈现给客户端的。

1102
01:15:51,800 --> 01:15:52,430
好的?

1103
01:15:53,720 --> 01:15:56,150
这就是这篇论文讨论的两件事，

1104
01:15:56,360 --> 01:15:58,970
我们将在周二看到有趣的，

1105
01:15:59,090 --> 01:16:03,680
这个 fork 检测方法，

1106
01:16:03,680 --> 01:16:05,960
是比特币的一个关键问题，

1107
01:16:06,920 --> 01:16:08,810
我们将在周二讨论，

1108
01:16:08,810 --> 01:16:13,130
但是比特币，我们会看到一种解决 fork 的方法，

1109
01:16:15,650 --> 01:16:18,230
所以，即使文件系统或服务器，

1110
01:16:18,230 --> 01:16:21,530
拜占庭服务器已经创建了一个 fork ，

1111
01:16:21,800 --> 01:16:24,560
比特币有一种方式来决定，

1112
01:16:24,560 --> 01:16:26,330
好的，我们将读取共识，

1113
01:16:26,330 --> 01:16:28,340
哪个 fork 将会继续。

1114
01:16:29,480 --> 01:16:32,960
所以我们把这件事留到周二，

1115
01:16:32,960 --> 01:16:38,120
但这是 SUNDR 和比特币之间的某种联系。

1116
01:16:40,940 --> 01:16:41,870
对于这个，有什么问题吗？

1117
01:16:50,050 --> 01:16:50,590
好的。

1118
01:16:51,640 --> 01:16:53,170
好的，我想说得很快，

1119
01:16:53,170 --> 01:16:54,580
因为我只剩三分钟了，

1120
01:16:54,610 --> 01:16:59,400
关于另一个，

1121
01:16:59,400 --> 01:17:01,590
所以我认为这篇论文的关键是

1122
01:17:01,590 --> 01:17:04,350
这个关于世界的日志概念观，

1123
01:17:05,100 --> 01:17:08,160
当然，我前面提到的不切实际的，

1124
01:17:08,310 --> 01:17:10,980
所以，一些人提出了如何做得更好的建议，

1125
01:17:11,250 --> 01:17:14,760
即使其他系统维护整个日志，

1126
01:17:14,850 --> 01:17:18,030
那么，其他人怎么把事情做好呢，

1127
01:17:18,210 --> 01:17:19,800
不是维护日志，

1128
01:17:19,800 --> 01:17:21,480
而是维护快照，

1129
01:17:22,240 --> 01:17:24,850
类似于某种快照，

1130
01:17:24,850 --> 01:17:26,800
我们之前在 Raft 中看到的，

1131
01:17:26,800 --> 01:17:30,340
我们以日志为基础构建世界的一部分，

1132
01:17:30,340 --> 01:17:31,420
我们创建一个快照，

1133
01:17:31,420 --> 01:17:34,210
这形成了当前的状态，

1134
01:17:34,390 --> 01:17:37,540
事实上， SUNDR 所做的，

1135
01:17:37,540 --> 01:17:39,580
它不是从字面上创建快照，

1136
01:17:39,580 --> 01:17:42,430
它维护着文件系统的快照视图，

1137
01:17:42,550 --> 01:17:43,720
并针对每个用户。

1138
01:17:46,200 --> 01:17:47,520
所以考虑这个问题的一种方式是，

1139
01:17:47,520 --> 01:17:49,920
文件系统按用户进行分片，

1140
01:17:49,980 --> 01:17:52,980
每个用户都有自己的世界视图快照，

1141
01:17:53,310 --> 01:17:55,200
这里有一些协议，

1142
01:17:55,200 --> 01:18:00,420
确保不同的快照和不同的用户是一致的。

1143
01:18:00,420 --> 01:18:04,650
让我来谈一谈，

1144
01:18:04,710 --> 01:18:08,520
SUNDR 是如何创建快照的。

1145
01:18:10,050 --> 01:18:12,780
基本上在 SUNDR 中，

1146
01:18:15,310 --> 01:18:17,860
SUNDR 有一种叫做用户 i-handle 的东西，

1147
01:18:18,680 --> 01:18:22,880
并且用户 i-handle 唯一地标识文件系统中的快照，

1148
01:18:23,150 --> 01:18:27,250
并且是 i-table 的加密哈希，

1149
01:18:27,250 --> 01:18:29,560
它完成了系统中的所有 inode ，

1150
01:18:29,890 --> 01:18:33,190
对于每个 inode ，

1151
01:18:33,190 --> 01:18:34,330
有一个哈希 inode ，

1152
01:18:34,330 --> 01:18:38,500
它涵盖了这个 inode 所有数据，所有数据块，

1153
01:18:39,270 --> 01:18:45,960
例如，假设 A 在我的写入块中修改 auth.py ，

1154
01:18:46,290 --> 01:18:50,160
客户端重新计算该块的哈希值，

1155
01:18:50,190 --> 01:18:55,260
更新这里的条目，更新这里的条目，更新这里的条目，

1156
01:18:55,320 --> 01:18:57,240
这是一个新的 handle ，

1157
01:18:57,420 --> 01:19:01,800
这描述了，是对完整文件系统的快照，

1158
01:19:02,070 --> 01:19:06,660
我们将暂时忽略目录块中的组，

1159
01:19:06,660 --> 01:19:09,990
所以这给了你一个完整的检查点，

1160
01:19:09,990 --> 01:19:14,460
用户的快照来查看文件系统。

1161
01:19:16,780 --> 01:19:19,780
为了处理这个问题，

1162
01:19:19,780 --> 01:19:23,740
如何在用户之间获得某种一致性，

1163
01:19:24,070 --> 01:19:26,650
他们有这个版本向量的概念。

1164
01:19:33,840 --> 01:19:36,030
版本向量非常简单，

1165
01:19:36,630 --> 01:19:39,240
每个版本向量都有一个 i-handle ，

1166
01:19:39,240 --> 01:19:40,860
比如 A 有一个 i-handle ，

1167
01:19:41,100 --> 01:19:46,900
在它修改 auth.py 之后，

1168
01:19:46,960 --> 01:19:49,960
然后对于系统中的每个用户，

1169
01:19:50,080 --> 01:19:53,260
版本向量具有修改次数的计数器，

1170
01:19:53,260 --> 01:19:54,310
由该用户进行的修改，

1171
01:19:54,400 --> 01:19:57,400
所以，如果 A 更新了 auth.py ，

1172
01:19:57,610 --> 01:19:58,840
则该计数器被设置为 1 ，

1173
01:19:59,110 --> 01:20:01,270
B 没有做任何修改，

1174
01:20:01,270 --> 01:20:02,890
C 没有做任何修改，

1175
01:20:03,190 --> 01:20:04,420
就是 0 0 ，

1176
01:20:04,420 --> 01:20:06,130
这整个东西都是签名的。

1177
01:20:09,620 --> 01:20:12,050
所以，当 B 进行修改时，

1178
01:20:12,050 --> 01:20:13,640
所以我们使用 B 的版本向量，

1179
01:20:14,240 --> 01:20:17,270
A 版本向量， B 版本向量，

1180
01:20:17,900 --> 01:20:19,340
它会创建一个新的 handle ，

1181
01:20:20,030 --> 01:20:24,650
当然，这包括所有的修改，

1182
01:20:25,070 --> 01:20:26,480
并且在它的版本 handle 中，

1183
01:20:26,600 --> 01:20:28,220
它打开了它的版本向量，

1184
01:20:28,250 --> 01:20:31,760
它包括用户读取了多少操作，

1185
01:20:31,760 --> 01:20:33,020
所以它会记录这个事实，

1186
01:20:33,020 --> 01:20:36,530
比如它看到了 A 的修改，

1187
01:20:36,800 --> 01:20:40,160
它更新 B 为 1 ， C 为 0 ，

1188
01:20:40,370 --> 01:20:41,960
并且对整个事情签名。

1189
01:20:44,740 --> 01:20:49,300
当 C 执行操作时，

1190
01:20:49,300 --> 01:20:51,400
想要读取 auth.py ，

1191
01:20:51,400 --> 01:20:57,220
并且获取 bank.py ，

1192
01:20:57,280 --> 01:21:00,760
它下载每个用户的所有版本向量，

1193
01:21:00,790 --> 01:21:02,590
在这种情况下，

1194
01:21:02,590 --> 01:21:05,230
它将获得 A 和 B 的版本向量，

1195
01:21:06,250 --> 01:21:08,860
取最新的一个，在本例中是 B ，

1196
01:21:09,250 --> 01:21:12,730
因为它包含了 A 的所有操作，

1197
01:21:13,180 --> 01:21:16,000
这代表了文件系统的版本，

1198
01:21:16,000 --> 01:21:20,920
从那个版本，它读取 auth.py 和 bank.py ，

1199
01:21:24,280 --> 01:21:27,400
注意，服务器不可能

1200
01:21:27,640 --> 01:21:34,420
只显示 bank.py ，而不是 auth.py ，

1201
01:21:34,420 --> 01:21:36,160
因为你知道它不能，

1202
01:21:36,250 --> 01:21:39,640
因为它只能返回的版本向量是，

1203
01:21:39,640 --> 01:21:41,590
这个版本向量或这个版本向量，

1204
01:21:41,710 --> 01:21:46,690
版本向量 A 不包括 bank.py 的修改，

1205
01:21:46,870 --> 01:21:50,350
如果 C 得到了这个版本的 bank.py ，

1206
01:21:50,500 --> 01:21:54,520
它必须有版本，修改是 A 所做的，

1207
01:21:54,790 --> 01:21:56,980
因为版本向量是以这种方式构造的。

1208
01:21:58,840 --> 01:22:03,100
所以这就是使用版本向量的方法，

1209
01:22:03,160 --> 01:22:07,600
为了检测 S 不会丢弃更改，

1210
01:22:07,720 --> 01:22:10,540
跟日志系统所使用的方式一样.

1211
01:22:12,120 --> 01:22:14,370
好的，这就是版本向量方案的本质。

1212
01:22:16,770 --> 01:22:18,480
所以，总结。

1213
01:22:22,870 --> 01:22:28,330
好的，拜占庭式的参与者是一个问题，

1214
01:22:28,330 --> 01:22:31,960
你必须在去中心化系统中处理的，

1215
01:22:34,040 --> 01:22:37,640
因为没有单一的机构，

1216
01:22:37,640 --> 01:22:39,290
它可以成为信任的来源，

1217
01:22:40,520 --> 01:22:42,650
我们已经看到了这种签名日志的概念，

1218
01:22:42,800 --> 01:22:48,830
它是对付恶意服务器的一个非常强大的工具。

1219
01:22:49,490 --> 01:22:52,670
就像我说的，在周二，

1220
01:22:52,670 --> 01:22:54,350
我们将继续讨论这个问题，

1221
01:22:54,560 --> 01:22:58,880
你会看到这个设计日志是如何在比特币中使用的，

1222
01:22:58,940 --> 01:23:01,130
特别是比如 fork 一致性，

1223
01:23:01,130 --> 01:23:05,210
fork 是如何被创建的，

1224
01:23:05,240 --> 01:23:07,910
在比特币的案例中是如何解决的。

1225
01:23:08,700 --> 01:23:12,900
好的，这就是对去中心化系统的介绍，

1226
01:23:13,230 --> 01:23:17,880
我希望这篇论文能更容易理解，

1227
01:23:17,880 --> 01:23:23,130
比你本周早些时候或今天开始阅读它之前要好。

1228
01:23:23,530 --> 01:23:25,510
好的，周二见。

1229
01:23:26,960 --> 01:23:31,130
当然，如果有问题，请随意停留，

1230
01:23:31,400 --> 01:23:34,670
如果你需要去别的地方，可以去别的地方。

1231
01:23:36,020 --> 01:23:38,720
我有一个关于数据结构的问题，

1232
01:23:38,720 --> 01:23:42,650
他们使用B+树或其他什么，

1233
01:23:42,650 --> 01:23:45,020
像这样有什么不同，

1234
01:23:45,930 --> 01:23:48,330
比如 Merkle ，

1235
01:23:48,450 --> 01:23:49,710
使用 Merkle 数据结构，

1236
01:23:49,920 --> 01:23:54,810
我认为那个人的名字叫 Merkle ，

1237
01:23:55,360 --> 01:23:58,150
这就是为什么它叫 Merkle 树？

1238
01:24:00,180 --> 01:24:01,620
所以这是一回事？

1239
01:24:03,180 --> 01:24:03,750
好的。

1240
01:24:04,230 --> 01:24:05,790
SUNDR 使用了 Merkle 树。

1241
01:24:11,900 --> 01:24:18,010
抱歉，当你验证签名时，

1242
01:24:18,250 --> 01:24:19,330
是不是意味着你必须，

1243
01:24:19,330 --> 01:24:22,520
比如，在你执行的时候，

1244
01:24:22,520 --> 01:24:25,820
如果在日志中有 100 个条目，

1245
01:24:26,210 --> 01:24:31,400
你必须计算所有 100 个条目的哈希，

1246
01:24:31,400 --> 01:24:34,780
连接然后计算。

1247
01:24:34,780 --> 01:24:36,790
是的，你需要一个运行的哈希，

1248
01:24:36,820 --> 01:24:38,410
好的，我们回去核实一下，

1249
01:24:45,650 --> 01:24:47,870
好的，这里可能是一个谈论它的好地方。

1250
01:24:48,580 --> 01:24:52,880
所以，在这里，

1251
01:24:53,410 --> 01:24:56,080
让我们来看最后一个条目，

1252
01:24:57,560 --> 01:25:02,390
最后的条目将会有之前条目的哈希，

1253
01:25:03,890 --> 01:25:06,350
所以从记录中的任何东西，

1254
01:25:06,470 --> 01:25:10,640
假设这是 0 1 和 2 ，

1255
01:25:12,000 --> 01:25:18,500
其中有前一个条目 2 的哈希，

1256
01:25:18,500 --> 01:25:21,890
这是需要检查的。

1257
01:25:22,640 --> 01:25:27,440
而被检查的方式是，

1258
01:25:27,440 --> 01:25:30,590
原则上，如果你从世界之初开始，

1259
01:25:30,800 --> 01:25:33,470
你必须计算记录为 0 的哈希，

1260
01:25:33,590 --> 01:25:34,940
你会发现哈希是什么，

1261
01:25:35,240 --> 01:25:40,550
并仔细检查与条目对应的条目，

1262
01:25:40,550 --> 01:25:44,490
它在这里，以及签名是否有效，等等。

1263
01:25:46,160 --> 01:25:47,990
当然，在真实的系统中，

1264
01:25:47,990 --> 01:25:49,610
你可以记住大部分的日志，

1265
01:25:50,000 --> 01:25:51,560
再仔细检查一下，

1266
01:25:51,560 --> 01:25:53,630
然后从那里开始。

1267
01:25:56,140 --> 01:25:58,920
哦，这效率太低了，好吧。

1268
01:25:59,530 --> 01:26:01,300
是的，你必须从头开始回放，

1269
01:26:01,300 --> 01:26:04,270
你必须从一开始验证整个日志。

1270
01:26:06,760 --> 01:26:08,290
谢谢，理解了。

1271
01:26:08,350 --> 01:26:10,120
你会在比特币论文上看到这一点。

1272
01:26:11,040 --> 01:26:15,030
所以哈希是，就像一条 Merkle 链。

1273
01:26:15,030 --> 01:26:15,510
是的。

1274
01:26:15,900 --> 01:26:16,500
好的。

1275
01:26:17,010 --> 01:26:17,760
同样的想法。

1276
01:26:18,780 --> 01:26:20,880
那么，它们是不是

1277
01:26:22,870 --> 01:26:29,650
比如树或链上的叶子，

1278
01:26:29,680 --> 01:26:32,920
是整个文件或文件块。

1279
01:26:32,950 --> 01:26:34,210
这是一个块，

1280
01:26:34,210 --> 01:26:36,370
所以这是 4096 个字节，

1281
01:26:43,680 --> 01:26:45,300
所有其他哈希都不会改变，

1282
01:26:45,300 --> 01:26:47,580
所以它并不是那么低效。

1283
01:26:48,150 --> 01:26:50,010
因为如果你只更改文件的一部分，

1284
01:26:50,010 --> 01:26:51,510
只对这一部分的重新哈希。

1285
01:26:51,540 --> 01:26:52,740
是的，你只需要重新哈希那个，

1286
01:26:52,740 --> 01:26:55,260
然后你必须重新计算树的哈希，

1287
01:26:56,590 --> 01:26:58,090
一直到用户的 i-handle 。

1288
01:27:02,760 --> 01:27:03,570
这篇论文谈到，

1289
01:27:03,570 --> 01:27:06,180
有一种优化可以使这一过程更有效率，

1290
01:27:06,240 --> 01:27:09,000
但哈希通常并不那么昂贵，

1291
01:27:09,000 --> 01:27:11,250
签名是一项成本更高的操作。

1292
01:27:18,480 --> 01:27:20,190
我有一个关于版本向量的问题，

1293
01:27:21,270 --> 01:27:23,010
所以，我们使用版本向量

1294
01:27:23,010 --> 01:27:25,560
来确保系统不会返回旧状态，

1295
01:27:25,800 --> 01:27:29,850
为什么系统不能直接返回旧状态和旧版本向量，

1296
01:27:29,850 --> 01:27:31,470
如果它保留第二份复制的话。

1297
01:27:32,040 --> 01:27:34,210
是的， fork ，是吗？

1298
01:27:34,210 --> 01:27:36,370
所以，我们只有 fork 一致性。

1299
01:27:36,520 --> 01:27:38,950
是的，版本向量只有 fork 一致性，

1300
01:27:39,220 --> 01:27:40,930
SUNDR fork 一致性，没有更多。

1301
01:27:47,460 --> 01:27:50,100
所以 fork 一致性，你需要时间戳吗？

1302
01:27:50,530 --> 01:27:52,330
fork 一致性，我的意思是，

1303
01:27:52,360 --> 01:27:59,680
服务器可以在任何时间点 fork 日志，

1304
01:28:00,900 --> 01:28:05,550
为它们可以将日志合并回一起提供一致的视图。

1305
01:28:07,850 --> 01:28:10,430
所以，这张图片，

1306
01:28:11,290 --> 01:28:15,970
服务器可以构建不同的世界观，

1307
01:28:16,210 --> 01:28:18,910
分裂为多个世界，

1308
01:28:19,210 --> 01:28:24,450
但可以在不被察觉的情况下重新合并在一起。

1309
01:28:27,170 --> 01:28:31,520
所以，我们能做的最好的就是保持 fork 一致性，

1310
01:28:31,610 --> 01:28:33,200
它允许 fork ，

1311
01:28:33,260 --> 01:28:34,850
但我们可以检测到 fork 。

1312
01:28:36,090 --> 01:28:37,620
所以如果我们检测到 fork ，

1313
01:28:38,360 --> 01:28:40,970
那么我们能得到比 fork 一致性更强的东西吗？

1314
01:28:40,970 --> 01:28:43,640
好的，是的，我们可以选一个 fork ，

1315
01:28:43,820 --> 01:28:44,870
我们会有 fork ，

1316
01:28:44,960 --> 01:28:48,560
我们可以选择一个 fork 并继续。

1317
01:28:49,540 --> 01:28:50,320
好的,

1318
01:28:51,370 --> 01:28:54,310
但是 SUNDR 没有办法做到这一点。

1319
01:29:00,230 --> 01:29:04,010
我是说， SUNDR 现在提出了一些方法吗？

1320
01:29:04,340 --> 01:29:05,600
检测的方法，

1321
01:29:05,630 --> 01:29:11,420
提出使用时间戳机器来使用该方法。

1322
01:29:17,210 --> 01:29:17,870
谢谢。

1323
01:29:18,200 --> 01:29:18,740
不用谢。

1324
01:29:20,740 --> 01:29:25,660
时间戳机器只是一个附加条目的服务器？

1325
01:29:25,660 --> 01:29:30,100
是的，并且是可信的，它不在对手的控制之下。

1326
01:29:35,380 --> 01:29:36,100
谢谢。

1327
01:29:38,150 --> 01:29:40,490
我还可以问最后一个问题，

1328
01:29:40,490 --> 01:29:43,250
关于你在开始说的 Debian 的例子，

1329
01:29:43,730 --> 01:29:46,970
你能再说一遍那里发生了什么吗？

1330
01:29:47,120 --> 01:29:48,230
是的，当然，

1331
01:29:48,830 --> 01:29:51,230
所以基本上，

1332
01:29:51,290 --> 01:29:58,040
这是 2003 年 Debian Linux 的源代码仓库或开发机器，

1333
01:29:58,040 --> 01:30:03,590
一名攻击者侵入了这台机器并修改了文件，

1334
01:30:05,430 --> 01:30:07,890
这是个发行版，

1335
01:30:07,890 --> 01:30:09,960
如果你使用的是 Debian Linux ，

1336
01:30:09,960 --> 01:30:11,040
你是，

1337
01:30:11,660 --> 01:30:15,050
任何人在受到攻击后得到 Debian Linux ，

1338
01:30:15,050 --> 01:30:17,150
你可能得到了一个[妥协]的 Debian Linux 。

1339
01:30:17,870 --> 01:30:19,730
当他们很快发现这一点时，

1340
01:30:19,730 --> 01:30:22,610
他们没有做任何进一步的开发，

1341
01:30:22,940 --> 01:30:24,440
延迟了发行版，

1342
01:30:24,440 --> 01:30:26,840
他们去到备份，

1343
01:30:26,840 --> 01:30:31,250
开始将备份中的文件与他们拥有的文件进行比较，

1344
01:30:31,250 --> 01:30:34,010
仔细检所有更改，

1345
01:30:34,010 --> 01:30:36,500
在仓库中的是合法的。

1346
01:30:38,170 --> 01:30:38,500
好的。

1347
01:30:38,500 --> 01:30:40,780
回滚任何不合法的修改。

1348
01:30:42,400 --> 01:30:44,620
那真是太糟糕了。

1349
01:30:44,770 --> 01:30:46,600
是的，那真的很糟糕，

1350
01:30:46,600 --> 01:30:47,560
它偶尔会发生，

1351
01:30:47,560 --> 01:30:48,490
这是一个真正的问题，

1352
01:30:49,760 --> 01:30:51,020
这在实践中是一个真正的问题。

1353
01:30:52,330 --> 01:30:55,000
太感谢了，这节课很有趣，谢谢。

1354
01:30:55,000 --> 01:30:55,450
不用谢。

1355
01:30:56,910 --> 01:30:57,600
谢谢。

