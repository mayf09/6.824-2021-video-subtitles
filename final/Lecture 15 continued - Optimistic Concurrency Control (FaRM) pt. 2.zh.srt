1
00:00:04,350 --> 00:00:09,780
好的，下午好，傍晚好，晚上好，早上好，

2
00:00:10,450 --> 00:00:14,050
无论你在哪个时区收看这个课程。

3
00:00:14,230 --> 00:00:19,450
再次检查声音，大家能听到我说话吗？

4
00:00:25,070 --> 00:00:25,490
是的。

5
00:00:25,640 --> 00:00:26,420
是的。

6
00:00:26,720 --> 00:00:30,770
好的，今天我要谈两件事，

7
00:00:30,770 --> 00:00:33,380
我想结束我们对 FaRM 的讨论，

8
00:00:33,650 --> 00:00:35,360
然后我会讨论 Spark 。

9
00:00:36,380 --> 00:00:38,390
只想提醒大家，

10
00:00:38,390 --> 00:00:41,030
所以每个人，我们（讨论）更多 FaRM ，

11
00:00:41,030 --> 00:00:45,470
我们讨论了执行事务，没有任何失败，

12
00:00:45,800 --> 00:00:48,140
我们看了一个例子，

13
00:00:48,140 --> 00:00:54,230
事务是否提供了外部一致性或严格的可串行化。

14
00:00:54,990 --> 00:00:58,170
所以，我想再谈一个例子，

15
00:00:58,200 --> 00:01:01,200
来讨论可串行化，

16
00:01:01,200 --> 00:01:04,230
然后讨论一下容错，

17
00:01:04,470 --> 00:01:05,970
但在此之前，

18
00:01:05,970 --> 00:01:07,380
提醒一下可能会有帮助，

19
00:01:07,500 --> 00:01:12,210
提醒我们事务是如何工作的，

20
00:01:12,300 --> 00:01:14,730
如果没有故障。

21
00:01:14,730 --> 00:01:17,640
在 FaRM 中，应用程序分为两个阶段，

22
00:01:17,640 --> 00:01:23,220
执行阶段，从不同的分片获取对象，

23
00:01:23,610 --> 00:01:25,350
然后是提交阶段。

24
00:01:25,350 --> 00:01:27,930
所以我们回到这张图片，

25
00:01:28,140 --> 00:01:30,000
有一个执行阶段，

26
00:01:30,000 --> 00:01:34,310
三个对象被读取，

27
00:01:36,520 --> 00:01:39,310
每个来自不同的分片，

28
00:01:39,340 --> 00:01:42,220
我们有分片一，分片二，分片三，

29
00:01:42,490 --> 00:01:44,440
每个分片都有一个备份，

30
00:01:44,440 --> 00:01:46,780
所以，这个系统可以容忍一个故障。

31
00:01:47,890 --> 00:01:52,210
所以一个对象读取，两个对象正在被修改，

32
00:01:52,330 --> 00:01:54,340
正如我们稍后会看到的，

33
00:01:54,760 --> 00:01:59,230
一旦三个对象被读取，两个对象被修改，

34
00:01:59,320 --> 00:02:01,330
应用程序可能决定提交，

35
00:02:01,540 --> 00:02:03,910
然后，整个提交阶段就开始了，

36
00:02:04,180 --> 00:02:08,180
整个故事从第一步到第五步，

37
00:02:09,030 --> 00:02:12,750
在第一步中，事务获取锁，

38
00:02:12,750 --> 00:02:15,360
在写入的对象上，

39
00:02:15,600 --> 00:02:16,620
我们在这里可以看到，

40
00:02:16,620 --> 00:02:21,840
事务已经写入了两个对象，

41
00:02:21,840 --> 00:02:27,270
所以，我们传播锁记录给每个 primary ，

42
00:02:28,030 --> 00:02:33,220
所以，每个 primary 都将拥有这个事务的锁记录，

43
00:02:33,950 --> 00:02:37,190
对于事务中涉及的对象，

44
00:02:37,640 --> 00:02:41,600
锁记录包含一个对象 id ，

45
00:02:41,750 --> 00:02:43,700
唯一地标识对象，

46
00:02:43,820 --> 00:02:44,990
一个版本号，

47
00:02:45,720 --> 00:02:49,800
在事务读取对象时，

48
00:02:50,100 --> 00:02:51,900
它会得到一个版本号，

49
00:02:52,110 --> 00:02:54,780
得到这个 64 位数字，

50
00:02:55,710 --> 00:02:58,620
其顶部是锁位，其余是版本号，

51
00:03:01,460 --> 00:03:04,130
然后是一个新的值。

52
00:03:08,610 --> 00:03:12,810
所以， primary 1 和 primary 2 会有，

53
00:03:12,870 --> 00:03:14,940
primary 会有对象 1 的锁记录，

54
00:03:14,940 --> 00:03:18,780
primary 2 会有对象 2 的锁记录，

55
00:03:19,200 --> 00:03:24,810
然后有一个单独的阶段用于验证只读操作，

56
00:03:24,810 --> 00:03:29,460
或者对象只读，没有修改的操作，是只读但没有修改的对象，

57
00:03:29,460 --> 00:03:32,310
正如我们在这些验证步骤中所看到的，

58
00:03:32,520 --> 00:03:36,000
虚线表示单边 RDMA ，

59
00:03:40,640 --> 00:03:43,070
正如我们周二谈到的，

60
00:03:43,220 --> 00:03:45,620
它们不涉及服务器，

61
00:03:45,650 --> 00:03:51,230
发送者能从服务器的内存中读取一个对象，

62
00:03:51,410 --> 00:03:52,430
不需要，

63
00:03:52,430 --> 00:03:56,120
不需要中断在服务器上运行的计算，

64
00:03:56,990 --> 00:03:58,460
所以它们往往非常快，

65
00:03:58,880 --> 00:04:01,400
不像我们在这里看到的这些操作，

66
00:04:01,430 --> 00:04:03,470
它们是写入 RDMA ，

67
00:04:07,720 --> 00:04:08,380
它们也很酷，

68
00:04:08,380 --> 00:04:11,320
在某种意义上，你必须写入，

69
00:04:11,650 --> 00:04:13,330
追加到日志记录中，

70
00:04:13,330 --> 00:04:14,980
不需要中断服务器，

71
00:04:15,130 --> 00:04:17,710
但服务器必须处理这些日志记录，

72
00:04:17,830 --> 00:04:20,230
本例中的服务器，

73
00:04:20,230 --> 00:04:22,330
一旦它处理了这些日志记录之一，

74
00:04:22,600 --> 00:04:24,430
试图获取锁，

75
00:04:24,430 --> 00:04:26,500
如果它成功地获取锁，

76
00:04:26,500 --> 00:04:28,360
因为版本号没有改变，

77
00:04:28,360 --> 00:04:31,870
或锁位或没有其他事务获取该锁，

78
00:04:32,020 --> 00:04:33,640
然后它会回复，

79
00:04:33,670 --> 00:04:37,720
用另一个写入 RDMA 说 ok 。

80
00:04:38,930 --> 00:04:42,020
所以，我们在获取锁上看到，

81
00:04:42,020 --> 00:04:43,670
需要在服务器上执行操作，

82
00:04:43,850 --> 00:04:47,390
但用于读取验证的单边 RDMA ，

83
00:04:47,390 --> 00:04:49,220
不需要在服务器上执行任何操作。

84
00:04:50,760 --> 00:04:52,740
然后，就是这样，

85
00:04:53,850 --> 00:04:56,220
如果一切顺利，

86
00:04:56,220 --> 00:05:00,600
事务能够获得这些写入锁，

87
00:05:00,600 --> 00:05:03,660
并验证读取操作，

88
00:05:03,810 --> 00:05:06,690
它会做出提交的决定，

89
00:05:06,810 --> 00:05:11,880
为了提交，它首先联系每个备份，

90
00:05:14,510 --> 00:05:17,480
对象改变了，

91
00:05:18,350 --> 00:05:20,270
写入提交备份记录，

92
00:05:26,080 --> 00:05:32,020
这取决于每个，对于已修改的对象的备份，

93
00:05:32,020 --> 00:05:35,620
同样，它是锁记录的复制，

94
00:05:35,620 --> 00:05:39,220
oid 在那里，版本号在那里，新值在那里。

95
00:05:42,130 --> 00:05:47,830
一旦所有备份都回复，

96
00:05:47,830 --> 00:05:50,020
它们有对象的复制，

97
00:05:50,020 --> 00:05:51,880
现在我们处于很好的状态，

98
00:05:51,880 --> 00:05:55,180
因为 primary 有复制，备份有复制，

99
00:05:55,300 --> 00:05:56,740
[]primary 并不知道，

100
00:05:56,740 --> 00:05:59,140
事务是否已经提交，

101
00:05:59,560 --> 00:06:01,570
所以，最后一步是，

102
00:06:01,570 --> 00:06:08,890
事务协调者写入并提交记录，

103
00:06:09,440 --> 00:06:10,880
并提交主记录，

104
00:06:18,160 --> 00:06:22,600
通知 primary 事务已经提交。

105
00:06:23,450 --> 00:06:26,690
一旦收到其中一个网卡的确认，

106
00:06:26,690 --> 00:06:28,550
由虚线表示的，

107
00:06:28,820 --> 00:06:32,030
它向应用程序报告，

108
00:06:32,030 --> 00:06:33,860
说这个事务已经提交。

109
00:06:37,900 --> 00:06:40,960
所以我们现在要做的是看两个案例，

110
00:06:41,080 --> 00:06:44,320
一个我们想更多地讨论一下可串行化，

111
00:06:44,320 --> 00:06:46,150
为了看看并发控制是否起作用，

112
00:06:46,150 --> 00:06:48,010
然后我们会稍微谈一下容错，

113
00:06:48,010 --> 00:06:49,660
看看容错是否起作用。

114
00:06:50,840 --> 00:06:55,490
让我首先从可串行化开始，

115
00:06:56,480 --> 00:06:57,830
也许在这么做之前，

116
00:06:57,830 --> 00:07:01,400
我想问问，目前有没有什么问题，

117
00:07:01,400 --> 00:07:03,680
或者是否每个人都切换，

118
00:07:04,370 --> 00:07:08,630
成功切换想起 FaRM 。

119
00:07:12,280 --> 00:07:15,130
长方形在这里是什么意思？

120
00:07:15,680 --> 00:07:16,400
抱歉?

121
00:07:16,790 --> 00:07:18,680
长方形是什么，

122
00:07:19,010 --> 00:07:20,360
这意味着什么？

123
00:07:20,360 --> 00:07:21,320
它是对象。

124
00:07:22,080 --> 00:07:23,490
哦，这是对象，好的。

125
00:07:26,080 --> 00:07:28,540
好的，还有其他问题吗？

126
00:07:31,320 --> 00:07:32,880
好的，让我们，

127
00:07:34,200 --> 00:07:39,360
所以我们从并发性的角度来看一下正确性，

128
00:07:39,810 --> 00:07:43,650
所以严格串行化的正确性。

129
00:07:49,230 --> 00:07:50,790
在周二，我们研究了

130
00:07:50,970 --> 00:07:56,490
没有涉及写入验证的事务，

131
00:07:56,490 --> 00:08:00,360
因为对象被读取，而不是写入，

132
00:08:00,720 --> 00:08:02,910
所以这一次我要看看另一个事务，

133
00:08:02,910 --> 00:08:05,190
在那里验证阶段发挥了作用。

134
00:08:05,720 --> 00:08:07,370
所以我们来看两个事务，

135
00:08:08,350 --> 00:08:09,370
这是，

136
00:08:09,370 --> 00:08:12,580
这是一个经典的例子

137
00:08:12,580 --> 00:08:16,240
用来测试协议是否提供可串行化，

138
00:08:16,300 --> 00:08:17,950
当然，它不会被证明，

139
00:08:17,950 --> 00:08:20,020
但它是关键的例子之一，

140
00:08:20,020 --> 00:08:24,250
总的来说，对了解协议是如何工作的非常有帮助。

141
00:08:24,880 --> 00:08:26,950
协议，事务是，

142
00:08:26,950 --> 00:08:29,830
如果 x 是 0 ，然后我们设置 y 为 1 ，

143
00:08:30,490 --> 00:08:33,700
如果对象 x 是 0 ，我们设置对象 y 1 ，

144
00:08:34,000 --> 00:08:37,180
事务 2 正好相反，它是，

145
00:08:37,180 --> 00:08:41,890
如果 y 是 0 ，则设置 x 为 1 。

146
00:08:44,080 --> 00:08:45,430
之所以这样，

147
00:08:45,730 --> 00:08:48,700
这是一个很好的可串行化测试，

148
00:08:48,700 --> 00:08:51,790
无论事务 1 应该在 T2 之后进行，

149
00:08:51,790 --> 00:08:53,620
或者 T2 应该在 T1 之后

150
00:08:53,980 --> 00:08:56,410
根据您运行的顺序，

151
00:08:56,410 --> 00:08:58,720
要么 y 是 1 ，要么 x 是 1 ，

152
00:08:58,930 --> 00:09:00,700
但你永远不会有，

153
00:09:01,480 --> 00:09:09,670
你永远不会有结果 x 是 1 ， y 也是 1 。

154
00:09:11,560 --> 00:09:13,090
这是不允许的，

155
00:09:13,090 --> 00:09:15,730
因为这肯定违反了可串行化。

156
00:09:16,210 --> 00:09:17,140
这能理解吗？

157
00:09:22,370 --> 00:09:23,840
好的，我们要做的是，

158
00:09:23,840 --> 00:09:28,070
测试 FaRM 是否成功，

159
00:09:28,810 --> 00:09:31,480
我们想要了解需求，

160
00:09:31,480 --> 00:09:36,820
实际上， x 是 1 ， y 是 1 是不可能产生的。

161
00:09:37,200 --> 00:09:39,120
那么让我们来看看时间线，

162
00:09:39,300 --> 00:09:44,880
假设这里有 T1 ，这里有 T2 时间线，

163
00:09:46,400 --> 00:09:50,600
它们都处于准备或执行阶段，

164
00:09:50,600 --> 00:09:51,770
都读取这些对象，

165
00:09:51,770 --> 00:09:54,650
所以我们假设它们同时运行，

166
00:09:54,650 --> 00:09:57,230
我们读取 x 和版本号 0 ，

167
00:09:57,320 --> 00:09:59,750
我们读取 y ，版本号为 0 ，

168
00:09:59,930 --> 00:10:00,830
这里也一样。

169
00:10:03,760 --> 00:10:09,310
当然 T1 会更新 y ， T2 会更新 x ，

170
00:10:09,490 --> 00:10:14,080
它们在某个点上，开始提交阶段，

171
00:10:19,320 --> 00:10:20,970
让我们，

172
00:10:22,580 --> 00:10:24,650
让我们假设 T1 先开始，

173
00:10:24,650 --> 00:10:29,540
它需要对 y 加锁，

174
00:10:29,630 --> 00:10:31,850
因为它将写入 y ，

175
00:10:32,270 --> 00:10:35,750
我们假设 x 成功地获取了 y 的锁，

176
00:10:36,260 --> 00:10:42,920
所以它会设置对象 y 的锁位和版本号。

177
00:10:43,840 --> 00:10:46,900
然后我们假设，

178
00:10:47,140 --> 00:10:48,280
因为它要读取，

179
00:10:48,370 --> 00:10:49,540
它读取了 x ，

180
00:10:49,540 --> 00:10:52,480
但它不像读取 x ，

181
00:10:52,480 --> 00:10:55,510
但它不是在修改 x ，而是在验证 x ，

182
00:10:56,780 --> 00:11:00,890
x 是读取版本号 0 ，

183
00:11:01,430 --> 00:11:04,730
在验证阶段，

184
00:11:04,730 --> 00:11:06,830
所以 x 并没有改变，

185
00:11:06,830 --> 00:11:09,110
那里的版本号仍然是 0 ，

186
00:11:09,110 --> 00:11:11,210
我们是按这个顺序执行的，

187
00:11:11,510 --> 00:11:14,420
所以一切都很好，

188
00:11:14,690 --> 00:11:18,680
在某个时候，这个事务可能会提交。

189
00:11:19,970 --> 00:11:21,650
那么让我们来看看 T2 ，

190
00:11:21,680 --> 00:11:27,740
假设 T2 在 x 的验证之后运行，

191
00:11:27,740 --> 00:11:29,090
所以它获取锁，

192
00:11:30,260 --> 00:11:36,470
它需要读取 y ，

193
00:11:36,470 --> 00:11:38,300
所以它需要对 y 进行验证，

194
00:11:38,950 --> 00:11:41,590
这将对 y 进行验证，

195
00:11:42,040 --> 00:11:44,110
问题是，

196
00:11:44,110 --> 00:11:47,200
这个验证是否会成功。

197
00:11:51,800 --> 00:11:56,420
不会，因为之前的另一个操作已经获取修改值的锁，

198
00:11:56,420 --> 00:11:58,820
所以这与它最初读到的不一样，

199
00:11:59,780 --> 00:12:01,910
是的，所以版本号可能还是一样的，

200
00:12:01,910 --> 00:12:07,040
但是 T1 已经设置了对象 y 的锁位，

201
00:12:07,250 --> 00:12:09,470
在这一点上，这个验证将失败，

202
00:12:10,860 --> 00:12:14,940
因为这不一样，或者锁位已经设置，

203
00:12:15,180 --> 00:12:18,090
所以，对于 T2 事务， T2 事务将会中止。

204
00:12:19,810 --> 00:12:21,400
好的，这能理解吗？

205
00:12:22,990 --> 00:12:24,820
所以我们至少在这个特定的例子中看到，

206
00:12:24,880 --> 00:12:27,340
情况就是这样，

207
00:12:27,340 --> 00:12:29,440
T1 和 T2 都提交，

208
00:12:29,470 --> 00:12:31,900
将导致这个不正确的结果。

209
00:12:34,920 --> 00:12:36,090
对此有什么问题吗？

210
00:12:39,540 --> 00:12:40,740
我有个问题。

211
00:12:41,560 --> 00:12:42,250
嗯。

212
00:12:42,760 --> 00:12:46,480
是的，所以，对于事务来说，

213
00:12:46,810 --> 00:12:51,100
所以这些必须有更新事务，

214
00:12:51,130 --> 00:12:53,500
比如重新写入，

215
00:12:53,800 --> 00:12:56,570
只是读取，无法做到这一点。

216
00:12:57,580 --> 00:12:58,180
好的，继续。

217
00:12:58,620 --> 00:12:59,670
我只是在想，

218
00:12:59,670 --> 00:13:02,310
如果它们是读取操作，

219
00:13:02,310 --> 00:13:04,530
你可以用无锁来做，

220
00:13:04,920 --> 00:13:06,000
而且只要。

221
00:13:06,180 --> 00:13:07,680
是的，所以这是，

222
00:13:07,680 --> 00:13:09,510
让我们回到这张图片上，

223
00:13:09,510 --> 00:13:10,890
让我们来看一下，

224
00:13:11,100 --> 00:13:14,400
比如，这个事务中根本没有涉及写入，

225
00:13:14,400 --> 00:13:16,830
比如，两个对象读取，

226
00:13:16,830 --> 00:13:18,780
保存在 P1 和 P2 。

227
00:13:19,830 --> 00:13:22,440
所以我们假设这些并没有参与，

228
00:13:22,470 --> 00:13:24,090
所以这些对象没有写入，

229
00:13:24,090 --> 00:13:27,660
所以，发生的唯一操作是对这个对象进行读取。

230
00:13:28,010 --> 00:13:32,180
你可以看到，协议是精心设计的，

231
00:13:32,570 --> 00:13:34,460
所以如果你只做读取，

232
00:13:34,670 --> 00:13:37,250
你只做单边 RDMA ，

233
00:13:37,900 --> 00:13:39,940
在这里的执行阶段，

234
00:13:39,940 --> 00:13:42,100
一个 RDMA 来进行验证，

235
00:13:43,720 --> 00:13:46,060
没有锁被拿出来，

236
00:13:46,090 --> 00:13:47,410
没有任何写入，

237
00:13:47,440 --> 00:13:49,000
没有附加任何记录，

238
00:13:49,060 --> 00:13:50,590
这是唯一发生的事情。

239
00:13:51,880 --> 00:13:55,450
所以这是 FaRM 的一个很酷的特点，

240
00:13:55,630 --> 00:13:59,320
如果事务只做读取，

241
00:13:59,320 --> 00:14:04,720
可以只使用单边 RDMA 执行，

242
00:14:04,870 --> 00:14:11,710
不需要写入任何锁或获取锁，

243
00:14:11,710 --> 00:14:14,920
这就是它们能获得极高性能的原因之一。

244
00:14:16,150 --> 00:14:17,650
这也是为什么，

245
00:14:17,650 --> 00:14:23,560
锁步骤和验证步骤是两个不同的事情，

246
00:14:23,560 --> 00:14:27,940
因为在只读事务中，没有锁步骤。

247
00:14:31,030 --> 00:14:31,660
好的?

248
00:14:32,680 --> 00:14:34,720
关于这个问题，

249
00:14:35,200 --> 00:14:38,050
对于只读事务，

250
00:14:38,050 --> 00:14:40,180
为什么我们需要第二个，

251
00:14:40,240 --> 00:14:42,040
为什么我们需要验证阶段，

252
00:14:42,280 --> 00:14:43,990
因为你不是只读取值吗，

253
00:14:44,020 --> 00:14:47,140
然后你在它之后验证版本，

254
00:14:47,170 --> 00:14:47,890
看起来像是。

255
00:14:48,660 --> 00:14:52,530
可能是另一个事务修改对象，

256
00:14:52,860 --> 00:14:57,270
如果事务在之前运行或开始并提交，

257
00:14:57,600 --> 00:15:02,180
好的，并发事务写入可能会修改对象，

258
00:15:04,660 --> 00:15:06,190
现在，我们回来，

259
00:15:06,190 --> 00:15:12,340
所以事务写入，

260
00:15:12,460 --> 00:15:14,890
然后后面的事务，

261
00:15:14,890 --> 00:15:17,230
应该观察到最后的写入。

262
00:15:19,280 --> 00:15:20,870
但如果它们同时发生，

263
00:15:20,870 --> 00:15:22,970
然后我们可以以任何一种方式对它们重新排序。

264
00:15:23,060 --> 00:15:27,650
在同一时间，我们可以对它们重新排序，是的。

265
00:15:32,300 --> 00:15:33,650
所以在我看来，

266
00:15:33,650 --> 00:15:35,720
第二个校验，

267
00:15:35,750 --> 00:15:37,100
因为你第一次读取它，

268
00:15:37,370 --> 00:15:41,090
第二次直接[]，看到版本是相同的，

269
00:15:41,210 --> 00:15:46,030
在我看来，第二次验证似乎是不必要的。

270
00:15:46,420 --> 00:15:48,370
你可能是对的，

271
00:15:48,370 --> 00:15:49,780
我还没好好想过这件事，

272
00:15:49,780 --> 00:15:55,840
如果事务只是只读事务，

273
00:15:55,840 --> 00:15:58,180
那么验证肯定是不必要的，

274
00:15:58,360 --> 00:16:00,280
我非常仔细地考虑过，

275
00:16:00,280 --> 00:16:01,840
当有混合事务时，

276
00:16:02,020 --> 00:16:04,000
你需要验证。

277
00:16:04,740 --> 00:16:06,420
是的，如果是这样的话，

278
00:16:06,420 --> 00:16:09,450
如果你读取一个值，

279
00:16:10,020 --> 00:16:12,840
你希望原子地读取两个值，

280
00:16:12,840 --> 00:16:15,480
在读取值之后，

281
00:16:15,510 --> 00:16:18,450
有事务修改了另一个值。

282
00:16:19,900 --> 00:16:21,790
是的，这是一种可能。

283
00:16:21,790 --> 00:16:22,360
它不会。

284
00:16:27,900 --> 00:16:29,970
是的，我不是很确定，

285
00:16:30,060 --> 00:16:32,430
在这种情况下，如果这是问题所在。

286
00:16:33,210 --> 00:16:34,500
比如在这种情况下，

287
00:16:34,500 --> 00:16:36,240
这个 T1 和 T2 的案例，

288
00:16:36,240 --> 00:16:39,390
非常关键的一点是 y 做了验证，

289
00:16:41,110 --> 00:16:50,220
即使事务 T1 只读取 y ，

290
00:16:52,020 --> 00:16:56,950
但是，如果事务 2 只是 x 等于 1 ，

291
00:16:57,040 --> 00:16:59,530
而没有那个语句。

292
00:16:59,530 --> 00:17:00,340
盲写。

293
00:17:02,110 --> 00:17:02,620
嗯？

294
00:17:02,920 --> 00:17:04,360
如果这是盲写。

295
00:17:04,630 --> 00:17:06,250
是的，它只是 x 等于 1 ，

296
00:17:06,250 --> 00:17:10,210
然后在 T1 验证后执行。

297
00:17:11,140 --> 00:17:12,430
是的，这是好的。

298
00:17:19,600 --> 00:17:20,650
但是。

299
00:17:20,650 --> 00:17:21,910
我不确定问题是什么。

300
00:17:22,150 --> 00:17:25,420
哦，所以如果 T2 只是，

301
00:17:25,420 --> 00:17:28,240
比如写入 x 等于 1 ，

302
00:17:28,540 --> 00:17:30,610
在验证步骤内，

303
00:17:30,940 --> 00:17:34,810
在 T1 的验证步骤之后，

304
00:17:35,050 --> 00:17:39,520
那么 T1 不会认为 x 等于 0 吗，

305
00:17:39,740 --> 00:17:44,210
但是在提交之前， x 变成了 1 。

306
00:17:46,740 --> 00:17:50,400
好的，也许我们可以先等一下，

307
00:17:50,400 --> 00:17:53,190
因为我要重画这张图，

308
00:17:53,190 --> 00:17:55,440
弄清楚你所说的场景到底是什么。

309
00:17:56,210 --> 00:17:58,610
好的，也许我们可以在最后回到这个问题上。

310
00:18:02,390 --> 00:18:03,320
抱歉，我有个问题，

311
00:18:03,320 --> 00:18:05,960
正常事务的用例是什么？

312
00:18:07,330 --> 00:18:13,510
如果回想一下 Spanner 和这个论文，

313
00:18:13,510 --> 00:18:15,550
很多情况下，

314
00:18:15,640 --> 00:18:20,350
这些工作负载， TPC-C 工作负载和 TATP 工作负载，

315
00:18:20,350 --> 00:18:23,860
有一个只读的事务，

316
00:18:24,010 --> 00:18:26,200
我计算一组账户的余额，

317
00:18:26,710 --> 00:18:28,420
什么都没写，

318
00:18:28,420 --> 00:18:30,700
但是很多账户被读取。

319
00:18:33,610 --> 00:18:34,630
谢谢。

320
00:18:38,240 --> 00:18:41,600
好的，我们在这里看到，验证阶段是至关重要的，

321
00:18:41,600 --> 00:18:45,050
T1 和 T2 事务，

322
00:18:45,050 --> 00:18:48,350
在[]，发挥作用了，

323
00:18:48,350 --> 00:18:49,670
我们得到了严格的可串行化，

324
00:18:49,670 --> 00:18:50,810
当然，这不是证明，

325
00:18:50,810 --> 00:18:53,480
但它给了你这个例子，

326
00:18:53,510 --> 00:18:56,540
一种棘手的情况，

327
00:18:56,540 --> 00:18:59,180
FaRM 解决得很好。

328
00:19:00,820 --> 00:19:04,500
好的，所以这是关于并发控制的，

329
00:19:04,680 --> 00:19:06,630
然后第二部分，

330
00:19:06,690 --> 00:19:09,480
我们想讨论一下容错。

331
00:19:11,220 --> 00:19:16,320
这里不会很深入，

332
00:19:16,380 --> 00:19:20,640
只想谈谈关键挑战，

333
00:19:20,850 --> 00:19:24,210
建立一些直觉，

334
00:19:24,210 --> 00:19:31,050
为什么我们希望 FaRM 解决关键挑战。

335
00:19:31,520 --> 00:19:33,530
所以关键的挑战是，

336
00:19:33,950 --> 00:19:37,760
所以我们面临的关键挑战是，

337
00:19:37,820 --> 00:19:46,700
在通知应用程序后，会发生崩溃，

338
00:19:53,880 --> 00:19:55,890
然后它必须是这样，

339
00:19:55,890 --> 00:19:58,170
事务持久化，

340
00:20:00,410 --> 00:20:03,140
因为我们已经通知应用程序事务已提交，

341
00:20:03,140 --> 00:20:08,000
所以，我们不能丢失事务已完成的所有写入。

342
00:20:08,780 --> 00:20:10,940
所以我们可以再看一下这张图片，

343
00:20:12,120 --> 00:20:13,650
看看我们，

344
00:20:13,680 --> 00:20:15,630
希望这是这种情况，

345
00:20:22,230 --> 00:20:25,320
所以有几个事情需要观察，

346
00:20:25,350 --> 00:20:28,260
在锁阶段之后，

347
00:20:29,170 --> 00:20:30,940
情况是这样的，

348
00:20:33,200 --> 00:20:34,250
在锁阶段之后，

349
00:20:34,250 --> 00:20:40,110
两个 primary P1 和 P2 具有锁记录，

350
00:20:42,840 --> 00:20:44,070
描述了更新，

351
00:20:44,460 --> 00:20:46,110
我们不知道事务，

352
00:20:46,650 --> 00:20:49,980
那个记录没有说，

353
00:20:49,980 --> 00:20:52,290
事务是否已经提交，

354
00:20:52,380 --> 00:20:54,690
但我们有关于事务的信息，

355
00:20:55,950 --> 00:20:58,830
然后，在这步骤之后，到达提交备份步骤，

356
00:20:59,170 --> 00:21:06,370
我们知道备份 B1 和 B2 有提交记录，

357
00:21:12,690 --> 00:21:16,110
然后在事务，

358
00:21:16,440 --> 00:21:19,830
事务协调者向应用程序报告之前，

359
00:21:19,830 --> 00:21:22,290
它必须是成功的，

360
00:21:22,320 --> 00:21:24,600
我们知道其中一个 primary ，

361
00:21:24,810 --> 00:21:27,450
假设 P1 也有提交记录，

362
00:21:34,130 --> 00:21:37,190
我们假设这里发生了崩溃，

363
00:21:37,220 --> 00:21:41,750
所以在那个特定的提交点之后，系统崩溃了，

364
00:21:41,750 --> 00:21:44,420
我们想要说服自己的是，

365
00:21:44,750 --> 00:21:47,000
如果有一次失败，

366
00:21:47,000 --> 00:21:50,240
对于每个分片，事情是正常的，

367
00:21:51,040 --> 00:21:56,230
所以最坏的情况是， B2 失败了，

368
00:21:58,560 --> 00:22:02,910
所以这里 B2 失败了，

369
00:22:03,460 --> 00:22:06,340
所以我们失去了提交记录，

370
00:22:06,370 --> 00:22:07,600
它就在那里，

371
00:22:07,930 --> 00:22:11,560
primary 可能还没有提交记录，

372
00:22:11,930 --> 00:22:16,580
因为它在我们看到一个 primary 的确认后崩溃了，

373
00:22:16,580 --> 00:22:19,460
所以，我们假设 P1 有提交记录，

374
00:22:20,330 --> 00:22:22,730
在这种情况下， P1 有提交记录，

375
00:22:25,260 --> 00:22:29,550
当然备份有 B1 的提交记录，

376
00:22:30,410 --> 00:22:35,750
所以，这在恢复时有足够的信息，

377
00:22:35,840 --> 00:22:37,850
事务已经提交，

378
00:22:37,850 --> 00:22:40,220
因为我们有提交记录，

379
00:22:40,250 --> 00:22:42,620
这是 tid 提交，

380
00:22:43,100 --> 00:22:46,010
我们有备份中的所有信息，

381
00:22:46,040 --> 00:22:51,440
即锁以及描述写事务的提交记录，

382
00:22:51,560 --> 00:22:53,240
在备份上，

383
00:22:53,240 --> 00:22:54,680
所以，在恢复期间，

384
00:22:54,740 --> 00:22:56,720
我们有足够的信息来确定

385
00:22:56,780 --> 00:22:58,730
事务是否已实际提交。

386
00:23:00,650 --> 00:23:02,930
所以这是足够的，

387
00:23:02,990 --> 00:23:04,550
当然这是一个复杂的协议，

388
00:23:04,550 --> 00:23:05,960
需要操作，

389
00:23:05,960 --> 00:23:09,410
看看事务留下的所有部分，

390
00:23:09,560 --> 00:23:11,240
有足够多的事务留下的部分，

391
00:23:11,240 --> 00:23:16,790
对于新的协调者，恢复进程来决定，

392
00:23:16,790 --> 00:23:20,120
这个事务已经提交，应该持久化。

393
00:23:22,360 --> 00:23:22,960
好的?

394
00:23:30,080 --> 00:23:31,340
好的。

395
00:23:31,960 --> 00:23:33,700
所以让我总结一下 FaRM ，

396
00:23:33,790 --> 00:23:37,810
在我们进入关于 Spark 的讨论之前。

397
00:23:41,270 --> 00:23:42,920
所以高级别的，

398
00:23:42,920 --> 00:23:46,430
FaRM 最酷的地方就是快，

399
00:23:46,850 --> 00:23:49,520
它每秒可以执行很多事务，

400
00:23:50,160 --> 00:23:54,240
当然 FaRM 有一些限制，

401
00:23:54,270 --> 00:24:00,690
你不能一直这样做。

402
00:24:02,060 --> 00:24:04,120
所以，首先，

403
00:24:04,120 --> 00:24:06,430
它假设很少有冲突，

404
00:24:08,160 --> 00:24:12,150
所以使用这个乐观并发控制方案，

405
00:24:12,870 --> 00:24:15,390
之所以使用这种乐观并发控制方案，

406
00:24:15,390 --> 00:24:16,830
因为想把锁拿出来，

407
00:24:16,830 --> 00:24:19,200
因为它想要做这种单边 RDMA ，

408
00:24:19,260 --> 00:24:21,240
不需要任何服务器参与。

409
00:24:21,830 --> 00:24:24,770
所以使用乐观并发控制方案，

410
00:24:24,920 --> 00:24:28,580
这意味着，如果你想要好的性能，

411
00:24:28,580 --> 00:24:31,670
避免事务中止，工作负载更好，

412
00:24:31,670 --> 00:24:33,590
很少有冲突，

413
00:24:33,830 --> 00:24:35,090
我们看到了新的创新，

414
00:24:35,090 --> 00:24:37,070
有两个基准测试，

415
00:24:37,070 --> 00:24:40,490
在事务文献中用来衡量系统，

416
00:24:40,820 --> 00:24:42,440
对于这两个基准，

417
00:24:42,590 --> 00:24:45,380
做得非常好，

418
00:24:45,410 --> 00:24:48,350
意味着它们没有那么多冲突。

419
00:24:49,770 --> 00:24:51,270
它提出的第二个假设是，

420
00:24:51,270 --> 00:24:52,920
数据必须存储在内存中，

421
00:24:58,560 --> 00:25:01,710
这意味着如果你有一个非常大的数据库，

422
00:25:01,710 --> 00:25:03,000
你必须买更多的机器，

423
00:25:03,480 --> 00:25:06,870
或者如果你的数据太大，

424
00:25:06,870 --> 00:25:08,160
你不想买更多的机器，

425
00:25:08,160 --> 00:25:09,750
那么你不能使用 FaRM ，

426
00:25:09,990 --> 00:25:12,540
你必须回到更传统的数据库，

427
00:25:12,540 --> 00:25:14,460
有持久存储，

428
00:25:14,460 --> 00:25:22,260
你可以在更大的存储设备上读取或写入记录。

429
00:25:24,420 --> 00:25:31,410
复制只是在数据中心内进行，

430
00:25:36,520 --> 00:25:39,130
所以这种方式，

431
00:25:39,130 --> 00:25:41,770
它和 Spanner 有很大不同，

432
00:25:41,770 --> 00:25:43,330
整个目标必须是，

433
00:25:43,450 --> 00:25:47,680
跨数据中心同步事务，同步复制，

434
00:25:48,040 --> 00:25:49,750
为了支持应用程序，

435
00:25:49,750 --> 00:25:54,280
它必须存活或继续，

436
00:25:54,280 --> 00:25:56,020
在一些数据中心停机时，

437
00:25:56,200 --> 00:25:59,110
FaRM 不是这样的，

438
00:25:59,200 --> 00:26:01,690
它不是针对那些类型的应用程序的。

439
00:26:03,860 --> 00:26:05,990
最后一点是，

440
00:26:06,170 --> 00:26:14,550
它需要非常奇特或奇异的硬件，

441
00:26:15,120 --> 00:26:16,920
尤其是有两样东西，

442
00:26:16,920 --> 00:26:23,160
UPS ，在数据中心完全故障中存活下来，

443
00:26:23,370 --> 00:26:28,080
更重要的是，使用这种 RDMA 网卡，

444
00:26:28,570 --> 00:26:30,520
获得很高的性能。

445
00:26:35,120 --> 00:26:40,830
好了，这是关于 FaRM 我想说的，

446
00:26:40,860 --> 00:26:42,810
除非有任何进一步的问题。

447
00:26:55,240 --> 00:27:06,690
好的，这结束了 6.824 的事务的论文，

448
00:27:06,960 --> 00:27:10,470
所以我们做了三节关于事务的课程，

449
00:27:10,470 --> 00:27:14,700
这是关于事务的讨论的结束，

450
00:27:14,700 --> 00:27:16,380
也会出现在其他论文上，

451
00:27:16,380 --> 00:27:18,630
但我们不会谈论更多细节，

452
00:27:18,870 --> 00:27:20,970
事实上，我们已经完成了

453
00:27:20,970 --> 00:27:25,410
讨论分布式系统中最具挑战性的部分，

454
00:27:25,410 --> 00:27:28,320
即构建容错存储系统，

455
00:27:28,590 --> 00:27:32,940
我们看到了各种不同的设计，

456
00:27:32,940 --> 00:27:33,930
包括一些设计，

457
00:27:33,930 --> 00:27:39,240
它们支持非常强大的事务编程抽象。

458
00:27:39,870 --> 00:27:42,240
所以在接下来的这节课里，

459
00:27:42,240 --> 00:27:44,790
这节课的剩余部分以及随后的课程，

460
00:27:45,090 --> 00:27:47,010
我们将讨论不同的主题，

461
00:27:47,040 --> 00:27:50,010
与存储系统无关。

462
00:27:51,410 --> 00:27:56,840
所以我们要讨论的第一个话题是 Spark 。

