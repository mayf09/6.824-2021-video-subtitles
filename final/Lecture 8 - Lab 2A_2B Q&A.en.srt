1
00:00:03,170 --> 00:00:05,690
Okay, good afternoon, sound check.

2
00:00:08,480 --> 00:00:09,800
Yep, we're good.

3
00:00:10,190 --> 00:00:10,910
Okay, great,

4
00:00:11,030 --> 00:00:14,150
good evening, good morning, wherever you are,

5
00:00:14,240 --> 00:00:18,620
so today I wanna talk about lab 2 a and b,

6
00:00:18,890 --> 00:00:21,110
and this is really a question answer session,

7
00:00:21,530 --> 00:00:24,290
so feel free to interrupt anytime,

8
00:00:24,290 --> 00:00:26,660
ask questions as much as you like,

9
00:00:26,690 --> 00:00:31,430
it's really, today's lecture is really dedicated to your questions,

10
00:00:31,700 --> 00:00:36,470
I summarized many of the questions,

11
00:00:36,470 --> 00:00:39,380
that came up or either once or multiple times in the email,

12
00:00:39,380 --> 00:00:41,720
on the right side here this on the board,

13
00:00:42,170 --> 00:00:51,020
and hopefully it will get through them as I walk through my solutions,

14
00:00:51,410 --> 00:00:57,240
and so I'm gonna basically cover four topics related to the solution.

15
00:00:57,390 --> 00:01:01,860
One, we're going to first talk a little bit about voting, or like the voting code,

16
00:01:01,860 --> 00:01:03,570
basically the heartbeats,

17
00:01:07,970 --> 00:01:11,090
and then I'll talk about start and commit.

18
00:01:17,310 --> 00:01:21,480
This sort of follows I think the suggestion that we made in the lab,

19
00:01:21,480 --> 00:01:22,590
like how you should get start,

20
00:01:22,590 --> 00:01:24,150
like first voting to work,

21
00:01:24,150 --> 00:01:25,320
you know get heartbeats to work,

22
00:01:25,320 --> 00:01:26,460
once you got heartbeat to work,

23
00:01:26,460 --> 00:01:28,770
you can actually start taking commands from clients,

24
00:01:29,130 --> 00:01:30,900
and then of course you gotta commit

25
00:01:30,900 --> 00:01:32,910
to supply them the apply channel.

26
00:01:33,420 --> 00:01:35,400
So there's roughly order planning go through,

27
00:01:35,400 --> 00:01:38,220
but again feel free to interrupt at any particular time.

28
00:01:40,690 --> 00:01:44,470
So before diving or looking at my particular solutions

29
00:01:44,470 --> 00:01:46,000
or the solutions I wrote this here,

30
00:01:46,150 --> 00:01:48,700
I want to talk a little bit about debugging,

31
00:01:48,700 --> 00:01:51,640
because that was probably question that came up most

32
00:01:51,670 --> 00:01:57,730
in the, in all your in the submitted questions.

33
00:01:58,310 --> 00:02:03,650
Let me talk a little bit at a very high level about debugging,

34
00:02:04,510 --> 00:02:07,600
and this is a clearly a topic that we could spend a whole lecture on,

35
00:02:07,660 --> 00:02:12,640
and but I'm just gonna give you some of my high level approach,

36
00:02:12,640 --> 00:02:16,660
that you know I typically used to address,

37
00:02:16,840 --> 00:02:18,580
you know to basically pass the labs.

38
00:02:19,190 --> 00:02:20,780
And then basically starts out,

39
00:02:20,840 --> 00:02:23,660
I just started, started basically we're running the first test case,

40
00:02:25,810 --> 00:02:27,550
and of course if I have not written any code,

41
00:02:27,550 --> 00:02:28,300
I'm gonna fail it,

42
00:02:29,020 --> 00:02:31,120
but at least I have some starting point,

43
00:02:31,120 --> 00:02:34,480
where I can I can start writing some code for,

44
00:02:34,660 --> 00:02:36,520
and so you know think about the first test case,

45
00:02:36,520 --> 00:02:37,960
you know starting writing,

46
00:02:37,990 --> 00:02:40,540
look at the hints and write some code,

47
00:02:41,110 --> 00:02:42,520
and while writing the code,

48
00:02:42,760 --> 00:02:45,610
I find it you know convenient,

49
00:02:45,670 --> 00:02:48,520
in this lab to or the sets of labs,

50
00:02:48,520 --> 00:02:50,320
actually any lab in the 6.824,

51
00:02:50,410 --> 00:02:52,450
to log all messages,

52
00:02:57,380 --> 00:03:02,210
and you know typically use a DPrintf function in the util.go,

53
00:03:02,450 --> 00:03:05,810
and I'm pretty systematic of logging messages,

54
00:03:06,440 --> 00:03:10,760
and the reason that I do this isn't for debugging purposes,

55
00:03:10,850 --> 00:03:13,850
and so I'll write code,

56
00:03:13,880 --> 00:03:15,620
run the test code fails,

57
00:03:15,620 --> 00:03:18,770
write some code to actually try to pass the test case,

58
00:03:19,280 --> 00:03:22,010
and you know there's two scenarios,

59
00:03:22,010 --> 00:03:23,600
you know one you know I pass,

60
00:03:24,070 --> 00:03:27,100
which then I immediately move on to the next test case,

61
00:03:27,370 --> 00:03:29,080
or I fail,

62
00:03:30,140 --> 00:03:33,020
and in that case,

63
00:03:33,440 --> 00:03:34,790
the first thing I do is

64
00:03:34,790 --> 00:03:36,980
to study the test case a little bit more in detail,

65
00:03:37,130 --> 00:03:41,720
and try to figure out what actually the test case is trying to test,

66
00:03:42,530 --> 00:03:44,750
and you know the name of the test cases

67
00:03:44,750 --> 00:03:47,450
often very suggestive of what the particular scenario

68
00:03:47,450 --> 00:03:51,020
or what sort of set of scenarios a test case is trying to cover,

69
00:03:51,740 --> 00:03:54,530
and then I tried to answer the formulate for myself,

70
00:03:54,530 --> 00:03:57,050
and hypothesis why you know my code,

71
00:03:57,050 --> 00:04:00,230
why not you know test that pass the test case,

72
00:04:00,650 --> 00:04:05,030
and so basically this is sort of a moment of reflection and thinking,

73
00:04:07,110 --> 00:04:11,880
and, to sort of like you understand,

74
00:04:11,880 --> 00:04:14,040
what the constructing my head a scenario,

75
00:04:14,040 --> 00:04:15,660
that there seems to fit the test case,

76
00:04:15,660 --> 00:04:16,950
you know think about my code,

77
00:04:16,950 --> 00:04:19,920
what actually it could be a problem,

78
00:04:19,920 --> 00:04:21,660
and once I have a hypothesis,

79
00:04:21,660 --> 00:04:23,250
then the next thing to do is like study,

80
00:04:23,250 --> 00:04:27,810
you know basically try to confirm the hypothesis,

81
00:04:27,810 --> 00:04:32,250
whether my explanation for why passing the test case, might be right or wrong,

82
00:04:32,430 --> 00:04:33,180
and so to do that,

83
00:04:33,180 --> 00:04:34,710
then basically I study the log,

84
00:04:36,950 --> 00:04:40,250
so if I have a print you know and trace of all the messages,

85
00:04:40,250 --> 00:04:42,140
being sent to the part of the protocol,

86
00:04:42,260 --> 00:04:44,990
I can look at that you know trace,

87
00:04:44,990 --> 00:04:48,260
and you know to see you know where things go wrong,

88
00:04:48,260 --> 00:04:49,670
and sort of work where backwards,

89
00:04:49,670 --> 00:04:51,320
and you know in that way,

90
00:04:51,320 --> 00:04:55,160
sort of test and refine my hypothesis

91
00:04:55,160 --> 00:04:57,080
about why my code might be wrong,

92
00:04:58,580 --> 00:05:02,330
sometimes you know that may require you know going back,

93
00:05:02,330 --> 00:05:07,250
and basically run the test case test to basically get more detailed log output,

94
00:05:07,250 --> 00:05:11,390
although early on I tend to be very systematic,

95
00:05:11,390 --> 00:05:13,940
and you don't really have to add any print statements,

96
00:05:13,940 --> 00:05:16,220
but in some cases, that necessary,

97
00:05:16,840 --> 00:05:19,480
then you know that gives me more information,

98
00:05:19,480 --> 00:05:23,170
and I can sort of really zoom in on scenario,

99
00:05:23,170 --> 00:05:25,960
that you know my code doesn't handle,

100
00:05:26,410 --> 00:05:28,570
once I sort of have a hypothesis,

101
00:05:28,570 --> 00:05:30,100
I verified with the log,

102
00:05:30,100 --> 00:05:32,620
that they are indeed the hypothesis seems to be correct,

103
00:05:32,620 --> 00:05:35,140
and that is a source or a bug in my code,

104
00:05:35,410 --> 00:05:37,150
I can just go fix the code,

105
00:05:39,670 --> 00:05:41,530
and then run the test case.

106
00:05:42,630 --> 00:05:44,790
And so this is a brief process,

107
00:05:44,880 --> 00:05:46,200
run test case,

108
00:05:46,410 --> 00:05:51,840
if fail, study test case and study logs to formulate hypothesis,

109
00:05:51,840 --> 00:05:53,550
you know trying to confirm that hypothesis,

110
00:05:53,730 --> 00:05:55,560
and then move on fix the code,

111
00:05:55,560 --> 00:05:56,730
and then move onto the next one,

112
00:05:57,270 --> 00:06:00,900
and that tend to be reasonable systematic in this.

113
00:06:01,410 --> 00:06:05,280
And so for example often I'll actually write down in a some file, a text file,

114
00:06:05,280 --> 00:06:06,420
what my hypothesis is,

115
00:06:06,420 --> 00:06:09,480
and sort of trying to collect evidence or counter evidence,

116
00:06:09,480 --> 00:06:12,780
you know to need to prove or disprove my hypothesis,

117
00:06:12,780 --> 00:06:16,830
I really have a good reason to fix the code,

118
00:06:16,860 --> 00:06:20,280
I think you know any approach that basically it's not very systematic,

119
00:06:20,280 --> 00:06:23,130
for example you think something is not really a hundred percent right,

120
00:06:23,130 --> 00:06:24,450
you know maybe change that,

121
00:06:24,450 --> 00:06:26,550
and see if you pass the test cases,

122
00:06:26,550 --> 00:06:28,770
tends to be not work that well,

123
00:06:28,770 --> 00:06:30,270
I think that takes a lot of time,

124
00:06:30,780 --> 00:06:32,880
because you might be wrong

125
00:06:32,880 --> 00:06:34,890
or and worse you might be wrong

126
00:06:34,890 --> 00:06:36,780
and actually pass the test case and think you're right,

127
00:06:37,110 --> 00:06:38,220
but it turned out,

128
00:06:38,220 --> 00:06:41,610
like basically you're just shifting the bug from one corner to another corner,

129
00:06:41,610 --> 00:06:42,960
and it will show up later again.

130
00:06:44,010 --> 00:06:49,710
So at a very high-level, this is the approach, that I take,

131
00:06:49,950 --> 00:06:54,870
and you can see what the the key here is really logging the messages.

132
00:06:57,530 --> 00:07:03,400
Any questions or comments on this, this approach,

133
00:07:03,520 --> 00:07:04,870
I know it's a very high level,

134
00:07:04,870 --> 00:07:07,390
but at least give you some sense about how I approach this.

135
00:07:08,040 --> 00:07:10,080
So the messages here are the RPC?

136
00:07:10,410 --> 00:07:11,490
Yes, all the RPCs.

137
00:07:11,610 --> 00:07:12,540
Okay, okay.

138
00:07:15,790 --> 00:07:18,130
Okay, so some, so.

139
00:07:18,220 --> 00:07:19,240
I have a quick question,

140
00:07:20,650 --> 00:07:22,930
so what's a good like approach,

141
00:07:22,930 --> 00:07:26,950
for deciding the granularity of what to log and what not to log?

142
00:07:27,010 --> 00:07:29,590
Ah, that's a very good, exact great question,

143
00:07:29,590 --> 00:07:30,700
I was hoping that someone has ask it,

144
00:07:31,000 --> 00:07:34,930
I tend to be log things are pretty fine-grained,

145
00:07:34,930 --> 00:07:36,580
[] log everything,

146
00:07:37,160 --> 00:07:41,600
and, then, I use you know whatever,

147
00:07:41,600 --> 00:07:44,690
I pulled you know basically the log in an editor

148
00:07:44,690 --> 00:07:47,390
or use Unix utilities like grep

149
00:07:47,480 --> 00:07:49,760
to basically pull out the things that are actually really interested in.

150
00:07:50,590 --> 00:07:52,480
And the reason I'm doing that is,

151
00:07:52,480 --> 00:07:56,920
you know sometimes I don't know what level granularity I want to study something,

152
00:07:57,280 --> 00:08:00,520
and I don't want to go back and run the test again,

153
00:08:00,520 --> 00:08:01,720
I just collect everything,

154
00:08:01,720 --> 00:08:04,810
and then you know filter stuff out, that I know that I care about.

155
00:08:05,340 --> 00:08:06,600
And this brings me on,

156
00:08:06,600 --> 00:08:12,840
so, some people write quite a bit of infrastructure for debugging,

157
00:08:12,870 --> 00:08:17,670
using the logs, making a lot more easier to understand,

158
00:08:17,700 --> 00:08:22,020
I'm pretty primitive, you know DPrintf and logs of information,

159
00:08:22,020 --> 00:08:26,340
although the I I structure my printf in a clear manner,

160
00:08:26,340 --> 00:08:29,310
so I can see what the source, the destination is,

161
00:08:29,670 --> 00:08:32,400
and what the the RPC itself is,

162
00:08:32,550 --> 00:08:37,500
and so I can sort of figure grabbed filter very quickly,

163
00:08:37,590 --> 00:08:41,010
because all the text lines have a particular format.

164
00:08:42,630 --> 00:08:45,930
Some people spend quite a bit of time building some infrastructure

165
00:08:45,930 --> 00:08:48,390
to make it all easier,

166
00:08:48,600 --> 00:08:50,880
take over one of the TAs Jose,

167
00:08:51,150 --> 00:08:52,380
when he took the class,

168
00:08:52,410 --> 00:08:54,090
he actually built some software

169
00:08:54,090 --> 00:08:55,410
to make it a little bit of,

170
00:08:55,410 --> 00:08:58,620
Python script, to make it easier to actually parse the logs,

171
00:08:58,620 --> 00:09:01,680
and I thought it might be interesting to see what he did,

172
00:09:02,070 --> 00:09:03,750
I'm gonna stop sharing,

173
00:09:03,750 --> 00:09:07,170
and then ask Jose to share and maybe demo,

174
00:09:07,170 --> 00:09:10,710
like how his log structure works.

175
00:09:11,430 --> 00:09:13,440
Sorry, I have a follow-up question.

176
00:09:14,200 --> 00:09:20,050
So how do you make the debugging prints going to a log rather than the standard out?

177
00:09:20,290 --> 00:09:26,470
Oh, usually [] to and output to a file, so.

178
00:09:26,500 --> 00:09:28,660
So you just pipe everything into a file.

179
00:09:28,690 --> 00:09:30,280
Yes, I pipe it to a file.

180
00:09:30,910 --> 00:09:31,810
Got it, thank you.

181
00:09:35,240 --> 00:09:37,910
So I guess this Johe's screen and Jose go ahead.

182
00:09:38,500 --> 00:09:39,760
You can hear me again?

183
00:09:40,210 --> 00:09:40,960
Yeah, I can hear you.

184
00:09:41,260 --> 00:09:42,040
Okay awesome,

185
00:09:42,370 --> 00:09:46,240
and as I kind of agree on a bunch of points,

186
00:09:46,240 --> 00:09:49,750
it is things very similar to like how Frans was describing,

187
00:09:49,750 --> 00:09:53,380
[] logs I try to kind of yes,

188
00:09:53,410 --> 00:09:56,470
log every single event that is going on,

189
00:09:56,470 --> 00:10:00,910
and again I also have a format that I follow,

190
00:10:01,300 --> 00:10:04,720
and then I'm gonna show is kind of how went about

191
00:10:04,720 --> 00:10:08,050
making my life easier going and passing through the logs.

192
00:10:08,480 --> 00:10:13,490
The high-level idea is I do very simple struct in Go,

193
00:10:13,760 --> 00:10:17,510
and then I usually dump that the standard out go to a file,

194
00:10:17,510 --> 00:10:20,030
and then I use Python scripts to actually do the,

195
00:10:20,270 --> 00:10:22,730
kind of like all the coloring and structuring,

196
00:10:22,970 --> 00:10:26,870
since that's much easier to do in Python than that in Go.

197
00:10:28,020 --> 00:10:32,940
And so here's for example when I get out of whenever a test in Go,

198
00:10:32,940 --> 00:10:34,980
so when I enable the VERBOSE,

199
00:10:35,280 --> 00:10:38,520
I just get like an output that looks something like this,

200
00:10:38,700 --> 00:10:41,010
and here what I'm logging is,

201
00:10:41,040 --> 00:10:44,160
kind of like the number of milliseconds is the first column,

202
00:10:44,190 --> 00:10:47,490
and that's pretty useful when you're trying to debug timer events,

203
00:10:47,860 --> 00:10:48,580
things like that,

204
00:10:48,580 --> 00:10:51,640
are trying to see how long an RPC takes to fail,

205
00:10:51,730 --> 00:10:55,630
then the second column is what I would like to call topics,

206
00:10:55,900 --> 00:10:56,950
they're not levels,

207
00:10:56,950 --> 00:10:59,470
because they are you know there's no hierarchy [],

208
00:10:59,470 --> 00:11:01,930
and they're just related to different events in Raft,

209
00:11:01,990 --> 00:11:04,900
probably a lot of you right now have realized that,

210
00:11:04,900 --> 00:11:06,910
in lab 3, a lot of things going on,

211
00:11:07,150 --> 00:11:10,270
like timers, there's elections, there's like log,

212
00:11:10,270 --> 00:11:13,360
things being applied communication with a state machine,

213
00:11:13,700 --> 00:11:16,850
and all of those events happen with slightly different frequencies,

214
00:11:17,030 --> 00:11:20,930
so if you want to later, like select some of them

215
00:11:20,930 --> 00:11:24,260
or like decide to ignore the more most ones,

216
00:11:24,410 --> 00:11:28,550
it's really handy to just have like that, that category,

217
00:11:28,580 --> 00:11:32,330
and then the third column probably a lot of you have something like this is

218
00:11:32,450 --> 00:11:35,180
which server who is saying this message,

219
00:11:35,180 --> 00:11:38,120
because we thought that is pretty hard to reason about what is going on,

220
00:11:38,880 --> 00:11:41,370
and the rest is just a free form message,

221
00:11:41,370 --> 00:11:44,160
that explains kind of like what this message is about,

222
00:11:44,370 --> 00:11:50,280
and even though this is kind of just the very initial test that you run,

223
00:11:50,280 --> 00:11:53,100
the one that just passed, that you can do an election,

224
00:11:53,340 --> 00:11:57,740
you have to like read, follow what the logic is going on here.

225
00:11:58,190 --> 00:12:02,600
So the way I made this easier kind of like first approach

226
00:12:02,600 --> 00:12:04,880
and this is what I did when I took the class,

227
00:12:04,880 --> 00:12:08,500
was yes, convert all the topics into colors,

228
00:12:08,500 --> 00:12:13,420
like most more internal support wide array of color support,

229
00:12:13,420 --> 00:12:16,480
and again by doing this in Python,

230
00:12:16,480 --> 00:12:20,620
you can use some fantastic libraries that do all the heavy lifting,

231
00:12:20,620 --> 00:12:24,520
so you don't have to get in the in the way of doing this.

232
00:12:24,900 --> 00:12:28,380
And here yes have included different events with different colors,

233
00:12:28,590 --> 00:12:31,380
and as you get more familiar with the colors,

234
00:12:31,380 --> 00:12:34,260
for example here all the timers events are in gray,

235
00:12:34,260 --> 00:12:36,150
so maybe they're easier to ignore,

236
00:12:36,240 --> 00:12:39,390
or we're looking for when someone is voting,

237
00:12:39,390 --> 00:12:42,300
we can look at like cyan, which relate to vote,

238
00:12:42,790 --> 00:12:48,640
and that like we'll just encode visually things are much easier to pick up,

239
00:12:48,940 --> 00:12:52,420
for example here yellow is when we elect, elect a new leader.

240
00:12:53,140 --> 00:12:55,870
We still have to decide who is saying what,

241
00:12:55,900 --> 00:12:58,340
and in order to do that,

242
00:12:58,340 --> 00:13:02,000
what I incorporated just having different columns,

243
00:13:02,330 --> 00:13:05,570
and again what I'm doing is just running here,

244
00:13:05,570 --> 00:13:08,810
what I'm doing just running the standard test script,

245
00:13:08,810 --> 00:13:12,800
and then just piping that into like the the script I wrote,

246
00:13:13,290 --> 00:13:15,990
in this case, I'm specifying that I have three columns,

247
00:13:15,990 --> 00:13:18,270
because of like three peers in this test case,

248
00:13:18,390 --> 00:13:21,960
and I have now decided to ignore the timer,

249
00:13:21,960 --> 00:13:23,970
like the events with the timer topic,

250
00:13:23,970 --> 00:13:25,800
because there are too many of them,

251
00:13:25,890 --> 00:13:27,420
and if timing logic is working,

252
00:13:27,420 --> 00:13:29,910
we probably don't need them to the debug what's going on,

253
00:13:30,570 --> 00:13:32,700
and if you look at this log,

254
00:13:32,700 --> 00:13:35,160
compared to what we the plaintext log,

255
00:13:35,280 --> 00:13:37,950
is fairly easy to see, that what's going on,

256
00:13:37,950 --> 00:13:39,990
it's like three servers are starting,

257
00:13:40,020 --> 00:13:41,910
the last one is becoming a candidate,

258
00:13:41,970 --> 00:13:43,620
the other two are voting for that,

259
00:13:44,000 --> 00:13:46,970
it's becoming a leader as soon as it gets the first vote,

260
00:13:46,970 --> 00:13:50,150
and then it just heartbeats through the rest of the test,

261
00:13:50,660 --> 00:13:52,820
and there's nothing else to look at it.

262
00:13:53,450 --> 00:13:56,510
But now again compared to this,

263
00:13:56,980 --> 00:14:00,340
it's kind of like an order of magnitude easier to pick up what is going on,

264
00:14:00,820 --> 00:14:02,800
and as you tweak that to your liking,

265
00:14:02,800 --> 00:14:04,360
it becomes more and more efficient.

266
00:14:05,160 --> 00:14:07,920
And as you move to like harder test,

267
00:14:07,980 --> 00:14:09,750
because a lot of you have probably have

268
00:14:09,900 --> 00:14:14,820
had to look at the logs of the backup test in the 2B lab,

269
00:14:14,850 --> 00:14:18,060
there will be lots and lots of events going on,

270
00:14:18,060 --> 00:14:20,760
and even if you know what you need,

271
00:14:20,760 --> 00:14:23,250
it might become like a daunting task,

272
00:14:23,600 --> 00:14:26,570
going through like thousands of lines of logs,

273
00:14:26,570 --> 00:14:28,910
you're searching for the point of failure

274
00:14:28,910 --> 00:14:30,950
and trying to reason about what's going on.

275
00:14:32,490 --> 00:14:34,230
Again, if we look,

276
00:14:34,260 --> 00:14:40,110
just like make this a kind of a similar format to visualize,

277
00:14:40,290 --> 00:14:42,420
we can quickly see what's going on,

278
00:14:42,450 --> 00:14:45,960
we just have like five different servers, that are starting,

279
00:14:46,170 --> 00:14:48,150
the first one is becoming a candidate,

280
00:14:48,390 --> 00:14:49,950
the other ones are voting for it,

281
00:14:50,380 --> 00:14:51,550
becoming a leader,

282
00:14:51,730 --> 00:14:54,160
and by looking at the different columns,

283
00:14:54,250 --> 00:14:54,640
we can see,

284
00:14:54,640 --> 00:14:57,160
for example all like purple [],

285
00:14:57,160 --> 00:14:59,410
whenever something is committed or applied,

286
00:14:59,410 --> 00:15:02,530
so we can see that a new entry is received,

287
00:15:02,960 --> 00:15:05,450
and this, this servers are receiving,

288
00:15:05,480 --> 00:15:10,280
and because backup to have a very verbose log,

289
00:15:10,490 --> 00:15:12,830
I have a lot of drop RPCs,

290
00:15:12,830 --> 00:15:16,030
I'm also ignoring those topics here,

291
00:15:16,060 --> 00:15:18,310
and as the test goes on,

292
00:15:18,370 --> 00:15:20,650
we can start reasoning about what's going on,

293
00:15:20,710 --> 00:15:22,570
so so maybe helpful

294
00:15:22,600 --> 00:15:26,980
to just have like some print statements or like the debug statements in the test code,

295
00:15:26,980 --> 00:15:28,660
you just can modify there,

296
00:15:29,050 --> 00:15:30,550
to know what the test is doing,

297
00:15:30,550 --> 00:15:32,410
for example here the test detects,

298
00:15:32,470 --> 00:15:35,830
that the first server S0 is the leader,

299
00:15:35,980 --> 00:15:39,180
and then disconnects S2 to S4,

300
00:15:39,180 --> 00:15:41,550
which are like the three on the right side,

301
00:15:41,880 --> 00:15:43,830
and that's pretty much what happens,

302
00:15:43,830 --> 00:15:47,700
we just get a stream of entries, that won't be committed,

303
00:15:47,700 --> 00:15:51,330
because there's only two servers that can talk to each other,

304
00:15:51,330 --> 00:15:52,950
and then after a while,

305
00:15:53,410 --> 00:15:56,290
we see that the first two are now disconnected,

306
00:15:56,320 --> 00:16:00,040
and the three on the right are reconnected,

307
00:16:00,040 --> 00:16:01,930
and now they can form a majority,

308
00:16:02,510 --> 00:16:04,010
and that's what we will see,

309
00:16:04,010 --> 00:16:07,970
like the last one becomes a candidate, achieves a majority,

310
00:16:08,060 --> 00:16:14,270
and kind of repeatedly we see the color pattern of like green and purple,

311
00:16:14,330 --> 00:16:18,560
like this staircase signifying that oh yeah receiving an entry,

312
00:16:18,740 --> 00:16:21,470
and propagating it to the other servers,

313
00:16:21,500 --> 00:16:25,190
and the disconnected servers here converting to a candidate.

314
00:16:25,610 --> 00:16:27,620
And hopefully I've convinced you by now,

315
00:16:27,620 --> 00:16:31,910
by there's slightly changing the presentation of your logs,

316
00:16:31,910 --> 00:16:36,920
kind of like the mental effort to like go through them can significantly decrease,

317
00:16:37,190 --> 00:16:39,890
and even though this is really fancy,

318
00:16:39,890 --> 00:16:43,070
there's not a lot of like fancy code,

319
00:16:43,070 --> 00:16:48,410
going on, I just use some of the self python libraries, mainly rich,

320
00:16:48,770 --> 00:16:53,430
and kind of all fits in about like a hundred lines of Python script,

321
00:16:53,460 --> 00:16:55,650
and if you're interested,

322
00:16:55,650 --> 00:16:57,810
I wrote a blog post,

323
00:16:57,810 --> 00:17:00,810
that will be linking on the web site on Piazza,

324
00:17:00,810 --> 00:17:05,470
about kind of like the these steps to build a tool like this,

325
00:17:05,470 --> 00:17:07,510
and you know how it all fit together,

326
00:17:07,510 --> 00:17:10,390
like some like design decisions related to that.

327
00:17:11,130 --> 00:17:15,180
And if anyone has any questions specific to this, happy to answer them.

328
00:17:23,500 --> 00:17:24,730
Any questions for Jose?

329
00:17:25,770 --> 00:17:29,130
Yeah, I have a question more about general logging,

330
00:17:29,670 --> 00:17:32,040
so I know that had some bugs,

331
00:17:32,250 --> 00:17:36,870
that when I put in the logging they were no longer there,

332
00:17:37,290 --> 00:17:42,180
because of some timing issue, or perhaps a concurrency issue,

333
00:17:42,360 --> 00:17:44,340
so what, what do we do then?

334
00:17:45,280 --> 00:17:48,370
Okay, so there's a couple things I do,

335
00:17:48,370 --> 00:17:51,490
first of all, one reason I log it sort of a fine-grained,

336
00:17:51,640 --> 00:17:55,300
always at the same level of granularity and fine granularity,

337
00:17:55,300 --> 00:17:57,310
so I always have a trace with everything,

338
00:17:57,310 --> 00:17:58,900
and I generally don't have to go back.

339
00:18:00,280 --> 00:18:02,200
The other thing to do is,

340
00:18:02,200 --> 00:18:05,500
I do run the test many many times,

341
00:18:05,500 --> 00:18:06,940
and basically save all logs,

342
00:18:07,490 --> 00:18:09,350
and then once I hit the wrong one,

343
00:18:09,350 --> 00:18:10,580
once I hit a bug,

344
00:18:10,610 --> 00:18:12,950
then you know I really studied that particular log.

345
00:18:16,920 --> 00:18:18,900
And so, for example if I run something overnight,

346
00:18:18,930 --> 00:18:21,720
I just save all the logs from all the runs overnight,

347
00:18:21,720 --> 00:18:23,640
and then grab the one you know failed.

348
00:18:29,440 --> 00:18:33,660
Anybody have any further questions on the topic of logging?

349
00:18:39,220 --> 00:18:41,650
Okay good, let me proceed,

350
00:18:42,320 --> 00:18:44,570
before again, you know look at code,

351
00:18:44,570 --> 00:18:46,340
I want to talk a little bit about the structure,

352
00:18:46,970 --> 00:18:49,280
that my particular solution has,

353
00:18:49,280 --> 00:18:51,440
and this is definitely not the only structure,

354
00:18:51,500 --> 00:18:53,330
you can do it in many many different ways,

355
00:18:53,360 --> 00:18:56,420
and you're you're free to actually do it in many different ways,

356
00:18:56,750 --> 00:19:00,050
and the fact that every year when I teach class,

357
00:19:00,050 --> 00:19:03,050
I I actually try to rewrite,

358
00:19:03,050 --> 00:19:05,030
implement the labs again,

359
00:19:05,210 --> 00:19:08,870
and often experiment with different types of ways of implementing it.

360
00:19:09,430 --> 00:19:13,510
So the one I'll show you with you today is

361
00:19:13,510 --> 00:19:15,670
one that I wrote over [],

362
00:19:15,670 --> 00:19:18,010
you know sort of getting ready for 6.824,

363
00:19:18,250 --> 00:19:20,350
and then it has the following structure.

364
00:19:20,680 --> 00:19:22,150
It's a pretty standard structure,

365
00:19:22,360 --> 00:19:25,030
you know, let me draw a box,

366
00:19:25,610 --> 00:19:28,430
you know signifying the Raft library,

367
00:19:28,550 --> 00:19:34,060
you know there's two basically API calls, right,

368
00:19:34,060 --> 00:19:38,530
one Start, to sort of initiate append entries

369
00:19:38,710 --> 00:19:42,790
and to initiate a logging operation one to actually

370
00:19:43,620 --> 00:19:47,640
output you know that goes come through the apply channel,

371
00:19:48,530 --> 00:19:53,120
then, in you know one documentation we're showing,

372
00:19:53,120 --> 00:19:58,060
how basically one, essentially one structure, the Raft structure,

373
00:19:59,340 --> 00:20:04,410
that basically has all the state of the of the Raft library,

374
00:20:04,440 --> 00:20:07,860
you know all the variables that are in the figure 2,

375
00:20:08,160 --> 00:20:11,430
and basically have one lock on this guy,

376
00:20:13,490 --> 00:20:15,800
and basically all my,

377
00:20:15,830 --> 00:20:20,150
so I use quite coarse-grained locking all my RPC handlers,

378
00:20:20,150 --> 00:20:22,100
all my start,

379
00:20:22,220 --> 00:20:24,320
take basically just one lock,

380
00:20:24,560 --> 00:20:26,780
do whatever stuff they need to do,

381
00:20:26,780 --> 00:20:28,790
do and then release the lock,

382
00:20:29,510 --> 00:20:33,320
so there's a couple threads you know that sort of running around,

383
00:20:33,470 --> 00:20:35,570
one of course is the ticker threads,

384
00:20:35,570 --> 00:20:37,280
that we sort of gave you,

385
00:20:38,030 --> 00:20:40,490
and you know that just wait,

386
00:20:40,700 --> 00:20:41,630
I'll show you in a second,

387
00:20:41,630 --> 00:20:45,290
that will wait for some number of milliseconds, you know 50 milliseconds,

388
00:20:45,680 --> 00:20:48,890
and then run and then check periodically,

389
00:20:48,890 --> 00:20:51,590
if any timeout, election timeout has gone off,

390
00:20:51,590 --> 00:20:53,060
and does whatever needs to be done,

391
00:20:53,810 --> 00:20:58,040
I have one thread dedicated to writing on the apply channel,

392
00:20:58,310 --> 00:21:01,040
so no other thread actually writes to the apply channel,

393
00:21:01,040 --> 00:21:02,150
there's only a single one,

394
00:21:02,330 --> 00:21:04,850
and it basically sleeps on a condition variable,

395
00:21:07,240 --> 00:21:13,720
and so when for example a new append entry comes in from the leader,

396
00:21:13,720 --> 00:21:17,500
and the commit index goes up,

397
00:21:17,710 --> 00:21:22,000
then you know the thread, that thread will wake up on the signal,

398
00:21:22,000 --> 00:21:24,130
and the condition variable that will wake up the thread,

399
00:21:24,130 --> 00:21:27,070
that actually looks at the apply, that writes the apply channel,

400
00:21:27,130 --> 00:21:30,340
it will grab whatever you know entries out of the log,

401
00:21:30,700 --> 00:21:32,560
and stick them on the apply channel.

402
00:21:36,440 --> 00:21:38,720
And, so that's one reason,

403
00:21:38,720 --> 00:21:40,880
a single thread is that of course you can't hold locks,

404
00:21:40,880 --> 00:21:43,100
while writing across the apply channel,

405
00:21:43,100 --> 00:21:45,500
but at least you might get a [] problems later,

406
00:21:45,770 --> 00:21:48,350
and so I just have a single thread,

407
00:21:48,350 --> 00:21:50,030
that actually writes on the apply channel.

408
00:21:51,590 --> 00:21:57,720
Then, the of course you know number of things coming in from the outside,

409
00:21:57,720 --> 00:21:59,790
you know require messages coming in,

410
00:22:00,180 --> 00:22:03,360
and of course each message or each RPC starts its own thread,

411
00:22:03,510 --> 00:22:08,340
like Go will, RPC library will basically start a thread for every incoming message,

412
00:22:08,700 --> 00:22:12,120
and basically the way I process every incoming messages,

413
00:22:12,120 --> 00:22:14,610
the first thing that grabs the log on the Raft structure,

414
00:22:14,880 --> 00:22:17,010
it reads writes you know the Raft structure,

415
00:22:17,010 --> 00:22:17,880
and then when it's done,

416
00:22:17,910 --> 00:22:21,360
you have releases the lock, maybe lock,

417
00:22:21,360 --> 00:22:22,320
and maybe in between,

418
00:22:22,320 --> 00:22:25,590
it will update you know signal in the condition variable too.

419
00:22:27,850 --> 00:22:30,040
Then, of course Start itself,

420
00:22:30,100 --> 00:22:32,050
you know runs on a particular thread,

421
00:22:32,810 --> 00:22:34,760
so it jumps into the Raft library,

422
00:22:34,760 --> 00:22:35,900
you know that's the same thing,

423
00:22:35,900 --> 00:22:37,820
you know acquire lock and then,

424
00:22:37,910 --> 00:22:41,870
let me append entry,

425
00:22:41,870 --> 00:22:46,250
if the leader appended to the log and the log structure,

426
00:22:46,670 --> 00:22:50,660
and then sends off you know the append RPC, append RPCs,

427
00:22:51,050 --> 00:22:54,860
and since I want to do the append RPC in parallel,

428
00:22:54,890 --> 00:22:57,590
basically what the way it works is,

429
00:22:57,590 --> 00:22:59,810
that you know for every RPC,

430
00:23:00,390 --> 00:23:01,860
I start a separate thread,

431
00:23:02,700 --> 00:23:06,690
and that are in that thread actually is responsible for sending it,

432
00:23:06,870 --> 00:23:11,490
reserving the response and in the response you know doing any updating,

433
00:23:11,490 --> 00:23:13,290
that is necessary to the Raft structure,

434
00:23:13,320 --> 00:23:16,470
so response handler when the response comes in,

435
00:23:16,710 --> 00:23:19,990
you know grab the Raft lock,

436
00:23:20,080 --> 00:23:23,380
and then do whatever update necessary to the Raft state

437
00:23:23,380 --> 00:23:24,430
and then release the lock.

438
00:23:25,320 --> 00:23:27,780
So, so there's a bunch of threads,

439
00:23:27,780 --> 00:23:29,730
quite a number of threads you can be running around,

440
00:23:29,730 --> 00:23:31,620
because some messages may be late,

441
00:23:31,620 --> 00:23:34,950
you know and so there may be many, many, many threads here,

442
00:23:35,510 --> 00:23:38,270
and there might be multiple Starts,

443
00:23:38,270 --> 00:23:39,680
there might be a Start outstanding is,

444
00:23:39,680 --> 00:23:41,000
instead of maybe multiple threads there,

445
00:23:41,000 --> 00:23:46,790
and of course your ticker you know also start, may send heartbeats,

446
00:23:46,790 --> 00:23:50,690
and those heartbeats you know again turn into a separate thread,

447
00:23:51,870 --> 00:23:57,150
but all those threads are basically serialized by the Raft lock

448
00:23:57,210 --> 00:23:58,950
or by Raft lock serialize.

449
00:24:08,880 --> 00:24:11,250
And so when I print, print log messages,

450
00:24:11,250 --> 00:24:14,970
you know of course this inside you know done while holding the Raft lock,

451
00:24:15,270 --> 00:24:19,200
and since you know sort of every thread runs one by one,

452
00:24:19,200 --> 00:24:21,480
you know a lot of messages would make a lot of sense,

453
00:24:21,480 --> 00:24:23,700
you know they they all serialized too.

454
00:24:24,520 --> 00:24:31,720
Similar, I make all RPC handlers atomic or serialized,

455
00:24:32,740 --> 00:24:34,510
so you know fine-grained locking,

456
00:24:34,660 --> 00:24:37,750
and that helps and I'll talk about in a second,

457
00:24:38,230 --> 00:24:41,980
and then the only thing that you have to be little bit careful with,

458
00:24:41,980 --> 00:24:43,870
if you do sort of coarse-grained locking,

459
00:24:44,200 --> 00:24:46,870
is that now you can get into deadlocks,

460
00:24:46,870 --> 00:24:48,280
in particular, you can have deadlock,

461
00:24:48,280 --> 00:24:50,080
if you hold locks across RPCs,

462
00:24:50,080 --> 00:24:54,970
and so I never hold no locks across RPCs,

463
00:24:58,620 --> 00:25:00,000
and that partially achieved,

464
00:25:00,000 --> 00:25:02,760
your as achieved as a side effect

465
00:25:02,760 --> 00:25:05,040
of really starting a new thread for every RPC.

466
00:25:06,670 --> 00:25:08,950
So that's sort of the overall structure,

467
00:25:08,980 --> 00:25:12,310
also by this particular solution,

468
00:25:12,310 --> 00:25:13,690
that I'll share in a second with you,

469
00:25:14,170 --> 00:25:16,600
again, other structures are possible,

470
00:25:16,630 --> 00:25:20,310
but hopefully this gives you some, some ideas,

471
00:25:20,340 --> 00:25:21,810
any questions about this?

472
00:25:22,820 --> 00:25:24,830
What were the threads on the right?

473
00:25:25,650 --> 00:25:26,670
On the right, these guys?

474
00:25:27,760 --> 00:25:28,270
Yeah.

475
00:25:28,300 --> 00:25:29,980
Those are the incoming messages,

476
00:25:30,890 --> 00:25:32,870
so like append RPC,

477
00:25:32,870 --> 00:25:36,470
for append RPC request or vote request,

478
00:25:36,680 --> 00:25:37,730
I think the only two.

479
00:25:40,840 --> 00:25:42,430
I also have a question,

480
00:25:42,430 --> 00:25:44,740
what's the,

481
00:25:45,040 --> 00:25:51,040
is there a benefit of having a single thread sleeping on the condition variable,

482
00:25:51,040 --> 00:25:53,710
and then having only that thread,

483
00:25:54,130 --> 00:25:56,950
a thread sending to apply channel,

484
00:25:57,070 --> 00:26:03,310
compared to having each RPC thread send to the apply channel.

485
00:26:03,310 --> 00:26:06,520
Well, everything has to go in order on the apply channel, correct,

486
00:26:06,550 --> 00:26:09,130
so the whole log that you made,

487
00:26:09,510 --> 00:26:12,810
that's in the Raft structure has to be sent on the apply channel,

488
00:26:12,810 --> 00:26:15,810
exactly in order as the entries are in the log,

489
00:26:16,540 --> 00:26:18,250
and so that's just more easier to do,

490
00:26:18,250 --> 00:26:21,520
I find it easy to do with the single thread,

491
00:26:22,470 --> 00:26:24,390
because that basically goes through the Raft log,

492
00:26:24,390 --> 00:26:27,690
and there's sticks from one by one the entries onto the apply channel,

493
00:26:28,580 --> 00:26:30,500
and there's no sort of coordination necessary.

494
00:26:32,000 --> 00:26:33,080
That makes sense, okay.

495
00:26:34,240 --> 00:26:35,890
Yeah, so like we all you know,

496
00:26:36,820 --> 00:26:43,420
yeah, so this goes like up into the servers that actually uses the Raft library.

497
00:26:45,670 --> 00:26:51,520
Okay, so one more word about about sort of fine-grained versus coarse-grained,

498
00:26:52,060 --> 00:26:57,280
some of you, it's a common mistake early on,

499
00:26:57,280 --> 00:27:00,370
when you haven't done that much you know parallel programming,

500
00:27:00,760 --> 00:27:05,200
you might do, if you have your RPC struct,

501
00:27:06,160 --> 00:27:09,580
you know maybe you have like the log and some other fields,

502
00:27:09,580 --> 00:27:13,360
and some people or sometimes you know there's a []

503
00:27:13,360 --> 00:27:16,630
or not reasonable to have multiple locks,

504
00:27:16,960 --> 00:27:24,010
so instead of having a single lock or even have a single one,

505
00:27:25,030 --> 00:27:26,890
but not really hold it for a long time.

506
00:27:36,550 --> 00:27:40,020
And, and I think in general,

507
00:27:40,080 --> 00:27:42,360
might reasoning about the code a little bit hard,

508
00:27:42,390 --> 00:27:46,980
so for example common thing that you know you might do,

509
00:27:46,980 --> 00:27:49,140
then it's like if you have an RPC handler,

510
00:27:49,170 --> 00:27:56,090
like this some Request handler, you know whatever Args, Reply,

511
00:27:57,250 --> 00:27:58,600
just sketching this out,

512
00:27:58,600 --> 00:28:01,900
you know you might know something, you might do like whatever mu.lock,

513
00:28:03,510 --> 00:28:06,570
do something you know with arguments,

514
00:28:06,570 --> 00:28:10,890
maybe you know updates some state you know in the Raft structure,

515
00:28:10,890 --> 00:28:12,240
and to mu.unlock,

516
00:28:14,760 --> 00:28:16,650
then maybe do some other stuff,

517
00:28:16,650 --> 00:28:19,140
there's not maybe directly related to the Raft structure,

518
00:28:19,140 --> 00:28:21,090
and then basically maybe grab the lock again,

519
00:28:23,440 --> 00:28:27,220
and then you know whatever update and read maybe to Raft structure again,

520
00:28:27,220 --> 00:28:28,300
and then unlock,

521
00:28:28,810 --> 00:28:32,140
and all you're sort of in a single RPC handler.

522
00:28:33,160 --> 00:28:37,800
And, just as a thought exercise,

523
00:28:37,800 --> 00:28:42,090
what is risky about this sort of style of fine-grained locking?

524
00:28:42,740 --> 00:28:44,450
I know this is a bit artificial,

525
00:28:44,450 --> 00:28:47,570
but it is a reasonable common,

526
00:28:48,120 --> 00:28:51,150
sort of early mistake that you know you might make.

527
00:28:53,970 --> 00:28:55,950
You have to like recheck your assumptions,

528
00:28:56,510 --> 00:28:59,390
before locking again every time, right?

529
00:28:59,420 --> 00:29:03,080
Yeah, you know basically this executes atomically,

530
00:29:03,110 --> 00:29:04,580
this executes atomically,

531
00:29:04,700 --> 00:29:07,280
but lots of things can happen in between, right,

532
00:29:07,280 --> 00:29:09,650
so for example new RPCs might have been coming in,

533
00:29:10,910 --> 00:29:12,560
and they might be running too,

534
00:29:12,560 --> 00:29:16,940
and they might actually have been updating the Raft struct or Raft state,

535
00:29:17,000 --> 00:29:19,520
between these two critical sections,

536
00:29:20,170 --> 00:29:21,250
between one and two,

537
00:29:22,090 --> 00:29:24,370
and so by the time you know to the,

538
00:29:24,610 --> 00:29:26,410
you start running critical section 2,

539
00:29:26,530 --> 00:29:28,660
Raft structure might be completely different,

540
00:29:28,990 --> 00:29:31,000
and have might completely different content,

541
00:29:31,910 --> 00:29:35,150
and, so to avoid you know those kind of situations,

542
00:29:35,300 --> 00:29:38,060
you know my general approach is to basically,

543
00:29:38,060 --> 00:29:41,960
you know basically have is to be one critical, one critical section,

544
00:29:42,600 --> 00:29:44,970
so I don't have to recheck any,

545
00:29:45,240 --> 00:29:47,340
I don't have to recheck the state at the new,

546
00:29:47,340 --> 00:29:52,580
when the second critical section starts.

547
00:29:53,220 --> 00:29:54,030
Does that make sense?

548
00:29:56,410 --> 00:29:58,780
This problem shows up in different you know,

549
00:29:59,170 --> 00:30:03,580
or this problem can show up in a different fashion, in different ways,

550
00:30:03,640 --> 00:30:06,070
but you know of [] problems, always the same,

551
00:30:06,070 --> 00:30:07,480
if you do a lot of fine-grained locking,

552
00:30:07,480 --> 00:30:09,610
you're going to have additional interleavings,

553
00:30:09,760 --> 00:30:12,970
and you have to consider and make sure that,

554
00:30:12,970 --> 00:30:19,480
you don't have a incorrect interleavings will result in incorrect behavior.

555
00:30:22,150 --> 00:30:23,350
I want to ask,

556
00:30:23,350 --> 00:30:28,360
is it, but it's not possible to avoid rechecking conditions,

557
00:30:28,360 --> 00:30:32,770
after you send an RPC thread, inside the RPC thread.

558
00:30:33,560 --> 00:30:37,580
Yeah, you, you cannot hold a lock while sending, right,

559
00:30:37,580 --> 00:30:39,020
so you should not you know,

560
00:30:39,200 --> 00:30:42,470
here you should not call whatever you know send RPC,

561
00:30:44,030 --> 00:30:46,130
because you can't do that while holding a lock,

562
00:30:46,130 --> 00:30:47,750
because they can easily result in deadlock

563
00:30:47,750 --> 00:30:48,890
or you're holding a lock,

564
00:30:48,890 --> 00:30:51,830
you sent it to a peer in RPC, while still holding the lock,

565
00:30:51,830 --> 00:30:54,800
the peer actually sends RPC to you,

566
00:30:54,980 --> 00:30:56,390
but you're holding you know,

567
00:30:56,390 --> 00:30:59,900
that you're the leader already holds the lock and the [] structure,

568
00:30:59,900 --> 00:31:02,600
so the response cannot be process,

569
00:31:02,900 --> 00:31:05,420
and maybe you know the two are interdependent,

570
00:31:05,660 --> 00:31:07,310
and may you have a deadlock.

571
00:31:09,450 --> 00:31:12,060
One thing that's worth noting is,

572
00:31:12,600 --> 00:31:14,880
something I saw some people doing is that,

573
00:31:14,880 --> 00:31:18,120
they spin off a thread to send an RPC,

574
00:31:18,390 --> 00:31:22,860
in that thread, they take the lock to prepare the arguments for the RPC,

575
00:31:22,980 --> 00:31:25,020
and then they send the RPC without lock,

576
00:31:25,140 --> 00:31:26,610
and you can do that,

577
00:31:26,610 --> 00:31:29,880
but it's often a fewer interleavings,

578
00:31:29,880 --> 00:31:32,220
if you generate the arguments for the RPC,

579
00:31:32,280 --> 00:31:34,110
before you spin off the thread,

580
00:31:34,140 --> 00:31:35,670
that actually sends it.

581
00:31:38,420 --> 00:31:41,210
Good point, we'll see, we'll show, this will show up in a second,

582
00:31:41,210 --> 00:31:41,780
actually in the.

583
00:31:42,140 --> 00:31:44,330
But doesn't that cause,

584
00:31:44,360 --> 00:31:47,990
so sometimes it's actually depending on the implementation,

585
00:31:47,990 --> 00:31:51,620
I think it's beneficial for other RPCs to see the changes,

586
00:31:51,620 --> 00:31:55,580
like for example if other RPCs made progress,

587
00:31:55,580 --> 00:31:58,970
you want to start off from the most recent last log index.

588
00:32:00,250 --> 00:32:05,260
Perhaps, it depends on exactly what you do,

589
00:32:05,350 --> 00:32:08,140
like how your implementation works,

590
00:32:08,380 --> 00:32:10,870
I I don't do that,

591
00:32:11,170 --> 00:32:14,020
at least, I don't think I do what you're suggesting,

592
00:32:14,020 --> 00:32:16,150
when I send an RPC to all the peers,

593
00:32:16,150 --> 00:32:18,490
all the peers are going to get exactly the same arguments,

594
00:32:19,980 --> 00:32:21,210
and no change in between.

595
00:32:26,350 --> 00:32:31,690
Okay, good, so okay, let me then talk a little bit about the implementation,

596
00:32:31,690 --> 00:32:35,260
can people read, can people read the screen?

597
00:32:35,870 --> 00:32:37,040
Sorry, I have a follow up question.

598
00:32:37,880 --> 00:32:39,140
Yeah.

599
00:32:39,170 --> 00:32:40,310
So I think you mentioned,

600
00:32:40,310 --> 00:32:44,690
that we shouldn't lock around sending things over the apply channel.

601
00:32:45,720 --> 00:32:49,260
Yes, although, let me,

602
00:32:49,500 --> 00:32:51,450
yeah, it's risky,

603
00:32:51,840 --> 00:32:54,450
because while you're holding the lock, right,

604
00:32:54,450 --> 00:32:55,800
you send on the apply channel,

605
00:32:55,800 --> 00:32:58,080
you might also block sending on the apply channel,

606
00:32:58,080 --> 00:33:03,510
because the servers you know must, the other side must be reading, correct,

607
00:33:03,510 --> 00:33:04,710
before you're unlock,

608
00:33:05,590 --> 00:33:06,550
of course, you have buffered,

609
00:33:06,550 --> 00:33:08,110
and buffered, it changed a little bit,

610
00:33:08,110 --> 00:33:09,820
let's say we have a not buffer channel,

611
00:33:09,820 --> 00:33:12,040
but just an unbuffered channel,

612
00:33:12,880 --> 00:33:17,080
and so the reader, if there's no reader,

613
00:33:17,830 --> 00:33:19,570
then this writer will block,

614
00:33:20,770 --> 00:33:22,270
and maybe holding the lock,

615
00:33:22,360 --> 00:33:26,170
and that might be you know mainly to problems later

616
00:33:26,470 --> 00:33:27,730
and lead to deadlocks.

617
00:33:30,460 --> 00:33:34,150
On that, isn't this all right,

618
00:33:34,150 --> 00:33:36,790
like like the apply channel will never,

619
00:33:37,150 --> 00:33:41,170
like the client who's calling Raft,

620
00:33:41,500 --> 00:33:43,600
will never hold the lock, right, they're like.

621
00:33:43,630 --> 00:33:45,910
You don't, not not true,

622
00:33:46,370 --> 00:33:49,460
here's are sort of servers right sitting on top,

623
00:33:50,140 --> 00:33:53,740
calling Start and reading from the apply channel,

624
00:33:54,360 --> 00:33:55,560
but it's called Start,

625
00:33:55,800 --> 00:33:58,050
Start is you know depending on how you do it,

626
00:33:58,050 --> 00:33:59,130
you start as a thread,

627
00:33:59,160 --> 00:34:02,100
and jumps into with that thread into the Raft library,

628
00:34:02,100 --> 00:34:03,600
and at least in my implementation,

629
00:34:03,600 --> 00:34:05,910
the first thing that Start function does is

630
00:34:05,910 --> 00:34:07,140
actually grap the Raft lock,

631
00:34:10,250 --> 00:34:12,710
and it can't grab the lock, raft lock,

632
00:34:12,710 --> 00:34:15,530
is actually either the apply thread is already holding it,

633
00:34:15,530 --> 00:34:17,210
trying to get something on the apply channel,

634
00:34:17,480 --> 00:34:19,670
but the servers now won't read from the apply channel,

635
00:34:19,670 --> 00:34:20,960
depending on how you set it up,

636
00:34:20,960 --> 00:34:22,220
but as you're saying that,

637
00:34:22,220 --> 00:34:23,090
there is a risk here,

638
00:34:23,120 --> 00:34:24,230
you've got to be a little careful.

639
00:34:25,190 --> 00:34:29,930
So would the solution be just to like create a new thread?

640
00:34:29,930 --> 00:34:31,610
Yes, there's all kinds of possible solutions here,

641
00:34:31,640 --> 00:34:34,850
I'm just like warning you, that you know there's alerting you,

642
00:34:34,850 --> 00:34:37,910
that you have to think a little bit about how you arrange this.

643
00:34:40,710 --> 00:34:41,310
Okay?

644
00:34:42,380 --> 00:34:46,310
But, isn't, isn't it using a single thread not sufficient,

645
00:34:46,310 --> 00:34:49,510
because the thread that puts it onto the apply channel,

646
00:34:49,510 --> 00:34:51,640
will still be looking at data, right,

647
00:34:51,640 --> 00:34:53,590
so it still need to acquire the lock.

648
00:34:54,550 --> 00:34:57,190
Okay, Okay, let me get back on here,

649
00:34:57,190 --> 00:34:59,350
it's easy to see that the deadlock here, correct,

650
00:34:59,560 --> 00:35:01,210
like if you're in the apply channel,

651
00:35:01,240 --> 00:35:02,740
you're not reading from the apply channel,

652
00:35:02,740 --> 00:35:05,260
because you're, you're calling Start,

653
00:35:05,870 --> 00:35:07,640
like maybe I get,

654
00:35:08,600 --> 00:35:12,380
and Start can't run, because the guy actually holds a lock,

655
00:35:12,380 --> 00:35:14,420
but it can't actually unlock,

656
00:35:14,420 --> 00:35:15,800
because it can't write to apply channel,

657
00:35:15,800 --> 00:35:16,940
because there's no reader,

658
00:35:17,090 --> 00:35:19,880
you know there's easy to construct scenarios,

659
00:35:19,880 --> 00:35:20,990
where you can get into deadlocks,

660
00:35:20,990 --> 00:35:22,700
of course you can avoid all these deadlocks,

661
00:35:22,760 --> 00:35:23,690
that's the whole goal,

662
00:35:23,690 --> 00:35:25,550
and one way to avoid these deadlocks is,

663
00:35:25,550 --> 00:35:28,100
actually not to hold the lock while read writing on the channel,

664
00:35:31,260 --> 00:35:32,490
there are other ways of doing it too,

665
00:35:34,370 --> 00:35:36,500
I just tell you in my implementation,

666
00:35:36,590 --> 00:35:37,850
you know I find a convenient,

667
00:35:37,850 --> 00:35:40,790
not to have to hold locks, while writing on a channel,

668
00:35:41,380 --> 00:35:42,940
I think in general it's bad practice.

669
00:35:50,270 --> 00:35:53,480
Okay, back to code.

670
00:35:56,450 --> 00:35:59,900
Okay, good, so I'm gonna show you one particular implementation,

671
00:35:59,900 --> 00:36:04,190
again, you know this is an implementation that I wrote over January

672
00:36:04,190 --> 00:36:05,120
to get ready for the class,

673
00:36:05,120 --> 00:36:07,160
so there's nothing particularly special about it,

674
00:36:07,280 --> 00:36:09,470
you know purely for myself,

675
00:36:09,860 --> 00:36:12,140
and I'm sure you know there are things about it,

676
00:36:12,140 --> 00:36:14,240
that you were to [violently object] to,

677
00:36:14,510 --> 00:36:16,880
but it gives you a sense you know what I did.

678
00:36:17,500 --> 00:36:19,420
And so here I go,

679
00:36:19,450 --> 00:36:20,950
so there's the Raft structure,

680
00:36:21,070 --> 00:36:23,440
I basically you know copy figure 2,

681
00:36:23,590 --> 00:36:24,580
as you will see,

682
00:36:24,580 --> 00:36:25,060
in the code,

683
00:36:25,060 --> 00:36:27,280
that's going to be a lot of figure 2 in the code,

684
00:36:27,790 --> 00:36:30,760
and you know here's the main thing you make,

685
00:36:30,760 --> 00:36:31,930
probably the main thing to point out,

686
00:36:31,930 --> 00:36:33,310
there's like, here's the Mutex

687
00:36:33,310 --> 00:36:34,420
and here's the Raft lock,

688
00:36:34,420 --> 00:36:37,570
that and my code will acquire release all over the place,

689
00:36:37,600 --> 00:36:39,160
but in a very coarse-grained manner,

690
00:36:39,910 --> 00:36:40,570
and the rest is

691
00:36:40,570 --> 00:36:42,580
just you know exactly as you expect,

692
00:36:42,580 --> 00:36:46,570
you know the Persistent state, Volatile state, Leader state and Snapshot state,

693
00:36:46,600 --> 00:36:48,220
I won't talk much about snapshot at all,

694
00:36:48,220 --> 00:36:50,320
since you know that what we do for Friday.

695
00:36:51,560 --> 00:36:54,590
That's basically it,

696
00:36:54,590 --> 00:36:58,010
then, interesting, I'm just gonna go bottom-up,

697
00:36:58,010 --> 00:37:00,050
sort of like in the beginning, you know what happens,

698
00:37:00,050 --> 00:37:02,330
so at some point, the tester,

699
00:37:11,450 --> 00:37:17,020
the tester will call Make, right,

700
00:37:17,020 --> 00:37:22,450
and here's my basically the Make call,

701
00:37:22,690 --> 00:37:26,170
it constructs you know the Raft states,

702
00:37:26,560 --> 00:37:29,950
you know apply channel, the condition variable that I mentioned,

703
00:37:30,430 --> 00:37:34,420
it sets itself to a follower, it's election time out,

704
00:37:34,920 --> 00:37:36,990
and I'll talk about that in a second,

705
00:37:37,050 --> 00:37:40,020
you know initially some other parts you make an empty log,

706
00:37:40,560 --> 00:37:45,090
and, then basically forks have two goroutine,

707
00:37:45,150 --> 00:37:48,930
one is the applier, that's the thread that actually writes on the apply channel,

708
00:37:49,140 --> 00:37:50,940
and then I got my the ticker

709
00:37:50,940 --> 00:37:55,830
and we basically gave you to basically runs the ticker code,

710
00:37:57,460 --> 00:38:00,940
so, nothing particularly exciting going on here.

711
00:38:01,300 --> 00:38:04,810
So let's look at the ticker code,

712
00:38:04,960 --> 00:38:06,310
some people ask you know,

713
00:38:06,310 --> 00:38:10,720
should you structure everything in a single file, multiple files,

714
00:38:10,990 --> 00:38:12,010
of course, it's all up to you,

715
00:38:12,010 --> 00:38:13,780
what actually is most convenient for you

716
00:38:13,780 --> 00:38:15,280
to actually you know find your code,

717
00:38:15,280 --> 00:38:17,620
in this case, I structed in multiple files,

718
00:38:17,620 --> 00:38:22,570
and have basically vote.go, deals with all the election part.

719
00:38:25,070 --> 00:38:26,330
So let's look at the ticker,

720
00:38:29,560 --> 00:38:32,470
so the ticker basically runs every 50 milliseconds,

721
00:38:32,590 --> 00:38:35,620
and it calls this function tick,

722
00:38:35,620 --> 00:38:37,420
function tick like right up here,

723
00:38:37,690 --> 00:38:38,770
it grips,

724
00:38:38,770 --> 00:38:40,930
you know you'll see that all over the place,

725
00:38:40,930 --> 00:38:42,940
it grasps the Raft lock,

726
00:38:43,300 --> 00:38:47,860
calls use defer to make sure that no matter when I leave the function,

727
00:38:48,130 --> 00:38:50,140
the lock actually will be released,

728
00:38:50,590 --> 00:38:53,920
and then you know check what is the leader,

729
00:38:53,920 --> 00:38:56,320
if the leader, does one thing,

730
00:38:56,320 --> 00:38:58,420
it's not a leader, that means that's a follower,

731
00:38:58,480 --> 00:39:03,470
then just check whether actually the election time has passed,

732
00:39:03,860 --> 00:39:05,990
and so basically the way I compute that is,

733
00:39:05,990 --> 00:39:07,400
I get the current time,

734
00:39:07,670 --> 00:39:11,630
and see if the current time is actually passed the,

735
00:39:11,660 --> 00:39:15,620
if now, is now past the election time,

736
00:39:17,430 --> 00:39:19,650
and if that's the case, I'll start the election,

737
00:39:19,680 --> 00:39:24,060
and, well first I'll set the election timeout again,

738
00:39:24,060 --> 00:39:25,770
as required by figure 2,

739
00:39:26,130 --> 00:39:27,780
and then you know start the election,

740
00:39:30,120 --> 00:39:31,830
in terms of setting the election timeouts,

741
00:39:31,830 --> 00:39:35,460
like the the first thing you know the way I do it,

742
00:39:35,460 --> 00:39:37,980
you know an election timeout is set to one second,

743
00:39:38,010 --> 00:39:40,290
which is sort of I got from,

744
00:39:40,980 --> 00:39:42,480
I can hold on a second [],

745
00:39:42,510 --> 00:39:45,600
there's a good reason from the chat,

746
00:39:45,690 --> 00:39:51,340
the the the selection timeouts one second,

747
00:39:51,340 --> 00:39:52,990
and then of course you know you need to

748
00:39:52,990 --> 00:39:56,290
randomize you know the peers across an interval,

749
00:39:56,620 --> 00:39:59,530
and I use an interval from 0 to 300 milliseconds,

750
00:39:59,830 --> 00:40:02,860
and add that to the election timeouts,

751
00:40:02,860 --> 00:40:07,780
and so basically every peer likely has to have a slightly different election timeout,

752
00:40:08,140 --> 00:40:12,820
and so, they will call, take at different stages,

753
00:40:12,820 --> 00:40:14,680
and you know we had a bit of [],

754
00:40:14,770 --> 00:40:17,710
only one or few actually will start the election.

755
00:40:19,180 --> 00:40:19,990
I have a question.

756
00:40:19,990 --> 00:40:20,380
Yeah.

757
00:40:20,590 --> 00:40:26,110
So, you're only like checking every like 50 milliseconds, right,

758
00:40:26,110 --> 00:40:28,630
doesn't that lead to a contested elections,

759
00:40:29,360 --> 00:40:30,950
like because you're essentially,

760
00:40:31,220 --> 00:40:32,840
it doesn't this limit,

761
00:40:33,140 --> 00:40:38,800
like you know you technically can get for anywhere

762
00:40:38,800 --> 00:40:42,340
from 3 to 0 to 300 right, like.

763
00:40:42,920 --> 00:40:45,590
No, I can get from one second to after 300,

764
00:40:45,650 --> 00:40:47,060
and one second to,

765
00:40:47,210 --> 00:40:51,050
any value between 1000 milliseconds to 1300 milliseconds.

766
00:40:51,230 --> 00:40:54,320
Right, so, but at the end of the day,

767
00:40:54,320 --> 00:40:58,040
like because you're like only checking every 50 milliseconds,

768
00:40:58,040 --> 00:40:59,390
doesn't that just give it like.

769
00:40:59,950 --> 00:41:02,050
It gives us more coarse-grained, but it's good enough.

770
00:41:02,580 --> 00:41:03,180
Okay.

771
00:41:03,660 --> 00:41:06,360
I mean basically two constraints here, correct,

772
00:41:06,360 --> 00:41:08,220
you know you don't want to be too slow,

773
00:41:08,790 --> 00:41:10,890
and because that means that,

774
00:41:10,890 --> 00:41:13,410
you're takes a long time before you start a new election,

775
00:41:13,410 --> 00:41:15,090
and you don't want to be too fast,

776
00:41:15,090 --> 00:41:17,550
because then you start too many elections,

777
00:41:17,550 --> 00:41:19,290
and you need to allow for some time

778
00:41:19,290 --> 00:41:22,890
for an election to lose some, some votes may get delayed,

779
00:41:23,220 --> 00:41:26,820
and you don't want to restart before you you have,

780
00:41:27,090 --> 00:41:29,160
just before the candidate has chance to

781
00:41:29,160 --> 00:41:32,220
sort of do a couple rounds of communication with the followers.

782
00:41:34,810 --> 00:41:38,410
Okay, so some of your people speculating about my capital L,

783
00:41:38,710 --> 00:41:40,600
this was just an experiment,

784
00:41:40,660 --> 00:41:42,610
you know for this implementation,

785
00:41:42,610 --> 00:41:44,020
I followed the convention

786
00:41:44,020 --> 00:41:45,430
and I probably broke it in some places,

787
00:41:45,430 --> 00:41:46,840
but I followed the convention that,

788
00:41:47,290 --> 00:41:53,350
if the caller, the callee assumes that the lock is held,

789
00:41:53,530 --> 00:41:56,290
then I put a capital L behind the function,

790
00:41:56,920 --> 00:42:01,000
so startElection, that assumes that the caller actually is required the lock,

791
00:42:01,030 --> 00:42:03,370
and basically any function that [] with an L,

792
00:42:03,430 --> 00:42:05,680
as that particular you know assumes that convention,

793
00:42:07,660 --> 00:42:11,470
and so this is purely a coding prevention for myself,

794
00:42:11,470 --> 00:42:14,560
and I thought it was sort of interesting to try it out in this implementation,

795
00:42:15,010 --> 00:42:16,180
might not always do that,

796
00:42:16,180 --> 00:42:17,770
but I just did that in this one.

797
00:42:20,720 --> 00:42:21,500
Any questions?

798
00:42:22,500 --> 00:42:24,510
Or should we look at the election part.

799
00:42:28,510 --> 00:42:31,510
Okay, well, let's look at the election part,

800
00:42:31,510 --> 00:42:34,690
and you'll see here startElection,

801
00:42:34,690 --> 00:42:36,550
so it doesn't require a lock,

802
00:42:36,550 --> 00:42:39,670
because I assume the caller holds it,

803
00:42:40,060 --> 00:42:42,070
and basically just follows figure 2,

804
00:42:42,160 --> 00:42:44,320
you know first, you know the rule is

805
00:42:44,320 --> 00:42:47,020
you have to increment the currentTerm by 1,

806
00:42:47,020 --> 00:42:47,770
so I do that,

807
00:42:47,770 --> 00:42:49,510
I set the state to Candidate,

808
00:42:49,510 --> 00:42:52,450
and also dictated by figure 2 basically,

809
00:42:52,750 --> 00:42:55,600
I record votedFor myself,

810
00:42:55,600 --> 00:42:57,220
this is also part of figure 2,

811
00:42:57,520 --> 00:43:00,370
and then you know this is for lab C,

812
00:43:00,370 --> 00:43:02,080
you know to C, you already know,

813
00:43:02,170 --> 00:43:05,590
that whenever you change basically state, that should to be persistent,

814
00:43:05,800 --> 00:43:07,450
you have to persistent right after,

815
00:43:07,720 --> 00:43:09,770
and so, so that's it,

816
00:43:09,800 --> 00:43:12,440
and basically you're you see my debugging messages,

817
00:43:12,530 --> 00:43:14,870
like you know from Jose says,

818
00:43:14,870 --> 00:43:16,880
you know I always have the source at the beginning,

819
00:43:16,880 --> 00:43:18,770
and this simplifies my life,

820
00:43:19,160 --> 00:43:20,600
and I have a bunch of other sort of,

821
00:43:20,900 --> 00:43:24,350
I don't have a Perl script or Python script nicely as Jose,

822
00:43:24,350 --> 00:43:26,180
but I have a bunch of Unix scripts,

823
00:43:26,180 --> 00:43:29,540
that I used to parse the log, print and process,

824
00:43:31,090 --> 00:43:34,210
and then we call requestVotesL

825
00:43:34,240 --> 00:43:35,980
and requestVotesL right up here,

826
00:43:36,430 --> 00:43:39,970
and you'll see in a second, you know how this is going to work out,

827
00:43:39,970 --> 00:43:44,230
but basically it as Cel said,

828
00:43:44,230 --> 00:43:48,550
you know we construct the arguments once you know [up front]

829
00:43:48,550 --> 00:43:52,720
and let me, so let's look at the RequestVoteArgs arguments,

830
00:43:52,990 --> 00:43:55,990
and basically you know your data here,

831
00:43:55,990 --> 00:44:01,820
and you know basically it contains exactly you know what basically figure 2 says,

832
00:44:01,820 --> 00:44:05,930
that contain the Term, CandidateId, the LastLogIndex and the LastLogTerm,

833
00:44:06,410 --> 00:44:10,490
and [] and one thing, maybe worth pointing out is,

834
00:44:10,490 --> 00:44:13,130
I do try to write the String functions,

835
00:44:13,520 --> 00:44:17,150
that allow Go you know when you're typing %v,

836
00:44:17,150 --> 00:44:19,280
you know we'll call that String function on this struct,

837
00:44:19,580 --> 00:44:24,680
and so that allows you to format you know the the structure,

838
00:44:24,680 --> 00:44:26,810
the request in a nice way,

839
00:44:26,810 --> 00:44:30,470
and again that helps with me, that helps me processing my log,

840
00:44:30,810 --> 00:44:34,740
and so basically every request argument that I have,

841
00:44:34,740 --> 00:44:36,840
I print in one standard way,

842
00:44:36,840 --> 00:44:39,180
and again to simplify loc processing.

843
00:44:45,730 --> 00:44:49,390
Okay, back to starting election,

844
00:44:49,390 --> 00:44:52,840
so multiple followers start at the same time,

845
00:44:52,840 --> 00:44:56,080
you know they become, one of them is hopefully it starts first,

846
00:44:56,080 --> 00:44:57,220
it becomes candidate,

847
00:44:57,580 --> 00:44:58,960
and it does requestVotesL,

848
00:44:58,960 --> 00:45:01,510
and here the struct you know the arguments,

849
00:45:01,780 --> 00:45:04,720
put the currentTerm in here, was going to be 1,

850
00:45:04,720 --> 00:45:06,310
if this is the first time for the election,

851
00:45:06,310 --> 00:45:07,390
you know who I am,

852
00:45:07,600 --> 00:45:14,020
and log.lastindex you know presumably is 0 or 1 whatever,

853
00:45:14,550 --> 00:45:16,500
yeah, it's gonna be 0, I guess,

854
00:45:16,800 --> 00:45:22,680
and then the Term in that entry which is term 0,

855
00:45:23,310 --> 00:45:25,410
because you know what we're doing, correct,

856
00:45:25,410 --> 00:45:26,820
we're running an election for one,

857
00:45:26,820 --> 00:45:30,360
and we need to show what the previous one were.

858
00:45:32,990 --> 00:45:33,860
Okay.

859
00:45:34,400 --> 00:45:35,390
So then here,

860
00:45:35,390 --> 00:45:38,420
this is my standard way of sending RPCs,

861
00:45:38,630 --> 00:45:40,880
just go through all the peers,

862
00:45:40,880 --> 00:45:43,040
skipping myself, of course,

863
00:45:43,040 --> 00:45:44,750
I have to count that I voted for myself,

864
00:45:44,750 --> 00:45:46,190
so I set the number of votes to 1,

865
00:45:46,490 --> 00:45:50,750
and then I basically fork off a a thread,

866
00:45:50,750 --> 00:45:55,040
that basically is gonna do actually the sending the RPC to each individual peer,

867
00:45:55,630 --> 00:45:58,540
the first argument is the peer to which the RPC sent,

868
00:45:58,540 --> 00:46:00,070
they all get the same arguments,

869
00:46:00,250 --> 00:46:02,320
and also passing the address of the votes,

870
00:46:02,320 --> 00:46:05,020
you know, so they can have a shared vote count.

871
00:46:07,870 --> 00:46:09,100
Any questions about this?

872
00:46:10,080 --> 00:46:14,070
So for requestVote, the the lock is being held,

873
00:46:14,070 --> 00:46:15,720
and then you're sending the.

874
00:46:16,020 --> 00:46:16,740
Yeah, so.

875
00:46:16,740 --> 00:46:17,520
RPC.

876
00:46:17,730 --> 00:46:19,800
Yeah, so, in a requestVote here,

877
00:46:19,800 --> 00:46:23,190
is the lock actually held inside of this function?

878
00:46:24,840 --> 00:46:26,970
No, right, because it's a new thread.

879
00:46:27,030 --> 00:46:28,740
Yeah, new thread, it doesn't hold a lock,

880
00:46:28,800 --> 00:46:30,870
and you see my naming convention hinted that,

881
00:46:30,870 --> 00:46:32,160
because it doesn't have an L there.

882
00:46:35,580 --> 00:46:36,150
Okay.

883
00:46:36,600 --> 00:46:38,070
So really requestVote

884
00:46:38,070 --> 00:46:40,860
and the requestVote when actually it starts running,

885
00:46:40,860 --> 00:46:42,090
it has no locks,

886
00:46:42,090 --> 00:46:44,820
because only the parent held the lock

887
00:46:44,820 --> 00:46:47,460
and this guy, this thread actually hasn't required the lock yet,

888
00:46:47,610 --> 00:46:49,080
it does not have lock.

889
00:46:51,150 --> 00:46:56,760
So, so basically one thread runs for each of these requestVote for each peer,

890
00:46:56,910 --> 00:46:59,550
it allocates a reply structure,

891
00:46:59,550 --> 00:47:02,220
and then basically it sends off you know the RPC,

892
00:47:02,250 --> 00:47:04,440
and this is all done without holding the lock,

893
00:47:04,920 --> 00:47:07,230
and then, at some point we get a response back,

894
00:47:07,620 --> 00:47:10,230
and then at that point, in response handler,

895
00:47:10,230 --> 00:47:11,910
I grab the log right at the beginning

896
00:47:12,060 --> 00:47:15,240
and do whatever response handling that is necessary.

897
00:47:17,260 --> 00:47:18,940
Yeah, go ahead.

898
00:47:18,940 --> 00:47:20,680
Alright, you said earlier,

899
00:47:20,680 --> 00:47:22,180
that you shouldn't hold a lock,

900
00:47:22,180 --> 00:47:25,720
when you're doing like you're doing RPC call,

901
00:47:25,720 --> 00:47:27,940
you mean like basically it's okay to,

902
00:47:28,270 --> 00:47:30,250
it's okay for the RPC call itself,

903
00:47:30,250 --> 00:47:32,680
in the RPC called to do, to hold a lock,

904
00:47:32,680 --> 00:47:34,090
but not like while you're calling.

905
00:47:34,090 --> 00:47:35,710
Yeah, not a cross this,

906
00:47:35,710 --> 00:47:38,890
when are you sending, a cross sending it over the network.

907
00:47:39,220 --> 00:47:41,740
But it's okay, if you're doing it within RPC.

908
00:47:41,830 --> 00:47:43,000
Or even the reply handler,

909
00:47:43,000 --> 00:47:46,030
like think about this as ways the reply handler running,

910
00:47:46,270 --> 00:47:47,470
so the response came back,

911
00:47:47,740 --> 00:47:50,470
and now there's a reply, you have to process the reply.

912
00:47:51,950 --> 00:47:54,350
Oh, I'm talking about like say in the RequestVote,

913
00:47:54,350 --> 00:47:58,310
but like the capital R request, capital V vote,

914
00:47:58,640 --> 00:48:01,640
that's okay to hold locks, in there at least, right.

915
00:48:02,220 --> 00:48:04,140
Where you want to hold locks, I'm actually.

916
00:48:04,140 --> 00:48:07,710
Like, so like capital RequestVote here,

917
00:48:08,100 --> 00:48:09,870
yeah, that's what I'm talking about.

918
00:48:10,440 --> 00:48:11,070
This one?

919
00:48:11,620 --> 00:48:13,150
No, like the function here,

920
00:48:14,080 --> 00:48:15,640
so it's RequestVote,

921
00:48:15,640 --> 00:48:19,690
but it's I think it's capital R, yeah,

922
00:48:21,890 --> 00:48:24,740
like you probably have a method, right,

923
00:48:24,740 --> 00:48:26,660
it's the RPC call.

924
00:48:26,660 --> 00:48:28,640
I think the RPC on the receiver side.

925
00:48:28,730 --> 00:48:32,570
Yeah yeah yeah, we'll look at the second of course,

926
00:48:32,570 --> 00:48:35,510
that was on a completely new way to think about it,

927
00:48:35,510 --> 00:48:36,620
totally different machine,

928
00:48:36,620 --> 00:48:39,450
yeah yeah yeah, absolutely.

929
00:48:39,450 --> 00:48:42,000
So, so basically these two places of while hold the lock,

930
00:48:42,000 --> 00:48:45,870
like in the handler, in the request handler and in the reply handler.

931
00:48:48,640 --> 00:48:49,420
Okay, thank you.

932
00:48:50,420 --> 00:48:52,130
Sorry, sorry for being confused,

933
00:48:52,550 --> 00:48:54,290
I'm glad we clarified that.

934
00:48:54,680 --> 00:48:57,140
Okay, so grab the lock,

935
00:48:57,140 --> 00:48:59,300
then put a print statement in the log,

936
00:48:59,300 --> 00:49:01,220
so I can know what later on I can study it,

937
00:49:01,640 --> 00:49:03,650
and then of course the basic checks,

938
00:49:03,650 --> 00:49:08,510
you know that you know actually figure 2 doesn't really saying much about it,

939
00:49:08,510 --> 00:49:14,360
but you know this is the rule that applies to all servers, correct,

940
00:49:14,360 --> 00:49:18,520
the term is bigger than the reply.Term,

941
00:49:18,520 --> 00:49:19,810
than the currentTerm,

942
00:49:19,870 --> 00:49:23,290
then you gotta switch to the follower state,

943
00:49:23,290 --> 00:49:28,120
and to the term of the [] that responded to you,

944
00:49:28,150 --> 00:49:29,440
so look at that in a second.

945
00:49:30,340 --> 00:49:33,640
So that basically you know, if this this was the candidate,

946
00:49:33,940 --> 00:49:36,610
and I was talking to appear that actually works in the higher term

947
00:49:36,730 --> 00:49:39,820
and basically backs off and becomes a follower.

948
00:49:43,310 --> 00:49:47,550
Okay, so, if the follower responded saying,

949
00:49:47,550 --> 00:49:48,930
I'm grant my vote,

950
00:49:49,050 --> 00:49:53,130
then I increment the number of votes, the share votes by 1,

951
00:49:53,130 --> 00:49:54,810
it is totally safe to do, correct,

952
00:49:54,810 --> 00:49:56,850
because I'm holding the Raft lock,

953
00:49:57,180 --> 00:49:58,470
and so this is a serialized,

954
00:49:58,470 --> 00:50:01,590
so multiple things that will happen, correct,

955
00:50:01,590 --> 00:50:03,240
multiple responses will come back,

956
00:50:03,420 --> 00:50:04,890
they may run in parallel,

957
00:50:05,010 --> 00:50:06,270
but they will be serialized,

958
00:50:06,270 --> 00:50:07,290
because of the Raft lock,

959
00:50:09,390 --> 00:50:10,710
so add up the votes,

960
00:50:10,740 --> 00:50:13,110
if the vote is longer than the,

961
00:50:13,170 --> 00:50:15,660
you know if I have a majority of the votes,

962
00:50:15,660 --> 00:50:20,970
then if I'm still in the same term as the start,

963
00:50:20,970 --> 00:50:23,760
when I started out actually running the election,

964
00:50:23,880 --> 00:50:25,470
then I'm going to become the leader,

965
00:50:25,650 --> 00:50:28,620
and I'll send out you know the first round of heartbeats,

966
00:50:28,620 --> 00:50:29,910
which all look in a second.

967
00:50:31,820 --> 00:50:33,560
Yeah, so I want to look at two things,

968
00:50:33,590 --> 00:50:35,180
let's see what becomeLeaderL is,

969
00:50:35,180 --> 00:50:37,100
becomeLeaderL is right up here,

970
00:50:37,490 --> 00:50:39,290
you know as capital L,

971
00:50:39,290 --> 00:50:41,510
because it's you know already holds a lock,

972
00:50:41,510 --> 00:50:43,910
basically sets the state to the leader state,

973
00:50:44,390 --> 00:50:47,630
and initialize is the nextIndex,

974
00:50:48,050 --> 00:50:51,080
and the nextIndex said the last lecture is basically guess,

975
00:50:51,080 --> 00:50:52,280
and it's an optimistic guess,

976
00:50:52,340 --> 00:50:56,150
you know I just said to whatever my lastindex plus 1,

977
00:50:56,740 --> 00:50:59,710
so basically assuming that all the followers are up to date,

978
00:51:00,500 --> 00:51:01,220
and if they're not,

979
00:51:01,220 --> 00:51:03,020
you know we'll see later they will back off,

980
00:51:04,120 --> 00:51:08,900
will back off on the append entry, sort of reply.

981
00:51:10,740 --> 00:51:11,730
Okay, good,

982
00:51:12,300 --> 00:51:13,560
so that has become leader,

983
00:51:13,590 --> 00:51:15,720
let me look at newTermL,

984
00:51:17,550 --> 00:51:20,580
so newTermL, nothing really you know too exciting

985
00:51:20,580 --> 00:51:24,060
and basically says I can go to the next term,

986
00:51:24,060 --> 00:51:26,640
that is supplied by the caller,

987
00:51:26,940 --> 00:51:28,800
I set votedFor to -1,

988
00:51:28,800 --> 00:51:30,660
because I haven't voted yet in this term,

989
00:51:30,660 --> 00:51:33,240
and I changed to a my state to follower,

990
00:51:33,330 --> 00:51:35,910
because this is kind of state that needs to be persisted,

991
00:51:35,910 --> 00:51:36,810
I call persist.

992
00:51:41,480 --> 00:51:43,790
Okay, so this is sort of the candidate side,

993
00:51:44,000 --> 00:51:48,470
and now we want to look at follower side,

994
00:51:49,080 --> 00:51:53,640
or perhaps another candidate, that's also running election in parallel.

995
00:51:55,170 --> 00:51:58,500
So, so here's the RequestVote handler,

996
00:51:58,530 --> 00:51:59,580
this is running,

997
00:51:59,580 --> 00:52:02,010
so this is the piece of code that runs on the other machine,

998
00:52:02,010 --> 00:52:03,000
if you will, correct,

999
00:52:03,000 --> 00:52:08,010
were where I was confused about a little bit in answering that question,

1000
00:52:08,670 --> 00:52:10,890
and you know you succeeded the first thing it does,

1001
00:52:11,370 --> 00:52:14,220
is vote by the RPC library system, correct,

1002
00:52:14,220 --> 00:52:15,120
with its own thread,

1003
00:52:15,120 --> 00:52:15,900
and the first thing it does,

1004
00:52:15,900 --> 00:52:18,990
it actually graps the lock on the Raft structure,

1005
00:52:20,420 --> 00:52:25,240
and then basically this follows literally the rules figure 2,

1006
00:52:25,270 --> 00:52:27,520
you know there's the rule for all servers, correct,

1007
00:52:27,520 --> 00:52:32,630
if the term, the args.Term argument is higher than my currentTerm,

1008
00:52:32,630 --> 00:52:35,180
then I should switch you know to this newTermL,

1009
00:52:35,180 --> 00:52:37,280
and that's it,

1010
00:52:37,940 --> 00:52:42,410
then here, sort of the you know the interesting piece, correct,

1011
00:52:42,410 --> 00:52:44,570
this is all related to figure [],

1012
00:52:44,570 --> 00:52:47,300
what it means to be were [] figure 7,

1013
00:52:47,600 --> 00:52:49,940
what it means to be up to date,

1014
00:52:49,940 --> 00:52:52,610
you can only become a leader, if you're up to date,

1015
00:52:53,040 --> 00:52:56,400
so I compute you know the uptodate function,

1016
00:52:56,400 --> 00:53:02,400
in and that's basically based on the last index or in the term in the last index,

1017
00:53:03,000 --> 00:53:04,560
and so it says uptodate is,

1018
00:53:04,620 --> 00:53:09,180
if my the term in the argument is equal to myTerm,

1019
00:53:09,450 --> 00:53:15,220
and the the call, the call the candidate

1020
00:53:15,250 --> 00:53:18,370
as a LastLogIndex that just equal or higher to myIndex,

1021
00:53:18,370 --> 00:53:21,370
so basically the term to equal the longest log should win,

1022
00:53:21,940 --> 00:53:27,670
and or if you know the candidater in higher than term period,

1023
00:53:27,670 --> 00:53:29,950
then it always wins, the candidate wins.

1024
00:53:31,110 --> 00:53:32,550
So that means it to be up to date,

1025
00:53:32,550 --> 00:53:33,720
so compute uptodate,

1026
00:53:33,720 --> 00:53:35,880
and then basically go through different cases,

1027
00:53:35,880 --> 00:53:37,950
if the term is smaller than the currentTerm,

1028
00:53:38,160 --> 00:53:41,580
that means that the caller is behind,

1029
00:53:41,670 --> 00:53:43,860
and so VoteGranted to false,

1030
00:53:43,860 --> 00:53:44,880
and then in the other case,

1031
00:53:44,880 --> 00:53:45,900
if I hadn't voted,

1032
00:53:46,400 --> 00:53:49,820
or I voted you know already voted for this candidate,

1033
00:53:50,240 --> 00:53:53,480
and you know the candidate is uptodate,

1034
00:53:53,540 --> 00:53:55,370
then I grant my vote,

1035
00:53:55,400 --> 00:53:59,630
and and reset the election timeout,

1036
00:54:01,010 --> 00:54:04,580
so why, why is this the second case here,

1037
00:54:04,610 --> 00:54:07,370
the or are votedFor equals args.CandidateId.

1038
00:54:13,340 --> 00:54:20,100
Because the, the candidate may resend, maybe their RPC was delayed.

1039
00:54:20,490 --> 00:54:22,200
Yeah, delayed or actually never made it, right.

1040
00:54:23,580 --> 00:54:26,880
And so, you know just basically checking,

1041
00:54:27,460 --> 00:54:30,280
so this allows me to vote twice for the same candidate,

1042
00:54:30,610 --> 00:54:32,500
but I can't vote for any other candidate.

1043
00:54:33,440 --> 00:54:34,070
Okay?

1044
00:54:34,370 --> 00:54:36,650
So just to double check the logic here,

1045
00:54:36,800 --> 00:54:40,130
so if we have the candidate has a term,

1046
00:54:40,340 --> 00:54:41,840
that is bigger than the currentTerm,

1047
00:54:42,140 --> 00:54:44,600
we obviously have to convert the follower,

1048
00:54:44,600 --> 00:54:46,730
and update the term to the term of the candidate,

1049
00:54:47,030 --> 00:54:50,240
but we don't automatically grant them vote,

1050
00:54:50,270 --> 00:54:53,870
unless their log is at least as up to date.

1051
00:54:54,640 --> 00:54:56,020
Yeah, exactly.

1052
00:54:56,350 --> 00:54:57,040
Awesome, thank you.

1053
00:54:58,470 --> 00:55:03,210
I'm also wondering is votedFor every reset to -1?

1054
00:55:03,570 --> 00:55:06,060
Yeah, when we go to newTermL, always,

1055
00:55:06,790 --> 00:55:08,770
it's new said always to,

1056
00:55:08,800 --> 00:55:10,300
whenever you go to the newTermL.

1057
00:55:10,510 --> 00:55:11,140
Okay.

1058
00:55:11,500 --> 00:55:14,050
I set to -1, is one place where this happens.

1059
00:55:17,220 --> 00:55:18,060
Any questions?

1060
00:55:24,930 --> 00:55:27,660
So this gives you probably a reasonable good sense about the overall structure,

1061
00:55:27,660 --> 00:55:30,570
and this is what everything else follows roughly the same structure.

1062
00:55:31,080 --> 00:55:34,980
And so let's go back and go here,

1063
00:55:34,980 --> 00:55:35,850
so let's you know,

1064
00:55:35,850 --> 00:55:39,480
let's assume that guy actually the leader or the candidate wins the election.

1065
00:55:40,460 --> 00:55:42,320
So it startElectionL,

1066
00:55:42,350 --> 00:55:44,150
let me go trace back,

1067
00:55:44,420 --> 00:55:45,890
so we startElectionL,

1068
00:55:46,400 --> 00:55:48,050
we requestVotesL

1069
00:55:48,350 --> 00:55:51,950
and we won the election,

1070
00:55:52,460 --> 00:55:54,020
and we became the leader,

1071
00:55:54,020 --> 00:55:57,080
and then the first thing that figure 2 tells you to do is,

1072
00:55:57,080 --> 00:56:00,470
like send heartbeats to every peer,

1073
00:56:02,540 --> 00:56:07,040
and so basically this is going to be the standard code for sendAppendsL,

1074
00:56:07,750 --> 00:56:13,180
in fact you know the heartbeat code is identical to the sendAppendsL code,

1075
00:56:13,180 --> 00:56:16,870
except you know the heartbeat often will may have no entry

1076
00:56:16,870 --> 00:56:19,990
or no entry in the log that is being sent to the followers.

1077
00:56:23,280 --> 00:56:26,850
Okay, so sendAppendsL follows the same structure as sendVotesL,

1078
00:56:27,090 --> 00:56:30,660
you know go cycle overall peers,

1079
00:56:30,660 --> 00:56:32,220
and if peers not equal to me,

1080
00:56:32,220 --> 00:56:34,020
then basically sendAppendL.

1081
00:56:36,200 --> 00:56:40,400
Yeah, and so here's to sendAppendL,

1082
00:56:42,940 --> 00:56:46,660
and you know basically we're keeping track, correct,

1083
00:56:46,660 --> 00:56:49,630
what did the next a log entry,

1084
00:56:49,630 --> 00:56:51,610
that the peer should have,

1085
00:56:51,610 --> 00:56:54,910
we initialize it to an optimistic guess in equal to ours,

1086
00:56:55,270 --> 00:56:56,350
so basically in this case,

1087
00:56:56,350 --> 00:56:59,260
there's gonna be no log entries, there's going to be sent,

1088
00:56:59,800 --> 00:57:02,110
so I can skip all this stuff for now,

1089
00:57:02,140 --> 00:57:02,950
we'll come back to it,

1090
00:57:02,950 --> 00:57:05,500
when we're looking actually at Start,

1091
00:57:05,680 --> 00:57:08,440
I fill in the AppendEntriesArgs,

1092
00:57:09,000 --> 00:57:12,240
and we can look at the structure,

1093
00:57:12,240 --> 00:57:12,810
you would like to,

1094
00:57:12,810 --> 00:57:14,820
but you know it is exactly as in figure 2,

1095
00:57:14,820 --> 00:57:18,900
may be the only thing that'll be careful,

1096
00:57:18,900 --> 00:57:20,610
you've got to be a little careful about is,

1097
00:57:20,880 --> 00:57:26,280
allocated slice you know to hold the entries that need to be sent,

1098
00:57:26,610 --> 00:57:29,100
in this particular case, number of entries zero,

1099
00:57:29,130 --> 00:57:31,860
were because we're assuming that everybody's up to date,

1100
00:57:32,190 --> 00:57:39,390
and then copy you know the part from the slices from the log in the Raft structure

1101
00:57:39,390 --> 00:57:43,640
to the, to the entries in the arguments,

1102
00:57:44,480 --> 00:57:49,490
and so I have really my own copy at this point of the log,

1103
00:57:49,730 --> 00:57:51,650
there's a little bit of danger, correct,

1104
00:57:51,650 --> 00:57:53,000
like slice share memory,

1105
00:57:53,030 --> 00:57:55,610
so this is why the copy needs to happen,

1106
00:57:56,490 --> 00:57:59,310
so I copied entries out of the Raft structure,

1107
00:57:59,310 --> 00:58:03,330
that I hold the log on into my private argument structure,

1108
00:58:04,620 --> 00:58:06,840
and, once that is done,

1109
00:58:06,840 --> 00:58:12,390
basically I sent you know started Go function, Go goroutine for every peer,

1110
00:58:12,480 --> 00:58:14,340
and in that Go function,

1111
00:58:14,340 --> 00:58:18,720
in that and in that function, I sent the RPC,

1112
00:58:19,170 --> 00:58:20,520
and then in the reply handler,

1113
00:58:20,520 --> 00:58:21,690
I grab the lock,

1114
00:58:21,690 --> 00:58:23,730
just reply handler of RPC,

1115
00:58:23,730 --> 00:58:25,500
grab the lock and then process the reply,

1116
00:58:25,990 --> 00:58:26,950
the append reply.

1117
00:58:30,640 --> 00:58:31,600
Does this all make sense?

1118
00:58:34,550 --> 00:58:39,410
Yeah, go ahead, maybe one by one.

1119
00:58:39,410 --> 00:58:41,990
One little question, yeah, so in sendAppendL,

1120
00:58:42,540 --> 00:58:43,950
we have, we have the loop

1121
00:58:43,950 --> 00:58:46,740
in which we call rf.sendAppendL,

1122
00:58:47,410 --> 00:58:51,190
and we assume the lock is held through that call,

1123
00:58:51,250 --> 00:58:53,780
but we do there you know any thread,

1124
00:58:53,900 --> 00:58:57,530
at which point, the thread actually go to the lock, right?

1125
00:58:58,770 --> 00:59:00,750
Okay, so like there's an outer loop, correct,

1126
00:59:00,750 --> 00:59:02,670
where somebody to caller holds the lock,

1127
00:59:02,700 --> 00:59:06,030
and basically it calls sendAppendL you know n times,

1128
00:59:06,030 --> 00:59:07,860
where n is the number of peers minus 1,

1129
00:59:08,680 --> 00:59:10,360
and for every one of them,

1130
00:59:10,660 --> 00:59:12,550
for every iteration of the loop,

1131
00:59:12,640 --> 00:59:14,950
we're going to create a new Go function,

1132
00:59:15,160 --> 00:59:18,190
that Go function runs without holding the locks, right,

1133
00:59:18,490 --> 00:59:21,220
so it will send its RPC without holding locks,

1134
00:59:21,220 --> 00:59:24,190
and at the same time, the new Go function might be started by the caller,

1135
00:59:24,490 --> 00:59:27,400
that actually also is going to send RPC,

1136
00:59:27,820 --> 00:59:30,880
although they're sent RPCs in parallel to the followers,

1137
00:59:31,120 --> 00:59:32,410
the followers respond,

1138
00:59:32,870 --> 00:59:34,610
and all the responses come back in,

1139
00:59:34,910 --> 00:59:37,250
that will, so that will return,

1140
00:59:37,280 --> 00:59:38,900
when the follower response comes in,

1141
00:59:38,900 --> 00:59:40,640
that returns from send RPC,

1142
00:59:40,640 --> 00:59:43,670
and at that point, grab the lock to process to reply,

1143
00:59:44,490 --> 00:59:51,390
now, if the caller still busy sending RPCs to the followers,

1144
00:59:51,540 --> 00:59:54,330
then basically you know the reply handler will block

1145
00:59:54,660 --> 00:59:58,740
until the caller is done, sending all the RPCs.

1146
01:00:00,430 --> 01:00:02,950
Yeah, so, my question was,

1147
01:00:03,070 --> 01:00:05,860
I I assumed why that happens is,

1148
01:00:05,860 --> 01:00:10,340
because you had a, we had a defer rf.Lock, the Unlock,

1149
01:00:10,370 --> 01:00:12,560
is that's why it doesn't hold the lock,

1150
01:00:12,560 --> 01:00:14,120
when it starts a thread, right,

1151
01:00:15,880 --> 01:00:16,630
or is that just.

1152
01:00:17,900 --> 01:00:18,890
When you start a thread,

1153
01:00:18,890 --> 01:00:20,300
you don't hold any locks.

1154
01:00:21,100 --> 01:00:23,080
Yeah, like whatever it is,

1155
01:00:23,110 --> 01:00:25,540
even if we don't have like that,

1156
01:00:25,630 --> 01:00:28,750
like even if we tried to hold the lock right before the Go code,

1157
01:00:29,140 --> 01:00:29,980
it wouldn't hold it.

1158
01:00:30,860 --> 01:00:33,200
That's right, yeah yeah.

1159
01:00:33,320 --> 01:00:33,950
Yeah.

1160
01:00:34,850 --> 01:00:36,140
I will sort of follow,

1161
01:00:36,170 --> 01:00:39,920
so in the, if ok block,

1162
01:00:40,130 --> 01:00:43,280
where's the defer being like called from,

1163
01:00:43,490 --> 01:00:45,860
from the return statement of that method.

1164
01:00:46,430 --> 01:00:48,710
When this block exits, when this block exits,

1165
01:00:48,710 --> 01:00:51,230
then the defer mu.Unlock will be called.

1166
01:00:53,020 --> 01:00:58,120
So defer, defer is called when the surrounding basic block exits.

1167
01:00:58,860 --> 01:01:00,540
Oh, not just return statements.

1168
01:01:00,780 --> 01:01:02,490
Not just return statements, that's correct.

1169
01:01:02,490 --> 01:01:03,090
Okay, cool.

1170
01:01:05,170 --> 01:01:06,670
That's cool, it's very handy.

1171
01:01:07,060 --> 01:01:07,990
Can you repeat that,

1172
01:01:07,990 --> 01:01:09,190
so what does the defer exits?

1173
01:01:09,640 --> 01:01:16,870
Defer called, like when this defer or this unlock runs when this basic block exits

1174
01:01:17,020 --> 01:01:19,840
or returns or goes out whatever [] went around,

1175
01:01:19,840 --> 01:01:21,460
so if you return from this basic block,

1176
01:01:21,760 --> 01:01:23,050
this unlock will happen.

1177
01:01:24,060 --> 01:01:24,690
That's awesome.

1178
01:01:27,160 --> 01:01:30,100
Sorry, why, you need to check,

1179
01:01:30,100 --> 01:01:34,240
if the currentTerm is still the term that you thought you were in,

1180
01:01:34,450 --> 01:01:37,240
because some requests can be slow,

1181
01:01:37,510 --> 01:01:41,110
and you might receive a response after a long time.

1182
01:01:41,260 --> 01:01:41,920
Yep.

1183
01:01:42,100 --> 01:01:42,670
Okay.

1184
01:01:42,850 --> 01:01:45,430
So here's all let's look at processAppendReply,

1185
01:01:45,430 --> 01:01:47,260
I think that's what you're asking what does it do,

1186
01:01:48,210 --> 01:01:49,890
and we have looked at it yet,

1187
01:01:49,890 --> 01:01:50,880
so we can look at it,

1188
01:01:52,250 --> 01:01:55,580
actually reasonable complicated,

1189
01:01:56,790 --> 01:01:59,160
it follows you know the general rule for all servers,

1190
01:01:59,160 --> 01:02:01,470
you have the reply.Term bigger than currentTerm,

1191
01:02:01,470 --> 01:02:04,140
then you know I got switched to becoming a follower,

1192
01:02:04,200 --> 01:02:06,120
and you know going to newTermL,

1193
01:02:06,300 --> 01:02:08,160
if it is actually equal to my term, correct,

1194
01:02:08,160 --> 01:02:09,390
this is what you are asking,

1195
01:02:09,780 --> 01:02:13,290
like if the reply comes in the same term,

1196
01:02:13,290 --> 01:02:15,330
that I sent in my args.Term,

1197
01:02:15,330 --> 01:02:19,200
then I'm gonna do a have a different function,

1198
01:02:19,200 --> 01:02:21,300
that actually does all the processing,

1199
01:02:21,330 --> 01:02:24,210
assuming that at least the terms are matching.

1200
01:02:25,360 --> 01:02:27,250
Oh, sorry, I meant in the leader,

1201
01:02:27,250 --> 01:02:29,140
when receives a response you have,

1202
01:02:29,830 --> 01:02:31,210
it had like a check.

1203
01:02:31,210 --> 01:02:33,940
Yeah, yeah, basically happening here too,

1204
01:02:33,970 --> 01:02:35,320
it's like the same check here.

1205
01:02:36,820 --> 01:02:37,480
I see, okay.

1206
01:02:39,950 --> 01:02:49,010
Okay, so you know basically this is then the append entries, reply code,

1207
01:02:49,040 --> 01:02:52,310
like what the handler that runs in response to the reply,

1208
01:02:52,460 --> 01:02:58,100
we know that the term matches and we check reply success,

1209
01:02:58,100 --> 01:02:59,240
if reply success,

1210
01:02:59,240 --> 01:03:06,380
you know we update our matchIndex and nextIndex,

1211
01:03:07,020 --> 01:03:09,720
follow exactly the rules of figure 2,

1212
01:03:10,400 --> 01:03:12,170
if there's a ConflictValid,

1213
01:03:12,170 --> 01:03:16,130
you know then you know I process the conflict

1214
01:03:16,130 --> 01:03:19,520
and so this is the piece of code is going to deal with like backing off fast,

1215
01:03:21,590 --> 01:03:27,020
and, and if there's no conflict information available,

1216
01:03:27,020 --> 01:03:28,340
then I just back off by one.

1217
01:03:30,490 --> 01:03:31,210
Okay?

1218
01:03:31,450 --> 01:03:34,720
Is it a question about how we back off by one,

1219
01:03:35,560 --> 01:03:38,850
is it not problem that,

1220
01:03:38,910 --> 01:03:40,050
I was thinking about this,

1221
01:03:40,050 --> 01:03:41,550
and I I think it wasn't true,

1222
01:03:41,550 --> 01:03:43,830
but I haven't fully convinced myself,

1223
01:03:43,860 --> 01:03:48,930
but isn't it possible that rf.nextIndex peer changed,

1224
01:03:48,960 --> 01:03:51,080
between when we sent it,

1225
01:03:51,080 --> 01:03:53,810
and when we're processing this response,

1226
01:03:53,810 --> 01:03:55,400
you're problematic,

1227
01:03:55,460 --> 01:03:59,300
the document kind of using a value that's potentially changed.

1228
01:03:59,510 --> 01:04:01,010
Probably not, correct,

1229
01:04:01,010 --> 01:04:04,490
because you think your risk your concern is valid,

1230
01:04:04,790 --> 01:04:08,300
because certainly you know the Raft structure might have completely changed,

1231
01:04:08,300 --> 01:04:09,710
by the time this response comes in.

1232
01:04:10,360 --> 01:04:16,030
In fact, you know although unlikely of course,

1233
01:04:16,030 --> 01:04:18,340
because the response to the same peer, right.

1234
01:04:23,460 --> 01:04:24,630
And so there's you know,

1235
01:04:24,630 --> 01:04:27,930
but I might have multiple RPC outstanding to that particular peer,

1236
01:04:28,170 --> 01:04:31,050
and so those reply handlers here might run in some order.

1237
01:04:33,920 --> 01:04:35,090
So I have a question,

1238
01:04:35,090 --> 01:04:37,820
so why do we decrement the nextIndex by 1,

1239
01:04:37,820 --> 01:04:38,810
if there's no conflict.

1240
01:04:43,160 --> 01:04:44,630
I think this has to do that,

1241
01:04:44,630 --> 01:04:45,410
maybe at some point,

1242
01:04:45,410 --> 01:04:48,950
I haven't implemented conflict or the conflict term stuff yet,

1243
01:04:50,620 --> 01:04:53,950
I don't remember whether this actually is essential or not.

1244
01:04:54,550 --> 01:04:55,540
Okay, thank you.

1245
01:04:55,850 --> 01:04:59,390
You know, of course like you I've changed my code multiple times,

1246
01:04:59,390 --> 01:05:04,310
and you know as I go along implementing the response of the test,

1247
01:05:07,390 --> 01:05:09,100
I don't think there's harm in it,

1248
01:05:09,690 --> 01:05:11,460
the only downside could be that,

1249
01:05:11,460 --> 01:05:15,210
I may send too many entries on RPC,

1250
01:05:15,210 --> 01:05:17,610
or send more entries in the RPC I really have to,

1251
01:05:18,560 --> 01:05:19,580
on the next append.

1252
01:05:24,430 --> 01:05:25,450
Okay, any questions?

1253
01:05:28,100 --> 01:05:31,700
Good, let me talk a little bit about the commit,

1254
01:05:32,180 --> 01:05:33,530
so you might have learned, correct,

1255
01:05:33,530 --> 01:05:39,500
that the follower actually has, has committed some entries,

1256
01:05:39,590 --> 01:05:41,000
that we didn't know before,

1257
01:05:41,000 --> 01:05:42,680
and the matchIndex is updated,

1258
01:05:42,770 --> 01:05:48,320
and so, so basically I always check after processing reply,

1259
01:05:48,320 --> 01:05:50,960
whether I should advance you know the commit point,

1260
01:05:52,570 --> 01:05:55,480
and this is basically the,

1261
01:05:55,540 --> 01:06:00,160
you know the this code corresponds to the last [] of the leaders in figure 2,

1262
01:06:00,610 --> 01:06:06,070
so and literally implement what actually is supposed to be happening there.

1263
01:06:06,780 --> 01:06:12,210
Probably the only thing that's sort of interesting in here is this particular point,

1264
01:06:13,450 --> 01:06:17,310
and this has to do with figure 8, right,

1265
01:06:17,310 --> 01:06:19,470
the scenario is that you're a leader,

1266
01:06:19,650 --> 01:06:21,990
is not allowed to commit a previous term

1267
01:06:22,170 --> 01:06:26,490
unless at least has committed one entry in its currentTerm,

1268
01:06:27,020 --> 01:06:32,090
and so this is exactly that one check that described section 5.4,

1269
01:06:32,090 --> 01:06:34,880
it checks whether the current log.entry,

1270
01:06:34,940 --> 01:06:39,710
that won't about to be in the entry about to commit,

1271
01:06:39,890 --> 01:06:42,590
whether that actually has a term is different than the currentTerm,

1272
01:06:42,590 --> 01:06:44,210
and if that's the case, I'll just skip it.

1273
01:06:45,110 --> 01:06:48,890
Now happens if there's another log entry following that term,

1274
01:06:49,280 --> 01:06:52,910
in my term for which I have a majority of the votes,

1275
01:06:53,030 --> 01:06:56,540
then I'll basically commit that newer one,

1276
01:06:56,630 --> 01:06:59,660
and then automatically allows to commit the previous one.

1277
01:07:03,600 --> 01:07:06,870
So that's that figure 8 problem,

1278
01:07:07,140 --> 01:07:09,510
and then a signalApplierL,

1279
01:07:09,510 --> 01:07:13,800
and the applier you know may run,

1280
01:07:13,830 --> 01:07:15,240
if there's actually a,

1281
01:07:15,480 --> 01:07:18,420
let's look at the applier thread,

1282
01:07:19,590 --> 01:07:21,300
here's the applier thread,

1283
01:07:22,040 --> 01:07:24,020
signalApplierL for it to wake it up,

1284
01:07:24,020 --> 01:07:27,470
when maybe advance the commit point,

1285
01:07:28,040 --> 01:07:29,780
it has a lastApplied,

1286
01:07:30,020 --> 01:07:33,260
first grasp a lock, lastApplied,

1287
01:07:33,720 --> 01:07:36,240
and then you know basically go through here,

1288
01:07:36,510 --> 01:07:40,680
and does a check you know that's the rule for all servers,

1289
01:07:40,680 --> 01:07:42,240
you know when you commit something,

1290
01:07:42,720 --> 01:07:44,310
and it just follows that rule,

1291
01:07:44,310 --> 01:07:46,470
and then basically write something to the apply channel,

1292
01:07:46,470 --> 01:07:47,460
and as you can see here,

1293
01:07:47,460 --> 01:07:49,650
I unlock before writing to the apply channel,

1294
01:07:50,340 --> 01:07:58,110
and then, if there's nothing anymore to, nothing more to supply

1295
01:07:58,110 --> 01:07:59,670
and this on the apply channel,

1296
01:07:59,670 --> 01:08:01,740
I just do a Wait on the condition variable.

1297
01:08:04,720 --> 01:08:06,820
And again, you know different ways of writing this,

1298
01:08:06,850 --> 01:08:08,800
but this is the way I happened to do it.

1299
01:08:10,000 --> 01:08:12,520
So why are you using a broadcast?

1300
01:08:13,060 --> 01:08:15,670
Oh, why, instead of signal, yeah, no no good reason.

1301
01:08:16,400 --> 01:08:20,270
Okay.

1302
01:08:20,360 --> 01:08:23,090
You know broadcast signal in this case do exactly the same thing.

1303
01:08:25,570 --> 01:08:26,200
For the applier?

1304
01:08:26,200 --> 01:08:27,400
Yeah.

1305
01:08:27,610 --> 01:08:31,180
So I using a condition variable,

1306
01:08:31,180 --> 01:08:34,570
and it seems like like probably natural to do that,

1307
01:08:34,780 --> 01:08:36,970
is there any disadvantage to doing it,

1308
01:08:37,000 --> 01:08:40,990
on on like on sleeping, like sleeping for a time interval,

1309
01:08:40,990 --> 01:08:44,140
then like you know watching everything together.

1310
01:08:44,760 --> 01:08:50,970
I I I dislike code with random sleeps in them,

1311
01:08:51,540 --> 01:08:53,880
I think it was generally a bad style of writing code,

1312
01:08:54,750 --> 01:08:57,300
and so I don't do that.

1313
01:08:58,160 --> 01:08:58,640
Yeah.

1314
01:08:58,670 --> 01:09:00,920
The only place where I do sleep is in the ticker,

1315
01:09:01,440 --> 01:09:01,950
that's it,

1316
01:09:02,100 --> 01:09:03,990
that's the way place where you have to do,

1317
01:09:04,050 --> 01:09:05,760
so otherwise I just never do that.

1318
01:09:06,060 --> 01:09:10,770
Actually, that's is there any advantage to doing it with a ticker?

1319
01:09:12,780 --> 01:09:13,320
Sorry?

1320
01:09:13,620 --> 01:09:19,200
Is there any advantage of checking and updating like alongside with the ticker,

1321
01:09:19,230 --> 01:09:19,860
like you have.

1322
01:09:19,860 --> 01:09:24,480
You could do that, I I find it harder to reason about,

1323
01:09:24,540 --> 01:09:27,840
I I'd like to you know if one thread we [] this one thing

1324
01:09:27,840 --> 01:09:29,340
and then the ticker thread in one thing,

1325
01:09:29,730 --> 01:09:33,540
you know I think there are people that basically do everything in a ticker thread,

1326
01:09:34,400 --> 01:09:37,670
and you know one of you know for me it's hard to reason about,

1327
01:09:38,240 --> 01:09:42,730
but that's more a question of personal taste than anything.

1328
01:09:49,130 --> 01:09:49,850
Okay?

1329
01:09:54,350 --> 01:09:55,550
Any further questions?

1330
01:10:00,190 --> 01:10:04,270
Okay, I want to quickly look then at Start,

1331
01:10:04,270 --> 01:10:06,700
because basically there's nothing really left to discuss anymore,

1332
01:10:06,700 --> 01:10:08,110
we talk basically about voting,

1333
01:10:08,110 --> 01:10:09,190
we talked about appending,

1334
01:10:09,640 --> 01:10:13,330
haven't really discussed exactly what happens on the follower side,

1335
01:10:13,330 --> 01:10:16,300
when it gets in appending request,

1336
01:10:16,510 --> 01:10:19,180
but basically follows figure 2,

1337
01:10:19,180 --> 01:10:21,040
if we have time left and we can look at that too.

1338
01:10:21,720 --> 01:10:24,210
Here's the Start command,

1339
01:10:24,880 --> 01:10:30,190
so this is like the service calls this to append an entry to the log

1340
01:10:30,520 --> 01:10:33,130
and you know immediately grabs the lock,

1341
01:10:33,340 --> 01:10:35,950
check whether we're still the leader,

1342
01:10:35,950 --> 01:10:37,450
if not we return false,

1343
01:10:37,480 --> 01:10:39,610
otherwise we create an entry,

1344
01:10:39,910 --> 01:10:41,470
and we append it to the log,

1345
01:10:41,800 --> 01:10:45,070
and log has to be persistent, so were persistent,

1346
01:10:45,340 --> 01:10:46,810
and then we sendAppendsL,

1347
01:10:46,810 --> 01:10:48,610
and this is exactly the same,

1348
01:10:48,610 --> 01:10:51,550
or sendAppendsL exactly the same code as the heartbeats

1349
01:10:51,880 --> 01:10:56,470
and except in the, unlike in the heartbeats,

1350
01:10:56,740 --> 01:10:59,350
you know most likely now it's going to actually send the entry,

1351
01:10:59,470 --> 01:11:02,530
that is, that just has been appended to the log.

1352
01:11:05,240 --> 01:11:05,780
Okay?

1353
01:11:07,990 --> 01:11:09,820
You noticed,

1354
01:11:09,820 --> 01:11:14,920
you know that probably many places have this log.lastindex or log that something,

1355
01:11:14,920 --> 01:11:20,440
and that's because I sort of abstracted the log away into its own structure.

1356
01:11:21,260 --> 01:11:26,540
Here's the log actually as just a log of entries, slice of entries

1357
01:11:26,870 --> 01:11:28,850
and the index0,

1358
01:11:28,850 --> 01:11:31,160
and this is really for part 2D,

1359
01:11:31,460 --> 01:11:34,850
where basically you're gonna cut up the beginning of the log,

1360
01:11:34,880 --> 01:11:36,260
this global log,

1361
01:11:36,680 --> 01:11:38,810
and you need to keep track of what the index,

1362
01:11:38,810 --> 01:11:41,570
you need to keep track of what the indexes of the first entry

1363
01:11:41,570 --> 01:11:43,550
actually you have recorded in your log.

1364
01:11:44,500 --> 01:11:47,110
And you know to hide most of those details away,

1365
01:11:47,110 --> 01:11:52,150
you know basically have an abstracted way in this file log.go

1366
01:11:52,420 --> 01:11:54,640
and they're basically functions for appending,

1367
01:11:54,640 --> 01:11:56,110
you know to get the start of the log,

1368
01:11:56,110 --> 01:11:58,330
to cutend, to go cutstart,

1369
01:11:58,930 --> 01:12:00,070
to get the slice out of it,

1370
01:12:00,070 --> 01:12:01,270
to get the lastindex,

1371
01:12:01,270 --> 01:12:03,580
you know get the particular entry or get the lastentry,

1372
01:12:05,020 --> 01:12:07,780
and that might be convenient for 2D,

1373
01:12:07,780 --> 01:12:09,610
although there's many other ways of doing it.

1374
01:12:16,370 --> 01:12:20,120
Okay, let me go back for a second to some of the questions that people ask.

1375
01:12:20,750 --> 01:12:24,500
So, I think hopefully I've answered many of them by now,

1376
01:12:24,740 --> 01:12:31,280
but if not, let me just review quickly go through them,

1377
01:12:31,790 --> 01:12:35,090
so I think we talked quite extensively about the election timeout,

1378
01:12:35,330 --> 01:12:36,500
you know how to compute it,

1379
01:12:36,800 --> 01:12:38,600
how to check with the timeout is passed.

1380
01:12:40,830 --> 01:12:47,290
There a question about always when receiving a message from leader,

1381
01:12:47,320 --> 01:12:50,350
you know I only reset when I receive a message from the leader,

1382
01:12:50,350 --> 01:12:51,940
that actually using my currentTerm,

1383
01:12:53,010 --> 01:12:54,570
or in my newTerm,

1384
01:12:54,570 --> 01:12:56,610
if I become a follower,

1385
01:12:56,820 --> 01:12:59,730
not [] somebody that's behind in terms of terms.

1386
01:13:00,290 --> 01:13:02,510
When to send AppendEntries,

1387
01:13:02,600 --> 01:13:03,980
you know the different ways of doing it,

1388
01:13:03,980 --> 01:13:05,540
you can do it only in the heartbeats,

1389
01:13:05,540 --> 01:13:07,850
you know some people have done that,

1390
01:13:07,850 --> 01:13:10,130
you can do, so never send anything in Start,

1391
01:13:10,160 --> 01:13:13,730
that's like I showed me I showed in the code,

1392
01:13:13,730 --> 01:13:16,550
or sometimes you people do, also do it in the response,

1393
01:13:16,610 --> 01:13:19,760
if for example the followers behind,

1394
01:13:19,790 --> 01:13:23,210
you know send immediately, the remaining entries,

1395
01:13:23,540 --> 01:13:24,950
I don't do that,

1396
01:13:24,950 --> 01:13:26,870
I never send anything in response,

1397
01:13:26,870 --> 01:13:28,520
although I had an implementation that does that,

1398
01:13:28,880 --> 01:13:30,140
the risk is that,

1399
01:13:30,140 --> 01:13:32,600
I think you [] the follower in later labs,

1400
01:13:32,600 --> 01:13:35,480
or in you know test for 2C 2D.

1401
01:13:37,760 --> 01:13:43,040
Do in only, some people I think just sent entries only in a heartbeat,

1402
01:13:43,040 --> 01:13:45,620
so that means every you know,

1403
01:13:45,620 --> 01:13:48,770
you're not allowed to send a heartbeat more than ten times a second,

1404
01:13:48,860 --> 01:13:52,160
in the rules of the game for the labs,

1405
01:13:52,550 --> 01:13:55,550
so that means that you go to sent append entries,

1406
01:13:55,550 --> 01:13:58,010
once every you know 100 milliseconds,

1407
01:13:58,010 --> 01:13:59,180
or maybe a little bit faster,

1408
01:13:59,630 --> 01:14:05,210
that maybe run into problems in lab 3,

1409
01:14:05,240 --> 01:14:09,080
where we actually see if you make fast enough progress,

1410
01:14:10,370 --> 01:14:12,980
so basically I do it in a heartbeat,

1411
01:14:12,980 --> 01:14:13,970
and I do it in Start.

1412
01:14:15,820 --> 01:14:17,740
We talked quite extensively about debugging,

1413
01:14:18,320 --> 01:14:20,570
talked a bunch about code organization,

1414
01:14:20,600 --> 01:14:22,790
I think we talked quite a bit about concurrency.

1415
01:14:23,340 --> 01:14:28,230
There's a number of questions about why 3/5/7 servers and never more,

1416
01:14:28,470 --> 01:14:30,510
I think this is the reason, that is the case,

1417
01:14:30,510 --> 01:14:33,780
because I think it reflects how raft is actually used in practice,

1418
01:14:33,780 --> 01:14:36,510
and really that 3/5/7 is based on

1419
01:14:36,510 --> 01:14:39,510
the computation of knowing what the meantime between failures are,

1420
01:14:40,090 --> 01:14:41,410
right, in the Raft paper,

1421
01:14:41,410 --> 01:14:45,280
it's assumed that any time could be failures are rough a couple months,

1422
01:14:45,550 --> 01:14:46,990
you run with 3 servers,

1423
01:14:47,230 --> 01:14:48,400
one goes down,

1424
01:14:48,430 --> 01:14:53,530
you know you have plenty of time to actually rebuilt you know third server

1425
01:14:53,530 --> 01:14:54,580
and get it back online,

1426
01:14:54,580 --> 01:14:55,960
and so get back to three,

1427
01:14:55,960 --> 01:14:57,970
before hopefully the next failure happens,

1428
01:14:59,740 --> 01:15:02,590
that's why you know this a small number of servers.

1429
01:15:08,650 --> 01:15:10,420
We talked a little bit about when to persist,

1430
01:15:10,510 --> 01:15:13,060
a number of good questions,

1431
01:15:13,060 --> 01:15:17,530
about like what happens if you crash while writing to stable storage,

1432
01:15:18,000 --> 01:15:21,810
and so you may write partial state and that would be a disaster,

1433
01:15:22,110 --> 01:15:23,670
and so typically what people do is,

1434
01:15:23,670 --> 01:15:26,010
actually to make sure that when they write to stable storage,

1435
01:15:26,010 --> 01:15:27,420
that is an atomic operation,

1436
01:15:28,260 --> 01:15:30,240
you know this does show up in the tester,

1437
01:15:30,240 --> 01:15:34,500
because the tester basically simulates persistent storage,

1438
01:15:34,500 --> 01:15:38,130
and then basically updates the persistent storage atomically,

1439
01:15:38,400 --> 01:15:40,800
within a real system that actually has a disk,

1440
01:15:40,980 --> 01:15:42,960
you might play a trick,

1441
01:15:42,990 --> 01:15:46,350
like the MapReduce library did where atomically rename,

1442
01:15:46,350 --> 01:15:47,910
you first write it in temporary file,

1443
01:15:47,910 --> 01:15:50,010
until everything is written and then atomic rename,

1444
01:15:50,440 --> 01:15:53,140
or use a log, write-ahead log system,

1445
01:15:53,940 --> 01:15:55,890
but yeah you have to,

1446
01:15:55,890 --> 01:15:57,360
that be a disaster,

1447
01:15:57,360 --> 01:16:03,300
if the crash persistent state to stable storage becomes inconsistent.

1448
01:16:05,120 --> 01:16:06,560
Okay, let me stop here,

1449
01:16:06,560 --> 01:16:09,170
so like there's maybe a little bit more time to ask questions

1450
01:16:09,170 --> 01:16:11,690
and of course I'll stay around as always,

1451
01:16:11,690 --> 01:16:13,700
and I can answer more questions,

1452
01:16:14,000 --> 01:16:17,570
I see there's also a ton of discussion in the chat,

1453
01:16:17,570 --> 01:16:22,700
I'm not I'm unfortunately not able probably I didn't keep up with all of it.

1454
01:16:27,030 --> 01:16:27,990
Okay, good.

1455
01:16:31,650 --> 01:16:33,180
Okay, so yeah any more questions?

1456
01:16:35,370 --> 01:16:37,740
I have a question about the log,

1457
01:16:38,940 --> 01:16:41,460
your your code for the log,

1458
01:16:42,160 --> 01:16:45,190
the index0, it is,

1459
01:16:46,060 --> 01:16:49,930
I guess in the underlying array,

1460
01:16:49,930 --> 01:16:53,260
what the start of the log is,

1461
01:16:53,740 --> 01:16:54,460
is that right?

1462
01:16:54,640 --> 01:16:56,650
So this is basically for lab 2D,

1463
01:16:57,240 --> 01:17:02,430
not for, you know in lab A B and C, index0 would be always 0,

1464
01:17:04,240 --> 01:17:06,310
in lab 2D where you take snapshots,

1465
01:17:06,310 --> 01:17:09,790
you know the index0 with no index number of the snapshot,

1466
01:17:12,070 --> 01:17:14,290
because you're gonna be cut the beginning of the log,

1467
01:17:15,480 --> 01:17:18,000
so if you take a snapshot index 10,

1468
01:17:18,000 --> 01:17:20,130
you're gonna cut 0 to 9

1469
01:17:20,310 --> 01:17:21,900
and index0 will be 10.

1470
01:17:23,250 --> 01:17:25,650
Oh, so this is this is the end of the snapshot,

1471
01:17:25,650 --> 01:17:26,460
I see, okay.

1472
01:17:30,540 --> 01:17:33,930
So basically everything to, to into index0

1473
01:17:33,930 --> 01:17:35,400
is actually included in the snapshot,

1474
01:17:35,400 --> 01:17:38,820
so there's no reason to maintain that state anymore in the log.

1475
01:17:45,860 --> 01:17:46,790
Any other questions?

1476
01:17:51,320 --> 01:17:52,940
I hope this was useful,

1477
01:17:52,970 --> 01:17:58,050
particularly still in time for you know 2C 2D,

1478
01:17:58,170 --> 01:17:59,610
maybe there's some ideas,

1479
01:17:59,610 --> 01:18:02,910
here that might be useful for you in implementing those labs.

1480
01:18:05,610 --> 01:18:09,090
I have a question about like,

1481
01:18:10,070 --> 01:18:13,130
what kind of ranges for election timeouts people used,

1482
01:18:15,380 --> 01:18:22,070
I think I used like you know the the lower the limit of 100 milliseconds for the heartbeats,

1483
01:18:22,070 --> 01:18:26,660
and then timeout anywhere between like 300 and 700 milliseconds.

1484
01:18:26,930 --> 01:18:27,200
Yeah.

1485
01:18:27,200 --> 01:18:28,430
I don't know, if that's.

1486
01:18:28,430 --> 01:18:31,730
Totally reasonable, I use a little bigger number, correct,

1487
01:18:31,730 --> 01:18:33,350
the [] we gave you is that,

1488
01:18:33,350 --> 01:18:37,190
you know you should be able to elect a leader in 5 seconds,

1489
01:18:37,620 --> 01:18:39,990
and that means you should count on,

1490
01:18:39,990 --> 01:18:42,180
and you may have to run the election a couple times,

1491
01:18:42,740 --> 01:18:45,500
and so you know the numbers your pick seems reasonable.

1492
01:18:51,320 --> 01:18:55,760
Any, any people that want to share a particular annoying bug that they had,

1493
01:18:55,790 --> 01:18:58,220
actually a number of questions where people are asking,

1494
01:18:58,220 --> 01:19:00,380
what is the most nasty bug that people have seen?

1495
01:19:11,180 --> 01:19:14,720
I have a pretty annoying bug in my implementation,

1496
01:19:15,980 --> 01:19:18,830
I didn't take my own advice

1497
01:19:18,830 --> 01:19:22,820
and sort of did like weird implementation of a timer,

1498
01:19:22,820 --> 01:19:26,970
where like spawn off new thread to sleep for something,

1499
01:19:26,970 --> 01:19:29,100
and then send a message back at the end,

1500
01:19:29,190 --> 01:19:31,410
it was not pretty great design,

1501
01:19:31,440 --> 01:19:32,850
and it had two different timers,

1502
01:19:32,850 --> 01:19:36,240
one for heartbeats and one for election timers,

1503
01:19:36,300 --> 01:19:40,770
and I was forgetting to stop the one of those timers,

1504
01:19:40,770 --> 01:19:42,150
when the server shutdown,

1505
01:19:42,180 --> 01:19:44,250
one of them was fine and one of them wasn't,

1506
01:19:44,370 --> 01:19:46,590
and it meant I would slowly gain,

1507
01:19:46,620 --> 01:19:50,100
like a number of goroutine over the course of a long running test

1508
01:19:50,340 --> 01:19:51,540
until it ran out,

1509
01:19:51,540 --> 01:19:53,370
and the race detector crashed everything,

1510
01:19:54,660 --> 01:19:56,310
and it was incredibly embarrassing,

1511
01:19:56,310 --> 01:20:00,030
because it was literally just that I forgot stop the timer,

1512
01:20:01,590 --> 01:20:04,760
so, but it took a very long time to debug,

1513
01:20:04,760 --> 01:20:06,260
because I couldn't figure out,

1514
01:20:06,350 --> 01:20:09,380
I thought there was a bug in the lab RPC code,

1515
01:20:09,380 --> 01:20:10,670
and no there wasn't,

1516
01:20:10,790 --> 01:20:14,120
no, there's probably no bugs in lab RPC code,

1517
01:20:14,120 --> 01:20:16,010
it was just me misinterpreting data.

1518
01:20:18,340 --> 01:20:20,080
Yep.

1519
01:20:20,580 --> 01:20:22,590
I'm talking about election timeouts,

1520
01:20:22,590 --> 01:20:29,950
I have a issue on where the one call is called from config.go

1521
01:20:30,340 --> 01:20:33,580
or that were occasionally failed to reach agreement,

1522
01:20:34,090 --> 01:20:35,290
I realized that,

1523
01:20:35,290 --> 01:20:39,910
if I increase my election timeouts to have the random interval

1524
01:20:39,910 --> 01:20:42,220
go up to 1500 milliseconds,

1525
01:20:42,760 --> 01:20:46,600
like greatly decreases the frequency at which this happens,

1526
01:20:46,600 --> 01:20:50,380
but I'm wondering if I should go even higher than that for the random interval,

1527
01:20:50,380 --> 01:20:54,040
that this is indicative of another bug I have.

1528
01:20:54,340 --> 01:20:54,940
I think it's indicative another bug you have,

1529
01:20:57,200 --> 01:20:58,550
my first guess I got,

1530
01:20:58,580 --> 01:21:00,830
to know of course I don't know for sure at all,

1531
01:21:00,920 --> 01:21:06,640
but you don't have to be able to run with that kind of long timers to pass.

1532
01:21:08,540 --> 01:21:12,830
Yeah, most of the time when people are tweaking their timeouts,

1533
01:21:12,830 --> 01:21:14,210
not actually fixing their bugs,

1534
01:21:14,210 --> 01:21:16,850
it's just changing how often they show up.

1535
01:21:19,300 --> 01:21:20,230
Okay, thanks.

1536
01:21:22,900 --> 01:21:24,520
Here's a bug in the channel,

1537
01:21:24,580 --> 01:21:26,350
when the channel was a bug I had,

1538
01:21:26,350 --> 01:21:28,090
was I forgot to initialize channel,

1539
01:21:29,780 --> 01:21:32,450
how did how did that manifest itself as a bug.

1540
01:21:34,110 --> 01:21:37,710
Oh, like basically when I was sending something,

1541
01:21:37,710 --> 01:21:40,140
it wouldn't able to receive it,

1542
01:21:41,330 --> 01:21:43,160
and I wondered what was going on,

1543
01:21:43,340 --> 01:21:46,010
it turns out it was just that I didn't ever initialize it,

1544
01:21:46,310 --> 01:21:48,320
feels like the not nil channel.

1545
01:21:53,010 --> 01:21:56,250
Because I don't really know what the semantics are overwriting to new channel,

1546
01:21:56,370 --> 01:21:58,080
I can't recall it top my head,

1547
01:21:58,080 --> 01:21:59,010
I know the rule for that,

1548
01:21:59,010 --> 01:22:00,420
but I don't remember what the rule is.

1549
01:22:01,640 --> 01:22:04,520
Do you have a comment on the previous point,

1550
01:22:05,350 --> 01:22:08,890
regard regarding the election timeout setting them high,

1551
01:22:08,950 --> 01:22:14,170
should we try and aim, thus to set them a little bit low,

1552
01:22:14,320 --> 01:22:17,260
so that if there are any bugs, we can expose them.

1553
01:22:18,270 --> 01:22:20,010
Yeah, not a bad plan,

1554
01:22:20,310 --> 01:22:22,020
I think it's always good to like,

1555
01:22:22,020 --> 01:22:23,340
you know push the boundaries

1556
01:22:23,340 --> 01:22:25,260
and see if you have any other bug [].

1557
01:22:28,170 --> 01:22:32,190
So the boundary should be something [akin] to what the paper suggests.

1558
01:22:32,220 --> 01:22:33,900
A little bit higher,

1559
01:22:33,900 --> 01:22:36,780
because the way we set up the tests are slightly different,

1560
01:22:36,840 --> 01:22:41,100
you know the [] of each has a discussion on this, right.

1561
01:22:42,360 --> 01:22:46,470
And actually the Raft paper can [] like guidelines,

1562
01:22:46,470 --> 01:22:48,510
and even if they have a specific value,

1563
01:22:48,510 --> 01:22:50,820
they set a value based on the guidelines,

1564
01:22:50,820 --> 01:22:51,780
and the guidelines said,

1565
01:22:51,780 --> 01:22:54,540
that you should have elected a leader

1566
01:22:54,570 --> 01:22:58,650
with an [order] of magnitude more time about what the heartbeat interval.

1567
01:22:58,980 --> 01:22:59,790
Exactly.

1568
01:22:59,790 --> 01:23:03,690
100 like if you do like 800 to a second,

1569
01:23:03,690 --> 01:23:05,130
like things will work out,

1570
01:23:05,840 --> 01:23:07,490
it's fine, if those are high,

1571
01:23:07,490 --> 01:23:09,470
because that's kind of the guidelines,

1572
01:23:09,470 --> 01:23:10,310
it all changes,

1573
01:23:10,310 --> 01:23:15,350
because we just made you change the kind of like the interval heartbeat frequency,

1574
01:23:15,350 --> 01:23:16,970
because of the RPC [].

1575
01:23:20,580 --> 01:23:25,740
Sorry, can actually see the heartbeat timer in the code?

1576
01:23:26,210 --> 01:23:27,050
Yeah, sure.

1577
01:23:35,090 --> 01:23:37,730
Basically, you know every 50 milliseconds,

1578
01:23:37,820 --> 01:23:39,500
the ticker goes off,

1579
01:23:40,410 --> 01:23:41,820
the ticker calls tick,

1580
01:23:41,880 --> 01:23:44,670
and if a leader obviously send an RPC,

1581
01:23:44,670 --> 01:23:46,770
just comes down to basically a heartbeat,

1582
01:23:49,570 --> 01:23:52,660
so here, my implementation every 50 milliseconds, sending a heartbeat.

1583
01:23:58,730 --> 01:23:59,750
I have a question,

1584
01:23:59,780 --> 01:24:02,570
I so, you were saying like,

1585
01:24:03,140 --> 01:24:06,640
like, it should be like timeout should be

1586
01:24:06,640 --> 01:24:11,440
an order of magnitude greater than heartbeats, right,

1587
01:24:12,250 --> 01:24:15,520
but I started playing to see how low it could get,

1588
01:24:16,090 --> 01:24:20,050
you know I I could like with 100 millisecond timeout,

1589
01:24:20,600 --> 01:24:25,610
you know it could go down to 3 to 500 milliseconds still work,

1590
01:24:25,640 --> 01:24:28,640
like you know without [],

1591
01:24:28,640 --> 01:24:32,250
and I was wondering like, it's like why,

1592
01:24:33,990 --> 01:24:37,380
like how how low you know how low can they get,

1593
01:24:38,150 --> 01:24:41,150
and why are we making them so much greater than the,

1594
01:24:41,870 --> 01:24:43,340
than the election timeout,

1595
01:24:43,550 --> 01:24:45,050
more than the heartbeat time.

1596
01:24:45,260 --> 01:24:51,020
Because we need to give the candidate shot actually becoming the leader,

1597
01:24:51,020 --> 01:24:56,830
and some of the messages might be delayed for a long time or dropped.

1598
01:25:00,200 --> 01:25:00,680
Okay?

1599
01:25:01,700 --> 01:25:02,300
I have a question,

1600
01:25:02,300 --> 01:25:03,590
I think I missed this part,

1601
01:25:03,590 --> 01:25:04,520
which is,

1602
01:25:05,060 --> 01:25:09,980
how you're like which append entries you're sending from Start

1603
01:25:09,980 --> 01:25:11,480
and which ones from the heartbeat.

1604
01:25:11,750 --> 01:25:13,490
Basically the same, it's the same code.

1605
01:25:14,870 --> 01:25:15,440
Okay.

1606
01:25:15,770 --> 01:25:18,380
Okay, there's nothing difference, I only have one,

1607
01:25:18,380 --> 01:25:19,340
if you look here,

1608
01:25:19,340 --> 01:25:21,230
this here sendAppendsL, right,

1609
01:25:21,260 --> 01:25:22,520
this is from the ticker.

1610
01:25:23,010 --> 01:25:23,790
Yeah.

1611
01:25:23,790 --> 01:25:26,400
And if you look at the API code,

1612
01:25:26,550 --> 01:25:29,070
Start function calls the same function,

1613
01:25:32,390 --> 01:25:34,460
but in this case, which which ones are,

1614
01:25:35,020 --> 01:25:36,820
like if you're sending all of them from Start,

1615
01:25:36,820 --> 01:25:39,010
which ones are going to be sent from the ticker.

1616
01:25:40,010 --> 01:25:44,360
The ticker probably says mostly empty appends.

1617
01:25:45,730 --> 01:25:48,970
Okay, so the both are coming from Start?

1618
01:25:49,580 --> 01:25:51,890
No, one is coming from the ticker.

1619
01:25:53,320 --> 01:25:55,090
Or like the actual log entries.

1620
01:25:56,010 --> 01:26:01,350
Oh, the oh the actual log entries are all sitting in struct Raft, right,

1621
01:26:01,350 --> 01:26:02,910
they are coming out of the Raft struct,

1622
01:26:04,660 --> 01:26:05,890
and if you look at Start,

1623
01:26:05,890 --> 01:26:07,180
the only thing Start does,

1624
01:26:08,180 --> 01:26:10,280
hold on, let me go pull up Start again,

1625
01:26:10,310 --> 01:26:11,390
because it's a good question,

1626
01:26:11,780 --> 01:26:12,980
okay, pull Start basically,

1627
01:26:12,980 --> 01:26:16,610
it appends to the log here, right,

1628
01:26:16,910 --> 01:26:18,560
and that's all does,

1629
01:26:18,590 --> 01:26:21,710
and like the only difference basically between the ticker and Start is,

1630
01:26:21,710 --> 01:26:23,570
that Start actually appends something to the log,

1631
01:26:23,570 --> 01:26:24,890
and the ticker doesn't do that,

1632
01:26:25,790 --> 01:26:29,300
and sendAppendsL basically grabs whatever,

1633
01:26:29,360 --> 01:26:32,300
so this is the loop for all of them,

1634
01:26:32,860 --> 01:26:34,420
so here's to the individual,

1635
01:26:35,080 --> 01:26:36,340
oops,

1636
01:26:40,220 --> 01:26:41,540
here's the individual one,

1637
01:26:41,540 --> 01:26:42,800
they sent to one peer,

1638
01:26:43,070 --> 01:26:49,490
and it basically grabs the right log entries out of the, out of log right here,

1639
01:26:50,380 --> 01:26:54,160
you're copy it out of the log into the args.Entries,

1640
01:26:54,900 --> 01:26:56,160
and so if it's a heartbeat,

1641
01:26:56,160 --> 01:26:58,710
most likely there's always be 0, not always, correct,

1642
01:26:58,710 --> 01:27:01,290
because you might be the leader, might be follower, might miss some,

1643
01:27:02,010 --> 01:27:04,830
but in the case when a Start calls this,

1644
01:27:04,830 --> 01:27:08,040
you always be sending the thing that actually just has been appended.

1645
01:27:09,720 --> 01:27:10,590
Okay, because,

1646
01:27:10,710 --> 01:27:14,340
I I did it that, such that I'm sending everything in the heartbeats,

1647
01:27:14,340 --> 01:27:15,570
like all the entries,

1648
01:27:16,420 --> 01:27:18,430
and for some of the two [],

1649
01:27:18,430 --> 01:27:20,470
sometimes I'll like fail to reach agreement

1650
01:27:20,470 --> 01:27:22,330
and I'm wondering if that's why,

1651
01:27:22,330 --> 01:27:24,070
because here it seems like,

1652
01:27:24,070 --> 01:27:26,350
the bulk of the entries are being sent in Start.

1653
01:27:26,350 --> 01:27:27,430
No, okay,

1654
01:27:27,430 --> 01:27:30,160
that might not be the reason why you,

1655
01:27:30,190 --> 01:27:33,070
I don't think it will affect reaching agreement,

1656
01:27:33,070 --> 01:27:36,640
is probably not a dependent on the number of entries you send in,

1657
01:27:37,320 --> 01:27:39,900
the number of log entries sending in append RPC.

1658
01:27:40,790 --> 01:27:41,360
No?

1659
01:27:42,540 --> 01:27:45,930
Yeah, I was able to make it all the way through lab 2,

1660
01:27:45,960 --> 01:27:50,400
with only ever sending append entries from the heartbeat timer.

1661
01:27:51,390 --> 01:27:56,520
Things down though.

1662
01:27:57,600 --> 01:27:58,950
To be clear, I don't recommend doing this,

1663
01:27:58,950 --> 01:28:01,590
but like, you can get through lab 2,

1664
01:28:01,590 --> 01:28:03,090
with just sending from the heartbeats,

1665
01:28:03,090 --> 01:28:09,690
so if you're not sure how long the timeout, then.

1666
01:28:09,720 --> 01:28:14,310
How do the limits on heartbeats work or the limit on heartbeats,

1667
01:28:14,610 --> 01:28:18,020
like the same as limit on append entries RPC

1668
01:28:18,020 --> 01:28:19,430
or are they counted differently.

1669
01:28:20,560 --> 01:28:23,110
The heartbeat is a bit different,

1670
01:28:23,140 --> 01:28:25,450
you know you can send, you know you have to send,

1671
01:28:25,600 --> 01:28:26,710
principle assume,

1672
01:28:26,710 --> 01:28:29,860
that every Start can result in an append entry call.

1673
01:28:30,320 --> 01:28:30,800
Right.

1674
01:28:31,040 --> 01:28:35,090
And and you're you're not allowed to send more than 10 heartbeats.

1675
01:28:35,740 --> 01:28:39,790
How, how do you, like differentiate that on the test?

1676
01:28:40,090 --> 01:28:42,790
Heartbeats have no entries, most typically.

1677
01:28:43,180 --> 01:28:47,280
Okay, so you literally go in and check like.

1678
01:28:47,310 --> 01:28:48,840
Oh, they don't really literally check,

1679
01:28:48,840 --> 01:28:52,440
but we basically see if you make more progress than 10 times a second,

1680
01:28:53,970 --> 01:28:55,680
like one of the test in lab 3,

1681
01:28:55,680 --> 01:28:57,030
checks if you go quick enough,

1682
01:29:02,700 --> 01:29:03,780
exactly for this reason,

1683
01:29:05,320 --> 01:29:06,220
maybe a little bit annoying,

1684
01:29:06,220 --> 01:29:07,570
but in a real application, correct,

1685
01:29:07,570 --> 01:29:11,110
if you delay you know your appends you know by 10 by 50 milliseconds,

1686
01:29:11,110 --> 01:29:12,010
before you do anything.

1687
01:29:13,050 --> 01:29:16,200
So if a client, you imagine a client meeting to your service,

1688
01:29:16,200 --> 01:29:17,070
you know basically it's going to

1689
01:29:17,070 --> 01:29:21,190
get one append operation through every 50 milliseconds,

1690
01:29:22,860 --> 01:29:25,020
that would be not a very desirable service to use.

1691
01:29:29,690 --> 01:29:30,920
I had a question,

1692
01:29:30,920 --> 01:29:37,850
about accessing parts of the rf struct without lock,

1693
01:29:38,120 --> 01:29:40,700
so in sendAppendEntries,

1694
01:29:41,180 --> 01:29:45,530
you're you're reading the peer, of peers.

1695
01:29:46,380 --> 01:29:47,130
Yep.

1696
01:29:47,970 --> 01:29:49,590
I guess slice,

1697
01:29:49,770 --> 01:29:52,560
but I know that it is it is static,

1698
01:29:52,890 --> 01:29:54,450
but there,

1699
01:29:54,540 --> 01:30:01,030
it could be that multiple threads read the same thing twice, right,

1700
01:30:01,210 --> 01:30:04,560
so is, is there a danger of

1701
01:30:04,560 --> 01:30:06,690
the race detector complaining about this.

1702
01:30:15,950 --> 01:30:18,410
So let me see,

1703
01:30:20,060 --> 01:30:24,350
so I guess I don't hold a lock on rf.peers, it's not the.

1704
01:30:25,580 --> 01:30:26,090
Yeah.

1705
01:30:27,020 --> 01:30:28,910
Yeah, maybe race, because there's not complaining,

1706
01:30:30,410 --> 01:30:32,630
because I always run this race detector.

1707
01:30:48,860 --> 01:30:53,330
Sorry, was that question about whether iterating over peers could cause races?

1708
01:30:53,900 --> 01:30:54,650
Yeah.

1709
01:30:54,800 --> 01:30:59,390
Right, because access it without holding the lock.

1710
01:30:59,720 --> 01:31:01,400
Right, there only [].

1711
01:31:04,170 --> 01:31:08,010
Nobody, right, you can't get the race detectors wrong complain.

1712
01:31:09,300 --> 01:31:10,890
What about rf.killed?

1713
01:31:13,370 --> 01:31:13,880
Sorry?

1714
01:31:14,420 --> 01:31:16,220
rf.killed.

1715
01:31:22,340 --> 01:31:24,950
Oh, I guess it was just an [] scenario,

1716
01:31:24,950 --> 01:31:27,920
if you kill it at the same time as doing something else,

1717
01:31:27,920 --> 01:31:28,790
I'm not sure.

1718
01:31:29,600 --> 01:31:32,270
Yeah it says not only modify,

1719
01:31:32,990 --> 01:31:35,690
killed still doesn't modify peers.

1720
01:31:43,130 --> 01:31:44,480
Yeah, okay, thank you.

1721
01:31:46,140 --> 01:31:48,840
Could I see how you do the apply channel thing again,

1722
01:31:48,840 --> 01:31:49,770
you talked about earlier,

1723
01:31:49,770 --> 01:31:52,260
how you needed to have a lock with the apply channel?

1724
01:31:53,090 --> 01:31:55,340
Not unlock, the opposite.

1725
01:31:55,640 --> 01:31:59,300
Oh, sorry, what is it condition variable?

1726
01:31:59,540 --> 01:32:00,890
Yeah, I have a condition variable, yeah.

1727
01:32:05,550 --> 01:32:09,090
So yeah okay, oh, what do you do with the condition variable though?

1728
01:32:09,090 --> 01:32:10,950
I brought a signal on it,

1729
01:32:11,400 --> 01:32:16,960
kind of like when, when the matchIndex is updated,

1730
01:32:16,960 --> 01:32:19,090
and a new entry needs to be committed

1731
01:32:19,120 --> 01:32:21,910
that thread will call signal,

1732
01:32:22,580 --> 01:32:26,000
and that will wake up the apply thread

1733
01:32:26,000 --> 01:32:27,080
and apply thread will see,

1734
01:32:27,080 --> 01:32:30,570
if there's anything that needs to be pushed on the apply channel,

1735
01:32:30,570 --> 01:32:31,890
which is the check here,

1736
01:32:31,920 --> 01:32:33,960
and if so, we will put it on the apply channel.

1737
01:32:34,890 --> 01:32:35,760
Oh, okay.

1738
01:32:36,720 --> 01:32:39,030
And if there's nothing to be pushed on your apply channel more,

1739
01:32:39,030 --> 01:32:39,960
it goes back to sleep.

1740
01:32:40,650 --> 01:32:41,100
Okay.

1741
01:32:48,450 --> 01:32:49,200
Okay.

1742
01:32:50,150 --> 01:32:52,760
Maybe this is it for today.

1743
01:32:59,000 --> 01:33:00,020
And who's left.

