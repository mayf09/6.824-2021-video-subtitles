1
00:00:00,300 --> 00:00:05,520
Okay, good afternoon, good morning, good evening, good night, wherever you are.

2
00:00:06,000 --> 00:00:08,820
Let's get started again.

3
00:00:08,820 --> 00:00:10,980
So, today we have a guest lecture,

4
00:00:11,670 --> 00:00:13,950
probably speaker needs a little introduction,

5
00:00:15,420 --> 00:00:20,640
Russ Cox, is one of the co-leads on the Go project,

6
00:00:20,640 --> 00:00:22,440
and we'll talk a lot more about it.

7
00:00:22,710 --> 00:00:25,140
Let me say a couple words,

8
00:00:26,220 --> 00:00:28,320
not trying to embarrass Russ too much,

9
00:00:28,350 --> 00:00:31,860
Russ has a long experience with distributed systems,

10
00:00:32,670 --> 00:00:37,500
he was a developer and contributor to Plan 9,

11
00:00:37,500 --> 00:00:40,320
when he was a high school student undergrad at Harvard,

12
00:00:41,040 --> 00:00:43,770
he joined the PHD program at MIT,

13
00:00:44,910 --> 00:00:45,960
which where we met up,

14
00:00:46,410 --> 00:00:50,880
and probably if you've taken any sort of PDOS class, if you will,

15
00:00:51,060 --> 00:00:52,680
there's gonna be,

16
00:00:52,710 --> 00:00:55,170
you will see Russ's touches on it,

17
00:00:55,800 --> 00:00:57,870
and certainly in 6.824,

18
00:00:57,900 --> 00:01:03,390
you know the Go, switch to Go for us has been a wonderful thing,

19
00:01:03,390 --> 00:01:07,170
and but if you differ in opinion,

20
00:01:07,230 --> 00:01:11,160
of course feel free to ask Russ questions and make suggestions,

21
00:01:11,160 --> 00:01:15,940
he's always welcome to entertain any ideas.

22
00:01:15,970 --> 00:01:17,800
So with that, Russ, it's yours.

23
00:01:18,280 --> 00:01:20,290
Great, thanks, can you see the slides,

24
00:01:20,900 --> 00:01:21,560
is that working?

25
00:01:21,800 --> 00:01:22,370
Okay, great.

26
00:01:22,790 --> 00:01:26,900
So so we build Go to support writing the sort of distributed systems,

27
00:01:26,900 --> 00:01:28,280
that we were building at Google,

28
00:01:28,640 --> 00:01:30,500
and that may Go a great fit for,

29
00:01:30,500 --> 00:01:32,780
what came next which is now called cloud software

30
00:01:32,810 --> 00:01:35,570
and also a great fit for 6.824.

31
00:01:35,600 --> 00:01:36,620
So in this lecture,

32
00:01:36,620 --> 00:01:37,850
I'm going to try to explain,

33
00:01:37,850 --> 00:01:40,580
how I think about writing programs in Go.

34
00:01:41,070 --> 00:01:45,690
I'm going to walk through the sort of design and implementation of programs

35
00:01:45,720 --> 00:01:48,510
for four different patterns that I see come up often.

36
00:01:49,060 --> 00:01:52,000
And along the way, I'm going to try to highlight some hints or rules of thumb,

37
00:01:52,000 --> 00:01:54,970
that you can keep in mind when designing your own Go programs.

38
00:01:55,420 --> 00:01:57,850
And I know the syllabus links to an older version of the slide,

39
00:01:57,850 --> 00:01:59,470
so you might have seen them already,

40
00:01:59,680 --> 00:02:02,110
I hope that the lecture form is a bit more intelligible

41
00:02:02,110 --> 00:02:04,330
than just sort of looking at the slides.

42
00:02:04,880 --> 00:02:08,360
And I hope that in general these patterns are common enough,

43
00:02:08,390 --> 00:02:10,340
that maybe they'll be helpful by themselves,

44
00:02:10,340 --> 00:02:12,530
but also that you know you'll,

45
00:02:12,560 --> 00:02:16,070
the hints will help you prepare for whatever it is you need to implement.

46
00:02:18,900 --> 00:02:23,280
So to start, it's important to distinguish between concurrency and parallelism.

47
00:02:23,810 --> 00:02:26,480
And concurrency is about how you write your programs

48
00:02:26,510 --> 00:02:31,100
about being able to compose independently executing control flows,

49
00:02:31,100 --> 00:02:33,950
whether you want to call them processes or threads or goroutines,

50
00:02:34,190 --> 00:02:37,640
so that your program can be dealing with lots of things at once,

51
00:02:37,670 --> 00:02:39,470
without turning into a giant mess.

52
00:02:40,100 --> 00:02:43,310
On the other hand parallelism is about how the programs get executed,

53
00:02:43,610 --> 00:02:47,180
about allowing multiple computations to run simultaneously,

54
00:02:47,180 --> 00:02:49,910
so that the program can be doing lots of things at once,

55
00:02:49,910 --> 00:02:51,680
not just dealing with [lots] of things at once.

56
00:02:52,120 --> 00:02:55,690
And so concurrency lends itself naturally to parallel execution,

57
00:02:55,930 --> 00:02:57,400
but today the focus is on,

58
00:02:57,400 --> 00:03:01,000
how to use Go's concurrency support to make your programs clear,

59
00:03:01,330 --> 00:03:02,740
not to make them faster,

60
00:03:02,740 --> 00:03:04,300
if they do get faster, that's wonderful,

61
00:03:04,300 --> 00:03:05,830
but that's not the point today.

62
00:03:07,220 --> 00:03:11,450
So I said, I'd walked through the design and implementation of some programs

63
00:03:11,450 --> 00:03:16,280
for four common, excuse me, concurrency patterns that I see often,

64
00:03:16,580 --> 00:03:18,260
but before we get to those,

65
00:03:18,290 --> 00:03:20,780
I want to start with what seems like a really trivial problem,

66
00:03:20,780 --> 00:03:23,420
but that illustrates one of the most important points

67
00:03:23,420 --> 00:03:26,750
about what it means to use concurrency to structure programs.

68
00:03:27,570 --> 00:03:31,080
A decision that comes up over and over, when you design concurrent programs

69
00:03:31,230 --> 00:03:34,980
is whether to represent states as code or as data.

70
00:03:35,220 --> 00:03:37,980
And by as code, I mean the control flow in the program,

71
00:03:38,780 --> 00:03:41,240
so suppose reading characters from a file,

72
00:03:41,270 --> 00:03:44,000
and we need to scan over a C style quoted string.

73
00:03:44,180 --> 00:03:46,190
Oh hello the slides aren't changing.

74
00:03:46,340 --> 00:03:47,630
Yeah, it will,

75
00:03:47,630 --> 00:03:50,660
can you see prologue goroutines for state right now.

76
00:03:50,690 --> 00:03:51,920
No, we see the title slide.

77
00:03:52,190 --> 00:03:54,500
Oh, no, yeah I was wondering about that,

78
00:03:54,500 --> 00:03:58,190
because there was a border around this thing, when I started

79
00:03:58,190 --> 00:03:59,600
and then it went away.

80
00:04:00,220 --> 00:04:03,070
So let me let me just unshare and reshare.

81
00:04:04,280 --> 00:04:07,740
I had to figure out how to do that in Zoom.

82
00:04:10,760 --> 00:04:12,980
Unfortunately, Keynote menu wants to be up

83
00:04:12,980 --> 00:04:14,570
and I don't know how to get to the Zoom menu.

84
00:04:19,880 --> 00:04:22,040
Ah, my screen sharing is paused,

85
00:04:22,040 --> 00:04:23,600
why is my screen sharing paused,

86
00:04:24,930 --> 00:04:26,100
can I resume,

87
00:04:26,600 --> 00:04:27,620
here we go.

88
00:04:27,650 --> 00:04:29,210
Alright, I don't know,

89
00:04:29,240 --> 00:04:31,160
the Zoom [box] says your screen sharing is paused,

90
00:04:31,160 --> 00:04:31,850
so that,

91
00:04:31,850 --> 00:04:33,050
now the borders back,

92
00:04:33,050 --> 00:04:34,040
so I'll watch that.

93
00:04:35,630 --> 00:04:40,030
Alright so, see, I was back here,

94
00:04:40,060 --> 00:04:42,160
so so you're reading a string,

95
00:04:42,520 --> 00:04:43,690
it's not a parallel program,

96
00:04:43,690 --> 00:04:44,950
is reading one character at a time,

97
00:04:44,950 --> 00:04:46,510
so there's no opportunity for parallelism,

98
00:04:46,510 --> 00:04:48,520
but there is a good opportunity for concurrency.

99
00:04:48,940 --> 00:04:52,660
So we don't actually care about the exact escape sequences in the string,

100
00:04:52,960 --> 00:04:55,450
that we need to do is match this regular expression,

101
00:04:55,880 --> 00:04:58,070
and we don't have to worry about understanding exactly,

102
00:04:58,100 --> 00:04:59,210
we'll come back to what it means,

103
00:04:59,210 --> 00:05:02,450
but that's basically all you have to do is implement this regular expression.

104
00:05:02,960 --> 00:05:04,790
And so you know you probably all know,

105
00:05:04,790 --> 00:05:07,100
you can turn a regular expression into a state machine,

106
00:05:07,280 --> 00:05:10,100
and so we might use a tool that generates this code,

107
00:05:10,950 --> 00:05:13,290
and in this code, there's a single variable state,

108
00:05:13,320 --> 00:05:14,730
that's the state of the machine,

109
00:05:14,910 --> 00:05:17,700
and the loop goes over the state one character at a time,

110
00:05:17,700 --> 00:05:19,380
reads the character depending on the state,

111
00:05:19,380 --> 00:05:21,270
and the character changes to a different state,

112
00:05:21,510 --> 00:05:22,620
until it gets to the end,

113
00:05:23,100 --> 00:05:25,530
and so this is a completely unreadable program,

114
00:05:25,770 --> 00:05:26,610
but it's the kind of thing,

115
00:05:26,610 --> 00:05:28,890
that you know an auto generated program might look like.

116
00:05:29,360 --> 00:05:33,110
And the important point is that the program state is stored in data,

117
00:05:33,110 --> 00:05:34,730
in this variable, that's called state,

118
00:05:35,270 --> 00:05:38,690
and if you can change it to store the state in code,

119
00:05:38,990 --> 00:05:40,280
that's often clearer.

120
00:05:41,260 --> 00:05:42,490
So here's what I mean,

121
00:05:42,880 --> 00:05:47,590
suppose we duplicate the readChar calls into each case of the switch,

122
00:05:47,890 --> 00:05:49,840
so we haven't made any semantic changes here,

123
00:05:49,840 --> 00:05:52,780
we just took the readChar that was at the top and we moved it into the middle.

124
00:05:53,940 --> 00:05:57,870
Now instead of setting state and then immediately doing the switch again,

125
00:05:57,900 --> 00:05:59,820
we can change those into gotos,

126
00:06:01,920 --> 00:06:03,930
and then we can simplify a little bit further,

127
00:06:03,930 --> 00:06:05,070
there's a goto state1,

128
00:06:05,070 --> 00:06:06,690
that's right before the state1 label,

129
00:06:06,690 --> 00:06:07,650
we can get rid of that.

130
00:06:08,340 --> 00:06:11,210
Then there's, I guess,

131
00:06:11,210 --> 00:06:14,810
yeah, so then there's you know there's only one way to get the state2,

132
00:06:14,840 --> 00:06:16,520
so we might as well pull the state2 code up

133
00:06:16,520 --> 00:06:18,890
and put it inside the if where the goto appears,

134
00:06:19,340 --> 00:06:23,300
and then both sides of that if now end in goto state1,

135
00:06:23,510 --> 00:06:24,920
so we can hoist that out.

136
00:06:25,440 --> 00:06:28,560
And now what's left is actually a pretty simple program,

137
00:06:28,590 --> 00:06:30,240
you know state0 is never jumped to,

138
00:06:30,240 --> 00:06:31,680
so it just begins there,

139
00:06:31,830 --> 00:06:33,630
and then state1 is just a regular loop,

140
00:06:33,660 --> 00:06:36,180
so we might as well make that look like a regular loop.

141
00:06:37,240 --> 00:06:40,930
And now like this is you know looking like a program,

142
00:06:41,320 --> 00:06:44,050
and then finally we can get rid of some variables

143
00:06:44,080 --> 00:06:45,700
and simplify a little bit further.

144
00:06:46,280 --> 00:06:48,230
And, and we can rotate the loop,

145
00:06:48,230 --> 00:06:51,140
so that you know we don't do a return true in the middle of the loop,

146
00:06:51,140 --> 00:06:52,610
we do the return true at the end.

147
00:06:54,220 --> 00:06:56,200
And so now we've got this program,

148
00:06:56,200 --> 00:06:59,230
that is actually you know reasonably nice,

149
00:06:59,230 --> 00:07:01,180
and it's worth mentioning that,

150
00:07:01,210 --> 00:07:03,970
it's possible to clean up much less egregious examples,

151
00:07:03,970 --> 00:07:05,800
you know if you had tried to write this by hand,

152
00:07:05,980 --> 00:07:08,260
your first attempt might have been the thing on the left,

153
00:07:08,320 --> 00:07:10,240
where you've got this extra piece of state,

154
00:07:10,420 --> 00:07:13,150
and then you can apply the same kinds of transformations

155
00:07:13,150 --> 00:07:15,910
to move that state into the actual control flow,

156
00:07:16,030 --> 00:07:18,700
and end up, { the same program that we have on the right,

157
00:07:18,700 --> 00:07:19,360
that's cleaner.

158
00:07:20,000 --> 00:07:23,630
So this is a useful transformation to keep in mind,

159
00:07:23,900 --> 00:07:24,980
anytime you have state,

160
00:07:24,980 --> 00:07:28,820
that kind of looks like it might be just reiterating,

161
00:07:28,820 --> 00:07:30,650
what's what's happening in the program counter.

162
00:07:31,760 --> 00:07:37,220
And so you can see this if the the original state,

163
00:07:37,220 --> 00:07:38,330
like if state equals 0,

164
00:07:38,330 --> 00:07:40,310
the program counter is at the beginning of the function,

165
00:07:40,430 --> 00:07:43,880
and if state equals 1 or if inEscape equals false and the other version,

166
00:07:44,060 --> 00:07:46,040
the program counter is just inside the for loop,

167
00:07:46,040 --> 00:07:48,470
and state equals 2 is further down in the for loop.

168
00:07:49,040 --> 00:07:52,040
And the benefit of writing it this way instead of with the states

169
00:07:52,070 --> 00:07:53,780
is that it's much easier to understand,

170
00:07:54,140 --> 00:07:56,960
like I can actually just walk through the code and explain it to you,

171
00:07:56,960 --> 00:07:58,490
you know if you just read through the code,

172
00:07:58,490 --> 00:08:01,040
you read an opening quote and then you start looping,

173
00:08:01,040 --> 00:08:02,780
and then until you find the closing quote,

174
00:08:02,780 --> 00:08:03,620
you read a character

175
00:08:03,620 --> 00:08:04,490
and if it's a backslash,

176
00:08:04,490 --> 00:08:05,510
you skip the next character,

177
00:08:05,510 --> 00:08:06,260
and that's it right,

178
00:08:06,260 --> 00:08:07,580
you can just read that off the page,

179
00:08:07,580 --> 00:08:09,500
which you couldn't do in the original.

180
00:08:10,790 --> 00:08:13,190
This version also happens to run faster,

181
00:08:13,190 --> 00:08:15,320
although that doesn't really matter for us.

182
00:08:17,270 --> 00:08:17,870
But as I mentioned,

183
00:08:17,870 --> 00:08:20,150
I'm going to highlight what I think are kind of important lessons

184
00:08:20,150 --> 00:08:22,070
as hints for designing your own Go programs,

185
00:08:22,070 --> 00:08:23,150
and this is the first one,

186
00:08:23,360 --> 00:08:25,970
to convert data state into code state,

187
00:08:26,000 --> 00:08:27,830
when it makes your programs clearer.

188
00:08:28,660 --> 00:08:30,910
And again like these are all hints,

189
00:08:31,180 --> 00:08:33,310
you should you should you know for all of these,

190
00:08:33,310 --> 00:08:34,600
you should consider it as,

191
00:08:34,600 --> 00:08:36,220
only if it helps you can decide.

192
00:08:38,260 --> 00:08:40,360
So one problem with this hint is that,

193
00:08:40,360 --> 00:08:45,220
not all programs have the luxury of having complete control over their control flow,

194
00:08:45,550 --> 00:08:47,890
so you know here's a different example,

195
00:08:47,890 --> 00:08:50,650
instead of having a readChar function that can be called,

196
00:08:50,830 --> 00:08:53,950
this code is written to have a ProcessChar method,

197
00:08:53,950 --> 00:08:56,470
that you have to hand the character to one at a time,

198
00:08:57,010 --> 00:08:59,590
and then ProcessChar has no choice really,

199
00:08:59,680 --> 00:09:03,310
but to you know encoded state in an explicit state variable,

200
00:09:03,310 --> 00:09:06,160
because after every character, it has to return back out,

201
00:09:06,460 --> 00:09:09,430
and so it can't save the state at the program counter and stack,

202
00:09:09,430 --> 00:09:12,430
it has to have the state in an actual variable.

203
00:09:13,550 --> 00:09:16,790
But in Go, we have another choice, right,

204
00:09:16,790 --> 00:09:20,390
because we can't save the state on that stack and in that program counter,

205
00:09:20,750 --> 00:09:24,500
but we can make another goroutine to hold that state for us.

206
00:09:25,490 --> 00:09:28,850
So supposing we already have this debug readString function,

207
00:09:29,120 --> 00:09:32,030
that we really don't want to rewrite in this other way,

208
00:09:32,060 --> 00:09:32,900
we just want to reuse it,

209
00:09:32,900 --> 00:09:33,830
it works,

210
00:09:33,830 --> 00:09:35,120
maybe it's really big and hairy,

211
00:09:35,120 --> 00:09:37,130
it's much more complicated than anything we saw,

212
00:09:37,310 --> 00:09:38,540
we just want to reuse it.

213
00:09:38,870 --> 00:09:40,640
And so the way we can do that in Go is,

214
00:09:40,640 --> 00:09:43,820
we can start a new goroutine that does the readString part,

215
00:09:43,820 --> 00:09:45,980
it's the same readString code as before,

216
00:09:45,980 --> 00:09:47,600
we pass in the character reader.

217
00:09:48,070 --> 00:09:55,210
And now here you know the Init method makes this goroutine to do the character reading,

218
00:09:55,210 --> 00:09:59,050
and then every time the ProcessChar method is called,

219
00:10:00,250 --> 00:10:02,980
we send a message to the goroutine on the char channel,

220
00:10:02,980 --> 00:10:04,960
that says here's the next character,

221
00:10:05,230 --> 00:10:06,700
and then we receive a message back,

222
00:10:06,700 --> 00:10:08,320
that says tell me the current status,

223
00:10:08,320 --> 00:10:09,580
and the current status is always,

224
00:10:09,580 --> 00:10:11,260
either I need more input

225
00:10:11,590 --> 00:10:15,760
or you know basically you know was it okay or not.

226
00:10:16,620 --> 00:10:19,070
And so you know,

227
00:10:19,070 --> 00:10:22,580
this lets us move the the program counter,

228
00:10:22,580 --> 00:10:24,440
that we couldn't do on the first stack

229
00:10:24,440 --> 00:10:26,120
into the other stack of the goroutine.

230
00:10:26,360 --> 00:10:30,770
And so using additional goroutines is a great way to hold additional code state,

231
00:10:30,770 --> 00:10:33,680
and give you the ability to do these kinds of cleanups,

232
00:10:33,830 --> 00:10:37,730
even if the original structure of the problem makes it look like you can't.

233
00:10:40,600 --> 00:10:41,080
Russ.

234
00:10:42,160 --> 00:10:42,760
Go ahead.

235
00:10:42,760 --> 00:10:46,360
I assume you're fine with people asking questions.

236
00:10:46,390 --> 00:10:47,140
Yeah, absolutely.

237
00:10:47,140 --> 00:10:48,190
I just wanted to make sure that.

238
00:10:48,550 --> 00:10:50,590
Yeah, definitely, please interrupt.

239
00:10:51,070 --> 00:10:53,770
So,so the hint here is

240
00:10:53,770 --> 00:10:56,920
to use additional goroutines to hold additional code state,

241
00:10:57,190 --> 00:10:59,770
and there's there's one caveat to this,

242
00:10:59,770 --> 00:11:03,220
and it's not free to just make goroutines, right,

243
00:11:03,220 --> 00:11:04,840
you have to actually make sure that they exit,

244
00:11:04,930 --> 00:11:06,640
because otherwise you'll just accumulate them.

245
00:11:07,080 --> 00:11:08,610
And so you have to think about,

246
00:11:08,910 --> 00:11:10,890
you know why does the goroutine exit,

247
00:11:10,890 --> 00:11:13,050
like you know is it going to get cleaned up.

248
00:11:13,230 --> 00:11:14,430
And in this case,

249
00:11:14,830 --> 00:11:18,490
we know that you know q.parse is going to return,

250
00:11:19,480 --> 00:11:20,560
where q.parse go.

251
00:11:22,390 --> 00:11:24,370
Sorry that's not right.

252
00:11:26,420 --> 00:11:27,680
Oh, sorry, the readString here,

253
00:11:27,680 --> 00:11:28,700
readString is going to return,

254
00:11:28,700 --> 00:11:31,910
anytime it sends a message, that says need more input.

255
00:11:32,450 --> 00:11:34,580
Where it go, there's something missing from this slide.

256
00:11:38,600 --> 00:11:41,060
Sorry, I write this until last night.

257
00:11:43,870 --> 00:11:46,300
So so as we go in, we go into Init,

258
00:11:46,720 --> 00:11:47,830
we kick off this goroutine,

259
00:11:47,830 --> 00:11:49,840
that's gonna call readChar a bunch of times,

260
00:11:49,840 --> 00:11:51,400
and then we read the status once

261
00:11:51,400 --> 00:11:53,590
and that first status is going to happen,

262
00:11:53,620 --> 00:11:57,340
because the the first call to readChar from readString

263
00:11:57,340 --> 00:11:58,600
is going to saying I need more input,

264
00:11:58,600 --> 00:12:00,010
and then we're going to send a character back,

265
00:12:01,080 --> 00:12:03,780
we're going to send the character back in ProcessChar,

266
00:12:04,110 --> 00:12:07,770
and then every time ProcessChar gets called, it returns a status,

267
00:12:07,830 --> 00:12:11,340
and so up until you get, you know need more input,

268
00:12:11,340 --> 00:12:12,630
you're going to get the.

269
00:12:15,000 --> 00:12:16,200
Sorry, this is not working,

270
00:12:16,560 --> 00:12:20,100
you're going to get any more input for every time you want to read a character.

271
00:12:20,850 --> 00:12:22,350
And then when it's done reading characters,

272
00:12:22,350 --> 00:12:25,830
what I haven't shown you here, what seems to be missing somehow,

273
00:12:25,860 --> 00:12:29,370
is when things exit and when things exit.

274
00:12:29,670 --> 00:12:30,900
Let's see, if it's on this slide.

275
00:12:31,200 --> 00:12:33,930
Yeah, so there's a return Success and a return BadInput,

276
00:12:33,930 --> 00:12:34,980
that I'd forgotten about.

277
00:12:35,480 --> 00:12:39,050
And so, you know these returning different status and then they're done.

278
00:12:39,680 --> 00:12:41,420
So when ProcessChar,

279
00:12:41,510 --> 00:12:44,270
in in the readString version,

280
00:12:44,330 --> 00:12:47,180
when it returns BadInput or Success,

281
00:12:47,180 --> 00:12:48,650
we say that you know it's done.

282
00:12:48,650 --> 00:12:52,580
And so as long as the caller is going through,

283
00:12:53,520 --> 00:12:57,930
and you know calling until it gets something, that's not need more input,

284
00:12:58,080 --> 00:12:59,940
then the goroutine will finish,

285
00:12:59,940 --> 00:13:01,890
but maybe if we stop early,

286
00:13:01,890 --> 00:13:04,350
if the caller hits an EOF and stops on its own,

287
00:13:04,350 --> 00:13:06,000
without telling us that it's done,

288
00:13:06,030 --> 00:13:07,620
there's a goroutine leftover,

289
00:13:07,680 --> 00:13:09,030
and so that could be a problem.

290
00:13:09,610 --> 00:13:11,200
And so you just you need to make sure that

291
00:13:11,200 --> 00:13:14,230
you know when and why each goroutine will exit,

292
00:13:14,710 --> 00:13:16,180
and the nice thing is that,

293
00:13:16,180 --> 00:13:17,500
if you do make a mistake

294
00:13:17,680 --> 00:13:19,090
and you leave goroutine stuck,

295
00:13:19,300 --> 00:13:20,350
they just sit there,

296
00:13:20,350 --> 00:13:22,330
it's like the best possible bug in the world,

297
00:13:22,330 --> 00:13:24,400
because they just sit around, waiting for you to look at them,

298
00:13:24,400 --> 00:13:25,990
and all you have to do is remember to look for them.

299
00:13:26,380 --> 00:13:28,810
And so here's a very simple program,

300
00:13:29,270 --> 00:13:31,910
and these goroutines and it runs an http server,

301
00:13:32,150 --> 00:13:34,010
and so if we run this,

302
00:13:34,040 --> 00:13:36,140
it kicks off a whole bunch of f goroutines,

303
00:13:36,200 --> 00:13:38,960
and they all block trying to send to a channel,

304
00:13:39,020 --> 00:13:40,520
and then it makes the http server.

305
00:13:40,990 --> 00:13:43,360
And so if I run this program, it just sits there,

306
00:13:43,570 --> 00:13:45,970
and if I type control backslash on a Unix system,

307
00:13:45,970 --> 00:13:47,050
I get a SIGQUIT,

308
00:13:47,410 --> 00:13:50,380
which makes it crash and dump all the stacks on the goroutines.

309
00:13:50,590 --> 00:13:51,910
And you can see on the slide,

310
00:13:51,910 --> 00:13:53,680
you know it's going to print over and over again,

311
00:13:53,680 --> 00:13:56,110
here's a goroutine and h call from g call from f,

312
00:13:56,570 --> 00:13:57,920
and in the channel send.

313
00:13:58,970 --> 00:14:00,140
And if you look at the line numbers,

314
00:14:00,140 --> 00:14:01,640
you can see exactly where they are.

315
00:14:02,740 --> 00:14:04,060
Another option is that,

316
00:14:04,060 --> 00:14:05,860
since we're in an http server,

317
00:14:06,560 --> 00:14:10,430
and the http server imports the net http pprof package,

318
00:14:10,520 --> 00:14:14,720
you can actually just visit the http server's /debug/pprof/goroutine url,

319
00:14:15,210 --> 00:14:17,790
which gives you the stacks of all the running goroutines,

320
00:14:17,970 --> 00:14:19,470
and unlike the crash dump,

321
00:14:19,500 --> 00:14:20,880
it takes a little more effort

322
00:14:20,880 --> 00:14:23,880
and it duplicates the goroutines based on their stacks,

323
00:14:24,090 --> 00:14:27,600
and so and then it sorts them by how many there are of each stack,

324
00:14:27,600 --> 00:14:29,070
and so if you have a goroutine leak,

325
00:14:29,370 --> 00:14:30,990
the leak shows up at the very top.

326
00:14:30,990 --> 00:14:31,620
So in this case,

327
00:14:31,620 --> 00:14:33,180
you've got a hundred goroutines stack

328
00:14:33,180 --> 00:14:35,070
in h called from g called from f,

329
00:14:35,310 --> 00:14:37,860
and then we can see there's one of a couple other goroutines,

330
00:14:37,860 --> 00:14:39,000
we don't really care about them.

331
00:14:39,670 --> 00:14:41,200
And so you know this is a new hint that,

332
00:14:41,470 --> 00:14:43,180
it just it's really really useful

333
00:14:43,180 --> 00:14:46,420
to look for stack goroutines by just going to this endpoint.

334
00:14:48,240 --> 00:14:51,240
Alright, so that was kind of the warm up.

335
00:14:51,720 --> 00:14:54,330
Now I want to look at the first real concurrency pattern,

336
00:14:54,330 --> 00:14:55,830
which is a publish subscribe server.

337
00:14:56,690 --> 00:14:59,330
So publish subscribe is a way of structuring a program,

338
00:14:59,450 --> 00:15:00,800
that you decouple the parts,

339
00:15:00,800 --> 00:15:04,400
that are publishing interesting events from the things that are subscribing to them,

340
00:15:04,520 --> 00:15:08,420
and there's a publish subscribe or pub sub server in the middle that connects those,

341
00:15:08,450 --> 00:15:11,150
so the individual publishers and the individual subscribers

342
00:15:11,150 --> 00:15:13,760
don't have to be aware of exactly who the other ones are.

343
00:15:14,540 --> 00:15:16,520
So you know on your Android phone,

344
00:15:16,670 --> 00:15:19,070
an app might publish or make a phone call event,

345
00:15:19,070 --> 00:15:21,440
and then the dial might subscribe to that

346
00:15:21,440 --> 00:15:23,420
and actually start you know help dial.

347
00:15:24,800 --> 00:15:26,420
And so in a real pub sub server,

348
00:15:26,420 --> 00:15:29,030
there are ways to filter events based on what kind they are,

349
00:15:29,030 --> 00:15:31,190
so that when you publish and make a phone call event,

350
00:15:31,190 --> 00:15:32,840
it doesn't go to your email program.

351
00:15:33,200 --> 00:15:34,220
But for now,

352
00:15:34,220 --> 00:15:37,190
we're just going to assume that the filtering is taken care of separately

353
00:15:37,220 --> 00:15:40,310
and we're just worried about the actual publish and subscribe,

354
00:15:41,070 --> 00:15:42,360
and the concurrency of that.

355
00:15:43,020 --> 00:15:45,210
So here's an API we want to implement,

356
00:15:45,980 --> 00:15:47,300
with any number of clients,

357
00:15:47,300 --> 00:15:49,580
that can call Subscribe with a channel

358
00:15:49,850 --> 00:15:53,720
and afterwards, events that are published will be sent on that channel,

359
00:15:54,480 --> 00:15:56,580
and then when a client is no longer interested,

360
00:15:56,640 --> 00:15:59,190
it can call Cancel and passing the same channel,

361
00:15:59,220 --> 00:16:01,830
to say stop sending the events on that channel,

362
00:16:02,250 --> 00:16:04,020
and the way the Cancel will signal that,

363
00:16:04,020 --> 00:16:06,510
it really is done sending events on that channel,

364
00:16:06,510 --> 00:16:07,890
is it will close the channel,

365
00:16:08,070 --> 00:16:11,310
so that the receiver caller can keep receiving events

366
00:16:11,310 --> 00:16:12,900
until it sees the channel get closed,

367
00:16:12,900 --> 00:16:14,940
then it knows that the Cancel has taken effect.

368
00:16:18,020 --> 00:16:22,580
So notice that the information is only flowing one way on the channel, right,

369
00:16:22,580 --> 00:16:24,530
you can send to the channel,

370
00:16:24,800 --> 00:16:26,810
and then the receiver can receive from it,

371
00:16:26,810 --> 00:16:29,180
and the information flows from the sender to the receiver,

372
00:16:29,180 --> 00:16:30,440
and it never goes the other way.

373
00:16:30,470 --> 00:16:34,640
So closing is also a signal from the sender to the receiver,

374
00:16:34,640 --> 00:16:36,260
but all the sending is over,

375
00:16:36,620 --> 00:16:38,390
the receiver cannot close the channel

376
00:16:38,390 --> 00:16:40,760
to tell the sender I don't want you to send anymore,

377
00:16:40,790 --> 00:16:43,190
because that's information going in the opposite direction.

378
00:16:43,830 --> 00:16:45,780
And it's just a lot easier to reason about,

379
00:16:45,900 --> 00:16:48,060
if the information only goes one way,

380
00:16:48,180 --> 00:16:51,780
and of course if you need communication in both directions,

381
00:16:51,780 --> 00:16:53,370
you can use a pair of channels,

382
00:16:53,430 --> 00:16:54,900
and it often turns out to be the case,

383
00:16:54,900 --> 00:16:59,010
that those different directions may have different types of data flowing,

384
00:16:59,070 --> 00:17:00,330
like before we saw that,

385
00:17:00,330 --> 00:17:01,680
there were runes going in one direction

386
00:17:01,680 --> 00:17:03,600
and status updates going in the other direction.

387
00:17:04,560 --> 00:17:07,320
So how do we implement this API,

388
00:17:07,870 --> 00:17:09,940
here's a pretty basic implementation,

389
00:17:09,940 --> 00:17:11,290
that you know could be good enough.

390
00:17:11,910 --> 00:17:13,020
We have a Server

391
00:17:13,200 --> 00:17:16,740
and the Server state is a map of registered subscriber channels,

392
00:17:16,740 --> 00:17:17,970
protected by a lock,

393
00:17:18,630 --> 00:17:21,510
we initialize the Server by just allocating the map,

394
00:17:22,210 --> 00:17:23,590
and then to publish the event,

395
00:17:23,620 --> 00:17:26,110
we just send it to every register channel,

396
00:17:27,060 --> 00:17:28,380
to subscribe a new channel,

397
00:17:28,380 --> 00:17:29,640
we just add that to the map

398
00:17:29,850 --> 00:17:31,770
and to cancel, we take it out of the map.

399
00:17:32,370 --> 00:17:33,960
And then, because these are all,

400
00:17:34,110 --> 00:17:37,740
these are all methods that might be called from multiple goroutines,

401
00:17:38,190 --> 00:17:44,400
we need to call lock and unlock around these to protect the map,

402
00:17:44,890 --> 00:17:48,310
and notice that I wrote defer unlock right after the lock,

403
00:17:48,460 --> 00:17:50,470
so I don't have to remember to unlock it later,

404
00:17:51,080 --> 00:17:52,550
you probably all seen this,

405
00:17:52,550 --> 00:17:54,800
you know sort of a nice idiom to just do the lock unlock,

406
00:17:54,800 --> 00:17:56,270
and then you know I have a blank line

407
00:17:56,270 --> 00:17:58,550
and have that be its own paragraph in the code.

408
00:18:02,620 --> 00:18:05,050
One thing I want to point out is that,

409
00:18:05,050 --> 00:18:07,540
using defer makes sure that the mutexes gets unlocked,

410
00:18:07,660 --> 00:18:09,610
even if you have multiple returns from the function,

411
00:18:09,610 --> 00:18:10,660
so you can't forget,

412
00:18:10,870 --> 00:18:13,960
but it also makes sure that it gets unlocked if you have a panic,

413
00:18:14,170 --> 00:18:15,940
like in Subscribe and Cancel,

414
00:18:15,970 --> 00:18:18,280
where there's panic for misuse.

415
00:18:19,010 --> 00:18:20,900
And there is a subtlety here about,

416
00:18:21,230 --> 00:18:23,150
if you might not want to unlock the mutex,

417
00:18:23,150 --> 00:18:24,620
if the panic happened,

418
00:18:24,620 --> 00:18:27,500
while the thing that was locked is in some inconsistent state,

419
00:18:27,650 --> 00:18:29,480
but I'm gonna ignore that for now,

420
00:18:29,870 --> 00:18:35,460
in general, you try to avoid having the things that might panic happen,

421
00:18:35,460 --> 00:18:37,710
while you're potentially in inconsistent state.

422
00:18:38,700 --> 00:18:40,110
And I should also point out that,

423
00:18:40,110 --> 00:18:43,230
the use of panic at all in Subscribe and Cancel,

424
00:18:43,350 --> 00:18:46,830
implies that you really trust your clients not to misuse the interface,

425
00:18:46,830 --> 00:18:48,450
that it is a program error,

426
00:18:48,450 --> 00:18:52,980
worth tearing down the entire program potentially for that to happen.

427
00:18:53,630 --> 00:18:57,050
And in a bigger program where other clients were using this API,

428
00:18:57,580 --> 00:18:59,470
you probably want to return an error instead,

429
00:18:59,740 --> 00:19:02,350
and not have the possibility of taking down the whole program,

430
00:19:02,470 --> 00:19:04,600
but panic is simplifies things for now,

431
00:19:05,200 --> 00:19:08,350
and you know error handling in general is kind of not the topic today.

432
00:19:10,930 --> 00:19:13,870
A more important concern with this code than panic is,

433
00:19:13,870 --> 00:19:18,040
what happens if a goroutine is slow to receive events.

434
00:19:18,630 --> 00:19:21,600
So all the operations here are done holding the mutex,

435
00:19:21,600 --> 00:19:24,660
which means all the clients kind of have to proceed in lockstep.

436
00:19:25,210 --> 00:19:29,800
So during Publish, there's a loop that's sending on the channels,

437
00:19:29,860 --> 00:19:31,420
sending the event to every channel,

438
00:19:31,450 --> 00:19:33,730
and if one subscriber falls behind,

439
00:19:33,850 --> 00:19:35,500
the next subscriber doesn't get the event,

440
00:19:35,500 --> 00:19:37,660
until that slow subscriber wakes up

441
00:19:37,660 --> 00:19:40,570
and actually get the event off of that channel.

442
00:19:41,120 --> 00:19:44,540
And so one slow subscriber can slow down everyone else,

443
00:19:44,810 --> 00:19:48,980
and you know forcing them to proceed in lockstep this way is not always a problem,

444
00:19:49,490 --> 00:19:51,770
if you document the restriction

445
00:19:51,770 --> 00:19:54,860
and for whatever reason you know how the clients are written

446
00:19:55,010 --> 00:19:57,380
and you know that they won't ever fall too far behind,

447
00:19:57,470 --> 00:19:58,700
this could be totally fine,

448
00:19:58,700 --> 00:20:00,380
it's a really simple implementation,

449
00:20:01,150 --> 00:20:03,610
and it has nice properties,

450
00:20:03,610 --> 00:20:05,110
like on return from Publish,

451
00:20:05,110 --> 00:20:08,890
you know that the event has actually been handed off to each of the other goroutines,

452
00:20:09,040 --> 00:20:10,750
you don't know that they've started processing it,

453
00:20:10,750 --> 00:20:12,070
but you know it's been handed off.

454
00:20:12,560 --> 00:20:15,230
And so, maybe that's good enough and you could stop here.

455
00:20:16,340 --> 00:20:17,840
A second option is that,

456
00:20:18,200 --> 00:20:22,190
if you need to tolerate just a little bit of slowness on the subscribers,

457
00:20:22,220 --> 00:20:23,690
then you could say that,

458
00:20:23,690 --> 00:20:25,490
they need to give you a buffered channel

459
00:20:25,490 --> 00:20:27,710
with room for a couple of events in the buffer,

460
00:20:27,770 --> 00:20:30,050
so that you know when you're publishing,

461
00:20:30,610 --> 00:20:32,170
you know as long as they're not too far behind,

462
00:20:32,170 --> 00:20:36,070
there always be room for the new event to go into the channel buffer,

463
00:20:36,160 --> 00:20:38,770
and then the actual Publish won't block for too long.

464
00:20:39,600 --> 00:20:40,980
And again, maybe that's good enough,

465
00:20:41,010 --> 00:20:43,530
if you're sure that they won't ever fall too far behind,

466
00:20:43,740 --> 00:20:44,940
you get to stop there.

467
00:20:45,780 --> 00:20:47,580
But in a really big program,

468
00:20:48,350 --> 00:20:53,180
you do want to cope more gracefully with arbitrarily slow subscribers,

469
00:20:53,180 --> 00:20:55,010
and so then the question is what do you do.

470
00:20:55,610 --> 00:20:57,770
And so in general you have three options,

471
00:20:57,860 --> 00:20:59,750
you can slow down the event generator,

472
00:20:59,780 --> 00:21:02,870
which is what the previous solutions implicitly do,

473
00:21:02,870 --> 00:21:06,560
because publish stops until the subscribers catch up.

474
00:21:07,230 --> 00:21:08,760
Or you can drop events

475
00:21:08,940 --> 00:21:11,850
or you can queue an arbitrary number of past events,

476
00:21:11,850 --> 00:21:13,620
those are pretty much your only options.

477
00:21:14,350 --> 00:21:18,490
So we talked about you know publish and slowing down the event generator.

478
00:21:19,060 --> 00:21:20,020
There's a middle ground,

479
00:21:20,020 --> 00:21:23,020
where you coalesce the events or you drop them,

480
00:21:24,100 --> 00:21:27,820
so that you know the subscriber might find out that,

481
00:21:27,910 --> 00:21:29,200
you know hey you missed some events

482
00:21:29,200 --> 00:21:30,250
and I can't tell you what they were,

483
00:21:30,250 --> 00:21:31,180
because I didn't save them,

484
00:21:31,180 --> 00:21:33,760
but I'm at least going to tell you, you missed five events,

485
00:21:34,180 --> 00:21:36,790
and then maybe it can do something else to try to catch up.

486
00:21:37,510 --> 00:21:41,230
And this is the kind of approach, that we take in the profiler,

487
00:21:41,230 --> 00:21:43,090
so in the profiler, if you've used it,

488
00:21:43,420 --> 00:21:43,840
if,

489
00:21:43,990 --> 00:21:45,250
there's a goroutine,

490
00:21:45,250 --> 00:21:50,620
that fills the profile on a signal handler actually with profiling events,

491
00:21:50,800 --> 00:21:52,120
and then there's a separate goroutine,

492
00:21:52,120 --> 00:21:53,980
whose job is to read the data back out

493
00:21:53,980 --> 00:21:56,890
and write it to disk or send it to an http request

494
00:21:56,890 --> 00:21:58,720
or whatever it is you're doing with profile data.

495
00:21:59,200 --> 00:22:00,970
And there's a buffer in the middle

496
00:22:01,150 --> 00:22:04,780
and if the receiver from the profile data falls behind,

497
00:22:04,990 --> 00:22:06,070
when the buffer fills up,

498
00:22:06,070 --> 00:22:09,880
we start adding entries to, a final profile entry,

499
00:22:09,940 --> 00:22:11,770
that just has a single entry,

500
00:22:11,770 --> 00:22:15,130
that's that's a function called [runtime last profile data],

501
00:22:15,370 --> 00:22:16,930
and so if you look at the profile,

502
00:22:16,930 --> 00:22:20,020
you see hey the program spent 5% of its time in [last] profile data,

503
00:22:20,110 --> 00:22:24,320
that just means you know the profile reader was too slow

504
00:22:24,320 --> 00:22:25,610
and it didn't catch up,

505
00:22:26,170 --> 00:22:27,430
and we lost some of the profile,

506
00:22:27,430 --> 00:22:31,570
but we're clear about exactly what the error rate is in the profile,

507
00:22:31,690 --> 00:22:33,310
and you pretty much never see that,

508
00:22:33,310 --> 00:22:35,230
because all the readers actually do keep up,

509
00:22:35,260 --> 00:22:36,790
but just in case they didn't,

510
00:22:37,030 --> 00:22:38,470
you have a pretty clear signal.

511
00:22:39,960 --> 00:22:44,430
An example of purely dropping the events is the OS signal package,

512
00:22:44,460 --> 00:22:48,880
where you have to pass in a channel,

513
00:22:48,880 --> 00:22:50,710
that will be ready to receive the signal,

514
00:22:50,920 --> 00:22:53,290
a signal like SIGHUP or SIGQUIT,

515
00:22:53,990 --> 00:22:55,520
and when the signal comes in,

516
00:22:55,550 --> 00:22:59,000
the runtime tries to send to each of the channels that subscribe to that signal,

517
00:22:59,360 --> 00:23:00,530
and if it can't send to it,

518
00:23:00,560 --> 00:23:02,630
it just doesn't, it's just gone,

519
00:23:02,630 --> 00:23:04,820
because you know in a signal handler, we can't wait,

520
00:23:05,120 --> 00:23:07,490
and so what the callers have to do is

521
00:23:07,490 --> 00:23:08,990
they have to pass in a buffer channel,

522
00:23:09,080 --> 00:23:10,760
and if they pass in a buffer channel,

523
00:23:10,820 --> 00:23:14,150
that has length at least one, buffer length at least one,

524
00:23:14,540 --> 00:23:18,110
and they only register that channel to a single signal,

525
00:23:18,230 --> 00:23:21,590
then you know that if a signal comes in,

526
00:23:21,590 --> 00:23:23,120
you're definitely gonna get told about it,

527
00:23:23,450 --> 00:23:24,710
if it comes in twice,

528
00:23:24,740 --> 00:23:26,480
you might only get told about it once,

529
00:23:26,510 --> 00:23:30,650
but that's actually the same semantics that Unix gives to processes for signals anyway,

530
00:23:30,890 --> 00:23:31,760
so that's fine.

531
00:23:32,220 --> 00:23:35,610
So those are both examples of dropping or coalescing events.

532
00:23:36,840 --> 00:23:38,460
And then the third choice is that,

533
00:23:38,550 --> 00:23:41,580
you might actually just really not want to lose any events,

534
00:23:41,580 --> 00:23:44,400
it might just be really important that you never lose anything,

535
00:23:44,610 --> 00:23:45,720
in which case,

536
00:23:45,810 --> 00:23:48,210
you know you can queue an arbitrary number of events,

537
00:23:48,210 --> 00:23:50,970
you can somehow arrange for the program

538
00:23:51,270 --> 00:23:55,620
to just save all the events that the slow subscriber hasn't seen yet somewhere

539
00:23:55,890 --> 00:23:57,960
and give them to the subscriber later.

540
00:23:58,720 --> 00:24:01,090
And it's really important to think carefully before you do that,

541
00:24:01,240 --> 00:24:03,040
because in a distributed system,

542
00:24:03,600 --> 00:24:05,190
you know there's always slow computers,

543
00:24:05,190 --> 00:24:08,340
always computers that have fallen offline or whatever,

544
00:24:08,340 --> 00:24:09,900
and they might be gone for a while,

545
00:24:10,020 --> 00:24:13,320
and so you don't want to introduce unbounded queuing, in general,

546
00:24:13,320 --> 00:24:15,300
you want to think very carefully before you do that,

547
00:24:15,300 --> 00:24:19,050
and think well you know how unbounded is [] and can I tolerate that.

548
00:24:19,620 --> 00:24:24,120
And so like that's a reason why channels don't have an unbounded buffering,

549
00:24:24,120 --> 00:24:26,160
it's really almost never the right choice,

550
00:24:26,160 --> 00:24:27,630
and if it is the right choice,

551
00:24:27,660 --> 00:24:29,340
you probably want to build it very carefully.

552
00:24:30,580 --> 00:24:32,950
And so but we're going to build one,

553
00:24:32,980 --> 00:24:34,780
just to see what it would look like.

554
00:24:35,950 --> 00:24:37,180
And before we do that,

555
00:24:37,210 --> 00:24:39,640
I just want to adjust the program a little bit,

556
00:24:40,000 --> 00:24:42,640
so we have this mutex in the code,

557
00:24:43,000 --> 00:24:46,780
and the mutex is an example of of keeping the state,

558
00:24:46,780 --> 00:24:49,150
whether you're locked or not in a state variable,

559
00:24:49,390 --> 00:24:52,360
but we can also move that into a program counter variable,

560
00:24:52,930 --> 00:24:54,640
by putting it in a different goroutine.

561
00:24:55,200 --> 00:24:57,860
And so, in this case,

562
00:24:57,860 --> 00:24:59,450
we can start a new goroutine,

563
00:24:59,600 --> 00:25:02,180
that runs a program function called s.loop,

564
00:25:02,860 --> 00:25:05,530
and it handles requests sent on three new channels,

565
00:25:05,530 --> 00:25:07,150
publish subscribe and cancel.

566
00:25:07,870 --> 00:25:08,740
And so in Init,

567
00:25:08,770 --> 00:25:10,150
we make the channels

568
00:25:10,240 --> 00:25:12,400
and then we kick off s.loop.

569
00:25:13,140 --> 00:25:17,670
And s.loop is sort of the amalgamation of the previous method bodies,

570
00:25:17,760 --> 00:25:20,850
and it just receives from any of the three channels,

571
00:25:20,880 --> 00:25:23,670
a request publish subscribe or cancel request,

572
00:25:24,060 --> 00:25:25,740
and it does whatever was asked,

573
00:25:26,130 --> 00:25:31,770
and now that map, the subscriber map, can be just a local variable in s.loop.

574
00:25:32,320 --> 00:25:35,050
And and so it's the same code,

575
00:25:35,690 --> 00:25:38,840
but now that data is clearly owned by s.loop,

576
00:25:38,840 --> 00:25:40,100
nothing else could even get to it,

577
00:25:40,100 --> 00:25:41,360
because it's a local variable.

578
00:25:44,080 --> 00:25:46,570
And then we just need to change the original methods

579
00:25:46,570 --> 00:25:48,730
to send the work over to the loop goroutine,

580
00:25:48,730 --> 00:25:53,650
and so uppercase Publish now sends on lower case publish the channel,

581
00:25:53,800 --> 00:25:55,600
the event that it wants to publish,

582
00:25:55,600 --> 00:25:57,730
and similarly subscribe and cancel.

583
00:25:58,230 --> 00:26:01,110
They create a request that has a channel,

584
00:26:01,320 --> 00:26:02,940
that we want to subscribe

585
00:26:02,940 --> 00:26:05,040
and also a channel to get the answer back,

586
00:26:05,220 --> 00:26:06,960
and they send that into the loop

587
00:26:07,110 --> 00:26:08,850
and the loop sends back the answer.

588
00:26:12,040 --> 00:26:14,980
And so I referred to transforming the program this way

589
00:26:14,980 --> 00:26:17,470
as converting the mutex into a goroutine,

590
00:26:17,560 --> 00:26:19,660
because we took the data state of the mutex,

591
00:26:19,660 --> 00:26:21,100
there's a lock bit inside it,

592
00:26:21,100 --> 00:26:24,460
and now that lock bit is implicit in the program counter of the loop.

593
00:26:26,050 --> 00:26:26,860
It's very clear that,

594
00:26:26,860 --> 00:26:30,820
you can't ever have a publish and subscribe happening at the same time,

595
00:26:30,850 --> 00:26:33,100
because it's just single thread code

596
00:26:33,100 --> 00:26:34,990
and just you know executed sequence.

597
00:26:36,660 --> 00:26:37,290
On the other hand,

598
00:26:37,290 --> 00:26:40,620
the original version had a kind of like clarity of state,

599
00:26:40,620 --> 00:26:42,180
where you could sort of inspect it,

600
00:26:42,390 --> 00:26:45,030
and reason about well this is the important state,

601
00:26:45,360 --> 00:26:49,530
and it's harder in the the goroutine version to see what's important state,

602
00:26:49,530 --> 00:26:52,860
and what's kind of incidental state from just having a goroutine.

603
00:26:53,680 --> 00:26:55,480
And in a given situation,

604
00:26:55,540 --> 00:26:57,490
one might be more important than the other,

605
00:26:57,850 --> 00:26:59,140
so a couple years ago,

606
00:26:59,140 --> 00:27:00,940
I did all the labs for the class,

607
00:27:00,940 --> 00:27:02,200
when it first switched to Go,

608
00:27:02,440 --> 00:27:04,600
and raft is a good example

609
00:27:04,600 --> 00:27:07,810
of where you probably prefer the state with the mutex,

610
00:27:07,810 --> 00:27:12,280
because raft is so different from most concurrent programs,

611
00:27:12,280 --> 00:27:17,110
and that each replica is just kind of profoundly uncertain of its state, right,

612
00:27:17,110 --> 00:27:18,430
like the state transitions,

613
00:27:18,970 --> 00:27:20,590
you know one moment you think you're the leader,

614
00:27:20,590 --> 00:27:22,210
and the next moment you've been deposed,

615
00:27:22,210 --> 00:27:23,830
like one moment your log has ten entries,

616
00:27:23,830 --> 00:27:25,990
and next moment actually you know it only has two entries,

617
00:27:26,170 --> 00:27:29,110
and so being able to manipulate that state directly

618
00:27:29,140 --> 00:27:32,860
rather than having to somehow get in and out of the program counter,

619
00:27:32,920 --> 00:27:34,660
makes a lot more sense for raft.

620
00:27:34,780 --> 00:27:37,450
But that's pretty unique in most situations,

621
00:27:38,010 --> 00:27:40,560
it cleans things up to put the state in the program counter.

622
00:27:42,620 --> 00:27:45,950
Alright, so in order to deal with the slow subscribers,

623
00:27:46,010 --> 00:27:48,170
now we're gonna add some helper goroutines,

624
00:27:48,260 --> 00:27:52,160
and their job is to manage a particular subscribers backlog

625
00:27:52,190 --> 00:27:54,170
and keep the overall program from blocking.

626
00:27:54,530 --> 00:27:56,360
And so this is the helper goroutine,

627
00:27:56,970 --> 00:28:00,660
and the the main loop goroutine will send the events to the helper,

628
00:28:00,840 --> 00:28:02,850
which we then trust, because we wrote it,

629
00:28:02,910 --> 00:28:05,010
not to fall arbitrarily behind,

630
00:28:05,160 --> 00:28:08,160
and then the helper's job is to queue events it needed

631
00:28:08,160 --> 00:28:09,810
and send them off to the subscriber.

632
00:28:10,860 --> 00:28:14,280
Alright, so this actually has two problems.

633
00:28:14,790 --> 00:28:15,930
The first is that,

634
00:28:16,260 --> 00:28:17,730
if there's nothing in the queue,

635
00:28:17,760 --> 00:28:21,270
then the select is actually wrong to try to offer queue of zero,

636
00:28:21,270 --> 00:28:23,100
and in fact just evaluating queue of 0,

637
00:28:23,100 --> 00:28:24,630
at the start of the select will panic,

638
00:28:24,630 --> 00:28:26,100
because the queue is empty

639
00:28:26,580 --> 00:28:28,320
and so we can fix these,

640
00:28:28,800 --> 00:28:31,800
by setting up the arguments separately from the select,

641
00:28:31,830 --> 00:28:35,520
and in particular we need to make a channel sendOut,

642
00:28:35,640 --> 00:28:36,840
that's going to be nil,

643
00:28:36,840 --> 00:28:39,630
which is never able to proceed in a select,

644
00:28:41,210 --> 00:28:42,830
as we know, when we don't want to send,

645
00:28:42,830 --> 00:28:44,660
and it's going to be the actual out channel,

646
00:28:44,660 --> 00:28:45,770
when we do want to send,

647
00:28:46,160 --> 00:28:47,840
and then we have to have a separate variable,

648
00:28:47,840 --> 00:28:49,520
that holds the event that we're going to send,

649
00:28:49,520 --> 00:28:51,830
it will actually read from queue of zero,

650
00:28:51,830 --> 00:28:52,970
if there's something in the queue.

651
00:28:55,400 --> 00:28:57,440
The second thing that's wrong is that,

652
00:28:57,440 --> 00:29:00,260
we need to handle closing of the channel, of the input channel,

653
00:29:00,380 --> 00:29:02,330
because when the input channel closes,

654
00:29:02,390 --> 00:29:04,070
we need to flush the rest of the queue,

655
00:29:04,070 --> 00:29:05,870
and then we need to close the output channel.

656
00:29:06,750 --> 00:29:07,950
So to check for that,

657
00:29:08,100 --> 00:29:09,210
we change the select

658
00:29:09,210 --> 00:29:11,790
from just doing e equals receiving from in

659
00:29:11,940 --> 00:29:14,130
to e, ok equals receiving from in,

660
00:29:14,130 --> 00:29:15,750
the comma ok will be told

661
00:29:15,780 --> 00:29:18,540
whether or not the channel is actually sending real data,

662
00:29:18,540 --> 00:29:19,710
or else it's closed.

663
00:29:20,280 --> 00:29:21,630
And so when ok is false,

664
00:29:21,720 --> 00:29:23,310
we can set in to nil,

665
00:29:23,340 --> 00:29:25,110
to say let's stop trying to receive from in,

666
00:29:25,110 --> 00:29:25,740
there's nothing there,

667
00:29:25,740 --> 00:29:27,720
we're just gonna keep getting told that it's closed.

668
00:29:28,730 --> 00:29:30,710
And then when the loop is fine,

669
00:29:30,710 --> 00:29:32,660
when the queue is finally empty,

670
00:29:32,690 --> 00:29:33,950
we can exit the loop,

671
00:29:34,040 --> 00:29:35,780
and so we change the for condition,

672
00:29:35,840 --> 00:29:38,030
to say we want to keep executing the loop

673
00:29:38,030 --> 00:29:40,490
as long as there actually still is an input channel,

674
00:29:40,880 --> 00:29:43,280
and there's something to write back to the output channel,

675
00:29:43,280 --> 00:29:45,890
and then once both of those are not true anymore,

676
00:29:46,010 --> 00:29:47,870
it's time to exit the loop

677
00:29:47,930 --> 00:29:49,220
and we close the output channel

678
00:29:49,490 --> 00:29:50,030
and we're done.

679
00:29:50,030 --> 00:29:51,890
And so now we've correctly propagated

680
00:29:52,010 --> 00:29:54,950
the closing of the input channel to the output channel,

681
00:29:56,640 --> 00:29:57,810
so that was the helper.

682
00:29:58,110 --> 00:30:00,240
And the Server loop used to look like this,

683
00:30:01,470 --> 00:30:02,520
and to update it,

684
00:30:02,700 --> 00:30:04,650
we just changed the subscription map,

685
00:30:04,740 --> 00:30:07,770
before it was a map from subscribe channels to bools,

686
00:30:07,770 --> 00:30:09,090
it was just basically a set,

687
00:30:09,480 --> 00:30:12,750
and now it's a map from subscribe channel to helper channel,

688
00:30:13,080 --> 00:30:14,880
and every time we get a new subscription,

689
00:30:15,060 --> 00:30:16,650
we make a helper channel,

690
00:30:16,680 --> 00:30:18,510
we kickoff a helper goroutine,

691
00:30:19,040 --> 00:30:21,710
and we record the helper channel in the subscription map

692
00:30:21,740 --> 00:30:23,810
instead of the actual channel.

693
00:30:24,510 --> 00:30:30,470
And then the rest of, the rest of the loop actually barely changes at all.

694
00:30:32,490 --> 00:30:33,870
So I do want to point out that,

695
00:30:33,870 --> 00:30:36,270
if you wanted to have a different strategy

696
00:30:36,270 --> 00:30:40,530
for what you do with clients that fall too far behind,

697
00:30:40,620 --> 00:30:42,390
that can all go in the helper goroutine,

698
00:30:42,450 --> 00:30:45,330
the code on the screen right now is completely unchanged,

699
00:30:45,330 --> 00:30:48,360
so we've completely separated the publish subscribe,

700
00:30:48,360 --> 00:30:51,150
maintaining the actual [list] of subscribers map,

701
00:30:51,180 --> 00:30:55,620
from the what do you do when things get too slow map problem.

702
00:30:55,950 --> 00:30:58,060
And so it's really nice,

703
00:30:58,060 --> 00:31:01,690
that you've got this clean separation of concerns into completely different goroutines,

704
00:31:01,690 --> 00:31:03,820
and that can help you keep your programs simpler.

705
00:31:04,360 --> 00:31:05,680
And so that's the general hint is that,

706
00:31:06,070 --> 00:31:10,090
you can use goroutines a lot of the time to separate independent concerns.

707
00:31:11,970 --> 00:31:12,480
Alright,

708
00:31:14,670 --> 00:31:18,150
so the second pattern for today is work scheduler,

709
00:31:18,570 --> 00:31:20,880
and you did one of these in lab 1 for mapreduce,

710
00:31:21,060 --> 00:31:22,830
and I'm just going to build up to that,

711
00:31:23,220 --> 00:31:25,740
and this doesn't do all the RPC stuff,

712
00:31:25,740 --> 00:31:26,670
it just kind of assumes that,

713
00:31:26,670 --> 00:31:28,830
there's kind of channel, channel based interfaces

714
00:31:28,830 --> 00:31:30,390
to all the servers.

715
00:31:31,430 --> 00:31:33,920
So you know we have this function Schedule,

716
00:31:33,950 --> 00:31:35,690
it takes a fixed list of servers,

717
00:31:36,260 --> 00:31:37,640
and a number of tasks to run,

718
00:31:37,880 --> 00:31:40,520
and it has just this abstracted function call,

719
00:31:40,610 --> 00:31:43,880
that you call to run the task on a specific server,

720
00:31:43,940 --> 00:31:46,580
you can imagine, it was doing the RPCs something.

721
00:31:48,120 --> 00:31:49,380
So we're gonna need some way

722
00:31:49,380 --> 00:31:52,890
to keep track of which servers are available to execute tasks.

723
00:31:53,440 --> 00:31:56,530
And so one option is to use our own stack or queue implementation,

724
00:31:56,650 --> 00:31:58,690
but another option is to use a channel,

725
00:31:58,690 --> 00:32:00,940
because it's a good synchronized queue.

726
00:32:01,740 --> 00:32:04,770
And so we can send into the channel to add to the queue

727
00:32:04,770 --> 00:32:06,780
and receive from it to pop something off.

728
00:32:07,330 --> 00:32:10,480
And in this case, we'll make the queue be a queue of servers,

729
00:32:10,840 --> 00:32:13,210
and we'll start off its a queue of idle servers,

730
00:32:13,210 --> 00:32:15,040
servers that aren't doing any work for us right now.

731
00:32:15,880 --> 00:32:17,620
We'll start off by just initializing it

732
00:32:17,680 --> 00:32:20,320
by sending all the known servers into the idle list.

733
00:32:21,880 --> 00:32:23,530
And then we can loop over the tasks,

734
00:32:23,530 --> 00:32:25,600
and for every task we kickoff a goroutine,

735
00:32:25,660 --> 00:32:28,210
and its job is to pull a server off the idle list,

736
00:32:28,540 --> 00:32:30,970
run the task, and then put the server back on.

737
00:32:32,060 --> 00:32:37,160
And this loop body is another example of the earlier hint to use goroutines,

738
00:32:37,340 --> 00:32:39,020
like independent things run independently,

739
00:32:39,140 --> 00:32:41,960
because each task is running as a separate concern,

740
00:32:41,990 --> 00:32:43,220
they're all running in parallel.

741
00:32:44,960 --> 00:32:47,510
Unfortunately, there are two problems with this program.

742
00:32:48,060 --> 00:32:51,420
The first one is that the closure that's running as a new goroutine

743
00:32:51,420 --> 00:32:54,210
refers to the loop iteration variable, which is task,

744
00:32:54,450 --> 00:32:56,370
and so by the time the goroutine starts executing,

745
00:32:56,430 --> 00:32:59,160
the loop has probably continued and done a task++,

746
00:32:59,160 --> 00:33:01,320
and so it's actually getting the wrong value of task.

747
00:33:02,490 --> 00:33:03,930
You've probably seen this by now,

748
00:33:04,320 --> 00:33:06,930
and of course the best way to catch this is

749
00:33:06,930 --> 00:33:08,100
to run the race detector.

750
00:33:08,780 --> 00:33:10,250
And at Google, we even encourage teams

751
00:33:10,250 --> 00:33:13,130
to set up canary servers that run the race detector,

752
00:33:13,220 --> 00:33:16,430
and split off something like 0.1% of their traffic to it,

753
00:33:16,550 --> 00:33:20,330
just to catch you know races that might be in the production system.

754
00:33:20,860 --> 00:33:22,660
And you know finding a bug with the race detector

755
00:33:22,840 --> 00:33:26,140
is way better than having to debug some corruption later.

756
00:33:27,900 --> 00:33:29,880
So there are two ways to fix this race,

757
00:33:30,000 --> 00:33:33,450
the first way is to give the closure an explicit parameter and pass it in,

758
00:33:33,960 --> 00:33:39,210
and Go statement requires a function call specifically for this reason,

759
00:33:39,330 --> 00:33:41,700
so that you can set specific arguments,

760
00:33:41,700 --> 00:33:44,910
that get evaluated in the context of the original goroutine

761
00:33:45,120 --> 00:33:46,920
and then you know copy to the new goroutine,

762
00:33:47,670 --> 00:33:50,430
and so in this case, we can declare a new argument task2,

763
00:33:50,490 --> 00:33:52,020
we can past task to it,

764
00:33:52,670 --> 00:33:53,840
and then inside the goroutine,

765
00:33:53,840 --> 00:33:57,290
task2 is a completely different copy of task,

766
00:33:57,880 --> 00:34:00,970
and I only named it task2 to make it easier to talk about.

767
00:34:01,610 --> 00:34:02,990
But of course there's a bug here,

768
00:34:02,990 --> 00:34:04,550
and the bug is that,

769
00:34:04,580 --> 00:34:07,040
I forgot to update task inside the function

770
00:34:07,040 --> 00:34:09,050
to refer to task2 instead of task,

771
00:34:09,290 --> 00:34:12,110
and so we basically never do that,

772
00:34:12,110 --> 00:34:14,150
what we do instead is,

773
00:34:14,730 --> 00:34:15,990
we just give it the same name,

774
00:34:16,050 --> 00:34:17,580
so that it's impossible now,

775
00:34:17,610 --> 00:34:21,060
for the code inside the goroutine to refer to the wrong copy of task.

776
00:34:22,500 --> 00:34:24,600
That was the first way to fix the race,

777
00:34:24,600 --> 00:34:25,830
there's a second way which is,

778
00:34:25,830 --> 00:34:27,630
you know sort of cryptic the first time you see it,

779
00:34:27,630 --> 00:34:29,340
but it amounts to the same thing,

780
00:34:29,640 --> 00:34:30,330
and that is that,

781
00:34:30,360 --> 00:34:33,810
you just make a copy of the variable inside the loop body.

782
00:34:34,570 --> 00:34:37,840
So every time := happens,

783
00:34:37,840 --> 00:34:39,160
that creates a new variable,

784
00:34:39,370 --> 00:34:41,200
so in the for loop, in the outer for loop,

785
00:34:41,200 --> 00:34:42,670
there's a := at the beginning,

786
00:34:42,670 --> 00:34:44,560
and there's not one the rest of the loop,

787
00:34:44,560 --> 00:34:47,080
so that's all just one variable for the entire loop,

788
00:34:47,290 --> 00:34:49,540
whereas if we put a := inside the body,

789
00:34:49,540 --> 00:34:51,370
every time we run an iteration of the loop,

790
00:34:51,370 --> 00:34:52,690
that's a different variable,

791
00:34:52,960 --> 00:34:57,040
so if if the Go function closure captures that variable,

792
00:34:57,070 --> 00:34:58,420
those will all be distinct.

793
00:34:59,130 --> 00:35:01,080
So we can do the same thing we do task2,

794
00:35:01,080 --> 00:35:03,030
and this time I remember to update the body,

795
00:35:03,210 --> 00:35:05,130
but you know just like before,

796
00:35:05,130 --> 00:35:06,990
it's too easy to forget to update the body,

797
00:35:07,080 --> 00:35:09,420
and so typically write task := task,

798
00:35:09,420 --> 00:35:11,490
which looks kind of magical the first time you see it,

799
00:35:11,490 --> 00:35:12,690
but that's what it's for.

800
00:35:14,300 --> 00:35:16,820
Alright, so I said there were two bugs in the program,

801
00:35:17,150 --> 00:35:19,190
the first one was this race on task,

802
00:35:19,840 --> 00:35:21,820
and the second one is that,

803
00:35:21,970 --> 00:35:25,990
we didn't actually do anything after we've kicked off all the tasks,

804
00:35:25,990 --> 00:35:27,160
we're not waiting for them to be done.

805
00:35:28,560 --> 00:35:33,000
And and in particular, we're kicking them off way too fast,

806
00:35:33,060 --> 00:35:37,050
because you know if there's a million tasks are going to kick off a million goroutines,

807
00:35:37,050 --> 00:35:39,750
and they're all just going to sit waiting for one of the five servers,

808
00:35:39,780 --> 00:35:40,740
which is kind of beneficial.

809
00:35:41,520 --> 00:35:42,990
And so what we can do is

810
00:35:42,990 --> 00:35:48,030
we can pull the fetching of the next idle server up out of the goroutine.

811
00:35:48,820 --> 00:35:51,400
And, we pull it up out of the goroutine,

812
00:35:51,430 --> 00:35:55,540
now we'll only kick off a goroutine when there is an idle server to use.

813
00:35:56,290 --> 00:35:57,550
And then we can kick it off

814
00:35:57,550 --> 00:36:00,160
and and you know use that server and put it back

815
00:36:00,250 --> 00:36:02,770
and using the server and put it back runs concurrently,

816
00:36:02,890 --> 00:36:06,670
but doing the fetch of the idle server inside the loop slows things down,

817
00:36:06,670 --> 00:36:10,240
so that there's only ever now number of servers goroutines running

818
00:36:10,240 --> 00:36:11,710
instead of number of tasks.

819
00:36:12,470 --> 00:36:16,130
And that receive is essentially creating some back pressure to slow down the loop,

820
00:36:16,160 --> 00:36:17,600
so it doesn't get too far ahead.

821
00:36:18,940 --> 00:36:21,400
And then I mentioned we have to wait for the task to finish,

822
00:36:22,030 --> 00:36:24,340
and so we can do that by just at the end of the loop,

823
00:36:24,370 --> 00:36:27,430
going over the list again and pulling all the servers out

824
00:36:27,430 --> 00:36:30,370
and we've pulled the right number of servers out of the idle list,

825
00:36:30,400 --> 00:36:31,390
that means they're all done.

826
00:36:32,020 --> 00:36:34,180
And so that's that's the full program.

827
00:36:35,460 --> 00:36:38,340
You know to me the most important part of this is that,

828
00:36:38,340 --> 00:36:41,610
you still get to write a for loop to iterate over the tasks,

829
00:36:41,640 --> 00:36:42,900
there's lots of other languages

830
00:36:42,900 --> 00:36:45,600
where you have to do this with state machines or some sort of callbacks,

831
00:36:46,210 --> 00:36:49,480
and you don't get the [luxury] of encoding this in the control flow,

832
00:36:49,810 --> 00:36:52,840
and so this is a much cleaner way,

833
00:36:52,840 --> 00:36:54,580
where you can just use a regular loop.

834
00:36:55,380 --> 00:36:58,260
But there are some some changes we could make, some improvements,

835
00:36:58,530 --> 00:37:00,990
and so one improvement is to notice that,

836
00:37:01,630 --> 00:37:05,500
there's only one goroutine that makes requests of a server at a particular time,

837
00:37:05,890 --> 00:37:08,170
so instead of having one goroutine for task,

838
00:37:08,290 --> 00:37:10,300
maybe we should have one goroutine per server,

839
00:37:10,720 --> 00:37:13,960
because there are probably going to be fewer servers than tasks.

840
00:37:14,540 --> 00:37:15,320
And to do that,

841
00:37:15,320 --> 00:37:18,020
we have to change from having a channel of idle servers

842
00:37:18,020 --> 00:37:20,810
to a channel of yet to be done tasks,

843
00:37:21,080 --> 00:37:23,300
and so we've renamed the idle channel to work.

844
00:37:24,020 --> 00:37:25,880
And then we also need a done channel

845
00:37:25,910 --> 00:37:29,570
to count you know how many tasks are done,

846
00:37:29,570 --> 00:37:31,610
so we know when we're completely finished.

847
00:37:32,300 --> 00:37:35,030
And so here there's a new function runTasks,

848
00:37:35,030 --> 00:37:37,220
and that's going to be the per server function,

849
00:37:37,610 --> 00:37:39,800
and we kick off one of them for each server.

850
00:37:40,410 --> 00:37:43,290
And runTasks, its job is just to loop over the work channel,

851
00:37:43,710 --> 00:37:44,820
run the tasks,

852
00:37:44,820 --> 00:37:46,230
and when the server is done,

853
00:37:46,800 --> 00:37:48,090
we send true to done,

854
00:37:48,360 --> 00:37:51,510
and you know the server tells us that you know it's done,

855
00:37:52,020 --> 00:37:54,870
and the server exits when the work channel gets closed,

856
00:37:54,870 --> 00:37:57,060
that's what makes that for loop actually stop.

857
00:37:58,220 --> 00:38:01,010
So then you having kicked off the servers,

858
00:38:01,010 --> 00:38:02,540
we can then just sit there in a loop,

859
00:38:02,570 --> 00:38:05,360
and send each task to the work channel,

860
00:38:05,890 --> 00:38:08,050
close the work channel and say hey there's no more work coming,

861
00:38:08,050 --> 00:38:10,180
all the servers should finish and then and then exit,

862
00:38:10,450 --> 00:38:12,580
and then wait for all the servers to tell us that they're done.

863
00:38:15,320 --> 00:38:17,960
So in the lab, there were a couple complications,

864
00:38:17,960 --> 00:38:20,990
one was that, you might get new servers at any given time,

865
00:38:21,380 --> 00:38:22,880
and so we could change that,

866
00:38:22,880 --> 00:38:25,580
by saying the servers come in on a channel of strings,

867
00:38:26,940 --> 00:38:30,060
and that actually fits pretty well into the current structure,

868
00:38:30,060 --> 00:38:32,070
where when you get a new server,

869
00:38:32,100 --> 00:38:35,790
you just kick off a new runTasks goroutine,

870
00:38:35,880 --> 00:38:37,530
and so the only thing we have to change here is

871
00:38:37,530 --> 00:38:39,930
to put that loop into its own goroutine,

872
00:38:39,930 --> 00:38:41,970
so that while we're sending tasks to servers,

873
00:38:41,970 --> 00:38:43,590
we can still accept new servers

874
00:38:43,590 --> 00:38:45,270
and kickoff the runTasks goroutines.

875
00:38:47,340 --> 00:38:48,240
But now we have this problem,

876
00:38:48,240 --> 00:38:49,440
that we don't really have a good way

877
00:38:49,440 --> 00:38:51,450
to tell when all the servers are done,

878
00:38:51,450 --> 00:38:53,400
because we don't know how many servers there are,

879
00:38:53,670 --> 00:38:58,190
and so we could try to maintain that number as servers come in,

880
00:38:58,190 --> 00:38:59,480
but it's a little tricky,

881
00:38:59,600 --> 00:39:02,900
and instead we can count the number of tasks that have finished,

882
00:39:02,930 --> 00:39:06,560
so we just moved the done sending true done [up align],

883
00:39:06,590 --> 00:39:08,420
so that instead of doing it per server,

884
00:39:08,420 --> 00:39:09,830
we now do it per task,

885
00:39:10,070 --> 00:39:11,210
and at the end of the loop,

886
00:39:11,240 --> 00:39:12,200
at the end of the function,

887
00:39:12,200 --> 00:39:14,480
we just have to wait for the right number of tasks to be done.

888
00:39:15,640 --> 00:39:21,130
And so, so now again we sort of know why these are going to finish,

889
00:39:21,460 --> 00:39:23,530
there's actually a deadlock still,

890
00:39:23,620 --> 00:39:28,510
and that is that if the number of tasks is is too big,

891
00:39:28,540 --> 00:39:29,650
actually I think always,

892
00:39:29,800 --> 00:39:31,150
you'll get a deadlock,

893
00:39:31,180 --> 00:39:32,290
and if you run this,

894
00:39:32,290 --> 00:39:33,430
you know you get this nice thing,

895
00:39:33,430 --> 00:39:35,800
where goroutine tells you like hey your goroutines are stop,

896
00:39:35,800 --> 00:39:37,270
and the problem is that,

897
00:39:37,300 --> 00:39:40,300
we have this runTasks server loop,

898
00:39:40,840 --> 00:39:42,760
and the server loop is trying to say hey I'm done,

899
00:39:43,030 --> 00:39:45,250
and you're trying to say hey like here's some more work,

900
00:39:45,250 --> 00:39:46,690
so if you have more than one task,

901
00:39:46,690 --> 00:39:48,040
you'll run into this deadlock,

902
00:39:48,730 --> 00:39:52,060
where you're trying to send the next task to a server,

903
00:39:52,090 --> 00:39:54,160
I guess it's a few more tasks than servers,

904
00:39:54,340 --> 00:39:55,990
you're trying to send the next task to a server,

905
00:39:55,990 --> 00:39:58,720
and all the servers are trying to say hey I'm done with the previous task,

906
00:39:58,750 --> 00:40:00,910
but you're not there to receive from the done channel.

907
00:40:01,920 --> 00:40:06,210
And so again you know it's really nice that the goroutine just hang around,

908
00:40:06,210 --> 00:40:07,380
and wait for you know to look at them.

909
00:40:07,530 --> 00:40:08,940
And we can fix this,

910
00:40:09,750 --> 00:40:13,530
one way to fix this would be to add a separate loop,

911
00:40:13,530 --> 00:40:14,880
that actually does a select,

912
00:40:14,880 --> 00:40:16,500
that either sends some work

913
00:40:16,530 --> 00:40:19,050
or a counts for some of the work being done,

914
00:40:19,260 --> 00:40:21,030
that's fine,

915
00:40:21,060 --> 00:40:22,500
but a cleaner way to do this,

916
00:40:22,680 --> 00:40:26,250
is to take the work sending loop that task sending loop,

917
00:40:26,250 --> 00:40:28,050
and put it in its own goroutine,

918
00:40:28,170 --> 00:40:30,930
so now it's running independently of the counting loop,

919
00:40:31,050 --> 00:40:33,480
and the counting loop can can run

920
00:40:33,540 --> 00:40:36,980
and you know unblock servers that are done with certain tasks,

921
00:40:36,980 --> 00:40:38,660
while other tasks are still being sent.

922
00:40:41,400 --> 00:40:44,280
But the simplest possible fix for this is

923
00:40:44,280 --> 00:40:46,170
to just make the work channel big enough,

924
00:40:46,200 --> 00:40:48,510
that you're never gonna run out of space.

925
00:40:49,020 --> 00:40:50,340
Because we might decide that,

926
00:40:50,340 --> 00:40:52,680
you know having a goroutine for task is

927
00:40:52,680 --> 00:40:54,540
you know a couple kilobytes for task,

928
00:40:54,660 --> 00:40:58,170
but you know an [extra] int in the channel is 8 bytes,

929
00:40:58,200 --> 00:41:00,420
so probably you can spend 8 bytes per task.

930
00:41:01,360 --> 00:41:02,380
And so if you can,

931
00:41:02,410 --> 00:41:04,060
you just make the work channel big enough,

932
00:41:04,090 --> 00:41:07,450
that you know that all the sends on work are going to never block,

933
00:41:07,450 --> 00:41:11,380
and you'll always get down to the counting loop at the end pretty quickly.

934
00:41:12,740 --> 00:41:16,880
And so doing that actually sets us up pretty well for the other [] in the lab,

935
00:41:16,880 --> 00:41:19,130
which is that sometimes calls can timeout,

936
00:41:19,160 --> 00:41:22,100
and here I've modeled it by the call of returning a false,

937
00:41:22,100 --> 00:41:23,330
so just say it didn't work.

938
00:41:24,560 --> 00:41:28,220
And so you know in runTasks is really easy to see,

939
00:41:28,220 --> 00:41:31,380
like if it's really easy to see,

940
00:41:31,380 --> 00:41:35,090
like if the call fails, then,

941
00:41:35,390 --> 00:41:37,190
sorry if the call succeeds, then you're done,

942
00:41:37,190 --> 00:41:40,070
but if it fails, just put the task back on the work list,

943
00:41:40,190 --> 00:41:42,170
and because it's a queue, not a stack,

944
00:41:42,230 --> 00:41:43,400
putting it back on the work list

945
00:41:43,400 --> 00:41:45,530
is very likely to hand it to some other server.

946
00:41:46,180 --> 00:41:49,630
And so that will probably succeed,

947
00:41:49,660 --> 00:41:50,800
because it's some other server,

948
00:41:50,800 --> 00:41:52,390
and this is all hypothetical,

949
00:41:52,420 --> 00:41:55,660
but it's a really,

950
00:41:55,660 --> 00:41:58,450
you know it fits really well into the structure that we've created.

951
00:42:00,710 --> 00:42:02,660
Alright, and the final change is that,

952
00:42:02,750 --> 00:42:05,090
because the server goroutines are sending on work,

953
00:42:05,180 --> 00:42:07,340
we do have to wait to close it

954
00:42:07,490 --> 00:42:09,020
until we know that they're done sending,

955
00:42:09,600 --> 00:42:13,530
and because again you can't close before they finish sending.

956
00:42:14,370 --> 00:42:16,140
And so we just have to move the close

957
00:42:16,170 --> 00:42:18,690
until after we've counted that all the tasks done,

958
00:42:19,620 --> 00:42:21,540
and sometimes we get to this point,

959
00:42:21,540 --> 00:42:24,630
and people ask why can't you just kill goroutines,

960
00:42:24,630 --> 00:42:25,890
like why not just be able to say,

961
00:42:25,890 --> 00:42:27,990
look hey kill all the server goroutines at this point,

962
00:42:27,990 --> 00:42:29,340
we know that they're not needed anymore.

963
00:42:29,900 --> 00:42:32,270
And the answer is that the goroutines has state

964
00:42:32,270 --> 00:42:34,100
and it's interacting with the rest of the program,

965
00:42:34,100 --> 00:42:35,870
and if it all of a sudden just stops,

966
00:42:36,170 --> 00:42:37,670
it's sort of like it hung, right,

967
00:42:37,670 --> 00:42:39,440
and maybe it was holding a lock,

968
00:42:39,530 --> 00:42:41,600
maybe it was in the middle of some sort of communication

969
00:42:41,600 --> 00:42:43,880
with some other goroutines that was kind of expecting an answer.

970
00:42:44,510 --> 00:42:47,690
So we need to find some way to tear them down more gracefully,

971
00:42:47,690 --> 00:42:49,160
and that's by telling them explicitly,

972
00:42:49,160 --> 00:42:51,230
hey you know you're done, you can go away,

973
00:42:51,230 --> 00:42:53,930
and then they can clean up however they need to clean up.

974
00:42:57,490 --> 00:42:59,170
You know, speaking of cleaning up,

975
00:42:59,170 --> 00:43:00,880
there's there's actually one more thing we have to do,

976
00:43:00,880 --> 00:43:03,940
which is to shut down the loop that's watching for new servers,

977
00:43:04,120 --> 00:43:06,430
and so we do have to put a select in here,

978
00:43:06,460 --> 00:43:11,450
where you know the thing that's waiting for new servers on the server channel,

979
00:43:11,450 --> 00:43:12,470
we have to go tell it,

980
00:43:12,710 --> 00:43:15,170
okay, we're done, just like stop watching new servers,

981
00:43:15,170 --> 00:43:17,390
all the servers are gone.

982
00:43:18,180 --> 00:43:19,980
And we could make this the caller's problem,

983
00:43:19,980 --> 00:43:21,960
but this is actually fairly easy to do.

984
00:43:24,260 --> 00:43:26,780
Alright, so here pattern number 3,

985
00:43:26,780 --> 00:43:30,560
which is a client for a replicated server of service.

986
00:43:31,340 --> 00:43:33,800
So here's the interface that we want to implement,

987
00:43:33,800 --> 00:43:36,110
we have some service that,

988
00:43:36,730 --> 00:43:39,070
we want that is replicated for reliability

989
00:43:39,400 --> 00:43:42,700
and it's okay for a client to talk to any one of these servers,

990
00:43:42,910 --> 00:43:47,830
and so the replicated client is given a list of servers,

991
00:43:47,860 --> 00:43:50,560
the arguments to Init is a list of servers,

992
00:43:50,680 --> 00:43:54,010
and a function that lets you call one of the servers

993
00:43:54,040 --> 00:43:56,260
with a particular argument [] to get a reply.

994
00:43:57,260 --> 00:44:00,140
And then being given that during Init,

995
00:44:00,170 --> 00:44:03,800
the replicated client then provides a call method,

996
00:44:03,950 --> 00:44:06,530
that doesn't tell you what server it's going to use,

997
00:44:06,530 --> 00:44:08,510
it just finds a good server to use,

998
00:44:08,570 --> 00:44:11,780
and it keeps the same, keeps using the same server for as long as it can,

999
00:44:11,780 --> 00:44:13,610
until it finds out that that server is no good.

1000
00:44:15,240 --> 00:44:16,320
So in this situation,

1001
00:44:16,320 --> 00:44:18,660
there's almost no shared state that you need to,

1002
00:44:19,230 --> 00:44:21,780
and so like the only state that persists from one call to next is

1003
00:44:21,780 --> 00:44:23,130
what server did I use last time,

1004
00:44:23,130 --> 00:44:24,630
because I'm going to try to use that again.

1005
00:44:25,500 --> 00:44:27,960
So in this case, that's totally fine for mutex,

1006
00:44:27,960 --> 00:44:29,040
I'm just going to leave it there,

1007
00:44:29,130 --> 00:44:30,930
it's always okay to use mutex,

1008
00:44:30,930 --> 00:44:33,060
if that's the cleanest way to write the code.

1009
00:44:33,660 --> 00:44:36,750
You know, some people get the wrong impression from how much we talk about channels,

1010
00:44:36,750 --> 00:44:39,180
but it's always okay to use mutex, if that's all you need.

1011
00:44:40,880 --> 00:44:44,000
So now we need to implement this replicated Call method,

1012
00:44:44,000 --> 00:44:47,240
whose job is to try sending to lots of different servers,

1013
00:44:47,890 --> 00:44:50,440
but first to try the the original server.

1014
00:44:51,090 --> 00:44:54,510
So, so what does it mean if the try fails,

1015
00:44:54,660 --> 00:44:58,110
well there's no clear way for it to fail above,

1016
00:44:58,110 --> 00:44:59,610
it just always returns a reply,

1017
00:44:59,610 --> 00:45:01,980
and so the only way it can fail is if it's taking too long,

1018
00:45:02,310 --> 00:45:05,100
so we'll assume that if it takes too long, that means it failed.

1019
00:45:06,000 --> 00:45:08,010
So in order to deal with timeouts,

1020
00:45:08,010 --> 00:45:11,130
we have to run that code in the background in a different goroutine.

1021
00:45:11,640 --> 00:45:13,380
So we can do something like this,

1022
00:45:14,110 --> 00:45:16,240
where we set a timeout,

1023
00:45:16,240 --> 00:45:17,440
we create a timer

1024
00:45:18,070 --> 00:45:20,650
and then we use goroutine to send in the background,

1025
00:45:20,950 --> 00:45:22,420
and then at the end, we wait

1026
00:45:22,420 --> 00:45:25,450
and either we get the timeout or we get the actual reply,

1027
00:45:25,540 --> 00:45:27,700
if we get the actual reply, we return it,

1028
00:45:28,120 --> 00:45:30,220
and if we get the timeout, we have to do something,

1029
00:45:30,310 --> 00:45:31,420
we have to figure out what to do.

1030
00:45:32,320 --> 00:45:36,970
It's worth pointing out that you have to call t.Stop,

1031
00:45:37,000 --> 00:45:39,640
because otherwise the timer sits in a timer queue,

1032
00:45:39,640 --> 00:45:41,500
that's going to go off in one second,

1033
00:45:41,830 --> 00:45:43,840
and so you know if this call took a millisecond,

1034
00:45:43,840 --> 00:45:46,150
and you have this timer that's going to sit there for the next second,

1035
00:45:46,180 --> 00:45:47,530
and then you do this on a loop,

1036
00:45:47,680 --> 00:45:50,830
and you get a thousand timers sitting in that that queue,

1037
00:45:50,830 --> 00:45:53,650
before they start actually you know a disappearing.

1038
00:45:53,920 --> 00:45:56,900
And so, this is kind of a work in the API,

1039
00:45:56,900 --> 00:45:59,180
but it's been there forever and we've never fixed it,

1040
00:45:59,720 --> 00:46:02,960
and and so you just have to remember to call stop.

1041
00:46:04,230 --> 00:46:06,030
And then now we have to figure out

1042
00:46:06,030 --> 00:46:07,740
what do we do in the case of the timeout.

1043
00:46:08,880 --> 00:46:10,140
And so in the case of the timeout,

1044
00:46:10,140 --> 00:46:11,970
we're going to need to try a different server,

1045
00:46:12,000 --> 00:46:13,050
so we'll write a loop,

1046
00:46:13,660 --> 00:46:18,880
and we'll start at the id, that id 0 it says,

1047
00:46:18,940 --> 00:46:21,190
and you know if a reply comes in, that's great,

1048
00:46:21,310 --> 00:46:24,550
and otherwise we'll reset the timeout and go around the loop again,

1049
00:46:24,700 --> 00:46:26,650
and try sending to a different server.

1050
00:46:27,010 --> 00:46:30,890
And notice, there's only one done channel in this program,

1051
00:46:31,250 --> 00:46:34,820
and so on the third iteration of the loop, we might be waiting,

1052
00:46:35,150 --> 00:46:37,670
and then finally the first server gives us a reply,

1053
00:46:37,760 --> 00:46:40,010
that's totally fine, we'll take that reply, that's great,

1054
00:46:41,060 --> 00:46:43,730
and so then we'll stop and return it.

1055
00:46:45,120 --> 00:46:47,010
And, but if we get all the way through the loop,

1056
00:46:47,010 --> 00:46:49,590
it means that we've sent the request to every single server,

1057
00:46:49,650 --> 00:46:51,480
in which case, there's no more timeouts,

1058
00:46:51,480 --> 00:46:53,460
we just have to wait for one of them to come back,

1059
00:46:53,700 --> 00:46:56,760
and so that's the [] receive and return at the end.

1060
00:46:58,260 --> 00:47:02,880
And then it's important to notice that the done channel is buffered now,

1061
00:47:02,910 --> 00:47:06,180
so that if you know you sent the result to three different servers,

1062
00:47:06,210 --> 00:47:08,790
you're going to take the first reply and return,

1063
00:47:08,970 --> 00:47:11,640
but the others are going to want to send responses too,

1064
00:47:12,100 --> 00:47:14,140
and we don't want those goroutines just sit around forever,

1065
00:47:14,140 --> 00:47:16,210
trying to send to a channel that we're not reading from,

1066
00:47:16,480 --> 00:47:17,710
so we make the buffer big enough,

1067
00:47:17,710 --> 00:47:20,380
that they can send into the buffer and then go away,

1068
00:47:20,380 --> 00:47:22,000
and the channel just gets garbage collected.

1069
00:47:23,930 --> 00:47:25,340
We've got a question in the chat,

1070
00:47:25,340 --> 00:47:28,580
that says,

1071
00:47:28,580 --> 00:47:30,590
why can't the timer just be garbage collected

1072
00:47:30,590 --> 00:47:31,730
when nobody's referencing it

1073
00:47:31,730 --> 00:47:33,710
instead of having to wait when it goes off,

1074
00:47:33,710 --> 00:47:35,360
when you said that you have multiple waiting,

1075
00:47:35,360 --> 00:47:36,860
if it goes off in one millisecond.

1076
00:47:37,250 --> 00:47:41,000
The problem is that timer is referenced by the runtime,

1077
00:47:41,030 --> 00:47:43,040
it's in the list of active timers,

1078
00:47:43,600 --> 00:47:46,360
and so calling stop takes it out of the list of active timers.

1079
00:47:46,840 --> 00:47:49,990
And and so like that's arguably kind of a work in that,

1080
00:47:50,020 --> 00:47:52,030
like in the specific case of a timer,

1081
00:47:52,030 --> 00:47:55,750
that's like only gonna ever get used in this channel way,

1082
00:47:55,750 --> 00:47:58,990
like we could have special case that by having the channel,

1083
00:47:58,990 --> 00:48:01,450
because inside the timer is this t.C channel, right,

1084
00:48:01,720 --> 00:48:04,870
so we could have like a different kind of channel implementation,

1085
00:48:05,020 --> 00:48:07,810
that inside had a bit that said hey I'm a timer channel, right,

1086
00:48:08,080 --> 00:48:12,250
and and and then like the select on it would like notice to wait,

1087
00:48:12,550 --> 00:48:14,890
but if you just let go of it, it would just disappear.

1088
00:48:15,360 --> 00:48:18,480
We've kind of thought about doing that for a while, but we never did,

1089
00:48:18,570 --> 00:48:20,280
so this is like the state of Go.

1090
00:48:20,810 --> 00:48:23,270
But but you know the garbage collector can't distinguish

1091
00:48:23,270 --> 00:48:27,500
between the reference inside the runtime and the reference at the rest of the program,

1092
00:48:27,500 --> 00:48:28,730
it's all just references,

1093
00:48:29,060 --> 00:48:32,600
and so until we special case that channel in some way,

1094
00:48:32,600 --> 00:48:34,610
we can't actually get rid of that.

1095
00:48:37,540 --> 00:48:38,050
Thank you.

1096
00:48:38,290 --> 00:48:38,980
Sure.

1097
00:48:39,070 --> 00:48:42,010
So, so the only thing we have left is to

1098
00:48:42,160 --> 00:48:46,570
have this preference where we try to use the same id that we did the previous time.

1099
00:48:47,390 --> 00:48:48,800
And so to do that preference,

1100
00:48:50,550 --> 00:48:54,900
we you know had the server id coming back in the reply anyway in the result channel,

1101
00:48:55,910 --> 00:48:58,100
and so you know we do the same sort of loop,

1102
00:48:58,100 --> 00:49:01,190
but we loop over an offset from the actual id, we're going to use,

1103
00:49:01,190 --> 00:49:02,930
which is the preferred one,

1104
00:49:03,260 --> 00:49:05,030
and then we get an answer,

1105
00:49:05,090 --> 00:49:08,060
we set the preferred one to where we got the answer from

1106
00:49:08,090 --> 00:49:09,050
and then we reply,

1107
00:49:09,500 --> 00:49:11,420
and you'll notice that I used a goto statement,

1108
00:49:11,510 --> 00:49:13,730
that's okay if you need to goto, it's fine,

1109
00:49:14,480 --> 00:49:16,520
it's not sort of there's no [zealotry] here.

1110
00:49:18,070 --> 00:49:20,680
Alright, so, the fourth one

1111
00:49:21,010 --> 00:49:25,060
and then we'll do some questions is protocol multiplexer.

1112
00:49:25,810 --> 00:49:29,470
And this is the logic of core of any RPC system,

1113
00:49:29,650 --> 00:49:31,210
and this comes up a lot,

1114
00:49:31,210 --> 00:49:33,160
I feel like I wrote a lot of these in grad school

1115
00:49:33,160 --> 00:49:34,270
and sort of years after that.

1116
00:49:35,760 --> 00:49:39,360
And so the basic API of a protocol multiplexer is that,

1117
00:49:39,480 --> 00:49:41,130
it's in from some Service,

1118
00:49:41,130 --> 00:49:42,900
which we're going to pass to the Init method,

1119
00:49:43,600 --> 00:49:45,790
and then having been initialized with the service,

1120
00:49:45,910 --> 00:49:48,940
you can call and you can call Call

1121
00:49:48,970 --> 00:49:51,220
and give a message a request message,

1122
00:49:51,220 --> 00:49:53,740
and then it'll give you back the reply message at some point,

1123
00:49:54,100 --> 00:49:57,100
and the things it needs from the service to do multiflexing,

1124
00:49:57,740 --> 00:49:58,940
is that given a message,

1125
00:49:58,970 --> 00:50:02,660
it has to be able to pull out the tag that uniquely identifies the message,

1126
00:50:02,960 --> 00:50:04,970
and will identify the reply,

1127
00:50:04,970 --> 00:50:07,100
because it will come back in with a matching tag,

1128
00:50:07,430 --> 00:50:11,330
and then it needs to be able to send a message out and to receive a message,

1129
00:50:11,330 --> 00:50:15,680
but the send and receive are arbitrary messages are not matched.

1130
00:50:16,680 --> 00:50:19,080
It's the multiplexer job to actually match them.

1131
00:50:21,020 --> 00:50:23,150
So, to start with,

1132
00:50:23,180 --> 00:50:25,820
we'll have a goroutine that's in charge of calling send,

1133
00:50:25,940 --> 00:50:28,130
and another goroutine that's in charge of calling receive,

1134
00:50:28,130 --> 00:50:29,480
both in just a simple loop.

1135
00:50:30,110 --> 00:50:32,930
And so to initialize the service, we set up the structure

1136
00:50:32,930 --> 00:50:35,540
and it will kick off the send loop and the receive loop

1137
00:50:35,660 --> 00:50:38,480
and then we also have a map of pending requests,

1138
00:50:38,720 --> 00:50:43,220
and the map maps from the tag, that we saw the id number in the messages

1139
00:50:43,220 --> 00:50:46,070
to a channel where the reply is supposed to go.

1140
00:50:47,960 --> 00:50:49,700
The send loop is fairly simple,

1141
00:50:49,700 --> 00:50:51,800
you just range over the things that need to be sent

1142
00:50:51,800 --> 00:50:52,550
and you send them,

1143
00:50:52,640 --> 00:50:55,490
and this just has the effect of serializing the calls to send,

1144
00:50:55,490 --> 00:50:58,550
because we're not going to force the service implementation

1145
00:50:58,790 --> 00:51:02,510
to deal with us sending you know from multiple goroutines at once,

1146
00:51:02,510 --> 00:51:03,410
we're serializing it,

1147
00:51:03,410 --> 00:51:07,160
so that it can just be thinking of you sending one packet at a time.

1148
00:51:09,200 --> 00:51:12,440
And then the receive loop is a little bit more complicated,

1149
00:51:12,440 --> 00:51:15,680
it pulls a receive, pulls a reply off the service,

1150
00:51:15,680 --> 00:51:18,770
and again they're serialized, only reading one at a time,

1151
00:51:19,040 --> 00:51:21,230
and then it pulls the tag out of the reply,

1152
00:51:22,040 --> 00:51:25,100
and then it says oh I need to find the channel to send this to,

1153
00:51:25,520 --> 00:51:27,710
so it pulls the channel out of the pending map,

1154
00:51:27,980 --> 00:51:29,540
it takes it out of the pending map,

1155
00:51:29,540 --> 00:51:31,910
so that you know if we accidentally get another one,

1156
00:51:31,910 --> 00:51:32,900
we won't try to send it,

1157
00:51:33,640 --> 00:51:35,050
and then it sends the reply.

1158
00:51:36,190 --> 00:51:37,960
And then to do a Call,

1159
00:51:38,110 --> 00:51:40,210
you just have to set yourself up in the map,

1160
00:51:40,210 --> 00:51:42,460
and then hand it to send and wait for the reply,

1161
00:51:42,490 --> 00:51:44,170
so we start off,

1162
00:51:44,170 --> 00:51:45,220
we get the tag out,

1163
00:51:45,640 --> 00:51:47,410
we make our own done channel,

1164
00:51:47,680 --> 00:51:49,660
we insert the tag into the map,

1165
00:51:49,690 --> 00:51:51,460
and first checking for bugs,

1166
00:51:51,790 --> 00:51:55,520
and then we send the argument message to send,

1167
00:51:55,640 --> 00:51:57,650
and then we wait for the reply to come in on done.

1168
00:51:57,710 --> 00:51:58,910
It's very very simple,

1169
00:51:58,910 --> 00:52:01,340
I mean like I used to write these sort of things in C

1170
00:52:01,340 --> 00:52:03,170
and it was it was much much worse.

1171
00:52:04,900 --> 00:52:07,810
So that was all the patterns that I wanted to show,

1172
00:52:08,140 --> 00:52:10,870
and I hope that those end up being useful for you

1173
00:52:10,870 --> 00:52:13,060
in whatever future program yo're writing,

1174
00:52:13,420 --> 00:52:17,190
and I hope that they're you know just sort of good ideas,

1175
00:52:17,190 --> 00:52:18,750
even in non Go programs,

1176
00:52:18,750 --> 00:52:20,100
but that you know thinking about them,

1177
00:52:20,100 --> 00:52:22,590
and Go can help you when you go to do other things as well.

1178
00:52:23,130 --> 00:52:24,720
So I'm going to put them all back up.

1179
00:52:24,900 --> 00:52:27,600
And then I have some questions that Frans sent,

1180
00:52:27,600 --> 00:52:29,010
that were from all of you.

1181
00:52:30,350 --> 00:52:35,030
And we'll probably have some time for questions from the chat as well.

1182
00:52:35,640 --> 00:52:38,280
I have no idea in Zoom where the chat window is,

1183
00:52:38,280 --> 00:52:41,760
so when we get to that, people can just speak up,

1184
00:52:41,760 --> 00:52:45,450
I don't use zoom on a daily basis, unfortunately.

1185
00:52:46,150 --> 00:52:49,660
So, and and normally I know how to use Zoom regularly,

1186
00:52:49,660 --> 00:52:51,040
but with with the presentation,

1187
00:52:51,040 --> 00:52:52,750
like Zoom in this minimized thing,

1188
00:52:52,750 --> 00:52:54,310
that doesn't have half the things I'm used to.

1189
00:52:54,910 --> 00:52:57,790
Anyway, someone asked how long Go took?

1190
00:52:57,970 --> 00:53:00,880
And so far it's been about thirteen and a half years,

1191
00:53:01,180 --> 00:53:04,510
we started discussions in late September 2007,

1192
00:53:04,660 --> 00:53:06,550
I joined full time in August 2008,

1193
00:53:06,550 --> 00:53:07,930
when I finished at MIT,

1194
00:53:08,530 --> 00:53:11,800
we did the initial open-source launch November 2009,

1195
00:53:12,380 --> 00:53:17,750
we released Go 1, that sort of first stable version in October 2011,

1196
00:53:17,780 --> 00:53:19,550
sorry the plan was October 2011,

1197
00:53:19,550 --> 00:53:21,350
Go 1 itself was March 2012,

1198
00:53:22,180 --> 00:53:25,210
and then we've just been on a regular schedule since then,

1199
00:53:25,450 --> 00:53:28,540
the next major change of course is going to be Generics,

1200
00:53:28,840 --> 00:53:32,740
and adding Generics and that's probably gonna be Go 1.18,

1201
00:53:32,740 --> 00:53:34,750
which is going to be next in February.

1202
00:53:37,260 --> 00:53:41,310
Someone asks, you know how big a team does it take to build a language like Go?

1203
00:53:41,310 --> 00:53:44,850
And you know for those first two years, there were just five of us,

1204
00:53:45,090 --> 00:53:49,200
and that was enough to get us to you know something that we release,

1205
00:53:49,200 --> 00:53:51,120
that actually could run in production,

1206
00:53:51,710 --> 00:53:53,060
but it was fairly primitive,

1207
00:53:53,090 --> 00:53:55,550
you know it was a good prototype,

1208
00:53:55,550 --> 00:53:56,930
it was a solid working prototype,

1209
00:53:56,930 --> 00:53:59,120
but it wasn't like what it is today,

1210
00:53:59,660 --> 00:54:01,490
and over time we've expanded a fair amount,

1211
00:54:01,490 --> 00:54:03,500
now we're up to something like 50 people,

1212
00:54:03,650 --> 00:54:07,070
employed directly, employed by Google to work directly on Go,

1213
00:54:07,950 --> 00:54:10,140
and then there's tons of open source contributors,

1214
00:54:10,140 --> 00:54:12,030
I mean there's literal cast of thousands,

1215
00:54:12,030 --> 00:54:13,920
that have helped us over the last 13 years,

1216
00:54:14,190 --> 00:54:16,050
and there's absolutely no way we could have done it,

1217
00:54:16,050 --> 00:54:17,100
even with 50 people,

1218
00:54:17,220 --> 00:54:20,310
without all the different contributions from the outside.

1219
00:54:22,800 --> 00:54:28,020
Someone asked about design priorities and motivations.

1220
00:54:28,320 --> 00:54:30,930
And you know we built it for us right,

1221
00:54:30,930 --> 00:54:33,870
the priority was to build something that was going to help Google,

1222
00:54:33,870 --> 00:54:36,000
and it just turned out that Google was a couple years ahead,

1223
00:54:36,000 --> 00:54:37,440
we were just in a really lucky spot,

1224
00:54:37,440 --> 00:54:39,900
where Google was a couple years ahead of the rest of the industry,

1225
00:54:40,080 --> 00:54:42,870
on having to write distributed systems right now,

1226
00:54:42,870 --> 00:54:44,910
everyone using cloud software

1227
00:54:44,910 --> 00:54:47,130
is writing programs that talk to other programs

1228
00:54:47,130 --> 00:54:48,030
and sending messages

1229
00:54:48,030 --> 00:54:51,900
and you know there's hardly any single machine programs anymore,

1230
00:54:52,610 --> 00:54:56,060
and so you know we sort of [] into at some level,

1231
00:54:56,180 --> 00:54:58,220
you know building the language,

1232
00:54:58,220 --> 00:55:00,560
that we the rest of the world needed a couple years later.

1233
00:55:01,740 --> 00:55:04,290
And then the other thing that was really a priority is

1234
00:55:04,290 --> 00:55:06,750
making it work for large numbers of programmers,

1235
00:55:07,140 --> 00:55:11,280
and because Google had a very large number of programmers working in one codebase,

1236
00:55:11,520 --> 00:55:13,110
and now we have open source,

1237
00:55:13,110 --> 00:55:15,300
where you know even if you're a small team,

1238
00:55:15,330 --> 00:55:18,480
you're depending on code that's written by a ton of other people usually,

1239
00:55:19,110 --> 00:55:21,480
and so a lot of the issues that come up

1240
00:55:21,510 --> 00:55:24,450
with just having many programmers still come up in that context,

1241
00:55:24,840 --> 00:55:27,270
so those were really the things we were trying to solve.

1242
00:55:28,090 --> 00:55:30,160
And you know for all of these things,

1243
00:55:30,160 --> 00:55:31,570
we took a long time,

1244
00:55:31,660 --> 00:55:35,320
before we were willing to actually commit to putting something in the language,

1245
00:55:35,320 --> 00:55:38,620
like everyone basically had to agree in the core original group,

1246
00:55:38,860 --> 00:55:40,780
and and so that meant that,

1247
00:55:41,290 --> 00:55:44,500
it took us a while to get the pieces exactly the way we wanted them,

1248
00:55:44,500 --> 00:55:45,760
but once we got them there,

1249
00:55:45,760 --> 00:55:49,360
they've actually been very stable and solid and really nice

1250
00:55:49,360 --> 00:55:50,590
and then work together well.

1251
00:55:50,980 --> 00:55:53,500
And the same thing is kind of happening with Generics now,

1252
00:55:53,740 --> 00:55:55,240
where we actually feel,

1253
00:55:55,270 --> 00:55:57,340
I feel personally really good about Generics,

1254
00:55:57,340 --> 00:56:00,100
I feel like it feels like the rest of Go,

1255
00:56:00,100 --> 00:56:02,890
and that just wasn't the case for the proposals that we had,

1256
00:56:02,920 --> 00:56:04,480
you know even a couple years ago,

1257
00:56:04,540 --> 00:56:06,490
much less the early ones.

1258
00:56:08,860 --> 00:56:12,640
Someone said they really liked defer, which is unique to language.

1259
00:56:12,640 --> 00:56:14,200
And I do too, thank you.

1260
00:56:14,590 --> 00:56:16,390
But I wanted to point out that,

1261
00:56:16,390 --> 00:56:19,300
we did absolutely you know create defer for Go,

1262
00:56:19,390 --> 00:56:21,430
but Swift has adopted it,

1263
00:56:21,430 --> 00:56:24,220
and I think there's a proposal for C++ to adopt it as well,

1264
00:56:24,220 --> 00:56:26,830
so you know hopefully it kind of moves out a little bit.

1265
00:56:29,280 --> 00:56:33,780
There was a question about Go is using capitalization for exporting.

1266
00:56:34,170 --> 00:56:36,450
And which I know is like something that,

1267
00:56:36,750 --> 00:56:39,270
you know sort of is [jarring] when you first see it,

1268
00:56:39,720 --> 00:56:41,130
and the story behind that is that,

1269
00:56:41,130 --> 00:56:42,660
well, we needed something

1270
00:56:42,960 --> 00:56:44,310
and we knew that we would need something,

1271
00:56:44,310 --> 00:56:45,540
but at the beginning, we just said,

1272
00:56:45,540 --> 00:56:47,580
look everything export, everything publicly visible,

1273
00:56:47,580 --> 00:56:48,690
we'll deal with it later,

1274
00:56:49,520 --> 00:56:50,450
and after about a year,

1275
00:56:50,450 --> 00:56:52,370
it was clear that we needed some way to

1276
00:56:52,760 --> 00:56:55,580
you know let programmers hide things from other programmers,

1277
00:56:55,970 --> 00:57:00,200
and you know C++ has this public: and private:,

1278
00:57:00,380 --> 00:57:01,880
and in a large struct,

1279
00:57:02,060 --> 00:57:03,380
it's actually really annoying,

1280
00:57:03,380 --> 00:57:05,840
that you're looking, you're looking at definitions,

1281
00:57:05,840 --> 00:57:07,310
and you have to scroll backwards

1282
00:57:07,310 --> 00:57:10,670
and try to find where the most recent public: or private: was,

1283
00:57:10,940 --> 00:57:12,200
and if it's really big,

1284
00:57:12,200 --> 00:57:13,250
it can be hard to find one,

1285
00:57:13,250 --> 00:57:16,550
and so it's hard to tell whether a particular definition is public or private.

1286
00:57:17,220 --> 00:57:20,430
And then in Java, of course it's at the beginning of every single field,

1287
00:57:20,820 --> 00:57:23,760
and that seemed kind of excessive too, just too much typing.

1288
00:57:24,900 --> 00:57:26,130
And so we looked around some more,

1289
00:57:26,130 --> 00:57:27,690
and and someone pointed out to us,

1290
00:57:27,690 --> 00:57:29,310
that Python has this convention,

1291
00:57:29,310 --> 00:57:31,860
where you put an underscore in front to make something hidden

1292
00:57:32,370 --> 00:57:33,690
and that seemed interesting,

1293
00:57:33,750 --> 00:57:36,600
but you probably don't want the default to be not hidden,

1294
00:57:36,630 --> 00:57:38,010
you want the default to be hidden.

1295
00:57:38,580 --> 00:57:42,480
And then we thought about well we could put a plus in front of names,

1296
00:57:44,510 --> 00:57:45,800
and then someone suggested,

1297
00:57:45,800 --> 00:57:48,110
well what about uppercase could be exported,

1298
00:57:48,380 --> 00:57:50,870
and it seemed like a dumb terrible idea,

1299
00:57:51,050 --> 00:57:51,800
it really did,

1300
00:57:52,580 --> 00:57:54,020
but as you think about it,

1301
00:57:54,020 --> 00:57:55,700
like I really didn't like this idea,

1302
00:57:56,060 --> 00:57:59,870
and I have a very clear memory of sitting in the room,

1303
00:57:59,870 --> 00:58:02,690
and what I was [staring] at as we discussed this,

1304
00:58:02,690 --> 00:58:04,400
but I had no logical argument against it,

1305
00:58:04,430 --> 00:58:06,050
and it turned out, it was fantastic,

1306
00:58:06,200 --> 00:58:09,650
it was like it seemed bad just like aesthetically,

1307
00:58:09,680 --> 00:58:12,380
but it is one of my favorite things now about Go,

1308
00:58:12,380 --> 00:58:14,330
that when you look at a use of something,

1309
00:58:14,360 --> 00:58:15,770
you can see immediately,

1310
00:58:15,770 --> 00:58:16,880
you get that bit of,

1311
00:58:17,000 --> 00:58:19,790
is this something that other people can access or not,

1312
00:58:19,910 --> 00:58:20,660
at every use,

1313
00:58:20,660 --> 00:58:22,790
because if you see code calling a function

1314
00:58:22,790 --> 00:58:24,530
to do you know whatever it is that it does,

1315
00:58:24,530 --> 00:58:27,470
you think, oh wow can other people do that,

1316
00:58:27,800 --> 00:58:29,930
and you know your brain sort of takes care of that,

1317
00:58:29,930 --> 00:58:31,040
but now I go to C++

1318
00:58:31,040 --> 00:58:32,330
and I see calls like that,

1319
00:58:32,600 --> 00:58:34,340
and I get really worried about,

1320
00:58:34,340 --> 00:58:36,950
is that, is that something other classes can get at,

1321
00:58:37,370 --> 00:58:41,390
and having that bit actually turns out to be really useful for reading code.

1322
00:58:42,560 --> 00:58:44,570
A couple people ask about Generics.

1323
00:58:44,570 --> 00:58:45,410
If you don't know,

1324
00:58:45,590 --> 00:58:47,600
we have an active proposal for Generics,

1325
00:58:47,600 --> 00:58:49,400
we're actively working on implementing it,

1326
00:58:49,640 --> 00:58:52,910
we hope that the released later in the year,

1327
00:58:53,120 --> 00:58:53,930
towards the end of the year,

1328
00:58:53,930 --> 00:58:56,660
we'll actually have a full version of Generics,

1329
00:58:56,660 --> 00:58:58,100
you can, you can actually use,

1330
00:58:58,280 --> 00:59:01,220
the that'll be a preview release,

1331
00:59:01,250 --> 00:59:04,670
the real release that we hope it will be in is Go 1.18,

1332
00:59:04,670 --> 00:59:06,050
which is February of next year,

1333
00:59:06,050 --> 00:59:07,580
so maybe next class,

1334
00:59:07,610 --> 00:59:09,200
we'll actually get to use Generics,

1335
00:59:09,200 --> 00:59:09,590
we'll see.

1336
00:59:10,910 --> 00:59:13,580
But I'm certainly looking forward to having a generic min and max,

1337
00:59:13,580 --> 00:59:15,050
the reason we don't have those is that,

1338
00:59:15,320 --> 00:59:17,030
we have to pick which type they were for

1339
00:59:17,030 --> 00:59:18,440
or you have a whole suite of them,

1340
00:59:18,440 --> 00:59:19,430
and it just seems silly,

1341
00:59:19,430 --> 00:59:21,110
it seems like we should wait for Generics.

1342
00:59:22,540 --> 00:59:25,750
Someone asked, is there any area of programming,

1343
00:59:25,750 --> 00:59:29,140
where Go may not be the best language, but it's still used?

1344
00:59:29,380 --> 00:59:31,300
And and the answer is absolutely,

1345
00:59:31,300 --> 00:59:33,640
like that happens all the time with every language.

1346
00:59:34,920 --> 00:59:37,860
I think Go is actually really good all-around language,

1347
00:59:37,890 --> 00:59:41,160
but you know you might use it for something that's not perfect for,

1348
00:59:41,730 --> 00:59:43,980
just because the rest of your program is written in Go,

1349
00:59:43,980 --> 00:59:46,260
and you want to inter operate with the rest of the program,

1350
00:59:46,260 --> 00:59:49,980
so there's this website called the On-Line Encyclopedia of Integer Sequences,

1351
00:59:50,310 --> 00:59:51,180
it's a search engine,

1352
00:59:51,180 --> 00:59:52,980
you type in like 2 3 5 7 11,

1353
00:59:52,980 --> 00:59:54,300
and it tells you those are the primes,

1354
00:59:55,410 --> 00:59:57,870
and it turns out that, the backend for that is all written in Go,

1355
00:59:58,510 --> 01:00:00,310
and if you type in a sequence,

1356
01:00:00,310 --> 01:00:03,370
it does you know it actually does some pretty sophisticated math on the numbers,

1357
01:00:03,370 --> 01:00:04,930
all with big numbers and things like that,

1358
01:00:05,050 --> 01:00:06,550
and all of that is written in Go too,

1359
01:00:06,550 --> 01:00:10,330
because it was too annoying to shell out to make [] mathematic

1360
01:00:10,330 --> 01:00:12,070
and sort of do that cross language thing,

1361
01:00:12,070 --> 01:00:14,440
even though you'd much rather implement in those languages,

1362
01:00:14,620 --> 01:00:18,430
so you know you run into those sorts of compromises all the time and that's fine.

1363
01:00:22,520 --> 01:00:26,300
Someone asked about, Go is supposed to be simple,

1364
01:00:26,330 --> 01:00:29,420
so that's why there's no Generics and no sets,

1365
01:00:29,420 --> 01:00:31,100
but isn't it also for software developers

1366
01:00:31,100 --> 01:00:32,960
and don't software developers need all this stuff

1367
01:00:32,960 --> 01:00:34,760
and it's silly to reconstruct it.

1368
01:00:35,400 --> 01:00:38,160
And I think that it's true that there's someone intention,

1369
01:00:38,160 --> 01:00:42,570
but but simplicity in the sense of leaving things out was not ever the goal,

1370
01:00:42,840 --> 01:00:44,460
so like for sets,

1371
01:00:44,790 --> 01:00:47,040
it just seemed like maps are so close to sets,

1372
01:00:47,040 --> 01:00:50,370
you just have a map where the value is empty or a boolean,

1373
01:00:50,610 --> 01:00:51,870
that's a set,

1374
01:00:52,050 --> 01:00:52,830
and for Generics,

1375
01:00:52,830 --> 01:00:56,940
like you have to remember that when we started Go in 2007,

1376
01:00:57,000 --> 01:01:02,520
Java was like just finishing a true fiasco of rollout of Generics,

1377
01:01:02,820 --> 01:01:04,740
and so like we were really scared of that,

1378
01:01:04,740 --> 01:01:06,570
we knew that if we just tried to do it,

1379
01:01:06,930 --> 01:01:09,000
you know we would get it wrong,

1380
01:01:09,060 --> 01:01:12,030
and we knew that we could write a lot of useful programs without Generics.

1381
01:01:12,200 --> 01:01:13,340
And so that was what we did.

1382
01:01:14,110 --> 01:01:16,210
And then we came back to it,

1383
01:01:16,210 --> 01:01:20,140
when we felt like okay we've spent enough time writing other programs,

1384
01:01:20,140 --> 01:01:23,800
we kind of know a lot more about what we need from from generics for Go,

1385
01:01:24,010 --> 01:01:26,860
and we can take the time to talk to real experts,

1386
01:01:26,980 --> 01:01:31,240
and I think that you know it would have been nice to have them five or ten years ago,

1387
01:01:31,240 --> 01:01:34,720
but we wouldn't have had the really nice one that we're going to have now,

1388
01:01:34,900 --> 01:01:36,610
so I think it was probably the right decision.

1389
01:01:40,030 --> 01:01:41,680
So there was a question

1390
01:01:41,680 --> 01:01:44,650
about goroutines and the relation to the Plan 9 thread library,

1391
01:01:44,650 --> 01:01:46,570
which was all cooperatively scheduled,

1392
01:01:47,020 --> 01:01:49,180
and whether goroutines were ever properly scheduled

1393
01:01:49,180 --> 01:01:50,800
and if that caused problems?

1394
01:01:51,430 --> 01:01:52,720
And it is absolutely the case,

1395
01:01:52,720 --> 01:01:56,260
that like Go and the goroutine runtime

1396
01:01:56,260 --> 01:01:59,410
were sort of inspired by previous experience on Plan 9,

1397
01:01:59,650 --> 01:02:02,050
there was actually a different language called Alef

1398
01:02:02,080 --> 01:02:03,520
on an early version Plan 9,

1399
01:02:03,670 --> 01:02:07,480
that was compiled, it had channels, it had select,

1400
01:02:07,570 --> 01:02:09,550
it had things we called tasks,

1401
01:02:09,550 --> 01:02:10,870
which were a little bit like goroutines,

1402
01:02:10,870 --> 01:02:12,280
but it didn't have a garbage collector

1403
01:02:12,280 --> 01:02:14,710
and that made things really annoying in a lot of cases,

1404
01:02:14,920 --> 01:02:17,140
and also the way that tasks work,

1405
01:02:17,140 --> 01:02:18,940
they were tied to a specific thread,

1406
01:02:18,940 --> 01:02:21,370
so you might have three tasks in one thread

1407
01:02:21,430 --> 01:02:23,080
and two tasks in another thread,

1408
01:02:23,600 --> 01:02:25,610
and in the three tasks in the first thread,

1409
01:02:25,640 --> 01:02:27,680
they only one ever ran at a time,

1410
01:02:27,680 --> 01:02:30,350
and they could only rescheduled during a channel operation,

1411
01:02:30,500 --> 01:02:31,850
and so you would write code,

1412
01:02:31,850 --> 01:02:34,940
where those three tasks were all operating on the same data structure,

1413
01:02:35,060 --> 01:02:36,350
and you just knew,

1414
01:02:36,380 --> 01:02:38,120
because it was in your head when you wrote it,

1415
01:02:38,770 --> 01:02:40,030
that you know it was okay,

1416
01:02:40,030 --> 01:02:43,150
for these two different tasks to be scribbling over the same data structure,

1417
01:02:43,150 --> 01:02:45,010
because they could never be running at the same time.

1418
01:02:45,640 --> 01:02:47,170
And, meanwhile in the other thread,

1419
01:02:47,170 --> 01:02:50,320
you've got the same situation going on with different data and different tasks,

1420
01:02:50,650 --> 01:02:52,780
and then you come back to the same program like six months later,

1421
01:02:52,780 --> 01:02:56,500
you totally forget which task could write to different pieces of data,

1422
01:02:56,650 --> 01:02:58,600
and I'm sure that we had tons of races,

1423
01:02:58,600 --> 01:03:01,450
I mean it was just it was a nice model for small programs,

1424
01:03:01,450 --> 01:03:04,870
and it was a terrible model for programming over a long period of time

1425
01:03:04,870 --> 01:03:07,330
or having a big program that other people had to work on.

1426
01:03:07,960 --> 01:03:09,550
So, so that was never the model for Go,

1427
01:03:09,550 --> 01:03:11,200
the model for Go was always,

1428
01:03:11,440 --> 01:03:13,510
it's good to have these lightweight goroutines,

1429
01:03:13,510 --> 01:03:15,820
but they're gonna all be running independently,

1430
01:03:15,820 --> 01:03:17,860
and if they're going to share anything they need to use locks,

1431
01:03:17,860 --> 01:03:21,820
or they need to use channels to communicate and coordinate explicitly.

1432
01:03:22,750 --> 01:03:27,010
And that that has definitely scaled a lot better than any of the plain line stuff ever did,

1433
01:03:27,550 --> 01:03:32,070
you know sometimes people hear that goroutines are cooperatively scheduled,

1434
01:03:32,070 --> 01:03:34,380
and they they think you know something more like that,

1435
01:03:34,560 --> 01:03:37,590
it's it's true that early on,

1436
01:03:37,680 --> 01:03:40,800
the goroutines were not as preemptively scheduled as you would like,

1437
01:03:41,040 --> 01:03:43,020
so in the very very early days,

1438
01:03:43,020 --> 01:03:45,480
the only preemption points when you called into the runtime,

1439
01:03:45,660 --> 01:03:46,980
shortly after that,

1440
01:03:47,010 --> 01:03:49,350
the preemption points where any time you entered a function,

1441
01:03:50,640 --> 01:03:53,430
but if you were in a tight loop for a very long time,

1442
01:03:53,430 --> 01:03:54,540
that would never preempt

1443
01:03:54,540 --> 01:03:56,550
and that would cause garbage collector delays,

1444
01:03:56,550 --> 01:03:58,800
because the garbage collector need to stop all the goroutines,

1445
01:03:58,950 --> 01:04:00,930
and there be some goroutines stuck in a tight loop,

1446
01:04:00,930 --> 01:04:02,550
and it would take forever to finish the loop,

1447
01:04:03,100 --> 01:04:05,680
and so actually in the last couple releases,

1448
01:04:05,680 --> 01:04:06,580
we've finally started,

1449
01:04:06,580 --> 01:04:07,120
we figured out,

1450
01:04:07,120 --> 01:04:11,050
how to get a unique signals to deliver to threads in just the right way,

1451
01:04:11,170 --> 01:04:13,630
so that and we can have the right bookkeeping

1452
01:04:13,630 --> 01:04:16,180
to actually be able to use that as a preemption mechanism.

1453
01:04:16,700 --> 01:04:18,170
And so now things are,

1454
01:04:18,350 --> 01:04:22,340
I think the preemption delays for garbage collection are actually done finally,

1455
01:04:22,370 --> 01:04:26,630
but from the start, the model has been that you know they're running preemptively,

1456
01:04:26,690 --> 01:04:29,030
and they don't get control over when they get preempted.

1457
01:04:30,980 --> 01:04:32,660
As a sort of following question,

1458
01:04:32,660 --> 01:04:33,770
someone else asked,

1459
01:04:33,950 --> 01:04:35,630
where they can look in the source tree

1460
01:04:35,630 --> 01:04:39,350
to learn more about goroutines and goroutine scheduler.

1461
01:04:39,620 --> 01:04:40,610
And the answer is that,

1462
01:04:40,610 --> 01:04:42,590
this is basically a little operating system,

1463
01:04:42,620 --> 01:04:45,890
like it's a little operating system that sits on top of the other operating system,

1464
01:04:45,890 --> 01:04:48,590
instead of on top of CPUs.

1465
01:04:49,100 --> 01:04:51,230
And so the first thing to do is take 6.828,

1466
01:04:51,230 --> 01:04:55,880
which is like I I mean I I worked on 6.828 and xv6,

1467
01:04:56,060 --> 01:04:59,390
like literally like the year to before I went do the Go runtime,

1468
01:04:59,390 --> 01:05:01,910
and so there's a huge amount of situate in the Go runtime.

1469
01:05:02,400 --> 01:05:05,010
And in the actual Go runtime directory,

1470
01:05:05,130 --> 01:05:06,720
there's a file called proc.go,

1471
01:05:06,720 --> 01:05:08,640
which is you know proc stands process,

1472
01:05:08,640 --> 01:05:10,920
because that's what it is in the operating systems,

1473
01:05:11,340 --> 01:05:12,690
and I would start there,

1474
01:05:12,690 --> 01:05:13,950
that's the file to start with

1475
01:05:13,950 --> 01:05:15,720
and then sort of pull on strings.

1476
01:05:17,930 --> 01:05:21,350
Someone asked about Python, sort of negative indexing,

1477
01:05:21,440 --> 01:05:23,090
where you can write x[-1],

1478
01:05:23,510 --> 01:05:24,800
and that comes up a lot,

1479
01:05:24,830 --> 01:05:26,330
especially from Python programmers,

1480
01:05:26,720 --> 01:05:28,850
and and it seems like a really great idea

1481
01:05:28,850 --> 01:05:30,740
you write these really nice elegant programs,

1482
01:05:30,740 --> 01:05:32,210
where you want to get the last element,

1483
01:05:32,210 --> 01:05:33,440
you just say x[-1].

1484
01:05:33,980 --> 01:05:36,740
But the real problem is that you have x of i,

1485
01:05:36,860 --> 01:05:37,610
and you have a loop,

1486
01:05:37,610 --> 01:05:40,820
that's like counting down from from you know n to 0,

1487
01:05:40,880 --> 01:05:42,440
and you have an off by 1 somewhere,

1488
01:05:42,440 --> 01:05:45,830
and now x of -1 instead of being x of i,

1489
01:05:45,830 --> 01:05:47,180
when i is -1,

1490
01:05:47,210 --> 01:05:48,200
instead of being an error,

1491
01:05:48,200 --> 01:05:50,870
where you immediately say hey, there's a bug I need to find that,

1492
01:05:50,990 --> 01:05:54,230
it just silently grabs the element off the other end of the array,

1493
01:05:54,620 --> 01:05:57,530
and that's where you know the sort of Python,

1494
01:05:58,610 --> 01:06:01,520
you know simplicity makes things worse,

1495
01:06:01,880 --> 01:06:03,350
and so that was why we left it out,

1496
01:06:03,350 --> 01:06:06,020
because it was going to hide bugs too much, we thought.

1497
01:06:07,750 --> 01:06:08,980
You know you could imagine something,

1498
01:06:08,980 --> 01:06:12,250
where you say like x of $-1, len-1,

1499
01:06:12,250 --> 01:06:13,810
not len of x, but just len,

1500
01:06:14,440 --> 01:06:16,660
but you know it seemed like too much of a special case,

1501
01:06:16,660 --> 01:06:18,580
and really it doesn't come up enough.

1502
01:06:20,430 --> 01:06:23,130
Someone asked about,

1503
01:06:23,130 --> 01:06:25,800
you know what aspect of Go was hardest to implement?

1504
01:06:26,780 --> 01:06:29,150
And honestly like a lot of this is not very hard,

1505
01:06:29,480 --> 01:06:31,520
we've done most of this before,

1506
01:06:31,550 --> 01:06:32,840
we've written operating systems

1507
01:06:32,840 --> 01:06:35,150
and reading libraries and channel implementations,

1508
01:06:35,330 --> 01:06:37,730
and so doing all that again was fairly straightforward,

1509
01:06:38,150 --> 01:06:40,760
the hardest thing was probably the garbage collector,

1510
01:06:41,680 --> 01:06:44,350
Go is unique among garbage collected languages,

1511
01:06:44,350 --> 01:06:47,590
and that it gives programmers a lot more control over memory layout,

1512
01:06:47,590 --> 01:06:50,890
so if you want to have a structure with two different other structures inside it,

1513
01:06:51,010 --> 01:06:52,660
that's just one big chunk of memory,

1514
01:06:52,780 --> 01:06:55,660
it's not a struct with pointers to to other chunks of memory.

1515
01:06:56,330 --> 01:06:57,140
And because of that,

1516
01:06:57,140 --> 01:06:59,630
and you can take the address of the second field in struct

1517
01:06:59,630 --> 01:07:00,590
and pass that around,

1518
01:07:01,010 --> 01:07:03,770
and that means the garbage collector has to be able to deal with a pointer,

1519
01:07:03,920 --> 01:07:06,380
that could point into the middle of an allocated object,

1520
01:07:06,380 --> 01:07:09,320
and that's just something that Java and Lisp and other things just don't do.

1521
01:07:10,360 --> 01:07:13,540
And so that makes the garbage collector a lot more complicated

1522
01:07:13,540 --> 01:07:15,760
in how it maintains its data structures.

1523
01:07:16,180 --> 01:07:17,680
And we also knew from the start,

1524
01:07:17,680 --> 01:07:19,570
that you really want low latency,

1525
01:07:19,570 --> 01:07:22,450
because if you're handling network requests,

1526
01:07:22,450 --> 01:07:26,080
you can't, you know just pause for 200 milliseconds while,

1527
01:07:26,080 --> 01:07:29,590
and block all of those in progress request to do a garbage collection,

1528
01:07:29,590 --> 01:07:33,460
it really needs to be you know low latency and not stop things,

1529
01:07:33,460 --> 01:07:36,940
and we thought that multi-core would be a good good opportunity there,

1530
01:07:36,940 --> 01:07:39,490
because we could have the garbage collector doing one core,

1531
01:07:39,640 --> 01:07:41,710
and the Go program using the other cores,

1532
01:07:41,710 --> 01:07:43,030
and that might work really well,

1533
01:07:43,030 --> 01:07:45,400
and that actually did turn out to work really well,

1534
01:07:45,580 --> 01:07:48,670
but it required hiring a real expert in garbage collection

1535
01:07:48,790 --> 01:07:51,190
to like figure out how to do it,

1536
01:07:51,880 --> 01:07:53,200
and make it work,

1537
01:07:53,290 --> 01:07:54,910
but now it's really great.

1538
01:07:55,700 --> 01:07:57,470
I I have a quick question,

1539
01:07:57,500 --> 01:08:00,950
you said like if it's struct,

1540
01:08:01,280 --> 01:08:03,320
like it's declared inside another struct,

1541
01:08:03,650 --> 01:08:06,080
it actually is a big chunk of memory.

1542
01:08:06,260 --> 01:08:06,620
Yeah.

1543
01:08:06,620 --> 01:08:08,900
Why, why did you implement it like that,

1544
01:08:09,020 --> 01:08:10,310
what's the reason behind that?

1545
01:08:11,210 --> 01:08:12,950
Well, so there's a couple reasons,

1546
01:08:12,950 --> 01:08:15,470
one is for a garbage collector, it's a service,

1547
01:08:15,500 --> 01:08:19,610
and the load on the garbage collector is proportional to the number of objects you allocate,

1548
01:08:19,910 --> 01:08:22,430
and so if you have a struct of five things in it,

1549
01:08:22,430 --> 01:08:23,900
you can make that one allocation,

1550
01:08:23,960 --> 01:08:26,570
that's a fifth of the load on the garbage collector,

1551
01:08:26,570 --> 01:08:27,830
and that turns out to be really important.

1552
01:08:28,450 --> 01:08:31,960
But the other thing that's really important is cache locality, right,

1553
01:08:31,960 --> 01:08:34,840
like if you have the processor is pulling in chunks of memory

1554
01:08:34,840 --> 01:08:37,060
in 64 byte chunks or whatever it is,

1555
01:08:37,180 --> 01:08:39,670
and it's much better reading memory that's altogether

1556
01:08:39,700 --> 01:08:41,050
than reading memory that's scattered.

1557
01:08:41,710 --> 01:08:45,820
And so you know we have a Git server at Google called Gerrit,

1558
01:08:46,000 --> 01:08:47,380
that is written in Java,

1559
01:08:47,410 --> 01:08:51,070
and it was just starting at the time that Go was just coming out,

1560
01:08:51,430 --> 01:08:53,860
and we just missed like Gerrit being written and Go,

1561
01:08:53,860 --> 01:08:54,970
I think by a year,

1562
01:08:55,660 --> 01:08:58,480
we talked to the guy who had written Gerrit,

1563
01:08:58,630 --> 01:09:02,020
and he said that one of the biggest problems in Gerrit was like,

1564
01:09:02,140 --> 01:09:03,880
you have really [?short one hashes],

1565
01:09:03,940 --> 01:09:06,250
and just having the idea of 20 bytes,

1566
01:09:06,540 --> 01:09:08,070
it is impossible to have in Java,

1567
01:09:08,100 --> 01:09:09,990
you can't just have 20 bytes in struct,

1568
01:09:10,260 --> 01:09:12,270
you have to have a pointer to an object,

1569
01:09:12,450 --> 01:09:13,650
and the object like,

1570
01:09:14,040 --> 01:09:16,080
you, you can't even have 20 bytes in the object,

1571
01:09:16,080 --> 01:09:18,630
you have to declare five different [] something like that,

1572
01:09:18,630 --> 01:09:19,680
to get 20 bytes,

1573
01:09:20,040 --> 01:09:22,170
and there's just no good way to do it,

1574
01:09:22,170 --> 01:09:25,080
and it's just the overhead of just a simple thing like that,

1575
01:09:25,320 --> 01:09:26,430
really adds up.

1576
01:09:27,080 --> 01:09:29,210
And so you know we thought

1577
01:09:29,210 --> 01:09:31,550
giving programmers control over memory was really important.

1578
01:09:35,180 --> 01:09:38,570
So, another question was was about automatic parallelization,

1579
01:09:38,570 --> 01:09:40,100
like for loops and things like that,

1580
01:09:40,130 --> 01:09:42,770
we don't do anything like that at the standard Go tool chain,

1581
01:09:42,890 --> 01:09:47,060
there are Go compilers for Go frontend for GCC and LLVM,

1582
01:09:47,390 --> 01:09:48,380
and so to the extent,

1583
01:09:48,380 --> 01:09:50,900
Go those do those kind of loop optimization in C,

1584
01:09:50,930 --> 01:09:54,170
I think you know we get the same from the Go [] for those,

1585
01:09:54,350 --> 01:09:58,520
but it's not the kind of parallelization that we typically need at Google,

1586
01:09:58,550 --> 01:10:02,540
it's it's more you know lots of servers running different things,

1587
01:10:02,540 --> 01:10:04,310
and and so you know that sort of,

1588
01:10:04,980 --> 01:10:07,500
you know like the sort of big vector math kind of stuff,

1589
01:10:07,500 --> 01:10:08,400
doesn't come up as much,

1590
01:10:08,400 --> 01:10:10,920
so it just hasn't been that important to us.

1591
01:10:12,140 --> 01:10:14,840
And then the last question I have right now,

1592
01:10:14,840 --> 01:10:17,120
is that someone asked about,

1593
01:10:17,120 --> 01:10:19,370
how do you decide when to acquire release locks,

1594
01:10:19,370 --> 01:10:20,720
and why don't you have re-entered locks?

1595
01:10:20,960 --> 01:10:22,880
And for that, I want to go back a slide,

1596
01:10:22,880 --> 01:10:26,140
let me see, yeah, here,

1597
01:10:26,410 --> 01:10:28,600
so like during the lecture,

1598
01:10:28,600 --> 01:10:30,100
I said things like the lock,

1599
01:10:30,130 --> 01:10:32,890
like mu protects the map or protects the data,

1600
01:10:33,220 --> 01:10:35,170
but what we really mean at that point is that,

1601
01:10:35,170 --> 01:10:38,650
we're saying that a lock protects some collection of invariance,

1602
01:10:38,680 --> 01:10:40,900
that apply to the data, that are true of the data,

1603
01:10:41,260 --> 01:10:42,760
and the reason we have a lock is

1604
01:10:42,760 --> 01:10:46,420
to protect the operations that depend on the invariance,

1605
01:10:46,420 --> 01:10:50,140
and that sometimes temporarily invalidate the invariance from each other.

1606
01:10:50,860 --> 01:10:52,480
And so when you call lock,

1607
01:10:52,480 --> 01:10:53,680
what you're saying is,

1608
01:10:54,010 --> 01:10:57,100
I need to make use of the invariance that this lock protects,

1609
01:10:57,400 --> 01:10:58,270
and when you call unlock,

1610
01:10:58,270 --> 01:11:00,250
what you're saying is I don't need them anymore,

1611
01:11:00,280 --> 01:11:03,010
and if I temporarily invalidated them,

1612
01:11:03,130 --> 01:11:04,270
I've put them back,

1613
01:11:04,300 --> 01:11:07,930
so that the next person who calls lock will see correct invariance.

1614
01:11:08,980 --> 01:11:11,290
So in the Mux, you know we want the invariant,

1615
01:11:11,290 --> 01:11:14,650
that each registered pending channel gets at most one reply,

1616
01:11:15,700 --> 01:11:16,390
and so to do that,

1617
01:11:16,390 --> 01:11:18,130
when we take done out of the map,

1618
01:11:18,160 --> 01:11:21,250
we also delete it from the map before we unlock it,

1619
01:11:21,520 --> 01:11:23,740
and if there was some separate cancel operation,

1620
01:11:23,740 --> 01:11:26,050
that was directly manipulating the map as well,

1621
01:11:26,320 --> 01:11:27,610
it could lock the,

1622
01:11:27,640 --> 01:11:28,690
it could call lock,

1623
01:11:28,930 --> 01:11:31,390
it could take the thing out, call unlock,

1624
01:11:32,110 --> 01:11:34,510
and then, if it actually found one it would know,

1625
01:11:34,600 --> 01:11:36,670
no one is going to send to that anymore,

1626
01:11:36,670 --> 01:11:37,960
because I took it out,

1627
01:11:38,170 --> 01:11:41,230
whereas if you know we had written this code

1628
01:11:41,230 --> 01:11:43,900
to have an extra unlock and relock

1629
01:11:43,900 --> 01:11:47,080
between the done equals pending of tag and the delete,

1630
01:11:47,230 --> 01:11:50,890
then you wouldn't have that protection of the invariance anymore,

1631
01:11:50,890 --> 01:11:52,930
because you would have put things back,

1632
01:11:52,930 --> 01:11:54,190
you've unlocked and relocked,

1633
01:11:54,190 --> 01:11:55,870
while the invariance were broken.

1634
01:11:56,420 --> 01:11:58,490
And so it's really important to

1635
01:11:58,520 --> 01:12:01,970
correctness to think about locks is protecting invariance.

1636
01:12:02,860 --> 01:12:05,410
And and so if you have reentrant locks,

1637
01:12:05,900 --> 01:12:07,880
all that goes out the window,

1638
01:12:07,910 --> 01:12:09,110
without the reentrant lock,

1639
01:12:09,110 --> 01:12:10,370
when you call lock,

1640
01:12:10,430 --> 01:12:11,270
on the next line,

1641
01:12:11,270 --> 01:12:14,270
you know, okay, the lock just got acquired,

1642
01:12:14,270 --> 01:12:15,440
all the invariant are true,

1643
01:12:16,100 --> 01:12:17,390
if you have a reentrant lock,

1644
01:12:17,420 --> 01:12:18,080
all you know is,

1645
01:12:18,080 --> 01:12:20,780
well, all the invariants were true,

1646
01:12:20,810 --> 01:12:22,490
for whoever locked this the first time,

1647
01:12:22,490 --> 01:12:24,380
we might be way up here on my call stack,

1648
01:12:24,900 --> 01:12:26,280
and you really know nothing,

1649
01:12:26,820 --> 01:12:30,720
and so that makes it a lot harder to reason about what can you assume,

1650
01:12:31,500 --> 01:12:35,190
and so I think the reentrant locks are really unfortunate part of Java's legacy.

1651
01:12:35,770 --> 01:12:37,720
Another big problem with reentrant locks is that,

1652
01:12:37,720 --> 01:12:40,660
if you have code where you know you call something

1653
01:12:40,660 --> 01:12:42,640
and it is depending on a reentrant lock,

1654
01:12:42,670 --> 01:12:45,100
or something where you've acquired the lock up above,

1655
01:12:45,940 --> 01:12:47,980
and then at some point you say you know what,

1656
01:12:48,010 --> 01:12:49,840
actually I want to have a timeout on this

1657
01:12:49,840 --> 01:12:52,210
or I want to do it you know in some other goroutine,

1658
01:12:52,210 --> 01:12:53,590
while I wait for something else,

1659
01:12:53,710 --> 01:12:55,960
when you move that code to a different goroutine,

1660
01:12:56,140 --> 01:12:58,810
reentrant always means locked on the same stack,

1661
01:12:58,810 --> 01:13:01,150
that's the only plausible thing it could possibly mean,

1662
01:13:01,540 --> 01:13:03,130
and so if you move the code

1663
01:13:03,130 --> 01:13:06,340
that was doing the reentrant lock onto a different stack,

1664
01:13:06,800 --> 01:13:07,700
then it's going to deadlock,

1665
01:13:07,700 --> 01:13:10,910
because deadlock is now actually going to be a real lock acquire,

1666
01:13:10,910 --> 01:13:13,280
and it's going to be waiting for you to let go of the lock,

1667
01:13:13,280 --> 01:13:14,090
you're not going to let go of it,

1668
01:13:14,090 --> 01:13:16,280
because you think that code needs to finish running.

1669
01:13:16,670 --> 01:13:20,390
So it's actually completely fundamentally incompatible with restructurings,

1670
01:13:20,390 --> 01:13:21,260
where you take code

1671
01:13:21,260 --> 01:13:23,570
and run it in different threads or different goroutines.

1672
01:13:24,160 --> 01:13:25,780
And so anyway, my advice there is

1673
01:13:25,780 --> 01:13:28,240
to just think about locks protecting invariants,

1674
01:13:28,480 --> 01:13:31,450
and then you know just avoid depending on reentrant locks,

1675
01:13:31,450 --> 01:13:35,320
it it really just doesn't scale well to real programs.

1676
01:13:35,620 --> 01:13:37,150
So I'll put this list back up,

1677
01:13:37,180 --> 01:13:38,680
actually we have that up long enough,

1678
01:13:38,680 --> 01:13:39,370
I can try to figure out

1679
01:13:39,370 --> 01:13:40,330
and stop presenting.

1680
01:13:41,060 --> 01:13:43,340
And then I can take a few more questions,

1681
01:13:46,560 --> 01:13:47,400
anyone has?

1682
01:13:47,880 --> 01:13:49,260
I had a question,

1683
01:13:49,770 --> 01:13:55,230
I mean I I think coming from Python gets very useful, right,

1684
01:13:55,230 --> 01:13:58,830
it's very common to use like standard functional operations,

1685
01:13:58,830 --> 01:14:02,820
like map or filter stuff like that,

1686
01:14:02,820 --> 01:14:06,070
like, like list comprehension,

1687
01:14:06,490 --> 01:14:10,480
and when you know I switched over to Go and started programming,

1688
01:14:10,630 --> 01:14:12,550
it's used, I I looked it up

1689
01:14:12,550 --> 01:14:15,610
and people say you shouldn't do this, do this with Go.

1690
01:14:15,640 --> 01:14:16,000
Right.

1691
01:14:16,000 --> 01:14:17,020
I was wondering why.

1692
01:14:17,750 --> 01:14:20,090
Well, I mean one is that,

1693
01:14:20,120 --> 01:14:21,020
you can do it the other way,

1694
01:14:21,020 --> 01:14:22,490
so you might just do the way you can do it,

1695
01:14:23,540 --> 01:14:26,270
but a bigger a bigger issue is that.

1696
01:14:27,580 --> 01:14:29,680
Well, there's, that one answer,

1697
01:14:29,680 --> 01:14:30,940
the other answer is that,

1698
01:14:31,390 --> 01:14:33,670
you know if you do it that way,

1699
01:14:33,670 --> 01:14:35,560
you actually end up creating a lot of garbage,

1700
01:14:35,590 --> 01:14:38,590
and if you care about not putting too much load on the garbage collector,

1701
01:14:38,590 --> 01:14:40,990
that kind of is another way to avoid that,

1702
01:14:41,590 --> 01:14:45,970
you know, so if you've got a map and then a filter and then another map,

1703
01:14:45,970 --> 01:14:47,800
like you can make that one loop over the data

1704
01:14:47,800 --> 01:14:49,180
instead of three loops over the data,

1705
01:14:49,180 --> 01:14:51,100
each of which generate a new piece of garbage.

1706
01:14:53,390 --> 01:14:55,520
But you know now that we have Generics coming,

1707
01:14:55,970 --> 01:14:57,800
you'll actually be able to write those functions,

1708
01:14:57,800 --> 01:15:00,950
like you couldn't actually write what the type [] of those functions were before,

1709
01:15:00,980 --> 01:15:02,630
and so you literally couldn't write them,

1710
01:15:03,200 --> 01:15:04,370
and python gets away with this,

1711
01:15:04,370 --> 01:15:06,620
because there's no static types.

1712
01:15:06,710 --> 01:15:08,570
But now we're actually going to have a way to do that,

1713
01:15:08,570 --> 01:15:10,850
and I totally expect that once Generics go in there,

1714
01:15:10,850 --> 01:15:12,020
will be a package slices

1715
01:15:12,020 --> 01:15:13,160
and if you import slices,

1716
01:15:13,160 --> 01:15:18,380
you can do slices.map and slices.filter and slices.unique or something like that,

1717
01:15:18,380 --> 01:15:20,000
and I think those will all happen,

1718
01:15:20,150 --> 01:15:23,000
and you know if if that's the right thing, then that's great.

1719
01:15:25,900 --> 01:15:26,350
Thanks.

1720
01:15:26,620 --> 01:15:27,280
Sure.

1721
01:15:28,820 --> 01:15:29,780
I have.

1722
01:15:29,930 --> 01:15:31,970
That one of the hints that you had,

1723
01:15:32,390 --> 01:15:38,870
it was about running goroutines that are independent like concurrently,

1724
01:15:40,230 --> 01:15:42,090
and some of the examples of the code,

1725
01:15:42,090 --> 01:15:43,860
I think I couldn't understand,

1726
01:15:44,660 --> 01:15:45,290
it seems to me,

1727
01:15:45,290 --> 01:15:49,550
like you can just like call the function in the same thread

1728
01:15:49,820 --> 01:15:51,740
rather than a different thread,

1729
01:15:52,340 --> 01:15:55,520
and I was not sure why you would call it in a different thread.

1730
01:15:56,290 --> 01:16:01,130
So, usually it's because you want them to proceed independently,

1731
01:16:01,250 --> 01:16:04,820
so so in one of the one of the examples, we had,

1732
01:16:04,820 --> 01:16:09,680
like the there was a loop that was sending you know tasks to the work queue,

1733
01:16:10,560 --> 01:16:13,740
but there was the servers were running in different goroutines,

1734
01:16:13,740 --> 01:16:15,750
and reading from the work queue and doing work,

1735
01:16:15,900 --> 01:16:16,980
but then when they were done,

1736
01:16:16,980 --> 01:16:20,460
they would send, you know hey I'm done now to the done channel,

1737
01:16:20,790 --> 01:16:22,920
but a sending Go doesn't complete

1738
01:16:22,920 --> 01:16:25,650
until the receive actually matches with it,

1739
01:16:26,150 --> 01:16:28,910
and so if the thing that's sending on the work queue

1740
01:16:29,240 --> 01:16:31,550
is not going to start receiving from the done channel

1741
01:16:31,550 --> 01:16:33,710
until it's done sending to all the work queues,

1742
01:16:34,070 --> 01:16:36,890
or sending all the work in all the tasks in the work queue,

1743
01:16:37,130 --> 01:16:38,450
then now you have a deadlock,

1744
01:16:38,450 --> 01:16:40,640
because the main thread,

1745
01:16:40,670 --> 01:16:44,150
the main goroutine is trying to send new work to the servers,

1746
01:16:44,180 --> 01:16:45,860
the servers are not taking new work,

1747
01:16:45,860 --> 01:16:48,110
they're trying to tell the main thread that they're done,

1748
01:16:48,230 --> 01:16:50,240
but the main thread not going to actually start at

1749
01:16:50,240 --> 01:16:51,980
like reading from the done channel

1750
01:16:52,160 --> 01:16:54,110
until it finishes giving out all the work,

1751
01:16:54,110 --> 01:16:56,240
and so there's just staring at each other,

1752
01:16:56,240 --> 01:16:57,710
waiting for different things to happen,

1753
01:16:57,830 --> 01:16:59,660
whereas if we take that loop,

1754
01:16:59,660 --> 01:17:03,320
that if we just put the little goroutine around the loop that's sending the work,

1755
01:17:03,380 --> 01:17:05,180
then that can go somewhere else,

1756
01:17:05,210 --> 01:17:06,590
and then it can proceed independently,

1757
01:17:06,590 --> 01:17:10,910
and while it's stuck, waiting for the servers to to take more work,

1758
01:17:10,970 --> 01:17:14,360
the servers are stuck waiting for the main goroutine

1759
01:17:14,360 --> 01:17:16,910
to acknowledge that it finished some work,

1760
01:17:17,060 --> 01:17:19,670
and now the main goroutine actually gets down to the loop,

1761
01:17:19,730 --> 01:17:23,630
that pulls it finishes that actually acknowledges that finish the work,

1762
01:17:23,630 --> 01:17:24,800
that reads from the done channel,

1763
01:17:25,070 --> 01:17:27,150
and so it's just a way to separate out,

1764
01:17:27,150 --> 01:17:29,280
you know these are two different things that logically,

1765
01:17:29,340 --> 01:17:31,470
they didn't have to happen one after the other,

1766
01:17:31,650 --> 01:17:34,530
and because they were happening one after the other, that caused a deadlock,

1767
01:17:34,530 --> 01:17:37,350
and by taking one out and moving it, let it run independently,

1768
01:17:38,340 --> 01:17:39,840
that removes the deadlock.

1769
01:17:41,760 --> 01:17:42,900
Thank you so much.

1770
01:17:42,930 --> 01:17:43,530
Sure.

1771
01:17:44,460 --> 01:17:47,640
Could you talk a little bit about how Go's race detector is implemented?

1772
01:17:48,250 --> 01:17:50,170
Sure, it is the LLVM race detector,

1773
01:17:50,470 --> 01:17:53,020
and so that probably doesn't help,

1774
01:17:53,020 --> 01:17:56,380
but it is exactly the thing that LLVM calls ThreadSanitizer,

1775
01:17:57,270 --> 01:18:02,430
and, and so we actually have a little binary blob that we link against,

1776
01:18:02,460 --> 01:18:04,500
because we don't want to depend on all of LLVM,

1777
01:18:04,650 --> 01:18:06,510
but it's the LLVM race detector.

1778
01:18:06,690 --> 01:18:08,850
And the way the LLVM race detector works is that,

1779
01:18:08,850 --> 01:18:11,310
it allocates a ton of extra virtual memory,

1780
01:18:11,580 --> 01:18:15,480
and then based on the address of of the thing being read or written,

1781
01:18:15,630 --> 01:18:18,480
it has this other you know spot in virtual memory,

1782
01:18:18,480 --> 01:18:22,830
where it records information about like the last thread,

1783
01:18:22,950 --> 01:18:25,860
you know it thinks of threads, but they're goroutines,

1784
01:18:25,920 --> 01:18:28,230
has when the last thread that did a read or write,

1785
01:18:28,320 --> 01:18:31,440
and then also every time asynchronizing event happens,

1786
01:18:31,440 --> 01:18:34,200
like you know communication from one goroutine to another,

1787
01:18:34,690 --> 01:18:37,000
that counts as establishing,

1788
01:18:37,000 --> 01:18:39,580
it happens before ends between two different goroutines,

1789
01:18:39,700 --> 01:18:43,690
and if you ever get something where you have a read a write,

1790
01:18:43,960 --> 01:18:46,210
and they're not properly sequence, right,

1791
01:18:46,210 --> 01:18:47,290
like so if you have a read

1792
01:18:47,290 --> 01:18:49,450
and then it happens before something in another goroutine

1793
01:18:49,450 --> 01:18:51,220
which then later does the write,

1794
01:18:51,220 --> 01:18:51,970
that's fine,

1795
01:18:52,180 --> 01:18:53,500
but if you have a read and a write

1796
01:18:53,500 --> 01:18:55,990
and there's no happens before sequence that connects them,

1797
01:18:56,110 --> 01:18:58,330
then that's a race,

1798
01:18:58,360 --> 01:19:01,690
and it actually you know has some pretty clever ways

1799
01:19:01,690 --> 01:19:04,360
to dynamically figure out quickly,

1800
01:19:04,360 --> 01:19:06,310
you know did this read happen,

1801
01:19:06,520 --> 01:19:07,720
is there happens before [],

1802
01:19:07,720 --> 01:19:09,490
between this read and write as they happen,

1803
01:19:09,670 --> 01:19:12,820
and it slows down the program by maybe 10x,

1804
01:19:12,880 --> 01:19:15,970
but you know if you just divert a small amount of traffic there,

1805
01:19:16,000 --> 01:19:16,990
that's probably fine,

1806
01:19:17,170 --> 01:19:19,300
if its for testing, that's also probably fine,

1807
01:19:19,570 --> 01:19:22,240
it's way better than not finding out about the races,

1808
01:19:22,270 --> 01:19:23,290
so it's totally worth it.

1809
01:19:23,470 --> 01:19:26,650
And honestly ten or twenty x is fantastic,

1810
01:19:26,650 --> 01:19:30,100
the original ThreadSanitizer was more like a hundred a thousand x,

1811
01:19:30,100 --> 01:19:31,390
and that was not good enough.

1812
01:19:31,960 --> 01:19:34,600
Well, what's the race detector called, LLVM?

1813
01:19:34,750 --> 01:19:36,100
It's called ThreadSanitizer,

1814
01:19:36,100 --> 01:19:40,330
but it's part of LLVM, which is the clang C compiler,

1815
01:19:40,360 --> 01:19:43,360
the one that almost everyone uses now,

1816
01:19:43,870 --> 01:19:46,840
is part of the LLVM project.

1817
01:19:54,740 --> 01:19:57,380
Can you talk about slices and the design choices,

1818
01:19:57,380 --> 01:19:59,360
having them as [views] on arrays,

1819
01:19:59,540 --> 01:20:01,130
which like confused me at first.

1820
01:20:01,220 --> 01:20:03,740
Yeah, it is a little confusing at first,

1821
01:20:05,420 --> 01:20:06,620
the main thing is that,

1822
01:20:06,620 --> 01:20:09,200
you want it to be efficient to kind of walk through an array,

1823
01:20:09,200 --> 01:20:12,230
or like if you can quick sort or merge sort or something,

1824
01:20:12,230 --> 01:20:13,760
where you have an array of things,

1825
01:20:13,760 --> 01:20:14,450
and now you want to say,

1826
01:20:14,450 --> 01:20:16,670
well now sort this half, then sort the other half,

1827
01:20:16,760 --> 01:20:18,500
you want to be able to efficiently say,

1828
01:20:18,500 --> 01:20:22,190
like here, this is half of the previous one, like you know sort that,

1829
01:20:22,400 --> 01:20:25,460
and so, in C the way you do that is,

1830
01:20:25,460 --> 01:20:26,660
you just pass in

1831
01:20:26,720 --> 01:20:29,480
you know the pointer to the first element and the number of elements,

1832
01:20:29,630 --> 01:20:31,520
and that's basically all the slices,

1833
01:20:31,700 --> 01:20:34,130
and then the other pattern that comes up a lot,

1834
01:20:34,130 --> 01:20:36,890
when you're trying to be efficient with arrays,

1835
01:20:36,920 --> 01:20:38,300
is you have to grow them,

1836
01:20:38,600 --> 01:20:43,130
and and so you don't want to recall reallocate on every single new element,

1837
01:20:43,130 --> 01:20:44,330
you want to amortize that,

1838
01:20:44,570 --> 01:20:48,170
and so the way you do that in C again is that,

1839
01:20:48,170 --> 01:20:49,250
you have a base pointer,

1840
01:20:49,280 --> 01:20:50,810
you have the length that you're using right now,

1841
01:20:50,810 --> 01:20:52,190
and you have the length that you allocated,

1842
01:20:52,400 --> 01:20:54,200
and then to add one,

1843
01:20:54,200 --> 01:20:57,200
you check and see if the length is bigger than the amount you allocate,

1844
01:20:57,200 --> 01:20:58,160
if so you reallocate,

1845
01:20:58,160 --> 01:20:59,990
and otherwise you just keep bumping it forward,

1846
01:21:00,260 --> 01:21:03,710
and and slices are really just an [encoding of those idioms],

1847
01:21:03,770 --> 01:21:06,920
because those are the most efficient way to manage the memory.

1848
01:21:07,280 --> 01:21:11,870
And so in any kind of like C++ vector or something like that,

1849
01:21:11,900 --> 01:21:13,730
that's what's going on underneath,

1850
01:21:13,820 --> 01:21:15,890
but it makes it a lot harder to,

1851
01:21:15,890 --> 01:21:18,200
like the C++ vector,

1852
01:21:18,230 --> 01:21:20,060
because of ownership reasons,

1853
01:21:20,120 --> 01:21:22,550
the vector is tied to the actual underlying memory,

1854
01:21:22,550 --> 01:21:25,010
it's a lot harder to get like a sub vector,

1855
01:21:25,010 --> 01:21:27,980
that's just the view on the second half for merge sort.

1856
01:21:28,870 --> 01:21:30,730
So that's sort of the idea,

1857
01:21:30,730 --> 01:21:32,230
is that just like there are all these patterns

1858
01:21:32,230 --> 01:21:34,510
for accessing memory efficiently that came from C,

1859
01:21:34,900 --> 01:21:36,850
and we tried to make them fit into Go,

1860
01:21:36,850 --> 01:21:39,570
in an idiomatic way, in a safe way.

1861
01:21:42,490 --> 01:21:44,980
Can you talk about how you decided to

1862
01:21:44,980 --> 01:21:47,890
implement the Go like remote module system,

1863
01:21:47,890 --> 01:21:50,500
where you import directly from a URL, which is like.

1864
01:21:50,500 --> 01:21:53,920
Yeah, I mean I just didn't want to run a service

1865
01:21:53,920 --> 01:21:57,710
and like like you know a lot of the things like Ruby gems,

1866
01:21:57,710 --> 01:22:02,090
and those were not as for at the front of my mind at the time,

1867
01:22:02,090 --> 01:22:03,290
just because they were newer,

1868
01:22:03,380 --> 01:22:04,940
but I had used Perl for a while

1869
01:22:04,940 --> 01:22:08,060
and like CPAN, and I just thought it was insane,

1870
01:22:08,060 --> 01:22:11,330
that like everyone was fighting over these short names like db,

1871
01:22:11,480 --> 01:22:13,820
you know there probably should be an argument

1872
01:22:13,820 --> 01:22:16,220
over who gets to make the "db" package.

1873
01:22:18,070 --> 01:22:19,600
And so putting domain names in the front,

1874
01:22:19,600 --> 01:22:21,160
seemed like a good way to decentralize it,

1875
01:22:21,760 --> 01:22:24,160
and it was also a good way for us not to run any server,

1876
01:22:24,160 --> 01:22:25,630
because you know we could just say,

1877
01:22:25,630 --> 01:22:27,310
well we'll recognize the hostname,

1878
01:22:27,310 --> 01:22:29,500
and then Go grab it from source control,

1879
01:22:29,980 --> 01:22:31,390
from someone else's server,

1880
01:22:31,420 --> 01:22:33,820
and that turned out to be a really great idea I think,

1881
01:22:34,300 --> 01:22:37,450
because we just don't have that kind of same infrastructure,

1882
01:22:37,480 --> 01:22:39,100
that other things depend on.

1883
01:22:40,190 --> 01:22:43,010
But in the Java world, it's actually really problematic,

1884
01:22:43,010 --> 01:22:46,160
there are multiple, there's no sort of standard registry,

1885
01:22:46,160 --> 01:22:47,720
but they all use these short names,

1886
01:22:47,840 --> 01:22:53,120
and so like maven can be configured to build from multiple different registries,

1887
01:22:53,480 --> 01:22:56,330
and if you're an open-source software package provider,

1888
01:22:56,330 --> 01:22:57,380
you actually have to go around

1889
01:22:57,380 --> 01:22:59,810
and be sure that you upload it to all the different registries,

1890
01:22:59,900 --> 01:23:01,520
because if you miss one

1891
01:23:01,520 --> 01:23:02,690
and it becomes popular,

1892
01:23:02,690 --> 01:23:04,760
someone else will upload different code to that one,

1893
01:23:05,150 --> 01:23:08,990
and then like maven actually just takes whichever one comes back first,

1894
01:23:08,990 --> 01:23:10,430
it just sends a request to all of them

1895
01:23:10,430 --> 01:23:11,540
and whatever comes back first,

1896
01:23:11,540 --> 01:23:14,660
so you know if someone wants to make a malicious copy of your package,

1897
01:23:14,660 --> 01:23:17,720
he could do is find some registry other people use that you forgot to upload it to,

1898
01:23:17,750 --> 01:23:21,350
and like you know they get to win the race sometimes,

1899
01:23:21,410 --> 01:23:23,180
so it's a real problem,

1900
01:23:23,180 --> 01:23:24,350
I think having domain there

1901
01:23:24,350 --> 01:23:27,740
really helps split up the ownership in a really important way.

1902
01:23:29,110 --> 01:23:29,410
Thank you.

1903
01:23:29,410 --> 01:23:29,560
Sure.

1904
01:23:34,920 --> 01:23:37,890
What the, maybe take a quick pause here,

1905
01:23:38,070 --> 01:23:39,510
if people that have to go can go,

1906
01:23:39,510 --> 01:23:42,270
I'm sure Russ is willing to stick around for a bit longer

1907
01:23:42,810 --> 01:23:44,190
and answer any questions,

1908
01:23:44,190 --> 01:23:47,610
but I do want to thank Russ for giving this lecture,

1909
01:23:47,730 --> 01:23:50,940
hopefully this will help you writing more good Go programs,

1910
01:23:51,460 --> 01:23:52,930
with these patterns,

1911
01:23:52,930 --> 01:23:54,910
and so thank you Russ.

1912
01:23:55,890 --> 01:23:57,180
You're welcome, it's nice to be here.

1913
01:24:00,180 --> 01:24:02,280
And then more questions, feel free to ask questions.

1914
01:24:02,640 --> 01:24:03,060
Yeah.

1915
01:24:03,780 --> 01:24:05,910
Oh, just a little logistical thing,

1916
01:24:06,240 --> 01:24:09,420
the slides that are on the 6.824 website

1917
01:24:09,420 --> 01:24:12,420
are not exactly the same as Russ's slides.

1918
01:24:12,450 --> 01:24:15,540
I'll get Frans a new PDF.

1919
01:24:18,340 --> 01:24:20,080
A more general question about,

1920
01:24:20,640 --> 01:24:22,680
when is writing a new language,

1921
01:24:22,680 --> 01:24:25,650
the like the best solution to a problem.

1922
01:24:25,920 --> 01:24:26,880
That's a great question,

1923
01:24:26,880 --> 01:24:28,620
it's almost never the best solution.

1924
01:24:30,340 --> 01:24:34,300
But you know at the time we had just an enormous number of programmers,

1925
01:24:34,300 --> 01:24:36,670
like thousands of programmers working in one codebase

1926
01:24:36,940 --> 01:24:39,700
and the compilations were just taking forever,

1927
01:24:39,730 --> 01:24:45,430
because C++ was just not meant for efficient incremental compilation.

1928
01:24:46,030 --> 01:24:52,510
And so and furthermore at the time like threading library were really awful

1929
01:24:52,510 --> 01:24:53,740
like people just didn't use threads,

1930
01:24:53,740 --> 01:24:55,840
I remember like one of the first days I was at MIT

1931
01:24:55,840 --> 01:24:56,740
and talking to Robert,

1932
01:24:56,890 --> 01:24:58,180
and Robert said to me,

1933
01:24:58,210 --> 01:24:59,920
like in 2001, he said to me,

1934
01:24:59,920 --> 01:25:00,970
like we don't use threads here,

1935
01:25:00,970 --> 01:25:01,930
because threads are slow.

1936
01:25:02,350 --> 01:25:04,360
And and that was like totally normal,

1937
01:25:04,360 --> 01:25:07,120
that was just the way the world at the time.

1938
01:25:07,960 --> 01:25:10,270
And at Google we're having a lot of trouble,

1939
01:25:10,330 --> 01:25:13,660
because it was all event based callbacks at C++,

1940
01:25:13,840 --> 01:25:15,850
and there were these multi-core machines,

1941
01:25:15,850 --> 01:25:18,040
and we actually didn't know how to get things to work on them,

1942
01:25:18,040 --> 01:25:21,580
because like Linux threads were not something you could rely on to work,

1943
01:25:22,030 --> 01:25:25,000
and so we ended up like if you had a four core machine,

1944
01:25:25,000 --> 01:25:26,560
you just run four different process

1945
01:25:26,560 --> 01:25:28,510
in completely independent processes of the web server

1946
01:25:28,510 --> 01:25:31,210
and just treat it as like four machines,

1947
01:25:31,480 --> 01:25:33,580
and that was clearly not very efficient,

1948
01:25:33,610 --> 01:25:37,030
so there were a lot of good reasons to try something.

1949
01:25:38,900 --> 01:25:40,910
But you know it's a huge amount of work

1950
01:25:40,910 --> 01:25:42,530
to get to the point where Go is today,

1951
01:25:42,530 --> 01:25:46,370
and I think that, so much is not the language, right,

1952
01:25:46,370 --> 01:25:48,290
there were important things that we made in the language,

1953
01:25:48,290 --> 01:25:50,930
that enable other considerations,

1954
01:25:51,050 --> 01:25:54,380
but so much of the successful languages,

1955
01:25:54,380 --> 01:25:55,910
the ecosystem that built up around it

1956
01:25:55,910 --> 01:25:57,830
and the tooling that we built in the Go command,

1957
01:25:57,830 --> 01:25:59,870
and like all these like not the language things,

1958
01:25:59,870 --> 01:26:01,910
so, you know primary language,

1959
01:26:02,480 --> 01:26:04,580
people who are focused on the language itself,

1960
01:26:04,880 --> 01:26:07,460
I think sometimes get distracted by all the stuff around,

1961
01:26:07,460 --> 01:26:08,900
like they miss all the stuff around it.

1962
01:26:15,250 --> 01:26:17,230
Oh, can I ask a lot from that?

1963
01:26:17,440 --> 01:26:18,040
Yeah.

1964
01:26:18,250 --> 01:26:21,580
I was wondering how was working on Go different now,

1965
01:26:21,580 --> 01:26:24,370
since it's more mature than it was before.

1966
01:26:26,050 --> 01:26:28,510
Oh, that's a great question,

1967
01:26:28,780 --> 01:26:30,310
you know in the early days,

1968
01:26:30,310 --> 01:26:31,810
it was so easy to make changes,

1969
01:26:31,840 --> 01:26:33,670
and now it's really hard to make changes,

1970
01:26:33,700 --> 01:26:35,740
I think that's the number one thing.

1971
01:26:36,500 --> 01:26:38,450
You know in the early days,

1972
01:26:38,450 --> 01:26:41,300
like everything was in one source code repository,

1973
01:26:41,300 --> 01:26:43,820
literally all the Go code in the world was one source code repository,

1974
01:26:43,820 --> 01:26:45,770
and so there were days where we changed the syntax,

1975
01:26:45,770 --> 01:26:48,800
used to have a star before chan everytime you set a channel,

1976
01:26:48,800 --> 01:26:50,420
because it was a pointer underneath,

1977
01:26:50,420 --> 01:26:51,920
and it was all kind of exposed,

1978
01:26:51,920 --> 01:26:54,080
so you'd always say *chan int instead of chan int,

1979
01:26:54,470 --> 01:26:55,940
and similarly for maps,

1980
01:26:55,940 --> 01:26:58,250
and at some point we realize like this is dumb,

1981
01:26:58,250 --> 01:26:59,390
like you have to say the star,

1982
01:26:59,390 --> 01:27:00,230
let's just take it out,

1983
01:27:00,680 --> 01:27:03,320
and so like we made the change to the compiler,

1984
01:27:03,320 --> 01:27:07,610
and I opened up literally like the couple hundred Go source files in the world in my editor,

1985
01:27:07,610 --> 01:27:10,200
and like the entire team stood behind me,

1986
01:27:10,200 --> 01:27:11,610
and I typed some regular expressions

1987
01:27:11,610 --> 01:27:13,560
and we looked at the effect on the files,

1988
01:27:13,560 --> 01:27:14,490
yep, that looks right,

1989
01:27:14,520 --> 01:27:16,530
save it, you know compile it, we're done,

1990
01:27:17,040 --> 01:27:20,850
and like today you know we can't make backwards incompatible changes at all,

1991
01:27:21,960 --> 01:27:24,360
and even making new changes like it,

1992
01:27:25,320 --> 01:27:26,760
it affects a lot of people,

1993
01:27:26,790 --> 01:27:30,750
and so you know you sort of propose something,

1994
01:27:30,750 --> 01:27:32,970
and you know put all this won't work for me,

1995
01:27:32,970 --> 01:27:34,650
and you try to adjust that maybe.

1996
01:27:35,190 --> 01:27:36,450
It's a lot harder,

1997
01:27:36,450 --> 01:27:40,050
we estimate there's at least a million, maybe two million Go programmers in the world,

1998
01:27:40,050 --> 01:27:43,650
and is very different from when they were four or five.

1999
01:27:51,830 --> 01:27:53,210
Not sure if this is a valid question,

2000
01:27:53,210 --> 01:27:55,310
but what languages Go written,

2001
01:27:55,310 --> 01:27:57,050
is written in Go also or no.

2002
01:27:57,500 --> 01:27:58,760
Now it is, now it is,

2003
01:27:58,760 --> 01:28:01,250
the original compiler runtime write written in C,

2004
01:28:01,400 --> 01:28:03,410
but a few years ago we went through a big,

2005
01:28:03,950 --> 01:28:07,040
we actually wrote a program to translate C to Go,

2006
01:28:07,250 --> 01:28:09,830
and it only worked for our C code, but still was good enough,

2007
01:28:10,040 --> 01:28:14,030
so that we wouldn't lose all the encoded knowledge in that code,

2008
01:28:14,090 --> 01:28:16,370
about why things were the way they were and how things work,

2009
01:28:16,370 --> 01:28:17,570
so we don't got to start from scratch,

2010
01:28:17,660 --> 01:28:19,250
but now it's all written in Go

2011
01:28:19,400 --> 01:28:20,780
and a little bit of assembly.

2012
01:28:21,160 --> 01:28:24,010
And that means that people can,

2013
01:28:24,010 --> 01:28:27,640
you know people who know Go can help on the Go project,

2014
01:28:27,640 --> 01:28:28,390
whereas before,

2015
01:28:28,390 --> 01:28:30,880
like if you wanted to work on the compiler or the runtime,

2016
01:28:30,880 --> 01:28:32,380
you had to know C really well,

2017
01:28:32,380 --> 01:28:35,080
and like we weren't getting a lot of people know C really well,

2018
01:28:35,080 --> 01:28:37,000
there's not actually that many of them proportionately,

2019
01:28:37,000 --> 01:28:39,580
and furthermore like our entire user bases Go programmers,

2020
01:28:39,580 --> 01:28:40,600
not C programmers,

2021
01:28:40,840 --> 01:28:42,940
so moving to Go was a really big deal.

2022
01:28:46,230 --> 01:28:47,880
I was wondering how do you

2023
01:28:47,940 --> 01:28:51,450
prioritize what features to add to the language at this point,

2024
01:28:51,450 --> 01:28:55,020
I know Genetics, like we're asking for that,

2025
01:28:55,020 --> 01:28:58,250
like did you all know like how you choose what to work on?

2026
01:28:59,210 --> 01:29:02,060
I mean we've considered language mostly frozen for a while,

2027
01:29:02,330 --> 01:29:04,670
and so we haven't been adding much,

2028
01:29:04,730 --> 01:29:05,750
there was a long period,

2029
01:29:05,750 --> 01:29:06,950
we said we weren't adding anything,

2030
01:29:06,950 --> 01:29:10,160
and then we added a little bit of things in the last couple years

2031
01:29:10,160 --> 01:29:12,470
to lead up to Generics just kind of shake the Rust off,

2032
01:29:12,470 --> 01:29:15,200
like all the what breaks when you change something in the language,

2033
01:29:15,440 --> 01:29:18,080
so you can put underscores between digits and long numbers now

2034
01:29:18,080 --> 01:29:18,860
and things like that.

2035
01:29:20,620 --> 01:29:24,160
But you know Generics has clearly been the next thing that needed to happen,

2036
01:29:24,160 --> 01:29:25,480
and we just have to figure out how.

2037
01:29:26,430 --> 01:29:28,140
In general, we try to only add things,

2038
01:29:28,140 --> 01:29:31,740
that don't have weird kind of interference with other features,

2039
01:29:32,100 --> 01:29:34,470
and we try to add things that are really important,

2040
01:29:34,470 --> 01:29:36,810
that will help a lot of people for the kinds of programs,

2041
01:29:36,810 --> 01:29:38,370
that we're trying to target with Go,

2042
01:29:38,370 --> 01:29:41,190
which is like distributed systems and that sort of thing.

2043
01:29:50,050 --> 01:29:50,770
Cool?

2044
01:29:50,800 --> 01:29:51,220
Thank you.

2045
01:29:51,940 --> 01:29:55,120
Oh, I had a question actually,

2046
01:29:55,120 --> 01:29:58,030
so, for I noticed that,

2047
01:29:58,030 --> 01:30:03,010
like you know Go doesn't have like basic functions like min or max for like,

2048
01:30:03,520 --> 01:30:06,820
yeah, so is that like something that you're considering

2049
01:30:06,820 --> 01:30:08,920
like say adding with the Generics stuff,

2050
01:30:08,920 --> 01:30:10,300
maybe is that why you didn't.

2051
01:30:10,330 --> 01:30:14,620
Exactly right, because you can't have a min, you have min_int [],

2052
01:30:14,620 --> 01:30:15,970
but those have different names

2053
01:30:16,120 --> 01:30:17,110
and that was kind of annoying.

2054
01:30:17,540 --> 01:30:19,880
So now we can write just a generic name,

2055
01:30:20,450 --> 01:30:22,430
over any type that has a less than operator.

2056
01:30:22,940 --> 01:30:23,480
Yeah.

2057
01:30:23,480 --> 01:30:24,140
That'll be good.

2058
01:30:24,140 --> 01:30:27,500
And you know honestly like for the specific case of min and max.

2059
01:30:27,680 --> 01:30:30,350
It's not that hard to code, I know.

2060
01:30:30,350 --> 01:30:32,690
I was gonna say, I'm starting to feel like we should just make them buildings,

2061
01:30:32,690 --> 01:30:35,330
like you know print and things like that,

2062
01:30:35,360 --> 01:30:37,400
so that you can just always have them,

2063
01:30:37,520 --> 01:30:38,930
but even if we don't,

2064
01:30:38,930 --> 01:30:41,270
you'll be math.min and that'll be there at least.

2065
01:30:41,620 --> 01:30:42,580
Yeah.

2066
01:30:42,700 --> 01:30:44,110
We really didn't want to make them buildings

2067
01:30:44,110 --> 01:30:46,090
until we could express their types,

2068
01:30:46,090 --> 01:30:47,740
and we couldn't do that until Generics happened.

2069
01:30:48,300 --> 01:30:51,510
Because there is actually a min for floating points actually.

2070
01:30:51,510 --> 01:30:53,370
Yeah, I know it's kind of weird,

2071
01:30:53,370 --> 01:30:57,450
because the math library is basically copied from the C math.h,

2072
01:30:57,480 --> 01:31:00,090
set of things.

2073
01:31:00,090 --> 01:31:00,750
Yeah.

2074
01:31:01,020 --> 01:31:01,800
That's a good point,

2075
01:31:01,800 --> 01:31:03,060
we can't actually put them in math,

2076
01:31:03,060 --> 01:31:04,140
because they're already there.

2077
01:31:04,720 --> 01:31:05,500
Okay.

2078
01:31:05,860 --> 01:31:06,130
But.

2079
01:31:06,130 --> 01:31:06,880
Yeah.

2080
01:31:07,090 --> 01:31:08,020
We'll figure it out,

2081
01:31:08,020 --> 01:31:09,790
like I think we should probably just put them in the language,

2082
01:31:09,790 --> 01:31:11,350
but we have to get generics through first.

2083
01:31:11,650 --> 01:31:12,640
And another thing,

2084
01:31:12,670 --> 01:31:15,970
actually I noticed that you did USACO like competitive programming,

2085
01:31:16,420 --> 01:31:17,560
I did it too, actually.

2086
01:31:18,100 --> 01:31:18,460
Cool.

2087
01:31:18,490 --> 01:31:20,200
Yeah, so how did you,

2088
01:31:20,200 --> 01:31:23,560
so actually I included this in one of the questions that I submitted,

2089
01:31:23,560 --> 01:31:24,880
let me pull it up,

2090
01:31:24,940 --> 01:31:27,340
so my question was like,

2091
01:31:27,670 --> 01:31:33,250
how did how was like how did you, go from doing competitive programming

2092
01:31:33,250 --> 01:31:36,520
to like doing what you you're doing now at Google working on Go,

2093
01:31:36,520 --> 01:31:40,810
and how is the transition between like competitive programming to systems,

2094
01:31:40,810 --> 01:31:43,510
also finally what made you decide to go into system,

2095
01:31:43,510 --> 01:31:45,790
so how did it relate to programming code?

2096
01:31:45,790 --> 01:31:48,100
I mean competitive programming at the time that I did,

2097
01:31:48,100 --> 01:31:50,830
it was not as all consuming as I gather it is now,

2098
01:31:50,920 --> 01:31:55,940
like, like you know you could just like be able to implement a simple dynamic programming,

2099
01:31:55,940 --> 01:31:58,220
like little two for loops, and that was fine,

2100
01:31:58,220 --> 01:32:00,260
and now you have to go with complex algorithms

2101
01:32:00,260 --> 01:32:01,940
and all that stuff that I can do,

2102
01:32:02,060 --> 01:32:05,960
so at some point like somehow like it was different.

2103
01:32:06,480 --> 01:32:09,810
But you know I was actually more interested in the sort of systems

2104
01:32:09,810 --> 01:32:11,070
you kind of start from the start,

2105
01:32:11,160 --> 01:32:14,880
and the program contests were just something fun to do on the side.

2106
01:32:15,060 --> 01:32:15,600
Oh.

2107
01:32:15,600 --> 01:32:17,640
It wasn't a huge transition there,

2108
01:32:17,670 --> 01:32:20,730
I was never into implementing complex algorithms,

2109
01:32:20,970 --> 01:32:23,760
and max flow and all those sorts of things.

2110
01:32:23,910 --> 01:32:26,910
On the other hand, like when you start a new language,

2111
01:32:27,280 --> 01:32:30,610
you actually do get to write a lot of core things, right,

2112
01:32:30,640 --> 01:32:32,980
like someone has to write the sort function,

2113
01:32:33,400 --> 01:32:35,470
and it has to be a good general sort function,

2114
01:32:35,470 --> 01:32:37,150
like I spent a while last month,

2115
01:32:37,150 --> 01:32:39,040
like looking into [dip] algorithms,

2116
01:32:39,040 --> 01:32:42,820
and that's like matches that background pretty well,

2117
01:32:43,180 --> 01:32:44,350
so it does come up.

2118
01:32:44,810 --> 01:32:48,050
But you know it's just it's just a different kind of program.

2119
01:32:48,290 --> 01:32:50,060
Oh so, you thought of it as more of a side thing,

2120
01:32:50,060 --> 01:32:50,900
back then, no.

2121
01:32:50,900 --> 01:32:53,750
Yeah, it was definitely not the sort of main thing I did

2122
01:32:53,750 --> 01:32:54,800
when I was writing programs.

2123
01:32:54,890 --> 01:32:57,830
Yeah, because like today it's effectively like the main thing.

2124
01:32:57,830 --> 01:32:58,400
I know,

2125
01:32:58,400 --> 01:33:00,740
if if you don't do it full time,

2126
01:33:00,740 --> 01:33:02,090
like there's just no way you can.

2127
01:33:02,810 --> 01:33:05,870
Okay, they just want that many people who cared in 1995.

2128
01:33:07,180 --> 01:33:09,580
Well, yeah, twenty years later.

2129
01:33:15,190 --> 01:33:17,170
I'm gonna ask a related question to that,

2130
01:33:17,170 --> 01:33:23,410
so how do you decide to go from like academic work into,

2131
01:33:23,500 --> 01:33:26,500
I mean your work is still a little bit more different

2132
01:33:26,500 --> 01:33:30,730
than like the usual like software engining, but still.

2133
01:33:32,040 --> 01:33:34,750
Yeah, you know I got lucky,

2134
01:33:34,750 --> 01:33:37,180
I I grew up near Bell Labs in New Jersey,

2135
01:33:37,180 --> 01:33:39,820
and so that was how I ended up working on Plan 9 a little bit

2136
01:33:39,820 --> 01:33:40,930
in high school and college.

2137
01:33:42,550 --> 01:33:44,230
And so you know I I sort of knew

2138
01:33:44,230 --> 01:33:45,430
I was going to go to grad school,

2139
01:33:45,430 --> 01:33:47,500
and you know the plan was to go back to Bell Labs,

2140
01:33:47,500 --> 01:33:49,690
but it kind of imploded, while I was in grad school,

2141
01:33:50,200 --> 01:33:52,900
with the dot-com bubble, and the dot-com crash,

2142
01:33:53,290 --> 01:33:58,570
and and so like you know Google was was sort of just [] up PhDs,

2143
01:33:58,570 --> 01:34:00,190
systems PhD at the time,

2144
01:34:00,680 --> 01:34:02,600
and and and doing really interesting things,

2145
01:34:02,600 --> 01:34:03,920
I mean you probably there's,

2146
01:34:03,950 --> 01:34:05,690
I don't know, I haven't looked at syllabus for this year,

2147
01:34:05,690 --> 01:34:06,560
but you know there's things,

2148
01:34:06,560 --> 01:34:10,790
like Spanner and Bigtable and Chubby and and things like that,

2149
01:34:10,790 --> 01:34:12,440
and you know they they had a whole host

2150
01:34:12,440 --> 01:34:14,930
of good distributed systems kind of stuff going on.

2151
01:34:15,460 --> 01:34:18,640
And so it was sort of lucky to be able to go to that, too.

2152
01:34:20,660 --> 01:34:22,580
And you know at the time I graduated,

2153
01:34:22,580 --> 01:34:24,800
I was also looking at you know industrial research labs,

2154
01:34:24,800 --> 01:34:27,020
like Microsoft research and places like that,

2155
01:34:27,350 --> 01:34:31,610
so you know there's definitely an opportunity there for researching things,

2156
01:34:31,610 --> 01:34:33,740
but not in academia, if that's what you want,

2157
01:34:34,370 --> 01:34:36,200
it's a little harder to find, now,

2158
01:34:36,230 --> 01:34:37,430
I mean most of the places I have,

2159
01:34:37,430 --> 01:34:40,670
like Microsoft research imploded too, a couple years later.

2160
01:34:41,200 --> 01:34:45,130
But, you know it's, it's still an option,

2161
01:34:45,310 --> 01:34:48,580
and and you know just a slightly different path,

2162
01:34:48,880 --> 01:34:50,110
you end up,

2163
01:34:50,140 --> 01:34:52,000
the differences I see from academia is

2164
01:34:52,000 --> 01:34:54,400
like you end up caring a ton more about

2165
01:34:54,790 --> 01:34:56,740
actually making things work a hundred percent time

2166
01:34:56,740 --> 01:34:58,630
and supporting them for a decade or more,

2167
01:34:58,810 --> 01:35:00,400
where as you finish your paper

2168
01:35:00,400 --> 01:35:02,020
and you kind of get to put it off to the side,

2169
01:35:02,020 --> 01:35:04,390
and that's really nice actually at some level.

2170
01:35:05,890 --> 01:35:08,080
It's, it's definitely strange to me

2171
01:35:08,080 --> 01:35:12,010
to be you know editing source files that I wrote,

2172
01:35:12,100 --> 01:35:14,800
you know in some cases actually twenty years ago,

2173
01:35:15,010 --> 01:35:16,990
because I used a bunch of code

2174
01:35:16,990 --> 01:35:18,700
that I've already written when we start to go.

2175
01:35:19,190 --> 01:35:20,810
And it's very weird to think that,

2176
01:35:20,810 --> 01:35:23,630
I've been keeping this program running for twenty years.

2177
01:35:26,430 --> 01:35:26,820
Thank you.

