1
00:00:00,300 --> 00:00:05,520
好的，下午好，早上好，傍晚好，晚上好，无论你在哪里。

2
00:00:06,000 --> 00:00:08,820
让我们重新开始吧。

3
00:00:08,820 --> 00:00:10,980
所以，今天我们有一个嘉宾课程，

4
00:00:11,670 --> 00:00:13,950
可能演讲者需要一些介绍，

5
00:00:15,420 --> 00:00:20,640
Russ Cox 是 Go 项目的联合负责人之一，

6
00:00:20,640 --> 00:00:22,440
我们会更多地讨论这个问题。

7
00:00:22,710 --> 00:00:25,140
让我说几句话，

8
00:00:26,220 --> 00:00:28,320
不让 Russ 太尴尬，

9
00:00:28,350 --> 00:00:31,860
Russ 在分布式系统方面有着长期的经验，

10
00:00:32,670 --> 00:00:37,500
他是一个 Plan 9 的开发者和贡献者，

11
00:00:37,500 --> 00:00:40,320
当他是哈佛大学的本科生时，

12
00:00:41,040 --> 00:00:43,770
他参加了麻省理工学院的博士项目，

13
00:00:44,910 --> 00:00:45,960
我们在那里认识的，

14
00:00:46,410 --> 00:00:50,880
如果你上过任何形式的 PDOS 课程，

15
00:00:51,060 --> 00:00:52,680
那里会有，

16
00:00:52,710 --> 00:00:55,170
你会看到 Russ 在上面的[工作]，

17
00:00:55,800 --> 00:00:57,870
当然，在 6.824 上，

18
00:00:57,900 --> 00:01:03,390
对我们来说，切换到 Go 是一件很棒的事情，

19
00:01:03,390 --> 00:01:07,170
但如果你有不同的意见，

20
00:01:07,230 --> 00:01:11,160
当然可以向 Russ 提问并提出建议，

21
00:01:11,160 --> 00:01:15,940
他总是欢迎提出任何想法。

22
00:01:15,970 --> 00:01:17,800
就这样， Russ ，交给你了。

23
00:01:18,280 --> 00:01:20,290
太好了，谢谢，你们能看到幻灯片吗，

24
00:01:20,900 --> 00:01:21,560
还能用吗？

25
00:01:21,800 --> 00:01:22,370
好的，很好。

26
00:01:22,790 --> 00:01:26,900
所以我们构建 Go 支持编写分布式系统，

27
00:01:26,900 --> 00:01:28,280
那些我们在 Google 构建的，

28
00:01:28,640 --> 00:01:30,500
Go 非常适合，

29
00:01:30,500 --> 00:01:32,780
下一代的云软件，

30
00:01:32,810 --> 00:01:35,570
也非常适合 6.824 。

31
00:01:35,600 --> 00:01:36,620
所以，在这节课中，

32
00:01:36,620 --> 00:01:37,850
我将试着解释，

33
00:01:37,850 --> 00:01:40,580
我是如何考虑用 Go 编写程序的。

34
00:01:41,070 --> 00:01:45,690
我将介绍程序的设计和实现，

35
00:01:45,720 --> 00:01:48,510
通过常见的四种不同的模式。

36
00:01:49,060 --> 00:01:52,000
在此过程中，我将尝试强调一些提示或经验法则，

37
00:01:52,000 --> 00:01:54,970
你可以在设计自己的 Go 程序时牢记。

38
00:01:55,420 --> 00:01:57,850
我知道教学大纲链接到了一个较老版本的幻灯片，

39
00:01:57,850 --> 00:01:59,470
所以你可能已经见过它们了，

40
00:01:59,680 --> 00:02:02,110
我希望课程的形式更容易理解，

41
00:02:02,110 --> 00:02:04,330
比只看幻灯片。

42
00:02:04,880 --> 00:02:08,360
我希望这些模式足够通用，

43
00:02:08,390 --> 00:02:10,340
或许它们自己能帮上忙，

44
00:02:10,340 --> 00:02:12,530
但是你也会，

45
00:02:12,560 --> 00:02:16,070
提示会帮助你做好需要实现的东西的准备。

46
00:02:18,900 --> 00:02:23,280
所以，首先区分并发性和并行性很重要。

47
00:02:23,810 --> 00:02:26,480
并发性是关于如何编写程序

48
00:02:26,510 --> 00:02:31,100
能够独立编排独立执行的控制流，

49
00:02:31,100 --> 00:02:33,950
无论你称它们为进程、线程还是 goroutine ，

50
00:02:34,190 --> 00:02:37,640
这样你的程序就可以同时处理很多事情，

51
00:02:37,670 --> 00:02:39,470
而不会变得一团糟。

52
00:02:40,100 --> 00:02:43,310
另一方面，并行性是关于程序是如何执行的，

53
00:02:43,610 --> 00:02:47,180
关于允许多个计算同时运行，

54
00:02:47,180 --> 00:02:49,910
这样程序可以同时做很多事情，

55
00:02:49,910 --> 00:02:51,680
而不是一次处理很多事情。

56
00:02:52,120 --> 00:02:55,690
所以并发性很自然地适合并行执行，

57
00:02:55,930 --> 00:02:57,400
但今天的关注点是，

58
00:02:57,400 --> 00:03:01,000
如何使用 Go 的并发支持来使你的程序清楚，

59
00:03:01,330 --> 00:03:02,740
而不是让它们更快，

60
00:03:02,740 --> 00:03:04,300
如果它们变得更快了，那很好，

61
00:03:04,300 --> 00:03:05,830
但这不是今天的重点。

62
00:03:07,220 --> 00:03:11,450
所以我说，我会通过一些程序的设计和实现，

63
00:03:11,450 --> 00:03:16,280
我经常看到的四种常见的并发模式，

64
00:03:16,580 --> 00:03:18,260
但在我们到达这些之前，

65
00:03:18,290 --> 00:03:20,780
我想从一个看似微不足道的问题开始，

66
00:03:20,780 --> 00:03:23,420
但这说明了一个最重要的点，

67
00:03:23,420 --> 00:03:26,750
关于使用并发来构建程序意味着什么。

68
00:03:27,570 --> 00:03:31,080
在设计并发程序时，一种反复出现的决定，

69
00:03:31,230 --> 00:03:34,980
是将状态表示为代码还是数据。

70
00:03:35,220 --> 00:03:37,980
作为代码，我指的是程序中的控制流，

71
00:03:38,780 --> 00:03:41,240
假设从文件中读取字符，

72
00:03:41,270 --> 00:03:44,000
我们需要扫描一个 C 样式的引号字符串。

73
00:03:44,180 --> 00:03:46,190
哦，你好，幻灯片没有变。

74
00:03:46,340 --> 00:03:47,630
是的，它会的，

75
00:03:47,630 --> 00:03:50,660
你现在能看到 goroutines 状态的序言吗？

76
00:03:50,690 --> 00:03:51,920
不，我们看到标题幻灯片。

77
00:03:52,190 --> 00:03:54,500
哦，不，是的，我在想这个问题，

78
00:03:54,500 --> 00:03:58,190
因为当我开始时，这里有一个[边框]环绕着，

79
00:03:58,190 --> 00:03:59,600
然后它就消失了。

80
00:04:00,220 --> 00:04:03,070
所以，让我先取消分享，再重新分享。

81
00:04:04,280 --> 00:04:07,740
我必须弄清楚如何在 Zoom 中做这个。

82
00:04:10,760 --> 00:04:12,980
不幸的是， Keynote 菜单想要打开，

83
00:04:12,980 --> 00:04:14,570
我不知道怎么才能进入 Zoom 菜单。

84
00:04:19,880 --> 00:04:22,040
啊，我的屏幕分享暂停了，

85
00:04:22,040 --> 00:04:23,600
为什么我的屏幕分享暂停了，

86
00:04:24,930 --> 00:04:26,100
我可以继续吗，

87
00:04:26,600 --> 00:04:27,620
我们开始吧。

88
00:04:27,650 --> 00:04:29,210
好的，我不知道，

89
00:04:29,240 --> 00:04:31,160
Zoom 说你的屏幕分享暂停了，

90
00:04:31,160 --> 00:04:31,850
所以，

91
00:04:31,850 --> 00:04:33,050
现在边框又回来了，

92
00:04:33,050 --> 00:04:34,040
所以我会看的。

93
00:04:35,630 --> 00:04:40,030
好的，我回到了这里，

94
00:04:40,060 --> 00:04:42,160
所以你读取一个字符串，

95
00:04:42,520 --> 00:04:43,690
这不是并行程序，

96
00:04:43,690 --> 00:04:44,950
一次读取一个字符，

97
00:04:44,950 --> 00:04:46,510
没有并行的机会，

98
00:04:46,510 --> 00:04:48,520
但这是一个很好的并发机会。

99
00:04:48,940 --> 00:04:52,660
所以我们并不关心字符串中的确切转义序列，

100
00:04:52,960 --> 00:04:55,450
我们需要做的就是匹配这个正则表达式，

101
00:04:55,880 --> 00:04:58,070
我们不必担心要准确地理解，

102
00:04:58,100 --> 00:04:59,210
我们会回到它的意思上，

103
00:04:59,210 --> 00:05:02,450
但你所要做的就是实现这个正则表达式。

104
00:05:02,960 --> 00:05:04,790
你们可能都知道，

105
00:05:04,790 --> 00:05:07,100
你可以将正则表达式转换为状态机，

106
00:05:07,280 --> 00:05:10,100
所以，我们可能会使用一个工具来生成这些代码，

107
00:05:10,950 --> 00:05:13,290
在这段代码中，只有一个变量状态，

108
00:05:13,320 --> 00:05:14,730
那就是机器的状态，

109
00:05:14,910 --> 00:05:17,700
循环遍历 state 一次一个字符，

110
00:05:17,700 --> 00:05:19,380
根据状态读取字符，

111
00:05:19,380 --> 00:05:21,270
并且字符转为不同的状态，

112
00:05:21,510 --> 00:05:22,620
直到它到达结尾，

113
00:05:23,100 --> 00:05:25,530
所以这是一个完全不可读的程序，

114
00:05:25,770 --> 00:05:26,610
但这是一种东西，

115
00:05:26,610 --> 00:05:28,890
自动生成的程序可能看起来的样子。

116
00:05:29,360 --> 00:05:33,110
重要的一点是，程序状态存储在数据中，

117
00:05:33,110 --> 00:05:34,730
在这个变量中，称为状态，

118
00:05:35,270 --> 00:05:38,690
如果你可以将其更改为将状态存储在代码中，

119
00:05:38,990 --> 00:05:40,280
这通常会更清楚。

120
00:05:41,260 --> 00:05:42,490
所以我的意思是，

121
00:05:42,880 --> 00:05:47,590
假设我们重复 readChar 调用到 switch 的每个 case 中，

122
00:05:47,890 --> 00:05:49,840
所以在这里我们没有做任何语义上的改变，

123
00:05:49,840 --> 00:05:52,780
我们只是将顶部的 readChar 移到了中间。

124
00:05:53,940 --> 00:05:57,870
现在，不是设置 state ，然后立即执行 switch ，

125
00:05:57,900 --> 00:05:59,820
我们可以把它们改成 goto ，

126
00:06:01,920 --> 00:06:03,930
然后我们可以进一步简化一点，

127
00:06:03,930 --> 00:06:05,070
这里有一个 goto state1 ，

128
00:06:05,070 --> 00:06:06,690
正好在 state1 标签之前，

129
00:06:06,690 --> 00:06:07,650
我们可以去掉它。

130
00:06:08,340 --> 00:06:11,210
然后，我想，

131
00:06:11,210 --> 00:06:14,810
是的，这里只有一种方法到达 state2 ，

132
00:06:14,840 --> 00:06:16,520
所以，我们不妨将 state2 代码拉上来，

133
00:06:16,520 --> 00:06:18,890
并将其放到 goto 出现的 if 中，

134
00:06:19,340 --> 00:06:23,300
然后，现在 if 的两边最终都到 goto state1 ，

135
00:06:23,510 --> 00:06:24,920
所以，我们可以把它拿出来。

136
00:06:25,440 --> 00:06:28,560
现在剩下的是一个非常简单的程序，

137
00:06:28,590 --> 00:06:30,240
state0 永远不会跳入，

138
00:06:30,240 --> 00:06:31,680
所以它只是从那里开始，

139
00:06:31,830 --> 00:06:33,630
然后 state1 只是一个常规循环，

140
00:06:33,660 --> 00:06:36,180
所以我们不妨让它看起来像一个常规的循环。

141
00:06:37,240 --> 00:06:40,930
现在，这看起来像是一个程序，

142
00:06:41,320 --> 00:06:44,050
最后，我们可以去掉一些变量，

143
00:06:44,080 --> 00:06:45,700
进一步简化。

144
00:06:46,280 --> 00:06:48,230
然后，我们可以旋转循环，

145
00:06:48,230 --> 00:06:51,140
我们不会在循环中间返回 true ，

146
00:06:51,140 --> 00:06:52,610
我们在结束时返回 true 。

147
00:06:54,220 --> 00:06:56,200
所以现在我们有了这个程序，

148
00:06:56,200 --> 00:06:59,230
它相当不错，

149
00:06:59,230 --> 00:07:01,180
值得一提的是，

150
00:07:01,210 --> 00:07:03,970
有可能清理不那么令人震惊的例子，

151
00:07:03,970 --> 00:07:05,800
如果你试着手写这个，

152
00:07:05,980 --> 00:07:08,260
你的第一次尝试可能是左边的东西，

153
00:07:08,320 --> 00:07:10,240
你得到了这个额外的状态，

154
00:07:10,420 --> 00:07:13,150
然后，你可以应用相同类型的转换

155
00:07:13,150 --> 00:07:15,910
将状态移动到实际的控制流中，

156
00:07:16,030 --> 00:07:18,700
最终，同一个程序会变成右边这样，

157
00:07:18,700 --> 00:07:19,360
这个程序更清楚。

158
00:07:20,000 --> 00:07:23,630
所以这是一个有用的转换，

159
00:07:23,900 --> 00:07:24,980
任何时候你有状态，

160
00:07:24,980 --> 00:07:28,820
这看起来像是在[重申]，

161
00:07:28,820 --> 00:07:30,650
程序计数器里发生了什么。

162
00:07:31,760 --> 00:07:37,220
所以你可以看到，如果是原始 state ，

163
00:07:37,220 --> 00:07:38,330
如果 state 等于 0 ，

164
00:07:38,330 --> 00:07:40,310
程序计数器在函数的开始处，

165
00:07:40,430 --> 00:07:43,880
如果 state 等于 1 或者如果 inEscape 等于 false 或其他版本，

166
00:07:44,060 --> 00:07:46,040
程序计数器就在 for 循环内，

167
00:07:46,040 --> 00:07:48,470
而 state 等于 2 在 for 循环中更靠下。

168
00:07:49,040 --> 00:07:52,040
这样写而不是使用 state 的好处，

169
00:07:52,070 --> 00:07:53,780
是它更容易理解，

170
00:07:54,140 --> 00:07:56,960
比如我可以浏览代码并向你解释，

171
00:07:56,960 --> 00:07:58,490
如果你通读代码，

172
00:07:58,490 --> 00:08:01,040
你读到一个左括号，然后开始循环，

173
00:08:01,040 --> 00:08:02,780
然后直到你找到右括号，

174
00:08:02,780 --> 00:08:03,620
你读取一个字符，

175
00:08:03,620 --> 00:08:04,490
如果下一个字符是反斜杠，

176
00:08:04,490 --> 00:08:05,510
你就跳过下一个字符，

177
00:08:05,510 --> 00:08:06,260
这就对了，

178
00:08:06,260 --> 00:08:07,580
你可以从纸上读它，

179
00:08:07,580 --> 00:08:09,500
这是你在原始（代码）中做不到的。

180
00:08:10,790 --> 00:08:13,190
这个版本也碰巧运行得更快，

181
00:08:13,190 --> 00:08:15,320
尽管这对我们来说并不重要。

182
00:08:17,270 --> 00:08:17,870
但正如我提到的，

183
00:08:17,870 --> 00:08:20,150
我将强调我认为重要的教训，

184
00:08:20,150 --> 00:08:22,070
作为设计你自己的 Go 程序的提示，

185
00:08:22,070 --> 00:08:23,150
这是第一个，

186
00:08:23,360 --> 00:08:25,970
将数据状态转换为代码状态，

187
00:08:26,000 --> 00:08:27,830
它会使你的代码更清楚。

188
00:08:28,660 --> 00:08:30,910
再说一次，这些都是暗示，

189
00:08:31,180 --> 00:08:33,310
对于所有这些，

190
00:08:33,310 --> 00:08:34,600
你应该考虑它，

191
00:08:34,600 --> 00:08:36,220
你确定它有帮助的时候。

192
00:08:38,260 --> 00:08:40,360
所以，这个提示的一个问题是，

193
00:08:40,360 --> 00:08:45,220
并不是所有的程序都有权完全控制它们的控制流，

194
00:08:45,550 --> 00:08:47,890
所以这里有一个不同的例子，

195
00:08:47,890 --> 00:08:50,650
不是有一个可以调用的 readChar 函数，

196
00:08:50,830 --> 00:08:53,950
这个代码是使用 ProcessChar 方法，

197
00:08:53,950 --> 00:08:56,470
你必须一次传递给一个字符，

198
00:08:57,010 --> 00:08:59,590
然后 ProcessChar 别无选择，

199
00:08:59,680 --> 00:09:03,310
只能编码 state 到一个显示的 state 变量，

200
00:09:03,310 --> 00:09:06,160
因为在每个字符之后，它必须返回，

201
00:09:06,460 --> 00:09:09,430
所以它不能保存 state 在程序计数器和栈中，

202
00:09:09,430 --> 00:09:12,430
它必须有 state 在实际变量中。

203
00:09:13,550 --> 00:09:16,790
但是在 Go 中，我们有另一个选择，

204
00:09:16,790 --> 00:09:20,390
因为我们不能把 state 保存到栈和程序计数器中，

205
00:09:20,750 --> 00:09:24,500
但我们可以创建另一个 goroutine 为我们保持状态。

206
00:09:25,490 --> 00:09:28,850
所以，假设我们已经有这个调试 readString 函数，

207
00:09:29,120 --> 00:09:32,030
我们不想以其他方式重写，

208
00:09:32,060 --> 00:09:32,900
我们只是想重复使用它，

209
00:09:32,900 --> 00:09:33,830
它可以工作，

210
00:09:33,830 --> 00:09:35,120
也许它很大很复杂，

211
00:09:35,120 --> 00:09:37,130
它比我们看到的任何东西都要复杂，

212
00:09:37,310 --> 00:09:38,540
我们只是想重复使用它。

213
00:09:38,870 --> 00:09:40,640
所以，我们在 Go 中做到的方法是，

214
00:09:40,640 --> 00:09:43,820
我们可以启动一个新的 goroutine 来完成 readString 部分，

215
00:09:43,820 --> 00:09:45,980
readString 与之前相同，

216
00:09:45,980 --> 00:09:47,600
我们传递[字符读取]。

217
00:09:48,070 --> 00:09:55,210
现在， Init 方法使这个 goroutine 执行字符读取，

218
00:09:55,210 --> 00:09:59,050
然后，每次调用 ProcessChar 方法时，

219
00:10:00,250 --> 00:10:02,980
我们通过 char channel 发送一个消息给 goroutine ，

220
00:10:02,980 --> 00:10:04,960
表示这是下一个字符，

221
00:10:05,230 --> 00:10:06,700
然后我们收到一条消息，

222
00:10:06,700 --> 00:10:08,320
表示告诉我当前的 status ，

223
00:10:08,320 --> 00:10:09,580
当前 status 总是，

224
00:10:09,580 --> 00:10:11,260
要么是我需要更多的输入

225
00:10:11,590 --> 00:10:15,760
或者它是不是好的。

226
00:10:16,620 --> 00:10:19,070
所以，

227
00:10:19,070 --> 00:10:22,580
这让我们可以移动程序计数器，

228
00:10:22,580 --> 00:10:24,440
那个我们不能在第一个栈上完成的，

229
00:10:24,440 --> 00:10:26,120
到 goroutine 的另一个栈中。

230
00:10:26,360 --> 00:10:30,770
所以，使用额外的 goroutine 是保存额外代码状态的好方法，

231
00:10:30,770 --> 00:10:33,680
并让你有能力进行这种清理，

232
00:10:33,830 --> 00:10:37,730
即使问题的原始结构看起来做不到。

233
00:10:40,600 --> 00:10:41,080
Russ 。

234
00:10:42,160 --> 00:10:42,760
继续。

235
00:10:42,760 --> 00:10:46,360
我想你不介意别人问你问题。

236
00:10:46,390 --> 00:10:47,140
是的，当然。

237
00:10:47,140 --> 00:10:48,190
我只是想确认一下。

238
00:10:48,550 --> 00:10:50,590
是的，当然可以，请随意打断。

239
00:10:51,070 --> 00:10:53,770
所以，这里的提示是

240
00:10:53,770 --> 00:10:56,920
使用额外的 goroutine 来保存额外的代码状态，

241
00:10:57,190 --> 00:10:59,770
但有一点需要注意，

242
00:10:59,770 --> 00:11:03,220
创建 goroutine 不是免费的，

243
00:11:03,220 --> 00:11:04,840
你必须确保它们退出，

244
00:11:04,930 --> 00:11:06,640
否则，你会把它们累积起来。

245
00:11:07,080 --> 00:11:08,610
所以你必须考虑，

246
00:11:08,910 --> 00:11:10,890
为什么 goroutine 会离开，

247
00:11:10,890 --> 00:11:13,050
比如它会被清理干净吗。

248
00:11:13,230 --> 00:11:14,430
在这种情况下，

249
00:11:14,830 --> 00:11:18,490
我们知道 q.parse 将会返回，

250
00:11:19,480 --> 00:11:20,560
q.parse 在哪里。

251
00:11:22,390 --> 00:11:24,370
抱歉，这不对。

252
00:11:26,420 --> 00:11:27,680
哦，抱歉，这里的 readString ，

253
00:11:27,680 --> 00:11:28,700
readString 会返回，

254
00:11:28,700 --> 00:11:31,910
任何时候它发送一个消息，表示需要更多输入。

255
00:11:32,450 --> 00:11:34,580
在哪里，这张幻灯片遗漏了一些东西。

256
00:11:38,600 --> 00:11:41,060
抱歉，我昨晚才写的这些。

257
00:11:43,870 --> 00:11:46,300
所以当我们进去的时候，我们进入了 Init ，

258
00:11:46,720 --> 00:11:47,830
我们启动这个 goroutine ，

259
00:11:47,830 --> 00:11:49,840
它将多次调用 ReadChar ，

260
00:11:49,840 --> 00:11:51,400
然后我们读取一次 status ，

261
00:11:51,400 --> 00:11:53,590
第一个 status 就会发生，

262
00:11:53,620 --> 00:11:57,340
因为第一次调用 readString 的 ReadChar

263
00:11:57,340 --> 00:11:58,600
会说我需要更多的输入，

264
00:11:58,600 --> 00:12:00,010
然后我们会发回一个字符，

265
00:12:01,080 --> 00:12:03,780
我们会在 ProcessChar 中发回字符，

266
00:12:04,110 --> 00:12:07,770
然后，每次调用 ProcessChar 时，它返回一个 status ，

267
00:12:07,830 --> 00:12:11,340
所以直到你需要更多的输入，

268
00:12:11,340 --> 00:12:12,630
你会得到。

269
00:12:15,000 --> 00:12:16,200
抱歉，这不起作用，

270
00:12:16,560 --> 00:12:20,100
每次你想读取一个字符时，都会得到更多的输入。

271
00:12:20,850 --> 00:12:22,350
然后当它完成读取字符后，

272
00:12:22,350 --> 00:12:25,830
我在这里没有展示的，似乎是遗漏的东西，

273
00:12:25,860 --> 00:12:29,370
当事情退出时。

274
00:12:29,670 --> 00:12:30,900
让我们看看，它是否在这张幻灯片上。

275
00:12:31,200 --> 00:12:33,930
是的，所以有一个 return Success 和一个 return BadInput ，

276
00:12:33,930 --> 00:12:34,980
这是我忘记的。

277
00:12:35,480 --> 00:12:39,050
所以，这些返回不同的 status ，然后就完成了。

278
00:12:39,680 --> 00:12:41,420
所以，当 ProcessChar ，

279
00:12:41,510 --> 00:12:44,270
在 readString 版本中，

280
00:12:44,330 --> 00:12:47,180
当它返回 BadInput 或 Success 时，

281
00:12:47,180 --> 00:12:48,650
这件事已经完成了。

282
00:12:48,650 --> 00:12:52,580
当调用者继续，

283
00:12:53,520 --> 00:12:57,930
调用直到它得到一些东西，不需要更多输入，

284
00:12:58,080 --> 00:12:59,940
然后 goroutine 就会结束，

285
00:12:59,940 --> 00:13:01,890
但是如果我们早点停止，

286
00:13:01,890 --> 00:13:04,350
如果调用者遇到 EOF 并自动停止，

287
00:13:04,350 --> 00:13:06,000
没有告诉我们已经完成，

288
00:13:06,030 --> 00:13:07,620
会有一个 goroutine 剩下，

289
00:13:07,680 --> 00:13:09,030
所以，这会是一个问题。

290
00:13:09,610 --> 00:13:11,200
所以你需要确保，

291
00:13:11,200 --> 00:13:14,230
什么时候以及为什么 goroutine 会退出，

292
00:13:14,710 --> 00:13:16,180
好的是，

293
00:13:16,180 --> 00:13:17,500
如果你出现一个错误，

294
00:13:17,680 --> 00:13:19,090
你让 goroutine 卡住了，

295
00:13:19,300 --> 00:13:20,350
它们只是在那里，

296
00:13:20,350 --> 00:13:22,330
像是世界上最好的 bug ，

297
00:13:22,330 --> 00:13:24,400
因为它们只是在那里，等着你看它们，

298
00:13:24,400 --> 00:13:25,990
你要做的就是记住去寻找它们。

299
00:13:26,380 --> 00:13:28,810
所以这是一个非常简单的程序，

300
00:13:29,270 --> 00:13:31,910
这些 goroutine 运行一个 http 服务，

301
00:13:32,150 --> 00:13:34,010
如果我们运行这个程序，

302
00:13:34,040 --> 00:13:36,140
它会启动很多 f goroutine ，

303
00:13:36,200 --> 00:13:38,960
它们都会阻塞尝试发送到一个 channel ，

304
00:13:39,020 --> 00:13:40,520
然后它成为 http 服务器。

305
00:13:40,990 --> 00:13:43,360
所以如果我运行这个程序，它就会停在那里，

306
00:13:43,570 --> 00:13:45,970
如果我在 Unix 系统上输入 ^\ ，

307
00:13:45,970 --> 00:13:47,050
我得到一个 SIGQUIT ，

308
00:13:47,410 --> 00:13:50,380
这使它崩溃，并 dump 出 goroutine 上的所有栈。

309
00:13:50,590 --> 00:13:51,910
你可以在幻灯片上看到，

310
00:13:51,910 --> 00:13:53,680
它会一遍又一遍地打印，

311
00:13:53,680 --> 00:13:56,110
这是一个 goroutine ， h 调用自 g 调用自 f ，

312
00:13:56,570 --> 00:13:57,920
在 channel send 中。

313
00:13:58,970 --> 00:14:00,140
如果你看一下行号，

314
00:14:00,140 --> 00:14:01,640
你可以确切地看到它们在哪里。

315
00:14:02,740 --> 00:14:04,060
另一种选择是，

316
00:14:04,060 --> 00:14:05,860
因为我们是在 http 服务器中，

317
00:14:06,560 --> 00:14:10,430
http 服务器导入了 net http pprof 包，

318
00:14:10,520 --> 00:14:14,720
你可以访问 http 服务器的 /debug/pprof/goroutine 链接，

319
00:14:15,210 --> 00:14:17,790
这会给你所有运行的 goroutine 的堆栈，

320
00:14:17,970 --> 00:14:19,470
与 crash dump 不同，

321
00:14:19,500 --> 00:14:20,880
它做了更多的努力，

322
00:14:20,880 --> 00:14:23,880
它根据它们的堆栈复制 goroutine ，

323
00:14:24,090 --> 00:14:27,600
然后根据每个堆栈的[数量]对它们进行排序，

324
00:14:27,600 --> 00:14:29,070
所以如果你有 goroutine [泄漏]，

325
00:14:29,370 --> 00:14:30,990
[泄漏]出现在最高层。

326
00:14:30,990 --> 00:14:31,620
在本例中，

327
00:14:31,620 --> 00:14:33,180
你获得 100 个 goroutine 堆栈，

328
00:14:33,180 --> 00:14:35,070
h 调用自 g 调用自 f ，

329
00:14:35,310 --> 00:14:37,860
然后我们可以看到还有其他 goroutine ，

330
00:14:37,860 --> 00:14:39,000
我们并不是关心它们。

331
00:14:39,670 --> 00:14:41,200
所以这是一个新的暗示，

332
00:14:41,470 --> 00:14:43,180
它非常有用，

333
00:14:43,180 --> 00:14:46,420
通过这个端点获取 goroutine 堆栈。

334
00:14:48,240 --> 00:14:51,240
好的，这算是热身了。

335
00:14:51,720 --> 00:14:54,330
现在我想看看第一个真正的并发模式，

336
00:14:54,330 --> 00:14:55,830
就是发布订阅服务器。

337
00:14:56,690 --> 00:14:59,330
发布订阅是组织程序的一种方式，

338
00:14:59,450 --> 00:15:00,800
你将不同部分解耦，

339
00:15:00,800 --> 00:15:04,400
将发布有趣事件的部分与订阅它们的部分（解耦），

340
00:15:04,520 --> 00:15:08,420
中间有一个发布订阅服务器，连接这些，

341
00:15:08,450 --> 00:15:11,150
所以，单独的发布者和订阅者

342
00:15:11,150 --> 00:15:13,760
不需要知道其他的确切身份。

343
00:15:14,540 --> 00:15:16,520
比如在你的安卓手机上，

344
00:15:16,670 --> 00:15:19,070
一个应用可能发出电话呼叫事件，

345
00:15:19,070 --> 00:15:21,440
然后拨号可能会订阅它，

346
00:15:21,440 --> 00:15:23,420
然后开始帮助拨号。

347
00:15:24,800 --> 00:15:26,420
所以，在真正的发布订阅服务器上，

348
00:15:26,420 --> 00:15:29,030
有方法可以根据事件的类型过滤事件，

349
00:15:29,030 --> 00:15:31,190
当你发布一个电话事件时，

350
00:15:31,190 --> 00:15:32,840
它不会进入你的电子邮件程序。

351
00:15:33,200 --> 00:15:34,220
但是现在，

352
00:15:34,220 --> 00:15:37,190
我们只假设过滤是单独处理的，

353
00:15:37,220 --> 00:15:40,310
我们只是考虑发布和订阅，

354
00:15:41,070 --> 00:15:42,360
以及它的并发性。

355
00:15:43,020 --> 00:15:45,210
所以这是我们想要实现的 API ，

356
00:15:45,980 --> 00:15:47,300
任意数量的客户端，

357
00:15:47,300 --> 00:15:49,580
可以调用 Subscribe 使用一个 channel ，

358
00:15:49,850 --> 00:15:53,720
之后，发布的事件将发送到那个 channel ，

359
00:15:54,480 --> 00:15:56,580
然后当客户端不再感兴趣时，

360
00:15:56,640 --> 00:15:59,190
它可以调用 Cancel 并传递相同的 channel ，

361
00:15:59,220 --> 00:16:01,830
表示停止向那个 channel 发送事件，

362
00:16:02,250 --> 00:16:04,020
而 Cancel 的方式将发出信号，

363
00:16:04,020 --> 00:16:06,510
当它完成发送事件到那个 channel ，

364
00:16:06,510 --> 00:16:07,890
它将关闭那个 channel ，

365
00:16:08,070 --> 00:16:11,310
这样接收方呼叫方可以继续接收事件，

366
00:16:11,310 --> 00:16:12,900
直到它看到 channel 关闭，

367
00:16:12,900 --> 00:16:14,940
然后它知道 Cancel 已经生效。

368
00:16:18,020 --> 00:16:22,580
所以注意到信息只在 channel 上单向流动，

369
00:16:22,580 --> 00:16:24,530
你可以发送到 channel ，

370
00:16:24,800 --> 00:16:26,810
然后接收者可以从它那里接收，

371
00:16:26,810 --> 00:16:29,180
信息从发送者流向接收者，

372
00:16:29,180 --> 00:16:30,440
它从来不会走另一条路。

373
00:16:30,470 --> 00:16:34,640
所以关闭也是发送者给接收者的信号，

374
00:16:34,640 --> 00:16:36,260
但是所有的发送都结束了，

375
00:16:36,620 --> 00:16:38,390
接收者不能关闭 channel

376
00:16:38,390 --> 00:16:40,760
告诉发送者我不希望你继续发送，

377
00:16:40,790 --> 00:16:43,190
因为这是相反方向的信息。

378
00:16:43,830 --> 00:16:45,780
所以这会更简单，

379
00:16:45,900 --> 00:16:48,060
如果信息只有一个方向，

380
00:16:48,180 --> 00:16:51,780
当然，如果你需要双向通信，

381
00:16:51,780 --> 00:16:53,370
你可以使用两个 channel ，

382
00:16:53,430 --> 00:16:54,900
事实往往是，

383
00:16:54,900 --> 00:16:59,010
这些不同的方向可能有不同类型的数据流动，

384
00:16:59,070 --> 00:17:00,330
就像我们之前看到的，

385
00:17:00,330 --> 00:17:01,680
runes 是一个方向，

386
00:17:01,680 --> 00:17:03,600
status 更新是另一个方向。

387
00:17:04,560 --> 00:17:07,320
那么我们如何实现这个 API ，

388
00:17:07,870 --> 00:17:09,940
这里有一个非常基本的实现，

389
00:17:09,940 --> 00:17:11,290
它可能已经足够好了。

390
00:17:11,910 --> 00:17:13,020
我们有一个 Server ，

391
00:17:13,200 --> 00:17:16,740
Server 状态是注册发布者的 map ，

392
00:17:16,740 --> 00:17:17,970
由锁保护，

393
00:17:18,630 --> 00:17:21,510
我们初始化 Server 通过分配 map ，

394
00:17:22,210 --> 00:17:23,590
然后，为了发布事件，

395
00:17:23,620 --> 00:17:26,110
我们只需把它发送到每个注册 channel ，

396
00:17:27,060 --> 00:17:28,380
为了订阅新 channel ，

397
00:17:28,380 --> 00:17:29,640
我们只需把它添加到 map ，

398
00:17:29,850 --> 00:17:31,770
为了取消，我们把它从 map 中删除。

399
00:17:32,370 --> 00:17:33,960
然后，因为这些都是，

400
00:17:34,110 --> 00:17:37,740
这些都是可以从多个 goroutine 调用的方法，

401
00:17:38,190 --> 00:17:44,400
我们需要调用 lock 和 unlock 来保护 map ，

402
00:17:44,890 --> 00:17:48,310
注意我在 lock 之后写了 defer unlock ，

403
00:17:48,460 --> 00:17:50,470
这样我就不用记得之后 unlock 了，

404
00:17:51,080 --> 00:17:52,550
你们可能都见过这个，

405
00:17:52,550 --> 00:17:54,800
一个不错的 lock unlock 的习惯用法，

406
00:17:54,800 --> 00:17:56,270
然后我有一个空行，

407
00:17:56,270 --> 00:17:58,550
让它在代码中有自己的段落。

408
00:18:02,620 --> 00:18:05,050
我想指出的一件事是，

409
00:18:05,050 --> 00:18:07,540
使用 defer 可以确保 mutex 被解锁，

410
00:18:07,660 --> 00:18:09,610
即使函数有多个返回值，

411
00:18:09,610 --> 00:18:10,660
所以你不会忘记，

412
00:18:10,870 --> 00:18:13,960
但它也能确保，在你出现 panic 时，会被解锁，

413
00:18:14,170 --> 00:18:15,940
比如在 Subscribe 和 Cancel 中，

414
00:18:15,970 --> 00:18:18,280
有 panic 的滥用。

415
00:18:19,010 --> 00:18:20,900
这里有一个微妙的地方，

416
00:18:21,230 --> 00:18:23,150
如果你可能不想解锁 mutex ，

417
00:18:23,150 --> 00:18:24,620
如果 panic 发生在，

418
00:18:24,620 --> 00:18:27,500
被锁定的东西处于某种不一致的状态时，

419
00:18:27,650 --> 00:18:29,480
但我暂时忽略这一点，

420
00:18:29,870 --> 00:18:35,460
一般来说，你尽量避免发生可能会引起 panic 的事情，

421
00:18:35,460 --> 00:18:37,710
当你可能处于不一致的状态时。

422
00:18:38,700 --> 00:18:40,110
我还要指出，

423
00:18:40,110 --> 00:18:43,230
在 Subscribe 和 Cancel 中使用 panic ，

424
00:18:43,350 --> 00:18:46,830
隐含你信任你的客户端不会滥用该接口，

425
00:18:46,830 --> 00:18:48,450
这是一个程序错误，

426
00:18:48,450 --> 00:18:52,980
值得拆解整个程序，才有可能发生这种情况。

427
00:18:53,630 --> 00:18:57,050
在一个更大的程序中，其他客户端正在使用这个 API ，

428
00:18:57,580 --> 00:18:59,470
你可能希望返回一个错误，

429
00:18:59,740 --> 00:19:02,350
而不会可能让整个程序停止，

430
00:19:02,470 --> 00:19:04,600
但目前， panic 让事情变得简单了，

431
00:19:05,200 --> 00:19:08,350
错误处理不是今天的主题。

432
00:19:10,930 --> 00:19:13,870
与 panic 相比，这个代码更重要的问题是，

433
00:19:13,870 --> 00:19:18,040
如果 goroutine 接收事件的速度很慢，会发生什么？

434
00:19:18,630 --> 00:19:21,600
所以这里的所有操作都完成了持有 mutex ，

435
00:19:21,600 --> 00:19:24,660
这意味着所有的客户端都必须步调一致。

436
00:19:25,210 --> 00:19:29,800
所以在 Publish 中，有一个循环在 channel 发送，

437
00:19:29,860 --> 00:19:31,420
将事件发送到每个 channel ，

438
00:19:31,450 --> 00:19:33,730
如果一个订阅者落后了，

439
00:19:33,850 --> 00:19:35,500
下一位订阅者不会收到事件，

440
00:19:35,500 --> 00:19:37,660
直到缓慢的订阅者醒来，

441
00:19:37,660 --> 00:19:40,570
并从 channel 上获取事件。

442
00:19:41,120 --> 00:19:44,540
所以，一个速度慢的订阅者可能会拖慢其他所有人的速度，

443
00:19:44,810 --> 00:19:48,980
强迫它们这样步调一致地进行并不总是一个问题，

444
00:19:49,490 --> 00:19:51,770
如果你记录了限制，

445
00:19:51,770 --> 00:19:54,860
无论出于什么原因，你知道客户端是如何编写的，

446
00:19:55,010 --> 00:19:57,380
你知道它们永远不会落后太多，

447
00:19:57,470 --> 00:19:58,700
这可能完全没问题，

448
00:19:58,700 --> 00:20:00,380
这是一个非常简单的实现，

449
00:20:01,150 --> 00:20:03,610
而且它有很好的属性，

450
00:20:03,610 --> 00:20:05,110
比如从 Publish 返回，

451
00:20:05,110 --> 00:20:08,890
你知道事件已经被移交给其他每个 goroutine ，

452
00:20:09,040 --> 00:20:10,750
你不知道它们已经开始处理了，

453
00:20:10,750 --> 00:20:12,070
但你知道它已经被转手了。

454
00:20:12,560 --> 00:20:15,230
所以，也许这已经足够好了，你可以停在这里。

455
00:20:16,340 --> 00:20:17,840
第二种选择是，

456
00:20:18,200 --> 00:20:22,190
如果你需要容忍订阅者稍微慢一点的话，

457
00:20:22,220 --> 00:20:23,690
然后你可以说，

458
00:20:23,690 --> 00:20:25,490
它们需要为你提供一个缓冲区 channel ，

459
00:20:25,490 --> 00:20:27,710
有空间在缓冲中有一些事件，

460
00:20:27,770 --> 00:20:30,050
这样当你发布的时候，

461
00:20:30,610 --> 00:20:32,170
只要它们不在太远的后面，

462
00:20:32,170 --> 00:20:36,070
总是有空间让新事件进入 channel 缓冲区，

463
00:20:36,160 --> 00:20:38,770
然后， Publish 不会阻塞太长事件。

464
00:20:39,600 --> 00:20:40,980
再说一次，也许这已经足够好了，

465
00:20:41,010 --> 00:20:43,530
如果你确定它们永远不会落后太多，

466
00:20:43,740 --> 00:20:44,940
你可以到此为止。

467
00:20:45,780 --> 00:20:47,580
但是在一个非常大的项目中，

468
00:20:48,350 --> 00:20:53,180
你希望更优雅地处理任意缓慢的订阅者，

469
00:20:53,180 --> 00:20:55,010
所以接下来的问题是你会做什么。

470
00:20:55,610 --> 00:20:57,770
通常你有三个选择，

471
00:20:57,860 --> 00:20:59,750
你可以降低事件生成器的速度，

472
00:20:59,780 --> 00:21:02,870
这是以前的解决方案隐含的做法，

473
00:21:02,870 --> 00:21:06,560
因为发布停止，直到订阅者跟上。

474
00:21:07,230 --> 00:21:08,760
或者你可以删除事件，

475
00:21:08,940 --> 00:21:11,850
也可以对任意数量的过去事件进行排队，

476
00:21:11,850 --> 00:21:13,620
这几乎是你唯一的选择。

477
00:21:14,350 --> 00:21:18,490
所以我们讨论了发布和减慢事件生成器的速度。

478
00:21:19,060 --> 00:21:20,020
有一个中间立场，

479
00:21:20,020 --> 00:21:23,020
你可以合并这些事件，也可以丢弃它们，

480
00:21:24,100 --> 00:21:27,820
这样订阅者可能会发现，

481
00:21:27,910 --> 00:21:29,200
嘿，你错过了一些事件，

482
00:21:29,200 --> 00:21:30,250
我不能告诉你它们是什么，

483
00:21:30,250 --> 00:21:31,180
因为我没有保存它们，

484
00:21:31,180 --> 00:21:33,760
但我至少要告诉你，你错过了五个事件，

485
00:21:34,180 --> 00:21:36,790
然后，也许它可以做一些事情来试图赶上。

486
00:21:37,510 --> 00:21:41,230
这是我们在 profiler 中采用的方法，

487
00:21:41,230 --> 00:21:43,090
在 profiler 中，如果你使用过它，

488
00:21:43,420 --> 00:21:43,840
如果，

489
00:21:43,990 --> 00:21:45,250
有一个 goroutine ，

490
00:21:45,250 --> 00:21:50,620
通过分析事件在一个信号处理器中填充了[分析]，

491
00:21:50,800 --> 00:21:52,120
然后有一个单独的 goroutine ，

492
00:21:52,120 --> 00:21:53,980
它的工作是读出数据，

493
00:21:53,980 --> 00:21:56,890
将其写入磁盘或发送到 http 请求，

494
00:21:56,890 --> 00:21:58,720
或者任何你使用分析数据所做的。

495
00:21:59,200 --> 00:22:00,970
这中间有一个缓冲区，

496
00:22:01,150 --> 00:22:04,780
如果来自分析数据的接收者落后，

497
00:22:04,990 --> 00:22:06,070
当缓冲区填满时，

498
00:22:06,070 --> 00:22:09,880
我们开始添加最终分析条目，

499
00:22:09,940 --> 00:22:11,770
它只有一个条目，

500
00:22:11,770 --> 00:22:15,130
它是一个函数名为 [runtime last profile data] ，

501
00:22:15,370 --> 00:22:16,930
所以如果你看一下 profile ，

502
00:22:16,930 --> 00:22:20,020
你看到程序花了 5% 的时间在[最后的]分析数据上，

503
00:22:20,110 --> 00:22:24,320
这意味着分析读取器太慢了，

504
00:22:24,320 --> 00:22:25,610
它没有跟上，

505
00:22:26,170 --> 00:22:27,430
我们丢失了一些 profile ，

506
00:22:27,430 --> 00:22:31,570
但我们很清楚知道 profile 中的错误率是多少，

507
00:22:31,690 --> 00:22:33,310
你几乎看不到这一点，

508
00:22:33,310 --> 00:22:35,230
因为所有的读取者都跟上了，

509
00:22:35,260 --> 00:22:36,790
但是为了防止它们没有，

510
00:22:37,030 --> 00:22:38,470
你有一个很清晰的信号。

511
00:22:39,960 --> 00:22:44,430
一个纯粹丢弃事件的例子是系统信号包，

512
00:22:44,460 --> 00:22:48,880
那里你必须通过一个 channel ，

513
00:22:48,880 --> 00:22:50,710
它做好接收信号的准备，

514
00:22:50,920 --> 00:22:53,290
像 SIGHUP 或 SIGQUIT 这样的信号，

515
00:22:53,990 --> 00:22:55,520
当信号进来的时候，

516
00:22:55,550 --> 00:22:59,000
运行时尝试向订阅这个信号的每个 channel 发送，

517
00:22:59,360 --> 00:23:00,530
如果它不能发送给它，

518
00:23:00,560 --> 00:23:02,630
它就不发送，它就会消失，

519
00:23:02,630 --> 00:23:04,820
因为在信号处理器里，我们不能等待，

520
00:23:05,120 --> 00:23:07,490
所以调用者必须做的是

521
00:23:07,490 --> 00:23:08,990
它们必须传递给缓冲 channel ，

522
00:23:09,080 --> 00:23:10,760
如果它们传递给缓冲 channel ，

523
00:23:10,820 --> 00:23:14,150
缓冲长度至少为 1 ，

524
00:23:14,540 --> 00:23:18,110
它们仅把 channel 注册到单个信号，

525
00:23:18,230 --> 00:23:21,590
那么如果有信号进来，

526
00:23:21,590 --> 00:23:23,120
你肯定会被告知这件事，

527
00:23:23,450 --> 00:23:24,710
如果它进来两次，

528
00:23:24,740 --> 00:23:26,480
你可能只会被告知一次，

529
00:23:26,510 --> 00:23:30,650
但这与 Unix 为信号处理提供的语义相同，

530
00:23:30,890 --> 00:23:31,760
所以这很好。

531
00:23:32,220 --> 00:23:35,610
所以，这两个都是放弃或合并事件的例子。

532
00:23:36,840 --> 00:23:38,460
然后第三种选择是，

533
00:23:38,550 --> 00:23:41,580
你可能不想丢掉任何事件，

534
00:23:41,580 --> 00:23:44,400
它可能很重要，你不能丢失任何东西，

535
00:23:44,610 --> 00:23:45,720
在这种情况下，

536
00:23:45,810 --> 00:23:48,210
你可以对任意数量的事件进行排队，

537
00:23:48,210 --> 00:23:50,970
你可以通过某种方式安排程序，

538
00:23:51,270 --> 00:23:55,620
保存慢订阅者没有看到的所有事件，

539
00:23:55,890 --> 00:23:57,960
稍后将它们提供给订阅者。

540
00:23:58,720 --> 00:24:01,090
在你这么做之前，仔细考虑一下是很重要的，

541
00:24:01,240 --> 00:24:03,040
因为在分布式系统中，

542
00:24:03,600 --> 00:24:05,190
总是有速度慢的计算机，

543
00:24:05,190 --> 00:24:08,340
总是有计算机下线或者别的什么，

544
00:24:08,340 --> 00:24:09,900
它们可能会离开一段时间，

545
00:24:10,020 --> 00:24:13,320
一般来说，你不想引入无界队列，

546
00:24:13,320 --> 00:24:15,300
在这样做之前，你需要非常仔细地考虑，

547
00:24:15,300 --> 00:24:19,050
想想，无界是多么的[]，我能忍受吗。

548
00:24:19,620 --> 00:24:24,120
所以，这就是为什么 channel 没有有无界缓冲的原因，

549
00:24:24,120 --> 00:24:26,160
这几乎从来都不是正确的选择，

550
00:24:26,160 --> 00:24:27,630
如果这是正确的选择，

551
00:24:27,660 --> 00:24:29,340
你可能要非常仔细地构建它。

552
00:24:30,580 --> 00:24:32,950
但是我们将构建一个，

553
00:24:32,980 --> 00:24:34,780
看看它会是什么样子。

554
00:24:35,950 --> 00:24:37,180
在此之前，

555
00:24:37,210 --> 00:24:39,640
我想稍微调整一下程序，

556
00:24:40,000 --> 00:24:42,640
所以我们在代码中有这个 mutex ，

557
00:24:43,000 --> 00:24:46,780
mutex 是保持状态的一个例子，

558
00:24:46,780 --> 00:24:49,150
你是否在状态变量中加锁，

559
00:24:49,390 --> 00:24:52,360
但我们也可以把它移到程序计数器变量中，

560
00:24:52,930 --> 00:24:54,640
把它放在不同的 goroutine 中。

561
00:24:55,200 --> 00:24:57,860
在本例中，

562
00:24:57,860 --> 00:24:59,450
我们可以启动一个新的 goroutine ，

563
00:24:59,600 --> 00:25:02,180
它运行一个名为 s.loop 的程序函数，

564
00:25:02,860 --> 00:25:05,530
它处理在三个新 channel 上发送的请求，

565
00:25:05,530 --> 00:25:07,150
publish subscribe 和 cancel 。

566
00:25:07,870 --> 00:25:08,740
在 Init 中，

567
00:25:08,770 --> 00:25:10,150
我们创建 channel ，

568
00:25:10,240 --> 00:25:12,400
然后启动 s.loop 。

569
00:25:13,140 --> 00:25:17,670
而 s.loop 则是前面方法体的一种合并，

570
00:25:17,760 --> 00:25:20,850
它从三个 channel 中的任何一个接收，

571
00:25:20,880 --> 00:25:23,670
publish subscribe 或 cancel 请求，

572
00:25:24,060 --> 00:25:25,740
它会做任何被要求的事情，

573
00:25:26,130 --> 00:25:31,770
现在 subscriber map 可以只是 s.loop 中的一个局部变量。

574
00:25:32,320 --> 00:25:35,050
所以这是相同的代码，

575
00:25:35,690 --> 00:25:38,840
但是现在这些数据显然归 s.loop 所有，

576
00:25:38,840 --> 00:25:40,100
其他任何东西都不能访问它，

577
00:25:40,100 --> 00:25:41,360
因为它是一个局部变量。

578
00:25:44,080 --> 00:25:46,570
然后，我们只需要更改原始方法，

579
00:25:46,570 --> 00:25:48,730
将工作发送到 loop goroutine ，

580
00:25:48,730 --> 00:25:53,650
大写的 Publish 现在发送给小写的 publish channel ，

581
00:25:53,800 --> 00:25:55,600
事件想要发送的（channel），

582
00:25:55,600 --> 00:25:57,730
类似地 subscribe 和 cancel 。

583
00:25:58,230 --> 00:26:01,110
它们创建具有 channel 的请求，

584
00:26:01,320 --> 00:26:02,940
我们想要订阅，

585
00:26:02,940 --> 00:26:05,040
也有一个 channel 可以获得回复，

586
00:26:05,220 --> 00:26:06,960
它们将其发送到循环中，

587
00:26:07,110 --> 00:26:08,850
循环返回答案。

588
00:26:12,040 --> 00:26:14,980
我将程序的这种转换方式称为

589
00:26:14,980 --> 00:26:17,470
将 mutex 转换为 goroutine ，

590
00:26:17,560 --> 00:26:19,660
因为我们获取了 mutex 的数据状态，

591
00:26:19,660 --> 00:26:21,100
里面有一个锁位，

592
00:26:21,100 --> 00:26:24,460
现在锁位隐含在循环的程序计数器中。

593
00:26:26,050 --> 00:26:26,860
很明显，

594
00:26:26,860 --> 00:26:30,820
发布和订阅不能同时发生，

595
00:26:30,850 --> 00:26:33,100
因为这只是单线程代码，

596
00:26:33,100 --> 00:26:34,990
只是序列执行。

597
00:26:36,660 --> 00:26:37,290
另一方面，

598
00:26:37,290 --> 00:26:40,620
原始版本有一种类似的状态清晰度，

599
00:26:40,620 --> 00:26:42,180
在那里你可以对它进行检查，

600
00:26:42,390 --> 00:26:45,030
推出这是一个重要的状态，

601
00:26:45,360 --> 00:26:49,530
在 goroutine 版本中，比较难看出什么是重要的状态，

602
00:26:49,530 --> 00:26:52,860
附带的状态是有一个 goroutine 。

603
00:26:53,680 --> 00:26:55,480
在给定的情况下，

604
00:26:55,540 --> 00:26:57,490
其中一个可能比另一个更重要，

605
00:26:57,850 --> 00:26:59,140
几年前，

606
00:26:59,140 --> 00:27:00,940
我做了所有的实验，

607
00:27:00,940 --> 00:27:02,200
当它换成 Go 的时候，

608
00:27:02,440 --> 00:27:04,600
raft 是一个很好的例子，

609
00:27:04,600 --> 00:27:07,810
你可能更喜欢使用 mutex 状态，

610
00:27:07,810 --> 00:27:12,280
因为 raft 与大多数并发程序非常不同，

611
00:27:12,280 --> 00:27:17,110
每个复制节点对自己的状态的不确定性，

612
00:27:17,110 --> 00:27:18,430
比如状态转换，

613
00:27:18,970 --> 00:27:20,590
一瞬间你是领导者，

614
00:27:20,590 --> 00:27:22,210
下一瞬间你被罢免，

615
00:27:22,210 --> 00:27:23,830
比如一瞬间你的日志有 10 个条目，

616
00:27:23,830 --> 00:27:25,990
下一瞬间只有 2 个条目，

617
00:27:26,170 --> 00:27:29,110
为了能够直接操纵这种状态，

618
00:27:29,140 --> 00:27:32,860
而不是不得不以某种方式进出程序计数器，

619
00:27:32,920 --> 00:27:34,660
对于 raft 来说更有意义。

620
00:27:34,780 --> 00:27:37,450
但在大多数情况下，这是非常独特的，

621
00:27:38,010 --> 00:27:40,560
将状态放在程序计数器中更清楚。

622
00:27:42,620 --> 00:27:45,950
好的，为了应对缓慢的订阅者，

623
00:27:46,010 --> 00:27:48,170
现在我们将添加一些 helper goroutine ，

624
00:27:48,260 --> 00:27:52,160
它们的工作是管理特定的订阅者积压，

625
00:27:52,190 --> 00:27:54,170
并防止整个程序被阻止。

626
00:27:54,530 --> 00:27:56,360
这就是 helper goroutine ，

627
00:27:56,970 --> 00:28:00,660
主循环 goroutine 会将事件发送给 helper ，

628
00:28:00,840 --> 00:28:02,850
我们信任的，因为是我们编写的，

629
00:28:02,910 --> 00:28:05,010
不会随意落后，

630
00:28:05,160 --> 00:28:08,160
然后， helper 的工作是对事件进行排队，

631
00:28:08,160 --> 00:28:09,810
并将其发送给订阅者。

632
00:28:10,860 --> 00:28:14,280
好的，这里有两个问题。

633
00:28:14,790 --> 00:28:15,930
第一个是，

634
00:28:16,260 --> 00:28:17,730
如果队列中没有任何东西，

635
00:28:17,760 --> 00:28:21,270
则 select 尝试提供 q[0] 是错误的，

636
00:28:21,270 --> 00:28:23,100
事实上，仅仅计算 q[0] ，

637
00:28:23,100 --> 00:28:24,630
select 的开头就会出现 panic ，

638
00:28:24,630 --> 00:28:26,100
因为队列是空的，

639
00:28:26,580 --> 00:28:28,320
因此，我们可以修复这些，

640
00:28:28,800 --> 00:28:31,800
通过将参数与 select 分开设置，

641
00:28:31,830 --> 00:28:35,520
我们需要创建一个 channel sendOut ，

642
00:28:35,640 --> 00:28:36,840
它会是 nil ，

643
00:28:36,840 --> 00:28:39,630
它永远不能在 select 中进行，

644
00:28:41,210 --> 00:28:42,830
正如我们知道的，当我们不想发送，

645
00:28:42,830 --> 00:28:44,660
它将成为实际的 out channel ，

646
00:28:44,660 --> 00:28:45,770
当我们想要发送时，

647
00:28:46,160 --> 00:28:47,840
然后我们必须有一个单独的变量，

648
00:28:47,840 --> 00:28:49,520
来保存我们要发送的事件，

649
00:28:49,520 --> 00:28:51,830
它从 q[0] 读取，

650
00:28:51,830 --> 00:28:52,970
如果队列中有东西。

651
00:28:55,400 --> 00:28:57,440
错误的第二件事是，

652
00:28:57,440 --> 00:29:00,260
我们需要处理输入 channel 的关闭，

653
00:29:00,380 --> 00:29:02,330
因为当输入 channel 关闭时，

654
00:29:02,390 --> 00:29:04,070
我们需要[冲掉]剩下的队列，

655
00:29:04,070 --> 00:29:05,870
然后我们需要关闭输出 channel 。

656
00:29:06,750 --> 00:29:07,950
所以，为了检查这一点，

657
00:29:08,100 --> 00:29:09,210
我们修改 select ，

658
00:29:09,210 --> 00:29:11,790
从 e 等于从 in 接收

659
00:29:11,940 --> 00:29:14,130
变为 e, ok 等于从 in 接收，

660
00:29:14,130 --> 00:29:15,750
逗号 ok 将会表示，

661
00:29:15,780 --> 00:29:18,540
channel 是否发送真正的数据，

662
00:29:18,540 --> 00:29:19,710
否则它是关闭的。

663
00:29:20,280 --> 00:29:21,630
所以当 ok 为 false 时，

664
00:29:21,720 --> 00:29:23,310
我们可以把 in 设置为 nil ，

665
00:29:23,340 --> 00:29:25,110
表示我们停止从 in 接收，

666
00:29:25,110 --> 00:29:25,740
那里没有东西，

667
00:29:25,740 --> 00:29:27,720
我们被告知它已经关闭了。

668
00:29:28,730 --> 00:29:30,710
然后，当循环正常时，

669
00:29:30,710 --> 00:29:32,660
当队列最终为空时，

670
00:29:32,690 --> 00:29:33,950
我们可以退出循环，

671
00:29:34,040 --> 00:29:35,780
所以，我们更改了 for 条件，

672
00:29:35,840 --> 00:29:38,030
表示我们希望继续执行循环，

673
00:29:38,030 --> 00:29:40,490
当输入 channel 为真时，

674
00:29:40,880 --> 00:29:43,280
并且有一些内容要写回输出 channel ，

675
00:29:43,280 --> 00:29:45,890
一旦这两个都不再为真，

676
00:29:46,010 --> 00:29:47,870
是退出循环的时候了，

677
00:29:47,930 --> 00:29:49,220
我们关闭输出 channel ，

678
00:29:49,490 --> 00:29:50,030
我们就完事了。

679
00:29:50,030 --> 00:29:51,890
现在我们已经正确地传播了，

680
00:29:52,010 --> 00:29:54,950
输入 channel 的关闭到输出 channel ，

681
00:29:56,640 --> 00:29:57,810
所以那就是 helper 。

682
00:29:58,110 --> 00:30:00,240
而 Server loop 过去是这样的，

683
00:30:01,470 --> 00:30:02,520
为了更新它，

684
00:30:02,700 --> 00:30:04,650
我们只需修改订阅者 map ，

685
00:30:04,740 --> 00:30:07,770
之前它是一个从订阅者 channel 到 bool 的映射，

686
00:30:07,770 --> 00:30:09,090
基本上只是一个 set ，

687
00:30:09,480 --> 00:30:12,750
现在它是从订阅者 channel 到 helper channel 的映射，

688
00:30:13,080 --> 00:30:14,880
每次我们收到新的订阅，

689
00:30:15,060 --> 00:30:16,650
我们创建一个 helper channel ，

690
00:30:16,680 --> 00:30:18,510
我们启动一个 helper goroutine ，

691
00:30:19,040 --> 00:30:21,710
我们将 helper channel 记录在订阅映射中，

692
00:30:21,740 --> 00:30:23,810
而不是实际的 channel 中。

693
00:30:24,510 --> 00:30:30,470
然后，循环的其余部分几乎没有改变。

694
00:30:32,490 --> 00:30:33,870
所以我想指出的是，

695
00:30:33,870 --> 00:30:36,270
如果你想使用不同的策略，

696
00:30:36,270 --> 00:30:40,530
对落后太多的客户端，

697
00:30:40,620 --> 00:30:42,390
这些都可以放在 helper goroutine 中，

698
00:30:42,450 --> 00:30:45,330
现在屏幕上的代码完全没有变化，

699
00:30:45,330 --> 00:30:48,360
所以，我们完全分离了 pubish subscribe ，

700
00:30:48,360 --> 00:30:51,150
维护了订阅者的列表映射，

701
00:30:51,180 --> 00:30:55,620
如果事情变得太慢，你会怎么做。

702
00:30:55,950 --> 00:30:58,060
所以，这非常好，

703
00:30:58,060 --> 00:31:01,690
你将关注点清晰地分离到完全不同的 goroutine 中，

704
00:31:01,690 --> 00:31:03,820
这可以帮助你的程序更简单。

705
00:31:04,360 --> 00:31:05,680
这就是一般的提示，

706
00:31:06,070 --> 00:31:10,090
你可以在很多时候使用 goroutine 来分离独立的关注点。

707
00:31:11,970 --> 00:31:12,480
好的，

708
00:31:14,670 --> 00:31:18,150
今天的第二个模式是工作调度器，

709
00:31:18,570 --> 00:31:20,880
你在第一个实验 mapreduce 中做了一个，

710
00:31:21,060 --> 00:31:22,830
我要做的就是它，

711
00:31:23,220 --> 00:31:25,740
这并做不所有的 RPC 功能，

712
00:31:25,740 --> 00:31:26,670
它只是在某种程度上假设，

713
00:31:26,670 --> 00:31:28,830
一种基于 channel 的接口，

714
00:31:28,830 --> 00:31:30,390
对于所有服务器。

715
00:31:31,430 --> 00:31:33,920
所以我们有这个函数 Schedule ，

716
00:31:33,950 --> 00:31:35,690
它使用一个 servers 列表，

717
00:31:36,260 --> 00:31:37,640
和一个运行的任务数，

718
00:31:37,880 --> 00:31:40,520
它有一个抽象的函数调用，

719
00:31:40,610 --> 00:31:43,880
你可以调用它在特定的服务器上运行任务，

720
00:31:43,940 --> 00:31:46,580
你可以想象，它是做 RPC 等事情。

721
00:31:48,120 --> 00:31:49,380
所以，我们需要一些方法

722
00:31:49,380 --> 00:31:52,890
来跟踪哪些服务器可用于执行任务。

723
00:31:53,440 --> 00:31:56,530
一种选择是使用我们自己的堆栈或队列实现，

724
00:31:56,650 --> 00:31:58,690
但是另一种选择是使用 channel ，

725
00:31:58,690 --> 00:32:00,940
因为它是一个很好的同步队列。

726
00:32:01,740 --> 00:32:04,770
因此我们可以发送到 channel 以添加到队列中，

727
00:32:04,770 --> 00:32:06,780
然后从它那里得到一些东西。

728
00:32:07,330 --> 00:32:10,480
在本例中，我们将队列设置为服务器队列，

729
00:32:10,840 --> 00:32:13,210
我们将从一个空闲的服务器队列开始，

730
00:32:13,210 --> 00:32:15,040
现在没有为我们做任何工作的服务器。

731
00:32:15,880 --> 00:32:17,620
我们开始对它进行初始化，

732
00:32:17,680 --> 00:32:20,320
通过将所有已知服务器发送到 idle 列表。

733
00:32:21,880 --> 00:32:23,530
然后我们可以循环执行任务，

734
00:32:23,530 --> 00:32:25,600
对于每一项任务，我们都启动一个 goroutine ，

735
00:32:25,660 --> 00:32:28,210
它的工作是将一个 server 从空闲列表中拿出，

736
00:32:28,540 --> 00:32:30,970
运行任务，然后重新把 server 放回。

737
00:32:32,060 --> 00:32:37,160
这个循环是使用 goroutine 的早期提示的另一个示例，

738
00:32:37,340 --> 00:32:39,020
比如独立的事情独立运行，

739
00:32:39,140 --> 00:32:41,960
因为每个任务都作为单独的关注点运行，

740
00:32:41,990 --> 00:32:43,220
它们都是并行运行的。

741
00:32:44,960 --> 00:32:47,510
不幸的是，这个程序有两个问题。

742
00:32:48,060 --> 00:32:51,420
第一个是作为新的 goroutine 运行的闭包

743
00:32:51,420 --> 00:32:54,210
引用循环迭代变量，即 task ，

744
00:32:54,450 --> 00:32:56,370
所以当 goroutine 开始执行时，

745
00:32:56,430 --> 00:32:59,160
循环可能继续，并完成 task++ ，

746
00:32:59,160 --> 00:33:01,320
所以，它得到了错误的 task 值。

747
00:33:02,490 --> 00:33:03,930
你可能已经看过了，

748
00:33:04,320 --> 00:33:06,930
当然，捕捉到这种情况的最好方法是

749
00:33:06,930 --> 00:33:08,100
运行竞态检测器。

750
00:33:08,780 --> 00:33:10,250
在 Google ，我们甚至鼓励团队

751
00:33:10,250 --> 00:33:13,130
设置金丝雀服务器来运行竞态检测器，

752
00:33:13,220 --> 00:33:16,430
并将大约 0.1% 的流量分给它，

753
00:33:16,550 --> 00:33:20,330
为了抓住可能存在于生产系统中的竞争。

754
00:33:20,860 --> 00:33:22,660
用竞态检测器找到一个 bug

755
00:33:22,840 --> 00:33:26,140
比之后不得不调试一些错误要好。

756
00:33:27,900 --> 00:33:29,880
所以，有两种方法可以修复这个竞争，

757
00:33:30,000 --> 00:33:33,450
第一种方法是给闭包一个显式参数并将其传入，

758
00:33:33,960 --> 00:33:39,210
Go 语句需要专门为此进行的函数调用，

759
00:33:39,330 --> 00:33:41,700
所以你可以设置特定参数，

760
00:33:41,700 --> 00:33:44,910
在原始 goroutine 的上下文中计算的，

761
00:33:45,120 --> 00:33:46,920
然后复制到新的 goroutine ，

762
00:33:47,670 --> 00:33:50,430
所以在本例中，我们可以声明一个新参数 task2 ，

763
00:33:50,490 --> 00:33:52,020
我们可以将 task 传递给它，

764
00:33:52,670 --> 00:33:53,840
然后在 goroutine 中，

765
00:33:53,840 --> 00:33:57,290
task2 是一个完全不同的 task 的复制，

766
00:33:57,880 --> 00:34:00,970
我把它命名为 task2 只是为了让它更容易讨论。

767
00:34:01,610 --> 00:34:02,990
当然，这里有一个 bug ，

768
00:34:02,990 --> 00:34:04,550
这个 bug 是，

769
00:34:04,580 --> 00:34:07,040
我忘了更新函数内的 task ，

770
00:34:07,040 --> 00:34:09,050
引用 task2 而不是 task ，

771
00:34:09,290 --> 00:34:12,110
我们基本上从来不这样做，

772
00:34:12,110 --> 00:34:14,150
取而代之的是，

773
00:34:14,730 --> 00:34:15,990
我们给它相同的名字，

774
00:34:16,050 --> 00:34:17,580
所以，现在是不可能的，

775
00:34:17,610 --> 00:34:21,060
对于 goroutine 中的代码引用错误的 task 复制。

776
00:34:22,500 --> 00:34:24,600
这是修复竞争的第一种方法,

777
00:34:24,600 --> 00:34:25,830
还有另一种方式是，

778
00:34:25,830 --> 00:34:27,630
第一次看到它时，你会觉得有点神秘，

779
00:34:27,630 --> 00:34:29,340
但这等同于一件事，

780
00:34:29,640 --> 00:34:30,330
也就是，

781
00:34:30,360 --> 00:34:33,810
你只需在循环体内复制变量即可。

782
00:34:34,570 --> 00:34:37,840
所以每次 := 的时候，

783
00:34:37,840 --> 00:34:39,160
就产生一个新的变量，

784
00:34:39,370 --> 00:34:41,200
所以在外部 for 循环中，

785
00:34:41,200 --> 00:34:42,670
开头有一个 := ，

786
00:34:42,670 --> 00:34:44,560
而循环的其余部分中没有，

787
00:34:44,560 --> 00:34:47,080
所以这是整个循环的一个变量，

788
00:34:47,290 --> 00:34:49,540
如果我们在函数里放一个 := ，

789
00:34:49,540 --> 00:34:51,370
每次我们运行循环的迭代时，

790
00:34:51,370 --> 00:34:52,690
都是一个不同的变量，

791
00:34:52,960 --> 00:34:57,040
所以，如果 Go 函数闭包捕获了那个变量，

792
00:34:57,070 --> 00:34:58,420
那些都是截然不同的。

793
00:34:59,130 --> 00:35:01,080
所以我们可以做和 task2 一样的事情，

794
00:35:01,080 --> 00:35:03,030
这一次我记得更新函数体，

795
00:35:03,210 --> 00:35:05,130
但是像以前一样，

796
00:35:05,130 --> 00:35:06,990
很容易忘记更新函数体，

797
00:35:07,080 --> 00:35:09,420
所以通常写 task := task ，

798
00:35:09,420 --> 00:35:11,490
第一次看到它时有点神奇，

799
00:35:11,490 --> 00:35:12,690
但这就是它的作用。

800
00:35:14,300 --> 00:35:16,820
好的，我说程序中有两个 bug ，

801
00:35:17,150 --> 00:35:19,190
第一个是任务的竞争，

802
00:35:19,840 --> 00:35:21,820
第二个问题是，

803
00:35:21,970 --> 00:35:25,990
在启动所有任务后，我们没有做任何事情，

804
00:35:25,990 --> 00:35:27,160
我们不是在等它们完成。

805
00:35:28,560 --> 00:35:33,000
尤其是，我们启动得太快了，

806
00:35:33,060 --> 00:35:37,050
因为如果有一百万个任务就会启动一百万个 goroutine ，

807
00:35:37,050 --> 00:35:39,750
它们都会坐在那里等待五个服务器中的一个，

808
00:35:39,780 --> 00:35:40,740
这是一种有益的做法。

809
00:35:41,520 --> 00:35:42,990
所以，我们所能做的是

810
00:35:42,990 --> 00:35:48,030
将下一个空闲服务器的从 goroutine 中拿出。

811
00:35:48,820 --> 00:35:51,400
我们把它从 goroutine 上拉出来，

812
00:35:51,430 --> 00:35:55,540
现在，我们仅在有空闲服务器可用时启动 goroutine 。

813
00:35:56,290 --> 00:35:57,550
然后我们就可以开始，

814
00:35:57,550 --> 00:36:00,160
使用那个服务器，然后把它放回去，

815
00:36:00,250 --> 00:36:02,770
使用服务器并将其放回并发运行，

816
00:36:02,890 --> 00:36:06,670
但是在循环内获取空闲服务器会减慢速度，

817
00:36:06,670 --> 00:36:10,240
现在只有正在运行的服务器数量，

818
00:36:10,240 --> 00:36:11,710
而不是任务数量。

819
00:36:12,470 --> 00:36:16,130
而接收器产生一些背压来减慢循环，

820
00:36:16,160 --> 00:36:17,600
因此，它不会走得太远。

821
00:36:18,940 --> 00:36:21,400
然后我提到，我们必须等待任务完成，

822
00:36:22,030 --> 00:36:24,340
所以我们可以在循环的末尾做到这一点，

823
00:36:24,370 --> 00:36:27,430
再次查看列表并取出所有服务器，

824
00:36:27,430 --> 00:36:30,370
我们已经从空闲列表中删除了合适数量的服务器，

825
00:36:30,400 --> 00:36:31,390
这意味着它们都完成了。

826
00:36:32,020 --> 00:36:34,180
所以这就是完整的程序。

827
00:36:35,460 --> 00:36:38,340
对我来说，最重要的部分是，

828
00:36:38,340 --> 00:36:41,610
你仍然可以编写一个 for 循环来迭代任务，

829
00:36:41,640 --> 00:36:42,900
在很多其他语言中，

830
00:36:42,900 --> 00:36:45,600
你必须使用状态机或某种回调来完成，

831
00:36:46,210 --> 00:36:49,480
你不能奢侈地在控制流中对此进行编码，

832
00:36:49,810 --> 00:36:52,840
所以这是一种更干净的方式，

833
00:36:52,840 --> 00:36:54,580
你可以只使用常规的循环。

834
00:36:55,380 --> 00:36:58,260
但是我们可以做一些改变，一些改进，

835
00:36:58,530 --> 00:37:00,990
一个改进是注意到，

836
00:37:01,630 --> 00:37:05,500
在特定时间，只有一个 goroutine 向服务器发出请求，

837
00:37:05,890 --> 00:37:08,170
所以，不是为任务分配一个 goroutine ，

838
00:37:08,290 --> 00:37:10,300
也许我们应该为每个服务器分配一个 goroutine ，

839
00:37:10,720 --> 00:37:13,960
因为服务器数量可能会少于任务数量。

840
00:37:14,540 --> 00:37:15,320
要做到这一点，

841
00:37:15,320 --> 00:37:18,020
我们必须从一个由空闲服务器组成的 channel

842
00:37:18,020 --> 00:37:20,810
转变为一个由尚未完成的任务组成的 channel ，

843
00:37:21,080 --> 00:37:23,300
所以，我们将空闲 channel 重命名为 work 。

844
00:37:24,020 --> 00:37:25,880
然后我们还需要一个 done channel

845
00:37:25,910 --> 00:37:29,570
来计算完成了多少任务，

846
00:37:29,570 --> 00:37:31,610
这样我们知道什么时候完全完成了。

847
00:37:32,300 --> 00:37:35,030
所以这里有一个新的函数 runTasks ，

848
00:37:35,030 --> 00:37:37,220
这将是每台服务器的函数，

849
00:37:37,610 --> 00:37:39,800
我们为每个服务器启动一个。

850
00:37:40,410 --> 00:37:43,290
runTasks 它的工作是在 work channel 上循环，

851
00:37:43,710 --> 00:37:44,820
运行任务，

852
00:37:44,820 --> 00:37:46,230
当服务器完成时，

853
00:37:46,800 --> 00:37:48,090
我们发送 true 给 done ，

854
00:37:48,360 --> 00:37:51,510
服务器告诉我们它已经完成了，

855
00:37:52,020 --> 00:37:54,870
当 work channel 关闭时，服务器退出，

856
00:37:54,870 --> 00:37:57,060
这让 for 循环停止。

857
00:37:58,220 --> 00:38:01,010
然后你启动了服务器，

858
00:38:01,010 --> 00:38:02,540
我们可以在一个循环中，

859
00:38:02,570 --> 00:38:05,360
将每个任务发送到 work channel ，

860
00:38:05,890 --> 00:38:08,050
关闭 work channel ，表示没有更多的工作要做了，

861
00:38:08,050 --> 00:38:10,180
所有服务器应该完成，然后退出，

862
00:38:10,450 --> 00:38:12,580
然后等待所有的服务器告诉我们它们完成了。

863
00:38:15,320 --> 00:38:17,960
所以在实验里，有一些复杂的东西，

864
00:38:17,960 --> 00:38:20,990
一个是，你可能会在任何时间获得新服务器，

865
00:38:21,380 --> 00:38:22,880
我们可以修改它，

866
00:38:22,880 --> 00:38:25,580
通过说服务器来自 channel string ，

867
00:38:26,940 --> 00:38:30,060
这非常适合目前的结构，

868
00:38:30,060 --> 00:38:32,070
当你获得新的服务器时，

869
00:38:32,100 --> 00:38:35,790
你只需要启动一个新的 runTasks goroutine ，

870
00:38:35,880 --> 00:38:37,530
所以我们现在唯一需要修改的是

871
00:38:37,530 --> 00:38:39,930
把这个循环放入自己的 goroutine 中，

872
00:38:39,930 --> 00:38:41,970
当我们向服务器发送任务时，

873
00:38:41,970 --> 00:38:43,590
我们仍然可以接受新的服务器，

874
00:38:43,590 --> 00:38:45,270
并启动 runTasks goroutine 。

875
00:38:47,340 --> 00:38:48,240
但是现在我们遇到了这个问题，

876
00:38:48,240 --> 00:38:49,440
我们没有一个好的方法

877
00:38:49,440 --> 00:38:51,450
来判断所有的服务器什么时候都完成了，

878
00:38:51,450 --> 00:38:53,400
因为我们不知道有多少台服务器，

879
00:38:53,670 --> 00:38:58,190
我们可以尝试保持服务器到来的数字，

880
00:38:58,190 --> 00:38:59,480
但这有点棘手，

881
00:38:59,600 --> 00:39:02,900
取而代之的是，我们可以计算已经完成的任务的数量，

882
00:39:02,930 --> 00:39:06,560
所以我们把发送 true 给 done [向上对齐]，

883
00:39:06,590 --> 00:39:08,420
不是对每个服务器执行这个操作，

884
00:39:08,420 --> 00:39:09,830
我们现在每个任务这样做，

885
00:39:10,070 --> 00:39:11,210
在循环结束时，

886
00:39:11,240 --> 00:39:12,200
在函数结束时，

887
00:39:12,200 --> 00:39:14,480
我们只需等待合适数量的任务完成即可。

888
00:39:15,640 --> 00:39:21,130
所以，现在我们又一次知道为什么这些将会结束，

889
00:39:21,460 --> 00:39:23,530
这里仍然有死锁，

890
00:39:23,620 --> 00:39:28,510
也就是，如果任务的数量太大，

891
00:39:28,540 --> 00:39:29,650
事实上，我认为总是这样的，

892
00:39:29,800 --> 00:39:31,150
你会得到死锁，

893
00:39:31,180 --> 00:39:32,290
如果你运行这个程序，

894
00:39:32,290 --> 00:39:33,430
你得到这个好东西，

895
00:39:33,430 --> 00:39:35,800
它告诉你，你的 goroutine 停止了，

896
00:39:35,800 --> 00:39:37,270
问题是，

897
00:39:37,300 --> 00:39:40,300
我们有这个 runTasks 服务器循环，

898
00:39:40,840 --> 00:39:42,760
服务器循环试图说，嘿，我完成了，

899
00:39:43,030 --> 00:39:45,250
你想说，嘿，还有更多的工作要做，

900
00:39:45,250 --> 00:39:46,690
如果你有不止一个任务，

901
00:39:46,690 --> 00:39:48,040
你就会陷入死锁，

902
00:39:48,730 --> 00:39:52,060
当你尝试将下一个任务发送到服务器时，

903
00:39:52,090 --> 00:39:54,160
我想这是比服务器多的任务，

904
00:39:54,340 --> 00:39:55,990
你尝试将下一个任务发送到服务器，

905
00:39:55,990 --> 00:39:58,720
所有的服务器都尝试说，嘿，我完成了前一项任务，

906
00:39:58,750 --> 00:40:00,910
但你不是在那里接收来自 done channel 的。

907
00:40:01,920 --> 00:40:06,210
所以再一次， goroutine 等待是很好的，

908
00:40:06,210 --> 00:40:07,380
等着查看它们。

909
00:40:07,530 --> 00:40:08,940
我们可以解决这个问题，

910
00:40:09,750 --> 00:40:13,530
解决这个问题的一种方法是添加一个单独的循环，

911
00:40:13,530 --> 00:40:14,880
它执行一个 select ，

912
00:40:14,880 --> 00:40:16,500
要么发送一些 work ，

913
00:40:16,530 --> 00:40:19,050
或者一些工作完成的计数，

914
00:40:19,260 --> 00:40:21,030
那很好，

915
00:40:21,060 --> 00:40:22,500
但更干净的方式是，

916
00:40:22,680 --> 00:40:26,250
就是把 task 发送循环，

917
00:40:26,250 --> 00:40:28,050
并将其放入自己的 goroutine 中，

918
00:40:28,170 --> 00:40:30,930
所以现在它独立于计数循环运行，

919
00:40:31,050 --> 00:40:33,480
计数循环可以运行，

920
00:40:33,540 --> 00:40:36,980
未阻塞的服务器某些任务已完成，

921
00:40:36,980 --> 00:40:38,660
而其他任务仍在发送中。

922
00:40:41,400 --> 00:40:44,280
但解决这一问题最简单的办法是，

923
00:40:44,280 --> 00:40:46,170
把 work channel 做得足够大，

924
00:40:46,200 --> 00:40:48,510
你永远不会用完空间。

925
00:40:49,020 --> 00:40:50,340
因为我们可能会决定，

926
00:40:50,340 --> 00:40:52,680
一个 goroutine 的 task 是，

927
00:40:52,680 --> 00:40:54,540
任务有几千字节，

928
00:40:54,660 --> 00:40:58,170
但是 channel 中的整型是 8 个字节，

929
00:40:58,200 --> 00:41:00,420
所以，你可能会在每个任务上花费 8 个字节。

930
00:41:01,360 --> 00:41:02,380
所以如果可以的话，

931
00:41:02,410 --> 00:41:04,060
你只要把 work channel 做得足够大，

932
00:41:04,090 --> 00:41:07,450
你知道发送给 work 的不会阻塞，

933
00:41:07,450 --> 00:41:11,380
你总是很快地进入到最后的计数循环。

934
00:41:12,740 --> 00:41:16,880
这样做为实验中的其他[]做好了准备，

935
00:41:16,880 --> 00:41:19,130
那就是有时调用可能会超时，

936
00:41:19,160 --> 00:41:22,100
在这里，我通过调用返回一个 false ，

937
00:41:22,100 --> 00:41:23,330
表示它没有工作。

938
00:41:24,560 --> 00:41:28,220
所以，在 runTasks 中，很容易看出，

939
00:41:28,220 --> 00:41:31,380
很容易看出，

940
00:41:31,380 --> 00:41:35,090
如果调用失败，那么，

941
00:41:35,390 --> 00:41:37,190
抱歉，如果调用成功，你就完成了，

942
00:41:37,190 --> 00:41:40,070
但如果失败了，就把这项任务重新放回 work 列表中，

943
00:41:40,190 --> 00:41:42,170
因为它是一个队列，而不是一个堆栈，

944
00:41:42,230 --> 00:41:43,400
把它放回 work 列表中，

945
00:41:43,400 --> 00:41:45,530
会把它交给其他服务器。

946
00:41:46,180 --> 00:41:49,630
所以，这很可能会成功，

947
00:41:49,660 --> 00:41:50,800
因为它是另一台服务器，

948
00:41:50,800 --> 00:41:52,390
这都是假设的，

949
00:41:52,420 --> 00:41:55,660
但这是一个非常，

950
00:41:55,660 --> 00:41:58,450
它非常适合我们创造的结构。

951
00:42:00,710 --> 00:42:02,660
好的，最后的修改是，

952
00:42:02,750 --> 00:42:05,090
因为服务器 goroutine 发送工作，

953
00:42:05,180 --> 00:42:07,340
我们必须等到关闭它，

954
00:42:07,490 --> 00:42:09,020
直到它们发送完毕，

955
00:42:09,600 --> 00:42:13,530
因为在它们完成发送之前，你不能关闭。

956
00:42:14,370 --> 00:42:16,140
所以我们需要把 close 移动到

957
00:42:16,170 --> 00:42:18,690
我们数完所有任务之后，

958
00:42:19,620 --> 00:42:21,540
有时我们会走到这一步，

959
00:42:21,540 --> 00:42:24,630
人们会问为什么你不能直接杀死 goroutine ，

960
00:42:24,630 --> 00:42:25,890
比如为什么不能说，

961
00:42:25,890 --> 00:42:27,990
在这一点上杀死所有的服务器 goroutine ，

962
00:42:27,990 --> 00:42:29,340
我们知道它们不再需要了。

963
00:42:29,900 --> 00:42:32,270
答案是 goroutine 有状态，

964
00:42:32,270 --> 00:42:34,100
它与程序的其余部分相互作用，

965
00:42:34,100 --> 00:42:35,870
如果它突然停止了，

966
00:42:36,170 --> 00:42:37,670
有点像卡住了，

967
00:42:37,670 --> 00:42:39,440
也许它持有一把锁，

968
00:42:39,530 --> 00:42:41,600
也许是在通信的过程中，

969
00:42:41,600 --> 00:42:43,880
与一些其他等待回复的 goroutine 。

970
00:42:44,510 --> 00:42:47,690
所以我们需要想办法更优雅地关闭它们，

971
00:42:47,690 --> 00:42:49,160
那就是明确地告诉它们，

972
00:42:49,160 --> 00:42:51,230
嘿，你完成了，你可以走了，

973
00:42:51,230 --> 00:42:53,930
然后它们可以清理它们需要清理的东西。

974
00:42:57,490 --> 00:42:59,170
说到清理，

975
00:42:59,170 --> 00:43:00,880
我们还有一件事要做，

976
00:43:00,880 --> 00:43:03,940
就是关闭正在监视新服务器的循环，

977
00:43:04,120 --> 00:43:06,430
所以我们必须在这里放一个 select ，

978
00:43:06,460 --> 00:43:11,450
在那里在服务器 channel 上等待新服务器，

979
00:43:11,450 --> 00:43:12,470
我们必须去告诉它，

980
00:43:12,710 --> 00:43:15,170
好的，我们已经完成了，停止监视新服务器，

981
00:43:15,170 --> 00:43:17,390
所有的服务器都不见了。

982
00:43:18,180 --> 00:43:19,980
我们可以把这个问题变成调用者的问题，

983
00:43:19,980 --> 00:43:21,960
但这是相当容易做到的。

984
00:43:24,260 --> 00:43:26,780
好的，这里是模式 3 ，

985
00:43:26,780 --> 00:43:30,560
一个复制服务的客户端。

986
00:43:31,340 --> 00:43:33,800
这是是我们要实现的接口，

987
00:43:33,800 --> 00:43:36,110
我们有一些服务，

988
00:43:36,730 --> 00:43:39,070
我们想要它为了可靠性是复制的，

989
00:43:39,400 --> 00:43:42,700
客户端可以与这些服务器中的任何一个进行交互，

990
00:43:42,910 --> 00:43:47,830
所以复制的客户端给一个服务器列表，

991
00:43:47,860 --> 00:43:50,560
Init 的参数是服务器列表，

992
00:43:50,680 --> 00:43:54,010
还有一个函数允许你调用其中一个服务器，

993
00:43:54,040 --> 00:43:56,260
使用特定的参数，并获得回复。

994
00:43:57,260 --> 00:44:00,140
然后在 Init 的过程中，

995
00:44:00,170 --> 00:44:03,800
复制的客户端提供一个调用方法，

996
00:44:03,950 --> 00:44:06,530
不会告诉你它将使用哪个服务器，

997
00:44:06,530 --> 00:44:08,510
它只是寻找一个好的服务器来使用，

998
00:44:08,570 --> 00:44:11,780
它尽可能长时间地使用同一服务器，

999
00:44:11,780 --> 00:44:13,610
直到它发现服务器不好为止。

1000
00:44:15,240 --> 00:44:16,320
所以，在这种情况下，

1001
00:44:16,320 --> 00:44:18,660
你几乎不需要共享状态，

1002
00:44:19,230 --> 00:44:21,780
从一次调用到下一次调用唯一保持的状态是

1003
00:44:21,780 --> 00:44:23,130
我上次使用的服务器，

1004
00:44:23,130 --> 00:44:24,630
因为我要尝试再用一次。

1005
00:44:25,500 --> 00:44:27,960
所以在这种情况下，使用 mutex 是完全没有问题的，

1006
00:44:27,960 --> 00:44:29,040
我只想把它留在那里，

1007
00:44:29,130 --> 00:44:30,930
使用 mutex  总是可以的，

1008
00:44:30,930 --> 00:44:33,060
如果这是编写代码的最干净的方式。

1009
00:44:33,660 --> 00:44:36,750
有些人从我们谈论 channel 的次数中得到了错误的印象，

1010
00:44:36,750 --> 00:44:39,180
但是，如果需要的话，使用 mutex 总是可以的。

1011
00:44:40,880 --> 00:44:44,000
所以现在我们需要实现这个复制 Call 方法，

1012
00:44:44,000 --> 00:44:47,240
它的工作是尝试发送到许多不同的服务器，

1013
00:44:47,890 --> 00:44:50,440
但是首先尝试一下原来的服务器。

1014
00:44:51,090 --> 00:44:54,510
那么，如果尝试失败了意味着什么呢，

1015
00:44:54,660 --> 00:44:58,110
没有明确的方法让它在上面失败，

1016
00:44:58,110 --> 00:44:59,610
它只是总是返回一个回复，

1017
00:44:59,610 --> 00:45:01,980
它失败的唯一方式是如果它花的时间太长，

1018
00:45:02,310 --> 00:45:05,100
所以我们假设，如果花了太长时间，就意味着它失败了。

1019
00:45:06,000 --> 00:45:08,010
所以，为了应对超时，

1020
00:45:08,010 --> 00:45:11,130
我们必须在后台的另一个 goroutine 中运行该代码。

1021
00:45:11,640 --> 00:45:13,380
所以我们可以做这样的事情，

1022
00:45:14,110 --> 00:45:16,240
在那里我们设置了超时，

1023
00:45:16,240 --> 00:45:17,440
我们创建一个计时器，

1024
00:45:18,070 --> 00:45:20,650
然后使用 goroutine 在后台发送，

1025
00:45:20,950 --> 00:45:22,420
然后在最后，我们等待，

1026
00:45:22,420 --> 00:45:25,450
要么得到超时，要么得到实际的回复，

1027
00:45:25,540 --> 00:45:27,700
如果我们得到了实际的回复，我们会返回它，

1028
00:45:28,120 --> 00:45:30,220
如果我们得到超时，我们就得做点什么，

1029
00:45:30,310 --> 00:45:31,420
我们必须弄清楚该做什么。

1030
00:45:32,320 --> 00:45:36,970
必须指出，你必须调用 t.Stop ，

1031
00:45:37,000 --> 00:45:39,640
否则定时器位于定时器队列中，

1032
00:45:39,640 --> 00:45:41,500
它将在一秒钟内退出，

1033
00:45:41,830 --> 00:45:43,840
所以如果这个调用花了一毫秒，

1034
00:45:43,840 --> 00:45:46,150
你有一个计时器等待下一秒，

1035
00:45:46,180 --> 00:45:47,530
然后你在一个循环中做这个，

1036
00:45:47,680 --> 00:45:50,830
你有一千个定时器在那个队列里，

1037
00:45:50,830 --> 00:45:53,650
在它们开始消失之前。

1038
00:45:53,920 --> 00:45:56,900
所以，这是一种在 API 中的工作，

1039
00:45:56,900 --> 00:45:59,180
但它一直在那里，我们没有修复它，

1040
00:45:59,720 --> 00:46:02,960
所以你只需要记得调用 stop 。

1041
00:46:04,230 --> 00:46:06,030
然后现在我们必须弄清楚

1042
00:46:06,030 --> 00:46:07,740
在超时的情况下我们该怎么做。

1043
00:46:08,880 --> 00:46:10,140
所以，在超时的情况下，

1044
00:46:10,140 --> 00:46:11,970
我们需要尝试不同的服务器，

1045
00:46:12,000 --> 00:46:13,050
所以我们要写一个循环，

1046
00:46:13,660 --> 00:46:18,880
我们将从 id 0 开始，

1047
00:46:18,940 --> 00:46:21,190
如果收到回复，那很好，

1048
00:46:21,310 --> 00:46:24,550
否则我们将重置超时，并再次循环，

1049
00:46:24,700 --> 00:46:26,650
并尝试发送到不同的服务器。

1050
00:46:27,010 --> 00:46:30,890
注意到，这个程序中只有一个 done channel ，

1051
00:46:31,250 --> 00:46:34,820
所以，在循环的第三次迭代中，我们可能会等待，

1052
00:46:35,150 --> 00:46:37,670
然后最后第一个服务器给我们一个回复，

1053
00:46:37,760 --> 00:46:40,010
这完全没问题，我们会接受这样的回复，这很好，

1054
00:46:41,060 --> 00:46:43,730
所以我们会停下来，并把它返回。

1055
00:46:45,120 --> 00:46:47,010
但是，如果我们把整个循环都做完，

1056
00:46:47,010 --> 00:46:49,590
这意味着我们已经将请求发送到每一台服务器，

1057
00:46:49,650 --> 00:46:51,480
在这种情况下，不会再有超时，

1058
00:46:51,480 --> 00:46:53,460
我们只需要等它们中的一个回来，

1059
00:46:53,700 --> 00:46:56,760
这就是[]的接收和最终的返回。

1060
00:46:58,260 --> 00:47:02,880
然后需要注意的是， done channel 现在是带缓冲的，

1061
00:47:02,910 --> 00:47:06,180
所以，如果你将结果发送到三个不同的服务器，

1062
00:47:06,210 --> 00:47:08,790
你将接受第一个回复，然后返回，

1063
00:47:08,970 --> 00:47:11,640
但其他人也想要发送响应，

1064
00:47:12,100 --> 00:47:14,140
我们不希望这些 goroutine 永远在那里，

1065
00:47:14,140 --> 00:47:16,210
试图发送到一个我们没有读取的 channel ，

1066
00:47:16,480 --> 00:47:17,710
所以，我们将缓冲区设置得足够大，

1067
00:47:17,710 --> 00:47:20,380
它们可以发送到缓冲区，然后离开，

1068
00:47:20,380 --> 00:47:22,000
然后 channel 会被垃圾收集。

1069
00:47:23,930 --> 00:47:25,340
我们在聊天中有一个问题，

1070
00:47:25,340 --> 00:47:28,580
问题说，

1071
00:47:28,580 --> 00:47:30,590
为什么计时器不能被垃圾收集，

1072
00:47:30,590 --> 00:47:31,730
在没有人引用它的情况下，

1073
00:47:31,730 --> 00:47:33,710
而不是在它离开时等待，

1074
00:47:33,710 --> 00:47:35,360
你说会有多个等待，

1075
00:47:35,360 --> 00:47:36,860
如果它在一毫秒内离开。

1076
00:47:37,250 --> 00:47:41,000
问题是计时器被运行时引用，

1077
00:47:41,030 --> 00:47:43,040
它在活动计时器列表中，

1078
00:47:43,600 --> 00:47:46,360
调用 stop 会将其从活动计时器列表中删除。

1079
00:47:46,840 --> 00:47:49,990
所以，可以说，这是一种工作，

1080
00:47:50,020 --> 00:47:52,030
就像在定时器的特定情况下，

1081
00:47:52,030 --> 00:47:55,750
就像是只有在这个 channel 中才会被使用，

1082
00:47:55,750 --> 00:47:58,990
我们可以有特殊的情况，通过拥有 channel ，

1083
00:47:58,990 --> 00:48:01,450
因为计时器内部是这个 t.C channel ，

1084
00:48:01,720 --> 00:48:04,870
所以我们可以有一种不同类型的 channel 实现，

1085
00:48:05,020 --> 00:48:07,810
内部表示，嘿，我是一个定时器 channel ，

1086
00:48:08,080 --> 00:48:12,250
然后就像它上面的 select 注意到退出，

1087
00:48:12,550 --> 00:48:14,890
但如果你放手，它就会消失。

1088
00:48:15,360 --> 00:48:18,480
我们想过这么做有一段时间，但我们从来没有这样做，

1089
00:48:18,570 --> 00:48:20,280
所以，这就是 Go 的现状。

1090
00:48:20,810 --> 00:48:23,270
但是你知道垃圾收集器不能区分，

1091
00:48:23,270 --> 00:48:27,500
运行时内部的引用和程序的其余部分的引用，

1092
00:48:27,500 --> 00:48:28,730
这些都只是引用，

1093
00:48:29,060 --> 00:48:32,600
所以，在我们使用某些方法对这个 channel 进行特殊处理之前，

1094
00:48:32,600 --> 00:48:34,610
我们无法摆脱这一点。

1095
00:48:37,540 --> 00:48:38,050
谢谢。

1096
00:48:38,290 --> 00:48:38,980
当然。

1097
00:48:39,070 --> 00:48:42,010
所以我们剩下的唯一一件事是，

1098
00:48:42,160 --> 00:48:46,570
我们尝试使用与上一次相同的 id 。

1099
00:48:47,390 --> 00:48:48,800
为了实现这一偏好，

1100
00:48:50,550 --> 00:48:54,900
我们在结果 channel 的回复中返回了服务器 id ，

1101
00:48:55,910 --> 00:48:58,100
所以我们做同样的循环，

1102
00:48:58,100 --> 00:49:01,190
我们循环将要使用的 id 的偏移量，

1103
00:49:01,190 --> 00:49:02,930
首选的那个，

1104
00:49:03,260 --> 00:49:05,030
然后我们得到了回答，

1105
00:49:05,090 --> 00:49:08,060
我们将首选的设置为获得回答，

1106
00:49:08,090 --> 00:49:09,050
然后进行回复，

1107
00:49:09,500 --> 00:49:11,420
你注意到我用了一个 goto 语句，

1108
00:49:11,510 --> 00:49:13,730
这也是可以的，如果你需要使用 goto 的话，

1109
00:49:14,480 --> 00:49:16,520
这里并没有[狂热行为]。

1110
00:49:18,070 --> 00:49:20,680
好的，第四个，

1111
00:49:21,010 --> 00:49:25,060
然后我们将做一些问题，是协议选择器。

1112
00:49:25,810 --> 00:49:29,470
这是任何 RPC 系统的核心逻辑，

1113
00:49:29,650 --> 00:49:31,210
这经常被提起，

1114
00:49:31,210 --> 00:49:33,160
我觉得我在研究生的时候写了很多这样的东西，

1115
00:49:33,160 --> 00:49:34,270
以及在那之后的几年里。

1116
00:49:35,760 --> 00:49:39,360
协议多路复用器的基本 API 是，

1117
00:49:39,480 --> 00:49:41,130
它是从某个 Service 开始，

1118
00:49:41,130 --> 00:49:42,900
我们会把它传递给 Init 方法，

1119
00:49:43,600 --> 00:49:45,790
然后使用 Service 进行初始化，

1120
00:49:45,910 --> 00:49:48,940
你可以调用 Call ，

1121
00:49:48,970 --> 00:49:51,220
给它一个请求消息，

1122
00:49:51,220 --> 00:49:53,740
然后它会在某个时候向你返回回复消息，

1123
00:49:54,100 --> 00:49:57,100
它需要从服务中获得多路复用，

1124
00:49:57,740 --> 00:49:58,940
给定一条消息，

1125
00:49:58,970 --> 00:50:02,660
它必须能够提取唯一标识消息的标记，

1126
00:50:02,960 --> 00:50:04,970
并标识该回复，

1127
00:50:04,970 --> 00:50:07,100
因为它会返回一个匹配的标记，

1128
00:50:07,430 --> 00:50:11,330
然后它需要能够发送消息和接收消息，

1129
00:50:11,330 --> 00:50:15,680
但它们发送和接收消息都是任意的，不匹配。

1130
00:50:16,680 --> 00:50:19,080
这是多路选择器的工作，为了匹配它们。

1131
00:50:21,020 --> 00:50:23,150
所以，首先，

1132
00:50:23,180 --> 00:50:25,820
我们有一个 goroutine 负责调用 send ，

1133
00:50:25,940 --> 00:50:28,130
另一个 goroutine 负责调用 receive ，

1134
00:50:28,130 --> 00:50:29,480
两者都在简单的循环中。

1135
00:50:30,110 --> 00:50:32,930
所以为了初始化服务，我们设置结构体，

1136
00:50:32,930 --> 00:50:35,540
它将启动发送循环和接收循环，

1137
00:50:35,660 --> 00:50:38,480
然后我们还有一个待处理请求的 map ，

1138
00:50:38,720 --> 00:50:43,220
map 从我们在消息中看到的 id 编号

1139
00:50:43,220 --> 00:50:46,070
到回复会去的 channel 。

1140
00:50:47,960 --> 00:50:49,700
发送循环相当简单，

1141
00:50:49,700 --> 00:50:51,800
你只需要遍历需要发送的东西，

1142
00:50:51,800 --> 00:50:52,550
然后将它们发送出去，

1143
00:50:52,640 --> 00:50:55,490
这会产生要发送的调用的串行化效果，

1144
00:50:55,490 --> 00:50:58,550
因为我们不会强制服务实现

1145
00:50:58,790 --> 00:51:02,510
同时处理从多个 goroutine 发送的内容，

1146
00:51:02,510 --> 00:51:03,410
我们序列化它，

1147
00:51:03,410 --> 00:51:07,160
所以它可以认为一次只发送一个包。

1148
00:51:09,200 --> 00:51:12,440
然后接收循环稍微复杂一点，

1149
00:51:12,440 --> 00:51:15,680
它从服务中拉出一个回复，

1150
00:51:15,680 --> 00:51:18,770
同样，它们也是序列化的，每次读取一个，

1151
00:51:19,040 --> 00:51:21,230
然后它从回复中取出标签，

1152
00:51:22,040 --> 00:51:25,100
然后它说，哦，我需要找到发送这个信息的 channel ，

1153
00:51:25,520 --> 00:51:27,710
因此它将 channel 从 pending 映射中拉出，

1154
00:51:27,980 --> 00:51:29,540
它把它从 pending 映射中拿出来，

1155
00:51:29,540 --> 00:51:31,910
这样如果我们意外地得到了另一个，

1156
00:51:31,910 --> 00:51:32,900
我们不会尝试发送它，

1157
00:51:33,640 --> 00:51:35,050
然后它会发送回复。

1158
00:51:36,190 --> 00:51:37,960
然后为了实现 Call ，

1159
00:51:38,110 --> 00:51:40,210
你需要在映射中设置好自己，

1160
00:51:40,210 --> 00:51:42,460
然后发送它并等待回复，

1161
00:51:42,490 --> 00:51:44,170
所以我们开始，

1162
00:51:44,170 --> 00:51:45,220
把标签拿出来，

1163
00:51:45,640 --> 00:51:47,410
创建我们的 done channel ，

1164
00:51:47,680 --> 00:51:49,660
我们将标签放入映射，

1165
00:51:49,690 --> 00:51:51,460
第一次检查 bug ，

1166
00:51:51,790 --> 00:51:55,520
然后，我们发送参数消息给 send ，

1167
00:51:55,640 --> 00:51:57,650
然后我们等待 done 的回复。

1168
00:51:57,710 --> 00:51:58,910
这非常非常简单，

1169
00:51:58,910 --> 00:52:01,340
我以前用 C 语言写这些东西，

1170
00:52:01,340 --> 00:52:03,170
情况要糟糕得多。

1171
00:52:04,900 --> 00:52:07,810
这就是我想展示的所有模式，

1172
00:52:08,140 --> 00:52:10,870
我希望这些东西最终会对你有用，

1173
00:52:10,870 --> 00:52:13,060
在未来编写的程序时，

1174
00:52:13,420 --> 00:52:17,190
我希望它们是好主意，

1175
00:52:17,190 --> 00:52:18,750
即使在非 Go 项目中，

1176
00:52:18,750 --> 00:52:20,100
但是考虑它们，

1177
00:52:20,100 --> 00:52:22,590
当你去做其他事情的时候， Go 也可以帮助你。

1178
00:52:23,130 --> 00:52:24,720
所以我把它们都放回去。

1179
00:52:24,900 --> 00:52:27,600
然后我有一些 Frans 发送的问题，

1180
00:52:27,600 --> 00:52:29,010
来自你们所有人的。

1181
00:52:30,350 --> 00:52:35,030
我们可能还会有一些时间来回答聊天中的问题。

1182
00:52:35,640 --> 00:52:38,280
我不知道在 Zoom 中聊天窗口在哪里，

1183
00:52:38,280 --> 00:52:41,760
所以当我们谈到这个时，大家可以大声说，

1184
00:52:41,760 --> 00:52:45,450
不幸的是，我不是每天都使用 Zoom 。

1185
00:52:46,150 --> 00:52:49,660
正常情况下，我知道如何使用 Zoom ，

1186
00:52:49,660 --> 00:52:51,040
但随着演示的进行，

1187
00:52:51,040 --> 00:52:52,750
Zoom 的这一小部分，

1188
00:52:52,750 --> 00:52:54,310
不是我常用的东西。

1189
00:52:54,910 --> 00:52:57,790
不管怎样，有人问我 Go 花了多长时间？

1190
00:52:57,970 --> 00:53:00,880
目前为止，它已经大约 13 年半了，

1191
00:53:01,180 --> 00:53:04,510
我们从 2007 年 9 月下旬开始讨论，

1192
00:53:04,660 --> 00:53:06,550
我从 2008 年 8 月全职加入，

1193
00:53:06,550 --> 00:53:07,930
当我从 MIT 毕业时，

1194
00:53:08,530 --> 00:53:11,800
在 2009 年 11 月，我们进行了最初的开源发布，

1195
00:53:12,380 --> 00:53:17,750
我们在 2011 年 10 月发布了的第一个稳定版本 Go 1 ，

1196
00:53:17,780 --> 00:53:19,550
抱歉，计划是 2011 年 10 月，

1197
00:53:19,550 --> 00:53:21,350
Go 1 本身是 2012 年 3 月，

1198
00:53:22,180 --> 00:53:25,210
从那时起，我们就一直按照常规的日程安排，

1199
00:53:25,450 --> 00:53:28,540
下一个重大变化将是泛型，

1200
00:53:28,840 --> 00:53:32,740
添加泛型可能是在 Go 1.18 ，

1201
00:53:32,740 --> 00:53:34,750
将是在下一次在 2 月份。

1202
00:53:37,260 --> 00:53:41,310
有人问，构建一门像 Go 这样的语言需要多大的团队？

1203
00:53:41,310 --> 00:53:44,850
在最初的两年里，我们只有五个人，

1204
00:53:45,090 --> 00:53:49,200
这足以让我们发布一些东西，

1205
00:53:49,200 --> 00:53:51,120
可以在生产中运行，

1206
00:53:51,710 --> 00:53:53,060
但它相当原始，

1207
00:53:53,090 --> 00:53:55,550
它是一个很好的原型，

1208
00:53:55,550 --> 00:53:56,930
它是一个可靠的工作原型，

1209
00:53:56,930 --> 00:53:59,120
但它不像今天这样，

1210
00:53:59,660 --> 00:54:01,490
随着时间的推移，我们已经扩大了相当多的规模，

1211
00:54:01,490 --> 00:54:03,500
现在我们有大约 50 人，

1212
00:54:03,650 --> 00:54:07,070
受雇于 Google ，直接在 Go 上工作，

1213
00:54:07,950 --> 00:54:10,140
然后有大量的开源贡献者，

1214
00:54:10,140 --> 00:54:12,030
我是说，有成千上万的，

1215
00:54:12,030 --> 00:54:13,920
在过去 13 年里帮助我们，

1216
00:54:14,190 --> 00:54:16,050
当然不可能完成它，

1217
00:54:16,050 --> 00:54:17,100
即使有 50 个人，

1218
00:54:17,220 --> 00:54:20,310
没有来自外部的所有不同的贡献。

1219
00:54:22,800 --> 00:54:28,020
有人问到，设计的优先顺序和动机。

1220
00:54:28,320 --> 00:54:30,930
你知道我们是为自己构建的，

1221
00:54:30,930 --> 00:54:33,870
优先级是构建一些对 Google 有帮助的东西，

1222
00:54:33,870 --> 00:54:36,000
事实证明， Google 领先了几年，

1223
00:54:36,000 --> 00:54:37,440
我们只是处在一个非常幸运的位置，

1224
00:54:37,440 --> 00:54:39,900
Google 领先行业其他公司几年，

1225
00:54:40,080 --> 00:54:42,870
现在必须编写分布式系统，

1226
00:54:42,870 --> 00:54:44,910
每个人使用云软件，

1227
00:54:44,910 --> 00:54:47,130
编写与其他程序交互的程序，

1228
00:54:47,130 --> 00:54:48,030
发送消息，

1229
00:54:48,030 --> 00:54:51,900
现在几乎没有单一机器的程序了，

1230
00:54:52,610 --> 00:54:56,060
所以我们在某种程度上，

1231
00:54:56,180 --> 00:54:58,220
构建语言，

1232
00:54:58,220 --> 00:55:00,560
世界其他地方几年后需要的（语言）。

1233
00:55:01,740 --> 00:55:04,290
然后另一件优先考虑的事情是

1234
00:55:04,290 --> 00:55:06,750
让它为大量程序员工作，

1235
00:55:07,140 --> 00:55:11,280
因为 Google 有大量的程序员在一个代码库中工作，

1236
00:55:11,520 --> 00:55:13,110
现在我们有了开放源码，

1237
00:55:13,110 --> 00:55:15,300
即使你是一个小团队，

1238
00:55:15,330 --> 00:55:18,480
你也依赖于大量由其他人编写的代码，

1239
00:55:19,110 --> 00:55:21,480
所以，很多问题出现，

1240
00:55:21,510 --> 00:55:24,450
许多程序员在这种情况下仍然会出现，

1241
00:55:24,840 --> 00:55:27,270
所以，这些都是我们试图解决的问题。

1242
00:55:28,090 --> 00:55:30,160
对于所有这些事情，

1243
00:55:30,160 --> 00:55:31,570
我们花了很长时间，

1244
00:55:31,660 --> 00:55:35,320
在我们把一些东西放在语言中之前，

1245
00:55:35,320 --> 00:55:38,620
比如在核心原创小组中的每个人都达成一致，

1246
00:55:38,860 --> 00:55:40,780
这意味着，

1247
00:55:41,290 --> 00:55:44,500
我们花了一段时间才得到我们想要的部分，

1248
00:55:44,500 --> 00:55:45,760
但是一旦我们到达那里，

1249
00:55:45,760 --> 00:55:49,360
它们非常稳定，坚实，非常好，

1250
00:55:49,360 --> 00:55:50,590
合作得很好。

1251
00:55:50,980 --> 00:55:53,500
同样的事情现在也发生在泛型上，

1252
00:55:53,740 --> 00:55:55,240
我们感觉，

1253
00:55:55,270 --> 00:55:57,340
我个人对泛型的感觉很好，

1254
00:55:57,340 --> 00:56:00,100
就像 Go 的其余部分，

1255
00:56:00,100 --> 00:56:02,890
但我们收到的提案却并非如此，

1256
00:56:02,920 --> 00:56:04,480
即使在几年前，

1257
00:56:04,540 --> 00:56:06,490
更不用说早期的那些了。

1258
00:56:08,860 --> 00:56:12,640
有人说他们很喜欢 defer ，这是语言中独有的。

1259
00:56:12,640 --> 00:56:14,200
我也是，谢谢。

1260
00:56:14,590 --> 00:56:16,390
但我想指出的是，

1261
00:56:16,390 --> 00:56:19,300
我们确实为 Go 创造了 defer ，

1262
00:56:19,390 --> 00:56:21,430
但是 Swift 已经采用了它，

1263
00:56:21,430 --> 00:56:24,220
我想 C++ 也有一个采用它的提议，

1264
00:56:24,220 --> 00:56:26,830
希望它能稍微走出去一点。

1265
00:56:29,280 --> 00:56:33,780
有一个问题是关于 Go 是用大写来导出。

1266
00:56:34,170 --> 00:56:36,450
我知道就像一些东西，

1267
00:56:36,750 --> 00:56:39,270
当你第一次看到它时，有点[不协调]，

1268
00:56:39,720 --> 00:56:41,130
这背后的故事是，

1269
00:56:41,130 --> 00:56:42,660
我们需要一些东西，

1270
00:56:42,960 --> 00:56:44,310
我们知道我们会需要一些东西，

1271
00:56:44,310 --> 00:56:45,540
但是一开始，我们只是说，

1272
00:56:45,540 --> 00:56:47,580
任何东西可导出，任何东西都是公开可见的，

1273
00:56:47,580 --> 00:56:48,690
我们以后再处理这件事，

1274
00:56:49,520 --> 00:56:50,450
大约一年后，

1275
00:56:50,450 --> 00:56:52,370
很明显，我们需要一些方法

1276
00:56:52,760 --> 00:56:55,580
让程序员对其他程序员隐藏一些东西，

1277
00:56:55,970 --> 00:57:00,200
你知道 C++ 有这个 public: 和 private: ，

1278
00:57:00,380 --> 00:57:01,880
在一个大的 struct 中，

1279
00:57:02,060 --> 00:57:03,380
这很烦人，

1280
00:57:03,380 --> 00:57:05,840
你查看定义时，

1281
00:57:05,840 --> 00:57:07,310
你必须向后滚动，

1282
00:57:07,310 --> 00:57:10,670
并查找最近的 public: 或 private: 在哪里，

1283
00:57:10,940 --> 00:57:12,200
如果真的很大，

1284
00:57:12,200 --> 00:57:13,250
可能很难找到，

1285
00:57:13,250 --> 00:57:16,550
所以，很难判断一个定义是公共的还是私有的。

1286
00:57:17,220 --> 00:57:20,430
然后在 Java 中，它当然位于每个单独字段的开头，

1287
00:57:20,820 --> 00:57:23,760
这似乎也有点过分，打字太多了。

1288
00:57:24,900 --> 00:57:26,130
所以我们又环顾了一下周围，

1289
00:57:26,130 --> 00:57:27,690
有人向我们指出，

1290
00:57:27,690 --> 00:57:29,310
Python 有这样的约定，

1291
00:57:29,310 --> 00:57:31,860
你在前面加下划线来隐藏一些东西，

1292
00:57:32,370 --> 00:57:33,690
这看起来很有趣，

1293
00:57:33,750 --> 00:57:36,600
但你可能不希望默认设置不被隐藏，

1294
00:57:36,630 --> 00:57:38,010
你希望默认设置隐藏。

1295
00:57:38,580 --> 00:57:42,480
然后我们想了想，我们可以在名字前面加一个加号，

1296
00:57:44,510 --> 00:57:45,800
然后有人建议，

1297
00:57:45,800 --> 00:57:48,110
如果大写字母可以导出怎么样，

1298
00:57:48,380 --> 00:57:50,870
这似乎是个愚蠢而糟糕的主意，

1299
00:57:51,050 --> 00:57:51,800
真的是这样，

1300
00:57:52,580 --> 00:57:54,020
但当你仔细想想，

1301
00:57:54,020 --> 00:57:55,700
我真的不喜欢这个主意，

1302
00:57:56,060 --> 00:57:59,870
我对坐在房间里的情景记忆犹新，

1303
00:57:59,870 --> 00:58:02,690
当我们讨论这个问题时，

1304
00:58:02,690 --> 00:58:04,400
但我没有合乎逻辑的理由反对它，

1305
00:58:04,430 --> 00:58:06,050
事实证明，这太棒了，

1306
00:58:06,200 --> 00:58:09,650
它从审美上看起来很糟糕，

1307
00:58:09,680 --> 00:58:12,380
但这是我现在最喜欢的 Go 的东西之一，

1308
00:58:12,380 --> 00:58:14,330
当你查看某个东西的使用时，

1309
00:58:14,360 --> 00:58:15,770
你可以立即看到，

1310
00:58:15,770 --> 00:58:16,880
你得到那个位，

1311
00:58:17,000 --> 00:58:19,790
这是不是其他人可以访问的东西，

1312
00:58:19,910 --> 00:58:20,660
每次使用时，

1313
00:58:20,660 --> 00:58:22,790
因为如果你看到代码调用一个函数

1314
00:58:22,790 --> 00:58:24,530
来做无论什么事情，

1315
00:58:24,530 --> 00:58:27,470
你考虑，哦，哇，其他人也能这么做吗，

1316
00:58:27,800 --> 00:58:29,930
你的大脑会处理这些问题，

1317
00:58:29,930 --> 00:58:31,040
但现在我转到 C++ ，

1318
00:58:31,040 --> 00:58:32,330
我看到这样的调用，

1319
00:58:32,600 --> 00:58:34,340
我真的很担心，

1320
00:58:34,340 --> 00:58:36,950
其他类也可以获取它吗，

1321
00:58:37,370 --> 00:58:41,390
事实证明，拥有这一位对于阅读代码非常有用。

1322
00:58:42,560 --> 00:58:44,570
有几个人问起了泛型。

1323
00:58:44,570 --> 00:58:45,410
如果你不知道，

1324
00:58:45,590 --> 00:58:47,600
我们有一个关于泛型的活跃的提议，

1325
00:58:47,600 --> 00:58:49,400
我们正在积极地实现它，

1326
00:58:49,640 --> 00:58:52,910
我们希望在今年晚些时候发布，

1327
00:58:53,120 --> 00:58:53,930
到今年年底，

1328
00:58:53,930 --> 00:58:56,660
我们将有一个完整版本的泛型，

1329
00:58:56,660 --> 00:58:58,100
你可以使用，

1330
00:58:58,280 --> 00:59:01,220
这将是一个预览版，

1331
00:59:01,250 --> 00:59:04,670
真正的发布我们希望是 Go 1.18 ，

1332
00:59:04,670 --> 00:59:06,050
也就是明年的二月，

1333
00:59:06,050 --> 00:59:07,580
也许下一次课程，

1334
00:59:07,610 --> 00:59:09,200
我们会用到泛型，

1335
00:59:09,200 --> 00:59:09,590
让我们拭目以待。

1336
00:59:10,910 --> 00:59:13,580
我当然很期待有一个通用的 min 和 max ，

1337
00:59:13,580 --> 00:59:15,050
我们没有这些的原因是，

1338
00:59:15,320 --> 00:59:17,030
我们必须选择它们是哪种类型的，

1339
00:59:17,030 --> 00:59:18,440
或者你有一整套这样的东西，

1340
00:59:18,440 --> 00:59:19,430
这看起来很愚蠢，

1341
00:59:19,430 --> 00:59:21,110
似乎我们应该等待泛型。

1342
00:59:22,540 --> 00:59:25,750
有人问，在编程领域，

1343
00:59:25,750 --> 00:59:29,140
Go 可能不是最好的语言，但它仍然在使用？

1344
00:59:29,380 --> 00:59:31,300
答案是绝对的，

1345
00:59:31,300 --> 00:59:33,640
这种情况在每种语言中都会发生。

1346
00:59:34,920 --> 00:59:37,860
我认为 Go 是一门很好的全能语言，

1347
00:59:37,890 --> 00:59:41,160
但你可能会把它用在不完美适用的东西上，

1348
00:59:41,730 --> 00:59:43,980
仅仅因为你的程序的其余部分是用 Go 写的，

1349
00:59:43,980 --> 00:59:46,260
你想要与程序的其余部分进行相互操作，

1350
00:59:46,260 --> 00:59:49,980
有一个网站叫做整数数列线上大全，

1351
00:59:50,310 --> 00:59:51,180
它是一个搜索引擎，

1352
00:59:51,180 --> 00:59:52,980
你可以输入 2 3 5 7 11 ，

1353
00:59:52,980 --> 00:59:54,300
它会告诉你这些是质数，

1354
00:59:55,410 --> 00:59:57,870
事实证明，这一切的后端都是用 Go 编写的，

1355
00:59:58,510 --> 01:00:00,310
如果你输入一个序列，

1356
01:00:00,310 --> 01:00:03,370
它对这些数字做了一些非常复杂的数学运算，

1357
01:00:03,370 --> 01:00:04,930
所有大数字或类似的东西，

1358
01:00:05,050 --> 01:00:06,550
所有这些都是用 Go 写的，

1359
01:00:06,550 --> 01:00:10,330
因为跳出做一些数学计算，

1360
01:00:10,330 --> 01:00:12,070
做一些跨语言的事情，

1361
01:00:12,070 --> 01:00:14,440
即使你更愿意在这些语言中实现，

1362
01:00:14,620 --> 01:00:18,430
所以你总是会遇到这样的妥协，这很好。

1363
01:00:22,520 --> 01:00:26,300
有人问， Go 应该很简单，

1364
01:00:26,330 --> 01:00:29,420
这就是为什么没有泛型和集合的原因，

1365
01:00:29,420 --> 01:00:31,100
但它不也是为软件开发人员的吗，

1366
01:00:31,100 --> 01:00:32,960
软件开发人员不需要所有这些东西吗，

1367
01:00:32,960 --> 01:00:34,760
重建它是愚蠢的。

1368
01:00:35,400 --> 01:00:38,160
我认为这是有些人的意思，

1369
01:00:38,160 --> 01:00:42,570
但是，省略东西的简单性从来不是我们的目标，

1370
01:00:42,840 --> 01:00:44,460
比如像集合，

1371
01:00:44,790 --> 01:00:47,040
映射看起来很像集合，

1372
01:00:47,040 --> 01:00:50,370
你有一个映射，其中的值为空或布尔值，

1373
01:00:50,610 --> 01:00:51,870
就是一个集合，

1374
01:00:52,050 --> 01:00:52,830
对于泛型，

1375
01:00:52,830 --> 01:00:56,940
你记得我们在 2007 年开始 Go ，

1376
01:00:57,000 --> 01:01:02,520
Java 刚刚结束了泛型推出的失败，

1377
01:01:02,820 --> 01:01:04,740
所以我们真的很害怕这样，

1378
01:01:04,740 --> 01:01:06,570
我们知道如果我们试着去做，

1379
01:01:06,930 --> 01:01:09,000
我们会把它做错，

1380
01:01:09,060 --> 01:01:12,030
我们知道我们可以在没有泛型的情况下编写很多有用的程序。

1381
01:01:12,200 --> 01:01:13,340
这就是我们所做的。

1382
01:01:14,110 --> 01:01:16,210
然后我们又回到了这个问题上，

1383
01:01:16,210 --> 01:01:20,140
当我们觉得已经花了足够多的时间编写其他程序，

1384
01:01:20,140 --> 01:01:23,800
我们了解了更多关于我们需要 Go 支持泛型的信息，

1385
01:01:24,010 --> 01:01:26,860
我们可以抽出时间与真正的专家交谈，

1386
01:01:26,980 --> 01:01:31,240
我想，如果在五年或十年前拥有它们会很好，

1387
01:01:31,240 --> 01:01:34,720
但我们就不会有现在这样好的，

1388
01:01:34,900 --> 01:01:36,610
所以我认为这可能是正确的决定。

1389
01:01:40,030 --> 01:01:41,680
这里有一个问题，

1390
01:01:41,680 --> 01:01:44,650
关于 goroutine 与 Plan 9 线程库的关系，

1391
01:01:44,650 --> 01:01:46,570
这些都是协同调度的，

1392
01:01:47,020 --> 01:01:49,180
以及 goroutine 是否对进行了适当的调度，

1393
01:01:49,180 --> 01:01:50,800
这是否会造成问题？

1394
01:01:51,430 --> 01:01:52,720
绝对是这样的，

1395
01:01:52,720 --> 01:01:56,260
Go 和 goroutine 运行时，

1396
01:01:56,260 --> 01:01:59,410
灵感来自于之前在 Plan 9 上的经验，

1397
01:01:59,650 --> 01:02:02,050
有一种不同的语言称为 Alef ，

1398
01:02:02,080 --> 01:02:03,520
在早期版本的 Plan 9 上，

1399
01:02:03,670 --> 01:02:07,480
它是汇编的，它有 channel ，它有 select ，

1400
01:02:07,570 --> 01:02:09,550
它有一些我们称之为 task 的东西，

1401
01:02:09,550 --> 01:02:10,870
有点像 goroutine ，

1402
01:02:10,870 --> 01:02:12,280
但它没有垃圾收集器，

1403
01:02:12,280 --> 01:02:14,710
这在很多情况下让事情变得非常烦人，

1404
01:02:14,920 --> 01:02:17,140
以及 task 的工作方式，

1405
01:02:17,140 --> 01:02:18,940
它们绑定在一个特定的线程上，

1406
01:02:18,940 --> 01:02:21,370
所以，你可能在一个线程中有三个 task ，

1407
01:02:21,430 --> 01:02:23,080
在另一个线程中有两个 task ，

1408
01:02:23,600 --> 01:02:25,610
在第一个线线程的三个 task 中，

1409
01:02:25,640 --> 01:02:27,680
它们一次只跑一个，

1410
01:02:27,680 --> 01:02:30,350
它们只能在 channel 操作期间重新调度，

1411
01:02:30,500 --> 01:02:31,850
所以，你可以编写代码，

1412
01:02:31,850 --> 01:02:34,940
其中这三个 task 都在相同的数据结构上运行，

1413
01:02:35,060 --> 01:02:36,350
你知道，

1414
01:02:36,380 --> 01:02:38,120
因为当你写它的时候，它就在你的脑海中，

1415
01:02:38,770 --> 01:02:40,030
这是可以的，

1416
01:02:40,030 --> 01:02:43,150
这两个不同的 task 在相同的数据结构上[涂鸦]，

1417
01:02:43,150 --> 01:02:45,010
因为它们永远不可能同时运行。

1418
01:02:45,640 --> 01:02:47,170
同时，在另一个线程中，

1419
01:02:47,170 --> 01:02:50,320
不同的数据和不同的任务也有相同的情况，

1420
01:02:50,650 --> 01:02:52,780
然后六个月后，你又回到了同样的项目，

1421
01:02:52,780 --> 01:02:56,500
你完全忘记了哪个 task 可以写入不同的数据，

1422
01:02:56,650 --> 01:02:58,600
我肯定我们有无数的竞争，

1423
01:02:58,600 --> 01:03:01,450
我的意思是，它是小型程序的一个很好的模型，

1424
01:03:01,450 --> 01:03:04,870
对于一段长时间的编程，这是一个糟糕的模式，

1425
01:03:04,870 --> 01:03:07,330
或者一个其他人参加的大型程序。

1426
01:03:07,960 --> 01:03:09,550
所以，这从来不是 Go 的模式，

1427
01:03:09,550 --> 01:03:11,200
Go 的模式总是，

1428
01:03:11,440 --> 01:03:13,510
有这些轻量级的 goroutine 很好，

1429
01:03:13,510 --> 01:03:15,820
但它们都独立运行，

1430
01:03:15,820 --> 01:03:17,860
如果它们要分享任何东西，就需要锁，

1431
01:03:17,860 --> 01:03:21,820
或者它们需要使用 channel 进行通信和协调。

1432
01:03:22,750 --> 01:03:27,010
这无疑比以往任何一种简单的方式都要好得多，

1433
01:03:27,550 --> 01:03:32,070
有时候人们听说 goroutine 是协同调度的，

1434
01:03:32,070 --> 01:03:34,380
它们认为更多类似的事情，

1435
01:03:34,560 --> 01:03:37,590
在早期是真的，

1436
01:03:37,680 --> 01:03:40,800
goroutine 并不是你知道的抢占式调度，

1437
01:03:41,040 --> 01:03:43,020
所以在非常非常早期的时候，

1438
01:03:43,020 --> 01:03:45,480
唯一的抢占点是当你进入运行时时，

1439
01:03:45,660 --> 01:03:46,980
在那之后不久，

1440
01:03:47,010 --> 01:03:49,350
抢占是任何时候你进入一个函数，

1441
01:03:50,640 --> 01:03:53,430
但如果处于一个紧密的循环中很长一段时间，

1442
01:03:53,430 --> 01:03:54,540
这永远不会抢占，

1443
01:03:54,540 --> 01:03:56,550
这将导致垃圾收集器延迟，

1444
01:03:56,550 --> 01:03:58,800
因为垃圾收集器需要停止所有的 goroutine ，

1445
01:03:58,950 --> 01:04:00,930
有一些 goroutine 被困在一个紧密的循环中，

1446
01:04:00,930 --> 01:04:02,550
要完成这一循环将需要永远的时间，

1447
01:04:03,100 --> 01:04:05,680
所以在最近的几个版本中，

1448
01:04:05,680 --> 01:04:06,580
我们终于开始，

1449
01:04:06,580 --> 01:04:07,120
我们发现，

1450
01:04:07,120 --> 01:04:11,050
如何以正确的方式将唯一的信号传递给线程，

1451
01:04:11,170 --> 01:04:13,630
所以，我们可以有正确的[簿记]，

1452
01:04:13,630 --> 01:04:16,180
能够使用抢占式机制。

1453
01:04:16,700 --> 01:04:18,170
所以现在的情况是，

1454
01:04:18,350 --> 01:04:22,340
我认为垃圾收集的抢占延迟最终完成了，

1455
01:04:22,370 --> 01:04:26,630
但从一开始，模型就是它们在抢占运行，

1456
01:04:26,690 --> 01:04:29,030
当它们抢占时，它们无法控制。

1457
01:04:30,980 --> 01:04:32,660
接下来的问题，

1458
01:04:32,660 --> 01:04:33,770
有人问到，

1459
01:04:33,950 --> 01:04:35,630
在哪里可以在源代码树中看到，

1460
01:04:35,630 --> 01:04:39,350
学习 goroutine 和 goroutine 调度器。

1461
01:04:39,620 --> 01:04:40,610
答案是，

1462
01:04:40,610 --> 01:04:42,590
这基本上是一个小的操作系统，

1463
01:04:42,620 --> 01:04:45,890
就像一个建立在其他操作系统之上的小操作系统，

1464
01:04:45,890 --> 01:04:48,590
而不是在 CPU 之上。

1465
01:04:49,100 --> 01:04:51,230
所以首先要做的是学习 6.828 ，

1466
01:04:51,230 --> 01:04:55,880
我的意思是我在 6.828 和 xv6 上工作，

1467
01:04:56,060 --> 01:04:59,390
在我做 Go 运行时的上一年，

1468
01:04:59,390 --> 01:05:01,910
所以，这与 Go 运行时有很大的联系。

1469
01:05:02,400 --> 01:05:05,010
在实际的 Go 运行时目录中，

1470
01:05:05,130 --> 01:05:06,720
有一个名为 proc.go 的文件，

1471
01:05:06,720 --> 01:05:08,640
你知道 proc 表示进程，

1472
01:05:08,640 --> 01:05:10,920
因为它在操作系统中就是这样的，

1473
01:05:11,340 --> 01:05:12,690
我会从那里开始，

1474
01:05:12,690 --> 01:05:13,950
这是开始的文件，

1475
01:05:13,950 --> 01:05:15,720
然后继续探索。

1476
01:05:17,930 --> 01:05:21,350
有人问到了 Python 的负索引，

1477
01:05:21,440 --> 01:05:23,090
你可以写 x[-1] ，

1478
01:05:23,510 --> 01:05:24,800
这引起了很多人的注意，

1479
01:05:24,830 --> 01:05:26,330
尤其是来自 Python 程序员，

1480
01:05:26,720 --> 01:05:28,850
这看起来是一个非常棒的想法，

1481
01:05:28,850 --> 01:05:30,740
你写这些非常好的优雅的程序，

1482
01:05:30,740 --> 01:05:32,210
如果你想得到最后一个元素，

1483
01:05:32,210 --> 01:05:33,440
你只需要写 x[-1] 。

1484
01:05:33,980 --> 01:05:36,740
但真正的问题是，你有 i 的 x ，

1485
01:05:36,860 --> 01:05:37,610
你有一个循环，

1486
01:05:37,610 --> 01:05:40,820
从 n 到 0 倒数，

1487
01:05:40,880 --> 01:05:42,440
你可以在某处减去 1 ，

1488
01:05:42,440 --> 01:05:45,830
现在 x[-1] ，而不是 x[i] ，

1489
01:05:45,830 --> 01:05:47,180
i 是 -1 ，

1490
01:05:47,210 --> 01:05:48,200
而不是一个错误，

1491
01:05:48,200 --> 01:05:50,870
你会说，这有一个 bug ，我需要找到它，

1492
01:05:50,990 --> 01:05:54,230
它只是默默地从数组的另一端获取元素，

1493
01:05:54,620 --> 01:05:57,530
这就是 Python 所做的，

1494
01:05:58,610 --> 01:06:01,520
简单只会让事情变得更糟，

1495
01:06:01,880 --> 01:06:03,350
这就是为什么我们没有做，

1496
01:06:03,350 --> 01:06:06,020
因为我们认为它会隐藏太多的 bug 。

1497
01:06:07,750 --> 01:06:08,980
你可以想象这样的情况，

1498
01:06:08,980 --> 01:06:12,250
比如 x $-1 ， len-1 ，

1499
01:06:12,250 --> 01:06:13,810
不是 x 的 len ，只是 len ，

1500
01:06:14,440 --> 01:06:16,660
但这看起来太特殊了，

1501
01:06:16,660 --> 01:06:18,580
事实上，这一点还不够多。

1502
01:06:20,430 --> 01:06:23,130
有人问到，

1503
01:06:23,130 --> 01:06:25,800
Go 的哪个方面最难实现？

1504
01:06:26,780 --> 01:06:29,150
老实说，这其中的许多事情并不是很难，

1505
01:06:29,480 --> 01:06:31,520
我们以前已经完成了大部分工作，

1506
01:06:31,550 --> 01:06:32,840
我们已经编写了操作系统，

1507
01:06:32,840 --> 01:06:35,150
以及读取库和 channel 实现，

1508
01:06:35,330 --> 01:06:37,730
所以，再做一次是相当简单的，

1509
01:06:38,150 --> 01:06:40,760
最难的可能是垃圾收集器，

1510
01:06:41,680 --> 01:06:44,350
Go 在垃圾收集语言中是唯一的，

1511
01:06:44,350 --> 01:06:47,590
它让程序员可以更好地控制内存布局，

1512
01:06:47,590 --> 01:06:50,890
所以，如果你想要一个内部有两个不同结构的结构，

1513
01:06:51,010 --> 01:06:52,660
这只是一大块内存，

1514
01:06:52,780 --> 01:06:55,660
它不是一个指向其他内存块的指针的结构。

1515
01:06:56,330 --> 01:06:57,140
正因为如此，

1516
01:06:57,140 --> 01:06:59,630
你可以获取结构中第二个字段的地址，

1517
01:06:59,630 --> 01:07:00,590
并将其传递，

1518
01:07:01,010 --> 01:07:03,770
这意味着垃圾回收器必须能够处理指针，

1519
01:07:03,920 --> 01:07:06,380
可以指向已分配对象中间，

1520
01:07:06,380 --> 01:07:09,320
这是 Java Lisp 和其他东西所不能做到的。

1521
01:07:10,360 --> 01:07:13,540
这使得垃圾收集器更复杂，

1522
01:07:13,540 --> 01:07:15,760
在如何维护它的数据结构方面。

1523
01:07:16,180 --> 01:07:17,680
我们也从一开始就知道，

1524
01:07:17,680 --> 01:07:19,570
你想要低延迟，

1525
01:07:19,570 --> 01:07:22,450
因为如果你正在处理网络请求，

1526
01:07:22,450 --> 01:07:26,080
你不能暂停 200 毫秒，

1527
01:07:26,080 --> 01:07:29,590
阻塞所有正在进行的请求进行垃圾收集，

1528
01:07:29,590 --> 01:07:33,460
它需要低延迟，而不是停止东西，

1529
01:07:33,460 --> 01:07:36,940
我们认为多核处理器在那里会是一个很好的机会，

1530
01:07:36,940 --> 01:07:39,490
因为我们可以让垃圾收集器在一个核心执行，

1531
01:07:39,640 --> 01:07:41,710
而 Go 程序使用其他的核心，

1532
01:07:41,710 --> 01:07:43,030
这可能工作地很好，

1533
01:07:43,030 --> 01:07:45,400
事实证明，这确实工作地很好，

1534
01:07:45,580 --> 01:07:48,670
但这需要聘请一位真正的垃圾收集专家，

1535
01:07:48,790 --> 01:07:51,190
来弄清楚怎么做，

1536
01:07:51,880 --> 01:07:53,200
并让它工作，

1537
01:07:53,290 --> 01:07:54,910
但现在它真的很棒。

1538
01:07:55,700 --> 01:07:57,470
我有一个简短的问题，

1539
01:07:57,500 --> 01:08:00,950
你说如果它是结构，

1540
01:08:01,280 --> 01:08:03,320
如果它在另一个 struct 中定义，

1541
01:08:03,650 --> 01:08:06,080
它实际上是一大块内存。

1542
01:08:06,260 --> 01:08:06,620
是的。

1543
01:08:06,620 --> 01:08:08,900
你为什么要这样实现，

1544
01:08:09,020 --> 01:08:10,310
这背后的原因是什么？

1545
01:08:11,210 --> 01:08:12,950
好的，这里有几个原因，

1546
01:08:12,950 --> 01:08:15,470
一个是垃圾收集器，它是一项服务，

1547
01:08:15,500 --> 01:08:19,610
垃圾收集器上的负载与你分配的对象数量成正比，

1548
01:08:19,910 --> 01:08:22,430
所以，如果你有一个由五个东西组成的结构，

1549
01:08:22,430 --> 01:08:23,900
你可以只分配一次，

1550
01:08:23,960 --> 01:08:26,570
这是垃圾收集器负载的五分之一，

1551
01:08:26,570 --> 01:08:27,830
事实证明，这一点非常重要。

1552
01:08:28,450 --> 01:08:31,960
但另一件重要的事情是缓存位置，

1553
01:08:31,960 --> 01:08:34,840
例如，如果处理器正在获取一大块内存，

1554
01:08:34,840 --> 01:08:37,060
以 64 字节块或其他，

1555
01:08:37,180 --> 01:08:39,670
整体地读取内存更好，

1556
01:08:39,700 --> 01:08:41,050
比起分散地读取内存。

1557
01:08:41,710 --> 01:08:45,820
我们在 Google 有一台 Git 服务器，名为 Gerrit ，

1558
01:08:46,000 --> 01:08:47,380
它是用 Java 编写的，

1559
01:08:47,410 --> 01:08:51,070
它开始在 Go 刚出现的时候，

1560
01:08:51,430 --> 01:08:53,860
我们刚好错过了编写 Gerrit 和 Go ，

1561
01:08:53,860 --> 01:08:54,970
我想是一年，

1562
01:08:55,660 --> 01:08:58,480
我们和编写 Gerrit 的人聊过，

1563
01:08:58,630 --> 01:09:02,020
他说 Gerrit 中的一个最大的问题是，

1564
01:09:02,140 --> 01:09:03,880
你只有[?很短的 hash] ，

1565
01:09:03,940 --> 01:09:06,250
你有 20 个字节的想法，

1566
01:09:06,540 --> 01:09:08,070
在 Java 中是不可能的，

1567
01:09:08,100 --> 01:09:09,990
你不能在 struct 中有 20 个字节，

1568
01:09:10,260 --> 01:09:12,270
你必须具有指向对象的指针，

1569
01:09:12,450 --> 01:09:13,650
这样的对象，

1570
01:09:14,040 --> 01:09:16,080
你甚至不能在对象中有 20 个字节，

1571
01:09:16,080 --> 01:09:18,630
你必须声明五个类似的不同[]，

1572
01:09:18,630 --> 01:09:19,680
来获得 20 字节，

1573
01:09:20,040 --> 01:09:22,170
而且没有好的方法去做，

1574
01:09:22,170 --> 01:09:25,080
这只是一件如此简单的事情的开销，

1575
01:09:25,320 --> 01:09:26,430
真的[很有道理]。

1576
01:09:27,080 --> 01:09:29,210
所以我们认为

1577
01:09:29,210 --> 01:09:31,550
让程序员控制内存是非常重要的。

1578
01:09:35,180 --> 01:09:38,570
所以，另一个问题是关于自动并行化，

1579
01:09:38,570 --> 01:09:40,100
比如 for 循环之类的东西，

1580
01:09:40,130 --> 01:09:42,770
我们不会在 Go 标准工具链做这样的事，

1581
01:09:42,890 --> 01:09:47,060
有 Go 编译器， Go 前端 GCC 和 LLVM ，

1582
01:09:47,390 --> 01:09:48,380
在某种程度上，

1583
01:09:48,380 --> 01:09:50,900
Go 做了类似 C 语言中的这种循环优化，

1584
01:09:50,930 --> 01:09:54,170
我想我们从 Go []那里得到了同样的东西，

1585
01:09:54,350 --> 01:09:58,520
但这不是通常我们在 Google 需要的那种并行化，

1586
01:09:58,550 --> 01:10:02,540
更多的是很多服务器运行不同的东西，

1587
01:10:02,540 --> 01:10:04,310
所以你知道那种，

1588
01:10:04,980 --> 01:10:07,500
比如那种大的矢量数学之类的东西，

1589
01:10:07,500 --> 01:10:08,400
不会出现太多的问题，

1590
01:10:08,400 --> 01:10:10,920
所以这对我们来说并不那么重要。

1591
01:10:12,140 --> 01:10:14,840
然后我现在的最后一个问题是，

1592
01:10:14,840 --> 01:10:17,120
有人问到，

1593
01:10:17,120 --> 01:10:19,370
你如何决定何时获得释放锁，

1594
01:10:19,370 --> 01:10:20,720
为什么没有可重入锁？

1595
01:10:20,960 --> 01:10:22,880
对于这个，我想回顾一下幻灯片，

1596
01:10:22,880 --> 01:10:26,140
让我看看，是的，在这里，

1597
01:10:26,410 --> 01:10:28,600
在课程中，

1598
01:10:28,600 --> 01:10:30,100
我说了像锁，

1599
01:10:30,130 --> 01:10:32,890
mu 保护 map 或保护数据，

1600
01:10:33,220 --> 01:10:35,170
但我们在这一点上真正的意思是，

1601
01:10:35,170 --> 01:10:38,650
我们说的是，锁保护了一些不变量的集合，

1602
01:10:38,680 --> 01:10:40,900
适用于数据，

1603
01:10:41,260 --> 01:10:42,760
我们拥有锁的原因是

1604
01:10:42,760 --> 01:10:46,420
为了保护依赖于不变量的操作，

1605
01:10:46,420 --> 01:10:50,140
有时会暂时使彼此之间的不变量失效。

1606
01:10:50,860 --> 01:10:52,480
所以当你调用 lock 时，

1607
01:10:52,480 --> 01:10:53,680
你的意思是，

1608
01:10:54,010 --> 01:10:57,100
我需要利用这个锁保护的不变量，

1609
01:10:57,400 --> 01:10:58,270
当你调用 unlock 时，

1610
01:10:58,270 --> 01:11:00,250
你说的是我不再需要它们了，

1611
01:11:00,280 --> 01:11:03,010
如果我暂时让它们无效，

1612
01:11:03,130 --> 01:11:04,270
我已经把它们放回去了，

1613
01:11:04,300 --> 01:11:07,930
这样下一个调用 lock 的就会看到正确的不变量。

1614
01:11:08,980 --> 01:11:11,290
所以在 Mux 中，我们需要不变量，

1615
01:11:11,290 --> 01:11:14,650
每个注册的 pending channel 最多得到一个回复，

1616
01:11:15,700 --> 01:11:16,390
为了做到这一点，

1617
01:11:16,390 --> 01:11:18,130
当我们从 map 中取出 done 时，

1618
01:11:18,160 --> 01:11:21,250
我们还会在解锁之前将其从 map 上删除，

1619
01:11:21,520 --> 01:11:23,740
如果有一些单独的 cancel 操作，

1620
01:11:23,740 --> 01:11:26,050
也直接操作 map ，

1621
01:11:26,320 --> 01:11:27,610
它可以锁定，

1622
01:11:27,640 --> 01:11:28,690
它可以调用 lock ，

1623
01:11:28,930 --> 01:11:31,390
它可以将东西拿出来，调用 unlock ，

1624
01:11:32,110 --> 01:11:34,510
然后，如果它找到了，它会知道，

1625
01:11:34,600 --> 01:11:36,670
没有人发送到那里了，

1626
01:11:36,670 --> 01:11:37,960
因为我把它拿出来了，

1627
01:11:38,170 --> 01:11:41,230
如果我们编写这个代码

1628
01:11:41,230 --> 01:11:43,900
有额外的 unlock 和 relock

1629
01:11:43,900 --> 01:11:47,080
在 done 等于 pending[tag] 和 delete 之间，

1630
01:11:47,230 --> 01:11:50,890
那么你就不会再有不变量的保护了，

1631
01:11:50,890 --> 01:11:52,930
因为你会把东西放回去，

1632
01:11:52,930 --> 01:11:54,190
你已经 unlock 又 relock ，

1633
01:11:54,190 --> 01:11:55,870
不变量就被打破了。

1634
01:11:56,420 --> 01:11:58,490
所以，这一点非常重要，

1635
01:11:58,520 --> 01:12:01,970
正确地考虑锁是为了保护不变量。

1636
01:12:02,860 --> 01:12:05,410
所以，如果你有可重入锁

1637
01:12:05,900 --> 01:12:07,880
所有的东西都丢失了，

1638
01:12:07,910 --> 01:12:09,110
在没有可重入锁的情况下，

1639
01:12:09,110 --> 01:12:10,370
当你调用了 lock ，

1640
01:12:10,430 --> 01:12:11,270
在下一行，

1641
01:12:11,270 --> 01:12:14,270
锁被获取了，

1642
01:12:14,270 --> 01:12:15,440
所有不变量都是真的，

1643
01:12:16,100 --> 01:12:17,390
如果你有一个可重入锁，

1644
01:12:17,420 --> 01:12:18,080
你所知道的是，

1645
01:12:18,080 --> 01:12:20,780
所以不变量都是真的，

1646
01:12:20,810 --> 01:12:22,490
对于第一次加锁的，

1647
01:12:22,490 --> 01:12:24,380
出现在我的调用堆栈上，

1648
01:12:24,900 --> 01:12:26,280
你什么都不知道，

1649
01:12:26,820 --> 01:12:30,720
这就使得你很难去假设什么，

1650
01:12:31,500 --> 01:12:35,190
所以我认为可重入锁是 Java 遗留下来的不好的一部分。

1651
01:12:35,770 --> 01:12:37,720
可重入锁的另一个大问题是，

1652
01:12:37,720 --> 01:12:40,660
如果你的代码调用某些东西，

1653
01:12:40,660 --> 01:12:42,640
并且它依赖于可重入锁，

1654
01:12:42,670 --> 01:12:45,100
或者你已经在上面获得了锁，

1655
01:12:45,940 --> 01:12:47,980
然后，在某个时候，你说，

1656
01:12:48,010 --> 01:12:49,840
我想暂停一下，

1657
01:12:49,840 --> 01:12:52,210
或者我想在其他 goroutine 这么做，

1658
01:12:52,210 --> 01:12:53,590
在我等待其他事情的时候，

1659
01:12:53,710 --> 01:12:55,960
当你将代码移动到不同的 goroutine 时，

1660
01:12:56,140 --> 01:12:58,810
可重入总是意味着锁在同一堆栈上，

1661
01:12:58,810 --> 01:13:01,150
这可能是唯一可信的意思，

1662
01:13:01,540 --> 01:13:03,130
所以，如果你移动代码

1663
01:13:03,130 --> 01:13:06,340
执行可重入锁的代码移动到不同的堆栈上，

1664
01:13:06,800 --> 01:13:07,700
然后它就会陷入死锁，

1665
01:13:07,700 --> 01:13:10,910
因为死锁现在是一个真正的锁获取，

1666
01:13:10,910 --> 01:13:13,280
它会等着你释放锁，

1667
01:13:13,280 --> 01:13:14,090
你不会放手，

1668
01:13:14,090 --> 01:13:16,280
因为你认为代码需要完成运行。

1669
01:13:16,670 --> 01:13:20,390
所以，它从根本上与重构完全不兼容，

1670
01:13:20,390 --> 01:13:21,260
你使用代码，

1671
01:13:21,260 --> 01:13:23,570
并在不同的线程或不同的 goroutine 中运行。

1672
01:13:24,160 --> 01:13:25,780
所以，我的建议是，

1673
01:13:25,780 --> 01:13:28,240
只考虑锁保护不变量，

1674
01:13:28,480 --> 01:13:31,450
然后避免依赖可重入锁，

1675
01:13:31,450 --> 01:13:35,320
它真的不能很好地扩展到真正的程序。

1676
01:13:35,620 --> 01:13:37,150
所以我会把这张清单放回去，

1677
01:13:37,180 --> 01:13:38,680
我们有足够长的时间，

1678
01:13:38,680 --> 01:13:39,370
我可以试着解决，

1679
01:13:39,370 --> 01:13:40,330
停止演示。

1680
01:13:41,060 --> 01:13:43,340
然后我可以再回答几个问题，

1681
01:13:46,560 --> 01:13:47,400
有人有问题吗？

1682
01:13:47,880 --> 01:13:49,260
我有个问题，

1683
01:13:49,770 --> 01:13:55,230
我的意思是，我认为来自 Python 的东西非常有用，

1684
01:13:55,230 --> 01:13:58,830
使用标准函数操作是非常常见的，

1685
01:13:58,830 --> 01:14:02,820
比如 map 或 filter 等东西，

1686
01:14:02,820 --> 01:14:06,070
比如列表解析，

1687
01:14:06,490 --> 01:14:10,480
当我转到 Go 开始编程时，

1688
01:14:10,630 --> 01:14:12,550
过去我查了一下，

1689
01:14:12,550 --> 01:14:15,610
人们说你不应该这样做，用 Go 做这个。

1690
01:14:15,640 --> 01:14:16,000
是的。

1691
01:14:16,000 --> 01:14:17,020
我想知道为什么。

1692
01:14:17,750 --> 01:14:20,090
好的，我的意思是，

1693
01:14:20,120 --> 01:14:21,020
你可以用另一种方式，

1694
01:14:21,020 --> 01:14:22,490
所以你可以使用自己的方式，

1695
01:14:23,540 --> 01:14:26,270
但一个更大的问题是。

1696
01:14:27,580 --> 01:14:29,680
好的，这是一个答案，

1697
01:14:29,680 --> 01:14:30,940
另一个答案是，

1698
01:14:31,390 --> 01:14:33,670
如果你这么做的话，

1699
01:14:33,670 --> 01:14:35,560
你最终创造了大量的垃圾，

1700
01:14:35,590 --> 01:14:38,590
如果你不想给垃圾收集器带来太多的负担，

1701
01:14:38,590 --> 01:14:40,990
这是另一种避免这种情况的方式，

1702
01:14:41,590 --> 01:14:45,970
如果你有一个 map ，然后是一个 filter ，然后是另一个 map ，

1703
01:14:45,970 --> 01:14:47,800
你可以对数据进行一次循环，

1704
01:14:47,800 --> 01:14:49,180
而不是对数据进行三次循环，

1705
01:14:49,180 --> 01:14:51,100
每一次都会产生一种新的垃圾。

1706
01:14:53,390 --> 01:14:55,520
但是你知道现在我们有了泛型，

1707
01:14:55,970 --> 01:14:57,800
你可以编写这些函数，

1708
01:14:57,800 --> 01:15:00,950
之前你不能写出类型[]的那些函数，

1709
01:15:00,980 --> 01:15:02,630
所以从字面上看，你不可能写出它们，

1710
01:15:03,200 --> 01:15:04,370
Python 可以逃脱这一点。

1711
01:15:04,370 --> 01:15:06,620
因为它没有静态类型。

1712
01:15:06,710 --> 01:15:08,570
但现在我们有一种方法可以做到这一点，

1713
01:15:08,570 --> 01:15:10,850
我完全期待一旦泛型进入，

1714
01:15:10,850 --> 01:15:12,020
将是一个 slices 包，

1715
01:15:12,020 --> 01:15:13,160
如果您导入 slices ，

1716
01:15:13,160 --> 01:15:18,380
你可以执行 slices.map slices.filter 和 slices.unique 等操作，

1717
01:15:18,380 --> 01:15:20,000
我认为这些都会发生，

1718
01:15:20,150 --> 01:15:23,000
如果这是对的，那就太好了。

1719
01:15:25,900 --> 01:15:26,350
谢谢。

1720
01:15:26,620 --> 01:15:27,280
好的。

1721
01:15:28,820 --> 01:15:29,780
我有。

1722
01:15:29,930 --> 01:15:31,970
你有过的一个提示，

1723
01:15:32,390 --> 01:15:38,870
它是关于并发运行独立的 goroutine ，

1724
01:15:40,230 --> 01:15:42,090
其中一些代码的例子，

1725
01:15:42,090 --> 01:15:43,860
我想我没有理解，

1726
01:15:44,660 --> 01:15:45,290
在我看来，

1727
01:15:45,290 --> 01:15:49,550
你可以在同一个线程中调用函数，

1728
01:15:49,820 --> 01:15:51,740
而不是在不同的线程中，

1729
01:15:52,340 --> 01:15:55,520
我不知道你为什么在另一个线程调用它。

1730
01:15:56,290 --> 01:16:01,130
所以，通常是因为你想让它们独立进行，

1731
01:16:01,250 --> 01:16:04,820
所以在其中一个例子中，

1732
01:16:04,820 --> 01:16:09,680
有一个循环将发送任务到工作队列，

1733
01:16:10,560 --> 01:16:13,740
但服务器在不同的 goroutine 中运行，

1734
01:16:13,740 --> 01:16:15,750
从工作队列中读取并做工作，

1735
01:16:15,900 --> 01:16:16,980
但是当它们完成的时候，

1736
01:16:16,980 --> 01:16:20,460
它们发送，嘿，我完成了，发到 done channel ，

1737
01:16:20,790 --> 01:16:22,920
但是，一个发送， Go 没有完成，

1738
01:16:22,920 --> 01:16:25,650
直到接收与之匹配时，

1739
01:16:26,150 --> 01:16:28,910
所以，如果在工作队列中发送的内容，

1740
01:16:29,240 --> 01:16:31,550
不会从 done channel 接收，

1741
01:16:31,550 --> 01:16:33,710
直到它完成对所有工作队列的发送，

1742
01:16:34,070 --> 01:16:36,890
或者发送工作队列中所有任务中的所有工作，

1743
01:16:37,130 --> 01:16:38,450
那么现在你会陷入死锁，

1744
01:16:38,450 --> 01:16:40,640
因为主线程，

1745
01:16:40,670 --> 01:16:44,150
主 goroutine 正在尝试将新工作发送到服务器，

1746
01:16:44,180 --> 01:16:45,860
服务器不接受新的工作，

1747
01:16:45,860 --> 01:16:48,110
它们试图告诉主线程它们已经完成了，

1748
01:16:48,230 --> 01:16:50,240
但是主线程不会开始，

1749
01:16:50,240 --> 01:16:51,980
从 done channel 读取，

1750
01:16:52,160 --> 01:16:54,110
直到它完成了所有的工作，

1751
01:16:54,110 --> 01:16:56,240
所以它们只是互相凝视，

1752
01:16:56,240 --> 01:16:57,710
等待着不同的事情发生，

1753
01:16:57,830 --> 01:16:59,660
如果我们使用这个循环，

1754
01:16:59,660 --> 01:17:03,320
如果我们只是将 goroutine 放在发送工作的循环周围，

1755
01:17:03,380 --> 01:17:05,180
然后就可以去别的地方了，

1756
01:17:05,210 --> 01:17:06,590
然后它就可以独立进行了，

1757
01:17:06,590 --> 01:17:10,910
当它卡住，等待服务器获取更多工作时，

1758
01:17:10,970 --> 01:17:14,360
服务器停滞等待主 goroutine

1759
01:17:14,360 --> 01:17:16,910
确认它已经完成了一些工作，

1760
01:17:17,060 --> 01:17:19,670
现在，主 goroutine 进入了循环，

1761
01:17:19,730 --> 01:17:23,630
确认完成工作，

1762
01:17:23,630 --> 01:17:24,800
从 done channel 读取的工作，

1763
01:17:25,070 --> 01:17:27,150
所以这是一种分开的方式，

1764
01:17:27,150 --> 01:17:29,280
这是逻辑上两件不同的事情，

1765
01:17:29,340 --> 01:17:31,470
它们不一定要一个接一个地发生，

1766
01:17:31,650 --> 01:17:34,530
因为这些事件一个接一个发生，会导致死锁，

1767
01:17:34,530 --> 01:17:37,350
通过拿出一个，移动它，让它独立运行，

1768
01:17:38,340 --> 01:17:39,840
就消除了死锁。

1769
01:17:41,760 --> 01:17:42,900
非常感谢。

1770
01:17:42,930 --> 01:17:43,530
好的。

1771
01:17:44,460 --> 01:17:47,640
你能谈谈 Go 的竞态检测器是如何实现的吗？

1772
01:17:48,250 --> 01:17:50,170
当然，这是 LLVM 竞态检测器，

1773
01:17:50,470 --> 01:17:53,020
所以这可能没有帮助，

1774
01:17:53,020 --> 01:17:56,380
但这是 LLVM 所说的 ThreadSanitizer ，

1775
01:17:57,270 --> 01:18:02,430
我们链接了一个小的二进制 blob ，

1776
01:18:02,460 --> 01:18:04,500
因为我们不想所有依赖于 LLVM ，

1777
01:18:04,650 --> 01:18:06,510
但这是 LLVM 竞态检测器。

1778
01:18:06,690 --> 01:18:08,850
LLVM 竞态检测器的工作方式是

1779
01:18:08,850 --> 01:18:11,310
它分配了大量额外的虚拟内存，

1780
01:18:11,580 --> 01:18:15,480
然后根据正在读取或写入的东西的地址，

1781
01:18:15,630 --> 01:18:18,480
它在虚拟内存中有另一个点，

1782
01:18:18,480 --> 01:18:22,830
在那里记录了最后一个线程的信息，

1783
01:18:22,950 --> 01:18:25,860
它认为是线程，但它们是 goroutine ，

1784
01:18:25,920 --> 01:18:28,230
当最后一个线程执行读取或写入，

1785
01:18:28,320 --> 01:18:31,440
然后，每次异步事件发生时，

1786
01:18:31,440 --> 01:18:34,200
从一个 goroutine 到另一个的通信，

1787
01:18:34,690 --> 01:18:37,000
这相当于，

1788
01:18:37,000 --> 01:18:39,580
在两个不同的 goroutine 之间发生，

1789
01:18:39,700 --> 01:18:43,690
如果你得到了一些你可以读取或写入，

1790
01:18:43,960 --> 01:18:46,210
它们的序列不正确，

1791
01:18:46,210 --> 01:18:47,290
比如，你有一个读取，

1792
01:18:47,290 --> 01:18:49,450
然后它发生在另一个 goroutine 之前，

1793
01:18:49,450 --> 01:18:51,220
然后再进行写入，

1794
01:18:51,220 --> 01:18:51,970
这是好的，

1795
01:18:52,180 --> 01:18:53,500
但是如果你有一个读取和写入，

1796
01:18:53,500 --> 01:18:55,990
在连接它们的序列之前没有发生，

1797
01:18:56,110 --> 01:18:58,330
那么这就是一个竞争，

1798
01:18:58,360 --> 01:19:01,690
它有一些非常聪明的方法

1799
01:19:01,690 --> 01:19:04,360
来快速动态地计算出，

1800
01:19:04,360 --> 01:19:06,310
这个读取是否发生，

1801
01:19:06,520 --> 01:19:07,720
是否在[]之前发生，

1802
01:19:07,720 --> 01:19:09,490
在发生读取和写入之间，

1803
01:19:09,670 --> 01:19:12,820
它可能会使程序速度减慢 10 倍，

1804
01:19:12,880 --> 01:19:15,970
但是如果你只转移少量的流量，

1805
01:19:16,000 --> 01:19:16,990
这可能是好的，

1806
01:19:17,170 --> 01:19:19,300
如果是为了测试，那可能也没问题，

1807
01:19:19,570 --> 01:19:22,240
这比不知道竞争要好得多，

1808
01:19:22,270 --> 01:19:23,290
所以这绝对是值得的。

1809
01:19:23,470 --> 01:19:26,650
老实说，十倍或二十倍是很棒的，

1810
01:19:26,650 --> 01:19:30,100
原始的 ThreadSanitizer 更像是百倍千倍，

1811
01:19:30,100 --> 01:19:31,390
这是不够好的。

1812
01:19:31,960 --> 01:19:34,600
好的，竞态探测器叫什么， LLVM ？

1813
01:19:34,750 --> 01:19:36,100
它叫做 ThreadSanitizer ，

1814
01:19:36,100 --> 01:19:40,330
但它是 LLVM 的一部分，也就是 clang C 编译器，

1815
01:19:40,360 --> 01:19:43,360
现在几乎每个人都在用的那个，

1816
01:19:43,870 --> 01:19:46,840
是 LLVM 项目的一部分。

1817
01:19:54,740 --> 01:19:57,380
你能谈谈切片和设计选择吗，

1818
01:19:57,380 --> 01:19:59,360
将它们作为数组的视图，

1819
01:19:59,540 --> 01:20:01,130
这让我一开始就很困惑。

1820
01:20:01,220 --> 01:20:03,740
是的，一开始有点令人困惑，

1821
01:20:05,420 --> 01:20:06,620
最重要的是，

1822
01:20:06,620 --> 01:20:09,200
它希望能够高效地遍历一个数组，

1823
01:20:09,200 --> 01:20:12,230
或者你可以快速排序或合并排序，

1824
01:20:12,230 --> 01:20:13,760
你有一个数组，

1825
01:20:13,760 --> 01:20:14,450
现在你想说，

1826
01:20:14,450 --> 01:20:16,670
现在对这一半排序，然后对另一半排序，

1827
01:20:16,760 --> 01:20:18,500
你想要能够有效地说，

1828
01:20:18,500 --> 01:20:22,190
比如，这是前一半，对它进行排序，

1829
01:20:22,400 --> 01:20:25,460
所以，在 C 语言中，你这样做的方式是，

1830
01:20:25,460 --> 01:20:26,660
你只需要传入，

1831
01:20:26,720 --> 01:20:29,480
第一个元素的指针和元素的数量，

1832
01:20:29,630 --> 01:20:31,520
这就是切片的所有，

1833
01:20:31,700 --> 01:20:34,130
然后是另一种模式经常出现，

1834
01:20:34,130 --> 01:20:36,890
当你尝试高效地使用数组时，

1835
01:20:36,920 --> 01:20:38,300
就是你需要都它们扩展，

1836
01:20:38,600 --> 01:20:43,130
所以你不想对每个新的元素调用重新分配，

1837
01:20:43,130 --> 01:20:44,330
你想摊销这个，

1838
01:20:44,570 --> 01:20:48,170
所以你用 C 语言来做的方式是，

1839
01:20:48,170 --> 01:20:49,250
你有一个基础指针，

1840
01:20:49,280 --> 01:20:50,810
你有现在使用的长度，

1841
01:20:50,810 --> 01:20:52,190
你有你分配的长度，

1842
01:20:52,400 --> 01:20:54,200
然后，要添加一个，

1843
01:20:54,200 --> 01:20:57,200
你检查长度是否大于分配的数量，

1844
01:20:57,200 --> 01:20:58,160
如果是这样，你重新分配，

1845
01:20:58,160 --> 01:20:59,990
否则你就继续向前推进，

1846
01:21:00,260 --> 01:21:03,710
切片只是这些[习语的编码]，

1847
01:21:03,770 --> 01:21:06,920
因为这是管理内存的最有效的方式。

1848
01:21:07,280 --> 01:21:11,870
所以在任何类型的 C++ vector 或类似的东西中，

1849
01:21:11,900 --> 01:21:13,730
这就是下面发生的事情，

1850
01:21:13,820 --> 01:21:15,890
但这使得更困难，

1851
01:21:15,890 --> 01:21:18,200
比如 C++ vector ，

1852
01:21:18,230 --> 01:21:20,060
因为所有权的原因，

1853
01:21:20,120 --> 01:21:22,550
向量被绑定到实际的底层内存，

1854
01:21:22,550 --> 01:21:25,010
它很难获取一个子 vector ，

1855
01:21:25,010 --> 01:21:27,980
这只是合并排序的下半部分的视图。

1856
01:21:28,870 --> 01:21:30,730
所以这就是我的想法，

1857
01:21:30,730 --> 01:21:32,230
所有这些模式，

1858
01:21:32,230 --> 01:21:34,510
用来高效访问内存，来自 C 语言，

1859
01:21:34,900 --> 01:21:36,850
我们试图让它们适应 Go ，

1860
01:21:36,850 --> 01:21:39,570
以一种惯用的方式，以一种安全的方式。

1861
01:21:42,490 --> 01:21:44,980
你能谈谈你是如何决定

1862
01:21:44,980 --> 01:21:47,890
实现 Go 远程模块系统，

1863
01:21:47,890 --> 01:21:50,500
你可以直接从 URL 导入。

1864
01:21:50,500 --> 01:21:53,920
是的，我的意思是我只是不想运行一个服务，

1865
01:21:53,920 --> 01:21:57,710
很多像 Ruby gems 的东西，

1866
01:21:57,710 --> 01:22:02,090
这些并不是当时我脑海中浮现的，

1867
01:22:02,090 --> 01:22:03,290
因为它们是新的，

1868
01:22:03,380 --> 01:22:04,940
但我使用过 Perl ，

1869
01:22:04,940 --> 01:22:08,060
比如 CPAN ，我觉得它太疯狂了，

1870
01:22:08,060 --> 01:22:11,330
每个人都在争夺 db 这样的短名字，

1871
01:22:11,480 --> 01:22:13,820
可能应该有一场争论

1872
01:22:13,820 --> 01:22:16,220
关于谁将获得 "db" 包。

1873
01:22:18,070 --> 01:22:19,600
所以，把域名放在最前面，

1874
01:22:19,600 --> 01:22:21,160
似乎是分散它的一个好方法，

1875
01:22:21,760 --> 01:22:24,160
这对我们来说也是一个不运行任何服务器的好方法，

1876
01:22:24,160 --> 01:22:25,630
因为我们可以说，

1877
01:22:25,630 --> 01:22:27,310
我们会识别主机名，

1878
01:22:27,310 --> 01:22:29,500
然后 Go 从源代码管理获取，

1879
01:22:29,980 --> 01:22:31,390
从其他人的服务器上，

1880
01:22:31,420 --> 01:22:33,820
我认为这是一个非常棒的主意，

1881
01:22:34,300 --> 01:22:37,450
因为我们没有那种相同的基础设施，

1882
01:22:37,480 --> 01:22:39,100
其他东西所依赖的。

1883
01:22:40,190 --> 01:22:43,010
但在 Java 世界中，它很有问题，

1884
01:22:43,010 --> 01:22:46,160
有多个，没有一种标准的 registry ，

1885
01:22:46,160 --> 01:22:47,720
但它们都用这些短名字，

1886
01:22:47,840 --> 01:22:53,120
像 maven 可以配置为从多个不同的 registry 进行构建，

1887
01:22:53,480 --> 01:22:56,330
如果你是一家开源软件包提供商，

1888
01:22:56,330 --> 01:22:57,380
你必须四处走动，

1889
01:22:57,380 --> 01:22:59,810
确保你把它上传到所有不同的 registry ，

1890
01:22:59,900 --> 01:23:01,520
因为如果你错过了一个，

1891
01:23:01,520 --> 01:23:02,690
并且它变得流行起来，

1892
01:23:02,690 --> 01:23:04,760
其他人会将不同的代码上传到那里，

1893
01:23:05,150 --> 01:23:08,990
然后， maven 只取先回来的那个，

1894
01:23:08,990 --> 01:23:10,430
它只是向所有发送请求，

1895
01:23:10,430 --> 01:23:11,540
无论最先返回的是什么，

1896
01:23:11,540 --> 01:23:14,660
如果有人想要恶意复制你的软件包，

1897
01:23:14,660 --> 01:23:17,720
它可以找到人们使用但是你没有上传的 registry ，

1898
01:23:17,750 --> 01:23:21,350
他们有时会赢得竞争，

1899
01:23:21,410 --> 01:23:23,180
所以这是一个真正的问题，

1900
01:23:23,180 --> 01:23:24,350
我认为拥有域名

1901
01:23:24,350 --> 01:23:27,740
有助于以非常重要的方式拆分所有权。

1902
01:23:29,110 --> 01:23:29,410
谢谢。

1903
01:23:29,410 --> 01:23:29,560
好的。

1904
01:23:34,920 --> 01:23:37,890
也许在这里稍作停顿，

1905
01:23:38,070 --> 01:23:39,510
如果大家必须走可以走，

1906
01:23:39,510 --> 01:23:42,270
我相信 Russ 愿意多待一段时间，

1907
01:23:42,810 --> 01:23:44,190
并回答任何问题，

1908
01:23:44,190 --> 01:23:47,610
但我要感谢 Russ 的这次课程，

1909
01:23:47,730 --> 01:23:50,940
希望这帮助你编写更多好的 Go 程序，

1910
01:23:51,460 --> 01:23:52,930
使用这些模式，

1911
01:23:52,930 --> 01:23:54,910
所以，谢谢你， Russ 。

1912
01:23:55,890 --> 01:23:57,180
不客气，很高兴来到这里。

1913
01:24:00,180 --> 01:24:02,280
然后是更多的问题，请随意提问。

1914
01:24:02,640 --> 01:24:03,060
是的。

1915
01:24:03,780 --> 01:24:05,910
哦，只是一点后勤上的事情，

1916
01:24:06,240 --> 01:24:09,420
6.824 网站上的幻灯片

1917
01:24:09,420 --> 01:24:12,420
与 Russ 的幻灯片不完全相同。

1918
01:24:12,450 --> 01:24:15,540
我去给 Frans 一个新的 PDF 。

1919
01:24:18,340 --> 01:24:20,080
一个更普遍的问题，

1920
01:24:20,640 --> 01:24:22,680
什么时候写一门新的语言，

1921
01:24:22,680 --> 01:24:25,650
解决问题的最佳方案。

1922
01:24:25,920 --> 01:24:26,880
这是一个很好的问题，

1923
01:24:26,880 --> 01:24:28,620
它几乎从来都不是最好的解决方案。

1924
01:24:30,340 --> 01:24:34,300
但是当时我们有大量的程序员，

1925
01:24:34,300 --> 01:24:36,670
数千名程序员在一个代码库中工作，

1926
01:24:36,940 --> 01:24:39,700
[汇编工作]耗费了很长时间，

1927
01:24:39,730 --> 01:24:45,430
因为 C++ 不适合高效的增量编译。

1928
01:24:46,030 --> 01:24:52,510
另外， threading 库这样的东西很糟糕，

1929
01:24:52,510 --> 01:24:53,740
人们不使用线程，

1930
01:24:53,740 --> 01:24:55,840
我记得在 MIT 的第一天，

1931
01:24:55,840 --> 01:24:56,740
我和 Robert 聊天，

1932
01:24:56,890 --> 01:24:58,180
Robert 对我说，

1933
01:24:58,210 --> 01:24:59,920
在 2001 年他对我说，

1934
01:24:59,920 --> 01:25:00,970
我们不使用线程，

1935
01:25:00,970 --> 01:25:01,930
因为线程很慢。

1936
01:25:02,350 --> 01:25:04,360
这完全是正常的，

1937
01:25:04,360 --> 01:25:07,120
这就是当时的世界。

1938
01:25:07,960 --> 01:25:10,270
在 Google ，我们遇到了很多麻烦，

1939
01:25:10,330 --> 01:25:13,660
因为它都是 C++ 上基于事件的回调，

1940
01:25:13,840 --> 01:25:15,850
有这些多核机器，

1941
01:25:15,850 --> 01:25:18,040
我们不知道如何在它们上面工作，

1942
01:25:18,040 --> 01:25:21,580
因为 Linux 线程不是你可以依赖的东西，

1943
01:25:22,030 --> 01:25:25,000
所以我们最终，如果你有一台四核机器，

1944
01:25:25,000 --> 01:25:26,560
你运行四个不同的进程，

1945
01:25:26,560 --> 01:25:28,510
web 服务器的完全独立的进程，

1946
01:25:28,510 --> 01:25:31,210
把它当作四台机器，

1947
01:25:31,480 --> 01:25:33,580
这显然不是很有效率，

1948
01:25:33,610 --> 01:25:37,030
所以，有很多很好的理由去尝试一些东西。

1949
01:25:38,900 --> 01:25:40,910
但是需要大量的工作，

1950
01:25:40,910 --> 01:25:42,530
达到今天的 Go 的水平，

1951
01:25:42,530 --> 01:25:46,370
我认为，很多不是语言，

1952
01:25:46,370 --> 01:25:48,290
我们在语言中做了一些重要的事情，

1953
01:25:48,290 --> 01:25:50,930
使其他考虑成为可能，

1954
01:25:51,050 --> 01:25:54,380
但很多成功的语言，

1955
01:25:54,380 --> 01:25:55,910
围绕它建立的生态系统

1956
01:25:55,910 --> 01:25:57,830
和我们在 Go 命令中建立的工具，

1957
01:25:57,830 --> 01:25:59,870
所有这些都不是语言上的东西，

1958
01:25:59,870 --> 01:26:01,910
所以，主要语言，

1959
01:26:02,480 --> 01:26:04,580
专注于语言本身的人，

1960
01:26:04,880 --> 01:26:07,460
我觉得有时候会被周围的事情分心，

1961
01:26:07,460 --> 01:26:08,900
他们忘记周围的一切。

1962
01:26:15,250 --> 01:26:17,230
哦，我能问得更多吗？

1963
01:26:17,440 --> 01:26:18,040
当然。

1964
01:26:18,250 --> 01:26:21,580
我想知道现在 Go 有什么不同，

1965
01:26:21,580 --> 01:26:24,370
因为它比以前更成熟了。

1966
01:26:26,050 --> 01:26:28,510
哦，这是个好问题，

1967
01:26:28,780 --> 01:26:30,310
在早期，

1968
01:26:30,310 --> 01:26:31,810
做出改变是很容易的，

1969
01:26:31,840 --> 01:26:33,670
现在要做出改变很难，

1970
01:26:33,700 --> 01:26:35,740
我认为这是最重要的事情。

1971
01:26:36,500 --> 01:26:38,450
在早期，

1972
01:26:38,450 --> 01:26:41,300
所有东西都在一个源代码仓库，

1973
01:26:41,300 --> 01:26:43,820
从字面上看，世界上所有的 Go 代码都在一个源代码仓库，

1974
01:26:43,820 --> 01:26:45,770
那些日子我们改变语法，

1975
01:26:45,770 --> 01:26:48,800
以前每次设置 channel 都有 * 在 chan 之前，

1976
01:26:48,800 --> 01:26:50,420
因为它下面是一个指针，

1977
01:26:50,420 --> 01:26:51,920
所有的东西都被曝光了，

1978
01:26:51,920 --> 01:26:54,080
所以你总是说 *chan int 而不是 chan int ，

1979
01:26:54,470 --> 01:26:55,940
map 也是这样，

1980
01:26:55,940 --> 01:26:58,250
在某个时刻，我们意识到这很愚蠢，

1981
01:26:58,250 --> 01:26:59,390
你不得不说星号，

1982
01:26:59,390 --> 01:27:00,230
让我们把它拿出来，

1983
01:27:00,680 --> 01:27:03,320
我们对编译器进行了修改，

1984
01:27:03,320 --> 01:27:07,610
我在我的编辑器中打开世界上几百个 Go 源文件，

1985
01:27:07,610 --> 01:27:10,200
整个团队都站在我身后，

1986
01:27:10,200 --> 01:27:11,610
我输入一些正则表达式，

1987
01:27:11,610 --> 01:27:13,560
我们观察了对文件的影响，

1988
01:27:13,560 --> 01:27:14,490
是的，看起来是对的，

1989
01:27:14,520 --> 01:27:16,530
保存它，编译它，我们完成了，

1990
01:27:17,040 --> 01:27:20,850
今天，我们不能做出向后不兼容的改变，

1991
01:27:21,960 --> 01:27:24,360
甚至做出类似的新改变，

1992
01:27:25,320 --> 01:27:26,760
它影响很多人，

1993
01:27:26,790 --> 01:27:30,750
所以，你提出了一些建议，

1994
01:27:30,750 --> 01:27:32,970
这些对我是行不通的，

1995
01:27:32,970 --> 01:27:34,650
你可能会试着去调整它。

1996
01:27:35,190 --> 01:27:36,450
这要困难得多，

1997
01:27:36,450 --> 01:27:40,050
我们估计世界上至少有 100 万，也许 200 万 Go 程序员，

1998
01:27:40,050 --> 01:27:43,650
与只有四五个非常不同。

1999
01:27:51,830 --> 01:27:53,210
不确定这是不是一个有效的问题，

2000
01:27:53,210 --> 01:27:55,310
但是 Go 是用什么语言写的，

2001
01:27:55,310 --> 01:27:57,050
也是用 Go 写的，或者不是。

2002
01:27:57,500 --> 01:27:58,760
现在它是，

2003
01:27:58,760 --> 01:28:01,250
最初的编译器运行时是使用 C 编写的，

2004
01:28:01,400 --> 01:28:03,410
但几年前，我们经历了一个大的，

2005
01:28:03,950 --> 01:28:07,040
我们编写了一个程序将 C 转换为 Go ，

2006
01:28:07,250 --> 01:28:09,830
它只适用于我们的 C 代码，但仍然足够好，

2007
01:28:10,040 --> 01:28:14,030
这样我们不会丢失代码中的所有编码[知识]，

2008
01:28:14,090 --> 01:28:16,370
关于为什么事情是这样的以及事情是如何运作的，

2009
01:28:16,370 --> 01:28:17,570
所以我们不是从头开始，

2010
01:28:17,660 --> 01:28:19,250
但现在它是用 Go 编写的，

2011
01:28:19,400 --> 01:28:20,780
以及一些汇编。

2012
01:28:21,160 --> 01:28:24,010
这意味着人们可以，

2013
01:28:24,010 --> 01:28:27,640
知道 Go 的人可以在 Go 项目上提供帮助，

2014
01:28:27,640 --> 01:28:28,390
而在以前，

2015
01:28:28,390 --> 01:28:30,880
如果你想对编译器或运行时工作，

2016
01:28:30,880 --> 01:28:32,380
你必须非常了解 C ，

2017
01:28:32,380 --> 01:28:35,080
我们没有让很多人真正了解 C ，

2018
01:28:35,080 --> 01:28:37,000
并不是按比例有那么多，

2019
01:28:37,000 --> 01:28:39,580
此外，我们的所有用户群是 Go 程序员，

2020
01:28:39,580 --> 01:28:40,600
而不是 C 程序员，

2021
01:28:40,840 --> 01:28:42,940
所以迁移到 Go 是一件非常重要的事情。

2022
01:28:46,230 --> 01:28:47,880
我想知道，你如何确定

2023
01:28:47,940 --> 01:28:51,450
语言添加哪些功能的优先级，

2024
01:28:51,450 --> 01:28:55,020
我知道泛型，我们提问的，

2025
01:28:55,020 --> 01:28:58,250
你知道如何选择要做的工作？

2026
01:28:59,210 --> 01:29:02,060
我的意思是，我们认为语言已经冻结了一段时间，

2027
01:29:02,330 --> 01:29:04,670
所以我们没有增加太多，

2028
01:29:04,730 --> 01:29:05,750
有很长一段时间，

2029
01:29:05,750 --> 01:29:06,950
我们说过不会增加任何东西，

2030
01:29:06,950 --> 01:29:10,160
然后在过去的几年里，我们增加了一些东西，

2031
01:29:10,160 --> 01:29:12,470
要引导泛型，甩掉 Rust ，

2032
01:29:12,470 --> 01:29:15,200
当你改变语言中的某些东西时，什么会破坏，

2033
01:29:15,440 --> 01:29:18,080
所以现在你可以在数字和长数字之间加下划线，

2034
01:29:18,080 --> 01:29:18,860
诸如此类的事情。

2035
01:29:20,620 --> 01:29:24,160
但你知道，泛型显然是下一步需要发生的事情，

2036
01:29:24,160 --> 01:29:25,480
我们只需要弄清楚如何做到这一点。

2037
01:29:26,430 --> 01:29:28,140
通常，我们只尝试添加东西

2038
01:29:28,140 --> 01:29:31,740
与其他功能没有奇怪干扰，

2039
01:29:32,100 --> 01:29:34,470
我们试图添加真正重要的东西，

2040
01:29:34,470 --> 01:29:36,810
这些东西将帮助许多人编程，

2041
01:29:36,810 --> 01:29:38,370
我们为 Go 定的目标，

2042
01:29:38,370 --> 01:29:41,190
像分布式系统之类的东西。

2043
01:29:50,050 --> 01:29:50,770
好吗？

2044
01:29:50,800 --> 01:29:51,220
谢谢。

2045
01:29:51,940 --> 01:29:55,120
哦，我有个问题，

2046
01:29:55,120 --> 01:29:58,030
所以，我注意到，

2047
01:29:58,030 --> 01:30:03,010
Go 没有像 min 或 max 这样的基本函数，

2048
01:30:03,520 --> 01:30:06,820
是的，那么这是不是像你正在考虑的事情，

2049
01:30:06,820 --> 01:30:08,920
比如添加泛型的东西，

2050
01:30:08,920 --> 01:30:10,300
也许这就是你没有这么做的原因。

2051
01:30:10,330 --> 01:30:14,620
完全正确，因为你不能有 min_int ，

2052
01:30:14,620 --> 01:30:15,970
它们有不同的名字，

2053
01:30:16,120 --> 01:30:17,110
这有点烦人。

2054
01:30:17,540 --> 01:30:19,880
所以现在我们可以只写一个通用名称，

2055
01:30:20,450 --> 01:30:22,430
任何具有小于运算符的类型。

2056
01:30:22,940 --> 01:30:23,480
嗯。

2057
01:30:23,480 --> 01:30:24,140
那就太好了。

2058
01:30:24,140 --> 01:30:27,500
老实说，对于 min 和 max 的情况。

2059
01:30:27,680 --> 01:30:30,350
编写代码并不那么难，我知道。

2060
01:30:30,350 --> 01:30:32,690
我想说，我开始觉得我们应该把它们构建起来，

2061
01:30:32,690 --> 01:30:35,330
就像 print 之类的东西，

2062
01:30:35,360 --> 01:30:37,400
这样你就可以一直拥有它们，

2063
01:30:37,520 --> 01:30:38,930
但即使我们不这么做，

2064
01:30:38,930 --> 01:30:41,270
你会有 math.min ，至少会在那里。

2065
01:30:41,620 --> 01:30:42,580
嗯。

2066
01:30:42,700 --> 01:30:44,110
我们不想构建它们，

2067
01:30:44,110 --> 01:30:46,090
直到我们能表达它们的类型，

2068
01:30:46,090 --> 01:30:47,740
在泛型出现之前，我们无法做到这一点。

2069
01:30:48,300 --> 01:30:51,510
因为浮点数有一个 min 。

2070
01:30:51,510 --> 01:30:53,370
是的，我知道这有点奇怪，

2071
01:30:53,370 --> 01:30:57,450
因为 math 库是从 C math.h 复制过来的，

2072
01:30:57,480 --> 01:31:00,090
一样的东西。

2073
01:31:00,090 --> 01:31:00,750
嗯。

2074
01:31:01,020 --> 01:31:01,800
这是很好的观点，

2075
01:31:01,800 --> 01:31:03,060
我们不能把它们放在 math 上，

2076
01:31:03,060 --> 01:31:04,140
因为它们已经在那里了。

2077
01:31:04,720 --> 01:31:05,500
好的。

2078
01:31:05,860 --> 01:31:06,130
但是。

2079
01:31:06,130 --> 01:31:06,880
嗯。

2080
01:31:07,090 --> 01:31:08,020
我们会弄清楚，

2081
01:31:08,020 --> 01:31:09,790
我觉得我们应该把它们放进语言里，

2082
01:31:09,790 --> 01:31:11,350
但我们必须首先有泛型。

2083
01:31:11,650 --> 01:31:12,640
还有一件事，

2084
01:31:12,670 --> 01:31:15,970
我注意到你参加了 USACO 竞赛编程，

2085
01:31:16,420 --> 01:31:17,560
我也这么做了。

2086
01:31:18,100 --> 01:31:18,460
酷。

2087
01:31:18,490 --> 01:31:20,200
是的，那么你是如何，

2088
01:31:20,200 --> 01:31:23,560
我把这个包括在我提交的一个问题中，

2089
01:31:23,560 --> 01:31:24,880
让我把找出来，

2090
01:31:24,940 --> 01:31:27,340
所以我的问题是，

2091
01:31:27,670 --> 01:31:33,250
你是怎么从竞技编程

2092
01:31:33,250 --> 01:31:36,520
到你现在在 Google 工作在 Go 上，

2093
01:31:36,520 --> 01:31:40,810
从竞赛编程到系统是如何转变的，

2094
01:31:40,810 --> 01:31:43,510
最后是什么让你决定进入系统，

2095
01:31:43,510 --> 01:31:45,790
它与编程代码有什么关系？

2096
01:31:45,790 --> 01:31:48,100
我的意思是，当时的竞赛编程，

2097
01:31:48,100 --> 01:31:50,830
它并不像我现在那样耗费精力，

2098
01:31:50,920 --> 01:31:55,940
比如，你可以实现一个简单的动态编程，

2099
01:31:55,940 --> 01:31:58,220
比如两个 for 循环，这很好，

2100
01:31:58,220 --> 01:32:00,260
现在你必须使用复杂的算法

2101
01:32:00,260 --> 01:32:01,940
和所有我能做到的东西，

2102
01:32:02,060 --> 01:32:05,960
所以在某种程度上，它是不同的。

2103
01:32:06,480 --> 01:32:09,810
但是，我更感兴趣的是系统，

2104
01:32:09,810 --> 01:32:11,070
从一开始就开始，

2105
01:32:11,160 --> 01:32:14,880
而编程竞赛只是在业余时间做一些有趣的事情。

2106
01:32:15,060 --> 01:32:15,600
噢。

2107
01:32:15,600 --> 01:32:17,640
这并不是一个巨大的转变，

2108
01:32:17,670 --> 01:32:20,730
我从来不喜欢实现复杂的算法，

2109
01:32:20,970 --> 01:32:23,760
最大流量和诸如此类的东西。

2110
01:32:23,910 --> 01:32:26,910
另一方面，当你开始学习一门新语言时，

2111
01:32:27,280 --> 01:32:30,610
你可以写你很多核心的东西，

2112
01:32:30,640 --> 01:32:32,980
比如有人必须编写排序函数，

2113
01:32:33,400 --> 01:32:35,470
而且它必须是一个很好的通用排序函数，

2114
01:32:35,470 --> 01:32:37,150
就像我上个月花了一段时间，

2115
01:32:37,150 --> 01:32:39,040
比如研究[DIP]算法，

2116
01:32:39,040 --> 01:32:42,820
很好地匹配了背景，

2117
01:32:43,180 --> 01:32:44,350
所以，它确实出现了。

2118
01:32:44,810 --> 01:32:48,050
但是，这只是一种不同的编程。

2119
01:32:48,290 --> 01:32:50,060
哦，那么，你认为它更多的是一种业余的东西，

2120
01:32:50,060 --> 01:32:50,900
当时，没有。

2121
01:32:50,900 --> 01:32:53,750
是的，这绝对不是我主要的事情，

2122
01:32:53,750 --> 01:32:54,800
当我编写程序时。

2123
01:32:54,890 --> 01:32:57,830
是的，因为今天，它就像是主要的东西。

2124
01:32:57,830 --> 01:32:58,400
我知道，

2125
01:32:58,400 --> 01:33:00,740
如果你不全职做，

2126
01:33:00,740 --> 01:33:02,090
你根本做不好。

2127
01:33:02,810 --> 01:33:05,870
好的，他们只是想要那些在 1995 的人关心。

2128
01:33:07,180 --> 01:33:09,580
是的，二十年后。

2129
01:33:15,190 --> 01:33:17,170
我要问一个相关的问题，

2130
01:33:17,170 --> 01:33:23,410
那么，你如何决定从学术工作进入，

2131
01:33:23,500 --> 01:33:26,500
我的意思是，你的工作仍然有一点不同，

2132
01:33:26,500 --> 01:33:30,730
比起普通的软件工程，仍然是。

2133
01:33:32,040 --> 01:33:34,750
是的，我很幸运，

2134
01:33:34,750 --> 01:33:37,180
我在新泽西州贝尔实验室附近长大，

2135
01:33:37,180 --> 01:33:39,820
这就是我为 Plan 9 做了一些工作，

2136
01:33:39,820 --> 01:33:40,930
在高中和大学里。

2137
01:33:42,550 --> 01:33:44,230
所以我大概知道，

2138
01:33:44,230 --> 01:33:45,430
我会去读研究生，

2139
01:33:45,430 --> 01:33:47,500
然后我的计划是回到贝尔实验室，

2140
01:33:47,500 --> 01:33:49,690
但当我还在读研究生的时候，它有点崩溃了，

2141
01:33:50,200 --> 01:33:52,900
随着互联网泡沫和互联网崩盘，

2142
01:33:53,290 --> 01:33:58,570
Google 当时在[]博士，

2143
01:33:58,570 --> 01:34:00,190
系统博士，

2144
01:34:00,680 --> 01:34:02,600
做一些非常有趣的事情，

2145
01:34:02,600 --> 01:34:03,920
我是说，你可能，

2146
01:34:03,950 --> 01:34:05,690
我不知道，我没看过今年的教学大纲，

2147
01:34:05,690 --> 01:34:06,560
但是那些东西，

2148
01:34:06,560 --> 01:34:10,790
比如 Spanner Bigtable Chubby 等东西，

2149
01:34:10,790 --> 01:34:12,440
他们有一大堆

2150
01:34:12,440 --> 01:34:14,930
好的分布式系统在运行。

2151
01:34:15,460 --> 01:34:18,640
所以，能够参加这个也是一种幸运。

2152
01:34:20,660 --> 01:34:22,580
在我毕业的时候，

2153
01:34:22,580 --> 01:34:24,800
我还查看了工业研究实验室，

2154
01:34:24,800 --> 01:34:27,020
比如微软的研究和类似的地方，

2155
01:34:27,350 --> 01:34:31,610
所以那里肯定有研究东西的机会，

2156
01:34:31,610 --> 01:34:33,740
但不是在学术界，如果这是你想要的，

2157
01:34:34,370 --> 01:34:36,200
现在更难找到了，

2158
01:34:36,230 --> 01:34:37,430
我的意思是，大多数地方，

2159
01:34:37,430 --> 01:34:40,670
比如微软的研究，也在几年后崩溃了。

2160
01:34:41,200 --> 01:34:45,130
但是，这仍然是一种选择，

2161
01:34:45,310 --> 01:34:48,580
这是一条略有不同的道路，

2162
01:34:48,880 --> 01:34:50,110
你最终，

2163
01:34:50,140 --> 01:34:52,000
我从学术界看到的不同之处在于，

2164
01:34:52,000 --> 01:34:54,400
你最终更关心的是

2165
01:34:54,790 --> 01:34:56,740
让事情百分之百地运转起来，

2166
01:34:56,740 --> 01:34:58,630
并支持它们十年或更长时间，

2167
01:34:58,810 --> 01:35:00,400
当你完成你的论文，

2168
01:35:00,400 --> 01:35:02,020
你可以把它放在一边，

2169
01:35:02,020 --> 01:35:04,390
在某种程度上，这真的很好。

2170
01:35:05,890 --> 01:35:08,080
这对我是奇怪的，

2171
01:35:08,080 --> 01:35:12,010
编辑我之前写的源文件，

2172
01:35:12,100 --> 01:35:14,800
在某些情况下，是在 20 年前，

2173
01:35:15,010 --> 01:35:16,990
因为我用了很多我已经写好的代码，

2174
01:35:16,990 --> 01:35:18,700
当我们开始的时候。

2175
01:35:19,190 --> 01:35:20,810
这想起来很奇怪，

2176
01:35:20,810 --> 01:35:23,630
我让这个项目运行了 20 年。

2177
01:35:26,430 --> 01:35:26,820
谢谢。

