1
00:00:00,000 --> 00:00:03,420
Good afternoon, good evening, good night, wherever you are.

2
00:00:03,870 --> 00:00:06,450
So today I want to talk about FaRM,

3
00:00:06,570 --> 00:00:09,150
this is a paper from 2015,

4
00:00:09,150 --> 00:00:10,890
so what a little bit more of a recent paper,

5
00:00:11,250 --> 00:00:12,690
and it's really a research paper,

6
00:00:12,720 --> 00:00:15,210
and the topic of the research paper is

7
00:00:15,210 --> 00:00:18,330
trying to explore some ideas and technologies

8
00:00:18,330 --> 00:00:20,430
to get high performance transactions,

9
00:00:31,700 --> 00:00:33,410
and with high performance,

10
00:00:33,410 --> 00:00:37,520
just to make sure we're on the, roughly what we're looking for,

11
00:00:37,700 --> 00:00:39,590
high performance from that means,

12
00:00:39,590 --> 00:00:44,730
they're getting 140 million transactions per second,

13
00:00:44,790 --> 00:00:52,060
on this you know TATP benchmark, using 90 machines,

14
00:00:58,620 --> 00:01:01,410
and so you know whether this number is impressive,

15
00:01:01,410 --> 00:01:03,480
of course you know depends on the numbers you know,

16
00:01:03,480 --> 00:01:05,010
and so does anybody remember,

17
00:01:05,010 --> 00:01:07,050
how many transactions per second Spanner could do?

18
00:01:16,220 --> 00:01:16,970
Anybody?

19
00:01:27,130 --> 00:01:29,200
So if we remember the paper,

20
00:01:29,200 --> 00:01:31,690
you know certain transaction there you know took about

21
00:01:31,960 --> 00:01:32,890
depending on what you did,

22
00:01:32,890 --> 00:01:35,290
you know 10 to 100 milliseconds,

23
00:01:35,290 --> 00:01:41,800
so you know 10 to 100 transactions per second.

24
00:01:41,800 --> 00:01:46,210
So, the number transactions that FaRM can do is

25
00:01:46,210 --> 00:01:48,490
in a completely different order of magnitude.

26
00:01:49,050 --> 00:01:52,200
And that partly is because they're completely different systems,

27
00:01:52,200 --> 00:01:56,550
Spanner tries to do synchronous [] replication across the world,

28
00:01:56,820 --> 00:02:00,240
and FaRM actually everything runs in a single data center.

29
00:02:04,560 --> 00:02:09,990
And so the applications that been targeted by FaRM and Spanner a quite different,

30
00:02:10,080 --> 00:02:16,500
Spanner targeting applications that cannot tolerate the crash with a data center,

31
00:02:16,650 --> 00:02:20,730
like you know F1 AD serving database,

32
00:02:20,850 --> 00:02:23,490
while Spanner is much, very well,

33
00:02:23,520 --> 00:02:25,500
FaRM much more targeting sort of

34
00:02:25,500 --> 00:02:27,930
like you're you're using MySQL

35
00:02:27,930 --> 00:02:32,310
or some other sort of database application database system,

36
00:02:32,460 --> 00:02:36,090
and you want much more high performance transactions,

37
00:02:36,300 --> 00:02:40,710
then you know FaRM sort of a possible design or a possible alternative.

38
00:02:41,950 --> 00:02:44,590
They do provide strict serializability,

39
00:02:48,370 --> 00:02:56,160
which is similar to the external consistency that Spanner offered.

40
00:02:56,990 --> 00:02:58,880
And so the whole goal is to get high performance,

41
00:02:58,880 --> 00:03:02,720
so there are numerous ideas you know they're going to achieving high performance.

42
00:03:02,930 --> 00:03:04,940
One, they they shard,

43
00:03:05,470 --> 00:03:09,600
that's probably the main you know standard technique that they used,

44
00:03:09,600 --> 00:03:11,130
that was going to give us the performance,

45
00:03:11,130 --> 00:03:15,450
for example if you know different records are on a different shards,

46
00:03:15,450 --> 00:03:18,300
and transactions you know touch the different shard,

47
00:03:18,300 --> 00:03:20,940
then these transaction can just run in parallel,

48
00:03:21,030 --> 00:03:23,730
and so, if you have 90 machines,

49
00:03:23,730 --> 00:03:27,930
you know get 90 times you know the performance of a single machine.

50
00:03:28,520 --> 00:03:30,380
So sharding are sort of starting point,

51
00:03:30,890 --> 00:03:33,110
but then they go much further,

52
00:03:33,350 --> 00:03:37,430
so they use non-volatile DRAM,

53
00:03:39,560 --> 00:03:45,620
and this is to avoid to the bottleneck of having to write to stable storage devices,

54
00:03:45,620 --> 00:03:47,030
so in their design,

55
00:03:47,030 --> 00:03:51,560
you don't actually have to write in the [critical path] to an SSD or a disk,

56
00:03:51,650 --> 00:03:55,760
and so they avoid the whole cost of doing so,

57
00:03:55,880 --> 00:03:57,290
which can be quite expensive,

58
00:03:57,320 --> 00:04:02,500
and that's for example you think about your implementations of Raft,

59
00:04:02,500 --> 00:04:07,870
you know they they store you know or make data persistent,

60
00:04:07,870 --> 00:04:11,410
and typically you know making something persistent on a stable storage device,

61
00:04:11,410 --> 00:04:15,940
you know the order of hundreds of milliseconds, or hundreds of,

62
00:04:16,510 --> 00:04:21,250
a few milliseconds you know to tens of milliseconds to ten milliseconds,

63
00:04:21,250 --> 00:04:22,900
if you're actually using a magnetic disk,

64
00:04:23,460 --> 00:04:26,400
an SSD you know sort of, sort of millisecond,

65
00:04:27,120 --> 00:04:29,880
and so given the time for they operate,

66
00:04:29,880 --> 00:04:31,560
you know that way just too costly,

67
00:04:31,590 --> 00:04:34,380
so they use some people they call non-volatile DRAM,

68
00:04:34,380 --> 00:04:35,550
this we'll talk about in a second,

69
00:04:36,420 --> 00:04:41,730
and then so that gets rid of storage access cost.

70
00:04:41,940 --> 00:04:45,720
And so the next two bottleneck they address is

71
00:04:45,750 --> 00:04:48,780
CPU bottlenecks and network bottlenecks,

72
00:04:49,200 --> 00:04:52,740
and for that, to use technical called kernel bypass,

73
00:04:57,010 --> 00:05:01,360
which basically avoids the operating system for, to talk to the network card,

74
00:05:01,600 --> 00:05:06,610
and then they use network cards that have a special feature called RDMA,

75
00:05:10,530 --> 00:05:14,730
that allows the card to read and write memory from remote server

76
00:05:14,730 --> 00:05:17,820
without actually having to interrupt you know that remote server,

77
00:05:18,420 --> 00:05:20,400
and so this gives us

78
00:05:20,400 --> 00:05:26,920
really low latency network access to remote server, or to remote memory,

79
00:05:26,950 --> 00:05:29,260
this is partially where the name FaRM comes from,

80
00:05:29,260 --> 00:05:33,250
you know the R stands for remote and M for memory and Fa for fast.

81
00:05:34,810 --> 00:05:39,370
So, those are the, those are the technologies they use,

82
00:05:39,430 --> 00:05:43,180
and then you know to be able to really exploit these technologies

83
00:05:43,360 --> 00:05:45,040
drives them to a design,

84
00:05:45,040 --> 00:05:46,810
that uses optimistic concurrency control

85
00:05:47,220 --> 00:05:51,510
or OCC, the short version of this, so optimistic,

86
00:05:56,230 --> 00:05:59,380
and in contrast with many of the designs that we've seen so far,

87
00:05:59,380 --> 00:06:04,030
where they use what was typically called pessimistic concurrency control scheme,

88
00:06:04,030 --> 00:06:07,630
and pessimistic control scheme basically acquire locks

89
00:06:07,720 --> 00:06:13,030
on you know the objects are being touched by the transaction,

90
00:06:13,270 --> 00:06:16,570
and so when they get to commit time,

91
00:06:16,720 --> 00:06:19,510
they own all the locks for all the relevant objects

92
00:06:19,510 --> 00:06:21,430
and just go ahead and commit,

93
00:06:21,580 --> 00:06:24,520
while with optimistic concurrency control,

94
00:06:24,520 --> 00:06:26,650
you don't actually acquire locks,

95
00:06:26,650 --> 00:06:28,030
particularly in FaRM,

96
00:06:28,030 --> 00:06:31,840
you don't require locks on the read transaction,

97
00:06:32,720 --> 00:06:35,300
and when you do go commit,

98
00:06:35,300 --> 00:06:36,410
you actually have to validate,

99
00:06:36,410 --> 00:06:40,340
that you read, you know read the most recent objects

100
00:06:40,550 --> 00:06:42,560
and if so, you can go commit,

101
00:06:42,560 --> 00:06:44,450
and if you're not, you know you have to abort

102
00:06:44,450 --> 00:06:45,680
and maybe try again.

103
00:06:46,530 --> 00:06:49,500
And the reason they use optimization concurrence control,

104
00:06:49,500 --> 00:06:50,400
as we'll see in a second,

105
00:06:50,400 --> 00:06:53,580
is really driven by the fact that they want to use RDMA.

106
00:06:56,820 --> 00:06:59,610
Okay, so then the final component to this is certain overview,

107
00:06:59,610 --> 00:07:01,140
this is really a research prototype,

108
00:07:05,250 --> 00:07:10,110
so unlike Spanner, you know which is a deployed system,

109
00:07:10,170 --> 00:07:14,010
you know it's been active use,

110
00:07:14,040 --> 00:07:17,850
FaRM is really a product of the research [] of Microsoft,

111
00:07:18,120 --> 00:07:21,300
Microsoft research trying to explore new ideas,

112
00:07:21,480 --> 00:07:25,620
to see how, to see what can achieve higher

113
00:07:25,740 --> 00:07:27,660
or really high performance transaction systems,

114
00:07:27,660 --> 00:07:29,670
and this is just a very active research,

115
00:07:29,700 --> 00:07:34,050
people would just love to have the power of transactions,

116
00:07:34,230 --> 00:07:36,720
and but also the performance.

117
00:07:40,430 --> 00:07:42,440
Okay, so that's sort of short introduction,

118
00:07:42,440 --> 00:07:43,580
any questions so far?

119
00:07:49,860 --> 00:08:00,020
Okay, let's talk a little bit about the setup for FaRM.

120
00:08:00,510 --> 00:08:11,710
And so there's basically 90 machines, 90 of these guys,

121
00:08:11,710 --> 00:08:15,310
they're connected by high-speed data center network,

122
00:08:15,340 --> 00:08:17,290
and see a particular one,

123
00:08:17,590 --> 00:08:20,410
I'm just going to draw that as a single line,

124
00:08:20,410 --> 00:08:22,630
of course, it's a switch network internally,

125
00:08:23,020 --> 00:08:27,280
and basically shard,

126
00:08:27,430 --> 00:08:31,480
the data is sharded across these different machines,

127
00:08:31,690 --> 00:08:36,970
and the level of sharding happens, some else called region,

128
00:08:37,800 --> 00:08:42,380
so region is 2 gigabyte,

129
00:08:44,730 --> 00:08:46,290
and you know those regions are sharded

130
00:08:46,290 --> 00:08:49,790
across different networks and the different machines,

131
00:08:49,790 --> 00:08:51,620
the region live in memory,

132
00:08:52,010 --> 00:08:53,390
so this is just DRAM,

133
00:08:56,490 --> 00:08:59,730
and not in for example on the disk,

134
00:08:59,760 --> 00:09:04,920
so basically, the total dataset of your database

135
00:09:04,920 --> 00:09:09,240
actually has to fit in the joint DRAMs of the machine that you're using,

136
00:09:09,240 --> 00:09:11,580
so if your dataset is larger than your current set of machines,

137
00:09:11,580 --> 00:09:13,620
you have to buy more machines, that get more DRAM,

138
00:09:13,620 --> 00:09:14,550
so they can actually fit.

139
00:09:16,150 --> 00:09:19,780
And again, the reason why you know they want to use DRAM is,

140
00:09:19,780 --> 00:09:26,100
because they want [] bottleneck by the performance of storage devices,

141
00:09:26,280 --> 00:09:29,880
and of course you know machine can fail,

142
00:09:29,880 --> 00:09:32,730
and if a machine fails, it uses loses DRAM,

143
00:09:32,850 --> 00:09:35,040
and so therefore they use replication,

144
00:09:35,250 --> 00:09:38,460
and so they replicate regions across multiple machines,

145
00:09:38,790 --> 00:09:41,910
one machine is primary for a region,

146
00:09:42,210 --> 00:09:46,050
and that makes machine region might be replicated on another machine,

147
00:09:46,230 --> 00:09:47,160
which is in the backup,

148
00:09:47,160 --> 00:09:52,690
so use primary backup for replication,

149
00:09:52,900 --> 00:09:57,000
and so this region 1, you know region 2,

150
00:09:57,000 --> 00:10:00,390
you know the backup might be on the same machine as the primary

151
00:10:00,390 --> 00:10:02,730
for backup for region 2,

152
00:10:03,090 --> 00:10:05,700
and here we have the primary region 2.

153
00:10:06,710 --> 00:10:08,900
So this deals you know,

154
00:10:08,900 --> 00:10:11,390
so one machine has a kernel panic

155
00:10:11,390 --> 00:10:13,160
or some device goes that

156
00:10:13,160 --> 00:10:16,250
or you know just crashes for some other reason,

157
00:10:16,460 --> 00:10:19,130
then there's a second machine,

158
00:10:19,130 --> 00:10:22,220
that actually has a copy of the data and just proceed from there.

159
00:10:23,120 --> 00:10:26,450
Of course, then we need some way of keeping track of

160
00:10:26,450 --> 00:10:32,780
the mapping from regions to primaries and backups,

161
00:10:32,780 --> 00:10:35,780
and so they use a configuration manager,

162
00:10:36,790 --> 00:10:38,680
a CM that sits on the side,

163
00:10:39,370 --> 00:10:44,140
and CM itself actually is coupled with a system that we've seen before zookeeper,

164
00:10:45,780 --> 00:10:50,610
and really the zookeeper and the configuration management that keep track of

165
00:10:50,610 --> 00:11:02,110
the mapping you know from region number to the primary and whatever the backups,

166
00:11:04,530 --> 00:11:05,610
for every region.

167
00:11:06,390 --> 00:11:08,880
Okay?

168
00:11:09,690 --> 00:11:13,440
Now there's one a serious problem of course here,

169
00:11:13,440 --> 00:11:14,430
I I talked about,

170
00:11:14,430 --> 00:11:16,950
like while primary with primary backup replication way,

171
00:11:16,950 --> 00:11:18,060
so we have fault,

172
00:11:18,180 --> 00:11:20,190
then you know one machine can fail,

173
00:11:20,190 --> 00:11:21,330
now the machine can take over,

174
00:11:21,570 --> 00:11:24,300
except the one sort of tricky case,

175
00:11:24,300 --> 00:11:27,240
that this scheme can't handle so far,

176
00:11:27,390 --> 00:11:29,040
is when there's a correlated failure,

177
00:11:29,040 --> 00:11:31,290
for example there's a power failure of the data center,

178
00:11:31,590 --> 00:11:33,510
and all machines should now go down,

179
00:11:34,190 --> 00:11:35,690
and to handle that case,

180
00:11:35,840 --> 00:11:40,610
basically the DRAM has it sits on a UPS,

181
00:11:40,610 --> 00:11:43,940
where every machine sits on an uninterruptible power supply,

182
00:11:44,360 --> 00:11:47,600
so I'm going to draw these a big battery that sits on the side,

183
00:11:54,520 --> 00:11:58,930
and the battery basically or UPS you know provides enough energy,

184
00:11:58,930 --> 00:12:02,260
that if there's a global power failure,

185
00:12:02,500 --> 00:12:04,900
the machine keep running for a little time,

186
00:12:04,900 --> 00:12:06,220
and ended up a little time,

187
00:12:06,490 --> 00:12:08,410
the machine can actually store,

188
00:12:08,680 --> 00:12:12,790
the FaRM would like to store the data on on SSDs

189
00:12:12,790 --> 00:12:16,570
or basically just flush the contents of its memory,

190
00:12:16,600 --> 00:12:23,560
all the regions, all the transaction state, all logs for the transactions,

191
00:12:23,770 --> 00:12:25,600
actually flushes it to SSD,

192
00:12:25,630 --> 00:12:29,590
so if there's a complete power failure of the whole data center,

193
00:12:29,680 --> 00:12:31,990
the data center at some point will come back up,

194
00:12:32,080 --> 00:12:37,690
and they can load you know the memory contents of the machines from the SSD,

195
00:12:37,840 --> 00:12:39,670
and you know start basically running again,

196
00:12:40,560 --> 00:12:44,700
and so this is basically the only place where the SSDs are being used,

197
00:12:45,000 --> 00:12:50,490
to deal with correlated failure many machines in the data center.

198
00:12:53,750 --> 00:12:55,220
Any questions so far?

199
00:13:03,180 --> 00:13:05,790
Okay, let me say a little bit about the software,

200
00:13:05,880 --> 00:13:07,560
so in the regions,

201
00:13:07,650 --> 00:13:09,150
so we have a region here,

202
00:13:09,740 --> 00:13:12,230
in the region objects live,

203
00:13:13,390 --> 00:13:17,650
so you can just think about an array, region as an array of bytes,

204
00:13:17,650 --> 00:13:18,880
you know 2 gigabytes,

205
00:13:19,240 --> 00:13:21,910
and in you know array of bytes, objects live,

206
00:13:22,800 --> 00:13:30,390
and objects have a unique identifier oid,

207
00:13:31,550 --> 00:13:34,100
and the oid of an object is nothing else,

208
00:13:34,100 --> 00:13:41,660
it's region number, [] the region number and then the address you know within that region,

209
00:13:48,860 --> 00:13:52,340
associated with every object,

210
00:13:52,340 --> 00:13:55,700
there's a little bit of metadata for that particular object,

211
00:13:56,090 --> 00:14:01,850
and in particular for object header contains a 64 bit number,

212
00:14:05,870 --> 00:14:15,070
and the number consists is basically a version number in the bottom 63

213
00:14:15,070 --> 00:14:20,350
and then a lock bit, as we'll see in the top bit, in the high order bit,

214
00:14:21,330 --> 00:14:25,500
so every object has this you know 64 bit number,

215
00:14:25,500 --> 00:14:27,600
refer to as a version number,

216
00:14:27,840 --> 00:14:32,220
and then we'll see plays an important role in the optimistic concurrency control.

217
00:14:33,720 --> 00:14:40,460
The way applications use you know this system,

218
00:14:40,460 --> 00:14:42,050
let me say a little bit about that,

219
00:14:42,050 --> 00:14:44,330
so what's the application programmer interface.

220
00:14:53,060 --> 00:14:54,440
So the API is

221
00:14:54,440 --> 00:14:55,910
you know you start transaction,

222
00:15:00,080 --> 00:15:01,760
and you read some objects,

223
00:15:05,490 --> 00:15:07,560
so there is read call,

224
00:15:07,560 --> 00:15:10,590
and read call takes oid as an argument,

225
00:15:11,580 --> 00:15:16,360
the application then can manipulate,

226
00:15:16,360 --> 00:15:19,690
you know change the fields in the, in the object,

227
00:15:19,690 --> 00:15:21,100
whatever add 1 to it,

228
00:15:22,270 --> 00:15:28,680
and then at some point write the object,

229
00:15:31,660 --> 00:15:34,570
write update the object itself using the write call

230
00:15:34,570 --> 00:15:38,200
and then you know commit it using txcommit.

231
00:15:41,310 --> 00:15:43,890
And it might also be the case that,

232
00:15:43,890 --> 00:15:47,130
the transaction needs to abort,

233
00:15:47,130 --> 00:15:48,780
because of the optimistic concurrency control,

234
00:15:48,780 --> 00:15:52,920
in that case, the application will typically just retry the transaction,

235
00:15:53,830 --> 00:15:58,360
and so in the transaction, the way it shows transaction here,

236
00:15:58,360 --> 00:15:59,890
there's only one object manipulated,

237
00:15:59,980 --> 00:16:02,680
yeah, but it seems actually manipulate many, many objects,

238
00:16:02,680 --> 00:16:05,440
those objects could be on a different regions,

239
00:16:05,800 --> 00:16:09,010
and and so you know they have to have some plans,

240
00:16:09,010 --> 00:16:09,670
we'll see,

241
00:16:09,700 --> 00:16:14,650
we're running some two-phase commit like protocol to do atomic operations

242
00:16:14,650 --> 00:16:18,310
across objects living in different regions.

243
00:16:20,210 --> 00:16:24,760
Any sort of questions about the API and setup?

244
00:16:29,910 --> 00:16:36,480
Sorry, the address oid, it is the address in the machine itself?

245
00:16:36,870 --> 00:16:40,860
Yeah, which is the offset within that region.

246
00:16:46,300 --> 00:16:46,990
Okay?

247
00:16:48,380 --> 00:16:49,700
The region could move, correct,

248
00:16:49,790 --> 00:16:54,680
you know that the replicated or the configuration manager [] the mapping,

249
00:16:55,040 --> 00:16:58,340
the actual address where the object might change,

250
00:16:58,580 --> 00:17:00,740
so this is a region number plus an offset,

251
00:17:02,130 --> 00:17:04,230
a little bit there here, I should set offset.

252
00:17:09,920 --> 00:17:12,770
Sorry, I have another question that,

253
00:17:13,010 --> 00:17:18,410
what was the design choice or design thinking behind making a global address space?

254
00:17:19,280 --> 00:17:23,210
The to have everything in the DRAM,

255
00:17:26,480 --> 00:17:29,330
not sure that answers your question, but,

256
00:17:32,120 --> 00:17:36,200
the whole goal of them is to actually run the transactions on an in-memory database,

257
00:17:36,230 --> 00:17:38,390
you know this whole trend of set of databases,

258
00:17:38,390 --> 00:17:41,480
where all the data is always in memory, is called in-memory databases,

259
00:17:41,990 --> 00:17:44,930
driven by the fact that DRAM is [reasonably] cheap,

260
00:17:45,230 --> 00:17:48,230
and so that would allow you to basically run transactions

261
00:17:48,230 --> 00:17:50,750
without actually having to go to persistent storage,

262
00:17:50,750 --> 00:17:57,120
and they're basically jumping on that [] in-memory databases.

263
00:17:58,310 --> 00:18:02,150
I see, and that requires like a global address space they all share.

264
00:18:02,680 --> 00:18:05,020
The address space is per machine, right,

265
00:18:05,020 --> 00:18:09,130
every machine has its own address space from 0 to whatever,

266
00:18:09,520 --> 00:18:18,970
and the the the the objects are really the global numbers or global names.

267
00:18:22,070 --> 00:18:22,820
Thank you.

268
00:18:26,450 --> 00:18:28,010
Okay, good.

269
00:18:28,340 --> 00:18:30,230
So let's talk so far,

270
00:18:30,350 --> 00:18:33,170
I think we basically sort of established

271
00:18:33,170 --> 00:18:36,740
you know they've gotten the stable storage devices out of the way,

272
00:18:37,160 --> 00:18:42,110
and so there's no bottleneck for reading writing storage devices,

273
00:18:42,110 --> 00:18:43,700
because they're basically not using them,

274
00:18:43,970 --> 00:18:47,990
other than this is one exceptional case when the power fails.

275
00:18:48,690 --> 00:18:51,690
And so the next set of things they focus on is

276
00:18:51,690 --> 00:18:56,070
trying to reduce CPU utilization

277
00:18:56,070 --> 00:18:57,870
or try to be very efficient with the CPU

278
00:18:57,900 --> 00:18:59,430
and be very efficient at the network.

279
00:19:00,830 --> 00:19:04,310
And there's two key ideas here,

280
00:19:04,310 --> 00:19:05,960
that are pretty well known.

281
00:19:06,380 --> 00:19:08,510
So the first one is kernel bypass,

282
00:19:20,460 --> 00:19:24,900
and the story that is reasonable simple,

283
00:19:25,020 --> 00:19:27,900
so we have FaRM that runs as a user level process,

284
00:19:31,880 --> 00:19:34,880
on top of Windows, the Windows operating system,

285
00:19:34,880 --> 00:19:36,350
so here's the operating system,

286
00:19:37,040 --> 00:19:38,390
let's move a little bit on the side,

287
00:19:38,420 --> 00:19:39,860
so here's the operating system,

288
00:19:40,340 --> 00:19:41,510
and the operating system of course

289
00:19:41,510 --> 00:19:45,560
and there are all the features for scheduling processes you know virtual memory,

290
00:19:45,770 --> 00:19:47,780
standard operating system,

291
00:19:48,050 --> 00:19:52,190
and it also have drivers for hardware devices,

292
00:19:52,370 --> 00:19:56,540
and like one of the hardware devices is a network interface card,

293
00:20:00,560 --> 00:20:04,550
and you know typically you know the OS driver inside of it,

294
00:20:05,140 --> 00:20:09,940
that programs the network interface card,

295
00:20:09,940 --> 00:20:14,410
so read and write registers on the network interface card to basically send a packet

296
00:20:14,770 --> 00:20:17,920
or to reconfigure the network interface card, etc, etc.

297
00:20:18,870 --> 00:20:25,080
So the typical way you know that you know applications interact with network card is,

298
00:20:25,080 --> 00:20:27,960
they make system calls to the kernel,

299
00:20:27,960 --> 00:20:30,840
and ask the kernel to basically send a packet,

300
00:20:31,750 --> 00:20:34,810
and that you know involves the operating system,

301
00:20:34,810 --> 00:20:37,090
involves TCP stack, the network stack,

302
00:20:37,270 --> 00:20:39,580
and it tends to be quite expensive,

303
00:20:40,120 --> 00:20:44,740
and so they want to avoid this this overhead,

304
00:20:44,740 --> 00:20:47,680
you know going entering the kernel running TCP, etc,

305
00:20:47,920 --> 00:20:51,340
and the way they do that is something that is technique called kernel bypass,

306
00:20:51,340 --> 00:20:56,770
and network card is sort of collaboration between the network card and the operating system,

307
00:20:57,100 --> 00:20:58,930
and basically what it does is,

308
00:20:58,930 --> 00:21:01,150
that the queues that the network interface has,

309
00:21:01,570 --> 00:21:04,810
here're some queues, for example send queue and receive queue,

310
00:21:05,170 --> 00:21:10,930
those queues are basically directly mapped or into the address space of the application,

311
00:21:11,410 --> 00:21:14,230
so the application can ask you know operating system,

312
00:21:14,230 --> 00:21:18,460
please you know take some queues that the NIC has

313
00:21:18,550 --> 00:21:20,830
and map them into the address space of the application,

314
00:21:21,280 --> 00:21:23,410
so you can just think about this sort of queue

315
00:21:23,410 --> 00:21:28,270
basically is directly accessible from the user level application,

316
00:21:28,270 --> 00:21:31,150
so the user level application, you know can basically now

317
00:21:31,150 --> 00:21:35,050
read and write you know commands or packets into the network interface card,

318
00:21:35,110 --> 00:21:39,100
without actually having to involve the operating system at all.

319
00:21:39,310 --> 00:21:41,740
So this cuts the whole operating system out of the picture

320
00:21:41,920 --> 00:21:45,310
and improves you know performance considerably.

321
00:21:46,180 --> 00:21:47,560
In the case of FaRM,

322
00:21:47,710 --> 00:21:49,390
they also don't want to use interrupts,

323
00:21:49,420 --> 00:21:51,700
so one way of delivering a packet, correct is

324
00:21:51,700 --> 00:21:52,390
the packet comes in,

325
00:21:52,390 --> 00:21:55,510
the network interface card delivers an interrupt to the operating system,

326
00:21:55,510 --> 00:22:00,520
the operating system then alerts the application that the packet has arrived,

327
00:22:00,760 --> 00:22:03,550
and [] trying to avoid that cost,

328
00:22:03,550 --> 00:22:04,870
and the way they avoid that cost is

329
00:22:04,870 --> 00:22:08,730
basically they poll the receive queue.

330
00:22:09,840 --> 00:22:12,150
So there's basically an user level thread,

331
00:22:12,180 --> 00:22:15,690
you know that sits in the FaRM application,

332
00:22:15,900 --> 00:22:20,100
and basically does nothing else than sort of reading the receive queue,

333
00:22:20,100 --> 00:22:21,780
to see if actually packet is available.

334
00:22:23,520 --> 00:22:26,340
And so that requires you know you need a [],

335
00:22:26,340 --> 00:22:28,530
so that avoids the use of interrupts,

336
00:22:28,800 --> 00:22:33,600
and you know and the cost of basically having a polling thread,

337
00:22:33,600 --> 00:22:36,660
that's you know sits there doing nothing else than polling,

338
00:22:37,410 --> 00:22:41,310
and FaRM turns out this thread actually switches back and forth

339
00:22:41,310 --> 00:22:45,270
between running some application code and polling the NIC.

340
00:22:46,640 --> 00:22:48,440
So that's sort of kernel bypass,

341
00:22:48,890 --> 00:22:51,200
and this is a reasonable standard,

342
00:22:51,200 --> 00:22:59,660
some people may, some of you maybe know familiar with DPDK,

343
00:23:01,570 --> 00:23:04,030
which is data plane development kit,

344
00:23:04,420 --> 00:23:09,940
which a development kit to basically leverage you know kernel bypass.

345
00:23:10,710 --> 00:23:12,030
It's a reasonable standard thing,

346
00:23:12,950 --> 00:23:15,830
is available on many operating systems.

347
00:23:16,720 --> 00:23:20,200
So then the next you know sort of piece of technology they use,

348
00:23:20,200 --> 00:23:24,520
is a little bit but also well known as wide and standardized,

349
00:23:24,520 --> 00:23:26,860
many network cards supported

350
00:23:26,890 --> 00:23:29,950
or more high-end network card supported,

351
00:23:30,250 --> 00:23:31,990
and that's something was called RDMA,

352
00:23:36,210 --> 00:23:42,260
which stands for remote, remote direct memory access.

353
00:23:51,030 --> 00:23:51,960
The basic idea is that,

354
00:23:51,990 --> 00:23:57,780
you know this requires NICs that actually understand RDMA,

355
00:23:57,930 --> 00:24:00,300
and so here we have cable,

356
00:24:00,330 --> 00:24:02,220
here we have NIC on the other side,

357
00:24:02,790 --> 00:24:05,010
the operating system may be sitting on top of it,

358
00:24:05,550 --> 00:24:07,290
you know where we have FaRM,

359
00:24:12,850 --> 00:24:19,360
and basically you know the application on the side, on the center side,

360
00:24:19,600 --> 00:24:24,010
you know can basically put particular packet into the send queue,

361
00:24:24,280 --> 00:24:28,150
and you know send RDMA packet,

362
00:24:28,540 --> 00:24:32,260
and so basically somewhere is a bit the header of the packet,

363
00:24:32,260 --> 00:24:34,150
saying, like hey I'm an RDMA packet,

364
00:24:34,780 --> 00:24:39,130
and then the NIC will send it over to the NIC, the destination NIC,

365
00:24:39,400 --> 00:24:43,510
the destination NIC sees that this is a special packet, an RDMA packet,

366
00:24:43,870 --> 00:24:47,590
and looks at the instruction that goes along with the RDMA packet,

367
00:24:47,920 --> 00:24:49,030
so the instruction might be

368
00:24:49,240 --> 00:24:52,630
read a particular memory location or write a particular memory location,

369
00:24:53,170 --> 00:24:54,610
so here so for example,

370
00:24:54,610 --> 00:24:56,110
let's say it's a read operation,

371
00:24:59,390 --> 00:25:02,300
and the read operation will be safely takes an address,

372
00:25:03,670 --> 00:25:05,950
and it allows the NIC

373
00:25:06,070 --> 00:25:10,930
to basically read the address straight out of memory, out of RAM,

374
00:25:11,110 --> 00:25:14,140
so for example let's say you know here we have our region,

375
00:25:15,690 --> 00:25:17,040
you know with objects in it,

376
00:25:18,120 --> 00:25:25,320
and the sending FaRM application can just say,

377
00:25:25,380 --> 00:25:30,180
okay, I wanna read you know this particular address,

378
00:25:30,180 --> 00:25:33,690
you know which corresponds to address with this object o,

379
00:25:34,020 --> 00:25:38,190
and will send an RDMA packet to the NIC on the other side,

380
00:25:39,830 --> 00:25:41,750
the NIC is that there is an RDMA packet,

381
00:25:42,170 --> 00:25:45,920
and basically read you know from memory,

382
00:25:46,100 --> 00:25:48,650
the value stored at that particular location,

383
00:25:48,890 --> 00:25:53,210
and sends them straight back you know to the source.

384
00:25:54,260 --> 00:25:58,160
And what is cool about this technology is that,

385
00:25:58,160 --> 00:25:59,180
the NIC can do this

386
00:25:59,240 --> 00:26:04,010
without actually interrupting or interfering with the server at all,

387
00:26:04,490 --> 00:26:06,320
it doesn't have to generate an interrupt,

388
00:26:06,320 --> 00:26:11,120
doesn't have to run any code on the the processors,

389
00:26:11,120 --> 00:26:13,220
that run the operating system, the application,

390
00:26:13,430 --> 00:26:18,290
instead you know NICs has firmware that runs executes those instructions,

391
00:26:18,470 --> 00:26:22,790
and loads you know the value stored those memory,

392
00:26:22,790 --> 00:26:26,270
request memory addresses straight into a response packet

393
00:26:26,270 --> 00:26:27,680
and sends response packet back,

394
00:26:27,920 --> 00:26:29,840
and then of course on the receiving side,

395
00:26:30,200 --> 00:26:32,450
you know that will show up in the receive queue,

396
00:26:32,600 --> 00:26:34,460
and so far, you know at some point,

397
00:26:34,460 --> 00:26:38,750
you know hold the receive queue and see actually the result of that RDMA.

398
00:26:41,820 --> 00:26:45,120
This, this particular version that I am describing here,

399
00:26:45,120 --> 00:26:49,470
the paper refers to as one-sided RDMA,

400
00:26:53,280 --> 00:26:59,100
and that's typically refers to the paper to read operations.

401
00:27:02,500 --> 00:27:03,190
Professor.

402
00:27:03,700 --> 00:27:04,420
Yeah, go ahead.

403
00:27:04,420 --> 00:27:05,290
Sorry professor,

404
00:27:05,320 --> 00:27:07,210
can can you repeat,

405
00:27:07,210 --> 00:27:13,810
how how the polling of the like NIC queues works on the on the client

406
00:27:13,870 --> 00:27:15,460
or yeah like.

407
00:27:16,380 --> 00:27:18,000
There's almost nothing to it,

408
00:27:18,060 --> 00:27:25,080
the the client just has a thread that reads a particular memory location,

409
00:27:25,500 --> 00:27:28,710
and which indicates whether a packet has arrived or not,

410
00:27:29,300 --> 00:27:34,100
and when the NIC receives packets, sticks in the receive queue,

411
00:27:34,340 --> 00:27:36,740
and as a side of setting in the receive queue,

412
00:27:36,740 --> 00:27:40,520
you know the flag bit you know turns into 1,

413
00:27:40,760 --> 00:27:43,520
and the application knows, oh yeah there's a packet there.

414
00:27:46,060 --> 00:27:50,200
Is it a specific thread that you know that polls or like?

415
00:27:50,380 --> 00:27:53,350
Yeah, they're in their system, they have specific threads,

416
00:27:53,350 --> 00:27:57,160
that actually are dedicated to polling the queues.

417
00:27:58,220 --> 00:27:59,910
Okay, thanks.

418
00:28:01,540 --> 00:28:02,770
Sorry, I'm also confused here,

419
00:28:02,770 --> 00:28:06,400
so does the NIC cooperate with this system or regularly doing a job,

420
00:28:06,520 --> 00:28:08,620
like as in any regular NIC.

421
00:28:09,500 --> 00:28:14,060
Okay, this is not you know whatever your standard NIC, right,

422
00:28:14,360 --> 00:28:20,570
this NIC that supports both kernel bypass and remote direct memory access RDMA,

423
00:28:21,230 --> 00:28:26,900
in the, typically for NIC to support kernel bypass,

424
00:28:26,900 --> 00:28:29,900
it means it has to have multiple receive and send queues,

425
00:28:30,140 --> 00:28:33,290
and it just gives a pair of send or receive queues to an application,

426
00:28:34,980 --> 00:28:35,970
and it cannot like,

427
00:28:35,970 --> 00:28:36,510
of course,

428
00:28:36,510 --> 00:28:40,860
you can't have a send receive queue for every process running on your machine,

429
00:28:41,130 --> 00:28:43,890
so typically they're like 16 of them, or 32 of them,

430
00:28:44,160 --> 00:28:47,160
and you know get some of them to particular OS,

431
00:28:47,160 --> 00:28:51,690
basically allow some applications to own basically send and receive queue.

432
00:28:52,880 --> 00:28:53,810
Thanks so much.

433
00:28:55,060 --> 00:28:59,170
It also means there's a specific support for RDMA and make it all work out,

434
00:29:00,050 --> 00:29:03,830
you know, so it requires a NIC that is a reasonable sophisticated,

435
00:29:03,830 --> 00:29:05,600
although it's a reasonable standard, these days.

436
00:29:07,070 --> 00:29:10,010
Okay, so that's one side of RDMA,

437
00:29:10,010 --> 00:29:13,610
they also use RDMA to do writes,

438
00:29:13,880 --> 00:29:16,040
and to actually implement RPC,

439
00:29:16,280 --> 00:29:23,470
and so, there's, they typically call this write RDMA in the paper,

440
00:29:24,520 --> 00:29:25,930
is basically the same thing,

441
00:29:27,970 --> 00:29:32,500
except the sender could put in the RDMA packet,

442
00:29:32,500 --> 00:29:34,390
saying like oh this is a write operation,

443
00:29:34,390 --> 00:29:38,020
and write you know the following bytes to a particular address,

444
00:29:38,290 --> 00:29:42,730
and the paper uses two places or two things,

445
00:29:42,730 --> 00:29:44,530
where writes are actually going to,

446
00:29:44,770 --> 00:29:48,580
[] written directly with RDMA,

447
00:29:48,700 --> 00:29:52,960
but there's two other data structures that are being written with write RDMAs,

448
00:29:52,990 --> 00:29:54,220
one is a log,

449
00:29:56,200 --> 00:29:58,600
you'll see the [rule] the log later,

450
00:30:00,440 --> 00:30:02,420
and this is a really [] transactions,

451
00:30:02,420 --> 00:30:06,440
so it has committed record, logging records, etc etc,

452
00:30:06,650 --> 00:30:12,080
and so if the source you know once append a log record to this particular log,

453
00:30:12,080 --> 00:30:14,480
I can just do write RDMA,

454
00:30:14,690 --> 00:30:18,050
and and then the receiving NIC will

455
00:30:18,050 --> 00:30:23,870
add you know the new entry in the log to the specified location.

456
00:30:24,970 --> 00:30:25,660
Okay?

457
00:30:26,680 --> 00:30:29,350
And so that means like the sender,

458
00:30:29,350 --> 00:30:34,450
and there's one of these queues and one of these logs per sender receiver pair,

459
00:30:34,540 --> 00:30:36,490
so that sender actually can manage and know

460
00:30:36,490 --> 00:30:38,290
what the beginning and the end of the log are.

461
00:30:40,020 --> 00:30:42,150
Then, in addition to that,

462
00:30:42,150 --> 00:30:49,590
there's something there message queues and also one per pair,

463
00:30:51,340 --> 00:30:54,970
and these are basically used to implement RPCs,

464
00:30:55,270 --> 00:30:57,940
so if you want to do remote procedure call,

465
00:30:58,090 --> 00:31:04,330
the client, the sender makes write RDMA RDMA packet,

466
00:31:04,630 --> 00:31:09,190
writes you know the data, the message basically into the remote message queue,

467
00:31:09,580 --> 00:31:13,990
there's a thread sitting on the destination side,

468
00:31:13,990 --> 00:31:18,430
that is basically polling that message queue or polling all the message queues,

469
00:31:18,760 --> 00:31:21,280
if it sees a message, you know it processes the message,

470
00:31:21,430 --> 00:31:25,850
and can then send a response back, using a write RDMA,

471
00:31:32,530 --> 00:31:38,050
and this turns out to be cheaper implementing remote procedure call using RDMA,

472
00:31:38,200 --> 00:31:43,330
it turns out to be cheaper than basically using sort of standard RPC packet,

473
00:31:43,450 --> 00:31:49,930
that you know since packet using a regular NIC, but without RDMA

474
00:31:50,170 --> 00:31:53,140
and has a thread on the other side you know that response.

475
00:31:54,190 --> 00:31:54,820
Okay?

476
00:31:56,450 --> 00:31:58,250
Is there any validation step here,

477
00:31:58,250 --> 00:32:01,760
to make sure that you're you're only writing to a region of memory,

478
00:32:01,760 --> 00:32:04,250
that's expressly allowed for RDMA,

479
00:32:04,250 --> 00:32:07,700
you know don't write application to application memory or something.

480
00:32:07,820 --> 00:32:09,380
Yeah, so there are all kinds of,

481
00:32:09,380 --> 00:32:12,080
you know this is sort of the high-level idea,

482
00:32:12,140 --> 00:32:13,610
talk into details here,

483
00:32:14,090 --> 00:32:18,590
so when you sort of set up one of these RDMA,

484
00:32:18,590 --> 00:32:24,230
in order to do this one-sided RDMA or write RDMAs,

485
00:32:24,320 --> 00:32:26,180
you first have to do connection setup,

486
00:32:26,390 --> 00:32:31,730
there's a negotiation step between the sender and the receiver to setup,

487
00:32:31,730 --> 00:32:34,310
basically like it's almost like a TCP channel,

488
00:32:34,310 --> 00:32:36,950
except you know RDMA doesn't use TCP,

489
00:32:37,070 --> 00:32:43,640
but it sets up a connection oriented reliable, ordered channel,

490
00:32:46,080 --> 00:32:48,810
and so the security checks and access control checks

491
00:32:48,810 --> 00:32:50,220
are happening at the point of the setup.

492
00:32:53,190 --> 00:32:56,280
So would you have to do that between every pair of machines?

493
00:32:56,280 --> 00:32:56,790
Yes.

494
00:32:58,600 --> 00:33:00,790
So that would become really costly to add,

495
00:33:00,820 --> 00:33:04,000
like one machine to a large cluster, right?

496
00:33:04,330 --> 00:33:07,090
You have n square RDMA connections,

497
00:33:08,300 --> 00:33:10,550
and otherwise we would have n square TCP connections,

498
00:33:11,650 --> 00:33:14,590
not clear as a major difference there.

499
00:33:18,040 --> 00:33:19,720
And so just to clarify,

500
00:33:19,720 --> 00:33:21,700
so the message in the logs,

501
00:33:21,700 --> 00:33:24,340
basically they both sit also in memory,

502
00:33:24,340 --> 00:33:27,100
they just sit in different places than where the objects sit.

503
00:33:27,430 --> 00:33:28,120
Yeah, exactly,

504
00:33:28,180 --> 00:33:28,990
so if you do,

505
00:33:28,990 --> 00:33:30,760
so this is sort of on here on the right,

506
00:33:31,150 --> 00:33:35,530
is a picture of the memory layout of the FaRM process,

507
00:33:35,530 --> 00:33:39,100
you know there's a region table or an object table,

508
00:33:39,100 --> 00:33:42,850
and there are regions in the memory of the server,

509
00:33:43,090 --> 00:33:45,820
these regions have objects in them,

510
00:33:46,090 --> 00:33:47,590
and in addition to the regions,

511
00:33:47,590 --> 00:33:50,290
there are message queues and there are logs.

512
00:33:51,900 --> 00:33:52,440
I see,

513
00:33:52,560 --> 00:33:56,460
and also for the NIC to support the direct access from memory,

514
00:33:56,460 --> 00:33:59,280
so since here we don't have any software involved,

515
00:33:59,280 --> 00:34:02,730
since the NIC can directly access the memory

516
00:34:02,730 --> 00:34:06,900
without even notifying the application or the OS,

517
00:34:07,110 --> 00:34:09,690
shouldn't be some coordination on the hardware level,

518
00:34:09,690 --> 00:34:16,830
or at least some support also from the processor to this feature.

519
00:34:17,190 --> 00:34:19,380
Yeah, so there's, it's basically,

520
00:34:19,380 --> 00:34:26,380
you know the NIC can read or write read or write cache lines atomically

521
00:34:26,680 --> 00:34:28,810
and so to support this,

522
00:34:28,810 --> 00:34:33,940
you know there's an interface you know to the memory system between NIC,

523
00:34:33,940 --> 00:34:37,150
and this has to be carefully setup you know between OS

524
00:34:37,150 --> 00:34:38,920
and when the connection setup is done.

525
00:34:40,710 --> 00:34:41,520
I see, thank you.

526
00:34:43,780 --> 00:34:48,850
Sorry, the write to RDMA on the right side that is red,

527
00:34:49,750 --> 00:34:50,890
what happens there?

528
00:34:52,120 --> 00:34:57,760
So, the sender, the left machine can do write RDMA,

529
00:34:58,090 --> 00:35:00,430
which basically sends an write RDMA packets

530
00:35:00,730 --> 00:35:03,880
to the right side you know the destination,

531
00:35:04,180 --> 00:35:07,960
and the NIC you know sees this is a write RDMA packet,

532
00:35:08,380 --> 00:35:10,900
and will write the content that came in over the network

533
00:35:11,110 --> 00:35:15,190
to the address that's specified in the write RDMA command.

534
00:35:18,950 --> 00:35:20,240
But that would be just.

535
00:35:20,750 --> 00:35:22,700
And so there's a remote machine,

536
00:35:22,700 --> 00:35:27,230
can just write the memory location set of addresses on the destination machine,

537
00:35:27,230 --> 00:35:30,770
without actually having the server you know being involved,

538
00:35:31,670 --> 00:35:33,110
other than doing setup, of course.

539
00:35:33,860 --> 00:35:34,940
Thank you.

540
00:35:37,030 --> 00:35:38,110
So, quick question,

541
00:35:38,110 --> 00:35:45,900
so that the, the queue, the queue and the NIC is only used for read RDMA,

542
00:35:46,290 --> 00:35:50,700
like the write, write directly to memory at the receiver.

543
00:35:51,500 --> 00:35:52,730
Yeah, on the on the,

544
00:35:52,790 --> 00:35:54,920
okay, so there on the write RDMA,

545
00:35:54,920 --> 00:35:56,630
as you maybe noticed in the paper,

546
00:35:56,750 --> 00:35:58,790
there can be an acknowledgment coming back,

547
00:35:59,400 --> 00:36:04,110
so, if the sender sends does write RDMA,

548
00:36:04,200 --> 00:36:08,490
it can wait from an acknowledgement, from the receiving NIC,

549
00:36:08,640 --> 00:36:11,340
that actually indeed performed the write RDMA.

550
00:36:13,550 --> 00:36:15,080
Okay, thanks.

551
00:36:16,630 --> 00:36:18,370
And that will play an important role.

552
00:36:21,300 --> 00:36:23,910
Any more questions about this part?

553
00:36:25,430 --> 00:36:27,590
This sort of a cool piece of technology,

554
00:36:27,590 --> 00:36:33,320
you know that's come into existence pretty widespread in the last decade,

555
00:36:33,650 --> 00:36:35,690
and basically they want to leverage it,

556
00:36:37,620 --> 00:36:42,000
because it allows them to get very, get something the latency

557
00:36:42,000 --> 00:36:46,710
to actually do one of these one-sided RDMAs about 5 microseconds,

558
00:36:49,000 --> 00:36:51,280
so very low latency,

559
00:36:54,010 --> 00:36:55,840
much much much faster, correct,

560
00:36:55,840 --> 00:36:57,490
for example reading or writing a disk,

561
00:36:57,790 --> 00:37:04,570
and not much slower, slower than writing your own memory,

562
00:37:04,660 --> 00:37:06,310
but you know pretty fast,

563
00:37:08,020 --> 00:37:12,700
because it allows you to do is one microsecond, a million packets per second,

564
00:37:14,150 --> 00:37:15,050
pretty impressive.

565
00:37:17,450 --> 00:37:17,990
Okay?

566
00:37:19,320 --> 00:37:21,780
So this so far basically standard technology, right,

567
00:37:21,810 --> 00:37:27,130
you know cutting edge, but you know standard.

568
00:37:27,990 --> 00:37:34,580
So, the real challenge that the paper address is,

569
00:37:36,800 --> 00:37:40,520
it's actually how to use RDMA,

570
00:37:41,030 --> 00:37:45,800
both write RDMA and one-sided RDMA actually doing transactions,

571
00:37:45,800 --> 00:37:50,000
so the challenge this paper address is transactions using RDMA.

572
00:37:59,210 --> 00:38:03,140
And you know sort of see that this is challenge,

573
00:38:03,140 --> 00:38:04,700
we have to think a little bit about,

574
00:38:04,700 --> 00:38:06,770
all the protocols that we've seen so far,

575
00:38:07,130 --> 00:38:18,560
so it sort of protocols for you know for transactions, two-phase commit, etc,

576
00:38:18,710 --> 00:38:23,060
all those protocols have required server-side participation,

577
00:38:33,290 --> 00:38:37,070
and for example, what I mean with that is

578
00:38:37,070 --> 00:38:41,300
you know the client sends a request for the transaction coordinator,

579
00:38:41,300 --> 00:38:43,130
sends a request to one of the participants,

580
00:38:43,490 --> 00:38:47,840
for example to require a lock on a particular object,

581
00:38:48,020 --> 00:38:52,790
and you know just wait you know on the server or the receiver

582
00:38:52,790 --> 00:38:54,890
until the lock actually it becomes available,

583
00:38:55,400 --> 00:39:00,200
or you know runs you know the server runs some validation step,

584
00:39:00,200 --> 00:39:05,720
you know to see if the the transaction can be committed or not,

585
00:39:06,230 --> 00:39:08,810
and so in all those cases basically,

586
00:39:08,930 --> 00:39:11,090
if you have some server-side participation,

587
00:39:11,090 --> 00:39:13,550
that means that you have to run code on the server,

588
00:39:22,550 --> 00:39:27,230
and you know that is sort of counter to what RDMA gives you, right,

589
00:39:27,230 --> 00:39:33,110
RDMA actually doesn't provide you the ability to run code on the server,

590
00:39:33,170 --> 00:39:36,740
and so the the designers or the authors of this paper

591
00:39:36,740 --> 00:39:38,540
have to come up with sort of protocols,

592
00:39:38,750 --> 00:39:43,700
that allow you to implement two-phase commit and transactions in general

593
00:39:43,820 --> 00:39:48,530
to without actually or trying to reduce your server-side participation,

594
00:39:49,480 --> 00:39:52,840
so that they can reuse some part of the operations using RDMA,

595
00:39:53,020 --> 00:39:56,200
and you know some using remote procedure calls,

596
00:39:56,230 --> 00:39:57,910
as usual sort of traditional would do,

597
00:39:57,910 --> 00:40:01,660
in traditional designs, that we've seen in the last couple weeks.

598
00:40:02,430 --> 00:40:07,980
And so that's sort of the central challenge in in this paper,

599
00:40:07,980 --> 00:40:13,500
and this pushes them in this direction to solve that problem,

600
00:40:13,830 --> 00:40:17,310
the high-level strategy that they use is,

601
00:40:21,220 --> 00:40:26,290
the high level strategy uses is optimistic concurrency control.

602
00:40:30,750 --> 00:40:37,050
And and you know really did really where the shine for them is on read operations,

603
00:40:37,320 --> 00:40:41,040
because basically the basic plan is read objects,

604
00:40:42,340 --> 00:40:46,600
that are part of the transaction without requiring locks,

605
00:40:51,240 --> 00:40:56,580
for example require locks you know that would mean interrupting maybe the server,

606
00:40:56,580 --> 00:40:58,080
the server has to do some work,

607
00:40:58,080 --> 00:41:00,540
and then maybe block the client

608
00:41:00,540 --> 00:41:03,900
until the lock is available and then return the object,

609
00:41:03,900 --> 00:41:12,870
and you know that is not really suitable or nice nicely with or lines up nicely with RDMA,

610
00:41:12,960 --> 00:41:15,720
and so they're going to go to optimistic scheme,

611
00:41:15,810 --> 00:41:19,110
where basically reading objects is not going to require locks at all,

612
00:41:19,140 --> 00:41:22,800
you can fetch an object and start using it,

613
00:41:22,800 --> 00:41:24,300
and as we'll see,

614
00:41:24,390 --> 00:41:26,790
you know of course you need to have some mechanism

615
00:41:26,790 --> 00:41:29,400
to discover whether you're reading an old version or new version,

616
00:41:29,580 --> 00:41:32,130
and this is where the version numbers are going to play an important role.

617
00:41:39,130 --> 00:41:41,950
So when you read an object in FaRM,

618
00:41:41,950 --> 00:41:42,970
you get the object back,

619
00:41:42,970 --> 00:41:45,370
and you get also the version number back to that object,

620
00:41:45,880 --> 00:41:49,210
and then basic idea is that,

621
00:41:49,210 --> 00:41:50,290
at the point of commit,

622
00:41:50,810 --> 00:41:54,410
we're going to do a validation step,

623
00:41:56,300 --> 00:42:02,930
to check that the objects being write at the beginning of the transaction,

624
00:42:02,930 --> 00:42:04,160
actually having been modified.

625
00:42:04,580 --> 00:42:06,680
And so during validation check step,

626
00:42:06,800 --> 00:42:08,720
we're basically going to check for conflict,

627
00:42:15,860 --> 00:42:17,270
and the conflict is basically,

628
00:42:17,270 --> 00:42:20,090
if the version number has been incremented,

629
00:42:20,240 --> 00:42:25,190
you know since you know the coordinator actually read the object,

630
00:42:25,370 --> 00:42:26,990
so if the version number are different,

631
00:42:30,720 --> 00:42:35,930
different, then the transaction is aborted,

632
00:42:39,760 --> 00:42:41,740
and if they're saying, are still the same,

633
00:42:41,740 --> 00:42:48,010
that basically means that nobody, no other transaction modified the transaction, the object,

634
00:42:48,250 --> 00:42:50,350
and then we can actually go ahead and commit.

635
00:42:52,860 --> 00:42:54,690
Of course, in the case of abort,

636
00:42:54,690 --> 00:42:56,280
you know typical what happen is that,

637
00:42:56,280 --> 00:43:00,900
the the client you know maybe run the whole transaction again,

638
00:43:01,400 --> 00:43:04,700
perhaps waiting for a little while before actually doing it,

639
00:43:04,730 --> 00:43:06,500
for some random period of time.

640
00:43:07,730 --> 00:43:10,250
So that's the basic plan, right,

641
00:43:10,250 --> 00:43:12,260
so this is optimistic scheme,

642
00:43:12,350 --> 00:43:16,340
so that reads can completely exploit RDMA,

643
00:43:16,610 --> 00:43:18,020
and as we'll see,

644
00:43:18,020 --> 00:43:23,570
in fact, read won't require any state changes on the servers at all.

645
00:43:25,500 --> 00:43:30,120
And so this is basically sort of the basic idea behind figure 4,

646
00:43:31,710 --> 00:43:33,420
except you know we'll see in a second,

647
00:43:33,420 --> 00:43:35,460
there's quite a bit more complications to it.

648
00:43:36,190 --> 00:43:40,120
So this again, sort of I think I used this phrase in a little while ago,

649
00:43:40,120 --> 00:43:41,110
a couple lectures ago,

650
00:43:41,230 --> 00:43:44,800
the optimistic schema in contrast to the pessimistic scheme is,

651
00:43:44,950 --> 00:43:48,520
you're basically going to assume that you're allowed to do the operation,

652
00:43:48,760 --> 00:43:51,880
and if it turns out you're not allowed, to sort of apologize and abort,

653
00:43:52,150 --> 00:43:53,650
in the pessimistic case,

654
00:43:53,650 --> 00:43:57,790
you basically first ask for approval to do the operation by acquiring locks,

655
00:43:57,940 --> 00:43:59,680
and then you know you basically guaranteed,

656
00:43:59,680 --> 00:44:01,660
at commit time, you can actually commit.

657
00:44:02,480 --> 00:44:03,050
Okay?

658
00:44:04,920 --> 00:44:08,610
Any questions about optimistic concurrency control at this high level?

659
00:44:10,670 --> 00:44:12,470
Just a question about the version numbers,

660
00:44:12,470 --> 00:44:14,840
how do they ensure that two different [],

661
00:44:14,840 --> 00:44:18,500
that there's like consistency across different objects,

662
00:44:18,770 --> 00:44:22,970
so that you're now reading one object and then later reading another object,

663
00:44:22,970 --> 00:44:27,080
but those, but a transaction modified some of those in between.

664
00:44:27,350 --> 00:44:29,810
Yeah, well, that's a great question,

665
00:44:29,960 --> 00:44:32,960
and so let's, I think we're going to get out,

666
00:44:32,960 --> 00:44:35,180
just gotta dive into actually figure 4,

667
00:44:35,890 --> 00:44:38,200
and which I think should be the core of this paper.

668
00:44:39,440 --> 00:44:42,470
So let's look at figure 4,

669
00:44:43,310 --> 00:44:51,940
and, oops, not that one.

670
00:44:56,630 --> 00:44:57,800
Alright, here figure 4,

671
00:45:00,160 --> 00:45:03,550
we're going to spend quite a bit of time basically talking about figure 4.

672
00:45:04,960 --> 00:45:10,540
So the first you know things get oriented in this figure 4,

673
00:45:10,570 --> 00:45:13,150
you know we see,

674
00:45:17,910 --> 00:45:22,920
so we have a transaction coordinator, the C here,

675
00:45:23,190 --> 00:45:26,700
and it's really the transaction coordinator is an application,

676
00:45:26,730 --> 00:45:29,040
and the application runs on the same machine,

677
00:45:29,040 --> 00:45:30,540
is one of those 90 machines,

678
00:45:30,810 --> 00:45:32,670
but the way I'm going to think about it,

679
00:45:32,850 --> 00:45:34,140
for the rest of those lectures,

680
00:45:34,140 --> 00:45:35,490
that it runs on a separate machine,

681
00:45:35,490 --> 00:45:37,920
I don't really care about it that much, okay?

682
00:45:38,620 --> 00:45:40,900
And then, there are different shards,

683
00:45:41,200 --> 00:45:45,310
in this case there are 3 shards, 1 2 and 3,

684
00:45:45,640 --> 00:45:48,250
and each shard is replicated twice,

685
00:45:48,250 --> 00:45:49,840
one's in the primary, one's in the backup.

686
00:45:51,050 --> 00:45:54,260
Then you know we'll see that,

687
00:45:54,260 --> 00:45:56,150
this is the execution phase of the transaction,

688
00:45:56,150 --> 00:45:57,920
so the transaction is two phases,

689
00:45:58,040 --> 00:46:02,030
one is the execution phase, and then commit phase,

690
00:46:02,030 --> 00:46:04,190
and during the execution phase,

691
00:46:04,190 --> 00:46:05,990
this is where the transaction is run,

692
00:46:05,990 --> 00:46:08,330
so does it begin, does read,

693
00:46:08,600 --> 00:46:11,720
for example, in this case, the 3 objects are being read,

694
00:46:11,870 --> 00:46:14,960
and one that was located, whose primary in,

695
00:46:15,050 --> 00:46:17,270
one object that actually sit in shard 1,

696
00:46:17,420 --> 00:46:19,370
one object that's sit in shard 3,

697
00:46:19,370 --> 00:46:22,950
one objects sit in shard 2, alright, region.

698
00:46:23,550 --> 00:46:27,660
And the we can see,

699
00:46:27,660 --> 00:46:29,310
actually we look a little bit ahead,

700
00:46:29,640 --> 00:46:31,290
we'll see that the,

701
00:46:31,830 --> 00:46:35,130
the two of these objects are actually being written,

702
00:46:35,130 --> 00:46:36,690
and one of them is being read,

703
00:46:36,960 --> 00:46:40,350
so the object from number shard 3,

704
00:46:40,410 --> 00:46:41,730
this is just a read operation,

705
00:46:41,820 --> 00:46:43,440
and these are write operations,

706
00:46:43,890 --> 00:46:45,000
or these are read operations,

707
00:46:45,000 --> 00:46:47,400
but those objects are going to be modified.

708
00:46:48,270 --> 00:46:50,550
So basically as the transaction runs,

709
00:46:50,550 --> 00:46:55,050
you know it fetches objects from different machines, modifies them locally,

710
00:46:55,230 --> 00:47:00,360
and then in the commit phase, the changes are being applied,

711
00:47:00,510 --> 00:47:03,180
and of course you know the whole challenge here is that,

712
00:47:03,180 --> 00:47:07,560
in the end we want to achieve strict serializability.

713
00:47:18,740 --> 00:47:24,800
And in some ways, the protocol for,

714
00:47:24,800 --> 00:47:29,150
at least writes always follows a very similar two-phase commit protocols,

715
00:47:29,150 --> 00:47:30,260
that we've seen in the past,

716
00:47:30,260 --> 00:47:31,730
there are differences in the details,

717
00:47:31,880 --> 00:47:34,610
but the basic strategy is the same,

718
00:47:34,610 --> 00:47:36,110
and you know we can sort of,

719
00:47:36,200 --> 00:47:39,920
so let's assume that you know we're done with the execution phase,

720
00:47:39,920 --> 00:47:42,260
so we're we're at the end of the transaction,

721
00:47:42,260 --> 00:47:43,940
and the transaction is going to try to commit,

722
00:47:44,250 --> 00:47:45,990
that transaction that could be two outcomes,

723
00:47:45,990 --> 00:47:48,690
you know actually you know successfully commits or actually aborts,

724
00:47:49,420 --> 00:47:52,870
and the aborts because some other transaction ran concurrently

725
00:47:52,990 --> 00:47:54,400
and modifies one of the objects,

726
00:47:54,400 --> 00:47:56,680
that we write or were trying to write.

727
00:47:59,190 --> 00:48:01,170
And so the first thing,

728
00:48:01,170 --> 00:48:05,190
that sort of protocol, the commit phase basically has 5 steps,

729
00:48:05,190 --> 00:48:08,190
you know the locking step, the validation step,

730
00:48:08,220 --> 00:48:10,500
the commit backup step, the commit primary

731
00:48:10,590 --> 00:48:11,400
and then the truncate,

732
00:48:11,400 --> 00:48:15,900
and the truncate basically runs almost lazily

733
00:48:15,900 --> 00:48:17,670
and so it's not particularly important,

734
00:48:17,880 --> 00:48:19,320
basically for our perspective,

735
00:48:19,320 --> 00:48:23,310
basically the point of interest where things are stopping is here,

736
00:48:23,370 --> 00:48:26,160
so that's sort of the end of the transaction is.

737
00:48:27,820 --> 00:48:31,540
Okay, so each of these objects have said before,

738
00:48:31,570 --> 00:48:33,430
you know when you read them has a version number,

739
00:48:33,430 --> 00:48:35,050
here's a version number,

740
00:48:37,290 --> 00:48:41,370
and there are modifies it locally,

741
00:48:41,370 --> 00:48:42,480
then at the point of this,

742
00:48:42,480 --> 00:48:44,580
you know when when this this is the commit point,

743
00:48:44,940 --> 00:48:47,280
where when the application calls end of transaction,

744
00:48:47,550 --> 00:48:52,470
the protocol, but this whole commit phase protocol kicks in.

745
00:48:53,550 --> 00:48:56,550
And so the first thing it does is,

746
00:48:56,550 --> 00:48:59,070
what's called the locking step, step number 1,

747
00:48:59,280 --> 00:49:01,470
and the goal here, in this step is

748
00:49:01,470 --> 00:49:05,370
to basically acquire locks on all the objects that are being written,

749
00:49:06,110 --> 00:49:08,660
and so we can see you know based on this diagram,

750
00:49:08,660 --> 00:49:12,260
that apparently two objects are being written,

751
00:49:12,290 --> 00:49:16,710
namely the this object,

752
00:49:16,710 --> 00:49:20,760
because context is the primary of shard 1, region 1,

753
00:49:20,910 --> 00:49:22,740
and then this object is being read,

754
00:49:22,800 --> 00:49:26,160
that is actually located on region 2, right,

755
00:49:26,490 --> 00:49:29,880
apparently the third object, that we read you know for primary 3,

756
00:49:30,240 --> 00:49:32,430
it's not being write,

757
00:49:32,430 --> 00:49:36,120
because it doesn't participate in the locking phase.

758
00:49:36,700 --> 00:49:38,560
So in the locking phase,

759
00:49:40,400 --> 00:49:43,490
the arrows actually have all kinds of different meanings.

760
00:49:43,610 --> 00:49:48,230
So these dashed arrows are one-sided RDMAs,

761
00:49:57,100 --> 00:49:59,530
so those objects are being read with RDMA,

762
00:49:59,530 --> 00:50:02,920
they're just fetched from the remote memory location,

763
00:50:02,980 --> 00:50:09,400
and [] locally you know to the to the memory of the application or coordinator.

764
00:50:14,620 --> 00:50:17,170
The solid ones are write RDMAs,

765
00:50:17,960 --> 00:50:22,830
and and in this particular case,

766
00:50:26,350 --> 00:50:34,500
they depend on lock entry to the, to the log of the primary,

767
00:50:34,500 --> 00:50:35,910
so the primary has a log,

768
00:50:36,030 --> 00:50:37,500
every primary has a log,

769
00:50:37,530 --> 00:50:39,150
so I'm just gonna draw it like this,

770
00:50:39,980 --> 00:50:43,580
and actually use a different color,

771
00:50:43,940 --> 00:50:47,210
so here we have the primary i with a log,

772
00:50:49,380 --> 00:50:57,100
and basically the the the coordinator, it's a commit record,

773
00:50:58,270 --> 00:51:07,060
no, sorry, sorry, lock record is called to the log,

774
00:51:07,090 --> 00:51:08,440
I'm going to make it a big record,

775
00:51:08,440 --> 00:51:09,910
I can write down what's in it,

776
00:51:10,330 --> 00:51:13,780
and it is [] version number, the time of the read or write

777
00:51:13,780 --> 00:51:14,890
and when the object is read,

778
00:51:14,890 --> 00:51:16,750
so that version number that came out here,

779
00:51:18,690 --> 00:51:21,270
that goes back into the log record,

780
00:51:21,450 --> 00:51:26,490
the object id that's being read and the new value for the object,

781
00:51:29,560 --> 00:51:34,210
and so this record is just appended you know to the

782
00:51:34,690 --> 00:51:40,300
you know primary 1 and primary 2's log,

783
00:51:40,480 --> 00:51:42,580
using write RDMA.

784
00:51:43,360 --> 00:51:46,690
And so there's some thread sitting on those machines,

785
00:51:46,780 --> 00:51:49,480
that looks at these logs and then actually does some operations,

786
00:51:50,190 --> 00:51:51,780
so in this particular case,

787
00:51:51,780 --> 00:51:56,250
if there's a thread sitting on P1 and P2,

788
00:51:56,250 --> 00:52:00,510
you know monitors or spins or polls this log,

789
00:52:00,690 --> 00:52:02,370
and sees there's a new log record,

790
00:52:02,370 --> 00:52:04,950
and then in this particular case, what it will do,

791
00:52:05,010 --> 00:52:07,260
it will try to get a lock on the object,

792
00:52:07,260 --> 00:52:15,050
you know that actually is listed in the in the transaction,

793
00:52:15,050 --> 00:52:16,400
somewhere, there's an object,

794
00:52:18,300 --> 00:52:20,310
and that object have some data in it

795
00:52:20,310 --> 00:52:22,860
and it has these lock bit and version number in it.

796
00:52:25,240 --> 00:52:27,730
And so P1 has one object,

797
00:52:27,730 --> 00:52:32,440
you know that is being modified by coordinator,

798
00:52:32,440 --> 00:52:35,290
P2 has another object, that is modified by the coordinator,

799
00:52:35,620 --> 00:52:44,590
and basically the, the primary tries to be required the lock on the, on the object,

800
00:52:44,590 --> 00:52:45,850
using test-and-set instruction.

801
00:52:46,540 --> 00:52:49,720
And so it will try to set lock bit,

802
00:52:52,050 --> 00:52:54,090
using test-and-set instruction,

803
00:52:54,300 --> 00:52:57,930
and if the lock bit is 0,

804
00:52:57,930 --> 00:53:03,030
and and the lock bit is 0

805
00:53:03,030 --> 00:53:04,920
and successfully set the bit to 1,

806
00:53:05,190 --> 00:53:10,680
then it knows that, the primary knows that actually acquire the lock,

807
00:53:10,830 --> 00:53:14,970
and in that case and we'll send one RDMA message back,

808
00:53:15,000 --> 00:53:18,900
to append a message to the coordinator's message queue,

809
00:53:18,900 --> 00:53:24,520
saying okay, you successfully acquired locks for these particular objects.

810
00:53:26,060 --> 00:53:32,420
If the transaction, if the lock was already taken by another transaction,

811
00:53:32,750 --> 00:53:34,550
and then at that point in time,

812
00:53:34,550 --> 00:53:36,320
the transaction is aborted,

813
00:53:36,500 --> 00:53:40,910
and so so when the primary i tries to get the lock,

814
00:53:40,940 --> 00:53:42,650
finds out that the lock is already set,

815
00:53:42,800 --> 00:53:44,690
using test-and instruction,

816
00:53:44,780 --> 00:53:48,620
then, that lock, so the try lock will fail,

817
00:53:51,060 --> 00:53:56,820
and the the primary will add a message

818
00:53:56,820 --> 00:54:01,350
to the queue of the to the queue of the coordinator,

819
00:54:01,380 --> 00:54:04,350
saying, like I you know I could not acquire the locks,

820
00:54:04,530 --> 00:54:07,890
and the coordinator in that case will abort transactions.

821
00:54:10,060 --> 00:54:11,260
Any questions so far?

822
00:54:13,040 --> 00:54:16,040
How are the are the locks obtained, through zookeeper?

823
00:54:16,600 --> 00:54:19,990
No, these are the other set of locks using zookeeper,

824
00:54:19,990 --> 00:54:21,610
that's really for configuration management,

825
00:54:21,610 --> 00:54:29,420
like the mapping of region number to primary and backups,

826
00:54:29,480 --> 00:54:34,550
these are just in memory locks, that the primary maintains,

827
00:54:34,550 --> 00:54:36,320
so in the address space,

828
00:54:36,320 --> 00:54:38,330
a little bit back, correct,

829
00:54:38,690 --> 00:54:40,310
little,bit back at this picture,

830
00:54:40,460 --> 00:54:42,680
there was a region has objects,

831
00:54:42,710 --> 00:54:45,950
every object has some data and a header,

832
00:54:46,160 --> 00:54:49,490
and in that header, there's basically a 64 bit number,

833
00:54:49,730 --> 00:54:52,580
that were top-level bit is the lock bit,

834
00:54:52,580 --> 00:54:55,310
and 63 other bits for the version number.

835
00:54:56,010 --> 00:54:58,470
Oh, what if the primary goes down,

836
00:54:58,470 --> 00:55:01,080
does the backup have the same locks of the primary?

837
00:55:01,780 --> 00:55:03,160
If the primary goes down,

838
00:55:03,160 --> 00:55:06,400
the whole, what's gonna happen is that,

839
00:55:06,400 --> 00:55:08,260
there's a whole reconfiguration protocol,

840
00:55:08,290 --> 00:55:11,110
happening in new recovery protocol,

841
00:55:11,780 --> 00:55:13,550
the end result of that is that,

842
00:55:13,550 --> 00:55:17,150
in this case, the, we we hope that transaction would be abort, correct,

843
00:55:17,150 --> 00:55:18,920
because it never made it to the end.

844
00:55:19,720 --> 00:55:22,150
We'll get to fault tolerance in a little while,

845
00:55:22,150 --> 00:55:23,410
so let's [] for,

846
00:55:23,590 --> 00:55:26,290
I'm going to talk about in a couple boards,

847
00:55:26,290 --> 00:55:27,580
and I'll talk about fault tolerance.

848
00:55:27,730 --> 00:55:28,150
Thank you.

849
00:55:31,210 --> 00:55:34,570
So the version number are per object, right?

850
00:55:35,260 --> 00:55:36,730
Sure, per object, yeah.

851
00:55:38,620 --> 00:55:39,250
[].

852
00:55:42,080 --> 00:55:46,180
Okay, good, so, alright.

853
00:55:46,180 --> 00:55:47,200
Can I ask a question,

854
00:55:48,130 --> 00:55:50,860
why do they choose to abort the transaction

855
00:55:50,860 --> 00:55:53,680
rather than blocking and waiting for the lock to be released?

856
00:55:54,660 --> 00:55:57,090
Because they have read old [material],

857
00:55:57,920 --> 00:56:00,950
they have not read the latest material value,

858
00:56:01,190 --> 00:56:03,500
and so the transaction has to abort.

859
00:56:04,940 --> 00:56:05,510
Oh I see,

860
00:56:05,510 --> 00:56:08,780
because the lock means that it's gonna change next time.

861
00:56:08,810 --> 00:56:13,360
Well, they ask for locks after really written the object, right,

862
00:56:13,570 --> 00:56:17,290
so the coordinator modifies the object based on some version number,

863
00:56:17,650 --> 00:56:19,570
submits a bunch of writes,

864
00:56:19,840 --> 00:56:22,420
assuming that is write the latest version number,

865
00:56:22,780 --> 00:56:28,390
and so by the time the the commit starts happening,

866
00:56:28,390 --> 00:56:29,740
and you try to get the locks,

867
00:56:29,980 --> 00:56:31,720
and you discover that somebody else is locked,

868
00:56:31,720 --> 00:56:33,310
that means somebody else already modifying it,

869
00:56:33,610 --> 00:56:36,610
and so that would violate serialization, right.

870
00:56:37,820 --> 00:56:38,840
Yep, thank you.

871
00:56:39,110 --> 00:56:41,420
So, in fact the point you get the lock here,

872
00:56:41,780 --> 00:56:44,450
that's sort of the serialization point for write transactions,

873
00:56:45,700 --> 00:56:49,210
at this point, the transaction has acquired all the locks,

874
00:56:49,210 --> 00:56:50,950
for all the objects is modified,

875
00:56:51,160 --> 00:56:55,120
so nobody else can actually modify in this particular point of time,

876
00:56:55,300 --> 00:56:58,660
so that's sort of the serialization point for the write part of the transaction.

877
00:57:02,180 --> 00:57:02,690
Make sense?

878
00:57:04,480 --> 00:57:05,380
Yes, thank you.

879
00:57:07,060 --> 00:57:10,780
Good okay, so now, you might have felt like,

880
00:57:10,780 --> 00:57:14,440
why not do the same thing for read, correct,

881
00:57:14,440 --> 00:57:17,260
and you know get the lock for the read objects,

882
00:57:17,260 --> 00:57:19,210
get the lock from the objects that read,

883
00:57:19,210 --> 00:57:21,220
you know check the version number in you know in good [].

884
00:57:21,860 --> 00:57:25,700
And the reason that that is actually a separate phase,

885
00:57:25,700 --> 00:57:27,110
namely the validation phase

886
00:57:27,530 --> 00:57:32,000
is to basically avoid these expensive write RDMAs, right,

887
00:57:32,270 --> 00:57:33,710
if you look at this vertical step,

888
00:57:33,710 --> 00:57:35,210
you'll see there's a write RDMA,

889
00:57:35,390 --> 00:57:37,400
the server has to run something,

890
00:57:37,430 --> 00:57:40,190
basically does acquiring the locks,

891
00:57:40,580 --> 00:57:42,560
and then responds with another write RDMA.

892
00:57:42,560 --> 00:57:44,840
So here this is a full RPC,

893
00:57:46,480 --> 00:57:48,610
that actually requires server participation,

894
00:57:49,360 --> 00:57:50,740
and as we'll see in a second,

895
00:57:50,980 --> 00:57:55,300
in the, to handle the read the objects have been read,

896
00:57:55,570 --> 00:58:00,160
the the the FaRM uses this validation step,

897
00:58:00,160 --> 00:58:03,310
in the validation step, just used one-sided RDMAs,

898
00:58:03,460 --> 00:58:06,340
and so there's no real server involvement necessary.

899
00:58:12,080 --> 00:58:12,650
Okay?

900
00:58:13,900 --> 00:58:16,060
So, what happens on the,

901
00:58:16,060 --> 00:58:19,150
so basically at this point, the where we here,

902
00:58:19,150 --> 00:58:22,660
the transaction coordinator actually has the write locks,

903
00:58:22,870 --> 00:58:24,070
and now the only thing it does is,

904
00:58:24,070 --> 00:58:27,820
it validates the read locks or basically read version numbers,

905
00:58:28,480 --> 00:58:33,070
and so it for every object that is read but not modified,

906
00:58:33,130 --> 00:58:34,420
so in our particular example,

907
00:58:34,420 --> 00:58:35,710
that's only one object,

908
00:58:35,710 --> 00:58:37,240
this is the one that actually being read,

909
00:58:37,880 --> 00:58:40,690
the one at region 3,

910
00:58:41,020 --> 00:58:46,810
so it's, it basically is one-sided RDMA to read the version number,

911
00:58:46,810 --> 00:58:50,620
that 64 bit number for the object is being read.

912
00:58:51,770 --> 00:58:55,400
And when it gets back, when it gets back here,

913
00:58:55,700 --> 00:58:57,200
it checks two things,

914
00:58:57,660 --> 00:59:01,200
if the lock is taken, so the lock bit set,

915
00:59:01,260 --> 00:59:05,790
that means that some coordinator concurrent transactions is being, is trying to modified,

916
00:59:06,090 --> 00:59:07,710
so that point just abort,

917
00:59:08,260 --> 00:59:10,540
and so the all the transaction abort again,

918
00:59:11,540 --> 00:59:15,710
if the first number is identical and it's not locked,

919
00:59:15,830 --> 00:59:19,370
that means that no other transactions using at this particular point of time,

920
00:59:19,610 --> 00:59:23,960
and the transaction could proceed,

921
00:59:23,990 --> 00:59:27,260
basically all the objects that are being read and modified,

922
00:59:27,560 --> 00:59:30,230
have the version number at the start of transaction,

923
00:59:30,650 --> 00:59:32,630
and nothing has changed yet,

924
00:59:32,780 --> 00:59:35,150
and so it is okay for the transaction to commit,

925
00:59:35,210 --> 00:59:37,730
it is really the true serialization point.

926
00:59:38,600 --> 00:59:40,610
And since you know the transactions numbers

927
00:59:40,610 --> 00:59:42,710
are required at the beginning with version number,

928
00:59:42,710 --> 00:59:44,150
right at the beginning of the transaction,

929
00:59:44,390 --> 00:59:48,710
you know the transaction will commit in the order of the version numbers basically,

930
00:59:48,890 --> 00:59:53,510
and they also would get basically strict serializability,

931
00:59:54,540 --> 00:59:58,350
because any transaction that will start after your transaction commits,

932
00:59:58,350 --> 00:59:59,760
will have higher version number,

933
00:59:59,790 --> 01:00:01,230
so therefore it also will commit later.

934
01:00:04,710 --> 01:00:07,050
Okay, so this is the point,

935
01:00:07,050 --> 01:00:09,960
basically where transaction coordinator says,

936
01:00:10,260 --> 01:00:12,900
you know at this point you know the,

937
01:00:14,230 --> 01:00:17,650
we know that all the we have to, we have acquired the locks,

938
01:00:17,650 --> 01:00:21,970
we have verified to validate the version numbers for the read objects,

939
01:00:21,970 --> 01:00:27,170
and so this is basically the commit point or the start of the commit point,

940
01:00:27,170 --> 01:00:29,660
so this point that is actually going to say,

941
01:00:29,930 --> 01:00:32,210
okay, I'm gonna go, I'm gonna go commit.

942
01:00:34,120 --> 01:00:38,200
And you know there's multiple messages necessary to commit point,

943
01:00:38,200 --> 01:00:39,100
we'll see in a second,

944
01:00:39,100 --> 01:00:41,650
and those are mostly for fault tolerance reasons.

945
01:00:44,400 --> 01:00:45,930
And so at this point,

946
01:00:45,930 --> 01:00:49,680
namely only the primary has been the,

947
01:00:49,980 --> 01:00:56,730
only the primary have been contacted of the of the objects that are being modified,

948
01:00:56,730 --> 01:00:57,750
but not the backups.

949
01:00:58,120 --> 01:01:01,180
And of course we want to ensure that and write,

950
01:01:01,180 --> 01:01:05,680
you know once you commit will survive f failures, right,

951
01:01:05,680 --> 01:01:08,800
system is designed to handle f+1 failures,

952
01:01:09,460 --> 01:01:13,330
in our particular designs, there's one backup,

953
01:01:13,330 --> 01:01:15,430
and so it can only survive one failure.

954
01:01:16,930 --> 01:01:20,740
And so what happens in this final phase, commit backup phase,

955
01:01:20,800 --> 01:01:26,650
is actually we're going to write to the logs of the primary of the backups,

956
01:01:26,650 --> 01:01:29,440
so the backups have log,

957
01:01:30,210 --> 01:01:31,710
so here's backup i,

958
01:01:31,770 --> 01:01:33,660
you know similar there's a log entry in it,

959
01:01:34,290 --> 01:01:38,520
and what we're gonna do is

960
01:01:38,670 --> 01:01:41,520
write what's called commit backup record,

961
01:01:50,500 --> 01:01:56,650
and the commit backup record exactly as the same information as the locking record,

962
01:01:56,650 --> 01:01:57,520
that we saw earlier,

963
01:01:57,520 --> 01:02:04,300
so in it, is going to be the version number, the oid and the new value.

964
01:02:07,870 --> 01:02:08,650
Okay?

965
01:02:09,580 --> 01:02:16,030
And this is you know like before this is actually done using write RDMA,

966
01:02:21,190 --> 01:02:25,060
now the backup doesn't really have to do any operation at this point,

967
01:02:25,060 --> 01:02:27,730
like the server side of the backup doesn't really have to run anything,

968
01:02:27,820 --> 01:02:32,620
just need and and so the the here's this trick,

969
01:02:32,710 --> 01:02:36,160
where basically the sender waits the acknowledgement of the NIC,

970
01:02:36,800 --> 01:02:42,560
and so this you know this is not one-sided or write RDMA,

971
01:02:42,680 --> 01:02:45,950
this is just make acknowledging that it got the write RDMA,

972
01:02:45,950 --> 01:02:47,870
and the write RDMA has been performed.

973
01:02:48,380 --> 01:02:49,910
And so that basically acknowledges,

974
01:02:49,910 --> 01:02:52,670
you know when we get this particular point in the protocol,

975
01:02:52,880 --> 01:02:54,710
the transaction coordinator knows,

976
01:02:54,860 --> 01:02:58,790
the object is in the log of all the primaries,

977
01:02:59,150 --> 01:03:01,970
and objects in in the log of all the backups.

978
01:03:02,420 --> 01:03:05,390
And so now we're in good position in terms of of fault tolerance, correct,

979
01:03:05,390 --> 01:03:09,170
because if any one of the two fails,

980
01:03:09,260 --> 01:03:11,720
the other one can actually apply the write operation.

981
01:03:13,870 --> 01:03:18,670
Then there's one more step that needs to be performed,

982
01:03:18,940 --> 01:03:21,880
and that is commit primary,

983
01:03:21,910 --> 01:03:24,190
I'll talk about a little bit later in more detail,

984
01:03:24,400 --> 01:03:26,950
but this is the final step,

985
01:03:26,950 --> 01:03:30,010
where there's one more log record written,

986
01:03:30,010 --> 01:03:32,890
in the primary, namely commit record,

987
01:03:38,620 --> 01:03:42,910
and the commit record is is transaction id, that actually is being committed.

988
01:03:44,390 --> 01:03:46,220
So like every,

989
01:03:46,220 --> 01:03:48,080
I didn't write that down in the other records,

990
01:03:48,080 --> 01:03:49,730
but every record has a transaction id,

991
01:03:49,730 --> 01:03:51,710
so we know which transaction we're talking about.

992
01:03:53,380 --> 01:03:57,700
And, again this use the same strategy,

993
01:03:57,700 --> 01:04:08,590
there's a write RDMA to appends, to the, to the log,

994
01:04:08,890 --> 01:04:16,240
and you know there's an acknowledgement, the NIC acknowledges the write RDMA,

995
01:04:16,270 --> 01:04:18,700
and so but it doesn't require any interrupts,

996
01:04:19,030 --> 01:04:22,540
or there's no server itself is not being interfered with,

997
01:04:22,630 --> 01:04:25,510
just NIC is involved in these two operations.

998
01:04:26,800 --> 01:04:33,560
Then as soon as, one of the NICs acknowledges the commit record

999
01:04:33,560 --> 01:04:34,910
on one of the primaries,

1000
01:04:35,000 --> 01:04:36,620
at that particular point of time,

1001
01:04:36,710 --> 01:04:38,510
which is actually really truly committed,

1002
01:04:39,000 --> 01:04:40,650
so this is the true commit point,

1003
01:04:43,820 --> 01:04:45,350
the commit starts basically here,

1004
01:04:45,350 --> 01:04:47,090
and this is actually the actual commit point,

1005
01:04:47,360 --> 01:04:48,860
at that particular point in time,

1006
01:04:49,010 --> 01:04:51,890
the transaction coordinator informs the application,

1007
01:04:51,980 --> 01:04:55,430
yes, your transaction has committed, and is done.

1008
01:04:57,470 --> 01:04:59,150
Then, of course some point later,

1009
01:04:59,150 --> 01:05:02,750
the logs need to be cleaned and shortened up and truncated and all that kind of stuff,

1010
01:05:02,750 --> 01:05:05,480
and this is like the truncate phase,

1011
01:05:05,690 --> 01:05:10,220
and that's basically [] back on later locking phases and validation phases,

1012
01:05:10,950 --> 01:05:13,380
and so I'm not really going to talk about it at all,

1013
01:05:13,380 --> 01:05:15,960
but basically they have to truncate the logs,

1014
01:05:15,960 --> 01:05:17,580
so that they don't grow unbounded.

1015
01:05:23,640 --> 01:05:27,960
Sorry, but the hardware acts,

1016
01:05:27,960 --> 01:05:34,400
they just go directly into, into the NIC of the coordinator?

1017
01:05:34,400 --> 01:05:37,970
Yeah, let's go back to the RDMA picture, right,

1018
01:05:38,360 --> 01:05:40,250
so if a write RDMA happens,

1019
01:05:41,090 --> 01:05:43,100
so here're write RDMA,

1020
01:05:43,250 --> 01:05:46,160
the sender coordinator was running here, right,

1021
01:05:46,190 --> 01:05:48,800
and here's may be one of the primary, so the backups,

1022
01:05:49,600 --> 01:05:52,180
and so the write RDMA goes in,

1023
01:05:52,210 --> 01:05:54,970
write maybe an entry to the log,

1024
01:05:54,970 --> 01:05:58,150
the NIC does that, NIC sends an acknowledgement back,

1025
01:06:00,170 --> 01:06:03,410
and the coordinator will see that acknowledgment in the received queue,

1026
01:06:07,180 --> 01:06:13,150
and so soon as the coordinator sees the ack you know for it's write RDMA,

1027
01:06:13,300 --> 01:06:15,520
it can proceed,

1028
01:06:16,380 --> 01:06:18,390
and knows that the write RDMA succeeded.

1029
01:06:23,920 --> 01:06:28,300
So does the write RDMA is only write to the log, they.

1030
01:06:28,930 --> 01:06:30,850
They're used in two cases,

1031
01:06:30,910 --> 01:06:37,060
they're both used for these message queues and for the the log append.

1032
01:06:41,620 --> 01:06:45,040
And so when we say that a write RDMA has been performed,

1033
01:06:45,040 --> 01:06:47,020
we mean that it has been appended to the log

1034
01:06:47,050 --> 01:06:49,990
and not actually executed necessarily by the application.

1035
01:06:50,050 --> 01:06:52,030
That's correct, that's correct,

1036
01:06:52,030 --> 01:06:53,440
so for example you know to,

1037
01:06:53,440 --> 01:06:58,840
for example to the backup to actually perform the update to the object,

1038
01:06:58,840 --> 01:07:01,870
you need to read the log entry and then apply the update.

1039
01:07:03,730 --> 01:07:04,090
I see,

1040
01:07:04,090 --> 01:07:06,850
and also for the lock bit for every object,

1041
01:07:06,850 --> 01:07:08,830
so since everything resides in memory,

1042
01:07:08,830 --> 01:07:12,250
and we have like 64 bits for the version number plus the lock bit,

1043
01:07:12,430 --> 01:07:15,700
so I'm assuming that it can fit in a single memory address,

1044
01:07:15,910 --> 01:07:17,500
but we can still have the problem of,

1045
01:07:17,500 --> 01:07:21,880
let's say the processor fetching that memory address into register,

1046
01:07:22,150 --> 01:07:25,600
and then maybe if we have a multi-core machine,

1047
01:07:25,600 --> 01:07:29,440
then another core fetching that that same address,

1048
01:07:29,440 --> 01:07:32,140
and then both of them flipping from 0 to 1,

1049
01:07:32,500 --> 01:07:35,800
so I'm assuming that there's some support from the hardware?

1050
01:07:35,920 --> 01:07:38,050
Yeah, so like I mentioned a bit earlier,

1051
01:07:38,050 --> 01:07:39,550
the primary when it acquires,

1052
01:07:39,550 --> 01:07:45,160
the primaries actually involved correct in the primary on,

1053
01:07:45,160 --> 01:07:46,540
so the coordinator sends,

1054
01:07:46,540 --> 01:07:50,380
so in the lock step like this, this step, step one,

1055
01:07:50,590 --> 01:07:57,940
the primary or the coordinator sends an write RDMA to the to the primaries,

1056
01:07:57,970 --> 01:08:02,220
asking the primaries to lock the object,

1057
01:08:02,730 --> 01:08:07,830
and the primaries answer explicitly with a message, then reply,

1058
01:08:08,220 --> 01:08:11,580
and so this crucial step that happens is,

1059
01:08:11,580 --> 01:08:13,680
that the primary when it actually tries to get the lock,

1060
01:08:14,010 --> 01:08:16,380
and that lock is set,

1061
01:08:16,410 --> 01:08:19,500
you know reason this is one single 64 bit number,

1062
01:08:19,620 --> 01:08:21,630
is so that you can use [] test-and-set instruction,

1063
01:08:21,780 --> 01:08:24,180
which is atomic to set the lock.

1064
01:08:25,640 --> 01:08:29,420
So if two, so there's never the case,

1065
01:08:29,420 --> 01:08:33,410
there's only, if two test-and-set instructions run exactly the same time,

1066
01:08:33,500 --> 01:08:35,390
one is going to win, the other is going to lose.

1067
01:08:36,500 --> 01:08:37,400
I see, thank you.

1068
01:08:38,090 --> 01:08:39,920
That's a crucial point, right.

1069
01:08:42,350 --> 01:08:46,370
I've got a question about the blue commit point.

1070
01:08:47,190 --> 01:08:48,180
Yeah.

1071
01:08:49,220 --> 01:08:50,420
Wouldn't it, so.

1072
01:08:50,660 --> 01:08:52,100
Should I, let me,

1073
01:08:52,100 --> 01:08:55,730
maybe it's better to actually open a new slide with the picture again,

1074
01:08:55,730 --> 01:08:59,030
and just instead of scribbling even more over this,

1075
01:08:59,490 --> 01:09:01,110
I mean, let's get one more picture,

1076
01:09:01,110 --> 01:09:03,270
so we can talk about other scenarios,

1077
01:09:14,240 --> 01:09:15,350
I think a little bit bigger,

1078
01:09:15,530 --> 01:09:17,150
I think should do that.

1079
01:09:18,410 --> 01:09:21,910
Okay, so you're worried about,

1080
01:09:21,940 --> 01:09:22,720
let me see.

1081
01:09:23,590 --> 01:09:27,520
Yeah, the commit point between step, after step 2, before step 3.

1082
01:09:27,670 --> 01:09:30,370
Yeah, so here, here's the decision, correct.

1083
01:09:30,370 --> 01:09:30,760
Right.

1084
01:09:31,240 --> 01:09:36,210
Starting to commit and then basically here's the actually commit point, right.

1085
01:09:37,090 --> 01:09:41,140
Okay, yeah I guess I was trying to think about the scenario,

1086
01:09:41,140 --> 01:09:47,440
where, would it be possible for a completely separate concurrent transaction,

1087
01:09:47,830 --> 01:09:51,820
that writes only P3 to get interleaved,

1088
01:09:51,850 --> 01:09:55,390
to like start and complete in that space,

1089
01:09:55,840 --> 01:09:56,890
and then wasn't that?

1090
01:09:57,450 --> 01:09:58,170
No, [],

1091
01:09:58,170 --> 01:10:01,290
yeah, we're problematic, but can't, correct,

1092
01:10:01,290 --> 01:10:02,160
because when it writes,

1093
01:10:02,160 --> 01:10:03,660
it does get the lock at some point,

1094
01:10:04,580 --> 01:10:05,960
and when we get the lock,

1095
01:10:05,960 --> 01:10:07,580
we check the version number and the lock bit.

1096
01:10:10,580 --> 01:10:14,630
But, does the read, does the read the P3 affect the version number and lock bit?

1097
01:10:15,290 --> 01:10:17,450
No, no, it just gets the version number.

1098
01:10:19,350 --> 01:10:23,370
But if you, let let me hold that question,

1099
01:10:23,370 --> 01:10:24,570
you're going to come back at this.

1100
01:10:25,250 --> 01:10:27,470
Okay, then we'll see what actually happens?

1101
01:10:28,820 --> 01:10:29,570
Okay, thanks.

1102
01:10:31,640 --> 01:10:32,630
Any other questions?

1103
01:10:34,930 --> 01:10:36,490
This might be like a separate scenario,

1104
01:10:36,490 --> 01:10:41,410
but what happens if you know after the execution phase,

1105
01:10:41,980 --> 01:10:45,160
you know it tries to acquire a lock,

1106
01:10:45,190 --> 01:10:47,530
and then crashes right after that,

1107
01:10:47,800 --> 01:10:49,120
and the lock has been acquired,

1108
01:10:49,120 --> 01:10:50,830
but no one else after that can acquire it.

1109
01:10:51,830 --> 01:10:55,730
Yeah, okay, so well first of all, the machine disappears from the earth, correct,

1110
01:10:55,730 --> 01:10:57,320
and memory content is gone too,

1111
01:10:59,200 --> 01:11:02,470
and in the whole recovery protocol,

1112
01:11:02,470 --> 01:11:05,170
that is described in the next section in the paper kicks in,

1113
01:11:05,760 --> 01:11:09,690
and that protocol in the end will abort the transaction,

1114
01:11:17,640 --> 01:11:19,380
so it will get cleaned up.

1115
01:11:26,440 --> 01:11:27,670
Just another question,

1116
01:11:27,700 --> 01:11:33,190
so here like the coordinator is the client, right, like it's the application.

1117
01:11:33,190 --> 01:11:35,800
Yeah, yeah.

1118
01:11:36,010 --> 01:11:38,800
And so the client is basically doing all the steps,

1119
01:11:38,800 --> 01:11:40,390
of like lock that.

1120
01:11:40,630 --> 01:11:42,850
Yeah, yeah, so you could think about

1121
01:11:42,850 --> 01:11:45,760
the applications running on the same set of 90 machines, right,

1122
01:11:45,760 --> 01:11:48,370
and you know running this transaction,

1123
01:11:48,550 --> 01:11:51,220
which apparently you know writes two objects and read one,

1124
01:11:51,520 --> 01:11:53,740
and runs the protocol.

1125
01:11:54,540 --> 01:11:58,080
And so, I guess what's confusing is,

1126
01:11:58,260 --> 01:12:02,760
so does the primary not communicate with the backup directly, it's the.

1127
01:12:02,790 --> 01:12:04,830
No, it's actually indeed,

1128
01:12:04,830 --> 01:12:06,930
the primary does not directly communicate with the backup.

1129
01:12:07,720 --> 01:12:08,320
I see.

1130
01:12:09,980 --> 01:12:11,630
Other than during recovery protocol,

1131
01:12:11,630 --> 01:12:13,040
there's all kinds of communication happening,

1132
01:12:13,040 --> 01:12:14,060
but that's not shown here.

1133
01:12:18,590 --> 01:12:22,340
So the coordinator just uses the configuration from the zookeeper?

1134
01:12:22,340 --> 01:12:26,090
Yeah, yeah, you go back to the very first picture,

1135
01:12:26,540 --> 01:12:29,690
you know there's all kinds of stuff you know related to this to that,

1136
01:12:29,690 --> 01:12:33,320
I'm not talking about like this precise membership and all that kind of thing,

1137
01:12:33,650 --> 01:12:37,310
but basically the zookeeper and connection manager really decide,

1138
01:12:37,310 --> 01:12:40,820
well this is a configuration, the current configuration, we're running in,

1139
01:12:41,120 --> 01:12:42,380
these are the regions,

1140
01:12:42,380 --> 01:12:45,320
how they're mapped primary backups and all that stuff,

1141
01:12:46,600 --> 01:12:48,070
and in any failure happens,

1142
01:12:48,070 --> 01:12:51,190
you know there's a whole reconfiguration process going on and recovery.

1143
01:12:53,370 --> 01:12:54,180
I see, thank you.

1144
01:13:00,820 --> 01:13:05,320
Okay, maybe I'm gonna skip the breakout room,

1145
01:13:05,320 --> 01:13:08,260
and so I can go a little bit further,

1146
01:13:08,380 --> 01:13:10,540
the question you know I wanted to answer the question,

1147
01:13:10,540 --> 01:13:14,230
that in the that was asking the post in the lecture,

1148
01:13:14,230 --> 01:13:15,790
I'm gonna lecture question,

1149
01:13:15,790 --> 01:13:19,660
and I'm just going to do that by talking about an example of transaction,

1150
01:13:19,660 --> 01:13:21,700
and this also comes to the earlier question about,

1151
01:13:22,090 --> 01:13:23,350
you know what happens,

1152
01:13:23,350 --> 01:13:26,440
you know two transactions run and read one version,

1153
01:13:26,440 --> 01:13:29,320
and then it commits blah blah blah all this stuff.

1154
01:13:29,350 --> 01:13:32,470
So so this is really the topic here

1155
01:13:32,470 --> 01:13:34,420
is going to do we get strict serializability?

1156
01:13:39,620 --> 01:13:40,730
And what I'm gonna do is,

1157
01:13:40,730 --> 01:13:43,760
I'm not going to give you proof you know that getting strict serializability will be,

1158
01:13:43,760 --> 01:13:44,810
instead what I'm gonna do is,

1159
01:13:44,810 --> 01:13:46,520
I'm going to walk for one or two examples,

1160
01:13:47,100 --> 01:13:48,900
to get build up some intuition,

1161
01:13:49,500 --> 01:13:51,570
and hopefully the intuition you know sort of convinced

1162
01:13:51,570 --> 01:13:53,520
you know that things might actually be fine.

1163
01:13:54,370 --> 01:13:56,680
So let's look at the following transaction,

1164
01:13:56,740 --> 01:13:57,940
we have TxnBegin,

1165
01:13:59,740 --> 01:14:00,700
and this transaction is,

1166
01:14:00,700 --> 01:14:03,940
you know like in the beginning, it reads an object,

1167
01:14:08,620 --> 01:14:18,930
adds 1, and then write the object,

1168
01:14:20,040 --> 01:14:24,410
and commits or ends with commit by fail,

1169
01:14:26,030 --> 01:14:27,140
so that's a transaction.

1170
01:14:27,810 --> 01:14:30,900
And you know we want to ask yourself,

1171
01:14:30,900 --> 01:14:32,220
what are the legal outcomes,

1172
01:14:32,220 --> 01:14:34,260
what are the outcomes correct.

1173
01:14:42,100 --> 01:14:45,880
So what are the possible outcomes of this transaction,

1174
01:14:47,290 --> 01:14:48,400
what could be the state of,

1175
01:14:48,490 --> 01:14:50,740
let's say x started at 0,

1176
01:14:50,860 --> 01:14:55,540
and we're running two transactions, you know T1 and T2,

1177
01:14:57,530 --> 01:15:00,920
what are the possible outcomes that are fine.

1178
01:15:04,080 --> 01:15:06,330
Either one of them could commit

1179
01:15:06,330 --> 01:15:07,590
or both of them could commit?

1180
01:15:08,260 --> 01:15:12,040
Yeah, and so we can have x=2, correct, both commit,

1181
01:15:12,930 --> 01:15:16,650
x=1, possibility one commit, and one another abort,

1182
01:15:16,650 --> 01:15:18,630
general two run concurrently or something,

1183
01:15:19,360 --> 01:15:21,370
and any other possible outcomes?

1184
01:15:23,940 --> 01:15:24,360
0.

1185
01:15:24,930 --> 01:15:26,400
Yeah 0,

1186
01:15:26,430 --> 01:15:28,470
if you know basically both abort, right,

1187
01:15:28,560 --> 01:15:29,760
maybe there's a crash.

1188
01:15:30,920 --> 01:15:33,020
Okay, so those are the three legal outcomes,

1189
01:15:33,620 --> 01:15:37,130
so this, you have to make sure that is the case.

1190
01:15:37,130 --> 01:15:40,910
So let's say T1 runs and so does a read operation,

1191
01:15:41,360 --> 01:15:43,760
get x back, maybe at version 0,

1192
01:15:44,120 --> 01:15:49,600
same thing with T2, it reads you know x 0,

1193
01:15:49,690 --> 01:15:53,050
and so it's basically to run truly concurrent,

1194
01:15:53,410 --> 01:15:56,470
and this is the question that we ask,

1195
01:15:56,470 --> 01:15:57,070
you know the lock question,

1196
01:15:57,070 --> 01:15:59,410
we do lock x, we do lock x,

1197
01:16:00,140 --> 01:16:04,190
and here sort of crucial step, correct,

1198
01:16:04,190 --> 01:16:06,470
because at this particular point,

1199
01:16:06,560 --> 01:16:10,160
there we're trying to get the locks on object 0

1200
01:16:10,370 --> 01:16:12,860
and can both succeed?

1201
01:16:14,860 --> 01:16:15,610
In reading?

1202
01:16:16,090 --> 01:16:17,260
In getting the lock x.

1203
01:16:18,610 --> 01:16:19,930
Oh, in getting the lock,

1204
01:16:19,960 --> 01:16:21,850
not at the same time.

1205
01:16:22,480 --> 01:16:24,790
So one is gonna, one is going to succeed, correct.

1206
01:16:25,440 --> 01:16:28,200
And so let's say the first one succeeds and gets the lock,

1207
01:16:28,820 --> 01:16:30,380
that means it can commit, right,

1208
01:16:31,430 --> 01:16:32,630
so this guy will commit,

1209
01:16:33,290 --> 01:16:36,170
and what happens with the second guy?

1210
01:16:36,870 --> 01:16:40,560
The second one, if it tries to obtain the lock at the same time,

1211
01:16:40,560 --> 01:16:41,820
that the first one is holding the lock,

1212
01:16:41,820 --> 01:16:42,900
it will abort and stop,

1213
01:16:43,320 --> 01:16:47,160
if the first transaction goes through the way and the lock is released,

1214
01:16:47,430 --> 01:16:48,960
then it will obtain the lock,

1215
01:16:48,960 --> 01:16:54,120
and then check to see whether the version that it has for x is still correct,

1216
01:16:54,210 --> 01:16:57,180
and it will find that the version has been changed,

1217
01:16:57,180 --> 01:16:58,020
and then it will abort.

1218
01:16:58,350 --> 01:17:02,040
Yep, this is exactly the two, the two cases.

1219
01:17:02,160 --> 01:17:05,040
So let me talk about validation case in in a second,

1220
01:17:05,040 --> 01:17:07,020
with a slightly different example, maybe more interesting,

1221
01:17:07,320 --> 01:17:09,810
but this is basically the outcome, right.

1222
01:17:11,520 --> 01:17:15,600
Good, and so even though these transactions in this particular picture

1223
01:17:15,600 --> 01:17:17,580
run you know exactly at the same time,

1224
01:17:17,610 --> 01:17:19,860
they are actually getting ordered,

1225
01:17:20,040 --> 01:17:21,690
and one wins and the other one loses,

1226
01:17:21,930 --> 01:17:24,150
that means the other one that lost can run again,

1227
01:17:24,390 --> 01:17:28,590
it will then read Rx1 and then hopefully succeed in the retry.

1228
01:17:29,370 --> 01:17:30,030
Okay?

1229
01:17:32,710 --> 01:17:34,000
Okay, so.

1230
01:17:39,910 --> 01:17:41,800
Okay, let me do one example,

1231
01:17:41,800 --> 01:17:45,760
and then I'll stop and I'll resume on the on the Thursday,

1232
01:17:46,760 --> 01:17:48,500
what time is it 24.

1233
01:17:48,530 --> 01:17:49,910
Let me actually you know stop here,

1234
01:17:50,120 --> 01:17:52,340
and then I'll do second example,

1235
01:17:52,340 --> 01:17:54,620
that answers that earlier question,

1236
01:17:54,740 --> 01:17:59,330
on on Thursday and also talk about fault tolerance,

1237
01:18:00,120 --> 01:18:02,340
I don't want too much over time,

1238
01:18:03,940 --> 01:18:06,520
anybody has to go, please feel free to go,

1239
01:18:06,550 --> 01:18:09,310
and I'll see you in Thursday,

1240
01:18:09,310 --> 01:18:13,030
anybody who asks, like to ask for more questions,

1241
01:18:13,030 --> 01:18:14,590
you know please feel free to stay,

1242
01:18:14,590 --> 01:18:16,540
and I'll try the best to answer them,

1243
01:18:16,990 --> 01:18:19,300
as you see, this is a complicated paper,

1244
01:18:19,570 --> 01:18:22,780
and I'm glad that we're going,

1245
01:18:22,780 --> 01:18:25,090
we're able to go and sort of depth and trying to really understand,

1246
01:18:25,090 --> 01:18:29,060
at least the protocol for normal operation.

1247
01:18:32,490 --> 01:18:34,800
So with that, I just like to finish this lecture,

1248
01:18:34,830 --> 01:18:36,840
and you know see you Thursday day

1249
01:18:36,840 --> 01:18:38,730
or if you have any questions, please hang around.

1250
01:18:40,680 --> 01:18:44,190
I had two like the high-level questions,

1251
01:18:44,190 --> 01:18:50,900
one was this, this whole hardware structure that they are using,

1252
01:18:51,020 --> 01:18:53,000
would it be useful at all,

1253
01:18:53,000 --> 01:18:55,910
if you're using it with pessimistic concurrency control?

1254
01:18:56,680 --> 01:19:00,640
Yes, I'm sure you can make the pessimistic protocol also better,

1255
01:19:00,640 --> 01:19:03,160
because you know RPC are just cheaper, right,

1256
01:19:03,640 --> 01:19:07,180
but the real thing I haven't, I haven't been able to point this out yet,

1257
01:19:07,180 --> 01:19:08,650
but I was trying to,

1258
01:19:08,650 --> 01:19:09,640
what I can do now,

1259
01:19:09,880 --> 01:19:13,060
is if you look at the read-only transactions here,

1260
01:19:13,740 --> 01:19:15,720
so read-only transactions,

1261
01:19:16,350 --> 01:19:20,670
so if here transaction that basically the only reads an object or multiple objects,

1262
01:19:24,920 --> 01:19:26,480
what's the performance, how good is that,

1263
01:19:26,510 --> 01:19:28,070
like how well is that gonna perform?

1264
01:19:30,520 --> 01:19:34,990
Probably pretty well, since you only do the one-sided.

1265
01:19:35,350 --> 01:19:40,900
Yeah, correct, if you look at the object that is stored at region 3, correct,

1266
01:19:40,900 --> 01:19:42,310
which is the object that's being read,

1267
01:19:42,460 --> 01:19:50,090
the only thing that happens is one-sided reads or one-sided RDMA, correct,

1268
01:19:51,410 --> 01:19:56,570
and there's no writes, nothing at all,

1269
01:19:56,630 --> 01:20:01,280
so, those because of the this,

1270
01:20:02,670 --> 01:20:05,220
because the read operation don't require locks,

1271
01:20:05,220 --> 01:20:06,300
there's nothing to be written,

1272
01:20:06,600 --> 01:20:09,690
only thing that needs to happen is this validation step,

1273
01:20:09,720 --> 01:20:11,550
which also is one-sided RDMA,

1274
01:20:11,990 --> 01:20:15,380
so read-only transaction, you can just run with two one-sided RDMAs,

1275
01:20:16,180 --> 01:20:18,850
and that's where the big win comes from

1276
01:20:19,420 --> 01:20:21,790
and the reason that point is there is,

1277
01:20:21,790 --> 01:20:23,800
because of the optimistic concurrency control.

1278
01:20:24,400 --> 01:20:28,480
So I think basically to exploit RDMAs [], []

1279
01:20:28,480 --> 01:20:31,780
and I'm trying to make a read-only transactions really fast,

1280
01:20:32,170 --> 01:20:36,310
they got went to optimistic concurrency control.

1281
01:20:38,390 --> 01:20:40,880
Okay, I see, I see, makes sense.

1282
01:20:41,090 --> 01:20:43,610
Another question was about security,

1283
01:20:43,640 --> 01:20:47,100
is this thing is gonna be secure, if it's,

1284
01:20:48,770 --> 01:20:50,900
I guess, someone already asked about this,

1285
01:20:50,900 --> 01:20:55,300
but the part where the NIC just reads memory,

1286
01:20:55,420 --> 01:20:56,830
it seems a little scary, so.

1287
01:20:56,950 --> 01:20:58,810
Yeah, it's totally scary,

1288
01:20:59,410 --> 01:21:03,250
and so there's there's a bunch of interaction between,

1289
01:21:03,250 --> 01:21:05,530
you know when the RDMA connection is setup

1290
01:21:05,680 --> 01:21:07,570
the operating system and the application,

1291
01:21:09,780 --> 01:21:14,130
so the operating system won't allow the NIC to write to any arbitrary location,

1292
01:21:14,130 --> 01:21:16,410
will tell it, you know here the addresses,

1293
01:21:16,410 --> 01:21:19,830
here's the VM, virtual memory addresses, that you can write to.

1294
01:21:21,230 --> 01:21:24,140
Okay, so you can make that [].

1295
01:21:24,790 --> 01:21:25,090
Okay.

1296
01:21:25,090 --> 01:21:25,510
Exactly.

1297
01:21:26,150 --> 01:21:29,210
Question about the performance,

1298
01:21:29,930 --> 01:21:33,320
so if you have, so the reads are quick,

1299
01:21:33,320 --> 01:21:35,780
because of the one-sided RDMAs,

1300
01:21:36,560 --> 01:21:38,720
but if you have a lot of writes happening,

1301
01:21:38,720 --> 01:21:40,580
like a lot of data and contention.

1302
01:21:40,700 --> 01:21:41,900
Yeah.

1303
01:21:41,900 --> 01:21:43,370
So the case, or.

1304
01:21:43,430 --> 01:21:45,860
No, correct, what happens if you have contention,

1305
01:21:45,980 --> 01:21:48,200
actually we saw this in this particular case, correct,

1306
01:21:49,590 --> 01:21:53,790
yeah, if we have a lot of contention,

1307
01:21:53,790 --> 01:21:55,440
one of the transaction will abort,

1308
01:21:57,310 --> 01:21:59,650
so this is really you know good for transactions,

1309
01:21:59,650 --> 01:22:03,850
that don't content or not writing to the same records or same objects.

1310
01:22:05,200 --> 01:22:06,580
And even the reads, right?

1311
01:22:07,510 --> 01:22:08,380
Yeah, even the reads,

1312
01:22:08,380 --> 01:22:10,030
because the version numbers may change.

1313
01:22:13,200 --> 01:22:16,440
So what's like the main, I guess use case for?

1314
01:22:17,030 --> 01:22:20,690
There's a lot of, you know there's a lot of studies independent of this paper

1315
01:22:20,690 --> 01:22:23,030
about pessimistic versus optimistic concurrency control,

1316
01:22:23,640 --> 01:22:26,910
and you know clearly from the two benchmarks,

1317
01:22:26,910 --> 01:22:29,850
they use in the paper, like TPC-C and TATP,

1318
01:22:30,000 --> 01:22:33,030
there's not a lot of conflicts,

1319
01:22:35,670 --> 01:22:38,700
so this is actually submitted maybe by different users or different clients,

1320
01:22:38,700 --> 01:22:40,320
and they basically touch different [tables].

1321
01:22:45,650 --> 01:22:47,180
So I have a question,

1322
01:22:47,210 --> 01:22:54,550
if there's multiple clients doing transactions on the same object,

1323
01:22:55,170 --> 01:23:00,240
how, so they want to do a write RDMA, write to to the log,

1324
01:23:02,960 --> 01:23:05,480
is it possible that there would be conflict,

1325
01:23:05,480 --> 01:23:08,630
like like one of them will write over the other log, or.

1326
01:23:08,630 --> 01:23:11,180
No no, there's one lock per pair,

1327
01:23:11,860 --> 01:23:13,600
One lock per pair, okay.

1328
01:23:13,630 --> 01:23:15,670
So every this exactly the reason why.

1329
01:23:17,040 --> 01:23:21,600
And and then, but in transactions like time,

1330
01:23:21,630 --> 01:23:25,710
is it like you know to provide serializability,

1331
01:23:26,070 --> 01:23:28,740
is it time based on what?

1332
01:23:29,260 --> 01:23:30,190
On the version number.

1333
01:23:31,940 --> 01:23:34,280
There's nothing like TrueTime or anything like that here,

1334
01:23:34,740 --> 01:23:37,710
these logical numbers, like in same way as in lab 3,

1335
01:23:37,710 --> 01:23:39,840
where you have logical sequence numbers,

1336
01:23:40,670 --> 01:23:42,710
for implementing your key-value store,

1337
01:23:43,460 --> 01:23:45,470
there's numbers basically played the same role.

1338
01:23:53,940 --> 01:23:58,500
Well, if two number of two transactions got the same number,

1339
01:23:58,500 --> 01:24:02,520
then only the one that got to the commit point first is going.

1340
01:24:02,940 --> 01:24:03,780
Yeah, okay.

1341
01:24:04,640 --> 01:24:05,900
Yeah, this is this case, right,

1342
01:24:06,770 --> 01:24:08,570
one abort, the other one succeed.

1343
01:24:11,880 --> 01:24:12,810
Okay.

1344
01:24:13,470 --> 01:24:17,460
If there is a message queue that is basically established between every pair,

1345
01:24:17,730 --> 01:24:19,350
then how do you know,

1346
01:24:19,800 --> 01:24:24,030
so then you have multiple message queues, given primary,

1347
01:24:24,030 --> 01:24:25,830
how do you know which order to read those

1348
01:24:25,830 --> 01:24:28,170
and you don't read them out of order.

1349
01:24:28,650 --> 01:24:35,370
There is, you read all the messages from one source in the same order, correct,

1350
01:24:35,370 --> 01:24:37,500
because they're all gonna be in one queue,

1351
01:24:37,810 --> 01:24:39,520
so one source writes to one queue,

1352
01:24:40,240 --> 01:24:46,450
multiple machines like write you know concurrently to different queues,

1353
01:24:46,690 --> 01:24:48,760
you don't know what the order anyway,

1354
01:24:49,770 --> 01:24:52,830
so it couldn't affect the correctness of the protocol.

1355
01:24:54,270 --> 01:24:58,860
I see, so we don't rely on the orderings of the incoming concurrent messages.

1356
01:24:58,890 --> 01:25:00,900
That's correct, you poll them in some order,

1357
01:25:00,900 --> 01:25:02,730
and then you poll the queues in some order,

1358
01:25:02,730 --> 01:25:05,190
that's the way, that's the way that's going to be processed.

1359
01:25:06,950 --> 01:25:07,490
Got it,

1360
01:25:07,550 --> 01:25:10,130
also one more specific question,

1361
01:25:10,400 --> 01:25:15,380
there's a part where this is a paper, that provides lock lock-free reads,

1362
01:25:15,380 --> 01:25:16,730
which we've just talked about,

1363
01:25:17,090 --> 01:25:21,680
but it also says, it also provides locality hints,

1364
01:25:21,830 --> 01:25:27,290
which enable programmers to co relate related objects on the same set of machines.

1365
01:25:27,320 --> 01:25:27,860
Yeah.

1366
01:25:28,040 --> 01:25:29,510
And I do not understand that,

1367
01:25:29,820 --> 01:25:32,070
the latter part of the sentence.

1368
01:25:32,550 --> 01:25:35,790
Okay, so I I have to look up the details what it is,

1369
01:25:35,790 --> 01:25:37,380
but I think what you're referring to is that,

1370
01:25:37,380 --> 01:25:41,160
if you, like if your objects are all kinds of different regions, correct,

1371
01:25:41,160 --> 01:25:42,870
like, let's look at this picture here,

1372
01:25:43,230 --> 01:25:47,070
then you would have to talk to lots of different primaries, right,

1373
01:25:47,070 --> 01:25:49,680
so if you like object one is in this primary,

1374
01:25:49,710 --> 01:25:51,330
object two is in this primary,

1375
01:25:51,630 --> 01:25:53,550
and if you are touching many,

1376
01:25:53,550 --> 01:25:56,400
if you're touching always a cluster of objects together,

1377
01:25:56,490 --> 01:25:59,310
it would be nice, if that cluster of objects all at the same primary,

1378
01:25:59,910 --> 01:26:02,310
so you only have to contact one primary instead of many.

1379
01:26:05,520 --> 01:26:06,720
I see, thank you.

1380
01:26:13,170 --> 01:26:14,400
Any further questions?

1381
01:26:18,180 --> 01:26:23,940
So this, so FaRM is not really suitable for long transactions, right,

1382
01:26:23,970 --> 01:26:26,220
because because most.

1383
01:26:27,240 --> 01:26:30,150
Yeah, you're worried long of transactions that you get conflicts.

1384
01:26:32,290 --> 01:26:36,910
I mean, it also is assuming, I guess read-only transactions,

1385
01:26:36,910 --> 01:26:39,430
since we're really optimized for them, right.

1386
01:26:39,490 --> 01:26:41,410
Yeah, absolutely,

1387
01:26:41,410 --> 01:26:43,420
many transactions you know people done studies,

1388
01:26:43,420 --> 01:26:45,760
and you know you saw in Spanner paper too, correct,

1389
01:26:46,250 --> 01:26:49,700
where a large fraction of the transactions are read-only transactions,

1390
01:26:53,710 --> 01:26:55,300
but that's clearly property of the workload.

1391
01:27:01,300 --> 01:27:05,240
I had, I think, going back to my earlier question,

1392
01:27:05,240 --> 01:27:11,540
I think I realized, I was misunderstanding [basic] about strict serializability,

1393
01:27:12,950 --> 01:27:15,740
is it, so strict,

1394
01:27:15,740 --> 01:27:17,750
so okay, so here's here's a situation,

1395
01:27:18,350 --> 01:27:21,650
say here's one transaction that begins first,

1396
01:27:21,650 --> 01:27:26,060
that writes shard 1, shard 2 and read shard 3,

1397
01:27:27,700 --> 01:27:29,890
and so that that begins like first time.

1398
01:27:30,010 --> 01:27:32,290
Write object.

1399
01:27:33,100 --> 01:27:34,300
Write 0.

1400
01:27:34,480 --> 01:27:38,470
Write x 0, write y 0.

1401
01:27:38,560 --> 01:27:39,850
And then reads z.

1402
01:27:40,150 --> 01:27:42,400
Okay, reads z0.

1403
01:27:43,180 --> 01:27:49,660
And then say, there's this second transaction that begins after transaction 1 started.

1404
01:27:49,990 --> 01:27:50,980
You know like here?

1405
01:27:51,520 --> 01:27:54,540
Yeah, and it writes z.

1406
01:27:55,670 --> 01:27:57,890
So before before write z,

1407
01:27:57,890 --> 01:27:59,360
it must read z [].

1408
01:27:59,690 --> 01:28:00,710
Yeah.

1409
01:28:00,740 --> 01:28:03,860
And so read z, what version number does it read?

1410
01:28:07,260 --> 01:28:10,410
The same, the same one to.

1411
01:28:10,650 --> 01:28:13,440
And then say reads that tries to write z,

1412
01:28:16,500 --> 01:28:19,980
and then say T2 commits before T1 commits.

1413
01:28:23,860 --> 01:28:25,870
Yes, okay, so this commits yep.

1414
01:28:26,600 --> 01:28:28,940
And then T1 commits after T2 commits.

1415
01:28:28,940 --> 01:28:30,650
We'll try to commit, correct,

1416
01:28:30,830 --> 01:28:35,630
now, we'll start doing this hold lock for validation blah blah blah, correct,

1417
01:28:36,750 --> 01:28:40,440
so before before, so what's gonna happen, correct,

1418
01:28:40,440 --> 01:28:42,360
you know I was going to give you this example,

1419
01:28:42,420 --> 01:28:44,550
this is an example that I'm saying for next lecture,

1420
01:28:44,550 --> 01:28:48,750
but, basically what happened z would be get,

1421
01:28:48,810 --> 01:28:49,950
z will get 1,

1422
01:28:50,970 --> 01:28:54,030
at this point, the z will be a version of 1, correct,

1423
01:28:54,630 --> 01:28:56,730
so the validation phase will run after the commit,

1424
01:28:56,730 --> 01:28:57,540
that's what you said.

1425
01:28:57,990 --> 01:28:58,410
Right.

1426
01:28:58,740 --> 01:29:00,510
And so here's a validation of z,

1427
01:29:01,220 --> 01:29:03,320
and you know it has 0, right,

1428
01:29:03,500 --> 01:29:06,650
and now it's 1 and will transaction will be abort.

1429
01:29:07,130 --> 01:29:09,110
Okay, so this is what I was wondering about that,

1430
01:29:09,110 --> 01:29:13,010
so because after the validation phase passes,

1431
01:29:13,160 --> 01:29:14,600
there was a period of time,

1432
01:29:16,190 --> 01:29:18,740
after the validation phase passes,

1433
01:29:18,740 --> 01:29:20,420
a period of time passes, it commits,

1434
01:29:20,600 --> 01:29:24,140
what if this validation happened before T2 committed,

1435
01:29:24,140 --> 01:29:26,450
so it's still sort of old version number.

1436
01:29:26,950 --> 01:29:28,000
It cannot happen,

1437
01:29:28,000 --> 01:29:30,520
because after the validation,

1438
01:29:30,520 --> 01:29:34,990
after commit, after commit has completed, correct,

1439
01:29:35,470 --> 01:29:38,260
the commit backup you know has recorded

1440
01:29:38,260 --> 01:29:40,870
and the primary have have made the change,

1441
01:29:42,200 --> 01:29:44,240
before the application was returned,

1442
01:29:44,240 --> 01:29:45,590
before the application returns,

1443
01:29:45,590 --> 01:29:46,580
z has been updated.

1444
01:29:51,130 --> 01:29:52,750
Wouldn't, I guess what I'm saying is,

1445
01:29:52,750 --> 01:29:58,120
isn't it possible for T1's validation phase to happen before

1446
01:29:58,450 --> 01:30:00,190
or I guess maybe what I'm trying to say is,

1447
01:30:00,190 --> 01:30:03,580
isn't it possible that T2's commit happens

1448
01:30:03,580 --> 01:30:10,120
between T1's validate, happens after T1 validate before T1's commit?

1449
01:30:13,680 --> 01:30:23,140
Clearly, you know there's a risk and must be excluded, and is executed,

1450
01:30:23,140 --> 01:30:25,480
so okay so you're worried,

1451
01:30:26,340 --> 01:30:27,480
let me construct this case,

1452
01:30:27,480 --> 01:30:28,980
may we'll come back to in next week,

1453
01:30:28,980 --> 01:30:30,420
we're gonna talk it anyway,

1454
01:30:30,450 --> 01:30:32,220
but I think you are worried about it,

1455
01:30:32,460 --> 01:30:33,750
could get the picture back,

1456
01:30:34,110 --> 01:30:36,750
here here's, we did,

1457
01:30:38,530 --> 01:30:42,250
so this guy committed,

1458
01:30:42,520 --> 01:30:44,260
so you basically doing the commit phase,

1459
01:30:44,260 --> 01:30:50,310
this is T1, after T2, actually T2,

1460
01:30:51,290 --> 01:30:55,610
so T2 is about doing is here, right,

1461
01:30:56,060 --> 01:31:02,090
then T1 is coming in before everything happens,

1462
01:31:02,120 --> 01:31:03,500
before the T2 is finished, correct.

1463
01:31:04,480 --> 01:31:05,080
Right.

1464
01:31:05,810 --> 01:31:08,480
So like T1 validation also comes in here,

1465
01:31:09,110 --> 01:31:09,980
so maybe,

1466
01:31:09,980 --> 01:31:11,000
okay, let me rewrite it,

1467
01:31:11,000 --> 01:31:11,750
and I'll get back to you.

1468
01:31:11,750 --> 01:31:13,190
Okay.

1469
01:31:13,670 --> 01:31:15,350
Exactly what I wanted to talk about.

1470
01:31:15,650 --> 01:31:16,850
Okay, okay, thank you.

1471
01:31:18,140 --> 01:31:19,010
So just make sure,

1472
01:31:19,010 --> 01:31:23,300
you're asking about T2 being like in between stage two and three of T1?

1473
01:31:23,300 --> 01:31:24,650
Yeah.

1474
01:31:26,880 --> 01:31:27,870
But in that case,

1475
01:31:27,870 --> 01:31:33,030
then T2, we could, we could serialize it as T2 coming before T1, right.

1476
01:31:33,300 --> 01:31:33,690
Yep.

1477
01:31:35,550 --> 01:31:38,880
So, let's, let's get, let's get back to this on Thursday,

1478
01:31:39,330 --> 01:31:42,600
I have an example for that exactly was going to go over top of this.

1479
01:31:46,330 --> 01:31:52,540
Sorry, in the validation stage, you just read, read the version number?

1480
01:31:53,480 --> 01:31:53,750
Yeah.

1481
01:31:53,750 --> 01:31:54,140
Okay.

1482
01:31:58,180 --> 01:32:01,900
And serializability allows us to reorder transactions.

1483
01:32:01,930 --> 01:32:03,910
Yeah, but strict serializability will not, correct,

1484
01:32:04,060 --> 01:32:07,480
if, if transaction, strict serializability requires that,

1485
01:32:07,480 --> 01:32:10,180
if transaction actually starts, somebody, after somebody committed,

1486
01:32:10,330 --> 01:32:12,550
that transaction is also committed after that transaction.

1487
01:32:14,200 --> 01:32:14,560
Right.

1488
01:32:14,560 --> 01:32:16,420
Which is protocol guarantee,

1489
01:32:16,420 --> 01:32:18,600
because of the, the version number.

1490
01:32:19,830 --> 01:32:20,790
Got it, thank you.

1491
01:32:21,980 --> 01:32:24,110
But strict serializability doesn't,

1492
01:32:24,650 --> 01:32:26,360
if I get T2 ends,

1493
01:32:27,000 --> 01:32:31,830
it's not refer T1 the end after T2 ends,

1494
01:32:32,400 --> 01:32:34,590
T1 have had to have started,

1495
01:32:34,620 --> 01:32:36,510
or maybe I need to think about this,

1496
01:32:36,510 --> 01:32:38,790
but I think this is always tripping me out,

1497
01:32:38,790 --> 01:32:42,600
this like there's also a rule about when the transaction starts.

1498
01:32:42,600 --> 01:32:45,870
Yeah, well, well what happens in real life,

1499
01:32:45,870 --> 01:32:48,180
exactly starts from some particular point of time,

1500
01:32:48,180 --> 01:32:53,940
and basically if T1, if T2 starts after T1 commits.

1501
01:32:56,250 --> 01:32:56,610
Right.

1502
01:32:56,700 --> 01:32:58,830
So and so then it must be the case,

1503
01:32:58,830 --> 01:33:02,520
that T2 observes you know T2 T1 changes,

1504
01:33:02,550 --> 01:33:03,870
that's strict serializability.

1505
01:33:04,700 --> 01:33:05,240
Right.

1506
01:33:05,790 --> 01:33:09,930
But what happened T2 starts and commits [] within?

1507
01:33:10,170 --> 01:33:12,570
Then concurrent transaction and either outcome is fine.

1508
01:33:12,870 --> 01:33:13,380
Okay.

1509
01:33:13,590 --> 01:33:17,730
Is that answer your question?

1510
01:33:17,730 --> 01:33:19,200
Yeah, I think that I confused, so.

1511
01:33:19,410 --> 01:33:24,450
When they literally, when T2 starts before T1 commits,

1512
01:33:24,570 --> 01:33:26,160
it's considered the concurrent transaction,

1513
01:33:27,200 --> 01:33:30,380
and so T1 or you know T2 can observe either,

1514
01:33:30,380 --> 01:33:32,780
can be ordered before either after, doesn't matter.

1515
01:33:32,990 --> 01:33:34,250
Okay, okay.

1516
01:33:34,810 --> 01:33:35,830
Okay, thank you.

1517
01:33:35,830 --> 01:33:37,930
I think there's also the answer to your example.

1518
01:33:38,170 --> 01:33:40,240
Right, okay, thank you.

1519
01:33:40,270 --> 01:33:42,520
Okay, we have we got it anyway already.

1520
01:33:44,230 --> 01:33:50,650
You're say if T2 started like between the T1 start and commit, right, like.

1521
01:33:50,680 --> 01:33:53,560
Yeah, you know, can be go for or after, it doesn't matter.

1522
01:33:56,010 --> 01:33:58,170
Can I ask a logistics question,

1523
01:33:58,230 --> 01:34:04,350
I remember in 6.S081, you post these slides too.

1524
01:34:05,160 --> 01:34:08,250
Yes, I, yeah, yeah I didn't do that here,

1525
01:34:08,700 --> 01:34:10,800
would you like to be on the website?

1526
01:34:11,290 --> 01:34:12,520
I think slides are useful,

1527
01:34:12,520 --> 01:34:15,790
if if you just need to look at this slides,

1528
01:34:15,790 --> 01:34:17,950
you need to scroll through the video.

1529
01:34:18,040 --> 01:34:22,420
Okay, you're first asking, why I haven't done it,

1530
01:34:23,080 --> 01:34:25,570
yeah, I'm happy to do it,

1531
01:34:25,570 --> 01:34:27,820
I I do save them all.

1532
01:34:29,690 --> 01:34:30,680
Thank you so much,

1533
01:34:30,710 --> 01:34:33,140
thank you for those fun lecture things.

1534
01:34:33,700 --> 01:34:34,300
You're welcome.

