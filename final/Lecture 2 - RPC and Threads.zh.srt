1
00:00:02,060 --> 00:00:07,100
好的，今天的主题是线程和 RPC ，

2
00:00:07,700 --> 00:00:10,460
6.824 第二讲，

3
00:00:10,550 --> 00:00:14,360
我们将主要关注 Go 的线程和 RPC ，

4
00:00:14,880 --> 00:00:18,570
我们在实验中使用的编程语言，

5
00:00:18,630 --> 00:00:21,900
这节课的大部分内容都是量身定做的，

6
00:00:21,900 --> 00:00:27,060
帮助你了解实验用的 Go 编程，

7
00:00:27,960 --> 00:00:33,870
希望你完成了入门教程和爬虫练习，

8
00:00:33,870 --> 00:00:37,170
我们将在稍后的课程中详细讨论它们，

9
00:00:37,410 --> 00:00:39,510
但在讨论细节之前，

10
00:00:39,510 --> 00:00:41,940
让我用更多的代码调用，

11
00:00:41,970 --> 00:00:44,670
来打破[]并让大家提问。

12
00:00:45,200 --> 00:00:47,630
也许你可以回答这个问题，

13
00:00:47,630 --> 00:00:50,420
你在哪里，你觉得这个教程怎么样，

14
00:00:50,420 --> 00:00:52,880
你对 Go 的第一印象是什么，

15
00:00:53,330 --> 00:00:54,740
也许我会。

16
00:00:54,770 --> 00:00:56,870
Evan Feldman 你觉得怎么样？

17
00:00:59,940 --> 00:01:02,550
大家好，我是 Batman ，

18
00:01:02,550 --> 00:01:06,270
我在 Newton ，在大波士顿的郊区，

19
00:01:06,600 --> 00:01:08,190
这个教程很有趣，

20
00:01:08,190 --> 00:01:12,240
这是我第一次接触到面向对象的语言，

21
00:01:12,300 --> 00:01:15,840
所以，这是一种框架的改变，

22
00:01:15,840 --> 00:01:18,030
适应这一点很有趣。

23
00:01:19,290 --> 00:01:21,990
好的，Brendan Wall 怎么样？

24
00:01:28,390 --> 00:01:29,680
Brendan ，你在吗？

25
00:01:30,530 --> 00:01:32,210
是的，我只是在找取消静音按钮，

26
00:01:32,360 --> 00:01:33,860
抱歉，问题是什么，我刚加入。

27
00:01:34,190 --> 00:01:38,000
你在哪里，你对 Go 的第一印象是什么？

28
00:01:38,000 --> 00:01:40,910
是的，我以前在实习中用过 Go ，

29
00:01:40,910 --> 00:01:43,700
那是我第一次处理并发的东西，

30
00:01:43,730 --> 00:01:45,500
我喜欢 Go ，使用 goroutine 来工作，

31
00:01:45,500 --> 00:01:51,010
一开始很难想清楚，

32
00:01:51,310 --> 00:01:54,340
比如主线程和所有的 goroutine 一起结束，

33
00:01:54,340 --> 00:01:57,610
解决早期的一些概念问题，

34
00:01:57,610 --> 00:01:58,720
但这很有趣。

35
00:02:00,670 --> 00:02:02,140
[Connor Prisby] 怎么样？

36
00:02:13,170 --> 00:02:14,250
[Connor]，你在吗？

37
00:02:19,120 --> 00:02:23,050
好的，试试其他人， Dory Shen 。

38
00:02:27,120 --> 00:02:29,640
嗨，我现在在剑桥，

39
00:02:29,640 --> 00:02:32,520
我发现 Go 非常有趣，

40
00:02:32,520 --> 00:02:35,280
我把教程的第一部分看了一遍，

41
00:02:35,280 --> 00:02:39,030
比如我学习了 for 循环，以及它们 for 循环的方式，

42
00:02:39,060 --> 00:02:40,500
我觉得这很有趣，

43
00:02:40,500 --> 00:02:42,450
比如它的组成方式，

44
00:02:42,480 --> 00:02:45,990
我想比如线程，

45
00:02:45,990 --> 00:02:49,770
我发现它有点难，

46
00:02:49,770 --> 00:02:50,700
当它结束时，

47
00:02:50,700 --> 00:02:54,900
比如有时函数会在所有例程之前结束，

48
00:02:54,900 --> 00:02:55,500
[比如结束]，

49
00:02:55,500 --> 00:02:58,230
所以这想起来很有趣，

50
00:02:58,230 --> 00:02:59,430
我学到的更多，

51
00:02:59,430 --> 00:03:00,630
所以这很酷，我喜欢它。

52
00:03:01,200 --> 00:03:08,160
好的，希望你们在这学期都会有一个好的 Go 的体验。

53
00:03:08,460 --> 00:03:13,320
让我说一下为什么使用 Go 吗？

54
00:03:14,210 --> 00:03:17,150
理论上，有很多编程语言，

55
00:03:17,150 --> 00:03:19,550
可以用来做分布式编程，

56
00:03:19,550 --> 00:03:21,320
Go 绝对不是唯一一个，

57
00:03:21,740 --> 00:03:26,000
但我们在 6.824 中选择 Go 有一些原因。

58
00:03:26,180 --> 00:03:32,060
首先，它对线程和 RPC 有很好的支持，

59
00:03:33,590 --> 00:03:37,970
这两点对于分布式编程非常重要，

60
00:03:38,360 --> 00:03:40,850
所以这是有道理的，

61
00:03:40,850 --> 00:03:42,560
Go 与这个很匹配。

62
00:03:43,010 --> 00:03:44,570
我们非常喜欢它的第二个原因是，

63
00:03:44,570 --> 00:03:46,160
它有一个垃圾收集器，

64
00:03:46,220 --> 00:03:49,010
如果你做共享内存式的并发，

65
00:03:49,010 --> 00:03:53,810
多个线程共享一个结构体或变量，

66
00:03:53,810 --> 00:03:56,150
那么有垃圾收集器是很好的，

67
00:03:56,150 --> 00:03:57,770
因为这样线程就不用考虑，

68
00:03:57,770 --> 00:04:01,460
谁是最后一个引用了这个内存的线程，

69
00:04:01,460 --> 00:04:03,230
因此应该重新分配，

70
00:04:03,320 --> 00:04:06,440
垃圾收集器负责处理所有这些问题，

71
00:04:06,980 --> 00:04:07,790
这很方便。

72
00:04:08,450 --> 00:04:10,250
它是类型安全的。

73
00:04:14,420 --> 00:04:18,440
它很简单，是一种简单的编程语言，

74
00:04:18,470 --> 00:04:19,940
学起来很容易。

75
00:04:19,940 --> 00:04:21,320
这些想法，

76
00:04:21,380 --> 00:04:23,660
希望你在 Go 教程中感受到了，

77
00:04:23,660 --> 00:04:25,160
你完成了 Go 教程，

78
00:04:25,160 --> 00:04:26,690
你就知道了 Go 的大部分。

79
00:04:27,440 --> 00:04:30,620
最后，它有一个编译器，

80
00:04:30,620 --> 00:04:31,520
所以它是编译的，

81
00:04:32,200 --> 00:04:34,450
与 Python 不同，

82
00:04:34,480 --> 00:04:38,650
或者编译器产生可用的代码，

83
00:04:38,650 --> 00:04:41,170
所以运行时开销不是很大。

84
00:04:41,980 --> 00:04:46,870
我想 6.824 使用 Go 的最后一个原因，

85
00:04:46,870 --> 00:04:50,110
我很喜欢使用 Go 写程序，

86
00:04:50,110 --> 00:04:52,510
这可能也是一个重要原因。

87
00:04:54,140 --> 00:04:56,180
所以我要做的是，

88
00:04:56,180 --> 00:04:59,390
我将简单介绍一下线程和 RPC ，

89
00:04:59,540 --> 00:05:05,240
讨论一下使用线程编程的不同方面，

90
00:05:05,570 --> 00:05:07,430
其中一些是很好的教程，

91
00:05:07,460 --> 00:05:11,720
你在我[抱歉]之前见过的，

92
00:05:11,720 --> 00:05:13,790
我会很快介绍它，

93
00:05:13,820 --> 00:05:17,300
它不是对并发编程的全面介绍，

94
00:05:17,570 --> 00:05:19,760
但希望可以提醒你，

95
00:05:19,760 --> 00:05:22,160
问题是什么，以及你应该注意的是什么。

96
00:05:22,560 --> 00:05:25,740
我们还会花一些时间讨论一下爬虫。

97
00:05:26,520 --> 00:05:29,460
所以我向你们分享一个解决方案，

98
00:05:29,460 --> 00:05:30,600
我有两个解决方案，

99
00:05:30,600 --> 00:05:33,240
一个使用 channel ，另一个使用 mutex ，

100
00:05:33,360 --> 00:05:34,530
我们会把它们都看一下。

101
00:05:36,140 --> 00:05:38,540
在我开始之前，有什么问题吗？

102
00:05:44,920 --> 00:05:47,500
好的，我们从线程开始，

103
00:05:50,050 --> 00:05:53,140
线程是执行线程的简写，

104
00:05:57,360 --> 00:06:01,440
在 Go 中，线程称为 goroutine ，

105
00:06:01,440 --> 00:06:05,550
但是在 Go 的世界中，人们还称它为线程的线程，

106
00:06:06,270 --> 00:06:07,830
所以，考虑这个问题的方法是，

107
00:06:07,830 --> 00:06:10,500
当你使用 go run 时，

108
00:06:10,500 --> 00:06:14,910
Go 在你的操作系统上创建一个进程，

109
00:06:15,480 --> 00:06:18,690
在这个进程中，是 Go 运行时系统，

110
00:06:19,860 --> 00:06:21,030
当 Go 开始的时候，

111
00:06:21,030 --> 00:06:23,490
它只有一个执行线程，即主线程，

112
00:06:23,790 --> 00:06:26,580
但是它有用于创建新线程的原语，

113
00:06:26,580 --> 00:06:27,660
所以你可以这样想，

114
00:06:27,660 --> 00:06:32,160
这里有很多执行的线程并行运行。

115
00:06:32,460 --> 00:06:36,360
你可以认为单线程是一种顺序程序行，

116
00:06:36,920 --> 00:06:39,620
程序有一个程序计数器，

117
00:06:40,100 --> 00:06:41,510
有自己的栈，

118
00:06:42,180 --> 00:06:44,190
并且有自己的一套寄存器，

119
00:06:47,920 --> 00:06:49,990
所以这就像一个顺序程序，

120
00:06:50,320 --> 00:06:54,670
你可以执行指令一和指令二，以及指令三和指令四，

121
00:06:54,670 --> 00:06:57,520
可能让过程调用在栈上分配内存，

122
00:06:57,520 --> 00:07:01,090
从过程调用、递归调用返回，

123
00:07:01,120 --> 00:07:03,490
所有标准顺序编程，

124
00:07:03,490 --> 00:07:06,280
就像一个顺序线程。

125
00:07:07,980 --> 00:07:10,110
有趣的是，

126
00:07:10,110 --> 00:07:14,070
这些线程可能与其他线程共享内存，

127
00:07:15,940 --> 00:07:20,260
因为所有线程都在相同的地址空间中运行，

128
00:07:20,350 --> 00:07:22,600
相同的操作系统地址空间，

129
00:07:22,810 --> 00:07:24,610
是相同的进程地址空间，

130
00:07:24,790 --> 00:07:27,520
它们可以共享内存，

131
00:07:27,520 --> 00:07:31,270
所以，比如一个线程可以写位置 10 ，

132
00:07:31,480 --> 00:07:33,820
然后其他线程可以读取位置 10 ，

133
00:07:34,000 --> 00:07:36,460
这样它们可以交流信息。

134
00:07:37,390 --> 00:07:41,500
另一种考虑线程的方式是，

135
00:07:41,500 --> 00:07:46,540
将其视为运行库支持的某种抽象，

136
00:07:46,540 --> 00:07:48,970
运行时在线程上执行多个操作，

137
00:07:48,970 --> 00:07:52,480
一个操作，我们已经看过很多次了，

138
00:07:52,480 --> 00:07:55,450
你已经看到过多次，来创建线程，

139
00:07:55,450 --> 00:07:59,950
这就是 go 语法， go 关键字。

140
00:08:00,580 --> 00:08:01,930
线程可以退出，

141
00:08:03,310 --> 00:08:06,130
通常退出是隐式的，

142
00:08:06,130 --> 00:08:09,160
比如当一个线程从这里返回时，

143
00:08:09,160 --> 00:08:15,100
如果你使用 go 关键字创建一个函数，

144
00:08:15,100 --> 00:08:16,840
从函数中返回时，

145
00:08:16,840 --> 00:08:19,180
那么这个线程就隐式退出了。

146
00:08:19,720 --> 00:08:24,190
Go 运行时还有几个高级操作，

147
00:08:24,190 --> 00:08:26,800
如果你愿意，它可以停止一个线程，

148
00:08:27,580 --> 00:08:30,700
比如，如果线程向 channel 写入数据，

149
00:08:30,700 --> 00:08:32,740
而这个 channel 上没有读取者，

150
00:08:32,740 --> 00:08:34,780
那么这个线程可能会被阻塞，

151
00:08:35,020 --> 00:08:37,330
所以 Go 运行时停止这个线程，

152
00:08:37,360 --> 00:08:38,590
把它放在一边，

153
00:08:38,980 --> 00:08:42,820
这样可以在处理器上运行另一个线程，

154
00:08:42,820 --> 00:08:45,220
也许稍后会恢复那个线程。

155
00:08:45,220 --> 00:08:49,480
所以，第三个原语是 resume 线程。

156
00:08:50,110 --> 00:08:51,970
而 stop resume 线程的真正含义是，

157
00:08:51,970 --> 00:08:53,530
获取线程的状态，

158
00:08:53,530 --> 00:08:56,770
比如程序计数器，栈指针和寄存器，

159
00:08:56,770 --> 00:09:00,700
把它放在一边，在处理器上运行另一个线程，

160
00:09:00,970 --> 00:09:03,520
然后在某个时刻，决定恢复处理器，

161
00:09:03,520 --> 00:09:08,020
也就是把程序计数器，栈指针和寄存器加载回处理器，

162
00:09:08,020 --> 00:09:09,160
让它开始运行。

163
00:09:10,260 --> 00:09:14,520
这是对线程的一种非常[机械的]看法。

164
00:09:19,180 --> 00:09:20,770
那么为什么要有线程，

165
00:09:20,770 --> 00:09:24,220
这是一个值得讨论的重要问题。

166
00:09:28,110 --> 00:09:29,040
因为在某些情况下，

167
00:09:29,040 --> 00:09:30,840
线程唯一能做的是，

168
00:09:30,840 --> 00:09:32,760
让你作为程序员的生活变得更加复杂，

169
00:09:33,660 --> 00:09:37,110
比如编写顺序代码比编写并行代码更容易。

170
00:09:37,530 --> 00:09:38,940
有它的主要原因是，

171
00:09:39,500 --> 00:09:45,750
在 6.824 中，我们非常关心的主要原因是表示并发性，

172
00:09:49,890 --> 00:09:53,790
有两三种不同类型的并发性，

173
00:09:53,790 --> 00:09:54,720
是我们关心的，

174
00:09:54,720 --> 00:09:57,210
所以，考虑我们的进程，

175
00:09:57,210 --> 00:10:00,060
我们有运行时运行线程。

176
00:10:00,560 --> 00:10:04,460
我们非常关心的一种并发类型是 IO 并发，

177
00:10:08,740 --> 00:10:11,290
所以有一个线程在这里运行，

178
00:10:11,380 --> 00:10:13,030
它可能在做一个网络调用，

179
00:10:13,390 --> 00:10:15,820
通过网络连接到另一台机器，

180
00:10:16,120 --> 00:10:19,870
为了实现分布式应用程序，比如 mapreduce ，

181
00:10:20,080 --> 00:10:23,740
当它发起一个调用，

182
00:10:23,740 --> 00:10:26,050
它会被阻塞，等待回复，

183
00:10:26,080 --> 00:10:28,330
当它被阻塞，等待回复时，

184
00:10:28,480 --> 00:10:30,880
你需要的是运行一些其他线程。

185
00:10:31,340 --> 00:10:34,100
所以我们[]更多，

186
00:10:34,100 --> 00:10:34,610
我们运行，

187
00:10:34,610 --> 00:10:36,740
比如我们要发出多个请求，

188
00:10:36,740 --> 00:10:39,890
多台机器大致并行，

189
00:10:39,890 --> 00:10:42,560
我们可以发起一个 goroutine 去做，

190
00:10:42,560 --> 00:10:44,570
发起另一个 goroutine ，另一个 goroutine ，

191
00:10:44,570 --> 00:10:47,720
所有发送，连接到其他远程机器上。

192
00:10:48,810 --> 00:10:52,230
这是我们非常关心它的原因之一， IO 并发性。

193
00:10:52,230 --> 00:10:54,000
我们关心的第二个原因是，

194
00:10:54,000 --> 00:10:56,130
允许多核并行。

195
00:11:03,310 --> 00:11:05,530
所以我们有多个核心，

196
00:11:05,530 --> 00:11:09,100
计算机或处理器，

197
00:11:09,190 --> 00:11:11,980
然后我们让一个线程运行，

198
00:11:11,980 --> 00:11:13,900
一个 goroutine 运行在一个核心上，

199
00:11:14,020 --> 00:11:16,690
另一个线程或另一个 goroutine 运行在另一个核心上，

200
00:11:16,690 --> 00:11:17,950
直接并行。

201
00:11:18,440 --> 00:11:21,110
比如，我们实现了键值服务器，

202
00:11:21,110 --> 00:11:24,230
然后我们可以处理不同键的请求，

203
00:11:24,230 --> 00:11:27,260
键值服务使用不同的核心并发，

204
00:11:27,260 --> 00:11:29,510
增加我们的吞吐量。

205
00:11:30,440 --> 00:11:34,730
所以这是我们非常关心并发性的两个主要原因，

206
00:11:35,180 --> 00:11:37,670
但是线程，还有第三个原因，

207
00:11:37,670 --> 00:11:39,470
就是比较方便。

208
00:11:43,840 --> 00:11:45,550
实验里会有很多案例，

209
00:11:45,550 --> 00:11:49,660
比如，我们希望定期执行一些事情，

210
00:11:49,720 --> 00:11:52,390
可能每隔一秒或每隔 200 毫秒，

211
00:11:52,450 --> 00:11:55,630
现在我们可以为它启动一个线程或 goroutine ，

212
00:11:55,630 --> 00:11:57,370
有 200 毫秒的睡眠时间，

213
00:11:57,370 --> 00:11:58,510
做它需要做的事情，

214
00:11:58,510 --> 00:12:00,790
然后它回到睡眠状态 200 毫秒，

215
00:12:01,060 --> 00:12:04,870
所以执行这些后台活动是很方便的，

216
00:12:04,870 --> 00:12:06,310
需要定期完成的，

217
00:12:06,310 --> 00:12:08,200
你可以用线程来做，

218
00:12:08,200 --> 00:12:09,550
当然你可以用其他方式，

219
00:12:09,550 --> 00:12:11,440
但线程是很方便的。

220
00:12:13,200 --> 00:12:15,540
另一个经常出现的问题是，

221
00:12:15,540 --> 00:12:17,610
在一些讲座中出现的问题，

222
00:12:17,610 --> 00:12:19,530
你可以创建多少线程。

223
00:12:20,100 --> 00:12:23,550
我认为 Go 设计者想要你考虑的是，

224
00:12:23,550 --> 00:12:25,380
你应该根据需要创建尽可能多的线程，

225
00:12:25,530 --> 00:12:27,540
它们肯定不是免费的，

226
00:12:27,570 --> 00:12:28,980
它们会占用一些内存，

227
00:12:28,980 --> 00:12:30,510
因为你会有栈，

228
00:12:30,840 --> 00:12:33,450
这会带来性能开销，我们启动它们时，

229
00:12:33,690 --> 00:12:36,480
但你应该认为它们非常轻，

230
00:12:36,570 --> 00:12:41,430
你也被鼓励应该按需创建线程。

231
00:12:43,640 --> 00:12:48,080
关于为什么要有线程的基本原因，有什么问题吗？

232
00:12:55,060 --> 00:12:55,720
好的，让我，

233
00:12:55,720 --> 00:12:59,170
就像我之前提到的，

234
00:12:59,200 --> 00:13:00,790
线程面临着挑战，

235
00:13:03,350 --> 00:13:05,150
使用线程进行编程具有挑战，

236
00:13:05,270 --> 00:13:07,070
所以，让我来谈谈这些挑战。

237
00:13:07,780 --> 00:13:10,210
我不打算在这里深入探讨，

238
00:13:10,210 --> 00:13:13,180
我希望它们是能理解的，

239
00:13:13,180 --> 00:13:16,000
如果我们看一些例子，就会变得更清楚。

240
00:13:16,570 --> 00:13:21,520
可能线程具有挑战性的主要原因是，

241
00:13:21,520 --> 00:13:22,660
你会有竞态条件。

242
00:13:30,890 --> 00:13:33,860
比如一个基本的竞态条件，

243
00:13:33,860 --> 00:13:35,300
假设你有两个线程，

244
00:13:35,300 --> 00:13:38,610
这是 t1 ，这是 t2 ，

245
00:13:39,240 --> 00:13:41,880
它们共享变量 n ，

246
00:13:41,910 --> 00:13:43,950
假设初始值为 0 ，

247
00:13:45,390 --> 00:13:47,190
它们都执行，

248
00:13:47,220 --> 00:13:52,080
都执行 n = n + 1 的语句，

249
00:13:53,020 --> 00:13:55,720
当然，你可能会认为这个语句是原子操作，

250
00:13:55,720 --> 00:13:57,310
或者是不可分割的，

251
00:13:57,310 --> 00:13:57,880
但事实并非如此，

252
00:13:57,940 --> 00:14:00,970
Go 语句会编译成，

253
00:14:00,970 --> 00:14:03,640
处理器正在执行的指令，

254
00:14:04,030 --> 00:14:06,310
所以我们不能假设这是原子指令，

255
00:14:06,310 --> 00:14:08,320
实际上它是，

256
00:14:08,470 --> 00:14:10,720
它可能包含一个 load ，

257
00:14:10,750 --> 00:14:15,190
将 n 的内容存入寄存器，

258
00:14:15,190 --> 00:14:16,180
然后递增寄存器，

259
00:14:16,180 --> 00:14:18,220
然后，将寄存器取回到内存。

260
00:14:19,220 --> 00:14:20,810
所以如果你非常不走运，

261
00:14:20,900 --> 00:14:22,760
这两个线程都试图，

262
00:14:22,760 --> 00:14:25,310
执行这条特定的指令，

263
00:14:25,490 --> 00:14:28,640
然后我们会有一个糟糕的事件序列，

264
00:14:28,640 --> 00:14:32,470
其中，两个线程都执行 load 指令，

265
00:14:34,380 --> 00:14:38,580
加载变量到寄存器 r0 中，

266
00:14:38,670 --> 00:14:40,560
这边也在 r0 中，

267
00:14:42,570 --> 00:14:47,450
然后增量，所以 r0 变成 1 1 ，

268
00:14:47,990 --> 00:14:52,250
然后使用 store 指令把它写回，

269
00:14:52,250 --> 00:14:56,120
把结果写回到内存中的变量 n 中。

270
00:14:56,960 --> 00:15:00,890
所以，如果在这种情况下，

271
00:15:00,920 --> 00:15:03,980
在这种场景下，是真正并行的，

272
00:15:04,130 --> 00:15:07,850
那么在这两个线程都递增之后， n 的值是多少。

273
00:15:11,450 --> 00:15:12,170
是 1 。

274
00:15:12,710 --> 00:15:13,400
是的， 1 ，

275
00:15:13,670 --> 00:15:16,130
这个值应该是什么，

276
00:15:16,130 --> 00:15:17,540
我们期望它是什么。

277
00:15:22,260 --> 00:15:22,650
2.

278
00:15:22,920 --> 00:15:24,240
是的，希望它是 2 ，

279
00:15:24,240 --> 00:15:27,450
所以， 1 肯定不等于 2 ，这里有一个错误。

280
00:15:28,400 --> 00:15:32,630
所以，这就是竞态条件的核心，

281
00:15:32,720 --> 00:15:38,060
如果线程是糟糕的事件队列，

282
00:15:38,060 --> 00:15:40,100
线程共享状态，

283
00:15:40,460 --> 00:15:43,370
更新可能会没有正确反映出来，

284
00:15:44,120 --> 00:15:46,040
当然，大多数情况下，这都会正常工作，

285
00:15:46,040 --> 00:15:49,190
因为你必须处于这个非常，

286
00:15:49,430 --> 00:15:51,470
处于这个非常特殊的条件，

287
00:15:51,470 --> 00:15:52,430
在它出现之前。

288
00:15:53,120 --> 00:15:55,580
通常情况下，你们中有人报告说，

289
00:15:55,580 --> 00:15:58,280
我没有对我的竞态条件加锁，

290
00:15:58,280 --> 00:16:00,440
我一直查着顺序，

291
00:16:00,620 --> 00:16:02,480
我的程序运行得很好，

292
00:16:02,600 --> 00:16:05,690
这就是竞态条件的真正问题所在，

293
00:16:05,690 --> 00:16:06,890
它们通常工作得很好，

294
00:16:06,890 --> 00:16:08,360
但有时会出错。

295
00:16:09,620 --> 00:16:13,040
所以，有两种方法可以解决竞态条件。

296
00:16:13,430 --> 00:16:15,380
第一种方法是避免分享，

297
00:16:17,720 --> 00:16:18,800
不要共享变量。

298
00:16:20,720 --> 00:16:23,900
这是一种 Go 鼓励的编程风格，

299
00:16:23,900 --> 00:16:25,040
通过使用通道，

300
00:16:25,100 --> 00:16:26,900
通道用来通信值，

301
00:16:26,900 --> 00:16:28,520
但你并不需要直接共享内存，

302
00:16:28,940 --> 00:16:31,280
所以这是一种方法。

303
00:16:31,670 --> 00:16:33,590
所以避免共享一种方法，

304
00:16:33,590 --> 00:16:35,510
另一种方法是使用锁，

305
00:16:38,640 --> 00:16:42,150
让一系列指令变为原子操作，

306
00:16:42,330 --> 00:16:44,400
稍后我们会更详细地讨论这个。

307
00:16:45,040 --> 00:16:46,750
我想指出的一点是，

308
00:16:46,750 --> 00:16:47,740
这真的很酷，

309
00:16:47,740 --> 00:16:49,450
一个实用的工具，

310
00:16:49,660 --> 00:16:51,520
Go 其实有一个竞态检测器，

311
00:16:52,760 --> 00:16:55,520
你将要做的大多数实验，

312
00:16:55,520 --> 00:16:59,420
推荐你运行 Go 使用 -race 标志，

313
00:16:59,570 --> 00:17:03,680
这虽然不能捕捉所有可能的竞争，

314
00:17:03,680 --> 00:17:06,680
但它在识别竞争方面做得非常好，

315
00:17:07,430 --> 00:17:11,510
所以，默认情况下，你应该在启用竞争检测器的情况下运行 Go 。

316
00:17:13,180 --> 00:17:15,400
好的，这是一个关于线程的挑战。

317
00:17:15,400 --> 00:17:17,590
第二个关于线程的挑战是协调。

318
00:17:19,640 --> 00:17:22,490
它通常情况下是，

319
00:17:22,610 --> 00:17:24,440
一个线程必须等待另一个线程，

320
00:17:24,440 --> 00:17:26,030
在完成某件事之前，

321
00:17:26,450 --> 00:17:31,610
教程中的很多 Go 练习有这种形式，

322
00:17:31,820 --> 00:17:34,490
有两种方式， Go 有两个原语，

323
00:17:34,490 --> 00:17:36,650
处理它的一个是通道，

324
00:17:37,550 --> 00:17:41,570
通道允许你同时通信和协调，

325
00:17:42,140 --> 00:17:47,270
或者，我们稍后会讨论条件变量，

326
00:17:53,640 --> 00:17:54,840
两者都很有用，

327
00:17:54,870 --> 00:17:56,250
我会更多地谈到这一点。

328
00:17:56,520 --> 00:17:59,400
最后的挑战是，

329
00:17:59,730 --> 00:18:03,930
一个大的挑战是死锁，

330
00:18:05,620 --> 00:18:06,670
所以，如果一个线程等待，

331
00:18:06,670 --> 00:18:10,780
比如 t1 等待 t2 ，而 t2 等待 t1 ，

332
00:18:10,780 --> 00:18:14,050
比如在其他程序之前，释放你的锁，

333
00:18:14,050 --> 00:18:16,330
它们称为死锁，

334
00:18:16,540 --> 00:18:18,700
双方都在等待对方，

335
00:18:18,700 --> 00:18:20,980
结果是什么都没有取得进展。

336
00:18:23,440 --> 00:18:27,160
一种微不足道的 Go 的死锁方式是，

337
00:18:27,160 --> 00:18:28,480
比如你只有一个线程，

338
00:18:28,540 --> 00:18:29,920
根本就没有其他线程，

339
00:18:30,310 --> 00:18:32,560
而你在写入通道，

340
00:18:35,200 --> 00:18:37,150
这会阻塞那个线程，

341
00:18:37,150 --> 00:18:40,090
直到其他人从通道中读取，

342
00:18:40,090 --> 00:18:41,770
但如果根本没有其他线程，

343
00:18:41,770 --> 00:18:43,330
这会导致死锁，

344
00:18:43,990 --> 00:18:46,390
就是最简单的可能的死锁，

345
00:18:46,960 --> 00:18:50,740
Go 会抓住这种情况，

346
00:18:50,740 --> 00:18:52,870
抛出运行时错误，

347
00:18:52,870 --> 00:18:55,450
表示没有线程可以运行，你有一个死锁。

348
00:18:56,210 --> 00:18:59,930
但是如果涉及多个线程，可能会出现更复杂的死锁，

349
00:19:00,350 --> 00:19:02,900
当你通过实验和学期的学习时，

350
00:19:02,900 --> 00:19:04,640
我肯定你会遇到一些。

351
00:19:07,540 --> 00:19:10,000
所以往后退一步，

352
00:19:10,000 --> 00:19:14,120
考虑 Go 的这些挑战，

353
00:19:17,750 --> 00:19:19,100
我刚才谈到的。

354
00:19:20,080 --> 00:19:23,620
粗略地说， Go 有两个方案，

355
00:19:24,510 --> 00:19:28,230
来应对这些并发挑战。

356
00:19:28,930 --> 00:19:32,950
一个方案是通过通道，

357
00:19:34,980 --> 00:19:41,060
另一个方案上是通过和条件变量。

358
00:19:51,510 --> 00:19:54,120
在我看来，

359
00:19:54,120 --> 00:19:56,640
有些人对此相当武断，

360
00:19:56,640 --> 00:19:58,500
是否一个方案比另一个方案好，

361
00:19:58,800 --> 00:20:01,080
我在的总体方案是，

362
00:20:01,080 --> 00:20:04,200
我找一个更适合我的方案，

363
00:20:04,710 --> 00:20:06,300
我要运行的。

364
00:20:06,360 --> 00:20:09,480
一般来说，我不会共享，

365
00:20:09,900 --> 00:20:13,770
我需要两个线程通信，

366
00:20:13,770 --> 00:20:15,570
但我不共享内存，

367
00:20:15,630 --> 00:20:17,610
我倾向于使用通道。

368
00:20:18,080 --> 00:20:20,960
如果有两个线程可以共享内存，

369
00:20:20,990 --> 00:20:22,700
因为共享内存很方便，

370
00:20:22,700 --> 00:20:24,500
比如，我编写一个键值服务，

371
00:20:24,500 --> 00:20:26,510
我想要共享键值表，

372
00:20:26,840 --> 00:20:33,320
然后我使用锁和条件变量。

373
00:20:37,630 --> 00:20:41,710
所以，我的总体方法不是[戏剧性]的，

374
00:20:41,710 --> 00:20:43,060
可以采取任何方法，

375
00:20:43,060 --> 00:20:46,000
对解决问题是最方便的。

376
00:20:47,150 --> 00:20:54,020
这个教程很好地讲了通道，

377
00:20:54,020 --> 00:20:56,870
提到了锁，不太涉及条件变量，

378
00:20:57,020 --> 00:21:01,580
所以我认为有必要讨论一下条件变量，

379
00:21:01,580 --> 00:21:05,210
确保你知道它们的存在。

380
00:21:05,930 --> 00:21:08,750
我会使用一个很小的例子来说明，

381
00:21:08,960 --> 00:21:10,850
为了说明这些问题，

382
00:21:11,060 --> 00:21:13,130
这个小例子是，

383
00:21:13,400 --> 00:21:16,790
我们有一点启发，

384
00:21:16,790 --> 00:21:18,950
它是受实验启发的，

385
00:21:19,160 --> 00:21:20,630
有一个线程 t1 ，

386
00:21:21,050 --> 00:21:24,890
t1 需要收集一些选票，

387
00:21:24,890 --> 00:21:26,570
从远程机器上，

388
00:21:26,690 --> 00:21:30,440
比如，需要确定它拥有多数席位，

389
00:21:30,470 --> 00:21:33,590
所以，可以提交一些值，

390
00:21:33,890 --> 00:21:36,830
稍后你会在 raft 实验里看到，

391
00:21:36,830 --> 00:21:39,200
作为你需要的原语之一，

392
00:21:39,650 --> 00:21:41,510
要做到这一点，

393
00:21:41,510 --> 00:21:45,770
t1 会 fork 出其他线程，比如 t2 ，

394
00:21:46,930 --> 00:21:49,060
t2 不会做一些昂贵的事，

395
00:21:49,060 --> 00:21:52,840
只是通过与远程机器通信来获得选票，

396
00:21:53,400 --> 00:21:56,460
然后向 t1 报告投票结果，

397
00:21:56,460 --> 00:21:59,610
t1 需要收集它们获得的所有选票，

398
00:21:59,640 --> 00:22:01,440
然后达到大多数，

399
00:22:01,620 --> 00:22:03,720
然后宣布胜利。

400
00:22:04,400 --> 00:22:06,950
所以有一个相当简单的程序，

401
00:22:07,160 --> 00:22:08,150
我要给你们展示一下，

402
00:22:08,150 --> 00:22:10,970
它让我可以说明几个问题，

403
00:22:11,300 --> 00:22:14,660
我们要切换到另一个屏幕。

404
00:22:16,850 --> 00:22:18,140
都能看到这个吗？

405
00:22:22,800 --> 00:22:28,530
所以，这里我有一个非常简单的程序，

406
00:22:28,530 --> 00:22:29,550
投票的事情，

407
00:22:29,550 --> 00:22:31,590
这又是一个像玩具的例子，

408
00:22:31,590 --> 00:22:33,570
希望让人们理解这一点。

409
00:22:34,220 --> 00:22:37,580
这里两个变量共享 count 和 finished ，

410
00:22:37,580 --> 00:22:39,410
count 统计投票数，

411
00:22:39,530 --> 00:22:42,380
finished 表示我们已经完成，

412
00:22:42,890 --> 00:22:46,040
这里有一个 10 次的循环，

413
00:22:46,160 --> 00:22:54,170
创建一个 Go 的匿名函数，

414
00:22:54,200 --> 00:22:58,940
匿名函数并行调用函数 requestVote ，

415
00:22:58,970 --> 00:23:01,250
requestVote 模拟

416
00:23:01,250 --> 00:23:04,730
在远程机器上执行一项长时间昂贵的操作，

417
00:23:04,730 --> 00:23:06,890
它模拟方式是使用 Sleep ，

418
00:23:07,010 --> 00:23:09,860
它会阻塞一段时间，然后返回，

419
00:23:09,980 --> 00:23:13,370
然后如果返回的投票是肯定的，

420
00:23:13,370 --> 00:23:14,810
那么 count 增加，

421
00:23:14,810 --> 00:23:18,970
实际上，如果我们再有一个线程投票，

422
00:23:18,970 --> 00:23:20,020
然后我们就完成了，

423
00:23:20,440 --> 00:23:22,720
所以会 fork 出 10 个线程，

424
00:23:22,720 --> 00:23:25,840
每个线程都会调用 requestVote 并报告结果，

425
00:23:25,840 --> 00:23:26,800
然后在最后，

426
00:23:26,800 --> 00:23:29,500
我们会检查 count 是否小于 5 ，

427
00:23:29,560 --> 00:23:33,210
这里我们知道我们失败了，输掉了选举，

428
00:23:33,240 --> 00:23:36,900
如果我们的票数大于等于 5 ，

429
00:23:36,900 --> 00:23:38,670
我们就赢得了选举，

430
00:23:38,940 --> 00:23:42,120
所以这是一个非常简单的程序。

431
00:23:42,740 --> 00:23:44,450
这个能理解吗？

432
00:23:45,630 --> 00:23:48,000
让我来运行它，只是为了好玩。

433
00:23:52,180 --> 00:23:55,600
我们要运行几次，

434
00:23:55,690 --> 00:23:58,390
有些输了，有些赢了，这是合理的。

435
00:24:00,380 --> 00:24:04,540
所以这个程序看起来工作正常而且是正确的，

436
00:24:04,540 --> 00:24:05,500
它真的是正确的吗？

437
00:24:09,940 --> 00:24:11,050
抱歉，这是个问题吗，

438
00:24:11,050 --> 00:24:13,210
这个程序是否是正确的。

439
00:24:13,750 --> 00:24:14,830
是的，它似乎产生了结果。

440
00:24:19,060 --> 00:24:20,680
我认为这里有一个竞态条件，

441
00:24:20,680 --> 00:24:25,060
比如所有不同线程都实现了 count 和 finished 变量，

442
00:24:25,480 --> 00:24:32,640
而且，我也不清楚，

443
00:24:32,640 --> 00:24:34,890
那个 finished 必须达到 10 ，

444
00:24:35,340 --> 00:24:37,740
有没有可能它不会。

445
00:24:38,700 --> 00:24:40,980
让我把这些一一拿出来，

446
00:24:40,980 --> 00:24:42,300
然后看你的第一个观点，

447
00:24:42,300 --> 00:24:44,580
这才是我真正想要的，

448
00:24:44,580 --> 00:24:48,330
很明显这是，

449
00:24:48,330 --> 00:24:53,130
我们这里有两个变量， count finished ，

450
00:24:53,280 --> 00:24:54,870
它们被不同的 goroutine 访问，

451
00:24:54,870 --> 00:24:56,670
所以这是一个明显的危险信号，

452
00:24:56,670 --> 00:24:58,350
可能是一个严重的问题，

453
00:24:58,440 --> 00:25:00,240
一旦你有一个变量，

454
00:25:00,240 --> 00:25:03,570
可以由两个不同的 goroutine 访问或修改，

455
00:25:03,570 --> 00:25:04,860
这里会有一个问题，

456
00:25:05,340 --> 00:25:07,920
所以运行 Go 竞争检测器，

457
00:25:07,920 --> 00:25:09,090
它会抓住它。

458
00:25:10,460 --> 00:25:11,780
如你所料，

459
00:25:11,780 --> 00:25:14,270
Go 竞争检测器告诉你，

460
00:25:14,270 --> 00:25:17,690
这个程序里确实有一些问题，

461
00:25:18,020 --> 00:25:21,740
并列出出问题的行号。

462
00:25:22,700 --> 00:25:24,650
所以它给你提供了一个很好的线索，

463
00:25:24,650 --> 00:25:27,680
表示有些东西不符合[]这个程序，

464
00:25:28,340 --> 00:25:30,470
所以我们分几步来修复它，

465
00:25:30,470 --> 00:25:36,380
希望为计算机编程带来更多的启示。

466
00:25:36,950 --> 00:25:40,160
所以让我给出这个程序的第二个解决方案。

467
00:25:40,970 --> 00:25:42,830
在这种情况下，

468
00:25:42,830 --> 00:25:44,750
我们将在稍后讨论通道，

469
00:25:44,750 --> 00:25:49,550
因为我想先说明锁和条件变量，

470
00:25:49,580 --> 00:25:52,160
因为它们在教程中强调比较少。

471
00:25:52,660 --> 00:25:55,330
所以一个简单的解决方案，

472
00:25:55,360 --> 00:25:58,600
Go 引入一个锁，

473
00:25:58,600 --> 00:26:00,880
锁完全独立于变量，

474
00:26:00,910 --> 00:26:04,030
你遵循一些惯例，

475
00:26:04,030 --> 00:26:07,690
这个锁 mu 保护 count 和 finished ，

476
00:26:08,340 --> 00:26:11,250
所以，当你访问 count finished 时，

477
00:26:11,250 --> 00:26:14,190
你必须将其包装到 lock 和 unlock 语句中，

478
00:26:14,190 --> 00:26:17,970
我们在这里看到两个 go 函数同时运行，

479
00:26:18,420 --> 00:26:21,600
在 requestVote 之后，

480
00:26:21,840 --> 00:26:23,700
是关于投票核 finished 的，

481
00:26:23,700 --> 00:26:24,780
我们对它加锁，

482
00:26:25,240 --> 00:26:28,750
然后 Go 有一个很好的特性， defer 声明，

483
00:26:28,960 --> 00:26:32,170
如果你退出基本区块，

484
00:26:32,170 --> 00:26:37,720
将会运行由 defer 声明的函数，

485
00:26:37,720 --> 00:26:40,240
在关键字 defer 之后，

486
00:26:40,750 --> 00:26:42,430
这意味着我们可以执行，

487
00:26:42,490 --> 00:26:46,000
我们让 Go 函数可以自动解锁，

488
00:26:46,420 --> 00:26:49,000
这很方便，因为那样你就不会忘记解锁了，

489
00:26:49,780 --> 00:26:52,120
所以，它很适合写到加锁的地方，

490
00:26:52,150 --> 00:26:54,280
所以你可以直接写 defer unlock ，

491
00:26:54,280 --> 00:26:55,780
然后你就不必担心，

492
00:26:55,780 --> 00:26:59,260
如果有多个 exit 通过 goroutine 或函数，

493
00:26:59,620 --> 00:27:01,120
你可能会忘记解锁。

494
00:27:02,520 --> 00:27:05,100
所以现在我们在临界区域，

495
00:27:05,100 --> 00:27:06,540
我们持有锁，

496
00:27:06,540 --> 00:27:08,370
我们更新投票 count ，

497
00:27:08,370 --> 00:27:11,370
然后函数返回并自动解锁。

498
00:27:12,240 --> 00:27:16,710
同样地，在最后，

499
00:27:16,740 --> 00:27:21,030
当我们每次访问 count finished 时，

500
00:27:21,270 --> 00:27:22,380
因为它们是共享的，

501
00:27:22,380 --> 00:27:24,540
我们需要用锁把它围起来，

502
00:27:24,540 --> 00:27:26,370
有一个简单的方法，

503
00:27:26,370 --> 00:27:28,890
我们也可以在这里写 defer unlock ，

504
00:27:29,010 --> 00:27:30,810
这样就可以了。

505
00:27:31,380 --> 00:27:33,360
所以我们可以运行这个程序，

506
00:27:34,270 --> 00:27:35,080
让我们看看。

507
00:27:36,820 --> 00:27:38,080
所以我们运行它，

508
00:27:38,080 --> 00:27:40,180
竞争检测器看起来没问题，

509
00:27:40,180 --> 00:27:42,370
希望我们有一个更好的程序。

510
00:27:42,670 --> 00:27:43,270
好的?

511
00:27:44,160 --> 00:27:46,860
我有一个关于作用域的问题，

512
00:27:47,280 --> 00:27:49,470
看起来，当我们有匿名函数时，

513
00:27:49,470 --> 00:27:50,250
然后我们有 mu ，

514
00:27:50,250 --> 00:27:52,350
我们有 count 和 finished ，

515
00:27:52,350 --> 00:27:54,690
看起来匿名函数可以访问

516
00:27:54,960 --> 00:27:56,790
函数外部定义的变量，

517
00:27:56,790 --> 00:27:58,440
那么作用域是如何工作的？

518
00:27:59,300 --> 00:28:01,490
是的，任何，

519
00:28:01,520 --> 00:28:02,630
在一个匿名函数中，

520
00:28:02,630 --> 00:28:06,980
在函数中使用的不是在函数中声明的任何变量，

521
00:28:07,130 --> 00:28:11,120
会指向外部作用域的变量，

522
00:28:12,020 --> 00:28:12,950
也就是静态作用域。

523
00:28:14,830 --> 00:28:18,130
像互斥锁的作用域呢，

524
00:28:19,040 --> 00:28:21,590
比如你要声明多少次，

525
00:28:21,620 --> 00:28:24,050
或者它的范围是什么。

526
00:28:24,320 --> 00:28:27,800
defer 语句的作用域是这个基本块。

527
00:28:29,190 --> 00:28:30,120
不，我的意思是，

528
00:28:30,120 --> 00:28:34,290
当你声明互斥锁数据结构时。

529
00:28:34,650 --> 00:28:36,990
像任何其他变量一样，

530
00:28:37,560 --> 00:28:39,810
它的作用域与 finished 或 count 相同。

531
00:28:40,550 --> 00:28:44,570
所以它与其余部分中声明的任何变量。

532
00:28:45,020 --> 00:28:46,910
是的，我们可以这样想，

533
00:28:46,910 --> 00:28:51,080
互斥锁不直接与任何变量相关联，

534
00:28:51,080 --> 00:28:53,150
它只是一把锁，一个名字，

535
00:28:53,510 --> 00:28:57,650
作为程序员，你可以决定锁保护的是什么，

536
00:29:01,450 --> 00:29:03,280
但是有两个独立的概念。

537
00:29:04,350 --> 00:29:08,770
如果你在 goroutine 中使用 i 会发生什么，

538
00:29:08,800 --> 00:29:10,840
那是不行的吧，你需要把它传进去。

539
00:29:11,320 --> 00:29:13,150
是的，这是个好问题，

540
00:29:13,150 --> 00:29:15,820
你们中很多人在邮件中问过，

541
00:29:15,820 --> 00:29:17,200
所以会发生什么，

542
00:29:17,200 --> 00:29:18,490
如果我们在这里使用 i ，

543
00:29:18,520 --> 00:29:20,950
用它做点什么，

544
00:29:20,950 --> 00:29:23,650
比如 count = i ，

545
00:29:24,620 --> 00:29:26,180
这是不是可行的？

546
00:29:31,460 --> 00:29:33,290
i 会是什么值，

547
00:29:33,350 --> 00:29:35,210
当这个线程运行时，

548
00:29:36,020 --> 00:29:39,170
如果 go func 在某个时刻运行，

549
00:29:39,170 --> 00:29:40,790
i 会是什么值。

550
00:29:41,710 --> 00:29:44,200
i 会是那个运行时刻的值，

551
00:29:44,200 --> 00:29:47,710
被外部的 for 循环修改。

552
00:29:47,770 --> 00:29:50,950
是的，所以这并不是很好，

553
00:29:51,070 --> 00:29:52,780
它可能不是我们想要的，

554
00:29:52,810 --> 00:29:57,040
我们希望 i 对应那次循环，

555
00:29:58,270 --> 00:29:59,110
那么我们要如何做，

556
00:29:59,110 --> 00:30:01,060
如果我们必须解决，我们要怎么做。

557
00:30:01,640 --> 00:30:06,050
你可以把它作为匿名函数的参数，并把它传进去，

558
00:30:06,050 --> 00:30:09,230
所以它会在创建 goroutine 时被求值。

559
00:30:09,500 --> 00:30:11,060
是的，所以我写下这个，

560
00:30:12,340 --> 00:30:13,810
然后传进去，

561
00:30:13,810 --> 00:30:15,040
在这个时刻会发生，

562
00:30:15,040 --> 00:30:17,980
在我们创建 goroutine 的这个时刻，

563
00:30:17,980 --> 00:30:20,660
i 被捕获，然后传参。

564
00:30:22,250 --> 00:30:22,700
好的?

565
00:30:24,390 --> 00:30:29,280
我还有个问题，局部变量是怎么分配的，

566
00:30:29,640 --> 00:30:32,790
比如 count finished 是本地变量，

567
00:30:32,790 --> 00:30:36,570
它们不会在主函数退出后被销毁吗，

568
00:30:36,690 --> 00:30:38,700
比如这个函数是由其他函数创建的，

569
00:30:38,700 --> 00:30:41,880
如果[命中]函数在 goroutine 之前退出会怎样。

570
00:30:41,880 --> 00:30:44,520
主体分配在栈中，

571
00:30:44,640 --> 00:30:47,670
可能其他函数，

572
00:30:47,670 --> 00:30:50,310
有指向它们的内存地址，

573
00:30:50,580 --> 00:30:51,570
所以是这样的，

574
00:30:51,570 --> 00:30:52,770
它的主函数返回了，

575
00:30:52,860 --> 00:30:56,340
那么这些栈分配的变量就消失了，

576
00:30:56,820 --> 00:30:59,700
所以通常你会在 Go 程序中看到，

577
00:30:59,700 --> 00:31:01,980
你会在堆上分配，

578
00:31:02,010 --> 00:31:05,250
使用 new 创建一个新的结构体。

579
00:31:05,580 --> 00:31:07,800
所以，你会遇到段错误，或者。

580
00:31:07,800 --> 00:31:08,910
是的，我们会得到。

581
00:31:09,210 --> 00:31:09,810
好的。

582
00:31:13,500 --> 00:31:14,670
我有一个问题，

583
00:31:14,670 --> 00:31:17,910
我不记得这是不是正确的方法，

584
00:31:17,910 --> 00:31:19,410
但是除了把它传递进去，

585
00:31:19,500 --> 00:31:22,380
是否可以在 for 循环的第一行，

586
00:31:22,380 --> 00:31:24,060
使用 i := i ，

587
00:31:24,960 --> 00:31:26,820
然后你有一个，

588
00:31:26,910 --> 00:31:30,960
我不知道作用域在 for 循环中是如何工作的，

589
00:31:30,960 --> 00:31:34,200
因为我认为这会产生一个新的变量 i ，

590
00:31:34,260 --> 00:31:35,580
goroutine 可以访问，

591
00:31:35,580 --> 00:31:36,990
并且不会再次更新。

592
00:31:37,440 --> 00:31:37,710
是的，你可以这样做。

593
00:31:37,710 --> 00:31:41,190
这可以避免传入参数，不过有点难看。

594
00:31:41,940 --> 00:31:43,740
好的，我喜欢传参，

595
00:31:43,740 --> 00:31:45,090
但这是另一种方式，

596
00:31:45,090 --> 00:31:46,740
稍后我将展示一个示例。

597
00:31:49,200 --> 00:31:51,510
所以有人问，

598
00:31:51,510 --> 00:31:54,150
我们会不会遇到段错误，

599
00:31:54,150 --> 00:31:56,100
我们不会直接得到段错误，

600
00:31:56,100 --> 00:31:57,060
往回一点，

601
00:31:57,390 --> 00:32:00,630
因为一个线程仍然持有引用，

602
00:32:00,930 --> 00:32:04,230
所以垃圾回收器不会删除该对象，

603
00:32:05,000 --> 00:32:06,890
只有最后一个线程，

604
00:32:06,890 --> 00:32:09,650
只有当没有线程持有引用时，

605
00:32:09,650 --> 00:32:12,140
垃圾回收器才会会删除该对象，

606
00:32:12,640 --> 00:32:13,690
这是最酷的地方之一，

607
00:32:13,690 --> 00:32:16,630
关于使用垃圾回收语言和共享内存编程，

608
00:32:16,870 --> 00:32:18,760
你不必担心这种情况。

609
00:32:21,300 --> 00:32:22,710
好的，那么。

610
00:32:24,680 --> 00:32:25,070
是的。

611
00:32:25,620 --> 00:32:28,560
这个代码会不会出现死锁，

612
00:32:28,830 --> 00:32:32,040
因为如果 goroutine ，

613
00:32:32,280 --> 00:32:34,140
第一个 for 循环退出，

614
00:32:34,140 --> 00:32:36,630
然后第二个会，比如，

615
00:32:37,930 --> 00:32:38,770
好的，没有关系。

616
00:32:40,660 --> 00:32:43,240
好的，这里肯定有一些问题不完美，

617
00:32:43,240 --> 00:32:44,770
所以让我来谈谈它们，

618
00:32:45,100 --> 00:32:49,090
其中之一是这个循环有点烦人，

619
00:32:49,090 --> 00:32:50,950
这个 for 循环是，

620
00:32:50,950 --> 00:32:53,950
除了等待 count 达到 5 ，没有别的，

621
00:32:54,380 --> 00:32:55,130
它这样做的方式，

622
00:32:55,130 --> 00:32:56,510
它是在旋转，

623
00:32:56,510 --> 00:32:59,360
所以它很快地对这个值加锁，

624
00:32:59,360 --> 00:33:00,770
对它解锁，然后再次旋转，

625
00:33:00,770 --> 00:33:03,380
所以就是在处理器上旋转，实际上什么都不做，

626
00:33:03,950 --> 00:33:06,140
应该有更好的方式来表示它，

627
00:33:06,140 --> 00:33:09,140
所以 Go 可以放弃核心，

628
00:33:09,140 --> 00:33:10,430
让另一个线程就运行。

629
00:33:11,040 --> 00:33:13,590
这样做的方法就是使用条件变量，

630
00:33:13,590 --> 00:33:16,170
这是我的下一个实现，

631
00:33:17,300 --> 00:33:20,810
或者我向你展示另一个实现，

632
00:33:20,810 --> 00:33:21,830
一种完成的方法，

633
00:33:21,830 --> 00:33:23,600
不是很好，

634
00:33:23,600 --> 00:33:25,280
比如，有人建议，

635
00:33:25,280 --> 00:33:27,680
在这里睡眠一段时间，

636
00:33:27,710 --> 00:33:31,850
与其疯狂地放弃旋转，

637
00:33:31,850 --> 00:33:33,140
只是睡眠一段时间，

638
00:33:33,200 --> 00:33:34,790
睡一段时间，然后回来。

639
00:33:35,500 --> 00:33:36,700
当然，这个解决方案是有效的，

640
00:33:36,700 --> 00:33:37,720
但它的缺点是，

641
00:33:37,720 --> 00:33:40,090
你应该睡多久，

642
00:33:40,120 --> 00:33:41,590
你很想这样，

643
00:33:41,590 --> 00:33:44,080
比如，假设这个变量到了 5 ，

644
00:33:44,530 --> 00:33:46,480
然后你唤醒，

645
00:33:46,510 --> 00:33:49,630
你可以唤醒这个主线程。

646
00:33:50,130 --> 00:33:52,650
所以我往前跳了一点，

647
00:33:52,650 --> 00:33:55,830
但这就是条件变量的作用，

648
00:33:56,250 --> 00:33:59,850
这是使用条件变量的解决方案，

649
00:34:00,670 --> 00:34:05,140
所以，我们分配一个新的条件，

650
00:34:05,140 --> 00:34:07,570
这里是分配条件变量，

651
00:34:07,630 --> 00:34:09,520
它与这个锁关联，

652
00:34:09,520 --> 00:34:11,500
我们稍后会看到，为什么这很重要。

653
00:34:12,340 --> 00:34:15,340
现在的主线所做的，

654
00:34:15,490 --> 00:34:17,620
它获取锁，

655
00:34:17,620 --> 00:34:19,960
因为它需要获取锁来检查 count 和 finished ，

656
00:34:19,960 --> 00:34:21,640
否则可能会有竞态条件，

657
00:34:22,060 --> 00:34:26,380
然后，如果条件仍然不成立，

658
00:34:26,440 --> 00:34:28,780
它只是在这个条件变量上调用 Wait ，

659
00:34:29,640 --> 00:34:33,720
它所做的是原子地进入睡眠状态

660
00:34:33,840 --> 00:34:37,500
并且释放与条件变量关联的锁，

661
00:34:37,830 --> 00:34:41,070
因为 mu 与条件变量关联，

662
00:34:41,100 --> 00:34:47,490
可以等待解锁并睡眠，

663
00:34:47,520 --> 00:34:48,780
在一个原子操作中，

664
00:34:49,580 --> 00:34:51,920
当它从 cond.Wait() 返回时，

665
00:34:51,920 --> 00:34:53,420
它会再次获得锁，

666
00:34:53,990 --> 00:34:56,480
所以这些是肯定的，

667
00:34:56,480 --> 00:34:59,360
如果调用者返回，将会再次持有锁，

668
00:34:59,570 --> 00:35:01,610
所以，这也是安全地，查看 count 和 finished ，

669
00:35:01,610 --> 00:35:02,690
然后再次调用 Wait 。

670
00:35:03,690 --> 00:35:04,350
好的?

671
00:35:05,160 --> 00:35:07,380
所以这个线程会进入睡眠状态，

672
00:35:07,800 --> 00:35:12,570
然后 goroutine 收集选票，

673
00:35:12,840 --> 00:35:14,280
与之前相同的代码，

674
00:35:14,310 --> 00:35:16,950
mu lock 和 unlock 或 defer unlock ，

675
00:35:17,160 --> 00:35:18,360
然后当你完成时，

676
00:35:18,390 --> 00:35:20,640
更新 count 和 finished ，

677
00:35:20,640 --> 00:35:22,530
条件变量上有两个原语，

678
00:35:22,530 --> 00:35:24,330
一个是 Signal ，一个是 Broadcast ，

679
00:35:24,720 --> 00:35:28,470
Signal 等待一个等待者，

680
00:35:28,470 --> 00:35:29,760
Broadcast 等待所有的等待者，

681
00:35:30,120 --> 00:35:31,740
这里只有一个等待者，

682
00:35:31,740 --> 00:35:33,150
所以我们可以用它们中的任何一个。

683
00:35:34,740 --> 00:35:37,590
所以当它达到 5 ，

684
00:35:37,620 --> 00:35:39,030
或者某些时刻是 10 ，

685
00:35:39,180 --> 00:35:42,240
所以每次 finished 递增，

686
00:35:42,270 --> 00:35:45,160
主线程会被唤醒，

687
00:35:45,370 --> 00:35:47,710
你可以检查条件，然后继续。

688
00:35:48,580 --> 00:35:49,210
好的?

689
00:35:50,260 --> 00:35:51,340
所以这很方便，

690
00:35:51,340 --> 00:35:53,230
所以，你可以把条件变量看成

691
00:35:53,230 --> 00:35:56,860
两个不同线程之间的协调原语，

692
00:35:57,100 --> 00:35:58,150
它们非常方便，

693
00:35:58,150 --> 00:36:02,050
当你使用锁来保护你的共享状态时。

694
00:36:10,580 --> 00:36:16,400
这是使用通道实现这个程序，

695
00:36:16,930 --> 00:36:19,960
基本上是一样的方式，

696
00:36:19,960 --> 00:36:21,640
当然除了没有锁，

697
00:36:21,970 --> 00:36:25,090
但是主线程创建通道，

698
00:36:25,090 --> 00:36:28,720
传递 goroutine 匿名函数，

699
00:36:28,720 --> 00:36:30,580
作为一个单独的线程创建，

700
00:36:30,820 --> 00:36:33,460
将 rquestVote 写入通道，

701
00:36:33,730 --> 00:36:36,040
然后主线程会在这里阻塞，

702
00:36:36,040 --> 00:36:37,660
当它开始从通道读取时，

703
00:36:38,080 --> 00:36:39,700
一旦它得到一些东西，

704
00:36:39,700 --> 00:36:41,890
当一些东西写入通道时，就会解锁，

705
00:36:42,280 --> 00:36:45,400
查看值，如果为真，就累加，

706
00:36:45,400 --> 00:36:48,070
否则， finished 总是递增的。

707
00:36:48,830 --> 00:36:50,540
这里发生的一切，

708
00:36:50,540 --> 00:36:51,620
我们不需要锁，

709
00:36:51,620 --> 00:36:53,270
因为 count 和 finished 没有共享，

710
00:36:53,330 --> 00:36:56,990
只有一个线程更新 count 和 finished ，

711
00:36:56,990 --> 00:36:57,890
也就是主线程。

712
00:36:58,830 --> 00:36:59,610
好的?

713
00:37:01,770 --> 00:37:02,520
这个。

714
00:37:03,240 --> 00:37:06,510
这个主线程，

715
00:37:06,510 --> 00:37:11,490
抱歉， requestVote 线程总是写入通道，

716
00:37:11,490 --> 00:37:13,470
可能在通道中并发写入，

717
00:37:13,770 --> 00:37:16,590
但是通道是 Go 中线程安全的东西之一，

718
00:37:16,590 --> 00:37:18,720
所以，多个线程可以写入通道。

719
00:37:21,240 --> 00:37:25,210
关于这个解决方案，有什么问题吗？

720
00:37:27,770 --> 00:37:32,050
有缓冲的通道是怎么回事？

721
00:37:32,260 --> 00:37:35,650
是的，通常情况下，当你写入通道时，

722
00:37:35,650 --> 00:37:37,900
没有人从通道读取，

723
00:37:37,900 --> 00:37:39,580
或者没有线程从通道读取，

724
00:37:39,670 --> 00:37:41,530
那么发送者会立即阻塞，

725
00:37:42,330 --> 00:37:48,180
你可以指定一个缓冲区为 10 或 20 的通道，

726
00:37:48,420 --> 00:37:52,110
这会允许通道有多个值，

727
00:37:52,920 --> 00:37:55,140
在 6.824 实验中，

728
00:37:55,140 --> 00:37:58,230
我从来没有用过缓冲通道，

729
00:37:58,230 --> 00:38:00,180
我用过两三次，

730
00:38:00,180 --> 00:38:01,140
我后悔了，

731
00:38:01,170 --> 00:38:03,090
所以我一般不用它。

732
00:38:04,180 --> 00:38:05,950
但这一点很重要，

733
00:38:06,780 --> 00:38:09,630
这个程序其实还不是很好，

734
00:38:09,990 --> 00:38:12,990
比如，当，

735
00:38:13,020 --> 00:38:16,770
在这个例子中没有关系，

736
00:38:16,770 --> 00:38:20,580
但在某些实验中，可能会出现，

737
00:38:21,000 --> 00:38:23,970
一旦 count 达到 5 ，就会发生什么。

738
00:38:27,800 --> 00:38:31,070
它停止监听新的频道，

739
00:38:31,190 --> 00:38:33,800
所以任何其他线程都会被阻塞。

740
00:38:34,070 --> 00:38:37,730
是的，这意味着如果前 5 个线程投了赞成票，

741
00:38:38,160 --> 00:38:41,130
那么接下来的 5 个线程将在这个通道中阻塞，

742
00:38:42,480 --> 00:38:44,040
它们会被困住。

743
00:38:44,970 --> 00:38:48,090
在这种情况下，这不会是一个问题，

744
00:38:48,090 --> 00:38:50,340
因为你们大多数人都注意到了，

745
00:38:50,340 --> 00:38:51,780
如果主线程退出，

746
00:38:52,080 --> 00:38:54,090
它也会清除所有其他线程，

747
00:38:54,810 --> 00:38:57,840
但是如果这是一个长期运行的服务，

748
00:38:58,170 --> 00:38:59,610
这不是很好，

749
00:38:59,610 --> 00:39:01,350
在这里我们会泄露线程，

750
00:39:01,380 --> 00:39:03,360
它们阻塞在一边，

751
00:39:03,360 --> 00:39:05,010
在通道中什么都不做，

752
00:39:05,220 --> 00:39:06,990
所以这很不方便，

753
00:39:06,990 --> 00:39:09,150
这是一个需要注意的东西。

754
00:39:09,980 --> 00:39:11,450
这出现在爬虫上，

755
00:39:11,450 --> 00:39:13,460
我想对许多人来说，

756
00:39:13,490 --> 00:39:16,670
另一方面，

757
00:39:16,940 --> 00:39:20,810
如果主线程在任何 requestVote 完成之前退出，

758
00:39:21,050 --> 00:39:22,520
那么你也有一个问题，

759
00:39:22,610 --> 00:39:26,960
所以，对线程的管理通常是一个棘手的问题。

760
00:39:29,040 --> 00:39:32,370
有没有在不退出主线程的情况下杀死线程？

761
00:39:33,530 --> 00:39:37,940
好的，你可以发送给一个变量到通道上，

762
00:39:37,940 --> 00:39:38,990
表示请退出，

763
00:39:39,320 --> 00:39:41,690
但你必须自己协调它。

764
00:39:47,250 --> 00:39:54,760
我要回到关于条件变量的一个很酷的事情上，

765
00:39:55,450 --> 00:40:01,470
你可能会认为这里也存在同样的问题，

766
00:40:01,740 --> 00:40:04,260
这个线程运行，

767
00:40:04,260 --> 00:40:06,720
在这个线程中，

768
00:40:06,750 --> 00:40:10,140
它可能会被阻塞，

769
00:40:10,140 --> 00:40:12,630
比如，如果它达到 5 ，

770
00:40:12,660 --> 00:40:15,810
这个主线程在做它的事情，

771
00:40:16,260 --> 00:40:19,290
而其他线程可能还在这里，

772
00:40:20,080 --> 00:40:23,710
注意在这种情况下，它们不会被阻塞，

773
00:40:23,830 --> 00:40:26,020
因为会获得锁，

774
00:40:26,260 --> 00:40:28,840
然后调用 Broadcast ，

775
00:40:28,840 --> 00:40:31,030
Broadcast 不是阻塞操作，

776
00:40:31,090 --> 00:40:32,980
所以不同于向通道写入，

777
00:40:32,980 --> 00:40:34,150
那是一个阻塞操作，

778
00:40:34,150 --> 00:40:35,320
如果没有线程在接收，

779
00:40:35,530 --> 00:40:37,930
cond.Broadcast 不是阻塞操作。

780
00:40:38,450 --> 00:40:40,550
所以在这个项目中起作用的，

781
00:40:40,550 --> 00:40:42,410
通过它自己。

782
00:40:43,690 --> 00:40:44,290
好的?

783
00:40:49,200 --> 00:40:49,890
好的，很好。

784
00:40:50,700 --> 00:40:54,090
关于这两个例子，还有什么问题吗？

785
00:41:00,480 --> 00:41:04,680
好的，那我们来谈谈爬虫，

786
00:41:05,700 --> 00:41:10,020
爬虫是并发编程的一个更现实的例子。

787
00:41:14,550 --> 00:41:15,900
提醒你一下，

788
00:41:15,900 --> 00:41:20,910
基本上这个想法是，

789
00:41:20,910 --> 00:41:23,850
你从一些网页的 url 开始，

790
00:41:24,210 --> 00:41:28,500
你获取的可能包含更多 url 的网页，

791
00:41:28,940 --> 00:41:30,590
当你继续的时候，

792
00:41:30,590 --> 00:41:32,630
然后取回那些网页，

793
00:41:32,630 --> 00:41:34,730
查着这些 url ，并继续前进。

794
00:41:35,730 --> 00:41:38,160
这个想法是爬取整个互联网，

795
00:41:38,340 --> 00:41:40,560
存在的所有网页，

796
00:41:41,010 --> 00:41:45,540
当然，一些 url 可能指向你已经访问过的网页，

797
00:41:45,540 --> 00:41:50,160
所以目标是不会两次访问同一个网页。

798
00:41:52,380 --> 00:41:54,690
所以这个练习有几个目标，

799
00:41:54,690 --> 00:41:56,520
你想达到的。

800
00:41:56,520 --> 00:41:58,470
一个是 IO 并发性，

801
00:42:03,180 --> 00:42:06,360
爬取操作可能需要很长时间，

802
00:42:06,360 --> 00:42:07,740
也许一个网页，

803
00:42:07,740 --> 00:42:09,090
它在世界的另一边，

804
00:42:09,090 --> 00:42:11,280
可能它是通过低速网络传输的，

805
00:42:11,460 --> 00:42:14,190
当一个线程正在爬取那个页面时，

806
00:42:14,190 --> 00:42:18,660
你希望能够爬取其他页面，

807
00:42:19,260 --> 00:42:22,950
另一个目标是正确性目标或性能目标，

808
00:42:22,950 --> 00:42:25,950
即只爬取一次 url ，

809
00:42:30,000 --> 00:42:33,240
假设你的目标是开发多个核心，

810
00:42:33,240 --> 00:42:36,540
你有多个核心并行工作。

811
00:42:42,270 --> 00:42:42,870
好的?

812
00:42:43,740 --> 00:42:46,980
所以，我想做的是，

813
00:42:47,010 --> 00:42:51,180
在真正讨论并发解决方案之前，

814
00:42:51,180 --> 00:42:55,650
首先，让我展示一个简单的顺序的解决方案，

815
00:42:55,650 --> 00:42:58,080
所以我们，

816
00:42:58,850 --> 00:43:01,280
让我们有一些东西可以作为基线来谈论。

817
00:43:12,240 --> 00:43:15,960
所以，这里我有三个解决方案。

818
00:43:19,040 --> 00:43:21,980
运行它们，go run.

819
00:43:26,080 --> 00:43:29,380
一个顺序的解决方案，一个使用互斥锁，一个使用通道，

820
00:43:29,440 --> 00:43:33,940
你看到，它们产生的结果或多或少是一样的，

821
00:43:33,940 --> 00:43:35,950
两个找到，一个丢失，两个找到，

822
00:43:36,470 --> 00:43:37,700
唯一的区别是，

823
00:43:37,700 --> 00:43:39,980
输出的顺序偶尔会略有不同，

824
00:43:39,980 --> 00:43:41,780
当然，它必须进行并发操作。

825
00:43:43,880 --> 00:43:49,290
好的，主函数调用的 Serial ，

826
00:43:49,290 --> 00:43:53,160
使用起始 url ， fetcher ，然后是一个空映射，

827
00:43:54,220 --> 00:44:00,760
顺序方案是一种标准的顺序递归解，

828
00:44:01,180 --> 00:44:04,960
我们首先检查是否已经访问了传递给我们的 url ，

829
00:44:05,420 --> 00:44:07,100
如果我们访问了，我们会立即返回，

830
00:44:07,100 --> 00:44:08,780
否则我们把它标记为访问，

831
00:44:09,080 --> 00:44:10,310
我们去获取 url ，

832
00:44:10,310 --> 00:44:12,770
这是一堆 url ，

833
00:44:12,770 --> 00:44:14,480
我们查找所有的 url ，

834
00:44:14,600 --> 00:44:16,430
然后再次调用 Serial ，

835
00:44:16,430 --> 00:44:18,080
这就是顺序解决方案，

836
00:44:18,080 --> 00:44:19,040
正是我所期望的。

837
00:44:19,760 --> 00:44:23,270
你的目标是编写这个的并发版本。

838
00:44:24,140 --> 00:44:28,450
所以，我想做的是，

839
00:44:28,450 --> 00:44:30,280
让课堂变得更具互动性，

840
00:44:30,340 --> 00:44:32,800
我想切换到分组会议室，

841
00:44:32,830 --> 00:44:34,180
我们要做的是，

842
00:44:34,180 --> 00:44:39,520
让你们四到五个人在一个分组会议室，

843
00:44:40,060 --> 00:44:41,290
大概十分钟，

844
00:44:41,560 --> 00:44:43,690
我希望你们做的是，

845
00:44:43,690 --> 00:44:45,970
分享你们的解决方案，并进行讨论，

846
00:44:46,270 --> 00:44:49,210
所以也许最好的办法就是，

847
00:44:49,330 --> 00:44:52,120
你们中的一个人，你进了一个房间，

848
00:44:52,240 --> 00:44:53,650
房间里的一个人，

849
00:44:53,680 --> 00:44:56,110
通过屏幕分享他们的解决方案，

850
00:44:56,440 --> 00:44:58,570
并讨论其中一个问题，

851
00:44:58,570 --> 00:45:00,070
你所遇到的，

852
00:45:00,070 --> 00:45:02,680
其他人可以评论或分享其他解决方案，

853
00:45:02,920 --> 00:45:04,360
让我们来讨论一下，

854
00:45:04,360 --> 00:45:05,830
并看看班上的其他同学。

855
00:45:07,480 --> 00:45:08,560
对于这个，有什么问题吗？

856
00:45:11,950 --> 00:45:13,960
好的，让我回去，

857
00:45:13,960 --> 00:45:16,870
再次分享我的屏幕，

858
00:45:17,350 --> 00:45:19,060
大家能不能再看到我的屏幕。

859
00:45:21,600 --> 00:45:22,590
是的，看起来不错。

860
00:45:23,120 --> 00:45:24,230
很好，谢谢你。

861
00:45:29,140 --> 00:45:31,870
好的，希望这很有趣，

862
00:45:32,110 --> 00:45:37,750
让我谈论一下我的解决方案，

863
00:45:38,380 --> 00:45:40,210
它们已经放在课程表页面上，

864
00:45:40,210 --> 00:45:45,280
如果你还没有，你可以和我一起看，

865
00:45:45,280 --> 00:45:45,970
如果你想的话。

866
00:45:46,770 --> 00:45:52,050
让我先看一遍互斥锁版本，

867
00:45:52,050 --> 00:45:56,160
稍后再看通道的版本。

868
00:45:56,340 --> 00:46:00,710
所以，这是互斥锁版本，

869
00:46:00,710 --> 00:46:05,690
互斥锁版本声明了具有映射和互斥锁的结构，

870
00:46:05,690 --> 00:46:08,660
映射需要由互斥锁保护，

871
00:46:08,660 --> 00:46:10,940
因为会对映射进行并发访问，

872
00:46:11,570 --> 00:46:13,190
映射本身并不是线程安全的，

873
00:46:13,190 --> 00:46:16,280
取决于程序员使映射是线程安全的。

874
00:46:17,330 --> 00:46:20,780
互斥锁版本跟顺序版本很像，

875
00:46:20,780 --> 00:46:23,510
除了有一个阶段使用了锁，

876
00:46:23,660 --> 00:46:24,950
所以我们获取锁，

877
00:46:24,980 --> 00:46:28,100
我们查看 url 是否已经被爬取，

878
00:46:28,220 --> 00:46:29,090
如果它没有被爬取，

879
00:46:29,090 --> 00:46:30,770
我们现在把它标记为爬取，

880
00:46:31,250 --> 00:46:33,290
还没有被爬取，我们解锁，

881
00:46:33,710 --> 00:46:35,990
我们保留这个 already 的值，

882
00:46:35,990 --> 00:46:37,580
决定我们是否应该返回。

883
00:46:38,560 --> 00:46:44,800
然后，这个 goroutine 开始爬取页面，

884
00:46:44,800 --> 00:46:46,150
取回一堆 url ，

885
00:46:46,660 --> 00:46:48,940
然后对于每个返回的 url ，

886
00:46:49,240 --> 00:46:53,020
它在这边创造了一个新的 goroutine ，

887
00:46:53,500 --> 00:46:55,540
传入 url ，

888
00:46:55,540 --> 00:46:58,840
goroutine 会爬取。

889
00:47:00,100 --> 00:47:04,630
这里唯一有趣的是，

890
00:47:04,630 --> 00:47:06,610
它使用了关于 WaitGroup 的一些东西，

891
00:47:07,000 --> 00:47:09,100
WaitGroup 是一个非常方便的原语，

892
00:47:09,100 --> 00:47:11,740
用于跟踪你有多少活动线程，

893
00:47:11,740 --> 00:47:13,060
什么时候可以终止。

894
00:47:13,520 --> 00:47:16,040
这是这次任务中的一个大问题，

895
00:47:16,040 --> 00:47:17,600
如果你终止得太早，

896
00:47:17,600 --> 00:47:19,430
那你还没有爬取网页。

897
00:47:19,980 --> 00:47:21,630
所以你需要跟踪，

898
00:47:21,630 --> 00:47:26,010
还有什么网页需要抓取，

899
00:47:26,010 --> 00:47:27,750
sync.WaitGroup 非常简单，

900
00:47:27,990 --> 00:47:31,560
每次你调用线程，调用 Add ，

901
00:47:31,860 --> 00:47:36,270
然后当线程终止时，调用 Done ，

902
00:47:36,390 --> 00:47:39,540
我们可以方便的在 defer 语句中做到。

903
00:47:39,970 --> 00:47:43,030
然后主线程等待所有线程结束，

904
00:47:43,030 --> 00:47:43,780
只是等待，

905
00:47:43,780 --> 00:47:45,850
Wait 将返回，直到每个线程，

906
00:47:45,880 --> 00:47:48,550
开始时的每个 Add(1) ，

907
00:47:48,790 --> 00:47:51,700
如果所有这些线程都已经退出。

908
00:47:53,330 --> 00:47:57,230
这是互斥锁的版本。

909
00:48:00,210 --> 00:48:01,950
你可以将 sync wait 看作是，

910
00:48:01,950 --> 00:48:05,070
条件变量的内部实现。

911
00:48:07,230 --> 00:48:11,490
好的，让我来看看通道版本，

912
00:48:12,380 --> 00:48:14,900
这是通道版本，

913
00:48:14,900 --> 00:48:20,690
基本上是按照 mapreduce 实验组织的，

914
00:48:20,690 --> 00:48:22,700
有协调者和工作者，

915
00:48:23,420 --> 00:48:28,340
所以，我们开始创建一个协调者线程，

916
00:48:28,790 --> 00:48:30,830
我们做这一点的方式是，

917
00:48:30,830 --> 00:48:31,880
我们创建一个通道，

918
00:48:32,330 --> 00:48:35,180
然后将通道传递给 coordinator ，

919
00:48:35,240 --> 00:48:38,570
coordinator 当然必须从开始 url 开始，

920
00:48:38,570 --> 00:48:40,520
所以我们需要在通道上提供这些信息，

921
00:48:40,520 --> 00:48:41,930
这是最方便的事情，

922
00:48:41,930 --> 00:48:42,950
我们马上会看到。

923
00:48:43,540 --> 00:48:45,850
但是，要把它发送给通道，

924
00:48:45,850 --> 00:48:47,380
我们需要创造一个 goroutine ，

925
00:48:47,380 --> 00:48:49,180
否则，我们会陷入死锁，

926
00:48:49,950 --> 00:48:51,390
这是一件困难的事情，

927
00:48:51,390 --> 00:48:54,180
我们将在通道上发送那个值。

928
00:48:55,150 --> 00:48:56,560
让我们来看一下 coordinator ，

929
00:48:57,980 --> 00:49:01,910
这是 coordinator ，它不使用任何锁，

930
00:49:01,940 --> 00:49:03,950
因为数据结构，

931
00:49:03,950 --> 00:49:07,340
这里没有实际共享的数据结构，

932
00:49:07,370 --> 00:49:08,240
比如 fetched ，

933
00:49:08,510 --> 00:49:12,020
映射跟踪哪些 url 被爬取，

934
00:49:12,020 --> 00:49:14,660
只在 coordinator 中访问。

935
00:49:16,480 --> 00:49:17,770
所以 coordinator 获得，

936
00:49:17,800 --> 00:49:20,980
当我们初始调用它的时候，我们得到，

937
00:49:20,980 --> 00:49:24,910
它有一个 url ，检查 fetched 映射，

938
00:49:24,910 --> 00:49:26,260
对于每个 url ，

939
00:49:26,800 --> 00:49:31,390
然后它循环到达通道

940
00:49:31,390 --> 00:49:32,590
使用 range 语句，

941
00:49:33,010 --> 00:49:34,420
它所做的是，

942
00:49:34,420 --> 00:49:35,740
只要继续读取通道，

943
00:49:35,740 --> 00:49:38,740
然后获取下一个值，获取下一个值，获取下一个值，

944
00:49:38,770 --> 00:49:40,870
所以就是获取 url ，

945
00:49:40,960 --> 00:49:42,070
我们知道有一个初始化，

946
00:49:42,100 --> 00:49:44,380
因为我们在创建它时，放入的。

947
00:49:45,020 --> 00:49:46,550
然后，对于那个 url ，

948
00:49:46,550 --> 00:49:50,270
我们做的事情类似于，

949
00:49:51,170 --> 00:49:53,420
并发类似于互斥锁版本，

950
00:49:53,750 --> 00:49:57,230
我们看到 url 已经被获取，

951
00:49:57,260 --> 00:50:00,170
如果已经获取，那我们完成了，

952
00:50:00,230 --> 00:50:04,430
否则，我们创建一个 Go worker 来获取那个 url 。

953
00:50:06,380 --> 00:50:10,760
我们会记录我们有多少 worker ，

954
00:50:10,790 --> 00:50:12,530
n 是统计 worker 的数量，

955
00:50:12,530 --> 00:50:14,060
只有当 n 为 0 时，

956
00:50:14,240 --> 00:50:17,210
我们才会终止 coordinator ，

957
00:50:17,600 --> 00:50:21,620
确保我们已经获取了所有网页，

958
00:50:21,650 --> 00:50:23,030
我们想要爬取的。

959
00:50:23,910 --> 00:50:25,110
如果你查看 worker ，

960
00:50:25,110 --> 00:50:26,430
worker 调用 Fetch ，

961
00:50:26,430 --> 00:50:29,670
这个调用是与其他 worker 并行发生的。

962
00:50:30,190 --> 00:50:34,960
如果它从网页获取了一些 url ，

963
00:50:34,960 --> 00:50:37,720
它将所有这些 url 写入通道，

964
00:50:37,870 --> 00:50:42,040
coordinator 通过 range 语句获取所有这些通道，

965
00:50:43,180 --> 00:50:44,590
然后当它完成的时候，

966
00:50:44,590 --> 00:50:47,320
通过通道写入所有 url ，

967
00:50:47,440 --> 00:50:50,440
然后 coordinator worker 退出，

968
00:50:50,440 --> 00:50:55,750
在某一时刻，减少 n ，

969
00:50:55,750 --> 00:50:57,880
然后在最后，

970
00:50:58,920 --> 00:50:59,940
基本上就是这样。

971
00:51:01,180 --> 00:51:01,840
好的?

972
00:51:02,470 --> 00:51:03,670
所以这就是两个解决方案，

973
00:51:03,700 --> 00:51:05,650
关于这些，有什么问题吗？

974
00:51:12,720 --> 00:51:13,560
都清楚了吗？

975
00:51:16,100 --> 00:51:17,510
聊天中有个问题。

976
00:51:17,720 --> 00:51:21,980
好的，让我找回我的聊天列表。

977
00:51:32,770 --> 00:51:34,930
好的，所以问题是，

978
00:51:35,140 --> 00:51:37,030
当 ch 有值时，

979
00:51:37,060 --> 00:51:40,210
当所有其他线程空闲时，

980
00:51:40,210 --> 00:51:41,350
如果是这种情况，

981
00:51:41,350 --> 00:51:44,260
由于这不是缓冲通道，

982
00:51:44,260 --> 00:51:47,560
通道中同时只会有一个请求，

983
00:51:48,170 --> 00:51:52,370
所有线程都会被一个接一个地加到通道中。

984
00:51:54,010 --> 00:51:56,410
但这不是让程序顺序化了吗，

985
00:51:56,410 --> 00:51:58,390
因为没有两个线程并行运行，

986
00:51:58,570 --> 00:52:00,130
除了主线程和一个线程。

987
00:52:00,880 --> 00:52:02,950
好的， fetcher 仍然会并行发生，

988
00:52:04,080 --> 00:52:05,820
这些是昂贵的操作，

989
00:52:06,090 --> 00:52:07,740
这些需要通过互联网。

990
00:52:09,350 --> 00:52:10,580
知道了，谢谢。

991
00:52:14,040 --> 00:52:17,310
好的，让我切换回我的另一个屏幕，

992
00:52:17,890 --> 00:52:20,950
稍微讨论一下 RPC ，

993
00:52:20,980 --> 00:52:24,400
因为这是实验里需要的另一个工具。

994
00:52:27,540 --> 00:52:29,100
关于这个我们不会说太多，

995
00:52:29,100 --> 00:52:34,820
但是 RPC 表示远程过程调用。

996
00:52:41,680 --> 00:52:46,870
RPC 系统的目标，

997
00:52:46,870 --> 00:52:48,310
比如一个目标是，

998
00:52:48,310 --> 00:52:53,260
RPC 的行为与过程调用大致相似，

999
00:52:53,290 --> 00:52:56,390
在栈上运行的本地过程调用，

1000
00:52:56,390 --> 00:52:58,010
所以目标是，

1001
00:52:58,010 --> 00:52:59,570
如果你有一个客户端，

1002
00:53:00,260 --> 00:53:04,460
在 RPC 术语中，调用方通常称为客户端，

1003
00:53:04,460 --> 00:53:07,220
被呼叫方称为服务器。

1004
00:53:07,820 --> 00:53:10,790
所以你有一个函数 fn ，

1005
00:53:10,790 --> 00:53:13,010
使用 x y 调用，

1006
00:53:13,190 --> 00:53:14,720
然后在服务器上，

1007
00:53:14,780 --> 00:53:16,430
有这个函数的实现。

1008
00:53:18,560 --> 00:53:22,190
所以有一个函数 fn(x, y int) ，

1009
00:53:22,820 --> 00:53:26,930
它返回，无论做什么计算，

1010
00:53:26,930 --> 00:53:31,270
可以返回 x+y 。

1011
00:53:33,580 --> 00:53:36,820
所以，我们希望发生的事，

1012
00:53:36,820 --> 00:53:40,450
或者我们考虑的模型是，

1013
00:53:40,540 --> 00:53:43,210
当客户端调用该函数 fn 时，

1014
00:53:43,390 --> 00:53:45,850
RPC 系统会确保，

1015
00:53:45,850 --> 00:53:49,480
在服务器端发生对应的应用程序，

1016
00:53:49,920 --> 00:53:53,040
将参数 x 和 y 传递给服务器，

1017
00:53:53,100 --> 00:53:54,750
代码在服务器上运行，

1018
00:53:54,900 --> 00:53:58,440
它会返回你看到的结果，

1019
00:53:59,040 --> 00:54:02,160
那个结果是向客户端发回信息，

1020
00:54:02,430 --> 00:54:06,990
然后 fn 恢复，返回，

1021
00:54:06,990 --> 00:54:08,490
客户端会返回，

1022
00:54:08,490 --> 00:54:11,310
将返回 x+y ，

1023
00:54:11,310 --> 00:54:14,120
返回 x+y 的值到 z 。

1024
00:54:14,480 --> 00:54:15,350
所以这看起来，

1025
00:54:15,350 --> 00:54:17,660
尽管这些程序运行在不同的计算机上，

1026
00:54:17,960 --> 00:54:19,940
它们实际上在这里是有界限的，

1027
00:54:20,060 --> 00:54:24,020
看起来像做一个普通的过程调用，

1028
00:54:24,920 --> 00:54:26,630
我们一会会看到，

1029
00:54:26,630 --> 00:54:29,750
实际上，我们可以找到很多相似之处，

1030
00:54:29,750 --> 00:54:32,120
所以让它们的行为非常相似，

1031
00:54:32,210 --> 00:54:34,580
但你也会发现有一个根本的不同，

1032
00:54:34,580 --> 00:54:36,620
与分布式计算有关系。

1033
00:54:38,040 --> 00:54:38,910
但在到达那里之前，

1034
00:54:38,910 --> 00:54:42,540
首先我大概说一下它是如何工作的。

1035
00:54:43,300 --> 00:54:45,340
这是一种粗略的 Go 说做的。

1036
00:54:45,670 --> 00:54:48,190
所以，你可以这样想，

1037
00:54:48,220 --> 00:54:49,210
当客户端，

1038
00:54:50,060 --> 00:54:51,650
所以这是我们的程序，

1039
00:54:52,660 --> 00:54:56,470
当客户端使用 x y 调用函数 fn 时，

1040
00:54:57,210 --> 00:55:00,150
它实际上调用的称为 stub 的东西，

1041
00:55:01,350 --> 00:55:03,480
stub 是本地函数，

1042
00:55:03,510 --> 00:55:08,220
调用 fn ，并用两个参数 x 和 y ，

1043
00:55:08,370 --> 00:55:09,930
stub 所做的，

1044
00:55:11,280 --> 00:55:13,260
考虑这是一个 stub 过程，

1045
00:55:13,350 --> 00:55:15,390
stub 过程所做的，

1046
00:55:15,390 --> 00:55:20,080
构建一个消息，表示哪个函数需要被调用，

1047
00:55:20,380 --> 00:55:22,330
函数的参数，

1048
00:55:22,330 --> 00:55:24,640
参数的类型，

1049
00:55:24,640 --> 00:55:27,580
参数的值等等。

1050
00:55:28,130 --> 00:55:31,430
然后 stub 所做的，

1051
00:55:31,430 --> 00:55:33,110
它通过网络发送，

1052
00:55:33,290 --> 00:55:35,810
到服务器上对应的 stub ，

1053
00:55:39,010 --> 00:55:41,080
服务器接收到这个消息，

1054
00:55:42,000 --> 00:55:45,330
取得这个消息，

1055
00:55:46,040 --> 00:55:49,790
反序列化它，这是一个术语，

1056
00:55:49,790 --> 00:55:50,660
它用来，

1057
00:55:50,660 --> 00:55:58,220
将值从字节数组转换回值，

1058
00:55:58,870 --> 00:56:02,770
然后在服务器上调用这个函数 fn ，

1059
00:56:02,950 --> 00:56:07,220
这是 fn x 等等。

1060
00:56:09,620 --> 00:56:11,300
所以， stub 调用这个函数，

1061
00:56:11,300 --> 00:56:13,460
这个函数返回到 stub ，

1062
00:56:14,050 --> 00:56:19,330
这个 stub 序列化响应值，比如 z x+y ，

1063
00:56:19,990 --> 00:56:24,950
它返回到客户端 stub ，

1064
00:56:24,980 --> 00:56:26,270
而且客户端 stub 仍在等待，

1065
00:56:26,270 --> 00:56:28,370
所以，客户端 stub 的工作方式，

1066
00:56:28,370 --> 00:56:30,770
它发出请求，然后等待响应，

1067
00:56:30,890 --> 00:56:32,510
当响应回来的时候，

1068
00:56:32,840 --> 00:56:34,190
它反序列化，

1069
00:56:38,120 --> 00:56:40,910
然后将值返回给客户端。

1070
00:56:40,910 --> 00:56:42,710
所以，这两个 stub ，

1071
00:56:43,040 --> 00:56:47,630
使远程过程调用看起来像是常规过程调用，

1072
00:56:47,810 --> 00:56:49,040
因为你几乎看不出来。

1073
00:56:49,820 --> 00:56:55,790
这些键，这些 stub 通常是自动生成的，

1074
00:56:56,390 --> 00:56:58,700
在 Go 的编译器中，

1075
00:56:58,700 --> 00:57:00,440
会为你生成两个 stub ，

1076
00:57:00,530 --> 00:57:05,030
并为你序列化和反序列化参数，

1077
00:57:06,200 --> 00:57:09,320
这就是它说做的。

1078
00:57:09,650 --> 00:57:14,150
所以当你从服务器到客户端时，

1079
00:57:14,150 --> 00:57:15,860
还有另一个 stub 吗？

1080
00:57:16,190 --> 00:57:19,250
你会返回到第一个 stub 。

1081
00:57:19,700 --> 00:57:21,740
所以这个 stub 发出一个过程调用，

1082
00:57:21,740 --> 00:57:23,900
发出一个过程调用 fn ，

1083
00:57:24,200 --> 00:57:26,300
这个过程直接返回到 stub ，

1084
00:57:26,300 --> 00:57:27,740
因为 stub 调用的它。

1085
00:57:27,950 --> 00:57:29,870
哦，这是同一个 stub 。

1086
00:57:30,170 --> 00:57:30,830
没错。

1087
00:57:31,780 --> 00:57:32,410
明白了。

1088
00:57:33,060 --> 00:57:33,450
好的?

1089
00:57:34,940 --> 00:57:39,920
好的，让我来展示这是如何在 Go 中进行的，

1090
00:57:43,320 --> 00:57:48,060
通过展示一个非常简单的键值服务器。

1091
00:57:50,010 --> 00:57:50,760
你会看到，

1092
00:57:50,760 --> 00:57:52,920
它看起来不完全是我们的过程调用，

1093
00:57:52,920 --> 00:57:54,270
但已经很接近了。

1094
00:57:54,920 --> 00:57:57,380
所以典型的情况是，

1095
00:57:57,380 --> 00:58:01,190
在 Go 中的典型转换，

1096
00:58:01,190 --> 00:58:06,530
你声明参数结构，

1097
00:58:06,530 --> 00:58:08,570
所以，我们将实现两个过程，

1098
00:58:09,020 --> 00:58:09,800
两个远程过程，

1099
00:58:09,800 --> 00:58:11,210
一个是 put ，一个是 get ，

1100
00:58:11,630 --> 00:58:13,760
put 的参数是，

1101
00:58:13,760 --> 00:58:16,160
参数通过 put ， put 返回响应，

1102
00:58:16,160 --> 00:58:18,680
类似地，有一个 get 参数请求，

1103
00:58:18,680 --> 00:58:22,400
参数通过 get 请求，然后返回。

1104
00:58:23,690 --> 00:58:25,310
所以让我先来看服务器，

1105
00:58:25,340 --> 00:58:26,810
这里有两个函数，

1106
00:58:26,900 --> 00:58:31,130
是我们要在服务器上调用的两个函数，

1107
00:58:31,840 --> 00:58:34,540
我想我先跳过这一步。

1108
00:58:35,370 --> 00:58:37,770
所以我们实际上。

1109
00:58:41,220 --> 00:58:43,080
让我稍微说一下，

1110
00:58:43,080 --> 00:58:44,550
这是客户端，

1111
00:58:45,180 --> 00:58:47,100
客户端调用一个函数 get ，

1112
00:58:47,130 --> 00:58:49,410
在 get 之中，

1113
00:58:49,410 --> 00:58:52,440
这个函数连接到服务器，

1114
00:58:52,440 --> 00:58:53,850
看看这到底是什么意思，

1115
00:58:54,330 --> 00:58:56,760
它填充了参数，

1116
00:58:56,760 --> 00:58:57,900
并分配响应，

1117
00:58:57,900 --> 00:59:00,540
然后调用这个过程调用 client.Call ，

1118
00:59:00,570 --> 00:59:02,580
你可以认为这是一个通用的 stub ，

1119
00:59:02,940 --> 00:59:05,700
使用需要在服务端调用的方法，

1120
00:59:05,730 --> 00:59:07,140
以及参数和响应，

1121
00:59:07,500 --> 00:59:09,000
所以 Call 有三个参数，

1122
00:59:09,180 --> 00:59:12,220
方法，参数和响应，

1123
00:59:13,200 --> 00:59:17,430
而 Call 内部会发送序列化的参数，

1124
00:59:17,730 --> 00:59:20,940
通过连接发送消息到服务器，

1125
00:59:21,180 --> 00:59:23,490
等待响应返回，

1126
00:59:23,490 --> 00:59:24,570
当响应回来时，

1127
00:59:24,570 --> 00:59:27,330
reply 结构由 Call stub 填充，

1128
00:59:27,540 --> 00:59:28,740
然后当这件事完成后，

1129
00:59:28,740 --> 00:59:30,690
然后返回到 Call 调用。

1130
00:59:32,240 --> 00:59:34,190
基本上， put 看起来是完全一样的。

1131
00:59:36,680 --> 00:59:37,850
所以，在服务器端，

1132
00:59:38,210 --> 00:59:39,770
让我们看看这是如何实现的，

1133
00:59:40,360 --> 00:59:42,280
服务器有键值映射，

1134
00:59:42,280 --> 00:59:45,190
只是一个常规的 Go 映射，

1135
00:59:45,700 --> 00:59:52,380
让我看看键值结构，

1136
00:59:55,450 --> 00:59:57,340
在某个地方声明的，

1137
00:59:58,930 --> 01:00:00,340
哦，抱歉，它就在上面。

1138
01:00:00,820 --> 01:00:02,740
所以这里有一个结构叫做 KV ，

1139
01:00:02,770 --> 01:00:05,230
它有一个互斥锁和一个映射，

1140
01:00:05,530 --> 01:00:08,260
这个映射是我们要放入和获取操作的。

1141
01:00:10,320 --> 01:00:12,120
这里有一个小的前言，

1142
01:00:12,120 --> 01:00:15,330
你需要编写来设置服务器，

1143
01:00:15,600 --> 01:00:16,710
但就是这样，

1144
01:00:16,980 --> 01:00:21,690
基本上，分配一个新的服务器对象，

1145
01:00:22,020 --> 01:00:27,330
然后这里是键操作 rpcs.Register(kv) ，

1146
01:00:27,360 --> 01:00:29,760
注册所有方法，

1147
01:00:29,760 --> 01:00:33,690
在 RPC 服务器上 KV 结构上实现的方法，

1148
01:00:35,010 --> 01:00:42,360
不同的是，这些由大写字母命名的方法，

1149
01:00:43,200 --> 01:00:45,990
用大写字母的方法会被记录，

1150
01:00:46,080 --> 01:00:51,300
Go 使用大写字母名称来表示公共方法，

1151
01:00:51,300 --> 01:00:56,790
而小写的方法是私有方法，

1152
01:00:57,120 --> 01:01:02,550
所以， rpcs.Register 只导出大写的方法，

1153
01:01:02,820 --> 01:01:04,140
例如，下面是一个方法，

1154
01:01:04,140 --> 01:01:06,720
这里是 Get 方法，它有大写字母，

1155
01:01:07,020 --> 01:01:09,030
通过调用 Register ，

1156
01:01:09,030 --> 01:01:11,940
这个方法可以通过客户端调用服务端。

1157
01:01:14,040 --> 01:01:15,480
所以，在服务器内部，

1158
01:01:15,510 --> 01:01:19,260
它创建一个 TCP 连接，

1159
01:01:19,260 --> 01:01:21,000
并等待 TCP 连接，

1160
01:01:21,000 --> 01:01:25,170
获得 TCP 连接的返回，

1161
01:01:25,170 --> 01:01:29,880
然后调用 rpcs.ServeConn 来提供 TCP 连接，

1162
01:01:30,380 --> 01:01:34,220
基本上，每一条通过连接的消息，

1163
01:01:34,400 --> 01:01:36,680
它会自动找到正确的方法，

1164
01:01:36,740 --> 01:01:38,780
与消息相关联，

1165
01:01:38,960 --> 01:01:43,610
使用反序列化的参数调用方法，并序列化回复。

1166
01:01:45,380 --> 01:01:47,240
例如，如果客户端调用 GET ，

1167
01:01:47,240 --> 01:01:51,290
它使这个连接存在，

1168
01:01:51,650 --> 01:01:54,290
然后，如果客户端使用 Get 调用 Call ，

1169
01:01:54,470 --> 01:01:56,300
然后将运行这个 Get 函数。

1170
01:01:57,280 --> 01:01:58,750
如你所见，这个 Get 函数，

1171
01:01:58,750 --> 01:01:59,530
它做的第一件事是，

1172
01:01:59,530 --> 01:02:00,670
它先获取一个锁，

1173
01:02:00,670 --> 01:02:04,870
因为多个客户端可能会调用服务器，

1174
01:02:04,870 --> 01:02:07,960
会有多个 goroutine 同时运行，

1175
01:02:07,990 --> 01:02:09,760
也许会调用 Get 和 Put ，

1176
01:02:10,580 --> 01:02:14,150
它们同时操作映射，

1177
01:02:14,150 --> 01:02:15,320
所以，我们需要确保，

1178
01:02:15,320 --> 01:02:18,710
这些是以原子的方式完成的，

1179
01:02:19,240 --> 01:02:20,710
所以，我们使用锁。

1180
01:02:22,210 --> 01:02:25,870
所以， Get 函数查看映射中的键，

1181
01:02:25,870 --> 01:02:29,080
查看映射中的键，然后返回值，

1182
01:02:29,580 --> 01:02:31,830
如果映射中没有条目，

1183
01:02:31,830 --> 01:02:34,020
它将返回 ErrNoKey ，

1184
01:02:34,020 --> 01:02:37,020
否则，它会返回适当的值，

1185
01:02:37,170 --> 01:02:37,710
就是这样。

1186
01:02:38,490 --> 01:02:40,140
在服务器端，

1187
01:02:40,140 --> 01:02:41,730
当这些 Get 函数返回时，

1188
01:02:41,730 --> 01:02:44,010
它会序列化自己的回应，

1189
01:02:44,340 --> 01:02:45,930
将响应发回客户端，

1190
01:02:45,930 --> 01:02:48,270
客户端对其进行反序列化，

1191
01:02:48,270 --> 01:02:49,830
并将其返回给调用者。

1192
01:02:52,880 --> 01:02:54,530
好的，这能理解吗？

1193
01:02:54,560 --> 01:03:00,350
所以这是在做一个简单的键值服务器。

1194
01:03:08,690 --> 01:03:10,460
好的，我想再说一点，

1195
01:03:10,460 --> 01:03:11,720
这是很重要的一点，

1196
01:03:11,840 --> 01:03:14,270
最后，

1197
01:03:15,150 --> 01:03:17,040
重要的是要考虑的是，

1198
01:03:17,040 --> 01:03:19,980
RPC 失败的语义是什么。

1199
01:03:31,600 --> 01:03:33,760
所以可能存在不同类型的语义，

1200
01:03:34,460 --> 01:03:36,140
某些东西称为至少调用一次，

1201
01:03:37,800 --> 01:03:39,150
这一切所做的，

1202
01:03:39,150 --> 01:03:41,610
如果服务器发生故障，客户端所做的事情。

1203
01:03:42,000 --> 01:03:45,960
我们假设客户端发送了请求，然后服务器崩溃了，

1204
01:03:46,940 --> 01:03:51,230
当然，在某个时刻，客户端将会超时，

1205
01:03:51,260 --> 01:03:54,380
它不知道操作是否真的发生了，

1206
01:03:55,420 --> 01:03:58,540
至少一次 RPC 语义意味着，

1207
01:03:58,540 --> 01:04:01,690
客户端将自动重试并继续，

1208
01:04:01,690 --> 01:04:03,850
所以它至少执行一次。

1209
01:04:06,020 --> 01:04:08,180
至少一次的缺点是，

1210
01:04:08,180 --> 01:04:10,910
同一个操作可能会被多次执行，

1211
01:04:10,940 --> 01:04:12,290
比如，如果你做一个 put ，

1212
01:04:12,350 --> 01:04:14,780
put 可能会被执行多次，

1213
01:04:14,780 --> 01:04:16,250
在至少一次 RPC 系统中。

1214
01:04:17,580 --> 01:04:19,800
所以这并不适用于许多应用程序，

1215
01:04:20,130 --> 01:04:22,170
所以，另一种语义，

1216
01:04:22,170 --> 01:04:24,840
常出现在 RPC 系统中的是最多一次，

1217
01:04:27,830 --> 01:04:35,270
相应的服务器请求执行零次或一次，

1218
01:04:35,270 --> 01:04:36,560
但不会超过一次，

1219
01:04:37,210 --> 01:04:40,600
它实现的方式是通过过滤重复，

1220
01:04:40,720 --> 01:04:45,280
你会在后面的实验中做这个，

1221
01:04:46,280 --> 01:04:47,480
可能是这种情况，

1222
01:04:47,480 --> 01:04:49,310
两个请求到达，

1223
01:04:49,670 --> 01:04:52,550
也许网络临时分裂，

1224
01:04:52,550 --> 01:04:53,810
服务器收到了这两个请求，

1225
01:04:53,810 --> 01:04:55,430
服务器必须安排，

1226
01:04:55,550 --> 01:04:59,690
它检测到重新发送的请求，并且不执行两次。

1227
01:05:01,390 --> 01:05:03,070
当然，理想情况下，

1228
01:05:03,660 --> 01:05:05,280
你可能需要正好一次，

1229
01:05:06,060 --> 01:05:08,550
因为这是正常过程所做的，

1230
01:05:08,610 --> 01:05:12,690
就像你在一个正常的顺序程序中调用过程，

1231
01:05:12,690 --> 01:05:14,160
正好执行一次，

1232
01:05:14,160 --> 01:05:16,800
它永远不可能是至少一次或最多一次。

1233
01:05:17,330 --> 01:05:19,400
事实证明，这很难[安排]，

1234
01:05:20,220 --> 01:05:25,350
这需要管理状态在磁盘上，

1235
01:05:25,350 --> 01:05:27,540
而且往往很昂贵，

1236
01:05:27,540 --> 01:05:31,230
事实上，很少有 RPC 系统是正好一次，

1237
01:05:31,500 --> 01:05:32,610
虽然在实验中，

1238
01:05:32,610 --> 01:05:34,530
你要在实验 3 中构建一个，

1239
01:05:34,740 --> 01:05:38,010
你需要构建一个正好一次的 RPC 系统。

1240
01:05:38,890 --> 01:05:39,610
好的?

1241
01:05:40,160 --> 01:05:45,710
实际上， Go 的 RPC 系统是最多一次，

1242
01:05:45,740 --> 01:05:46,940
所以如果你发起一个调用，

1243
01:05:47,090 --> 01:05:49,040
你通过 TCP 通道进行调用，

1244
01:05:49,040 --> 01:05:51,620
TCP 通道将确保不存在重复项，

1245
01:05:52,010 --> 01:05:58,280
RPC 系统要么执行一次，要么根本不执行，

1246
01:05:58,310 --> 01:06:00,590
然后在这种情况下，返回一个错误，

1247
01:06:01,580 --> 01:06:03,890
然后当然应用程序可以重试，

1248
01:06:03,920 --> 01:06:05,690
但这是应用程序的责任，

1249
01:06:05,690 --> 01:06:08,810
处理重复和失败消息的问题。

1250
01:06:10,700 --> 01:06:13,280
好的，这就是关键点，

1251
01:06:13,640 --> 01:06:15,020
它们的失败，

1252
01:06:15,200 --> 01:06:20,720
使 RPC 与过程调用不同，

1253
01:06:21,200 --> 01:06:22,280
所以目标是，

1254
01:06:22,280 --> 01:06:25,370
让它们看起来尽可能地相似，实际上并不完全相同，

1255
01:06:25,400 --> 01:06:31,910
导致出现差异的是故障或服务器崩溃。

1256
01:06:35,550 --> 01:06:39,270
关于 RPC 的快速介绍，有什么问题吗？

1257
01:06:47,190 --> 01:06:49,740
好的，如果没有，我就在这里结束了，

1258
01:06:49,740 --> 01:06:51,060
所以有些人需要离开，

1259
01:06:51,060 --> 01:06:52,680
或者学生需要上下一节课，

1260
01:06:52,680 --> 01:06:53,760
你可以去下一节课，

1261
01:06:53,760 --> 01:06:54,720
我会在线，

1262
01:06:54,720 --> 01:06:56,190
所以如果还有什么问题，

1263
01:06:56,190 --> 01:06:59,720
我很乐意回答，

1264
01:06:59,870 --> 01:07:01,460
在这里逗留一段时间。

1265
01:07:03,230 --> 01:07:05,810
同时，享受实验 1 ，并祝你们好运。

