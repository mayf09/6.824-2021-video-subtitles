1
00:00:00,540 --> 00:00:01,440
好的，谢谢。

2
00:00:02,130 --> 00:00:05,670
好的，下午好，傍晚好，早上好，晚上好，无论你在哪里，

3
00:00:05,850 --> 00:00:08,940
今天我们要谈的是事务。

4
00:00:09,720 --> 00:00:11,760
你们可能注意到了，

5
00:00:11,760 --> 00:00:15,330
今天的阅读材料本质上更多是教程，

6
00:00:15,360 --> 00:00:17,520
我们不是在研究一个特定的系统，

7
00:00:17,520 --> 00:00:23,280
看看一系列的想法是如何在这个系统中实现的，

8
00:00:23,280 --> 00:00:29,520
相反，我们要做的只是谈论事务的概念，

9
00:00:29,520 --> 00:00:33,570
因为它会出现在接下来的两个论文中，

10
00:00:33,570 --> 00:00:36,060
我们将研究这两篇论文，

11
00:00:36,060 --> 00:00:39,450
其中有相当多的材料，

12
00:00:39,450 --> 00:00:42,810
假设对事务很熟悉，

13
00:00:42,930 --> 00:00:48,390
特别是你们熟悉我们今天课程中的两个核心思想，

14
00:00:48,390 --> 00:00:57,950
也就是两阶段锁和两阶段提交，

15
00:01:06,430 --> 00:01:10,390
有时，它们被缩写， 2PC 表示两阶段提交，

16
00:01:10,390 --> 00:01:13,060
2PL 表示两阶段锁，

17
00:01:13,750 --> 00:01:15,730
有一点令人困惑，

18
00:01:16,030 --> 00:01:19,090
这两个术语不需要做太多事情，

19
00:01:19,090 --> 00:01:20,590
不需要，

20
00:01:21,380 --> 00:01:23,000
没有什么关系，

21
00:01:23,030 --> 00:01:28,670
他们碰巧有两个词 2-phase ，

22
00:01:28,910 --> 00:01:31,610
但是，它们表现完全不同的问题，

23
00:01:31,640 --> 00:01:35,930
它们还出现在事务的背景下，

24
00:01:36,110 --> 00:01:38,300
但是即使在事务之外，

25
00:01:38,300 --> 00:01:41,900
它们也是好想法或有价值的想法，

26
00:01:42,420 --> 00:01:46,410
所以不要让你自己被他们都有 2-phase 所迷惑，

27
00:01:46,620 --> 00:01:48,540
它们没什么关系。

28
00:01:50,090 --> 00:01:52,370
好的，所以我要稍微深入一点，

29
00:01:52,370 --> 00:01:54,860
开始谈论一般的事务，

30
00:01:55,220 --> 00:02:01,610
我们非常关注事务的原因是，

31
00:02:01,640 --> 00:02:05,330
我们希望能够进行跨机器操作。

32
00:02:06,360 --> 00:02:08,700
所以我们尝试解决的问题，

33
00:02:11,220 --> 00:02:14,190
在这个课程以及即将看到的两篇论文中，

34
00:02:14,460 --> 00:02:22,030
是跨机器的原子操作。

35
00:02:25,890 --> 00:02:28,530
举个例子，让它变得更具体，

36
00:02:28,560 --> 00:02:30,570
假设我们有一个客户端，

37
00:02:31,250 --> 00:02:34,040
我们有两个，

38
00:02:34,700 --> 00:02:36,710
我们有一个分片的键值服务器，

39
00:02:36,770 --> 00:02:40,580
所以一些键在键值服务器 1 上，

40
00:02:41,840 --> 00:02:44,060
一些在键值服务器 2 上，

41
00:02:44,830 --> 00:02:46,750
所以键分布在它们上面，

42
00:02:46,750 --> 00:02:51,340
例如， kv1 有 x ， kv2 有 y ，

43
00:02:51,940 --> 00:02:56,080
我们想要跨这两个键进行原子操作，

44
00:02:56,080 --> 00:03:00,820
在事务的背景下，简单的方法或经典的例子

45
00:03:01,000 --> 00:03:02,500
总是进行转账。

46
00:03:03,290 --> 00:03:08,030
假设客户端想要进行从 x 到 y 的转账，

47
00:03:09,140 --> 00:03:10,190
这是我们的客户端，

48
00:03:10,580 --> 00:03:15,920
它会对 x 做一次 put ，

49
00:03:15,920 --> 00:03:21,080
从帐户中增加或减少，

50
00:03:21,080 --> 00:03:22,460
所以我们做 x,-1 ，

51
00:03:23,090 --> 00:03:28,370
然后客户端要做 put(y,+1) ，

52
00:03:29,430 --> 00:03:34,470
从账户 x 向账户 y 转账一美元。

53
00:03:35,460 --> 00:03:37,590
我们的目标是，

54
00:03:40,300 --> 00:03:50,020
我们希望在故障和并发方面保持原子性。

55
00:03:55,540 --> 00:04:00,310
所以，即使第一个 kv ，

56
00:04:00,310 --> 00:04:03,730
第一个键值服务器在 put 之后失败，

57
00:04:04,030 --> 00:04:07,030
那么我们想要安排，

58
00:04:07,030 --> 00:04:08,860
转账根本不会发生，

59
00:04:08,890 --> 00:04:11,380
所以，我们要寻找的语义是，

60
00:04:11,410 --> 00:04:14,620
这两种操作都会发生或者都不会发生。

61
00:04:15,190 --> 00:04:17,500
所以，从并发性的角度来看，

62
00:04:17,500 --> 00:04:19,030
如果另一个客户端正在运行，

63
00:04:19,030 --> 00:04:21,070
并且尝试检查这些帐户，

64
00:04:21,160 --> 00:04:23,260
现在我们想要的是

65
00:04:23,260 --> 00:04:25,930
这两个 put 原子地显示，

66
00:04:25,930 --> 00:04:30,100
所以其他事务不能观察到中间结果，

67
00:04:30,100 --> 00:04:31,420
中间结果，

68
00:04:31,420 --> 00:04:33,670
比如，钱从 x 中减去，

69
00:04:33,700 --> 00:04:35,260
没有加到 y 上。

70
00:04:36,070 --> 00:04:38,740
所以，这些就是我们想要做的事情，

71
00:04:38,920 --> 00:04:41,170
这在分布式系统中非常常见，

72
00:04:41,170 --> 00:04:45,490
比如你希望跨分片执行操作。

73
00:04:48,130 --> 00:04:52,630
所以，这就是我们想要做的事情的背景，

74
00:04:52,930 --> 00:04:57,610
这样做的总体方案来自数据库社区，

75
00:04:58,030 --> 00:05:00,790
这个总体方案就是事务。

76
00:05:09,780 --> 00:05:13,650
我们想要做的是对这些操作进行分组，

77
00:05:13,650 --> 00:05:15,360
例如，在转账的情况中，

78
00:05:15,360 --> 00:05:18,120
两个 put 操作作为一个事务。

79
00:05:18,700 --> 00:05:23,320
然后，这个事务原子地执行，

80
00:05:23,530 --> 00:05:26,950
这通常需要一些编程注解，

81
00:05:28,820 --> 00:05:34,850
所以 begin_x 表示客户端想要启动事务，

82
00:05:34,880 --> 00:05:41,320
然后可能是 add 操作， add(x,-1) ，

83
00:05:41,680 --> 00:05:45,550
然后 add(y,+1) ，

84
00:05:46,570 --> 00:05:50,110
然后，你必须指明事务何时完成，

85
00:05:51,250 --> 00:05:55,450
通常我们使用 commit 。

86
00:05:56,410 --> 00:06:00,430
所以，我们寻找的语义是，

87
00:06:00,430 --> 00:06:03,490
这些操作原子地执行，

88
00:06:03,520 --> 00:06:06,520
对于并发和故障。

89
00:06:07,060 --> 00:06:08,860
为了让它更激动人心，

90
00:06:08,860 --> 00:06:10,360
让我们来看看第二个事务，

91
00:06:10,360 --> 00:06:12,910
我们可以看一些案例研究，

92
00:06:12,910 --> 00:06:15,160
关于事务如何[互动]，

93
00:06:15,370 --> 00:06:19,240
我们可能有第二个事务 begin_x ，

94
00:06:19,960 --> 00:06:23,560
它读取这些账户，

95
00:06:24,460 --> 00:06:30,870
所以 t1 得到 x ，然后 t2 得到 y ，

96
00:06:33,120 --> 00:06:37,770
并打印 t1 和 t2 ，

97
00:06:37,950 --> 00:06:42,000
然后结束或 commit 。

98
00:06:47,590 --> 00:06:48,850
所以，我们有第二个事务，

99
00:06:48,850 --> 00:06:51,880
它读取帐户 x 和 y ，并打印值。

100
00:06:52,180 --> 00:06:55,420
我们有两个事务的一个原因是，

101
00:06:55,420 --> 00:06:57,370
我们可以从并发性的角度来看，

102
00:06:57,580 --> 00:06:59,860
这些事务是如何排序的，

103
00:06:59,860 --> 00:07:02,650
什么是合法结果，什么是非法结果。

104
00:07:03,540 --> 00:07:09,540
事务就像是一个魔法，

105
00:07:09,570 --> 00:07:14,940
程序员可以注解这些 begin 和 end 操作，

106
00:07:15,060 --> 00:07:17,850
它使一组操作一起，

107
00:07:17,850 --> 00:07:18,750
使它们原子化，

108
00:07:18,870 --> 00:07:20,640
使用这个系统会处理好一切，

109
00:07:20,640 --> 00:07:22,050
它会负责锁，

110
00:07:22,200 --> 00:07:23,730
会负责恢复，

111
00:07:23,790 --> 00:07:25,980
程序员不必担心这个问题，

112
00:07:26,160 --> 00:07:30,210
事务是一个非常强大的结构，

113
00:07:30,980 --> 00:07:34,460
它们在非分布式系统中很有用，

114
00:07:34,460 --> 00:07:38,600
你有一台单数据库机器或多核数据库机器，

115
00:07:38,600 --> 00:07:40,610
客户端向它提交事务，

116
00:07:41,000 --> 00:07:43,730
然后事务系统执行这些事务

117
00:07:43,730 --> 00:07:46,190
尽可能并发地（执行），

118
00:07:46,190 --> 00:07:48,980
但即使机器出现故障，它也会恢复正常，

119
00:07:49,010 --> 00:07:53,330
你可以期待结果就在那里。

120
00:07:54,080 --> 00:07:58,550
当然，我们的重点是分布式事务，

121
00:08:02,430 --> 00:08:05,190
在我之前的幻灯片里，

122
00:08:05,250 --> 00:08:09,860
也就是一个跨分片的例子，

123
00:08:09,860 --> 00:08:13,220
这在数据中心很常见。

124
00:08:14,220 --> 00:08:18,450
事务通常的 API 还有一个操作，

125
00:08:18,450 --> 00:08:19,800
我没有列在这里，

126
00:08:19,950 --> 00:08:21,210
也就是 abort ，

127
00:08:23,700 --> 00:08:26,670
这里显示的两个事务都是 commit ，

128
00:08:26,670 --> 00:08:29,610
但是你可以直接终止事务，

129
00:08:29,640 --> 00:08:33,870
比如你可能会发现，

130
00:08:33,930 --> 00:08:37,230
例如，事务 T1 可以检查

131
00:08:37,230 --> 00:08:39,690
x 帐户中是否有足够的钱，

132
00:08:39,960 --> 00:08:42,720
如果账户中没有足够的钱，

133
00:08:42,840 --> 00:08:45,690
不是调用 commit ，而是调用 abort ，

134
00:08:45,840 --> 00:08:49,680
这个时候，事务将被取消，

135
00:08:50,010 --> 00:08:53,370
即使事务在一半时中止，

136
00:08:53,430 --> 00:08:55,920
也许已经做了一些 put 操作，

137
00:08:55,920 --> 00:08:57,270
语义仍然应该是，

138
00:08:57,270 --> 00:08:59,790
这些 put 操作都没有发生。

139
00:09:00,730 --> 00:09:04,540
所以，在所有 abort 或 commit 的情况下，

140
00:09:04,690 --> 00:09:07,240
要么全部发生，要么一个都不发生，

141
00:09:07,510 --> 00:09:08,830
永远不会有部分结果，

142
00:09:09,710 --> 00:09:14,030
事务系统本身也可以调用 abort ，

143
00:09:14,270 --> 00:09:16,250
例如，我们稍后将看到，

144
00:09:16,250 --> 00:09:20,840
如果两个事务之间存在死锁，

145
00:09:20,990 --> 00:09:24,020
则事务系统可以中止其中一个事务，

146
00:09:24,170 --> 00:09:25,460
在，

147
00:09:25,550 --> 00:09:27,320
让其他事务继续，

148
00:09:27,320 --> 00:09:30,200
并且稍后重试已经中止的事务。

149
00:09:31,870 --> 00:09:34,330
好的，这是原语，

150
00:09:34,330 --> 00:09:41,170
begin_x commit 和 abort ，三个关键接口操作。

151
00:09:41,560 --> 00:09:45,670
然后事务的语义

152
00:09:45,670 --> 00:09:50,730
通常由单个词语来概括，即 ACID ，

153
00:09:53,570 --> 00:09:58,370
这代表了事务的四个关键属性。

154
00:09:58,400 --> 00:10:01,210
第一，它是原子的，

155
00:10:04,640 --> 00:10:07,100
这里的原子表示的情况，

156
00:10:07,100 --> 00:10:09,650
我们有两个事务运行，

157
00:10:09,650 --> 00:10:13,850
一个事务执行多个 put 操作或多个 add 操作，

158
00:10:13,970 --> 00:10:15,410
所有这些结果都是，

159
00:10:15,410 --> 00:10:18,920
全部对另一事务可见或者全部不可见，

160
00:10:19,660 --> 00:10:21,160
所以这是一个方面，

161
00:10:21,460 --> 00:10:28,550
抱歉，我说的这个不对，

162
00:10:28,550 --> 00:10:30,890
原子性意思是崩溃恢复的情况，

163
00:10:31,130 --> 00:10:35,900
如果一个事务有多个 put 操作，

164
00:10:35,960 --> 00:10:38,990
事务在中途崩溃，

165
00:10:39,560 --> 00:10:42,650
规则是所有的写入都是可见的，

166
00:10:42,680 --> 00:10:44,990
所有写入都进入存储或都没有，

167
00:10:45,760 --> 00:10:48,430
原子性与崩溃恢复有关。

168
00:10:49,060 --> 00:10:52,150
C 代表一致性，

169
00:10:53,090 --> 00:10:55,430
这是我们不太会谈论的事情，

170
00:10:55,700 --> 00:10:57,920
它更多地与数据库相关，

171
00:10:58,100 --> 00:11:01,130
通常情况下，数据库具有内部变量，

172
00:11:01,130 --> 00:11:04,310
比如参照完整性就是其中之一，

173
00:11:04,460 --> 00:11:09,560
而事务应该保持这种一致性，

174
00:11:10,320 --> 00:11:12,270
所以没有内部一致性，

175
00:11:12,720 --> 00:11:14,880
对于我们今天来说，这不是一个话题。

176
00:11:15,180 --> 00:11:18,930
第三个是隔离性， I 代表隔离性，

177
00:11:23,100 --> 00:11:25,140
隔离性是，

178
00:11:25,170 --> 00:11:27,300
我之前说错的，

179
00:11:27,300 --> 00:11:28,590
隔离性指的是这种情况，

180
00:11:28,590 --> 00:11:30,000
我们运行两个事务，

181
00:11:30,270 --> 00:11:32,730
它们不会看到，

182
00:11:32,730 --> 00:11:34,860
它们不应该观察到彼此的中间结果，

183
00:11:34,890 --> 00:11:38,610
所以应用所有写入，

184
00:11:39,600 --> 00:11:43,650
其他事务看到全部或没有。

185
00:11:44,500 --> 00:11:47,110
最后， D 代表耐久性，

186
00:11:49,410 --> 00:11:51,270
意味着如果事务提交，

187
00:11:51,760 --> 00:11:54,970
结果写入稳定存储，

188
00:11:54,970 --> 00:11:57,520
如果系统崩溃，稍后又恢复，

189
00:11:57,700 --> 00:12:01,360
最新写入或最新事务，

190
00:12:01,360 --> 00:12:05,260
最新提交的事务会记录在稳定存储上。

191
00:12:08,420 --> 00:12:12,110
关于事务的简介，有什么问题吗？

192
00:12:22,210 --> 00:12:27,910
好的，我主要会讲两个话题，

193
00:12:27,910 --> 00:12:32,950
也就是事务的 A 部分和 I 部分，

194
00:12:33,070 --> 00:12:35,840
我们将从 I 部分开始，

195
00:12:36,230 --> 00:12:40,040
稍微讨论一下隔离性是什么。

196
00:12:44,420 --> 00:12:47,150
所以我们要找的是一个定义，

197
00:12:47,480 --> 00:12:51,770
正确执行多个事务或并发事务，

198
00:12:52,330 --> 00:12:56,920
在数据库文献中的典型定义或标准中，

199
00:12:57,040 --> 00:13:06,370
称为可串行化，

200
00:13:08,980 --> 00:13:10,450
这意味着，

201
00:13:10,450 --> 00:13:13,120
如果你有两个或多个事务，

202
00:13:13,120 --> 00:13:14,530
它们同时执行，

203
00:13:14,890 --> 00:13:19,030
那么结果肯定是某种串行的顺序，

204
00:13:20,080 --> 00:13:27,910
所以 t1 在 t2 之前执行，或者 t2 在 t1 之前执行，

205
00:13:27,910 --> 00:13:30,790
有某种串行的顺序，

206
00:13:35,910 --> 00:13:44,320
串行顺序必须产生与并发执行相同的结果，

207
00:13:44,320 --> 00:13:47,260
所以你同时运行两个事务，

208
00:13:47,260 --> 00:13:48,430
它们产生一些结果，

209
00:13:48,550 --> 00:13:51,760
这个结果是有效的、合法的或正确的，

210
00:13:51,940 --> 00:13:56,260
这可能是串行执行的结果。

211
00:13:57,500 --> 00:14:00,470
所以，为了更具体一些，

212
00:14:00,530 --> 00:14:05,150
假设在帐户中 x 从 10 开始，

213
00:14:05,300 --> 00:14:07,160
y 从 10 开始，

214
00:14:07,850 --> 00:14:09,830
我们运行这两个事务，

215
00:14:09,830 --> 00:14:11,570
我们之前在白板上看到的，

216
00:14:12,080 --> 00:14:13,940
这两个事务的内容，

217
00:14:14,300 --> 00:14:18,200
一个是在两个帐户之间移动一，

218
00:14:18,200 --> 00:14:19,790
另一个是打印两个的结果。

219
00:14:21,400 --> 00:14:23,140
所以你稍微想一下，

220
00:14:23,140 --> 00:14:24,370
如果 t1 先执行，

221
00:14:24,860 --> 00:14:28,280
那么结果将是 9,10 ，

222
00:14:29,720 --> 00:14:33,170
而打印语句将是，

223
00:14:40,240 --> 00:14:42,370
是的，打印语句，

224
00:14:42,460 --> 00:14:45,220
实际上这里是 9,10 ，抱歉， 9,11 ，

225
00:14:45,280 --> 00:14:46,450
这就是我困惑的原因，

226
00:14:47,540 --> 00:14:49,760
打印语句也会说，

227
00:14:50,240 --> 00:14:53,300
x 是减去的那个，所以是 9,11 ，

228
00:14:54,570 --> 00:14:56,640
所以我们得到字符串 9,11 ，

229
00:14:56,700 --> 00:15:00,330
两个账户中的值是 9,11 ，

230
00:15:00,420 --> 00:15:03,510
如果 t2 先执行，

231
00:15:03,600 --> 00:15:06,570
那么结果是 10,10 ，

232
00:15:06,690 --> 00:15:08,430
因为钱还没有动过，

233
00:15:08,790 --> 00:15:12,000
然后 t1 开始，

234
00:15:12,000 --> 00:15:13,470
所以这是一种可能的结果。

235
00:15:14,960 --> 00:15:18,380
所以这是两个事务的两种合法的输出，

236
00:15:18,380 --> 00:15:20,630
我们，

237
00:15:20,960 --> 00:15:23,450
如果我们同时执行这两个事务，

238
00:15:23,450 --> 00:15:26,960
系统保证可串行化。

239
00:15:27,690 --> 00:15:32,940
现在你注意到，可串行化有很多特点，

240
00:15:32,940 --> 00:15:36,360
就像我们之前使用的术语线性一致性，

241
00:15:36,950 --> 00:15:40,640
可串行化和可线性化之间的关键区别在于，

242
00:15:40,640 --> 00:15:44,480
在线性一致性中，有一个实时的组件，

243
00:15:44,480 --> 00:15:49,430
如果 t2 在 t1 结束后开始，

244
00:15:49,520 --> 00:15:52,940
那么 t2 必须在整体顺序中出现在后面，

245
00:15:52,970 --> 00:15:53,900
在串行化顺序中，

246
00:15:54,200 --> 00:15:56,390
在可串行化中，那是不需要的，

247
00:15:56,420 --> 00:15:58,040
所以，如果事务开始，

248
00:15:58,280 --> 00:16:03,080
在时间上晚于另一个事务停止或结束，

249
00:16:03,290 --> 00:16:06,740
系统仍然允许对它重新排序，

250
00:16:07,980 --> 00:16:12,510
所以可串行化在某些方面比可线性化要弱一些。

251
00:16:13,610 --> 00:16:18,920
尽管如此，可序列化是一个非常方便的编程[思想]，

252
00:16:18,920 --> 00:16:21,440
因为从编程的角度来看，

253
00:16:21,590 --> 00:16:25,100
你总是可以考虑事务以某种顺序执行，

254
00:16:25,990 --> 00:16:28,900
你不必考虑所有的交错。

255
00:16:31,330 --> 00:16:37,540
好的，所以即使可串行化略弱于可线性化，

256
00:16:37,630 --> 00:16:42,220
它实际上禁止了很多有问题的情况。

257
00:16:43,630 --> 00:16:45,760
所以让我简单地谈一谈，

258
00:16:45,760 --> 00:16:50,370
弄清楚可串行化的含义，

259
00:16:51,680 --> 00:16:54,890
什么类型的执行，

260
00:16:54,890 --> 00:16:58,640
事务系统必须禁止？

261
00:17:00,730 --> 00:17:03,490
然后，所以，有两种情况，

262
00:17:03,490 --> 00:17:07,630
这里我们有第一个事务，

263
00:17:07,630 --> 00:17:10,000
我们有第二个事务，

264
00:17:11,270 --> 00:17:13,550
所以 t1 运行， t2 ，

265
00:17:14,090 --> 00:17:16,850
我们可能会有一个结果，

266
00:17:16,850 --> 00:17:21,020
一个可能发生的执行是，

267
00:17:21,020 --> 00:17:23,240
如果我们不做一些特别的事情，

268
00:17:23,390 --> 00:17:26,660
t1 get(x) ，

269
00:17:28,790 --> 00:17:31,070
这里转账发生，

270
00:17:31,100 --> 00:17:33,380
所以更新 x,y 发生，

271
00:17:35,290 --> 00:17:39,040
然后 t2 执行 get(y) ，

272
00:17:40,240 --> 00:17:43,060
这是不是非法的，

273
00:17:43,060 --> 00:17:46,600
是不是可串行化的执行？

274
00:17:47,260 --> 00:17:49,120
这是我们要问的问题，

275
00:17:49,690 --> 00:17:51,430
这个问题的答案是什么？

276
00:17:54,420 --> 00:17:56,370
这不是可串行化的。

277
00:17:57,220 --> 00:17:59,440
是的，因为你知道结果，

278
00:17:59,440 --> 00:18:01,450
如果我们写下结果是什么，

279
00:18:01,450 --> 00:18:04,510
那么结果是，这里是 9,11 ，

280
00:18:04,630 --> 00:18:10,150
这里是 10,11 。

281
00:18:11,490 --> 00:18:12,240
我想是的。

282
00:18:12,860 --> 00:18:15,050
如果我们回到之前的幻灯片，

283
00:18:15,050 --> 00:18:17,780
这不是两个合法结果之一，

284
00:18:17,960 --> 00:18:19,490
所以这不是好的。

285
00:18:20,330 --> 00:18:23,600
所以，当我们考虑事务系统的含义时，

286
00:18:23,900 --> 00:18:25,070
它必须是这样的，

287
00:18:25,070 --> 00:18:29,060
它禁止这种执行安排，

288
00:18:29,860 --> 00:18:31,360
这是一个简单的版本，

289
00:18:31,540 --> 00:18:33,880
这两个例子的事务并不复杂，

290
00:18:33,880 --> 00:18:35,770
所以不会有太多交错，

291
00:18:36,190 --> 00:18:38,440
你认为可能会出问题。

292
00:18:38,590 --> 00:18:40,390
但至少还有另外一个，

293
00:18:40,420 --> 00:18:43,720
可能会导致不正确的结果，

294
00:18:43,900 --> 00:18:48,230
那就是我们先执行 put(x) ，

295
00:18:50,040 --> 00:18:51,660
所以我们开始，

296
00:18:52,550 --> 00:18:55,550
然后我们打印两个，

297
00:18:55,580 --> 00:19:00,410
执行两个 get ， get(x) get(y) ，

298
00:19:02,520 --> 00:19:07,080
然后我们执行 put(y) ，

299
00:19:07,080 --> 00:19:10,080
这是可串行化的执行吗，

300
00:19:22,180 --> 00:19:26,500
这是我们应该被可串行化事务系统禁止的执行吗，

301
00:19:26,500 --> 00:19:28,510
还是可行的执行？

302
00:19:30,800 --> 00:19:31,640
这应该被禁止。

303
00:19:32,280 --> 00:19:33,270
它应该被禁止，

304
00:19:33,270 --> 00:19:34,650
因为作为结果，

305
00:19:34,800 --> 00:19:36,000
不会发生这种情况，

306
00:19:36,000 --> 00:19:39,630
如果我们先执行 t1 ，然后执行 t2 ，

307
00:19:39,660 --> 00:19:42,150
或者先执行 t2 ，然后执行 t1 。

308
00:19:43,900 --> 00:19:46,360
好的，我们清楚地看到，

309
00:19:46,360 --> 00:19:50,980
可串行化排除了（某些）执行，

310
00:19:50,980 --> 00:19:55,270
为了让程序员更容易地

311
00:19:55,270 --> 00:19:57,820
考虑数据库所做的。

312
00:19:58,480 --> 00:20:04,480
有两种大的方法来禁止执行，

313
00:20:05,300 --> 00:20:08,060
而且在这些方法中，

314
00:20:08,060 --> 00:20:12,380
禁止的方法称为并发控制。

315
00:20:22,020 --> 00:20:24,450
在第一种方法中，

316
00:20:24,450 --> 00:20:27,600
第一类解决方案是，

317
00:20:27,600 --> 00:20:29,490
所谓的悲观解决方案，

318
00:20:35,400 --> 00:20:37,980
悲观的解决方案是引入锁，

319
00:20:40,350 --> 00:20:41,760
所以这个想法是，

320
00:20:41,760 --> 00:20:44,490
当事务运行或开始时，

321
00:20:44,580 --> 00:20:50,640
它需要必要的锁来维护可串行化，

322
00:20:50,790 --> 00:20:54,930
只有确保以下情况才释放锁，

323
00:20:54,930 --> 00:20:58,710
当执行会导致串行化执行时，

324
00:20:59,450 --> 00:21:00,650
这是一种方法，

325
00:21:00,650 --> 00:21:02,450
我们稍后会更详细地讨论。

326
00:21:03,100 --> 00:21:07,150
第二种方法是是乐观的，

327
00:21:12,050 --> 00:21:15,020
在乐观的方法中，没有锁，

328
00:21:16,730 --> 00:21:19,640
乐观的方法，你只是假设一切都会好起来，

329
00:21:20,960 --> 00:21:23,390
当你到达提交点时，

330
00:21:24,130 --> 00:21:27,880
[]系统问你自己这个问题，

331
00:21:27,910 --> 00:21:31,660
我之前做过的所有操作，

332
00:21:31,660 --> 00:21:35,920
这是可线性化执行的结果吗，

333
00:21:36,280 --> 00:21:39,190
或者这是可串行化执行的结果吗，

334
00:21:39,890 --> 00:21:43,340
如果是这样的话，一切都很好，没有问题，

335
00:21:43,790 --> 00:21:45,290
然后我们是好的，

336
00:21:45,320 --> 00:21:49,730
如果结果不对应于单次执行，

337
00:21:49,850 --> 00:21:51,170
它们会被终止，

338
00:22:01,560 --> 00:22:05,610
它可能会重试。

339
00:22:06,150 --> 00:22:08,010
我们将看到，

340
00:22:08,040 --> 00:22:11,880
我现在不会太多地谈论乐观的并发控制，

341
00:22:12,120 --> 00:22:14,220
但下周或两周后，

342
00:22:14,220 --> 00:22:15,840
在读完 FaRM 论文后，

343
00:22:16,260 --> 00:22:21,300
你将看到一个乐观的分布式事务系统，

344
00:22:21,300 --> 00:22:22,860
我们正在考虑的类型，

345
00:22:22,980 --> 00:22:28,110
它使用乐观并发控制方法，

346
00:22:28,870 --> 00:22:31,660
但是今天的重点是悲观的（方式）。

347
00:22:33,700 --> 00:22:38,770
一种[翻转方式]，

348
00:22:38,770 --> 00:22:42,460
这两种方法在文献中经常被描述为，

349
00:22:42,460 --> 00:22:43,930
悲观的（方法）是，

350
00:22:44,140 --> 00:22:47,680
你先获得许可，然后执行操作，

351
00:22:48,070 --> 00:22:50,410
而乐观的方式则相反，

352
00:22:50,470 --> 00:22:52,840
你只管去执行你的操作，

353
00:22:52,870 --> 00:22:55,480
如果结果是错的，你随后道歉就可以了。

354
00:22:56,520 --> 00:23:01,470
所以，如果你愿意的话，这是一种类比，

355
00:23:01,950 --> 00:23:03,900
在这两种不同的方法之间。

356
00:23:05,200 --> 00:23:06,910
在每种方法中，

357
00:23:06,940 --> 00:23:08,770
无论是悲观的还是乐观的，

358
00:23:08,830 --> 00:23:13,030
有许多不同的并发控制方案，

359
00:23:13,030 --> 00:23:15,880
要么增加它们的并发性，

360
00:23:15,880 --> 00:23:19,510
或者提供更弱的一致性和更多的并发性，

361
00:23:19,660 --> 00:23:22,240
所以这是一个[很大的资料]。

362
00:23:22,900 --> 00:23:29,400
我想谈谈一种特殊的方法，

363
00:23:30,020 --> 00:23:31,340
它非常受欢迎，

364
00:23:31,490 --> 00:23:34,580
尤其是如果你想实现可串行化，

365
00:23:34,580 --> 00:23:35,600
事实证明不是，

366
00:23:35,660 --> 00:23:38,930
尽管我说过可串行化是数据库的黄金标准，

367
00:23:39,080 --> 00:23:44,090
数据库提供了多种程度的隔离，

368
00:23:44,120 --> 00:23:45,320
所以作为一个程序员，

369
00:23:45,320 --> 00:23:48,500
你可以选择你喜欢的隔离度，

370
00:23:48,800 --> 00:23:52,160
你可能想要选择一个较弱的隔离度，

371
00:23:52,160 --> 00:23:53,600
这样你可以获得更多的并发性。

372
00:23:54,540 --> 00:23:57,810
现在我们将坚持并发的黄金标准，

373
00:23:57,960 --> 00:23:59,580
也就是可串行化，

374
00:23:59,730 --> 00:24:01,470
如果你要实现可串行化，

375
00:24:01,530 --> 00:24:04,620
一种常见的方法是两阶段锁，

376
00:24:15,090 --> 00:24:19,140
在两阶段锁中，每个记录都有锁，

377
00:24:21,100 --> 00:24:24,370
这是数据库记录的起点，

378
00:24:24,370 --> 00:24:26,320
在我们的例子中，

379
00:24:26,530 --> 00:24:31,390
这是对变量的锁，

380
00:24:31,390 --> 00:24:33,430
x 的锁和 y 的锁。

381
00:24:34,430 --> 00:24:36,080
有两条规则，

382
00:24:36,590 --> 00:24:46,980
第一，事务在使用之前需要一个锁，

383
00:24:52,020 --> 00:24:53,370
所以这个想法是，

384
00:24:53,370 --> 00:24:57,420
在你可以读写 x y 之前，

385
00:24:57,510 --> 00:24:59,520
你必须先拿到锁，

386
00:24:59,520 --> 00:25:01,380
事务系统会帮你做到这个，

387
00:25:03,470 --> 00:25:07,490
第二， T 持有一把锁，

388
00:25:07,730 --> 00:25:08,990
一旦你获取，

389
00:25:09,720 --> 00:25:15,790
你不允许释放它，直到提交或中止，

390
00:25:15,880 --> 00:25:19,140
无论事务的结果是什么。

391
00:25:20,260 --> 00:25:22,300
好的，在我们这个案例中，

392
00:25:22,300 --> 00:25:27,190
如果我们有 T1 运行， T2 运行，

393
00:25:27,840 --> 00:25:30,840
T1 首先对 x 加锁，

394
00:25:31,290 --> 00:25:33,870
然后对 y 加锁，

395
00:25:34,020 --> 00:25:36,060
它必须维持这些锁，

396
00:25:36,060 --> 00:25:37,830
直到它达到提交点，

397
00:25:40,520 --> 00:25:43,910
T2 在同一时间或大致相同时间运行，

398
00:25:44,060 --> 00:25:46,730
如果 T2 开始得晚一点，

399
00:25:46,940 --> 00:25:49,010
它试图获得 x 的锁，

400
00:25:49,460 --> 00:25:51,020
T1 拥有它，

401
00:25:51,170 --> 00:25:52,850
如果 T2 开始的时间稍晚一些，

402
00:25:53,030 --> 00:25:55,940
在这一点上， T2 必须等待，

403
00:25:58,140 --> 00:26:00,390
一种标准的锁定协议。

404
00:26:00,810 --> 00:26:03,330
两阶段锁的基本思想是，

405
00:26:03,690 --> 00:26:08,850
它是对这个简单锁方案的改进，

406
00:26:08,850 --> 00:26:11,040
在文档中描述，

407
00:26:11,040 --> 00:26:15,090
有时被称为简单锁或严格锁，

408
00:26:15,180 --> 00:26:17,010
在事务开始时，

409
00:26:17,070 --> 00:26:19,890
你获取整个事务所需的所有锁，

410
00:26:19,950 --> 00:26:21,990
你持有它们直到最后，然后释放它们，

411
00:26:22,620 --> 00:26:25,650
而两阶段锁要更细粒度一点，

412
00:26:25,890 --> 00:26:29,940
其中，即使事务[]，

413
00:26:32,440 --> 00:26:34,240
它们不需要直接获取锁，

414
00:26:34,240 --> 00:26:35,770
在开始的时候同时获取所有（锁），

415
00:26:36,620 --> 00:26:40,550
相反，它们在事务运行时以增量方式获取锁，

416
00:26:40,730 --> 00:26:45,590
允许某些严格锁不允许的并发模式。

417
00:26:47,320 --> 00:26:50,320
现在，第一条规则似乎很清楚，

418
00:26:50,350 --> 00:26:51,250
为什么你需要它，

419
00:26:51,580 --> 00:26:55,180
第二条规则也许不那么明显，

420
00:26:55,510 --> 00:26:57,580
这可能是一个好主意，

421
00:26:57,580 --> 00:27:00,160
看看哪里会出问题，

422
00:27:00,160 --> 00:27:01,960
如果你没有坚持第二条规则。

423
00:27:02,900 --> 00:27:06,650
所以，让我们来讨论一下 until 提交，

424
00:27:12,250 --> 00:27:15,370
所以这里我们有两个事务，

425
00:27:16,310 --> 00:27:21,460
T1 和 T2 ，分别是转账和打印语句，

426
00:27:21,850 --> 00:27:23,350
所以我们假设，

427
00:27:23,350 --> 00:27:25,180
在这里，我们执行 put(x) ，

428
00:27:25,750 --> 00:27:28,090
这意味着在 put(x) 之前，

429
00:27:28,090 --> 00:27:30,130
事务系统锁定 x ，

430
00:27:31,480 --> 00:27:34,630
假设我们没有遵循两阶段锁规定，

431
00:27:34,900 --> 00:27:39,700
我们在 put 之后释放 x 的锁，

432
00:27:39,700 --> 00:27:40,600
因为我们已经完成了，

433
00:27:40,600 --> 00:27:43,390
不会再出现在事务 T1 中，

434
00:27:43,510 --> 00:27:45,640
稍后还有一个 put ， put(y) ，

435
00:27:47,660 --> 00:27:48,440
让我们假设，

436
00:27:48,440 --> 00:27:53,420
在获取 y 的锁之前， T2 运行，

437
00:27:53,540 --> 00:27:57,320
T2 整个是，

438
00:27:57,960 --> 00:28:03,060
两个 get ， get(x) get(y) ，你摆脱了x，让y跑了

439
00:28:03,990 --> 00:28:07,410
如果 T1 释放 x 的锁，

440
00:28:07,410 --> 00:28:09,000
它可以得到 x 的锁，

441
00:28:09,450 --> 00:28:13,260
因为 T1 还没有完成 put ，

442
00:28:13,260 --> 00:28:15,510
它也能获得 y 的锁，

443
00:28:15,840 --> 00:28:17,790
所以打印 x 和 y ，

444
00:28:18,720 --> 00:28:22,160
然后重新设置，然后释放锁。

445
00:28:26,180 --> 00:28:36,180
那么，这是一个可串行化的执行吗？

446
00:28:41,010 --> 00:28:42,750
不，它跟以前一样。

447
00:28:42,810 --> 00:28:44,820
是的，跟以前一样，

448
00:28:44,820 --> 00:28:48,450
因为这里的打印语句，

449
00:28:48,510 --> 00:28:51,750
它们处于两个 put x 和 y 之间，

450
00:28:51,810 --> 00:28:53,880
在两个 put x 和 y 之间，

451
00:28:54,240 --> 00:28:55,740
我们之前已经总结了，

452
00:28:55,740 --> 00:28:58,830
这不是可串行化的执行，

453
00:28:59,540 --> 00:29:00,560
所以这是错误的，

454
00:29:00,890 --> 00:29:02,810
所以这是一个很好的演示例子，

455
00:29:02,810 --> 00:29:04,640
如果你过早地解锁，

456
00:29:04,700 --> 00:29:08,660
在这种情况下， T1 过早地释放 x ，

457
00:29:08,810 --> 00:29:11,030
你不会得到一个可串行化的执行。

458
00:29:12,390 --> 00:29:14,220
一种考虑它的方式是，

459
00:29:14,280 --> 00:29:19,620
在两个锁集中间有交集，

460
00:29:19,620 --> 00:29:21,510
所以 T1 有 x y 的锁集，

461
00:29:21,510 --> 00:29:24,960
T2 也有 x y 的锁集，

462
00:29:25,080 --> 00:29:27,300
重要的是，

463
00:29:27,300 --> 00:29:31,530
这两个事务可以以特定方式排序，

464
00:29:31,530 --> 00:29:34,560
这意味着如果锁相交，

465
00:29:34,710 --> 00:29:37,080
我们必须确保一些整体顺序，

466
00:29:37,470 --> 00:29:39,030
这意味着我们必须

467
00:29:39,030 --> 00:29:41,820
持有锁直到提交点，

468
00:29:42,100 --> 00:29:46,480
没有事务的中间结果对其他事务可见，

469
00:29:47,530 --> 00:29:49,600
我们在提交点之前释放锁，

470
00:29:49,840 --> 00:29:52,240
我们可能会让结果变得可见，

471
00:29:52,330 --> 00:29:55,390
即使晚点它可能中止，

472
00:29:55,390 --> 00:29:56,980
然后，整个变化就会消失，

473
00:29:58,610 --> 00:30:01,490
这就是为什么锁必须持有到底的原因。

474
00:30:03,670 --> 00:30:06,910
现在，你们中的许多人问到的一个明显的问题，

475
00:30:07,300 --> 00:30:09,850
在两阶段锁中，

476
00:30:09,850 --> 00:30:12,430
是不是会有死锁，

477
00:30:14,200 --> 00:30:18,920
如果你在事务执行时获取锁。

478
00:30:19,430 --> 00:30:20,090
所以我们，

479
00:30:20,090 --> 00:30:21,830
这绝对是一种情况，

480
00:30:22,010 --> 00:30:25,940
例如，我们稍微修改一下 T2 ，

481
00:30:26,480 --> 00:30:27,770
所以 T2 原来是，

482
00:30:27,770 --> 00:30:29,990
t1 get(x) ，

483
00:30:30,260 --> 00:30:33,560
相反，我们要用相反的顺序， get(y) ，

484
00:30:34,380 --> 00:30:38,550
而 t2 get(x) ，

485
00:30:39,060 --> 00:30:41,730
我们保持 T1 不变，

486
00:30:41,730 --> 00:30:45,030
所以 T1 仍然是首先 put(x) ，然后 put(y) ，

487
00:30:45,540 --> 00:30:47,880
所以现在我们很容易陷入麻烦，

488
00:30:48,850 --> 00:30:50,530
所以这是 T2' ，

489
00:30:51,060 --> 00:30:54,630
这是我们已经有的普通的 T1 ，

490
00:30:54,990 --> 00:30:56,340
它执行 put(x) ，

491
00:30:57,340 --> 00:30:58,870
在做 put(x) 之前，

492
00:30:58,870 --> 00:31:01,390
需要获取 x 的锁，

493
00:31:01,390 --> 00:31:03,220
所以锁 Lx 。

494
00:31:04,000 --> 00:31:07,990
现在我们假设排序如下所示，

495
00:31:07,990 --> 00:31:11,350
T2' 同时运行，

496
00:31:11,590 --> 00:31:14,050
它执行 get(y) ，

497
00:31:14,950 --> 00:31:17,500
这意味着你获得 y 的锁，

498
00:31:18,490 --> 00:31:20,920
现在你可以很容易地看到这里出了什么问题，

499
00:31:21,040 --> 00:31:25,990
现在 T1 执行 put(y) 或要执行 put(y) ，

500
00:31:26,530 --> 00:31:29,350
所以我们需要获得 y 的锁，

501
00:31:29,680 --> 00:31:31,720
但你不能得到它，

502
00:31:31,720 --> 00:31:35,200
因为 T2' 已经持有那个锁，

503
00:31:35,200 --> 00:31:37,480
所以它必须在这里等待，并阻塞，

504
00:31:38,280 --> 00:31:40,560
同样的事情当然也会发生在另一边，

505
00:31:40,560 --> 00:31:43,740
在执行 get(x) 之前，

506
00:31:44,130 --> 00:31:47,970
T2 需要获得 x 的锁，

507
00:31:48,450 --> 00:31:51,120
它不能获得 x 的锁，

508
00:31:51,120 --> 00:31:52,410
因为 T1 持有它，

509
00:31:52,680 --> 00:31:55,230
所以这个也需要等待，

510
00:31:57,200 --> 00:32:01,580
现在我们有 T1 等待 T2' ，

511
00:32:01,580 --> 00:32:03,680
我们有 T2' 等待 T1 ，

512
00:32:03,740 --> 00:32:05,030
我们有一个死锁。

513
00:32:08,670 --> 00:32:12,210
现在，事务系统最酷的部分是，

514
00:32:12,210 --> 00:32:13,560
我们有 abort 操作，

515
00:32:14,380 --> 00:32:18,700
所以，如果事务系统可以检测到死锁，

516
00:32:18,730 --> 00:32:20,920
可以使用 abort 两个事务中的一个，

517
00:32:21,420 --> 00:32:23,010
让另一个继续，

518
00:32:23,160 --> 00:32:25,830
希望它能走到最后并提交，

519
00:32:26,280 --> 00:32:28,380
并中止另一个，

520
00:32:28,440 --> 00:32:31,590
然后客户端或应用程序可以决定

521
00:32:31,590 --> 00:32:33,300
如何处理事务中止，

522
00:32:33,300 --> 00:32:34,530
它可以重试，

523
00:32:34,530 --> 00:32:36,810
可能会稍等片刻，然后重试，

524
00:32:37,260 --> 00:32:41,220
希望在这一点上，你不会陷入死锁。

525
00:32:42,470 --> 00:32:46,040
所以，考虑一下两阶段锁的一种方式是，

526
00:32:46,040 --> 00:32:49,910
它有一点乐观的味道，

527
00:32:49,910 --> 00:32:50,810
从某种意义上说，

528
00:32:51,140 --> 00:32:52,250
它没有保证，

529
00:32:52,250 --> 00:32:53,840
它不会遇到问题，

530
00:32:53,870 --> 00:32:55,640
但即使它遇到了问题，

531
00:32:55,670 --> 00:32:59,750
你总是可以中止，然后从问题中恢复。

532
00:33:03,060 --> 00:33:04,410
对于这个，有什么问题吗？

533
00:33:10,530 --> 00:33:13,350
所以你怎么找到死锁？

534
00:33:13,500 --> 00:33:16,440
这正是我希望有人问这个问题。

535
00:33:16,770 --> 00:33:21,090
所以，人们使用两种方法，

536
00:33:21,360 --> 00:33:23,550
一个是，

537
00:33:23,580 --> 00:33:26,010
也不是可靠的，

538
00:33:26,010 --> 00:33:31,530
一个是基于超时的，

539
00:33:31,530 --> 00:33:34,530
比如如果事务运行了很长时间，

540
00:33:34,530 --> 00:33:36,720
它们似乎没有取得任何进展，

541
00:33:36,960 --> 00:33:38,910
你只是中止其中一个，

542
00:33:39,700 --> 00:33:41,020
所以这个是基于超时的，

543
00:33:41,680 --> 00:33:44,830
一种更系统的思考方式是，

544
00:33:44,830 --> 00:33:47,440
构造一个等待图，

545
00:33:47,620 --> 00:33:50,650
随着事务系统的移动，

546
00:33:50,650 --> 00:33:53,920
例如，如果 T1 运行，

547
00:33:53,950 --> 00:33:55,540
所以在等待图中，

548
00:33:55,540 --> 00:33:56,890
事务是节点，

549
00:33:56,920 --> 00:33:58,600
所以我们有一个节点 T1 ，

550
00:33:58,930 --> 00:34:00,490
我们创建一个节点 T2 ，

551
00:34:00,490 --> 00:34:01,360
当它们开始时，

552
00:34:01,360 --> 00:34:02,710
如果你愿意的话，使用 T2' ，

553
00:34:03,190 --> 00:34:06,550
当 T1 运行 get(x) ，

554
00:34:06,580 --> 00:34:08,320
然后获取 y 的锁，

555
00:34:08,320 --> 00:34:09,250
它不能这样做，

556
00:34:09,520 --> 00:34:14,380
所以我们画一个 T1 到 T2' 的箭头，

557
00:34:14,380 --> 00:34:16,960
表示 T1 正在等待 T2' ，

558
00:34:17,740 --> 00:34:19,600
然后在某个时候， T2 运行，

559
00:34:19,600 --> 00:34:23,560
T2 到达这个点， T2' 到达这个点，

560
00:34:23,680 --> 00:34:25,870
它想要获得 x 的锁，它做不到。

561
00:34:26,460 --> 00:34:28,020
所以我们来看看，

562
00:34:28,020 --> 00:34:30,150
有什么在等着，谁持有锁，

563
00:34:30,150 --> 00:34:31,200
嗯，是 T1 ，

564
00:34:31,440 --> 00:34:34,830
所以我们在等待图中放一条边，

565
00:34:34,830 --> 00:34:38,280
从 T2' 到 T1 ，

566
00:34:38,580 --> 00:34:40,560
现在我们看到这是一个环，

567
00:34:41,660 --> 00:34:43,310
当这里出现环时，

568
00:34:43,310 --> 00:34:44,510
意味着出现了死锁，

569
00:34:44,840 --> 00:34:46,490
因为一个在等待另一个，

570
00:34:46,550 --> 00:34:48,350
而另一个则在等待第一个。

571
00:34:49,040 --> 00:34:53,870
所以，事务系统可以动态构建这些图，

572
00:34:53,960 --> 00:34:57,170
检测图中何时出现环，

573
00:34:57,230 --> 00:35:00,620
然后，例如中止 T1 或 T2' 。

574
00:35:02,650 --> 00:35:07,130
它称为等待图。

575
00:35:13,170 --> 00:35:14,610
中止后会发生什么？

576
00:35:16,080 --> 00:35:20,130
好吧，假设我们已经中止了 T2 ，

577
00:35:20,770 --> 00:35:22,510
只是作为一个实验，

578
00:35:23,300 --> 00:35:25,010
所以我们要杀死这个，

579
00:35:25,040 --> 00:35:29,660
所以 T2 ，事务系统将安排，

580
00:35:29,660 --> 00:35:30,620
我们一会儿就会看到，

581
00:35:31,100 --> 00:35:33,770
它将安排 T2 没有结果

582
00:35:33,770 --> 00:35:35,630
或者 T2 的结果是可见的，

583
00:35:35,960 --> 00:35:38,720
在这一点上，锁被释放，

584
00:35:39,080 --> 00:35:43,610
abort 将强制释放 y 的锁，

585
00:35:43,610 --> 00:35:45,440
因为 T2' 退出，

586
00:35:45,860 --> 00:35:50,150
这意味着 T1 可以获得 y 的锁并继续完成，

587
00:35:50,740 --> 00:35:54,340
调用 T2' 的客户端将会知道，

588
00:35:54,340 --> 00:35:55,510
事务中止了它，

589
00:35:55,810 --> 00:35:58,360
一般情况，你可以选择重新运行它。

590
00:36:04,570 --> 00:36:05,410
这能理解吗？

591
00:36:10,910 --> 00:36:14,690
好的，这是第一部分，

592
00:36:14,690 --> 00:36:17,480
我想说的关于两阶段锁，

593
00:36:17,570 --> 00:36:21,530
另外我想再说一遍家庭作业，

594
00:36:21,680 --> 00:36:23,810
在什么情况下，

595
00:36:23,810 --> 00:36:27,710
两阶段锁比严格锁允许更多的并发性，

596
00:36:27,740 --> 00:36:30,050
严格锁是一种协议，

597
00:36:30,050 --> 00:36:34,360
事务事先获得全部锁，

598
00:36:34,950 --> 00:36:37,440
这就要求程序员，

599
00:36:37,440 --> 00:36:39,570
或者事务的开始声明

600
00:36:39,570 --> 00:36:41,760
事务需要哪些锁，

601
00:36:42,300 --> 00:36:44,940
稍微有点不可取，对程序员不太友好，

602
00:36:45,210 --> 00:36:46,650
但它有一个优势，

603
00:36:46,650 --> 00:36:48,360
那就是你不需要，

604
00:36:48,390 --> 00:36:49,950
你可以执行，

605
00:36:51,340 --> 00:36:54,400
你不必在结束时中止事务，

606
00:36:54,580 --> 00:36:56,320
以防你陷入死锁。

607
00:36:57,060 --> 00:37:01,350
所以，两阶段锁原则上允许更多的并发性，

608
00:37:01,350 --> 00:37:02,910
或者应该允许更多的并发性

609
00:37:03,120 --> 00:37:06,810
比严格锁或简单锁方案。

610
00:37:06,840 --> 00:37:10,230
我想做的是一个快的分组会议室，

611
00:37:10,230 --> 00:37:12,690
过几分钟，比如五分钟，

612
00:37:12,960 --> 00:37:17,160
说服自己或构思案例，

613
00:37:17,190 --> 00:37:21,120
其中简单锁不允许某些并发性，

614
00:37:21,180 --> 00:37:24,450
而两阶段锁可以使用。

615
00:37:26,730 --> 00:37:29,940
太棒了，好的，我们来进入分组会议室。

616
00:37:34,410 --> 00:37:36,330
好的，五分钟后见。

617
00:44:07,130 --> 00:44:08,150
我们听不到你说话。

618
00:44:17,730 --> 00:44:19,080
我想你静音了。

619
00:44:36,180 --> 00:44:40,710
我有一个问题，关于你之前提到的一张幻灯片。

620
00:44:40,740 --> 00:44:43,410
稍等，我再检查一下现在大家是否都能听到我说话。

621
00:44:44,330 --> 00:44:44,870
是的。

622
00:44:45,110 --> 00:44:49,060
好的，很好，继续。

623
00:44:50,620 --> 00:44:54,040
关于你之前的或者我想这是一个一般性的问题，

624
00:44:54,040 --> 00:44:57,100
但是（释放）锁的点是否总是与提交点相同，

625
00:44:57,370 --> 00:45:01,480
或者，是否可以在提交点之前开始放弃锁。

626
00:45:01,540 --> 00:45:04,390
好的，这是一个非常好的问题，

627
00:45:04,420 --> 00:45:06,160
视情况而定，

628
00:45:06,190 --> 00:45:09,280
所以如果你只执行独占锁，

629
00:45:09,280 --> 00:45:11,530
像我们到目前为止所做的，

630
00:45:11,530 --> 00:45:12,640
至少在我的例子中，

631
00:45:12,640 --> 00:45:14,500
提交点一样，

632
00:45:15,060 --> 00:45:17,820
（释放）锁的点与提交点和中止点一样，

633
00:45:17,910 --> 00:45:19,830
如果你使用读写锁，

634
00:45:19,980 --> 00:45:24,570
锁允许读锁和写锁，

635
00:45:24,870 --> 00:45:30,480
然后，可以在有一些限制的情况下更早地释放读锁。

636
00:45:32,540 --> 00:45:33,230
好的。

637
00:45:34,780 --> 00:45:39,710
好的，有人能给我举个例子吗，

638
00:45:39,710 --> 00:45:44,360
两阶段锁允许比简单锁有更多的并发，

639
00:45:45,380 --> 00:45:47,540
只是为了确保我们想法一致。

640
00:45:52,360 --> 00:45:54,400
比如审计功能，

641
00:45:54,400 --> 00:46:00,870
一旦你读到这个人的金额就可以释放锁，

642
00:46:00,900 --> 00:46:03,120
你不必读到每个人的。

643
00:46:04,120 --> 00:46:07,210
这是利用读锁的一个例子，

644
00:46:07,210 --> 00:46:08,200
如果你有读锁。

645
00:46:15,060 --> 00:46:16,080
还有其他例子吗？

646
00:46:19,930 --> 00:46:21,280
如果你有一个事务，

647
00:46:21,280 --> 00:46:26,320
其中有一个条件很少是 true ，

648
00:46:26,320 --> 00:46:28,510
当它是 true 时，你读取一块数据，

649
00:46:28,510 --> 00:46:31,750
所以，在开始时，你不需要获取锁，

650
00:46:31,750 --> 00:46:33,340
只有当你真的需要读取它时。

651
00:46:33,640 --> 00:46:34,780
是的，这是一个很好的例子，

652
00:46:34,780 --> 00:46:36,460
我个人非常喜欢这个例子，

653
00:46:36,490 --> 00:46:37,210
这是一个很好的例子。

654
00:46:38,960 --> 00:46:40,310
好的，好的，

655
00:46:40,310 --> 00:46:44,420
让我们继续这节课的第二个主题，

656
00:46:44,420 --> 00:46:45,890
也就是两阶段提交，

657
00:46:49,420 --> 00:46:51,190
这是关于处理崩溃，

658
00:46:53,670 --> 00:46:56,190
换回蓝色，在白板上。

659
00:47:01,910 --> 00:47:04,640
我们还看不到幻灯片。

660
00:47:05,120 --> 00:47:09,860
哦，让我来解决这个问题，

661
00:47:10,970 --> 00:47:12,590
稍等，

662
00:47:15,030 --> 00:47:20,190
共享屏幕，开始共享，

663
00:47:21,390 --> 00:47:22,620
现在怎么样？

664
00:47:23,180 --> 00:47:23,690
好了。

665
00:47:24,020 --> 00:47:25,910
好的，谢谢。

666
00:47:26,800 --> 00:47:35,980
好的，所以两阶段提交或通常称为 2PC ，

667
00:47:36,220 --> 00:47:41,590
同样，这是一个非常著名的流行的协议，

668
00:47:41,890 --> 00:47:43,690
我将讨论它，

669
00:47:43,690 --> 00:47:49,060
协议的简单明了或最常见的版本，

670
00:47:49,090 --> 00:47:51,430
它们是它的各种变体，

671
00:47:51,640 --> 00:47:58,100
但它们也有相同的基本想法。

672
00:47:58,840 --> 00:48:02,530
同样地，通常在两阶段协议中，

673
00:48:02,530 --> 00:48:06,550
我将在转账事务的背景下这样做，

674
00:48:07,000 --> 00:48:09,970
所以，如果客户端想进行转账，

675
00:48:10,090 --> 00:48:15,070
将转账业务提交给事务系统，

676
00:48:15,430 --> 00:48:21,070
而接收事务的机器称为协调器，

677
00:48:23,490 --> 00:48:31,290
那个机器负责通过事务系统运行事务，

678
00:48:31,860 --> 00:48:35,910
在我们的情况下，协调器将与两台不同的机器交互，

679
00:48:37,100 --> 00:48:38,180
A 和 B ，

680
00:48:38,960 --> 00:48:43,160
其中 A 持有 x ， B 持有 y 。

681
00:48:45,150 --> 00:48:52,910
而且通常的一种方式是，

682
00:48:52,910 --> 00:48:55,340
协调者执行整个事务，

683
00:48:55,340 --> 00:48:57,140
但以试探性的方式，

684
00:48:57,200 --> 00:49:02,400
所以， put x 导致一个给 A 的消息，

685
00:49:02,430 --> 00:49:06,210
锁定 A ， 修改 A ，

686
00:49:06,300 --> 00:49:09,690
put x ，

687
00:49:09,690 --> 00:49:12,540
put 在数据库中还是不可见的，

688
00:49:12,630 --> 00:49:15,510
它所做的是放入一个日志，

689
00:49:15,780 --> 00:49:19,170
很像在 Frangipani 中的方式，

690
00:49:19,170 --> 00:49:20,670
我们必须预先写入日志，

691
00:49:20,940 --> 00:49:21,750
所有操作，

692
00:49:21,750 --> 00:49:24,780
在某个时刻，数据库自己[具体化]，

693
00:49:24,810 --> 00:49:26,190
我们首先放入日志，

694
00:49:26,310 --> 00:49:29,250
在这种情况下，直到我们遇到提交，

695
00:49:29,340 --> 00:49:32,610
然后我们将安装数据库中的所有东西。

696
00:49:33,280 --> 00:49:37,360
所以我们执行第二个 put 到 y ，

697
00:49:39,810 --> 00:49:42,120
同样的事情也发生在那里，

698
00:49:42,120 --> 00:49:44,880
我们获得 y 的锁，

699
00:49:44,910 --> 00:49:46,590
好的，这是对 x 的锁，

700
00:49:47,080 --> 00:49:49,240
我们对 y 执行 put ，

701
00:49:50,800 --> 00:49:55,840
再次，我们不会真的把值放入数据库，

702
00:49:55,840 --> 00:49:56,770
我们将是使用日志，

703
00:49:56,890 --> 00:49:58,630
所以我们 log y ，

704
00:49:58,840 --> 00:50:00,070
这里是 log x 。

705
00:50:01,400 --> 00:50:02,060
好的?

706
00:50:03,440 --> 00:50:07,490
现在协调者完成了两个事务，

707
00:50:07,490 --> 00:50:11,810
现在两个操作准备好提交，

708
00:50:12,020 --> 00:50:14,660
这就是两阶段的用处。

709
00:50:15,390 --> 00:50:19,680
协调器将发送一个 prepare 消息，

710
00:50:20,410 --> 00:50:22,600
首先描述这个协议，

711
00:50:22,600 --> 00:50:25,600
表明没有失败，一切都解决了，

712
00:50:26,140 --> 00:50:30,670
是一些简单的案例，

713
00:50:31,240 --> 00:50:32,950
发送一个 prepare 消息，

714
00:50:33,490 --> 00:50:36,070
发送 prepare 消息到，

715
00:50:37,080 --> 00:50:41,250
prepare A ， prepare B ，

716
00:50:45,310 --> 00:50:48,730
并且 prepare 消息当然包括事务 ID ，

717
00:50:48,730 --> 00:50:51,130
用于这个事务，

718
00:50:51,130 --> 00:50:53,560
所以，每个事务都有一个事务 ID ，

719
00:50:54,130 --> 00:50:57,100
所有的消息都标记有事务 ID ，

720
00:50:57,100 --> 00:50:59,830
所以，我们始终知道我们谈论的是哪个事务，

721
00:51:00,880 --> 00:51:04,750
当 A 和 B 接收到 prepare 消息，

722
00:51:05,110 --> 00:51:07,000
它们查看自己的状态，

723
00:51:07,060 --> 00:51:11,500
看看它们是否真的可以执行事务，

724
00:51:11,500 --> 00:51:14,410
在这种情况下，它们持有 x 的锁，

725
00:51:14,590 --> 00:51:16,660
x 在日志中，

726
00:51:16,810 --> 00:51:17,770
所以它们发回，

727
00:51:17,770 --> 00:51:21,160
说是的，我准备好提交了，

728
00:51:21,990 --> 00:51:25,330
所以，是的，是的，

729
00:51:27,200 --> 00:51:31,610
在这一点上，关键的一步是，

730
00:51:31,850 --> 00:51:37,940
协调者知道 A 和 B 都准备好提交，

731
00:51:38,240 --> 00:51:44,480
我承诺要提交，响应 y ，

732
00:51:44,660 --> 00:51:49,320
在这一点上，协调者提交，

733
00:51:49,930 --> 00:51:55,030
然后发送消息给 A ，

734
00:51:55,030 --> 00:51:59,260
说 commit(TID) ，

735
00:51:59,960 --> 00:52:04,070
同样的消息给 B ， commit(TID) ，

736
00:52:07,190 --> 00:52:08,360
在这一点上，

737
00:52:08,660 --> 00:52:11,420
A 和 B 执行操作，

738
00:52:11,420 --> 00:52:13,610
所以它们安装，

739
00:52:14,160 --> 00:52:19,650
在这一点上，它们安装 y 的日志，

740
00:52:19,980 --> 00:52:26,270
同样，这个安装 x ，

741
00:52:26,300 --> 00:52:27,770
然后释放锁，

742
00:52:28,100 --> 00:52:32,210
所以释放 y ，这里释放 x ，

743
00:52:33,010 --> 00:52:37,330
然后它们回复协调者，

744
00:52:37,420 --> 00:52:39,400
表示所有都完成了，

745
00:52:40,600 --> 00:52:45,790
在这一点上，事务完全完成，

746
00:52:45,790 --> 00:52:47,800
事实上，协调器不需要

747
00:52:47,800 --> 00:52:49,960
记住有关这个事务的任何内容。

748
00:52:50,740 --> 00:52:52,810
而且，也可以在后面看到，

749
00:52:52,810 --> 00:52:55,690
A 和 B 需要记住这个状态长一点时间，

750
00:52:55,690 --> 00:52:57,490
直到它们听到下一个事务。

751
00:52:58,410 --> 00:53:01,830
好的，这是一个核心的基本案例，

752
00:53:01,830 --> 00:53:03,300
当绝对没有失败的时候，

753
00:53:03,630 --> 00:53:07,980
我们看到我们得到了预期结果，

754
00:53:08,370 --> 00:53:10,500
什么时候协调者提交，

755
00:53:10,740 --> 00:53:23,650
只有在 A 和 B 同意的情况下，协调者才能提交。

756
00:53:28,890 --> 00:53:30,600
好吧，有可能是这样的，

757
00:53:30,600 --> 00:53:34,500
例如，当协调器向 B 发送消息时，

758
00:53:34,500 --> 00:53:38,550
B 决定，我不能提交，

759
00:53:38,580 --> 00:53:41,670
可能有多种原因造成这种情况，

760
00:53:42,030 --> 00:53:45,540
也许 B 处于一种情况，

761
00:53:45,540 --> 00:53:48,120
y 有一个死锁，

762
00:53:48,590 --> 00:53:52,280
或者日志已经没有空间，

763
00:53:52,280 --> 00:53:55,010
或者账户里没有足够的钱，

764
00:53:55,430 --> 00:54:00,050
所以 B 可以回复不，

765
00:54:00,320 --> 00:54:02,120
假设在这里，

766
00:54:02,330 --> 00:54:04,070
另一个可能的结果是，

767
00:54:04,070 --> 00:54:06,950
prepare 消息可以发回一个 no ，

768
00:54:07,490 --> 00:54:08,840
在这种情况下，协调员得到A的肯定，B的否定，

769
00:54:08,990 --> 00:54:13,580
协调者得到一个来自 A 的 yes ，一个来自 B 的 no ，

770
00:54:13,580 --> 00:54:15,230
所以双方都不同意，

771
00:54:15,440 --> 00:54:16,070
在这种情况下，

772
00:54:16,070 --> 00:54:18,320
协调者不能提交事务，

773
00:54:18,320 --> 00:54:19,910
然后它可以中止事务，

774
00:54:22,600 --> 00:54:24,670
然后向 A 和 B 发送 abort 消息，

775
00:54:24,670 --> 00:54:28,450
停止事务，

776
00:54:28,480 --> 00:54:30,100
所以这是两种可能的结果，

777
00:54:30,100 --> 00:54:31,960
一个是提交的情况，一个是中止的情况，

778
00:54:32,110 --> 00:54:34,090
它总是这种情况，

779
00:54:34,090 --> 00:54:35,770
事务仅提交，

780
00:54:36,010 --> 00:54:37,600
顶层事务仅提交，

781
00:54:37,600 --> 00:54:41,620
当参与事务的双方都同意这样做。

782
00:54:44,720 --> 00:54:49,040
现在，这就是协议的概述，

783
00:54:49,040 --> 00:54:51,110
现在我想看几种情况，

784
00:54:51,110 --> 00:54:54,890
理解什么会出错，

785
00:54:54,890 --> 00:54:56,900
我们如何处理，

786
00:54:56,930 --> 00:55:01,580
两阶段提交如何安排仍然是正确的。

787
00:55:01,970 --> 00:55:03,530
我有个问题。

788
00:55:03,710 --> 00:55:07,850
所以我们说， B 可能会决定它需要中止，

789
00:55:08,480 --> 00:55:09,590
发回 no 消息，

790
00:55:09,590 --> 00:55:14,300
如果它在回复 yes 之后，决定需要中止，

791
00:55:14,390 --> 00:55:15,740
这有可能吗？

792
00:55:16,040 --> 00:55:18,110
不，我们一会儿再谈，

793
00:55:18,110 --> 00:55:19,790
但这绝对是不可能的，

794
00:55:19,940 --> 00:55:23,060
如果你承诺提交，你必须提交。

795
00:55:25,520 --> 00:55:27,290
或者你必须做好提交的准备。

796
00:55:27,350 --> 00:55:28,640
你必须准备好提交，

797
00:55:28,640 --> 00:55:29,630
你不立即提交，

798
00:55:29,630 --> 00:55:31,670
必须等到提交消息，

799
00:55:31,670 --> 00:55:33,260
但你不能[反悔]，

800
00:55:33,410 --> 00:55:35,150
所以，直到 prepare ，

801
00:55:35,730 --> 00:55:38,520
B 可以单方面中止事务，

802
00:55:39,100 --> 00:55:40,780
一旦承诺 yes ，

803
00:55:40,930 --> 00:55:43,420
它不能再单方面中止事务。

804
00:55:44,580 --> 00:55:47,220
所以，有没有可能你陷入死锁，

805
00:55:47,250 --> 00:55:48,870
但你无法摆脱死锁，

806
00:55:48,870 --> 00:55:54,460
因为环中的每个都同意准备好提交。

807
00:55:55,680 --> 00:55:57,390
如果每个人都同意准备，

808
00:55:57,390 --> 00:55:59,340
它们肯定会提交，它们就会提交，

809
00:56:00,660 --> 00:56:02,040
你仍然持有锁。

810
00:56:02,710 --> 00:56:04,090
是的，但如果你陷入死锁，

811
00:56:04,090 --> 00:56:05,230
因为我们前面提到了，

812
00:56:05,230 --> 00:56:07,840
你可能想要中止的原因之一。

813
00:56:07,840 --> 00:56:09,940
你会在准备好之前发现它，

814
00:56:11,240 --> 00:56:12,800
如果你得到了 y 的锁，

815
00:56:13,040 --> 00:56:16,400
如果你没有成功获得事务所需的锁，

816
00:56:16,550 --> 00:56:18,890
那么你在那个点上就知道了。

817
00:56:19,990 --> 00:56:20,800
好的，谢谢。

818
00:56:22,680 --> 00:56:25,650
好的，这就是将要进行的讨论，

819
00:56:25,680 --> 00:56:30,330
我将使用同样的白板，并复制它，

820
00:56:30,690 --> 00:56:33,030
考虑一系列不同的情况，

821
00:56:33,960 --> 00:56:36,480
所以这是相同的白板，

822
00:56:36,810 --> 00:56:39,900
目前为止什么都没有改变，它是一样的，

823
00:56:40,230 --> 00:56:41,940
所以我们首先，

824
00:56:41,940 --> 00:56:45,210
跟进我们刚才提出的这个问题，

825
00:56:45,240 --> 00:56:52,520
让我们首先考虑 B 处于准备状态的情况，

826
00:56:54,180 --> 00:56:56,400
然后崩溃了，

827
00:56:58,050 --> 00:56:59,610
所以它是准备好的，

828
00:57:02,220 --> 00:57:07,060
它发回给协调者，

829
00:57:07,060 --> 00:57:10,750
同意一起去做，

830
00:57:11,320 --> 00:57:16,450
然后在它发送 prepare 消息 ok 消息后，

831
00:57:16,450 --> 00:57:17,590
它崩溃了，

832
00:57:19,040 --> 00:57:20,000
这是什么意思，

833
00:57:22,500 --> 00:57:23,520
我们需要做什么，

834
00:57:23,520 --> 00:57:25,170
我们如何解决这一问题，

835
00:57:25,730 --> 00:57:26,870
或者风险是什么，

836
00:57:28,220 --> 00:57:29,990
如果 B 崩溃。

837
00:57:31,260 --> 00:57:33,990
如果 B 崩溃，我们需要中止所有东西。

838
00:57:34,710 --> 00:57:36,390
现在，我们不能中止了，

839
00:57:36,390 --> 00:57:38,340
因为 B 已经承诺了，

840
00:57:39,060 --> 00:57:39,990
它将会提交。

841
00:57:41,540 --> 00:57:43,160
我们要使用日志吗？

842
00:57:44,410 --> 00:57:46,660
是的，好的，所以 B 要崩溃了，

843
00:57:46,660 --> 00:57:48,550
在某个时刻，会重新出现，对吧，

844
00:57:49,100 --> 00:57:50,540
希望它会恢复。

845
00:57:51,210 --> 00:57:54,870
哪些状态需要记住，在崩溃过程中？

846
00:57:59,130 --> 00:58:01,410
A 需要记住是准备好的。

847
00:58:01,800 --> 00:58:04,380
是的，还需要记住，

848
00:58:04,380 --> 00:58:07,500
它准备好的事务 ID ，无论 TID 是什么，

849
00:58:08,370 --> 00:58:11,010
以及持有 y 的锁。

850
00:58:12,930 --> 00:58:14,370
所以，当它恢复时，

851
00:58:14,730 --> 00:58:17,910
它首先要做的是查看，

852
00:58:17,910 --> 00:58:23,490
我是否在分布式事务的一个参与者中间，

853
00:58:23,490 --> 00:58:24,990
如果查看状态，

854
00:58:24,990 --> 00:58:25,800
你将看到，

855
00:58:25,800 --> 00:58:29,580
它为事务 ID TID 准备好了，

856
00:58:29,580 --> 00:58:33,120
它也必须持有锁 Ly ，

857
00:58:33,270 --> 00:58:35,280
获得 y 的锁在做任何其他事情之前，

858
00:58:35,280 --> 00:58:37,350
在于其他交互之前，

859
00:58:37,350 --> 00:58:39,330
一旦它处于这种状态，

860
00:58:39,600 --> 00:58:41,850
就像它没有崩溃，

861
00:58:41,940 --> 00:58:44,340
所有东西都回归正常了，

862
00:58:44,490 --> 00:58:49,020
并且希望在某一时刻协调者将重试 commit 消息，

863
00:58:49,140 --> 00:58:53,070
B 将获得该事务 ID 的 commit 消息，

864
00:58:53,130 --> 00:58:55,290
看到我确实准备好了，

865
00:58:55,380 --> 00:58:57,450
我希望 y 的锁，

866
00:58:57,450 --> 00:59:00,300
所以，它继续并安装 y ，等等，

867
00:59:00,300 --> 00:59:01,380
完成这个事务。

868
00:59:04,190 --> 00:59:04,940
这能理解吗？

869
00:59:05,700 --> 00:59:08,700
所以这里有一些改进的地方，

870
00:59:08,730 --> 00:59:13,860
我们必须将一些数据写入到稳定存储中，

871
00:59:13,860 --> 00:59:15,390
作为事务的一部分，

872
00:59:16,340 --> 00:59:17,990
这是两阶段提交的一部分，

873
00:59:18,170 --> 00:59:20,720
这是两阶段提交有些昂贵的原因之一，

874
00:59:20,870 --> 00:59:24,110
因为我们不仅要发送多个回合的信息，

875
00:59:24,320 --> 00:59:30,170
而且参与者必须将东西写到稳定存储中，

876
00:59:30,560 --> 00:59:32,300
正如我们之前讨论过的，

877
00:59:32,300 --> 00:59:34,970
写入稳定存储是昂贵的，

878
00:59:34,970 --> 00:59:37,640
可能很容易就是几毫秒，

879
00:59:37,640 --> 00:59:40,820
让我们乐观地说一毫秒，

880
00:59:40,910 --> 00:59:41,840
这意味着，

881
00:59:41,840 --> 00:59:44,630
直接被限制在每秒 1000 个事务，

882
00:59:44,930 --> 00:59:45,620
不会更多。

883
00:59:48,080 --> 00:59:50,240
好的，让我们来考虑另一个情况，

884
00:59:51,750 --> 00:59:54,630
所以让我再复制一次这张幻灯片，

885
01:00:01,780 --> 01:00:06,040
考虑另一种情况。

886
01:00:06,700 --> 01:00:12,700
比如，协调者崩溃，

887
01:00:12,730 --> 01:00:17,750
所以，这里使用红色铅笔，

888
01:00:18,110 --> 01:00:23,030
我们有一个，我们有准备好的消息，

889
01:00:23,330 --> 01:00:26,510
协调者可能已经发送了一条 commit 消息，

890
01:00:26,750 --> 01:00:28,700
然后在这里崩溃，

891
01:00:29,880 --> 01:00:34,290
我们需要安排什么，

892
01:00:34,320 --> 01:00:36,300
确保整个方案顺利实施。

893
01:00:42,210 --> 01:00:47,400
所以协调器需要将命令持久化存储，

894
01:00:47,400 --> 01:00:49,830
已经承诺提交，但还没有提交的。

895
01:00:50,430 --> 01:00:56,460
是的，所以协调者几乎和对 B 的分析相同，

896
01:00:56,670 --> 01:00:58,170
如果我们提交一个事务，

897
01:00:58,200 --> 01:00:59,580
我们需要写入稳定存储，

898
01:00:59,580 --> 01:01:00,960
我们正在提交事务，

899
01:01:00,960 --> 01:01:03,960
因此我们需要写入稳定存储， commit tid ，

900
01:01:05,660 --> 01:01:08,630
这样当协调者回来的时候，

901
01:01:08,960 --> 01:01:11,450
然后它才能完成事务，

902
01:01:11,450 --> 01:01:15,590
在 A 和 B 事务提交之前，

903
01:01:15,620 --> 01:01:16,970
因为 A 和 B 都在等着，

904
01:01:16,970 --> 01:01:19,910
A 和 B 说，是的，我们很乐意继续，

905
01:01:20,150 --> 01:01:21,980
它们一直在等待，

906
01:01:21,980 --> 01:01:25,670
直到它们听到协调者决定完成，

907
01:01:25,670 --> 01:01:29,600
因为一旦它们决定，一旦它们继续，

908
01:01:29,600 --> 01:01:31,310
一旦它们同意继续，

909
01:01:31,370 --> 01:01:34,580
它们就不能单方面[]，

910
01:01:34,580 --> 01:01:39,140
因为，假设它们都说完全同意，

911
01:01:39,140 --> 01:01:40,790
那就意味着协调者，

912
01:01:40,790 --> 01:01:43,070
它们不知道，

913
01:01:43,070 --> 01:01:46,780
协调者发送 commit 信息给 A ，

914
01:01:46,780 --> 01:01:48,460
表示提交事务，

915
01:01:48,730 --> 01:01:49,780
B 还没有收到，

916
01:01:49,780 --> 01:01:52,930
可能消息延迟了，然后协调者崩溃了，

917
01:01:53,080 --> 01:01:54,430
在这一点上，

918
01:01:54,550 --> 01:01:57,760
B 中止事务将是完全错误的，

919
01:01:57,940 --> 01:02:01,150
它必须要等到协调者回来，

920
01:02:01,240 --> 01:02:04,060
判断事务的结果是什么。

921
01:02:07,880 --> 01:02:08,600
好的?

922
01:02:12,880 --> 01:02:13,780
所以，只有，

923
01:02:13,780 --> 01:02:19,060
抱歉，协调者不会重新发送的唯一消息是 prepare ，

924
01:02:19,820 --> 01:02:23,540
如果它没有得到 yes ，它就会中止？

925
01:02:24,150 --> 01:02:27,180
是的，这是下一个例子，所以我们继续。

926
01:02:28,010 --> 01:02:30,470
让我再复制一下这个白板，

927
01:02:31,520 --> 01:02:33,830
然后谈谈这种情况。

928
01:02:33,830 --> 01:02:37,470
所以，为了[]，我们把它移到下面，

929
01:02:37,800 --> 01:02:39,000
所以[]，

930
01:02:39,000 --> 01:02:43,710
假设下面的事情发生，

931
01:02:44,270 --> 01:02:48,450
这个 prepare 消息永远不会出现，

932
01:02:49,400 --> 01:02:56,510
然后协调者可以单方面决定中止，

933
01:02:57,800 --> 01:03:00,290
事实上，你可以告诉 B 中止，

934
01:03:00,410 --> 01:03:04,160
A 不需要知道任何关于它的事情，

935
01:03:04,490 --> 01:03:10,790
有些会晚点回来问协调者，

936
01:03:10,790 --> 01:03:13,460
协调者不知道关于这个事务的任何更多信息，

937
01:03:13,670 --> 01:03:16,490
你可以告诉 A ，那个事务已经中止，

938
01:03:16,520 --> 01:03:18,650
因为我没有提交记录，

939
01:03:18,650 --> 01:03:20,990
我没有等待通知任何人。

940
01:03:22,930 --> 01:03:24,370
所以在这种情况下，我们可以中止，

941
01:03:25,520 --> 01:03:27,860
这意味着 B 可以释放锁，

942
01:03:27,860 --> 01:03:29,630
B 可以继续，

943
01:03:29,990 --> 01:03:35,870
尝试其他可能涉及 y 的事务。

944
01:03:38,630 --> 01:03:39,260
好的?

945
01:03:40,680 --> 01:03:44,640
抱歉，如果给 A 的信息丢失会发生什么，

946
01:03:44,880 --> 01:03:46,500
协调器中止，

947
01:03:47,110 --> 01:03:48,550
然后 B 崩溃了，

948
01:03:48,700 --> 01:03:50,080
但是当它回来时，

949
01:03:50,110 --> 01:03:54,460
它将等待来自协调者的提交消息，

950
01:03:54,520 --> 01:03:56,620
但这个事务已经中止。

951
01:03:56,650 --> 01:03:59,980
是的，这两种情况，

952
01:04:00,010 --> 01:04:04,750
大多数协议 B 会 ping 协调者，

953
01:04:04,750 --> 01:04:06,190
因为它知道谁是协调者，

954
01:04:06,850 --> 01:04:09,460
并询问这个事务的结果是什么。

955
01:04:15,840 --> 01:04:18,060
好的，我想再谈一种情况，

956
01:04:18,060 --> 01:04:21,030
有一种最有趣的情况，

957
01:04:21,420 --> 01:04:24,090
是最棘手的情况之一。

958
01:04:24,240 --> 01:04:26,790
所以我有一个简单的问题。

959
01:04:26,790 --> 01:04:28,050
好的，等一下。

960
01:04:28,200 --> 01:04:28,500
抱歉。

961
01:04:28,800 --> 01:04:29,340
好的。

962
01:04:29,700 --> 01:04:31,800
好的，所以第一个问题是，

963
01:04:32,010 --> 01:04:35,820
假设 B 持有 y 的锁，

964
01:04:36,090 --> 01:04:39,540
直到把 y 放入日志，

965
01:04:39,570 --> 01:04:43,020
把 y 安装到[]。

966
01:04:43,020 --> 01:04:43,260
是的。

967
01:04:43,320 --> 01:04:43,620
好的。

968
01:04:44,080 --> 01:04:45,610
然后是第二个问题，

969
01:04:45,610 --> 01:04:48,190
这里的锁是分布式的，

970
01:04:48,550 --> 01:04:50,200
因为我们在处理跨服务器的问题，

971
01:04:50,200 --> 01:04:53,530
我的意思是，如果 y 只存在于服务器 B 上，

972
01:04:53,530 --> 01:04:55,300
或许我们不需要对它加锁，

973
01:04:55,360 --> 01:04:56,830
我只是好奇是怎么回事。

974
01:04:56,950 --> 01:04:58,330
是的，这里的设置，

975
01:04:58,330 --> 01:05:01,780
A 维护它的所有分片的锁，

976
01:05:01,870 --> 01:05:04,120
它的所有的变量，所有的记录，

977
01:05:04,120 --> 01:05:06,730
B 维护它所有的记录。

978
01:05:07,440 --> 01:05:08,310
好的，但如果我们，

979
01:05:08,310 --> 01:05:10,530
例如， y 在多个服务器上，

980
01:05:10,530 --> 01:05:12,270
那么我们需要某种分布式锁？

981
01:05:12,720 --> 01:05:15,780
是的，我们在谈论分片的情况，

982
01:05:15,780 --> 01:05:18,210
帐户分片在多个服务器之上，

983
01:05:18,360 --> 01:05:20,250
只有一台服务器有特定的帐户。

984
01:05:22,560 --> 01:05:23,280
太棒了，谢谢。

985
01:05:23,370 --> 01:05:25,830
我稍后再回到这个问题上，再说一次。

986
01:05:27,060 --> 01:05:29,910
所以我想指出的第一件事是，

987
01:05:29,910 --> 01:05:36,400
回来看看这种情况，

988
01:05:36,400 --> 01:05:47,070
B 或 A 回复 yes ，然后崩溃了，

989
01:05:47,600 --> 01:05:50,030
或者，让我看看是不是这样，

990
01:05:50,610 --> 01:05:52,740
不，我想下面这种情况，

991
01:05:53,570 --> 01:05:56,060
修复这条线，

992
01:05:56,620 --> 01:05:58,750
所以 A 和 B 承诺了，

993
01:05:59,050 --> 01:06:02,080
但我想回到这个情况，

994
01:06:02,080 --> 01:06:03,700
我们已经讨论过了，

995
01:06:03,820 --> 01:06:07,270
也就是在提交点之后，

996
01:06:07,950 --> 01:06:09,180
协调者崩溃。

997
01:06:10,490 --> 01:06:10,940
好的。

998
01:06:11,510 --> 01:06:18,400
而且，我们知道这段时间，从这里到那里，

999
01:06:18,400 --> 01:06:23,230
B 不能再单方面中止了，

1000
01:06:23,230 --> 01:06:25,720
因为它承诺会继续，

1001
01:06:25,900 --> 01:06:28,090
也有可能是这样的，

1002
01:06:28,090 --> 01:06:31,180
A 已经提交了，

1003
01:06:31,830 --> 01:06:35,280
所以，它不能再单方面中止了，

1004
01:06:35,550 --> 01:06:37,980
所以在这种情况下只有一个选择，

1005
01:06:37,980 --> 01:06:38,970
是哪种选择？

1006
01:06:52,380 --> 01:06:53,760
我们只能等待。

1007
01:06:54,030 --> 01:06:57,600
是的，这很不幸，但却是真的，

1008
01:06:59,250 --> 01:07:00,840
我们唯一能做的就是等待，

1009
01:07:01,650 --> 01:07:04,530
它仍然持有 y 的锁，

1010
01:07:04,530 --> 01:07:05,250
所以这意味着，

1011
01:07:05,250 --> 01:07:08,820
任何其他涉及 y 的事务都不能继续进行，

1012
01:07:09,240 --> 01:07:13,680
必须等待协调者回来，

1013
01:07:14,010 --> 01:07:18,000
宣布或重新宣布决定，

1014
01:07:18,000 --> 01:07:20,130
那个事务的结果是什么。

1015
01:07:21,160 --> 01:07:24,310
这是两个方面中的一个，

1016
01:07:24,310 --> 01:07:27,400
这是两阶段提交的其中一个方面，

1017
01:07:27,760 --> 01:07:31,120
这些都是可取的，

1018
01:07:31,120 --> 01:07:37,990
在那里协议可能会被阻塞，直到机器回来。

1019
01:07:40,450 --> 01:07:41,350
这能理解吗？

1020
01:07:45,720 --> 01:07:48,390
那么，人们在实践中是如何处理这一问题的，

1021
01:07:48,390 --> 01:07:50,650
好吧，这有点不幸，

1022
01:07:50,950 --> 01:07:55,210
但这里是我们过去的一些技巧可以来拯救，

1023
01:07:55,240 --> 01:07:57,190
我们能对协调者做些什么，

1024
01:07:58,610 --> 01:08:00,560
让这种情况变得不太可能。

1025
01:08:06,420 --> 01:08:08,310
我们可以让它容错。

1026
01:08:08,310 --> 01:08:10,530
是的，做容错，我们怎么做呢？

1027
01:08:13,110 --> 01:08:15,570
好的，有多种方法，但是，

1028
01:08:17,170 --> 01:08:19,030
你可以通过 raft 来做这件事。

1029
01:08:19,700 --> 01:08:22,610
是的，运行 raft

1030
01:08:22,610 --> 01:08:26,540
使协调者不是在一台机器上运行，

1031
01:08:26,540 --> 01:08:29,960
我们有一个复制状态机来实现协调者，

1032
01:08:30,350 --> 01:08:32,060
我们使用 raft

1033
01:08:32,060 --> 01:08:36,140
来保持复制的状态机

1034
01:08:36,140 --> 01:08:38,840
实现协调者同步，

1035
01:08:39,200 --> 01:08:43,340
然后，如果组成协调器的机器中的一台发生故障，

1036
01:08:43,340 --> 01:08:45,200
希望另外两个还在那里，

1037
01:08:45,380 --> 01:08:47,720
所以我们仍然可以继续，

1038
01:08:49,260 --> 01:08:52,920
所以有可能，

1039
01:08:52,920 --> 01:08:54,570
复制协调者，

1040
01:08:54,570 --> 01:08:57,540
或者任何参与者使用 raft 。

1041
01:08:59,170 --> 01:09:00,190
所以让我，

1042
01:09:01,200 --> 01:09:04,560
所以让我来讨论一下，

1043
01:09:10,010 --> 01:09:10,970
有几个讨论点，

1044
01:09:10,970 --> 01:09:13,340
我们可以使用 Raft ，

1045
01:09:17,480 --> 01:09:23,170
使协调器容错或可用，

1046
01:09:24,480 --> 01:09:26,190
这是我们关心的性质。

1047
01:09:31,210 --> 01:09:32,110
这能理解吗？

1048
01:09:36,450 --> 01:09:37,710
事实上，你会发现，

1049
01:09:37,740 --> 01:09:40,320
如果你做的是实验 4 而不是一个项目，

1050
01:09:40,620 --> 01:09:42,690
这正是实验 4 要做的事情，

1051
01:09:43,020 --> 01:09:45,960
实验 4 实际上也有类似的方案，

1052
01:09:45,960 --> 01:09:49,380
有一种形式的两阶段提交，

1053
01:09:49,380 --> 01:09:56,970
你实现，移动 master 分片或 master 协调者，

1054
01:09:57,150 --> 01:10:01,710
然后在分片服务器之间重新平衡，

1055
01:10:02,040 --> 01:10:04,230
使用 Raft 复制，

1056
01:10:04,230 --> 01:10:07,200
分片服务器也使用 Raft 复制，

1057
01:10:07,260 --> 01:10:10,920
所以，许多 Raft 组并行运行，

1058
01:10:12,220 --> 01:10:14,290
也是实验 4 的实质所在，

1059
01:10:14,500 --> 01:10:16,750
所以这就是通常的方式，

1060
01:10:16,750 --> 01:10:19,240
如果你担心，

1061
01:10:19,240 --> 01:10:22,270
系统长时间阻塞，

1062
01:10:22,270 --> 01:10:23,140
一种方法是，

1063
01:10:23,140 --> 01:10:26,710
使协调者容错。

1064
01:10:31,460 --> 01:10:33,590
所以[]让我想到了另一件事，

1065
01:10:33,590 --> 01:10:35,630
很多人问到，

1066
01:10:35,870 --> 01:10:42,010
Raft 和两阶段提交是不是类似的东西，

1067
01:10:46,000 --> 01:10:48,190
或者你可以使用 Raft 做两阶段提交，

1068
01:10:48,190 --> 01:10:52,900
或者你需要有一些并行，

1069
01:10:52,900 --> 01:10:56,470
比如，一个东西叫做协调者， Raft 叫做领导者，

1070
01:10:56,740 --> 01:11:01,570
我们有参与者，也许我们可以把这些当作跟随者，

1071
01:11:01,930 --> 01:11:05,050
所以似乎有一些相似之处，

1072
01:11:05,050 --> 01:11:06,160
我们怎么考虑它，

1073
01:11:06,160 --> 01:11:09,370
Raft 和 2PC 之间有什么关系？

1074
01:11:12,060 --> 01:11:13,620
不同之处在于，

1075
01:11:13,740 --> 01:11:16,830
在 Raft 中，协调者可以改变，

1076
01:11:17,070 --> 01:11:20,520
否则，它就是单点故障。

1077
01:11:20,670 --> 01:11:23,080
是的，很好的观点，还有其他的吗？

1078
01:11:24,900 --> 01:11:26,580
另一个不同之处是，

1079
01:11:26,580 --> 01:11:29,160
Raft 是基于多数的概念，

1080
01:11:29,160 --> 01:11:30,690
而在两阶段提交协调者中，

1081
01:11:30,690 --> 01:11:34,530
它需要从每个其他服务器获得响应，

1082
01:11:34,530 --> 01:11:35,970
所有涉及到的。

1083
01:11:37,620 --> 01:11:38,070
是的，很好的观点，

1084
01:11:38,070 --> 01:11:40,950
所以这些几乎就是关键的区别，

1085
01:11:41,310 --> 01:11:44,160
我们在想，如果我们到了一个点，

1086
01:11:44,160 --> 01:11:45,960
比如，如果概念上的差异，

1087
01:11:45,960 --> 01:11:48,590
它们是否解决了相同的问题？

1088
01:11:49,730 --> 01:11:52,820
哦， Raft 是用来复制相同的东西，

1089
01:11:53,420 --> 01:11:56,330
两阶段提交是相反的，

1090
01:11:56,330 --> 01:12:00,770
不是让一个东西传播到不同服务器上，

1091
01:12:00,800 --> 01:12:03,200
那你就得处理这个问题。

1092
01:12:03,680 --> 01:12:08,190
没错，在 Raft 中，所有服务器都做同样的事情，

1093
01:12:13,880 --> 01:12:16,040
实现复制状态机，

1094
01:12:18,150 --> 01:12:23,460
而在 2PC 中，所有服务器操作不同的数据，

1095
01:12:35,300 --> 01:12:38,630
第一个参与者在 x 上操作，

1096
01:12:38,630 --> 01:12:40,700
第二个参与者在 y 上操作，

1097
01:12:41,380 --> 01:12:45,610
所以在 2PC 中，解决了一个与 Raft 完全不同的问题，

1098
01:12:45,610 --> 01:12:48,130
Raft 是关于高可用性，

1099
01:12:54,860 --> 01:13:00,110
2PC 是关于跨服务器的原子操作，

1100
01:13:07,640 --> 01:13:10,220
跨位于不同服务器上的数据。

1101
01:13:10,760 --> 01:13:11,660
这能理解吗？

1102
01:13:13,700 --> 01:13:18,140
所以，即使它们可能有一些内部技术看起来非常相似，

1103
01:13:18,350 --> 01:13:22,550
这两个协议是为完全不同的问题而设计的，

1104
01:13:23,940 --> 01:13:25,020
没有直接的关系，

1105
01:13:25,020 --> 01:13:26,190
现在看起来很有趣，

1106
01:13:26,190 --> 01:13:27,660
但我们可以做 Raft ，

1107
01:13:27,900 --> 01:13:30,120
我们可以使用 Raft 使协调者具有更强的容错性，

1108
01:13:30,120 --> 01:13:32,730
或者参与者更高的可用性，

1109
01:13:33,000 --> 01:13:36,270
但它们本质上解决了不同的问题。

1110
01:13:43,860 --> 01:13:46,470
说到这里，我想结束这节课，

1111
01:13:46,500 --> 01:13:49,440
我很乐意回答更多的问题，

1112
01:13:49,710 --> 01:13:53,310
希望这对接下来的两篇论文有帮助，

1113
01:13:53,340 --> 01:13:57,000
所以接下来的两篇论文都是两个事务系统，

1114
01:13:57,180 --> 01:14:00,990
一个来自 Google ，

1115
01:14:00,990 --> 01:14:02,400
一个来自微软的研究，

1116
01:14:02,700 --> 01:14:06,330
第二个使用乐观事务，

1117
01:14:06,630 --> 01:14:09,090
当你读到这些论文的时候，你会发现，

1118
01:14:09,090 --> 01:14:11,970
有很多机制，都是相当复杂的系统，

1119
01:14:12,210 --> 01:14:15,780
但有希望的是，至少有一部分将被描述，

1120
01:14:15,990 --> 01:14:17,130
你现在就会明白，

1121
01:14:17,130 --> 01:14:18,720
因为你知道什么是两阶段提交，

1122
01:14:18,720 --> 01:14:19,950
而且你知道什么是两阶段锁。

1123
01:14:21,560 --> 01:14:23,810
好的，说到这里，我就结束了，

1124
01:14:23,840 --> 01:14:26,540
每个需要离开的认就可以离开，

1125
01:14:26,540 --> 01:14:28,220
如果有人想问问题，

1126
01:14:28,220 --> 01:14:29,750
请自由提问。

1127
01:14:36,720 --> 01:14:41,360
抱歉，这个问题可能有点奇怪，

1128
01:14:41,360 --> 01:14:43,640
但对于两阶段锁来说，

1129
01:14:44,030 --> 01:14:46,730
它也是关于原子操作的，

1130
01:14:46,730 --> 01:14:53,920
它是关于，不是跨服务器，而是在一台服务器，

1131
01:14:54,580 --> 01:14:56,620
两阶段是跨服务器的。

1132
01:14:56,620 --> 01:14:59,770
是的，如果你只有一台机器，两阶段锁也是有关的，

1133
01:14:59,770 --> 01:15:01,030
比如一台多核机器，

1134
01:15:01,480 --> 01:15:04,570
你在一台多核机器上实现事务系统，

1135
01:15:04,810 --> 01:15:08,590
你必须对事务中涉及的记录加锁，

1136
01:15:08,920 --> 01:15:11,830
对于这个，两阶段锁也是一个非常好的协议，

1137
01:15:16,200 --> 01:15:18,540
而两阶段提交真正是关于分布式系统的。

1138
01:15:20,770 --> 01:15:25,190
我想我的问题是，两阶段锁，

1139
01:15:25,580 --> 01:15:28,640
它可能是两阶段提交的一部分吗？

1140
01:15:30,140 --> 01:15:33,020
我不确定那是什么意思，

1141
01:15:33,020 --> 01:15:34,490
我的想法是，

1142
01:15:34,490 --> 01:15:36,020
你解决两个不同的问题。

1143
01:15:38,470 --> 01:15:39,100
好的。

1144
01:15:39,460 --> 01:15:40,570
事实是，

1145
01:15:40,570 --> 01:15:42,670
也许这就是你的意思，

1146
01:15:42,910 --> 01:15:46,810
在这种情况下，有一个协调者，

1147
01:15:47,110 --> 01:15:50,710
或者作为初始设置的一部分，

1148
01:15:50,710 --> 01:15:52,960
当初始 put 通过事务完成时，

1149
01:15:53,260 --> 01:15:55,870
这个事务遵循两阶段锁，

1150
01:15:57,080 --> 01:16:00,740
这里需要获取 x 的锁，需要获取 B 的锁，

1151
01:16:01,880 --> 01:16:04,640
需要获取 y 的锁，

1152
01:16:04,640 --> 01:16:07,880
事务做这个是使用两阶段锁的方式，

1153
01:16:08,000 --> 01:16:09,890
它也可以使用严格锁，

1154
01:16:09,890 --> 01:16:13,820
但是从两阶段提交的角度来看，

1155
01:16:14,270 --> 01:16:15,290
这不重要，

1156
01:16:15,290 --> 01:16:18,710
在某一点上，事务将要执行，

1157
01:16:19,070 --> 01:16:22,640
两阶段提交是为了达成协议，

1158
01:16:22,940 --> 01:16:25,910
所有各方都同意继续。

1159
01:16:28,350 --> 01:16:30,060
好的，理解了，谢谢。

1160
01:16:30,240 --> 01:16:30,810
不用谢。

1161
01:16:31,290 --> 01:16:34,560
两阶段提交是专门用于分片数据吗？

1162
01:16:35,100 --> 01:16:38,760
不，事实上它来自，

1163
01:16:39,150 --> 01:16:41,850
好吧，是或不是，

1164
01:16:42,150 --> 01:16:46,920
最初的两阶段提交来自这种情况，

1165
01:16:46,920 --> 01:16:49,620
比如你有不同的机构，

1166
01:16:49,620 --> 01:16:51,150
它们需要同意做一些事情，

1167
01:16:51,150 --> 01:16:55,950
比如你在旅游网站上预定，

1168
01:16:55,950 --> 01:16:57,690
你预定一趟旅行，

1169
01:16:57,690 --> 01:16:59,880
还有一件事，你订了酒店，

1170
01:17:00,180 --> 01:17:03,420
你想提交整个旅行，

1171
01:17:03,420 --> 01:17:12,600
如果酒店网站和旅游网站都同意，

1172
01:17:12,900 --> 01:17:14,010
那么提交这个事务，

1173
01:17:14,610 --> 01:17:18,510
这决定，

1174
01:17:18,510 --> 01:17:20,940
来自不同的机构，

1175
01:17:21,150 --> 01:17:26,690
它们需要提交一个特定的操作，

1176
01:17:26,690 --> 01:17:28,940
出于这样的原因，

1177
01:17:29,000 --> 01:17:34,490
人们并不想使用两阶段提交，

1178
01:17:34,940 --> 01:17:36,950
因为这就意味着，

1179
01:17:37,280 --> 01:17:42,980
旅行社网站依赖于酒店预订网站，

1180
01:17:42,980 --> 01:17:45,560
它们来自不同的机构，

1181
01:17:45,560 --> 01:17:48,200
机构并不彼此信任，

1182
01:17:48,410 --> 01:17:50,690
如果其中一个停机了，

1183
01:17:50,690 --> 01:17:53,930
然后就不能继续了，这看起来很糟糕，

1184
01:17:54,380 --> 01:17:58,490
所以，两阶段提交有点负面名声，

1185
01:17:58,860 --> 01:18:00,840
因为你知道，

1186
01:18:01,980 --> 01:18:04,830
两阶段提交的最初目标之一是解决这个问题，

1187
01:18:04,830 --> 01:18:07,350
这里的问题，人们不希望使用两阶段提交来解决，

1188
01:18:07,860 --> 01:18:10,770
然而，在拥有数据中心的环境中，

1189
01:18:10,770 --> 01:18:13,380
是一个单一的机构，数据库是分片的，

1190
01:18:13,590 --> 01:18:17,620
两阶段提交是广泛流行和典型使用。

1191
01:18:21,000 --> 01:18:21,900
太棒了，谢谢。

1192
01:18:22,410 --> 01:18:23,130
不用谢。

1193
01:18:24,210 --> 01:18:26,760
你能回到第一个失败的情况吗，

1194
01:18:26,760 --> 01:18:28,500
我们谈到的两阶段提交，

1195
01:18:28,500 --> 01:18:33,960
B 在回复 prepare ok 之后崩溃，

1196
01:18:34,140 --> 01:18:35,700
好的，是这个吗？

1197
01:18:36,250 --> 01:18:38,770
是的，我想是的。

1198
01:18:39,560 --> 01:18:41,690
关于这个情况我谈了两次，但是。

1199
01:18:41,690 --> 01:18:45,230
是的，我想我想知道，

1200
01:18:45,740 --> 01:18:48,530
为什么 B 需要持久化，

1201
01:18:48,530 --> 01:18:52,910
或者为什么需要记住它收到了 prepare ，

1202
01:18:53,450 --> 01:18:55,700
我想我的想法是，

1203
01:18:56,260 --> 01:18:57,670
当它恢复时，

1204
01:18:58,060 --> 01:19:01,360
如果它从协调者接收到 commit 消息，

1205
01:19:01,360 --> 01:19:04,510
它就不能假设它已经准备好了吗，

1206
01:19:04,510 --> 01:19:06,400
我想它在哪里使用那个信息。

1207
01:19:06,790 --> 01:19:10,840
是的，它可能在崩溃前中止，

1208
01:19:12,030 --> 01:19:13,650
B 需要记住它做了什么。

1209
01:19:14,430 --> 01:19:15,360
好的。

1210
01:19:15,690 --> 01:19:18,300
这个方案还有另一个细微的变化，

1211
01:19:18,300 --> 01:19:21,660
当你假设你总是提交，

1212
01:19:21,660 --> 01:19:25,110
假设提交，其中一条消息略有不同，

1213
01:19:25,200 --> 01:19:28,230
你可以考虑一个优化方案，

1214
01:19:28,560 --> 01:19:31,260
在某些情况下也是有意义的，

1215
01:19:31,940 --> 01:19:35,000
我并没有真的谈到那个特定的协议，

1216
01:19:35,000 --> 01:19:35,990
但只是略有不同，

1217
01:19:35,990 --> 01:19:37,010
一种变体，

1218
01:19:37,010 --> 01:19:38,990
两阶段提交有相当多的变体，

1219
01:19:39,880 --> 01:19:42,040
它们会有一些微小的变化。

1220
01:19:45,190 --> 01:19:45,760
理解了吗?

1221
01:19:46,030 --> 01:19:46,930
是的，谢谢。

1222
01:19:54,270 --> 01:19:55,260
今天就这些吗？

1223
01:19:57,430 --> 01:19:59,110
抱歉，你说它可以，

1224
01:19:59,140 --> 01:20:02,410
它可以中止事务，

1225
01:20:02,410 --> 01:20:06,190
但如果它这样做，它将永远不会收到提交。

1226
01:20:07,380 --> 01:20:09,390
你的意思是回应最后一个问题？

1227
01:20:09,570 --> 01:20:11,310
是的。

1228
01:20:11,310 --> 01:20:12,540
这个问题是，

1229
01:20:12,540 --> 01:20:15,720
为什么 B 必须记录到稳定存储，

1230
01:20:15,720 --> 01:20:16,770
决定要做什么。

1231
01:20:17,580 --> 01:20:21,600
问题是，当 B 出现时，

1232
01:20:21,600 --> 01:20:24,360
它需要知道是否同意提交，

1233
01:20:24,390 --> 01:20:25,800
或者同意中止，

1234
01:20:26,760 --> 01:20:31,090
它没有写任何东西，它不知道同意什么。

1235
01:20:35,030 --> 01:20:36,800
因为它可能中止，之后。

1236
01:20:36,830 --> 01:20:37,430
是的。

1237
01:20:37,810 --> 01:20:38,830
好的。

1238
01:20:40,540 --> 01:20:41,710
我需要知道，

1239
01:20:41,710 --> 01:20:44,560
在恢复阶段做什么。

1240
01:20:44,860 --> 01:20:45,400
是的，没错。

1241
01:20:52,260 --> 01:20:54,330
它还需要记录它所做的事情，

1242
01:20:54,330 --> 01:20:56,900
因为如果它中止，

1243
01:20:56,930 --> 01:20:58,940
但消息永远不会到达协调者，

1244
01:20:58,970 --> 01:21:02,420
需要重新发送相同的消息。

1245
01:21:02,420 --> 01:21:06,080
是的，它需要记录中止那个事务 ID ，

1246
01:21:06,080 --> 01:21:08,990
所以当协调者问起你做了什么，

1247
01:21:09,230 --> 01:21:10,820
它回复一个 no 。

1248
01:21:11,940 --> 01:21:12,870
明白了，谢谢。

1249
01:21:17,530 --> 01:21:18,250
谢谢。

1250
01:21:18,910 --> 01:21:19,420
不用谢。

1251
01:21:20,790 --> 01:21:21,720
谢谢。

1252
01:21:24,010 --> 01:21:25,540
好的，下周见。

