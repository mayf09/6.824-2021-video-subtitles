1
00:00:00,530 --> 00:00:08,720
所以今天的主题是 raft 复制协议，

2
00:00:08,840 --> 00:00:10,850
我们将详细讨论这个问题，

3
00:00:10,910 --> 00:00:13,700
实际上，我们将使用多节课来讲解它，

4
00:00:14,600 --> 00:00:15,140
一个是，

5
00:00:15,140 --> 00:00:22,430
因为它是分布式复制协议示例的核心组件之一。

6
00:00:22,900 --> 00:00:27,490
所以，今天我们主要关注

7
00:00:27,610 --> 00:00:31,120
实验 2A 和 2B 所需的材料，

8
00:00:32,590 --> 00:00:36,700
leader 的选举以及推送日志，

9
00:00:37,120 --> 00:00:38,530
然后下一周，

10
00:00:42,710 --> 00:00:45,560
我们将更多地关注 2C 和 2D ，

11
00:00:45,560 --> 00:00:49,890
也就是快照和日志压缩，

12
00:00:49,890 --> 00:00:53,280
让我们有机会了解 raft 的任何其他方面。

13
00:00:53,430 --> 00:00:57,270
事实上，我们会在接下来的一周再谈一次 raft ，

14
00:00:58,250 --> 00:01:05,970
我们会有一节关于 2A 和 2B 的问答课，

15
00:01:05,970 --> 00:01:10,020
讨论实验 2A 和 2B 的实际解决方案。

16
00:01:10,600 --> 00:01:11,230
好的?

17
00:01:11,590 --> 00:01:13,540
这就是我们的计划。

18
00:01:13,540 --> 00:01:18,760
我将从今天的起点开始深入讨论，

19
00:01:19,530 --> 00:01:22,410
可能开始的地方是

20
00:01:22,410 --> 00:01:27,900
观察之前复制系统的一些案例研究，

21
00:01:27,960 --> 00:01:29,370
我们已经看到了一些模式，

22
00:01:32,180 --> 00:01:38,030
看了 GFS mapreduce VM-FT ，

23
00:01:38,360 --> 00:01:41,240
它们都有一个单点故障，

24
00:01:41,240 --> 00:01:44,210
所以，即使它们是复制系统，

25
00:01:44,810 --> 00:01:47,090
它们复制以实现容错，

26
00:01:47,780 --> 00:01:50,900
它们实际上都有一个单点故障，

27
00:01:51,780 --> 00:01:55,260
在 mapreduce 案例中是 coordinator ，

28
00:01:58,520 --> 00:02:04,740
在 GFS 的案例中是 master ，比如它发放租约，

29
00:02:05,220 --> 00:02:12,890
在 VM-FT 案例中，存储服务器是 test-and-set 服务器。

30
00:02:15,470 --> 00:02:21,020
就像我们在上一节课中讨论的原因，

31
00:02:21,020 --> 00:02:24,800
是单个计算机而不是复制机器的原因是，

32
00:02:25,040 --> 00:02:27,830
是为了避免脑裂。

33
00:02:36,850 --> 00:02:38,650
对于许多系统来说，

34
00:02:38,650 --> 00:02:41,260
一种[]这种局面的方法是，

35
00:02:41,290 --> 00:02:42,460
我们构建一个高性能，

36
00:02:42,610 --> 00:02:45,190
构建一个强容错的系统，

37
00:02:45,490 --> 00:02:47,590
所有这些设计，

38
00:02:47,590 --> 00:02:50,080
我们实际上仍然有一个单点故障，

39
00:02:50,080 --> 00:02:53,800
即使复制用于系统设计的许多其他方面，

40
00:02:54,370 --> 00:02:57,610
对于到目前为止我们所讨论的许多系统，

41
00:02:57,820 --> 00:03:02,430
为了避免脑裂，

42
00:03:02,430 --> 00:03:06,030
使用单点故障或维护单点故障，

43
00:03:06,060 --> 00:03:08,460
在许多情况下，这些都是完全可以接受的，

44
00:03:09,270 --> 00:03:10,530
因为在许多情况下，

45
00:03:10,530 --> 00:03:15,360
比如存储服务器或 master 宕机，

46
00:03:15,510 --> 00:03:18,870
它只是一台机器，

47
00:03:18,870 --> 00:03:22,590
它宕机的机会比任何块服务器都小，

48
00:03:22,920 --> 00:03:26,910
可能已经有服务器准备启动，

49
00:03:26,910 --> 00:03:29,310
意味着如果 master 宕机，重新启动，

50
00:03:29,310 --> 00:03:31,440
我们将确保只有一个 master 在线。

51
00:03:32,240 --> 00:03:35,960
所以，在很多情况下都是很好的，

52
00:03:35,990 --> 00:03:38,630
可能会导致很短的停机时间。

53
00:03:39,240 --> 00:03:40,860
但是有些系统，

54
00:03:40,860 --> 00:03:44,400
如果这样，就太好了，

55
00:03:44,400 --> 00:03:46,530
我们不需要单点故障，

56
00:03:46,560 --> 00:03:48,900
也许我们可以进一步减少停机时间，

57
00:03:49,140 --> 00:03:53,550
增加待机时间。

58
00:03:54,490 --> 00:03:58,660
所以，这是那种协议，

59
00:03:58,660 --> 00:04:02,560
raft 协议适合的地方。

60
00:04:02,800 --> 00:04:07,750
在深入讨论协议中的关键概念之前，

61
00:04:07,900 --> 00:04:13,150
让我们提醒自己为什么这种单点故障会导致，

62
00:04:13,180 --> 00:04:15,790
为什么复制，

63
00:04:15,880 --> 00:04:19,630
严重的单点故障，比如 test-and-set ，

64
00:04:19,660 --> 00:04:22,960
会导致这种脑裂的问题。

65
00:04:23,680 --> 00:04:25,120
所以你可能会想，

66
00:04:25,120 --> 00:04:28,450
为什么不复制单点故障呢？

67
00:04:29,020 --> 00:04:31,090
所以让我们试着这样做，

68
00:04:31,090 --> 00:04:33,910
然后我们很快会看到问题所在，

69
00:04:33,910 --> 00:04:36,190
所以，让我们复制 test-and-set 服务器。

70
00:04:48,140 --> 00:04:53,720
所以，让我们来做一个简单明了的情况，

71
00:04:53,720 --> 00:04:58,880
我们只有一个复制 test-and-set 服务器 S1 ，

72
00:04:59,000 --> 00:05:03,200
这里我们有 S2 ，是另一个复制 test-and-set 服务器，

73
00:05:03,380 --> 00:05:05,900
记得 test-and-set ，

74
00:05:07,080 --> 00:05:10,530
它接受参数 new ，并返回 old 值。

75
00:05:12,750 --> 00:05:16,500
目标是如果两个客户端同时调用 test-and-set ，

76
00:05:16,530 --> 00:05:17,460
其中一个赢了，

77
00:05:17,460 --> 00:05:20,880
得到 false 作为旧值，

78
00:05:20,880 --> 00:05:21,810
而另一个会输，

79
00:05:21,810 --> 00:05:25,590
因为它会得到 true 作为旧值。

80
00:05:26,140 --> 00:05:28,420
所以让我们看看这如何发挥作用，

81
00:05:28,420 --> 00:05:31,000
所以，我们有一个客户端调用 test-and-set ，

82
00:05:31,360 --> 00:05:38,380
与第一个服务器通信，

83
00:05:38,380 --> 00:05:39,730
与第二个服务器通信，

84
00:05:42,500 --> 00:05:44,330
我们不知道，

85
00:05:44,330 --> 00:05:46,580
是否能收到第二台服务器的响应。

86
00:05:48,300 --> 00:05:50,010
所以现在有两种情况，

87
00:05:50,010 --> 00:05:53,520
如果 S2 没有反应，

88
00:05:53,520 --> 00:05:56,070
有两个可能的原因会出现这种情况。

89
00:05:56,520 --> 00:05:58,410
所以有一种情况可能是，

90
00:05:58,710 --> 00:06:01,860
S2 没有反应，因为 S2 失败了，

91
00:06:06,260 --> 00:06:07,130
在某些情况下，

92
00:06:07,250 --> 00:06:10,070
这种情况是我们想要做的，

93
00:06:10,070 --> 00:06:13,160
在这一点， C1 宣布胜利，

94
00:06:13,640 --> 00:06:18,560
因为没有其他人能够观察到 S2 ，

95
00:06:18,770 --> 00:06:21,230
我们就完成了，我们可以继续。

96
00:06:22,820 --> 00:06:23,900
但问题是，

97
00:06:23,930 --> 00:06:25,160
还有第二个情况，

98
00:06:25,780 --> 00:06:27,220
在第二种情况下，

99
00:06:27,550 --> 00:06:29,080
出现网络分区，

100
00:06:31,780 --> 00:06:37,000
在 C1 和 S2 之间出现网络分区，

101
00:06:38,100 --> 00:06:41,370
所以在这种情况下， C1 不能继续进行，

102
00:06:41,580 --> 00:06:44,700
因为可能还有另一个客户端 C2 ，

103
00:06:45,120 --> 00:06:47,040
与 S2 进行通信，

104
00:06:48,350 --> 00:06:51,590
这将是非常严重的，

105
00:06:51,590 --> 00:06:53,120
在这种情况下， C1 继续进行，

106
00:06:53,270 --> 00:06:55,490
因为它可能会更新 S1 ，

107
00:06:55,790 --> 00:06:59,480
得到 false 值，认为它成功了，

108
00:06:59,600 --> 00:07:02,660
同时，与 S2 进行通信，

109
00:07:02,780 --> 00:07:04,610
并且在 test-and-set 也会成功，

110
00:07:04,610 --> 00:07:08,180
所以，现在我们违反了 test-and-set 协议。

111
00:07:09,240 --> 00:07:10,980
所以这就是脑裂的问题，

112
00:07:10,980 --> 00:07:12,840
当存在网络分区时，

113
00:07:12,930 --> 00:07:14,520
我们可能会遇到一种情况，

114
00:07:14,520 --> 00:07:18,360
两台服务器都在运行，

115
00:07:18,360 --> 00:07:20,100
并且为不同的客户端提供服务，

116
00:07:20,100 --> 00:07:21,660
因此违反协议，

117
00:07:21,660 --> 00:07:24,030
（违反）我们正在构建的系统的规范。

118
00:07:24,660 --> 00:07:27,000
真正具有挑战性的部分是，

119
00:07:27,000 --> 00:07:30,450
C1 无法区分这两种情况，

120
00:07:31,420 --> 00:07:33,430
它不知道，

121
00:07:36,120 --> 00:07:37,650
到底是什么情况，

122
00:07:38,520 --> 00:07:40,140
S2 不可达，

123
00:07:40,140 --> 00:07:42,180
是因为它失败了或是因为网络分区，

124
00:07:42,920 --> 00:07:45,080
所以这是一个难题，

125
00:07:45,080 --> 00:07:51,800
在之前这些系统背后的，

126
00:07:51,800 --> 00:07:53,900
为什么它们使用单点，

127
00:07:54,230 --> 00:07:57,410
为什么它们不复制这些重要的服务，

128
00:07:57,470 --> 00:08:00,320
需要避免，

129
00:08:01,560 --> 00:08:04,230
避免脑裂问题。

130
00:08:04,880 --> 00:08:08,420
那么，我们能做些什么，

131
00:08:08,420 --> 00:08:10,430
这里的关键问题是，

132
00:08:10,430 --> 00:08:12,620
我们应该如何处理网络分区，

133
00:08:13,140 --> 00:08:14,310
我们怎么处理它们。

134
00:08:14,700 --> 00:08:16,470
所以有一个关键的想法，

135
00:08:16,770 --> 00:08:23,970
作为 raft 或其他协议的基础，

136
00:08:25,170 --> 00:08:29,610
解决方案或为什么这些协议可以成功。

137
00:08:29,880 --> 00:08:31,140
它是什么，

138
00:08:31,170 --> 00:08:34,110
简而言之，就是多数原则。

139
00:08:37,820 --> 00:08:39,110
作为一个例子，

140
00:08:39,110 --> 00:08:41,720
在 test-and-set 服务器的情况中，

141
00:08:41,720 --> 00:08:44,870
不是运行两个复制的服务器，

142
00:08:44,870 --> 00:08:46,550
我刚才所做的，

143
00:08:46,820 --> 00:08:48,500
我会用三个服务器来运行它，

144
00:08:49,370 --> 00:08:52,820
所以我会有 S1 S2 S3 ，

145
00:08:54,600 --> 00:08:56,310
规则将会是，

146
00:08:56,310 --> 00:09:00,810
客户端可以认为操作是成功的，

147
00:09:00,900 --> 00:09:03,510
如果至少更新了大多数服务器。

148
00:09:04,250 --> 00:09:05,360
所以在这种情况下，

149
00:09:05,360 --> 00:09:08,090
我们可以向 S1 发送消息，做 test-and-set ，

150
00:09:08,090 --> 00:09:10,280
我们向 S2 发送消息，做 test-and-set ，

151
00:09:10,490 --> 00:09:14,030
现在我们得到它们两个的积极回应，

152
00:09:14,150 --> 00:09:15,800
在这两种情况下，都是 false ，

153
00:09:15,860 --> 00:09:19,100
然后我们向应用程序返回 false ，

154
00:09:19,100 --> 00:09:21,500
然后应用程序认为 test-and-set 是成功的。

155
00:09:23,000 --> 00:09:24,560
当然，我们对第三个也是这样做的，

156
00:09:24,560 --> 00:09:25,790
但第三个可能，

157
00:09:25,790 --> 00:09:27,800
消息可能不会到达，

158
00:09:27,800 --> 00:09:29,060
或者服务器可能停机，

159
00:09:29,060 --> 00:09:31,400
我们不知道，实际上我们并不在乎，

160
00:09:32,080 --> 00:09:35,320
因为考虑以下情况，

161
00:09:35,320 --> 00:09:39,250
我们有第二个客户端也在尝试进行 test-and-set ，

162
00:09:39,960 --> 00:09:41,400
为了能够成功，

163
00:09:41,400 --> 00:09:45,300
它必须与大多数服务器通信，

164
00:09:45,870 --> 00:09:48,360
所以，无论与哪个大多数通信，

165
00:09:48,510 --> 00:09:50,850
它将包括 S1 或 S2 ，

166
00:09:51,620 --> 00:09:53,060
并且对于 S1 和 S2 ，

167
00:09:53,060 --> 00:09:56,120
这两个操作都已经在 C1 成功了，

168
00:09:56,780 --> 00:10:03,800
所以 C2 总会观察到 C1 的操作结果，

169
00:10:03,830 --> 00:10:05,420
因为这里有重叠。

170
00:10:21,980 --> 00:10:24,560
你会看到 raft ，

171
00:10:24,710 --> 00:10:27,500
和现在发生的事情完全一样，

172
00:10:27,500 --> 00:10:29,750
当一个 leader 接受，

173
00:10:29,930 --> 00:10:36,980
或者操作在大多数 follower 接受，

174
00:10:37,280 --> 00:10:40,550
这意味着下一任期会有一位继任的 leader ，

175
00:10:40,820 --> 00:10:45,410
也会获得多数席位，选为 leader ，

176
00:10:45,500 --> 00:10:46,970
作为投票的一部分，

177
00:10:47,030 --> 00:10:49,670
将会有一个服务器或一个 follower ，

178
00:10:49,700 --> 00:10:51,980
会看到了最后一次操作，

179
00:10:52,160 --> 00:10:55,040
由上一任 leader 执行的（操作）。

180
00:10:55,890 --> 00:10:58,320
所以，这将我们奠定基础，

181
00:10:58,320 --> 00:11:03,450
我们可以构建容错服务，

182
00:11:03,510 --> 00:11:05,310
可以处理网络分区，

183
00:11:05,460 --> 00:11:09,420
在服务器故障中，

184
00:11:10,040 --> 00:11:12,020
仍然实现很强的一致性。

185
00:11:13,130 --> 00:11:17,510
另一种考虑这个大多数的方式是，

186
00:11:17,780 --> 00:11:19,610
如果发生网络分区，

187
00:11:20,330 --> 00:11:25,040
只会有一个拥有多数的分区，

188
00:11:25,310 --> 00:11:27,680
不会有其他分区具有多数，

189
00:11:28,130 --> 00:11:33,320
所以，只有拥有多数的分区才能继续进行。

190
00:11:35,070 --> 00:11:36,360
换一种说法是，

191
00:11:36,360 --> 00:11:39,090
另一种含义是，

192
00:11:39,300 --> 00:11:40,350
也有可能是这样的，

193
00:11:40,350 --> 00:11:42,840
有多个分区，

194
00:11:42,900 --> 00:11:44,700
任何地方都没有多数，

195
00:11:44,760 --> 00:11:46,110
在那个特殊的案例中，

196
00:11:46,110 --> 00:11:48,450
系统不能继续运行，

197
00:11:48,660 --> 00:11:53,070
访问它的客户端必须等待，

198
00:11:53,100 --> 00:11:55,110
直到网络完全修复，

199
00:11:55,110 --> 00:11:56,400
至少有一个，

200
00:11:56,580 --> 00:12:00,090
至少有一个分区包含大多数服务。

201
00:12:04,010 --> 00:12:07,490
另一种简单的观察是，

202
00:12:07,790 --> 00:12:10,430
当然，你可能想要使用这个方案，

203
00:12:10,430 --> 00:12:11,930
我刚才描述了三台服务器，

204
00:12:11,930 --> 00:12:14,570
只能容忍一台服务器停机，

205
00:12:14,570 --> 00:12:15,740
如果两台服务器停机，

206
00:12:15,740 --> 00:12:18,110
没有人能真正获得多数，

207
00:12:18,110 --> 00:12:19,700
所以没有人可以

208
00:12:19,700 --> 00:12:22,730
或没有客户端可以真正完成操作，

209
00:12:23,630 --> 00:12:25,580
显然，这个想法很容易推广，

210
00:12:25,640 --> 00:12:29,930
通过通常被称为 2f+1 复制的方式。

211
00:12:30,500 --> 00:12:33,920
所以如果你想容忍 f 个错误而不是 1 个，

212
00:12:34,160 --> 00:12:36,830
你需要 2f+1 台服务器，

213
00:12:36,830 --> 00:12:40,610
如果 f 失败，至少你还有多数。

214
00:12:41,380 --> 00:12:43,780
所以，这里 f 是 1 ，

215
00:12:43,780 --> 00:12:45,190
所以我们运行的是 3 台服务器，

216
00:12:45,460 --> 00:12:48,550
你h希望 f 是 2 ，你有 5 台服务器，等等，

217
00:12:48,670 --> 00:12:50,710
你希望 f 为 3 ，那么有 7 台服务器。

218
00:12:51,700 --> 00:12:52,420
好的?

219
00:12:53,090 --> 00:12:56,840
还有一件事可能需要指出，

220
00:12:56,840 --> 00:12:58,310
我在问题中提到了很多，

221
00:12:58,490 --> 00:13:00,170
大多数是什么，

222
00:13:00,650 --> 00:13:06,080
多数是所有服务中的大多数，

223
00:13:06,110 --> 00:13:08,810
包括开机和停机的。

224
00:13:09,260 --> 00:13:10,640
所以，当你获得多数时，

225
00:13:10,640 --> 00:13:12,050
你不是获得 2 个中的大多数，

226
00:13:12,050 --> 00:13:13,010
如果这里只有两个存活，

227
00:13:13,010 --> 00:13:15,230
你获得系统中所有服务器的大多数。

228
00:13:20,060 --> 00:13:23,810
对于这个关键想法，有什么问题吗？

229
00:13:23,960 --> 00:13:26,720
会有偶数台服务器吗，

230
00:13:26,720 --> 00:13:28,910
比如，你有 4 台服务器，且占多数，

231
00:13:28,910 --> 00:13:30,020
而不是 3 台。

232
00:13:30,260 --> 00:13:32,990
如果你会在几个案例中看到这一点，

233
00:13:32,990 --> 00:13:35,720
在图表中，

234
00:13:35,720 --> 00:13:37,610
如果服务器的数量

235
00:13:37,610 --> 00:13:40,220
从 7 台减少到 6 台，其中一台停机了，

236
00:13:40,220 --> 00:13:41,240
而你仍然想继续，

237
00:13:41,680 --> 00:13:42,490
你需要多数，

238
00:13:42,490 --> 00:13:45,310
你仍然需要 4 台服务器才能继续。

239
00:13:47,010 --> 00:13:48,360
但如果你可以拥有 4 台服务器，

240
00:13:48,360 --> 00:13:49,410
然后你就可以继续前进了。

241
00:13:54,660 --> 00:13:56,100
好的。

242
00:13:57,710 --> 00:14:00,350
我也有一个关于大多数的问题，

243
00:14:00,410 --> 00:14:03,740
大多数是否包括服务器本身，

244
00:14:03,800 --> 00:14:07,730
假设是 raft ，服务器考虑到本身吗？

245
00:14:07,970 --> 00:14:09,290
是的，它是其中的一个，

246
00:14:09,290 --> 00:14:11,780
通常我们看到的 raft ，

247
00:14:11,780 --> 00:14:14,120
领导者直接投票给自己，

248
00:14:14,670 --> 00:14:16,590
或者候选人投票给自己，

249
00:14:16,590 --> 00:14:17,670
在领导者中，

250
00:14:17,670 --> 00:14:19,380
当它追加自己的日志时，

251
00:14:19,380 --> 00:14:20,490
它算一个，

252
00:14:21,280 --> 00:14:22,540
所以它是其中的一部分。

253
00:14:28,820 --> 00:14:31,890
好的，所以，

254
00:14:32,420 --> 00:14:38,840
有相当多的协议使用这个想法，

255
00:14:39,840 --> 00:14:44,280
有时这些想法被称为法定人数协议，

256
00:14:50,120 --> 00:14:52,280
很明显的原因，

257
00:14:52,550 --> 00:14:54,170
大概有两个，

258
00:14:54,980 --> 00:14:56,450
[]的状态维持了很长一段段时间，

259
00:14:56,450 --> 00:14:59,000
直到 90 年代初或 80 年代末，

260
00:14:59,120 --> 00:15:00,800
基本上没有协议，

261
00:15:01,070 --> 00:15:05,060
所以，我们总是处于这种单点故障的情况下。

262
00:15:05,650 --> 00:15:07,210
然后在 90 年代初，

263
00:15:07,210 --> 00:15:09,400
出现了两个协议，

264
00:15:10,350 --> 00:15:12,210
几乎在同一时间被发明，

265
00:15:12,240 --> 00:15:13,230
一种叫 Paxos ，

266
00:15:13,230 --> 00:15:14,910
这个在论文中提到了很多，

267
00:15:15,060 --> 00:15:18,630
另一种称为 View-Stamped 复制，

268
00:15:23,840 --> 00:15:25,010
有时称为 VR ，

269
00:15:25,490 --> 00:15:28,310
它们都是在 1990 年左右发明的。

270
00:15:29,580 --> 00:15:33,930
在那个时间点上，它们并没有得到太多关注，

271
00:15:34,110 --> 00:15:36,510
因为人们并没有迫切需要

272
00:15:36,510 --> 00:15:40,740
[]一种完全自动化和容错的系统。

273
00:15:41,240 --> 00:15:43,850
但在过去的 15 年里，情况发生了变化，

274
00:15:43,850 --> 00:15:45,470
在过去的 15 年里，

275
00:15:45,500 --> 00:15:47,210
大量使用这些协议。

276
00:15:56,690 --> 00:16:00,260
事实上，观察起来很有趣，

277
00:16:00,260 --> 00:16:03,200
在过去的 15 年里。

278
00:16:05,800 --> 00:16:09,250
这是在这些协议发明 15 年后，

279
00:16:09,430 --> 00:16:13,150
它们在桌子上或在架子上放了 15 年，

280
00:16:13,150 --> 00:16:15,250
直到人们有了真正的用例。

281
00:16:16,020 --> 00:16:22,140
我们将在实验中实施的协议，

282
00:16:22,140 --> 00:16:23,520
我们将在讲座中讨论，

283
00:16:23,520 --> 00:16:25,020
论文的主题，

284
00:16:25,140 --> 00:16:29,370
就是这个称为 raft 的协议。

285
00:16:30,940 --> 00:16:36,100
我认为它是 2014 年产生或写下的，

286
00:16:36,100 --> 00:16:38,230
2014 年的论文，

287
00:16:38,230 --> 00:16:40,600
这是更完整的描述之一，

288
00:16:40,840 --> 00:16:42,370
它涉及到很多不同的方面，

289
00:16:42,370 --> 00:16:45,430
你能够构建完全复制状态机，

290
00:16:45,430 --> 00:16:47,110
并清楚地解释了这些，

291
00:16:47,110 --> 00:16:50,140
这是为什么我们要把它用于实验的原因之一，

292
00:16:50,140 --> 00:16:51,880
对于这个课程。

293
00:16:55,940 --> 00:17:00,410
关于协议历史，有什么问题吗，

294
00:17:03,210 --> 00:17:04,740
在我讨论 raft 之前。

295
00:17:11,350 --> 00:17:18,180
好的，在真正讨论 raft 之前，

296
00:17:18,180 --> 00:17:19,740
首先，让我简单介绍一下

297
00:17:19,740 --> 00:17:23,250
如何使用 raft 构建复制状态机，

298
00:17:24,320 --> 00:17:26,390
因为这是我们最终的目标，

299
00:17:27,540 --> 00:17:32,850
这有助于我们思考 raft 能为我们做什么。

300
00:17:33,510 --> 00:17:36,720
所以你使用 raft 的基本方法是，

301
00:17:36,720 --> 00:17:38,460
我们会在实验 3 中做这件事。

302
00:17:38,790 --> 00:17:41,700
假设你有一台服务器，

303
00:17:43,680 --> 00:17:46,530
而 raft 就是一个库，

304
00:17:46,980 --> 00:17:50,400
在我们的设置中是一个 Go 包，

305
00:17:50,400 --> 00:17:53,400
你可以编写一个状态复制机

306
00:17:53,400 --> 00:17:55,320
通过导入这个包，

307
00:17:55,350 --> 00:17:57,000
所以我们得到，

308
00:17:57,180 --> 00:18:00,300
在底部有一个 raft ，

309
00:18:02,860 --> 00:18:07,300
你使用 raft 构建一台服务器，

310
00:18:07,450 --> 00:18:09,790
例如，在实验 3 中，

311
00:18:09,790 --> 00:18:12,950
我们将使用 raft 构建一个键值服务器，

312
00:18:14,520 --> 00:18:20,210
客户端与键值服务器交互，

313
00:18:23,760 --> 00:18:26,880
这有点像 put 和 get 操作，

314
00:18:29,180 --> 00:18:30,980
而键值服务器，

315
00:18:30,980 --> 00:18:33,830
当它收到这些 put 和 get 操作时，

316
00:18:34,130 --> 00:18:35,840
它把它交给 raft ，

317
00:18:36,840 --> 00:18:39,600
所以它放到 raft 中，

318
00:18:39,600 --> 00:18:40,920
放入一个，

319
00:18:40,950 --> 00:18:43,740
我们会看到更多细节，

320
00:18:43,740 --> 00:18:44,940
它会把它放入日志，

321
00:18:46,050 --> 00:18:47,670
稍微重新画一下，

322
00:18:48,930 --> 00:18:52,260
将它附加到日志中，

323
00:18:54,750 --> 00:18:57,150
它附加到日志的末尾，

324
00:18:57,790 --> 00:19:00,670
然后 raft 内部与其他服务器交互，

325
00:19:00,670 --> 00:19:02,260
复制这个日志。

326
00:19:03,060 --> 00:19:05,430
这里有一些其他的服务器，

327
00:19:05,850 --> 00:19:08,070
它们的结构基本上是完全一样的，

328
00:19:08,070 --> 00:19:10,080
它们都有一个 raft 库组件，

329
00:19:11,180 --> 00:19:12,530
以及键值服务器，

330
00:19:13,370 --> 00:19:15,830
就像我们见过的许多其他复制状态机一样，

331
00:19:16,640 --> 00:19:20,800
它们是相同的键值服务器，

332
00:19:21,130 --> 00:19:22,720
我们要玩同样的游戏，

333
00:19:22,720 --> 00:19:25,420
像其他以前的复制的状态机，

334
00:19:25,420 --> 00:19:28,450
向键值服务器提供操作，

335
00:19:28,450 --> 00:19:31,570
以相同的顺序，

336
00:19:31,780 --> 00:19:32,620
因此，

337
00:19:32,620 --> 00:19:36,700
以完全相同的顺序复制所有 [applied] 操作，

338
00:19:36,730 --> 00:19:41,530
我们会看到同样的键值存储，

339
00:19:41,530 --> 00:19:44,110
我们在这里有一个键值存储，

340
00:19:44,110 --> 00:19:46,510
键 20 有一些值，

341
00:19:46,660 --> 00:19:48,790
我们更新这个表，

342
00:19:48,790 --> 00:19:51,310
以完全相同的顺序，对所有副本，

343
00:19:51,490 --> 00:19:53,170
事情应该是好的，

344
00:19:53,200 --> 00:19:54,940
我们会有一样的复制。

345
00:19:56,070 --> 00:19:58,500
raft 构建的方式是，

346
00:19:58,500 --> 00:20:00,180
其中一个复制是领导者，

347
00:20:00,210 --> 00:20:02,580
所以为了方便起见，

348
00:20:02,580 --> 00:20:04,770
这是这一边的第一个，

349
00:20:05,010 --> 00:20:07,380
客户端访问领导者，

350
00:20:08,100 --> 00:20:12,630
然后，接下来发生的是，

351
00:20:12,630 --> 00:20:16,500
客户端访问其中一个领导者，

352
00:20:16,500 --> 00:20:18,660
kv 服务器的领导者，

353
00:20:18,840 --> 00:20:23,880
将日志条目附加到领导者的 raft 日志中，

354
00:20:24,000 --> 00:20:29,430
然后可以与其他的 raft 库进行交互，

355
00:20:29,850 --> 00:20:31,860
还有一些 raft 库也做同样的事情，

356
00:20:31,860 --> 00:20:35,100
它们将操作附加到日志中，

357
00:20:36,340 --> 00:20:37,480
添加到它们的日志中，

358
00:20:39,840 --> 00:20:44,360
发送响应给领导者。

359
00:20:46,030 --> 00:20:50,290
当然，所有这些状态都是存储的，

360
00:20:50,650 --> 00:20:53,080
日志以及一些其他状态存储在磁盘上，

361
00:20:53,080 --> 00:20:55,150
所以如果其中任何一个失败了，

362
00:20:55,450 --> 00:21:00,070
它们至少有最后一部分的日志可用，

363
00:21:00,190 --> 00:21:01,960
并可以从那里进行构建。

364
00:21:02,930 --> 00:21:06,710
我们会更详细地讨论一下，

365
00:21:06,710 --> 00:21:11,810
但是一旦日志条目在 3 个服务器上复制，

366
00:21:11,900 --> 00:21:16,310
然后，它们可以按顺序传送到键值服务器。

367
00:21:18,280 --> 00:21:20,710
所以，每个提交的操作，

368
00:21:20,710 --> 00:21:22,150
每个日志都有一个索引，

369
00:21:22,150 --> 00:21:27,430
操作索引为 0 或为 1 2 3 4 ，任何有顺序的，

370
00:21:27,430 --> 00:21:29,950
它们将会按顺序传送到键值服务器，

371
00:21:29,950 --> 00:21:30,910
一旦操作被提交，

372
00:21:30,910 --> 00:21:33,820
它将被传送到键值服务器，

373
00:21:33,850 --> 00:21:36,070
键值服务器执行该操作，

374
00:21:36,130 --> 00:21:40,060
可能更新键值表，

375
00:21:40,180 --> 00:21:43,750
然后，领导者单独向客户发回响应。

376
00:21:44,790 --> 00:21:48,180
所以这是一系列事件大概发生的顺序，

377
00:21:48,180 --> 00:21:50,310
客户端向领导者发送请求，

378
00:21:50,340 --> 00:21:52,230
领导者把[]给 raft ，

379
00:21:52,230 --> 00:21:55,950
raft 和其他服务器交互，

380
00:21:55,950 --> 00:21:59,430
一旦它复制了足够多的机器，

381
00:21:59,550 --> 00:22:02,280
那么它被任务已经提交了，

382
00:22:02,550 --> 00:22:05,790
我们随后会讨论更准确的提交的含义，

383
00:22:05,970 --> 00:22:09,600
然后提交的操作传递给键值服务器，

384
00:22:09,960 --> 00:22:13,890
然后它们执行操作并响应客户端，

385
00:22:13,890 --> 00:22:15,180
领导者回应客户端。

386
00:22:17,390 --> 00:22:19,580
那么，失败后会发生什么，

387
00:22:24,300 --> 00:22:29,390
如果失败，新领导者就会当选，

388
00:22:31,470 --> 00:22:33,510
它将接替旧领导者的角色，

389
00:22:34,050 --> 00:22:35,880
例如，在这张图片中，

390
00:22:35,880 --> 00:22:37,350
情况可能是这样的，

391
00:22:37,650 --> 00:22:40,260
这个领导者崩溃了，

392
00:22:41,130 --> 00:22:44,940
然后这个成为下一届的新领导者，

393
00:22:44,940 --> 00:22:46,380
我们会明白这到底是什么意思，

394
00:22:46,710 --> 00:22:48,810
然后客户端会发生故障转移，

395
00:22:48,840 --> 00:22:50,940
它们会看到的，它们得不到回应，

396
00:22:50,940 --> 00:22:51,990
所以它们会超时，

397
00:22:52,350 --> 00:22:55,950
它们转移到第二个领导者，新的领导者，

398
00:22:56,070 --> 00:22:57,720
重试它们的操作。

399
00:22:58,440 --> 00:23:01,980
所以新领导者将接管它们的操作，

400
00:23:01,980 --> 00:23:03,570
把它放回 raft ，

401
00:23:03,570 --> 00:23:05,940
和以前一样的事情发生了，

402
00:23:06,120 --> 00:23:07,800
也许这一次我们很幸运，

403
00:23:07,800 --> 00:23:10,260
我们完成了操作，没有失败。

404
00:23:11,640 --> 00:23:13,380
如果你仔细想想这件事，

405
00:23:13,380 --> 00:23:14,790
这意味着，

406
00:23:15,060 --> 00:23:18,270
客户端操作可能会在日志中出现两次，

407
00:23:18,270 --> 00:23:20,850
因为可能是在它第一次成功了，

408
00:23:20,850 --> 00:23:22,410
但是没有得到回应，

409
00:23:22,710 --> 00:23:24,450
所以它不知道自己成功了，

410
00:23:24,450 --> 00:23:25,200
它将重试，

411
00:23:25,200 --> 00:23:28,560
这个新的领导者会把日志，

412
00:23:28,560 --> 00:23:31,650
把新的重试操作也放在日志中，

413
00:23:31,710 --> 00:23:36,720
它将在键值服务器的某个时刻出现，

414
00:23:36,720 --> 00:23:39,720
实际上是重复的，

415
00:23:39,810 --> 00:23:45,490
正如你们将在实验 3 看到的，

416
00:23:45,550 --> 00:23:48,640
实际上，

417
00:23:48,670 --> 00:23:52,540
你需要检测重复。

418
00:24:01,060 --> 00:24:02,530
但这主要是实验 3 的问题，

419
00:24:02,590 --> 00:24:04,960
不是目前的主要问题，

420
00:24:04,960 --> 00:24:06,190
但重要的是，

421
00:24:06,220 --> 00:24:08,890
这是一种普遍的风格，

422
00:24:09,070 --> 00:24:13,990
人们使用 raft 来构建一个复制状态机。

423
00:24:18,940 --> 00:24:24,070
关于如何将 raft 用于复制状态机，有什么问题吗？

424
00:24:25,090 --> 00:24:26,050
我们在聊天中有一个问题。

425
00:24:26,320 --> 00:24:27,010
好的。

426
00:24:28,230 --> 00:24:32,970
访问领导者的客户端数量通常是多少？

427
00:24:34,380 --> 00:24:36,390
可能会有很多，

428
00:24:36,390 --> 00:24:39,480
它没有真正的限制，

429
00:24:39,480 --> 00:24:40,860
你会看到，

430
00:24:40,860 --> 00:24:43,440
可能是一台机器可以，

431
00:24:43,440 --> 00:24:44,280
也许这是不明显的，

432
00:24:44,280 --> 00:24:45,000
但问题是，

433
00:24:45,180 --> 00:24:48,510
一个领导者无法容忍，

434
00:24:48,510 --> 00:24:52,620
没有能力处理这么多客户端，

435
00:24:52,620 --> 00:24:55,440
所以，接下来会发生的是，

436
00:24:55,440 --> 00:24:57,090
服务器会分片，

437
00:24:57,120 --> 00:25:01,170
将键值服务器分片到多个 raft 组中，

438
00:25:01,800 --> 00:25:04,500
例如，分片 1 是一个 raft 实例，

439
00:25:04,530 --> 00:25:06,270
分片 2 是一个 raft 实例，

440
00:25:06,300 --> 00:25:07,890
分片 3 是一个 raft 实例，

441
00:25:07,890 --> 00:25:14,520
客户端访问对应的分片以应用其操作，

442
00:25:14,520 --> 00:25:18,390
通过这种方式，我们可以将服务器扩展到许多客户端，

443
00:25:18,390 --> 00:25:20,130
事实上，这就是实验 4 所做的。

444
00:25:22,760 --> 00:25:24,320
客户端如何知道

445
00:25:24,320 --> 00:25:27,260
在旧领导者失败后，如何与新领导者通信？

446
00:25:27,410 --> 00:25:31,340
客户端有系统中所有服务器的列表，

447
00:25:31,760 --> 00:25:32,810
在这种情况下，

448
00:25:32,810 --> 00:25:34,010
我们运行三台服务器，

449
00:25:34,010 --> 00:25:36,050
每个人都同意只有三台服务器，

450
00:25:36,200 --> 00:25:37,730
客户端知道这三台服务器，

451
00:25:38,000 --> 00:25:40,730
它们随机尝试，

452
00:25:40,970 --> 00:25:44,360
如果这不是客户端，它将重定向，

453
00:25:44,360 --> 00:25:45,410
这不是领导者，

454
00:25:45,410 --> 00:25:48,710
它会将客户端重定向到适当的，实际的领导者。

455
00:25:51,040 --> 00:25:52,720
是的，答案很清楚。

456
00:25:53,890 --> 00:25:58,180
但我们是否认为这些服务器在地理位置上是相近的，

457
00:25:58,180 --> 00:26:00,460
彼此很亲近，或者它们可以。

458
00:26:00,460 --> 00:26:02,620
原则上，它们可能相距甚远，

459
00:26:02,710 --> 00:26:05,740
这边没有真正的限制，

460
00:26:06,010 --> 00:26:07,300
当然，唯一的问题是，

461
00:26:07,300 --> 00:26:10,360
如果它服务于很远的世界各地，

462
00:26:10,570 --> 00:26:15,160
获取日志记录追加的延迟，

463
00:26:15,160 --> 00:26:16,360
将需要一段时间，

464
00:26:16,840 --> 00:26:18,430
所以，延迟会变长。

465
00:26:22,750 --> 00:26:27,010
kv存储中执行的日志条目是什么？

466
00:26:27,690 --> 00:26:32,460
一旦它被 raft 提交，

467
00:26:32,490 --> 00:26:34,230
一旦 raft 确定，

468
00:26:34,230 --> 00:26:36,450
有足够的复制收到了它，

469
00:26:36,450 --> 00:26:40,290
现在，不能能回退那个操作，

470
00:26:40,440 --> 00:26:43,770
然后，它被送往键值服务器。

471
00:26:45,560 --> 00:26:49,010
所以领导者会首先执行这个命令，

472
00:26:49,010 --> 00:26:52,610
领导者会告诉跟随者这个命令已经提交，

473
00:26:52,610 --> 00:26:54,440
然后是跟随者。

474
00:26:54,440 --> 00:26:57,590
一旦领导者知道操作被提交，

475
00:26:57,590 --> 00:26:59,690
从键值服务器获得的。

476
00:26:59,720 --> 00:27:01,520
让我们现在谈一谈，

477
00:27:01,910 --> 00:27:04,100
我将在进行的过程中更详细地介绍，

478
00:27:04,550 --> 00:27:07,610
所以，更多地了解协议的概况。

479
00:27:07,610 --> 00:27:10,370
上一个页面是一个概述，

480
00:27:10,370 --> 00:27:14,390
关于如何使用 raft 构建复制状态机，

481
00:27:14,510 --> 00:27:17,840
现在让我们更详细地看看 raft 。

482
00:27:17,840 --> 00:27:19,820
所以我们这里有时间线，

483
00:27:19,910 --> 00:27:22,860
有一个领导者，有两个跟随者，

484
00:27:24,670 --> 00:27:25,930
我们运行了三个。

485
00:27:26,260 --> 00:27:28,690
客户端访问领导者，

486
00:27:29,380 --> 00:27:33,740
领导者有日志，

487
00:27:33,770 --> 00:27:37,250
所有的 put 和 get 操作，

488
00:27:37,250 --> 00:27:38,480
当它得到一个新的（日志），

489
00:27:38,510 --> 00:27:40,610
把它附加到日志的末尾，

490
00:27:41,890 --> 00:27:43,840
然后它会发送它，

491
00:27:43,990 --> 00:27:46,330
发送日志条目给，

492
00:27:47,640 --> 00:27:49,800
（发送）新日志条目给跟随者。

493
00:27:56,000 --> 00:27:58,490
比如跟随者 2 ，

494
00:27:58,490 --> 00:28:00,200
这是跟随者 1 ，这是跟随者 2 ，

495
00:28:00,200 --> 00:28:02,630
跟随者 1 接收到日志条目，

496
00:28:02,630 --> 00:28:03,410
一切都很好，

497
00:28:03,410 --> 00:28:05,450
附加在日志的末尾，

498
00:28:05,450 --> 00:28:07,250
它发回一个确认，

499
00:28:07,250 --> 00:28:09,020
表示是的，我附加了它。

500
00:28:09,500 --> 00:28:14,540
在 raft 的这一点上，

501
00:28:14,570 --> 00:28:18,710
两个服务器有日志条目，

502
00:28:19,190 --> 00:28:23,000
领导者可以提交日志条目，

503
00:28:23,840 --> 00:28:25,790
在这一点上，

504
00:28:25,790 --> 00:28:33,250
领导者可以移交刚刚收到的请求，

505
00:28:33,250 --> 00:28:35,380
可以将其移交给 kv 服务器。

506
00:28:36,800 --> 00:28:38,630
实验执行这个操作的方式，

507
00:28:38,630 --> 00:28:40,610
或者实验[]所做的是，

508
00:28:40,610 --> 00:28:43,820
我们有一个 Go channel ，

509
00:28:44,060 --> 00:28:49,310
一个 Go channel 是一个 raft Goroutine ，

510
00:28:49,490 --> 00:28:51,410
而 raft Goroutine 决定

511
00:28:51,410 --> 00:28:53,570
一个操作已经提交，

512
00:28:53,720 --> 00:28:57,770
它只是把操作发送给 apply channel ，

513
00:28:57,860 --> 00:29:00,050
让键值服务器可以应用它。

514
00:29:01,610 --> 00:29:02,690
以后的某一点，

515
00:29:02,720 --> 00:29:04,580
所以注意这一点，

516
00:29:04,700 --> 00:29:08,870
领导者已经提交了操作，

517
00:29:09,140 --> 00:29:13,310
对于领导者提交这次操作是绝对安全的，

518
00:29:13,490 --> 00:29:16,010
因为大多数服务器，

519
00:29:16,010 --> 00:29:19,190
实际上大多数节点都已经收到了操作，

520
00:29:19,190 --> 00:29:21,110
所以即使有一次失败，

521
00:29:21,500 --> 00:29:23,000
我们选举一个新的领导者，

522
00:29:23,240 --> 00:29:24,470
在这种情况下，

523
00:29:24,470 --> 00:29:26,180
领导者是其中一个服务器，

524
00:29:26,180 --> 00:29:28,970
它包含最后的操作，

525
00:29:29,060 --> 00:29:32,930
是由上一个领导者附加到日志中的。

526
00:29:33,730 --> 00:29:34,780
所以一切都很好，

527
00:29:35,110 --> 00:29:36,730
当然，最后一个服务器，

528
00:29:36,760 --> 00:29:41,680
第一个追随者也会在某个时候做出回应，表示同意。

529
00:29:42,720 --> 00:29:46,260
所以这一点，从领导者的角度来看，

530
00:29:46,260 --> 00:29:49,740
操作已经提交了，只是追随者还不知道，

531
00:29:50,220 --> 00:29:53,700
因为追随者只知道他们得到了它，

532
00:29:53,970 --> 00:29:56,610
领导者可能拥有它，

533
00:29:56,850 --> 00:29:59,070
但它们并不真正知道，

534
00:29:59,220 --> 00:30:00,990
所以实际发生的是，

535
00:30:01,020 --> 00:30:05,130
随后的操作，当另一个客户端请求进入时，

536
00:30:05,430 --> 00:30:07,650
领导者将追加另一个日志条目，

537
00:30:07,860 --> 00:30:13,710
向跟随者发送一个新的操作或新的附加条目，

538
00:30:13,980 --> 00:30:17,340
这个附加条目做两件事，

539
00:30:17,400 --> 00:30:21,420
它为新操作提供新的日志条目，

540
00:30:21,540 --> 00:30:25,500
但它也确认所有之前的操作，

541
00:30:25,560 --> 00:30:28,080
告诉我们到目前为止提交了哪些操作。

542
00:30:28,680 --> 00:30:34,320
所以当 F1 和 F2 收到这个操作，这个 RPC ，

543
00:30:34,380 --> 00:30:38,130
它们知道操作已经被领导者提交了，

544
00:30:38,340 --> 00:30:39,600
所以，在这一点上，

545
00:30:39,630 --> 00:30:43,530
它们也可以传递给它们的键值实例，

546
00:30:44,240 --> 00:30:45,860
并且知道这个操作已经提交。

547
00:30:50,460 --> 00:30:52,680
我有一个简短的问题，

548
00:30:52,680 --> 00:30:59,800
所以，当领导者发送操作，

549
00:30:59,830 --> 00:31:02,860
并得到服务器响应，

550
00:31:03,070 --> 00:31:04,120
这是不是意味着，

551
00:31:04,150 --> 00:31:06,100
这意味着它在日志中，对吧，

552
00:31:07,240 --> 00:31:08,680
但是（以下情况）会发生什么，

553
00:31:08,680 --> 00:31:11,650
如果你有一个[轻微的]多数，

554
00:31:11,680 --> 00:31:14,800
然后其中一个服务器崩溃，

555
00:31:14,980 --> 00:31:18,400
我们的日志必须存储在存储中，比如磁盘。

556
00:31:18,550 --> 00:31:20,860
是的，这是一个非常好的问题，

557
00:31:20,860 --> 00:31:23,320
日志的每一次更改，

558
00:31:23,560 --> 00:31:25,750
所以你仔细看看 raft 论文，

559
00:31:26,050 --> 00:31:30,280
有些状态是必须稳定的，

560
00:31:30,890 --> 00:31:33,830
日志是那些必须稳定的信息之一，

561
00:31:33,830 --> 00:31:36,620
以及 term 编号和很多其他东西。

562
00:31:37,180 --> 00:31:39,190
所以，如果服务器崩溃，

563
00:31:39,550 --> 00:31:42,310
不是什么大事，

564
00:31:42,310 --> 00:31:46,420
因为大多数服务器的磁盘上都有该条目，

565
00:31:47,650 --> 00:31:49,630
当它们回来的时候，它们会找到的。

566
00:31:53,160 --> 00:31:54,450
我有个问题？

567
00:31:54,600 --> 00:31:54,990
好的。

568
00:31:55,110 --> 00:31:57,150
那么会发生什么，

569
00:31:57,150 --> 00:32:02,070
如果跟随者 1 回答是的并提交，

570
00:32:03,240 --> 00:32:09,570
在它向其余跟随者发送下一个命令提交之前，

571
00:32:09,570 --> 00:32:10,170
它崩溃了，

572
00:32:10,440 --> 00:32:13,590
现在很多追随者不知道它们需要提交，

573
00:32:13,590 --> 00:32:14,910
因为领导者已经崩溃了，

574
00:32:15,880 --> 00:32:18,160
那么，这不会带来问题吗？

575
00:32:18,490 --> 00:32:19,420
它们会提交，

576
00:32:19,450 --> 00:32:22,060
因为它在一个跟随者的日志里，

577
00:32:22,330 --> 00:32:24,610
正如我们将在领导者选举规则中看到的，

578
00:32:24,610 --> 00:32:25,810
它会成为新领导者，

579
00:32:26,480 --> 00:32:31,550
它会将追加条目传播到其他服务器，

580
00:32:31,550 --> 00:32:32,810
然后它们也会应用。

581
00:32:34,010 --> 00:32:35,690
好的，我明白了，好的，谢谢。

582
00:32:37,090 --> 00:32:38,230
好的，这带来了，

583
00:32:38,230 --> 00:32:41,050
转到下一个主题，

584
00:32:41,050 --> 00:32:42,970
为什么日志，

585
00:32:44,620 --> 00:32:47,170
最后三个问题都是关于这个的。

586
00:32:47,350 --> 00:32:47,620
好的。

587
00:32:47,620 --> 00:32:50,590
我有一个最后一个问题的后续问题，

588
00:32:50,770 --> 00:32:56,650
所以，服务器在发生共识后崩溃，

589
00:32:57,300 --> 00:32:59,400
比如正好在提交之前，

590
00:32:59,990 --> 00:33:02,930
它可以推迟提交，对吗？

591
00:33:02,930 --> 00:33:04,280
你说的提交是什么意思？

592
00:33:04,670 --> 00:33:09,480
比如它达成共识之后，

593
00:33:09,480 --> 00:33:12,360
在它有大多数之后，

594
00:33:13,180 --> 00:33:16,420
它可以像论文上说的那样，

595
00:33:16,450 --> 00:33:20,740
你可以告诉其他服务器，

596
00:33:20,740 --> 00:33:22,540
你告诉它们，一切都准备好了，

597
00:33:23,020 --> 00:33:25,180
或者抱歉它被提交了，已经准备好，

598
00:33:25,680 --> 00:33:29,100
在状态机中执行，

599
00:33:30,860 --> 00:33:31,970
所以，如果它崩溃，

600
00:33:31,970 --> 00:33:35,120
在告诉所有服务器，它准备好执行之前，

601
00:33:35,780 --> 00:33:37,760
它可以延迟执行，对吧。

602
00:33:38,370 --> 00:33:39,750
它可以延迟执行，

603
00:33:39,840 --> 00:33:40,890
好的，首先，

604
00:33:40,890 --> 00:33:43,830
如果领导者在这一点上失败了，什么都不会发生，

605
00:33:43,830 --> 00:33:47,190
至少客户端不能继续进行任何其他更多操作，

606
00:33:47,580 --> 00:33:49,800
所以，如果你考虑的话，

607
00:33:49,800 --> 00:33:51,930
在这一点上， raft 重新配置自己，

608
00:33:52,370 --> 00:33:53,420
选举新的领导者，

609
00:33:54,010 --> 00:33:56,950
也就是 F1 或 F2 ，

610
00:33:57,040 --> 00:33:58,600
这两个中的一人将成为新的领导者，

611
00:33:58,600 --> 00:34:00,220
另一个成为跟随者，

612
00:34:00,730 --> 00:34:02,950
两个中的一个已经收到了，

613
00:34:02,980 --> 00:34:06,880
领导者可能已经提交的追加条目，

614
00:34:06,910 --> 00:34:09,220
实际上，它可能已经被 kv （服务器）执行了，

615
00:34:09,690 --> 00:34:10,650
这是没有问题的，

616
00:34:10,650 --> 00:34:11,790
因为它们中的一个包含它，

617
00:34:12,210 --> 00:34:14,070
这个将成为领导者，

618
00:34:14,070 --> 00:34:16,380
我们将在后面的领导者选举规则中看到，

619
00:34:16,860 --> 00:34:20,040
那个将提交到它的 kv 服务器，

620
00:34:20,070 --> 00:34:22,830
并将它复制给其他跟随者，

621
00:34:22,860 --> 00:34:25,080
然后它将应用于每个 kv 服务器，

622
00:34:25,230 --> 00:34:28,320
最后，所有（服务器）以相同的顺序应用所有操作。

623
00:34:28,780 --> 00:34:31,360
我同意，最终它会发生，

624
00:34:31,360 --> 00:34:32,620
但它可能会推迟，对吗？

625
00:34:39,620 --> 00:34:40,070
是啊，完全有可能推迟，

626
00:34:40,070 --> 00:34:42,950
[]，对所有追随者来说，一个完整的日志，

627
00:34:42,950 --> 00:34:44,780
它会，

628
00:34:45,050 --> 00:34:46,310
它的工作方式是，

629
00:34:46,310 --> 00:34:48,470
它尝试发送它的日志的结尾，

630
00:34:48,740 --> 00:34:51,860
如果一个跟随者没有识别出日志的结尾，

631
00:34:51,860 --> 00:34:52,640
就回退，

632
00:34:52,670 --> 00:34:55,880
发送更多更早的条目，

633
00:34:55,910 --> 00:34:56,960
我们以后再讨论这件事。

634
00:34:57,980 --> 00:34:59,930
但是，最终情况可能是这样的，

635
00:34:59,930 --> 00:35:03,590
领导者将向其中一个跟随者重播它的完整日志，

636
00:35:03,710 --> 00:35:06,350
如果一个跟随者错过了所有日志条目。

637
00:35:07,800 --> 00:35:09,360
我要回到日志了。

638
00:35:10,440 --> 00:35:15,450
所以你可能想知道为什么会有日志，

639
00:35:15,450 --> 00:35:18,480
因为 kv 服务器，它也有一个数据库，

640
00:35:18,810 --> 00:35:21,690
有一个表，里面有所有的信息，

641
00:35:21,690 --> 00:35:24,780
那么为什么我们需要这样的信息两次，

642
00:35:24,780 --> 00:35:28,800
一次在日志中，一次在 kv 表中。

643
00:35:28,950 --> 00:35:30,240
有几个原因，

644
00:35:30,680 --> 00:35:32,060
一个是，

645
00:35:32,060 --> 00:35:35,450
几个已经在问题中出现了，

646
00:35:35,480 --> 00:35:36,920
一个是用于重传，

647
00:35:44,090 --> 00:35:49,160
当领导者向其中一个跟随者发送这些附加条目时，

648
00:35:49,160 --> 00:35:50,420
消息可能会丢失，

649
00:35:50,630 --> 00:35:53,060
所以，领导者必须能够重传，

650
00:35:53,060 --> 00:35:56,060
所以，我们需要保留所有日志条目的记录，

651
00:35:56,060 --> 00:35:59,150
那些正在[传输中]的。

652
00:35:59,950 --> 00:36:02,680
第二个原因可能是主要的原因，

653
00:36:02,680 --> 00:36:04,000
首先，我们需要顺序，

654
00:36:04,790 --> 00:36:10,330
每个追加操作或每个命令必须传输，

655
00:36:10,330 --> 00:36:14,050
以相同的顺序在所有的复制上，

656
00:36:14,440 --> 00:36:16,630
对于我们来说，日志是一种非常方便的方式

657
00:36:16,630 --> 00:36:18,010
来维护这种顺序，

658
00:36:18,340 --> 00:36:20,470
所以第二个原因是重播。

659
00:36:20,710 --> 00:36:23,470
第三个原因是我们需要持久化，

660
00:36:25,350 --> 00:36:27,480
其中一个追随者可能会崩溃，

661
00:36:28,020 --> 00:36:30,180
或者它们都可能会崩溃，

662
00:36:30,180 --> 00:36:31,710
然后它们又出现了，

663
00:36:31,710 --> 00:36:33,570
我们需要一个[位置]，

664
00:36:33,570 --> 00:36:35,580
我们可以重传日志条目，

665
00:36:35,670 --> 00:36:37,350
使每个（跟随者）都同步到最新，

666
00:36:37,380 --> 00:36:41,160
所以，日志也必须是持久化的。

667
00:36:42,110 --> 00:36:44,810
最后，我们需要一些空间

668
00:36:44,900 --> 00:36:49,490
来进行试探性的操作或试探性地提交，试探性的命令，

669
00:36:50,390 --> 00:36:53,090
就像我们之前提到的，

670
00:36:53,090 --> 00:36:54,650
它出现在前面的问题中，

671
00:36:54,650 --> 00:36:58,970
当领导者向追随者发送操作时，

672
00:36:59,060 --> 00:37:00,800
在这一点上，追随者并不知道，

673
00:37:00,800 --> 00:37:02,150
哪些操作将被提交，

674
00:37:02,150 --> 00:37:04,280
所以在这待一会儿，

675
00:37:04,400 --> 00:37:07,340
直到它了解到操作已经提交，

676
00:37:07,340 --> 00:37:09,620
所以我们需要一些空间来进行试探性操作，

677
00:37:09,620 --> 00:37:11,630
日志是做到这一点的方便的地方。

678
00:37:13,100 --> 00:37:16,580
最后，会发生的是，

679
00:37:16,580 --> 00:37:24,440
日志在所有服务器上都是相同的，

680
00:37:28,500 --> 00:37:32,610
可能在一段时间内会有不同步的情况，

681
00:37:32,610 --> 00:37:36,030
一个日志可能比其他日志有更多的条目，

682
00:37:36,150 --> 00:37:38,070
但是如果你继续运行这个系统，

683
00:37:38,070 --> 00:37:39,390
然后阻止客户端，

684
00:37:39,570 --> 00:37:41,100
然后在某个时间点，

685
00:37:41,280 --> 00:37:43,680
所有日志将是完全相同的，

686
00:37:44,040 --> 00:37:45,660
这意味着那些，

687
00:37:45,990 --> 00:37:47,550
因为它们都有相同的顺序，

688
00:37:47,550 --> 00:37:49,230
所有操作将会，

689
00:37:49,230 --> 00:37:52,860
以相同的顺序对 kv 服务器，

690
00:37:52,860 --> 00:37:55,590
然后 kv 服务器最终会是相同的状态。

691
00:37:57,340 --> 00:37:58,030
好的?

692
00:38:03,690 --> 00:38:06,570
好的，让我来简单介绍一下单个日志条目。

693
00:38:17,150 --> 00:38:18,560
所以，不管怎么说，

694
00:38:18,860 --> 00:38:20,390
我们会画很多这样的画，

695
00:38:20,390 --> 00:38:22,940
这里有很多日志条目，

696
00:38:22,940 --> 00:38:26,360
从 0 1 2 开始，

697
00:38:26,540 --> 00:38:29,240
如果我们查看其中一个日志条目，

698
00:38:29,420 --> 00:38:30,740
会有一个命令，

699
00:38:32,740 --> 00:38:34,240
我们会忽略这个，

700
00:38:34,240 --> 00:38:36,160
我们要好好考虑一下，

701
00:38:36,190 --> 00:38:38,560
这是要交付给应用程序的东西，

702
00:38:38,560 --> 00:38:42,360
比如这是一个带参数的 put 或 get 操作。

703
00:38:43,020 --> 00:38:45,600
然后第二个东西是 term ，

704
00:38:48,460 --> 00:38:51,340
这是领导者的任期，

705
00:38:55,340 --> 00:38:59,360
所以 term 是这个指令附加到日志中，

706
00:39:00,200 --> 00:39:03,080
你可以考虑的一种方式是，

707
00:39:03,170 --> 00:39:09,530
term 唯一地标识领导者将操作附加到日志，

708
00:39:09,950 --> 00:39:12,620
在每一个任期内，只有一个领导者，

709
00:39:13,230 --> 00:39:18,990
所以， term id 隐含地表示

710
00:39:18,990 --> 00:39:25,350
领导者附加日志条目，

711
00:39:26,220 --> 00:39:28,410
这里出现的数字，

712
00:39:28,410 --> 00:39:31,440
如果这是 n 或者我使用 i ，

713
00:39:32,080 --> 00:39:34,510
这是日志索引，

714
00:39:39,000 --> 00:39:42,030
所以，日志索引和 term 编号的组合，

715
00:39:42,030 --> 00:39:45,450
唯一地标识特定条目的内容，

716
00:39:45,450 --> 00:39:48,570
不会有两个日志条目，

717
00:39:48,570 --> 00:39:51,780
具有相同的索引，相同的 term 和不同的命令，

718
00:39:52,050 --> 00:39:54,210
因为只有一个领导者，

719
00:39:54,210 --> 00:39:56,910
在特定的任期内主管，

720
00:39:57,030 --> 00:40:00,840
那个领导者提交追加操作。

721
00:40:03,460 --> 00:40:06,160
没有提交的日志条目会被覆盖吗？

722
00:40:06,160 --> 00:40:07,450
是的，它们可能会被覆盖，

723
00:40:07,450 --> 00:40:08,440
我们以后再谈，

724
00:40:08,620 --> 00:40:10,450
但这当然是有可能的。

725
00:40:12,540 --> 00:40:16,250
好的，我们看这张图，

726
00:40:16,250 --> 00:40:19,190
在这一部分中有两个东西，

727
00:40:19,190 --> 00:40:20,300
我想我对这个问题的回答，

728
00:40:20,300 --> 00:40:22,280
有两件事需要发生，

729
00:40:22,490 --> 00:40:27,560
我们需要选出特定任期的领导者，

730
00:40:29,080 --> 00:40:31,840
我们需要确保，

731
00:40:34,440 --> 00:40:35,940
确保日志是相同的，

732
00:40:39,060 --> 00:40:42,150
我们更换领导者，

733
00:40:44,480 --> 00:40:46,460
所以我们要讨论这两个话题，

734
00:40:46,520 --> 00:40:50,120
我们从领导者选举开始，

735
00:40:50,180 --> 00:40:55,310
然后稍后再讨论如何使日志完全相同。

736
00:40:57,020 --> 00:40:57,950
好的，选举，

737
00:41:03,010 --> 00:41:06,250
选举是实验 2a 的主题，

738
00:41:06,250 --> 00:41:08,890
这个故事很简单，

739
00:41:08,890 --> 00:41:10,750
我们有，

740
00:41:10,750 --> 00:41:13,420
假设我们是具有三个条目的系统，

741
00:41:13,420 --> 00:41:18,010
我们有一个领导者，在 term 10 ，

742
00:41:18,010 --> 00:41:19,330
我们有跟随者在 term 10 ，

743
00:41:19,330 --> 00:41:20,920
所以我们的情况是稳定的，

744
00:41:21,280 --> 00:41:23,080
另一个跟随者在 term 10 ，

745
00:41:23,470 --> 00:41:26,560
假设领导者崩溃

746
00:41:26,590 --> 00:41:29,020
或者发生网络分区，

747
00:41:29,020 --> 00:41:30,790
不能继续访问了，

748
00:41:31,090 --> 00:41:33,160
接下来会发生的是，

749
00:41:33,460 --> 00:41:35,440
跟随者将开始选举。

750
00:41:36,200 --> 00:41:38,840
它们开始选举的原因是，

751
00:41:38,840 --> 00:41:40,280
它们错过了领导者的心跳，

752
00:41:47,200 --> 00:41:50,440
领导者的工作就是定期地，

753
00:41:50,530 --> 00:41:56,680
它使用固定间隔向跟随者发送附加条目，

754
00:41:57,230 --> 00:41:59,810
通常，可能会发生，

755
00:42:00,110 --> 00:42:02,120
因为很多客户端都处于活动状态，

756
00:42:02,120 --> 00:42:05,420
所以，跟随者不断地获得追加条目，

757
00:42:05,600 --> 00:42:11,180
但是如果领导者没有从客户端收到任何命令，

758
00:42:11,420 --> 00:42:15,080
那么它周期性地发送心跳，

759
00:42:15,080 --> 00:42:20,270
告诉跟随者，它仍然是领导者，

760
00:42:21,010 --> 00:42:25,060
心跳基本上是正常追加条目的形式，

761
00:42:25,120 --> 00:42:26,800
除了没有新的日志条目，

762
00:42:27,460 --> 00:42:30,940
所以领导者在心跳中告诉（跟随者），

763
00:42:30,940 --> 00:42:33,700
比如我的日志有这么长，

764
00:42:33,820 --> 00:42:37,090
这是我的最后一个条目，

765
00:42:37,090 --> 00:42:40,240
如果这些是匹配的，那么一切都很好。

766
00:42:41,190 --> 00:42:43,620
所以，如果领导者失败了，

767
00:42:43,740 --> 00:42:45,270
在几次心跳之后，

768
00:42:45,360 --> 00:42:48,840
我们会更详细地谈到这一点，

769
00:42:48,840 --> 00:42:50,370
这里有一个选举超时。

770
00:42:52,270 --> 00:42:55,270
所以跟随者运行一个计时器，

771
00:42:56,250 --> 00:42:58,980
它们重新设置计时器，

772
00:42:58,980 --> 00:43:01,650
每当收到心跳或附加条目时，

773
00:43:01,950 --> 00:43:06,030
但是如果它们没有收到任何心跳或附加条目，

774
00:43:06,090 --> 00:43:07,290
然后在某个时间点，

775
00:43:07,290 --> 00:43:10,410
在这个选举超时之后，计时器开始计时，

776
00:43:10,710 --> 00:43:13,200
在这一点上，跟随者开始选举，

777
00:43:13,350 --> 00:43:14,520
让我们假设，

778
00:43:14,520 --> 00:43:17,490
第一个跟随者首先到达那个点，

779
00:43:17,760 --> 00:43:18,660
它会做什么，

780
00:43:18,660 --> 00:43:19,740
它会发送，

781
00:43:19,830 --> 00:43:21,270
它会增加它的 term 编号，

782
00:43:21,270 --> 00:43:22,980
所以，我们将 term 编号设置为 11 ，

783
00:43:24,440 --> 00:43:27,860
它会告诉自己，

784
00:43:27,890 --> 00:43:32,510
作为（选举）的一部分，并为自己投票，

785
00:43:32,720 --> 00:43:36,500
然后会联系其他跟随者，

786
00:43:36,500 --> 00:43:37,820
也试着联系领导者，

787
00:43:37,820 --> 00:43:40,580
假设领导者宕机了，

788
00:43:40,580 --> 00:43:41,720
所以领导者不会回应，

789
00:43:41,930 --> 00:43:43,610
但第二个跟随者会回应，

790
00:43:44,440 --> 00:43:46,090
所以，在这一点上，它获得了两票，

791
00:43:46,090 --> 00:43:48,280
一个来自自己，一个来自跟随者，

792
00:43:48,490 --> 00:43:50,650
在这一点上，它成为了新的领导者，

793
00:43:50,650 --> 00:43:52,510
它成为 term 11 的领导者，

794
00:43:56,240 --> 00:43:59,540
然后客户端会故障转移到那个领导者上，

795
00:43:59,570 --> 00:44:01,820
事情会像以前一样进行。

796
00:44:03,370 --> 00:44:04,000
好的?

797
00:44:04,180 --> 00:44:08,320
现在可能有点小问题，

798
00:44:08,320 --> 00:44:09,280
你可能会担心，

799
00:44:09,280 --> 00:44:11,980
其中之一可能是以下情况，

800
00:44:11,980 --> 00:44:15,550
在领导者 10 之间有一个网络分区，

801
00:44:15,580 --> 00:44:18,310
其中领导者和跟随者都是 term 10 。

802
00:44:18,840 --> 00:44:22,050
在某一时刻，网络分区会修复，

803
00:44:22,320 --> 00:44:27,930
所以，可能客户端的请求仍然到达领导者，

804
00:44:27,930 --> 00:44:29,790
term 10 的领导者，

805
00:44:30,120 --> 00:44:32,970
当然，现在看起来，

806
00:44:32,970 --> 00:44:36,060
我们可能有两个领导者，

807
00:44:36,060 --> 00:44:39,240
我们又回到了脑裂问题上，

808
00:44:39,570 --> 00:44:41,340
事实证明并非如此，

809
00:44:41,610 --> 00:44:44,310
因为当领导者试图

810
00:44:44,950 --> 00:44:47,110
向跟随者发送追加条目时，

811
00:44:47,500 --> 00:44:51,340
向位于 term 11 的跟随者，

812
00:44:51,430 --> 00:44:54,700
它们会拒绝那些追加的条目，

813
00:44:54,970 --> 00:44:56,530
它们会告诉老的领导者，

814
00:44:56,530 --> 00:44:57,790
不好了，

815
00:44:57,820 --> 00:45:01,330
他不再是领者了，

816
00:45:01,330 --> 00:45:02,740
事实上，它们会发回一条消息，

817
00:45:02,770 --> 00:45:05,920
说，我不能做附加，

818
00:45:06,470 --> 00:45:12,200
这是我目前的 term 编号 11 ，

819
00:45:12,200 --> 00:45:13,670
领导者收到，

820
00:45:13,670 --> 00:45:16,730
看到 term 编号 11 大于 term 编号 10 ，

821
00:45:16,790 --> 00:45:19,760
从领导者退下来，变成一个跟随者。

822
00:45:20,620 --> 00:45:22,240
它们参加另一次选举，

823
00:45:22,360 --> 00:45:27,130
或者成为这三个的一部分，

824
00:45:27,340 --> 00:45:30,940
但不会出现脑裂的问题，

825
00:45:31,090 --> 00:45:34,150
因为你不能做任何操作，

826
00:45:35,740 --> 00:45:37,540
所以没有脑裂问题。

827
00:45:42,890 --> 00:45:44,480
我们避免脑裂问题的原因是，

828
00:45:44,480 --> 00:45:47,540
因为这个多数规则以及这些 term 编号。

829
00:45:51,400 --> 00:45:53,980
好的，这当然不是唯一的问题，

830
00:45:54,010 --> 00:46:00,150
我们可能面临的另一个挑战是，

831
00:46:01,730 --> 00:46:04,930
我们可能会遇到分裂选举。

832
00:46:09,160 --> 00:46:11,050
所以就像这张图，

833
00:46:11,050 --> 00:46:12,010
我们有一个领导者，

834
00:46:12,010 --> 00:46:14,020
也许这个领导者在 10 ，

835
00:46:14,530 --> 00:46:15,910
是网络分区，

836
00:46:16,480 --> 00:46:20,320
这是两个跟随者在 10 ，

837
00:46:22,540 --> 00:46:25,030
如果我们一不小心，

838
00:46:25,030 --> 00:46:26,320
也许它们会

839
00:46:26,320 --> 00:46:28,570
开始选举非常接近，

840
00:46:29,640 --> 00:46:33,630
所以 F10 投票给自己，

841
00:46:33,900 --> 00:46:35,610
第一个跟随者投票给自己，

842
00:46:35,610 --> 00:46:38,460
第二个跟随者也投票给自己，

843
00:46:38,520 --> 00:46:43,860
然后它们互相发出了投票请求，

844
00:46:44,070 --> 00:46:51,540
规则是你可以每个 term 投一票。

845
00:46:54,860 --> 00:46:57,680
所以当第一个跟随者投票给自己，

846
00:46:57,680 --> 00:46:59,000
它已经为自己投票了，

847
00:46:59,000 --> 00:47:00,500
当它收到第二个投票请求时，

848
00:47:00,500 --> 00:47:03,000
它不能投票给该请求，

849
00:47:03,000 --> 00:47:04,540
因为它已经投票给了自己，

850
00:47:05,080 --> 00:47:07,540
所以，在这一点上，我们会有分裂投票，

851
00:47:07,540 --> 00:47:09,130
这个有一票，

852
00:47:09,130 --> 00:47:10,630
而这个也有一票，

853
00:47:11,480 --> 00:47:13,460
它什么也做不了，

854
00:47:13,460 --> 00:47:15,440
但在随后的某个时刻，

855
00:47:15,680 --> 00:47:17,330
这里会有超时，

856
00:47:18,260 --> 00:47:20,510
然后这个过程又开始了，

857
00:47:21,440 --> 00:47:23,570
当然，作为这个过程的一部分，

858
00:47:23,570 --> 00:47:27,170
这是选举 11 ， 11 导致 12 ，

859
00:47:27,170 --> 00:47:29,300
如果你想到选举编号 12 ，

860
00:47:29,900 --> 00:47:32,480
然后再次尝试这样做，

861
00:47:33,590 --> 00:47:34,970
现在如果你不在意，

862
00:47:35,450 --> 00:47:38,570
这可能会一次又一次地发生，

863
00:47:39,110 --> 00:47:40,370
基本上每次，

864
00:47:40,370 --> 00:47:43,910
这两个跟随者大致同时开始这次选举，

865
00:47:43,910 --> 00:47:46,130
我们不会取得任何进展。

866
00:47:46,840 --> 00:47:48,430
所以，我们需要避免这个问题，

867
00:47:48,610 --> 00:47:52,300
就是选举超时是随机的，

868
00:48:08,340 --> 00:48:14,850
所以跟随者设置选举计时器时，

869
00:48:14,850 --> 00:48:17,580
在论文中，他们谈到，

870
00:48:17,700 --> 00:48:22,620
选择 150 毫秒到 300 毫秒之间的值，

871
00:48:23,440 --> 00:48:25,120
这个区间内的随机数，

872
00:48:25,720 --> 00:48:30,790
每次这些追随者重置它们的选举超时，

873
00:48:30,910 --> 00:48:33,760
它们选择了一个新的数字，间隔中的一个随机数，

874
00:48:33,880 --> 00:48:37,450
只有当计时器结束时，它们才会进行选举，

875
00:48:38,130 --> 00:48:40,770
而且，如果，

876
00:48:40,980 --> 00:48:42,900
如果这个间隔足够宽，

877
00:48:43,110 --> 00:48:44,580
这不太可能是，

878
00:48:44,580 --> 00:48:47,880
第一个跟随者得到，

879
00:48:48,300 --> 00:48:51,750
第一个跟随者的定时器超时，

880
00:48:52,770 --> 00:48:55,410
间隔足够宽，

881
00:48:55,410 --> 00:48:59,640
有机会成功完成选举，

882
00:48:59,700 --> 00:49:03,120
在第二个定时器走完之前，

883
00:49:03,270 --> 00:49:04,740
在另一个跟随者之前，

884
00:49:05,040 --> 00:49:08,310
所以这避免了无休止的分裂投票，

885
00:49:08,430 --> 00:49:09,690
我们可能不走运，

886
00:49:09,690 --> 00:49:11,580
我们可能会得到一两次分裂投票，

887
00:49:11,700 --> 00:49:14,040
但随着时间的推移，情况是这样的，

888
00:49:14,040 --> 00:49:16,650
我们最终会成功。

889
00:49:20,380 --> 00:49:21,370
有几种，

890
00:49:21,430 --> 00:49:23,410
这对实验 2 来说可能很重要，

891
00:49:23,590 --> 00:49:27,850
这些选举超时有几种[压力]，

892
00:49:32,840 --> 00:49:40,290
你不想让选举超时时间太短，

893
00:49:40,290 --> 00:49:41,460
因为如果它太短，

894
00:49:41,460 --> 00:49:44,820
例如，比心跳还短，

895
00:49:44,820 --> 00:49:46,560
你可能会丢失一条消息，

896
00:49:46,560 --> 00:49:48,540
直接开始选举，

897
00:49:49,080 --> 00:49:50,670
没有什么不好的事情发生，

898
00:49:50,700 --> 00:49:53,130
因为我们会选出一位新领导者，

899
00:49:53,130 --> 00:49:55,110
你会到一个新的 term 以及一些东西，

900
00:49:55,410 --> 00:49:58,530
但是，在这次选举中，

901
00:49:58,530 --> 00:50:00,960
这个系统是不可用的，

902
00:50:00,960 --> 00:50:02,280
客户端被阻塞了。

903
00:50:02,680 --> 00:50:07,690
所以你不想导致不必要地选举，

904
00:50:07,690 --> 00:50:08,890
所以你想做的一件事，

905
00:50:08,890 --> 00:50:13,570
选取一个值

906
00:50:13,570 --> 00:50:16,840
至少大于一些超时，一些心跳，

907
00:50:22,240 --> 00:50:23,740
也许在一个，

908
00:50:23,770 --> 00:50:28,060
也许一个数据中心需要几毫秒的时间来进行 RPC ，

909
00:50:28,270 --> 00:50:29,560
我们可能想要等待

910
00:50:29,560 --> 00:50:32,500
至少可能三四次 RPC 左右时间，

911
00:50:32,500 --> 00:50:36,190
以便我们有机会重试 RPC ，

912
00:50:36,400 --> 00:50:40,000
在选举定时器没有到达之前，

913
00:50:40,000 --> 00:50:42,460
这样我们可以从临时网络故障中恢复过来。

914
00:50:44,390 --> 00:50:50,360
那么我们大概想要增加一些随机的值，

915
00:50:50,840 --> 00:50:53,870
随机值，以避免分裂投票，

916
00:50:54,450 --> 00:50:58,260
所以一方面我们想让随机值尽可能大，

917
00:50:58,290 --> 00:50:59,490
因为我们把它做大，

918
00:50:59,490 --> 00:51:04,890
那么，我们遇到分裂投票问题的可能性很小。

919
00:51:05,740 --> 00:51:07,900
但另一方面，如果我们这么做了，

920
00:51:07,900 --> 00:51:11,560
那么系统可能会停机更长一段时间，

921
00:51:11,560 --> 00:51:14,440
我们可能会把选举超时时间定得很大，

922
00:51:14,680 --> 00:51:17,860
从客户的角度来看，这意味着停机时间，

923
00:51:18,400 --> 00:51:22,270
所以我们想要保持足够短的时间，

924
00:51:27,040 --> 00:51:28,300
停机时间很短，

925
00:51:36,030 --> 00:51:38,700
在[]选举的论文中，做了相当多的工作，

926
00:51:38,730 --> 00:51:41,580
来验证得到合理的值，

927
00:51:42,180 --> 00:51:43,140
对于他们的设置，

928
00:51:43,140 --> 00:51:46,260
这就是为什么他们得到 250 到 300 毫秒的时间，

929
00:51:46,650 --> 00:51:48,450
在实验里，我们使用更广泛的（时间），

930
00:51:48,450 --> 00:51:51,900
基本上，如果你在一秒钟内恢复，

931
00:51:51,960 --> 00:51:53,700
你都会做得很好，

932
00:51:54,320 --> 00:51:57,800
对于我们的测试用例。

933
00:52:02,520 --> 00:52:11,110
好的，我想再提一点关于选举的问题，

934
00:52:11,590 --> 00:52:15,760
所以，另一个需要考虑的重要场景是，

935
00:52:15,760 --> 00:52:16,990
我们有一个跟随者，

936
00:52:17,020 --> 00:52:19,240
我们有领导者，并且领导者停机，

937
00:52:19,540 --> 00:52:22,630
所以这是 10 ，这是 10 ，这是跟随者 10 。

938
00:52:25,150 --> 00:52:27,760
我们已经谈过了，

939
00:52:27,760 --> 00:52:31,870
比如这个（跟随者）先开始，为自己投票，

940
00:52:33,200 --> 00:52:39,080
协议记录在稳定的存储上，

941
00:52:39,260 --> 00:52:41,030
我们投票给了谁，

942
00:52:41,850 --> 00:52:47,400
所以记录在跟随者 1 ， 跟随者 2 ，

943
00:52:47,400 --> 00:52:52,740
对于跟随者 1 ，记录选举在 term 11 ，

944
00:52:55,070 --> 00:52:57,590
为什么它记录在稳定的存储器上，

945
00:52:59,180 --> 00:53:03,310
为什么跟随者需要记住这一点，

946
00:53:05,670 --> 00:53:07,740
这是在 term 11 投票给自己的。

947
00:53:14,040 --> 00:53:17,580
如果失败，这种方式不会投票两次。

948
00:53:18,380 --> 00:53:25,950
是的，它可能会崩溃，在这里，然后回来，

949
00:53:25,950 --> 00:53:28,920
它应该记住这一点，有些事情可能，

950
00:53:28,920 --> 00:53:33,570
我们假设这里有第三个，跟随者 3 ，

951
00:53:33,840 --> 00:53:36,360
并且已经投票给了跟随者 3 ，

952
00:53:36,630 --> 00:53:41,260
那么它其实是不会变的，

953
00:53:41,770 --> 00:53:44,560
因为在 term 的最后，

954
00:53:44,560 --> 00:53:47,080
我们需要一个[位置]，

955
00:53:47,290 --> 00:53:50,920
每个 term 只有一个领导者，永远不会有两个，

956
00:53:51,730 --> 00:53:56,710
所以，为了确保每个跟随者都必须记住

957
00:53:56,710 --> 00:53:59,470
投票给了哪位候选人，并且永远不会改变主意。

958
00:54:07,920 --> 00:54:13,200
好吧，我想聊天中所有关于超时时间的讨论，

959
00:54:13,650 --> 00:54:15,030
都和实验有关，

960
00:54:15,210 --> 00:54:18,840
所以人们看到，对此感到困惑，

961
00:54:18,840 --> 00:54:22,680
否则我们可以更多地谈论选举，

962
00:54:22,680 --> 00:54:25,920
因为这是我说的最后的关于选举的事情。

963
00:54:28,320 --> 00:54:29,910
对于选举，有什么问题吗？

964
00:54:36,780 --> 00:54:39,210
有一个更一般的问题，

965
00:54:39,240 --> 00:54:42,120
所以，在实验的图 2 中，

966
00:54:42,120 --> 00:54:45,730
它说，对于每个服务器，

967
00:54:45,730 --> 00:54:48,790
保存当前的 term 和投票给谁，

968
00:54:49,630 --> 00:54:52,630
但不是服务器现在的状态，

969
00:54:52,630 --> 00:54:56,830
比如它是候选者或跟随者或领导者。

970
00:54:57,630 --> 00:54:59,640
所以我想知道，

971
00:55:00,250 --> 00:55:01,120
这是隐含的，

972
00:55:01,120 --> 00:55:03,040
还是有其他方法来解决这个问题？

973
00:55:03,430 --> 00:55:06,250
我想当你回来的时候，

974
00:55:06,280 --> 00:55:07,900
你以跟随者的身份回来，

975
00:55:09,100 --> 00:55:10,930
你要开始一场选举，

976
00:55:12,620 --> 00:55:15,920
然后，在选举结束时，

977
00:55:15,920 --> 00:55:16,790
你知道你是什么，

978
00:55:18,300 --> 00:55:20,340
你要么是跟随者，要么是领导者。

979
00:55:24,090 --> 00:55:25,410
我明白了，好的，谢谢你。

980
00:55:25,650 --> 00:55:26,280
这能理解吗?

981
00:55:27,180 --> 00:55:31,470
关于图 2 的一个警告，

982
00:55:31,500 --> 00:55:33,900
大多是积极的，可能会有负面的[说法]。

983
00:55:35,620 --> 00:55:36,580
在图 2 中的任何地方，

984
00:55:36,580 --> 00:55:38,860
当它说你应该这样做时，

985
00:55:39,190 --> 00:55:40,240
你真的应该这么做，

986
00:55:40,420 --> 00:55:43,960
所以你不能[]图 2 中的任何细节，

987
00:55:43,960 --> 00:55:44,980
如果你这么做了，

988
00:55:44,980 --> 00:55:47,380
那么毫无疑问，一些测试用例会失败，

989
00:55:47,950 --> 00:55:50,350
不幸的是，图 2 并不完整，

990
00:55:50,820 --> 00:55:52,980
所以你还是得做点什么，

991
00:55:53,400 --> 00:55:56,190
尤其是图 2 并没有很好地说明，

992
00:55:56,190 --> 00:55:57,630
如何处理回复，

993
00:55:57,870 --> 00:56:00,300
投票 RPC 和追加 RPC ，

994
00:56:00,300 --> 00:56:04,680
所以，你必须做一些事情来填补缺失的细节，

995
00:56:05,010 --> 00:56:09,360
所以，在图 2 中有两点，

996
00:56:10,000 --> 00:56:12,130
你最好处理好它里面的任何东西，

997
00:56:12,520 --> 00:56:14,590
但仍有可能会遗漏一些东西，

998
00:56:14,590 --> 00:56:16,480
你必须自己解决，

999
00:56:20,450 --> 00:56:23,480
你会经常看图 2 。

1000
00:56:26,240 --> 00:56:28,730
从选举过程的描述来看，

1001
00:56:28,730 --> 00:56:29,690
看起来是这样，

1002
00:56:29,690 --> 00:56:32,930
即使对于实验 2a ，仅处理选举，

1003
00:56:32,930 --> 00:56:36,020
好像也有一些状态需要我们持久化存储，

1004
00:56:36,890 --> 00:56:40,700
例如，你投票给谁和 term 编号。

1005
00:56:40,880 --> 00:56:41,270
是的。

1006
00:56:41,480 --> 00:56:43,910
但是，当你查看实验 2 的代码，

1007
00:56:43,970 --> 00:56:46,910
所有与持久化保存状态有关的代码，

1008
00:56:46,910 --> 00:56:48,650
上面写着实验 2c ，

1009
00:56:48,980 --> 00:56:51,770
那么它是不是并不那么关键，

1010
00:56:51,770 --> 00:56:53,960
也许关心持久存储，

1011
00:56:53,960 --> 00:56:56,870
或者我们应该开始[]。

1012
00:56:57,080 --> 00:57:00,140
是的，我想在前几次测试中，

1013
00:57:00,140 --> 00:57:01,610
我们并没有使机器崩溃，

1014
00:57:02,570 --> 00:57:04,400
所以，这并不重要，

1015
00:57:04,490 --> 00:57:07,040
在实验 2c 中，有机器崩溃。

1016
00:57:08,120 --> 00:57:09,170
好的，太棒了，谢谢。

1017
00:57:13,440 --> 00:57:19,350
好的，怎么样，大家都跟的上吗？

1018
00:57:25,260 --> 00:57:27,210
好的，我们开始下一步。

1019
00:57:28,000 --> 00:57:32,370
好的，有一件重要的事要注意，

1020
00:57:32,370 --> 00:57:34,050
在在前面的问题中也提到了，

1021
00:57:34,050 --> 00:57:36,180
当我说到到那个困难的主题，

1022
00:57:36,390 --> 00:57:39,030
就是日志可能分叉。

1023
00:57:48,080 --> 00:57:50,210
它们可能非常[戏剧性]，

1024
00:57:50,210 --> 00:57:53,900
但是我们先初步了解，

1025
00:57:54,140 --> 00:57:57,830
然后更详细地讨论。

1026
00:57:57,830 --> 00:57:59,750
让我们举几个简单的例子，

1027
00:57:59,930 --> 00:58:03,140
所以我写一些东西，并使用下面的符号，

1028
00:58:03,140 --> 00:58:06,890
我们像以前一样有三台服务器，

1029
00:58:07,070 --> 00:58:09,350
但我要删掉所有时间线的东西，

1030
00:58:09,500 --> 00:58:11,390
只是画出日志。

1031
00:58:15,600 --> 00:58:19,700
我们有索引，

1032
00:58:19,820 --> 00:58:21,380
我们假设这些索引，

1033
00:58:21,380 --> 00:58:23,420
这里有前面的部分，

1034
00:58:23,420 --> 00:58:25,670
当我们谈论 10 11 12 的时候，

1035
00:58:27,460 --> 00:58:31,420
在每一个中有一个 term 条目，

1036
00:58:31,630 --> 00:58:33,580
我们假设所有三个服务器

1037
00:58:33,910 --> 00:58:39,850
在 term 3 中提交或追加操作到索引 10 ，

1038
00:58:41,710 --> 00:58:50,470
同样的事情也发生在索引 11 中。

1039
00:58:50,470 --> 00:58:51,280
所以，一种考虑方式，

1040
00:58:51,280 --> 00:58:52,690
一种可以得到这个的方式，

1041
00:58:52,690 --> 00:58:54,370
服务器 1 是领导者，

1042
00:58:54,490 --> 00:58:56,680
服务器 1 附加到自己的日志，

1043
00:58:56,680 --> 00:58:59,140
然后复制到 S2 和 S3 ，

1044
00:58:59,380 --> 00:59:01,150
同样的事情也发生在索引 11 上，

1045
00:59:01,210 --> 00:59:04,180
然后接下来的 12 可能也成功的，

1046
00:59:04,180 --> 00:59:08,620
追加一个操作到它的 term 的那个索引，

1047
00:59:08,620 --> 00:59:09,820
这是 term 3 ，

1048
00:59:09,850 --> 00:59:10,870
然后它崩溃了。

1049
00:59:11,980 --> 00:59:13,570
好的，现在我们遇到这样情况，

1050
00:59:13,570 --> 00:59:19,870
其中一台服务器的日志中有一个额外的日志条目，

1051
00:59:19,870 --> 00:59:21,370
而其他的没有，

1052
00:59:21,400 --> 00:59:23,170
或者可能其中一个有两个，

1053
00:59:23,170 --> 00:59:25,480
但肯定不是完全相同的。

1054
00:59:26,520 --> 00:59:28,020
但这是一个简单的情况，

1055
00:59:28,020 --> 00:59:30,150
不仅是我们正在进行的步骤，

1056
00:59:30,300 --> 00:59:32,610
还有更多有趣的情况。

1057
00:59:32,610 --> 00:59:34,920
所以，另一种情况可能是

1058
00:59:36,000 --> 00:59:39,030
一台服务器，同样是 S1 ，

1059
00:59:39,030 --> 00:59:41,820
相同的场景 S2 和 S3 ，

1060
00:59:42,820 --> 00:59:46,690
假设我们有以下日志，

1061
00:59:54,550 --> 00:59:59,400
这是我们在索引 10 中的情况，

1062
00:59:59,960 --> 01:00:03,560
我们有 term 3 的条目和所有服务器，

1063
01:00:03,800 --> 01:00:07,130
索引 11 ，第一个服务器没有条目，

1064
01:00:07,400 --> 01:00:10,850
另外两个有一个 term 3 的条目，

1065
01:00:11,030 --> 01:00:14,030
然后最后一个编号 12 ，

1066
01:00:14,060 --> 01:00:19,450
我们有条目索引 4 在 2 3 服务器上，

1067
01:00:19,570 --> 01:00:21,250
并且使用 term 编号 4 和 5 。

1068
01:00:22,020 --> 01:00:23,760
所以，我们需要问自己的第一个问题是，

1069
01:00:23,760 --> 01:00:24,630
这可能吗，

1070
01:00:26,330 --> 01:00:30,530
raft 会以这种方式生产日志吗，

1071
01:00:31,010 --> 01:00:33,920
在相同的日志条目中，

1072
01:00:34,010 --> 01:00:37,580
我们有两个不同的 term 编号和相同的日志索引。

1073
01:00:37,610 --> 01:00:39,080
是的，这是可能的。

1074
01:00:41,140 --> 01:00:45,700
所以，它看起来像。

1075
01:00:45,700 --> 01:00:47,020
它像什么场景产生的？

1076
01:00:47,020 --> 01:00:48,730
是的，这看起来像，

1077
01:00:48,730 --> 01:00:54,730
服务器 2 或服务器 3 是 term 3 的领导者，

1078
01:00:54,730 --> 01:00:59,050
然后把一些日志放到服务器 1 上，

1079
01:00:59,050 --> 01:01:04,760
然后与两个服务器中的一个共享另一个日志，

1080
01:01:04,790 --> 01:01:07,550
在这一点之后，它停机了，

1081
01:01:08,220 --> 01:01:12,990
然后 S2 当选为 term 2 的领导者，

1082
01:01:12,990 --> 01:01:14,040
这仍然是可能的，

1083
01:01:14,040 --> 01:01:18,330
因为它的日志是最新的，和其他人一样最新，

1084
01:01:18,570 --> 01:01:20,070
然后。

1085
01:01:20,070 --> 01:01:21,150
再次确认一下，

1086
01:01:21,150 --> 01:01:24,350
S2 当选在 term 4 。

1087
01:01:24,560 --> 01:01:25,340
是的。

1088
01:01:25,340 --> 01:01:26,660
好的，不是 term 2 。

1089
01:01:27,540 --> 01:01:29,610
好的，那么 S2 在 term 4 当选，

1090
01:01:29,670 --> 01:01:32,820
并使用 S1 作为备份，

1091
01:01:32,820 --> 01:01:34,230
以追随者的身份？

1092
01:01:35,900 --> 01:01:39,440
是的，我想，

1093
01:01:39,440 --> 01:01:41,630
然后 S3 在 term 5 当选，

1094
01:01:41,630 --> 01:01:44,240
在 S2 可以将任何东西放入日志之前。

1095
01:01:44,330 --> 01:01:45,290
是的，换一种说法就是，

1096
01:01:45,290 --> 01:01:47,330
S2 可能崩溃，

1097
01:01:47,360 --> 01:01:50,330
正好在 term 4 当选之后，

1098
01:01:50,690 --> 01:01:53,180
然后有一个超时，

1099
01:01:53,180 --> 01:01:56,330
然后假设 S3 分区，但现在又回来了，

1100
01:01:56,720 --> 01:01:59,600
在这一点上，它将成为，

1101
01:01:59,630 --> 01:02:03,170
它会进入 term 5 ，是吗。

1102
01:02:04,350 --> 01:02:05,040
是的。

1103
01:02:06,460 --> 01:02:07,900
好的，所以这是可能的，

1104
01:02:08,080 --> 01:02:11,860
所以可能会有相当多的[]变种，

1105
01:02:11,860 --> 01:02:13,750
所以我们来看一下，

1106
01:02:16,180 --> 01:02:20,440
所以这是家庭作业中的表 6 或表 7 ，

1107
01:02:20,860 --> 01:02:24,290
糟糕，

1108
01:02:27,580 --> 01:02:32,920
家庭作业问一些关于表格的基本问题，

1109
01:02:32,920 --> 01:02:37,480
比如图 6  或图 7 中的这个会发生什么，

1110
01:02:37,660 --> 01:02:39,370
我认为是图 7 ，

1111
01:02:39,700 --> 01:02:43,300
正在讨论的场景，

1112
01:02:43,300 --> 01:02:46,030
比如最上面的这个成为新的领导者，

1113
01:02:46,300 --> 01:02:47,950
在作业中，我们问这个问题，

1114
01:02:48,070 --> 01:02:51,610
如果这个领导者停机了会怎样，

1115
01:02:52,060 --> 01:02:54,430
可能的结果是什么，

1116
01:02:54,820 --> 01:02:56,170
可能的结果，

1117
01:02:56,170 --> 01:03:01,150
对每个日志索引，问题是，

1118
01:03:01,180 --> 01:03:02,560
哪个会拒绝，

1119
01:03:06,210 --> 01:03:08,580
哪个肯定会被接受，

1120
01:03:11,170 --> 01:03:13,270
哪个要看情况而定。

1121
01:03:16,280 --> 01:03:18,620
我认为有一件重要的事情要做，

1122
01:03:18,620 --> 01:03:20,570
因为我们必须了解什么，

1123
01:03:20,570 --> 01:03:22,970
所有可能的日志条目，可能的输出是什么，

1124
01:03:22,970 --> 01:03:25,430
它会更加稳固我们的理解，

1125
01:03:25,430 --> 01:03:27,860
关于 raft 是如何运作的，

1126
01:03:28,620 --> 01:03:31,050
我想做的是一个快速分解会议室，

1127
01:03:31,380 --> 01:03:37,970
我想让你们找出两种可能的结果，

1128
01:03:38,000 --> 01:03:39,470
这并不能保证，

1129
01:03:40,280 --> 01:03:44,000
在相应的场景中，

1130
01:03:44,150 --> 01:03:49,250
所以，让我们进行一个简短的分解会议室，

1131
01:03:49,250 --> 01:03:54,110
让我们试着在 5 分钟内找出家庭作业问题的答案。

1132
01:04:00,930 --> 01:04:02,430
Lily ，你能做。

1133
01:04:02,490 --> 01:04:03,780
你想让我这么做。

1134
01:04:03,960 --> 01:04:05,550
是的。

1135
01:04:05,550 --> 01:04:19,800
是的，让我让你来主持，

1136
01:04:19,950 --> 01:04:20,850
现在你是主持人。

1137
01:11:58,250 --> 01:11:59,090
嘿，各位。

1138
01:12:10,150 --> 01:12:12,700
好了，大家能听到我说话吗？

1139
01:12:15,460 --> 01:12:17,260
我能得到一个确定的信号？

1140
01:12:17,980 --> 01:12:18,490
是的。

1141
01:12:18,700 --> 01:12:19,630
好的，

1142
01:12:20,080 --> 01:12:25,960
好的，希望大家都能好好讨论这个，

1143
01:12:26,950 --> 01:12:30,730
这是一个关于日志发散的讨论，

1144
01:12:31,750 --> 01:12:33,970
我们在这里看到这个表格，

1145
01:12:33,970 --> 01:12:36,040
有一些很[]的变量，

1146
01:12:36,550 --> 01:12:39,130
对于可能发生的事情，

1147
01:12:39,550 --> 01:12:41,170
这些都是可能的，

1148
01:12:41,230 --> 01:12:43,540
如图中的标题所解释的，

1149
01:12:43,540 --> 01:12:47,050
它们都是可能的情景，

1150
01:12:48,340 --> 01:12:50,890
所以作业中的问题，

1151
01:12:50,890 --> 01:12:52,030
快速回顾一下，

1152
01:12:52,030 --> 01:12:53,710
我相信你们大多数人已经。

1153
01:12:54,160 --> 01:12:55,510
我想我们看不到你的屏幕。

1154
01:12:55,900 --> 01:12:57,610
哦，那太糟糕了，

1155
01:12:58,000 --> 01:13:01,090
那是因为我忘了点击分享，

1156
01:13:01,540 --> 01:13:04,240
好的，让我来修复它，

1157
01:13:04,760 --> 01:13:05,540
对此我很感激。

1158
01:13:14,680 --> 01:13:17,080
好的，你在屏幕上看到了吗？

1159
01:13:18,980 --> 01:13:19,370
是的。

1160
01:13:19,400 --> 01:13:21,350
好的，谢谢，抱歉，

1161
01:13:21,350 --> 01:13:26,330
好的，回到图 7 的标题，

1162
01:13:26,330 --> 01:13:29,120
图 7 解释了所有可能的情况，

1163
01:13:29,600 --> 01:13:31,460
我们想弄清楚的是，

1164
01:13:31,460 --> 01:13:34,640
在讨论日志如何修复的细节之前，

1165
01:13:35,000 --> 01:13:37,160
什么是可能的，

1166
01:13:37,160 --> 01:13:42,460
这个最高的这个（节点）没有当选为领导者，

1167
01:13:42,460 --> 01:13:45,910
这幅图的标题，

1168
01:13:45,910 --> 01:13:48,250
有什么结果是可能的，

1169
01:13:48,250 --> 01:13:49,480
它们将会是，

1170
01:13:49,480 --> 01:13:50,710
我的意思是，

1171
01:13:50,710 --> 01:13:52,750
比如，我们查看 f ，

1172
01:13:52,840 --> 01:13:58,330
它有一个条目来自 term 2 在索引 4 ，

1173
01:13:59,230 --> 01:14:01,810
我们想要问和理解的问题是，

1174
01:14:02,110 --> 01:14:03,760
显然这是可能的，

1175
01:14:03,760 --> 01:14:05,110
因为这是可能发生的，

1176
01:14:05,200 --> 01:14:06,580
接下来会发生什么，

1177
01:14:07,060 --> 01:14:09,880
这个条目有没有可能保留下来，

1178
01:14:10,890 --> 01:14:13,110
所以我们重新配置领导者，

1179
01:14:13,110 --> 01:14:17,310
日志[同步地]放在一起，

1180
01:14:17,310 --> 01:14:20,550
领导者强制日志是相同的，

1181
01:14:20,700 --> 01:14:21,630
有没有一种情况，

1182
01:14:21,630 --> 01:14:26,100
来自 term 2 的条目继续存在。

1183
01:14:29,880 --> 01:14:30,600
没有。

1184
01:14:31,130 --> 01:14:32,060
没有，正确，

1185
01:14:32,060 --> 01:14:34,040
这个肯定会被拒绝，

1186
01:14:34,370 --> 01:14:35,480
为什么会这样呢？

1187
01:14:36,740 --> 01:14:40,850
来自 term 6 的条目已经被提交，

1188
01:14:41,550 --> 01:14:44,490
所以 f 永远不会当选。

1189
01:14:45,000 --> 01:14:46,350
是的， f 永远不会当选，

1190
01:14:46,350 --> 01:14:47,970
所以其他人将会当选，

1191
01:14:47,970 --> 01:14:51,000
没有人有来自 term 2 在索引 4 （的条目），

1192
01:14:51,030 --> 01:14:52,290
所以，它会被覆盖，

1193
01:14:52,440 --> 01:14:54,180
什么值会被覆盖？

1194
01:14:58,360 --> 01:15:01,240
一个 4 会被覆盖。

1195
01:15:01,780 --> 01:15:03,520
这会变成 4 ，

1196
01:15:03,700 --> 01:15:06,520
所以，当我们稍后谈到日志时，

1197
01:15:06,520 --> 01:15:09,850
同步迫使跟随者记下日志，

1198
01:15:09,970 --> 01:15:10,960
必须是这样的，

1199
01:15:10,960 --> 01:15:13,270
在 f 上，这里的 2 变成 4 。

1200
01:15:14,190 --> 01:15:18,130
好的，所以，这也回答了第二个问题，

1201
01:15:18,130 --> 01:15:25,150
来自 term 4 的条目肯定会被接受。

1202
01:15:26,910 --> 01:15:32,730
好的，也许更有趣的是关于依赖的讨论，

1203
01:15:33,790 --> 01:15:37,660
我们知道至少有一个 term 肯定会拒绝它，

1204
01:15:37,660 --> 01:15:39,640
我们知道有一个 term 肯定会接受它，

1205
01:15:39,970 --> 01:15:45,700
这里有没有任何可能被接受的 term 和索引？

1206
01:15:47,570 --> 01:15:49,190
哦， 7 是可能的。

1207
01:15:50,060 --> 01:15:51,080
是的， 7 。

1208
01:15:52,180 --> 01:15:54,640
那么，这个 7 什么时候不会被接受呢？

1209
01:15:55,240 --> 01:15:56,650
好的，那么简单的场景，

1210
01:15:56,650 --> 01:15:58,090
7 将被接受，

1211
01:15:58,090 --> 01:15:59,710
因为 d 当选为领导者，

1212
01:15:59,920 --> 01:16:02,890
然后它会强制它的日志到其他所有人，

1213
01:16:03,420 --> 01:16:05,190
所以这是 7 被接受的情况，

1214
01:16:05,190 --> 01:16:07,200
什么时候 7 会被拒绝？

1215
01:16:08,620 --> 01:16:12,580
如果 c 当选领导者，然后 d 停机，

1216
01:16:13,300 --> 01:16:14,500
它会被覆盖。

1217
01:16:14,890 --> 01:16:18,400
是的，所以 d 停机， c 成为领导者，

1218
01:16:18,910 --> 01:16:22,900
然后 c 的日志条目被推送到其他所有的条目上，

1219
01:16:23,020 --> 01:16:24,880
然后，无论 d ，

1220
01:16:24,970 --> 01:16:27,640
所以我们会是 term 7 ，

1221
01:16:27,640 --> 01:16:29,050
在某一时刻，它将变得更长，

1222
01:16:29,140 --> 01:16:30,520
当 d 恢复时，

1223
01:16:30,760 --> 01:16:33,580
它的条目将被覆盖。

1224
01:16:34,730 --> 01:16:35,840
是一种可能。

1225
01:16:36,320 --> 01:16:39,410
所以， 7 是绝对有可能的，但不能保证，

1226
01:16:40,220 --> 01:16:41,810
还有其他情况吗？

1227
01:16:41,810 --> 01:16:45,230
我有一个问题， a 也可以成为领导者，对吧？

1228
01:16:47,490 --> 01:16:48,030
a 吗？

1229
01:16:48,740 --> 01:16:49,520
是的。

1230
01:16:49,980 --> 01:16:53,100
是的，如果 c 和 d 都停机， a 可能成为领导者。

1231
01:16:55,280 --> 01:16:58,670
d 甚至不需要停机，让 a 选为领导者，

1232
01:16:59,150 --> 01:17:00,860
它只会[]。

1233
01:17:00,860 --> 01:17:01,580
第一个。

1234
01:17:02,870 --> 01:17:05,000
最长日志，

1235
01:17:05,000 --> 01:17:07,670
如果两个 term 最终相等，

1236
01:17:07,670 --> 01:17:08,930
那么选择最长的日志。

1237
01:17:09,800 --> 01:17:13,640
但是，我认为，

1238
01:17:13,640 --> 01:17:17,390
如果 a 是第一个发起选举的，

1239
01:17:17,750 --> 01:17:19,790
可能成为。

1240
01:17:20,490 --> 01:17:25,200
是的，如果 c 和 d 停机， a 可能赢得选举。

1241
01:17:25,930 --> 01:17:29,320
但如果它们还活着，它还能赢得选举吗？

1242
01:17:30,320 --> 01:17:32,940
啊，那么比如 c ，

1243
01:17:32,940 --> 01:17:33,960
好的，假设 d 停机，

1244
01:17:33,960 --> 01:17:35,160
我们一定会这么做，

1245
01:17:35,160 --> 01:17:37,290
因为我们知道 d 会赢得选举，

1246
01:17:38,120 --> 01:17:38,660
d 完成。

1247
01:17:39,340 --> 01:17:40,420
它必须这样吗，

1248
01:17:40,450 --> 01:17:42,220
比如我们知道，

1249
01:17:42,220 --> 01:17:45,760
它肯定不会得到 d 的投票，

1250
01:17:46,870 --> 01:17:50,840
但是，它必须赢得什么。

1251
01:17:51,540 --> 01:17:52,350
怎么了，你觉得呢？

1252
01:17:54,820 --> 01:17:59,500
如果 a 先得到 b e 和 f 的投票，

1253
01:17:59,500 --> 01:18:01,930
然后收到来自（d 的投票）。

1254
01:18:04,840 --> 01:18:08,410
是的，你可以在没有 d 参与的情况下获得多数选票。

1255
01:18:18,800 --> 01:18:20,630
即使 d 参加了选举，

1256
01:18:20,630 --> 01:18:23,690
a 也可以获得多数选票，对吧。

1257
01:18:28,840 --> 01:18:30,790
是的，我想我们已经回答了这个问题。

1258
01:18:34,780 --> 01:18:37,540
难道不是有一种机制吗，

1259
01:18:38,460 --> 01:18:42,080
如果候选者看到一条消息，

1260
01:18:42,080 --> 01:18:45,830
来自更高 term 编号的已经停机的其他服务器。

1261
01:18:48,090 --> 01:18:51,660
从一个更高的 term 编号， a 有，

1262
01:18:51,870 --> 01:18:53,100
如果 d 已经停机。

1263
01:18:56,910 --> 01:18:58,350
它不一定要停机，对吧，

1264
01:18:58,350 --> 01:19:00,600
我们只要先拿到它们。

1265
01:19:00,600 --> 01:19:02,570
是的，没错。

1266
01:19:06,160 --> 01:19:09,970
但是它将在投票给 d 时下台。

1267
01:19:10,880 --> 01:19:12,740
等等，你确定吗，

1268
01:19:12,740 --> 01:19:15,770
因为我不这么认为。

1269
01:19:16,450 --> 01:19:18,490
好的，如果 d 在某个时候，

1270
01:19:18,490 --> 01:19:22,000
这要看情况了，它们要开始竞争了，

1271
01:19:22,330 --> 01:19:27,310
好的，让我问一个非常重要的话题，

1272
01:19:27,310 --> 01:19:29,140
所以我不想在十秒钟内完成，

1273
01:19:30,040 --> 01:19:31,540
让我回到这个问题上来，

1274
01:19:31,540 --> 01:19:32,980
在下一节课开始时，

1275
01:19:33,130 --> 01:19:35,020
好的，这是一个很好的停止点。

1276
01:19:39,320 --> 01:19:42,170
我认为图 4 中的状态机澄清了它，

1277
01:19:42,350 --> 01:19:44,360
比如候选者回到了跟随者，

1278
01:19:44,360 --> 01:19:46,520
如果发现了更高的 term ，

1279
01:19:46,520 --> 01:19:48,440
所以，如果 d 没有停机，

1280
01:19:48,830 --> 01:19:50,750
它将立即返回到跟随者，

1281
01:19:50,780 --> 01:19:51,920
试图开始选举。

1282
01:19:53,350 --> 01:19:57,520
等等，但我以为它只会回到跟随者的状态，

1283
01:19:57,850 --> 01:20:01,840
如果它接收到来自当前领导者的追加条目，

1284
01:20:02,700 --> 01:20:05,850
比如一个请求投票，是不一样的。

1285
01:20:06,830 --> 01:20:09,050
所以它是值得的，

1286
01:20:09,050 --> 01:20:15,620
服务器所在的 term 编号和日志中最近条目的 term 是不同的，

1287
01:20:15,830 --> 01:20:17,030
哦，是的。

1288
01:20:17,810 --> 01:20:23,330
比如服务器 a ，它具有最近的日志条目为 term 6 ，

1289
01:20:23,360 --> 01:20:26,630
但是它当前的 term 编号是 7 。

1290
01:20:26,840 --> 01:20:29,810
目前的 term 可以任意得高。

1291
01:20:30,110 --> 01:20:30,500
是的。

1292
01:20:30,530 --> 01:20:32,030
正确，

1293
01:20:32,060 --> 01:20:35,210
所以 a 可以从 term 8 开始，

1294
01:20:35,600 --> 01:20:37,880
然后在 term 8 中当选，

1295
01:20:38,330 --> 01:20:42,320
不管告诉我们什么，都无关紧要，

1296
01:20:42,320 --> 01:20:44,930
因为如果最新的 term 是 7 ，

1297
01:20:45,260 --> 01:20:46,970
它不会成为跟随者，

1298
01:20:46,970 --> 01:20:48,980
因为它是一个比 7 更高的 term 。

1299
01:20:49,500 --> 01:20:53,010
我明白了，所以它可以是一个任意更高的 term 。

1300
01:20:53,880 --> 01:20:59,370
等等， a 能不能进入 term 7 ，

1301
01:21:00,420 --> 01:21:01,740
它自己的 term 7 ，

1302
01:21:01,770 --> 01:21:04,340
如果 d 出现分区，

1303
01:21:04,340 --> 01:21:06,440
比如这里有一个网络分区，

1304
01:21:06,440 --> 01:21:08,240
而它不知道 d 。

1305
01:21:09,060 --> 01:21:10,530
我认为很困惑，

1306
01:21:10,530 --> 01:21:12,330
比如即使它知道 d ，

1307
01:21:12,330 --> 01:21:14,820
这有什么关系，不应该有什么关系。

1308
01:21:19,070 --> 01:21:21,950
如果 a 将自己提升为候选者，

1309
01:21:21,950 --> 01:21:28,730
然后发出一个投票请求，

1310
01:21:29,280 --> 01:21:32,310
然后， d 可以回来说，

1311
01:21:32,340 --> 01:21:37,890
哦，我最新的日志条目是 term 7 的这个索引，

1312
01:21:38,340 --> 01:21:41,540
但是我不认为 a ，

1313
01:21:41,570 --> 01:21:44,590
等等，它甚至看不到这个，对吧，

1314
01:21:44,590 --> 01:21:47,350
在它们对 RPC 请求的响应中，

1315
01:21:47,680 --> 01:21:53,620
说它现在的 term 是 7 ，与 a 的匹配，

1316
01:21:54,040 --> 01:21:56,830
因为那这就是我们的假设。

1317
01:21:57,250 --> 01:22:00,850
是的， a 在 term 7 开始选举，

1318
01:22:04,370 --> 01:22:06,440
d 不会投票给 a 。

1319
01:22:06,740 --> 01:22:07,880
是的，这是对的，

1320
01:22:08,400 --> 01:22:09,360
但我不知道，

1321
01:22:09,570 --> 01:22:11,550
我觉得这完全没问题，

1322
01:22:11,550 --> 01:22:12,630
如果 d 是存活的，

1323
01:22:12,630 --> 01:22:17,430
并且给 a 的投票请求响应，

1324
01:22:17,850 --> 01:22:20,820
我不认为这会阻止 a 成为候选人。

1325
01:22:22,120 --> 01:22:24,070
有人在聊天中说了，

1326
01:22:24,070 --> 01:22:25,270
我认为答案是，

1327
01:22:25,300 --> 01:22:26,800
所以我同意这么说，

1328
01:22:26,950 --> 01:22:29,320
一旦 d 拒绝投票，

1329
01:22:29,650 --> 01:22:32,800
a 会变为跟随者，

1330
01:22:32,800 --> 01:22:35,740
因为它会意识到它有一个较低的 term 编号。

1331
01:22:35,770 --> 01:22:36,760
但是，好的。

1332
01:22:37,090 --> 01:22:38,290
不一定，

1333
01:22:38,320 --> 01:22:42,280
因为记住它们日志上的最近的 term

1334
01:22:42,280 --> 01:22:47,360
与服务器记录的最近 term 不是同一件事，

1335
01:22:47,990 --> 01:22:52,010
你可以拥有比日志中最近的 term 更高的当前 term ，

1336
01:22:52,430 --> 01:22:56,240
所以，如果 a 试图在 term 7 中选举自己，

1337
01:22:56,270 --> 01:22:59,090
是的，当它试图联系 d 时，

1338
01:22:59,480 --> 01:23:00,500
它会放弃，

1339
01:23:00,560 --> 01:23:02,750
但是如果 a 试图在 term 8 选举自己，

1340
01:23:02,780 --> 01:23:06,620
如果它看到 d 已经到达 term 7 ，

1341
01:23:08,110 --> 01:23:10,030
那么 a 可以当选。

1342
01:23:10,570 --> 01:23:12,670
等等，但是如果 d ，

1343
01:23:12,670 --> 01:23:15,100
如果我们假设 d 在 term 7 ，

1344
01:23:15,460 --> 01:23:19,780
例如，如果 a 试图在 term 7 选举自己，

1345
01:23:20,110 --> 01:23:23,180
那么我们没有这种情况，

1346
01:23:23,180 --> 01:23:26,660
因为如果 RPC 请求响应包含一个 term ，

1347
01:23:26,660 --> 01:23:29,030
大于你给它的当前的 term ，

1348
01:23:29,030 --> 01:23:30,110
如果它们是一样的，

1349
01:23:30,290 --> 01:23:31,400
那就不重要了，

1350
01:23:31,400 --> 01:23:33,020
一切照常进行。

1351
01:23:34,170 --> 01:23:34,860
对的。

1352
01:23:34,860 --> 01:23:35,340
是的。

1353
01:23:35,640 --> 01:23:38,760
d 的条目会被 a 告诉它的所取代。

1354
01:23:40,100 --> 01:23:43,190
所以，在这一节的末尾，

1355
01:23:43,220 --> 01:23:47,150
比如选举限制条款 5.4.1 ，

1356
01:23:47,450 --> 01:23:51,110
如果 raft 决定哪个日志是最新的，

1357
01:23:51,110 --> 01:23:54,350
通过对比日志中最后条目的索引，

1358
01:23:54,800 --> 01:24:00,080
这不是意味着 d 必须成为领导者，

1359
01:24:00,080 --> 01:24:01,430
如果我们比较。

1360
01:24:01,760 --> 01:24:04,220
不，因为 d 会投反对票，

1361
01:24:04,670 --> 01:24:06,350
但其他人可能会投赞成票。

1362
01:24:09,380 --> 01:24:10,280
好的。

1363
01:24:11,680 --> 01:24:12,190
所以。

1364
01:24:12,220 --> 01:24:23,390
如果 e 在 term 5 选举，

1365
01:24:23,480 --> 01:24:26,900
然后 d 投了反对票，

1366
01:24:26,900 --> 01:24:29,600
它会更新 term 并停止运行。

1367
01:24:30,530 --> 01:24:34,370
等一下，你在考虑 e 在 term 5 开始选举。

1368
01:24:34,400 --> 01:24:39,230
是的，如果它得到了几乎所有人的回应，

1369
01:24:39,230 --> 01:24:41,480
它会发现它落后一个 term ，对吧，

1370
01:24:41,480 --> 01:24:44,180
所以，在这种情况下，它更新了它的 term ，对吧，

1371
01:24:44,180 --> 01:24:44,570
追加。

1372
01:24:44,570 --> 01:24:47,090
这个问题的另一种提问方式是，

1373
01:24:47,090 --> 01:24:49,250
谁能成为领导者，

1374
01:24:49,250 --> 01:24:50,570
从这几个，

1375
01:24:50,570 --> 01:24:55,460
从这 6 个， a b c 到 f ，谁能成为领导者？

1376
01:24:57,840 --> 01:24:59,220
f 能成为领导者吗？

1377
01:24:59,820 --> 01:25:01,830
不能。

1378
01:25:03,430 --> 01:25:04,660
e 能成为领导者吗？

1379
01:25:06,660 --> 01:25:10,650
也不能，可以成为领导者的是 a c 和 d 。

1380
01:25:11,040 --> 01:25:15,420
没错，（这些）可能成为领导者。

1381
01:25:17,690 --> 01:25:21,470
但是如果 d 还活着， a 能不能成为领导者，

1382
01:25:21,500 --> 01:25:25,100
因为安全部分说，

1383
01:25:25,190 --> 01:25:28,850
RPC 请求实施了限制，

1384
01:25:28,850 --> 01:25:32,030
它会比较最后的日志条目，

1385
01:25:32,030 --> 01:25:35,930
而日志条目最高的应该成为领导者。

1386
01:25:36,380 --> 01:25:41,090
我只是觉得，它不会投票给某个人。

1387
01:25:42,060 --> 01:25:42,870
没错。

1388
01:25:43,410 --> 01:25:47,340
比如它们永远不会投票给 a 。

1389
01:25:47,370 --> 01:25:48,390
完全正确。

1390
01:25:48,450 --> 01:25:50,250
我的意思是，这也不是真的，

1391
01:25:50,250 --> 01:25:56,100
如果你有一个条目比另一个节点的 term 更高，

1392
01:25:56,100 --> 01:25:59,570
比如你更好[]，

1393
01:25:59,570 --> 01:26:04,050
我的意思是，你可以像成为领导者，

1394
01:26:04,050 --> 01:26:06,960
试图将追加条目到日志中，

1395
01:26:06,960 --> 01:26:09,180
它们不会通过，所以。

1396
01:26:09,900 --> 01:26:11,700
d ，当你通过的时候，

1397
01:26:12,290 --> 01:26:13,880
好的， d 是，

1398
01:26:14,000 --> 01:26:16,010
d 再次投票， a 成为领导者，

1399
01:26:16,040 --> 01:26:17,540
d 试着，

1400
01:26:17,870 --> 01:26:21,990
a 不会联系 d ，

1401
01:26:22,020 --> 01:26:23,910
如果不投票给它。

1402
01:26:27,780 --> 01:26:29,070
所以，它们会继续进行下去。

1403
01:26:31,380 --> 01:26:34,170
那么为什么它们会有 term 7 的日志，

1404
01:26:34,170 --> 01:26:36,210
如果它在 term 7 不是领导者？

1405
01:26:37,940 --> 01:26:40,370
d 一定是 term 7 的领导者。

1406
01:26:41,760 --> 01:26:42,660
是的，我同意。

1407
01:26:43,590 --> 01:26:45,060
否则，你将没有日志条目。

1408
01:26:54,360 --> 01:26:58,230
什么时候通过日志的，我想我忘了。

1409
01:26:58,230 --> 01:27:06,550
所以，在这种情况下， d 是 term 7 的领导者吗，

1410
01:27:06,580 --> 01:27:08,230
丢失了连接，

1411
01:27:08,230 --> 01:27:11,620
然后最上面的当选为新的领导者。

1412
01:27:12,740 --> 01:27:13,820
是的，我想是的。

1413
01:27:15,120 --> 01:27:16,380
让我收回这句话，

1414
01:27:16,380 --> 01:27:18,330
我记不清具体的顺序了，

1415
01:27:18,330 --> 01:27:20,370
我没怎么注意过最上面这个，

1416
01:27:20,820 --> 01:27:23,490
但我认为情况就是这样。

1417
01:27:23,790 --> 01:27:30,840
它说过，它不是 term 8 ，也不是[]日志。

1418
01:27:33,110 --> 01:27:34,640
我认为我们正在看的情况，

1419
01:27:34,640 --> 01:27:37,820
其中 a 的 term 比 d 的大，

1420
01:27:37,820 --> 01:27:40,940
他们在安全论证中的提到的[矛盾]情况，

1421
01:27:41,270 --> 01:27:43,520
我认为他们证明了这是不可能的。

1422
01:27:45,890 --> 01:27:47,120
哪一个是不可能的？

1423
01:27:47,780 --> 01:27:50,660
比如 a 可以当选，

1424
01:27:51,110 --> 01:27:54,260
b 丢失一个条目，并且有比 d 高的 term ，

1425
01:27:54,260 --> 01:27:55,340
这里就是这种情况，

1426
01:27:55,370 --> 01:27:58,910
我认为有证据表明这是一种矛盾。

1427
01:27:59,570 --> 01:28:00,740
我不这么认为，

1428
01:28:00,740 --> 01:28:03,320
我认为[]当选领导人是完全可以的。

1429
01:28:03,920 --> 01:28:07,160
是的，我认为安全证明说，

1430
01:28:07,400 --> 01:28:14,190
未来的领导者不能有，需要提交所有的日志。

1431
01:28:14,190 --> 01:28:15,570
提交，是的。

1432
01:28:15,570 --> 01:28:17,010
并且 7 没有被提交。

1433
01:28:17,220 --> 01:28:17,820
没错。

1434
01:28:18,700 --> 01:28:20,230
我可以在这里做很多操作，

1435
01:28:20,230 --> 01:28:21,250
它们没有被提交，

1436
01:28:21,250 --> 01:28:22,180
它们只是试探性的，

1437
01:28:22,210 --> 01:28:23,800
所以任何事情都可能发生在它们身上，

1438
01:28:24,190 --> 01:28:25,960
然后就不会出什么错了。

1439
01:28:27,490 --> 01:28:30,190
而所有提交的事情工作的原因是，

1440
01:28:30,190 --> 01:28:35,080
因为如果它提交比大多数都要多，

1441
01:28:35,110 --> 01:28:35,980
那些条目，

1442
01:28:35,980 --> 01:28:39,850
没有提交的条目永远不会当选，对吧。

1443
01:28:40,030 --> 01:28:40,720
是的。

1444
01:28:41,180 --> 01:28:42,050
完全正确。

1445
01:28:49,450 --> 01:28:51,250
是的，他们讨论，

1446
01:28:51,250 --> 01:28:56,530
只有包含更老的提交条目的才能当选，

1447
01:28:56,530 --> 01:28:59,080
我认为事情变得更复杂了，

1448
01:28:59,410 --> 01:29:04,540
包含所有提交条目的人可以当选，

1449
01:29:05,060 --> 01:29:05,780
那是。

1450
01:29:06,380 --> 01:29:07,850
是的，在某种程度上这无关紧要。

1451
01:29:08,800 --> 01:29:10,090
好的。

1452
01:29:15,060 --> 01:29:15,990
所以，所有的。

1453
01:29:16,230 --> 01:29:21,180
term 4 之后的所有提交都不会在这里提交，对吧。

1454
01:29:22,020 --> 01:29:27,130
所以这两个 4 吗，这些不是。

1455
01:29:27,130 --> 01:29:29,020
前两个 4 。

1456
01:29:29,630 --> 01:29:31,640
这些吗，你的问题所在，

1457
01:29:31,790 --> 01:29:32,750
它们会被提交。

1458
01:29:33,200 --> 01:29:34,340
是的，这些会被提交，

1459
01:29:34,340 --> 01:29:35,960
但是之后的所有东西也会吗？

1460
01:29:37,220 --> 01:29:38,390
两个 5 会被提交。

1461
01:29:38,690 --> 01:29:39,350
两个 6 。

1462
01:29:39,560 --> 01:29:41,600
两个 6 也会被提交。

1463
01:29:42,780 --> 01:29:44,520
好的，你只需要，

1464
01:29:44,520 --> 01:29:45,630
好的,

1465
01:29:45,810 --> 01:29:47,130
就是这样的，好的。

1466
01:29:48,120 --> 01:29:49,380
不，另一个。

1467
01:29:49,380 --> 01:29:50,520
超过 4 。

1468
01:29:52,430 --> 01:29:54,410
是的，所以 5 和 6 不会被提交，

1469
01:29:55,400 --> 01:29:58,130
哦，但你又有另一个领导者。

1470
01:29:58,130 --> 01:29:59,450
是的。

1471
01:29:59,450 --> 01:30:01,850
好的，别忘了这些，

1472
01:30:02,180 --> 01:30:02,660
我知道了。

1473
01:30:03,610 --> 01:30:07,270
好的，我会回到这个话题，

1474
01:30:07,270 --> 01:30:08,260
在下一节课开始的时候，

1475
01:30:08,260 --> 01:30:11,020
因为你们中的一些人可能要到其他课上，

1476
01:30:12,220 --> 01:30:13,960
但是，我会回到这个问题上来，

1477
01:30:14,050 --> 01:30:16,120
如果你有更多的问题，请不要客气，

1478
01:30:16,270 --> 01:30:19,030
我们会重新开始的。

1479
01:30:23,000 --> 01:30:27,230
哦，你能再说一下日志复制吗，

1480
01:30:27,230 --> 01:30:29,960
什么时候会有日志复制。

1481
01:30:30,910 --> 01:30:32,860
我的意思是，

1482
01:30:33,370 --> 01:30:37,630
在某个时课，领导者会把自己的日志给跟随者。

1483
01:30:41,910 --> 01:30:45,840
我想你在前面的一些幻灯片中提到了。

1484
01:30:45,840 --> 01:30:54,660
好的，也许，我不记得我说过。

1485
01:30:55,050 --> 01:30:58,520
更多一点，也许更多一点。

1486
01:31:09,510 --> 01:31:12,780
哦，这是不是删除重复？

1487
01:31:13,490 --> 01:31:14,750
检测重复。

1488
01:31:14,780 --> 01:31:16,610
是的，这很难。

1489
01:31:16,670 --> 01:31:20,450
是的，这不是一个 raft 问题，

1490
01:31:20,450 --> 01:31:23,840
这是一个键值服务问题，

1491
01:31:24,340 --> 01:31:28,600
在客户端请求时，可能，

1492
01:31:28,600 --> 01:31:31,930
客户端可能得不到响应，

1493
01:31:32,460 --> 01:31:35,790
即使那个请求通过了 raft ，

1494
01:31:36,180 --> 01:31:37,470
因为发生的情况是，

1495
01:31:37,470 --> 01:31:40,260
领导者可能会把操作应用于其状态，

1496
01:31:40,260 --> 01:31:42,540
在回应客户端之前，它崩溃了，

1497
01:31:43,880 --> 01:31:45,290
因此客户端会重试，

1498
01:31:45,860 --> 01:31:48,170
我们会将这一请求发送给新的领导者，

1499
01:31:48,200 --> 01:31:49,940
新的领导者通过 raft 运行它，

1500
01:31:49,940 --> 01:31:51,350
然后它又会从 raft 出来。

1501
01:31:52,570 --> 01:31:53,920
所以，情况是这样的，

1502
01:31:53,920 --> 01:31:56,290
kv 服务器进行重复检测。

1503
01:31:58,240 --> 01:32:01,210
哦，这就像是只有在客户没有得到回复的情况下。

1504
01:32:02,350 --> 01:32:03,220
是的，没错。

1505
01:32:03,580 --> 01:32:05,770
好的，我明白了，谢谢。

1506
01:32:05,950 --> 01:32:08,110
你将在实验 3 中完成这个。

1507
01:32:13,380 --> 01:32:15,450
我想我在课程中也问了一些问题，

1508
01:32:15,450 --> 01:32:17,790
但我不认为我完全理解了答案，

1509
01:32:17,790 --> 01:32:19,650
所以我再重复一遍问题，

1510
01:32:20,550 --> 01:32:21,840
问题是，

1511
01:32:21,870 --> 01:32:26,130
你说提交工作的一种方式是，

1512
01:32:26,160 --> 01:32:31,090
一旦领导者提交，它就会等待新的客户端消息，

1513
01:32:31,090 --> 01:32:33,700
然后它只是将消息附加到日志条目，

1514
01:32:33,700 --> 01:32:36,640
并将附加条目发送给剩余的跟随者，

1515
01:32:37,060 --> 01:32:38,770
另外还有一条消息说，

1516
01:32:38,770 --> 01:32:41,410
它们也应该提交之前的所有条目，是吗。

1517
01:32:41,740 --> 01:32:44,110
是的，这是[]的协议。

1518
01:32:44,290 --> 01:32:46,450
是的，所以我的问题是，

1519
01:32:46,480 --> 01:32:50,200
如果领导者提交了所有条目，

1520
01:32:50,640 --> 01:32:54,990
在它将消息发送给其他跟随者之前，

1521
01:32:55,020 --> 01:32:56,160
领导者崩溃了。

1522
01:32:56,460 --> 01:32:57,750
它不能提交，

1523
01:32:57,750 --> 01:33:02,520
直到得到大多数跟随者的多数响应。

1524
01:33:03,760 --> 01:33:07,300
我明白了，所以它即使。

1525
01:33:07,300 --> 01:33:08,920
它在日志中，

1526
01:33:08,920 --> 01:33:11,590
但它还没有交付给 kv 服务器。

1527
01:33:12,650 --> 01:33:13,010
我明白了，

1528
01:33:13,010 --> 01:33:16,790
所以它在等待所有其他跟随者的提交回复，

1529
01:33:16,790 --> 01:33:18,800
然后它提交自己的。

1530
01:33:20,120 --> 01:33:21,050
好的。

1531
01:33:21,050 --> 01:33:22,160
所以基本上，

1532
01:33:22,160 --> 01:33:25,160
有一个变量最后应用提交的索引，

1533
01:33:25,190 --> 01:33:26,450
这是在维护，

1534
01:33:26,780 --> 01:33:29,000
它只会增加提交的索引，

1535
01:33:29,000 --> 01:33:32,360
一旦收到大多数跟随者的回应。

1536
01:33:32,940 --> 01:33:35,670
所有的跟随者说它们已经提交了自己的，

1537
01:33:36,180 --> 01:33:38,910
比如它们在自己的服务器上提交了日志条目。

1538
01:33:39,890 --> 01:33:41,540
它们会提交日志条目，

1539
01:33:41,540 --> 01:33:45,500
一旦它们知道领导者提交了日志条目。

1540
01:33:48,280 --> 01:33:49,750
是的，这就是我的问题，

1541
01:33:49,750 --> 01:33:50,920
它们如何知道，

1542
01:33:50,920 --> 01:33:53,470
如果领导者不能发送消息给其他的。

1543
01:33:53,710 --> 01:33:55,510
是的，所以我们，

1544
01:33:55,510 --> 01:33:58,000
我们会结束在图 7 中看到的情况下，

1545
01:33:58,330 --> 01:34:02,290
它们的日志中会有试探性的日志条目，

1546
01:34:02,620 --> 01:34:05,830
取决于谁将成为新的领导者，

1547
01:34:05,830 --> 01:34:07,390
以及日志情况是什么，

1548
01:34:07,390 --> 01:34:09,970
该操作中可能被提交，也可能不被提交。

1549
01:34:11,490 --> 01:34:12,240
我明白了，

1550
01:34:12,650 --> 01:34:15,590
好的，我明白了。

1551
01:34:15,590 --> 01:34:17,480
嗨，我有一个关于这个的后续问题，

1552
01:34:17,660 --> 01:34:21,710
如果领导者推入了一个日志条目，

1553
01:34:21,830 --> 01:34:23,480
被大多数人接受了，

1554
01:34:23,480 --> 01:34:24,560
但它崩溃了，

1555
01:34:25,100 --> 01:34:28,880
然后这个日志条目可以提交，对吗，

1556
01:34:28,940 --> 01:34:29,990
通过其他领导者。

1557
01:34:30,080 --> 01:34:31,850
它可以，也可能不会。

1558
01:34:32,700 --> 01:34:34,680
是的，但如果已经提交的话，

1559
01:34:34,680 --> 01:34:37,260
那么，新的领导者怎么知道，

1560
01:34:37,260 --> 01:34:38,220
谁是客户端，

1561
01:34:38,220 --> 01:34:40,230
谁请求这个日志条目

1562
01:34:40,230 --> 01:34:44,220
或客户端是合格的。

1563
01:34:49,540 --> 01:34:53,560
好的，好的，

1564
01:34:53,560 --> 01:34:54,820
这里确实有一个问题，

1565
01:34:54,820 --> 01:34:58,960
关于 kv 服务器是如何使用 raft 存储信息的，

1566
01:34:59,350 --> 01:35:01,360
所以情况是这样的，

1567
01:35:01,420 --> 01:35:02,740
客户端访问领导者，

1568
01:35:02,890 --> 01:35:09,960
领导者提交有没有执行过这个操作，

1569
01:35:10,170 --> 01:35:11,100
它们不知道，

1570
01:35:12,060 --> 01:35:13,050
他们不知道的是，

1571
01:35:13,050 --> 01:35:18,180
然后有一个跟随者得到这个操作，

1572
01:35:18,300 --> 01:35:19,440
或许应用它，

1573
01:35:19,830 --> 01:35:21,600
不会发送响应，

1574
01:35:21,600 --> 01:35:23,160
因为它不知道客户端，

1575
01:35:23,600 --> 01:35:25,460
但是客户端会重试，

1576
01:35:25,460 --> 01:35:27,320
因为它还没有得到回应，

1577
01:35:27,350 --> 01:35:28,730
它将访问新的领导者，

1578
01:35:28,880 --> 01:35:32,990
然后输入相同的操作给 raft ，

1579
01:35:33,470 --> 01:35:35,030
并且再次出来，

1580
01:35:35,270 --> 01:35:38,120
然后服务器将发送，

1581
01:35:38,180 --> 01:35:39,740
正如我们将在实验 3 中看到的，

1582
01:35:39,740 --> 01:35:41,090
会发送最后一条回复，

1583
01:35:41,090 --> 01:35:44,630
事实上，服务器会记住它们发回的最后一个值。

1584
01:35:46,770 --> 01:35:48,150
好的。

1585
01:35:48,180 --> 01:35:51,630
如果是 get 请求，

1586
01:35:51,630 --> 01:35:53,850
第一个 get 请求被执行，

1587
01:35:54,210 --> 01:35:55,740
没有要发回的响应，

1588
01:35:55,950 --> 01:36:01,680
get 请求会将响应存储在 kv 服务器中，

1589
01:36:01,680 --> 01:36:03,150
并会记住响应。

1590
01:36:03,660 --> 01:36:05,730
所以当它看到重复时，

1591
01:36:05,730 --> 01:36:06,960
就会发送一个响应，

1592
01:36:08,050 --> 01:36:09,880
所以会有重复检测表，

1593
01:36:10,600 --> 01:36:11,890
包含那些响应。

1594
01:36:13,270 --> 01:36:14,950
好的，理解了，谢谢。

1595
01:36:16,950 --> 01:36:17,580
不用谢。

1596
01:36:19,260 --> 01:36:20,520
我有点好奇，

1597
01:36:20,520 --> 01:36:21,180
我想我问到了，

1598
01:36:21,240 --> 01:36:23,430
这是我的问题，

1599
01:36:23,460 --> 01:36:24,810
课程前的问题，

1600
01:36:25,170 --> 01:36:28,560
比如 raft 与其他类似的共识算法相比，

1601
01:36:28,560 --> 01:36:31,770
在比如可以做的优化方面，

1602
01:36:32,010 --> 01:36:36,000
举个例子，我唯一能想到的就是批处理。

1603
01:36:36,330 --> 01:36:36,540
是的。

1604
01:36:36,540 --> 01:36:39,150
看起来 raft 对于批处理是很完美的，

1605
01:36:39,150 --> 01:36:42,570
因为领导者可以在日志中放入不止一个条目，

1606
01:36:42,570 --> 01:36:44,550
在发送下一个条目之前等待，

1607
01:36:44,670 --> 01:36:49,620
然后发送带有批处理的操作的条目，

1608
01:36:49,620 --> 01:36:51,900
或者它想复制的东西，

1609
01:36:52,320 --> 01:36:55,830
只是想弄清楚 raft 有什么不足之处，

1610
01:36:55,830 --> 01:36:57,660
从性能的角度来看。

1611
01:36:57,810 --> 01:37:00,240
好的， raft 没有这么做，

1612
01:37:00,540 --> 01:37:01,980
也许它可以，

1613
01:37:02,010 --> 01:37:03,870
但这会使协议变得更加复杂，

1614
01:37:03,900 --> 01:37:05,280
所以他们决定什么都不做。

1615
01:37:05,830 --> 01:37:06,310
我想，

1616
01:37:06,310 --> 01:37:09,580
好的，我想我写 raft 实验代码的方式，

1617
01:37:09,580 --> 01:37:12,490
我隐含地做了批处理，

1618
01:37:12,490 --> 01:37:14,500
有时会等待一小段时间，

1619
01:37:14,500 --> 01:37:15,610
在发送附加条目之前，

1620
01:37:15,610 --> 01:37:16,900
所以我想我觉得，

1621
01:37:17,140 --> 01:37:18,220
你不需要做任何事情，

1622
01:37:18,220 --> 01:37:21,100
只是像之前那样。

1623
01:37:21,100 --> 01:37:22,120
是的，你可以。

1624
01:37:23,920 --> 01:37:27,610
所以，是的。

1625
01:37:27,640 --> 01:37:33,190
是的，我想它归结为性能，

1626
01:37:33,580 --> 01:37:36,190
有很多优化 raft 没有做，

1627
01:37:36,190 --> 01:37:37,660
其他一些系统是做了的，

1628
01:37:37,660 --> 01:37:40,390
例如，你也许能够沟通你的操作，

1629
01:37:40,390 --> 01:37:43,330
因为你按什么顺序做并不重要，

1630
01:37:43,450 --> 01:37:46,120
所以有一系列的优化，

1631
01:37:46,120 --> 01:37:48,010
在 raft 上，基本上什么都没做。

1632
01:37:48,760 --> 01:37:51,900
好的，谢谢。

1633
01:37:52,230 --> 01:37:54,660
对于用例，它可能非常好。

1634
01:37:55,240 --> 01:37:55,780
是的。

1635
01:37:59,380 --> 01:38:02,170
你几分钟前提到了一件事，

1636
01:38:02,170 --> 01:38:04,540
日志条目可能丢失，

1637
01:38:04,810 --> 01:38:08,020
那么有没有可能永远不会执行客户端请求，

1638
01:38:08,020 --> 01:38:09,460
但 raft 保证，

1639
01:38:09,730 --> 01:38:14,170
所有服务器将以相同的顺序执行相同的日志条目。

1640
01:38:15,920 --> 01:38:20,630
因此，这意味着 raft 并不是适用于所有应用，

1641
01:38:20,630 --> 01:38:26,360
只能用于负担得起一些丢失的请求。

1642
01:38:27,340 --> 01:38:29,680
好的，我们必须假设

1643
01:38:29,680 --> 01:38:34,720
来自 raft 服务器的响应作为一个整体，

1644
01:38:34,720 --> 01:38:36,250
kv 服务器加上 raft ，

1645
01:38:36,280 --> 01:38:37,360
可能会丢失，

1646
01:38:37,360 --> 01:38:38,530
因为网络会丢失，

1647
01:38:39,220 --> 01:38:40,870
网络可能丢失响应，

1648
01:38:40,870 --> 01:38:42,850
所以客户端必须能够重复，

1649
01:38:44,200 --> 01:38:47,500
客户端必须重试。

1650
01:38:48,700 --> 01:38:49,300
我明白了，

1651
01:38:49,300 --> 01:38:51,970
所以当它提交日志条目时，

1652
01:38:51,970 --> 01:38:54,520
执行它，并响应给客户端，

1653
01:38:54,520 --> 01:38:55,630
它确实做到了。

1654
01:38:56,020 --> 01:38:58,420
是的，这就像我们之前讨论过的，

1655
01:38:58,420 --> 01:39:00,160
重复检测表，

1656
01:39:00,160 --> 01:39:03,760
重复检测表具有已发送的响应，

1657
01:39:03,970 --> 01:39:06,910
或者响应执行操作的构造。

1658
01:39:08,890 --> 01:39:09,340
好的。

1659
01:39:13,740 --> 01:39:14,970
还有什么问题吗？

1660
01:39:18,320 --> 01:39:19,640
好的，非常感谢。

1661
01:39:20,030 --> 01:39:22,400
好的，不用谢，能问这么多问题真是太好了。

