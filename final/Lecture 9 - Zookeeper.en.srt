1
00:00:00,450 --> 00:00:01,290
Thank you.

2
00:00:01,470 --> 00:00:05,400
Okay, good afternoon, good morning, good evening, good night, wherever you are,

3
00:00:06,180 --> 00:00:10,230
so today I want to talk about the zookeeper

4
00:00:10,230 --> 00:00:12,690
and with the this background,

5
00:00:12,720 --> 00:00:15,300
paper that we you know which is assigned for today,

6
00:00:15,300 --> 00:00:16,770
which is from 2010.

7
00:00:17,890 --> 00:00:23,710
And, so there's gonna be referring back the last couple lectures,

8
00:00:23,710 --> 00:00:26,170
I think we dove in quite a bit of detail into raft,

9
00:00:26,170 --> 00:00:29,530
including looking at code,

10
00:00:29,560 --> 00:00:32,530
the lectures from now on are going to be more conceptual

11
00:00:32,800 --> 00:00:38,170
and exploring ideas in distributed systems zookeeper's,

12
00:00:38,740 --> 00:00:43,000
and the zookeeper, what is particularly relevant to us,

13
00:00:43,300 --> 00:00:46,360
because it has a little bit of relationship

14
00:00:46,360 --> 00:00:47,920
as we'll see with lab 3.

15
00:00:48,970 --> 00:00:52,420
And so it will allow us to talk about some properties of lab 3,

16
00:00:52,420 --> 00:00:54,130
and particularly linearizability,

17
00:00:54,760 --> 00:00:57,580
but zookeeper system more importantly,

18
00:00:57,580 --> 00:00:58,270
it's interesting,

19
00:00:58,270 --> 00:01:05,350
because one of widely-used system in practice,

20
00:01:07,700 --> 00:01:12,350
well beyond Apache, well beyond Yahoo,

21
00:01:12,350 --> 00:01:15,200
is a open source Apache project,

22
00:01:15,200 --> 00:01:17,120
that is still active.

23
00:01:17,910 --> 00:01:21,660
What particularly interesting about it for us,

24
00:01:21,870 --> 00:01:24,480
in the lecture like today is actually high performance,

25
00:01:25,110 --> 00:01:26,700
and high performance, I mean,

26
00:01:26,820 --> 00:01:31,770
much higher performance than what actually lab 3 is gonna be.

27
00:01:32,840 --> 00:01:36,020
I'll talk to talk quite a bit of detail about this,

28
00:01:36,380 --> 00:01:39,260
and there's sort of two reasons why it is high performance,

29
00:01:39,260 --> 00:01:42,740
one, it is the client operations are asynchronous,

30
00:01:47,180 --> 00:01:49,610
and really what high performing from here means is,

31
00:01:49,610 --> 00:01:54,020
we can, the system can process many more operations per second,

32
00:01:54,020 --> 00:01:55,940
so it's really a throughput metric,

33
00:01:56,480 --> 00:01:59,990
and the second reason it's high performances because,

34
00:01:59,990 --> 00:02:02,510
it doesn't provide strong consistency,

35
00:02:02,540 --> 00:02:10,900
so it doesn't, it has an interesting consistency definition,

36
00:02:11,500 --> 00:02:12,850
and it gives us some freedom

37
00:02:12,880 --> 00:02:16,240
to execute basically read operations on any replica,

38
00:02:16,420 --> 00:02:18,250
and therefore read [] can scale.

39
00:02:19,700 --> 00:02:23,030
Then, the second aspect that is interesting from zookeeper is,

40
00:02:23,030 --> 00:02:24,680
in addition to being high performance,

41
00:02:24,890 --> 00:02:26,390
it is sort of a generic,

42
00:02:26,390 --> 00:02:28,310
what they call coordination service,

43
00:02:35,260 --> 00:02:37,330
and the point being here is,

44
00:02:37,330 --> 00:02:39,220
there are many applications,

45
00:02:39,550 --> 00:02:44,920
where you need to keep track of like who's part of this cluster

46
00:02:44,920 --> 00:02:46,210
and who's the master,

47
00:02:46,750 --> 00:02:50,920
so think about the mapreduce or think about the GFS,

48
00:02:50,920 --> 00:02:53,410
the master in GFS needs to keep track

49
00:02:53,410 --> 00:02:54,670
or like for every chunk,

50
00:02:54,820 --> 00:02:56,950
who are the servers that actually server that,

51
00:02:56,950 --> 00:03:00,130
[] server chunk who servers actually is the master,

52
00:03:00,820 --> 00:03:03,760
and so tracking that sort of configuration information,

53
00:03:03,760 --> 00:03:06,490
you know comes up in lots of different distributed applications,

54
00:03:06,730 --> 00:03:09,970
zookeeper is really designed to support that kind of thing,

55
00:03:09,970 --> 00:03:14,260
so you sort of outsource all the configuration management to zookeeper,

56
00:03:14,560 --> 00:03:18,910
and then focus the rest of your application development,

57
00:03:18,910 --> 00:03:21,880
on other aspects of your distributed system.

58
00:03:22,860 --> 00:03:25,470
Okay, so that's sort of a brief introduction,

59
00:03:25,470 --> 00:03:28,080
you know the topics that we're gonna be talking about.

60
00:03:30,350 --> 00:03:32,960
And as usual, feel free to interrupt at any time,

61
00:03:33,470 --> 00:03:37,130
or you know post something in the chat message,

62
00:03:37,190 --> 00:03:38,930
let me actually pull up the chat.

63
00:03:40,670 --> 00:03:48,440
Okay, so we just you know start from the basics zookeeper is replicated state machine,

64
00:03:58,730 --> 00:04:02,450
in the same way that you know the replicated state machines that we've been seeing.

65
00:04:02,750 --> 00:04:05,900
And so let's draw the usual picture,

66
00:04:06,110 --> 00:04:07,580
we have some servers,

67
00:04:07,700 --> 00:04:08,480
in this case,

68
00:04:08,480 --> 00:04:10,790
it's gonna be zookeeper ZK.

69
00:04:11,670 --> 00:04:14,850
It receives requests from clients,

70
00:04:14,850 --> 00:04:17,790
that create create znode,

71
00:04:17,850 --> 00:04:25,590
and basically the way it interacts to distribute these operations,

72
00:04:25,590 --> 00:04:27,480
it has sort of a separate library,

73
00:04:27,480 --> 00:04:30,030
you know think about this as the raft library,

74
00:04:30,480 --> 00:04:32,370
in their case, it's called ZAB.

75
00:04:34,620 --> 00:04:39,960
Basically, you know the leader you know sticks the operation into

76
00:04:39,960 --> 00:04:42,480
you know the equivalent raft library,

77
00:04:42,480 --> 00:04:49,020
that you know talks you know to you know other libraries or other peers,

78
00:04:49,440 --> 00:04:52,500
that basically creates a log,

79
00:04:52,830 --> 00:04:56,010
you know that conveys with all these operations and all these machines,

80
00:04:56,820 --> 00:05:00,570
and then the operations are the log of feedback to the [],

81
00:05:00,570 --> 00:05:05,070
so in our case, the apply channel to the service,

82
00:05:05,070 --> 00:05:07,260
the service applies the operation in response to the client,

83
00:05:07,290 --> 00:05:10,300
and so we have basically different [] is running.

84
00:05:11,090 --> 00:05:16,670
And so far, you know in the labs you know really focusing mostly,

85
00:05:16,670 --> 00:05:19,040
you know lab 2 is all about you know this part,

86
00:05:21,000 --> 00:05:24,390
implementing in our case raft, so instead of ZAB,

87
00:05:24,690 --> 00:05:27,810
and for the first or the at a very high level,

88
00:05:27,810 --> 00:05:31,950
you can think about ZAB being another raft,

89
00:05:31,950 --> 00:05:34,500
you know providing sort of similar guarantees

90
00:05:34,500 --> 00:05:36,450
you know implemented quite differently,

91
00:05:36,750 --> 00:05:41,400
you know it provides an order of all the operations,

92
00:05:41,460 --> 00:05:45,150
the [] failures, network partitions, etc etc,

93
00:05:45,180 --> 00:05:47,280
doesn't suffer from split-brain brain,

94
00:05:47,280 --> 00:05:51,120
all are sort of things which we associate with the raft library.

95
00:05:51,900 --> 00:05:56,970
In you know what we're gonna be focusing in lab 3 on is,

96
00:05:56,970 --> 00:05:58,650
actually implementing a service on top of it,

97
00:05:58,890 --> 00:06:03,750
so this paper talks about the this coordination service zookeeper in,

98
00:06:03,780 --> 00:06:06,480
we're going to actually implement in lab 3 key value stores,

99
00:06:12,400 --> 00:06:15,760
and the data structure is just map from keys to values.

100
00:06:16,690 --> 00:06:20,530
And so the operations you know that we're going to be supporting are put and get,

101
00:06:22,650 --> 00:06:26,400
so the clients may put and get operations you know to the service,

102
00:06:26,400 --> 00:06:28,290
the service runs in through raft,

103
00:06:28,590 --> 00:06:31,950
and then applies them one by one to the key value store.

104
00:06:32,810 --> 00:06:35,930
In zookeeper you know the structures slightly different,

105
00:06:35,930 --> 00:06:37,730
there's a tree of znodes,

106
00:06:38,180 --> 00:06:40,700
but the basic operation is the applys the same,

107
00:06:40,700 --> 00:06:45,450
you know the lower layer the ZAB or the ZAB library

108
00:06:45,450 --> 00:06:47,370
or ZAB library orders all the operations,

109
00:06:47,370 --> 00:06:49,740
they're applied in the same order all replicas,

110
00:06:49,920 --> 00:06:51,960
because they are applied all in the same order,

111
00:06:51,960 --> 00:06:53,520
there's no non-determinism,

112
00:06:53,820 --> 00:06:57,360
the resulting state on each of the replica is going to be identical.

113
00:07:00,480 --> 00:07:01,080
Okay?

114
00:07:01,980 --> 00:07:06,480
That's sort of the basic setting of this paper,

115
00:07:06,600 --> 00:07:09,240
and sort of also the relation, part of the relationship

116
00:07:09,240 --> 00:07:13,620
between lab 3 and the zookeeper service itself.

117
00:07:14,280 --> 00:07:16,320
And mostly going to be talking in this lecture

118
00:07:16,320 --> 00:07:18,360
on focus on the zookeeper part itself,

119
00:07:18,360 --> 00:07:19,920
and not talk about ZAB,

120
00:07:20,280 --> 00:07:21,780
because you're gonna assume,

121
00:07:21,780 --> 00:07:25,620
that's similar to what we're doing and we're doing in lab 2.

122
00:07:28,370 --> 00:07:31,340
Okay, we're going to talking a little bit about,

123
00:07:31,490 --> 00:07:34,730
what kind of performance would you observe,

124
00:07:34,820 --> 00:07:37,040
if you want to finish lab 3,

125
00:07:37,650 --> 00:07:42,690
and would measure how many you puts or gets your operation get through per second,

126
00:07:42,780 --> 00:07:47,370
because one of the achievements this paper is you know high performance.

127
00:07:47,760 --> 00:07:49,260
So let's think a little bit about that,

128
00:07:49,650 --> 00:07:52,290
so let's assume you know a put operation coming in,

129
00:07:54,360 --> 00:07:56,490
and you know put operation comes in by the leader,

130
00:07:56,490 --> 00:07:58,320
and so we're just gonna go for the normal case,

131
00:07:58,320 --> 00:08:00,060
like the standard case, where everything is working,

132
00:08:00,060 --> 00:08:01,770
no network failures, no partitions, nothing,

133
00:08:01,800 --> 00:08:03,120
everything works out perfectly.

134
00:08:03,570 --> 00:08:04,620
Here's the leader,

135
00:08:04,710 --> 00:08:06,000
we've got two followers.

136
00:08:09,390 --> 00:08:13,320
And you know now you know that protocol you know probably inside out,

137
00:08:13,590 --> 00:08:15,060
you know the first thing of course it happens,

138
00:08:15,060 --> 00:08:17,340
like would be the leader call start,

139
00:08:17,840 --> 00:08:26,080
start actually writes the put operation to its, to log in the leader,

140
00:08:26,260 --> 00:08:30,670
and then the leader you know propagates it's log to the other followers,

141
00:08:31,360 --> 00:08:34,210
and you know before it actually happens in parallel,

142
00:08:34,810 --> 00:08:35,890
send that argument,

143
00:08:35,980 --> 00:08:37,660
let me draw it slightly differently,

144
00:08:40,020 --> 00:08:46,650
basically it launches a bunch of RPCs almost instantaneously to the different followers,

145
00:08:46,950 --> 00:08:50,340
each follower of course you know will append the entry to its logs,

146
00:08:50,340 --> 00:08:53,760
so that requires a writes to persistent storage,

147
00:08:53,760 --> 00:08:54,840
same thing here,

148
00:08:54,870 --> 00:08:56,160
and then they respond back.

149
00:08:57,110 --> 00:08:59,090
And so here's a response back,

150
00:08:59,360 --> 00:09:02,210
and in this case, majority has responded,

151
00:09:02,540 --> 00:09:04,820
the leader can actually apply the operation,

152
00:09:05,000 --> 00:09:09,140
so the leader will actually apply the operation here for [],

153
00:09:10,000 --> 00:09:14,680
so do the put and send the response back to the client.

154
00:09:15,580 --> 00:09:16,990
What curious about is like,

155
00:09:16,990 --> 00:09:21,010
how many put per second can we actually get,

156
00:09:21,040 --> 00:09:25,340
you know in this in this setting.

157
00:09:26,170 --> 00:09:28,330
And you know think about it,

158
00:09:28,330 --> 00:09:32,770
you know the when you do [] back-of-the-envelope-calculation,

159
00:09:32,770 --> 00:09:35,920
we don't really care exactly about the exact numbers,

160
00:09:35,920 --> 00:09:37,990
but you know one roundtrip,

161
00:09:38,410 --> 00:09:41,770
we need at least one roundtrip to actually get the majority,right,

162
00:09:41,800 --> 00:09:45,160
leader needs to talk to at least one follower to actually maintain the majority,

163
00:09:45,160 --> 00:09:47,800
so we're going to have at least one roundtrip messaging.

164
00:09:52,340 --> 00:09:57,920
And then you sort of need to look at the writes to stable storage,

165
00:09:57,920 --> 00:09:59,510
because those tend to be expensive,

166
00:09:59,840 --> 00:10:01,280
and we'll see you know in this case,

167
00:10:01,280 --> 00:10:02,270
we're going to have two writes,

168
00:10:02,270 --> 00:10:03,950
because there's gonna be one write at the leader,

169
00:10:03,950 --> 00:10:05,270
one write at the follower,

170
00:10:05,270 --> 00:10:08,360
at that point, we have at least two nodes that have copy,

171
00:10:08,540 --> 00:10:10,100
so what are the things will be committed,

172
00:10:10,430 --> 00:10:13,340
if no further failures,

173
00:10:13,520 --> 00:10:18,640
and so basically you know 2, and minimum we're going to need 2 writes.

174
00:10:20,590 --> 00:10:23,110
So that's sort of the base and the best you could do right,

175
00:10:23,110 --> 00:10:26,080
in this simple scheme that we discussed, discussed here,

176
00:10:26,500 --> 00:10:28,720
sort of, we can think about the cost is,

177
00:10:29,260 --> 00:10:31,360
in a roundtrip,

178
00:10:31,360 --> 00:10:32,860
you know maybe those running in the data center,

179
00:10:32,860 --> 00:10:34,420
networks are not across the Internet,

180
00:10:34,630 --> 00:10:37,270
maybe you know that actually comes down to 1 millisecond,

181
00:10:40,080 --> 00:10:42,180
we're roughly in the [neighborhood] for a millisecond,

182
00:10:42,180 --> 00:10:43,110
maybe a little bit faster,

183
00:10:43,110 --> 00:10:44,220
but we don't really care about,

184
00:10:44,310 --> 00:10:45,330
just a millisecond.

185
00:10:45,890 --> 00:10:48,020
So, we're going to do two writes to stable storage,

186
00:10:48,830 --> 00:10:51,590
write actually to stable storage seems to be expensive,

187
00:10:51,590 --> 00:10:55,910
and you know depends on what medium, what technology you're using for stable storage,

188
00:10:55,970 --> 00:10:59,300
let's assume when we're using SSDs, you know sort of pretty typical,

189
00:10:59,450 --> 00:11:03,260
then you know presumably one write in the order of maybe 2 milliseconds,

190
00:11:03,260 --> 00:11:07,280
you know we've got to really make sure actually the write ends up on the in the SSD,

191
00:11:07,280 --> 00:11:10,070
so we're gonna probably has to be a synchronous write,

192
00:11:10,990 --> 00:11:13,960
so it means like 2 milliseconds for one write,

193
00:11:13,960 --> 00:11:17,140
so two writes would be roughly you know 4 milliseconds.

194
00:11:19,110 --> 00:11:21,990
So we ended up, there's going to be 5 milliseconds.

195
00:11:24,270 --> 00:11:26,070
And so, how many operations per second?

196
00:11:28,100 --> 00:11:29,660
Just to see if anybody still awake.

197
00:11:33,880 --> 00:11:35,200
200.

198
00:11:35,200 --> 00:11:37,450
Yeah, so there's gonna be 200 put per second.

199
00:11:41,040 --> 00:11:42,810
Any questions about this, does that make sense?

200
00:11:46,010 --> 00:11:49,040
Okay, so now let's look at zookeeper.

201
00:11:49,070 --> 00:11:51,080
What's the roundtrip for in the writes,

202
00:11:51,080 --> 00:11:52,250
sorry, I missed it.

203
00:11:53,300 --> 00:11:56,900
The, the writes, the writes there's you know roundtrip,

204
00:11:56,900 --> 00:11:58,070
there's 1 roundtrip correct,

205
00:11:58,070 --> 00:11:59,600
talk from the leader to the follower,

206
00:11:59,600 --> 00:12:00,410
and the two writes,

207
00:12:00,410 --> 00:12:02,480
one at the stable storage for the leader

208
00:12:02,570 --> 00:12:05,600
and one at the stable storage for the follower,

209
00:12:07,340 --> 00:12:09,170
and the 2 writes end up to 4,

210
00:12:09,200 --> 00:12:11,060
roundtrip to roughly 1 millisecond,

211
00:12:11,060 --> 00:12:13,840
so the total is 5 milliseconds for one put.

212
00:12:17,160 --> 00:12:19,320
Okay, let's look at the zookeeper,

213
00:12:27,920 --> 00:12:32,390
and again the metric that the paper is interested in is the throughput metric,

214
00:12:32,390 --> 00:12:35,360
where it basically the clients, you have many many many clients

215
00:12:35,630 --> 00:12:45,800
and they pump many request to zookeeper as much as possible

216
00:12:45,980 --> 00:12:49,220
and [pipeline] them aggressively.

217
00:12:49,930 --> 00:12:54,520
And so, so let's see what the results of that is,

218
00:12:54,790 --> 00:13:00,570
and so let me pull up the graph of the paper,

219
00:13:04,260 --> 00:13:07,890
and you know look at that paper a little, look the graph a little bit.

220
00:13:10,240 --> 00:13:12,760
So a couple things that presumably to observe,

221
00:13:12,760 --> 00:13:15,850
you know on the x axis is the percentage of read requests,

222
00:13:15,850 --> 00:13:16,900
as we'll see in a second,

223
00:13:16,900 --> 00:13:21,310
you know this is going to be important to distinguish read or write operations,

224
00:13:21,310 --> 00:13:23,710
and so write operations are really operations that modify,

225
00:13:23,710 --> 00:13:25,840
any write operation that modifies state,

226
00:13:26,140 --> 00:13:28,990
read operations are operations don't modify the state at all,

227
00:13:29,260 --> 00:13:31,510
so in our lab three terms,

228
00:13:31,510 --> 00:13:33,550
you know put would be the write operation

229
00:13:33,550 --> 00:13:35,380
and get be the read operation.

230
00:13:36,340 --> 00:13:39,820
And on the y axis is the number operations per second,

231
00:13:39,820 --> 00:13:41,860
and let's look at the case of 3 servers,

232
00:13:42,130 --> 00:13:46,510
and so the first thing you notice is that zero reads,

233
00:13:46,510 --> 00:13:50,260
so only write operations, so what that modify the state,

234
00:13:50,440 --> 00:13:58,930
you know we get roughly 21k operations per second as throughput, right,

235
00:13:59,260 --> 00:14:03,910
and you know look at, you know if the system only has reads,

236
00:14:04,240 --> 00:14:05,380
it actually gets a lot more,

237
00:14:05,380 --> 00:14:10,270
and gets up in the you know whatever the 60-70 reads region,

238
00:14:10,570 --> 00:14:12,880
and in fact, what really go on is,

239
00:14:12,880 --> 00:14:14,080
that the number reads,

240
00:14:14,930 --> 00:14:17,990
the throughput in terms of reads the scales with the number of servers.

241
00:14:25,510 --> 00:14:29,740
So, if you have 3 servers,

242
00:14:29,740 --> 00:14:32,740
you know you get 3 times you know the read performance of one server,

243
00:14:32,740 --> 00:14:33,610
if you have 5 servers,

244
00:14:33,610 --> 00:14:37,720
you get 5 times the read performance one server.

245
00:14:38,200 --> 00:14:39,730
Of course not true writes, correct,

246
00:14:39,730 --> 00:14:41,470
in fact if you look at this graph,

247
00:14:41,500 --> 00:14:44,260
you see that if with more servers,

248
00:14:44,290 --> 00:14:45,880
the write performance actually goes down.

249
00:14:46,460 --> 00:14:49,400
And you know that the reason for that is presumably,

250
00:14:49,400 --> 00:14:52,850
the leader has to chat with more servers,

251
00:14:52,850 --> 00:14:54,260
to actually gets operation through.

252
00:14:54,980 --> 00:14:57,980
And so when we're purely doing write operations,

253
00:14:58,100 --> 00:14:59,900
we actually limited,

254
00:14:59,900 --> 00:15:02,390
and we cannot expect more performance than a single server,

255
00:15:02,390 --> 00:15:05,570
in fact, the [up] servers we're going to go down performance.

256
00:15:07,540 --> 00:15:09,850
And so this 21k you know per second,

257
00:15:09,850 --> 00:15:12,520
you know even for single,

258
00:15:13,060 --> 00:15:17,740
for you know write operations with a configuration of 3 servers,

259
00:15:17,740 --> 00:15:18,700
you know is impressive number,

260
00:15:18,820 --> 00:15:24,160
is quite a bit higher than actually the simple [] that we did for lab 3,

261
00:15:24,160 --> 00:15:27,880
lab 3 will never get the, will not get closer to the number at all.

262
00:15:28,570 --> 00:15:31,180
And so we want to understand,

263
00:15:31,390 --> 00:15:33,700
you want to see in this design,

264
00:15:33,730 --> 00:15:36,910
what the designer do to actually get that kind of performance.

265
00:15:41,950 --> 00:15:43,600
And sort of two as I mentioned earlier,

266
00:15:43,600 --> 00:15:45,820
there's sort of two key ideas,

267
00:15:45,820 --> 00:15:48,010
1, everything is asynchronous,

268
00:15:48,040 --> 00:15:56,270
or the clients can submit many operations to raft or zookeeper, sorry, in a single shot,

269
00:15:56,750 --> 00:15:58,010
so they all pipeline,

270
00:15:58,010 --> 00:16:02,090
so basically when, the way to think about zookeeper client,

271
00:16:02,090 --> 00:16:05,150
basically says, please start executing this put

272
00:16:05,150 --> 00:16:08,360
and doesn't wait in the response of the put,

273
00:16:08,390 --> 00:16:10,760
you know immediately issues the second put,

274
00:16:10,760 --> 00:16:12,230
and then the third and fourth [and fifth],

275
00:16:12,750 --> 00:16:15,660
so, for example, a lot of these puts run will be batched together,

276
00:16:15,660 --> 00:16:19,650
maybe even a single message will be transferred to the leader,

277
00:16:19,650 --> 00:16:22,230
and the leader will apply them all at the same time,

278
00:16:22,500 --> 00:16:26,670
in fact, will leader will write to the persistent storage only once,

279
00:16:26,670 --> 00:16:28,380
you know for a whole batch of operation,

280
00:16:28,380 --> 00:16:31,530
so instead of having one write per operation,

281
00:16:31,560 --> 00:16:34,950
you're going to have one disk write to many many many operations,

282
00:16:35,190 --> 00:16:36,420
and this is one reason,

283
00:16:36,420 --> 00:16:41,160
you know they get this very good performance on write operations.

284
00:16:41,710 --> 00:16:43,720
And the second thing is,

285
00:16:43,900 --> 00:16:47,470
they do something special for read operations,

286
00:16:47,530 --> 00:16:52,590
they allow read operations to be processed by any server.

287
00:16:57,200 --> 00:16:59,600
So instead of running all the operations through the leader,

288
00:16:59,990 --> 00:17:04,730
they allow operations to actually be processed by any server.

289
00:17:06,060 --> 00:17:06,840
So.

290
00:17:07,840 --> 00:17:11,560
And then the [] we want to talk a little bit more about it.

291
00:17:11,800 --> 00:17:15,130
I think, I wanted to think about what could we do something similar,

292
00:17:15,130 --> 00:17:16,870
like, let's say we want to lab 3,

293
00:17:20,570 --> 00:17:22,700
and we're gonna do the same trick,

294
00:17:22,700 --> 00:17:24,530
here we want to look at is

295
00:17:24,560 --> 00:17:32,840
basically reads from any machine or any peer.

296
00:17:36,760 --> 00:17:38,680
So the picture would be as follows,

297
00:17:38,680 --> 00:17:39,730
you know we have a leader,

298
00:17:40,750 --> 00:17:42,310
we have the two followers,

299
00:17:42,910 --> 00:17:45,070
we just stick to the case of three,

300
00:17:46,950 --> 00:17:48,240
we have a client.

301
00:17:49,980 --> 00:17:54,330
And we're like consider what actually could happen,

302
00:17:55,110 --> 00:17:58,020
if you know we sort of, if we follow this strategy,

303
00:17:58,020 --> 00:17:59,340
where we're going to read from anything,

304
00:17:59,340 --> 00:18:00,270
we use our client,

305
00:18:01,310 --> 00:18:03,260
the leaders actually when we do puts,

306
00:18:03,260 --> 00:18:05,030
you know they all go through the leader,

307
00:18:06,150 --> 00:18:08,250
and so the client you know basically does read,

308
00:18:08,610 --> 00:18:11,580
and let's say you know this was a put done,

309
00:18:12,310 --> 00:18:15,610
and at the same time, roughly after after the put was done,

310
00:18:15,610 --> 00:18:17,470
the client issues a get,

311
00:18:18,510 --> 00:18:21,300
and talks to one of the followers an arbitrary one,

312
00:18:21,300 --> 00:18:24,000
let's use this in case, it does not talk to the leader,

313
00:18:24,210 --> 00:18:28,770
and then you know where the follower response,

314
00:18:29,040 --> 00:18:32,910
and the question is like what value does the get to observe.

315
00:18:35,320 --> 00:18:38,050
So what are the possible values you know that the client can observe,

316
00:18:38,080 --> 00:18:42,010
let's say that you know we're reading whatever the key x,

317
00:18:42,010 --> 00:18:44,410
and the initial value of x is 0,

318
00:18:44,590 --> 00:18:46,780
and this put actually put x to 1.

319
00:18:48,240 --> 00:18:51,120
And what are the value that x actually return,

320
00:18:51,150 --> 00:18:53,100
if we don't do anything particularly special.

321
00:18:56,520 --> 00:18:58,110
So just a question here about the setup,

322
00:18:58,110 --> 00:19:01,560
so if we're assuming that raft is the infrastructure here,

323
00:19:01,620 --> 00:19:03,300
and get its just another command,

324
00:19:03,420 --> 00:19:06,990
then would the follower just redirect applying to the leader,

325
00:19:07,020 --> 00:19:12,420
put or get request to the leader.

326
00:19:12,420 --> 00:19:13,440
No, [] a lot of things we could do,

327
00:19:13,440 --> 00:19:16,350
but like we want to get this [perfect] scalability,

328
00:19:16,850 --> 00:19:18,530
so to get perfect scalability,

329
00:19:18,770 --> 00:19:22,130
the follower cannot talk to the leader for read operations,

330
00:19:22,130 --> 00:19:27,740
so basically read operations are executed by the individual followers immediately,

331
00:19:27,890 --> 00:19:28,910
with that no communication,

332
00:19:29,060 --> 00:19:31,160
with that you know the way we're going to get perfect scalability.

333
00:19:31,340 --> 00:19:33,230
So, there not even communicating with.

334
00:19:34,490 --> 00:19:36,410
Yep, I'm just doing beneath plan,

335
00:19:36,410 --> 00:19:38,540
looks like our goal is to get perfect scalability,

336
00:19:38,810 --> 00:19:40,310
like you know zookeeper does,

337
00:19:40,610 --> 00:19:43,190
and we want to understand like you know is that difficult or easy,

338
00:19:43,400 --> 00:19:44,780
or what does that really mean,

339
00:19:44,960 --> 00:19:46,790
and so the first thing to find experiment is,

340
00:19:46,790 --> 00:19:49,760
like would do absolutely nothing at the leaders and followers,

341
00:19:50,060 --> 00:19:53,390
followers get read operation executed and return the value.

342
00:19:55,060 --> 00:19:55,870
And what can you know,

343
00:19:55,870 --> 00:19:56,620
so another question,

344
00:19:56,620 --> 00:20:01,810
what values can be returned by, in the client observe, in this picture.

345
00:20:01,930 --> 00:20:02,950
Can be either,

346
00:20:02,950 --> 00:20:04,750
because maybe you put,

347
00:20:04,840 --> 00:20:07,900
then they make it through the disk of the leader yet.

348
00:20:08,110 --> 00:20:09,340
Yeah, it could be either,

349
00:20:09,340 --> 00:20:13,060
so either going to return 0 or it could return 1, right.

350
00:20:14,180 --> 00:20:18,080
So it can return stale data, it's possibility.

351
00:20:19,330 --> 00:20:22,270
Let's say, let's say we do,

352
00:20:22,300 --> 00:20:24,250
let's say return 1,

353
00:20:25,270 --> 00:20:28,540
so this get returns 1 for a [] experiment,

354
00:20:28,540 --> 00:20:30,880
and then the client does another get,

355
00:20:33,680 --> 00:20:35,930
now going to say to where that get is going,

356
00:20:36,380 --> 00:20:43,530
but you know and what values could we see,

357
00:20:44,750 --> 00:20:45,920
for respond to that get.

358
00:20:46,840 --> 00:20:49,510
Assuming there are no other writes that should be 1, right.

359
00:20:50,820 --> 00:20:51,780
Yeah, [unfortunately],

360
00:20:51,810 --> 00:20:53,730
because I have 3 servers,

361
00:20:53,850 --> 00:20:55,110
if I have 5 servers?

362
00:21:00,660 --> 00:21:03,570
Why is it different?

363
00:21:03,600 --> 00:21:05,460
Okay, let's make it different.

364
00:21:07,200 --> 00:21:11,010
So certainly can return 1, we're agreeing that,

365
00:21:11,250 --> 00:21:14,760
because if the follower talks to the second get request,

366
00:21:14,760 --> 00:21:20,970
you know talks to a follower that actually has seen the put operation,

367
00:21:21,150 --> 00:21:23,280
which the majority of them have seen put operation,

368
00:21:23,280 --> 00:21:24,780
we're going to get 1 back, right.

369
00:21:25,920 --> 00:21:28,500
The real question is, could it see 0,

370
00:21:31,670 --> 00:21:33,650
even though it observed the 1 earlier.

371
00:21:34,930 --> 00:21:36,370
I mean you could see that 0,

372
00:21:36,370 --> 00:21:38,470
even in the case of a 3 servers, right,

373
00:21:38,470 --> 00:21:41,260
because let's say that you have the majority of servers.

374
00:21:41,260 --> 00:21:43,990
Let me do first 5 case, because it's simpler to see.

375
00:21:46,750 --> 00:21:51,280
Are we assuming that the client always asks the same peer?

376
00:21:51,550 --> 00:21:56,320
No, there might be a little network partition or disconnection for a brief period of time,

377
00:21:56,320 --> 00:21:59,440
so you don't actually have to talk to the same peer as the last time, right.

378
00:22:00,070 --> 00:22:03,700
Yeah, so in that case, it can talk to a different peer,

379
00:22:03,700 --> 00:22:08,500
who and that peer may respond with 0, that's.

380
00:22:08,500 --> 00:22:09,490
So, this is possible,

381
00:22:09,910 --> 00:22:12,670
so we're gonna have sort of strange behavior,

382
00:22:12,670 --> 00:22:16,000
in this configuration where you might see a recent,

383
00:22:16,030 --> 00:22:17,380
you know in the first case,

384
00:22:17,380 --> 00:22:18,940
we might see actually a recent value,

385
00:22:19,030 --> 00:22:22,030
and then we read actually something from back back in time.

386
00:22:28,090 --> 00:22:28,900
Yep.

387
00:22:30,080 --> 00:22:32,030
So we're doing nothing special,

388
00:22:32,180 --> 00:22:35,510
and just like naively read from any peer,

389
00:22:35,510 --> 00:22:37,610
and you know we have sort of two side [types] of problems

390
00:22:37,610 --> 00:22:40,040
I mean the get can return stale data,

391
00:22:40,460 --> 00:22:43,550
the get return data you've gone back in time.

392
00:22:44,840 --> 00:22:45,590
And so.

393
00:22:46,290 --> 00:22:49,890
Sorry, wasn't this possible also with 3 followers,

394
00:22:49,890 --> 00:22:52,380
because the majority was the leader and one follower

395
00:22:52,380 --> 00:22:53,820
and you could ask the other one.

396
00:22:55,520 --> 00:22:57,230
If you've seen the one in,

397
00:22:57,230 --> 00:23:00,650
yes, it could be possible, absolutely,

398
00:23:00,710 --> 00:23:02,150
the 3 will be possible too,

399
00:23:02,150 --> 00:23:03,590
I think the 5 is much more clear,

400
00:23:03,590 --> 00:23:04,490
that this is possible.

401
00:23:09,520 --> 00:23:10,570
Okay, so.

402
00:23:12,660 --> 00:23:13,980
So, now we're going to go back

403
00:23:13,980 --> 00:23:16,140
and sort of think about a little bit of this behavior,

404
00:23:16,260 --> 00:23:19,500
you know the returning those values, is that okay?

405
00:23:20,170 --> 00:23:22,300
And this is a very interesting question,

406
00:23:22,330 --> 00:23:24,820
and it depends of course, what do you mean with correct.

407
00:23:25,740 --> 00:23:28,380
And what you know if something's okay,

408
00:23:28,380 --> 00:23:30,330
depends on what our correct definition is.

409
00:23:31,050 --> 00:23:33,990
And the correctness definition that we sort of in peddling

410
00:23:33,990 --> 00:23:37,230
for the last couple lectures at the beginning of term,

411
00:23:37,230 --> 00:23:39,300
is this notion of linearizability.

412
00:23:45,760 --> 00:23:48,610
And, in roughly what that means,

413
00:23:49,110 --> 00:23:52,590
I talked a little bit about it in a week ago,

414
00:23:52,680 --> 00:23:54,780
you know behaves like a single machine,

415
00:23:57,460 --> 00:24:01,750
that's the intuition that we've been using since the beginning of the semester,

416
00:24:02,920 --> 00:24:06,790
but you know the definition of linearizability is a little bit more precise,

417
00:24:07,000 --> 00:24:10,960
sort of tries to nail down what it means to behave like a single machine,

418
00:24:10,990 --> 00:24:13,480
and so when something behaves like a single machine,

419
00:24:13,480 --> 00:24:15,130
first of all, it has to be the case,

420
00:24:15,130 --> 00:24:17,350
that even if the operation actually concurrently,

421
00:24:17,380 --> 00:24:19,510
you can sort of order them in a total order,

422
00:24:20,300 --> 00:24:25,010
so it's possible to construct a total order of all the operations,

423
00:24:25,250 --> 00:24:26,900
because in the end, it's a single machine,

424
00:24:26,900 --> 00:24:28,880
so it behaves as a single machine,

425
00:24:28,880 --> 00:24:30,110
there's only one machine,

426
00:24:30,140 --> 00:24:36,380
so virtual machine that can actually perform the operations total order of ops,

427
00:24:37,370 --> 00:24:40,970
and there has to be some properties true about that total order.

428
00:24:41,700 --> 00:24:44,460
And so one property that has to be true is,

429
00:24:44,460 --> 00:24:46,320
that the order matches real-time,

430
00:24:51,950 --> 00:24:54,140
and the real-time really what I mean is that,

431
00:24:54,140 --> 00:24:57,140
if operation completed before another one started,

432
00:24:58,930 --> 00:25:04,090
then you know that first operation has to go before the second operation in the total order.

433
00:25:05,870 --> 00:25:07,100
And then there's third property,

434
00:25:07,900 --> 00:25:16,310
that read operation, read op returns value of last write.

435
00:25:23,620 --> 00:25:26,140
That's sort of the official definition of linearizability

436
00:25:26,140 --> 00:25:27,220
and you can just think about this

437
00:25:27,220 --> 00:25:31,030
as sort of more precise definition, more precise statement,

438
00:25:31,030 --> 00:25:32,800
this first thing this intuition,

439
00:25:32,920 --> 00:25:35,470
namely the whole thing behaves like a single machine.

440
00:25:37,370 --> 00:25:38,570
Now we want to go back,

441
00:25:38,690 --> 00:25:42,140
and you know think a little bit about scenario,

442
00:25:42,140 --> 00:25:44,600
that we [] have just on this whiteboard,

443
00:25:44,630 --> 00:25:47,870
namely use two cases of stale data and back in time,

444
00:25:48,080 --> 00:25:53,190
and think about that think whether linearizability allows them.

445
00:25:53,400 --> 00:25:56,250
And so let's first focus on the first one,

446
00:25:56,430 --> 00:25:58,410
so we have a client 1, correct, for this,

447
00:25:58,410 --> 00:26:00,450
the way you would draw this out,

448
00:26:00,450 --> 00:26:02,100
and reasonable linearizability is,

449
00:26:02,100 --> 00:26:04,020
you could draw a diagram for this form,

450
00:26:04,350 --> 00:26:07,290
where going to the left bar is the start of the operation,

451
00:26:07,290 --> 00:26:11,250
the right bar is acknowledgement to the client that the operation actually executed,

452
00:26:11,640 --> 00:26:12,420
and in this case,

453
00:26:12,420 --> 00:26:17,370
you know we sort of saying were to put to x and put the value of 1.

454
00:26:18,170 --> 00:26:21,560
Then we had another client or in the same client,

455
00:26:22,040 --> 00:26:23,690
let's do drawing other client,

456
00:26:23,690 --> 00:26:25,010
you know basically did the read,

457
00:26:25,040 --> 00:26:30,080
and the read started well past the put operations,

458
00:26:30,080 --> 00:26:31,700
there's a get of x,

459
00:26:32,220 --> 00:26:35,880
and we had one case, where the get that's actually return the 0,

460
00:26:35,910 --> 00:26:38,040
that was the first possibility.

461
00:26:39,820 --> 00:26:43,180
And so that's what actually happened on the previous board,

462
00:26:43,180 --> 00:26:44,620
and now we want to think about this,

463
00:26:44,620 --> 00:26:47,650
is this execution allowed by linearizability,

464
00:26:47,740 --> 00:26:50,560
this is the correctness definition that we're looking for,

465
00:26:50,680 --> 00:26:53,170
then we want to see this execution,

466
00:26:53,170 --> 00:26:56,410
this order of operations that happened in practice,

467
00:26:56,410 --> 00:26:58,690
you know at least we've seen that it's possible in practice,

468
00:26:58,690 --> 00:27:00,430
is this allowed by linearizability,

469
00:27:00,430 --> 00:27:01,780
that is our correctness criteria.

470
00:27:03,360 --> 00:27:06,600
Is this allow by linearizability?

471
00:27:11,980 --> 00:27:12,370
No.

472
00:27:12,880 --> 00:27:14,260
No, why not?

473
00:27:14,620 --> 00:27:20,170
Well, because the C2 client operation started after the C1 completed,

474
00:27:20,170 --> 00:27:21,550
so in the total order,

475
00:27:21,550 --> 00:27:23,320
you have that put x 1

476
00:27:23,320 --> 00:27:25,150
and get x has to be 1,

477
00:27:25,150 --> 00:27:26,530
because it should read the last write.

478
00:27:27,070 --> 00:27:29,530
Yeah, so basically in the total order that you construct,

479
00:27:29,890 --> 00:27:30,850
you know this guy,

480
00:27:30,850 --> 00:27:33,670
you know this operation must be after that operation,

481
00:27:34,340 --> 00:27:35,570
because it started later.

482
00:27:36,150 --> 00:27:39,660
But then you look, you know that violated rule number 3, correct,

483
00:27:40,220 --> 00:27:42,500
that operation returns the value of the last write,

484
00:27:42,500 --> 00:27:43,520
that's actually not the case,

485
00:27:43,520 --> 00:27:45,560
actually returns [new] earlier value,

486
00:27:45,590 --> 00:27:47,000
so this is not linearizable.

487
00:27:49,790 --> 00:27:50,630
Does that make sense?

488
00:27:53,060 --> 00:27:55,190
And of course it's totally matches our intuition, right,

489
00:27:55,190 --> 00:27:57,500
because a single machine just could not have happened,

490
00:27:57,560 --> 00:28:00,140
you know you wrote a value to a single machine,

491
00:28:00,140 --> 00:28:01,130
and then you read it back

492
00:28:01,400 --> 00:28:02,690
and it's certainly not other value,

493
00:28:02,690 --> 00:28:03,710
it's actually the previous value,

494
00:28:03,710 --> 00:28:04,610
so this is not allow.

495
00:28:06,220 --> 00:28:08,590
Okay, let's do a second one, like other examples,

496
00:28:08,590 --> 00:28:10,360
so we had a client 1 again,

497
00:28:10,390 --> 00:28:11,260
just put,

498
00:28:12,120 --> 00:28:14,520
draw a little bit more compact,

499
00:28:14,520 --> 00:28:15,960
because I don't have much space.

500
00:28:16,620 --> 00:28:18,690
And you know we do a put,

501
00:28:18,690 --> 00:28:22,740
then we do, there's the read or a get,

502
00:28:23,320 --> 00:28:24,640
get run returns 1,

503
00:28:24,700 --> 00:28:26,620
so we're not in the first case,

504
00:28:26,620 --> 00:28:28,690
but in the second, but another case,

505
00:28:28,930 --> 00:28:32,800
and then, we have to get that returns 0.

506
00:28:35,860 --> 00:28:39,550
And so that's the second sort of case that we looked at, correct,

507
00:28:39,550 --> 00:28:42,880
this picture you know the back in time case.

508
00:28:43,580 --> 00:28:45,470
And again we can ask ourselves the same question,

509
00:28:46,350 --> 00:28:49,170
is it allowed by linearizability?

510
00:28:53,350 --> 00:28:58,750
No, because the read wouldn't be return the value the last write.

511
00:28:58,780 --> 00:29:01,720
Yeah, its pretty straightforward observation, correct,

512
00:29:01,720 --> 00:29:02,950
this is absolutely not the case,

513
00:29:02,950 --> 00:29:04,630
in fact, it's almost similar in the first case,

514
00:29:04,630 --> 00:29:07,540
because these operations have to be in this order,

515
00:29:07,780 --> 00:29:10,840
but you know that could not have happened,

516
00:29:10,840 --> 00:29:13,870
it would violate rule 3, right.

517
00:29:16,120 --> 00:29:20,650
Okay, so you know this gives you an intuition like linearizability means,

518
00:29:20,650 --> 00:29:21,880
how you reason about it,

519
00:29:21,880 --> 00:29:25,120
and basically, if we don't do anything special,

520
00:29:25,300 --> 00:29:27,520
and we do this naive scheme,

521
00:29:27,640 --> 00:29:29,650
if you were implementing lab 3,

522
00:29:29,650 --> 00:29:31,600
and you followed this naive scheme,

523
00:29:31,810 --> 00:29:34,090
then you would not pass the test,

524
00:29:34,090 --> 00:29:37,600
because you know the test assume or the goal in lab 3 is

525
00:29:37,600 --> 00:29:40,000
actually to provide linearizability for put and gets.

526
00:29:40,320 --> 00:29:43,020
And so the scenarios like these ones are just not allowed,

527
00:29:43,050 --> 00:29:46,110
you know your implementation has to be a in a way,

528
00:29:46,110 --> 00:29:48,600
that these results cannot appear.

529
00:29:50,400 --> 00:29:51,150
Does that make sense?

530
00:29:53,150 --> 00:29:57,740
So we're going lab 3 were a shoot for linearizability

531
00:29:58,100 --> 00:30:00,560
and what is one easy way of getting linearizability,

532
00:30:02,680 --> 00:30:06,400
how are we going to sure that puts or gets operation are linearizable.

533
00:30:08,800 --> 00:30:11,530
Well, I mean if you do actually we use one machine,

534
00:30:12,080 --> 00:30:14,000
then it will be linearizable, right.

535
00:30:14,330 --> 00:30:15,950
Yeah, so what's the easy solution,

536
00:30:16,070 --> 00:30:18,710
we run all the reads you know for the leader, right.

537
00:30:19,600 --> 00:30:22,870
So basically the easy solution to get linearizability,

538
00:30:22,870 --> 00:30:24,880
and in fact, that's what we're gonna be doing in lab 3,

539
00:30:25,440 --> 00:30:29,700
in lab 3 what going to be doing is

540
00:30:31,080 --> 00:30:36,410
you know read or get operations get ops go through the log,

541
00:30:37,400 --> 00:30:38,960
go through raft,

542
00:30:42,470 --> 00:30:43,520
and as you observe,

543
00:30:43,520 --> 00:30:46,640
it seems you know if they really go all through one machine,

544
00:30:46,640 --> 00:30:48,980
they might not go for one machine,

545
00:30:49,190 --> 00:30:50,630
leader may change over time,

546
00:30:51,050 --> 00:30:53,540
when we know that the leader is always totally order, correct,

547
00:30:53,540 --> 00:30:54,830
the log is total order,

548
00:30:55,100 --> 00:30:58,190
and so we're going to be able to construct you know a total order,

549
00:30:58,190 --> 00:31:00,980
that actually has the order matches real-time,

550
00:31:00,980 --> 00:31:03,800
and all the reads return values up the last write.

551
00:31:04,340 --> 00:31:07,610
Because this is the raft protocol will guarantee,

552
00:31:07,610 --> 00:31:12,530
that all the entries in log are in a total order, right.

553
00:31:13,320 --> 00:31:15,540
And of course the raft protocol do quite a bit of work

554
00:31:15,540 --> 00:31:16,830
to actually make that all happen,

555
00:31:16,980 --> 00:31:20,460
and despite you know network failures,

556
00:31:20,460 --> 00:31:24,570
despite network splits,

557
00:31:24,690 --> 00:31:27,510
you know the raft protocol will guarantee us,

558
00:31:27,600 --> 00:31:30,810
that basically all the operations happen in a total order.

559
00:31:31,390 --> 00:31:35,170
In fact, the whole replicated state machine approaches are based on this idea, correct,

560
00:31:35,170 --> 00:31:36,880
like all the ops in total order

561
00:31:36,880 --> 00:31:38,890
and applied in the same order all peers,

562
00:31:38,890 --> 00:31:42,760
and as a result, [] looks like a single machine.

563
00:31:43,420 --> 00:31:45,850
And so the easy way to solve this problem is

564
00:31:45,850 --> 00:31:49,270
to run all the reads you know through the leader,

565
00:31:49,720 --> 00:31:51,760
whenever the leader at that particular point of time

566
00:31:51,760 --> 00:31:53,230
and that will give us linearizability.

567
00:31:57,830 --> 00:32:00,080
Let me pause for a second, any questions about this?

568
00:32:02,210 --> 00:32:04,520
Sorry, matches real-time it just means that,

569
00:32:04,520 --> 00:32:07,100
if operation 1 ends before operation 2 starts,

570
00:32:07,130 --> 00:32:08,060
then 1 before 2.

571
00:32:08,560 --> 00:32:12,730
Yeah, yeah, the raft,

572
00:32:12,730 --> 00:32:15,310
you know you will see that this will happen automatically, correct,

573
00:32:15,310 --> 00:32:20,350
because the the if operation actually completely finished,

574
00:32:20,350 --> 00:32:21,490
that must have been the case,

575
00:32:21,490 --> 00:32:24,220
that the leader responded you know back to a client,

576
00:32:24,220 --> 00:32:26,290
and then if the client started operation later

577
00:32:26,410 --> 00:32:28,630
and must end up later in the log at the leader.

578
00:32:30,720 --> 00:32:32,400
So this is going to be a practice is true.

579
00:32:33,500 --> 00:32:36,590
And also, so just double check, maybe reiterate,

580
00:32:36,590 --> 00:32:37,850
so the in lab 3,

581
00:32:37,850 --> 00:32:40,980
all of the client requests gonna be synchronous, []?

582
00:32:40,980 --> 00:32:42,510
Yes it's absolute.

583
00:32:44,830 --> 00:32:45,490
Okay, good,

584
00:32:45,700 --> 00:32:48,550
so you know what [] side of this scheme,

585
00:32:48,550 --> 00:32:50,230
you know we'll go back actually,

586
00:32:50,230 --> 00:32:51,940
if you read the raft paper very carefully,

587
00:32:51,940 --> 00:32:54,280
there's an optimization for read-only operations,

588
00:32:54,640 --> 00:32:59,800
but even that optimization, requires some some communication.

589
00:33:00,530 --> 00:33:02,900
And so like if we just follow this naive,

590
00:33:02,930 --> 00:33:06,770
you know this trick for a plan to actually get linearizability.

591
00:33:07,360 --> 00:33:10,510
You know, does this what does that mean for performance,

592
00:33:10,510 --> 00:33:14,050
you know go back to sort of thinking about contrasting the zookeeper,

593
00:33:20,350 --> 00:33:21,610
you know is for example,

594
00:33:21,610 --> 00:33:24,340
the number of read operations is going to scale with the number of servers?

595
00:33:26,660 --> 00:33:30,410
No, because now everything has to pass through the leader.

596
00:33:30,440 --> 00:33:32,180
Exactly, everything have go through the leader again,

597
00:33:32,180 --> 00:33:33,590
so here we are again,

598
00:33:33,590 --> 00:33:35,120
that's a little bit undesirable, correct.

599
00:33:35,840 --> 00:33:37,520
And so it gives you an instant question is,

600
00:33:37,520 --> 00:33:39,380
like you know how is it possible,

601
00:33:39,380 --> 00:33:42,110
that [when you go to] a zookeeper,

602
00:33:42,110 --> 00:33:43,670
zookeeper gets great performance,

603
00:33:43,700 --> 00:33:46,670
like we see the simple scheme that doesn't really work,

604
00:33:47,550 --> 00:33:49,350
or at least violates linearizability.

605
00:33:50,310 --> 00:33:52,980
And so one, so we want to talk a little bit,

606
00:33:52,980 --> 00:33:56,160
like to understand what was really how did zookeeper get this.

607
00:33:56,910 --> 00:33:59,940
And so the first thing to really realize is,

608
00:33:59,940 --> 00:34:01,380
probably the most important part,

609
00:34:02,040 --> 00:34:06,880
is that zookeeper does not provide the linearizability,

610
00:34:08,350 --> 00:34:10,690
it basically changes the correctness definition.

611
00:34:22,740 --> 00:34:24,990
And so the zookeeper service,

612
00:34:25,200 --> 00:34:27,570
it's not going to behave like a single machine,

613
00:34:27,690 --> 00:34:32,610
you know it's gonna have results that would never happen on a single machine.

614
00:34:33,450 --> 00:34:37,380
So the particular, so what is it, what does it provide.

615
00:34:37,380 --> 00:34:41,190
Well, it does provide linearizable writes,

616
00:34:51,880 --> 00:34:56,710
so all the operations, all the write operation actually you know go through the leader

617
00:34:56,710 --> 00:34:59,200
and you go through the log

618
00:34:59,440 --> 00:35:02,590
and appended to the log every peer in the same order,

619
00:35:02,590 --> 00:35:04,720
and so there going to also be applied in the same order,

620
00:35:04,720 --> 00:35:08,950
so we still have this replicated state machine approach,

621
00:35:08,950 --> 00:35:11,110
where apply all the write operation,

622
00:35:11,110 --> 00:35:17,920
operation change data into in the total order.

623
00:35:18,680 --> 00:35:22,490
But, there's a couple more properties.

624
00:35:23,040 --> 00:35:25,740
So, but it does not provide linearizability for reads,

625
00:35:25,920 --> 00:35:28,980
instead it sort of provides two sort of different property,

626
00:35:29,220 --> 00:35:38,640
which is that all the operations appear in FIFO order, in FIFO client order,

627
00:35:40,440 --> 00:35:42,210
this partly has to do with asynchronous,

628
00:35:42,990 --> 00:35:47,220
you know client may submit multiple requests one by one

629
00:35:47,400 --> 00:35:49,950
without waiting for a response.

630
00:35:50,100 --> 00:35:52,710
And you know zookeeper will guarantee,

631
00:35:52,710 --> 00:35:56,130
if you submit client 1 submitted the request,

632
00:35:56,580 --> 00:35:58,920
and then client 1 submitted another request,

633
00:35:59,040 --> 00:36:02,850
then that second request will appear later,

634
00:36:02,880 --> 00:36:06,990
result will observe the result of the first operation.

635
00:36:08,740 --> 00:36:13,420
And so in particular you know writes goes client order,

636
00:36:23,600 --> 00:36:29,270
and then reads where all the actually is where the interesting properties are,

637
00:36:32,430 --> 00:36:34,560
the reads observe last write,

638
00:36:34,620 --> 00:36:41,910
okay, so reads reads observe last write from same client.

639
00:36:51,050 --> 00:36:52,130
So this sort of makes sense,

640
00:36:52,130 --> 00:36:55,460
you know basically this sort of sense like, you read your own writes,

641
00:36:55,730 --> 00:36:57,170
so if you do the write operation,

642
00:36:57,170 --> 00:36:58,760
you immediately follow the read operation,

643
00:36:58,760 --> 00:37:01,370
you see at least the results of your own writes.

644
00:37:02,380 --> 00:37:06,160
But, for writes from other operations, from other clients,

645
00:37:06,250 --> 00:37:09,340
the zookeeper does not guarantee that property,

646
00:37:09,340 --> 00:37:11,350
instead what it guarantees is that,

647
00:37:11,470 --> 00:37:17,710
the read will observe some prefix of the log.

648
00:37:20,920 --> 00:37:25,660
And so this means right you can actually see stale data,

649
00:37:29,620 --> 00:37:31,840
which may read from a follower

650
00:37:31,870 --> 00:37:34,630
and that follower has a prefix of the log,

651
00:37:34,780 --> 00:37:36,940
but not has the last entries in the log,

652
00:37:36,940 --> 00:37:40,390
because maybe just lag behind a little bit,

653
00:37:40,390 --> 00:37:45,700
and nevertheless that follower is allowed to return a value,

654
00:37:45,850 --> 00:37:50,020
because you know the only thing that's you know zookeeper going to guarantee,

655
00:37:50,020 --> 00:37:53,050
that actually reads observe a prefix log.

656
00:37:54,680 --> 00:37:56,660
So the operations can now go out of order,

657
00:37:56,810 --> 00:37:58,310
you know once they in the log,

658
00:37:58,310 --> 00:37:59,270
and you can sort of,

659
00:37:59,270 --> 00:38:03,680
reads can like read operation out of the log in out of order,

660
00:38:03,710 --> 00:38:05,930
it really has to be a prefix, a prefix of the log.

661
00:38:07,070 --> 00:38:08,600
And then there's a second requirement,

662
00:38:08,840 --> 00:38:11,600
that you cannot do no reads from the past,

663
00:38:18,250 --> 00:38:21,130
and it really means like if you saw some prefix 1,

664
00:38:22,900 --> 00:38:25,600
and then you issue reads some prefix one,

665
00:38:25,600 --> 00:38:27,340
and then you read the second read,

666
00:38:27,700 --> 00:38:31,570
then that second read has to see at least prefix 1 plus more.

667
00:38:34,780 --> 00:38:37,240
It might be no, it might be just prefix 1,

668
00:38:37,300 --> 00:38:38,740
but cannot go back in time,

669
00:38:38,740 --> 00:38:42,670
so it cannot see a shorter prefix than prefix 1.

670
00:38:44,120 --> 00:38:45,470
And so this basically,

671
00:38:45,470 --> 00:38:47,420
so so if we look back at this picture,

672
00:38:49,690 --> 00:38:52,630
the zookeeper will allow this in certain cases,

673
00:38:52,630 --> 00:38:55,510
namely, if the two clients are different,

674
00:38:56,060 --> 00:38:58,630
but it won't allow this,

675
00:38:58,630 --> 00:39:00,820
this you can never have back in time.

676
00:39:01,700 --> 00:39:02,390
Okay?

677
00:39:04,690 --> 00:39:07,210
So I have a question, a conceptual one,

678
00:39:07,270 --> 00:39:09,640
so we have these two consistency guarantees,

679
00:39:09,640 --> 00:39:12,430
the linearizable writes and the FIFO client order,

680
00:39:12,640 --> 00:39:15,100
so if we ignore the second constraint for a second,

681
00:39:15,100 --> 00:39:16,750
and if we only focus on the first one,

682
00:39:17,110 --> 00:39:20,920
does the definition of linearizable writes actually makes sense,

683
00:39:20,920 --> 00:39:22,870
since the definition of linearizability

684
00:39:22,900 --> 00:39:26,320
depends on having a read operation and a write operation.

685
00:39:26,530 --> 00:39:30,430
So you're like hold that thought for a second,

686
00:39:30,460 --> 00:39:35,090
because the way they define linearizable writes

687
00:39:35,090 --> 00:39:36,950
is not basically the writes in a total order,

688
00:39:37,040 --> 00:39:39,440
and but there is a relationship between the read and the write,

689
00:39:39,440 --> 00:39:41,300
so hold the thought for a second, okay,

690
00:39:42,160 --> 00:39:43,180
we'll come back,

691
00:39:43,180 --> 00:39:45,190
we get to that in a in a minute,

692
00:39:45,220 --> 00:39:46,360
like one board,

693
00:39:46,660 --> 00:39:48,880
I want to make one board in between, okay?

694
00:39:50,020 --> 00:39:50,620
Sounds good.

695
00:39:52,180 --> 00:39:54,430
Okay so, just like,

696
00:39:54,430 --> 00:39:56,830
let's look a little bit at

697
00:39:56,830 --> 00:40:00,310
how zookeeper actually provides these guarantees.

698
00:40:00,890 --> 00:40:05,480
And you know sort of get the intuition you know,

699
00:40:06,350 --> 00:40:07,700
how you could implement this,

700
00:40:07,970 --> 00:40:11,240
the paper actually not very explicit about how they implement this,

701
00:40:11,420 --> 00:40:13,970
sort of like I'm gonna give you a roughly best guess.

702
00:40:14,640 --> 00:40:18,510
So, there's a zookeeper client,

703
00:40:21,150 --> 00:40:22,380
it runs on the client machine,

704
00:40:22,500 --> 00:40:25,020
in lab 3, we call this a clerk,

705
00:40:25,050 --> 00:40:26,760
and so this is a piece of software library

706
00:40:26,760 --> 00:40:29,280
sort of works collaborates with the service.

707
00:40:30,360 --> 00:40:33,750
In in zookeeper in the paper terminology,

708
00:40:33,750 --> 00:40:35,610
basically it is the thing that has session,

709
00:40:36,030 --> 00:40:37,710
so when you join,

710
00:40:37,710 --> 00:40:39,990
when a client wants to connect the zookeeper service,

711
00:40:39,990 --> 00:40:41,010
you know it creates a session,

712
00:40:41,010 --> 00:40:44,460
it connects using the session information to the leader

713
00:40:44,460 --> 00:40:47,190
and maintains you know state across the session.

714
00:40:48,050 --> 00:40:51,410
So we have a leader in zookeeper,

715
00:40:51,410 --> 00:40:53,570
and we'll see you know followers,

716
00:40:53,570 --> 00:40:55,580
you know basically this is all sort of similar,

717
00:40:56,100 --> 00:40:58,920
to what we're used to from lab 2,

718
00:40:59,250 --> 00:41:03,150
and the zookeeper client issues write you know to the leader,

719
00:41:03,180 --> 00:41:05,520
because the writes are going to be linearizable,

720
00:41:05,520 --> 00:41:07,260
in fact the writes basically follow

721
00:41:07,260 --> 00:41:11,190
exactly sort of roughly the same strategy as in the raft library,

722
00:41:11,190 --> 00:41:12,870
so, it's going to be a log,

723
00:41:13,110 --> 00:41:14,760
and in the log,

724
00:41:14,760 --> 00:41:17,970
all the writes are entered you know whatever you know some slots,

725
00:41:18,000 --> 00:41:23,370
let's say the leader appends this write here in this particular index,

726
00:41:23,790 --> 00:41:25,440
so this has an index,

727
00:41:25,530 --> 00:41:29,880
and in the paper, they refer to this index as zxid,

728
00:41:31,260 --> 00:41:35,220
so I think you can think about the zxid basically as the index in the log.

729
00:41:36,760 --> 00:41:40,570
And when the leader basically commits,

730
00:41:40,630 --> 00:41:44,200
an entry writes you know to the log,

731
00:41:44,200 --> 00:41:47,230
it returns the zxid back to the client,

732
00:41:47,530 --> 00:41:49,240
so the client maintains that state,

733
00:41:50,550 --> 00:41:56,580
so associated with the session is basically with zxids zxid at last write.

734
00:41:59,540 --> 00:42:00,260
Okay?

735
00:42:02,060 --> 00:42:05,390
And so when the client later on the read,

736
00:42:06,200 --> 00:42:08,120
and the read it doesn't have to go to the leader,

737
00:42:08,120 --> 00:42:10,310
because that's the whole goal to get more performance,

738
00:42:10,310 --> 00:42:14,660
so maybe the read actually will go you know to one of the followers,

739
00:42:16,180 --> 00:42:20,380
and but then the read will be tagged with the zxid

740
00:42:20,380 --> 00:42:23,320
that of the last write that particular client is done.

741
00:42:24,930 --> 00:42:26,520
And so what does that mean,

742
00:42:26,520 --> 00:42:28,830
well, let's say this following behind, right,

743
00:42:28,830 --> 00:42:31,230
and it has two entries,

744
00:42:31,230 --> 00:42:33,660
but hasn't actually observed you know the write yet,

745
00:42:33,660 --> 00:42:36,420
because whatever the leader may be committed it through these other followers.

746
00:42:37,560 --> 00:42:39,210
And what happens in this case is that,

747
00:42:39,300 --> 00:42:43,350
this read the follower won't really respond immediately,

748
00:42:43,350 --> 00:42:48,480
instead it will wait until the same you know the zxid,

749
00:42:49,660 --> 00:42:51,400
and as soon as we've seen the zxid,

750
00:42:51,400 --> 00:42:52,630
it actually will respond.

751
00:42:56,620 --> 00:42:58,390
Of course there's gonna be another client,

752
00:42:59,050 --> 00:43:02,380
and so maybe at some point this write will come through,

753
00:43:02,920 --> 00:43:07,900
and maybe now the read the client does another read,

754
00:43:07,960 --> 00:43:11,110
and so it hasn't seen you know other zxids,

755
00:43:11,530 --> 00:43:14,590
and maybe like let me make one more follower,

756
00:43:15,430 --> 00:43:16,960
let's say there's yet another follower,

757
00:43:16,960 --> 00:43:20,590
that actually has not observed you know that that final write yet.

758
00:43:21,340 --> 00:43:21,910
Let me.

759
00:43:22,870 --> 00:43:24,220
So there's going to be another,

760
00:43:24,220 --> 00:43:26,140
let's say there's another client,

761
00:43:26,170 --> 00:43:27,640
that sticks in some other write,

762
00:43:27,850 --> 00:43:29,440
that's the scenario I want to talk about,

763
00:43:29,560 --> 00:43:33,880
there was another client that actually appended w after the cxid,

764
00:43:33,880 --> 00:43:36,280
you know it is right here,

765
00:43:36,280 --> 00:43:38,320
but it was not observed that particularly write,

766
00:43:38,320 --> 00:43:39,730
you know what we have here,

767
00:43:40,140 --> 00:43:46,980
is we got the, we got two slots,

768
00:43:46,980 --> 00:43:47,790
we got to write,

769
00:43:47,790 --> 00:43:51,870
but you know the green write hasn't really show up at particular follower,

770
00:43:52,170 --> 00:43:55,050
so if the client now issues second read,

771
00:43:55,050 --> 00:43:56,730
maybe that goes to the other follower,

772
00:43:57,350 --> 00:43:59,060
you know that's the same zxid,

773
00:43:59,060 --> 00:44:01,010
because it hasn't seen any new,

774
00:44:01,070 --> 00:44:03,620
that client has not issued any new writes,

775
00:44:04,100 --> 00:44:05,150
it will arrive there,

776
00:44:05,180 --> 00:44:09,500
and that guy is allowed to respond immediately,

777
00:44:10,600 --> 00:44:15,520
because it has seen the zxid of you know the [],

778
00:44:15,520 --> 00:44:18,130
has seen the zxid of that particular client,

779
00:44:18,430 --> 00:44:20,470
of course, it misses some writes,

780
00:44:20,470 --> 00:44:22,030
you know that from other clients,

781
00:44:22,030 --> 00:44:25,150
that are already being processed by some majority of the servers,

782
00:44:25,240 --> 00:44:27,460
but it is not required to return that data

783
00:44:27,670 --> 00:44:28,870
and so it can just return.

784
00:44:29,770 --> 00:44:32,980
And so this might actually return in stale values,

785
00:44:33,640 --> 00:44:38,200
but you know that allow by the definition of the zookeeper correctness guarantees.

786
00:44:39,040 --> 00:44:41,140
Professor, I had a question.

787
00:44:41,170 --> 00:44:41,620
Yeah.

788
00:44:42,010 --> 00:44:46,000
At first, I I thought, I'm not sure, but,

789
00:44:46,520 --> 00:44:51,380
I understood client reads like the session reads were sticky,

790
00:44:51,800 --> 00:44:54,410
so they would like in general go to the same.

791
00:44:54,970 --> 00:45:00,430
Yeah, you know but of course there might be a little bit of,

792
00:45:00,430 --> 00:45:04,450
it might be a quick network partition or anything like it,

793
00:45:04,450 --> 00:45:06,340
and so in between time you know the,

794
00:45:06,760 --> 00:45:08,680
it might have switched to another server.

795
00:45:09,740 --> 00:45:12,320
Okay, and then.

796
00:45:12,320 --> 00:45:15,620
In addition, turns out the zookeeper does actually do some load balancing,

797
00:45:16,370 --> 00:45:19,910
so but but nevertheless it can happen, right.

798
00:45:20,510 --> 00:45:21,080
Right.

799
00:45:21,690 --> 00:45:23,100
The other thing was,

800
00:45:23,100 --> 00:45:29,490
you said write always always go to the leader,

801
00:45:29,920 --> 00:45:34,570
and then the leader responded with zxid,

802
00:45:34,630 --> 00:45:40,420
that does the leader have to like first reach consensus before responding,

803
00:45:41,120 --> 00:45:41,990
or in this.

804
00:45:42,980 --> 00:45:47,120
Okay, yes, I guess so,

805
00:45:47,990 --> 00:45:52,040
you know that's committed, otherwise it is uncommitted, right,

806
00:45:52,040 --> 00:45:54,380
I think the exact protocol,

807
00:45:54,680 --> 00:45:58,010
I'm abstracting away a little bit in the details of the protocol,

808
00:45:58,010 --> 00:46:00,230
I'm just going to sketch how it works.

809
00:46:00,780 --> 00:46:02,310
I believe you're right,

810
00:46:02,310 --> 00:46:04,620
you know that it must return presumably

811
00:46:04,620 --> 00:46:06,750
after you know the entries really committed.

812
00:46:08,310 --> 00:46:10,020
Then, sorry last thing,

813
00:46:10,080 --> 00:46:13,290
you said it always goes to the leader,

814
00:46:13,320 --> 00:46:16,410
but I think the paper described it could go to followers,

815
00:46:16,410 --> 00:46:18,180
so write go to a follower and then be read.

816
00:46:18,300 --> 00:46:20,430
But then ends up to the leader, right,

817
00:46:21,630 --> 00:46:23,010
so it ends it go to the leader.

818
00:46:23,850 --> 00:46:24,780
Thanks.

819
00:46:25,200 --> 00:46:25,590
Yeah.

820
00:46:26,460 --> 00:46:27,510
Just to clarify,

821
00:46:27,510 --> 00:46:29,970
when you say wait for zxid,

822
00:46:30,000 --> 00:46:32,850
like for example the second follower or second,

823
00:46:32,850 --> 00:46:34,200
when we wait for the zxid,

824
00:46:34,200 --> 00:46:36,030
we're actually waiting for it to be committed,

825
00:46:36,210 --> 00:46:38,490
it's not sufficient to just get.

826
00:46:38,490 --> 00:46:39,780
It must be committed, yeah.

827
00:46:40,340 --> 00:46:40,760
Got it.

828
00:46:42,960 --> 00:46:44,910
Wait, but would like,

829
00:46:45,240 --> 00:46:47,880
it would have been committed by the time it was,

830
00:46:47,910 --> 00:46:52,500
like a client wouldn't get an uncommitted zxid, right,

831
00:46:52,740 --> 00:46:53,640
like ever, like.

832
00:46:53,640 --> 00:46:55,620
Oh, yeah, but just that's correct,

833
00:46:55,980 --> 00:46:59,310
so if you know the this point,

834
00:47:01,260 --> 00:47:04,470
at this point, the follower sees zxid,

835
00:47:04,470 --> 00:47:07,380
and the write is in that particular zxid,

836
00:47:07,410 --> 00:47:08,760
now it must have been committed,

837
00:47:08,760 --> 00:47:11,340
because you know the client could not have gotten that zxid

838
00:47:11,340 --> 00:47:14,280
unless you know that that zxid was committed.

839
00:47:17,350 --> 00:47:17,800
Thanks.

840
00:47:18,760 --> 00:47:24,940
Also, so when you say that from the read you you get stale data,

841
00:47:24,940 --> 00:47:27,130
so like the last basic arrow,

842
00:47:27,370 --> 00:47:30,220
but the client here in the read request,

843
00:47:30,220 --> 00:47:32,380
it supplied these zxid within it,

844
00:47:32,410 --> 00:47:38,560
so it's as if the client knowingly exactly wanted that location in the log,

845
00:47:38,990 --> 00:47:41,540
that had zxid as its index,

846
00:47:41,990 --> 00:47:46,910
so didn't it knowingly just request that prefix that specific prefix of the log?

847
00:47:47,120 --> 00:47:50,480
No, but really says you know what this zxid actually says,

848
00:47:50,480 --> 00:47:54,080
like it's basically counters you know going back in time,

849
00:47:55,320 --> 00:47:58,260
and so the zxid like you know you have,

850
00:47:58,290 --> 00:48:01,050
as a follower, you have to return to your result,

851
00:48:01,080 --> 00:48:05,190
that at least concludes the prefix of the log through zxid,

852
00:48:05,490 --> 00:48:07,680
you might have more, that be fine too,

853
00:48:07,740 --> 00:48:09,180
but at least through zxid,

854
00:48:09,180 --> 00:48:11,820
and this just stops one case where you read back in time.

855
00:48:13,280 --> 00:48:13,670
Okay, awesome, thank you.

856
00:48:16,090 --> 00:48:18,610
Okay, so now you might wonder,

857
00:48:19,680 --> 00:48:22,470
you know, so this clearly does not provide linearizability,

858
00:48:22,470 --> 00:48:24,900
and one reason people are excited about the linearizability is,

859
00:48:24,900 --> 00:48:26,340
because it behaves like a single machine,

860
00:48:26,340 --> 00:48:27,330
so it's easier to program,

861
00:48:27,420 --> 00:48:30,000
you know you do put, you do get,

862
00:48:30,000 --> 00:48:31,080
you roughly know what you're gonna get,

863
00:48:31,610 --> 00:48:33,530
and no pun intended,

864
00:48:33,800 --> 00:48:38,330
but here you certainly have a model of programming model

865
00:48:38,330 --> 00:48:39,770
is different from a single machine,

866
00:48:40,560 --> 00:48:43,770
and so you know how do you program this thing.

867
00:48:44,700 --> 00:48:46,320
And you know it turns out that,

868
00:48:46,320 --> 00:48:47,790
there basically the rules,

869
00:48:47,820 --> 00:48:50,850
you know the correct definition that you know zookeeper has,

870
00:48:51,240 --> 00:48:53,910
are basically you can think of it like,

871
00:48:53,940 --> 00:48:58,950
those good enough to actually do for purpose to do help programming.

872
00:48:59,720 --> 00:49:01,760
And so I want to talk a little bit about that.

873
00:49:12,470 --> 00:49:14,090
So the real point is that,

874
00:49:14,360 --> 00:49:16,010
you know with linearizability,

875
00:49:16,010 --> 00:49:19,010
it's pretty clear that you know that helps programming

876
00:49:19,010 --> 00:49:20,900
and writing intuitive programs,

877
00:49:21,020 --> 00:49:22,580
you think is going to be slightly different,

878
00:49:22,790 --> 00:49:23,930
and we want to understand,

879
00:49:23,930 --> 00:49:26,690
actually if things work out well,

880
00:49:26,690 --> 00:49:29,810
and whether it's like [] in the [] program

881
00:49:29,810 --> 00:49:31,250
is basically completely unusable.

882
00:49:32,280 --> 00:49:37,860
So, so let's look at one of the key examples they talk about in the paper.

883
00:49:38,500 --> 00:49:41,500
And the first thing I want to do is,

884
00:49:41,500 --> 00:49:43,330
basically ignore the sync operation,

885
00:49:43,330 --> 00:49:48,340
because you can make every operation actually linearizable by just issuing sync,

886
00:49:48,840 --> 00:49:50,340
like before you do the read,

887
00:49:50,700 --> 00:49:53,550
but that of course makes everything slow again,

888
00:49:53,550 --> 00:49:54,810
and we're not going to get our performance,

889
00:49:55,050 --> 00:49:58,650
so basically we want to avoid doing syncs,

890
00:49:58,650 --> 00:50:00,150
and so I'm just gonna ignore syncs,

891
00:50:00,150 --> 00:50:02,760
and like program as if we don't have syncs.

892
00:50:04,200 --> 00:50:06,270
So let's look at the following operations,

893
00:50:06,270 --> 00:50:08,220
so here's the write order,

894
00:50:13,220 --> 00:50:14,450
do a couple operations,

895
00:50:14,450 --> 00:50:16,160
and this is the case of the ready file,

896
00:50:16,160 --> 00:50:21,520
so we issue a delete of the ready file,

897
00:50:23,420 --> 00:50:28,760
so, for example, this is a, a new master,

898
00:50:28,760 --> 00:50:34,730
that becomes, becomes the new, the new leader,

899
00:50:34,940 --> 00:50:38,960
and so need to write a configuration information in it,

900
00:50:38,960 --> 00:50:43,940
like you know who were part of the, the replicated state machine,

901
00:50:43,940 --> 00:50:44,990
and who is the leader,

902
00:50:44,990 --> 00:50:47,360
and so it writes you know some configuration files,

903
00:50:47,390 --> 00:50:58,580
write f1, write f2, create of ready,

904
00:51:02,420 --> 00:51:03,980
and then other followers,

905
00:51:04,560 --> 00:51:07,080
might other is the read order,

906
00:51:11,430 --> 00:51:18,830
they can you know for example call if exists ready,

907
00:51:22,650 --> 00:51:24,900
and so zookeeper actually operation exists,

908
00:51:24,900 --> 00:51:28,980
and if ready exists,

909
00:51:28,980 --> 00:51:31,770
then it will be a true,

910
00:51:31,770 --> 00:51:35,130
and otherwise not and so you have to wait,

911
00:51:35,520 --> 00:51:37,560
so let's ignore that case for a second,

912
00:51:37,560 --> 00:51:40,110
let's assume that you know the second clients,

913
00:51:40,110 --> 00:51:43,080
so here was the one for one client did write operations,

914
00:51:43,080 --> 00:51:44,550
second client read operations,

915
00:51:45,000 --> 00:51:46,590
and then if it exists,

916
00:51:46,590 --> 00:51:51,500
then the client reads f1 and then reads f2.

917
00:51:55,200 --> 00:51:59,490
And so the thing that you know we want to understand,

918
00:51:59,490 --> 00:52:03,360
like you know what values could f1 this read actually return.

919
00:52:11,850 --> 00:52:14,100
The thing that we worry about correct is,

920
00:52:14,100 --> 00:52:18,510
it could return could return some result of a write,

921
00:52:18,510 --> 00:52:20,160
that was done much earlier here,

922
00:52:25,750 --> 00:52:27,460
or must have observe this write.

923
00:52:33,230 --> 00:52:34,940
I think the paper mentions that,

924
00:52:34,970 --> 00:52:38,630
the reader can watch certain things

925
00:52:38,630 --> 00:52:41,390
and be notified of changes.

926
00:52:41,810 --> 00:52:43,610
Yeah, so let's assume that actually the file exists,

927
00:52:43,610 --> 00:52:45,410
so created actually succeeds immediately,

928
00:52:45,440 --> 00:52:47,420
so let's talk about the notifications in a second.

929
00:52:49,300 --> 00:52:51,820
So this exists returns immediately,

930
00:52:52,530 --> 00:52:54,810
no watch evolved, it just exists,

931
00:52:55,260 --> 00:52:57,660
and then we do that second client does a read of f1.

932
00:52:59,510 --> 00:53:03,350
I think it should read whatever was written by the first client,

933
00:53:03,350 --> 00:53:05,480
because the operations are in FIFO.

934
00:53:06,250 --> 00:53:08,230
Yeah, right,

935
00:53:08,260 --> 00:53:11,830
so the I think the real thing that actually does.

936
00:53:14,020 --> 00:53:16,000
If we saw this [] what value,

937
00:53:16,000 --> 00:53:17,290
correctly for some write earlier,

938
00:53:17,290 --> 00:53:19,750
that would mean that we're reading back in time, right.

939
00:53:20,600 --> 00:53:22,310
And that is just not allowed,

940
00:53:22,340 --> 00:53:24,470
you know the rules actually forbid that,

941
00:53:25,160 --> 00:53:31,220
this read you know must observe you know this value of that write,

942
00:53:31,220 --> 00:53:35,690
because this read the previous read exists observe this write, right,

943
00:53:35,690 --> 00:53:39,140
so we know that you know this exists [id]

944
00:53:39,140 --> 00:53:42,620
must have seen the zxid corresponding by that create,

945
00:53:43,580 --> 00:53:44,420
and so that means that,

946
00:53:44,420 --> 00:53:52,270
this read will must you know must see the last write,

947
00:53:52,270 --> 00:53:54,010
you know that was performed in the total order,

948
00:53:54,010 --> 00:53:55,960
that proceeded you know that particular create,

949
00:53:55,960 --> 00:53:59,860
and so the last write you know critical order,

950
00:53:59,860 --> 00:54:02,110
before that is this particular write, right,

951
00:54:02,200 --> 00:54:04,060
because all the writes are actually linearizable.

952
00:54:05,280 --> 00:54:06,330
And so it must be the case,

953
00:54:06,330 --> 00:54:09,600
that this read f1 observes the result of the write f1.

954
00:54:10,240 --> 00:54:11,440
So this is nice, correct,

955
00:54:11,440 --> 00:54:15,700
because if you know some new leader became the primary,

956
00:54:15,700 --> 00:54:17,500
get raised configuration file,

957
00:54:17,590 --> 00:54:18,730
you know we know for sure,

958
00:54:18,730 --> 00:54:21,370
that actually we're going to see that last configuration file,

959
00:54:21,370 --> 00:54:23,620
that was created by that by that new leader.

960
00:54:26,020 --> 00:54:27,370
So we see here an example,

961
00:54:27,370 --> 00:54:29,410
that these rules are carefully chosen,

962
00:54:29,770 --> 00:54:31,900
that you know things that you might care about,

963
00:54:31,930 --> 00:54:33,940
if you're writing a configuration servers,

964
00:54:33,940 --> 00:54:35,320
that actually certainly workout.

965
00:54:38,140 --> 00:54:41,680
Sorry, I I might have not understood what you were saying before,

966
00:54:41,680 --> 00:54:44,410
but in this case if it exists,

967
00:54:44,470 --> 00:54:45,940
if checking exists ready,

968
00:54:46,060 --> 00:54:49,720
couldn't read like stuff before ready was deleted?

969
00:54:52,270 --> 00:54:53,770
Okay, all the writes in the total order,

970
00:54:53,800 --> 00:54:54,940
so these writes in total order,

971
00:54:54,940 --> 00:54:56,050
that write is in total order,

972
00:54:56,050 --> 00:54:57,250
that create in total order,

973
00:54:58,150 --> 00:55:01,150
so this read here on the other side has observed that create,

974
00:55:02,020 --> 00:55:03,730
so whatever read is going to do is

975
00:55:03,730 --> 00:55:05,200
go back and in totol order, correct,

976
00:55:05,200 --> 00:55:08,500
like observed the last write in that total order,

977
00:55:08,500 --> 00:55:10,240
and at last write f1 is this one.

978
00:55:10,510 --> 00:55:12,640
But is exists writes?

979
00:55:13,300 --> 00:55:14,230
No, exists is read,

980
00:55:14,260 --> 00:55:16,150
but exists observed this particular write.

981
00:55:16,780 --> 00:55:18,250
Oh, you're saying.

982
00:55:18,250 --> 00:55:20,590
You, you cannot read it back in time, correct,

983
00:55:20,590 --> 00:55:21,760
that just the whole goal.

984
00:55:21,880 --> 00:55:26,440
Right, but how did we know that it observed, that exists.

985
00:55:26,440 --> 00:55:27,220
I told you that,

986
00:55:27,250 --> 00:55:28,780
I said like the file existed,

987
00:55:28,780 --> 00:55:30,520
so it must be the case that it observed it,

988
00:55:31,520 --> 00:55:32,750
exists is return true.

989
00:55:32,990 --> 00:55:35,690
But it, but it existed before you deleted it, right.

990
00:55:37,720 --> 00:55:38,560
Yeah yeah yeah yeah,

991
00:55:38,560 --> 00:55:41,320
but you know okay, we'll go back in a second,

992
00:55:41,320 --> 00:55:42,760
let me, okay this is the second case,

993
00:55:42,760 --> 00:55:43,600
this is a good point,

994
00:55:43,600 --> 00:55:45,370
let me a talk about that,

995
00:55:45,370 --> 00:55:47,380
so there's another scenario,

996
00:55:47,380 --> 00:55:49,720
and I think this is the one you're worrying about that could have happened,

997
00:55:50,050 --> 00:55:51,760
and this is where notifications come in.

998
00:55:52,900 --> 00:55:55,780
So at least agree that this is right, correct.

999
00:55:56,340 --> 00:55:59,740
So the second case, more rules

1000
00:56:01,570 --> 00:56:02,950
and this is indeed interesting.

1001
00:56:04,450 --> 00:56:06,520
I think the case where you're worried about is,

1002
00:56:07,100 --> 00:56:09,170
here's our reader again,

1003
00:56:09,260 --> 00:56:10,490
here's our writer again,

1004
00:56:10,940 --> 00:56:16,430
and the reader you know calls exists on ready,

1005
00:56:18,600 --> 00:56:22,620
unless the file you know is there,

1006
00:56:22,620 --> 00:56:24,750
in you know does read f1.

1007
00:56:26,470 --> 00:56:28,900
Alright, we're almost same as in the previous scenario,

1008
00:56:29,410 --> 00:56:32,200
and now like you know there's some changing leadership,

1009
00:56:32,200 --> 00:56:36,310
you know there's a there's a crash, you know recovery,

1010
00:56:36,310 --> 00:56:37,600
and all that kind of stuff is happening,

1011
00:56:37,900 --> 00:56:40,540
and so there's a new primary,

1012
00:56:40,990 --> 00:56:42,970
it deletes ready,

1013
00:56:46,170 --> 00:56:52,640
you know write f1, and write f2,

1014
00:56:54,520 --> 00:57:02,260
and it's might create ready like as before.

1015
00:57:05,440 --> 00:57:08,170
And let's assume that this like this read a little bit delayed,

1016
00:57:08,200 --> 00:57:10,060
and you know something else happened on the machine,

1017
00:57:10,770 --> 00:57:12,990
and you know now does the read f2.

1018
00:57:15,480 --> 00:57:17,910
And I think this is a very the question you were asking about,

1019
00:57:17,910 --> 00:57:19,380
because this is the [] something, right,

1020
00:57:19,620 --> 00:57:23,040
because now there's a configuration change,

1021
00:57:23,250 --> 00:57:26,940
and if this configuration change gets flooded in the middle here, right,

1022
00:57:27,060 --> 00:57:31,860
this read of f2 is going to return the new configuration,

1023
00:57:31,860 --> 00:57:35,310
as opposed to the read of f1 that is going to return the old configuration,

1024
00:57:35,370 --> 00:57:37,440
and clearly things are gonna be messed up,

1025
00:57:38,200 --> 00:57:40,510
that's not a scenario we want to be in,

1026
00:57:40,510 --> 00:57:41,770
so we terrible outcome.

1027
00:57:42,870 --> 00:57:46,920
So and how does that actually you know get rectified,

1028
00:57:46,920 --> 00:57:49,320
or how this actually zookeeper deal with this.

1029
00:57:49,320 --> 00:57:51,900
Well, this is where the watch come in,

1030
00:57:52,320 --> 00:57:56,310
you know the pictures I drew in the previously board is not completely correct,

1031
00:57:56,340 --> 00:58:00,090
in addition to calling exists with the ready

1032
00:58:00,090 --> 00:58:01,710
is going to say watch to true.

1033
00:58:08,370 --> 00:58:12,240
And what that means is that,

1034
00:58:12,240 --> 00:58:16,790
this delete you know change is the ready file,

1035
00:58:16,790 --> 00:58:19,130
and we have now set a watch on the ready file,

1036
00:58:19,610 --> 00:58:25,760
and so when the ready file gets deleted by this new primary,

1037
00:58:25,790 --> 00:58:27,530
that actually results in a notification.

1038
00:58:34,780 --> 00:58:36,580
And there's a rule for this notification,

1039
00:58:37,000 --> 00:58:38,890
and the rule for the notification is that,

1040
00:58:38,890 --> 00:58:45,040
every notification will be delivered before you know writes that go after it.

1041
00:58:46,320 --> 00:58:48,060
And so what has to be the case,

1042
00:58:48,060 --> 00:58:54,690
that you know the this notification will be delivered before the write to f1.

1043
00:58:56,320 --> 00:58:58,570
So when, so there's two possible scenarios,

1044
00:58:58,570 --> 00:59:00,520
if the notification gets delivered here,

1045
00:59:02,130 --> 00:59:05,460
or the notification gets delivered like after the read of f2.

1046
00:59:06,420 --> 00:59:08,820
Let me move that read of f2 slightly up,

1047
00:59:12,310 --> 00:59:13,390
or yeah,

1048
00:59:13,930 --> 00:59:14,860
so it's still happening,

1049
00:59:14,860 --> 00:59:18,010
so in time behind you know the write operation,

1050
00:59:18,310 --> 00:59:21,580
but notification gets [] delivered here depending on the delays

1051
00:59:21,760 --> 00:59:23,200
or it's going to delivered here.

1052
00:59:23,930 --> 00:59:28,280
Sorry, what's the exact wording of that rule that allows this to happen?

1053
00:59:30,260 --> 00:59:32,900
Basically, I think one way to think about it,

1054
00:59:32,900 --> 00:59:35,270
the notification is like it was always like a write operation,

1055
00:59:36,200 --> 00:59:38,630
and the followers you know implemented,

1056
00:59:38,720 --> 00:59:44,300
so that the if the change happens to delete the notification goes off,

1057
00:59:44,300 --> 00:59:47,840
that notification is delivered to the client with that zxid.

1058
00:59:51,010 --> 00:59:54,220
Yeah, but I still don't understand why this guarantees,

1059
00:59:54,220 --> 01:00:00,270
that it can go like before,

1060
01:00:00,850 --> 01:00:03,280
wait, so the valid places for it are,

1061
01:00:03,310 --> 01:00:10,720
before the write of f1 and also like after the write of f2, right?

1062
01:00:11,340 --> 01:00:15,720
The notification is delivered after the after the delete of ready,

1063
01:00:16,260 --> 01:00:17,610
and before the writes,

1064
01:00:17,610 --> 01:00:19,770
before the writes of f1 and f2 are [],

1065
01:00:20,340 --> 01:00:22,260
or [in] the create for that matter.

1066
01:00:23,540 --> 01:00:24,260
Oh, I see.

1067
01:00:30,230 --> 01:00:32,870
That's just a rule, zookeeper has to guarantee that.

1068
01:00:33,480 --> 01:00:34,230
Okay.

1069
01:00:34,800 --> 01:00:37,140
Okay, so so that means there's two cases, correct,

1070
01:00:37,140 --> 01:00:38,730
like the notification gets delivered,

1071
01:00:38,730 --> 01:00:41,220
before the read of f1 or after the read of f1.

1072
01:00:42,560 --> 01:00:46,790
If we deliver, if it gets delivered after the read of f1 of f2,

1073
01:00:47,030 --> 01:00:48,020
is there a problem?

1074
01:00:50,920 --> 01:00:51,400
No.

1075
01:00:51,430 --> 01:00:54,340
No, because then the read just happened before the writes.

1076
01:00:54,610 --> 01:00:55,420
So everything's good,

1077
01:00:55,450 --> 01:00:59,470
so this is this whole block is happening after the read of f2 is perfectly fine,

1078
01:00:59,470 --> 01:01:00,220
and how about here?

1079
01:01:03,270 --> 01:01:08,610
Professor, did you say the watch is like a like write something?

1080
01:01:09,450 --> 01:01:11,640
Well, you can think about it,

1081
01:01:11,640 --> 01:01:13,020
the watch is not a write operation,

1082
01:01:13,020 --> 01:01:14,490
I didn't mean to imply that,

1083
01:01:14,490 --> 01:01:18,420
the write, the watch is executed with the appropriate zxid,

1084
01:01:18,600 --> 01:01:21,420
that's associated with that modification.

1085
01:01:21,940 --> 01:01:23,800
Those are local, right, watches.

1086
01:01:23,800 --> 01:01:25,240
Yeah, the watches are local,

1087
01:01:25,240 --> 01:01:26,410
and so when they're executed,

1088
01:01:26,590 --> 01:01:32,110
the it's guaranteed you know that they happened at the write,

1089
01:01:32,410 --> 01:01:34,000
when the write is observed

1090
01:01:34,300 --> 01:01:35,740
or the client sees that's [],

1091
01:01:35,740 --> 01:01:38,350
the watch propagated with the zxid to the client

1092
01:01:38,350 --> 01:01:39,820
and make sure that execute it.

1093
01:01:41,070 --> 01:01:41,550
Thanks.

1094
01:01:44,200 --> 01:01:47,080
Again, the papers are slightly [vapor], exactly how it's implemented,

1095
01:01:47,110 --> 01:01:48,790
but you can imagine different scenarios,

1096
01:01:50,170 --> 01:01:52,330
but the more important points like these rules guaranteed.

1097
01:01:52,420 --> 01:01:54,940
Okay, so what happens if the notification is delivered here?

1098
01:01:58,140 --> 01:01:59,730
So the client is running, correct,

1099
01:01:59,730 --> 01:02:01,110
you know exists, the read f1

1100
01:02:01,110 --> 01:02:02,640
and now this notification comes in.

1101
01:02:06,020 --> 01:02:07,520
Then you have to restart probably.

1102
01:02:07,520 --> 01:02:08,960
Yeah, you have to restart.

1103
01:02:14,800 --> 01:02:18,800
Okay? So what we see here basically is that,

1104
01:02:18,830 --> 01:02:23,150
you know the rules you know make programming definitely a bit more a difficult,

1105
01:02:23,360 --> 01:02:25,250
but not impossible,

1106
01:02:25,840 --> 01:02:28,930
you know with a little bit careful sort of programming,

1107
01:02:28,930 --> 01:02:31,000
you know you and understand the rules,

1108
01:02:31,000 --> 01:02:33,670
you can actually get the desirable results,

1109
01:02:33,670 --> 01:02:35,620
that actually probably the application wants.

1110
01:02:36,080 --> 01:02:38,150
What happens to the read f1 though?

1111
01:02:39,480 --> 01:02:41,040
What happens to read f1?

1112
01:02:41,220 --> 01:02:42,570
You start over.

1113
01:02:43,110 --> 01:02:44,190
Including that.

1114
01:02:44,250 --> 01:02:44,850
Right.

1115
01:02:47,780 --> 01:02:48,410
Okay?

1116
01:02:50,120 --> 01:02:51,410
And you'll see this is a trick,

1117
01:02:51,410 --> 01:02:53,180
that shows up in those [recipes] quite a bit,

1118
01:02:53,210 --> 01:02:58,640
like this there's an idea of actually you know bailing out and starting over again.

1119
01:02:59,820 --> 01:03:03,870
Okay, so hopefully that gives you a sense that got for two things,

1120
01:03:04,110 --> 01:03:07,230
sort of even though people,

1121
01:03:07,230 --> 01:03:09,300
one reason like people like linearizability is

1122
01:03:09,300 --> 01:03:10,440
because it's very intuitive,

1123
01:03:10,470 --> 01:03:11,790
very easy to program with,

1124
01:03:11,790 --> 01:03:13,350
because everything behaves like a single machine.

1125
01:03:13,800 --> 01:03:16,770
But if you want fault tolerance, scalability,

1126
01:03:16,860 --> 01:03:18,570
it's hard to get actually good performance,

1127
01:03:18,570 --> 01:03:20,520
and so one way to get good performance is

1128
01:03:20,520 --> 01:03:22,830
to compromise on the consistency guarantee,

1129
01:03:23,100 --> 01:03:24,210
and in this case,

1130
01:03:24,210 --> 01:03:26,130
you know compromising linearizability

1131
01:03:26,250 --> 01:03:28,080
and provide some other consistency guarantee,

1132
01:03:28,080 --> 01:03:29,010
and as we can see,

1133
01:03:29,130 --> 01:03:33,930
you know that's complicate the user experience of the programmer experience,

1134
01:03:34,020 --> 01:03:37,500
but, these rules in zookeeper are carefully chosen,

1135
01:03:37,620 --> 01:03:39,690
so still you know things can actually work out,

1136
01:03:41,320 --> 01:03:42,910
it's doable.

1137
01:03:43,650 --> 01:03:46,950
So it is possible to get the write to sort of guarantees.

1138
01:03:48,300 --> 01:03:51,330
So now there's another aspect to this programming model,

1139
01:03:51,360 --> 01:03:52,980
and then I want to talk a little bit about now,

1140
01:03:52,980 --> 01:03:55,440
that is really related to the coordination service part.

1141
01:04:05,830 --> 01:04:10,330
And so examples, you know that you need to,

1142
01:04:10,330 --> 01:04:12,760
you know what does it mean to be a coordination service.

1143
01:04:13,460 --> 01:04:18,650
One good example is probably the VM virtual machine fault tolerance paper

1144
01:04:18,650 --> 01:04:20,420
from a little while ago that we read,

1145
01:04:20,720 --> 01:04:23,570
and that had this test-and-set operation,

1146
01:04:27,520 --> 01:04:29,620
the goal of the you know the test-and-set operation is

1147
01:04:29,620 --> 01:04:31,570
basically make sure that there's no split-brain,

1148
01:04:31,570 --> 01:04:33,310
because basically two clients would run,

1149
01:04:33,700 --> 01:04:36,430
and one would win the test-and-set, the other one wouldn't,

1150
01:04:36,430 --> 01:04:39,040
and as a result, you know the one that won the test-and-set

1151
01:04:39,160 --> 01:04:42,490
could conclude you know that that's going to be the primary.

1152
01:04:43,130 --> 01:04:45,620
And so that is sort of a an example

1153
01:04:45,620 --> 01:04:50,060
of feature that coordination service should be able to provide.

1154
01:04:51,520 --> 01:04:56,290
And I wanna you know just just make a little bit more concrete,

1155
01:04:56,320 --> 01:04:58,990
let's think about with lab 3,

1156
01:04:59,020 --> 01:05:01,030
could you get that with lab 3,

1157
01:05:01,810 --> 01:05:04,690
you know basically sort of test-and-set type thing.

1158
01:05:04,690 --> 01:05:09,780
Well, so let's do a very simple case,

1159
01:05:09,780 --> 01:05:12,690
you know let's say we have,

1160
01:05:12,690 --> 01:05:14,850
here are simple implementation of test-and-set,

1161
01:05:17,400 --> 01:05:20,580
and in lab 3, we only have put and get operations,

1162
01:05:20,580 --> 01:05:22,230
there's no other operations,

1163
01:05:22,230 --> 01:05:23,460
so those are the two operations,

1164
01:05:23,460 --> 01:05:25,020
so like how would you write this,

1165
01:05:25,020 --> 01:05:32,000
you know, maybe you know do a put to a key, let's say master,

1166
01:05:34,760 --> 01:05:36,560
and we put my IP address in it,

1167
01:05:36,920 --> 01:05:38,780
the IP address of the caller

1168
01:05:40,490 --> 01:05:42,110
and then you do get,

1169
01:05:42,290 --> 01:05:50,960
you know and we say if the get on master is equal to my IP address,

1170
01:05:55,520 --> 01:05:59,510
then you know act as master or act as leader.

1171
01:06:02,550 --> 01:06:05,130
Actually, this is our naive implementation,

1172
01:06:05,160 --> 01:06:07,110
you know we don't have many other choices,

1173
01:06:07,110 --> 01:06:09,420
because we put, we only have put and get,

1174
01:06:09,810 --> 01:06:11,190
and this is how we can implement this.

1175
01:06:13,150 --> 01:06:15,130
Will this do the desirable thing?

1176
01:06:23,240 --> 01:06:26,960
Oh, there's no atomicity between the put and the get,

1177
01:06:26,960 --> 01:06:29,030
so maybe something changed.

1178
01:06:29,420 --> 01:06:31,610
Correct, so basically there could be two clients, correct,

1179
01:06:31,610 --> 01:06:34,220
both could execute both put at the same time,

1180
01:06:36,440 --> 01:06:41,270
and, and then observe, you know the,

1181
01:06:41,860 --> 01:06:45,790
in roughly, they could do it at the same time,

1182
01:06:45,790 --> 01:06:47,950
and the interleave correctly involve [actually]

1183
01:06:47,950 --> 01:06:50,800
return gets you know with their particular IP address, right,

1184
01:06:51,190 --> 01:06:53,170
so we can get 2 leaders.

1185
01:06:57,240 --> 01:06:58,560
And of course not what we want,

1186
01:06:58,560 --> 01:07:00,630
so the main point of this,

1187
01:07:00,630 --> 01:07:03,870
for example is basically you just have put and get,

1188
01:07:04,140 --> 01:07:06,720
it's gonna be very hard to actually implement the test-and-set.

1189
01:07:07,580 --> 01:07:10,010
It turns out it's possible, but very complex,

1190
01:07:10,040 --> 01:07:12,980
use bakery algorithm, you can actually probably do it,

1191
01:07:12,980 --> 01:07:14,360
but it's gonna be ridiculous,

1192
01:07:14,360 --> 01:07:15,980
like to do that in a distributed system,

1193
01:07:17,090 --> 01:07:20,000
and so what zookeeper does,

1194
01:07:20,210 --> 01:07:24,410
it just provides some additional help,

1195
01:07:24,710 --> 01:07:27,050
to build the sort of [] primitives,

1196
01:07:27,710 --> 01:07:28,640
we'll see in a second.

1197
01:07:31,120 --> 01:07:33,280
The other thing that presumably what you want to know,

1198
01:07:33,310 --> 01:07:36,460
and lab 3 does not provide any support

1199
01:07:36,460 --> 01:07:39,580
for you sort of configuration services or coordination services,

1200
01:07:39,580 --> 01:07:41,770
that you want to know when somebody goes down,

1201
01:07:42,190 --> 01:07:43,630
for example you want to observe that

1202
01:07:43,630 --> 01:07:44,980
like the leader goes down,

1203
01:07:44,980 --> 01:07:47,620
like some other parties would like to know,

1204
01:07:47,620 --> 01:07:49,060
like is the leader down,

1205
01:07:49,060 --> 01:07:50,830
so that we can choose a new one if it needed to,

1206
01:07:51,810 --> 01:07:56,580
and so at least on the application of the building using a service.

1207
01:07:57,330 --> 01:08:00,390
Okay, so, so there are two things that we really want,

1208
01:08:00,420 --> 01:08:03,720
you know one is you know sort of way of trying to get this atomicity,

1209
01:08:04,780 --> 01:08:07,840
that's what we're looking for in the zookeeper design,

1210
01:08:07,840 --> 01:08:10,930
and then zookeeper design, second we were looking for in zookeeper design is,

1211
01:08:10,930 --> 01:08:15,100
for an application to learn whether some node goes down.

1212
01:08:16,680 --> 01:08:19,620
So let's look at the zookeeper API,

1213
01:08:19,620 --> 01:08:22,740
and really we want to look at is znode API.

1214
01:08:27,360 --> 01:08:28,200
And you'll see again,

1215
01:08:28,200 --> 01:08:29,880
that is actually carefully designed

1216
01:08:29,880 --> 01:08:31,050
to actually make it possible

1217
01:08:31,050 --> 01:08:34,320
to do the things that we're we're looking for.

1218
01:08:34,980 --> 01:08:37,650
Okay, so the way the system is organized is,

1219
01:08:37,650 --> 01:08:39,840
you know there's a tree of znodes,

1220
01:08:40,200 --> 01:08:46,260
typically you know there's like one sort of app1 as a znode,

1221
01:08:46,290 --> 01:08:47,430
that might have some children,

1222
01:08:47,430 --> 01:08:51,720
that correspond to the machines that are part of app1,

1223
01:08:52,190 --> 01:08:56,480
so it's like peer or machine 1, machine 2,

1224
01:08:56,480 --> 01:08:59,180
like maybe IP addresses or DNS names,

1225
01:08:59,540 --> 01:09:00,560
machine 3,

1226
01:09:01,080 --> 01:09:04,110
and they might actually have version numbers associated

1227
01:09:04,710 --> 01:09:06,000
or sequence numbers with them.

1228
01:09:06,330 --> 01:09:09,720
And basically znodes can be of three types,

1229
01:09:10,450 --> 01:09:11,710
one, they can be regular,

1230
01:09:13,030 --> 01:09:15,970
so they're fault tolerance replicated all that kind of stuff.

1231
01:09:16,240 --> 01:09:18,100
And then they could be ephemeral,

1232
01:09:21,220 --> 01:09:25,960
and ephemeral basically means that the node will disappear automatically,

1233
01:09:25,960 --> 01:09:31,750
when the session with that the machine 3 goes away,

1234
01:09:32,380 --> 01:09:34,390
so either because there's a network partition,

1235
01:09:34,390 --> 01:09:37,300
there's no heartbeat more coming in from machine 3,

1236
01:09:37,630 --> 01:09:40,810
but at some point zookeeper decides you know that session is gone,

1237
01:09:41,050 --> 01:09:44,710
and so then it will delete that node automatically,

1238
01:09:46,040 --> 01:09:47,750
and so that's where ephemeral nodes.

1239
01:09:49,400 --> 01:09:52,040
And then there's a third one which is sequential,

1240
01:09:52,930 --> 01:09:54,220
oops, go back,

1241
01:09:54,220 --> 01:09:59,370
to the third one you know type node sequential nodes,

1242
01:09:59,370 --> 01:10:00,420
and that really means that,

1243
01:10:00,420 --> 01:10:03,750
you know that version version number associated with them in their name,

1244
01:10:04,140 --> 01:10:10,080
and and they're created one by one in under particular znode,

1245
01:10:10,170 --> 01:10:15,000
all the children will have a sequence number in their name,

1246
01:10:15,000 --> 01:10:17,370
and the nodes are ordered by the sequence number,

1247
01:10:19,400 --> 01:10:21,200
and so again this might have sequence number 1,

1248
01:10:21,200 --> 01:10:22,400
this might sequence number 2,

1249
01:10:22,400 --> 01:10:23,870
and this might have sequence number 3,

1250
01:10:23,870 --> 01:10:27,080
and the new one gets created will have a sequence number higher than 3.

1251
01:10:29,480 --> 01:10:32,990
Okay, then, there's a API associated with that,

1252
01:10:32,990 --> 01:10:34,490
I want to talk a little bit about,

1253
01:10:34,490 --> 01:10:38,270
there's create which we already mentioned a little bit,

1254
01:10:38,760 --> 01:10:43,140
you know takes a path, it takes some data and flags,

1255
01:10:43,800 --> 01:10:46,740
and the flags correspond to the three cases.

1256
01:10:47,850 --> 01:10:48,960
And then there's delete,

1257
01:10:50,390 --> 01:10:52,850
and in the previous slide effort little bit misleading,

1258
01:10:52,850 --> 01:10:55,850
and delete takes a path before, it also takes a version number.

1259
01:10:57,980 --> 01:11:02,930
And exists takes a path and a watch.

1260
01:11:05,240 --> 01:11:09,000
And then there's a getData primitive,

1261
01:11:09,030 --> 01:11:11,400
takes a path and version number.

1262
01:11:14,290 --> 01:11:16,360
And we'll see that these version numbers are the trick,

1263
01:11:16,420 --> 01:11:18,430
are the key to actually get are atomicity.

1264
01:11:18,700 --> 01:11:24,240
And then setData path data and version number.

1265
01:11:26,130 --> 01:11:28,320
And there's also a call for getChildren

1266
01:11:28,350 --> 01:11:32,220
to get actual the children of a particular znode,

1267
01:11:32,460 --> 01:11:36,370
which takes a path, and I think the watch.

1268
01:11:38,710 --> 01:11:41,530
And there sync basically a call the operation

1269
01:11:41,530 --> 01:11:43,000
to actually ensure that actually,

1270
01:11:43,330 --> 01:11:45,910
so if you really need strong linearizability.

1271
01:11:47,450 --> 01:11:50,150
Okay, so I want to talk a little bit about

1272
01:11:50,150 --> 01:11:53,540
you know why you know this version number handy,

1273
01:11:53,570 --> 01:11:58,430
and so, let's look at a particular example, the simple example,

1274
01:11:58,430 --> 01:12:00,710
I can come up with basically implementing a counter.

1275
01:12:07,090 --> 01:12:10,810
And so the way you would write the,

1276
01:12:11,560 --> 01:12:13,360
if you write you know,

1277
01:12:13,360 --> 01:12:15,760
okay so, let me actually first get the write solution,

1278
01:12:15,760 --> 01:12:18,160
so while you know true,

1279
01:12:19,450 --> 01:12:21,160
you know the way you implement increment,

1280
01:12:21,460 --> 01:12:24,490
so there's the pseudo code for increment of this counter,

1281
01:12:24,670 --> 01:12:32,410
is you do get x,v you know getData of the counter,

1282
01:12:34,720 --> 01:12:37,090
getData count,

1283
01:12:39,160 --> 01:12:48,770
and then if you know setData count,

1284
01:12:50,470 --> 01:12:57,820
that's a sort of x+1 and the version number,

1285
01:12:59,100 --> 01:13:01,680
and if that is the case, then break.

1286
01:13:03,920 --> 01:13:05,990
Okay, so let me quickly go over this,

1287
01:13:06,170 --> 01:13:12,710
so the getData returns the current version number and the value of the key,

1288
01:13:13,280 --> 01:13:15,170
so the key or the path you know,

1289
01:13:15,170 --> 01:13:16,400
so for the file count,

1290
01:13:16,400 --> 01:13:18,950
it returns the value and its version number that particular point,

1291
01:13:18,950 --> 01:13:19,880
when they did read,

1292
01:13:20,480 --> 01:13:23,660
and then you call and setData takes three arguments,

1293
01:13:23,660 --> 01:13:26,180
you know the path, updates the new value,

1294
01:13:26,180 --> 01:13:27,560
in this case it's going to be x+1,

1295
01:13:27,560 --> 01:13:29,690
because we want to increment the value by 1,

1296
01:13:29,930 --> 01:13:32,360
and it actually passes in the version number,

1297
01:13:32,450 --> 01:13:36,360
and the semantics of setData is that,

1298
01:13:36,360 --> 01:13:39,300
if you know the version numbers are still the same,

1299
01:13:40,330 --> 01:13:43,420
then the setData actually happens and otherwise not.

1300
01:13:44,770 --> 01:13:46,510
So what does this protect against?

1301
01:13:49,740 --> 01:13:55,260
This prevents you from interleaving the get-and-set, basically.

1302
01:13:56,400 --> 01:14:00,300
So if like two operate, two clients did get at the same time,

1303
01:14:00,510 --> 01:14:02,220
they would read,

1304
01:14:03,980 --> 01:14:05,660
they do get at the same time,

1305
01:14:06,640 --> 01:14:12,700
they get both back say you know whatever x 0 and version number 0,

1306
01:14:13,090 --> 01:14:15,400
x 0, version number 0,

1307
01:14:16,170 --> 01:14:18,750
then they do both put,

1308
01:14:19,020 --> 01:14:20,550
where like in this case a setData,

1309
01:14:22,400 --> 01:14:28,570
so the setData with you know whatever x is 1, you know version number 0,

1310
01:14:29,260 --> 01:14:30,940
also this guy does the same thing,

1311
01:14:30,970 --> 01:14:34,130
set you know 1 0.

1312
01:14:35,480 --> 01:14:37,130
And you know why

1313
01:14:37,130 --> 01:14:40,670
and so both both clients issued two set operations,

1314
01:14:40,670 --> 01:14:42,380
both set operation []?

1315
01:14:50,590 --> 01:14:51,280
Well, no.

1316
01:14:51,900 --> 01:14:52,770
And yeah, why not.

1317
01:14:53,660 --> 01:14:56,270
Because one of the version numbers will be wrong.

1318
01:14:56,960 --> 01:14:59,570
Yeah, right, like so one of the two goes first,

1319
01:14:59,600 --> 01:15:01,400
why does one of the two go first?

1320
01:15:02,440 --> 01:15:04,660
Because all writes are linearizable.

1321
01:15:04,720 --> 01:15:05,950
Yeah, all writes are linearizable,

1322
01:15:05,950 --> 01:15:07,450
so they're going some total order,

1323
01:15:07,480 --> 01:15:08,890
so you know we can pick one,

1324
01:15:08,890 --> 01:15:10,240
so let's say this guy goes first,

1325
01:15:10,240 --> 01:15:11,710
or this the operation goes first,

1326
01:15:12,300 --> 01:15:14,700
so that will increase the,

1327
01:15:14,880 --> 01:15:21,330
that will increase the, the value correct 1,

1328
01:15:21,330 --> 01:15:22,560
from 0 to 1 is correctly

1329
01:15:22,560 --> 01:15:25,080
and but will also and will execute,

1330
01:15:25,080 --> 01:15:26,700
because the version number is match, right,

1331
01:15:26,700 --> 01:15:29,370
like the version number 0 is actually what the current version number is,

1332
01:15:29,760 --> 01:15:32,370
so the version number match, the increment happens

1333
01:15:32,490 --> 01:15:34,770
and setData returns true.

1334
01:15:35,360 --> 01:15:36,620
What will happen with the second one,

1335
01:15:36,620 --> 01:15:38,420
while the second one, the version number won't match,

1336
01:15:38,420 --> 01:15:40,220
because the version number will be increased,

1337
01:15:40,220 --> 01:15:42,530
because of previous setData operation,

1338
01:15:42,710 --> 01:15:45,020
and therefore the second setData operation will fail,

1339
01:15:45,410 --> 01:15:48,410
and so and then the client will loop back and try again,

1340
01:15:48,410 --> 01:15:53,780
and try to and try to take another shot and do the increment.

1341
01:15:54,480 --> 01:15:57,540
And correct, so what happens in this case is correct,

1342
01:15:57,540 --> 01:16:02,130
even though the two clients executed the operation concurrently,

1343
01:16:02,130 --> 01:16:03,540
if the interleaving is bad,

1344
01:16:03,540 --> 01:16:06,360
you know the this piece of code will actually do the write thing,

1345
01:16:06,360 --> 01:16:07,740
the second client will try again,

1346
01:16:07,830 --> 01:16:09,270
and as a result you know the,

1347
01:16:09,810 --> 01:16:14,190
what the end value will be you know 2 supposed to 1.

1348
01:16:14,990 --> 01:16:15,710
Okay?

1349
01:16:19,430 --> 01:16:20,210
Does that make sense?

1350
01:16:23,860 --> 01:16:26,980
If you've done any sort of lock-free programming in the past,

1351
01:16:27,070 --> 01:16:29,410
then this might now look very familiar to you,

1352
01:16:29,500 --> 01:16:31,690
and so this sort of style of lock-free

1353
01:16:31,690 --> 01:16:35,440
basically zookeeper to encourage this sort of style of lock-free programming.

1354
01:16:44,840 --> 01:16:48,890
Okay, what I'd like to do,

1355
01:16:49,010 --> 01:16:50,420
since I'm running out of time,

1356
01:16:50,420 --> 01:16:52,250
last time I ran over time is,

1357
01:16:52,250 --> 01:16:56,060
I'll want to talk with some points about logs,

1358
01:16:56,420 --> 01:16:58,970
but I will do that next time,

1359
01:16:59,450 --> 01:17:01,820
the next lecture.

1360
01:17:02,000 --> 01:17:05,000
Now let me just sort of summarize what we've learned so far,

1361
01:17:05,000 --> 01:17:08,690
and then I'll talk a little bit more about zookeeper in the next lecture.

1362
01:17:10,560 --> 01:17:13,260
So, as summary,

1363
01:17:15,550 --> 01:17:18,910
so basically you know just a very successful design,

1364
01:17:25,300 --> 01:17:26,230
widely used,

1365
01:17:26,260 --> 01:17:29,230
you can download you know on github,

1366
01:17:29,230 --> 01:17:31,330
you can play around with it, if you wanted to,

1367
01:17:31,690 --> 01:17:34,030
and one of the things that's interesting about it,

1368
01:17:34,330 --> 01:17:36,340
compared to all the systems that we look so far,

1369
01:17:36,520 --> 01:17:38,650
it has weaker consistency,

1370
01:17:38,650 --> 01:17:42,280
which weaker consistency, I mean it doesn't provide linearizability,

1371
01:17:44,350 --> 01:17:50,020
and you know we're seeing that basically as a careful design API,

1372
01:17:50,020 --> 01:17:52,900
at least we've seen some aspects of the careful design API,

1373
01:17:52,900 --> 01:17:55,960
that despite the fact that actually has weaker consistency,

1374
01:17:56,020 --> 01:17:57,190
you can still use it,

1375
01:17:57,190 --> 01:18:00,970
and in fact you know you can use it actually for pretty important applications,

1376
01:18:00,970 --> 01:18:04,060
you can actually use zookeeper as a configuration service,

1377
01:18:04,540 --> 01:18:07,240
like its main purpose of keeping track of,

1378
01:18:07,240 --> 01:18:13,210
like who's primary, who's in the, who what the set of replicas etc etc,

1379
01:18:13,420 --> 01:18:16,510
and so for this sort of crucial operation of being a configuration service,

1380
01:18:16,510 --> 01:18:17,500
that has to be correct,

1381
01:18:17,500 --> 01:18:19,750
because otherwise we get to split-brain problem,

1382
01:18:20,020 --> 01:18:22,090
the API carefully designed,

1383
01:18:22,090 --> 01:18:24,340
so that if you use the API correctly,

1384
01:18:24,580 --> 01:18:30,040
you still can implement this crucial application on top of it,

1385
01:18:30,570 --> 01:18:33,480
despite the fact that actually provides weak consistency.

1386
01:18:34,420 --> 01:18:36,460
And the cool part of that is that,

1387
01:18:36,520 --> 01:18:37,870
this discrimination,

1388
01:18:37,930 --> 01:18:40,960
you know like sort of careful design API and the weaker consistency

1389
01:18:41,050 --> 01:18:43,750
allows us to get you know zookeeper really high performance.

1390
01:18:49,400 --> 01:18:51,320
And we'll see later in later lectures,

1391
01:18:51,380 --> 01:18:53,480
more of this sort of trick,

1392
01:18:53,510 --> 01:18:57,050
of trying to weaken the consistency guarantees

1393
01:18:57,050 --> 01:19:01,010
to actually you know get better for get better performance

1394
01:19:01,010 --> 01:19:07,310
or you know able to continue despite network partitions.

1395
01:19:09,810 --> 01:19:10,950
Okay, let me stop here,

1396
01:19:10,980 --> 01:19:15,130
and then I'll resume in a little while,

1397
01:19:15,720 --> 01:19:17,430
the next time around for the [] lecture.

1398
01:19:19,280 --> 01:19:20,090
Any questions?

1399
01:19:21,280 --> 01:19:22,960
Where again as usual,

1400
01:19:22,960 --> 01:19:25,270
if you have to go, please feel to go,

1401
01:19:25,270 --> 01:19:27,370
if you want to hang around and ask more questions,

1402
01:19:27,370 --> 01:19:29,560
you know feel free, please feel free to do so.

1403
01:19:41,940 --> 01:19:48,630
Sorry, can you go to the slide which said the set,

1404
01:19:49,140 --> 01:19:54,370
the unsuccessful example for the set and for the test-and-set,

1405
01:19:55,380 --> 01:19:57,660
I think it's two slides back.

1406
01:19:57,750 --> 01:19:58,320
This one?

1407
01:19:59,160 --> 01:20:03,280
Yeah, so the new design,

1408
01:20:03,960 --> 01:20:06,660
it's, it is able to fix that write.

1409
01:20:07,020 --> 01:20:10,980
Yeah, I mean like API zookeeper provides.

1410
01:20:14,700 --> 01:20:16,050
In the [] version write.

1411
01:20:16,380 --> 01:20:18,750
Yeah, if you have to exactly,

1412
01:20:19,110 --> 01:20:20,730
I didn't get to do that,

1413
01:20:20,730 --> 01:20:23,370
but that was going to the rest of the lecture is to talk about,

1414
01:20:23,370 --> 01:20:26,010
how you can implement test-and-set using the version numbers.

1415
01:20:27,100 --> 01:20:30,250
And clearly the increment suggests you can, correct,

1416
01:20:30,250 --> 01:20:31,900
because this is basically the same sequence.

1417
01:20:33,940 --> 01:20:34,420
Right.

1418
01:20:35,830 --> 01:20:38,440
Oh, if this is the same thing as the master, okay.

1419
01:20:38,440 --> 01:20:40,240
Yeah, that exactly.

1420
01:20:41,060 --> 01:20:42,260
Okay, thank you so much.

1421
01:20:42,260 --> 01:20:42,800
You're welcome.

1422
01:20:44,780 --> 01:20:49,760
I have a question about this version versioning to prevent lock

1423
01:20:50,000 --> 01:20:52,070
to implement lock-free programming,

1424
01:20:52,070 --> 01:20:55,340
is this like much more efficient lock-free programming,

1425
01:20:55,340 --> 01:20:57,590
because you still need to read,

1426
01:20:57,890 --> 01:20:59,630
try the operation again and again

1427
01:20:59,630 --> 01:21:00,950
until it succeeds write.

1428
01:21:01,640 --> 01:21:05,630
Yeah, again, this test-and-set has a similar property, correct,

1429
01:21:05,630 --> 01:21:06,830
if the test-and-set failed,

1430
01:21:06,890 --> 01:21:08,810
and you wanted to become you know actually increment,

1431
01:21:08,810 --> 01:21:09,740
you have to do that again,

1432
01:21:09,770 --> 01:21:11,520
so, it's often the case,

1433
01:21:11,520 --> 01:21:12,960
in this lock-free style programming,

1434
01:21:12,960 --> 01:21:15,030
that you have these loops where you retry.

1435
01:21:16,420 --> 01:21:17,920
And so if there's a lot of contention,

1436
01:21:18,310 --> 01:21:19,630
you're gonna get a lot of retry,

1437
01:21:19,750 --> 01:21:21,730
because there's no contention, there's no retry,

1438
01:21:22,210 --> 01:21:25,960
and typically you know these lock-free algorithms actually are pretty careful

1439
01:21:25,960 --> 01:21:27,250
in how they do the back off,

1440
01:21:27,610 --> 01:21:29,170
so they don't really retry immediately,

1441
01:21:29,170 --> 01:21:30,370
you know they have some backup plan.

1442
01:21:32,150 --> 01:21:36,440
Right, but what benefits this skip over a standard lock,

1443
01:21:36,530 --> 01:21:38,960
because either way if you have a lot of contention,

1444
01:21:38,960 --> 01:21:42,020
you're gonna be like sitting there and retrying a lot.

1445
01:21:42,170 --> 01:21:43,160
Yeah, so let's,

1446
01:21:43,160 --> 01:21:44,570
yeah, so you know,

1447
01:21:44,660 --> 01:21:48,230
so, the increment counter is an example,

1448
01:21:48,230 --> 01:21:52,400
where basically sort of implicitly do the locking,

1449
01:21:52,400 --> 01:21:56,430
because you will see if we implement locks in zookeeper,

1450
01:21:56,430 --> 01:22:00,990
like zookeeper, implement locks with zookeeper API,

1451
01:22:01,170 --> 01:22:02,700
and then if you do this stupid lock,

1452
01:22:02,730 --> 01:22:04,710
you can also have this contention issue,

1453
01:22:05,220 --> 01:22:07,830
of course, there's a way of implementing smarter lock,

1454
01:22:07,830 --> 01:22:10,560
they talked about like without [hurting]

1455
01:22:10,560 --> 01:22:12,240
and then you could do better,

1456
01:22:12,830 --> 01:22:16,760
and so I hoping to talk about next time.

1457
01:22:18,690 --> 01:22:19,590
Okay, thank you.

1458
01:22:20,040 --> 01:22:22,110
I think the real point here is you know that,

1459
01:22:22,110 --> 01:22:24,720
you can use these primitives to actually do lock-free programming,

1460
01:22:25,740 --> 01:22:29,250
like with the interface that the lab 3 provides, its not possible.

1461
01:22:31,820 --> 01:22:32,960
Makes sense, thank you.

1462
01:22:42,960 --> 01:22:43,980
Any further questions?

