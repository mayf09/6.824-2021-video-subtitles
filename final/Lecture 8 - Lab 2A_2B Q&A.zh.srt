1
00:00:03,170 --> 00:00:05,690
好的，下午好，声音检查。

2
00:00:08,480 --> 00:00:09,800
是的，我们是好的。

3
00:00:10,190 --> 00:00:10,910
好的，很好，

4
00:00:11,030 --> 00:00:14,150
晚上好，早上好，无论你在哪里，

5
00:00:14,240 --> 00:00:18,620
所以今天我想谈谈实验 2 a 和 b，

6
00:00:18,890 --> 00:00:21,110
这是一个问答环节，

7
00:00:21,530 --> 00:00:24,290
所以你可以随时打断我，

8
00:00:24,290 --> 00:00:26,660
随便问问题，

9
00:00:26,690 --> 00:00:31,430
今天的课程是专门针对你们的问题的，

10
00:00:31,700 --> 00:00:36,470
我总结了许多问题，

11
00:00:36,470 --> 00:00:39,380
在电子邮件中出现一次或多次，

12
00:00:39,380 --> 00:00:41,720
在右边这块白板上，

13
00:00:42,170 --> 00:00:51,020
希望当我演示我的解决方案时，能通过它们，

14
00:00:51,410 --> 00:00:57,240
我将主要介绍与该解决方案相关的四个主题。

15
00:00:57,390 --> 00:01:01,860
我们首先要谈一谈投票，或者投票代码，

16
00:01:01,860 --> 00:01:03,570
然后是心跳，

17
00:01:07,970 --> 00:01:11,090
然后我会讨论开始和提交。

18
00:01:17,310 --> 00:01:21,480
我认为这是我们在实验中提出的建议，

19
00:01:21,480 --> 00:01:22,590
比如你应该如何开始，

20
00:01:22,590 --> 00:01:24,150
第一次投票起作用，

21
00:01:24,150 --> 00:01:25,320
让心跳起作用，

22
00:01:25,320 --> 00:01:26,460
一旦你的心跳开始工作，

23
00:01:26,460 --> 00:01:28,770
你可以开始接受来自客户端的命令，

24
00:01:29,130 --> 00:01:30,900
然后当然你必须提交，

25
00:01:30,900 --> 00:01:32,910
把它们交给 apply 通道。

26
00:01:33,420 --> 00:01:35,400
所以有一个大致的方案顺序，

27
00:01:35,400 --> 00:01:38,220
但是，在任何时间，你都可以随意打断。

28
00:01:40,690 --> 00:01:44,470
所以在深入查看我的解决方案之前，

29
00:01:44,470 --> 00:01:46,000
或者我在这里写的解决方案，

30
00:01:46,150 --> 00:01:48,700
我想谈一谈调试，

31
00:01:48,700 --> 00:01:51,640
因为这是出现最多的问题，

32
00:01:51,670 --> 00:01:57,730
在所有你们提交的问题中。

33
00:01:58,310 --> 00:02:03,650
让我在很高级别上谈一谈调试，

34
00:02:04,510 --> 00:02:07,600
这显然是一个我们可以花上一整节课的话题，

35
00:02:07,660 --> 00:02:12,640
但我只想给你们一些我的高级别的方法，

36
00:02:12,640 --> 00:02:16,660
我通常会用来解决，

37
00:02:16,840 --> 00:02:18,580
通过实验。

38
00:02:19,190 --> 00:02:20,780
然后开始，

39
00:02:20,840 --> 00:02:23,660
我开始，我们运行的第一个测试用例，

40
00:02:25,810 --> 00:02:27,550
当然，如果我没有写过任何代码，

41
00:02:27,550 --> 00:02:28,300
我会失败，

42
00:02:29,020 --> 00:02:31,120
但至少我有了一个起点，

43
00:02:31,120 --> 00:02:34,480
我可以开始写一些代码，

44
00:02:34,660 --> 00:02:36,520
所以想想第一个测试用例，

45
00:02:36,520 --> 00:02:37,960
开始编写，

46
00:02:37,990 --> 00:02:40,540
查看提示并编写一些代码，

47
00:02:41,110 --> 00:02:42,520
在编写代码时，

48
00:02:42,760 --> 00:02:45,610
我觉得这很方便，

49
00:02:45,670 --> 00:02:48,520
在这个实验或这个实验集合中，

50
00:02:48,520 --> 00:02:50,320
实际上， 6.824 中的任何实验，

51
00:02:50,410 --> 00:02:52,450
要记录所有消息，

52
00:02:57,380 --> 00:03:02,210
通常使用 util.go 中的 DPrintf 函数，

53
00:03:02,450 --> 00:03:05,810
我很有系统地记录消息，

54
00:03:06,440 --> 00:03:10,760
我这样做的原因不是为了调试目的，

55
00:03:10,850 --> 00:03:13,850
所以，我将编写代码，

56
00:03:13,880 --> 00:03:15,620
运行测试代码失败，

57
00:03:15,620 --> 00:03:18,770
编写一些代码以尝试通过测试用例，

58
00:03:19,280 --> 00:03:22,010
这里有两种情况，

59
00:03:22,010 --> 00:03:23,600
一个是我通过了，

60
00:03:24,070 --> 00:03:27,100
然后我立即转到下一个测试用例，

61
00:03:27,370 --> 00:03:29,080
或者我失败了，

62
00:03:30,140 --> 00:03:33,020
在这种情况下，

63
00:03:33,440 --> 00:03:34,790
我做的第一件事是，

64
00:03:34,790 --> 00:03:36,980
更详细地研究测试用例，

65
00:03:37,130 --> 00:03:41,720
并尝试找出测试用例要测试的东西，

66
00:03:42,530 --> 00:03:44,750
测试用例的名称

67
00:03:44,750 --> 00:03:47,450
通常非常暗示特定场景是什么，

68
00:03:47,450 --> 00:03:51,020
或者测试用例试图涵盖的场景集合，

69
00:03:51,740 --> 00:03:54,530
然后我试着自己回答，

70
00:03:54,530 --> 00:03:57,050
假设为什么我的代码，

71
00:03:57,050 --> 00:04:00,230
为什么没通过测试用例，

72
00:04:00,650 --> 00:04:05,030
所以这是一个反思和思考的时刻，

73
00:04:07,110 --> 00:04:11,880
而且，为了理解，

74
00:04:11,880 --> 00:04:14,040
我脑子里想的是什么场景，

75
00:04:14,040 --> 00:04:15,660
似乎符合测试用例，

76
00:04:15,660 --> 00:04:16,950
想想我的代码，

77
00:04:16,950 --> 00:04:19,920
它可能是一个问题，

78
00:04:19,920 --> 00:04:21,660
一旦我有了一个假设，

79
00:04:21,660 --> 00:04:23,250
然后接下来要做的就是学习，

80
00:04:23,250 --> 00:04:27,810
试着确认这个假设，

81
00:04:27,810 --> 00:04:32,250
我的解释，为什么通过测试，可能是对的或错的，

82
00:04:32,430 --> 00:04:33,180
所以，要做到这一点，

83
00:04:33,180 --> 00:04:34,710
我要研究一下日志，

84
00:04:36,950 --> 00:04:40,250
所以如果我有打印或所有消息，

85
00:04:40,250 --> 00:04:42,140
发送到协议的那部分，

86
00:04:42,260 --> 00:04:44,990
我可以看到跟踪，

87
00:04:44,990 --> 00:04:48,260
看看哪里出了问题，

88
00:04:48,260 --> 00:04:49,670
工作回退，

89
00:04:49,670 --> 00:04:51,320
使用这种方式，

90
00:04:51,320 --> 00:04:55,160
测试和完善我的假设，

91
00:04:55,160 --> 00:04:57,080
为什么我的代码可能是错误的，

92
00:04:58,580 --> 00:05:02,330
有时这可能需要回到过去，

93
00:05:02,330 --> 00:05:07,250
运行测试用例测试以获得更详细的日志输出，

94
00:05:07,250 --> 00:05:11,390
虽然在早期我倾向于非常系统化，

95
00:05:11,390 --> 00:05:13,940
你不需要添加任何打印语句，

96
00:05:13,940 --> 00:05:16,220
但在某些情况下，是需要的，

97
00:05:16,840 --> 00:05:19,480
那么这给了我更多的信息，

98
00:05:19,480 --> 00:05:23,170
我可以真正放大场景，

99
00:05:23,170 --> 00:05:25,960
我的代码没有处理的，

100
00:05:26,410 --> 00:05:28,570
一旦我有了一个假设，

101
00:05:28,570 --> 00:05:30,100
我在日志里检查，

102
00:05:30,100 --> 00:05:32,620
这个假设似乎是正确的，

103
00:05:32,620 --> 00:05:35,140
这是我的代码中的一个 bug ，

104
00:05:35,410 --> 00:05:37,150
我可以修改代码，

105
00:05:39,670 --> 00:05:41,530
然后运行测试用例。

106
00:05:42,630 --> 00:05:44,790
所以这是一个简短的过程，

107
00:05:44,880 --> 00:05:46,200
运行测试用例，

108
00:05:46,410 --> 00:05:51,840
如果失败，研究测试用例和研究日志以制定假设，

109
00:05:51,840 --> 00:05:53,550
试图证实这一假设，

110
00:05:53,730 --> 00:05:55,560
然后继续修复代码，

111
00:05:55,560 --> 00:05:56,730
然后转到下一个，

112
00:05:57,270 --> 00:06:00,900
这往往是合理的，系统的。

113
00:06:01,410 --> 00:06:05,280
例如，我经常会在某个文件中写下，一个文本文件，

114
00:06:05,280 --> 00:06:06,420
我的假设是什么，

115
00:06:06,420 --> 00:06:09,480
并试图收集证据或反证据，

116
00:06:09,480 --> 00:06:12,780
要证明或反驳我的假设，

117
00:06:12,780 --> 00:06:16,830
我有很好的理由来修复代码，

118
00:06:16,860 --> 00:06:20,280
我认为任何方法都不是非常系统化的，

119
00:06:20,280 --> 00:06:23,130
例如，你认为有些事情并不是百分之百正确的，

120
00:06:23,130 --> 00:06:24,450
也许可以改变这个，

121
00:06:24,450 --> 00:06:26,550
看看你是否通过了测试用例，

122
00:06:26,550 --> 00:06:28,770
往往效果不是很好，

123
00:06:28,770 --> 00:06:30,270
我认为这需要很长时间，

124
00:06:30,780 --> 00:06:32,880
因为你可能错了，

125
00:06:32,880 --> 00:06:34,890
或者更糟糕的是，你可能是错的，

126
00:06:34,890 --> 00:06:36,780
实际上通过了测试用例，认为你是对的，

127
00:06:37,110 --> 00:06:38,220
但事实证明，

128
00:06:38,220 --> 00:06:41,610
你只是将 bug 从一个角落转移到另一个角落，

129
00:06:41,610 --> 00:06:42,960
它将在稍后再次出现。

130
00:06:44,010 --> 00:06:49,710
所以在非常高级别上，这是我采取的方法，

131
00:06:49,950 --> 00:06:54,870
你可以看到这里的关键是记录消息。

132
00:06:57,530 --> 00:07:03,400
对这个方法，有什么疑问或者评论，

133
00:07:03,520 --> 00:07:04,870
我知道这是很高的级别上，

134
00:07:04,870 --> 00:07:07,390
但至少让你对我是如何处理这件事有所了解。

135
00:07:08,040 --> 00:07:10,080
所以这里的消息是 RPC ？

136
00:07:10,410 --> 00:07:11,490
是的，所有的 RPC 。

137
00:07:11,610 --> 00:07:12,540
好的，好的。

138
00:07:15,790 --> 00:07:18,130
好的，所以有一些，所以。

139
00:07:18,220 --> 00:07:19,240
我有一个简短的问题，

140
00:07:20,650 --> 00:07:22,930
那么什么是好的方法，

141
00:07:22,930 --> 00:07:26,950
用于决定记录什么和不记录什么的粒度？

142
00:07:27,010 --> 00:07:29,590
啊，这是一个非常好的问题，

143
00:07:29,590 --> 00:07:30,700
我希望有人提问，

144
00:07:31,000 --> 00:07:34,930
我倾向于把事情做得很细粒度，

145
00:07:34,930 --> 00:07:36,580
[]记录所有东西，

146
00:07:37,160 --> 00:07:41,600
然后，我使用，

147
00:07:41,600 --> 00:07:44,690
我把日志放入编辑器，

148
00:07:44,690 --> 00:07:47,390
或者使用像 grep 这样的 Unix 程序，

149
00:07:47,480 --> 00:07:49,760
找出那些有兴趣的东西。

150
00:07:50,590 --> 00:07:52,480
我这么做的原因是，

151
00:07:52,480 --> 00:07:56,920
有时候我不知道我想要研究什么粒度的东西，

152
00:07:57,280 --> 00:08:00,520
我不想回去再做一次测试，

153
00:08:00,520 --> 00:08:01,720
我只是收集所有的东西，

154
00:08:01,720 --> 00:08:04,810
然后找出我关心的东西。

155
00:08:05,340 --> 00:08:06,600
这让我开始了，

156
00:08:06,600 --> 00:08:12,840
所以，有些人编写了相当多的调试基础设施，

157
00:08:12,870 --> 00:08:17,670
使用日志，使更容易理解，

158
00:08:17,700 --> 00:08:22,020
我很原始， DPrintf 和信息日志，

159
00:08:22,020 --> 00:08:26,340
尽管我以清晰的方式组织我的 printf ，

160
00:08:26,340 --> 00:08:29,310
这样我就能看到来源是什么，目的地是什么，

161
00:08:29,670 --> 00:08:32,400
以及 RPC 本身是什么，

162
00:08:32,550 --> 00:08:37,500
我可以非常快速地找出过滤，

163
00:08:37,590 --> 00:08:41,010
因为所有文本行都有特定的格式。

164
00:08:42,630 --> 00:08:45,930
一些人花了相当多的时间建设一些基础设施，

165
00:08:45,930 --> 00:08:48,390
以使一切变得更容易，

166
00:08:48,600 --> 00:08:50,880
TA 之一的 Jose ，

167
00:08:51,150 --> 00:08:52,380
当他上课的时候，

168
00:08:52,410 --> 00:08:54,090
他构建了一些软件，

169
00:08:54,090 --> 00:08:55,410
让它更容易，

170
00:08:55,410 --> 00:08:58,620
Python 脚本，使解析日志变得更容易，

171
00:08:58,620 --> 00:09:01,680
我想看看他所做的会很有趣，

172
00:09:02,070 --> 00:09:03,750
我要停止分享，

173
00:09:03,750 --> 00:09:07,170
然后请 Jose 分享，也许还有 demo ，

174
00:09:07,170 --> 00:09:10,710
它的日志结构是如何工作的。

175
00:09:11,430 --> 00:09:13,440
抱歉，我有一个跟进的问题。

176
00:09:14,200 --> 00:09:20,050
那么，如何将调试 print 写入日志而不是标准输出？

177
00:09:20,290 --> 00:09:26,470
哦，通常是输出到一个文件，所以。

178
00:09:26,500 --> 00:09:28,660
所以，你只是使用管道将所有东西到一个文件中。

179
00:09:28,690 --> 00:09:30,280
是的，我把它通过管道传输到一个文件中。

180
00:09:30,910 --> 00:09:31,810
知道了，谢谢。

181
00:09:35,240 --> 00:09:37,910
我想这是 Jose 的屏幕， Jose 继续。

182
00:09:38,500 --> 00:09:39,760
你能听到我说话吗？

183
00:09:40,210 --> 00:09:40,960
是的，我能听到。

184
00:09:41,260 --> 00:09:42,040
好的，太棒了，

185
00:09:42,370 --> 00:09:46,240
我同意这些观点，

186
00:09:46,240 --> 00:09:49,750
事情与 Frans 所描述的很像，

187
00:09:49,750 --> 00:09:53,380
[]日志，我试着去做，

188
00:09:53,410 --> 00:09:56,470
记录进行的每个事件，

189
00:09:56,470 --> 00:10:00,910
我也有一个我遵循的格式，

190
00:10:01,300 --> 00:10:04,720
然后我要展示的是，

191
00:10:04,720 --> 00:10:08,050
让我的生活更轻松，并通过日志。

192
00:10:08,480 --> 00:10:13,490
高级别的想法是我在 Go 中做非常简单的结构，

193
00:10:13,760 --> 00:10:17,510
然后我会把这些标准输入转存到一个文件中，

194
00:10:17,510 --> 00:10:20,030
然后我使用 Python 脚本执行，

195
00:10:20,270 --> 00:10:22,730
所有的颜色和结构，

196
00:10:22,970 --> 00:10:26,870
因为这在 Python 中要比在 Go 中容易得多。

197
00:10:28,020 --> 00:10:32,940
例如，这是我在一个 Go 测试中得到的，

198
00:10:32,940 --> 00:10:34,980
当我启用 VERBOSE 时，

199
00:10:35,280 --> 00:10:38,520
我得到一个输出，看起来像这样，

200
00:10:38,700 --> 00:10:41,010
我在这里记录的是，

201
00:10:41,040 --> 00:10:44,160
毫秒数是第一列，

202
00:10:44,190 --> 00:10:47,490
当你调试计时器事件时，这非常有用，

203
00:10:47,860 --> 00:10:48,580
诸如此类的事情，

204
00:10:48,580 --> 00:10:51,640
试图了解 RPC 需要多长时间才能失败，

205
00:10:51,730 --> 00:10:55,630
第二栏是我称为主题，

206
00:10:55,900 --> 00:10:56,950
它们不是级别，

207
00:10:56,950 --> 00:10:59,470
因为它们是没有等级，

208
00:10:59,470 --> 00:11:01,930
它们只是与 Raft 上的不同时间有关，

209
00:11:01,990 --> 00:11:04,900
可能你们中的许多人现在已经意识到，

210
00:11:04,900 --> 00:11:06,910
在实验 3 中，很多事情发生，

211
00:11:07,150 --> 00:11:10,270
比如定时器，选举，日志，

212
00:11:10,270 --> 00:11:13,360
应用与状态机通信的东西，

213
00:11:13,700 --> 00:11:16,850
所有这些事件发生的频率都略有不同，

214
00:11:17,030 --> 00:11:20,930
所以如果你想之后从它们中选择，

215
00:11:20,930 --> 00:11:24,260
或者决定忽略更多的那些，

216
00:11:24,410 --> 00:11:28,550
这样的类别真的很方便，

217
00:11:28,580 --> 00:11:32,330
然后第三列，可能你们中的许多人有这个，

218
00:11:32,450 --> 00:11:35,180
哪个服务器在说这条消息，

219
00:11:35,180 --> 00:11:38,120
因为我们认为这很难对发生的事情进行推理，

220
00:11:38,880 --> 00:11:41,370
剩下的是一条自由形式的信息，

221
00:11:41,370 --> 00:11:44,160
解释了这条信息是关于什么的，

222
00:11:44,370 --> 00:11:50,280
尽管这只是你运行的最初始的测试，

223
00:11:50,280 --> 00:11:53,100
刚刚通过的，你可以进行选举的那个，

224
00:11:53,340 --> 00:11:57,740
你必须阅读，遵循这里的逻辑。

225
00:11:58,190 --> 00:12:02,600
所以我让这件事变得更容易，

226
00:12:02,600 --> 00:12:04,880
这就是我在课程中所做的，

227
00:12:04,880 --> 00:12:08,500
把所有的主题都转换成颜色，

228
00:12:08,500 --> 00:12:13,420
像大多数内部支持一样，广泛的颜色支持，

229
00:12:13,420 --> 00:12:16,480
同样，通过使用 Python 语言做这个，

230
00:12:16,480 --> 00:12:20,620
你可以使用一些出色的库来完成所有繁重的任务，

231
00:12:20,620 --> 00:12:24,520
你不必参与到这件事中来。

232
00:12:24,900 --> 00:12:28,380
在这里，是的，包括了不同颜色的不同事件，

233
00:12:28,590 --> 00:12:31,380
随着你对颜色越来越熟悉，

234
00:12:31,380 --> 00:12:34,260
例如，这里所有定时器事件都是灰色的，

235
00:12:34,260 --> 00:12:36,150
所以也许它们更容易被忽视，

236
00:12:36,240 --> 00:12:39,390
或者我们寻找当有人投票的时候，

237
00:12:39,390 --> 00:12:42,300
我们可以看一下青色，它与投票有关，

238
00:12:42,790 --> 00:12:48,640
我们在视觉上编码，东西更容易找出来，

239
00:12:48,940 --> 00:12:52,420
例如，这里的黄色是我们选举，选举新领导人的时候。

240
00:12:53,140 --> 00:12:55,870
我们还得决定谁在说什么，

241
00:12:55,900 --> 00:12:58,340
为了做到这一点，

242
00:12:58,340 --> 00:13:02,000
我加入了不同的列，

243
00:13:02,330 --> 00:13:05,570
再说一次，我现在所做的就是运行，

244
00:13:05,570 --> 00:13:08,810
我所做的只是运行标准测试脚本，

245
00:13:08,810 --> 00:13:12,800
然后通过管道到我写的脚本中，

246
00:13:13,290 --> 00:13:15,990
在本例中，我指定我有三列，

247
00:13:15,990 --> 00:13:18,270
因为在这个测试用例中有三个节点，

248
00:13:18,390 --> 00:13:21,960
我现在决定忽略计时器，

249
00:13:21,960 --> 00:13:23,970
就像定时器主题的事件，

250
00:13:23,970 --> 00:13:25,800
因为它们太多了，

251
00:13:25,890 --> 00:13:27,420
并且如果定时逻辑工作了，

252
00:13:27,420 --> 00:13:29,910
我们可能不需要它们来调试正在发生的事情，

253
00:13:30,570 --> 00:13:32,700
如果你看一下这个日志，

254
00:13:32,700 --> 00:13:35,160
与我们的明文日志相比，

255
00:13:35,280 --> 00:13:37,950
很容易看到，发生了什么，

256
00:13:37,950 --> 00:13:39,990
有三台服务器在启动，

257
00:13:40,020 --> 00:13:41,910
最后一个成为候选者，

258
00:13:41,970 --> 00:13:43,620
另外两个给它投了票，

259
00:13:44,000 --> 00:13:46,970
一旦获得第一票，它就会成为领导者，

260
00:13:46,970 --> 00:13:50,150
然后它就会在剩下的测试中心跳，

261
00:13:50,660 --> 00:13:52,820
没有其他东西可以看了。

262
00:13:53,450 --> 00:13:56,510
但现在再一次和这个相比，

263
00:13:56,980 --> 00:14:00,340
更容易发现正在发生的事情，

264
00:14:00,820 --> 00:14:02,800
当你根据自己的喜好调整它的时候，

265
00:14:02,800 --> 00:14:04,360
它变得越来越高效。

266
00:14:05,160 --> 00:14:07,920
当你转向更难的测试时，

267
00:14:07,980 --> 00:14:09,750
因为你们中的许多人可能

268
00:14:09,900 --> 00:14:14,820
已经看过 2B 实验的 backup 测试日志，

269
00:14:14,850 --> 00:14:18,060
会有很多很多的事件在进行，

270
00:14:18,060 --> 00:14:20,760
即使你知道你需要什么，

271
00:14:20,760 --> 00:14:23,250
这可能会成为一项艰巨的任务，

272
00:14:23,600 --> 00:14:26,570
通过上千行的日志，

273
00:14:26,570 --> 00:14:28,910
你寻找失败点，

274
00:14:28,910 --> 00:14:30,950
并试图对发生的事情进行推理。

275
00:14:32,490 --> 00:14:34,230
同样，如果我们查看，

276
00:14:34,260 --> 00:14:40,110
使用这种类似于可视化的格式，

277
00:14:40,290 --> 00:14:42,420
我们可以很快看到发生了什么，

278
00:14:42,450 --> 00:14:45,960
我们有五个不同的服务器正在启动，

279
00:14:46,170 --> 00:14:48,150
第一个成为候选者，

280
00:14:48,390 --> 00:14:49,950
其他人投票给它，

281
00:14:50,380 --> 00:14:51,550
成为领导者，

282
00:14:51,730 --> 00:14:54,160
通过观察不同的列，

283
00:14:54,250 --> 00:14:54,640
我们可以看到，

284
00:14:54,640 --> 00:14:57,160
例如所有紫色的[]，

285
00:14:57,160 --> 00:14:59,410
当提交或应用某件事时，

286
00:14:59,410 --> 00:15:02,530
所以我们可以看到收到了一个新条目，

287
00:15:02,960 --> 00:15:05,450
这个服务器正在接收，

288
00:15:05,480 --> 00:15:10,280
而且由于 backup 具有非常详细的日志，

289
00:15:10,490 --> 00:15:12,830
我有很多 Drop RPC ，

290
00:15:12,830 --> 00:15:16,030
我在这里也忽略了这些话题，

291
00:15:16,060 --> 00:15:18,310
随着测试的进行，

292
00:15:18,370 --> 00:15:20,650
我们可以开始对发生的事情进行推理，

293
00:15:20,710 --> 00:15:22,570
所以，可能是有帮助的，

294
00:15:22,600 --> 00:15:26,980
在测试代码中有一些打印语句或调试语句，

295
00:15:26,980 --> 00:15:28,660
你可以在那里修改，

296
00:15:29,050 --> 00:15:30,550
知道测试在做什么，

297
00:15:30,550 --> 00:15:32,410
例如，在这里，测试检测到，

298
00:15:32,470 --> 00:15:35,830
第一个服务器 S0 是领导者，

299
00:15:35,980 --> 00:15:39,180
然后断开 S2 直到 S4 的连接，

300
00:15:39,180 --> 00:15:41,550
就是右边的三个，

301
00:15:41,880 --> 00:15:43,830
这几乎就是发生的事情，

302
00:15:43,830 --> 00:15:47,700
我们收到一串条目，不会被提交，

303
00:15:47,700 --> 00:15:51,330
因为只有两台服务器可以相互通信，

304
00:15:51,330 --> 00:15:52,950
然后过了一段时间，

305
00:15:53,410 --> 00:15:56,290
我们看到前两个现在是断开的，

306
00:15:56,320 --> 00:16:00,040
右边的三个重新连接在一起，

307
00:16:00,040 --> 00:16:01,930
现在它们可以形成大多数，

308
00:16:02,510 --> 00:16:04,010
这就是我们将看到的，

309
00:16:04,010 --> 00:16:07,970
最后一个人成为候选者，获得多数，

310
00:16:08,060 --> 00:16:14,270
我们可以重复地看到绿色和紫色的颜色模式，

311
00:16:14,330 --> 00:16:18,560
就像这个楼梯表示，哦，接受一个条目，

312
00:16:18,740 --> 00:16:21,470
并将它传播到其他服务器，

313
00:16:21,500 --> 00:16:25,190
而这里的断开连接的服务器转换为候选者。

314
00:16:25,610 --> 00:16:27,620
希望我现在已经说服了你，

315
00:16:27,620 --> 00:16:31,910
通过稍微改变日志的呈现方式，

316
00:16:31,910 --> 00:16:36,920
经历它们的精神努力会显著减少，

317
00:16:37,190 --> 00:16:39,890
尽管这真的很花哨，

318
00:16:39,890 --> 00:16:43,070
没有太多花哨的代码，

319
00:16:43,070 --> 00:16:48,410
我只使用了一些自带的 Python 库，主要是 rich ，

320
00:16:48,770 --> 00:16:53,430
大概有上百行的 Python 脚本，

321
00:16:53,460 --> 00:16:55,650
如果你感兴趣的话，

322
00:16:55,650 --> 00:16:57,810
我写了一篇博客文章，

323
00:16:57,810 --> 00:17:00,810
在 Piazza 上放了网站链接，

324
00:17:00,810 --> 00:17:05,470
关于构建一个这样的工具的步骤，

325
00:17:05,470 --> 00:17:07,510
这些是如何结合在一起的，

326
00:17:07,510 --> 00:17:10,390
一些与此相关的设计决定。

327
00:17:11,130 --> 00:17:15,180
如果任何人有任何与此相关的问题，很乐意回答。

328
00:17:23,500 --> 00:17:24,730
有什么问题要问 Jose 吗？

329
00:17:25,770 --> 00:17:29,130
是的，我有一个关于一般日志的问题，

330
00:17:29,670 --> 00:17:32,040
所以我知道有一些 bug ，

331
00:17:32,250 --> 00:17:36,870
当我把它们放进日志时，它们已经不在那里了，

332
00:17:37,290 --> 00:17:42,180
由于某些时间问题，或者可能是并发问题，

333
00:17:42,360 --> 00:17:44,340
那么我们该怎么办？

334
00:17:45,280 --> 00:17:48,370
好的，我做了几件事，

335
00:17:48,370 --> 00:17:51,490
首先，我记录细粒度的一个原因，

336
00:17:51,640 --> 00:17:55,300
始终保持细粒度，

337
00:17:55,300 --> 00:17:57,310
所以我总是对每件事都有跟踪，

338
00:17:57,310 --> 00:17:58,900
我一般都不需要回去。

339
00:18:00,280 --> 00:18:02,200
另一件要做的事情是，

340
00:18:02,200 --> 00:18:05,500
我确实做了很多很多次测试，

341
00:18:05,500 --> 00:18:06,940
保存所有的日志，

342
00:18:07,490 --> 00:18:09,350
一旦我遇到了错误的，

343
00:18:09,350 --> 00:18:10,580
一旦我碰到了 bug ，

344
00:18:10,610 --> 00:18:12,950
那么我研究那个特定的日志。

345
00:18:16,920 --> 00:18:18,900
所以，比如，如果我连夜运行一些东西，

346
00:18:18,930 --> 00:18:21,720
我只是保存连夜运行的所有日志，

347
00:18:21,720 --> 00:18:23,640
然后找出失败的那个。

348
00:18:29,440 --> 00:18:33,660
对于日志的话题，还有更多问题吗？

349
00:18:39,220 --> 00:18:41,650
好的，让我继续，

350
00:18:42,320 --> 00:18:44,570
在之前的，看看代码，

351
00:18:44,570 --> 00:18:46,340
我想谈一谈结构，

352
00:18:46,970 --> 00:18:49,280
我的解决方案有的，

353
00:18:49,280 --> 00:18:51,440
这绝对不是唯一的结构，

354
00:18:51,500 --> 00:18:53,330
你可以用很多不同的方法来做这件事，

355
00:18:53,360 --> 00:18:56,420
你可以自由地以多种不同的方式做这件事，

356
00:18:56,750 --> 00:19:00,050
事实上，每年我上课的时候，

357
00:19:00,050 --> 00:19:03,050
我试着重写，

358
00:19:03,050 --> 00:19:05,030
再次实现实验，

359
00:19:05,210 --> 00:19:08,870
并经常尝试不同类型的实现方式。

360
00:19:09,430 --> 00:19:13,510
所以今天我要向你们展示的是，

361
00:19:13,510 --> 00:19:15,670
一个我写的[]，

362
00:19:15,670 --> 00:19:18,010
是为 6.824 做准备的，

363
00:19:18,250 --> 00:19:20,350
然后它有如下的结构。

364
00:19:20,680 --> 00:19:22,150
这是一个非常标准的结构，

365
00:19:22,360 --> 00:19:25,030
让我画一个盒子，

366
00:19:25,610 --> 00:19:28,430
表示 Raft 库，

367
00:19:28,550 --> 00:19:34,060
有两个 API 调用，

368
00:19:34,060 --> 00:19:38,530
一个是 Start ，用来初始化追加条目，

369
00:19:38,710 --> 00:19:42,790
初始化日志操作，

370
00:19:43,620 --> 00:19:47,640
输出通过 apply 通道，

371
00:19:48,530 --> 00:19:53,120
然后，在我们展示的一个文件中，

372
00:19:53,120 --> 00:19:58,060
基本上是一个 Raft 结构，

373
00:19:59,340 --> 00:20:04,410
它具有 Raft 库的所有状态，

374
00:20:04,440 --> 00:20:07,860
图 2 中的所有变量，

375
00:20:08,160 --> 00:20:11,430
这个有一个锁，

376
00:20:13,490 --> 00:20:15,800
基本上我所有的，

377
00:20:15,830 --> 00:20:20,150
所以我使用相当粗粒度的锁，对于所有 RPC 处理程序，

378
00:20:20,150 --> 00:20:22,100
我一开始，

379
00:20:22,220 --> 00:20:24,320
只使用一个锁，

380
00:20:24,560 --> 00:20:26,780
做它们需要做的任何事情，

381
00:20:26,780 --> 00:20:28,790
然后释放锁，

382
00:20:29,510 --> 00:20:33,320
所以有几个线程，在各处运行，

383
00:20:33,470 --> 00:20:35,570
其中一个当然定时器线程，

384
00:20:35,570 --> 00:20:37,280
我们给你的，

385
00:20:38,030 --> 00:20:40,490
它只是等待，

386
00:20:40,700 --> 00:20:41,630
我稍后向你们展示，

387
00:20:41,630 --> 00:20:45,290
它将等待一定的毫秒数， 50 毫秒，

388
00:20:45,680 --> 00:20:48,890
然后运行，然后定期检查，

389
00:20:48,890 --> 00:20:51,590
如果有任何超时，选举超时已经结束，

390
00:20:51,590 --> 00:20:53,060
做任何需要做的事情，

391
00:20:53,810 --> 00:20:58,040
我有一个线程专门用于在 apply 通道上写入数据，

392
00:20:58,310 --> 00:21:01,040
没有其他线程写入 apply 通道，

393
00:21:01,040 --> 00:21:02,150
只有一个，

394
00:21:02,330 --> 00:21:04,850
它在一个条件变量上睡眠，

395
00:21:07,240 --> 00:21:13,720
当一个新的附加条目从领导者处进入时，

396
00:21:13,720 --> 00:21:17,500
然后提交索引会增加，

397
00:21:17,710 --> 00:21:22,000
然后线程将在信号上被唤醒，

398
00:21:22,000 --> 00:21:24,130
条件变量将唤醒那个线程，

399
00:21:24,130 --> 00:21:27,070
它写入 apply 通道，

400
00:21:27,130 --> 00:21:30,340
它将从日志中获取条目，

401
00:21:30,700 --> 00:21:32,560
并把它们放在 apply 通道上。

402
00:21:36,440 --> 00:21:38,720
所以，这是一个原因，

403
00:21:38,720 --> 00:21:40,880
单个线程当然不能持有锁，

404
00:21:40,880 --> 00:21:43,100
在向 apply 通道写入时，

405
00:21:43,100 --> 00:21:45,500
你稍后可能会遇到问题，

406
00:21:45,770 --> 00:21:48,350
所以我只有一个线程，

407
00:21:48,350 --> 00:21:50,030
它在 apply 通道上写入。

408
00:21:51,590 --> 00:21:57,720
然后，当然有很多东西是从外面进来的，

409
00:21:57,720 --> 00:21:59,790
需要传入的消息，

410
00:22:00,180 --> 00:22:03,360
当然，每个消息或每个 RPC 都会启动自己的线程，

411
00:22:03,510 --> 00:22:08,340
RPC 库会为每条传入消息启动一个线程，

412
00:22:08,700 --> 00:22:12,120
我处理每一条消息的方式，

413
00:22:12,120 --> 00:22:14,610
第一件事抓住 Raft 结构的日志，

414
00:22:14,880 --> 00:22:17,010
它读写 Raft 结构，

415
00:22:17,010 --> 00:22:17,880
然后当它完成的时候，

416
00:22:17,910 --> 00:22:21,360
你可以解锁，

417
00:22:21,360 --> 00:22:22,320
也许在这两者之间，

418
00:22:22,320 --> 00:22:25,590
它也会更新条件变量中的信号。

419
00:22:27,850 --> 00:22:30,040
然后，当然 Start 自己，

420
00:22:30,100 --> 00:22:32,050
在特定的线程上运行，

421
00:22:32,810 --> 00:22:34,760
所以它跳入 Raft 库，

422
00:22:34,760 --> 00:22:35,900
这是一回事，

423
00:22:35,900 --> 00:22:37,820
获取锁，然后，

424
00:22:37,910 --> 00:22:41,870
让我添加条目，

425
00:22:41,870 --> 00:22:46,250
如果领导者追加到日志结构中，

426
00:22:46,670 --> 00:22:50,660
然后发送附加 RPC ，

427
00:22:51,050 --> 00:22:54,860
因为我想并行执行附加 RPC ，

428
00:22:54,890 --> 00:22:57,590
它的工作方式是，

429
00:22:57,590 --> 00:22:59,810
对于每个 RPC ，

430
00:23:00,390 --> 00:23:01,860
我开始一个单独的线程，

431
00:23:02,700 --> 00:23:06,690
而在那个线程中上负责发送它，

432
00:23:06,870 --> 00:23:11,490
保留响应，并在响应中进行任何更新，

433
00:23:11,490 --> 00:23:13,290
对 Raft 结构是必要的。

434
00:23:13,320 --> 00:23:16,470
所以，响应处理程序在响应到达时，

435
00:23:16,710 --> 00:23:19,990
获取 Raft 锁，

436
00:23:20,080 --> 00:23:23,380
然后更新任何需要的 Raft 状态，

437
00:23:23,380 --> 00:23:24,430
然后释放锁。

438
00:23:25,320 --> 00:23:27,780
所以，这里有一堆线程，

439
00:23:27,780 --> 00:23:29,730
你可以运行相当多的线程，

440
00:23:29,730 --> 00:23:31,620
因为一些消息可能会迟到，

441
00:23:31,620 --> 00:23:34,950
所以这里可能有很多的线程，

442
00:23:35,510 --> 00:23:38,270
而且可能会有多个 Start ，

443
00:23:38,270 --> 00:23:39,680
可能会有 Start 是，

444
00:23:39,680 --> 00:23:41,000
而不是那里的多个线程，

445
00:23:41,000 --> 00:23:46,790
当然，你的定时器也开始了，可能会发出心跳，

446
00:23:46,790 --> 00:23:50,690
那些心跳又变成了一个单独的线程，

447
00:23:51,870 --> 00:23:57,150
但所有这些线程都是由 Raft 锁序列化的，

448
00:23:57,210 --> 00:23:58,950
或通过 Raft 锁串行化。

449
00:24:08,880 --> 00:24:11,250
所以当我打印日志消息时，

450
00:24:11,250 --> 00:24:14,970
当然这是在持有 Raft 锁时做的，

451
00:24:15,270 --> 00:24:19,200
因为每个线程都是一个接一个地运行，

452
00:24:19,200 --> 00:24:21,480
很多信息都很有意义，

453
00:24:21,480 --> 00:24:23,700
它们也是串行化的。

454
00:24:24,520 --> 00:24:31,720
类似地，我使所有 RPC 处理程序都是原子的或序列化的，

455
00:24:32,740 --> 00:24:34,510
所以细粒度锁，

456
00:24:34,660 --> 00:24:37,750
这很有帮助，我稍后会谈到，

457
00:24:38,230 --> 00:24:41,980
然后，你唯一要小心的是，

458
00:24:41,980 --> 00:24:43,870
如果你执行某种粗粒度锁，

459
00:24:44,200 --> 00:24:46,870
你可能陷入死锁，

460
00:24:46,870 --> 00:24:48,280
特别是可能会出现死锁，

461
00:24:48,280 --> 00:24:50,080
如果你跨 RPC 持有锁，

462
00:24:50,080 --> 00:24:54,970
所以我从来不会在 RPC 上持有锁，

463
00:24:58,620 --> 00:25:00,000
而这部分实现了，

464
00:25:00,000 --> 00:25:02,760
作为一个连带效果，

465
00:25:02,760 --> 00:25:05,040
为每个 RPC 启动一个新线程。

466
00:25:06,670 --> 00:25:08,950
这就是整体结构，

467
00:25:08,980 --> 00:25:12,310
还有这个解决方案，

468
00:25:12,310 --> 00:25:13,690
我马上就会和你们分享，

469
00:25:14,170 --> 00:25:16,600
同样，其他结构也是可能的，

470
00:25:16,630 --> 00:25:20,310
但希望这能给你一些想法，

471
00:25:20,340 --> 00:25:21,810
对此有什么问题吗？

472
00:25:22,820 --> 00:25:24,830
右边的线程是什么？

473
00:25:25,650 --> 00:25:26,670
右边的这些？

474
00:25:27,760 --> 00:25:28,270
是的。

475
00:25:28,300 --> 00:25:29,980
这些是传入的消息，

476
00:25:30,890 --> 00:25:32,870
比如，附加 RPC ，

477
00:25:32,870 --> 00:25:36,470
附加 RPC 请求或投票请求，

478
00:25:36,680 --> 00:25:37,730
我想只有两个。

479
00:25:40,840 --> 00:25:42,430
我也有一个问题，

480
00:25:42,430 --> 00:25:44,740
什么是，

481
00:25:45,040 --> 00:25:51,040
让单个线程在条件变量上睡眠是否有好处，

482
00:25:51,040 --> 00:25:53,710
然后只有那个线程，

483
00:25:54,130 --> 00:25:56,950
一个程发送到 apply 通道，

484
00:25:57,070 --> 00:26:03,310
与让每个 RPC 线程发送到 apply 通道相比。

485
00:26:03,310 --> 00:26:06,520
好的， apply 通道的所有东西都要有序，

486
00:26:06,550 --> 00:26:09,130
所以你做的整个日志，

487
00:26:09,510 --> 00:26:12,810
在 Raft 结构中，必须在 apply 通道上发送，

488
00:26:12,810 --> 00:26:15,810
完全按照日志中条目的顺序，

489
00:26:16,540 --> 00:26:18,250
所以这更容易做到，

490
00:26:18,250 --> 00:26:21,520
我发现用单个线程很容易做到，

491
00:26:22,470 --> 00:26:24,390
因为这要经过 Raft 日志，

492
00:26:24,390 --> 00:26:27,690
把条目一个一个地放入 apply 通道，

493
00:26:28,580 --> 00:26:30,500
而且没有必要进行任何协调。

494
00:26:32,000 --> 00:26:33,080
理解了，好的。

495
00:26:34,240 --> 00:26:35,890
好的，像我们大家都知道的，

496
00:26:36,820 --> 00:26:43,420
是的，这是进入了实际使用 Raft 库的服务器。

497
00:26:45,670 --> 00:26:51,520
好的，再多说一句细粒度与粗粒度的对比，

498
00:26:52,060 --> 00:26:57,280
你们中的一些人，这在早期是一个常见的错误，

499
00:26:57,280 --> 00:27:00,370
当你还没做那么多并行编程，

500
00:27:00,760 --> 00:27:05,200
你可能会做，如果你有自己的 RPC 结构，

501
00:27:06,160 --> 00:27:09,580
也许你有像日志和其他一些字段，

502
00:27:09,580 --> 00:27:13,360
有些人，或者有时，这里有[]，

503
00:27:13,360 --> 00:27:16,630
或者不合理的有多个锁，

504
00:27:16,960 --> 00:27:24,010
所以，不是只有一个锁，

505
00:27:25,030 --> 00:27:26,890
但并不是持有很长时间。

506
00:27:36,550 --> 00:27:40,020
而且，我认为在一般情况下，

507
00:27:40,080 --> 00:27:42,360
对代码进行推理有点困难，

508
00:27:42,390 --> 00:27:46,980
例如，你可能会做的常见事情，

509
00:27:46,980 --> 00:27:49,140
如果你有一个 RPC 处理程序，

510
00:27:49,170 --> 00:27:56,090
比如这个 Request 处理程序，包括 Args Reply ，

511
00:27:57,250 --> 00:27:58,600
只是勾勒出这个，

512
00:27:58,600 --> 00:28:01,900
你可能会做 mu.lock ，

513
00:28:03,510 --> 00:28:06,570
和参数一起执行，

514
00:28:06,570 --> 00:28:10,890
也许更新 Raft 结构中的一些状态，

515
00:28:10,890 --> 00:28:12,240
并执行 mu.unlock ，

516
00:28:14,760 --> 00:28:16,650
然后也许做一些其他的事情，

517
00:28:16,650 --> 00:28:19,140
可能与 Raft 结构没有直接关系，

518
00:28:19,140 --> 00:28:21,090
然后可能会再次获取锁，

519
00:28:23,440 --> 00:28:27,220
然后再次更新或读取 Raft 结构，

520
00:28:27,220 --> 00:28:28,300
然后解锁，

521
00:28:28,810 --> 00:28:32,140
所有这些都在一个 RPC 处理程序中。

522
00:28:33,160 --> 00:28:37,800
作为一种思维练习，

523
00:28:37,800 --> 00:28:42,090
这种细粒度锁的风格有什么风险？

524
00:28:42,740 --> 00:28:44,450
我知道这有点做作，

525
00:28:44,450 --> 00:28:47,570
但这是一种合理的普遍现象，

526
00:28:48,120 --> 00:28:51,150
一种你可能会犯的早期错误。

527
00:28:53,970 --> 00:28:55,950
你必须重新检查你的设置，

528
00:28:56,510 --> 00:28:59,390
在每次再次锁定之前，对吗？

529
00:28:59,420 --> 00:29:03,080
是的，上这是原子执行的，

530
00:29:03,110 --> 00:29:04,580
这是原子执行的，

531
00:29:04,700 --> 00:29:07,280
但中间可能会发生很多事情，

532
00:29:07,280 --> 00:29:09,650
例如，新的 RPC 可能进来，

533
00:29:10,910 --> 00:29:12,560
它们可能也在运行，

534
00:29:12,560 --> 00:29:16,940
它们可能更新了 Raft 结构或 Raft 状态，

535
00:29:17,000 --> 00:29:19,520
在这两个关键部分之间，

536
00:29:20,170 --> 00:29:21,250
在一和二之间，

537
00:29:22,090 --> 00:29:24,370
所以这时，

538
00:29:24,610 --> 00:29:26,410
你开始运行关键部分 2 ，

539
00:29:26,530 --> 00:29:28,660
Raft 结构可能是完全不同的，

540
00:29:28,990 --> 00:29:31,000
可能有完全不同的内容，

541
00:29:31,910 --> 00:29:35,150
所以，为了避免这种情况，

542
00:29:35,300 --> 00:29:38,060
我一般的做法是，

543
00:29:38,060 --> 00:29:41,960
有一个关键的部分，

544
00:29:42,600 --> 00:29:44,970
所以我不需要重新检查任何东西，

545
00:29:45,240 --> 00:29:47,340
我不需要在新的重新检查状态，

546
00:29:47,340 --> 00:29:52,580
在第二个关键部分开始时。

547
00:29:53,220 --> 00:29:54,030
这能理解吗？

548
00:29:56,410 --> 00:29:58,780
这个问题表现在不同的方面，

549
00:29:59,170 --> 00:30:03,580
或者这个问题可以以不同的方式表现出来，

550
00:30:03,640 --> 00:30:06,070
但问题总是一样，

551
00:30:06,070 --> 00:30:07,480
如果你执行大量细粒度锁，

552
00:30:07,480 --> 00:30:09,610
你将会有额外的交错，

553
00:30:09,760 --> 00:30:12,970
你必须考虑并确保，

554
00:30:12,970 --> 00:30:19,480
你没有不正确的交错会导致不正确的行为。

555
00:30:22,150 --> 00:30:23,350
我想问一下，

556
00:30:23,350 --> 00:30:28,360
是不是无法避免复查条件，

557
00:30:28,360 --> 00:30:32,770
在你在 RPC 线程中时。

558
00:30:33,560 --> 00:30:37,580
是的，你不能在发送时持有锁，

559
00:30:37,580 --> 00:30:39,020
所以你不应该，

560
00:30:39,200 --> 00:30:42,470
在这里，你不应调用发送 RPC ，

561
00:30:44,030 --> 00:30:46,130
因为当你拿着锁的时候你不能这样做，

562
00:30:46,130 --> 00:30:47,750
因为它们很容易导致死锁，

563
00:30:47,750 --> 00:30:48,890
或者你持有一把锁，

564
00:30:48,890 --> 00:30:51,830
你在仍持有锁的情况下，通过 RPC 发送到一个节点，

565
00:30:51,830 --> 00:30:54,800
那个节点发送 RPC 给你，

566
00:30:54,980 --> 00:30:56,390
但你持有，

567
00:30:56,390 --> 00:30:59,900
你是领导者已经持有了锁和[]结构，

568
00:30:59,900 --> 00:31:02,600
所以响应不能被处理，

569
00:31:02,900 --> 00:31:05,420
也许这两者是相互依存的，

570
00:31:05,660 --> 00:31:07,310
你可能会陷入死锁。

571
00:31:09,450 --> 00:31:12,060
值得注意的一件事是，

572
00:31:12,600 --> 00:31:14,880
我看到一些人在做的事情是，

573
00:31:14,880 --> 00:31:18,120
它们启动一个线程来发送 RPC ，

574
00:31:18,390 --> 00:31:22,860
在那个线程中，它们获取锁来为 RPC 准备参数，

575
00:31:22,980 --> 00:31:25,020
然后他们不加锁地发送 RPC ，

576
00:31:25,140 --> 00:31:26,610
你可以做这个，

577
00:31:26,610 --> 00:31:29,880
但它通常是较少的交错，

578
00:31:29,880 --> 00:31:32,220
如果为 RPC 生成参数，

579
00:31:32,280 --> 00:31:34,110
在你启动线程之前，

580
00:31:34,140 --> 00:31:35,670
它发送的。

581
00:31:38,420 --> 00:31:41,210
说得好，我们会看到，我们在稍后展示，

582
00:31:41,210 --> 00:31:41,780
事实上在。

583
00:31:42,140 --> 00:31:44,330
但这不是导致，

584
00:31:44,360 --> 00:31:47,990
所以，有时它取决于实现，

585
00:31:47,990 --> 00:31:51,620
我认为让其他 RPC 看到这些变化是有益的，

586
00:31:51,620 --> 00:31:55,580
例如，如果其他 RPC 取得了进展，

587
00:31:55,580 --> 00:31:58,970
你希望从最新的日志索引开始。

588
00:32:00,250 --> 00:32:05,260
可能是，这取决于你到底做了什么，

589
00:32:05,350 --> 00:32:08,140
比如你的实现是如何工作的，

590
00:32:08,380 --> 00:32:10,870
我不会那么做，

591
00:32:11,170 --> 00:32:14,020
至少，我不认为我做了你建议的事，

592
00:32:14,020 --> 00:32:16,150
当我向所有节点发送 RPC 时，

593
00:32:16,150 --> 00:32:18,490
所有的节点都会得到相同的参数，

594
00:32:19,980 --> 00:32:21,210
在这两者之间没有变化。

595
00:32:26,350 --> 00:32:31,690
好的，好的，让我来谈一谈实现的问题，

596
00:32:31,690 --> 00:32:35,260
大家能看到屏幕吗？

597
00:32:35,870 --> 00:32:37,040
抱歉，我有一个跟进的问题。

598
00:32:37,880 --> 00:32:39,140
嗯。

599
00:32:39,170 --> 00:32:40,310
所以我想你提到过，

600
00:32:40,310 --> 00:32:44,690
我们不应该加锁，发送东西到 apply 通道。

601
00:32:45,720 --> 00:32:49,260
是的，尽管，让我，

602
00:32:49,500 --> 00:32:51,450
是的，这很冒险，

603
00:32:51,840 --> 00:32:54,450
因为当你持有锁的时候，

604
00:32:54,450 --> 00:32:55,800
你发送到 apply 通道，

605
00:32:55,800 --> 00:32:58,080
你也可能阻塞在 apply 通道上，

606
00:32:58,080 --> 00:33:03,510
因为另一端必须读取，

607
00:33:03,510 --> 00:33:04,710
在你解锁之前，

608
00:33:05,590 --> 00:33:06,550
当然，你有缓冲，

609
00:33:06,550 --> 00:33:08,110
缓冲会稍微改变一点，

610
00:33:08,110 --> 00:33:09,820
假设我们有没有缓冲的通道，

611
00:33:09,820 --> 00:33:12,040
只是一个无缓冲的通道，

612
00:33:12,880 --> 00:33:17,080
所以读取者，如果没有读取者，

613
00:33:17,830 --> 00:33:19,570
那么这个写入者就会阻塞，

614
00:33:20,770 --> 00:33:22,270
也许还会持有锁，

615
00:33:22,360 --> 00:33:26,170
这可能会导致后面的问题，

616
00:33:26,470 --> 00:33:27,730
并导致死锁。

617
00:33:30,460 --> 00:33:34,150
在那上面，这不对吗，

618
00:33:34,150 --> 00:33:36,790
apply 通道永远不会，

619
00:33:37,150 --> 00:33:41,170
比如调用 Raft 的客户端，

620
00:33:41,500 --> 00:33:43,600
永远不会持有锁，它们是。

621
00:33:43,630 --> 00:33:45,910
你不是，不是真的，

622
00:33:46,370 --> 00:33:49,460
这是一种位于顶部的服务器，

623
00:33:50,140 --> 00:33:53,740
调用 Start ，并从 apply 通道读取，

624
00:33:54,360 --> 00:33:55,560
但它调用 Start ，

625
00:33:55,800 --> 00:33:58,050
Start 取决于你如何做到它，

626
00:33:58,050 --> 00:33:59,130
你从一个线程开始，

627
00:33:59,160 --> 00:34:02,100
然后在那个线程进入 Raft 库，

628
00:34:02,100 --> 00:34:03,600
至少在我的实现中，

629
00:34:03,600 --> 00:34:05,910
Start 函数所做的第一件事是，

630
00:34:05,910 --> 00:34:07,140
获取 Raft 锁，

631
00:34:10,250 --> 00:34:12,710
它不能获取 Raft 锁，

632
00:34:12,710 --> 00:34:15,530
要么是 apply 线程已经持有它，

633
00:34:15,530 --> 00:34:17,210
想要在 apply 通道上获取一些东西，

634
00:34:17,480 --> 00:34:19,670
但服务器现在不会从 apply 通道读取，

635
00:34:19,670 --> 00:34:20,960
取决于你如何设置它，

636
00:34:20,960 --> 00:34:22,220
但正如你所说的，

637
00:34:22,220 --> 00:34:23,090
这其中存在风险，

638
00:34:23,120 --> 00:34:24,230
你得小心一点。

639
00:34:25,190 --> 00:34:29,930
那么，解决方案是不是创建一个新线程？

640
00:34:29,930 --> 00:34:31,610
是的，这里有各种可能的解决方案，

641
00:34:31,640 --> 00:34:34,850
我只是在警告你，在提醒你，

642
00:34:34,850 --> 00:34:37,910
你必须考虑一下如何安排这件事。

643
00:34:40,710 --> 00:34:41,310
好的？

644
00:34:42,380 --> 00:34:46,310
但是，使用单个线程是不是不够，

645
00:34:46,310 --> 00:34:49,510
因为放入 apply 通道的线程，

646
00:34:49,510 --> 00:34:51,640
会继续关注数据，

647
00:34:51,640 --> 00:34:53,590
所以它仍然需要获得锁。

648
00:34:54,550 --> 00:34:57,190
好的，让我回到这里，

649
00:34:57,190 --> 00:34:59,350
很容易看出，这里的死锁，

650
00:34:59,560 --> 00:35:01,210
如果你在 apply 通道，

651
00:35:01,240 --> 00:35:02,740
你不是在读取 apply 通道，

652
00:35:02,740 --> 00:35:05,260
因为你在调用 Start ，

653
00:35:05,870 --> 00:35:07,640
我可能会得到，

654
00:35:08,600 --> 00:35:12,380
而 Start 不能运行，因为这个持有一把锁，

655
00:35:12,380 --> 00:35:14,420
但它不能解锁，

656
00:35:14,420 --> 00:35:15,800
因为它不能写入 apply 通道，

657
00:35:15,800 --> 00:35:16,940
因为没有读取者，

658
00:35:17,090 --> 00:35:19,880
很容易构建场景，

659
00:35:19,880 --> 00:35:20,990
在那里你会陷入死锁，

660
00:35:20,990 --> 00:35:22,700
当然，你可以避免所有这些死锁，

661
00:35:22,760 --> 00:35:23,690
这就是我们的目标，

662
00:35:23,690 --> 00:35:25,550
而避免这些死锁的一种方法是，

663
00:35:25,550 --> 00:35:28,100
不要在读写通道时持有锁，

664
00:35:31,260 --> 00:35:32,490
也有其他方法可以做到这一点，

665
00:35:34,370 --> 00:35:36,500
我只是告诉你在我的实现中，

666
00:35:36,590 --> 00:35:37,850
我发现这很方便

667
00:35:37,850 --> 00:35:40,790
在写入通道时，不要持有锁，

668
00:35:41,380 --> 00:35:42,940
我认为总的来说，这是一种糟糕的做法。

669
00:35:50,270 --> 00:35:53,480
好的，回到代码上来。

670
00:35:56,450 --> 00:35:59,900
好的，我将向你们展示一个特定的实现，

671
00:35:59,900 --> 00:36:04,190
再次，这是我在一月份编写的一个实现，

672
00:36:04,190 --> 00:36:05,120
为了备课，

673
00:36:05,120 --> 00:36:07,160
所以它没有什么特别之处，

674
00:36:07,280 --> 00:36:09,470
纯粹是为了我自己，

675
00:36:09,860 --> 00:36:12,140
我相信关于它的一些事情，

676
00:36:12,140 --> 00:36:14,240
你会强烈反对的东西，

677
00:36:14,510 --> 00:36:16,880
但这给你一种感觉，我做了什么。

678
00:36:17,500 --> 00:36:19,420
所以我开始了，

679
00:36:19,450 --> 00:36:20,950
这就是 Raft 结构，

680
00:36:21,070 --> 00:36:23,440
我从图 2 复制的，

681
00:36:23,590 --> 00:36:24,580
正如你将看到的，

682
00:36:24,580 --> 00:36:25,060
在代码中，

683
00:36:25,060 --> 00:36:27,280
代码中有很多是图 2 的，

684
00:36:27,790 --> 00:36:30,760
这是你做的主要东西，

685
00:36:30,760 --> 00:36:31,930
可能需要指出的主要问题是，

686
00:36:31,930 --> 00:36:33,310
这是 Mutex ，

687
00:36:33,310 --> 00:36:34,420
这是 Raft 锁，

688
00:36:34,420 --> 00:36:37,570
我的代码将在所有地方获取释放，

689
00:36:37,600 --> 00:36:39,160
以一种非常粗粒度的方式，

690
00:36:39,910 --> 00:36:40,570
剩下的就是，

691
00:36:40,570 --> 00:36:42,580
正如你所期望的，

692
00:36:42,580 --> 00:36:46,570
持久性状态，易失性状态，领导者状态和快照状态，

693
00:36:46,600 --> 00:36:48,220
我不会太多地谈论快照，

694
00:36:48,220 --> 00:36:50,320
因为这是我们周五要做的事。

695
00:36:51,560 --> 00:36:54,590
基本上就是这样，

696
00:36:54,590 --> 00:36:58,010
然后，有趣的是，我将自下而上，

697
00:36:58,010 --> 00:37:00,050
比如在一开始，会发生什么，

698
00:37:00,050 --> 00:37:02,330
所以在某种程度上， tester ，

699
00:37:11,450 --> 00:37:17,020
tester 将调用 Make ，

700
00:37:17,020 --> 00:37:22,450
这是我的 Make 调用，

701
00:37:22,690 --> 00:37:26,170
它构建了 Raft 状态，

702
00:37:26,560 --> 00:37:29,950
apply 通道，还有我提到的条件变量，

703
00:37:30,430 --> 00:37:34,420
它将自己设置为跟随者，选举时间到了，

704
00:37:34,920 --> 00:37:36,990
我稍后会谈到这一点，

705
00:37:37,050 --> 00:37:40,020
一开始，把其他一些部分做成一个空的日志，

706
00:37:40,560 --> 00:37:45,090
然后，然后生成两个 goroutine ，

707
00:37:45,150 --> 00:37:48,930
一个是 applier ，这是在 apply 通道上写入的线程，

708
00:37:49,140 --> 00:37:50,940
然后是一个 ticker ，

709
00:37:50,940 --> 00:37:55,830
运行 ticker 代码，

710
00:37:57,460 --> 00:38:00,940
所以，这里没有什么特别令人兴奋的事情。

711
00:38:01,300 --> 00:38:04,810
那么让我们来看一下 ticker 代码，

712
00:38:04,960 --> 00:38:06,310
有些人问到，

713
00:38:06,310 --> 00:38:10,720
你是不是应该把所有东西都组织成一个文件，多个文件，

714
00:38:10,990 --> 00:38:12,010
当然，一切都取决于你，

715
00:38:12,010 --> 00:38:13,780
你到底最方便的是什么，

716
00:38:13,780 --> 00:38:15,280
找到你的代码，

717
00:38:15,280 --> 00:38:17,620
在这种情况下，我使用多个文件组成，

718
00:38:17,620 --> 00:38:22,570
有 vote.go ，处理所有选择部分。

719
00:38:25,070 --> 00:38:26,330
那么让我们来看一下 ticker ，

720
00:38:29,560 --> 00:38:32,470
所以， ticker 每 50 毫秒运行一次，

721
00:38:32,590 --> 00:38:35,620
它调用这个函数 tick ，

722
00:38:35,620 --> 00:38:37,420
函数 tick 在这里，

723
00:38:37,690 --> 00:38:38,770
它获取，

724
00:38:38,770 --> 00:38:40,930
你会看到它到处都是，

725
00:38:40,930 --> 00:38:42,940
它获取 Raft 锁，

726
00:38:43,300 --> 00:38:47,860
使用 defer 来确保无论我何时离开函数，

727
00:38:48,130 --> 00:38:50,140
锁将被释放，

728
00:38:50,590 --> 00:38:53,920
然后检查什么是领导者，

729
00:38:53,920 --> 00:38:56,320
如果是领导者，做一件事，

730
00:38:56,320 --> 00:38:58,420
如果它不是领导者，这意味着它是一个跟随者，

731
00:38:58,480 --> 00:39:03,470
那就检查一下选举时间是不是过去了，

732
00:39:03,860 --> 00:39:05,990
所以我计算的方法是，

733
00:39:05,990 --> 00:39:07,400
我获取现在的时间，

734
00:39:07,670 --> 00:39:11,630
并查看当前时间是否已过，

735
00:39:11,660 --> 00:39:15,620
now 是否过了选举时间，

736
00:39:17,430 --> 00:39:19,650
如果是这样的话，我将开始选举

737
00:39:19,680 --> 00:39:24,060
首先，我将再次设置选举超时，

738
00:39:24,060 --> 00:39:25,770
如图 2 所示，

739
00:39:26,130 --> 00:39:27,780
然后开始选举，

740
00:39:30,120 --> 00:39:31,830
在设置选举超时方面，

741
00:39:31,830 --> 00:39:35,460
第一件事，我做的方式，

742
00:39:35,460 --> 00:39:37,980
选举超时设置为一秒，

743
00:39:38,010 --> 00:39:40,290
从某种意义上说，我是从，

744
00:39:40,980 --> 00:39:42,480
稍等一下，

745
00:39:42,510 --> 00:39:45,600
我们的聊天中有一个很好的理由，

746
00:39:45,690 --> 00:39:51,340
选择超时一秒，

747
00:39:51,340 --> 00:39:52,990
当然，你需要，

748
00:39:52,990 --> 00:39:56,290
在一段时间内随机化节点，

749
00:39:56,620 --> 00:39:59,530
我使用的间隔是 0 到 300 毫秒，

750
00:39:59,830 --> 00:40:02,860
再加上选举超时时间，

751
00:40:02,860 --> 00:40:07,780
所以，每个节点会有一个略有不同的选举超时时间，

752
00:40:08,140 --> 00:40:12,820
所处，它们会调用，在不同的阶段采取行动，

753
00:40:12,820 --> 00:40:14,680
我们有一点[]，

754
00:40:14,770 --> 00:40:17,710
只有一人或几个会开始选举。

755
00:40:19,180 --> 00:40:19,990
我有个问题。

756
00:40:19,990 --> 00:40:20,380
嗯。

757
00:40:20,590 --> 00:40:26,110
所以，你每隔 50 毫秒检查一次，

758
00:40:26,110 --> 00:40:28,630
这不会导致一场竞争激烈的选举吗，

759
00:40:29,360 --> 00:40:30,950
就像因为你是，

760
00:40:31,220 --> 00:40:32,840
它没有这个限制，

761
00:40:33,140 --> 00:40:38,800
从技术上讲，你可以得到任何，

762
00:40:38,800 --> 00:40:42,340
从 0 到 300 的。

763
00:40:42,920 --> 00:40:45,590
不，我可以从 1 秒到 300 ，

764
00:40:45,650 --> 00:40:47,060
一秒到，

765
00:40:47,210 --> 00:40:51,050
1000 毫秒到 1300 毫秒之间的任意值。

766
00:40:51,230 --> 00:40:54,320
对，所以，但到了最后，

767
00:40:54,320 --> 00:40:58,040
因为你每隔 50 毫秒才检查一次，

768
00:40:58,040 --> 00:40:59,390
这不是给了。

769
00:40:59,950 --> 00:41:02,050
它为我们提供了更多的粗粒度，但已经足够了。

770
00:41:02,580 --> 00:41:03,180
好的。

771
00:41:03,660 --> 00:41:06,360
我的意思是这里有两个限制，

772
00:41:06,360 --> 00:41:08,220
你不想太慢，

773
00:41:08,790 --> 00:41:10,890
因为这意味着，

774
00:41:10,890 --> 00:41:13,410
你需要很长时间才能开始新的选举，

775
00:41:13,410 --> 00:41:15,090
你不想太快，

776
00:41:15,090 --> 00:41:17,550
因为那样你就会开始太多的选举，

777
00:41:17,550 --> 00:41:19,290
你需要留出一段时间

778
00:41:19,290 --> 00:41:22,890
让选举失去一些，一些投票可能会延迟，

779
00:41:23,220 --> 00:41:26,820
你不想在之前重启，

780
00:41:27,090 --> 00:41:29,160
在候选者改变之前，

781
00:41:29,160 --> 00:41:32,220
与跟随者做几轮的通信。

782
00:41:34,810 --> 00:41:38,410
好的，你们一些人在猜测我的大写字母 L ，

783
00:41:38,710 --> 00:41:40,600
这只是一种实践，

784
00:41:40,660 --> 00:41:42,610
对于这个实现，

785
00:41:42,610 --> 00:41:44,020
我遵循了惯例，

786
00:41:44,020 --> 00:41:45,430
可能在某些地方打破了惯例，

787
00:41:45,430 --> 00:41:46,840
但我遵循的惯例是，

788
00:41:47,290 --> 00:41:53,350
如果调用者，被调用者假设锁被持有，

789
00:41:53,530 --> 00:41:56,290
然后我在函数后面加一个大写的 L ，

790
00:41:56,920 --> 00:42:01,000
所以 startElection 假设调用者持有锁，

791
00:42:01,030 --> 00:42:03,370
任何带有 L 的函数，

792
00:42:03,430 --> 00:42:05,680
假设了这一惯例，

793
00:42:07,660 --> 00:42:11,470
所以这纯粹是我自己的一种编码预防，

794
00:42:11,470 --> 00:42:14,560
我认为在这个实现中尝试它是一件有趣的事情，

795
00:42:15,010 --> 00:42:16,180
可能并不总是这样，

796
00:42:16,180 --> 00:42:17,770
但我在这里是这么做的。

797
00:42:20,720 --> 00:42:21,500
有什么问题吗？

798
00:42:22,500 --> 00:42:24,510
或者我们应该看看选举部分。

799
00:42:28,510 --> 00:42:31,510
好的，让我们来看看选举部分，

800
00:42:31,510 --> 00:42:34,690
你会看到这个 startElection ，

801
00:42:34,690 --> 00:42:36,550
所以它不需要锁，

802
00:42:36,550 --> 00:42:39,670
因为我假调用者持有它，

803
00:42:40,060 --> 00:42:42,070
基本上按照图 2 所示，

804
00:42:42,160 --> 00:42:44,320
首先，规则是，

805
00:42:44,320 --> 00:42:47,020
你必须对 currentTerm 加 1 ，

806
00:42:47,020 --> 00:42:47,770
所以我就这么做了，

807
00:42:47,770 --> 00:42:49,510
我把 state 设为 Candidate ，

808
00:42:49,510 --> 00:42:52,450
也是由图 2 指示的，

809
00:42:52,750 --> 00:42:55,600
我记录 votedFor 给自己，

810
00:42:55,600 --> 00:42:57,220
这也是图 2 的一部分，

811
00:42:57,520 --> 00:43:00,370
然后这是为了实验 C ，

812
00:43:00,370 --> 00:43:02,080
对于 C ，你已经知道了，

813
00:43:02,170 --> 00:43:05,590
每当你改变状态时，都应该持久化，

814
00:43:05,800 --> 00:43:07,450
你必须在这之后持久化，

815
00:43:07,720 --> 00:43:09,770
所以，就是这样，

816
00:43:09,800 --> 00:43:12,440
你可以看到我的调试信息，

817
00:43:12,530 --> 00:43:14,870
就像 Jose 所说的，

818
00:43:14,870 --> 00:43:16,880
我总是让来源在开头，

819
00:43:16,880 --> 00:43:18,770
这简化了我的生活，

820
00:43:19,160 --> 00:43:20,600
我还有一堆其他类型的，

821
00:43:20,900 --> 00:43:24,350
我没有像 Jose 那样好的 Perl 脚本或 Python 脚本，

822
00:43:24,350 --> 00:43:26,180
但我有一堆 Unix 脚本，

823
00:43:26,180 --> 00:43:29,540
我用它来解析日志，打印和处理，

824
00:43:31,090 --> 00:43:34,210
然后我们调用 requestVotesL ，

825
00:43:34,240 --> 00:43:35,980
requestVotesL 就在这里，

826
00:43:36,430 --> 00:43:39,970
你很快就会看到，这是怎么回事，

827
00:43:39,970 --> 00:43:44,230
但是如 Cel 所说，

828
00:43:44,230 --> 00:43:48,550
我们预先构建参数，

829
00:43:48,550 --> 00:43:52,720
让我来，看看 RequestVoteArgs 参数，

830
00:43:52,990 --> 00:43:55,990
你在这里的数据，

831
00:43:55,990 --> 00:44:01,820
它包含了图 2 所示的内容，

832
00:44:01,820 --> 00:44:05,930
包含 Term CandiateId LastLogIndex LastLogTerm ，

833
00:44:06,410 --> 00:44:10,490
还有一件事，也许值得指出的是，

834
00:44:10,490 --> 00:44:13,130
我尝试编写 String 函数，

835
00:44:13,520 --> 00:44:17,150
这允许 Go ，当你输入 %v 时，

836
00:44:17,150 --> 00:44:19,280
我们将调用这个结构的 String 函数，

837
00:44:19,580 --> 00:44:24,680
这让你可以格式化结构，

838
00:44:24,680 --> 00:44:26,810
（格式化） request ，以一种很好的方式，

839
00:44:26,810 --> 00:44:30,470
再次，这对我有帮助，帮助我处理我的日志，

840
00:44:30,810 --> 00:44:34,740
所以我的每一个 request 参数，

841
00:44:34,740 --> 00:44:36,840
我用一种标准的方式打印，

842
00:44:36,840 --> 00:44:39,180
再次简化日志处理。

843
00:44:45,730 --> 00:44:49,390
好的，回到开始选举，

844
00:44:49,390 --> 00:44:52,840
所以多个跟随者同时开始，

845
00:44:52,840 --> 00:44:56,080
它们中的一个首先开始，

846
00:44:56,080 --> 00:44:57,220
它将成为候选者，

847
00:44:57,580 --> 00:44:58,960
而且它执行 requestVotesL ，

848
00:44:58,960 --> 00:45:01,510
在这里的结构参数，

849
00:45:01,780 --> 00:45:04,720
把 currentTerm 放在这里，将会是 1 ，

850
00:45:04,720 --> 00:45:06,310
如果这是第一次选举，

851
00:45:06,310 --> 00:45:07,390
我是谁，

852
00:45:07,600 --> 00:45:14,020
log.lastindex ，假设是 0 或 1 ，

853
00:45:14,550 --> 00:45:16,500
我想应该是 0 ，

854
00:45:16,800 --> 00:45:22,680
然后条目中的 Term ，即 term 0 ，

855
00:45:23,310 --> 00:45:25,410
因为我们在做的，

856
00:45:25,410 --> 00:45:26,820
我们正在进行选举，

857
00:45:26,820 --> 00:45:30,360
我们需要展示之前的是什么。

858
00:45:32,990 --> 00:45:33,860
好的。

859
00:45:34,400 --> 00:45:35,390
然后在这里，

860
00:45:35,390 --> 00:45:38,420
这是我发送 RPC 的标准方式，

861
00:45:38,630 --> 00:45:40,880
只是遍历所有节点，

862
00:45:40,880 --> 00:45:43,040
当然，跳过我自己，

863
00:45:43,040 --> 00:45:44,750
我算了我投了自己的票，

864
00:45:44,750 --> 00:45:46,190
所以我把票数设为 1 ，

865
00:45:46,490 --> 00:45:50,750
然后我启动一个线程，

866
00:45:50,750 --> 00:45:55,040
这是将 RPC 发送到每个单独的节点，

867
00:45:55,630 --> 00:45:58,540
第一个参数是 RPC 发送到的节点，

868
00:45:58,540 --> 00:46:00,070
它们都得到相同的参数，

869
00:46:00,250 --> 00:46:02,320
并传递 votes 的地址，

870
00:46:02,320 --> 00:46:05,020
这样它们可以有一个共同的计票。

871
00:46:07,870 --> 00:46:09,100
对于这个，有什么问题吗？

872
00:46:10,080 --> 00:46:14,070
所以，对于 requestVote ，锁被持有，

873
00:46:14,070 --> 00:46:15,720
然后你会发送。

874
00:46:16,020 --> 00:46:16,740
是的，所以。

875
00:46:16,740 --> 00:46:17,520
RPC 。

876
00:46:17,730 --> 00:46:19,800
是的，在这里的 requestVote 中，

877
00:46:19,800 --> 00:46:23,190
锁是不是在这个函数中持有的？

878
00:46:24,840 --> 00:46:26,970
不，因为这是一个新线程。

879
00:46:27,030 --> 00:46:28,740
是的，新的线程，它没有持有锁，

880
00:46:28,800 --> 00:46:30,870
看我的命名惯例暗示，

881
00:46:30,870 --> 00:46:32,160
因为那里没有 L 。

882
00:46:35,580 --> 00:46:36,150
好的。

883
00:46:36,600 --> 00:46:38,070
所以， requestVote ，

884
00:46:38,070 --> 00:46:40,860
requestVote 当它开始运行时，

885
00:46:40,860 --> 00:46:42,090
它没有锁，

886
00:46:42,090 --> 00:46:44,820
因为只有父线程持有锁，

887
00:46:44,820 --> 00:46:47,460
而这个线程没有持有锁，

888
00:46:47,610 --> 00:46:49,080
它没有锁。

889
00:46:51,150 --> 00:46:56,760
所以，每个节点的每个 requestVote 都运行一个线程，

890
00:46:56,910 --> 00:46:59,550
它分配一个 reply 结构，

891
00:46:59,550 --> 00:47:02,220
然后它发出 RPC ，

892
00:47:02,250 --> 00:47:04,440
这一切都是在没有持有锁的情况下完成的，

893
00:47:04,920 --> 00:47:07,230
然后，在某个时刻，我们得到了回复，

894
00:47:07,620 --> 00:47:10,230
然后在那个时候，在响应处理程序中，

895
00:47:10,230 --> 00:47:11,910
我从从日志的开始获取，

896
00:47:12,060 --> 00:47:15,240
并执行任何必要的响应处理。

897
00:47:17,260 --> 00:47:18,940
好的，继续。

898
00:47:18,940 --> 00:47:20,680
好的，你之前说过，

899
00:47:20,680 --> 00:47:22,180
你不应该持有锁，

900
00:47:22,180 --> 00:47:25,720
当你执行 RPC 调用时，

901
00:47:25,720 --> 00:47:27,940
你的意思是它是可以的，

902
00:47:28,270 --> 00:47:30,250
对于 RPC 调用本身来说是可以的，

903
00:47:30,250 --> 00:47:32,680
在 RPC 调用持有锁，

904
00:47:32,680 --> 00:47:34,090
但不是你在调用的时候。

905
00:47:34,090 --> 00:47:35,710
是的，不是在这里，

906
00:47:35,710 --> 00:47:38,890
当你通过网络发送它时。

907
00:47:39,220 --> 00:47:41,740
但是，如果你是在 RPC 内完成的，这是可以的。

908
00:47:41,830 --> 00:47:43,000
或者甚至回复处理程序，

909
00:47:43,000 --> 00:47:46,030
考虑这个是回复处理程序运行，

910
00:47:46,270 --> 00:47:47,470
所以回复回来，

911
00:47:47,740 --> 00:47:50,470
现在有了回复，你必须处理回复。

912
00:47:51,950 --> 00:47:54,350
哦，我是说，在 RequestVote 中，

913
00:47:54,350 --> 00:47:58,310
大些的 R request ，大写的 V vote ，

914
00:47:58,640 --> 00:48:01,640
持有锁是可以的，至少在那里。

915
00:48:02,220 --> 00:48:04,140
你想持有锁的地方是哪里？

916
00:48:04,140 --> 00:48:07,710
大写的 RequestVote ，

917
00:48:08,100 --> 00:48:09,870
是的，这就是我要说的。

918
00:48:10,440 --> 00:48:11,070
这个？

919
00:48:11,620 --> 00:48:13,150
不，是这里的函数，

920
00:48:14,080 --> 00:48:15,640
它是 RequestVote ，

921
00:48:15,640 --> 00:48:19,690
但是我想它是大写的 R ，

922
00:48:21,890 --> 00:48:24,740
你可能有一个方法，

923
00:48:24,740 --> 00:48:26,660
是 RPC 调用。

924
00:48:26,660 --> 00:48:28,640
我认为是接收方的 RPC 。

925
00:48:28,730 --> 00:48:32,570
是的，我们稍后当然会看到，

926
00:48:32,570 --> 00:48:35,510
这是一种全新的思考方式，

927
00:48:35,510 --> 00:48:36,620
完全不同的机器，

928
00:48:36,620 --> 00:48:39,450
是的，绝对是。

929
00:48:39,450 --> 00:48:42,000
所以，这里有两个地方持有锁，

930
00:48:42,000 --> 00:48:45,870
例如在请求处理程序中和在回复处理程序中。

931
00:48:48,640 --> 00:48:49,420
好的，谢谢。

932
00:48:50,420 --> 00:48:52,130
抱歉，抱歉弄糊涂了，

933
00:48:52,550 --> 00:48:54,290
我很高兴我们澄清了这一点。

934
00:48:54,680 --> 00:48:57,140
好的，所以持有锁，

935
00:48:57,140 --> 00:48:59,300
然后在日志中放入一个 print 语句，

936
00:48:59,300 --> 00:49:01,220
这样我以后我可以研究它，

937
00:49:01,640 --> 00:49:03,650
当然，还有基本的检查，

938
00:49:03,650 --> 00:49:08,510
图 2 没有说太多，

939
00:49:08,510 --> 00:49:14,360
但这是适用于所有服务器的规则，

940
00:49:14,360 --> 00:49:18,520
term 比 reply.Term 大，

941
00:49:18,520 --> 00:49:19,810
比 currentTerm ，

942
00:49:19,870 --> 00:49:23,290
然后你必须切换到跟随者状态，

943
00:49:23,290 --> 00:49:28,120
对于回复你的 term ，

944
00:49:28,150 --> 00:49:29,440
我们马上就能看到这一点。

945
00:49:30,340 --> 00:49:33,640
所以如果这是候选者，

946
00:49:33,940 --> 00:49:36,610
出现更到的 term ，

947
00:49:36,730 --> 00:49:39,820
就是后退，成为一个跟随者。

948
00:49:43,310 --> 00:49:47,550
好的，所以，如果跟随者回答说，

949
00:49:47,550 --> 00:49:48,930
我投票，

950
00:49:49,050 --> 00:49:53,130
然后我增加共享的 votes 加 1 ，

951
00:49:53,130 --> 00:49:54,810
这完全是安全的，

952
00:49:54,810 --> 00:49:56,850
因为我持有 Raft 锁，

953
00:49:57,180 --> 00:49:58,470
所以这是一个串行的，

954
00:49:58,470 --> 00:50:01,590
所以会有很多事情发生，

955
00:50:01,590 --> 00:50:03,240
会有多个回复，

956
00:50:03,420 --> 00:50:04,890
它们可以并行运行，

957
00:50:05,010 --> 00:50:06,270
但它们会串行化，

958
00:50:06,270 --> 00:50:07,290
因为 Raft 锁，

959
00:50:09,390 --> 00:50:10,710
所以把选票加起来，

960
00:50:10,740 --> 00:50:13,110
如果投票超过，

961
00:50:13,170 --> 00:50:15,660
如果我拥有多数选票，

962
00:50:15,660 --> 00:50:20,970
如果我还在和开始一样的 term ，

963
00:50:20,970 --> 00:50:23,760
当我开始选举时，

964
00:50:23,880 --> 00:50:25,470
然后我就会成为领导者，

965
00:50:25,650 --> 00:50:28,620
我会发出第一轮心跳，

966
00:50:28,620 --> 00:50:29,910
我们稍后会看到。

967
00:50:31,820 --> 00:50:33,560
是的，所以我想看两件事，

968
00:50:33,590 --> 00:50:35,180
让我们看看 becomeLeaderL 是什么，

969
00:50:35,180 --> 00:50:37,100
becomeLeaderL 就在这里，

970
00:50:37,490 --> 00:50:39,290
大写的 L ，

971
00:50:39,290 --> 00:50:41,510
因为它已经持有锁，

972
00:50:41,510 --> 00:50:43,910
将状态设置为领导者状态，

973
00:50:44,390 --> 00:50:47,630
并且初始化 nextIndex ，

974
00:50:48,050 --> 00:50:51,080
nextIndex 上节课说的，是一个猜测，

975
00:50:51,080 --> 00:50:52,280
这是一个乐观的猜测，

976
00:50:52,340 --> 00:50:56,150
我的 lastindex 加 1 ，

977
00:50:56,740 --> 00:50:59,710
所以假设所有的跟随者都是最新的，

978
00:51:00,500 --> 00:51:01,220
如果它们不是，

979
00:51:01,220 --> 00:51:03,020
我们以后会看到它们会回退，

980
00:51:04,120 --> 00:51:08,900
会放弃附加条目，并重试。

981
00:51:10,740 --> 00:51:11,730
好的，很好，

982
00:51:12,300 --> 00:51:13,560
所以，它已经成为了领导者，

983
00:51:13,590 --> 00:51:15,720
让我看看 newTermL ，

984
00:51:17,550 --> 00:51:20,580
所以 newTermL 没有什么很兴奋的东西，

985
00:51:20,580 --> 00:51:24,060
就是说我可以进入下个 term ，

986
00:51:24,060 --> 00:51:26,640
它由调用者提供，

987
00:51:26,940 --> 00:51:28,800
我将 votedFor 设置为 -1 ，

988
00:51:28,800 --> 00:51:30,660
因为我在这个 term 还没有投票，

989
00:51:30,660 --> 00:51:33,240
我把状态改成了跟随者，

990
00:51:33,330 --> 00:51:35,910
因为这是一种需要持久化的状态，

991
00:51:35,910 --> 00:51:36,810
我调用 persist 。

992
00:51:41,480 --> 00:51:43,790
好的，这就是候选者一方，

993
00:51:44,000 --> 00:51:48,470
现在我们想看看跟随者一方，

994
00:51:49,080 --> 00:51:53,640
或者可能是另一位候选者，也在并行运行选举。

995
00:51:55,170 --> 00:51:58,500
所以，这是 RequestVote 处理程序，

996
00:51:58,530 --> 00:51:59,580
这是在运行，

997
00:51:59,580 --> 00:52:02,010
这是在另一台机器上运行的代码，

998
00:52:02,010 --> 00:52:03,000
如果你愿意，

999
00:52:03,000 --> 00:52:08,010
我在回答这个问题时有一点困惑，

1000
00:52:08,670 --> 00:52:10,890
你成功的第一件事是，

1001
00:52:11,370 --> 00:52:14,220
由 RPC 库系统投票，

1002
00:52:14,220 --> 00:52:15,120
有它自己的线程，

1003
00:52:15,120 --> 00:52:15,900
它做的第一件事是，

1004
00:52:15,900 --> 00:52:18,990
它获取 Raft 结构的锁，

1005
00:52:20,420 --> 00:52:25,240
这基本上遵循了图 2 所示的规则，

1006
00:52:25,270 --> 00:52:27,520
这些规则是对所有服务器的，

1007
00:52:27,520 --> 00:52:32,630
如果 args.Term 大于 currentTerm ，

1008
00:52:32,630 --> 00:52:35,180
那么我应该切换到这个 newTerm ，

1009
00:52:35,180 --> 00:52:37,280
仅此而已，

1010
00:52:37,940 --> 00:52:42,410
然后在这里，有趣的部分是，

1011
00:52:42,410 --> 00:52:44,570
这都与图[]有关，

1012
00:52:44,570 --> 00:52:47,300
它的意思是[]图 7 ，

1013
00:52:47,600 --> 00:52:49,940
它的意思是最新的，

1014
00:52:49,940 --> 00:52:52,610
你能成为一名领导者，如果你是最新的，

1015
00:52:53,040 --> 00:52:56,400
所以我计算 uptodate 函数，

1016
00:52:56,400 --> 00:53:02,400
它基于 last index 或 last index 中的 term ，

1017
00:53:03,000 --> 00:53:04,560
所以它说 uptodate 是，

1018
00:53:04,620 --> 00:53:09,180
如果参数中的 term 等于 myTerm ，

1019
00:53:09,450 --> 00:53:15,220
调用候选者，

1020
00:53:15,250 --> 00:53:18,370
LastLogIndex 大于等于 myIndex ，

1021
00:53:18,370 --> 00:53:21,370
所以，等于最长的日志的 term 会获胜，

1022
00:53:21,940 --> 00:53:27,670
或者如果候选者高于 term ，

1023
00:53:27,670 --> 00:53:29,950
那么它总是赢，候选者就赢了。

1024
00:53:31,110 --> 00:53:32,550
这意味着它必须是最新的，

1025
00:53:32,550 --> 00:53:33,720
因此计算 uptodate ，

1026
00:53:33,720 --> 00:53:35,880
然后通过不同的情况，

1027
00:53:35,880 --> 00:53:37,950
如果 term 小于 currentTerm ，

1028
00:53:38,160 --> 00:53:41,580
这意味着调用者落后了，

1029
00:53:41,670 --> 00:53:43,860
所以 VoteGranted 为 false ，

1030
00:53:43,860 --> 00:53:44,880
然后在另一种情况下，

1031
00:53:44,880 --> 00:53:45,900
如果我没有投票，

1032
00:53:46,400 --> 00:53:49,820
或者我已经投给这个候选人，

1033
00:53:50,240 --> 00:53:53,480
而且候选者是最新的，

1034
00:53:53,540 --> 00:53:55,370
那么我同意我的投票，

1035
00:53:55,400 --> 00:53:59,630
并重置选举超时，

1036
00:54:01,010 --> 00:54:04,580
那么为什么这里的第二个情况，

1037
00:54:04,610 --> 00:54:07,370
或者 votedFor 等于 args.CandidateId 。

1038
00:54:13,340 --> 00:54:20,100
因为，候选者可能会重发，可能它们的 RPC 延迟了。

1039
00:54:20,490 --> 00:54:22,200
是的，推迟了，或者从来没有做过。

1040
00:54:23,580 --> 00:54:26,880
所以，基本上就是检查，

1041
00:54:27,460 --> 00:54:30,280
这允许我为同一候选人投两次票，

1042
00:54:30,610 --> 00:54:32,500
但我不能投票给任何其他候选人。

1043
00:54:33,440 --> 00:54:34,070
好的？

1044
00:54:34,370 --> 00:54:36,650
所以为了再检查一下这里的逻辑，

1045
00:54:36,800 --> 00:54:40,130
如果候选者有一个 term ，

1046
00:54:40,340 --> 00:54:41,840
它比 currentTerm 大，

1047
00:54:42,140 --> 00:54:44,600
显然，我们必须转为跟随者，

1048
00:54:44,600 --> 00:54:46,730
并更新 term 到候选者的 term ，

1049
00:54:47,030 --> 00:54:50,240
但我们不会自动授予它们投票，

1050
00:54:50,270 --> 00:54:53,870
除非他们的日志至少是最新的。

1051
00:54:54,640 --> 00:54:56,020
是的，就是这样。

1052
00:54:56,350 --> 00:54:57,040
太棒了，谢谢。

1053
00:54:58,470 --> 00:55:03,210
我还想知道，每次 votedFor 都重置为 -1 ？

1054
00:55:03,570 --> 00:55:06,060
是的，当我们进入 newTermL 的时候，总是，

1055
00:55:06,790 --> 00:55:08,770
它总是，

1056
00:55:08,800 --> 00:55:10,300
每当你进入 newTermL 时。

1057
00:55:10,510 --> 00:55:11,140
好的。

1058
00:55:11,500 --> 00:55:14,050
我设置为 -1 ，这是发生这种情况的地方。

1059
00:55:17,220 --> 00:55:18,060
还有什么问题吗？

1060
00:55:24,930 --> 00:55:27,660
所以，这可能会给你整个结构有一个相当好的感觉，

1061
00:55:27,660 --> 00:55:30,570
这就是其他一切都遵循大致相同的结构。

1062
00:55:31,080 --> 00:55:34,980
所以让我们回到这里，

1063
00:55:34,980 --> 00:55:35,850
所以，让我们，

1064
00:55:35,850 --> 00:55:39,480
假设那个候选者赢得了选举。

1065
00:55:40,460 --> 00:55:42,320
所以它 startElectionL ，

1066
00:55:42,350 --> 00:55:44,150
让我回溯一下，

1067
00:55:44,420 --> 00:55:45,890
所以我们 startElectionL ，

1068
00:55:46,400 --> 00:55:48,050
我们 requestVotesL ，

1069
00:55:48,350 --> 00:55:51,950
我们赢得了选举，

1070
00:55:52,460 --> 00:55:54,020
我们成了领导者，

1071
00:55:54,020 --> 00:55:57,080
然后图 2 告诉你要做的第一件事是，

1072
00:55:57,080 --> 00:56:00,470
向每个节点发送心跳，

1073
00:56:02,540 --> 00:56:07,040
这是标准的代码 sendAppendsL ，

1074
00:56:07,750 --> 00:56:13,180
事实上，心跳代码与 sendAppendsL 代码相同，

1075
00:56:13,180 --> 00:56:16,870
除了心跳常常会没有条目，

1076
00:56:16,870 --> 00:56:19,990
或者在发送给跟随者的日志中没有条目。

1077
00:56:23,280 --> 00:56:26,850
好的，所以 sendAppendsL 与 sendVotesL 的结构相同，

1078
00:56:27,090 --> 00:56:30,660
循环节点，

1079
00:56:30,660 --> 00:56:32,220
如果节点不等于我，

1080
00:56:32,220 --> 00:56:34,020
然后 sendAppendL 。

1081
00:56:36,200 --> 00:56:40,400
是的，所以这是 sendAppendL ，

1082
00:56:42,940 --> 00:56:46,660
而且我们跟踪的是，

1083
00:56:46,660 --> 00:56:49,630
下一个日志条目，

1084
00:56:49,630 --> 00:56:51,610
这个节点应该有的，

1085
00:56:51,610 --> 00:56:54,910
我们将其初始化乐观猜测等于我们的，

1086
00:56:55,270 --> 00:56:56,350
所以，在这种情况下，

1087
00:56:56,350 --> 00:56:59,260
将不会有日志条目发送，

1088
00:56:59,800 --> 00:57:02,110
所以我现在可以跳过所有这些东西，

1089
00:57:02,140 --> 00:57:02,950
我们会回到这里，

1090
00:57:02,950 --> 00:57:05,500
当我们查看 Start 的时候，

1091
00:57:05,680 --> 00:57:08,440
我填入 AppendEntriesArgs ，

1092
00:57:09,000 --> 00:57:12,240
我们可以看看它的结构，

1093
00:57:12,240 --> 00:57:12,810
如果你愿意，

1094
00:57:12,810 --> 00:57:14,820
但它和图 2 完全一样，

1095
00:57:14,820 --> 00:57:18,900
可能是唯一要小心的事，

1096
00:57:18,900 --> 00:57:20,610
你要小心的是，

1097
00:57:20,880 --> 00:57:26,280
分配切片保存需要发送的条目，

1098
00:57:26,610 --> 00:57:29,100
在这种情况下，条目数量为零，

1099
00:57:29,130 --> 00:57:31,860
因为我们假设每个都是最新的，

1100
00:57:32,190 --> 00:57:39,390
然后复制日志的切片部分到 Raft 结构，

1101
00:57:39,390 --> 00:57:43,640
到参数中的条目，

1102
00:57:44,480 --> 00:57:49,490
所以我在这一点上，有自己日志的复制，

1103
00:57:49,730 --> 00:57:51,650
有一点危险，

1104
00:57:51,650 --> 00:57:53,000
分片共享内存，

1105
00:57:53,030 --> 00:57:55,610
这就是复制需要发生的原因，

1106
00:57:56,490 --> 00:57:59,310
所以我从 Raft 结构复制出条目，

1107
00:57:59,310 --> 00:58:03,330
我把日志保存在我的私有参数结构中，

1108
00:58:04,620 --> 00:58:06,840
而且，一旦完成了，

1109
00:58:06,840 --> 00:58:12,390
我为每个节点启动一个 goroutine ，

1110
00:58:12,480 --> 00:58:14,340
在那个 Go 函数中，

1111
00:58:14,340 --> 00:58:18,720
在那个函数中，我发送了 RPC ，

1112
00:58:19,170 --> 00:58:20,520
然后在回复处理程序中，

1113
00:58:20,520 --> 00:58:21,690
我获取锁，

1114
00:58:21,690 --> 00:58:23,730
只需 RPC 的回复处理程序，

1115
00:58:23,730 --> 00:58:25,500
获取锁，然后处理回复，

1116
00:58:25,990 --> 00:58:26,950
追加答复。

1117
00:58:30,640 --> 00:58:31,600
这能理解吗？

1118
00:58:34,550 --> 00:58:39,410
是的，继续，也许一个接一个。

1119
00:58:39,410 --> 00:58:41,990
一个小问题，所以在 sendAppendL 中，

1120
00:58:42,540 --> 00:58:43,950
我们有循环，

1121
00:58:43,950 --> 00:58:46,740
其中我们调用 rf.sendAppendL ，

1122
00:58:47,410 --> 00:58:51,190
我们假设锁是在调用过程中持有的，

1123
00:58:51,250 --> 00:58:53,780
但我们在任何线程，

1124
00:58:53,900 --> 00:58:57,530
在某一点上，线程会获取锁，对吗？

1125
00:58:58,770 --> 00:59:00,750
好的，这里有一个外部循环，

1126
00:59:00,750 --> 00:59:02,670
调用这持有锁，

1127
00:59:02,700 --> 00:59:06,030
它调用 sendAppendL n 次，

1128
00:59:06,030 --> 00:59:07,860
其中 n 是节点的数量减去 1 ，

1129
00:59:08,680 --> 00:59:10,360
对于它们中的每一个，

1130
00:59:10,660 --> 00:59:12,550
对于循环的每次迭代，

1131
00:59:12,640 --> 00:59:14,950
我们将创建一个新的 Go 函数，

1132
00:59:15,160 --> 00:59:18,190
那个 Go 函数运行不需要持有锁，

1133
00:59:18,490 --> 00:59:21,220
所以，它发送 RPC 不持有锁，

1134
00:59:21,220 --> 00:59:24,190
同时，新的 Go 函数可能由调用者启动，

1135
00:59:24,490 --> 00:59:27,400
它也会发送 RPC ，

1136
00:59:27,820 --> 00:59:30,880
尽管它们发送 RPC 并行到跟随者，

1137
00:59:31,120 --> 00:59:32,410
跟随者回应说，

1138
00:59:32,870 --> 00:59:34,610
所有的回复都回来了，

1139
00:59:34,910 --> 00:59:37,250
所以它会返回，

1140
00:59:37,280 --> 00:59:38,900
当跟随者回复进来，

1141
00:59:38,900 --> 00:59:40,640
从发送 RPC 返回，

1142
00:59:40,640 --> 00:59:43,670
在这一点上，获取锁来处理回复，

1143
00:59:44,490 --> 00:59:51,390
现在，如果调用者仍然忙于向新跟随者发送 RPC ，

1144
00:59:51,540 --> 00:59:54,330
那么回复处理程序将会阻塞，

1145
00:59:54,660 --> 00:59:58,740
直到调用者完成，发送所有 RPC 。

1146
01:00:00,430 --> 01:00:02,950
是的，所以，我的问题是，

1147
01:00:03,070 --> 01:00:05,860
我假设这会发生的原因是，

1148
01:00:05,860 --> 01:00:10,340
因为我们有一个 defer rf.Unlock ，

1149
01:00:10,370 --> 01:00:12,560
这是不是它不持有锁，

1150
01:00:12,560 --> 01:00:14,120
当它启动一个线程时，

1151
01:00:15,880 --> 01:00:16,630
或者这只是。

1152
01:00:17,900 --> 01:00:18,890
当你启动一个线程时，

1153
01:00:18,890 --> 01:00:20,300
你没有持有任何锁。

1154
01:00:21,100 --> 01:00:23,080
是的，不管是什么，

1155
01:00:23,110 --> 01:00:25,540
即使我们没有，

1156
01:00:25,630 --> 01:00:28,750
即使我们试着在 Go 代码之前持有锁，

1157
01:00:29,140 --> 01:00:29,980
它也不持有它。

1158
01:00:30,860 --> 01:00:33,200
是的，是的。

1159
01:00:33,320 --> 01:00:33,950
好的。

1160
01:00:34,850 --> 01:00:36,140
我是跟进，

1161
01:00:36,170 --> 01:00:39,920
如果 ok 阻塞，

1162
01:00:40,130 --> 01:00:43,280
defer 是从哪里调用的，

1163
01:00:43,490 --> 01:00:45,860
从该方法的 return 语句。

1164
01:00:46,430 --> 01:00:48,710
当这个块退出时，

1165
01:00:48,710 --> 01:00:51,230
将调用 defer mu.Unlock 。

1166
01:00:53,020 --> 01:00:58,120
所以， defer 是在包围的块退出时调用。

1167
01:00:58,860 --> 01:01:00,540
哦，不只是返回语句。

1168
01:01:00,780 --> 01:01:02,490
不仅是返回语句，没错。

1169
01:01:02,490 --> 01:01:03,090
好的，酷。

1170
01:01:05,170 --> 01:01:06,670
那很酷，非常方便。

1171
01:01:07,060 --> 01:01:07,990
你能重复一遍吗，

1172
01:01:07,990 --> 01:01:09,190
defer 什么时候退出？

1173
01:01:09,640 --> 01:01:16,870
这个 defer 这个 unlock 在这个块退出时运行，

1174
01:01:17,020 --> 01:01:19,840
或返回或退出包围的块，

1175
01:01:19,840 --> 01:01:21,460
所以如果你从这个块返回，

1176
01:01:21,760 --> 01:01:23,050
这个 unlock 将会发生。

1177
01:01:24,060 --> 01:01:24,690
那真是太棒了。

1178
01:01:27,160 --> 01:01:30,100
抱歉，为什么，你需要检查，

1179
01:01:30,100 --> 01:01:34,240
currentTerm 仍然是你进入的 term ，

1180
01:01:34,450 --> 01:01:37,240
因为有些请求可能会很慢，

1181
01:01:37,510 --> 01:01:41,110
你可能会在很长一段时间后收到回复。

1182
01:01:41,260 --> 01:01:41,920
是的。

1183
01:01:42,100 --> 01:01:42,670
好的。

1184
01:01:42,850 --> 01:01:45,430
所以，我们看一下 processAppendReply ，

1185
01:01:45,430 --> 01:01:47,260
我想这就是你在问它是做什么的，

1186
01:01:48,210 --> 01:01:49,890
我们已经看过了，

1187
01:01:49,890 --> 01:01:50,880
这样我们可以看到它，

1188
01:01:52,250 --> 01:01:55,580
实际上相当复杂，

1189
01:01:56,790 --> 01:01:59,160
它遵循所有服务器的一般规则，

1190
01:01:59,160 --> 01:02:01,470
你有 reply.Term 大于 currentTerm ，

1191
01:02:01,470 --> 01:02:04,140
然后我变为一个跟随者，

1192
01:02:04,200 --> 01:02:06,120
然后去 newTermL ，

1193
01:02:06,300 --> 01:02:08,160
如果它等于我的 term ，

1194
01:02:08,160 --> 01:02:09,390
这就是你要问的，

1195
01:02:09,780 --> 01:02:13,290
如果回复是在同一个 term 内，

1196
01:02:13,290 --> 01:02:15,330
我发送了 args.Term ，

1197
01:02:15,330 --> 01:02:19,200
然后我要做一个不同的函数，

1198
01:02:19,200 --> 01:02:21,300
它完成了所有的处理，

1199
01:02:21,330 --> 01:02:24,210
假设至少这些 term 是匹配的。

1200
01:02:25,360 --> 01:02:27,250
哦，抱歉，我是说在领导者里，

1201
01:02:27,250 --> 01:02:29,140
当收到回复时，

1202
01:02:29,830 --> 01:02:31,210
它需要检查。

1203
01:02:31,210 --> 01:02:33,940
是的，是的，也在这里发生，

1204
01:02:33,970 --> 01:02:35,320
这里有同样的检查。

1205
01:02:36,820 --> 01:02:37,480
我明白了，好的。

1206
01:02:39,950 --> 01:02:49,010
好的，这就是附加条目，回复代码，

1207
01:02:49,040 --> 01:02:52,310
比如响应回复的处理程序，

1208
01:02:52,460 --> 01:02:58,100
我们知道 term 匹配并且我们检查回复成功，

1209
01:02:58,100 --> 01:02:59,240
如果回复成功，

1210
01:02:59,240 --> 01:03:06,380
我们更新 matchIndex 和 nextIndex ，

1211
01:03:07,020 --> 01:03:09,720
完全遵循图 2 的规则，

1212
01:03:10,400 --> 01:03:12,170
如果有 ConflitValid ，

1213
01:03:12,170 --> 01:03:16,130
然后我处理冲突，

1214
01:03:16,130 --> 01:03:19,520
这是一段要处理的快速回退的代码，

1215
01:03:21,590 --> 01:03:27,020
如果没有可用的冲突信息，

1216
01:03:27,020 --> 01:03:28,340
然后我就退一步。

1217
01:03:30,490 --> 01:03:31,210
好的？

1218
01:03:31,450 --> 01:03:34,720
这是一个关于我们如何后退一步的问题，

1219
01:03:35,560 --> 01:03:38,850
这难道不是问题吗，

1220
01:03:38,910 --> 01:03:40,050
我在想这件事，

1221
01:03:40,050 --> 01:03:41,550
我觉得这不是真的，

1222
01:03:41,550 --> 01:03:43,830
但我还没有完全说服自己，

1223
01:03:43,860 --> 01:03:48,930
但有没有可能 rf.nextIndex 节点发生了更改，

1224
01:03:48,960 --> 01:03:51,080
在我们发送它的时候，

1225
01:03:51,080 --> 01:03:53,810
当我们处理这些回应时，

1226
01:03:53,810 --> 01:03:55,400
你会有问题，

1227
01:03:55,460 --> 01:03:59,300
因为文档使用的值可能已更改。

1228
01:03:59,510 --> 01:04:01,010
可能不会，

1229
01:04:01,010 --> 01:04:04,490
因为你的担心是合理的，

1230
01:04:04,790 --> 01:04:08,300
因为 Raft 结构可能已经完全改变了，

1231
01:04:08,300 --> 01:04:09,710
等恢复进入时。

1232
01:04:10,360 --> 01:04:16,030
事实上，虽然不太可能，

1233
01:04:16,030 --> 01:04:18,340
因为回复是对同一个节点。

1234
01:04:23,460 --> 01:04:24,630
所以有一个，

1235
01:04:24,630 --> 01:04:27,930
但是对于那个节点，我可能有多个未完成的 RPC ，

1236
01:04:28,170 --> 01:04:31,050
所以，这些回复处理程序可能会以某种顺序运行。

1237
01:04:33,920 --> 01:04:35,090
所以我有一个问题，

1238
01:04:35,090 --> 01:04:37,820
为什么我们要将 nextIndex 减 1 ，

1239
01:04:37,820 --> 01:04:38,810
如果没有冲突的话。

1240
01:04:43,160 --> 01:04:44,630
我认为这个必须做到这一点，

1241
01:04:44,630 --> 01:04:45,410
也许在某种程度上，

1242
01:04:45,410 --> 01:04:48,950
我还没有实现冲突 term 的东西，

1243
01:04:50,620 --> 01:04:53,950
我不记得这个是不是必须的。

1244
01:04:54,550 --> 01:04:55,540
好的，谢谢。

1245
01:04:55,850 --> 01:04:59,390
当然像你一样，我多次更改了我的代码，

1246
01:04:59,390 --> 01:05:04,310
当我继续实现测试的回复时，

1247
01:05:07,390 --> 01:05:09,100
我不认为这有什么坏处，

1248
01:05:09,690 --> 01:05:11,460
唯一的缺点可能是，

1249
01:05:11,460 --> 01:05:15,210
我可能会在 RPC 上发送太多条目，

1250
01:05:15,210 --> 01:05:17,610
或者在 RPC 中发送更多条目，

1251
01:05:18,560 --> 01:05:19,580
在下一个附加上。

1252
01:05:24,430 --> 01:05:25,450
好的，还有什么问题吗？

1253
01:05:28,100 --> 01:05:31,700
好的，让我简单地谈一下提交，

1254
01:05:32,180 --> 01:05:33,530
所以你可能已经知道，

1255
01:05:33,530 --> 01:05:39,500
跟随者提交了一些条目，

1256
01:05:39,590 --> 01:05:41,000
我们之前不知道的，

1257
01:05:41,000 --> 01:05:42,680
并且 matchIndex 已经更新，

1258
01:05:42,770 --> 01:05:48,320
所以，我总是在处理回复后检查，

1259
01:05:48,320 --> 01:05:50,960
我是不是应该提出提交点，

1260
01:05:52,570 --> 01:05:55,480
这基本上就是，

1261
01:05:55,540 --> 01:06:00,160
这个代码对应于图 2 中的最后一个领导者[]，

1262
01:06:00,610 --> 01:06:06,070
实现应该在那里发生的事情。

1263
01:06:06,780 --> 01:06:12,210
可能这里唯一有趣的是这个的点，

1264
01:06:13,450 --> 01:06:17,310
这与图 8 有关，

1265
01:06:17,310 --> 01:06:19,470
场景是，你是一个领导者，

1266
01:06:19,650 --> 01:06:21,990
不允许提交前一个 term ，

1267
01:06:22,170 --> 01:06:26,490
除非至少在其 currentTerm 内提交了一个条目，

1268
01:06:27,020 --> 01:06:32,090
这就是第 5.4 节描述的那个检查，

1269
01:06:32,090 --> 01:06:34,880
它检查当前的 log.entry ，

1270
01:06:34,940 --> 01:06:39,710
不会出现在要提交的条目里，

1271
01:06:39,890 --> 01:06:42,590
它是否有一个 term 与 currentTerm 不同，

1272
01:06:42,590 --> 01:06:44,210
如果是这样的话，我就跳过它。

1273
01:06:45,110 --> 01:06:48,890
现在，如果那个 term 后面有另一个日志条目，

1274
01:06:49,280 --> 01:06:52,910
在我的 term 中，我有投票的大多数，

1275
01:06:53,030 --> 01:06:56,540
那么我会提交新的那个，

1276
01:06:56,630 --> 01:06:59,660
然后自动允许提交前一个。

1277
01:07:03,600 --> 01:07:06,870
这就是图 8 的问题，

1278
01:07:07,140 --> 01:07:09,510
然后是 signalApplierL ，

1279
01:07:09,510 --> 01:07:13,800
applier 可能会运行，

1280
01:07:13,830 --> 01:07:15,240
如果这里有一个，

1281
01:07:15,480 --> 01:07:18,420
让我们来看看 applier 线程，

1282
01:07:19,590 --> 01:07:21,300
这是 applier 线程，

1283
01:07:22,040 --> 01:07:24,020
signalApplierL 用于唤醒它，

1284
01:07:24,020 --> 01:07:27,470
当可能提出提交点时，

1285
01:07:28,040 --> 01:07:29,780
它有一个 lastApplied ，

1286
01:07:30,020 --> 01:07:33,260
首先获取一把锁，然后 lastApplied ，

1287
01:07:33,720 --> 01:07:36,240
然后从这里经过，

1288
01:07:36,510 --> 01:07:40,680
执行一个检查对所有的服务器的规则，

1289
01:07:40,680 --> 01:07:42,240
当你提交一些时，

1290
01:07:42,720 --> 01:07:44,310
它遵循这条规则，

1291
01:07:44,310 --> 01:07:46,470
然后向 apply 通道写入一些内容，

1292
01:07:46,470 --> 01:07:47,460
正如你在这里看到的，

1293
01:07:47,460 --> 01:07:49,650
我解锁，在写入 apply 通道之前，

1294
01:07:50,340 --> 01:07:58,110
然后，如果没有更多的东西可以供应，

1295
01:07:58,110 --> 01:07:59,670
在这个 apply 通道上，

1296
01:07:59,670 --> 01:08:01,740
我只是在条件变量上等待。

1297
01:08:04,720 --> 01:08:06,820
再说一次，有不同的方式编写这个，

1298
01:08:06,850 --> 01:08:08,800
但这是我使用的方式。

1299
01:08:10,000 --> 01:08:12,520
你为什么用 broadcast 呢？

1300
01:08:13,060 --> 01:08:15,670
哦，为什么，替换信号，是的，没有充分的理由。

1301
01:08:16,400 --> 01:08:20,270
好的。

1302
01:08:20,360 --> 01:08:23,090
broadcast 信号在这种情况下做的是完全相同的事情。

1303
01:08:25,570 --> 01:08:26,200
对于 applier 吗？

1304
01:08:26,200 --> 01:08:27,400
是的。

1305
01:08:27,610 --> 01:08:31,180
所以我使用了一个条件变量，

1306
01:08:31,180 --> 01:08:34,570
这似乎是很自然的事情，

1307
01:08:34,780 --> 01:08:36,970
做这件事有什么坏处吗，

1308
01:08:37,000 --> 01:08:40,990
比如睡眠一段时间，

1309
01:08:40,990 --> 01:08:44,140
然后，一起观察所有东西。

1310
01:08:44,760 --> 01:08:50,970
我不喜欢随机睡眠的代码，

1311
01:08:51,540 --> 01:08:53,880
我认为这是一种糟糕的代码编写风格，

1312
01:08:54,750 --> 01:08:57,300
所以我不会那么做。

1313
01:08:58,160 --> 01:08:58,640
嗯。

1314
01:08:58,670 --> 01:09:00,920
我唯一使用睡眠的地方是在 ticker 中，

1315
01:09:01,440 --> 01:09:01,950
就这样,

1316
01:09:02,100 --> 01:09:03,990
这是你必须要做的事，

1317
01:09:04,050 --> 01:09:05,760
否则我永远不会那么做。

1318
01:09:06,060 --> 01:09:10,770
用 ticker 做，有什么好处吗？

1319
01:09:12,780 --> 01:09:13,320
抱歉？

1320
01:09:13,620 --> 01:09:19,200
与 ticker 一起检查和更新有什么处吗，

1321
01:09:19,230 --> 01:09:19,860
就像你有。

1322
01:09:19,860 --> 01:09:24,480
你可以这么做，我觉得这很难解释，

1323
01:09:24,540 --> 01:09:27,840
如果一个线程[]一件事，

1324
01:09:27,840 --> 01:09:29,340
然后 ticker 线程一件事，

1325
01:09:29,730 --> 01:09:33,540
我认为有些人所有事情都在 ticker 线程上做，

1326
01:09:34,400 --> 01:09:37,670
对我来说这是很难解释的，

1327
01:09:38,240 --> 01:09:42,730
但这更多的是个人品味问题，而不是任何事情。

1328
01:09:49,130 --> 01:09:49,850
好的？

1329
01:09:54,350 --> 01:09:55,550
还有什么问题吗？

1330
01:10:00,190 --> 01:10:04,270
好的，我想快速看一下开始部分，

1331
01:10:04,270 --> 01:10:06,700
因为已经没有什可讨论的了，

1332
01:10:06,700 --> 01:10:08,110
我们讨论了投票，

1333
01:10:08,110 --> 01:10:09,190
我们谈到了追加，

1334
01:10:09,640 --> 01:10:13,330
还没有讨论过跟随者一方到底会发生什么，

1335
01:10:13,330 --> 01:10:16,300
当它进入附加请求时，

1336
01:10:16,510 --> 01:10:19,180
但是遵循图 2 ，

1337
01:10:19,180 --> 01:10:21,040
如果我们还有时间，我们也可以看看这个。

1338
01:10:21,720 --> 01:10:24,210
这是 Start 命令，

1339
01:10:24,880 --> 01:10:30,190
这是调用追加条目到日志的服务，

1340
01:10:30,520 --> 01:10:33,130
获取锁，

1341
01:10:33,340 --> 01:10:35,950
看看我们是否仍是领导者，

1342
01:10:35,950 --> 01:10:37,450
如果不是，则返回 false ，

1343
01:10:37,480 --> 01:10:39,610
否则，我们将创建一个条目，

1344
01:10:39,910 --> 01:10:41,470
然后我们将其附加到日志中，

1345
01:10:41,800 --> 01:10:45,070
日志必须是持久化，所以我们 persist ，

1346
01:10:45,340 --> 01:10:46,810
然后我们 sendAppendsL ，

1347
01:10:46,810 --> 01:10:48,610
这完全一样，

1348
01:10:48,610 --> 01:10:51,550
或者 sendAppendsL 与心跳完全相同的代码，

1349
01:10:51,880 --> 01:10:56,470
除了在心跳中，

1350
01:10:56,740 --> 01:10:59,350
现在，它将发送条目，

1351
01:10:59,470 --> 01:11:02,530
它被附加到日志中。

1352
01:11:05,240 --> 01:11:05,780
好的？

1353
01:11:07,990 --> 01:11:09,820
你注意到，

1354
01:11:09,820 --> 01:11:14,920
可能很多地方都有这个 log.lastindex 或什么东西，

1355
01:11:14,920 --> 01:11:20,440
这是因为我在某种程度上将日志抽象为自己的结构。

1356
01:11:21,260 --> 01:11:26,540
这里的日志只是条目的日志，条目的切片，

1357
01:11:26,870 --> 01:11:28,850
和 index0 ，

1358
01:11:28,850 --> 01:11:31,160
这是 2D 部分的内容，

1359
01:11:31,460 --> 01:11:34,850
你要截断日志的开始部分，

1360
01:11:34,880 --> 01:11:36,260
这个全局日志，

1361
01:11:36,680 --> 01:11:38,810
而且你需要跟踪 index ，

1362
01:11:38,810 --> 01:11:41,570
你需要跟踪第一个条目的索引

1363
01:11:41,570 --> 01:11:43,550
记录在日志中。

1364
01:11:44,500 --> 01:11:47,110
为了隐藏大部分细节，

1365
01:11:47,110 --> 01:11:52,150
在这个 log.go 文件中有一个抽象的方式。

1366
01:11:52,420 --> 01:11:54,640
它们是用于附加的函数，

1367
01:11:54,640 --> 01:11:56,110
获取日志的开始，

1368
01:11:56,110 --> 01:11:58,330
cutend ， cutstart ，

1369
01:11:58,930 --> 01:12:00,070
获取它的切片，

1370
01:12:00,070 --> 01:12:01,270
获取 lastindex ，

1371
01:12:01,270 --> 01:12:03,580
获取指定的 entry 或获取 lastentry ，

1372
01:12:05,020 --> 01:12:07,780
这对 2D 来说可能是方便的，

1373
01:12:07,780 --> 01:12:09,610
尽管有很多其他的方法可以做到这个。

1374
01:12:16,370 --> 01:12:20,120
好的，让我回顾一下人们问的一些问题。

1375
01:12:20,750 --> 01:12:24,500
所以，我想我到现在为止已经回答了很多问题，

1376
01:12:24,740 --> 01:12:31,280
但如果不是，让我快速回顾一下它们，

1377
01:12:31,790 --> 01:12:35,090
我认为我们就选举超时问题进行了相当广泛的讨论，

1378
01:12:35,330 --> 01:12:36,500
如何计算它，

1379
01:12:36,800 --> 01:12:38,600
如何查看超时时间已过。

1380
01:12:40,830 --> 01:12:47,290
有一个问题是，关于总是收到领导者的消息，

1381
01:12:47,320 --> 01:12:50,350
我只有在收到领导者的信息后才会重置，

1382
01:12:50,350 --> 01:12:51,940
使用我的 currentTerm ，

1383
01:12:53,010 --> 01:12:54,570
或者在我的 newTerm ，

1384
01:12:54,570 --> 01:12:56,610
如果我成为一个跟随者，

1385
01:12:56,820 --> 01:12:59,730
不会[]一些落后 term 的。

1386
01:13:00,290 --> 01:13:02,510
什么时候发送 AppendEntries ，

1387
01:13:02,600 --> 01:13:03,980
做这件事的不同方式，

1388
01:13:03,980 --> 01:13:05,540
你可以只在心跳时做，

1389
01:13:05,540 --> 01:13:07,850
有些人这样做过，

1390
01:13:07,850 --> 01:13:10,130
所以永远不要在 Start 中发送任何东西，

1391
01:13:10,160 --> 01:13:13,730
就像我在代码中展示的，

1392
01:13:13,730 --> 01:13:16,550
或者有时候人们也会在回复中做，

1393
01:13:16,610 --> 01:13:19,760
如果后面的跟随者，

1394
01:13:19,790 --> 01:13:23,210
直接发送剩余的条目，

1395
01:13:23,540 --> 01:13:24,950
我不会那么做，

1396
01:13:24,950 --> 01:13:26,870
我从来没有在回复中发送任何东西，

1397
01:13:26,870 --> 01:13:28,520
尽管我有一个实现做过，

1398
01:13:28,880 --> 01:13:30,140
风险在于，

1399
01:13:30,140 --> 01:13:32,600
我认为你[]后面实验中的跟随者，

1400
01:13:32,600 --> 01:13:35,480
或者在 2C 和 2D 的测试中。

1401
01:13:37,760 --> 01:13:43,040
我认为一些人只是在心跳中发送条目，

1402
01:13:43,040 --> 01:13:45,620
也就是说每一个，

1403
01:13:45,620 --> 01:13:48,770
你不能发送心跳超过每秒十次，

1404
01:13:48,860 --> 01:13:52,160
在实验的游戏规则中，

1405
01:13:52,550 --> 01:13:55,550
这意味着你可以发送附加条目，

1406
01:13:55,550 --> 01:13:58,010
每 100 毫秒一次，

1407
01:13:58,010 --> 01:13:59,180
或者更快一点，

1408
01:13:59,630 --> 01:14:05,210
这可能会在实验 3 遇到问题，

1409
01:14:05,240 --> 01:14:09,080
我们看你是否取得了足够快的进展，

1410
01:14:10,370 --> 01:14:12,980
所以我是在心跳完成的，

1411
01:14:12,980 --> 01:14:13,970
我在 Start 这样做。

1412
01:14:15,820 --> 01:14:17,740
我们非常广泛地讨论了调试，

1413
01:14:18,320 --> 01:14:20,570
谈了很多关于代码组织的话题，

1414
01:14:20,600 --> 01:14:22,790
我想我们谈了很多关于并发性的问题。

1415
01:14:23,340 --> 01:14:28,230
有许多问题是关于为什么 3/5/7 台服务器，而不是更多，

1416
01:14:28,470 --> 01:14:30,510
我想这就是原因，

1417
01:14:30,510 --> 01:14:33,780
因为我认为它反映了 Raft 在实践中的使用情况，

1418
01:14:33,780 --> 01:14:36,510
3/5/7 是基于

1419
01:14:36,510 --> 01:14:39,510
故障间隔时间的计算得出的，

1420
01:14:40,090 --> 01:14:41,410
在 Raft 论文中，

1421
01:14:41,410 --> 01:14:45,280
它推测任何失败大概几个月，

1422
01:14:45,550 --> 01:14:46,990
你使用 3 台服务器运行，

1423
01:14:47,230 --> 01:14:48,400
一个停机，

1424
01:14:48,430 --> 01:14:53,530
你有足够的时间来重建第三台服务器，

1425
01:14:53,530 --> 01:14:54,580
然后让它重新上线，

1426
01:14:54,580 --> 01:14:55,960
所以回到之前的三个，

1427
01:14:55,960 --> 01:14:57,970
在下一次失败发生之前，

1428
01:14:59,740 --> 01:15:02,590
这就是为什么这是少量的服务器。

1429
01:15:08,650 --> 01:15:10,420
我们讨论了一下什么时候应该持久化，

1430
01:15:10,510 --> 01:15:13,060
一些很好的问题，

1431
01:15:13,060 --> 01:15:17,530
如果在写入稳定存储时崩溃，会发生什么，

1432
01:15:18,000 --> 01:15:21,810
所以你可能会写入部分状态，这将是一场灾难，

1433
01:15:22,110 --> 01:15:23,670
所以人们通常会做的是，

1434
01:15:23,670 --> 01:15:26,010
为了确保当它们写入稳定存储时，

1435
01:15:26,010 --> 01:15:27,420
这是一个原子操作，

1436
01:15:28,260 --> 01:15:30,240
这会在 tester 中显示出来，

1437
01:15:30,240 --> 01:15:34,500
因为 tester 模拟持久性存储，

1438
01:15:34,500 --> 01:15:38,130
然后原子地更新持久存储，

1439
01:15:38,400 --> 01:15:40,800
在一个真实系统中，有一个磁盘，

1440
01:15:40,980 --> 01:15:42,960
你可能会使用一个技巧，

1441
01:15:42,990 --> 01:15:46,350
就像 MapReduce 库，执行原子地重命名，

1442
01:15:46,350 --> 01:15:47,910
你首先将其写入临时文件，

1443
01:15:47,910 --> 01:15:50,010
直到一切都写好，然后原子重命名，

1444
01:15:50,440 --> 01:15:53,140
或者使用一个预先式日志系统，

1445
01:15:53,940 --> 01:15:55,890
但你必须这样做，

1446
01:15:55,890 --> 01:15:57,360
这是一场灾难，

1447
01:15:57,360 --> 01:16:03,300
如果崩溃，到稳定存储的持久化状态变得不一致。

1448
01:16:05,120 --> 01:16:06,560
好的，让我停在这里，

1449
01:16:06,560 --> 01:16:09,170
所以可能会有更多的时间来提问，

1450
01:16:09,170 --> 01:16:11,690
当然，像往常一样，我会留在这里，

1451
01:16:11,690 --> 01:16:13,700
我可以回答更多的问题，

1452
01:16:14,000 --> 01:16:17,570
我看到在聊天中也有大量的讨论，

1453
01:16:17,570 --> 01:16:22,700
很遗憾可能我没有跟上所有的进度。

1454
01:16:27,030 --> 01:16:27,990
好的，很好。

1455
01:16:31,650 --> 01:16:33,180
好的，还有什么问题吗？

1456
01:16:35,370 --> 01:16:37,740
我有一个关于日志的问题，

1457
01:16:38,940 --> 01:16:41,460
你的日志代码，

1458
01:16:42,160 --> 01:16:45,190
index0 ，它是，

1459
01:16:46,060 --> 01:16:49,930
我想是在底层数组中，

1460
01:16:49,930 --> 01:16:53,260
是日志的开头，

1461
01:16:53,740 --> 01:16:54,460
是这样吗？

1462
01:16:54,640 --> 01:16:56,650
这基本上是实验 2D 的内容，

1463
01:16:57,240 --> 01:17:02,430
不是，在实验 A B 和 C 中， index0 总是 0 ，

1464
01:17:04,240 --> 01:17:06,310
在实验 2D 中，你执行快照，

1465
01:17:06,310 --> 01:17:09,790
index0 没有快照索引号，

1466
01:17:12,070 --> 01:17:14,290
因为你会截断日志的开头，

1467
01:17:15,480 --> 01:17:18,000
如果你把快照索引取为 10 ，

1468
01:17:18,000 --> 01:17:20,130
你要截断 0 到 9 ，

1469
01:17:20,310 --> 01:17:21,900
而 index0 将是 10 。

1470
01:17:23,250 --> 01:17:25,650
哦，这是快照的结尾，

1471
01:17:25,650 --> 01:17:26,460
我明白了，好的。

1472
01:17:30,540 --> 01:17:33,930
所以任何在 index0 中的东西，

1473
01:17:33,930 --> 01:17:35,400
包含在快照中，

1474
01:17:35,400 --> 01:17:38,820
所以，没有理由再在日志中维护那些状态。

1475
01:17:45,860 --> 01:17:46,790
还有其他问题吗？

1476
01:17:51,320 --> 01:17:52,940
我希望这是有用的，

1477
01:17:52,970 --> 01:17:58,050
尤其是 2C 2D ，

1478
01:17:58,170 --> 01:17:59,610
也许会有一些想法，

1479
01:17:59,610 --> 01:18:02,910
可能会对你实现这些实验很有用。

1480
01:18:05,610 --> 01:18:09,090
我有个问题，

1481
01:18:10,070 --> 01:18:13,130
人们使用什么样的选举超时范围，

1482
01:18:15,380 --> 01:18:22,070
我想我用了心跳 100 毫秒的下限，

1483
01:18:22,070 --> 01:18:26,660
然后超时时间在 300 到 700 毫秒之间。

1484
01:18:26,930 --> 01:18:27,200
嗯。

1485
01:18:27,200 --> 01:18:28,430
我不知道，这是不是。

1486
01:18:28,430 --> 01:18:31,730
完全合理，我使用了一个更大的数字，

1487
01:18:31,730 --> 01:18:33,350
我们给你的[]是，

1488
01:18:33,350 --> 01:18:37,190
你应该在 5 秒内选出一位领导者，

1489
01:18:37,620 --> 01:18:39,990
这意味着你应该指望，

1490
01:18:39,990 --> 01:18:42,180
而且你可能要运行几次选举，

1491
01:18:42,740 --> 01:18:45,500
所以你选择的数字是合理的。

1492
01:18:51,320 --> 01:18:55,760
任何人想要分享他们有过的恼人的 bug ，

1493
01:18:55,790 --> 01:18:58,220
人们在问的一些问题，

1494
01:18:58,220 --> 01:19:00,380
人们见过的最讨厌的 bug 是什么？

1495
01:19:11,180 --> 01:19:14,720
我的实现中有一个非常恼人的 bug ，

1496
01:19:15,980 --> 01:19:18,830
我没有采纳我自己的建议，

1497
01:19:18,830 --> 01:19:22,820
奇怪地实现定时器，

1498
01:19:22,820 --> 01:19:26,970
在那里产生新的线程来睡眠，

1499
01:19:26,970 --> 01:19:29,100
然后在结尾发回一条消息，

1500
01:19:29,190 --> 01:19:31,410
这并不是一个很好的设计，

1501
01:19:31,440 --> 01:19:32,850
它有两个不同的定时器，

1502
01:19:32,850 --> 01:19:36,240
一个是心跳，一个是选举计时器，

1503
01:19:36,300 --> 01:19:40,770
我忘了停掉其中一个计时器，

1504
01:19:40,770 --> 01:19:42,150
当服务器关闭时，

1505
01:19:42,180 --> 01:19:44,250
其中一个很好，另一个不太好，

1506
01:19:44,370 --> 01:19:46,590
这意味着很慢[]，

1507
01:19:46,620 --> 01:19:50,100
一些 goroutine 运行很长时间，

1508
01:19:50,340 --> 01:19:51,540
直到它用完了，

1509
01:19:51,540 --> 01:19:53,370
竞争探测器崩溃了所有东西，

1510
01:19:54,660 --> 01:19:56,310
这令人难以置信地尴尬，

1511
01:19:56,310 --> 01:20:00,030
因为我忘了停止计时器，

1512
01:20:01,590 --> 01:20:04,760
但是它花了很长的时间来调试，

1513
01:20:04,760 --> 01:20:06,260
因为我不能解决，

1514
01:20:06,350 --> 01:20:09,380
我以为实验的 RPC 代码中有 bug ，

1515
01:20:09,380 --> 01:20:10,670
不，没有，

1516
01:20:10,790 --> 01:20:14,120
不，实验RPC 代码中可能没有错误，

1517
01:20:14,120 --> 01:20:16,010
只是我曲解了数据。

1518
01:20:18,340 --> 01:20:20,080
是的。

1519
01:20:20,580 --> 01:20:22,590
我说的是选举超时，

1520
01:20:22,590 --> 01:20:29,950
我对一个 config.go 中的调用有疑问，

1521
01:20:30,340 --> 01:20:33,580
或者偶尔不能达成协议，

1522
01:20:34,090 --> 01:20:35,290
我意识到，

1523
01:20:35,290 --> 01:20:39,910
如果我增加我的选举超时，加上随机间隔，

1524
01:20:39,910 --> 01:20:42,220
增加到 1500 毫秒，

1525
01:20:42,760 --> 01:20:46,600
大大降低了这种情况发生的频率，

1526
01:20:46,600 --> 01:20:50,380
但我在想，对于随机间隔，我是否应该比这个更高，

1527
01:20:50,380 --> 01:20:54,040
这表明我有另一种 bug 。

1528
01:20:54,340 --> 01:20:54,940
我认为这表明你又有另一个 bug ，

1529
01:20:57,200 --> 01:20:58,550
我的第一个猜测是，

1530
01:20:58,580 --> 01:21:00,830
当然，我也不确定，

1531
01:21:00,920 --> 01:21:06,640
但你不需要运行这么长时间才能通过。

1532
01:21:08,540 --> 01:21:12,830
是的，大多数时候，当人们调整他们的超时时，

1533
01:21:12,830 --> 01:21:14,210
而不是真正修复它们的 bug ，

1534
01:21:14,210 --> 01:21:16,850
它只是改变了它们出现的频率。

1535
01:21:19,300 --> 01:21:20,230
好的，谢谢。

1536
01:21:22,900 --> 01:21:24,520
在通道中有一个 bug ，

1537
01:21:24,580 --> 01:21:26,350
我有一个 bug 在通道中，

1538
01:21:26,350 --> 01:21:28,090
我忘了初始化通道，

1539
01:21:29,780 --> 01:21:32,450
这是如何表现为一个 bug 的。

1540
01:21:34,110 --> 01:21:37,710
哦，当我发送一些东西时，

1541
01:21:37,710 --> 01:21:40,140
它无法接收到它，

1542
01:21:41,330 --> 01:21:43,160
我想知道发生了什么事，

1543
01:21:43,340 --> 01:21:46,010
事实证明，只是我从来没有初始化它，

1544
01:21:46,310 --> 01:21:48,320
就像一个非 nil 频道。

1545
01:21:53,010 --> 01:21:56,250
因为我不知道新频道的语义覆盖了什么，

1546
01:21:56,370 --> 01:21:58,080
我想不起来了，

1547
01:21:58,080 --> 01:21:59,010
我知道这方面的规则，

1548
01:21:59,010 --> 01:22:00,420
但我不记得规则是什么了。

1549
01:22:01,640 --> 01:22:04,520
你对前面这一点有什么看法，

1550
01:22:05,350 --> 01:22:08,890
考虑到选举超时，将它们设得很高，

1551
01:22:08,950 --> 01:22:14,170
我们是不是应该试着把它们设置低一点，

1552
01:22:14,320 --> 01:22:17,260
如果有任何 bug ，我们可以发现它们。

1553
01:22:18,270 --> 01:22:20,010
是的，不是一个坏的方案，

1554
01:22:20,310 --> 01:22:22,020
我觉得总是好的，

1555
01:22:22,020 --> 01:22:23,340
推动边界

1556
01:22:23,340 --> 01:22:25,260
看看是不是有其他 bug 。

1557
01:22:28,170 --> 01:22:32,190
所以，边界应该是与论文建议的[类似]的东西。

1558
01:22:32,220 --> 01:22:33,900
稍微高一点，

1559
01:22:33,900 --> 01:22:36,780
因为我们设置测试的方式略有不同，

1560
01:22:36,840 --> 01:22:41,100
每一个[]都有关于这个的讨论。

1561
01:22:42,360 --> 01:22:46,470
实际上 Raft 论文可以作为参考，

1562
01:22:46,470 --> 01:22:48,510
即使它们有特定的值，

1563
01:22:48,510 --> 01:22:50,820
他们根据参考设定一个值，

1564
01:22:50,820 --> 01:22:51,780
参考说，

1565
01:22:51,780 --> 01:22:54,540
你应该选举一个领导者，

1566
01:22:54,570 --> 01:22:58,650
使用比心跳间隔大得多的时间。

1567
01:22:58,980 --> 01:22:59,790
没错。

1568
01:22:59,790 --> 01:23:03,690
100 ，如果你 800 到 1 秒，

1569
01:23:03,690 --> 01:23:05,130
事情将会起作用，

1570
01:23:05,840 --> 01:23:07,490
这是可以的，如果这些都很高，

1571
01:23:07,490 --> 01:23:09,470
因为这是参考，

1572
01:23:09,470 --> 01:23:10,310
一切都变了，

1573
01:23:10,310 --> 01:23:15,350
因为我们刚刚改变了心跳频率，

1574
01:23:15,350 --> 01:23:16,970
因为 RPC[]。

1575
01:23:20,580 --> 01:23:25,740
抱歉，可以在代码中看到心跳计时器吗？

1576
01:23:26,210 --> 01:23:27,050
好的，当然。

1577
01:23:35,090 --> 01:23:37,730
基本上每 50 毫秒，

1578
01:23:37,820 --> 01:23:39,500
ticker 走完，

1579
01:23:40,410 --> 01:23:41,820
ticker 调用 tick ，

1580
01:23:41,880 --> 01:23:44,670
如果一个领导者发送一个 RPC ，

1581
01:23:44,670 --> 01:23:46,770
就是一个心跳，

1582
01:23:49,570 --> 01:23:52,660
所以这里我的实现，每 50 毫秒发送一个心跳。

1583
01:23:58,730 --> 01:23:59,750
我有一个问题，

1584
01:23:59,780 --> 01:24:02,570
你刚才说的，

1585
01:24:03,140 --> 01:24:06,640
超时应该

1586
01:24:06,640 --> 01:24:11,440
比心跳大一个数量级，

1587
01:24:12,250 --> 01:24:15,520
但我刚开始看它可以多小，

1588
01:24:16,090 --> 01:24:20,050
我可以使用 100 毫秒超时，

1589
01:24:20,600 --> 01:24:25,610
它可能会缩短到 300 到 500 毫秒，仍然有效，

1590
01:24:25,640 --> 01:24:28,640
在没有[]的情况下，

1591
01:24:28,640 --> 01:24:32,250
我在想，这是为什么，

1592
01:24:33,990 --> 01:24:37,380
它们可以降到多低，

1593
01:24:38,150 --> 01:24:41,150
为什么我们要让它们变得比，

1594
01:24:41,870 --> 01:24:43,340
比选举超时，

1595
01:24:43,550 --> 01:24:45,050
比心跳时间。

1596
01:24:45,260 --> 01:24:51,020
因为我们需要给候选人成为领袖的机会，

1597
01:24:51,020 --> 01:24:56,830
一些消息可能会被延迟很长时间或被丢弃。

1598
01:25:00,200 --> 01:25:00,680
好的？

1599
01:25:01,700 --> 01:25:02,300
我有个问题，

1600
01:25:02,300 --> 01:25:03,590
我想我错过了这一部分，

1601
01:25:03,590 --> 01:25:04,520
也就是，

1602
01:25:05,060 --> 01:25:09,980
哪些追加条目是从 Start 发送，

1603
01:25:09,980 --> 01:25:11,480
哪些是来自心跳的。

1604
01:25:11,750 --> 01:25:13,490
基本上是一样的，是相同的代码。

1605
01:25:14,870 --> 01:25:15,440
好的。

1606
01:25:15,770 --> 01:25:18,380
好的，没什么区别，我只有一个，

1607
01:25:18,380 --> 01:25:19,340
如果你看这里，

1608
01:25:19,340 --> 01:25:21,230
这个 sendAppendsL

1609
01:25:21,260 --> 01:25:22,520
这是来自 ticker 的。

1610
01:25:23,010 --> 01:25:23,790
嗯。

1611
01:25:23,790 --> 01:25:26,400
如果你看一下 API 代码，

1612
01:25:26,550 --> 01:25:29,070
Start 函数调用相同的函数，

1613
01:25:32,390 --> 01:25:34,460
但在这种情况下，哪些是，

1614
01:25:35,020 --> 01:25:36,820
如果把它们全部从 Start 发送出去，

1615
01:25:36,820 --> 01:25:39,010
哪些是从 ticker 发出的。

1616
01:25:40,010 --> 01:25:44,360
ticker 可能更多是空的追加。

1617
01:25:45,730 --> 01:25:48,970
好的，所以这两个都来自 Start ？

1618
01:25:49,580 --> 01:25:51,890
不，一个是从 ticker 的。

1619
01:25:53,320 --> 01:25:55,090
或者实际的日志条目。

1620
01:25:56,010 --> 01:26:01,350
哦，实际的日志条目都在 Raft 结构上，

1621
01:26:01,350 --> 01:26:02,910
它们来自 Raft 结构，

1622
01:26:04,660 --> 01:26:05,890
如果你看看 Start ，

1623
01:26:05,890 --> 01:26:07,180
Start 做的唯一一件事，

1624
01:26:08,180 --> 01:26:10,280
等一下，我把 Start 找出来，

1625
01:26:10,310 --> 01:26:11,390
因为这是个好问题，

1626
01:26:11,780 --> 01:26:12,980
好的，找到 Start ，

1627
01:26:12,980 --> 01:26:16,610
它会追加到这里的日志中，

1628
01:26:16,910 --> 01:26:18,560
这就是所有的事情，

1629
01:26:18,590 --> 01:26:21,710
ticker 和 Start 之间唯一的区别是，

1630
01:26:21,710 --> 01:26:23,570
Start 追加一些东西到日志中，

1631
01:26:23,570 --> 01:26:24,890
而 ticker 没有这么做，

1632
01:26:25,790 --> 01:26:29,300
sendAppendsL 获取，

1633
01:26:29,360 --> 01:26:32,300
这是它们所有的循环，

1634
01:26:32,860 --> 01:26:34,420
所以，这是单独的，

1635
01:26:35,080 --> 01:26:36,340
糟糕，

1636
01:26:40,220 --> 01:26:41,540
这是单独的一个，

1637
01:26:41,540 --> 01:26:42,800
它们发送给一个节点，

1638
01:26:43,070 --> 01:26:49,490
它从这里中抓取正确的日志条目，

1639
01:26:50,380 --> 01:26:54,160
把它从日志中复制到 args.Entries ，

1640
01:26:54,900 --> 01:26:56,160
如果是心跳，

1641
01:26:56,160 --> 01:26:58,710
最有可能的是总是有 0 ，但不总是，

1642
01:26:58,710 --> 01:27:01,290
因为你可能是领导者，可能是跟随者，可能错过一些，

1643
01:27:02,010 --> 01:27:04,830
但是在 Start 调用这个的情况下，

1644
01:27:04,830 --> 01:27:08,040
你总是发送刚刚附加的东西。

1645
01:27:09,720 --> 01:27:10,590
好的，因为，

1646
01:27:10,710 --> 01:27:14,340
我做的，把所有的东西都在心跳中发送，

1647
01:27:14,340 --> 01:27:15,570
所有的条目，

1648
01:27:16,420 --> 01:27:18,430
对与某些[]，

1649
01:27:18,430 --> 01:27:20,470
有时我不能达成协议，

1650
01:27:20,470 --> 01:27:22,330
我想知道这是为什么，

1651
01:27:22,330 --> 01:27:24,070
因为这里看起来像是，

1652
01:27:24,070 --> 01:27:26,350
大部分条目是在 Start 中发送的。

1653
01:27:26,350 --> 01:27:27,430
不，好的，

1654
01:27:27,430 --> 01:27:30,160
这可能不是你为什么，

1655
01:27:30,190 --> 01:27:33,070
我认为这不会影响达成协议，

1656
01:27:33,070 --> 01:27:36,640
可能并不依赖于你发送的条目数量，

1657
01:27:37,320 --> 01:27:39,900
你在附加 RPC 中发送的日志条目数量。

1658
01:27:40,790 --> 01:27:41,360
不是？

1659
01:27:42,540 --> 01:27:45,930
是的，我顺利通过了实验 2 ，

1660
01:27:45,960 --> 01:27:50,400
在仅从心跳定时器发送附加条目的情况下。

1661
01:27:51,390 --> 01:27:56,520
情况有所好转。

1662
01:27:57,600 --> 01:27:58,950
明确地说，我不建议这么做，

1663
01:27:58,950 --> 01:28:01,590
但是，你可以通过实验 2 ，

1664
01:28:01,590 --> 01:28:03,090
只是从心跳中发送，

1665
01:28:03,090 --> 01:28:09,690
如果您不确定超时时间有多长，那么。

1666
01:28:09,720 --> 01:28:14,310
心跳的限制是如何起作用的，

1667
01:28:14,610 --> 01:28:18,020
与追加条目 RPC 的限制相同，

1668
01:28:18,020 --> 01:28:19,430
或者它们的计算方式不同。

1669
01:28:20,560 --> 01:28:23,110
心跳有一点不同，

1670
01:28:23,140 --> 01:28:25,450
你可以发送，

1671
01:28:25,600 --> 01:28:26,710
原则上假设，

1672
01:28:26,710 --> 01:28:29,860
每个 Start 都会导致追加条目调用。

1673
01:28:30,320 --> 01:28:30,800
好的。

1674
01:28:31,040 --> 01:28:35,090
你不能发送超过 10 个心跳。

1675
01:28:35,740 --> 01:28:39,790
你怎么在测试中区分这一点？

1676
01:28:40,090 --> 01:28:42,790
心跳没有条目，最典型的情况是。

1677
01:28:43,180 --> 01:28:47,280
好的，所以进去，检查。

1678
01:28:47,310 --> 01:28:48,840
哦，它们不是真的检查，

1679
01:28:48,840 --> 01:28:52,440
但我们看你是否每秒进展超过 10 次，

1680
01:28:53,970 --> 01:28:55,680
比如实验3 中的一项测试，

1681
01:28:55,680 --> 01:28:57,030
检查你的速度是否足够快，

1682
01:29:02,700 --> 01:29:03,780
正是因为这个原因，

1683
01:29:05,320 --> 01:29:06,220
可能有点烦人，

1684
01:29:06,220 --> 01:29:07,570
但在实际应用中，

1685
01:29:07,570 --> 01:29:11,110
如果你延迟你的附加 50 毫秒，

1686
01:29:11,110 --> 01:29:12,010
在你做任何事情之前。

1687
01:29:13,050 --> 01:29:16,200
所以，如果一个客户端访问你的服务，

1688
01:29:16,200 --> 01:29:17,070
它将会，

1689
01:29:17,070 --> 01:29:21,190
每 50 毫秒就会有一次追加操作，

1690
01:29:22,860 --> 01:29:25,020
这将不是一项非常可取的服务。

1691
01:29:29,690 --> 01:29:30,920
我有一个问题，

1692
01:29:30,920 --> 01:29:37,850
关于在没有锁的情况下访问 rf 结构部分，

1693
01:29:38,120 --> 01:29:40,700
所以，在 sendAppendEntries ，

1694
01:29:41,180 --> 01:29:45,530
你是在读取节点。

1695
01:29:46,380 --> 01:29:47,130
是的。

1696
01:29:47,970 --> 01:29:49,590
我想切片，

1697
01:29:49,770 --> 01:29:52,560
但我知道它是静态的，

1698
01:29:52,890 --> 01:29:54,450
但在那里，

1699
01:29:54,540 --> 01:30:01,030
可能是多个线程读取同一个东西两次，

1700
01:30:01,210 --> 01:30:04,560
所以，有没有风险，

1701
01:30:04,560 --> 01:30:06,690
竞争探测器会抱怨这个。

1702
01:30:15,950 --> 01:30:18,410
所以让我想想，

1703
01:30:20,060 --> 01:30:24,350
所以我想我没有在 rf.peers 持有锁，这不是。

1704
01:30:25,580 --> 01:30:26,090
嗯。

1705
01:30:27,020 --> 01:30:28,910
是的，也许是竞争，因为没有抱怨，

1706
01:30:30,410 --> 01:30:32,630
因为我总是运行竞争探测器。

1707
01:30:48,860 --> 01:30:53,330
抱歉，你的问题是关于迭代是否会导致竞争吗？

1708
01:30:53,900 --> 01:30:54,650
嗯。

1709
01:30:54,800 --> 01:30:59,390
是的，不持有锁访问它。

1710
01:30:59,720 --> 01:31:01,400
好的，这里只有[] 。

1711
01:31:04,170 --> 01:31:08,010
没有，你不能让竞争检测器抱怨。

1712
01:31:09,300 --> 01:31:10,890
那么 rf.killed 呢？

1713
01:31:13,370 --> 01:31:13,880
抱歉？

1714
01:31:14,420 --> 01:31:16,220
rf.killed 。

1715
01:31:22,340 --> 01:31:24,950
哦，我想这只是[]场景，

1716
01:31:24,950 --> 01:31:27,920
如果你在做其他事情的同时杀死它，

1717
01:31:27,920 --> 01:31:28,790
我不确定。

1718
01:31:29,600 --> 01:31:32,270
是的，它说的不仅是修改，

1719
01:31:32,990 --> 01:31:35,690
killed 仍然不会修改节点。

1720
01:31:43,130 --> 01:31:44,480
好的，好的，谢谢。

1721
01:31:46,140 --> 01:31:48,840
我能再看看你是怎么做 apply 通道的吗，

1722
01:31:48,840 --> 01:31:49,770
你在前面谈到，

1723
01:31:49,770 --> 01:31:52,260
如何需要使用锁在 apply 通道？

1724
01:31:53,090 --> 01:31:55,340
不是解锁，相反。

1725
01:31:55,640 --> 01:31:59,300
哦，抱歉，这是什么，条件变量？

1726
01:31:59,540 --> 01:32:00,890
是的，我有条件变量，是的。

1727
01:32:05,550 --> 01:32:09,090
所以，好的，哦，你怎么处理条件变量？

1728
01:32:09,090 --> 01:32:10,950
我给它带来了一个信号，

1729
01:32:11,400 --> 01:32:16,960
当 matchIndex 更新时，

1730
01:32:16,960 --> 01:32:19,090
需要提交新的条目，

1731
01:32:19,120 --> 01:32:21,910
那个线程将调用信号，

1732
01:32:22,580 --> 01:32:26,000
并且这将唤醒 apply 线程，

1733
01:32:26,000 --> 01:32:27,080
apply 线程将查看，

1734
01:32:27,080 --> 01:32:30,570
是否有需要在 apply 通道上推送的东西，

1735
01:32:30,570 --> 01:32:31,890
在这里检查，

1736
01:32:31,920 --> 01:32:33,960
如果是这样，我们将把它放在 apply 通道上。

1737
01:32:34,890 --> 01:32:35,760
哦，好的。

1738
01:32:36,720 --> 01:32:39,030
如果没有更多东西推送到 apply 通道，

1739
01:32:39,030 --> 01:32:39,960
它又回到睡眠状态。

1740
01:32:40,650 --> 01:32:41,100
好的。

1741
01:32:48,450 --> 01:32:49,200
好的。

1742
01:32:50,150 --> 01:32:52,760
也许今天就到此为止。

1743
01:32:59,000 --> 01:33:00,020
还有谁还在。

