1
00:00:00,210 --> 00:00:01,170
0,360 360,450 450,600 600,750 750,960
So I want to talk
所以今天我想讨论一下 memcache ，

2
00:00:01,170 --> 00:00:03,450
0,390 390,750 1410,1770 1770,2280 2280,2280
today about {the,memcache -},| this
|这是一篇来自 Facebook 的 2013 年的论文，

3
00:00:03,450 --> 00:00:06,870
0,570 570,840 840,1170 1170,1950 2400,3420
is a paper from Facebook

4
00:00:06,870 --> 00:00:08,360
0,120 120,1230
from 2013,|
|

5
00:00:08,740 --> 00:00:10,570
0,390 390,630 630,720 720,1320 1350,1830
{memcache -} are still widely
memcache 在很多网站中使用，

6
00:00:10,570 --> 00:00:13,240
0,480 480,690 1050,1500 1500,2250 2250,2670
used in many websites| or
|或者大型网站使用的，

7
00:00:13,240 --> 00:00:15,040
0,240 240,450 450,990 1020,1590 1590,1800
{} big Internet websites []

8
00:00:15,040 --> 00:00:16,510
0,360 360,450 450,840 840,1230 1230,1470
use| {} have ideas or
|与它的想法或架构很相似。

9
00:00:16,510 --> 00:00:17,650
0,450 450,510 510,660 660,990 990,1140
architecture is very similar to

10
00:00:17,650 --> 00:00:19,280
0,210 810,1380
it. {}|
|

11
00:00:19,420 --> 00:00:21,880
0,870 870,1230 1230,1800 1830,1950 1950,2460
The paper is an experience
这篇论文是一篇经验论文，

12
00:00:21,880 --> 00:00:22,720
0,540
paper,|
|

13
00:00:24,840 --> 00:00:25,800
0,330

14
00:00:27,220 --> 00:00:29,920
0,120

15
00:00:30,200 --> 00:00:30,830
0,150 150,270 270,480 480,540 540,630
so the goal of the
所以，这篇论文的目的并不是

16
00:00:30,830 --> 00:00:31,910
0,210 210,300 300,660 660,840 840,1080
paper is not so much|
|

17
00:00:31,910 --> 00:00:33,350
0,120 120,660 660,870 870,1350 1350,1440
to introduce new ideas or
介绍构建系统的新思想，新概念或新的创新方式，

18
00:00:33,350 --> 00:00:36,230
0,120 120,960 960,1740 1740,1950 1950,2880
new concepts or new innovative

19
00:00:36,230 --> 00:00:38,120
0,270 270,360 360,750 750,1140 1470,1890
ways of building {} systems,|
|

20
00:00:38,120 --> 00:00:39,290
0,210 210,630 630,840 840,1050 1050,1170
{ -} there's more to
这更多是构建系统的实践经验的总结，

21
00:00:39,290 --> 00:00:41,690
0,510 510,840 840,1080 1080,1530 1530,2400
report on actual practical experience

22
00:00:41,930 --> 00:00:43,820
0,300 300,690 690,780 780,1440 1440,1890
in trying to build systems,|
|

23
00:00:43,820 --> 00:00:45,320
0,270 570,690 690,810 810,1170 1170,1500
that in this particular case,|
在这种情况下，|

24
00:00:45,320 --> 00:00:47,870
0,360 360,540 540,1710 1740,2400 2400,2550
can have {support,a,billion} requests per
可以支持每秒 10 亿个请求或每秒数十亿个请求。

25
00:00:47,870 --> 00:00:49,580
0,510 510,660 660,1080 1080,1410 1410,1710
seconds or multiple billion requests

26
00:00:49,580 --> 00:00:50,380
0,120 120,720
per seconds.|
|

27
00:00:51,070 --> 00:00:53,230
0,570 930,1260 1260,1380 1380,1800 1920,2160
{} And so there are
这里有三个经验，

28
00:00:53,230 --> 00:00:55,510
0,210 210,960 990,1200 1200,1680 2070,2280
three lessons,| you know you
|你可以从论文中学到的。

29
00:00:55,510 --> 00:00:56,590
0,90 90,240 240,420 420,690 690,1080
can take away from this

30
00:00:56,590 --> 00:00:58,740
0,330 330,840
particular paper.|
|

31
00:01:01,060 --> 00:01:03,700
0,750 1020,1530 1620,2130 2130,2310 2310,2640
{} One is they got
一是他们获得了令人印象深刻的性能，

32
00:01:03,700 --> 00:01:06,220
0,360 360,720 720,1470 1950,2250 2250,2520
very impressive performance,| out of
|使用现成组件构建的系统，

33
00:01:06,250 --> 00:01:08,080
0,600 600,780 780,870 870,1230 1230,1830
building, out of building system

34
00:01:08,500 --> 00:01:10,660
0,570 570,1110 1110,1890 1890,2100 2100,2160
{} with {} off the

35
00:01:10,660 --> 00:01:12,320
0,270 270,900
shelf component,|
|

36
00:01:16,300 --> 00:01:17,620
0,150 150,210 210,510 510,960 960,1320
so the system {} consist
系统由标准的开放软件组成，

37
00:01:17,620 --> 00:01:20,140
0,360 660,1290 1290,1530 1530,1950 1950,2520
of standard open software packages,|
|

38
00:01:20,140 --> 00:01:22,120
0,540 570,750 750,1440 1440,1680 1680,1980
like {MySQL -} {memcached -
比如 MySQL memcached ，

39
00:01:22,120 --> 00:01:24,010
0,540 750,1170 1170,1350 1350,1740 1740,1890
-},| and they combine that
|他们把它们结合在一起，

40
00:01:24,010 --> 00:01:26,440
0,570 630,840 840,1080 1080,1560 1590,2430
together| {} to actually build
|构建了一个系统，

41
00:01:26,440 --> 00:01:27,250
0,30 30,300 300,360 360,600 600,810
a system| or scale that
|或者向外扩展了一个系统，

42
00:01:27,250 --> 00:01:28,030
0,180 180,270 270,330 330,660 660,780
out to a system,| that
|支持每秒 10 亿个请求。

43
00:01:28,030 --> 00:01:29,770
0,240 240,750 750,780 780,1470 1470,1740
actually support a billion requests

44
00:01:29,770 --> 00:01:32,110
0,90 90,660 1260,1800 2040,2250 2250,2340
per seconds.| As you can
|正如你所看到的，正如我们在这节课中所看到的，

45
00:01:32,110 --> 00:01:33,640
0,540 570,1200 1200,1320 1320,1440 1440,1530
see, as we see in

46
00:01:33,640 --> 00:01:35,500
0,120 120,720 720,1080 1080,1770 1770,1860
this lecture,| {there's,sort,of} continuously in
|在性能和一致性之间有一种持续的紧张关系，

47
00:01:35,500 --> 00:01:43,480
0,630 870,2340 2760,3900 6810,7170 7170,7980
tension between performance and consistency,|
|

48
00:01:48,760 --> 00:01:49,360
0,180 180,270 270,420 420,540 540,600
and as you'll see in
正如你将在这篇论文中看到的，

49
00:01:49,360 --> 00:01:51,010
0,150 150,750 750,1200 1230,1560 1560,1650
this paper,| the design is
|这个设计主要受性能驱动，

50
00:01:51,010 --> 00:01:54,040
0,420 420,960 1020,1200 1200,1980 2190,3030
mostly driven by performance, {}|
|

51
00:01:54,040 --> 00:01:55,510
0,120 120,720 720,840 840,1080 1080,1470
you know they want to
他们想要找到某种程度的一致性，

52
00:01:55,540 --> 00:01:57,760
0,240 240,690 1050,1350 1350,1410 1410,2220
find some degree of {consistency

53
00:01:58,030 --> 00:02:00,640
0,1650 1650,1650 1650,2190 2190,2550 2550,2610
-},| {} is sort of
|某种程度上增加，

54
00:02:00,640 --> 00:02:03,310
0,420 420,900 900,1260 1590,2310 2310,2670
added to,| {you,know} {make,the} system
|使系统至少对 Facebook 使用的应用可用，

55
00:02:03,310 --> 00:02:04,600
0,330 330,690 690,1110 1110,1230 1230,1290
{at,least} be usable for the

56
00:02:04,600 --> 00:02:06,490
0,540 540,750 750,990 990,1380 1380,1890
application that actually Facebook has,|
|

57
00:02:06,700 --> 00:02:08,860
0,210 210,450 450,510 510,960 1770,2160
in fact, you know the
事实上，这里的一致性模型

58
00:02:08,860 --> 00:02:10,150
0,390 390,630 630,690 690,960 960,1290
consistency model| is quite different
|与我们以前看到的一致性模型有很大不同，

59
00:02:10,150 --> 00:02:11,620
0,480 480,570 570,1050 1050,1350 1350,1470
from the consistency models that

60
00:02:11,620 --> 00:02:13,270
0,150 150,330 330,900 990,1500 1500,1650
we've seen before,| most of
|我们到目前为止讨论的大多数系统

61
00:02:13,270 --> 00:02:14,650
0,210 210,480 480,690 690,990 990,1380
the system we talked about

62
00:02:14,650 --> 00:02:16,510
0,210 210,600 600,900 900,1470 1470,1860
so far| actually provides either
|要么提供外部一致性，要么提供线性一致性，

63
00:02:16,510 --> 00:02:18,250
0,480 480,1200 1200,1380 1380,1590 1590,1740
external consistency or {linearizability -

64
00:02:18,250 --> 00:02:20,770
0,660 930,1320 1320,1710 1710,1950 1950,2520
-},| {} they're very strong
|它们在一致性方面非常强大，

65
00:02:20,770 --> 00:02:22,570
0,240 240,390 390,1080 1260,1680 1680,1800
for {} consistency,| and then
|在 Facebook 的案例中，

66
00:02:22,570 --> 00:02:23,680
0,240 240,600 600,720 720,990 990,1110
{} in the case of

67
00:02:23,680 --> 00:02:24,420
0,630
Facebook,|
|

68
00:02:25,000 --> 00:02:26,410
0,180 180,450 450,900 900,1050 1050,1410
{} their applications don't really
它们的应用程序并不真正需要线性一致性，

69
00:02:26,410 --> 00:02:28,870
0,480 510,660 660,1050 1050,1620 1980,2460
need {} {linearizability -}, {}|
|

70
00:02:28,870 --> 00:02:30,550
0,330 330,1110 1110,1350 1350,1470 1470,1680
{if,the} user {} is reading
如果用户阅读新闻文章，

71
00:02:30,550 --> 00:02:32,440
0,240 240,990 1170,1590 1590,1650 1650,1890
news articles,| and the news
|而新闻消息落后了几秒钟，

72
00:02:32,440 --> 00:02:33,460
0,300 300,690 690,780 780,960 960,1020
feed is a couple of

73
00:02:33,460 --> 00:02:35,530
0,300 300,900 990,1320 1320,1530 1530,2070
seconds behind,| {it,doesn't} really matter,|
|这真的不重要，|

74
00:02:35,800 --> 00:02:36,940
0,360 360,510 510,660 660,780 780,1140
{} and so they are,
所以，它们的目标不是

75
00:02:36,940 --> 00:02:38,320
0,150 150,360 360,780 780,1290 1290,1380
they have absolutely not the

76
00:02:38,320 --> 00:02:40,600
0,630 630,720 720,1440 1680,2070 2070,2280
goal| of providing {} sort
|提供某种线性一致性或严格的一致性，

77
00:02:40,600 --> 00:02:42,400
0,180 180,780 780,960 960,1410 1410,1800
of {linearizability - -} or

78
00:02:42,460 --> 00:02:43,640
0,330 330,960
strict consistency,|
|

79
00:02:44,360 --> 00:02:45,200
0,240 240,360 360,420 420,720 720,840
so that's an important thing
所以，这是一件需要记住的重要事情。

80
00:02:45,200 --> 00:02:46,880
0,60 60,240 240,300 300,600 1080,1680
to keep in mind {}.|
|

81
00:02:48,150 --> 00:02:49,680
0,570 570,780 780,960 960,1200 1200,1530
Despite that they're not shooting
尽管他们不是在追求强一致性，

82
00:02:49,680 --> 00:02:51,390
0,180 180,210 210,750 780,960 960,1710
for {} strong {you,know} consistency,|
|

83
00:02:51,420 --> 00:02:52,350
0,210 210,420 420,690 690,870 870,930
there are some sort of
在论文中仍然有一些警示故事，

84
00:02:52,350 --> 00:02:54,000
0,660 660,1410
cautionary tales

85
00:02:55,270 --> 00:02:56,470
0,90 90,180 180,540 540,900 1080,1200
in the paper,| that you
|添加一致性度量并不容易，

86
00:02:56,470 --> 00:02:59,620
0,90 90,690 1320,1890 1890,2550 2550,3150
know adding {} consistency measures

87
00:02:59,650 --> 00:03:01,540
0,930 930,1170 1170,1470 1470,1770 1770,1890
is not easy,| and you
|你不需要，为它的开始做好准备，

88
00:03:01,540 --> 00:03:03,340
0,240 240,510 510,960 990,1530 1530,1800
should not have, prepared for

89
00:03:03,340 --> 00:03:05,780
0,90 90,510 540,990 1560,2190
it to start, {}|
|

90
00:03:06,380 --> 00:03:08,330
0,510 600,1170 1170,1740 1740,1830 1830,1950
{} but nevertheless, you know
但无论如何，你不能对这个系统的成功提出异议，

91
00:03:08,330 --> 00:03:10,430
0,660 810,1260 1260,1470 1470,1710 1710,2100
the you really can't argue

92
00:03:10,430 --> 00:03:11,990
0,750 750,990 990,1380 1380,1470 1470,1560
with the success of the

93
00:03:11,990 --> 00:03:14,240
0,450 570,1140 1140,1380 1740,1980 1980,2250
system,| {} it really very
|它真的非常成功，

94
00:03:14,240 --> 00:03:17,930
0,780 1140,1560 1560,1920 1920,2640 2670,3690
successful,| and allows Facebook {}
|允许 Facebook 网站的跟随者，

95
00:03:17,960 --> 00:03:20,450
0,840 840,1260 1290,1650 1650,2040 2070,2490
websites {you,know} {follower -},| {there,is,a,couple}
|有很多使用相同策略，

96
00:03:20,450 --> 00:03:22,130
0,90 90,330 330,570 570,1230 1380,1680
the follow similar strategies| to
|能够扩大大量的用户。

97
00:03:22,130 --> 00:03:23,480
0,180 180,630 630,690 690,1050 1050,1350
actually scaled a large large

98
00:03:23,480 --> 00:03:24,860
0,330 330,570 600,1230
number of users.|
|

99
00:03:25,800 --> 00:03:27,000
0,570

100
00:03:28,260 --> 00:03:29,310
0,330 330,570 570,840 840,930 930,1050
So my plan for this
所以我这次课程的计划是先谈谈性能，

101
00:03:29,310 --> 00:03:30,540
0,270 270,660 660,960 960,1050 1050,1230
lecture basically first to talk

102
00:03:30,540 --> 00:03:32,040
0,180 180,720 720,1170 1170,1410 1410,1500
about performance,| because really the
|因为性能才是这个设计背后的驱动力，

103
00:03:32,040 --> 00:03:33,840
0,420 420,510 510,630 630,1290 1440,1800
performance is the driving force

104
00:03:33,840 --> 00:03:35,850
0,270 270,450 450,1110 1350,1500 1500,2010
behind this design,| and then
|然后在最后更多地谈论一致性。

105
00:03:35,850 --> 00:03:37,140
0,150 150,270 270,600 600,690 690,1290
at the end {you,know} talk

106
00:03:37,140 --> 00:03:38,920
0,300 300,870 870,1530
more about consistency.|
|

107
00:03:39,690 --> 00:03:40,950
0,390 390,570 570,870 870,1140 1140,1260
{ -} Before jumping {into
在开始之前，

108
00:03:40,950 --> 00:03:42,120
0,360 480,900 900,960 960,1080 1080,1170
-},| let me know if
|有什么问题吗？

109
00:03:42,120 --> 00:03:43,800
0,210 210,660 660,1410
there's any questions?|
|

110
00:03:50,010 --> 00:03:51,780
0,570 600,870 870,1260 1290,1470 1470,1770
Okay, so, {} let me
好的，让我从[]性能介绍开始，

111
00:03:51,780 --> 00:03:52,920
0,300 300,600 600,720 720,930 930,1140
{} start with a little

112
00:03:52,920 --> 00:03:54,720
0,150 150,330 330,720 720,1440 1440,1800
bit of [] introduction to

113
00:03:54,720 --> 00:03:57,210
0,120 120,900 1020,1680 1680,2160 2160,2490
{} performance,| and basically talk
|谈谈网站的演变。

114
00:03:57,210 --> 00:04:02,400
0,480 480,1560 1620,2370
about website evolution.|
|

115
00:04:05,930 --> 00:04:07,070
0,180 180,690 690,900 900,960 960,1140
I'm sure many of you
我相信你们中的许多人建立过网站，

116
00:04:07,070 --> 00:04:10,010
0,300 300,510 510,960 990,1890 2340,2940
actually have built websites,| and
|如果你一开始，

117
00:04:10,010 --> 00:04:10,700
0,60 60,210 210,330 330,450 450,690
you know if you {sort,of}

118
00:04:10,700 --> 00:04:11,870
0,270 270,720 720,900 900,1020 1020,1170
start out,| and you don't
|你没有任何用户，

119
00:04:11,870 --> 00:04:12,860
0,120 120,270 270,750 750,840 840,990
have any users,| you know
|这很简单，

120
00:04:12,860 --> 00:04:14,780
0,210 210,390 390,1050
that's pretty straightforward,|
|

121
00:04:15,410 --> 00:04:16,880
0,420 420,810 810,960 960,1200 1200,1470
{buy,a} machine or {run,a} machine
在 Amazon 或其他任何地方购买或运行一台机器，

122
00:04:16,880 --> 00:04:18,830
0,90 90,720 720,1020 1020,1380 1380,1950
on Amazon or anywhere else,|
|

123
00:04:19,070 --> 00:04:21,110
0,420 420,1110 1110,1320 1320,1650 1650,2040
{} and you just basically
你基本上只需要三个组件，

124
00:04:21,110 --> 00:04:22,700
0,180 180,330 330,870 870,1200 1200,1590
need three components,| you need
|你需要网络服务器，比如 Apache ，

125
00:04:23,030 --> 00:04:25,560
0,180 180,750 1320,2250
web server, {let's,say,Apache},|
|

126
00:04:27,230 --> 00:04:30,110
0,480 480,630 630,1230 2070,2280 2280,2880
{} you need an application
你需要一个应用程序框架来构建你的网站，

127
00:04:30,110 --> 00:04:31,430
0,510 510,600 600,840 840,930 930,1320
framework to build your website

128
00:04:31,430 --> 00:04:34,430
0,390 660,1320 1320,1950 1950,2250 2250,3000
in,| maybe PHP, maybe Python,|
|可能是 PHP ，可能是 Python ，|

129
00:04:34,430 --> 00:04:36,170
0,120 120,540 570,840 870,1200 1200,1740
you know in case of
在 Facebook 的情况下，我想他们使用的是 PHP ，

130
00:04:36,560 --> 00:04:38,240
0,960 960,1200 1200,1380 1380,1500 1500,1680
Facebook, I think they use

131
00:04:38,240 --> 00:04:40,970
0,750 1530,2040 2040,2460 2460,2550 2550,2730
PHP,| {} and you need
|你需要一个数据库来存储你网站的数据，

132
00:04:40,970 --> 00:04:42,140
0,30 30,510 510,600 600,810 810,1170
a database that actually stores

133
00:04:42,140 --> 00:04:43,060
0,60 60,540
the data

134
00:04:44,320 --> 00:04:45,820
0,150 150,750 1020,1230 1230,1350 1350,1500
{of,your} website,| you know for
|比如使用 MySQL ，

135
00:04:45,820 --> 00:04:47,680
0,300 300,750 750,1110 1110,1260 1260,1860
example use whatever {MySQL -},|
|

136
00:04:48,850 --> 00:04:50,360
0,240 240,600
{that's,you,know} {Facebook,is,doing}.|
这是 FaceBook 所使用的。|

137
00:04:50,960 --> 00:04:52,190
0,390 390,630 630,720 720,840 840,1230
And so you know clients
客户端连接到你的网站，

138
00:04:52,190 --> 00:04:54,050
0,180 180,510 510,600 600,1080 1080,1860
{you,know} connect to your website,|
|

139
00:04:54,110 --> 00:04:56,360
0,750 1110,1740 1740,1860 1860,1980 1980,2250
{} run you know the
运行应用程序代码，

140
00:04:56,360 --> 00:04:59,120
0,510 510,1080 1080,1620 1650,2280 2280,2760
whatever application code| or whatever
|或者网站提供的任何应用程序服务，

141
00:04:59,120 --> 00:05:01,310
0,420 420,750 750,1170 1260,1590 1590,2190
application service the website provides,|
|

142
00:05:01,610 --> 00:05:03,260
0,630 630,900 900,1020 1020,1320 1320,1650
and store and retrieve data
并使用数据库存储和查找数据，

143
00:05:03,260 --> 00:05:04,200
0,720
using

144
00:05:04,870 --> 00:05:07,000
0,90 90,570 570,630 630,1050 1050,2130
the database,| the database provides
|数据库提供事务，

145
00:05:07,000 --> 00:05:09,610
0,840 990,1470 1470,1590 1590,2340 2370,2610
transactions,| {} it has {SQL
|它有 SQL ，

146
00:05:09,610 --> 00:05:10,780
0,390 390,480 480,630 630,930 930,1170
-},| so it's easy to
|所以，它可以很容易地以不同的方式查询数据，

147
00:05:10,780 --> 00:05:13,030
0,720 750,1350 1350,1380 1680,2190 2190,2250
query { -} over the

148
00:05:13,030 --> 00:05:15,070
0,240 240,330 330,600 600,1170 1380,2040
data in different ways, {}|
|

149
00:05:15,070 --> 00:05:16,720
0,450 450,630 630,720 720,1080 1080,1650
and all the persistent state
所有持久化状态都存储在数据库中，

150
00:05:16,720 --> 00:05:17,710
0,150 150,420 420,480 480,570 570,990
{you,know} store in the database,|
|

151
00:05:17,710 --> 00:05:18,730
0,270 300,480 480,660 660,960 960,1020
so you know {} to
为了备份数据库，

152
00:05:18,730 --> 00:05:20,110
0,240 240,360 360,420 420,1020 1020,1380
{backup -} the database,| and
|你会有一个很好的容错方案。

153
00:05:20,590 --> 00:05:21,550
0,180 180,510 510,660 660,750 750,960
you basically have a good

154
00:05:21,550 --> 00:05:23,020
0,210 210,330 330,810 810,1170 1170,1470
sort of fault tolerance plan.|
|

155
00:05:23,830 --> 00:05:25,540
0,150 150,270 270,390 390,780 1140,1710
And that's sort of, {}
这在某种程度上，对于任何网站来说，

156
00:05:25,540 --> 00:05:26,950
0,420 420,660 660,1110 1110,1350 1350,1410
{and,for} any website,| that's {}
|对于少量的用户是完全足够的，

157
00:05:26,950 --> 00:05:28,150
0,270 270,480 480,570 570,990 990,1200
small number of users is

158
00:05:28,150 --> 00:05:31,000
0,360 360,990 1110,1560 1560,2250 2430,2850
completely sufficient,| {} and {the,way}
|许多网站的构建方式，

159
00:05:31,000 --> 00:05:33,550
0,180 180,600 600,960 960,1350 1470,2550
many websites are built,| however
|但是当用户数量增加的时候，

160
00:05:33,550 --> 00:05:34,760
0,90 90,150 150,450 450,930
you know when the,

161
00:05:35,140 --> 00:05:36,790
0,300 300,510 510,570 570,900 900,1650
the number of users increases,|
|

162
00:05:36,880 --> 00:05:37,900
0,330 330,450 450,750 750,960 960,1020
{} you probably need to
你可能需要进行更复杂的设计。

163
00:05:37,900 --> 00:05:38,920
0,210 210,360 360,720 720,870 870,1020
go to a little bit

164
00:05:38,920 --> 00:05:40,340
0,180 180,750 750,1140
more sophisticated design.|
|

165
00:05:40,710 --> 00:05:42,090
0,330 330,540 540,810 810,1080 1080,1380
So {this,is} {sort,of} step one
所以这是演化的第一步。

166
00:05:42,090 --> 00:05:43,740
0,150 150,240 240,960 1170,1380 1380,1650
in the evolution.| In step
|在第二步中，

167
00:05:43,740 --> 00:05:45,760
0,480 810,1410
two, {}|
|

168
00:05:50,990 --> 00:05:52,220
0,270 270,360 360,630 630,720 720,1230
sort of trying to address
为了解决我们面临的第一个瓶颈问题，

169
00:05:52,220 --> 00:05:53,480
0,240 240,330 330,570 570,1140 1140,1260
getting the first bottleneck that

170
00:05:53,480 --> 00:05:55,160
0,150 150,480 480,930 1080,1350 1350,1680
we're {run,into -},| {} when
|当你的用户数量较多时，

171
00:05:55,160 --> 00:05:56,030
0,180 180,330 330,390 390,660 660,870
you have a larger number

172
00:05:56,030 --> 00:05:57,380
0,60 60,450 450,600 600,1020 1020,1350
of users,| and typically the
|通常你遇到的瓶颈，

173
00:05:57,410 --> 00:05:58,940
0,630 630,750 750,870 870,1050 1050,1530
bottleneck you are run into|
|

174
00:05:59,120 --> 00:06:00,500
0,180 180,600 600,720 720,1260 1260,1380
is basically the computation of
是应用程序使用的计算周期，

175
00:06:00,500 --> 00:06:02,390
0,480 480,690 690,1470 1470,1680 1680,1890
cycles being used by the

176
00:06:02,390 --> 00:06:03,440
0,600 600,750 750,840 840,930 930,1050
application,| so if you have
|如果你有数千名用户同时在网站上运行，

177
00:06:03,440 --> 00:06:04,700
0,360 360,480 480,930 930,1170 1170,1260
thousands of users running at

178
00:06:04,700 --> 00:06:05,840
0,90 90,510 510,600 600,840 840,1140
the website at the same

179
00:06:05,840 --> 00:06:08,150
0,540 810,1110 1110,1710 1710,2070 2070,2310
time| or {10\,000,or} whatever number
|或 10,000 或任何数量的用户，

180
00:06:08,150 --> 00:06:09,710
0,90 90,360 360,480 480,870 1050,1560
of users it is, {}|
|

181
00:06:09,710 --> 00:06:11,510
0,510 510,630 630,750 750,1050 1080,1800
and you know just running
运行应用程序代码

182
00:06:11,510 --> 00:06:12,800
0,150 150,240 240,360 360,870 870,1290
you know the application code|
|

183
00:06:12,980 --> 00:06:14,120
0,180 180,240 240,540 540,1020 1020,1140
on a single CPU or
在单个 CPU 或单个计算机上，

184
00:06:14,120 --> 00:06:16,640
0,90 90,600 600,1200 1320,1950 1980,2520
a single computer,| {} gets
|导致 CPU 负载到 200% ，

185
00:06:16,640 --> 00:06:20,090
0,2070 2400,2970 2970,3210 3210,3300 3300,3450
to drive basically CPU {you,know}

186
00:06:20,090 --> 00:06:21,380
0,270 270,510 510,720 720,870 870,1290
{ -} load up {200%

187
00:06:21,380 --> 00:06:22,970
0,330 330,930 930,1020 1020,1230 1230,1590
-},| then you can't support
|你就不能支持更多了。

188
00:06:22,970 --> 00:06:23,340
0,300
more.|
|

189
00:06:23,940 --> 00:06:25,170
0,150 150,450 570,1020 1020,1170 1170,1230
And so, fortunately this is
幸运的是，这很容易解决，

190
00:06:25,170 --> 00:06:26,970
0,600 630,1020 1020,1260 1260,1650 1650,1800
actually {straightforwardly - -} {}

191
00:06:26,970 --> 00:06:29,700
0,630 840,1650 1650,2010 2010,2490 2490,2730
solved,| because the database actually
|因为数据库具有所有持久状态，

192
00:06:29,700 --> 00:06:31,290
0,270 270,480 480,690 690,1140 1140,1590
has all the persistent state,|
|

193
00:06:31,830 --> 00:06:33,390
0,480 600,1050 1050,1170 1170,1290 1290,1560
so typically way you solve
所以通常你解决这个问题的方法是，

194
00:06:33,390 --> 00:06:34,800
0,240 240,480 480,810 810,1080 1080,1410
this is,| {you,know,you} keep the
|你保持一台机器运行数据库，

195
00:06:35,100 --> 00:06:36,510
0,300 300,720 720,870 870,960 960,1410
one machine with the database

196
00:06:36,510 --> 00:06:37,410
0,240 240,420 420,510 510,810 810,900
run,| keep the machine on
|保持数据库机器，

197
00:06:37,410 --> 00:06:38,730
0,90 90,660 870,1050 1050,1140 1140,1320
the database,| and then just
|然后为前端买一些机器，

198
00:06:38,730 --> 00:06:39,810
0,300 300,390 390,660 660,780 780,1080
buy a bunch of different

199
00:06:39,810 --> 00:06:41,280
0,390 390,510 510,870 870,1260 1290,1470
machines for {the,frontends -},| I'm
|我说的到前端，是一种东西，

200
00:06:41,280 --> 00:06:42,000
0,120 120,240 240,330 330,540 540,720
just going to talk about

201
00:06:42,000 --> 00:06:42,870
0,90 90,330 330,510 510,600 600,870
the frontend, that is one

202
00:06:42,870 --> 00:06:44,640
0,480 840,1170 1170,1350 1350,1500 1500,1770
thing,| which is you know
|网站、 Apache 加上一些应用程序代码，

203
00:06:44,670 --> 00:06:48,120
0,450 450,660 930,1860 2160,2940 2970,3450
typically the website Apache plus

204
00:06:48,120 --> 00:06:49,320
0,90 90,210 210,330 330,810 810,1200
you know some application code,|
|

205
00:06:49,320 --> 00:06:52,470
0,570 1020,2610 2610,2760 2760,2970 2970,3150
{if,you,get,more} users, you'll buy more
如果你有更多的用户，你买更多的机器，

206
00:06:52,470 --> 00:06:53,440
0,600
machines,|
|

207
00:07:00,350 --> 00:07:01,610
0,300 300,450 450,900 900,1200 1200,1260
{you,know} they all connect to
它们都连接到数据库来获取数据，

208
00:07:01,610 --> 00:07:02,690
0,90 90,690 690,780 780,900 900,1080
the database {you,know} to get

209
00:07:02,690 --> 00:07:05,690
0,90 90,600 840,1500 1500,2340 2370,3000
their data,| {} and {}
|实际上，这个设计效果非常好，

210
00:07:05,690 --> 00:07:06,950
0,210 210,510 510,690 690,1080 1080,1260
and actually this design works

211
00:07:06,950 --> 00:07:09,260
0,180 180,750 750,1350 1380,1920 1920,2310
out extremely well,| because basically
|因为前端是无状态的，

212
00:07:09,260 --> 00:07:10,540
0,870
{the,frontends}

213
00:07:12,190 --> 00:07:13,720
0,210 210,780 1020,1170 1170,1380 1380,1530
are stateless,| {you,know} all this
|所有这些数据都在数据库里，

214
00:07:13,720 --> 00:07:14,650
0,210 210,600 600,780 780,870 870,930
data again is in the

215
00:07:14,650 --> 00:07:16,900
0,810 1140,1590 1590,1770 1770,1950 1950,2250
database,| {} and so adding
|添加一台新服务器是微不足道的，

216
00:07:16,900 --> 00:07:18,190
0,60 60,210 210,810 810,1080 1080,1290
a new server, it's pretty

217
00:07:18,190 --> 00:07:21,310
0,630 750,1530 1530,2370 2400,2820 2820,3120
trivial,| {} {all,the} frontends actually
|所有前端都会看到最新的写入，

218
00:07:21,310 --> 00:07:22,660
0,120 120,360 360,780 780,1110 1110,1350
will see {the,latest} writes,| because
|因为所有数据都存储在数据库中，

219
00:07:22,660 --> 00:07:23,410
0,120 120,210 210,420 420,510 510,750
all the data is actually

220
00:07:23,410 --> 00:07:24,760
0,240 240,330 330,420 420,1110 1200,1350
stored in the database,| so
|所以不存在一致性问题，

221
00:07:24,760 --> 00:07:26,740
0,120 120,240 240,840 840,1380 1710,1980
there's no consistency issues,| in
|在容错方面很容易，

222
00:07:26,740 --> 00:07:27,670
0,180 180,240 240,420 420,780 780,930
terms of fault tolerance is

223
00:07:27,670 --> 00:07:28,630
0,450 450,540 540,660 660,750 750,960
easy,| if one of these
|如果其中一台机器出现故障，

224
00:07:28,630 --> 00:07:30,190
0,330 330,870 870,960 960,1230 1230,1560
machines fails,| {you,know} no problem
|完全没有问题，

225
00:07:30,190 --> 00:07:32,470
0,60 60,480 720,1530 1530,1830 1830,2280
at all,| {} and maybe
|可能机器必须接管负载，

226
00:07:32,470 --> 00:07:33,460
0,330 330,570 570,690 690,810 810,990
the machines have to take

227
00:07:33,460 --> 00:07:35,200
0,180 180,300 300,720 960,1440 1440,1740
over the load,| or you
|或者你必须起一台机器给前端，

228
00:07:35,200 --> 00:07:35,770
0,90 90,180 180,390 390,510 510,570
have to bring on a

229
00:07:35,770 --> 00:07:36,730
0,120 120,450 450,510 510,870 870,960
new machine of frontend,| but
|但是你不需要做任何事情，

230
00:07:36,730 --> 00:07:37,840
0,120 120,300 300,870 870,1050 1050,1110
you don't actually have to

231
00:07:37,840 --> 00:07:39,400
0,90 90,450 450,840 840,930 930,1560
do anything| {in,terms} of complicated
|在复杂的数据恢复方面，

232
00:07:39,400 --> 00:07:43,240
0,600 810,1590 1590,2280 2280,2970 2970,3840
{} data restoration or restoration,|
|

233
00:07:43,240 --> 00:07:44,020
0,240 240,420 420,480 480,720 720,780
because all the data is
因为所有数据都在数据库中。

234
00:07:44,020 --> 00:07:45,580
0,360 360,570 570,630 630,1260
actually in the database.|
|

235
00:07:46,540 --> 00:07:47,590
0,450 450,660 660,780 780,930 930,1050
{} And so this is,|
所以这是，|

236
00:07:47,590 --> 00:07:49,750
0,750 750,1170 1170,1470 1470,1860 1860,2160
{} good, {} typically does
好的，发生的第一件事，

237
00:07:49,750 --> 00:07:51,010
0,90 90,420 420,570 570,750 750,1260
the first thing that happens|
|

238
00:07:51,280 --> 00:07:52,420
0,180 180,450 450,540 540,1050 1050,1140
and as a website {you,know}
随着网站规模发展。

239
00:07:52,420 --> 00:07:53,540
0,120 120,750
{} scales.|
|

240
00:07:55,340 --> 00:07:57,410
0,330 330,390 390,900 990,1620 1620,2070
{} Of course, {} as
当然，随着你的网站规模进一步扩大，

241
00:07:57,410 --> 00:07:58,610
0,120 120,210 210,390 390,600 600,1200
{} {your -} {website -}

242
00:07:58,610 --> 00:08:01,220
0,360 360,870 1230,1650 1650,2250 2250,2610
scales further,| {} and you
|你需要支持超过，

243
00:08:01,220 --> 00:08:02,990
0,210 210,270 270,1020 1170,1650 1650,1770
need to support more than

244
00:08:02,990 --> 00:08:04,130
0,360 360,450 450,600 600,690 690,1140
say,| you know for example
|比如，一个简单的 MySQL 设置

245
00:08:04,130 --> 00:08:05,750
0,60 60,420 420,660 660,1050 1050,1620
a simple {MySQL - -}

246
00:08:05,900 --> 00:08:07,550
0,510 510,630 630,930 930,1410 1410,1650
setup| can probably support {hundred
|可能支持每秒十万的简单读事务或简单读查询，

247
00:08:07,550 --> 00:08:09,620
0,60 60,870 1170,1380 1380,1740 1740,2070
-} thousand {you,know} simple read

248
00:08:09,650 --> 00:08:11,630
0,930 1050,1260 1260,1470 1470,1770 1770,1980
transactions {} or simple read

249
00:08:11,630 --> 00:08:13,100
0,570 570,720 720,840 840,990 990,1470
queries you know per second,|
|

250
00:08:13,580 --> 00:08:15,620
0,510 540,1020 1020,1110 1110,1290 1290,2040
{} probably you know thousands
可能支持上千的写事务，

251
00:08:15,620 --> 00:08:17,750
0,180 180,690 720,990 990,1710 1950,2130
you know write transactions,| and
|如果来自你的用户的请求总数超过十万，

252
00:08:17,750 --> 00:08:19,790
0,300 300,720 720,810 810,1320 1320,2040
so if the {total,number} requests

253
00:08:19,790 --> 00:08:21,050
0,180 180,390 390,780 780,1050 1050,1260
from your users actually goes

254
00:08:21,050 --> 00:08:23,600
0,660 690,1080 1350,1710 1710,2250
over {} hundred thousand,|
|

255
00:08:23,680 --> 00:08:25,120
0,690 690,690 1140,1230 1230,1380 1380,1440
then {} you need a
然后，你需要一个不同的方案。

256
00:08:25,120 --> 00:08:26,060
0,270 270,600
different plan.|
|

257
00:08:26,530 --> 00:08:27,280
0,150 150,270 270,420 420,510 510,750
And so, then the next
所以，下一个方案是分片。

258
00:08:27,280 --> 00:08:34,500
0,480 750,1560 1770,2340 2340,2850
plan is typically {is,sharding}.|
|

259
00:08:38,270 --> 00:08:40,010
0,690 690,1110 1110,1170 1170,1350 1350,1740
{} And you know so
到目前为止，这一切都是相当标准的，

260
00:08:40,010 --> 00:08:40,820
0,150 150,300 300,390 390,600 600,810
far this is all pretty

261
00:08:40,820 --> 00:08:42,080
0,540 540,900 900,1050 1050,1170 1170,1260
standard,| and so what you
|所以你要做的是，

262
00:08:42,080 --> 00:08:43,460
0,210 210,300 300,780 1020,1290 1290,1380
do is| actually take the
|把存储机器分为多台机器，

263
00:08:43,460 --> 00:08:45,980
0,750 810,1680 1860,2040 2040,2430 2430,2520
storage machine be split in

264
00:08:45,980 --> 00:08:47,180
0,330 330,810
multiple machines,|
|

265
00:08:49,730 --> 00:08:51,020
0,120 120,570 570,960 960,1200 1200,1290
the frontends basically stay the
前端保持不变，

266
00:08:51,020 --> 00:08:52,640
0,510 510,750 750,960 960,1110 1110,1620
same,| we still have are
|我们仍然有很多前端机器，

267
00:08:52,820 --> 00:08:54,760
0,510 510,930 930,1680
many frontend machines,|
|

268
00:09:02,070 --> 00:09:04,890
0,600 600,1260 1260,1470 1470,1980 2280,2820
and {you,know,here,we} have are sharded
这里我们有分片数据库，

269
00:09:04,890 --> 00:09:06,120
0,780
database,|
|

270
00:09:07,940 --> 00:09:09,890
0,330 330,750 750,840 840,1410 1410,1950
and basically you know some
一些键位于，

271
00:09:09,890 --> 00:09:11,600
0,330 330,450 450,990 990,1320 1320,1710
range of keys lives on,|
|

272
00:09:11,600 --> 00:09:13,190
0,390 390,690 690,900 900,1140 1140,1590
whatever maybe 1 to 40
可能 1 到 40 位于分片 1 ，

273
00:09:13,190 --> 00:09:17,060
0,270 270,630 1170,2760 2790,3150 3150,3870
live on {you,know} shard 1,|
|

274
00:09:17,150 --> 00:09:18,770
0,420 420,690 690,840 840,1200 1200,1620
{} might from 40 to
可能 40 到 70 位于分片 2 ，

275
00:09:18,770 --> 00:09:21,230
0,510 510,1020 1020,1320 1320,1830 1920,2460
whatever 70 live on shard

276
00:09:21,230 --> 00:09:22,880
0,270 270,420 420,900 900,1080 1080,1650
2,| and 70 to 100,
|进一步， 70 到 100 位于分片 3 ，

277
00:09:23,030 --> 00:09:23,900
0,120 120,270 270,510 510,630 630,870
you know just to make

278
00:09:23,900 --> 00:09:25,250
0,180 180,570 780,1050 1050,1290 1290,1350
step up, {} live on

279
00:09:25,250 --> 00:09:26,270
0,240 240,450 450,570 570,870 870,1020
shard 3,| so basically you
|你获取数据库中的表或数据库中的行，

280
00:09:26,270 --> 00:09:28,040
0,210 210,510 990,1620 1620,1710 1710,1770
take the tables in the

281
00:09:28,040 --> 00:09:29,030
0,450 450,510 510,630 630,930 930,990
database or the rows in

282
00:09:29,030 --> 00:09:30,920
0,90 90,810 810,1290 1320,1500 1500,1890
the database| and {} sharded
|并按键进行分片。

283
00:09:30,920 --> 00:09:31,540
0,150 150,510
by key.|
|

284
00:09:32,440 --> 00:09:33,640
0,420 420,600 600,750 750,960 960,1200
{} And so when the
所以，前端需要知道，

285
00:09:33,790 --> 00:09:34,870
0,420 420,600 600,660 660,960 960,1080
frontend needs to know,| of
|哪个数据库，

286
00:09:34,870 --> 00:09:36,310
0,240 240,360 360,810 810,1020 1020,1440
course, which database there are|
|

287
00:09:36,490 --> 00:09:38,080
0,750 750,990 990,1170 1170,1230 1230,1590
and {you,know,that -} it needs
它需要获取键 32 ，会去分片 1 ，

288
00:09:38,080 --> 00:09:40,060
0,450 480,720 720,960 960,1500 1860,1980
to {get,you,know,key} {32 -}, you

289
00:09:40,060 --> 00:09:41,560
0,330 330,570 570,840 840,1110 1110,1500
know {it,will,go} to shard 1,|
|

290
00:09:41,560 --> 00:09:42,430
0,150 150,330 330,420 420,630 630,870
it needs to get {you,know}
它需要获取键 50 ，会去分片 2 。

291
00:09:42,430 --> 00:09:44,080
0,360 450,960 960,1350 1350,1500 1500,1650
to key 50, {it,will} go

292
00:09:44,080 --> 00:09:44,940
0,120 120,360 360,600
to shard 2.|
|

293
00:09:46,340 --> 00:09:48,770
0,630 780,1260 1260,1920 1950,2220 2220,2430
{} And so this gives
所以，这为我们提供了数据库并行性，

294
00:09:48,770 --> 00:09:50,660
0,360 360,870 870,1470
us database parallelism,|
|

295
00:09:53,760 --> 00:09:54,700
0,150

296
00:09:56,310 --> 00:09:57,990
0,150 150,300 300,1020 1020,1350 1380,1680
so like every, { -}
所以大多数请求都在两个不同分片上，

297
00:09:57,990 --> 00:10:00,390
0,150 150,540 540,1200 1350,1950 1950,2400
in most {} request actually

298
00:10:00,390 --> 00:10:02,580
0,570 810,1080 1080,1320 1320,1620 1620,2190
are on two different shards,|
|

299
00:10:02,580 --> 00:10:04,050
0,90 90,180 180,990 990,1320 1320,1470
you know basically instead of
而不是被一台机器所限制，

300
00:10:04,050 --> 00:10:05,640
0,390 390,750 750,960 960,1050 1050,1590
actually limited by the one

301
00:10:05,850 --> 00:10:07,770
0,660 660,960 960,1260 1260,1680 1680,1920
machine,| we're actually getting the
|我们得到的吞吐量，

302
00:10:07,800 --> 00:10:08,910
0,360 360,420 420,600 600,990 990,1110
throughput| of one machine, {say,a}
|一台机器比如是十万，

303
00:10:08,910 --> 00:10:10,650
0,300 300,900 930,1350 1350,1650 1650,1740
hundred thousand| times {you,know} the
|乘以我们有的机器数量。

304
00:10:10,650 --> 00:10:11,490
0,210 210,270 270,570 570,750 750,840
number of machines that we

305
00:10:11,490 --> 00:10:12,080
0,360
have.|
|

306
00:10:13,540 --> 00:10:16,060
0,630 1440,1830 1830,2010 2010,2280 2280,2520
{} And so that is
所以这是下一步，

307
00:10:16,060 --> 00:10:18,220
0,960 1050,1410 1410,1470 1470,1680 1680,2160
{} typically the next step,|
|

308
00:10:18,220 --> 00:10:19,180
0,90 90,180 180,420 420,600 600,960
and of course this actually
当然这是，

309
00:10:19,180 --> 00:10:20,830
0,660 750,1230 1230,1500 1500,1590 1590,1650
has,| this step is a
|这一步比第一步更困难，

310
00:10:20,830 --> 00:10:22,270
0,180 180,330 330,510 510,1200 1200,1440
little bit more painful than

311
00:10:22,270 --> 00:10:24,760
0,240 240,510 510,1020 1290,1980 2070,2490
the first step,| {} because
|因为现在你可能有跨分片事务，

312
00:10:24,760 --> 00:10:25,840
0,360 360,480 480,630 630,840 840,1080
now you might actually have

313
00:10:25,840 --> 00:10:28,390
0,420 420,420 900,2190 2310,2460 2460,2550
{cross-shard -} transactions,| if you
|如果你需要它们，

314
00:10:28,390 --> 00:10:29,740
0,180 180,570 960,1170 1170,1230 1230,1350
need them,| or if you
|或者如果你想避免它们，

315
00:10:29,740 --> 00:10:30,610
0,180 180,240 240,510 510,750 750,870
want to avoid them,| you
|你可以对键分组放在同一台机器上，

316
00:10:30,610 --> 00:10:31,960
0,240 240,390 390,660 660,720 720,1350
got {} group the keys

317
00:10:31,960 --> 00:10:33,220
0,120 120,270 270,510 510,1110 1110,1260
you know that go go

318
00:10:33,220 --> 00:10:35,020
0,630 840,1260 1260,1500 1500,1590 1590,1800
together {} on the same

319
00:10:35,020 --> 00:10:37,720
0,690 780,1110 1110,1860 1890,2520 2520,2700
machine,| {} otherwise, {} you
|否则，你需要一些两阶段提交协议，

320
00:10:37,720 --> 00:10:38,530
0,60 60,240 240,390 390,630 630,810
know you need some {two-phase

321
00:10:38,530 --> 00:10:41,050
0,750 750,1020 1020,1920 2070,2370 2370,2520
-} commit protocol,| {} if
|如果使用事跨分片事务，

322
00:10:41,050 --> 00:10:42,520
0,150 150,480 480,690 690,1170 1170,1470
you do {} transaction {cross-shard

323
00:10:42,520 --> 00:10:44,740
0,300 300,630 810,1110 1110,2040 2040,2220
-},| so, {} this, this
|所以，这一步从设计二到设计三，

324
00:10:44,740 --> 00:10:45,760
0,270 270,450 450,540 540,840 840,1020
step {[] - -} {you,know}

325
00:10:45,760 --> 00:10:47,380
0,390 390,600 600,750 750,1140 1140,1620
design two to design three,|
|

326
00:10:47,530 --> 00:10:49,840
0,270 270,510 510,750 750,1650 1680,2310
{} is a significant, a
是非常重要的一步。

327
00:10:49,870 --> 00:10:51,100
0,660 660,1170
significant step.|
|

328
00:10:54,390 --> 00:10:56,790
0,690 870,1410 1860,2010 2010,2160 2160,2400
Now, {} if you grow
现在，如果你扩展更大，

329
00:10:56,790 --> 00:10:58,380
0,240 240,360 360,990 1170,1470 1470,1590
further and further,| {} you
|你可能会说，

330
00:10:58,380 --> 00:10:59,310
0,120 120,240 240,690 690,780 780,930
might say well,| you know
|你可以把数据库分片更多，

331
00:10:59,310 --> 00:11:00,270
0,90 90,180 180,540 540,900 900,960
you could just shard the

332
00:11:00,270 --> 00:11:03,210
0,450 450,1320 1620,2010 2010,2460 2460,2940
database {further,and,further},| {sort,of} fewer key,
|每台服务器的键更少，

333
00:11:03,210 --> 00:11:04,710
0,150 150,480 480,660 660,1200 1260,1500
{} keys per server,| but
|但这增加了风险，

334
00:11:04,710 --> 00:11:06,720
0,210 210,480 480,1380 1410,1890 1890,2010
that actually increases {} you

335
00:11:06,720 --> 00:11:08,370
0,150 150,1110 1110,1440 1440,1560 1560,1650
know the risk,| that you
|你必须进行跨分片事务。

336
00:11:08,370 --> 00:11:09,960
0,240 240,510 510,630 630,1200 1260,1590
actually have to do {}

337
00:11:09,960 --> 00:11:12,120
0,900 930,990 990,1290 1290,2040
{cross-shard -} transactions.|
|

338
00:11:12,680 --> 00:11:14,570
0,450 690,1170 1290,1500 1500,1710 1710,1890
{} So there's another way
还有一条路可以走，

339
00:11:14,570 --> 00:11:16,490
0,60 60,540 540,1110 1110,1320 1320,1920
of going,| which is observed
|观察到，比如，

340
00:11:16,490 --> 00:11:17,930
0,210 210,780 810,1110 1110,1230 1230,1440
like well,| maybe it's not
|也许这并不重要，

341
00:11:17,930 --> 00:11:20,420
0,180 180,840 900,1200 1200,1920 1950,2490
really important,| that the database
|数据库支持读取，

342
00:11:20,420 --> 00:11:22,760
0,630 630,990 990,1110 1110,1680 1830,2340
actually supports the reads, {}|
|

343
00:11:22,760 --> 00:11:23,960
0,120 120,210 210,300 300,720 720,1200
you know we can offload
我们可以从数据库中卸载读取，

344
00:11:23,960 --> 00:11:24,950
0,120 120,540 540,690 690,810 810,990
the reads you know from

345
00:11:24,950 --> 00:11:26,960
0,90 90,810 1020,1350 1350,1860 1860,2010
the database,| and basically the
|数据库只进行写操作，

346
00:11:26,960 --> 00:11:28,550
0,390 390,660 660,840 840,960 960,1590
database only does the writes,|
|

347
00:11:28,670 --> 00:11:30,020
0,450 450,570 570,930 930,1230 1230,1350
{} then maybe we can
那么也许我们可以获得很大的性能提升。

348
00:11:30,020 --> 00:11:31,670
0,150 150,240 240,720 750,1290 1290,1650
get a big performance gain.|
|

349
00:11:32,380 --> 00:11:33,550
0,150 150,270 270,510 510,900 900,1170
And so that's basically the
所以，这是网站采取的下一个常见步骤，

350
00:11:34,150 --> 00:11:36,100
0,570 570,1020 1020,1590 1620,1860 1860,1950
next common step that the

351
00:11:36,100 --> 00:11:38,230
0,480 480,1020 1080,1440 1440,1620 1620,2130
websites take,| {if,they} scale up,|
|如果它们扩展，|

352
00:11:38,410 --> 00:11:39,840
0,930
is
添加缓存，

353
00:11:40,210 --> 00:11:42,780
0,150 150,300 300,540 540,960
{} {you,know} add cache,|
|

354
00:11:51,660 --> 00:11:52,440
0,330 330,390 390,510 510,660 660,780
and you know it could
它可以是 memcached 或 redis 的形式，

355
00:11:52,440 --> 00:11:53,010
0,90 90,180 180,240 240,480 480,570
be in the form of

356
00:11:53,010 --> 00:11:55,500
0,180 180,870 870,1320 1320,1980 2370,2490
{memcached -} or redis,| {you,know,sort,of}
|一种流行的用于缓存的开源软件。

357
00:11:55,500 --> 00:11:57,630
0,1080 1080,1140 1140,1230 1230,1470 1470,2130
popular you know {open-source -}

358
00:11:58,350 --> 00:12:01,410
0,780 780,1110 1110,1650 2040,2550 2760,3060
packages for caching.| And and
|然后基本的计划是，

359
00:12:01,410 --> 00:12:02,460
0,270 270,330 330,600 600,840 840,1050
then the basic plan is,|
|

360
00:12:02,460 --> 00:12:04,140
0,90 90,210 210,600 600,1200 1200,1680
you know so is roughly
大致是这样的，

361
00:12:04,140 --> 00:12:05,130
0,120 120,660 660,780 780,960 960,990
as follows,| you have a
|跟前面一样，你有很多前端，

362
00:12:05,130 --> 00:12:07,230
0,180 180,270 270,960 1260,1410 1410,2100
lot of frontends as before,|
|

363
00:12:13,720 --> 00:12:15,550
0,510 510,690 690,990 990,1650 1650,1830
and we have a set
我们在边上有一些缓存，

364
00:12:15,550 --> 00:12:16,840
0,60 60,510 510,630 630,690 690,1290
of caches on the side,|
|

365
00:12:16,990 --> 00:12:17,980
0,420 450,660 660,690 690,870 870,990
we'll talk a little bit
稍后我们会更详细地讨论这一点，

366
00:12:17,980 --> 00:12:19,570
0,240 240,630 630,810 810,1230 1230,1590
about {that,in,a} second bit more,|
|

367
00:12:19,810 --> 00:12:22,810
0,420 420,1620 1650,2100 2100,2640 2670,3000
{in,case} {} case, {we,get} here
在这种情况下，我们有缓存层，

368
00:12:22,810 --> 00:12:25,400
0,780 1320,1530 1530,1890 1890,2370
caches, {} cache layer,|
|

369
00:12:26,650 --> 00:12:28,180
0,210 210,600 600,870 870,1260 1260,1530
cache 1, cache 2, cache
缓存 1 ，缓存 2 ，缓存 3 ，

370
00:12:28,180 --> 00:12:29,680
0,450 630,1020 1020,1230 1230,1290 1290,1500
3,| and in the case
|在 Facebook 的案例中，这些被称为，

371
00:12:29,680 --> 00:12:31,450
0,120 240,900 900,1080 1080,1200 1200,1770
of Facebook, these are called,|
|

372
00:12:31,900 --> 00:12:33,910
0,210 210,750 750,1290 1290,1770 1770,2010
each individual {server,is} called {memcached
每个单独的服务器被称为 memcached 守护进程，

373
00:12:33,910 --> 00:12:36,250
0,360 360,1140 1350,1980 2010,2100 2100,2340
-} daemon,| and the whole
|整个缓存集群称为 memcache 。

374
00:12:36,250 --> 00:12:37,720
0,480 480,840 840,1020 1020,1380 1380,1470
cluster or the collection of

375
00:12:37,720 --> 00:12:39,280
0,300 300,510 510,780 780,930 930,1560
cache is called {memcache -}.|
|

376
00:12:43,520 --> 00:12:44,720
0,390 390,480 480,660 660,930 930,1200
And you know there's still
我们的数据库仍然存在，

377
00:12:44,720 --> 00:12:47,500
0,120 120,720 870,1110 1110,1770
our database| {you,know} sharded
|分片在多台机器上，

378
00:12:47,960 --> 00:12:52,260
0,960 990,1590 1770,2400 2400,2970
across maybe multiple machines,|
|

379
00:12:52,690 --> 00:12:54,680
0,240 240,780 780,1200 1200,1620
{there's,sort,of} a storage layer.|
这是一个存储层。|

380
00:12:57,800 --> 00:12:58,970
0,240 240,330 330,720 720,1050 1050,1170
And so the idea is
所以想法很简单，

381
00:12:58,970 --> 00:13:01,610
0,150 150,1020 1140,1620 1620,1920 1950,2640
{you,know} pretty { -} straightforward,|
|

382
00:13:01,910 --> 00:13:03,950
0,570 570,1140 1170,1380 1380,1770 1770,2040
{} if {you,know} frontend needs
如果前端需要读取特定的键，

383
00:13:03,950 --> 00:13:05,570
0,510 510,1170 1170,1350 1350,1440 1440,1620
to, {} want to read

384
00:13:05,570 --> 00:13:06,950
0,30 30,360 360,780 900,1140 1140,1380
a particular key,| {you,know} first
|首先从缓存读取，

385
00:13:06,950 --> 00:13:08,040
0,210 210,300 300,960
read to cache,|
|

386
00:13:10,120 --> 00:13:11,560
0,360 360,870 870,990 990,1170 1170,1440
and hopefully you know will
希望会命中缓存，

387
00:13:11,560 --> 00:13:12,580
0,180 180,270 270,330 330,810 810,1020
hit in the cache,| so
|从缓存中得到一个快速的回复，

388
00:13:12,580 --> 00:13:13,750
0,300 300,450 450,480 480,750 750,1170
basically get a quick response

389
00:13:13,750 --> 00:13:15,100
0,390 390,540 540,660 660,1050 1050,1350
back you know from the

390
00:13:16,200 --> 00:13:18,120
0,840 870,1290 1290,1500 1500,1650 1650,1920
{} cache,| if it's not
|如果它不在缓存中，

391
00:13:18,120 --> 00:13:19,110
0,90 90,150 150,630 630,870 870,990
in the cache,| and it
|它可以从存储系统中获取数据，

392
00:13:19,110 --> 00:13:20,160
0,120 120,540 540,780 780,870 870,1050
can retrieve it you know

393
00:13:20,160 --> 00:13:22,950
0,330 330,750 1110,1710 1710,2310 2490,2790
from the storage system,| and
|然后把数据安装到缓存中，

394
00:13:22,950 --> 00:13:24,480
0,300 300,1050 1050,1110 1110,1260 1260,1530
then install you know the

395
00:13:24,480 --> 00:13:25,740
0,270 270,450 450,510 510,1080
data in the cache,|
|

396
00:13:26,490 --> 00:13:28,860
0,630 840,1590 1590,1770 1770,2190 2190,2370
{} writes {you,know} basically go
写数据会直接发送到存储服务器。

397
00:13:28,860 --> 00:13:30,660
0,600 780,960 960,1050 1050,1410 1410,1800
straight to the storage server.|
|

398
00:13:32,740 --> 00:13:34,740
0,480

399
00:13:36,440 --> 00:13:38,750
0,600 1290,1920 1920,2070 2070,2160 2160,2310
And, this, you know this
这个设计，

400
00:13:38,750 --> 00:13:39,920
0,150 150,210 210,420 420,510 510,1170
sort of kind of design,|
|

401
00:13:39,950 --> 00:13:40,880
0,300 300,480 480,660 660,750 750,930
we'll talk about it much
稍后我们将更详细地讨论它，

402
00:13:40,880 --> 00:13:41,600
0,150 150,210 210,270 270,630 630,720
more in the details in

403
00:13:41,600 --> 00:13:42,350
0,30 30,360 360,480 480,600 600,750
a second,| but this sort
|但是这种带有缓存层的设计

404
00:13:42,350 --> 00:13:43,460
0,330 330,750 750,900 900,1020 1020,1110
of design where you have

405
00:13:43,460 --> 00:13:45,260
0,60 60,450 450,870 960,1260 1260,1800
a caching layer| works extremely
|非常适合重读的工作负载，

406
00:13:45,260 --> 00:13:46,940
0,360 360,570 570,780 780,1020 1020,1680
well for read heavy workloads,|
|

407
00:13:46,940 --> 00:13:47,570
0,180 180,300 300,390 390,480 480,630
and so if you think
如果你想一想 Facebook ，

408
00:13:47,570 --> 00:13:49,610
0,450 450,1110 1260,1770 1770,1950 1950,2040
about Facebook,| {} it is
|将是很多用户，

409
00:13:49,610 --> 00:13:50,420
0,120 120,180 180,540 540,630 630,810
going to be you know

410
00:13:50,420 --> 00:13:51,920
0,450 450,720 720,900 900,990 990,1500
a whole lot of users,|
|

411
00:13:52,250 --> 00:13:53,900
0,180 180,360 360,510 510,960 960,1650
and what they're doing is
他们所做的就是阅读人们的帖子，

412
00:13:54,110 --> 00:13:55,610
0,360 360,480 480,540 540,810 810,1500
reading out of people's posts,|
|

413
00:13:55,610 --> 00:13:57,440
0,270 270,510 510,690 690,900 900,1830
{you,know} looking at the timelines,|
查看时间线，|

414
00:13:57,440 --> 00:13:59,480
0,120 120,600 660,1080 1080,1560 1560,2040
you know maybe watching looking
也许查看照片，

415
00:13:59,480 --> 00:14:02,270
0,90 90,960 1170,2100 2160,2700 2700,2790
at pictures,| {} reading the
|阅读新闻、文章等，

416
00:14:02,270 --> 00:14:05,270
0,1380 1380,1980 2130,2550 2550,2880 2880,3000
news, articles etc etc,| so
|所以它是面向读取的繁重的工作负载，

417
00:14:05,270 --> 00:14:09,470
0,180 210,810 810,1950 1950,2910 3270,4200
it's very heavily oriented, {}

418
00:14:09,650 --> 00:14:12,650
0,720 720,960 960,1440 1740,2460 2460,3000
{} {workload -} {} oriented

419
00:14:12,650 --> 00:14:16,370
0,240 240,750 2400,2970 3090,3480 3480,3720
to read,| and {you,know} in
|在这种情况下，

420
00:14:16,370 --> 00:14:17,390
0,210 210,690 690,780 780,900 900,1020
this case,| you know the
|读取几乎都是来自缓存的，

421
00:14:17,390 --> 00:14:18,620
0,330 330,450 450,570 570,810 810,1230
read to be almost served

422
00:14:18,620 --> 00:14:19,520
0,120 120,270 270,690 690,780 780,900
from these caches,| and these
|这些缓存可能非常简单。

423
00:14:19,520 --> 00:14:20,810
0,360 360,480 480,690 690,990 990,1290
caches can be like dirt

424
00:14:20,810 --> 00:14:21,320
0,420
simple.|
|

425
00:14:21,720 --> 00:14:22,780
0,630

426
00:14:23,410 --> 00:14:26,230
0,240 240,480 480,990 990,1890 1950,2820
And think about like the
想像一下缓存，

427
00:14:26,320 --> 00:14:27,850
0,720 720,780 780,930 930,1200 1200,1530
caching,| the key value server
|你在实验 3 中构建的键值服务器，

428
00:14:27,850 --> 00:14:29,140
0,240 240,540 540,630 630,870 870,1290
you built in lab 3,|
|

429
00:14:29,320 --> 00:14:30,010
0,120 120,240 240,330 330,450 450,690
you know the key value
键值服务器本身只是一个哈希表，

430
00:14:30,010 --> 00:14:31,450
0,300 300,690 690,780 780,1140 1140,1440
server itself is actually nothing

431
00:14:31,450 --> 00:14:32,650
0,240 240,390 390,450 450,690 690,1200
more than a hash table,|
|

432
00:14:32,650 --> 00:14:34,270
0,420 420,540 540,1230 1260,1470 1470,1620
maybe you know you want
也许你想要聪明一点，

433
00:14:34,270 --> 00:14:34,690
0,60 60,150 150,180 180,330 330,420
to be a little bit

434
00:14:34,690 --> 00:14:36,820
0,330 330,660 1080,1620 1620,1950 1950,2130
smart about,| having locks for
|对[]加上锁，

435
00:14:36,820 --> 00:14:38,170
0,600 600,870 870,1020 1020,1200 1200,1350
[],| and so you have
|所以，你在缓存服务器中有并发性，

436
00:14:38,170 --> 00:14:39,430
0,90 90,300 300,390 390,900 900,1260
a bunch of concurrency within

437
00:14:39,430 --> 00:14:42,730
0,1080 1110,1680 1680,2280 2550,3090 3090,3300
the {cache,server} itself| {} or
|或者键值服务器，

438
00:14:42,730 --> 00:14:44,110
0,120 120,300 300,600 600,840 840,1380
the key value server itself,|
|

439
00:14:44,170 --> 00:14:45,370
0,390 390,450 450,570 570,990 990,1200
but it is basically pretty
但它是相当简单的。

440
00:14:45,370 --> 00:14:46,380
0,690
straightforward.|
|

441
00:14:47,060 --> 00:14:48,500
0,840

442
00:14:50,160 --> 00:14:51,900
0,150 150,240 240,750 750,1470 1530,1740
There are two challenges that
随之而来的是两个挑战，

443
00:14:51,900 --> 00:14:54,570
0,150 150,810 810,810 1980,2250 2250,2670
come along {} with this,|
|

444
00:14:54,600 --> 00:14:56,130
0,390 390,450 450,720 720,1050 1050,1530
where the main challenge basically
其中的主要挑战是，

445
00:14:56,130 --> 00:14:59,610
0,420 600,1380 1500,2460 2460,3240 3270,3480
is| {} how to keep
|如何保持数据库和缓存的一致性。

446
00:14:59,610 --> 00:15:00,780
0,90 90,960
the database

447
00:15:02,370 --> 00:15:04,180
0,450 450,750 750,1290
{and,the} cache consistent.|
|

448
00:15:07,170 --> 00:15:08,000
0,360

449
00:15:09,360 --> 00:15:11,700
0,570 570,960 960,1470 1560,2190 2190,2340
{That's,sort,of} challenge one,| {} you
这是第一个挑战，|很多论文都致力于谈论这一点。

450
00:15:11,700 --> 00:15:12,360
0,150 150,300 300,510 510,570 570,660
know a lot of the

451
00:15:12,360 --> 00:15:14,880
0,720 720,900 900,1410 1410,1830 2070,2520
paper is devoted to talking

452
00:15:14,880 --> 00:15:15,760
0,240 240,600
about that.|
|

453
00:15:15,970 --> 00:15:19,080
0,690 1050,1800 1950,2700
{} And the
第二个挑战，

454
00:15:19,240 --> 00:15:21,190
0,450 450,1080 1350,1620 1620,1860 1860,1950
second challenge,| {} which is
|也是这个论文的主题，

455
00:15:21,190 --> 00:15:22,360
0,240 240,360 360,960 960,1080 1080,1170
also the {main,theme} from the

456
00:15:22,360 --> 00:15:23,230
0,360 360,480 480,630 630,720 720,870
paper| is how to make
|如何确保数据库不会超载。

457
00:15:23,230 --> 00:15:24,280
0,150 150,270 270,360 360,810 810,1050
sure that the database doesn't

458
00:15:24,280 --> 00:15:25,280
0,120 120,750
get overloaded.|
|

459
00:15:35,970 --> 00:15:38,010
0,510 510,1080 1080,1200 1200,1650 1650,2040
And the the issue here
这里的问题是，

460
00:15:38,010 --> 00:15:40,320
0,240 240,600 930,1260 1260,1950 1950,2310
is that,| {} once {you,know,you}
|一旦你扩展到，

461
00:15:40,320 --> 00:15:41,370
0,330 330,510 510,750 750,960 960,1050
scale up| say to a
|通过使用缓存扩展到例如每秒 10 亿次，

462
00:15:41,370 --> 00:15:43,110
0,540 540,930 930,1050 1050,1470 1470,1740
billion requests per second {you,know}

463
00:15:43,110 --> 00:15:45,030
0,270 270,600 600,960 960,1140 1590,1920
by using caches, { -},|
|

464
00:15:45,030 --> 00:15:46,350
0,360 360,690 690,810 810,900 900,1320
if any of the caches
如果任何缓存出现故障，

465
00:15:46,350 --> 00:15:48,180
0,630 750,990 990,1260 1260,1710 1710,1830
fail,| {} that load will
|负载将从前台转移到数据库，

466
00:15:48,180 --> 00:15:49,740
0,630 660,780 780,900 900,1290 1290,1560
shift you know from the

467
00:15:49,740 --> 00:15:51,330
0,270 270,660 660,780 780,870 870,1590
{frontend -} you know perhaps

468
00:15:51,330 --> 00:15:53,190
0,90 90,750 1140,1500 1500,1740 1740,1860
the database,| {} and of
|当然，数据库完全不是设计，

469
00:15:53,190 --> 00:15:54,540
0,330 330,390 390,510 510,630 630,1350
course you know the database

470
00:15:54,630 --> 00:15:56,730
0,480 480,750 750,1170 1170,1530 1530,2100
{} is completely not designed|
|

471
00:15:56,730 --> 00:15:57,780
0,360 360,690 690,840 840,990 990,1050
to support that kind of
来支持这种工作负载，

472
00:15:57,780 --> 00:15:59,760
0,600 720,1140 1140,1290 1290,1530 1530,1980
workload,| basically will fall over.|
|基本上会倒下。|

473
00:16:00,140 --> 00:16:02,150
0,450 450,720 720,1080 1080,1470 1470,2010
And so a key challenge
所以整个课程中的一个关键挑战，

474
00:16:02,150 --> 00:16:04,940
0,720 930,1410 1410,1560 1560,2460 2550,2790
in {} the whole set

475
00:16:04,940 --> 00:16:05,810
0,90 90,420 420,540 540,630 630,870
of lessons,| that you learn
|你从这篇论文中学到的，

476
00:16:05,810 --> 00:16:08,240
0,240 240,690 690,1440 1470,2040 2130,2430
from this particular paper| is
|是避免访问数据库的技术，

477
00:16:08,240 --> 00:16:10,280
0,210 210,810 810,1020 1020,1380 1380,2040
that techniques to basically avoid

478
00:16:10,310 --> 00:16:11,750
0,450 450,570 570,690 690,1290 1290,1440
going to the database,| so
|所以，没有使数据库过载的风险。

479
00:16:11,750 --> 00:16:13,610
0,360 360,570 570,1140 1200,1500 1500,1860
there's no risk that actually

480
00:16:13,610 --> 00:16:15,620
0,390 390,1110 1110,1170 1170,1920
you overload the database.|
|

481
00:16:16,380 --> 00:16:17,660
0,510

482
00:16:19,520 --> 00:16:20,690
0,270 270,600 600,720 720,1050 1050,1170
Okay, any other questions so
好的，到目前为止，还有其他问题吗？

483
00:16:20,690 --> 00:16:21,460
0,450
far?|
|

484
00:16:27,310 --> 00:16:28,150
0,270 270,360 360,570 570,660 660,840
Let me say a little
让我简单地说一下一致性，

485
00:16:28,150 --> 00:16:30,880
0,750 780,1080 1080,1890 1950,2520 2520,2730
bit about consistency,| because that
|因为那会是，

486
00:16:30,880 --> 00:16:31,900
0,210 210,600 600,810 810,900 900,1020
will be,| although I'm going
|虽然我将主要讨论性能，

487
00:16:31,900 --> 00:16:33,070
0,60 60,210 210,450 450,630 630,1170
to talk mostly about performance,|
|

488
00:16:33,070 --> 00:16:34,870
0,420 420,630 630,810 810,1080 1320,1800
{you,know} it's gonna be important
记住这一点很重要，

489
00:16:34,870 --> 00:16:35,890
0,90 90,270 270,330 330,690 690,1020
to keep in mind,| even
|甚至在关于性能的部分。

490
00:16:35,890 --> 00:16:36,790
0,150 150,300 300,510 510,570 570,900
in the sort of section

491
00:16:36,790 --> 00:16:39,260
0,270 270,930 930,1410 1410,2100
about consistency, about performance.|
|

492
00:16:39,760 --> 00:16:41,650
0,480 690,930 930,990 990,1590 1590,1890
Oh, {I,have} a quick question,
哦，我有个小问题，抱歉，

493
00:16:41,650 --> 00:16:43,660
0,480 870,1350 1350,1500 1500,1740 1740,2010
sorry,| {} {} goes back
|回到比如客户端是无状态的，

494
00:16:43,660 --> 00:16:44,830
0,180 180,450 450,750 750,870 870,1170
to, like having this state,

495
00:16:44,830 --> 00:16:45,820
0,180 180,690
like the

496
00:16:45,990 --> 00:16:49,220
0,720 750,1500 1500,1920 1920,2640
{} clients be stateless,|
|

497
00:16:49,520 --> 00:16:51,170
0,600 630,840 840,1110 1110,1470 1470,1650
{} so what,| yeah, there
那么,|是的，在网站解决方案的第二部分，

498
00:16:51,170 --> 00:16:52,400
0,90 90,330 360,540 540,810 840,1230
we go, on the second

499
00:16:52,400 --> 00:16:53,690
0,210 210,270 270,600 600,930 930,1290
part of website solution,| why
|为什么客户端必须是无状态的？

500
00:16:53,690 --> 00:16:55,040
0,90 90,150 150,750 1140,1260 1260,1350
is it important for the

501
00:16:55,040 --> 00:16:56,580
0,270 270,360 360,480 480,1350
clients to be stateless?|
|

502
00:16:56,780 --> 00:16:58,790
0,330 780,1140 1140,1200 1200,1650 1650,2010
{} {That,makes} the replication easy,
这使得复制变得很容易，

503
00:16:58,850 --> 00:17:00,620
0,330 330,720 750,1050 1050,1230 1230,1770
right,| the clients don't actually,
|客户端不用，你不用复制数据，

504
00:17:00,620 --> 00:17:01,730
0,150 150,570 570,630 630,990 990,1110
{you,don't} replicate the data,| so
|所以，你不必保持数据的一致性，

505
00:17:01,730 --> 00:17:02,300
0,90 90,240 240,360 360,450 450,570
you don't have to keep

506
00:17:02,300 --> 00:17:03,400
0,90 90,270 270,810
the data consistent,|
|

507
00:17:04,480 --> 00:17:05,500
0,120 120,270 270,510 510,810 810,1020
you know all data lives
所有的数据都在一个地方，

508
00:17:05,500 --> 00:17:07,360
0,60 60,240 240,750 1380,1770 1770,1860
in one place,| maybe there
|也许这里有一个数据库服务器。

509
00:17:07,360 --> 00:17:08,640
0,120 120,150 150,540 540,990
is a database server.|
|

510
00:17:09,300 --> 00:17:11,010
0,450 480,900 930,1260 1260,1410 1410,1710
Okay, yeah, so the idea
好的，所以这个想法是，

511
00:17:11,010 --> 00:17:12,600
0,90 90,240 240,720 1050,1320 1320,1590
is,| like any any client
|任何客户都可以失败，这并不重要。

512
00:17:12,600 --> 00:17:14,340
0,450 450,1020 1050,1380 1380,1500 1500,1740
can fail and it doesn't

513
00:17:14,340 --> 00:17:15,840
0,390 570,900 900,960 960,1110 1110,1500
matter.| Yeah, it doesn't matter,|
|是的，这不重要，|

514
00:17:15,840 --> 00:17:18,630
0,1200 1200,1260 1530,1920 1920,2100 2100,2790
{} {you,know} keep going computing,|
继续进行计算，|

515
00:17:18,690 --> 00:17:19,830
0,480 480,660 660,840 840,1050 1050,1140
{} and you don't have
你不必担心保持数据的一致性，

516
00:17:19,830 --> 00:17:20,940
0,120 120,420 420,660 660,900 900,1110
to worry about actually keeping

517
00:17:20,940 --> 00:17:22,200
0,330 330,750 750,990 990,1170 1170,1260
data consistent,| because data is
|因为数据只在一个地方，

518
00:17:22,200 --> 00:17:23,280
0,210 210,270 270,450 450,930
only in one place,|
|

519
00:17:25,300 --> 00:17:26,140
0,270 270,450 450,540 540,600 600,840
{like,a} lot of the things
我们这学期谈到的很多事情，

520
00:17:26,140 --> 00:17:27,070
0,150 150,300 300,570 570,750 750,930
we've been talking about this

521
00:17:27,070 --> 00:17:28,750
0,420 420,930 930,1470 1470,1590 1590,1680
semester,| doesn't show up in
|在这个设计中没有体现出来。

522
00:17:28,750 --> 00:17:30,020
0,180 180,540 540,930
this particular design.|
|

523
00:17:32,820 --> 00:17:33,940
0,840
Okay?|
好的?|

524
00:17:35,730 --> 00:17:37,380
0,330 330,780 780,1020 1020,1260 1260,1650
Okay, so getting back to
好了，让我们回到，

525
00:17:37,380 --> 00:17:38,970
0,210 210,480 480,1020 1170,1440 1440,1590
sort of,| {} once you
|一旦你缓存了数据，

526
00:17:38,970 --> 00:17:40,830
0,240 240,720 750,1380 1380,1650 1650,1860
do actually cache data,| you
|你就有了一致性问题，

527
00:17:40,830 --> 00:17:42,330
0,120 120,360 360,480 480,1080 1080,1500
do have this consistency {issue\,,right},|
|

528
00:17:42,810 --> 00:17:45,510
0,810 810,1500 1650,2160 2160,2370 2370,2700
{} and {} and so
所以当前的问题是，

529
00:17:45,660 --> 00:17:46,650
0,150 150,240 240,360 360,630 630,990
you know the instant {question,is},|
|

530
00:17:46,650 --> 00:17:48,000
0,150 150,450 450,960 960,1200 1200,1350
like what database, what is
Facebook 的目标是什么。

531
00:17:48,000 --> 00:17:49,400
0,210 210,540 540,840 840,1200
{} Facebook shooting for.|
|

532
00:17:49,770 --> 00:17:51,840
0,450 480,870 870,1140 1380,1770 1770,2070
And something is typically called
一些东西被称为，

533
00:17:51,840 --> 00:17:53,250
0,330 330,480 480,780 780,1020 1020,1410
almost,| like it's called eventual
|它被称为最终一致性，

534
00:17:53,250 --> 00:17:54,870
0,750 750,900 900,1050 1050,1230 1230,1620
consistency,| which a pretty vague
|这是一个相当模糊的术语，

535
00:17:54,900 --> 00:17:58,020
0,480 840,1500 1830,2220 2220,3000 3000,3120
term,| {} but basically you
|但是也许是为了对比一下，

536
00:17:58,020 --> 00:17:59,190
0,270 270,510 510,600 600,1080 1080,1170
know maybe to contrast it

537
00:17:59,190 --> 00:18:00,600
0,270 270,480 480,960 1050,1200 1200,1410
is,| to say it actually
|可以说，它并不追求线性一致性，

538
00:18:00,600 --> 00:18:02,010
0,240 240,660 690,1020 1020,1200 1200,1410
does not shoot for {linearizability

539
00:18:02,010 --> 00:18:02,860
0,150 150,630
- -},|
|

540
00:18:03,480 --> 00:18:05,790
0,510 510,1230 1290,1680 1680,1860 1860,2310
{} and {} in fact
事实上，他们所追求的是，

541
00:18:05,790 --> 00:18:07,020
0,180 180,300 300,510 510,720 900,1230
what they sort of shooting

542
00:18:07,020 --> 00:18:08,160
0,270 270,660 660,840 840,990 990,1140
for is,| you know they
|他们想要按顺序写入，

543
00:18:08,160 --> 00:18:10,040
0,120 120,510 570,1050 1050,1560
do want write ordering,|
|

544
00:18:14,670 --> 00:18:17,340
0,630 630,1230 1530,1800 1800,2010 2010,2670
{writes,are,all} applies in some consistent
写入是以某种一致的整体顺序来应用的，

545
00:18:17,340 --> 00:18:18,420
0,150 150,300 300,510 510,960 960,1080
you know total order,| so
|你不会在时间问题上感到奇怪，

546
00:18:18,420 --> 00:18:19,830
0,150 150,300 300,510 510,810 810,1410
that you don't get weird

547
00:18:20,130 --> 00:18:21,930
0,510 510,750 750,810 810,1080 1080,1800
going back in time problems,|
|

548
00:18:22,140 --> 00:18:23,070
0,390 390,540 540,690 690,750 750,930
{} and that is all
这些都是由数据库完成的，

549
00:18:23,070 --> 00:18:24,570
0,210 210,570 570,720 720,810 810,1500
done basically by the database,|
|

550
00:18:28,180 --> 00:18:29,410
0,240 240,600 600,870 870,1050 1050,1230
so not really a big
对于 memcache 层来说，这并不是一个大问题。

551
00:18:29,410 --> 00:18:31,690
0,720 750,870 870,990 990,1740 1830,2280
concern you know for {}

552
00:18:31,690 --> 00:18:33,250
0,120 120,360 360,840 840,960 960,1560
the {memcache -} layer itself.|
|

553
00:18:34,350 --> 00:18:36,750
0,420 420,690 690,810 810,1440 1710,2400
{} {In,terms,of -} reads, {}
在读取方面，如果读取落后也没关系，

554
00:18:36,750 --> 00:18:38,670
0,480 480,960 960,1110 1110,1440 1440,1920
it's okay, if {reads,are} behind,|
|

555
00:18:48,590 --> 00:18:49,580
0,180 180,300 300,450 450,600 600,990
and {} that is really
这就是应用程序的属性，

556
00:18:49,580 --> 00:18:51,080
0,120 120,630 630,750 750,840 840,1500
the property of the applications,|
|

557
00:18:51,080 --> 00:18:52,160
0,270 270,360 360,450 450,780 780,1080
that you know Facebook wants
Facebook 想要支持的应用程序，

558
00:18:52,160 --> 00:18:54,560
0,600 870,1470 1470,1590 1590,1860 1860,2400
{to,support},| again you know the
|再次，这些缓存中的数据，

559
00:18:55,640 --> 00:18:57,740
0,870 870,1080 1080,1170 1170,1350 1350,2100
data that's in these caches,|
|

560
00:18:57,740 --> 00:18:58,580
0,210 210,270 270,540 540,690 690,840
{} the data that the
用户使用的数据，

561
00:18:58,580 --> 00:19:00,950
0,360 360,570 570,1050 1320,1710 1710,2370
user actually consume,| web pages,
|网页、帖子时间表、朋友列表和所有类似的东西，或状态，

562
00:19:00,950 --> 00:19:05,450
0,930 960,1680 1710,3240 3420,3840 3840,4500
{} post timelines, friend lists

563
00:19:05,450 --> 00:19:06,020
0,150 150,270 270,390 390,510 510,570
and all that kind of

564
00:19:06,020 --> 00:19:06,580
0,390
stuff,

565
00:19:06,820 --> 00:19:09,400
0,510 510,660 660,1470 1590,2160 2160,2580
and or status,| {} and
|对于用户来说，这些都不是那么重要，

566
00:19:09,430 --> 00:19:10,960
0,480 480,570 570,660 660,1380 1380,1530
none of that actually is

567
00:19:10,960 --> 00:19:12,730
0,510 510,780 780,1290 1290,1410 1410,1770
really that important for users

568
00:19:12,730 --> 00:19:14,170
0,90 90,420 420,480 480,990 1080,1440
to see,| {} very, {}
|更新你的照片，

569
00:19:14,170 --> 00:19:16,510
0,390 780,990 990,1620 1620,1770 1770,2340
{} {you,know} update your picture,|
|

570
00:19:16,510 --> 00:19:18,070
0,90 90,690 840,1290 1290,1350 1350,1560
you know {it,is} {} behind
它稍微晚了一两秒，

571
00:19:18,070 --> 00:19:19,030
0,90 90,270 270,690 690,870 870,960
a little bit one or

572
00:19:19,030 --> 00:19:20,350
0,120 120,630 630,930 930,1230 1230,1320
two seconds,| no problem at
|一点问题都没有,

573
00:19:20,350 --> 00:19:22,360
0,300 720,1080 1080,1500 1500,1740 1740,2010
all,| {} certainly left behind
|当然会落后几百毫秒的时间，

574
00:19:22,360 --> 00:19:24,640
0,510 510,780 780,840 840,1500 1740,2280
for hundreds of milliseconds,| {you,know,user}
|用户甚至不会注意到，

575
00:19:24,640 --> 00:19:25,810
0,240 240,420 420,900 900,1020 1020,1170
won't even notice,| you know
|不会察觉到，

576
00:19:25,810 --> 00:19:28,240
0,360 360,540 540,1170 1590,2130 2250,2430
there's not perceptible,| and so
|所以落后也没关系，

577
00:19:28,240 --> 00:19:29,560
0,120 120,420 420,690 690,1140 1140,1320
it's okay to behind,| you
|当然你不想落后几个小时，

578
00:19:29,560 --> 00:19:30,400
0,300 300,510 510,660 660,750 750,840
know of course you don't

579
00:19:30,400 --> 00:19:31,180
0,150 150,210 210,390 390,660 660,780
want to be behind for

580
00:19:31,180 --> 00:19:32,380
0,540 540,660 660,750 750,1080 1080,1200
hours,| you know {user -}
|用户可能会注意到，

581
00:19:32,380 --> 00:19:34,870
0,210 210,450 450,1020 1230,2040 2220,2490
might actually notice,| but you
|但在一小段时间内落后，

582
00:19:34,870 --> 00:19:35,620
0,150 150,270 270,330 330,540 540,750
know for a little while

583
00:19:35,620 --> 00:19:36,640
0,270 270,390 390,720 720,810 810,1020
behind,| this actually are not
|这并不是什么特别大的事情。

584
00:19:36,640 --> 00:19:37,900
0,90 90,750 750,900 900,1200
a particular big deal.|
|

585
00:19:38,660 --> 00:19:40,940
0,510 720,1080 1110,1440 1440,1740 1740,2280
{} So they're {not,really} shoot
所以他们的不是为了线性一致性，

586
00:19:41,000 --> 00:19:42,620
0,150 150,300 300,840 930,1230 1230,1620
you know for {serializability -}

587
00:19:42,620 --> 00:19:44,030
0,270 270,600 600,780 780,1080 1080,1410
{linearizability - -},| where read
|读取观察到最新的写入，

588
00:19:44,060 --> 00:19:45,680
0,360 360,450 450,810 810,1230 1440,1620
observe the last write,| you
|如果[]写入，这是可以的。

589
00:19:45,680 --> 00:19:47,750
0,810 930,1230 1230,1440 1440,1740 1740,2070
know [] some [] write,

590
00:19:47,750 --> 00:19:48,800
0,180 180,420 420,810
{you,know} that's fine.|
|

591
00:19:49,140 --> 00:19:50,730
0,540 570,780 780,1050 1050,1500 1500,1590
{} There's one exception to
但有一个例外，

592
00:19:50,730 --> 00:19:52,350
0,420 630,960 960,1140 1140,1410 1410,1620
that,| which is that they
|那就是他们想要安排，

593
00:19:52,350 --> 00:19:53,610
0,150 150,360 360,510 510,990 990,1260
do want to arrange that,|
|

594
00:19:53,610 --> 00:19:54,930
0,90 90,180 180,360 360,1080 1080,1320
you know {sort,of} clients read
客户端读取自己的写入，

595
00:19:54,930 --> 00:19:56,880
0,240 240,750 780,1470
their own writes,|
|

596
00:20:06,760 --> 00:20:09,190
0,390 390,990 1320,1710 1710,2070 2070,2430
and {} and meaning that
这意味着如果一个客户端更新键 k

597
00:20:09,190 --> 00:20:10,780
0,150 150,240 240,840 870,1230 1230,1590
you know if {} one

598
00:20:10,780 --> 00:20:13,690
0,570 660,1410 1410,2040 2070,2370 2370,2910
client updates {} key k|
|

599
00:20:13,900 --> 00:20:15,490
0,180 180,420 420,870 870,1440 1440,1590
and then immediately {read,that} at
然后立即读取键 k ，

600
00:20:15,490 --> 00:20:16,930
0,210 210,660 750,960 960,1170 1170,1440
key k,| {} it's very
|非常希望客户端观察自身的写入，

601
00:20:16,930 --> 00:20:18,820
0,690 690,990 990,1320 1320,1590 1590,1890
desirable that client actually does

602
00:20:18,820 --> 00:20:21,520
0,540 540,750 750,1290 1470,2220 2250,2700
observe its own {} write,|
|

603
00:20:21,610 --> 00:20:22,660
0,300 300,570 570,780 780,840 840,1050
because actually makes it more
因为这让事情变得更加复杂，

604
00:20:22,660 --> 00:20:25,240
0,690 690,1350 1350,1830 1830,2310 2310,2580
complicated to,| otherwise maybe {[]
|否则，[]可能会更加复杂。

605
00:20:25,240 --> 00:20:26,470
0,540 540,660 660,840 840,990 990,1230
-} would be even more

606
00:20:26,470 --> 00:20:27,300
0,510
complicated.|
|

607
00:20:27,670 --> 00:20:28,870
0,210 210,360 360,600 600,780 780,1200
{} So this is roughly
所以，这就是他们要争取的目标，

608
00:20:28,870 --> 00:20:30,260
0,180 180,300 300,630 630,1110
what they're shooting for,|
|

609
00:20:30,760 --> 00:20:32,680
0,660 960,1470 1470,1560 1560,1680 1680,1920
{} and you know just
只是稍微弱了一点，

610
00:20:32,680 --> 00:20:34,180
0,330 330,390 390,570 570,1170 1200,1500
quite a bit weaker| than
|比我们以前见过的一些模型，

611
00:20:34,180 --> 00:20:35,020
0,180 180,270 270,360 360,690 690,840
some of the models that

612
00:20:35,020 --> 00:20:36,730
0,480 480,690 690,1170 1470,1620 1620,1710
we've seen before,| and {remind
|让我想起 Zookeeper ，

613
00:20:36,730 --> 00:20:38,050
0,300 300,510 510,570 570,780 780,1320
-} me a little bit

614
00:20:38,050 --> 00:20:40,390
0,240 240,540 570,1650 1650,2130 2160,2340
from the {Zookeeper -} {}|
|

615
00:20:40,390 --> 00:20:42,550
0,150 150,210 210,810 1050,1410 1410,2160
sort of style of {}
可以提供的合约风格。

616
00:20:42,580 --> 00:20:44,380
0,780 780,900 900,1170 1170,1680 1680,1800
contract you know it can

617
00:20:44,380 --> 00:20:45,040
0,390
provide.|
|

618
00:20:48,320 --> 00:20:49,820
0,210 210,480 480,840 840,1050 1050,1500
Okay, so one other thing
好的，还有一件事我想说，

619
00:20:49,850 --> 00:20:50,690
0,270 270,330 330,480 480,540 540,840
that I want to say,|
|

620
00:20:50,690 --> 00:20:51,800
0,330 330,570 570,600 600,810 810,1110
go back a little bit,|
往回一点，|

621
00:20:52,130 --> 00:20:53,360
0,690 690,870 870,990 990,1170 1170,1230
{} so we need to
我们需要将数据库保存在缓存中，

622
00:20:53,360 --> 00:20:54,860
0,210 210,300 300,870 870,990 990,1500
keep the databases in caches|
|

623
00:20:54,860 --> 00:20:56,690
0,810 840,1110 1110,1500 1500,1590 1590,1830
and cache consistency in some
以某种方式保持缓存一致性。

624
00:20:56,690 --> 00:20:57,380
0,480
manner.|
|

625
00:20:57,950 --> 00:21:00,560
0,330 330,780 900,1110 1110,1470 1470,2610
Okay, so the basic plan
好的， Facebook 的基本方案是，

626
00:21:00,560 --> 00:21:03,200
0,630 660,1110 1110,1470 1470,2460
that {} Facebook follows,|
|

627
00:21:05,490 --> 00:21:06,690
0,180 180,330 330,510 510,660 660,1200
{is,an - -} {invalidation -}
是缓存失效方案。

628
00:21:06,690 --> 00:21:07,460
0,390
plan

629
00:21:08,660 --> 00:21:10,860
0,210 210,690 690,1200 1200,1650
or cache invalidation plan.|
|

630
00:21:16,780 --> 00:21:18,280
0,330 330,1050 1050,1200 1200,1440 1440,1500
And we'll see later in
我们会在后面的课程中看到，为什么是这样，

631
00:21:18,280 --> 00:21:19,660
0,60 60,630 630,930 930,1290 1290,1380
the lecture why that's the

632
00:21:19,660 --> 00:21:21,970
0,540 600,1080 1080,1260 1260,1890 1920,2310
case,| basically what happens, if
|发生的是，如果前端执行写入，

633
00:21:21,970 --> 00:21:24,440
0,90 90,810 960,1260 1260,1800
the frontend does write,|
|

634
00:21:25,650 --> 00:21:27,060
0,750 750,900 900,990 990,1170 1170,1410
{} {you,know} it goes actually
它进入数据库，

635
00:21:27,060 --> 00:21:28,500
0,120 120,210 210,1170
to the database,|
|

636
00:21:30,200 --> 00:21:31,800
0,270 270,450 450,1290
here's {MySQL -},|
这是 MySQL ，|

637
00:21:35,000 --> 00:21:36,920
0,300 300,450 450,570 570,1230 1320,1920
{} but they run on
但他们在数据库旁边运行另一个程序，

638
00:21:36,920 --> 00:21:38,210
0,300 300,390 390,480 480,1140 1140,1290
next to the database you

639
00:21:38,210 --> 00:21:41,060
0,150 150,570 570,1230 2070,2610 2610,2850
know another program,| whatever called
|称为 squeal ，

640
00:21:41,060 --> 00:21:42,000
0,630
squeal,|
|

641
00:21:45,170 --> 00:21:46,790
0,480 480,960 960,1320 1320,1530 1530,1620
and basically it looks at
它会查看事务日志，

642
00:21:46,790 --> 00:21:49,280
0,90 90,630 630,1110 1860,2250 2280,2490
the transaction log,| so {MySQL
|MySQL 维护事务日志以实现事务，

643
00:21:49,280 --> 00:21:51,500
0,540 540,1200 1200,1710 1710,2010 2010,2220
-} maintains transaction log {you,know}

644
00:21:51,500 --> 00:21:53,930
0,360 360,1200 1440,2010 2010,2190 2190,2430
{to,implement} transactions,| and {you,know} squeal
|squeal 查看这个事务日志，看看什么东西被修改了，

645
00:21:53,930 --> 00:21:55,640
0,420 420,570 570,720 720,1200 1200,1710
looks like this transaction log,

646
00:21:55,730 --> 00:21:58,190
0,840 840,1260 1260,1470 1470,1680 1680,2460
sees what things get modified,|
|

647
00:21:58,430 --> 00:22:00,580
0,810 810,1590
and basically
如果有一个键被修改，

648
00:22:01,230 --> 00:22:03,900
0,270 270,480 480,1080 1800,2460 2460,2670
if there's a key gets

649
00:22:03,900 --> 00:22:05,340
0,630 630,810 810,900 900,1170 1170,1440
modified,| so it seems like
|它看到键 k 被修改了，

650
00:22:05,340 --> 00:22:07,410
0,420 420,630 630,1290 1350,1650 1650,2070
{key,k} gets modified,| {it,will} send
|它向缓存发送失效消息，

651
00:22:07,410 --> 00:22:08,760
0,210 210,750 750,1110 1110,1260 1260,1350
an invalidation message to the

652
00:22:08,760 --> 00:22:12,020
0,600 690,1680 1680,2400
cache,| basically deleting,
|删除，它只是发送一个删除键 k ，

653
00:22:13,190 --> 00:22:14,510
0,420 420,630 630,810 810,1230 1230,1320
actually it just issues a

654
00:22:14,510 --> 00:22:16,340
0,540 540,780 780,960 960,1500 1650,1830
delete {of,that} key k,| {you,know}
|到合适的缓存，

655
00:22:16,340 --> 00:22:17,870
0,240 240,450 450,900 900,1410 1440,1530
to the appropriate cache,| and
|这样数据将被删除，

656
00:22:17,870 --> 00:22:18,620
0,180 180,420 420,540 540,660 660,750
that way you know the

657
00:22:18,620 --> 00:22:20,210
0,270 270,480 480,630 630,1230 1440,1590
data will be removed,| and
|然后在之后的某个时候，

658
00:22:20,210 --> 00:22:21,350
0,150 150,270 270,420 420,660 660,1140
then at some point later,|
|

659
00:22:22,030 --> 00:22:24,580
0,720 750,1410 1410,1770 1770,1980 1980,2550
when a client comes along,
当客户端出现，执行读取，

660
00:22:25,730 --> 00:22:28,310
0,420 420,1080 1650,1950 1950,2370 2370,2580
{does,a} read,| it will get
|它不会在缓存命中，

661
00:22:28,310 --> 00:22:29,480
0,60 60,630
a miss

662
00:22:29,680 --> 00:22:33,160
0,630 630,1050 1050,2070 2070,2760 2940,3480
{} in the cache,| read
|读取从这里查找数据，

663
00:22:33,160 --> 00:22:35,140
0,210 210,660 660,750 750,1260 1290,1980
{} retrieves the data from

664
00:22:37,190 --> 00:22:38,900
0,600 600,780 780,1080 1080,1230 1230,1710
{} and read from there,|
|

665
00:22:39,020 --> 00:22:40,790
0,240 240,480 480,750 750,1320 1320,1770
so here {it,does} get,| {let,me}
所以这里是 get ，|让我把这称为 get ，

666
00:22:40,850 --> 00:22:42,770
0,360 360,810 960,1320 1320,1440 1440,1920
{call,this} {a,get},| there's a reed,
|这里有一个 read ，从 read 获取数据，

667
00:22:43,100 --> 00:22:44,120
0,570 570,630 630,840 840,960 960,1020
gets the data from the

668
00:22:44,120 --> 00:22:45,440
0,270 270,390 390,570 570,840 840,1320
read,| and then actually installs
|然后安装到缓存中。

669
00:22:45,440 --> 00:22:46,520
0,120 120,240 240,330 330,990
it in the cache.|
|

670
00:22:48,100 --> 00:22:48,940
0,330 330,450 450,630 630,750 750,840
And so one thing you
所以，你可能会想，

671
00:22:48,940 --> 00:22:50,860
0,150 150,510 510,720 720,1200 1200,1920
might wonder,| like why actually
|为什么应用程序自己将数据安装到缓存中，

672
00:22:51,160 --> 00:22:53,170
0,300 300,390 390,870 870,1380 1380,2010
does the application itself installed

673
00:22:53,170 --> 00:22:55,090
0,540 570,900 900,1320 1320,1380 1380,1920
the data into the cache,|
|

674
00:22:55,120 --> 00:22:57,730
0,150 150,210 210,420 420,840 1740,2610
so it does put,| and
所以它执行 put ，|这与这些缓存有关，

675
00:22:57,730 --> 00:22:58,660
0,240 240,390 390,480 480,750 750,930
this has to do with

676
00:22:58,660 --> 00:23:00,100
0,360 360,660 660,1200 1200,1350 1350,1440
actually these caches,| you know
|他们所说的旁路缓存，

677
00:23:00,100 --> 00:23:01,090
0,180 180,300 300,690 690,810 810,990
what they call are {look-aside

678
00:23:01,090 --> 00:23:02,640
0,420 420,1020
-} caches,|
|

679
00:23:05,090 --> 00:23:05,870
0,150 150,210 210,480 480,630 630,780
and the reason they're sort
它们是旁路的原因是，

680
00:23:05,870 --> 00:23:06,770
0,90 90,240 240,600 600,750 750,900
of {look-aside -} is that,|
|

681
00:23:06,770 --> 00:23:08,360
0,390 390,840 840,1020 1020,1110 1110,1590
because typically what the application
因为通常应用程序所做的，

682
00:23:08,360 --> 00:23:09,380
0,150 150,420 420,630 630,750 750,1020
will do| with the data
|数据从数据库中读取，

683
00:23:09,380 --> 00:23:10,340
0,240 240,510 510,750 750,870 870,960
that actually read from the
实际从数据库中读取的数据，

684
00:23:10,340 --> 00:23:12,080
0,630 780,930 930,1230 1230,1650 1650,1740
database,| it's maybe {[] -}
|这有一点[]，

685
00:23:12,080 --> 00:23:12,860
0,60 60,240 240,390 390,660 660,780
a little bit,| there's some
|它上面有一些计算，

686
00:23:12,860 --> 00:23:14,060
0,570 570,720 720,810 870,1020 1020,1200
computation on it,| and it'll
|它将获取页面的文本，

687
00:23:14,060 --> 00:23:15,320
0,210 210,420 450,840 840,930 930,1260
take the text of the

688
00:23:15,410 --> 00:23:16,700
0,510 510,600 600,990 990,1200 1200,1290
page,| and actually turn it
|将其转换为 HTML 页面或 HTML5 ，

689
00:23:16,700 --> 00:23:18,290
0,240 240,330 330,960 960,1500 1500,1590
into an HTML page or

690
00:23:18,290 --> 00:23:19,880
0,600 600,900 1200,1320 1320,1410 1410,1590
{HTML5 -},| and then store
|然后将页面的 HTML 版本的结果存储到缓存中，

691
00:23:19,880 --> 00:23:21,620
0,120 120,780 810,990 990,1260 1260,1740
the result of that {}

692
00:23:21,620 --> 00:23:23,150
0,570 570,1080 1080,1170 1170,1260 1260,1530
HTML version of the page

693
00:23:23,150 --> 00:23:24,830
0,270 270,540 540,600 600,1170 1410,1680
actually into the cache,| or
|或者可能读取很多记录，

694
00:23:24,830 --> 00:23:26,030
0,450 450,630 630,930 930,990 990,1200
maybe {you,know} reads a bunch

695
00:23:26,030 --> 00:23:27,890
0,60 60,270 270,900 930,1740 1740,1860
of different records| aggregates you
|聚合一些数据，

696
00:23:27,890 --> 00:23:29,660
0,150 150,390 390,930 1020,1560 1560,1770
know some data| and {you,know}
|并将聚合结果放入缓存中。

697
00:23:29,660 --> 00:23:31,160
0,180 180,360 360,930 930,1350 1350,1500
puts the aggregated result into

698
00:23:31,160 --> 00:23:31,700
0,480
cache.|
|

699
00:23:32,150 --> 00:23:33,350
0,270 270,360 360,870 870,1110 1110,1200
So the application {is,sort,of -}
所以，应用程序控制，

700
00:23:33,350 --> 00:23:35,210
0,60 60,930 1020,1530 1530,1680 1680,1860
in control,| {} in this
|在这个设计中，

701
00:23:35,210 --> 00:23:36,650
0,720 750,1080 1080,1140 1140,1350 1350,1440
design,| what to put in
|将什么放入缓存中，

702
00:23:36,650 --> 00:23:37,580
0,60 60,540 570,690 690,780 780,930
the cache,| and it puts
|这给前端或应用程序增加了负担，

703
00:23:37,580 --> 00:23:38,600
0,30 30,180 180,300 300,480 480,1020
a little bit more burden

704
00:23:38,690 --> 00:23:41,120
0,420 420,1800 1800,1980 1980,2280 2280,2430
{} on the {frontend -}

705
00:23:41,120 --> 00:23:42,170
0,150 150,210 210,300 300,960 960,1050
or in the application| or
|或者在这种情况下，在客户端中，

706
00:23:42,170 --> 00:23:43,460
0,90 90,540 540,630 630,780 780,1290
the client, in this case,|
|

707
00:23:43,730 --> 00:23:45,320
0,660 900,1260 1260,1380 1380,1530 1530,1590
{} but it has the
但它有一个优势，

708
00:23:45,320 --> 00:23:46,400
0,480 480,570 570,690 690,900 900,1080
advantage,| you know that you
|你可以做一些预处理，

709
00:23:46,400 --> 00:23:47,300
0,240 240,420 420,480 480,720 720,900
can sort of {do,some} pre

710
00:23:47,300 --> 00:23:49,310
0,690 690,1200 1200,1410 1410,1710 1710,2010
processing,| before actually sticking something
|在把东西放入缓存之前。

711
00:23:49,310 --> 00:23:50,100
0,90 90,150 150,690
in the cache.|
|

712
00:23:50,690 --> 00:23:51,740
0,150 150,270 270,420 420,540 540,1050
And this sort of contrast,
在这个对比中，缓存是透明的，

713
00:23:51,740 --> 00:23:52,430
0,150 150,210 210,480 480,600 600,690
where the cache would be

714
00:23:52,430 --> 00:23:53,780
0,570 570,690 690,750 750,1050 1050,1350
transparent,| where the cache would
|缓存位于前端和存储服务器之间，

715
00:23:53,780 --> 00:23:55,160
0,90 90,390 390,660 660,720 720,1380
be sitting between the frontend

716
00:23:55,430 --> 00:23:56,930
0,210 210,270 270,630 630,1230 1260,1500
and the storage server,| and
|如果你错过了缓存，

717
00:23:56,930 --> 00:23:57,770
0,60 60,150 150,420 420,480 480,840
if you're missing the cache,|
|

718
00:23:57,770 --> 00:23:58,910
0,120 120,180 180,420 420,540 540,1140
then the cache will {choose,the,data},|
然后缓存将选择数据，|

719
00:23:58,910 --> 00:23:59,400
0,180

720
00:24:00,130 --> 00:24:00,940
0,240 240,510 510,570 570,750 750,810
{} but of course the
当然，数据库中的缓存

721
00:24:00,940 --> 00:24:02,110
0,330 330,450 450,630 630,990 990,1170
cache in the database| don't
|不知道应用程序到底在缓存中存储什么，

722
00:24:02,110 --> 00:24:03,160
0,180 180,330 330,540 540,600 600,1050
really know what the application

723
00:24:03,160 --> 00:24:04,210
0,390 390,600 600,930 930,990 990,1050
exactly what's stored in the

724
00:24:04,210 --> 00:24:05,470
0,450 780,930 930,1050 1050,1170 1170,1260
cache,| and so in the
|所以，在旁路设计中，

725
00:24:05,470 --> 00:24:08,080
0,150 150,660 660,1200 1440,2010 2100,2610
{look-aside -} design,| {} this
|是应用程序在控制缓存。

726
00:24:08,080 --> 00:24:10,030
0,60 60,1290 1290,1710 1710,1800 1800,1950
is the application is sort

727
00:24:10,030 --> 00:24:11,290
0,60 60,120 120,660 660,750 750,1260
of {} control the cache.|
|

728
00:24:14,540 --> 00:24:15,410
0,300 300,480 480,660 660,750 750,870
So a little bit more
所以更详细一点，

729
00:24:15,410 --> 00:24:16,370
0,390 390,450 450,570 570,870 870,960
detail,| we can look at
|我们可以看看这个图片，

730
00:24:16,370 --> 00:24:17,720
0,360 360,1050
this {}

731
00:24:17,990 --> 00:24:19,730
0,540 540,810 810,1140 1140,1320 1320,1740
picture,| that looks like how
|看看读或写是如何实现的。

732
00:24:19,730 --> 00:24:20,900
0,420 420,870
actually {}

733
00:24:21,170 --> 00:24:22,250
0,240 240,300 300,540 540,660 660,1080
read or write {} {implemented

734
00:24:22,250 --> 00:24:22,880
0,300
-}.|
|

735
00:24:23,090 --> 00:24:24,520
0,300 300,630 630,1050
So here's read,|
所以这是读取，|

736
00:24:24,970 --> 00:24:28,720
0,840 1170,1830 2430,3480
{} oops, sorry,|
糟糕，抱歉，|

737
00:24:39,590 --> 00:24:40,790
0,180 180,360 360,510 510,840 840,1200
so this is a figure
这是论文中的图 2 ，

738
00:24:40,790 --> 00:24:42,580
0,660 690,1320
2 {}

739
00:24:42,740 --> 00:24:45,300
0,390 390,600 600,1170
from the paper,|
|

740
00:24:47,230 --> 00:24:48,550
0,450 450,630 630,1050 1050,1140 1140,1320
and so here's our web
这是我们的网络服务器或客户端，

741
00:24:48,550 --> 00:24:50,220
0,420 420,570 570,1140
servers or clients,|
|

742
00:24:51,950 --> 00:24:54,260
0,120 120,630 630,1170 1200,1980 1980,2310
{you,know} {the,clients} to retrieve {}
客户端从 memcache 获取 k ，

743
00:24:54,260 --> 00:24:56,150
0,330 330,540 540,750 750,1560 1680,1890
k for {memcache -},| as
|我们稍后会看到，

744
00:24:56,150 --> 00:24:56,900
0,120 120,300 300,360 360,420 420,750
we'll see in a second,|
|

745
00:24:56,900 --> 00:24:58,400
0,120 120,210 210,570 570,1020 1020,1500
they are typically actually will
它们通常会请求很多键，

746
00:24:58,520 --> 00:25:00,050
0,960 960,1080 1080,1140 1140,1320 1320,1530
ask for a whole bunch

747
00:25:00,050 --> 00:25:01,460
0,60 60,450 450,780 780,960 960,1410
of keys,| there's not uncommon,|
|这并不少见，|

748
00:25:01,460 --> 00:25:02,600
0,270 270,390 390,540 540,960 960,1140
that you know the web
网络服务器要求 20 到 100 个键，

749
00:25:02,600 --> 00:25:03,740
0,180 180,330 330,630 630,780 780,1140
server will ask for {20,to

750
00:25:03,740 --> 00:25:05,810
0,270 270,960 1170,1530 1530,1980 1980,2070
-} 100 of keys,| you
|开始计算一些网页，

751
00:25:05,810 --> 00:25:06,860
0,90 90,630 630,750 750,990 990,1050
know presumably and starting to

752
00:25:06,860 --> 00:25:08,000
0,330 330,450 450,660 660,1020 1020,1140
compute some web page,| the
|网页包含来自许多不同地方的聚合数据，

753
00:25:08,000 --> 00:25:10,250
0,180 180,420 420,1050 1230,1950 1950,2250
web page contains aggregates data

754
00:25:10,250 --> 00:25:11,990
0,300 300,660 660,720 720,990 990,1740
from lots of different places,|
|

755
00:25:12,020 --> 00:25:13,040
0,270 270,390 390,690 690,930 930,1020
and for every piece of
对于每一条数据，

756
00:25:13,040 --> 00:25:13,850
0,300 300,450 450,600 600,690 690,810
data,| that needs to be
|需要放到那个网页上，

757
00:25:13,850 --> 00:25:15,710
0,180 180,510 510,960 1020,1350 1350,1860
put into that web page,|
|

758
00:25:15,860 --> 00:25:18,950
0,420 420,810 810,1470 1500,2160 2160,3090
{} the client issues,| the
客户发出，|我们发出的 get 请求可能有很多很多键，

759
00:25:18,980 --> 00:25:20,630
0,390 390,750 750,930 930,1290 1290,1650
get request we've made perhaps

760
00:25:20,630 --> 00:25:21,980
0,120 120,390 390,570 570,780 780,1350
with many many, many keys,|
|

761
00:25:22,400 --> 00:25:23,080
0,600

762
00:25:23,660 --> 00:25:25,520
0,450 450,690 690,960 960,1260 1260,1860
that goes to {memcache -},|
它们会到 memcache ，|

763
00:25:25,820 --> 00:25:27,950
0,270 270,420 420,780 780,1260 1290,2130
it gets results back,| and
它获取结果，|当发送那个 get 到 memcache ，

764
00:25:28,070 --> 00:25:29,480
0,600 600,870 870,1050 1050,1290 1290,1410
when sending that get to

765
00:25:29,480 --> 00:25:30,890
0,270 270,570 570,750 750,990 990,1410
{memcache -},| {you,know} might contact
|可能会联系许多 memcached 服务器，

766
00:25:30,890 --> 00:25:33,350
0,510 750,1320 1320,1620 1620,1830 1830,2460
many {memcached - -} servers,|
|

767
00:25:33,930 --> 00:25:35,040
0,270 270,600 600,720 720,1020 1020,1110
the results come back to
结果返回到网络服务器，

768
00:25:35,040 --> 00:25:37,440
0,90 90,270 270,870 1110,1590 1590,2400
the web server,| {} if
|如果有什么东西没有命中，

769
00:25:37,440 --> 00:25:39,570
0,840 840,960 960,1320 1320,1890 1890,2130
{} if anything's missing,| {you,know}
|可以处理那些，

770
00:25:39,570 --> 00:25:40,440
0,120 120,450 450,540 540,780 780,870
can process the ones,| that
|返回[]结果，

771
00:25:40,440 --> 00:25:42,420
0,480 480,840 840,870 870,1620 1620,1980
actually returns a [] result,|
|

772
00:25:42,420 --> 00:25:43,770
0,390 390,480 480,630 630,810 810,1350
{you,know} {we,can} get nil back,|
我们会得到 nil ，|

773
00:25:43,830 --> 00:25:46,080
0,900 1260,2010
then the
然后客户端向数据库 SELECT ，

774
00:25:46,550 --> 00:25:47,420
0,570
{}

775
00:25:47,670 --> 00:25:49,440
0,660 660,780 780,900 900,1470 1470,1770
client you know goes does

776
00:25:49,440 --> 00:25:51,060
0,360 360,510 510,1080 1080,1380 1380,1620
select the database,| runs a
|运行 SQL 查询，

777
00:25:51,060 --> 00:25:52,950
0,480 480,1020 1170,1440 1440,1770 1770,1890
SQL query,| that returns some
|它返回一些数据和结果，

778
00:25:52,950 --> 00:25:55,230
0,540 780,1200 1200,1950 1950,2130 2130,2280
data {} and {} the

779
00:25:55,230 --> 00:25:58,200
0,540 540,630 630,1080 1080,1500 2520,2970
results,| you know that clients
|客户端可能会进行一些计算，

780
00:25:58,200 --> 00:25:59,670
0,180 180,270 270,420 420,1170 1350,1470
might do some computation,| and
|然后安装进程，

781
00:25:59,670 --> 00:26:01,830
0,120 120,390 390,1350 1350,1470 1470,2160
then actually {install,you,know} the process|
|

782
00:26:01,830 --> 00:26:03,720
0,210 210,990 1140,1380 1380,1560 1560,1890
and values that came back
从 SELECT 获得的值到 memcache ，

783
00:26:03,720 --> 00:26:05,220
0,150 150,240 240,690 690,1290 1290,1500
from the SELECT into {}

784
00:26:05,220 --> 00:26:06,000
0,180 180,720
{memcache -},|
|

785
00:26:06,410 --> 00:26:07,700
0,270 270,420 420,600 600,840 840,1290
that's {sort,of} the read side.|
这就是读取的方面。|

786
00:26:07,850 --> 00:26:09,020
0,450 450,540 540,780 780,1110 1110,1170
Again and again here you
再一次，你可以在这里看到，

787
00:26:09,020 --> 00:26:11,510
0,300 300,540 540,930 960,1500 1620,2490
can see the,| look look-aside
|这个设计的旁路属性或方面，

788
00:26:11,690 --> 00:26:12,980
0,540 540,630 630,1020 1020,1080 1080,1290
property or aspect of this

789
00:26:12,980 --> 00:26:14,600
0,660 810,1110 1110,1320 1320,1500 1500,1620
design,| where {memcache -} is
|memcache 并不是直接位于网络服务器和数据库之间，

790
00:26:14,600 --> 00:26:16,280
0,180 180,360 360,570 570,960 960,1680
not really sitting straight between

791
00:26:16,280 --> 00:26:17,600
0,60 60,240 240,630 630,780 780,1320
the web server and database,|
|

792
00:26:17,600 --> 00:26:18,770
0,270 270,480 480,570 570,690 690,1170
but sits on this side,|
而是在旁边，|

793
00:26:19,160 --> 00:26:20,360
0,210 210,570 570,660 660,720 720,1200
is managed by the client.|
由客户端管理。|

794
00:26:22,390 --> 00:26:24,280
0,180 180,420 420,570 570,1080 1110,1890
So here's the write {}
所以这是写入端，

795
00:26:24,370 --> 00:26:25,600
0,720
side,|
|

796
00:26:28,130 --> 00:26:29,600
0,300 300,510 510,570 570,1200 1200,1470
{} so, for example, {}
例如，如果网络服务器或应用程序需要添加帖子，

797
00:26:29,600 --> 00:26:31,280
0,390 390,960 990,1230 1230,1590 1590,1680
if the web server or

798
00:26:31,280 --> 00:26:32,990
0,90 90,660 660,930 930,1140 1140,1710
the application needs to whatever

799
00:26:32,990 --> 00:26:35,210
0,660 660,750 750,1380 1620,2130 2130,2220
add a post,| or you
|或者在帖子中放一张图片，

800
00:26:35,210 --> 00:26:37,580
0,420 450,840 840,870 870,2160 2160,2370
know put a picture in

801
00:26:37,580 --> 00:26:39,560
0,90 90,480 480,630 630,1140 1380,1980
the post or whatever, {}|
|

802
00:26:39,560 --> 00:26:40,440
0,600
the
服务器进行更新，

803
00:26:40,810 --> 00:26:42,970
0,840 840,840 1230,1590 1590,2040 2040,2160
server {} does updates,| {you,know}
|将更新发送到数据库，

804
00:26:42,970 --> 00:26:45,040
0,330 330,750 750,870 870,1410 1500,2070
sends basically the update {}

805
00:26:45,040 --> 00:26:47,470
0,510 510,660 660,1440 1740,2010 2010,2430
to the database,| {} this
|就像正常的事务一样执行，

806
00:26:47,470 --> 00:26:48,400
0,90 90,330 330,720 720,900 900,930
is just performed like a

807
00:26:48,400 --> 00:26:51,580
0,990 990,1740 2010,2790 2790,3030 3030,3180
normal transaction,| {} and then
|当然，在数据库旁边，

808
00:26:51,580 --> 00:26:52,480
0,90 90,360 360,450 450,810 810,900
of course the database on

809
00:26:52,480 --> 00:26:53,500
0,60 60,570 630,720 720,870 870,1020
the side,| you know as
|像我们之前看到的，

810
00:26:53,500 --> 00:26:55,060
0,90 90,300 300,900 1110,1440 1440,1560
we saw before,| will do
|将会导致失效，

811
00:26:55,060 --> 00:26:57,700
0,720 720,960 990,1470 1590,2370 2490,2640
{invalidation -},| {} using you
|使用 squeal 守护程序，

812
00:26:57,700 --> 00:27:00,640
0,120 120,360 360,870 1200,2040 2220,2940
know the {} squeal demon,|
|

813
00:27:02,110 --> 00:27:05,080
0,660 1320,2070 2070,2310 2310,2610 2610,2970
and with that squeal daemon,
有了那个 squeal 守护程序，你可以异步操作，

814
00:27:05,080 --> 00:27:07,200
0,180 180,660 660,750 750,1440
{you,know} operate {asynchronously -},|
|

815
00:27:13,240 --> 00:27:14,280
0,330 330,720
oops, sorry,|
糟糕，抱歉，|

816
00:27:18,920 --> 00:27:20,690
0,270 270,450 450,930 960,1560 1560,1770
and so the client, the
客户端，写入者等待失效发生，

817
00:27:20,720 --> 00:27:22,310
0,480 480,750 750,1140 1140,1440 1440,1590
writers really wait until that

818
00:27:22,310 --> 00:27:23,960
0,630 630,720 720,1140 1140,1380 1380,1650
invalidation is happen,| {} once
|一旦事务中的更新，

819
00:27:23,960 --> 00:27:25,190
0,90 90,390 390,480 480,570 570,1230
the update in the transaction,|
|

820
00:27:25,490 --> 00:27:26,570
0,270 270,450 450,750 750,840 840,1080
once the update is done
一旦数据库中的更新完成，

821
00:27:26,570 --> 00:27:27,800
0,60 60,150 150,660 660,1140 1140,1230
in the database,| transaction is
|事务完成，并返回给客户端，

822
00:27:27,800 --> 00:27:29,870
0,360 360,960 1320,1470 1470,1950 1950,2070
completely completed and returned to

823
00:27:29,870 --> 00:27:31,790
0,60 60,630 840,990 990,1230 1230,1920
the client,| and then {in,parallel},
|然后同时 squeal 会看到失效，

824
00:27:31,790 --> 00:27:33,920
0,360 390,960 960,1350 1350,1680 1680,2130
the squeal actually, squeal {will,see}

825
00:27:33,920 --> 00:27:38,060
0,570 600,1320 2100,2760 3060,3810 3810,4140
the invalidation,| {} and and
|因为 squeal 以异步方式执行无效操作，

826
00:27:38,060 --> 00:27:39,890
0,630 630,750 750,900 900,1320 1350,1830
because you know the {squeal,does}

827
00:27:39,890 --> 00:27:42,140
0,210 210,810 810,1200 1200,1410 1410,2250
the invalidation {} {asynchronously -},|
|

828
00:27:42,380 --> 00:27:44,750
0,810 840,1380 1380,1740 1740,2010 2010,2370
the web server just do
网络服务器执行[]，

829
00:27:44,750 --> 00:27:47,210
0,420 450,1170 1230,1740 1740,2250 2250,2460
{} [],| does delete of
|立即删除缓存中的键，

830
00:27:47,210 --> 00:27:49,190
0,90 90,660 660,1260 1320,1770 1770,1980
the key in the cache

831
00:27:49,190 --> 00:27:51,560
0,600 1080,1290 1290,1440 1440,1920 2010,2370
immediately,| and so when the
|这个删除的原因是，

832
00:27:51,560 --> 00:27:53,210
0,360 360,510 510,750 750,1290 1320,1650
reason for that delete is|
|

833
00:27:53,300 --> 00:27:55,070
0,570 570,1110 1110,1470 1470,1680 1680,1770
only because we want to
因为我们想要读取自己的写入。

834
00:27:55,070 --> 00:27:56,180
0,210 210,390 390,570 570,1050
read our own writes.|
|

835
00:28:08,060 --> 00:28:09,200
0,300 300,450 450,630 630,780 780,1140
{} So when the {web,server}
所以，当网络服务器查找键 k 时，

836
00:28:09,200 --> 00:28:10,400
0,60 60,570 570,900 900,1020 1020,1200
for example look for that

837
00:28:10,400 --> 00:28:12,620
0,180 180,750 990,1440 1470,1860 1860,2220
key k,| {} right after
|就在它更新之后，

838
00:28:12,620 --> 00:28:14,270
0,60 60,240 240,360 360,960 1110,1650
it did the update,| then
|然后它将在 memcached 中丢失，

839
00:28:14,270 --> 00:28:15,530
0,150 150,300 300,840 870,1020 1020,1260
it will miss in {memcached

840
00:28:15,530 --> 00:28:16,790
0,300 300,750 840,1020 1020,1080 1080,1260
- -}| and it will
|它将获取新的值，然后安装它，

841
00:28:16,790 --> 00:28:18,590
0,240 240,360 360,600 600,1290 1320,1800
go and actually retrieve new

842
00:28:18,590 --> 00:28:21,050
0,480 480,570 570,720 720,1170 1890,2460
value and then {install,it} {},|
|

843
00:28:21,050 --> 00:28:22,520
0,420 420,780 780,1020 1020,1050 1050,1470
and but just a case,|
但是只是这种情况，|

844
00:28:22,520 --> 00:28:24,770
0,510 630,960 960,1380 1380,1980 1980,2250
where {} {web,server} immediately reads
网络服务器立即读取它自己的，

845
00:28:24,770 --> 00:28:26,420
0,150 150,420 420,990 1080,1410 1410,1650
its own, {} reads, {}|
|

846
00:28:26,420 --> 00:28:27,830
0,270 450,720 720,780 780,1170 1170,1410
that reads the key k
读取刚刚更新的 key k 。

847
00:28:27,830 --> 00:28:29,780
0,300 300,660 660,1050 1050,1530 1560,1950
that just actually {} updated

848
00:28:29,780 --> 00:28:30,740
0,60 60,240 240,450 450,780
a little while ago.|
|

849
00:28:31,030 --> 00:28:31,920
0,570

850
00:28:33,080 --> 00:28:35,000
0,660 900,1290 1290,1470 1470,1830 1830,1920
Okay?| Where in principal is
好的?|原则上不需要执行这个删除，

851
00:28:35,000 --> 00:28:36,800
0,180 180,870 900,1050 1050,1350 1350,1800
not necessary to do this

852
00:28:36,800 --> 00:28:39,770
0,510 510,1140 1440,2010 2280,2880 2880,2970
delete,| {} the invalidation at
|失效在某个时刻会发生，

853
00:28:39,770 --> 00:28:41,000
0,120 120,390 390,540 540,1080 1080,1230
some point will happen,| and
|将 key k 从缓存中删除，

854
00:28:41,000 --> 00:28:42,800
0,150 150,390 390,780 780,1080 1080,1800
will kick out {you,know,that} {key,k}

855
00:28:42,800 --> 00:28:44,600
0,180 180,300 300,930 1230,1590 1590,1800
out of cache,| and that's
|对于其他客户端来说，这是可以的，

856
00:28:44,600 --> 00:28:46,610
0,750 750,900 900,1230 1230,1410 1410,2010
fine for basically other clients,|
|

857
00:28:46,610 --> 00:28:47,870
0,240 240,480 480,600 600,750 750,1260
but just with this client,|
但是对于这个客户端，|

858
00:28:47,870 --> 00:28:48,710
0,300 300,420 420,480 480,630 630,840
we want to make sure
我们希望确保它能读取自己的写入。

859
00:28:48,710 --> 00:28:50,330
0,150 150,570 570,840 840,960 960,1620
that actually reads its own

860
00:28:50,570 --> 00:28:51,600
0,210 210,390 390,870
its own writes.|
|

861
00:28:53,250 --> 00:28:55,680
0,120 120,240 240,300 300,930 1770,2430
I have a question,| so
我有个问题，|为什么不在删除后进行设置呢？

862
00:28:56,010 --> 00:28:58,470
0,840 840,1170 1170,1470 1470,1980 1980,2460
why doesn't it set after

863
00:28:58,470 --> 00:28:59,620
0,240 240,930
the delete?|
|

864
00:29:00,080 --> 00:29:01,460
0,780 780,990 990,1050 1050,1260 1260,1380
Yeah, that's a very good
是的，这是个好问题，

865
00:29:01,460 --> 00:29:02,600
0,390 390,510 510,720 720,1020 1020,1140
question,| like why doesn't do
|为什么不立即更新，

866
00:29:02,600 --> 00:29:04,140
0,150 150,450 450,870 900,1230
{} update immediately, right,|
|

867
00:29:04,590 --> 00:29:07,920
0,750 930,1290 1290,1470 1470,1650 1650,3330
and {} I think {that,so,that's
我认为这就是所谓的更新方案，

868
00:29:07,920 --> 00:29:10,350
0,60 60,570 570,1050 1050,1590 1950,2430
-} called update scheme, {}|
|

869
00:29:10,350 --> 00:29:11,640
0,180 180,390 390,480 480,900 900,1290
and that's in principle possible
原则上这在这里也是可能的，

870
00:29:11,640 --> 00:29:13,170
0,240 240,720 930,1320 1320,1470 1470,1530
here too,| {} but I
|但我认为这对他们来说有点困难，

871
00:29:13,170 --> 00:29:13,710
0,150 150,240 240,270 270,420 420,540
think it's a little bit

872
00:29:13,710 --> 00:29:14,640
0,330 330,450 450,630 630,690 690,930
tricky for them to make

873
00:29:14,640 --> 00:29:15,570
0,360 360,630 630,720 720,870 870,930
work,| because I think it
|因为我认为这需要一些合作，

874
00:29:15,570 --> 00:29:16,560
0,150 150,270 270,360 360,870 870,990
was going to require some

875
00:29:16,560 --> 00:29:19,080
0,780 780,1050 1050,1110 1110,1950 2040,2520
cooperation| between the database, {}
|在数据库、缓存和客户端之间。

876
00:29:19,080 --> 00:29:20,250
0,90 90,540 540,690 690,750 750,1170
the cache and the client.|
|

877
00:29:20,670 --> 00:29:22,260
0,450 450,480 480,660 660,990 1020,1590
And I think the {issue,is}
我认为问题是这样的，

878
00:29:22,260 --> 00:29:24,870
0,750 1050,1770 1860,2280 2280,2460 2460,2610
follows,| {} let's say we
|假设我们有一个客户端 C1 ，

879
00:29:24,870 --> 00:29:26,840
0,150 150,210 210,600 600,1380
have a client C1,|
|

880
00:29:27,160 --> 00:29:28,630
0,150 150,270 270,330 330,660 660,1470
we have a client C2,|
我们有一个客户端 C2 ，|

881
00:29:29,560 --> 00:29:31,840
0,630 630,780 780,1080 1080,1350 1350,2280
{} and we'll see similar
我们会看到类似的类型出现，

882
00:29:31,840 --> 00:29:33,220
0,270 270,570 570,870 870,1110 1110,1380
type [] showing up,| let's
|假设客户端 x 1 ，

883
00:29:33,220 --> 00:29:35,980
0,450 600,1080 1110,1290 1290,1860 2400,2760
say client x 1,| sets
|将 x 设置为 1 并将其发送到数据库，

884
00:29:36,040 --> 00:29:37,360
0,330 330,780 780,870 870,1140 1140,1320
x {to,1} and sends that

885
00:29:37,360 --> 00:29:38,540
0,90 90,180 180,1020
to the database,|
|

886
00:29:40,050 --> 00:29:41,160
0,810

887
00:29:41,860 --> 00:29:44,140
0,210 210,840 900,1650 1680,2160 2160,2280
and then, {} {so,like} you
然后，比如，

888
00:29:44,140 --> 00:29:45,460
0,330 330,510 900,1110 1110,1260 1260,1320
know,| like so this is
|这是一个假设的更新方案，

889
00:29:45,460 --> 00:29:47,920
0,60 60,870 870,1200 1200,1710
a hypothetical update scheme,|
|

890
00:29:50,320 --> 00:29:52,240
0,660 660,1170 1170,1290 1290,1710 1710,1920
{} it's, the main point
这张幻灯片的重点是，

891
00:29:52,240 --> 00:29:53,620
0,120 120,360 360,1020 1020,1140 1140,1380
of this slide will be,|
|

892
00:29:53,620 --> 00:29:54,580
0,210 210,540 540,780 780,870 870,960
or this board will be
或者这个白板讨论，

893
00:29:54,580 --> 00:29:56,080
0,180 180,300 300,780 780,1020 1020,1500
sort of talk about| like
|执行更新不是无关紧要的，

894
00:29:56,080 --> 00:29:57,220
0,180 180,480 480,780 780,870 870,1140
doing actually update is not

895
00:29:57,220 --> 00:29:59,260
0,360 360,870 1320,1650 1650,1830 1830,2040
completely trivial,| {} let's say
|假设同时客户端 2 ，

896
00:29:59,260 --> 00:30:00,310
0,300 300,570 570,660 660,750 750,1050
client 2 at the same

897
00:30:00,310 --> 00:30:02,050
0,330 330,450 450,780 780,1170 1170,1740
time,| we're running after it,|
|我们运行它，|

898
00:30:02,050 --> 00:30:04,030
0,210 210,570 570,1110 1440,1740 1740,1980
says {x,to} 2, sends that
将 x 设为 2 ，将其发送到数据库，

899
00:30:04,030 --> 00:30:05,280
0,60 60,180 180,1140
to the database,|
|

900
00:30:06,570 --> 00:30:07,920
0,690 690,930 930,1110 1110,1230 1230,1350
{} and let's say the
假设客户端 1 有一点延迟，

901
00:30:07,920 --> 00:30:08,880
0,450 450,660 660,780 780,930 930,960
client 1 has got a

902
00:30:08,880 --> 00:30:10,500
0,180 180,300 300,810 1260,1470 1470,1620
little bit delayed,| and so
|所以我们实施你的方案，

903
00:30:10,500 --> 00:30:12,360
0,240 240,840 840,1080 1080,1560 1560,1860
we're implement your scheme, correct,|
|

904
00:30:12,360 --> 00:30:14,370
0,570 570,750 750,1200 1200,1470 1470,2010
then we immediately do set
然后我们立即执行设置 k 为 2 ，

905
00:30:14,880 --> 00:30:17,040
0,270 270,660 660,960 960,1500
of k to 2,|
|

906
00:30:17,960 --> 00:30:18,800
0,150 150,300 300,450 450,630 630,840
and let me say k
假设 k 在开始时是 0 ，

907
00:30:18,800 --> 00:30:19,820
0,120 120,570 570,660 660,780 780,1020
with 0 at the end

908
00:30:19,820 --> 00:30:20,900
0,120 120,180 180,750
in the beginning,|
|

909
00:30:21,010 --> 00:30:22,090
0,240 240,390 390,540 540,720 720,1080
{} so this will update
所以，这将更新 memcached ，

910
00:30:22,090 --> 00:30:23,860
0,210 210,480 480,870 870,1440 1440,1770
{memcached - -}, correct,| cache
|缓存现在将有一个值 k 为 2 ，

911
00:30:23,860 --> 00:30:24,850
0,120 120,330 330,450 450,660 660,990
is now going to have

912
00:30:24,850 --> 00:30:26,140
0,30 30,540 540,720 720,990 990,1290
a value of {you,know} whatever

913
00:30:26,500 --> 00:30:29,980
0,900 1350,1800 1830,2010 2010,2550 2670,3480
k {} to 2,| then
|然后客户端 1 执行它的设置，

914
00:30:30,010 --> 00:30:32,050
0,90 90,180 180,510 510,1050 1470,2040
you know client 1 actually

915
00:30:32,050 --> 00:30:32,890
0,90 90,240 240,480 480,780 780,840
you know comes around to

916
00:30:32,890 --> 00:30:34,750
0,240 240,570 570,750 750,1200 1470,1860
do actually it's set,| so
|所以，它会放在这里 set 或 put ，

917
00:30:34,750 --> 00:30:36,070
0,180 180,300 300,510 510,780 780,1320
it will do set here

918
00:30:36,070 --> 00:30:38,840
0,240 240,630 1830,2250
or put,| set,
|set put ，糟糕，设置 k 为 1 ，

919
00:30:39,010 --> 00:30:40,120
0,390 390,870
put, oops

920
00:30:40,630 --> 00:30:43,520
0,390 390,1080 1530,1680 1680,2130
set k to 1,|
|

921
00:30:44,240 --> 00:30:46,100
0,240 240,390 390,570 570,1410 1410,1860
and so {this,will} overwrite {the,2},|
这将覆盖 2 ，|

922
00:30:46,190 --> 00:30:47,690
0,480 480,960 960,1140 1140,1410 1410,1500
and now we have a
现在我们在缓存中有一个旧的值，

923
00:30:47,690 --> 00:30:49,400
0,660 660,1320
stale value

924
00:30:50,280 --> 00:30:54,750
0,600 1260,1500 1500,2250 3480,4050 4050,4470
in the cache,| and worse
|更糟糕的是，这个值是一直过时的，

925
00:30:54,750 --> 00:30:57,660
0,90 90,210 210,450 450,1020 1050,2910
you know this value is

926
00:30:57,660 --> 00:31:00,570
0,630 720,1500 1770,2310 2310,2370 2370,2910
there {} sort of persistently

927
00:31:00,570 --> 00:31:02,130
0,390 630,780 780,900 900,1440 1440,1560
stale,| you know any you
|任何之后的 get 将看到旧的值。

928
00:31:02,130 --> 00:31:03,600
0,120 120,420 420,750 750,1320 1320,1470
know get later on will

929
00:31:03,600 --> 00:31:05,220
0,210 210,540 540,870 870,1140 1140,1620
see actually the stale value.|
|

930
00:31:05,900 --> 00:31:06,830
0,270 270,390 390,540 540,600 600,930
And so this is not
所以，这不是所希望的，

931
00:31:06,830 --> 00:31:08,600
0,180 180,930 1350,1590 1590,1680 1680,1770
so desirable,| and so you
|所以你想避免这种情况

932
00:31:08,600 --> 00:31:09,620
0,150 150,210 210,450 450,840 900,1020
want to avoid that,| and
|当然，你可以让更新方案起作用，

933
00:31:09,620 --> 00:31:10,820
0,390 600,750 750,990 990,1080 1080,1200
then of course you can

934
00:31:10,820 --> 00:31:12,470
0,210 210,510 510,870 870,1200 1200,1650
make maybe update scheme work,|
|

935
00:31:12,680 --> 00:31:15,050
0,570 570,1440 1440,1530 1530,1740 1830,2370
by {for,example} you know ordering
比如，对时间戳排序，

936
00:31:15,050 --> 00:31:17,810
0,300 360,1020 1020,1530 1530,2160 2190,2760
{} time stamping| or assigning
|或者为更新分配序列号，

937
00:31:17,810 --> 00:31:19,430
0,60 60,450 450,660 660,960 960,1620
a sequence number {to,the} updates,|
|

938
00:31:19,760 --> 00:31:21,440
0,210 210,780 780,930 930,1020 1020,1680
and then by the database,|
然后通过数据库，|

939
00:31:21,440 --> 00:31:23,360
0,120 120,600 930,1440 1440,1770 1770,1920
and then {} the key
然后键值服务器或 memcached

940
00:31:23,360 --> 00:31:25,550
0,360 360,900 900,1140 1140,2010 2010,2190
value server or memcached| could
|可以不执行顺序之外的更新，

941
00:31:25,580 --> 00:31:28,580
0,930 930,1140 1140,1470 1470,2250 2370,3000
basically {} not perform updates

942
00:31:28,580 --> 00:31:29,750
0,300 300,540 540,690 690,750 750,1170
that are out of order,|
|

943
00:31:30,240 --> 00:31:31,320
0,330 330,330 330,630 630,750 750,1080
but a scheme like that
但这样的方案需要数据库的一些参与，

944
00:31:31,320 --> 00:31:32,220
0,150 150,270 270,330 330,750 750,900
was going to require some

945
00:31:32,220 --> 00:31:34,740
0,630 630,690 690,780 780,1530 1560,2520
participation of the database,| {I,mean}
|我的意思是对 MySQL 进行必要的修改，

946
00:31:34,740 --> 00:31:36,570
0,360 360,930 930,1020 1020,1200 1200,1830
required modifications to {MySQL -},|
|

947
00:31:36,690 --> 00:31:37,470
0,120 120,270 270,330 330,480 480,780
and one of their goals
他们的目标之一是从现成的组件构建所有东西，

948
00:31:37,470 --> 00:31:38,580
0,150 150,240 240,450 450,660 660,1110
was to actually build everything

949
00:31:38,580 --> 00:31:40,230
0,300 300,480 480,570 570,930 930,1650
from off the shelf components,|
|

950
00:31:41,180 --> 00:31:42,260
0,240 240,600 600,720 720,840 840,1080
and so you know they
所以他们更喜欢这个失效方案，

951
00:31:42,260 --> 00:31:43,940
0,330 330,450 450,720 720,1050 1050,1680
prefer to go this invalidation

952
00:31:43,940 --> 00:31:45,260
0,570 720,930 930,1110 1110,1200 1200,1320
scheme,| {} which I think
|我认为这实施起来更简单，

953
00:31:45,260 --> 00:31:46,400
0,90 90,480 510,660 660,1050 1050,1140
is just {} simpler to

954
00:31:46,400 --> 00:31:50,390
0,630 960,2070 2070,2730 2730,3420 3450,3990
implement,| because basically {you,know,your} database,
|因为你的数据库唯一要做的，

955
00:31:50,390 --> 00:31:50,960
0,60 60,210 210,330 330,420 420,570
the only thing it has

956
00:31:50,960 --> 00:31:52,610
0,90 90,660 750,1170 1170,1440 1440,1650
to do| {} is this
|是这个额外的进程在旁边，

957
00:31:52,610 --> 00:31:54,350
0,540 540,1140 1140,1410 1410,1650 1650,1740
additional process that sits on

958
00:31:54,350 --> 00:31:56,900
0,60 60,630 870,1560 1710,2460 2460,2550
the side,| and uses the
|并使用标准的删除操作，

959
00:31:56,900 --> 00:31:58,160
0,630 630,720 720,840 840,1200 1200,1260
standard you know delete the

960
00:31:58,160 --> 00:32:00,470
0,780 960,1260 1260,1560 1560,1950 1950,2310
operation,| {} that {memcached -
|memcached 已经支持的。

961
00:32:00,470 --> 00:32:01,700
0,180 180,510 510,1140
-} already supports.|
|

962
00:32:04,620 --> 00:32:05,850
0,240 240,510 930,1020 1020,1110 1110,1230
Thank you.| Does that make
谢谢。|这能理解吗？

963
00:32:05,850 --> 00:32:06,560
0,390
sense?|
|

964
00:32:08,620 --> 00:32:09,850
0,270 270,510 510,870 870,1110 1110,1230
{And,we'll} see similar issue like
我们稍后会看到类似的问题再次出现，

965
00:32:09,850 --> 00:32:10,900
0,150 150,330 330,630 630,810 810,1050
this one show up later

966
00:32:10,900 --> 00:32:12,460
0,390 420,690 690,1110 1110,1110 1110,1560
again, correct,| { -} because
|因为，你还记得从论文上看到，

967
00:32:12,460 --> 00:32:14,830
0,240 240,1140 1770,1890 1890,2280 2280,2370
there's, {} you remember from

968
00:32:14,830 --> 00:32:16,420
0,90 90,660 720,960 960,1110 1110,1590
the paper,| there's some discussion
|有一些关于 token 或租约的讨论，

969
00:32:16,420 --> 00:32:18,670
0,330 330,720 720,1440 1440,1620 1620,2250
about these tokens or leases,|
|

970
00:32:18,850 --> 00:32:19,930
0,240 240,330 330,630 630,810 810,1080
{} to deal with stale
为了处理陈旧的值，

971
00:32:19,930 --> 00:32:21,040
0,570 570,690 690,930 930,1050 1050,1110
values,| but that's going to
|但这将是，

972
00:32:21,040 --> 00:32:22,480
0,180 180,360 360,540 540,960 1020,1440
be,| as we'll see stale
|我们将看到，旧值在读方面，

973
00:32:22,480 --> 00:32:24,100
0,570 570,780 780,900 900,1110 1110,1620
values on the read side,|
|

974
00:32:24,250 --> 00:32:27,520
0,780 780,1080 1080,1620 2490,2790 2790,3270
{} or {} stale values
或者读取者和写入者之间交互的旧值，

975
00:32:27,520 --> 00:32:28,900
0,120 120,300 300,390 390,630 630,1380
that sort of have {}

976
00:32:28,900 --> 00:32:30,730
0,750 750,990 990,1230 1230,1320 1320,1830
interaction between readers or writers,|
|

977
00:32:30,910 --> 00:32:32,110
0,270 270,420 420,510 510,600 600,1200
{} but can be solved
但是完全可以在 memcached 的上下文中解决，

978
00:32:32,110 --> 00:32:33,790
0,720 840,1200 1200,1260 1260,1320 1320,1680
{} totally in the context

979
00:32:33,790 --> 00:32:34,930
0,90 90,270 270,540 540,810 810,1140
of {memcached - -}| without
|无需对数据库做任何修改。

980
00:32:34,930 --> 00:32:36,760
0,270 270,540 540,660 660,1110 1110,1830
actually making any database modifications.|
|

981
00:32:37,910 --> 00:32:38,660
0,240 240,390 390,570 570,660 660,750
{} So why do we
为什么我们要有一个单独的程序来发布失效，

982
00:32:38,660 --> 00:32:40,670
0,150 150,210 210,780 780,1410 1410,2010
have a separate process to

983
00:32:40,700 --> 00:32:43,250
0,750 840,1200 1200,1320 1320,2100 2280,2550
basically issue the invalidation,| so
|我想它被称为 squeal ，

984
00:32:43,250 --> 00:32:44,720
0,540 540,1050 1080,1200 1200,1380 1380,1470
this squeal, I think it

985
00:32:44,720 --> 00:32:46,580
0,150 150,480 1020,1230 1230,1500 1500,1860
was called,| so why so
|所以为什么我们有这个程序，

986
00:32:46,700 --> 00:32:47,570
0,420 420,510 510,600 600,750 750,870
why do we have this

987
00:32:47,570 --> 00:32:50,510
0,510 510,1350 1380,1800 1830,2340 2340,2940
process,| if the frontend itself
|如果前端本身发出删除 k ？

988
00:32:50,510 --> 00:32:52,070
0,330 330,690 690,750 750,1110 1110,1560
will issue a delete k

989
00:32:52,070 --> 00:32:52,880
0,570
anyway?|
|

990
00:32:53,390 --> 00:32:55,820
0,480 750,1890 1890,2040 2040,2130 2130,2430
{} We'll see you later
我们稍后会看到，

991
00:32:55,820 --> 00:32:56,780
0,240 240,510 510,690 690,810 810,960
on,| why this is going
|为什么这是非常有用的，

992
00:32:56,780 --> 00:32:59,540
0,60 60,180 180,450 450,900 1320,2760
to be very useful,| particularly
|尤其是我们要做的是，

993
00:32:59,540 --> 00:33:00,380
0,240 240,360 360,510 510,690 690,840
what we're gonna do is,|
|

994
00:33:00,380 --> 00:33:01,010
0,120 120,300 300,390 390,540 540,630
we'll see is that the
我们将看到，缓存被复制，

995
00:33:01,010 --> 00:33:01,610
0,240 240,300 300,420 420,480 480,600
cache is going to be

996
00:33:01,610 --> 00:33:03,230
0,510 960,1290 1290,1410 1410,1560 1560,1620
replicated,| and we need to
|我们需要发送失效给每个复制。

997
00:33:03,230 --> 00:33:04,160
0,180 180,210 210,360 360,840 840,930
set {} {invalidation -} to

998
00:33:04,160 --> 00:33:05,120
0,210 210,750
every replica.|
|

999
00:33:05,330 --> 00:33:06,350
0,270 270,360 360,630 660,870 870,1020
Okay, I see, thank you.|
好的，我明白了，谢谢。|

1000
00:33:07,590 --> 00:33:09,240
0,660 660,930 1080,1350 1350,1500 1500,1650
Okay, {squeal -} it's not
好的， squeal 不会发送删除到每个复制吧？

1001
00:33:09,240 --> 00:33:11,070
0,210 210,780 810,960 960,1680 1680,1830
gonna send a delete to

1002
00:33:11,070 --> 00:33:13,520
0,780 810,1110 1110,1500 1500,2190
every {memcache -} replica?|
|

1003
00:33:14,120 --> 00:33:15,800
0,450 450,720 720,1140 1140,1530 1530,1680
The squeal, yeah,| we'll see
squeal ，是的，|我们一会儿会看到，

1004
00:33:15,800 --> 00:33:16,610
0,60 60,90 90,330 330,540 540,810
in a second,| hold on
|稍等，我们马上就会看到。

1005
00:33:16,610 --> 00:33:17,510
0,180 180,540 540,690 690,840 840,900
and we'll see that in

1006
00:33:17,510 --> 00:33:18,200
0,30 30,330
a second.|
|

1007
00:33:19,250 --> 00:33:21,650
0,150 150,600 1050,2130 2130,2190 2190,2400
In fact, {} I'm gonna
事实上，我现在就要谈谈这件事。

1008
00:33:21,650 --> 00:33:22,340
0,150 150,360 360,510 510,570 570,690
go talk about it right

1009
00:33:22,340 --> 00:33:24,500
0,390 960,1740
now {}.|
|

1010
00:33:25,350 --> 00:33:27,300
0,540 630,900 900,1140 1140,1680 1680,1950
So so so far actually
到目前为止，大部分故事都是相当标准的，

1011
00:33:27,300 --> 00:33:29,070
0,450 450,540 540,690 690,1410 1500,1770
most of the story {}

1012
00:33:29,070 --> 00:33:31,110
0,240 240,480 480,1080 1260,1920 1920,2040
is pretty standard,| {} you
|这里的变化很小，

1013
00:33:31,110 --> 00:33:34,230
0,300 690,1440 1440,1740 1740,2220 2400,3120
know small changes here,| and
|我们到目前为止谈过的，

1014
00:33:34,230 --> 00:33:35,580
0,420 510,630 630,750 750,1140 1140,1350
what you know we've talked

1015
00:33:35,580 --> 00:33:37,710
0,150 150,270 270,540 960,1620 1620,2130
about so far,| nothing really
|没有什么特别的，

1016
00:33:37,710 --> 00:33:40,140
0,690 690,900 900,1470 1770,2310 2310,2430
{} too exceptional,| things get
|在这之后事情就变得更有趣了，

1017
00:33:40,140 --> 00:33:42,120
0,210 210,750 750,1290 1290,1590 1590,1980
more interesting right after this,|
|

1018
00:33:42,360 --> 00:33:44,430
0,210 210,690 720,1740 1740,1950 1950,2070
{} and {} and so
所以，我们更深入地了解

1019
00:33:44,430 --> 00:33:45,450
0,270 270,420 420,630 630,810 810,1020
we get more into| sort
|Facebook 特定的优化或性能技巧。

1020
00:33:45,450 --> 00:33:48,600
0,90 90,480 480,1110 1320,2400 2670,3150
of Facebook specific optimization {or,performance}

1021
00:33:48,630 --> 00:33:49,300
0,600
tricks.|
|

1022
00:33:49,850 --> 00:33:52,790
0,570 780,1440 1740,2040 2040,2460 2460,2940
And, { -} one first
我们要看到的第一件事是，

1023
00:33:52,820 --> 00:33:54,500
0,990 990,1110 1110,1260 1260,1380 1380,1680
thing that we're going to

1024
00:33:54,530 --> 00:33:56,330
0,540 540,780 780,1140 1140,1410 1410,1800
see,| let me get this
|让我把这个整理好，[]放回去，

1025
00:33:56,360 --> 00:33:57,340
0,180 180,720
in order,

1026
00:33:58,020 --> 00:33:59,760
0,420 420,480 480,570 570,1020 1350,1740
[] to go back, {}|
|

1027
00:33:59,880 --> 00:34:01,290
0,180 180,420 420,540 540,870 870,1410
the first thing is actually
第一件事是，

1028
00:34:01,290 --> 00:34:03,510
0,300 300,960 960,1230 1230,1860 1860,2220
{} {sort,of},| becomes usual is
|通常情况下，

1029
00:34:03,510 --> 00:34:05,130
0,240 240,750 750,900 900,1290 1290,1620
that,| actually {} Facebook basically
|Facebook 复制一个完整的数据中心，

1030
00:34:05,130 --> 00:34:07,530
0,930 990,1140 1140,1710 1710,1950 1950,2400
replicates a complete data center,|
|

1031
00:34:07,950 --> 00:34:08,820
0,390 390,510 510,570 570,780 780,870
{} at the time of
在编写这个论文的时候，

1032
00:34:08,820 --> 00:34:09,900
0,90 90,450 450,630 630,780 780,1080
the writing of this paper,|
|

1033
00:34:09,900 --> 00:34:10,950
0,90 90,180 180,480 480,750 750,1050
there were basically two data
有两个数据中心，

1034
00:34:10,950 --> 00:34:11,640
0,510
centers,|
|

1035
00:34:11,810 --> 00:34:12,800
0,330 330,630 630,690 690,780 780,990
{} one on the west
一个在西海岸，

1036
00:34:12,800 --> 00:34:15,170
0,570 780,1290 1380,2010 2010,2280 2280,2370
coast,| we switch back to
|我们换回蓝色，

1037
00:34:15,170 --> 00:34:16,260
0,540
blue,|
|

1038
00:34:16,760 --> 00:34:18,590
0,210 210,480 480,690 690,1200 1680,1830
so data center 1,| they
数据中心 1 ，|他们称为区域，

1039
00:34:18,590 --> 00:34:19,840
0,270 270,990
called regions,|
|

1040
00:34:22,630 --> 00:34:24,070
0,360 360,510 510,720 720,960 960,1440
{here's -} data center 2,|
这是数据中心 2 ，|

1041
00:34:25,980 --> 00:34:28,860
0,720 1080,1680 1680,1830 1830,2220 2220,2880
and {} they basically have
它们都有都有客户端层，

1042
00:34:28,890 --> 00:34:30,900
0,120 120,270 270,810 1410,1740 1740,2010
you know, they're all have

1043
00:34:30,900 --> 00:34:31,580
0,390
a

1044
00:34:32,000 --> 00:34:34,420
0,630 630,1260
client layer,|
|

1045
00:34:34,900 --> 00:34:36,430
0,450 510,540 570,840 840,960 960,1530
so a lot of frontends,|
所以有很多前端，|

1046
00:34:43,290 --> 00:34:44,070
0,180 180,420 420,570 570,690 690,780
and maybe this is the
也许这是西海岸的那个，

1047
00:34:44,070 --> 00:34:45,150
0,180 180,270 270,330 330,600 600,1080
one on the west coast,|
|

1048
00:34:48,580 --> 00:34:49,840
0,390 390,660 660,720 720,990 990,1260
and then you know {this,is,the}
然后这是 memcached 或 memcache 层，

1049
00:34:49,840 --> 00:34:50,950
0,420 420,750 750,870 870,900 900,1110
{memcached -} or a {memcache

1050
00:34:50,950 --> 00:34:52,020
0,210 210,690
-} layer,|
|

1051
00:34:52,520 --> 00:34:54,440
0,150 150,690 690,1200 1230,1470 1470,1920
they both have their own
它们都有自己的 memcache 层，

1052
00:34:54,440 --> 00:34:55,680
0,210 210,510 510,930
{memcache -} layer,|
|

1053
00:34:56,180 --> 00:34:57,950
0,240 240,660 780,1140 1140,1260 1260,1770
so here there are frontends
所以这里也是前端，很多前端，

1054
00:34:57,950 --> 00:34:58,920
0,570
again,

1055
00:34:59,050 --> 00:35:00,940
0,30 90,330 330,390 390,1170 1680,1890
a lot of frontends,| so
|这里是很多 memcached ，

1056
00:35:00,940 --> 00:35:01,840
0,270 270,480 480,600 600,840 840,900
here are a lot of

1057
00:35:01,840 --> 00:35:03,260
0,210 210,510 510,1170
{memcacheds - -},|
|

1058
00:35:05,360 --> 00:35:06,290
0,30 60,390 390,450 450,630 630,930
a lot of {memcacheds -},|
很多 memcached ，|

1059
00:35:06,290 --> 00:35:09,560
0,660 1170,1620 1620,2010 2010,2730 3090,3270
{a,lot,of} {memcached -} here,| and
这里有很多 memcached ，|然后这是存储层，

1060
00:35:09,560 --> 00:35:11,420
0,600 600,840 840,900 900,1380 1380,1860
then {you,know,there's} the storage layer,|
|

1061
00:35:11,570 --> 00:35:14,600
0,570 570,1020 1830,2160 2160,2460 2460,3030
which are sort of sharded
它是一种分片的数据库，

1062
00:35:14,690 --> 00:35:15,920
0,930
databases,|
|

1063
00:35:18,410 --> 00:35:19,730
0,270 270,420 450,720 720,1110 1110,1320
so a {lot,of} machines here
这里也有很多机器，

1064
00:35:19,730 --> 00:35:20,400
0,360
too,|
|

1065
00:35:22,140 --> 00:35:24,330
0,240 240,960 960,1500 1530,1800 1800,2190
and basically the data center
数据中心 2 在东海岸，

1066
00:35:24,360 --> 00:35:26,160
0,570 600,690 690,900 900,1380 1710,1800
2, the one on the

1067
00:35:26,160 --> 00:35:28,830
0,180 180,720 1080,1500 1500,1980 1980,2670
east coast,| {} is a
|是西海岸那个的直接复制品，

1068
00:35:28,830 --> 00:35:30,000
0,300 300,720 720,810 810,900 900,1170
direct replica of the one

1069
00:35:30,000 --> 00:35:31,000
0,120 120,180 180,390 390,840
on the west coast,|
|

1070
00:35:31,340 --> 00:35:33,680
0,780 810,1440 1440,1650 1650,1800 1830,2340
and, {} and the scheme
它们用来写入的方案，

1071
00:35:33,680 --> 00:35:35,660
0,180 180,780 780,1260 1260,1590 1590,1980
that they use for write,|
|

1072
00:35:36,080 --> 00:35:37,460
0,270 270,360 360,660 690,870 870,1380
{because,now} we have two replica
因为现在我们有两个数据副本，

1073
00:35:37,460 --> 00:35:38,690
0,270 270,390 390,480 480,750 750,1230
{} of the data, correct,|
|

1074
00:35:38,690 --> 00:35:40,310
0,270 270,600 600,840 840,1350 1350,1620
data of the database stored
数据库的数据存储在两个地方，

1075
00:35:40,310 --> 00:35:41,570
0,60 60,210 210,810 960,1140 1140,1260
in two places,| so we
|所以我们需要以某种方式保持这两个副本同步，

1076
00:35:41,570 --> 00:35:42,470
0,150 150,240 240,540 540,660 660,900
need to keep in some

1077
00:35:42,470 --> 00:35:43,490
0,390 390,480 480,570 570,810 810,1020
way you know these two

1078
00:35:43,490 --> 00:35:45,320
0,480 480,660 660,750 750,1140 1560,1830
copies up to date,| and
|基本的方案至少在右边是，

1079
00:35:45,320 --> 00:35:46,310
0,60 60,360 360,720 720,810 810,990
the basic plan at least

1080
00:35:46,310 --> 00:35:47,990
0,90 90,150 150,390 390,810 990,1680
on the right side is

1081
00:35:47,990 --> 00:35:49,550
0,570 720,1050 1050,1170 1170,1440 1440,1560
to| all the writes are
|所有写入都通过 primary ，

1082
00:35:49,550 --> 00:35:51,200
0,270 270,600 600,840 840,1290 1440,1650
going through the primary,| and
|其中一个区域是 primary ，另一个是 backup 区域，

1083
00:35:51,200 --> 00:35:52,070
0,180 180,270 270,330 330,690 690,870
one of the regions is

1084
00:35:52,070 --> 00:35:52,910
0,480 480,540 540,720 720,810 810,840
primary, the other is a

1085
00:35:52,910 --> 00:35:53,780
0,390 390,720
backup region,|
|

1086
00:35:54,250 --> 00:35:55,540
0,180 180,300 300,420 420,750 750,1290
so this is region 2,|
这是区域 2 ，|

1087
00:35:56,440 --> 00:35:57,670
0,420 450,840 840,990 990,1080 1080,1230
the fact, {I,think} the paper
事实上，我想论文说西海岸是 primary ，

1088
00:35:57,670 --> 00:35:58,630
0,270 270,330 330,540 540,840 840,960
says the west coast is

1089
00:35:58,630 --> 00:36:00,500
0,120 120,810
the primary,|
|

1090
00:36:02,060 --> 00:36:06,740
0,720 720,1440 1470,2820 2820,3390 4410,4680
and the {east,coast,is} {the,backup},| and
东海岸是 backup ，|所以，所有写入都要通过 primary 的存储层，

1091
00:36:06,740 --> 00:36:09,680
0,180 180,1020 1050,1650 1650,2130 2130,2940
so {all,write} {} actually {go,you,know}

1092
00:36:09,680 --> 00:36:10,640
0,690
through

1093
00:36:10,880 --> 00:36:12,920
0,330 330,900 900,1350 1350,1800 1800,2040
the storage layer on the

1094
00:36:12,920 --> 00:36:14,390
0,480 480,690 690,990 990,1260 1260,1470
primary,| so even writes {you,know}
|所以即使是东海岸的前端发布的写入，

1095
00:36:14,390 --> 00:36:15,860
0,450 450,600 600,720 720,1020 1020,1470
issued by the {frontends -}

1096
00:36:15,950 --> 00:36:17,780
0,540 540,990 1170,1380 1380,1740 1740,1830
on the east coast,| you
|会去这里的数据库，

1097
00:36:17,780 --> 00:36:20,090
0,360 390,780 780,1200 1620,1950 1950,2310
know go to the database

1098
00:36:20,090 --> 00:36:21,590
0,300 300,390 390,480 480,870 870,1500
here,| so the database there
|primary 上的数据库运行事务，

1099
00:36:21,620 --> 00:36:23,150
0,540 540,630 630,1020 1020,1170 1170,1530
on the primary just runs

1100
00:36:23,150 --> 00:36:25,640
0,120 120,900 1200,1890 1890,1980 1980,2490
the transaction,| and you know
|传播这些失效消息，

1101
00:36:25,640 --> 00:36:27,530
0,330 330,720 720,1620 1620,1770 1770,1890
and basically propagates you know

1102
00:36:27,530 --> 00:36:29,630
0,450 450,1200 1200,1500 1500,1890 1890,2100
these invalidation message,| well, first
|首先，在这边获取日志，

1103
00:36:29,630 --> 00:36:30,420
0,60 60,390
of all,

1104
00:36:30,610 --> 00:36:32,050
0,330 330,450 450,990 1020,1230 1230,1440
takes the log that actually

1105
00:36:32,050 --> 00:36:34,150
0,240 240,300 300,480 480,990 1440,2100
sits at this side| and
|然后复制或传输到另一边，

1106
00:36:34,210 --> 00:36:36,280
0,480 480,930 930,1170 1170,1680 1680,2070
basically copies or transmitted over

1107
00:36:36,280 --> 00:36:37,460
0,90 90,240 240,420 420,900
to the other side,|
|

1108
00:36:37,920 --> 00:36:38,790
0,180 180,300 300,480 480,720 720,870
and so this is the
这就是 squeal 进程，

1109
00:36:38,790 --> 00:36:40,380
0,420 420,870 870,1140 1140,1320 1320,1590
squeal process,| that basically does
|它执行，

1110
00:36:40,380 --> 00:36:43,140
0,360 750,1290 1320,1410 1410,1920 1950,2760
that in,| you know that
|这个进程将日志应用于

1111
00:36:43,170 --> 00:36:45,690
0,870 870,1170 1170,2040 2040,2160 2160,2520
process basically applies the log|
|

1112
00:36:45,690 --> 00:36:47,220
0,60 60,660 750,1350 1350,1440 1440,1530
to storage {in,the,database} on the
另一边数据库中的存储，

1113
00:36:47,220 --> 00:36:48,840
0,180 180,570 930,1230 1230,1530 1530,1620
other side,| so keeping the
|使两个数据库保持同步，

1114
00:36:48,840 --> 00:36:50,490
0,150 150,720 720,930 930,1140 1140,1650
two databases in {} sync,|
|

1115
00:36:50,730 --> 00:36:51,960
0,450 450,570 570,630 630,870 870,1230
and as a side effect,|
并且作为连带作用，|

1116
00:36:51,960 --> 00:36:53,730
0,240 240,450 450,810 810,1080 1080,1770
it might actually send invalidation
它可能发送失效消息或删除消息给 k ，

1117
00:36:53,730 --> 00:36:56,130
0,630 630,870 870,1260 1260,1860 2010,2400
messages or delete messages to

1118
00:36:56,130 --> 00:36:58,760
0,330 330,810
like k,|
|

1119
00:37:01,040 --> 00:37:02,360
0,540 540,720 720,930 930,1080 1080,1320
and so you might wonder
所以你可能会想，

1120
00:37:02,360 --> 00:37:03,470
0,360 360,660 660,780 780,960 960,1110
like,| why do it this
|为什么要这样做，

1121
00:37:03,470 --> 00:37:04,460
0,420 420,510 510,630 630,810 810,990
way,| you know why not
|为什么不把所有东西放在西海岸，

1122
00:37:04,460 --> 00:37:05,450
0,210 210,300 300,630 630,900 900,990
keep for example everything on

1123
00:37:05,450 --> 00:37:08,030
0,90 90,300 300,690 810,1380 1590,2580
the west coast,| and basically
|而是两倍的 memcache 和所有东西。

1124
00:37:08,030 --> 00:37:09,500
0,330 330,420 420,780 780,1020 1050,1470
double the number of {you,know}

1125
00:37:09,530 --> 00:37:10,490
0,240 240,600 600,750 750,840 840,960
{memcaches -} { -} and

1126
00:37:10,490 --> 00:37:11,300
0,120 120,210 210,360 360,420 420,810
all that kind of stuff.|
|

1127
00:37:11,720 --> 00:37:13,100
0,480 480,810 810,930 930,1080 1080,1380
{} You know the one
这样做的一个主要原因是，

1128
00:37:13,100 --> 00:37:14,180
0,300 300,570 570,660 660,810 810,1080
primary reason to do this

1129
00:37:14,180 --> 00:37:15,950
0,150 150,480 480,720 720,930 930,1770
is,| this good read performance
|对于用户来说，这种良好的读取性能，

1130
00:37:19,450 --> 00:37:21,040
0,390 390,840
for users,|
|

1131
00:37:21,600 --> 00:37:23,010
0,360 360,540 540,990 990,1110 1110,1410
{} good {read,performance} for users
对于在东海岸的用户来说，读取性能很好，

1132
00:37:23,010 --> 00:37:23,790
0,90 90,300 300,510 510,600 600,780
{} actually sitting on east

1133
00:37:23,790 --> 00:37:24,640
0,570
coast,|
|

1134
00:37:24,890 --> 00:37:26,660
0,510 510,780 780,1320 1350,1620 1620,1770
{you,know} the, they they will
他们会连接这些中的一个，

1135
00:37:26,660 --> 00:37:27,710
0,420 420,570 570,750 750,960 960,1050
connect {you,know} to one of

1136
00:37:27,710 --> 00:37:29,270
0,240 240,840 1020,1290 1290,1410 1410,1560
these guys,| {} they will
|他们在缓存中查找数据，

1137
00:37:29,270 --> 00:37:30,590
0,180 180,270 270,360 360,660 660,1320
look up the data in

1138
00:37:31,040 --> 00:37:33,230
0,570 600,1290 1320,1470 1470,1710 1710,2190
the cache,| their {memcache -}
|他们的 memcache 在东海岸，

1139
00:37:33,230 --> 00:37:34,730
0,390 390,630 630,840 840,1320 1320,1500
on the east coast,| and
|直接从 memcache 中返回数据，

1140
00:37:34,730 --> 00:37:35,990
0,150 150,540 540,840 840,1110 1110,1260
basically return {the,data} straight {out,of}

1141
00:37:35,990 --> 00:37:36,920
0,270 270,780
the memcache,|
|

1142
00:37:37,090 --> 00:37:38,110
0,180 180,540 540,660 660,720 720,1020
so {we're,basically} going to get
所以我们会得到好的，

1143
00:37:38,320 --> 00:37:40,090
0,600 600,1050 1050,1350 1350,1500 1500,1770
really good,| {you,know,one} we still
|一个是，我们得到好的读取性能，

1144
00:37:40,090 --> 00:37:41,320
0,180 180,240 240,420 420,570 570,1230
get a good read performance,|
|

1145
00:37:41,380 --> 00:37:42,460
0,120 120,600 600,690 690,840 840,1080
in fact, we can also
我们还可以获得低延迟，

1146
00:37:42,460 --> 00:37:43,720
0,120 120,300 300,900 900,1170 1170,1260
get low latency,| because we're
|因为我们从附近的一个复制中读取数据，

1147
00:37:43,720 --> 00:37:45,610
0,540 540,930 930,1140 1140,1260 1260,1890
basically reading from a replica

1148
00:37:45,640 --> 00:37:47,120
0,330 330,570 570,870 870,1200
{} that's close by,|
|

1149
00:37:48,280 --> 00:37:49,330
0,180 180,420 420,480 480,690 690,1050
of course, you know the
当然，这些缓存可能会有一点不同步，

1150
00:37:49,720 --> 00:37:51,550
0,780 780,1350 1350,1440 1440,1710 1710,1830
these caches you might get

1151
00:37:51,550 --> 00:37:52,690
0,30 30,180 180,570 570,990 990,1140
a little bit more out

1152
00:37:52,690 --> 00:37:54,070
0,60 60,450 480,720 720,1170 1170,1380
of sync,| than {for,example} that
|比起在一个数据中心，

1153
00:37:54,070 --> 00:37:55,090
0,120 120,210 210,480 480,690 690,1020
in the same data center,|
|

1154
00:37:55,090 --> 00:37:56,650
0,270 270,450 450,540 540,930 930,1560
because like this whole updates
因为像整个更新和失效，

1155
00:37:56,650 --> 00:37:58,150
0,150 150,240 240,960 1110,1320 1320,1500
and {invalidation -},| {you,know} all
|都是异步发生的，

1156
00:37:58,150 --> 00:37:59,640
0,360 360,450 450,1050
happens {asynchronously -},|
|

1157
00:38:05,230 --> 00:38:06,070
0,150 150,360 360,540 540,600 600,840
but, that's more or less
但是，这是可以的，

1158
00:38:06,070 --> 00:38:07,210
0,150 150,330 330,450 450,810 810,1140
a little bit okay, correct,|
|

1159
00:38:07,210 --> 00:38:09,460
0,510 870,1380 1380,1650 1650,1980 1980,2250
because {} we already said,|
因为我们已经说过，|

1160
00:38:09,460 --> 00:38:10,570
0,150 150,360 360,540 540,810 810,1110
that we're actually not looking
我们不是在寻找严格的一致性或串行化。

1161
00:38:10,570 --> 00:38:12,910
0,360 360,540 540,1590 1590,2220 2220,2340
for {you,know} strict consistency or

1162
00:38:12,910 --> 00:38:14,800
0,450 450,840 840,1590
{} or serializability.|
|

1163
00:38:15,120 --> 00:38:18,360
0,480 660,960 960,1920 1920,2550 2580,3240
{} I {have,a} question,| so,
我有个问题，|如果某人在东海岸，

1164
00:38:19,050 --> 00:38:20,180
0,780
{}

1165
00:38:21,040 --> 00:38:22,690
0,540 630,930 930,1260 1260,1560 1560,1650
if, so, if someone in

1166
00:38:22,690 --> 00:38:23,620
0,90 90,270 270,480 480,570 570,930
the east coast,| or client
|东海岸的客户端写入，

1167
00:38:23,620 --> 00:38:25,510
0,90 90,270 270,660 690,1500 1620,1890
{in,the} east coast write,| it
|它会直接写到西海岸的存储，对吗？

1168
00:38:25,510 --> 00:38:27,220
0,240 240,720 720,900 900,1350
writes directly to {

1169
00:38:27,640 --> 00:38:29,560
0,420 420,810 810,1380 1380,1590 1590,1920
-} to storage on west,

1170
00:38:29,560 --> 00:38:34,330
0,480 1200,1830 1980,2700 2700,3450 3870,4770
right?| Yeah.| Which, it doesn't
|是的。|但这并不会失效。

1171
00:38:34,330 --> 00:38:38,530
0,1050 1260,3480 3480,3750 3750,3930 3930,4200
invalidate.| {Okay\,,this,guy} also goes {invalidate
|好的，这个会对每个缓存执行失效操作。

1172
00:38:38,530 --> 00:38:40,800
0,540 540,690 690,1140 1170,1740
-} to each cache.|
|

1173
00:38:41,770 --> 00:38:43,660
0,450 450,630 630,750 750,1320 1350,1890
Oh, but we said, right,|
哦，但我们说过，|

1174
00:38:43,660 --> 00:38:45,610
0,180 180,300 300,750 780,1350 1740,1950
but we said,| {} like
但我们说过，|客户端读取自己的写入。

1175
00:38:45,610 --> 00:38:47,260
0,120 120,510 510,1110 1110,1440 1440,1650
the client itself to read

1176
00:38:47,260 --> 00:38:49,330
0,180 180,270 270,630 1740,1800 1800,2070
its own write, {its,own} write.|
|

1177
00:38:49,330 --> 00:38:50,680
0,240 240,480 480,960 960,1140 1140,1350
{Yeah\,,so} where does that where
是的，那么这个会去哪里，

1178
00:38:50,680 --> 00:38:51,550
0,180 180,390 390,570 570,750 750,870
does this go that,| of
|当然会去这里。

1179
00:38:51,550 --> 00:38:54,130
0,210 210,360 360,600 600,1200 1530,2580
course goes {to,here\,,right}.| Yeah, yeah,
|是的，理解了，好的。

1180
00:38:54,130 --> 00:38:55,520
0,180 180,360 360,750 780,1170
that makes sense, okay.|
|

1181
00:38:55,920 --> 00:38:56,900
0,690

1182
00:38:57,340 --> 00:38:58,180
0,720
Okay.|
好的。|

1183
00:38:59,090 --> 00:39:01,370
0,750 840,1740 1740,1860 1860,1920 1920,2280
Okay?| I got a question
好的?|我也有个问题，

1184
00:39:01,370 --> 00:39:02,240
0,360 360,510
{too -},|
|

1185
00:39:03,200 --> 00:39:06,420
0,1020 1020,1680 1680,2880
do clients always
客户端是不是总是访问，

1186
00:39:06,780 --> 00:39:08,520
0,510 600,930 930,1140 1140,1410 1410,1740
talk,| said, will given client
|比如，给定的客户端是否总是访问相同的 memcache 服务器？

1187
00:39:08,520 --> 00:39:09,930
0,570 570,900 900,960 960,1110 1110,1410
always talk to the same

1188
00:39:09,930 --> 00:39:11,160
0,180 180,450 450,930
{memcache -} server?|
|

1189
00:39:11,890 --> 00:39:12,820
0,630
No,
不，我往回一点，

1190
00:39:13,040 --> 00:39:15,710
0,990 1020,1500 1500,2100 2130,2370 2370,2670
{} because I'll go back

1191
00:39:15,710 --> 00:39:17,030
0,30 30,180 180,300 300,900 1110,1320
a little bit earlier,| and
|我们稍后会讨论这个问题，

1192
00:39:17,030 --> 00:39:17,720
0,90 90,240 240,420 420,570 570,690
we'll talk about this in

1193
00:39:17,720 --> 00:39:18,950
0,30 30,330 330,690 690,1080 1080,1230
a second,| because actually is
|因为正如我们将看到的，这是一个问题，

1194
00:39:18,950 --> 00:39:21,140
0,570 900,1410 1410,1500 1500,2010 2010,2190
a {} a problem as

1195
00:39:21,140 --> 00:39:22,610
0,120 120,540 690,1230 1230,1380 1380,1470
we'll see,| {} so if
|所以，前端访问，

1196
00:39:22,610 --> 00:39:24,140
0,90 90,330 330,540 540,930 930,1530
a {frontend -} basically talks,|
|

1197
00:39:24,140 --> 00:39:25,850
0,570 600,1080 1110,1290 1290,1560 1560,1710
{} the the keys are
键分片在 memcache 服务器上，

1198
00:39:25,850 --> 00:39:27,200
0,390 390,690 690,780 780,960 960,1350
sharded across the {memcache -}

1199
00:39:27,230 --> 00:39:29,810
0,480 480,810 1410,2070 2070,2370 2370,2580
servers, right,| {} and so
|比如键 k1 ，

1200
00:39:29,810 --> 00:39:31,430
0,240 240,510 510,720 720,1200 1200,1620
like whatever key k1,| k1
|k1 在 C1 上，

1201
00:39:31,430 --> 00:39:33,050
0,300 300,780 780,960 960,1440 1440,1620
{lives,in} C1,| {k2,lives,in -} {C2
|k2 在 C2 上，等等，

1202
00:39:33,050 --> 00:39:34,320
0,210 210,540 540,1020
-}, etc etc,|
|

1203
00:39:34,600 --> 00:39:36,370
0,630 630,1110 1110,1380 1380,1560 1560,1770
and typically from then, when
当它需要组成一个网页时，

1204
00:39:36,370 --> 00:39:37,990
0,120 120,570 570,1110 1110,1290 1290,1620
it needs to {} construct

1205
00:39:37,990 --> 00:39:38,740
0,30 30,180 180,480 480,570 570,750
a web page,| it needs
|它需要很多键，

1206
00:39:38,740 --> 00:39:39,400
0,90 90,210 210,240 240,450 450,660
to get a whole bunch

1207
00:39:39,400 --> 00:39:41,440
0,90 90,600 990,1560 1560,1740 1740,2040
of keys,| and so sends
|同时发送这些请求到不同的 memcached ，

1208
00:39:41,440 --> 00:39:44,080
0,360 360,840 870,1500 1500,1980 1980,2640
actually these requests basically parallel

1209
00:39:44,080 --> 00:39:46,510
0,150 150,240 240,900 1170,2070 2100,2430
to the different {} {memcacheds

1210
00:39:46,510 --> 00:39:47,830
0,240 240,750 750,990 990,1170 1170,1320
- -},| and gets all
|然后获得所有的回复，

1211
00:39:47,830 --> 00:39:49,020
0,90 90,600 600,1020
the responses back,|
|

1212
00:39:49,610 --> 00:39:52,760
0,540 540,1290 1470,2340 2550,2940 2940,3150
{} and the, {} and
所以事实上，

1213
00:39:52,760 --> 00:39:53,480
0,120 120,210 210,540 540,630 630,720
so in fact,| you know
|前端很可能会访问系统中每个 memcached 。

1214
00:39:53,480 --> 00:39:54,470
0,120 120,390 390,630 630,750 750,990
the {frontends -} are very

1215
00:39:54,470 --> 00:39:56,060
0,450 450,570 570,840 840,960 960,1590
likely to talk to every

1216
00:39:56,240 --> 00:39:58,340
0,960 960,1500 1500,1560 1560,1650 1650,2100
{memcached -} in the system.|
|

1217
00:39:59,860 --> 00:40:01,420
0,210 210,510 510,780 780,1290 1320,1560
I see, but for, but
我明白了，如果对于一个给定的键，

1218
00:40:01,420 --> 00:40:02,590
0,150 150,270 270,630 630,1050 1050,1170
for a given key,| would
|是否总是访问相同的服务器。

1219
00:40:02,590 --> 00:40:03,580
0,300 300,510 510,600 600,720 720,990
always talk to the same

1220
00:40:03,580 --> 00:40:06,040
0,420 450,930 1200,2070 2070,2250 2250,2460
server.| Yes, yeah, they they
|是的，他们使用了一致性哈希，

1221
00:40:06,040 --> 00:40:07,450
0,330 330,660 660,750 750,990 990,1410
actually happened to use consistent

1222
00:40:07,450 --> 00:40:10,600
0,570 1080,1380 1380,2220 2730,2970 2970,3150
hashing,| so if we'll talk
|我们稍后会多谈一点，

1223
00:40:10,600 --> 00:40:11,440
0,30 30,180 180,330 330,570 570,840
a little bit about second

1224
00:40:11,440 --> 00:40:12,250
0,60 60,210 210,360 360,570 570,810
a little bit more,| like
|如果一个 memcached 服务器出现故障，

1225
00:40:12,250 --> 00:40:13,000
0,150 150,270 270,330 330,540 540,750
one of the one {memcached

1226
00:40:13,000 --> 00:40:14,260
0,240 240,390 390,690 690,900 900,1260
- -} server goes down,

1227
00:40:14,260 --> 00:40:15,580
0,360 660,870 870,1050 1050,1260 1260,1320
correct,| it can't talk to
|它就不能访问那个了，

1228
00:40:15,580 --> 00:40:17,470
0,180 180,330 330,810 1050,1410 1410,1890
that one anymore,| and so
|所以，随着时间的推移，

1229
00:40:17,500 --> 00:40:18,670
0,150 150,360 360,510 510,720 720,1170
it might be over time,|
|

1230
00:40:18,670 --> 00:40:20,950
0,180 180,300 300,930 930,1440 1500,2280
that the assignment from shards
从分片到服务器的分配可能会发生一些变化。

1231
00:40:20,950 --> 00:40:22,960
0,750 750,1020 1020,1590 1590,1770 1770,2010
to {} servers will change

1232
00:40:22,960 --> 00:40:23,660
0,60 60,270 270,570
a little bit.|
|

1233
00:40:26,010 --> 00:40:27,150
0,360 360,630 630,780 780,870 870,1140
Sorry, actually just to follow
抱歉，我想跟进一下，

1234
00:40:27,150 --> 00:40:28,980
0,150 150,300 300,630 840,1440 1500,1830
up on that,| so the
|所以客户端需要读取自己的写入内容，

1235
00:40:28,980 --> 00:40:30,960
0,660 660,990 990,1590 1590,1770 1770,1980
requirement for clients to read

1236
00:40:30,960 --> 00:40:32,160
0,150 150,330 330,990
their own writes,|
|

1237
00:40:32,360 --> 00:40:34,130
0,660 900,1230 1230,1500 1500,1560 1560,1770
is is kind of like
像是一种弱的保证，

1238
00:40:34,130 --> 00:40:35,930
0,330 360,750 750,1380 1380,1590 1590,1800
a weak guarantee, right,| because
|因为如果它从中删除的服务器停机，

1239
00:40:35,930 --> 00:40:36,890
0,180 180,300 300,660 660,870 870,960
if the server that it

1240
00:40:36,890 --> 00:40:38,960
0,330 330,720 750,1050 1050,1680 1920,2070
deletes from goes down,| and
|然后它必须从不同的复制中读取，

1241
00:40:38,960 --> 00:40:40,130
0,210 210,540 540,780 780,900 900,1170
then it has to read

1242
00:40:40,130 --> 00:40:41,360
0,150 150,270 270,540 540,1110 1110,1230
from a different replica,| it
|它可能最终不能读取自己的写入内容，

1243
00:40:41,360 --> 00:40:42,350
0,210 210,330 330,450 450,720 720,990
might end up not reading

1244
00:40:42,350 --> 00:40:43,120
0,180 180,510
its write,|
|

1245
00:40:43,520 --> 00:40:44,750
0,540 570,690 690,780 780,1140 1140,1230
if in the presence of
如果在出现故障时。

1246
00:40:44,750 --> 00:40:46,550
0,90 90,660 720,1290 1290,1470 1470,1800
a failure.| Hold on, hold
|稍等一下，好吗，

1247
00:40:46,550 --> 00:40:47,540
0,180 180,480 480,810 810,960 960,990
on, hold that for a

1248
00:40:47,540 --> 00:40:48,680
0,150 150,390 420,840
little while, okay,|
|

1249
00:40:49,050 --> 00:40:49,770
0,180 180,360 360,510 510,660 660,720
{you,know} we'll see there's a
我们会看到有一些[]或竞争，

1250
00:40:49,770 --> 00:40:51,630
0,330 330,390 390,930 1110,1470 1470,1860
number of [] or races,|
|

1251
00:40:51,630 --> 00:40:52,320
0,120 120,240 240,510 510,630 630,690
if you will and they
他们有不同的技术来解决这些竞争问题。

1252
00:40:52,320 --> 00:40:53,760
0,210 210,510 510,960 960,1110 1110,1440
have different techniques for solving

1253
00:40:53,760 --> 00:40:54,700
0,180 180,750
those races.|
|

1254
00:40:55,150 --> 00:40:58,420
0,570 720,1140 1140,1440 1440,2010 2760,3270
Oh, sorry, final question.| Yeah,
哦，抱歉，最后一个问题。|是的，最后一个，继续。

1255
00:40:58,420 --> 00:41:05,020
0,510 540,2610 3570,4290 5250,5520 5520,6600
final, {go,ahead}.| Oh, so we're
|哦，所以我们在做，

1256
00:41:05,020 --> 00:41:06,620
0,660 690,1350
doing {},|
|

1257
00:41:06,860 --> 00:41:08,420
0,300 300,540 540,960 960,1380 1380,1560
we like for read for
我们为了读取自己的写入，

1258
00:41:08,420 --> 00:41:09,950
0,210 210,330 330,480 480,1140 1350,1530
read our own writes,| we
|我们确保直接访问存储服务器，

1259
00:41:09,950 --> 00:41:11,510
0,210 210,540 540,930 960,1230 1230,1560
make sure that we go

1260
00:41:11,510 --> 00:41:12,980
0,420 420,510 510,630 630,990 990,1470
directly to the storage servers,|
|

1261
00:41:12,980 --> 00:41:15,230
0,360 360,690 690,1020 1140,1770 1800,2250
right after, {} right, correct?|
正好在后面，对吗？|

1262
00:41:15,230 --> 00:41:17,000
0,420 450,660 660,1140 1140,1230 1230,1770
Yes.| {} {Not,in} the cache,|
是的。|不在缓存中，|

1263
00:41:17,180 --> 00:41:20,090
0,660 660,1260 1530,2310 2310,2520 2520,2910
{} but you also said
但你也说过。

1264
00:41:20,090 --> 00:41:21,500
0,540 570,840 840,1050 1050,1200 1200,1410
the.| No, hold on hold
|不，稍等，

1265
00:41:21,500 --> 00:41:21,960
0,150
on,|
|

1266
00:41:22,430 --> 00:41:23,690
0,270 270,390 390,600 600,1020 1050,1260
when you do write,| you
当你执行写入时，|你在数据库中进行更新。

1267
00:41:23,690 --> 00:41:24,410
0,90 90,240 240,570 570,630 630,720
do the update in the

1268
00:41:24,410 --> 00:41:26,360
0,750 780,1110 1110,1230 1230,1380 1380,1950
database.| Right.| Then you delete
|是的。|然后你从你的系统中删除键，

1269
00:41:26,360 --> 00:41:28,880
0,90 90,480 480,660 660,1350 1530,2520
the key from your {}

1270
00:41:28,880 --> 00:41:30,290
0,390 390,600 600,1140 1140,1230 1230,1410
system,| so {for,example} in this
|例如，在这个案例中，

1271
00:41:30,290 --> 00:41:31,480
0,360 360,960
particular case,|
|

1272
00:41:32,300 --> 00:41:33,560
0,390 420,540 540,690 690,900 900,1260
{} you know you would
你会写入到 primary ，

1273
00:41:34,190 --> 00:41:35,420
0,480 480,600 600,720 720,1140 1140,1230
you do a write you

1274
00:41:35,420 --> 00:41:37,220
0,90 90,270 270,390 390,1020 1230,1800
know to the primary,| delete
|从你的本地缓存中删除键 k ，

1275
00:41:37,220 --> 00:41:39,080
0,60 60,780 780,960 960,1410 1440,1860
the {key,k} from your local

1276
00:41:39,080 --> 00:41:40,550
0,690 750,990 990,1110 1110,1200 1200,1470
cache,| so when the next
|所以当你下一次执行 get 时，

1277
00:41:40,550 --> 00:41:42,170
0,240 240,330 330,540 540,1050 1260,1620
time you do get {},|
|

1278
00:41:42,170 --> 00:41:44,870
0,150 150,1710 2010,2460 2460,2640 2640,2700
you're gonna read from the
你将再次从存储服务器读取。

1279
00:41:44,870 --> 00:41:46,790
0,300 300,600 600,840 900,1320 1410,1920
storage server again.| Right, exactly,
|是的，没错，但我很好奇，

1280
00:41:46,790 --> 00:41:48,400
0,840 840,1470
yeah, but

1281
00:41:49,210 --> 00:41:51,220
0,390 390,960 960,1110 1110,1590 1590,2010
{} I was curious,| so
|所以你也说过，

1282
00:41:51,400 --> 00:41:53,500
0,420 540,810 810,1050 1050,1560 1560,2100
that you also said,| the
|对存储的写入是异步进行的，对吗？

1283
00:41:53,590 --> 00:41:55,420
0,600 600,690 690,1260 1260,1680 1680,1830
write to storage happen {asynchronously

1284
00:41:55,420 --> 00:41:56,840
0,780 780,1170
-}, right?|
|

1285
00:41:57,450 --> 00:42:01,080
0,960 1140,1560 1560,1950 2100,2580 2970,3630
The the, this this replication
这个复制是异步进行的，

1286
00:42:01,080 --> 00:42:02,490
0,360 360,480 480,1140 1140,1290 1290,1410
happens {asynchronously -}| and the
|失效是异步进行的，

1287
00:42:02,490 --> 00:42:04,440
0,600 600,990 990,1110 1110,1620 1650,1950
invalidation happens {asynchronously -},| not
|而不是写入。

1288
00:42:04,440 --> 00:42:05,970
0,90 90,570 750,1110 1110,1200 1200,1530
the write.| Okay, the writes
|好的，写入是同步的。

1289
00:42:05,970 --> 00:42:06,920
0,90 90,780
are synchronous.|
|

1290
00:42:07,660 --> 00:42:08,950
0,210 210,450 450,930 930,1200 1200,1290
So, {you,do} {the,delete} after you
所以，你在完成写入后执行删除。

1291
00:42:08,950 --> 00:42:10,900
0,240 240,360 360,690 840,1350 1560,1950
finish the write.| Okay, great,
|好的，很好，谢谢。

1292
00:42:10,990 --> 00:42:11,980
0,510
thanks.|
|

1293
00:42:12,720 --> 00:42:16,120
0,600 720,1320 1380,1710 2190,2820
A question here,| so
有一个问题，|所以如果你执行写入，

1294
00:42:16,360 --> 00:42:18,070
0,180 180,330 330,450 450,1260 1500,1710
if you do {a,write},| and
|而你来自，

1295
00:42:18,070 --> 00:42:19,840
0,270 270,690 690,1290
you're from the,|
|

1296
00:42:20,080 --> 00:42:21,190
0,180 180,360 360,690 690,840 840,1110
so you're not, you're not
你不是来自 primary 区域，

1297
00:42:21,190 --> 00:42:23,440
0,240 240,360 360,990 990,1590 1620,2250
from the primary region,| you
|你向主存储执行写入操作，

1298
00:42:23,440 --> 00:42:24,460
0,180 180,330 330,750 750,840 840,1020
do a write to the

1299
00:42:24,460 --> 00:42:26,470
0,600 600,1380 1440,1770 1770,1920 1920,2010
primary storage,| and then you
|然后你失效你的 memcache ，

1300
00:42:26,470 --> 00:42:28,270
0,630 630,840 840,1140 1140,1590 1590,1800
invalidate your {memcache -},| and
|然后进行读取，

1301
00:42:28,270 --> 00:42:29,980
0,210 210,510 510,810 810,1260 1350,1710
then do a read,| but
|但是从你的存储中读取，

1302
00:42:30,010 --> 00:42:31,690
0,480 480,750 750,1080 1080,1530 1530,1680
read from your storage,| and
|也许你的存储还不是最新的。

1303
00:42:31,690 --> 00:42:33,760
0,600 930,1260 1260,1440 1440,1740 1740,2070
maybe {} your storage isn't

1304
00:42:33,760 --> 00:42:35,590
0,180 180,300 300,600 600,960 1650,1830
up to date yet.| {Yeah\,,so}
|是的，所以有风险，

1305
00:42:35,590 --> 00:42:37,030
0,150 150,360 360,810 840,1260 1260,1440
you gotta risk,| so {we'll,see,how}
|所以，我们将看他们如何解决这个问题的。

1306
00:42:37,030 --> 00:42:37,980
0,60 60,120 120,390 390,690
{they -} solve that.|
|

1307
00:42:38,290 --> 00:42:39,140
0,510
Okay.|
好的。|

1308
00:42:40,750 --> 00:42:42,460
0,210 210,510 990,1230 1230,1470 1470,1710
That's correct,| but first let's
没错，|但首先让我们更多地谈谈性能，

1309
00:42:42,460 --> 00:42:43,900
0,180 180,360 360,540 540,990 990,1440
talk more about performance,| because
|因为这对他们来说还不够好，

1310
00:42:43,960 --> 00:42:44,860
0,150 150,360 360,480 480,690 690,900
it's not good enough for

1311
00:42:44,860 --> 00:42:45,880
0,240 240,480 510,630 630,840 840,1020
them yet,| they want more
|他们想要更高的性能。

1312
00:42:45,880 --> 00:42:46,900
0,690
performance.|
|

1313
00:42:47,160 --> 00:42:48,140
0,540

1314
00:42:48,320 --> 00:42:50,240
0,750 930,1140 1140,1530 1530,1650 1650,1920
{And,so} {} you know if
所以如果从广义上说，

1315
00:42:50,240 --> 00:42:52,370
0,90 90,270 270,630 630,1200 1560,2130
you {sort,of} broadly speaking, {}|
|

1316
00:42:52,400 --> 00:42:54,500
0,210 210,360 360,1140 1140,1800 1800,2100
there are two strategies {to,getting}
有两种策略可以获得性能。

1317
00:42:54,500 --> 00:42:55,500
0,810
performance.|
|

1318
00:42:55,770 --> 00:42:57,960
0,450 450,630 630,930 960,2160 2160,2190
I'm just stepping back a
我往后退一点，

1319
00:42:57,960 --> 00:43:06,900
0,240 240,510 7980,8220 8220,8580 8580,8940
little bit,| we already seen
|我们已经在高级别上看到了它们。

1320
00:43:06,900 --> 00:43:07,650
0,60 60,180 180,240 240,420 420,750
{them -} a little bit,

1321
00:43:08,010 --> 00:43:09,300
0,570 570,840 840,900 900,1170 1170,1290
{} in a very high

1322
00:43:09,300 --> 00:43:10,080
0,300 300,420 420,510 510,570 570,780
level.| So there are two
|所以有两个方案，

1323
00:43:10,080 --> 00:43:12,300
0,450 450,690 690,1200 1290,1770 1770,2220
basically {} plan,| one is
|一个是分区或分片，

1324
00:43:12,300 --> 00:43:15,000
0,720 960,1350 1350,1920 1920,2040 2040,2700
to {} partition or shard,|
|

1325
00:43:23,060 --> 00:43:24,620
0,240 240,540 540,750 750,1230 1230,1560
and that's very cool,| because
这很酷，|因为我们看到这使用在

1326
00:43:24,620 --> 00:43:25,490
0,180 180,450 450,510 510,720 720,870
in fact we see {this,being}

1327
00:43:25,490 --> 00:43:27,110
0,510 510,900 900,1380 1380,1560 1560,1620
use basically| both on the
|存储层和 memcache 层上，

1328
00:43:27,110 --> 00:43:28,310
0,360 360,720 720,930 930,990 990,1200
storage layer and the {memcache

1329
00:43:28,310 --> 00:43:29,780
0,300 300,780 960,1200 1200,1380 1380,1470
-} layer,| and so if
|如果你需要更多容量，

1330
00:43:29,780 --> 00:43:31,730
0,540 540,720 720,930 930,1110 1110,1950
you you need more capacity,|
|

1331
00:43:31,910 --> 00:43:33,380
0,450 450,840 840,990 990,1170 1170,1470
{} you should buy another
你应该再买一台服务器，

1332
00:43:33,380 --> 00:43:36,380
0,630 630,1320 1650,2160 2160,2760 2760,3000
server,| {} change the hashing
|修改散列函数，

1333
00:43:36,380 --> 00:43:38,150
0,690 990,1260 1260,1470 1470,1620 1620,1770
function,| and so you've got
|这样你的 memcached 中有了更多的容量，

1334
00:43:38,150 --> 00:43:39,470
0,150 150,810 810,960 960,1110 1110,1320
more capacity in your {memcached

1335
00:43:39,470 --> 00:43:40,550
0,240 240,600 600,870 870,990 990,1080
- -},| and you can
|你可以保存更多的数据，

1336
00:43:40,550 --> 00:43:41,990
0,240 240,420 420,810 840,1110 1110,1440
hold more data, right, {}|
|

1337
00:43:42,290 --> 00:43:43,220
0,300 300,450 450,660 660,810 810,930
and that data can be
并且数据可以被并行访问，

1338
00:43:43,220 --> 00:43:44,400
0,420 420,510 510,1080
accessed in parallel,|
|

1339
00:43:44,890 --> 00:43:45,580
0,180 180,390 390,540 540,660 660,690
so {you,know} we've got a
所以我们得到很大的容量，

1340
00:43:45,580 --> 00:43:47,520
0,150 150,210 210,1050
lot of capacity,|
|

1341
00:43:53,310 --> 00:43:55,590
0,300 300,1050 1050,1350 1350,1890 1890,2280
{lots,of} capacity, {lots,of} parallelism side,|
很大的容量，很大的并行性，|

1342
00:43:59,400 --> 00:44:00,750
0,540 570,990 990,1140 1140,1230 1230,1350
{} but you know if
但是，如果你有非常热的键，

1343
00:44:00,750 --> 00:44:02,100
0,180 180,570 570,660 660,1050 1050,1350
you have {} particular key

1344
00:44:02,100 --> 00:44:05,130
0,180 180,630 630,1140 1380,2490 2490,3030
that's extremely hot,| a lot
|很多客户端都需要获取那个键，

1345
00:44:05,130 --> 00:44:06,930
0,720 840,1230 1230,1440 1440,1560 1560,1800
of clients actually need to

1346
00:44:06,930 --> 00:44:07,830
0,240 240,360 360,690 690,780 780,900
get that key,| you know
|无论是 Facebook 的特殊的人，

1347
00:44:07,830 --> 00:44:09,330
0,270 270,360 360,810 810,1230 1230,1500
whatever a particular person on

1348
00:44:09,510 --> 00:44:11,250
0,660 660,840 840,1050 1050,1110 1110,1740
Facebook| who has a timeline
|有一个每个人都关注的时间线，

1349
00:44:11,250 --> 00:44:13,140
0,390 390,1080 1080,1170 1170,1290 1290,1890
that {everybody,is} you know following,|
|

1350
00:44:13,320 --> 00:44:15,480
0,510 510,600 600,720 720,1050 1050,2160
then you know that that
然后那个键会命中很多次，

1351
00:44:15,480 --> 00:44:16,140
0,210 210,270 270,390 390,450 450,660
key is going to hit

1352
00:44:16,140 --> 00:44:18,000
0,90 90,540 870,1650 1650,1770 1770,1860
a lot,| and it is
|它被提供服务，

1353
00:44:18,000 --> 00:44:19,440
0,150 150,660 840,1260 1260,1320 1320,1440
being served,| [] in this
|在这种情况下，可能由两个不同的服务器提供服务，

1354
00:44:19,440 --> 00:44:20,550
0,300 300,480 480,750 750,960 960,1110
case, being served maybe by

1355
00:44:20,550 --> 00:44:22,080
0,180 180,480 480,870 870,1080 1080,1530
two different servers,| one in
|一个在西海岸，一个在东海岸，

1356
00:44:22,080 --> 00:44:22,890
0,90 90,300 300,540 540,750 750,810
the west coast, one on

1357
00:44:22,890 --> 00:44:24,390
0,60 60,270 270,630 900,1290 1290,1500
the east coast,| {} but
|但是东海岸和西海岸的很多客户端，

1358
00:44:24,390 --> 00:44:25,200
0,90 90,180 180,540 540,600 600,810
{you,know -} presumably a lot

1359
00:44:25,200 --> 00:44:25,980
0,60 60,390 390,540 540,630 630,780
of clients on the east

1360
00:44:25,980 --> 00:44:27,030
0,270 270,600 600,660 660,870 870,1050
coast and the west coast,|
|

1361
00:44:27,030 --> 00:44:28,230
0,60 60,240 240,540 540,600 600,1200
will gonna hit the same,|
将会命中相同的，|

1362
00:44:28,380 --> 00:44:29,880
0,270 270,360 360,780 1020,1290 1290,1500
or the two,| {the,memcached -
或者两个，|西海岸的 memcached 服务器，

1363
00:44:29,880 --> 00:44:30,990
0,150 150,660 660,810 810,900 900,1110
-} server on the west

1364
00:44:30,990 --> 00:44:32,130
0,330 330,510 510,660 660,990 990,1140
coast| and {memcached - -}
|和东海岸的 memcached 服务器，

1365
00:44:32,130 --> 00:44:33,330
0,300 300,510 510,750 750,990 990,1200
server east coast,| hold that
|持有那个键，

1366
00:44:33,330 --> 00:44:33,640
0,240
key,|
|

1367
00:44:34,410 --> 00:44:36,030
0,540 540,990 1080,1230 1230,1470 1470,1620
{} and so that's not
那就不太好了，

1368
00:44:36,030 --> 00:44:36,930
0,120 120,210 210,420 420,660 690,900
gonna be that good, right,|
|

1369
00:44:36,930 --> 00:44:38,040
0,270 270,630 630,750 750,870 870,1110
because like you know that
因为单个服务器可能会超载，

1370
00:44:38,040 --> 00:44:39,480
0,270 270,720 720,930 930,1140 1140,1440
single server might actually get

1371
00:44:39,480 --> 00:44:41,100
0,780 900,1050 1050,1170 1170,1410 1410,1620
overloaded| and it turns out
|事实证明，键分发的差异很大，

1372
00:44:41,100 --> 00:44:43,440
0,510 510,720 720,1410 1560,1980 1980,2340
the key distribution {} varies

1373
00:44:43,440 --> 00:44:44,160
0,390
widely,|
|

1374
00:44:44,770 --> 00:44:45,580
0,150 150,240 240,450 450,630 630,810
and so that's not so
所以这并不是很好。

1375
00:44:45,580 --> 00:44:46,660
0,240 240,330 330,630 690,870 870,1080
good.| And so to solve
|所以，要解决这样的问题，

1376
00:44:46,660 --> 00:44:47,920
0,240 240,360 360,870 960,1170 1170,1260
problems like that,| and the
|第二种方法是复制，复制数据，

1377
00:44:47,920 --> 00:44:49,270
0,300 300,510 510,570 570,1140 1170,1350
second sort of approach is

1378
00:44:49,270 --> 00:44:50,400
0,120 120,750
to replicate,

1379
00:44:52,710 --> 00:44:53,960
0,960
{replicate,data},|
|

1380
00:44:54,170 --> 00:44:55,490
0,150 150,210 210,390 390,780 780,1320
so here is partition data
这里是分区数据，然后是复制数据，

1381
00:44:56,480 --> 00:44:57,680
0,150 150,300 300,360 360,480 480,1200
and then {} is {replicate,data},|
|

1382
00:44:59,460 --> 00:45:01,170
0,420 420,990 990,1230 1230,1440 1440,1710
that's great {you,know} for hot
这对热的键来说很好，

1383
00:45:01,170 --> 00:45:02,040
0,420
keys,|
|

1384
00:45:03,610 --> 00:45:04,180
0,150 150,270 270,360 360,510 510,570
if you can take the
如果你可以使相同的键扩展到不同的 memcached 服务器，

1385
00:45:04,180 --> 00:45:05,770
0,240 240,780 900,1440 1440,1530 1530,1590
same key propagated on a

1386
00:45:05,770 --> 00:45:06,820
0,180 180,270 270,510 510,900 900,1050
bunch of different {memcached -}

1387
00:45:06,820 --> 00:45:09,070
0,600 810,1230 1230,1740 1740,1950 1950,2250
servers,| then {the,clients} that {all,hit}
|然后，所有命中这个键的客户端

1388
00:45:09,070 --> 00:45:10,090
0,210 210,480 480,600 600,720 720,1020
that key| can be spread
|都可以分布在这些 memcached 服务器上，

1389
00:45:10,090 --> 00:45:11,140
0,480 480,540 540,660 660,870 870,1050
across you know those {memcached

1390
00:45:11,140 --> 00:45:12,460
0,390 390,840 840,1110 1110,1260 1260,1320
-} servers| and get the
|并且并行地获得键，

1391
00:45:12,460 --> 00:45:14,180
0,300 300,690 690,1200
keys basically {in,parallel},|
|

1392
00:45:14,370 --> 00:45:15,810
0,540 540,720 720,840 840,1200 1200,1440
{} and so that it
所以，这对热键很有效。

1393
00:45:15,810 --> 00:45:17,550
0,240 240,600 600,1020 1050,1590 1590,1740
works actually {} good for

1394
00:45:17,550 --> 00:45:18,520
0,240 240,750
hot keys.|
|

1395
00:45:18,960 --> 00:45:20,020
0,630

1396
00:45:20,100 --> 00:45:21,450
0,240 240,480 480,720 720,1140 1140,1350
It doesn't really increase {you,know}
它并不能增加容量，

1397
00:45:21,450 --> 00:45:24,420
0,690 810,1080 1080,1320 1650,2280 2460,2970
capacity,| so you just just
|所以你需要更多的，

1398
00:45:24,420 --> 00:45:26,060
0,390 390,810
takes more,|
|

1399
00:45:27,240 --> 00:45:27,990
0,210 210,330 330,480 480,660 660,750
and in some ways we
在某些方面，我们可以在上一张图片中看到，

1400
00:45:27,990 --> 00:45:28,530
0,90 90,210 210,360 360,450 450,540
can see this in the

1401
00:45:28,530 --> 00:45:30,360
0,390 390,990 990,1140 1140,1320 1320,1830
previous picture,| we have replication
|我们在这里进行了复制，

1402
00:45:30,360 --> 00:45:31,560
0,90 90,420 420,810 840,990 990,1200
in action here,| we have
|我们复制了一个数据中心，

1403
00:45:31,560 --> 00:45:33,720
0,750 780,1110 1110,1380 1380,1920 2040,2160
replicated one data center,| you
|从西海岸到东海岸，

1404
00:45:33,720 --> 00:45:34,710
0,210 210,480 480,540 540,750 750,990
know from the west coast

1405
00:45:34,710 --> 00:45:35,940
0,360 360,450 450,570 570,750 750,1230
completely to the east coast,|
|

1406
00:45:36,090 --> 00:45:38,100
0,300 300,630 630,1260 1260,1920 1920,2010
that hasn't {} increase the
这并没有增加 memcached 的总容量，

1407
00:45:38,100 --> 00:45:40,200
0,270 270,990 1560,1830 1830,1920 1920,2100
total capacity for the {memcached

1408
00:45:40,200 --> 00:45:41,370
0,180 180,450 450,720 720,1020 1020,1170
- -},| because both {memcache
|由于两个 memcache 层都存储了相同数量的数据，

1409
00:45:41,370 --> 00:45:42,870
0,270 270,570 570,750 750,960 960,1500
-} the {memcache -} layers

1410
00:45:42,870 --> 00:45:45,480
0,840 1800,2100 2100,2160 2160,2340 2340,2610
store store the same amount

1411
00:45:45,480 --> 00:45:47,880
0,120 120,750 900,1680 1710,1830 1830,2400
of {} data,| and {didn't,increase}
|没有增加 memcache 层的容量，

1412
00:45:47,880 --> 00:45:49,080
0,180 180,660 660,930 930,1020 1020,1200
the capacity of the {memcache

1413
00:45:49,080 --> 00:45:51,330
0,210 210,630 1140,1560 1680,2100 2130,2250
-} layer,| {} but you
|但是你允许读取两个不同的 memcache 层，

1414
00:45:51,330 --> 00:45:52,920
0,120 120,330 330,750 750,960 960,1590
know you're allowed to {you,know}

1415
00:45:52,980 --> 00:45:54,330
0,480 480,660 660,810 810,960 960,1350
read from these two different

1416
00:45:54,330 --> 00:45:55,440
0,120 120,300 300,570 570,990 990,1110
and {memcache -} layers| on
|并行的从东海岸和西海岸（读取）。

1417
00:45:55,440 --> 00:45:56,160
0,60 60,240 240,330 330,510 510,720
the east and west coast

1418
00:45:56,160 --> 00:45:56,720
0,90 90,480
in parallel.|
|

1419
00:45:57,850 --> 00:45:59,320
0,570 1050,1200 1200,1290 1290,1410 1410,1470
Okay?| So we see a
好的?|所以我们看到了一种复制的小型形式，

1420
00:45:59,320 --> 00:46:00,850
0,420 420,690 690,780 780,1290 1290,1530
little form of replication going

1421
00:46:00,850 --> 00:46:02,920
0,390 750,1260 1260,1380 1380,1590 1590,2070
on| and you might wonder
|你可能会想，还有什么事情要做吗？

1422
00:46:02,920 --> 00:46:04,420
0,300 300,960 960,1230 1230,1320 1320,1500
like what else is left

1423
00:46:04,420 --> 00:46:05,280
0,60 60,150 150,480
to be done?|
|

1424
00:46:05,590 --> 00:46:07,390
0,480 480,780 780,1080 1080,1530 1530,1800
And this comes to a
这就涉及到了之前提出的一个问题，

1425
00:46:07,420 --> 00:46:08,410
0,420 420,510 510,780 780,810 810,990
question was asked a little

1426
00:46:08,410 --> 00:46:10,270
0,120 120,750 810,1500 1500,1680 1680,1860
bit earlier,| {let's,say} you need
|比如，你需要更多的容量，

1427
00:46:10,270 --> 00:46:12,310
0,270 270,900 1320,1590 1590,1710 1710,2040
more capacity, right,| so well,
|所以，一个更多容量的解决方案，

1428
00:46:12,310 --> 00:46:13,990
0,150 150,780 780,1260 1260,1590 1590,1680
{} one solution to {you,know}

1429
00:46:13,990 --> 00:46:15,190
0,240 240,840 840,1050 1050,1140 1140,1200
more capacity,| even in a
|即使在单个数据中心，

1430
00:46:15,190 --> 00:46:16,330
0,270 270,480 480,750 750,870 870,1140
single data center,| so forget
|所以忘了有两个数据中心，

1431
00:46:16,330 --> 00:46:17,350
0,120 120,330 330,450 450,690 690,1020
that there's two data centers,|
|

1432
00:46:17,350 --> 00:46:18,760
0,270 270,480 480,900 990,1320 1320,1410
just look for things from
只从单个数据中心的角度来看，

1433
00:46:18,760 --> 00:46:19,630
0,60 60,480 480,540 540,600 600,870
the perspective of a single

1434
00:46:19,630 --> 00:46:20,980
0,240 240,720 780,1050 1050,1200 1200,1350
data center,| we want more
|我们想要更大的容量，

1435
00:46:20,980 --> 00:46:23,320
0,600 810,1080 1080,1440 1470,2010 2010,2340
capacity,| {} one option correct
|一个选择是，

1436
00:46:23,320 --> 00:46:24,610
0,150 150,360 360,600 600,1170 1170,1290
would be to| whatever you
|你购买更多的 memcached 服务器，

1437
00:46:24,610 --> 00:46:25,690
0,240 240,480 480,720 720,960 960,1080
buy more {memcached - -}

1438
00:46:25,690 --> 00:46:27,370
0,630 900,1080 1080,1230 1230,1380 1380,1680
servers,| and just keep buying
|并继续购买更多的服务器，

1439
00:46:27,370 --> 00:46:28,000
0,180 180,270 270,510
more of them,|
|

1440
00:46:29,220 --> 00:46:30,260
0,720
and
这里有一个小问题，

1441
00:46:30,470 --> 00:46:31,340
0,240 240,450 450,660 660,780 780,870
{} that turns out to

1442
00:46:31,340 --> 00:46:33,980
0,360 360,480 480,930 930,1650 2070,2640
be {} slightly problematic, {}|
|

1443
00:46:33,980 --> 00:46:35,690
0,570 570,1110 1110,1440 1440,1530 1530,1710
and one reason {that -}
这里有问题的一个原因是，

1444
00:46:35,690 --> 00:46:37,610
0,270 270,420 420,1020 1020,1290 1290,1920
that is problematic is,| because
|因为这些前端与每个 memcache 服务器交互，

1445
00:46:37,730 --> 00:46:39,830
0,360 360,630 630,840 840,1230 1260,2100
{} these {frontends -} talk

1446
00:46:39,890 --> 00:46:42,620
0,810 840,1530 1530,1830 1830,2070 2070,2730
to basically every {memcache -}

1447
00:46:43,190 --> 00:46:44,320
0,660
server,|
|

1448
00:46:46,020 --> 00:46:47,430
0,150 150,360 360,750 780,990 990,1410
and so they,| {you,know} almost
所以它们，|至少在写入方面，

1449
00:46:47,430 --> 00:46:49,650
0,360 360,750 750,1230 1230,1650 1650,2220
at least for writes, {}|
|

1450
00:46:49,680 --> 00:46:51,300
0,120 120,690 690,900 900,1260 1260,1620
{you,know} {we,know} that TCP {connections
我们知道 TCP 连接打开，

1451
00:46:51,300 --> 00:46:52,830
0,60 60,450 690,1200 1200,1320 1320,1530
-} open,| and so there's
|所以这里有大量的 TCP 连接，

1452
00:46:52,830 --> 00:46:54,330
0,60 60,750 750,1050 1050,1140 1140,1500
a large number of TCP

1453
00:46:54,330 --> 00:46:55,180
0,630
connections,|
|

1454
00:46:55,750 --> 00:46:58,420
0,630 1020,1440 1440,1590 1590,2250 2280,2670
{ -} and furthermore, as
此外，正如我之前所说的，

1455
00:46:58,420 --> 00:46:59,830
0,330 330,1080 1080,1140 1200,1230 1230,1410
we, {} as I said

1456
00:46:59,830 --> 00:47:01,360
0,450 450,720 720,1110 1110,1200 1200,1530
before| is actually a particular
|如果一个键命中很多，

1457
00:47:01,360 --> 00:47:05,230
0,480 510,1230 1230,1800 2010,2850 2910,3870
key hard, {hit,hard},| then the,
|这没有被分片解决，

1458
00:47:05,650 --> 00:47:06,780
0,870
{}

1459
00:47:07,050 --> 00:47:08,580
0,240 240,390 390,810 810,1350 1350,1530
that doesn't really solved by

1460
00:47:08,580 --> 00:47:09,340
0,450
shard,|
|

1461
00:47:09,980 --> 00:47:11,150
0,330 330,450 450,840 840,1020 1020,1170
so you can buy more
你可以买更多的机器，

1462
00:47:11,150 --> 00:47:12,350
0,450 450,630 630,810 810,960 960,1200
machines,| but there's that one
|但是一个热键在一台机器里，

1463
00:47:12,350 --> 00:47:13,280
0,270 270,570 570,690 690,870 870,930
keys hot and lives in

1464
00:47:13,280 --> 00:47:14,150
0,150 150,480 480,600 600,810 810,870
one machine,| that actually is
|这不会提高你的性能。

1465
00:47:14,150 --> 00:47:15,050
0,120 120,240 240,450 450,780 780,900
not going to improve your

1466
00:47:15,050 --> 00:47:16,260
0,750
performance.|
|

1467
00:47:16,650 --> 00:47:18,420
0,540 570,750 750,1020 1020,1470 1500,1770
So their next step in
所以，他们在性能改进方面的下一步，

1468
00:47:18,420 --> 00:47:21,600
0,270 270,630 750,1620 1680,2550 2550,3180
terms of performance {} improvement|
|

1469
00:47:21,840 --> 00:47:23,820
0,300 300,450 450,900 900,1620 1620,1980
is to actually replicate with
是在单个数据中心内进行复制。

1470
00:47:23,820 --> 00:47:26,340
0,840 840,960 960,1740 1770,2070 2070,2520
inside a single data center.|
|

1471
00:47:26,640 --> 00:47:28,200
0,480
So,
更高的性能，这就是集群的概念，

1472
00:47:28,930 --> 00:47:30,660
0,240 240,1140
more performance,

1473
00:47:31,560 --> 00:47:32,430
0,150 150,300 300,390 390,570 570,870
so this is this idea

1474
00:47:32,430 --> 00:47:34,740
0,60 60,600
of clusters,|
|

1475
00:47:35,810 --> 00:47:36,740
0,150 150,270 270,330 330,720 720,930
and this is really a
这是一个关于复制的故事。

1476
00:47:36,740 --> 00:47:38,760
0,300 300,540 540,1140
story about replication.|
|

1477
00:47:40,960 --> 00:47:42,250
0,450 450,630 630,870 870,1050 1050,1290
And so what they actually
所以他们做的是，

1478
00:47:42,250 --> 00:47:43,090
0,300 300,450 450,630 630,750 750,840
do is like,| if we
|如果我们查看单个数据中心，

1479
00:47:43,090 --> 00:47:43,960
0,150 150,240 240,300 300,630 630,870
look at a single data

1480
00:47:43,960 --> 00:47:44,760
0,480
center,|
|

1481
00:47:46,970 --> 00:47:49,070
0,210 210,1110 1110,1230 1230,1590 1590,2100
we got our storage layer,|
我们有自己的存储层，|

1482
00:47:53,400 --> 00:47:54,540
0,420 420,600 600,810 810,870 870,1140
and then within the storage
然后在存储层内，

1483
00:47:54,540 --> 00:47:55,280
0,450
layer,|
|

1484
00:47:55,510 --> 00:47:58,030
0,360 360,450 450,900 1080,1950 1950,2520
basically we're gonna replicate a
我们要复制一组前端，

1485
00:47:58,030 --> 00:47:59,320
0,180 180,270 270,1020
set of frontends,|
|

1486
00:47:59,780 --> 00:48:01,250
0,210 210,450 450,540 540,930 930,1470
so here's {} frontend layer,|
这是前端层，|

1487
00:48:01,550 --> 00:48:04,460
0,180 180,480 480,960 1230,2610 2610,2910
and here's our {memcache -}
这是我们的 memcache 层，

1488
00:48:04,460 --> 00:48:05,300
0,480
layer,|
|

1489
00:48:08,110 --> 00:48:09,820
0,300 300,480 480,720 720,1290
I'm gonna take that
我要把它复制多次，

1490
00:48:10,620 --> 00:48:13,720
0,210 210,930 1500,1890 1890,2460
and {just,replicate} multiple times,|
|

1491
00:48:15,720 --> 00:48:16,710
0,450 450,600 600,660 660,900 900,990
and {they -} call this
他们称为集群。

1492
00:48:16,710 --> 00:48:17,940
0,60 60,630
a cluster.|
|

1493
00:48:21,040 --> 00:48:22,960
0,510 720,1320 1350,1560 1560,1770 1770,1920
And {} the reason this
这个好的原因是，

1494
00:48:22,960 --> 00:48:24,430
0,120 120,630 780,900 900,1050 1050,1470
is good you know is,|
|

1495
00:48:24,430 --> 00:48:26,080
0,270 270,600 600,960 960,1260 1260,1650
this actually deals deal well
很好地解决了，对热门键有好处，

1496
00:48:26,080 --> 00:48:27,430
0,390 420,720 720,900 900,1020 1020,1350
with, its good for popular

1497
00:48:27,430 --> 00:48:28,660
0,480
keys,|
|

1498
00:48:31,560 --> 00:48:32,430
0,150 150,450 450,660 660,750 750,870
{} popular key, it will
热门的键，它可能被复制到多个集群，

1499
00:48:32,430 --> 00:48:33,900
0,150 150,300 300,960 990,1110 1110,1470
now be replicated you know

1500
00:48:33,900 --> 00:48:36,990
0,150 150,630 630,990 990,1620 1980,3090
{} potentially multiple clusters,| and
|所以这很好，

1501
00:48:37,020 --> 00:48:39,060
0,750 750,960 960,1410 1410,1500 1500,2040
{} so that is nice,|
|

1502
00:48:39,330 --> 00:48:41,070
0,540 540,930 930,1200 1200,1650 1650,1740
{} second, it reduces the
第二，它减少了连接的数量，

1503
00:48:41,070 --> 00:48:42,680
0,210 210,300 300,1020
number of connections,|
|

1504
00:48:47,790 --> 00:48:48,990
0,390 390,570 570,870 870,960 960,1200
{} and this is actually
有多个原因为什么这很重要，

1505
00:48:48,990 --> 00:48:50,340
0,450 450,600 600,660 660,1080 1080,1350
particularly there are multiple reasons

1506
00:48:50,340 --> 00:48:53,100
0,180 180,480 480,1020 1290,2160 2160,2760
why this important,| {} it
|它避免了，他们所说的，

1507
00:48:53,100 --> 00:48:54,780
0,720 720,930 930,1050 1050,1290 1290,1680
avoids what they call the,|
|

1508
00:48:57,000 --> 00:48:58,980
0,270 270,420 420,720 720,1230 1230,1980
avoids {} {incast -} problems
避免 incast 拥塞问题，

1509
00:48:59,880 --> 00:49:04,120
0,210 210,540 540,1320
{incast -} congestion,|
|

1510
00:49:04,640 --> 00:49:05,870
0,300 300,300 300,540 540,900 900,1230
as I said before,| one
就像我之前说的，|其中一个前端必须获取 500 ，

1511
00:49:05,870 --> 00:49:07,790
0,60 60,210 210,510 510,1440 1440,1920
of these {frontends -} {}

1512
00:49:07,790 --> 00:49:10,130
0,120 120,270 270,360 360,960 990,2340
may have to retrieve 500,|
|

1513
00:49:10,130 --> 00:49:11,210
0,90 90,600 600,810 810,990 990,1080
{you,know} whatever hundred {} you
几十到上百的键，

1514
00:49:11,210 --> 00:49:12,860
0,540 660,1080 1080,1230 1230,1560 1560,1650
know tens to hundreds of

1515
00:49:12,860 --> 00:49:15,110
0,570 780,1650 1650,1950 1950,2130 2130,2250
keys,| {} and so it
|它会并行地发送它们，

1516
00:49:15,110 --> 00:49:17,000
0,180 180,570 570,990 1080,1260 1260,1890
will send them in parallel|
|

1517
00:49:17,000 --> 00:49:19,100
0,150 150,390 390,930 960,1530 1530,2100
to all the particular {}
到所有重要的 memcache ，

1518
00:49:19,130 --> 00:49:20,150
0,210 210,480 480,600 600,930 930,1020
{memcache -} there {important -},|
|

1519
00:49:20,150 --> 00:49:21,520
0,150 150,510 510,1080
they all respond,|
它们都会做出响应，|

1520
00:49:22,060 --> 00:49:23,380
0,660 660,900 900,990 990,1230 1230,1320
{} and of course you
当然，我们有很多的 memcache ，

1521
00:49:23,380 --> 00:49:24,820
0,120 120,630 720,1020 1020,1230 1230,1440
know we have many, many

1522
00:49:24,820 --> 00:49:27,160
0,570 600,1260 1260,1860 1950,2220 2220,2340
more {memcaches -},| we're going
|我们将会有更多的并行性，

1523
00:49:27,160 --> 00:49:28,540
0,90 90,300 300,570 570,750 750,1380
to have much more parallelism,|
|

1524
00:49:28,570 --> 00:49:29,530
0,210 210,300 300,720 720,810 810,960
{a,lot} of packets will come
很多包同时返回，

1525
00:49:29,530 --> 00:49:30,940
0,360 360,990 990,1080 1080,1170 1170,1410
back exactly at the same

1526
00:49:30,940 --> 00:49:32,800
0,480 660,870 870,990 990,1500 1500,1860
time,| they can easily {}
|它们可以很容易地进入队列，

1527
00:49:32,800 --> 00:49:36,160
0,810 810,1260 1260,1860 2280,3060 3090,3360
into {} queue,| {} queues
|队列超载或队列已满，

1528
00:49:36,160 --> 00:49:37,960
0,240 240,990 1020,1320 1320,1590 1590,1800
being overloaded or queues being

1529
00:49:37,960 --> 00:49:39,250
0,450 450,540 540,810 810,1080 1080,1290
full,| and therefore packets getting
|因此包被丢弃，

1530
00:49:39,250 --> 00:49:39,900
0,540
dropped,|
|

1531
00:49:40,480 --> 00:49:41,860
0,330 330,480 480,750 750,1020 1020,1380
{} and so by reducing
所以，通过减少连接数量，

1532
00:49:41,860 --> 00:49:42,760
0,60 60,240 240,300 300,750 750,900
the number of connections,| not
|不是每个前端都访问，

1533
00:49:42,760 --> 00:49:44,230
0,270 270,510 510,840 840,1170 1170,1470
actually every frontend talks to,|
|

1534
00:49:44,230 --> 00:49:45,640
0,90 90,630 630,900 900,1350 1350,1410
{you,know,reduces -} where responses are
减少回来的响应，

1535
00:49:45,640 --> 00:49:47,080
0,120 120,210 210,330 330,750 1020,1440
going to come back,| and
|我们避免了这个 incast 拥堵问题，

1536
00:49:47,080 --> 00:49:48,610
0,120 120,450 450,720 720,1080 1080,1530
we avoid this {} {incast

1537
00:49:48,610 --> 00:49:50,140
0,300 300,720 720,1110
-} congestion problem,|
|

1538
00:49:50,580 --> 00:49:51,810
0,150 150,270 270,870 960,1170 1170,1230
and in general, sort of
总的来说，这减轻了网络压力，

1539
00:49:51,810 --> 00:49:52,830
0,420 420,540 540,900 900,960 960,1020
reduce the pressure of the

1540
00:49:52,830 --> 00:49:55,380
0,510
network,|
|

1541
00:49:55,600 --> 00:49:57,160
0,150 150,360 360,870 870,1290 1290,1560
it's actually hard to build
很难建立具有双向带宽的网络，

1542
00:49:57,160 --> 00:49:58,960
0,450 450,570 570,1110 1140,1380 1380,1800
networks that have bi section

1543
00:49:58,960 --> 00:50:01,120
0,480 480,600 600,720 720,1470 1590,2160
bandwidth,| that could sustain a
|可以承受巨大的负载，

1544
00:50:01,120 --> 00:50:03,460
0,300 300,810 990,1590 1590,2100 2100,2340
huge load,| and here by
|这里通过使用复制，

1545
00:50:03,460 --> 00:50:05,260
0,180 180,270 270,720 720,1020 1020,1800
sort of making using replication,|
|

1546
00:50:05,380 --> 00:50:07,720
0,390 390,1530 1530,1620 1620,1890 1890,2340
basically network for one cluster
一个集群的网络很好地支持了这个集群。

1547
00:50:07,720 --> 00:50:08,620
0,210 210,390 390,480 480,750 750,900
really has to support that

1548
00:50:08,620 --> 00:50:10,440
0,210 210,780 930,1170 1170,1620
one cluster {} well.|
|

1549
00:50:17,110 --> 00:50:19,360
0,720 1170,1680 1710,2010 2010,2100 2100,2250
Now, now this is all
现在，这一切都很好，

1550
00:50:19,360 --> 00:50:20,410
0,420 450,570 570,870 870,930 930,1050
good,| of course you know
|当然，这个设计的缺点，

1551
00:50:20,410 --> 00:50:22,030
0,150 150,480 630,780 780,1560 1560,1620
this is the downside of

1552
00:50:22,030 --> 00:50:22,930
0,60 60,420 420,570 570,780 780,900
a design,| like this is
|也就是，

1553
00:50:22,930 --> 00:50:23,770
0,180 180,330 330,450 450,630 630,840
that,| if you have {unpopular
|如果你有不受欢迎的键，

1554
00:50:23,770 --> 00:50:25,930
0,420 420,990 1290,1800 1800,2040 2040,2160
-} keys,| {} there's {unpopular
|不受欢迎的键将被存储在多个区域，

1555
00:50:25,930 --> 00:50:26,800
0,270 270,420 420,540 540,720 720,870
-} keys is gonna get

1556
00:50:26,800 --> 00:50:29,950
0,600 630,1290 1560,2310 2310,2820 2820,3150
stored in multiple regions,| and
|基本上什么都不做，

1557
00:50:29,950 --> 00:50:31,210
0,570 570,690 690,780 780,930 930,1260
basically you know do nothing,|
|

1558
00:50:31,690 --> 00:50:33,430
0,360 360,570 570,810 810,1320 1320,1740
or {[] -} contribute to
或者[]对性能的提高做出贡献，

1559
00:50:33,430 --> 00:50:36,370
0,900 900,1050 1050,1770 2070,2670 2670,2940
improvement in performance,| and so
|所以，他们所做的是，

1560
00:50:36,370 --> 00:50:37,720
0,120 120,630 630,870 870,1020 1020,1350
in fact what they do

1561
00:50:37,720 --> 00:50:39,100
0,240 240,330 330,540 540,750 750,1380
is,| they have one additional
|他们还有一个额外的池，

1562
00:50:39,100 --> 00:50:40,660
0,240 240,420 420,1230 1230,1380 1380,1560
sort of pool that they

1563
00:50:40,660 --> 00:50:42,250
0,510 840,1110 1110,1200 1200,1380 1380,1590
have,| and they call this
|他们称为区域池，

1564
00:50:42,250 --> 00:50:43,440
0,180 180,630 630,1110
the regional pool,|
|

1565
00:50:46,010 --> 00:50:49,340
0,510 510,1230 1230,1440 1440,2130 2610,3330
and applications can decide {}|
应用程序可以决定|

1566
00:50:50,720 --> 00:50:52,100
0,210 210,990
to store
保存不是很受欢迎的键到区域池，

1567
00:50:52,480 --> 00:50:53,950
0,180 180,480 480,930 930,1110 1110,1470
{you,know} not so {} popular

1568
00:50:53,950 --> 00:50:55,780
0,630 690,1020 1020,1110 1110,1470 1470,1830
keys into the regional pool,|
|

1569
00:50:56,250 --> 00:50:57,900
0,330 330,600 600,900 900,990 990,1650
{} to stick it inside,|
把它放在里面，|

1570
00:50:57,960 --> 00:50:59,790
0,390 390,720 720,1080 1080,1350 1350,1830
{} and {} so the
所以这些，

1571
00:50:59,790 --> 00:51:02,160
0,390 390,540 540,540 2040,2220 2220,2370
these,| { - -} so
|所以它们不会在时间上跨所有集群复制，

1572
00:51:02,160 --> 00:51:04,680
0,810 840,960 960,1710 1710,1980 1980,2520
they, they don't are replicated

1573
00:51:04,680 --> 00:51:06,210
0,180 180,570 570,870 870,1020 1020,1530
in times across all clusters,|
|

1574
00:51:06,210 --> 00:51:06,840
0,150 150,240 240,330 330,450 450,630
so you can think about
你可以考虑区域池在多个集群之间共享，

1575
00:51:06,840 --> 00:51:08,280
0,60 60,420 420,750 750,960 960,1440
the regional pool being shared

1576
00:51:08,280 --> 00:51:10,650
0,480 600,1020 1020,1590 1800,2040 2040,2370
among multiple clusters,| and used
|用于不太受欢迎的键或不太频繁使用的键。

1577
00:51:10,650 --> 00:51:12,600
0,300 300,780 840,1170 1170,1620 1620,1950
for the less popular keys

1578
00:51:12,600 --> 00:51:14,340
0,180 180,330 330,990 990,1170 1170,1740
or less frequently used keys.|
|

1579
00:51:15,370 --> 00:51:16,380
0,720
Okay?|
好的?|

1580
00:51:17,900 --> 00:51:18,710
0,180 180,330 330,600 600,720 720,810
So is this going to
那么，这会对流行的键有帮助吗，

1581
00:51:18,710 --> 00:51:20,870
0,390 390,870 930,1320 1320,1860 1860,2160
help with {} popular keys,|
|

1582
00:51:20,870 --> 00:51:21,760
0,630
because
因为每个集群都会有自己的 memcache 。

1583
00:51:21,960 --> 00:51:24,510
0,540 600,1290 1320,2100 2100,2340 2340,2550
{} each cluster is gonna

1584
00:51:24,510 --> 00:51:27,090
0,270 270,450 450,870 870,1530 1650,2580
have its own memcache.| Yeah,
|是的，每个集群都有自己的 memcache ，

1585
00:51:27,090 --> 00:51:28,320
0,330 330,660 660,810 810,900 900,1230
every cluster has its own

1586
00:51:28,320 --> 00:51:29,420
0,510
memcache,|
|

1587
00:51:31,580 --> 00:51:33,350
0,570 570,690 690,810 810,960 960,1770
{} has his own frontends,|
有自己的前端，|

1588
00:51:33,380 --> 00:51:34,940
0,90 90,300 300,420 420,780 780,1560
{} has his own memcache,|
有自己的 memcache ，|

1589
00:51:37,720 --> 00:51:39,280
0,300 300,660 660,1290 1290,1380 1380,1560
and basically users you know|
基本上用户，|

1590
00:51:39,280 --> 00:51:42,310
0,480 510,840 840,930 930,1530 1740,3030
the users are basically {}
用户是负载均衡到所有这些集群的。

1591
00:51:42,610 --> 00:51:43,900
0,420 420,690 690,1020 1020,1140 1140,1290
load balance across all these

1592
00:51:43,900 --> 00:51:44,760
0,570
clusters.|
|

1593
00:51:45,890 --> 00:51:47,060
0,360 360,540 540,750 750,930 930,1170
But this still does not
但这仍然不能增加容量，对吗？

1594
00:51:47,060 --> 00:51:48,960
0,360 360,1050 1080,1500
increase capacity, right?|
|

1595
00:51:49,330 --> 00:51:51,220
0,240 240,540 540,1020 1020,1230 1230,1890
This not increase {} capacity,|
这没有增加容量，|

1596
00:51:51,220 --> 00:51:53,230
0,270 270,720 720,810 810,960 960,2010
{} if you want to
如果您想要增加容量，

1597
00:51:53,560 --> 00:51:56,410
0,180 180,540 540,1500 1500,1950 2490,2850
{} increase capacity,| the {}
|你，

1598
00:51:56,410 --> 00:51:59,440
0,900 1380,2130 2220,2370 2370,2670 2670,3030
you,| well, it increase capacity
|好的，它稍微增加了一些容量，

1599
00:51:59,440 --> 00:52:00,640
0,30 30,210 210,420 420,690 690,1200
a little bit, correct,| because
|因为所有不受欢迎的内容都不在额外的缓存，

1600
00:52:00,640 --> 00:52:01,750
0,180 180,300 300,780 780,990 990,1110
all the unpopular stuff is

1601
00:52:01,750 --> 00:52:03,010
0,240 240,450 450,750 750,1110 1110,1260
not being extra cache,| and
|并被困在区域池中，

1602
00:52:03,010 --> 00:52:04,150
0,270 270,360 360,450 450,810 810,1140
stuck in the regional pool,|
|

1603
00:52:05,560 --> 00:52:06,820
0,480 480,600 600,750 750,1110 1110,1260
and so that space {is,now}
所以，这些空间现在可以存储其他键。

1604
00:52:06,820 --> 00:52:07,960
0,150 150,330 330,480 480,780 780,1140
{free -} to actually store

1605
00:52:07,960 --> 00:52:09,600
0,210 210,690
other keys.|
|

1606
00:52:14,490 --> 00:52:15,990
0,330 330,420 420,930 930,1050 1050,1500
So to avoid {incast -}
所以为了避免 incast 拥塞，

1607
00:52:15,990 --> 00:52:17,910
0,870 900,1020 1020,1170 1170,1470 1470,1920
congestion,| they would also reduce
|它们还会减少每个集群的分片数量，对吗？

1608
00:52:17,910 --> 00:52:19,410
0,90 90,360 360,480 480,1230 1260,1500
the number of shards per

1609
00:52:19,410 --> 00:52:21,960
0,660 690,1140 1290,1620 1620,1890 1890,2550
cluster, right?| Yeah, {} don't
|是的，不增加，他们不会增加它，

1610
00:52:21,960 --> 00:52:23,130
0,330 330,510 510,720 720,990 990,1170
increase, they don't grow it,|
|

1611
00:52:25,090 --> 00:52:26,170
0,120 120,510 510,750 750,960 960,1080
the alternative plan correct was
替代方案不是引入集群，

1612
00:52:26,170 --> 00:52:27,970
0,240 240,660 660,1260 1380,1500 1500,1800
not introduce clusters,| but basically
|但会继续增加 memcache 分片，

1613
00:52:27,970 --> 00:52:31,030
0,270 270,960 960,1890 2010,2400 2400,3060
keep growing the {memcache's -}

1614
00:52:31,450 --> 00:52:32,620
0,420 420,540 540,630 630,900 900,1170
shards,| with the {number,of} shards
|在单个 memcache 中的分片数量，

1615
00:52:32,620 --> 00:52:34,720
0,90 90,120 120,810 1200,1530 1530,2100
in a single {memcache -},|
|

1616
00:52:35,900 --> 00:52:37,100
0,600 600,750 750,810 810,990 990,1200
and you know that has
它有自己的限制。

1617
00:52:37,100 --> 00:52:38,480
0,150 150,300 300,1200
its own limitations.|
|

1618
00:52:39,830 --> 00:52:41,180
0,270 270,570 570,780 780,1050
Makes sense, thank you.|
理解了，谢谢。|

1619
00:52:46,640 --> 00:52:50,720
0,750 1800,2340 3030,3600 3630,3900 3900,4080
Okay, well, so this sort
好的，这是基本的设计，

1620
00:52:50,720 --> 00:52:53,690
0,90 90,810 840,1680 1680,2310 2430,2970
of the base design,| except
|除了他们必须解决的各种各样的性能挑战，

1621
00:52:53,690 --> 00:52:54,410
0,150 150,360 360,480 480,660 660,720
there are all kinds of

1622
00:52:54,410 --> 00:52:56,300
0,360 360,960 960,1410 1410,1650 1650,1890
performance challenges, that they had

1623
00:52:56,300 --> 00:52:58,190
0,270 270,900 1170,1620 1620,1710 1710,1890
to resolve,| most of these
|大多数这些性能挑战必须解决，

1624
00:52:58,190 --> 00:52:59,960
0,390 390,1080 1260,1410 1410,1500 1500,1770
performance challenges { -} really

1625
00:52:59,960 --> 00:53:01,280
0,180 180,270 270,660 660,1200 1200,1320
had to do with, {}|
|

1626
00:53:01,280 --> 00:53:02,240
0,0 510,690 690,750 750,870 870,960
I think the way to
我认为考虑的方式是保护数据库。

1627
00:53:02,240 --> 00:53:03,230
0,150 150,390 390,510 510,930 930,990
think about is protecting the

1628
00:53:03,230 --> 00:53:04,060
0,720
database.|
|

1629
00:53:04,710 --> 00:53:05,700
0,690

1630
00:53:06,240 --> 00:53:07,460
0,630

1631
00:53:14,120 --> 00:53:15,020
0,600

1632
00:53:19,790 --> 00:53:20,900
0,450

1633
00:53:22,270 --> 00:53:23,140
0,210 210,360 360,510 510,660 660,870
So, {} like go back
所以，回到这张图片，

1634
00:53:23,140 --> 00:53:24,430
0,90 90,240 240,810 810,1050 1050,1290
to this picture, correct,| we
|我们现在的设计显然能支持每秒数十亿次请求，

1635
00:53:24,430 --> 00:53:26,500
0,150 150,360 360,1110 1380,1950 1950,2070
have now design apparently to

1636
00:53:26,500 --> 00:53:28,420
0,630 630,1050 1050,1380 1380,1470 1470,1920
support billions requests per second,|
|

1637
00:53:29,340 --> 00:53:31,530
0,960 960,1620 1620,1800 1800,1860 1860,2190
{} and but the storage
但是存储层本身是分片的，

1638
00:53:31,530 --> 00:53:33,480
0,210 210,930 1080,1620 1620,1740 1740,1950
layer itself {} you know

1639
00:53:33,480 --> 00:53:35,550
0,510 780,1200 1200,1530 1530,1980 1980,2070
{is,sharded},| because certainly not you
|因为肯定不能承受每秒支持数十亿次请求，

1640
00:53:35,550 --> 00:53:37,770
0,150 150,1350 1350,1740 1740,2130 2130,2220
know {sustain,billions -} requests per

1641
00:53:37,770 --> 00:53:39,840
0,300 840,1500 1500,1800 1800,1950 1950,2070
second,| and it would be
|这会是一个灾难，

1642
00:53:39,840 --> 00:53:41,580
0,120 120,960 1020,1320 1320,1680 1680,1740
a disaster,| {} if for
|假设所有的 memcache 都以这样或那样的方式失败了，

1643
00:53:41,580 --> 00:53:42,810
0,690 690,930 930,1050 1050,1140 1140,1230
example, let's say all the

1644
00:53:42,810 --> 00:53:43,950
0,510 510,780 780,840 840,990 990,1140
memcaches failed in some way

1645
00:53:43,950 --> 00:53:45,480
0,30 30,600 780,960 960,1140 1140,1530
or another| or whole cluster
|或整个集群出现故障，

1646
00:53:45,480 --> 00:53:47,070
0,450 600,990 990,1200 1200,1320 1320,1590
failed,| and all the {frontends
|所有前端都会命中存储服务器，

1647
00:53:47,070 --> 00:53:47,910
0,240 240,330 330,570 570,780 780,840
-} {you,know} would hit the

1648
00:53:47,910 --> 00:53:49,860
0,330 330,900 1200,1590 1590,1860 1860,1950
storage servers,| {} then {you,know
|那么存储服务器会崩溃，

1649
00:53:49,860 --> 00:53:50,670
0,120 120,210 210,270 270,510 510,810
- -} the storage servers

1650
00:53:50,670 --> 00:53:52,380
0,150 150,360 360,870 900,1320 1470,1710
would fail over,| {you,know} couldn't
|不能处理这种负载，

1651
00:53:52,380 --> 00:53:53,460
0,240 240,360 360,510 510,570 570,1080
handle that kind of load,|
|

1652
00:53:53,670 --> 00:53:54,870
0,450 450,570 570,900 930,1140 1140,1200
and so they got to
所以他们必须非常非常小心做任何事情，

1653
00:53:54,870 --> 00:53:56,610
0,90 90,360 360,600 600,1110 1350,1740
be very very careful {}

1654
00:53:56,610 --> 00:53:58,980
0,330 330,930 930,1230 1500,2160 2160,2370
with actually {} putting, {}

1655
00:53:58,980 --> 00:54:01,080
0,270 270,750 810,1050 1050,1290 1290,2100
doing anything,| {} that requires
|需要在存储服务器上加载更多负载（的事情）。

1656
00:54:01,110 --> 00:54:02,340
0,570 570,810 810,870 870,930 930,1230
more load on the storage

1657
00:54:02,340 --> 00:54:02,800
0,270
servers.|
|

1658
00:54:03,890 --> 00:54:06,020
0,480 1380,1530 1530,1770 1770,1830 1830,2130
So, so one for example
所以，比如一个挑战，

1659
00:54:06,020 --> 00:54:06,980
0,450 450,630 630,750 750,810 810,960
challenge,| I'm going to talk
|我要谈的是，

1660
00:54:06,980 --> 00:54:07,910
0,180 180,270 270,480 480,540 540,930
about the number of them|
|

1661
00:54:08,210 --> 00:54:09,230
0,300 300,600 600,690 690,870 870,1020
{} is to bring up
建立一个新的集群，

1662
00:54:09,230 --> 00:54:11,200
0,90 90,420 420,990
a new cluster,|
|

1663
00:54:15,280 --> 00:54:16,390
0,300 300,540 540,810 810,930 930,1110
{you,know} easy way to bring
建立一个新集群的简单方法，

1664
00:54:16,390 --> 00:54:17,350
0,120 120,150 150,330 330,810 810,960
up a new cluster| would
|就是建立一个集群，

1665
00:54:17,350 --> 00:54:19,060
0,180 180,390 390,900 1200,1320 1320,1710
be just to you know

1666
00:54:19,330 --> 00:54:21,100
0,660 660,720 720,1470 1470,1710 1710,1770
build a cluster,| turn the
|打开机器，安装软件，然后就完成了，

1667
00:54:21,100 --> 00:54:22,960
0,360 360,870 960,1440 1440,1800 1800,1860
machines on, {} installed the

1668
00:54:22,960 --> 00:54:25,270
0,720 870,1530 1530,1740 1740,1830 1830,2310
software and then be done,|
|

1669
00:54:25,630 --> 00:54:27,940
0,690 690,1440 1470,1920 1920,2220 2220,2310
{} and basically rely on
基于这样一个事实，

1670
00:54:27,940 --> 00:54:29,110
0,90 90,450 450,630 630,720 720,1170
the fact,| that you know
|如果数据不在缓存中，

1671
00:54:29,200 --> 00:54:30,520
0,630 630,870 870,1050 1050,1140 1140,1320
if the data is not

1672
00:54:30,520 --> 00:54:31,840
0,90 90,150 150,510 510,1110 1110,1320
in the cache,| you'll have
|你会不命中，

1673
00:54:31,840 --> 00:54:33,220
0,570 750,930 930,1050 1050,1230 1230,1380
miss| and the miss will
|未命中会进入数据库，

1674
00:54:33,220 --> 00:54:34,690
0,120 120,240 240,330 330,990 990,1470
go to the database,| actually
|收集必要的数据，

1675
00:54:34,690 --> 00:54:35,770
0,60 60,210 210,480 480,570 570,1080
you know collect the necessary

1676
00:54:35,770 --> 00:54:36,260
0,330
data,|
|

1677
00:54:37,080 --> 00:54:39,660
0,660 1170,1800 2100,2400 2400,2520 2520,2580
{} and {} you know
这种设计有什么问题吗？

1678
00:54:39,660 --> 00:54:40,470
0,240 240,330 330,570 570,750 750,810
what's the problem about the

1679
00:54:40,470 --> 00:54:41,500
0,150 150,240 240,720
kind of design?|
|

1680
00:54:45,510 --> 00:54:46,500
0,210 210,450 450,660 660,750 750,990
It's gonna have a lot
它会有很多缓存未命中，

1681
00:54:46,500 --> 00:54:47,970
0,150 150,510 510,930 930,1230 1230,1470
of cache misses,| because there's
|因为缓存里什么都没有。

1682
00:54:47,970 --> 00:54:49,950
0,330 330,450 450,510 510,1080 1650,1980
nothing in the cache.| {Yeah\,,for}
|是的，假设你有一个集群，

1683
00:54:49,950 --> 00:54:51,090
0,300 300,480 480,660 660,810 810,1140
example, let's say you have

1684
00:54:51,180 --> 00:54:52,580
0,210 210,330 330,540 540,1140
you had one cluster,|
|

1685
00:54:52,890 --> 00:54:53,670
0,210 210,330 330,420 420,480 480,780
{and,you} {had -} the second
你有第二个集群，

1686
00:54:53,670 --> 00:54:55,200
0,510 540,870 870,1020 1020,1230 1230,1530
cluster, right,| you move half
|你把一半的用户移动到第二个集群，

1687
00:54:55,200 --> 00:54:56,130
0,90 90,240 240,720 720,840 840,930
of your users to the

1688
00:54:56,130 --> 00:54:57,320
0,270 270,780
second cluster,

1689
00:54:57,540 --> 00:54:59,280
0,150 150,330 330,900 900,1260 1260,1740
right,| then {50%,of -} your
|那么 50% 的请求将在缓存中丢失，

1690
00:54:59,580 --> 00:55:01,290
0,1230 1230,1320 1320,1440 1440,1500 1500,1710
requests are going to miss

1691
00:55:01,290 --> 00:55:02,520
0,120 120,180 180,780 930,1140 1140,1230
in the cache,| and they're
|它们会命中数据库，

1692
00:55:02,520 --> 00:55:03,760
0,120 120,270 270,330 330,1080
gonna hit the database,|
|

1693
00:55:03,980 --> 00:55:05,060
0,300 300,360 360,720 720,840 840,1080
and the database will fall
数据库就会崩溃。

1694
00:55:05,060 --> 00:55:06,260
0,390 420,900
over, correct.|
|

1695
00:55:07,070 --> 00:55:08,630
0,180 180,330 330,630 630,1290 1320,1560
So how do they deal
那么，他们是如何处理这一问题的呢？

1696
00:55:08,630 --> 00:55:09,360
0,120 120,510
with this?|
|

1697
00:55:11,700 --> 00:55:12,760
0,810
Gutter?|
Gutter ？|

1698
00:55:13,400 --> 00:55:14,630
0,510 510,660 660,750 750,1050 1080,1230
No, not the Gutter, this
不，不是 Gutter ，这是。

1699
00:55:14,630 --> 00:55:15,540
0,150 150,570
is the.|
|

1700
00:55:17,030 --> 00:55:19,310
0,210 210,780 780,930 930,1590 1800,2280
I think they were making
我认为他们让新集群

1701
00:55:19,310 --> 00:55:21,350
0,120 120,300 300,1260 1260,1530 1530,2040
the new cluster| read some
|从旧集群的缓存中读取一些条目。

1702
00:55:21,350 --> 00:55:23,360
0,990 1020,1230 1230,1350 1350,1650 1650,2010
entries from the cache of

1703
00:55:23,390 --> 00:55:26,120
0,210 210,420 420,1380 1470,2070 2220,2730
an old cluster.| {Yeah\,,gets,in,the} new
|是的，从新的集群获取，

1704
00:55:26,120 --> 00:55:27,480
0,630
cluster,|
|

1705
00:55:27,880 --> 00:55:28,930
0,450 450,600 600,720 720,900 900,1050
{} if they miss {in,the}
如果它们在新集群中未命中，

1706
00:55:28,930 --> 00:55:29,890
0,150 150,420 420,660 660,840 840,960
new cluster,| they go to
|它们会转向旧的集群，从已经存在的那个，

1707
00:55:29,890 --> 00:55:30,960
0,90 90,300 300,780
the old cluster

1708
00:55:31,210 --> 00:55:34,140
0,360 360,450 450,840 840,1140
from an existing one,|
|

1709
00:55:36,250 --> 00:55:37,980
0,180 180,630 660,870 870,1410
and then they set
然后它们在新集群中设置，

1710
00:55:38,890 --> 00:55:42,550
0,390 390,840 870,1140 1140,1680 3420,3660
in the new cluster,| so
|所以考虑的一种方式是，

1711
00:55:42,550 --> 00:55:43,510
0,390 390,570 570,690 690,810 810,960
basically one way to think

1712
00:55:43,510 --> 00:55:45,070
0,360 360,600 600,930 930,1260 1260,1560
about is,| they fill up
|它们填充新的集群或预热新的集群，

1713
00:55:45,100 --> 00:55:46,960
0,180 180,330 330,840 840,1260 1290,1860
a new cluster or warm

1714
00:55:46,960 --> 00:55:49,570
0,120 120,180 180,360 360,960 1230,2610
up a new cluster,| by
|通过从现有集群中读取，

1715
00:55:49,600 --> 00:55:51,910
0,750 930,1440 1440,1530 1530,1890 1890,2310
reading from an existing cluster,|
|

1716
00:55:52,060 --> 00:55:53,110
0,240 240,360 360,480 480,750 750,1050
and so that maybe increase
所以，这可能会稍微增加现有集群上的负载，

1717
00:55:53,110 --> 00:55:54,370
0,90 90,600 600,780 780,870 870,1260
the load on an existing

1718
00:55:54,370 --> 00:55:55,480
0,300 300,360 360,570 570,900
cluster a little bit,|
|

1719
00:55:55,600 --> 00:55:57,220
0,390 390,510 510,900 900,1230 1230,1620
but at least don't actually
但至少不会给数据库带来太大压力，

1720
00:55:57,220 --> 00:55:58,120
0,180 180,270 270,450 450,510 510,900
put a lot of pressure

1721
00:55:58,120 --> 00:55:59,140
0,90 90,150 150,810
on the database,|
|

1722
00:56:00,080 --> 00:56:01,880
0,330 330,480 480,540 540,1020 1050,1800
{as,we,see} is the second, {}|
我们稍后会看到，|

1723
00:56:02,000 --> 00:56:03,650
0,210 210,450 450,960 960,1260 1260,1650
that also introduces again some
这再次带来了一些一致性问题，

1724
00:56:03,920 --> 00:56:06,680
0,750 750,1320 1500,2160 2160,2670 2670,2760
consistency issues,| {} and you
|我们稍后会看到这个。

1725
00:56:06,680 --> 00:56:07,550
0,270 270,570 570,720 720,840 840,870
know we'll see that a

1726
00:56:07,550 --> 00:56:08,440
0,150 150,270 270,630
little bit later.|
|

1727
00:56:09,060 --> 00:56:09,860
0,510
Okay?|
好的？|

1728
00:56:10,070 --> 00:56:11,330
0,180 180,360 360,990 990,1110 1110,1260
So that's one you know
所以这是一个解决性能挑战的例子，

1729
00:56:11,330 --> 00:56:13,640
0,540 540,660 660,1050 1050,1350 1350,2310
example of performance challenge the

1730
00:56:13,700 --> 00:56:16,220
0,180 180,840 1380,1950 2220,2340 2340,2520
the address,| {} the other
|另一个性能是在受欢迎的术语，

1731
00:56:16,220 --> 00:56:19,160
0,600 600,720 720,1080 1080,1620 2580,2940
{performance,is} {} popular term,| used
|在很多上下文中，称为惊群问题，

1732
00:56:19,160 --> 00:56:20,390
0,60 60,510 510,990 990,1140 1140,1230
in many contexts, that are

1733
00:56:20,390 --> 00:56:22,100
0,300 300,360 360,810 810,1170 1170,1710
called the thundering herd problem,|
|

1734
00:56:25,460 --> 00:56:26,930
0,240 240,330 330,720 720,990 990,1470
what's the thundering herd problem?|
什么是惊群问题？|

1735
00:56:31,070 --> 00:56:32,030
0,240 240,480 480,660 660,780 780,960
I guess when there are
我想，当有大量的读写操作

1736
00:56:32,030 --> 00:56:34,610
0,90 90,300 300,1050 1890,2370 2370,2580
a lot of writes and

1737
00:56:34,610 --> 00:56:37,010
0,690 870,1830 1830,1920 1920,2040 2040,2400
reads| approximately at the same
|大致同时发生，

1738
00:56:37,010 --> 00:56:38,300
0,510 510,870 870,1110 1110,1230 1230,1290
time,| and because there are
|因为有大量的写操作，

1739
00:56:38,300 --> 00:56:40,310
0,60 60,300 300,540 870,1800 1800,2010
a lot of writes,| the
|数据将多次失效，

1740
00:56:40,310 --> 00:56:43,160
0,300 300,480 480,630 630,1650 2580,2850
data will be invalidated many

1741
00:56:43,160 --> 00:56:45,350
0,570 660,1200 1200,1320 1320,1980 1980,2190
times,| and the database will
|数据库将受到请求的攻击。

1742
00:56:45,350 --> 00:56:49,250
0,420 990,1740 1740,2070 2100,2670 2670,3900
be assaulted with request.| Yeah,
|是的，你可以让它变得简单，

1743
00:56:49,250 --> 00:56:50,270
0,270 270,360 360,480 480,720 720,1020
you can make it simpler,|
|

1744
00:56:50,270 --> 00:56:52,880
0,330 330,810 810,1170 2220,2520 2520,2610
{like,a} single write cause an
单次写入导致一个键无效，

1745
00:56:52,880 --> 00:56:54,290
0,570 570,630 630,690 690,1050 1080,1410
invalidation of a key, right,|
|

1746
00:56:54,850 --> 00:56:57,670
0,570 630,1350 1380,2160 2160,2430 2430,2820
{} and anybody, any client
任何在它之后读取键的客户端，

1747
00:56:57,670 --> 00:56:58,900
0,150 150,450 450,720 720,930 930,1230
that reads key right after

1748
00:56:58,900 --> 00:56:59,800
0,90 90,420 420,570 570,690 690,900
it,| so you could have
|所以，可能会出现以下情况，

1749
00:56:59,800 --> 00:57:01,180
0,60 60,330 330,960 1140,1260 1260,1380
the following situation,| you have
|你有一个非常受欢迎的键，

1750
00:57:01,180 --> 00:57:02,410
0,60 60,300 300,540 540,870 870,1230
a very very popular key,|
|

1751
00:57:02,620 --> 00:57:05,560
0,960 1770,2040 2040,2490 2490,2550 2550,2940
the you invalidate the key,|
你使键失效，|

1752
00:57:05,590 --> 00:57:06,370
0,150 150,240 240,480 480,540 540,780
so you delete the key
所以你从缓存中删除键，

1753
00:57:06,370 --> 00:57:09,280
0,150 150,210 210,720 870,1890 1920,2910
from the cache,| all the
|所有在前端遇到流行键的机器

1754
00:57:10,150 --> 00:57:11,320
0,600 600,720 720,810 810,900 900,1170
machines are on the {frontends

1755
00:57:11,320 --> 00:57:13,330
0,420 420,960 960,1260 1260,1590 1590,2010
-} that meet popular key|
|

1756
00:57:13,420 --> 00:57:14,230
0,210 210,300 300,480 480,540 540,810
{} will do a get
会执行一次获取那个键，

1757
00:57:14,230 --> 00:57:15,610
0,120 120,270 270,690 900,1200 1200,1380
on that key,| all get
|所有都得到 nil ，

1758
00:57:15,610 --> 00:57:17,470
0,270 270,780 840,1380 1380,1680 1680,1860
back nil,| and then they're
|然后它们都想从数据库中读取 SELECT ，

1759
00:57:17,470 --> 00:57:19,030
0,180 180,360 360,720 720,1140 1140,1560
all {want,to} like read SELECT

1760
00:57:19,030 --> 00:57:20,260
0,180 180,240 240,750 750,1110
from the database, correct,|
|

1761
00:57:20,930 --> 00:57:21,950
0,330 330,630 630,750 750,870 870,1020
and that you know might
这可能给数据库带来很大的压力，

1762
00:57:21,950 --> 00:57:23,840
0,480 480,570 570,780 780,1290 1530,1890
cost you know they put

1763
00:57:23,840 --> 00:57:24,410
0,30 30,180 180,240 240,510 510,570
a lot of pressure on

1764
00:57:24,410 --> 00:57:26,780
0,60 60,750 1170,1680 1680,2220 2220,2370
the database,| {} so, {}
|所以，他们想要避免这个问题，

1765
00:57:26,780 --> 00:57:27,770
0,180 180,360 360,570 570,840 840,990
they want to avoid that

1766
00:57:27,770 --> 00:57:28,940
0,810 810,960 960,1050 1050,1110 1110,1170
problem,| so how do they
|那么他们如何做的，

1767
00:57:28,940 --> 00:57:29,880
0,150 150,660
do that,|
|

1768
00:57:30,130 --> 00:57:31,330
0,210 210,300 300,690 690,1050 1050,1200
how do they avoid that
他们如何避免这个问题？

1769
00:57:31,330 --> 00:57:32,060
0,420
problem?|
|

1770
00:57:33,080 --> 00:57:37,970
0,300 300,660 660,1410 1470,2130 4350,4890
They used leases.| Yeah, {exactly\,,go,ahead},
他们用了租约。|是的，没错，继续，多说一点。

1771
00:57:38,060 --> 00:57:39,650
0,720 720,840 840,1110 1110,1260 1260,1590
{say,more}.| Yeah, I think they
|是的，我想他们给了一段时间，

1772
00:57:39,650 --> 00:57:41,750
0,210 210,480 480,1170 1170,1650 1680,2100
give like a time,| like
|为用户指定的键，

1773
00:57:41,750 --> 00:57:44,300
0,210 210,480 480,1170 1170,1710 2010,2550
for key specific for for

1774
00:57:44,300 --> 00:57:45,710
0,120 120,750 750,1020 1020,1230 1230,1410
the user,| and then like
|然后在某个时刻，

1775
00:57:45,710 --> 00:57:47,600
0,450 450,690 690,1410 1410,1800 1800,1890
some like sometime,| what I
|据我所知，就像一把锁，

1776
00:57:47,600 --> 00:57:48,680
0,480 480,540 540,720 720,840 840,1080
understood, it was like kind

1777
00:57:48,680 --> 00:57:49,610
0,90 90,180 180,450 450,570 570,930
of a lock,| and then
|如果另一个用户试图使用它，

1778
00:57:50,000 --> 00:57:52,340
0,1050 1050,1200 1200,1620 1620,2010 2010,2340
like if another user tries

1779
00:57:52,340 --> 00:57:54,710
0,360 510,960 1110,1470 1470,1710 2010,2370
to to use it,| they
|它们会等待，

1780
00:57:54,710 --> 00:57:55,760
0,120 120,360 360,750 750,900 900,1050
would like wait| and then
|然后希望它能足够快地更新，

1781
00:57:55,760 --> 00:57:57,350
0,600 600,690 690,840 840,1020 1020,1590
hopefully it will be updated

1782
00:57:57,350 --> 00:57:58,460
0,360 360,630 630,810 810,960 960,1110
fast enough,| so that in
|在下一次重试时，他们就会得到它。

1783
00:57:58,460 --> 00:57:59,960
0,90 90,420 420,810 810,1140 1140,1500
the next retry, they'll {get,it}.|
|

1784
00:58:02,770 --> 00:58:04,180
0,180 180,270 270,540 540,900 930,1410
If you do a get,
如果你执行获取，你会获得 nil ，

1785
00:58:04,180 --> 00:58:05,580
0,150 150,300 300,510 510,1020
you get nil back,|
|

1786
00:58:06,310 --> 00:58:08,140
0,210 210,360 360,480 480,1110 1110,1830
you get two situations,| either
你有两种情况，|要么你获取一个租约，

1787
00:58:08,170 --> 00:58:09,780
0,210 210,390 390,420 420,960
you've got a lease,

1788
00:58:10,920 --> 00:58:12,390
0,420 420,540 540,870 870,1110 1110,1470
right,| the first line basically
|第一行没有得到和未命中，

1789
00:58:12,390 --> 00:58:13,680
0,150 150,420 420,720 720,810 810,1290
that doesn't get and misses,|
|

1790
00:58:13,680 --> 00:58:14,700
0,90 90,210 210,390 390,810 810,1020
you know gets release from
从 memcached 中获取释放，

1791
00:58:14,700 --> 00:58:16,440
0,180 180,450 450,870 1230,1590 1590,1740
{memcached - -},| and that
|而 memcached 至少给你更新的权限，

1792
00:58:16,440 --> 00:58:18,120
0,1020 1020,1320 1320,1500 1500,1560 1560,1680
memcached {at,least} gives you the

1793
00:58:18,120 --> 00:58:20,310
0,570 570,720 720,1320 1770,1920 1920,2190
right to update| or tells
|或者告诉客户端，

1794
00:58:20,310 --> 00:58:21,120
0,90 90,450 450,690 690,750 750,810
the clients,| like you know
|比如你要负责更新，

1795
00:58:21,120 --> 00:58:22,200
0,180 180,690 690,810 810,990 990,1080
you're responsible for doing the

1796
00:58:22,200 --> 00:58:22,960
0,510
update,|
|

1797
00:58:23,160 --> 00:58:25,920
0,840 900,2010 2010,2220 2220,2340 2340,2760
and {} if you don't,|
如果你不这么做，|

1798
00:58:25,950 --> 00:58:26,940
0,150 150,270 270,390 390,600 600,990
you know the first one,|
你知道第一个，|

1799
00:58:27,060 --> 00:58:29,640
0,690 690,690 1770,2130 2130,2310 2310,2580
then {} you get a
你会收到一条重试消息或结果，

1800
00:58:29,670 --> 00:58:31,900
0,420 420,540 540,900 900,1500
basically a retry message

1801
00:58:32,620 --> 00:58:34,180
0,660 660,810 810,990 990,1290 1290,1560
{or,result},| and that basically tells
|这告诉客户端，你应该尽快重试，

1802
00:58:34,180 --> 00:58:35,110
0,60 60,450 450,630 630,630 630,930
the client like oh you

1803
00:58:35,110 --> 00:58:36,670
0,180 180,570 570,690 690,1260 1260,1560
should retry it soon,| not
|不会立即出现，可能会扩散一点，

1804
00:58:36,670 --> 00:58:38,200
0,570 570,780 780,1020 1020,1260 1260,1530
immediately and maybe spread around

1805
00:58:38,200 --> 00:58:39,520
0,60 60,240 240,510 900,1050 1050,1320
a little bit,| they probably
|他们可能会做一些二进制备份类型的事情，

1806
00:58:39,520 --> 00:58:41,290
0,90 90,540 600,1140 1140,1560 1560,1770
do some binary backup type

1807
00:58:41,290 --> 00:58:43,570
0,300 300,690 1020,1710 1710,1920 1920,2280
style thing,| and we try
|我们试着获取，

1808
00:58:43,570 --> 00:58:45,970
0,120 120,510 900,1620 1680,1950 1950,2400
to get,| and in most
|在大多数情况下，客户端，

1809
00:58:45,970 --> 00:58:48,190
0,540 540,1080 1110,1650 1650,2040 2040,2220
cases the clients,| that you
|未命中的第一行

1810
00:58:48,190 --> 00:58:49,030
0,90 90,210 210,510 510,720 720,840
know the first line that

1811
00:58:49,030 --> 00:58:51,160
0,510 780,1110 1110,1350 1350,1470 1470,2130
missed| {} will have updated
|很快地更新键 k ，

1812
00:58:51,220 --> 00:58:53,530
0,660 660,1350 1350,1440 1440,1680 1770,2310
{the,key} k you know reasonably

1813
00:58:53,530 --> 00:58:54,880
0,450 450,660 660,870 870,1080 1080,1350
soon,| like in the order
|在毫秒量级上，

1814
00:58:54,880 --> 00:58:56,770
0,60 60,870 1200,1440 1440,1890 1890,1890
of milliseconds,| and then {}
|然后这些重试成功，

1815
00:58:56,770 --> 00:58:58,700
0,420 420,840 840,1260 1260,1800
these retries {actual,will} succeed,

1816
00:58:59,260 --> 00:59:00,850
0,270 270,570 570,870 870,1170 1170,1590
right,| and and there's no
|这里没有爆炸式增长，

1817
00:59:00,850 --> 00:59:02,620
0,420 420,570 570,840 840,990 990,1770
really and there's no explosion|
|

1818
00:59:02,620 --> 00:59:04,000
0,420 420,660 660,990 990,1050 1050,1380
on the number of requests
对数据库的请求数量，

1819
00:59:04,000 --> 00:59:04,900
0,90 90,180 180,660 660,780 780,900
to the database| with this
|在这种方案下。

1820
00:59:04,900 --> 00:59:05,560
0,420
scheme.|
|

1821
00:59:06,260 --> 00:59:08,120
0,120 120,390 390,480 480,1200 1200,1860
Of course, it introduces,| as
当然，它引入了，|正如我们稍后将看到的，更多的竞态条件，

1822
00:59:08,120 --> 00:59:08,810
0,150 150,300 300,360 360,420 420,690
we'll see in a second

1823
00:59:08,810 --> 00:59:12,440
0,390 450,870 870,1500 1860,2580 2730,3630
more {you,know,race} conditions,| {} but
|但是，首先让我们继续关注性能。

1824
00:59:12,440 --> 00:59:14,060
0,120 120,540 600,1050 1050,1380 1410,1620
you know first let's keep

1825
00:59:14,060 --> 00:59:15,300
0,330 330,420 420,1080
focusing on performance.|
|

1826
00:59:17,170 --> 00:59:18,160
0,840

1827
00:59:18,450 --> 00:59:19,530
0,150 150,330 330,600 600,750 750,1080
There was another thing about
租约还有另一件事，

1828
00:59:19,530 --> 00:59:21,330
0,600 600,930 960,1200 1200,1530 1530,1800
leases, right,| {} where where
|它们适合，比如地址仍然固定。

1829
00:59:21,330 --> 00:59:25,410
0,480 930,1650 1770,2160 2250,3210 3660,4080
they fit, like address still

1830
00:59:25,410 --> 00:59:27,510
0,750 840,1230 1230,1380 1380,1620 1710,2100
sets.| Yeah, so that leases
|是的，所以租约形成了两个角色，

1831
00:59:27,510 --> 00:59:29,430
0,330 330,480 480,1140 1320,1770 1770,1920
form two roles,| {} as
|我们稍后将看到，

1832
00:59:29,430 --> 00:59:30,120
0,120 120,270 270,330 330,390 390,690
we'll see in a second,|
|

1833
00:59:30,120 --> 00:59:31,560
0,390 390,540 540,1200 1200,1290 1290,1440
one for consistency and one
一个是一致性，一个是性能，

1834
00:59:31,560 --> 00:59:33,180
0,90 90,870 1110,1290 1290,1500 1500,1620
for performance,| this one is
|这个是用来性能的，

1835
00:59:33,180 --> 00:59:34,180
0,120 120,900
for performance,|
|

1836
00:59:35,870 --> 00:59:36,650
0,210 210,330 330,450 450,630 630,780
and so we'll talk about
我们将在稍后讨论一致性，

1837
00:59:36,650 --> 00:59:37,670
0,420 420,780 780,900 900,930 930,1020
consistency {in,a,second},| and I will
|我会看到第二次讨论，

1838
00:59:37,670 --> 00:59:39,020
0,150 150,240 240,510 510,1080 1170,1350
see the second reviews,| as
|作为解决这些竞争情况的一种方法。

1839
00:59:39,020 --> 00:59:39,950
0,210 210,450 450,570 570,810 810,930
one way to solve one

1840
00:59:39,950 --> 00:59:41,160
0,60 60,210 210,390 390,960
of these race conditions.|
|

1841
00:59:46,390 --> 00:59:48,040
0,270 270,480 480,960 1020,1440 1440,1650
Okay, one more, {} there
好的，论文上还有更多，

1842
00:59:48,040 --> 00:59:48,610
0,30 30,240 240,420 420,480 480,570
are many more in the

1843
00:59:48,610 --> 00:59:49,930
0,450 480,750 750,960 960,1140 1140,1320
paper,| {} but just one
|还有一件有趣的事，

1844
00:59:49,930 --> 00:59:50,950
0,180 180,360 360,510 510,570 570,1020
more that's sort of interesting,|
|

1845
00:59:50,950 --> 00:59:53,410
0,630 630,810 810,1020 1020,1500 1890,2460
{at,least} I find interesting, {}|
至少我觉得有趣，|

1846
00:59:53,920 --> 00:59:55,090
0,210 210,450 450,810 810,1050 1050,1170
you know what happens if
如果 memcached 或 memcache 服务器出现故障，会发生什么情况？

1847
00:59:55,090 --> 00:59:57,370
0,150 150,420 420,780 870,1680 1680,2280
they have a {memcached -}

1848
00:59:57,370 --> 00:59:58,960
0,240 240,570 570,600 600,990 990,1590
or {memcache -} server failure?|
|

1849
01:00:08,750 --> 01:00:09,860
0,180 180,360 360,750 750,900 900,1110
{} It depends,| if it's
那得看情况,|如果是整个数据中心，

1850
01:00:09,860 --> 01:00:12,170
0,90 90,810 840,1560 1590,2010 2010,2310
the whole data center that,|
|

1851
01:00:12,170 --> 01:00:14,660
0,450 720,870 870,1500 1530,2100 2100,2490
{} the whole collection of
整个 memcache 服务器集合都发生了故障。

1852
01:00:14,840 --> 01:00:17,600
0,300 300,600 600,780 780,1350 2610,2760
memcache servers that failed.| {Just,consider,a}
|只要考虑一个，我想要做的。

1853
01:00:17,600 --> 01:00:18,440
0,600
handful,

1854
01:00:19,180 --> 01:00:20,980
0,150 150,450 450,870 900,1410 1410,1800
I want {to,do}.| These kind
|之前有人提到过，

1855
01:00:20,980 --> 01:00:24,130
0,180 180,420 420,900 900,1590 2640,3150
that someone mentioned before,| that
|故障的 memcache ，

1856
01:00:24,400 --> 01:00:26,050
0,360 360,1140 1140,1230 1230,1470 1470,1650
the memcache the failed {memcache

1857
01:00:26,050 --> 01:00:29,530
0,630 990,1290 1290,1650 1650,2370 2520,3480
-},| but they don't delete
|但他们不会删除它们。

1858
01:00:29,530 --> 01:00:30,200
0,450
them.|
|

1859
01:00:30,460 --> 01:00:32,080
0,240 240,390 390,630 630,750 750,1620
Yeah, so look at the
是的，所以看看这个场景，

1860
01:00:32,080 --> 01:00:33,880
0,390 390,690 690,1110 1110,1530 1530,1800
scenario, correct,| problematic scenario is
|有问题的情况是 memcached 服务器出现故障，

1861
01:00:33,880 --> 01:00:35,320
0,180 180,600 600,1050 1050,1140 1140,1440
like a {memcached -} server

1862
01:00:35,320 --> 01:00:38,350
0,570 1020,1890 1920,2280 2280,2640 2640,3030
fails,| {} that will result
|这将导致一系列未命中，

1863
01:00:38,350 --> 01:00:39,310
0,60 60,150 150,360 360,450 450,960
in a bunch of misses,|
|

1864
01:00:39,310 --> 01:00:40,240
0,330 330,570 570,720 720,870 870,930
those misses will hit the
这些未命中将进入数据库，

1865
01:00:40,240 --> 01:00:41,320
0,660 660,780 780,840 840,1020 1020,1080
database,| and they want to
|他们想避免命中数据库，

1866
01:00:41,320 --> 01:00:43,090
0,480 480,720 720,840 840,1410 1410,1770
avoid hitting the database, right,|
|

1867
01:00:43,660 --> 01:00:44,980
0,330 330,690 690,810 810,1050 1050,1320
any client that actually has
任何在这些服务器中具有键的客户端，

1868
01:00:44,980 --> 01:00:45,790
0,90 90,300 300,570 570,660 660,810
a couple keys in those

1869
01:00:45,790 --> 01:00:47,410
0,540 870,1020 1020,1080 1080,1380 1380,1620
servers| and is gonna try
|试图获取键将会失败，

1870
01:00:47,410 --> 01:00:49,990
0,1290 1530,1890 1890,1950 1950,2310 2310,2580
to retrieve the key will

1871
01:00:49,990 --> 01:00:51,700
0,750 750,840 840,1230 1230,1530 1530,1710
fail,| and then {you,know} have
|然后必须做点什么。

1872
01:00:51,700 --> 01:00:52,440
0,90 90,180 180,570
to do something.|
|

1873
01:00:53,260 --> 01:00:56,060
0,540 570,780 780,1080 1080,1920
So when it {get,fails},|
所以当它失败的时候，|

1874
01:00:56,890 --> 01:00:58,780
0,570 930,1140 1140,1410 1410,1800 1800,1890
{you,know} the easy solution is
简单的解决办法就是去数据库，

1875
01:00:58,780 --> 01:00:59,890
0,60 60,210 210,330 330,420 420,1110
to go to the database,|
|

1876
01:00:59,920 --> 01:01:01,600
0,1110 1110,1200 1200,1350 1350,1410 1410,1680
but we want to protect
但我们想要保护数据库，

1877
01:01:01,600 --> 01:01:03,370
0,90 90,750 1020,1440 1440,1590 1590,1770
the database,| and so that
|所以这看起来不是个好主意，

1878
01:01:03,370 --> 01:01:04,090
0,270 270,480 480,570 570,630 630,720
doesn't seem to be a

1879
01:01:04,090 --> 01:01:05,320
0,240 240,750 900,1020 1020,1110 1110,1230
great idea,| and so what
|所以，他们所做的是，

1880
01:01:05,320 --> 01:01:06,280
0,120 120,330 330,420 420,750 750,960
they do is| actually have
|拥有一个小型的其他集群或另一个池，

1881
01:01:06,280 --> 01:01:07,630
0,60 60,390 390,660 660,1200 1200,1350
a small other cluster or

1882
01:01:07,630 --> 01:01:09,190
0,390 450,930 930,1080 1080,1170 1170,1560
another pool,| like the regional
|比如区域池或者他们叫 Gutter 池，

1883
01:01:09,190 --> 01:01:10,360
0,390 630,810 810,900 900,1110 1110,1170
pool or they called the

1884
01:01:10,360 --> 01:01:11,420
0,300 300,660
Gutter pool,|
|

1885
01:01:15,070 --> 01:01:16,300
0,300 300,570 570,810 810,990 990,1230
and the Gutter pool is
Gutter 池就是一些 memcached 机器，

1886
01:01:16,300 --> 01:01:17,830
0,600 600,750 750,930 930,1020 1020,1530
basically {} sort of {}

1887
01:01:17,830 --> 01:01:20,290
0,570 570,1050 1050,1260 1260,1920 2040,2460
handful {memcached -} machines,| {that,is,just}
|这只是可用的，

1888
01:01:20,290 --> 01:01:23,500
0,720 1080,1500 1500,2670 2670,2820 2820,3210
available,| {} and they're available
|它们的使用时间很短，

1889
01:01:23,500 --> 01:01:24,670
0,120 120,600 600,870 870,1110 1110,1170
for a short period of

1890
01:01:24,670 --> 01:01:26,920
0,630 840,1380 1410,1890 1890,2010 2010,2250
time,| the system {sort,of} {reconfigures
|系统在重新配置和修复自身，

1891
01:01:26,920 --> 01:01:28,510
0,480 480,600 600,1020 1020,1440 1440,1590
-} and repairs itself,| and
|添加新的 memcached 服务器，

1892
01:01:28,510 --> 01:01:29,560
0,180 180,420 420,660 660,900 900,1050
adds new {memcached - -}

1893
01:01:29,560 --> 01:01:30,880
0,630 630,720 720,810 810,1200 1200,1320
servers,| you know to {}
|替换失败的那个。

1894
01:01:30,880 --> 01:01:31,870
0,150 150,570 570,660 660,900 900,990
to replace the one that

1895
01:01:31,870 --> 01:01:32,460
0,300
failed.|
|

1896
01:01:32,930 --> 01:01:33,860
0,300 300,390 390,570 570,870 870,930
But in that period of
但在那段时间里，

1897
01:01:33,860 --> 01:01:34,730
0,420 420,510 510,630 630,810 810,870
time,| you know there's a
|有一个新的[顺序]，或者可能更多一点，

1898
01:01:34,730 --> 01:01:36,230
0,150 150,390 390,480 480,1080 1320,1500
new order of minutes or

1899
01:01:36,230 --> 01:01:37,280
0,210 210,240 240,390 390,510 510,1050
maybe a little bit more,|
|

1900
01:01:37,370 --> 01:01:39,500
0,840 870,1080 1080,1260 1260,1620 1620,2130
{} they don't want to
它们不想收到请求，

1901
01:01:39,620 --> 01:01:41,510
0,690 690,1140 1140,1440 1440,1830 1830,1890
get requests| or SELECT to
|或 SELECT 转到数据库，

1902
01:01:41,510 --> 01:01:43,010
0,150 150,270 270,360 360,1050 1170,1500
go to the database,| instead
|不是它们在失败时所做的事情，

1903
01:01:43,010 --> 01:01:43,790
0,60 60,210 210,330 330,570 570,780
of what they do when

1904
01:01:43,790 --> 01:01:45,230
0,90 90,330 330,870 1020,1230 1230,1440
they get fails,| you go
|你先去试试 Gutter 池，

1905
01:01:45,230 --> 01:01:46,820
0,480 480,900 900,990 990,1290 1290,1590
try first the Gutter pool,|
|

1906
01:01:47,540 --> 01:01:48,890
0,660 660,750 750,1080 1080,1260 1260,1350
and you know {the,Gutter -}
Gutter 池将会，

1907
01:01:48,890 --> 01:01:51,650
0,360 360,930 1170,2220 2250,2400 2400,2760
pool will,| {} you know
|第一个命中 Gutter 池的会失败或未命中，

1908
01:01:51,860 --> 01:01:52,700
0,210 210,450 450,600 600,720 720,840
the first one that hits

1909
01:01:52,700 --> 01:01:53,630
0,90 90,210 210,300 300,780 780,930
the {Gutter -} pool {you,know}

1910
01:01:53,630 --> 01:01:55,610
0,270 270,810 810,1080 1290,1470 1470,1980
will fail or will miss,|
|

1911
01:01:55,820 --> 01:01:57,560
0,420 420,750 750,1140 1140,1200 1200,1740
{} do SELECT the database,|
执行 SELECT 数据库，|

1912
01:01:57,560 --> 01:01:58,850
0,210 210,750 750,990 990,1200 1200,1290
get results stick into the
将结果放入 Gutter 池，

1913
01:01:58,850 --> 01:02:00,590
0,240 240,720 750,870 870,930 930,1740
Gutter pool,| and then subsequent
|然后，后面的请求或获取将从 Gutter 池中得到答复，

1914
01:02:00,620 --> 01:02:02,780
0,990 1140,1350 1350,1620 1620,1860 1860,2160
request or gets will actually

1915
01:02:02,780 --> 01:02:03,740
0,300 300,450 450,750 750,900 900,960
then be answered from the

1916
01:02:03,740 --> 01:02:05,180
0,270 270,570 960,1170 1170,1290 1290,1440
Gutter pool,| and at some
|在某个时刻， memcached 机器扩展，

1917
01:02:05,180 --> 01:02:06,290
0,360 360,570 570,660 660,840 840,1110
point, {you,know} the {memcached -

1918
01:02:06,290 --> 01:02:08,690
0,510 780,1260 1260,1650 1650,1860 1860,2400
-} {} machine [] scaled,|
|

1919
01:02:08,720 --> 01:02:10,160
0,270 270,450 450,690 690,900 900,1440
it has either been replaced
它或者被另一台机器替换或者恢复，

1920
01:02:10,160 --> 01:02:11,600
0,270 270,630 630,750 750,990 990,1440
or replaced with another machine

1921
01:02:11,600 --> 01:02:13,220
0,150 150,720 1050,1200 1200,1530 1530,1620
or recovered,| and then you
|然后，负载将转移回 memcached 服务器和 Gutter 池，

1922
01:02:13,220 --> 01:02:14,390
0,90 90,180 180,270 270,690 690,1170
{know -} the loads shift

1923
01:02:14,390 --> 01:02:15,470
0,330 330,420 420,600 600,840 840,1080
back to this {memcached -

1924
01:02:15,470 --> 01:02:16,670
0,150 150,630 630,990 990,1140 1140,1200
-} server and {the,Gutter -}

1925
01:02:16,670 --> 01:02:17,630
0,270 270,360 360,630 630,840 840,960
pool,| so it's again in
|它又一次在边上，

1926
01:02:17,630 --> 01:02:18,860
0,90 90,570 810,1020 1020,1170 1170,1230
the side| to sort of
|在这些过渡期之间进行。

1927
01:02:18,860 --> 01:02:20,300
0,420 420,870 870,1170 1170,1290 1290,1440
carry over between these sort

1928
01:02:20,300 --> 01:02:21,320
0,60 60,480 480,960
of transition periods.|
|

1929
01:02:23,610 --> 01:02:24,380
0,480
Okay?|
好的？|

1930
01:02:25,120 --> 01:02:25,990
0,210 210,300 300,570 570,750 750,870
So this {sort,of} gets us
这就是我们今天的阅读问题，

1931
01:02:25,990 --> 01:02:28,150
0,180 180,870 1440,1770 1770,2070 2070,2160
to the reading question for

1932
01:02:28,150 --> 01:02:30,130
0,600 600,1020 1020,1230 1230,1440 1440,1980
today,| as you just mentioned,|
|就像你刚才提到的，|

1933
01:02:30,310 --> 01:02:32,800
0,900 930,1560 1560,2010 2010,2190 2190,2490
the Gutter pools you don't
你不在 Gutter 池执行删除，

1934
01:02:32,800 --> 01:02:33,490
0,120 120,210 210,510 510,630 630,690
do a delete from the

1935
01:02:33,490 --> 01:02:34,420
0,270 270,690
Gutter pool,|
|

1936
01:02:34,870 --> 01:02:36,970
0,600 600,1350 1350,1440 1440,1740 1740,2100
and invalidation is actually also
并且失效也不会被发送到 Gutter 池，

1937
01:02:36,970 --> 01:02:37,810
0,210 210,420 420,510 510,600 600,840
not sent to the Gutter

1938
01:02:37,810 --> 01:02:40,960
0,450 900,1650 1650,2400 2640,2850 2850,3150
pool,| {} and the question
|问题是为什么，或者我们可以推测为什么，

1939
01:02:40,960 --> 01:02:42,670
0,120 120,480 480,1080 1080,1410 1410,1710
is like why or can

1940
01:02:42,670 --> 01:02:43,900
0,90 90,540 540,630 630,960 1050,1230
we speculate on why,| so
|所以也许这是一个快速分组会议室的时间，

1941
01:02:43,900 --> 01:02:44,560
0,210 210,330 330,450 450,540 540,660
maybe this is a good

1942
01:02:44,560 --> 01:02:46,210
0,210 210,570 570,750 750,960 960,1650
time for a quick {breakout,room},|
|

1943
01:02:46,450 --> 01:02:47,830
0,270 270,750 750,840 840,930 930,1380
couple minutes,| you know to
用几分钟时间，|要么讨论一下 memcached 设计的其他方面，

1944
01:02:48,070 --> 01:02:49,540
0,270 270,570 570,780 780,1200 1200,1470
either discuss other aspects from

1945
01:02:49,540 --> 01:02:51,130
0,510 540,870 870,1410 1410,1500 1500,1590
the memcached design,| or you
|或者你想要讨论这个问题的答案是什么。

1946
01:02:51,130 --> 01:02:52,030
0,120 120,180 180,480 480,750 750,900
want to discuss [] trying

1947
01:02:52,030 --> 01:02:52,810
0,90 90,330 330,420 420,570 570,780
to figure out the answer

1948
01:02:52,810 --> 01:02:53,820
0,90 90,240 240,570 570,900
to that question is.|
|

1949
01:02:56,080 --> 01:02:57,310
0,210 210,630 630,810 810,1050 1050,1230
{So,maybe} we're gonna break up,|
所以或许我们中断一下，|

1950
01:02:57,310 --> 01:02:58,860
0,360 360,630 630,840 840,1230
yes, thank you, Lily.|
是的，谢谢， Lily 。|

1951
01:04:14,520 --> 01:04:15,280
0,60

1952
01:04:39,700 --> 01:04:40,940
0,450

1953
01:05:08,530 --> 01:05:10,020
0,330

1954
01:05:13,350 --> 01:05:14,820
0,60 60,1320

1955
01:05:15,880 --> 01:05:16,400
0,240

1956
01:06:20,770 --> 01:06:22,000
0,960

1957
01:06:53,860 --> 01:06:54,760
0,660

1958
01:07:20,190 --> 01:07:21,220
0,300

1959
01:07:43,780 --> 01:07:45,200
0,870

1960
01:08:36,540 --> 01:08:37,480
0,60

1961
01:08:39,400 --> 01:08:40,200
0,480

1962
01:09:03,340 --> 01:09:05,000
0,300 300,690 690,1230
Okay, {so,is,everybody} back?|
好的，大家都回来了吗？|

1963
01:09:10,310 --> 01:09:11,580
0,330 330,510 510,630 630,900
{Yep\,,it} looks like it.|
是的，看起来是的。|

1964
01:09:11,980 --> 01:09:13,280
0,390 390,420 420,600 600,900
Yep, {okay -} good.|
是的，好的。|

1965
01:09:13,490 --> 01:09:15,560
0,300 300,570 570,1110 1140,1800 1860,2070
Okay, so {} anybody,| {you,know}
好的，有人知道，|这篇论文没有非常准确地回答这个问题，

1966
01:09:15,560 --> 01:09:16,580
0,240 240,480 480,690 690,930 930,1020
the paper doesn't answer this

1967
01:09:16,580 --> 01:09:18,680
0,570 570,810 810,1380 1380,1560 1560,2100
question very precisely,| but anybody
|但是有人想大胆猜测

1968
01:09:18,680 --> 01:09:20,000
0,270 270,510 510,780 780,840 840,1320
want to dare to speculate|
|

1969
01:09:20,000 --> 01:09:21,060
0,90 90,180 180,450 450,780
what the answer is
删除的答案是什么，

1970
01:09:21,460 --> 01:09:22,920
0,300 300,450 450,1200
on the deletes,|
|

1971
01:09:23,520 --> 01:09:25,260
0,210 210,540 540,930 930,1200 1200,1740
no delete, {you,know} no invalidation
没有删除，没有失效到 Gutter 集群。

1972
01:09:25,260 --> 01:09:27,020
0,600 600,900 900,1440
{to,the} Gutter cluster.|
|

1973
01:09:27,830 --> 01:09:31,020
0,300 300,750 780,1740 2160,2610
Oh, what are.| {Go,ahead}.|
哦，那个。|继续。|

1974
01:09:31,550 --> 01:09:32,660
0,360 360,540 540,660 660,930 930,1110
Oh, what we said was
哦，我们说的是，

1975
01:09:32,660 --> 01:09:33,880
0,390 390,990
something like,|
|

1976
01:09:34,450 --> 01:09:35,560
0,300 300,480 480,750 750,1020 1020,1110
if you do,| then you
如果你这样做了，|那么你会对 Gutter 池施加很大的压力，

1977
01:09:35,560 --> 01:09:36,700
0,330 420,780 780,840 840,1020 1020,1140
would have a lot of

1978
01:09:36,700 --> 01:09:38,050
0,480 480,660 660,780 780,1110 1110,1350
pressure on the Gutter pool,|
|

1979
01:09:38,050 --> 01:09:39,040
0,360 360,510 510,600 600,780 780,990
because there are so few
因为只有很少的机器，

1980
01:09:39,040 --> 01:09:41,020
0,720 990,1200 1200,1350 1350,1620 1620,1980
machines,| and for every cache
|对于每个缓存未命中，

1981
01:09:41,020 --> 01:09:43,180
0,600 750,1020 1020,1140 1140,1440 1440,2160
miss,| there are two requests
|有两个对缓存的请求，

1982
01:09:43,180 --> 01:09:44,950
0,480 780,1170 1170,1320 1320,1500 1500,1770
for cache [] are just

1983
01:09:44,950 --> 01:09:46,330
0,510 660,930 930,1110 1110,1230 1230,1380
one,| so if you do
|所以，如果你这样做，

1984
01:09:46,330 --> 01:09:48,310
0,480 630,1110 1110,1470 1470,1800 1800,1980
that,| after every write, you
|在每次写入之后，你都会有一个额外的请求，

1985
01:09:48,310 --> 01:09:50,400
0,480 660,840 840,1170 1170,1950
have an extra request,|
|

1986
01:09:50,540 --> 01:09:51,800
0,300 300,480 480,570 570,1020 1050,1260
{on,the} {Gutter -} pool, it's
在 Gutter 池上，它太小了，

1987
01:09:51,800 --> 01:09:52,730
0,150 150,540 540,660 660,780 780,930
so small,| so you don't
|所以你不会想这么做的，

1988
01:09:52,730 --> 01:09:53,690
0,270 270,360 360,510 510,840 840,960
want to do that,| and
|此外，你还应该保护数据库，

1989
01:09:53,690 --> 01:09:55,100
0,270 270,390 390,900 900,1320 1320,1410
also you would protect the

1990
01:09:55,100 --> 01:09:57,050
0,570 570,1020 1230,1500 1500,1830 1830,1950
database as well,| because you
|因为你会在写入请求后不断地查询它。

1991
01:09:57,050 --> 01:10:00,110
0,390 690,1290 1290,1680 1680,2010 2460,3060
would constantly query it after

1992
01:10:00,110 --> 01:10:04,760
0,240 240,750 780,1530 2640,4290 4290,4650
a write request.| {Yeah\,,in,general} {the,delete}
|是的，删除消息需要去两个池，

1993
01:10:04,760 --> 01:10:05,720
0,390 390,660 660,750 750,870 870,960
messages also {} have to

1994
01:10:05,720 --> 01:10:06,800
0,120 120,270 270,450 450,810 810,1080
go to two pools, correct,|
|

1995
01:10:06,800 --> 01:10:07,880
0,60 60,450 450,660 660,930 930,1080
the original {memcached - -}
原始的 memcached 池，

1996
01:10:07,880 --> 01:10:09,260
0,450 750,960 960,1020 1020,1200 1200,1380
pool,| all the {memcached,pools -
|所有 memcached 池，并将其在 Gutter 失效，

1997
01:10:09,260 --> 01:10:10,880
0,360 360,480 480,1170 1170,1530 1530,1620
-} and {invalidate,it} into the

1998
01:10:10,880 --> 01:10:13,160
0,510 870,1080 1080,1290 1290,1920 1950,2280
Gutter,| and so you also
|所以，删除流量也翻了一番，

1999
01:10:13,160 --> 01:10:14,630
0,270 270,360 360,690 690,1200 1320,1470
double the delete traffic,| so
|所以我认为这是一个完美的，

2000
01:10:14,630 --> 01:10:15,800
0,150 150,270 270,450 450,510 510,1170
I think that's a perfectly,|
|

2001
01:10:16,220 --> 01:10:18,380
0,420 420,570 570,840 840,1230 1500,2160
I think that's the reason,|
我想这就是原因，|

2002
01:10:18,440 --> 01:10:19,250
0,270 270,300 300,570 570,750 750,810
it's a small set of
这是一组很小的机器，

2003
01:10:19,250 --> 01:10:20,900
0,570 570,810 810,1050 1050,1440
machines,| just there {to,sort,of}
|只是在那里

2004
01:10:21,140 --> 01:10:23,600
0,780 1080,1410 1410,1920 1920,2310 2310,2460
over| {} basically get through
|完成从已删除的 memcached 服务器的转换，

2005
01:10:23,600 --> 01:10:26,480
0,150 150,870 870,1380 1380,2130 2190,2880
that transformation from a deleted

2006
01:10:26,510 --> 01:10:29,180
0,540 540,1200 1260,1710 1710,2220 2220,2670
memcached server,| failed memcached server
|从出现故障的 memcached 服务器到新的 memcached 服务器。

2007
01:10:29,180 --> 01:10:30,470
0,180 180,270 270,690 690,990 990,1290
to a new {memcached -}

2008
01:10:30,470 --> 01:10:31,140
0,450
server.|
|

2009
01:10:32,200 --> 01:10:32,920
0,420
Good.|
好的。|

2010
01:10:33,120 --> 01:10:35,790
0,570 870,1230 1260,1800 2130,2520 2520,2670
Okay, so {} {it's,all,I,want,to} say
好了，关于性能，我想说的就是这些，

2011
01:10:35,790 --> 01:10:37,710
0,210 210,1020 1050,1230 1230,1800 1800,1920
about performance,| {} even though
|尽管论文中有更多关于性能的内容，

2012
01:10:37,710 --> 01:10:38,610
0,180 180,450 450,510 510,570 570,900
there's more in the paper

2013
01:10:38,610 --> 01:10:41,040
0,210 210,870 870,1440 1590,2070 2070,2430
about performance,| { -} instead
|相反，我想谈谈这些竞争，

2014
01:10:41,040 --> 01:10:41,490
0,60 60,210 210,270 270,390 390,450
I want to talk a

2015
01:10:41,490 --> 01:10:42,540
0,360 360,540 540,840 840,960 960,1050
little bit about sort of

2016
01:10:42,540 --> 01:10:44,790
0,300 300,1140 1350,1710 1710,1920 1920,2250
these races,| {} and {}
|它们来自，

2017
01:10:44,790 --> 01:10:45,960
0,180 180,240 240,390 390,900 900,1170
sort of come about,| because
|因为这个试图获得高性能，

2018
01:10:45,960 --> 01:10:47,640
0,90 90,510 510,990 1020,1320 1320,1680
of this {} trying to

2019
01:10:47,640 --> 01:10:49,440
0,720 750,1020 1020,1260 1260,1650 1650,1800
achieve {} high performance,| that
|我们已经讨论过的。

2020
01:10:49,440 --> 01:10:50,980
0,480 480,630 630,930 930,1200
I've been talking about.|
|

2021
01:10:51,170 --> 01:10:52,250
0,450 450,600 600,720 720,840 840,1080
{} They're gonna be three
我想谈论的有三个竞争，

2022
01:10:52,250 --> 01:10:52,940
0,270 270,360 360,510 510,570 570,690
races I want to talk

2023
01:10:52,940 --> 01:10:54,410
0,390 570,870 900,1020 1020,1410 1410,1470
about,| and in fact I
|我认为你已经确认的三个，

2024
01:10:54,410 --> 01:10:55,610
0,210 210,450 450,780 780,900 900,1200
think all three you already

2025
01:10:55,610 --> 01:10:56,660
0,750
identified,|
|

2026
01:10:57,100 --> 01:10:58,810
0,540 540,810 810,930 930,1320 1320,1710
{} and so [] most
大多数讨论都是关于，

2027
01:10:58,810 --> 01:11:00,430
0,420 420,780 780,930 930,1110 1110,1620
discussions presumably gonna be about,|
|

2028
01:11:00,730 --> 01:11:02,860
0,750 900,1050 1050,1170 1170,1320 1320,2130
how you know how {do,they}
他们是如何躲避它们的。

2029
01:11:02,890 --> 01:11:04,820
0,750 750,960
avoid them.|
|

2030
01:11:05,300 --> 01:11:07,280
0,330 330,780 900,1350 1350,1830 1830,1980
And so race 1 is
所以竞争 1 是他们所说的旧配置，

2031
01:11:07,280 --> 01:11:08,780
0,180 180,270 270,570 570,930 930,1500
what they call stale sets,|
|

2032
01:11:08,810 --> 01:11:12,080
0,450 450,960 1080,1680 1680,2250 2370,3270
{} and scenario as follows,|
场景如下，|

2033
01:11:12,440 --> 01:11:14,480
0,360 360,510 510,840 840,1320 1380,2040
we have client 1, use
我们有客户端 1 ，使用一个区域，

2034
01:11:14,480 --> 01:11:16,430
0,300 300,810 840,1380 1380,1740 1740,1950
one region,| nothing {}, one
|一个集群，没什么特别的设置，

2035
01:11:16,430 --> 01:11:18,620
0,420 420,750 750,930 930,1290 1290,2190
cluster nothing a particular special

2036
01:11:18,620 --> 01:11:19,440
0,390
setup,|
|

2037
01:11:19,660 --> 01:11:21,670
0,300 300,750 750,1290 1470,1800 1800,2010
so client 1 {} does
所以客户端 1 执行获取 k ，

2038
01:11:21,670 --> 01:11:25,210
0,540 1170,2010 2700,2940 2940,3240 3240,3540
get {of,k},| {you,know} that turns
|在这种情况下，结果是 nil ，

2039
01:11:25,210 --> 01:11:26,110
0,90 90,150 150,300 300,390 390,900
out to get a nil

2040
01:11:26,230 --> 01:11:28,090
0,330 330,480 480,570 570,1350 1470,1860
{} in the scenario, {}|
|

2041
01:11:28,090 --> 01:11:29,680
0,90 90,270 270,810 870,1200 1200,1590
it will read the value
它将从数据库中读取值，

2042
01:11:29,680 --> 01:11:31,020
0,210 210,270 270,1140
from the database,|
|

2043
01:11:32,130 --> 01:11:33,420
0,480 480,630 630,750 750,840 840,1290
maybe this is the client
也许这是获得 token 的客户端，

2044
01:11:33,420 --> 01:11:34,500
0,120 120,330 330,480 480,540 540,1080
that actually got the token,

2045
01:11:34,740 --> 01:11:36,840
0,480 870,1500 1500,1800 1800,1890 1890,2100
correct,| and it's the one
|它是被允许设置的那个，

2046
01:11:36,840 --> 01:11:39,030
0,150 150,450 450,510 510,1050 1050,2190
that actually is allowed to

2047
01:11:39,090 --> 01:11:41,310
0,300 300,570 990,1860 1860,2130 2130,2220
set it,| but before it
|但在它设置之前，

2048
01:11:41,310 --> 01:11:42,870
0,180 180,420 420,540 540,1020 1050,1560
actually gets to set,| another
|另一个客户端进来了，

2049
01:11:42,870 --> 01:11:45,450
0,510 510,750 750,960 960,1440 1440,2580
client {you,know} comes in,| and
|并将 k 为 2 写入数据库，

2050
01:11:45,510 --> 01:11:47,430
0,840 900,1080 1080,1260 1260,1590 1590,1920
writes you know k is

2051
01:11:47,430 --> 01:11:50,400
0,600 1080,1200 1200,1290 1290,2130 2730,2970
2 to the database,| and
|然后有一个 put(k,2) ，

2052
01:11:50,400 --> 01:11:52,260
0,180 180,390 390,450 450,960 1590,1860
then there's a put of

2053
01:11:52,260 --> 01:11:57,120
0,570 570,1590 3390,4140 4140,4350 4350,4860
k {on,2}| {} and then
|然后其他客户端，

2054
01:11:57,120 --> 01:11:59,580
0,60 60,180 180,750 1500,1800 1800,2460
you know the other clients,|
|

2055
01:11:59,580 --> 01:12:00,510
0,120 120,270 270,510 510,780 780,930
you know actually finally gets
终于等到执行 put ，

2056
01:12:00,510 --> 01:12:02,400
0,420 420,750 750,1080 1080,1380 1380,1890
around to doing actual puts,|
|

2057
01:12:02,400 --> 01:12:04,830
0,240 240,540 540,780 780,1170 1500,2430
{you,know} that puts {you,know} k
它执行 put(k, v1) ，

2058
01:12:04,860 --> 01:12:06,210
0,600 600,780 780,930 930,1140 1140,1350
comma and this is like

2059
01:12:06,210 --> 01:12:07,340
0,450 450,960
maybe v1,|
|

2060
01:12:07,760 --> 01:12:11,030
0,630 630,1050 1050,1650 2340,2790 2790,3270
okay, {comma,v1 -},| and now
好的， ,v1 ，|现在，我们在缓存中有一个旧的值，

2061
01:12:11,030 --> 01:12:12,590
0,300 300,450 450,900 900,1140 1140,1560
can we have a stale

2062
01:12:12,590 --> 01:12:13,780
0,660
value

2063
01:12:14,110 --> 01:12:15,940
0,630 660,780 780,1320 1320,1590 1590,1830
in the cache,| and that
|而且在那里旧的值是持久性的，

2064
01:12:15,940 --> 01:12:17,170
0,150 150,300 300,570 570,1080 1080,1230
you know stale value is

2065
01:12:17,170 --> 01:12:18,820
0,180 180,270 270,750 750,1110
sort of permanent there,|
|

2066
01:12:19,150 --> 01:12:20,890
0,510 510,840 840,1050 1050,1290 1290,1740
until somebody else {does,an} update,|
在其他人更新之前，|

2067
01:12:21,460 --> 01:12:22,900
0,630 930,1080 1080,1230 1230,1380 1380,1440
okay,| and that sort of
好的,|这是不希望的，

2068
01:12:22,900 --> 01:12:25,090
0,900 900,1170 1170,1470 1470,1860 1860,2190
undesirable,| that really breaks their
|这破坏了与应用程序的契约，

2069
01:12:25,090 --> 01:12:27,370
0,630 630,780 780,900 900,1800 2040,2280
contract with the applications,| and
|它们不想回到过去，

2070
01:12:27,370 --> 01:12:27,910
0,90 90,210 210,360 360,420 420,540
they don't want to go

2071
01:12:27,910 --> 01:12:29,350
0,270 270,390 390,750 900,1320 1320,1440
back in time,| {} you
|用户观察到它们，将是[]，

2072
01:12:29,350 --> 01:12:31,420
0,210 210,360 360,630 630,1710 1710,2070
know would be [], actually

2073
01:12:31,420 --> 01:12:33,370
0,270 270,390 390,1050 1590,1860 1860,1950
user could observe that,| so
|所以试图避免这种情况。

2074
01:12:33,370 --> 01:12:34,420
0,150 150,540 540,720 720,780 780,1050
want to try to avoid

2075
01:12:34,420 --> 01:12:34,900
0,270
that.|
|

2076
01:12:35,650 --> 01:12:38,080
0,630 1380,1620 1620,1740 1740,2220 2250,2430
{} So what they do,
那么他们做了什么，他们如何解决这个问题？

2077
01:12:38,080 --> 01:12:39,070
0,390 390,510 510,630 630,870 870,990
how do they solve this

2078
01:12:39,070 --> 01:12:39,840
0,480
problem?|
|

2079
01:12:42,630 --> 01:12:44,120
0,360 360,450 450,960
Would use lease?|
使用租约吗？|

2080
01:12:44,740 --> 01:12:46,150
0,510 540,930 930,1080 1080,1230 1230,1410
Yeah, great, some says it's
是的，有人说是租约的帮助，

2081
01:12:46,150 --> 01:12:47,410
0,120 120,480 480,750 750,990 990,1260
the lease help out here,|
|

2082
01:12:47,410 --> 01:12:48,280
0,60 60,330 330,450 450,510 510,870
they already have a lease,
它们已经有了租约，

2083
01:12:48,280 --> 01:12:49,300
0,210 210,420 420,600 600,870 870,1020
correct,| because this guy got
|因为这个已经有了租约，

2084
01:12:49,300 --> 01:12:50,640
0,90 90,390 390,870
a lease for,|
|

2085
01:12:51,290 --> 01:12:52,430
0,270 270,360 360,600 600,930 930,1140
must have gotten lease,| because
已经获得租约，|否则它就不会从数据库中读取数据，

2086
01:12:52,430 --> 01:12:53,810
0,660 690,870 870,1050 1050,1260 1260,1380
otherwise it's not reading from

2087
01:12:53,810 --> 01:12:55,940
0,90 90,810 1230,1500 1500,1950 1950,2130
the database,| and so at
|所以，在客户端 1 在 put 上面加上租约，

2088
01:12:55,940 --> 01:12:57,350
0,330 360,600 600,840 840,1140 1140,1410
the client 1 presents this

2089
01:12:57,350 --> 01:13:01,380
0,660 870,1080 1080,1140 1140,1680
lease at the put,|
|

2090
01:13:02,010 --> 01:13:03,210
0,240 240,360 360,660 660,870 870,1200
{} or can put {}
或者可以在 put 上加上租约，

2091
01:13:03,240 --> 01:13:04,740
0,330 330,420 420,930 930,1020 1020,1500
present to {lease,at} the put,|
|

2092
01:13:04,770 --> 01:13:07,170
0,1050 1050,1470 1470,1920 1920,2130 2130,2400
{} {and,in,fact\,,it} will| and what
事实上，它会，|还有额外的步骤是什么？

2093
01:13:07,170 --> 01:13:09,330
0,90 90,300 300,1020 1140,1560 1560,2160
is the additional step basically?|
|

2094
01:13:15,140 --> 01:13:17,330
0,270 270,660 660,930 930,1380 1680,2190
To check that the this
检查这个没有过期或者什么，

2095
01:13:17,330 --> 01:13:19,370
0,420 420,1050 1050,1140 1140,1620 1620,2040
hasn't expired or something,| because
|因为如果另一个客户能够。

2096
01:13:19,370 --> 01:13:21,230
0,360 360,720 750,1080 1080,1620 1620,1860
if the other client was

2097
01:13:21,230 --> 01:13:24,020
0,360 360,870 1770,2160 2160,2400 2400,2790
able to.| Sorry, I I
|抱歉，我刚意识到我犯了个错误，

2098
01:13:24,020 --> 01:13:25,070
0,420 420,510 510,690 690,1020 1020,1050
mean I just realized I

2099
01:13:25,070 --> 01:13:26,480
0,150 150,180 180,840 1080,1260 1260,1410
made a mistake,| so this
|这就是为什么这个问题不是很好，

2100
01:13:26,480 --> 01:13:27,260
0,60 60,270 270,360 360,690 690,780
is why the question is

2101
01:13:27,260 --> 01:13:29,330
0,480 630,990 990,1110 1110,1440 1590,2070
also not so good,| let
|让我看看，客户端 2 不会执行 put ，

2102
01:13:29,330 --> 01:13:30,920
0,90 90,390 630,1020 1020,1350 1350,1590
me see the {client,2} doesn't

2103
01:13:30,920 --> 01:13:33,560
0,180 180,420 420,780 1170,1890 1890,2640
do put, correct,| {that,was,invalidation} consistency,|
|这是无效一致性，|

2104
01:13:34,090 --> 01:13:35,380
0,150 150,300 300,630 630,990 990,1290
I got myself confused here,|
我在这里把自己搞糊涂了，|

2105
01:13:35,380 --> 01:13:36,190
0,150 150,330 330,450 450,540 540,810
so what does the client
那么客户端 2 做了什么，

2106
01:13:36,190 --> 01:13:37,560
0,240 240,570 570,690 690,1080
actually {the,client} 2 do,|
|

2107
01:13:38,920 --> 01:13:40,510
0,420 420,540 540,810 810,900 900,1590
after it sets the database.|
在它设置数据库之后。|

2108
01:13:44,080 --> 01:13:46,030
0,480 480,780 780,1410 1470,1740 1740,1950
Go back.| Delete?| Yeah, {it,does}
回去。|删除？|是的，它执行删除，

2109
01:13:46,030 --> 01:13:47,520
0,750
delete,|
|

2110
01:13:47,920 --> 01:13:48,580
0,150 150,240 240,480 480,570 570,660
for the reason that we
基于我们之前谈到的原因，

2111
01:13:48,580 --> 01:13:49,990
0,240 240,450 450,810 810,1230 1230,1410
talked about earlier, correct,| so
|所以它执行删除 k ，

2112
01:13:49,990 --> 01:13:51,040
0,60 60,300 300,540 540,600 600,1050
it does delete of k,|
|

2113
01:13:51,760 --> 01:13:53,200
0,420 420,810 810,930 930,1170 1170,1440
and what's the side effect,|
那么连带作用是什么，|

2114
01:13:53,200 --> 01:13:54,100
0,150 150,450 450,690 690,810 810,900
of what happens with the
删除 k ，租约会发生什么？

2115
01:13:54,100 --> 01:13:55,600
0,390 390,720 720,1050 1050,1350 1350,1500
lease of {} {the,k} being

2116
01:13:55,600 --> 01:13:56,440
0,540
deleted?|
|

2117
01:13:59,420 --> 01:14:02,000
0,240 240,330 330,780 780,1530 1560,2580
But it doesn't like verify
它不会验证，或者它不会。

2118
01:14:02,000 --> 01:14:03,000
0,120 120,240 240,690
or it doesn't.|
|

2119
01:14:03,320 --> 01:14:04,370
0,270 270,540 540,690 690,960 960,1050
Yeah, actually what happens is
是的，删除的连带作用是，

2120
01:14:04,370 --> 01:14:05,630
0,660 660,870 870,1080 1080,1140 1140,1260
a side effect of the

2121
01:14:05,630 --> 01:14:11,060
0,480 510,1530 1560,2430 2460,4620 4620,5430
delete,| the {lease,is} {} invalidated,|
|租约失效，|

2122
01:14:12,420 --> 01:14:14,100
0,300 300,510 510,1050 1050,1170 1170,1680
so it invalidates the lease,|
所以，它使租约失效，|

2123
01:14:17,590 --> 01:14:18,580
0,210 210,360 360,690 690,810 810,990
and so when the put
所以当 put 出现时，

2124
01:14:18,580 --> 01:14:20,200
0,180 180,660 690,900 900,1170 1170,1620
comes along,| so my timeline
|我的时间线有点，

2125
01:14:20,200 --> 01:14:20,830
0,90 90,120 120,270 270,570 570,630
is a little bit,| you
|这个发生在之前，

2126
01:14:20,830 --> 01:14:22,690
0,360 390,900 900,1350 1350,1620 1620,1860
know this happens quite well

2127
01:14:22,690 --> 01:14:25,870
0,570 2220,2520 2520,2670 2670,2910 2910,3180
before, right,| so the put
|所以， put 在 delete 之后发生，

2128
01:14:25,870 --> 01:14:28,120
0,360 360,960 960,1050 1050,1560 1950,2250
happens after the delete, {}|
|

2129
01:14:28,120 --> 01:14:28,990
0,120 120,360 360,450 450,780 780,870
the put will present the
put 将带上 get 的租约，

2130
01:14:28,990 --> 01:14:31,000
0,300 300,480 480,900 900,1350 1680,2010
lease that gotta get, {}|
|

2131
01:14:31,000 --> 01:14:32,050
0,210 210,540 540,750 750,900 900,1050
but that lease has been
但是租约已经因为删除而失效，

2132
01:14:32,050 --> 01:14:33,850
0,720 750,1110 1110,1230 1230,1710 1710,1800
invalidated by the delete,| and
|所以这个 put 被拒绝了。

2133
01:14:33,850 --> 01:14:35,800
0,510 540,780 780,1170 1170,1410 1410,1950
so this put gets rejected.|
|

2134
01:14:41,520 --> 01:14:42,810
0,390 390,900 900,1080 1080,1200 1200,1290
So basically one way to
所以考虑这个问题的一种方式是，

2135
01:14:42,810 --> 01:14:43,740
0,150 150,390 390,570 570,720 720,930
think about this is that,|
|

2136
01:14:43,740 --> 01:14:45,270
0,360 390,1140 1140,1260 1260,1380 1380,1530
they leverage you know the
他们利用租约机制来避免惊群问题，

2137
01:14:45,270 --> 01:14:47,640
0,240 240,750 750,1380 1440,2160 2190,2370
lease mechanism to avoid the

2138
01:14:47,640 --> 01:14:50,970
0,300 300,570 570,1110 1140,2130 2610,3330
thundering herd problem,| they extended
|也避免了这个旧设置的问题。

2139
01:14:50,970 --> 01:14:53,220
0,120 120,510 510,1140 1230,1890 1890,2250
to basically also avoid this

2140
01:14:53,220 --> 01:14:55,060
0,360 360,750 750,1140 1140,1650
{} stale set problem.|
|

2141
01:14:58,280 --> 01:14:59,150
0,180 180,270 270,360 360,510 510,870
Right, does that make sense?|
这能理解吗？|

2142
01:15:01,490 --> 01:15:04,850
0,2460 2580,2880 2880,3030 3030,3090 3090,3360
So, even if we don't
所以，即使我们没有这个租约失效机制，

2143
01:15:04,850 --> 01:15:07,670
0,480 510,1020 1020,1350 1350,2130 2160,2820
have this lease invalidation mechanism,|
|

2144
01:15:07,760 --> 01:15:09,470
0,330 330,480 480,810 810,1140 1140,1710
we would still obey the
我们仍然会服从弱一致性，

2145
01:15:09,500 --> 01:15:11,750
0,240 240,930 930,1620 1950,2130 2130,2250
weak consistency,| that you would
|你会获得在过去的某个时间发生的顺序写入，

2146
01:15:11,750 --> 01:15:13,250
0,270 270,690 690,1020 1020,1170 1170,1500
have ordered writes that happened

2147
01:15:13,250 --> 01:15:14,330
0,90 90,330 330,630 630,990 990,1080
at some point in the

2148
01:15:14,330 --> 01:15:15,590
0,390 390,570 570,660 660,1020 1020,1260
past,| but I believe that,|
|但我相信，|

2149
01:15:15,590 --> 01:15:16,730
0,390 390,540 540,660 660,870 870,1140
the thing of this thing
这件事可以确保你观察到自己的写入，对吗？

2150
01:15:16,730 --> 01:15:17,900
0,480 480,690 690,750 750,1050 1050,1170
ensures that you observe your

2151
01:15:17,900 --> 01:15:19,140
0,210 210,660
own {writes\,,right}?|
|

2152
01:15:19,520 --> 01:15:20,960
0,480 480,630 630,870 870,1170 1170,1440
You're sure, you're right,| they
你是对的，|它们还能确保你不会回到过去，

2153
01:15:20,960 --> 01:15:21,920
0,210 210,540 540,660 660,780 780,960
also ensures that you don't

2154
01:15:21,920 --> 01:15:23,040
0,90 90,330 330,390 390,780
go back in time,|
|

2155
01:15:23,820 --> 01:15:25,230
0,360 360,450 450,600 600,810 810,1410
like if you read something,|
比如，如果你读到一些东西，|

2156
01:15:25,680 --> 01:15:28,470
0,870 870,1590 1590,1980 1980,2610 2610,2790
{} {} {} and like
任何比客户端 2 更晚的客户端，

2157
01:15:28,470 --> 01:15:29,730
0,420 420,750 750,900 900,1080 1080,1260
everybody else that comes {you,know}

2158
01:15:29,730 --> 01:15:31,650
0,300 300,510 510,810 810,1320 1590,1920
after this client 2, {}|
|

2159
01:15:31,650 --> 01:15:33,120
0,270 270,810 810,930 930,1140 1140,1470
will see you know the
将会看到旧的 v1 ，

2160
01:15:33,120 --> 01:15:34,650
0,240 240,390 390,810 900,1200 1200,1530
old {v1 -}| and so
|客户端可能会远远落后于，

2161
01:15:34,650 --> 01:15:35,640
0,90 90,360 360,510 510,720 720,990
a client might get well

2162
01:15:35,640 --> 01:15:37,350
0,450 540,1080 1080,1320 1320,1530 1530,1710
behind| and not see that
|很长一段时间都看不到新的写入，

2163
01:15:37,350 --> 01:15:38,640
0,240 240,600 600,780 780,1080 1080,1290
new write for long, long

2164
01:15:38,640 --> 01:15:39,720
0,240 240,300 300,600 600,660 660,1080
periods of time,| in fact,
|事实上，可能一直看不到。

2165
01:15:39,720 --> 01:15:40,830
0,240 240,450 450,630 630,750 750,1110
might seen not at all.|
|

2166
01:15:41,440 --> 01:15:43,000
0,450 450,630 630,900 900,990 990,1560
Yeah, but, {} I mean
是的，但是，我是说，这会回到过去吗，

2167
01:15:43,060 --> 01:15:44,230
0,270 270,420 420,570 570,930 930,1170
would this be actually going

2168
01:15:44,230 --> 01:15:46,420
0,210 210,300 300,570 570,1260 1740,2190
back in time,| because clients
|因为客户端没有读取之后的东西。

2169
01:15:46,420 --> 01:15:47,920
0,180 180,420 420,600 600,990 990,1500
did not read anything after.|
|

2170
01:15:48,100 --> 01:15:49,690
0,750 780,1200 1200,1380 1380,1440 1440,1590
Maybe maybe back in time
或许回到过去是个错误的词，

2171
01:15:49,690 --> 01:15:50,560
0,60 60,150 150,300 300,630 660,870
is the wrong word,| but
|但它在很长一段时间内不会观察到 v2 。

2172
01:15:50,560 --> 01:15:51,970
0,60 60,270 270,720 720,930 930,1410
it won't observe {v2 -}

2173
01:15:52,030 --> 01:15:53,410
0,210 210,270 270,750 750,990 990,1380
for a long, long time.|
|

2174
01:15:53,740 --> 01:15:55,480
0,150 150,420 1020,1410 1410,1620 1620,1740
I see, okay.| That was
我明白了，好的。|这不是我们想要发生的事情，

2175
01:15:55,480 --> 01:15:56,440
0,240 240,450 450,570 570,690 690,960
not something that we wanted

2176
01:15:56,440 --> 01:15:58,140
0,90 90,450
to happen,|
|

2177
01:15:58,400 --> 01:15:59,210
0,210 210,390 390,480 480,630 630,810
it's okay to be a
有一点是可以的，

2178
01:15:59,210 --> 01:16:00,110
0,150 150,360 360,480 480,810 810,900
little bit,| but not you
|但在很长一段时间是不可以的。

2179
01:16:00,110 --> 01:16:00,860
0,150 150,300 300,360 360,570 570,750
know for a long, long

2180
01:16:00,860 --> 01:16:01,940
0,240
time.|
|

2181
01:16:03,030 --> 01:16:05,940
0,660 1020,1620 1650,2010 2010,2430 2430,2910
Okay, {} second race which
好的，第二场比赛你认识的人已经提过了，

2182
01:16:05,940 --> 01:16:07,740
0,360 360,570 570,900 900,1320 1380,1800
{you,know} guys already mentioned, {}|
|

2183
01:16:07,740 --> 01:16:10,180
0,600 690,1020 1020,1650 1650,2100
already {} identified too,|
也已经被确认了，|

2184
01:16:10,590 --> 01:16:13,740
0,420 1200,1710 1710,1830 1830,2400 2550,3150
because advantage of many {}
因为我猜有很多实验室调试的优势，

2185
01:16:13,830 --> 01:16:15,540
0,330 330,660 660,990 990,1530 1530,1710
I guess lab debugging,| you
|你对比赛了如指掌，

2186
01:16:15,540 --> 01:16:16,860
0,420 420,570 570,780 780,840 840,1320
know all about the races,|
|

2187
01:16:18,050 --> 01:16:20,480
0,900 900,1470 1860,2160 2160,2310 2310,2430
race 2 and this is
第二场比赛，这是冷星系团比赛，

2188
01:16:20,480 --> 01:16:22,860
0,90 90,360 360,720 720,1410
the cold cluster race,|
|

2189
01:16:25,460 --> 01:16:26,090
0,210 210,390 390,480 480,570 570,630
and sort of in a
风格也差不多，

2190
01:16:26,090 --> 01:16:29,180
0,300 300,1020 1260,2310 2670,2940 2940,3090
similar style,| we have two
|我们有两个客户，

2191
01:16:29,180 --> 01:16:30,280
0,810
clients,|
|

2192
01:16:30,640 --> 01:16:33,500
0,210 210,810 1410,1980 1980,2580
client {1,,client,2 - -}.|
客户端1客户端2。|

2193
01:16:35,620 --> 01:16:36,860
0,930

2194
01:16:37,300 --> 01:16:39,910
0,900 930,1470 1500,1800 1800,2220 2250,2610
And, {} let's say k
假设k最初是v1

2195
01:16:39,910 --> 01:16:41,620
0,240 240,420 420,810 810,1560 1560,1710
is {v1 -} originally| and
|所以我们在两个客户端都在冷集群中，

2196
01:16:41,620 --> 01:16:42,550
0,150 150,300 300,390 390,630 630,930
so we're in both clients

2197
01:16:42,550 --> 01:16:43,330
0,90 90,150 150,210 210,510 510,780
are in the cold {}

2198
01:16:43,330 --> 01:16:44,280
0,630
cluster,|
|

2199
01:16:44,640 --> 01:16:47,720
0,780 1170,1830 1830,2220 2220,2760
{} {client,1} sets the
客户端1在数据库中将k设置为新值，

2200
01:16:48,500 --> 01:16:49,880
0,390 390,510 510,540 540,720 720,1380
k to a new value

2201
01:16:49,910 --> 01:16:51,920
0,510 720,900 900,1740
in the database,|
|

2202
01:16:53,070 --> 01:16:56,280
0,780 930,1800 1830,2580
{} {delete,the} k
正确删除冷簇中的k，

2203
01:16:57,630 --> 01:16:59,160
0,150 150,240 240,510 510,960 960,1530
in the cold cluster correct,|
|

2204
01:16:59,160 --> 01:17:00,680
0,360 360,480 480,690 690,1230
{current,cluster} {actually -} in,|
当前集群实际所在位置，|

2205
01:17:01,200 --> 01:17:04,320
0,540 540,1110 1200,2070 2460,2670 2670,3120
and then {} this client
然后这个客户端确实进入了冷集群，

2206
01:17:04,320 --> 01:17:05,360
0,240 240,750
does get

2207
01:17:07,030 --> 01:17:08,680
0,270 270,330 330,570 570,1200
in the cold cluster,|
|

2208
01:17:10,600 --> 01:17:13,540
0,960 1260,1740 1740,2010 2010,2100 2100,2940
{} sees that it actually
看到它实际上并不在那里

2209
01:17:13,540 --> 01:17:17,020
0,450 480,1680 1680,2160 2610,3330 3330,3480
is not there| and what
|接下来要做的是，

2210
01:17:17,020 --> 01:17:19,120
0,120 120,300 300,720 720,1350 1380,2100
is gonna do,| {} get
|从温暖的星团中，

2211
01:17:20,500 --> 01:17:22,500
0,360 360,720 780,1140 1140,1770
from the warm cluster,|
|

2212
01:17:23,280 --> 01:17:24,920
0,390 390,480 480,810 810,1350
get the value back.|
把价值拿回来。|

2213
01:17:26,870 --> 01:17:28,040
0,30 30,360 360,690 690,1050 1050,1170
I mean that like you
我的意思是，就像你知道的那样，真的到了那里

2214
01:17:28,040 --> 01:17:29,150
0,210 210,450 450,660 660,870 870,1110
know get actually gets there|
|

2215
01:17:29,150 --> 01:17:31,280
0,450 450,810 810,1590
before actually the
在实际更新冷星团或暖星团之前。

2216
01:17:31,950 --> 01:17:33,930
0,360 360,990 1080,1410 1410,1860 1860,1980
{} the cold cluster or

2217
01:17:33,930 --> 01:17:34,920
0,60 60,270 270,600 600,810 810,990
the warm cluster actually has

2218
01:17:34,920 --> 01:17:35,980
0,150 150,750
been updated.|
|

2219
01:17:36,290 --> 01:17:37,700
0,450 450,720 720,900 900,1260 1260,1410
{} And so now it
现在，它将执行一组v1的密钥

2220
01:17:37,700 --> 01:17:39,500
0,210 210,660 690,840 840,1260 1260,1800
will do a set of

2221
01:17:40,260 --> 01:17:41,400
0,120 120,270 270,360 360,720 720,1140
you know this key to

2222
01:17:41,400 --> 01:17:42,930
0,180 180,510 510,750 750,1080 1110,1530
{v1 -}| or put sorry,
|或者说抱歉，让我始终如一，

2223
01:17:42,930 --> 01:17:44,640
0,180 180,420 450,720 720,1320 1350,1710
let me be consistent,| put
|将冷集群中的k到v1

2224
01:17:45,660 --> 01:17:46,950
0,210 210,480 480,630 630,780 780,1290
{} k to {v1 -}

2225
01:17:46,950 --> 01:17:50,490
0,930 1260,1410 1410,2190 2520,2940 2940,3540
{in,the} { -} cold cluster|
|

2226
01:17:50,640 --> 01:17:52,200
0,210 210,1140 1140,1350 1350,1500 1500,1560
and now we have to
现在我们不得不面对和以前一样的情况，

2227
01:17:52,200 --> 01:17:53,340
0,210 210,270 270,540 540,1020 1020,1140
{sort,of} the same situation as

2228
01:17:53,340 --> 01:17:55,590
0,510 510,600 600,1140 1380,1500 1500,2250
before,| and we're you know
|而我们，你知道，我们在冷星团中有一种永久的陈旧价值。

2229
01:17:55,650 --> 01:17:56,310
0,240 240,360 360,510 510,570 570,660
we have sort of a

2230
01:17:56,310 --> 01:17:57,800
0,450 450,1080
permanent stale

2231
01:17:58,780 --> 01:18:00,120
0,930
value

2232
01:18:00,410 --> 01:18:01,720
0,240 240,780 780,960
{in,the} cold cluster.|
|

2233
01:18:07,070 --> 01:18:08,900
0,180 180,300 300,450 450,1200 1410,1830
And how do they solve
他们如何解决这个问题？

2234
01:18:08,900 --> 01:18:09,820
0,150 150,600
that problem?|
|

2235
01:18:15,810 --> 01:18:17,100
0,420 420,990
Anybody remember?|
有人记得吗？|

2236
01:18:27,590 --> 01:18:28,280
0,180 180,240 240,330 330,390 390,690
So they have a small
所以他们有一个小的扩展来避免这个问题。

2237
01:18:28,280 --> 01:18:31,010
0,810 810,1200 1440,2160 2160,2280 2280,2730
extension that avoids this problem.|
|

2238
01:18:31,800 --> 01:18:32,610
0,240 240,510 510,660 660,720 720,810
And guess what it could
猜猜会是什么，如果你。

2239
01:18:32,610 --> 01:18:33,660
0,240 240,420 420,720
be if you.|
|

2240
01:18:38,780 --> 01:18:40,160
0,240 240,420 420,990 990,1170 1170,1380
Which are c1 and the
它们是c1和温星团或冷星团。

2241
01:18:40,160 --> 01:18:41,930
0,270 270,810 810,1110 1110,1470 1470,1770
warm cluster {or,cold} cluster.| Both
|这两个冷星团。

2242
01:18:41,930 --> 01:18:43,120
0,150 150,360 360,720
the cold clusters.|
|

2243
01:18:47,070 --> 01:18:49,260
0,690 690,840 840,1260 1260,1380 1380,2190
And they're different, they're {in,different}
它们是不同的，它们在不同的冷星团中，对吗？

2244
01:18:49,260 --> 01:18:50,760
0,270 270,720 720,1230
cold clusters, right?|
|

2245
01:18:50,940 --> 01:18:53,610
0,1830 1830,1980 1980,2070 2070,2190 2190,2670
I'm not sure that matters.|
我不确定这有什么关系。|

2246
01:18:54,600 --> 01:18:56,580
0,390 390,840 840,1230 1230,1710
Yeah, actually {it,doesn't}. {}|
是啊，实际上不是这样。|

2247
01:19:03,990 --> 01:19:04,820
0,510

2248
01:19:08,990 --> 01:19:10,080
0,840

2249
01:19:27,910 --> 01:19:28,720
0,540

2250
01:19:29,900 --> 01:19:30,840
0,660
Anybody?|
有人吗？|

2251
01:19:34,980 --> 01:19:36,060
0,300

2252
01:19:52,340 --> 01:19:53,510
0,210 210,450 450,600 600,990 990,1170
I think they mentioned like
我想他们提到过要推迟两秒钟，

2253
01:19:53,510 --> 01:19:55,250
0,390 390,630 630,810 810,1020 1020,1740
{hold-off -} for two seconds,|
|

2254
01:19:55,250 --> 01:19:57,530
0,660 720,1560 1560,1980 1980,2190 2190,2280
though entirely shared all the
尽管完全分享了所有的细节。

2255
01:19:57,530 --> 01:19:58,820
0,600 600,660 660,990
details of that.|
|

2256
01:20:01,680 --> 01:20:05,370
0,690 690,1410 1440,2160 2160,2760 3090,3690
Yeah, the basically the, {}
是的，基本上，这实际上是他们推迟的原因，

2257
01:20:05,400 --> 01:20:07,680
0,450 450,1020 1020,1860 1890,2100 2100,2280
this actually causes they put

2258
01:20:07,680 --> 01:20:08,740
0,60 60,600
{} hold-off,|
|

2259
01:20:09,030 --> 01:20:09,840
0,180 180,330 330,480 480,540 540,810
they call this a {hold-off
他们称之为暂缓，两秒钟的暂缓，

2260
01:20:09,840 --> 01:20:10,800
0,180 180,270 270,420 420,690 690,960
-}, of {two-second -} {hold-off

2261
01:20:10,800 --> 01:20:11,700
0,450
-},|
|

2262
01:20:15,510 --> 01:20:17,580
0,330 330,720 720,1410 1680,1830 1830,2070
on any set to that
在该键的任何一组上，

2263
01:20:17,580 --> 01:20:19,680
0,420 420,600 600,780 780,1560 1770,2100
key,| so this particular {}
|因此，在删除冷群集中的数据后，

2264
01:20:19,680 --> 01:20:20,820
0,330 330,450 450,570 570,630 630,1140
after you do a delete

2265
01:20:20,820 --> 01:20:23,100
0,300 300,660 660,960 960,1560 1890,2280
in the cold cluster, {}|
|

2266
01:20:23,100 --> 01:20:24,180
0,180 180,420 420,510 510,720 720,1080
you can't do any sets
你在两秒钟内不能对那个键做任何设置

2267
01:20:24,180 --> 01:20:25,110
0,90 90,300 300,600 600,780 780,930
to that key for two

2268
01:20:25,110 --> 01:20:27,390
0,690 1290,1500 1500,1680 1680,1890 1890,2280
seconds| and so this particular
|因此，这一特定的看跌期权将被拒绝，

2269
01:20:27,390 --> 01:20:29,360
0,540 720,900 900,990 990,1620
put will be rejected,|
|

2270
01:20:31,790 --> 01:20:32,630
0,180 180,300 300,390 390,630 630,840
and this is only during
而且这只是在热身到他们脸上的时候，对吧，

2271
01:20:32,630 --> 01:20:33,590
0,90 90,360 360,660 660,810 810,960
the warm up to their

2272
01:20:33,590 --> 01:20:34,460
0,390 390,570 570,660 660,810 810,870
face, right,| so when the
|因此，当星团出现时，天气很冷，

2273
01:20:34,460 --> 01:20:36,500
0,330 330,510 510,930 1230,1440 1440,2040
cluster comes up, it's cold,|
|

2274
01:20:36,740 --> 01:20:38,060
0,120 120,270 270,660 660,1020 1020,1320
you know for a couple
你知道，有几个小时，

2275
01:20:38,060 --> 01:20:39,110
0,270 270,420 420,840 840,930 930,1050
hours,| it runs you know
|你知道，它跑着开始热身

2276
01:20:39,110 --> 01:20:40,850
0,240 240,810 810,1140 1140,1440 1440,1740
to start warming up| and
|并将其内容就位

2277
01:20:40,850 --> 01:20:42,230
0,150 150,300 300,660 660,780 780,1380
get its content in place|
|

2278
01:20:42,500 --> 01:20:43,940
0,510 510,870 870,990 990,1140 1140,1440
and once you know sort
一旦你知道某种程度的热身，

2279
01:20:43,940 --> 01:20:45,950
0,510 540,840 840,1200 1380,1920 1920,2010
of warmed up,| then you
|那你就知道他们不再耍这个把戏了，

2280
01:20:45,950 --> 01:20:46,790
0,120 120,270 270,510 510,690 690,840
know they stopped doing this

2281
01:20:46,790 --> 01:20:48,890
0,570 720,1260 1260,1740 1740,1920 1920,2100
trick,| but basically sort of
|但基本上，你知道，把这个问题抛在脑后，

2282
01:20:49,490 --> 01:20:51,530
0,150 150,1320 1320,1560 1560,1860 1860,2040
you know just paste this

2283
01:20:51,530 --> 01:20:54,500
0,420 420,990 1080,1440 1440,2430 2460,2970
problem over,| {} they think
|他们认为两秒钟就足够了，

2284
01:20:54,500 --> 01:20:55,740
0,120 120,450 450,570 570,1110
two seconds is sufficient,|
|

2285
01:20:56,340 --> 01:20:57,900
0,150 150,300 300,840 840,1200 1200,1560
and that sufficient for basically
这基本上也足以让该写入传播到COLD数据库。

2286
01:20:57,900 --> 01:21:00,840
0,240 240,660 660,1050 1470,2250 2370,2940
that write to {} propagate

2287
01:21:00,840 --> 01:21:02,670
0,210 210,690 810,1110 1110,1530 1530,1830
to the cold database too.|
|

2288
01:21:05,090 --> 01:21:05,940
0,600
Okay?|
好吧?|

2289
01:21:09,240 --> 01:21:11,340
0,180 180,360 360,720 720,1320 1350,2100
But there's one more write
但还有一个问题是，

2290
01:21:11,340 --> 01:21:12,270
0,90 90,510 510,600 600,810 810,930
the problem is,| let me
|让我快速提到这一点，

2291
01:21:12,270 --> 01:21:13,680
0,450 450,750 750,870 870,1080 1080,1410
quickly mention that,| because again
|因为你又一次提到了，

2292
01:21:13,680 --> 01:21:15,300
0,120 120,360 360,720 720,960 1380,1620
you already mentioned it,| so
|所以他们在报纸上谈到的第三场比赛

2293
01:21:15,300 --> 01:21:18,120
0,240 240,480 480,1020 2460,2670 2670,2820
race number 3 that they

2294
01:21:18,120 --> 01:21:18,960
0,240 240,450 450,510 510,600 600,840
talked about in the paper|
|

2295
01:21:18,960 --> 01:21:19,860
0,90 90,270 270,450 450,600 600,900
and I'm sure there's more,|
我相信还有更多，|

2296
01:21:19,860 --> 01:21:20,670
0,270 270,390 390,540 540,600 600,810
but you know the one
但你知道他们说的那句话，

2297
01:21:20,670 --> 01:21:21,630
0,150 150,360 360,720 720,780 780,960
they say,| that the one
|他们在报纸上谈论的那个人

2298
01:21:21,630 --> 01:21:22,470
0,240 240,420 420,510 510,600 600,840
they talk to the paper

2299
01:21:22,470 --> 01:21:24,720
0,450 720,870 870,1020 1020,1170 1170,2250
about| and this is between
|这是在不同地区之间，

2300
01:21:24,720 --> 01:21:27,630
0,780 2010,2460 2460,2670 2670,2730 2730,2910
regions,| it has to do
|这与主备份问题有关，

2301
01:21:27,630 --> 01:21:29,760
0,180 180,330 330,870 870,1470 1590,2130
with the primary backup problem,|
|

2302
01:21:30,030 --> 01:21:31,400
0,240 300,930
primary backup.|
主备份。|

2303
01:21:32,200 --> 01:21:33,130
0,270 270,450 450,510 510,540 540,930
It's sort of a similar
这是一个类似的问题，

2304
01:21:33,130 --> 01:21:34,780
0,660
problem,|
|

2305
01:21:35,060 --> 01:21:36,160
0,780

2306
01:21:36,560 --> 01:21:38,960
0,540 540,1200 1380,2100 2100,2220 2220,2400
and where {} you know
在你知道客户端的地方，它确实会写入数据库，数据库，

2307
01:21:38,960 --> 01:21:41,870
0,360 390,720 720,1200 1800,2610 2610,2910
the client one does write

2308
01:21:41,870 --> 01:21:43,300
0,90 90,150 150,1110
to the database,

2309
01:21:45,310 --> 01:21:46,520
0,90 90,960
the database,|
|

2310
01:21:47,350 --> 01:21:48,160
0,180 180,330 330,420 420,480 480,810
and this is a client
这是背景中的一位客户，

2311
01:21:48,160 --> 01:21:49,240
0,90 90,150 150,570 630,870 870,1080
in the background,| so this
|这是备份区域中的备份客户端，

2312
01:21:49,240 --> 01:21:50,530
0,120 120,240 240,600 600,1230 1230,1290
is a backup clients in

2313
01:21:50,530 --> 01:21:51,520
0,60 60,270 270,390 390,780 780,990
the {backup -} region,| so
|所以这是对主区域中数据库的写入，

2314
01:21:51,520 --> 01:21:54,010
0,210 390,780 780,1320 1350,2100 2100,2490
that's write to the database

2315
01:21:54,010 --> 01:21:55,780
0,90 90,180 180,840 870,1470
in the primary region,|
|

2316
01:21:55,980 --> 01:21:57,060
0,180 180,330 330,420 420,630 630,1080
that sort of goes off
就这样响起，然后这个键被删除，

2317
01:21:57,240 --> 01:21:58,940
0,180 180,450 450,690 690,1380
and then this delete

2318
01:22:02,400 --> 01:22:04,920
0,390 420,750 750,1380 1680,2370 2370,2520
of the key,| {in,of,course} the
|当然，在备份区域中，

2319
01:22:04,920 --> 01:22:06,120
0,360 360,870
backup region,|
|

2320
01:22:06,380 --> 01:22:09,860
0,420 420,810 810,1380 1800,2550 2580,3480
from it's cache| and {}
从它的缓存中|然后原则上它会立即起作用，

2321
01:22:09,980 --> 01:22:11,420
0,360 360,630 660,1200 1200,1320 1320,1440
then in principle it would

2322
01:22:11,420 --> 01:22:12,650
0,150 150,750 750,870 870,1020 1020,1230
do immediately,| and this is
|这就像你们中的一个提到了这一点，

2323
01:22:12,650 --> 01:22:13,460
0,150 150,300 300,390 390,510 510,810
like one of you mentioned

2324
01:22:13,460 --> 01:22:14,510
0,270 270,450 450,540 540,780 780,1050
this,| like you can either
|就像你可以拿到那个特别的k，对吧，

2325
01:22:14,510 --> 01:22:16,490
0,240 240,660 660,1140 1140,1650 1650,1980
do get {that,particular} k, right,|
|

2326
01:22:16,880 --> 01:22:20,720
0,660 840,1590 1590,2490 2520,3030 3030,3840
then, {} and {} and
然后，和将不会看到，将从取回，

2327
01:22:20,720 --> 01:22:22,580
0,240 240,750 840,1650
won't see the,

2328
01:22:23,090 --> 01:22:24,620
0,360 360,510 510,750 750,990 990,1530
{} will fetch from the,|
|

2329
01:22:25,550 --> 01:22:26,580
0,720

2330
01:22:27,120 --> 01:22:29,130
0,630 840,1110 1110,1380 1380,1590 1590,2010
yeah, you know it won't
是的，你知道它不会真正看到那篇文章的结果，

2331
01:22:29,130 --> 01:22:30,030
0,210 210,480 480,570 570,840 840,900
see actually the result of

2332
01:22:30,030 --> 01:22:31,770
0,210 210,600 960,1470 1470,1650 1650,1740
that write,| {} so we
|所以我们不会看到它自己写的东西，

2333
01:22:31,770 --> 01:22:34,560
0,240 240,690 690,930 930,1530 1800,2790
won't see its own write,|
|

2334
01:22:34,590 --> 01:22:35,820
0,420 420,540 540,810 810,870 870,1230
because of write is still
由于写入仍在到备份或到主盘的过程中，

2335
01:22:35,820 --> 01:22:36,900
0,180 180,240 240,450 450,690 690,1080
on the way to the

2336
01:22:36,930 --> 01:22:38,700
0,600 930,1170 1170,1260 1260,1680 1680,1770
backup {or,to} the primary,| the
|主站将通过SQL发出尖叫声，

2337
01:22:38,700 --> 01:22:40,860
0,450 450,1170 1200,1620 1620,1770 1770,2160
primary will send {through -}

2338
01:22:40,860 --> 01:22:41,580
0,540
{}

2339
01:22:41,880 --> 01:22:44,340
0,390 390,630 630,990 1320,1860 1860,2460
{} the {} sql thing,

2340
01:22:44,340 --> 01:22:46,890
0,390 390,780 780,780 1680,2130 2130,2550
squeal thing,| {} propagate update
|将更新传播到备份区域中的数据库

2341
01:22:46,890 --> 01:22:48,360
0,180 180,390 390,840 840,1080 1080,1470
to the database in the

2342
01:22:48,720 --> 01:22:50,190
0,480 480,600 600,990 990,1200 1200,1470
{backup -} area| and so
|只有到那时，你才能再次知道备份实际上会在备份区域，

2343
01:22:50,190 --> 01:22:51,810
0,300 300,840 840,930 930,1140 1140,1620
only then you know again

2344
01:22:51,810 --> 01:22:53,100
0,120 120,510 510,630 630,1140 1140,1290
the backup will actually in

2345
01:22:53,100 --> 01:22:53,790
0,90 90,300 300,390 390,630 630,690
the {backup -} area,| in
|在备份区域中将实际看到k的变化，

2346
01:22:53,790 --> 01:22:54,570
0,60 60,240 240,330 330,600 600,780
the {backup -} region will

2347
01:22:54,570 --> 01:22:55,950
0,240 240,420 420,600 600,870 870,1380
actually see the k change,|
|

2348
01:22:56,310 --> 01:22:57,420
0,240 240,720 720,960 960,1020 1020,1110
so we're sort of, {we,have,a}
所以我们有点，我们这里有个问题，对吧，

2349
01:22:57,420 --> 01:23:00,090
0,390 390,720 720,930 930,1320 1470,2670
problem here, right,| where {}
|其中，如果该k将在没有任何修改的情况下继续，

2350
01:23:00,090 --> 01:23:02,190
0,240 240,420 420,1440 1440,1590 1590,2100
if this k would proceed

2351
01:23:02,670 --> 01:23:05,610
0,330 330,480 480,1470 1560,2460 2550,2940
without any modifications,| then, {}
|那么，我们就看不到我们自己的笔迹了。

2352
01:23:05,610 --> 01:23:06,690
0,150 150,300 300,510 510,930 930,1080
we would see not our

2353
01:23:06,690 --> 01:23:07,500
0,210 210,750
own writes.|
|

2354
01:23:07,930 --> 01:23:09,310
0,330 330,780 780,1110 1110,1200 1200,1380
And anybody remember how they
有人记得他们是怎么解决这个问题的吗？

2355
01:23:09,310 --> 01:23:10,540
0,300 300,390 390,900
solve this problem?|
|

2356
01:23:13,630 --> 01:23:16,150
0,420 420,750 750,1050 1050,1650 1650,2520
{} Was this remote marker?|
这是遥控器吗？|

2357
01:23:16,180 --> 01:23:17,860
0,390 390,960 1080,1290 1290,1470 1470,1680
Yeah, absolutely, it is,| so
是的，绝对是，它是，|所以当他们删除k-k密钥时，

2358
01:23:17,860 --> 01:23:19,150
0,180 180,270 270,750 750,1200 1200,1290
when they delete {k -}

2359
01:23:19,360 --> 01:23:21,430
0,420 420,900 1230,1410 1410,1770 1770,2070
k key,| and they are
|而且他们可能，他们，他们把它保存在备份的Memcached中，

2360
01:23:21,430 --> 01:23:22,660
0,240 240,450 450,840 840,960 960,1230
they may, they, they keep

2361
01:23:22,660 --> 01:23:23,410
0,90 90,180 180,270 270,450 450,750
it in the {memcached -

2362
01:23:23,410 --> 01:23:25,630
0,360 390,600 600,900 900,1440 1680,2220
-} of the backup, {}|
|

2363
01:23:25,630 --> 01:23:27,600
0,210 210,690 690,930 930,1530
and {mark,it} as remote,|
并将其标记为远程，|

2364
01:23:30,490 --> 01:23:32,080
0,210 210,390 390,840 870,1230 1230,1590
and so when this {}
因此，当客户端1得到这一点时，

2365
01:23:32,080 --> 01:23:33,760
0,240 240,780 840,1080 1080,1410 1410,1680
the client {} 1 does

2366
01:23:33,760 --> 01:23:36,670
0,450 570,930 930,1470 1470,2040 2070,2910
get,| they'll see, hey, I'm
|他们会明白的，嘿，我要去拿，

2367
01:23:36,670 --> 01:23:38,260
0,210 210,660 690,1080 1080,1290 1290,1590
gonna get,| basically gets remote
|基本上从它的本地内存缓存远程取回

2368
01:23:38,260 --> 01:23:41,050
0,510 540,840 840,1050 1050,1680 2490,2790
back from its local {memcache

2369
01:23:41,050 --> 01:23:43,060
0,630 870,1050 1050,1470 1470,1650 1650,2010
-}| and then {} goes
|然后基本上从主区域，从主区域获取它。

2370
01:23:43,060 --> 01:23:44,110
0,330 330,450 450,720 720,840 840,1050
basically to fetch it from

2371
01:23:44,110 --> 01:23:45,320
0,90 90,540
the primary,

2372
01:23:48,180 --> 01:23:49,980
0,270 270,630 630,1020
from primary region.|
|

2373
01:23:54,910 --> 01:23:55,840
0,630
Okay?|
好吧?|

2374
01:23:59,220 --> 01:24:00,720
0,270 270,540 540,810 810,990 990,1500
But then the the remote
但之后远程标记将被移除，

2375
01:24:00,720 --> 01:24:02,020
0,810
marker

2376
01:24:02,380 --> 01:24:03,550
0,210 210,360 360,840 840,990 990,1170
will be removed,| when it's
|当可以安全地从备份中读取时。

2377
01:24:03,550 --> 01:24:05,980
0,390 390,840 870,1260 1260,1980 2190,2430
safe to read from the

2378
01:24:05,980 --> 01:24:07,090
0,150 180,630 660,690 690,960 960,1110
backup.| Yes, {} I think
|是的，我认为其中一个数据库，

2379
01:24:07,090 --> 01:24:08,530
0,180 180,240 240,450 450,1110 1110,1440
one of the database,| the
|备份数据库从主数据库获取数据，

2380
01:24:08,650 --> 01:24:11,200
0,660 660,1140 1140,1440 1440,1890 1920,2550
backup database gets the data

2381
01:24:11,230 --> 01:24:12,490
0,210 210,300 300,930 990,1140 1140,1260
from the primary,| that can
|它可以移除标记，

2382
01:24:12,490 --> 01:24:14,000
0,420 420,780 810,1350
remove the marker,|
|

2383
01:24:17,590 --> 01:24:18,820
0,360 360,570 570,870 870,1140 1140,1230
because then it's safe to
因为这样就可以安全地从主数据库和备份数据库进行读取。

2384
01:24:18,820 --> 01:24:20,200
0,270 270,420 420,510 510,840 840,1380
read from the primary database,

2385
01:24:20,260 --> 01:24:21,540
0,90 90,150 150,450 450,1020
from the backup database.|
|

2386
01:24:24,430 --> 01:24:26,040
0,150 150,240 240,360 360,810
Does that make sense?|
这说得通吗？|

2387
01:24:28,000 --> 01:24:29,440
0,450 480,960 1050,1260 1260,1320 1320,1440
Okay, so let me do
好的，让我做个简短的总结，

2388
01:24:29,440 --> 01:24:30,860
0,60 60,270 270,840
a quick summary,|
|

2389
01:24:32,160 --> 01:24:33,600
0,420 450,750 750,900 900,1170 1170,1440
and because I'm running a
因为随着时间的推移我跑得有点慢，

2390
01:24:33,600 --> 01:24:35,310
0,150 150,300 300,480 480,930 1050,1710
little bit over time, {}|
|

2391
01:24:35,310 --> 01:24:36,960
0,180 180,360 360,1080 1170,1290 1290,1650
so quick summaries, you know
快速总结一下，你知道缓存是至关重要的，

2392
01:24:37,610 --> 01:24:41,200
0,330 330,720 720,810 810,1350
{} caching is vital,|
|

2393
01:24:42,100 --> 01:24:44,080
0,510 510,810 810,1260 1260,1320 1650,1980
basically {get -} in {}
基本上达到我们所讨论的这篇论文的能力，

2394
01:24:44,080 --> 01:24:45,580
0,600 600,780 780,1050 1050,1320 1320,1500
capacity that we're talking about

2395
01:24:45,580 --> 01:24:47,560
0,240 270,690 690,930 930,1560 1590,1980
this paper,| like billions of
|例如每秒数十亿次操作，

2396
01:24:47,560 --> 01:24:49,870
0,570 570,840 840,1290 1920,2130 2130,2310
operations per second,| {} there
|有两种策略可以获得这种高容量，

2397
01:24:49,870 --> 01:24:51,340
0,180 180,360 360,1110 1110,1290 1290,1470
are two strategies to sort

2398
01:24:51,340 --> 01:24:52,990
0,60 60,240 240,330 330,1080 1110,1650
of get this high capacity,|
|

2399
01:24:52,990 --> 01:24:54,420
0,270 270,390 390,1050
one is petitioning,|
一个是请愿，|

2400
01:24:55,820 --> 01:24:57,660
0,120

2401
01:24:57,990 --> 01:24:59,160
0,420 420,630 630,780 780,960 960,1170
{} which gives you {}
这给你带来了并行性或切分，

2402
01:24:59,160 --> 01:25:01,480
0,600 600,720 720,1260
parallelism or sharding,|
|

2403
01:25:03,550 --> 01:25:05,110
0,240 240,300 300,510 510,1230 1230,1560
and the other strategy {is,you,know}
另一种策略是复制，

2404
01:25:05,170 --> 01:25:07,120
0,990 1050,1110 1110,1440 1440,1650 1650,1950
replication,| is really good for
|对热键来说真的很好，

2405
01:25:07,120 --> 01:25:08,320
0,240 240,720
hot keys,|
|

2406
01:25:08,970 --> 01:25:10,680
0,360 360,510 510,930 930,1530 1530,1710
Keys are being requested by
密钥正被越来越多的客户请求，

2407
01:25:10,680 --> 01:25:12,030
0,300 300,390 390,540 540,630 630,1350
lots and lots of clients,|
|

2408
01:25:12,120 --> 01:25:13,800
0,450 450,600 600,990 990,1380 1410,1680
{} so that's the keys
这就是密钥在多台机器上复制的情况。

2409
01:25:13,800 --> 01:25:15,480
0,180 180,660 660,750 750,1110 1110,1680
get replicated on multiple machines.|
|

2410
01:25:16,350 --> 01:25:20,010
0,900 1170,1920 2430,2910 2910,3240 3240,3660
And {} you know {we,also,see}
你知道，我们也看到，你知道，有一堆几乎是特别的技术

2411
01:25:20,010 --> 01:25:21,240
0,60 60,450 450,660 660,990 990,1230
you know there's a bunch

2412
01:25:21,240 --> 01:25:23,550
0,540 540,990 990,1230 1230,1620 1650,2310
of almost ad hoc techniques|
|

2413
01:25:23,550 --> 01:25:25,980
0,300 300,630 1080,1230 1230,2100 2100,2430
to sort of get around
为了绕过一些严重的一致性问题，

2414
01:25:25,980 --> 01:25:28,470
0,180 180,270 270,780 780,1500 1890,2490
some of the serious consistency

2415
01:25:28,470 --> 01:25:30,780
0,390 390,840 840,1050 1080,1650 1680,2310
issues,| that are {pop,up},| even
|它们被弹出，|即使系统被设计成提供弱一致性

2416
01:25:30,780 --> 01:25:32,190
0,360 360,450 450,840 840,1020 1020,1410
if the systems are designed

2417
01:25:32,190 --> 01:25:34,140
0,90 90,360 360,720 720,1320 1650,1950
to give weak consistency| and
|因此，数据库之间、数据库和高速缓存或内存高速缓存之间的这种整体一致性是棘手的，

2418
01:25:34,140 --> 01:25:35,460
0,210 210,330 330,990 1020,1260 1260,1320
so this whole sort of

2419
01:25:35,460 --> 01:25:40,620
0,600 600,990 990,1350 1500,2640 4470,5160
consistency between the database, between

2420
01:25:40,650 --> 01:25:41,800
0,810
db

2421
01:25:42,710 --> 01:25:45,350
0,600 630,1110 1110,1710 1710,2130 2130,2640
and {} caches {or,memcache -}

2422
01:25:45,410 --> 01:25:46,790
0,120 120,630 660,1020 1020,1230 1230,1380
is tricky,| maybe much more
|可能比你可能发现的要复杂得多，

2423
01:25:46,790 --> 01:25:48,980
0,300 300,510 510,930 1230,1650 1650,2190
tricky than you might found,|
|

2424
01:25:49,220 --> 01:25:51,110
0,630 630,810 810,1380 1380,1440 1440,1890
because of memcache, the cache
因为Memcache，缓存，你知道可能是什么问题，

2425
01:25:51,110 --> 01:25:52,490
0,150 150,480 540,1170 1170,1290 1290,1380
you know what could be

2426
01:25:52,490 --> 01:25:53,900
0,90 90,570 690,1080 1080,1260 1260,1410
the problem,| {} but {you,know}
|但你知道，正如你所看到的，这实际上是相当棘手的，

2427
01:25:53,900 --> 01:25:54,710
0,120 120,210 210,300 300,570 570,810
as you can see it's

2428
01:25:54,710 --> 01:25:56,960
0,210 210,420 420,990 1080,1830 1830,2250
actually pretty tricky,| {} in
|事实上，有更多的研究正在进行中，

2429
01:25:56,990 --> 01:25:58,640
0,300 300,720 720,1230 1230,1440 1440,1650
fact there's a more quite

2430
01:25:58,640 --> 01:25:59,570
0,30 30,150 150,270 270,660 660,930
a bit of {} research

2431
01:25:59,570 --> 01:26:00,560
0,240 240,480 480,690 690,750 750,990
going on,| trying to figure
|想知道你怎样才能做得更好。

2432
01:26:00,560 --> 01:26:01,400
0,330 330,480 480,660 660,750 750,840
out how could you do

2433
01:26:01,400 --> 01:26:01,940
0,390
better.|
|

2434
01:26:03,070 --> 01:26:03,970
0,330 330,450 450,600 600,660 660,900
Okay, with that I want
好了，我想总结一下，

2435
01:26:03,970 --> 01:26:05,350
0,150 150,690 690,930 930,1200 1200,1380
to conclude,| that people that
|那些需要跑步的人，可以跑步，

2436
01:26:05,350 --> 01:26:06,580
0,150 150,210 210,690 690,930 930,1230
need to run, can run,|
|

2437
01:26:06,580 --> 01:26:08,020
0,390 420,840 840,960 960,1170 1170,1440
{you,know} go to their next
你知道，去参加他们的下一次会议

2438
01:26:08,020 --> 01:26:10,240
0,240 240,660 1080,1800 1860,2070 2070,2220
zoom meeting| and I'll see
|我们会再见的

2439
01:26:10,240 --> 01:26:11,890
0,180 180,450 510,1290 1290,1530 1530,1650
you around| or answer any
|或者回答任何问题，如果你还有任何问题，

2440
01:26:11,890 --> 01:26:12,820
0,330 330,420 420,570 570,750 750,930
questions, if you have any

2441
01:26:12,820 --> 01:26:14,040
0,450 450,960
questions remaining,|
|

2442
01:26:14,630 --> 01:26:15,410
0,180 180,510 510,570 570,690 690,780
and otherwise, I'll see you
否则，我会先见到你的，谢谢。

2443
01:26:15,410 --> 01:26:18,540
0,330 1740,2190 2190,2430
first, thank you.|
|

2444
01:26:21,780 --> 01:26:22,920
0,360 360,600 600,690 690,870 870,1140
{} Sorry, I have a
抱歉，我有个问题要问，

2445
01:26:22,950 --> 01:26:24,280
0,450 450,1020
question about,|
|

2446
01:26:24,870 --> 01:26:27,300
0,750 1650,1830 1830,2190 2190,2340 2340,2430
so, for example, for the
因此，例如，对于我们讨论的最后一件事，远程标记，

2447
01:26:27,300 --> 01:26:28,530
0,300 300,450 450,570 570,870 870,1230
last thing we talked about

2448
01:26:28,530 --> 01:26:30,220
0,180 180,390 390,750 750,1440
with the remote marker,|
|

2449
01:26:30,850 --> 01:26:32,500
0,330 330,510 510,720 720,1380 1380,1650
how did they know that
他们怎么知道这将是一场相关的数据竞赛，

2450
01:26:32,500 --> 01:26:33,680
0,150 150,270 270,480 480,960
this is gonna be

2451
01:26:34,320 --> 01:26:36,400
0,870 870,1170 1170,1830
{a,relevant} data race,|
|

2452
01:26:36,710 --> 01:26:37,910
0,240 240,420 420,570 570,690 690,1200
or how did they decide
或者他们是如何决定做这些额外的远程标记会更有用的

2453
01:26:37,910 --> 01:26:40,100
0,390 510,660 660,1050 1200,1620 1620,2190
that it is going to

2454
01:26:40,130 --> 01:26:42,050
0,330 330,600 600,1020 1020,1500 1650,1920
be more useful to do

2455
01:26:42,050 --> 01:26:44,720
0,630 660,1500 1530,2100 2100,2310 2310,2670
this additional stuffs of remote

2456
01:26:44,720 --> 01:26:47,330
0,750 870,1350 1350,1770 1800,2250 2250,2610
marker| versus just getting stable
|而不是仅仅获得稳定的数据。

2457
01:26:47,330 --> 01:26:48,830
0,600 660,1080 1080,1170 1170,1350 1350,1500
data.| Well, I think there
|嗯，我想是有的，因为他们事先有这个要求，

2458
01:26:48,830 --> 01:26:50,000
0,210 210,480 480,630 630,900 900,1170
is because they have this

2459
01:26:50,000 --> 01:26:51,530
0,690 690,900 900,990 990,1320 1320,1530
requirement right up front,| although
|虽然老百姓并没有真正明确的规定，

2460
01:26:51,530 --> 01:26:53,330
0,390 390,660 660,840 840,1200 1200,1800
the people didn't really stipulate

2461
01:26:53,330 --> 01:26:54,900
0,750 750,1380
very clearly,|
|

2462
01:26:55,070 --> 01:26:57,290
0,840 870,1140 1140,1500 1500,1680 1680,2220
{} they really want this,|
他们真的很想要这个，|

2463
01:26:59,570 --> 01:27:00,920
0,300 300,360 360,720 720,1140 1140,1350
like, for example you do
比如，你让用户在他们的时间线上添加一些东西，

2464
01:27:00,920 --> 01:27:03,500
0,630 660,1530 1530,2160 2160,2460 2460,2580
a user adds something to

2465
01:27:03,500 --> 01:27:06,140
0,420 420,1200 1680,2010 2010,2100 2100,2640
their timeline,| read it again,
|再读一遍，它就不在那里了，

2466
01:27:06,140 --> 01:27:07,300
0,90 90,270 270,450 450,900
and it's not there,|
|

2467
01:27:07,640 --> 01:27:08,750
0,300 300,630 630,780 780,990 990,1110
{} and so now is
现在，用户可以直接观察到这一点

2468
01:27:08,750 --> 01:27:09,560
0,90 90,300 300,390 390,750 750,810
a thing that could be

2469
01:27:09,560 --> 01:27:12,230
0,480 480,780 780,900 900,1380 1590,2670
observed directly by users {}|
|

2470
01:27:12,230 --> 01:27:14,660
0,180 180,750 780,1350 1350,2190 2190,2430
and {} strange inconsistency| and
和奇怪的不一致|他们想要避免这种情况。

2471
01:27:14,660 --> 01:27:16,190
0,690 720,900 900,1320 1320,1470 1470,1530
they they they want to

2472
01:27:16,190 --> 01:27:16,940
0,210 210,450
avoid that.|
|

2473
01:27:19,600 --> 01:27:20,920
0,390 390,510 510,690 690,1200 1200,1320
Okay, that makes sense, that
好吧，这说得通，说得通。

2474
01:27:20,920 --> 01:27:22,150
0,180 180,540 750,930 930,1050 1050,1230
makes sense.| And my other
|我的另一个问题是，

2475
01:27:22,150 --> 01:27:24,190
0,330 330,660 660,840 840,1380 1800,2040
question was,| on the one
|在最初的一张幻灯片上，您看到了Memcache的失效。

2476
01:27:24,190 --> 01:27:25,450
0,90 90,330 330,750 750,1050 1050,1260
of the first slides where

2477
01:27:25,450 --> 01:27:28,450
0,120 120,570 870,2190 2190,2640 2730,3000
you had invalidation of the

2478
01:27:28,450 --> 01:27:30,760
0,330 330,1440 1650,1830 1830,1980 1980,2310
{memcache -}.| Let me find
|让我找找我把它放在哪里了。

2479
01:27:30,760 --> 01:27:31,940
0,300 300,420 420,630 630,960
where I had that.|
|

2480
01:27:34,140 --> 01:27:39,390
0,1380 1680,2730 3150,4380 4620,5070 5070,5250
Oh, here.| Well, yeah, this
哦，给你。|嗯，是的，这是一个有点疯狂的数据库，但是。

2481
01:27:39,390 --> 01:27:40,290
0,60 60,210 210,480 480,660 660,900
is the {database -} like

2482
01:27:40,290 --> 01:27:41,340
0,30 30,210 210,360 360,690 690,1050
a little bit wild now,

2483
01:27:41,370 --> 01:27:42,930
0,270 720,1200 1200,1320 1320,1500 1500,1560
but.| {Oh,no}, it was one
|哦，不，那是后来的一次。

2484
01:27:42,930 --> 01:27:44,940
0,150 150,270 270,630 630,1350 1440,2010
of the later {ones -}.|
|

2485
01:27:45,900 --> 01:27:47,250
0,210 210,330 330,450 450,990 990,1350
Also have some invalidation {on,it}
也有一些无效，或者它没有。

2486
01:27:47,400 --> 01:27:49,240
0,270 270,660 930,1560
or {it,doesn't}. {}|
|

2487
01:27:50,550 --> 01:27:52,000
0,270 270,330 330,660 660,1230
Maybe the next one.|
也许是下一次。|

2488
01:27:52,440 --> 01:27:56,760
0,480 510,1320 1320,3390 3420,4080
Yes.| Yeah, yeah, so
是。|是的，是的，所以客户端将仅为其本地区域设置无效

2489
01:27:57,260 --> 01:27:58,640
0,330 330,840 840,960 960,1260 1260,1380
the client is going to

2490
01:27:58,640 --> 01:28:00,830
0,750 780,960 960,1710 1710,1980 1980,2190
set the invalidation only for

2491
01:28:00,830 --> 01:28:04,100
0,480 690,1560 1560,2160 2160,2640 2700,3270
its local region| and the
|尖叫声就要来了，

2492
01:28:04,130 --> 01:28:05,120
0,420 420,540 540,750 750,840 840,990
squeal is going to do

2493
01:28:05,120 --> 01:28:07,220
0,330 960,1170 1170,1260 1260,1920 1920,2100
it,| what the transfer and
|什么是外调，外地人是什么。

2494
01:28:07,220 --> 01:28:08,260
0,360 360,810
for the

2495
01:28:08,610 --> 01:28:10,700
0,1350 1380,1830
non-local.| Yeah.|
|嗯。|

2496
01:28:10,850 --> 01:28:12,380
0,510 540,810 810,1230
Okay, make sense,
好的，说得通，非常感谢。

2497
01:28:13,170 --> 01:28:14,970
0,480 480,570 570,690 690,1200 1230,1800
thank you so much.| {You're,welcome}.|
|不用谢。|

2498
01:28:16,620 --> 01:28:18,870
0,450 480,960 960,1290 1380,2010 2040,2250
{} Professor, {I,had} {} two.|
教授，我喝了两杯。|

2499
01:28:18,870 --> 01:28:20,280
0,330 330,420 420,600 600,930 930,1410
{} You had your final
你有你的最后一个问题，

2500
01:28:20,280 --> 01:28:27,360
0,510 2070,2610 3030,3930 3960,4410 4440,7080
question,| sorry sorry sorry, {go,ahead,please,ask,your}
|对不起，对不起，请继续提问。

2501
01:28:27,390 --> 01:28:29,730
0,540 1470,1680 1680,1890 1890,2040 2040,2340
questions.| {} These {} after
|这些都是课后的。

2502
01:28:29,730 --> 01:28:35,070
0,540 810,2640 3690,4170 4170,4500 4500,5340
class.| {They,don't,count}.| {} So for
|他们不算数。|因此，对于区域中的服务器分配服务器，

2503
01:28:35,070 --> 01:28:37,620
0,570 570,1080 1080,1650 1740,2400
servers servers in {}

2504
01:28:38,160 --> 01:28:39,420
0,150 150,240 240,600 600,750 750,1260
in a region are assigned,|
|

2505
01:28:39,420 --> 01:28:41,130
0,420 420,540 540,690 690,1440 1470,1710
when we have classes, each
当我们有课的时候，每个人都被分配到一个集群，对吧。

2506
01:28:41,130 --> 01:28:41,940
0,180 180,270 270,630 630,720 720,810
one are assigned to a

2507
01:28:41,940 --> 01:28:43,020
0,450 450,780
cluster, right.|
|

2508
01:28:43,430 --> 01:28:46,820
0,480 510,1290 1380,2790 2790,3030 3030,3390
Yeah yeah yeah, every clusters
是的，是的，每个星团都在复制。

2509
01:28:46,820 --> 01:28:49,550
0,300 300,780 1350,1860 1980,2400 2400,2730
really replicate.| Okay, nice, yeah.|
|好的，很好，是的。|

2510
01:28:49,790 --> 01:28:51,640
0,240 240,510 510,930 1110,1590
I mean like like
我的意思是，就像服务器被分配给一个单一的复制品。

2511
01:28:52,060 --> 01:28:53,260
0,480 480,570 570,810 810,870 870,1200
servers are assigned to one

2512
01:28:53,260 --> 01:28:55,840
0,360 360,1350
single replica.|
|

2513
01:28:56,110 --> 01:28:58,360
0,720 780,1050 1050,1500 1530,1920 1920,2250
Nice and then {} the
很好，然后第二个就像是直接从纸上出来的，非常精确，

2514
01:28:58,360 --> 01:29:00,370
0,270 270,360 360,750 750,1230 1620,2010
second one was like straight

2515
01:29:00,370 --> 01:29:01,270
0,120 120,240 240,570 570,660 660,900
from the paper and very

2516
01:29:01,270 --> 01:29:03,790
0,750 750,930 930,1080 1080,1620 1740,2520
precise,| but it says {}
|但这上面写的是“好吧，

2517
01:29:03,820 --> 01:29:06,140
0,570 600,1020 1020,1500 1530,2130
like okay here, {}|
|

2518
01:29:06,680 --> 01:29:09,710
0,810 870,1050 1050,1500 1500,2340 2340,3030
in I think generic cache
在我认为通用缓存页第二页中，

2519
01:29:09,740 --> 01:29:12,350
0,480 480,930 1350,1620 1620,2010 2010,2610
page two,| it says like
|它说像使用内存缓存作为更通用的键值存储

2520
01:29:12,740 --> 01:29:15,440
0,570 780,1500 1500,2040 2040,2190 2190,2700
{} use memcache as more

2521
01:29:15,500 --> 01:29:16,880
0,840 990,1110 1110,1230 1230,1290 1290,1380
general {key-value - - -}

2522
01:29:16,880 --> 01:29:19,130
0,660 750,990 990,1050 1050,1710 1710,2250
store| and I particularly say
|我特别要说的是，新服务利用现有的Marcher基础设施只需付出很小的努力

2523
01:29:19,160 --> 01:29:20,660
0,270 270,720 720,1020 1020,1380 1380,1500
it takes little effort for

2524
01:29:20,660 --> 01:29:22,580
0,210 210,690 690,810 810,1470 1590,1920
new services to leverage the

2525
01:29:22,580 --> 01:29:25,340
0,630 630,1110 1110,1920 1920,2580 2610,2760
existing marcher infrastructure| without the
|没有调整优化资源调配的负担

2526
01:29:25,340 --> 01:29:27,200
0,270 270,360 360,720 720,1230 1230,1860
burden of tuning optimizing provisioning|
|

2527
01:29:27,500 --> 01:29:29,030
0,210 210,930 930,1020 1020,1350 1350,1530
and maintaining a large sort
并保持着巨大的领先优势，

2528
01:29:29,030 --> 01:29:30,320
0,150 150,360 360,510 510,780 900,1290
of lead,| so I wasn't
|所以我不确定，我抬头看了看

2529
01:29:30,320 --> 01:29:31,070
0,180 180,270 270,330 330,600 600,750
sure and I looked up|
|

2530
01:29:31,070 --> 01:29:32,120
0,90 90,150 150,480 480,720 720,1050
and I couldn't find what
我找不到现有的游行者基础设施。

2531
01:29:32,150 --> 01:29:34,880
0,330 450,780 780,1410 1410,1830 1830,2730
like what's existing marcher infrastructure.|
|

2532
01:29:34,970 --> 01:29:36,140
0,270 270,480 480,690 690,840 840,1170
I don't actually know exactly
我其实不知道他们指的是什么，所以。

2533
01:29:36,140 --> 01:29:37,280
0,90 90,210 210,540 540,750 780,1140
what they're referring to, so.|
|

2534
01:29:37,310 --> 01:29:38,160
0,540
Okay,
好的，好的，谢谢。

2535
01:29:38,440 --> 01:29:42,000
0,1170 1500,2070 2310,2940
{all,right} cool, thanks.|
|

2536
01:29:42,430 --> 01:29:43,140
0,420
Okay.|
好吧。|

2537
01:29:43,460 --> 01:29:44,840
0,1320
{See,you}.|
再见。|

2538
01:29:49,200 --> 01:29:50,730
0,450 750,1050 1050,1110 1110,1410 1410,1530
I wanted to pull up
我想问一个问题，

2539
01:29:50,730 --> 01:29:51,540
0,120 120,240 240,600 600,690 690,810
on a question,| that I
|我想你问的是某种失败模式，

2540
01:29:51,540 --> 01:29:52,980
0,210 210,390 390,540 540,930 930,1440
think well you asked about

2541
01:29:53,010 --> 01:29:55,020
0,510 510,810 810,1170 1170,1710 1830,2010
a certain failure mode,| if
|如果Memcached服务器出现故障，

2542
01:29:55,020 --> 01:29:57,570
0,360 360,840 870,1110 1110,1650 1650,2550
{memcached - -} server fails,|
|

2543
01:29:58,540 --> 01:30:00,520
0,30 30,810 1230,1740 1740,1890 1890,1980
{} I think there's, {}|
我觉得有，|

2544
01:30:00,520 --> 01:30:01,750
0,420 420,630 630,840 840,1020 1020,1230
{I'm,trying} to think which slide
我在想哪张幻灯片会对我有所帮助，

2545
01:30:01,750 --> 01:30:02,710
0,90 90,210 210,480 480,540 540,960
would be helpful to look

2546
01:30:02,800 --> 01:30:03,840
0,720
at,|
|

2547
01:30:05,100 --> 01:30:08,790
0,1050 1410,2160 2160,3000 3120,3510 3510,3690
{} was earlier,| maybe that
是早些时候，|也许你刚才说的那个，

2548
01:30:08,790 --> 01:30:10,160
0,360 390,750 750,1140
one you just,|
|

2549
01:30:11,240 --> 01:30:12,080
0,210 210,450 450,600 600,750 750,840
just anything that kind of
就像任何显示Memcached的东西一样，

2550
01:30:12,080 --> 01:30:13,670
0,240 240,540 540,870 870,1350 1440,1590
shows {memcached -},| the the
|我想这是整个系统图。

2551
01:30:13,670 --> 01:30:15,410
0,390 390,690 690,1110 1110,1110 1110,1740
overall system diagram I guess.|
|

2552
01:30:15,470 --> 01:30:17,390
0,540 540,780 780,990 990,1530 1530,1920
Okay, well, the multiple [],|
好的，这个倍数[]，|

2553
01:30:18,200 --> 01:30:19,640
0,480 480,660 660,780 780,1050 1050,1440
but this is the one
但如果你愿意的话，这基本上就是你认为的一个单一星系团。

2554
01:30:19,640 --> 01:30:20,600
0,330 330,420 420,540 540,720 720,960
basically if you think about

2555
01:30:20,600 --> 01:30:21,500
0,120 120,180 180,450 450,810 810,900
as a single cluster, if

2556
01:30:21,500 --> 01:30:23,140
0,120 120,510 570,870 870,1410
you will.| Yeah, okay.|
|好的，好的。|

2557
01:30:23,660 --> 01:30:26,390
0,750 1080,1860 1860,2460 2460,2610 2610,2730
{} Yeah.| We look at
嗯。|我们再看另一个，

2558
01:30:26,390 --> 01:30:27,140
0,240 240,390 390,510 510,600 600,750
another one,| but I think
|但我认为这可能已经足够好了。

2559
01:30:27,140 --> 01:30:28,250
0,120 120,210 210,390 390,600 600,1110
this is sort of probably

2560
01:30:28,250 --> 01:30:29,510
0,150 150,450 930,1050 1050,1140 1140,1260
good enough.| Yeah, I think
|是的，我觉得这是，这很好，

2561
01:30:29,510 --> 01:30:30,830
0,120 120,480 510,690 690,810 810,1320
this is, this is good,|
|

2562
01:30:30,950 --> 01:30:31,960
0,690

2563
01:30:32,620 --> 01:30:33,670
0,150 150,270 270,480 480,630 630,1050
yeah, I think this question
是的，我想这个问题是，

2564
01:30:33,670 --> 01:30:35,960
0,780 1050,1920
was, {}|
|

2565
01:30:36,310 --> 01:30:41,140
0,1020 1320,2010 2220,2910 3390,4050 4170,4830
so, { -} {try,to},| but
所以，试着，|但这就像是，

2566
01:30:41,140 --> 01:30:42,310
0,90 90,180 180,480 480,750 750,1170
it was something about like,|
|

2567
01:30:42,460 --> 01:30:44,530
0,360 360,540 540,660 660,1770 1800,2070
{} if a client {}
如果客户端前端写入，

2568
01:30:44,530 --> 01:30:47,320
0,660 660,1350 1710,2550
frontend writes, {}|
|

2569
01:30:48,540 --> 01:30:49,890
0,180 180,300 300,360 360,750 780,1350
yeah, if a client writes
是的，如果客户端向其Memcached服务器写入数据

2570
01:30:49,890 --> 01:30:51,240
0,510 510,720 720,900 900,1170 1170,1350
to its {memcached - -}

2571
01:30:51,240 --> 01:30:53,220
0,690 900,1350 1350,1530 1530,1680 1680,1980
server| and that {memcached -
|然后Memcached服务器崩溃

2572
01:30:53,220 --> 01:30:55,380
0,150 150,510 510,1590 1650,2070 2070,2160
-} server crashes| and then
|然后客户端立即尝试，然后可能会切换到另一台Memcached服务器，

2573
01:30:55,380 --> 01:30:57,270
0,90 90,360 360,870 870,1410 1440,1890
the client immediately tries, then

2574
01:30:57,270 --> 01:30:58,680
0,210 210,390 390,960 960,1320 1320,1410
which is presumably switches to

2575
01:30:58,680 --> 01:31:00,660
0,480 480,1140 1140,1440 1440,1590 1590,1980
another {memcached - -} server,|
|

2576
01:31:00,660 --> 01:31:01,890
0,120 120,300 300,510 510,630 630,1230
and then read it again,|
然后再读一遍，|

2577
01:31:02,780 --> 01:31:04,280
0,240 240,990 990,1230 1230,1410 1410,1500
what mechanism makes sure it
是什么机制确保它不会看到它是之前写入的结果。

2578
01:31:04,280 --> 01:31:05,960
0,270 270,810 840,1020 1020,1290 1590,1680
doesn't see that it's a

2579
01:31:05,960 --> 01:31:07,250
0,300 300,360 360,630 630,990 990,1290
result of its previous write.|
|

2580
01:31:07,250 --> 01:31:08,360
0,120 120,390 390,570 570,720 720,1110
I I think what happens
我我认为发生的事情是我们很可能会陷入困境，

2581
01:31:08,360 --> 01:31:09,470
0,120 120,390 390,750 750,930 930,1110
is we probably go to

2582
01:31:09,470 --> 01:31:10,400
0,150 150,660
the gutter,|
|

2583
01:31:12,500 --> 01:31:13,790
0,330 330,480 480,780 780,990 990,1290
when the {memcached - -}
当内存缓存失败时，正确的，

2584
01:31:13,790 --> 01:31:15,530
0,510 510,870 870,1440 1440,1560 1560,1740
fails, correct,| client will get
|客户端将不会收到任何响应，

2585
01:31:15,530 --> 01:31:17,480
0,420 450,750 750,1200 1200,1680
{} no response back,|
|

2586
01:31:17,940 --> 01:31:20,250
0,960 1020,1470 1470,1950 1950,2130 2130,2310
and {} when that no
当没有回应的时候，

2587
01:31:20,250 --> 01:31:21,780
0,570 630,870 870,1140 1140,1260 1260,1530
response comes back,| it actually
|它实际上进入了排水沟，

2588
01:31:21,780 --> 01:31:22,860
0,210 210,330 330,450 450,840 840,1080
goes to the gutter,| which
|里面什么都没有，

2589
01:31:22,860 --> 01:31:25,230
0,210 210,630 630,780 780,1050 1410,2370
has nothing in it,| probably
|可能是第一次尝试

2590
01:31:25,230 --> 01:31:27,060
0,60 60,150 150,570 570,1230 1440,1830
in the first try| and
|并将从任何数据库中读取它。

2591
01:31:27,060 --> 01:31:28,170
0,210 210,420 420,600 600,840 840,1110
will read it from whatever

2592
01:31:28,170 --> 01:31:29,040
0,750
database.|
|

2593
01:31:31,230 --> 01:31:33,720
0,450 450,780 810,1410 1470,2040 2280,2490
Oh, okay, okay, that that
哦，好吧，好吧，这就说得通了。

2594
01:31:33,720 --> 01:31:34,840
0,300 300,900
makes sense.|
|

2595
01:31:35,410 --> 01:31:36,340
0,270 270,570 570,690 690,780 780,930
And yeah, it's a little
是的，这有一点不清楚

2596
01:31:36,340 --> 01:31:37,600
0,120 120,420 420,840 840,990 990,1260
bit unclear| exactly what happens
|当添加一台新机器时到底会发生什么，

2597
01:31:37,600 --> 01:31:38,440
0,120 120,180 180,330 330,630 630,840
when a new machine gets

2598
01:31:38,440 --> 01:31:39,460
0,450 480,630 630,720 720,840 840,1020
added,| you know they don't
|你知道他们并没有在报纸上谈论太多，

2599
01:31:39,460 --> 01:31:40,450
0,150 150,420 420,630 630,900 900,990
really talk much about in

2600
01:31:40,450 --> 01:31:41,300
0,90 90,570
the paper,|
|

2601
01:31:41,740 --> 01:31:43,660
0,270 270,1320 1350,1620 1620,1770 1770,1920
{} I presume this is
我认为这实际上是一致的行动部分，

2602
01:31:43,660 --> 01:31:45,760
0,360 360,810 810,1080 1080,1470 1500,2100
actually consistent action part,| where
|其中密钥将自动从一台机器转移到另一台机器。

2603
01:31:45,850 --> 01:31:47,770
0,420 420,660 690,990 990,1500 1500,1920
keys will be automatically shifted

2604
01:31:47,770 --> 01:31:49,000
0,180 180,390 390,690 690,780 780,1230
from one machine to another.|
|

2605
01:31:51,530 --> 01:31:53,540
0,930 1140,1290 1290,1770
{} I guess,
我想，如果有多个星团，

2606
01:31:53,730 --> 01:31:55,320
0,540 720,930 930,1050 1050,1170 1170,1590
what if there were multiple

2607
01:31:55,320 --> 01:31:59,130
0,1020 1410,1950 1950,2280 2550,3150 3330,3810
clusters,| wouldn't it not,| maybe
|难道不是吗？|或许我只需要读一读排水沟的故事，

2608
01:31:59,130 --> 01:31:59,760
0,90 90,210 210,300 300,360 360,630
I just need to read

2609
01:31:59,760 --> 01:32:00,690
0,240 240,330 330,570 570,690 690,930
about the gutter,| but wouldn't
|但它不会潜在地转移到另一个Memcached

2610
01:32:00,690 --> 01:32:02,670
0,300 390,870 870,1200 1200,1470 1470,1980
it potentially shift to another

2611
01:32:02,670 --> 01:32:03,780
0,180 180,480 480,660 660,960 960,1110
{memcached - -}| and oh
|哦，事实上，是的。

2612
01:32:03,780 --> 01:32:05,910
0,420 630,1500 1500,1650 1650,1950 1950,2130
actually, yeah.| I think it
|我想每次GET失败的时候，

2613
01:32:05,910 --> 01:32:08,300
0,570 570,1080 1080,1350 1350,2130
always when get fails,|
|

2614
01:32:08,570 --> 01:32:09,290
0,90 90,390 390,540 540,630 630,720
the client goes to the
这位客户走进了贫民窟。

2615
01:32:09,290 --> 01:32:10,060
0,480
gutter.|
|

2616
01:32:10,460 --> 01:32:11,640
0,870
Right.|
正确的。|

2617
01:32:12,120 --> 01:32:13,290
0,330 330,480 480,660 660,1080 1080,1170
Okay, yeah, these clusters are
好吧，是的，这些集群是自给自足的，

2618
01:32:13,290 --> 01:32:15,510
0,270 270,450 450,1380 1710,2070 2070,2220
kind of self-contained,| different and
|不同，然后是内存缓存。

2619
01:32:15,510 --> 01:32:17,310
0,180 180,270 270,450 450,930 1140,1800
then the {memcache -}.| Okay,
|好的，好的，这就说得通了，谢谢。

2620
01:32:17,400 --> 01:32:18,570
0,240 240,450 450,810 810,1020 1020,1170
okay, that makes, yeah that

2621
01:32:18,570 --> 01:32:19,580
0,150 150,420 420,780
makes perfect sense,

2622
01:32:20,150 --> 01:32:21,800
0,210 210,450 750,1080 1080,1170 1170,1650
thank you.| {You're,welcome -}.| Follow
|不用谢。|跟进这件事，

2623
01:32:22,280 --> 01:32:23,450
0,330 330,420 420,570 570,900 930,1170
follow up on that,| when
|当它退回到排水沟时

2624
01:32:23,450 --> 01:32:24,350
0,210 210,480 480,660 660,780 780,900
it falls back to the

2625
01:32:24,350 --> 01:32:26,090
0,330 330,630 840,1140 1140,1320 1320,1740
gutter| or what is like
|或者就像是两个不同的星团，

2626
01:32:26,240 --> 01:32:28,550
0,240 240,630 630,1590 1710,2130 2130,2310
two different clusters,| {} their
|他们的内存缓存服务器同时出现故障

2627
01:32:28,550 --> 01:32:30,170
0,180 180,630 630,990 990,1500 1500,1620
{memcache -} server fails at

2628
01:32:30,170 --> 01:32:31,160
0,90 90,360 360,720 720,870 870,990
the same time| and so
|所以他们都去了排水沟，

2629
01:32:31,160 --> 01:32:31,970
0,150 150,450 450,600 600,690 690,810
they both go to the

2630
01:32:31,970 --> 01:32:33,800
0,480 690,930 930,1230 1230,1560 1560,1830
gutter,| and now doing like
|现在，就像对沟槽进行并发写入一样，

2631
01:32:33,800 --> 01:32:35,360
0,480 480,870 870,960 960,1080 1080,1560
concurrent writes to the gutter,|
|

2632
01:32:35,840 --> 01:32:37,490
0,660 840,1200 1200,1260 1260,1380 1380,1650
{} how do we ensure
我们如何确保这些写入不会扰乱顺序？

2633
01:32:37,490 --> 01:32:38,630
0,180 180,480 480,750 750,960 960,1140
that those writes don't go

2634
01:32:38,630 --> 01:32:39,700
0,180 180,270 270,780
out of order?|
|

2635
01:32:40,870 --> 01:32:42,220
0,810 810,930 930,1050 1050,1200 1200,1350
{} You know they do
你知道他们做布景，对吧，

2636
01:32:42,220 --> 01:32:43,560
0,510 510,1050
sets, correct,|
|

2637
01:32:43,990 --> 01:32:47,320
0,510 510,1200 1200,2430 2580,2850 2880,3330
{} and the the writes
写操作总是从数据库转到主数据库，

2638
01:32:47,320 --> 01:32:50,290
0,240 240,390 390,570 570,1800 1890,2970
always go to the database

2639
01:32:50,730 --> 01:32:51,900
0,210 210,300 300,750 750,840 840,1170
to the primary,| the primary
|主要命令他们所有的人，

2640
01:32:51,900 --> 01:32:53,100
0,360 360,570 570,630 630,900
orders all of them,|
|

2641
01:32:55,260 --> 01:32:55,980
0,180 180,210 210,390 390,600 600,720
so I think writes are
所以我认为写作总是有顺序的，

2642
01:32:55,980 --> 01:32:57,220
0,390 390,930
always ordered,|
|

2643
01:32:58,930 --> 01:32:59,890
0,120 120,360 360,540 540,750 750,960
the only thing that you
您知道客户端可能会做的唯一一件事就是在KV服务器中设置或放置一个值，

2644
01:32:59,890 --> 01:33:01,360
0,150 150,1110
know the

2645
01:33:01,910 --> 01:33:03,290
0,480 480,660 660,960 960,1200 1200,1380
clients might do is go

2646
01:33:03,290 --> 01:33:04,700
0,330 330,390 390,960 960,1230 1230,1410
set a value in or

2647
01:33:04,700 --> 01:33:05,720
0,180 180,210 210,660 660,960 960,1020
put a value into the

2648
01:33:05,720 --> 01:33:06,920
0,210 210,420 420,900
{kv -} server,|
|

2649
01:33:07,710 --> 01:33:08,700
0,210 210,450 450,630 630,780 780,990
but then they have done
但他们在从数据库中读取数据后就这样做了。

2650
01:33:08,700 --> 01:33:10,020
0,180 180,630 630,810 810,1080 1080,1320
that after they read from

2651
01:33:10,020 --> 01:33:11,120
0,90 90,900
the database.|
|

2652
01:33:13,370 --> 01:33:14,540
0,360 360,540 540,690 690,810 810,1170
Right, so what if someone
对，所以如果有人做了一个，他们做了一个阅读，

2653
01:33:14,540 --> 01:33:16,340
0,120 120,450 450,900 900,1440 1530,1800
is like doing a, they

2654
01:33:16,340 --> 01:33:18,530
0,300 300,510 510,1080 1560,1950 1950,2190
do a read,| {} and
|然后他们将其设置到数据库中，

2655
01:33:18,530 --> 01:33:19,760
0,210 210,390 390,810 810,1020 1020,1230
then they're setting it into

2656
01:33:19,760 --> 01:33:22,100
0,120 120,630 630,960 1230,1680 1890,2340
the database,| but like let's
|但就像假设两个不同的集群发生故障一样，

2657
01:33:22,100 --> 01:33:23,840
0,120 120,360 360,660 660,1110 1110,1740
say two different clusters fail,|
|

2658
01:33:23,990 --> 01:33:26,360
0,690 1110,1260 1260,1770 2040,2220 2220,2370
{} and then I'm not
然后我不确定这是否真的可能，

2659
01:33:26,360 --> 01:33:27,410
0,120 120,180 180,390 390,780 780,1050
sure if this possible actually,|
|

2660
01:33:27,410 --> 01:33:29,540
0,150 150,300 300,420 420,1470 1530,2130
but let's say like one,
但是比方说，集群1首先从一个键中读取，取回值

2661
01:33:29,600 --> 01:33:31,430
0,450 450,810 810,1170 1170,1650 1650,1830
cluster one first reads from

2662
01:33:31,430 --> 01:33:32,450
0,90 90,450 480,720 720,960 960,1020
a key, gets back the

2663
01:33:32,450 --> 01:33:33,830
0,570 660,870 870,1080 1080,1260 1260,1380
value| and then there's a
|然后在中间写一个字，

2664
01:33:33,830 --> 01:33:35,690
0,270 270,420 420,1110 1320,1590 1590,1860
write in between,| and then
|然后，第二个集群读取

2665
01:33:35,690 --> 01:33:37,580
0,90 90,450 450,1050 1050,1290 1290,1890
the second cluster then reads|
|

2666
01:33:37,610 --> 01:33:38,390
0,210 210,300 300,420 420,600 600,780
and then they both try
然后他们都试着把他们的内存缓存服务器，

2667
01:33:38,390 --> 01:33:39,290
0,90 90,330 330,540 540,690 690,900
to put into their {memcache

2668
01:33:39,290 --> 01:33:41,920
0,270 270,990 1410,1890
-} servers,| but,
|但是，假设这些服务器出了故障。

2669
01:33:42,500 --> 01:33:44,510
0,420 420,630 630,1080 1110,1560 1560,2010
but let's say those servers

2670
01:33:44,510 --> 01:33:46,370
0,480 480,900 900,1290 1290,1560 1560,1860
failed.| Yeah, maybe, yeah maybe,|
|是的，也许，是的，也许，|

2671
01:33:46,370 --> 01:33:48,470
0,1110 1110,1260 1260,1380 1380,1770 1770,2100
yeah, it's a good question,|
是啊，这是个好问题，|

2672
01:33:48,470 --> 01:33:49,190
0,60 60,240 240,390 390,510 510,720
I think there's all kinds
我认为有各种各样的小角落案件，

2673
01:33:49,190 --> 01:33:50,270
0,60 60,270 270,510 510,870 870,1080
of little corner cases,| that
|实际上并不能描述这个案例，

2674
01:33:50,270 --> 01:33:51,380
0,240 240,420 420,690 690,780 780,1110
actually not describe the case,|
|

2675
01:33:51,470 --> 01:33:52,640
0,180 180,180 180,630 630,900 900,1170
I I think maybe leases
我觉得租约也许能帮上忙，

2676
01:33:52,640 --> 01:33:54,530
0,150 150,390 390,750 750,1320 1470,1890
will help out,| because that
|因为您要设置的服务器没有租约，

2677
01:33:54,560 --> 01:33:55,880
0,600 600,750 750,930 930,1200 1200,1320
server you're gonna set to

2678
01:33:55,880 --> 01:33:57,720
0,270 270,750 780,1110 1110,1740
doesn't have the lease,|
|

2679
01:33:57,860 --> 01:34:01,400
0,1050 1050,1470 1470,2220 3030,3360 3360,3540
for, {} the first one
因为，我们第一次拿回了正确的片场租约，

2680
01:34:01,400 --> 01:34:02,750
0,90 90,270 270,600 600,780 780,1350
we did get a {lease,back}

2681
01:34:02,750 --> 01:34:04,000
0,330 330,420 420,510 510,960
correct to the set,|
|

2682
01:34:04,210 --> 01:34:08,800
0,720 1230,2010 2040,2790 2790,4320 4320,4590
{} and {} if in
如果在此期间，

2683
01:34:08,800 --> 01:34:09,730
0,60 60,420 420,480 480,750 750,930
the meantime,| the servers gets
|服务器被替换

2684
01:34:09,730 --> 01:34:11,830
0,690 900,1080 1080,1590 1590,1920 1920,2100
replaced| the replacement server does
|替换服务器不知道租约实际上已被授予

2685
01:34:11,830 --> 01:34:13,480
0,270 270,630 630,840 840,1530 1530,1650
not know that actually the

2686
01:34:13,480 --> 01:34:15,400
0,210 210,330 330,840 1260,1740 1740,1920
lease was granted| and so
|因此会拒绝布景，

2687
01:34:15,400 --> 01:34:16,540
0,150 150,450 450,510 510,900
will reject the set,|
|

2688
01:34:18,410 --> 01:34:20,930
0,210 210,360 360,900 900,1230 1530,2520
I'm just speculating, correct.| Okay,
我只是在猜测，没错。|好吧，是的，所以对于排水沟来说，

2689
01:34:20,960 --> 01:34:23,030
0,540 540,1110 1290,1560 1560,1680 1680,2070
yeah, so for the gutter,|
|

2690
01:34:23,030 --> 01:34:24,500
0,210 210,420 420,630 660,1110 1110,1470
how does it control leases
它如何控制那里的租约。

2691
01:34:24,500 --> 01:34:25,240
0,480
there.|
|

2692
01:34:25,460 --> 01:34:27,830
0,240 240,480 480,870 1170,1950 2190,2370
I don't know.| Okay, I
我不知道。|好的，我明白了。

2693
01:34:27,830 --> 01:34:28,460
0,450
see.|
|

2694
01:34:28,830 --> 01:34:31,680
0,630 1920,2010 2010,2130 2130,2670 2670,2850
Sorry, I can speculate,| but
抱歉，我可以推测，|但你知道，你知道，我当然不知道。

2695
01:34:31,680 --> 01:34:34,050
0,270 270,750 750,1350 1350,1740 1770,2370
you know you know certainly

2696
01:34:34,050 --> 01:34:34,940
0,30 30,180 180,450
I don't know.|
|

2697
01:34:36,430 --> 01:34:37,240
0,240 240,420 420,540 540,660 660,810
{} What would you say,
如果让你去推测，你会怎么说？

2698
01:34:37,240 --> 01:34:38,260
0,90 90,180 180,330 330,390 390,1020
if you had to speculate?|
|

2699
01:34:39,100 --> 01:34:40,750
0,900 960,1170 1170,1350 1350,1560 1560,1650
Well, I would first have
好吧，我得先去坐下来

2700
01:34:40,750 --> 01:34:41,470
0,90 90,270 270,450 450,630 630,720
to go sit down| and
|好好想一想。

2701
01:34:41,470 --> 01:34:42,280
0,150 150,240 240,480 480,600 600,810
think a little bit about

2702
01:34:42,280 --> 01:34:45,430
0,210 990,1500 1530,1740 1740,2190 2580,3150
it.| Okay, makes sense, yeah,
|好的，有道理，是的，谢谢你。

2703
01:34:45,640 --> 01:34:46,480
0,210 210,570
thank you.|
|

2704
01:34:49,120 --> 01:34:49,870
0,210 210,270 270,420 420,480 480,750
{I,have} a bit of a
我有一个离题的问题，

2705
01:34:49,870 --> 01:34:52,030
0,480 480,900 900,1110 1110,1530 1560,2160
tangential question,| which is, {}
|也就是说，我认为他们对GET请求使用UDP，对其他请求使用TCP，这真的很酷，

2706
01:34:52,660 --> 01:34:53,560
0,240 240,390 390,600 600,780 780,900
{I,thought} {it,was} really cool that

2707
01:34:53,560 --> 01:34:54,670
0,90 90,180 180,540 540,660 660,1110
they were using {UDP -}

2708
01:34:54,670 --> 01:34:55,990
0,150 150,270 270,600 600,1080 1080,1320
for the get request and

2709
01:34:55,990 --> 01:34:57,370
0,570 570,690 690,780 780,1260 1260,1380
TCP for the others,| and
|我想知道这有多普遍，

2710
01:34:57,370 --> 01:34:58,540
0,30 30,150 150,450 450,750 750,1170
I was wondering how common

2711
01:34:58,540 --> 01:34:59,590
0,180 180,420 420,660 660,840 840,1050
that is,| {is,that} like a
|这是一件非常标准的事情吗？

2712
01:34:59,620 --> 01:35:00,500
0,540
very

2713
01:35:01,060 --> 01:35:03,220
0,540 540,750 750,840 840,1320 1440,2160
standard thing to do?| Yes,
|是的，是的，也不是，

2714
01:35:03,220 --> 01:35:05,840
0,360 360,450 450,1020 1050,2160
yes and no, {}|
|

2715
01:35:06,320 --> 01:35:08,720
0,630 870,1110 1110,1410 1410,1560 1560,2400
{} it is, you know
它是，你知道，我认为人们通常更喜欢使用TCP提供可靠性排序和所有好的很好的东西，

2716
01:35:08,780 --> 01:35:10,190
0,210 210,360 360,720 720,1050 1050,1410
I think people prefer generally

2717
01:35:10,190 --> 01:35:12,260
0,90 90,360 360,930 1110,1500 1500,2070
to use TCP provides reliability

2718
01:35:12,260 --> 01:35:13,130
0,390 390,480 480,600 600,660 660,870
ordering and all the good

2719
01:35:13,130 --> 01:35:14,840
0,240 240,690 900,1260 1260,1440 1440,1710
great stuff,| but there's real
|但它有真正的管理费用，

2720
01:35:14,840 --> 01:35:15,950
0,510 510,660 660,870 900,1020 1020,1110
overheads with it,| you know
|您知道，就像您知道需要为连接、连接维护的状态

2721
01:35:15,950 --> 01:35:17,450
0,240 240,1140 1200,1290 1290,1380 1380,1500
like the you know the

2722
01:35:17,450 --> 01:35:18,170
0,240 240,360 360,540 540,600 600,720
state that needs to be

2723
01:35:18,170 --> 01:35:20,690
0,450 450,960 960,1410 1410,2010 2010,2520
maintained for connections, for connection|
|

2724
01:35:20,960 --> 01:35:21,920
0,240 240,360 360,570 570,930 930,960
and so there's always a
所以总会有一些挣扎，

2725
01:35:21,920 --> 01:35:22,790
0,150 150,240 240,330 330,390 390,870
little bit of {} struggle,|
|

2726
01:35:22,790 --> 01:35:24,260
0,450 450,900 900,990 990,1350 1350,1470
when machines a lot of
当机器有大量传入的TCP连接时，

2727
01:35:24,260 --> 01:35:26,150
0,750 750,1080 1110,1440 1440,1830 1830,1890
incoming {} TCP connection,| a
|有很多出站连接，

2728
01:35:26,150 --> 01:35:27,800
0,180 180,300 300,660 660,1290 1440,1650
lot of outbound connections, {}|
|

2729
01:35:27,800 --> 01:35:30,500
0,180 180,420 420,780 780,1350 1860,2700
that always causes problems| and
这总会带来问题|在默认情况下，你知道如果你遇到这个问题

2730
01:35:30,740 --> 01:35:32,450
0,330 330,930 930,1020 1020,1650 1650,1710
{} in the default, you

2731
01:35:32,450 --> 01:35:33,410
0,300 300,420 420,630 630,840 840,960
know if you run into

2732
01:35:33,410 --> 01:35:34,610
0,180 180,540 540,660 660,840 840,1200
that problem is| to basically
|基本上是做UDP类型的东西。

2733
01:35:34,610 --> 01:35:35,690
0,150 150,360 360,540 540,780 780,1080
do {UDP -} type stuff.|
|

2734
01:35:38,580 --> 01:35:40,350
0,510 510,600 600,840 840,1470 1470,1770
Sometimes.| {} Like normal from
有时候。|像这张报纸上写的那样正常吗？

2735
01:35:40,350 --> 01:35:44,360
0,300 300,900 1260,2040 2040,3690
this paper?| No, {not,from,this,paper}.|
|不，不是从这份报纸上。|

2736
01:35:45,990 --> 01:35:47,010
0,210 210,420 420,510 510,660 660,1020
Some people like to roll
有些人喜欢在UDP上使用他们自己的类似可靠传输的关键技术。

2737
01:35:47,010 --> 01:35:47,910
0,180 180,330 330,510 510,660 660,900
their own sort of like

2738
01:35:47,910 --> 01:35:49,770
0,600 600,1080 1080,1440 1440,1740 1740,1860
reliably transport critical over {UDP

2739
01:35:49,770 --> 01:35:50,560
0,120 120,480
- -}.|
|

2740
01:35:51,040 --> 01:35:52,220
0,300 300,900
Like quick?|
要快点吗？|

2741
01:35:52,460 --> 01:35:54,140
0,510 540,1350
Yep, {for,example}.|
例如，是的。|

2742
01:35:55,800 --> 01:35:56,940
0,270 270,660 660,780 780,1080 1080,1140
Yeah, because they mentioned they
是的，因为他们提到他们也喜欢顺序号UDP连接关闭。

2743
01:35:56,940 --> 01:35:58,920
0,300 300,510 510,990 990,1410 1410,1980
also do like sequence numbers

2744
01:36:00,060 --> 01:36:01,840
0,630 630,1170 1170,1530
UDP connections down.|
|

2745
01:36:02,960 --> 01:36:05,270
0,390 390,660 660,1050 1050,1500 1500,2310
But persumably overtake congestion windows
但毫无疑问地超过了拥塞窗口和所有其他扩展

2746
01:36:05,270 --> 01:36:06,620
0,180 180,390 390,480 480,750 750,1350
and all the other scaling|
|

2747
01:36:06,620 --> 01:36:07,700
0,120 120,360 360,450 450,660 660,1080
and all the other TCP
以及tcp拥有的所有其他tcp功能。

2748
01:36:07,700 --> 01:36:09,220
0,360 360,480 480,900 900,1290
features that TCP has.|
|

2749
01:36:10,650 --> 01:36:12,570
0,330 330,570 570,990 1290,1440 1440,1920
{} Thank you.| You're welcome.|
谢谢。|不用谢。|

2750
01:36:18,300 --> 01:36:20,240
0,360 360,840 840,1080 1080,1620
So, another, oops, sorry,
所以，再来一次，哦，对不起，继续。

2751
01:36:20,480 --> 01:36:21,220
0,420
{go,ahead}.|
|

2752
01:36:25,180 --> 01:36:26,860
0,210 210,480 480,600 600,1050 1140,1680
{} Okay, I guess, {}
好吧，我想，我只是想快速询问一下不同星团之间的复制情况，

2753
01:36:26,860 --> 01:36:27,970
0,240 240,480 480,690 690,750 750,1110
I just wanted to quickly

2754
01:36:27,970 --> 01:36:29,520
0,330 330,690 720,1230
ask about {}

2755
01:36:29,850 --> 01:36:31,290
0,270 270,330 330,450 450,1080 1080,1440
Kind of the replication between

2756
01:36:31,290 --> 01:36:33,930
0,90 90,390 390,1170 1380,2070 2070,2640
the different clusters,| but basically
|但基本上，他们不会进行任何正式的复制。

2757
01:36:33,930 --> 01:36:35,100
0,150 150,360 360,480 480,720 720,1170
they don't do any formal

2758
01:36:35,100 --> 01:36:37,770
0,630 630,1050 1050,1530 1560,2010 2010,2670
replication.| {Yeah,that} correctly,| well, yeah,
|是的，正确地说，|好吧，是的，不，好吧，是或不是，对，

2759
01:36:38,190 --> 01:36:41,460
0,1410 1530,2190 2700,2940 2940,3000 3000,3270
no, well, yes or no,

2760
01:36:41,460 --> 01:36:42,960
0,210 210,480 480,600 600,750 750,1500
right,| because you know the
|因为你知道数据库需要更新，

2761
01:36:42,990 --> 01:36:44,340
0,480 480,630 630,690 690,840 840,1350
database need to be updated,|
|

2762
01:36:45,120 --> 01:36:46,320
0,330 330,480 480,690 690,840 840,1200
hold on, hold on,| let
等等，等等，|让我回到过去，确保你知道你在说什么。

2763
01:36:46,320 --> 01:36:47,370
0,150 150,390 390,510 510,810 810,1050
me actually go back and

2764
01:36:47,370 --> 01:36:48,660
0,300 630,780 780,1110 1110,1200 1200,1290
{} make sure you know

2765
01:36:48,660 --> 01:36:49,840
0,150 150,240 240,510 510,870
what you're talking about.|
|

2766
01:36:51,070 --> 01:36:53,900
0,420 420,660 660,780 780,1260
Let's see {clusters -},|
让我们来看看星团，|

2767
01:36:54,120 --> 01:36:55,380
0,240 240,330 330,420 420,690 690,1260
yeah, we have multiple clusters,|
是的，我们有多个星团，|

2768
01:36:55,530 --> 01:36:56,760
0,240 240,390 390,570 570,780 780,1230
yeah there's no real replication
是的，集群之间没有真正的复制，对吧，

2769
01:36:56,760 --> 01:36:57,870
0,210 210,360 360,600 600,660 660,1110
going on between the clusters,

2770
01:36:57,870 --> 01:36:59,070
0,240 240,510 510,720 720,960 960,1200
right,| because there's one single
|因为里面只有一个储藏室。

2771
01:36:59,070 --> 01:37:00,080
0,360 360,420 420,720
storage in there.|
|

2772
01:37:01,890 --> 01:37:03,780
0,390 390,540 540,750 750,1410 1530,1890
Right, and so there are
对，所以有一些类似于根据这些租约来保持缓存最新的或。

2773
01:37:03,810 --> 01:37:05,610
0,390 390,480 480,720 720,1260 1260,1800
kind of like depending on

2774
01:37:05,610 --> 01:37:07,740
0,420 420,1170 1170,1560 1590,2010 2010,2130
these leases to keep the

2775
01:37:07,740 --> 01:37:09,570
0,360 360,630 630,870 870,1200 1200,1830
cache is {up-to-date -} or.|
|

2776
01:37:10,260 --> 01:37:11,580
0,450 450,690 690,960 960,1230 1230,1320
The the every cluster is
每个集群都是完全独立的，

2777
01:37:11,580 --> 01:37:12,840
0,390 390,960
completely independent,|
|

2778
01:37:13,380 --> 01:37:14,190
0,240 240,360 360,630 630,690 690,810
they have nothing to do
他们彼此之间没有任何关系，

2779
01:37:14,190 --> 01:37:15,040
0,90 90,210 210,540
with each other,|
|

2780
01:37:15,820 --> 01:37:18,370
0,600 600,1320 1620,1860 1860,2310 2310,2550
and users are divided over
用户在这些问题上存在分歧，

2781
01:37:18,370 --> 01:37:19,380
0,150 150,750
these questions,|
|

2782
01:37:20,280 --> 01:37:21,360
0,270 270,420 420,630 630,840 840,1080
and so one user talks
因此，一个用户与一个集群对话

2783
01:37:21,360 --> 01:37:24,810
0,90 90,270 270,900 900,2010 2490,3450
to one cluster| and {}
|然后你知道在集群内，你知道他们使用租赁或，

2784
01:37:24,810 --> 01:37:26,010
0,300 300,690 690,840 840,930 930,1200
and then you know within

2785
01:37:26,010 --> 01:37:27,030
0,90 90,570 570,690 690,810 810,1020
the cluster, you know they

2786
01:37:27,030 --> 01:37:28,200
0,330 330,990
use leases

2787
01:37:28,620 --> 01:37:29,860
0,630
or,|
|

2788
01:37:31,630 --> 01:37:34,210
0,330 330,750 840,1440 1440,2040 2040,2580
and this database invalidates leases
并且该数据库使租约和密钥无效。

2789
01:37:34,360 --> 01:37:35,420
0,240 240,750
and keys.|
|

2790
01:37:36,650 --> 01:37:38,000
0,330 330,570 570,960 990,1170 1170,1350
Right, {got,it}, okay,| yeah, so
好的，明白了，好的，|是的，所以这就像尖叫声和仓库[]。

2791
01:37:38,000 --> 01:37:38,930
0,150 150,270 270,360 360,840 840,930
it's like the squeal and

2792
01:37:38,930 --> 01:37:42,530
0,90 90,780 1140,1500 2640,3390 3390,3600
the storage [].| Yeah, {all,the}
|是的，所有的写入基本上都会正确地通过这个存储，

2793
01:37:42,530 --> 01:37:44,000
0,390 390,870 870,1110 1110,1290 1290,1470
writes basically and just go

2794
01:37:44,000 --> 01:37:46,040
0,300 300,420 420,960 960,1380 1740,2040
through this storage correct,| all
|所有的写作都要经过这里，

2795
01:37:46,040 --> 01:37:47,440
0,300 300,420 420,630 630,1140
writes go through here,|
|

2796
01:37:49,240 --> 01:37:50,700
0,390 390,600 600,1170
they get ordered,|
他们被点餐了，|

2797
01:37:51,260 --> 01:37:52,490
0,540 540,630 630,750 750,960 960,1230
and you know they pop
你知道，它们会弹出无效消息。

2798
01:37:52,490 --> 01:37:54,500
0,420 420,990 990,1590
out invalidation messages.|
|

2799
01:37:57,660 --> 01:37:59,520
0,480 480,960 990,1200 1200,1500
{Got,it} [], thank you.|
明白了，谢谢。|

2800
01:38:03,320 --> 01:38:06,770
0,780 810,1620 1650,3090 3090,3120 3120,3450
Yeah, {go,ahead}.| Yeah, {} so
好的，去吧。|是的，所以这个离题的问题，

2801
01:38:06,770 --> 01:38:09,620
0,690 750,1740 1770,2550
tangential question, {}|
|

2802
01:38:10,400 --> 01:38:11,150
0,150 150,300 300,480 480,570 570,750
{} I guess I'm not
我想我不确定这是不是，

2803
01:38:11,150 --> 01:38:12,140
0,120 120,270 270,660 660,930 930,990
sure this is,| because of
|因为我们在课堂上展示论文的方式，

2804
01:38:12,140 --> 01:38:13,370
0,90 90,270 270,750 780,990 990,1230
the way we've kind of

2805
01:38:13,370 --> 01:38:15,230
0,570 570,960 960,1080 1080,1170 1170,1860
presented papers in the class,|
|

2806
01:38:15,350 --> 01:38:17,390
0,480 480,780 990,1500 1500,1590 1590,2040
but it kind of seems
但这看起来有点像，

2807
01:38:17,390 --> 01:38:18,340
0,690
like,|
|

2808
01:38:18,780 --> 01:38:21,180
0,960 1230,1740 1740,1950 1950,2340 2340,2400
the way these systems are
这些系统的开发方式是

2809
01:38:21,180 --> 01:38:22,440
0,450 450,570 570,840 840,1140 1140,1260
developed is| like okay, we
|就像好的，我们有这样的系统，我们的需求在继续扩大，

2810
01:38:22,440 --> 01:38:23,400
0,240 240,690
have like

2811
01:38:23,740 --> 01:38:25,510
0,210 210,750 750,990 990,1620 1620,1770
{} these these systems like

2812
01:38:25,510 --> 01:38:26,620
0,180 180,420 420,540 540,1020 1020,1110
our needs are continuing to

2813
01:38:26,620 --> 01:38:28,930
0,510 510,630 630,1290 1380,2010 2130,2310
scale,| so let's like maybe
|所以让我们假设也许这也不是一个准确的表达，

2814
01:38:28,930 --> 01:38:29,590
0,150 150,210 210,450 450,570 570,660
this is also not an

2815
01:38:29,590 --> 01:38:31,180
0,330 330,990 990,1170 1170,1350 1350,1590
accurate representation,| but it sounds
|但这听起来像是让我们再增加一层来处理这个负载，

2816
01:38:31,180 --> 01:38:32,830
0,180 180,330 330,540 540,930 930,1650
like let's add another layer

2817
01:38:33,360 --> 01:38:34,830
0,120 120,420 420,780 810,1230 1230,1470
to kind of handle this

2818
01:38:34,830 --> 01:38:36,090
0,600 600,660 660,810 810,1080 1080,1260
load,| or that kind of
|或者那种你知道的缓存东西，或者在它上面增加另一层复杂性，

2819
01:38:36,120 --> 01:38:37,860
0,120 120,240 240,570 570,1260 1260,1740
you know cache something or

2820
01:38:38,130 --> 01:38:39,600
0,240 240,660 660,870 870,930 930,1470
add another layer of complexity

2821
01:38:39,600 --> 01:38:41,190
0,90 90,300 300,420 420,780 1380,1590
on top of it,| is
|公平地说，类似的系统开发通常是这样的，

2822
01:38:41,190 --> 01:38:43,110
0,270 270,1320 1320,1500 1500,1740 1740,1920
it fair to say that

2823
01:38:43,110 --> 01:38:44,670
0,150 150,510 510,1020 1020,1200 1200,1560
like system development has generally

2824
01:38:44,670 --> 01:38:46,260
0,180 180,690 870,1140 1140,1380 1380,1590
been like,| let's just add
|让我们再加一层来处理吧。

2825
01:38:46,260 --> 01:38:47,850
0,450 450,1110 1110,1230 1230,1500 1500,1590
another layer to kind of

2826
01:38:47,850 --> 01:38:48,620
0,270 270,630
deal with.|
|

2827
01:38:48,920 --> 01:38:51,230
0,660 690,1170 1170,1230 1230,1770 1830,2310
{} Yes or no,| I
是或不是，|我认为设计师制度采取了非常务实的方式，

2828
01:38:51,230 --> 01:38:52,880
0,390 390,660 660,1080 1080,1470 1470,1650
think the designer system took

2829
01:38:52,880 --> 01:38:54,110
0,30 30,270 270,660 660,1110 1110,1230
a very pragmatic approach,| you
|你知道，弄清楚遇到了真正的问题，解决了真正的问题，

2830
01:38:54,110 --> 01:38:55,280
0,210 210,630 630,840 840,1080 1080,1170
know figure out like {}

2831
01:38:55,280 --> 01:38:56,390
0,270 270,450 450,540 540,720 720,1110
run into a real problem

2832
01:38:56,390 --> 01:38:57,620
0,240 300,600 600,690 690,870 870,1230
and solve the real problem,|
|

2833
01:38:58,280 --> 01:39:00,890
0,600 600,1140 1140,1740 1740,2250 2250,2610
{} and {} in basically
从根本上来说，你想的并不是很多额外的机制

2834
01:39:00,890 --> 01:39:01,910
0,120 120,270 270,480 480,630 630,1020
you think about it not

2835
01:39:01,910 --> 01:39:03,050
0,30 30,210 210,270 270,660 660,1140
a lot of additional mechanism|
|

2836
01:39:03,860 --> 01:39:05,030
0,150 150,780 780,960 960,1050 1050,1170
to actually make it all
才能真正让这一切运转起来，

2837
01:39:05,030 --> 01:39:07,010
0,450 750,1320 1320,1560 1560,1680 1680,1980
work,| {} so in terms
|所以从这个角度来说，

2838
01:39:07,010 --> 01:39:09,260
0,240 750,990 1020,1590 1590,1830 1830,2250
of,| I mean I mean
|我的意思是，我认为这是非常令人印象深刻的，这种表演

2839
01:39:09,260 --> 01:39:10,520
0,330 330,480 480,600 600,810 810,1260
I think it's pretty impressive

2840
01:39:10,520 --> 01:39:11,900
0,420 420,540 540,720 720,810 810,1380
and this kind of performance|
|

2841
01:39:11,900 --> 01:39:13,430
0,150 150,390 390,630 630,870 870,1530
and they've often shelf components,|
而且他们经常会把部件放在架子上|

2842
01:39:14,090 --> 01:39:17,810
0,870 1170,1920 2490,3300 3300,3510 3510,3720
{} the absolute people also
绝对的人也会偶尔回去，

2843
01:39:17,810 --> 01:39:18,530
0,120 120,420 420,600 600,660 660,720
go back once in a

2844
01:39:18,530 --> 01:39:19,520
0,150 150,210 210,540 540,720 720,990
while,| {} said okay, how
|回答：好的，我该如何设计一个系统来获得更好的性能

2845
01:39:19,520 --> 01:39:20,840
0,150 150,450 450,780 780,840 840,1320
would I design a system

2846
01:39:20,840 --> 01:39:23,180
0,420 420,630 630,870 870,1800 2070,2340
to get better performance| and
|例如，数据库和缓存之间不会有这种不一致，

2847
01:39:23,180 --> 01:39:24,170
0,210 210,270 270,630 630,840 840,990
don't for example have this

2848
01:39:24,170 --> 01:39:25,880
0,810 810,1050 1050,1110 1110,1560 1560,1710
inconsistency between the database and

2849
01:39:25,880 --> 01:39:26,540
0,600
caches,|
|

2850
01:39:27,120 --> 01:39:29,970
0,810 840,960 960,2220 2220,2580 2580,2850
and you know it actually
你知道，这实际上是一个研究问题，

2851
01:39:29,970 --> 01:39:31,260
0,180 180,270 270,330 330,840 840,1290
turns out to be a

2852
01:39:31,260 --> 01:39:33,630
0,240 240,750 1110,1530 1530,2130 2130,2370
research problem,| because people figured
|因为人们知道如何做到这一点

2853
01:39:33,630 --> 01:39:34,590
0,270 270,450 450,510 510,630 630,960
out how to do that|
|

2854
01:39:34,590 --> 01:39:35,850
0,360 360,510 510,780 780,960 960,1260
and so you'll see recent
因此，您将看到描述替代解决方案的最新研究论文

2855
01:39:35,850 --> 01:39:37,650
0,300 300,690 690,990 990,1350 1350,1800
research papers that describe alternative

2856
01:39:37,650 --> 01:39:38,440
0,600
solutions|
|

2857
01:39:39,680 --> 01:39:41,150
0,480 510,840 840,1320 1320,1380 1380,1470
or new components of the
或解决方案的新组件，

2858
01:39:41,150 --> 01:39:43,580
0,480 480,720 720,900 900,2070 2160,2430
solution,| because like {you,know} any
|因为就像你知道我所知道的任何提议一样，

2859
01:39:43,580 --> 01:39:44,510
0,120 120,210 210,570 570,630 630,930
of the proposals I know

2860
01:39:44,510 --> 01:39:45,980
0,270 570,780 780,1140 1140,1440 1440,1470
of,| {you,know} cannot support a
|你知道，它不能支持每秒10亿次操作。

2861
01:39:45,980 --> 01:39:47,540
0,300 300,750 750,870 870,1230
billion operations per second.|
|

2862
01:39:47,770 --> 01:39:49,320
0,750 780,1260
Yeah, right.|
是啊，没错。|

2863
01:39:50,880 --> 01:39:52,800
0,330 330,510 510,990 1290,1620 1620,1920
Okay, that's interesting, thank you.|
好的，这很有趣，谢谢。|

2864
01:39:52,950 --> 01:39:54,750
0,270 270,450 450,660 660,1290 1290,1800
Yeah, this is fascinating stuff,|
是啊，这是很吸引人的东西，|

2865
01:39:54,900 --> 01:39:57,270
0,240 240,390 390,570 570,1350 1950,2370
it's like a {real,world} system
这就像一个真实世界的系统设计。

2866
01:39:57,270 --> 01:39:58,040
0,510
design.|
|

2867
01:39:59,040 --> 01:40:00,030
0,390 390,570 570,690 690,870 870,990
{} I have one more
如果你不介意的话，我还有一个问题。

2868
01:40:00,030 --> 01:40:01,110
0,390 390,510 510,600 600,750 750,1080
question, if you don't mind.|
|

2869
01:40:01,290 --> 01:40:04,290
0,300 300,1050 1080,1470 1470,2190 2640,3000
Yeah, {go,ahead}.| {} So in
好的，去吧。|所以在这里的设计中，

2870
01:40:04,290 --> 01:40:05,520
0,120 120,570 570,870 870,1110 1110,1230
the design here,| where they
|它们在不同的地区复制，

2871
01:40:05,520 --> 01:40:07,770
0,570 570,900 900,1290 1290,1800 1950,2250
replicate across different regions,| so
|很抱歉，我要澄清的第一个问题是，

2872
01:40:07,770 --> 01:40:09,090
0,300 300,480 480,540 540,900 900,1320
sorry just to clarify when

2873
01:40:09,270 --> 01:40:10,680
0,180 180,420 420,990 990,1290 1290,1410
the first clarification question I

2874
01:40:10,680 --> 01:40:11,550
0,150 150,480 510,690 690,750 750,870
have is,| when they were
|当他们在不同的地区表现良好时，

2875
01:40:11,550 --> 01:40:13,710
0,300 300,660 660,990 990,1620 1650,2160
okay against different regions,| {each,region}
|每个区域都有一堆内部集群，对吧。

2876
01:40:13,710 --> 01:40:15,480
0,450 450,690 690,900 900,1140 1200,1770
has a bunch of internal

2877
01:40:15,480 --> 01:40:17,580
0,660 660,1200
clusters, right.|
|

2878
01:40:17,880 --> 01:40:20,310
0,210 210,690 870,1170 1170,1650 1920,2430
And then, {} my follow-up
然后，我的后续问题是，

2879
01:40:20,310 --> 01:40:21,480
0,330 330,390 390,630 630,1020 1050,1170
question to that is,| it
|看起来一切都是，

2880
01:40:21,480 --> 01:40:22,860
0,270 270,390 390,900 900,1170 1170,1380
seems like everything is,| yeah
|是的，所有东西都在访问主存储，

2881
01:40:22,860 --> 01:40:24,210
0,300 300,420 420,750 750,870 870,1350
everything is hitting the primary

2882
01:40:24,210 --> 01:40:25,200
0,750
storage,|
|

2883
01:40:25,500 --> 01:40:26,670
0,300 300,480 480,600 600,780 780,1170
if let's say we wanted
假设我们想要扩大规模，

2884
01:40:26,670 --> 01:40:27,960
0,90 90,480 480,870 870,1080 1080,1290
to scale up,| so that
|这样我们就不会让所有写操作都命中主存储，

2885
01:40:27,960 --> 01:40:29,310
0,120 120,450 450,960 1020,1230 1230,1350
we didn't have all the

2886
01:40:29,310 --> 01:40:31,140
0,270 270,630 630,750 750,1200 1200,1830
writes hitting the primary storage,|
|

2887
01:40:31,680 --> 01:40:32,970
0,300 300,450 450,600 600,870 870,1290
how would you go about
你将如何着手设计。

2888
01:40:33,090 --> 01:40:35,910
0,810 840,1740 1860,2100 2100,2220 2220,2820
designing.| Yeah, {} my suspicion
|是的，我的怀疑是，它们实际上是一种设计，描述得不错，

2889
01:40:35,910 --> 01:40:38,010
0,270 270,510 510,990 990,1470 1470,2100
is that, they're actually a

2890
01:40:38,580 --> 01:40:40,500
0,540 540,960 960,1140 1140,1470
design described okay,| so
|所以有一大堆要点，

2891
01:40:40,850 --> 01:40:41,870
0,210 210,270 270,450 450,510 510,1020
there's a bunch of points,|
|

2892
01:40:41,870 --> 01:40:43,160
0,330 330,390 390,600 600,840 840,1290
there's a whole other paper
关于这个主题还有一整篇论文是关于如何进行复制的，

2893
01:40:43,160 --> 01:40:44,510
0,240 240,420 420,780 780,1080 1080,1350
on this topic about actually

2894
01:40:44,510 --> 01:40:45,650
0,270 270,360 360,510 510,600 600,1140
how to do the replication,|
|

2895
01:40:46,340 --> 01:40:47,780
0,810 810,990 990,1170 1170,1260 1260,1440
{} so this is not
因此，这并不是Facebook上唯一一篇关于扩大规模的文章

2896
01:40:47,780 --> 01:40:48,860
0,90 90,270 270,600 600,960 960,1080
the only Facebook paper on

2897
01:40:48,860 --> 01:40:50,180
0,300 300,510 510,780 810,1170 1170,1320
scaling things up| and there's
|有一个系统是在2015年或[]发布的，

2898
01:40:50,180 --> 01:40:51,560
0,60 60,330 330,1050 1050,1320 1320,1380
a system was published in

2899
01:40:51,560 --> 01:40:53,580
0,1050 1050,1710
{2015,or} [],|
|

2900
01:40:53,850 --> 01:40:55,980
0,750 750,1620 1650,1920 1920,2040 2040,2130
{} were you know they
您是否知道他们有一个可扩展的设计来传播这些写入，

2901
01:40:55,980 --> 01:40:57,600
0,240 240,570 570,960 960,1350 1350,1620
have a scalable design to

2902
01:40:57,600 --> 01:41:00,600
0,510 510,690 690,1260 1620,2280 2580,3000
propagate these writes,| {} my
|我的意思也是，他们会或已经将用户分割到特定的地区，

2903
01:41:00,600 --> 01:41:01,980
0,480 480,570 570,870 870,1080 1080,1380
speaking is also that they

2904
01:41:01,980 --> 01:41:04,620
0,600 600,900 900,1410 1440,1920 1920,2640
will or have a shard

2905
01:41:04,950 --> 01:41:07,440
0,180 180,690 690,1230 1230,1890 1920,2490
the users to a particular

2906
01:41:07,440 --> 01:41:08,320
0,690
regions,|
|

2907
01:41:08,620 --> 01:41:11,470
0,840 840,930 930,1560 1710,2220 2220,2850
and {} make some regions,
并使一些地区成为这些用户的主要地区。

2908
01:41:11,470 --> 01:41:13,300
0,240 240,780 780,930 930,1200 1200,1830
the primary for those users.|
|

2909
01:41:16,040 --> 01:41:17,690
0,240 240,510 510,720 720,1140 1170,1650
I see, so they assigned
我明白了，所以他们为不同的碎片分配了不同的区域初选。

2910
01:41:17,690 --> 01:41:19,640
0,300 300,840 840,1500 1500,1650 1650,1950
different regions primaries for different

2911
01:41:19,640 --> 01:41:21,470
0,720 930,1290 1290,1380 1380,1530 1530,1830
shards.| Yeah, I think so,|
|是的，我想是的，|

2912
01:41:21,620 --> 01:41:22,430
0,300 300,450 450,540 540,690 690,810
that's why I would do,
这就是为什么我会这样做，我们正在尝试这样做，

2913
01:41:22,430 --> 01:41:23,600
0,300 300,540 540,600 600,900
we're trying to do,|
|

2914
01:41:24,370 --> 01:41:26,020
0,180 180,330 330,870 870,1170 1170,1650
and I'm speculating here now.|
我现在在这里推测。|

2915
01:41:28,170 --> 01:41:29,160
0,240 240,300 300,450 450,570 570,990
Would it be a wise
像跨存储层的共识协议那样做是不是明智的决定，

2916
01:41:29,160 --> 01:41:30,990
0,510 510,690 690,960 960,1200 1200,1830
decision to do like consensus

2917
01:41:30,990 --> 01:41:32,910
0,570 570,930 930,1020 1020,1530 1530,1920
protocol across the storage layers,|
|

2918
01:41:32,910 --> 01:41:33,870
0,150 150,300 300,570 570,810 810,960
or would that just be
或者会不会太高了，你知道。

2919
01:41:33,870 --> 01:41:35,610
0,300 390,600 600,1050 1500,1590 1590,1740
like too high you know.|
|

2920
01:41:35,610 --> 01:41:36,900
0,240 240,390 390,510 510,1020 1020,1290
You could do that, like
你可以这样做，就像扳手那样，对吧。

2921
01:41:36,900 --> 01:41:38,280
0,300 300,570 570,780 780,1140
Spanner does that, correct.|
|

2922
01:41:39,410 --> 01:41:41,540
0,510 870,1290 1290,1590 1590,1680 1680,2130
Right.| {And,how} fast is spanner?|
正确的。|扳手有多快？|

2923
01:41:43,140 --> 01:41:44,100
0,210 210,720
Pretty fast.|
挺快的。|

2924
01:41:44,570 --> 01:41:46,460
0,630 750,1380 1380,1530 1530,1770 1770,1890
{} You look back into
你回头看看它，再看看桌子，

2925
01:41:46,460 --> 01:41:47,600
0,150 150,360 360,540 540,660 660,1140
it back into the table,|
|

2926
01:41:47,870 --> 01:41:49,130
0,210 210,510 510,960 960,1020 1020,1260
how many transactions per second
每秒可以处理多少笔交易？

2927
01:41:49,130 --> 01:41:49,960
0,210 210,510
could do?|
|

2928
01:41:51,040 --> 01:41:52,900
0,780 810,930 930,1080 1080,1470 1470,1860
{} I do not remember
我记不清确切的数字了。

2929
01:41:52,900 --> 01:41:54,360
0,90 90,480 480,1170
the exact number.|
|

2930
01:41:54,560 --> 01:41:55,700
0,120 120,270 270,510 510,570 570,1140
I think about a hundred.|
我想大概有一百个。|

2931
01:41:57,690 --> 01:41:59,490
0,570 570,1140 1140,1320 1320,1470 1470,1800
{Oh,oh}.| {In,fact}, for {I,think} write
哦哦。|事实上，因为我想写第十区。

2932
01:41:59,490 --> 01:42:00,620
0,420 420,810
area ten.|
|

2933
01:42:01,400 --> 01:42:02,480
0,390 390,600 600,690 690,900 900,1080
Right, this is for write
对，这是写业务，对。

2934
01:42:02,480 --> 01:42:04,850
0,750 750,1260 1530,1920 1920,2160 2160,2370
transactions, right.| Right, the write,
|对，写，写事务都很慢。

2935
01:42:04,850 --> 01:42:06,110
0,120 120,330 330,960 960,1020 1020,1260
the write transactions are very

2936
01:42:06,110 --> 01:42:07,580
0,660
slow.|
|

2937
01:42:11,550 --> 01:42:13,860
0,510 540,1290 1350,1830 1860,2040 2040,2310
{} Sorry, {} I think
对不起，我想我意识到我不了解第一场比赛。

2938
01:42:13,860 --> 01:42:15,180
0,480 510,960 960,1050 1050,1170 1170,1320
I realized that I do

2939
01:42:15,180 --> 01:42:17,560
0,210 210,840 1080,1560 1560,2040
not understand race one.|
|

2940
01:42:17,710 --> 01:42:19,300
0,510 840,1260 1260,1350 1350,1470 1470,1590
Okay, let me see if
好吧，让我看看我能不能复制它。

2941
01:42:19,300 --> 01:42:22,200
0,60 60,270 270,660 660,1890
I can replicate it.|
|

2942
01:42:22,960 --> 01:42:24,820
0,390 390,690 690,1170 1170,1500 1500,1860
Now let's see where we
现在让我们看看我们在哪里比赛一场。

2943
01:42:24,820 --> 01:42:25,860
0,300 300,660
race one.|
|

2944
01:42:27,490 --> 01:42:28,960
0,270 270,510 510,660 660,840 840,1470
I think I'm just confused
我想我只是搞不懂什么是v2。

2945
01:42:28,960 --> 01:42:30,840
0,270 270,540 540,840 840,1560
what is {v2 -}.|
|

2946
01:42:32,350 --> 01:42:33,790
0,390 390,720 720,870 870,1230 1230,1440
Um, {v2 -} is this,
嗯，v2是这样的，对。

2947
01:42:33,790 --> 01:42:34,620
0,510
right.|
|

2948
01:42:35,660 --> 01:42:37,100
0,870 870,1140
{Hold,on,I'll,mark} it.|
稍等，我来做个记号。|

2949
01:42:39,360 --> 01:42:40,260
0,600
Okay.|
好吧。|

2950
01:42:42,430 --> 01:42:43,900
0,360 360,570 570,1020 1020,1140 1140,1470
And the problem is that,|
问题是，|

2951
01:42:43,900 --> 01:42:46,210
0,120 120,420 420,870 1140,1890 2100,2310
it is like wedged in
它就像是夹在第一个中间。

2952
01:42:46,210 --> 01:42:48,560
0,420 420,540 540,1380 1380,2070
between the first one.|
|

2953
01:42:51,810 --> 01:42:52,760
0,660
Okay.|
好吧。|

2954
01:42:55,100 --> 01:42:58,580
0,600 1830,2400 2400,3000
Okay, so like,
好的，就像，我们想把它删除，

2955
01:42:58,820 --> 01:42:59,540
0,150 150,420 420,540 540,630 630,720
we wanted it to be

2956
01:42:59,540 --> 01:43:01,160
0,450 450,570 570,900 1140,1380 1380,1620
deleted,| so that the next
|以便下一个人可以从数据库中读取、刷新它，

2957
01:43:01,160 --> 01:43:02,800
0,360 360,720 750,1350
person can read,

2958
01:43:03,400 --> 01:43:05,320
0,510 510,660 660,750 750,1530 1560,1920
{refresh,it} from the database,| but
|但现在它仍然保持着旧的价值。

2959
01:43:05,320 --> 01:43:06,310
0,210 210,450 450,780 780,930 930,990
now it's there with the

2960
01:43:06,310 --> 01:43:08,050
0,240 240,810 840,1290 1290,1440 1440,1740
old value.| Yeah, so basically
|是的，所以基本上我们有一个永久稳定的值，

2961
01:43:08,050 --> 01:43:09,040
0,90 90,210 210,300 300,720 720,990
we have a permanent stable

2962
01:43:09,040 --> 01:43:10,150
0,330 360,660 660,750 750,1020 1020,1110
value,| really the issue is
|真正的问题是这个永久的业务，或者你允许在引号之间，对吗，

2963
01:43:10,150 --> 01:43:11,660
0,180 180,630 630,1170
this permanent business,

2964
01:43:13,090 --> 01:43:14,770
0,360 360,510 510,1020 1020,1290 1290,1680
or you permitted between quotes,

2965
01:43:14,770 --> 01:43:16,150
0,240 240,480 480,600 600,660 660,1380
correct,| because it's a cache,
|因为这是个宝藏，但就像你知道的，

2966
01:43:16,390 --> 01:43:18,160
0,660 660,960 960,1200 1200,1380 1380,1770
{} but like {you,know} this,

2967
01:43:18,160 --> 01:43:19,820
0,480 750,1410
this put,|
|

2968
01:43:20,060 --> 01:43:22,670
0,930 960,1350 1350,1620 1620,2370 2430,2610
{} that came after you
这是在你知道基本上k是k被更新到v2之后，

2969
01:43:22,670 --> 01:43:25,280
0,90 90,510 510,1230 1230,2130 2160,2610
know basically the {k,be} k

2970
01:43:25,280 --> 01:43:27,320
0,390 420,660 660,1110 1560,1830 1830,2040
the {k - -} being

2971
01:43:27,320 --> 01:43:28,910
0,510 720,840 840,1050 1050,1350 1350,1590
updated to {v2 -},| so
|所以我们这里有k2，对吗，

2972
01:43:28,910 --> 01:43:30,350
0,150 150,330 330,660 660,1080 1080,1440
we have k 2 here

2973
01:43:30,350 --> 01:43:31,400
0,360 360,630 630,810 810,990 990,1050
really, correct,| that's what the
|这就是正确的价值所在，

2974
01:43:31,400 --> 01:43:33,050
0,210 210,510 510,660 660,990 1380,1650
right value should be,| and
|这里实际上是v1，

2975
01:43:33,050 --> 01:43:34,280
0,450 450,780 780,960 960,1080 1080,1230
here actually this is {v1

2976
01:43:34,280 --> 01:43:35,270
0,360 360,540 540,720 720,870 870,990
-},| so let's say there's
|所以我们假设只有1，

2977
01:43:35,270 --> 01:43:36,160
0,180 180,600
just 1,|
|

2978
01:43:36,440 --> 01:43:37,460
0,240 240,360 360,570 570,930 930,1020
what we've done here is,|
我们在这里所做的是，|

2979
01:43:37,460 --> 01:43:40,460
0,810 960,1320 1320,1950 1980,2370 2640,3000
we took a {key,1} in
后来我们拿了一把钥匙进去，

2980
01:43:40,460 --> 01:43:41,500
0,690
after,|
|

2981
01:43:41,820 --> 01:43:42,960
0,810

2982
01:43:43,220 --> 01:43:44,120
0,270 270,450 450,630 630,810 810,900
and that's just not the
这不是一件正确的事情。

2983
01:43:44,120 --> 01:43:44,980
0,210 210,540
right thing.|
|

2984
01:43:47,440 --> 01:43:49,390
0,810 810,1260 1260,1440 1440,1650 1650,1950
{} Everybody that comes after
现在每个追随的人

2985
01:43:49,390 --> 01:43:51,040
0,390 390,630 630,900 930,1350 1350,1650
now| and doesn't get on
|相处得不好，很好，

2986
01:43:51,190 --> 01:43:52,480
0,540 540,870 870,990 990,1140 1140,1290
okay great,| we're gonna get
|我们要拿回1而不是2。

2987
01:43:52,480 --> 01:43:53,680
0,240 240,510 510,750 750,840 840,1200
1 back instead of 2.|
|

2988
01:43:54,540 --> 01:43:55,890
0,480 480,600 600,780 780,1140 1170,1350
Okay, that makes sense, okay.|
好的，这说得通，好的。|

2989
01:43:55,890 --> 01:43:57,570
0,150 150,630 630,990 990,1380 1440,1680
{} Including client 2, which
包括客户端2，这将是奇怪的。

2990
01:43:57,570 --> 01:43:58,860
0,150 150,270 270,330 330,600 600,1290
is going to be bizarre.|
|

2991
01:43:59,770 --> 01:44:01,810
0,480 840,1290 1440,1740 1740,1860 1860,2040
Right, right, okay that makes
好的，好的，这很有道理，非常感谢。

2992
01:44:01,810 --> 01:44:03,550
0,450 600,930 930,1050 1050,1230 1230,1740
sense, thank you so much.|
|

2993
01:44:03,610 --> 01:44:04,520
0,180 180,600
You're welcome.|
不用谢。|

2994
01:44:04,950 --> 01:44:05,850
0,150 150,270 270,480 480,780 780,900
I will take part in
我会在一开始就参加关于进化的讨论，我认为这也是相当有帮助的。

2995
01:44:05,850 --> 01:44:07,890
0,90 90,510 510,1080 1110,1380 1380,2040
the beginning about the evolution

2996
01:44:07,890 --> 01:44:09,900
0,180 180,510 510,1110 1260,1800 1800,2010
was also pretty helpful, I

2997
01:44:09,900 --> 01:44:12,510
0,360 390,840 840,1170 1350,1770 1860,2610
think.| Okay, good good.| Thank
|好的，很好很好。|非常感谢。

2998
01:44:12,510 --> 01:44:14,100
0,60 60,240 240,810 870,1110 1110,1590
you so much.| You're welcome.
|不用谢。
