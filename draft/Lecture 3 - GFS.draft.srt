1
00:00:00,060 --> 00:00:01,290
0,270 270,540 750,1020 1020,1140 1140,1230
Works again.| Okay, so the
又起作用了。|好的，今天的计划是关于 GFS ，

2
00:00:01,290 --> 00:00:02,850
0,240 240,360 360,690 690,1170 1200,1560
plan for today is talking

3
00:00:02,850 --> 00:00:04,230
0,120 120,720 750,1050 1050,1230 1230,1380
about GFS,| I'm gonna do
|我会分多个步骤来做。

4
00:00:04,230 --> 00:00:05,190
0,120 120,330 330,540 540,600 600,960
it in sort of multiple

5
00:00:05,190 --> 00:00:08,160
0,690 1140,1530 1530,2190 2250,2790 2790,2970
steps.| {} One I'm gonna
|首先，我会从总体上谈一下存储，

6
00:00:08,160 --> 00:00:08,820
0,150 150,210 210,390 390,510 510,660
talk a little bit about

7
00:00:08,820 --> 00:00:10,980
0,390 390,450 450,1020 1020,1440 1440,2160
storage in general,| and why
|为什么它如此重要，

8
00:00:11,640 --> 00:00:14,460
0,240 240,600 600,1620 2040,2610 2610,2820
it's so important,| and why
|以及为什么我们花很多时间

9
00:00:14,460 --> 00:00:15,180
0,210 210,450 450,480 480,660 660,720
we spend a lot of

10
00:00:15,180 --> 00:00:16,710
0,360 360,660 660,990 990,1260 1260,1530
time| in this class talking
|在这堂课上讨论它。

11
00:00:16,710 --> 00:00:17,580
0,210 210,420
about it.|
|

12
00:00:17,930 --> 00:00:20,660
0,690 870,1620 2040,2520 2520,2580 2580,2730
Then I'm going to talk
然后我将讨论一下，

13
00:00:20,660 --> 00:00:22,070
0,30 30,240 240,390 390,780 780,1410
a little bit about {}|
|

14
00:00:22,640 --> 00:00:24,260
0,180 180,390 390,450 450,1170 1170,1620
in terms of GFS and
从 GFS 的角度，以及它的主要设计，

15
00:00:24,260 --> 00:00:26,150
0,120 120,360 360,1020 1200,1710 1710,1890
it's main design,| {} we'll
|我们重点关注一致性，

16
00:00:26,150 --> 00:00:27,920
0,540 540,750 750,1410 1410,1620 1620,1770
focus on consistency,| which will
|它是这堂课的主要主题，

17
00:00:27,920 --> 00:00:29,840
0,240 240,540 540,930 930,1590 1590,1920
be the main theme through

18
00:00:29,840 --> 00:00:32,000
0,180 180,690 1260,1740 1740,1980 1980,2160
this lecture,| {} as part
|作为一致性的一部分，

19
00:00:32,000 --> 00:00:33,710
0,90 90,180 180,750 750,1530 1530,1710
of the consistency,| {you,know} we
|我们很可能这样，

20
00:00:33,710 --> 00:00:35,600
0,540 540,750 750,1020 1680,1770 1770,1890
probably I do,| hopefully there's
|希望还有时间进入分组会议室，

21
00:00:35,600 --> 00:00:36,680
0,150 150,570 570,660 660,990 990,1080
still time to {breakout -}

22
00:00:36,680 --> 00:00:37,340
0,60 60,120 120,360 360,480 480,660
of the room,| and talk
|讨论一下，分组会议关于课程，

23
00:00:37,340 --> 00:00:38,540
0,30 30,240 240,390 390,840 1050,1200
a little bit about the

24
00:00:38,540 --> 00:00:40,420
0,420 420,660 660,990 990,1230
breakout rooms about the

25
00:00:40,570 --> 00:00:42,220
0,720 720,810 810,870 870,1470 1470,1650
lecture,| or the question was
|或者课程贴出的问题，

26
00:00:42,220 --> 00:00:43,900
0,330 330,570 570,1020 1020,1380 1380,1680
posed for lecture,| and we'll
|我们将继续讨论一致性的问题。

27
00:00:43,900 --> 00:00:46,930
0,600 600,1320 1320,1560 1560,2100 2430,3030
resume discussion of { -}

28
00:00:47,680 --> 00:00:49,680
0,720 720,1380
of consistency.|
|

29
00:00:50,920 --> 00:00:53,100
0,390 390,990 990,1590
Okay, so, {}|
好的，所以，|

30
00:00:53,100 --> 00:00:53,730
0,120 120,270 270,300 300,510 510,630
{let,me} talk a little bit
让我来总体上地讨论一下存储系统，

31
00:00:53,730 --> 00:00:55,590
0,480 480,870 870,1230 1230,1290 1290,1860
about storage systems in general,|
|

32
00:00:56,220 --> 00:00:57,930
0,420 420,780 780,990 990,1260 1260,1710
and why they so feature
以及为什么它们在 6.824 中占据重要地位，

33
00:00:57,930 --> 00:01:00,630
0,180 180,1080 1170,1740 1740,2220 2250,2700
so prominently {} in {6.824

34
00:01:00,630 --> 00:01:02,880
0,240 240,420 420,900 1650,2100 2100,2250
- - -},| and the
|主要原因是，

35
00:01:02,880 --> 00:01:05,010
0,360 360,690 690,1110 1140,1770 1770,2130
main reason is,| {} it's
|它是一个神奇的构建组件，

36
00:01:05,010 --> 00:01:06,870
0,270 270,390 390,990 990,1350 1350,1860
just a fantastic building block,|
|

37
00:01:07,510 --> 00:01:13,420
0,990 1440,2040 3000,3660 3660,4290
for {} {fault,tolerance} systems.|
用于容错系统。|

38
00:01:13,840 --> 00:01:15,130
0,180 180,300 300,420 420,720 720,1290
And so the basic idea
所以基本的想法是，

39
00:01:15,130 --> 00:01:17,380
0,120 120,360 360,1290 1920,2130 2130,2250
is that,| if you if
|如果你能建立一个持久的存储系统，

40
00:01:17,380 --> 00:01:19,750
0,120 120,450 450,900 900,1230 1230,2370
you can build an durable

41
00:01:19,750 --> 00:01:22,330
0,780 810,1170 1170,1860 1980,2460 2460,2580
storage {} system,| then you
|然后你可以构建你的应用程序，

42
00:01:22,330 --> 00:01:23,110
0,90 90,450 450,630 630,690 690,780
can structure sort of {your,application

43
00:01:23,110 --> 00:01:25,330
0,750 750,1620 1830,2010 2010,2130 2130,2220
-} as| you know the
|应用程序无状态的，

44
00:01:25,330 --> 00:01:28,030
0,300 300,390 390,1230 1440,2220 2370,2700
app is basically you know

45
00:01:28,030 --> 00:01:29,520
0,690
{state,less},|
|

46
00:01:31,680 --> 00:01:33,660
0,390 390,990 990,1080 1080,1560 1560,1980
and then the storage holds
然后存储保存所有的持久状态。

47
00:01:33,660 --> 00:01:36,360
0,210 210,600 720,1290 1290,1860
all the persistent state.|
|

48
00:01:39,660 --> 00:01:41,340
0,180 180,360 360,1050 1050,1260 1260,1680
And that simplifies the design
这极大地简化了应用程序的设计，

49
00:01:41,340 --> 00:01:43,080
0,120 120,210 210,480 480,1200
of the app tremendously,|
|

50
00:01:43,270 --> 00:01:45,730
0,480 480,1080 1110,1470 1470,2250 2310,2460
{} because {the,app} basically you
因为应用程序没有任何持久的存储空间，

51
00:01:45,730 --> 00:01:47,650
0,360 420,960 960,1260 1260,1740 1740,1920
know doesn't really have any

52
00:01:47,650 --> 00:01:48,940
0,330 330,840 840,990 990,1080 1080,1290
stable storage,| you know that
|它必须保持自己，

53
00:01:48,940 --> 00:01:50,140
0,300 300,450 450,540 540,780 780,1200
it has to maintain itself,|
|

54
00:01:50,140 --> 00:01:51,040
0,90 90,390 390,540 540,660 660,900
in fact is a fact
事实上，这些都在存储系统，

55
00:01:51,040 --> 00:01:52,270
0,270 270,480 480,690 690,810 810,1230
that all out to storage

56
00:01:52,270 --> 00:01:53,890
0,450 750,990 990,1140 1140,1260 1260,1620
system,| so you can start
|所以，你可以非常快速地启动新的应用程序，

57
00:01:53,890 --> 00:01:55,960
0,150 150,570 600,1290 1290,1860 1860,2070
up a new application very

58
00:01:55,960 --> 00:01:57,250
0,540 540,630 630,780 780,900 900,1290
quickly,| you know it crash
|它崩溃并不重要，

59
00:01:57,250 --> 00:01:58,420
0,210 210,420 420,780 780,1050 1050,1170
doesn't really matter,| because it
|因为它只有软状态，没有任何硬状态，

60
00:01:58,420 --> 00:01:59,950
0,240 240,360 360,660 660,960 960,1530
only has soft state, not

61
00:01:59,950 --> 00:02:01,420
0,180 180,450 450,810 1020,1200 1200,1470
any hard state,| {and,then} start
|然后再重新启动，

62
00:02:01,420 --> 00:02:02,560
0,150 150,630 630,810 810,870 870,1140
up again,| when you start
|当你重新启动时，

63
00:02:02,560 --> 00:02:03,640
0,150 150,420 420,600 600,780 780,1080
up again,| you just reach
|你就从分布式存储系统进入状态。

64
00:02:03,640 --> 00:02:05,080
0,450 450,630 630,720 720,1140 1140,1440
state from the distributed storage

65
00:02:05,080 --> 00:02:05,880
0,390
system.|
|

66
00:02:06,340 --> 00:02:07,240
0,210 210,420 420,540 540,720 720,900
And you can see this
你可以在任何网站上看到这个，

67
00:02:07,240 --> 00:02:09,070
0,210 210,900 900,1080 1080,1260 1260,1830
quick look at any website,|
|

68
00:02:09,070 --> 00:02:10,270
0,120 120,540 540,930 930,1020 1020,1200
{you,know} basically structured in that
基本上就是这样构建的，

69
00:02:10,270 --> 00:02:12,310
0,300 450,690 690,990 990,1470 1470,2040
way,| there's a storage backend,
|有一个存储后端，用来保持状态，

70
00:02:12,310 --> 00:02:14,020
0,210 210,330 330,600 600,1230 1320,1710
you know that maintains {}

71
00:02:14,020 --> 00:02:15,610
0,420 420,510 510,1080 1080,1380 1380,1590
state,| and then there's the
|然后是应用程序，

72
00:02:15,610 --> 00:02:18,610
0,870 1260,1770 1770,2070 2070,2820 2820,3000
application,| {} middle tier that
|参与应用程序计算的中间层，

73
00:02:18,610 --> 00:02:20,380
0,210 210,300 300,720 720,1020 1020,1770
does the application specific computation,|
|

74
00:02:20,380 --> 00:02:22,030
0,90 90,420 420,630 630,1290 1290,1650
or whatever runs Javascript Go
或者运行 Javascript Go 的程序，

75
00:02:22,030 --> 00:02:23,980
0,60 60,750 930,1410 1410,1860 1860,1950
or whatever,| {} and you
|它的前端在，

76
00:02:23,980 --> 00:02:24,970
0,120 120,300 300,510 510,780 780,990
know it front ends that

77
00:02:24,970 --> 00:02:26,590
0,360 360,480 480,720 720,1110 1110,1620
out| you know to a
|在互联网上的客户端。

78
00:02:26,620 --> 00:02:28,100
0,450 450,570 570,660 660,1140
client on the Internet.|
|

79
00:02:28,280 --> 00:02:30,740
0,540 750,990 990,1350 1380,2040 2040,2460
And, {} so storage just
所以，存储像一个神奇的构建组件,

80
00:02:30,740 --> 00:02:32,810
0,150 150,270 270,1080 1110,1650 1650,2070
like this fantastic building block,|
|

81
00:02:32,810 --> 00:02:33,380
0,210 210,270 270,420 420,510 510,570
and I think this is
我想这是一个原因，

82
00:02:33,380 --> 00:02:34,250
0,270 270,540 540,630 630,750 750,870
one reason,| that we're going
|为什么我们会在这节课上反复看到这个。

83
00:02:34,250 --> 00:02:35,390
0,240 240,480 480,690 690,1020 1020,1140
to see this over and

84
00:02:35,390 --> 00:02:37,460
0,600 600,750 750,930 930,1650
over in this class.|
|

85
00:02:37,700 --> 00:02:39,290
0,480 660,960 960,1230 1230,1440 1440,1590
{} That means that you
这意味着存储系统本身，

86
00:02:39,290 --> 00:02:40,490
0,120 120,330 360,660 660,870 870,1200
know the storage system itself,|
|

87
00:02:40,490 --> 00:02:41,120
0,60 60,270 270,420 420,510 510,630
of course has to be
当然必须具有高度的容错性，

88
00:02:41,120 --> 00:02:42,770
0,330 330,570 570,1050 1260,1470 1470,1650
highly fault tolerant,| and as
|这是一件非常棘手的事情，

89
00:02:42,770 --> 00:02:43,310
0,60 60,270 270,390 390,450 450,540
it turns out to be

90
00:02:43,310 --> 00:02:44,240
0,120 120,390 390,660 660,840 840,930
a very tricky thing to

91
00:02:44,240 --> 00:02:45,920
0,420 420,840 840,1020 1020,1230 1230,1680
do,| and {} so that
|这就是另一个方面，

92
00:02:45,920 --> 00:02:48,290
0,270 930,1440 1470,1860 1860,2100 2100,2370
is {} the other side,|
|

93
00:02:48,290 --> 00:02:49,130
0,90 90,300 300,540 540,630 630,840
the flip side of it,|
另一方面，|

94
00:02:49,220 --> 00:02:49,970
0,150 150,240 240,450 450,690 690,750
it will make life of
它使应用程序的生命周期变得简单，

95
00:02:49,970 --> 00:02:51,260
0,90 90,630 630,990 990,1200 1200,1290
the application easy,| but you
|但是设计容错存储系统并不容易。

96
00:02:51,260 --> 00:02:52,910
0,150 150,390 390,1080 1080,1470 1470,1650
know the designing actually fault

97
00:02:52,910 --> 00:02:54,560
0,300 690,1080 1080,1320 1320,1410 1410,1650
tolerant storage system is not

98
00:02:54,560 --> 00:02:55,260
0,300
easy.|
|

99
00:02:55,710 --> 00:02:56,850
0,180 180,390 390,480 480,570 570,1140
So why is it hard,|
那么为什么这么难，|

100
00:03:00,480 --> 00:03:02,730
0,480 780,1440 1440,1560 1560,1920 1920,2250
and basically come down to
可以归结为一个原因，

101
00:03:02,730 --> 00:03:05,100
0,840 870,960 960,1020 1020,1830 1950,2370
{} you know one reason,|
|

102
00:03:05,100 --> 00:03:07,200
0,120 120,870 900,1260 1260,1620 1620,2100
that drives {} these designs,|
驱动这些设计，|

103
00:03:07,200 --> 00:03:08,280
0,180 180,330 330,540 540,690 690,1080
which is like we generally
我们通常希望获得高性能，

104
00:03:08,280 --> 00:03:10,290
0,180 180,330 330,1050 1710,1890 1890,2010
want high performance,| when you
|当你考虑今天的存储系统，

105
00:03:10,290 --> 00:03:11,550
0,180 180,480 480,750 750,990 990,1260
think about the storage system

106
00:03:11,550 --> 00:03:13,410
0,150 150,780 900,1200 1200,1380 1380,1860
for today,| you know GFS
|GFS 的主要目标是，

107
00:03:13,470 --> 00:03:14,760
0,390 390,660 660,1080 1080,1200 1200,1290
its main goal is| to
|支持 mapreduce 类型的应用程序，

108
00:03:14,760 --> 00:03:16,470
0,360 360,900 900,1140 1140,1440 1440,1710
basically support {mapreduce -} types

109
00:03:16,470 --> 00:03:18,180
0,690 690,810 810,1170 1230,1560 1560,1710
applications,| and so, {} it
|所以，它需要高性能。

110
00:03:18,180 --> 00:03:20,190
0,270 270,750 750,1050 1050,1290 1290,2010
really needs {} high performance.|
|

111
00:03:20,580 --> 00:03:21,960
0,450 450,630 630,720 720,900 900,1380
Well, what does that mean,|
好的，那是什么意思，|

112
00:03:21,990 --> 00:03:22,890
0,210 210,300 300,570 570,720 720,900
well, it means that you
这意味着你必须跨服务器对数据分片，

113
00:03:22,890 --> 00:03:26,490
0,420 420,630 630,900 930,2040 2100,3600
typically have to shard data

114
00:03:27,060 --> 00:03:32,790
0,960 1170,1830 3600,4530 4530,5040 5130,5730
across servers,| {so,you,cant't,use} one server,|
|所以你不能使用一台服务器，|

115
00:03:32,790 --> 00:03:33,690
0,90 90,210 210,300 300,480 480,900
you have to use multiple
你必须使用多台服务器，

116
00:03:33,690 --> 00:03:35,160
0,150 570,900 900,1140 1140,1380 1380,1470
servers,| and the reason you
|你想要从磁盘中读取的原因，

117
00:03:35,160 --> 00:03:36,570
0,150 150,240 240,510 510,1230 1290,1410
want to read from the

118
00:03:36,570 --> 00:03:38,640
0,450 450,600 600,1080 1320,1710 1710,2070
disk,| and often particular machine
|通常特定的机器具有有限的吞吐量，

119
00:03:38,640 --> 00:03:40,710
0,240 240,810 990,1650 1830,1980 1980,2070
has limited throughput,| if you
|如果你想读取更多，

120
00:03:40,710 --> 00:03:41,700
0,180 180,270 270,480 480,810 810,990
want to read more| than
|超过一个磁盘的容量，

121
00:03:41,700 --> 00:03:43,770
0,630 630,990 990,1290 1290,1620 1620,2070
actually a single disk {can,sustain},|
|

122
00:03:43,770 --> 00:03:44,610
0,90 90,210 210,300 300,480 480,840
you have to use multiple
你必须使用多个磁盘，

123
00:03:44,610 --> 00:03:45,360
0,270 270,510 510,570 570,660 660,750
disks,| and you have to
|你必须使用多个网卡，

124
00:03:45,360 --> 00:03:46,650
0,210 210,510 510,810 810,1110 1110,1290
use multiple network cards,| and
|你可以立即进入这种大规模系统，

125
00:03:46,650 --> 00:03:47,760
0,150 150,330 330,420 420,900 900,1110
so you can immediately get

126
00:03:47,760 --> 00:03:49,290
0,240 240,420 420,600 600,690 840,1530
into these sort of large

127
00:03:49,290 --> 00:03:51,570
0,630 630,1290 1290,1530 1530,1680 1680,2280
scale systems| in the GFS
|在 GFS 中，有数千台机器。

128
00:03:51,570 --> 00:03:53,360
0,330 330,840 840,960 960,1560
{where,you,have} thousands of machines.|
|

129
00:03:54,560 --> 00:03:55,850
0,270 270,360 360,480 480,720 720,1290
{But,if} you have many servers,|
但是如果你有多台服务器，|

130
00:03:58,070 --> 00:03:59,060
0,180 180,240 240,360 360,510 510,990
{some -} are gonna fail,|
有些会失败，|

131
00:04:00,790 --> 00:04:02,500
0,420 420,540 540,1140
{you,gonna} get failures,|
你会遭遇失败，|

132
00:04:02,500 --> 00:04:03,640
0,300 300,480 480,840 840,1080 1080,1140
or {you,can} maybe,| you can
或者你可能，|你会看到更多专有的不断的故障，

133
00:04:03,640 --> 00:04:05,470
0,330 330,510 510,1230 1230,1380 1380,1830
see more exclusively {} constant

134
00:04:05,470 --> 00:04:10,840
0,690 3240,4110 4110,4230 4230,5010 5010,5370
faults,| and {you,know} let's say
|假设电脑崩溃，一年一次，

135
00:04:10,840 --> 00:04:12,340
0,180 180,540 540,1110 1110,1230 1230,1500
the computer crashes, you know

136
00:04:12,340 --> 00:04:13,840
0,210 210,300 300,720 840,1080 1080,1500
once a year,| you know,
|现在假设你有数千台机器，

137
00:04:13,840 --> 00:04:15,550
0,570 810,1170 1170,1320 1320,1620 1620,1710
{} now let's say you

138
00:04:15,550 --> 00:04:16,630
0,150 150,270 270,660 660,1020 1020,1080
know you have thousands of

139
00:04:16,630 --> 00:04:18,310
0,420 420,660 660,990 990,1290 1290,1680
machines,| like in the GFS
|就像在 GFS 的论文中，

140
00:04:18,310 --> 00:04:19,690
0,630 660,750 750,990 990,1290 1290,1380
paper,| so many more in
|比上千台机器更多，

141
00:04:19,690 --> 00:04:20,860
0,120 120,210 210,360 360,750 750,1170
the {thousand -} machines,| {at,minimal}
|最少一千台机器，

142
00:04:20,860 --> 00:04:22,320
0,150 150,420 420,1050
{thousand -} machines,|
|

143
00:04:22,320 --> 00:04:23,280
0,210 210,390 390,780 780,810 810,960
how many failures are going
粗略地说，每天会看到多少次失败。

144
00:04:23,280 --> 00:04:25,050
0,60 60,240 240,360 360,750 1200,1770
to see per day, roughly.|
|

145
00:04:29,210 --> 00:04:31,190
0,390 420,750 750,1230 1470,1800 1800,1980
{} Around 3.| Yeah, around
大概 3 次。|是的，大约 3 次，

146
00:04:31,190 --> 00:04:32,660
0,390 420,660 660,900 900,1230 1230,1470
3, right,| that means that
|这意味着计算机的失败，

147
00:04:32,660 --> 00:04:34,010
0,120 120,480 480,780 780,840 840,1350
you know sort of a

148
00:04:34,010 --> 00:04:36,050
0,510 510,600 600,660 660,1230 1530,2040
failure of a computer| like
|像我在课程开头的笔记本电脑，

149
00:04:36,050 --> 00:04:37,100
0,90 90,600 600,690 690,750 750,1050
my laptop at the beginning

150
00:04:37,100 --> 00:04:38,480
0,90 90,180 180,720 870,1080 1080,1380
of the lecture,| {} is
|是一个常见的场景，

151
00:04:38,480 --> 00:04:41,720
0,270 270,1380 1380,1950 1950,2640 2760,3240
just a common scenario,| and
|如果你上升到

152
00:04:41,720 --> 00:04:42,200
0,120 120,210 210,300 300,420 420,480
so if you're going to

153
00:04:42,200 --> 00:04:43,340
0,360 360,540 540,660 660,900 900,1140
move up to| more than
|超过一千台，一万台机器，十万台机器，

154
00:04:43,340 --> 00:04:45,050
0,60 60,480 480,900 900,1200 1200,1710
a thousand, ten thousand machines,

155
00:04:45,050 --> 00:04:46,670
0,120 120,360 360,690 690,1230 1410,1620
a hundred thousand machines,| you're
十万台机器，|你使用这种数量的计算机运行应用程序，

156
00:04:46,670 --> 00:04:48,110
0,240 240,870 870,1140 1140,1290 1290,1440
running applications using that kind

157
00:04:48,110 --> 00:04:49,310
0,90 90,300 300,360 360,840 1020,1200
of number of computers,| you're
|你会遇到失败，

158
00:04:49,310 --> 00:04:51,290
0,210 210,390 390,810 810,1260 1410,1980
gonna get faults,| and so
|这意味着你需要一个容错的设计。

159
00:04:51,320 --> 00:04:52,460
0,180 180,510 510,750 750,1020 1020,1140
that means you want a

160
00:04:52,460 --> 00:04:54,220
0,210 210,450 450,990
fall tolerance design.|
|

161
00:04:59,240 --> 00:05:00,120
0,120

162
00:05:01,260 --> 00:05:02,790
0,510 510,660 660,1050 1080,1380 1380,1530
And you know {to,get} fault
为了获得容错能力，

163
00:05:02,790 --> 00:05:03,870
0,420 420,510 510,570 570,870 870,1080
tolerance,| you know at least
|至少在这种情况下，

164
00:05:03,870 --> 00:05:04,920
0,60 60,120 120,390 390,540 540,1050
in the case,| where {storage,system}
|存储系统采用的传统方法，

165
00:05:04,920 --> 00:05:06,000
0,90 90,210 210,480 480,900 900,1080
with the typical approach the

166
00:05:06,000 --> 00:05:06,840
0,180 180,270 270,480 480,600 600,840
way to go,| we're gonna
|我们将使用复制，

167
00:05:06,840 --> 00:05:10,710
0,180 180,300 300,870 2940,3510 3510,3870
go with replication,| copy data
|复制数据到多个磁盘上，

168
00:05:10,710 --> 00:05:12,480
0,150 150,480 480,1080 1350,1530 1530,1770
on multiple disks,| {you,know,so,that} they
|这样，当这个失败时，

169
00:05:12,480 --> 00:05:13,590
0,300 300,420 420,870 870,960 960,1110
what this fails,| you know
|希望另一个磁盘有数据。

170
00:05:13,590 --> 00:05:14,850
0,210 210,420 420,810 810,990 990,1260
the other disk hopefully have

171
00:05:14,850 --> 00:05:16,960
0,570 600,1080
the data.|
|

172
00:05:17,770 --> 00:05:19,150
0,480 510,690 690,810 810,1050 1050,1380
But if you go into
但是如果你使用复制，

173
00:05:19,150 --> 00:05:21,130
0,870 1140,1500 1500,1620 1620,1710 1710,1980
replication| and so the data
|数据位于多个位置，

174
00:05:21,130 --> 00:05:23,000
0,90 90,180 180,600 600,1380
is in multiple places,|
|

175
00:05:23,060 --> 00:05:24,560
0,240 240,540 540,750 750,1350 1350,1500
{} that runs into the
就会遇到数据不同步的挑战，

176
00:05:24,560 --> 00:05:25,970
0,390 390,900 900,990 990,1230 1230,1410
challenge that the data may

177
00:05:25,970 --> 00:05:27,350
0,150 150,270 270,360 360,750 990,1380
be out of sync,| and
|你会陷入可能的不一致。

178
00:05:27,350 --> 00:05:28,520
0,150 150,330 330,600 600,810 810,1170
so you actually get into

179
00:05:28,520 --> 00:05:38,660
0,660 660,1260 1260,2250
inconsistent potential inconsistencies.|
|

180
00:05:40,020 --> 00:05:41,340
0,120 120,210 210,420 420,1050 1080,1320
You know, to avoid these
为了避免这些不一致，

181
00:05:41,340 --> 00:05:43,500
0,1050 1200,1350 1350,1530 1530,1890 1890,2160
inconsistencies,| you know if you
|如果你想要强一致性，

182
00:05:43,500 --> 00:05:45,600
0,510 510,810 810,1440 1440,1890 1890,2100
{desire,a} strong consistency,| basically your
|你的复制系统的行为就像

183
00:05:45,600 --> 00:05:46,950
0,450 450,480 480,840 840,1200 1200,1350
replicate {} system behaves as


184
00:05:46,950 --> 00:05:48,510
0,180 180,360 360,840 840,1410 1410,1560
if it's {},| it as
|就像未复制系统的行为。

185
00:05:48,510 --> 00:05:49,350
0,60 60,270 270,630 630,750 750,840
the same behavior as an

186
00:05:49,350 --> 00:05:51,180
0,240 240,750 750,1230
{unreplicated -} system.|
|

187
00:05:51,180 --> 00:05:53,880
0,450 750,1470 1680,2100 2100,2400 2400,2700
{} Then you will need
然后，你将需要一些持久性协议，

188
00:05:53,880 --> 00:05:56,460
0,240 240,750 750,1410
some persistency protocol,|
|

189
00:05:57,600 --> 00:05:58,980
0,210 210,660 660,840 840,1230 1230,1380
and that's gonna require some
这可能需要发送一些消息，

190
00:05:58,980 --> 00:06:00,960
0,240 240,480 480,1080 1080,1680 1710,1980
maybe sending messages| and may
|而且可能会降低性能，

191
00:06:00,960 --> 00:06:03,720
0,150 150,450 450,1320
be lower performance,|
|

192
00:06:05,870 --> 00:06:07,550
0,360 360,450 450,870 870,1410 1410,1680
maybe the messages themselves, not
也许消息本身并不会带来很大的性能开销，

193
00:06:07,550 --> 00:06:09,380
0,330 330,720 750,1230 1230,1680 1680,1830
really huge performance overhead,| but
|但是我们会看到的[]知识，

194
00:06:09,380 --> 00:06:10,730
0,210 210,420 420,780 780,900 900,1350
{you,know} [] knowledge we'll see,|
|

195
00:06:10,910 --> 00:06:11,780
0,150 150,270 270,450 450,690 690,870
and you might actually have
你可能必须读取或写入持久存储，

196
00:06:11,780 --> 00:06:13,250
0,150 150,810 810,1050 1050,1380 1380,1470
to read or write to

197
00:06:13,250 --> 00:06:14,570
0,450 450,900 900,1020 1020,1260 1260,1320
durable storage,| as part of
|作为协议的一部分，

198
00:06:14,570 --> 00:06:16,520
0,210 210,750 1080,1500 1500,1680 1680,1950
that protocol| and {you,know} reading
|而且读取或写入存储

199
00:06:16,520 --> 00:06:17,660
0,60 60,300 300,420 420,720 720,1140
or writing to storage| intentionally
|往往是相当昂贵的。

200
00:06:17,660 --> 00:06:19,220
0,210 210,300 300,690 690,930 930,1560
tends to be quite expensive.|
|

201
00:06:19,740 --> 00:06:20,880
0,210 210,630 630,810 810,990 990,1140
So here we see this
所以我们在这里看到了这个难题，

202
00:06:20,880 --> 00:06:22,170
0,570 570,840 840,900 900,1080 1080,1290
conundrum,| like you know we
|我们想要高性能，

203
00:06:22,170 --> 00:06:24,150
0,180 180,360 360,1170 1470,1830 1830,1980
want high performance,| {} we
|我们想要容错，

204
00:06:24,150 --> 00:06:25,290
0,180 180,360 360,810 810,1050 1050,1140
want fault tolerance,| because we
|因为我们有很多服务器，

205
00:06:25,290 --> 00:06:27,240
0,90 90,300 300,990 1320,1800 1800,1950
have many servers,| we want
|我们希望在多台服务器上实现高性能，

206
00:06:27,240 --> 00:06:29,130
0,120 120,600 600,990 990,1290 1290,1890
high performance over many servers,|
|

207
00:06:29,130 --> 00:06:30,900
0,300 300,690 690,900 900,1050 1050,1770
many servers means fault tolerance,|
许多服务器意味着容错，|

208
00:06:31,020 --> 00:06:32,490
0,270 270,450 450,660 660,1320 1320,1470
{} that means application that
这意味着应用程序不一致的情况，

209
00:06:32,490 --> 00:06:34,620
0,390 390,540 540,900 900,1380 1410,2130
means you know {} {inconsistencies

210
00:06:34,620 --> 00:06:36,030
0,300 330,870 870,960 960,1200 1200,1410
-},| because we have data
|因为我们在多个地方都有数据，

211
00:06:36,030 --> 00:06:37,710
0,90 90,630 630,1290 1290,1440 1440,1680
in multiple places,| to fix
|为了修复不一致，

212
00:06:37,710 --> 00:06:39,450
0,120 120,780 780,870 870,1020 1020,1740
the inconsistencies,| we need to
|我们需要一个协议，可能会降低性能。

213
00:06:39,480 --> 00:06:40,500
0,150 150,210 210,720 720,870 870,1020
get a protocol that might

214
00:06:40,500 --> 00:06:42,330
0,210 210,870 1200,1410 1410,1680 1680,1830
lower performance.| So here sort
|所以，这是基本挑战，

215
00:06:42,330 --> 00:06:44,520
0,90 90,240 240,1020 1050,1800 1800,2190
of this fundamental challenge| in
|在设计这些分布式存储系统时，

216
00:06:44,520 --> 00:06:46,440
0,420 420,600 600,1110 1110,1500 1500,1920
designing these distributed storage systems,|
|

217
00:06:46,440 --> 00:06:48,900
0,330 600,1050 1200,1650 1650,2070 2070,2460
that {} user struggle between
用户在一致性和性能之间苦苦挣扎，

218
00:06:48,900 --> 00:06:52,290
0,900 900,1230 1410,2190 2250,2850 3060,3390
consistency and performance,| and we'll
|我们将在整个学期中看到这一点。

219
00:06:52,290 --> 00:06:53,520
0,150 150,390 390,750 750,810 810,1230
see that throughout the term.|
|

220
00:06:55,840 --> 00:06:56,620
0,180 180,300 300,480 480,690 690,780
So let me talk a
所以，让我来谈一下一致性。

221
00:06:56,620 --> 00:06:58,680
0,270 270,420 420,660 660,1470
little bit about consistency.|
|

222
00:06:58,710 --> 00:07:00,260
0,1080

223
00:07:02,400 --> 00:07:03,270
0,150 150,330 330,420 420,720 720,870
And there's a very high
而且有一个非常高的水平

224
00:07:03,270 --> 00:07:05,610
0,360 510,750 750,1110 1800,2220 2220,2340
level| and I promise you
|我向你保证在这学期剩下的时间里，

225
00:07:05,610 --> 00:07:06,690
0,120 120,450 450,570 570,960 960,1080
for {the,rest,of} this semester,| we're
|我们将一边走一边详细介绍。

226
00:07:06,690 --> 00:07:08,910
0,690 780,1230 1230,1800 1800,2100 2100,2220
going more detail as we

227
00:07:08,910 --> 00:07:10,740
0,330 840,1170 1200,1470 1470,1620 1620,1830
go.| So first let's talk
|所以首先让我们再谈一谈理想的一致性，

228
00:07:10,740 --> 00:07:12,690
0,570 570,810 810,900 900,1260 1260,1950
again about the ideal consistency,|
|

229
00:07:13,260 --> 00:07:14,760
0,150 150,450 450,1050 1050,1230 1230,1500
an ideal consistency the way
一个理想的一致性最简单的思考方式是，基本上机器的行为就像它是一个单一的系统一样，

230
00:07:14,760 --> 00:07:15,600
0,90 90,450 450,540 540,630 630,840
the simplest way to think

231
00:07:15,600 --> 00:07:16,890
0,390 390,570 570,840 840,1200 1200,1290
about is that basically the

232
00:07:16,890 --> 00:07:18,300
0,330 330,930 930,1080 1080,1260 1260,1410
machine behaves as if it's

233
00:07:18,300 --> 00:07:20,820
0,60 60,420 420,1230
a single system,|
|

234
00:07:23,020 --> 00:07:25,640
0,240

235
00:07:28,770 --> 00:07:30,540
0,390 390,540 540,810 810,1200 1200,1770
that's also the desired behavior|
这也是我们想要的行为|

236
00:07:30,570 --> 00:07:31,650
0,150 150,240 240,390 390,540 540,1080
and the sort of two
这两件事会让人产生想要的行为或两种危险

237
00:07:31,650 --> 00:07:33,990
0,750 930,1260 1260,1470 1470,1800 1830,2340
things that make the desired

238
00:07:33,990 --> 00:07:37,350
0,420 420,540 540,1080 1320,2070 2220,3360
behavior or two {} hazards|
|

239
00:07:37,350 --> 00:07:39,750
0,570 630,990 990,1260 1260,1620 1620,2400
that make this design behavior
这使得这种设计行为很难实现，

240
00:07:39,780 --> 00:07:41,360
0,300 300,540 540,600 600,1110
{} hard to achieve,|
|

241
00:07:41,610 --> 00:07:42,690
0,510 510,690 690,810 810,900 900,1080
{} or you know at
或者你知道，至少你知道需要一些思考

242
00:07:42,690 --> 00:07:44,190
0,300 300,390 390,810 810,1350 1350,1500
least you know requires some

243
00:07:44,190 --> 00:07:46,350
0,390 720,1110 1110,1350 1350,1530 1530,2160
thinking| and one is concurrency
|其一是并发性，其二是失败。

244
00:07:46,350 --> 00:07:47,550
0,120 120,450 450,630 630,750 750,1200
and second thing is failures.|
|

245
00:07:48,350 --> 00:07:49,400
0,420 420,540 540,690 690,750 750,1050
{} So let me start
所以让我从消费者并发性开始，

246
00:07:49,400 --> 00:07:50,690
0,150 150,210 210,570 570,1050 1050,1290
with {} consumer concurrency,| because
|因为即使您有一台具有多个客户端的计算机，

247
00:07:50,690 --> 00:07:51,800
0,630 660,810 810,930 930,1050 1050,1110
even if you have a

248
00:07:51,800 --> 00:07:55,280
0,690 1140,1890 2430,2580 2580,2970 2970,3480
single machine with multiple clients,|
|

249
00:07:55,280 --> 00:07:56,480
0,240 240,420 420,900 900,1170 1170,1200
so your concurrency within a
因此，您在一台计算机中的并发性，

250
00:07:56,480 --> 00:07:57,800
0,270 270,720 840,960 960,1170 1170,1320
single machine,| you actually have
|实际上，你必须考虑一致性

251
00:07:57,800 --> 00:07:59,810
0,120 120,330 330,600 600,1290 1590,2010
to think about consistency| and
|这个原因是很明显的，

252
00:07:59,810 --> 00:08:01,310
0,360 360,570 570,630 630,1050 1050,1500
this cause is quite obvious,|
|

253
00:08:01,310 --> 00:08:02,750
0,300 300,510 510,660 660,1200 1200,1440
let's say we have one
假设我们有一台机器，一张磁盘，

254
00:08:02,750 --> 00:08:05,480
0,540 540,990 990,1770 2040,2640 2640,2730
machine, one disk,| both of
|您知道，这两个请求来自不同的客户。

255
00:08:05,480 --> 00:08:06,620
0,570 570,660 660,780 780,930 930,1140
requests you know come in

256
00:08:06,620 --> 00:08:08,460
0,480 510,870 870,1470
from different clients.|
|

257
00:08:08,490 --> 00:08:09,210
0,150 150,240 240,300 300,630 630,720
And if the machine is
如果机器是多处理器机器，

258
00:08:09,210 --> 00:08:10,410
0,60 60,630 630,930 930,1020 1020,1200
a multi-processor machine,| they might
|它们实际上可能会在内部并行运行这些请求。

259
00:08:10,410 --> 00:08:12,690
0,210 210,810 1050,1680 1680,1920 1920,2280
actually run {} these requests

260
00:08:12,690 --> 00:08:14,240
0,210 210,420 420,510 510,990
{internally -} in parallel.|
|

261
00:08:14,240 --> 00:08:16,130
0,720 1080,1410 1410,1560 1560,1710 1710,1890
So, {} so let's think
所以，让我们稍微想一想，

262
00:08:16,130 --> 00:08:17,120
0,30 30,240 240,390 390,690 690,990
a little bit about it,|
|

263
00:08:17,120 --> 00:08:18,320
0,180 180,360 360,450 450,720 720,1200
what does it mean,| so
这是什么意思，|因此，假设我们有客户1，

264
00:08:18,620 --> 00:08:20,300
0,690 930,1260 1260,1440 1440,1560 1560,1680
so let's say we have

265
00:08:20,300 --> 00:08:22,010
0,360 360,900 1320,1470 1470,1620 1620,1710
client 1,| that does a
|它对键x和写1执行写操作

266
00:08:22,010 --> 00:08:25,700
0,300 300,1110 2220,2850 2850,3360 3360,3690
write operation to {} key

267
00:08:25,700 --> 00:08:28,370
0,600 630,1050 1050,1260 1260,1680 2490,2670
x and write 1| and
|与此同时，也有一个写入x的请求进入，

268
00:08:28,370 --> 00:08:29,450
0,60 60,150 150,450 450,900 900,1080
at the same time, there's

269
00:08:29,450 --> 00:08:30,770
0,30 30,360 360,600 600,960 1140,1320
a request coming in with

270
00:08:30,770 --> 00:08:33,020
0,420 420,900 900,1800 1800,2010 2010,2250
writes to {x,too},| but actually
|但实际上写的是值2，对吧。

271
00:08:33,020 --> 00:08:34,380
0,210 210,270 270,600 600,930
writes the value 2,

272
00:08:35,080 --> 00:08:36,280
0,240 240,720 720,930 930,1050 1050,1200
right.| Now, you know if
|现在，你知道如果你想具体说明或展示一致性意味着什么，

273
00:08:36,280 --> 00:08:37,750
0,150 150,300 300,360 360,1320 1320,1470
you want to specify or

274
00:08:37,750 --> 00:08:39,280
0,450 450,660 660,1110 1110,1230 1230,1530
stage what {consistency -} means,|
|

275
00:08:39,280 --> 00:08:40,900
0,120 120,270 270,510 510,1080 1140,1620
we need some rule about
我们需要一些规则，比如会发生什么，

276
00:08:40,900 --> 00:08:42,610
0,210 210,570 570,720 720,1170 1560,1710
like what will happen,| in
|在通常从读者的角度表述的规则中，

277
00:08:42,610 --> 00:08:43,960
0,90 90,390 390,780 780,1200 1200,1350
the rules typically phrased from

278
00:08:43,960 --> 00:08:45,130
0,90 90,510 510,630 630,720 720,1170
the perspective of the reader,|
|

279
00:08:45,160 --> 00:08:46,180
0,210 210,390 390,570 570,750 750,1020
so let's say there's another
假设有另一位读者走进来，

280
00:08:46,180 --> 00:08:47,720
0,300 300,600 600,900
reader coming in,|
|

281
00:08:47,980 --> 00:08:49,120
0,210 210,390 390,450 450,780 780,1140
where {another - -} request
其中来自另一个客户端的另一个请求实际读取x。

282
00:08:49,120 --> 00:08:50,260
0,180 180,300 300,510 510,630 630,1140
coming in from another client

283
00:08:50,260 --> 00:08:52,480
0,270 270,570 570,840 840,1320
and actually read x.|
|

284
00:08:53,460 --> 00:08:54,420
0,210 210,480 480,540 540,840 840,960
The question is what is
问题是，读者或客户实际观察到的价值是什么。

285
00:08:54,420 --> 00:08:55,950
0,60 60,570 630,930 930,1320 1320,1530
the value that actually that

286
00:08:55,950 --> 00:08:57,120
0,270 270,420 420,690 690,810 810,1170
{reader -} or that client

287
00:08:57,120 --> 00:08:58,340
0,120 120,720
{observes -}.|
|

288
00:08:58,460 --> 00:08:59,300
0,150 150,420 420,510 510,690 690,840
And look a little bit
看起来更复杂或更有趣，

289
00:08:59,300 --> 00:09:00,830
0,180 180,750 750,900 900,1080 1080,1530
more complicated or more interesting,|
|

290
00:09:00,830 --> 00:09:01,790
0,210 210,330 330,450 450,660 660,960
let's say we have four
假设我们有四个客户

291
00:09:01,790 --> 00:09:02,810
0,510 510,690 690,840 840,960 960,1020
clients| which we're going to
|我们将更清楚地提出一致性定义这一问题，

292
00:09:02,810 --> 00:09:03,770
0,210 210,390 390,540 540,900 900,960
bring out this issue of

293
00:09:03,770 --> 00:09:06,080
0,540 540,1050 1050,1290 1290,1830 2070,2310
consistency definitions more clearly,| and
|它还读取x，

294
00:09:06,080 --> 00:09:06,920
0,120 120,360 360,570 570,660 660,840
it also does a read

295
00:09:06,920 --> 00:09:08,930
0,90 90,600 660,1200 1200,1860 1890,2010
of x,| well after you
|好的，在你知道客户端3实际上读到了x之后。

296
00:09:08,930 --> 00:09:10,430
0,210 210,600 600,930 930,1200 1200,1500
know the client 3 actually

297
00:09:10,430 --> 00:09:11,500
0,240 240,660
read x.|
|

298
00:09:12,580 --> 00:09:13,420
0,180 180,420 420,510 510,630 630,840
So now we have some
所以现在我们有了一些状态，

299
00:09:13,420 --> 00:09:15,220
0,450 450,750 750,930 930,1380 1380,1800
state,| what is desired outcomes,
|什么是期望的结果，什么是不正确的结果

300
00:09:15,220 --> 00:09:16,480
0,180 180,300 300,780 780,1170 1170,1260
what are incorrect outcomes| and
|这就是一致性的真正定义。

301
00:09:16,480 --> 00:09:19,030
0,240 240,600 600,1140 1140,1680 1680,2550
that's really what defines consistency.|
|

302
00:09:19,670 --> 00:09:21,980
0,630 750,1350 1530,2040 2040,2250 2250,2310
So, {} let's take the
那么，让我们来看第一个案例，

303
00:09:21,980 --> 00:09:23,150
0,270 270,510 510,690 690,1050 1050,1170
first case,| {c3 -} {you,know}
|你知道什么是一个合理的结果，

304
00:09:23,150 --> 00:09:24,590
0,210 210,450 450,690 690,1020 1020,1440
what be a reasonable outcome

305
00:09:24,590 --> 00:09:28,610
0,720 750,1290 1320,1890 2490,3480 3690,4020
for {} {read,c}, read,| what
|对于3岁的读者来说，什么是合理的结果。

306
00:09:28,610 --> 00:09:29,600
0,90 90,180 180,420 420,720 720,990
is {reasonable -} outcome for

307
00:09:29,600 --> 00:09:30,470
0,150 150,330 330,390 390,720 720,870
the reader of 3 to

308
00:09:30,470 --> 00:09:31,460
0,540
return.|
|

309
00:09:31,580 --> 00:09:32,960
0,180 180,810
What values.|
什么价值。|

310
00:09:33,660 --> 00:09:34,620
0,180 180,270 270,510 510,780 780,960
You know what value would
你知道什么价值会让你开心，或者让一个应用程序程序员开心。

311
00:09:34,620 --> 00:09:35,580
0,180 180,300 300,600 600,750 750,960
make you happy or make

312
00:09:35,580 --> 00:09:37,540
0,150 150,600 600,1020 1020,1440
an application programmer happy.|
|

313
00:09:38,850 --> 00:09:39,960
0,570
2.|
2.|

314
00:09:39,960 --> 00:09:41,340
0,300 300,510 510,660 660,870 870,1380
{2 -} be very reasonable?|
2很合理吗？|

315
00:09:42,100 --> 00:09:44,640
0,240 240,720 930,1350 1350,1980
Any other reasonable values?|
还有其他合理的价值吗？|

316
00:09:44,820 --> 00:09:46,500
0,570 900,1170 1170,1410 1410,1530 1530,1680
1.| Yeah, 1 would be
1.|是的，1是合理的，

317
00:09:46,500 --> 00:09:48,630
0,480 780,1260 1260,1410 1410,1830 1830,2130
reasonable,| because the operation happened
|因为手术是同时进行的，

318
00:09:48,630 --> 00:09:50,130
0,540 540,870 870,1260 1260,1350 1350,1500
concurrently,| so maybe we don't
|所以也许我们真的不知道是哪一个，

319
00:09:50,130 --> 00:09:51,120
0,180 180,300 300,540 540,840 840,990
really know which one,| we
|我们并不是真的想限制他们的具体顺序，

320
00:09:51,120 --> 00:09:52,170
0,150 150,330 330,450 450,510 510,1050
don't really want to restrict

321
00:09:52,170 --> 00:09:53,640
0,210 210,660 660,870 870,990 990,1470
what particular order they go,|
|

322
00:09:53,670 --> 00:09:54,600
0,180 180,420 420,510 510,660 660,930
so we gone say like
所以我们去说随便哪一个都可以，因为并行运行。

323
00:09:54,600 --> 00:09:55,770
0,90 90,270 270,330 330,630 1140,1170
either one to fine, because

324
00:09:55,770 --> 00:09:57,040
0,630
{run,concurrently}.|
|

325
00:09:57,350 --> 00:09:58,190
0,210 210,270 270,390 390,690 690,840
What are some values that
有哪些价值观是我们不想看到的，或者C3阅读过的。

326
00:09:58,190 --> 00:09:59,060
0,120 120,300 300,570 570,810 810,870
we would like not to

327
00:09:59,060 --> 00:10:00,020
0,390
see,

328
00:10:00,660 --> 00:10:02,380
0,180 180,270 270,750 750,1110
ror the c3 read.|
|

329
00:10:02,410 --> 00:10:04,270
0,690 960,1200 1200,1500 1500,1710 1710,1860
7.| Yeah, 7, any other
7.|是的，7，任何其他的价值，对，

330
00:10:04,270 --> 00:10:06,040
0,330 330,690 720,1050 1050,1560 1560,1770
value, right,| because nobody wrote
|因为没人写过这些，

331
00:10:06,040 --> 00:10:07,450
0,270 330,540 540,660 660,840 840,1410
that,| {so,that} would be undesirable.|
|因此，这将是不受欢迎的。|

332
00:10:08,210 --> 00:10:09,980
0,330 330,540 540,750 750,1080 1080,1770
Okay, {so,good},| so like we
好的，太好了，|所以，就像我们一致认为的那样，c3的原始结果可能是1或2。

333
00:10:09,980 --> 00:10:11,330
0,300 300,480 480,900 900,1260 1260,1350
agree that probably used the

334
00:10:11,330 --> 00:10:12,830
0,510 510,900 900,1140 1140,1350 1350,1500
original outcome for c3 would

335
00:10:12,830 --> 00:10:13,580
0,120 120,300 300,480 480,570 570,750
be either 1 or 2.|
|

336
00:10:14,240 --> 00:10:15,440
0,330 330,450 450,660 660,780 780,1200
Okay, how about {c4 -}?|
好的，C4怎么样？|

337
00:10:17,520 --> 00:10:19,580
0,90 90,330 330,780 810,1380
The same as c3.|
与C3相同。|

338
00:10:19,580 --> 00:10:21,800
0,510 570,1050 1050,1170 1170,1680
Really, exactly the same?|
真的吗，一模一样？|

339
00:10:23,270 --> 00:10:24,650
0,240 240,390 390,540 540,1020 1020,1380
So, let's say c3 return
所以，假设c3返回1，

340
00:10:24,650 --> 00:10:25,620
0,420
1,|
|

341
00:10:25,620 --> 00:10:26,760
0,270 270,330 330,450 450,750 750,1140
what do we expect c4
我们期望C4能得到什么回报？

342
00:10:26,760 --> 00:10:27,900
0,90 90,570
to return?|
|

343
00:10:28,490 --> 00:10:31,370
0,450 450,900 900,1470 1740,2520 2580,2880
Whatever c3 saw.| Yeah, {because}
不管C3看到了什么。|是的，因为它是在C3之后运行的，对。

344
00:10:31,370 --> 00:10:32,990
0,540 540,870 870,1050 1050,1260 1260,1620
{it,run} after {c3 -}, right.|
|

345
00:10:32,990 --> 00:10:34,600
0,450 630,1050
Yeah, if
是的，如果返回1，我们预计这里也会有1。

346
00:10:34,630 --> 00:10:35,950
0,300 300,450 450,900 900,1050 1050,1320
1 was returned, we expect

347
00:10:35,950 --> 00:10:37,580
0,210 210,420 420,690
1 here too.|
|

348
00:10:37,640 --> 00:10:39,080
0,180 180,510 510,690 690,1230 1260,1440
If 2 was returned, we
如果返回%2，我们预计这里会有%2。

349
00:10:39,080 --> 00:10:40,620
0,330 330,480 480,900
expect 2 here.|
|

350
00:10:41,800 --> 00:10:43,120
0,120 120,240 240,390 390,780
Does that make sense?|
这说得通吗？|

351
00:10:45,320 --> 00:10:47,030
0,450 450,900 1260,1470 1470,1590 1590,1710
Okay, so, {} you know
好的，所以，你知道，有一种超级简短的介绍

352
00:10:47,030 --> 00:10:48,560
0,180 180,360 360,540 570,960 960,1530
there's like {} super brief

353
00:10:48,590 --> 00:10:49,700
0,90 90,360 360,510 510,600 600,1110
you know sort of introduction|
|

354
00:10:49,700 --> 00:10:51,050
0,360 360,600 600,1050 1050,1230 1230,1350
of saying how can we
说我们如何定义一致性

355
00:10:51,050 --> 00:10:53,540
0,1080 1080,1680 1680,1890 1890,2370 2370,2490
define consistency| and typically we
|通常，我们使用某种痕迹来实现这一点

356
00:10:53,540 --> 00:10:55,010
0,180 180,360 360,720 720,930 930,1470
do this using {sort,of} traces|
|

357
00:10:55,010 --> 00:10:56,090
0,120 120,210 210,480 480,750 750,1080
and we argue about what
我们争论的是特定痕迹的正确性

358
00:10:56,090 --> 00:10:58,220
0,570 840,1140 1140,1530 1530,2010 2010,2130
correctness for particular traces| and
|我们将看到更多这样的情况。

359
00:10:58,220 --> 00:10:58,880
0,150 150,270 270,420 420,600 600,660
we will see more of

360
00:10:58,880 --> 00:10:59,700
0,330
that.|
|

361
00:10:59,940 --> 00:11:00,870
0,180 180,420 420,510 510,720 720,930
Of course, you know the
当然，您知道服务器可以强制这种并发性，例如使用锁，

362
00:11:00,870 --> 00:11:02,340
0,540 540,1140 1140,1230 1230,1320 1320,1470
{server,can} enforce you know this

363
00:11:02,340 --> 00:11:03,900
0,210 210,420 450,900 900,1230 1230,1560
kind of {} {concurrency -}

364
00:11:03,900 --> 00:11:05,220
0,180 180,570 570,810 810,1170 1170,1320
by {for,example} using locks,| if
|如果您已经这样做了，如果您执行了MapReduce，

365
00:11:05,220 --> 00:11:06,540
0,330 330,480 480,930 1080,1200 1200,1320
you have done if you

366
00:11:06,540 --> 00:11:07,890
0,150 150,270 270,420 420,1080 1080,1350
do {mapreduce - -},| you
|您知道您正在编写的任何并发围棋编程，

367
00:11:07,890 --> 00:11:08,970
0,120 120,270 270,540 540,870 870,1080
know of any concurrent Go

368
00:11:08,970 --> 00:11:10,740
0,630 630,960 1200,1440 1440,1620 1620,1770
programming {you're,write},| that sort of
|在并发性存在的情况下，强制一致性的那种标准技术是使用锁。

369
00:11:10,740 --> 00:11:12,570
0,60 60,450 450,1110 1110,1230 1230,1830
the standard technique to enforce

370
00:11:12,840 --> 00:11:14,670
0,390 390,1020 1020,1140 1140,1470 1470,1830
{} consistency in terms of,

371
00:11:14,730 --> 00:11:16,530
0,360 360,540 540,900 900,1020 1020,1800
in the presence of concurrency

372
00:11:16,710 --> 00:11:18,240
0,330 330,420 420,660 660,1200
is to use locks.|
|

373
00:11:18,630 --> 00:11:20,660
0,600 660,1530

374
00:11:20,720 --> 00:11:22,460
0,180 180,270 270,600 600,1170 1200,1740
In a distributed system, {}
在分布式系统中，您知道理想的一致性，

375
00:11:22,460 --> 00:11:24,140
0,150 150,240 240,570 600,900 900,1680
you know the ideal consistency,|
|

376
00:11:24,140 --> 00:11:25,040
0,90 90,180 180,330 330,630 630,900
you know sort of similar
你知道类似的两种危险，第二种危险基本上是故障，

377
00:11:25,040 --> 00:11:26,240
0,210 210,750 750,840 840,930 930,1200
two hazards and the second

378
00:11:26,240 --> 00:11:28,130
0,510 780,1080 1080,1410 1410,1800 1800,1890
hazard is basically failure,| so
|所以一般而言，只是复制，

379
00:11:28,130 --> 00:11:29,810
0,330 330,810 810,930 930,1380 1410,1680
just replication in general,| look
|看，如果我们有两台服务器[现在][组装]，

380
00:11:29,810 --> 00:11:30,740
0,90 90,180 180,300 300,450 450,930
if we have two servers

381
00:11:30,740 --> 00:11:32,840
0,90 90,750 1050,1350 1350,1560 1560,2100
[now] [assembly],| {so,here} {S1 -},
|所以这里是S1，这里是S2，

382
00:11:33,860 --> 00:11:35,620
0,330 330,600 600,1140
here {S2 -},|
|

383
00:11:36,440 --> 00:11:37,760
0,570 570,810 810,1080 1080,1230 1230,1320
and {you,know} both have a
你知道两个人都有一张光盘，

384
00:11:37,760 --> 00:11:39,420
0,750
disk,|
|

385
00:11:40,400 --> 00:11:41,690
0,240 240,450 450,750 750,990 990,1290
and we have our same
我们有和以前一样的客户，

386
00:11:41,690 --> 00:11:43,490
0,420 420,540 540,1140 1140,1380 1380,1800
clients as before,| {C1 -}
|C1和C2

387
00:11:43,490 --> 00:11:44,990
0,180 180,870 870,990 990,1170 1170,1500
and C2| and they write
|他们给x写了封信，

388
00:11:44,990 --> 00:11:46,520
0,90 90,450 570,750 750,990 990,1530
you know {} to x,|
|

389
00:11:47,380 --> 00:11:50,050
0,600 870,1620 1680,1860 1860,2070 2070,2670
{} and {you,know} let's say
你知道，假设你知道，只是为了说明什么样的复杂性，

390
00:11:50,200 --> 00:11:51,700
0,210 210,420 420,660 660,840 840,1500
you know just to illustrate

391
00:11:51,700 --> 00:11:52,990
0,330 330,450 450,510 510,1110 1110,1290
what kind of complication,| what
|什么样的，说明我们必须做些什么，

392
00:11:52,990 --> 00:11:54,820
0,120 120,450 1230,1680 1680,1770 1770,1830
kind of, illustrate that we

393
00:11:54,820 --> 00:11:56,410
0,270 270,360 360,510 510,1140 1320,1590
have to do something, {}|
|

394
00:11:56,410 --> 00:11:57,940
0,180 180,450 450,570 570,930 930,1530
let's start with the most
让我们从你所知道的最愚蠢的东西开始，复制计划，

395
00:11:57,940 --> 00:12:00,940
0,90 90,480 510,1050 1050,2040 2340,3000
you know dumb, a replication

396
00:12:00,940 --> 00:12:02,740
0,300 300,480 480,870 1020,1560 1560,1800
plan,| so what very bad
|那么，什么是非常糟糕的复制。

397
00:12:02,740 --> 00:12:10,160
0,480
replication.|
|

398
00:12:11,240 --> 00:12:12,890
0,360 360,540 540,900 900,1140 1140,1650
So this particular bad replication
所以这个特别糟糕的复制计划我们要做的是，

399
00:12:12,890 --> 00:12:13,790
0,210 210,450 450,630 630,750 750,900
{kind,of} plan what we're gonna

400
00:12:13,790 --> 00:12:14,780
0,120 120,330 330,510 510,780 780,990
do is,| like, yeah we're
|就像，是的，我们将允许客户，当客户真正想要更新或编写时，

401
00:12:14,780 --> 00:12:16,520
0,240 240,630 630,630 630,1260 1440,1740
gonna allow a client, when

402
00:12:16,520 --> 00:12:17,720
0,60 60,390 390,900 900,1110 1110,1200
a client actually wants to

403
00:12:17,720 --> 00:12:20,090
0,480 480,630 630,1020 1320,1980 1980,2370
update or write,| {} we're
|我们要告诉它，基本上你知道协议，

404
00:12:20,090 --> 00:12:21,620
0,270 270,720 720,810 810,960 960,1530
gonna tell it to basically

405
00:12:21,620 --> 00:12:22,520
0,180 180,420 420,720 720,810 810,900
{you,know} the protocol,| that we're
|我们接下来要做的是将客户端写入到两台服务器

406
00:12:22,520 --> 00:12:23,300
0,120 120,180 180,510 510,690 690,780
going to follow is to

407
00:12:23,300 --> 00:12:25,100
0,240 240,570 570,810 810,1140 1140,1800
client write to both servers|
|

408
00:12:25,250 --> 00:12:26,870
0,420 420,510 510,660 660,1170 1200,1620
in you know whatever, don't
无论你知道什么，不要真的协调，只需给两者都写信就行了。

409
00:12:26,870 --> 00:12:28,430
0,240 240,900 900,1170 1170,1470 1470,1560
really coordinate just write to

410
00:12:28,430 --> 00:12:29,240
0,450
both.|
|

411
00:12:29,900 --> 00:12:31,670
0,660 780,990 990,1170 1170,1650 1650,1770
{} And so exactly we
准确地说，我们有客户端1、客户端2在运行，

412
00:12:31,670 --> 00:12:32,780
0,120 120,390 390,600 600,990 990,1110
have client 1, client 2

413
00:12:32,780 --> 00:12:35,120
0,540 780,1590 1590,1680 1680,1860 1860,2340
running,| {} you know then
|你知道，然后你知道，客户2可能会做同样的事情，

414
00:12:35,120 --> 00:12:36,230
0,300 330,510 510,600 600,930 930,1110
{you,know} may be client 2

415
00:12:36,230 --> 00:12:37,780
0,180 180,270 270,480 480,990
does the same thing,|
|

416
00:12:39,520 --> 00:12:41,740
0,900
and,
然后，我们会问自己同样的问题，

417
00:12:41,770 --> 00:12:42,640
0,120 120,270 270,660 660,810 810,870
and then we're going to

418
00:12:42,640 --> 00:12:43,900
0,240 240,570 570,630 630,840 840,1260
ask ourselves the same question,|
|

419
00:12:43,900 --> 00:12:46,570
0,630 630,990 990,1170 1170,1860 1890,2670
what does {you,know} C3 {see,what}
你知道什么C3看实际阅读的内容

420
00:12:46,570 --> 00:12:49,540
0,660 1020,2010 2160,2460 2460,2640 2640,2970
actually read| and let's assume
|让我们假设，对于阅读，我会说，无论是哪种方式，

421
00:12:49,540 --> 00:12:50,410
0,120 120,270 270,570 570,660 660,870
that for reading I'm gonna

422
00:12:50,410 --> 00:12:51,670
0,180 180,360 390,780 780,1050 1050,1260
say like, {} we're either

423
00:12:51,670 --> 00:12:52,620
0,420
way,|
|

424
00:12:52,970 --> 00:12:54,050
0,570 570,630 630,780 780,960 960,1080
{} we're gonna read from
我们会从任何复制品中读取，

425
00:12:54,050 --> 00:12:55,970
0,240 240,750 750,1110 1140,1800 1800,1920
any replica,| as {I,said}, is
|就像我说的，这是一个非常糟糕的复制计划，

426
00:12:55,970 --> 00:12:57,170
0,30 30,270 270,480 480,930 930,1200
a very bad replication plan,|
|

427
00:12:57,170 --> 00:12:59,160
0,360 360,570 570,750 750,1500
basically there's no restrictions.|
基本上没有任何限制。|

428
00:13:00,080 --> 00:13:00,890
0,150 150,300 300,330 330,450 450,810
So what are the possible
那么，可能的结果是什么呢？

429
00:13:00,890 --> 00:13:02,120
0,720
outcomes.|
|

430
00:13:02,650 --> 00:13:03,910
0,120 120,300 300,510 510,720 720,1260
So this guy writes 1,
这个人写的是1，这个人写的是2

431
00:13:04,750 --> 00:13:07,360
0,390 390,690 690,1440 1920,2520 2520,2610
{this,guy} writes 2| and you
|你知道我们C3。

432
00:13:07,360 --> 00:13:09,040
0,450 450,570 570,780 780,1170
know we {C3 -}.|
|

433
00:13:10,080 --> 00:13:11,160
0,270 270,330 330,420 420,720 720,1080
What are the possible outcomes
C3的可能结果是什么？

434
00:13:11,160 --> 00:13:12,680
0,150 150,300 300,660
for {C3 -}?|
|

435
00:13:12,680 --> 00:13:14,020
0,690

436
00:13:15,130 --> 00:13:16,600
0,360 360,510 510,690 690,1170 1410,1470
1 and 2, again.| Yeah,
1和2，再来一次。|是的，1和2，这真的很糟糕。

437
00:13:16,600 --> 00:13:18,160
0,240 240,300 300,630 1200,1380 1380,1560
1 and 2, that really

438
00:13:18,190 --> 00:13:19,880
0,390 390,690
bad happens.|
|

439
00:13:19,910 --> 00:13:22,500
0,120 120,270 270,960
How about C4?|
C4怎么样？|

440
00:13:22,500 --> 00:13:23,190
0,240 240,360 360,450 450,630 630,690
We do a read of
我们读出x，在C3x之后，就像在前一块板上一样。

441
00:13:23,190 --> 00:13:24,930
0,360 360,900 900,1290 1290,1500 1500,1740
x, well after {C3 -}

442
00:13:24,930 --> 00:13:25,830
0,330 330,510 510,690 690,810 810,900
x, like this in the

443
00:13:25,830 --> 00:13:27,120
0,690
previous

444
00:13:27,210 --> 00:13:28,580
0,990
board.|
|

445
00:13:28,610 --> 00:13:30,340
0,420 420,570 570,750 750,1200
Also 1 and 2.|
也是1比2。|

446
00:13:30,630 --> 00:13:32,490
0,600 600,1110 1110,1200 1200,1350 1350,1860
Yeah, 1 and 2 again,|
是的，又是1号和2号，|

447
00:13:33,030 --> 00:13:36,260
0,780 1170,1740 1740,1980 1980,2490
{what,happens} C3 reads 1,
C3读取1，但C4可能返回。

448
00:13:37,640 --> 00:13:39,260
0,300 300,930 960,1200 1200,1440 1440,1620
but {C4 - -} may

449
00:13:39,260 --> 00:13:40,380
0,120 120,480
{return -}.|
|

450
00:13:41,130 --> 00:13:42,510
0,330 330,450 450,900 1020,1260 1260,1380
1 or 2.| 1 or
1或2。|1或2，这是我们现在想要的或不想要的。

451
00:13:42,510 --> 00:13:43,770
0,270 510,810 810,960 960,1140 1140,1260
2, it's now what we

452
00:13:43,770 --> 00:13:45,540
0,240 240,330 330,720
want or not.|
|

453
00:13:45,750 --> 00:13:47,880
0,480 1020,1410 1410,1530 1530,2010 2040,2130
No.| No, I mean you
不是的。|不，我是说你又一次知道，

454
00:13:47,880 --> 00:13:48,660
0,90 90,390 390,570 570,660 660,780
know again,| it would be
|对于应用程序编写者来说，很难真正读到这一点，

455
00:13:48,660 --> 00:13:50,010
0,360 360,480 480,570 570,1080 1080,1350
difficult for an application writer

456
00:13:50,010 --> 00:13:51,270
0,120 120,330 330,570 570,840 840,1260
to actually read about this,|
|

457
00:13:51,780 --> 00:13:53,020
0,690

458
00:13:53,260 --> 00:13:54,520
0,630 630,720 720,840 840,1170 1170,1260
{you,know,particularly}, the new c3 and
你特别知道，新的C3和C4是一回事

459
00:13:54,520 --> 00:13:55,570
0,420 420,540 540,600 600,840 840,1050
c4 were the same thing|
|

460
00:13:55,570 --> 00:13:56,470
0,90 90,390 390,510 510,660 660,900
you first need to teach
你首先需要教一个，

461
00:13:56,470 --> 00:13:58,090
0,60 60,450 450,630 630,1230 1230,1620
{} one,| no modification makes
|任何修改都不会使下一秒返回另一个值，

462
00:13:58,090 --> 00:13:59,410
0,120 120,330 330,600 600,1110 1110,1320
the next second returns another

463
00:13:59,410 --> 00:14:00,610
0,360 360,510 510,600 600,750 750,1200
value,| how is that possible.|
|这怎么可能。|

464
00:14:01,170 --> 00:14:02,490
0,240 240,420 420,480 480,1020 1020,1320
{And,it} make the application program
这使得应用程序的编写变得非常困难。

465
00:14:02,490 --> 00:14:04,280
0,270 270,630 630,720 720,1020
much difficult to write.|
|

466
00:14:04,500 --> 00:14:05,940
0,150 150,480 480,900 930,1080 1080,1440
And so {} you know
所以你知道为什么这种不一致出现在这里，

467
00:14:05,970 --> 00:14:06,780
0,150 150,420 420,510 510,690 690,810
the reason of course that

468
00:14:06,780 --> 00:14:08,760
0,240 240,990 990,1260 1260,1440 1440,1980
this inconsistency shows up here,|
|

469
00:14:08,880 --> 00:14:10,140
0,570 570,660 660,960 960,1080 1080,1260
because we basically have no
因为我们基本上没有协议来协调客户、读者和作者，

470
00:14:10,140 --> 00:14:12,480
0,660 960,1260 1260,1530 1530,2250 2250,2340
protocol to {} coordinate you

471
00:14:12,480 --> 00:14:14,160
0,120 120,900 900,1260 1260,1590 1590,1680
know {the,clients} the readers and

472
00:14:14,160 --> 00:14:15,300
0,60 60,330 360,660 660,870 870,1140
the writers,| so we need
|所以我们需要某种形式的系统，

473
00:14:15,300 --> 00:14:16,860
0,150 150,390 390,570 570,1170 1170,1560
some form of system,| typically
|通常，我们需要某种形式的垂直来解决这些问题

474
00:14:16,860 --> 00:14:17,730
0,120 120,240 240,450 450,690 690,870
we need some form of

475
00:14:17,730 --> 00:14:19,110
0,510 510,630 630,840 840,1230 1230,1380
vertical to fix these| and
|并获得强制执行的愿望，以确保我们获得所需的一致性。

476
00:14:20,250 --> 00:14:21,930
0,360 360,450 450,1050 1050,1200 1200,1680
get the desire to enforce

477
00:14:21,930 --> 00:14:22,710
0,90 90,180 180,330 330,420 420,780
that we get the desired

478
00:14:22,710 --> 00:14:25,710
0,660 2130,2490 2490,2580 2580,2700 2700,3000
consistency.| So we can see
|所以我们可以在这学期剩下的时间里看到，

479
00:14:25,710 --> 00:14:27,030
0,150 150,480 480,930 930,1110 1110,1320
in {rest,of,the} semester,| a whole
|一大堆潜在的协议，

480
00:14:27,030 --> 00:14:28,350
0,150 150,240 240,690 690,1200 1200,1320
bunch of potential protocols,| they
|它们在容错和一致性方面有不同的权衡。

481
00:14:28,350 --> 00:14:29,640
0,150 150,420 420,930 930,1020 1020,1290
have different trade-offs in terms

482
00:14:29,640 --> 00:14:31,140
0,120 120,330 330,780 780,930 930,1500
of fault tolerance and consistency.|
|

483
00:14:32,340 --> 00:14:35,040
0,630 1620,1950 1950,2010 2010,2280 2280,2700
Okay?| And in fact you
好吧?|事实上，你应该让我们的头脑有这样的想法，

484
00:14:35,040 --> 00:14:36,570
0,270 300,600 600,780 780,930 930,1530
should get {} {into -}

485
00:14:36,690 --> 00:14:37,560
0,360 360,450 450,660 660,720 720,870
get our head in that

486
00:14:37,560 --> 00:14:40,200
0,120 120,210 210,690 990,1650 1980,2640
kind of thinking,| {} we're
|我们要用一大堆不同的案例研究

487
00:14:40,320 --> 00:14:41,940
0,630 630,780 780,1140 1140,1410 1410,1620
we're gonna use a whole

488
00:14:41,940 --> 00:14:43,230
0,180 180,240 240,510 510,750 750,1290
bunch of different case studys|
|

489
00:14:43,380 --> 00:14:45,000
0,570 570,840 840,1200 1200,1380 1380,1620
{} and the case study
今天的案例研究是政府飞行服务队。

490
00:14:45,000 --> 00:14:48,440
0,570 690,1350 1350,2400
today is GFS.|
|

491
00:14:54,970 --> 00:14:55,960
0,120 120,270 270,420 420,690 690,990
And this is an interesting
这是一个有趣的案例研究，

492
00:14:55,960 --> 00:14:57,580
0,240 240,630 660,1200 1200,1410 1410,1620
case study,| why we would
|为什么我们会签下它

493
00:14:57,580 --> 00:14:59,650
0,120 120,570 900,1470 1470,1680 1680,2070
have signed it| and one
|其中一个原因是一个有趣的案例研究，

494
00:14:59,650 --> 00:15:00,610
0,270 270,360 360,450 450,720 720,960
reason is an interesting case

495
00:15:00,610 --> 00:15:01,870
0,240 240,510 510,660 660,990 990,1260
study,| because it brings out
|因为它提出了所有这些核心问题，

496
00:15:01,870 --> 00:15:05,110
0,1440 1440,1680 1680,2130 2190,2640 2640,3240
{all,these} core issue,| {GFS -}
|GFS设计旨在获得高性能。

497
00:15:05,110 --> 00:15:06,910
0,750 1020,1440 1440,1500 1500,1620 1620,1800
design designed to get high

498
00:15:06,910 --> 00:15:08,900
0,810
performance.|
|

499
00:15:10,240 --> 00:15:11,800
0,360 360,510 510,960 960,1200 1200,1560
Yeah, that means it actually
是的，这意味着它实际上使用了复制和容错。

500
00:15:11,800 --> 00:15:14,540
0,540 570,2190
uses replication

501
00:15:15,010 --> 00:15:16,540
0,270
{}

502
00:15:18,020 --> 00:15:21,520
0,300 300,450 450,1260
and fault tolerance.|
|

503
00:15:21,730 --> 00:15:24,190
0,960 1080,1800 1830,2190 2190,2310 2310,2460
{} And, {} you know
而且，你知道它很难保持这种一致性，

504
00:15:24,190 --> 00:15:25,690
0,450 450,600 600,750 750,1320 1350,1500
{it,struggles} with this consistency,| so
|所以这就像是一些[主题]，

505
00:15:25,690 --> 00:15:26,620
0,120 120,300 300,360 360,630 630,930
it's like a few [for]

506
00:15:26,620 --> 00:15:27,460
0,180 180,240 240,630 630,780 780,840
sort of [themes],| that we're
|我们将在整个学期中持续看到它，

507
00:15:27,460 --> 00:15:28,870
0,150 150,210 210,360 540,1140 1140,1410
going to be consistently seeing

508
00:15:28,870 --> 00:15:29,980
0,120 120,390 390,480 480,960 960,1110
it throughout the semester,| will
|都会出现在这一篇论文中。

509
00:15:29,980 --> 00:15:30,940
0,210 210,360 360,420 420,570 570,960
show up in this one

510
00:15:30,970 --> 00:15:32,080
0,630
paper.|
|

511
00:15:32,960 --> 00:15:34,850
0,540 660,1320 1320,1650 1650,1740 1740,1890
The other side of this
另一个原因是有趣的案例研究，

512
00:15:34,850 --> 00:15:36,110
0,270 270,540 540,780 780,990 990,1260
why is interesting case study,|
|

513
00:15:36,110 --> 00:15:37,010
0,210 210,270 270,330 330,420 420,900
because it is a {successful,system},|
因为它是一个成功的系统，|

514
00:15:41,030 --> 00:15:44,000
0,1770 1770,2010 2010,2340 2340,2670 2670,2970
Google does actually use {GFS
至少在我的理解中，谷歌确实使用了GFS，

515
00:15:44,000 --> 00:15:45,650
0,450 450,720 810,1020 1020,1290 1290,1650
-} at at least at

516
00:15:45,650 --> 00:15:46,850
0,150 150,450 450,570 570,690 690,1200
this point in my understanding,|
|

517
00:15:46,850 --> 00:15:48,440
0,390 390,480 480,960 960,1230 1230,1590
there's a successor file system
有一个后继文件系统，名为[]，

518
00:15:48,440 --> 00:15:50,120
0,210 210,870 870,1290 1290,1470 1470,1680
called [],| {you,know} but {}
|你知道，但它的灵感来自于GFS。

519
00:15:50,120 --> 00:15:51,980
0,180 180,600 600,720 720,1440
it's inspired by GFS.|
|

520
00:15:51,980 --> 00:15:54,740
0,690 960,1710 1740,2220 2250,2400 2400,2760
{} In, {} but there
中，但还有其他类型的基于群集的文件系统，

521
00:15:54,740 --> 00:15:55,850
0,30 30,300 300,480 480,630 630,1110
are other sort of {}

522
00:15:56,270 --> 00:15:57,710
0,360 360,660 660,900 900,1350 1350,1440
{cluster-based -} file systems,| you
|您知道，对于像MapReduce型使用的HDFS，

523
00:15:57,710 --> 00:15:58,910
0,150 150,330 330,480 480,930 930,1200
know for like mapreduce type

524
00:15:58,910 --> 00:16:01,010
0,330 330,690 840,1200 1200,1770 1830,2100
used {} {HDFS -},| {you,know}
|您也知道，GFS的设计也给了您很大的启发。

525
00:16:01,010 --> 00:16:02,300
0,240 240,480 480,660 660,1170 1170,1290
also very much inspired by

526
00:16:02,300 --> 00:16:03,940
0,120 120,450 450,510 510,1230
the design of GFS.|
|

527
00:16:04,620 --> 00:16:07,020
0,570 1230,1770 1980,2100 2100,2160 2160,2400
{} And you know one
你知道有一件事其实很有趣，

528
00:16:07,020 --> 00:16:08,400
0,150 150,300 300,420 420,750 750,1380
thing that is actually interesting,|
|

529
00:16:08,400 --> 00:16:09,450
0,300 300,390 390,690 690,810 810,1050
at the point that this
在写这篇论文的时候，

530
00:16:09,450 --> 00:16:11,370
0,330 330,510 510,990 1080,1440 1440,1920
paper was written,| {} in
|在差不多2000年的时候，

531
00:16:11,400 --> 00:16:12,810
0,210 210,300 300,540 540,1140 1200,1410
sort of late to {}

532
00:16:12,810 --> 00:16:15,630
0,1290 1290,1950 1950,2340 2340,2700 2700,2820
2000,| {it,was,pretty} distributed {file,system} and
|它是一个相当分布式文件系统，是很容易理解的主题，

533
00:16:15,630 --> 00:16:16,620
0,240 240,540 540,630 630,720 720,990
were well {understood - -}

534
00:16:16,620 --> 00:16:18,060
0,540 600,750 750,990 990,1170 1170,1440
topics,| so people knew about
|所以人们知道什么是宽容，

535
00:16:18,060 --> 00:16:19,320
0,570 570,750 750,870 870,990 990,1260
tolerance,| but they knew about
|但他们知道复制，

536
00:16:19,350 --> 00:16:21,900
0,720 720,930 930,1110 1110,1740 1740,2550
replication,| people knew about consistency,|
|人们知道一致性，|

537
00:16:21,930 --> 00:16:22,590
0,210 210,300 300,420 420,480 480,660
all that kind of stuff
所有这类事情都很容易理解。

538
00:16:22,590 --> 00:16:25,060
0,450 480,1140 1140,1500 1500,2070
were pretty well understood.|
|

539
00:16:25,210 --> 00:16:28,360
0,660 690,1500 1530,2040 2040,2610 2610,3150
{} However, nobody actually built
然而，没有人真正建造出你知道的系统，你知道的，在成千上万台计算机的规模上

540
00:16:28,360 --> 00:16:29,440
0,90 90,210 210,660 660,930 930,1080
you know system {you,know} at

541
00:16:29,440 --> 00:16:31,030
0,90 90,660 660,750 750,1410 1470,1590
the scale of thousands of

542
00:16:31,030 --> 00:16:33,910
0,630 780,1290 1890,2280 2280,2640 2700,2880
computers| and {} that sure
|这肯定会带来一些挑战，

543
00:16:33,910 --> 00:16:35,440
0,360 360,660 660,690 690,1200 1200,1530
brings out a number of

544
00:16:35,440 --> 00:16:37,480
0,810 990,1230 1230,1560 1560,1800 1800,2040
challenges,| {} that previous system
|以前系统不能解决

545
00:16:37,480 --> 00:16:39,130
0,210 210,300 300,510 510,1080 1200,1650
have to not address| and
|而且设计的效果也不完全规范。

546
00:16:39,310 --> 00:16:41,230
0,180 180,750 750,870 870,1740 1770,1920
the effect the design is

547
00:16:41,230 --> 00:16:42,860
0,180 180,570 570,1260
not completely standard.|
|

548
00:16:43,150 --> 00:16:44,770
0,420 420,570 570,870 870,1470 1470,1620
{} So the design that
因此，我们正在阅读的设计，

549
00:16:44,770 --> 00:16:46,090
0,330 330,540 540,930 930,1050 1050,1320
we're reading about,| it's not
|这不是某种不标准的设计，

550
00:16:46,090 --> 00:16:47,170
0,540 540,780 780,900 900,990 990,1080
was not sort of the

551
00:16:47,170 --> 00:16:48,310
0,390 390,810 810,930 930,1020 1020,1140
standard design,| that you would
|你会在当时的学术论文中看到，

552
00:16:48,310 --> 00:16:49,510
0,270 270,360 360,840 840,1140 1140,1200
see in academic papers at

553
00:16:49,510 --> 00:16:51,670
0,210 210,510 1410,1650 1650,1920 1920,2160
that time,| there were two
|制定非标准有两个方面，

554
00:16:51,670 --> 00:16:53,290
0,450 450,510 510,780 780,1020 1020,1620
aspects of making non standard,|
|

555
00:16:53,620 --> 00:16:55,150
0,570 570,840 840,1020 1020,1170 1170,1530
[] which will get more
[]我们会把更多的时间花在哪一项上，

556
00:16:55,180 --> 00:16:56,650
0,330 330,540 540,660 660,960 960,1470
we'll spend more time on,|
|

557
00:16:56,740 --> 00:16:58,180
0,480 480,1020 1020,1140 1140,1260 1260,1440
one is you know there's
一是你知道实际上只有一位大师，

558
00:16:58,180 --> 00:16:59,440
0,240 240,300 300,600 600,1170 1170,1260
actually a single master,| the
|主节点，它不是复制的，

559
00:16:59,440 --> 00:17:01,260
0,630
master,

560
00:17:01,320 --> 00:17:02,640
0,120 120,330 330,870 900,1260 1260,1320
it's not replicated,| there's a
|只有一台机器负责系统中几乎所有的协调

561
00:17:02,640 --> 00:17:03,720
0,240 240,630 630,780 780,990 990,1080
single machine that sort of

562
00:17:03,720 --> 00:17:05,100
0,510 510,600 600,840 840,1200 1200,1380
charged with like almost all

563
00:17:05,100 --> 00:17:06,520
0,60 60,810
the coordination

564
00:17:06,550 --> 00:17:08,830
0,660 660,840 840,930 930,1500 1830,2280
{} in the system {}|
|

565
00:17:08,830 --> 00:17:10,750
0,120 120,300 300,660 660,990 1020,1920
and so that is unusual,|
所以这是不寻常的，|

566
00:17:10,870 --> 00:17:12,340
0,240 240,300 300,930 960,1320 1320,1470
{} you know why would
您知道为什么要构建文件系统容错系统，

567
00:17:12,340 --> 00:17:14,110
0,120 120,540 570,1200 1200,1260 1470,1770
you build {file,system -} fault

568
00:17:14,110 --> 00:17:15,220
0,360 360,690 690,840 840,1020 1020,1110
tolerance system,| which has a
|单点故障并不是当时学术文献中的人正在做的事情

569
00:17:15,220 --> 00:17:16,720
0,240 240,420 420,480 480,960 1440,1500
single point of failure is

570
00:17:16,780 --> 00:17:18,130
0,300 300,600 600,960 960,1230 1230,1350
not something that people in

571
00:17:18,130 --> 00:17:19,660
0,90 90,510 510,870 870,1290 1290,1530
the academic literature were doing

572
00:17:19,660 --> 00:17:21,880
0,60 60,210 210,570 1410,1980 2070,2220
at that time| and the
|第二件事是，它有它不一致，

573
00:17:21,880 --> 00:17:23,620
0,210 210,420 420,660 660,1080 1230,1740
second thing is that, {}

574
00:17:23,620 --> 00:17:26,200
0,180 180,1350 1500,1710 1710,1920 1920,2580
it has it's not consistent,|
|

575
00:17:26,230 --> 00:17:33,120
0,630 630,840 840,1140 1140,2010
{you,know,it} can have inconsistencies.|
你知道它可能会有不一致之处。|

576
00:17:33,180 --> 00:17:35,640
0,150 150,600 600,1290 1290,1590 1740,2460
And again mostly in literature
同样，在那个特定的时期，主要是在文学上，

577
00:17:35,640 --> 00:17:37,080
0,360 360,600 600,750 750,1050 1050,1440
in at that particular time,|
|

578
00:17:37,080 --> 00:17:37,800
0,60 60,180 180,420 420,540 540,720
you know people were really
你知道，人们实际上非常努力地构建具有强大一致性的分布式系统

579
00:17:37,800 --> 00:17:39,630
0,450 450,1110 1110,1200 1200,1560 1560,1830
sweating actually to build the

580
00:17:39,630 --> 00:17:41,190
0,270 270,690 690,900 900,1410 1410,1560
distributed systems that actually have

581
00:17:41,190 --> 00:17:43,230
0,300 300,1080 1230,1620 1620,1710 1710,2040
strong consistency| and you don't
|而且你没有我们在上一块板上看到的异常情况。

582
00:17:43,230 --> 00:17:44,730
0,270 270,330 330,1020 1020,1380 1380,1500
have the anomalies that we

583
00:17:44,730 --> 00:17:45,810
0,150 150,240 240,330 330,660 660,1080
saw on the previous board.|
|

584
00:17:47,120 --> 00:17:49,820
0,420 1080,1320 1320,1620 1830,2310 2460,2700
Alright, and so {} so
好的，所以你知道，就像你所熟知的许多核心技术一样，

585
00:17:49,820 --> 00:17:50,870
0,270 270,600 600,810 810,870 870,1050
you know like a lot

586
00:17:50,870 --> 00:17:51,920
0,90 90,150 150,390 390,960 960,1050
of the core techniques you

587
00:17:51,920 --> 00:17:53,690
0,300 300,540 540,1110 1230,1710 1710,1770
were well known,| {} you
|你知道你拼凑起来的方式本质上是完全不同的。

588
00:17:53,690 --> 00:17:54,470
0,90 90,240 240,540 540,630 630,780
know the way you were

589
00:17:54,470 --> 00:17:56,720
0,240 240,1080 1080,1470 1470,1770 1770,2250
putting together essentially quite different.|
|

590
00:17:58,150 --> 00:17:59,020
0,420 420,540 540,630 630,810 810,870
And so, that makes it
因此，这让它变得有趣

591
00:17:59,020 --> 00:18:01,450
0,420 540,930 930,1530 1530,1620 1620,2430
interesting| and particularly the scale
|特别是，你知道这个系统实际运行的规模是令人印象深刻的。

592
00:18:01,450 --> 00:18:02,470
0,390 390,510 510,600 600,750 750,1020
which you know this system

593
00:18:02,470 --> 00:18:04,820
0,270 270,810 810,1230 1230,1860
actually operates is impressive.|
|

594
00:18:05,120 --> 00:18:06,350
0,180 180,390 390,870 870,990 990,1230
And pretty common {} even
即使在今天也很常见，

595
00:18:06,350 --> 00:18:07,310
0,120 120,510 510,600 600,750 750,960
for today,| you know this
|您知道，这个问题是容错、复制性能和一致性之间的斗争

596
00:18:07,310 --> 00:18:10,550
0,780 960,1770 1860,2490 2490,3000 3000,3240
issue a struggle between fault

597
00:18:10,550 --> 00:18:14,390
0,840 1020,1920 1950,2820 2820,3600 3600,3840
tolerance, {} replication performance and

598
00:18:14,390 --> 00:18:17,810
0,1200 1200,2160 2160,2550 2550,2940 2940,3420
consistency| is standard problem, recurring
|是标准问题，几乎是任何分布式存储系统重复出现问题，

599
00:18:17,810 --> 00:18:19,280
0,390 390,540 540,870 870,1080 1080,1470
problems for almost any distributed

600
00:18:19,280 --> 00:18:20,570
0,270 270,600 600,900 900,1050 1050,1290
storage system,| so that people
|所以今天的人们建造了。

601
00:18:20,570 --> 00:18:21,520
0,180 180,480
built today.|
|

602
00:18:22,660 --> 00:18:23,920
0,180 180,480 480,630 630,990 1020,1260
It changes over time,| like
它会随着时间的推移而改变，|像[]有一段时间，

603
00:18:23,920 --> 00:18:24,970
0,150 150,390 390,540 540,630 630,1050
{[] -} for a while,|
|

604
00:18:24,970 --> 00:18:26,050
0,60 60,180 180,330 330,660 660,1080
you know they really have
你知道他们真的有很强的一致性，

605
00:18:26,050 --> 00:18:27,790
0,180 180,450 450,1200 1200,1620 1620,1740
that strong consistency,| lately {it,has}
|最近，它的一致性变得更强了。

606
00:18:27,790 --> 00:18:29,720
0,240 240,420 420,750 750,1410
gotten much stronger consistency.|
|

607
00:18:30,990 --> 00:18:33,120
0,510 690,1260 1440,1620 1620,1770 1770,2130
Okay, {} so what, {}
好吧，那又怎样，因为这份报纸真的

608
00:18:33,480 --> 00:18:34,470
0,450 450,510 510,720 720,810 810,990
since the paper is really

609
00:18:34,470 --> 00:18:36,390
0,630 870,1350 1350,1440 1440,1830 1830,1920
driven| and the design is
|而设计是由[]通过性能驱动的，

610
00:18:36,390 --> 00:18:38,880
0,240 240,570 570,1440 1470,2130 2130,2490
driven by {} [] by

611
00:18:38,880 --> 00:18:40,500
0,690 720,990 990,1080 1080,1230 1230,1620
performance,| {I,wanted} to go back
|我想回到MapReduce报上做第二次

612
00:18:40,500 --> 00:18:42,720
0,240 240,330 330,540 540,1230 1320,2220
to the {mapreduce -} {}

613
00:18:43,220 --> 00:18:45,050
0,390 390,540 540,1080 1110,1590 1590,1830
paper for second| and this
|这是一张地图还原论文的图表

614
00:18:45,050 --> 00:18:46,280
0,120 120,210 210,900 990,1140 1140,1230
is a graph of the

615
00:18:46,280 --> 00:18:48,020
0,210 210,480 480,960 1290,1470 1470,1740
{mapreduce -} paper| and one
|考虑GFS的一种方式是，它是MapReduce的文件系统。

616
00:18:48,020 --> 00:18:48,860
0,120 120,210 210,390 390,600 600,840
way to think about {GFS

617
00:18:48,860 --> 00:18:51,770
0,600 1200,1590 1590,2250 2340,2730 2730,2910
-} {} is that it's

618
00:18:51,770 --> 00:18:53,700
0,120 120,390 390,960
the file system

619
00:18:53,900 --> 00:18:56,400
0,720 750,960 960,1650
for {mapreduce -}.|
|

620
00:19:00,530 --> 00:19:01,610
0,240 240,360 360,450 450,870 870,1080
And so the goal is
因此，我们的目标是实际运行多个MapReduce作业并获得高性能。

621
00:19:01,610 --> 00:19:02,600
0,120 120,300 300,510 510,750 750,990
to actually run many {mapreduce

622
00:19:02,600 --> 00:19:03,890
0,240 240,780 780,990 990,1110 1110,1290
-} jobs and get high

623
00:19:03,890 --> 00:19:05,040
0,690
performance.|
|

624
00:19:05,250 --> 00:19:07,050
0,480 600,780 780,1110 1110,1380 1380,1800
And we know that basically
我们知道这基本上是从，

625
00:19:07,050 --> 00:19:07,830
0,150 150,390 390,510 510,690 690,780
from,| we could tell from
|我们可以从MapReduce的论文中看出GFS令人印象深刻，

626
00:19:07,830 --> 00:19:09,150
0,60 60,270 270,570 570,960 960,1320
the {mapreduce -} paper already

627
00:19:09,150 --> 00:19:11,640
0,480 480,1500 1590,1830 1830,1980 1980,2490
that GFS {} is impressive,|
|

628
00:19:11,640 --> 00:19:13,350
0,90 90,240 240,540 570,1020 1020,1710
in that manner {in,terms,of} performance,|
以这种方式在性能方面，|

629
00:19:13,680 --> 00:19:14,640
0,330 330,510 510,600 600,780 780,960
{} so if you look
所以如果你看一下这张图的这一面，

630
00:19:14,640 --> 00:19:16,140
0,120 120,540 600,750 750,870 870,1500
at the you know this

631
00:19:16,350 --> 00:19:18,240
0,510 510,600 600,960 960,1590 1590,1890
side of this graph,| this
|这是直接从地图还原论文中脱颖而出的，

632
00:19:18,240 --> 00:19:18,960
0,210 210,510 510,600 600,660 660,720
is straight out of the

633
00:19:18,960 --> 00:19:20,730
0,210 210,450 450,990 1200,1530 1530,1770
{mapreduce -} paper,| {} this
|这是MapReduce作业之一的正常执行，

634
00:19:20,730 --> 00:19:21,930
0,90 90,180 180,510 510,1140 1140,1200
is the normal execution of

635
00:19:21,930 --> 00:19:23,250
0,210 210,270 270,750 750,990 990,1320
one of the {mapreduce -}

636
00:19:23,250 --> 00:19:25,440
0,630 870,1350 1350,1890 1890,2070 2070,2190
jobs,| {} and get it
|而得到它有三个部分，

637
00:19:25,440 --> 00:19:27,690
0,480 570,1170 1590,1950 1950,2100 2100,2250
has three parts to it,|
|

638
00:19:27,690 --> 00:19:28,680
0,240 240,420 420,510 510,720 720,990
one is the first part
一个是第一部分的输入，

639
00:19:28,680 --> 00:19:30,450
0,420 420,660 660,1200 1200,1410 1410,1770
input,| like reading the input
|类似于读取输入文件，

640
00:19:30,450 --> 00:19:31,590
0,360 360,570 570,930 930,1050 1050,1140
files,| the inputs to the
|从文件系统到地图的输入

641
00:19:31,590 --> 00:19:33,450
0,480 840,1170 1170,1260 1260,1500 1500,1860
map from the file system|
|

642
00:19:33,450 --> 00:19:34,230
0,120 120,210 210,510 510,600 600,780
and in case you know
如果你知道他们没怎么说这件事，

643
00:19:34,230 --> 00:19:35,220
0,270 270,510 510,630 630,810 810,990
they didn't say much about

644
00:19:35,220 --> 00:19:36,360
0,60 60,270 390,630 630,750 750,1140
it,| but those are written
|但这些都是从GFS读写的。

645
00:19:36,360 --> 00:19:38,180
0,360 360,870 870,1620
read from GFS.|
|

646
00:19:39,320 --> 00:19:40,460
0,270 270,330 330,630 630,990 990,1140
There's the internal shuffle that
这是我们真正关心的内部洗牌，

647
00:19:40,460 --> 00:19:41,420
0,180 180,360 360,540 540,840 840,960
we really care about,| and
|然后，在最后，您知道REDUTE作业将结果写回GFS。

648
00:19:41,420 --> 00:19:42,740
0,480 480,660 660,750 750,1170 1200,1320
then at the end you

649
00:19:42,740 --> 00:19:44,180
0,240 240,510 510,900 900,1230 1230,1440
know the reduce jobs write

650
00:19:44,180 --> 00:19:46,340
0,300 300,420 420,870 870,1380 1380,2160
back the results into GFS.|
|

651
00:19:47,200 --> 00:19:49,750
0,540 780,1380 1380,1590 1590,2010 2070,2550
And, {} and so, {}
表演也是如此，你知道表演的一部分，

652
00:19:49,780 --> 00:19:51,100
0,330 330,870 870,1020 1020,1110 1110,1320
do performance, you know part

653
00:19:51,100 --> 00:19:52,060
0,90 90,150 150,570 570,780 780,960
of the performance,| there's {mapreduce
|有一个地图还原任务能够由你知道的读者决定，

654
00:19:52,060 --> 00:19:52,960
0,300 300,600 600,690 690,840 840,900
-} task is able to

655
00:19:52,960 --> 00:19:54,220
0,540 540,900 900,1020 1020,1140 1140,1260
determined by you know the

656
00:19:54,220 --> 00:19:55,840
0,300 300,420 420,1050 1140,1470 1470,1620
reader,| at which a the
|此时映射器可以从GFS文件系统中实际读取数据，

657
00:19:55,840 --> 00:19:57,250
0,390 390,480 480,660 660,990 990,1410
{mappers -} can actually read

658
00:19:57,250 --> 00:19:59,170
0,120 120,240 240,570 570,1230 1260,1920
you know data from {}

659
00:19:59,200 --> 00:20:00,580
0,480 480,690 690,1020 1050,1230 1230,1380
GFS file system,| make sure
|确保我们同时运行多个地图绘制程序，

660
00:20:00,580 --> 00:20:01,960
0,240 240,540 540,780 780,990 990,1380
we're running many, many mappers

661
00:20:01,960 --> 00:20:02,680
0,90 90,150 150,360 360,630 630,720
at the same time,| in
|事实上，来自不同工作岗位的一些地图绘制人员可能会读取相同的文件。

662
00:20:02,680 --> 00:20:04,570
0,270 270,630 870,1380 1380,1590 1590,1890
fact some mappers from different

663
00:20:04,570 --> 00:20:05,890
0,420 420,780 780,1020 1020,1110 1110,1320
jobs maybe reading the same

664
00:20:05,890 --> 00:20:06,860
0,630
files.|
|

665
00:20:07,150 --> 00:20:08,110
0,270 270,360 360,540 540,660 660,960
So we look at the
所以我们来看一下输入，

666
00:20:08,110 --> 00:20:10,750
0,600 630,930 930,1350 1350,2310 2310,2640
input,| like this, this there's
|像这样，这是你知道的图的顶端，

667
00:20:10,750 --> 00:20:13,090
0,630 630,780 780,1350 1530,1800 1800,2340
top {you,know} graph,| {} shows
|显示以兆字节/秒为单位的输入

668
00:20:13,090 --> 00:20:15,190
0,630 870,1410 1440,1860 1860,2040 2040,2100
the input in terms of

669
00:20:15,190 --> 00:20:16,780
0,360 360,450 450,930 1230,1470 1470,1590
megabytes per second| at the
|以你所知道的地图绘制者实际上共同为一项特定工作而共同工作的速度，

670
00:20:16,780 --> 00:20:17,680
0,330 330,390 390,690 690,810 810,900
rate at which you know

671
00:20:17,680 --> 00:20:19,870
0,60 60,300 300,930 930,1470 1470,2190
the mapper actually jointly collectively

672
00:20:19,870 --> 00:20:21,160
0,150 150,360 360,750 750,1170 1170,1290
for one particular job,| you
|您可以从文件系统中读取。

673
00:20:21,160 --> 00:20:22,150
0,180 180,450 450,660 660,750 750,990
can read from the file

674
00:20:22,150 --> 00:20:22,900
0,330
system.|
|

675
00:20:23,240 --> 00:20:23,990
0,180 180,270 270,360 360,630 630,750
As you can see, you
正如你所看到的，你知道它会过去，远远超过每秒1000或10000兆字节。

676
00:20:23,990 --> 00:20:25,640
0,180 180,420 420,810 810,1020 1020,1650
know {it,goes} over, well over

677
00:20:25,670 --> 00:20:28,250
0,450 450,1050 1200,1440 1440,2460 2460,2580
a thousand or {10,000,megabytes} per

678
00:20:28,250 --> 00:20:29,220
0,450
second.|
|

679
00:20:30,800 --> 00:20:31,550
0,240 240,360 360,480 480,570 570,750
And you know the first
你知道你要问的第一个问题是

680
00:20:31,550 --> 00:20:32,480
0,210 210,270 270,630 630,810 810,930
question to ask you is|
|

681
00:20:32,480 --> 00:20:34,190
0,510 630,840 840,930 930,1320 1320,1710
maybe not an impressive number.|
也许不是一个令人印象深刻的数字。|

682
00:20:38,180 --> 00:20:39,050
0,240 240,330 330,450 450,780 780,870
Should we be impressed with
如果我们对这个数字印象深刻，你会想得很好。

683
00:20:39,050 --> 00:20:40,460
0,120 120,570 570,690 690,1020 1020,1410
that number are thinking well.|
|

684
00:20:41,520 --> 00:20:42,540
0,240 240,450 450,510 510,720 720,1020
{You,know} give me one disk
你知道，给我一张光盘，我也会这么做的。

685
00:20:42,540 --> 00:20:43,800
0,60 60,270 270,690
{and,I} do too.|
|

686
00:20:50,500 --> 00:20:51,820
0,390 390,840
{Anybody -}?|
有人吗？|

687
00:20:51,820 --> 00:20:53,860
0,180 180,510 510,780 780,1230 1290,2040
I think because it's older,
我想是因为它更老了，也许是的。

688
00:20:53,860 --> 00:20:55,300
0,270 270,930
maybe yes.|
|

689
00:20:56,000 --> 00:20:59,960
0,360 360,2070 2550,3450 3450,3690 3690,3960
{} Okay, SSD, how much
好的，固态硬盘，你的读写速率是多少？

690
00:20:59,960 --> 00:21:01,490
0,720 720,1020 1020,1140 1140,1260 1260,1530
what rates can you write

691
00:21:01,520 --> 00:21:02,440
0,390
read?|
|

692
00:21:08,220 --> 00:21:08,940
0,300 300,420 420,480 480,660 660,720
Okay, let me tell you
好吧，让我告诉你，

693
00:21:08,940 --> 00:21:11,250
0,360 360,810 870,1770 1770,1920 1920,2310
this,| {} roughly the throughput
|大致相当于当时一张磁盘的吞吐量，这张纸大约是每秒30兆字节，

694
00:21:11,250 --> 00:21:12,800
0,120 120,240 240,540 540,1050
of a single disk

695
00:21:12,800 --> 00:21:14,510
0,240 240,780 780,870 870,1260 1260,1710
{} at the time this,

696
00:21:14,960 --> 00:21:16,250
0,240 240,600 600,720 720,1080 1080,1290
this paper was around like

697
00:21:16,250 --> 00:21:17,720
0,510 510,930 930,990 990,1290 1290,1470
thirty megabytes per second,| but
|但在每秒几十兆字节的某个地方。

698
00:21:17,720 --> 00:21:18,530
0,300 300,360 360,450 450,720 720,810
somewhere in the tens of

699
00:21:18,530 --> 00:21:19,920
0,390 390,480 480,720
megabytes a second.|
|

700
00:21:20,810 --> 00:21:21,920
0,210 210,390 390,480 480,750 750,1110
So here we're looking at
所以我们现在看到的是超过10000兆字节每秒的数据，对吗？

701
00:21:21,950 --> 00:21:24,470
0,150 150,540 630,1050 1050,1290 1290,2520
you know well over {10000,megabytes}

702
00:21:24,470 --> 00:21:25,560
0,60 60,540
per second,

703
00:21:26,560 --> 00:21:27,520
0,420 420,540 540,660 660,870 870,960
correct,| and so that is
|这是一个令人印象深刻的数字。

704
00:21:27,520 --> 00:21:29,000
0,60 60,480 480,960
an impressive number.|
|

705
00:21:29,540 --> 00:21:30,860
0,360 360,660 660,810 810,930 930,1320
And {you,know,you} have to work|
你知道你必须工作|

706
00:21:30,860 --> 00:21:32,150
0,210 210,330 330,540 540,870 930,1290
as you know the seeing
正如您所知道的，GFS设计允许这种吞吐量。

707
00:21:32,150 --> 00:21:33,590
0,120 120,510 510,840 840,960 960,1440
the GFS design that allows

708
00:21:33,590 --> 00:21:35,020
0,210 210,390 390,450 450,930
that kind of throughput.|
|

709
00:21:36,260 --> 00:21:38,150
0,150 150,450 450,750 750,1410 1410,1890
Of course, this technology indications
当然，这项技术表明GFS，

710
00:21:38,150 --> 00:21:39,770
0,540 540,630 630,900 900,1170 1170,1620
GFS,| of course this technology
|当然，这项技术更快，

711
00:21:39,770 --> 00:21:41,450
0,120 120,750 930,1110 1110,1350 1350,1680
was faster,| it would be
|你应该知道这里真正的目标是什么，

712
00:21:41,450 --> 00:21:42,170
0,90 90,210 210,420 420,480 480,720
you know what the real

713
00:21:42,170 --> 00:21:43,400
0,330 330,540 540,870 870,1020 1020,1230
goal here correctly,| it's like
|就像我们有一千台机器，

714
00:21:43,400 --> 00:21:44,480
0,90 90,180 180,240 240,540 540,1080
we have a thousand machines,|
|

715
00:21:44,690 --> 00:21:45,680
0,360 360,480 480,660 660,900 900,990
maybe each one has a
也许每个人都有一张光盘，

716
00:21:45,680 --> 00:21:47,240
0,420 420,720 720,1020 1020,1290 1290,1560
disk,| each one read thirty
|每一个都读取每秒30兆字节，

717
00:21:47,240 --> 00:21:48,560
0,450 450,510 510,960 1020,1260 1260,1320
megabytes per second,| which is
|这是每秒1000乘以30兆字节才能摆脱它。

718
00:21:48,560 --> 00:21:50,360
0,750 750,990 990,1440 1440,1500 1500,1800
{1000,times} thirty megabytes per second

719
00:21:50,420 --> 00:21:51,170
0,90 90,270 270,450 450,540 540,750
to get out of it.|
|

720
00:21:51,800 --> 00:21:52,960
0,600
Okay?|
好吧?|

721
00:21:53,410 --> 00:21:56,290
0,480 660,1320 1410,1980 2130,2820 2820,2880
So {} {that't,what,you,know} drives a
所以这并不是你所知道的驱动这个设计的很多东西是

722
00:21:56,290 --> 00:21:57,460
0,180 180,270 270,450 450,960 990,1170
lot of this design is|
|

723
00:21:57,460 --> 00:21:59,380
0,240 240,870 870,1260 1260,1380 1380,1920
to immediately allow the mappers
以立即允许映射器从文件系统、联合文件系统并行读取。

724
00:21:59,380 --> 00:22:01,360
0,270 270,750 780,990 990,1650 1680,1980
to read in parallel from

725
00:22:01,360 --> 00:22:03,280
0,120 120,390 390,720 720,1680 1680,1920
the file system, {} joint

726
00:22:03,280 --> 00:22:04,360
0,270 270,600
file system.|
|

727
00:22:04,910 --> 00:22:06,020
0,570
Okay?|
好吧?|

728
00:22:06,850 --> 00:22:07,720
0,240 240,360 360,600 600,690 690,870
Let me say a little
关于这一点，让我再说一点，

729
00:22:07,720 --> 00:22:09,100
0,330 390,780 780,1020 1020,1140 1140,1380
bit more about this,| about
|关于GFS的关键属性是什么，

730
00:22:09,100 --> 00:22:10,360
0,150 150,240 240,300 300,510 510,1260
what are the key properties

731
00:22:10,810 --> 00:22:12,820
0,360 360,780 780,1440 1800,1920 1920,2010
that GFS has,| you know
|你知道，一个大数据集记住了这一点，我是认真的。

732
00:22:12,820 --> 00:22:15,540
0,390 390,870
one big

733
00:22:16,080 --> 00:22:18,570
0,1050 1050,1320 1320,1590 1590,2040 2040,2490
large data sets remember that,

734
00:22:18,780 --> 00:22:23,200
0,240 240,480 480,1080
I mean that.|
|

735
00:22:23,900 --> 00:22:24,770
0,240 240,420 420,570 570,660 660,870
And so in the think
因此，在我看来，你应该考虑的数据集就像MapReduce型数据集，

736
00:22:24,770 --> 00:22:25,700
0,90 90,480 480,570 570,750 750,930
the {data,set} you should think

737
00:22:25,700 --> 00:22:26,810
0,300 300,420 420,570 570,810 810,1110
about is like {mapreduce -}

738
00:22:26,810 --> 00:22:27,980
0,210 210,570 570,900 900,1110 1110,1170
data sets,| you're going to
|你将在万维网上进行一次完整的爬行，

739
00:22:27,980 --> 00:22:31,580
0,150 150,2130 2610,3000 3000,3510 3510,3600
have a complete crawl the

740
00:22:31,580 --> 00:22:32,720
0,180 180,390 390,660 690,840 840,1140
world wide web,| is stored
|存储在该分布式文件系统中，

741
00:22:32,720 --> 00:22:34,340
0,90 90,450 660,1020 1020,1260 1260,1620
in this distributed file system,|
|

742
00:22:35,460 --> 00:22:37,140
0,570 690,930 930,990 990,1080 1080,1680
{} has to be fast,|
必须要快，|

743
00:22:37,140 --> 00:22:39,120
0,330 360,720 720,1110 1650,1740 1740,1980
we talked about the way
我们谈到了他们获得高性能的方法是进行自动分片，

744
00:22:39,120 --> 00:22:40,590
0,150 150,450 450,600 600,750 750,1470
they get like high {performance,is}

745
00:22:40,590 --> 00:22:43,340
0,150 150,360 360,810 810,1230
to do automatic sharding,|
|

746
00:22:43,730 --> 00:22:45,620
0,390 390,780 780,1110 1110,1440 1440,1890
shard files across multiple disks,|
跨多个磁盘的碎片文件，|

747
00:22:45,830 --> 00:22:47,720
0,780 810,1200 1200,1590 1590,1680 1680,1890
allow multiple clients to read
允许多个客户端从这些可比较的磁盘中读取数据。

748
00:22:47,720 --> 00:22:49,600
0,150 150,330 330,570 570,1170
from those disks comparable.|
|

749
00:22:49,600 --> 00:22:50,620
0,480
Alright?|
好吗？|

750
00:22:51,710 --> 00:22:56,090
0,240 240,480 480,990 3900,4200 4200,4380
It goes global, what that
它走向全球，这意味着它在哪里共享，所有的应用程序，

751
00:22:56,090 --> 00:22:58,100
0,450 450,1140 1140,1620 1620,1830 1830,2010
mean it's shared where again

752
00:22:58,100 --> 00:23:02,300
0,330 330,930 3300,3690 3690,3930 3930,4200
all apps,| see same file
|请参见相同的文件系统。

753
00:23:02,300 --> 00:23:03,580
0,390
system.|
|

754
00:23:06,190 --> 00:23:07,450
0,150 150,330 330,810 810,960 960,1260
And that's convenient,| like if
这很方便，|例如，如果您有多个MapReduce作业，

755
00:23:07,450 --> 00:23:09,370
0,210 210,420 420,1350 1380,1620 1620,1920
you have multiple {mapreduce -}

756
00:23:09,370 --> 00:23:11,260
0,570 570,630 630,990 990,1350 1350,1890
jobs,| you know that operate
|您知道，对同一组文件进行操作，

757
00:23:11,260 --> 00:23:12,160
0,300 300,420 420,660 660,840 840,900
on the same set of

758
00:23:12,160 --> 00:23:14,530
0,690 930,1560 1560,1950 1950,2190 2190,2370
files,| {} they can, first
|首先，他们可以读取所有相同的文件集，

759
00:23:14,530 --> 00:23:15,190
0,90 90,210 210,420 420,570 570,660
of all read all the

760
00:23:15,190 --> 00:23:16,150
0,210 210,360 360,450 450,810 810,960
same set of files,| but
|但他们可以制作新的文件

761
00:23:16,150 --> 00:23:17,410
0,120 120,240 240,690 690,900 900,1260
they can produce new files|
|

762
00:23:17,410 --> 00:23:18,460
0,210 210,390 390,720 720,900 900,1050
and another mapreduce you can
如果是另一个MapReduce，您可以再次使用这些文件

763
00:23:18,460 --> 00:23:20,020
0,180 180,630 690,1050 1050,1320 1350,1560
use those files again| and
|因此，在应用程序之间进行大量共享非常方便，

764
00:23:20,020 --> 00:23:21,460
0,120 120,240 240,630 630,1260 1260,1440
so it's very convenient to

765
00:23:21,460 --> 00:23:22,270
0,90 90,120 120,240 240,330 330,810
have a lot of sharing

766
00:23:22,270 --> 00:23:23,800
0,540 540,1170 1170,1260 1260,1350 1350,1530
between applications,| so it's very
|所以拥有它是非常方便的。

767
00:23:23,800 --> 00:23:24,940
0,330 330,390 390,720
convenient to have.|
|

768
00:23:26,000 --> 00:23:26,720
0,180 180,390 390,450 450,570 570,720
Of course, you know the
当然，您知道GFS必须具有容错能力。

769
00:23:26,720 --> 00:23:27,530
0,270 270,420 420,480 480,600 600,810
GFS has to be fault

770
00:23:27,530 --> 00:23:28,680
0,390
tolerant.|
|

771
00:23:33,710 --> 00:23:34,760
0,330 330,630 630,810 810,960 960,1050
It's likely they're gonna be
他们很可能会失败，

772
00:23:34,760 --> 00:23:36,140
0,450 450,750 750,870 870,990 990,1380
failures,| it's what we want
|这是我们想要的，就像自动的，

773
00:23:36,140 --> 00:23:37,900
0,180 180,900
like automatic,|
|

774
00:23:37,990 --> 00:23:40,000
0,300 300,390 390,900 900,1320 1320,2010
close to automatic {fault,tolerance} {as,possible},|
尽可能接近自动容错，|

775
00:23:40,000 --> 00:23:41,290
0,120 120,360 360,750 750,990 990,1290
you'll see GFS doesn't provide
你会发现GFS并不是完全自动的，

776
00:23:41,290 --> 00:23:42,460
0,300 300,750 750,870 870,1080 1080,1170
completely automatic,| but do a
|但在提高容错能力方面做得相当好。

777
00:23:42,460 --> 00:23:43,840
0,210 210,330 330,750 750,1170 1170,1380
pretty good job with getting

778
00:23:43,840 --> 00:23:46,300
0,420 660,930 930,1110 1110,1530
high with fault tolerance.|
|

779
00:23:48,160 --> 00:23:50,320
0,240 240,450 450,870 870,1230 1230,2160
Okay, any questions about the,
好的，到目前为止，关于这一部分有什么问题吗，

780
00:23:50,950 --> 00:23:52,780
0,360 360,600 600,780 780,1170 1590,1830
this part so far,| like
|就像对这个主题的广泛介绍一样，

781
00:23:52,780 --> 00:23:54,520
0,0 240,630 630,1260 1440,1560 1560,1740
a broad intro to this

782
00:23:54,520 --> 00:23:57,550
0,510 510,1110 1110,1110 2460,2760 2760,3030
topic,| then a few intro
|然后是关于GFS的几个介绍性奖项。

783
00:23:57,550 --> 00:23:59,580
0,330 330,870 870,1470
awards about GFS.|
|

784
00:24:04,330 --> 00:24:05,420
0,570
Okay.|
好吧。|

785
00:24:05,420 --> 00:24:06,080
0,150 150,240 240,420 420,570 570,660
Let's then talk about the
然后让我们来讨论一下设计。

786
00:24:06,080 --> 00:24:07,200
0,570
design.|
|

787
00:24:10,220 --> 00:24:12,320
0,330

788
00:24:13,940 --> 00:24:16,880
0,180 180,510 510,1470 1920,2850 2850,2940
So here's the design is
这里的设计是从图中看到的，我认为是论文中的一个，

789
00:24:16,880 --> 00:24:19,250
0,360 360,630 630,1230 1410,1710 1710,2370
seen in {} from the

790
00:24:19,520 --> 00:24:20,390
0,360 360,540 540,600 600,780 780,870
figure one I think in

791
00:24:20,390 --> 00:24:22,070
0,60 60,600 930,1380 1380,1620 1620,1680
the paper,| and there's a
|有几件事我想更详细地指出。

792
00:24:22,070 --> 00:24:22,970
0,180 180,390 390,450 450,720 720,900
couple things I wanted to

793
00:24:22,970 --> 00:24:23,780
0,240 240,390 390,540 540,630 630,810
point out that a little

794
00:24:23,780 --> 00:24:25,010
0,150 150,420 420,510 510,840 840,1230
bit more in detail about.|
|

795
00:24:25,480 --> 00:24:26,290
0,150 150,330 330,390 390,720 720,810
So, first of all you
所以，首先你知道，我们有一个应用程序

796
00:24:26,290 --> 00:24:27,280
0,150 150,270 270,390 390,450 450,990
know, we have an application|
|

797
00:24:27,280 --> 00:24:27,940
0,90 90,390 390,450 450,540 540,660
and then you know the
然后你又知道了这个应用程序，

798
00:24:27,940 --> 00:24:29,170
0,480 480,870 900,990 990,1080 1080,1230
application again,| you know might
|您知道，MapReduce[]可能正在消耗多个减少的任务、多个地图任务

799
00:24:29,170 --> 00:24:31,210
0,240 240,420 420,780 780,1050 1440,2040
be {mapreduce -} [] consuming

800
00:24:31,210 --> 00:24:33,550
0,930 930,1320 1320,1770 1770,2070 2070,2340
multiple reduced task, multiple map

801
00:24:33,550 --> 00:24:35,830
0,600 900,1470 1470,1620 1620,2100 2100,2280
task| and they link with
|他们与政府飞行服务队联系在一起，

802
00:24:35,830 --> 00:24:37,780
0,120 120,630 630,1050 1170,1530 1530,1950
the GFS,| like and so,
|像这样，它不是Linux文件系统，

803
00:24:37,990 --> 00:24:39,250
0,450 450,690 690,900 900,960 960,1260
{} it's not a Linux

804
00:24:39,250 --> 00:24:40,450
0,240 240,690 720,870 870,990 990,1200
file system,| you know this
|你知道这不是文件系统，你习惯于你知道任何文件或编译，

805
00:24:40,450 --> 00:24:41,410
0,90 90,330 330,420 420,660 660,960
is not the file system,

806
00:24:41,410 --> 00:24:42,610
0,210 210,510 510,990 990,1080 1080,1200
you used to you know

807
00:24:42,610 --> 00:24:44,560
0,510 510,900 900,1320
whatever any files

808
00:24:44,560 --> 00:24:46,390
0,300 300,990 1020,1470 1470,1710 1710,1830
or compile,| {} it is
|它实际上是一个专门用于这些大型计算的文件系统。

809
00:24:46,390 --> 00:24:48,130
0,360 360,1020 1020,1140 1140,1410 1410,1740
really intended, you know as

810
00:24:48,130 --> 00:24:50,080
0,330 570,1080 1080,1440 1440,1680 1680,1950
a special purpose file system

811
00:24:50,080 --> 00:24:52,880
0,180 180,450 450,1500 1500,2340
for these large computations.|
|

812
00:24:53,800 --> 00:24:54,910
0,300 300,390 390,450 450,630 630,1110
And as I said before
正如我之前所说，我们的真正目标正确地实现了一个令人印象深刻的数字

813
00:24:54,910 --> 00:24:57,220
0,300 300,570 570,870 870,1170 1470,2310
our real goal correctly achieves

814
00:24:57,220 --> 00:24:58,810
0,90 90,510 510,1020 1020,1260 1260,1590
an impressive number| like we
|就像我们想要单个磁盘的兆字节数乘以机器数量一样

815
00:24:58,810 --> 00:24:59,920
0,240 240,330 330,540 540,600 600,1110
want the number of megabytes

816
00:24:59,920 --> 00:25:01,150
0,360 360,390 390,690 690,930 930,1230
from a single disk times

817
00:25:01,150 --> 00:25:02,260
0,210 210,300 300,720 720,960 960,1110
number of machines| and a
|单个应用程序应该能够利用这一点。

818
00:25:02,260 --> 00:25:03,460
0,330 330,810 810,960 960,1050 1050,1200
single application should be able

819
00:25:03,460 --> 00:25:04,720
0,60 60,450 450,720
to exploit that.|
|

820
00:25:04,840 --> 00:25:05,860
0,240 240,360 360,540 540,690 690,1020
So the way they arrange
所以他们安排的方式是

821
00:25:05,860 --> 00:25:07,630
0,330 330,630 630,1170 1350,1620 1620,1770
that is to| {} have
|有一个基本上负责实际知道东西在哪里的主人

822
00:25:07,630 --> 00:25:09,730
0,330 330,1050 1320,1590 1590,1680 1680,2100
a master that is basically

823
00:25:09,730 --> 00:25:11,110
0,90 90,630 630,780 780,1050 1050,1380
in charge of actually know

824
00:25:11,110 --> 00:25:12,580
0,270 270,510 510,900 1080,1410 1410,1470
where things are| and the
|客户只是周期性地与主人交谈，

825
00:25:12,580 --> 00:25:14,470
0,330 330,540 540,1470 1500,1800 1800,1890
clients just periodically talks to

826
00:25:14,470 --> 00:25:16,780
0,90 90,720 720,1290 1320,1740 1740,2310
the master,| {} to {}
|为了检索信息，

827
00:25:17,590 --> 00:25:18,880
0,150 150,240 240,540 540,1080 1080,1290
to {retrieve -} information,| so
|例如，它会打开文件

828
00:25:18,880 --> 00:25:20,110
0,60 60,570 690,870 870,1140 1140,1230
for example it opens the

829
00:25:20,110 --> 00:25:21,970
0,600 660,840 840,1140 1140,1590 1590,1860
file| and open call will
|打开呼叫将导致向主控发送一条消息

830
00:25:21,970 --> 00:25:24,070
0,510 510,930 930,1260 1260,1650 1650,2100
result in a message to

831
00:25:24,070 --> 00:25:27,790
0,330 720,1590 1590,2220 2550,3090 3180,3720
the master| and a master
|并且主机将回复并像所有特定的文件名一样说，

832
00:25:27,790 --> 00:25:28,810
0,150 150,510 510,780 780,870 870,1020
will respond back and say

833
00:25:28,810 --> 00:25:30,790
0,210 210,420 420,750 780,1320 1320,1980
like all the particular filename,|
|

834
00:25:30,850 --> 00:25:32,080
0,240 240,540 540,660 660,780 780,1230
the chunks that you need
你需要的大块就在这里，

835
00:25:32,110 --> 00:25:34,640
0,1440 1440,1620 1620,2220
{} are here,|
|

836
00:25:34,640 --> 00:25:35,600
0,360 360,510 510,600 600,690 690,960
well, these are the chunks
好的，这些是你需要的块

837
00:25:35,600 --> 00:25:37,430
0,120 120,240 240,660 930,1620 1620,1830
that you need| and there's
|并且存在用于构成文件的特定块的块句柄标识符，

838
00:25:37,430 --> 00:25:39,260
0,90 120,420 420,1020 1020,1710 1710,1830
a chunk handles identifier for

839
00:25:39,260 --> 00:25:40,940
0,60 60,390 390,690 690,1200 1200,1680
the particular chunks that constitute

840
00:25:40,940 --> 00:25:42,410
0,60 60,600 750,930 930,1350 1350,1470
a file,| and here are
|这是确保该块数据的服务器，

841
00:25:42,410 --> 00:25:44,750
0,90 90,660 990,1380 1380,1890 2130,2340
the servers that sure that

842
00:25:44,750 --> 00:25:46,100
0,330 360,600 600,720 720,870 870,1350
chunk,| so you get back
|因此，您可以得到块句柄以及一堆块位置。

843
00:25:46,100 --> 00:25:47,780
0,150 150,450 450,1110 1260,1410 1410,1680
{} chunk handle as well

844
00:25:47,780 --> 00:25:48,800
0,330 360,480 480,690 690,780 780,1020
as a bunch of chunk

845
00:25:48,800 --> 00:25:49,880
0,660
locations.|
|

846
00:25:50,620 --> 00:25:51,820
0,150 150,390 390,900 900,1140 1140,1200
And one file might you
你可能知道有一个文件基本上由文件组成，

847
00:25:51,820 --> 00:25:53,620
0,300 330,870 870,1140 1140,1590 1590,1800
know basically file consists,| if
|如果你想到一个大文件，

848
00:25:53,620 --> 00:25:54,490
0,90 90,240 240,510 510,630 630,870
you think about a big

849
00:25:54,490 --> 00:25:56,650
0,570 1260,1530 1530,1890 1890,1980 1980,2160
file,| it consists of many
|它由许多块组成，块0、块1、块2等，块3等等，

850
00:25:56,650 --> 00:26:00,670
0,270 270,810 2700,3090 3090,3750 3750,4020
many chunks, chunk 0, chunk

851
00:26:00,670 --> 00:26:03,970
0,630 1110,1470 1470,1920 1920,2580 2910,3300
1, chunk 2, etc, chunk

852
00:26:03,970 --> 00:26:06,580
0,570 600,1050 1050,1380 1410,1890 1890,2610
3 blah, blah, etc, etc,|
|

853
00:26:06,580 --> 00:26:08,080
0,180 180,570 570,1170 1170,1290 1290,1500
any {chunk -} is pretty
任何块都是相当大的，64兆字节。

854
00:26:08,080 --> 00:26:10,360
0,300 420,1050 1050,1530
big, 64 megabytes.|
|

855
00:26:12,060 --> 00:26:13,590
0,420 420,600 600,1020 1020,1230 1230,1530
Naturally, the application once we
当然，一旦我们知道第二个64兆字节的应用程序，

856
00:26:13,590 --> 00:26:14,910
0,90 90,240 240,510 510,990 990,1320
you know second second {}

857
00:26:14,910 --> 00:26:16,710
0,300 300,690 690,1020 1020,1260 1530,1800
second 64 megabyte,| it goes
|它被送到GFS是这样的，我想给你读第二块，

858
00:26:16,710 --> 00:26:18,930
0,300 300,930 1410,1650 1650,1920 1920,2220
to the {GFS -} is

859
00:26:18,930 --> 00:26:20,910
0,180 180,480 480,570 570,1260 1290,1980
like okay, I wanna read

860
00:26:20,910 --> 00:26:22,470
0,180 180,300 300,570 570,1080 1410,1560
you the second chunk,| you
|你知道这个特别的文件

861
00:26:22,470 --> 00:26:24,450
0,210 210,390 390,780 780,1410 1530,1980
know this particular file {}|
|

862
00:26:24,450 --> 00:26:25,950
0,570 570,630 630,840 840,1260 1260,1500
and the GFS answer will
并且GFS应答将使用块1的句柄进行应答，

863
00:26:25,950 --> 00:26:27,240
0,270 270,660 660,780 780,870 870,1290
answer back with the handle

864
00:26:27,240 --> 00:26:29,070
0,390 390,780 810,1050 1050,1560 1620,1830
for {} chunk 1,| as
|以及实际保存块1的服务器，对吧。

865
00:26:29,070 --> 00:26:30,030
0,210 210,300 300,360 360,810 810,960
well as the servers that

866
00:26:30,030 --> 00:26:31,740
0,270 270,780 780,1020 1020,1290
actually holds chunk 1,

867
00:26:32,020 --> 00:26:33,000
0,450
right.|
|

868
00:26:33,910 --> 00:26:36,610
0,510 510,1140 1170,1680 1680,2280 2280,2700
So {} multiple applications might
因此，多个应用程序可能会要求从同一文件中获取块，

869
00:26:36,640 --> 00:26:38,230
0,480 480,660 660,1140 1140,1410 1410,1590
ask {you,know} for chunks from

870
00:26:38,230 --> 00:26:39,880
0,60 60,300 300,900 1020,1500 1500,1650
the same file,| and they
|它们都会让您知道一个应用程序可能正在读取区块0，

871
00:26:39,880 --> 00:26:41,650
0,270 270,570 570,690 690,1260 1260,1770
all get you know {}

872
00:26:42,310 --> 00:26:43,420
0,180 180,570 570,750 750,870 870,1110
one application might be reading

873
00:26:43,420 --> 00:26:44,860
0,210 210,540 540,810 810,1230 1230,1440
chunk 0,| another application might
|另一应用程序可以是读取块2，

874
00:26:44,860 --> 00:26:46,120
0,90 90,390 390,510 510,780 780,1260
be read {} chunk 2,|
|

875
00:26:46,150 --> 00:26:47,830
0,300 300,720 720,990 990,1350 1350,1680
they'll get different lists back
他们将从这些块中得到不同的列表。

876
00:26:47,830 --> 00:26:48,880
0,120 120,270 270,360 360,540 540,1050
from each of these chunks.|
|

877
00:26:50,460 --> 00:26:51,570
0,150 150,330 330,420 420,750 750,1110
So then the GFS client
因此，一旦GFS客户端知道区块位置，它就会知道

878
00:26:51,570 --> 00:26:52,920
0,90 90,180 180,420 420,750 750,1350
you know {once,it} knows chunk

879
00:26:52,920 --> 00:26:55,170
0,720 750,870 870,1230 1230,1740 1740,2250
locations| and basically straight talks
|基本上直接与数据块服务器对话，

880
00:26:55,170 --> 00:26:56,780
0,150 150,240 240,480 480,1110
to the chunk servers,|
|

881
00:26:57,670 --> 00:27:01,300
0,510 510,1110 1170,1920 1980,3540 3540,3630
{} and basically read you
基本上是以网络的速度读取数据，

882
00:27:01,300 --> 00:27:02,830
0,120 120,210 210,840 870,1050 1050,1530
know the data at the

883
00:27:03,310 --> 00:27:04,510
0,450 450,510 510,600 600,960 960,1200
speed of the network,| and
|你知道，可能你所知道的每个磁盘都位于这个特定的区块服务器后面，直接连接到应用程序。

884
00:27:04,510 --> 00:27:05,710
0,90 90,180 180,420 420,870 870,1200
you know maybe every disk

885
00:27:05,710 --> 00:27:06,520
0,90 90,210 210,360 360,540 540,810
you know that sits behind

886
00:27:06,520 --> 00:27:08,440
0,120 120,600 600,840 840,1380 1470,1920
this particular chunk server, {}

887
00:27:08,440 --> 00:27:10,200
0,420 420,540 540,630 630,1260
directly to the application.|
|

888
00:27:10,480 --> 00:27:11,260
0,150 150,390 390,510 510,600 600,780
And here you can see
在这里你可以看到我们将在哪里获得重大胜利，对吧，

889
00:27:11,260 --> 00:27:11,980
0,270 270,360 360,480 480,540 540,720
where we're going to get

890
00:27:11,980 --> 00:27:13,300
0,90 90,360 360,600 720,1050 1050,1320
the big win, right,| because
|因为我们将会识字，

891
00:27:13,300 --> 00:27:14,080
0,120 120,270 270,420 420,660 660,780
we're gonna be able to

892
00:27:14,080 --> 00:27:15,640
0,420 420,570 570,780 780,1470 1470,1560
read,| {you,know} for multiple you
|您知道，对于多个磁盘，可以同时从多个磁盘读取多个客户端

893
00:27:15,640 --> 00:27:17,620
0,870 900,1380 1380,1740 1740,1860 1860,1980
know multiple clients can be

894
00:27:17,620 --> 00:27:18,700
0,270 270,390 390,720 720,990 990,1080
read from multiple disks at

895
00:27:18,700 --> 00:27:20,470
0,90 90,330 330,870 1140,1620 1620,1770
the same time| and we're
|我们将获得巨大的表现，

896
00:27:20,470 --> 00:27:21,490
0,120 120,180 180,510 510,870 870,1020
going to get tremendous amount

897
00:27:21,490 --> 00:27:23,800
0,60 60,840 1050,1320 1320,1920 1980,2310
of performance,| so general, means
|所以一般的意思是这里的地图任务正在运行，

898
00:27:23,800 --> 00:27:25,420
0,180 180,480 480,750 750,1080 1080,1620
like here's map task running,|
|

899
00:27:25,750 --> 00:27:27,400
0,270 270,540 540,840 840,1110 1110,1650
here's another map tasks running,|
这是另一个正在运行的地图任务，|

900
00:27:27,400 --> 00:27:28,570
0,180 180,420 420,510 510,570 570,1170
that also as a client,|
也是作为客户，|

901
00:27:28,870 --> 00:27:29,710
0,180 180,300 300,570 570,690 690,840
you know they you know
你知道，他们会和一组服务器对话，

902
00:27:29,710 --> 00:27:30,700
0,360 360,420 420,540 540,870 870,990
going to be talking to

903
00:27:30,700 --> 00:27:31,810
0,90 90,330 330,390 390,1020 1020,1110
the set of servers,| we
|我们有一个完整的，你知道的，所有集合的大块，数据集

904
00:27:31,810 --> 00:27:32,800
0,120 120,270 270,810 810,870 870,990
have that whole you know

905
00:27:32,800 --> 00:27:33,670
0,150 150,450 450,570 570,810 810,870
the chunk of all the

906
00:27:33,670 --> 00:27:35,440
0,480 480,630 630,1230 1350,1560 1560,1770
collection the {data,set}| and there's
|并且将从所有不同的块服务器并行读取。

907
00:27:35,440 --> 00:27:37,030
0,240 240,660 660,870 870,1380 1380,1590
gonna read in parallel from

908
00:27:37,030 --> 00:27:38,800
0,120 120,330 330,930 930,1140 1140,1770
all those different chunk servers.|
|

909
00:27:39,200 --> 00:27:39,770
0,210 210,270 270,390 390,510 510,570
And I was going to
我本打算给我们一个高吞吐量的数字。

910
00:27:39,770 --> 00:27:41,510
0,180 180,330 330,600 600,1110 1110,1740
give us a high throughput

911
00:27:41,630 --> 00:27:43,740
0,900 960,1560
{} number.|
|

912
00:27:45,090 --> 00:27:46,200
0,210 210,390 390,810 810,960 960,1110
That makes sense, that's sort
这是有道理的，这是这里明确的总体计划。

913
00:27:46,200 --> 00:27:47,250
0,60 60,150 150,480 480,750 750,1050
of the overall plan clear

914
00:27:47,250 --> 00:27:48,220
0,420
here.|
|

915
00:27:52,590 --> 00:27:54,000
0,270 270,360 360,780 780,1230 1230,1410
Just to {sort,of} completed,| like
在某种程度上完成，|就像在区块服务器上什么都不是，有点像Linux盒子，Linux计算机上有你知道的磁盘，

916
00:27:54,000 --> 00:27:56,040
0,720 900,1260 1260,1620 1620,1770 1770,2040
on chunk server is nothing

917
00:27:56,040 --> 00:27:57,540
0,300 300,900 900,1260 1260,1410 1410,1500
really, {} and sort of

918
00:27:57,540 --> 00:27:59,760
0,330 330,750 750,1260 1290,1680 1680,2220
a Linux box, Linux computer

919
00:27:59,760 --> 00:28:01,680
0,300 300,510 510,1260 1470,1680 1680,1920
with {you,know} {disk,to,it},| in fact
|事实上，有64兆字节的数据块，

920
00:28:01,680 --> 00:28:03,240
0,150 150,210 210,690 690,1140 1140,1560
there's {} 64 megabyte chunk,|
|

921
00:28:03,330 --> 00:28:04,500
0,240 240,570 570,690 690,780 780,1170
each store as a Linux
每个文件都作为一个Linux文件存储在Linux文件系统中。

922
00:28:04,500 --> 00:28:06,240
0,630 720,1050 1050,1200 1200,1470 1470,1740
file in the Linux file

923
00:28:06,240 --> 00:28:07,080
0,420
system.|
|

924
00:28:07,710 --> 00:28:08,840
0,570
Okay?|
好吧?|

925
00:28:12,080 --> 00:28:12,770
0,210 210,330 330,360 360,540 540,690
Okay, so I want to
好的，我想把不同的片段放大

926
00:28:12,770 --> 00:28:13,700
0,300 300,420 420,540 540,630 630,930
zoom in on the different

927
00:28:13,700 --> 00:28:15,440
0,660 720,1140 1140,1290 1290,1620 1620,1740
pieces| and I'll start with
|我先从大师说起，

928
00:28:15,440 --> 00:28:16,820
0,60 60,480 480,750 750,1230 1230,1380
the master,| because masters are
|因为师傅跟这里的控制中心有关系，

929
00:28:16,820 --> 00:28:18,320
0,360 360,600 600,690 690,1080 1080,1500
related to the control center

930
00:28:18,350 --> 00:28:19,400
0,510
{

931
00:28:19,460 --> 00:28:21,860
0,330 330,900 1110,1350 1350,1830 2130,2400
-} here,| {} so talk
|所以，稍微谈谈主机实际维护的状态。

932
00:28:21,860 --> 00:28:22,460
0,30 30,180 180,300 300,510 510,600
a little bit about the

933
00:28:22,460 --> 00:28:23,570
0,360 360,480 480,690 690,780 780,1110
state that actually the master

934
00:28:23,570 --> 00:28:24,980
0,660
maintains.|
|

935
00:28:29,340 --> 00:28:31,650
0,480 510,1140 1560,2040 2040,2250 2250,2310
Okay, {} so first of
好的，首先您知道它有从文件名到主干句柄数组的映射。

936
00:28:31,650 --> 00:28:33,120
0,450 480,600 600,750 750,810 810,1470
all you know it has

937
00:28:33,120 --> 00:28:35,640
0,120 120,600 600,780 780,1650
the mapping from {file,name}

938
00:28:37,610 --> 00:28:40,260
0,900 1020,1230 1230,1620 1620,1860
to an array of

939
00:28:41,170 --> 00:28:44,780
0,180 180,450 450,1140
of trunk handles.|
|

940
00:28:49,040 --> 00:28:49,910
0,180 180,270 270,360 360,600 600,870
And as you saw in
正如你在报纸上看到的，其中一个目标，

941
00:28:49,910 --> 00:28:50,540
0,120 120,330 330,480 480,570 570,630
the paper, one of the

942
00:28:50,540 --> 00:28:52,400
0,300 300,360 360,720 720,1710 1710,1860
goals,| {} actually is to
|实际上是维护所有这些记忆中的大部分信息，实际上是直接在记忆中可用的，

943
00:28:52,400 --> 00:28:54,140
0,780 810,1020 1020,1200 1200,1650 1650,1740
maintain all this memory of

944
00:28:54,140 --> 00:28:55,280
0,210 210,300 300,360 360,810 810,1140
most of the information actually

945
00:28:55,280 --> 00:28:57,350
0,420 420,930 930,1080 1080,1590 1860,2070
directly available in memory,| so
|因此主机可以非常快速地响应客户端

946
00:28:57,350 --> 00:28:59,780
0,240 270,1020 1020,1590 1590,2220 2220,2430
that master response to a

947
00:28:59,780 --> 00:29:01,190
0,330 330,570 570,990 990,1350 1350,1410
client very quickly| and the
|而这么做的原因是因为，

948
00:29:01,190 --> 00:29:01,910
0,210 210,330 330,390 390,660 660,720
reason why {} reason to

949
00:29:01,910 --> 00:29:03,380
0,120 120,420 420,570 570,930 1110,1470
do that is because,| now
|现在只有一个主人，很多客户

950
00:29:03,380 --> 00:29:05,510
0,180 180,420 420,1080 1110,1380 1380,2130
there's one master, many clients|
|

951
00:29:05,600 --> 00:29:06,530
0,150 150,300 300,360 360,720 720,930
you want to execute every
您希望尽可能高效地执行每个客户端操作，

952
00:29:06,530 --> 00:29:08,060
0,270 270,660 660,810 810,1440 1440,1530
client operation as efficient as

953
00:29:08,060 --> 00:29:08,900
0,450 450,540 540,660 660,750 750,840
possible,| so that you can
|这样您就可以将主服务器扩展到至少合理数量的客户端。

954
00:29:08,900 --> 00:29:10,610
0,240 240,330 330,960 1170,1500 1500,1710
scale the master to at

955
00:29:10,610 --> 00:29:11,480
0,180 180,240 240,570 570,810 810,870
least a reasonable number of

956
00:29:11,480 --> 00:29:12,360
0,570
clients.|
|

957
00:29:13,940 --> 00:29:14,870
0,150 150,270 270,420 420,660 660,930
And then, for every trunk
然后，对于每个后备箱手柄，

958
00:29:14,870 --> 00:29:17,780
0,510
handle,|
|

959
00:29:19,120 --> 00:29:20,740
0,180 180,540 540,1140 1140,1260 1260,1620
the mask contains some additional
该掩码包含一些额外的数字，

960
00:29:20,740 --> 00:29:22,420
0,540 570,780 780,960 960,1410 1410,1680
number,| can make particular, it
|可以特别，它维护一个版本号，

961
00:29:22,420 --> 00:29:24,360
0,330 330,420 420,720 720,1170
maintains a version number,|
|

962
00:29:24,630 --> 00:29:26,680
0,510 540,1560
{ -
在垃圾服务器列表中，

963
00:29:27,220 --> 00:29:28,580
0,690
-}

964
00:29:28,640 --> 00:29:32,840
0,690 690,1590 1950,2970 3720,3930 3930,4200
in a list of junk

965
00:29:32,840 --> 00:29:34,180
0,750
servers,|
|

966
00:29:34,970 --> 00:29:36,710
0,240 240,750 810,990 990,1530 1530,1740
that holds a copy of
里面有一大块的复印件。

967
00:29:36,710 --> 00:29:39,280
0,480 510,1290
that chunk.|
|

968
00:29:39,820 --> 00:29:40,570
0,240 240,360 360,480 480,660 660,750
And as we'll see in
正如我们稍后将看到的，

969
00:29:40,570 --> 00:29:41,770
0,30 30,480 480,630 630,780 780,1200
a second,| you know one
|你知道其中一个名字叫，

970
00:29:41,770 --> 00:29:43,450
0,90 90,270 270,450 750,1590 1590,1680
of them is named, {}|
|

971
00:29:43,450 --> 00:29:44,500
0,270 270,360 360,540 540,960 960,1050
one of those servers are
其中一台服务器是主服务器

972
00:29:44,500 --> 00:29:46,660
0,660 1500,1680 1680,1740 1740,1920 1920,2160
primary| and the other ones
|而其他的则是次要的

973
00:29:46,660 --> 00:29:50,770
0,360 360,1110 3600,3750 3750,3810 3810,4110
are secondary| and the typical
|您所知道的存储在3台服务器上的数据块的典型数量

974
00:29:50,770 --> 00:29:52,420
0,480 480,660 660,780 780,1260 1290,1650
number that you know a

975
00:29:52,420 --> 00:29:54,820
0,300 300,630 630,1080 1080,1920 2220,2400
chunk stored at {3,servers}| and
|也许我们可以过一会儿再谈为什么3.

976
00:29:54,820 --> 00:29:55,540
0,180 180,300 300,480 480,690 690,720
we can maybe talk a

977
00:29:55,540 --> 00:29:56,680
0,180 180,270 270,540 540,930 930,1140
little bit later about why

978
00:29:56,680 --> 00:29:57,460
0,330
3.|
|

979
00:29:58,010 --> 00:29:59,390
0,150 150,600 630,750 750,900 900,1380
And then you know there
然后你就知道至少每个初选都有关联，

980
00:29:59,390 --> 00:30:01,640
0,180 180,270 270,690 690,1500 1980,2250
is at least associated with

981
00:30:01,640 --> 00:30:02,720
0,240 240,660 660,810 810,960 960,1080
each primary,| so there's at
|因此，至少还能维持时间。

982
00:30:02,720 --> 00:30:04,310
0,240 240,540 540,1080 1080,1200 1200,1590
least time maintained as well.|
|

983
00:30:06,100 --> 00:30:07,960
0,540 570,840 840,1260 1350,1710 1710,1860
Then there's {} two sort
然后还有另外两种大的存储组件，

984
00:30:07,960 --> 00:30:09,970
0,60 60,330 330,720 930,1440 1440,2010
of other big storage components,|
|

985
00:30:09,970 --> 00:30:10,660
0,150 150,330 330,420 420,570 570,690
and these are sort of
这些都是文件系统级别的东西，

986
00:30:10,660 --> 00:30:12,640
0,180 180,450 930,1320 1320,1620 1620,1980
the {} file system level

987
00:30:12,640 --> 00:30:13,510
0,300 300,390 390,540 540,630 630,870
things,| and then in terms
|然后在实施方面，有一个日志，

988
00:30:13,510 --> 00:30:15,880
0,60 60,900 960,1560 1560,2070 2070,2370
of implementation, there's {} a

989
00:30:15,880 --> 00:30:17,160
0,630
log,|
|

990
00:30:17,370 --> 00:30:21,560
0,180 180,270 270,360 360,1140
and there are checkpoints.|
而且还有检查站。|

991
00:30:23,620 --> 00:30:24,850
0,240 240,390 390,600 600,1110 1110,1230
{Since -} the master of
因为关键的控制中心的主人

992
00:30:24,850 --> 00:30:28,690
0,120 120,1110 2040,2550 2550,3060 3090,3840
the crucial control center| whenever
|每当名称空间发生更改时

993
00:30:28,750 --> 00:30:31,300
0,1200 1200,1920 1920,2220 2220,2310 2310,2550
there's change to the name

994
00:30:31,300 --> 00:30:32,590
0,480 480,630 630,1020 1020,1230 1230,1290
space| and potentially create a
|并可能在GFS中创建新文件

995
00:30:32,590 --> 00:30:35,020
0,240 240,840 840,1320 1320,1590 1620,2430
new file in the GFS|
|

996
00:30:35,260 --> 00:30:37,270
0,870 900,1350 1350,1470 1470,1890 1890,2010
or mapping the file to
或者将文件映射到分块块和改变，

997
00:30:37,270 --> 00:30:39,430
0,270 270,630 630,810 810,1530 1620,2160
chunk blocks and changes {},|
|

998
00:30:39,430 --> 00:30:40,720
0,210 210,360 360,960 960,1050 1050,1290
all those operations are written
所有这些操作都会写入此日志

999
00:30:40,720 --> 00:30:42,040
0,180 180,360 360,780 810,990 990,1320
to this log| and log
|而原木则存放在稳定的储藏室里。

1000
00:30:42,040 --> 00:30:46,120
0,240 240,1020 1050,1740 1740,2310
sits on stable storage.|
|

1001
00:30:47,540 --> 00:30:48,440
0,90

1002
00:30:49,160 --> 00:30:50,900
0,870 870,960 960,1230 1230,1650 1650,1740
And the basic idea is
基本的想法是

1003
00:30:50,900 --> 00:30:53,000
0,300 300,990 1020,1140 1140,1500 1620,2100
that| like we were before
|就像我们在回应客户之前一样，

1004
00:30:53,000 --> 00:30:54,620
0,450 450,540 540,1050 1050,1260 1260,1620
responding to {the,client},| the change
|该改变实际上使主设备首先写入稳定存储器，

1005
00:30:54,620 --> 00:30:56,510
0,240 240,390 390,990 1080,1530 1530,1890
actually has made the master

1006
00:30:56,510 --> 00:30:58,130
0,270 270,390 390,750 750,1140 1140,1620
writes to stable storage first,|
|

1007
00:30:58,620 --> 00:30:59,550
0,150 150,360 360,750 750,840 840,930
and then responds to the
然后对客户端进行响应，

1008
00:30:59,550 --> 00:31:01,230
0,420 570,750 750,930 930,1290 1290,1680
client,| so this means that
|因此，这意味着如果主服务器出现故障或崩溃，

1009
00:31:01,440 --> 00:31:03,000
0,480 480,570 570,1050 1050,1500 1500,1560
if the master fails or

1010
00:31:03,000 --> 00:31:04,950
0,750 990,1230 1230,1500 1500,1680 1680,1950
crashes,| then later comes back
|然后后来又回来了，

1011
00:31:04,950 --> 00:31:06,990
0,330 330,600 600,870 870,1410 1410,2040
up,| it can replace {log,to}
|它可以取代LOG来重建您知道的其内部状态，

1012
00:31:06,990 --> 00:31:08,550
0,870 870,930 930,1050 1050,1170 1170,1560
reconstruct you know the state

1013
00:31:08,550 --> 00:31:10,260
0,240 240,390 390,780 780,1230
of its internal state,|
|

1014
00:31:10,840 --> 00:31:11,920
0,180 180,270 270,660 660,780 780,1080
and by writing it first
并且通过在响应客户端之前首先将其写入存储器，

1015
00:31:11,920 --> 00:31:13,690
0,450 480,840 840,1170 1170,1440 1440,1770
to a storage before responding

1016
00:31:13,690 --> 00:31:14,830
0,90 90,150 150,630 780,870 870,1140
to the client,| the client
|客户永远不会观察到奇怪的结果，

1017
00:31:14,830 --> 00:31:16,360
0,90 90,390 390,720 720,1020 1020,1530
will never observe strange results,|
|

1018
00:31:16,360 --> 00:31:18,280
0,90 90,570 870,1560 1590,1830 1830,1920
you know you could do
你知道你可以用另一种方式纠正错误，

1019
00:31:18,280 --> 00:31:19,330
0,120 120,240 240,390 390,690 690,1050
the other way around corrected,|
|

1020
00:31:19,330 --> 00:31:20,320
0,210 210,510 510,600 600,660 660,990
that result in a problem,|
这导致了一个问题，|

1021
00:31:20,320 --> 00:31:21,370
0,300 300,390 390,510 510,600 600,1050
because you know the client
因为您知道客户端会认为文件已创建，

1022
00:31:21,370 --> 00:31:22,180
0,150 150,360 360,480 480,570 570,810
will think that the file

1023
00:31:22,180 --> 00:31:23,650
0,120 120,240 240,690 690,1050 1050,1470
has been created,| server crash
|服务器崩溃备份，然后文件就不存在了。

1024
00:31:23,680 --> 00:31:24,730
0,570 570,660 660,750 750,840 840,1050
backup and then the file

1025
00:31:24,730 --> 00:31:25,840
0,240 240,720
doesn't exist.|
|

1026
00:31:26,840 --> 00:31:28,100
0,450 450,630 630,810 810,990 990,1260
{} So, these are another
因此，这些是另一个一致性点。

1027
00:31:28,100 --> 00:31:30,680
0,870 1170,1470 1470,1980
consistency {} point.|
|

1028
00:31:31,440 --> 00:31:33,180
0,150 150,690 690,1110 1110,1500 1530,1740
{You,know} replaying always back all
您知道，回放总是从开始的时间到日志的所有操作是

1029
00:31:33,180 --> 00:31:34,170
0,120 120,570 570,660 660,720 720,990
the operations from the beginning

1030
00:31:34,170 --> 00:31:35,070
0,90 90,330 330,450 450,750 750,900
of time to log is|
|

1031
00:31:35,070 --> 00:31:36,720
0,120 120,390 390,1290 1290,1380 1380,1650
of course undesirable it means
当然不受欢迎，这意味着如果主服务器崩溃

1032
00:31:36,720 --> 00:31:38,010
0,150 150,330 330,450 450,810 810,1290
that if the master crashes|
|

1033
00:31:38,010 --> 00:31:38,670
0,90 90,210 210,330 330,510 510,660
and we have only one
我们只有一个会停机很长一段时间，

1034
00:31:38,670 --> 00:31:40,080
0,90 90,660 660,960 960,1110 1110,1410
of them will be down

1035
00:31:40,080 --> 00:31:41,400
0,120 120,150 150,360 360,750 1020,1320
for a long time,| so
|除此之外，你知道它实际上将检查站保存在稳定的存储中，

1036
00:31:41,400 --> 00:31:42,360
0,240 240,330 330,390 390,750 750,960
in addition to that, {you,know}

1037
00:31:42,360 --> 00:31:44,190
0,150 150,420 420,900 1170,1710 1710,1830
it actually keeps checkpoints in

1038
00:31:44,190 --> 00:31:48,600
0,390 390,1020 3060,3360 3360,4140 4140,4410
stable storage,| so periodically, the
|因此，主服务器会定期创建自己状态的检查点

1039
00:31:48,960 --> 00:31:50,400
0,420 420,660 660,900 930,1380 1380,1440
master makes a checkpoint of

1040
00:31:50,400 --> 00:31:51,930
0,540 540,870 870,1290 1290,1470 1470,1530
its own state| and the
|和映射[]数组块句柄

1041
00:31:51,930 --> 00:31:54,900
0,390 390,870 870,1470 1500,2040 2040,2970
mapping [] array chunk handles|
|

1042
00:31:55,320 --> 00:31:57,720
0,360 360,720 720,1020 1020,2010 2010,2400
and stores that on on
并将其存储在稳定的存储上

1043
00:31:57,720 --> 00:31:59,100
0,120 120,390 390,990 1110,1260 1260,1380
the stable storage| and so
|然后他们只需重播最后一段，

1044
00:31:59,100 --> 00:32:00,030
0,240 240,390 390,690 690,810 810,930
then they only have to

1045
00:32:00,030 --> 00:32:02,070
0,630 630,780 780,1140 1140,1470 1500,2040
replay the last part,| basically
|基本上，日志中最后一个检查点之后的所有操作，

1046
00:32:02,070 --> 00:32:03,090
0,240 240,300 300,840 840,930 930,1020
all the operations in the

1047
00:32:03,090 --> 00:32:04,740
0,330 360,750 750,840 840,1140 1140,1650
log after the last checkpoint,|
|

1048
00:32:04,830 --> 00:32:06,000
0,390 390,480 480,870 870,930 930,1170
so the recovery is actually
因此，复苏实际上是很快的。

1049
00:32:06,000 --> 00:32:06,700
0,420
quickly.|
|

1050
00:32:08,220 --> 00:32:09,330
0,150 150,300 300,630 630,840 840,1110
So, there's another couple interesting
所以，还有另外几个有趣的问题，我们可以问自己，

1051
00:32:09,330 --> 00:32:10,170
0,300 300,420 420,480 480,600 600,840
questions, that we can ask

1052
00:32:10,170 --> 00:32:11,910
0,420 420,540 540,900 930,1500 1500,1740
ourselves,| like what state does
|就像什么州需要在一个稳定的仓库里结束一样，

1053
00:32:11,910 --> 00:32:13,320
0,240 240,330 330,540 540,900 930,1410
need to end up in

1054
00:32:13,350 --> 00:32:14,640
0,210 210,510 510,1020 1020,1170 1170,1290
a stable storage,| you know
|你知道，对于[大规模][额外]功能是正确的。

1055
00:32:14,640 --> 00:32:15,870
0,210 210,300 300,660 660,930 930,1230
for the [massive] [extra] function

1056
00:32:15,870 --> 00:32:16,880
0,480
correctly.|
|

1057
00:32:17,140 --> 00:32:18,040
0,210 210,270 270,480 480,780 780,900
So the first question to
所以第一个要问的问题是，

1058
00:32:18,040 --> 00:32:19,360
0,330 330,600 660,780 780,990 990,1320
ask is,| how about this
|下面这组块处理从文件名到块句柄的映射，

1059
00:32:19,360 --> 00:32:21,610
0,510 510,1020 1140,1500 1500,1740 1740,2250
array of {} chunk handles

1060
00:32:21,610 --> 00:32:22,930
0,180 180,540 540,660 660,1140 1140,1320
the mapping from filename to

1061
00:32:22,930 --> 00:32:24,340
0,240 240,840 840,990 990,1230 1230,1410
chunk handles,| does that need
|它需要稳定储存吗，

1062
00:32:24,340 --> 00:32:26,960
0,120 120,600 1020,1530 1530,2160
to be stable stored,|
|

1063
00:32:27,320 --> 00:32:28,340
0,180 180,330 330,450 450,570 570,1020
or can it be only
或者它可能只存在于记忆中。

1064
00:32:28,340 --> 00:32:29,340
0,450
{in,memory}.|
|

1065
00:32:37,770 --> 00:32:40,980
0,570 870,1170 1170,1260 1260,2010 2040,3210
{} If the master crashes,
如果主服务器崩溃，我想你可以从服务器、区块服务器、

1066
00:32:41,130 --> 00:32:42,420
0,330 330,570 570,690 690,900 900,1290
I think you can like

1067
00:32:42,540 --> 00:32:44,070
0,210 210,360 360,990 990,1230 1230,1530
get that information from the

1068
00:32:44,100 --> 00:32:45,460
0,840
servers,

1069
00:32:45,670 --> 00:32:48,200
0,600 600,1350 1380,1980
chunk servers, {}|
|

1070
00:32:48,200 --> 00:32:49,800
0,150 150,450 450,1020
so maybe only,
所以也许只是，也许是记忆。

1071
00:32:49,950 --> 00:32:51,980
0,870 870,1440
may memory.|
|

1072
00:32:52,340 --> 00:32:54,380
0,510 510,1350 1350,1470 1470,1710 1710,2040
Yeah, well that's {answer,the} question,
是的，这就是问题的答案，别人是怎么想的。

1073
00:32:54,380 --> 00:32:55,820
0,210 210,360 360,570 570,870
what other people think.|
|

1074
00:32:56,180 --> 00:32:56,960
0,180 180,330 330,480 480,630 630,780
{} So it can be
所以它可以从日志中重建出来，

1075
00:32:56,960 --> 00:32:58,970
0,780 780,960 960,1050 1050,1380 1410,2010
reconstructed from the log,| so,
|因此，当服务器崩溃时，

1076
00:32:58,970 --> 00:33:00,380
0,210 210,360 360,420 420,750 750,1410
{} when the server crashes,|
|

1077
00:33:00,470 --> 00:33:01,400
0,300 300,390 390,630 630,840 840,930
only the log needs to
只有日志需要存储在硬盘中

1078
00:33:01,400 --> 00:33:03,470
0,270 270,510 510,630 630,1050 1350,2070
be in the hard storage|
|

1079
00:33:03,710 --> 00:33:04,730
0,150 150,330 330,420 420,690 690,1020
and then it can reload
然后它可以将其从日志重新加载到主存中。

1080
00:33:04,730 --> 00:33:05,390
0,90 90,210 210,300 300,540 540,660
it from the log to

1081
00:33:05,390 --> 00:33:06,980
0,150 150,510 810,1080 1080,1260 1260,1590
main memory.| Yeah, so definitely
|是啊，所以肯定是在原木里，

1082
00:33:06,980 --> 00:33:07,430
0,120 120,210 210,300 300,360 360,450
has to be in {}

1083
00:33:07,430 --> 00:33:08,840
0,450 450,630 630,960 960,1260 1260,1410
log,| so we agree that
|所以我们同意，这一组块句柄基本上必须存储在稳定的存储中，

1084
00:33:08,840 --> 00:33:09,830
0,120 120,390 390,480 480,690 690,990
this array of chunk handles

1085
00:33:09,830 --> 00:33:10,850
0,330 330,510 510,570 570,750 750,1020
basically has to be stored

1086
00:33:10,850 --> 00:33:14,440
0,60 60,390 390,1080
in stable storage,|
|

1087
00:33:16,220 --> 00:33:17,690
0,390 390,840 840,930 930,1290 1290,1470
because otherwise we lose like
因为不然的话，我们会输得像创建一个文件一样，

1088
00:33:17,690 --> 00:33:18,800
0,120 120,240 240,450 450,480 480,1110
we {} create a file,|
|

1089
00:33:18,830 --> 00:33:19,970
0,270 270,360 360,540 540,810 810,1140
and we didn't write the
而且我们也没有写存储，

1090
00:33:19,970 --> 00:33:20,750
0,240 240,360 360,540 540,720 720,780
storage,| we just lose the
|我们只是把文件弄丢了

1091
00:33:20,750 --> 00:33:22,160
0,390 420,780 780,900 900,1050 1050,1410
file right,| so this mapping
|因此，从文件名块句柄的这种映射需要在稳定的存储中，

1092
00:33:22,160 --> 00:33:23,810
0,90 90,360 360,780 930,1320 1320,1650
from file name chunk handles

1093
00:33:23,810 --> 00:33:25,160
0,150 150,270 270,540 540,930 1200,1350
need to be in a

1094
00:33:25,160 --> 00:33:26,330
0,270 270,600 600,720 720,900 900,1170
stable storage,| how about this,
|这样如何，从块句柄到块句柄到我们服务器的块列表。

1095
00:33:26,330 --> 00:33:28,430
0,360 390,690 690,990 990,1470 1770,2100
{} chunk handle to chunk

1096
00:33:28,430 --> 00:33:29,420
0,270 270,390 390,630 630,720 720,990
handle to list of chunk

1097
00:33:29,420 --> 00:33:30,720
0,120 120,240 240,870
for our servers.|
|

1098
00:33:32,220 --> 00:33:33,180
0,120 120,360 360,720 720,780 780,960
Is that actually you need
是不是你真的需要[]。

1099
00:33:33,180 --> 00:33:34,520
0,60 60,270 270,750
to be [].|
|

1100
00:33:35,580 --> 00:33:36,660
0,120 120,390 390,480 480,570 570,1080
I think in the paper,
我想在报纸上，他们说当主服务器重新启动时，

1101
00:33:36,660 --> 00:33:38,700
0,150 150,420 420,870 990,1530 1530,2040
they say that when the

1102
00:33:39,030 --> 00:33:42,150
0,480 480,1200 1200,2070 2310,2520 2520,3120
{} master reboots,| it asks
|它要求服务器告诉主服务器他们拥有的中继线是什么。

1103
00:33:42,150 --> 00:33:45,120
0,120 120,1290 1290,1590 1590,2130 2310,2970
the servers to tell tell

1104
00:33:45,120 --> 00:33:46,920
0,90 90,660 660,1020 1020,1080 1080,1800
the master what the trunks

1105
00:33:47,190 --> 00:33:49,260
0,420 450,600 600,930 930,1380 1620,2070
that they have are.| Yeah,
|是的，所以这不是实际上，这基本上只是挥发状态，而不是稳定的存储。

1106
00:33:49,530 --> 00:33:50,520
0,90 90,270 270,390 390,720 720,990
so this is not actually

1107
00:33:50,520 --> 00:33:51,990
0,210 210,360 360,780 780,930 930,1470
this is basically just volatile

1108
00:33:51,990 --> 00:33:53,300
0,510
state,

1109
00:33:53,860 --> 00:33:56,080
0,660 660,870 870,1140 1140,1740
not not stable storage.|
|

1110
00:33:56,080 --> 00:33:57,550
0,270 270,690 690,900 900,1110 1110,1470
So same says only through
同样的道理，只有通过初选和初选，

1111
00:33:57,550 --> 00:33:59,380
0,180 180,660 660,840 840,960 960,1830
the primaries and the secondaries,|
|

1112
00:33:59,880 --> 00:34:01,770
0,540 540,870 870,1110 1110,1380 1380,1890
and through the least time.|
用最少的时间。|

1113
00:34:02,630 --> 00:34:03,710
0,120 120,300 300,360 360,660 660,1080
How about the version number?|
版本号是多少？|

1114
00:34:10,740 --> 00:34:12,660
0,360 360,750 1080,1650 1650,1830 1830,1920
Does the master need to
主控是否需要记住稳定存储上的版本号？

1115
00:34:12,660 --> 00:34:14,250
0,450 450,540 540,870 870,1260 1260,1590
remember on stable storage version

1116
00:34:14,250 --> 00:34:15,460
0,240 240,300 300,660
number or not?|
|

1117
00:34:16,410 --> 00:34:17,940
0,570 570,1140 1140,1260 1260,1440 1440,1530
Yes, because it needs to
是的，因为它需要知道其他服务器中的中继线是否可扩展。

1118
00:34:17,940 --> 00:34:20,550
0,270 270,870 1200,2040 2040,2220 2220,2610
know if {} the trunks

1119
00:34:20,550 --> 00:34:22,350
0,180 180,690 990,1320 1320,1680 1680,1800
in the other servers are

1120
00:34:22,350 --> 00:34:23,780
0,300 300,360 360,840
scale or not.|
|

1121
00:34:23,780 --> 00:34:26,030
0,420 420,930 1080,1830 1830,2130 2130,2250
Yeah, exactly exactly right, right,|
是的，完全正确，对，|

1122
00:34:26,030 --> 00:34:27,260
0,120 120,210 210,540 540,840 840,1230
so the master must remember
所以母版必须记住版本号，

1123
00:34:27,260 --> 00:34:28,880
0,270 270,630 630,1080
version number,| because
|因为如果它不能

1124
00:34:28,880 --> 00:34:32,000
0,570 870,1230 1230,2160 2160,2700 2700,3120
{} if it doesn't| and
|整个系统都崩溃了

1125
00:34:32,000 --> 00:34:33,350
0,210 210,450 450,750 750,900 900,1350
the whole system went down|
|

1126
00:34:33,770 --> 00:34:34,820
0,270 270,330 330,540 540,840 840,1050
and the [] servers came
然后[]服务器又恢复了

1127
00:34:34,820 --> 00:34:36,800
0,240 240,630 930,1530 1530,1890 1890,1980
back up| and maybe the
|可能实际上包含最新数据的区块服务器没有出现

1128
00:34:36,800 --> 00:34:38,030
0,480 480,750 750,900 900,990 990,1230
{chunk,server} actually with the most

1129
00:34:38,030 --> 00:34:39,320
0,300 300,600 600,840 840,1140 1140,1290
recent data does not come

1130
00:34:39,320 --> 00:34:40,370
0,270 270,480 480,570 570,840 840,1050
up| with an older guy
|一个年纪较大的人拿出了版本14，

1131
00:34:40,370 --> 00:34:41,480
0,240 240,390 390,510 510,930 930,1110
comes up with version number

1132
00:34:41,480 --> 00:34:43,520
0,750 1140,1470 1470,1650 1650,1710 1710,2040
fourteen,| {} then the master
|然后，主服务器必须能够告诉您，您知道14的块服务器版本不是最新的块服务器。

1133
00:34:43,520 --> 00:34:44,120
0,150 150,240 240,330 330,480 480,600
has to be able to

1134
00:34:44,120 --> 00:34:45,410
0,360 360,660 660,780 780,960 960,1290
tell that you know that

1135
00:34:45,410 --> 00:34:47,090
0,660 660,990 990,1140 1140,1560 1560,1680
{chunk,server} version of fourteen was

1136
00:34:47,090 --> 00:34:49,130
0,300 300,360 360,630 630,1200 1470,2040
not the most recent {}

1137
00:34:49,130 --> 00:34:50,240
0,660
{chunk,server}.|
|

1138
00:34:50,620 --> 00:34:51,460
0,210 210,330 330,540 540,750 750,840
And so it needs to
因此，它需要在磁盘上维护该版本号，

1139
00:34:51,460 --> 00:34:53,410
0,720 750,1080 1080,1380 1380,1650 1650,1950
maintain that version number on

1140
00:34:53,410 --> 00:34:54,400
0,300 300,450 450,630 630,870 870,990
disk,| so that actually can
|因此，这实际上可以区分哪些区块服务器实际上拥有关于哪些没有的最新信息。

1141
00:34:54,400 --> 00:34:56,170
0,630 660,960 960,1290 1290,1470 1470,1770
tell which chunk servers actually

1142
00:34:56,170 --> 00:34:58,060
0,540 540,690 690,990 990,1440 1440,1890
have the most updated information

1143
00:34:58,060 --> 00:34:59,460
0,60 60,240 240,450 450,900
on which ones don't.|
|

1144
00:35:00,010 --> 00:35:01,020
0,540
Okay?|
好吧?|

1145
00:35:01,020 --> 00:35:02,040
0,90 90,300 300,450 450,540 540,1020
A I have a question
A我有一个问题，

1146
00:35:02,040 --> 00:35:05,100
0,390 1560,2130 2430,2730 2730,2850 2850,3060
here,| if, well, I mean
|如果，嗯，我是说，如果主人失败了

1147
00:35:05,100 --> 00:35:07,740
0,330 360,540 540,660 660,1500 1980,2640
if if the master failed|
|

1148
00:35:07,740 --> 00:35:08,550
0,180 180,390 390,510 510,690 690,810
and then it has to
然后它就会出现，

1149
00:35:08,550 --> 00:35:10,680
0,210 210,570 780,1290 1380,1800 1800,2130
come up,| it's anyway going
|无论如何，它都会连接到所有区块服务器

1150
00:35:10,680 --> 00:35:11,670
0,180 180,630 630,750 750,870 870,990
to connect to all of

1151
00:35:11,670 --> 00:35:13,780
0,120 120,390 390,870 870,1470
the chunk servers| and
|它会找出最大的版本是什么。

1152
00:35:13,780 --> 00:35:15,730
0,360 360,930 930,1410 1410,1680 1680,1950
it will find out what

1153
00:35:15,730 --> 00:35:18,220
0,270 300,810 810,1320 1320,1830
the largest version is.|
|

1154
00:35:18,220 --> 00:35:20,800
0,450 1020,1560 1980,2220 2220,2520 2520,2580
Yeah {}, has ability to
是的，有能力找出最后一件事，

1155
00:35:20,800 --> 00:35:21,760
0,240 240,360 360,480 480,540 540,960
find out what the last,|
|

1156
00:35:21,760 --> 00:35:24,040
0,1140 1170,1410 1410,1470 1470,1770 2070,2280
{} first of all, it
首先，它将尝试与所有区块服务器进行对话，

1157
00:35:24,040 --> 00:35:24,940
0,150 150,420 420,570 570,810 810,900
will try to talk to

1158
00:35:24,940 --> 00:35:26,560
0,150 150,390 390,900 1170,1380 1380,1620
all chunk servers,| some chunk
|某些区块服务器可能已关闭。

1159
00:35:26,560 --> 00:35:27,980
0,300 300,450 450,540 540,900
servers might be down.|
|

1160
00:35:28,040 --> 00:35:30,800
0,630 1080,1650 1650,2100 2100,2400 2400,2760
Okay.| And that's that maybe
好吧。|这可能只是实际拥有最新版本的块服务器。

1161
00:35:30,800 --> 00:35:32,240
0,330 330,420 420,870 870,990 990,1440
just the {chunk,server} that actually

1162
00:35:32,240 --> 00:35:33,440
0,180 180,240 240,480 480,810 810,1200
has the most recent version

1163
00:35:33,530 --> 00:35:35,870
0,360 690,990 990,1380 1860,2190 2190,2340
right.| Yeah, okay.| So you
|好的，好的。|因此，您不能使用最大的寿命块服务器，

1164
00:35:35,870 --> 00:35:36,950
0,240 240,420 420,480 480,870 870,1080
can't take the max of

1165
00:35:36,950 --> 00:35:39,480
0,270 270,870 900,1410 1410,2040
the life chunk servers,|
|

1166
00:35:39,480 --> 00:35:41,780
0,420 420,960 960,1200 1200,1770
{} that be incorrect.|
这是不正确的。|

1167
00:35:46,110 --> 00:35:47,400
0,300 300,450 450,750 750,930 930,1290
Any other questions about this?|
对此还有其他问题吗？|

1168
00:35:51,820 --> 00:35:52,690
0,330 330,540 540,690 690,780 780,870
Okay, let's look at the
好的，让我们来看看这两种基本运算，

1169
00:35:52,690 --> 00:35:54,490
0,480 480,630 630,690 690,960 960,1800
two sort of basic operations,|
|

1170
00:35:55,120 --> 00:35:56,350
0,390 390,570 570,780 780,930 930,1230
{} to really get down
真正做到始终如一

1171
00:35:56,350 --> 00:35:58,120
0,240 240,930 930,1170 1290,1410 1410,1770
to consistency| and of course
|当然，你知道这将是阅读和写作，

1172
00:35:58,120 --> 00:35:58,720
0,150 150,300 300,420 420,540 540,600
you know it's going to

1173
00:35:58,720 --> 00:36:00,250
0,120 120,390 390,540 540,990 1230,1530
be reading and writing,| {so,reading}
|所以读一份文件，

1174
00:36:00,250 --> 00:36:01,900
0,120 120,690 1260,1470 1470,1560 1560,1650
a file,| and then we'll
|然后我们将讨论如何编写文件，

1175
00:36:01,900 --> 00:36:02,950
0,180 180,390 390,600 600,690 690,1050
talk about writing a file,|
|

1176
00:36:04,060 --> 00:36:05,830
0,480 660,990 990,1440 1440,1590 1590,1770
so reading files in some
因此，从某种意义上说，阅读文件很简单，

1177
00:36:05,830 --> 00:36:07,660
0,270 270,960 990,1290 1290,1500 1500,1830
sense straightforward,| we talked about
|我们谈到的基本上是客户端向主服务器发送带有文件名和偏移量的消息，

1178
00:36:07,660 --> 00:36:09,520
0,390 390,810 810,1170 1170,1680 1680,1860
basically {a,client} send message {you,know}

1179
00:36:09,520 --> 00:36:10,680
0,420
to

1180
00:36:10,800 --> 00:36:12,480
0,540 540,750 750,840 840,1470 1470,1680
{} with the filename plus

1181
00:36:12,480 --> 00:36:16,890
0,690 1770,1980 1980,2670 3840,4110 4110,4410
offset {to,the} master,| and basically
|基本上，我会问，请给我区块服务器

1182
00:36:16,890 --> 00:36:18,930
0,510 510,780 780,960 960,1260 1260,2040
ask please give me {you,know}

1183
00:36:19,660 --> 00:36:21,730
0,330 330,990 1080,1560 1560,1830 1830,2070
chunk servers| {} and chunk
|以及保存在该偏移量处的数据的区块句柄，

1184
00:36:21,730 --> 00:36:25,600
0,600 900,1530 1560,2310 2820,3270 3300,3870
handle that { -} hold

1185
00:36:25,630 --> 00:36:28,420
0,420 510,1230 1410,1710 1710,2340 2640,2790
that {} {hold,the} data at

1186
00:36:28,420 --> 00:36:29,580
0,180 180,690
that offset,|
|

1187
00:36:29,850 --> 00:36:31,440
0,240 240,510 510,1050 1050,1350 1350,1590
and so ends the chunk
块句柄就这样结束了。

1188
00:36:31,440 --> 00:36:32,560
0,570
handle.|
|

1189
00:36:32,730 --> 00:36:35,250
0,420 420,720 720,1350 1350,1980 1980,2520
So like read byte whatever
所以就像读取字节，不管是零

1190
00:36:35,310 --> 00:36:36,750
0,360 360,960 990,1110 1110,1320 1320,1440
{} zero| you know it's
|你知道，很明显，这必须是名单上的第一个条目，

1191
00:36:36,750 --> 00:36:37,770
0,210 210,630 630,750 750,930 930,1020
pretty clear that has to

1192
00:36:37,770 --> 00:36:39,460
0,150 150,390 510,1200
be the first

1193
00:36:39,460 --> 00:36:42,010
0,450 480,1080 1080,1380 1380,1860 1950,2550
{} entry in the list,|
|

1194
00:36:42,010 --> 00:36:43,420
0,60 60,210 210,450 450,1050 1050,1410
you know from filename to
你知道从文件名到主干句柄。

1195
00:36:43,450 --> 00:36:44,700
0,660
{}

1196
00:36:44,700 --> 00:36:45,940
0,240 240,690
trunk handle.|
|

1197
00:36:46,130 --> 00:36:47,900
0,420 420,960 960,1050 1050,1560 1560,1770
So [], the master chunk
所以[]，主数据块句柄基本上与主数据块一起回复，

1198
00:36:47,900 --> 00:36:49,970
0,480 510,1020 1020,1830 1830,1920 1920,2070
handle basically replies you know

1199
00:36:49,970 --> 00:36:51,160
0,210 210,600
with the

1200
00:36:51,520 --> 00:36:54,250
0,840 870,1350 1350,1530 1530,2100 2100,2730
master,| replies to {the,client} with
|用块句柄回复客户端，

1201
00:36:54,250 --> 00:36:57,200
0,180 180,480 480,690 690,1020
the chunk {handle -},|
|

1202
00:36:57,440 --> 00:37:03,200
0,570 570,780 1200,1680 1680,2370 3990,5760
and the chunk servers for
以及该句柄和版本号的块服务器。

1203
00:37:03,650 --> 00:37:05,060
0,330 330,900
that handle

1204
00:37:05,060 --> 00:37:08,060
0,720 720,1020
and {version,numbers}.|
|

1205
00:37:09,000 --> 00:37:10,950
0,150 150,600 600,1050 1440,1800 1800,1950
So basically the client gets
所以基本上客户会收到一条消息，说你知道这是块你知道的221

1206
00:37:10,950 --> 00:37:12,030
0,330 330,360 360,720 720,990 990,1080
back a message saying you

1207
00:37:12,030 --> 00:37:13,020
0,180 180,420 420,780 780,870 870,990
know that's chunk you know

1208
00:37:13,170 --> 00:37:15,630
0,210 210,450 450,900 1230,1740 1740,2460
{221 - -}| {you,know} and
|你知道，这是三台机器，

1209
00:37:15,630 --> 00:37:16,860
0,330 330,630 630,810 810,1020 1020,1230
{} here are the three

1210
00:37:16,860 --> 00:37:18,420
0,480 480,960 960,1320 1320,1410 1410,1560
machines,| IP address, the three
|IP地址，即实际拥有该地址的三台计算机。

1211
00:37:18,420 --> 00:37:19,560
0,360 360,480 480,720 720,960 960,1140
machines that actually have it.|
|

1212
00:37:20,140 --> 00:37:21,820
0,300 300,810 810,900 900,1200 1200,1680
{} And the version number
版本号类似于版本10。

1213
00:37:21,820 --> 00:37:22,960
0,300 300,420 420,690 690,840 840,1140
is like version of 10.|
|

1214
00:37:25,110 --> 00:37:26,400
0,690

1215
00:37:26,400 --> 00:37:27,660
0,300 300,390 390,690 690,1080 1080,1260
Then the client caches this
然后，客户端缓存该列表。

1216
00:37:27,660 --> 00:37:28,760
0,540
list.|
|

1217
00:37:33,120 --> 00:37:34,160
0,300

1218
00:37:34,820 --> 00:37:36,680
0,600 600,810 810,990 990,1440 1440,1860
And then it basically sends
然后它基本上会向最近的服务器发送一条消息，从最近的服务器读取。

1219
00:37:36,680 --> 00:37:38,240
0,120 120,480 480,630 630,720 720,1560
a message to the closest,

1220
00:37:40,140 --> 00:37:44,520
0,360 360,600 600,1470
reads from closest

1221
00:37:45,450 --> 00:37:47,620
0,840
server.|
|

1222
00:37:51,380 --> 00:37:52,850
0,390 390,510 510,660 660,1170 1170,1470
{} and so why this
那么为什么客户端实际上会读取缓存，这些信息。

1223
00:37:52,850 --> 00:37:55,040
0,420 420,750 750,1380 1380,1980 2010,2190
{the,client} actually read cache, this

1224
00:37:55,040 --> 00:37:56,260
0,660
information.|
|

1225
00:37:58,100 --> 00:37:59,240
0,300 300,390 390,510 510,780 780,1140
Yes, we see later, correct,
是的，我们后来看到了，对，那造成了一些麻烦。

1226
00:37:59,240 --> 00:38:01,080
0,240 240,600 600,720 720,1350
that caused some troubles.|
|

1227
00:38:01,400 --> 00:38:02,390
0,240 240,360 360,720 720,840 840,990
So it doesn't have to
所以它在一段时间内不需要联系主人，

1228
00:38:02,390 --> 00:38:03,920
0,480 480,540 540,1020 1020,1200 1200,1530
contact the master for some

1229
00:38:03,920 --> 00:38:05,600
0,420 420,630 630,750 750,1140 1140,1680
time,| if it wants to
|如果它想要再次阅读或写入。

1230
00:38:05,810 --> 00:38:07,580
0,390 390,930 930,1080 1080,1470 1470,1770
read again or write to.|
|

1231
00:38:08,780 --> 00:38:10,740
0,660 660,1350
{Yeah,why,is,that} important?|
是啊，这有什么重要的？|

1232
00:38:11,610 --> 00:38:14,100
0,660 900,1800 1800,2100 2100,2310 2310,2490
To reduce the, I guess
为了减少，我想交通，

1233
00:38:14,100 --> 00:38:16,860
0,90 90,1170 1350,1860 1860,2040 2550,2760
the traffic,| {} and in
|一般来说，如果你与师父的交流较少，所需的时间就会更短。

1234
00:38:16,860 --> 00:38:18,240
0,420 420,570 570,870 870,1110 1110,1380
general it takes less time

1235
00:38:18,240 --> 00:38:19,740
0,180 180,300 300,540 540,750 750,1500
if you have less communication

1236
00:38:19,740 --> 00:38:21,150
0,150 150,240 240,720 870,1080 1080,1410
with the master.| Yeah, and
|是啊，你知道的越多，

1237
00:38:21,150 --> 00:38:22,020
0,90 90,240 240,360 360,660 750,870
you know the more,| you
|你也这样做，这是正确的，

1238
00:38:22,020 --> 00:38:23,190
0,180 180,420 510,870 870,960 960,1170
do the same with that's

1239
00:38:23,190 --> 00:38:24,390
0,450 450,630 630,990 990,1080 1080,1200
correct,| this design is that
|这种设计是主机实际上是一台机器，

1240
00:38:24,390 --> 00:38:25,620
0,60 60,540 540,810 810,960 960,1230
the master actually a single

1241
00:38:25,620 --> 00:38:26,580
0,420
machine,|
|

1242
00:38:26,980 --> 00:38:28,180
0,510 540,750 750,960 960,1050 1050,1200
and as {a,single} machine you
作为一台机器，您可以只拥有有限的内存和有限的网络接口

1243
00:38:28,180 --> 00:38:29,320
0,210 210,540 540,690 690,870 870,1140
can just have a limited

1244
00:38:29,320 --> 00:38:30,760
0,180 180,240 240,720 720,1050 1050,1440
amount of memory and limit

1245
00:38:30,760 --> 00:38:32,350
0,150 150,510 510,990 990,1140 1140,1590
{} network interface| and so
|所以你有太多的客户在和你交谈，

1246
00:38:32,620 --> 00:38:33,730
0,360 360,450 450,570 570,810 810,1110
you have too many clients

1247
00:38:33,730 --> 00:38:34,960
0,300 300,420 420,870 870,1140 1140,1230
talking to,| it wouldn't be
|它就不能服务了，对吧，

1248
00:38:34,960 --> 00:38:36,700
0,180 180,240 240,780 900,1380 1380,1740
able to serve, right,| so
|因此，客户端缓存对于减少这台机器上的负载很重要。

1249
00:38:36,760 --> 00:38:38,170
0,450 450,780 780,870 870,1290 1290,1410
client caching is important to

1250
00:38:38,170 --> 00:38:39,280
0,330 330,390 390,750 750,960 960,1110
reduce the load on this

1251
00:38:39,280 --> 00:38:40,440
0,270 270,690
single machine.|
|

1252
00:38:41,730 --> 00:38:42,810
0,240 240,330 330,660 660,870 870,1080
Okay, why read from the
好吧，为什么要从最近的服务器上阅读呢？

1253
00:38:42,810 --> 00:38:44,980
0,630 660,1200
closest server?|
|

1254
00:38:46,860 --> 00:38:49,260
0,450 450,870 870,1440 1800,2070 2070,2400
Minimize network traffic.| Yeah, minimize
最大限度地减少网络流量。|是的，最大限度地减少网络流量，

1255
00:38:49,260 --> 00:38:50,340
0,240 240,660 660,720 720,870 870,1080
network traffic,| you know, so
|你知道，所以整个目标是正确的

1256
00:38:50,340 --> 00:38:51,420
0,270 270,480 480,720 720,780 780,1080
the whole goal {correct -}

1257
00:38:51,420 --> 00:38:53,010
0,90 90,570 990,1260 1260,1410 1410,1590
is| to pump as much
|为了将尽可能多的数据传输到客户端、最高的吞吐量、

1258
00:38:53,010 --> 00:38:54,720
0,630 690,1110 1110,1200 1200,1650 1650,1710
data {to,client} as possible, the

1259
00:38:54,720 --> 00:38:57,150
0,270 270,780 1170,1770 1770,2370 2370,2430
highest throughput,| {} and you
|你知道你必须这样做，我们必须解决数据中心网络的两个问题，

1260
00:38:57,150 --> 00:38:58,110
0,210 210,360 360,510 510,660 660,960
know you have to, {there's}

1261
00:38:58,260 --> 00:38:59,340
0,150 150,390 390,810 810,960 960,1080
{two -} problems we had

1262
00:38:59,340 --> 00:39:00,870
0,60 60,480 480,1020 1050,1320 1320,1530
to cross with data center

1263
00:39:00,870 --> 00:39:02,820
0,450 450,870 1140,1350 1350,1680 1680,1950
network,| one {you,know} where there's
|一个你知道的地方可能有一些拓扑

1264
00:39:02,820 --> 00:39:05,040
0,540 570,810 810,1500 1500,1650 1650,2220
probably some topology| and {maybe
|也许沼泽就像拓扑学的顶层链接，

1265
00:39:05,040 --> 00:39:06,330
0,210 210,690 690,870 870,930 930,1290
-} swamps like the top

1266
00:39:06,330 --> 00:39:07,920
0,270 270,360 360,1200
links of topology,|
|

1267
00:39:07,980 --> 00:39:10,170
0,570 570,990 990,1230 1230,1680 1680,2190
{} and may actually increase
实际上可能会增加到达另一边的延迟。

1268
00:39:10,170 --> 00:39:11,880
0,600 660,960 960,1230 1230,1440 1440,1710
latency to actually get to

1269
00:39:11,880 --> 00:39:13,400
0,390 390,570 570,990
the other side.|
|

1270
00:39:13,520 --> 00:39:14,480
0,360 360,450 450,780 780,870 870,960
Actually, it's important to be
事实上，重要的是能够离最近的一边

1271
00:39:14,480 --> 00:39:15,200
0,180 180,270 270,420 420,630 630,720
able to be to the

1272
00:39:15,200 --> 00:39:16,640
0,300 300,600 600,870 870,1050 1050,1440
closest side| again to basically
|同样，为了最大限度地提高吞吐量，您知道联合的一组客户端，

1273
00:39:16,640 --> 00:39:18,620
0,690 690,780 780,900 900,1260 1740,1980
maximize you know the {throughput

1274
00:39:18,620 --> 00:39:20,000
0,360 360,450 450,570 570,1050 1050,1380
-} you know that joint

1275
00:39:20,000 --> 00:39:21,200
0,180 180,300 300,840 840,1050 1050,1200
set of clients,| you can
|当他们从许多块服务器并行读取时，您可以体验到某种程度上的体验。

1276
00:39:21,200 --> 00:39:22,340
0,180 180,240 240,810 810,960 960,1140
sort of experience when they're

1277
00:39:22,340 --> 00:39:24,230
0,270 270,360 360,840 840,1440 1530,1890
reading in parallel from many

1278
00:39:24,230 --> 00:39:25,660
0,240 240,450 450,990
many chunk servers.|
|

1279
00:39:26,420 --> 00:39:27,500
0,210 210,570
{Okay -}?|
好吧?|

1280
00:39:28,110 --> 00:39:30,300
0,180 180,270 270,720 720,1170 1380,2190
So the {chunk,server -} S
所以你知道的区块服务器S最好检查一下版本号。

1281
00:39:30,840 --> 00:39:32,640
0,180 180,570 570,840 840,1230 1230,1800
{you,know} better check {the,version} number.|
|

1282
00:39:35,570 --> 00:39:37,190
0,360 360,450 450,690 690,990 990,1620
And {if,the} version {number,is} okay,|
如果版本号是正确的，|

1283
00:39:37,280 --> 00:39:38,570
0,240 240,450 450,660 660,900 900,1290
you know then send data.|
你知道，然后发送数据。|

1284
00:39:42,570 --> 00:39:43,740
0,240 240,600
{Okay -}?|
好吧?|

1285
00:39:44,510 --> 00:39:45,650
0,360 360,510 510,810 810,900 900,1140
Why is check the version
为什么在那里检查版本号？

1286
00:39:45,650 --> 00:39:46,780
0,180 180,540
number there?|
|

1287
00:39:50,580 --> 00:39:51,810
0,150 150,510 510,810 810,1080 1080,1230
To check if it's too
看看是不是太陈旧了。

1288
00:39:51,810 --> 00:39:54,720
0,720 960,2370
stale.| Yeah,
|是的，我们尽最大努力避免阅读过时的数据，

1289
00:39:54,920 --> 00:39:56,090
0,210 210,360 360,630 660,1080 1080,1170
we do our best to

1290
00:39:56,090 --> 00:39:59,510
0,300 300,510 510,780 780,1920 2730,3420
avoid reading stale data,| {and,you,know,as,we'll}
|你们知道，我们马上就会看到，

1291
00:39:59,510 --> 00:40:01,250
0,210 210,630 630,870 870,960 960,1740
seen {in,a,second},| we do you
|如果你在[]方面做得不够完美，

1292
00:40:01,250 --> 00:40:02,390
0,360 360,510 510,570 570,840 840,1140
don't do a perfect job

1293
00:40:02,390 --> 00:40:03,770
0,150 150,540 540,720 720,960 960,1380
at [],| but try hard
|但要尽量减少客户端读取过时数据的情况。

1294
00:40:03,800 --> 00:40:06,020
0,270 270,990 990,1110 1110,1710
to minimize you know

1295
00:40:06,280 --> 00:40:08,350
0,690 690,870 870,1560 1560,1860 1860,2070
occurrences with the clients reading

1296
00:40:08,350 --> 00:40:09,500
0,240 240,570
stale data.|
|

1297
00:40:09,500 --> 00:40:10,600
0,540
Okay?|
好吧?|

1298
00:40:11,470 --> 00:40:13,780
0,330 330,870 1020,1620 1620,1890 1890,2310
Those reading reasonable {straightforward -}.|
那些阅读合理的直截了当。|

1299
00:40:15,450 --> 00:40:16,410
0,270 270,450 450,600 600,750 750,960
So let's look at the
那么，让我们来看看这些文字。

1300
00:40:16,410 --> 00:40:17,480
0,510
writing.|
|

1301
00:40:20,690 --> 00:40:21,950
0,240 240,450 450,600 600,930 960,1260
So this is a picture
这是报纸上的一张照片。

1302
00:40:21,950 --> 00:40:23,440
0,210 210,420 420,960
from the paper.|
|

1303
00:40:23,590 --> 00:40:24,880
0,750

1304
00:40:24,880 --> 00:40:25,840
0,270 270,420 420,600 600,900 900,960
And so let's say {}
所以我们假设客户是，

1305
00:40:25,840 --> 00:40:27,520
0,300 300,510 510,1020 1020,1290 1290,1680
client was the,| let's focus
|让我们来关注一下追加。

1306
00:40:27,520 --> 00:40:29,000
0,420 420,930
{append -}.|
|

1307
00:40:31,650 --> 00:40:32,840
0,120

1308
00:40:40,440 --> 00:40:42,300
0,540 540,690 690,840 840,1350 1350,1860
{} And so they argued
因此，他们认为，对他们来说，非常常见的操作需要将记录附加到文件中

1309
00:40:42,300 --> 00:40:43,440
0,90 90,180 180,420 420,690 690,1140
that the very common operation

1310
00:40:43,440 --> 00:40:44,430
0,90 90,270 270,540 540,660 660,990
for them needs to {append

1311
00:40:44,430 --> 00:40:45,090
0,60 60,120 120,420 420,570 570,660
-} a record to a

1312
00:40:45,090 --> 00:40:48,180
0,420 630,1350 2550,2790 2790,2880 2880,3090
file| and can we see
|我们能知道为什么，鉴于你们从MapReduce中了解到的情况，

1313
00:40:48,180 --> 00:40:49,680
0,450 480,1110 1110,1230 1230,1320 1320,1500
why, given what you guys

1314
00:40:49,680 --> 00:40:52,560
0,270 270,1230 1710,2010 2010,2790 2790,2880
{you,know} from {mapreduce -},| you
|你知道谷歌是有道理的，为什么追加是如此重要。

1315
00:40:52,560 --> 00:40:54,030
0,270 300,960 960,1170 1170,1320 1320,1470
know Google {} does {}

1316
00:40:54,030 --> 00:40:55,230
0,150 150,510 510,810 810,1110 1110,1200
make sense, why append is

1317
00:40:55,230 --> 00:40:56,440
0,180 180,780
so important.|
|

1318
00:41:01,830 --> 00:41:03,510
0,570 570,1020 1020,1350 1350,1440 1440,1680
{} Because largely in doing
因为在很大程度上，在进行MapReduce时，您需要

1319
00:41:03,510 --> 00:41:06,030
0,210 210,870 1110,1650 2010,2250 2250,2520
{mapreduce -}, {} you need

1320
00:41:06,030 --> 00:41:08,850
0,630 780,1230 1230,1620 1620,2070 2100,2820
to,| {} as the map
|当MAP函数发出信息时，

1321
00:41:08,880 --> 00:41:11,250
0,720 720,1050 1050,1500 1500,2190 2190,2370
function spits out information,| it's
|它在很大程度上只是增加信息，而不是改变以前的[吐][出]信息。

1322
00:41:11,250 --> 00:41:13,350
0,330 330,720 960,1380 1380,1500 1500,2100
largely just adding on information

1323
00:41:13,350 --> 00:41:15,090
0,270 270,480 480,900 900,1500 1500,1740
rather than changing previously [spit]

1324
00:41:15,090 --> 00:41:16,950
0,180 180,870 930,1380 1380,1560 1560,1860
[out] informations.| Yeah, you know
|是的，你知道也许地图不是最好的例子，

1325
00:41:16,980 --> 00:41:17,730
0,270 270,330 330,540 540,630 630,750
maybe the map is not

1326
00:41:17,730 --> 00:41:19,140
0,60 60,270 270,630 630,1140 1140,1410
the best example,| because write
|因为写入本地文件而不是GFS，

1327
00:41:19,140 --> 00:41:20,310
0,150 150,210 210,480 480,900 900,1170
to the local files not

1328
00:41:20,310 --> 00:41:21,510
0,90 90,630 630,750 750,810 810,1200
to GFS,| but the reducer
|但是简约器是这样做的，同样的论点也是简约器。

1329
00:41:21,510 --> 00:41:24,060
0,480 780,1290 1440,1770 1770,2190 2190,2550
does, the same argument also

1330
00:41:24,060 --> 00:41:25,040
0,570
reducer.|
|

1331
00:41:25,630 --> 00:41:26,710
0,210 210,360 360,480 480,600 600,1080
Yeah, so they're going to
是的，所以他们将在那里工作，写作基本上消耗了大量的信息

1332
00:41:26,830 --> 00:41:28,690
0,300 300,480 480,960 960,1290 1290,1860
work there at writings basically

1333
00:41:28,750 --> 00:41:30,280
0,420 420,480 480,630 630,720 720,1530
consume a lot of information|
|

1334
00:41:30,430 --> 00:41:31,810
0,570 570,660 660,780 780,1080 1080,1380
and you know append record
你知道，很快就会把记录附加到文件中

1335
00:41:31,810 --> 00:41:33,100
0,330 330,540 540,870 870,1050 1050,1290
soon to file| with the
|将计算结果与计算结果进行比较。

1336
00:41:33,100 --> 00:41:34,540
0,360 360,960 960,1080 1080,1380 1380,1440
resulting computation with result of

1337
00:41:34,540 --> 00:41:36,500
0,60 60,630 930,1470
the computation.| Okay?|
|好吧?|

1338
00:41:36,970 --> 00:41:38,050
0,330 360,660 660,750 750,870 870,1080
Good, so you know step
很好，所以你知道第一步我们有客户，

1339
00:41:38,050 --> 00:41:40,180
0,390 390,780 780,990 990,1620
1 we have clients,|
|

1340
00:41:40,180 --> 00:41:41,530
0,480 480,840 840,1050 1050,1290 1290,1350
{} it will talk to
它将与大师交谈，以确定在哪里写作。

1341
00:41:41,530 --> 00:41:42,550
0,60 60,420 420,570 570,690 690,1020
the {master -} to figure

1342
00:41:42,550 --> 00:41:44,200
0,270 270,570 570,690 690,1080
out where to write.|
|

1343
00:41:44,520 --> 00:41:45,690
0,270 270,420 420,510 510,810 810,1170
And so the master {looks,in}
于是主人看了看桌子，

1344
00:41:45,690 --> 00:41:47,040
0,210 210,480 480,960 960,1170 1170,1350
it's {} table,| where the
|其中要分块句柄的文件名，

1345
00:41:47,040 --> 00:41:49,530
0,330 330,810 1230,1830 1830,2220 2220,2490
{filename -} {} to chunk

1346
00:41:49,530 --> 00:41:50,700
0,720
handles,|
|

1347
00:41:56,510 --> 00:41:57,860
0,480 480,810 810,1020 1020,1110 1110,1350
and finds {you,know} the chunk
发现你知道大块的句柄

1348
00:41:57,860 --> 00:41:59,660
0,600 630,840 840,1290 1290,1380 1380,1800
handles| and then you know
|然后你知道，看看这张服务器的区块句柄表格，

1349
00:41:59,690 --> 00:42:01,160
0,360 360,450 450,660 660,1140 1140,1470
looks at this table of

1350
00:42:01,190 --> 00:42:03,140
0,690 690,1350
chunk handles

1351
00:42:05,450 --> 00:42:09,320
0,180 180,450 450,930 2910,3570 3570,3870
to {servers -},| {to,find,the,list,of} serves
|要找到具有以下功能的发球列表，

1352
00:42:09,320 --> 00:42:10,910
0,210 210,720 870,1230 1230,1530 1530,1590
that has,| that have a
|有一样特别的东西。

1353
00:42:10,910 --> 00:42:12,140
0,390 390,690
particular thing.|
|

1354
00:42:12,170 --> 00:42:13,340
0,180 180,360 360,510 510,870 870,1170
They have that particular chunk.|
他们有那块特殊的块。|

1355
00:42:13,950 --> 00:42:15,210
0,300 300,420 420,570 570,780 780,1260
Okay, so what happens next,|
好的，接下来会发生什么，|

1356
00:42:15,240 --> 00:42:17,670
0,450 660,960 960,1110 1110,1650 1710,2430
so there's two cases,| when
所以有两个案例，|当第二个案例中已经有初选的时候，

1357
00:42:17,670 --> 00:42:19,440
0,690 690,1050 1050,1590 1590,1710 1710,1770
there's already primary in the

1358
00:42:19,440 --> 00:42:20,910
0,270 270,600 600,900 960,1200 1200,1470
second case,| the first case
|第一例，两例均为原发或非原发。

1359
00:42:20,910 --> 00:42:22,050
0,240 240,330 330,720 720,1050 1050,1140
with two cases having a

1360
00:42:22,050 --> 00:42:23,560
0,300 300,390 390,660 660,900
primary or not primary.|
|

1361
00:42:23,650 --> 00:42:24,520
0,300 300,540 540,690 690,780 780,870
Let's say this is the
假设这是这个特定的客户第一次为这个特定的块联系主控，

1362
00:42:24,520 --> 00:42:25,600
0,270 270,510 510,840 840,930 930,1080
very first time that this

1363
00:42:25,600 --> 00:42:27,550
0,420 420,900 1020,1470 1470,1530 1530,1950
particular client contacts the master

1364
00:42:27,550 --> 00:42:29,620
0,90 90,270 270,1140 1170,1560 1740,2070
for this particular chunk,| nobody
|到目前为止，还没有其他人这样做过，

1365
00:42:29,620 --> 00:42:30,340
0,180 180,300 300,450 450,540 540,720
else has done it so

1366
00:42:30,340 --> 00:42:31,840
0,480 510,630 630,810 810,990 990,1500
far,| so there's no primary.|
|所以没有初选。|

1367
00:42:32,510 --> 00:42:33,470
0,180 180,330 330,690 690,780 780,960
In that case, you know
在这种情况下，你知道我们需要做的是，

1368
00:42:33,470 --> 00:42:35,700
0,90 90,300 300,750 780,1650
we need to do,|
|

1369
00:42:35,850 --> 00:42:37,380
0,450 450,630 630,720 720,1110 1380,1530
master needs to pick a
师父要选一个初选，对，

1370
00:42:37,380 --> 00:42:38,400
0,450 450,690 690,810 810,930 930,1020
primary, right,| how did it
|它是怎么做到的。

1371
00:42:38,400 --> 00:42:39,360
0,120 120,390
do that.|
|

1372
00:42:39,950 --> 00:42:41,300
0,210 210,210 210,960 960,1020 1020,1350
{} I think the master
我认为主服务器只选择任何可用的块服务器，对吧。

1373
00:42:41,300 --> 00:42:43,250
0,210 210,690 720,1350 1380,1770 1800,1950
just picks any of the

1374
00:42:43,250 --> 00:42:46,020
0,450 450,660 660,1050 1050,1440
available chunk servers, right.|
|

1375
00:42:46,290 --> 00:42:48,090
0,150 150,660 1110,1470 1470,1590 1590,1800
{Yeah,it's} one, {} so each
是的，它是一个，所以每一个主要的和其他的都是次要的，

1376
00:42:48,090 --> 00:42:49,230
0,180 180,300 300,540 540,1020 1020,1140
one of those primary and

1377
00:42:49,230 --> 00:42:50,550
0,390 390,600 600,660 660,720 720,1320
other ones are the secondary,|
|

1378
00:42:50,880 --> 00:42:52,290
0,360 360,510 510,840 840,960 960,1410
what other steps are involved
在这种情况下，还涉及到哪些步骤。

1379
00:42:52,290 --> 00:42:54,270
0,150 150,270 270,450 450,630 1050,1980
in this sort of.| Yeah,
|是的，然后主人就把租约给了那个初级中学

1380
00:42:54,270 --> 00:42:55,530
0,120 120,270 270,780 780,900 900,1260
and then subsequently the master

1381
00:42:55,530 --> 00:42:58,560
0,420 420,600 600,1230 1620,2280 2460,3030
grants a lease to that

1382
00:42:58,560 --> 00:43:00,600
0,600 600,1080 1110,1350 1350,1800 1800,2040
primary| and at least has
|并且至少有一个类似的过期日期。

1383
00:43:00,600 --> 00:43:02,490
0,60 60,480 480,1110 1140,1800 1800,1890
a certain like date of

1384
00:43:02,490 --> 00:43:04,380
0,750 1170,1410 1410,1590 1590,1830 1830,1890
expiry.| Yeah, what else do,
|是的，还有什么，你有一条或多条其他关键信息。

1385
00:43:04,380 --> 00:43:05,160
0,90 90,360 360,540 540,630 630,780
you have one or more

1386
00:43:05,160 --> 00:43:06,570
0,210 210,420 420,480 480,840 840,1410
other piece of crucial information.|
|

1387
00:43:07,820 --> 00:43:09,260
0,780

1388
00:43:10,150 --> 00:43:11,360
0,630
Even.|
不相上下。|

1389
00:43:12,260 --> 00:43:16,010
0,810 810,900 900,1230 1230,1740 1740,3750
Increment the version number?| Yeah,
是否递增版本号？|是的，是的，一个是增量版本号，

1390
00:43:16,040 --> 00:43:18,140
0,540 540,960 960,1140 1140,1620 1710,2100
yeah, one is increment version

1391
00:43:18,140 --> 00:43:20,930
0,570 1830,2370 2370,2460 2460,2610 2610,2790
number,| because you're gonna make
|因为你要做一个新的初选

1392
00:43:20,930 --> 00:43:22,970
0,30 30,750 780,1650 1650,1830 1830,2040
a new primary| and when
|当你每次制作新的初选时，或者无论你制作什么新的初选，

1393
00:43:22,970 --> 00:43:23,600
0,150 150,360 360,420 420,600 600,630
every time you make a

1394
00:43:23,600 --> 00:43:24,980
0,180 180,810 810,1080 1080,1230 1230,1380
new primary, {or,whatever,you,make,a,new,primary},| you go
|您需要考虑的是文件系统进入了一个新纪元

1395
00:43:24,980 --> 00:43:26,000
0,120 120,390 450,630 630,870 870,1020
to {sort,of} want to think

1396
00:43:26,000 --> 00:43:27,290
0,270 270,390 390,630 630,810 810,1290
about is a new epoch

1397
00:43:27,320 --> 00:43:29,750
0,1020 1020,1080 1080,1320 1320,1770 2160,2430
{in,the} {} file system| or
|或者这个特定的文件，所以增加版本号，

1398
00:43:29,750 --> 00:43:30,950
0,150 150,510 510,990 990,1080 1080,1200
this particular file and so

1399
00:43:30,950 --> 00:43:31,970
0,180 180,390 390,450 450,720 720,1020
you increase the version number,|
|

1400
00:43:32,180 --> 00:43:33,260
0,300 300,450 450,630 630,660 660,1080
because you have a new
因为你有一个新的数据，

1401
00:43:33,260 --> 00:43:34,080
0,420
data,|
|

1402
00:43:34,600 --> 00:43:36,100
0,390 390,600 600,930 930,1020 1020,1500
{} so basically the master
因此，基本上主程序会增加版本号。

1403
00:43:36,100 --> 00:43:37,820
0,360 360,480 480,720 720,1140
increases the version number.|
|

1404
00:43:37,880 --> 00:43:39,980
0,750 750,1260 1260,1440 1440,1770 1770,2100
Yeah, it's {} sends to
是的，它会在次要目录中向主要目录发送一个新的版本号

1405
00:43:39,980 --> 00:43:42,530
0,120 120,780 810,1710 1740,2250 2250,2550
the primary a new version

1406
00:43:42,530 --> 00:43:43,940
0,270 270,390 390,480 480,1200 1230,1410
number in the secondaries| and
|然后说，嘿，伙计们，我们要开始一个新的，

1407
00:43:43,940 --> 00:43:45,050
0,210 210,330 330,660 690,1020 1020,1110
saying like hey guys we're

1408
00:43:45,050 --> 00:43:47,570
0,330 360,690 690,750 750,1290 1740,2520
gonna start a new, {}|
|

1409
00:43:47,570 --> 00:43:48,920
0,150 150,450 450,480 480,630 630,1350
we understand a new mutation
我们了解到你为了形成复制组而获得的一种新的突变

1410
00:43:48,950 --> 00:43:50,510
0,480 480,630 630,870 870,1260 1260,1560
{} you got for forming

1411
00:43:50,510 --> 00:43:51,860
0,90 90,450 450,810 1050,1200 1200,1350
a replica group| and your
|和您的复制组与这个特定的版本号，无论版本号12，对。

1412
00:43:51,860 --> 00:43:53,030
0,390 390,570 570,660 660,810 810,1170
replica group with this particular

1413
00:43:53,030 --> 00:43:55,340
0,270 270,1080 1140,1590 1590,1770 1770,2310
version {number,whatever} version number 12,

1414
00:43:56,290 --> 00:43:57,260
0,420
right.|
|

1415
00:43:57,350 --> 00:43:58,910
0,630 630,840 840,1290 1290,1440 1440,1560
And the primary and the
以及主存储版本号和辅助存储版本号，

1416
00:43:58,910 --> 00:44:00,320
0,360 360,780 780,1080 1080,1260 1260,1410
secondary store version number,| what
|您存储的是什么版本号。

1417
00:44:00,320 --> 00:44:01,610
0,60 60,300 300,600 600,1050 1050,1290
do you is store {the,version}

1418
00:44:01,610 --> 00:44:02,540
0,390
number.|
|

1419
00:44:07,210 --> 00:44:09,310
0,480 480,690 690,1320 1350,1830 1830,2100
{Do,they,store} on disk or on
它们是存储在磁盘上，还是存储在磁盘或内存上，或者。

1420
00:44:09,310 --> 00:44:11,770
0,270 270,690 690,1170 1200,1950 1950,2460
their disk or memory, or.|
|

1421
00:44:16,160 --> 00:44:17,460
0,240 240,420 420,690
I don't know.|
我不知道。|

1422
00:44:18,780 --> 00:44:19,920
0,570
Anyone,
有没有人，你觉得。

1423
00:44:20,040 --> 00:44:22,380
0,180 180,240 240,1380 1380,1770
what do you think.|
|

1424
00:44:22,740 --> 00:44:23,880
0,150 150,330 330,540 540,720 720,1140
Okay, let's first do memory,|
好的，让我们先来回忆一下，|

1425
00:44:23,880 --> 00:44:25,200
0,180 180,390 390,900 900,990 990,1320
let's say storage in memory,|
比如说存储在内存中，|

1426
00:44:25,200 --> 00:44:26,740
0,300 300,390 390,570 570,990
{would,that,be} a good design?|
这是一个好的设计吗？|

1427
00:44:28,900 --> 00:44:30,280
0,690
No.|
不是的。|

1428
00:44:30,720 --> 00:44:33,690
0,450 1050,1290 1290,1680 2070,2520 2520,2970
Sorry.| You {can,go}.| I guess
抱歉的。|你可以走了。|我想不会的，

1429
00:44:33,690 --> 00:44:35,010
0,150 150,510 510,840 840,1020 1020,1320
it wouldn't,| because if the
|因为如果区块服务器出现故障

1430
00:44:35,010 --> 00:44:36,840
0,240 240,570 570,810 810,1350 1350,1830
chunk server goes down| and
|然后它又回到了上面，

1431
00:44:36,840 --> 00:44:37,860
0,120 120,240 240,480 480,720 720,1020
then it comes back up

1432
00:44:37,890 --> 00:44:38,840
0,300
it,|
|

1433
00:44:38,840 --> 00:44:40,040
0,210 210,390 390,600 600,840 840,1200
it should know what version
它应该知道自己有什么版本。

1434
00:44:40,040 --> 00:44:42,050
0,150 150,660 1200,1500 1500,1680 1680,2010
it has.| Yeah, because otherwise
|是的，因为否则你不能说服初选有最近一次的，

1435
00:44:42,050 --> 00:44:43,100
0,60 60,270 270,600 600,690 690,1050
you couldn't convince the primary

1436
00:44:43,100 --> 00:44:44,090
0,180 180,360 360,450 450,660 660,990
that has the most recent

1437
00:44:44,090 --> 00:44:45,320
0,210 270,750 750,840 840,1140 1140,1230
one,| was a primary of
|是一个初级阶段的高手可以大放异彩，

1438
00:44:45,320 --> 00:44:47,000
0,630 660,1050 1050,1260 1260,1560 1590,1680
the master could big,| you
|你知道动机数据的结构。

1439
00:44:47,000 --> 00:44:48,440
0,150 150,270 300,690 690,990 990,1440
know the structure of motivation

1440
00:44:48,440 --> 00:44:49,300
0,300
data.|
|

1441
00:44:49,610 --> 00:44:50,270
0,150 150,240 240,420 420,480 480,660
So it has to be
所以它必须在这个上面，

1442
00:44:50,270 --> 00:44:51,710
0,300 300,720 750,900 900,1290 1290,1440
on this,| so basically the
|因此，版本号基本上存储在磁盘上，包括块服务器和主服务器，对吧。

1443
00:44:51,710 --> 00:44:52,850
0,270 270,570 570,750 750,870 870,1140
version number lives on disk,

1444
00:44:52,850 --> 00:44:54,980
0,480 480,540 540,1470 1500,1770 1770,2130
both at the chunk servers

1445
00:44:54,980 --> 00:44:56,620
0,330 660,1080
and {at,the,master},

1446
00:44:57,030 --> 00:44:58,080
0,450
right.|
|

1447
00:44:58,340 --> 00:44:59,660
0,180 180,420 420,540 540,960 1170,1320
So when the chunk, the
所以当大块，主人回来的时候，

1448
00:44:59,660 --> 00:45:00,800
0,300 300,510 510,900 900,990 990,1140
master gets back,| you know
|您知道来自主服务器和辅助服务器的确认，即它们已将版本号写入磁盘，

1449
00:45:00,800 --> 00:45:02,900
0,660 690,1350 1350,1590 1590,1770 1770,2100
the acknowledgement from the primary

1450
00:45:02,900 --> 00:45:04,880
0,120 120,660 660,810 810,1200 1200,1980
and secondary that they {}

1451
00:45:04,910 --> 00:45:06,440
0,420 420,870 900,1200 1200,1410 1410,1530
written the version number to

1452
00:45:06,440 --> 00:45:08,570
0,480 570,960 960,1470 1590,1800 1800,2130
disk,| and in the primary
|而在初选中实际上已经收到了释放，

1453
00:45:08,570 --> 00:45:10,220
0,210 210,360 360,750 750,1050 1050,1650
actually has received the release,|
|

1454
00:45:10,340 --> 00:45:12,050
0,630 660,750 750,930 930,1200 1260,1710
then you know the master
那么您知道主服务器也会将其版本号写入磁盘，

1455
00:45:12,050 --> 00:45:14,480
0,600 840,1560 1560,1770 1770,2070 2070,2430
also writes its version number

1456
00:45:14,480 --> 00:45:16,010
0,390 390,780 780,900 900,1110 1110,1530
to disk,| and then responds
|然后对客户作出响应。

1457
00:45:16,010 --> 00:45:17,040
0,60 60,150 150,600
to the client.|
|

1458
00:45:18,050 --> 00:45:19,160
0,600
Okay?|
好吧?|

1459
00:45:19,780 --> 00:45:20,590
0,300 300,420 420,660 660,750 750,810
So to back to the
因此，要返回到客户端，使用服务器列表进行响应，

1460
00:45:20,590 --> 00:45:22,510
0,540 660,1290 1290,1500 1500,1560 1560,1920
client, responds with a list

1461
00:45:22,510 --> 00:45:24,700
0,90 90,810 990,1290 1290,1890 1890,2190
of servers,| {you,know} primary plus
|你知道主要加次要加版本号。

1462
00:45:25,240 --> 00:45:28,720
0,870 1110,1560 1560,1920 1920,2280
secondary plus version number.|
|

1463
00:45:29,350 --> 00:45:30,520
0,630
Okay?|
好吧?|

1464
00:45:31,580 --> 00:45:32,810
0,570 570,660 660,780 780,960 960,1230
Then you know the next
然后你知道下一步

1465
00:45:32,810 --> 00:45:33,950
0,450 450,540 540,780 780,1050 1050,1140
step| and again here we
|同样，我们在这里看到，整个目标是从网络中输入大量数据，

1466
00:45:33,950 --> 00:45:34,760
0,180 180,270 270,450 450,690 690,810
see the whole goal is

1467
00:45:34,760 --> 00:45:35,780
0,450 480,630 630,780 780,960 960,1020
to type a lot of

1468
00:45:35,780 --> 00:45:36,920
0,270 270,450 450,510 510,930 930,1140
data from the network,| is
|客户端实际上只是将想要写入的数据发送到主服务器和辅助服务器，

1469
00:45:36,920 --> 00:45:39,140
0,390 390,810 1050,1650 1650,1890 1890,2220
{the,client} actually {} just sends

1470
00:45:39,140 --> 00:45:40,700
0,90 90,570 600,810 810,1080 1080,1560
the data that wants write

1471
00:45:40,700 --> 00:45:42,530
0,300 300,990 1020,1200 1200,1410 1410,1830
to the to the primary

1472
00:45:42,530 --> 00:45:44,330
0,90 90,150 150,660 1470,1650 1650,1800
and the secondary,| the way
|它的实际工作方式是一种有趣的方式

1473
00:45:44,330 --> 00:45:45,230
0,90 90,300 300,630 630,690 690,900
it actually does is sort

1474
00:45:45,230 --> 00:45:46,280
0,60 60,180 180,510 510,900 900,1050
of an interesting way| and
|基本上就是联系它认识的最近的第二个，你知道的，在这个名单上

1475
00:45:46,280 --> 00:45:48,320
0,330 330,810 810,870 870,1410 1410,2040
basically contact the closest secondary

1476
00:45:48,320 --> 00:45:49,640
0,90 90,360 360,750 900,1260 1260,1320
it knows off, {you,know,out} of

1477
00:45:49,640 --> 00:45:51,170
0,210 210,720 990,1140 1140,1410 1410,1530
this list| and sends the
|并将数据发送到那里。

1478
00:45:51,170 --> 00:45:52,140
0,210 210,600
data there.|
|

1479
00:45:52,520 --> 00:45:54,410
0,540 570,870 870,1380 1380,1500 1500,1890
And that secondary {you,know} move
而你知道的第二个人会将数据转移到列表中的下一个人

1480
00:45:54,410 --> 00:45:55,190
0,60 60,330 330,600 600,720 720,780
the data over to the

1481
00:45:55,190 --> 00:45:56,570
0,480 510,870 870,960 960,1050 1050,1380
next person in the list|
|

1482
00:45:56,570 --> 00:45:57,500
0,120 120,330 330,450 450,540 540,930
and then to the next
然后转到下一个服务器列表。

1483
00:45:57,500 --> 00:45:58,840
0,450 450,840
server list.|
|

1484
00:45:59,360 --> 00:46:00,440
0,510

1485
00:46:00,500 --> 00:46:01,400
0,210 210,300 300,480 480,810 810,900
And so this way you
通过这种方式，您可以了解从您知道的客户端发送到管道中的所有副本的数据

1486
00:46:01,400 --> 00:46:02,300
0,120 120,300 300,570 570,810 810,900
know the data sort of

1487
00:46:02,300 --> 00:46:04,100
0,690 690,960 960,1020 1020,1590 1590,1800
pumped from the clients {you,know}

1488
00:46:04,100 --> 00:46:05,840
0,270 270,600 690,1380 1380,1530 1530,1740
to the pipeline to all

1489
00:46:05,840 --> 00:46:06,800
0,360
the

1490
00:46:06,800 --> 00:46:09,260
0,210 210,660 660,960 1110,2190 2340,2460
{} {replicas -}| and you
|你知道，当第二个人收到，

1491
00:46:09,260 --> 00:46:11,090
0,600 600,810 810,900 900,1410 1410,1830
know when the secondary receives,|
|

1492
00:46:11,090 --> 00:46:11,960
0,90 90,270 270,630 630,720 720,870
the first secondary {receives -}
第一次设备接收一些数据，

1493
00:46:11,960 --> 00:46:13,040
0,240 240,360 360,450 450,720 720,1080
some of the data,| immediately
|立即开始将数据进一步推向下一步。

1494
00:46:13,040 --> 00:46:14,990
0,330 330,660 660,960 960,1050 1050,1950
starts actually pushing the data

1495
00:46:15,020 --> 00:46:16,620
0,330 330,540 540,630 630,1080
further down the pipeline.|
|

1496
00:46:16,760 --> 00:46:17,960
0,660
Okay?|
好吧?|

1497
00:46:18,960 --> 00:46:20,490
0,390 390,480 480,1050 1050,1200 1200,1530
{The,reason} this {design,is} this way
这种设计的原因基本上是这种网络接口通过外部世界的客户端，

1498
00:46:20,490 --> 00:46:21,690
0,210 210,270 270,660 660,870 870,1200
sort of basically this network

1499
00:46:21,690 --> 00:46:23,190
0,450 450,900 900,1200 1200,1290 1290,1500
interface {the,client -} that goes

1500
00:46:23,190 --> 00:46:25,170
0,120 120,240 240,600 600,1050 1110,1980
through the outside world,| uses
|使用全网络接口沿管道向下推送数据。

1501
00:46:25,170 --> 00:46:26,520
0,90 90,450 450,780 780,1260 1260,1350
a full network interface to

1502
00:46:26,520 --> 00:46:27,540
0,270 270,360 360,660 660,960 960,1020
push the data down the

1503
00:46:27,540 --> 00:46:28,540
0,480
pipeline.|
|

1504
00:46:29,000 --> 00:46:29,780
0,240 240,360 360,360 360,690 690,780
{So,that} {gives -} us {}
因此，这为我们提供了高吞吐量。

1505
00:46:29,780 --> 00:46:30,980
0,210 210,630
high throughput.|
|

1506
00:46:31,550 --> 00:46:32,580
0,540
Okay?|
好吧?|

1507
00:46:34,650 --> 00:46:35,730
0,210 210,360 360,750 750,900 900,1080
Okay, so then you know
好的，那么你知道如果这一切都成功了

1508
00:46:35,730 --> 00:46:37,830
0,390 390,540 540,720 720,1470 1500,2100
if this all successful| and
|数据已经被推送到所有服务器，

1509
00:46:37,830 --> 00:46:38,880
0,90 90,330 330,480 480,600 600,1050
the data has been pushed

1510
00:46:38,880 --> 00:46:40,260
0,90 90,330 330,600 600,870 870,1380
you know to all the

1511
00:46:40,290 --> 00:46:41,820
0,510 630,870 870,1110 1110,1320 1320,1530
servers,| those servers don't store
|这些服务器还不会将信息存储在此文件中

1512
00:46:41,820 --> 00:46:43,020
0,150 150,570 570,630 630,870 870,1200
that information in this yet|
|

1513
00:46:43,020 --> 00:46:44,220
0,90 90,210 210,450 450,630 630,1200
and it just sits there
它只是坐在那里，有点像在一边，

1514
00:46:44,250 --> 00:46:45,240
0,240 240,300 300,450 450,540 540,990
sort of on the side,|
|

1515
00:46:45,240 --> 00:46:46,440
0,90 90,240 240,540 540,660 660,1200
you know to be used
你知道要在下一步中使用，

1516
00:46:46,440 --> 00:46:48,330
0,300 300,390 390,600 600,1080 1680,1890
in the next step,| so
|所以下一步基本上是让客户端发送消息，

1517
00:46:48,330 --> 00:46:49,350
0,60 60,240 240,450 450,570 570,1020
the next step is basically

1518
00:46:49,350 --> 00:46:50,700
0,180 180,450 450,990 1050,1200 1200,1350
for the client to send

1519
00:46:50,700 --> 00:46:52,110
0,30 30,360 360,510 510,1020 1020,1410
a message,| like {an,append} message
|就像将您知道的消息附加到主服务器

1520
00:46:52,110 --> 00:46:54,040
0,270 270,810
{you,know} to

1521
00:46:54,190 --> 00:46:56,770
0,570 600,1260 1620,2310 2310,2400 2400,2580
the primary| and at that
|在这一点上，你知道主服务器会检查你知道版本号，对吧，

1522
00:46:56,770 --> 00:46:58,540
0,570 870,990 990,1230 1230,1380 1380,1770
point you know the primary

1523
00:46:58,540 --> 00:46:59,770
0,210 210,660 690,840 840,900 900,1230
will check you know {the,version}

1524
00:46:59,770 --> 00:47:01,280
0,450 480,840
number, right,|
|

1525
00:47:02,240 --> 00:47:03,800
0,330 330,420 420,660 660,1080 1080,1560
whether it actually version corresponds
无论它的实际版本是否对应于版本号，

1526
00:47:03,800 --> 00:47:04,820
0,60 60,270 270,540 540,870 870,1020
to the version number,| it
|它不对应于，如果它不匹配，

1527
00:47:04,820 --> 00:47:06,860
0,630 630,1080 1080,1170 1170,1650 1650,2040
doesn't correspond to, {if,it} doesn't

1528
00:47:06,860 --> 00:47:08,480
0,360 360,810 810,1140 1140,1380 1380,1620
match,| then they probably won't
|那么他们可能不会允许这样做。

1529
00:47:08,480 --> 00:47:09,540
0,270 270,510
allow it.|
|

1530
00:47:09,540 --> 00:47:10,710
0,330 330,480 480,780 780,990 990,1170
{} The primary checks this
主要检查该租约，该租约是否有效，

1531
00:47:10,710 --> 00:47:12,390
0,600 630,720 720,840 840,1200 1200,1680
lease, is the lease valid,|
|

1532
00:47:13,290 --> 00:47:14,490
0,300 300,630 630,720 720,900 900,1200
because {if,lease} is not valid
因为如果租赁不再有效，

1533
00:47:14,490 --> 00:47:16,470
0,450 450,570 570,930 930,1440 1470,1980
anymore,| it cannot accept {}
|它不能接受任何变异操作，

1534
00:47:16,470 --> 00:47:18,630
0,420 420,870 870,1470 1470,1980 1980,2160
any mutation operations,| because it
|因为如果租赁无效，

1535
00:47:18,630 --> 00:47:19,860
0,180 180,480 480,960 960,1140 1140,1230
if lease {is,not,valid},| {there,might} be
|外面的世界可能会有另一场初选。

1536
00:47:19,860 --> 00:47:21,750
0,420 420,1020 1020,1500 1500,1800 1800,1890
another primary outside in the

1537
00:47:21,750 --> 00:47:22,620
0,420
world.|
|

1538
00:47:23,100 --> 00:47:24,540
0,300 300,600 600,780 780,1050 1050,1440
{} So it checks the
所以它会检查租约，

1539
00:47:24,540 --> 00:47:25,580
0,540
lease,|
|

1540
00:47:25,610 --> 00:47:26,480
0,150 150,360 360,600 600,720 720,870
and then, if you know
然后，如果您知道与租约基本匹配的版本号仍然有效，

1541
00:47:26,480 --> 00:47:27,770
0,360 360,420 420,690 690,930 930,1290
basically the version numbers match

1542
00:47:27,770 --> 00:47:28,940
0,210 210,390 390,480 480,720 720,1170
the lease is still valid,|
|

1543
00:47:29,150 --> 00:47:30,710
0,450 450,690 690,750 750,1380 1410,1560
basically picks an offset to
基本上是选择一个偏移量来提前写入。

1544
00:47:30,710 --> 00:47:33,480
0,270 270,570
write ahead.|
|

1545
00:47:34,190 --> 00:47:34,970
0,210 210,300 300,360 360,540 540,780
And then the next step
然后下一步基本上是我们写下你知道的刚刚进来的数据，

1546
00:47:34,970 --> 00:47:36,290
0,210 210,390 390,780 780,1230 1230,1320
is we basically, write you

1547
00:47:36,290 --> 00:47:37,190
0,90 90,210 210,480 480,720 720,900
know the data that just

1548
00:47:37,190 --> 00:47:38,000
0,180 180,480 480,540 540,660 660,810
came in,| you know this
|你知道这张唱片放到了一个稳定的储藏室，

1549
00:47:38,000 --> 00:47:40,400
0,480 960,1200 1200,1800 1800,2070 2070,2400
record {} to a stable

1550
00:47:40,400 --> 00:47:42,350
0,540 570,840 840,990 990,1350 1350,1950
storage,| so the primary actually
|因此，主节点在这一点上实际上将其写入稳定存储，即数据

1551
00:47:42,350 --> 00:47:44,330
0,180 180,540 540,840 840,1320 1320,1980
{at,this} point {write,it,to} stable storage,

1552
00:47:44,940 --> 00:47:47,010
0,180 180,720 1440,1620 1620,1800 1800,2070
the data| and then sends
|然后将消息发送到次要服务器，

1553
00:47:47,010 --> 00:47:49,020
0,690 690,840 840,930 930,1470 1470,2010
messages to the secondary,| saying
|说请将数据写入。

1554
00:47:49,020 --> 00:47:50,160
0,300 300,540 540,600 600,870 870,1140
please write the data to.|
|

1555
00:47:51,480 --> 00:47:53,520
0,690 690,990 990,1380
And since the
由于主要选择的是偏移量，

1556
00:47:53,550 --> 00:47:54,900
0,420 420,630 630,720 720,1260 1260,1350
primary picks the offsets you

1557
00:47:54,900 --> 00:47:55,950
0,210 210,480 480,720 720,990 990,1050
know the,| it tells the
|它告诉从属服务器将您知道的特定记录写入文件的位置。

1558
00:47:55,950 --> 00:47:57,450
0,510 510,900 900,1020 1020,1440 1440,1500
secondaries where to write you

1559
00:47:57,450 --> 00:47:58,770
0,150 150,360 360,720 720,1050 1050,1320
know that particular record into

1560
00:47:58,770 --> 00:47:59,840
0,120 120,510
the file.|
|

1561
00:48:00,310 --> 00:48:01,390
0,210 210,450 450,570 570,750 750,1080
So maybe you like whatever
所以也许你会想尽一切办法来抵消125

1562
00:48:01,390 --> 00:48:03,370
0,120 120,300 300,360 360,780 960,1980
it takes to offset 125|
|

1563
00:48:03,370 --> 00:48:04,150
0,90 90,270 270,390 390,720 720,780
and it will tell the
它会告诉中学，

1564
00:48:04,150 --> 00:48:06,400
0,360 360,990 1140,1740 1740,2100 2100,2250
{secondaries -},| go all to
|全力以赴写，你知道早些时候在偏移量125处进来的数据。

1565
00:48:06,400 --> 00:48:07,540
0,360 360,450 450,600 600,870 870,1140
write you know the data

1566
00:48:07,540 --> 00:48:09,040
0,210 210,420 420,600 600,1170 1170,1500
that came in earlier at

1567
00:48:09,070 --> 00:48:10,840
0,420 510,720 720,960 960,1290
offset {125 - -}.|
|

1568
00:48:11,930 --> 00:48:14,810
0,480 480,870 870,1140 1140,1770 1770,2880
Then, if everything workout,| {you,know}
然后，如果一切顺利，|大家都知道，主服务器中的所有次要服务器都成功地将其数据写回磁盘，

1569
00:48:14,810 --> 00:48:16,700
0,600 600,870 870,990 990,1500 1620,1890
everybody, all the secondary {in,the,primary}

1570
00:48:16,700 --> 00:48:18,080
0,330 330,810 810,1050 1050,1140 1140,1380
{} successfully write their data

1571
00:48:18,080 --> 00:48:19,160
0,330 330,420 420,510 510,630 630,1080
back you know to disk,|
|

1572
00:48:19,310 --> 00:48:20,660
0,360 360,660 660,1050 1050,1260 1260,1350
{then,it} actually responds back to
然后它实际上会对客户端做出响应，

1573
00:48:20,660 --> 00:48:22,370
0,90 90,420 420,720 720,1050 1230,1710
the client,| saying like okay
|像这样说，好吧，你附加的成功确实发生了。

1574
00:48:22,400 --> 00:48:24,740
0,720 1020,1350 1350,1740 1740,1980 1980,2340
success {} you append actually

1575
00:48:24,740 --> 00:48:25,660
0,510
happens.|
|

1576
00:48:27,770 --> 00:48:29,540
0,240 240,330 330,660 660,1170 1170,1770
There's a way that the
存在一种写入实际上可能不成功或可能不成功的方式

1577
00:48:29,690 --> 00:48:30,980
0,450 450,690 690,930 930,1050 1050,1290
write actually might be not

1578
00:48:30,980 --> 00:48:32,300
0,540 540,720 720,1020 1020,1170 1170,1320
successful or it might not

1579
00:48:32,300 --> 00:48:33,770
0,90 90,600 600,690 690,1080 1080,1470
be successful| and namely example,
|也就是说，主服务器已写入其自己的磁盘，

1580
00:48:33,770 --> 00:48:34,670
0,90 90,420 420,540 540,720 720,900
the primary has written into

1581
00:48:34,670 --> 00:48:36,800
0,150 150,330 330,810 1020,1920 1950,2130
its own disk,| {} but
|但它没能写出来，

1582
00:48:36,800 --> 00:48:37,790
0,120 120,390 390,480 480,720 720,990
it fails to write it,|
|

1583
00:48:37,790 --> 00:48:38,780
0,150 150,330 330,510 510,750 750,990
you know it fails to
您知道它无法连接到其中一个辅助服务器，

1584
00:48:38,780 --> 00:48:39,740
0,360 360,480 480,690 690,810 810,960
connect to one of the

1585
00:48:39,740 --> 00:48:42,200
0,570 570,840 840,1620 1620,1920 1920,2460
secondaries,| maybe secondary actually crashed,|
|或许次要任务真的坠毁了，|

1586
00:48:42,200 --> 00:48:43,520
0,120 120,570 570,690 690,1170 1170,1320
or maybe the secondary just
或者，可能是次要服务器的网络连接不起作用。

1587
00:48:43,520 --> 00:48:44,510
0,180 180,300 300,570 570,900 900,990
has a network connection that

1588
00:48:44,510 --> 00:48:45,400
0,270 270,510
doesn't work.|
|

1589
00:48:46,060 --> 00:48:47,230
0,150 150,210 210,420 420,840 840,1170
And in that case, the
在这种情况下，主服务器实际上向客户端返回错误，

1590
00:48:47,230 --> 00:48:49,090
0,360 360,600 600,1170 1170,1320 1320,1860
primary actually returns an error

1591
00:48:49,270 --> 00:48:52,960
0,240 240,750 1140,1710 1740,2280 2940,3690
to the client,| so error
|因此，如果一个辅助服务器没有响应，则是错误的。

1592
00:48:52,960 --> 00:48:54,360
0,600
if

1593
00:48:55,630 --> 00:49:01,660
0,420 420,1320 1890,2190 2190,2760
one secondary didn't respond.|
|

1594
00:49:04,340 --> 00:49:05,480
0,180 180,270 270,510 510,810

1595
00:49:05,510 --> 00:49:06,410
0,180 180,240 240,420 420,780 780,900
And in that case the
在这种情况下，客户端库将执行的操作通常是尝试或重试，

1596
00:49:06,410 --> 00:49:07,760
0,300 300,960 990,1200 1200,1260 1260,1350
client library what it will

1597
00:49:07,760 --> 00:49:08,690
0,120 120,240 240,600 600,810 810,930
do is usually try or

1598
00:49:08,690 --> 00:49:12,230
0,540 780,1380 1380,1560 1560,2850 2880,3540
retry,| {} it will reissue
|它将重新发布相同的活动，并将再次尝试，

1599
00:49:12,230 --> 00:49:13,620
0,120 120,330 330,900
the same event,

1600
00:49:13,620 --> 00:49:15,240
0,390 390,840 840,990 990,1230 1230,1620
{} and will try again,|
|

1601
00:49:15,750 --> 00:49:16,860
0,420 420,570 570,630 630,960 960,1110
{} in the hope that
希望在第二次你知道这些数据的时候，这些数据真的能被通过。

1602
00:49:16,860 --> 00:49:18,180
0,60 60,300 300,510 510,1020 1170,1320
the second time around you

1603
00:49:18,180 --> 00:49:19,740
0,180 180,420 420,720 720,1110 1110,1560
know that data actually, {}

1604
00:49:19,740 --> 00:49:20,790
0,120 120,420 420,540 540,750 750,1050
that {actually -} get through.|
|

1605
00:49:21,690 --> 00:49:22,710
0,600 600,720 720,840 840,900 900,1020
And so this is what
这就是他们回忆起的至少一次你做的事情。

1606
00:49:22,710 --> 00:49:24,240
0,120 120,540 540,990 1140,1410 1410,1530
they recall like you do

1607
00:49:24,240 --> 00:49:25,900
0,210 210,510 510,1050
{at-least-once - -}.|
|

1608
00:49:30,830 --> 00:49:33,050
0,150 150,270 270,1080 1320,1710 1710,2220
If you retry, will the
如果重试，主节点是否会选取相同的偏移量？

1609
00:49:33,080 --> 00:49:34,460
0,420 420,600 600,660 660,900 900,1380
primary pick the same offset?|
|

1610
00:49:36,630 --> 00:49:40,740
0,150 150,330 330,510 510,960
I don't think so.|
我不这样认为。|

1611
00:49:40,740 --> 00:49:43,410
0,810 810,1290 1290,1530 1530,1770 1770,2670
{No,it,takes,a,new,offset} and {you,know} writes the,|
不，它需要一个新的偏移量，你知道的，|

1612
00:49:43,440 --> 00:49:45,360
0,450 450,690 720,1110 1110,1500 1500,1920
write {} new particular offset,|
写入新的特定偏移量，|

1613
00:49:45,750 --> 00:49:46,890
0,180 180,360 360,720 720,1020 1020,1140
so that means if you
这意味着如果你查看磁盘上的三个副本上的一个文件，

1614
00:49:46,890 --> 00:49:50,040
0,180 180,270 270,960 960,1500 1590,3150
look at the {disks -}

1615
00:49:50,040 --> 00:49:51,810
0,0 0,690 1080,1380 1380,1530 1530,1770
a file on the three

1616
00:49:51,810 --> 00:49:54,360
0,630 1320,1560 1560,1650 1650,2340 2340,2550
replicas,| {you,know} the primary {S1
|你知道主要的S1S2，

1617
00:49:54,360 --> 00:49:56,130
0,630 720,1080 1080,1320 1320,1590 1590,1770
-} {S2 -},| it might
|这可能是你写的东西，比如你知道s1 125的数据，

1618
00:49:56,130 --> 00:49:56,970
0,90 90,150 150,420 420,690 690,840
be the case something you

1619
00:49:56,970 --> 00:49:58,170
0,420 420,690 810,930 930,1050 1050,1200
wrote like you know {S1

1620
00:49:58,170 --> 00:49:59,720
0,210 210,480 480,1110
-} {125 -}

1621
00:49:59,750 --> 00:50:01,670
0,120 120,690 960,1320 1320,1500 1500,1920
the data,| {} we succeeded
|我们成功了，可能是S2 1 2，

1622
00:50:01,670 --> 00:50:02,990
0,360 360,720 720,960 960,1170 1170,1320
maybe S2 one two,| but
|但S2实际上并没有发生，没有数据，对吧。

1623
00:50:02,990 --> 00:50:04,910
0,450 480,1080 1080,1290 1290,1620 1620,1920
{S2 - -} actually doesn't

1624
00:50:04,910 --> 00:50:06,400
0,300 300,450 450,600 600,900
happen, there's no data,

1625
00:50:07,100 --> 00:50:08,080
0,420
right.|
|

1626
00:50:08,110 --> 00:50:09,850
0,270 270,450 450,720 720,930 930,1740
And then we try again,|
然后我们再试一次，|

1627
00:50:09,850 --> 00:50:10,660
0,60 60,300 300,600 600,750 750,810
we might rather read the
我们可能更愿意读取相同的数据x

1628
00:50:10,660 --> 00:50:13,060
0,240 240,660 660,1170 1170,1800 1860,2400
same data x| and maybe
|也许我们会在这三个项目上都取得成功。

1629
00:50:13,060 --> 00:50:14,200
0,240 240,570 570,660 660,810 810,1140
we'll succeed in all three.|
|

1630
00:50:14,950 --> 00:50:15,940
0,270 270,420 420,630 630,900 900,990
So you see here that
所以你可以在这里看到，基本上复制的记录是可以复制的。

1631
00:50:15,940 --> 00:50:17,290
0,300 300,780 780,1110 1110,1230 1230,1350
basically replicates records can be

1632
00:50:17,290 --> 00:50:18,460
0,630
duplicated.|
|

1633
00:50:20,960 --> 00:50:21,710
0,150 150,270 270,570 570,660 660,750
Is this something that can
这是在标准文件系统中可以发生的事情吗，

1634
00:50:21,710 --> 00:50:22,880
0,240 240,390 390,510 510,930 930,1170
happen in a standard file

1635
00:50:22,880 --> 00:50:24,320
0,390 390,690 720,930 930,1200 1200,1440
system,| like your Linux file
|就像您笔记本电脑或计算机上的Linux文件系统。

1636
00:50:24,320 --> 00:50:25,430
0,300 300,420 420,540 540,1020 1020,1110
system on your laptop or

1637
00:50:25,430 --> 00:50:26,560
0,90 90,600
your computer.|
|

1638
00:50:31,710 --> 00:50:34,860
0,660 1500,2160 2340,2640 2640,2730 2730,3150
No.| No, would you be
不是的。|不，如果你的电脑做到了这一点，你会感到惊讶吗？

1639
00:50:34,860 --> 00:50:36,690
0,660 660,780 780,1170 1170,1350 1350,1830
surprised if {your,computer} did this.|
|

1640
00:50:39,680 --> 00:50:40,460
0,120 120,300 300,480 480,660 660,780
I mean, yeah,| this is
我是说，是的，|这不是标准文件写入的工作方式。

1641
00:50:40,460 --> 00:50:41,720
0,180 180,300 300,690 690,960 960,1260
not how standard file writes

1642
00:50:41,720 --> 00:50:44,750
0,390 690,1710 1710,1800 1800,1950 1950,3030
work.| Yeah it would be
|是的，拥有这处房产会很不方便，或者这没什么关系。

1643
00:50:44,810 --> 00:50:46,780
0,750 750,870 870,1500
inconvenient to have

1644
00:50:47,760 --> 00:50:49,170
0,270 270,690 690,870 870,1200 1200,1410
this property, or it doesn't

1645
00:50:49,170 --> 00:50:50,220
0,480
matter.|
|

1646
00:50:53,140 --> 00:50:56,380
0,480 480,1200 1230,2190 2190,2850 3000,3240
Yeah, yeah, yeah.| Yeah, gonna
是啊，是啊，是啊。|是啊，这将会是一个非常奇怪的，

1647
00:50:56,380 --> 00:50:57,910
0,150 150,360 360,630 630,1230 1260,1530
be a pretty bizarre,| you
|您大概知道，就像您知道的那样，您会在文件中生成输出

1648
00:50:57,910 --> 00:50:58,990
0,150 150,420 420,870 870,930 930,1080
know presumably like you know

1649
00:50:58,990 --> 00:51:00,700
0,150 150,720 720,870 870,1260 1260,1710
you compiler you produce outputs

1650
00:51:00,700 --> 00:51:02,110
0,90 90,210 210,750 1080,1260 1260,1410
in your file| and then
|然后，您可能知道某些数据块写入了两次

1651
00:51:02,110 --> 00:51:03,370
0,420 420,480 480,600 600,870 870,1260
maybe you know certain blocks

1652
00:51:03,370 --> 00:51:04,900
0,180 180,810 810,1020 1020,1410 1410,1530
written twice| and then you
|然后你就可以再运行程序了，

1653
00:51:04,900 --> 00:51:06,100
0,240 240,360 360,450 450,780 780,1200
can run the program anymore,|
|

1654
00:51:06,130 --> 00:51:07,930
0,750 750,840 840,1200 1410,1620 1620,1800
like you know the whole
就像你知道当时整件事都是垃圾。

1655
00:51:07,930 --> 00:51:09,130
0,120 120,270 270,600 630,1110 1110,1200
thing is just garbage at

1656
00:51:09,130 --> 00:51:10,040
0,120 120,390
that point.|
|

1657
00:51:10,370 --> 00:51:11,420
0,390 390,600 600,720 720,870 870,1050
So it would just be
所以这会很奇怪，就像你写了一封电子邮件，而这是电子邮件的正文出现了两次。

1658
00:51:11,420 --> 00:51:12,230
0,330 330,480 480,570 570,720 720,810
weird like you write an

1659
00:51:12,230 --> 00:51:13,250
0,270 270,600 600,750 750,930 930,1020
email message and this is

1660
00:51:13,250 --> 00:51:14,030
0,90 90,390 390,480 480,540 540,780
the body of the email

1661
00:51:14,030 --> 00:51:15,640
0,270 270,510 510,570 570,1140
message shows up twice.|
|

1662
00:51:15,640 --> 00:51:17,890
0,780 810,1530 1560,1830 1830,1920 1920,2250
{} So this is not
因此，这不是典型的文件系统，

1663
00:51:17,890 --> 00:51:19,270
0,120 120,420 420,660 660,1050 1050,1380
your typical file system,| we
|我们做到了，所以有一种有点奇怪的

1664
00:51:19,270 --> 00:51:20,200
0,270 270,360 360,510 510,720 720,930
do and so there's like

1665
00:51:20,200 --> 00:51:22,480
0,420 420,750 750,1200 1770,2130 2160,2280
a slightly bizarre| and you
|你知道理由是什么，

1666
00:51:22,480 --> 00:51:23,710
0,60 60,240 240,330 330,420 420,1230
know what is the justification,|
|

1667
00:51:24,390 --> 00:51:25,800
0,540 540,960 960,1170 1170,1260 1260,1410
why, why, why do you
为什么，为什么，为什么你认为这是个好主意。

1668
00:51:25,800 --> 00:51:26,520
0,150 150,300 300,420 420,540 540,720
think this is a good

1669
00:51:26,520 --> 00:51:27,540
0,450
idea.|
|

1670
00:51:29,800 --> 00:51:30,700
0,240 240,420 420,570 570,750 750,900
I'm not sure what is
我不确定什么是好主意，

1671
00:51:30,700 --> 00:51:31,540
0,90 90,240 240,570 570,690 690,840
a good idea,| but I'm
|但我特别搞不懂这对MapReduce是如何起作用的，

1672
00:51:31,540 --> 00:51:33,490
0,540 540,810 810,1200 1200,1680 1680,1950
confused how that works for

1673
00:51:33,490 --> 00:51:35,770
0,270 270,690 690,1680 1860,2100 2100,2280
{mapreduce -} specifically,| so if
|因此，如果您运行Word Count并执行此操作，

1674
00:51:35,770 --> 00:51:37,960
0,540 720,1260 1260,1530 1530,2070 2070,2190
you run word count and

1675
00:51:37,960 --> 00:51:39,520
0,90 90,210 210,660 960,1350 1350,1560
you do that,| and like
|就像一些文件，你会数的，

1676
00:51:39,520 --> 00:51:41,200
0,210 210,870 870,990 990,1170 1170,1680
some files and you'll count,|
|

1677
00:51:41,260 --> 00:51:42,970
0,150 150,300 300,600 630,1110 1140,1710
and they're like word a,
它们就像一个单词，它只出现一次，

1678
00:51:43,210 --> 00:51:45,100
0,300 300,540 540,990 1020,1500 1500,1890
it shows up once,| but
|但如果你做了两次，

1679
00:51:45,130 --> 00:51:46,720
0,240 240,390 390,720 930,1380 1380,1590
you do it twice,| because
|因为有些事情失败了

1680
00:51:46,720 --> 00:51:48,310
0,390 390,1020 1080,1260 1260,1470 1470,1590
something failed| and now you
|现在你得到的是1a1，

1681
00:51:48,310 --> 00:51:49,900
0,300 330,510 510,930 930,990 990,1590
have {a,,1 -} {a,,1 -},|
|

1682
00:51:50,110 --> 00:51:51,010
0,210 210,360 360,690 690,780 780,900
so your {a,count} is going
所以你的a数是错的。

1683
00:51:51,010 --> 00:51:52,260
0,90 90,210 210,900
to be wrong.|
|

1684
00:51:52,370 --> 00:51:55,240
0,960 1050,1350 1350,1470 1470,2310
How, yeah I'm confused.|
怎么回事，是的，我很困惑。|

1685
00:51:55,240 --> 00:51:57,760
0,390 390,1020 1920,2250 2250,2370 2370,2520
Yes, right, how do they
是的，对，它们是怎么工作的，

1686
00:51:57,760 --> 00:51:58,870
0,360 360,450 450,690 690,900 900,1110
work,| it seems like if
|好像如果你什么都不做，

1687
00:51:58,870 --> 00:52:00,040
0,90 90,270 270,390 390,840 840,1170
you don't do anything,| then
|那么这真的是非常不方便，

1688
00:52:00,040 --> 00:52:01,810
0,210 210,330 330,720 720,1170 1170,1770
this is really highly inconvenient,|
|

1689
00:52:02,140 --> 00:52:03,820
0,240 240,810 810,1230 1230,1560 1560,1680
where {it,actually} returns to the
它实际返回到应用程序的位置，将计算错误的结果。

1690
00:52:03,820 --> 00:52:05,170
0,420 420,750 750,1020 1020,1110 1110,1350
application, will compute the wrong

1691
00:52:05,170 --> 00:52:06,140
0,510
result.|
|

1692
00:52:07,230 --> 00:52:11,280
0,1890 1890,2130 2130,3030 3510,3870 3870,4050
{They,said} use checksums and a
他们说使用校验和和唯一的ID来检查，你知道每一次，每一条记录都只有一次。

1693
00:52:11,280 --> 00:52:13,080
0,270 270,780 780,930 930,1530 1560,1800
unique IDs to check, you

1694
00:52:13,080 --> 00:52:16,760
0,720 1020,1860 2370,3060
know every {}

1695
00:52:16,790 --> 00:52:18,410
0,630 630,900 900,1230 1230,1470 1470,1620
yeah, every record was like

1696
00:52:18,410 --> 00:52:19,740
0,150 150,660
{} once.|
|

1697
00:52:20,080 --> 00:52:22,570
0,1380 1410,1950 1950,2070 2070,2220 2220,2490
Additionally, when you do record
此外，当您记录附加内容时，

1698
00:52:22,570 --> 00:52:24,760
0,570 570,1020 1140,1920 1920,2040 2040,2190
appends,| the response which has
|从主服务器返回给客户端的响应，

1699
00:52:24,760 --> 00:52:25,990
0,420 420,660 660,750 750,1110 1110,1230
returned from the primary to

1700
00:52:25,990 --> 00:52:27,490
0,90 90,690 690,1050 1050,1260 1260,1500
the client,| gives you the
|为您提供文件的偏移量，

1701
00:52:27,490 --> 00:52:29,980
0,720 780,1380 1380,1890 1920,2100 2100,2490
offset {} into the file,|
|

1702
00:52:29,980 --> 00:52:31,390
0,540 540,720 720,930 930,1080 1080,1410
where your data was actually
您的数据实际写入的位置

1703
00:52:31,390 --> 00:52:32,380
0,330 330,570 570,690 690,900 900,990
written| and the rest of
|而其余的部分则被认为是未定义的。

1704
00:52:32,380 --> 00:52:33,610
0,90 90,240 240,780 780,930 930,1230
it is assumed to be

1705
00:52:33,610 --> 00:52:35,980
0,300 330,1020 1200,1890
like undefined. {}|
|

1706
00:52:36,740 --> 00:52:37,730
0,300 300,690 690,780 780,930 930,990
Yeah, that I think the
是的，我认为这里正确的关键一点是

1707
00:52:37,730 --> 00:52:38,570
0,120 120,360 360,540 540,750 750,840
key point here correct is|
|

1708
00:52:38,570 --> 00:52:40,280
0,540 540,960 960,1020 1020,1470 1470,1710
like basically the application doesn't
就像基本上应用程序不直接与文件系统交互一样，

1709
00:52:40,280 --> 00:52:41,960
0,390 390,480 480,540 540,960 960,1680
interact with the {file,system} directly,|
|

1710
00:52:41,960 --> 00:52:43,520
0,420 420,600 600,930 930,1440 1440,1560
interact for some library,| in
与某些库交互，|在图书馆里，基本上如果你写10条记录，

1711
00:52:43,520 --> 00:52:44,930
0,90 90,480 480,990 990,1260 1260,1410
the library, basically if you

1712
00:52:44,930 --> 00:52:46,550
0,180 180,240 240,480 480,1050 1410,1620
write {} 10 records,| {}
|图书馆在里面放了一个身份证

1713
00:52:46,550 --> 00:52:47,960
0,120 120,540 570,930 930,1020 1020,1410
the library sticks an id

1714
00:52:47,960 --> 00:52:49,640
0,120 120,360 720,1080 1080,1530 1530,1680
in it| and so I
|所以我也使用图书馆来阅读这些记录

1715
00:52:49,640 --> 00:52:50,870
0,240 240,690 690,780 780,1080 1080,1230
also use the library to

1716
00:52:50,870 --> 00:52:52,610
0,390 420,780 780,1260 1260,1620 1620,1740
read these records| and so
|因此，如果您看到具有相同ID的记录，则可以跳过第二个记录。

1717
00:52:52,610 --> 00:52:53,360
0,90 90,210 210,420 420,480 480,750
if you see a record

1718
00:52:53,360 --> 00:52:54,470
0,120 120,180 180,420 420,1020 1020,1110
with the same id, {you,know}

1719
00:52:54,470 --> 00:52:55,780
0,270 270,330 330,600 600,870
skip the second one.|
|

1720
00:52:55,780 --> 00:52:57,100
0,480 480,630 630,870 870,1080 1080,1320
Because you know it's been
因为你知道这显然是同一件事。

1721
00:52:57,100 --> 00:52:58,620
0,360 360,450 450,690 690,930
clearly the same one.|
|

1722
00:52:58,940 --> 00:52:59,750
0,330 330,420 420,540 540,660 660,810
And you know they have
你知道他们有双倍的，一个额外的东西，用于检查和，以确保记录不会被篡改，

1723
00:52:59,750 --> 00:53:00,980
0,480 480,660 660,930 930,1110 1110,1230
double, an extra thing in

1724
00:53:00,980 --> 00:53:02,000
0,240 240,390 390,600 600,930 930,1020
there for {checksums -} to

1725
00:53:02,000 --> 00:53:03,440
0,180 180,600 600,870 870,1170 1170,1440
make sure the record didn't

1726
00:53:03,440 --> 00:53:06,230
0,120 120,690 930,1500 1500,1920 1980,2790
get garbled,| {} and basically
|基本上是为了检测字节中的变化，

1727
00:53:06,230 --> 00:53:09,560
0,120 120,720 720,1530 2700,3210 3210,3330
to detect {} change in

1728
00:53:09,560 --> 00:53:10,730
0,60 60,360 360,510 510,600 600,1170
the bytes,| but you know
|但你知道，本我基本上会帮助他们做出决定，

1729
00:53:10,730 --> 00:53:12,080
0,150 150,570 570,930 930,1200 1200,1350
the id basically helps them

1730
00:53:12,080 --> 00:53:14,150
0,120 120,630 990,1290 1290,1440 1500,2070
to decide,| { -} allows
|允许图书馆决定，嗯，这是相同的记录，

1731
00:53:14,150 --> 00:53:15,380
0,90 90,480 480,570 570,960 960,1230
the library to decide, well

1732
00:53:15,380 --> 00:53:16,310
0,180 180,270 270,330 330,570 570,930
this is the same record,|
|

1733
00:53:16,340 --> 00:53:17,300
0,300 300,510 510,690 690,900 900,960
I'm not gonna {give,it} to
我不会把它交给申请者，否则申请者不需要处理它。

1734
00:53:17,300 --> 00:53:18,360
0,120 120,630
the application,

1735
00:53:18,860 --> 00:53:19,910
0,240 240,330 330,810 810,960 960,1050
or the applications {doesn't,need} to

1736
00:53:19,910 --> 00:53:20,980
0,360 360,540
process it.|
|

1737
00:53:21,520 --> 00:53:22,820
0,840
Okay?|
好吧?|

1738
00:53:23,390 --> 00:53:25,460
0,960 960,1350 1350,1470 1470,1800 1800,2070
My question is instead of
我的问题是，与其重写每个副本，

1739
00:53:25,730 --> 00:53:27,680
0,780 780,990 990,1200 1200,1770 1770,1950
rewriting to every replica,| wouldn't
|记住哪些复制失败不是更好吗

1740
00:53:27,680 --> 00:53:28,640
0,90 90,210 210,450 450,600 600,960
it be better to remember

1741
00:53:28,640 --> 00:53:31,370
0,540 780,1470 1470,1950 2430,2610 2610,2730
which replicates failing| and to
|并停止，直到它可以被写入到那个。

1742
00:53:31,370 --> 00:53:32,750
0,360 360,930 960,1110 1110,1260 1260,1380
stop until it can be

1743
00:53:32,750 --> 00:53:34,260
0,390 390,540 540,720 720,990
written to that one.|
|

1744
00:53:34,620 --> 00:53:35,610
0,330 330,690 690,720 720,900 900,990
Yeah, there's a bunch of
是的，有一堆不同的设计，

1745
00:53:35,610 --> 00:53:37,470
0,240 240,540 540,930 930,1440 1440,1860
different designs possible,| when let's
|当我们稍后再回来时，

1746
00:53:37,470 --> 00:53:40,410
0,300 300,660 690,1170 1260,1830 2280,2940
return to later, { -}|
|

1747
00:53:40,410 --> 00:53:42,600
0,480 1260,1320 1320,1980 1980,2010 2010,2190
in you know I think
我认为他们这样做的一个原因是

1748
00:53:42,600 --> 00:53:44,010
0,240 240,630 630,900 900,1260 1260,1410
one reason that they do

1749
00:53:44,010 --> 00:53:44,850
0,180 180,330 330,540 540,660 660,840
this this way is| like
|比如，如果他们把暂时的失败，

1750
00:53:44,850 --> 00:53:46,500
0,150 150,390 390,630 630,1050 1110,1650
if they're putting a temporary

1751
00:53:46,500 --> 00:53:47,910
0,420 420,570 570,600 600,870 870,1410
failure,| like a network disconnection
|就像网络断开或任何你知道的租约一样，写入将成功，它们将继续。

1752
00:53:47,910 --> 00:53:48,810
0,30 30,480 480,570 570,690 690,900
or whatever you know the

1753
00:53:48,810 --> 00:53:49,920
0,270 270,360 360,600 600,690 690,1110
lease the write will succeed

1754
00:53:49,920 --> 00:53:51,180
0,90 90,150 150,270 270,750
and they will continue.|
|

1755
00:53:51,380 --> 00:53:52,280
0,270 270,510 510,690 690,750 750,900
And just have to be
并且只需要进行任何重新配置，

1756
00:53:52,280 --> 00:53:53,900
0,240 240,1230 1230,1350 1350,1500 1500,1620
any reconfiguration,| there has to
|什么都不能做，你知道的，写作可以继续下去，对吧。

1757
00:53:53,900 --> 00:53:55,400
0,240 240,600 600,720 720,1200 1260,1500
be nothing, you know and

1758
00:53:55,400 --> 00:53:56,390
0,120 120,360 360,480 480,750 780,990
the write can just keep

1759
00:53:56,390 --> 00:53:57,300
0,300
going,

1760
00:53:57,960 --> 00:54:00,060
0,450 510,720 720,1200 1290,2010 2010,2100
right.| Yeah, so {the,writers -}
|是啊，所以编剧必须失败。

1761
00:54:00,060 --> 00:54:01,200
0,150 150,240 240,570
have to fail.|
|

1762
00:54:02,630 --> 00:54:03,700
0,540
Okay.|
好吧。|

1763
00:54:03,820 --> 00:54:04,840
0,210 240,570 570,780 780,810 810,1020
It's {} just a quick
总的来说，这只是一个简短的问题，

1764
00:54:04,840 --> 00:54:07,930
0,390 390,570 570,1140 1560,2430 2730,3090
question in general,| the {}
|所有这些服务器都是可信的，对，没有。

1765
00:54:07,930 --> 00:54:09,340
0,210 210,270 270,510 510,990 990,1410
all of these servers are

1766
00:54:09,400 --> 00:54:12,340
0,720 750,1080 1110,1680 1680,1770 1800,2940
trusted, right, there's no.| Yes,
|是的，当然，这实际上是重要的一点，

1767
00:54:12,370 --> 00:54:15,640
0,960 1380,1950 1980,2430 2430,2790 2790,3270
absolutely, {this,is,actually} important {point -},|
|

1768
00:54:15,640 --> 00:54:16,360
0,90 90,300 300,510 510,600 600,720
{this,is} not like you know
这不像您了解您的Linux文件系统，

1769
00:54:16,360 --> 00:54:17,710
0,210 210,480 480,750 750,1080 1080,1350
your Linux file system,| where
|这里有权限和访问控制写入以及诸如此类的东西。

1770
00:54:17,710 --> 00:54:19,960
0,240 240,960 960,1350 1350,1860 1860,2250
there's permissions and access control

1771
00:54:19,960 --> 00:54:20,950
0,390 390,600 600,750 750,870 870,990
writes and all that kind

1772
00:54:20,950 --> 00:54:21,820
0,60 60,450
of stuff.|
|

1773
00:54:22,180 --> 00:54:23,290
0,360 360,510 510,630 630,960 960,1110
{} If the servers are
如果服务器是完全可信的，

1774
00:54:23,290 --> 00:54:25,030
0,450 450,1020 1230,1350 1350,1710 1710,1740
completely trusted,| the clients are
|客户是可信的，主控是可信的，

1775
00:54:25,030 --> 00:54:26,680
0,510 510,570 570,1020 1020,1560 1560,1650
trusted, the masters trusted,| the
|谷歌写的软件是可信的，整个事情都是可信的。

1776
00:54:26,680 --> 00:54:27,880
0,330 330,660 660,810 810,1110 1110,1200
software written by Google is

1777
00:54:27,880 --> 00:54:28,930
0,510 510,600 600,840 840,990 990,1050
trusted, the whole thing is

1778
00:54:28,930 --> 00:54:29,960
0,420
trusted.|
|

1779
00:54:31,440 --> 00:54:32,730
0,210 210,300 300,420 420,840 840,1290
Right, {this,is} your complete internal
对，这是您的完整内部文件系统。

1780
00:54:32,730 --> 00:54:33,940
0,240 240,630
file system.|
|

1781
00:54:34,220 --> 00:54:35,210
0,120 120,360 360,540 540,690 690,990
In fact, it's {sort,of} cool,|
事实上，这是一种很酷的感觉，|

1782
00:54:35,210 --> 00:54:36,290
0,360 360,660 660,900 900,1020 1020,1080
it's like {a,little,bit} may be
我们甚至不知道这个文件系统的这么多细节，这可能有点令人惊讶，

1783
00:54:36,290 --> 00:54:37,220
0,420 420,510 510,570 570,750 750,930
surprising that we {don't,even} know

1784
00:54:37,220 --> 00:54:38,690
0,240 240,390 390,960 960,1200 1200,1470
about this {file,system} {in,such} amout

1785
00:54:38,690 --> 00:54:41,660
0,450 480,870 870,1170 1350,1740 1740,2970
detail,| because {it's,only,used} inside Google|
|因为它只在谷歌内部使用|

1786
00:54:41,660 --> 00:54:42,410
0,180 180,420 420,480 480,540 540,750
and one of the cool
其中一件很酷的事情是

1787
00:54:42,410 --> 00:54:43,580
0,270 270,420 420,600 600,870 870,1170
things is that| you know
|你知道，有一段时间，他们仍然在这样做，

1788
00:54:44,230 --> 00:54:45,520
0,270 270,330 330,720 720,1050 1050,1290
period of time and still

1789
00:54:45,520 --> 00:54:47,170
0,120 120,570 720,1260 1260,1410 1410,1650
they do,| {} they wrote
|他们撰写了论文，并实际描述了这些系统是如何工作的

1790
00:54:47,170 --> 00:54:48,580
0,150 150,240 240,660 660,960 960,1410
up the papers and describing

1791
00:54:48,580 --> 00:54:49,840
0,240 240,360 360,510 510,870 870,1260
actually how these systems work|
|

1792
00:54:49,870 --> 00:54:51,490
0,210 210,480 480,720 720,960 960,1620
and there's one reason we
我们知道这一点只有一个原因，

1793
00:54:51,490 --> 00:54:53,800
0,180 180,480 960,1110 1110,2100 2100,2310
know that,| {it's -} actually
|事实上，他们这样做是非常酷的。

1794
00:54:53,800 --> 00:54:55,360
0,510 510,900 990,1230 1230,1440 1440,1560
extremely cool, {} that they

1795
00:54:55,360 --> 00:54:56,260
0,180 180,420
did that.|
|

1796
00:54:59,110 --> 00:55:00,180
0,540
Okay.|
好吧。|

1797
00:55:00,480 --> 00:55:01,660
0,630

1798
00:55:01,660 --> 00:55:02,380
0,240 240,390 390,510 510,600 600,720
So okay, so we now
好了，我们现在了解了读是如何工作的，什么是写工作，

1799
00:55:02,380 --> 00:55:04,300
0,390 390,510 510,750 750,1200 1200,1920
understand how read works, what

1800
00:55:04,300 --> 00:55:05,410
0,240 240,690 690,810 810,900 900,1110
write works,| you know there's
|你知道有一些有趣的行为，

1801
00:55:05,410 --> 00:55:08,110
0,180 180,330 330,510 720,1320 1320,2700
some sort of interesting {}

1802
00:55:08,140 --> 00:55:09,580
0,630 990,1110 1110,1230 1230,1290 1290,1440
behaviors,| I want to talk
|我想更多地谈谈一致性，对吗？

1803
00:55:09,580 --> 00:55:10,570
0,30 30,180 180,300 300,510 510,990
a little bit more about

1804
00:55:10,570 --> 00:55:11,800
0,540 540,780 780,870 870,1020 1020,1230
consistency, correct| and that really
|这真的要归结为你知道在你添加了

1805
00:55:11,800 --> 00:55:14,230
0,180 180,480 480,870 1230,1890 1890,2430
comes down to {} you

1806
00:55:14,920 --> 00:55:15,910
0,90 90,600 600,750 750,810 810,990
know what {} a read

1807
00:55:15,910 --> 00:55:18,130
0,510 510,1380 1380,1470 1470,1620 1620,2220
observe after you did append|
|

1808
00:55:18,370 --> 00:55:21,310
0,660 1110,1260 1260,1620 1620,2160 2250,2940
and the homework question {}
在这之后，家庭作业的问题真的变得很重要了

1809
00:55:21,340 --> 00:55:22,360
0,300 300,450 450,570 570,930 930,1020
really got after this| and
|我现在想要做的是快速休息一下，比如五分钟

1810
00:55:22,360 --> 00:55:22,960
0,180 180,240 240,390 390,510 510,600
what I would like to

1811
00:55:22,960 --> 00:55:23,800
0,180 180,480 480,600 600,720 720,840
do now is to take

1812
00:55:23,800 --> 00:55:25,300
0,240 300,810 810,1050 1050,1350 1350,1500
a quick break out, like

1813
00:55:25,300 --> 00:55:27,160
0,240 240,780 960,1590 1590,1710 1710,1860
five minutes| and so you
|所以你可以讨论你知道这个问题的答案

1814
00:55:27,160 --> 00:55:29,140
0,90 90,630 630,690 690,1830 1860,1980
can {discuss -} {you,know} the

1815
00:55:29,140 --> 00:55:30,520
0,210 210,330 330,480 480,1080 1200,1380
answer to this question| and
|然后回来，更详细地谈一谈一致性。

1816
00:55:30,520 --> 00:55:32,200
0,120 120,210 210,750 750,1440 1470,1680
then come back and talk

1817
00:55:32,200 --> 00:55:32,740
0,60 60,210 210,300 300,480 480,540
a little bit more in

1818
00:55:32,740 --> 00:55:34,020
0,300 300,450 450,1020
detail about consistency.|
|

1819
00:55:34,220 --> 00:55:35,360
0,630
Okay?|
好吧?|

1820
00:55:36,370 --> 00:55:37,660
0,270 270,750
I'm gonna
我要做[]。

1821
00:55:39,020 --> 00:55:40,220
0,660
{}

1822
00:55:40,510 --> 00:55:42,640
0,840 870,1560
make [].|
|

1823
00:55:43,160 --> 00:55:44,220
0,480
Okay,
好了，大家退后。

1824
00:55:44,340 --> 00:55:45,800
0,390 390,870
everybody back.|
|

1825
00:55:46,110 --> 00:55:47,670
0,330 330,420 420,570 570,900 1230,1560
Can everybody here me, double
能不能请大家给我复查一下。

1826
00:55:47,670 --> 00:55:50,310
0,450 900,1230 1260,1650 1650,2010 2010,2640
checking.| Yeah, hey professor question,|
|是啊，嘿教授提问，|

1827
00:55:50,310 --> 00:55:51,150
0,150 150,240 240,330 330,570 570,840
can you go back to
你能带着滑梯回到幻灯片上吗，

1828
00:55:51,150 --> 00:55:54,040
0,120 120,870 1170,1470 1470,2340
the slide with the,|
|

1829
00:55:54,580 --> 00:55:56,050
0,750 750,930 930,1200 1200,1380 1380,1470
when we talked about the
当我们在这里谈到写幻灯片时，

1830
00:55:56,050 --> 00:55:57,250
0,240 240,450 510,900 930,1080 1080,1200
write slide here,| so you
|就像你提到的，主服务器通过版本号响应客户端，

1831
00:55:57,250 --> 00:55:58,560
0,630
mentioned,

1832
00:55:58,560 --> 00:55:59,790
0,120 120,570 570,1020 1020,1110 1110,1230
the master responds to the

1833
00:55:59,790 --> 00:56:01,230
0,360 360,450 450,630 630,960 960,1440
client through the version number,|
|

1834
00:56:02,780 --> 00:56:03,950
0,660 660,780 780,990 990,1080 1080,1170
and if that is the
如果这是关键，

1835
00:56:03,950 --> 00:56:05,870
0,330 330,630 630,810 810,1170 1170,1920
key,| then is it possible,
|那有没有可能，有没有可能，

1836
00:56:06,020 --> 00:56:08,000
0,360 360,450 450,630 630,1350
is it even possible,|
|

1837
00:56:08,120 --> 00:56:09,500
0,630 690,990 990,1140 1140,1230 1230,1380
wouldn't even have to read
甚至不需要像阅读过时的数据一样阅读，

1838
00:56:09,500 --> 00:56:10,850
0,150 150,240 240,480 480,720 720,1350
like a stale data,| because
|因为客户端具有版本号而块服务器没有版本号，

1839
00:56:10,850 --> 00:56:11,780
0,90 90,390 390,540 540,600 600,930
the client has a version

1840
00:56:11,780 --> 00:56:13,010
0,360 360,570 570,660 660,870 870,1230
number and the chunk servers

1841
00:56:13,010 --> 00:56:14,480
0,240 240,330 330,630 630,1020 1320,1470
without the version number,| so
|这样他们就可以比较这些，

1842
00:56:14,480 --> 00:56:15,890
0,90 90,240 240,480 480,900 900,1410
they can just compare those,|
|

1843
00:56:16,070 --> 00:56:17,330
0,180 180,300 300,510 510,810 810,1260
if they don't match the
如果它们与客户端不匹配，块服务器可以只说我我稍后有一个[]输出，

1844
00:56:17,330 --> 00:56:19,760
0,330 330,630 870,2010 2010,2310 2310,2430
client, the chunk servers can

1845
00:56:19,760 --> 00:56:21,110
0,240 240,660 720,960 960,960 960,1350
just say I I have

1846
00:56:21,110 --> 00:56:22,310
0,90 90,330 330,540 540,780 780,1200
a [] later out,| so
|所以你不应该读这篇文章。

1847
00:56:23,210 --> 00:56:23,960
0,180 180,270 270,420 420,600 600,750
{} you should not read

1848
00:56:23,960 --> 00:56:24,920
0,450
this.|
|

1849
00:56:25,170 --> 00:56:26,670
0,270 270,480 480,1020 1080,1290 1290,1500
Okay, let's go,| yeah, let's
好的，我们走，|是的，让我们来看一下这个场景的更多细节。

1850
00:56:26,670 --> 00:56:27,300
0,150 150,270 270,420 420,630 630,630
go for this scenario a

1851
00:56:27,300 --> 00:56:28,320
0,240 240,360 360,480 480,900 900,1020
little bit more detail.| Let
|让我真的甩掉这扇窗户。

1852
00:56:28,320 --> 00:56:29,040
0,90 90,330 330,510 510,630 630,720
me actually get rid of

1853
00:56:29,040 --> 00:56:30,260
0,270 270,660
this window.|
|

1854
00:56:36,090 --> 00:56:37,440
0,240 240,540 570,960 960,1170 1170,1350
Okay, let's talk about it,|
好的，我们来谈谈吧，|

1855
00:56:37,440 --> 00:56:38,340
0,150 150,210 210,360 360,480 480,900
so I think this scenario
所以我认为我们正在讨论的这个场景，

1856
00:56:38,340 --> 00:56:39,810
0,90 90,390 390,780 1110,1260 1260,1470
we're talking about,| {} that
|这导致了一个问题，情况如下，

1857
00:56:39,810 --> 00:56:41,670
0,240 240,600 600,900 900,1410 1410,1860
leads into a problematic situation

1858
00:56:41,670 --> 00:56:43,710
0,90 90,780 960,1110 1110,1410 1410,2040
as follows,| we have primary,
|我们有主要的，我们有次要的

1859
00:56:43,710 --> 00:56:45,690
0,120 120,300 300,1020 1020,1230 1230,1980
we have secondary,| two secondary,
|两个中学，中学一年级，中学二年级，

1860
00:56:46,770 --> 00:56:49,980
0,450 450,930 930,1440 1440,2070 2430,3210
secondary one, secondary two, {}|
|

1861
00:56:49,980 --> 00:56:50,940
0,240 240,480 480,570 570,900 900,960
we have a client at
我们这边有个客户。

1862
00:56:50,940 --> 00:56:52,120
0,210 210,780
this side.|
|

1863
00:56:52,420 --> 00:56:54,460
0,510 510,660 660,840 840,1170 1170,2040
{} We have a primary
我们有一个主要的客户群，你知道，它回来了，就像一个版本号，比如说10。

1864
00:56:55,450 --> 00:56:57,130
0,480 480,930 930,1050 1050,1230 1230,1680
client reach you know it's

1865
00:56:57,130 --> 00:56:58,450
0,450 450,570 570,930 930,1140 1140,1320
back like {a,version} number say

1866
00:56:58,450 --> 00:56:59,520
0,510
10.|
|

1867
00:57:00,660 --> 00:57:01,740
0,570

1868
00:57:01,920 --> 00:57:03,320
0,810

1869
00:57:03,440 --> 00:57:07,010
0,570 990,1470 1470,1950 1950,2910 3060,3570
The, later on another a
后来，又有了一份主要遗嘱。

1870
00:57:07,220 --> 00:57:09,560
0,540 540,1110 1170,1800
primary will. {}|
|

1871
00:57:10,200 --> 00:57:11,340
0,600

1872
00:57:13,110 --> 00:57:14,360
0,750

1873
00:57:16,680 --> 00:57:18,480
0,330 330,480 480,690 690,1260 1290,1800
Okay, so {S2 -} get
好的，所以S2准备了一些服务器，

1874
00:57:18,480 --> 00:57:20,700
0,150 150,870 870,1260 1260,2100 2100,2220
some servers,| {} then at
|然后在某个时候，

1875
00:57:20,700 --> 00:57:23,280
0,150 150,510 510,900 2220,2400 2400,2580
some point, the,| so this
|因此，此信息被缓存在

1876
00:57:23,280 --> 00:57:26,610
0,420 420,510 510,1260 2430,2640 2640,3330
information is cached on {the,side}|
|

1877
00:57:26,610 --> 00:57:28,680
0,120 120,240 240,600 600,720 720,2070
you know, maybe you know
你知道，也许你知道次要的事情之一就是S2崩溃，

1878
00:57:29,010 --> 00:57:30,150
0,330 330,420 420,570 570,810 810,1140
one of the thing {}

1879
00:57:30,570 --> 00:57:31,800
0,540 540,630 630,780 780,960 960,1230
secondary is like {S2 -}

1880
00:57:31,800 --> 00:57:32,900
0,690
crashes,|
|

1881
00:57:32,900 --> 00:57:33,890
0,210 210,300 300,540 540,900 900,990
or at least appears to
或者至少看起来与网络断开。

1882
00:57:33,890 --> 00:57:35,960
0,360 630,1320 1320,1470 1470,1530 1530,2070
be disconnected from the network.|
|

1883
00:57:36,650 --> 00:57:38,060
0,210 210,450 450,690 690,930 960,1410
{} So what the master
所以主服务器要做的是递增版本号，

1884
00:57:38,060 --> 00:57:39,410
0,150 150,420 420,600 600,1020 1020,1350
will do is increment version

1885
00:57:39,410 --> 00:57:40,760
0,390 390,570 570,690 690,810 810,1350
numbers,| {you,know} go to 11
|你知道，转到11条消息11，

1886
00:57:42,050 --> 00:57:44,160
0,600 600,900 900,1380
messages {11 -},|
|

1887
00:57:44,160 --> 00:57:45,930
0,720 780,1350 1350,1410 1410,1500 1500,1770
{} then you know another
然后你就知道，另一个客户可能会过来，开始写信。

1888
00:57:45,930 --> 00:57:47,670
0,390 390,510 510,720 720,1290 1530,1740
client may come around and

1889
00:57:47,670 --> 00:57:49,200
0,300 300,870
start writing.|
|

1890
00:57:49,320 --> 00:57:50,940
0,510 510,810 810,1230 1230,1440 1440,1620
So we'll write a new
因此，我们将为该文件的s1和s2写入一个新值，

1891
00:57:50,940 --> 00:57:52,860
0,480 480,1440 1440,1620 1620,1830 1830,1920
value to {S1 -} and

1892
00:57:52,860 --> 00:57:54,870
0,150 150,630 1380,1560 1560,1650 1650,2010
{S2 -} for the file,|
|

1893
00:57:54,870 --> 00:57:55,740
0,120 120,240 240,480 480,660 660,870
so the chunk has now
所以块现在已经更新了，

1894
00:57:55,740 --> 00:57:57,000
0,150 150,600 600,780 780,1020 1020,1260
been updated,| so let's say
|我们假设原始版本号为10，现在这里是11，

1895
00:57:57,000 --> 00:57:59,190
0,420 420,840 840,1410 1830,2070 2070,2190
chunks original 10 same as

1896
00:57:59,190 --> 00:58:00,570
0,300 300,570 570,780 780,930 930,1380
version number, now it's {11,here

1897
00:58:00,720 --> 00:58:02,460
0,870
-},|
|

1898
00:58:02,460 --> 00:58:03,570
0,360 360,690 690,780 780,900 900,1110
{} but you know it's
但你知道，情况是这样的，即使主小学中学不能与中学二年级交谈，

1899
00:58:03,570 --> 00:58:04,860
0,60 60,360 360,840 840,1020 1020,1290
the case that even though

1900
00:58:04,860 --> 00:58:06,900
0,120 120,480 810,1200 1200,1620 1710,2040
the master primary secondary {couldn't,talk}

1901
00:58:06,900 --> 00:58:08,160
0,420 420,690 690,840 840,930 930,1260
secondary two,| but the second
|但是第二个客户端、第一个客户端仍然可以与第二个客户端对话

1902
00:58:08,160 --> 00:58:09,930
0,630 870,1170 1170,1470 1470,1560 1560,1770
client, first client could still

1903
00:58:09,930 --> 00:58:12,420
0,360 360,720 750,960 1140,1920 2130,2490
talk to the secondary| and
|它将读取与之匹配的版本号，

1904
00:58:12,420 --> 00:58:13,560
0,210 210,390 390,720 720,870 870,1140
it will read the version

1905
00:58:13,560 --> 00:58:15,510
0,270 270,780 810,1200 1200,1470 1470,1950
numbers match,| they're both 10,|
|他们都是10岁，|

1906
00:58:17,340 --> 00:58:19,140
0,330 330,420 420,630 630,1110 1140,1800
and it will read, {}
它会读到，它会发回10个，对吧，

1907
00:58:19,140 --> 00:58:21,990
0,210 210,390 390,600 600,1050 2550,2850
it'll send 10 back, right,|
|

1908
00:58:21,990 --> 00:58:23,010
0,180 180,510 510,660 660,720 720,1020
so you have a case
因此，您有一个写入已完成的案例，

1909
00:58:23,010 --> 00:58:24,840
0,480 660,780 780,1020 1020,1140 1140,1830
where the write has completed,|
|

1910
00:58:25,220 --> 00:58:26,990
0,300 300,930 930,1020 1020,1200 1200,1770
as acknowledged to be okay|
就像大家都知道的那样|

1911
00:58:27,260 --> 00:58:29,060
0,540 540,1140 1140,1350 1350,1470 1470,1800
and nevertheless there's a client
尽管如此，还是有一个客户实际上会读回一个陈旧的值。

1912
00:58:29,060 --> 00:58:29,990
0,150 150,390 390,510 510,840 840,930
that actually will read a

1913
00:58:29,990 --> 00:58:31,500
0,240 240,630 630,990
stale value back.|
|

1914
00:58:31,680 --> 00:58:33,030
0,240 240,480 480,720 720,810 810,1350
So, why doesn't the 11
那么，为什么11号不回到客户那里呢？

1915
00:58:33,030 --> 00:58:34,500
0,210 210,510 510,630 630,750 750,1470
go back to the client?|
|

1916
00:58:36,550 --> 00:58:39,180
0,1140 1170,1530 1530,2040
{} {The,first} client,|
第一个客户，|

1917
00:58:39,650 --> 00:58:40,490
0,150 150,390 390,510 510,750 750,840
the reason is because the
原因是因为第一客户端将其缓存了更长的时间段，

1918
00:58:40,490 --> 00:58:41,690
0,210 210,510 510,870 870,1020 1020,1200
first client caches it for

1919
00:58:41,690 --> 00:58:42,620
0,60 60,270 270,510 510,570 570,930
a longer period of time,|
|

1920
00:58:43,280 --> 00:58:44,330
0,180 180,330 330,600 600,780 780,1050
they don't actually have anything
他们实际上在协议中没有任何实际做到这一点的内容。

1921
00:58:44,330 --> 00:58:45,320
0,90 90,150 150,630 630,780 780,990
in the protocol that actually

1922
00:58:45,320 --> 00:58:46,320
0,210 210,480
does that.|
|

1923
00:58:50,060 --> 00:58:51,860
0,210 210,420 420,600 600,1080 1080,1800
So does the version increment
当系统尝试将更新推送到S2时，版本也会增加

1924
00:58:51,860 --> 00:58:54,410
0,660 960,1650 2040,2220 2220,2490 2490,2550
when the {} when the

1925
00:58:54,410 --> 00:58:56,030
0,390 390,810 810,930 930,1470 1470,1620
system tries to push an

1926
00:58:56,030 --> 00:58:57,560
0,480 480,600 600,840 840,1290 1290,1530
update to {S2 -}| and
|它不能，或者。

1927
00:58:57,560 --> 00:58:59,210
0,210 210,450 450,720 720,1050 1050,1650
it's not able to, or.|
|

1928
00:58:59,300 --> 00:59:01,640
0,360 360,660 660,1050 1050,1800 2130,2340
Version numbers only increment,| the
版本号只会递增，|版本号由主服务器维护，

1929
00:59:01,640 --> 00:59:02,630
0,270 270,450 450,510 510,900 900,990
version number is maintained by

1930
00:59:02,630 --> 00:59:04,340
0,90 90,690 690,1230 1230,1410 1410,1710
the master,| {} they only
|只有当您选择新的主节点时，它们才会增加，

1931
00:59:04,340 --> 00:59:05,750
0,420 420,630 630,990 1020,1380 1380,1410
increment when you select a

1932
00:59:05,750 --> 00:59:06,820
0,150 150,600
new primary,|
|

1933
00:59:12,910 --> 00:59:13,900
0,270 270,450 450,540 540,720 720,990
not when you do it,|
当你这样做的时候不会，|

1934
00:59:13,900 --> 00:59:15,070
0,300 300,630 630,840 840,1080 1080,1170
there's a there's also a
还有一个序列号，他们都在谈论，

1935
00:59:15,070 --> 00:59:16,240
0,390 390,660 660,780 780,900 900,1170
serial number, that they talk

1936
00:59:16,240 --> 00:59:17,860
0,420 780,1050 1050,1200 1200,1500 1500,1620
about,| but its different from
|但它与版本号不同，

1937
00:59:17,860 --> 00:59:18,880
0,60 60,300 300,600 630,840 840,1020
the version number,| that just
|只是为了让你知道写的是什么。

1938
00:59:18,880 --> 00:59:20,080
0,90 90,660 690,810 810,930 930,1200
to order you know the

1939
00:59:20,080 --> 00:59:21,040
0,510
writes.|
|

1940
00:59:22,670 --> 00:59:23,800
0,570
Okay?|
好吧?|

1941
00:59:23,920 --> 00:59:25,660
0,210 210,360 360,480 480,1050 1050,1740
How does the primary know
主设备如何知道它必须与哪个辅助设备进行检查，

1942
00:59:25,720 --> 00:59:26,890
0,270 270,660 660,840 840,1050 1050,1170
which {secondary } is it

1943
00:59:26,890 --> 00:59:28,450
0,180 180,270 270,540 540,840 990,1560
has to check with,| before
|在制作之前，在完成它之前，写成功。

1944
00:59:28,450 --> 00:59:30,040
0,600 690,990 990,1350 1350,1440 1440,1590
making, before completing it write

1945
00:59:30,040 --> 00:59:31,240
0,600
successfully.|
|

1946
00:59:31,360 --> 00:59:32,590
0,210 210,390 390,810 810,900 900,1230
{} The primary, the master
小学，老师告诉它，

1947
00:59:32,590 --> 00:59:33,780
0,270 270,510
tells it,|
|

1948
00:59:34,140 --> 00:59:35,820
0,390 390,600 600,660 660,1050 1050,1680
master tells the primary {you,know}
主服务器告诉主服务器您知道次要服务器需要更新。

1949
00:59:35,820 --> 00:59:36,480
0,210 210,360 360,480 480,600 600,660
{secondary -} you need to

1950
00:59:36,480 --> 00:59:37,460
0,420
update.|
|

1951
00:59:39,720 --> 00:59:40,950
0,240 240,420 420,630 630,690 690,1230
{} So when the master
因此，当主服务器基本上向主服务器发出租约时

1952
00:59:40,950 --> 00:59:42,420
0,450 450,870 870,960 960,1290 1290,1470
basically issues the lease to

1953
00:59:42,420 --> 00:59:44,160
0,120 120,660 780,1320 1350,1500 1500,1740
the primary| and if one
|如果当时有一个次要设备出了故障，

1954
00:59:44,160 --> 00:59:45,600
0,180 180,330 330,960 960,1110 1110,1440
of the secondaries is down

1955
00:59:45,600 --> 00:59:47,610
0,180 180,480 570,1110 1320,1620 1620,2010
at that moment,| does the
|主人是否认为这是一次失败，

1956
00:59:47,610 --> 00:59:48,990
0,450 450,750 750,900 900,960 960,1380
master consider this a failure,|
|

1957
00:59:48,990 --> 00:59:50,070
0,300 330,510 510,570 570,750 750,1080
or does it just update
或者它只是更新处于活动状态的服务器的版本号

1958
00:59:50,070 --> 00:59:51,630
0,60 60,630 690,1080 1080,1470 1470,1560
the version number for the

1959
00:59:51,630 --> 00:59:53,160
0,420 420,600 600,780 780,1230 1230,1530
servers that are alive| and
|而它只是忘记了另一个，

1960
00:59:53,160 --> 00:59:54,060
0,180 180,480
it just

1961
00:59:54,210 --> 00:59:55,350
0,390 390,690 690,780 780,960 960,1140
forget about the other one,|
|

1962
00:59:55,350 --> 00:59:56,130
0,330 330,450 450,570 570,630 630,780
because it's going to have
因为它无论如何都会有一个过时的版本号。

1963
00:59:56,130 --> 00:59:57,930
0,90 90,540 840,1140 1140,1380 1380,1800
an outdated version number anyway.|
|

1964
00:59:58,410 --> 01:00:00,690
0,1650 1650,1740 1740,2070 2070,2220 2220,2280
Yeah, the papers {is,a,little} bit
是的，这些文件确实有点[]，

1965
01:00:00,690 --> 01:00:02,790
0,420 420,900 900,1110 1110,1440 1470,2100
[] exactly,| how the recovery
|恢复部分是如何工作的重新配置的东西，

1966
01:00:02,790 --> 01:00:05,700
0,330 330,660 660,1410 1440,2610 2610,2910
part {} the reconfiguration stuff

1967
01:00:05,700 --> 01:00:08,040
0,720 930,1380 1380,1470 1470,1920 1920,2340
works,| but I imagine that
|但我想，基本上主音与P1，S1，S2的心跳是一致的，

1968
01:00:08,040 --> 01:00:10,050
0,480 480,1050 1080,1440 1440,1740 1740,2010
basically the primary actually does

1969
01:00:10,050 --> 01:00:11,370
0,570 570,780 780,960 960,1170 1170,1320
heartbeats with {P1 -} {S1

1970
01:00:11,370 --> 01:00:13,200
0,270 270,450 450,930 1260,1650 1650,1830
-} {S2 -},| {} it's
|它是点上的，所以S2使用那个站点

1971
01:00:13,200 --> 01:00:14,250
0,150 150,390 390,570 570,900 900,1050
on point, the site so

1972
01:00:14,250 --> 01:00:16,530
0,270 270,360 360,540 540,900 1170,2280
{S2 -} use that| and
|在这一点上，它将指向，主要的租约可能会到期。

1973
01:00:16,530 --> 01:00:18,300
0,750 750,930 930,1350 1350,1560 1560,1770
at that point {} it

1974
01:00:18,300 --> 01:00:19,740
0,210 210,630 630,900 900,1350 1350,1440
will point and {the,lease} the

1975
01:00:19,740 --> 01:00:21,600
0,420 420,840 840,1170 1170,1500
primary maybe runs out.|
|

1976
01:00:21,660 --> 01:00:22,650
0,330 330,480 480,630 630,720 720,990
{} And then it will
然后，它将创建一个新的主节点和一个S1

1977
01:00:22,650 --> 01:00:24,060
0,390 390,420 420,630 630,1230 1230,1410
create a new primary and

1978
01:00:24,060 --> 01:00:26,280
0,90 90,390 390,870 870,1500 1530,2220
a {S1 -}| and another
|另一个S，你知道，实际持有，或者可能只有S1，

1979
01:00:26,280 --> 01:00:27,660
0,420 420,510 510,780 780,1050 1050,1380
S you know actual hold

1980
01:00:27,660 --> 01:00:28,680
0,60 60,270 270,510 510,810 810,1020
you know, or maybe just

1981
01:00:28,680 --> 01:00:29,670
0,120 120,390 390,630 630,780 780,990
{S1 -},| because there's no,
|因为没有，没有额外的区块服务器

1982
01:00:29,670 --> 01:00:32,670
0,570 930,1860 1860,2250 2250,2490 2490,3000
{} no additional chunk server|
|

1983
01:00:32,850 --> 01:00:34,230
0,210 210,420 420,690 690,780 780,1380
and that forms the new
这就形成了该区块的新复制组。

1984
01:00:34,350 --> 01:00:35,910
0,690 690,900 900,1020 1020,1170 1170,1560
replica group for that chunk.|
|

1985
01:00:37,620 --> 01:00:39,690
0,660 750,990 990,1410 1410,1770 1770,2070
Also, the lease doesn't run
此外，租约基本上还没有到期。

1986
01:00:39,690 --> 01:00:42,060
0,240 240,600 630,1170 1860,2280 2280,2370
out yet, basically.| Well, the
|嗯，我们不能指定初选，

1987
01:00:42,060 --> 01:00:44,490
0,240 240,330 330,990 1050,2250 2250,2430
primary we can't appoint,| okay
|好的，这里有一些有趣的案例，

1988
01:00:44,490 --> 01:00:45,990
0,120 120,540 540,690 690,1050 1050,1500
so here's some interesting cases,|
|

1989
01:00:45,990 --> 01:00:47,520
0,180 180,450 570,930 1170,1380 1380,1530
let's see, so, {} you
让我想想，你们做的就是我想做的事，

1990
01:00:47,520 --> 01:00:48,420
0,180 180,210 210,360 360,720 720,900
guys are doing exactly the

1991
01:00:48,420 --> 01:00:50,250
0,150 150,240 240,600 690,1770 1770,1830
thing I want,| based on
|在这篇论文的基础上，你真正开始思考所有有问题的案例。

1992
01:00:50,250 --> 01:00:51,330
0,150 150,420 420,630 630,900 900,1080
this paper, which you really

1993
01:00:51,330 --> 01:00:52,440
0,240 240,540 540,810 810,1020 1020,1110
start thinking about all the

1994
01:00:52,440 --> 01:00:53,960
0,540 540,1140
problematic cases.|
|

1995
01:00:53,990 --> 01:00:55,040
0,270 270,390 390,510 510,930 930,1050
And this is exactly how
这正是你对一致性的看法，

1996
01:00:55,040 --> 01:00:56,450
0,90 90,240 240,450 450,1050 1080,1410
you think about consistency,| when
|当你开始考虑一致性时，

1997
01:00:56,450 --> 01:00:57,740
0,60 60,300 300,510 510,660 660,1290
you start thinking about consistency,|
|

1998
01:00:57,740 --> 01:00:59,240
0,90 90,330 330,630 660,1110 1110,1500
you need to consider all
您需要考虑所有可能的失败

1999
01:00:59,240 --> 01:01:01,880
0,450 450,990 1380,1800 1800,2190 2190,2640
possible failures| and argue whether
|并争论你是否知道这些失败会导致不一致。

2000
01:01:01,880 --> 01:01:03,020
0,90 90,360 360,600 600,960 960,1140
you know those failures lead

2001
01:01:03,020 --> 01:01:04,460
0,120 120,1050
to inconsistencies.|
|

2002
01:01:04,700 --> 01:01:06,920
0,480 630,1020 1050,1290 1290,1830 1830,2220
{} So, one thing let's
所以，有一件事我们来谈谈这个案例，

2003
01:01:06,920 --> 01:01:08,210
0,150 150,360 360,480 480,690 690,1290
talk about this one case,|
|

2004
01:01:08,240 --> 01:01:09,530
0,270 270,450 450,570 570,630 630,1290
where we've got a master,
哪里有大师，哪里就有初选。

2005
01:01:09,560 --> 01:01:11,560
0,360 360,510 510,570 570,1200
we've got a primary.|
|

2006
01:01:11,560 --> 01:01:14,860
0,270 270,480 480,1020 1020,1950 2280,3300
And let's say the primary
让我们假设主站中的主站或断开连接，

2007
01:01:14,860 --> 01:01:16,060
0,150 150,210 210,720 720,990 990,1200
in the master or get

2008
01:01:16,060 --> 01:01:17,590
0,630 690,1050 1050,1230 1230,1320 1320,1530
disconnected,| actually let me draw
|实际上，让我以稍微不同的方式来描绘这幅图，

2009
01:01:17,590 --> 01:01:19,480
0,90 90,360 360,660 660,1290
the picture slightly differently,|
|

2010
01:01:21,170 --> 01:01:21,920
0,120 120,270 270,600 600,660 660,750
{ -} master in the
师父在中间。

2011
01:01:21,920 --> 01:01:22,960
0,480
middle.|
|

2012
01:01:23,920 --> 01:01:25,630
0,270 270,390 390,1200 1200,1560 1560,1710
And we got server, we
我们有服务器，我们这里有服务器，

2013
01:01:25,630 --> 01:01:27,220
0,240 240,510 510,1050
got server here,|
|

2014
01:01:27,500 --> 01:01:29,060
0,210 210,420 420,990 990,1200 1200,1560
{you,know} {S1 -}, {S2 -},|
你知道S1，S2，|

2015
01:01:29,060 --> 01:01:29,900
0,120 120,300 300,600 600,690 690,840
and let's {say,S2 -} is
假设S2是主要的，

2016
01:01:29,900 --> 01:01:31,080
0,90 90,600
the primary,|
|

2017
01:01:32,310 --> 01:01:33,900
0,690 690,1020 1020,1380 1380,1500 1500,1590
{} and so you know
因此，无论您可能会与其他服务器交谈，

2018
01:01:33,900 --> 01:01:35,370
0,390 390,540 540,690 690,1050 1050,1470
whatever you may talk to

2019
01:01:35,400 --> 01:01:37,200
0,210 210,390 390,1050 1140,1470 1470,1800
some other servers out there,|
|

2020
01:01:38,540 --> 01:01:40,580
0,540 540,930 930,1050 1050,1500 1770,2040
perhaps even {S1 -} is
也许连S1都是，是这场初选的次要之一。

2021
01:01:40,580 --> 01:01:41,900
0,390 390,750 750,1050 1050,1230 1230,1320
the, {} is one of

2022
01:01:41,900 --> 01:01:43,160
0,60 60,510 510,630 630,750 750,1260
the secondary for this primary.|
|

2023
01:01:43,930 --> 01:01:45,580
0,600 930,1110 1110,1200 1200,1350 1350,1650
So let's say a network
因此，让我们假设网络请愿书，

2024
01:01:45,580 --> 01:01:47,440
0,450 690,990 990,1320 1320,1680 1680,1860
petition,| so the master sends
|所以主控发送消息，你知道心跳消息，没有得到响应。

2025
01:01:47,440 --> 01:01:49,390
0,630 630,720 720,930 930,1320 1320,1950
messages, you know heartbeat messages,

2026
01:01:49,390 --> 01:01:51,260
0,270 270,420 420,480 480,1170
doesn't get a response.|
|

2027
01:01:51,550 --> 01:01:52,960
0,870

2028
01:01:53,270 --> 01:01:55,010
0,540 540,750 750,840 840,1470 1470,1740
When can the master {point,to}
主服务器何时可以指向新的主服务器。

2029
01:01:55,010 --> 01:01:56,240
0,30 30,180 180,630
a new primary.|
|

2030
01:01:59,270 --> 01:02:00,740
0,300 300,420 420,780 780,930 930,1470
When the lease is over
S2的租约什么时候到期？

2031
01:02:00,770 --> 01:02:02,180
0,240 240,420 420,840
for {S2 -}?|
|

2032
01:02:04,060 --> 01:02:08,200
0,450 750,1050 1050,1440 1440,3390 3540,4140
Yeah, right, because a primary
是啊，没错，因为初选要等一等，

2033
01:02:08,200 --> 01:02:08,890
0,150 150,270 270,540 540,630 630,690
has to wait,| but the
|但房主必须等到租约到期。

2034
01:02:08,890 --> 01:02:09,940
0,300 300,390 390,510 510,840 840,1050
master has to wait until

2035
01:02:09,940 --> 01:02:11,580
0,120 120,360 360,510 510,1110
the lease has expired.|
|

2036
01:02:11,610 --> 01:02:13,350
0,420 420,690 690,1110 1110,1260 1260,1740
{} Because if the lease
因为如果租约没有到期，

2037
01:02:13,560 --> 01:02:15,300
0,240 240,480 480,720 720,1350 1530,1740
{} was not expired,| then
|那么也许我们同时有两个初选，对吧，

2038
01:02:15,300 --> 01:02:16,680
0,360 360,540 540,750 750,930 930,1380
maybe we have two primaries

2039
01:02:16,680 --> 01:02:18,030
0,60 60,150 150,360 360,780 900,1350
at the same time, right,|
|

2040
01:02:18,800 --> 01:02:20,780
0,330 330,600 600,690 690,1290 1680,1980
{P1 -} and P2 {}
P1和P2同时停留在

2041
01:02:20,780 --> 01:02:21,710
0,270 270,600 600,660 660,720 720,930
are staying at the same

2042
01:02:21,710 --> 01:02:22,910
0,390 390,660 720,930 930,1080 1080,1200
time| and would that be
|那会不会很糟糕？

2043
01:02:22,910 --> 01:02:23,960
0,480
bad?|
|

2044
01:02:26,540 --> 01:02:28,880
0,510 510,1350 1350,1620 1620,1710 1710,2340
{} Yeah, then I think,|
是啊，然后我想，|

2045
01:02:30,180 --> 01:02:32,580
0,480 480,750 780,990 990,1590 2040,2400
wait would would clients, clients
等待客户，客户将不知道送到哪里

2046
01:02:32,580 --> 01:02:33,660
0,270 270,390 390,540 540,630 630,1080
wouldn't know where to send

2047
01:02:33,660 --> 01:02:34,860
0,510 510,600 600,660 660,960 960,1200
to| and the master wouldn't
|大师不会知道哪一个是主要的，对吧。

2048
01:02:34,860 --> 01:02:36,060
0,150 150,390 390,570 570,720 720,1200
know which one is primary,

2049
01:02:36,060 --> 01:02:38,520
0,420 450,810 1650,1860 1860,2100 2100,2460
right.| Well, {presumably,some,clients} still talking
|嗯，大概有些客户还在跟这个初选对话，对吧，

2050
01:02:38,520 --> 01:02:40,260
0,90 90,270 270,810 840,1230
to this primary, right,|
|

2051
01:02:40,410 --> 01:02:41,610
0,630 630,720 720,870 870,930 930,1200
while you might be talking
当你可能在和初选对话的时候，

2052
01:02:41,610 --> 01:02:43,140
0,90 90,300 300,870
to this primary,|
|

2053
01:02:43,200 --> 01:02:43,980
0,180 180,300 300,630 630,720 720,780
in a primary for the
在同一块的主数据块中。

2054
01:02:43,980 --> 01:02:45,220
0,240 240,690
same chunk.|
|

2055
01:02:47,820 --> 01:02:48,660
0,180 180,330 330,420 420,600 600,840
I think you get very
我觉得你点的东西很奇怪，对吧，

2056
01:02:48,660 --> 01:02:50,640
0,390 390,900 900,1200 1290,1770 1770,1980
bizarre ordering, right,| where like
|就像一些写操作会丢失一样，

2057
01:02:50,640 --> 01:02:51,990
0,180 180,420 420,510 510,690 690,1350
some writes will get lost,|
|

2058
01:02:51,990 --> 01:02:52,950
0,120 120,480 480,600 600,690 690,960
you know you know it
你知道你知道那会是一团糟。

2059
01:02:52,950 --> 01:02:54,380
0,270 270,390 390,450 450,960
would be a mess.|
|

2060
01:02:54,630 --> 01:02:55,470
0,240 240,420 420,540 540,780 780,840
It would be not a
它不会是一个本金，

2061
01:02:55,470 --> 01:02:57,360
0,600 600,750 750,1080 1080,1500 1500,1890
principal,| you know argument where
|你知道，论点，你知道，我们都在写发生顺序，一次写一个。

2062
01:02:57,360 --> 01:02:58,740
0,420 420,510 510,660 660,840 840,1380
one you know we're {all,writes}

2063
01:02:58,740 --> 01:03:00,480
0,480 480,1050 1170,1380 1380,1620 1620,1740
happening order and one at

2064
01:03:00,480 --> 01:03:01,440
0,60 60,420
a time.|
|

2065
01:03:03,900 --> 01:03:04,500
0,150 150,300 300,360 360,390 390,600
So this is a bad
所以这是一个糟糕的情况

2066
01:03:04,500 --> 01:03:06,120
0,480 480,810 810,990 990,1530 1530,1620
situation| and this situation is
|这种情况是可以避免的，比如大脑分裂综合症，

2067
01:03:06,120 --> 01:03:07,680
0,360 360,510 510,600 600,1020 1020,1560
avoided like the split brain

2068
01:03:07,680 --> 01:03:09,510
0,450 450,570 570,1020 1020,1380 1410,1830
syndrome,| is sometimes called split
|有时被称为大脑分裂综合症，

2069
01:03:09,510 --> 01:03:10,680
0,240 240,690 690,930 930,1020 1020,1170
brain syndrome,| where you end
|在那里，你最终会得到一个有两个主人的系统。

2070
01:03:10,680 --> 01:03:11,400
0,150 150,270 270,300 300,600 600,720
up with a system where

2071
01:03:11,400 --> 01:03:12,980
0,240 240,390 390,1110
have two masters.|
|

2072
01:03:12,980 --> 01:03:15,290
0,330 330,510 510,1230 1680,1950 1950,2310
And this is problem here
由于租约的缘故，这里避免了这个问题

2073
01:03:15,290 --> 01:03:17,000
0,480 480,750 750,1050 1050,1170 1170,1710
avoided, because of the lease|
|

2074
01:03:17,990 --> 01:03:19,370
0,360 360,480 480,840 840,1050 1050,1380
and the master will not
在第一个小学的租约完全到期之前，校长不会指定任何其他小学

2075
01:03:19,370 --> 01:03:21,440
0,360 360,960 1170,1440 1440,1830 1830,2070
appoint any other primary until

2076
01:03:21,440 --> 01:03:22,460
0,270 270,540 540,660 660,780 780,1020
the lease of the first

2077
01:03:22,460 --> 01:03:25,880
0,360 360,840 840,1440 1710,2370 2760,3420
primary absolutely has has expired|
|

2078
01:03:25,880 --> 01:03:26,870
0,180 180,270 270,600 600,870 870,990
and it knows even if
它知道，即使初选上升，但它无法达到，

2079
01:03:26,870 --> 01:03:27,950
0,90 90,480 480,750 750,900 900,1080
the primaries up, but not

2080
01:03:27,950 --> 01:03:29,180
0,570 570,720 720,960 960,1110 1110,1230
reachable to it,| but may
|但对其他客户来说可能是合理的，

2081
01:03:29,180 --> 01:03:30,530
0,150 150,450 450,570 570,720 720,1350
be reasonable to other clients,|
|

2082
01:03:30,590 --> 01:03:32,030
0,300 300,630 630,870 870,1260 1260,1440
that primary won't accept any
该主服务器将不再接受任何写入消息，

2083
01:03:32,030 --> 01:03:33,650
0,270 270,630 630,1050 1050,1380 1380,1620
write messages anymore,| because lease
|因为租约已经到期了。

2084
01:03:33,650 --> 01:03:34,760
0,180 180,750
has expired.|
|

2085
01:03:40,210 --> 01:03:41,520
0,120 120,240 240,360 360,750
Does that make sense?|
这说得通吗？|

2086
01:03:43,400 --> 01:03:44,420
0,270 270,420 420,510 510,720 720,1020
Okay, let me say one
好的，在结束之前让我再说一件事，

2087
01:03:44,420 --> 01:03:46,340
0,210 210,510 510,1080 1080,1560 1560,1920
more thing before wrapping up,|
|

2088
01:03:46,580 --> 01:03:48,920
0,1020 1020,1350 1350,1920 1920,2040 2040,2340
apologizes partly because you know,
道歉的部分原因是你知道，我有一些技术问题，

2089
01:03:49,430 --> 01:03:50,440
0,480
{}

2090
01:03:50,800 --> 01:03:52,510
0,120 120,210 210,330 330,960 990,1710
I had some technical problems,|
|

2091
01:03:52,510 --> 01:03:53,140
0,90 90,150 150,390 390,480 480,630
but I wanted to make
但我想再说一句

2092
01:03:53,140 --> 01:03:54,820
0,270 270,810 990,1350 1350,1470 1470,1680
one more point| and it
|这是在分手间的第二次讨论中提出的，

2093
01:03:54,820 --> 01:03:56,860
0,180 180,330 330,450 450,1080 1590,2040
came up in the discussion

2094
01:03:56,860 --> 01:03:58,390
0,270 270,420 420,840 870,1200 1200,1530
two in the breakup room,|
|

2095
01:03:58,420 --> 01:03:59,620
0,270 270,690 720,840 840,990 990,1200
which is you know how
那就是你知道怎样才能做得更好

2096
01:03:59,620 --> 01:04:01,240
0,120 120,210 210,300 300,750 1320,1620
could you do better,| how
|如何获得强大的一致性，

2097
01:04:01,240 --> 01:04:06,370
0,90 90,240 240,510 510,1230 4830,5130
to get strong consistency,| or
|或者只是变得更强，获得了相当强的一致性，

2098
01:04:06,370 --> 01:04:08,470
0,270 270,570 570,1290 1320,1830 1830,2100
maybe just stronger, got pretty

2099
01:04:08,470 --> 01:04:09,940
0,360 360,720 720,900 900,1080 1080,1470
strong {consistency -},| {that -}
|对于一些你知道的问题，你不知道。

2100
01:04:09,940 --> 01:04:11,600
0,90 90,300
you know

2101
01:04:11,660 --> 01:04:13,670
0,270 270,390 390,780 780,1380 1560,2010
not with some you know

2102
01:04:14,770 --> 01:04:15,980
0,720
issues.|
|

2103
01:04:16,100 --> 01:04:17,060
0,240 240,390 390,540 540,600 600,960
And so there's a hundred
所以你可以用一百种不同的方法来做

2104
01:04:17,060 --> 01:04:17,720
0,240 240,360 360,450 450,540 540,660
different ways you could do

2105
01:04:17,720 --> 01:04:19,850
0,270 270,840 870,1350 1560,1740 1740,2130
it| and {} in fact,
|事实上，你知道，我们将要看到的是。

2106
01:04:19,850 --> 01:04:22,370
0,60 60,750 1170,1920 1950,2400 2400,2520
you know, {} what we're

2107
01:04:22,370 --> 01:04:24,980
0,120 120,180 180,300 300,960 1290,2610
going to be seeing. {}|
|

2108
01:04:25,740 --> 01:04:26,910
0,150 150,240 240,810 810,1020 1020,1170
You know one, I think
你知道，我认为这里经常出现的一个问题是

2109
01:04:26,910 --> 01:04:28,050
0,150 150,480 480,720 720,960 960,1140
one issue that shows up

2110
01:04:28,050 --> 01:04:28,980
0,270 270,480 480,540 540,810 810,930
here all the time is|
|

2111
01:04:28,980 --> 01:04:29,760
0,150 150,240 240,360 360,660 660,780
like you could instead of
就像你可以不像获得初选然后报告，

2112
01:04:29,760 --> 01:04:31,650
0,270 300,1020 1260,1380 1380,1800 1800,1890
like obtaining the primary and

2113
01:04:31,650 --> 01:04:33,280
0,150 150,780 780,1080
then reporting, {}|
|

2114
01:04:33,340 --> 01:04:35,110
0,390 390,690 690,1170 1170,1680 1680,1770
making writes visible incrementally,| it's
以增量方式使写入可见，|这可能不是个好主意，

2115
01:04:35,110 --> 01:04:36,190
0,270 270,420 420,480 480,630 630,1080
probably not a good idea,|
|

2116
01:04:36,400 --> 01:04:37,540
0,180 180,450 450,930 930,1080 1080,1140
so you probably want to
所以你可能想要做的就是更新所有的初选或不更新，

2117
01:04:37,540 --> 01:04:39,610
0,180 180,330 330,570 570,1230 1320,2070
do is like update all

2118
01:04:41,260 --> 01:04:43,900
0,450 450,540 540,1110 1890,2130 2130,2640
secondary {} primaries or not,|
|

2119
01:04:45,220 --> 01:04:46,360
0,210 210,630 630,750 750,1020 1020,1140
but not in this you
但不是在这个你知道的特定设计中，

2120
01:04:46,360 --> 01:04:47,800
0,180 180,540 540,960 960,1260 1260,1440
know particular design,| where like
|比如有些人更新了，有些人可能不会更新，

2121
01:04:47,800 --> 01:04:48,970
0,330 330,480 480,900 900,1020 1020,1170
somebody get updated and some

2122
01:04:48,970 --> 01:04:50,200
0,120 120,420 420,570 570,990 990,1230
may not get updated,| that's
|这实际上对客户是可见的。

2123
01:04:50,200 --> 01:04:51,520
0,270 270,690 690,780 780,840 840,1320
actually visible to the client.|
|

2124
01:04:52,660 --> 01:04:53,950
0,450 660,870 870,1020 1020,1080 1080,1290
{} So there's a bunch
所以有一堆你知道的技术或协议改变你可以做的，

2125
01:04:53,950 --> 01:04:55,450
0,180 180,600 630,780 780,990 990,1500
of like you know techniques

2126
01:04:55,450 --> 01:04:57,250
0,480 510,1260 1260,1590 1590,1710 1710,1800
or protocol changes that you

2127
01:04:57,250 --> 01:04:58,690
0,120 120,480 780,1170 1170,1350 1350,1440
could do,| {} that will
|这会让它变得更好，事实上，你们将在实验2和3中看到，

2128
01:04:58,690 --> 01:04:59,590
0,180 180,300 300,630 630,840 840,900
make this better and in

2129
01:04:59,590 --> 01:05:01,060
0,270 270,360 360,600 600,1260 1260,1470
fact you will see in

2130
01:05:01,060 --> 01:05:02,740
0,420 420,660 660,780 780,1290 1320,1680
labs 2 and 3,| you
|您将构建的系统实际上具有更强的属性，

2131
01:05:02,740 --> 01:05:04,060
0,150 150,480 480,960 960,1080 1080,1320
will build systems that actually

2132
01:05:04,060 --> 01:05:06,000
0,330 330,420 420,810 810,1530
have the stronger properties,|
|

2133
01:05:06,370 --> 01:05:07,510
0,270 270,420 420,870 870,1050 1050,1140
{} and deal with the
并同时处理你所知道的场景，从而实现一致性。

2134
01:05:07,510 --> 01:05:10,450
0,660 690,1320 1320,1710 1710,2430 2430,2940
scenarios you know concurrently {lead,to}

2135
01:05:10,450 --> 01:05:11,660
0,630
consistency.|
|

2136
01:05:11,690 --> 01:05:12,440
0,150 150,390 390,450 450,570 570,750
In fact, if you look
事实上，如果你看看谷歌自己

2137
01:05:12,440 --> 01:05:14,600
0,120 120,480 480,1110 1380,1980 1980,2160
at Google's self| and we'll
|我们稍后将阅读其中的一些州，

2138
01:05:14,600 --> 01:05:15,380
0,150 150,270 270,360 360,510 510,780
read some of these states

2139
01:05:15,380 --> 01:05:17,870
0,480 660,1410 1410,1680 1680,2130 2130,2490
later,| Google build additional storage
|谷歌建造了更多的存储系统，其他一致性更强的存储系统。

2140
01:05:17,870 --> 01:05:19,020
0,540
systems,

2141
01:05:19,640 --> 01:05:20,720
0,240 240,480 480,810 810,900 900,1080
other storage systems that have

2142
01:05:20,720 --> 01:05:23,800
0,450 450,1110
stronger consistency.|
|

2143
01:05:25,930 --> 01:05:27,790
0,360 390,1020 1020,1380 1380,1680 1680,1860
And basically tailored those to
并且基本上针对不同的应用领域定制了这些应用程序，

2144
01:05:27,790 --> 01:05:29,590
0,90 90,450 450,930 930,1380 1620,1800
a different application domain,| for
|例如，就像在TERM[]只是纸扳手一样，

2145
01:05:29,590 --> 01:05:31,120
0,360 360,540 540,960 990,1230 1230,1530
example like in like halfway

2146
01:05:31,120 --> 01:05:32,650
0,90 90,390 390,840 840,990 990,1530
to term [] just paper

2147
01:05:32,650 --> 01:05:34,060
0,180 180,720 990,1140 1140,1230 1230,1410
{spanner -},| you know that
|您知道，它实际上具有更强大的一致性存储

2148
01:05:34,060 --> 01:05:36,040
0,270 270,450 450,720 720,1170 1170,1980
actually has a much stronger

2149
01:05:36,040 --> 01:05:38,290
0,480 480,630 630,1500 1500,1770 1830,2250
storage for consistency| and {}
|甚至对交易提供支持。

2150
01:05:38,290 --> 01:05:39,250
0,180 180,390 390,540 540,870 870,960
and even have support for

2151
01:05:39,250 --> 01:05:40,480
0,780
transactions.|
|

2152
01:05:40,570 --> 01:05:41,470
0,300 300,480 480,540 540,660 660,900
{} But it was like
但这就好像应用程序领域是完全不同的，

2153
01:05:41,470 --> 01:05:42,730
0,270 270,690 690,930 930,1020 1020,1260
the application domain is quite

2154
01:05:42,730 --> 01:05:43,810
0,420 450,570 570,810 810,990 990,1080
different,| you know you can
|你知道，你可以在这里看到，

2155
01:05:43,810 --> 01:05:44,710
0,180 180,240 240,510 510,780 780,900
sort of see here,| the
|GFS真的是量身定制的，

2156
01:05:44,710 --> 01:05:46,150
0,240 240,480 480,570 570,840 840,1440
{GFS -} is really tailored,|
|

2157
01:05:46,150 --> 01:05:46,840
0,90 90,180 180,420 420,600 600,690
you know to sort of
您知道，要运行MapReduceJOB。

2158
01:05:46,840 --> 01:05:49,510
0,1410 1440,1740 1740,1920 1920,2160 2160,2670
{} running {mapreduce -} jobs.|
|

2159
01:05:51,680 --> 01:05:52,790
0,360 390,600 600,750 750,960 960,1110
Okay, so I hope this
好的，我希望这是一个关于一致性的有用的介绍

2160
01:05:52,790 --> 01:05:54,650
0,120 120,540 570,1110 1110,1530 1530,1860
is a useful introduction for

2161
01:05:54,650 --> 01:05:56,660
0,780 780,1230 1260,1560 1560,1830 1830,2010
consistency| and start thinking about
|开始思考这类问题，

2162
01:05:56,660 --> 01:05:58,400
0,90 90,270 270,330 330,990 1290,1740
these kinds of problems,| because
|因为它们不会重复出现一系列问题，

2163
01:05:58,400 --> 01:05:59,810
0,150 150,360 360,480 480,1260 1260,1410
they won't be recurring set

2164
01:05:59,810 --> 01:06:01,160
0,60 60,480 480,660 660,1110 1110,1350
of problems,| that will show
|这一点将在本学期余下的时间里体现出来。

2165
01:06:01,160 --> 01:06:01,670
0,120 120,210 210,270 270,420 420,510
up in the rest of

2166
01:06:01,670 --> 01:06:02,580
0,90 90,420
the term.|
|

2167
01:06:03,760 --> 01:06:04,780
0,150 150,240 240,750 750,810 810,1020
And I apologize for running
我很抱歉我撞到了你的车。

2168
01:06:04,780 --> 01:06:06,220
0,210 210,270 270,450 450,780
over a little bit.|
|

2169
01:06:07,740 --> 01:06:09,300
0,390 390,660 660,840 840,1290 1290,1560
Thank you.| Hang around, so
谢谢。|所以人们想问更多的问题，

2170
01:06:09,300 --> 01:06:10,530
0,240 240,360 360,630 630,900 900,1230
people want to ask additional

2171
01:06:10,530 --> 01:06:13,110
0,420 420,810 810,1020 1020,1800 2280,2580
questions,| feel free to ask
|想问就问吧

2172
01:06:13,110 --> 01:06:14,340
0,240 510,870 870,990 990,1140 1140,1230
it| and you have to
|你必须跑到另一节课上，

2173
01:06:14,340 --> 01:06:15,480
0,150 150,240 240,510 510,960 960,1140
run to another class,| {you,know}
|你知道的，请跑到另一节课去。

2174
01:06:15,480 --> 01:06:16,920
0,270 270,510 510,630 630,900 900,1440
please run to another class.
