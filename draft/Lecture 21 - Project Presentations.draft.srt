1
00:00:08,730 --> 00:00:09,440
0,450

2
00:00:09,730 --> 00:00:11,080
0,780 780,1020 1020,1170 1170,1290 1290,1350
{} So feel free to
只要你想做好准备，就可以开始了。

3
00:00:11,080 --> 00:00:12,370
0,120 120,390 390,690 690,1110 1140,1290
get started, whenever you want

4
00:00:12,370 --> 00:00:13,340
0,60 60,150 150,630
to be ready.|
|

5
00:00:19,430 --> 00:00:21,080
0,720 840,1140 1140,1290 1290,1380 1380,1650
Alright, {} should we start
好的，那我们开始吧。

6
00:00:21,080 --> 00:00:21,760
0,390
then.|
|

7
00:00:22,560 --> 00:00:23,600
0,570
Please.|
请。|

8
00:00:24,420 --> 00:00:26,400
0,510 540,1050 1050,1230 1230,1770 1800,1980
Alright, {} hey everyone, {I'm
好了，大家好，我是 Felipe ，

9
00:00:26,400 --> 00:00:28,140
0,210 210,840 840,1050 1050,1350 1350,1740
-} Felipe,| I'm working with
|我和 Caralina 一起工作，

10
00:00:28,140 --> 00:00:29,340
0,630 630,720 720,930 930,1050 1050,1200
Caralina,| and today we're going
|今天，我们将介绍

11
00:00:29,340 --> 00:00:31,170
0,120 120,270 270,1020 1350,1590 1590,1830
to be presenting| on our
|我们的分布式私有电子投票项目。

12
00:00:31,170 --> 00:00:33,300
0,450 450,540 540,1050 1050,1530 1560,2130
project on distributed private electronic

13
00:00:33,300 --> 00:00:34,040
0,450
voting.|
|

14
00:00:34,400 --> 00:00:36,830
0,390 390,690 960,1770 1770,1950 1950,2430
{} So motivating this project
所以这个项目的动机其实很简单，

15
00:00:36,830 --> 00:00:38,120
0,300 300,420 420,600 600,960 960,1290
was you know actually sort

16
00:00:38,120 --> 00:00:39,620
0,270 330,600 600,690 690,1140 1170,1500
of sort of easy,| given
|给出当前的事件和选举，

17
00:00:39,620 --> 00:00:41,990
0,390 420,840 840,1260 1260,1530 1560,2370
the current events and elections,|
|

18
00:00:41,990 --> 00:00:43,130
0,180 180,420 420,480 480,840 840,1140
that had to happen with
必须在[秘密的]限制下发生，

19
00:00:43,160 --> 00:00:45,500
0,270 270,930 1170,1650 1650,2070 2070,2340
[covert] restrictions,| so we ask
|所以，我们提出了这个问题，

20
00:00:45,500 --> 00:00:47,810
0,60 60,600 600,1290 1440,2100 2100,2310
the question,| how would {}
|[]投票将如何运作？

21
00:00:47,810 --> 00:00:49,380
0,450 450,810 810,1380
[] voting work?|
|

22
00:00:49,760 --> 00:00:51,060
0,420 420,990
{} And,
我们特别关注维护选民隐私，

23
00:00:51,370 --> 00:00:53,290
0,330 330,480 480,930 930,1740 1740,1920
we're we're focusing specifically on

24
00:00:53,290 --> 00:00:55,800
0,660 660,930 930,1560 1590,2190
maintaining voter privacy, {}|
|

25
00:00:55,970 --> 00:00:57,350
0,330 330,690 690,810 810,930 930,1380
{} or you know keeping
或者让投票保密。

26
00:00:57,350 --> 00:00:58,740
0,450 450,1110
votes private.|
|

27
00:00:59,010 --> 00:01:00,300
0,150 150,420 420,870 870,930 930,1290
And so here's a sketch
以下是投票系统的工作原理，

28
00:01:00,300 --> 00:01:02,490
0,90 90,690 930,1590 1590,1890 1890,2190
of how a voting system

29
00:01:02,490 --> 00:01:03,400
0,240 240,660
might work,|
|

30
00:01:03,520 --> 00:01:05,230
0,390 390,540 540,1170 1260,1440 1440,1710
{} you have a bunch
你有一些选民，

31
00:01:05,230 --> 00:01:06,820
0,90 90,870 930,1350 1350,1440 1440,1590
of voters,| {} in this
|在这种情况下，有五个，

32
00:01:06,820 --> 00:01:08,380
0,270 270,360 360,480 480,1020 1290,1560
case, you know five,| and
|然后是一个计票器，

33
00:01:08,380 --> 00:01:10,600
0,510 540,780 780,1080 1080,1560 1860,2220
then a vote counter, {}|
|

34
00:01:10,600 --> 00:01:12,220
0,180 180,660 660,990 990,1110 1110,1620
the voters send their votes
选民把他们的选票送到机票器，

35
00:01:12,220 --> 00:01:13,680
0,210 210,390 390,690 690,1230
{} {to,the} vote counter,|
|

36
00:01:14,060 --> 00:01:16,520
0,570 600,870 870,1500 1500,1770 1770,2460
and {} the vote {counter,is},|
而计票器是，|

37
00:01:16,520 --> 00:01:17,450
0,90 90,240 240,600 600,720 720,930
you know maybe they send
也许他们会加密发送，或者某种安全措施，

38
00:01:17,450 --> 00:01:20,120
0,240 630,1290 1290,1590 2130,2460 2460,2670
them encrypted or some sort

39
00:01:20,120 --> 00:01:21,470
0,60 60,720 750,900 900,1080 1080,1350
of security,| the vote counter
|机票器解密它们，

40
00:01:21,470 --> 00:01:23,660
0,480 480,1590 1590,1800 1800,2010 2010,2190
decrypts them,| make sure that
|确保每个选民最多投票一次，

41
00:01:23,660 --> 00:01:24,770
0,180 180,480 480,720 720,810 810,1110
each voter votes at most

42
00:01:24,770 --> 00:01:27,060
0,600 900,1230 1230,1620 1620,2100
once| and {computes,a} winner.|
|并计算出获胜者。|

43
00:01:27,590 --> 00:01:30,500
0,480 480,1140 1170,1290 1290,2130 2460,2910
And so you know {}
所以这里要注意的关键是，

44
00:01:30,500 --> 00:01:31,910
0,360 360,630 630,750 750,1050 1050,1410
key thing to notice here

45
00:01:31,910 --> 00:01:33,470
0,210 210,630 690,1110 1140,1320 1320,1560
is that,| {} in order
|为了使计票器确定每个选民最多投一次票，

46
00:01:33,470 --> 00:01:34,640
0,120 120,210 210,450 450,810 810,1170
for the vote counter to

47
00:01:34,730 --> 00:01:36,830
0,660 660,990 990,1260 1260,1530 1530,2100
determine that every voter vote

48
00:01:36,830 --> 00:01:38,630
0,480 480,900 900,1170 1170,1530 1530,1800
[] at most once,| each
|每一张选票都必须以某种方式与选民联系在一起，

49
00:01:38,630 --> 00:01:39,830
0,360 360,540 540,630 630,990 1020,1200
vote has to be in

50
00:01:39,830 --> 00:01:41,660
0,270 270,450 450,990 1170,1620 1680,1830
some way linked to the

51
00:01:41,660 --> 00:01:43,340
0,510 840,1110 1110,1350 1350,1590 1590,1680
voter,| {} which which is
|这很危险。

52
00:01:43,340 --> 00:01:44,540
0,600 630,930 930,1020 1020,1140 1140,1200
dangerous.| So we're going to
|我们将在这里解释我们的威胁模型，

53
00:01:44,540 --> 00:01:45,740
0,210 210,330 330,570 570,810 810,1200
explain our threat model here,|
|

54
00:01:46,040 --> 00:01:47,210
0,240 240,450 450,630 630,930 930,1170
{} which is we're giving
也就是我们给了攻击者两种能力，

55
00:01:47,210 --> 00:01:49,310
0,120 120,840 870,1170 1170,1740 1770,2100
the attacker {} two sort

56
00:01:49,310 --> 00:01:51,530
0,270 360,1260 1260,1620 1800,2040 2040,2220
of capacity| or two two
|或者两种力量，

57
00:01:51,530 --> 00:01:53,540
0,270 270,870 960,1170 1170,1650 1650,2010
{sort,of} powers,| the first is
|第一种是制造崩溃停止失败，

58
00:01:53,570 --> 00:01:55,400
0,330 330,810 810,1320 1320,1530 1530,1830
{} to create fail stop

59
00:01:55,400 --> 00:01:57,470
0,540 600,1200 1200,1560 1560,1890 1890,2070
failures,| but not {byzantine -}
|但不是拜占庭式的失败，

60
00:01:57,470 --> 00:01:59,330
0,330 330,720 810,1110 1110,1530 1530,1860
failures,| so {} the attacker
|这样攻击者就可以使服务器崩溃，

61
00:01:59,330 --> 00:02:01,310
0,150 150,510 510,1200 1290,1680 1680,1980
can crash server,| but it
|但它不能让它行为不端。

62
00:02:01,310 --> 00:02:03,410
0,900 1170,1650 1650,1860 1860,1920 1920,2100
cannot {} sort of make

63
00:02:03,410 --> 00:02:04,660
0,360 360,1170
it misbehave.|
|

64
00:02:04,930 --> 00:02:06,160
0,420 420,510 510,630 630,1110 1110,1230
And you know whether there
这是否有一个合理的假设是另一个问题，

65
00:02:06,160 --> 00:02:07,210
0,90 90,180 180,540 540,960 960,1050
is a reasonable assumption is

66
00:02:07,210 --> 00:02:08,380
0,60 60,390 390,510 510,810 810,1170
a question for another day,|
|

67
00:02:08,830 --> 00:02:09,700
0,330 330,450 450,630 630,780 780,870
but we think there are
但我们认为还有其他协议可以处理这个问题，

68
00:02:09,700 --> 00:02:11,080
0,330 330,780 780,870 870,1110 1110,1380
other protocols that deal with

69
00:02:11,080 --> 00:02:13,450
0,210 210,810 900,1770 1770,2070 2070,2370
this issues,| we're not dealing
|我们不是在处理拜占庭式的失败。

70
00:02:13,450 --> 00:02:14,780
0,120 120,540 540,1140
with Byzantine failures.|
|

71
00:02:15,090 --> 00:02:17,310
0,690 810,1260 1260,1350 1350,1890 1890,2220
{} The the second power
我们给他们的第二种力量是，

72
00:02:17,310 --> 00:02:18,390
0,120 120,300 300,660 720,930 930,1080
we give them is| to
|监视计票器上的人，

73
00:02:18,390 --> 00:02:20,880
0,510 510,1110 1350,1950 1950,2340 2340,2490
passively spy on a on

74
00:02:20,880 --> 00:02:22,380
0,90 90,360 360,840 960,1320 1320,1500
a vote counter,| and so
|所以这是有问题的，

75
00:02:22,380 --> 00:02:23,640
0,180 180,330 330,900 900,1170 1170,1260
this is problematic,| because as
|因为正如我们所说，选票与他们的选民是联系在一起的，

76
00:02:23,640 --> 00:02:25,320
0,150 150,510 510,960 960,1110 1110,1680
we said votes are linked

77
00:02:25,500 --> 00:02:27,090
0,330 330,750 750,900 900,1470 1470,1590
{} with their voters,| and
|所以，一个被动的攻击者，

78
00:02:27,090 --> 00:02:29,100
0,330 330,690 690,990 990,1440 1440,2010
so a passive attacker,| that's
|对服务器的间谍活动，

79
00:02:29,100 --> 00:02:31,530
0,330 510,990 990,1290 1290,1620 1680,2430
{} spying on the server,|
|

80
00:02:31,560 --> 00:02:32,820
0,270 270,450 450,540 540,660 660,1260
can sort of {deanonymized -}
可以在某种程度上取消这些投票的匿名性。

81
00:02:32,820 --> 00:02:35,490
0,180 180,780 1020,1800 2100,2340 2340,2670
those votes.| {} And so
|这就是我们的用武之地，

82
00:02:35,490 --> 00:02:36,900
0,330 330,570 570,870 870,1110 1110,1410
here's where we come in,|
|

83
00:02:36,900 --> 00:02:38,880
0,660 780,1140 1140,1230 1230,1680 1680,1980
and present our distributed voting
并展示我们的分布式投票设计，

84
00:02:38,880 --> 00:02:40,560
0,450 630,1050 1050,1380 1380,1620 1620,1680
design,| {} we're going to
|我们要处理第一个问题，

85
00:02:40,560 --> 00:02:42,360
0,180 180,300 300,390 390,870 900,1800
deal with the first problem,|
|

86
00:02:42,450 --> 00:02:44,820
0,420 420,1020 1140,1770 2040,2190 2190,2370
which is {} you know
也就是对手使服务器崩溃，

87
00:02:44,820 --> 00:02:46,500
0,510 510,900 900,1260 1260,1320 1320,1680
the adversary crashing the servers,|
|

88
00:02:46,500 --> 00:02:47,760
0,150 150,510 570,870 870,990 990,1260
and so we are going
我们将有几个投票器，

89
00:02:47,760 --> 00:02:49,710
0,450 570,900 900,1200 1200,1710 1710,1950
to {} have several vote

90
00:02:49,710 --> 00:02:51,780
0,660 750,1020 1020,1140 1140,1560 1560,2070
counters,| and the idea is
|我们的想法是，

91
00:02:51,870 --> 00:02:53,550
0,270 270,510 540,990 990,1530 1530,1680
{} that,| each voter will
|每个投票者都会把其他选票送到所有的投票器，

92
00:02:53,550 --> 00:02:55,680
0,390 420,750 750,1380 1500,1890 1890,2130
send other votes to all

93
00:02:55,680 --> 00:02:56,760
0,90 90,360 360,1020
the vote counters,|
|

94
00:02:57,030 --> 00:02:59,100
0,630 630,1200 1350,1530 1530,1770 1770,2070
{} and the vote counters
而计票器将使用与之前相同的协议

95
00:02:59,100 --> 00:03:00,540
0,150 150,480 480,810 840,990 990,1440
will use {} the same

96
00:03:00,570 --> 00:03:03,090
0,510 750,1320 1320,1950 1980,2190 2190,2520
{} protocols {as,before}| and compute
|来计算获胜者，

97
00:03:03,090 --> 00:03:06,330
0,540 1080,1590 1590,1890 1890,2220 2460,3240
winners,| [] winners, sorry, {}|
|[]获胜者，抱歉，|

98
00:03:06,480 --> 00:03:08,520
0,540 900,1410 1410,1650 1650,1920 1920,2040
and {} it's this is
这很好，

99
00:03:08,520 --> 00:03:10,320
0,240 240,840 840,1230 1230,1740 1740,1800
good,| because {} add a
|因为再加上一个崩溃，

100
00:03:10,320 --> 00:03:12,030
0,300 300,960 990,1230 1230,1350 1350,1710
second crash,| sort of like
|比如 n-1 个计票器，

101
00:03:12,090 --> 00:03:14,310
0,240 240,540 540,1140 1290,1710 1710,2220
{n-1 - -} vote counters,|
|

102
00:03:14,310 --> 00:03:15,510
0,210 210,390 390,480 480,990 1020,1200
as long as one of
只要其中一个还在运行，

103
00:03:15,510 --> 00:03:16,890
0,270 270,480 480,780 780,900 900,1380
them is up and running,|
|

104
00:03:17,070 --> 00:03:17,970
0,150 150,450 450,660 660,750 750,900
{} we will be able
我们就能够计算出获胜者。

105
00:03:17,970 --> 00:03:18,920
0,90 90,360 360,450 450,840
to compute a winner.|
|

106
00:03:19,320 --> 00:03:21,840
0,390 390,930 930,1440 1440,1950 1980,2520
{} However it's very {}
然而，这是非常不安全的，

107
00:03:21,930 --> 00:03:24,660
0,450 450,630 630,1440 1470,2010 2010,2730
you know arguably more unsafe|
|

108
00:03:24,900 --> 00:03:25,980
0,450 450,510 510,810 810,990 990,1080
for the second type of
对于第二种类型的攻击来说，

109
00:03:25,980 --> 00:03:27,990
0,360 360,480 480,750 750,1290 1290,2010
attack,| which was passively [fine],|
|这是被动的[很好]，|

110
00:03:28,020 --> 00:03:29,820
0,840 870,1140 1140,1350 1350,1620 1620,1800
because as long as you
因为作为一个对手，

111
00:03:29,820 --> 00:03:32,460
0,510 600,930 930,1170 1170,1860 1860,2640
know as as a adversary,|
|

112
00:03:32,460 --> 00:03:34,440
0,210 210,600 600,900 960,1530 1710,1980
the attacker can compromise, even
攻击者甚至可以危害一台服务器，

113
00:03:34,440 --> 00:03:37,050
0,690 750,1560 1650,2160 2160,2460 2460,2610
one server,| {} you know
|它可以取消匿名投票，

114
00:03:37,050 --> 00:03:38,490
0,240 240,360 360,480 480,930 930,1440
it can {deanonymized -} votes,|
|

115
00:03:38,490 --> 00:03:39,720
0,240 240,480 480,690 690,840 840,1230
so that's where we're introducing
这就是我们要介绍 Shamir 秘密共享，

116
00:03:39,720 --> 00:03:42,660
0,330 330,630 630,990 1650,2670 2670,2940
Shamir Secret Sharing,| for {Shamir,Secret}
|对于 Shamir 秘密共享，我们有一个投票器，

117
00:03:42,660 --> 00:03:44,310
0,330 330,450 450,780 780,990 990,1650
Sharing, we have a voter,|
|

118
00:03:44,460 --> 00:03:46,200
0,300 300,600 600,990 990,990 1620,1740
{} that's gonna, {} you
这将是，选择一个投票 0 或 1 ，

119
00:03:46,200 --> 00:03:47,700
0,270 300,720 720,780 780,1230 1260,1500
know choose a vote either

120
00:03:47,700 --> 00:03:48,540
0,270 270,360 360,750
0 or 1,|
|

121
00:03:48,820 --> 00:03:49,780
0,300 300,420 420,510 510,870 870,960
{} and we're gonna,| you
我们会，|我不会解释 Shamir 是如何工作的，

122
00:03:49,780 --> 00:03:50,590
0,210 210,480 480,630 630,750 750,810
know I'm not going to

123
00:03:50,590 --> 00:03:52,750
0,480 480,690 690,1200 1230,1830 1830,2160
explain how Shamir actually works,|
|

124
00:03:52,750 --> 00:03:55,030
0,210 240,540 540,1200 1200,1860 1890,2280
it's a cryptographic protocol,| but
它是一种加密协议，|但我们要展示它允许我们做什么，

125
00:03:55,030 --> 00:03:56,470
0,90 90,270 270,690 780,930 930,1440
we're gonna just you know

126
00:03:56,500 --> 00:03:57,610
0,420 420,630 630,720 720,990 990,1110
show what it allows us

127
00:03:57,610 --> 00:04:00,010
0,120 120,570 810,1290 1290,1980 2010,2400
to do,| {} you pass
|你通过 Shamir 传递投票，

128
00:04:00,010 --> 00:04:01,330
0,360 360,480 480,1050 1080,1200 1200,1320
vote through Shamir,| where you
|给它两个参数， n 和 k ，

129
00:04:01,330 --> 00:04:02,980
0,180 180,330 330,450 450,1020 1020,1650
give it two parameters, {n,and,k},|
|

130
00:04:03,070 --> 00:04:05,560
0,330 330,540 540,900 900,1410 1590,2490
and it's going to create
它将产生 n 个部分，

131
00:04:05,560 --> 00:04:07,720
0,420 420,1170 1320,1650 1650,1890 1890,2160
n part,| {} which allow
|允许你重新计算选票，

132
00:04:07,720 --> 00:04:09,010
0,180 180,300 300,450 450,900 900,1290
you to {re-compute -} that

133
00:04:09,010 --> 00:04:11,260
0,450 720,1410 1440,1830 1830,1980 1980,2250
{} vote,| the n parts
|这 n 个部分可以完全随机，

134
00:04:11,260 --> 00:04:12,700
0,150 150,600 600,990 1020,1290 1290,1440
could completely random,| and in
|事实上，最强大的是，

135
00:04:12,700 --> 00:04:14,290
0,630 720,930 930,1050 1050,1500 1500,1590
fact, what is sort of

136
00:04:14,290 --> 00:04:16,180
0,420 420,600 600,900 900,1110 1320,1890
powerful,| but Shamir is even
|但是 Shamir 即使是 k-1 个部分

137
00:04:16,210 --> 00:04:18,550
0,300 300,690 690,1380 1560,1860 1860,2340
{k-1 - -} {} shares|
|

138
00:04:18,550 --> 00:04:20,560
0,150 150,330 330,540 540,1260 1440,2010
give you no information about
也不会给你提供任何关于原始投票的信息，

139
00:04:20,560 --> 00:04:22,720
0,90 90,570 570,990 1020,1710 1770,2160
the original vote,| but {}
|但如果有 k 或更多的部分，

140
00:04:22,720 --> 00:04:24,340
0,360 360,720 720,780 780,1020 1020,1620
given k or more shares,|
|

141
00:04:24,370 --> 00:04:25,750
0,300 300,570 570,780 780,1260 1260,1380
you can use {Shamir -}
你可以使用 Shamir 重新计算那个选票。

142
00:04:25,750 --> 00:04:27,140
0,150 150,720 750,960 960,1320
to re-compute that vote.|
|

143
00:04:29,780 --> 00:04:31,040
0,420 420,660 660,930 930,1140 1140,1260
{} So we're going to
所以，我们将展示 Shamir 投票方案。

144
00:04:31,040 --> 00:04:33,560
0,180 180,330 330,660 1530,1830 1830,2520
show Shamir {Voting,Scheme}.| {} So,
|所以，现在，对于 Shamir 投票方案，

145
00:04:33,560 --> 00:04:34,670
0,180 180,540 540,720 720,840 840,1110
yeah, now, for the Shamir

146
00:04:34,670 --> 00:04:37,520
0,450 480,1290 1290,1620 1620,2160 2220,2850
Voting Voting Scheme,| so first
|首先，所有的选民要选择他们的选票，

147
00:04:37,520 --> 00:04:38,420
0,150 150,240 240,660 660,750 750,900
all the voters are going

148
00:04:38,420 --> 00:04:39,860
0,240 240,420 420,600 600,990 990,1440
to choose their vote,| and
|并共享部分计票器，

149
00:04:39,860 --> 00:04:41,030
0,420 420,570 570,1020 1020,1110 1110,1170
share {} parts of the

150
00:04:41,030 --> 00:04:42,290
0,270 270,660 660,810 810,900 900,1260
vote counters,| and the complete
|以及对不同部分的完整投票，

151
00:04:42,290 --> 00:04:44,330
0,300 300,450 450,1020 1110,1590 1590,2040
vote on the different parts,|
|

152
00:04:44,720 --> 00:04:46,520
0,300 300,780 780,930 930,1200 1200,1800
and so the both counters
两个计票器都将接收部分，

153
00:04:46,520 --> 00:04:47,570
0,210 210,390 390,540 540,900 900,1050
are going to receive the

154
00:04:47,570 --> 00:04:48,620
0,420 420,600 600,750 750,870 870,1050
parts,| and when they have
|当它们得到所有选民的部分时，

155
00:04:48,620 --> 00:04:49,550
0,120 120,360 360,510 570,810 810,930
the parts of all the

156
00:04:49,550 --> 00:04:50,280
0,630
voters,|
|

157
00:04:50,610 --> 00:04:51,900
0,480 480,690 690,840 840,1110 1110,1290
they're going to SUM these
它们将这些部分相加，

158
00:04:51,900 --> 00:04:53,610
0,510 750,1080 1080,1350 1350,1440 1440,1710
parts,| and share the SUM
|并将 SUM 分享给机票器，

159
00:04:53,610 --> 00:04:55,170
0,150 150,240 240,510 510,1080 1170,1560
with the vote counters,| so
|所以这里需要注意的是，

160
00:04:55,170 --> 00:04:56,280
0,300 300,450 450,630 630,1020 1020,1110
{} here it's important to

161
00:04:56,280 --> 00:04:57,990
0,240 240,540 540,840 840,1470 1470,1710
note that,| this SUM looks
|这个 SUM 看起来完全是随机的，

162
00:04:57,990 --> 00:04:59,580
0,180 180,570 570,720 720,1200 1290,1590
like completely at random,| and
|所以，通过与两个计数器共享它，

163
00:04:59,580 --> 00:05:00,570
0,210 210,360 360,690 690,810 810,990
so by sharing it with

164
00:05:00,570 --> 00:05:02,010
0,90 90,360 360,870 990,1260 1260,1440
the both counters,| {} the
|其他两个计票器，

165
00:05:02,010 --> 00:05:03,570
0,510 510,810 810,1140 1140,1260 1260,1560
other both counters,| they cannot
|它们无法了解任何关于 a 收到的部分的信息，

166
00:05:03,570 --> 00:05:05,370
0,330 330,870 870,1200 1200,1320 1320,1800
learn anything about the parts

167
00:05:05,370 --> 00:05:08,280
0,360 390,960 990,1350 1380,2070 2310,2910
that {} a received,| so,
|所以，这保证了选民的隐私得到维护，

168
00:05:08,280 --> 00:05:10,320
0,210 210,600 600,1140 1290,1860 1860,2040
{} this {} ensures that

169
00:05:10,320 --> 00:05:11,700
0,120 120,690 690,870 870,960 960,1380
the privacy of the voters

170
00:05:11,700 --> 00:05:12,620
0,150 150,750
is maintained,|
|

171
00:05:13,970 --> 00:05:15,470
0,240 240,420 420,690 690,1350 1350,1500
{} so they exchange their
所以他们交换了他们的选票，

172
00:05:15,470 --> 00:05:17,180
0,540 630,1080 1080,1350 1350,1410 1410,1710
votes,| and when a vote
|当机票器收到 SUM 时，

173
00:05:17,180 --> 00:05:19,100
0,390 390,600 600,1020 1020,1350 1350,1920
counter has received case sums|
|

174
00:05:19,370 --> 00:05:22,130
0,540 540,900 900,1290 1290,1830 2190,2760
from other voters are including
来自其他选民的包括他们的一部分，

175
00:05:22,130 --> 00:05:23,810
0,180 180,570 600,1110 1110,1290 1290,1680
their part,| they can finally
|他们最终可以计算出获胜者，

176
00:05:23,810 --> 00:05:25,670
0,390 390,510 510,930 1170,1470 1470,1860
compute the winner,| so using
|所以再次使用 Shamir 秘密共享，黑色盒子，

177
00:05:25,670 --> 00:05:27,590
0,540 540,960 960,1560 1560,1920 1920,1920
{} Shamir {Secret,Sharing} again, {}

178
00:05:27,590 --> 00:05:30,050
0,390 390,750 870,1980 1980,2220 2220,2460
black box,| {} {it,will} like
|它会像重新计算 sum ，

179
00:05:30,050 --> 00:05:31,520
0,570 630,780 780,1080 1080,1170 1170,1470
{} {re-compute -} the sum,|
|

180
00:05:31,760 --> 00:05:32,900
0,270 270,420 420,510 510,840 840,1140
and if we get something
如果我们得到的选票超过选民总数的一半，

181
00:05:32,900 --> 00:05:33,860
0,150 150,240 240,570 570,750 750,960
that is greater than half

182
00:05:33,860 --> 00:05:34,850
0,120 120,210 210,480 480,540 540,990
of the number of voters,|
|

183
00:05:34,850 --> 00:05:35,960
0,150 150,240 240,480 480,660 660,1110
then the winner is 1,|
那么获胜者就是 1 ，|

184
00:05:35,960 --> 00:05:36,860
0,210 210,330 330,420 420,570 570,900
and if it is less
如果小于，则获胜者是 0 ，

185
00:05:36,860 --> 00:05:37,610
0,150 150,270 270,510 510,660 660,750
than, the winner would be

186
00:05:37,610 --> 00:05:39,590
0,510 810,1410 1410,1560 1560,1800 1800,1980
0,| and yes so we
|是的，我们最终有了获胜者。

187
00:05:39,590 --> 00:05:41,020
0,600 630,840 840,930 930,1320
finally have a winner.|
|

188
00:05:41,680 --> 00:05:42,880
0,600 600,780 780,990 990,1110 1110,1200
{} Now, some of the
现在，我们方案的一些假设是，

189
00:05:42,880 --> 00:05:44,860
0,540 540,780 780,990 990,1680 1680,1980
assumptions of our scheme are,|
|

190
00:05:44,860 --> 00:05:46,120
0,360 360,540 540,630 630,1080 1080,1260
first that the voters and
首先，选民和计票器都表现良好，

191
00:05:46,120 --> 00:05:47,890
0,270 270,690 690,1200 1200,1380 1380,1770
vote counters are well behaved,|
|

192
00:05:47,890 --> 00:05:49,420
0,150 150,390 390,510 510,1140 1290,1530
and follow the protocol| or
并遵循协议，|或他们的部分听起来是善意的，

193
00:05:49,420 --> 00:05:50,980
0,210 210,690 690,1320 1320,1410 1410,1560
their parts some to what

194
00:05:50,980 --> 00:05:53,290
0,120 120,660 660,1080 1680,2190 2190,2310
they say sounds like good

195
00:05:53,290 --> 00:05:55,180
0,630 660,1410 1410,1560 1560,1680 1680,1890
intentions,| and {} we only
|我们使用这个方案只处理故障停止失败。

196
00:05:55,180 --> 00:05:56,920
0,360 360,600 600,870 870,1140 1140,1740
handle {} fail stop failures

197
00:05:58,240 --> 00:06:00,610
0,180 180,810 840,1230 1680,2160 2160,2370
with this scheme.| So yeah
|所以，现在来处理一些情况，

198
00:06:00,610 --> 00:06:01,780
0,360 360,510 510,840 840,1050 1050,1170
now to handle some of

199
00:06:01,780 --> 00:06:03,220
0,90 90,630 630,1020 1020,1230 1230,1440
the scenarios,| first {} if
|首先，如果我们有一个不可靠的网络方案，

200
00:06:03,220 --> 00:06:04,600
0,90 90,300 300,810 870,1290 1290,1380
we have { -} an

201
00:06:04,600 --> 00:06:06,680
0,540 540,1020 1020,1440
unreliable network {}

202
00:06:06,870 --> 00:06:08,700
0,750 750,1350 1380,1590 1590,1710 1710,1830
scenario,| {} all of the
|我们在服务器中发送的所有 RPC 都将定期发送，

203
00:06:08,700 --> 00:06:09,630
0,180 180,450 450,600 600,720 720,930
{RPCs -} that we send

204
00:06:09,630 --> 00:06:10,890
0,120 120,240 240,750 750,1050 1050,1260
in our servers are going

205
00:06:10,890 --> 00:06:12,510
0,240 240,450 480,780 780,1350 1350,1620
to be sent periodically| until
|直到我们收到它已被接收的确认，

206
00:06:12,510 --> 00:06:14,280
0,120 120,480 480,870 870,1560 1560,1770
we receive an acknowledgement that

207
00:06:14,280 --> 00:06:18,060
0,180 180,330 330,540 540,1170 2850,3780
it has been received,| then
|然后为了处理选民失败，

208
00:06:18,090 --> 00:06:20,130
0,150 150,600 600,930 930,1530 1620,2040
to handle voter failures,| so
|所以我们需要持久化所有选民，

209
00:06:20,130 --> 00:06:21,600
0,390 390,510 510,690 690,810 810,1470
we we need to persist

210
00:06:21,630 --> 00:06:22,980
0,450 450,630 630,750 750,870 870,1350
{} all of the voters,|
|

211
00:06:23,010 --> 00:06:24,540
0,420 420,780 780,870 870,1290 1290,1530
like persist the parts they
比如持久化他们计算的部分和他们的投票，

212
00:06:24,540 --> 00:06:27,360
0,540 540,870 870,1080 1080,1500 1590,2820
computed and their vote,| because
|因为如果我们重新计算部分，

213
00:06:27,390 --> 00:06:29,280
0,630 630,1050 1080,1200 1200,1560 1560,1890
if we {re-compute -} parts,|
|

214
00:06:29,280 --> 00:06:30,390
0,180 180,330 330,420 420,690 690,1110
and then the vote counters
然后计票器有不同的部分，

215
00:06:30,390 --> 00:06:31,800
0,210 210,600 600,990 990,1320 1320,1410
had different parts,| then the
|那么方案的正确性就会消失，

216
00:06:31,800 --> 00:06:32,850
0,450 450,570 570,660 660,900 900,1050
correctness of the scheme will

217
00:06:32,850 --> 00:06:33,540
0,120 120,330 330,420 420,510 510,690
be gone,| and they would
|他们将不能修正 sum ，

218
00:06:33,540 --> 00:06:34,410
0,180 180,270 270,450 450,570 570,870
not be able to correct

219
00:06:34,410 --> 00:06:35,760
0,60 60,390 540,810 810,930 930,1350
the sum,| so it's important
|所以，重要的是始终共享来自同一计算的部分，

220
00:06:35,760 --> 00:06:37,890
0,330 360,780 780,1200 1350,1740 1740,2130
to always share like parts

221
00:06:37,890 --> 00:06:39,870
0,240 240,330 330,780 1140,1830 1830,1980
from the same computation,| and
|而不修改部分，

222
00:06:39,870 --> 00:06:40,340
0,180 180,390
not like

223
00:06:40,580 --> 00:06:43,520
0,510 510,1080 1920,2220 2220,2790 2790,2940
change parts,| and finally to
|最后，为了处理计票器失败，

224
00:06:43,520 --> 00:06:45,560
0,600 600,780 780,1050 1050,1380 1380,2040
handle the vote counter failures,|
|

225
00:06:45,560 --> 00:06:47,660
0,660 840,1440 1440,1560 1560,1890 1890,2100
{} here we rely on
这里我们依赖于 Shamir 秘密共享方案，

226
00:06:47,660 --> 00:06:49,940
0,390 390,1080 1110,1500 1500,1920 2010,2280
Shamir Secret Sharing scheme,| and
|正如我们之前提到的，

227
00:06:49,940 --> 00:06:51,140
0,180 180,300 300,450 450,870 870,1200
so as we mentioned before,|
|

228
00:06:51,140 --> 00:06:52,640
0,210 210,420 420,720 720,1110 1140,1500
we only need {} k
我们只需要 k 个服务器来计算获胜者，

229
00:06:52,640 --> 00:06:54,260
0,540 540,660 660,1080 1080,1170 1170,1620
servers to compute the winner,|
|

230
00:06:54,530 --> 00:06:56,060
0,480 480,750 750,900 900,1290 1290,1530
so, {} the system is
所以，系统[] n-k 个计票器崩溃。

231
00:06:56,060 --> 00:06:57,440
0,300 300,720 720,900 900,1080 1080,1380
{} [] to {n-k -

232
00:06:57,440 --> 00:06:58,970
0,180 180,750 810,1080 1080,1260 1260,1530
-} crashes {} of vote

233
00:06:58,970 --> 00:06:59,640
0,570
counters.|
|

234
00:07:00,480 --> 00:07:01,680
0,210 210,510 510,720 720,930 930,1200
And now it is demo
现在是演示时间，

235
00:07:01,680 --> 00:07:03,750
0,270 300,840 1020,1260 1260,1740 1740,2070
time,| so I'll stop sharing
|所以，我停止共享屏幕，并共享另一个屏幕。

236
00:07:03,750 --> 00:07:05,580
0,420 420,600 600,930 960,1320 1320,1830
screen and share another screen.|
|

237
00:07:08,520 --> 00:07:10,110
0,600 600,780 780,1290 1290,1470 1470,1590
And so here is our
这是我们的 demo ，

238
00:07:10,110 --> 00:07:12,690
0,1080 1200,1860 1860,1980 1980,2280 2280,2580
demo,| basically we have {}
|我们这里有 5 名选民，

239
00:07:12,690 --> 00:07:14,520
0,300 300,780 780,1230 1230,1620 1680,1830
5 voters here,| so we
|我们有 3 个投票器，5个投票者，

240
00:07:14,520 --> 00:07:15,930
0,150 150,330 330,600 600,1140 1140,1410
have 3 vote counters, 5

241
00:07:15,930 --> 00:07:17,610
0,540 540,870 870,1200 1200,1440 1440,1680
voters,| and k is equal
|而且 k 等于 2 ，

242
00:07:17,610 --> 00:07:18,380
0,150 150,510
to 2,|
|

243
00:07:18,710 --> 00:07:20,720
0,330 330,600 600,840 840,1080 1350,2010
this means that {} network
这意味着网络是不可靠的，

244
00:07:20,720 --> 00:07:22,910
0,540 540,1380 1560,1740 1740,1980 1980,2190
is unreliable,| and now if
|现在如果我们运行它，

245
00:07:22,910 --> 00:07:24,720
0,150 150,360 360,570
we run it,|
|

246
00:07:26,000 --> 00:07:27,530
0,510 540,990 990,1170 1170,1290 1290,1530
here, {} so we got
在这里，我们有 3 个，

247
00:07:27,530 --> 00:07:28,940
0,330 330,690 690,810 810,1080 1080,1410
3,| and we get the
|我们得到的获胜者是 1 ，

248
00:07:28,940 --> 00:07:31,190
0,450 450,960 990,1170 1170,1530 1920,2250
winner is {} 1,| we
|我们也可以让其中一台服务器崩溃，

249
00:07:31,190 --> 00:07:32,210
0,150 150,420 420,690 690,900 900,1020
can also crash one of

250
00:07:32,210 --> 00:07:34,460
0,90 90,690 1320,1860 1860,2070 2070,2250
the servers,| since k is
|因为 k 等于 2 ，

251
00:07:34,460 --> 00:07:36,260
0,240 240,390 390,600 600,1200 1440,1800
equal to 2,| we can
|我们仍然可以通过只有两台服务器运行来计算获胜者，

252
00:07:36,260 --> 00:07:37,580
0,240 240,570 570,630 630,1050 1050,1320
still compute a winner by

253
00:07:37,580 --> 00:07:39,050
0,300 300,540 540,690 690,1110 1110,1470
having only two servers up,|
|

254
00:07:39,230 --> 00:07:40,250
0,210 210,390 390,660 660,900 900,1020
and so now if we
所以现在如果我们运行它，

255
00:07:40,250 --> 00:07:42,200
0,180 180,390 720,1440 1470,1830 1830,1950
run it,| we get the
|我们得到的选举获胜者还是 1 ，

256
00:07:42,200 --> 00:07:43,070
0,270 270,330 330,390 390,750 750,870
winner of the election is

257
00:07:43,070 --> 00:07:45,200
0,180 180,570 600,1020 1140,1710 1770,2130
say 1 again,| and this
|我们的展示到此结束，

258
00:07:45,200 --> 00:07:45,770
0,90 90,180 180,330 330,420 420,570
is the end of our

259
00:07:45,770 --> 00:07:47,270
0,600 600,990 990,1110 1110,1290 1290,1500
presentation,| thank you very much
|非常感谢你的收听，

260
00:07:47,270 --> 00:07:48,440
0,120 120,540 540,780 780,960 960,1170
for listening| and we'll take
|我们将回答一些问题。

261
00:07:48,440 --> 00:07:49,260
0,150 150,690
some questions.|
|

262
00:08:03,940 --> 00:08:05,320
0,300 300,450 450,630 630,840 840,1380
Feel free to ask questions.|
请随意提问。|

263
00:08:12,130 --> 00:08:14,470
0,600 600,1050 1050,1800 1800,1950 1950,2340
Curious, how extensively you tested
好奇的是，你测试这个系统的范围有多广，

264
00:08:14,470 --> 00:08:16,090
0,180 180,690 960,1290 1290,1410 1410,1620
this system,| like do you
|比如，你有没有尝试过不同的其他配置，

265
00:08:16,090 --> 00:08:17,860
0,600 810,1200 1260,1620 1620,1740 1740,1770
have a try in {}

266
00:08:17,860 --> 00:08:19,990
0,180 180,480 480,660 660,1800 1860,2130
much different other configurations,| do
|你们有性能数字吗？

267
00:08:19,990 --> 00:08:21,680
0,150 150,330 330,780 780,1440
you have performance numbers?|
|

268
00:08:22,680 --> 00:08:25,020
0,600 600,870 870,1350 1620,1770 1770,2340
{} Sure, so, {} we
当然，我们确实有不同大小的，

269
00:08:25,020 --> 00:08:27,120
0,270 270,690 720,1320 1350,1800 1800,2100
we did {} have like

270
00:08:27,120 --> 00:08:29,730
0,540 750,1530 1530,2070 2100,2340 2340,2610
different sizes of,| we create
|我们创建了一整套测试套件，

271
00:08:29,730 --> 00:08:31,230
0,60 60,360 360,630 630,930 960,1500
a whole test suite,| and
|确保测试投票者故障，服务器故障有不同的大小，

272
00:08:31,350 --> 00:08:32,700
0,330 330,630 630,690 690,1140 1140,1350
make sure to test like

273
00:08:32,700 --> 00:08:34,830
0,360 360,930 930,1350 1350,1860 1860,2130
voter failures, server failures have

274
00:08:34,830 --> 00:08:38,430
0,420 450,1290 1530,2670 2910,3330 3330,3600
different sizes,| and we don't
|我们没有性能数据，

275
00:08:38,430 --> 00:08:40,500
0,330 330,960 960,1560 1680,1830 1830,2070
have performance numbers,| we didn't
|我们没有测试过，

276
00:08:40,500 --> 00:08:42,480
0,270 270,660 690,1260 1560,1860 1860,1980
test that,| {} but in
|但就失败而言，

277
00:08:42,480 --> 00:08:44,100
0,330 330,420 420,630 630,1140 1140,1620
terms of like failures,| and
|以及不同数量的投票者，投票器，

278
00:08:44,100 --> 00:08:45,690
0,240 240,600 600,930 1050,1500 1500,1590
and different like numbers of

279
00:08:45,690 --> 00:08:47,880
0,660 660,1080 1080,1530 1530,1740 1740,2190
voters, vote counters,| yeah, we
|是的，我们有一套完整的测试套件，

280
00:08:47,880 --> 00:08:49,410
0,330 330,630 630,900 900,1170 1170,1530
have a full test suite,|
|

281
00:08:49,410 --> 00:08:50,490
0,120 120,480 660,900 900,990 990,1080
and that we should have
我们应该把链接放到 github 上，

282
00:08:50,490 --> 00:08:51,750
0,180 180,300 300,720 750,960 960,1260
put the link and get

283
00:08:51,750 --> 00:08:53,040
0,180 180,510 510,690 690,1020 1080,1290
{} {for,github -},| but {}
|但是我们可以把它发给你，如果你想要的话，

284
00:08:53,040 --> 00:08:54,210
0,360 360,600 630,750 750,930 930,1170
we can you know send

285
00:08:54,210 --> 00:08:55,020
0,90 90,210 210,360 360,540 540,810
it to you, if you,

286
00:08:55,330 --> 00:08:56,380
0,180 180,480 480,690 690,750 750,1050
you want,| so you can
|你可以在测试中检查查看实现。

287
00:08:56,410 --> 00:08:58,540
0,360 390,600 600,870 870,1170 1170,2130
check like look over implementation,

288
00:08:59,490 --> 00:09:01,080
0,480 480,720 720,1200
{} under testing.|
|

289
00:09:09,490 --> 00:09:10,760
0,840
There,
好的，还有问题吗？

290
00:09:11,150 --> 00:09:13,880
0,1920 1920,2070 2070,2310 2310,2580 2580,2730
{more,questions}?| {Can,you,say} something maybe a
|你能说点比如 6.824 的想法吗，

291
00:09:13,880 --> 00:09:15,170
0,180 180,540 540,780 780,1200 1200,1290
little bit like what {ideas

292
00:09:15,170 --> 00:09:15,920
0,180 180,330 330,570 570,660 660,750
-} from {6.824 - -

293
00:09:15,920 --> 00:09:16,730
0,300 300,420 420,510 510,750 750,810
-}| were you able to
|你在这个系统里应用的，

294
00:09:16,730 --> 00:09:17,900
0,390 390,630 630,870 870,1020 1020,1170
apply in the in this

295
00:09:17,900 --> 00:09:18,600
0,390
system,|
|

296
00:09:20,390 --> 00:09:21,530
0,270 270,480 480,720 720,810 810,1140
other than using the testing
而不是使用测试框架。

297
00:09:21,530 --> 00:09:25,490
0,570 2640,3210 3240,3780 3780,3870 3870,3960
framework.| Sure, {Caro -}, {do,you}
|当然， Caro 你想要说这个，还是我来？

298
00:09:25,490 --> 00:09:26,210
0,150 150,210 210,390 390,570 570,720
want to take this one

299
00:09:26,210 --> 00:09:27,140
0,120 120,300 300,360 360,600
or should I take?|
|

300
00:09:27,340 --> 00:09:30,130
0,270 270,600 630,1380 1680,2430 2580,2790
{} Sure, { -} so
当然，所以在这里，

301
00:09:30,130 --> 00:09:32,050
0,600 600,600 1020,1230 1230,1530 1530,1920
here,| {} I guess, yeah
|我想，这个游戏来自

302
00:09:32,050 --> 00:09:33,640
0,570 570,780 780,1140 1140,1410 1410,1590
this game actually comes from|
|

303
00:09:33,640 --> 00:09:35,440
0,360 390,810 810,1020 1020,1170 1170,1800
a [pizza] from the cryptography
密码学课上的披萨，

304
00:09:35,440 --> 00:09:36,460
0,390 420,660 660,780 780,840 840,1020
class,| and so it was
|所以，从不同的角度来看它是很有趣的，

305
00:09:36,460 --> 00:09:38,170
0,150 150,270 270,870 870,1320 1320,1710
fun to look at it

306
00:09:38,170 --> 00:09:39,490
0,150 150,210 210,600 600,1140 1140,1320
from a different perspective,| so
|现在我们关注安全问题，

307
00:09:39,490 --> 00:09:41,710
0,240 240,420 420,600 600,1680 1710,2220
now we're {} like focusing

308
00:09:41,710 --> 00:09:43,150
0,120 120,360 360,840 870,960 960,1440
that much on the security,|
|

309
00:09:43,150 --> 00:09:43,990
0,60 60,270 270,420 420,600 600,840
I need {} more like
我需要，如果个别的服务器会发生什么，

310
00:09:43,990 --> 00:09:45,340
0,270 270,600 600,720 720,810 810,1350
what happens if the individual

311
00:09:45,340 --> 00:09:47,050
0,360 480,840 840,1380 1380,1530 1530,1710
{} like servers,| if they
|如果它们失败了，

312
00:09:47,050 --> 00:09:49,450
0,570 600,1140 1320,1590 1590,2040 2040,2400
fail,| {} so both handling
|无论是处理投票者故障、处理投票器故障，

313
00:09:49,450 --> 00:09:53,260
0,1560 1560,2070 2070,2640 2760,3480 3480,3810
voter failures, handling vote counter

314
00:09:53,260 --> 00:09:55,060
0,690 780,1200 1200,1590 1590,1710 1710,1800
failures,| {} problems with the
|还是网络问题，

315
00:09:55,060 --> 00:09:57,340
0,630 660,1200 1500,1710 1710,2010 2010,2280
network,| {} I guess we
|我想我们没有解决分区问题，

316
00:09:57,340 --> 00:09:59,290
0,300 300,600 600,1170 1170,1680 1680,1950
didn't address specific partitions,| because
|因为它的工作原理类似于投票器，

317
00:09:59,290 --> 00:10:00,460
0,90 90,240 240,480 480,900 900,1170
it would work similar to

318
00:10:00,490 --> 00:10:04,120
0,360 360,810 810,1410 1800,2640 2880,3630
vote counter crushed, { -}|
|

319
00:10:04,150 --> 00:10:06,190
0,210 210,990 990,1170 1170,1830 1920,2040
but, yeah, it was, it
但是，从不同的角度来看待这个问题是很有趣的。

320
00:10:06,190 --> 00:10:07,060
0,150 150,300 300,390 390,780 780,870
was fun to look at

321
00:10:07,060 --> 00:10:08,230
0,150 150,480 480,660 660,870 930,1170
this problem from a different

322
00:10:08,230 --> 00:10:08,820
0,510
perspective.|
|

323
00:10:11,300 --> 00:10:14,870
0,1530 1530,2160 3000,3390 3390,3480 3480,3570
Yeah, thanks.| Unless you have
好的，谢谢。|除非你有话要说，

324
00:10:14,870 --> 00:10:15,770
0,240 240,300 300,600 630,810 810,900
something to say,| we're out
|我们有点超时了，所以，

325
00:10:15,770 --> 00:10:16,610
0,60 60,240 240,300 300,510 510,840
of time a bit, so,|
|

326
00:10:17,940 --> 00:10:19,590
0,180 180,480 510,870 960,1350 1380,1650
yeah, cool awesome, {} nice
好的，酷，干得好，谢谢分享。

327
00:10:19,590 --> 00:10:21,690
0,390 630,870 870,990 990,1410 1770,2100
job, thanks for sharing.| Okay,
|好的，我们有一个关于私有分析的演讲。

328
00:10:21,690 --> 00:10:23,700
0,270 270,630 630,1080 1080,1710 1710,2010
we have a presentation on

329
00:10:23,700 --> 00:10:25,840
0,300 300,1260
private analytics.|
|

330
00:10:27,830 --> 00:10:29,390
0,660 810,1170 1170,1260 1260,1470 1470,1560
If Kevin is ready to
如果 Kevin 准备好分享，太棒了，

331
00:10:29,390 --> 00:10:30,700
0,510 540,990
share, awesome,|
|

332
00:10:30,900 --> 00:10:31,650
0,210 210,270 270,540 540,690 690,750
take it away, I'll be
请开始，我会准备好的。

333
00:10:31,650 --> 00:10:32,460
0,300
ready.|
|

334
00:10:34,150 --> 00:10:35,020
0,420 420,480 480,630 630,720 720,870
Okay, you guys can hear
好的，你们能听到我的声音吗，你们能看到我的鼠标吗？

335
00:10:35,020 --> 00:10:35,560
0,150 150,240 240,300 300,450 450,540
me and you guys can

336
00:10:35,560 --> 00:10:37,160
0,180 180,600 840,1380
see my pointer?|
|

337
00:10:37,420 --> 00:10:40,990
0,510 1020,1920 1950,2520 2970,3450 3450,3570
Yes.| Okay, cool,| everyone, I'm
是的。|好的，酷，|各位好，我是 Kevin ，

338
00:10:40,990 --> 00:10:42,100
0,480 480,750 750,900 900,960 960,1110
Kevin,| and today I'm going
|今天，我将介绍这个非常有创意的命名为 Sys 的系统，

339
00:10:42,100 --> 00:10:43,240
0,60 60,120 120,510 510,690 690,1140
to be presenting this very

340
00:10:43,420 --> 00:10:45,010
0,450 450,630 630,900 900,1110 1110,1590
creatively named system called Sys,|
|

341
00:10:45,310 --> 00:10:46,450
0,390 390,540 540,660 660,720 720,1140
and this is a system
这是一种以保护隐私的方式收集汇总统计数据的系统，

342
00:10:46,450 --> 00:10:48,490
0,210 210,690 690,1080 1080,1770 1770,2040
for collecting aggregate statistics in

343
00:10:48,490 --> 00:10:49,980
0,150 150,570 570,960 960,1260
a privacy preserving way,|
|

344
00:10:50,440 --> 00:10:51,610
0,210 210,390 390,480 480,720 720,1170
and so the last presentation
所以上一个演示很好地引导了我的项目，

345
00:10:51,610 --> 00:10:52,780
0,120 120,270 270,660 660,990 1020,1170
was good leading to my

346
00:10:52,780 --> 00:10:53,950
0,540 570,840 840,990 990,1080 1080,1170
project,| {} so for the
|在 6.824 的大部分时间里，

347
00:10:53,950 --> 00:10:55,960
0,240 240,570 570,750 750,1530 1830,2010
most part in 6.824,| we've
|我们已经讨论了，

348
00:10:55,960 --> 00:10:56,800
0,240 240,420 420,540 540,660 660,840
talked about,| how we can
|如何在拜占庭或[]故障的情况下建立可靠的系统，

349
00:10:56,800 --> 00:10:58,450
0,480 510,930 930,1440 1440,1500 1500,1650
build reliable systems in the

350
00:10:58,510 --> 00:11:00,490
0,420 420,630 630,1110 1110,1410 1410,1980
presence of byzantine or []

351
00:11:00,490 --> 00:11:02,080
0,390 540,840 840,1110 1110,1200 1200,1590
fails,| so servers can crash,|
|所以服务器可能会崩溃，|

352
00:11:02,080 --> 00:11:03,160
0,330 330,600 600,660 660,990 990,1080
and clients are generally well
客户端通常都表现得很好，

353
00:11:03,160 --> 00:11:05,110
0,660 870,1470 1470,1590 1590,1710 1710,1950
behaved,| but from this talk,|
|但从这次演讲来看，|

354
00:11:05,110 --> 00:11:05,890
0,60 60,210 210,300 300,570 600,780
I hope you learn some
我希望你能学到一些新概念，

355
00:11:05,890 --> 00:11:07,030
0,150 150,720 720,840 840,1020 1020,1140
new concepts,| on how we
|关于我们如何在出现拜占庭式故障的情况下建立具有强大保障的系统，

356
00:11:07,030 --> 00:11:08,950
0,450 660,1290 1290,1620 1620,1710 1710,1920
can build systems with strong

357
00:11:08,950 --> 00:11:10,150
0,630 630,720 720,810 810,1080 1080,1200
guarantees in the presence of

358
00:11:10,150 --> 00:11:11,890
0,390 390,1050 1290,1470 1470,1680 1680,1740
byzantine failures| on behalf of
|代表系统内的客户端和服务器。

359
00:11:11,890 --> 00:11:13,240
0,210 210,660 660,900 900,1170 1170,1350
both clients and servers within

360
00:11:13,240 --> 00:11:13,780
0,60 60,450
the system.|
|

361
00:11:14,450 --> 00:11:15,980
0,420 690,930 930,1170 1170,1410 1410,1530
And the main tools that
我们要使用的主要工具

362
00:11:15,980 --> 00:11:16,580
0,90 90,210 210,270 270,480 480,600
we're going to use| to
|用来实现这些保证的是加密原语，

363
00:11:16,580 --> 00:11:18,350
0,270 270,420 420,990 990,1320 1440,1770
achieve these guarantees are cryptographic

364
00:11:18,350 --> 00:11:20,330
0,420 420,630 630,870 870,1260 1260,1980
primitives,| such as multiparty computation
|例如多方计算和零知识证明，

365
00:11:20,510 --> 00:11:22,010
0,270 270,390 390,630 630,1260 1350,1500
and {zero-knowledge -} proofs| and
|以及广播之类的分布式计算原语，比如广播。

366
00:11:22,010 --> 00:11:23,600
0,270 270,780 780,1140 1140,1470 1470,1590
also distributed computing primitives, such

367
00:11:23,600 --> 00:11:24,620
0,120 120,870
as broadcast.|
|

368
00:11:27,040 --> 00:11:28,510
0,180 180,360 360,480 480,1170 1200,1470
Okay, so for simplicity,| let's
好的，为了简单起见，|假设我们想建立一个计算和的系统，

369
00:11:28,510 --> 00:11:29,020
0,120 120,210 210,330 330,450 450,510
say we just want to

370
00:11:29,020 --> 00:11:30,100
0,210 210,240 240,570 570,720 720,1080
build a system that computes

371
00:11:30,100 --> 00:11:31,240
0,570 720,900 900,960 960,1080 1080,1140
sums,| so we're going to
|所以，我们将拥有一个聚合服务器，

372
00:11:31,240 --> 00:11:32,500
0,270 270,360 360,840 840,1110 1110,1260
have an aggregation server,| that
|存储键值存储，

373
00:11:32,500 --> 00:11:34,210
0,570 570,690 690,870 870,1320 1320,1710
stores {} key value store,|
|

374
00:11:34,450 --> 00:11:35,260
0,180 180,270 270,510 510,570 570,810
so the keys are going
键将成为某些统计数据的索引，

375
00:11:35,260 --> 00:11:36,280
0,60 60,150 150,630 630,750 750,1020
to be indices for some

376
00:11:36,280 --> 00:11:38,560
0,1440 1500,1860 1860,1950 1950,2220 2220,2280
statistics,| and the values are
|值将是和的元组，

377
00:11:38,560 --> 00:11:39,280
0,120 120,180 180,300 300,630 630,720
going to be tuples of

378
00:11:39,280 --> 00:11:40,080
0,630
sums,|
|

379
00:11:40,850 --> 00:11:41,450
0,240 240,330 330,450 450,540 540,600
and we're gonna have a
我们会有一堆客户端，

380
00:11:41,450 --> 00:11:42,830
0,150 150,210 210,900 990,1200 1200,1380
bunch of clients,| so each
|所以每个客户端都会有一些身份，

381
00:11:42,830 --> 00:11:43,790
0,270 270,360 360,510 510,780 780,960
client is gonna have some

382
00:11:43,790 --> 00:11:45,470
0,540 540,870 870,1140 1140,1470 1470,1680
identity,| say its client IP
|比如它的客户端 IP 地址，

383
00:11:45,470 --> 00:11:46,280
0,510
addresses,|
|

384
00:11:46,380 --> 00:11:47,160
0,270 270,450 450,510 510,690 690,780
it's going to have the
它会有他们想要增加的统计数据的索引，

385
00:11:47,160 --> 00:11:48,210
0,330 330,420 420,480 480,990 990,1050
index of the statistic they

386
00:11:48,210 --> 00:11:49,710
0,240 240,720 1020,1170 1170,1290 1290,1500
wanna bump,| and it's also
|而且它也将有它的私有输入，

387
00:11:49,710 --> 00:11:51,030
0,120 120,210 210,690 690,960 960,1320
going to have its private

388
00:11:51,030 --> 00:11:51,820
0,540
inputs,|
|

389
00:11:52,040 --> 00:11:53,000
0,240 240,300 300,570 570,780 780,960
so the most {straightforward -}
所以最直接的做法就是，

390
00:11:53,000 --> 00:11:53,600
0,120 120,240 240,390 390,480 480,600
thing to do is,| we
|我们可以让所有客户端按原样将其输入发送到服务器，

391
00:11:53,600 --> 00:11:54,710
0,180 180,390 390,510 510,570 570,1110
can have all the clients

392
00:11:54,710 --> 00:11:56,540
0,540 690,1020 1020,1170 1170,1680 1680,1830
send {} their inputs {to,the}

393
00:11:56,540 --> 00:11:57,800
0,690 690,810 810,900 900,1020 1020,1260
{server,as,is},| and they can computes
|它们可以计算和，

394
00:11:57,800 --> 00:11:58,660
0,60 60,630
the sums,|
|

395
00:11:59,120 --> 00:11:59,990
0,240 240,360 360,480 480,630 630,870
but obviously this is bad,|
但显然这很糟糕，|

396
00:11:59,990 --> 00:12:01,790
0,270 270,600 600,1140 1140,1320 1320,1800
because now this leads everything,
因为现在这引领了一切，

397
00:12:01,820 --> 00:12:03,050
0,360 510,660 660,870 870,1020 1020,1230
right,| the server will learn
|服务器将获知客户端的身份，

398
00:12:03,050 --> 00:12:04,610
0,90 90,360 360,960 1080,1380 1380,1560
the client's identity,| it'll learn
|它将获得发出的索引，

399
00:12:04,610 --> 00:12:06,050
0,60 60,330 330,540 540,960 1140,1440
the index being bumped,| and
|它将获得它们的私有输入。

400
00:12:06,050 --> 00:12:07,580
0,240 240,660 690,870 870,1140 1140,1530
they'll learn their private input.|
|

401
00:12:09,130 --> 00:12:09,640
0,180 180,270 270,360 360,450 450,510
So we can do a
所以我们可以做得更好一点，

402
00:12:09,640 --> 00:12:10,810
0,150 150,270 270,690 780,1020 1020,1170
little bit better,| {} we
|我们可以私下计算这些和，

403
00:12:10,810 --> 00:12:12,220
0,120 120,390 390,510 510,750 750,1410
can compute these sums privately,|
|

404
00:12:12,340 --> 00:12:13,750
0,270 270,360 360,750 750,1140 1140,1410
if we deploy to non
如果我们部署到非合谋服务器，

405
00:12:13,750 --> 00:12:15,490
0,420 420,1050 1320,1560 1560,1650 1650,1740
colluding servers,| and then we're
|然后，我们将让每个客户端

406
00:12:15,490 --> 00:12:16,810
0,120 120,180 180,600 630,840 840,1320
going to have each client|
|

407
00:12:16,840 --> 00:12:18,190
0,450 450,630 630,750 750,1260 1260,1350
secret share their input to
秘密地将它们的输入共享到每个服务器，

408
00:12:18,190 --> 00:12:19,380
0,150 150,240 240,360 360,990
each of these servers,|
|

409
00:12:19,620 --> 00:12:20,520
0,180 180,540 540,630 630,810 810,900
so as we said in
正如我们在上一次演示中所说的，

410
00:12:20,520 --> 00:12:21,990
0,180 210,540 540,1050 1050,1230 1230,1470
the previous presentation,| so each
|每个服务器、每个签名本身都不会泄露有关客户端私有输入的信息，

411
00:12:21,990 --> 00:12:24,390
0,540 570,1020 1020,1410 1410,1920 1950,2400
server, each signature alone leaks

412
00:12:24,390 --> 00:12:25,950
0,210 210,810 810,1140 1140,1200 1200,1560
no information about the client's

413
00:12:25,950 --> 00:12:28,020
0,240 240,780 1050,1230 1230,1860 1920,2070
private input,| but still the
|但服务器仍然可以将这些份额相加，

414
00:12:28,020 --> 00:12:29,250
0,360 360,630 630,840 840,1050 1050,1230
servers can add up these

415
00:12:29,250 --> 00:12:31,020
0,510 510,660 660,1080 1110,1230 1230,1770
shares| and compute a local
|并计算出一个键值存储的本地版本，

416
00:12:31,200 --> 00:12:32,550
0,690 690,900 900,960 960,1110 1110,1350
version of the key value

417
00:12:32,550 --> 00:12:33,200
0,450
store,|
|

418
00:12:33,660 --> 00:12:34,560
0,150 150,240 240,570 570,810 810,900
and then later when the
然后稍后当服务器想要恢复实际和时，

419
00:12:34,560 --> 00:12:35,880
0,330 330,540 540,660 660,1200 1200,1320
servers want to recover the

420
00:12:35,880 --> 00:12:37,620
0,330 330,840 930,1200 1200,1350 1350,1740
actual sums,| they can combine
|它们可以合并它们本地的键值存储

421
00:12:37,620 --> 00:12:38,760
0,120 120,390 390,600 600,840 840,1140
their local key value stores|
|

422
00:12:38,760 --> 00:12:40,260
0,180 180,930 960,1080 1080,1350 1350,1500
to reconstruct the global key
重建全局键值存储，

423
00:12:40,260 --> 00:12:41,140
0,240 240,600
value store,|
|

424
00:12:42,120 --> 00:12:42,630
0,120 120,240 240,300 300,360 360,510
and this is a little
这个好了一点，

425
00:12:42,630 --> 00:12:44,310
0,120 120,510 510,900 900,1260 1500,1680
bit better,| at least if
|至少如果这些服务器中有一个是诚实的，

426
00:12:44,310 --> 00:12:45,120
0,210 210,300 300,450 450,690 690,810
one of these servers is

427
00:12:45,120 --> 00:12:46,560
0,540 690,840 840,930 930,1320 1320,1440
honest,| then the servers are
|那么服务器仍然会获知客户的身份，

428
00:12:46,560 --> 00:12:47,460
0,210 210,360 360,570 570,630 630,900
still gonna learn the client's

429
00:12:47,460 --> 00:12:48,780
0,570 600,900 900,1110 1110,1230 1230,1320
identity,| they're still going to
|它们仍将获取客户的索引，

430
00:12:48,780 --> 00:12:50,550
0,330 330,420 420,840 840,1530 1590,1770
learn the client's index,| but
|但现在不是获得每个客户端的输入，

431
00:12:50,550 --> 00:12:51,690
0,210 210,480 480,570 570,870 870,1140
now instead of learning each

432
00:12:51,690 --> 00:12:53,490
0,450 450,840 840,1350 1440,1680 1680,1800
individual client's input,| they're going
|它们将获得所有客户端的和和输入，

433
00:12:53,490 --> 00:12:54,690
0,90 90,450 450,570 570,1020 1020,1200
to learn the sums of

434
00:12:54,690 --> 00:12:56,340
0,210 210,660 660,900 930,1530
all clients and inputs,|
|

435
00:12:56,880 --> 00:12:58,500
0,180 180,300 300,510 510,900 900,1620
okay, so that's better,| but
好的，这样好多了，|但这仍然是个问题，

436
00:12:58,500 --> 00:12:59,760
0,150 150,240 240,720 720,1020 1020,1260
still a problem,| namely that
|也就是，这个身份索引关系仍然可以泄露大量信息。

437
00:12:59,760 --> 00:13:01,830
0,450 450,1050 1050,1470 1470,1950 1950,2070
this identity index relation can

438
00:13:01,830 --> 00:13:03,060
0,270 270,600 690,990 990,1170 1170,1230
still leak a lot of

439
00:13:03,060 --> 00:13:04,000
0,630
information.|
|

440
00:13:04,510 --> 00:13:05,230
0,180 180,330 330,450 450,510 510,720
So how can we fix
那么我们如何才能解决这个问题，

441
00:13:05,230 --> 00:13:06,400
0,390 450,690 690,810 810,1020 1020,1170
this,| we can make things
|我们可以让事情匿名，

442
00:13:06,400 --> 00:13:08,470
0,720 930,1440 1440,1590 1590,1920 1920,2070
anonymous,| so we're still going
|所以，我们仍将调整[]的设置，

443
00:13:08,470 --> 00:13:09,640
0,60 60,540 570,870 870,1050 1050,1170
to adapt {} {setup -}

444
00:13:09,640 --> 00:13:11,020
0,150 150,210 210,660 870,1140 1140,1380
from the [],| but now
|现在我们给每台服务器提供一个公钥用于加密，

445
00:13:11,020 --> 00:13:11,800
0,120 120,240 240,300 300,570 600,780
we're going to give each

446
00:13:11,800 --> 00:13:13,450
0,600 600,690 690,1080 1080,1500 1500,1650
server a public key for

447
00:13:13,450 --> 00:13:14,260
0,540
encryption,|
|

448
00:13:14,840 --> 00:13:15,830
0,150 150,300 300,420 420,870 870,990
and that each client is
并且每个客户端都将对其每个份额进行加密，

449
00:13:15,830 --> 00:13:17,000
0,120 120,180 180,810 900,1110 1110,1170
going to encrypt each of

450
00:13:17,000 --> 00:13:18,060
0,150 150,840
their shares,|
|

451
00:13:18,380 --> 00:13:19,130
0,150 150,420 420,480 480,690 690,750
and instead of having the
并且不是让客户端将它们的份额直接发送到服务器，

452
00:13:19,130 --> 00:13:20,780
0,600 600,960 960,1110 1110,1350 1350,1650
clients send their shares directly

453
00:13:20,780 --> 00:13:21,860
0,90 90,600 630,900 900,960 960,1080
to servers,| now we're going
|现在，我们将在两者之间设置一层转发代理，

454
00:13:21,860 --> 00:13:22,580
0,60 60,210 210,240 240,570 570,720
to have a layer of

455
00:13:22,580 --> 00:13:24,340
0,330 330,810 810,930 930,1470
forwarding proxies in between,|
|

456
00:13:24,980 --> 00:13:25,550
0,180 180,270 270,390 390,510 510,570
and so what's going to
所以接下来会发生的是，

457
00:13:25,550 --> 00:13:26,480
0,210 210,330 330,420 420,780 780,930
happen is,| the clients going
|客户端将通过广播将其加密的共享发送到这些代理，

458
00:13:26,480 --> 00:13:28,370
0,90 90,570 690,990 990,1290 1290,1890
to send their encrypted shares

459
00:13:28,490 --> 00:13:31,520
0,390 390,1350 1380,1560 1560,2400 2400,3030
via broadcast to those proxies,|
|

460
00:13:31,700 --> 00:13:33,200
0,300 300,360 360,900 900,1110 1110,1500
and the proxies will route
并且代理将每个共享发送到它们各自的服务器，

461
00:13:33,500 --> 00:13:34,880
0,420 420,750 750,840 840,960 960,1380
each share to their respective

462
00:13:34,880 --> 00:13:35,760
0,690
servers,|
|

463
00:13:36,160 --> 00:13:37,750
0,210 210,510 510,630 630,1200 1200,1590
and then the aggregation can
然后聚合可以像解释的那样进行，

464
00:13:37,750 --> 00:13:39,820
0,240 240,990 990,1230 1230,1740
go as as explained,|
|

465
00:13:40,720 --> 00:13:41,230
0,180 180,270 270,420 420,450 450,510
and so what are the
那么，这里的隐私保障是什么，

466
00:13:41,230 --> 00:13:43,060
0,330 330,690 690,1140 1440,1710 1710,1830
privacy guarantees here,| if at
|如果这些[财产]中至少有一个是诚实的，

467
00:13:43,060 --> 00:13:44,050
0,180 180,390 390,480 480,660 660,990
least one of these properties

468
00:13:44,050 --> 00:13:45,520
0,150 150,810 900,1050 1050,1110 1110,1470
is honest,| then the proxy
|代理仍将获知客户端的身份，

469
00:13:45,520 --> 00:13:46,750
0,120 120,540 540,840 840,930 930,1230
will still learn the client's

470
00:13:46,750 --> 00:13:48,310
0,630 900,1080 1080,1230 1230,1440 1440,1560
identity,| and it'll learn some
|它会获得一些计时信息，

471
00:13:48,310 --> 00:13:49,990
0,300 300,900 900,1200 1200,1320 1320,1680
timing information,| based on when
|基于客户端何时设置共享，

472
00:13:49,990 --> 00:13:51,430
0,330 360,720 720,900 900,990 990,1440
the client set the share,|
|

473
00:13:52,100 --> 00:13:54,140
0,150 150,420 420,840 840,1170 1170,2040
but nothing else,| because the
但没别的了，|因为共享被加密到服务器，

474
00:13:54,140 --> 00:13:55,070
0,270 270,360 360,750 750,840 840,930
shares are encrypted to the

475
00:13:55,070 --> 00:13:56,390
0,330 330,480 480,570 570,1020 1050,1320
server,| so they learn nothing
|所以它们没有从中获得任何东西，

476
00:13:56,390 --> 00:13:57,240
0,240 240,540
from that,|
|

477
00:13:58,100 --> 00:13:59,510
0,150 150,360 360,780 1020,1230 1230,1410
and then if at least
如果这些服务器中至少有一个是诚实的，

478
00:13:59,510 --> 00:14:00,470
0,180 180,270 270,480 480,840 840,960
one of the servers is

479
00:14:00,470 --> 00:14:01,670
0,510 540,660 660,720 720,1050 1050,1200
honest,| then the servers will
|服务器也会获得一些计时信息，

480
00:14:01,670 --> 00:14:03,230
0,240 240,480 480,600 600,930 930,1560
also learn some timing information|
|

481
00:14:03,260 --> 00:14:04,490
0,240 240,480 480,540 540,870 870,1230
based when the proxy forward
基于代理转发它的时间，

482
00:14:04,490 --> 00:14:05,040
0,210
it,|
|

483
00:14:05,180 --> 00:14:06,110
0,210 210,300 300,630 630,840 840,930
it will certainly learn the
它还会获得统计的指标，

484
00:14:06,110 --> 00:14:07,790
0,420 420,570 570,660 660,1290 1380,1680
index of the statistic| and
|并获得和，

485
00:14:07,790 --> 00:14:08,820
0,180 180,240 240,720
learn the sum,|
|

486
00:14:09,260 --> 00:14:11,570
0,450 450,660 660,1350 1800,2040 2040,2310
but most importantly,| as long
但最重要的是，|只要代理和服务器不是同时受到危害，

487
00:14:11,570 --> 00:14:13,220
0,180 180,420 420,960 960,1080 1080,1650
as not both {} proxy

488
00:14:13,220 --> 00:14:14,450
0,240 240,270 270,630 630,720 720,1230
and {} server are compromised

489
00:14:14,450 --> 00:14:15,890
0,90 90,180 180,450 450,1020 1140,1440
at the same time,| then
|然后，这个设计将身份与被导出的索引解除链接，

490
00:14:15,890 --> 00:14:17,120
0,150 150,600 600,840 840,1110 1110,1230
this design {unlinks -} the

491
00:14:17,120 --> 00:14:18,530
0,690 720,930 930,990 990,1230 1230,1410
identity from the index being

492
00:14:18,530 --> 00:14:19,610
0,300 300,450 450,540 540,930 930,1080
bumped,| which is exactly what
|这正是我们想要的，

493
00:14:19,610 --> 00:14:20,340
0,90 90,450
we wanted,

494
00:14:20,700 --> 00:14:21,840
0,300 300,390 390,540 540,660 660,1140
right,| so this is great,|
|所以这很棒，|

495
00:14:21,960 --> 00:14:23,280
0,450 450,690 690,930 930,1200 1200,1320
but this also leads to
但这也导致了另一个问题，

496
00:14:23,280 --> 00:14:25,200
0,360 360,930 1020,1380 1380,1530 1530,1920
another problem,| namely that now
|也就是说，现在客户端可以躲在隐私后面，

497
00:14:25,200 --> 00:14:27,120
0,480 480,600 600,960 960,1500 1770,1920
clients can hide behind the

498
00:14:27,120 --> 00:14:28,500
0,420 420,510 510,930 930,1290 1290,1380
privacy,| and anonymity guarantees of
|以及匿名保证系统发送错误的输入。

499
00:14:28,500 --> 00:14:29,850
0,90 90,570 630,870 870,1140 1140,1350
the system to send bad

500
00:14:29,850 --> 00:14:30,660
0,630
inputs,

501
00:14:30,900 --> 00:14:31,920
0,330 330,480 480,690 690,930 930,1020
right.| So let's say the
|假设系统预期客户端输入为 0 和 1 ，

502
00:14:31,920 --> 00:14:33,570
0,390 390,840 840,1110 1110,1530 1530,1650
system expected client inputs to

503
00:14:33,570 --> 00:14:35,010
0,120 120,390 390,510 510,1020 1140,1440
be zeros and ones,| while
|在这种隐私的后面，

504
00:14:35,010 --> 00:14:36,300
0,330 330,480 480,630 630,690 690,1290
behind this [] of privacy,|
|

505
00:14:36,330 --> 00:14:37,350
0,270 270,330 330,660 660,780 780,1020
now the client can send
现在客户端可以通过系统发送 10 亿的签名，

506
00:14:37,350 --> 00:14:38,190
0,90 90,330 330,570 570,660 660,840
the {signature -} like a

507
00:14:38,190 --> 00:14:40,020
0,510 540,720 720,810 810,1410 1560,1830
billion through the system,| and
|现在它可以在无法察觉的情况下扭曲这个和，

508
00:14:40,020 --> 00:14:41,250
0,210 210,390 390,540 540,1110 1110,1230
now it can {undetectably -}

509
00:14:41,250 --> 00:14:43,260
0,540 540,750 750,1200 1590,1740 1740,2010
skew this sum,| so clearly
|所以，很明显，这很糟糕。

510
00:14:43,260 --> 00:14:44,400
0,150 150,300 300,930
this is bad.|
|

511
00:14:45,280 --> 00:14:46,210
0,270 270,510 510,690 690,810 810,930
Let's fix this,| we want
我们来解决这件事，|我们想让这个系统更强大，

512
00:14:46,210 --> 00:14:46,990
0,60 60,240 240,330 330,630 630,780
to make the system more

513
00:14:46,990 --> 00:14:48,550
0,690 840,1140 1140,1290 1290,1440 1440,1560
robust,| so what we're going
|所以我们要做的是，

514
00:14:48,550 --> 00:14:49,760
0,90 90,330 330,960
to do is,|
|

515
00:14:50,320 --> 00:14:51,010
0,150 150,270 270,330 330,540 540,690
we're going to have each
我们将让每个客户生成，

516
00:14:51,010 --> 00:14:52,060
0,330 330,630 630,780 780,1020 1020,1050
client generate,| what's called a
|所谓的对它们分享的零知识证明，

517
00:14:52,060 --> 00:14:53,770
0,210 210,540 540,1080 1110,1560 1560,1710
{zero-knowledge -} proof over their

518
00:14:53,770 --> 00:14:55,180
0,840 840,990 990,1170 1170,1320 1320,1410
shares,| and send these to
|并将这些发送到服务器，

519
00:14:55,180 --> 00:14:56,160
0,90 90,750
the servers,|
|

520
00:14:56,680 --> 00:14:58,420
0,150 150,210 210,360 360,990 1050,1740
and the many servers collect
许多服务器收集这些零知识证明，

521
00:14:58,420 --> 00:14:59,860
0,180 180,540 540,1080 1170,1320 1320,1440
these zero-knowledge proofs,| they can
|它们可以交互地检查客户端的输入，

522
00:14:59,860 --> 00:15:02,830
0,570 570,1080 1500,1800 1800,2190 2430,2970
interactively check that the client's

523
00:15:02,830 --> 00:15:04,540
0,420 420,1020 1020,1140 1140,1440 1440,1710
inputs,| actually the client shares
|实际上，客户端共享重建为一些格式良好的输入，

524
00:15:04,540 --> 00:15:07,210
0,390 480,1620 1620,1740 1740,2220 2460,2670
actually reconstruct to some well

525
00:15:07,210 --> 00:15:08,180
0,270 270,720
formed input,|
|

526
00:15:08,640 --> 00:15:09,900
0,300 300,720 720,900 900,1110 1110,1260
and because this proof is
因为这个证明是零知识的，

527
00:15:09,900 --> 00:15:11,700
0,150 150,360 360,1020 1110,1620 1620,1800
in {zero-knowledge -},| {} it
|它没有留下任何关于输入的内容，

528
00:15:11,700 --> 00:15:13,920
0,210 210,660 660,1230 1260,1860 1860,2220
leaves nothing about {} input,|
|

529
00:15:13,950 --> 00:15:14,970
0,210 210,390 390,690 690,810 810,1020
other than that it's well
除了它是格式良好的，

530
00:15:14,970 --> 00:15:15,660
0,450
formed,|
|

531
00:15:16,160 --> 00:15:17,120
0,180 180,270 270,480 480,570 570,960
and so again our privacy
所以我们的隐私属性又一次保持不变，

532
00:15:17,120 --> 00:15:18,200
0,330 330,480 480,540 540,960 960,1080
properties stay the same,| the
|代理仍会获得客户端的身份，

533
00:15:18,200 --> 00:15:19,490
0,360 360,660 660,900 900,990 990,1290
proxy still learns that client's

534
00:15:19,490 --> 00:15:20,870
0,630 720,930 930,1080 1080,1260 1260,1380
identity,| is still learns some
|仍能获得一些定时信息，

535
00:15:20,870 --> 00:15:22,970
0,270 270,1080 1470,1620 1620,1890 1890,2100
timing information,| the server learns
|服务器获知定时信息，

536
00:15:22,970 --> 00:15:23,930
0,240 240,630 630,720 720,870 870,960
timing information,| it learns the
|它获得索引和获得和，

537
00:15:23,930 --> 00:15:25,130
0,300 300,420 420,570 570,630 630,1200
index and learns the sums,|
|

538
00:15:25,510 --> 00:15:26,500
0,180 180,330 330,480 480,930 930,990
but now we've protected the
但现在我们已经保护系统不受恶意客户端的攻击，

539
00:15:26,500 --> 00:15:28,720
0,330 330,660 660,1170 1170,1830 1980,2220
system against malicious clients,| because
|因为它只接受格式良好的输入，

540
00:15:28,720 --> 00:15:30,070
0,210 210,450 450,930 930,1110 1110,1350
it'll only accept well formed

541
00:15:30,070 --> 00:15:30,860
0,600
inputs,|
|

542
00:15:31,610 --> 00:15:32,570
0,150 150,240 240,390 390,510 510,960
and so this is great,|
所以这很棒，|

543
00:15:32,720 --> 00:15:34,670
0,870 870,1050 1050,1350 1350,1740 1740,1950
still there's another problem,| which
还有另一个问题，|就是服务器可能会崩溃，

544
00:15:34,670 --> 00:15:36,050
0,120 120,360 360,660 660,780 780,1380
is that servers can crash,|
|

545
00:15:36,260 --> 00:15:37,190
0,120 120,180 180,300 300,480 480,930
and we can lose data,|
我们可能会丢失数据，|

546
00:15:37,220 --> 00:15:38,270
0,180 180,300 300,630 630,810 810,1050
so we obviously need both
所以，我们显然需要两台服务器都在线，

547
00:15:38,270 --> 00:15:39,380
0,330 330,420 420,600 600,1020 1020,1110
servers to be online,| in
|以便重建全局键值存储。

548
00:15:39,380 --> 00:15:41,420
0,180 180,480 600,1230 1380,1650 1650,2040
order to reconstruct {} global

549
00:15:41,420 --> 00:15:42,460
0,150 150,360 360,780
key value store.|
|

550
00:15:42,840 --> 00:15:43,410
0,210 210,330 330,390 390,450 450,570
And so if we want
所以，如果我们想让系统更可靠，

551
00:15:43,410 --> 00:15:44,190
0,60 60,180 180,240 240,690 690,780
to make the system more

552
00:15:44,190 --> 00:15:45,150
0,360 360,450 450,540 540,720 720,960
reliable,| we can do what
|我们可以做我们最了解的事情，即复制服务器，

553
00:15:45,150 --> 00:15:46,350
0,300 330,510 510,810 810,990 990,1200
we know best which is

554
00:15:46,350 --> 00:15:48,090
0,150 150,600 600,690 690,1350 1500,1740
to replicate the servers,| and
|所以我们可以使用 Raft 风格的复制，

555
00:15:48,090 --> 00:15:49,200
0,90 90,180 180,390 390,720 720,1110
so we can use Raft

556
00:15:49,200 --> 00:15:50,190
0,180 180,690 690,780 780,900 900,990
style replication,| or we can
|或者，我们也可以使用主备份式复制。

557
00:15:50,190 --> 00:15:51,930
0,180 180,330 330,870 960,1410 1410,1740
also use primary backup style

558
00:15:51,930 --> 00:15:52,760
0,570
replication.|
|

559
00:15:53,340 --> 00:15:54,450
0,240 240,300 300,630 630,900 900,1110
Now the question is,| okay,
现在的问题是，|好的，所有这些复制，所有这些加密机制，

560
00:15:54,450 --> 00:15:55,950
0,150 150,330 330,480 480,1320 1350,1500
with all this replication, all

561
00:15:55,950 --> 00:15:57,450
0,150 150,570 570,1140 1170,1410 1410,1500
this cryptographic machinery| and on
|在这条消息路由上，

562
00:15:57,450 --> 00:15:58,350
0,120 120,420 420,660 660,810 810,900
this message routing,| can we
|我们还能实现很好的吞吐量吗，

563
00:15:58,350 --> 00:16:00,380
0,240 240,810 990,1230 1230,1740
still achieve good throughput,|
|

564
00:16:01,180 --> 00:16:01,930
0,210 210,300 300,510 510,630 630,750
and it turns out that
事实证明，我们可以在这里并行服务器步骤，

565
00:16:01,930 --> 00:16:03,040
0,120 120,210 210,480 480,1020 1020,1110
we can actually parallelize the

566
00:16:03,040 --> 00:16:04,540
0,300 300,600 600,930 960,1170 1170,1500
server step here,| that does
|提供证明验证[]，

567
00:16:04,540 --> 00:16:06,340
0,210 210,510 510,1200 1230,1560 1560,1800
proof checking [],| which is
|这很可能是系统的瓶颈，

568
00:16:06,340 --> 00:16:07,240
0,240 240,300 300,390 390,510 510,900
likely to be the bottleneck

569
00:16:07,240 --> 00:16:08,590
0,60 60,150 150,660 1020,1200 1200,1350
of the system,| and what's
|接下来会发生的是，

570
00:16:08,590 --> 00:16:09,490
0,120 120,180 180,480 480,780 780,900
going to happen is that,|
|

571
00:16:09,490 --> 00:16:10,720
0,450 450,570 570,780 780,900 900,1230
proxies are going to hash
代理要对分区进行哈希，

572
00:16:10,720 --> 00:16:12,190
0,660 690,900 900,1230 1230,1350 1350,1470
partition,| their inputs to each
|它们对每台服务器的输入，

573
00:16:12,190 --> 00:16:13,510
0,90 90,210 210,840 1110,1230 1230,1320
of these servers,| and then
|然后这些服务器中的每一个都处于 reduce 步骤中，

574
00:16:13,510 --> 00:16:14,530
0,150 150,240 240,390 390,750 750,1020
each of these servers in

575
00:16:14,530 --> 00:16:16,330
0,150 180,660 660,1050 1080,1320 1320,1800
{sort,of} reduce step,| will combine
|将合并它们的中间键值存储，

576
00:16:16,330 --> 00:16:17,740
0,150 150,600 600,720 720,960 960,1410
their intermediate key value stores|
|

577
00:16:17,800 --> 00:16:19,090
0,270 270,780 780,870 870,1140 1140,1290
to reconstruct the global key
以重建包含所有和的全局键值存储。

578
00:16:19,090 --> 00:16:20,350
0,240 240,690 720,1080 1080,1200 1200,1260
value store containing all the

579
00:16:20,350 --> 00:16:21,020
0,600
sums.|
|

580
00:16:21,910 --> 00:16:22,720
0,510
Okay?|
好的？|

581
00:16:23,200 --> 00:16:24,010
0,150 150,240 240,510 510,600 600,810
And so now the final
所以现在最后一个问题是，

582
00:16:24,010 --> 00:16:24,880
0,300 300,390 390,510 510,540 540,870
question is,| did I implement
|我是不是在到期日之前实现了这个，

583
00:16:24,880 --> 00:16:25,870
0,210 210,420 420,720 720,840 840,990
all this before the due

584
00:16:25,870 --> 00:16:26,540
0,360
date,|
|

585
00:16:27,040 --> 00:16:28,570
0,420 420,690 690,1080 1140,1290 1290,1530
unfortunately, no,| but I did
很遗憾，没有,|但我确实走了很远的路，

586
00:16:28,570 --> 00:16:29,500
0,180 180,420 540,780 780,870 870,930
make it much of the

587
00:16:29,500 --> 00:16:30,280
0,150 150,450 450,570 570,630 630,780
way there,| so I'm gonna
|所以，我将展示一个简单的 domo ，

588
00:16:30,280 --> 00:16:32,140
0,510 510,660 660,900 900,1470 1590,1860
show a quick demo| of
|它的非复制、非并行版本。

589
00:16:32,140 --> 00:16:33,550
0,120 120,360 360,900 900,1140 1140,1410
the non replicated, non parallel

590
00:16:33,550 --> 00:16:34,400
0,240 240,300 300,540
version of it.|
|

591
00:16:34,700 --> 00:16:36,680
0,240 240,990 1020,1680 1680,1830 1830,1980
{So\,,I'm,going,to} quickly switch to my
所以我要快速切换到我的另一台笔记本电脑，

592
00:16:36,680 --> 00:16:37,780
0,180 180,900
other laptop,|
|

593
00:16:42,520 --> 00:16:43,480
0,180 180,360 360,570 570,840 840,960
I gotta stop sharing this
我得先停止分享这个。

594
00:16:43,480 --> 00:16:44,320
0,120 120,600
one first.|
|

595
00:16:46,630 --> 00:16:47,740
0,840
Yes,
是的，酷，

596
00:16:52,620 --> 00:16:55,120
0,420 450,810 810,1440 1770,2220
cool,| okay, so great,|
|好的，太棒了，|

597
00:16:55,430 --> 00:16:56,630
0,480 480,720 720,960 960,1110 1110,1200
so, on these right two
所以，在这两个右侧的终端上将安装服务器，

598
00:16:56,630 --> 00:16:57,290
0,330 330,420 420,540 540,600 600,660
terminals are going to be

599
00:16:57,290 --> 00:16:58,100
0,90 90,510 510,630 630,690 690,810
with servers,| so I'm going
|所以我要运行它们，

600
00:16:58,100 --> 00:16:59,040
0,90 90,300 300,600
to run them,|
|

601
00:17:00,640 --> 00:17:02,080
0,120 120,300 300,780 780,900 900,1440
it is implemented in Rust,|
它是用 Rust 实现的，|

602
00:17:02,200 --> 00:17:03,490
0,780 780,870 870,990 990,1050 1050,1290
now I'm going to hook
现在我要把中间的这两个代理连接起来，

603
00:17:03,490 --> 00:17:04,480
0,210 210,450 450,600 600,930 930,990
up these two proxies in

604
00:17:04,480 --> 00:17:05,320
0,60 60,540
the middle,|
|

605
00:17:07,420 --> 00:17:08,080
0,150 150,270 270,330 330,420 420,660
and then on the left
然后在左边的终端，

606
00:17:08,080 --> 00:17:09,490
0,330 330,390 390,570 570,930 960,1410
terminal,| I'm just gonna simulate
|我只想模拟一千个诚实的客户端。

607
00:17:09,490 --> 00:17:10,940
0,90 90,390 390,630 630,1230
a thousand honest clients.|
|

608
00:17:11,820 --> 00:17:12,720
0,150 150,300 300,630 630,780 780,900
And what's happening is all
现在的情况是，所有的客户端都在生成它们的输入共享，

609
00:17:12,720 --> 00:17:14,430
0,60 60,600 600,1020 1020,1500 1500,1710
the clients are generating their

610
00:17:14,430 --> 00:17:15,660
0,240 240,540 540,660 660,990 990,1230
input sharing| and generating {zero-knowledge
|以及生成零知识证明，

611
00:17:15,660 --> 00:17:17,010
0,240 240,720 780,1050 1050,1230 1230,1350
-} proofs| and sending them
|并通过代理发送它们，

612
00:17:17,010 --> 00:17:18,120
0,180 180,900
with proxies,|
|

613
00:17:18,320 --> 00:17:19,220
0,120 120,180 180,510 510,600 600,900
and the proxies are simply
而代理只是将它们转发到服务器，

614
00:17:19,220 --> 00:17:20,780
0,480 480,720 720,810 810,900 900,1560
forwarding them to the servers,|
|

615
00:17:21,280 --> 00:17:22,270
0,150 150,270 270,570 570,900 900,990
and then here finally on
最后，在服务器端，

616
00:17:22,270 --> 00:17:23,170
0,60 60,330 330,660 660,780 780,900
the server side,| they're going
|它们会检查所有的证明，

617
00:17:23,170 --> 00:17:23,950
0,60 60,150 150,480 480,660 660,780
to be checking all the

618
00:17:23,950 --> 00:17:26,020
0,570 660,1080 1080,1470 1500,1830 1830,2070
proofs,| and if the inputs
|如果这些输入是格式良好的，

619
00:17:26,020 --> 00:17:26,830
0,90 90,150 150,360 360,510 510,810
are in fact well formed,|
|

620
00:17:26,830 --> 00:17:27,400
0,120 120,240 240,300 300,450 450,570
it's going to add it
它将把它添加到本地键值存储中，

621
00:17:27,400 --> 00:17:28,840
0,210 210,570 570,1080 1080,1230 1230,1440
to its local key value

622
00:17:28,840 --> 00:17:30,070
0,330 720,930 930,1020 1020,1110 1110,1230
store,| and then at some
|然后在一段时间之后，

623
00:17:30,070 --> 00:17:31,300
0,210 210,420 420,630 630,720 720,1230
time later,| when the servers
|当服务器想要重建最终统计数据时，

624
00:17:31,300 --> 00:17:32,560
0,180 180,240 240,780 780,960 960,1260
want to reconstruct the final

625
00:17:32,560 --> 00:17:33,700
0,480 480,570 570,690 690,840 840,1140
statistics,| they can just combine
|它们只需结合它们的键值存储来恢复和。

626
00:17:33,700 --> 00:17:34,780
0,90 90,180 180,390 390,780 870,1080
their key value store to

627
00:17:34,780 --> 00:17:35,740
0,270 270,360 360,840
recover the sums.|
|

628
00:17:36,760 --> 00:17:38,110
0,450 750,990 990,1140 1140,1230 1230,1350
And that's it for my
我的演讲到此结束，

629
00:17:38,110 --> 00:17:39,400
0,630 630,810 810,1050 1050,1110 1110,1290
presentation,| I'm happy to take
|我很乐意回答任何问题。

630
00:17:39,400 --> 00:17:40,380
0,120 120,690
any questions.|
|

631
00:17:45,830 --> 00:17:46,430
0,60 60,120 120,210 210,300 300,600
Do you have any questions
观众有什么问题吗？

632
00:17:46,430 --> 00:17:48,700
0,270 270,360 360,870
from the audience?|
|

633
00:17:54,380 --> 00:17:54,950
0,240 240,390 390,450 450,540 540,570
I guess I have a
我想我有个问题，

634
00:17:54,950 --> 00:17:56,600
0,540 600,990 1020,1200 1200,1410 1410,1650
question,| {} so like with
|所以你到目前为止实现的那样，

635
00:17:56,600 --> 00:17:58,130
0,180 180,300 300,750 750,960 960,1530
what you implemented so far,|
|

636
00:17:58,220 --> 00:18:00,560
0,360 360,630 630,1290 1410,1830 1980,2340
what sort of, like which
比如什么你会接受，

637
00:18:00,560 --> 00:18:01,580
0,150 150,360 360,660 660,720 720,1020
at what point do you

638
00:18:01,580 --> 00:18:03,830
0,510 690,1440 1650,1980 1980,2160 2160,2250
{} accept,| what point do
|什么容错，类似的东西，

639
00:18:03,830 --> 00:18:05,510
0,420 420,990 990,1290 1290,1500 1500,1680
tolerate failures and like stuff,|
|

640
00:18:05,510 --> 00:18:06,560
0,150 150,390 510,630 630,870 870,1050
like that I can talk
我可以谈谈你当前实现的可靠性。

641
00:18:06,560 --> 00:18:07,700
0,210 210,630
about the

642
00:18:08,660 --> 00:18:10,730
0,600 600,660 660,1140 1170,1440 1440,2070
reliability of your current implementation.|
|

643
00:18:11,640 --> 00:18:13,290
0,300 300,450 450,900 930,1590 1590,1650
Yeah, so the reliability of
是的，所以现在实现的可靠性不是很高，

644
00:18:13,290 --> 00:18:15,270
0,60 60,330 330,780 780,1440 1680,1980
the current implementation is not

645
00:18:15,270 --> 00:18:17,460
0,420 780,1590 1590,1800 1800,1860 1860,2190
great,| mostly because the servers
|主要是因为服务器没有被复制，

646
00:18:17,460 --> 00:18:19,110
0,180 180,810 1260,1470 1470,1560 1560,1650
aren't replicated,| so for the
|所以对于代理来说，

647
00:18:19,110 --> 00:18:21,040
0,660 660,840 840,1770
proxies,| {} because,
|因为，客户广播代理，

648
00:18:21,450 --> 00:18:23,100
0,240 240,600 600,1110 1110,1200 1200,1650
the clients broadcast the proxies,|
|

649
00:18:23,100 --> 00:18:24,450
0,210 210,270 270,720 720,900 900,1350
all you require is that
你所需要的就是其中一个代理启动，

650
00:18:24,780 --> 00:18:25,590
0,210 210,270 270,360 360,690 690,810
one of the proxies is

651
00:18:25,590 --> 00:18:26,140
0,240
up,|
|

652
00:18:26,540 --> 00:18:27,050
0,180 180,240 240,300 300,390 390,510
so if we have two
如果我们有两个代理，

653
00:18:27,050 --> 00:18:29,120
0,510 600,1110 1140,1530 1530,1860 1860,2070
proxies,| we can tolerate one
|我们可以容忍一个代理失败，

654
00:18:29,120 --> 00:18:30,080
0,390 390,450 450,510 510,870 870,960
failure of the proxies,| and
|我们仍然会获得到服务器的消息，

655
00:18:30,080 --> 00:18:31,610
0,120 120,360 360,750 870,990 990,1530
we'll still get the messages

656
00:18:31,610 --> 00:18:33,740
0,480 570,900 900,960 960,1500 1770,2130
to {} the servers,| but
|但如果任何一台服务器出现故障，

657
00:18:33,800 --> 00:18:34,640
0,240 240,420 420,510 510,570 570,840
if any of the servers

658
00:18:34,640 --> 00:18:35,780
0,180 180,630 660,840 840,960 960,1140
goes down,| then you're just
|那么你就不能根据这些数据进行重建了。

659
00:18:35,780 --> 00:18:36,950
0,120 120,240 240,480 480,600 600,1170
not going to be reconstruct

660
00:18:37,100 --> 00:18:38,030
0,150 150,240 240,600 630,750 750,930
on the data for that.|
|

661
00:18:41,670 --> 00:18:42,870
0,240 240,420 420,600 600,870 870,1200
{} Is it only for
这只是对于和吗，

662
00:18:42,870 --> 00:18:44,310
0,540 540,690 690,840 840,960 960,1440
sums| or did you implemented
|或者，你是否实现了对所有这些输入进行操作的任何通用函数？

663
00:18:44,310 --> 00:18:46,410
0,420 600,930 930,1380 1380,1860 1860,2100
for any general function that

664
00:18:46,410 --> 00:18:48,000
0,390 390,840 900,1140 1140,1350 1350,1590
operates on the all those

665
00:18:48,000 --> 00:18:48,840
0,630
inputs?|
|

666
00:18:49,620 --> 00:18:51,450
0,390 390,570 570,1140 1170,1680 1680,1830
Yeah, for now, {} I've
是的，目前，我只实现了和，

667
00:18:51,450 --> 00:18:53,220
0,420 420,840 840,960 960,1320 1320,1770
only implemented for sums,| but
|但使用这种相加的秘密共享方案，

668
00:18:53,220 --> 00:18:54,750
0,510 510,780 780,990 990,1320 1320,1530
basically with this additive secret

669
00:18:54,750 --> 00:18:56,100
0,180 180,570 600,930 930,1020 1020,1350
sharing scheme,| you can compute
|你可以计算任何你想要的线性函数，

670
00:18:56,100 --> 00:18:58,260
0,570 600,1110 1230,1680 1680,1800 1800,2160
any linear function you want,|
|

671
00:18:59,000 --> 00:19:00,320
0,450 450,690 690,870 870,1170 1170,1320
and maybe more complex ones
也许更复杂的问题是可能的，

672
00:19:00,320 --> 00:19:02,150
0,60 60,450 450,750 870,1440 1590,1830
are possible,| but I'm still
|但我还没有探索过这些，

673
00:19:02,150 --> 00:19:03,300
0,150 150,450 450,600 600,810
haven't explored those yet,|
|

674
00:19:04,100 --> 00:19:04,940
0,150 150,300 300,510 540,690 690,840
it turns out at least
事实证明，至少在实践中，

675
00:19:04,940 --> 00:19:06,830
0,570 570,1080 1080,1440 1440,1650 1650,1890
in practice,| sums probably get
|和可能会达到 90% 的水平。

676
00:19:06,830 --> 00:19:08,150
0,360 390,1080 1080,1140 1140,1200 1200,1320
like {90%,of -} the way

677
00:19:08,150 --> 00:19:08,820
0,390
there.|
|

678
00:19:10,350 --> 00:19:12,030
0,630 630,1050 1050,1440 1440,1500 1500,1680
{} So what do you
那么，你的性能数据是什么样子的？

679
00:19:12,510 --> 00:19:14,140
0,210 210,660 660,930 930,1320
performance numbers looked like?|
|

680
00:19:14,790 --> 00:19:16,500
0,540 540,840 840,1200 1290,1590 1590,1710
Performance numbers, yeah,| so the
性能数字，是的，|所以我们想要衡量的主要事情是，

681
00:19:16,500 --> 00:19:17,220
0,210 210,390 390,480 480,630 630,720
main things we want to

682
00:19:17,220 --> 00:19:19,170
0,570 570,1110 1200,1560 1560,1650 1650,1950
measure are,| for the client
|对于客户端，计算和客户端带宽，

683
00:19:19,170 --> 00:19:20,910
0,300 300,900 900,1050 1050,1620 1620,1740
side clients on computation and

684
00:19:20,910 --> 00:19:21,980
0,300 300,840
client bandwidth,|
|

685
00:19:22,080 --> 00:19:23,400
0,330 330,630 630,840 840,1230 1230,1320
I have some numbers,| at
我有一些数字，|至少对于客户端计算而言，

686
00:19:23,400 --> 00:19:25,050
0,120 120,240 240,480 480,1200 1290,1650
least for client computation,| I'm
|这些共享，而这些证明只需不到几毫秒，

687
00:19:25,050 --> 00:19:26,340
0,450 450,630 630,1050 1050,1140 1140,1290
generating these shares and these

688
00:19:26,340 --> 00:19:27,930
0,330 330,570 570,1110 1110,1440 1440,1590
proofs takes less than a

689
00:19:27,930 --> 00:19:29,370
0,150 150,720 720,930 930,1050 1050,1440
few milliseconds,| so it's very
|所以它非常轻，

690
00:19:29,490 --> 00:19:31,410
0,780 960,1080 1080,1440 1440,1680 1680,1920
lightweight,| the bandwidth is just
|带宽只有几千字节，

691
00:19:31,410 --> 00:19:32,540
0,30 30,180 180,930
a few kilobytes,|
|

692
00:19:32,840 --> 00:19:34,700
0,210 210,420 420,1080 1110,1440 1440,1860
and then for the throughput
然后对于服务器端的吞吐量，

693
00:19:34,700 --> 00:19:36,020
0,90 90,150 150,390 390,810 840,1320
on the server side, {}|
|

694
00:19:36,140 --> 00:19:37,400
0,390 390,600 600,810 810,990 990,1260
actually ran on {EC2 -},|
我是在使用 EC2 ，|

695
00:19:37,400 --> 00:19:38,660
0,150 150,240 240,420 420,900 900,1260
but I only allocated four
但我只给每台服务器分配了四个核心，

696
00:19:38,660 --> 00:19:41,420
0,450 450,570 570,1020 1620,2220 2430,2760
cores to each server,| because
|因为我只有 64 个核心，

697
00:19:41,420 --> 00:19:42,350
0,60 60,180 180,300 300,690 690,930
I only had 64 cores,|
|

698
00:19:42,350 --> 00:19:42,950
0,90 90,150 150,390 390,540 540,600
and I wanted most of
我希望它们中的大多数都在客户端上，

699
00:19:42,950 --> 00:19:43,490
0,120 120,180 180,360 360,480 480,540
them to be on the

700
00:19:43,490 --> 00:19:44,870
0,330 330,420 420,450 450,720 900,1380
client,| so I could remove
|这样我就能消除这个瓶颈，

701
00:19:44,870 --> 00:19:46,160
0,120 120,660 810,1050 1050,1170 1170,1290
that bottleneck,| and so at
|所以，在四个核心上，

702
00:19:46,160 --> 00:19:47,600
0,240 240,630 630,750 750,1230
four cores,| I think,
|我想，那是什么，

703
00:19:49,450 --> 00:19:50,590
0,180 180,270 270,480 480,690 690,1140
what is that,| probably like
|可能每秒有一千个查询，

704
00:19:50,920 --> 00:19:52,420
0,150 150,540 540,900 900,1020 1020,1500
a thousand queries per second,|
|

705
00:19:52,780 --> 00:19:54,040
0,180 180,330 330,870 870,960 960,1260
and then estimating I guess
然后估计，我猜如果每台机器并行 20 台服务器，

706
00:19:54,040 --> 00:19:56,950
0,240 240,750 1020,2340 2340,2610 2610,2910
if you parallelize by twenty

707
00:19:56,950 --> 00:19:58,300
0,330 330,420 420,570 570,840 840,1350
servers for each logical machine,|
|

708
00:19:58,360 --> 00:19:59,740
0,330 330,450 450,690 690,1080 1080,1380
they can probably achieve close
它们可能每秒可以实现近 22000 次查询，

709
00:19:59,740 --> 00:20:02,260
0,600 630,930 930,1380 1410,2400 2400,2520
to {22000,queries - -} per

710
00:20:02,260 --> 00:20:02,900
0,420
second,|
|

711
00:20:03,110 --> 00:20:04,550
0,300 330,540 540,630 630,870 870,1440
but this is all run
但这些都是在同一个数据中心运行的，

712
00:20:04,550 --> 00:20:05,390
0,120 120,180 180,360 360,600 600,840
on the same data center,|
|

713
00:20:05,390 --> 00:20:06,440
0,90 90,150 150,450 450,720 720,1050
so it doesn't factor into
所以，它不会影响延迟，

714
00:20:06,860 --> 00:20:08,810
0,660 690,1230 1350,1500 1500,1770 1770,1950
latency,| so the actual numbers
|实际数字可能会比这个数字低一点。

715
00:20:08,810 --> 00:20:09,500
0,90 90,330 330,510 510,540 540,690
will probably be a little

716
00:20:09,500 --> 00:20:10,400
0,90 90,270 270,390 390,600
bit lower than that.|
|

717
00:20:12,040 --> 00:20:12,940
0,120 120,210 210,270 270,570 570,900
I had a question about
我对你的实现有一个问题，

718
00:20:12,940 --> 00:20:14,740
0,180 180,1110 1230,1530 1530,1680 1680,1800
your implementation,| {} how do
|你如何，

719
00:20:14,740 --> 00:20:15,660
0,240 240,570
you do,|
|

720
00:20:16,010 --> 00:20:17,720
0,240 240,420 420,510 510,1140 1320,1710
so how do you actually
你如何实现的知识证明代码，不是理论上的。

721
00:20:17,720 --> 00:20:19,430
0,510 540,840 840,1140 1140,1530 1530,1710
implement your knowledge proofs {}

722
00:20:19,430 --> 00:20:21,460
0,510 690,1080 1080,1650
code not theoretical.|
|

723
00:20:21,770 --> 00:20:23,780
0,450 480,720 720,1290 1290,1470 1470,2010
Yeah, that's a great question,|
是的，这是个很好的问题，|

724
00:20:24,170 --> 00:20:25,280
0,570 570,720 720,930 930,1020 1020,1110
I can send you the
我可以把我实现的论文发送给你，

725
00:20:25,280 --> 00:20:27,830
0,510 1080,1440 1440,1950 1950,2430 2430,2550
paper, that I implemented it

726
00:20:27,830 --> 00:20:28,460
0,300
out,|
|

727
00:20:28,950 --> 00:20:30,750
0,540 540,1170 1200,1440 1440,1680 1680,1800
but it's it's not too
但这并不太复杂，

728
00:20:30,750 --> 00:20:32,340
0,600 600,1170 1170,1290 1290,1530 1530,1590
complicated,| basically it's just a
|基本上，它只是一堆有限域运算，

729
00:20:32,340 --> 00:20:33,870
0,210 210,330 330,690 690,900 900,1530
bunch of [finite] field operations,|
|

730
00:20:33,870 --> 00:20:34,560
0,120 120,210 210,300 300,420 420,690
and so if you find
如果你找到你的文件库，

731
00:20:34,560 --> 00:20:35,790
0,120 120,510 510,840 840,1020 1020,1230
your [file] library,| just follow
|只要按照论文，遵循步骤，

732
00:20:35,790 --> 00:20:36,990
0,90 90,600 840,990 990,1140 1140,1200
the paper and follow the

733
00:20:36,990 --> 00:20:38,780
0,570 930,1050 1050,1230 1230,1530
steps| and it's {}
|从这一点上来说，这是非常简单的，

734
00:20:39,100 --> 00:20:40,030
0,210 210,360 360,570 570,840 840,930
so much {straightforward -} from

735
00:20:40,030 --> 00:20:41,020
0,150 150,480 630,750 750,870 870,990
that point,| as long as
|只要你能解密那个论文。

736
00:20:41,020 --> 00:20:41,800
0,90 90,450
you can

737
00:20:42,340 --> 00:20:43,600
0,360 360,480 480,960
decrypt the paper.|
|

738
00:20:44,020 --> 00:20:45,430
0,390 390,570 570,690 690,990 1080,1410
Okay, and is that and
好的，有没有可能测试它，

739
00:20:45,490 --> 00:20:46,810
0,180 180,420 420,780 780,900 900,1320
is it possible to like

740
00:20:46,840 --> 00:20:49,160
0,390 390,720 1260,2010
test that,| like,
|你怎么知道它起作用了还是没有起作用。

741
00:20:49,460 --> 00:20:50,120
0,180 180,330 330,480 480,570 570,660
like, how would you know

742
00:20:50,120 --> 00:20:51,110
0,180 180,330 330,660 660,780 780,990
that it's working or not

743
00:20:51,110 --> 00:20:52,850
0,510 960,1230 1230,1350 1350,1410 1410,1740
working.| Yeah, so I guess,|
|是的，所以我想，|

744
00:20:52,880 --> 00:20:53,600
0,180 180,270 270,450 450,660 660,720
yeah, I only showed the
是的，我只展示了诚实的客户端模拟，

745
00:20:53,600 --> 00:20:55,760
0,450 450,750 750,1350 1530,1830 1830,2160
simulation with a honest clients,|
|

746
00:20:55,760 --> 00:20:57,080
0,150 150,270 270,390 390,750 750,1320
but you can also generate
但是，你也可以生成与提交错误证据的客户的模拟，

747
00:20:57,230 --> 00:20:58,850
0,210 210,600 600,1230 1260,1530 1530,1620
a simulation with clients that

748
00:20:58,850 --> 00:21:00,110
0,150 150,660 660,900 900,1140 1140,1260
{} submit bad proofs,| and
|然后你可以看到它们被拒绝了。

749
00:21:00,110 --> 00:21:01,640
0,300 450,630 630,750 750,1110 1350,1530
then you can see them

750
00:21:01,640 --> 00:21:02,520
0,180 180,660
being rejected.|
|

751
00:21:02,960 --> 00:21:04,100
0,300 300,480 480,630 630,810 810,1140
Okay, yeah, that makes sense,
好的，是的，有道理，谢谢。

752
00:21:04,100 --> 00:21:05,260
0,270 270,420 450,840
thank you.| Yeah.|
|好的。|

753
00:21:10,280 --> 00:21:13,730
0,510 780,1410 1560,1770 1770,2250 2640,3450
Great, thanks, pretty [],| is
好的，谢谢，很[]，|下一组准备好了吗？

754
00:21:13,730 --> 00:21:14,780
0,210 210,570 570,840 840,960 960,1050
the next group ready to

755
00:21:14,780 --> 00:21:15,540
0,390
go?|
|

756
00:21:17,760 --> 00:21:18,640
0,600

757
00:21:20,140 --> 00:21:20,900
0,630

758
00:21:22,300 --> 00:21:25,570
0,570 660,1410 1410,1890 1890,2550 2550,3270
{} Hello, I'm Shannon and
你好，我是香农、尼克和约翰，

759
00:21:25,600 --> 00:21:27,850
0,630 630,840 840,1140 1140,1680 1680,2250
Nik {and,Johan} on here,| so
|所以约翰把它拿走了。

760
00:21:28,450 --> 00:21:29,940
0,540 540,750 750,870 870,1230
Johan take it away.|
|

761
00:21:32,850 --> 00:21:34,260
0,360 360,480 480,900 1050,1260 1260,1410
Thank you, Shannon,| so we'll
谢谢你，香农|所以我们将谈论BukaDocs，

762
00:21:34,260 --> 00:21:35,520
0,60 60,300 300,540 540,720 720,1260
be talking about {BukaDocs -},|
|

763
00:21:35,550 --> 00:21:36,690
0,180 180,480 480,660 660,900 900,1140
{BukaDocs -} is a {distributive
BukaDocs是一个分布式协同编辑器，

764
00:21:36,690 --> 00:21:38,940
0,240 240,780 780,1320 1650,1920 1920,2250
-} collaborative editor,| it's similar
|它类似于谷歌文档，

765
00:21:38,940 --> 00:21:39,810
0,60 60,270 270,600 600,810 810,870
to Google docs,| just a
|只是稍微好一点，

766
00:21:39,810 --> 00:21:42,750
0,180 180,300 300,750 1320,2070 2370,2940
little bit better,| {} so
|因此，要进入下一张幻灯片，

767
00:21:42,750 --> 00:21:43,680
0,120 120,300 300,510 510,570 570,930
to move onto the next

768
00:21:43,680 --> 00:21:46,020
0,720 1410,1620 1620,1770 1770,2010 2010,2340
slide,| can you look next
|你能帮我找找下一个吗。

769
00:21:46,020 --> 00:21:46,640
0,120 120,390
for them.|
|

770
00:21:47,140 --> 00:21:48,820
0,450 780,1200 1200,1350 1350,1500 1500,1680
Okay, so as you've seen
好的，就像你们在这节课上看到的，

771
00:21:48,820 --> 00:21:50,650
0,60 60,180 180,570 570,1230 1230,1830
in this class,| achieving consistency
|在分布式系统中实现一致性是非常困难的，

772
00:21:50,650 --> 00:21:51,640
0,150 150,420 420,750 750,840 840,990
is very hard to do

773
00:21:51,640 --> 00:21:53,020
0,60 60,120 120,570 570,1080
in the distributed system,|
|

774
00:21:53,140 --> 00:21:54,490
0,330 330,420 420,720 720,990 990,1350
there are many ways that
一致性可能会在很多方面出错，

775
00:21:54,520 --> 00:21:56,920
0,630 630,840 840,1020 1020,1530 1920,2400
consistency could go wrong,| so
|所以一个非常简单的例子是，

776
00:21:56,920 --> 00:21:58,360
0,120 120,330 330,570 570,1020 1020,1440
a very simple example is,|
|

777
00:21:58,360 --> 00:21:59,230
0,180 180,300 300,630 630,750 750,870
if the order that you
如果您在每个对等端中收到RPC的顺序不同，

778
00:21:59,230 --> 00:22:01,660
0,360 360,1020 1050,1500 1500,1740 1740,2430
received {RPCs -} is different

779
00:22:01,840 --> 00:22:03,400
0,180 180,390 390,960 1110,1290 1290,1560
in each peer,| you might
|你可能最终会得到一个不一致的状态，

780
00:22:03,400 --> 00:22:04,450
0,120 120,300 300,450 450,540 540,1050
end up with an inconsistent

781
00:22:04,450 --> 00:22:05,140
0,540
state,|
|

782
00:22:06,100 --> 00:22:08,470
0,720 990,1290 1290,1380 1380,1650 1650,2370
and there's a data structure
还有一种叫做CRDT的数据结构，

783
00:22:09,220 --> 00:22:10,870
0,630 630,810 810,900 900,1380 1380,1650
called {CRDTs - -},| which
|我们在我们的系统中使用它来缓解这个问题，

784
00:22:10,870 --> 00:22:12,040
0,150 150,360 360,450 450,600 600,1170
we use in our system

785
00:22:12,820 --> 00:22:15,670
0,360 360,750 750,900 900,2040 2070,2850
to mitigate this issue,| CRDTs
|CRDT最终实现一致性，

786
00:22:15,670 --> 00:22:19,750
0,840 870,1440 1830,2430 2430,3180 3630,4080
achieve {} eventually consistency,| by
|通过对文档进行每一次操作，

787
00:22:19,750 --> 00:22:21,640
0,450 450,750 750,1080 1080,1770 1770,1890
making every single operation that

788
00:22:21,640 --> 00:22:22,810
0,120 120,360 360,450 450,510 510,1170
you make on the document,|
|

789
00:22:22,930 --> 00:22:24,910
0,600 600,1140 1170,1470 1470,1650 1650,1980
globally unique,| not just unique
全球独一无二的|不仅对每个同级都是唯一的，而且是全球独一无二的，

790
00:22:24,910 --> 00:22:26,290
0,90 90,240 240,480 480,1080 1140,1380
to every single peer, but

791
00:22:26,290 --> 00:22:27,700
0,390 390,870 960,1170 1170,1260 1260,1410
globally unique,| so if I
|所以如果我按下我的编辑的字母a，

792
00:22:27,700 --> 00:22:28,840
0,150 150,270 270,570 570,900 900,1140
press the letter a on

793
00:22:28,840 --> 00:22:30,700
0,180 180,720 1020,1290 1290,1680 1680,1860
my editor,| it's different from
|这不同于香农或尼克把字母a压在他们的编辑身上，

794
00:22:30,700 --> 00:22:31,900
0,420 420,540 540,780 780,1080 1080,1200
Shannon or Nik pressing the

795
00:22:31,900 --> 00:22:33,160
0,270 270,450 450,600 600,870 870,1260
letter a on their editor,|
|

796
00:22:34,280 --> 00:22:36,020
0,360 360,480 480,810 810,1380 1410,1740
so, for example here even
所以，举个例子，即使这里的底部，

797
00:22:36,020 --> 00:22:37,440
0,450 480,1110
if {}

798
00:22:37,680 --> 00:22:38,940
0,270 270,570 570,870 870,960 960,1260
the bottom here,| for example
|例如，这里将一个新的海龟添加到文档中，

799
00:22:38,940 --> 00:22:41,430
0,480 510,870 870,990 990,1980 2010,2490
here adds a new turtle

800
00:22:41,430 --> 00:22:42,580
0,120 120,180 180,870
to a document,|
|

801
00:22:43,260 --> 00:22:45,270
0,300 300,420 420,570 570,1350 1410,2010
even if they receive remove
即使它们接收到来自其他两个对等体的移除请求，

802
00:22:45,270 --> 00:22:47,370
0,840 1020,1500 1500,1620 1620,1920 1920,2100
request from the other two

803
00:22:47,370 --> 00:22:49,440
0,660 720,900 900,1050 1050,1500 1500,2070
peers,| they will never remove
|他们永远不会移走金海龟，

804
00:22:49,440 --> 00:22:51,240
0,150 150,510 510,1020 1350,1740 1740,1800
the golden turtle,| because the
|因为该操作本身不同于删除，

805
00:22:51,240 --> 00:22:53,340
0,480 480,600 600,1020 1020,1470 1470,2100
operation is itself different from

806
00:22:53,550 --> 00:22:56,280
0,780 960,1470 1470,1980 1980,2340 2340,2730
remove,| so remove green turtle
|所以去掉绿龟和去掉金龟是不同的。

807
00:22:56,280 --> 00:22:58,200
0,180 180,540 540,780 780,1410 1560,1920
is different from remove gold

808
00:22:58,200 --> 00:22:59,460
0,540
turtle.|
|

809
00:22:59,980 --> 00:23:01,150
0,240 240,690 690,870 870,990 990,1170
And this, this is how
这，这就是我们实现最终一致性的方式，

810
00:23:01,150 --> 00:23:03,640
0,300 300,720 720,1080 1080,1710 2070,2490
we achieve eventual consistency,| so
|所以从这里开始，我相信尼克会更多地谈一谈这里的情况，

811
00:23:03,640 --> 00:23:04,720
0,150 150,510 510,570 570,870 870,1080
from here, I believe Nik

812
00:23:04,720 --> 00:23:05,380
0,240 240,390 390,450 450,630 630,660
is going to talk a

813
00:23:05,380 --> 00:23:07,060
0,150 150,330 330,540 540,1050 1350,1680
little bit more about what

814
00:23:07,060 --> 00:23:08,170
0,120 120,450 450,660 660,750 750,1110
is here,| how we implement
|我们如何实现[][Entities]。

815
00:23:08,170 --> 00:23:09,100
0,150 150,720
[] [entities].|
|

816
00:23:09,600 --> 00:23:11,500
0,1800
Yeah,
是的，对于Bukadocs，我们选择了一种名为LSEQ的CRDT，

817
00:23:11,700 --> 00:23:13,740
0,540 570,1020 1020,1290 1290,1740 1740,2040
so for {Bukadocs -}, we

818
00:23:13,740 --> 00:23:15,030
0,300 300,360 360,510 510,810 810,1290
chose to use a CRDT

819
00:23:15,030 --> 00:23:16,470
0,330 330,450 450,930 990,1140 1140,1440
called {LSEQ -},| {} which
|其表示具有可变长度密钥的元素序列，

820
00:23:16,470 --> 00:23:18,870
0,450 450,570 570,1260 1290,1740 1860,2400
represents a sequence of elements

821
00:23:18,870 --> 00:23:20,640
0,240 240,630 630,900 900,1380 1560,1770
with variable length keys,| so
|所以我们的目标是，

822
00:23:20,640 --> 00:23:22,320
0,90 90,420 420,1140 1260,1560 1560,1680
the goal is,| let's say
|假设我们想要一个表示字母表的序列

823
00:23:22,320 --> 00:23:23,670
0,150 150,330 330,660 660,1230 1230,1350
we want a sequence that

824
00:23:23,670 --> 00:23:25,050
0,360 360,510 510,1050 1050,1200 1200,1380
represents the alphabet| and so
|到目前为止，我们有字母a和c，

825
00:23:25,050 --> 00:23:26,040
0,180 180,300 300,510 510,600 600,990
far we have the letters

826
00:23:26,040 --> 00:23:27,040
0,240 240,360 360,810
a and c,|
|

827
00:23:27,460 --> 00:23:28,900
0,210 210,510 510,870 870,1140 1140,1440
so one editor might choose
因此，一位编辑可能会选择尝试在它们之间添加字母b

828
00:23:28,900 --> 00:23:30,040
0,120 120,300 300,810 810,900 900,1140
to try adding the letter

829
00:23:30,040 --> 00:23:32,230
0,390 450,1050 1050,1440 1680,1890 1890,2190
b between them| and another
|并且另一编辑可以选择尝试在C之后添加字母D，

830
00:23:32,230 --> 00:23:33,340
0,390 390,540 540,870 870,930 930,1110
editor may choose to try

831
00:23:33,340 --> 00:23:35,140
0,360 360,450 450,780 780,1260 1440,1800
adding the letter d after

832
00:23:35,140 --> 00:23:35,700
0,330
c,|
|

833
00:23:35,890 --> 00:23:36,880
0,300 300,480 480,570 570,840 840,990
{} and the goal is
我们的目标是通过最终的一致性，

834
00:23:36,880 --> 00:23:38,770
0,210 210,360 360,720 720,1560 1650,1890
that with eventual consistency, {}|
|

835
00:23:38,770 --> 00:23:40,480
0,210 210,540 540,900 900,1140 1140,1710
will eventually reach the state
最终会到达国家a、b、c、d，

836
00:23:40,480 --> 00:23:42,010
0,90 90,240 240,480 480,780 1170,1530
a b c d, {}|
|

837
00:23:42,040 --> 00:23:42,850
0,180 180,270 270,390 390,540 540,810
so the way that LSEQ
因此，LSEQ实现这一点的方式是，

838
00:23:42,850 --> 00:23:44,440
0,360 360,840 930,1080 1080,1230 1230,1590
achieves this is,| by using
|通过使用开始和结束令牌，

839
00:23:44,440 --> 00:23:45,880
0,150 150,570 570,780 780,990 990,1440
a START and END token,|
|

840
00:23:46,350 --> 00:23:47,550
0,180 180,330 330,510 510,870 870,1200
and then it gives every
然后它给文档中的每个字符一个单独的令牌，

841
00:23:47,550 --> 00:23:49,830
0,780 810,1110 1110,1200 1200,1920 2010,2280
character in the document an

842
00:23:49,830 --> 00:23:51,510
0,480 480,840 840,990 990,1110 1110,1680
individual token,| that is between
|这是在开始和结束之间，

843
00:23:51,510 --> 00:23:52,260
0,90 90,300 300,390 390,480 480,750
the start and the end,|
|

844
00:23:52,560 --> 00:23:53,670
0,210 210,300 300,390 390,810 810,1110
so we can insert h
所以我们可以在开头和结尾之间插入h，

845
00:23:53,670 --> 00:23:55,620
0,360 360,840 840,1350 1680,1890 1890,1950
between start end,| if we
|如果我们想要h之后的字母i，

846
00:23:55,620 --> 00:23:57,030
0,330 330,390 390,660 660,1020 1020,1410
want the letter i after

847
00:23:57,030 --> 00:23:58,350
0,510 600,780 780,840 840,990 990,1320
h,| then we can insert
|然后我们可以把它插入到7，这是在4和End之间，

848
00:23:58,350 --> 00:23:59,610
0,210 210,420 420,810 810,1140 1140,1260
that at 7, which is

849
00:23:59,610 --> 00:24:00,760
0,360 360,540 540,660 660,990
between 4 and end,|
|

850
00:24:01,060 --> 00:24:01,840
0,420 420,510 510,570 570,690 690,780
now, if we want to
现在，如果我们想在i和文档末尾之间插入一个感叹号，

851
00:24:01,840 --> 00:24:03,790
0,450 450,600 600,1170 1170,1530 1530,1950
insert an exclamation point between

852
00:24:03,790 --> 00:24:04,810
0,390 390,540 540,660 660,900 900,1020
i and the end of

853
00:24:04,810 --> 00:24:06,370
0,60 60,630 870,1140 1140,1260 1260,1560
the document,| we can insert
|我们可以用键72插入它，

854
00:24:06,370 --> 00:24:07,540
0,90 90,240 240,300 300,600 600,1170
it with the key {7,2

855
00:24:07,540 --> 00:24:09,130
0,390 390,690 870,1050 1050,1170 1170,1590
- -},| so we increase
|因此我们增加一个或两个密钥长度以在相邻两个其他密钥之间创建密钥，

856
00:24:09,130 --> 00:24:11,230
0,300 300,780 810,990 990,1530 1560,2100
key length or two to

857
00:24:11,350 --> 00:24:12,820
0,420 420,450 450,750 750,1230 1230,1470
create {} key between two

858
00:24:12,820 --> 00:24:14,440
0,360 360,690 690,840 840,1080 1080,1620
other keys that are adjacent,|
|

859
00:24:14,890 --> 00:24:15,670
0,180 180,270 270,420 420,660 660,780
so in this way, we
因此，通过这种方式，我们始终可以在任何两个其他密钥之间创建一个密钥，

860
00:24:15,670 --> 00:24:16,810
0,150 150,480 480,750 750,840 840,1140
can always create a key

861
00:24:16,810 --> 00:24:18,790
0,420 420,690 690,1140 1170,1440 1440,1980
between any two other keys,|
|

862
00:24:19,000 --> 00:24:20,410
0,390 390,780 810,930 930,1080 1080,1410
{} so we can always
所以我们可以随时插入，

863
00:24:20,410 --> 00:24:20,920
0,390
insert,|
|

864
00:24:21,540 --> 00:24:24,780
0,540 690,1020 1290,1800 2310,2760 2760,3240
{} now LSEQ forms well,|
现在LSEQ很好地形成了，|

865
00:24:24,780 --> 00:24:25,890
0,150 150,330 330,630 630,810 810,1110
{} in that it reaches
因为它以很少的协调努力达到了最终的一致性，

866
00:24:25,890 --> 00:24:27,810
0,360 360,1080 1080,1410 1410,1680 1680,1920
eventual consistency with very little

867
00:24:27,810 --> 00:24:30,390
0,300 300,390 390,1050 1470,2100 2220,2580
effort for coordination,| {} and
|它还进行了一些优化，导致密钥的长度增长相对较慢。

868
00:24:30,390 --> 00:24:31,800
0,240 240,420 420,510 510,1170 1170,1410
it has some optimizations that

869
00:24:31,800 --> 00:24:33,300
0,570 600,810 810,1200 1230,1410 1410,1500
cause the length of the

870
00:24:33,300 --> 00:24:35,010
0,360 360,480 480,750 750,1230 1230,1710
keys to grow relatively slowly.|
|

871
00:24:36,000 --> 00:24:38,520
0,420 450,1170 1200,1410 1410,2160 2220,2520
{} However, {} {some,cons} {}
然而，一些缺点是，为了支持删除这些元素，

872
00:24:38,520 --> 00:24:39,690
0,180 180,510 540,750 750,990 990,1170
are that in order to

873
00:24:39,690 --> 00:24:41,370
0,420 420,960 960,1080 1080,1230 1230,1680
support deletion of these elements,|
|

874
00:24:41,370 --> 00:24:43,110
0,150 150,540 540,720 720,1170 1170,1740
it relies on causal delivery
它依赖于因果交付和恰好一次交付，

875
00:24:43,110 --> 00:24:45,120
0,90 90,570 570,840 840,1350 1680,2010
and {exactly-once -} delivery, {}|
|

876
00:24:45,120 --> 00:24:46,110
0,270 270,480 480,660 660,840 840,990
and we didn't really want
我们并不是真的想要实现这一点，

877
00:24:46,110 --> 00:24:47,010
0,90 90,420 420,600 600,780 780,900
to implement this,| since it
|由于它是根据其他一些作品改编的，

878
00:24:47,040 --> 00:24:48,210
0,180 180,420 420,630 630,930 930,1170
was based off a number

879
00:24:48,210 --> 00:24:49,180
0,60 60,240 240,840
of other works,|
|

880
00:24:49,420 --> 00:24:50,080
0,240 240,390 390,480 480,570 570,660
{} so we use a
所以我们使用一种稍微简单一些的方法，即删除集，

881
00:24:50,080 --> 00:24:52,120
0,300 300,690 690,1260 1500,1770 1770,2040
slightly simpler approach, which was

882
00:24:52,120 --> 00:24:53,420
0,120 120,600 600,1020
a deletion set,|
|

883
00:24:53,660 --> 00:24:54,440
0,210 210,360 360,450 450,540 540,780
so this is a grow
这是一个仅增长的集合，我们在其中添加元素，

884
00:24:54,440 --> 00:24:55,520
0,240 240,540 540,690 690,840 840,1080
only set, where we add

885
00:24:55,520 --> 00:24:57,230
0,120 120,780 990,1380 1380,1560 1560,1710
in elements,| {} so for
|因此例如删除字母h和i，

886
00:24:57,230 --> 00:24:58,640
0,330 330,420 420,780 780,1140 1140,1410
instance to delete letters h

887
00:24:58,640 --> 00:24:59,600
0,180 180,450 450,630 630,750 750,960
and i,| we would add
|我们会把47添加到这个删除集中，

888
00:24:59,600 --> 00:25:01,010
0,150 150,510 540,960 960,1230 1230,1410
in 4 7 into this

889
00:25:01,010 --> 00:25:02,040
0,450 450,840
deletion set,|
|

890
00:25:02,580 --> 00:25:04,920
0,510 600,1290 1290,1620 1650,1950 1950,2340
{} then this whole state
然后，整个状态就相当于只需要开始和结束令牌

891
00:25:04,920 --> 00:25:06,450
0,330 330,810 810,1050 1050,1290 1290,1530
becomes equivalent to just having

892
00:25:06,450 --> 00:25:07,440
0,60 60,300 300,420 420,540 540,990
to start and end tokens|
|

893
00:25:07,440 --> 00:25:08,880
0,330 330,450 450,1050 1050,1320 1320,1440
and the exclamation point at
和键72上的感叹号。

894
00:25:08,880 --> 00:25:10,120
0,270 270,630 630,930
key 7 2.|
|

895
00:25:14,820 --> 00:25:15,720
0,180 180,270 270,480 480,570 570,900
So we built the Buka
所以我们建立了Buka Docs服务

896
00:25:15,720 --> 00:25:17,880
0,300 300,1020 1050,1740 1740,1980 1980,2160
docs service| similar to how
|类似于我们实施KV筏子的方式，

897
00:25:17,880 --> 00:25:19,380
0,120 120,600 600,960 960,1410 1410,1500
we implemented kv raft,| we
|我们有多台服务器、多个客户端

898
00:25:19,380 --> 00:25:21,600
0,210 210,690 690,1200 1200,1560 1560,2220
have multiple servers, multiple clients|
|

899
00:25:21,600 --> 00:25:23,520
0,540 780,1260 1260,1560 1560,1740 1740,1920
and multiple clients, they only
和多个客户端，它们一次只与一台服务器通信

900
00:25:23,520 --> 00:25:24,420
0,210 210,270 270,480 480,810 810,900
talk to one server at

901
00:25:24,420 --> 00:25:27,300
0,90 90,660 660,1140 1170,2010 2100,2880
a time| and they continuously
|并不断尝试操作，直到从服务器获得成功回复，

902
00:25:27,300 --> 00:25:28,620
0,180 180,300 300,900 900,1230 1230,1320
try the operations until they

903
00:25:28,620 --> 00:25:30,390
0,180 180,240 240,870 870,1440 1440,1770
get a successful reply from

904
00:25:30,390 --> 00:25:32,540
0,180 180,630
the server,|
|

905
00:25:34,320 --> 00:25:36,480
0,330 330,540 540,930 930,1230 1230,2160
clients and servers both maintain
客户端和服务器都维护文档中的字符的AVL树，

906
00:25:36,510 --> 00:25:38,130
0,540 570,1020 1020,1170 1170,1500 1500,1620
{} {an,AVL -} tree of

907
00:25:38,130 --> 00:25:39,630
0,570 570,660 660,720 720,1320 1320,1500
characters in the document,| as
|以及我们自己删除的删除密钥集，

908
00:25:39,630 --> 00:25:40,740
0,120 120,270 270,420 420,720 720,1110
well as our own deletion

909
00:25:40,740 --> 00:25:43,260
0,330 330,690 720,1170 1170,1770 2340,2520
set of removed keys, {}|
|

910
00:25:43,260 --> 00:25:45,720
0,150 150,600 600,1260 1350,2040 2040,2460
we chose to store characters
我们选择将字符存储在AVL树中，

911
00:25:45,720 --> 00:25:47,550
0,270 270,690 690,990 990,1350 1620,1830
in AVL tree,| for I
|我猜是出于性能原因，

912
00:25:47,550 --> 00:25:50,140
0,180 180,750 750,1320
guess performance reasons,|
|

913
00:25:50,340 --> 00:25:51,480
0,330 330,510 510,600 600,930 930,1140
the chain of events goes
事件的链条大概是这样的，

914
00:25:51,480 --> 00:25:52,740
0,300 300,510 510,810 810,1170 1170,1260
something like this,| so the
|因此客户端将向服务器发送插入和删除，

915
00:25:52,740 --> 00:25:54,330
0,330 330,420 420,810 810,1020 1020,1590
client will send an insertion

916
00:25:54,330 --> 00:25:55,530
0,120 120,420 420,510 510,630 630,1200
and deletion to the server,|
|

917
00:25:55,860 --> 00:25:57,210
0,150 150,450 450,840 840,1200 1200,1350
a server will update its
服务器将更新其自己的AVL树和删除集并持久保存，

918
00:25:57,210 --> 00:25:58,800
0,180 180,510 510,930 930,1200 1200,1590
own AVL tree and deletion

919
00:25:58,800 --> 00:26:00,870
0,390 390,660 660,1080 1080,1440 1830,2070
set and persist that,| and
|对于所有其他服务器和客户端的更新

920
00:26:00,870 --> 00:26:02,010
0,270 270,480 480,900 900,1020 1020,1140
for those updates to all

921
00:26:02,010 --> 00:26:03,300
0,120 120,360 360,750 750,840 840,1290
the other servers and clients|
|

922
00:26:03,300 --> 00:26:04,470
0,150 150,300 300,360 360,900 900,1170
and then the server will
然后服务器会向客户端响应成功。

923
00:26:04,470 --> 00:26:06,630
0,540 540,1230 1320,1680 1680,1740 1740,2160
respond success to the client.|
|

924
00:26:07,870 --> 00:26:10,330
0,750 1140,1290 1290,1560 1560,1710 1710,2460
So we're going to demo
所以我们要演示一下，

925
00:26:10,330 --> 00:26:12,160
0,330 870,1080 1080,1320 1320,1440 1440,1830
it,| we build a very
|我们在这里为它构建了一个非常简单的用户界面，

926
00:26:12,160 --> 00:26:14,890
0,900 1140,1620 1620,2040 2040,2280 2280,2730
simple {} UI for it

927
00:26:15,070 --> 00:26:15,860
0,570
here,|
|

928
00:26:15,940 --> 00:26:17,350
0,840 870,990 990,1080 1080,1230 1230,1410
so let me give it,|
所以让我来告诉你，|

929
00:26:18,350 --> 00:26:20,030
0,630 630,750 750,960 960,1080 1080,1680
Johan and Nik are also
约翰和尼克现在也在从不同的客户访问这个视频，

930
00:26:20,030 --> 00:26:22,790
0,570 1080,1680 1680,1860 1860,2100 2100,2760
{} accessing this from different

931
00:26:22,790 --> 00:26:25,220
0,540 540,660 660,1110 1440,1920 1920,2430
clients right now,| so you
|所以你可以看到他们在打字，

932
00:26:25,220 --> 00:26:27,170
0,180 180,300 300,480 480,1140 1500,1950
can see them typing, {}|
|

933
00:26:27,170 --> 00:26:29,570
0,60 60,450 450,750 750,1410 2160,2400
{you,can} type something else,| I'm
您可以输入其他内容，|我在这里打字，

934
00:26:29,570 --> 00:26:31,700
0,360 360,1170
typing here,|
|

935
00:26:34,210 --> 00:26:36,520
0,870 1380,1530 1530,1770 1770,2190 2190,2310
{} I think Johan is
我想约翰在打招呼，

936
00:26:36,520 --> 00:26:38,360
0,450 450,1230
typing hi,|
|

937
00:26:38,710 --> 00:26:40,810
0,420 420,540 540,1140 1140,1530 1530,2100
Nik is typing something here,|
尼克在这里打字，|

938
00:26:53,360 --> 00:26:54,560
0,330 330,450 450,660 660,960 960,1200
and we can edit each
我们还可以编辑彼此的文本。

939
00:26:54,560 --> 00:26:55,960
0,480 510,1080
others {}

940
00:26:56,380 --> 00:26:57,640
0,330 330,480 480,930
text as well.|
|

941
00:27:02,930 --> 00:27:03,880
0,630
Then,
那么，是的，那就是布卡医生，

942
00:27:04,650 --> 00:27:05,460
0,480
yeah,

943
00:27:05,660 --> 00:27:06,780
0,330 360,810
that is

944
00:27:07,140 --> 00:27:08,300
0,270 270,870
Buka Docs,|
|

945
00:27:09,310 --> 00:27:10,240
0,570

946
00:27:12,770 --> 00:27:15,290
0,600 690,990 990,1440 1440,1860 2040,2520
{} we're happy to answer
我想，我们很乐意回答任何问题。

947
00:27:15,290 --> 00:27:17,040
0,210 210,750 750,840 840,1410
any questions, I guess.|
|

948
00:27:21,550 --> 00:27:22,600
0,150 150,300 300,360 360,810 810,1050
I have a question here,|
我有一个问题，|

949
00:27:23,050 --> 00:27:24,910
0,660 660,930 930,1140 1140,1440 1440,1860
I really like the turtle
我真的很喜欢海龟的主题，

950
00:27:24,910 --> 00:27:25,900
0,240 240,390 390,510 510,810 810,990
theme,| that you guys came
|你们想出了这个

951
00:27:25,900 --> 00:27:26,530
0,180 180,270 270,480 480,570 570,630
up with this| and I
|我只是想知道海龟的主题是从哪里来的。

952
00:27:26,530 --> 00:27:27,880
0,120 120,360 360,780 780,1050 1050,1350
was just wondering where the,

953
00:27:27,910 --> 00:27:29,110
0,240 240,360 360,690 690,930 930,1200
where the turtle theme came

954
00:27:29,110 --> 00:27:30,000
0,570
from.|
|

955
00:27:30,930 --> 00:27:32,100
0,180 180,360 360,600 600,750 750,1170
Oh yeah, so the turtle
哦，是的，所以乌龟是尼克·约翰，我也通过IP教这门课

956
00:27:32,100 --> 00:27:34,170
0,390 450,1140 1140,1680 1680,1800 1800,2070
is Nik Johan and I

957
00:27:34,170 --> 00:27:36,660
0,270 660,1050 1050,1860 1890,2280 2280,2490
also taught the class over

958
00:27:36,660 --> 00:27:38,730
0,510 510,750 750,1140 1380,1890 1890,2070
IP| and the turtle is
|乌龟是我们班上的吉祥物

959
00:27:38,730 --> 00:27:40,170
0,120 120,750 750,840 840,930 930,1440
our mascot for the class|
|

960
00:27:40,170 --> 00:27:41,730
0,270 270,480 480,570 570,1500 1500,1560
and we are inspired to
我们受到启发，要建造布卡文档，

961
00:27:41,730 --> 00:27:43,140
0,210 210,480 480,780 780,1260 1260,1410
build Buka docs,| because we
|因为我们使用的Google Docs是一个针对学生提问的问题文档，

962
00:27:43,140 --> 00:27:44,310
0,360 360,690 690,1020 1020,1110 1110,1170
use Google docs is a

963
00:27:44,310 --> 00:27:46,470
0,810 870,1560 1560,1680 1680,1800 1800,2160
question document for the students

964
00:27:46,470 --> 00:27:47,670
0,240 240,630 630,780 780,900 900,1200
ask questions,| but it couldn't
|但它无法同时处理超过75个用户的输入

965
00:27:47,670 --> 00:27:48,960
0,420 420,600 600,900 900,1020 1020,1290
handle a load of over

966
00:27:48,960 --> 00:27:50,550
0,720 720,1050 1050,1380 1380,1500 1500,1590
75 users typing at the

967
00:27:50,550 --> 00:27:52,290
0,270 270,720 1020,1230 1230,1500 1500,1740
same time| and that's how
|布卡医生就是这样诞生的。

968
00:27:52,290 --> 00:27:53,760
0,300 300,630 630,750 750,1320
Buka docs was born.|
|

969
00:27:54,560 --> 00:27:56,840
0,240 240,420 420,1110 1800,1890 1890,2280
Thank you {for,ask}.| {That's,cool -}.|
谢谢你的问候。|那很酷啊。|

970
00:27:58,060 --> 00:27:59,560
0,150 150,690 690,750 750,930 930,1500
I had a quick question,|
我有一个简短的问题，|

971
00:27:59,740 --> 00:28:01,060
0,540 540,870 870,1050 1050,1260 1260,1320
{} and so first of
所以首先，我被称为小演示，

972
00:28:01,060 --> 00:28:02,110
0,330 330,420 420,570 570,780 780,1050
all, I got called little

973
00:28:02,110 --> 00:28:03,340
0,480 480,750 750,840 840,960 960,1230
presentation,| sorry, if you mentioned
|抱歉，如果你提到这一点，你可能已经，

974
00:28:03,340 --> 00:28:04,660
0,330 330,450 450,570 570,840 870,1320
this, you may have,| but
|但首先，第一个问题是为了确保我理解正确，

975
00:28:04,960 --> 00:28:07,420
0,720 840,1590 1770,2190 2190,2280 2280,2460
{} so first of all,

976
00:28:07,420 --> 00:28:08,380
0,180 180,600 600,750 750,840 840,960
first question just to make

977
00:28:08,380 --> 00:28:09,490
0,150 150,180 180,540 540,900 900,1110
sure I understood correctly,| is
|这些数据结构非常有趣，

978
00:28:09,490 --> 00:28:11,050
0,240 240,390 390,810 840,1200 1200,1560
the are these data structures

979
00:28:11,050 --> 00:28:11,980
0,150 150,210 210,390 390,750 750,930
which are very interesting,| they
|它们存储在客户端或服务器上，

980
00:28:11,980 --> 00:28:12,790
0,210 210,300 300,360 360,750 750,810
stored on the client or

981
00:28:12,790 --> 00:28:13,560
0,90 90,600
the server,|
|

982
00:28:14,090 --> 00:28:15,230
0,210 210,360 360,840 840,1050 1050,1140
if they're stored, on I
如果它们被存储在上，我想现在服务器上没有复制，

983
00:28:15,230 --> 00:28:16,160
0,360 360,510 510,630 630,720 720,930
imagine right now the server

984
00:28:16,160 --> 00:28:17,090
0,60 60,210 210,690 690,780 780,930
is not replicated,| but that's
|但这是你可以很容易做到的事情，

985
00:28:17,090 --> 00:28:18,260
0,210 210,330 330,480 480,750 750,1170
something you could easily do,|
|

986
00:28:18,290 --> 00:28:20,000
0,450 960,1170 1170,1410 1410,1590 1590,1710
but if they if they
但如果它们存储在客户端上，

987
00:28:20,000 --> 00:28:21,050
0,210 210,450 450,510 510,600 600,1050
are stored on the client,|
|

988
00:28:21,500 --> 00:28:22,280
0,240 240,510 510,600 600,720 720,780
what happens if one of
如果其中一个客户端出现故障会发生什么情况。

989
00:28:22,280 --> 00:28:23,380
0,60 60,390 390,900
the clients fails.|
|

990
00:28:24,500 --> 00:28:25,820
0,240 240,360 360,540 540,1080 1080,1320
So the data structures are
因此，数据结构实际上存储在所有客户端和所有服务器上，

991
00:28:25,820 --> 00:28:27,140
0,300 300,780 780,1050 1050,1260 1260,1320
actually stored on all the

992
00:28:27,140 --> 00:28:28,820
0,420 420,660 660,840 840,900 900,1680
clients and all the servers,|
|

993
00:28:29,660 --> 00:28:31,100
0,330 330,1080 1080,1230 1230,1350 1350,1440
and so right now, we're
所以现在，我们假设客户是完全值得信任的，

994
00:28:31,100 --> 00:28:32,180
0,300 300,360 360,720 720,840 840,1080
assuming the clients are fully

995
00:28:32,180 --> 00:28:34,790
0,840 1050,1710 1710,2130 2130,2370 2370,2610
trustworthy,| {} and so if
|因此，如果客户端出现故障，他们没有发送到服务器的任何编辑，

996
00:28:34,790 --> 00:28:36,770
0,330 330,900 900,1500 1500,1830 1830,1980
client fails, any edits they

997
00:28:36,770 --> 00:28:38,330
0,330 330,720 720,960 960,1020 1020,1560
haven't sent to a server,|
|

998
00:28:38,360 --> 00:28:39,800
0,240 240,690 690,1050 1050,1230 1230,1440
{} will just be on
在他们重新上线之前，他们只会一直呆在一边，

999
00:28:39,800 --> 00:28:41,000
0,240 240,540 540,870 870,1020 1020,1200
their end until they come

1000
00:28:41,000 --> 00:28:42,410
0,210 210,690 690,780 780,960 960,1410
back online,| in which case
|在这种情况下，他们可以发送

1001
00:28:42,530 --> 00:28:43,850
0,300 300,570 570,810 810,1050 1050,1320
they can send it| and
|它将实现最终的一致性。

1002
00:28:43,880 --> 00:28:45,890
0,120 120,480 540,1050 1050,1350 1350,2010
it will achieve eventual consistency.|
|

1003
00:28:47,180 --> 00:28:48,680
0,540 540,930 930,1200
Interesting, thank you.|
很有趣，谢谢。|

1004
00:28:49,850 --> 00:28:50,930
0,210 210,210 210,420 420,480 480,1080
Oh, I had a question,|
哦，我有个问题，|

1005
00:28:50,990 --> 00:28:52,550
0,180 180,630 630,990 990,1260 1260,1560
{} why {LSEQ -} over
为什么LSEQ胜过其他CRDT。

1006
00:28:52,550 --> 00:28:54,120
0,330 330,750 750,1290
other {CRDTs -}.|
|

1007
00:28:58,460 --> 00:28:59,690
0,360 360,510 510,630 630,1050 1050,1230
{} Yeah, we chose {LSEQ
是的，我们选择LSEQ主要是因为，

1008
00:28:59,690 --> 00:29:01,520
0,360 390,750 750,930 930,1590 1620,1830
-} mainly just because {},|
|

1009
00:29:01,520 --> 00:29:02,390
0,90 90,480 480,630 630,750 750,870
it was one of the
这是我们最先发现的

1010
00:29:02,390 --> 00:29:03,350
0,330 330,510 510,600 600,870 870,960
first ones we found| and
|我们想要开始

1011
00:29:03,350 --> 00:29:04,400
0,90 90,330 330,390 390,540 540,1050
we wanted to get started|
|

1012
00:29:04,580 --> 00:29:07,100
0,480 480,1230 1440,1890 1890,2400 2400,2520
and because after implementing the
并且因为在实现可变长度密钥的逻辑之后，

1013
00:29:07,100 --> 00:29:08,420
0,420 420,570 570,690 690,1080 1080,1320
logic of the variable length

1014
00:29:08,420 --> 00:29:09,860
0,480 480,660 660,870 870,1140 1140,1440
keys,| there was really not
|真的没有太多了，

1015
00:29:09,860 --> 00:29:10,520
0,210 210,390 390,510 510,600 600,660
much more,| we have to
|我们必须这样做，以确保，

1016
00:29:10,520 --> 00:29:11,690
0,270 270,450 450,690 690,930 930,1170
do in order to make

1017
00:29:11,690 --> 00:29:12,770
0,210 210,420 420,600 600,960 960,1080
sure,| that the clients and
|客户端和服务器保持一致。

1018
00:29:12,770 --> 00:29:14,100
0,360 360,600 600,1110
servers stayed consistent.|
|

1019
00:29:15,610 --> 00:29:16,930
0,240 240,630 660,870 870,990 990,1320
Oh, okay, thank you. {}|
哦，好的，谢谢。|

1020
00:29:16,930 --> 00:29:17,860
0,270 270,660 660,780 780,840 840,930
So beyond that it was
除此之外，它就像是消息传递

1021
00:29:17,860 --> 00:29:19,150
0,240 240,450 450,810 810,1200 1200,1290
just like message passing| and
|并确保每个人都收到了所有的信息。

1022
00:29:19,150 --> 00:29:20,200
0,270 270,420 420,720 720,930 930,1050
making sure everyone gets all

1023
00:29:20,200 --> 00:29:21,080
0,90 90,660
the messages.|
|

1024
00:29:22,100 --> 00:29:24,280
0,630 660,1200
Okay, thanks.|
好的，谢谢。|

1025
00:29:24,780 --> 00:29:25,890
0,210 210,330 330,510 510,1050 1050,1110
So, how many servers are
那么，在这个示例中，您运行了多少台服务器，

1026
00:29:25,890 --> 00:29:27,120
0,90 90,300 300,660 660,780 780,1230
you running within this example,|
|

1027
00:29:27,120 --> 00:29:27,900
0,150 150,240 240,420 420,660 660,780
was it just one or
是只有一个还是多个？

1028
00:29:27,900 --> 00:29:28,920
0,180 180,240 240,690
was it multiple?|
|

1029
00:29:30,080 --> 00:29:31,670
0,180 180,390 390,630 630,1260 1260,1590
There were three servers and
有三台服务器和三台客户端，

1030
00:29:31,670 --> 00:29:32,930
0,180 180,810 840,1050 1050,1200 1200,1260
three clients,| each one of
|每个客户端都连接到其自己的服务器已知的。

1031
00:29:32,930 --> 00:29:34,340
0,210 240,750 750,930 930,1260 1260,1410
the clients was connected to

1032
00:29:34,340 --> 00:29:35,540
0,90 90,690 720,870 870,1050 1050,1200
{} known to its own

1033
00:29:35,540 --> 00:29:36,420
0,420
server.|
|

1034
00:29:37,070 --> 00:29:38,690
0,480 930,1110 1110,1230 1230,1530 1530,1620
So you are using the
因此，您将服务器用于扩展或容错，还是两者兼而有之？

1035
00:29:38,690 --> 00:29:41,780
0,450 450,1140 1170,2280 2280,2580 2580,3090
servers for scaling or for

1036
00:29:41,780 --> 00:29:44,020
0,240 240,1080 1170,1440 1440,1980
fault tolerance, or both?|
|

1037
00:29:44,900 --> 00:29:46,190
0,180 180,360 360,540 540,780 780,1290
A little bit for both,|
对两个人都有一点，|

1038
00:29:46,190 --> 00:29:47,240
0,270 270,540 540,660 660,960 960,1050
{} when we ran the
当我们运行性能指标时，

1039
00:29:47,240 --> 00:29:51,140
0,540 540,1290 1800,2370 2430,3300 3330,3900
performance metrics,| {} by distributing
|通过将客户端请求的负载分布在多个服务器上，

1040
00:29:51,140 --> 00:29:52,190
0,120 120,510 510,690 690,750 750,1050
the load of the client

1041
00:29:52,190 --> 00:29:53,630
0,330 330,630 630,810 810,1320 1320,1440
requests across many servers,| you
|您可以处理稍微多一点的带宽请求，

1042
00:29:53,630 --> 00:29:54,350
0,150 150,360 360,450 450,690 690,720
are able to handle a

1043
00:29:54,350 --> 00:29:56,120
0,150 150,270 270,450 450,960 990,1770
little bit more bandwidth request,|
|

1044
00:29:56,740 --> 00:29:58,090
0,330 330,750 750,990 990,1200 1200,1350
{} however, this is a
然而，这是一种权衡，

1045
00:29:58,090 --> 00:30:00,190
0,420 420,690 720,1080 1080,1380 1380,2100
trade-off between,| because eventual consistency
|因为最终的一致性将需要更多的时间，

1046
00:30:00,190 --> 00:30:00,880
0,180 180,360 360,420 420,570 570,690
will take a little bit

1047
00:30:00,880 --> 00:30:02,320
0,120 120,510 510,1020 1020,1080 1080,1440
more time,| because the servers
|因为服务器将必须发送RPC，

1048
00:30:02,320 --> 00:30:03,130
0,150 150,270 270,360 360,600 600,810
will have to send {RPCs

1049
00:30:03,130 --> 00:30:04,180
0,600
-},|
|

1050
00:30:04,400 --> 00:30:07,220
0,360 360,630 630,840 840,1380 2280,2820
every single other servers,| so
每一台其他服务器，|所以我们的论文，我们有一个完整的图表，但是。

1051
00:30:07,340 --> 00:30:08,390
0,210 210,420 420,510 510,660 660,1050
our paper, we have a

1052
00:30:08,390 --> 00:30:13,610
0,150 150,570 570,1020 1020,1500 4380,5220
whole diagram everything, but.| Yeah,
|是的，它的规模有多大，

1053
00:30:13,610 --> 00:30:14,900
0,150 150,450 450,660 660,780 780,1290
how well does it scale,|
|

1054
00:30:14,930 --> 00:30:16,640
0,240 240,420 420,810 810,1020 1020,1710
as you add more servers.|
随着您添加更多的服务器。|

1055
00:30:17,220 --> 00:30:19,020
0,810 810,1050 1050,1200 1200,1260 1260,1800
Yeah, so have the metrics
是啊，我的另一个屏幕上也有指标，

1056
00:30:19,020 --> 00:30:21,150
0,300 300,420 420,660 660,1440 1620,2130
on my other screen,| so
|所以它能够处理，

1057
00:30:21,150 --> 00:30:24,630
0,240 240,450 450,570 570,1620 2130,3480
it's able to handle {},|
|

1058
00:30:25,920 --> 00:30:27,360
0,210 210,540 540,810 810,1110 1110,1440
if we gave it to
如果我们将其分配给五个客户端和五个服务器上的3000个请求，

1059
00:30:27,360 --> 00:30:30,000
0,600 600,660 660,840 840,1980 2100,2640
more or less {3000,requests} across

1060
00:30:30,000 --> 00:30:32,100
0,270 270,930 930,1230 1230,1440 1440,2100
five clients and five servers,|
|

1061
00:30:32,550 --> 00:30:34,470
0,540 540,900 900,1500 1500,1740 1740,1920
{it,achieve} eventual consistency within three
它在三秒内实现了最终一致性，

1062
00:30:34,470 --> 00:30:36,330
0,510 510,690 690,840 840,1080 1080,1860
seconds,| but this was mainly
|但这主要是因为它也在电脑上，

1063
00:30:36,330 --> 00:30:37,980
0,480 480,570 570,750 750,1230 1230,1650
because it was also on

1064
00:30:38,280 --> 00:30:39,300
0,180 180,540 540,720 720,810 810,1020
a computer,| that's on local
|这是在具有RPC的本地主机上进行的，速度非常快。

1065
00:30:39,300 --> 00:30:40,260
0,300 300,390 390,510 510,840 840,960
host with {RPCs -} were

1066
00:30:40,260 --> 00:30:41,140
0,180 180,750
really fast.|
|

1067
00:30:42,460 --> 00:30:43,720
0,420 420,600 600,900 900,1110 1110,1260
However, that also means that
然而，这也意味着所有的计算机都在一台机器上运行，

1068
00:30:43,720 --> 00:30:44,980
0,150 150,240 240,720 720,1140 1140,1260
all the computers happening on

1069
00:30:44,980 --> 00:30:46,930
0,180 180,750 750,1170 1200,1680 1710,1950
one machine,| so this can
|所以，当我们把它放在真正的硬件上时，这可以是两种方式。

1070
00:30:46,930 --> 00:30:48,100
0,120 120,390 390,570 570,780 780,1170
go either way when we

1071
00:30:48,190 --> 00:30:49,300
0,180 180,300 300,420 420,600 600,1110
put it on real hardware.|
|

1072
00:30:54,080 --> 00:30:55,970
0,390 390,900 900,1230 1230,1650 1650,1890
{} Yeah, another thing is
是的，还有一件事是，

1073
00:30:55,970 --> 00:30:58,550
0,600 1200,1740 1740,1980 1980,2280 2280,2580
that,| {} if you make
|如果你一次提出太多要求，

1074
00:30:58,550 --> 00:31:00,290
0,150 150,360 360,810 810,1050 1050,1740
too many requests at once,|
|

1075
00:31:00,680 --> 00:31:03,470
0,1080 1080,1770 2160,2400 2400,2460 2460,2790
eventually consistency kind of hard
最终，一致性很难实现，

1076
00:31:03,470 --> 00:31:05,450
0,300 300,990 1050,1320 1320,1440 1440,1980
to achieve,| so for example
|例如，我们试图一次进行19000次编辑，

1077
00:31:05,450 --> 00:31:09,140
0,150 150,420 420,480 480,1140 1530,3690
we tried to do {19000,edits}

1078
00:31:09,650 --> 00:31:11,240
0,330 330,570 570,1080 1110,1530 1530,1590
{} at once,| across a
|跨100个客户端和5台服务器

1079
00:31:11,240 --> 00:31:13,070
0,360 360,900 900,1080 1080,1260 1260,1830
hundred clients and five servers|
|

1080
00:31:13,400 --> 00:31:14,510
0,90 90,240 240,480 480,720 720,1110
and it took around 32
它花了大约32秒才达到最终的一致性，

1081
00:31:14,510 --> 00:31:16,040
0,360 360,480 480,780 810,1230 1230,1530
seconds to reach {} eventual

1082
00:31:16,040 --> 00:31:16,940
0,630
consistency,|
|

1083
00:31:17,480 --> 00:31:18,680
0,480 480,690 690,810 810,990 990,1200
however, if we only did
然而，如果我们只在100个客户端和5个服务器上进行3000次编辑，

1084
00:31:18,680 --> 00:31:20,540
0,840 840,1170 1170,1230 1230,1470 1470,1860
{3000,edits} across a hundred clients

1085
00:31:20,540 --> 00:31:21,530
0,120 120,300 300,720 720,810 810,990
and five servers,| it only
|这只花了大约三秒钟。

1086
00:31:21,530 --> 00:31:22,960
0,210 210,390 390,510 510,1140
took around three seconds.|
|

1087
00:31:25,740 --> 00:31:26,520
0,120 120,180 180,330 330,420 420,780
When you say you do
当你说你做了19000或其他的事，

1088
00:31:26,520 --> 00:31:28,440
0,330 330,450 450,1500 1500,1770 1770,1920
whatever the {19000,or} whatever that

1089
00:31:28,440 --> 00:31:29,760
0,420 420,600 600,900 900,1050 1050,1320
was,| is that like sending
|这就像是一次发送所有这些信息，

1090
00:31:29,760 --> 00:31:31,020
0,240 240,450 450,570 570,900 900,1260
all those at once,| or
|或者它是随着时间的推移而扩散的。

1091
00:31:31,020 --> 00:31:32,100
0,90 90,360 360,720 720,900 900,1080
is it spread out over

1092
00:31:32,100 --> 00:31:34,020
0,420 1110,1530 1530,1710 1710,1830 1830,1920
time.| Every single one is
|每一个单独发送，每个编辑并行发送，至少在测试时。

1093
00:31:34,020 --> 00:31:35,340
0,270 270,450 450,750 750,1080 1080,1320
sent, every single edit sent

1094
00:31:35,340 --> 00:31:36,260
0,120 120,630
in parallel,

1095
00:31:36,650 --> 00:31:40,380
0,210 210,300 300,510 2340,2790
and at {least,at,test}.| Interesting.|
|有意思的。|

1096
00:31:42,580 --> 00:31:43,750
0,150 150,300 300,390 390,570 570,1170
I had a quick question,|
我有一个简短的问题，|

1097
00:31:43,750 --> 00:31:45,460
0,390 390,750 750,870 870,990 990,1710
so one of the motivators|
所以其中一个激励因素|

1098
00:31:45,460 --> 00:31:47,230
0,450 540,1080 1080,1320 1320,1650 1650,1770
that collaborative text editors like
像Google Docs这样的协作文本编辑器不能支持大规模更新和并发更新，

1099
00:31:47,230 --> 00:31:49,810
0,300 300,840 1350,1680 1680,2370 2370,2580
Google docs can't support high

1100
00:31:49,810 --> 00:31:52,840
0,510 510,1200 1530,2040 2070,2460 2460,3030
scale updates {} concurrent updates,|
|

1101
00:31:52,960 --> 00:31:54,190
0,270 270,480 480,840 840,990 990,1230
so why don't you think
所以你为什么不认为他们不采用你们所提议的方法呢？

1102
00:31:54,190 --> 00:31:55,240
0,240 240,480 480,540 540,870 870,1050
they use an approach like

1103
00:31:55,240 --> 00:31:56,590
0,270 270,420 420,660 660,750 750,1350
what you guys are proposing.|
|

1104
00:31:59,650 --> 00:32:01,150
0,150 150,480 480,780 780,1110 1110,1500
I think Google docs uses
我认为Google Docs使用了一种类似的方法，称为操作转换，

1105
00:32:01,150 --> 00:32:02,860
0,90 90,480 480,810 810,1170 1170,1710
a similar approach called operational

1106
00:32:02,860 --> 00:32:04,990
0,750 780,1200 1290,1740 1770,1920 1920,2130
transform,| {} which I'm not
|我不确定，它是否也可以并行化，

1107
00:32:04,990 --> 00:32:05,890
0,150 150,330 330,420 420,570 570,900
sure, if it can be

1108
00:32:05,890 --> 00:32:07,900
0,720 720,900 900,1260 1710,1890 1890,2010
parallelized as well,| and they
|他们可能不想这么做，

1109
00:32:07,900 --> 00:32:08,920
0,300 300,510 510,720 720,840 840,1020
probably don't want to,| because
|因为他们不想给我们提供那么多的服务器能力，

1110
00:32:08,920 --> 00:32:09,490
0,90 90,210 210,330 330,390 390,570
they don't want to give

1111
00:32:09,490 --> 00:32:10,630
0,90 90,270 270,420 420,690 690,1140
us that much server power,|
|

1112
00:32:11,140 --> 00:32:11,980
0,540

1113
00:32:12,320 --> 00:32:13,970
0,480 480,780 780,1020 1020,1230 1230,1650
it's probably just like for
这可能只是为了提高成本效益，

1114
00:32:14,000 --> 00:32:16,220
0,390 390,1260 1290,1440 1440,1890
cost effectiveness,| I'm guessing.|
|我是猜的。|

1115
00:32:18,950 --> 00:32:20,960
0,390 390,510 510,750 750,1530 1560,2010
Yeah, I'm just, how {[]
是的，我只是，怎么说，

1116
00:32:20,960 --> 00:32:22,700
0,90 90,510 1020,1320 1350,1560 1560,1740
-} say,| I don't think
|我认为他们不会用一百个人编辑一个文档的情况，

1117
00:32:22,700 --> 00:32:23,600
0,90 90,300 300,480 480,600 600,900
they use case a hundred

1118
00:32:23,600 --> 00:32:25,400
0,210 210,600 600,840 840,1500 1500,1800
people editing one document,| comes
|出现得太频繁了，

1119
00:32:25,400 --> 00:32:26,680
0,300 300,480 480,960
up too often,|
|

1120
00:32:26,960 --> 00:32:28,100
0,150 150,390 390,480 480,540 540,1140
at least in the Google
至少在Google Google Docs的使用中，

1121
00:32:28,130 --> 00:32:30,540
0,300 300,750 750,1200 1380,2040
Google docs {} usage,|
|

1122
00:32:31,290 --> 00:32:32,310
0,240 240,390 390,600 600,780 780,1020
so it's probably not something
因此，您可能不想在这方面花费额外的工程时间。

1123
00:32:32,310 --> 00:32:33,030
0,60 60,180 180,240 240,510 510,720
you want to spend extra

1124
00:32:33,030 --> 00:32:34,200
0,330 330,540 540,900
engineering time on.|
|

1125
00:32:39,200 --> 00:32:41,420
0,390 390,780 780,1050 1410,1710 1710,2220
Great, thank you, cool demo,|
太好了，谢谢你，酷小样，|

1126
00:32:41,990 --> 00:32:43,250
0,330 330,510 510,720 720,840 840,1260
so up next, we have
接下来，我们来看搅蛋器，

1127
00:32:43,250 --> 00:32:44,780
0,180 180,390 390,900 900,1140 1140,1530
the {eggscrambler -},| {if,you,all} ready.|
|如果你们都准备好了。|

1128
00:32:51,910 --> 00:32:53,710
0,450 450,840 840,1200 1290,1650 1650,1800
Cool, hello everyone, {} my
太好了，大家好，我叫阿维德

1129
00:32:53,710 --> 00:32:54,820
0,180 180,330 330,480 480,870 870,1110
name is {Arvid -}| and
|和阿尔曼和温迪一起

1130
00:32:54,820 --> 00:32:56,860
0,390 390,780 780,1320 1320,1590 1590,2040
together with Arman and Wendy,|
|

1131
00:32:56,860 --> 00:32:57,610
0,120 120,210 210,330 330,600 600,750
we have been working on
我们一直在研究鸡蛋搅拌机，

1132
00:32:57,640 --> 00:32:59,890
0,240 240,720 720,960 960,1320 1710,2250
{eggscrambler -},| which is anonymous
|这是使用社区加密的匿名广播。

1133
00:32:59,890 --> 00:33:02,350
0,570 570,810 810,1260 1260,1800 1830,2460
broadcasting using community encryption. {}|
|

1134
00:33:02,350 --> 00:33:03,310
0,180 180,390 390,750 750,870 870,960
So let's start with a
所以让我们从一个激励人的问题开始，

1135
00:33:03,310 --> 00:33:06,430
0,420 420,1710 2160,2370 2370,2820 2820,3120
motivating problem,| we all know
|我们都知道我们都喜欢麻省理工学院的忏悔录

1136
00:33:06,430 --> 00:33:07,840
0,150 150,360 360,630 630,960 960,1410
we all love MIT Confessions,|
|

1137
00:33:07,840 --> 00:33:09,040
0,240 240,480 480,720 720,990 990,1200
so let's say that one
假设这个班上有一个人想要提交一份供词，

1138
00:33:09,040 --> 00:33:10,120
0,420 420,510 510,660 660,930 930,1080
person in this class wants

1139
00:33:10,120 --> 00:33:11,560
0,90 90,330 330,390 390,1020 1110,1440
to submit a confession, {}|
|

1140
00:33:11,560 --> 00:33:13,000
0,510 510,900 900,1020 1020,1230 1230,1440
telling people how much they
告诉人们他们有多喜欢这门课，

1141
00:33:13,000 --> 00:33:14,350
0,210 210,390 390,840 930,1260 1260,1350
love this class,| and so
|那么他们会做些什么，

1142
00:33:14,350 --> 00:33:15,400
0,150 150,240 240,390 390,540 540,1050
what do they do,| well
|他们把这个会议提交给谷歌表格，

1143
00:33:15,430 --> 00:33:16,870
0,390 390,630 630,780 780,1140 1140,1440
they submit this convention to

1144
00:33:16,870 --> 00:33:19,000
0,150 150,390 390,1020 1140,1440 1440,2130
a Google form,| and then
|然后交给麻省理工学院的忏悔管理员

1145
00:33:19,340 --> 00:33:20,750
0,330 330,570 570,690 690,1020 1020,1410
that goes to the MIT

1146
00:33:20,750 --> 00:33:22,670
0,510 510,1110 1110,1350 1350,1650 1650,1920
Confessions admin| and then that
|然后这些信息有望进入Facebook页面，

1147
00:33:22,670 --> 00:33:23,990
0,480 480,780 780,870 870,990 990,1320
hopefully goes to the Facebook

1148
00:33:23,990 --> 00:33:25,910
0,390 570,1260 1260,1440 1440,1620 1620,1920
page,| but now let's consider
|但现在让我们来考虑一个场景，

1149
00:33:25,910 --> 00:33:27,080
0,60 60,450 450,630 630,720 720,1170
a scenario,| where the confessions
|供词管理员实际上是麻省理工学院的教授，

1150
00:33:27,080 --> 00:33:28,910
0,390 390,570 570,1350 1350,1470 1470,1830
admin is actually an MIT

1151
00:33:28,910 --> 00:33:31,910
0,510 660,1710 1740,2070 2070,2550 2550,3000
professor,| particularly for another classic
|特别是对于另一门经典课程来说，

1152
00:33:31,910 --> 00:33:33,470
0,390 390,690 690,1260 1260,1380 1380,1560
course,| so obviously they would
|所以很明显他们不希望这份供词被张贴出来，

1153
00:33:33,470 --> 00:33:34,730
0,300 300,510 510,750 750,1170 1170,1260
not want this confession to

1154
00:33:34,730 --> 00:33:35,460
0,90 90,540
be posted,|
|

1155
00:33:35,670 --> 00:33:37,290
0,450 450,600 600,750 750,1170 1200,1620
{} so they would [censor]
所以他们会[审查]它，

1156
00:33:37,290 --> 00:33:39,000
0,270 360,600 600,690 690,1080 1380,1710
it,| because they can,| but
|因为他们可以，|但更糟糕的是，

1157
00:33:39,000 --> 00:33:40,200
0,120 120,270 270,540 540,900 900,1200
it's like even worse,| because
|因为他们可以像麻省理工学院的教授一样，

1158
00:33:40,200 --> 00:33:41,790
0,180 180,690 960,1140 1140,1410 1410,1590
they could they could there

1159
00:33:41,790 --> 00:33:42,930
0,180 180,240 240,570 570,1020 1020,1140
like an MIT professor,| so
|这样他们就可以去谷歌查看他们的网络流量，

1160
00:33:42,930 --> 00:33:44,370
0,120 120,450 450,660 660,780 780,1440
they could go to Google

1161
00:33:44,430 --> 00:33:45,900
0,600 600,660 660,780 780,1080 1080,1470
look at their network traffic,|
|

1162
00:33:45,900 --> 00:33:46,410
0,90 90,210 210,360 360,420 420,510
they could look at the
他们可以查看麻省理工学院WiFi网络流量，

1163
00:33:46,410 --> 00:33:48,150
0,330 330,600 600,930 930,1380 1470,1740
MIT WiFi network traffic,| so
|这样他们就能找出到底是谁发的这个，

1164
00:33:48,150 --> 00:33:49,200
0,90 90,300 300,600 600,780 780,1050
they could figure out who

1165
00:33:49,200 --> 00:33:50,320
0,390 390,600 600,1020
actually sent this,|
|

1166
00:33:50,610 --> 00:33:51,900
0,240 240,510 510,960 960,1050 1050,1290
and then obviously they would
很明显，他们想在班上给那个人打个F-

1167
00:33:51,900 --> 00:33:52,740
0,150 150,240 240,360 360,510 510,840
like to give that person

1168
00:33:52,740 --> 00:33:53,880
0,150 150,360 360,660 660,990 990,1140
an f minus in their

1169
00:33:53,880 --> 00:33:56,310
0,450 720,1260 1260,1680 1680,2070 2070,2430
class| and that's terrible,| so
|这太可怕了，|那么我们想要做什么呢，

1170
00:33:56,310 --> 00:33:56,850
0,120 120,210 210,330 330,480 480,540
what do we want to

1171
00:33:56,850 --> 00:33:58,800
0,120 120,690 870,1200 1200,1350 1350,1950
do,| well, {} we want
|嗯，我们想要匿名广播

1172
00:33:58,920 --> 00:34:00,510
0,300 300,840 840,1320 1320,1410 1410,1590
{} anonymous broadcasting| and that's
|这就像是今天的一个共同主题，

1173
00:34:00,510 --> 00:34:01,980
0,150 150,450 480,840 840,1200 1200,1470
like a common theme today,|
|

1174
00:34:01,980 --> 00:34:03,300
0,120 120,330 330,630 660,1170 1170,1320
it seems like {} and
这看起来像是什么是匿名广播，

1175
00:34:03,300 --> 00:34:04,680
0,120 120,300 300,420 420,810 810,1380
so what is anonymous broadcasting,|
|

1176
00:34:04,680 --> 00:34:05,970
0,210 210,330 330,630 630,810 810,1290
well, we define it as
我们把它定义为向每个人广播消息的协议，

1177
00:34:06,030 --> 00:34:07,800
0,210 210,750 750,1140 1140,1710 1710,1770
a protocol to broadcast a

1178
00:34:07,800 --> 00:34:09,930
0,360 360,840 840,1560 1650,2040 2040,2130
message to everyone,| all the
|在没有透露消息来自谁的情况下的所有用户，

1179
00:34:09,930 --> 00:34:11,760
0,660 690,1110 1110,1530 1530,1740 1740,1830
users without revealing who the

1180
00:34:11,760 --> 00:34:12,600
0,330 330,570 570,750
message comes from,|
|

1181
00:34:12,790 --> 00:34:14,590
0,420 420,870 870,1200 1200,1440 1440,1800
{} so without further do,|
因此，如果不做进一步的工作，|

1182
00:34:14,590 --> 00:34:16,960
0,540 540,720 720,1140 1170,1830 1860,2370
I will let Wendy talk
我会让温迪谈谈我们是怎么做到的。

1183
00:34:16,960 --> 00:34:18,250
0,420 420,750 750,870 870,990 990,1290
about how we do that.|
|

1184
00:34:20,540 --> 00:34:22,100
0,150 150,600 600,1110 1170,1380 1380,1560
So yeah, {} the two
所以，是的，我们设计的两个主要特点是，

1185
00:34:22,100 --> 00:34:23,300
0,210 210,510 510,600 600,720 720,1200
main features of our design

1186
00:34:23,300 --> 00:34:24,950
0,210 210,420 420,570 570,750 750,1650
are that,| it is decentralized
|它是去中心化的，并使用密码学，

1187
00:34:24,980 --> 00:34:27,800
0,570 570,810 810,1620 1650,1950 1950,2820
and uses cryptography,| in particular,
|尤其是，加密社区是必要，

1188
00:34:27,800 --> 00:34:29,330
0,300 300,750 750,840 840,1410 1410,1530
{} community of encryption is

1189
00:34:29,330 --> 00:34:31,610
0,630 630,870 870,1590 1590,1770 1770,2280
necessary,| because otherwise the description
|因为否则描述顺序将揭示消息发送者的原始身份。

1190
00:34:31,610 --> 00:34:33,200
0,390 390,570 570,1050 1050,1200 1200,1590
order will reveal the original

1191
00:34:33,200 --> 00:34:35,400
0,570 570,690 690,1050 1050,1650
identities of message senders.|
|

1192
00:34:36,880 --> 00:34:38,890
0,540 540,810 810,1230 1230,1710 1710,2010
{} Yeah, so here's the
是的，所以这就是我们要执行的协议，

1193
00:34:38,890 --> 00:34:41,470
0,420 420,510 510,1260 1320,1980 1980,2580
protocol be implemented,| ensure participants
|确保参与者加入网络

1194
00:34:41,470 --> 00:34:43,570
0,240 240,300 300,960 1110,1710 1710,2100
join the network| and encrypt
|并加密和提交他们的消息，

1195
00:34:43,570 --> 00:34:44,920
0,90 90,360 360,510 510,990 990,1350
and submit their message,| which
|它在加密阶段中由所有参与者恰好加密一次，

1196
00:34:44,920 --> 00:34:46,240
0,300 300,450 450,990 990,1110 1110,1320
[winds] up encrypted by all

1197
00:34:46,240 --> 00:34:48,070
0,660 660,1170 1170,1590 1620,1740 1740,1830
participants exactly once in the

1198
00:34:48,070 --> 00:34:49,930
0,390 390,810 990,1200 1200,1620 1620,1860
encrypt phase,| the scramble phase
|加扰阶段提供匿名性，

1199
00:34:49,930 --> 00:34:52,300
0,420 420,1170 1170,1800 1830,2100 2100,2370
provides anonymity,| because {} as
|因为正如突出显示的那样，

1200
00:34:52,300 --> 00:34:54,800
0,570 810,1620 1620,2340
highlighted,| because every
|因为每个参与者都对消息进行加密

1201
00:34:54,930 --> 00:34:57,120
0,660 660,1050 1050,1170 1170,2010 2010,2190
participant encrypts the messages| and
|随机化是有秩序的，

1202
00:34:57,120 --> 00:34:59,670
0,510 510,690 690,1020 1020,1500 1950,2550
randomize is there order,| finally
|最后，解密会得到所需的消息列表，这些消息来自与身份无关的所有参与者。

1203
00:34:59,670 --> 00:35:01,020
0,90 90,510 510,930 930,1230 1230,1350
{} decryption results in the

1204
00:35:01,020 --> 00:35:02,490
0,480 480,720 720,810 810,1290 1290,1470
desired list of messages from

1205
00:35:02,490 --> 00:35:04,140
0,180 180,870 870,1020 1020,1200 1200,1650
all participants with no connection

1206
00:35:04,140 --> 00:35:05,200
0,120 120,810
to identity.|
|

1207
00:35:08,340 --> 00:35:10,050
0,570 600,780 780,1050 1050,1320 1320,1710
{} So yeah, if all
所以，如果所有参与者都是诚实的，

1208
00:35:10,050 --> 00:35:11,760
0,510 510,660 660,1050 1050,1230 1230,1710
participants are honest,| this protocol
|该协议成功地导致了匿名性，

1209
00:35:11,760 --> 00:35:15,360
0,630 630,1110 1110,1470 1470,2310 3180,3600
successfully results in anonymity,| while
|虽然恶意用户可能确定消息的发送者，

1210
00:35:15,360 --> 00:35:16,170
0,150 150,270 270,690 690,780 780,810
it is possible for a

1211
00:35:16,170 --> 00:35:17,700
0,540 540,840 840,990 990,1470 1470,1530
malicious user to determine the

1212
00:35:17,700 --> 00:35:18,720
0,270 270,390 390,450 450,870 870,1020
sender of a message,| we
|我们相信，这样的行为在大屠杀曝光后是可以检测到的，

1213
00:35:18,720 --> 00:35:19,920
0,300 300,420 420,630 630,1020 1020,1200
believe that such actions are

1214
00:35:19,920 --> 00:35:22,200
0,600 600,870 870,1200 1200,1770 1890,2280
detectable upon massacre reveals,| if
|如果人们感兴趣，

1215
00:35:22,200 --> 00:35:24,030
0,210 210,300 300,1230 1230,1470 1500,1830
people are interested,| there exist
|对于这个问题还有其他解决方案，

1216
00:35:24,030 --> 00:35:25,320
0,240 240,630 630,690 690,810 810,1290
other solutions to this problems,|
|

1217
00:35:25,320 --> 00:35:26,430
0,150 150,270 270,540 540,810 810,1110
such as {mix-nets -} and
例如混合网络和DC网络，

1218
00:35:26,430 --> 00:35:29,130
0,360 360,840 960,1920 1920,2370 2370,2700
{DC-nets -},| next Armand will
|接下来，Armand将描述实现的结构。

1219
00:35:29,130 --> 00:35:30,210
0,420 420,480 480,900 900,990 990,1080
describe the structure of the

1220
00:35:30,210 --> 00:35:31,140
0,840
implementation.|
|

1221
00:35:34,800 --> 00:35:36,300
0,630 630,930 930,990 990,1320 1320,1500
So, first of all, look
所以，首先，看看这个假设，

1222
00:35:36,300 --> 00:35:38,040
0,60 60,420 450,900 900,1290 1380,1740
at this assuming that, {}|
|

1223
00:35:38,840 --> 00:35:40,130
0,180 180,420 420,570 570,840 870,1290
we're looking at the high-level
我们看到的是高级界面，

1224
00:35:40,130 --> 00:35:41,540
0,480 480,870 900,1200 1200,1350 1350,1410
interface for,| someone trying to
|试图提交消息的人

1225
00:35:41,540 --> 00:35:42,470
0,300 300,330 330,690 690,840 840,930
submit a message| and our
|以及我们与服务器的交互，

1226
00:35:42,470 --> 00:35:43,790
0,420 420,540 540,660 660,1140 1170,1320
interaction with our servers,| so
|假设你就是那个想要提交供词的人，

1227
00:35:43,790 --> 00:35:44,780
0,180 180,390 390,540 540,630 630,990
let's say you're the person

1228
00:35:44,780 --> 00:35:46,340
0,360 360,570 570,900 900,960 960,1560
trying to submit a confession,|
|

1229
00:35:46,370 --> 00:35:48,060
0,210 210,360 360,960 960,1380
you're this application client,|
你是这个应用程序的客户，|

1230
00:35:48,170 --> 00:35:48,920
0,300 300,360 360,570 570,660 660,750
so the first thing you're
所以你要做的第一件事就是发送一条开始消息，

1231
00:35:48,920 --> 00:35:50,330
0,180 180,270 270,630 660,870 870,1410
going to do is send

1232
00:35:50,330 --> 00:35:52,130
0,360 420,900 900,1350 1380,1560 1560,1800
a start message,| so that
|这表明你想要开始新一轮的广播，

1233
00:35:52,130 --> 00:35:53,180
0,540 540,720 720,840 840,960 960,1050
indicates that you want to

1234
00:35:53,180 --> 00:35:55,070
0,420 420,480 480,810 810,1410 1410,1890
start a new broadcast round,|
|

1235
00:35:55,820 --> 00:35:56,990
0,240 240,300 300,750 750,870 870,1170
and the service is going
这项服务将询问所有人

1236
00:35:56,990 --> 00:35:58,610
0,480 480,1020 1020,1230 1230,1320 1320,1620
to ask all the people|
|

1237
00:35:58,610 --> 00:35:59,690
0,90 90,180 180,810 810,960 960,1080
who are participating in the
他们参加这轮比赛是为了传递一个信息，

1238
00:35:59,690 --> 00:36:01,400
0,420 480,780 780,870 870,1470
round for a message,|
|

1239
00:36:02,050 --> 00:36:02,710
0,150 150,270 270,390 390,540 540,660
and then it's going to
然后它将运行这个协议

1240
00:36:02,710 --> 00:36:04,330
0,180 180,300 300,1020 1380,1530 1530,1620
run this protocol| and then
|然后它会将结果发送给所有参与的人

1241
00:36:04,330 --> 00:36:05,050
0,90 90,300 300,390 390,630 630,720
it's going to send the

1242
00:36:05,050 --> 00:36:07,450
0,360 360,480 480,1170 1380,1560 1560,2400
results to everyone who participated|
|

1243
00:36:07,480 --> 00:36:08,350
0,240 240,360 360,480 480,720 720,870
or if it's something like
或者如果是像《忏悔》这样的东西要出版，

1244
00:36:08,350 --> 00:36:10,270
0,690 690,960 960,1290 1320,1710 1710,1920
confessions going to publish it,|
|

1245
00:36:11,140 --> 00:36:11,920
0,210 210,330 330,510 510,630 630,780
and I feel at this
我觉得在这一点上，它将是匿名的，

1246
00:36:11,920 --> 00:36:13,570
0,300 300,360 360,540 540,780 780,1650
point, it would be anonymized,|
|

1247
00:36:14,440 --> 00:36:15,310
0,450 480,660 660,750 750,810 810,870
{} but this is a
但这是一个非常简单的观点，

1248
00:36:15,310 --> 00:36:17,170
0,180 180,510 510,810 810,1080 1080,1860
very simple view,| in reality,
|事实上，我们实际上是在实验室的RAFT实现的基础上构建这个平台，

1249
00:36:17,470 --> 00:36:18,850
0,360 360,630 630,900 900,1200 1200,1380
we're actually building this on

1250
00:36:18,850 --> 00:36:20,530
0,270 270,420 420,600 600,930 930,1680
top of our raft implementation

1251
00:36:20,650 --> 00:36:22,120
0,450 510,690 690,1320
from the labs,|
|

1252
00:36:22,390 --> 00:36:23,200
0,180 180,240 240,480 480,600 600,810
so the reason we use
所以我们使用实验室木筏的原因是两个[]，

1253
00:36:23,200 --> 00:36:24,940
0,360 390,750 750,870 870,1410 1500,1740
lab raft is {two,[]},| so
|因此，第一，我们将协议实现为状态机，

1254
00:36:24,940 --> 00:36:26,470
0,480 600,870 870,990 990,1440 1440,1530
one, {} we implement the

1255
00:36:26,470 --> 00:36:28,210
0,570 570,750 750,930 930,1260 1260,1740
protocol as a state machine,|
|

1256
00:36:28,980 --> 00:36:30,510
0,210 210,420 420,780 780,1050 1080,1530
and so raft is among
因此，RAFT是运行该协议的众多实例之一

1257
00:36:30,540 --> 00:36:33,540
0,480 1170,1710 1710,1860 1860,2100 2610,3000
many instances that are running

1258
00:36:33,540 --> 00:36:34,860
0,90 90,720 810,960 960,1050 1050,1320
the protocol| and so raft
|因此，RAFT被用来复制这种状态

1259
00:36:34,860 --> 00:36:36,150
0,90 90,420 420,660 660,1170 1170,1290
is used to replicate this

1260
00:36:36,150 --> 00:36:37,830
0,390 870,1020 1020,1200 1200,1470 1470,1680
state| and then two, when
|然后第二，当我们做打乱阶段时，

1261
00:36:37,830 --> 00:36:38,940
0,90 90,270 270,330 330,810 810,1110
we're doing the scramble phase,|
|

1262
00:36:38,940 --> 00:36:39,600
0,90 90,210 210,300 300,480 480,660
we need to make sure
我们需要确保每个参与者都以特定的顺序进行争抢，

1263
00:36:39,600 --> 00:36:41,610
0,210 210,360 360,1110 1290,1470 1470,2010
that each participant is scrambling

1264
00:36:41,610 --> 00:36:42,780
0,180 180,210 210,720 720,1020 1020,1170
in a specific order,| so
|所以我们实际上使用浮筏作为一种协调机制

1265
00:36:42,780 --> 00:36:44,010
0,90 90,390 390,570 570,1050 1050,1230
we actually use raft as

1266
00:36:44,010 --> 00:36:45,870
0,270 510,1110 1110,1650 1650,1770 1770,1860
a coordination mechanism| to do
|要做这个测试和设置，

1267
00:36:45,870 --> 00:36:47,000
0,180 180,510 510,630 630,960
this test and set,|
|

1268
00:36:47,220 --> 00:36:48,450
0,180 180,450 450,720 720,1140 1140,1230
where they all proceed in
在那里，它们都以单一的顺序进行，

1269
00:36:48,450 --> 00:36:50,670
0,60 60,390 390,900 1530,1920 1920,2220
a single order,| so similar
|就像KV商店一样，

1270
00:36:50,670 --> 00:36:52,440
0,90 90,180 180,570 570,1020 1440,1770
to the kv store, {}|
|

1271
00:36:52,440 --> 00:36:53,550
0,180 180,330 330,420 420,720 720,1110
we have the state machine
我们有状态机服务器，

1272
00:36:53,550 --> 00:36:55,020
0,480 480,720 720,1020 1020,1140 1140,1470
server,| that's reading the raft
|那是在读木筏的更新

1273
00:36:55,020 --> 00:36:56,400
0,420 420,540 540,960 960,1080 1080,1380
updates| and updating the state
|并用它们商定的任何状态更新状态机，

1274
00:36:56,400 --> 00:36:58,560
0,540 1050,1230 1230,1590 1590,1830 1830,2160
machine with whatever they agreed

1275
00:36:58,560 --> 00:36:59,680
0,270 270,930
upon {state,is},|
|

1276
00:36:59,970 --> 00:37:01,020
0,210 210,300 300,510 510,750 750,1050
and we also add in
我们还添加了状态机客户端，

1277
00:37:01,050 --> 00:37:02,490
0,120 120,480 480,810 810,1260 1260,1440
the state machine client,| which
|它正在读取状态机是如何改变的

1278
00:37:02,490 --> 00:37:03,420
0,120 120,420 420,570 570,660 660,930
is reading how the state

1279
00:37:03,420 --> 00:37:05,220
0,270 270,360 360,990 1350,1530 1530,1800
machine is changing| and then
|然后这个客户才是真正采取行动的人

1280
00:37:05,220 --> 00:37:06,420
0,180 180,600 600,690 690,870 870,1200
this client is what's actually

1281
00:37:06,420 --> 00:37:08,700
0,330 330,450 450,990 990,1380 1800,2280
taking the actions| to progress
|为了以某种方式推进协议，

1282
00:37:08,700 --> 00:37:10,290
0,150 150,720 720,900 900,1110 1110,1590
the protocol in some way,|
|

1283
00:37:11,640 --> 00:37:12,840
0,120 120,210 210,660 690,1020 1020,1200
and then again just as
然后，就像在KV商店一样，

1284
00:37:12,840 --> 00:37:14,430
0,360 390,600 600,930 930,1080 1080,1590
in {} {kv -} store,|
|

1285
00:37:14,980 --> 00:37:17,080
0,450 690,840 840,1080 1080,1500 1650,2100
{} in order to progress
为了推进协议，

1286
00:37:17,080 --> 00:37:18,370
0,120 120,600 600,720 720,1170 1170,1290
the protocol,| this client is
|该客户端将联系Leader服务器，

1287
00:37:18,370 --> 00:37:20,380
0,210 210,330 330,1020 1050,1410 1440,2010
going to contact the leader

1288
00:37:20,470 --> 00:37:22,780
0,630 900,1410 1410,1650 1650,2250 2250,2310
server,| with a request to
|利用对状态机更新的请求，

1289
00:37:22,780 --> 00:37:24,460
0,300 360,630 630,870 870,1500
the state machine updates,|
|

1290
00:37:24,900 --> 00:37:25,980
0,150 150,240 240,360 360,600 600,1080
and then we also implement
然后我们还实现了RAFT配置更改RPC，

1291
00:37:25,980 --> 00:37:27,780
0,120 120,750 750,1350 1350,1650 1650,1800
the raft configuration change {RPCs

1292
00:37:27,780 --> 00:37:28,660
0,630
-},|
|

1293
00:37:28,870 --> 00:37:31,090
0,630 1140,1590 1590,1860 1860,2130 2130,2220
so servers can add or
因此，服务器可以在配置中添加或删除自身，

1294
00:37:31,090 --> 00:37:32,710
0,300 300,720 720,810 810,900 900,1620
remove themselves to the configuration,|
|

1295
00:37:32,770 --> 00:37:34,330
0,150 150,330 330,570 570,930 1320,1560
and this means that,| new
这意味着，|新人可以加入随后的几轮广播

1296
00:37:34,330 --> 00:37:36,640
0,390 390,570 570,1110 1140,1770 1770,2310
people can join subsequent broadcast

1297
00:37:36,640 --> 00:37:38,170
0,540 930,1050 1050,1170 1170,1440 1440,1530
rounds| and then also if
|然后，如果出现故障，

1298
00:37:38,170 --> 00:37:39,220
0,150 150,210 210,750 750,900 900,1050
there's a failure,| we can
|我们可以把某人从配置中剔除，

1299
00:37:39,220 --> 00:37:40,060
0,210 210,510 510,660 660,750 750,840
cut someone out of the

1300
00:37:40,060 --> 00:37:41,590
0,810 840,1020 1020,1170 1170,1260 1260,1530
configuration,| so that the next
|这样下一轮广播才能继续进行，

1301
00:37:41,590 --> 00:37:44,350
0,510 510,870 870,1230 1290,1860 2190,2760
broadcast round can proceed,| because
|因为我们的协议要求每个人都是活跃的，才能完成这轮谈判，

1302
00:37:44,350 --> 00:37:45,000
0,450
our

1303
00:37:45,320 --> 00:37:47,390
0,600 600,990 990,1140 1140,1740 1890,2070
protocol requires that everyone is

1304
00:37:47,390 --> 00:37:48,650
0,300 300,810 810,960 960,1170 1170,1260
actually active in order for

1305
00:37:48,650 --> 00:37:49,900
0,90 90,360 360,450 450,930
the round to complete,|
|

1306
00:37:51,380 --> 00:37:52,190
0,120 120,270 270,570 570,660 660,810
and then finally we have
然后我们终于有了应用程序，

1307
00:37:52,190 --> 00:37:54,470
0,90 90,750 750,1020 1020,1380 1860,2280
the application,| where the client
|客户就像是在你手机上运行的供词，

1308
00:37:54,470 --> 00:37:55,850
0,180 180,420 420,690 690,810 810,1380
is like something like confessions

1309
00:37:55,850 --> 00:37:57,350
0,270 270,360 360,480 480,990 1350,1500
running on your phone,| will
|会将这些广播消息发送给客户端

1310
00:37:57,350 --> 00:37:58,910
0,240 240,390 390,960 960,1410 1410,1560
send these broadcast messages to

1311
00:37:58,910 --> 00:38:00,710
0,90 90,840 1170,1350 1350,1620 1620,1800
the clients| and then it
|然后它会收到更新，

1312
00:38:00,710 --> 00:38:03,140
0,360 390,1080 1710,1890 1890,2250 2250,2430
will receive the update,| once
|一旦协议完成。

1313
00:38:03,140 --> 00:38:05,060
0,120 120,600 600,1110 1140,1710
the protocol has completed.|
|

1314
00:38:05,950 --> 00:38:07,000
0,540 570,690 690,810 810,870 870,1050
So we're going to show
因此，我们将播放一段录制的快速演示，

1315
00:38:07,000 --> 00:38:09,190
0,90 90,270 270,1230 1260,1530 1530,2190
a quick demo {} recorded,|
|

1316
00:38:09,220 --> 00:38:10,180
0,360 390,630 630,750 750,810 810,960
{} just let me know
如果你听不到的话就告诉我，

1317
00:38:10,180 --> 00:38:11,950
0,120 120,240 240,600 600,1110 1200,1770
if you can't hear this,|
|

1318
00:38:16,730 --> 00:38:17,960
0,420 420,630 630,720 720,1080 1080,1230
{So,now} onto the demo,| we
现在我们来看演示，|我们现在开始在温迪的电脑前工作

1319
00:38:17,960 --> 00:38:19,610
0,330 360,690 690,1110 1110,1260 1260,1650
start {} working at Wendy's

1320
00:38:19,610 --> 00:38:21,650
0,540 540,750 750,1140 1470,1830 1830,2040
computer right now| and she's
|她将启动应用程序，

1321
00:38:21,650 --> 00:38:23,870
0,210 210,360 360,1050 1260,1650 1680,2220
going to start the application,|
|

1322
00:38:23,870 --> 00:38:24,890
0,120 120,360 360,630 630,750 750,1020
so she's basically gonna start
所以她基本上要在她的计算机上启动一个实例，并尝试

1323
00:38:24,890 --> 00:38:26,150
0,60 60,450 450,540 540,690 690,1260
an instance on her computer

1324
00:38:26,390 --> 00:38:28,080
0,210 210,600 690,1320
and try| and
|她目前正在将她的配置链接发送到缩放聊天中

1325
00:38:28,480 --> 00:38:30,340
0,450 450,870 870,1350 1350,1530 1530,1860
she's currently sending the link

1326
00:38:30,340 --> 00:38:32,170
0,120 120,330 330,1380 1410,1710 1710,1830
for her configuration into the

1327
00:38:32,170 --> 00:38:33,280
0,330 330,690 720,870 870,990 990,1110
zoom chat| as we can
|正如我们在这里看到的，

1328
00:38:33,280 --> 00:38:34,400
0,180 180,570
see here,|
|

1329
00:38:35,210 --> 00:38:35,870
0,150 150,240 240,330 330,510 510,660
so now we're gonna go
所以现在我们要进入阿维德的电脑，

1330
00:38:35,870 --> 00:38:38,090
0,210 210,990 1200,1800 1800,2010 2010,2220
to Arvid's computer,| he's gonna
|他会利用这个链接，享受和温迪一样的配置，

1331
00:38:38,090 --> 00:38:39,320
0,240 240,420 420,780 780,900 900,1230
take that link and enjoy

1332
00:38:39,320 --> 00:38:41,390
0,120 120,510 510,1620 1650,1800 1800,2070
the same configuration as {Wendy

1333
00:38:41,390 --> 00:38:42,000
0,330
-},|
|

1334
00:38:43,110 --> 00:38:45,120
0,210 210,300 300,510 510,1020 1410,2010
so he does that,| and
所以他这么做了，|现在他要开始这一轮了，

1335
00:38:45,540 --> 00:38:46,620
0,270 270,420 420,630 630,720 720,1080
now he's going to start

1336
00:38:46,620 --> 00:38:47,700
0,120 120,690
the round,|
|

1337
00:38:48,540 --> 00:38:49,920
0,420 630,900 900,1020 1020,1260 1260,1380
{} will can send their
威尔可以发送他们的信息，

1338
00:38:49,920 --> 00:38:51,040
0,780
messages,|
|

1339
00:38:53,220 --> 00:38:54,330
0,210 210,330 330,660 690,810 810,1110
and we have the round
我们的回合已经成功了，

1340
00:38:54,330 --> 00:38:56,010
0,660 1140,1320 1320,1500 1500,1590 1590,1680
succeeded,| so now are we
|那么现在我们是否要展示我们可以无缝添加新客户端，

1341
00:38:56,010 --> 00:38:56,580
0,120 120,210 210,360 360,480 480,570
going to show that we

1342
00:38:56,580 --> 00:38:58,260
0,330 360,900 900,1140 1140,1350 1350,1680
can seamlessly add a new

1343
00:38:58,260 --> 00:38:59,430
0,480 480,570 570,690 690,780 780,1170
client,| so this is both
|所以这两个人都会发出一条信息

1344
00:38:59,460 --> 00:39:00,240
0,300 300,360 360,480 480,540 540,780
someone is going to send

1345
00:39:00,240 --> 00:39:01,740
0,60 60,540 570,930 930,1020 1020,1500
a message| and an entirely
|和一个全新的木筏实例，

1346
00:39:01,740 --> 00:39:03,660
0,210 210,540 540,1230 1650,1800 1800,1920
new raft instance,| so we
|所以我们在这里看到，

1347
00:39:03,660 --> 00:39:05,040
0,150 150,510 510,780 780,960 960,1380
see here,| this new instance
|这个新实例很快就赶上了左边的那个，

1348
00:39:05,040 --> 00:39:06,600
0,510 510,960 960,1290
quickly catches up

1349
00:39:07,160 --> 00:39:08,510
0,390 420,600 600,690 690,990 990,1350
{} on the left there,|
|

1350
00:39:08,660 --> 00:39:09,860
0,300 300,600 600,840 840,1080 1080,1200
and now all three of
现在他们三人都将为下一轮传递一个信息，

1351
00:39:09,860 --> 00:39:10,850
0,270 270,360 360,570 570,660 660,990
them are going to send

1352
00:39:10,850 --> 00:39:11,930
0,60 60,480 480,630 630,780 780,1080
a message for this next

1353
00:39:11,930 --> 00:39:12,820
0,360
round,|
|

1354
00:39:15,980 --> 00:39:17,540
0,390 420,570 570,960 1140,1380 1380,1560
and we get {} all
我们收到了所有三条信息，

1355
00:39:17,540 --> 00:39:19,490
0,120 120,690 720,1230 1260,1380 1380,1950
three messages,| so we demonstrated
|所以我们演示了我们可以通过网络进行广播

1356
00:39:19,490 --> 00:39:20,900
0,180 180,300 300,600 660,1260 1260,1410
that we can broadcast over

1357
00:39:20,900 --> 00:39:23,090
0,90 90,600 1050,1290 1290,1590 1590,2190
the network| {} and also
|还可以随意添加客户。

1358
00:39:23,240 --> 00:39:25,400
0,300 300,630 690,1410 1440,1740 1740,2160
add in clients at will.|
|

1359
00:39:28,980 --> 00:39:29,820
0,510

1360
00:39:30,260 --> 00:39:31,970
0,390 390,630 630,690 690,1320 1470,1710
Yes, that's a demo of
是的，这是打蛋器的演示，

1361
00:39:31,970 --> 00:39:32,700
0,420
{}

1362
00:39:32,890 --> 00:39:34,840
0,300 300,780 870,1290 1290,1620 1620,1950
{eggscrambler -},| does anyone have
|有没有人有什么问题？

1363
00:39:34,840 --> 00:39:36,140
0,150 150,1170
any questions?|
|

1364
00:39:39,610 --> 00:39:40,420
0,270 270,450 450,630 630,720 720,810
This is this is a
这是一张非常快的照片，

1365
00:39:40,420 --> 00:39:42,250
0,240 240,510 510,720 750,1200 1350,1830
really fast one,| {} this
|首先，这是一个非常酷的系统，

1366
00:39:42,250 --> 00:39:42,790
0,180 180,240 240,330 330,480 480,540
first of all, this is

1367
00:39:42,790 --> 00:39:44,620
0,180 180,420 420,630 630,1140 1170,1830
a really cool system, {}|
|

1368
00:39:44,920 --> 00:39:48,070
0,360 390,990 1200,1950 2040,2340 2340,3150
well, {} so the application
那么，应用程序与客户端RAFT状态机是分开的，对吗？

1369
00:39:48,070 --> 00:39:50,620
0,180 180,720 720,1050 1050,1620 1740,2550
is separate from the client

1370
00:39:50,650 --> 00:39:52,960
0,630 630,840 840,1380 1470,2130
raft state machine, correct.|
|

1371
00:39:53,660 --> 00:39:54,830
0,480 600,810 810,930 930,1080 1080,1170
Yes.| And it's like two
是。|这就像是两个不同的设备，

1372
00:39:54,830 --> 00:39:56,500
0,270 270,720 750,1320
different devices, {}|
|

1373
00:39:56,740 --> 00:39:57,730
0,150 150,210 210,360 360,630 630,990
so I guess my question
所以我想我的问题是，

1374
00:39:57,730 --> 00:39:59,440
0,210 210,300 300,870 1020,1590 1590,1710
sort of is,| like in
|就像你将如何部署这个东西的整体图景一样，

1375
00:39:59,440 --> 00:40:00,700
0,240 240,660 660,960 960,1140 1140,1260
the overall picture of how

1376
00:40:00,700 --> 00:40:01,570
0,90 90,210 210,510 510,690 690,870
you would deploy this thing,|
|

1377
00:40:01,570 --> 00:40:03,220
0,210 210,480 480,840 1140,1530 1530,1650
why is that,| {} I
为什么会这样呢，|我的意思是，我想象你可以用一堆电话像木筏状态机一样运行，

1378
00:40:03,220 --> 00:40:04,030
0,150 150,210 210,570 570,690 690,810
mean I imagine you could

1379
00:40:04,030 --> 00:40:05,530
0,570 840,960 960,1170 1170,1350 1350,1500
run a {} like a

1380
00:40:05,530 --> 00:40:06,610
0,420 420,600 600,900 900,1050 1050,1080
raft state machine with a

1381
00:40:06,610 --> 00:40:07,660
0,120 120,210 210,870
bunch of phones,|
|

1382
00:40:07,940 --> 00:40:09,920
0,480 480,720 720,870 870,1260 1740,1980
{} it might be poor
它可能是可用性较差，

1383
00:40:09,920 --> 00:40:12,410
0,750 750,1170 1200,1950 1980,2400 2400,2490
availability,| but you've implemented the
|但您已经实现了配置更改，

1384
00:40:12,410 --> 00:40:13,790
0,510 510,810 810,930 930,1020 1020,1380
configuration changes,| so in principle
|所以原则上可以这样做，

1385
00:40:13,790 --> 00:40:14,720
0,270 270,630
could that,|
|

1386
00:40:15,290 --> 00:40:16,010
0,300 300,390 390,510 510,660 660,720
really, I'm just trying to
真的，我只是想弄清楚客户的角色是什么，

1387
00:40:16,010 --> 00:40:16,700
0,180 180,240 240,330 330,450 450,690
figure out what the role

1388
00:40:16,700 --> 00:40:17,450
0,60 60,150 150,540 540,690 690,750
of the client is,| in
|在这整个过程中，服务器是一个有意义的服务器集群，

1389
00:40:17,450 --> 00:40:18,200
0,90 90,270 270,390 390,450 450,750
this whole thing, the server

1390
00:40:18,200 --> 00:40:19,040
0,150 150,210 210,480 480,540 540,840
is a cluster of servers

1391
00:40:19,040 --> 00:40:20,480
0,120 120,300 300,540 540,810 810,1440
that makes sense,| the applications
|有意义的应用程序，但是。

1392
00:40:20,480 --> 00:40:21,740
0,120 120,270 270,570 570,840
that make sense, but.|
|

1393
00:40:22,270 --> 00:40:23,980
0,360 360,810 810,900 900,1380 1410,1710
So basically the client,| it's
所以基本上客户，|这基本上就像是编写实现的一种不错的方式，

1394
00:40:23,980 --> 00:40:25,810
0,510 510,720 720,930 930,1140 1140,1830
basically just like a nice

1395
00:40:25,840 --> 00:40:27,880
0,300 300,810 870,1680 1710,1980 1980,2040
way to like write the

1396
00:40:27,880 --> 00:40:29,920
0,780 1050,1440 1440,1590 1590,1800 1800,2040
implementation,| {} so the server
|所以服务器和客户端，

1397
00:40:29,920 --> 00:40:30,640
0,120 120,210 210,540 540,630 630,720
and the client,| you can
|你基本上可以把它想象成一台服务器，

1398
00:40:30,640 --> 00:40:31,570
0,300 300,450 450,540 540,750 750,930
basically think of that as

1399
00:40:31,570 --> 00:40:32,950
0,30 30,540 690,1020 1020,1170 1170,1380
a server,| {} is just
|就像我们的实现一样，

1400
00:40:32,950 --> 00:40:35,140
0,240 420,660 660,1530 1530,2130 2130,2190
like in our implementation,| it
|创造这个抽象概念是有意义的，是的。

1401
00:40:35,140 --> 00:40:36,340
0,180 180,360 360,510 510,960 960,1200
made sense to create this

1402
00:40:36,340 --> 00:40:38,680
0,690 1020,1680 1830,2160
abstraction, {} yeah.|
|

1403
00:40:38,940 --> 00:40:40,980
0,450 780,1170
Okay, thanks.|
好的，谢谢。|

1404
00:40:43,760 --> 00:40:44,570
0,300 300,390 390,600 600,720 720,810
{} In order for the
为了让这轮谈判取得进展，

1405
00:40:44,570 --> 00:40:46,250
0,270 270,360 360,930 930,1290 1290,1680
round to progress,| all peers
|所有对等点必须从其中n-1个对等点的所有其他对等点接收消息

1406
00:40:46,250 --> 00:40:47,900
0,180 180,930 960,1110 1110,1470 1470,1650
must receive the message from

1407
00:40:47,900 --> 00:40:48,980
0,180 180,300 300,450 450,750 750,1080
all the other peers where

1408
00:40:48,980 --> 00:40:50,570
0,90 90,360 360,630 630,1110 1320,1590
{n-1 - -} peers| and
|所以如果你有一些非常奇怪的隔板，

1409
00:40:50,570 --> 00:40:51,830
0,330 330,420 420,510 510,870 870,1260
so if you have some

1410
00:40:51,830 --> 00:40:53,540
0,300 300,600 600,1110 1110,1350 1350,1710
very weird partition,| where like
|其中像某些子集能够与子集的其余部分对话，

1411
00:40:53,810 --> 00:40:54,770
0,300 300,630 630,720 720,870 870,960
some subset is able to

1412
00:40:54,770 --> 00:40:55,970
0,330 330,720 810,900 900,1110 1110,1200
talk to the rest of

1413
00:40:55,970 --> 00:40:57,980
0,90 90,690 750,1470 1530,1890 1890,2010
the subset,| {} how would
|这个问题将如何在这里得到解决？

1414
00:40:57,980 --> 00:40:59,140
0,120 120,240 240,630 630,990
that be resolved here?|
|

1415
00:41:01,640 --> 00:41:03,260
0,720 840,1080 1080,1230 1230,1350 1350,1620
{} Yeah, so if you,
是的，所以如果你，如果你喜欢把分区分成小于，

1416
00:41:03,260 --> 00:41:04,850
0,150 150,450 450,900 900,1320 1320,1590
if you like partition into

1417
00:41:04,850 --> 00:41:07,190
0,480 660,1140 1170,1650 1650,2040 2040,2340
like {} smaller than,| like
|比如，如果每个人都是少数族裔，

1418
00:41:07,190 --> 00:41:10,040
0,810 840,1140 1140,1290 1290,2250 2280,2850
if everyone is minorities,| then
|然后它就会永远卡住，

1419
00:41:10,040 --> 00:41:10,970
0,390 390,510 510,660 660,840 840,930
then it would just be

1420
00:41:10,970 --> 00:41:13,250
0,390 390,930 1110,1770 1830,2160 2160,2280
stuck forever,| {} until you
|直到你找到多数票

1421
00:41:13,250 --> 00:41:14,450
0,180 180,240 240,840 840,960 960,1200
find a majority| and then
|一旦你获得了多数票，

1422
00:41:14,450 --> 00:41:15,650
0,420 420,510 510,600 600,690 690,1200
once you have a majority,|
|

1423
00:41:15,650 --> 00:41:17,720
0,120 120,540 600,900 900,1800 1800,2070
you can like they, they
你可以喜欢他们，他们会自动提交，

1424
00:41:17,720 --> 00:41:20,000
0,630 630,1050 1050,1290 1290,1680 1680,2280
automatically submit,| like remove server
|与删除服务器RPC一样，

1425
00:41:20,150 --> 00:41:22,580
0,540 540,990 990,1260 1350,1650 1650,2430
{} {RPCs -},| {} whenever
|每当他们得不到某人的回应时，

1426
00:41:22,580 --> 00:41:23,600
0,240 240,480 480,630 630,690 690,1020
they don't get a response

1427
00:41:23,600 --> 00:41:24,710
0,150 150,510 510,660 660,870 870,1110
from someone,| so then the
|因此，群集LIKE会缩小，直到没有响应的节点消失。

1428
00:41:24,800 --> 00:41:27,290
0,510 510,660 660,1320 1350,2010 2040,2490
cluster like shrinks until like

1429
00:41:27,290 --> 00:41:29,870
0,810 840,1140 1140,1620 1620,2010 2010,2580
the non responding nodes disappeared.|
|

1430
00:41:34,130 --> 00:41:35,540
0,300 300,570 570,990 990,1230 1230,1410
{} I noticed in the
我注意到在您给出的演示示例中，

1431
00:41:35,540 --> 00:41:37,340
0,330 330,810 810,960 960,1410 1470,1800
demo example you gave,| you
|你有一个人写了两条信息

1432
00:41:37,340 --> 00:41:39,080
0,300 300,540 540,1050 1050,1320 1320,1740
had one person who wrote

1433
00:41:39,080 --> 00:41:41,210
0,210 210,360 360,600 600,1350 1410,2130
two of the messages| and
|所以，另一个写了第三条信息的人

1434
00:41:41,330 --> 00:41:42,890
0,300 300,300 840,1200 1200,1440 1440,1560
so, {} someone else who

1435
00:41:42,890 --> 00:41:45,080
0,390 390,510 510,1380 1380,1920 1950,2190
wrote the third message| and
|这意味着你可以让写了两条信息的人

1436
00:41:45,080 --> 00:41:45,830
0,120 120,300 300,420 420,510 510,750
that meant that you could

1437
00:41:45,890 --> 00:41:46,700
0,180 180,270 270,570 570,630 630,810
that the person who wrote

1438
00:41:46,700 --> 00:41:48,440
0,120 120,510 510,810 900,1440 1440,1740
two messages| could always tell
|总是能分辨出第三个人分享了什么，

1439
00:41:48,440 --> 00:41:49,730
0,240 240,450 450,720 720,1080 1080,1290
what that third person had

1440
00:41:49,730 --> 00:41:51,470
0,570 630,1200 1200,1470 1470,1650 1650,1740
shared,| doesn't that sort of
|这是不是有点违背了你的协议的目的。

1441
00:41:51,470 --> 00:41:52,430
0,330 330,420 420,780 780,840 840,960
defeat the purpose of your

1442
00:41:52,430 --> 00:41:53,120
0,570
protocol.|
|

1443
00:41:55,040 --> 00:41:57,440
0,750 750,1050 1050,1530 1710,2160 2160,2400
Yeah, yeah, so the reason
是的，是的，所以为什么是两条信息，

1444
00:41:57,440 --> 00:41:58,640
0,210 210,270 270,510 510,660 660,1200
why it was two messages,|
|

1445
00:41:58,640 --> 00:42:00,820
0,360 360,660 660,1200 1320,1830
because we're running, {}
因为我们正在运行，所以我们在同一台计算机上运行这两个实例，

1446
00:42:01,280 --> 00:42:02,210
0,270 270,480 480,690 690,750 750,930
we're running both of those

1447
00:42:02,210 --> 00:42:04,190
0,420 420,930 990,1110 1110,1350 1350,1980
instances on the same computer,|
|

1448
00:42:04,750 --> 00:42:06,400
0,540 570,780 780,1260 1290,1470 1470,1650
{} that is, that is
就是说，这是一个攻击，虽然在哪里，

1449
00:42:06,400 --> 00:42:08,170
0,390 390,810 810,1110 1110,1530 1650,1770
an attack though where,| you
|你知道你拥有它，

1450
00:42:08,170 --> 00:42:09,730
0,150 150,540 540,750 750,960 990,1560
know you have it,| you
|你从一个人被所有人控制的地方开始，

1451
00:42:09,730 --> 00:42:11,770
0,270 270,660 660,1230 1350,1650 1650,2040
start around where one person

1452
00:42:11,770 --> 00:42:14,320
0,150 150,750 750,900 900,1620 2040,2550
is controlled by everyone, {}|
|

1453
00:42:14,350 --> 00:42:15,790
0,420 420,990 990,1260 1260,1350 1350,1440
well like five of the
嗯，就像五台服务器

1454
00:42:15,790 --> 00:42:16,960
0,450 450,660 690,990 990,1050 1050,1170
servers| and five of them
|其中五个提交信息的人被每个人控制，

1455
00:42:16,960 --> 00:42:18,100
0,390 390,750 750,780 780,1050 1050,1140
submitting messages are controlled by

1456
00:42:18,100 --> 00:42:19,240
0,360 360,540 540,690 690,930 930,1140
everyone,| and you know who
|你知道最后一个人是谁，

1457
00:42:19,240 --> 00:42:20,580
0,90 90,360 360,660 660,1020
the last person is,|
|

1458
00:42:20,950 --> 00:42:22,820
0,450 690,1560
but, {}
但是，我认为我们目前认为这就像拜占庭式或非拜占庭式的失败，

1459
00:42:23,840 --> 00:42:25,490
0,90 90,390 390,600 600,1020 1020,1650
I think so we currently

1460
00:42:25,490 --> 00:42:27,830
0,480 480,810 810,1020 1020,1380 1620,2340
consider that like a byzantine

1461
00:42:27,860 --> 00:42:29,360
0,180 180,420 420,930 930,1320 1320,1500
or non byzantine failures,| so
|所以客户的行为是诚实的

1462
00:42:29,360 --> 00:42:30,920
0,150 150,510 510,630 630,960 960,1560
the clients are acting honestly|
|

1463
00:42:30,920 --> 00:42:32,060
0,120 120,210 210,450 450,750 750,1140
and they're not trying to
他们并没有试图在系统中获得不公平的优势

1464
00:42:32,180 --> 00:42:33,680
0,480 480,570 570,1020 1020,1410 1410,1500
gain an unfair amount of

1465
00:42:33,680 --> 00:42:35,270
0,450 450,540 540,600 600,1170 1440,1590
advantage in the system| and
|以及攻击者或监听所有网络流量的人。

1466
00:42:35,270 --> 00:42:36,740
0,480 480,900 900,930 930,1290 1290,1470
the attacker or someone who's

1467
00:42:36,740 --> 00:42:38,090
0,420 420,570 570,690 690,900 900,1350
listening to all the network

1468
00:42:38,090 --> 00:42:38,860
0,630
traffic.|
|

1469
00:42:39,950 --> 00:42:41,330
0,360 360,510 510,990 990,1200 1200,1380
Okay, so you're not worried
好的，所以你并不担心系统中涉及的人破坏它，

1470
00:42:41,330 --> 00:42:42,770
0,180 180,660 660,1260 1260,1380 1380,1440
about people involved in the

1471
00:42:42,770 --> 00:42:44,510
0,360 360,900 900,1140 1260,1500 1500,1740
system undermining it,| you're only
|你只会担心那些喜欢偷看系统并驾驶它的人。

1472
00:42:44,510 --> 00:42:46,070
0,480 480,840 840,1170 1170,1290 1290,1560
worried about people who are

1473
00:42:46,400 --> 00:42:47,990
0,330 330,900 1050,1320 1320,1500 1500,1590
like peeking in on the

1474
00:42:47,990 --> 00:42:49,360
0,420 420,510 510,810 810,1080
system and driving it.|
|

1475
00:42:50,610 --> 00:42:51,990
0,600 600,810 810,1020 1020,1290 1290,1380
Yeah.| Or like kind of,|
嗯。|或者就像是，|

1476
00:42:51,990 --> 00:42:53,700
0,360 360,510 510,870 1080,1380 1380,1710
so I think we're like
所以我认为我们很有信心，

1477
00:42:53,700 --> 00:42:56,340
0,600 600,1230 1230,1440 1440,1980 2010,2640
decently confident that,| like a
|如果他们是拜占庭式的参与者，

1478
00:42:56,340 --> 00:42:58,620
0,600 630,810 810,990 990,1530 1530,2280
if if they're byzantine participants,|
|

1479
00:42:58,620 --> 00:43:00,570
0,600 750,1170 1170,1320 1320,1770 1770,1950
then, {} the protocol will
然后，该协议将失败

1480
00:43:00,570 --> 00:43:02,340
0,540 540,660 660,750 750,1020 1020,1770
fail| and it will fail
|它会失败，就像明确地说，

1481
00:43:02,430 --> 00:43:04,860
0,240 240,990 990,1440 1470,1980 1980,2430
like explicitly,| like and we,|
|像和我们一样，|

1482
00:43:04,860 --> 00:43:06,060
0,330 330,540 540,840 840,990 990,1200
but it's like there are
但这就像是有太多不同的东西，绝对不确定是不是这样，

1483
00:43:06,060 --> 00:43:07,740
0,150 150,300 300,690 690,1260 1260,1680
so many different absolutely not

1484
00:43:07,770 --> 00:43:09,210
0,690 690,1080 1080,1200 1200,1350 1350,1440
exactly certain that that is

1485
00:43:09,210 --> 00:43:10,380
0,90 90,450 660,870 870,1050 1050,1170
the case,| {} but we
|但我们认为是这样，

1486
00:43:10,380 --> 00:43:11,580
0,180 180,390 420,780 780,930 930,1200
think so,| but it's like
|但这就像是。

1487
00:43:11,580 --> 00:43:13,320
0,510 510,1050 1050,1200 1200,1350 1350,1740
it's.| So for the attack
|所以对于当时讨论的袭击，

1488
00:43:13,320 --> 00:43:15,240
0,210 210,390 390,870 870,1230 1260,1920
that got discussed then,| where
|其中有人控制了集群

1489
00:43:15,420 --> 00:43:16,620
0,420 420,720 720,1050 1050,1110 1110,1200
someone takes control of the

1490
00:43:16,620 --> 00:43:18,220
0,570 600,1440
cluster| and
|但它接管了所有

1491
00:43:18,630 --> 00:43:20,010
0,240 240,630 630,930 930,1200 1200,1380
but it takes over all

1492
00:43:20,010 --> 00:43:21,600
0,150 150,750 750,1140 1140,1320 1320,1590
the| and essentially is all
|基本上是所有的客户，除了他们中的一个，

1493
00:43:21,600 --> 00:43:23,460
0,90 90,150 150,870 900,1560 1560,1860
of the clients, except for

1494
00:43:23,460 --> 00:43:24,750
0,420 420,510 510,840 930,1230 1230,1290
one of them,| and if
|如果你是领导者，

1495
00:43:24,750 --> 00:43:25,560
0,120 120,180 180,450 450,600 600,810
you're a leader,| you can
|你可以控制，大概是控制谁从组中添加或删除，

1496
00:43:25,560 --> 00:43:27,330
0,480 480,900 900,1290 1290,1470 1470,1770
control, presumably control who gets

1497
00:43:27,330 --> 00:43:28,470
0,270 270,450 450,900 900,1050 1050,1140
added or removed from the

1498
00:43:28,470 --> 00:43:29,850
0,360 360,480 480,750 840,1260 1260,1380
groups,| you could make that
|你可以做到这一点，

1499
00:43:29,850 --> 00:43:30,840
0,510
happen,|
|

1500
00:43:31,660 --> 00:43:33,010
0,330 330,480 480,600 600,1080 1080,1350
would that be detected by
你们目前的系统能检测到吗。

1501
00:43:33,010 --> 00:43:35,180
0,930 960,1350 1350,1860
your current system.|
|

1502
00:43:35,490 --> 00:43:37,260
0,480 480,810 810,1380 1380,1620 1620,1770
No, no, not not when
不，不，当它是n-1的时候不会，

1503
00:43:37,260 --> 00:43:38,370
0,120 120,330 330,480 480,750 750,1110
it's like {n-1 - -},|
|

1504
00:43:38,460 --> 00:43:39,750
0,510 510,840 840,960 960,1140 1140,1290
{} so we need at
所以我们至少需要两个，

1505
00:43:39,750 --> 00:43:41,100
0,360 360,810 840,990 990,1080 1080,1350
least two,| if we have
|如果我们有两个诚实的人，

1506
00:43:41,100 --> 00:43:44,220
0,270 270,870 1260,2160 2400,2970 2970,3120
two honest people,| then that
|那就足够了，

1507
00:43:44,220 --> 00:43:45,540
0,150 150,240 240,720 750,1230 1230,1320
would be enough,| because they
|因为它们会像是，如果它们彼此断开，

1508
00:43:45,540 --> 00:43:46,830
0,180 180,330 330,750 810,1170 1170,1290
would be like if they

1509
00:43:46,830 --> 00:43:48,570
0,450 540,1200 1200,1350 1350,1470 1470,1740
were disconnected from each other,|
|

1510
00:43:48,570 --> 00:43:50,020
0,540 540,780 780,930 930,1260
they could know that.|
他们可能知道这一点。|

1511
00:43:50,300 --> 00:43:51,260
0,780

1512
00:43:53,810 --> 00:43:55,500
0,240 240,570 570,750 750,930
Alright cool, thank you.|
好的，很好，谢谢。|

1513
00:43:57,960 --> 00:44:00,360
0,600 600,1140 1140,1380 1380,1890 1920,2400
Overtime, thanks very cool,| maybe
加班，谢谢，很酷，|也许麻省理工学院会做出让步，

1514
00:44:00,360 --> 00:44:01,890
0,360 360,720 720,1140 1140,1290 1290,1530
a MIT concession will reach

1515
00:44:01,890 --> 00:44:04,860
0,390 1050,1260 1260,1860 1860,2160 2160,2970
out,| {} let's hear from
|让我们来听听容错项目的意见，

1516
00:44:05,620 --> 00:44:08,640
0,690 720,960 960,2010 2040,2670
the fault tolerance project,|
|

1517
00:44:09,550 --> 00:44:10,330
0,210 210,360 360,450 450,630 630,780
maybe that's a bad way
也许这是一种糟糕的总结方式。

1518
00:44:10,330 --> 00:44:11,720
0,240 360,1020
of summarizing.|
|

1519
00:44:12,370 --> 00:44:14,860
0,90 90,510 1470,2040 2040,2370 2370,2490
No worries.| Yeah, everyone, I'm
别担心。|是的，各位，我是艾丽尔，

1520
00:44:14,860 --> 00:44:16,720
0,450 480,900 1290,1530 1530,1620 1620,1860
Ariel,| {} I've been working
|我和弗兰斯合作这个项目已经有一段时间了，

1521
00:44:16,720 --> 00:44:17,740
0,60 60,180 180,510 510,630 630,1020
on this project with Frans

1522
00:44:17,740 --> 00:44:18,430
0,90 90,150 150,330 330,480 480,690
for a bit now,| so
|让我们看看我能不能分享我的屏幕。

1523
00:44:18,430 --> 00:44:19,420
0,180 180,540 570,690 690,810 810,990
let's see I can share

1524
00:44:19,420 --> 00:44:20,460
0,120 120,720
my screen.|
|

1525
00:44:22,050 --> 00:44:24,780
0,660 660,930 930,1650 1950,2370 2370,2730
{} And so, {} yeah
所以，是的，正如你在这里看到的，

1526
00:44:24,780 --> 00:44:25,590
0,240 240,330 330,420 420,540 540,810
as you can see here,|
|

1527
00:44:25,590 --> 00:44:27,690
0,510 810,1230 1230,1500 1500,1890 1920,2100
a project involves giving fault
一个项目涉及在9P接口上免费提供容错

1528
00:44:27,690 --> 00:44:28,770
0,330 330,450 450,750 750,900 900,1080
tolerance for free at the

1529
00:44:28,770 --> 00:44:30,270
0,270 270,420 420,900 900,1140 1140,1500
{9P -} interface| and also
|并详细分析了这意味着什么和额外的幻灯片，

1530
00:44:30,270 --> 00:44:31,140
0,240 240,450 450,540 540,690 690,870
break down what this means

1531
00:44:31,140 --> 00:44:33,990
0,690 1020,1260 1260,1560 1560,2160 2580,2850
exactly and extra slides, {}|
|

1532
00:44:33,990 --> 00:44:35,100
0,240 240,450 450,540 540,810 810,1110
we start by looking at
我们先来看看服务计算，

1533
00:44:35,130 --> 00:44:36,780
0,450 450,1140 1140,1290 1290,1380 1380,1650
service computation,| so if you've
|因此，如果你听说过像AWS lambda或GCP这样的东西，也有谷歌云功能，

1534
00:44:36,840 --> 00:44:38,490
0,210 210,360 360,900 930,1170 1170,1650
heard of some things like

1535
00:44:38,520 --> 00:44:40,680
0,480 480,1500 1590,2010
AWS lambda or

1536
00:44:40,920 --> 00:44:44,070
0,390 450,1590 1590,1920 1920,2280 2280,3150
{} GCP also Google cloud

1537
00:44:44,070 --> 00:44:47,190
0,660 810,1770 2010,2460 2460,2610 2610,3120
functions,| {} essentially what this
|从本质上讲，它的作用是，

1538
00:44:47,190 --> 00:44:48,330
0,270 270,510 510,870 870,930 930,1140
does is,| instead of having
|而不是必须设置一堆虚拟机

1539
00:44:48,330 --> 00:44:49,830
0,510 840,1140 1140,1200 1200,1410 1410,1500
to set a bunch of

1540
00:44:49,830 --> 00:44:51,720
0,450 450,540 540,660 660,1020 1020,1890
{VMs -}| and scale them
|并根据客户的请求进行扩展，以加载所有内容，

1541
00:44:51,720 --> 00:44:52,830
0,330 330,600 600,660 660,780 780,1110
with requests to your customer

1542
00:44:52,830 --> 00:44:53,880
0,300 300,630 630,750 750,840 840,1050
load everything,| you can just
|您可以只编写一个小的无状态函数，

1543
00:44:53,880 --> 00:44:56,100
0,510 660,960 960,1260 1260,1620 1620,2220
write a small stateless function,|
|

1544
00:44:56,430 --> 00:44:57,600
0,420 420,540 540,870 870,1080 1080,1170
{} do you oppose your
您是否通过一堆小的无状态函数来反对您的应用程序，

1545
00:44:57,600 --> 00:44:58,650
0,450 450,750 750,810 810,990 990,1050
application through a bunch of

1546
00:44:58,650 --> 00:44:59,880
0,270 270,570 570,990 990,1170 1170,1230
small stateless functions,| which are
|其在http请求上被触发，

1547
00:44:59,880 --> 00:45:02,610
0,270 270,450 450,1020 1020,1800 2040,2730
triggered over http requests,| and
|然后，AWS或Google云或您的服务提供商将负责扩展

1548
00:45:02,610 --> 00:45:05,130
0,570 570,1170 1170,1440 1560,2100 2100,2520
then AWS or Google cloud

1549
00:45:05,130 --> 00:45:06,420
0,90 90,240 240,570 570,990 1020,1290
or who are your service

1550
00:45:06,420 --> 00:45:08,250
0,720 720,930 930,1260 1260,1350 1350,1830
providers will handle the scaling|
|

1551
00:45:08,250 --> 00:45:09,900
0,330 330,510 510,780 780,1290 1290,1650
and all the infrastructure management
并为您提供所有基础设施管理，

1552
00:45:09,900 --> 00:45:10,520
0,270 270,510
for you,|
|

1553
00:45:10,880 --> 00:45:11,750
0,270 270,390 390,480 480,570 570,870
{} and this is nice,|
这很好，|

1554
00:45:11,750 --> 00:45:13,940
0,600 630,870 870,1440 1500,1800 1800,2190
because {} {in,theory -} operators
因为理论上运营商可以更有效地平衡资源，

1555
00:45:13,940 --> 00:45:15,680
0,300 300,600 600,1110 1110,1290 1290,1740
can balance resources more effectively,|
|

1556
00:45:15,680 --> 00:45:17,960
0,150 150,420 1050,1260 1260,1440 1440,2280
they can get high utilization,|
他们可以获得很高的利用率，|

1557
00:45:18,380 --> 00:45:19,850
0,540 540,930 930,1050 1050,1320 1320,1470
{} and in theory it's
从理论上讲，这对开发人员来说也更容易，

1558
00:45:19,850 --> 00:45:20,960
0,210 210,300 300,720 720,840 840,1110
easier for developers as well,|
|

1559
00:45:20,960 --> 00:45:21,440
0,120 120,180 180,270 270,360 360,480
all you have to do
你所要做的就是，

1560
00:45:21,440 --> 00:45:23,270
0,420 1050,1470 1470,1620 1620,1740 1740,1830
is,| is you don't have
|您不必担心所有这些基础设施管理

1561
00:45:23,270 --> 00:45:24,020
0,90 90,240 240,450 450,570 570,750
to worry about all this

1562
00:45:24,020 --> 00:45:26,300
0,240 240,450 750,1320 1320,1860 1860,2280
kind of infrastructure management| and
|并且有足够的净空

1563
00:45:26,300 --> 00:45:27,830
0,240 240,300 300,510 510,720 720,1530
sort of having enough headroom|
|

1564
00:45:27,920 --> 00:45:29,570
0,390 390,510 510,780 780,1080 1110,1650
and your {number -} of
以及您的虚拟机数

1565
00:45:29,570 --> 00:45:30,950
0,60 60,150 150,480 480,870 900,1380
VMs| and everything to handle
|以及处理客户负载激增等问题的一切措施。

1566
00:45:30,950 --> 00:45:32,210
0,390 390,480 480,840 840,1140 1140,1260
spikes in customer load and

1567
00:45:32,210 --> 00:45:33,040
0,180 180,330 330,720
things like this.|
|

1568
00:45:34,440 --> 00:45:36,000
0,600 600,810 810,1200 1200,1320 1320,1560
However, the reality is not
然而，现实并不像理论那么美好，

1569
00:45:36,000 --> 00:45:38,100
0,720 720,960 960,1320 1470,1590 1590,2100
as nice as the theory,|
|

1570
00:45:38,280 --> 00:45:40,500
0,600 690,960 960,1380 1470,2100 2100,2220
{} which is {} in
也就是说，到最后，

1571
00:45:40,500 --> 00:45:42,240
0,120 120,630 840,1500
the end, {}|
|

1572
00:45:42,350 --> 00:45:44,840
0,240 240,480 480,720 720,1800 1860,2490
{} in current implementations,| actually
在当前的实现中，|实际上构建这些复杂的应用程序是相当困难的，

1573
00:45:44,840 --> 00:45:47,150
0,600 600,780 780,1140 1140,2190 2190,2310
building these complex applications is

1574
00:45:47,150 --> 00:45:48,940
0,270 270,840 870,1500
quite difficult, {}|
|

1575
00:45:49,450 --> 00:45:50,920
0,300 300,510 510,960 960,1080 1080,1470
{} and decomposing them into
将它们分解成这些状态函数相当困难，

1576
00:45:50,920 --> 00:45:53,050
0,480 510,960 960,1410 1410,1650 1650,2130
these state functions quite difficult,|
|

1577
00:45:53,050 --> 00:45:55,090
0,240 240,540 540,1140 1290,1560 1560,2040
in part because these lambdas
部分因为这些波长这些无状态函数缺乏丰富的通信原语，

1578
00:45:55,090 --> 00:45:57,190
0,510 510,840 840,1440 1440,1800 1830,2100
these stateless functions lack rich

1579
00:45:57,190 --> 00:45:59,740
0,660 660,1380 1410,2310
communication primitives, {}|
|

1580
00:46:00,220 --> 00:46:02,050
0,240 240,600 600,810 810,1320 1320,1830
which would be important support
这将是构建复杂应用程序的重要支持，

1581
00:46:02,050 --> 00:46:04,180
0,270 330,630 630,990 990,1830 1860,2130
to build complex applications,| so
|所以他们不能直接交流，也不能相互沟通，

1582
00:46:04,180 --> 00:46:05,830
0,360 390,480 480,750 750,1080 1080,1650
{} they can't directly communicate

1583
00:46:05,830 --> 00:46:07,120
0,240 240,450 450,600 600,720 720,1290
or through to each other,|
|

1584
00:46:07,720 --> 00:46:08,800
0,390 390,720 720,810 810,960 960,1080
therefore systems that try to
因此，试图利用无服务器功能的系统，

1585
00:46:08,800 --> 00:46:11,350
0,720 780,1260 1260,1950 1980,2400 2400,2550
utilize serverless functions,| have had
|他们不得不构建自己的定制通信解决方案，

1586
00:46:11,350 --> 00:46:12,100
0,90 90,270 270,390 390,600 600,750
to sort of build their

1587
00:46:12,100 --> 00:46:16,270
0,480 1380,1740 1740,2550 2550,3420 3450,4170
own custom communication solutions,| like
|比如把两端放在边上，

1588
00:46:16,330 --> 00:46:17,800
0,300 300,540 540,930 1080,1260 1260,1470
maybe setting up the ends

1589
00:46:17,800 --> 00:46:18,580
0,120 120,180 180,510 510,630 630,780
on the side,| that they
|他们围着每个人说话

1590
00:46:18,580 --> 00:46:20,020
0,270 270,600 600,900 900,1200 1200,1440
round everyone talk through| or
|或者通过存储系统(如S3)进行交谈

1591
00:46:20,020 --> 00:46:22,150
0,300 300,840 1080,1500 1500,1830 1830,2130
talking through a storage systems,

1592
00:46:22,150 --> 00:46:23,230
0,150 150,360 360,690 690,810 810,1080
like {S3 -}| and this
|这使得它们变得高效，开发人员很难真正以合理的方式将它们组合在一起，

1593
00:46:23,230 --> 00:46:24,610
0,210 210,330 330,780 780,1050 1050,1380
makes them efficient and difficult

1594
00:46:24,610 --> 00:46:26,260
0,60 60,570 570,1140 1140,1500 1500,1650
for developers to actually put

1595
00:46:26,260 --> 00:46:27,700
0,510 540,690 690,750 750,1140 1140,1440
together in a sensible way,|
|

1596
00:46:28,060 --> 00:46:29,180
0,810

1597
00:46:29,290 --> 00:46:31,540
0,660 660,810 810,1710 1740,2070 2070,2250
all this complexity causes data
所有这些复杂性导致数据中心实际上管理资源相当糟糕，

1598
00:46:31,540 --> 00:46:32,770
0,210 210,300 300,540 540,780 780,1230
centers to actually manage resources

1599
00:46:32,770 --> 00:46:36,760
0,300 300,810 840,1350 2070,2700 3090,3990
quite poor,| {} and {}
|问题是，

1600
00:46:37,450 --> 00:46:39,160
0,510 570,960 960,1230 1230,1320 1320,1710
and the problem is that,|
|

1601
00:46:39,430 --> 00:46:40,990
0,300 300,510 510,750 750,1230 1350,1560
{} we still have all
我们仍然将所有这些数据中心资源划分为一组本地名称空间，

1602
00:46:40,990 --> 00:46:43,120
0,150 150,390 390,990 1020,1650 1650,2130
these data center resources segmented

1603
00:46:43,120 --> 00:46:44,650
0,210 210,270 270,510 510,840 990,1530
into a bunch of local

1604
00:46:44,650 --> 00:46:46,420
0,240 240,690 690,930 930,1170 1170,1770
name spaces,| which are destroyed
|它们都被摧毁了，你不能在它们之间共享资源。

1605
00:46:46,420 --> 00:46:48,310
0,480 540,810 810,1320 1530,1680 1680,1890
and {} and you can't

1606
00:46:48,310 --> 00:46:49,860
0,240 240,630 630,990 990,1170
share resources across them.|
|

1607
00:46:50,790 --> 00:46:51,720
0,300 300,510 510,600 600,660 660,930
So what we were looking
因此，我们正在研究的是恢复过去几十年的一些名为Plan9的工作

1608
00:46:51,720 --> 00:46:54,750
0,420 630,1020 1020,1470 1470,2280 2310,3030
at {} was reviving some

1609
00:46:54,900 --> 00:46:58,110
0,420 420,1050 1110,1740 2010,2580 2580,3210
work {} from past decades

1610
00:46:58,110 --> 00:47:00,060
0,330 330,600 600,1050 1140,1710 1710,1950
called {Plan9 -}| and Plan9
|和Plan9实质上提供了统一数据中心资源的计划

1611
00:47:00,060 --> 00:47:02,520
0,90 90,900 1170,1920 1920,2280 2280,2460
are essentially provides plan for

1612
00:47:02,520 --> 00:47:04,590
0,630 630,840 840,1050 1050,1740 1800,2070
unifying data center resources| and
|并提供单个系统映像，

1613
00:47:04,590 --> 00:47:06,390
0,330 330,690 690,960 960,1290 1290,1800
providing a single system image,|
|

1614
00:47:06,920 --> 00:47:08,030
0,180 180,300 300,540 540,960 960,1110
what this means essentially when
当您编写应用程序时，这实际上意味着什么，

1615
00:47:08,030 --> 00:47:09,290
0,120 120,300 300,420 420,1110 1140,1260
you write your application,| you
|你不必担心什么东西在什么机器上运行，

1616
00:47:09,290 --> 00:47:10,250
0,90 90,210 210,300 300,480 480,960
don't have to worry about

1617
00:47:10,280 --> 00:47:11,780
0,240 240,510 510,630 630,840 840,1500
what runs on what machines,|
|

1618
00:47:11,780 --> 00:47:13,880
0,390 510,960 960,1590 1590,1830 1860,2100
{} about provisioning {} {VMs
关于调配虚拟机或类似的内容，

1619
00:47:13,880 --> 00:47:14,900
0,90 90,120 120,360 360,510 510,1020
-} or anything like that,|
|

1620
00:47:15,170 --> 00:47:18,020
0,750 750,1410 1650,2220 2430,2670 2670,2850
{} or {} making sure
或确保某些VM上的应用程序的某些部分，

1621
00:47:18,020 --> 00:47:19,220
0,180 180,840 840,1080 1080,1140 1140,1200
that certain parts of the

1622
00:47:19,220 --> 00:47:20,600
0,540 540,630 630,900 900,1230 1230,1380
application {on -} certain VMs,|
|

1623
00:47:20,600 --> 00:47:21,740
0,120 120,270 270,480 480,630 630,1140
it all looks like one
这一切看起来都像是一个巨人对您的应用程序来说就是名称空间，

1624
00:47:22,100 --> 00:47:22,740
0,450
{}

1625
00:47:22,920 --> 00:47:24,780
0,540 540,750 750,990 990,1620 1710,1860
giants are name space to

1626
00:47:24,780 --> 00:47:26,940
0,180 180,900 1020,1350 1350,1830 1860,2160
your application,| {} so your
|因此，您的应用程序完全不知道它实际运行在什么硬件上

1627
00:47:26,970 --> 00:47:28,410
0,480 480,630 630,900 900,1080 1080,1440
application knows nothing about what

1628
00:47:28,530 --> 00:47:29,910
0,420 420,540 540,810 810,1110 1110,1380
hardware it's actually running on|
|

1629
00:47:29,910 --> 00:47:32,190
0,60 60,600 840,1560 1590,1800 1800,2280
or where {} other services
或者在数据中心有其他服务的情况下，

1630
00:47:32,190 --> 00:47:33,210
0,240 240,300 300,390 390,540 540,1020
are in the data centre,|
|

1631
00:47:33,450 --> 00:47:36,780
0,750 780,1230 1230,1620 1620,2370 2400,3330
{} {the,ways} achieved is applications
实现的方式是应用服务通过全局分层命名空间进行通信，

1632
00:47:36,780 --> 00:47:38,940
0,450 450,1020 1020,1380 1380,1770 1800,2160
services communicate through a global

1633
00:47:38,940 --> 00:47:40,440
0,630 630,840 840,1440
hierarchical {namespace -},|
|

1634
00:47:40,970 --> 00:47:43,250
0,660 840,1530 1530,1650 1650,2160 2190,2280
{} services and resources to
服务和资源，以公开统一的文件系统类接口，

1635
00:47:43,250 --> 00:47:45,770
0,780 780,1230 1260,2010 2040,2250 2250,2520
expose {} uniform file system

1636
00:47:45,770 --> 00:47:47,720
0,330 330,1050 1320,1590 1590,1860 1860,1950
like interface,| {} you don't
|您不必担心实现和调用客户RPC，

1637
00:47:47,720 --> 00:47:49,250
0,90 90,180 180,330 330,870 900,1530
have to worry about implementing

1638
00:47:49,250 --> 00:47:52,190
0,480 660,1050 1050,1500 1500,2100 2430,2940
and calling customer RPCs, {}|
|

1639
00:47:52,190 --> 00:47:53,300
0,150 150,300 300,390 390,990 990,1110
and so for example and
例如，在这棵树上，

1640
00:47:53,300 --> 00:47:54,340
0,360 360,840
this, {}

1641
00:47:54,600 --> 00:47:55,800
0,270 270,540 540,990 990,1080 1080,1200
in this tree,| you can
|你可以在这里看到，

1642
00:47:55,800 --> 00:47:59,340
0,180 180,870 900,1800 2250,2880 3240,3540
see here,| {} we have
|我们有顶级的根级名称空间，

1643
00:47:59,340 --> 00:48:00,960
0,150 150,390 390,1080 1080,1440 1440,1620
the top level root level

1644
00:48:00,960 --> 00:48:02,460
0,180 180,600 600,750 750,1230 1260,1500
name space,| and then under
|然后我们有三个注册的服务，

1645
00:48:02,460 --> 00:48:03,870
0,240 240,330 330,480 480,720 720,1410
that we have three services

1646
00:48:03,870 --> 00:48:05,610
0,750 750,990 990,1440 1470,1590 1590,1740
registered,| we have an {S3
|我们有S3服务，

1647
00:48:05,610 --> 00:48:07,200
0,180 180,570 570,1020 1050,1470 1470,1590
-} service,| which you can
|你可以用它把你的[着陆器]连接到S3，

1648
00:48:07,200 --> 00:48:09,510
0,210 210,300 300,780 1050,1620 1650,2310
use to connect {} your

1649
00:48:09,510 --> 00:48:11,130
0,690 690,780 780,1230 1230,1500 1500,1620
[landers] to {S3 -},| you
|您可以通过它访问密钥、S3密钥和值，

1650
00:48:11,130 --> 00:48:12,540
0,330 360,780 780,1350
can access keys,

1651
00:48:12,740 --> 00:48:14,240
0,450 450,1050 1050,1200 1200,1410 1410,1500
{} {S3 -} keys and

1652
00:48:14,240 --> 00:48:15,980
0,690 690,900 900,1200 1200,1620 1650,1740
values through that,| {} we
|我们有内存中的文件系统和调度

1653
00:48:15,980 --> 00:48:17,750
0,180 180,390 390,990 990,1230 1230,1770
have an in-memory file system

1654
00:48:17,780 --> 00:48:19,900
0,390 420,1020 1230,1440 1440,1860
and sched| and so
|而且这么快。

1655
00:48:20,200 --> 00:48:21,300
0,780
quickly.|
|

1656
00:48:21,790 --> 00:48:22,540
0,570
Yeah,
是的，这就是典型的9P名称空间是什么样子的，

1657
00:48:23,160 --> 00:48:24,630
0,330 330,570 570,630 630,810 810,1470
so this is what the

1658
00:48:24,660 --> 00:48:27,090
0,180 180,300 300,660 930,1650 2040,2430
what like a typical 9P

1659
00:48:27,090 --> 00:48:28,290
0,210 210,480 480,600 600,750 750,1200
name space would look like,|
|

1660
00:48:29,550 --> 00:48:31,950
0,570 570,990 1020,1470 2070,2280 2280,2400
{} we have done some
我们已经做了一些工作来实现这个9P架构的例子，

1661
00:48:31,950 --> 00:48:34,950
0,240 240,360 360,1020 1020,1770 2400,3000
work to implement {} example

1662
00:48:34,950 --> 00:48:35,940
0,120 120,390 390,570 570,750 750,990
of {} of this {9P

1663
00:48:35,940 --> 00:48:38,400
0,450 480,1470 1650,1950 1950,2250 2250,2460
-} architecture,| {} we have
|我们有一个像动物园管理员一样的配置服务，

1664
00:48:38,400 --> 00:48:40,110
0,360 390,660 660,990 990,1170 1170,1710
a, {zookeeper -} like configuration

1665
00:48:40,110 --> 00:48:41,610
0,510 510,990 1020,1230 1230,1320 1320,1500
service,| which hosts the top
|它主存顶级名称空间，

1666
00:48:41,610 --> 00:48:43,110
0,180 180,390 390,900 1020,1140 1140,1500
level name space,| we have
|我们有一个调度程序和一堆NP服务器，9P服务器，

1667
00:48:43,140 --> 00:48:44,730
0,30 90,750 750,1140 1230,1410 1410,1590
a scheduler and a bunch

1668
00:48:44,730 --> 00:48:46,530
0,90 90,390 390,750 750,1350 1380,1800
of these np servers, {9P

1669
00:48:46,530 --> 00:48:48,690
0,300 330,990 1350,1770 1770,2010 2010,2160
-} servers,| {} what these
|它们所做的是公开资源和功能

1670
00:48:48,690 --> 00:48:49,980
0,120 120,210 210,330 330,750 750,1290
do is they expose resources

1671
00:48:49,980 --> 00:48:51,990
0,240 240,900 900,1170 1170,1530 1530,2010
and functionality| such as the
|比如，如果我们回到这里，

1672
00:48:52,050 --> 00:48:53,280
0,330 330,420 420,540 540,780 780,1230
if we go back here,|
|

1673
00:48:53,370 --> 00:48:54,780
0,510 510,870 870,1140 1140,1200 1200,1410
this three part of name
名称空间的这三个部分，

1674
00:48:54,780 --> 00:48:56,580
0,360 360,450 450,840 870,1200 1200,1800
space,| you can write {}
|您可以编写连接S3存储桶的服务

1675
00:48:57,060 --> 00:48:59,070
0,150 150,660 660,1020 1020,1590 1620,2010
a service which {} connected

1676
00:48:59,070 --> 00:49:00,450
0,180 180,330 330,510 510,1050 1050,1380
{S3 - -} buckets| and
|并将其暴露在9p下，这将是一个9p服务器。

1677
00:49:00,450 --> 00:49:01,710
0,330 330,720 720,840 840,990 990,1260
and expose it to {9P

1678
00:49:01,710 --> 00:49:02,730
0,300 300,540 540,780 780,900 900,1020
-} and this would be

1679
00:49:02,730 --> 00:49:04,480
0,210 210,450 450,660 660,1050
a {9P -} server.|
|

1680
00:49:05,250 --> 00:49:06,740
0,420 420,600 600,1140
{} And the
以及用于与这些不同服务交互的RPC或操作

1681
00:49:06,940 --> 00:49:08,350
0,540 540,750 750,1140 1140,1230 1230,1410
{} {RPCs -} or the

1682
00:49:08,350 --> 00:49:10,840
0,540 540,630 630,1020 1020,1410 1860,2490
operations that used to {}

1683
00:49:10,900 --> 00:49:12,670
0,360 360,480 480,930 930,1350 1350,1770
interact with these different services|
|

1684
00:49:12,670 --> 00:49:14,710
0,150 150,630 660,1080 1410,1770 1770,2040
are all {} the {9P
都是9P操作，

1685
00:49:14,710 --> 00:49:15,970
0,120 120,600 600,720 720,900 900,1260
-} operations,| so it's a
|所以这是一个非常小的，定义很好的一组操作，

1686
00:49:15,970 --> 00:49:17,530
0,210 210,750 780,1020 1020,1350 1350,1560
very small, well defined set

1687
00:49:17,530 --> 00:49:20,200
0,240 450,1530 1530,1770 1770,2310 2520,2670
of operations,| that, {} you
|你可以在这里看到他们中的一些人，

1688
00:49:20,200 --> 00:49:20,770
0,120 120,270 270,360 360,510 510,570
can see a few of

1689
00:49:20,770 --> 00:49:21,760
0,120 120,390 390,570 570,720 720,990
them here,| such as read
|例如读和写会移动较少规范文件系统操作。

1690
00:49:21,760 --> 00:49:24,490
0,120 120,540 570,1320 1320,1680 2520,2730
and write moves that {}

1691
00:49:24,490 --> 00:49:25,480
0,270 270,540 540,780
small number of

1692
00:49:25,930 --> 00:49:28,180
0,630 630,1140 1140,1890
canonical {file,system} operations.|
|

1693
00:49:29,470 --> 00:49:30,550
0,180 180,360 360,630 630,840 840,1080
I so quickly done, what
我这么快就做了，这看起来是什么样子，

1694
00:49:30,550 --> 00:49:33,250
0,180 180,420 420,960 1080,2340 2370,2700
this looks like,| {} so
|例如，在这里，

1695
00:49:33,250 --> 00:49:35,170
0,120 120,930 1200,1680 1680,1770 1770,1920
for example here,| I can
|我可以启动正确的基础设施。

1696
00:49:35,170 --> 00:49:37,840
0,270 270,420 420,750 750,1680
start up correct infrastructure.|
|

1697
00:49:40,690 --> 00:49:42,130
0,390 390,510 510,630 630,810 810,1440
So I can look into,|
这样我就可以调查，|

1698
00:49:42,160 --> 00:49:43,270
0,210 210,300 300,420 420,630 630,1110
{} you can map this
您可以将这个名称空间直接映射到Linux中，

1699
00:49:43,300 --> 00:49:45,010
0,540 540,750 750,930 930,1080 1080,1710
name space right into Linux,|
|

1700
00:49:45,670 --> 00:49:47,890
0,330 330,420 420,540 540,1200 1590,2220
so I can see {}
这样我就能看到一些服务

1701
00:49:47,950 --> 00:49:51,760
0,540 540,1110 1110,2370 2790,3390 3450,3810
some services| and {} different
|以及我们在这里安装的不同名称空间，

1702
00:49:51,760 --> 00:49:52,840
0,240 240,510 510,600 600,750 750,1080
name spaces that we've mounted

1703
00:49:52,840 --> 00:49:53,680
0,300 300,390 390,720 720,780 780,840
here,| for example if I
|例如，如果我看一下S3，

1704
00:49:53,680 --> 00:49:55,150
0,150 150,270 270,810 810,1020 1020,1470
look at {S3 - -},|
|

1705
00:49:58,610 --> 00:50:00,560
0,270 270,600 600,960 960,1350 1350,1950
this is actually connecting to
这实际上是连接到我们拥有的S3存储桶，

1706
00:50:00,890 --> 00:50:02,840
0,750 990,1380 1380,1560 1560,1860 1860,1950
{} {S3 -} bucket that

1707
00:50:02,840 --> 00:50:03,780
0,120 120,570
we have,|
|

1708
00:50:03,980 --> 00:50:06,050
0,600 750,1140 1140,1440 1830,1980 1980,2070
{} I'm sorry do you
抱歉，你真的看到S3桶里的钥匙了吗，

1709
00:50:06,050 --> 00:50:08,780
0,990 1020,1380 1380,2070 2220,2670 2670,2730
actually see the keys in

1710
00:50:08,780 --> 00:50:09,590
0,90 90,240 240,390 390,660 660,810
the {S3 -} bucket,| just
|就像文件系统中的文件一样，

1711
00:50:09,590 --> 00:50:10,790
0,150 150,510 510,750 780,990 990,1200
as files in your file

1712
00:50:10,790 --> 00:50:13,730
0,420 720,1260 1500,1860 1860,1920 1920,2940
system,| and this is S3
|这是S3桶在这里，

1713
00:50:13,730 --> 00:50:15,230
0,300 300,450 450,870 1230,1410 1410,1500
bucket over here,| so if
|所以如果我想创建，写一个新的密钥，

1714
00:50:15,230 --> 00:50:16,970
0,60 60,240 240,570 570,1230 1260,1740
I want to create, write

1715
00:50:16,970 --> 00:50:18,410
0,90 90,330 330,750 750,840 840,1440
a new key,| for example,
|例如，我所要做的就是说猫，回声，

1716
00:50:18,590 --> 00:50:19,340
0,270 270,300 300,450 450,540 540,750
all I need to do

1717
00:50:19,340 --> 00:50:25,800
0,150 150,660 690,1320 4620,5280
is say cat, {echo,to},|
|

1718
00:50:30,090 --> 00:50:32,010
0,750 750,1080 1080,1140 1140,1350 1350,1920
so instead of having to
因此，不必使用AWS定制库，

1719
00:50:32,040 --> 00:50:35,250
0,750 810,990 990,1650 1650,2370 2490,3210
use {} AWS custom library,|
|

1720
00:50:35,250 --> 00:50:37,170
0,90 90,270 270,660 900,1620 1650,1920
in order to {} so
为了如此写入S3，

1721
00:50:37,170 --> 00:50:37,860
0,210 210,330 330,510 510,600 600,690
write {S3 -},| I can
|我可以只编写一个文件系统模块，

1722
00:50:37,860 --> 00:50:38,540
0,360
just

1723
00:50:38,880 --> 00:50:40,620
0,870 870,960 960,1170 1170,1470 1470,1740
write a file system module,|
|

1724
00:50:40,620 --> 00:50:42,000
0,240 240,510 510,1020 1020,1140 1140,1380
file system operation to create
创建文件并向其写入的文件系统操作

1725
00:50:42,000 --> 00:50:42,750
0,60 60,300 300,420 420,630 630,750
a file and write to

1726
00:50:42,750 --> 00:50:44,370
0,300 600,780 780,960 960,1140 1140,1620
it| and then {S3 -},
|然后是S3，这实际上现在应该显示为一个新密钥，

1727
00:50:45,080 --> 00:50:47,030
0,210 210,840 1290,1620 1620,1830 1830,1950
this actually should show up

1728
00:50:47,030 --> 00:50:48,140
0,120 120,180 180,390 390,630 630,1110
as a new key now,|
|

1729
00:50:49,600 --> 00:50:50,410
0,180 180,270 270,360 360,630 630,810
so we have {test456 -
所以我们测试了456，这是我们刚刚写的。

1730
00:50:50,410 --> 00:50:51,580
0,210 210,660 660,870 870,960 960,1170
- -}, which we just

1731
00:50:51,580 --> 00:50:52,320
0,450
wrote.|
|

1732
00:50:54,260 --> 00:50:55,800
0,990

1733
00:50:56,630 --> 00:50:58,340
0,720 1020,1200 1200,1380 1380,1530 1530,1710
So, um, what does fault
那么，嗯，来这里容错是什么意思，

1734
00:50:58,340 --> 00:51:00,590
0,420 420,810 810,1050 1050,1470 1530,2250
tolerance part coming here,| well
|就像我之前提到的，

1735
00:51:00,590 --> 00:51:01,640
0,150 150,180 180,480 480,900 900,1050
as I mentioned before,| all
|所有这些9P服务都具有定义良好的统一接口，

1736
00:51:01,640 --> 00:51:03,290
0,450 480,900 900,1440 1440,1590 1590,1650
these 9P services have a

1737
00:51:03,290 --> 00:51:05,510
0,480 480,660 660,1050 1050,1500 1500,2220
very well defined uniform interface,|
|

1738
00:51:05,540 --> 00:51:06,920
0,450 630,780 780,810 810,960 960,1380
{} there are no customer
没有客户RPC，

1739
00:51:06,920 --> 00:51:09,050
0,450 450,1170 1200,1830 1830,2040 2040,2130
RPCs,| and this gives us
|这给了我们一个非常独特的机会，

1740
00:51:09,050 --> 00:51:10,610
0,30 30,270 270,690 720,1350 1350,1560
a very unique opportunity,| which
|即我们可以在这个9P接口上切片以复制未修改的服务，

1741
00:51:10,610 --> 00:51:12,170
0,390 420,690 690,1050 1080,1500 1500,1560
is we can slice at

1742
00:51:12,170 --> 00:51:14,120
0,180 180,420 420,510 510,1200 1410,1950
this {9P -} interface {}

1743
00:51:14,120 --> 00:51:16,970
0,480 480,1080 1110,1710 1710,2340 2370,2850
to replicate unmodified services,| so
|因此，如果我能够将所有这些操作复制到服务器的不同服务器实例，

1744
00:51:17,270 --> 00:51:19,070
0,690 720,900 900,1230 1230,1530 1560,1800
if if I am able

1745
00:51:19,070 --> 00:51:20,900
0,90 90,750 780,930 930,1110 1110,1830
to replicate all these operations

1746
00:51:21,230 --> 00:51:23,060
0,150 150,450 450,990 1020,1530 1530,1830
to different server instances of

1747
00:51:23,060 --> 00:51:25,790
0,480 480,900 1170,1830 1890,2520 2520,2730
servers,| then {} servers gets
|然后服务器可以自由复制，根本不需要修改它，

1748
00:51:25,790 --> 00:51:27,020
0,450 450,690 690,960 960,1140 1140,1230
replicated freely without having to

1749
00:51:27,020 --> 00:51:29,210
0,450 450,600 600,690 690,930 1530,2190
modify it at all, {}|
|

1750
00:51:29,270 --> 00:51:29,810
0,150 150,270 270,330 330,420 420,540
so this is what we
这就是我们所做的，

1751
00:51:29,810 --> 00:51:30,800
0,270 270,510 510,660 660,690 690,990
did,| {} when I worked
|当我工作的时候，

1752
00:51:30,800 --> 00:51:31,700
0,240 240,840
on,| I
|我实现了基于链复制的容错方案，

1753
00:51:31,970 --> 00:51:35,030
0,600 600,1500 1980,2250 2250,2670 2670,3060
{} implemented chain replication based

1754
00:51:35,030 --> 00:51:35,960
0,600
{}

1755
00:51:36,430 --> 00:51:39,460
0,420 420,600 600,1290 1290,1950 2280,3030
{} fault tolerance scheme, {}|
|

1756
00:51:39,880 --> 00:51:40,990
0,300 300,540 540,810 810,990 990,1110
I use {named -} is
我使用命名就像是一种配置，

1757
00:51:40,990 --> 00:51:44,110
0,120 120,570 660,1500 1530,1950 2190,3120
like a configuration,| {} configuration
|配置服务，您可以将其视为动物园管理员

1758
00:51:44,350 --> 00:51:45,280
0,570 570,630 630,720 720,870 870,930
service, you can think of

1759
00:51:45,280 --> 00:51:46,600
0,240 240,360 360,540 540,900 990,1320
this as like a {zookeeper

1760
00:51:46,600 --> 00:51:48,070
0,510 540,810 810,900 900,1350 1350,1470
-}| and I replicated 2
|我原封不动地复制了2个不同的服务

1761
00:51:48,070 --> 00:51:51,430
0,270 270,1020 1170,1770 1770,2280 2580,3360
different services without any modification|
|

1762
00:51:51,430 --> 00:51:53,020
0,270 270,630 630,810 810,1260 1260,1590
and in-memory file system and
以及存储器中的文件系统和从本地机器暴露持久存储的服务

1763
00:51:53,350 --> 00:51:55,660
0,690 720,1140 1140,1260 1260,1920 1920,2310
a service which exposes {}

1764
00:51:56,110 --> 00:51:58,780
0,390 390,1050 1470,1800 1800,2280 2310,2670
durable storage from a local

1765
00:51:58,780 --> 00:52:01,420
0,630 750,900 900,1320 1380,2100 2100,2640
machines| and so I'll quickly
|所以我会很快地向他们展示这一点。

1766
00:52:01,420 --> 00:52:02,860
0,330 330,540 660,1140
show them that.|
|

1767
00:52:03,460 --> 00:52:05,680
0,690 720,990 1020,1350 1350,1890 1920,2220
So let's stop this,| let's
所以让我们停止这一切，|让我们看看。

1768
00:52:05,680 --> 00:52:07,520
0,210
see.|
|

1769
00:52:08,180 --> 00:52:09,180
0,720
So,
举个例子，我可以，

1770
00:52:11,390 --> 00:52:14,320
0,630 660,840 840,1590
{for,example} I can,|
|

1771
00:52:20,000 --> 00:52:20,660
0,180 180,210 210,330 330,570 570,660
so I can start up
这样我就可以开始一系列的复制，

1772
00:52:20,660 --> 00:52:22,080
0,60 60,270 270,360 360,1110
a bunch of replicates,|
|

1773
00:52:32,840 --> 00:52:34,040
0,210 210,360 360,450 450,690 690,1200
so if I look into
因此，如果我研究一下Linux中的9P名称空间模块，

1774
00:52:34,040 --> 00:52:35,720
0,240 240,540 540,720 720,1020 1020,1680
the {9P -} name space

1775
00:52:35,750 --> 00:52:37,460
0,330 330,390 390,960 1230,1560 1560,1710
module in Linux,| you see
|您可以看到这个Memf-Replica

1776
00:52:37,460 --> 00:52:39,620
0,150 150,630 630,1320 1740,2010 2010,2160
this {memfs-replica -},| here's where
|这是这些复制品自我注册的地方，

1777
00:52:39,620 --> 00:52:42,840
0,450 450,810 810,1200 1200,1980
these replicas register themselves,|
|

1778
00:52:44,590 --> 00:52:45,520
0,210 210,300 300,390 390,780 780,930
so we can see that,
所以我们可以看到，我们有五个这样的复制品，

1779
00:52:45,520 --> 00:52:46,840
0,90 90,240 240,780 780,1170 1170,1320
we have five of these

1780
00:52:46,840 --> 00:52:48,160
0,360 360,750 780,900 900,1080 1080,1320
replicas up,| I can write
|我可以给他们中的一个写信。

1781
00:52:48,160 --> 00:52:50,820
0,60 60,210 210,300 300,1440
to one of them.|
|

1782
00:52:51,690 --> 00:52:53,020
0,840

1783
00:52:53,640 --> 00:52:55,040
0,570
Oops.|
哎呀。|

1784
00:52:58,110 --> 00:52:59,250
0,240 240,420 420,690 690,930 930,1140
Okay, so can I write
好的，我能给其中一个复制品写信吗

1785
00:52:59,250 --> 00:53:00,240
0,60 60,180 180,240 240,300 300,990
to one of the replicas|
|

1786
00:53:00,450 --> 00:53:01,290
0,360 360,510 510,600 600,660 660,840
{} and then I can
然后我可以从另一组人中阅读，

1787
00:53:01,290 --> 00:53:02,190
0,180 180,330 330,540 540,690 690,900
read from another one group,|
|

1788
00:53:02,190 --> 00:53:05,080
0,360 360,510 510,840 1440,2670
because we should get
因为我们应该在书外得到相同的结果，

1789
00:53:05,590 --> 00:53:07,480
0,300 300,630 630,960 960,1290 1290,1890
the same result outside wrote,|
|

1790
00:53:07,920 --> 00:53:10,050
0,900 990,1320 1320,1620 1620,1920 1920,2130
a small string to a
第一复制品中的文件的小字符串，

1791
00:53:10,050 --> 00:53:11,520
0,480 480,570 570,660 660,900 900,1470
file in the first replica,|
|

1792
00:53:11,550 --> 00:53:12,270
0,150 150,300 300,510 510,660 660,720
you can read from the
你可以从最后一个复制品中读取，

1793
00:53:12,270 --> 00:53:13,410
0,240 240,720 750,960 960,1080 1080,1140
last replica,| should get the
|应该拿回同样的东西，

1794
00:53:13,410 --> 00:53:15,600
0,210 210,330 330,810 1200,1560 1560,2190
same thing back,| can even
|甚至可以使复制品崩溃，因为，

1795
00:53:17,340 --> 00:53:20,120
0,660 660,1140 1140,1830
{crash,replica -}, because,|
|

1796
00:53:22,590 --> 00:53:24,400
0,210 210,360 360,1530
so {let's,kill -}
所以让我们杀了其中一个人，

1797
00:53:24,900 --> 00:53:26,380
0,210 210,330 330,540 540,1170
one of these guys,|
|

1798
00:53:28,610 --> 00:53:29,320
0,510

1799
00:53:32,960 --> 00:53:34,250
0,420 420,540 540,660 660,840 840,1290
{} we can see this,|
我们可以看到，|

1800
00:53:37,650 --> 00:53:38,610
0,330 330,480 480,540 540,720 720,960
see there are only four
你看，现在名字空间里只剩下四个副本了，

1801
00:53:38,610 --> 00:53:39,600
0,330 330,600 600,780 780,930 930,990
replicas left now in the

1802
00:53:39,600 --> 00:53:43,980
0,210 210,840 1170,1860 2160,3090 3720,4380
name space,| {} then {}
|然后向该文件写入不同的字符串，

1803
00:53:43,980 --> 00:53:44,850
0,210 210,240 240,570 570,810 810,870
write a different string to

1804
00:53:44,850 --> 00:53:46,140
0,180 180,720
this file,|
|

1805
00:53:48,910 --> 00:53:51,800
0,630 1410,1680 1680,1950 1950,2550
and, {} I should,|
而且，我应该，|

1806
00:53:52,300 --> 00:53:54,220
0,330 330,780 780,1200 1200,1380 1380,1920
yeah, so, {} so now,
是的，所以，所以现在，尽管失败了，

1807
00:53:54,640 --> 00:53:57,730
0,360 360,1140 1560,1830 1830,2850 2880,3090
{} despite a failure,| the
|该服务自动重新配置，

1808
00:53:57,730 --> 00:53:59,520
0,300 300,720 720,1590
service automatically reconfigured,|
|

1809
00:53:59,800 --> 00:54:02,140
0,480 480,1140 1170,1590 1590,1770 1770,2340
and the in-memory file systems
以及基于的内存中文件系统服务，

1810
00:54:02,140 --> 00:54:05,620
0,420 450,1410 1680,2310 2730,3120 3120,3480
{} services {} based off,|
|

1811
00:54:05,620 --> 00:54:06,160
0,180 180,300 300,420 420,480 480,540
did not have to be
根本不需要修改，

1812
00:54:06,160 --> 00:54:07,060
0,360 360,480 480,720 720,810 810,900
modified at all,| you can
|您只需插入任何您想要的新服务，

1813
00:54:07,060 --> 00:54:07,930
0,150 150,330 330,420 420,630 630,870
just plug in any new

1814
00:54:07,930 --> 00:54:09,430
0,420 420,510 510,720 720,1020 1290,1500
service you want to {},|
|

1815
00:54:09,430 --> 00:54:10,960
0,600 630,1020 1020,1140 1140,1380 1380,1530
that implements this {9P -}
实现此9P接口的

1816
00:54:10,960 --> 00:54:12,160
0,330 330,420 420,510 510,810 810,1200
interface| and it should work
|而且它应该开箱即用。

1817
00:54:12,190 --> 00:54:13,280
0,300 300,360 360,420 420,930
out of the box.|
|

1818
00:54:15,100 --> 00:54:17,890
0,720 720,1290 1320,1350 1740,2340 2340,2790
So, {} I think that's,|
所以，我认为这是，|

1819
00:54:18,460 --> 00:54:19,120
0,210 210,360 360,480 480,600 600,660
I think that sort of
我想我的演讲到此结束了

1820
00:54:19,120 --> 00:54:22,330
0,750 990,1560 1710,2250 2250,3030 3030,3210
concludes {} my presentation| and
|我很乐意回答更多的问题，

1821
00:54:22,420 --> 00:54:23,140
0,60 60,150 150,300 300,360 360,720
I'd be happy to take

1822
00:54:23,140 --> 00:54:24,760
0,120 120,270 270,810 1290,1380 1380,1620
any more questions,| you guys
|你们可能有过。

1823
00:54:24,760 --> 00:54:25,400
0,120 120,450
might have.|
|

1824
00:54:33,330 --> 00:54:34,500
0,180 180,600 600,840 840,1050 1050,1170
I regret not wearing my
我后悔这次没有穿我的Plan9球衣，

1825
00:54:34,500 --> 00:54:35,730
0,270 270,480 480,780 780,960 960,1230
{Plan9 -} shirt this time,|
|

1826
00:54:37,530 --> 00:54:39,270
0,270 270,660 720,960 960,1320 1320,1740
I {should,have},| I'm curious though,
我应该这么做的，|不过我很好奇，这学期早些时候我正在做一些类似的东西，

1827
00:54:39,450 --> 00:54:41,250
0,720 1050,1410 1410,1500 1500,1710 1710,1800
I'm working on something that

1828
00:54:41,250 --> 00:54:42,450
0,120 120,330 330,390 390,870 870,1200
was sort of similar earlier

1829
00:54:42,450 --> 00:54:43,680
0,150 150,600 600,960 960,1080 1080,1230
this semester,| except there was
|只是没有复制，

1830
00:54:43,680 --> 00:54:45,630
0,480 810,1500 1500,1560 1560,1710 1710,1950
no replication,| it was just
|它只是Linux机器下的9P服务，

1831
00:54:45,630 --> 00:54:47,910
0,270 270,1230 1470,1770 1770,1860 1860,2280
9P services under {} Linux

1832
00:54:47,910 --> 00:54:50,010
0,450 510,1620 1650,1890 1890,1980 1980,2100
box,| why this is sort
|为什么这是一个即兴的问题，为什么要改变复制，

1833
00:54:50,010 --> 00:54:51,090
0,60 60,150 150,540 540,810 810,1080
of an offhand question, why

1834
00:54:51,090 --> 00:54:52,120
0,270 270,810
change replication,|
|

1835
00:54:52,580 --> 00:54:53,780
0,60 60,570 600,990 990,1110 1110,1200
{} I imagine there are
我想还有其他的复制方案，

1836
00:54:53,780 --> 00:54:55,820
0,210 210,630 630,1290 1710,1860 1860,2040
other replication schemes,| that are
|在这类事情上是可用的，

1837
00:54:55,820 --> 00:54:57,770
0,600 720,1440 1470,1650 1650,1800 1800,1950
available for this sort of

1838
00:54:57,770 --> 00:54:58,940
0,330 330,480 480,690 690,960 960,1170
thing,| and in theory because
|从理论上讲，因为这是9便士，

1839
00:54:58,940 --> 00:54:59,750
0,150 150,240 240,480 480,690 690,810
this is {9P -},| you
|你可能会把所有这些复制品都绑在同一个空间里，

1840
00:54:59,750 --> 00:55:01,010
0,90 90,360 360,870 870,1080 1080,1260
could probably bind all these

1841
00:55:01,010 --> 00:55:02,330
0,390 390,570 570,630 630,1020 1020,1320
replicas over the same space,|
|

1842
00:55:02,330 --> 00:55:03,050
0,150 150,360 360,480 480,630 630,720
they look like, it's a
它们看起来像是一台机器，

1843
00:55:03,050 --> 00:55:05,120
0,390 390,660 960,1200 1200,1440 1440,2070
machine,| but why chain replication.|
|但为什么是链式复制呢。|

1844
00:55:06,480 --> 00:55:08,040
0,300 300,750 780,990 990,1410 1440,1560
Yeah, yeah, good question, {}|
是的，是的，问得好，|

1845
00:55:08,040 --> 00:55:09,090
0,120 120,420 420,600 600,870 870,1050
you could in theory do
理论上，你可以做任何你想做的复制方案，在引擎盖下，

1846
00:55:09,090 --> 00:55:10,530
0,480 480,630 630,1080 1080,1350 1350,1440
any any replication scheme you'd

1847
00:55:10,530 --> 00:55:12,120
0,420 450,900 930,1110 1110,1200 1200,1590
like, {} under the hood,|
|

1848
00:55:12,210 --> 00:55:14,310
0,360 360,360 360,930 930,1140 1140,2100
{} I did chain application,
我做了连锁应用，因为它看起来像一个简单的起点，我想，

1849
00:55:14,820 --> 00:55:16,650
0,750 750,900 930,1200 1200,1350 1350,1830
because it seemed like a

1850
00:55:17,270 --> 00:55:18,560
0,390 390,720 720,930 930,990 990,1290
simple starting point, I guess,|
|

1851
00:55:18,560 --> 00:55:19,520
0,270 300,450 450,660 660,810 810,960
I could also throw this
我也可以把这个放在木筏上解读，

1852
00:55:19,520 --> 00:55:20,930
0,60 60,240 240,330 330,810 1110,1410
on top of a raft

1853
00:55:20,930 --> 00:55:22,190
0,450 450,600 600,660 660,900 900,1260
interpretation,| like the entry class
|比如入门类或类似的东西，

1854
00:55:22,190 --> 00:55:24,180
0,210 210,450 450,570 570,930
or anything like that,|
|

1855
00:55:24,530 --> 00:55:25,670
0,210 210,420 420,930 930,1080 1080,1140
it's something fundamental about the
这是关于选择的一些基本问题。

1856
00:55:25,670 --> 00:55:26,520
0,450
choice.|
|

1857
00:55:31,840 --> 00:55:34,180
0,870 870,1080 1080,1410 1410,1800 1800,2340
Does your system support adding
您的系统是否支持在启动后添加其他复制副本。

1858
00:55:34,210 --> 00:55:36,550
0,930 930,1470 1470,1770 1770,1860 1860,2340
additional replicas after it started.|
|

1859
00:55:36,880 --> 00:55:39,070
0,600 600,810 810,1260 1290,1560 1560,2190
Yeah, great question,| {} so
是啊，问得好，|所以你已经知道这是一项正在进行的工作，

1860
00:55:39,100 --> 00:55:40,930
0,90 90,330 330,810 840,1410 1440,1830
you already know {} that's

1861
00:55:40,930 --> 00:55:43,300
0,270 270,480 480,540 540,1200 1560,2370
a work in progress, {}|
|

1862
00:55:44,060 --> 00:55:46,190
0,600 630,750 750,1110 1440,1890 1890,2130
{} but yeah currently we
但是，是的，目前我们不支持添加额外的副本。

1863
00:55:46,190 --> 00:55:49,310
0,870 900,1470 1500,2010 2280,2730 2730,3120
don't support adding additional replicas

1864
00:55:49,310 --> 00:55:50,240
0,120 120,210 210,720
out of box.|
|

1865
00:55:56,500 --> 00:55:57,640
0,180 180,300 300,420 420,690 690,1140
This is an open question,|
这是一个悬而未决的问题，|

1866
00:55:57,640 --> 00:55:58,630
0,180 180,330 330,420 420,750 780,990
it's sort of like {}
就像你可能不知道这一点，

1867
00:55:58,630 --> 00:55:59,530
0,180 180,270 270,450 450,570 570,900
you may not know this,|
|

1868
00:55:59,530 --> 00:56:00,610
0,150 150,390 390,480 480,840 840,1080
this wasn't the express intent
这不是目的的明确意图，

1869
00:56:00,610 --> 00:56:01,420
0,60 60,150 150,480 480,630 630,810
of the purpose,| but one
|但Plan9和9P真正酷的一点是，

1870
00:56:01,420 --> 00:56:02,200
0,60 60,180 180,390 390,600 600,780
of the things that's really

1871
00:56:02,200 --> 00:56:03,280
0,240 240,540 540,750 750,990 990,1080
cool about {Plan9 -} and

1872
00:56:03,280 --> 00:56:04,570
0,210 210,420 420,510 510,780 990,1290
{9P -} is that,| you
|您也将网络连接视为它们的文件，

1873
00:56:04,570 --> 00:56:05,800
0,330 330,600 600,960 960,1080 1080,1230
treat network connections like their

1874
00:56:05,800 --> 00:56:07,900
0,360 360,450 450,840 1050,1800 1830,2100
files as well,| so you're
|所以你就像你有Memf一样，从我看到的情况来看，你已经实现了一个调度程序队列，

1875
00:56:07,900 --> 00:56:08,980
0,180 180,300 300,420 420,600 600,1080
like you have like memfs,

1876
00:56:08,980 --> 00:56:10,120
0,120 120,630 810,960 960,1050 1050,1140
you have from what I

1877
00:56:10,120 --> 00:56:11,260
0,150 150,240 240,750 750,930 930,1140
saw a scheduler queue was

1878
00:56:11,260 --> 00:56:12,550
0,420 420,570 570,720 720,780 780,1290
implemented,| just set of files,|
|只有一组文件，|

1879
00:56:14,330 --> 00:56:15,590
0,330 330,840 840,990 990,1140 1140,1260
do you and this is
你和这是一个悬而未决的问题，

1880
00:56:15,590 --> 00:56:17,060
0,210 210,420 420,690 690,1110 1110,1470
an open question,| because the
|因为文件接口上的网络内容是否存在问题，

1881
00:56:17,060 --> 00:56:18,620
0,300 300,360 360,540 540,1170 1200,1560
question of whether network stuff

1882
00:56:18,620 --> 00:56:20,780
0,240 240,510 510,1020 1020,1590 1590,2160
over file interfaces,| scalable is
|可伸缩性很难回答，

1883
00:56:21,020 --> 00:56:22,730
0,420 420,510 510,870 900,1230 1350,1710
difficult to answer,| but do
|但您是否也以这种方式实现这一点呢

1884
00:56:22,730 --> 00:56:24,470
0,390 390,870 870,1350 1350,1680 1680,1740
you also implement this in

1885
00:56:24,470 --> 00:56:25,220
0,180 180,240 240,450 450,660 660,750
sort of that way| or
|或者您是否使用更传统的策略界面，

1886
00:56:25,220 --> 00:56:26,300
0,60 60,210 210,390 390,510 510,1080
do you use more traditional

1887
00:56:26,300 --> 00:56:28,220
0,330 330,480 480,1020 1020,1470 1620,1920
{policy -} interfaces to,| when
|当客户使用这个东西时，他们认为他们使用传统的套接字和东西进行通信。

1888
00:56:28,220 --> 00:56:29,450
0,60 60,450 450,660 660,930 930,1230
the clients use this thing

1889
00:56:29,450 --> 00:56:30,950
0,210 210,780 780,870 870,990 990,1500
they presume they use traditional

1890
00:56:30,980 --> 00:56:32,300
0,420 420,510 510,720 720,840 840,1320
sockets and things to communicate.|
|

1891
00:56:33,400 --> 00:56:35,650
0,750 750,1140 1140,1320 1320,1710 1710,2250
Yeah, yeah, good question,| so
是的，是的，问得好，|所以，是的，所有的东西，所以目前所有的客户端和服务都是通过TCP通信的，

1892
00:56:35,920 --> 00:56:37,600
0,240 240,870 900,1140 1140,1350 1350,1680
yeah, everything, so all the

1893
00:56:37,600 --> 00:56:40,870
0,390 390,480 480,1320 1890,2670 2700,3270
clients and services communicate over

1894
00:56:40,870 --> 00:56:42,910
0,660 720,1290 1320,1500 1500,1560 1560,2040
TCP {} at the moment,|
|

1895
00:56:42,940 --> 00:56:43,840
0,660

1896
00:56:44,250 --> 00:56:46,020
0,300 300,1260 1260,1590 1590,1710 1710,1770
and yeah it is a
是的，这是一个很好的问题

1897
00:56:46,020 --> 00:56:46,890
0,90 90,420 420,540 540,600 600,870
good question| as to whether
|至于9P空间是否真的表现得足够好

1898
00:56:46,890 --> 00:56:48,630
0,120 120,570 570,960 960,1350 1350,1740
the 9P spaces actually performed

1899
00:56:48,630 --> 00:56:49,590
0,300 300,420 420,720 720,810 810,960
enough| for what we're gonna
|我们要用它来做什么，

1900
00:56:49,590 --> 00:56:51,030
0,150 150,300 300,510 600,1320 1320,1440
do with it,| {} as
|就我们现在所能看到的，

1901
00:56:51,030 --> 00:56:51,600
0,150 150,240 240,300 300,390 390,570
far as we can see

1902
00:56:51,600 --> 00:56:54,200
0,600 630,1110 1320,1770 1770,2370
now,| {} there's not,|
|没有，|

1903
00:56:55,050 --> 00:56:56,850
0,540 570,810 810,1350 1410,1650 1650,1800
{} so we've done some
所以我们做了一些性能基准测试

1904
00:56:56,850 --> 00:56:58,500
0,360 360,810 810,870 870,1080 1080,1650
performance benchmarking| to see how
|要了解我们在9p以上编写的调度器有多好，

1905
00:56:58,890 --> 00:57:01,230
0,840 1140,1710 1710,2070 2070,2250 2250,2340
well like we've written a

1906
00:57:01,230 --> 00:57:04,020
0,1530 1530,1680 1680,1920 1920,2310 2340,2790
scheduler over {9P -}, {}|
|

1907
00:57:04,640 --> 00:57:06,200
0,480 480,1020 1020,1290 1290,1470 1470,1560
{} and we've done some
我们已经做了一些性能基准测试，看看它的表现如何

1908
00:57:06,200 --> 00:57:07,490
0,360 360,780 780,840 840,1020 1020,1290
performance benchmarking to see how

1909
00:57:07,490 --> 00:57:08,720
0,150 150,660 660,840 840,960 960,1230
it performs| and it seems
|而且目前它似乎并没有增加太多的开销，

1910
00:57:08,720 --> 00:57:09,410
0,120 120,330 330,450 450,510 510,690
to not add a ton

1911
00:57:09,410 --> 00:57:10,280
0,60 60,390 390,480 480,540 540,870
of overhead at the moment,|
|

1912
00:57:10,280 --> 00:57:11,120
0,510
but,
但是，好吧，我们可以想象不同类型的服务的权衡会发生变化

1913
00:57:11,380 --> 00:57:13,090
0,450 570,780 780,870 870,1170 1170,1710
alright, we can imagine those

1914
00:57:13,120 --> 00:57:14,440
0,390 390,780 780,870 870,1110 1110,1320
trade-offs changing for different types

1915
00:57:14,440 --> 00:57:16,690
0,60 60,810 990,1380 1380,2190 2190,2250
of services| and as the
|并且随着调度器或多或少变得超额订阅。

1916
00:57:16,690 --> 00:57:17,980
0,480 480,840 840,1080 1080,1110 1110,1290
scheduler becomes more or less

1917
00:57:17,980 --> 00:57:19,060
0,870
oversubscribed.|
|

1918
00:57:20,750 --> 00:57:21,410
0,120 120,390 390,450 450,570 570,660
I guess, I guess to
我想，我想澄清一下，

1919
00:57:21,410 --> 00:57:23,240
0,540 540,1110 1140,1470 1470,1590 1590,1830
clarify,| so sorry I'm taking
|很抱歉我占用了你很多时间，

1920
00:57:23,240 --> 00:57:24,080
0,150 150,540 540,660 660,690 690,840
up taking up a lot

1921
00:57:24,080 --> 00:57:25,700
0,90 90,330 330,720 720,1110 1110,1620
of time,| but just briefly
|但只是简单地说整个9便士，

1922
00:57:25,760 --> 00:57:27,680
0,150 150,630 660,1350 1350,1590 1590,1920
the whole 9P,| if you
|如果你如果你能够

1923
00:57:27,680 --> 00:57:29,120
0,300 300,510 510,690 690,1020 1020,1440
if you were able to|
|

1924
00:57:29,120 --> 00:57:30,080
0,150 150,300 300,420 420,750 750,960
and this is again very
这也是非常开放的，

1925
00:57:30,080 --> 00:57:30,860
0,270 270,420 420,540 540,630 630,780
open,| but if you were
|但如果你能够处理网络连接文件，你就有了副本，对吧，

1926
00:57:30,860 --> 00:57:32,120
0,180 180,270 270,540 540,810 810,1260
able to treat network connections

1927
00:57:32,120 --> 00:57:34,220
0,390 390,480 480,630 630,1350 1530,2100
files, you have replicas, right,|
|

1928
00:57:34,250 --> 00:57:35,200
0,210 210,330 330,750
you could have
你可以为每一张卡准备一些东西，

1929
00:57:35,580 --> 00:57:36,840
0,390 390,480 480,720 720,1110 1110,1260
something for each card,| then
|然后在这些网卡上共享网络流量，

1930
00:57:36,840 --> 00:57:38,250
0,420 420,720 720,1080 1080,1230 1230,1410
shared network traffic over those

1931
00:57:38,250 --> 00:57:39,570
0,300 300,600 600,870 870,1110 1110,1320
network cards,| which I guess
|我想这无论如何都是无服务器的，

1932
00:57:39,570 --> 00:57:41,070
0,210 210,300 300,750 750,1140 1140,1500
this is serverless anyway,| so
|所以这可能不会有太大不同，

1933
00:57:41,070 --> 00:57:41,820
0,90 90,330 330,510 510,630 630,750
it probably doesn't make that

1934
00:57:41,820 --> 00:57:43,170
0,150 150,210 210,240 240,900 1020,1350
much of a difference,| yeah,
|是啊，算了吧，

1935
00:57:43,170 --> 00:57:44,020
0,120 120,330
forget it,|
|

1936
00:57:45,900 --> 00:57:46,590
0,180 180,270 270,450 450,600 600,690
because you already have the
因为你已经有自己的把手了。

1937
00:57:46,590 --> 00:57:49,020
0,300 300,690 1230,1890
handles for you.|
|

1938
00:57:50,440 --> 00:57:52,100
0,600 600,900
Thank you.|
谢谢。|

1939
00:57:52,150 --> 00:57:55,570
0,420 420,720 1980,2580 2580,3180 3210,3420
Thank you.| Alright, so let's
谢谢。|好的，如果你准备好了，让我们来听一些关于验证的东西。

1940
00:57:55,570 --> 00:57:57,310
0,120 120,570 570,720 720,1290 1290,1740
hear about some verification stuff,

1941
00:57:57,310 --> 00:57:58,260
0,90 90,240 240,630
if you're ready.|
|

1942
00:58:02,730 --> 00:58:03,570
0,390 390,450 450,630 630,750 750,840
Can you guys hear me,
你们能听到我说话吗，好的。

1943
00:58:03,570 --> 00:58:04,220
0,300
okay.|
|

1944
00:58:04,490 --> 00:58:05,480
0,450
Yes.|
是。|

1945
00:58:05,590 --> 00:58:08,440
0,750 780,1230 1500,2070 2070,2460 2460,2850
Alright, excellent,| so indeed, {}
好的，太好了，|所以，我确实要和你们谈谈我的项目，

1946
00:58:08,440 --> 00:58:09,250
0,330 330,480 480,690 690,750 750,810
I'm gonna talk to you

1947
00:58:09,250 --> 00:58:10,300
0,270 270,450 450,840 840,930 930,1050
about my project,| which is
|它专注于分布式系统的模块化验证，

1948
00:58:10,300 --> 00:58:12,520
0,420 420,900 900,1350 1350,1980 1980,2220
focused on modular verification for

1949
00:58:12,520 --> 00:58:15,220
0,390 390,1020 1350,2010 2220,2430 2430,2700
distributed systems,| so let's start
|所以让我们从回答这个显而易见的问题开始，

1950
00:58:15,220 --> 00:58:17,650
0,1020 1320,1770 1770,1950 1950,2190 2190,2430
by answering the obvious question,|
|

1951
00:58:17,650 --> 00:58:18,640
0,90 90,180 180,420 420,750 750,990
which is why bother with
这就是为什么要费心做这些事，

1952
00:58:18,640 --> 00:58:20,440
0,150 150,210 210,300 300,750 1170,1800
any of this stuff, {}|
|

1953
00:58:20,560 --> 00:58:22,510
0,450 450,630 630,1050 1320,1740 1740,1950
and I think anyone that's
我认为任何在实验室工作了6.824年的人

1954
00:58:22,510 --> 00:58:23,530
0,270 270,330 330,420 420,720 720,1020
worked in the lab for

1955
00:58:23,530 --> 00:58:24,910
0,540 540,840 840,960 960,1320 1320,1380
6.824| must have discovered at
|一定是在某个时候发现的，

1956
00:58:24,910 --> 00:58:26,650
0,180 180,510 510,1230 1260,1620 1620,1740
some point,| that getting this
|让这种抵抗变得正确是困难的，

1957
00:58:26,650 --> 00:58:28,660
0,420 420,720 720,900 900,1410 1800,2010
resistance right is hard, {}|
|

1958
00:58:28,660 --> 00:58:29,230
0,150 150,180 180,330 330,390 390,570
there's a lot of non
并发和网络故障导致了大量的不确定性，

1959
00:58:29,230 --> 00:58:30,940
0,510 510,840 840,930 930,1470 1470,1710
determinism caused by concurrency {}

1960
00:58:31,000 --> 00:58:33,100
0,300 300,630 630,1380 1470,1920 1920,2100
and network failure,| {} and
|这使得测试变得非常困难

1961
00:58:33,100 --> 00:58:34,420
0,150 150,360 360,630 630,930 930,1320
that makes it very difficult

1962
00:58:34,420 --> 00:58:35,890
0,120 120,690 690,780 780,1350 1350,1470
to exhaust the test| to
|为了确保没有角落里的窃听器，

1963
00:58:35,890 --> 00:58:36,820
0,180 180,330 330,510 510,660 660,930
make sure there's no corner

1964
00:58:36,820 --> 00:58:40,180
0,240 240,810 1860,3060 3060,3300 3300,3360
case bugs,| verification is an
|验证是尝试获得正确性的另一种方法测试

1965
00:58:40,180 --> 00:58:42,520
0,570 570,1260 1260,1650 1650,1920 1920,2340
alternative to, alternative approach testing

1966
00:58:42,520 --> 00:58:44,140
0,150 150,330 330,420 420,750 870,1620
to try and get correctness|
|

1967
00:58:44,230 --> 00:58:45,430
0,360 360,480 480,900 900,990 990,1200
and in principle, it can
原则上，它可以完全排除细菌，

1968
00:58:45,430 --> 00:58:47,830
0,510 510,900 900,1140 1140,1770 2010,2400
entirely rule out bugs,| with
|通过验证，您基本上已经对系统进行了数学建模

1969
00:58:47,830 --> 00:58:50,080
0,540 540,780 780,1110 1110,1740 1740,2250
verification you've basically mathematically modeled

1970
00:58:50,080 --> 00:58:51,700
0,120 120,630 810,990 990,1380 1380,1620
your system| and improve some
|并改进了关于该模型的一些定理，

1971
00:58:51,700 --> 00:58:53,580
0,510 510,930 930,1170 1170,1590
theorem about that model,|
|

1972
00:58:53,910 --> 00:58:56,040
0,630 720,1380 1500,1620 1620,1710 1710,2130
{} and you know one
你知道，核实的一个缺点是，

1973
00:58:56,040 --> 00:58:57,420
0,60 60,360 360,840 840,900 900,1380
of the downsides of verification

1974
00:58:57,420 --> 00:58:58,350
0,60 60,180 180,360 360,870 870,930
is that,| it's quite a
|在这些正式证明过程中，需要做相当多的工作

1975
00:58:58,350 --> 00:58:59,820
0,150 150,270 270,750 930,1260 1260,1470
lot of work {} during

1976
00:58:59,820 --> 00:59:01,320
0,270 390,780 780,1170 1170,1350 1350,1500
these formal proofs is| by
|绝非易事

1977
00:59:01,320 --> 00:59:03,330
0,150 150,450 450,990 1290,1710 1740,2010
no means easy| and even
|即使这很容易，核实仍然不是完美的灵丹妙药，

1978
00:59:03,330 --> 00:59:04,860
0,90 90,180 180,600 600,1110 1170,1530
if it was easy, {}

1979
00:59:04,860 --> 00:59:06,270
0,480 480,750 750,990 990,1140 1140,1410
verification still wouldn't be a

1980
00:59:06,270 --> 00:59:08,310
0,330 330,570 570,1050 1320,1590 1590,2040
perfect silver bullet,| for one
|对于一个验证，你必须确保你的规格是正确的，

1981
00:59:08,340 --> 00:59:09,660
0,870 870,960 960,1050 1050,1140 1140,1320
verification, you have to make

1982
00:59:09,660 --> 00:59:10,260
0,180 180,300 300,390 390,510 510,600
sure that you get your

1983
00:59:10,260 --> 00:59:12,570
0,750 750,1140 1380,1590 1590,1770 1770,2310
specification right,| {} if the
|如果你用你的系统证明的数学定理

1984
00:59:12,600 --> 00:59:14,070
0,630 630,930 930,1050 1050,1320 1320,1470
mathematical theorem you're proving by

1985
00:59:14,070 --> 00:59:15,960
0,120 120,630 690,1260 1260,1650 1650,1890
your system| doesn't actually say
|实际上并没有说出你真正想说的话，

1986
00:59:15,960 --> 00:59:17,190
0,300 300,510 510,810 810,1170 1170,1230
what you really wanted to

1987
00:59:17,190 --> 00:59:18,570
0,420 450,810 810,990 990,1110 1110,1380
say,| then what you've proved
|那么你所证明的一切都是无用的

1988
00:59:18,570 --> 00:59:21,030
0,90 90,720 810,1530 1530,1890 1890,2460
is useless| {} and relatedly,
|与之相关的是，你必须确保你必须抵制它们的模型也是完整的，

1989
00:59:21,030 --> 00:59:21,660
0,120 120,240 240,330 330,510 510,630
you have to make sure

1990
00:59:21,660 --> 00:59:22,590
0,210 210,300 300,690 690,810 810,930
that the model that you

1991
00:59:22,590 --> 00:59:23,700
0,120 120,210 210,480 480,720 960,1110
have to resist them is

1992
00:59:23,700 --> 00:59:26,010
0,300 300,900 1230,1530 1530,2070 2070,2310
also complete,| {} if you
|如果你不能对现实中可能发生的一些执行进行建模，

1993
00:59:26,010 --> 00:59:28,350
0,390 390,480 480,990 990,1500 1500,2340
fail to model some execution

1994
00:59:28,350 --> 00:59:29,460
0,180 180,270 270,600 600,690 690,1110
that can happen in reality,|
|

1995
00:59:29,460 --> 00:59:30,990
0,540 540,660 660,810 810,1230 1230,1530
but you don't consider, then
但你不考虑，那么你的定理就会适用于现实世界。

1996
00:59:31,050 --> 00:59:32,610
0,330 330,630 630,870 870,1230 1230,1560
your theorem would apply to

1997
00:59:33,120 --> 00:59:33,940
0,180 180,390 390,750
the real world.|
|

1998
00:59:35,190 --> 00:59:36,480
0,360 360,810 840,1020 1020,1110 1110,1290
{} And some of you
你们中的一些人熟悉一些分布式验证工作，

1999
00:59:36,480 --> 00:59:37,650
0,210 210,420 420,690 690,840 840,1170
that are familiar with some

2000
00:59:37,680 --> 00:59:39,840
0,450 750,1260 1260,1530 1530,1740 1740,2160
distributed verification work,| might say
|可能会说，我们不是已经知道怎么做了吗，

2001
00:59:39,900 --> 00:59:40,920
0,360 390,660 660,750 750,930 930,1020
well don't we already know

2002
00:59:40,920 --> 00:59:42,150
0,120 120,210 210,360 360,810 960,1230
how to do this, {}|
|

2003
00:59:42,150 --> 00:59:43,650
0,450 450,840 840,1110 1110,1200 1200,1500
indeed distributed systems have always
事实上，分布式系统一直很难实现

2004
00:59:43,650 --> 00:59:45,540
0,120 120,450 450,660 720,1170 1170,1890
been hard| and people have
|人们最近致力于一个项目，试图验证分布式系统的实际实现，

2005
00:59:45,570 --> 00:59:47,430
0,450 450,780 780,1140 1140,1380 1380,1860
recently worked on a project

2006
00:59:47,430 --> 00:59:49,140
0,180 180,360 360,480 480,1290 1380,1710
to try to verify actual

2007
00:59:49,140 --> 00:59:51,300
0,480 480,540 540,960 960,1530 1860,2160
implementations of distributed systems,| so
|因此，其中一些项目包括铁道舰队和威尔第，

2008
00:59:51,300 --> 00:59:52,350
0,120 120,180 180,300 300,720 720,1050
some of these projects include

2009
00:59:52,350 --> 00:59:53,880
0,300 300,690 690,840 840,1320
{IronFleet -} and Verdi,|
|

2010
00:59:54,210 --> 00:59:56,520
0,510 540,1230 1230,1500 1500,2040 2040,2310
{} however, these projects didn't
然而，这些项目并没有太多地关注模块化

2011
00:59:56,520 --> 00:59:58,080
0,420 420,720 720,870 870,1290 1290,1560
focus much on {modularity -

2012
00:59:58,080 --> 00:59:59,640
0,300 630,960 960,1140 1140,1470 1470,1560
-}| {} or trying to
|或者试图证明系统组件的可重用规范，

2013
00:59:59,640 --> 01:00:01,890
0,300 300,720 720,1440 1440,1560 1560,2250
prove reusable specifications for components

2014
01:00:01,890 --> 01:00:03,240
0,90 90,630 690,1020 1020,1080 1080,1350
of systems,| trying to build
|试图用它们来建造更复杂的系统，

2015
01:00:03,240 --> 01:00:04,440
0,210 210,690 690,960 960,1140 1140,1200
more complicated systems out of

2016
01:00:04,440 --> 01:00:06,810
0,240 960,1530 1560,1920 1920,2160 2160,2370
them,| and {} I'd argue
|我认为这就是分布式系统的实际构建方式，

2017
01:00:06,810 --> 01:00:07,560
0,120 120,360 360,450 450,600 600,750
that that's the way that

2018
01:00:07,560 --> 01:00:09,180
0,390 390,690 690,780 780,1080 1080,1620
distributed systems are actually built,|
|

2019
01:00:09,300 --> 01:00:10,590
0,240 240,450 450,660 660,1020 1020,1290
the way you build a
构建分布式系统的方法是通过

2020
01:00:10,590 --> 01:00:12,870
0,390 390,720 720,930 930,1260 1260,2280
distributed system is by| oftentimes
|通常使用构建块，

2021
01:00:12,870 --> 01:00:14,790
0,330 330,660 660,1200 1320,1710 1710,1920
using building blocks,| like kv
|像KV重视服务和锁服务或或动物园饲养员

2022
01:00:14,790 --> 01:00:16,530
0,330 330,810 810,930 930,1200 1200,1740
values services and lock services

2023
01:00:16,530 --> 01:00:18,330
0,240 330,570 570,750 750,1320 1350,1800
or or {zookeeper -}| and
|并将它们与一些您知道的添加的代码和新的功能放在一起

2024
01:00:18,330 --> 01:00:19,800
0,240 240,360 360,900 900,1110 1110,1470
putting them together with some

2025
01:00:19,830 --> 01:00:21,390
0,240 240,600 600,960 960,1260 1260,1560
{you,know} added code and novel

2026
01:00:21,390 --> 01:00:23,250
0,690 780,990 990,1260 1260,1590 1590,1860
functionality| to build your more
|为了建立更有趣、更有用的系统，

2027
01:00:23,250 --> 01:00:24,570
0,390 390,480 480,660 660,930 930,1320
interesting and more useful system,|
|

2028
01:00:25,840 --> 01:00:27,580
0,540 570,1050 1080,1290 1290,1350 1350,1740
and are sort of thesis
如果你愿意的话，这是一种论题，

2029
01:00:27,580 --> 01:00:28,720
0,90 90,210 210,600 720,930 930,1140
if you will,| is that
|核查可以而且应该利用这种构成性，

2030
01:00:28,720 --> 01:00:31,030
0,690 690,1260 1260,1500 1500,1920 1920,2310
verification can and should exploit

2031
01:00:31,030 --> 01:00:33,160
0,120 120,600 600,750 750,1020 1620,2130
this {compositionality - -}, {}|
|

2032
01:00:33,190 --> 01:00:34,690
0,390 390,900 900,1050 1050,1110 1110,1500
as one sort of targeted
作为一种有针对性的目标，

2033
01:00:34,690 --> 01:00:35,800
0,420 420,600 600,810 810,870 870,1110
goal,| we aim to prove
|我们的目标是证明客户端系统的规格，

2034
01:00:35,800 --> 01:00:39,100
0,870 870,1230 1260,1800 1800,2550 2850,3300
specifications for client systems,| firework
|像IronFleet Verdi这样的烟火仅仅是对实际服务器端[]的行为进行推理，

2035
01:00:39,100 --> 01:00:40,780
0,180 180,420 420,570 570,1170 1200,1680
like {IronFleet -} Verdi simply

2036
01:00:40,780 --> 01:00:42,580
0,330 330,690 690,990 990,1170 1170,1800
reason about what the behavior

2037
01:00:42,580 --> 01:00:43,840
0,90 90,240 240,630 630,990 990,1260
of the actual server side

2038
01:00:43,840 --> 01:00:45,310
0,270 270,420 420,690 840,1230 1230,1470
[] looks like,| and don't
|并且不要显式地建模或证明任何关于客户端程序实际所做的事情

2039
01:00:45,310 --> 01:00:47,080
0,600 600,1110 1110,1260 1260,1530 1530,1770
explicitly model or prove anything

2040
01:00:47,080 --> 01:00:48,610
0,360 390,660 660,720 720,1110 1110,1530
about what the client programs

2041
01:00:48,610 --> 01:00:49,990
0,240 240,600 660,810 810,1230 1230,1380
actually do| and oftentimes there's
|而且通常情况下，客户端上有一些逻辑，

2042
01:00:49,990 --> 01:00:50,650
0,60 60,210 210,300 300,600 600,660
a bit of logic on

2043
01:00:50,650 --> 01:00:52,390
0,60 60,570 750,1020 1020,1470 1470,1740
the client,| that's crucial for
|这对于获得正确的结果至关重要，

2044
01:00:52,390 --> 01:00:54,970
0,270 270,990 1530,2130 2160,2490 2490,2580
getting correctness,| {} and the
|我们使用的方法是使用并行分离逻辑中的先进技术，

2045
01:00:54,970 --> 01:00:55,900
0,330 330,450 450,690 690,810 810,930
approach we use is to

2046
01:00:55,900 --> 01:00:58,270
0,480 480,1230 1230,1470 1470,1920 1920,2370
use advances in concurrent separation

2047
01:00:58,270 --> 01:01:00,430
0,390 690,990 990,1080 1080,1560 1560,2160
logic,| which is a compositional
|它是关于并发程序的推理的组合手段，

2048
01:01:00,430 --> 01:01:01,720
0,270 270,390 390,690 690,960 960,1290
means of reasoning about concurrent

2049
01:01:01,720 --> 01:01:04,300
0,420 420,660 690,1170 1170,1860 1890,2580
programs,| that's lately become popular
|它最近变得流行起来

2050
01:01:04,300 --> 01:01:06,490
0,510 870,1620 1620,1800 1800,2130 2130,2190
for popular| and demonstrate to
|并证明成功地提出了关于真正的代码。

2051
01:01:06,490 --> 01:01:08,200
0,90 90,690 900,1230 1230,1440 1440,1710
be successful at raising about

2052
01:01:08,200 --> 01:01:08,820
0,150 150,540
real code.|
|

2053
01:01:09,800 --> 01:01:11,630
0,360 360,720 720,930 930,1500 1680,1830
So the first example that
所以我们研究的第一个例子，

2054
01:01:11,630 --> 01:01:12,920
0,90 90,390 390,600 600,780 780,1290
we worked on,| was verifying
|是在验证一个分割的价值系统，

2055
01:01:12,920 --> 01:01:15,080
0,60 60,450 450,810 810,1290 1710,2160
a sharded value system, {}|
|

2056
01:01:15,080 --> 01:01:16,430
0,210 210,690 690,780 780,990 990,1350
the keys in this are
其中的密钥是静态拆分成碎片的

2057
01:01:16,430 --> 01:01:18,050
0,300 540,1020 1020,1290 1290,1410 1410,1620
a statically split up into

2058
01:01:18,050 --> 01:01:20,690
0,720 990,1590 1590,1830 1830,2250 2250,2640
shards| {} and shards themselves
|并且碎片本身可以在碎片服务器之间移动，

2059
01:01:20,690 --> 01:01:21,560
0,120 120,210 210,510 510,810 810,870
can be moved between the

2060
01:01:21,560 --> 01:01:23,180
0,330 330,930 1140,1290 1290,1380 1380,1620
shard servers,| so it's very
|这与6.824的实验4非常相似，

2061
01:01:23,180 --> 01:01:24,710
0,390 390,510 510,870 870,1350 1350,1530
similar to lab 4 of

2062
01:01:24,710 --> 01:01:26,390
0,300 300,420 420,570 570,960 1020,1680
of {6.824 - -},| except
|只是它不是复制的，

2063
01:01:26,390 --> 01:01:27,740
0,210 210,510 510,780 780,1260 1260,1350
that it's not replicated,| so
|所以这里面没有木筏，

2064
01:01:27,740 --> 01:01:28,970
0,180 180,450 450,660 660,780 780,1230
there's no there's no raft

2065
01:01:28,970 --> 01:01:30,290
0,90 90,390 510,930 930,1140 1140,1320
in this,| and, {} it's
|而且，它纯粹是在记忆中。

2066
01:01:30,290 --> 01:01:31,260
0,360 360,450 450,840
purely in memory.|
|

2067
01:01:31,520 --> 01:01:33,080
0,300 300,690 690,960 990,1320 1320,1560
{} Besides that, {} our
除此之外，我们的系统还具有共享服务器和协调服务器

2068
01:01:33,080 --> 01:01:34,640
0,360 360,630 630,870 870,1140 1140,1560
system also has shared servers

2069
01:01:34,640 --> 01:01:36,350
0,330 330,660 660,1110 1110,1500 1500,1710
and a coordinator server| and
|协调器是通知其他碎片服务器的协调器

2070
01:01:36,500 --> 01:01:37,670
0,180 180,780 780,870 870,930 930,1170
the coordinator is the one

2071
01:01:37,670 --> 01:01:38,960
0,240 240,570 570,780 780,990 990,1290
that tells other shard servers|
|

2072
01:01:38,960 --> 01:01:40,700
0,300 390,750 750,1050 1050,1290 1290,1740
to move shard between themselves|
在碎片之间移动碎片|

2073
01:01:40,700 --> 01:01:41,540
0,300 300,450 450,630 630,720 720,840
as you {nodes -} want
因为您的节点想要加入

2074
01:01:41,540 --> 01:01:42,620
0,60 60,420 420,630 810,1020 1020,1080
to join| or as you
|或者当你需要重新平衡的时候，

2075
01:01:42,620 --> 01:01:45,080
0,90 90,150 150,870 1740,2160 2190,2460
need to rebalance,| {} the
|我们提供的库的顶部

2076
01:01:45,080 --> 01:01:46,160
0,360 360,450 450,510 510,990 990,1080
top of a library that

2077
01:01:46,160 --> 01:01:47,240
0,330 360,810 810,900 900,1020 1020,1080
we provide| and that we
|我们想要证明的是我们称之为KVClerk的规范，

2078
01:01:47,240 --> 01:01:48,680
0,270 270,480 510,720 720,780 780,1440
want to prove {} specification

2079
01:01:48,680 --> 01:01:50,060
0,360 510,930 930,1200 1200,1290 1290,1380
for is you know we

2080
01:01:50,060 --> 01:01:51,110
0,210 210,270 270,330 330,660 660,1050
call it a {KVClerk -},|
|

2081
01:01:51,110 --> 01:01:52,250
0,150 150,270 270,330 330,630 630,1140
which is a client object
它是一个用户可以使用的客户端对象

2082
01:01:52,340 --> 01:01:54,410
0,690 690,1020 1020,1200 1200,1740 1740,2070
that one can use| and
|我们调用这三个函数来实际与服务器交互，

2083
01:01:54,500 --> 01:01:55,610
0,120 120,390 390,600 600,750 750,1110
we call these three functions

2084
01:01:55,610 --> 01:01:57,260
0,390 480,900 900,1050 1050,1260 1260,1650
on {} to actually interact

2085
01:01:57,260 --> 01:01:58,460
0,120 120,390 390,720 720,840 840,1200
with the server,| so there's
|所以有一个看跌期权，你说要投入什么价值，

2086
01:01:58,460 --> 01:01:59,570
0,60 60,450 480,840 840,1020 1020,1110
a Put, you you say

2087
01:01:59,570 --> 01:02:00,350
0,210 210,540 540,600 600,720 720,780
what value to Put in,|
|

2088
01:02:00,350 --> 01:02:01,490
0,60 60,480 510,840 840,930 930,1140
the key there's a Get
键有一个GET，它将返回键中的当前值，

2089
01:02:01,490 --> 01:02:02,270
0,120 120,210 210,510 510,570 570,780
which will return the current

2090
01:02:02,270 --> 01:02:03,470
0,240 240,300 300,360 360,810 1050,1200
value in the key,| and
|然后是有条件的推送，

2091
01:02:03,470 --> 01:02:04,610
0,90 90,270 270,330 330,810 810,1140
then there's a {conditionalPut -},|
|

2092
01:02:04,640 --> 01:02:05,600
0,210 210,390 390,720 720,900 900,960
which will only put the
它只会放入新值，如果旧值是期望值，

2093
01:02:05,600 --> 01:02:07,520
0,210 210,810 930,1290 1290,1680 1680,1920
new value, if the old

2094
01:02:07,520 --> 01:02:09,140
0,390 390,570 570,780 780,1290 1290,1620
value is the expected one,|
|

2095
01:02:10,020 --> 01:02:11,670
0,420 450,870 870,1110 1110,1320 1320,1650
{} and we aim to
我们的目标是基本实现一个可线性化的密钥价值服务

2096
01:02:11,670 --> 01:02:13,920
0,450 450,930 930,1500 1500,2130 2130,2250
basically implement a implement a

2097
01:02:13,920 --> 01:02:14,940
0,240 240,390 390,450 450,780 780,1020
{linearizable - -} key value

2098
01:02:14,940 --> 01:02:16,680
0,330 330,510 510,840 840,930 930,1740
service| and approve a classification
|并批准显示可线性化的分类

2099
01:02:16,800 --> 01:02:19,320
0,330 330,600 600,750 780,1500 1950,2520
that shows {} linearizable| and
|以及您在分离逻辑样式中执行此操作的方式

2100
01:02:19,380 --> 01:02:20,250
0,270 270,450 450,630 630,750 750,870
{} the way you do

2101
01:02:20,250 --> 01:02:21,720
0,240 240,330 330,540 540,1080 1080,1470
this in the separation logic

2102
01:02:21,720 --> 01:02:23,670
0,600 600,1080 1230,1560 1560,1680 1680,1950
style| is basically by writing
|基本上是通过编写一个看起来很像这样的规范，

2103
01:02:23,670 --> 01:02:24,570
0,120 120,630 630,720 720,870 870,900
a specification that look a

2104
01:02:24,570 --> 01:02:26,070
0,210 210,330 330,750 1110,1290 1290,1500
lot like this,| so this
|这基本上是说，如果对象Ck是一个键值职员，

2105
01:02:26,070 --> 01:02:28,290
0,300 300,540 540,690 690,1860 1920,2220
basically says that if the

2106
01:02:28,290 --> 01:02:29,880
0,420 420,630 630,870 870,1080 1080,1590
object {ck -} is a

2107
01:02:29,910 --> 01:02:31,830
0,210 210,450 450,960 1230,1590 1590,1920
key value clerk,| {} then
|然后您就有了PUT和GET函数的规范，

2108
01:02:31,830 --> 01:02:34,050
0,150 150,930 1350,2040 2040,2160 2160,2220
you have specifications for the

2109
01:02:34,050 --> 01:02:35,820
0,180 180,270 270,450 450,1020 1260,1770
put and get functions,| that
|例如，如果您开始运行PUT函数，

2110
01:02:35,820 --> 01:02:37,950
0,360 360,540 540,1110 1740,1950 1950,2130
say for example, if you

2111
01:02:37,950 --> 01:02:39,420
0,420 420,600 600,690 690,960 960,1470
start running the put function,|
|

2112
01:02:39,510 --> 01:02:41,640
0,270 270,390 390,1290 1290,1710 1740,2130
with the precondition that key
在密钥k具有值w的前提下，

2113
01:02:41,640 --> 01:02:44,190
0,660 720,960 960,1320 1320,2220 2340,2550
k has value w,| then
|然后在它结束时，

2114
01:02:44,190 --> 01:02:44,790
0,120 120,240 240,360 360,420 420,600
by the end of it,|
|

2115
01:02:44,790 --> 01:02:46,170
0,180 180,330 330,540 540,750 750,1380
you'll know that key k
你会知道密钥k取值为v，

2116
01:02:46,200 --> 01:02:48,100
0,780 990,1200 1200,1500 1500,1830
get as value v,|
|

2117
01:02:48,720 --> 01:02:51,150
0,270 270,990 1200,1740 1740,1980 1980,2430
{} similarly, {} if you
同样，如果您执行一个GET

2118
01:02:51,180 --> 01:02:52,140
0,150 150,540 540,660 660,780 780,960
do {a,get}| and you know
|你知道，密钥k在开始时的值是v，

2119
01:02:52,140 --> 01:02:53,580
0,330 330,720 810,1050 1050,1290 1290,1440
that a key k has

2120
01:02:53,580 --> 01:02:54,540
0,270 270,420 420,510 510,600 600,960
value v at the beginning,|
|

2121
01:02:54,540 --> 01:02:55,500
0,270 300,570 570,660 660,810 810,960
then that's the thing that's
那么这就是要退还的东西

2122
01:02:55,500 --> 01:02:56,670
0,120 120,180 180,270 270,750 960,1170
going to be returned| and
|你仍然会知道这就是钥匙的价值，

2123
01:02:56,670 --> 01:02:57,420
0,90 90,360 360,540 540,630 630,750
you're still going to know

2124
01:02:57,420 --> 01:02:58,290
0,360 360,450 450,720 720,810 810,870
that's the value of the

2125
01:02:58,290 --> 01:03:00,720
0,360 870,1350 1350,1500 1500,2130 2130,2430
key,| although the specifications look
|尽管这些规范看起来很简单

2126
01:03:00,720 --> 01:03:02,310
0,210 210,660 660,960 990,1320 1350,1590
pretty simple| and you might
|您可能会认为，Key Value服务当然会

2127
01:03:02,310 --> 01:03:03,300
0,300 330,450 450,720 720,870 870,990
think, of course the key

2128
01:03:03,300 --> 01:03:04,800
0,180 180,450 450,900 1050,1320 1320,1500
value service does| and that's
|这就是这些顶级客户端规范尽可能简单的要点

2129
01:03:04,800 --> 01:03:05,460
0,120 120,180 180,240 240,540 540,660
sort of the point that

2130
01:03:05,460 --> 01:03:07,860
0,330 780,1140 1140,1320 1320,1590 1590,2400
these top level client specifications

2131
01:03:07,890 --> 01:03:08,880
0,330 330,420 420,750 750,900 900,990
are as simple as they

2132
01:03:08,880 --> 01:03:10,680
0,270 270,510 510,750 930,1200 1200,1800
can be| and and basically
|并且基本上隐藏了事实的所有细节，

2133
01:03:10,710 --> 01:03:12,030
0,510 510,780 780,840 840,1260 1260,1320
hide all the details of

2134
01:03:12,030 --> 01:03:13,260
0,90 90,330 330,480 570,930 930,1230
the fact,| that there's multiple
|有多个碎片服务器

2135
01:03:13,260 --> 01:03:14,820
0,330 330,870 870,990 990,1200 1260,1560
shard servers| and that this
|而这个书记员图书馆可能需要与服务器多次交谈，

2136
01:03:14,820 --> 01:03:16,110
0,390 390,780 780,1110 1110,1230 1230,1290
clerk library might need to

2137
01:03:16,110 --> 01:03:17,910
0,240 240,300 300,810 840,1320 1320,1800
talk to servers multiple times,|
|

2138
01:03:17,910 --> 01:03:18,840
0,120 120,270 270,390 390,510 510,930
it might need to refresh
它可能需要刷新其关于哪个服务器拥有该服务器的信息，

2139
01:03:18,840 --> 01:03:20,640
0,120 120,840 960,1260 1260,1470 1470,1800
its information about which server

2140
01:03:20,640 --> 01:03:22,500
0,420 420,810 840,960 960,1230 1230,1860
owns the,| {you,know} which keys,|
|你知道哪把钥匙，|

2141
01:03:22,650 --> 01:03:24,630
0,390 390,840 900,1230 1230,1410 1410,1980
{} and {} we basically
我们基本上证明了你的尊重，让你忘记了这一切

2142
01:03:24,660 --> 01:03:26,100
0,240 240,570 630,870 870,1260 1260,1440
{} you prove respect that

2143
01:03:26,100 --> 01:03:26,880
0,300 300,360 360,420 420,630 630,780
allows you to forget all

2144
01:03:26,880 --> 01:03:27,990
0,270 270,480 630,900 900,990 990,1110
that| and use a key
|只需调用这些PUT和GET即可使用关键人物服务

2145
01:03:27,990 --> 01:03:28,980
0,180 180,480 480,630 630,750 750,990
guy service just by calling

2146
01:03:28,980 --> 01:03:30,180
0,150 150,330 330,450 450,960 1080,1200
these puts and gets| and
|并对键值映射的实际情况有了这个理想化的概念。

2147
01:03:30,180 --> 01:03:31,410
0,180 180,300 300,870 870,1170 1170,1230
having this idealized notion of

2148
01:03:31,410 --> 01:03:33,210
0,240 240,600 1080,1350 1350,1530 1530,1800
what the key value mapping

2149
01:03:33,210 --> 01:03:34,080
0,300 300,540 540,780
actually looks like.|
|

2150
01:03:34,750 --> 01:03:35,560
0,270 270,360 360,390 390,630 630,810
{} So I won't talk
所以我不会太详细地谈论实际的证据是什么，

2151
01:03:35,560 --> 01:03:36,430
0,90 90,360 360,600 600,660 660,870
too much more in detail

2152
01:03:36,430 --> 01:03:37,300
0,210 210,360 360,450 450,660 660,870
about what the actual proof

2153
01:03:37,300 --> 01:03:39,490
0,210 210,720 930,1470 1590,2100 2100,2190
looks like,| {} instead to
|相反，要把重点放在我们感兴趣的下一件事上，

2154
01:03:39,490 --> 01:03:41,350
0,390 390,780 900,1350 1350,1530 1530,1860
focus to, {} issue focus

2155
01:03:41,350 --> 01:03:42,670
0,360 360,780 810,1140 1140,1230 1230,1320
towards a next thing we

2156
01:03:42,670 --> 01:03:43,960
0,90 90,360 360,420 420,750 930,1290
were interested in doing,| which
|这实际上是在做一些对此具有容错性的事情，

2157
01:03:43,960 --> 01:03:45,520
0,120 120,660 660,1020 1020,1410 1410,1560
is actually doing something with

2158
01:03:45,520 --> 01:03:46,480
0,30 30,150 150,210 210,510 510,960
a bit of fault tolerance

2159
01:03:46,480 --> 01:03:47,410
0,90 90,510 570,780 780,840 840,930
to this,| so I can
|所以我可以提一下，关键字值本身不是复制的

2160
01:03:47,410 --> 01:03:49,000
0,330 330,420 420,600 600,990 990,1590
mention the key value itself

2161
01:03:49,150 --> 01:03:50,440
0,150 150,390 390,930 930,1110 1110,1290
is not replicated| and {}
|并且不能容错

2162
01:03:50,440 --> 01:03:52,030
0,270 270,510 510,990 1140,1500 1500,1590
isn't fault tolerant| and so
|因此，我们开始尝试找出如何验证最简单的容错协议，

2163
01:03:52,030 --> 01:03:52,960
0,120 120,480 480,660 660,870 870,930
we started by trying to

2164
01:03:52,960 --> 01:03:54,280
0,270 270,390 390,570 570,660 660,1320
figure out how to verify

2165
01:03:54,460 --> 01:03:56,650
0,180 180,660 660,1530 1560,1800 1800,2190
the simplest possible fault tolerant

2166
01:03:56,980 --> 01:03:59,080
0,570 660,1110 1110,1410 1410,1800 1830,2100
protocol,| {} and we basically
|我们基本上开始了一项单一的帕克索斯法令

2167
01:03:59,080 --> 01:04:00,550
0,210 210,270 270,540 540,840 840,1470
started a {Single-decree -} Paxos|
|

2168
01:04:00,730 --> 01:04:01,900
0,480 480,480 480,840 840,1050 1050,1170
to {} decree paxos is
判定PAXOS是用于根据单个值获取内容的经典协议，

2169
01:04:01,900 --> 01:04:03,160
0,180 180,570 570,930 930,1080 1080,1260
a classic protocol for getting

2170
01:04:03,160 --> 01:04:04,630
0,420 420,540 540,600 600,1080 1080,1470
contents on a single value,|
|

2171
01:04:05,060 --> 01:04:06,290
0,240 240,480 480,600 600,660 660,1230
so whereas with a raft,|
因此，与木筏相比，|

2172
01:04:06,380 --> 01:04:08,180
0,180 180,390 390,780 810,1260 1260,1800
you can get you replicate
您可以让您复制整个日志

2173
01:04:08,180 --> 01:04:09,200
0,330 330,690 690,780 780,870 870,1020
entire log| and you keep
|你不停地在日志中添加新的条目，

2174
01:04:09,200 --> 01:04:10,460
0,300 300,450 450,690 690,810 810,1260
appending new entries to log,|
|

2175
01:04:10,490 --> 01:04:12,650
0,420 420,690 690,1170 1170,1350 1350,2160
{single-decree -} paxos is the
单一法令派克斯是多个[]的[]

2176
01:04:12,710 --> 01:04:14,000
0,390 390,480 480,750 750,1110 1110,1290
[] of multi []| and
|基本实现了一次写入寄存器的功能，

2177
01:04:14,150 --> 01:04:15,620
0,570 570,900 900,1020 1020,1260 1260,1470
basically functions of write once

2178
01:04:15,620 --> 01:04:17,180
0,540 660,1110 1110,1260 1260,1350 1350,1560
register,| {} if you want
|如果要将值设置为某个值，

2179
01:04:17,180 --> 01:04:18,740
0,360 480,840 840,1170 1170,1470 1470,1560
to set the value to

2180
01:04:18,740 --> 01:04:20,450
0,480 510,720 720,870 870,1350 1350,1710
something,| you can attempt to
|您可以尝试对其进行写入，

2181
01:04:20,450 --> 01:04:21,830
0,210 240,570 570,690 690,870 1140,1380
{} write to it,| and
|如果有人打败了你，

2182
01:04:21,830 --> 01:04:22,760
0,90 90,360 360,540 540,750 750,930
if someone else beat you,|
|

2183
01:04:22,760 --> 01:04:24,530
0,330 330,330 1230,1470 1470,1560 1560,1770
then, {} that's too bad
那对你来说太糟糕了，

2184
01:04:24,530 --> 01:04:25,190
0,90 90,300 300,390 390,570 570,660
for you,| and now the
|现在价值已经确定了

2185
01:04:25,190 --> 01:04:26,180
0,210 210,300 300,480 480,600 600,990
value has already been decided|
|

2186
01:04:26,180 --> 01:04:26,840
0,120 120,240 240,450 450,570 570,660
and it's never going to
它再也不会改变了，

2187
01:04:26,840 --> 01:04:27,540
0,240 240,510
change again,|
|

2188
01:04:28,080 --> 01:04:30,090
0,540 690,1050 1050,1320 1320,1830 1830,2010
{} so we implemented and
因此，我们实现并部分验证了单个法令的paxos实现

2189
01:04:30,090 --> 01:04:31,650
0,330 330,900 900,990 990,1260 1260,1560
partially verified a {single-decree -}

2190
01:04:31,650 --> 01:04:33,690
0,300 300,1050 1140,1380 1380,1860 1860,2040
paxos implementation| and basically prove
|基本上证明了它是一次写入寄存器的规范

2191
01:04:33,690 --> 01:04:35,040
0,60 60,660 660,780 780,1140 1140,1350
a specification that shows that

2192
01:04:35,160 --> 01:04:36,600
0,240 240,330 330,570 570,780 780,1440
it's a write once register|
|

2193
01:04:37,560 --> 01:04:39,240
0,180 180,270 270,510 510,1020 1020,1680
and the key idea in
以及说明书和证明中的关键思想

2194
01:04:39,270 --> 01:04:40,740
0,90 90,720 720,810 810,900 900,1470
the specification and the proof|
|

2195
01:04:40,920 --> 01:04:42,480
0,210 210,600 630,990 990,1200 1200,1560
is that when you commit
当你在单一法令的派克斯债券中承诺一个值时，

2196
01:04:42,480 --> 01:04:43,860
0,30 30,570 570,840 870,1110 1110,1380
a value in in {single-decree

2197
01:04:43,860 --> 01:04:46,050
0,210 210,750 990,1230 1230,1500 1530,2190
-} paxos,| you get irrevocable
|你得到了不可撤销的知识，知道什么是承诺的价值

2198
01:04:46,050 --> 01:04:47,580
0,450 450,600 600,990 990,1380 1380,1530
knowledge of what that a

2199
01:04:47,580 --> 01:04:49,140
0,360 360,660 660,1260 1320,1470 1470,1560
committed value is| and you
|你基本上知道，从现在开始，

2200
01:04:49,140 --> 01:04:50,370
0,330 330,480 480,690 750,1020 1020,1230
basically know that from here

2201
01:04:50,370 --> 01:04:51,690
0,150 150,420 420,540 570,1020 1020,1320
on out,| if anybody else
|如果其他人看到任何承诺的价值，

2202
01:04:51,720 --> 01:04:53,430
0,300 300,660 660,870 870,1200 1200,1710
ever sees any committed value,|
|

2203
01:04:53,550 --> 01:04:54,570
0,270 270,390 390,450 450,750 900,1020
it's going to be the
这将是你现在看到的完全相同的东西。

2204
01:04:54,570 --> 01:04:55,470
0,360 360,510 510,630 630,750 750,900
exact same thing that you

2205
01:04:55,470 --> 01:04:56,240
0,180 180,390 390,690
see right now.|
|

2206
01:04:57,190 --> 01:04:58,510
0,630 630,960 960,1170 1170,1290 1290,1320
And thinking about this a
在我们研究了它的证明之后，想了想这个问题，

2207
01:04:58,510 --> 01:04:59,680
0,150 150,270 270,540 540,810 840,1170
little bit after we worked

2208
01:04:59,680 --> 01:05:00,400
0,90 90,180 180,390 390,480 480,720
on the proof of it,|
|

2209
01:05:00,910 --> 01:05:02,320
0,330 330,660 660,840 840,900 900,1410
{} we sort of thinking
我们有点想，

2210
01:05:02,320 --> 01:05:03,580
0,420 480,690 690,1050 1050,1200 1200,1260
that,| {} we sort of
|我们可以说注意到，

2211
01:05:03,580 --> 01:05:04,660
0,300 300,390 390,600 600,750 750,1080
notice that,| there's a slight
|你可以对单一法令的帕克斯做一个轻微的概括，

2212
01:05:04,660 --> 01:05:06,010
0,630 630,750 750,840 840,1020 1020,1350
generalization you can do to

2213
01:05:06,280 --> 01:05:08,170
0,300 300,540 540,960 960,1500 1530,1890
{single-decree -} paxos,| which a
|我们都是单调的帕克索斯，因为没有更好的名字

2214
01:05:08,170 --> 01:05:10,000
0,210 210,600 630,1140 1140,1530 1530,1830
we all Monotone Paxos for

2215
01:05:10,000 --> 01:05:11,530
0,240 240,300 300,480 480,900 1320,1530
lack of better name| and
|这个想法不是在提交时获得关于确切价值的知识，

2216
01:05:11,530 --> 01:05:13,360
0,120 120,510 510,840 840,1470 1470,1830
the idea is rather than

2217
01:05:13,390 --> 01:05:15,280
0,570 570,930 930,1170 1170,1290 1290,1890
gaining knowledge about the exact

2218
01:05:15,280 --> 01:05:16,720
0,270 270,480 480,540 540,930 1200,1440
value upon a commit,| you
|你可以改为我们修改协议，

2219
01:05:16,720 --> 01:05:18,790
0,660 720,990 990,1260 1260,1530 1560,2070
instead {} can we modify

2220
01:05:18,790 --> 01:05:20,110
0,120 120,660 840,1020 1020,1140 1140,1320
the protocol,| so that you
|这样你就只能获得关于值的下界的知识，

2221
01:05:20,110 --> 01:05:21,430
0,270 270,570 570,930 930,1170 1170,1320
only gain knowledge about a

2222
01:05:21,430 --> 01:05:22,930
0,360 360,870 870,1020 1020,1080 1080,1500
lower bound on the value,|
|

2223
01:05:23,570 --> 01:05:26,090
0,450 450,930 990,1770 1800,2130 2130,2520
so, {} basically when you
所以，基本上，当你承诺一个价值时，

2224
01:05:26,090 --> 01:05:27,590
0,390 540,810 810,870 870,1320 1380,1500
{} commit a value,| for
|例如，一旦寄存器，您在编号15处提交此写入

2225
01:05:27,590 --> 01:05:28,400
0,240 240,360 360,480 480,600 600,810
example you commit at number

2226
01:05:28,400 --> 01:05:29,870
0,600 600,690 690,960 960,1260 1260,1470
15 to this write, once

2227
01:05:29,870 --> 01:05:31,760
0,540 630,1290 1290,1410 1410,1710 1710,1890
register| rather than knowing that
|我们不会知道15对其他人来说是未来唯一的价值，而是我们将看到，

2228
01:05:31,760 --> 01:05:32,960
0,390 390,480 480,630 630,930 930,1200
15 is the only value

2229
01:05:32,960 --> 01:05:33,650
0,60 60,390 390,570 570,630 630,690
to anybody else in the

2230
01:05:33,650 --> 01:05:34,550
0,270 270,390 390,510 510,570 570,900
future, we're going to see,|
|

2231
01:05:34,760 --> 01:05:36,200
0,210 210,420 420,720 870,1170 1170,1440
you'll know that any value
你会知道人们在未来看到的任何价值

2232
01:05:36,200 --> 01:05:36,800
0,90 90,300 300,450 450,510 510,600
that people see in the

2233
01:05:36,800 --> 01:05:37,970
0,330 330,450 450,840 840,960 960,1170
future| as committed is going
|承诺的人数至少为15人，

2234
01:05:37,970 --> 01:05:40,100
0,60 60,210 210,390 390,750 1590,2130
to be at least 15,|
|

2235
01:05:40,100 --> 01:05:41,090
0,150 150,240 240,300 300,720 720,990
and so of course doing
当然，要做到这一点，需要对大于值类型的实际含义有一些概念。

2236
01:05:41,090 --> 01:05:42,470
0,150 150,510 510,690 690,1020 1020,1380
this requires having some notion

2237
01:05:42,470 --> 01:05:44,000
0,90 90,390 480,1020 1020,1200 1200,1530
of what larger than actually

2238
01:05:44,000 --> 01:05:45,200
0,300 300,390 390,450 450,780 780,1200
means for the value type.|
|

2239
01:05:45,550 --> 01:05:48,040
0,630 990,1530 1560,1950 1980,2280 2280,2490
{} And {} the key
关键思想是复本始终可以找到最新提交的值是多少

2240
01:05:48,040 --> 01:05:50,200
0,300 300,750 900,1320 1350,2010 2010,2160
idea is a replica can

2241
01:05:50,200 --> 01:05:51,820
0,360 360,690 690,900 900,1080 1080,1620
always find out what the

2242
01:05:51,850 --> 01:05:53,650
0,480 480,780 780,1110 1110,1470 1560,1800
latest committed value is| and
|并选择增加它

2243
01:05:53,650 --> 01:05:55,180
0,240 240,360 360,810 810,1020 1200,1530
choose to increase it| and
|而其他复制可以不断地找出到目前为止的值基本上是越来越大的下界，

2244
01:05:55,180 --> 01:05:56,830
0,270 270,660 660,810 810,1350 1350,1650
other replicates can continually find

2245
01:05:56,830 --> 01:05:58,150
0,240 240,630 630,720 720,1050 1050,1320
out larger and larger lower

2246
01:05:58,150 --> 01:05:59,860
0,420 420,660 810,1290 1290,1380 1380,1710
bounds on basically the value

2247
01:05:59,860 --> 01:06:01,140
0,270 270,630 630,1110
so far is,|
|

2248
01:06:01,680 --> 01:06:03,660
0,870 930,1350 1350,1680 1710,1920 1920,1980
and once we sort of
一旦我们想出了单调的短裤的想法，

2249
01:06:03,660 --> 01:06:04,440
0,150 150,210 210,300 300,390 390,780
came up with this idea

2250
01:06:04,440 --> 01:06:07,200
0,240 240,690 690,1260 1320,2010 2040,2760
of monotone paxos,| we realized
|我们立刻意识到，我们可以用它来进行日志复制，

2251
01:06:07,200 --> 01:06:08,430
0,330 330,570 600,870 870,990 990,1230
immediately that we can do

2252
01:06:08,430 --> 01:06:10,620
0,300 300,810 810,930 930,1350 1770,2190
log replication with this,| so
|所以这组值V，我们可以简单地选择为所有的对数，

2253
01:06:10,620 --> 01:06:13,020
0,1140 1200,1530 1530,1590 1590,1980 1980,2400
the set of values V,

2254
01:06:13,050 --> 01:06:14,160
0,390 390,570 570,690 690,990 990,1110
{} we can choose to

2255
01:06:14,160 --> 01:06:15,600
0,270 270,450 450,630 630,720 720,1440
simply be all the logs,|
|

2256
01:06:15,630 --> 01:06:16,290
0,210 210,270 270,450 450,600 600,660
that you might want to
您可能希望复制您的操作日志

2257
01:06:16,290 --> 01:06:18,540
0,540 630,990 990,1500 1500,1560 1560,2250
replicate your logs of operations|
|

2258
01:06:18,660 --> 01:06:19,860
0,240 240,330 330,420 420,990 990,1200
and we can define one
我们可以定义一个对数大于另一个对数，

2259
01:06:19,860 --> 01:06:20,550
0,150 150,270 270,360 360,600 600,690
log to be bigger than

2260
01:06:20,550 --> 01:06:22,350
0,210 210,510 510,720 720,1320 1350,1800
another one,| if the smaller
|如果较小的是L1的前缀是L2的前缀，

2261
01:06:22,350 --> 01:06:23,280
0,150 150,240 240,360 360,750 750,930
one is a prefix of

2262
01:06:23,850 --> 01:06:24,630
0,240 240,390 390,480 480,510 510,780
{l1 -} is a prefix

2263
01:06:24,630 --> 01:06:25,240
0,90 90,210 210,480
of {l2 -},|
|

2264
01:06:26,820 --> 01:06:28,530
0,540 600,900 900,1140 1140,1410 1410,1710
{} and this basically allows
这基本上让我们知道，

2265
01:06:28,530 --> 01:06:29,370
0,150 150,300 300,510 510,720 720,840
us to know,| this sort
|这就产生了一种你必须信任的协议，

2266
01:06:29,370 --> 01:06:30,930
0,150 240,810 810,870 870,1350 1350,1560
of yield a protocol which

2267
01:06:30,930 --> 01:06:32,040
0,150 150,360 360,420 420,840 840,1110
you'll have to trust,| that
|我现在给你们看的是代码，

2268
01:06:32,040 --> 01:06:32,730
0,90 90,270 270,360 360,450 450,690
I'm showing you the code

2269
01:06:32,730 --> 01:06:34,590
0,270 570,990 990,1110 1110,1650 1680,1860
for,| {} in which you
|您可以在其中获取有关日志前缀的信息

2270
01:06:34,590 --> 01:06:36,780
0,330 360,1110 1110,1740 1740,2010 2010,2190
can gain information about what

2271
01:06:36,780 --> 01:06:37,770
0,90 90,510 510,570 570,660 660,990
the prefix of the log

2272
01:06:37,770 --> 01:06:39,330
0,300 570,840 840,1110 1110,1440 1440,1560
is| and over time you
|随着时间的推移，您可以向日志中添加新的内容

2273
01:06:39,330 --> 01:06:40,290
0,150 150,480 480,690 690,870 870,960
can add new things to

2274
01:06:40,290 --> 01:06:41,310
0,270 270,390 390,630 630,720 720,1020
log| by making it larger
|通过让它变得越来越大

2275
01:06:41,310 --> 01:06:42,360
0,90 90,480 480,720 720,900 900,1050
and larger| and that's pretty
|这几乎就是我们的意思，

2276
01:06:42,360 --> 01:06:43,500
0,90 90,600 600,750 750,870 870,1140
much exactly what we mean,|
|

2277
01:06:43,500 --> 01:06:44,580
0,90 90,150 150,270 270,510 510,1080
when we say log replication.|
当我们说到日志复制时。|

2278
01:06:45,380 --> 01:06:46,760
0,450 480,630 630,870 870,1020 1020,1380
{} The problem with this
这个协议的问题是

2279
01:06:46,790 --> 01:06:49,010
0,570 570,1020 1020,1140 1140,1710 1710,2220
exact protocol is that| naively
|如果我们用最天真的版本来实现这个单调的小熊猫，

2280
01:06:49,010 --> 01:06:50,450
0,120 120,330 660,1110 1110,1170 1170,1440
if we implement the most

2281
01:06:50,450 --> 01:06:52,130
0,360 360,660 660,810 930,1290 1290,1680
naive version of this monotone

2282
01:06:52,130 --> 01:06:53,450
0,360 360,660 870,1110 1110,1200 1200,1320
paxos thing,| you would need
|您需要在每个RPC上发送完整的日志，

2283
01:06:53,450 --> 01:06:54,470
0,90 90,300 300,540 540,630 630,1020
to send around the full

2284
01:06:54,470 --> 01:06:55,580
0,390 390,510 510,750 750,990 990,1110
log on every single {RPC

2285
01:06:55,580 --> 01:06:57,320
0,480 720,1020 1020,1260 1260,1470 1470,1740
-},| in {single-decree -} paxos,
|在单法令paxo中，您在所有RPC上发送的值为[错误]

2286
01:06:57,320 --> 01:06:58,070
0,210 210,330 330,480 480,690 690,750
those you sent around the

2287
01:06:58,070 --> 01:06:59,690
0,270 270,840 900,1260 1260,1440 1440,1620
[fault] value on all the

2288
01:06:59,690 --> 01:07:02,210
0,630 720,1230 1230,1590 1620,2160 2280,2520
RPCs| and the new {}
|并且模型在PARXOS中的新的微不足道的概括将不得不被发送到整个日志，

2289
01:07:02,210 --> 01:07:04,100
0,810 810,1440 1440,1560 1560,1620 1620,1890
trivial generalization of the model

2290
01:07:04,100 --> 01:07:04,790
0,60 60,390 390,510 510,630 630,690
in paxos would have to

2291
01:07:04,790 --> 01:07:05,420
0,60 60,210 210,360 360,420 420,630
be sent around the full

2292
01:07:05,420 --> 01:07:07,220
0,420 660,990 990,1170 1170,1440 1440,1800
log,| that's not really useful
|这并不是真正有用的日志，以变得越来越大

2293
01:07:07,220 --> 01:07:08,270
0,120 120,480 480,570 570,780 780,1050
to log to get larger

2294
01:07:08,270 --> 01:07:09,200
0,90 90,300 300,390 390,720 720,930
and larger and larger| and
|并且到那时，日志的开始不再相关，

2295
01:07:09,410 --> 01:07:10,430
0,270 270,570 570,660 660,870 870,1020
the beginning of log is

2296
01:07:10,430 --> 01:07:11,750
0,120 120,420 420,900 930,1230 1230,1320
no longer relevant by the

2297
01:07:11,750 --> 01:07:13,070
0,180 180,540 540,810 810,900 900,1320
time,| everybody agreed to commit|
|每个人都同意承诺|

2298
01:07:13,070 --> 01:07:14,540
0,420 420,510 510,810 1080,1320 1320,1470
and all that, so you
所有这些，所以您可以尝试通过传递日志的后缀来优化它

2299
01:07:14,540 --> 01:07:15,500
0,90 90,180 180,270 270,810 810,960
could try to optimize this

2300
01:07:15,500 --> 01:07:16,760
0,270 270,570 570,930 930,1170 1170,1260
by only passing around a

2301
01:07:16,760 --> 01:07:18,680
0,390 390,480 480,540 540,1050 1410,1920
suffix of the log| and
|事实上，有一个完整的优化序列，

2302
01:07:18,680 --> 01:07:20,750
0,570 570,570 1080,1320 1320,1350 1350,2070
indeed, {} there's a whole

2303
01:07:20,780 --> 01:07:22,100
0,420 420,480 480,1080 1080,1200 1200,1320
sequence of optimization,| you can
|您可以对这种基于单调paxos的日志进行复制，

2304
01:07:22,100 --> 01:07:23,900
0,240 240,300 300,660 690,1350 1350,1800
make to this monotone paxos

2305
01:07:23,900 --> 01:07:26,300
0,300 300,480 480,1200 1560,2070 2100,2400
based log replication,| and as
|当你开始做越来越多这样的事情时，

2306
01:07:26,300 --> 01:07:27,290
0,150 150,420 420,660 660,900 900,990
you start doing more and

2307
01:07:27,290 --> 01:07:28,400
0,150 150,240 240,480 480,750 750,1110
more of this,| you'll realize
|你会意识到这看起来和木筏一模一样

2308
01:07:28,400 --> 01:07:29,870
0,180 240,510 510,630 630,1230 1230,1470
that this looks exactly like

2309
01:07:29,870 --> 01:07:32,630
0,600 1140,1530 1530,1650 1650,2130 2160,2760
raft| and in fact, {}
|事实上，我们的目标基本上是利用我们监测帕克斯的想法

2310
01:07:32,960 --> 01:07:35,030
0,540 540,1050 1050,1530 1530,1770 1770,2070
We aimed basically to use

2311
01:07:35,030 --> 01:07:36,350
0,150 150,390 390,450 450,780 780,1320
our idea of monitoring paxos|
|

2312
01:07:36,380 --> 01:07:37,790
0,480 480,570 570,990 990,1110 1110,1410
not to implement a new
不实现新的复制协议，

2313
01:07:37,790 --> 01:07:39,980
0,510 510,1140 1200,1590 1590,1980 1980,2190
replication protocol,| but rather to
|而是为了验证一个类似木筏的系统，

2314
01:07:40,010 --> 01:07:42,050
0,450 450,1050 1050,1410 1410,1560 1560,2040
a {verify,a} raft like system,|
|

2315
01:07:42,320 --> 01:07:43,220
0,180 180,450 450,540 540,660 660,900
so we have this proof
所以我们有一个单一法令派克斯的证明，

2316
01:07:43,220 --> 01:07:44,660
0,120 120,330 330,570 570,1110 1230,1440
for {single-decree -} paxos,| we
|我们对这种单调的派克索斯有一个明确的概括

2317
01:07:44,660 --> 01:07:45,740
0,90 90,240 240,450 450,990 990,1080
have this clear generalization to

2318
01:07:45,740 --> 01:07:47,960
0,180 180,660 660,900 900,1380 1950,2220
this monotone paxos thing| and
|我们的希望是，我们可以利用单调的派克斯的想法，

2319
01:07:47,960 --> 01:07:48,620
0,120 120,360 360,450 450,570 570,660
our hope is that we

2320
01:07:48,620 --> 01:07:49,460
0,150 150,390 390,510 510,780 780,840
can use the idea of

2321
01:07:49,460 --> 01:07:51,110
0,450 450,660 660,870 870,1170 1200,1650
monotone paxos,| {so -} to
|所以基本上直接验证浮筏，

2322
01:07:51,140 --> 01:07:53,270
0,390 390,810 810,1140 1140,1770 1830,2130
basically verify raft directly,| as
|与依赖于为RAFT而争论的更为复杂的正确性相反，

2323
01:07:53,270 --> 01:07:54,650
0,390 390,480 480,870 870,1170 1170,1380
opposed to rely on the

2324
01:07:54,650 --> 01:07:56,690
0,270 270,420 420,1140 1170,1770 1770,2040
much more complicated correctness argued

2325
01:07:56,690 --> 01:07:58,550
0,510 540,570 570,1110 1320,1740 1740,1860
for {} raft,| that has
|这已经在某种其他状态机类型的样式中进行了描述。

2326
01:07:58,550 --> 01:07:59,690
0,90 90,630 630,810 810,990 990,1140
been described in sort of

2327
01:07:59,900 --> 01:08:01,670
0,300 300,600 600,870 870,1080 1080,1770
other state machine type styles.|
|

2328
01:08:02,220 --> 01:08:03,870
0,510 570,750 750,900 900,1140 1200,1650
{} So this is our
所以这是我们未来的工作，

2329
01:08:03,930 --> 01:08:06,360
0,450 450,810 1080,1590 1860,2130 2130,2430
future work,| {} and the
|我想告诉你们的关键一点是

2330
01:08:06,360 --> 01:08:07,680
0,180 180,600 600,960 960,1140 1140,1320
key takeaway I I sort

2331
01:08:07,680 --> 01:08:09,300
0,60 60,300 300,630 750,1560 1560,1620
of want to leave you

2332
01:08:09,300 --> 01:08:10,620
0,180 180,300 300,420 420,660 720,1320
guys with is that| reasoning
|关于分布式系统的正式和非正式推理，

2333
01:08:10,620 --> 01:08:12,330
0,270 270,660 660,900 900,1350 1350,1710
both formal and informal about

2334
01:08:12,390 --> 01:08:14,070
0,330 330,480 480,1080 1320,1590 1590,1680
{distributed -} systems,| should be
|应该像编写代码一样进行组合，

2335
01:08:14,070 --> 01:08:15,840
0,120 120,720 720,960 990,1320 1320,1770
as compositional as writing code,|
|

2336
01:08:16,230 --> 01:08:17,160
0,210 210,330 330,450 450,720 720,930
the way you scale writing
编写代码的扩展方式是模块化的，

2337
01:08:17,160 --> 01:08:18,360
0,210 210,300 300,870 870,990 990,1200
code is modular,| and that's
|这就是推理也应该进行扩展的方式。

2338
01:08:18,360 --> 01:08:19,680
0,90 90,240 240,750 930,1110 1110,1320
the way reasoning should also

2339
01:08:19,680 --> 01:08:20,240
0,390
scale.|
|

2340
01:08:21,680 --> 01:08:24,020
0,510 540,1110 1410,1980 2040,2250 2250,2340
{} And that's all for
我的演讲到此结束，

2341
01:08:24,020 --> 01:08:25,160
0,90 90,510 510,630 630,840 840,1140
my presentation,| I'm happy to
|我很乐意回答大家的提问。

2342
01:08:25,250 --> 01:08:26,360
0,180 180,840
take questions.|
|

2343
01:08:29,140 --> 01:08:29,800
0,360

2344
01:08:35,610 --> 01:08:36,510
0,300 300,420 420,630 630,750 750,900
If the answer is too
如果答案太长，

2345
01:08:36,510 --> 01:08:37,710
0,300 300,420 420,930 930,1050 1050,1200
long,| you can look me
|你可以在聊天中看到我，

2346
01:08:37,710 --> 01:08:38,310
0,90 90,180 180,480 480,570 570,600
in the chat,| but I
|但我很好奇，

2347
01:08:38,310 --> 01:08:39,210
0,90 90,540 540,660 660,780 780,900
was curious,| I know there's
|我知道有个壁橱，

2348
01:08:39,210 --> 01:08:40,080
0,60 60,630 630,720 720,780 780,870
a closet,| do you have
|你有没有什么资源提供给有兴趣从软件的角度进入的人，

2349
01:08:40,080 --> 01:08:41,550
0,180 180,630 630,750 750,1080 1080,1470
any resources for somebody interested

2350
01:08:41,550 --> 01:08:42,900
0,90 90,330 330,690 690,960 960,1350
in getting into {as,a -}

2351
01:08:43,140 --> 01:08:44,580
0,330 330,390 390,690 690,1260 1260,1440
from a software perspective,| like
|就像任何简短的建议一样。

2352
01:08:44,580 --> 01:08:46,220
0,210 210,570 570,1470
any brief recommendations.|
|

2353
01:08:46,780 --> 01:08:49,090
0,780 1230,1440 1440,1680 1680,1890 1890,2310
{} Are you, so yeah,
你是，所以是的，我想我不是很确定，

2354
01:08:49,090 --> 01:08:50,170
0,210 210,390 390,690 690,870 870,1080
I guess I'm not quite

2355
01:08:50,170 --> 01:08:51,480
0,210 210,480 480,960
sure what the,|
|

2356
01:08:51,780 --> 01:08:52,800
0,360 360,540 540,600 600,900 900,1020
so, are you interested in
那么，你有没有兴趣，

2357
01:08:52,800 --> 01:08:54,210
0,300 300,660 660,960 990,1170 1170,1410
like,| I I should message
|我我应该在事后发消息，

2358
01:08:54,210 --> 01:08:55,500
0,240 240,510 570,840 840,960 960,1290
afterward,| but if you're interested
|但如果你感兴趣的话，我想，

2359
01:08:55,500 --> 01:08:57,180
0,90 90,360 360,720 750,1080 1110,1680
I guess,| in a sort
|在某种最轻量级的验证版本中，

2360
01:08:57,300 --> 01:08:59,550
0,600 600,990 990,1230 1230,1410 1410,2250
most lightweight versions of verification,|
|

2361
01:08:59,670 --> 01:09:00,540
0,180 180,360 360,720 720,780 780,870
I think [Daphne] is a
我认为[达芙妮]是一个很好的学习工具，

2362
01:09:00,540 --> 01:09:01,530
0,240 240,390 390,480 480,810 810,990
great tool to learn,| because
|因为这是一个非常简单的起点，

2363
01:09:01,530 --> 01:09:03,540
0,300 300,720 1110,1530 1530,1740 1740,2010
it's a pretty simple starting

2364
01:09:03,540 --> 01:09:04,890
0,180 180,270 270,390 390,720 960,1350
point,| you can write real
|你可以编写真正的代码，并对事物有感觉，

2365
01:09:04,890 --> 01:09:05,880
0,360 360,600 600,750 750,780 780,990
code and get a feel

2366
01:09:05,880 --> 01:09:07,290
0,120 120,660 750,1080 1080,1200 1200,1410
for things,| {} I think
|我认为很多很多的核实都是相当学术的

2367
01:09:07,290 --> 01:09:08,040
0,120 120,330 330,390 390,630 630,750
a lot of a lot

2368
01:09:08,040 --> 01:09:09,360
0,60 60,480 480,600 600,810 810,1320
of verification is pretty academic|
|

2369
01:09:09,360 --> 01:09:10,950
0,270 360,870 870,1230 1230,1500 1500,1590
and not super close to
而且在像这样的验证中并不是非常有用，

2370
01:09:10,950 --> 01:09:12,870
0,270 270,600 600,1050 1050,1380 1380,1920
being really useful at verification

2371
01:09:12,870 --> 01:09:14,910
0,180 180,630 870,1440 1470,1890 1890,2040
like this,| {} so I'm
|所以我不确定它到底有多大用处，

2372
01:09:14,910 --> 01:09:15,570
0,150 150,240 240,330 330,600 600,660
not sure how useful it

2373
01:09:15,570 --> 01:09:16,800
0,210 210,390 390,540 540,870 900,1230
really would be for,| real
|真正的软件目前还没有，

2374
01:09:16,800 --> 01:09:18,210
0,300 300,540 540,720 720,1050 1260,1410
software during just yet,| so
|因此，人们希望有一天它会成为现实。

2375
01:09:18,210 --> 01:09:19,260
0,90 90,300 300,450 450,780 810,1050
the hope is that one

2376
01:09:19,260 --> 01:09:20,300
0,90 90,180 180,330 330,570
day it will be.|
|

2377
01:09:20,840 --> 01:09:21,500
0,390
Thanks.|
谢谢。|

2378
01:09:24,670 --> 01:09:26,980
0,630 630,840 840,1710 1740,2040 2040,2310
Did you implement {} this
你有没有实现你所说的这个版本的派克斯。

2379
01:09:26,980 --> 01:09:28,480
0,480 480,870 870,1140 1140,1290 1290,1500
version of {paxos -} you're

2380
01:09:28,480 --> 01:09:29,540
0,330 330,780
talking about.|
|

2381
01:09:29,770 --> 01:09:31,330
0,360 360,840 840,1080 1080,1260 1260,1560
This monotone paxos those thing.|
这个单调的派克斯穿着那些东西。|

2382
01:09:32,500 --> 01:09:34,120
0,510 510,690 690,900 900,1020 1020,1620
{} So, yeah I implemented
所以，是的，我实现了，而不是实现了通用的单调paxos，

2383
01:09:34,120 --> 01:09:35,770
0,240 240,330 330,870 900,1170 1170,1650
rather than implementing a generic

2384
01:09:35,770 --> 01:09:37,150
0,330 330,630 630,840 840,1050 1050,1380
monotone paxos thing,| which wouldn't
|这真的说不通

2385
01:09:37,150 --> 01:09:37,930
0,120 120,270 270,480 480,570 570,780
really make sense| and go
|无论如何，我直接实现了单调paxos上的日志复制，

2386
01:09:37,930 --> 01:09:39,910
0,510 540,750 750,1350 1350,1860 1860,1980
anyways I implemented directly the

2387
01:09:39,910 --> 01:09:42,100
0,330 330,1050 1080,1410 1410,1800 1800,2190
log replication over monotone {paxos

2388
01:09:42,100 --> 01:09:43,810
0,300 330,570 570,1050 1050,1290 1290,1710
-},| so in this monotone
|因此，在单调单调日志应用程序中，

2389
01:09:44,110 --> 01:09:46,150
0,780 810,1230 1230,1590 1590,1890 1890,2040
monotone log application thing,| all
|所有RPC中心都在满日志上，

2390
01:09:46,150 --> 01:09:46,930
0,90 90,420 420,630 630,720 720,780
the RPC center on the

2391
01:09:46,930 --> 01:09:48,100
0,240 240,720 870,990 990,1080 1080,1170
full log,| if you run
|如果你跑了很长时间才变得太慢，

2392
01:09:48,100 --> 01:09:48,760
0,60 60,150 150,210 210,450 450,660
it for a long time

2393
01:09:48,760 --> 01:09:49,750
0,180 180,330 330,510 510,630 630,990
to get way too slow,|
|

2394
01:09:49,750 --> 01:09:50,860
0,150 150,450 570,780 780,1020 1020,1110
because the {RPCs -} are
因为RPC发送了太多的东西，

2395
01:09:50,860 --> 01:09:51,640
0,180 180,270 270,390 390,630 630,780
sending too much stuff,| but
|但是，是的，我确实实施了，

2396
01:09:51,640 --> 01:09:52,900
0,300 450,570 570,690 690,1080 1080,1260
yeah I did implement it,|
|

2397
01:09:52,900 --> 01:09:53,920
0,240 240,570 570,660 660,780 780,1020
{} and I think we're
我认为我们实际上正在努力试图对此进行推理。

2398
01:09:53,980 --> 01:09:55,210
0,360 360,600 600,870 870,1050 1050,1230
working on actually trying to

2399
01:09:55,240 --> 01:09:56,180
0,300 300,510 510,840
reason about it.|
|

2400
01:09:57,490 --> 01:10:00,940
0,270 270,780 930,2250 2250,2700 3000,3450
Did you [vanish] to figure
你有没有[消失]去弄清楚表演到底是如何结束的？

2401
01:10:00,940 --> 01:10:02,290
0,60 60,570 600,960 960,1050 1050,1350
out how performing it actually

2402
01:10:02,290 --> 01:10:03,850
0,120 120,240 240,600 600,1080 1110,1560
ends up being| or how
|或者它在实践中是如何运作的。

2403
01:10:03,850 --> 01:10:05,180
0,120 120,330 330,390 390,1110
it works in practice.|
|

2404
01:10:06,040 --> 01:10:08,290
0,570 810,930 930,1140 1140,1590 1620,2250
So I think the exact
所以我认为我们现在所拥有的代码并不是您想要运行的代码

2405
01:10:08,290 --> 01:10:08,890
0,150 150,240 240,300 300,420 420,600
code that we have right

2406
01:10:08,890 --> 01:10:09,910
0,210 210,450 450,660 660,870 870,1020
now is not code you'd

2407
01:10:09,910 --> 01:10:12,070
0,150 150,210 210,720 720,1080 1170,2160
want to run| and my,
|而我的，在某种意义上，它应该像木筏一样有表现力，

2408
01:10:12,970 --> 01:10:14,050
0,150 150,180 180,450 450,900 900,1080
in a sense, it ought

2409
01:10:14,050 --> 01:10:14,710
0,60 60,150 150,270 270,390 390,660
to be as {performant -}

2410
01:10:14,710 --> 01:10:15,910
0,150 150,660 660,840 840,930 930,1200
as raft,| sort of is
|在某种程度上，我们并没有真正优化的实施，

2411
01:10:15,910 --> 01:10:17,170
0,270 300,600 600,750 750,960 960,1260
and we don't really have

2412
01:10:17,170 --> 01:10:18,340
0,90 90,480 480,1020 1020,1110 1110,1170
an optimized implementation,| so I
|因此，我实际上根本没有费心去获取它的性能数据，

2413
01:10:18,340 --> 01:10:19,690
0,150 150,360 360,750 750,930 930,1350
haven't actually bothered getting performance

2414
01:10:19,690 --> 01:10:20,650
0,240 240,420 420,480 480,570 570,960
numbers for it at all,|
|

2415
01:10:21,040 --> 01:10:21,780
0,540

2416
01:10:22,200 --> 01:10:23,490
0,240 240,510 510,690 690,1050 1080,1290
it's probably pretty slow, not
它可能相当慢，不是很确定。

2417
01:10:23,490 --> 01:10:24,260
0,120 120,450
really sure.|
|

2418
01:10:29,930 --> 01:10:32,300
0,420 420,600 600,840 1020,1650 1980,2370
Great, thank you,| yeah, even
太好了，谢谢你，|是的，即使我们核实了我的程序，

2419
01:10:32,300 --> 01:10:33,440
0,120 120,210 210,540 540,690 690,1140
if we verify my programs,|
|

2420
01:10:33,440 --> 01:10:34,430
0,120 120,360 360,420 420,570 570,990
I'm sure on this lock
我肯定在这把锁上的某个地方，

2421
01:10:34,430 --> 01:10:37,100
0,630 1200,1650 1650,1830 1830,2040 2040,2670
somewhere,| but let's hear from
|但现在让我们来听听PP2的说法。

2422
01:10:37,680 --> 01:10:39,740
0,630 690,1110 1110,1800
{PP2 -} now.|
|

2423
01:10:51,340 --> 01:10:52,440
0,300 300,540 540,780
Alright, {can,everyone} see?|
好了，大家都能看到了吗？|

2424
01:10:54,150 --> 01:10:56,160
0,450 840,1260 1260,1680 1680,1830 1830,2010
Great.| So, {} we are
太棒了。|因此，我们是[鸽子]礼宾团队，我[]我杰伊·蒂米，

2425
01:10:56,160 --> 01:10:57,840
0,240 240,450 450,780 780,1170 1200,1680
the [pigeon] protocol team, me

2426
01:10:57,840 --> 01:10:59,970
0,720 720,990 990,1170 1170,1500 1650,2130
[] {me,Jay} {Timmy -}, {}|
|

2427
01:10:59,970 --> 01:11:01,200
0,240 240,450 450,870 870,990 990,1230
and we are we present
我们呈现了一个简单的分布式文件系统，

2428
01:11:01,200 --> 01:11:02,520
0,60 60,360 360,720 720,900 900,1320
a simple distributed file system,|
|

2429
01:11:03,120 --> 01:11:04,080
0,180 180,270 270,480 480,570 570,960
and the reason we selected
我们之所以选择分布式文件系统

2430
01:11:04,080 --> 01:11:05,520
0,330 330,690 690,870 870,1290 1290,1440
a distributed file system| is
|用户经常希望以一种真正可访问的方式私下对数据进行排序

2431
01:11:05,520 --> 01:11:06,870
0,270 270,720 720,990 990,1230 1230,1350
that users often times want

2432
01:11:06,870 --> 01:11:08,070
0,60 60,240 240,450 450,1110 1110,1200
to sort data privately in

2433
01:11:08,070 --> 01:11:09,480
0,120 120,330 330,780 780,1080 1110,1410
a really accessible way| without
|如果不考虑使用云公司的影响，

2434
01:11:09,480 --> 01:11:10,530
0,60 60,660 660,750 750,990 990,1050
the implications of using a

2435
01:11:10,530 --> 01:11:11,910
0,240 240,600 600,1080 1080,1170 1170,1380
cloud company,| where you don't
|你不拥有你自己的数据。

2436
01:11:11,910 --> 01:11:12,920
0,120 120,240 240,330 330,690
own your own data.|
|

2437
01:11:13,500 --> 01:11:14,700
0,600 600,750 750,930 930,1020 1020,1200
So we wanted to create
所以我们想要创造一个解决方案，

2438
01:11:14,700 --> 01:11:15,690
0,30 30,420 420,630 630,750 750,990
a solution,| where you self
|您在商用硬件上以容错分布式方式自行托管数据，

2439
01:11:15,690 --> 01:11:17,280
0,210 210,360 360,810 840,1110 1110,1590
host, your data in a

2440
01:11:17,280 --> 01:11:19,200
0,210 210,690 690,1260 1260,1650 1680,1920
fault tolerant distributed manner on

2441
01:11:19,200 --> 01:11:20,280
0,330 330,720
commodity hardware,|
|

2442
01:11:20,690 --> 01:11:21,980
0,360 360,540 540,720 720,1020 1020,1290
and our file system is
我们的文件系统非常类似于Frangipani，

2443
01:11:21,980 --> 01:11:23,960
0,330 330,690 690,900 900,1620 1620,1980
really similar to Frangipani,| except
|只是它用木筏而不是踏板

2444
01:11:23,960 --> 01:11:25,070
0,120 120,180 180,540 540,900 1020,1110
that it uses raft {instead,of}

2445
01:11:25,070 --> 01:11:26,510
0,510 540,840 840,990 990,1200 1200,1440
pedal| and the file system
|并且文件系统位于服务器上，而不是客户端上。

2446
01:11:26,510 --> 01:11:27,710
0,90 90,210 210,270 270,840 840,1200
is on the servers instead

2447
01:11:27,710 --> 01:11:29,020
0,240 240,450 450,1110
of the clients.|
|

2448
01:11:29,420 --> 01:11:30,440
0,210 210,330 330,540 540,600 600,1020
{} In terms of {file,system}
在文件系统参数方面，

2449
01:11:30,440 --> 01:11:31,910
0,540 540,660 660,870 870,1050 1050,1470
parameters,| we also have a
|我们还有一个4096字节的数据块大小

2450
01:11:31,910 --> 01:11:33,530
0,330 330,480 480,1140 1140,1380 1380,1620
{4096 - -} byte block

2451
01:11:33,530 --> 01:11:35,420
0,390 390,540 540,660 660,990 990,1890
size| and a 2 megabyte
|和2兆字节的最大文件大小，

2452
01:11:35,420 --> 01:11:37,700
0,330 330,540 540,1020 1530,1770 1770,2280
maximum file size,| we theoretically
|理论上我们有32G的最大磁盘容量，

2453
01:11:37,700 --> 01:11:39,200
0,120 120,420 420,810 810,1170 1170,1500
have a 32 gigabyte maximum

2454
01:11:39,200 --> 01:11:40,850
0,210 210,900 1080,1440 1440,1590 1590,1650
disk capacity,| however this is
|然而，这实际上受到您的RAM的限制，

2455
01:11:40,850 --> 01:11:42,080
0,330 330,720 720,810 810,960 960,1230
actually constrained by your RAM,|
|

2456
01:11:42,080 --> 01:11:42,680
0,120 120,210 210,270 270,390 390,600
so if you only have
因此，如果您只有8G的RAM，

2457
01:11:42,680 --> 01:11:44,300
0,60 60,420 420,570 570,1080 1110,1620
8 gigabyte of RAM, {}|
|

2458
01:11:44,300 --> 01:11:45,240
0,150 150,240 240,750
you would have,
无论你的系统占用了多少，你都会有剩余的。

2459
01:11:45,440 --> 01:11:47,030
0,390 390,660 660,900 900,1140 1140,1590
however much left over after

2460
01:11:47,030 --> 01:11:48,590
0,270 270,870 930,1230 1230,1440 1440,1560
your, {} after whatever your

2461
01:11:48,590 --> 01:11:49,800
0,270 270,510 510,750
system takes up.|
|

2462
01:11:50,140 --> 01:11:52,030
0,330 330,600 600,1080 1080,1290 1290,1890
And we support as many
我们在合理范围内支持尽可能多的服务器和客户端，

2463
01:11:52,090 --> 01:11:53,140
0,420 420,510 510,840 840,960 960,1050
servers and clients as we

2464
01:11:53,140 --> 01:11:55,150
0,240 240,480 480,1080 1110,1920 1920,2010
can within reason,| obviously the
|显然，您向锁定争用中添加的服务器和客户端越多，

2465
01:11:55,150 --> 01:11:56,020
0,150 150,420 420,510 510,780 780,870
more servers and clients that

2466
01:11:56,020 --> 01:11:57,250
0,120 120,570 570,1020 1050,1140 1140,1230
you add {} to the

2467
01:11:57,250 --> 01:11:58,750
0,300 300,840 840,930 930,1080 1080,1500
locking contention,| there will be
|当您开始一遍又一遍地访问同一文件时，性能将会降低。

2468
01:11:58,960 --> 01:12:00,520
0,600 600,1080 1080,1230 1230,1350 1350,1560
less performance as you start

2469
01:12:00,520 --> 01:12:02,080
0,150 150,570 570,810 840,1170 1170,1560
to access the same file

2470
01:12:02,110 --> 01:12:03,280
0,240 240,360 360,540 540,870
over and over again.|
|

2471
01:12:03,690 --> 01:12:05,430
0,360 360,1200 1290,1440 1440,1650 1650,1740
And, {} in terms of
而且，就性能而言，

2472
01:12:05,430 --> 01:12:06,960
0,630 630,870 870,990 990,1140 1140,1530
performance,| well, we were very
|嗯，我们非常关注可用性和崩溃恢复，

2473
01:12:06,960 --> 01:12:08,880
0,390 390,810 810,1080 1080,1740 1740,1920
heavily focused on availability and

2474
01:12:08,880 --> 01:12:10,620
0,300 300,780 780,1110 1110,1290 1290,1740
crash recovery,| so we didn't,
|所以我们没有，我们没有衡量绩效

2475
01:12:10,980 --> 01:12:12,180
0,120 120,300 300,510 510,990 990,1200
we didn't measure performance| and
|我们认为情况可能相当糟糕，

2476
01:12:12,180 --> 01:12:12,930
0,90 90,210 210,330 330,570 570,750
we think it's probably pretty

2477
01:12:12,930 --> 01:12:14,610
0,300 300,570 570,1020 1110,1530 1530,1680
bad,| because our system is
|因为我们的系统是建立在木筏上的，

2478
01:12:14,610 --> 01:12:15,510
0,180 180,270 270,480 480,600 600,900
built on top of raft,|
|

2479
01:12:15,510 --> 01:12:16,830
0,150 150,420 510,990 990,1200 1200,1320
which is not known to
这并不是已知的系统中性能最好的。

2480
01:12:16,830 --> 01:12:18,180
0,180 180,270 270,600 630,960 960,1350
be the most {performance -}

2481
01:12:18,180 --> 01:12:19,100
0,120 120,810
of systems.|
|

2482
01:12:19,890 --> 01:12:21,780
0,330 330,930 960,1200 1200,1380 1380,1890
So, {} over to Jay.|
所以，轮到杰伊了。|

2483
01:12:22,760 --> 01:12:24,470
0,570 630,990 990,1470 1470,1530 1530,1710
So, again performance is not
所以，再说一次，表现不是我们最重要的东西，

2484
01:12:24,470 --> 01:12:25,400
0,60 60,360 360,660 660,810 810,930
the biggest thing that we

2485
01:12:25,400 --> 01:12:26,570
0,300 300,600 600,720 720,900 900,1170
have,| but we do have
|但我们确实有非常非常强大的一致性保证，

2486
01:12:26,570 --> 01:12:28,610
0,270 270,510 510,810 810,1290 1290,2040
very very strong consistency guarantees,|
|

2487
01:12:28,670 --> 01:12:29,960
0,330 330,390 390,840 840,960 960,1290
{} in particular we enforce
特别是，我们强制执行POSIX一致性，

2488
01:12:29,960 --> 01:12:31,310
0,390 390,900 900,1080 1080,1170 1170,1350
POSIX consistency,| which is a
|这是一种强一致性的形式，

2489
01:12:31,310 --> 01:12:32,810
0,270 270,510 540,810 810,1410 1410,1500
form of strong consistency,| we
|我们通常在本地文件系统上看到，

2490
01:12:32,810 --> 01:12:34,070
0,330 330,600 600,750 750,1050 1050,1260
usually see on local file

2491
01:12:34,070 --> 01:12:36,110
0,540 750,1380 1410,1590 1590,1950 1950,2040
systems,| so we enforce the
|所以我们实施了不变量，在一个文件之后，

2492
01:12:36,110 --> 01:12:37,340
0,420 420,570 570,840 840,930 930,1230
invariant that after a file,|
|

2493
01:12:37,340 --> 01:12:38,150
0,180 180,390 390,540 540,720 720,810
right after you do a
在您成功完成文件写入之后，

2494
01:12:38,150 --> 01:12:40,280
0,450 450,750 750,1020 1380,1740 1740,2130
successful file write,| any read
|从任何地方读取您先前写入的字节，

2495
01:12:40,280 --> 01:12:41,540
0,180 180,330 330,720 720,900 900,1260
of your previously written bytes

2496
01:12:41,540 --> 01:12:42,740
0,180 180,750 750,870 870,990 990,1200
from anywhere,| or will turn
|或者将转换由该先前写入指定的数据，

2497
01:12:42,740 --> 01:12:43,850
0,60 60,300 300,810 810,930 930,1110
the data specified by that

2498
01:12:43,850 --> 01:12:46,490
0,360 360,690 870,2130 2130,2400 2400,2640
previous write,| similarly any new
|类似地，对该数据的任何新写入都将导致该数据的可视重写，

2499
01:12:46,490 --> 01:12:48,170
0,300 300,600 600,780 780,1350 1380,1680
writes over that data will

2500
01:12:48,170 --> 01:12:49,730
0,420 420,720 720,1140 1140,1350 1350,1560
result in visible {overwrites -}

2501
01:12:49,730 --> 01:12:50,440
0,60 60,210 210,630
of that data,|
|

2502
01:12:50,610 --> 01:12:51,660
0,240 240,300 300,720 720,810 810,1050
from the perspective of other
从其他读者的角度来看。

2503
01:12:51,660 --> 01:12:52,420
0,510
readers.|
|

2504
01:12:52,650 --> 01:12:54,210
0,720 870,1020 1020,1200 1200,1260 1260,1560
So in order to achieve
因此，为了实现这一点，

2505
01:12:54,210 --> 01:12:54,930
0,150 150,270 270,360 360,450 450,720
this,| we have a data
|我们在这种数据块层中内置了数据模式日志，

2506
01:12:54,930 --> 01:12:56,100
0,240 240,570 570,690 690,840 840,1170
mode journal that is built

2507
01:12:56,100 --> 01:12:57,030
0,180 180,330 330,540 540,630 630,930
into this sort of block

2508
01:12:57,030 --> 01:12:58,710
0,420 570,930 930,1080 1080,1350 1380,1680
layer,| {} that is again
|它再次与RAFT一起分发并复制

2509
01:12:58,710 --> 01:13:00,660
0,450 450,600 600,1020 1170,1320 1320,1950
distributed with raft and replicated|
|

2510
01:13:00,840 --> 01:13:02,340
0,510 540,780 780,840 840,1380 1380,1500
and which is effectively a
并且其实际上是预写日志，

2511
01:13:02,340 --> 01:13:03,510
0,180 180,390 390,660 660,750 750,1170
{write-ahead -} log,| that guarantees
|这保证了在存在崩溃的情况下写入强语义的原子性，

2512
01:13:03,510 --> 01:13:04,980
0,120 120,570 570,660 660,1110 1140,1470
the atomicity of writes strong

2513
01:13:04,980 --> 01:13:05,880
0,420 420,480 480,570 570,810 810,900
semantics in the presence of

2514
01:13:05,880 --> 01:13:07,140
0,300 300,750 810,960 960,1140 1140,1260
{crashes -},| the same as
|和木筏差不多。

2515
01:13:07,140 --> 01:13:09,060
0,390 390,540 540,1020 1260,1620 1620,1920
raft pretty much| and also
|以及我们上面提供的一致性模型。

2516
01:13:09,060 --> 01:13:10,650
0,690 690,1140 1140,1350 1350,1500 1500,1590
the consistency model that we

2517
01:13:10,650 --> 01:13:11,520
0,300 300,690
offer above.|
|

2518
01:13:11,660 --> 01:13:13,280
0,450 450,780 780,1320 1320,1470 1470,1620
So servers also in order
因此，服务器也为了帮助实现这一点，

2519
01:13:13,280 --> 01:13:14,060
0,90 90,240 240,360 360,600 600,780
to help with this,| we
|我们发布分布式锁定，这样我们就可以拥有这个非常原始的块缓存，

2520
01:13:14,060 --> 01:13:15,320
0,240 240,660 660,1020 1020,1170 1170,1260
issue distributed locking, so we

2521
01:13:15,320 --> 01:13:16,310
0,90 90,270 270,420 420,660 660,990
can have this very primitive

2522
01:13:16,310 --> 01:13:17,450
0,240 240,720 750,930 930,1020 1020,1140
block cache,| as you would
|正如您将在本地文件系统中看到的那样，

2523
01:13:17,450 --> 01:13:18,350
0,150 150,240 240,330 330,660 660,900
see in a local file

2524
01:13:18,350 --> 01:13:20,420
0,450 750,1080 1080,1740 1830,1950 1950,2070
system,| and also we have,
|我们也有，我们有租约，以确保有相互排斥的访问所有这些区块。

2525
01:13:20,420 --> 01:13:21,470
0,360 360,690 690,780 780,900 900,1050
we've leases to make sure

2526
01:13:21,470 --> 01:13:22,730
0,120 120,300 300,600 600,960 960,1260
that there's mutually exclusive access

2527
01:13:22,730 --> 01:13:23,690
0,120 120,240 240,330 330,450 450,960
to all of these blocks.|
|

2528
01:13:27,520 --> 01:13:28,660
0,330 330,600 600,780 780,990 990,1140
Right, so to allow our
对，所以为了允许我们的客户使用我们的文件系统，

2529
01:13:28,660 --> 01:13:29,830
0,510 510,630 630,840 840,960 960,1170
clients to use our file

2530
01:13:29,830 --> 01:13:31,480
0,360 360,510 510,930 930,1200 1200,1650
system,| we created a POSIX
|我们创建了一个类似POSIX的界面，

2531
01:13:31,480 --> 01:13:32,920
0,150 150,660 660,900 900,1260 1260,1440
like interface,| where users can
|其中用户可以与文件交互，

2532
01:13:32,920 --> 01:13:34,870
0,420 420,570 570,1080 1320,1680 1680,1950
interact with files,| we mainly
|我们主要有打开、关闭、读、写、

2533
01:13:34,870 --> 01:13:36,520
0,180 180,420 420,990 990,1290 1290,1650
have four functions open, close,

2534
01:13:36,520 --> 01:13:38,470
0,210 210,780 930,1380 1380,1620 1620,1950
read, write,| open and close
|OPEN和CLOSE很容易解释，

2535
01:13:38,470 --> 01:13:40,840
0,300 300,840 1080,1770 1770,1890 1890,2370
are pretty explanatory,| they just
|他们只是打开和关闭我们文件系统上的文件描述符，

2536
01:13:40,870 --> 01:13:42,370
0,330 330,450 450,720 720,900 900,1500
open and close file descriptors

2537
01:13:42,370 --> 01:13:43,560
0,120 120,240 240,420 420,990
on our file system,|
|

2538
01:13:44,020 --> 01:13:45,460
0,540 540,870 870,1050 1050,1230 1230,1440
{} read, it just takes
读取，它只需要一个文件描述符

2539
01:13:45,460 --> 01:13:47,110
0,60 60,240 240,900 900,1230 1230,1650
a file descriptor| and {}
|并在当前文件位置读取固定数量的字节，

2540
01:13:47,260 --> 01:13:48,160
0,270 270,330 330,600 600,840 840,900
read a fixed number of

2541
01:13:48,160 --> 01:13:49,270
0,390 390,540 540,600 600,900 900,1110
bytes at the current file

2542
01:13:49,270 --> 01:13:51,190
0,630 990,1350 1350,1590 1590,1830 1830,1920
position,| write also takes a
|写还获取文件描述符，并且读刷新是，

2543
01:13:51,190 --> 01:13:53,080
0,180 180,780 780,1020 1020,1410 1440,1890
file descriptor and read {}

2544
01:13:53,140 --> 01:13:55,300
0,510 510,1050 1200,1440 1440,1800 1830,2160
flush is,| {} sorry write
|对不起，写入操作需要文件描述符

2545
01:13:55,300 --> 01:13:58,090
0,270 270,1260 1650,2160 2160,2670 2670,2790
takes a file descriptor| and
|并只将数据写入文件[]，

2546
01:13:58,090 --> 01:13:59,800
0,240 240,660 660,1110 1140,1500 1500,1710
just writes the data to

2547
01:13:59,800 --> 01:14:03,160
0,360 450,1020 1050,1860 1980,2670 2910,3360
the file [],| but it's
|但它的方式与正常的POSIX写入方式不同，

2548
01:14:03,160 --> 01:14:04,060
0,150 150,240 240,570 570,720 720,900
in a different way than

2549
01:14:04,060 --> 01:14:06,610
0,570 570,1050 1050,1320 1320,2040 2130,2550
{a,normal} POSIX write,| because {
|因为不是刷新文件的缓冲副本，

2550
01:14:06,610 --> 01:14:08,770
0,570 660,1200 1200,1680 1680,1830 1830,2160
-} instead flushes the buffer

2551
01:14:08,770 --> 01:14:10,030
0,630 660,840 840,900 900,1170 1170,1260
copy of the file,| and
|然后在上面附加新的数据，

2552
01:14:10,030 --> 01:14:11,200
0,180 180,660 660,780 780,930 930,1170
then appends the new data

2553
01:14:11,200 --> 01:14:13,330
0,150 150,600 1110,1620 1650,2010 2010,2130
on this,| so instead of
|因此，与正常的POSIX写入不同，

2554
01:14:13,330 --> 01:14:14,440
0,30 30,300 300,660 660,930 930,1110
a normal POSIX write,| where
|其中我们只需使用缓冲区写入[]描述符

2555
01:14:14,440 --> 01:14:15,280
0,120 120,330 330,600 600,720 720,840
we just write to a

2556
01:14:15,280 --> 01:14:16,540
0,510 510,1200
[] descriptor

2557
01:14:16,970 --> 01:14:18,110
0,210 210,330 330,780 780,1050 1050,1140
with a buffer| and the
|而要写入的字节数，正如我刚才所说的那样。

2558
01:14:18,110 --> 01:14:18,980
0,240 240,300 300,540 540,660 660,870
number of bytes to write

2559
01:14:18,980 --> 01:14:20,180
0,120 120,570 690,930 930,1020 1020,1200
it does, what I just

2560
01:14:20,180 --> 01:14:21,530
0,210 210,660 840,1140 1140,1230 1230,1350
said instead.| And we have
|我们有一个演示来演示客户端与系统的交互。

2561
01:14:21,530 --> 01:14:23,510
0,90 90,450 450,840 870,1500 1530,1980
a demo to represent {}

2562
01:14:23,540 --> 01:14:25,160
0,480 480,990 990,1110 1110,1230 1230,1620
clients interacting with the system.|
|

2563
01:14:28,290 --> 01:14:28,980
0,270 270,360 360,480 480,660 660,690
So this is just a
这只是我们的文件系统的快速演示

2564
01:14:28,980 --> 01:14:30,120
0,210 210,720 720,780 780,900 900,1140
quick demonstration of our file

2565
01:14:30,120 --> 01:14:31,890
0,330 330,600 600,810 810,1170 1200,1770
system| being run both serially
|在串联和并行运行的情况下，

2566
01:14:31,890 --> 01:14:33,780
0,210 210,780 780,1200 1320,1770 1770,1890
and concurrently,| so what's going
|接下来会发生的是一号游戏机

2567
01:14:33,780 --> 01:14:35,130
0,60 60,300 300,390 390,810 810,1350
to happen is console one|
|

2568
01:14:35,130 --> 01:14:36,360
0,60 60,150 150,300 300,660 810,1230
or I should say left
或者我应该说左控制台

2569
01:14:36,360 --> 01:14:38,160
0,540 570,1080 1110,1440 1440,1560 1560,1800
console| is going to open
|将打开一个名为TT的文件，只是测试一下，

2570
01:14:38,160 --> 01:14:39,780
0,150 150,210 210,510 510,900 990,1620
up a file called tt,

2571
01:14:39,780 --> 01:14:41,260
0,300 510,960 960,1260
just testing thing,|
|

2572
01:14:41,420 --> 01:14:42,440
0,750

2573
01:14:42,670 --> 01:14:43,600
0,180 180,390 390,540 540,720 720,930
it's going to write something
它会在文件中写入一些内容，

2574
01:14:43,600 --> 01:14:44,470
0,90 90,180 180,630 630,780 780,870
to the file,| and then
|然后右边的控制台随后将读取它，

2575
01:14:44,470 --> 01:14:45,310
0,60 60,390 390,510 510,600 600,840
the console on the right

2576
01:14:45,310 --> 01:14:46,000
0,90 90,240 240,330 330,540 540,690
is going to read from

2577
01:14:46,000 --> 01:14:48,070
0,150 150,810 1020,1380 1380,1470 1470,2070
it afterwards,| per the consistency
|根据一致性模型，

2578
01:14:48,070 --> 01:14:49,150
0,420 450,630 630,810 810,990 990,1080
model,| they should see the
|他们应该看到与左侧控制台所写的内容相同的内容

2579
01:14:49,150 --> 01:14:50,800
0,240 240,660 660,1230 1260,1410 1410,1650
same thing as the left

2580
01:14:50,800 --> 01:14:52,940
0,510 510,1020 1020,1260 1260,1890
console wrote| and indeed
|事实上，一分钟后，我们就看到了这一点。

2581
01:14:53,670 --> 01:14:54,820
0,360 360,420 420,870
after a minute,

2582
01:14:56,730 --> 01:14:58,680
0,510 510,660 660,900 1110,1410 1590,1950
we see that.| Okay, so
|好的，接下来会发生的事情是，

2583
01:14:58,680 --> 01:14:59,400
0,180 180,360 360,480 480,600 600,720
the next thing that's going

2584
01:14:59,400 --> 01:15:01,290
0,60 60,420 450,990 1170,1530 1530,1890
to happen is,| both console
|控制台1和控制台2都将尝试同时刷新该文件的本地副本，

2585
01:15:01,290 --> 01:15:02,460
0,300 300,540 540,840 840,1080 1080,1170
one and console two are

2586
01:15:02,460 --> 01:15:03,510
0,210 210,270 270,420 420,540 540,1050
going to try to flush

2587
01:15:03,510 --> 01:15:04,950
0,360 360,750 750,1140 1140,1230 1230,1440
their local copies of this

2588
01:15:04,950 --> 01:15:06,870
0,360 360,570 570,660 660,1170 1410,1920
file at the same time,|
|

2589
01:15:06,990 --> 01:15:08,250
0,270 270,390 390,720 720,810 810,1260
this is not a traditional
这不是传统的POSIX写入，

2590
01:15:08,250 --> 01:15:10,140
0,420 420,720 930,1140 1140,1590 1590,1890
POSIX write,| they're both taking
|他们都拿着他们拥有的文件的副本

2591
01:15:10,140 --> 01:15:11,040
0,120 120,480 480,540 540,630 630,900
the copies of the file

2592
01:15:11,040 --> 01:15:12,090
0,90 90,210 210,690 690,810 810,1050
that they have| and trying
|并试图同时将它们放到磁盘上，

2593
01:15:12,090 --> 01:15:12,990
0,60 60,300 300,450 450,660 660,900
to put them onto disk

2594
01:15:12,990 --> 01:15:13,920
0,60 60,150 150,330 330,720
at the same time,|
|

2595
01:15:14,140 --> 01:15:14,950
0,270 270,360 360,570 570,630 630,810
so it's sort of like
所以这有点像从偏移量零开始的两次写入，

2596
01:15:14,950 --> 01:15:16,810
0,270 270,720 720,960 960,1380 1380,1860
two writes from offset zero,|
|

2597
01:15:17,140 --> 01:15:17,980
0,360 360,420 420,570 570,660 660,840
one of these is going
他们中的一个会赢，

2598
01:15:17,980 --> 01:15:18,860
0,150 150,570
to win,|
|

2599
01:15:19,060 --> 01:15:20,020
0,150 150,240 240,570 600,870 870,960
and we can look at
我们可以查看左侧控制台上的日志，

2600
01:15:20,020 --> 01:15:21,130
0,120 120,570 570,750 750,840 840,1110
the log on the left

2601
01:15:21,130 --> 01:15:22,390
0,420 420,570 570,660 660,1080 1080,1260
console,| as it commits| and
|因为它承诺|实际上，过了一会儿，你会看到，

2602
01:15:22,390 --> 01:15:23,620
0,330 330,900
actually see,

2603
01:15:23,950 --> 01:15:25,100
0,390 390,450 450,870
after a moment,|
|

2604
01:15:25,520 --> 01:15:28,070
0,390 390,720 720,1290 1290,1710 1710,2550
that both transactions run concurrently,|
两个事务同时运行，|

2605
01:15:28,160 --> 01:15:29,060
0,120 120,330 330,480 480,570 570,900
they both take up different
它们都占据了原木的不同部分，

2606
01:15:29,060 --> 01:15:30,260
0,210 210,300 300,420 420,900 990,1200
parts of the log,| but
|但归根结底，

2607
01:15:30,260 --> 01:15:30,800
0,60 60,210 210,390 390,450 450,540
at the end of the

2608
01:15:30,800 --> 01:15:33,440
0,450 570,1050 1440,1800 1800,2100 2100,2640
day,| the left console transaction
|左侧控制台事务将获胜，

2609
01:15:33,440 --> 01:15:35,120
0,60 60,270 270,390 390,690 1080,1680
is going to win,| so
|因此，它完全是原子的，一切都是有效的。

2610
01:15:35,210 --> 01:15:36,950
0,150 150,270 270,660 660,1230 1380,1740
it was completely atomic everything

2611
01:15:36,950 --> 01:15:37,580
0,420
works.|
|

2612
01:15:41,450 --> 01:15:42,260
0,270 270,510
So this.|
所以这就是。|

2613
01:15:48,950 --> 01:15:49,970
0,90 90,240 240,360 360,600 600,1020
I think you got muted.|
我想你被静音了。|

2614
01:15:51,110 --> 01:15:52,820
0,450 450,570 570,1050 1440,1590 1590,1710
Sorry, I muted,| due to
抱歉，我静音了，|由于时间的原因，还有更多的，

2615
01:15:52,820 --> 01:15:53,960
0,330 330,480 480,540 540,990 1020,1140
time there are more,| there
|我们可以向我们的文件系统添加一些限制和功能，

2616
01:15:53,960 --> 01:15:55,700
0,60 60,330 330,1050 1050,1440 1440,1740
are some limitations and features

2617
01:15:55,700 --> 01:15:56,480
0,90 90,210 210,390 390,480 480,780
we can add to {our,file}

2618
01:15:56,480 --> 01:15:58,520
0,330 540,1110 1200,1710 1710,1830 1830,2040
system,| so firstly, we only
|首先，我们只有一个根目录，

2619
01:15:58,520 --> 01:16:00,440
0,360 390,660 660,1200 1200,1410 1410,1920
have {} one root directory,|
|

2620
01:16:00,440 --> 01:16:01,640
0,180 180,480 480,750 750,840 840,1200
so adding more will definitely
所以增加更多肯定会是一个加分，

2621
01:16:01,640 --> 01:16:04,160
0,180 180,300 300,960 1350,2130 2130,2520
be a plus,| next we
|接下来，我们只应将数据块持久存储到磁盘而不是RAM，

2622
01:16:04,160 --> 01:16:06,860
0,600 1050,1410 1410,1830 1830,2400 2520,2700
only, should persist blocks to

2623
01:16:06,860 --> 01:16:08,480
0,450 480,840 840,1080 1080,1380 1380,1620
disk rather than RAM,| because
|因为这就是我们目前正在做的事情，

2624
01:16:08,480 --> 01:16:09,770
0,180 180,390 390,480 480,840 840,1290
that's what we're currently doing,|
|

2625
01:16:09,890 --> 01:16:11,480
0,480 480,570 570,720 720,990 990,1590
but we should also consider
但我们也应该考虑到我们正在做的事情，

2626
01:16:11,510 --> 01:16:13,190
0,450 450,810 1110,1290 1290,1410 1410,1680
{} that what we're doing,|
|

2627
01:16:13,190 --> 01:16:14,120
0,180 180,270 270,480 480,570 570,930
has a lot of writes,|
写了很多东西，|

2628
01:16:14,120 --> 01:16:15,170
0,240 240,330 330,540 540,720 720,1050
so it could be pretty
所以情况可能会很糟糕，

2629
01:16:15,170 --> 01:16:16,400
0,510 510,630 630,750 750,990 990,1230
bad,| if we just keep
|如果我们继续写下去，

2630
01:16:16,400 --> 01:16:17,080
0,540
writing,|
|

2631
01:16:17,310 --> 01:16:18,270
0,150 150,330 330,540 540,750 750,960
{doing -} have a lot
仅一次操作就有大量写入，

2632
01:16:18,270 --> 01:16:19,110
0,90 90,360 360,480 480,660 660,840
of writes for just one

2633
01:16:19,110 --> 01:16:21,150
0,630 840,1080 1080,1500 1500,1800 1800,2040
operation,| we also only have
|我们也只有直接信息节点块，而不是直接和间接信息节点，

2634
01:16:21,150 --> 01:16:22,530
0,390 390,450 450,660 660,1080 1080,1380
direct {inode -} blocks rather

2635
01:16:22,530 --> 01:16:25,200
0,870 1110,1590 1590,1950 1950,2250 2250,2670
than having direct and indirect

2636
01:16:25,200 --> 01:16:26,340
0,90 90,660 660,930 930,1050 1050,1140
{inodes -},| so that would
|所以这将是一个加号，

2637
01:16:26,340 --> 01:16:27,120
0,90 90,180 180,480 480,570 570,780
be a plus to add

2638
01:16:27,120 --> 01:16:29,670
0,390 390,570 570,1290 1350,2100 2340,2550
those,| and secondly, {} there
|其次，应该有更好的方式让客户端与此文件系统交互，

2639
01:16:29,670 --> 01:16:30,450
0,150 150,270 270,330 330,600 600,780
should be a better way

2640
01:16:30,450 --> 01:16:32,160
0,120 120,570 570,660 660,1260 1500,1710
for clients to interact with

2641
01:16:32,160 --> 01:16:33,150
0,150 150,330 330,690 690,840 840,990
this file system,| so there
|所以可能有一层熔断层

2642
01:16:33,150 --> 01:16:34,080
0,120 120,210 210,330 330,630 630,930
could be a fuse layer|
|

2643
01:16:34,080 --> 01:16:35,100
0,210 210,330 330,510 510,810 810,1020
or they could just be
或者，它们可能只是总体上更好的积极合规性。

2644
01:16:35,100 --> 01:16:36,660
0,270 270,630 630,1080 1080,1170 1170,1560
better positive compliance in general.|
|

2645
01:16:38,700 --> 01:16:40,280
0,510 510,720 720,1350
Concludes our presentation.|
我们的演讲结束了。|

2646
01:16:48,300 --> 01:16:48,960
0,210 210,270 270,390 390,450 450,660
Do you want to talk
你想谈谈你是如何测试这个的吗？

2647
01:16:48,960 --> 01:16:49,740
0,30 30,210 210,360 360,600 600,780
a little bit about how

2648
01:16:49,740 --> 01:16:51,120
0,150 150,540 540,1020
you tested this?|
|

2649
01:16:52,290 --> 01:16:53,760
0,390 390,600 600,780 780,1050 1050,1470
Sure, so we had a
当然，所以我们在你的[推荐]下进行了一次很不错的，

2650
01:16:53,760 --> 01:16:55,470
0,570 600,930 930,1050 1050,1650 1650,1710
pretty at your [recommendation],| we
|我们有一套相当广泛的测试，

2651
01:16:55,470 --> 01:16:56,340
0,90 90,120 120,360 360,720 720,870
had a pretty broad set

2652
01:16:56,340 --> 01:16:57,480
0,60 60,480 480,660 660,960 960,1140
of tests,| we had so
|因此，我们必须开始每个组件，

2653
01:16:57,480 --> 01:16:58,770
0,90 90,390 390,660 660,1170 1170,1290
to begin each component,| so
|所以每个人都知道这里的块层，

2654
01:16:58,770 --> 01:16:59,970
0,510 570,690 690,780 780,900 900,1200
each you know the block

2655
01:16:59,970 --> 01:17:01,740
0,480 510,720 720,900 900,1380 1380,1770
layer right here,| individual {raft,key}
|单独的RAW键值，

2656
01:17:01,740 --> 01:17:03,150
0,480 480,570 570,780 780,870 870,1410
values,| we had the journal|
|我们有那本日记|

2657
01:17:03,240 --> 01:17:04,050
0,210 210,330 330,600 600,660 660,810
and we had all these
我们拥有了所有这些东西，

2658
01:17:04,050 --> 01:17:05,730
0,330 360,570 570,930 930,1470 1470,1680
things,| we basically mocked every
|我们基本上嘲笑了下面的每一层，

2659
01:17:05,730 --> 01:17:07,290
0,390 390,990 1020,1260 1260,1470 1470,1560
layer underneath,| each layer we
|我们正在测试和测试的每一层

2660
01:17:07,290 --> 01:17:09,600
0,120 120,570 570,870 870,2130 2130,2310
were testing and tested| did
|做了一些单元测试，

2661
01:17:09,600 --> 01:17:10,980
0,180 180,390 570,930 930,1290 1290,1380
sort of unit testing,| you
|你不能把它叫做单元测试，一旦你达到了足够高的程度，

2662
01:17:10,980 --> 01:17:11,700
0,180 180,300 300,450 450,540 540,720
can't really call it unit

2663
01:17:11,700 --> 01:17:12,450
0,270 270,420 420,480 480,600 600,750
testing, once you get high

2664
01:17:12,450 --> 01:17:12,980
0,420
enough,|
|

2665
01:17:13,160 --> 01:17:15,350
0,660 660,1200 1200,1470 1470,1680 1680,2190
{} because you're so reliant
因为你太依赖较低层次的正确性了，

2666
01:17:15,350 --> 01:17:16,670
0,90 90,330 330,690 690,870 870,1320
on lower layers being correct,|
|

2667
01:17:16,670 --> 01:17:18,320
0,300 660,1290 1290,1410 1410,1470 1470,1650
but we did as best
但我们尽了最大努力，

2668
01:17:18,320 --> 01:17:19,070
0,90 90,300 300,450 450,660 660,750
we could,| from there we
|从那里我们进行了集成测试

2669
01:17:19,070 --> 01:17:21,140
0,180 180,630 630,1140 1140,1860 1890,2070
did integration testing| and {you,know}
|你知道，写出了一组分区，

2670
01:17:21,140 --> 01:17:22,010
0,390 390,570 570,660 660,810 810,870
wrote out a set of

2671
01:17:22,010 --> 01:17:23,600
0,540 540,810 810,930 930,1140 1140,1590
partitions,| one of those partitions
|其中一个分区就是你刚才看到的，

2672
01:17:23,600 --> 01:17:24,200
0,60 60,270 270,330 330,510 510,600
is sort of what you

2673
01:17:24,200 --> 01:17:25,670
0,210 210,660 810,990 990,1170 1170,1470
just saw,| the most interesting
|其中最有趣的是，

2674
01:17:25,670 --> 01:17:26,600
0,120 120,420 420,600 600,720 720,930
of them,| there were five
|他们有五个人，

2675
01:17:26,600 --> 01:17:27,320
0,120 120,330 330,450 450,570 570,720
of them,| you can see
|你可以在我们的Git库中看到它们，

2676
01:17:27,320 --> 01:17:29,060
0,120 120,210 210,510 720,960 960,1740
them in our git repository,|
|

2677
01:17:29,360 --> 01:17:30,710
0,300 300,390 390,510 510,1140 1170,1350
and then we also, to
然后我们也，在多大程度上，我们可以，

2678
01:17:30,710 --> 01:17:31,940
0,270 270,570 570,690 690,1050 1050,1230
what degree, we could,| so
|所以这并不一定完全奏效，

2679
01:17:31,940 --> 01:17:33,860
0,210 210,570 840,1380 1380,1740 1740,1920
this didn't necessarily entirely work,|
|

2680
01:17:33,860 --> 01:17:34,820
0,240 240,570 570,660 660,780 780,960
just because of some of
只是因为我们有一些时间限制，

2681
01:17:34,820 --> 01:17:35,720
0,90 90,270 270,690 690,810 810,900
the time limitations that we

2682
01:17:35,720 --> 01:17:37,640
0,240 240,570 750,1110 1110,1470 1470,1920
had,| but we also attempted
|但我们也试图做一些压力测试，

2683
01:17:37,640 --> 01:17:38,630
0,60 60,150 150,300 300,510 510,990
to do some stress testing,|
|

2684
01:17:38,660 --> 01:17:40,220
0,450 450,810 810,990 990,1170 1170,1560
obviously performance numbers aren't great,|
显然，业绩数据并不是很好，|

2685
01:17:40,430 --> 01:17:41,600
0,390 390,570 570,840 840,1110 1110,1170
because it's not supposed to
因为这不应该是很棒的，

2686
01:17:41,600 --> 01:17:42,720
0,60 60,420 420,810
be great,| but,
|但是，尽我们所能，

2687
01:17:43,190 --> 01:17:43,970
0,90 90,300 300,360 360,630 630,780
the best we could,| so
|因此，我们非常确定这至少是在这里得到证实的。

2688
01:17:43,970 --> 01:17:44,960
0,150 150,330 330,510 510,660 660,990
we're pretty sure this is

2689
01:17:44,960 --> 01:17:46,490
0,90 90,240 240,720 720,1260 1260,1530
at least correct verified here.|
|

2690
01:18:02,790 --> 01:18:03,930
0,300 300,600 600,780 780,930 930,1140
One interesting thing is that
一件有趣的事情是，您基本上是在追求POSIX所需的稍微更强的一致性属性，

2691
01:18:03,930 --> 01:18:05,220
0,330 330,630 630,960 960,1110 1110,1290
you're basically shooting for actually

2692
01:18:05,220 --> 01:18:07,800
0,420 420,1200 1260,1740 1740,2190 2190,2580
slightly stronger {} consistency property

2693
01:18:07,800 --> 01:18:09,750
0,390 390,630 630,750 750,1290 1710,1950
that POSIX are required,| just
|只有两个收益写入到一个文件中，

2694
01:18:09,750 --> 01:18:12,150
0,570 1020,2010 2010,2190 2190,2340 2340,2400
two proceeds write into a

2695
01:18:12,150 --> 01:18:13,860
0,330 330,930 930,1320 1320,1530 1530,1710
single file,| there's actually not
|实际上并没有太多，

2696
01:18:13,860 --> 01:18:15,480
0,450 480,990 990,1110 1110,1350 1350,1620
much,| actually the write []
|实际上，我们必须要写的是[]。

2697
01:18:15,480 --> 01:18:16,710
0,60 60,240 240,900 930,1140 1140,1230
we have to have to

2698
01:18:16,710 --> 01:18:20,100
0,360 1170,2130 2160,2670 2670,3060 3060,3390
do.| Yes, that was kind
|是的，那是一种意外，

2699
01:18:20,100 --> 01:18:22,320
0,150 150,1050 1080,1500 1530,1740 1740,2220
of accidental,| but we were,|
|但我们确实是，|

2700
01:18:22,500 --> 01:18:24,060
0,210 210,540 570,900 900,990 990,1560
so it's kind of stronger.|
所以它的力量更强了。|

2701
01:18:24,240 --> 01:18:25,800
0,570 570,660 660,810 810,1350 1350,1560
Yeah.| It was accidental, but
嗯。|这是意外，但它确实发生了，

2702
01:18:25,800 --> 01:18:26,880
0,270 270,750 750,930 930,990 990,1080
it happened,| so we were
|所以我们就像是酷，它起作用了。

2703
01:18:26,880 --> 01:18:29,580
0,330 330,780 1020,1200 1200,1800
like cool, it worked.|
|

2704
01:18:30,480 --> 01:18:31,470
0,240 240,600 600,600 600,840 840,990
The server, I mean I
服务器，我的意思是，我认为发生的一部分是，

2705
01:18:31,470 --> 01:18:32,610
0,300 300,450 450,780 780,990 990,1140
think part of what sort

2706
01:18:32,610 --> 01:18:33,450
0,60 60,450 450,600 600,720 720,840
of happened was,| that we
|我们向你们保证，

2707
01:18:33,450 --> 01:18:35,700
0,810 810,1200 1200,1320 1320,1920 1920,2250
guarantee we,| I positively guarantees
|我肯定我说过的话，

2708
01:18:35,700 --> 01:18:36,480
0,60 60,270 270,510 510,660 660,780
I talked about,| but we
|但我们也保证块写入都是原子的，

2709
01:18:36,480 --> 01:18:37,470
0,270 270,420 420,480 480,840 840,990
also make the guarantee that

2710
01:18:37,470 --> 01:18:38,340
0,90 90,420 420,600 600,720 720,870
the block writes are all

2711
01:18:38,340 --> 01:18:39,390
0,390 420,570 570,660 660,840 840,1050
atomic,| and I think that's
|我认为这就是为什么我们会得到这种更强的一致性，

2712
01:18:39,390 --> 01:18:41,010
0,630 870,1140 1140,1320 1320,1440 1440,1620
why we get this sort

2713
01:18:41,010 --> 01:18:43,200
0,60 60,930 1170,1890 1890,2130 2130,2190
of stronger consistency,| because of
|因为日记这件事，

2714
01:18:43,200 --> 01:18:44,550
0,90 90,420 450,870 870,1050 1050,1350
the whole journal thing,| yes,
|是的，你可以让你的写作被覆盖，

2715
01:18:44,550 --> 01:18:45,600
0,150 150,330 330,480 480,780 780,1050
you could get your write

2716
01:18:45,600 --> 01:18:46,530
0,450 450,540 540,630 630,750 750,930
overwritten,| if you do at
|如果你同时这么做，

2717
01:18:46,530 --> 01:18:47,250
0,180 180,330 330,540 540,630 630,720
the same time,| but it's
|但它将永远是干净的。

2718
01:18:47,250 --> 01:18:48,090
0,210 210,330 330,390 390,450 450,840
always going to be clean.|
|

2719
01:18:51,740 --> 01:18:53,150
0,150 150,270 270,360 360,750 750,1410
If you have aggressive caching,|
如果您拥有主动缓存，|

2720
01:18:53,150 --> 01:18:54,410
0,270 270,450 450,720 720,1020 1080,1260
you might run in and
您可能会遇到问题，而不会立即写入日志，

2721
01:18:54,410 --> 01:18:56,030
0,180 180,390 390,840 840,1110 1110,1620
don't write immediately to the

2722
01:18:56,600 --> 01:18:58,070
0,480 480,690 690,780 780,1260 1260,1470
log,| then you might get
|那么你可能会得到不同的行为。

2723
01:18:58,070 --> 01:18:59,740
0,480 480,1050
different behavior.|
|

2724
01:19:00,370 --> 01:19:01,000
0,210 210,270 270,390 390,480 480,630
This is, why we don't
这就是为什么我们不积极地缓存，

2725
01:19:01,000 --> 01:19:02,860
0,450 450,840 870,1290 1290,1380 1380,1860
aggressively cache,| we have a
|我们有一个大小为1的数据块缓存。

2726
01:19:02,890 --> 01:19:04,240
0,300 300,510 510,630 630,870 870,1350
block cache of size one.|
|

2727
01:19:10,890 --> 01:19:12,300
0,360 360,600 600,780 780,990 990,1410
Awesome, thank you, very cool,|
太棒了，谢谢，很酷，|

2728
01:19:12,660 --> 01:19:14,310
0,270 270,540 540,840 840,1380 1380,1650
alright, our last group is
好了，我们的最后一组正在展示一个游戏框架，

2729
01:19:14,310 --> 01:19:16,260
0,570 570,690 690,1020 1020,1560
presenting a game framework,|
|

2730
01:19:16,430 --> 01:19:17,450
0,300 300,390 390,690 780,960 960,1020
whenever you're ready, take it
只要你准备好了，就把它拿走。

2731
01:19:17,450 --> 01:19:18,160
0,330
away.|
|

2732
01:19:21,660 --> 01:19:23,280
0,300 360,780 870,1080 1080,1290 1290,1620
Alright, so we're sure that
好的，我们相信你们中的很多人都玩过隔离的多人游戏，

2733
01:19:23,280 --> 01:19:24,360
0,210 210,300 300,480 480,780 780,1080
many of you have played

2734
01:19:24,360 --> 01:19:26,190
0,420 420,870 870,1110 1110,1290 1290,1830
multiplayer games {} in quarantine,|
|

2735
01:19:26,220 --> 01:19:27,340
0,150 150,240 240,630
when you're bored.|
当你无聊的时候。|

2736
01:19:27,660 --> 01:19:29,280
0,270 270,450 450,960 960,1410 1410,1620
So let's imagine that,| you
所以让我们想象一下，|你是一家小型独立游戏开发公司

2737
01:19:29,280 --> 01:19:31,080
0,480 480,750 750,1200 1200,1590 1590,1800
are a small indie game

2738
01:19:31,080 --> 01:19:32,790
0,150 150,660 1110,1440 1440,1530 1530,1710
dev company| and you're trying
|而你正试图开发一款玩家最多的游戏，

2739
01:19:32,790 --> 01:19:33,750
0,90 90,450 450,540 540,750 750,960
to develop a most player

2740
01:19:33,750 --> 01:19:36,690
0,390 420,1050 1050,1620 2070,2430 2430,2940
game,| possibly that has either
|可能有几个不同的房间，

2741
01:19:36,690 --> 01:19:38,310
0,210 210,480 480,1080 1080,1440 1440,1620
several different rooms,| something like
|就像聊天企鹅，

2742
01:19:38,310 --> 01:19:39,390
0,210 210,600 600,810 810,900 900,1080
chat penguin,| where you might
|在那里你可能会和同一个房间里的其他玩家互动，

2743
01:19:39,390 --> 01:19:40,590
0,330 330,450 450,690 690,1140 1140,1200
interact with other players in

2744
01:19:40,590 --> 01:19:41,940
0,90 90,300 300,630 780,1020 1020,1350
the same room,| or perhaps
|或者它就像是相亲基地，

2745
01:19:41,940 --> 01:19:43,440
0,120 120,270 270,720 720,1050 1050,1500
it's like matchmaking base,| where
|你和其他几个玩家在大厅里。

2746
01:19:43,440 --> 01:19:44,550
0,360 360,510 510,570 570,930 930,1110
you're in a Lobby with

2747
01:19:44,550 --> 01:19:45,620
0,270 270,450 450,870
several other players.|
|

2748
01:19:45,930 --> 01:19:47,640
0,390 390,690 690,1260 1260,1470 1470,1710
Well, so traditionally, how these
嗯，所以传统上，这些是如何工作的，

2749
01:19:47,640 --> 01:19:49,920
0,270 270,510 510,960 1050,1740 1830,2280
work is that,| everything goes
|每件事都与一台中央服务器上的进程相反，

2750
01:19:50,010 --> 01:19:51,270
0,300 300,600 600,750 750,960 960,1260
against process on one central

2751
01:19:51,270 --> 01:19:53,220
0,540 780,1140 1170,1350 1350,1620 1620,1950
server,| but that central server
|但中央服务器是一个瓶颈，

2752
01:19:53,220 --> 01:19:55,170
0,300 300,420 420,990 1230,1560 1560,1950
is a bottleneck,| if every
|如果每个玩家都必须连接到该服务器来处理游戏逻辑，

2753
01:19:55,170 --> 01:19:56,280
0,240 240,540 540,720 720,810 810,1110
single player has to connect

2754
01:19:56,280 --> 01:19:57,750
0,90 90,300 300,780 840,1140 1140,1470
to that server to handle

2755
01:19:57,750 --> 01:19:59,130
0,120 120,330 330,840 900,1170 1170,1380
the game logic,| {} {that,server
|该服务器因通过的请求数量而开始出现瓶颈

2756
01:19:59,130 --> 01:20:00,990
0,180 180,540 540,1290 1380,1680 1680,1860
-} began a {bottleneck -}

2757
01:20:00,990 --> 01:20:01,920
0,240 240,360 360,540 540,600 600,930
by the number of requests

2758
01:20:01,920 --> 01:20:03,330
0,120 120,300 300,630 990,1170 1170,1410
that come through| and also
|而且，如果服务器出现故障，

2759
01:20:03,330 --> 01:20:04,560
0,150 150,330 330,570 570,750 750,1230
if that server goes down,|
|

2760
01:20:05,070 --> 01:20:06,160
0,150 150,330 330,420 420,900
there goes your game.|
这就是你的游戏。|

2761
01:20:06,760 --> 01:20:08,140
0,210 210,390 390,540 540,1110 1230,1380
So what we're proposing is
因此，我们的建议是创建一个分布式游戏框架，

2762
01:20:08,140 --> 01:20:09,520
0,90 90,420 420,540 540,1170 1170,1380
to create a distributed game

2763
01:20:09,520 --> 01:20:12,190
0,540 540,1020 1110,1650 2130,2460 2460,2670
framework,| that instead, that's also
|相反，这也是容错的，

2764
01:20:12,190 --> 01:20:13,720
0,180 180,510 750,1110 1110,1470 1470,1530
fault tolerant,| so instead of
|因此，不是将所有处理都放在该中央服务器上，

2765
01:20:13,720 --> 01:20:15,250
0,510 510,750 750,870 870,1350 1350,1530
having all the processing being

2766
01:20:15,250 --> 01:20:16,570
0,150 150,270 270,540 540,960 960,1320
on that central server,| we
|我们实际上将游戏逻辑处理分布到几个不同的工作服务器上，

2767
01:20:16,570 --> 01:20:18,340
0,330 330,1020 1020,1290 1290,1470 1470,1770
actually distribute the game logic

2768
01:20:18,340 --> 01:20:19,990
0,510 510,660 660,1020 1020,1380 1380,1650
processing to several different worker

2769
01:20:19,990 --> 01:20:21,580
0,420 990,1170 1170,1290 1290,1500 1500,1590
servers,| but on top of
|但最重要的是，

2770
01:20:21,580 --> 01:20:22,220
0,450
that,|
|

2771
01:20:22,560 --> 01:20:23,880
0,180 180,330 330,540 540,960 990,1320
to be fault tolerant {},|
为了实现容错，|

2772
01:20:23,880 --> 01:20:25,020
0,150 150,450 480,750 750,810 810,1140
so when one of these
因此，当这些工作服务器中的一个出现故障时，

2773
01:20:25,050 --> 01:20:26,550
0,420 420,750 750,930 930,1290 1320,1500
worker servers goes down,| we
|我们需要能够处理这种博弈逻辑

2774
01:20:26,550 --> 01:20:27,420
0,240 240,420 420,570 570,780 780,870
need to be able to

2775
01:20:27,420 --> 01:20:29,250
0,390 390,780 810,1230 1230,1590 1590,1830
handle that game logic| and
|并进一步将球员转移到其他一些服务人员，

2776
01:20:29,250 --> 01:20:31,170
0,270 270,630 630,1110 1380,1740 1740,1920
further move players {} to

2777
01:20:31,170 --> 01:20:33,420
0,150 150,390 390,660 960,1380 1680,2250
some other service workers,| so
|因此，作为其中的一部分，我们需要实际平衡延迟和容错，

2778
01:20:33,810 --> 01:20:34,590
0,210 210,390 390,450 450,660 660,780
as part of that, we

2779
01:20:34,590 --> 01:20:36,240
0,120 120,240 240,570 570,1080 1080,1650
need to actually balance latency

2780
01:20:36,240 --> 01:20:37,950
0,180 180,450 450,960 960,1470 1470,1710
with fault tolerance,| because if
|因为如果我们让一切保持容错，

2781
01:20:37,950 --> 01:20:40,050
0,120 120,330 330,810 1110,1500 1500,2100
we make everything {stay,fault} tolerant,|
|

2782
01:20:40,170 --> 01:20:42,660
0,810 840,1170 1170,1320 1320,1860 1860,2490
we might run into a
我们可能会遇到需要很长时间才能处理的每一步。

2783
01:20:42,840 --> 01:20:44,040
0,360 360,600 600,930 930,1020 1020,1200
each move taking a long

2784
01:20:44,040 --> 01:20:45,080
0,240 240,360 360,840
time to process.|
|

2785
01:20:46,080 --> 01:20:47,310
0,180 180,360 360,540 540,690 690,1230
So that's why we're introducing
这就是为什么我们要介绍平吉诺，

2786
01:20:47,310 --> 01:20:48,480
0,210 210,330 330,510 750,1020 1020,1170
{Pinguino - -},| which is
|这是我们的容错游戏框架，

2787
01:20:48,480 --> 01:20:49,860
0,180 180,450 450,750 750,960 960,1380
our fault tolerant game framework,|
|

2788
01:20:49,860 --> 01:20:51,510
0,180 180,840 960,1470 1470,1530 1530,1650
that addresses all of the
这解决了之前分布式网络的所有问题。

2789
01:20:51,510 --> 01:20:53,880
0,360 360,930 960,1380 1380,1980 1980,2370
previous issues with distributed networks.|
|

2790
01:20:59,160 --> 01:21:00,240
0,150 150,450 450,540 540,840 840,1080
To dive a bit into
为了深入了解我们框架的系统，

2791
01:21:00,240 --> 01:21:01,680
0,180 180,510 510,660 660,810 810,1440
the system of our framework,|
|

2792
01:21:01,710 --> 01:21:03,330
0,450 480,930 930,1020 1020,1380 1410,1620
let's imagine the game club
让我们想象一下游戏俱乐部的企鹅，

2793
01:21:03,330 --> 01:21:05,160
0,360 720,960 960,1170 1170,1380 1380,1830
penguin,| so in club penguin,
|因此，在企鹅俱乐部，被分配到一个房间或一个区域的用户，

2794
01:21:05,190 --> 01:21:06,540
0,210 210,690 690,900 900,1020 1020,1350
{} user that is assigned

2795
01:21:06,540 --> 01:21:07,740
0,240 240,570 570,840 840,930 930,1200
into one room or one

2796
01:21:07,740 --> 01:21:09,540
0,600 840,1020 1020,1230 1230,1440 1440,1800
region,| it only really cares
|它只关心与其他用户交谈和互动

2797
01:21:09,540 --> 01:21:11,070
0,240 240,720 720,840 840,1380 1380,1530
about talking and interacting with

2798
01:21:11,070 --> 01:21:13,560
0,300 300,870 870,1290 1350,1980 2010,2490
other users| and the objects
|和那个房间里的物品

2799
01:21:13,560 --> 01:21:14,850
0,180 180,390 390,600 600,1050 1080,1290
in that one room| and
|他们真的不需要关心在另一个房间里发生的任何其他事情，

2800
01:21:14,850 --> 01:21:15,480
0,60 60,210 210,390 390,570 570,630
they don't really need to

2801
01:21:15,480 --> 01:21:16,920
0,240 240,690 720,1080 1080,1290 1290,1440
care about anything else that's

2802
01:21:16,920 --> 01:21:18,120
0,270 270,390 390,750 750,1020
happening in another room,|
|

2803
01:21:18,440 --> 01:21:19,730
0,240 240,450 450,630 630,1080 1080,1290
so there's no reason to
因此，没有理由让每个用户的请求都由一个集中的服务器处理，

2804
01:21:19,730 --> 01:21:21,710
0,480 780,1170 1170,1530 1530,1710 1710,1980
have the request of every

2805
01:21:21,710 --> 01:21:23,030
0,360 360,510 510,960 960,1050 1050,1320
user be processed by one

2806
01:21:23,030 --> 01:21:25,250
0,570 570,1110 1500,1710 1710,2130 2130,2220
centralized servers,| so instead we
|因此，我们决定在多个工作进程中处理所有这些请求，

2807
01:21:25,250 --> 01:21:26,510
0,450 450,660 660,810 810,930 930,1260
decided that we will have

2808
01:21:26,510 --> 01:21:28,250
0,120 120,210 210,570 750,1590 1590,1740
all of these requests be

2809
01:21:28,250 --> 01:21:30,950
0,510 510,1080 1080,1500 1500,2070 2220,2700
process across multiple workers,| in
|为了做到这一点，我们有分配到不同地区的工人，

2810
01:21:30,950 --> 01:21:31,970
0,150 150,270 270,420 420,780 810,1020
order to do this, we

2811
01:21:31,970 --> 01:21:33,470
0,240 240,630 630,840 840,1080 1080,1500
have workers that are assigned

2812
01:21:33,470 --> 01:21:35,030
0,120 120,630 630,1080 1080,1320 1320,1560
to different regions,| so if
|因此，如果玩家在一个地区，

2813
01:21:35,030 --> 01:21:36,080
0,180 180,570 570,720 720,840 840,1050
a player is in one

2814
01:21:36,080 --> 01:21:37,400
0,480 600,870 870,1020 1020,1230 1230,1320
region,| {} they might be
|他们可能正在与分配到该地区的工作人员交谈，

2815
01:21:37,400 --> 01:21:39,080
0,480 480,780 780,990 990,1440 1440,1680
talking with the worker that

2816
01:21:39,080 --> 01:21:40,280
0,150 150,660 660,810 810,960 960,1200
is assigned to that region,|
|

2817
01:21:40,280 --> 01:21:41,510
0,210 210,360 360,690 690,840 840,1230
so for example in here,|
例如，在这里，|

2818
01:21:41,630 --> 01:21:42,710
0,210 210,570 570,750 750,900 900,1080
the penguin that is in
企鹅正在工作，

2819
01:21:42,710 --> 01:21:44,210
0,360 450,660 660,960 990,1380 1380,1500
work,| that is assigned to
|它被分配给工人2的区域，

2820
01:21:44,210 --> 01:21:45,320
0,120 120,450 450,630 630,900 900,1110
the region for worker 2,|
|

2821
01:21:45,320 --> 01:21:46,400
0,180 180,480 480,570 570,870 870,1080
we'll talk with worker 2
我们只和2号工人谈，

2822
01:21:46,400 --> 01:21:47,990
0,450 540,900 900,1170 1170,1260 1260,1590
only,| but then the one
|然后是工人身上的那个，并将与工人交谈。

2823
01:21:47,990 --> 01:21:49,760
0,600 810,1170 1170,1470 1470,1680 1680,1770
in the worker and will

2824
01:21:49,760 --> 01:21:50,680
0,210 210,300 300,750
talk with worker.|
|

2825
01:21:51,210 --> 01:21:52,860
0,180 180,780 780,1050 1050,1470 1470,1650
And additionally we mentioned,| we
此外，我们还提到，|我们认为这不会影响工人和地区之间的关系，

2826
01:21:52,860 --> 01:21:54,600
0,330 330,450 450,630 630,1050 1320,1740
decided that this wouldn't the

2827
01:21:54,630 --> 01:21:56,940
0,630 630,1080 1080,1590 1590,1800 1800,2310
relation between worker and regions,|
|

2828
01:21:56,940 --> 01:21:57,990
0,270 270,720 720,870 870,960 960,1050
doesn't necessarily have to be
不一定是一对一的映射，

2829
01:21:57,990 --> 01:21:59,700
0,240 240,360 360,570 570,1110 1500,1710
one to one mapping,| for
|对于一些可能不太受欢迎和流量较少的房间，

2830
01:21:59,700 --> 01:22:00,720
0,270 270,570 570,720 720,930 930,1020
some rooms that might be

2831
01:22:00,720 --> 01:22:02,100
0,240 240,750 750,870 870,1110 1110,1380
less popular and have less

2832
01:22:02,100 --> 01:22:04,500
0,660 690,1020 1020,1470 1470,1860 1980,2400
traffic,| it's possible that a
|一名工人有可能处理多个这样的问题，

2833
01:22:04,500 --> 01:22:05,970
0,360 360,630 630,930 930,1380 1380,1470
worker can handle multiple of

2834
01:22:05,970 --> 01:22:07,800
0,420 540,840 840,1410 1410,1650 1650,1830
those,| so there's that type
|所以有这样一种关系，

2835
01:22:07,800 --> 01:22:09,240
0,180 180,780 1020,1230 1230,1290 1290,1440
of relation,| that we need
|我们需要追踪的信息。

2836
01:22:09,240 --> 01:22:10,160
0,60 60,240 240,540 540,720
to keep track of.|
|

2837
01:22:10,540 --> 01:22:11,260
0,180 180,270 270,420 420,630 630,720
And so in order to
因此，为了跟踪这一点，

2838
01:22:11,260 --> 01:22:12,160
0,210 210,420 420,540 540,780 780,900
keep track of this,| we
|我们确实需要一台中央服务器，

2839
01:22:12,160 --> 01:22:13,870
0,180 180,390 390,660 660,1350 1350,1710
do need one centralized server,|
|

2840
01:22:13,870 --> 01:22:15,610
0,270 270,390 390,480 480,1290 1500,1740
which is the coordinator,| so
这就是协调人，|因此协调员将跟踪所有这些映射

2841
01:22:15,610 --> 01:22:17,110
0,90 90,960 990,1140 1140,1230 1230,1500
the coordinator will be keeping

2842
01:22:17,110 --> 01:22:18,250
0,240 240,330 330,540 540,720 720,1140
track of all these mappings|
|

2843
01:22:18,580 --> 01:22:19,480
0,210 210,360 360,450 450,510 510,900
and some of the mapping
并且一些映射包括区域到工作者关系以及区域，

2844
01:22:19,480 --> 01:22:21,640
0,720 750,1320 1320,1710 1710,1890 1890,2160
includes the region to {worker

2845
01:22:21,640 --> 01:22:23,500
0,120 120,870 900,1230 1230,1500 1500,1860
-} relation as well as

2846
01:22:23,500 --> 01:22:25,210
0,420 450,750 750,1140 1140,1500 1500,1710
region,| the worker to their
|工人与他们的复制品关系，

2847
01:22:25,210 --> 01:22:26,900
0,510 900,1500
replica {}

2848
01:22:27,260 --> 01:22:29,390
0,600 630,1110 1110,1320 1320,1590 1590,2130
{} relation,| as well as
|以及球员本身，

2849
01:22:29,540 --> 01:22:32,150
0,180 180,630 630,1110 1320,2070 2100,2610
the players itself,| so for
|因此，在容错方面，

2850
01:22:32,150 --> 01:22:33,560
0,120 120,420 420,600 600,1200 1230,1410
the fault tolerant aspect,| we
|我们有，工人将有两个副本，每个副本

2851
01:22:33,560 --> 01:22:35,240
0,480 480,840 840,990 990,1470 1470,1680
have, that the workers will

2852
01:22:35,240 --> 01:22:37,310
0,240 240,450 450,960 990,1380 1410,2070
have two replicate each| and
|当然，我们可以更多地谈论一下什么样的信息

2853
01:22:37,310 --> 01:22:38,420
0,270 270,390 390,690 750,1050 1050,1110
surely we can talk a

2854
01:22:38,420 --> 01:22:39,680
0,240 240,420 420,660 660,1020 1050,1260
little bit more about what

2855
01:22:39,680 --> 01:22:41,150
0,210 210,390 390,990 990,1170 1170,1470
kind of information| is sent
|从那里送到工人那里，然后再送到那里。

2856
01:22:41,150 --> 01:22:43,400
0,270 270,510 510,1200 1530,1920 1920,2250
to the worker from there

2857
01:22:43,610 --> 01:22:45,220
0,150 150,600 750,1440
to [there] later.|
|

2858
01:22:45,610 --> 01:22:47,890
0,210 210,990 990,1230 1230,1860 1860,2280
And additionally, the coordinator,| because
另外，协调员，|因为它是一台集中式服务器，

2859
01:22:47,890 --> 01:22:49,090
0,150 150,300 300,540 540,750 750,1200
it is that one centralized

2860
01:22:49,090 --> 01:22:49,930
0,240 240,390 390,480 480,750 750,840
server,| it is also a
|它也是一个可能的故障点，

2861
01:22:49,930 --> 01:22:52,150
0,660 810,1380 1380,1740 1740,2040 2040,2220
possible a failure point,| so
|所以我们有一个协调人后备

2862
01:22:52,150 --> 01:22:53,590
0,150 150,330 330,420 420,900 900,1440
we have a coordinator backup|
|

2863
01:22:53,650 --> 01:22:55,900
0,690 960,1560 1560,1650 1650,2100 2100,2250
and here the {coordinator's -}
在这里，协调员的主要角色是

2864
01:22:55,900 --> 01:22:56,950
0,270 270,480 480,660 660,930 930,1050
main role is| just to
|只是为了跟踪所有这些游戏状态的关系，

2865
01:22:56,950 --> 01:22:57,820
0,180 180,420 420,540 540,750 750,870
keep track of all of

2866
01:22:57,820 --> 01:22:59,590
0,240 240,900 1170,1410 1410,1500 1500,1770
these relations of the game

2867
01:22:59,590 --> 01:23:02,080
0,390 510,840 840,1470 1470,2010 2280,2490
states,| so information about the
|因此有关为这些关系更改的协调器的信息

2868
01:23:02,080 --> 01:23:04,060
0,690 690,900 900,1440 1440,1620 1620,1980
coordinator that changes for those

2869
01:23:04,060 --> 01:23:05,290
0,600 630,810 810,900 900,1140 1140,1230
relations| will be sent to
|将被发送到协调器备份，

2870
01:23:05,290 --> 01:23:07,540
0,90 90,600 600,1080 1080,1710 1890,2250
the coordinator backup,| before being
|在被完全加工之前是完全的。

2871
01:23:07,540 --> 01:23:10,360
0,870 900,1290 1320,1770 2070,2730
processed a complete completely.|
|

2872
01:23:10,690 --> 01:23:12,580
0,390 390,930 960,1170 1170,1440 1440,1890
So now with this, although
所以现在有了这个，虽然我们只有一台服务器，

2873
01:23:12,580 --> 01:23:13,960
0,270 270,450 450,600 600,810 810,1380
we have that one server,|
|

2874
01:23:14,320 --> 01:23:15,430
0,120 120,360 360,510 510,630 630,1110
the bulk of the traffic
游戏的大部分流量通常是

2875
01:23:15,430 --> 01:23:17,470
0,150 150,540 540,1110 1320,1560 1560,2040
for games usually is| players
|玩家进行移动并发送请求处理这些移动

2876
01:23:17,470 --> 01:23:19,060
0,300 300,690 690,840 840,1140 1140,1590
making moves and sending request

2877
01:23:19,060 --> 01:23:20,680
0,390 390,660 660,990 1110,1410 1410,1620
process those moves| and those
|现在，这些资源被分配给多名员工

2878
01:23:20,680 --> 01:23:22,240
0,90 90,270 270,660 660,1050 1050,1560
are now divided across multiple

2879
01:23:22,240 --> 01:23:23,920
0,780 780,990 990,1080 1080,1530 1530,1680
workers| and the coordinator is
|而协调员只负责一幅地图

2880
01:23:23,920 --> 01:23:24,820
0,120 120,480 480,570 570,840 840,900
in charge of just a

2881
01:23:24,820 --> 01:23:26,740
0,540 540,720 720,1020 1020,1590 1710,1920
mapping| and sending heartbeat to
|并发送心跳信号以确保工人们还活着

2882
01:23:26,740 --> 01:23:28,180
0,390 390,570 570,720 720,1260 1260,1440
ensure that the workers are

2883
01:23:28,180 --> 01:23:30,130
0,240 240,720 750,1200 1230,1620 1620,1950
still alive| and can handle
|并且可以处理任何故障情况。

2884
01:23:30,130 --> 01:23:31,380
0,240 240,630 630,1140
any failure cases.|
|

2885
01:23:33,210 --> 01:23:34,200
0,240 240,480 480,630 630,720 720,990
Yep, so in the case
是的，所以在工人倒下的情况下，

2886
01:23:34,200 --> 01:23:35,640
0,270 270,420 420,780 780,1020 1020,1440
that a worker goes down,|
|

2887
01:23:35,730 --> 01:23:37,050
0,270 270,420 420,630 630,720 720,1320
{} we have the coordinator
我们让协调员来处理那个工人中球员的重新分配

2888
01:23:37,050 --> 01:23:39,240
0,600 630,1020 1020,1680 1680,2070 2070,2190
handling the reassignment of the

2889
01:23:39,240 --> 01:23:40,920
0,420 420,510 510,990 1320,1500 1500,1680
players who were in that

2890
01:23:40,920 --> 01:23:43,080
0,390 750,1140 1140,1590 1590,1710 1710,2160
worker| and because the coordinator
|并且因为协调器仅管理区域映射，

2891
01:23:43,080 --> 01:23:44,880
0,570 570,810 810,930 930,1200 1200,1800
manages only the region mapping,|
|

2892
01:23:44,880 --> 01:23:46,200
0,270 270,570 570,930 930,1140 1140,1320
it's also easy for us
对于我们来说，在不同地区之间移动也很容易

2893
01:23:46,200 --> 01:23:47,910
0,120 120,360 360,780 780,1350 1350,1710
to move around regions| when
|当我们中的一个人，

2894
01:23:47,910 --> 01:23:49,040
0,270 270,390 480,990
one of us,|
|

2895
01:23:49,360 --> 01:23:51,070
0,210 210,600 600,870 870,1050 1050,1710
say one worker gets overloaded,|
假设一个工人超负荷工作，|

2896
01:23:51,070 --> 01:23:52,090
0,120 120,390 390,510 510,630 630,1020
this allows us to perform
这允许我们执行一定量的负载平衡，

2897
01:23:52,090 --> 01:23:53,500
0,270 270,570 570,720 720,900 900,1410
some amount of load balancing,|
|

2898
01:23:54,380 --> 01:23:55,740
0,180 180,270 270,570 570,1080
as we mentioned earlier.|
正如我们之前提到的。|

2899
01:23:56,400 --> 01:23:57,720
0,570 600,930 930,1050 1050,1170 1170,1320
{} Cool, so I'll move
酷，所以我将继续开发人员API是什么样子的，

2900
01:23:57,720 --> 01:23:58,950
0,150 150,360 360,690 690,810 810,1230
on to what the developer

2901
01:23:58,950 --> 01:24:00,720
0,390 390,630 630,840 840,1230 1230,1770
API looks like,| because another
|因为我们想要的另一个关键功能是

2902
01:24:00,720 --> 01:24:02,010
0,240 240,570 570,750 750,900 900,1290
key feature that we wanted

2903
01:24:02,010 --> 01:24:03,300
0,540 570,720 720,840 840,1170 1170,1290
was| for the framework to
|为了使框架易于使用，

2904
01:24:03,300 --> 01:24:04,530
0,120 120,420 420,570 570,870 870,1230
be easy to use,| for
|对于试图在其中编写新游戏代码的开发人员来说，

2905
01:24:04,530 --> 01:24:06,690
0,150 150,810 1020,1350 1650,2100 2100,2160
a developer {trying,to} code a

2906
01:24:06,690 --> 01:24:07,770
0,150 150,390 390,480 480,600 840,1080
new game in it,| so
|因此，我们将游戏本质上视为一个状态机

2907
01:24:07,770 --> 01:24:08,970
0,90 90,300 300,390 390,660 660,1200
we treat the game as

2908
01:24:08,970 --> 01:24:10,770
0,120 120,360 360,660 660,1230 1440,1800
a state machine essentially| and
|所以玩家的任何举动，

2909
01:24:10,770 --> 01:24:11,940
0,210 210,540 540,930 930,1050 1050,1170
so any move that the

2910
01:24:11,940 --> 01:24:13,530
0,330 330,780 900,1230 1230,1410 1410,1590
player makes,| actually fits into
|实际上属于两种不同类型的动作之一，

2911
01:24:13,530 --> 01:24:14,610
0,240 240,360 360,540 540,840 840,1080
one of two different types

2912
01:24:14,610 --> 01:24:15,990
0,90 90,450 720,930 930,1080 1080,1380
of moves,| so I mentioned
|所以我之前提到过，

2913
01:24:15,990 --> 01:24:17,640
0,480 480,780 780,1110 1110,1410 1410,1650
earlier,| that we're trying to
|我们试图在延迟和容错之间取得平衡，

2914
01:24:17,640 --> 01:24:19,350
0,480 480,690 690,840 840,1050 1080,1710
balance a bit of latency

2915
01:24:19,350 --> 01:24:21,210
0,180 180,450 450,870 1170,1620 1620,1860
with fault tolerant,| so in
|所以为了给开发商提供一种选择，

2916
01:24:21,210 --> 01:24:23,100
0,240 240,390 390,1050 1290,1650 1650,1890
order to provide a sort

2917
01:24:23,100 --> 01:24:24,540
0,300 300,720 720,840 840,930 930,1440
of choice for the developer,|
|

2918
01:24:24,540 --> 01:24:26,760
0,120 120,600 840,1110 1110,1770 1770,2220
we have two separate commands
我们向开发人员公开了两个单独的命令，

2919
01:24:26,760 --> 01:24:27,750
0,120 120,240 240,690 690,810 810,990
that we expose to the

2920
01:24:27,750 --> 01:24:29,430
0,510 600,870 870,1200 1200,1350 1350,1680
developer,| the first is send
|第一个是发送快速移动，

2921
01:24:29,430 --> 01:24:31,380
0,360 360,690 810,1380 1380,1620 1620,1950
fast move,| so this fast
|因此，这一快速移动确保了移动尽快到达复制品，

2922
01:24:31,380 --> 01:24:32,610
0,360 390,690 690,990 990,1170 1170,1230
move make sure that the

2923
01:24:32,610 --> 01:24:34,020
0,240 240,660 690,840 840,900 900,1410
move gets to the replicas

2924
01:24:34,020 --> 01:24:35,010
0,150 150,330 330,450 450,870 870,990
as soon as possible,| so
|以便在工作人员上尽可能快地处理移动，

2925
01:24:35,010 --> 01:24:36,330
0,60 60,240 240,510 750,1170 1170,1320
the move gets processed as

2926
01:24:36,330 --> 01:24:37,770
0,240 240,330 330,780 780,1260 1290,1440
fast as possible on the

2927
01:24:37,770 --> 01:24:40,020
0,450 1320,1590 1590,1680 1680,1920 1920,2250
worker,| on the other hand,
|另一方面，我们有SendSableMove，

2928
01:24:40,020 --> 01:24:42,030
0,120 120,480 510,1080 1080,1470 1560,2010
we have {sendStableMove -},| which
|这实际上是一个容错能力更强的举动，

2929
01:24:42,030 --> 01:24:43,530
0,450 450,840 840,1020 1020,1290 1290,1500
actually is a more fault

2930
01:24:43,530 --> 01:24:44,880
0,510 540,990 990,1020 1020,1260 1260,1350
tolerant move,| {} that we
|我们向开发人员公开的

2931
01:24:44,880 --> 01:24:46,650
0,360 360,450 450,750 750,1320 1470,1770
expose to the developer| and
|这确保了这主要用于游戏关键逻辑改变，

2932
01:24:46,650 --> 01:24:48,150
0,180 180,930 930,1140 1140,1230 1230,1500
this ensures this is mainly

2933
01:24:48,150 --> 01:24:50,400
0,300 300,780 810,1230 1230,1890 1890,2250
used for game critical logic

2934
01:24:50,400 --> 01:24:52,200
0,450 450,630 630,870 930,1140 1140,1800
changes,| such as say transaction,|
|例如交易，|

2935
01:24:52,530 --> 01:24:53,550
0,180 180,240 240,360 360,660 660,1020
so if you're buying something
所以如果你买了你不想要的东西，

2936
01:24:53,550 --> 01:24:54,660
0,240 240,630 630,990
you don't want,|
|

2937
01:24:55,090 --> 01:24:56,530
0,390 390,840 840,990 990,1200 1200,1440
like if you've already spent
比如，如果你已经花了那笔钱，

2938
01:24:56,530 --> 01:24:57,310
0,180 180,420 420,510 510,690 690,780
that money,| you want to
|你想确保你在游戏上花的钱都能得到

2939
01:24:57,310 --> 01:24:58,270
0,150 150,300 300,450 450,570 570,960
make sure that you get

2940
01:24:58,570 --> 01:24:59,860
0,330 330,660 660,930 930,1080 1080,1290
whatever you spend that money

2941
01:24:59,860 --> 01:25:01,930
0,420 420,570 570,870 1170,1440 1440,2070
on your game| and so
|所以我们保证，

2942
01:25:02,290 --> 01:25:04,300
0,420 420,1170 1170,1500 1500,1770 1770,2010
we guarantee that,| if that
|如果这一步得到完全处理，并在游戏中进行，

2943
01:25:04,300 --> 01:25:06,700
0,360 360,630 630,1350 1350,1920 1920,2400
move gets fully processed and

2944
01:25:06,730 --> 01:25:08,380
0,270 300,510 510,570 570,930 1140,1650
{} on the game,| it's,
|它，它存储在两个复制品上，

2945
01:25:08,820 --> 01:25:10,140
0,210 210,510 600,960 960,1110 1110,1320
{} it's stored on both

2946
01:25:10,140 --> 01:25:11,700
0,60 60,150 150,660 810,1140 1140,1560
of the replica,| which ensures
|这确保了如果与你交谈的工人倒下

2947
01:25:11,700 --> 01:25:12,840
0,210 210,360 360,510 510,930 930,1140
that if the worker that

2948
01:25:12,840 --> 01:25:14,460
0,390 390,780 780,960 960,1290 1290,1620
you're talking to goes down|
|

2949
01:25:14,460 --> 01:25:15,450
0,120 120,180 180,420 420,600 600,990
and the player gets transferred
然后玩家被转移到新的工人那里，

2950
01:25:15,450 --> 01:25:16,890
0,120 120,150 150,390 390,900 1170,1440
to a new worker,| that
|新的工人将能够重建游戏，

2951
01:25:16,890 --> 01:25:18,090
0,150 150,600 600,750 750,930 930,1200
new worker will be able

2952
01:25:18,090 --> 01:25:19,620
0,150 150,660 660,720 720,1020 1020,1530
to reconstruct the game,| including
|包括那笔交易，

2953
01:25:19,620 --> 01:25:21,720
0,180 180,870 1050,1260 1260,1740 1740,2100
that transaction,| this guarantee isn't
|这一保证不是为快速行动而做的，

2954
01:25:21,720 --> 01:25:22,890
0,270 270,510 510,570 570,930 930,1170
done for a fast move,|
|

2955
01:25:22,890 --> 01:25:25,290
0,210 210,1050 1050,1200 1200,1800 1860,2400
which prioritizes the latency aspect,|
其对延迟方面进行了优先排序，|

2956
01:25:25,590 --> 01:25:26,580
0,360 360,450 450,570 570,810 810,990
but you can also see
但你也可以在这里看到，

2957
01:25:26,580 --> 01:25:28,410
0,360 360,450 450,780 780,1200 1410,1830
here,| the move struct, that
|开发人员定义的Move结构非常通用，

2958
01:25:28,410 --> 01:25:30,720
0,60 60,630 630,1320 1350,1710 1710,2310
the developer defines {} are

2959
01:25:30,750 --> 01:25:32,430
0,360 360,810 810,1350 1380,1620 1620,1680
pretty general,| so in the
|因此，在游戏中，我们开发了一个类似于我们框架的玩具演示，

2960
01:25:32,430 --> 01:25:34,110
0,210 210,480 480,660 660,1230 1380,1680
game that will be that

2961
01:25:34,110 --> 01:25:35,340
0,330 360,570 570,630 630,990 990,1230
we kind of developed as

2962
01:25:35,340 --> 01:25:37,020
0,270 270,750 780,990 990,1440 1440,1680
a {} toy demo for

2963
01:25:37,020 --> 01:25:38,880
0,360 360,990 1290,1530 1530,1770 1770,1860
our framework,| it's kind of
|这是一种聊天企鹅式的界面。

2964
01:25:38,880 --> 01:25:40,380
0,120 120,390 390,720 720,930 930,1500
a chat penguin like interface.|
|

2965
01:25:40,580 --> 01:25:42,140
0,300 300,600 600,1020 1020,1260 1260,1560
So each player is in
所以每个玩家都在几个不同的房间里

2966
01:25:42,140 --> 01:25:44,120
0,390 390,1050 1080,1650
several different {}

2967
01:25:44,810 --> 01:25:47,150
0,540 840,1260 1260,1710 1740,2070 2070,2340
rooms| and so within each
|所以在每个房间里，

2968
01:25:47,150 --> 01:25:48,380
0,210 210,510 510,690 690,930 930,1230
room,| there's a chat window
|有一个聊天窗口，你可以通过它与其他玩家互动，

2969
01:25:48,380 --> 01:25:49,910
0,330 330,450 450,780 1020,1290 1290,1530
that you can talk to

2970
01:25:49,910 --> 01:25:51,230
0,150 150,540 540,690 690,930 930,1320
to interact with another player,|
|

2971
01:25:51,620 --> 01:25:52,730
0,390 390,630 630,720 720,870 870,1110
{} so the two types
所以两种主要的动作，

2972
01:25:52,730 --> 01:25:53,720
0,90 90,420 420,720 720,870 870,990
of main moves,| that you
|你能在这个游戏中赚到的钱

2973
01:25:53,720 --> 01:25:54,710
0,180 180,450 450,540 540,720 720,990
can make in this game|
|

2974
01:25:54,710 --> 01:25:56,630
0,360 360,660 660,840 840,1230 1320,1920
are first a move,| so
首先是一步棋，|因此，开发人员只需定义X、Y和移动玩家的用户名，

2975
01:25:56,630 --> 01:25:58,220
0,240 240,570 570,690 690,840 840,1590
a developer would just define

2976
01:25:58,250 --> 01:25:59,930
0,330 480,930 930,1230 1230,1500 1500,1680
like the X Y and

2977
01:25:59,930 --> 01:26:00,890
0,90 90,510 510,600 600,720 720,960
the username of the player

2978
01:26:00,890 --> 01:26:02,450
0,510 780,1110 1110,1380 1380,1500 1500,1560
moving,| {} and so the
|所以聊天信息都是一样的话

2979
01:26:02,450 --> 01:26:03,350
0,210 210,570 570,660 660,840 840,900
chat message is kind of

2980
01:26:03,350 --> 01:26:04,370
0,90 90,360 360,720 720,900 900,1020
the same words| just like
|就像你发送到窗口的聊天消息一样。

2981
01:26:04,370 --> 01:26:05,210
0,60 60,300 300,600 600,750 750,840
a chat message that you

2982
01:26:05,210 --> 01:26:07,520
0,240 240,420 420,540 540,1920
send into the window.|
|

2983
01:26:07,760 --> 01:26:09,080
0,420 420,1050
And so,
因此，我们在我们的游戏中，

2984
01:26:09,460 --> 01:26:10,900
0,570 570,750 750,870 870,1140 1140,1440
we, in our game,| we
|我们让聊天消息成为一项稳定的举措

2985
01:26:10,930 --> 01:26:12,820
0,240 240,480 480,1110 1110,1440 1440,1890
made chat messages a stable

2986
01:26:12,820 --> 01:26:14,200
0,360 360,660 660,1080 1080,1290 1290,1380
move| and move as a
|像快速移动一样移动，

2987
01:26:14,200 --> 01:26:16,180
0,360 360,750 960,1470 1470,1800 1800,1980
fast move,| so even if
|所以即使像这样，比如说一个举动被放弃了，

2988
01:26:16,180 --> 01:26:17,230
0,210 210,330 330,630 630,810 810,1050
like say one move gets

2989
01:26:17,230 --> 01:26:18,490
0,300 300,450 450,810 810,930 930,1260
dropped,| it's okay,| if you're
|没关系的,|如果你是一种新的[传送]，

2990
01:26:18,520 --> 01:26:19,720
0,90 90,240 240,480 480,540 540,1200
a new kind of [teleports],|
|

2991
01:26:19,750 --> 01:26:21,320
0,690 720,1350
but, {}
但是，我们不希望聊天消息随机消失，

2992
01:26:21,670 --> 01:26:22,990
0,210 210,420 420,600 600,810 810,1320
we don't want chat messages

2993
01:26:22,990 --> 01:26:24,190
0,90 90,420 420,870 870,1110 1110,1200
to randomly disappear,| because they
|因为它们可能是重要的信息。

2994
01:26:24,190 --> 01:26:25,820
0,180 180,300 300,720 720,1230
could be important messages.|
|

2995
01:26:26,080 --> 01:26:27,310
0,510 540,720 720,960 960,1020 1020,1230
So with that, I'll move
到此为止，我将继续演示，

2996
01:26:27,310 --> 01:26:28,930
0,240 240,690 690,870 870,1380 1410,1620
on to the demo,| which
|这只是一个小小的骨架，

2997
01:26:28,930 --> 01:26:30,070
0,180 180,300 300,510 510,690 690,1140
is a little bare bones,|
|

2998
01:26:30,070 --> 01:26:31,720
0,360 630,990 990,1260 1260,1530 1530,1650
but should show off the
但应该炫耀一下它的功能。

2999
01:26:31,720 --> 01:26:32,660
0,660
functionality.|
|

3000
01:26:40,500 --> 01:26:41,280
0,120 120,240 240,390 390,570 570,780
So we have our super
所以我们有我们的超级极简主义前端，

3001
01:26:41,280 --> 01:26:43,560
0,480 480,840 1020,1680
minimalist {frontend -},|
|

3002
01:26:44,690 --> 01:26:45,650
0,390 390,540 540,690 690,780 780,960
and so when we move
所以当我们绕着企鹅走的时候，

3003
01:26:45,650 --> 01:26:46,700
0,210 210,300 300,780 780,900 900,1050
around the penguin,| we can
|我们可以看到，这是第一种快速移动的感觉，

3004
01:26:46,700 --> 01:26:47,960
0,240 240,570 570,810 810,1020 1020,1260
see that, it's first sense

3005
01:26:47,960 --> 01:26:49,820
0,90 90,420 420,810 1020,1620 1620,1860
of fast move,| {} and
|并将相同移动的副本发送到另一个副本

3006
01:26:49,820 --> 01:26:51,680
0,60 60,900 1080,1410 1410,1620 1620,1860
the replica that same move

3007
01:26:51,680 --> 01:26:53,030
0,300 300,570 570,870 870,1020 1020,1350
gets {} sent to the

3008
01:26:53,030 --> 01:26:54,110
0,270 270,600 600,660 660,1020 1020,1080
other replica| is assigned to
|分配给缅因州的工人，

3009
01:26:54,110 --> 01:26:55,010
0,60 60,270 270,600 600,750 750,900
the maine workers,| so right
|所以现在，我们是零号工人，

3010
01:26:55,010 --> 01:26:56,120
0,150 150,300 300,450 450,720 720,1110
now, we're on worker zero,|
|

3011
01:26:56,300 --> 01:26:57,290
0,210 210,300 300,480 480,870 870,990
{} it gets replicated to
它被复制成工作一和工作二，

3012
01:26:57,290 --> 01:26:58,640
0,180 180,510 510,750 750,1050 1080,1350
work one and two,| so
|所以我们有两份拷贝，

3013
01:26:58,640 --> 01:26:59,720
0,120 120,270 270,390 390,840
we have two copies,|
|

3014
01:26:59,870 --> 01:27:01,370
0,690 690,930 930,990 990,1200 1200,1500
{} and the game server
并且游戏服务器然后接收该改变

3015
01:27:01,370 --> 01:27:03,410
0,330 360,1050 1050,1320 1320,1770 1770,2040
then receives that change| and
|这样他们就可以在本地处理这些信息，

3016
01:27:03,410 --> 01:27:04,400
0,120 120,300 300,450 450,810 810,990
so they can process that

3017
01:27:04,400 --> 01:27:05,060
0,390
locally,|
|

3018
01:27:05,300 --> 01:27:06,650
0,450 450,630 630,870 870,1080 1080,1350
{} and then if we
如果我们发一条聊天消息，

3019
01:27:06,830 --> 01:27:08,380
0,270 270,360 360,600 600,1320
send a chat message,|
|

3020
01:27:09,460 --> 01:27:10,990
0,240 240,540 540,1080 1080,1440 1440,1530
we also have {} the
我们还有播放器用户名

3021
01:27:10,990 --> 01:27:12,640
0,480 480,900 900,1440 1440,1560 1560,1650
player username| identified with the
|用所发送的聊天消息标识，

3022
01:27:12,640 --> 01:27:14,290
0,150 150,540 540,960 1020,1380 1380,1650
chat message sent,| {} but
|但这实际上是一个稳定的举动，

3023
01:27:14,290 --> 01:27:15,250
0,180 180,300 300,630 630,690 690,960
this is actually a stable

3024
01:27:15,250 --> 01:27:17,350
0,360 540,930 930,1590 1770,1950 1950,2100
move,| {} so it's not
|所以它在日志中是不可见的，

3025
01:27:17,350 --> 01:27:18,640
0,300 300,390 390,450 450,990 990,1290
visible in the logs,| but
|但稳定的动作要等到这些动作真正复制到工人身上

3026
01:27:18,640 --> 01:27:20,350
0,90 90,540 540,930 930,1200 1200,1710
the stable moves wait until

3027
01:27:20,350 --> 01:27:22,150
0,300 300,690 690,930 930,1170 1170,1800
those moves are actually replicated

3028
01:27:22,270 --> 01:27:23,410
0,180 180,300 300,900 900,1050 1050,1140
to the workers| and it's
|在这里看起来并不容易，

3029
01:27:23,410 --> 01:27:24,280
0,210 210,300 300,390 390,540 540,870
not easy to see here,|
|

3030
01:27:24,280 --> 01:27:25,810
0,600 600,1020 1020,1230 1230,1380 1380,1530
because normally there might be
因为通常情况下可能会有一些滞后，

3031
01:27:25,810 --> 01:27:28,000
0,210 240,540 540,630 630,2010
some amount of lag,|
|

3032
01:27:28,530 --> 01:27:29,760
0,270 270,510 510,600 600,780 780,1230
but when we do introduce
但当我们在网络中引入一定数量的滞后时，

3033
01:27:29,760 --> 01:27:30,630
0,150 150,390 390,450 450,720 720,870
some amount of lag into

3034
01:27:30,630 --> 01:27:31,980
0,120 120,690 720,990 990,1050 1050,1350
the network,| that's {} move
|那就是搬家要花更长的时间，

3035
01:27:31,980 --> 01:27:33,420
0,270 270,570 570,750 1140,1230 1230,1440
takes longer than it does,|
|

3036
01:27:34,160 --> 01:27:35,360
0,300 300,450 450,780 780,1080 1080,1200
{} and now move it
现在把它移回到我们想要实现的一些未来工作中。

3037
01:27:35,360 --> 01:27:37,220
0,210 210,930 1080,1350 1350,1680 1680,1860
back to some future work

3038
01:27:37,220 --> 01:27:38,630
0,90 90,210 210,450 450,780 810,1410
that we want to implement.|
|

3039
01:27:40,060 --> 01:27:40,900
0,600

3040
01:27:44,060 --> 01:27:45,080
0,150 150,330 330,420 420,540 540,1020
In terms of the backend,|
在后台方面，|

3041
01:27:45,080 --> 01:27:46,310
0,510 540,930 930,1050 1050,1170 1170,1230
one additional thing that we
我们还想做一件事

3042
01:27:46,310 --> 01:27:47,480
0,120 120,270 270,390 390,690 690,1170
would like to do| is
|是允许用户在不同的房间之间移动，

3043
01:27:47,480 --> 01:27:48,950
0,210 210,600 600,810 810,1350 1350,1470
to allow the users to

3044
01:27:48,950 --> 01:27:50,840
0,270 270,690 690,1140 1140,1590 1710,1890
move across different rooms,| so
|所以现在，当用户加入游戏时，

3045
01:27:50,840 --> 01:27:52,490
0,150 150,330 330,990 990,1140 1140,1650
right now, upon a user

3046
01:27:52,640 --> 01:27:54,110
0,630 630,720 720,930 930,1320 1320,1470
joining the game,| it'd be
|它会被初始化，

3047
01:27:54,110 --> 01:27:55,520
0,630 630,750 750,990 990,1290 1290,1410
initialized,| they are assigned to
|他们被分配到一个房间，

3048
01:27:55,520 --> 01:27:57,380
0,300 300,720 780,1170 1170,1710 1710,1860
one room,| but ideally if
|但理想情况下，如果他们想要搬到那里去，

3049
01:27:57,380 --> 01:27:58,430
0,120 120,270 270,330 330,480 480,1050
they want to move across

3050
01:27:58,460 --> 01:27:59,390
0,240 240,450 480,600 600,720 720,930
to it,| if they want
|如果他们想换个房间，

3051
01:27:59,390 --> 01:28:00,200
0,60 60,240 240,330 330,420 420,810
to move to a different

3052
01:28:00,200 --> 01:28:01,250
0,390 420,630 630,750 750,930 930,1050
room,| then they should be
|然后他们应该能够与协调员交谈，

3053
01:28:01,250 --> 01:28:01,940
0,150 150,240 240,540 540,600 600,690
able to talk to the

3054
01:28:01,940 --> 01:28:03,170
0,420 420,570 570,690 690,840 840,1230
coordinator to be like,| hey
|嘿，我现在要去这个地区了，

3055
01:28:03,200 --> 01:28:04,340
0,360 360,600 600,750 750,870 870,1140
I'm gonna go to this

3056
01:28:04,340 --> 01:28:05,540
0,360 360,690 690,900 900,990 990,1200
region now,| can we load
|我们可以从那个区域加载游戏状态信息吗

3057
01:28:05,540 --> 01:28:07,250
0,210 210,360 360,1110 1290,1560 1560,1710
up the information of the

3058
01:28:07,250 --> 01:28:08,390
0,240 240,480 480,600 600,840 840,1140
game state from that region|
|

3059
01:28:08,390 --> 01:28:09,320
0,150 150,330 330,690 690,840 840,930
and then also now I'm
然后，现在我也要开始和一位新员工交谈。

3060
01:28:09,320 --> 01:28:10,130
0,120 120,180 180,360 360,660 660,810
going to start talking to

3061
01:28:10,130 --> 01:28:11,200
0,60 60,330 330,930
a new worker.|
|

3062
01:28:11,620 --> 01:28:13,180
0,150 150,720 720,1110 1110,1410 1410,1560
And additionally we hinted at
此外，我们早些时候也曾暗示过，

3063
01:28:13,180 --> 01:28:15,190
0,150 150,720 1020,1410 1410,1800 1800,2010
this earlier,| where we wanted
|我们希望处理基于区域的工作负载平衡，

3064
01:28:15,190 --> 01:28:16,240
0,60 60,270 270,390 390,690 690,1050
to deal with region based

3065
01:28:16,240 --> 01:28:17,830
0,300 300,510 510,1140 1230,1470 1470,1590
worker load balancing,| so the
|所以我们拥有它的原因是，

3066
01:28:17,830 --> 01:28:19,150
0,300 300,510 510,660 660,990 990,1320
reason why we had that,|
|

3067
01:28:19,180 --> 01:28:20,860
0,510 660,930 930,1260 1290,1470 1470,1680
{} why we did not
为什么我们不采用员工到地区的一对一映射

3068
01:28:20,860 --> 01:28:21,610
0,120 120,240 240,480 480,570 570,750
go for one to one

3069
01:28:21,610 --> 01:28:23,590
0,450 450,720 930,1380 1380,1560 1560,1980
mapping with worker to region|
|

3070
01:28:23,590 --> 01:28:25,090
0,180 180,450 480,870 870,1050 1050,1500
was to allow for this
是为了让这项未来的工作

3071
01:28:25,240 --> 01:28:26,770
0,810 810,1080 1080,1230 1230,1350 1350,1530
future work| and we hope
|我们希望能够做到这一点

3072
01:28:26,770 --> 01:28:27,400
0,90 90,240 240,420 420,480 480,630
to be able to do

3073
01:28:27,400 --> 01:28:29,320
0,240 240,300 300,540 540,1020 1050,1920
that| in order to control
|以控制每个工人将承担多少负荷。

3074
01:28:29,350 --> 01:28:31,330
0,360 360,540 540,1140 1260,1680 1710,1980
{} how much load each

3075
01:28:31,330 --> 01:28:32,890
0,420 420,660 660,840 840,1260 1260,1560
worker will be based with.|
|

3076
01:28:37,900 --> 01:28:40,200
0,450 450,480 480,690 690,1230

3077
01:28:44,260 --> 01:28:46,420
0,300 1320,1710 1710,1980 1980,2070 2070,2160
{} Sorry, I have a
抱歉，我有个问题，

3078
01:28:46,420 --> 01:28:48,970
0,480 540,930 930,1410 1650,1890 1890,2550
question,| {} so are your,|
|你的也是，|

3079
01:28:49,880 --> 01:28:51,170
0,300 300,480 480,600 600,810 810,1290
again, you have two actions
同样，您有两个动作来发送消息和移动，

3080
01:28:51,170 --> 01:28:53,570
0,480 480,630 630,1230 1230,1680 1680,2400
sending a message and {}

3081
01:28:53,600 --> 01:28:55,790
0,570 600,840 840,1170 1170,1680 1680,2190
moving,| so those actions are
|因此，这些行为都是原子上正确的，

3082
01:28:56,000 --> 01:28:57,620
0,240 240,840 840,1170 1260,1470 1470,1620
all atomic right,| are they
|他们是不是就像。

3083
01:28:57,620 --> 01:28:58,680
0,300
like.|
|

3084
01:28:59,640 --> 01:29:02,600
0,1530
Yeah.|
嗯。|

3085
01:29:03,000 --> 01:29:04,710
0,120 120,270 270,630 630,1230 1230,1710
They get sequentially processed| and
它们会被按顺序处理|因为它们就像是单独的动作，

3086
01:29:04,710 --> 01:29:05,640
0,150 150,210 210,270 270,420 420,930
since they are like individual

3087
01:29:05,640 --> 01:29:07,650
0,480 480,1050 1170,1890 1890,1950 1950,2010
moves,| they most of the
|大多数情况下，他们只修改一些变量

3088
01:29:07,650 --> 01:29:09,720
0,240 240,420 420,630 630,1410 1620,2070
time they only modify some

3089
01:29:09,720 --> 01:29:11,190
0,540 540,720 720,1020 1020,1380 1380,1470
variables| and they acquire that
|他们在搬家之前就锁定了这些变量。

3090
01:29:11,190 --> 01:29:12,270
0,240 240,330 330,480 480,870 870,1080
locks on those variables before

3091
01:29:12,270 --> 01:29:13,000
0,120 180,540
the moves.|
|

3092
01:29:16,350 --> 01:29:17,940
0,240 240,900 900,1080 1080,1440 1440,1590
So you said earlier, that
所以你之前说过，你有一个协调员和一个后备协调员

3093
01:29:17,940 --> 01:29:19,560
0,120 120,420 450,810 810,1440 1440,1620
you have a coordinator and

3094
01:29:19,560 --> 01:29:22,290
0,540 540,1140 1320,1770 1770,1920 1920,2730
coordinator backup| {} and the
|复制品可以与它们中的任何一个对话，

3095
01:29:22,590 --> 01:29:23,910
0,570 570,660 660,870 870,930 930,1320
replicas can talk to either

3096
01:29:23,910 --> 01:29:25,950
0,90 90,450 750,1260 1290,1590 1590,2040
of them,| {} what happens
|如果您有一个网络分区，

3097
01:29:25,950 --> 01:29:27,120
0,120 120,270 270,630 630,810 810,1170
if you have a network

3098
01:29:27,120 --> 01:29:29,640
0,690 900,1080 1080,1770 1770,1860 1860,2520
partition,| that separates the coordinator|
|这将协调者分开|

3099
01:29:29,640 --> 01:29:31,260
0,240 240,540 540,780 780,870 870,1620
and some set of replicas
以及协调器备份中的一些副本集

3100
01:29:31,380 --> 01:29:32,760
0,180 180,240 240,750 750,1170 1170,1380
from the coordinator backup| and
|以及其他一些复制品。

3101
01:29:32,760 --> 01:29:34,080
0,120 120,360 360,540 540,630 630,1320
some other set of replicas.|
|

3102
01:29:37,900 --> 01:29:39,550
0,330 330,450 450,1020 1020,1410 1410,1650
So the coordinator backup in
因此协调器在网络分区的情况下进行备份，

3103
01:29:39,550 --> 01:29:41,320
0,300 300,390 390,450 450,870 870,1770
case of a network partition,|
|

3104
01:29:41,560 --> 01:29:43,180
0,180 180,720 720,1050 1050,1380 1380,1620
the workers will be kind
工人们会有些迷茫，

3105
01:29:43,180 --> 01:29:44,530
0,120 120,420 420,660 660,780 780,1350
of lost,| like the coordinator
|就像协调器不是工作人员能够与协调器或后备协调器对话的问题，

3106
01:29:44,530 --> 01:29:45,430
0,330 330,480 480,540 540,780 780,900
is not a matter of

3107
01:29:45,430 --> 01:29:46,480
0,120 120,480 480,630 630,900 900,1050
the worker being able to

3108
01:29:46,480 --> 01:29:47,710
0,240 240,360 360,600 600,750 750,1230
talk to either the coordinator

3109
01:29:47,710 --> 01:29:49,390
0,150 150,270 270,690 690,1170 1170,1680
or the coordinator backup,| they'll
|他们只能与协调员交谈

3110
01:29:49,390 --> 01:29:50,350
0,240 240,360 360,600 600,690 690,960
only be able to talk

3111
01:29:50,350 --> 01:29:51,730
0,90 90,210 210,930 960,1230 1230,1380
to the coordinator| and if
|如果协调人倒下了，

3112
01:29:51,730 --> 01:29:53,170
0,60 60,660 660,900 900,1260 1260,1440
a coordinator goes down,| then
|然后备份被启动以实际开始处理，

3113
01:29:53,170 --> 01:29:54,730
0,90 90,480 480,780 780,1170 1200,1560
the backup gets brought up

3114
01:29:54,790 --> 01:29:57,250
0,300 300,1080 1110,1500 1500,2250 2280,2460
to actually start processing,| so
|因此，在网络分区情况下，

3115
01:29:57,250 --> 01:29:58,420
0,150 150,420 420,660 660,780 780,1170
in that case of network

3116
01:29:58,420 --> 01:29:59,620
0,480 480,570 570,780 780,1020 1020,1200
partition,| I don't think we
|我不认为我们会像。

3117
01:29:59,620 --> 01:30:00,680
0,240 270,570 600,930
will be like.|
|

3118
01:30:00,930 --> 01:30:03,000
0,420 450,900 900,1110 1110,1350 1350,2070
The workers that are isolated
与世隔绝、远离协调员的工作人员

3119
01:30:03,000 --> 01:30:04,950
0,180 180,450 450,630 630,930 1080,1950
and away from that coordinator|
|

3120
01:30:05,010 --> 01:30:06,210
0,210 210,480 480,780 780,1050 1050,1200
will not be able to
将无法处理

3121
01:30:06,210 --> 01:30:08,460
0,150 150,810 810,1050 1170,1620 1980,2250
be processed| with the like
|与协调者本身类似

3122
01:30:08,460 --> 01:30:10,440
0,240 270,780 780,1350 1440,1740 1740,1980
the coordinator itself| and turns
|结果发现，用户端，

3123
01:30:10,440 --> 01:30:11,840
0,90 90,210 210,540 540,1140
out the user side,|
|

3124
01:30:12,070 --> 01:30:13,150
0,210 210,360 360,600 600,720 720,1080
it can still be processed,|
它仍然可以被处理，|

3125
01:30:13,150 --> 01:30:14,530
0,390 390,660 690,1020 1020,1230 1230,1380
because the player just needs
因为玩家只需要继续与那个工人交谈，

3126
01:30:14,530 --> 01:30:15,700
0,120 120,540 540,900 900,990 990,1170
to continue talking to that

3127
01:30:15,700 --> 01:30:17,170
0,570 630,900 900,1110 1110,1260 1260,1470
worker,| it's just that, if
|只是，如果这个地区有任何变化，

3128
01:30:17,170 --> 01:30:18,310
0,180 180,420 420,930 930,1020 1020,1140
there's any changes in the

3129
01:30:18,310 --> 01:30:20,500
0,630 960,1230 1230,1800 1800,1980 1980,2190
region,| {like -} the state
|就像整个比赛的状态一样，

3130
01:30:20,500 --> 01:30:21,100
0,60 60,150 150,390 390,570 570,600
of the game as a

3131
01:30:21,100 --> 01:30:22,870
0,570 600,900 900,1140 1140,1290 1290,1770
whole,| that will be processed
|它还会被处理。

3132
01:30:22,870 --> 01:30:24,700
0,210 630,960 990,1680 1680,1710 1710,1830
yet.| Yeah, additionally I want
|是啊，另外我还想做这个，

3133
01:30:24,700 --> 01:30:25,960
0,60 60,270 270,660 870,1080 1080,1260
to make that,| {} if
|如果我们有一个隔板，

3134
01:30:25,960 --> 01:30:27,520
0,120 120,390 390,570 570,1140 1140,1560
we have a partition, {}|
|

3135
01:30:27,550 --> 01:30:28,990
0,120 120,540 540,900 900,1230 1230,1440
the coordinator backup essentially acts
协调器备份实质上充当协调器

3136
01:30:28,990 --> 01:30:29,980
0,120 120,180 180,720 720,900 900,990
as a coordinator| for all
|对于它可以与之交谈的所有工人

3137
01:30:29,980 --> 01:30:30,850
0,90 90,180 180,570 570,750 750,870
of the workers that it

3138
01:30:30,850 --> 01:30:32,470
0,420 450,690 690,960 1140,1470 1470,1620
can talk to| and this
|这很好，

3139
01:30:32,470 --> 01:30:33,790
0,180 180,540 540,840 840,990 990,1320
is fine,| because we want
|因为我们希望游戏仍然在所有地区运行

3140
01:30:33,790 --> 01:30:35,050
0,90 90,420 420,570 570,900 930,1260
the game to be still

3141
01:30:35,050 --> 01:30:35,980
0,360 360,570 570,720 720,810 810,930
running for all of the

3142
01:30:35,980 --> 01:30:37,180
0,450 450,600 600,690 690,1110 1110,1200
regions| in the workers at
|在后备协调员正在与之交谈的工作人员中，

3143
01:30:37,180 --> 01:30:38,320
0,90 90,450 450,750 750,840 840,1140
the coordinator backup is talking

3144
01:30:38,320 --> 01:30:40,060
0,300 420,870 870,1080 1080,1410 1410,1740
to,| {} this mainly becomes
|这主要成了一个问题，

3145
01:30:40,060 --> 01:30:41,710
0,60 60,450 450,780 780,1290 1320,1650
a problem,| when they do
|当他们重聚的时候

3146
01:30:41,710 --> 01:30:43,630
0,630 660,1080 1080,1290 1290,1500 1500,1920
reunite| and in this case
|在这种情况下，协调器备份然后获取其所有数据

3147
01:30:43,630 --> 01:30:45,640
0,450 480,660 660,1140 1140,1650 1650,2010
{} the coordinator backup then

3148
01:30:45,640 --> 01:30:46,840
0,150 150,480 480,720 720,870 870,1200
{} takes all of its

3149
01:30:46,840 --> 01:30:47,480
0,540
{}

3150
01:30:48,190 --> 01:30:49,270
0,330 330,660 660,780 780,870 870,1080
data| and it can send
|并且它可以将其发送给协调器

3151
01:30:49,270 --> 01:30:50,110
0,90 90,180 180,300 300,720 720,840
it to the coordinator| and
|并且协调器可以本地解决该问题，

3152
01:30:50,110 --> 01:30:51,730
0,60 60,420 420,720 720,1230 1230,1620
the coordinator can locally resolve

3153
01:30:51,730 --> 01:30:52,990
0,150 180,660 660,990 990,1080 1080,1260
it,| because there is kind
|因为有一种原始协调器和协调器备份

3154
01:30:52,990 --> 01:30:54,760
0,90 90,660 660,1200 1200,1620 1620,1770
of an original coordinator and

3155
01:30:54,760 --> 01:30:56,230
0,60 60,450 450,960 960,1320 1320,1470
the coordinator backup| and they
|他们知道备份是协调员的备份，

3156
01:30:56,230 --> 01:30:58,180
0,270 270,570 750,960 960,1380 1650,1950
know that the backup was,

3157
01:30:58,270 --> 01:30:59,410
0,150 150,420 420,540 540,630 630,1140
{} backup of the coordinator,|
|

3158
01:30:59,440 --> 01:31:00,980
0,300 300,420 420,750 780,1260
because it's stored locally.|
因为它是本地储存的。|

3159
01:31:02,330 --> 01:31:04,670
0,750 1080,1410 1410,1620 1620,2070 2070,2340
But if the coordinator backup
但是如果后备协调器成为协调器，

3160
01:31:04,670 --> 01:31:06,740
0,270 270,300 300,1020 1050,1650 1680,2070
becomes a coordinator,| then wouldn't
|那不是吗，

3161
01:31:06,740 --> 01:31:08,600
0,300 540,750 750,1260 1260,1530 1530,1860
it,| for example say, oh
|例如，说，哦，我需要确保，

3162
01:31:08,600 --> 01:31:09,680
0,360 360,570 570,690 690,870 870,1080
I need to make sure

3163
01:31:09,680 --> 01:31:10,850
0,120 120,210 210,390 390,720 720,1170
that,| we have active replicas
|我们所有的房间都有活动的复制品，

3164
01:31:10,850 --> 01:31:14,060
0,150 150,450 450,1050 1950,2760 2760,3210
for all these rooms,| that
|它们位于隔板的另一边，

3165
01:31:14,180 --> 01:31:14,990
0,30 240,510 510,660 660,720 720,810
are that are on the

3166
01:31:14,990 --> 01:31:16,190
0,360 360,510 510,570 570,630 630,1200
other side of the partition,|
|

3167
01:31:16,250 --> 01:31:17,390
0,330 330,420 420,540 540,630 630,1140
wouldn't you have the same
你不会在两边都有相同的房间主人吗，

3168
01:31:17,390 --> 01:31:18,770
0,270 270,630 630,840 840,1080 1080,1380
room hosts on both sides,|
|

3169
01:31:18,770 --> 01:31:19,910
0,60 60,600 600,810 810,930 930,1140
the partition and be able
并且能够发散。

3170
01:31:19,910 --> 01:31:20,940
0,120 120,900
to diverge.|
|

3171
01:31:23,820 --> 01:31:25,530
0,360 360,690 690,1080 1080,1440 1440,1710
{} No, because each room
不，因为每个房间只属于一名员工，

3172
01:31:25,530 --> 01:31:27,630
0,600 600,900 900,1470 1500,1680 1680,2100
belongs only to like one

3173
01:31:27,660 --> 01:31:30,480
0,900 1170,1680 1680,2160 2190,2550
worker,| {} so like,|
|所以就像，|

3174
01:31:30,920 --> 01:31:32,630
0,180 180,240 240,390 390,1200 1380,1710
so I guess, like each
所以我想，就像每个房间，比如不能，

3175
01:31:32,630 --> 01:31:34,540
0,570 720,1020 1020,1590
room, like can't,|
|

3176
01:31:34,960 --> 01:31:35,890
0,180 180,270 270,660 660,810 810,930
like the replicas for the
就像房间的复制品会被遗弃一样，

3177
01:31:35,890 --> 01:31:38,110
0,360 360,1080 1080,1350 1350,1950 1950,2220
rooms would get abandoned,| so
|所以从本质上讲，发生的是，

3178
01:31:38,110 --> 01:31:39,550
0,420 420,510 510,900 900,1140 1140,1440
essentially what happens is,| if
|如果一个工人，

3179
01:31:39,550 --> 01:31:40,960
0,150 150,870 1050,1260 1260,1350 1350,1410
a worker,| like in the
|就像在分区的情况下，

3180
01:31:40,960 --> 01:31:41,950
0,210 210,300 300,390 390,900 900,990
case of a partition,| the
|协调器将无法访问另一个分区中的工作进程，

3181
01:31:41,950 --> 01:31:42,940
0,360 360,570 570,690 690,870 870,990
coordinator wouldn't be able to

3182
01:31:42,940 --> 01:31:44,020
0,300 300,480 480,750 750,930 930,1080
access a worker that's in

3183
01:31:44,020 --> 01:31:45,700
0,90 90,390 390,960 1110,1500 1500,1680
the other partition,| {} so
|所以发生的事情是，

3184
01:31:45,700 --> 01:31:47,770
0,150 150,420 420,1110 1590,1950 1950,2070
what happens is,| I think
|我觉得他们喜欢把复制品搬过来，

3185
01:31:47,770 --> 01:31:49,450
0,120 120,540 570,990 990,1140 1140,1680
they like move their replicas

3186
01:31:49,450 --> 01:31:50,080
0,480
over,|
|

3187
01:31:50,220 --> 01:31:51,750
0,360 360,630 630,750 750,1260 1260,1530
but because the players also
但因为球员也不能联系工作人员，

3188
01:31:51,750 --> 01:31:54,200
0,270 270,720 720,1260 1380,2010
can't contact worker, {}|
|

3189
01:31:54,590 --> 01:31:55,700
0,630 630,690 690,780 780,1020 1020,1110
none of the moves would
所有移动都不会被处理

3190
01:31:55,700 --> 01:31:57,380
0,120 120,810 870,1170 1170,1320 1320,1680
be processed| and so the
|因此在分区修复之后较新的复制品将被优先处理，

3191
01:31:57,410 --> 01:31:59,570
0,270 270,630 630,1170 1170,1710 1710,2160
more recent replicas after the

3192
01:31:59,600 --> 01:32:01,910
0,600 600,1110 1110,1320 1320,1470 1470,2310
partition heals would be prioritized,|
|

3193
01:32:01,910 --> 01:32:03,740
0,360 360,630 630,810 810,1230
when healing that network.|
在修复那个网络的时候。|

3194
01:32:08,590 --> 01:32:10,090
0,210 210,600 600,750 750,840 840,1500
{} Why did you decide
您为什么决定使用带有Move的API

3195
01:32:10,120 --> 01:32:12,280
0,150 150,540 540,990 990,1440 1470,2160
on that API with move|
|

3196
01:32:12,310 --> 01:32:14,380
0,600 630,960 960,1290 1290,1350 1350,2070
and {} sending a message.|
并发出一条信息。|

3197
01:32:16,330 --> 01:32:18,970
0,360 360,1020 1080,1860 1860,2190 2190,2640
{} So specifically for this
所以专门针对这个API，

3198
01:32:18,970 --> 01:32:20,680
0,690 720,1050 1050,1230 1230,1530 1530,1710
API,| {} we wanted two
|我们想要两种不同类型的动作，

3199
01:32:20,680 --> 01:32:22,660
0,360 360,720 720,1020 1020,1830 1830,1980
different types of moves,| two
|两种截然不同的动作，

3200
01:32:22,660 --> 01:32:24,520
0,300 300,480 480,540 540,930 1200,1860
distinct types of moves,| demonstrate
|示范一个，快速移动，一个稳定移动，

3201
01:32:24,520 --> 01:32:25,480
0,180 180,300 300,360 360,720 720,960
one, with a fast move,

3202
01:32:25,480 --> 01:32:26,980
0,270 270,330 330,630 630,960 1110,1500
{one,with} a stable move, {}|
|

3203
01:32:26,980 --> 01:32:29,020
0,420 420,720 720,990 990,1710 1710,2040
ideally stable move is used
理想的稳定移动更像是稀有的使用

3204
01:32:29,020 --> 01:32:31,870
0,990 1260,1830 1830,2100 2400,2700 2700,2850
more {like,raraly}| and used more
|并更多地用于交易，

3205
01:32:31,870 --> 01:32:33,310
0,120 120,720 720,1050 1080,1320 1320,1440
for transactions,| that where it's
|在那里花更长的时间是可以的，

3206
01:32:33,310 --> 01:32:34,150
0,330 330,450 450,510 510,600 600,840
okay for it to take

3207
01:32:34,150 --> 01:32:35,770
0,480 480,990 990,1110 1110,1440 1440,1620
longer,| but we wanted to
|但我们不想被抛弃，

3208
01:32:35,770 --> 01:32:36,850
0,180 180,270 270,690 690,810 810,1080
not be dropped at all,|
|

3209
01:32:37,090 --> 01:32:38,080
0,270 270,480 480,780 780,870 870,990
{} the easiest way to
在一个简单的前端复制它的最简单的方法是通过聊天消息，

3210
01:32:38,080 --> 01:32:39,670
0,420 420,570 570,840 840,1320 1320,1590
replicate this in a simple

3211
01:32:39,670 --> 01:32:40,450
0,180 180,330 330,570 570,690 690,780
{frontend -} was with a

3212
01:32:40,450 --> 01:32:41,980
0,210 210,750 1200,1320 1320,1410 1410,1530
chat message,| so it's kind
|所以这有点武断，

3213
01:32:41,980 --> 01:32:42,960
0,60 60,630
of arbitrary,|
|

3214
01:32:43,670 --> 01:32:44,780
0,420 420,570 570,810 810,990 990,1110
moves for sure should be
动作当然应该是快的，

3215
01:32:44,780 --> 01:32:46,540
0,390 390,750 750,930 930,1410
fast,| because we are,
|因为我们是，就像我们不希望的那样，

3216
01:32:47,030 --> 01:32:48,050
0,210 210,300 300,450 450,630 870,1020
like we don't want it

3217
01:32:48,050 --> 01:32:49,430
0,60 60,330 330,660 840,1200 1200,1380
to be,| because players move
|因为球员们经常搬家。

3218
01:32:49,430 --> 01:32:50,380
0,60 60,330
a lot.|
|

3219
01:32:52,390 --> 01:32:53,480
0,270 270,810
Thank you.|
谢谢。|

3220
01:32:59,650 --> 01:33:01,090
0,330 330,540 540,660 660,1050 1080,1440
Awesome, thanks so much,| that
太棒了，非常感谢，|演讲到此结束，

3221
01:33:01,090 --> 01:33:02,860
0,480 480,750 750,1410 1410,1590 1590,1770
concludes the presentations,| great job
|大家都干得很好，

3222
01:33:02,860 --> 01:33:04,090
0,330 330,510 510,690 690,1050 1050,1230
everyone,| this was a pretty
|这真是一场激动人心的比赛。

3223
01:33:04,090 --> 01:33:06,430
0,360 1710,1860 1860,2070 2070,2190 2190,2340
exciting.| I have one more
|如果可能的话，我还有一个关于老演示文稿的问题。

3224
01:33:06,430 --> 01:33:08,140
0,570 570,720 720,840 840,1050 1050,1710
question for an old presentation,

3225
01:33:08,140 --> 01:33:10,540
0,900 1320,1590 1590,2190
if that's possible.|
|

3226
01:33:10,820 --> 01:33:12,060
0,420 480,930
Yep, {go,ahead}.|
好的，去吧。|

3227
01:33:12,420 --> 01:33:14,040
0,300 300,600 600,780 780,930 930,1620
{} So for the leader,|
所以对于领导者来说，|

3228
01:33:14,070 --> 01:33:16,800
0,270 270,510 510,990 1380,2250 2250,2730
I'm sorry, for distributed election
对不起，对于分布式选举系统，

3229
01:33:16,800 --> 01:33:17,860
0,690
system,|
|

3230
01:33:18,080 --> 01:33:19,140
0,780

3231
01:33:19,680 --> 01:33:21,390
0,360 360,840 840,1320 1320,1590 1590,1710
I'm not familiar lot with
我对密码学不是很熟悉，

3232
01:33:21,390 --> 01:33:23,880
0,720 720,1230 1380,2040
cryptography,| but {}
|但我想你总结所有选举结果的系统

3233
01:33:24,180 --> 01:33:25,620
0,120 120,480 480,840 840,1260 1260,1440
I guess the system where

3234
01:33:25,620 --> 01:33:26,760
0,210 210,450 450,750 750,990 990,1140
you sum up all the

3235
01:33:26,760 --> 01:33:28,740
0,450 450,540 540,630 630,1470 1830,1980
results of the election| on
|在柜台服务器上进行投票，

3236
01:33:28,740 --> 01:33:30,480
0,120 120,720 750,1020 1020,1140 1140,1740
a vote on a counter

3237
01:33:30,480 --> 01:33:31,380
0,600
server,|
|

3238
01:33:31,680 --> 01:33:33,330
0,240 240,600 600,930 930,1170 1170,1650
{} this, wouldn't that [high]
这个，不是那个高团伙性袭击，

3239
01:33:33,330 --> 01:33:35,250
0,360 360,780 780,900 900,1470 1470,1920
group attacks,| for example if
|例如，如果我有两台服务器，

3240
01:33:35,310 --> 01:33:36,690
0,150 150,420 420,600 600,1170 1170,1380
I have two servers,| and
|然后我在两台服务器上投票给不同的人，

3241
01:33:36,690 --> 01:33:38,550
0,180 180,330 330,1020 1230,1410 1410,1860
then I vote for different

3242
01:33:38,550 --> 01:33:39,870
0,300 300,480 480,720 720,1200 1200,1320
people on both servers,| but
|但之后我会和其他人协调

3243
01:33:39,870 --> 01:33:41,160
0,120 120,240 240,780 780,960 960,1290
then I coordinate with someone

3244
01:33:41,160 --> 01:33:43,530
0,690 840,960 960,1530 1560,2220 2250,2370
else| to also vote in
|以另一种方式投票，

3245
01:33:43,530 --> 01:33:44,970
0,120 120,330 330,480 480,990 1080,1440
the other way around,| will
|最终将获得相同的投票因素，

3246
01:33:44,970 --> 01:33:46,500
0,480 480,720 720,810 810,1170 1170,1530
eventually get the same vote

3247
01:33:46,500 --> 01:33:47,340
0,600
factor,|
|

3248
01:33:47,550 --> 01:33:49,260
0,720 750,930 930,1110 1110,1470 1470,1710
but I would have thought
但我会恶意地认为它反对，

3249
01:33:49,260 --> 01:33:51,120
0,150 150,750 750,1200 1200,1290 1290,1860
it maliciously against,| I guess
|我想这种情况下不会改变投票结果，

3250
01:33:51,150 --> 01:33:52,950
0,180 180,360 360,690 690,1050 1050,1800
in this case wouldn't change

3251
01:33:53,590 --> 01:33:55,750
0,540 660,1050 1050,1830 1830,1950 1950,2160
the vote results,| or like
|或者像选举结果一样，

3252
01:33:55,750 --> 01:33:57,760
0,90 90,510 510,1080 1080,1500 1890,2010
the election result,| but I
|但我想我的行为是错误的，

3253
01:33:57,760 --> 01:33:58,810
0,210 210,300 300,420 420,750 750,1050
guess I would have acted

3254
01:33:58,810 --> 01:34:00,280
0,540 540,750 750,870 870,1080 1080,1470
incorrectly,| so are there checks
|因此，是否有检查以确保每个服务器上的每个人都正确投票。

3255
01:34:00,280 --> 01:34:01,660
0,120 120,300 300,570 570,960 960,1380
to make sure everybody voted

3256
01:34:01,660 --> 01:34:03,520
0,660 660,870 870,1020 1020,1650
correctly at each server.|
|

3257
01:34:03,860 --> 01:34:06,200
0,2070
Yeah.|
嗯。|

3258
01:34:07,430 --> 01:34:09,950
0,420 420,900 900,1710 1980,2160 2160,2520
{} Sorry, so we actually
抱歉，我们实际上不处理恶意投票，

3259
01:34:09,950 --> 01:34:12,110
0,360 360,1020 1020,1500 1500,1890 1890,2160
don't handle malicious voting,| which
|这是一件很大的事情，

3260
01:34:12,110 --> 01:34:13,640
0,480 600,930 930,1140 1140,1410 1410,1530
was which is which is

3261
01:34:13,640 --> 01:34:14,700
0,300 300,780
pretty big,|
|

3262
01:34:14,870 --> 01:34:16,400
0,660 690,930 930,1080 1080,1290 1290,1530
and you know I used
你知道，对于现实世界的投票系统来说，我曾经非常重要，

3263
01:34:16,400 --> 01:34:17,750
0,60 60,180 180,420 420,930 930,1350
to be pretty important for

3264
01:34:17,780 --> 01:34:19,920
0,540 540,990 990,1290 1290,1860
for real-world voting system,|
|

3265
01:34:20,130 --> 01:34:23,190
0,840 870,1770 2040,2430 2430,2610 2610,3060
{} but yeah I think
但是，是的，我想就像你知道我们的项目的范围一样

3266
01:34:23,490 --> 01:34:24,810
0,540 570,720 720,840 840,930 930,1320
like you know the scope

3267
01:34:24,810 --> 01:34:25,650
0,90 90,210 210,600 600,720 720,840
of the project that we

3268
01:34:25,650 --> 01:34:26,490
0,300 300,390 390,480 480,600 600,840
had| and that we set
|我们出发了，

3269
01:34:26,490 --> 01:34:28,410
0,450 720,1110 1110,1350 1350,1500 1500,1920
out,| {} it was just
|只是有点太复杂了，

3270
01:34:28,410 --> 01:34:30,630
0,150 150,570 570,810 810,1620 1650,2220
a little too complicated, {}|
|

3271
01:34:31,090 --> 01:34:34,330
0,210 210,840 1470,2760 2790,2970 2970,3240
so we, yeah.| I think
所以我们，是的。|我认为我们更关注分布式系统部分，

3272
01:34:34,330 --> 01:34:35,530
0,270 270,600 600,900 930,1050 1050,1200
we focus more on the

3273
01:34:35,530 --> 01:34:38,080
0,840 840,1380 1380,2010 2070,2460 2460,2550
distributed systems part,| but if
|但如果我们想提供更多的安全保障，

3274
01:34:38,080 --> 01:34:39,490
0,90 90,390 390,630 630,990 990,1410
we wanted to provide more

3275
01:34:39,490 --> 01:34:41,470
0,120 120,870 870,1170 1170,1320 1320,1980
{} security,| like for security,|
|比如为了安全起见，|

3276
01:34:41,800 --> 01:34:43,480
0,360 360,510 510,1170 1170,1440 1500,1680
using for example like an
例如，使用一个我们认为的想法，

3277
01:34:43,480 --> 01:34:44,500
0,240 240,420 420,570 570,840 840,1020
idea that we thought,| but
|但后来决定这样做，

3278
01:34:44,500 --> 01:34:46,690
0,150 150,570 570,1410 1440,1890 1890,2190
then decided to do,| I
|我有一个公共账本，你可以在那里赚到，

3279
01:34:46,690 --> 01:34:48,220
0,210 210,570 570,810 810,1170 1170,1530
was having a public ledger

3280
01:34:48,220 --> 01:34:49,220
0,180 180,330 330,540 540,810
where you can make,|
|

3281
01:34:49,390 --> 01:34:51,220
0,390 390,750 750,960 960,1290 1290,1830
give us your knowledge proofs,|
给我们你的知识证据，|

3282
01:34:51,220 --> 01:34:53,230
0,330 330,1080 1200,1410 1410,1590 1590,2010
that they what you're posting
你发的帖子加起来就是

3283
01:34:53,230 --> 01:34:54,760
0,300 450,780 780,1110 1110,1230 1230,1530
like adds up| and is
|这就是你所说的

3284
01:34:54,760 --> 01:34:55,840
0,360 360,510 510,810 810,960 960,1080
what you're saying that it

3285
01:34:55,840 --> 01:34:57,280
0,240 240,810 840,1080 1080,1230 1230,1440
is| and thinks of these
|并想到这些事情来处理恶意参与者。

3286
01:34:57,280 --> 01:34:59,800
0,270 270,390 390,810 810,1560 1740,2520
things to handle malicious participants.|
|

3287
01:35:00,340 --> 01:35:01,160
0,570

3288
01:35:02,170 --> 01:35:04,330
0,1170 1380,1560 1560,1950 1950,2130 2130,2160
Yeah.| So we're running a
嗯。|所以我们有点晚了，

3289
01:35:04,330 --> 01:35:06,190
0,150 150,270 270,840 840,1620 1620,1860
little bit late,| yeah, it's
|是的，原则上是在班级里

3290
01:35:06,190 --> 01:35:07,540
0,120 120,360 360,660 660,780 780,1350
in the class in principle|
|

3291
01:35:07,540 --> 01:35:08,440
0,210 210,570 570,690 690,780 780,900
and anybody want to take
如果有人想回答一个问题，

3292
01:35:08,440 --> 01:35:09,460
0,210 210,270 270,690 690,870 870,1020
around a question,| feel free
|你可以自由地留下来，

3293
01:35:09,460 --> 01:35:10,930
0,90 90,240 240,660 930,1350 1350,1470
to stick around,| {} as
|上次班会结束前你想说两件事中的一件，

3294
01:35:10,930 --> 01:35:11,770
0,60 60,180 180,360 360,630 630,840
you want to say one

3295
01:35:11,770 --> 01:35:13,090
0,90 90,180 180,510 510,870 870,1320
of two things before closing

3296
01:35:13,090 --> 01:35:14,530
0,330 330,480 480,750 750,1020 1020,1440
since our last class meeting,|
|

3297
01:35:14,890 --> 01:35:15,670
0,390 390,570 570,630 630,720 720,780
{} first of all, I
首先，我想感谢你们的参与，

3298
01:35:15,670 --> 01:35:16,840
0,120 120,180 180,390 420,900 930,1170
want to thank you for

3299
01:35:16,840 --> 01:35:18,220
0,690 690,900 900,1050 1050,1140 1140,1380
participating,| even though it's another
|即使这又是一个令人欣喜的学期，

3300
01:35:18,220 --> 01:35:20,140
0,270 270,1140 1320,1590 1590,1770 1770,1920
covid semester,| I feel I've
|我觉得我已经和你们中的许多人互动过了，

3301
01:35:20,140 --> 01:35:21,220
0,390 390,480 480,690 690,780 780,1080
interacted with many of you,|
|

3302
01:35:21,220 --> 01:35:23,710
0,690 1080,1590 1590,1710 1710,2160 2160,2490
{} you for email, we're
你的电子邮件，我们间接地

3303
01:35:23,710 --> 01:35:25,270
0,690 690,900 900,1260 1260,1470 1470,1560
indirectly| and exchange lots of
|并交换大量的信息

3304
01:35:25,270 --> 01:35:26,770
0,630 630,1020 1020,1260 1260,1380 1380,1500
information| and I'd love to
|我也很想在某个时候见到你本人，

3305
01:35:26,770 --> 01:35:27,520
0,150 150,240 240,330 330,480 480,750
see you at some point

3306
01:35:27,520 --> 01:35:29,560
0,300 750,1500 1500,1710 1710,1920 1920,2040
{in,person},| actually know who you
|真正知道你是谁，

3307
01:35:29,560 --> 01:35:32,530
0,210 420,960 1530,2250 2400,2730 2730,2970
are,| {} the {} but,
|但是，我很感谢大家的参与。

3308
01:35:32,530 --> 01:35:33,940
0,270 270,660 660,750 750,810 810,1410
I appreciate all the participation.|
|

3309
01:35:34,410 --> 01:35:35,190
0,210 210,420 420,540 540,600 600,780
The second thing I want
我想感谢助教的第二件事，

3310
01:35:35,190 --> 01:35:38,280
0,210 210,450 450,960 990,2190 2910,3090
to thank TAs,| {} it's
|这是一套很棒的助教，

3311
01:35:38,280 --> 01:35:39,780
0,120 120,420 420,990 990,1170 1170,1500
an awesome {set,of,TAs},| you probably
|你可能意识到，可能对很多人来说，

3312
01:35:39,780 --> 01:35:42,360
0,660 990,1920 1920,2040 2040,2250 2250,2580
realized, probably for many you,|
|

3313
01:35:42,360 --> 01:35:43,650
0,240 240,570 570,690 690,780 780,1290
they figured out some bugs
他们找出了一些漏洞，帮你通过了实验室

3314
01:35:43,680 --> 01:35:44,760
0,420 420,660 660,780 780,960 960,1080
and helped you get through

3315
01:35:44,760 --> 01:35:47,640
0,90 90,630 1500,1890 1890,2220 2220,2880
the labs| and so I
|所以我为助教们鼓掌，

3316
01:35:48,000 --> 01:35:49,740
0,210 210,540 540,990 1080,1500 1500,1740
ran applause for {the,TAs} {},|
|

3317
01:35:50,250 --> 01:35:52,200
0,690 690,1140 1140,1590 1620,1770 1770,1950
very fortunate with this kind
非常幸运，有这样的品质。

3318
01:35:52,200 --> 01:35:53,880
0,150 330,1200
of quality.|
|

3319
01:35:54,460 --> 01:35:56,500
0,750 840,1440 1440,1560 1560,1680 1680,2040
And, {} I guess {last,thing}
我想我要说的最后一句话，

3320
01:35:56,500 --> 01:35:57,730
0,120 120,360 360,780 780,780 780,1230
I was {to,say},| I guess
|我想祝你在决赛中好运

3321
01:35:57,730 --> 01:36:00,640
0,150 150,330 900,2010 2220,2730 2730,2910
good {luck,on,the,final}| and hopefully not
|希望不会太糟，

3322
01:36:00,640 --> 01:36:02,530
0,60 60,570 570,1050 1470,1650 1650,1890
too bad,| and I hope
|我希望你在6.824学到了一些东西

3323
01:36:02,530 --> 01:36:03,820
0,90 90,510 540,990 990,1230 1230,1290
you had learned something in

3324
01:36:03,820 --> 01:36:05,590
0,720 720,1170 1260,1620 1620,1680 1680,1770
6.824| and enjoyed it at
|并在同一时间享受它。

3325
01:36:05,590 --> 01:36:06,380
0,60 60,270 270,540
the same time.|
|

3326
01:36:07,320 --> 01:36:08,130
0,300 300,540 540,600 600,750 750,810
And anyone who wants to
任何想留下来的人，

3327
01:36:08,130 --> 01:36:09,270
0,120 120,330 330,720 720,870 870,1140
stick around,| please stick around,|
|请留下来，|

3328
01:36:09,270 --> 01:36:10,650
0,330 330,750 750,870 870,1140 1140,1380
{ -} you know more
你知道你想问不同团队更多的问题，

3329
01:36:10,650 --> 01:36:11,850
0,420 420,720 720,870 870,930 930,1200
questions you want to ask

3330
01:36:11,850 --> 01:36:13,230
0,150 150,420 420,690 690,1020 1020,1380
to the different teams, {}|
|

3331
01:36:13,230 --> 01:36:14,340
0,120 120,240 240,480 480,750 810,1110
if the teams can stick
如果这两支球队能坚持下去，让他们变得更出色，

3332
01:36:14,340 --> 01:36:16,530
0,210 210,870 900,1110 1110,1590 1590,2190
around to be wonderful,| otherwise,
|否则，好吧，这就结束了，

3333
01:36:16,530 --> 01:36:17,580
0,390 390,540 540,630 630,780 780,1050
well, this is the end,|
|

3334
01:36:17,970 --> 01:36:18,990
0,330 330,480 480,660 660,720 720,1020
at least for the class
至少6.824年的班会是这样。

3335
01:36:18,990 --> 01:36:19,980
0,270 270,480 480,600 600,690 690,990
meetings for {6.824 - -}.|
|

3336
01:36:20,950 --> 01:36:22,040
0,210 210,330 330,690
Thank you all.|
谢谢大家。|

3337
01:36:24,180 --> 01:36:26,250
0,390 390,720 900,1890 1890,1950 1950,2070
Thank you.| Thank you so
谢谢。|非常感谢。

3338
01:36:26,250 --> 01:36:28,170
0,300 300,570 570,840 1020,1380 1380,1920
much.| Thank you.| Thank you.|
|谢谢。|谢谢。|

3339
01:36:28,530 --> 01:36:30,500
0,240 240,330 330,480 480,1170
Thank you so much.|
非常感谢。|

3340
01:36:34,070 --> 01:36:35,460
0,450

3341
01:36:38,180 --> 01:36:39,140
0,630

3342
01:36:40,260 --> 01:36:43,350
0,510 510,750 750,960 960,1590 1920,3090
Sorry, a quick question.| Okay.|
抱歉，我有个小问题。|好吧。|

3343
01:36:43,380 --> 01:36:46,710
0,900 900,1170 1170,1680 1680,2190 3150,3330
One last question now for
现在是最后一个问题了，

3344
01:36:46,710 --> 01:36:50,940
0,510 1770,2400 2760,3330 3330,3660 3660,4230
real,| oh, I I oh
|哦，我，哦，我在想考试的后勤费用，

3345
01:36:50,970 --> 01:36:52,380
0,150 150,270 270,540 540,1110 1110,1410
I was wondering actually for

3346
01:36:52,380 --> 01:36:53,880
0,180 180,690 690,810 810,900 900,1500
for logistics for the exam,|
|

3347
01:36:54,630 --> 01:36:58,260
0,750 750,1440 1470,1920 1920,2340 2370,3630
{} I emailed you.| Yeah,
我给你发了电子邮件。|是的，是的，我们还没说到点子上，

3348
01:36:58,260 --> 01:37:00,030
0,660 660,930 1230,1500 1500,1680 1680,1770
yeah, we haven't gotten to

3349
01:37:00,030 --> 01:37:00,990
0,90 90,330 330,570 570,660 660,960
the point, yet,| we're dealing
|我们正在处理这个例子的后勤问题。

3350
01:37:00,990 --> 01:37:01,770
0,120 120,180 180,630 630,720 720,780
with the logistics of the

3351
01:37:01,770 --> 01:37:04,170
0,660 690,1140 1230,1470 1470,1890 1890,2400
example.| Okay.| A couple, {}
|好吧。|一对情侣，知道你们两个三个要。

3352
01:37:04,380 --> 01:37:06,390
0,480 480,570 570,1320 1320,1830 1830,2010
aware of you two three

3353
01:37:06,390 --> 01:37:10,080
0,240 450,1050 1140,1590 3030,3270 3270,3690
[] to.| We have plan,
|我们有计划，我们还没有执行，

3354
01:37:10,080 --> 01:37:11,580
0,120 120,300 300,660 660,990 990,1500
we haven't executed yet,| noe
|Noe透露了任何细节。

3355
01:37:11,610 --> 01:37:12,800
0,390 390,540 540,1080
shared any details.|
|

3356
01:37:13,340 --> 01:37:16,730
0,570 720,990 990,1470 1920,2700 2700,3390
Okay.| But {it,will,happen}.| Sounds good.|
好吧。|但这是会发生的。|听起来不错。|

3357
01:37:16,970 --> 01:37:18,590
0,300 300,450 450,690 690,1020 1140,1620
You don't need me to
你不需要我来确保你主动联系。

3358
01:37:18,710 --> 01:37:20,030
0,450 450,750 750,840 840,1140 1140,1320
make sure you reach out.|
|

3359
01:37:20,030 --> 01:37:25,400
0,60 3510,4110 4140,5010 5010,5250 5250,5370
{} Alright, perfect,| thank you
好的，太好了，|非常感谢你所做的一切，

3360
01:37:25,400 --> 01:37:26,930
0,180 180,420 420,870 870,1350 1380,1530
so much for everything,| for
|对于班级和助教来说。

3361
01:37:26,930 --> 01:37:28,190
0,60 60,420 420,630 720,960 960,1260
the class and you know

3362
01:37:28,220 --> 01:37:30,320
0,90 90,180 180,750
for the TAs.|
|

3363
01:37:30,740 --> 01:37:32,570
0,840 840,930 930,1170 1170,1440 1440,1830
Thank you very much for
非常感谢你的所有课程，

3364
01:37:33,280 --> 01:37:34,620
0,240 240,330 330,690 690,1050
all the class,| so
|非常有趣，我学到了很多。

3365
01:37:35,910 --> 01:37:37,290
0,540 540,840 870,1080 1080,1290 1290,1380
very fun I learned a

3366
01:37:37,290 --> 01:37:37,860
0,240
lot.|
|

3367
01:37:38,060 --> 01:37:39,290
0,720 720,840 840,1020 1020,1110 1110,1230
Thank you, thank you for
谢谢你们，感谢你们的参与，提出了所有这些问题，

3368
01:37:39,290 --> 01:37:41,180
0,570 810,1140 1140,1230 1230,1320 1320,1890
participating, asking all these questions,|
|

3369
01:37:41,300 --> 01:37:42,680
0,60 60,420 420,570
I appreciate it.|
我很感激。|

3370
01:37:44,080 --> 01:37:44,980
0,240 240,450 450,540 540,690 690,900
Yes, thank you,| this is
好的，谢谢,|这是一堂很棒的课，

3371
01:37:44,980 --> 01:37:45,790
0,150 150,240 240,300 300,570 570,810
this is an awesome class,|
|

3372
01:37:45,790 --> 01:37:49,030
0,60 60,210 210,750 2070,2850 2850,3240
I really appreciate.| Things were
我真的很感激。|上课时一切都很活跃。

3373
01:37:49,120 --> 01:37:50,710
0,540 540,870 870,1110 1110,1170 1170,1590
being active during the class.|
|

3374
01:37:53,920 --> 01:37:55,840
0,450 450,630 630,1020 1020,1350 1350,1920
Okay, I guess that's probably,|
好吧，我想那可能是，|

3375
01:37:55,870 --> 01:37:57,250
0,480 480,840 870,930 930,1080 1080,1380
{} so I guess let's
所以我想我们停止录音吧。

3376
01:37:58,300 --> 01:37:59,524
0,540 540,630 630,1140
stop the recording.
