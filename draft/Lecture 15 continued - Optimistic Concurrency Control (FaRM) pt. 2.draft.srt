1
00:00:04,350 --> 00:00:07,470
0,390 390,1050 1080,1290 1290,2070 2880,3120
Okay, {} good afternoon, good
好的，下午好，晚上好或晚安，早上好，

2
00:00:07,470 --> 00:00:08,610
0,330 330,510 510,660 660,960 960,1140
evening or good night, good

3
00:00:08,610 --> 00:00:10,080
0,480 630,1170
morning, {}|
|

4
00:00:10,450 --> 00:00:12,550
0,330 330,600 600,990 1020,1320 1320,2100
whatever {timezone -} you're in
无论你在哪个时区收看这场演讲。

5
00:00:12,580 --> 00:00:16,600
0,420 420,600 600,1470 1650,2340 3270,4020
watching this lecture.| {} Double
|仔细检查声音，人们能听到我说话吗？

6
00:00:16,630 --> 00:00:18,910
0,390 390,480 480,1020 1110,1800 2040,2280
checking on sound, {} people

7
00:00:18,910 --> 00:00:19,700
0,90 90,240 240,540
can hear me?|
|

8
00:00:25,070 --> 00:00:28,730
0,420 570,1350 1650,2100 2400,2880 2910,3660
Yes yes.| Sure, okay, {}
是的，是的。|当然，好的，今天我要谈两件事，

9
00:00:28,730 --> 00:00:30,200
0,120 120,390 390,690 690,1140 1170,1470
I'm gonna talk about two

10
00:00:30,200 --> 00:00:31,130
0,240 240,570 570,660 660,840 840,930
things today,| I want to
|我想结束我们对农场的讨论

11
00:00:31,130 --> 00:00:32,270
0,300 300,540 540,630 630,1080 1080,1140
finish off our discussion to

12
00:00:32,270 --> 00:00:34,430
0,450 480,1110 1380,1650 1650,1950 1950,2160
{} FaRM| and then I'll
|然后我会谈到Spark。

13
00:00:34,430 --> 00:00:36,860
0,180 180,360 360,930 1950,2280 2280,2430
talk about spark.| And just
|我只想提醒大家，

14
00:00:36,860 --> 00:00:38,600
0,270 270,540 540,930 930,1530 1530,1740
to remind everybody else,| so
|所以每个人，我们更像是农场，

15
00:00:38,600 --> 00:00:41,030
0,540 540,870 870,1170 1170,1860 2070,2430
everybody we were {more,FaRM}, {}|
|

16
00:00:41,030 --> 00:00:43,370
0,510 510,840 840,1350 1380,2190 2190,2340
we're talked about executing {}
我们谈到了执行事务，并且没有任何失败

17
00:00:43,370 --> 00:00:45,470
0,750 750,990 990,1320 1320,1500 1500,2100
transaction and without any failures|
|

18
00:00:45,800 --> 00:00:47,270
0,780 780,900 900,1140 1140,1230 1230,1470
and we looked at one
我们看了一个例子

19
00:00:47,270 --> 00:00:49,520
0,870 870,960 960,1410 1410,1800 1800,2250
example| of whether actually the
|事务实际上是否提供了外部一致性或严格的可序列化。

20
00:00:49,580 --> 00:00:52,640
0,450 450,1170 1500,2010 2010,2430 2430,3060
transaction provided {} external consistency

21
00:00:52,640 --> 00:00:54,300
0,450 480,930 930,1590
or {strict,serializability -}.|
|

22
00:00:54,990 --> 00:00:56,700
0,450 720,1320 1350,1530 1530,1590 1590,1710
And, {} so I want
所以，我想再谈一个例子，

23
00:00:56,700 --> 00:00:57,510
0,60 60,240 240,420 420,600 600,810
to talk about one more

24
00:00:57,510 --> 00:00:59,850
0,660 690,1080 1080,1590 1590,2070 2070,2340
example,| {} to look about
|来讨论可串行化，

25
00:00:59,850 --> 00:01:01,200
0,210 210,480 480,660 660,780 780,1350
to talk about {serializability -},|
|

26
00:01:01,200 --> 00:01:03,120
0,120 120,960 1260,1680 1680,1740 1740,1920
and then talk a little
然后稍微谈一谈容错，

27
00:01:03,120 --> 00:01:04,710
0,90 90,300 300,570 570,1110 1350,1590
bit about fault tolerance,| but
|但在此之前，

28
00:01:04,710 --> 00:01:06,510
0,390 390,660 660,1260 1260,1590 1590,1800
before doing so,| it's probably
|提醒一下可能会有帮助，

29
00:01:06,510 --> 00:01:08,610
0,300 300,390 390,870 990,1620 1680,2100
helpful to remind,| my remind
|我准确地提醒自己，

30
00:01:08,610 --> 00:01:10,320
0,360 360,840 840,930 930,1080 1080,1710
ourselves exactly,| you know how
|你知道交易是怎么运作的，

31
00:01:10,500 --> 00:01:12,720
0,210 660,1200 1200,1710 1800,2040 2040,2220
{} transaction works,| {} if
|如果没有故障，

32
00:01:12,720 --> 00:01:14,730
0,150 150,210 210,360 360,930 1500,2010
there are no failures, {}|
|

33
00:01:14,730 --> 00:01:15,870
0,180 180,450 450,720 720,1050 1050,1140
and so in FaRM and
因此，在农场和应用程序分为两个阶段，

34
00:01:15,870 --> 00:01:17,640
0,480 480,840 840,990 990,1170 1170,1770
application goes for two phases,|
|

35
00:01:17,640 --> 00:01:19,710
0,180 180,750 750,1320 1500,1980 1980,2070
the execution phase, where it
执行阶段，它从不同的碎片获取您知道的对象

36
00:01:19,710 --> 00:01:21,510
0,360 360,960 960,1110 1110,1290 1290,1800
fetches objects you know from

37
00:01:21,510 --> 00:01:24,330
0,330 330,1080 1080,1710 2100,2310 2310,2820
{} different shards| and then
|然后是提交阶段。

38
00:01:24,330 --> 00:01:25,500
0,0 0,300 300,600 600,1020 1020,1170
{} the commit phase.| And
|所以我们回过头来看这张照片

39
00:01:25,500 --> 00:01:26,310
0,180 180,330 330,480 480,720 720,810
so we look back at

40
00:01:26,310 --> 00:01:28,560
0,300 330,1050 1050,1620 1830,1950 1950,2250
this picture here,| you know
|你知道有一个执行阶段，三个对象被读取，三个对象被读取，

41
00:01:28,560 --> 00:01:30,210
0,570 570,720 720,1200 1200,1440 1440,1650
there's an execution phase three

42
00:01:30,210 --> 00:01:31,120
0,450 450,810
objects being,

43
00:01:32,240 --> 00:01:34,310
0,540 570,780 780,1140 1140,1530 1530,2070
{} three objects being read,|
|

44
00:01:36,520 --> 00:01:38,020
0,180 180,270 270,690 690,1110 1110,1500
you know one from each
你知道每个不同的碎片上都有一个，

45
00:01:38,020 --> 00:01:40,120
0,420 420,720 720,1290 1320,1980 1980,2100
{} different shard,| {} you
|你知道我们有碎片一，碎片二和碎片三，

46
00:01:40,120 --> 00:01:40,930
0,120 120,210 210,300 300,570 570,810
know we have shard one,

47
00:01:40,930 --> 00:01:42,220
0,270 270,510 510,630 630,900 900,1290
shard two and shard three,|
|

48
00:01:42,490 --> 00:01:44,020
0,210 210,420 420,780 780,1260 1260,1530
and every shard has one
每个碎片都有一个备份，

49
00:01:44,020 --> 00:01:45,580
0,420 420,960 990,1170 1170,1440 1440,1560
backup,| so this system could
|因此，这个系统可以容忍一次故障。

50
00:01:45,580 --> 00:01:47,000
0,450 450,690 690,1200
tolerate one failure.|
|

51
00:01:47,890 --> 00:01:49,480
0,420 630,810 810,1080 1080,1170 1170,1590
{} So object to read
所以要读取这两个对象的对象正在被修改，

52
00:01:49,510 --> 00:01:51,340
0,720 930,1170 1170,1380 1380,1710 1710,1830
the the two objects are

53
00:01:51,340 --> 00:01:53,770
0,180 180,870 990,2070 2100,2250 2250,2430
being modified,| as we see
|正如我们在第二个中看到的

54
00:01:53,770 --> 00:01:55,720
0,90 90,150 150,570 990,1440 1440,1950
in the second| and then
|一旦您知道三个对象被读取，两个对象被修改，

55
00:01:55,720 --> 00:01:57,430
0,0 0,840 840,960 960,1170 1170,1710
{} once you know the

56
00:01:57,550 --> 00:01:59,230
0,390 390,720 720,870 870,960 960,1680
{three,objects} {read,and} two {} modified,|
|

57
00:01:59,320 --> 00:02:00,880
0,510 540,1080 1080,1200 1200,1500 1500,1560
the application might decide to
应用程序可能决定提交

58
00:02:00,880 --> 00:02:02,260
0,450 660,870 870,1140 1140,1290 1290,1380
commit| and then so the
|然后，整个提交阶段就开始了，

59
00:02:02,260 --> 00:02:03,460
0,240 240,510 510,780 780,990 990,1200
whole commit phase goes into

60
00:02:03,460 --> 00:02:05,620
0,450 720,1200 1200,1470 1470,1800 1800,2160
action,| this whole story from
|整个故事从第一步到第五步，

61
00:02:05,650 --> 00:02:06,400
0,540
{}

62
00:02:06,620 --> 00:02:08,460
0,360 360,690 690,1020 1020,1560
steps one through five,|
|

63
00:02:09,030 --> 00:02:11,130
0,570 660,840 840,1110 1110,1590 1650,2100
and in step one, {}
在第一步中，事务解除锁定

64
00:02:11,130 --> 00:02:12,210
0,150 150,600 600,870 870,960 960,1080
the transaction takes out of

65
00:02:12,210 --> 00:02:13,770
0,540 540,960 960,1020 1020,1380 1380,1560
locks| on the objects that
|在已经写好的物品上，

66
00:02:13,770 --> 00:02:15,960
0,210 210,600 600,1020 1050,1590 1830,2190
have been written written,| so
|我们在这里可以看到，事务已经写入了两个对象

67
00:02:15,960 --> 00:02:16,860
0,120 120,270 270,660 660,780 780,900
we see here there have

68
00:02:16,860 --> 00:02:17,940
0,180 180,420 420,840 840,930 930,1080
been two objects that have

69
00:02:17,940 --> 00:02:21,180
0,330 720,1650 1800,2160 2160,2640 2820,3240
been {} written to by

70
00:02:21,180 --> 00:02:22,500
0,90 90,660 660,900 900,1110 1110,1320
the transaction| and so we're
|因此，我们将所谓的锁定记录传播给每一位初选学生。

71
00:02:22,500 --> 00:02:24,660
0,630 630,930 930,1170 1170,1500 1500,2160
propagating what's called locked records

72
00:02:24,840 --> 00:02:27,420
0,240 240,1110 1110,1830 1830,2430
{you,know} to every primary.|
|

73
00:02:28,030 --> 00:02:30,190
0,390 390,720 720,1410 1740,2040 2040,2160
So every primary is going
因此，每个主数据库都将拥有该事务的锁定记录，

74
00:02:30,190 --> 00:02:31,660
0,60 60,330 330,840 840,1200 1200,1470
to have a lock record

75
00:02:31,660 --> 00:02:33,520
0,480 510,1560
{for,this} transaction,|
|

76
00:02:33,950 --> 00:02:35,900
0,270 270,750 780,840 840,1290 1290,1950
and for the objects involved
并且对于交易中涉及的对象，

77
00:02:35,930 --> 00:02:38,780
0,300 300,600 600,1260 1710,2280 2280,2850
in the transaction,| so {and,lockg}
|因此和Lockg记录包含对象ID，

78
00:02:38,780 --> 00:02:41,600
0,480 480,1320 1410,1560 1560,2220 2220,2820
records contains an object id,|
|

79
00:02:41,750 --> 00:02:43,700
0,360 360,900 900,990 990,1290 1290,1950
which identifies the object uniquely
其唯一地标识该对象的版本号，

80
00:02:43,820 --> 00:02:45,260
0,240 240,630 630,1170
a version number,|
|

81
00:02:45,720 --> 00:02:47,040
0,180 180,270 270,330 330,960 990,1320
so at the time that
因此，在该事务读取对象时，

82
00:02:47,040 --> 00:02:49,800
0,1260 1260,1770 1770,2070 2070,2220 2220,2760
{} transaction reads an object,|
|

83
00:02:50,100 --> 00:02:51,360
0,270 270,450 450,780 780,930 930,1260
it gets back a version
它会得到一个版本号，

84
00:02:51,360 --> 00:02:53,070
0,540 750,840 840,1080 1080,1260 1260,1710
number,| in fact gets back
|实际上取回了这个64位数字，

85
00:02:53,070 --> 00:02:55,280
0,210 210,990 990,1170 1170,1710
this 64 bit number,|
|

86
00:02:55,710 --> 00:02:57,000
0,420 420,570 570,930 930,1020 1020,1290
which is {top,is} a log
其顶部是对数位，其余是版本号，

87
00:02:57,000 --> 00:02:58,620
0,270 270,480 480,840 840,1200 1200,1620
bit and {the,rest,is} version number,|
|

88
00:02:59,830 --> 00:03:00,980
0,810

89
00:03:01,460 --> 00:03:04,130
0,150 150,540 540,1230 1590,2190 2190,2670
and then a new value.|
然后是一个新的价值。|

90
00:03:08,610 --> 00:03:10,530
0,450 450,900 900,1380 1410,1590 1590,1920
{} So, {} you know
所以，你知道小学一年级和小学二年级将会有，

91
00:03:10,560 --> 00:03:12,000
0,330 330,750 750,870 870,1200 1200,1440
primary one and primary two

92
00:03:12,000 --> 00:03:13,140
0,150 150,300 300,360 360,810 870,1140
is going to have,| primary
|第一个主对象将不得不锁定对象一的记录，

93
00:03:13,140 --> 00:03:13,650
0,120 120,210 210,330 330,390 390,510
one is going to have

94
00:03:13,650 --> 00:03:14,610
0,90 90,330 330,540 540,690 690,960
to lock record for object

95
00:03:14,610 --> 00:03:15,630
0,330 330,690 690,810 810,900 900,1020
one,| primary two is going
|主对象2将必须锁定对象2的主对象，

96
00:03:15,630 --> 00:03:17,010
0,60 60,180 180,270 270,630 660,1380
to have to lock object

97
00:03:17,010 --> 00:03:18,780
0,150 150,600 600,1110 1110,1410 1410,1770
for primary for object two,|
|

98
00:03:19,200 --> 00:03:21,060
0,780 780,960 960,1020 1020,1320 1320,1860
then there's a separate phase
然后有一个单独的阶段用于验证只读操作或操作，

99
00:03:21,390 --> 00:03:23,370
0,270 270,360 360,1200 1200,1740 1770,1980
for the validation of the

100
00:03:23,370 --> 00:03:25,770
0,210 210,810 810,1440 1440,1530 1530,2400
{read-only -} operations or operations,|
|

101
00:03:25,800 --> 00:03:27,240
0,300 330,840 840,930 930,1110 1110,1440
were objects that have only
是只读但没有修改的对象，

102
00:03:27,240 --> 00:03:29,460
0,330 330,450 450,630 630,1320 1710,2220
read, but not modified, {}|
|

103
00:03:29,460 --> 00:03:30,600
0,300 300,420 420,510 510,960 960,1140
as we can see in
正如我们在这些验证步骤中所看到的，

104
00:03:30,600 --> 00:03:33,300
0,540 540,1200 1200,1710 1920,2400 2400,2700
those validation step,| {} the
|虚线表示单面RDMA。

105
00:03:33,300 --> 00:03:35,700
0,360 360,660 660,1230 1230,1800 1800,2400
dotted lines represent one-sided {RDMAs

106
00:03:35,700 --> 00:03:36,260
0,300
-}.|
|

107
00:03:40,640 --> 00:03:42,140
0,480 480,630 630,720 720,960 960,1500
And as we talked about
就像我们周二谈到的，

108
00:03:42,140 --> 00:03:44,540
0,300 300,930 1080,1620 1620,1980 1980,2400
on Tuesday,| those basically involve
|它们基本上不涉及服务器，

109
00:03:44,540 --> 00:03:46,580
0,150 150,510 510,1080 1110,1230 1230,2040
no server involvement,| you know
|您知道，发送者只能从服务器的内存中读取一个对象，

110
00:03:46,940 --> 00:03:48,920
0,450 450,570 570,750 750,1020 1020,1980
sender can just read a

111
00:03:48,920 --> 00:03:49,820
0,60 60,600 600,720 720,810 810,900
an object out of the

112
00:03:49,820 --> 00:03:51,710
0,360 360,510 510,810 810,1410 1590,1890
memory of the server,| which
|在没有中断计算的情况下，它实际上是在服务器上运行的。

113
00:03:51,710 --> 00:03:53,240
0,360 360,720 720,1050 1050,1320 1320,1530
actually have without actually having

114
00:03:53,240 --> 00:03:54,920
0,90 90,840 840,900 900,1500 1500,1680
to interrupt the computation, that's

115
00:03:54,920 --> 00:03:56,120
0,270 270,570 570,660 660,720 720,1200
actually running on the server.|
|

116
00:03:56,990 --> 00:03:57,800
0,150 150,510 510,660 660,720 720,810
So they tend to be
所以它们往往非常快，

117
00:03:57,800 --> 00:03:59,780
0,210 210,660 1080,1800 1800,1860 1860,1980
very fast,| unlike you know
|不像你知道的，我们在这里看到的这些行动，

118
00:03:59,780 --> 00:04:00,830
0,210 210,630 630,750 750,870 870,1050
these operations that we saw

119
00:04:00,830 --> 00:04:02,540
0,570 600,870 870,1050 1050,1320 1320,1710
here,| which are actually write
|它们实际上是写入RDMA。

120
00:04:02,540 --> 00:04:03,680
0,600 600,930
{RDMAs -}.|
|

121
00:04:07,720 --> 00:04:08,500
0,120 120,210 210,420 420,660 660,780
They are cool too,| in
他们也很酷，|在某种意义上，您可以将您知道的内容写入到此日志记录的附加内容中

122
00:04:08,500 --> 00:04:09,520
0,60 60,330 330,750 750,870 870,1020
the sense that you get

123
00:04:09,520 --> 00:04:10,870
0,150 150,570 570,660 660,780 780,1350
to write you know to

124
00:04:10,870 --> 00:04:12,550
0,450 780,1350 1350,1440 1440,1530 1530,1680
the appends you know to

125
00:04:12,550 --> 00:04:13,870
0,180 180,450 450,780 780,1080 1080,1320
this log record| without actually
|在不实际中断服务器的情况下，

126
00:04:13,870 --> 00:04:15,430
0,480 480,570 570,1110 1260,1500 1500,1560
interrupting the server,| but the
|但服务器实际上必须处理这些日志记录

127
00:04:15,430 --> 00:04:16,690
0,330 330,540 540,660 660,750 750,1260
server actually has to process

128
00:04:16,690 --> 00:04:18,940
0,210 210,510 510,1020 1140,1740 1740,2250
these log records| and {}
|以及本例中的服务器，

129
00:04:18,940 --> 00:04:19,870
0,360 360,420 420,720 720,780 780,930
and the server in this

130
00:04:19,870 --> 00:04:21,130
0,360 360,570 570,660 660,870 870,1260
case,| once it actually process
|一旦它实际处理了这些日志记录之一，

131
00:04:21,130 --> 00:04:22,330
0,180 180,240 240,420 420,660 660,1200
one of these log records,|
|

132
00:04:22,600 --> 00:04:23,710
0,420 420,480 480,690 720,1020 1020,1110
{} you know tries to
你知道的，试着把锁打开，

133
00:04:23,710 --> 00:04:24,670
0,210 210,330 330,420 420,720 720,960
take out the lock,| if
|如果它成功地尝试夺取锁，

134
00:04:24,670 --> 00:04:26,110
0,60 60,480 480,720 720,1200 1200,1440
it succeeds trying to take

135
00:04:26,110 --> 00:04:27,400
0,60 60,390 390,900 900,990 990,1290
the lock,| because the version
|因为版本号没有改变

136
00:04:27,400 --> 00:04:28,540
0,210 210,510 510,960 960,1050 1050,1140
number hasn't changed| or to
|或锁定位或没有其他事务获取该锁，

137
00:04:28,540 --> 00:04:30,310
0,450 630,1050 1050,1410 1410,1590 1590,1770
{the,lock} {} bit or no

138
00:04:30,310 --> 00:04:31,870
0,210 210,720 720,1080 1080,1170 1170,1560
other transactions taking the lock,|
|

139
00:04:32,020 --> 00:04:33,640
0,390 390,540 540,720 720,1110 1110,1620
then it will reply back,|
然后它会回复，|

140
00:04:33,670 --> 00:04:35,290
0,150 150,300 300,630 630,1140 1140,1620
you know using another one
你知道，用另一个写RDMA说OK。

141
00:04:35,470 --> 00:04:37,270
0,420 420,570 570,960 960,1500 1500,1800
{} of write RDMA saying

142
00:04:37,270 --> 00:04:37,820
0,450
okay.|
|

143
00:04:38,930 --> 00:04:40,220
0,240 240,630 690,930 930,1110 1110,1290
And so yeah we see
所以，是的，我们在获取锁上看到，

144
00:04:40,220 --> 00:04:42,020
0,180 180,360 360,780 810,1260 1260,1800
that on the acquiring lock,|
|

145
00:04:42,020 --> 00:04:43,670
0,450 450,840 840,990 990,1050 1050,1650
requires action on the server,|
需要在服务器上执行操作，|

146
00:04:43,850 --> 00:04:45,890
0,810 810,870 870,1080 1080,1470 1470,2040
but the {one-sided -} RDMA
但用于读取验证的单边RDMA，

147
00:04:45,890 --> 00:04:48,050
0,180 180,660 690,1500 1500,1740 1740,2160
for reads validation,| doesn't require
|不需要在服务器上执行任何操作。

148
00:04:48,050 --> 00:04:49,220
0,240 240,600 600,720 720,780 780,1170
any action on the server.|
|

149
00:04:50,760 --> 00:04:52,740
0,450 450,960 1050,1290 1290,1530 1530,1980
{} Then, {} there's there,|
然后，就是这样，|

150
00:04:53,850 --> 00:04:55,560
0,900 930,1260 1260,1500 1500,1620 1620,1710
if everything turns out to
如果一切顺利，

151
00:04:55,560 --> 00:04:57,240
0,150 150,660 660,900 900,1200 1200,1680
be okay,| {} so, {}
|因此，事务基本上能够获得这些写锁定

152
00:04:57,360 --> 00:04:59,550
0,450 450,840 840,1140 1140,1560 1680,2190
transactions basically able to obtain

153
00:04:59,550 --> 00:05:01,830
0,300 300,570 570,1050 1050,1560 1560,2280
those write locks| and validate
|并验证您是否知道读取操作，

154
00:05:01,830 --> 00:05:04,950
0,480 480,870 870,1830 1980,2970 2970,3120
{you,know,the} read operations,| {} it
|它实际上做出了承诺的决定

155
00:05:04,950 --> 00:05:06,240
0,270 270,570 570,780 780,1170 1170,1290
actually makes a decision to

156
00:05:06,240 --> 00:05:08,220
0,450 570,870 870,960 960,1440 1470,1980
commit| and to commit {}
|并将其提交给每个备份、对象和更改，

157
00:05:08,220 --> 00:05:11,010
0,660 1020,1650 1680,2040 2040,2670 2670,2790
it a first communicates to

158
00:05:11,010 --> 00:05:12,040
0,240 240,870
every backup,

159
00:05:14,510 --> 00:05:18,000
0,270 270,810 810,1800 2160,2970
the object the change,|
|

160
00:05:18,350 --> 00:05:19,760
0,510 510,690 690,780 780,1050 1050,1410
so write to commit backup
因此写入以提交备份记录。

161
00:05:19,760 --> 00:05:20,940
0,510
record.|
|

162
00:05:26,080 --> 00:05:27,280
0,120 120,450 450,630 630,720 720,1200
It depends that to every,
这取决于每个，对于已修改的对象的备份，

163
00:05:27,280 --> 00:05:29,290
0,450 450,750 750,1170 1200,1860 1860,2010
{} to the backups of

164
00:05:29,290 --> 00:05:31,300
0,480 990,1560 1560,1740 1740,1860 1860,2010
the objects that have been

165
00:05:31,300 --> 00:05:32,920
0,720 720,1170 1170,1230 1230,1410 1410,1620
modified,| again you know it's
|同样，您知道它基本上是日志记录的副本，

166
00:05:32,920 --> 00:05:34,330
0,480 480,540 540,900 900,1020 1020,1410
basically a copy of the

167
00:05:34,360 --> 00:05:36,460
0,480 630,1260 1260,1350 1350,1710 1710,2100
log record,| you know oid
|你知道，OID在那里，版本号在那里，新值在那里。

168
00:05:36,460 --> 00:05:37,750
0,240 240,390 390,630 630,1050 1050,1290
goes in there {the,version} number

169
00:05:37,750 --> 00:05:38,620
0,240 240,420 420,690 690,810 810,870
goes in there and the

170
00:05:38,620 --> 00:05:39,620
0,180 180,600
new value.|
|

171
00:05:42,130 --> 00:05:43,690
0,870 870,990 990,1110 1110,1320 1320,1560
Once you know all the
一旦您知道您知道的所有备份都已报告，

172
00:05:43,690 --> 00:05:47,830
0,750 780,1020 1020,1710 2130,3180 3420,4140
backups {you,know} have have reported,|
|

173
00:05:47,830 --> 00:05:48,580
0,120 120,240 240,480 480,690 690,750
that they actually have a
他们实际上有一件物品的副本，

174
00:05:48,580 --> 00:05:50,380
0,330 330,480 480,810 810,1440 1440,1800
copy of the object,| now
|现在我们基本上处于相当好的状态，

175
00:05:50,380 --> 00:05:51,430
0,300 300,660 660,720 720,900 900,1050
we're basically in pretty good

176
00:05:51,430 --> 00:05:53,170
0,450 450,870 870,1080 1080,1530 1530,1740
shape,| because the primary has
|因为主映像有拷贝，所以备份必须拷贝，

177
00:05:53,170 --> 00:05:54,610
0,600 660,810 810,1170 1170,1350 1350,1440
copy, the backup has to

178
00:05:54,610 --> 00:05:56,350
0,570 690,1020 1020,1110 1110,1500 1500,1740
copy,| [] the primary doesn't
|[]主服务器并不真正知道事务是否已提交，

179
00:05:56,350 --> 00:05:57,340
0,180 180,390 390,480 480,540 540,990
really know if the transaction

180
00:05:57,340 --> 00:05:58,720
0,150 150,390 810,1140 1140,1320 1320,1380
has been committed yet or

181
00:05:58,720 --> 00:05:59,360
0,420
not,|
|

182
00:05:59,560 --> 00:06:01,090
0,240 240,750 780,870 870,1200 1200,1530
and so the final step
因此，最后一步实际上不是协调者或检测协调者写出并提交记录，

183
00:06:01,090 --> 00:06:05,140
0,240 240,480 480,930 930,1470 2910,4050
is not actually the coordinator

184
00:06:05,140 --> 00:06:06,820
0,240 240,690 690,1140 1140,1410 1410,1680
or detection coordinator write out

185
00:06:06,820 --> 00:06:09,120
0,330 510,1230 1260,1530 1530,2070
and commit a record,|
|

186
00:06:09,440 --> 00:06:11,180
0,300 300,480 480,930 930,1440
and commit primary record,|
并提交主记录，|

187
00:06:18,160 --> 00:06:20,530
0,360 360,1230 1290,1770 1800,2250 2250,2370
{} informing the primaries that
通知初选实际进行交易的实际已提交。

188
00:06:20,530 --> 00:06:22,120
0,360 360,600 600,1050 1050,1410 1410,1590
actually do transaction actually has

189
00:06:22,120 --> 00:06:22,960
0,480
committed.|
|

190
00:06:23,450 --> 00:06:24,200
0,300 300,390 390,600 600,690 690,750
And as soon as it
一旦收到其中一个NIC的确认，

191
00:06:24,200 --> 00:06:26,120
0,360 690,900 900,1590 1590,1740 1740,1920
gets an acknowledgement from one

192
00:06:26,120 --> 00:06:27,080
0,90 90,180 180,570 570,660 660,960
of the NICs,| you know
|你知道，由虚线表示的，

193
00:06:27,080 --> 00:06:28,550
0,420 420,540 540,660 660,930 930,1470
indicated by the dotted lines,|
|

194
00:06:28,820 --> 00:06:30,680
0,630 630,810 810,1050 1050,1440 1440,1860
{} it actually reports back
它实际上向应用程序返回报告，

195
00:06:30,710 --> 00:06:32,600
0,300 300,690 690,1320 1320,1650 1650,1890
to the application,| saying that
|说这笔交易。

196
00:06:32,600 --> 00:06:34,320
0,390 390,900 900,1260
the transaction committed.|
|

197
00:06:37,900 --> 00:06:38,830
0,270 270,480 480,570 570,780 780,930
So what we wanna do
所以我们现在要做的是看两个案例，

198
00:06:38,830 --> 00:06:40,240
0,330 330,540 540,870 870,990 990,1410
now is look at two

199
00:06:40,240 --> 00:06:41,830
0,720 840,1260 1260,1350 1350,1530 1530,1590
cases,| one we wanted to
|其中一个我们想更多地讨论一下可串行化，

200
00:06:41,830 --> 00:06:42,700
0,180 180,240 240,450 450,600 600,870
talk a little bit more

201
00:06:42,700 --> 00:06:44,800
0,480 840,1620 1620,1890 1890,1950 1950,2100
about serializability,| just to see
|只是为了看看并发控制是否起作用

202
00:06:44,800 --> 00:06:46,150
0,90 90,180 180,600 600,900 900,1350
if the concurrency control {work,out}|
|

203
00:06:46,150 --> 00:06:46,930
0,90 90,330 330,570 570,750 750,780
and then we'll talk a
然后我们会稍微谈一下容错

204
00:06:46,930 --> 00:06:48,130
0,180 180,330 330,570 570,1080 1080,1200
little bit about {fault,tolerance}| and
|看看容错的故事是否奏效。

205
00:06:48,130 --> 00:06:49,210
0,150 150,270 270,360 360,750 750,1080
see if the {fault,tolerance} story

206
00:06:49,210 --> 00:06:49,940
0,450
{works,out}.|
|

207
00:06:50,840 --> 00:06:52,790
0,660 840,1320 1410,1650 1650,1740 1740,1950
Aha, so let me first
啊哈，那么让我首先从可串行化开始，

208
00:06:52,790 --> 00:06:54,920
0,390 420,780 780,1410 1440,1710 1710,2130
start {} with {} {serializability

209
00:06:54,920 --> 00:06:55,800
0,570
-},|
|

210
00:06:56,480 --> 00:06:57,560
0,300 300,420 420,690 690,930 930,1080
alright, so maybe before doing
好的，所以也许在这么做之前，

211
00:06:57,560 --> 00:06:58,640
0,270 270,360 360,540 540,720 720,1080
that,| let me just ask
|我只想问一问目前有没有什么问题，

212
00:06:58,640 --> 00:07:01,160
0,360 360,1290 1380,1650 1650,2220 2340,2520
if {} any questions so

213
00:07:01,160 --> 00:07:02,960
0,240 240,510 510,1200 1200,1620 1620,1800
far,| or whether everybody should
|或者是否每个人都应该把农场成功地换回你的记忆中。

214
00:07:02,960 --> 00:07:06,080
0,90 90,720 1410,1890 1890,2820 2820,3120
have swapped, successfully swapped FaRM

215
00:07:06,080 --> 00:07:08,030
0,240 240,690 690,1080 1110,1800 1800,1950
back into {} into your

216
00:07:08,030 --> 00:07:08,740
0,600
memories.|
|

217
00:07:12,280 --> 00:07:14,110
0,210 210,390 390,900 930,1470 1470,1830
What does the rectangle mean
长方形在这里是什么意思？

218
00:07:14,110 --> 00:07:15,280
0,480 480,1020
in this?|
|

219
00:07:15,680 --> 00:07:18,680
0,720 1110,1320 1320,1710 1710,2040 2070,3000
Picture?| So what's the rectangle,|
图片?|那么长方形是什么，|

220
00:07:19,010 --> 00:07:20,360
0,150 150,240 240,300 300,990 1020,1350
what does it signify along.|
这意味着什么。|

221
00:07:20,360 --> 00:07:21,700
0,120 120,960
The object.|
该对象。|

222
00:07:22,080 --> 00:07:23,490
0,180 180,300 300,360 360,630 630,1410
Oh, it's an object, okay.|
哦，这是一件物品，好的。|

223
00:07:26,080 --> 00:07:28,540
0,930 1380,1560 1560,1650 1650,1770 1770,2460
Okay, {any -} other questions?|
好的，还有其他问题吗？|

224
00:07:31,320 --> 00:07:33,180
0,240 240,570 690,960 960,1560
Okay, good, let's, {}
好的，很好，让我们从并发性的角度来看一下正确性，

225
00:07:34,200 --> 00:07:36,390
0,480 480,690 690,930 930,1770 1800,2190
{} so let's let's look

226
00:07:36,390 --> 00:07:38,280
0,150 150,660 690,1380 1410,1800 1800,1890
at the correctness from the

227
00:07:38,280 --> 00:07:40,860
0,420 420,1080 1530,2010 2010,2280 2280,2580
concurrency perspective,| {} so the
|所以正确、正确、严格的可序列化。

228
00:07:40,890 --> 00:07:43,080
0,240 240,900 900,1230 1230,1710 1740,2190
correct correctness {} strict {serializability

229
00:07:43,080 --> 00:07:44,080
0,570
-}.|
|

230
00:07:49,230 --> 00:07:50,490
0,210 210,330 330,810 810,960 960,1260
And on Tuesday, we looked
在周二，我们研究了并未真正演变为编写验证的事务，

231
00:07:50,490 --> 00:07:53,220
0,300 480,1140 1140,1770 1770,2100 2100,2730
at {} transaction that {}

232
00:07:53,760 --> 00:07:55,740
0,330 330,600 600,1200 1230,1590 1590,1980
didn't really evolve {} write

233
00:07:55,740 --> 00:07:57,150
0,750 750,990 990,1110 1110,1260 1260,1410
validation,| because there was no
|因为没有对象被读取，而不是写入，

234
00:07:57,150 --> 00:07:59,940
0,540 540,1020 1290,1980 2220,2670 2670,2790
object was {} read, but

235
00:07:59,940 --> 00:08:01,140
0,270 270,420 780,1020 1020,1140 1140,1200
not written,| and so I'm
|所以这一次我要看看另一笔交易，

236
00:08:01,140 --> 00:08:01,860
0,120 120,180 180,330 330,420 420,720
going to look at another

237
00:08:01,860 --> 00:08:03,270
0,480 480,600 600,780 780,1050 1050,1410
transaction this time around,| where
|在那里，实际上是验证阶段，并发挥作用。

238
00:08:03,270 --> 00:08:04,530
0,210 210,270 270,780 780,1110 1110,1260
actually the validation phase and

239
00:08:04,530 --> 00:08:05,360
0,240 240,270 270,660
plays a role.|
|

240
00:08:05,720 --> 00:08:06,440
0,120 120,270 270,450 450,600 600,720
And so we look at
所以我们来看两笔交易，

241
00:08:06,440 --> 00:08:07,660
0,120 120,930
two transactions,|
|

242
00:08:08,350 --> 00:08:09,370
0,390 390,630 630,720 720,900 900,1020
and this is sort of
这就是这个例子，

243
00:08:09,370 --> 00:08:11,740
0,150 150,870 870,1200 1200,1380 1380,2370
this example,| is a classic
|是测试协议是否提供可串行化的经典示例，

244
00:08:11,830 --> 00:08:14,590
0,750 750,870 870,1410 1680,1950 1950,2760
example to test {} whether

245
00:08:14,590 --> 00:08:16,450
0,90 90,510 510,930 930,1650 1710,1860
a protocol provides {serializability,or,not},| of
|当然，它不会被批准，

246
00:08:16,630 --> 00:08:17,260
0,210 210,300 300,450 450,570 570,630
course, it's not going to

247
00:08:17,260 --> 00:08:18,640
0,60 60,690 690,1050 1050,1200 1200,1380
be approved,| but if you're
|但如果你是这些关键的例子之一，

248
00:08:18,640 --> 00:08:20,020
0,210 210,300 300,690 690,900 900,1380
one of these key examples,|
|

249
00:08:20,020 --> 00:08:21,460
0,330 330,720 720,840 840,1080 1080,1440
but generally it's very helpful
但总的来说，这对了解协议是如何工作的非常有帮助，

250
00:08:21,460 --> 00:08:23,410
0,120 120,510 900,1200 1200,1650 1650,1950
to see, to understand how

251
00:08:23,410 --> 00:08:25,780
0,60 60,390 390,840 1470,1620 1620,2370
the protocol works,| the protocol,
|协议，事务是如果x为0，

252
00:08:25,780 --> 00:08:27,310
0,330 330,450 450,900 900,1170 1170,1530
{} the transactions are {if,x,is}

253
00:08:27,310 --> 00:08:28,750
0,660 660,1110 1110,1230 1230,1350 1350,1440
0,| then we're going to
|然后我们会说y到1，

254
00:08:28,750 --> 00:08:30,080
0,120 120,510 510,630 630,1080
say y to 1,|
|

255
00:08:30,490 --> 00:08:32,260
0,270 270,660 660,1110 1110,1260 1260,1770
so if object x 0,
所以如果物体x0，我们会看到物体y1，

256
00:08:32,260 --> 00:08:33,700
0,150 150,330 330,690 690,870 870,1440
we'll see object y 1,|
|

257
00:08:34,000 --> 00:08:35,530
0,120 120,210 210,540 540,1110 1230,1530
which is transaction 2 sort
这与交易2正好相反，

258
00:08:35,530 --> 00:08:37,180
0,60 60,180 180,780 1050,1380 1380,1650
of the opposite,| it looks
|如果y为0，且y为0，则将x设为1。

259
00:08:37,180 --> 00:08:39,760
0,300 300,690 690,990 990,1740 1920,2580
if y is 0, {}

260
00:08:39,760 --> 00:08:41,320
0,270 270,480 480,720 720,1290 1290,1560
and is y 0, set

261
00:08:41,320 --> 00:08:42,180
0,180 180,270 270,570
x to 1.|
|

262
00:08:44,080 --> 00:08:45,040
0,150 150,210 210,450 450,570 570,960
And the reason of this
而之所以会出现这种，

263
00:08:45,040 --> 00:08:46,360
0,390 690,990 990,1110 1110,1170 1170,1320
{sort,of},| this is a good
|这是一个很好的可序列化测试，

264
00:08:46,360 --> 00:08:48,700
0,480 480,600 600,810 810,1650 1830,2340
test for {serializability -}, {}|
|

265
00:08:48,700 --> 00:08:50,380
0,360 360,720 720,960 960,1500 1500,1680
is that either {transaction,1} should
事务1应该在T2之后进行，对吗，

266
00:08:50,380 --> 00:08:51,790
0,150 150,450 450,630 630,930 930,1410
go after {T2 -}, correct,|
|

267
00:08:51,790 --> 00:08:52,720
0,240 240,390 390,600 600,780 780,930
or {T2 -} should go
或者T2应该在T1之后

268
00:08:52,720 --> 00:08:55,420
0,270 270,420 420,900 1260,2070 2250,2700
after {T1 -}| and depending
|根据您运行的顺序，

269
00:08:55,420 --> 00:08:56,410
0,60 60,210 210,420 420,540 540,990
on which order you run,|
|

270
00:08:56,410 --> 00:08:57,820
0,120 120,510 510,840 840,960 960,1410
{you,know} either y is 1,
你知道，要么y是1，要么x是1，

271
00:08:57,880 --> 00:08:59,530
0,240 240,480 480,840 1050,1500 1500,1650
or {x,is} 1,| but you
|但你永远不应该，你永远不应该让结果说x是1，哎呀，x是1，y是1。

272
00:08:59,530 --> 00:09:00,900
0,450 450,630 630,1170
never should have,

273
00:09:01,480 --> 00:09:02,380
0,180 180,420 420,570 570,810 810,900
you never should have the

274
00:09:02,380 --> 00:09:04,150
0,630 690,960 960,1170 1170,1260 1260,1770
outcome said x is 1,

275
00:09:05,150 --> 00:09:06,620
0,420 450,630 630,870 870,990 990,1470
oops, the x is 1,

276
00:09:08,710 --> 00:09:10,000
0,270 270,660 660,960
and {y,is} 1.|
|

277
00:09:11,560 --> 00:09:12,430
0,150 150,300 300,420 420,600 600,870
And that should not be
这应该不是很多，

278
00:09:12,430 --> 00:09:14,890
0,330 330,660 660,1320 1350,1980 1980,2460
a lot,| because definitely violates
|因为这肯定违反了可序列化。

279
00:09:14,890 --> 00:09:16,040
0,150 150,840
{serializability -}.|
|

280
00:09:16,210 --> 00:09:17,380
0,240 240,360 360,510 510,930
Does that make sense?|
这说得通吗？|

281
00:09:22,370 --> 00:09:23,300
0,450 450,570 570,750 750,810 810,930
Okay, so what do we
好的，那么我们要做的就是测试，

282
00:09:23,300 --> 00:09:24,020
0,150 150,210 210,390 390,540 540,720
want to do is to

283
00:09:24,020 --> 00:09:27,350
0,420 450,1230 1260,2310 2400,2850 2850,3330
test,| where {} FaRM {is,actually}
|在农场真正成功的地方，

284
00:09:27,350 --> 00:09:28,380
0,720
successful,|
|

285
00:09:28,810 --> 00:09:30,970
0,870 960,1200 1200,1410 1410,1740 1740,2160
in a, {we,want} to understand
首先，我们想要了解需求，

286
00:09:30,970 --> 00:09:32,740
0,510 510,600 600,1080 1110,1440 1440,1770
requirements,| and indeed a it
|实际上，x是1，y是1是不可能产生的。

287
00:09:32,740 --> 00:09:34,390
0,120 120,300 300,750 750,1050 1410,1650
is not possible that x

288
00:09:34,390 --> 00:09:35,170
0,90 90,420 420,510 510,690 690,780
is 1 and y is

289
00:09:35,170 --> 00:09:37,040
0,390 420,1050 1050,1650
1 get produced.|
|

290
00:09:37,200 --> 00:09:38,400
0,210 210,390 390,840 840,1140 1140,1200
So let's look at the
那么让我们来看看时间表，

291
00:09:38,400 --> 00:09:40,380
0,720 900,1320 1320,1500 1500,1860 1860,1980
timeline,| let's say we're we
|假设我们有T1，这里有T2时间线。

292
00:09:40,380 --> 00:09:41,790
0,210 210,450 450,900 990,1290 1290,1410
have {T1 -}, here we

293
00:09:41,790 --> 00:09:45,460
0,150 150,960 1410,2040 2070,3090
have T2 {} timeline.|
|

294
00:09:46,400 --> 00:09:47,960
0,180 180,330 330,960 1110,1230 1230,1560
So they both you know
所以你知道，他们都处于准备或执行阶段，

295
00:09:48,050 --> 00:09:48,980
0,240 240,450 450,630 630,750 750,930
in their sort of the

296
00:09:48,980 --> 00:09:50,600
0,510 510,660 660,1170 1170,1500 1500,1620
preparation or execution phase, {}|
|

297
00:09:50,600 --> 00:09:52,070
0,300 300,600 600,810 810,1170 1170,1470
both reads these objects,| so
两者都读取这些对象，|所以我们假设他们同时运行，

298
00:09:52,760 --> 00:09:53,840
0,180 180,360 360,480 480,840 840,1080
let's say they run through

299
00:09:53,840 --> 00:09:55,040
0,60 60,810 810,960 960,1080 1080,1200
the concurrently,| we do a
|我们读取x和版本号0，

300
00:09:55,040 --> 00:09:56,450
0,240 240,360 360,870 870,1020 1020,1410
read of x and version

301
00:09:56,450 --> 00:09:57,770
0,210 210,780 870,1080 1080,1230 1230,1320
number 0,| we do a
|我们读取y，版本号为0，

302
00:09:57,770 --> 00:09:58,970
0,180 180,270 270,750 750,930 930,1200
read of y, the version

303
00:09:58,970 --> 00:10:01,060
0,180 180,780 960,1290 1290,1860
number 0,| same here.|
|这里也一样。|

304
00:10:03,760 --> 00:10:05,740
0,540 540,870 870,960 960,1260 1260,1980
{} And of course T1
当然t1会更新y，t2会更新x

305
00:10:05,740 --> 00:10:08,020
0,240 240,690 720,1470 1560,2100 2100,2280
will update y, T2 will

306
00:10:08,020 --> 00:10:10,540
0,780 780,1290 1470,2040 2040,2190 2190,2520
update x| and the base
|而基地在某个点上，你知道，这些开始提交阶段。

307
00:10:10,540 --> 00:10:11,350
0,120 120,270 270,600 600,660 660,810
at some point you know

308
00:10:11,350 --> 00:10:14,080
0,480 510,1290 1290,1350 1350,1800 2130,2730
those start to commit phase.|
|

309
00:10:19,320 --> 00:10:20,970
0,540 540,630 630,750 750,1020 1020,1650
And you know let's {},|
你知道，让我们，|

310
00:10:21,210 --> 00:10:22,180
0,690

311
00:10:22,580 --> 00:10:23,750
0,270 270,480 480,600 600,840 840,1170
so let's say the T1
所以让我们假设第一个开始的T1

312
00:10:23,750 --> 00:10:25,310
0,240 240,510 510,900 900,1140 1140,1560
that starts first| and basically
|基本上抓住了，它需要锁定y，

313
00:10:25,310 --> 00:10:27,080
0,480 480,990 1050,1380 1380,1650 1650,1770
grabs the, it needs to

314
00:10:27,080 --> 00:10:30,410
0,480 510,1290 1650,2460 2550,3060 3060,3330
lock on y,| since it's
|因为它将写成y，

315
00:10:30,410 --> 00:10:31,850
0,120 120,180 180,420 420,840 840,1440
going to be writing y,|
|

316
00:10:32,270 --> 00:10:34,400
0,510 510,690 690,1050 1050,1260 1260,2130
so, let's say x successfully
所以，让我们假设x成功地抓住了锁，y

317
00:10:34,430 --> 00:10:35,750
0,390 390,480 480,750 750,870 870,1320
grab the lock and y|
|

318
00:10:36,260 --> 00:10:37,250
0,210 210,300 300,540 540,840 840,990
and so that actually will
这实际上会在y对象的版本号中设置日志位。

319
00:10:37,250 --> 00:10:39,140
0,480 570,1080 1080,1410 1410,1770 1800,1890
set the log bit you

320
00:10:39,140 --> 00:10:40,760
0,330 330,420 420,750 750,1230 1230,1620
in the version number of

321
00:10:40,760 --> 00:10:43,040
0,510 810,1560 1560,2160
the y object.|
|

322
00:10:43,840 --> 00:10:46,060
0,570 1050,1230 1230,1800 1800,1950 1950,2220
{} And then let's say
然后我们假设你知道，实际上，

323
00:10:46,060 --> 00:10:47,680
0,210 210,840 1080,1380 1380,1500 1500,1620
{you,know} actually,| since it's going
|因为它要写成，

324
00:10:47,680 --> 00:10:49,150
0,120 120,600 690,900 900,1230 1230,1470
to read,| it has read
|它已经读取了x，

325
00:10:49,150 --> 00:10:50,950
0,390 390,510 510,600 600,780 780,1800
x,| but it's not as
|但它并不像X所说的那样

326
00:10:51,850 --> 00:10:53,020
0,390 390,630 630,780 780,990 990,1170
read x,| but it's not
|但它不是在修改x，而是在验证x，

327
00:10:53,020 --> 00:10:54,850
0,480 480,720 720,1110 1110,1260 1260,1830
modifying x, but the validation

328
00:10:54,850 --> 00:10:55,760
0,120 120,660
of x,|
|

329
00:10:56,780 --> 00:10:58,220
0,540 540,660 660,780 780,1260 1260,1440
{} you know x was
你知道x读的是版本号0，

330
00:10:58,220 --> 00:11:00,890
0,360 360,630 630,840 840,1440 1710,2670
read version number 0 {},|
|

331
00:11:01,430 --> 00:11:04,910
0,780 870,2040 2190,2970 2970,3300 3300,3480
the {you,know} {at,validation} five,| so
你知道，在第五次验证会上，|所以实际上x并没有改变，

332
00:11:04,910 --> 00:11:06,230
0,300 300,570 570,780 780,1110 1110,1320
nothing actually has changed {}

333
00:11:06,230 --> 00:11:07,730
0,150 150,600 600,930 930,1320 1320,1500
with x,| that version number
|那里的版本号仍然是0，

334
00:11:07,730 --> 00:11:09,920
0,540 600,1020 1020,1380 1380,1800 1800,2190
still 0 there,| {you,know} we're
|你知道我们是按这个顺序被处决的

335
00:11:09,920 --> 00:11:11,210
0,120 120,570 570,660 660,780 780,1290
an executed in this order|
|

336
00:11:11,510 --> 00:11:13,760
0,510 510,990 1020,1500 1500,1650 1770,2250
and so things are {sort,of}
所以一切都很好，

337
00:11:13,760 --> 00:11:15,890
0,150 150,660 930,1680 1920,2040 2040,2130
are fine,| and you know
|你知道，在某个时候，你知道这笔交易可能会提交。

338
00:11:15,890 --> 00:11:16,640
0,90 90,210 210,540 540,660 660,750
at some point, you know

339
00:11:16,640 --> 00:11:18,680
0,180 180,780 780,1140 1170,1560 1560,2040
this transaction {} might commit.|
|

340
00:11:19,970 --> 00:11:21,080
0,180 180,330 330,510 510,900 900,1110
So let's look at {T2
那么让我们来看看T2，

341
00:11:21,080 --> 00:11:23,720
0,570 600,1290 1320,1590 1590,2070 2400,2640
-},| {} let's say {you,know}
|假设你知道t2在x的验证之后运行，

342
00:11:23,720 --> 00:11:25,660
0,870 990,1650
T2 {}

343
00:11:25,850 --> 00:11:27,440
0,540 540,900 900,990 990,1500 1500,1590
runs after the validation of

344
00:11:27,440 --> 00:11:28,550
0,300 300,420 420,660 660,1020 1020,1110
x,| so it grabs the
|所以它抓住了锁，

345
00:11:28,550 --> 00:11:29,420
0,540
lock,|
|

346
00:11:30,260 --> 00:11:33,860
0,990 990,1590 1620,2400 2940,3120 3120,3600
{} and {} and then
然后你知道，它已经写成了y，

347
00:11:34,040 --> 00:11:35,870
0,150 150,420 420,930 960,1530 1530,1830
you know the, it has

348
00:11:35,870 --> 00:11:36,890
0,300 300,600 600,750 750,810 810,1020
read y,| so it needs
|所以它需要对y进行验证。

349
00:11:36,890 --> 00:11:37,880
0,60 60,180 180,240 240,840 840,990
to do a validation of

350
00:11:37,880 --> 00:11:38,560
0,420
y.|
|

351
00:11:38,950 --> 00:11:40,540
0,360 360,480 480,540 540,1080 1080,1590
That's going to do a
这将对y进行验证

352
00:11:40,540 --> 00:11:43,210
0,480 480,570 570,1050 1500,2310 2400,2670
validation of y| and {}
|问题是，验证是否会成功。

353
00:11:43,210 --> 00:11:45,250
0,120 120,480 480,900 900,1530 1740,2040
the question is, {} is

354
00:11:45,250 --> 00:11:46,810
0,330 330,840 840,1080 1080,1470 1470,1560
that validation could succeed or

355
00:11:46,810 --> 00:11:47,480
0,390
not.|
|

356
00:11:51,800 --> 00:11:53,990
0,600 630,1410 1440,1620 1620,2070 2070,2190
No, because the previous the
否，因为之前的另一个操作已允许修改值，

357
00:11:53,990 --> 00:11:56,120
0,240 240,900 900,1110 1110,1500 1500,2130
other operation has allowed modified

358
00:11:56,120 --> 00:11:57,020
0,300 300,480 480,630 630,780 780,900
value,| so it's not the
|所以这不一样，

359
00:11:57,020 --> 00:12:00,020
0,390 390,600 600,900 930,1800 2760,3000
same,| that was {originally,read}.| {Yeah,so}
|这是最初阅读的内容。|是啊，所以版本号可能还是一样的，

360
00:12:00,020 --> 00:12:01,130
0,360 360,630 630,840 840,990 990,1110
the version numbers might be

361
00:12:01,130 --> 00:12:02,420
0,120 120,330 330,420 420,780 780,1290
{} still the same,| but
|但是y，如果t1[]已经设置了对象y的锁位

362
00:12:02,420 --> 00:12:03,830
0,390 390,750 750,930 930,1140 1140,1410
y, if you T1 []

363
00:12:03,830 --> 00:12:05,180
0,180 180,420 420,750 750,1080 1080,1350
has set the lock bit,

364
00:12:05,330 --> 00:12:07,040
0,300 300,660 660,780 780,1200 1200,1710
right, for the object y|
|

365
00:12:07,250 --> 00:12:08,090
0,120 120,240 240,360 360,510 510,840
and so at this point,
因此，在这一点上，这个验证将失败，

366
00:12:08,090 --> 00:12:09,620
0,150 150,690 690,840 840,1380
this validation will fail,|
|

367
00:12:10,860 --> 00:12:12,210
0,330 330,480 480,720 720,780 780,1350
because it's not the same,|
因为这不一样，|

368
00:12:12,300 --> 00:12:14,160
0,660 660,1110 1110,1140 1320,1770 1770,1860
{} {} a lot of
其中很多都已经设定好了，

369
00:12:14,160 --> 00:12:15,420
0,120 120,270 270,390 390,780 1020,1260
it has been set,| so
|因此，对于T2事务，T2事务将中止。

370
00:12:15,420 --> 00:12:16,620
0,180 180,480 480,600 600,1080 1080,1200
to T2 {} transaction, the

371
00:12:16,620 --> 00:12:18,340
0,330 330,960 960,1470
T2 {transaction,will} abort.|
|

372
00:12:19,810 --> 00:12:21,740
0,660 960,1110 1110,1230 1230,1590
Okay, {does,that} makes sense?|
好吧，这说得通吗？|

373
00:12:22,990 --> 00:12:23,530
0,180 180,270 270,390 390,450 450,540
So we see you at
所以我们至少在这个特定的例子中看到了你，

374
00:12:23,530 --> 00:12:24,820
0,180 180,240 240,390 390,720 720,1290
least in this particular example,|
|

375
00:12:24,880 --> 00:12:26,980
0,360 360,480 480,1560 1560,1980 1980,2100
that you know it is
你知道情况就是这样，

376
00:12:26,980 --> 00:12:28,000
0,90 90,360 360,570 570,930 930,1020
the case,| that T1 and
|T1和T2都没有承诺，

377
00:12:28,000 --> 00:12:29,440
0,180 180,390 390,780 780,1020 1020,1440
{T2 -} both don't commit,|
|

378
00:12:29,470 --> 00:12:30,820
0,240 240,450 450,900 900,1020 1020,1350
which would result in this
这将导致这个不正确的结果。

379
00:12:30,820 --> 00:12:32,180
0,210 210,690 690,1080
{} incorrect outcome.|
|

380
00:12:34,920 --> 00:12:36,360
0,240 240,600 600,810 810,1170
Any questions about this?|
对此有什么问题吗？|

381
00:12:39,540 --> 00:12:40,740
0,240 240,480 480,600 600,660 660,1200
I I had a question.|
我我有个问题。|

382
00:12:41,560 --> 00:12:42,360
0,690
Yeah.|
嗯。|

383
00:12:42,760 --> 00:12:45,160
0,270 270,570 570,1110 1800,2130 2130,2400
Yeah, so, {} like for
是的，所以，就像交易一样，

384
00:12:45,160 --> 00:12:47,980
0,150 150,270 270,1320 1650,2130 2160,2820
for the transactions,| so these
|所以这些就像是更新事务一样，

385
00:12:47,980 --> 00:12:49,600
0,180 180,840 900,1080 1080,1500 1500,1620
are like these have to

386
00:12:49,600 --> 00:12:51,640
0,90 90,270 270,810 810,1500 1530,2040
be like update transaction,| like
|就像重写正确读取一样，

387
00:12:51,640 --> 00:12:55,020
0,840 1200,1860 2160,3120
rewrite correct read,|
|

388
00:12:55,310 --> 00:12:57,320
0,390 390,660 660,930 930,1260
it couldn't do it.|
它无法做到这一点。|

389
00:12:57,580 --> 00:12:58,520
0,180 180,270 270,600
Yeah, go ahead.|
好的，去吧。|

390
00:12:58,620 --> 00:13:00,270
0,390 390,540 540,780 780,1050 1050,1650
I I just wonder if
我我只是在想，如果他们像读操作一样，你可以这样做，像日志释放，对吧，

391
00:13:00,270 --> 00:13:02,310
0,180 180,300 300,570 570,990 1020,2040
they were like read operations,

392
00:13:02,310 --> 00:13:03,390
0,150 150,300 300,450 450,780 810,1080
you could do that, like

393
00:13:03,390 --> 00:13:05,190
0,450 450,690 690,1140 1530,1650 1650,1800
log free, right,| and as
|而且只要。

394
00:13:05,190 --> 00:13:06,930
0,180 180,360 360,810 990,1560 1560,1740
long as the.| Yeah, so
|是的，所以这实际上是，让我们回到这张照片上，对吧，

395
00:13:06,930 --> 00:13:08,010
0,180 180,300 300,750 750,960 960,1080
this is actually, let's go

396
00:13:08,010 --> 00:13:09,300
0,300 300,390 390,570 570,870 870,1290
back to this picture here,

397
00:13:09,300 --> 00:13:10,320
0,210 210,360 360,600 600,840 840,1020
right,| then let's look at
|那么让我们来看一下，比如说，这个事务中根本没有涉及写入，对吧，

398
00:13:10,320 --> 00:13:11,850
0,570 780,1020 1020,1260 1260,1380 1380,1530
the, let's say, there were

399
00:13:11,850 --> 00:13:12,960
0,270 270,540 540,930 930,990 990,1110
no writes involved in this

400
00:13:12,960 --> 00:13:14,550
0,480 480,600 600,960 1020,1440 1440,1590
transaction at all, right,| so
|因此，例如，这两个显而易见的概念被正确解读

401
00:13:14,550 --> 00:13:15,660
0,60 60,480 480,570 570,780 780,1110
for example the two obvious

402
00:13:15,660 --> 00:13:16,830
0,180 180,390 390,630 630,990 990,1170
have been read correct| or
|或者储存在你知道的P1和P2。

403
00:13:16,830 --> 00:13:18,210
0,420 780,870 870,990 990,1170 1170,1380
{store,at} you know {P1 -}

404
00:13:18,210 --> 00:13:19,160
0,90 90,570
and P2.|
|

405
00:13:19,830 --> 00:13:20,940
0,240 240,390 390,540 540,990 990,1110
{} So let's assume that
所以让我们假设这些人实际上并没有参与，

406
00:13:20,940 --> 00:13:21,840
0,150 150,360 360,450 450,690 690,900
these guys are actually not

407
00:13:21,840 --> 00:13:23,880
0,600 630,1560 1560,1710 1710,1830 1830,2040
involved,| so {those,objects} were not
|所以这些物品不是写出来的，

408
00:13:23,880 --> 00:13:25,770
0,210 210,360 360,570 570,1110 1110,1890
written,| so the only operation
|因此，发生的唯一操作是对该对象进行读取。

409
00:13:25,770 --> 00:13:26,940
0,150 150,540 540,630 630,1080 1080,1170
that's happening is read with

410
00:13:26,940 --> 00:13:27,840
0,150 150,720
that object.|
|

411
00:13:28,010 --> 00:13:30,320
0,300 300,420 420,990 1020,1500 1500,2310
And you see in {}
你可以看到，协议是精心设计的，

412
00:13:30,320 --> 00:13:31,550
0,150 150,270 270,390 390,780 780,1230
and so the protocols carefully

413
00:13:31,550 --> 00:13:33,470
0,630 1020,1200 1200,1380 1380,1770 1770,1920
designed,| so that if you
|所以如果你只做阅读，

414
00:13:33,470 --> 00:13:35,150
0,240 240,420 420,990 1200,1380 1380,1680
only do reads,| you only
|你在RDMA上只做单边的，对吗，

415
00:13:35,150 --> 00:13:36,680
0,90 90,390 390,720 720,990 990,1530
do {one-sided -} at {RDMAs

416
00:13:36,680 --> 00:13:37,540
0,120 120,570
-}, correct,|
|

417
00:13:37,900 --> 00:13:39,460
0,420 420,720 720,930 930,1020 1020,1560
{} here in the execution
在这里的执行阶段

418
00:13:39,460 --> 00:13:40,900
0,480 480,630 630,960 960,1350 1350,1440
phase| and one RDMA {
|和一个RDMA来进行验证，

419
00:13:40,900 --> 00:13:42,100
0,210 210,360 360,510 510,630 630,1200
-} to do the validation,|
|

420
00:13:43,720 --> 00:13:45,700
0,690 810,1320 1320,1620 1620,1680 1680,1980
and no locks are taken
而且没有锁被拿出来，

421
00:13:45,700 --> 00:13:47,020
0,360 390,720 720,1020 1020,1110 1110,1320
out,| no writes are being
|未执行任何写入，

422
00:13:47,020 --> 00:13:48,430
0,390 420,720 720,1020 1020,1200 1200,1410
done,| no records are being
|没有附加任何记录，

423
00:13:48,430 --> 00:13:49,870
0,570 630,840 840,960 960,1290 1290,1440
appended,| that's the only thing
|这是唯一会发生的事情。

424
00:13:49,870 --> 00:13:50,760
0,120 120,720
that happens.|
|

425
00:13:51,880 --> 00:13:52,990
0,360 360,660 660,870 870,930 930,1110
And so this is one
所以这是农场的一个很酷的特点，

426
00:13:52,990 --> 00:13:54,910
0,120 120,330 690,1260 1260,1650 1650,1920
of the cool features about

427
00:13:54,910 --> 00:13:57,400
0,540 720,930 930,1140 1140,1620 1680,2490
FaRM,| is that these transactions
|这些只进行读取的事务，

428
00:13:57,400 --> 00:13:59,320
0,180 180,450 450,660 660,1320 1620,1920
that only do reads, {}|
|

429
00:13:59,320 --> 00:14:02,020
0,210 210,360 360,1140 1140,1830 2100,2700
can be executed without, {}
可以在没有RDMA的情况下执行，仅使用单侧RDMA

430
00:14:02,050 --> 00:14:03,760
0,300 300,960 990,1200 1200,1410 1410,1710
with only {} {one-sided -}

431
00:14:03,760 --> 00:14:07,120
0,630 630,960 1110,1860 2010,2490 2490,3360
{RDMAs -}| and {} only
|并且不写入任何锁或抓取锁

432
00:14:07,330 --> 00:14:08,650
0,270 270,450 450,840 840,1200 1200,1320
{} with no writes to

433
00:14:08,650 --> 00:14:11,230
0,600 600,1020 1260,1830 1830,2010 2010,2580
any {} locks or grabbing

434
00:14:11,230 --> 00:14:12,550
0,480 480,720 720,840 840,1020 1020,1320
locks| and so that's why
|这就是为什么它们能获得极高性能的原因之一。

435
00:14:12,550 --> 00:14:13,510
0,270 270,540 540,690 690,780 780,960
one reason that they get

436
00:14:13,510 --> 00:14:15,000
0,510 510,720 720,1410
extremely high performance.|
|

437
00:14:16,150 --> 00:14:16,900
0,210 210,330 330,420 420,630 630,750
And this is also the
这也是为什么，

438
00:14:16,900 --> 00:14:19,090
0,360 360,750 750,870 870,1500 1620,2190
reason why,| for example the
|例如锁定阶段、锁定步骤和验证步骤是两个不同的事情，

439
00:14:19,120 --> 00:14:21,610
0,480 480,900 900,1050 1050,2010 2280,2490
lock phase, the {lock,step} and

440
00:14:21,610 --> 00:14:23,080
0,480 480,810 810,870 870,1080 1080,1470
validation steps are two separate

441
00:14:23,080 --> 00:14:25,360
0,480 480,1050 1290,1650 1650,2070 2070,2280
things,| because {} in for
|因为在只读事务中，没有锁定步骤。

442
00:14:25,360 --> 00:14:26,980
0,240 240,480 480,1200 1230,1470 1470,1620
{read-only -} transactions, there's no

443
00:14:26,980 --> 00:14:28,100
0,390 420,960
lock step.|
|

444
00:14:31,030 --> 00:14:31,960
0,630
Okay?|
好吧?|

445
00:14:32,680 --> 00:14:34,720
0,450 450,720 720,1440 1440,1620 1620,2040
Actually, a question on that,|
事实上，关于这个问题，|

446
00:14:35,200 --> 00:14:38,050
0,540 1140,1590 1590,1860 1860,2100 2100,2850
{} for {read-only -} transactions,|
对于只读事务，|

447
00:14:38,050 --> 00:14:38,950
0,360 360,480 480,570 570,810 810,900
why do we need the
为什么我们需要第二个阀门，

448
00:14:38,950 --> 00:14:40,630
0,750 780,1230 1290,1500 1500,1590 1590,1680
second valve,| why do we
|为什么我们需要验证阶段，

449
00:14:40,630 --> 00:14:42,550
0,150 150,240 240,900 900,1410 1650,1920
need the validation phase,| because
|因为你不是喜欢读值吗，

450
00:14:42,550 --> 00:14:43,450
0,180 180,330 330,600 600,840 840,900
aren't you like reading a

451
00:14:43,450 --> 00:14:44,920
0,540 570,720 720,810 810,960 960,1470
value,| and then you're immediately
|然后你立即在它之后进行验证，就像版本一样，

452
00:14:44,920 --> 00:14:46,510
0,630 630,960 960,1290 1290,1410 1410,1590
validating right after it, like

453
00:14:46,510 --> 00:14:47,890
0,120 120,630 660,750 750,1080 1080,1380
the version,| it seems like.|
|看起来像是。|

454
00:14:48,660 --> 00:14:50,100
0,480 480,570 570,660 660,930 930,1440
It could be another transaction,|
可能是另一笔交易，|

455
00:14:50,100 --> 00:14:51,780
0,180 180,420 420,780 780,1110 1110,1680
that has been has modified
已经被修改过的对象，

456
00:14:51,780 --> 00:14:53,490
0,90 90,450 450,750 1080,1410 1440,1710
the object yet,| so if
|因此，如果事务在之前运行或启动并提交，

457
00:14:53,490 --> 00:14:55,890
0,630 630,1110 1440,1620 1620,2220 2220,2400
transaction ran or started and

458
00:14:55,890 --> 00:14:58,860
0,450 450,1380 1710,2370
committed before,| okay,
|好的，并发事务实际写入可能会修改对象，

459
00:14:59,450 --> 00:15:00,950
0,150 150,420 420,900 900,1140 1140,1500
the concurrent transaction actual writes

460
00:15:00,950 --> 00:15:02,460
0,210 210,570 570,690 690,1230
might modify the object,|
|

461
00:15:04,660 --> 00:15:05,860
0,330 330,480 480,600 600,720 720,1200
and now, we'll be back
现在，我们马上回来，

462
00:15:05,920 --> 00:15:10,690
0,270 270,510 510,1170 1260,3690 3930,4770
right,| so the {the,the} transaction
|因此该事务写道，

463
00:15:11,110 --> 00:15:14,020
0,1230 1350,1890 1890,2070 2070,2610 2610,2910
writes,| then the transaction that
|然后实际跟随的事务，你知道，你应该知道，看，观察到最后写。

464
00:15:14,020 --> 00:15:15,550
0,300 300,870 870,1110 1110,1410 1410,1530
actually follows {you,know} should you

465
00:15:15,550 --> 00:15:16,810
0,150 150,420 420,870 870,960 960,1260
know see observed at last

466
00:15:16,810 --> 00:15:17,460
0,420
write.|
|

467
00:15:19,280 --> 00:15:20,090
0,150 150,240 240,420 420,690 690,810
But if they occur at
但如果它们同时发生，

468
00:15:20,090 --> 00:15:21,140
0,90 90,390 390,780 780,960 960,1050
the same time,| then we
|然后我们可以以任何一种方式重新订购它们。

469
00:15:21,140 --> 00:15:22,970
0,210 210,690 690,840 840,1140 1140,1830
can reorder them either way.|
|

470
00:15:23,060 --> 00:15:24,530
0,780 780,840 840,900 900,1140 1140,1470
Exactly at the same time,
就在同一时间，我们重新订购它们，是的。

471
00:15:24,530 --> 00:15:27,650
0,1140 1440,2220 2280,2700 2700,2880 2880,3120
we order reorder them, yeah.|
|

472
00:15:32,300 --> 00:15:33,530
0,270 270,390 390,630 630,1140 1140,1230
So it still seems to
所以在我看来，就像第二种验证一样，

473
00:15:33,530 --> 00:15:35,720
0,120 120,450 450,750 960,1410 1410,2190
me, like the second validation,|
|

474
00:15:35,750 --> 00:15:36,680
0,330 330,450 450,660 660,810 810,930
because the first time you
因为你第一次读它的时候，

475
00:15:36,680 --> 00:15:38,030
0,180 180,420 690,810 810,1080 1080,1350
read it,| the second time
|第二次您只是立即[]，并看到版本是同一计算机，

476
00:15:38,030 --> 00:15:39,560
0,150 150,300 300,930 930,1290 1290,1530
you just immediately [] and

477
00:15:39,560 --> 00:15:40,640
0,240 240,660 660,750 750,870 870,1080
see {the,version} is the same

478
00:15:40,640 --> 00:15:42,080
0,450 570,750 750,960 960,1350 1350,1440
machine,| it still seems to
|在我看来，第二次验证似乎几乎是不必要的。

479
00:15:42,080 --> 00:15:43,400
0,150 150,360 360,450 450,750 750,1320
me like the second validation

480
00:15:43,400 --> 00:15:44,100
0,120 120,450
is like

481
00:15:44,620 --> 00:15:47,320
0,480 510,1410 1800,2040 2040,2040 2040,2700
almost unnecessary.| I I, {}
|我，你可能是对的，

482
00:15:47,320 --> 00:15:48,490
0,150 150,690 690,780 780,1050 1050,1170
you might be right,| I
|我还没好好想过这件事，

483
00:15:48,490 --> 00:15:49,600
0,180 180,420 420,660 660,870 870,1110
haven't thought very hard about

484
00:15:49,600 --> 00:15:50,620
0,180 180,360 360,690 690,1020 1020,1020
this,| that {} if there,
|如果有，如果有事务只是只读事务，

485
00:15:50,620 --> 00:15:53,890
0,1560 2010,2460 2700,3060 3060,3180 3180,3270
{ -} if there are

486
00:15:53,890 --> 00:15:55,270
0,510 510,660 660,960 960,1140 1140,1380
transactions are only {read-only -}

487
00:15:55,270 --> 00:15:56,380
0,570 570,660 660,840 840,1050 1050,1110
transactions,| you know then the
|你知道，那么验证肯定是不必要的，

488
00:15:56,380 --> 00:15:58,180
0,630 630,690 690,1020 1020,1200 1200,1800
validation is definitely not necessary,|
|

489
00:15:58,360 --> 00:15:59,770
0,240 240,450 450,780 780,1140 1140,1410
I have very carefully thought
我非常仔细地考虑过，

490
00:15:59,770 --> 00:16:00,910
0,510 510,720 720,870 870,930 930,1140
about,| when there's a mix
|当有多种交易时，

491
00:16:00,910 --> 00:16:02,650
0,120 120,930 1110,1530 1530,1650 1650,1740
of transactions,| where there is
|在某些情况下，您需要验证。

492
00:16:02,650 --> 00:16:03,370
0,30 30,330 330,450 450,570 570,720
a case where you need

493
00:16:03,370 --> 00:16:04,200
0,60 60,630
the validation.|
|

494
00:16:04,740 --> 00:16:05,970
0,210 210,660 660,930 930,1110 1110,1230
Yeah, what would that be
是啊，如果是这样的话，

495
00:16:05,970 --> 00:16:07,380
0,90 90,450 450,600 600,960 990,1410
the case,| where like you
|就像你有的，如果你读到一个值，

496
00:16:07,380 --> 00:16:08,760
0,450 480,690 690,870 870,1140 1140,1380
have like, if you read

497
00:16:08,760 --> 00:16:09,800
0,60 60,690
a value,|
|

498
00:16:10,020 --> 00:16:11,460
0,480 540,810 810,960 960,1350 1350,1440
{} like you expect to
就像你期望的那样，就像自动读取两个值一样，

499
00:16:11,460 --> 00:16:12,840
0,150 150,300 300,450 450,780 780,1380
read, like two values automatically,|
|

500
00:16:12,840 --> 00:16:14,080
0,270 270,900
read value
读取值在读取值之后，

501
00:16:14,280 --> 00:16:15,480
0,360 360,420 420,600 600,660 660,1200
after you read a value,|
|

502
00:16:15,510 --> 00:16:17,640
0,420 720,990 990,1530 1530,2040 2040,2130
like some transaction modifies the
与某些事务一样，事务修改另一个值。

503
00:16:17,640 --> 00:16:18,760
0,210 210,810
other value.|
|

504
00:16:19,900 --> 00:16:20,950
0,360 360,690 690,750 750,840 840,1050
{} Yeah, it would be
是啊，那只有一种可能。

505
00:16:20,950 --> 00:16:22,000
0,180 180,420 420,840 840,990 990,1050
only one possible.| When it
|当它不起作用时。

506
00:16:22,000 --> 00:16:23,120
0,360
doesn't.|
|

507
00:16:25,160 --> 00:16:26,080
0,630

508
00:16:27,900 --> 00:16:29,100
0,270 270,600 630,750 750,990 1020,1200
Yeah, sure, I'm not, I'm
是的，当然，我不是，我不是很确定，

509
00:16:29,100 --> 00:16:31,020
0,150 150,360 360,870 960,1590 1770,1920
not quite sure,| actually in
|实际上，在这种情况下，如果这是问题所在。

510
00:16:31,020 --> 00:16:31,950
0,180 180,450 450,600 600,840 840,930
that case, if that's the

511
00:16:31,950 --> 00:16:32,780
0,480
problem.|
|

512
00:16:33,210 --> 00:16:34,050
0,240 240,300 300,630 630,690 690,840
Like, for example in this
就像，比如在这种情况下，

513
00:16:34,050 --> 00:16:35,130
0,450 450,540 540,720 720,900 900,1080
case,| you know this {T1
|你知道这个T1和T2的案例，

514
00:16:35,130 --> 00:16:36,240
0,210 210,330 330,480 480,630 630,1110
-} and {T2 -} cases,|
|

515
00:16:36,240 --> 00:16:38,070
0,480 480,930 930,1110 1110,1410 1410,1830
really crucial that y actually
非常关键的一点是y确实做了验证，对吗，

516
00:16:38,070 --> 00:16:39,660
0,210 210,270 270,900 900,1320
does the validation, correct,|
|

517
00:16:41,110 --> 00:16:43,120
0,360 360,780 780,1080 1080,1290 1290,2010
even though actually that transaction
即使实际上，你知道t1只读y，对吧。

518
00:16:43,270 --> 00:16:45,320
0,600 630,1020 1020,1740
{you,know} {T1 -}

519
00:16:45,530 --> 00:16:47,200
0,300 300,660 660,930 930,1380
{} only reads y,

520
00:16:49,800 --> 00:16:50,500
0,420
right.|
|

521
00:16:52,020 --> 00:16:53,300
0,150 150,420 420,870
But what if,
但是，如果交易2正好是x等于1，

522
00:16:53,470 --> 00:16:55,810
0,450 450,1230 1230,1650 1650,1950 1950,2340
{} transaction 2 was just

523
00:16:55,810 --> 00:16:57,730
0,270 270,660 660,1140 1230,1650 1650,1920
x equals 1,| instead of
|而不是没有那句话的LIKE。

524
00:16:57,730 --> 00:16:59,530
0,210 210,540 540,750 750,1350 1470,1800
like without that statement.| {}
|[盲写]。

525
00:16:59,530 --> 00:17:00,600
0,330 330,810
[Blind write].|
|

526
00:17:02,110 --> 00:17:03,610
0,510 810,1080 1080,1170 1170,1260 1260,1500
Hmm?| If it is a
嗯？|如果这是盲写的话。

527
00:17:03,610 --> 00:17:05,350
0,300 300,750 1020,1350 1350,1470 1470,1740
blind write.| Yeah, it's just
|对，它就是x等于1，然后在t1验证后执行。

528
00:17:05,350 --> 00:17:06,580
0,240 240,600 600,900 900,1110 1110,1230
x equals one and then

529
00:17:06,580 --> 00:17:08,770
0,180 180,900 900,1320 1320,1440 1440,2190
it executes after the validation

530
00:17:08,770 --> 00:17:12,430
0,690 750,960 960,1440 2370,2760 2760,3660
of {T1 -}.| {Yeah,that's} {fine,correct}.|
|是啊，很好，没错。|

531
00:17:19,600 --> 00:17:21,040
0,480 480,1050 1050,1200 1200,1350 1350,1440
But whould.| I'm not sure
但是应该怎么做呢？|我不确定问题是什么。

532
00:17:21,040 --> 00:17:22,510
0,90 90,150 150,510 510,870 1110,1470
what the question is.| Oh,
|哦，所以如果T2是公正的，

533
00:17:22,510 --> 00:17:25,120
0,210 210,540 570,1410 1410,2010 2010,2610
so if T2 is is

534
00:17:25,120 --> 00:17:26,830
0,300 300,960 990,1410 1410,1500 1500,1710
just,| like like you know
|就像你知道的，写x等于1，

535
00:17:26,830 --> 00:17:29,080
0,360 360,570 570,960 960,1410 1710,2250
write x equals 1,| within
|在验证步骤内，在借口之后，在T1的验证步骤之后，

536
00:17:29,080 --> 00:17:32,050
0,150 150,810 810,1530 1860,2250 2250,2970
the validation step, after an

537
00:17:32,050 --> 00:17:33,940
0,600 600,930 930,1050 1050,1590 1590,1890
excuse, after the validation step

538
00:17:33,940 --> 00:17:36,070
0,180 180,330 330,870 1110,1590 1590,2130
of {T1 -},| wouldn't then
|那么T1不会认为x等于0吗，

539
00:17:36,280 --> 00:17:39,520
0,1140 1140,1590 1590,2070 2100,2550 2550,3240
T1 think that {x,equals} 0,|
|

540
00:17:39,740 --> 00:17:42,560
0,750 780,1080 1080,1680 1710,2160 2160,2820
but then x becomes 1
但是在提交之前，x变成了1。

541
00:17:42,830 --> 00:17:44,460
0,540 540,630 630,1380
before the commit.|
|

542
00:17:46,740 --> 00:17:48,810
0,960 960,1230 1230,1530 1530,1890 1890,2070
{} Okay, so okay, let
好的，好的，也许我们可以先等一下，

543
00:17:48,810 --> 00:17:49,830
0,360 420,690 690,750 750,870 870,1020
me maybe we can make

544
00:17:49,830 --> 00:17:51,510
0,60 60,570 570,870 870,1260 1260,1680
a {hold,up},| because I gotta
|因为我要重新画出整幅画

545
00:17:51,540 --> 00:17:53,280
0,930 960,1230 1230,1380 1380,1650 1650,1740
redraw the whole picture| and
|弄清楚你所说的场景到底是什么。

546
00:17:53,280 --> 00:17:54,210
0,210 210,330 330,660 660,840 840,930
figure out exactly what the

547
00:17:54,210 --> 00:17:55,780
0,390 390,570 570,900 900,1230
scenario you're talking about.|
|

548
00:17:56,210 --> 00:17:57,530
0,540 630,870 870,1110 1110,1200 1200,1320
Okay, so maybe we can
好的，也许我们可以在最后回到这个问题上。

549
00:17:57,530 --> 00:17:58,250
0,120 120,360 360,420 420,630 630,720
go back to this at

550
00:17:58,250 --> 00:17:59,320
0,120 120,360
the end.|
|

551
00:18:02,390 --> 00:18:03,320
0,300 300,360 360,480 480,570 570,930
Sorry, I had a question,|
抱歉，我有个问题，|

552
00:18:03,320 --> 00:18:04,340
0,120 120,240 240,390 390,720 720,1020
what is the use case
正常交易的用例是什么。

553
00:18:04,340 --> 00:18:06,280
0,330 330,690 690,1620
for normal transaction.|
|

554
00:18:07,330 --> 00:18:12,880
0,1110 1320,3780 3810,4350 4350,4800 4800,5550
{} If {think,back} Spanner and
如果回想一下扳手和这张纸，

555
00:18:12,910 --> 00:18:14,590
0,150 150,600 600,810 810,1440 1470,1680
this paper,| like {} there's
|就像这些工作负载、TPC-C工作负载和TATP工作负载一样，

556
00:18:14,590 --> 00:18:15,970
0,300 300,390 390,960 1050,1230 1230,1380
often the case in these

557
00:18:15,970 --> 00:18:18,910
0,780 1020,1560 1560,1770 1770,2400 2400,2940
workloads, {} the TPC-C workload

558
00:18:18,910 --> 00:18:20,830
0,150 150,240 240,930 930,1440 1440,1920
and the TATP workload,| where
|例如，您知道有一个只读的事务，

559
00:18:20,830 --> 00:18:22,300
0,90 90,210 210,480 480,750 810,1470
you know there's a transaction

560
00:18:22,300 --> 00:18:23,260
0,240 240,450 450,600 600,870 870,960
that only does reads for

561
00:18:23,260 --> 00:18:25,210
0,600 750,1050 1050,1380 1380,1440 1440,1950
example,| I've computed the balances
|我计算了一组账户的余额，

562
00:18:25,210 --> 00:18:26,200
0,90 90,150 150,300 300,390 390,990
of a set of accounts,|
|

563
00:18:26,710 --> 00:18:28,420
0,540 540,660 660,870 870,1380 1380,1710
nothing is being written {},|
什么都没写，|

564
00:18:28,420 --> 00:18:29,260
0,240 240,330 330,570 570,660 660,840
but you know a lot
但你知道很多事情，很多被阅读的账户。

565
00:18:29,260 --> 00:18:29,860
0,60 60,360 360,390 390,540 540,600
of things, a lot of

566
00:18:29,860 --> 00:18:31,100
0,330 330,570 570,840
accounts being read.|
|

567
00:18:33,610 --> 00:18:34,720
0,270 270,1020
Thank you.|
谢谢。|

568
00:18:38,240 --> 00:18:39,410
0,360 390,630 630,750 750,900 900,1170
Okay, so we see here
好的，我们在这里看到，验证阶段是至关重要的，对吧，

569
00:18:39,410 --> 00:18:40,820
0,180 180,390 390,420 420,930 930,1410
there's actually a validation phase

570
00:18:40,820 --> 00:18:42,410
0,60 60,510 510,780 780,1470 1470,1590
is crucial, correct,| T1 and
|T1和t2交易进一步计算出实际计算结果，

571
00:18:42,410 --> 00:18:45,050
0,120 120,420 420,1110 1140,1740 2070,2640
T2 { -} transaction {}

572
00:18:45,050 --> 00:18:46,910
0,690 720,990 990,1200 1200,1650 1650,1860
in {} in furthermore that

573
00:18:46,910 --> 00:18:47,900
0,240 240,480 480,630 630,870 870,990
actually figures out work out,

574
00:18:47,900 --> 00:18:49,670
0,450 450,660 660,780 780,1200 1200,1770
correct,| we get {strict,serializability -},|
|我们得到了严格的可序列化，|

575
00:18:49,670 --> 00:18:50,360
0,60 60,300 300,420 420,510 510,690
of course this is not
当然，这不是证据，

576
00:18:50,360 --> 00:18:51,200
0,60 60,450 450,600 600,660 660,840
a proof,| but it gives
|但它给了你这个例子，试图抓住这个棘手的案例，

577
00:18:51,200 --> 00:18:52,940
0,450 600,1350 1350,1470 1470,1590 1590,1740
you {} you know this

578
00:18:52,940 --> 00:18:54,860
0,540 570,1380 1470,1650 1650,1770 1770,1920
example to try to get

579
00:18:54,860 --> 00:18:56,540
0,90 90,180 180,480 480,1020 1140,1680
at the tricky case, {}|
|

580
00:18:56,540 --> 00:18:57,590
0,150 150,330 330,690 690,780 780,1050
you know actually {} FaRM
你知道吗，实际上农场似乎解决得很好。

581
00:18:57,590 --> 00:18:59,180
0,210 210,330 330,630 630,1050 1050,1590
seems to work out correctly.|
|

582
00:19:00,820 --> 00:19:01,840
0,270 270,720
Okay so,
好的，所以这是关于并发控制的，

583
00:19:02,670 --> 00:19:03,600
0,150 150,420 420,600 600,810 810,930
so that's on the {concurrency

584
00:19:03,600 --> 00:19:05,850
0,300 300,900 1080,1830 1890,2190 2190,2250
-} control,| {} then the
|然后第二部分，

585
00:19:05,850 --> 00:19:07,320
0,300 300,780 840,1170 1170,1350 1350,1470
second part,| {} we want
|我们想谈一谈容错。

586
00:19:07,320 --> 00:19:07,950
0,60 60,180 180,240 240,480 480,630
to talk a little bit

587
00:19:07,950 --> 00:19:09,900
0,360 360,630 630,810 810,1530
about is fault tolerance.|
|

588
00:19:11,220 --> 00:19:12,630
0,330 330,690 870,1080 1080,1260 1260,1410
{} And you really want
你真的想要，不会深入到这里，

589
00:19:12,630 --> 00:19:14,790
0,210 210,480 480,1110 1680,1950 1950,2160
to get the, not gonna

590
00:19:14,790 --> 00:19:15,870
0,240 240,510 510,720 720,810 810,1080
go great amount of depth

591
00:19:15,870 --> 00:19:17,520
0,450 510,840 840,960 960,1230 1260,1650
here,| just want to talk
|我只想谈谈你知道的关键挑战

592
00:19:17,520 --> 00:19:19,890
0,630 900,1410 1830,2010 2010,2130 2130,2370
about the you know key

593
00:19:19,890 --> 00:19:22,800
0,750 960,1530 1530,2310 2310,2460 2460,2910
challenge| and see you know
|看到你所知道的并建立一些直觉，

594
00:19:22,800 --> 00:19:24,600
0,420 420,630 630,780 780,1410 1410,1800
and build some intuition,| why
|为什么我们可能真的希望农场实际上解决了关键的挑战。

595
00:19:24,600 --> 00:19:26,190
0,150 150,420 420,840 870,1080 1080,1590
we might actually be hopeful

596
00:19:26,190 --> 00:19:29,130
0,390 390,990 1350,2010 2010,2490 2490,2940
that {} FaRM actually {}

597
00:19:29,490 --> 00:19:31,120
0,690 690,780 780,960 960,1560
addresses the key challenge.|
|

598
00:19:31,520 --> 00:19:33,530
0,180 180,540 810,1080 1080,1290 1290,2010
And so the key challenge,|
所以关键的挑战是，|

599
00:19:33,950 --> 00:19:35,930
0,750 750,870 990,1260 1260,1710 1710,1980
{} and so we actually
所以我们实际上面临的关键挑战是，在通知应用程序后，实际上会发生崩溃，

600
00:19:35,930 --> 00:19:37,310
0,120 390,540 540,900 900,1230 1230,1380
have the key challenge is

601
00:19:37,310 --> 00:19:41,040
0,450 510,720 720,1350 1380,2580
that there's actually crashes

602
00:19:42,960 --> 00:19:45,140
0,1440
after

603
00:19:45,410 --> 00:19:47,340
0,360 360,480 480,1290
telling the application,|
|

604
00:19:53,880 --> 00:19:54,780
0,330 330,480 480,570 570,810 810,900
and then it has to
然后它必须是这样的，对吧，

605
00:19:54,780 --> 00:19:56,010
0,90 90,180 180,810 840,1110 1110,1230
be the case, right,| that
|事务持续存在。

606
00:19:56,010 --> 00:19:59,560
0,210 210,1020 1350,2160
the transaction persists.|
|

607
00:20:00,410 --> 00:20:01,430
0,330 330,450 450,540 540,930 930,1020
Because we have informed the
因为我们已经通知应用程序事务已提交，

608
00:20:01,430 --> 00:20:02,780
0,570 570,750 750,840 840,1260 1260,1350
application that the transaction is

609
00:20:02,780 --> 00:20:04,010
0,360 360,480 480,600 600,810 810,1230
committed,| so we can actually
|因此，我们实际上可能会丢失事务已完成的所有写入。

610
00:20:04,010 --> 00:20:06,620
0,690 930,1800 1830,2370 2370,2520 2520,2610
lose any writes that the

611
00:20:06,620 --> 00:20:09,080
0,480 480,1080 1080,1380 2160,2340 2340,2460
transaction has done.| And so
|所以我们可以再看一遍这张照片，

612
00:20:09,080 --> 00:20:10,130
0,90 90,450 510,810 810,900 900,1050
we can look at this

613
00:20:10,130 --> 00:20:11,200
0,300 300,810
picture again,|
|

614
00:20:12,120 --> 00:20:13,800
0,330 330,690 690,870 870,1530 1560,1680
and see if we're, going
看看我们是不是会对这种情况抱有希望。

615
00:20:13,800 --> 00:20:14,820
0,60 60,150 150,570 570,720 720,1020
to be hopeful that this

616
00:20:14,820 --> 00:20:15,820
0,120 120,240 240,810
is the case.|
|

617
00:20:22,230 --> 00:20:23,730
0,660 1080,1230 1230,1350 1350,1470 1470,1500
So you know there are
所以你知道你观察到了几件事，

618
00:20:23,730 --> 00:20:25,320
0,30 30,240 240,510 510,870 870,1590
a couple things you observe,|
|

619
00:20:25,350 --> 00:20:27,480
0,750 780,1710 1740,1890 1890,1980 1980,2130
{} after you know the
在您知道锁定阶段之后，

620
00:20:27,480 --> 00:20:28,600
0,270 270,780
lock phase,|
|

621
00:20:29,170 --> 00:20:30,400
0,360 360,510 510,690 690,780 780,1230
{} it is the case
情况是这样的，

622
00:20:30,400 --> 00:20:31,260
0,540
that,|
|

623
00:20:33,200 --> 00:20:34,490
0,330 330,390 390,600 600,1050 1050,1290
after the lock phase,| it's
在锁定阶段之后，|在这种情况下，两个初选数据P1和P2具有锁定记录，

624
00:20:34,490 --> 00:20:35,390
0,90 90,360 360,540 540,690 690,900
the case that the two

625
00:20:35,390 --> 00:20:37,080
0,630 630,810 810,1320
primaries {P1 -}

626
00:20:37,410 --> 00:20:40,110
0,480 480,1140 1560,1800 1800,2190 2190,2700
{and,P2 -} have {a,lock} record,|
|

627
00:20:42,840 --> 00:20:44,670
0,240 240,690 690,810 810,1230 1620,1830
which describes the update,| we
其中描述了更新，|我们真的不知道这笔交易，那份记录没有说明记录是否真的，

628
00:20:44,670 --> 00:20:46,110
0,150 150,330 330,570 570,660 660,1440
don't really know the transaction,

629
00:20:46,650 --> 00:20:48,420
0,240 240,510 510,750 750,1110 1110,1770
that record doesn't say whether

630
00:20:48,420 --> 00:20:51,090
0,420 570,990 990,1560 1560,2310 2310,2670
the record actually,| whether the
|事务是否已提交，

631
00:20:51,180 --> 00:20:53,010
0,510 510,630 630,1110 1200,1710 1710,1830
transaction is committed,| but we
|但我们有关于这笔交易的信息。

632
00:20:53,010 --> 00:20:54,690
0,330 330,870 870,1050 1050,1140 1140,1680
have information about the transaction.|
|

633
00:20:55,950 --> 00:20:57,510
0,570 570,930 930,1170 1170,1470 1470,1560
Then, after this step, to
然后，在此步骤之后，要提交备份步骤，

634
00:20:57,510 --> 00:20:58,980
0,300 300,720 720,1320
commit backup step,|
|

635
00:20:59,170 --> 00:21:00,250
0,240 240,360 360,600 600,960 960,1080
{} we know that you
我们知道您知道备份，您希望B1和B2拥有提交记录。

636
00:21:00,250 --> 00:21:01,840
0,120 120,570 840,1170 1170,1440 1440,1590
know backup you want {B1

637
00:21:01,840 --> 00:21:04,990
0,570 600,900 900,1080 1080,1650 2670,3150
-} and {B2 -} have

638
00:21:04,990 --> 00:21:07,060
0,510 570,930 930,1380
the commit record.|
|

639
00:21:12,690 --> 00:21:14,490
0,210 210,570 570,1530 1560,1650 1650,1800
And then before you know
然后在你知道交易之前，

640
00:21:14,490 --> 00:21:18,450
0,450 780,1620 1950,2340 2340,2760 2760,3960
the transaction,| the transaction coordinator
|事务协调器向应用程序报告，

641
00:21:18,450 --> 00:21:20,250
0,480 480,600 600,720 720,1380 1380,1800
reports to the application,| that
|它必须是成功的，

642
00:21:20,580 --> 00:21:21,510
0,450 450,660 660,780 780,840 840,930
{} it has to be

643
00:21:21,510 --> 00:21:23,490
0,780 810,960 960,1110 1110,1260 1260,1980
successful,| we know that one
|我们知道其中一个初选，

644
00:21:23,520 --> 00:21:25,380
0,120 120,240 240,1080 1290,1680 1680,1860
of the primaries,| let's say
|假设P1也有提交记录。

645
00:21:25,380 --> 00:21:26,820
0,180 180,690 780,1170 1170,1350 1350,1440
{P1 -} also has {}

646
00:21:26,820 --> 00:21:28,140
0,240 240,630
commit record.|
|

647
00:21:34,130 --> 00:21:35,300
0,510 510,600 600,720 720,900 900,1170
So you know let's assume
你知道，让我们假设这里发生了一起撞车事故，

648
00:21:35,300 --> 00:21:36,200
0,120 120,210 210,690 690,780 780,900
there's a crash you know

649
00:21:36,200 --> 00:21:37,580
0,270 270,510 510,990 1020,1260 1260,1380
like right here,| so at
|所以在那个特定的提交点之后，系统崩溃了

650
00:21:37,580 --> 00:21:38,870
0,180 180,630 630,840 840,1110 1110,1290
that particular just after that

651
00:21:38,870 --> 00:21:40,790
0,300 300,690 1080,1200 1200,1500 1500,1920
commit point, you know and

652
00:21:40,790 --> 00:21:42,560
0,90 90,360 360,960 960,1500 1560,1770
the system crashes| and what
|我们想要说服自己的是，

653
00:21:42,560 --> 00:21:43,520
0,90 90,210 210,270 270,540 540,960
we want to convince ourselves

654
00:21:43,520 --> 00:21:45,170
0,300 300,510 510,900 1230,1440 1440,1650
off is that,| {} if
|如果有一次失败，

655
00:21:45,170 --> 00:21:47,000
0,120 120,300 300,1020 1260,1590 1590,1830
there's one failure,| {} we
|我们寻找每一片碎片，实际上一切都是正确的。

656
00:21:47,000 --> 00:21:49,070
0,330 330,810 810,990 990,1500 1680,2070
look for each shard, things

657
00:21:49,070 --> 00:21:50,440
0,300 300,570 570,720 720,1170
actually work out correct.|
|

658
00:21:51,040 --> 00:21:52,570
0,240 240,390 390,720 750,1170 1170,1530
And so the worst case
所以最坏的情况基本上是正确的，那就是B2失败了，

659
00:21:52,570 --> 00:21:55,120
0,480 480,750 750,1230 1470,2310 2340,2550
basically correct is the {B2

660
00:21:55,120 --> 00:21:56,440
0,390 390,1110
-} fails,|
|

661
00:21:58,560 --> 00:21:59,520
0,180 180,420 420,660 660,780 780,960
so here, where is {B2
所以这里，B2在哪里，你知道B2失败了。

662
00:21:59,520 --> 00:22:02,010
0,540 570,1320 1410,1800 1800,2250 2280,2490
-}, {you,know} {B2 -} {B2

663
00:22:02,010 --> 00:22:03,180
0,180 180,900
-} fails.|
|

664
00:22:03,460 --> 00:22:05,170
0,660 660,930 930,1050 1050,1200 1200,1710
{} And so we lose
所以我们失去了你知道的承诺记录，

665
00:22:05,170 --> 00:22:06,340
0,120 120,210 210,420 420,720 720,1170
you know that commit record,|
|

666
00:22:06,370 --> 00:22:08,440
0,270 270,390 390,720 720,1230 1560,2070
that is actually there,| the
它实际上就在那里，|主服务器可能实际上还没有提交记录。

667
00:22:08,470 --> 00:22:10,450
0,660 690,1020 1020,1290 1290,1500 1500,1980
primary might actually have not

668
00:22:10,480 --> 00:22:11,840
0,120 120,450 450,720 720,1080
a commit record yet.|
|

669
00:22:11,930 --> 00:22:13,070
0,420 420,750 750,870 870,960 960,1140
{} Because you know it
因为你知道它在我们看到一个初选的确认后崩溃了，

670
00:22:13,070 --> 00:22:14,360
0,450 450,870 870,930 930,1170 1170,1290
crashed after we see if

671
00:22:14,360 --> 00:22:16,580
0,90 90,570 570,630 630,1290 1560,2220
the acknowledgement of one primary,|
|

672
00:22:16,580 --> 00:22:17,510
0,150 150,330 330,600 600,750 750,930
so let's say that {P1
因此，假设P1实际上必须提交记录。

673
00:22:17,510 --> 00:22:18,800
0,390 390,690 690,990 990,1200 1200,1290
-} must actually have to

674
00:22:18,800 --> 00:22:19,780
0,270 270,660
commit record.|
|

675
00:22:20,330 --> 00:22:21,380
0,300 300,360 360,540 540,930 930,1050
So in this case, {P1
因此在这种情况下，P1必须允许记录，

676
00:22:21,380 --> 00:22:22,730
0,360 360,570 570,630 630,900 900,1350
-} have to permit record,|
|

677
00:22:25,260 --> 00:22:26,400
0,420 420,570 570,750 750,1050 1050,1140
and you know and of
你知道，当然你知道备份已经提交了B1的记录。

678
00:22:26,400 --> 00:22:27,570
0,270 270,360 360,570 570,750 750,1170
course you know the backup

679
00:22:27,570 --> 00:22:29,130
0,360 360,660 660,1080 1110,1440 1440,1560
has committed record for {B1

680
00:22:29,130 --> 00:22:30,080
0,420
-}.|
|

681
00:22:30,410 --> 00:22:31,940
0,180 180,390 390,510 510,780 780,1530
So this is enough information
因此，在康复过程中，这些信息足以让人信服，

682
00:22:31,940 --> 00:22:35,090
0,570 570,1110 1230,1680 1680,2700 2730,3150
correct for convince {} during

683
00:22:35,090 --> 00:22:36,920
0,660 750,960 960,1260 1260,1350 1350,1830
recovery,| that actually the transaction
|该交易实际上已经完成，

684
00:22:36,920 --> 00:22:38,990
0,360 360,930 930,1560 1650,1890 1890,2070
has committed,| because {you,know} we
|因为你知道我们有犯罪记录，

685
00:22:38,990 --> 00:22:40,670
0,390 390,480 480,750 750,1230 1260,1680
have a commit record,| which
|这正是TID所承诺的

686
00:22:40,670 --> 00:22:41,930
0,150 150,330 330,480 480,570 570,1260
is just what the tid

687
00:22:41,930 --> 00:22:44,060
0,180 180,690 1170,1740 1740,1890 1890,2130
that's committed| and we actually
|我们实际上有备份中的所有信息，

688
00:22:44,060 --> 00:22:45,260
0,240 240,450 450,570 570,1110 1110,1200
have all the information at

689
00:22:45,260 --> 00:22:47,900
0,90 90,750 780,1260 1260,1620 2160,2640
the backups,| namely the lock,
|即锁，即描述备份上的写事务的提交记录

690
00:22:47,900 --> 00:22:49,610
0,270 300,600 600,900 900,1110 1110,1710
the commit records which describe

691
00:22:49,610 --> 00:22:52,790
0,450 450,840 840,1830 1950,2730 2730,3180
the write transactions, {} on

692
00:22:52,790 --> 00:22:54,020
0,60 60,450 450,600 600,930 930,1230
the backups| and so during
|因此，在恢复期间，我们实际上有足够的信息来确定事务是否已实际提交。

693
00:22:54,020 --> 00:22:55,520
0,660 720,930 930,1170 1170,1260 1260,1500
recovery, we actually have enough

694
00:22:55,520 --> 00:22:56,990
0,510 510,600 600,1200 1260,1380 1380,1470
information to decide you know

695
00:22:56,990 --> 00:22:58,340
0,150 150,240 240,720 720,1140 1140,1350
that the transaction actually has

696
00:22:58,340 --> 00:22:58,920
0,390
committed.|
|

697
00:23:00,650 --> 00:23:03,200
0,630 900,1320 1320,1560 1560,2280 2340,2550
And so that's sufficient,| yeah,
所以这就足够了，|是的，当然有一个复杂的协议，

698
00:23:03,200 --> 00:23:04,100
0,150 150,360 360,480 480,540 540,900
of course there's a complex

699
00:23:04,100 --> 00:23:05,180
0,450 450,600 600,870 870,1020 1020,1080
protocol,| that actually needs to
|这实际上需要付诸行动

700
00:23:05,180 --> 00:23:06,200
0,180 180,420 420,780 780,870 870,1020
go into action| and sort
|在某种程度上，看看交易留下的所有部分

701
00:23:06,200 --> 00:23:07,010
0,60 60,270 270,360 360,510 510,810
of look at all the

702
00:23:07,130 --> 00:23:08,540
0,570 570,720 720,810 810,1020 1020,1410
pieces that are left behind

703
00:23:08,540 --> 00:23:10,130
0,120 120,210 210,870 1020,1200 1200,1590
by the transaction| with enough
|在为协调器留下足够多的事务的情况下，

704
00:23:10,130 --> 00:23:11,360
0,390 390,570 570,930 930,1110 1110,1230
pieces left behind transaction for

705
00:23:11,360 --> 00:23:13,700
0,90 90,360 360,480 480,1830 1830,2340
the coordinator,| for the new
|对于新的协调员来说，恢复进程决定这一交易实际上已经提交，并且应该是持久的。

706
00:23:13,850 --> 00:23:16,040
0,960 960,1230 1230,1680 1680,2070 2070,2190
coordinator the recovery process to

707
00:23:16,040 --> 00:23:17,660
0,570 570,750 750,990 990,1140 1140,1620
decide that actually this transaction

708
00:23:17,660 --> 00:23:19,430
0,450 450,660 660,1080 1290,1560 1560,1770
indeed has committed and should

709
00:23:19,430 --> 00:23:20,260
0,90 90,690
be persistent.|
|

710
00:23:22,360 --> 00:23:23,240
0,600
Okay?|
好吧?|

711
00:23:30,080 --> 00:23:31,720
0,480 510,1260
Good. {}|
好的。|

712
00:23:31,960 --> 00:23:33,700
0,120 120,240 240,660 660,1170 1170,1740
So let me summarize FaRM|
所以让我总结一下农场|

713
00:23:33,790 --> 00:23:35,860
0,540 780,1440 1440,1740 1740,1830 1830,2070
{} and before we jump
在我们进入关于火花的讨论之前。

714
00:23:35,860 --> 00:23:37,810
0,390 390,630 630,1080 1080,1170 1170,1950
into the discussion of spark.|
|

715
00:23:41,270 --> 00:23:43,010
0,540 690,870 870,1140 1140,1650 1650,1740
So {you,know} top level,| you
所以你知道最高级别，|你知道农场最酷的地方就是速度快，

716
00:23:43,010 --> 00:23:44,360
0,150 150,690 690,810 810,1110 1110,1350
know what's so cool about

717
00:23:44,360 --> 00:23:47,030
0,510 540,990 990,1380 1380,2070 2490,2670
{} FaRM is fast,| it
|它每秒可以执行很多事务。

718
00:23:47,030 --> 00:23:48,440
0,150 150,660 660,930 930,1170 1170,1410
can execute many many, many

719
00:23:48,440 --> 00:23:49,860
0,510 510,600 600,1080
transactions per second.|
|

720
00:23:50,160 --> 00:23:51,480
0,420 420,510 510,600 600,750 750,1320
{} You know there are
你知道，当然你知道农场有一些限制，

721
00:23:51,750 --> 00:23:53,250
0,390 390,900 900,990 990,1410 1410,1500
some restrictions of course you

722
00:23:53,250 --> 00:23:54,930
0,210 210,390 390,420 420,990 1020,1680
know on {} FaRM,| you
|你不能一直这样做。

723
00:23:54,930 --> 00:23:56,880
0,240 240,330 330,570 570,1110 1320,1950
can't do it all {

724
00:23:57,450 --> 00:23:58,660
0,930
-}

725
00:23:58,860 --> 00:24:01,000
0,360 360,450 450,960 1110,1830
all the time. {}|
|

726
00:24:02,060 --> 00:24:03,120
0,270 270,750
{} So,
所以，首先，

727
00:24:03,550 --> 00:24:04,510
0,300 300,390 390,570 570,630 630,960
first of all,| it seems
|似乎很少有冲突，

728
00:24:04,510 --> 00:24:07,320
0,570 810,1920
few conflicts,|
|

729
00:24:08,160 --> 00:24:10,710
0,210 210,540 540,720 720,1530 1560,2550
so use this optimistic {}
所以使用这个乐观的并发控制方案

730
00:24:10,800 --> 00:24:13,110
0,450 450,780 780,1350 2070,2250 2250,2310
concurrency control scheme| and the
|而之所以使用这种乐观的并发控制方案，

731
00:24:13,110 --> 00:24:14,550
0,300 300,450 450,810 810,990 990,1440
reason that uses this optimistic

732
00:24:14,550 --> 00:24:16,020
0,330 330,540 540,840 840,1080 1080,1470
concurrency control scheme,| because want
|因为想把锁拿出来，

733
00:24:16,020 --> 00:24:17,040
0,60 60,270 270,420 420,810 810,1020
to take out locks,| because
|因为它想要做这种单边RDMA，

734
00:24:17,040 --> 00:24:17,670
0,90 90,270 270,360 360,480 480,630
it wants to do this

735
00:24:17,670 --> 00:24:20,190
0,570 570,1530 1590,2040 2040,2340 2340,2520
one-sided RDMA,| without actually any
|实际上不需要任何服务器参与。

736
00:24:20,190 --> 00:24:21,460
0,330 330,1050
server involvement.|
|

737
00:24:21,830 --> 00:24:23,090
0,270 270,450 450,750 750,1170 1170,1260
{} So using optimistic {concurrency
因此使用乐观并发控制方案，

738
00:24:23,090 --> 00:24:25,490
0,390 390,1200 1200,1680 1830,2190 2190,2400
-} control scheme,| {} that
|这意味着，如果你想要一场好的表演

739
00:24:25,490 --> 00:24:27,470
0,330 330,690 690,1440 1560,1830 1830,1980
means that, { -} if

740
00:24:27,470 --> 00:24:28,580
0,120 120,270 270,330 330,600 600,1110
you want a good performance|
|

741
00:24:28,580 --> 00:24:30,740
0,270 270,1050 1050,1500 1500,1890 1890,2160
and avoid transaction boards that
并更好地避免了工作量大的交易板块，

742
00:24:30,740 --> 00:24:32,000
0,90 90,360 360,480 480,930 930,1260
{} {workload -} better,| actually,
|其实，很少有冲突，

743
00:24:32,000 --> 00:24:34,280
0,60 60,930 960,1590 1830,2040 2040,2280
{} {have,few} conflicts,| we're seeing
|我们看到了新的创新，

744
00:24:34,280 --> 00:24:36,050
0,180 180,810 810,1020 1020,1260 1530,1770
new innovation,| there are two
|在交易文献中有两个常用的基准来衡量系统，

745
00:24:36,050 --> 00:24:37,460
0,390 390,1020 1020,1170 1170,1230 1230,1410
common benchmarks that are being

746
00:24:37,460 --> 00:24:39,110
0,390 390,510 510,690 690,1170 1170,1650
used in the transaction literature

747
00:24:39,110 --> 00:24:41,330
0,330 330,510 540,840 840,1380 1710,2220
to {} measure systems,| for
|对于这两个基准，

748
00:24:41,330 --> 00:24:43,190
0,240 240,330 330,1110 1260,1770 1770,1860
those two benchmarks,| {} you
|你很清楚，你做得非常好，

749
00:24:43,190 --> 00:24:44,870
0,180 180,690 690,1050 1050,1230 1230,1680
know clearly as doing extremely

750
00:24:44,870 --> 00:24:46,610
0,510 540,1110 1110,1320 1320,1500 1500,1740
well,| doesn't mean they're not
|并不意味着它们没有那么多冲突。

751
00:24:46,610 --> 00:24:48,420
0,150 150,540 630,1140 1140,1740
that many {} conflicts.|
|

752
00:24:49,770 --> 00:24:50,760
0,240 240,390 390,600 600,930 930,990
{} The second assumption, it
它提出的第二个假设是，

753
00:24:50,760 --> 00:24:51,600
0,270 270,390 390,510 510,570 570,840
makes is that,| the data
|数据必须存储在内存中，

754
00:24:51,600 --> 00:24:53,540
0,240 240,420 420,690 720,1320
must fit in memory,|
|

755
00:24:58,560 --> 00:24:59,580
0,150 150,480 480,720 720,870 870,1020
so it means that if
这意味着如果你有一个非常非常大的数据库，

756
00:24:59,580 --> 00:25:00,840
0,480 510,720 720,750 750,990 990,1260
you have a really really

757
00:25:00,840 --> 00:25:01,950
0,180 180,870 870,960 960,1050 1050,1110
big database,| you have to
|你必须买更多的机器，

758
00:25:01,950 --> 00:25:05,010
0,180 180,390 390,1050 1530,2910 2910,3060
buy more machines,| or if
|或者如果你的数据真的太大了

759
00:25:05,010 --> 00:25:06,870
0,210 210,540 540,1080 1110,1410 1410,1860
you're really the data {too,big}|
|

760
00:25:06,870 --> 00:25:07,350
0,90 90,180 180,300 300,420 420,480
and you don't want to
你不想买更多的机器，

761
00:25:07,350 --> 00:25:08,760
0,150 150,390 390,810 810,1020 1020,1410
buy more machines,| then basically
|那么基本上你不能使用农场

762
00:25:08,760 --> 00:25:10,170
0,90 90,360 360,510 510,990 1230,1410
you can't use FaRM| and
|而且你必须回到更传统的数据库，

763
00:25:10,170 --> 00:25:11,100
0,120 120,240 240,420 450,690 690,930
you have to go back

764
00:25:11,100 --> 00:25:12,540
0,150 150,300 300,480 480,900 900,1440
to {} more traditional database,|
|

765
00:25:12,540 --> 00:25:13,890
0,150 150,450 450,810 810,960 960,1350
that actually has {you,know} persistent
这实际上让您了解了持久存储

766
00:25:13,890 --> 00:25:16,650
0,570 570,1350 1500,1710 1710,1860 1860,2760
storage| and so you can
|因此，您可以在更大的存储设备上读取或写入记录。

767
00:25:16,890 --> 00:25:19,620
0,360 360,510 510,1020 1260,2160 2190,2730
read or write {} record

768
00:25:19,620 --> 00:25:21,630
0,540 540,600 600,870 870,1680 1680,2010
to a much larger storage

769
00:25:21,630 --> 00:25:22,320
0,630
device.|
|

770
00:25:24,420 --> 00:25:27,480
0,810 810,900 900,1500
Replication is only,
复制只是，它只在数据中心内进行。

771
00:25:29,760 --> 00:25:30,900
0,120 120,480 480,810 810,900 900,1140
it's only within the data

772
00:25:30,900 --> 00:25:31,820
0,510
center.|
|

773
00:25:36,520 --> 00:25:38,020
0,180 180,240 240,420 420,990 1140,1500
So in that way, {}
所以这样的话，这样的尊重，

774
00:25:38,020 --> 00:25:39,280
0,60 60,210 210,480 570,1110 1110,1260
in that way, respect,| it's
|它和扳手有很大不同，

775
00:25:39,280 --> 00:25:41,770
0,330 330,720 720,1260 1290,1710 1710,2490
quite different from {} Spanner,|
|

776
00:25:41,770 --> 00:25:42,880
0,90 90,300 300,660 660,930 930,1110
the whole goal, there was
整个目标是在跨数据中心的同步复制中进行同步事务，

777
00:25:42,880 --> 00:25:44,740
0,90 90,450 570,990 990,1530 1530,1860
to do synchronous transactions across

778
00:25:44,740 --> 00:25:47,110
0,60 60,420 420,1020 1020,1740 1830,2370
the synchronous replication across data

779
00:25:47,110 --> 00:25:48,730
0,570 930,1320 1320,1380 1380,1500 1500,1620
centers,| {} you know to
|您知道，要支持应用程序，需要能够生存下来

780
00:25:48,730 --> 00:25:50,470
0,360 360,1020 1020,1320 1320,1680 1680,1740
support applications, that need to

781
00:25:50,470 --> 00:25:53,530
0,120 120,420 420,1050 1110,1920 2280,3060
be able to survive {}|
|

782
00:25:53,530 --> 00:25:55,150
0,240 240,750 750,1230 1230,1410 1410,1620
or continue while some data
或者在一些数据中心停机时继续，

783
00:25:55,150 --> 00:25:56,950
0,300 300,360 360,870 1050,1290 1290,1800
centers are down,| {} indicates
|表明你知道农场不是这样的，

784
00:25:56,950 --> 00:25:58,360
0,450 480,960 960,1110 1110,1230 1230,1410
{you,know} FaRM that is just

785
00:25:58,360 --> 00:26:00,010
0,180 180,270 270,750 840,1440 1440,1650
not the case,| it's not
|它不是针对那些类型的应用程序的。

786
00:26:00,010 --> 00:26:00,970
0,390 390,480 480,660 660,870 870,960
targeted to those kinds of

787
00:26:00,970 --> 00:26:01,760
0,720
applications.|
|

788
00:26:03,860 --> 00:26:05,510
0,150 150,240 240,330 330,900 900,1650
And then the final point
最后一点是，

789
00:26:05,510 --> 00:26:08,220
0,480 660,1050 1050,1920
is,| it requires
|它需要你了解非常奇特或奇异的硬件，

790
00:26:08,770 --> 00:26:11,590
0,450 450,570 570,1260 1710,2550 2550,2820
you know pretty fancy or

791
00:26:11,590 --> 00:26:13,520
0,840
exotic

792
00:26:13,560 --> 00:26:16,620
0,990 1560,1800 1800,2400 2400,2820 2850,3060
hardware,| in particular has two
|尤其是有两样东西，

793
00:26:16,620 --> 00:26:18,960
0,300 300,690 690,1110 1140,1890 1890,2340
things,| this a UPS, []
|这是一款UPS，[]UPS可在完全数据中心故障中幸存下来

794
00:26:18,960 --> 00:26:21,630
0,90 90,630 900,1500 1500,1500 2100,2670
{UPS -} to {} survive

795
00:26:21,630 --> 00:26:24,240
0,360 360,570 570,810 810,1530 1740,2610
complete data center outages| and
|更重要的是，您知道使用这种RDMA网卡，

796
00:26:24,240 --> 00:26:26,040
0,540 540,1170 1170,1290 1290,1440 1440,1800
more importantly you know use

797
00:26:26,040 --> 00:26:28,300
0,210 210,1050 1320,2040
this RDMA NICs,|
|

798
00:26:28,570 --> 00:26:29,740
0,330 330,510 510,750 750,990 990,1170
{you,know} get actually really high
你知道，这真的是很高的表现。

799
00:26:29,740 --> 00:26:30,780
0,780
performance.|
|

800
00:26:35,120 --> 00:26:36,380
0,300 300,450 450,960 960,990 990,1260
Okay, that's all I wanted
好了，关于农场我想说的就是这些，

801
00:26:36,380 --> 00:26:38,620
0,60 60,270 270,930 960,1920
to say about {

802
00:26:39,090 --> 00:26:41,580
0,840 1140,1740 1770,2310 2310,2460 2460,2490
-} FaRM,| unless there are
|除非有任何进一步的问题。

803
00:26:41,580 --> 00:26:43,040
0,330 330,570 570,1230
any further questions.|
|

804
00:26:55,240 --> 00:26:57,370
0,630 780,1320 1410,1530 1530,1650 1650,2130
Okay, {} so that basically
好的，这基本上结束了这张6.824的一套纸或交易方面，

805
00:26:57,370 --> 00:27:00,340
0,540 570,1740 1740,2640
ends { -}

806
00:27:00,540 --> 00:27:03,270
0,270 270,330 330,1740 1740,2010 2010,2730
set of paper or ends

807
00:27:03,270 --> 00:27:06,210
0,480 480,750 750,840 840,2370 2760,2940
transaction side of this {6.824

808
00:27:06,210 --> 00:27:07,650
0,90 90,480 750,930 930,1260 1260,1440
- -},| so we're sort
|所以我们做了三堂关于交易的课

809
00:27:07,650 --> 00:27:09,090
0,90 90,390 390,600 600,990 990,1440
of done three lectures on

810
00:27:09,480 --> 00:27:12,240
0,990 990,1710 1710,1950 1950,2100 2100,2760
transactions| and that was basically
|这基本上就是关于交易的讨论的结束，

811
00:27:12,240 --> 00:27:13,500
0,270 270,360 360,840 840,1080 1080,1260
this is the end of

812
00:27:13,500 --> 00:27:15,360
0,390 390,690 780,1200 1200,1560 1560,1860
talking about transactions,| so will
|也会出现在其他报纸上，

813
00:27:15,360 --> 00:27:16,380
0,210 210,360 360,480 480,660 660,1020
show up in other papers,|
|

814
00:27:16,380 --> 00:27:17,250
0,390 390,510 510,660 660,780 780,870
but we're not going to
但我们不会谈论更多细节，

815
00:27:17,250 --> 00:27:18,630
0,210 210,480 480,810 810,930 930,1380
talk about any more detail,|
|

816
00:27:18,870 --> 00:27:20,460
0,180 180,630 930,1080 1080,1440 1440,1590
in fact we're basically sort
事实上，我们基本上已经谈完了分布式系统中最具挑战性的部分，

817
00:27:20,460 --> 00:27:22,860
0,90 90,510 510,1170 1260,1920 1920,2400
of done with talking about

818
00:27:22,860 --> 00:27:23,370
0,150 150,240 240,390 390,450 450,510
you know sort of the

819
00:27:23,370 --> 00:27:24,720
0,240 240,750 750,1140 1140,1260 1260,1350
most challenging part in the

820
00:27:24,720 --> 00:27:27,060
0,300 300,690 690,1320 1440,2040 2040,2340
distributed systems,| namely building fault
|即构建容错存储系统，

821
00:27:27,060 --> 00:27:29,790
0,270 270,600 600,1260 1530,2130 2130,2730
tolerant storage systems,| {} and
|你知道，我们现在看到了各种不同的设计，

822
00:27:29,790 --> 00:27:31,080
0,90 90,270 270,480 480,690 690,1290
you know we're now seeing

823
00:27:31,170 --> 00:27:32,370
0,210 210,480 480,810 810,930 930,1200
a broad spectrum of different

824
00:27:32,370 --> 00:27:34,200
0,570 570,1110 1110,1560 1560,1710 1710,1830
designs,| including designs that they
|包括它们实际上支持非常强大的事务编程抽象的设计。

825
00:27:34,200 --> 00:27:36,480
0,270 270,510 510,1080 1080,1500 1500,2280
are actually supports very powerful

826
00:27:36,750 --> 00:27:39,300
0,720 720,1320 1320,1710 1740,2490
programming abstraction of transactions.|
|

827
00:27:39,870 --> 00:27:41,760
0,450 450,600 600,660 660,1170 1470,1890
So in the next, this
所以在接下来的这节课里，

828
00:27:41,760 --> 00:27:42,870
0,480 480,540 540,840 840,960 960,1110
lecture,| the remaining of this
|这场演讲的剩余部分以及随后的演讲，

829
00:27:42,870 --> 00:27:45,420
0,390 390,1050 1080,1560 1560,1920 2220,2550
lecture and subsequent lectures,| we're
|我们将讨论不同的主题，

830
00:27:45,420 --> 00:27:46,050
0,120 120,180 180,360 360,450 450,630
going to sort of look

831
00:27:46,050 --> 00:27:47,790
0,90 90,360 360,960 990,1350 1350,1740
at different topics,| {} that
|与存储系统相关的信息。

832
00:27:47,790 --> 00:27:50,010
0,180 180,870 870,1260 1260,1620 1620,2220
were related to storage systems.|
|

833
00:27:51,410 --> 00:27:52,670
0,180 180,330 330,630 630,840 840,1260
And so the first topic,
所以我们要讨论的第一个话题是火花。

834
00:27:53,030 --> 00:27:53,750
0,240 240,390 390,450 450,630 630,720
{} that we're gonna be

835
00:27:53,750 --> 00:27:56,510
0,360 360,840 1200,1890 1890,2640 2640,2760
talking about {} is {}

836
00:27:56,510 --> 00:27:56,898
0,330
spark.

