1
00:00:00,540 --> 00:00:03,090
0,630 630,900 1590,2040 2070,2400 2400,2550
{Okay\,,thank} you.| Okay, so good
好的，谢谢。|好的，下午好，傍晚好，早上好，晚上好，无论你在哪里，

2
00:00:03,090 --> 00:00:04,500
0,360 360,510 510,810 810,960 960,1410
afternoon, good evening, good morning,

3
00:00:04,500 --> 00:00:05,670
0,180 180,420 420,690 690,810 810,1170
good night, wherever you are,|
|

4
00:00:05,850 --> 00:00:07,530
0,750 840,1200 1200,1260 1260,1530 1530,1680
we're going to talk {today
今天我们要谈的是事务。

5
00:00:07,530 --> 00:00:09,440
0,450 450,690 690,1410
-} about transactions.|
|

6
00:00:09,720 --> 00:00:12,570
0,510 930,1200 1200,1440 1440,2040 2040,2850
And you probably noticed,| the
你们可能注意到了，|今天的阅读材料本质上更多是教程，

7
00:00:12,600 --> 00:00:13,770
0,300 300,690 690,810 810,1080 1080,1170
reading material for today a

8
00:00:13,770 --> 00:00:14,850
0,150 150,270 270,420 420,990 990,1080
little bit more tutorial in

9
00:00:14,850 --> 00:00:16,590
0,480 510,990 990,1290 1290,1710 1710,1740
nature,| we're not studying a
|我们不是在研究一个特定的系统，

10
00:00:16,590 --> 00:00:18,480
0,420 420,930 930,1050 1050,1350 1350,1890
particular system,| and see how
|看看一系列的想法是如何在这个系统中实现的，

11
00:00:18,930 --> 00:00:20,970
0,1200 1260,1500 1500,1590 1590,1950 1950,2040
a set of ideas are

12
00:00:20,970 --> 00:00:24,360
0,450 450,1950 1980,2310 2310,2730 2970,3390
implemented {in,that} system,| instead {}
|相反，我们要做的只是谈论事务的概念，

13
00:00:24,360 --> 00:00:25,230
0,240 240,330 330,450 450,570 570,870
what we're gonna be doing

14
00:00:25,230 --> 00:00:27,210
0,150 150,510 510,1050 1080,1680 1680,1980
is talking about {} just

15
00:00:27,210 --> 00:00:29,520
0,60 60,450 450,510 510,1260 1620,2310
the concept of transactions, {}|
|

16
00:00:29,520 --> 00:00:31,710
0,360 360,1230 1440,1710 1710,1950 1950,2190
because it it shows up
因为它会出现在接下来的两个论文中，

17
00:00:31,710 --> 00:00:33,570
0,570 570,840 840,1170 1170,1350 1350,1860
in the next two papers,|
|

18
00:00:33,570 --> 00:00:35,430
0,210 210,420 420,660 660,1200 1560,1860
that we'll be studying those
我们将研究这两篇论文，

19
00:00:35,430 --> 00:00:37,200
0,300 300,630 630,930 930,1260 1260,1770
two papers,| have a quite
|其中有相当多的材料，

20
00:00:37,230 --> 00:00:39,180
0,840 870,1320 1320,1380 1380,1830 1830,1950
a lot of material in

21
00:00:39,180 --> 00:00:41,880
0,270 270,630 630,1320 1320,1890 2130,2700
them,| and assume {} familiar
|假设对事务很熟悉，

22
00:00:41,880 --> 00:00:43,950
0,150 150,930 1050,1500 1500,1650 1650,2070
with transactions,| {} in particular
|特别是你们熟悉我们今天课程中的两个核心思想，

23
00:00:43,950 --> 00:00:45,750
0,150 150,330 330,930 930,1380 1590,1800
that you're familiar with the

24
00:00:45,750 --> 00:00:47,130
0,360 360,660 660,1110 1110,1260 1260,1380
two core ideas that we'll

25
00:00:47,130 --> 00:00:48,930
0,270 270,510 510,900 900,1260 1260,1800
see the today's lecture,| namely
|也就是两阶段锁和两阶段提交，

26
00:00:49,280 --> 00:00:51,340
0,180 180,450 450,840 840,1470
{} {2-phase -} locking

27
00:00:56,240 --> 00:00:58,940
0,750 780,990 990,1260 1260,1710
and {2-phase -} commit,|
|

28
00:01:06,430 --> 00:01:07,780
0,150 150,510 510,630 630,690 690,1350
and sometimes they are abbreviated
有时，它们被缩写， 2PC 表示两阶段提交，

29
00:01:07,780 --> 00:01:09,160
0,180 180,240 240,390 390,630 630,1380
as you know {2PC -}

30
00:01:09,280 --> 00:01:10,750
0,270 270,390 390,630 630,1110 1110,1470
for {2-phase -} commit| and
|2PL 表示两阶段锁，

31
00:01:10,750 --> 00:01:12,610
0,150 150,660 660,1020 1440,1620 1620,1860
{2PL -} for {2-phase -}

32
00:01:12,610 --> 00:01:15,010
0,450 1140,1500 1500,2070 2070,2310 2310,2400
locking,| {} one point of
|有一点令人困惑，

33
00:01:15,010 --> 00:01:17,680
0,720 1020,1560 1560,1860 1860,2280 2280,2670
confusion,| {} the two terms
|这两个术语不需要做太多事情，

34
00:01:17,680 --> 00:01:18,580
0,210 210,510 510,660 660,750 750,900
really don't have to do

35
00:01:18,580 --> 00:01:20,200
0,510 510,750 750,870 870,1290 1320,1620
much,| don't have to, don't
|不需要，

36
00:01:20,200 --> 00:01:21,160
0,390
do,|
|

37
00:01:21,380 --> 00:01:23,000
0,180 180,420 420,900 900,1080 1080,1620
{} really not much related,|
没有什么关系，|

38
00:01:23,030 --> 00:01:25,400
0,510 990,1170 1170,1650 1650,2100 2100,2370
{} you know they happen
他们碰巧有两个词 2-phase ，

39
00:01:25,400 --> 00:01:27,590
0,60 60,360 360,690 690,1740 1980,2190
to have both words two

40
00:01:27,590 --> 00:01:28,670
0,240 240,390 390,720 720,840 840,1080
words {2-phase -} in it,|
|

41
00:01:28,910 --> 00:01:30,320
0,450 450,720 720,990 990,1110 1110,1410
{} but {you,know} they show
但是，它们表现完全不同的问题，

42
00:01:30,320 --> 00:01:32,930
0,420 420,660 660,1290 1320,1830 2160,2610
completely different problems,| {} they
|它们还出现在事务的背景下，

43
00:01:32,930 --> 00:01:33,920
0,330 330,480 480,600 600,780 780,990
they have to also show

44
00:01:33,920 --> 00:01:34,790
0,90 90,390 390,750 750,810 810,870
up on typically in the

45
00:01:34,790 --> 00:01:36,890
0,330 330,390 390,1140 1320,1860 1860,2100
context of transactions,| {} but
|但是即使在事务之外，

46
00:01:36,890 --> 00:01:37,760
0,180 180,300 300,510 510,810 810,870
there are even outside of

47
00:01:37,760 --> 00:01:40,520
0,540 540,840 840,1740 1770,2310 2310,2760
transactions,| they are good ideas
|它们也是好想法或有价值的想法，

48
00:01:40,520 --> 00:01:42,300
0,330 330,690 690,1380
or worthwhile ideas,|
|

49
00:01:42,420 --> 00:01:43,800
0,150 150,510 540,780 780,960 960,1380
and so don't let your
所以不要让你自己被他们都有 2-phase 所迷惑，

50
00:01:44,040 --> 00:01:45,060
0,300 300,600 600,690 690,780 780,1020
self confused by the fact

51
00:01:45,060 --> 00:01:45,720
0,90 90,180 180,420 420,510 510,660
that they both have {2-phase

52
00:01:45,720 --> 00:01:47,190
0,330 330,480 480,690 900,1260 1260,1470
-} in it,| {} they're
|它们没什么关系。

53
00:01:47,190 --> 00:01:49,060
0,750 750,1350
pretty unrelated.|
|

54
00:01:50,090 --> 00:01:51,140
0,240 240,390 390,510 510,630 630,1050
Okay, so I'm just gonna
好的，所以我要稍微深入一点，

55
00:01:51,170 --> 00:01:52,370
0,480 480,570 570,660 660,870 870,1200
dive in a little bit|
|

56
00:01:52,370 --> 00:01:54,110
0,360 360,690 690,960 960,1170 1170,1740
and start talking about transactions
开始谈论一般的事务，

57
00:01:54,110 --> 00:01:57,320
0,180 180,750 1110,1830 2100,2790 2790,3210
in general,| {} and the
|我们非常关注事务的原因是，

58
00:01:57,320 --> 00:01:58,670
0,300 300,450 450,1140 1170,1290 1290,1350
reason that we're going to

59
00:01:58,670 --> 00:02:00,260
0,390 390,600 600,1080 1080,1170 1170,1590
care about transactions a lot

60
00:02:00,440 --> 00:02:02,300
0,180 180,1170 1200,1530 1530,1710 1710,1860
{} is,| {} that we
|我们希望能够进行跨机器操作。

61
00:02:02,300 --> 00:02:02,930
0,150 150,210 210,330 330,540 540,630
want to be able to

62
00:02:02,930 --> 00:02:06,000
0,300 330,900 900,1530 1560,2400
do {cross-machine -} operations.|
|

63
00:02:06,360 --> 00:02:07,350
0,240 240,450 450,810 810,930 930,990
So the problem that we're
所以我们尝试解决的问题，

64
00:02:07,350 --> 00:02:08,700
0,120 120,180 180,390 390,630 660,1350
going to try to tackle|
|

65
00:02:11,220 --> 00:02:12,330
0,180 180,570 570,720 720,960 960,1110
{in,this} lecture as well as
在这个课程以及即将看到的两篇论文中，

66
00:02:12,330 --> 00:02:14,190
0,180 180,630 660,870 870,1260 1260,1860
in the two upcoming papers|
|

67
00:02:14,460 --> 00:02:17,820
0,420 420,780 780,1470
is {cross-machine -}
是跨机器的原子操作。

68
00:02:20,830 --> 00:02:23,480
0,360 360,420 420,1200
{atomic -} ops.|
|

69
00:02:25,890 --> 00:02:27,210
0,540 540,720 720,900 900,960 960,1320
{} And so for example
举个例子，让它变得更具体，

70
00:02:27,210 --> 00:02:27,690
0,180 180,240 240,360 360,450 450,480
just to make it a

71
00:02:27,690 --> 00:02:29,400
0,150 150,270 270,840 870,1500 1500,1710
little bit concrete,| {} let's
|假设我们有一个客户端，

72
00:02:29,400 --> 00:02:30,570
0,120 120,270 270,360 360,450 450,1170
say we have a client,|
|

73
00:02:31,250 --> 00:02:34,040
0,210 210,390 390,660 660,1770 1770,2790
{} we have two, {}|
我们有两个，|

74
00:02:34,700 --> 00:02:35,750
0,180 180,270 270,330 330,840 840,1050
we have a sharded key
我们有一个分片的键值服务器，

75
00:02:35,750 --> 00:02:37,460
0,390 390,960 1020,1230 1230,1470 1470,1710
value server,| {} so some
|所以一些键在键值服务器 1 上，

76
00:02:37,460 --> 00:02:39,260
0,150 150,480 630,1110 1110,1410 1410,1800
of the keys are on

77
00:02:39,260 --> 00:02:41,420
0,150 150,480 480,780 780,1320
key value server 1,|
|

78
00:02:41,840 --> 00:02:43,160
0,300 300,540 540,840 840,1020 1020,1320
some are on key value
一些在键值服务器 2 上，

79
00:02:43,160 --> 00:02:44,620
0,360 360,900
server 2,|
|

80
00:02:44,830 --> 00:02:46,000
0,180 180,300 300,570 570,660 660,1170
so the keys are split
所以键分布在它们上面，

81
00:02:46,030 --> 00:02:47,290
0,450 450,720 720,900 900,960 960,1260
across them,| so for example,
|例如， kv1 有 x ， kv2 有 y ，

82
00:02:47,290 --> 00:02:49,150
0,480 690,1080 1080,1290 1290,1620 1620,1860
maybe {kv1 - -} has

83
00:02:49,150 --> 00:02:51,340
0,390 390,900 900,1380 1380,1590 1590,2190
x, {kv2 -} has y,|
|

84
00:02:51,940 --> 00:02:53,170
0,510 510,660 660,810 810,870 870,1230
and we want to basically
我们想要跨这两个键进行原子操作，

85
00:02:53,170 --> 00:02:54,910
0,180 180,330 330,780 780,1260 1260,1740
want to atomic operation across

86
00:02:54,910 --> 00:02:56,980
0,330 330,630 630,1170 1170,1530 1770,2070
those two keys,| and the
|在事务的背景下，简单的方法或经典的例子

87
00:02:56,980 --> 00:02:58,300
0,300 300,480 480,630 630,810 810,1320
easy way or the classic

88
00:02:58,300 --> 00:03:00,100
0,660 660,1140 1140,1350 1350,1740 1740,1800
example in the context of

89
00:03:00,100 --> 00:03:01,900
0,720 900,1080 1080,1530 1530,1740 1740,1800
transactions| is always doing a
|总是进行转账。

90
00:03:01,900 --> 00:03:02,900
0,600
transfer.|
|

91
00:03:03,290 --> 00:03:04,280
0,180 180,360 360,480 480,570 570,990
So let's say the client
假设客户端想要进行从 x 到 y 的转账，

92
00:03:04,280 --> 00:03:06,140
0,180 180,270 270,690 750,960 960,1860
wants to do a transfer

93
00:03:06,380 --> 00:03:09,500
0,600 630,960 960,1080 1080,1650 2760,3120
from x to y,| {here's,our}
|这是我们的客户端，

94
00:03:09,500 --> 00:03:12,320
0,690 1080,1830 1830,2130 2130,2340 2340,2820
client,| and it's gonna do
|它会对 x 做一次 put ，

95
00:03:12,320 --> 00:03:13,780
0,450 450,960
basically put

96
00:03:14,840 --> 00:03:16,970
0,360 360,540 540,1080 1080,1500 1530,2130
{you,know} to x,| to maybe
|从帐户中增加或减少，

97
00:03:17,000 --> 00:03:20,300
0,660 1080,1740 1770,2310 2310,2490 2490,3300
{} add {} or subtract

98
00:03:20,300 --> 00:03:21,380
0,150 150,270 270,780 780,990 990,1080
from the account,| {so,let's,do} {}
|所以我们做 x,-1 ，

99
00:03:21,380 --> 00:03:23,900
0,240 240,540 540,1080 1710,2010 2010,2520
{x\,-1 - -}| and then
|然后客户端要做 put(y,+1) ，

100
00:03:23,900 --> 00:03:24,560
0,90 90,390 390,480 480,600 600,660
the client is going to

101
00:03:24,560 --> 00:03:27,680
0,210 210,270 270,840 1500,2160 2220,3120
do {} put of {y\,+1

102
00:03:27,890 --> 00:03:29,000
0,270 270,480
- -},|
|

103
00:03:29,430 --> 00:03:31,500
0,690 690,1110 1110,1320 1320,1710 1710,2070
transfer namely one dollar from
从账户 x 向账户 y 转账一美元。

104
00:03:31,500 --> 00:03:32,520
0,120 120,240 240,330 330,720 720,1020
you know the account x

105
00:03:32,520 --> 00:03:35,940
0,210 210,540 540,1530 1530,1950 2940,3420
to the account y.| And
|我们的目标是，

106
00:03:35,940 --> 00:03:36,960
0,180 180,480 480,540 540,900 900,1020
our goal is basically going

107
00:03:36,960 --> 00:03:38,120
0,120 120,630
to be,|
|

108
00:03:40,300 --> 00:03:41,230
0,240 240,360 360,570 570,750 750,930
{you,know} we want {atomicity -
我们希望在故障和并发方面保持原子性。

109
00:03:41,230 --> 00:03:42,360
0,450
-}

110
00:03:44,860 --> 00:03:46,780
0,240 240,660 660,1350
with {respect,to} failures

111
00:03:49,030 --> 00:03:50,600
0,390 390,990
and concurrency.|
|

112
00:03:55,540 --> 00:03:58,120
0,480 510,780 780,1110 1110,1620 1650,2580
{} So even if {}
所以，即使第一个 kv ，

113
00:03:58,120 --> 00:03:59,860
0,150 150,390 480,750 750,1320 1320,1740
you know {} [] {kv

114
00:03:59,860 --> 00:04:00,970
0,300 300,450 450,660 660,900 900,1110
-} {},| the first key
|第一个键值服务器在 put 之后失败，

115
00:04:00,970 --> 00:04:03,280
0,360 360,1020 1020,1380 1380,1740 1740,2310
value server fails after the

116
00:04:03,310 --> 00:04:06,220
0,420 720,1590 1620,2610 2610,2760 2760,2910
put,| {} then we want
|那么我们想要安排，

117
00:04:06,220 --> 00:04:07,450
0,120 120,270 270,600 600,810 810,1230
like to arrange it,| basically
|转账根本不会发生，

118
00:04:07,450 --> 00:04:08,590
0,120 120,510 510,750 750,1020 1020,1140
the transfer didn't happen at

119
00:04:08,590 --> 00:04:10,060
0,270 300,570 570,960 960,1080 1080,1470
all,| so generally the semantics
|所以，我们要寻找的语义是，

120
00:04:10,060 --> 00:04:11,110
0,90 90,180 180,480 480,870 870,1050
that we're looking for is

121
00:04:11,110 --> 00:04:13,180
0,270 300,780 780,1320 1320,1770 1830,2070
that,| both operations happen or
|这两种操作都会发生或者都不会发生。

122
00:04:13,180 --> 00:04:14,620
0,300 300,540 540,630 630,810 810,1440
neither one of them happens.|
|

123
00:04:15,190 --> 00:04:16,540
0,240 240,360 360,870 870,1260 1260,1350
And so, similarly from {}
所以，从并发性的角度来看，

124
00:04:16,540 --> 00:04:18,640
0,360 360,960 960,1320 1320,1740 1740,2100
concurrency perspective,| if another client
|如果另一个客户端正在运行，

125
00:04:18,640 --> 00:04:19,690
0,90 90,390 390,510 510,720 720,1050
is running| and also tries
|并且尝试检查这些帐户，

126
00:04:19,690 --> 00:04:21,460
0,300 300,690 690,810 810,1380 1470,1770
to inspect these accounts,| now
|现在我们想要的是

127
00:04:21,460 --> 00:04:22,150
0,210 210,330 330,420 420,600 600,690
what we would like to

128
00:04:22,150 --> 00:04:23,260
0,210 210,270 270,630 630,750 750,1110
be the case is that,|
|

129
00:04:23,260 --> 00:04:25,930
0,450 450,960 1080,1650 1650,1920 1920,2670
both puts {} show atomically,|
这两个 put 原子地显示，|

130
00:04:25,930 --> 00:04:28,480
0,240 240,570 570,1290 1470,2100 2100,2550
and so other transaction cannot
所以其他事务不能观察到中间结果，

131
00:04:28,510 --> 00:04:30,430
0,510 510,630 630,1170 1170,1590 1590,1920
observe {} intermediate results,| where
|中间结果，

132
00:04:30,430 --> 00:04:32,110
0,90 90,570 570,990 990,1110 1110,1680
{} intermediate result,| for example,
|比如，钱从 x 中减去，

133
00:04:32,170 --> 00:04:33,190
0,180 180,390 390,480 480,930 930,1020
the money is deducted from

134
00:04:33,190 --> 00:04:34,540
0,480 510,630 630,930 930,1050 1050,1350
x,| that hasn't been added
|没有加到 y 上。

135
00:04:34,540 --> 00:04:35,620
0,90 90,300 300,720
to y yet.|
|

136
00:04:36,070 --> 00:04:37,450
0,480 750,930 930,1110 1110,1290 1290,1380
{} So, these are the
所以，这些就是我们想要做的事情，

137
00:04:37,450 --> 00:04:38,260
0,210 210,300 300,540 540,660 660,810
type of things we want

138
00:04:38,260 --> 00:04:39,700
0,60 60,480 660,810 810,930 930,1440
to do| and it's complete
|这在分布式系统中非常常见，

139
00:04:39,700 --> 00:04:41,230
0,450 450,600 600,990 990,1470 1470,1530
common in distributed systems,| you
|比如你希望跨分片执行操作。

140
00:04:41,230 --> 00:04:42,670
0,120 120,300 300,480 480,720 720,1440
know that you would like

141
00:04:42,760 --> 00:04:45,490
0,630 660,1140 1140,1680 1680,2040 2040,2730
to do operation across shards.|
|

142
00:04:48,130 --> 00:04:48,790
0,210 210,360 360,510 510,570 570,660
So that's sort of the
所以，这就是我们想要做的事情的背景，

143
00:04:48,790 --> 00:04:52,180
0,750 2220,2730 2730,3030 3030,3180 3180,3390
context of what we'd like

144
00:04:52,180 --> 00:04:54,040
0,60 60,450 750,1230 1230,1500 1500,1860
to do| and the general
|这样做的总体方案来自数据库社区，

145
00:04:54,040 --> 00:04:55,840
0,480 480,840 840,1110 1110,1440 1440,1800
plan for doing this is

146
00:04:55,840 --> 00:04:57,070
0,240 240,540 540,720 720,810 810,1230
comes directly from the database

147
00:04:57,070 --> 00:04:59,440
0,540 960,1410 1410,1710 1710,2040 2040,2370
community,| {} this general plan
|这个总体方案就是事务。

148
00:04:59,440 --> 00:05:01,220
0,360 390,1350
is transactions.|
|

149
00:05:09,780 --> 00:05:10,800
0,420 420,690 690,810 810,960 960,1020
And what we'd like to
我们想要做的是对这些操作进行分组，

150
00:05:10,800 --> 00:05:13,050
0,270 270,840 870,1590 1590,2100 2100,2250
do is basically group these

151
00:05:13,050 --> 00:05:14,430
0,600 600,810 810,1170 1170,1260 1260,1380
operations,| for example in the
|例如，在转账的情况中，

152
00:05:14,430 --> 00:05:15,570
0,240 240,330 330,420 420,930 930,1140
case with the transfer,| two
|两个 put 操作作为一个事务。

153
00:05:15,570 --> 00:05:17,550
0,300 300,1110 1230,1590 1590,1650 1650,1980
put operations into a single

154
00:05:17,550 --> 00:05:18,700
0,570
transaction.|
|

155
00:05:18,700 --> 00:05:20,020
0,660 660,780 780,990 990,1170 1170,1320
And, {} we like, then
然后，这个事务原子地执行，

156
00:05:20,020 --> 00:05:21,400
0,90 90,540 540,690 690,840 840,1380
the property that this transaction

157
00:05:21,400 --> 00:05:24,100
0,750 870,1920 2130,2430 2430,2550 2550,2700
executes atomically,| so you know
|这通常需要一些编程注解，

158
00:05:24,100 --> 00:05:26,110
0,720 720,990 990,1350 1350,1560 1560,2010
typically this requires some program

159
00:05:26,110 --> 00:05:27,980
0,840
annotations,|
|

160
00:05:28,820 --> 00:05:30,740
0,210 210,480 480,1350
so {begin_x -}
所以 begin_x 表示客户端想要启动事务，

161
00:05:30,740 --> 00:05:32,900
0,360 360,780 780,1410 1410,1620 1620,2160
{} to indicate that the

162
00:05:32,930 --> 00:05:34,130
0,420 420,660 660,870 870,1170 1170,1200
client wants to start a

163
00:05:34,130 --> 00:05:35,750
0,720 750,900 900,1110 1110,1260 1260,1620
transaction,| {you,know} may be then
|然后可能是 add 操作， add(x,-1) ，

164
00:05:36,670 --> 00:05:38,500
0,150 150,270 270,420 420,1110 1110,1830
you know the operations like

165
00:05:38,650 --> 00:05:40,840
0,660 1050,1200 1200,1650 1650,1860 1860,2190
add, {you,know} add x {-1

166
00:05:40,840 --> 00:05:44,470
0,480 840,1020 1020,1470 2010,2490 2550,3630
-}| and then add y
|然后 add(y,+1) ，

167
00:05:44,500 --> 00:05:46,140
0,150 150,270 270,570 570,1050
you know {+1 -},|
|

168
00:05:46,570 --> 00:05:47,890
0,510 510,930 930,1140 1140,1260 1260,1320
and then you have to
然后，你必须指明事务何时完成，

169
00:05:47,890 --> 00:05:49,480
0,450 450,750 750,840 840,1500 1500,1590
indicate when the transaction is

170
00:05:49,480 --> 00:05:52,930
0,630 1770,2160 2160,2370 2370,2850 2850,3450
completed| and so typically we
|通常我们使用 commit 。

171
00:05:54,430 --> 00:05:56,100
0,450 450,510 510,600 600,1020
{come,to} make a commit.|
|

172
00:05:56,410 --> 00:05:58,180
0,600 780,1290 1290,1470 1470,1620 1620,1770
And, {} and so the
所以，我们寻找的语义是，

173
00:05:58,180 --> 00:05:59,830
0,540 540,630 630,720 720,1080 1080,1650
semantics that we're looking for

174
00:05:59,920 --> 00:06:02,350
0,330 330,510 510,810 810,1830 2010,2430
is that,| these operations are
|这些操作原子地执行，

175
00:06:02,350 --> 00:06:04,000
0,450 450,870 870,1140 1170,1350 1350,1650
executed {atomically -}| with respect
|对于并发和故障。

176
00:06:04,000 --> 00:06:05,710
0,90 90,720 720,930 930,1320 1320,1710
to concurrency and respect to

177
00:06:05,710 --> 00:06:07,750
0,330 360,810 1350,1800 1800,1980 1980,2040
{} failure.| And just to
|为了让它更激动人心，

178
00:06:07,750 --> 00:06:08,260
0,150 150,210 210,240 240,390 390,510
make it a little bit

179
00:06:08,260 --> 00:06:09,400
0,120 120,600 600,870 870,1050 1050,1140
more exciting,| let's look at
|让我们来看看第二个事务，

180
00:06:09,400 --> 00:06:10,600
0,180 180,450 450,960 960,1080 1080,1200
{} second transaction,| so that
|我们可以看一些案例研究，

181
00:06:10,600 --> 00:06:11,560
0,90 90,240 240,540 540,630 630,960
we can look at some

182
00:06:11,830 --> 00:06:13,780
0,390 390,750 750,1080 1080,1470 1470,1950
{} case studies| about how
|关于事务如何[互动]，

183
00:06:13,780 --> 00:06:15,970
0,540 540,780 780,1380 1590,1980 1980,2190
transactions actually interact,| we might
|我们可能有第二个事务 begin_x ，

184
00:06:15,970 --> 00:06:18,220
0,150 150,450 480,900 900,1770
have a second transaction

185
00:06:18,220 --> 00:06:19,960
0,390 390,1020
{begin_x -},|
|

186
00:06:19,960 --> 00:06:22,570
0,480 480,1290 1320,1770 1770,2070 2070,2610
{} which reads actually these
它读取这些账户，

187
00:06:22,780 --> 00:06:24,120
0,780
accounts,|
|

188
00:06:24,460 --> 00:06:26,200
0,300 300,510 510,900 900,1080 1080,1740
so {t1 -} gets x,
所以 t1 得到 x ，然后 t2 得到 y ，

189
00:06:28,530 --> 00:06:34,140
0,1080 1110,1350 1350,1650 1650,2340 4590,5610
{and,then,t2} {you,know} gets y,| {and,print}
|并打印 t1 和 t2 ，

190
00:06:35,700 --> 00:06:37,770
0,390 390,960 990,1350 1350,1560 1560,2070
{t1 -} and {t2 -},|
|

191
00:06:37,950 --> 00:06:39,660
0,360 360,600 600,1020
and then end
然后结束或 commit 。

192
00:06:41,160 --> 00:06:42,740
0,360 390,840
or commit.|
|

193
00:06:47,590 --> 00:06:48,400
0,180 180,270 270,420 420,540 540,810
So we have a second
所以，我们有第二个事务，

194
00:06:48,400 --> 00:06:49,780
0,450 450,540 540,990 990,1290 1290,1380
transaction,| that basically reads the
|它读取帐户 x 和 y ，并打印值。

195
00:06:49,780 --> 00:06:50,950
0,360 360,510 510,600 600,960 960,1170
account x and y and

196
00:06:50,950 --> 00:06:53,020
0,210 210,270 270,930 1230,1650 1650,2070
prints the values.| And one
|我们有两个事务的一个原因是，

197
00:06:53,020 --> 00:06:54,820
0,210 210,330 330,1440 1470,1650 1650,1800
reason that we have two

198
00:06:54,820 --> 00:06:55,870
0,600 600,690 690,840 840,930 930,1050
transactions,| so that we can
|我们可以从并发性的角度来看，

199
00:06:55,870 --> 00:06:57,370
0,180 180,300 300,390 390,750 750,1500
look from the concurrency perspective,|
|

200
00:06:57,580 --> 00:06:59,860
0,390 390,810 840,1470 1470,1800 1800,2280
how these transactions actually ordered,|
这些事务是如何排序的，|

201
00:06:59,860 --> 00:07:01,120
0,210 210,420 420,750 750,1140 1140,1260
what are legal outcome and
什么是合法结果，什么是非法结果。

202
00:07:01,120 --> 00:07:02,650
0,150 150,420 420,600 600,870 870,1530
what are {illegal -} outcomes.|
|

203
00:07:03,540 --> 00:07:05,130
0,450 600,1230 1230,1410 1410,1530 1530,1590
{} Transactions turned out to
事务就像是一个魔法，

204
00:07:05,130 --> 00:07:08,400
0,420 720,1410 1410,2310 2760,3150 3150,3270
be a general, almost like

205
00:07:08,400 --> 00:07:10,050
0,300 300,480 480,600 600,1140 1170,1650
a piece of magic,| basically
|程序员可以注解这些 begin 和 end 操作，

206
00:07:10,050 --> 00:07:12,450
0,750 1110,1560 1560,1830 1830,2250 2250,2400
programmers {} can annotate these

207
00:07:12,450 --> 00:07:15,270
0,480 480,1170 1200,2490 2610,2760 2760,2820
begin {and,end} operations,| and it
|它使一组操作一起，

208
00:07:15,270 --> 00:07:16,200
0,180 180,270 270,630 630,870 870,930
takes a whole group of

209
00:07:16,200 --> 00:07:18,750
0,870 1050,1650 1650,1860 1860,1980 1980,2550
operations together,| make them atomic|
|使它们原子化，|

210
00:07:18,870 --> 00:07:19,830
0,180 180,360 360,420 420,840 840,960
and use the system will
使用这个系统会处理好一切，

211
00:07:19,830 --> 00:07:20,760
0,180 180,420 420,480 480,810 810,930
take care of everything,| it
|它会负责锁，

212
00:07:20,760 --> 00:07:21,420
0,120 120,300 300,450 450,540 540,660
will take care of the

213
00:07:21,420 --> 00:07:22,890
0,630 780,990 990,1230 1230,1380 1380,1470
locking,| will take care of
|会负责恢复，

214
00:07:22,890 --> 00:07:24,390
0,90 90,840 900,1080 1080,1350 1350,1500
the recovery,| it's all like
|程序员不必担心这个问题，

215
00:07:24,390 --> 00:07:25,260
0,60 60,420 420,660 660,780 780,870
the programmer doesn't have to

216
00:07:25,260 --> 00:07:26,520
0,270 270,510 510,720 900,1170 1170,1260
worry about it,| {} the
|事务是一个非常强大的结构，

217
00:07:26,520 --> 00:07:27,960
0,510 510,600 600,720 720,1110 1110,1440
transactions is a very very

218
00:07:27,960 --> 00:07:30,580
0,750 780,1560 1590,2250
powerful {} construct,|
|

219
00:07:30,980 --> 00:07:33,140
0,510 690,900 900,1080 1080,1620 1620,2160
{} and they're useful in
它们在非分布式系统中很有用，

220
00:07:33,200 --> 00:07:34,670
0,330 330,750 750,1260 1260,1350 1350,1470
non distributed systems,| you know
|你有一台单数据库机器或多核数据库机器，

221
00:07:34,670 --> 00:07:36,410
0,210 210,450 450,870 930,1290 1290,1740
you have a single database

222
00:07:36,410 --> 00:07:38,030
0,600 600,780 780,1020 1020,1200 1200,1620
machine or {multi-core -} database

223
00:07:38,030 --> 00:07:39,680
0,570 570,780 780,1200 1200,1260 1260,1650
machine,| and clients are submitting
|客户端向它提交事务，

224
00:07:39,680 --> 00:07:41,390
0,570 570,720 720,930 1320,1530 1530,1710
transactions to it,| {} then
|然后事务系统执行这些事务

225
00:07:41,390 --> 00:07:42,980
0,60 60,510 510,990 990,1200 1200,1590
the transaction system will execute

226
00:07:42,980 --> 00:07:44,330
0,150 150,750 750,990 990,1170 1170,1350
these transactions| {} as much
|尽可能并发地（执行），

227
00:07:44,330 --> 00:07:46,190
0,150 150,600 600,690 690,1410 1560,1860
as concurrently as possible, {}|
|

228
00:07:46,190 --> 00:07:47,690
0,150 150,660 660,990 990,1140 1140,1500
but also even if machine
但即使机器出现故障，它也会恢复正常，

229
00:07:47,690 --> 00:07:48,980
0,360 360,420 420,630 630,900 900,1290
fails, it comes back up,|
|

230
00:07:49,010 --> 00:07:50,630
0,270 270,420 420,540 540,990 990,1620
{you,know} you can actually expect
你可以期待结果就在那里。

231
00:07:50,870 --> 00:07:52,910
0,690 900,1470 1470,1830 1830,1920 1920,2040
{} the results to be

232
00:07:52,910 --> 00:07:53,700
0,420
there.|
|

233
00:07:54,080 --> 00:07:56,090
0,540 900,1380 1380,1710 1710,1800 1800,2010
And our focus of course
当然，我们的重点是分布式事务，

234
00:07:56,090 --> 00:07:57,740
0,60 60,180 180,240 240,690 870,1650
is going to be distributed

235
00:07:57,740 --> 00:07:59,220
0,810
transactions,|
|

236
00:08:02,430 --> 00:08:04,320
0,570 570,690 690,1200 1200,1560 1560,1890
{} {you,know} what I had
在我之前的幻灯片里，

237
00:08:04,320 --> 00:08:06,700
0,120 120,510 510,870 930,1800
the previous slide,| namely
|也就是一个跨分片的例子，

238
00:08:08,150 --> 00:08:09,860
0,330 330,660 660,990 990,1320 1320,1710
{} one example across shards,|
|

239
00:08:09,860 --> 00:08:11,240
0,150 150,270 270,480 480,840 840,1380
which is a common case
这在数据中心很常见。

240
00:08:11,240 --> 00:08:13,720
0,390 390,1200 1200,1440 1440,1980
{} in data centers.|
|

241
00:08:14,220 --> 00:08:16,830
0,390 720,1320 1320,1920 1920,2070 2070,2610
{} {The,typical} API of transaction
事务通常的 API 还有一个操作，

242
00:08:16,830 --> 00:08:18,450
0,330 330,450 450,780 780,1020 1020,1620
also has one more operation|
|

243
00:08:18,450 --> 00:08:19,800
0,330 330,390 390,630 630,930 930,1350
that I didn't list here,|
我没有列在这里，|

244
00:08:19,950 --> 00:08:21,210
0,450 450,630 630,720 720,780 780,1260
and that is {abort -},|
也就是 abort ，|

245
00:08:23,700 --> 00:08:25,080
0,180 180,270 270,420 420,1080 1080,1380
so the two transactions shown
这里显示的两个事务都是 commit ，

246
00:08:25,080 --> 00:08:26,670
0,270 270,330 330,570 570,1110 1290,1590
here are both committing {},|
|

247
00:08:26,670 --> 00:08:28,200
0,180 180,300 300,630 630,870 870,1530
{but,you} could immediately have transaction
但是你可以直接终止事务，

248
00:08:28,200 --> 00:08:29,760
0,390 390,810 810,930 930,1410 1440,1560
that decides to abort,| you
|比如你可能会发现，

249
00:08:29,760 --> 00:08:32,010
0,90 90,180 180,870 1110,1800 1800,2250
know for example {} you

250
00:08:32,010 --> 00:08:35,880
0,660 660,1260 1260,1860 1920,3630 3630,3870
might discover that,| {for,example} transaction
|例如，事务 T1 可以检查

251
00:08:35,880 --> 00:08:37,380
0,150 150,600 690,1020 1020,1350 1350,1500
{T1 -} might check| the
|x 帐户中是否有足够的钱，

252
00:08:37,380 --> 00:08:38,940
0,660 660,990 990,1290 1290,1380 1380,1560
{x,has} sufficient money in it

253
00:08:38,940 --> 00:08:40,170
0,180 180,270 270,750 1020,1170 1170,1230
in the account,| and if
|如果账户中没有足够的钱，

254
00:08:40,170 --> 00:08:41,820
0,120 120,780 810,1140 1140,1440 1440,1650
{} the account doesn't have

255
00:08:41,820 --> 00:08:43,920
0,450 450,900 1020,1560 1560,2040 2040,2100
sufficient money,| {} instead of
|不是调用 commit ，而是调用 abort ，

256
00:08:43,920 --> 00:08:45,150
0,390 390,780 780,960 960,1080 1080,1230
calling commit, it would call

257
00:08:45,150 --> 00:08:47,310
0,120 120,540 690,1080 1110,1770 1770,2160
{abort -},| and {at,that,point -}
|这个时候，事务将被取消，

258
00:08:47,310 --> 00:08:49,680
0,690 810,1080 1080,1500 1530,1800 1800,2370
{the,transaction} {} would be cancelled,|
|

259
00:08:50,010 --> 00:08:51,420
0,540 540,810 810,900 900,960 960,1410
and even if the transaction
即使事务在一半时中止，

260
00:08:51,420 --> 00:08:52,350
0,510 510,630 630,720 720,870 870,930
aborts you know sort of

261
00:08:52,350 --> 00:08:53,970
0,420 420,1020 1080,1230 1230,1470 1470,1620
halfway through,| and maybe has
|也许已经做了一些 put 操作，

262
00:08:53,970 --> 00:08:55,920
0,180 180,450 450,660 660,1500 1560,1950
done some put operations, {}|
|

263
00:08:55,920 --> 00:08:57,270
0,450 450,540 540,960 960,1110 1110,1350
{the,still} the semantics should be,|
语义仍然应该是，|

264
00:08:57,270 --> 00:08:58,500
0,450 480,780 780,870 870,1050 1050,1230
that none of those put
这些 put 操作都没有发生。

265
00:08:58,500 --> 00:09:00,080
0,540 540,810 810,1290
operations actually happened.|
|

266
00:09:00,730 --> 00:09:02,680
0,510 930,1200 1200,1350 1350,1500 1500,1950
{} So in all cases
所以，在所有 abort 或 commit 的情况下，

267
00:09:02,680 --> 00:09:04,030
0,210 210,330 330,390 390,960 990,1350
where it's {abort -} or

268
00:09:04,030 --> 00:09:05,890
0,510 660,1110 1110,1590 1590,1770 1770,1860
commit,| {} either all of
|要么全部发生，要么一个都不发生，

269
00:09:05,890 --> 00:09:06,820
0,90 90,420 420,600 600,840 840,930
them happen or none of

270
00:09:06,820 --> 00:09:08,830
0,150 150,420 690,1200 1200,1560 1560,2010
them happen,| never partial result,|
|永远不会有部分结果，|

271
00:09:09,710 --> 00:09:11,510
0,510 720,1290 1290,1500 1500,1680 1680,1800
{} abort also might be
事务系统本身也可以调用 abort ，

272
00:09:11,510 --> 00:09:13,310
0,570 600,930 930,1080 1080,1530 1530,1800
called by the transaction system

273
00:09:13,310 --> 00:09:15,500
0,720 960,1290 1290,1470 1470,2010 2010,2190
itself,| {} for example as
|例如，我们稍后将看到，

274
00:09:15,500 --> 00:09:17,360
0,120 120,300 300,750 750,1410 1680,1860
we'll see later,| if a
|如果两个事务之间存在死锁，

275
00:09:17,360 --> 00:09:19,130
0,270 270,690 870,1110 1110,1710 1710,1770
there's a, {} there's a

276
00:09:19,130 --> 00:09:21,260
0,570 570,870 870,960 960,1710 1860,2130
deadlock between two transactions,| then
|则事务系统可以中止其中一个事务，

277
00:09:21,260 --> 00:09:22,460
0,90 90,510 510,810 810,1080 1080,1200
the transaction system actually can

278
00:09:22,460 --> 00:09:24,020
0,390 390,570 570,660 660,750 750,1560
abort one of the transactions,|
|

279
00:09:24,170 --> 00:09:25,910
0,750 750,930 930,1290 1380,1560 1560,1740
{} in the,| so that
在，|让其他事务继续，

280
00:09:25,910 --> 00:09:27,440
0,150 150,360 360,750 750,1410 1410,1530
the other transaction continue| and
|并且稍后重试已经中止的事务。

281
00:09:27,440 --> 00:09:28,970
0,240 240,330 330,750 750,1260 1320,1530
maybe {} retry later {}

282
00:09:28,970 --> 00:09:30,200
0,150 150,600 600,720 720,840 840,1230
the transaction that was abort.|
|

283
00:09:31,870 --> 00:09:33,250
0,630 840,1020 1020,1140 1140,1290 1290,1380
{} Okay, so this is
好的，这是原语，

284
00:09:33,250 --> 00:09:35,560
0,390 390,1080 1080,1260 1260,1680 1680,2310
{sort,of} primitives,| {you,know} {begin_x -}
|begin_x commit 和 abort ，三个关键接口操作。

285
00:09:35,560 --> 00:09:38,710
0,450 600,990 990,1470 2130,2760 2760,3150
commit and abort, {three,key} {}

286
00:09:39,070 --> 00:09:42,130
0,600 930,2100 2490,2820 2820,2970 2970,3060
interface operations.| And then the
|然后事务的语义

287
00:09:42,130 --> 00:09:46,360
0,780 810,1500 1980,3540 3540,3660 3660,4230
semantics of transactions| are typically
|通常由单个词语来概括，即 ACID ，

288
00:09:46,360 --> 00:09:47,640
0,900
summarized

289
00:09:47,640 --> 00:09:50,160
0,750 750,1290 1290,1560 1560,2010 2040,2520
by a single word, namely

290
00:09:50,160 --> 00:09:51,360
0,570
ACID,|
|

291
00:09:53,570 --> 00:09:55,550
0,540 540,1170 1170,1470 1470,1650 1650,1980
and { -} that stands
这代表了事务的四个关键属性。

292
00:09:55,550 --> 00:09:57,560
0,330 330,900 900,1320 1320,1860 1860,2010
for four key properties with

293
00:09:57,560 --> 00:09:59,740
0,810 840,1650
transactions.| One,
|第一，它是原子的，

294
00:10:00,370 --> 00:10:01,880
0,150 150,840
it's atomic,|
|

295
00:10:04,640 --> 00:10:06,290
0,270 270,540 540,810 810,1260 1260,1650
and here really atomic refers
这里的原子表示的情况，

296
00:10:06,290 --> 00:10:07,490
0,150 150,450 450,810 810,1110 1110,1200
to the case,| where we
|我们有两个事务运行，

297
00:10:07,490 --> 00:10:09,650
0,120 120,300 300,810 810,1290 1530,2160
have two transactions running, {}|
|

298
00:10:09,650 --> 00:10:11,450
0,330 330,540 540,930 930,1110 1110,1800
and one transaction does multiple
一个事务执行多个 put 操作或多个 add 操作，

299
00:10:11,480 --> 00:10:13,850
0,1050 1050,1140 1140,1440 1440,1590 1590,2370
{put,operations} or multiple add operations,|
|

300
00:10:13,970 --> 00:10:15,260
0,270 270,540 540,750 750,1080 1080,1290
{} all those results will
所有这些结果都是，

301
00:10:15,260 --> 00:10:16,700
0,150 150,450 450,1080 1170,1320 1320,1440
be,| all visible to the
|全部对另一事务可见或者全部不可见，

302
00:10:16,700 --> 00:10:18,020
0,150 150,630 630,750 750,1140 1140,1320
other transaction or none of

303
00:10:18,020 --> 00:10:19,400
0,210 210,360 360,450 450,900
them will be visible,|
|

304
00:10:19,660 --> 00:10:21,160
0,270 270,420 420,630 630,870 870,1500
{} so that's one aspect,|
所以这是一个方面，|

305
00:10:21,460 --> 00:10:23,400
0,570 750,1380
sorry, {}
抱歉，我说的这个不对，

306
00:10:26,870 --> 00:10:27,890
0,240 240,390 390,630 630,840 840,1020
I say this, I said

307
00:10:27,890 --> 00:10:28,970
0,150 150,240 240,660 660,930 960,1080
this is wrong,| so the
|原子性意思是崩溃恢复的情况，

308
00:10:28,970 --> 00:10:29,990
0,240 240,420 420,600 600,750 750,1020
atomic actually means to crash

309
00:10:29,990 --> 00:10:32,870
0,390 390,900 1140,1560 1560,2010 2010,2880
recovery case,| {} so, {}
|如果一个事务有多个 put 操作，

310
00:10:32,900 --> 00:10:34,880
0,330 330,420 420,840 840,1170 1560,1980
if a transaction actually multiple

311
00:10:34,880 --> 00:10:37,370
0,180 180,1020 1080,1650 1680,2100 2100,2490
put operations,| the transaction crashes
|事务在中途崩溃，

312
00:10:37,370 --> 00:10:39,500
0,810 960,1620
halfway, {}|
|

313
00:10:39,560 --> 00:10:41,570
0,630 660,1080 1080,1320 1320,1770 1770,2010
the rule is that all
规则是所有的写入都是可见的，

314
00:10:41,570 --> 00:10:43,190
0,120 120,360 360,450 450,1080 1110,1620
the writes are visible,| all
|所有写入都进入存储或都没有，

315
00:10:43,190 --> 00:10:44,510
0,210 210,510 510,750 750,1050 1050,1320
writes around a stable storage

316
00:10:44,510 --> 00:10:45,580
0,60 60,270 270,480
or none {of,them},|
|

317
00:10:45,760 --> 00:10:47,380
0,270 270,750 780,1230 1230,1320 1320,1620
was the atomic {sort,of} respect
原子性与崩溃恢复有关。

318
00:10:47,380 --> 00:10:49,060
0,60 60,390 390,1050
to crash recovery.|
|

319
00:10:49,060 --> 00:10:51,550
0,570 1050,1440 1440,2040 2040,2340 2340,2490
{} The C stands for
C 代表一致性，

320
00:10:51,550 --> 00:10:52,860
0,600
consistent,|
|

321
00:10:53,090 --> 00:10:54,080
0,180 180,390 390,450 450,780 780,990
{} which is something we're
这是我们不太会谈论的事情，

322
00:10:54,080 --> 00:10:55,010
0,390 390,510 510,630 630,690 690,930
mostly not going to talk

323
00:10:55,010 --> 00:10:56,990
0,420 690,1260 1260,1470 1470,1680 1680,1980
about,| {} it's more related
|它更多地与数据库相关，

324
00:10:56,990 --> 00:10:58,850
0,60 60,930 1110,1440 1440,1620 1620,1860
to databases,| {} it's often
|通常情况下，数据库具有内部变量，

325
00:10:58,850 --> 00:10:59,870
0,60 60,360 360,480 480,870 870,1020
the case that database have

326
00:10:59,870 --> 00:11:02,630
0,600 600,1260 1260,1500 1500,2100 2100,2760
internal variants,| like referential integrity,
|比如参照完整性就是其中之一，

327
00:11:02,900 --> 00:11:04,310
0,510 510,750 750,930 930,1050 1050,1410
{} is one of them,|
|

328
00:11:04,460 --> 00:11:06,740
0,690 690,1050 1050,1320 1320,1890 1890,2280
and {} the transaction {}
而事务应该保持这种一致性，

329
00:11:06,740 --> 00:11:08,900
0,330 330,780 780,1170 1200,1980 1980,2160
is supposed to maintain that

330
00:11:08,900 --> 00:11:10,020
0,660
consistency,|
|

331
00:11:10,320 --> 00:11:12,030
0,210 210,390 390,780 780,1170 1170,1710
and so no internal {consistencies
所以没有内部一致性，

332
00:11:12,030 --> 00:11:13,320
0,240 690,960 960,1020 1020,1110 1110,1290
-},| {this,is,going} to be less
|对于我们今天来说，这不是一个话题。

333
00:11:13,320 --> 00:11:14,130
0,90 90,120 120,510 510,690 690,810
of a topic for {us

334
00:11:14,130 --> 00:11:16,230
0,180 180,750 1050,1320 1320,1830 1830,2100
-} today.| The three is
|第三个是隔离性， I 代表隔离性，

335
00:11:16,230 --> 00:11:18,930
0,810 1200,1440 1440,1680 1680,2070 2070,2700
isolated, the I {stands,for} isolated,|
|

336
00:11:23,100 --> 00:11:25,770
0,360 360,840 840,2040 2070,2550 2550,2670
and isolated was,| what I
隔离性是，|我之前说错的，

337
00:11:25,770 --> 00:11:27,300
0,150 150,360 360,930 930,1050 1050,1530
just said earlier {} incorrectly,|
|

338
00:11:27,300 --> 00:11:28,320
0,390 390,600 600,870 870,930 930,1020
isolated actually refers to the
隔离性指的是这种情况，

339
00:11:28,320 --> 00:11:30,000
0,270 270,480 480,720 720,870 870,1680
case,| we're running two transactions,|
|我们运行两个事务，|

340
00:11:30,270 --> 00:11:32,730
0,720 720,1290 1290,1890 1890,2160 2160,2460
and {} they don't see,|
它们不会看到，|

341
00:11:32,730 --> 00:11:34,350
0,210 210,480 480,870 870,1320 1320,1620
they {should,not} observe intermediate results
它们不应该观察到彼此的中间结果，

342
00:11:34,350 --> 00:11:35,670
0,120 120,240 240,510 540,720 720,1320
from each other,| so again
|所以应用所有写入，

343
00:11:35,730 --> 00:11:38,610
0,300 300,810 810,930 930,1650 1920,2880
{} {all,the,writes} are applied, {}|
|

344
00:11:39,600 --> 00:11:42,030
0,540 540,720 720,1350 1860,2010 2010,2430
all or nothing with respect
其他事务看到全部或没有。

345
00:11:42,030 --> 00:11:43,650
0,60 60,750 750,840 840,1020 1020,1620
to [] to another transactions.|
|

346
00:11:44,500 --> 00:11:46,330
0,270 270,720 720,1110 1200,1590 1590,1830
And finally, the D stands
最后， D 代表耐久性，

347
00:11:46,330 --> 00:11:48,060
0,90 90,780
for durable,|
|

348
00:11:49,410 --> 00:11:50,670
0,420 420,570 570,750 750,810 810,1260
meaning that if the transaction
意味着如果事务提交，

349
00:11:50,670 --> 00:11:51,760
0,600
commits,|
|

350
00:11:51,760 --> 00:11:53,410
0,300 300,720 720,1170 1200,1560 1560,1650
{} then the results are
结果写入稳定存储，

351
00:11:53,410 --> 00:11:54,970
0,300 300,720 720,810 810,1110 1110,1560
written to a stable storage,|
|

352
00:11:54,970 --> 00:11:55,840
0,120 120,270 270,480 480,540 540,870
so that if the system
如果系统崩溃，稍后又恢复，

353
00:11:55,840 --> 00:11:57,520
0,570 570,780 780,1020 1020,1170 1170,1680
crashes, comes back up later,|
|

354
00:11:57,700 --> 00:12:00,220
0,540 540,1050 1080,1500 1500,2130 2160,2520
the {} latest writes or
最新写入或最新事务，

355
00:12:00,220 --> 00:12:01,750
0,90 90,390 390,1140 1140,1230 1230,1530
the latest transactions,| the latest
|最新提交的事务会记录在稳定存储上。

356
00:12:01,750 --> 00:12:04,120
0,300 300,1020 1050,1470 1470,1770 1770,2370
committed transactions are actually recorded

357
00:12:04,120 --> 00:12:05,700
0,210 210,510 510,1140
on stable storage.|
|

358
00:12:08,420 --> 00:12:10,610
0,210 210,840 900,1410 1410,1920 1920,2190
Any questions {} about {}
关于事务的简介，有什么问题吗？

359
00:12:10,610 --> 00:12:12,640
0,240 240,690 690,780 780,1500
quick introduction to transactions?|
|

360
00:12:22,210 --> 00:12:23,440
0,390 390,570 570,660 660,870 870,1230
Okay, so I'm gonna talk
好的，我主要会讲两个话题，

361
00:12:23,470 --> 00:12:26,770
0,600 600,930 930,1350 1350,2130 2160,3300
basically about two topics {}

362
00:12:26,980 --> 00:12:28,810
0,570 570,600 600,930 930,1380 1380,1830
quite a bit,| namely the
|也就是事务的 A 部分和 I 部分，

363
00:12:29,260 --> 00:12:30,970
0,360 360,780 810,930 930,1590 1590,1710
{A,part} of the transactions and

364
00:12:30,970 --> 00:12:32,950
0,120 120,390 390,840 870,1200 1200,1980
the I part of transactions.|
|

365
00:12:33,070 --> 00:12:34,540
0,330 330,450 450,840 840,1020 1020,1470
We're gonna start with the
我们将从 I 部分开始，

366
00:12:35,060 --> 00:12:37,190
0,180 180,780 1170,1920 1920,2100 2100,2130
I part,| and talk a
|稍微讨论一下隔离性是什么。

367
00:12:37,190 --> 00:12:38,660
0,180 180,330 330,660 660,930 930,1470
little bit about what actually

368
00:12:38,660 --> 00:12:40,540
0,360 360,870 870,1380
correct isolation means.|
|

369
00:12:44,420 --> 00:12:45,440
0,150 150,450 450,630 630,690 690,1020
So basically what we're looking
所以我们要找的是一个定义，

370
00:12:45,440 --> 00:12:48,260
0,600 630,810 810,870 870,1710 2040,2820
for is a definition| for
|正确执行多个事务或并发事务，

371
00:12:48,260 --> 00:12:49,910
0,150 150,480 480,1080 1080,1230 1230,1650
{} correct execution of multiple

372
00:12:49,910 --> 00:12:52,240
0,600 660,990 990,1860
transactions {or,concurrency} transactions,|
|

373
00:12:52,330 --> 00:12:54,520
0,270 270,660 750,1440 1440,1980 1980,2190
in the typical definition or
在数据库文献中的典型定义或标准中，

374
00:12:54,520 --> 00:12:56,170
0,390 390,930 930,1140 1140,1200 1200,1650
[] standard in the database

375
00:12:56,170 --> 00:12:58,270
0,750 870,1320 1320,1620 1620,2040 2040,2100
literature,| is called {serializable -
|称为可串行化，

376
00:12:58,270 --> 00:12:59,200
0,330
-}

377
00:13:05,260 --> 00:13:07,160
0,210 210,360 360,1110
or {serializability -},|
|

378
00:13:08,980 --> 00:13:10,150
0,330 330,450 450,630 630,960 960,1170
and what that means is
这意味着，

379
00:13:10,150 --> 00:13:10,960
0,300 300,450 450,540 540,660 660,810
that,| if you have two
|如果你有两个或多个事务，

380
00:13:10,960 --> 00:13:13,330
0,750 960,1230 1230,1530 1530,2160 2160,2370
transactions or many transactions,| they
|它们同时执行，

381
00:13:13,330 --> 00:13:16,720
0,450 450,1200 1560,2400 2490,2760 2760,3390
execute concurrently,| then the outcome
|那么结果肯定是某种串行的顺序，

382
00:13:17,080 --> 00:13:18,460
0,360 360,450 450,690 690,960 960,1380
has to be some serial

383
00:13:18,460 --> 00:13:19,500
0,570
order,|
|

384
00:13:20,080 --> 00:13:22,960
0,420 450,1080 1140,1410 1410,2010 2130,2880
so either {t1 -} executes
所以 t1 在 t2 之前执行，或者 t2 在 t1 之前执行，

385
00:13:23,050 --> 00:13:25,690
0,390 390,630 630,1080 1680,2340 2370,2640
before {t2 -} or {t2

386
00:13:25,690 --> 00:13:27,910
0,300 300,1050 1080,1620 1620,2100 2100,2220
-} executes before t1, {}|
|

387
00:13:27,910 --> 00:13:30,250
0,210 210,630 750,1200 1200,1500 1500,2340
there's some serial or serial
有某种串行的顺序，

388
00:13:30,250 --> 00:13:31,460
0,540
order,|
|

389
00:13:35,910 --> 00:13:38,760
0,630 1050,1590 1590,1890 1890,2610 2610,2850
and the serial order has
串行顺序必须产生与并发执行相同的结果，

390
00:13:38,760 --> 00:13:39,930
0,90 90,420 420,510 510,750 750,1170
to produce the same outcome

391
00:13:43,150 --> 00:13:44,710
0,210 210,270 270,630 630,1170 1170,1560
as the concurrent execution,| so
|所以你同时运行两个事务，

392
00:13:44,740 --> 00:13:46,180
0,120 120,210 210,450 450,900 1140,1440
you get run two {}

393
00:13:46,180 --> 00:13:47,830
0,540 540,1080 1080,1200 1200,1560 1560,1650
transaction concurrently,| they produce some
|它们产生一些结果，

394
00:13:47,830 --> 00:13:49,720
0,600 720,990 990,1260 1260,1410 1410,1890
outcome,| that outcome is only
|这个结果是有效的、合法的或正确的，

395
00:13:49,750 --> 00:13:51,760
0,720 720,870 870,1320 1320,1500 1500,2010
valid or legal or correct,|
|

396
00:13:51,940 --> 00:13:53,500
0,660 660,810 810,960 960,1110 1110,1560
if it could have been
这可能是串行执行的结果。

397
00:13:53,770 --> 00:13:55,270
0,300 300,600 600,1140 1140,1410 1410,1500
{} the result of a

398
00:13:55,270 --> 00:13:56,760
0,360 360,990
serial execution.|
|

399
00:13:57,500 --> 00:13:58,970
0,510 540,840 840,900 900,1080 1080,1470
So just to make {}
所以，为了更具体一些，

400
00:13:58,970 --> 00:14:01,310
0,540 540,780 780,1500 1560,1980 1980,2340
concrete, for example,| let's say
|假设在帐户中 x 从 10 开始，

401
00:14:01,310 --> 00:14:02,930
0,330 330,450 450,810 810,1260 1260,1620
in the account case x

402
00:14:02,930 --> 00:14:05,150
0,570 570,690 690,840 840,1320 1440,2220
starts out as being 10,|
|

403
00:14:05,300 --> 00:14:06,560
0,420 420,750 750,900 900,1020 1020,1260
y starts out as being
y 从 10 开始，

404
00:14:06,560 --> 00:14:08,930
0,600 1290,1530 1530,1650 1650,2160 2190,2370
10,| {} we run {}
|我们运行这两个事务，

405
00:14:08,930 --> 00:14:10,070
0,240 240,390 390,900 900,1020 1020,1140
these two transactions,| that we
|我们之前在白板上看到的，

406
00:14:10,070 --> 00:14:11,570
0,240 240,840 840,990 990,1050 1050,1500
had earlier on the board,|
|

407
00:14:12,080 --> 00:14:12,830
0,180 180,420 420,510 510,660 660,750
here might be what the
这两个事务的内容，

408
00:14:12,830 --> 00:14:14,930
0,150 150,630 630,1110 1470,1650 1650,2100
two transactions are,| and one
|一个是在两个帐户之间移动一，

409
00:14:14,930 --> 00:14:17,720
0,630 1200,1860 1860,2310 2310,2640 2640,2790
basically moves one between two

410
00:14:17,720 --> 00:14:18,680
0,480 480,570 570,630 630,780 780,960
accounts| and the other one
|另一个是打印两个的结果。

411
00:14:18,680 --> 00:14:19,550
0,270 270,360 360,720 720,780 780,870
prints the results of the

412
00:14:19,550 --> 00:14:20,220
0,240
two.|
|

413
00:14:21,400 --> 00:14:21,970
0,210 210,270 270,330 330,510 510,570
So if you think a
所以你稍微想一下，

414
00:14:21,970 --> 00:14:23,410
0,300 300,420 420,660 660,1170 1170,1440
little bit about it,| {if,t1}
|如果 t1 先执行，

415
00:14:23,410 --> 00:14:24,860
0,240 240,960
goes first,|
|

416
00:14:24,860 --> 00:14:26,150
0,570 570,720 720,1020 1020,1140 1140,1290
then the outcome is gonna
那么结果将是 9,10 ，

417
00:14:26,150 --> 00:14:29,060
0,480 510,1260 1440,2130
be {9\,10 -},|
|

418
00:14:29,720 --> 00:14:31,400
0,480 480,570 570,780 780,1320 1320,1680
and the print statement is
而打印语句将是，

419
00:14:31,400 --> 00:14:33,740
0,150 150,240 240,990 1020,1770
going to be {},|
|

420
00:14:40,240 --> 00:14:41,950
0,450 450,990 990,1200 1200,1530 1530,1710
{} yeah, and the print
是的，打印语句，

421
00:14:41,950 --> 00:14:43,870
0,420 510,870 870,1170 1170,1530 1530,1920
statement,| actually there's {9\,10 -},
|实际上这里是 9,10 ，抱歉， 9,11 ，

422
00:14:43,870 --> 00:14:45,640
0,300 330,720 720,1350 1410,1590 1590,1770
sorry {9\,11 -},| that's why
|这就是我困惑的原因，

423
00:14:45,640 --> 00:14:47,000
0,60 60,210 210,810
I got confused,|
|

424
00:14:47,540 --> 00:14:48,380
0,180 180,240 240,420 420,750 750,840
and the print statement is
打印语句也会说，

425
00:14:48,380 --> 00:14:50,720
0,210 210,330 330,600 630,1380 1860,2340
also going to say,| x
|x 是减去的那个，所以是 9,11 ，

426
00:14:50,720 --> 00:14:51,890
0,420 450,690 690,930 930,1050 1050,1170
was the one that was

427
00:14:51,890 --> 00:14:54,020
0,510 510,720 720,1020 1020,1410
substract, so {9,11 -},|
|

428
00:14:54,570 --> 00:14:55,650
0,270 270,390 390,510 510,570 570,1080
so we get the string
所以我们得到字符串 9,11 ，

429
00:14:55,650 --> 00:14:57,270
0,270 270,600 600,990 1050,1500 1500,1620
{9\,11 -} out| and two
|两个账户中的值是 9,11 ，

430
00:14:57,270 --> 00:14:58,620
0,330 330,420 420,810 810,870 870,1350
value of {the,accounts} are {9\,11

431
00:14:58,920 --> 00:15:02,070
0,840 840,1410 1500,2310 2310,2730 2730,3150
- -},| {} if two
|如果 t2 先执行，

432
00:15:02,220 --> 00:15:04,110
0,240 240,450 450,720 720,1290 1380,1890
{t2 -} goes first,| then
|那么结果是 10,10 ，

433
00:15:04,110 --> 00:15:05,280
0,120 120,600 600,990 990,1080 1080,1170
the outcome is you know

434
00:15:05,280 --> 00:15:07,770
0,1290 1410,1950 1950,2100 2100,2340 2340,2490
{10\,10,},| {because,nothing} no money has
|因为钱还没有动过，

435
00:15:07,770 --> 00:15:10,470
0,270 270,660 1020,1290 1290,1890 2100,2700
moved yet,| and then {}
|然后 t1 开始，

436
00:15:11,190 --> 00:15:12,630
0,300 300,570 570,810 810,1170 1170,1440
{t1 -} goes,| so that's
|所以这是一种可能的结果。

437
00:15:12,630 --> 00:15:14,060
0,60 60,450 450,840
a possible outcome.|
|

438
00:15:14,960 --> 00:15:16,130
0,270 270,360 360,660 660,780 780,1170
And so that's the two
所以这是两个事务的两种合法的输出，

439
00:15:16,130 --> 00:15:18,380
0,720 720,1440 1440,1530 1530,1620 1620,2250
legal outcomes of the {two,transaction},|
|

440
00:15:18,380 --> 00:15:20,630
0,150 150,360 360,900 900,1170 1530,2250
that we're actually, { -}|
我们，|

441
00:15:20,960 --> 00:15:22,400
0,180 180,330 330,1080 1080,1230 1230,1440
if we executed the two
如果我们同时执行这两个事务，

442
00:15:22,400 --> 00:15:25,070
0,450 450,1050 1050,1620 1830,2220 2220,2670
transactions concurrently| and {} the
|系统保证可串行化。

443
00:15:25,100 --> 00:15:27,460
0,390 390,1020 1020,1440 1440,1860
system guarantees {serializability -}.|
|

444
00:15:27,690 --> 00:15:29,430
0,510 690,900 900,1230 1230,1350 1350,1740
Now you notice that {serializability
现在你注意到，可串行化有很多特点，

445
00:15:29,430 --> 00:15:31,110
0,600 720,1200 1200,1440 1440,1500 1500,1680
-} has probably a lot

446
00:15:31,110 --> 00:15:33,660
0,960 1080,1830 1830,1980 1980,2250 2250,2550
of flavor,| of like the
|就像我们之前使用的术语线性一致性，

447
00:15:33,690 --> 00:15:35,040
0,600 600,720 720,810 810,1020 1020,1350
terminology that we used before

448
00:15:35,040 --> 00:15:36,920
0,390 390,690 690,840 840,1320
namely {linearizability - -},|
|

449
00:15:36,950 --> 00:15:38,540
0,240 240,540 540,870 870,1140 1140,1590
the key difference between {serializability
可串行化和可线性化之间的关键区别在于，

450
00:15:38,540 --> 00:15:40,160
0,480 480,630 630,870 870,1020 1020,1620
-} and {linearizability - -}

451
00:15:40,160 --> 00:15:41,420
0,150 150,480 480,780 780,1080 1080,1260
is that,| in {linearizability -
|在线性一致性中，有一个实时的组件，

452
00:15:41,420 --> 00:15:42,830
0,360 360,570 570,810 810,1050 1050,1410
-}, there's a {real-time -},

453
00:15:42,920 --> 00:15:45,080
0,510 540,1050 1050,1560 1560,1830 1830,2160
a real-time component,| that if
|如果 t2 在 t1 结束后开始，

454
00:15:45,230 --> 00:15:47,420
0,150 150,300 300,630 630,1350 1380,2190
{transaction -} {t2 -} start

455
00:15:47,450 --> 00:15:49,430
0,570 570,720 720,990 990,1380 1380,1980
after {} {t1 -} ends,|
|

456
00:15:49,520 --> 00:15:51,260
0,720 750,1050 1050,1290 1290,1650 1650,1740
then {t2 -} has to
那么 t2 必须在整体顺序中出现在后面，

457
00:15:51,260 --> 00:15:52,250
0,210 210,360 360,750 750,930 930,990
show up later in the

458
00:15:52,250 --> 00:15:53,900
0,300 300,690 720,960 960,1290 1290,1650
total order,| in {the,serial} order,|
|在串行化顺序中，|

459
00:15:54,200 --> 00:15:55,550
0,300 300,690 690,1080 1080,1260 1260,1350
in {serializability -}, that is
在可串行化中，那是不需要的，

460
00:15:55,550 --> 00:15:57,080
0,270 270,840 870,1080 1080,1410 1410,1530
not required,| so even if
|所以，如果事务开始，

461
00:15:57,080 --> 00:15:59,690
0,480 480,960 1200,1860 1860,2160 2160,2610
transaction started| were clock time
|在时间上晚于另一个事务停止或结束，

462
00:15:59,690 --> 00:16:01,130
0,270 270,420 420,900 900,1050 1050,1440
{a,little} bit later than another

463
00:16:01,130 --> 00:16:03,650
0,660 840,1350 1350,1440 1440,1950 2160,2520
transaction stopped or finished,| and
|系统仍然允许对它重新排序，

464
00:16:03,650 --> 00:16:05,570
0,420 600,1020 1020,1110 1110,1410 1410,1920
the system is still allowed

465
00:16:05,600 --> 00:16:07,040
0,450 450,900 900,1140
to reorder it,|
|

466
00:16:07,980 --> 00:16:09,540
0,510 540,1050 1050,1290 1290,1380 1380,1560
so {serializability -} in some
所以可串行化在某些方面比可线性化要弱一些。

467
00:16:09,540 --> 00:16:10,830
0,300 300,420 420,570 570,720 720,1290
ways a little bit weaker

468
00:16:10,860 --> 00:16:12,510
0,540 570,750 750,990 990,1200 1200,1650
than {} {linearizability - -}.|
|

469
00:16:13,610 --> 00:16:16,250
0,510 570,1650 1680,2190 2190,2550 2550,2640
{} Nevertheless, {serializability -} is
尽管如此，可序列化是一个非常方便的编程[思想]，

470
00:16:16,250 --> 00:16:18,560
0,60 60,450 450,1200 1230,1830 1830,2310
a very convenient programming [idea],

471
00:16:18,620 --> 00:16:20,360
0,300 300,870 1110,1470 1470,1620 1620,1740
right,| because {} from {}
|因为从编程的角度来看，

472
00:16:20,360 --> 00:16:22,250
0,390 390,1080 1230,1440 1440,1560 1560,1890
programming perspective,| you could always
|你总是可以考虑事务以某种顺序执行，

473
00:16:22,250 --> 00:16:23,960
0,210 210,480 480,1080 1080,1590 1590,1710
think about transactions executing in

474
00:16:23,960 --> 00:16:25,560
0,300 300,720 720,1140
some serial order,|
|

475
00:16:25,990 --> 00:16:26,680
0,270 270,360 360,540 540,630 630,690
and you don't have to
你不必考虑所有的交错。

476
00:16:26,680 --> 00:16:28,900
0,390 390,540 540,720 720,900 1080,2220
consider all kinds of interleavings.|
|

477
00:16:31,330 --> 00:16:33,220
0,300 300,450 450,660 660,1200 1200,1890
Okay, so even though {}
好的，所以即使可串行化略弱于可线性化，

478
00:16:34,030 --> 00:16:36,400
0,450 450,720 720,1230 1230,2040 2040,2370
{serializability -} slightly weaker than

479
00:16:36,400 --> 00:16:39,310
0,540 540,1140 1230,1770 1770,2010 2010,2910
{linearizability -},| {} it actually
|它实际上禁止了很多有问题的情况。

480
00:16:39,340 --> 00:16:41,020
0,1110 1110,1140 1140,1380 1380,1590 1590,1680
disallows a whole bunch of

481
00:16:41,020 --> 00:16:42,580
0,510 510,1200
problematic cases.|
|

482
00:16:43,630 --> 00:16:44,920
0,240 240,390 390,810 930,1230 1230,1290
So let me talk a
所以让我简单地谈一谈，

483
00:16:44,920 --> 00:16:45,910
0,210 210,330 330,570 570,840 840,990
little bit about that,| just
|弄清楚可串行化的含义，

484
00:16:45,910 --> 00:16:47,640
0,60 60,210 210,870
to make clear

485
00:16:47,700 --> 00:16:49,410
0,390 390,420 420,690 690,1230 1230,1710
{what - -} actually {serializability

486
00:16:49,410 --> 00:16:50,960
0,360 360,960
-} means,|
|

487
00:16:51,680 --> 00:16:54,050
0,600 1140,1620 1620,2130 2130,2280 2280,2370
{} and what sort of
什么类型的执行，

488
00:16:54,050 --> 00:16:57,230
0,840 840,1710 1710,2550 2550,2700 2700,3180
executions,| the transactions, the transaction
|事务系统必须禁止？

489
00:16:57,230 --> 00:16:58,640
0,300 300,540 540,750 750,840 840,1410
system actually has to forbid?|
|

490
00:16:59,090 --> 00:17:00,640
0,810

491
00:17:00,730 --> 00:17:02,620
0,240 240,1170 1200,1650 1650,1770 1770,1890
And, so let's, you know
然后，所以，有两种情况，

492
00:17:02,620 --> 00:17:04,420
0,180 180,870 870,1080 1080,1350 1350,1800
two cases,| like here we
|这里我们有第一个事务，

493
00:17:04,900 --> 00:17:06,340
0,900
have

494
00:17:06,370 --> 00:17:08,020
0,270 270,540 540,1260 1260,1470 1470,1650
the first transaction,| we have
|我们有第二个事务，

495
00:17:08,020 --> 00:17:10,580
0,150 150,420 420,1140 1320,1980
the second transaction running,|
|

496
00:17:11,270 --> 00:17:13,010
0,420 630,810 810,1080 1080,1530 1530,1740
so {t1 -} runs, {t2
所以 t1 运行， t2 ，

497
00:17:13,010 --> 00:17:15,590
0,540 1080,1770 2130,2250 2250,2340 2340,2580
-},| and you know one
|我们可能会有一个结果，

498
00:17:15,590 --> 00:17:16,850
0,450 450,570 570,660 660,810 810,1260
outcome that we could have,|
|

499
00:17:16,850 --> 00:17:19,490
0,480 480,600 600,990 1230,1860 1860,2640
is like one possible execution
一个可能发生的执行是，

500
00:17:19,700 --> 00:17:21,020
0,180 180,510 510,750 750,1080 1080,1320
{} that might happen is,|
|

501
00:17:21,020 --> 00:17:22,280
0,600 630,720 720,840 840,1050 1050,1260
if we if we don't
如果我们不做一些特别的事情，

502
00:17:22,280 --> 00:17:23,780
0,90 90,360 360,960 1110,1320 1320,1500
do something special,| you know
|t1 get(x) ，

503
00:17:23,780 --> 00:17:26,660
0,240 240,780 1500,2010 2010,2250 2250,2880
{t1 -} {} gets x,|
|

504
00:17:28,790 --> 00:17:29,930
0,120 120,510 510,720 720,1020 1020,1140
{} you know here the
这里转账发生，

505
00:17:29,930 --> 00:17:32,300
0,480 480,1140 1170,1620 1800,1950 1950,2370
transfer happens,| so the updates
|所以更新 x,y 发生，

506
00:17:32,300 --> 00:17:34,360
0,300 300,540 540,600 600,1080
x {y -} happen,|
|

507
00:17:35,290 --> 00:17:36,460
0,180 180,570 570,660 660,840 840,1170
and then you know {t2
然后 t2 执行 get(y) ，

508
00:17:36,460 --> 00:17:39,700
0,540 870,1620 1620,1860 1860,2580
-} does get y,|
|

509
00:17:40,240 --> 00:17:42,400
0,750 780,1470 1470,1590 1740,2010 2010,2160
and {} you know is
这是不是非法的，

510
00:17:42,400 --> 00:17:43,750
0,180 180,660 660,1050 1050,1170 1170,1350
this illegal| or is this
|是不是可串行化的执行？

511
00:17:43,750 --> 00:17:45,430
0,240 240,720 720,900 900,1470 1470,1680
a serializable, is this a

512
00:17:45,430 --> 00:17:47,260
0,660 660,1170
serializable execution?|
|

513
00:17:47,260 --> 00:17:48,430
0,210 210,510 510,870 870,1020 1020,1170
That's {sort,of} question we have
这是我们要问的问题，

514
00:17:48,430 --> 00:17:50,350
0,120 120,690 1260,1530 1530,1860 1860,1920
to ask,| and what is
|这个问题的答案是什么？

515
00:17:50,350 --> 00:17:51,430
0,120 120,480 480,600 600,750 750,1080
the answer to that one?|
|

516
00:17:54,420 --> 00:17:55,980
0,240 240,510 510,690 690,1080 1080,1560
{} This is not {serializable
这不是可串行化的。

517
00:17:55,980 --> 00:17:56,900
0,390
-}.|
|

518
00:17:57,220 --> 00:17:58,660
0,690 690,930 930,1230 1230,1350 1350,1440
Yeah, and because you know
是的，因为你知道结果，

519
00:17:58,660 --> 00:17:59,890
0,150 150,780 780,870 870,1050 1050,1230
the outcome,| you know if
|如果我们写下结果是什么，

520
00:17:59,890 --> 00:18:00,730
0,210 210,420 420,600 600,720 720,840
we write down what the

521
00:18:00,730 --> 00:18:01,750
0,300 300,450 450,720 720,870 870,1020
outcome is, correct,| then the
|那么结果是，这里是 9,11 ，

522
00:18:01,750 --> 00:18:02,950
0,270 270,360 360,510 510,660 660,1200
outcome is gonna be {9\,11

523
00:18:03,370 --> 00:18:05,290
0,450 450,1140 1260,1650 1650,1830 1830,1920
-} here,| and this is
|这里是 10,11 。

524
00:18:05,290 --> 00:18:08,080
0,150 150,270 270,540 540,1350 1590,2790
going to write down a

525
00:18:08,110 --> 00:18:10,580
0,2040
{10\,11\,,right.}|
|

526
00:18:11,490 --> 00:18:12,800
0,90 90,270 270,750
I think so.|
我想是的。|

527
00:18:12,860 --> 00:18:13,820
0,210 210,300 300,390 390,480 480,960
And if we go back
如果我们回到之前的幻灯片，

528
00:18:14,060 --> 00:18:15,260
0,120 120,270 270,570 570,990 990,1200
to our previous slides,| that
|这不是两个合法结果之一，

529
00:18:15,260 --> 00:18:16,010
0,120 120,360 360,570 570,660 660,750
is not one of the

530
00:18:16,010 --> 00:18:18,500
0,240 240,540 540,1230 1320,1770 1950,2490
two legal outcomes, right,| so
|所以这不是好的。

531
00:18:18,530 --> 00:18:20,060
0,180 180,300 300,600 600,960
this is not good.|
|

532
00:18:20,330 --> 00:18:21,800
0,180 180,450 450,900 930,1170 1170,1470
So when we think about
所以，当我们考虑事务系统的含义时，

533
00:18:21,800 --> 00:18:23,030
0,60 60,630 630,720 720,780 780,1230
the implications of {} transaction

534
00:18:23,030 --> 00:18:24,650
0,570 870,1230 1230,1440 1440,1530 1530,1620
system,| it has to be
|它必须是这样的，

535
00:18:24,650 --> 00:18:25,790
0,90 90,420 420,570 570,720 720,1140
the case,| that it forbids
|它禁止这种执行安排，

536
00:18:25,790 --> 00:18:29,060
0,210 210,960 990,1830 1920,2550 2580,3270
this particular execution {} schedule,|
|

537
00:18:29,860 --> 00:18:30,940
0,90 90,510 510,720 720,780 780,1080
you know {this,is} a simple
这是一个简单的版本，

538
00:18:30,940 --> 00:18:32,470
0,420 600,780 780,1230 1230,1320 1320,1530
version,| {} transactions for these
|这两个例子的事务并不复杂，

539
00:18:32,470 --> 00:18:33,340
0,210 210,570 570,630 630,780 780,870
two examples are not so

540
00:18:33,340 --> 00:18:34,600
0,540 540,690 690,870 870,1080 1080,1260
complicated,| so there not that
|所以不会有太多交错，

541
00:18:34,600 --> 00:18:35,320
0,210 210,300 300,390 390,540 540,720
many {interleavings - - -}

542
00:18:35,320 --> 00:18:37,060
0,60 60,180 180,450 870,1590 1590,1740
you have to,| you, you
|你认为可能会出问题。

543
00:18:37,060 --> 00:18:38,440
0,120 120,480 480,570 570,930 930,1380
could consider {that,could,go -} wrong.|
|

544
00:18:38,590 --> 00:18:39,760
0,390 390,570 570,690 690,870 870,1170
But there's at least one,
但至少还有另外一个，

545
00:18:39,760 --> 00:18:41,740
0,180 180,630 660,960 960,1350 1560,1980
other one,| that can result
|可能会导致不正确的结果，

546
00:18:41,740 --> 00:18:43,720
0,300 330,810 810,930 930,1410 1410,1980
in not an incorrect outcome,|
|

547
00:18:43,900 --> 00:18:46,090
0,300 300,780 1020,1500 1500,1650 1650,2190
which is {} we {do,the}
那就是我们先执行 put(x) ，

548
00:18:46,730 --> 00:18:49,520
0,510 540,930 930,1500
put x first,|
|

549
00:18:50,040 --> 00:18:51,660
0,390 390,600 600,900 900,990 990,1620
{} so here we go,|
所以我们开始，|

550
00:18:52,550 --> 00:18:54,290
0,570 570,1170 1170,1260 1260,1410 1410,1740
{} then you know we
然后我们打印两个，

551
00:18:54,290 --> 00:18:56,000
0,300 300,690 690,840 840,1260 1290,1710
actually print the two,| do
|执行两个 get ， get(x) get(y) ，

552
00:18:56,000 --> 00:19:00,410
0,210 210,780 1950,2490 2490,3060 3630,4410
two gets, {get(x) -} {get(y)},|
|

553
00:19:02,520 --> 00:19:03,510
0,240 240,330 330,600 600,780 780,990
and we do the {put(y)
然后我们执行 put(y) ，

554
00:19:03,510 --> 00:19:09,360
0,480 2550,3570 3570,3750 3750,5250 5250,5850
- -},| {is,this} a serializable
|这是可串行化的执行吗，

555
00:19:09,360 --> 00:19:10,620
0,720
execution,|
|

556
00:19:22,180 --> 00:19:23,170
0,150 150,300 300,390 390,840 840,990
is this an execution that
这是我们应该被可串行化事务系统禁止的执行吗，

557
00:19:23,170 --> 00:19:24,160
0,90 90,210 210,330 330,810 810,990
we should be forbidden by

558
00:19:24,160 --> 00:19:27,010
0,180 180,990 1140,1710 1710,2340 2340,2850
the serializable transaction system,| or
|还是可行的执行？

559
00:19:27,010 --> 00:19:29,120
0,90 90,330 330,600 600,1500
is it okay execution?|
|

560
00:19:30,800 --> 00:19:32,280
0,150 150,300 300,390 390,840
It should be forbidden.|
这应该被禁止。|

561
00:19:32,280 --> 00:19:33,270
0,180 180,330 330,420 420,720 720,990
It should be forbidden, correct,|
它应该被禁止，|

562
00:19:33,270 --> 00:19:35,010
0,240 240,540 540,720 720,1380 1530,1740
because as an outcome,| that
因为作为结果，|不会发生这种情况，

563
00:19:35,010 --> 00:19:36,120
0,300 300,510 510,600 600,990 990,1110
could not have happened,| if
|如果我们先执行 t1 ，然后执行 t2 ，

564
00:19:36,120 --> 00:19:38,190
0,120 120,630 630,780 780,1320 1770,2070
we executed {t1 -} {}

565
00:19:38,190 --> 00:19:39,630
0,360 360,570 570,690 690,900 900,1440
first followed by {t2 -}|
|

566
00:19:39,660 --> 00:19:40,980
0,240 240,450 450,690 690,990 990,1320
or {t2 -} first followed
或者先执行 t2 ，然后执行 t1 。

567
00:19:40,980 --> 00:19:42,600
0,90 90,270 270,570 750,1170
by {t1 -}, right.|
|

568
00:19:43,900 --> 00:19:45,640
0,300 300,840 900,1350 1350,1440 1440,1740
Okay, so what we clearly
好的，我们清楚地看到，

569
00:19:45,640 --> 00:19:46,930
0,300 300,450 450,720 720,870 870,1290
see is that,| {you,know} {serializability
|可串行化排除了（某些）执行，

570
00:19:46,930 --> 00:19:50,980
0,690 780,1620 1650,2310 2310,3270 3510,4050
-} excludes {you,know} executions, {}|
|

571
00:19:50,980 --> 00:19:53,230
0,300 300,570 570,960 960,1740 1740,2250
and just do, {} in
为了让程序员更容易地

572
00:19:53,230 --> 00:19:54,310
0,360 360,510 510,810 810,990 990,1080
order to actually make it

573
00:19:54,310 --> 00:19:55,630
0,330 330,450 450,960 960,1080 1080,1320
easier for programmers| to think
|考虑数据库所做的。

574
00:19:55,630 --> 00:19:57,820
0,270 270,690 690,1290 1290,1680 1680,2190
about actually what database does.|
|

575
00:19:58,480 --> 00:20:00,070
0,480 480,690 690,780 780,1200 1200,1590
And there are two broad
有两种大的方法来禁止执行，

576
00:20:00,070 --> 00:20:04,480
0,870 1050,1800 1800,2550 2550,3390 3450,4410
approaches to forbidding {} executions,|
|

577
00:20:05,300 --> 00:20:08,060
0,540 810,1440 1440,1800 1950,2100 2100,2760
and {} in these approaches,|
而且在这些方法中，|

578
00:20:08,060 --> 00:20:11,750
0,1890 1890,2250 2250,2700 2820,3270 3270,3690
the approach forbidding {is,called,concurrency -}
禁止的方法称为并发控制。

579
00:20:11,750 --> 00:20:13,920
0,630
control.|
|

580
00:20:22,020 --> 00:20:24,450
0,540 1170,1410 1410,1680 1680,1920 1920,2430
{} In the first approach,|
在第一种方法中，|

581
00:20:24,450 --> 00:20:26,880
0,90 90,210 210,570 780,1770 1920,2430
for the first category of
第一类解决方案是，

582
00:20:26,880 --> 00:20:28,140
0,570 570,720 720,870 870,960 960,1260
solutions is,| what is called
|所谓的悲观解决方案，

583
00:20:28,140 --> 00:20:29,940
0,600 600,1350
pessimistic solutions,|
|

584
00:20:35,400 --> 00:20:36,900
0,360 360,420 420,840 840,1140 1140,1500
and the pessimistic solution basically
悲观的解决方案是引入锁，

585
00:20:36,900 --> 00:20:40,020
0,480 480,1080
involve locks,|
|

586
00:20:40,350 --> 00:20:41,760
0,270 270,420 420,930 930,1020 1020,1410
so the idea is that,|
所以这个想法是，|

587
00:20:41,760 --> 00:20:43,770
0,150 150,240 240,810 810,1440 1650,2010
when the transaction runs or
当事务运行或开始时，

588
00:20:43,770 --> 00:20:46,530
0,720 810,1080 1080,1230 1230,1770 1770,2760
starts,| {} it requires necessary,
|它需要必要的锁来维护可串行化，

589
00:20:46,530 --> 00:20:49,230
0,600 600,1290 1410,1680 1680,1920 1920,2700
necessary locks {} to maintain

590
00:20:49,260 --> 00:20:51,660
0,300 300,510 510,1380 1530,2040 2040,2400
{} {serializability -},| and only
|只有确保以下情况才释放锁，

591
00:20:51,660 --> 00:20:54,270
0,420 420,540 540,1110 2100,2490 2490,2610
release the locks when it's

592
00:20:54,270 --> 00:20:56,850
0,660 660,870 870,1440 1470,2340 2340,2580
guaranteed,| that the executions will
|当执行会导致串行化执行时，

593
00:20:56,850 --> 00:20:58,710
0,480 480,570 570,630 630,1200 1230,1860
result in a serializable execution,|
|

594
00:20:59,450 --> 00:21:00,650
0,270 270,420 420,690 690,900 900,1200
{} so that's one approach|
这是一种方法，|

595
00:21:00,650 --> 00:21:01,100
0,90 90,150 150,270 270,330 330,450
and we're going to talk
我们稍后会更详细地讨论。

596
00:21:01,100 --> 00:21:01,880
0,30 30,210 210,330 330,510 510,780
a little bit more about

597
00:21:01,880 --> 00:21:03,100
0,120 120,180 180,570
in a second.|
|

598
00:21:03,100 --> 00:21:04,390
0,180 180,450 450,840 840,1140 1140,1290
The second approach is {}
第二种方法是是乐观的，

599
00:21:04,390 --> 00:21:07,840
0,630 630,1110 1500,1860 1860,2760
is {} is optimistic,|
|

600
00:21:12,050 --> 00:21:13,610
0,180 180,300 300,570 570,1110 1110,1560
and in the optimistic approach,
在乐观的方法中，没有锁，

601
00:21:13,610 --> 00:21:15,020
0,150 150,270 270,570 570,750 750,1410
there was basically no locks,|
|

602
00:21:16,730 --> 00:21:18,740
0,360 360,810 810,1170 1170,1620 1620,2010
and optimistic approach, {you,just} assume
乐观的方法，你只是假设一切都会好起来，

603
00:21:18,740 --> 00:21:19,640
0,180 180,240 240,390 390,600 600,900
things are gonna work out,|
|

604
00:21:20,960 --> 00:21:22,550
0,720 810,1230 1230,1350 1350,1440 1440,1590
and basically when you get
当你到达提交点时，

605
00:21:22,550 --> 00:21:23,980
0,60 60,150 150,420 420,840
to the commit point,|
|

606
00:21:24,130 --> 00:21:25,630
0,750 750,810 810,960 960,1260 1260,1500
{} you know the []
[]系统问你自己这个问题，

607
00:21:25,630 --> 00:21:27,220
0,600 630,930 930,990 990,1260 1260,1590
system sort of ask yourself

608
00:21:27,220 --> 00:21:29,140
0,60 60,660 690,1320 1350,1470 1470,1920
the question,| well, you know
|我之前做过的所有操作，

609
00:21:29,590 --> 00:21:30,880
0,240 240,450 480,810 810,900 900,1290
all the given the operation

610
00:21:30,880 --> 00:21:31,660
0,90 90,270 270,330 330,420 420,780
I've done in the past,|
|

611
00:21:31,660 --> 00:21:32,800
0,120 120,300 300,780 780,960 960,1140
is that actually could that
这是可线性化执行的结果吗，

612
00:21:32,800 --> 00:21:34,420
0,570 780,1020 1020,1170 1170,1500 1500,1620
be a the result of

613
00:21:34,420 --> 00:21:37,000
0,480 480,990 990,1500 1860,2370
a linearizable execution,| or
|或者这是可串行化执行的结果吗，

614
00:21:37,000 --> 00:21:37,900
0,180 180,390 390,540 540,600 600,900
could that be the result

615
00:21:37,900 --> 00:21:39,800
0,90 90,150 150,690 690,1290
of a serializable execution,|
|

616
00:21:39,890 --> 00:21:41,810
0,600 780,1050 1050,1560 1590,1860 1860,1920
{} if so, things are
如果是这样的话，一切都很好，没有问题，

617
00:21:41,810 --> 00:21:43,340
0,390 450,870 870,1140 1140,1230 1230,1530
fine, no problem at all,|
|

618
00:21:43,790 --> 00:21:44,930
0,390 390,780 780,900 900,1020 1020,1140
{} then you know we're
然后我们是好的，

619
00:21:44,930 --> 00:21:47,180
0,360 390,690 690,1080 1080,1770 1800,2250
good,| {if,it} is {} result
|如果结果不对应于单次执行，

620
00:21:47,180 --> 00:21:48,710
0,240 240,600 600,1290 1290,1440 1440,1530
this doesn't correspond to a

621
00:21:48,710 --> 00:21:50,480
0,300 300,1020 1140,1320 1320,1410 1410,1770
single execution,| they were basically
|它们会被终止，

622
00:21:50,480 --> 00:21:51,640
0,150 150,690
just abort,|
|

623
00:22:01,560 --> 00:22:03,900
0,510 510,1080 1080,1500 1500,2070 2070,2340
and maybe and {} it
它可能会重试。

624
00:22:03,900 --> 00:22:06,630
0,180 180,660 690,1020 1020,1710 2250,2730
will retry {} probably.| And
|我们将看到，

625
00:22:06,630 --> 00:22:08,970
0,210 210,690 690,1380 1410,2010 2040,2340
so we'll see,| I'm not
|我现在不会太多地谈论乐观的并发控制，

626
00:22:08,970 --> 00:22:10,620
0,120 120,330 330,540 540,810 810,1650
gonna talk much about optimistic

627
00:22:10,620 --> 00:22:11,880
0,90 90,300 300,660 660,810 810,1260
{concurrency -} control right now,|
|

628
00:22:12,120 --> 00:22:13,710
0,720 720,1050 1050,1350 1350,1440 1440,1590
but next week or two
但下周或两周后，

629
00:22:13,710 --> 00:22:14,850
0,180 180,300 300,510 510,720 720,1140
weeks from now,| after reading
|在读完 FaRM 论文后，

630
00:22:14,850 --> 00:22:16,950
0,120 120,480 480,990 1410,1800 1800,2100
the FaRM paper,| {} and
|你将看到一个乐观的分布式事务系统，

631
00:22:16,950 --> 00:22:19,320
0,150 150,750 750,930 930,1800 1800,2370
you'll see an optimistic {}

632
00:22:19,320 --> 00:22:21,300
0,450 450,780 780,1200 1200,1620 1620,1980
transaction system, distributed transaction system|
|

633
00:22:21,300 --> 00:22:22,290
0,90 90,180 180,420 420,540 540,990
of the type that we're
我们正在考虑的类型，

634
00:22:22,320 --> 00:22:24,450
0,540 660,960 960,1260 1260,1350 1350,2130
considering,| that uses an optimistic,
|它使用乐观并发控制方法，

635
00:22:24,480 --> 00:22:28,110
0,720 720,1260 1980,2520 2520,2880 2880,3630
optimistic control concurrency control approach,|
|

636
00:22:28,870 --> 00:22:29,740
0,270 270,420 420,480 480,750 750,870
{} but the focus for
但是今天的重点是悲观的（方式）。

637
00:22:29,740 --> 00:22:30,790
0,510 600,750 750,870 870,930 930,1050
today is going to be

638
00:22:30,790 --> 00:22:32,220
0,150 150,870
{} pessimistic.|
|

639
00:22:33,700 --> 00:22:35,980
0,510 750,1860 1860,2010 2010,2130 2130,2280
And one you know sort
一种[翻转方式]，

640
00:22:35,980 --> 00:22:38,770
0,90 90,810 1080,1530 1530,2130 2220,2790
of the [flip way], {}|
|

641
00:22:38,770 --> 00:22:39,850
0,180 180,360 360,540 540,960 960,1080
that these two approaches are
这两种方法在文献中经常被描述为，

642
00:22:39,850 --> 00:22:42,190
0,720 990,1410 1410,1590 1590,2040 2040,2340
described a in literature often

643
00:22:42,190 --> 00:22:43,390
0,270 270,390 390,540 540,600 600,1200
is,| {} sort of pessimistic
|悲观的（方法）是，

644
00:22:43,390 --> 00:22:45,250
0,540 750,1050 1050,1290 1290,1410 1410,1860
is,| {you,know,you} ask for permission
|你先获得许可，然后执行操作，

645
00:22:45,250 --> 00:22:46,600
0,630 690,840 840,1080 1080,1230 1230,1350
first and then you do

646
00:22:46,600 --> 00:22:48,040
0,210 210,1080
your operations,|
|

647
00:22:48,070 --> 00:22:49,720
0,630 660,840 840,1350 1350,1590 1590,1650
and the optimistic sort the
而乐观的方式则相反，

648
00:22:49,720 --> 00:22:50,950
0,150 150,300 300,690 750,990 990,1230
other way around,| you just
|你只管去执行你的操作，

649
00:22:50,950 --> 00:22:52,030
0,240 240,540 540,720 720,840 840,1080
go ahead and do your

650
00:22:52,030 --> 00:22:53,470
0,810 840,1050 1050,1110 1110,1320 1320,1440
operations,| and it turns out
|如果结果是错的，你随后道歉就可以了。

651
00:22:53,470 --> 00:22:54,490
0,60 60,180 180,660 690,840 840,1020
to be wrong, you just

652
00:22:54,490 --> 00:22:56,000
0,540 540,990
apologize later.|
|

653
00:22:56,520 --> 00:23:00,810
0,570 1200,1650 1650,2130 3390,4200 4200,4290
{} {So,that,is} {sort,of} analogy if
所以，如果你愿意的话，这是一种类比，

654
00:23:00,810 --> 00:23:03,000
0,150 150,660 1140,2040 2040,2100 2100,2190
you will,| between the two
|在这两种不同的方法之间。

655
00:23:03,000 --> 00:23:04,420
0,300 300,900
different approaches.|
|

656
00:23:05,200 --> 00:23:06,910
0,180 180,540 540,900 900,1050 1050,1710
And now within each approach,|
在每种方法中，|

657
00:23:06,940 --> 00:23:08,050
0,360 360,480 480,540 540,1050 1050,1110
whether it's {} pessimistic or
无论是悲观的还是乐观的，

658
00:23:08,050 --> 00:23:10,570
0,720 780,1020 1020,1080 1080,1920 1920,2520
optimistic,| there are many different
|有许多不同的并发控制方案，

659
00:23:10,600 --> 00:23:13,030
0,450 450,510 510,840 840,1410 1620,2430
{concurrency -} control plans, {}|
|

660
00:23:13,030 --> 00:23:14,980
0,150 150,270 270,870 1020,1380 1380,1950
you know to either increase
要么增加它们的并发性，

661
00:23:14,980 --> 00:23:16,750
0,180 180,900 900,1170 1170,1500 1500,1770
their concurrency| or provide weaker
|或者提供更弱的一致性和更多的并发性，

662
00:23:16,750 --> 00:23:19,510
0,1140 1140,1590 1590,1740 1740,1980 1980,2760
consistency and with more concurrency,|
|

663
00:23:19,660 --> 00:23:20,500
0,150 150,240 240,420 420,570 570,840
and so there's like a,
所以这是一个[很大的资料]。

664
00:23:20,650 --> 00:23:22,680
0,300 300,330 330,1080 1080,1590
there's a [huge literature].|
|

665
00:23:22,900 --> 00:23:24,940
0,630 810,1530 1590,1770 1770,1920 1920,2040
{} And I'm just gonna
我想谈谈一种特殊的方法，

666
00:23:24,940 --> 00:23:27,680
0,270 270,510 510,1290 1470,2460
talk about one {}

667
00:23:28,170 --> 00:23:30,020
0,510 510,1230
particular approach,|
|

668
00:23:30,020 --> 00:23:31,340
0,150 150,360 360,450 450,750 750,1320
{} which is very popular,|
它非常受欢迎，|

669
00:23:31,490 --> 00:23:32,660
0,750 750,840 840,960 960,1110 1110,1170
particularly if you want to
尤其是如果你想实现可串行化，

670
00:23:32,660 --> 00:23:34,700
0,510 540,1140 1140,1530 1530,1920 1920,2040
achieve {} {serializability -},| it
|事实证明不是，

671
00:23:34,700 --> 00:23:35,870
0,240 240,330 330,570 570,900 960,1170
turns out that not,| {alrough
|尽管我说过可串行化是数据库的黄金标准，

672
00:23:35,870 --> 00:23:37,100
0,180 180,270 270,570 570,900 900,1230
-} I said like {serializability,is

673
00:23:37,100 --> 00:23:38,300
0,480 480,540 540,810 810,1140 1140,1200
-} a gold standard for

674
00:23:38,300 --> 00:23:40,460
0,630 780,990 990,1320 1320,1770 1770,2160
databases,| it's often [] that
|数据库提供了多种程度的隔离，

675
00:23:40,790 --> 00:23:43,460
0,1410 1410,1650 1650,2190 2190,2550 2550,2670
databases offer multiple degrees of

676
00:23:43,460 --> 00:23:44,840
0,630 660,900 900,1080 1080,1290 1290,1380
isolation,| so {you,know} as a
|所以作为一个程序员，

677
00:23:44,840 --> 00:23:46,460
0,480 480,600 600,690 810,1380 1470,1620
programmer,| you can {sort,of,pick} you
|你可以选择你喜欢的隔离度，

678
00:23:46,460 --> 00:23:47,810
0,120 120,240 240,660 660,780 780,1350
know the degree of isolation

679
00:23:47,810 --> 00:23:49,100
0,150 150,270 270,690 990,1230 1230,1290
that you like,| and the
|你可能想要选择一个较弱的隔离度，

680
00:23:49,100 --> 00:23:50,270
0,360 360,780 780,930 930,1110 1110,1170
reason you may want to

681
00:23:50,270 --> 00:23:51,530
0,150 150,240 240,780 810,1140 1140,1260
pick a weaker degree of

682
00:23:51,530 --> 00:23:52,610
0,630 630,750 750,870 870,990 990,1080
isolation,| so that you can
|这样你可以获得更多的并发性。

683
00:23:52,610 --> 00:23:53,880
0,150 150,390 390,990
get more concurrency.|
|

684
00:23:54,540 --> 00:23:55,800
0,390 420,570 570,750 750,840 840,1260
Now we're going to stick
现在我们将坚持并发的黄金标准，

685
00:23:55,800 --> 00:23:57,060
0,150 150,540 540,810 810,1140 1140,1260
to the gold standard of

686
00:23:57,060 --> 00:23:58,950
0,750 900,1170 1170,1230 1230,1530 1530,1890
concurrency,| which is namely {serializability
|也就是可串行化，

687
00:23:58,950 --> 00:24:00,450
0,630 780,1200 1200,1260 1260,1380 1380,1500
-},| and if you do
|如果你要实现可串行化，

688
00:24:00,450 --> 00:24:03,180
0,420 420,1020 1080,1890 2070,2370 2370,2730
{serializability -},| then a common
|一种常见的方法是两阶段锁，

689
00:24:03,180 --> 00:24:05,240
0,690 690,810 810,1050 1050,1440
{approache,is} {2-phase -} locking,|
|

690
00:24:06,850 --> 00:24:07,880
0,180

691
00:24:15,090 --> 00:24:17,940
0,510 810,1380 1380,1920 1980,2610 2610,2850
{} {in,2-phase} locking, basically sort
在两阶段锁中，每个记录都有锁，

692
00:24:17,940 --> 00:24:19,980
0,60 60,570 570,690 690,1200
of lock per record,|
|

693
00:24:21,100 --> 00:24:22,940
0,300 300,390 390,720 720,1320
that's the starting point
这是数据库记录的起点，

694
00:24:23,260 --> 00:24:24,910
0,120 120,600 600,1110 1110,1470 1470,1650
for database record,| and you
|在我们的例子中，

695
00:24:24,910 --> 00:24:26,320
0,90 90,270 270,450 450,690 690,1410
know in our little example,|
|

696
00:24:26,530 --> 00:24:27,550
0,330 330,510 510,630 630,930 930,1020
{} that would be {}
这是对变量的锁，

697
00:24:27,550 --> 00:24:29,770
0,150 150,240 240,1380 1380,1710 1710,2220
sort of a lock for

698
00:24:30,100 --> 00:24:32,020
0,750 750,1290 1290,1380 1380,1500 1500,1920
{} variable,| and {} lock
|x 的锁和 y 的锁。

699
00:24:32,020 --> 00:24:33,070
0,150 150,540 540,720 720,960 960,1050
for x and lock for

700
00:24:33,070 --> 00:24:34,000
0,360
y.|
|

701
00:24:34,430 --> 00:24:36,080
0,330 330,510 510,810 810,1020 1020,1650
And there's basically two rules,|
有两条规则，|

702
00:24:36,590 --> 00:24:39,340
0,540 540,1230 1230,1950
{} one, transaction
第一，事务在使用之前需要一个锁，

703
00:24:41,340 --> 00:24:43,560
0,540 540,570 570,1260
requires a lock

704
00:24:45,840 --> 00:24:47,700
0,570 570,1140
before using,|
|

705
00:24:52,020 --> 00:24:53,250
0,390 390,600 600,780 780,900 900,1230
{} and so the idea
所以这个想法是，

706
00:24:53,250 --> 00:24:54,390
0,120 120,780 780,900 900,990 990,1140
is,| before you know you
|在你可以读写 x y 之前，

707
00:24:54,390 --> 00:24:56,100
0,120 120,540 600,1080 1080,1560 1590,1710
can read or write you

708
00:24:56,100 --> 00:24:57,630
0,150 150,330 330,630 630,1320 1410,1530
know to x y,| you
|你必须先拿到锁，

709
00:24:57,630 --> 00:24:59,100
0,210 210,390 390,720 720,1350 1350,1470
first have to obtain the

710
00:24:59,100 --> 00:25:00,480
0,420 420,540 540,600 600,1080 1080,1380
lock,| and the transaction system
|事务系统会帮你做到这个，

711
00:25:00,480 --> 00:25:01,380
0,90 90,210 210,360 360,570 570,900
will do this for you,|
|

712
00:25:01,920 --> 00:25:03,320
0,690

713
00:25:03,470 --> 00:25:06,800
0,780 810,1410 1740,2010 2010,2850
two, the T holds
第二， T 持有一把锁，

714
00:25:06,800 --> 00:25:08,990
0,90 90,690 930,1320 1320,1410 1410,2190
a lock,| once you're acquired,|
|一旦你获取，|

715
00:25:09,720 --> 00:25:10,950
0,240 240,420 420,720 720,810 810,1230
you're not allowed to release
你不允许释放它，直到提交或中止，

716
00:25:10,950 --> 00:25:13,060
0,330 420,870 870,1050 1050,1560
it {until -} commit

717
00:25:14,980 --> 00:25:17,300
0,240 240,330 330,810 900,1530
or {abort -},| whatever,
|无论事务的结果是什么。

718
00:25:17,760 --> 00:25:18,480
0,330 330,420 420,540 540,630 630,720
whatever is the end of

719
00:25:18,480 --> 00:25:19,700
0,90 90,660
the transaction.|
|

720
00:25:20,260 --> 00:25:21,700
0,480 690,900 900,1140 1140,1260 1260,1440
Okay, and so in our
好的，在我们这个案例中，

721
00:25:21,700 --> 00:25:22,630
0,300 300,600 600,720 720,840 840,930
particular case,| if we have
|如果我们有 T1 运行， T2 运行，

722
00:25:22,630 --> 00:25:24,180
0,210 210,360 360,990
like {T1 -}

723
00:25:24,880 --> 00:25:26,290
0,570 570,720 720,810 810,930 930,1410
running and we have {T2

724
00:25:26,290 --> 00:25:27,840
0,360 360,900
-} running,|
|

725
00:25:27,840 --> 00:25:29,910
0,690 720,1050 1050,1320 1320,1680 1680,2070
and {} {T1 -} locks
T1 首先对 x 加锁，

726
00:25:29,910 --> 00:25:32,070
0,300 300,930 1380,1710 1710,2070 2070,2160
x first,| and then you
|然后对 y 加锁，

727
00:25:32,070 --> 00:25:34,290
0,210 210,840 1080,1800 1950,2100 2100,2220
know lock y,| and it
|它必须维持这些锁，

728
00:25:34,290 --> 00:25:36,060
0,300 300,360 360,1080 1110,1380 1380,1770
has to maintain those locks|
|

729
00:25:36,060 --> 00:25:37,830
0,210 210,690 690,1110 1110,1410 1410,1770
until {it,actually} reaches commit points,|
直到它达到提交点，|

730
00:25:40,520 --> 00:25:42,110
0,840 840,1170 1170,1260 1260,1350 1350,1590
{so,T2} runs at the same
T2 在同一时间或大致相同时间运行，

731
00:25:42,110 --> 00:25:43,160
0,450 450,600 600,900 900,990 990,1050
time or roughly at the

732
00:25:43,160 --> 00:25:45,320
0,270 270,750 900,1140 1140,1770 1770,2160
same time,| if {T2 -}
|如果 T2 开始得晚一点，

733
00:25:45,320 --> 00:25:46,730
0,210 210,270 270,570 570,840 840,1410
starts a little bit later,|
|

734
00:25:46,940 --> 00:25:47,990
0,180 180,300 300,570 570,660 660,1050
and it tries to grab
它试图获得 x 的锁，

735
00:25:47,990 --> 00:25:50,030
0,60 60,420 420,1020 1470,1890 1890,2040
the {lock,in} x,| {} {t1
|T1 拥有它，

736
00:25:50,030 --> 00:25:51,710
0,300 300,420 420,690 690,990 1140,1680
-} will have it,| {if,T2}
|如果 T2 开始的时间稍晚一些，

737
00:25:51,710 --> 00:25:52,850
0,300 300,330 330,510 510,600 600,1140
started a little bit later,|
|

738
00:25:53,030 --> 00:25:54,860
0,570 570,660 660,840 840,1230 1230,1830
and at that point, basically
在这一点上， T2 必须等待，

739
00:25:54,860 --> 00:25:55,940
0,180 180,390 390,600 600,690 690,1080
{T2 -} has to wait,|
|

740
00:25:58,140 --> 00:25:59,430
0,120 120,330 330,390 390,780 780,1290
{} sort of standard locking
一种标准的锁定协议。

741
00:25:59,490 --> 00:26:01,410
0,420 420,900 1320,1560 1560,1620 1620,1920
{protocol -}.| And the basic
|两阶段锁的基本思想是，

742
00:26:01,410 --> 00:26:02,970
0,540 540,690 690,930 930,1320 1320,1560
idea {2-phase -} locking is

743
00:26:02,970 --> 00:26:04,800
0,360 720,1350 1350,1560 1560,1740 1740,1830
that,| {} it's sort of
|它是对这个简单锁方案的改进，

744
00:26:04,800 --> 00:26:07,530
0,570 720,1470 1470,1740 1740,2340 2340,2730
a refinement or improvement over

745
00:26:07,530 --> 00:26:09,060
0,180 180,720 720,1020 1020,1320 1320,1530
this simple locking scheme,| that
|在文档中描述，

746
00:26:09,060 --> 00:26:11,040
0,660 690,1110 1110,1290 1290,1410 1410,1980
{is,described} {} in the document|
|

747
00:26:11,040 --> 00:26:12,960
0,240 240,570 810,1020 1020,1500 1500,1920
{} and which sometimes are
有时被称为简单锁或严格锁，

748
00:26:13,050 --> 00:26:14,610
0,630 630,930 930,1200 1200,1290 1290,1560
called simple locking or strict

749
00:26:14,610 --> 00:26:15,960
0,480 570,900 900,1200 1200,1260 1260,1350
locking,| where basically at the
|在事务开始时，

750
00:26:15,960 --> 00:26:17,220
0,270 270,360 360,450 450,1050 1110,1260
beginning of the transaction,| you
|你获取整个事务所需的所有锁，

751
00:26:17,220 --> 00:26:18,060
0,270 270,390 390,450 450,540 540,840
grab all of the locks

752
00:26:18,060 --> 00:26:19,200
0,120 120,570 690,870 870,930 930,1140
you need for the whole

753
00:26:19,200 --> 00:26:20,820
0,690 750,930 930,1230 1230,1380 1380,1620
transaction,| you hold them until
|你持有它们直到最后，然后释放它们，

754
00:26:20,820 --> 00:26:21,540
0,150 150,360 360,480 480,600 600,720
the end and then you

755
00:26:21,540 --> 00:26:22,380
0,270 270,450
release them,|
|

756
00:26:22,620 --> 00:26:24,300
0,600 600,1020 1020,1140 1140,1380 1380,1680
and {} {2-phase -} locking
而两阶段锁要更细粒度一点，

757
00:26:24,300 --> 00:26:24,930
0,90 90,150 150,330 330,450 450,630
is a little bit more

758
00:26:24,930 --> 00:26:27,630
0,720 960,1140 1140,1440 1440,1950 1980,2700
fine-grained,| {} in that, {}
|其中，即使事务[]，

759
00:26:27,720 --> 00:26:29,940
0,630 630,1080 1080,1200 1200,1770 1770,2220
even if the transactions [],|
|

760
00:26:30,180 --> 00:26:32,440
0,1710

761
00:26:32,440 --> 00:26:33,400
0,150 150,450 450,480 480,630 630,960
and they are not required
它们不需要直接获取锁，

762
00:26:33,400 --> 00:26:34,510
0,60 60,390 390,480 480,840 840,1110
to lock {immediately -}| all
|在开始的时候同时获取所有（锁），

763
00:26:34,510 --> 00:26:35,380
0,90 90,180 180,480 480,780 780,870
at the same time at

764
00:26:35,380 --> 00:26:36,380
0,60 60,390
the beginning,|
|

765
00:26:36,620 --> 00:26:38,450
0,540 540,870 870,1380 1380,1470 1470,1830
instead, they require the locks
相反，它们在事务运行时以增量方式获取锁，

766
00:26:38,450 --> 00:26:40,550
0,720 720,990 990,1080 1080,1590 1590,2100
incrementally as the transaction runs,|
|

767
00:26:40,730 --> 00:26:42,980
0,360 360,1050 1050,1500 1500,1860 1860,2250
which allows certain concurrency patterns
允许某些严格锁不允许的并发模式。

768
00:26:42,980 --> 00:26:44,960
0,360 360,510 510,1200 1200,1650 1680,1980
that are disallowed by {}

769
00:26:44,990 --> 00:26:46,180
0,330 330,600
strict lock.|
|

770
00:26:47,320 --> 00:26:49,600
0,990 1140,1260 1260,1470 1470,1740 1740,2280
Now, the first rule seems
现在，第一条规则似乎很清楚，

771
00:26:49,600 --> 00:26:51,250
0,240 240,720 750,1200 1200,1260 1260,1650
pretty clear,| why you {need,it},|
|为什么你需要它，|

772
00:26:51,580 --> 00:26:53,890
0,690 1050,1410 1410,1680 1680,1890 1890,2310
the second rule might be,
第二条规则也许不那么明显，

773
00:26:53,920 --> 00:26:55,840
0,390 390,630 630,1260 1590,1770 1770,1920
maybe less obvious,| and so
|这可能是一个好主意，

774
00:26:55,840 --> 00:26:57,250
0,180 180,960 990,1230 1230,1260 1260,1410
it's a probably a good

775
00:26:57,250 --> 00:26:59,500
0,330 330,480 480,1020 1530,2040 2040,2250
idea| to actually see what
|看看哪里会出问题，

776
00:26:59,500 --> 00:27:00,550
0,210 210,660 660,750 750,870 870,1050
goes wrong,| if you did
|如果你没有坚持第二条规则。

777
00:27:00,550 --> 00:27:01,960
0,270 270,600 600,660 660,990 990,1410
not maintain the second rule.|
|

778
00:27:02,900 --> 00:27:05,180
0,300 300,840 990,1530 1530,1980 2010,2280
And so, let's say talk
所以，让我们来讨论一下 until 提交，

779
00:27:05,180 --> 00:27:06,050
0,30 30,240 240,390 390,720 720,870
a little bit about {until

780
00:27:06,050 --> 00:27:07,460
0,180 180,600
-} commit,|
|

781
00:27:12,250 --> 00:27:14,560
0,690 690,900 900,1590 1590,1890 1980,2310
and so {here,we,have} our two
所以这里我们有两个事务，

782
00:27:14,560 --> 00:27:16,140
0,810
transactions,|
|

783
00:27:16,310 --> 00:27:18,290
0,330 330,690 690,900 900,1440 1710,1980
{T1,and -} T2 {you,know -}
T1 和 T2 ，分别是转账和打印语句，

784
00:27:18,290 --> 00:27:19,260
0,420
the

785
00:27:19,510 --> 00:27:21,460
0,630 630,900 900,1110 1110,1350 1350,1950
transfer and the print statement,|
|

786
00:27:21,850 --> 00:27:23,230
0,540 540,690 690,900 900,1290 1290,1380
and so let's say you
所以我们假设，

787
00:27:23,230 --> 00:27:24,430
0,120 120,480 480,690 690,930 930,1200
know,| here we do our
|在这里，我们执行 put(x) ，

788
00:27:24,430 --> 00:27:26,410
0,180 180,270 270,750 1320,1770 1770,1980
put of x,| and so
|这意味着在 put(x) 之前，

789
00:27:26,410 --> 00:27:27,760
0,390 390,690 690,1020 1020,1110 1110,1350
that means before the put

790
00:27:27,760 --> 00:27:30,130
0,330 330,990 1020,1440 1440,1830 1830,2370
x,| transaction system locks x,|
|事务系统锁定 x ，|

791
00:27:31,480 --> 00:27:32,500
0,240 240,420 420,690 690,900 900,1020
and let's say that we're
假设我们没有遵循两阶段锁规定，

792
00:27:32,500 --> 00:27:33,880
0,270 270,810 810,930 930,1080 1080,1380
not following the {2-phase -}

793
00:27:33,880 --> 00:27:35,740
0,330 330,750 1020,1500 1500,1620 1620,1860
locking rule,| and we actually
|我们在 put 之后释放 x 的锁，

794
00:27:35,740 --> 00:27:37,750
0,390 390,510 510,990 1140,1710 1710,2010
release the lock x right

795
00:27:37,750 --> 00:27:39,940
0,660 1020,1380 1380,1530 1530,1950 1950,2190
after {} the put,| because
|因为我们已经完成了，

796
00:27:39,940 --> 00:27:40,840
0,120 120,360 360,510 510,660 660,900
we're done with it,| actually
|不会再出现在事务 T1 中，

797
00:27:40,840 --> 00:27:42,280
0,210 210,450 450,600 600,720 720,1440
doesn't show up in transaction

798
00:27:42,340 --> 00:27:43,870
0,390 390,1050 1170,1290 1290,1440 1440,1530
t1 anymore,| there will be
|稍后还有一个 put ， put(y) ，

799
00:27:43,870 --> 00:27:44,800
0,60 60,330 330,630 630,720 720,930
a later put, for us

800
00:27:44,800 --> 00:27:46,320
0,270 270,360 360,840
put to y,|
|

801
00:27:47,660 --> 00:27:49,130
0,180 180,330 330,630 630,780 780,1470
and let's assume that,| before
让我们假设，|在获取 y 的锁之前， T2 运行，

802
00:27:49,130 --> 00:27:50,870
0,300 300,570 570,720 720,1140 1170,1740
actually get to the locking

803
00:27:50,870 --> 00:27:53,420
0,150 150,750 1320,1620 1620,1920 1920,2550
of y, {T2 -} runs,|
|

804
00:27:53,540 --> 00:27:56,120
0,240 240,540 540,810 810,1470 1650,2580
and actually {T2 -} {}
T2 整个是，

805
00:27:56,150 --> 00:27:57,960
0,480 480,570 570,1170
basically the whole,|
|

806
00:27:57,960 --> 00:27:59,580
0,120 120,390 780,960 960,1140 1140,1620
you know the two gets,
两个 get ， get(x) get(y) ，

807
00:27:59,580 --> 00:28:01,680
0,270 270,480 480,570 570,1170 1920,2100
you get of x and
你摆脱了x，让y跑了

808
00:28:01,680 --> 00:28:04,770
0,270 270,690 690,1380 2310,2640 2640,3090
get y run,| and so
|如果 T1 释放 x 的锁，

809
00:28:04,800 --> 00:28:06,180
0,540 540,630 630,870 870,1080 1080,1380
since you know {T1 -}

810
00:28:06,180 --> 00:28:07,740
0,450 450,540 540,840 840,1230 1230,1560
release the lock x,| {you,know}
|它可以得到 x 的锁，

811
00:28:07,740 --> 00:28:09,000
0,180 180,360 360,420 420,720 720,1260
{it,can} get the lock x,|
|

812
00:28:09,450 --> 00:28:11,700
0,720 810,1110 1110,1440 1440,1770 1770,2250
since {} {T1 -} hasn't
因为 T1 还没有完成 put ，

813
00:28:11,760 --> 00:28:13,260
0,720 720,840 840,900 900,1140 1140,1500
done to the put yet,|
|

814
00:28:13,260 --> 00:28:14,070
0,90 90,300 300,480 480,600 600,810
you know it can also
它也能获得 y 的锁，

815
00:28:14,070 --> 00:28:15,510
0,150 150,240 240,600 630,870 870,1440
get the lock on y|
|

816
00:28:15,840 --> 00:28:17,220
0,240 240,480 480,1050 1050,1260 1260,1380
and so {you,know,print} x and
所以打印 x 和 y ，

817
00:28:17,220 --> 00:28:20,840
0,570 1500,2070 2430,2610 2610,3030
y,| and {reset -}
|然后重新设置，然后释放锁。

818
00:28:21,050 --> 00:28:23,040
0,180 180,330 330,600 600,1110
and then release locks.|
|

819
00:28:26,180 --> 00:28:27,660
0,930
So,
那么，这是一个可串行化的执行吗？

820
00:28:28,660 --> 00:28:30,490
0,180 180,840 1170,1440 1440,1590 1590,1830
is this, would this be

821
00:28:30,490 --> 00:28:34,560
0,1170 1170,1350 1350,2190 2370,3480
a {serializable -} {}

822
00:28:35,400 --> 00:28:36,740
0,780
execution?|
|

823
00:28:41,010 --> 00:28:42,240
0,360 360,600 600,690 690,960 960,1230
No, it's the same as
不，它跟以前一样。

824
00:28:42,270 --> 00:28:44,040
0,480 540,1170 1170,1530 1530,1590 1590,1770
before.| Yeah, exactly the same
|是的，跟以前一样，

825
00:28:44,040 --> 00:28:45,510
0,90 90,510 510,780 780,1020 1020,1470
as before, right,| because basically
|因为这里的打印语句，

826
00:28:45,510 --> 00:28:48,450
0,300 1440,1800 1800,2250 2250,2430 2430,2940
the print statements like here,|
|

827
00:28:48,510 --> 00:28:49,860
0,210 210,450 450,510 510,1080 1080,1350
they sort of slipped in
它们处于两个 put x 和 y 之间，

828
00:28:49,860 --> 00:28:50,850
0,330 330,390 390,720 720,930 930,990
between the two put in

829
00:28:50,850 --> 00:28:52,500
0,270 270,420 420,900 960,1590 1590,1650
x and y,| between the
|在两个 put x 和 y 之间，

830
00:28:52,500 --> 00:28:53,370
0,180 180,420 420,540 540,690 690,870
two put of the x

831
00:28:53,370 --> 00:28:54,960
0,120 120,510 870,1110 1110,1230 1230,1590
and y,| and we already
|我们之前已经总结了，

832
00:28:54,960 --> 00:28:56,250
0,390 390,780 780,960 960,1080 1080,1290
concluded earlier,| that is not
|这不是可串行化的执行，

833
00:28:56,250 --> 00:28:57,600
0,30 30,450 450,630 630,1110 1170,1350
a {serializable -} conclusion, {}

834
00:28:57,600 --> 00:28:59,340
0,540 540,720 720,1230
{serializable -} execution.|
|

835
00:28:59,540 --> 00:29:00,560
0,150 150,300 300,450 450,540 540,1020
{} So this is wrong,|
所以这是错误的，|

836
00:29:00,890 --> 00:29:01,520
0,180 180,300 300,390 390,480 480,630
and so this is a
所以这是一个很好的演示例子，

837
00:29:01,520 --> 00:29:02,990
0,150 150,600 600,690 690,1290 1290,1470
good example of demonstrating,| that
|如果你过早地解锁，

838
00:29:02,990 --> 00:29:03,950
0,90 90,300 300,570 570,660 660,960
if you release the lock

839
00:29:03,950 --> 00:29:05,900
0,150 150,690 750,1590 1590,1770 1770,1950
too early,| {} in this
|在这种情况下， T1 过早地释放 x ，

840
00:29:05,900 --> 00:29:07,580
0,240 240,390 390,1170 1170,1500 1500,1680
case {T1 -} release the

841
00:29:07,580 --> 00:29:09,530
0,570 570,1080 1230,1560 1560,1740 1740,1950
{x,too} early,| {} you're not
|你不会得到一个可串行化的执行。

842
00:29:09,530 --> 00:29:11,030
0,180 180,360 360,450 450,960 960,1500
gonna get a serializable execution.|
|

843
00:29:12,390 --> 00:29:13,080
0,150 150,300 300,420 420,540 540,690
And one way to think
一种考虑它的方式是，

844
00:29:13,080 --> 00:29:14,220
0,210 210,300 300,750 750,870 870,1140
about it basically is that,|
|

845
00:29:14,280 --> 00:29:15,450
0,720 720,840 840,990 990,1050 1050,1170
whatever there's sort of an
在两个锁集中间有交集，

846
00:29:15,450 --> 00:29:18,840
0,720 1260,2520 2520,2610 2610,2790 2790,3390
intersection between you know two

847
00:29:18,840 --> 00:29:20,250
0,120 120,420 420,780 780,1170 1170,1410
{} lock sets,| {so,T1 -}
|所以 T1 有 x y 的锁集，

848
00:29:20,250 --> 00:29:20,970
0,150 150,240 240,450 450,600 600,720
has a lock set of

849
00:29:20,970 --> 00:29:22,110
0,150 150,240 240,540 540,810 810,1140
x and y,| {T2 -}
|T2 也有 x y 的锁集，

850
00:29:22,110 --> 00:29:23,040
0,180 180,240 240,510 510,690 690,930
has a lock set of

851
00:29:23,100 --> 00:29:26,400
0,810 990,1320 1320,1860 1980,2550 2550,3300
x y too,| {} it
|重要的是，

852
00:29:26,400 --> 00:29:27,810
0,60 60,600 600,900 900,1050 1050,1410
is important that,| you know
|这两个事务可以以特定方式排序，

853
00:29:27,810 --> 00:29:30,030
0,450 480,930 930,1860 1860,2100 2100,2220
{} during, {} these two

854
00:29:30,030 --> 00:29:30,990
0,420 420,540 540,810 810,870 870,960
transactions can order in a

855
00:29:30,990 --> 00:29:32,190
0,300 300,540 540,690 690,960 960,1200
particular way,| that means that
|这意味着如果锁相交，

856
00:29:32,310 --> 00:29:34,560
0,630 630,900 900,1200 1200,1590 1590,2250
{} if the locks intersect,|
|

857
00:29:34,710 --> 00:29:35,490
0,120 120,240 240,390 390,660 660,780
you know we have to
我们必须确保一些整体顺序，

858
00:29:35,490 --> 00:29:37,080
0,240 240,600 600,780 780,1050 1050,1590
make ensure some total ordering,|
|

859
00:29:37,470 --> 00:29:38,430
0,300 300,450 450,720 720,810 810,960
and that means that we
这意味着我们必须

860
00:29:38,430 --> 00:29:39,450
0,330 330,540 540,600 600,930 930,1020
actually have to| hold the
|持有锁直到提交点，

861
00:29:39,450 --> 00:29:41,070
0,570 690,870 870,1050 1050,1320 1320,1620
lock to the end until

862
00:29:41,070 --> 00:29:42,100
0,180 180,750
the {commit,point},|
|

863
00:29:42,100 --> 00:29:43,900
0,180 180,360 360,690 690,1410 1410,1800
so that no intermediate results
没有事务的中间结果对其他事务可见，

864
00:29:43,900 --> 00:29:45,010
0,90 90,180 180,720 720,810 810,1110
of the transaction are actually

865
00:29:45,010 --> 00:29:46,980
0,420 420,510 510,750 750,1470
visible to other transactions,|
|

866
00:29:47,530 --> 00:29:48,850
0,240 240,390 390,690 690,1050 1050,1320
and we release locks before
我们在提交点之前释放锁，

867
00:29:48,850 --> 00:29:50,410
0,60 60,330 330,750 990,1320 1320,1560
the commit point,| we might
|我们可能会让结果变得可见，

868
00:29:50,410 --> 00:29:52,240
0,300 300,660 660,930 930,1260 1260,1830
actually make a result visible,|
|

869
00:29:52,330 --> 00:29:53,560
0,300 300,750 750,840 840,1050 1050,1230
even though {you,know} may be
即使晚点它可能中止，

870
00:29:53,560 --> 00:29:54,910
0,270 270,690 690,870 870,960 960,1350
later {it's,actually} even {abort -},

871
00:29:55,060 --> 00:29:55,990
0,330 330,450 450,630 630,720 720,930
right,| and then the whole
|然后，整个变化就会消失，

872
00:29:55,990 --> 00:29:57,460
0,300 300,480 480,630 630,990
change will go away,|
|

873
00:29:58,610 --> 00:29:59,390
0,270 270,390 390,450 450,510 510,780
so this is the reason
这就是为什么锁必须持有到底的原因。

874
00:29:59,390 --> 00:30:00,770
0,570 600,720 720,1080 1080,1290 1290,1380
why the locks must be

875
00:30:00,770 --> 00:30:02,100
0,270 270,720
{held,to} {the,end}.|
|

876
00:30:03,670 --> 00:30:05,680
0,510 510,630 630,1050 1050,1920 1920,2010
Now, an obvious problem that
现在，你们中的许多人问到的一个明显的问题，

877
00:30:05,680 --> 00:30:06,910
0,240 240,300 300,510 510,780 780,1230
many of you asked about,|
|

878
00:30:07,300 --> 00:30:10,090
0,810 840,1590 1830,2190 2190,2550 2550,2790
in {} 2-phase locking,| is
在两阶段锁中，|是不是会有死锁，

879
00:30:10,090 --> 00:30:11,320
0,240 240,480 480,810 840,990 990,1230
{} {there,is} a, is there

880
00:30:11,320 --> 00:30:13,120
0,90 90,390 390,480 480,1110
a chance of deadlock,|
|

881
00:30:14,200 --> 00:30:16,210
0,360 360,510 510,1200 1200,1320 1320,2010
if you're requiring the locks
如果你在事务执行时获取锁。

882
00:30:16,700 --> 00:30:18,920
0,390 390,990 990,1110 1110,1620 1620,2220
{as -} the transactions execute.|
|

883
00:30:19,430 --> 00:30:20,750
0,150 150,330 330,660 660,1170 1170,1320
And so let's,| this is
所以我们，|这绝对是一种情况，

884
00:30:20,750 --> 00:30:23,270
0,510 510,570 570,1080 1260,2190 2190,2520
absolutely the case,| and so
|例如，我们稍微修改一下 T2 ，

885
00:30:23,270 --> 00:30:25,940
0,420 420,660 660,1410 1440,1920 1920,2670
{for,example}, let's modify T2 slightly,|
|

886
00:30:26,480 --> 00:30:27,770
0,210 210,600 600,840 840,900 900,1290
so T2 used to be,|
所以 T2 原来是，|

887
00:30:27,770 --> 00:30:29,990
0,120 120,270 270,1050 1230,1680 1680,2220
you know t1 gets x,|
t1 get(x) ，|

888
00:30:30,260 --> 00:30:31,160
0,390 390,510 510,630 630,690 690,900
instead we're going to do
相反，我们要用相反的顺序， get(y) ，

889
00:30:31,160 --> 00:30:32,270
0,180 180,270 270,360 360,720 720,1110
with in the opposite order

890
00:30:32,270 --> 00:30:34,160
0,390 390,570 570,720 720,1290
refers to get y,|
|

891
00:30:34,380 --> 00:30:38,550
0,810 840,1200 1200,1740 1770,2790 3390,4170
and {t2 -} gets x,|
而 t2 get(x) ，|

892
00:30:39,060 --> 00:30:40,470
0,210 210,660 660,1050 1050,1140 1140,1410
and we remain we keep
我们保持 T1 不变，

893
00:30:40,470 --> 00:30:41,730
0,120 120,360 360,420 420,810 1050,1260
{T1 -} the same, right,|
|

894
00:30:41,730 --> 00:30:42,870
0,150 150,300 300,570 570,840 840,1140
so {T1 -} actually still
所以 T1 仍然是首先 put(x) ，然后 put(y) ，

895
00:30:42,870 --> 00:30:44,100
0,210 210,510 510,720 720,810 810,1230
the first put to x

896
00:30:44,100 --> 00:30:45,030
0,120 120,300 300,450 450,540 540,930
and then put to y,|
|

897
00:30:45,540 --> 00:30:46,620
0,270 270,540 540,660 660,780 780,1080
so now we can easily
所以现在我们很容易陷入麻烦，

898
00:30:46,620 --> 00:30:48,300
0,180 180,570 600,1260
get into trouble,|
|

899
00:30:48,850 --> 00:30:49,900
0,300 300,510 510,630 630,840 840,1050
so this is {T2 -}
所以这是 T2' ，

900
00:30:49,900 --> 00:30:51,060
0,630
prime,|
|

901
00:30:51,060 --> 00:30:52,320
0,420 420,600 600,750 750,960 960,1260
{} and this is just
这是我们已经有的普通的 T1 ，

902
00:30:52,320 --> 00:30:53,790
0,300 300,840 840,1170 1170,1350 1350,1470
the ordinary {T1 -} that

903
00:30:53,790 --> 00:30:55,380
0,120 120,360 360,840 1200,1350 1350,1590
we already have,| it does
|它执行 put(x) ，

904
00:30:55,380 --> 00:30:56,840
0,180 180,210 210,960
put of x,|
|

905
00:30:57,340 --> 00:30:58,870
0,480 480,750 750,810 810,1020 1020,1530
{you,know,before} doing the {put,of} x|
在做 put(x) 之前，|

906
00:30:58,870 --> 00:30:59,650
0,90 90,240 240,330 330,480 480,780
and needs to get the
需要获取 x 的锁，

907
00:31:00,100 --> 00:31:01,930
0,690 720,1020 1020,1290 1290,1530 1530,1830
lock on x,| so L
|所以锁 Lx 。

908
00:31:01,930 --> 00:31:03,880
0,450 450,660 660,1290
locks {Lx -}.|
|

909
00:31:04,000 --> 00:31:05,290
0,450 480,630 630,840 840,1110 1110,1290
{} Now let's say that
现在我们假设排序如下所示，

910
00:31:05,290 --> 00:31:07,990
0,510 540,1050 1080,1650 1650,2100 2100,2700
the {} ordering {works,out} {as,follows},|
|

911
00:31:07,990 --> 00:31:09,370
0,120 120,300 300,750 780,1050 1050,1380
you know the same time
T2' 同时运行，

912
00:31:09,370 --> 00:31:11,350
0,780 810,1020 1020,1170 1170,1500 1500,1980
to {T2' - -} runs,|
|

913
00:31:11,590 --> 00:31:14,800
0,150 150,420 420,1140 1470,2460
it does get y,|
它执行 get(y) ，|

914
00:31:14,950 --> 00:31:15,880
0,240 240,360 360,510 510,810 810,930
{} so that means you've
这意味着你获得 y 的锁，

915
00:31:15,880 --> 00:31:17,500
0,210 210,390 420,900 900,1050 1050,1620
got the lock on y,|
|

916
00:31:18,490 --> 00:31:19,600
0,420 420,570 570,660 660,780 780,1110
and now you can easily
现在你可以很容易地看到这里出了什么问题，

917
00:31:19,600 --> 00:31:20,920
0,210 210,330 330,480 480,840 840,1320
see what goes wrong here,|
|

918
00:31:21,040 --> 00:31:22,510
0,690 720,930 930,1200 1200,1290 1290,1470
now {t1 -} is gonna
现在 T1 执行 put(y) 或要执行 put(y) ，

919
00:31:22,510 --> 00:31:23,770
0,300 300,390 390,570 570,690 690,1260
do {} put of y

920
00:31:24,580 --> 00:31:25,510
0,240 240,450 450,540 540,690 690,930
or wants to do put

921
00:31:25,510 --> 00:31:27,490
0,480 1020,1410 1410,1560 1560,1740 1740,1980
y,| {} so we need
|所以我们需要获得 y 的锁，

922
00:31:27,490 --> 00:31:28,720
0,90 90,240 240,330 330,840 960,1230
to get the lock on

923
00:31:28,720 --> 00:31:31,240
0,630 960,1350 1350,1800 2130,2280 2280,2520
y,| {} but you can't
|但你不能得到它，

924
00:31:31,240 --> 00:31:32,410
0,180 180,480 480,930 930,1020 1020,1170
get it,| because you know
|因为 T2' 已经持有那个锁，

925
00:31:32,410 --> 00:31:34,600
0,210 210,420 420,1050 1350,1470 1470,2190
{T2' - -} {} actually

926
00:31:34,600 --> 00:31:35,680
0,270 270,360 360,600 600,840 840,1080
has the lock,| so it
|所以它必须在这里等待，并阻塞，

927
00:31:35,680 --> 00:31:36,850
0,180 180,270 270,510 510,960 990,1170
has to wait here and

928
00:31:36,850 --> 00:31:37,920
0,90 90,630
the block,|
|

929
00:31:38,280 --> 00:31:39,120
0,210 210,450 450,570 570,690 690,840
{you,know} same thing is gonna
同样的事情当然也会发生在另一边，

930
00:31:39,120 --> 00:31:39,960
0,300 300,420 420,660 660,720 720,840
happen of course on the

931
00:31:39,960 --> 00:31:41,130
0,180 180,600 600,690 690,780 780,1170
other side,| you know when
|在执行 get(x) 之前，

932
00:31:41,310 --> 00:31:43,290
0,690 690,930 930,990 990,1410 1440,1980
before doing the get of

933
00:31:43,290 --> 00:31:45,240
0,450 840,1290 1290,1560 1560,1830 1830,1950
x,| {} {T2 -} will
|T2 需要获得 x 的锁，

934
00:31:45,240 --> 00:31:46,290
0,180 180,270 270,450 450,540 540,1050
need to get the lock

935
00:31:46,620 --> 00:31:48,360
0,780 780,1350
of x,|
|

936
00:31:48,450 --> 00:31:50,130
0,780 780,900 900,1140 1140,1440 1440,1680
and you know it can't
它不能获得 x 的锁，

937
00:31:50,130 --> 00:31:51,120
0,240 240,360 360,570 570,660 660,990
get the lock of x,|
|

938
00:31:51,120 --> 00:31:52,410
0,300 300,450 450,750 750,990 990,1290
because {T1 -} has it,|
因为 T1 持有它，|

939
00:31:52,680 --> 00:31:54,420
0,360 360,990 1020,1350 1350,1560 1560,1740
and so { -} this
所以这个也需要等待，

940
00:31:54,420 --> 00:31:56,540
0,150 150,240 240,480 480,810
has to wait too,|
|

941
00:31:57,200 --> 00:31:59,090
0,330 330,690 690,840 840,1500 1680,1890
and now we have {}
现在我们有 T1 等待 T2' ，

942
00:31:59,090 --> 00:32:01,580
0,420 420,900 900,1470 1740,2010 2010,2490
{you,know,T1} waiting {T2' - -},|
|

943
00:32:01,580 --> 00:32:03,020
0,120 120,300 300,840 840,1140 1140,1440
and {we,have} {T2' -} waiting
我们有 T2' 等待 T1 ，

944
00:32:03,020 --> 00:32:04,340
0,180 180,660 720,900 900,1230 1230,1320
{T1 -},| we basically have
|我们有一个死锁。

945
00:32:04,340 --> 00:32:05,500
0,60 60,690
a deadlock.|
|

946
00:32:06,910 --> 00:32:08,160
0,720

947
00:32:08,670 --> 00:32:09,600
0,240 240,360 360,480 480,540 540,930
Now, what is the cool
现在，事务系统最酷的部分是，

948
00:32:09,600 --> 00:32:12,060
0,480 480,690 690,1110 1110,1860 2040,2460
part about transaction systems is

949
00:32:12,060 --> 00:32:12,990
0,150 150,300 300,450 450,630 630,930
that,| we have the abort
|我们有 abort 操作，

950
00:32:12,990 --> 00:32:14,140
0,570
operation,|
|

951
00:32:14,380 --> 00:32:16,060
0,270 270,750 810,1170 1170,1260 1260,1680
and so if the transaction
所以，如果事务系统可以检测到死锁，

952
00:32:16,060 --> 00:32:18,700
0,300 300,450 450,1110 1260,1890 1890,2640
system could detect a deadlock,|
|

953
00:32:18,730 --> 00:32:19,840
0,270 270,390 390,840 840,1020 1020,1110
could use abort one of
可以使用 abort 两个事务中的一个，

954
00:32:19,840 --> 00:32:21,420
0,90 90,210 210,1080
the two transactions,|
|

955
00:32:21,420 --> 00:32:22,410
0,300 300,510 510,600 600,750 750,990
{} let the other one
让另一个继续，

956
00:32:22,410 --> 00:32:24,240
0,600 750,1080 1080,1470 1470,1650 1650,1830
proceed,| and hopefully that will
|希望它能走到最后并提交，

957
00:32:24,240 --> 00:32:25,170
0,210 210,390 390,450 450,600 600,930
actually get to the end

958
00:32:25,170 --> 00:32:27,690
0,180 180,660 1110,1740 1740,2190 2190,2520
and commit| and {} abort
|并中止另一个，

959
00:32:27,690 --> 00:32:29,160
0,60 60,240 240,690 750,960 960,1470
the other one,| and then
|然后客户端或应用程序可以决定

960
00:32:29,310 --> 00:32:31,020
0,180 180,900 900,1050 1050,1140 1140,1710
the client or the application

961
00:32:31,020 --> 00:32:32,130
0,120 120,570 570,690 690,780 780,1110
can decide| what to do
|如何处理事务中止，

962
00:32:32,130 --> 00:32:33,300
0,270 270,390 390,570 570,630 630,1170
with {abort -} of transactions,|
|

963
00:32:33,300 --> 00:32:34,530
0,120 120,270 270,600 600,990 990,1230
it can actually retry it,|
它可以重试，|

964
00:32:34,530 --> 00:32:35,250
0,150 150,300 300,390 390,510 510,720
{you,know} may be so {}
可能会稍等片刻，然后重试，

965
00:32:35,250 --> 00:32:36,030
0,330 330,360 360,540 540,690 690,780
wait a little bit and

966
00:32:36,030 --> 00:32:38,610
0,150 150,780 1230,1560 1560,2100 2100,2580
then retry,| {} {in,the} hope
|希望在这一点上，你不会陷入死锁。

967
00:32:38,610 --> 00:32:39,720
0,210 210,420 420,720 720,960 960,1110
at that point you're not

968
00:32:39,720 --> 00:32:40,650
0,120 120,210 210,420 420,810 810,930
going to run into a

969
00:32:40,650 --> 00:32:41,640
0,570
deadlock.|
|

970
00:32:42,470 --> 00:32:43,460
0,240 240,390 390,750 750,870 870,990
And so one way to
所以，考虑一下两阶段锁的一种方式是，

971
00:32:43,460 --> 00:32:44,420
0,120 120,180 180,390 390,540 540,960
think a little bit about

972
00:32:44,450 --> 00:32:45,890
0,120 120,330 330,600 600,1200 1260,1440
{} {2-phase -} locking is

973
00:32:45,890 --> 00:32:46,520
0,150 150,240 240,390 390,450 450,630
that,| it has a little
|它有一点乐观的味道，

974
00:32:46,520 --> 00:32:48,830
0,120 120,240 240,990 1290,2190 2190,2310
bit of {} optimistic you

975
00:32:48,830 --> 00:32:50,030
0,330 330,750 750,930 930,1080 1080,1200
know flavor to it,| in
|从某种意义上说，

976
00:32:50,030 --> 00:32:51,500
0,60 60,360 360,780 1110,1260 1260,1470
the sense that,| it's not
|它没有保证，

977
00:32:51,500 --> 00:32:53,180
0,750 750,870 870,1230 1230,1470 1470,1680
guaranteed,| it won't run into
|它不会遇到问题，

978
00:32:53,180 --> 00:32:54,620
0,660 690,930 930,1140 1140,1290 1290,1440
problems,| but even if it
|但即使它遇到了问题，

979
00:32:54,620 --> 00:32:56,000
0,210 210,420 420,1020 1050,1260 1260,1380
runs into problems,| {you,know} you
|你总是可以中止，然后从问题中恢复。

980
00:32:56,000 --> 00:32:57,770
0,150 150,450 450,1050 1080,1290 1290,1770
can always abort and then

981
00:32:57,800 --> 00:33:00,180
0,1140 1170,1380 1380,1530 1530,1950
recover from that problem.|
|

982
00:33:03,060 --> 00:33:04,880
0,240 240,660 660,900 900,1350
Any questions about this?|
对于这个，有什么问题吗？|

983
00:33:10,530 --> 00:33:11,130
0,150 150,270 270,330 330,540 540,600
So you say how do
所以你怎么找到死锁？

984
00:33:11,130 --> 00:33:12,600
0,480 690,990 990,1050 1050,1200 1200,1470
you, how do you find

985
00:33:12,600 --> 00:33:14,850
0,60 60,750 900,1710 1740,2130 2130,2250
the deadlock?| That's exactly I
|这正是我希望有人问这个问题。

986
00:33:14,850 --> 00:33:15,720
0,120 120,360 360,480 480,750 750,870
was hoping that somebody was

987
00:33:15,720 --> 00:33:17,820
0,240 240,330 330,720 1050,1530 1620,2100
asking that question.| So the
|所以，人们使用两种方法，

988
00:33:17,850 --> 00:33:19,530
0,840 840,1050 1050,1170 1170,1320 1320,1680
way, there's sort of two

989
00:33:19,530 --> 00:33:21,090
0,300 300,690 690,840 840,1080 1080,1560
broad approaches that people use,|
|

990
00:33:21,360 --> 00:33:26,010
0,840 900,1410 1410,2190 2220,3150 3840,4650
{} one is,| {} {yeah\,,one,is,not,solid,as,well},|
一个是，|也不是可靠的，|

991
00:33:26,010 --> 00:33:30,720
0,300 330,4200 4200,4530 4530,4680 4680,4710
one is basically on a
一个是基于超时的，

992
00:33:30,720 --> 00:33:31,890
0,390 390,810 810,990 990,1110 1110,1170
timeout basis,| like if the
|比如如果事务运行了很长时间，

993
00:33:31,890 --> 00:33:33,870
0,1200 1290,1470 1470,1770 1770,1920 1920,1980
transaction {} running for a

994
00:33:33,870 --> 00:33:35,130
0,270 270,660 660,1050 1050,1110 1110,1260
long time,| and you know
|它们似乎没有取得任何进展，

995
00:33:35,130 --> 00:33:35,910
0,270 270,450 450,570 570,630 630,780
they don't seem to make

996
00:33:35,910 --> 00:33:37,980
0,270 270,810 1050,1410 1410,1590 1590,2070
forward progress,| {} you just
|你只是中止其中一个，

997
00:33:38,010 --> 00:33:39,280
0,420 420,570 570,660 660,900
abort one of them,|
|

998
00:33:39,700 --> 00:33:41,020
0,210 210,360 360,540 540,810 810,1320
and so this {timeout,based -},|
所以这个是基于超时的，|

999
00:33:41,680 --> 00:33:43,300
0,120 120,420 420,1170 1200,1470 1470,1620
the more systematic {} sort
一种更系统的思考方式是，

1000
00:33:43,300 --> 00:33:44,290
0,90 90,330 330,420 420,720 720,990
of way of thinking about

1001
00:33:44,290 --> 00:33:46,390
0,120 120,540 540,1110 1380,1980 1980,2100
it is,| to construct an
|构造一个等待图，

1002
00:33:46,390 --> 00:33:48,760
0,240 240,510 510,1050 1230,1890 1890,2370
{wait-for -} graph,| {as,the} transaction
|随着事务系统的移动，

1003
00:33:48,760 --> 00:33:50,650
0,510 510,630 630,1380 1380,1500 1500,1890
systems you know are moving,|
|

1004
00:33:50,650 --> 00:33:53,170
0,420 450,510 540,1290 1500,2280 2340,2520
so for example if {t1
例如，如果 T1 运行，

1005
00:33:53,170 --> 00:33:54,700
0,240 240,750 780,1260 1260,1440 1440,1530
-} runs,| so a in
|所以在等待图中，

1006
00:33:54,700 --> 00:33:55,720
0,90 90,270 270,450 450,840 840,1020
the {wait-for -} graph,| the
|事务是节点，

1007
00:33:55,720 --> 00:33:57,250
0,480 480,570 570,1170 1200,1410 1410,1530
transactions are nodes,| so we
|所以我们有一个节点 T1 ，

1008
00:33:57,250 --> 00:33:59,350
0,240 240,300 300,720 720,1350 1680,2100
got a node T1| and
|我们创建一个节点 T2 ，

1009
00:33:59,350 --> 00:34:00,490
0,180 180,390 390,510 510,930 930,1140
we make a {node,T2 -},|
|

1010
00:34:00,490 --> 00:34:01,630
0,240 240,330 330,870 870,990 990,1140
when they start,| with {T2'
当它们开始时，|如果你愿意的话，使用 T2' ，

1011
00:34:01,630 --> 00:34:02,710
0,180 180,510 510,600 600,720 720,1080
- -} if you will,|
|

1012
00:34:03,190 --> 00:34:04,750
0,390 390,570 570,750 750,1020 1020,1560
and when {T1 -} runs
当 T1 运行 get(x) ，

1013
00:34:04,750 --> 00:34:05,950
0,90 90,360 360,570 570,900 900,1200
you know gets x, []

1014
00:34:05,950 --> 00:34:07,690
0,600 630,1320 1320,1560 1560,1680 1680,1740
[],| then gets to the
|然后获取 y 的锁，

1015
00:34:07,690 --> 00:34:08,800
0,210 210,300 300,630 630,840 840,1110
lock of y,| it can't
|它不能这样做，

1016
00:34:08,800 --> 00:34:10,780
0,180 180,450 720,1200 1200,1680 1710,1980
do it,| so we'll make
|所以我们画一个 T1 到 T2' 的箭头，

1017
00:34:10,780 --> 00:34:11,680
0,390
an

1018
00:34:11,980 --> 00:34:13,510
0,510 510,810 810,1170 1170,1320 1320,1530
arrow from {} {T1 -}

1019
00:34:13,510 --> 00:34:14,440
0,90 90,300 300,510 510,870 870,930
to {T2' - -}| to
|表示 T1 正在等待 T2' ，

1020
00:34:14,440 --> 00:34:15,550
0,480 480,600 600,780 780,1020 1020,1110
indicate that {T1 -} is

1021
00:34:15,550 --> 00:34:16,960
0,420 420,540 540,750 750,930 930,1410
waiting for {T2' - -},|
|

1022
00:34:17,740 --> 00:34:18,610
0,270 270,420 420,630 630,810 810,870
{then,at} some point, like you
然后在某个时候， T2 运行，

1023
00:34:18,610 --> 00:34:19,900
0,90 90,540 540,990 990,1080 1080,1290
know T2 running,| you know
|T2 到达这个点， T2' 到达这个点，

1024
00:34:19,900 --> 00:34:21,970
0,450 450,660 660,1230 1260,1770 1770,2070
{T2 -} {} hits this,

1025
00:34:21,970 --> 00:34:23,560
0,270 270,720 720,930 930,1110 1110,1590
{T2' -} hits this point,|
|

1026
00:34:23,680 --> 00:34:24,700
0,360 360,450 450,630 630,720 720,1020
where it want to lock
它想要获得 x 的锁，它做不到。

1027
00:34:24,700 --> 00:34:25,870
0,360 360,480 480,750 750,930 930,1170
x, it can't do it.|
|

1028
00:34:26,460 --> 00:34:28,020
0,450 480,870 870,1200 1200,1440 1440,1560
{} So we'll look at,|
所以我们来看看，|

1029
00:34:28,020 --> 00:34:29,730
0,510 510,870 870,1020 1020,1320 1320,1710
what's waiting for, who's holding
有什么在等着，谁持有锁，

1030
00:34:29,730 --> 00:34:30,690
0,90 90,420 420,630 630,780 780,960
the lock,| well, it's {t1
|嗯，是 T1 ，

1031
00:34:30,690 --> 00:34:32,190
0,510 750,990 990,1140 1140,1320 1320,1500
-},| so we'll put an
|所以我们在等待图中放一条边，

1032
00:34:32,190 --> 00:34:34,020
0,900 1260,1410 1410,1530 1530,1740 1740,1830
edge you know in the

1033
00:34:34,020 --> 00:34:35,190
0,210 210,420 420,810 810,960 960,1170
{wait-for -} graph| from {T2
|从 T2' 到 T1 ，

1034
00:34:35,190 --> 00:34:37,530
0,330 330,900 900,1590 1650,2040 2040,2340
-} to {} {T2',to -}

1035
00:34:37,530 --> 00:34:39,300
0,210 210,750 1050,1470 1470,1680 1680,1770
{T1 -},| and now we
|现在我们看到这是一个环，

1036
00:34:39,300 --> 00:34:41,060
0,330 330,690 690,750 750,1260
see there's a cycle,|
|

1037
00:34:41,660 --> 00:34:43,310
0,150 150,810 810,1020 1020,1080 1080,1650
and whenever there's a cycle,|
当这里出现环时，|

1038
00:34:43,310 --> 00:34:44,510
0,180 180,390 390,600 600,630 630,1200
that means there's a deadlock,|
意味着出现了死锁，|

1039
00:34:44,840 --> 00:34:45,860
0,420 420,630 630,690 690,930 930,1020
because one is waiting on
因为一个在等待另一个，

1040
00:34:45,860 --> 00:34:47,150
0,60 60,630 690,1050 1050,1110 1110,1290
the other,| and the other
|而另一个则在等待第一个。

1041
00:34:47,150 --> 00:34:48,350
0,90 90,330 330,450 450,570 570,1200
is waiting on the first.|
|

1042
00:34:49,040 --> 00:34:51,080
0,360 360,930 1020,1470 1470,1650 1650,2040
And so, {} the transaction
所以，事务系统可以动态构建这些图，

1043
00:34:51,080 --> 00:34:52,910
0,330 330,480 480,1170 1170,1350 1350,1830
system can construct these graphs

1044
00:34:52,910 --> 00:34:55,190
0,240 240,330 330,960 1050,1740 1740,2280
on the fly,| {} detect
|检测图中何时出现环，

1045
00:34:55,190 --> 00:34:56,570
0,270 270,540 540,930 930,1290 1290,1380
when there's a cycle in

1046
00:34:56,570 --> 00:34:58,010
0,60 60,600 660,1020 1020,1140 1140,1440
the graph,| {and,then} for example
|然后，例如中止 T1 或 T2' 。

1047
00:34:58,010 --> 00:34:59,630
0,210 210,720 750,900 900,1350 1350,1620
either abort {T1 -} {or,abort}

1048
00:34:59,630 --> 00:35:01,120
0,600 600,990
{T2' -}.|
|

1049
00:35:02,650 --> 00:35:03,970
0,180 180,360 360,540 540,660 660,1320
{} It's call the {wait-for
它称为等待图。

1050
00:35:06,020 --> 00:35:07,640
0,360 360,1110
-} graph.|
|

1051
00:35:13,170 --> 00:35:14,610
0,210 210,570 570,870 870,990 990,1440
What happens after the abort?|
中止后会发生什么？|

1052
00:35:16,080 --> 00:35:18,780
0,990 1020,1590 1620,2220 2250,2490 2490,2700
{} Well, {} so let's
好吧，假设我们已经中止了 T2 ，

1053
00:35:18,780 --> 00:35:20,740
0,240 240,420 420,510 510,1350
say we have {abort,T2},|
|

1054
00:35:20,770 --> 00:35:22,510
0,240 240,510 510,900 900,1020 1020,1740
just for as an experiment,|
只是作为一个实验，|

1055
00:35:23,300 --> 00:35:24,500
0,450 480,660 660,840 840,1050 1050,1200
so we're gonna kill this
所以我们要杀死这个，

1056
00:35:24,500 --> 00:35:26,420
0,510 540,900 900,1290 1320,1650 1650,1920
guy,| {} so {T2 -}
|所以 T2 ，事务系统将安排，

1057
00:35:26,420 --> 00:35:29,120
0,900 1590,1950 1950,2370 2370,2640 2640,2700
basically the transaction system is

1058
00:35:29,120 --> 00:35:29,930
0,120 120,180 180,540 540,660 660,810
going to arrange,| so we'll
|我们一会儿就会看到，

1059
00:35:29,930 --> 00:35:31,250
0,180 180,240 240,300 300,690 1170,1320
see in a second,| it's
|它将安排 T2 没有结果

1060
00:35:31,250 --> 00:35:32,270
0,120 120,180 180,570 570,690 690,1020
going to arrange that basically

1061
00:35:32,270 --> 00:35:34,850
0,570 570,1020 1020,1140 1140,1500 1500,2580
none results of T2| or
|或者 T2 的结果是可见的，

1062
00:35:34,850 --> 00:35:36,770
0,120 120,780 1110,1590 1590,1740 1740,1920
t2 {is,visible},| {} at that
|在这一点上，锁被释放，

1063
00:35:36,770 --> 00:35:38,720
0,600 810,930 930,1170 1170,1290 1290,1950
point, the lock is released,|
|

1064
00:35:39,080 --> 00:35:40,940
0,390 390,900 900,1350 1350,1770 1770,1860
the abort will force the
abort 将强制释放 y 的锁，

1065
00:35:40,940 --> 00:35:43,010
0,300 300,360 360,750 750,1230 1470,2070
lock {} release of the

1066
00:35:43,040 --> 00:35:44,600
0,570 570,870 870,1050 1050,1230 1230,1560
y,| because {t2 - -}
|因为 T2' 退出，

1067
00:35:44,600 --> 00:35:45,860
0,90 90,450 450,840
is backing out,|
|

1068
00:35:45,860 --> 00:35:47,090
0,210 210,480 480,780 780,1080 1080,1230
{} that means that {you,know}
这意味着 T1 可以获得 y 的锁并继续完成，

1069
00:35:47,090 --> 00:35:48,230
0,510 510,600 600,810 810,870 870,1140
T1 can get the lock

1070
00:35:48,230 --> 00:35:49,580
0,120 120,690 780,960 960,1260 1260,1350
on y and proceed to

1071
00:35:49,580 --> 00:35:50,680
0,570
finish,|
|

1072
00:35:50,740 --> 00:35:53,110
0,420 420,870 1080,1560 1560,2190 2190,2370
{} the client {that,called} {T2'
调用 T2' 的客户端将会知道，

1073
00:35:53,110 --> 00:35:54,340
0,480 480,630 630,750 750,810 810,1230
-} is going to learn,|
|

1074
00:35:54,340 --> 00:35:56,260
0,180 180,270 270,780 780,1170 1470,1920
that the transaction {abort,it},| and
事务中止了它，|一般情况，你可以选择重新运行它。

1075
00:35:56,260 --> 00:35:57,100
0,90 90,420 420,510 510,630 630,840
for general you can just

1076
00:35:57,100 --> 00:35:58,360
0,270 270,390 390,810 810,900 900,1260
choose to rerun it again.|
|

1077
00:36:04,570 --> 00:36:05,940
0,180 180,240 240,450 450,840
Does it makes sense?|
这能理解吗？|

1078
00:36:10,910 --> 00:36:12,350
0,540 810,990 990,1140 1140,1230 1230,1440
Okay, so this is sort
好的，这是第一部分，

1079
00:36:12,350 --> 00:36:14,690
0,90 90,660 720,1230 1230,1800 1830,2340
of the first part, {}|
|

1080
00:36:14,690 --> 00:36:15,920
0,90 120,450 450,630 630,1080 1080,1230
and you know actually what
我想说的关于两阶段锁，

1081
00:36:15,920 --> 00:36:16,610
0,30 30,270 270,330 330,480 480,690
I wanted to say about

1082
00:36:16,610 --> 00:36:18,800
0,90 90,330 330,870 960,1620 1620,2190
{2-phase -} locking,| {} except
|另外我想再说一遍家庭作业，

1083
00:36:18,830 --> 00:36:20,120
0,210 210,450 450,570 570,900 900,1290
I wanted to address the

1084
00:36:20,120 --> 00:36:21,530
0,150 150,210 210,600 600,1020 1020,1410
sort of homework assignment again,|
|

1085
00:36:21,680 --> 00:36:23,060
0,270 270,480 480,870 900,1080 1080,1380
which is like in what
在什么情况下，

1086
00:36:23,060 --> 00:36:25,130
0,750 750,1080 1080,1290 1290,1530 1530,2070
situations,| does {2-phase -} locking
|两阶段锁比严格锁允许更多的并发性，

1087
00:36:25,130 --> 00:36:27,050
0,450 450,570 570,960 960,1620 1620,1920
allow for more concurrency than

1088
00:36:27,050 --> 00:36:28,760
0,330 330,660 690,1050 1050,1320 1320,1710
strict locking,| where strict locking
|严格锁是一种协议，

1089
00:36:28,760 --> 00:36:31,060
0,210 210,540 600,1290 1290,1920
was the protocol,| where
|事务事先获得全部锁，

1090
00:36:31,180 --> 00:36:33,280
0,210 210,900 1140,1740 1740,1980 1980,2100
the transaction acquires all the

1091
00:36:33,280 --> 00:36:34,860
0,300 300,390 390,1080
locks in advance,|
|

1092
00:36:34,950 --> 00:36:36,660
0,180 180,360 360,1080 1080,1320 1320,1710
and this requires that the
这就要求程序员，

1093
00:36:36,690 --> 00:36:38,220
0,750 750,960 960,1140 1140,1230 1230,1530
programmer| or like the beginning
|或者事务的开始声明

1094
00:36:38,220 --> 00:36:39,570
0,90 90,150 150,570 570,810 810,1350
of the transaction basically declares|
|

1095
00:36:39,570 --> 00:36:41,280
0,210 210,870 870,990 990,1470 1470,1710
which locks the transaction actually
事务需要哪些锁，

1096
00:36:41,280 --> 00:36:43,680
0,480 1020,1260 1260,1320 1320,1710 1710,2400
needs,| sort of slightly indesirable,
|稍微有点不可取，对程序员不太友好，

1097
00:36:43,680 --> 00:36:45,690
0,240 240,690 690,1260 1530,1920 1920,2010
less programmer friendly,| but it
|但它有一个优势，

1098
00:36:45,690 --> 00:36:46,980
0,240 240,510 510,960 960,1170 1170,1290
has the advantage,| that you
|那就是你不需要，

1099
00:36:46,980 --> 00:36:48,360
0,90 90,240 240,420 420,960 960,1380
know you don't actually, {}|
|

1100
00:36:48,390 --> 00:36:49,950
0,390 390,600 600,840 840,1170 1170,1560
you can run into these,|
你可以执行，|

1101
00:36:49,950 --> 00:36:51,060
0,660

1102
00:36:51,340 --> 00:36:53,740
0,690 810,1200 1200,1380 1380,1800 1800,2400
{} {you,don't} {have,to} abort transaction
你不必在结束时中止事务，

1103
00:36:53,740 --> 00:36:55,150
0,180 180,300 300,660 840,1170 1170,1410
at the end,| in case
|以防你陷入死锁。

1104
00:36:55,150 --> 00:36:56,320
0,120 120,300 300,510 510,570 570,1170
you run into a deadlock.|
|

1105
00:36:57,060 --> 00:36:59,430
0,570 690,1080 1080,1440 1440,1920 1920,2370
{} So 2-phase locking allow
所以，两阶段锁原则上允许更多的并发性，

1106
00:36:59,430 --> 00:37:01,350
0,510 540,780 780,1380 1380,1500 1500,1920
for more concurrency in principle,|
|

1107
00:37:01,350 --> 00:37:02,220
0,180 180,390 390,570 570,690 690,870
or should allow for more
或者应该允许更多的并发性

1108
00:37:02,220 --> 00:37:05,220
0,690 900,1560 1650,2490 2490,2700 2700,3000
concurrency| {} than the strict
|比严格锁或简单锁方案。

1109
00:37:05,220 --> 00:37:06,810
0,300 300,480 480,780 780,1050 1050,1590
locking or simple locking scheme.|
|

1110
00:37:06,840 --> 00:37:08,310
0,420 720,1080 1080,1200 1200,1320 1320,1470
And so I would like
我想做的是一个快的分组会议室，

1111
00:37:08,310 --> 00:37:09,420
0,90 90,300 300,480 480,870 900,1110
to do is a quick

1112
00:37:09,420 --> 00:37:11,370
0,390 390,810 810,1590 1620,1740 1740,1950
breakout room| for a couple
|过几分钟，比如五分钟，

1113
00:37:11,370 --> 00:37:12,690
0,300 300,450 450,660 660,900 900,1320
minutes like five minutes again,|
|

1114
00:37:12,960 --> 00:37:14,700
0,720 720,1140 1140,1350 1350,1470 1470,1740
and {} you know convince
说服自己或构思案例，

1115
00:37:14,700 --> 00:37:17,910
0,660 900,1260 1260,1770 1770,2460 2490,3210
yourself or constructing case,| where
|其中简单锁不允许某些并发性，

1116
00:37:17,910 --> 00:37:20,280
0,360 360,780 780,1170 1380,2220 2220,2370
simple locking which disallows some

1117
00:37:20,280 --> 00:37:22,800
0,840 900,1740 1770,2070 2070,2250 2250,2520
concurrency,| that {} {2-phase -}
|而两阶段锁可以使用。

1118
00:37:22,800 --> 00:37:23,880
0,360 360,480 480,780 780,990 990,1080
locking is actually able to

1119
00:37:23,880 --> 00:37:24,800
0,570
exploit.|
|

1120
00:37:26,730 --> 00:37:28,830
0,420 630,750 750,1350 1380,1830 1830,2100
Cool, all right, let's do
太棒了，好的，我们来进入分组会议室。

1121
00:37:28,830 --> 00:37:30,820
0,450 450,1110
breakout rooms.|
|

1122
00:37:34,410 --> 00:37:35,850
0,510 600,960 960,1170 1170,1290 1290,1440
Okay, {} see you {in,five}
好的，五分钟后见。

1123
00:37:35,850 --> 00:37:36,920
0,480
minutes.|
|

1124
00:44:07,130 --> 00:44:08,780
0,300 300,540 540,720 720,1020
We can't hear you.|
我们听不到你说话。|

1125
00:44:17,730 --> 00:44:19,620
0,180 180,450 450,660 660,1350
I think you're muted.|
我想你静音了。|

1126
00:44:36,180 --> 00:44:37,800
0,390 390,450 450,930 930,1440 1440,1620
{I,have} a question about one
我有一个问题，关于你之前提到的一张幻灯片。

1127
00:44:37,800 --> 00:44:39,750
0,150 150,300 300,840 840,1740 1770,1950
of the previous slides that

1128
00:44:39,750 --> 00:44:41,550
0,150 150,570 570,960 990,1530 1530,1800
you're talking about.| {Hold,on}, let
|稍等，我再检查一下现在大家是否都能听到我说话。

1129
00:44:41,550 --> 00:44:42,690
0,60 60,300 300,660 690,840 840,1140
me double check if everybody

1130
00:44:42,690 --> 00:44:44,180
0,90 90,240 240,330 330,720
can hear me now.|
|

1131
00:44:44,330 --> 00:44:47,420
0,540 780,1470 1560,2010 2040,2550
Yes.| Okay, good, {}
是的。|好的，很好，继续。

1132
00:44:48,550 --> 00:44:49,660
0,180 180,510
go ahead.|
|

1133
00:44:50,620 --> 00:44:51,340
0,210 210,360 360,510 510,570 570,720
{} On one of your
关于你之前的或者我想这是一个一般性的问题，

1134
00:44:51,340 --> 00:44:52,600
0,630 660,840 840,960 960,1140 1140,1260
previous or I guess this

1135
00:44:52,600 --> 00:44:54,040
0,90 90,270 270,330 330,630 630,1440
is just a general question,|
|

1136
00:44:54,040 --> 00:44:55,420
0,210 210,390 390,660 660,960 960,1380
but is the lock point
但是（释放）锁的点是否总是与提交点相同，

1137
00:44:55,420 --> 00:44:56,320
0,300 300,390 390,630 630,780 780,900
always the same as the

1138
00:44:56,320 --> 00:44:57,730
0,330 330,780 1050,1230 1230,1320 1320,1410
commit point,| or is it
|或者，是否可以在提交点之前开始放弃锁。

1139
00:44:57,730 --> 00:45:00,370
0,480 480,570 570,1290 1320,2190 2190,2640
possible to start relinquishing locks

1140
00:45:00,370 --> 00:45:01,840
0,300 300,420 420,720 720,1110 1170,1470
before your commit point.| Okay,
|好的，这是一个非常好的问题，

1141
00:45:01,840 --> 00:45:04,390
0,1260 1260,1740 1740,1920 1920,2040 2040,2550
{this,is} a very good question,|
|

1142
00:45:04,420 --> 00:45:07,180
0,360 360,690 750,1740 1770,2400 2490,2760
{} so depends,| {} so
视情况而定，|所以如果你只执行独占锁，

1143
00:45:07,180 --> 00:45:08,770
0,150 150,330 330,840 840,1020 1020,1590
if you only do exclusive

1144
00:45:08,770 --> 00:45:11,080
0,510 510,1620 1740,1980 1980,2160 2160,2310
locking,| {} as we've done
|像我们到目前为止所做的，

1145
00:45:11,080 --> 00:45:11,890
0,180 180,450 450,540 540,720 720,810
so far,| at least in
|至少在我的例子中，

1146
00:45:11,890 --> 00:45:13,330
0,120 120,750 750,960 960,1200 1200,1440
my examples,| then commit point
|提交点一样，

1147
00:45:13,330 --> 00:45:14,940
0,90 90,450 450,630 630,1170
is similar to the,|
|

1148
00:45:15,060 --> 00:45:16,350
0,390 420,750 750,960 960,1020 1020,1290
the lock point is similar
（释放）锁的点与提交点和中止点一样，

1149
00:45:16,350 --> 00:45:17,130
0,60 60,150 150,600 600,690 690,780
to the {commit,point} and the

1150
00:45:17,130 --> 00:45:18,780
0,300 300,690 780,1350 1350,1470 1470,1650
abort point,| if you have
|如果你使用读写锁，

1151
00:45:18,780 --> 00:45:20,520
0,240 240,480 480,1050 1200,1410 1410,1740
read write locking,| the locks
|锁允许读锁和写锁，

1152
00:45:20,520 --> 00:45:23,340
0,180 180,1410 1740,2370 2370,2640 2640,2820
that allow {} both read

1153
00:45:23,340 --> 00:45:25,650
0,330 330,510 510,720 720,1230 1530,2310
locks and write locks,| then,
|然后，可以在有一些限制的情况下更早地释放读锁。

1154
00:45:25,650 --> 00:45:27,240
0,0 0,420 420,870 870,1020 1020,1590
{} it's possible to release

1155
00:45:27,240 --> 00:45:29,490
0,540 540,750 750,1050 1050,1770 1800,2250
{} read locks earlier with

1156
00:45:29,490 --> 00:45:30,900
0,210 210,990
some restrictions.|
|

1157
00:45:32,540 --> 00:45:33,820
0,690
Okay.|
好的。|

1158
00:45:34,780 --> 00:45:36,920
0,690 720,1470
Okay, {}
好的，有人能给我举个例子吗，

1159
00:45:36,950 --> 00:45:38,990
0,390 390,390 1290,1620 1620,1920 1920,2040
so {} can somebody give

1160
00:45:38,990 --> 00:45:40,340
0,90 90,270 270,720 720,780 780,1350
me one example| of where
|两阶段锁允许比简单锁有更多的并发，

1161
00:45:40,460 --> 00:45:42,710
0,210 210,480 480,840 840,1410 1440,2250
{2-phase -} locking is allowing

1162
00:45:42,710 --> 00:45:43,910
0,150 150,330 330,810 810,960 960,1200
for more concurrency than simple

1163
00:45:43,910 --> 00:45:44,900
0,450
locking,|
|

1164
00:45:45,380 --> 00:45:46,460
0,240 240,480 510,690 690,930 930,1080
just to make sure we're
只是为了确保我们想法一致。

1165
00:45:46,460 --> 00:45:47,540
0,180 180,300 300,390 390,570 570,1080
all on the same page.|
|

1166
00:45:52,360 --> 00:45:54,670
0,150 150,780 780,1440 1440,2040 2040,2310
The audit function example,| like
比如审计功能，|一旦你读到这个人的金额就可以释放锁，

1167
00:45:54,670 --> 00:45:56,020
0,150 150,420 420,810 810,960 960,1350
you can release the lock

1168
00:45:56,020 --> 00:45:58,120
0,150 150,450 450,990 1260,1590 1590,2100
as soon as you read

1169
00:45:58,510 --> 00:46:00,120
0,330 330,1140
this person's

1170
00:46:00,150 --> 00:46:01,380
0,720 750,930 930,1020 1020,1140 1140,1230
amount,| like you don't have
|你不必读到每个人的。

1171
00:46:01,380 --> 00:46:02,340
0,120 120,300 300,630 630,780 780,960
to wait until you read

1172
00:46:02,340 --> 00:46:03,640
0,300 300,780
{everyone's -}.|
|

1173
00:46:04,120 --> 00:46:05,140
0,330 330,510 510,600 600,660 660,1020
{} This is an example
这是利用读锁的一个例子，

1174
00:46:05,140 --> 00:46:06,610
0,60 60,450 450,570 570,780 780,1470
of exploiting the read {}

1175
00:46:06,640 --> 00:46:07,600
0,240 240,570 570,660 660,750 750,960
read locks,| if you have
|如果你有读锁。

1176
00:46:07,600 --> 00:46:08,720
0,150 150,600
read locks.|
|

1177
00:46:15,060 --> 00:46:17,620
0,360 360,540 540,1020
Any other examples?|
还有其他例子吗？|

1178
00:46:19,930 --> 00:46:21,280
0,180 180,300 300,420 420,630 630,1350
If you have a transaction,|
如果你有一个事务，|

1179
00:46:21,280 --> 00:46:23,530
0,630 720,1080 1080,1380 1380,1980 1980,2250
where there's a condition that
其中有一个条件很少是 true ，

1180
00:46:23,530 --> 00:46:26,320
0,300 300,780 780,1800 2190,2370 2370,2790
only rarely like is true,|
|

1181
00:46:26,320 --> 00:46:27,490
0,300 330,570 570,780 780,960 960,1170
and you read a piece
当它是 true 时，你读取一块数据，

1182
00:46:27,490 --> 00:46:28,510
0,120 120,390 390,540 540,690 690,1020
of data when it's true,|
|

1183
00:46:28,510 --> 00:46:29,500
0,510
so,
所以，在开始时，你不需要获取锁，

1184
00:46:29,500 --> 00:46:30,160
0,120 120,180 180,480 480,570 570,660
at the beginning, you don't

1185
00:46:30,160 --> 00:46:31,090
0,180 180,270 270,570 570,660 660,930
need to acquire the lock

1186
00:46:31,090 --> 00:46:32,170
0,120 120,660 660,900 900,1020 1020,1080
for that,| only when you
|只有当你真的需要读取它时。

1187
00:46:32,170 --> 00:46:34,150
0,300 300,630 660,1170 1470,1770 1800,1980
actually need {to,read,it}.| Yeah, that's
|是的，这是一个很好的例子，

1188
00:46:34,150 --> 00:46:35,560
0,60 60,240 240,630 630,930 930,1410
a great example,| I personally
|我个人非常喜欢这个例子，

1189
00:46:35,560 --> 00:46:36,460
0,150 150,270 270,540 540,570 570,900
like that example a lot,|
|

1190
00:46:36,490 --> 00:46:37,840
0,240 240,300 300,450 450,720
that's a great one.|
这是一个很好的例子。|

1191
00:46:38,960 --> 00:46:40,700
0,540 600,1050 1110,1350 1350,1470 1470,1740
Good, okay, good,| so let's
好的，好的，|让我们继续这节课的第二个主题，

1192
00:46:40,730 --> 00:46:42,110
0,510 510,690 690,1050 1050,1230 1230,1380
move on basically down to

1193
00:46:42,110 --> 00:46:44,150
0,240 240,600 600,1110 1200,1860 1860,2040
the second topic of this

1194
00:46:44,150 --> 00:46:45,380
0,270 270,450 450,690 690,1020 1020,1230
lecture,| which is {} {2-phase
|也就是两阶段提交，

1195
00:46:45,380 --> 00:46:46,440
0,210 210,510
-} commit,|
|

1196
00:46:49,420 --> 00:46:50,560
0,270 270,360 360,690 690,960 960,1140
this is really dealing with
这是关于处理崩溃，

1197
00:46:50,560 --> 00:46:52,100
0,630
crashes,|
|

1198
00:46:53,670 --> 00:46:55,440
0,480 480,720 720,810 810,1320 1560,1770
switch back to blue and
换回蓝色，在白板上。

1199
00:46:55,440 --> 00:46:57,660
0,90 90,210 210,750
on the white.|
|

1200
00:47:01,910 --> 00:47:02,840
0,210 210,420 420,510 510,570 570,930
We can't see the slides
我们还看不到幻灯片。

1201
00:47:02,840 --> 00:47:06,660
0,1800 2280,3180
{either,yet}.| Oh,
|哦，让我来解决这个问题，

1202
00:47:07,280 --> 00:47:09,860
0,180 180,750 780,1080 1080,1470 1980,2580
let me fix that, {}|
|

1203
00:47:10,970 --> 00:47:13,160
0,390 390,720 720,1110 1110,1620
and {hold -} on,|
稍等，|

1204
00:47:15,030 --> 00:47:17,680
0,1020 1020,1320 1320,2130
share screen, {step,to}
共享屏幕，开始共享，

1205
00:47:19,440 --> 00:47:20,780
0,750
share,|
|

1206
00:47:21,390 --> 00:47:23,180
0,390 510,1230
how {about,now}?|
现在怎么样？|

1207
00:47:23,180 --> 00:47:26,660
0,510 840,1620 1800,2370 2370,2730
Okay.| Good, thank you.|
好了。|好的，谢谢。|

1208
00:47:26,800 --> 00:47:28,090
0,420 420,540 540,660 660,840 840,1290
Alright, so {2-phase -} commit
好的，所以两阶段提交或通常称为 2PC ，

1209
00:47:32,500 --> 00:47:35,470
0,390 420,600 600,1320 2250,2550 2550,2970
or {2PC -} that's popular

1210
00:47:35,470 --> 00:47:37,060
0,510 750,1230 1230,1380 1380,1500 1500,1590
called,| again this is a
|同样，这是一个非常著名的流行的协议，

1211
00:47:37,060 --> 00:47:41,590
0,660 690,1320 1770,2670 2670,3390 3420,4530
very {} well-known popular protocol,|
|

1212
00:47:41,890 --> 00:47:43,510
0,780 900,1170 1170,1230 1230,1440 1440,1620
I'm going to talk about
我将讨论它，

1213
00:47:43,510 --> 00:47:44,830
0,180 180,630 630,810 810,870 870,1320
that,| base sort of simple
|协议的简单明了或最常见的版本，

1214
00:47:44,830 --> 00:47:47,020
0,900 900,1440 1500,1680 1680,1890 1890,2190
straightforward or the most common

1215
00:47:47,020 --> 00:47:49,060
0,360 360,450 450,540 540,1200 1470,2040
version of the protocol, {}|
|

1216
00:47:49,090 --> 00:47:51,070
0,420 420,690 690,930 930,1050 1050,1980
they're all kinds of variations
它们是它的各种变体，

1217
00:47:51,070 --> 00:47:52,570
0,150 150,360 570,1140 1140,1290 1290,1500
of it,| but you know
|但它们也有相同的基本想法。

1218
00:47:52,570 --> 00:47:53,890
0,360 360,600 600,960 960,1230 1230,1320
in they also have the

1219
00:47:53,890 --> 00:47:56,060
0,780 990,1740
same {}

1220
00:47:56,090 --> 00:47:58,660
0,810 810,1470 1470,2010
{} underlying idea.|
|

1221
00:47:58,840 --> 00:48:01,330
0,240 240,360 360,780 990,1530 1740,2490
And so again, {} typically
同样地，通常在两阶段协议中，

1222
00:48:01,330 --> 00:48:03,220
0,540 540,1200 1200,1590 1590,1740 1740,1890
{in,2-phase} protocol,| and I'm going
|我将在转账事务的背景下这样做，

1223
00:48:03,220 --> 00:48:03,880
0,210 240,420 420,510 510,600 600,660
to do it in the

1224
00:48:03,880 --> 00:48:06,550
0,510 510,660 660,900 900,1860 1890,2670
context of the transfer transaction,|
|

1225
00:48:07,000 --> 00:48:08,650
0,360 360,450 450,930 930,1080 1080,1650
so a client that actually
所以，如果客户端想进行转账，

1226
00:48:08,650 --> 00:48:09,970
0,240 240,330 330,450 450,510 510,1320
wants to do a transfer,|
|

1227
00:48:10,090 --> 00:48:13,840
0,540 540,990 990,1530 2700,3330 3330,3750
{you,know,basically} submits the transfer transaction
将转账业务提交给事务系统，

1228
00:48:13,840 --> 00:48:16,930
0,210 210,660 660,1230 1590,2790 2790,3090
to transaction system,| {} and
|而接收事务的机器称为协调器，

1229
00:48:16,930 --> 00:48:18,160
0,120 120,450 450,600 600,900 900,1230
the { -} the machine

1230
00:48:18,160 --> 00:48:20,020
0,180 180,390 600,1230 1230,1710 1710,1860
sort of receive transaction is

1231
00:48:20,020 --> 00:48:21,640
0,210 210,270 270,1050
called the coordinator,|
|

1232
00:48:23,490 --> 00:48:25,220
0,660
and
那个机器负责通过事务系统运行事务，

1233
00:48:25,560 --> 00:48:27,510
0,360 360,900 900,990 990,1200 1200,1950
that machine is in charge

1234
00:48:27,540 --> 00:48:29,910
0,450 480,1050 1050,1140 1140,1680 1680,2370
of running the transaction through

1235
00:48:29,940 --> 00:48:32,400
0,420 420,870 870,1350 1920,2130 2130,2460
the transaction system,| and so
|在我们的情况下，协调器将与两台不同的机器交互，

1236
00:48:32,400 --> 00:48:33,870
0,480 480,630 630,1050 1050,1170 1170,1470
{} the coordinator will talk

1237
00:48:33,870 --> 00:48:34,980
0,210 210,390 390,720 720,900 900,1110
in our case to two

1238
00:48:34,980 --> 00:48:36,380
0,270 270,930
different machines,|
|

1239
00:48:37,100 --> 00:48:38,740
0,420 420,600 600,1080
A and B,|
A 和 B ，|

1240
00:48:38,960 --> 00:48:40,310
0,210 210,480 480,660 660,1260 1260,1350
{} where A holds you
其中 A 持有 x ， B 持有 y 。

1241
00:48:40,310 --> 00:48:42,560
0,150 150,720 720,1320 1350,1740 1740,2250
know x and B holds

1242
00:48:42,560 --> 00:48:44,000
0,600
y.|
|

1243
00:48:45,150 --> 00:48:47,360
0,960 990,1620
And {}
而且通常的一种方式是，

1244
00:48:47,860 --> 00:48:49,100
0,690
{}

1245
00:48:49,280 --> 00:48:51,110
0,360 360,1020 1020,1260 1260,1560 1560,1830
and basically you know one

1246
00:48:51,110 --> 00:48:52,640
0,420 420,630 630,810 810,1170 1170,1530
way that this typically goes

1247
00:48:52,640 --> 00:48:53,660
0,120 120,270 270,360 360,810 810,1020
is that,| the coordinator for
|协调者执行整个事务，

1248
00:48:53,660 --> 00:48:54,560
0,90 90,270 270,450 480,810 810,900
a sort of does the

1249
00:48:54,560 --> 00:48:55,760
0,210 210,780 780,930 930,1080 1080,1200
whole transaction,| but in a
|但以试探性的方式，

1250
00:48:55,760 --> 00:48:58,700
0,660 690,1380 1440,1620 1620,1980 2340,2940
tentative way,| {} so, {}
|所以， put x 导致一个给 A 的消息，

1251
00:48:58,700 --> 00:49:00,300
0,210 210,480 480,1170
the put x

1252
00:49:00,660 --> 00:49:01,350
0,90 90,240 240,570 570,630 630,690
you know results in a

1253
00:49:01,350 --> 00:49:03,090
0,330 330,510 510,1050 1080,1290 1290,1740
message to A,| {you,know} locking
|锁定 A ， 修改 A ，

1254
00:49:03,090 --> 00:49:04,200
0,540
A,

1255
00:49:04,380 --> 00:49:06,690
0,480 480,1230 1230,1830 1920,2130 2130,2310
{} modifying A,| you know
|put x ，

1256
00:49:06,690 --> 00:49:10,020
0,870 1290,2070 2280,3000 3000,3090 3090,3330
put x, except,| the put
|put 在数据库中还是不可见的，

1257
00:49:10,020 --> 00:49:11,610
0,120 120,420 420,900 900,1380 1380,1590
is not actually visible yet

1258
00:49:11,610 --> 00:49:13,350
0,60 60,150 150,930 1020,1290 1290,1740
in the database,| {} what
|它所做的是放入一个日志，

1259
00:49:13,350 --> 00:49:14,880
0,450 450,720 720,1020 1020,1440 1440,1530
what's done is putting a

1260
00:49:14,880 --> 00:49:17,130
0,630 900,1590 1590,1890 1890,2130 2130,2250
log,| very much like in
|很像在 Frangipani 中的方式，

1261
00:49:17,130 --> 00:49:18,150
0,210 210,330 330,720 720,810 810,1020
sort of {} in the

1262
00:49:18,150 --> 00:49:19,530
0,330 330,480 480,630 630,1020 1020,1380
{Frangipani - -} style,| where
|我们必须预先写入日志，

1263
00:49:19,530 --> 00:49:20,220
0,120 120,210 210,300 300,510 510,690
we have to write ahead

1264
00:49:20,220 --> 00:49:21,870
0,450 720,960 960,1080 1080,1530 1530,1650
log,| all the operations,| that
|所有操作，|在某个时刻，数据库自己[具体化]，

1265
00:49:21,870 --> 00:49:22,710
0,120 120,210 210,390 390,690 690,840
we at some point, one

1266
00:49:22,710 --> 00:49:23,730
0,60 60,510 510,810 810,960 960,1020
of {[materialize] -} in the

1267
00:49:23,730 --> 00:49:25,440
0,450 450,1050 1080,1200 1200,1530 1530,1710
database itself,| we first put
|我们首先放入日志，

1268
00:49:25,440 --> 00:49:27,330
0,90 90,180 180,750 870,1290 1290,1890
in the log,| until later,
|在这种情况下，直到我们遇到提交，

1269
00:49:27,330 --> 00:49:28,590
0,150 150,270 270,990 990,1170 1170,1260
in the {particular,case} until we

1270
00:49:28,590 --> 00:49:30,210
0,180 180,660 750,930 930,1440 1440,1620
hit commit,| and then we
|然后我们将安装数据库中的所有东西。

1271
00:49:30,210 --> 00:49:31,500
0,210 210,360 360,810 810,1170 1170,1290
actually will install everything in

1272
00:49:31,500 --> 00:49:32,860
0,450 480,1110
the database.|
|

1273
00:49:33,280 --> 00:49:35,050
0,240 240,330 330,540 540,1020 1050,1770
So we do put, {}
所以我们执行第二个 put 到 y ，

1274
00:49:35,080 --> 00:49:37,360
0,150 150,300 300,600 600,1050 1560,2280
we do second put {you,know,to,y},|
|

1275
00:49:39,810 --> 00:49:41,400
0,540 540,690 690,1200 1200,1470 1470,1590
{} in another same thing
同样的事情也发生在那里，

1276
00:49:41,400 --> 00:49:43,170
0,330 330,720 720,810 810,1380 1500,1770
happens there,| you know we
|我们获得 y 的锁，

1277
00:49:43,170 --> 00:49:44,880
0,120 120,180 180,660 690,1140 1140,1710
got a lock on y,|
|

1278
00:49:44,910 --> 00:49:45,630
0,240 240,390 390,540 540,660 660,720
okay, so this sort of
好的，这是对 x 的锁，

1279
00:49:45,630 --> 00:49:47,080
0,210 210,480 480,570 570,960
being lock on x,|
|

1280
00:49:47,080 --> 00:49:48,250
0,390 390,510 510,600 600,720 720,1170
and we do a put
我们对 y 执行 put ，

1281
00:49:48,250 --> 00:49:50,220
0,360 360,990
on y,|
|

1282
00:49:50,800 --> 00:49:53,080
0,300 300,750 750,960 960,1530 1740,2280
and again we're gonna not
再次，我们不会真的把值放入数据库，

1283
00:49:53,080 --> 00:49:54,250
0,510 510,600 600,750 750,990 990,1170
actually you know really put

1284
00:49:54,250 --> 00:49:55,840
0,420 450,960 960,1050 1050,1140 1140,1590
the value in the database,|
|

1285
00:49:55,840 --> 00:49:57,520
0,300 300,480 480,930 1050,1440 1530,1680
we're gonna {using,log},| so we're
我们将是使用日志，|所以我们 log y ，

1286
00:49:57,520 --> 00:49:59,290
0,450 450,1110 1320,1470 1470,1710 1710,1770
log y| and here we
|这里是 log x 。

1287
00:49:59,290 --> 00:50:00,840
0,30 30,390 390,780
{} log x.|
|

1288
00:50:01,400 --> 00:50:02,640
0,660
Okay?|
好的?|

1289
00:50:03,440 --> 00:50:04,880
0,420 420,570 570,960 960,1080 1080,1440
{} And now the coordinator
现在协调者完成了两个事务，

1290
00:50:04,880 --> 00:50:06,140
0,90 90,300 300,960 990,1110 1110,1260
is done two you know

1291
00:50:06,140 --> 00:50:08,360
0,570 600,1350 1350,1530 1530,2010 2010,2220
the transactions,| that {two,of} main
|现在两个操作准备好提交，

1292
00:50:08,360 --> 00:50:10,130
0,540 540,810 810,1050 1050,1350 1350,1770
operations now so ready to

1293
00:50:10,130 --> 00:50:13,340
0,960 1170,1680 1890,2790 2790,3030 3030,3210
{} commit,| and here's where
|这就是两阶段的用处。

1294
00:50:13,340 --> 00:50:14,510
0,120 120,300 300,660 660,960 960,1170
the {2-phase -} part comes

1295
00:50:14,510 --> 00:50:15,220
0,150
in.|
|

1296
00:50:15,390 --> 00:50:18,120
0,450 450,870 990,1680 1830,2580 2580,2730
And so the coordinator will
协调器将发送一个 prepare 消息，

1297
00:50:18,120 --> 00:50:20,140
0,300 300,540 540,930 930,1560
send a prepare message,|
|

1298
00:50:20,410 --> 00:50:21,820
0,210 210,480 480,690 690,1170 1170,1410
and first gonna describe this
首先描述这个协议，

1299
00:50:21,850 --> 00:50:24,220
0,750 750,1230 1230,1440 1440,1590 1590,2370
protocol,| indicates there's no failures
|表明没有失败，一切都解决了，

1300
00:50:24,220 --> 00:50:26,140
0,390 390,750 750,1050 1050,1380
and everything works out,|
|

1301
00:50:26,140 --> 00:50:28,150
0,600 600,690 690,1020 1020,1620 1620,2010
{} you know just sort
是一些简单的案例，

1302
00:50:28,150 --> 00:50:30,670
0,60 60,1410 1410,1680 1680,2040 2040,2520
of the easy cases {as,will},|
|

1303
00:50:31,240 --> 00:50:32,950
0,360 360,570 570,780 780,1110 1110,1710
{} sends a prepare message,|
发送一个 prepare 消息，|

1304
00:50:33,490 --> 00:50:35,500
0,630 630,1020 1020,1290 1320,1650 1650,2010
{} sends a prepare message
发送 prepare 消息到，

1305
00:50:35,500 --> 00:50:36,920
0,570
to,|
|

1306
00:50:37,080 --> 00:50:40,710
0,1800 1830,2520 2520,3000 3090,3300 3300,3630
to prepare A, {you,know} prepare
prepare A ， prepare B ，

1307
00:50:40,710 --> 00:50:42,040
0,540
B,|
|

1308
00:50:45,310 --> 00:50:46,630
0,300 300,390 390,750 750,1050 1050,1320
and the prepare message of
并且 prepare 消息当然包括事务 ID ，

1309
00:50:46,630 --> 00:50:48,730
0,300 300,810 810,930 930,1560 1560,2100
course includes the transaction ID,|
|

1310
00:50:48,730 --> 00:50:50,380
0,240 240,510 510,810 810,1200 1200,1650
that {} actually used for
用于这个事务，

1311
00:50:50,410 --> 00:50:52,210
0,420 420,720 720,990 1020,1320 1320,1800
{this,transaction -},| so every transaction
|所以，每个事务都有一个事务 ID ，

1312
00:50:52,210 --> 00:50:54,640
0,210 210,330 330,780 780,1350 1920,2430
has a transaction ID,| and
|所有的消息都标记有事务 ID ，

1313
00:50:54,640 --> 00:50:55,930
0,180 180,240 240,570 570,720 720,1290
all the message are tag

1314
00:50:55,990 --> 00:50:57,280
0,330 330,420 420,840 840,1110 1110,1290
with the transaction ID,| so
|所以，我们始终知道我们谈论的是哪个事务，

1315
00:50:57,280 --> 00:50:58,450
0,120 120,240 240,720 720,960 960,1170
we always know about which

1316
00:50:58,450 --> 00:51:00,320
0,480 480,600 600,930 930,1380
transaction we're talking about,|
|

1317
00:51:00,880 --> 00:51:03,070
0,540 720,1230 1230,1560 1560,1710 1710,2190
{} when A and B
当 A 和 B 接收到 prepare 消息，

1318
00:51:03,100 --> 00:51:05,800
0,660 660,990 990,1650 2010,2610 2610,2700
receives prepare messages,| {} you
|它们查看自己的状态，

1319
00:51:05,800 --> 00:51:06,490
0,120 120,270 270,480 480,570 570,690
know they look at their

1320
00:51:06,490 --> 00:51:08,950
0,510 570,1890 1890,2010 2010,2160 2160,2460
state,| {} you know see
|看看它们是否真的可以执行事务，

1321
00:51:08,950 --> 00:51:10,420
0,150 150,450 450,990 990,1110 1110,1470
if they indeed can actually

1322
00:51:10,420 --> 00:51:11,770
0,360 360,450 450,1080 1080,1140 1140,1350
execute the transaction,| you know
|在这种情况下，它们持有 x 的锁，

1323
00:51:11,770 --> 00:51:13,510
0,180 180,510 510,600 600,990 990,1740
they're holding the lock on

1324
00:51:13,510 --> 00:51:15,220
0,210 210,270 270,390 390,900 1080,1710
x in this case,| the
|x 在日志中，

1325
00:51:15,250 --> 00:51:16,660
0,270 270,390 390,750 750,840 840,1410
x is actually the log|
|

1326
00:51:16,810 --> 00:51:17,770
0,180 180,300 300,390 390,570 570,960
and so they sent back,|
所以它们发回，|

1327
00:51:17,770 --> 00:51:19,900
0,90 90,990 1020,1230 1230,1800 1800,2130
you know saying yeah I'm
说是的，我准备好提交了，

1328
00:51:19,900 --> 00:51:21,520
0,450 450,720 720,1260
ready to commit,|
|

1329
00:51:21,990 --> 00:51:23,440
0,870
{So\,,yes},
所以，是的，是的，

1330
00:51:24,490 --> 00:51:25,840
0,840
yes,|
|

1331
00:51:27,200 --> 00:51:28,820
0,600 600,690 690,810 810,1110 1110,1620
and at this particular point,
在这一点上，关键的一步是，

1332
00:51:29,120 --> 00:51:31,280
0,600 600,1140 1140,1230 1230,1830 1830,2160
{} use the crucial step

1333
00:51:31,280 --> 00:51:33,170
0,330 570,720 720,1230 1230,1410 1410,1890
is,| the coordinator now knows
|协调者知道 A 和 B 都准备好提交，

1334
00:51:33,170 --> 00:51:34,490
0,150 150,570 570,990 990,1140 1140,1320
that basically both A and

1335
00:51:34,490 --> 00:51:37,940
0,330 330,1440 1620,2640 2640,3060 3060,3450
B are prepared to commit,|
|

1336
00:51:38,240 --> 00:51:40,040
0,240 240,600 600,1260 1260,1530 1530,1800
and so and I have
我承诺要提交，响应 y ，

1337
00:51:40,040 --> 00:51:41,780
0,390 390,930 930,1020 1020,1380 1380,1740
basically promised to commit by

1338
00:51:41,780 --> 00:51:45,320
0,510 510,840 1110,1950 1950,2700 2880,3540
actually {} responding y,| and
|在这一点上，协调者提交，

1339
00:51:45,320 --> 00:51:47,300
0,240 240,420 420,930 930,1350
at this point the

1340
00:51:48,000 --> 00:51:49,840
0,660 660,1320
coordinator commits,|
|

1341
00:51:49,930 --> 00:51:51,250
0,450 450,930 930,1020 1020,1110 1110,1320
and then you know sends
然后发送消息给 A ，

1342
00:51:51,250 --> 00:51:54,100
0,600 600,720 720,1170 1170,1710 2100,2850
messages {you,know} again to the

1343
00:51:54,670 --> 00:51:56,620
0,360 360,900
A,| {saying,commits}
|说 commit(TID) ，

1344
00:51:56,920 --> 00:51:59,260
0,360 360,480 480,1260 1290,1650 1650,2340
{you,know} the transaction {TID -},|
|

1345
00:51:59,960 --> 00:52:02,450
0,270 270,690 690,1080 1080,1650 1650,2490
{} similar message to B
同样的消息给 B ， commit(TID) ，

1346
00:52:02,450 --> 00:52:04,720
0,180 180,690 720,960 960,1620
{you,know} commit {TID -},|
|

1347
00:52:07,190 --> 00:52:08,360
0,150 150,240 240,390 390,690 690,1170
and at this particular point,|
在这一点上，|

1348
00:52:08,660 --> 00:52:10,700
0,540 540,900 900,1110 1110,1590 1590,2040
A and B actually perform
A 和 B 执行操作，

1349
00:52:10,700 --> 00:52:12,800
0,150 150,720 720,1140 1230,1710 1710,2100
the operation,| so they basically
|所以它们安装，

1350
00:52:12,800 --> 00:52:14,160
0,810
install,|
|

1351
00:52:14,160 --> 00:52:15,060
0,180 180,330 330,690 690,780 780,900
at this point, you know
在这一点上，它们安装 y 的日志，

1352
00:52:15,060 --> 00:52:17,400
0,150 150,900
they install

1353
00:52:17,820 --> 00:52:18,960
0,270 270,420 420,720 720,1050 1050,1140
{you,know} the log version of

1354
00:52:18,960 --> 00:52:24,120
0,690 1020,2070 2070,2940 3420,4440 4440,5160
y,| {here,again}, {this,transaction}, {this,participants} installs
|同样，这个安装 x ，

1355
00:52:24,120 --> 00:52:25,460
0,450
the

1356
00:52:25,610 --> 00:52:27,260
0,660 690,1140 1140,1290 1290,1560 1560,1650
x,| and then release the
|然后释放锁，

1357
00:52:27,260 --> 00:52:30,440
0,510 840,1110 1110,1650 1680,2700 2730,3180
locks,| so release y and
|所以释放 y ，这里释放 x ，

1358
00:52:30,440 --> 00:52:31,640
0,180 180,300 300,450 450,870 870,1200
{here -} the release of

1359
00:52:31,670 --> 00:52:32,740
0,540
x,|
|

1360
00:52:33,010 --> 00:52:34,420
0,390 390,510 510,900 900,1320 1320,1410
then they respond back you
然后它们回复协调者，

1361
00:52:34,420 --> 00:52:36,100
0,120 120,690
know {to,the}

1362
00:52:36,190 --> 00:52:38,740
0,240 240,1140 1230,1650 1650,1830 1830,2550
{} coordinator,| saying like yep
|表示所有都完成了，

1363
00:52:38,770 --> 00:52:40,020
0,300 300,630
all done,|
|

1364
00:52:40,600 --> 00:52:42,480
0,720
and
在这一点上，事务完全完成，

1365
00:52:43,120 --> 00:52:43,900
0,120 120,210 210,360 360,600 600,780
{} at that point, the

1366
00:52:43,900 --> 00:52:45,790
0,480 480,540 540,1080 1080,1440 1530,1890
transaction is completely done, {}|
|

1367
00:52:45,790 --> 00:52:47,530
0,180 180,750 750,1290 1290,1530 1530,1740
in fact coordinator doesn't really
事实上，协调器不需要

1368
00:52:47,530 --> 00:52:48,820
0,180 180,270 270,600 600,900 900,1290
have to| remember anything anymore
|记住有关这个事务的任何内容。

1369
00:52:48,820 --> 00:52:50,560
0,180 180,330 330,660 660,1140
about this particular transaction.|
|

1370
00:52:50,740 --> 00:52:52,420
0,630 690,1200 1200,1260 1260,1500 1500,1680
And { -} also see
而且，也可以在后面看到，

1371
00:52:52,420 --> 00:52:53,980
0,390 390,480 480,570 570,1290 1350,1560
later,| you know {A,and,B} {you,know}
|A 和 B 需要记住这个状态长一点时间，

1372
00:52:53,980 --> 00:52:54,940
0,270 270,360 360,690 690,780 780,960
need to remember that state

1373
00:52:54,940 --> 00:52:56,140
0,0 0,270 270,750 750,1050 1050,1200
a little longer| until they
|直到它们听到下一个事务。

1374
00:52:56,140 --> 00:52:57,490
0,240 240,450 450,510 510,840 840,1350
hear about the next transaction.|
|

1375
00:52:58,410 --> 00:52:59,460
0,300 300,420 420,600 600,720 720,1050
Okay, so this is a
好的，这是一个核心的基本案例，

1376
00:52:59,820 --> 00:53:02,100
0,750 1140,1680 1680,2010 2010,2130 2130,2280
core basic case,| when there's
|当绝对没有失败的时候，

1377
00:53:02,100 --> 00:53:04,950
0,420 420,600 600,1200 1530,2310 2520,2850
absolutely no failures,| and {}
|我们看到我们得到了预期结果，

1378
00:53:04,950 --> 00:53:06,300
0,390 390,720 720,960 960,1080 1080,1350
we see what we actually

1379
00:53:06,300 --> 00:53:07,980
0,210 210,360 360,810 810,1380 1380,1680
get the desired outcome, correct,|
|

1380
00:53:08,370 --> 00:53:09,390
0,150 150,210 210,750 750,930 930,1020
you know when does the
什么时候协调者提交，

1381
00:53:09,390 --> 00:53:12,630
0,600 600,1110 1350,2070 2070,2490 2490,3240
coordinator commits,| coordinator commits only
|只有在 A 和 B 同意的情况下，协调者才能提交。

1382
00:53:19,360 --> 00:53:23,650
0,300 300,810 1290,2190 2700,3810 3810,4290
if A {and,B} {} agree.|
|

1383
00:53:28,890 --> 00:53:30,090
0,570 600,930 930,1050 1050,1140 1140,1200
Okay, it could be the
好吧，有可能是这样的，

1384
00:53:30,090 --> 00:53:31,950
0,510 510,780 780,1020 1020,1410 1410,1860
case,| {that,you,know} for example when
|例如，当协调器向 B 发送消息时，

1385
00:53:32,190 --> 00:53:33,660
0,570 570,690 690,1200 1200,1410 1410,1470
{} the coordinator sends a

1386
00:53:33,660 --> 00:53:35,970
0,330 330,840 840,1620 1620,2070 2070,2310
message {to,B},| {and,B} decides, well,
|B 决定，我不能提交，

1387
00:53:35,970 --> 00:53:38,550
0,330 360,600 600,810 810,1260 1680,2580
I can't really commit, {}|
|

1388
00:53:38,580 --> 00:53:40,890
0,1140 1320,1410 1410,1620 1620,1740 1740,2310
maybe {sort,of} could be multiple
可能有多种原因造成这种情况，

1389
00:53:40,890 --> 00:53:42,810
0,360 360,630 630,780 1140,1410 1410,1920
reasons for it,| {} maybe
|也许 B 处于一种情况，

1390
00:53:42,810 --> 00:53:44,970
0,1020 1050,1470 1470,1980 1980,2070 2070,2160
the B actually is in

1391
00:53:44,970 --> 00:53:45,930
0,60 60,570 570,720 720,900 900,960
a situation,| where there's a
|y 有一个死锁，

1392
00:53:45,930 --> 00:53:48,560
0,570 600,1380 1380,1710 1710,2190
deadlock {} with y,|
|

1393
00:53:48,590 --> 00:53:50,900
0,840 870,1620 1620,1770 1770,1890 1890,2310
or {} you know there's
或者日志已经没有空间，

1394
00:53:50,900 --> 00:53:51,800
0,150 150,420 420,510 510,600 600,900
no space in the log

1395
00:53:51,800 --> 00:53:53,210
0,480 480,900 900,1080 1080,1230 1230,1410
anymore,| or there's not enough
|或者账户里没有足够的钱，

1396
00:53:53,210 --> 00:53:54,530
0,360 360,510 510,870 870,1260 1260,1320
money in the account of

1397
00:53:54,530 --> 00:53:57,140
0,480 900,1590 1740,2160 2160,2340 2340,2610
y| and, {} and so
|所以 B 可以回复不，

1398
00:53:57,140 --> 00:53:59,210
0,120 120,450 480,960 960,1170 1170,2070
you know B could respond

1399
00:53:59,240 --> 00:54:01,340
0,210 210,360 360,810 1080,1440 1440,2100
with an no,| let's say
|假设在这里，

1400
00:54:01,580 --> 00:54:03,020
0,150 150,540 750,960 960,1080 1080,1440
in this,| so the other
|另一个可能的结果是，

1401
00:54:03,020 --> 00:54:04,370
0,420 420,840 840,1050 1050,1140 1140,1350
possible outcome is| you know
|prepare 消息可以发回一个 no ，

1402
00:54:04,370 --> 00:54:05,630
0,120 120,450 450,750 750,900 900,1260
the prepare message can actually

1403
00:54:05,630 --> 00:54:07,820
0,510 510,660 660,870 870,1320 1860,2190
send a no back,| and
|在这种情况下，协调员得到A的肯定，B的否定，

1404
00:54:07,820 --> 00:54:10,850
0,120 120,330 330,1020 1170,1980 2100,3030
in that case,| the coordinator
|协调者得到一个来自 A 的 yes ，一个来自 B 的 no ，

1405
00:54:10,850 --> 00:54:11,990
0,180 180,480 480,900 900,1020 1020,1140
gets one yes you know

1406
00:54:11,990 --> 00:54:13,100
0,90 90,540 540,630 630,930 930,1110
from A, a no from

1407
00:54:13,100 --> 00:54:14,510
0,480 480,690 690,780 780,1290 1290,1410
B,| and so both do
|所以双方都不同意，

1408
00:54:14,510 --> 00:54:15,770
0,240 240,720 930,1050 1050,1110 1110,1260
not agree,| and in that
|在这种情况下，

1409
00:54:15,770 --> 00:54:17,090
0,300 300,390 390,510 510,750 750,1320
case,| you know the coordinator
|协调者不能提交事务，

1410
00:54:17,090 --> 00:54:18,410
0,390 390,630 630,720 720,1230 1230,1320
cannot commit the transaction,| and
|然后它可以中止事务，

1411
00:54:18,410 --> 00:54:19,340
0,150 150,210 210,330 330,600 600,930
then it would actually abort

1412
00:54:19,340 --> 00:54:20,280
0,60 60,570
the transaction,|
|

1413
00:54:22,600 --> 00:54:23,440
0,210 210,360 360,510 510,600 600,840
and then sends the abort
然后向 A 和 B 发送 abort 消息，

1414
00:54:23,440 --> 00:54:26,350
0,630 630,750 750,1230 1230,1800 2340,2910
messages to {A,and,B},| basically {}
|停止事务，

1415
00:54:26,440 --> 00:54:28,870
0,1110 1140,1470 1470,2010 2040,2220 2220,2430
discontinuing the transaction,| so those
|所以这是两种可能的结果，

1416
00:54:28,870 --> 00:54:30,100
0,180 180,270 270,420 420,780 780,1230
are the two possible outcomes,|
|

1417
00:54:30,100 --> 00:54:30,970
0,60 60,240 240,390 390,630 630,870
one is the commit case,
一个是提交的情况，一个是中止的情况，

1418
00:54:30,970 --> 00:54:31,960
0,150 150,210 210,300 300,540 540,990
one is the abort case,|
|

1419
00:54:32,110 --> 00:54:33,430
0,540 540,870 870,1140 1140,1230 1230,1320
{} and when it is
它总是这种情况，

1420
00:54:33,430 --> 00:54:34,450
0,270 270,330 330,660 660,930 930,1020
always the case,| that the
|事务仅提交，

1421
00:54:34,450 --> 00:54:36,400
0,420 450,870 870,1320 1560,1680 1680,1950
transaction only commits,| the top
|顶层事务仅提交，

1422
00:54:36,400 --> 00:54:38,350
0,180 180,600 600,810 810,1200 1200,1950
level transaction only commits,| both
|当参与事务的双方都同意这样做。

1423
00:54:38,350 --> 00:54:39,640
0,90 90,660 660,810 810,840 840,1290
the participants that are involved

1424
00:54:39,640 --> 00:54:41,140
0,60 60,150 150,840 930,1440 1440,1500
in the transaction agreed to

1425
00:54:41,140 --> 00:54:42,020
0,150 150,480
do so.|
|

1426
00:54:44,720 --> 00:54:46,640
0,540 660,1350 1410,1680 1680,1830 1830,1920
{} Now, that's sort of
现在，这就是协议的概述，

1427
00:54:46,640 --> 00:54:49,040
0,360 420,1170 1200,1410 1410,1800 1830,2400
the outline of the protocols,|
|

1428
00:54:49,040 --> 00:54:49,970
0,90 90,270 270,360 360,660 660,930
I want to now go
现在我想看几种情况，

1429
00:54:49,970 --> 00:54:51,110
0,270 270,330 330,540 540,600 600,1140
through a couple of cases|
|

1430
00:54:51,110 --> 00:54:53,750
0,270 270,360 360,630 630,1380 1800,2640
{you,know} {sort,of} to understand {}
理解什么会出错，

1431
00:54:53,750 --> 00:54:54,440
0,180 180,240 240,420 420,510 510,690
you know what can go

1432
00:54:54,440 --> 00:54:55,970
0,450 450,1020 1020,1200 1200,1290 1290,1530
wrong,| and how we do,
|我们如何处理，

1433
00:54:55,970 --> 00:54:57,500
0,360 360,480 480,930 960,1230 1230,1530
how we deal,| how {2-phase
|两阶段提交如何安排仍然是正确的。

1434
00:54:57,500 --> 00:54:59,930
0,450 570,1140 1380,2190 2190,2280 2280,2430
-} commit {arranges -} that

1435
00:54:59,930 --> 00:55:00,950
0,390 390,630 630,690 690,900 900,1020
actually still the right thing

1436
00:55:00,950 --> 00:55:01,880
0,630
happens.|
|

1437
00:55:01,970 --> 00:55:03,020
0,390 390,450 450,540 540,600 600,1050
Actually I have a question,
我有个问题。

1438
00:55:03,020 --> 00:55:04,730
0,510 690,1110 1110,1350 1350,1470 1470,1710
yeah.| {} So we said
|所以我们说， B 可能会决定它需要中止，

1439
00:55:04,730 --> 00:55:06,260
0,270 300,630 630,840 840,1170 1170,1530
that, like B might decide

1440
00:55:06,260 --> 00:55:07,850
0,330 570,690 690,930 930,1050 1050,1590
that it needs to abort,|
|

1441
00:55:08,480 --> 00:55:09,800
0,330 330,570 570,720 720,1110 1110,1320
sends back no message,| what
发回 no 消息，|如果它在回复 yes 之后，决定需要中止，

1442
00:55:09,800 --> 00:55:10,760
0,120 120,210 210,630 630,690 690,960
if it decides it needs

1443
00:55:10,760 --> 00:55:13,640
0,330 600,1290 1320,1860 1860,2220 2370,2880
to abort after it replied

1444
00:55:13,640 --> 00:55:15,080
0,660 750,990 990,1140 1140,1290 1290,1440
yes,| would that ever be
|这有可能吗？

1445
00:55:15,080 --> 00:55:17,600
0,660 960,1920 1920,2160 2160,2340 2340,2520
possible?| No, we'll talk about
|不，我们一会儿再谈，

1446
00:55:17,600 --> 00:55:18,680
0,150 150,210 210,510 510,810 810,1080
in a second,| but that's
|但这绝对是不可能的，

1447
00:55:18,680 --> 00:55:20,720
0,450 450,660 660,1110 1260,1620 1620,2040
absolutely not possible,| if you
|如果你承诺提交，你必须提交。

1448
00:55:20,720 --> 00:55:22,310
0,480 480,660 660,990 990,1290 1320,1590
promise to {commit -}, you

1449
00:55:22,310 --> 00:55:23,460
0,270 270,330 330,750
have to commit.|
|

1450
00:55:25,520 --> 00:55:26,360
0,210 210,360 360,540 540,660 660,840
Or you have to be
或者你必须做好提交的准备。

1451
00:55:26,360 --> 00:55:27,650
0,360 360,480 480,930 990,1200 1200,1290
ready to commit.| You have
|你必须准备好提交，

1452
00:55:27,650 --> 00:55:28,640
0,90 90,210 210,450 450,510 510,990
to be ready to commit,|
|

1453
00:55:28,640 --> 00:55:29,630
0,120 120,300 300,600 600,750 750,990
you don't commit right away,|
你不立即提交，|

1454
00:55:29,630 --> 00:55:30,710
0,120 120,240 240,330 330,780 810,1080
you have to wait until
必须等到提交消息，

1455
00:55:30,710 --> 00:55:31,670
0,60 60,300 300,570 570,660 660,960
the commit message of course,|
|

1456
00:55:31,670 --> 00:55:32,630
0,180 180,300 300,510 510,750 750,960
but you can not []
但你不能[反悔]，

1457
00:55:32,630 --> 00:55:34,490
0,180 180,630 780,1140 1230,1770 1770,1860
out anyone,| so until the
|所以，直到 prepare ，

1458
00:55:34,490 --> 00:55:35,640
0,660
prepare,|
|

1459
00:55:35,730 --> 00:55:37,920
0,420 450,1020 1020,1800 1800,2130 2130,2190
the {B,can} unilaterally abort the
B 可以单方面中止事务，

1460
00:55:37,920 --> 00:55:39,100
0,600
transaction,|
|

1461
00:55:39,100 --> 00:55:41,110
0,480 480,660 660,1080 1080,1680 1830,2010
once {} promise yes,| it
一旦承诺 yes ，|它不能再单方面中止事务。

1462
00:55:41,110 --> 00:55:43,420
0,570 570,1140 1140,1410 1410,1860 1860,2310
cannot unilaterally abort {the,transaction} anymore.|
|

1463
00:55:44,580 --> 00:55:45,840
0,270 270,450 450,540 540,1020 1020,1260
So, is it possible where
所以，有没有可能你陷入死锁，

1464
00:55:45,840 --> 00:55:47,400
0,240 240,420 450,660 660,1380 1410,1560
you {} in deadlock,| but
|但你无法摆脱死锁，

1465
00:55:47,400 --> 00:55:48,270
0,120 120,420 420,600 600,780 780,870
you can't get out of

1466
00:55:48,270 --> 00:55:49,800
0,90 90,600 600,900 900,1440 1440,1530
the deadlock,| because everyone in
|因为环中的每个都同意准备好提交。

1467
00:55:49,800 --> 00:55:52,410
0,240 240,690 690,1110 1140,1860 2220,2610
that cycle has agreed to

1468
00:55:52,560 --> 00:55:53,920
0,720
prepare

1469
00:55:53,950 --> 00:55:55,060
0,240 240,510
{commit -}.|
|

1470
00:55:55,680 --> 00:55:57,390
0,180 180,510 510,840 840,1260 1260,1710
If everybody agrees to prepare,|
如果每个人都同意准备，|

1471
00:55:57,390 --> 00:55:58,680
0,120 120,240 240,600 600,990 990,1290
they can definitely commit, then
它们肯定会提交，它们就会提交，

1472
00:55:58,680 --> 00:55:59,920
0,120 120,270 270,660
they will commit,|
|

1473
00:56:00,660 --> 00:56:02,040
0,180 180,300 300,480 480,810 810,1380
and you're still holding locks.|
你仍然持有锁。|

1474
00:56:02,710 --> 00:56:03,520
0,270 270,390 390,540 540,630 630,810
Right, but what if you're
是的，但如果你陷入死锁，

1475
00:56:03,520 --> 00:56:04,540
0,60 60,120 120,570 570,870 870,1020
in a deadlock,| because we
|因为我们前面提到了，

1476
00:56:04,540 --> 00:56:05,710
0,360 360,690 690,990 990,1080 1080,1170
mentioned before,| one of the
|你可能想要中止的原因之一。

1477
00:56:05,710 --> 00:56:06,640
0,360 360,480 480,570 570,810 810,930
reasons why you might want

1478
00:56:06,640 --> 00:56:08,890
0,1200 1200,1320 1320,1920 1920,2130 2130,2250
{to,abort}.| You would find it
|你会在准备好之前发现它，

1479
00:56:08,890 --> 00:56:10,480
0,150 150,420 420,510 510,1050
out before to prepare,|
|

1480
00:56:11,240 --> 00:56:12,170
0,210 210,330 330,540 540,600 600,930
if you get the locks
如果你得到了 y 的锁，

1481
00:56:12,170 --> 00:56:13,610
0,120 120,630 870,1050 1050,1230 1230,1440
of y,| if you did
|如果你没有成功获得事务所需的锁，

1482
00:56:13,610 --> 00:56:14,840
0,210 210,600 600,660 660,900 900,1230
not succeed in getting those

1483
00:56:14,840 --> 00:56:15,770
0,450 450,510 510,750 750,840 840,930
necessary {locks -} for the

1484
00:56:15,770 --> 00:56:18,260
0,630 780,1080 1080,1800 2070,2310 2310,2490
transaction,| {} then you know
|那么你在那个点上就知道了。

1485
00:56:18,260 --> 00:56:19,440
0,90 90,240 240,630
at that point.|
|

1486
00:56:19,990 --> 00:56:21,380
0,330 330,510 510,810
Right, thank you.|
好的，谢谢。|

1487
00:56:22,680 --> 00:56:23,820
0,270 270,390 390,570 570,690 690,1140
Okay, so this is exactly
好的，这就是将要进行的讨论，

1488
00:56:23,820 --> 00:56:24,660
0,90 90,240 240,300 300,720 720,840
the kind of discussion is

1489
00:56:24,660 --> 00:56:25,320
0,120 120,180 180,390 390,540 540,660
going to { -} come

1490
00:56:25,320 --> 00:56:27,150
0,330 360,810 810,960 960,1290 1320,1830
up,| I'm gonna, {} I'm
|我将使用同样的白板，并复制它，

1491
00:56:27,150 --> 00:56:28,380
0,210 210,360 360,450 450,750 750,1230
gonna take the same board

1492
00:56:28,740 --> 00:56:31,980
0,630 660,1320 1320,1590 1950,2850 2880,3240
and replicate it,| and consider
|考虑一系列不同的情况，

1493
00:56:31,980 --> 00:56:33,030
0,60 60,240 240,300 300,510 510,1050
a bunch of different cases,|
|

1494
00:56:33,960 --> 00:56:36,030
0,600 1050,1440 1440,1590 1590,1830 1830,2070
so here's the same board
所以这是相同的白板，

1495
00:56:36,030 --> 00:56:38,100
0,450 780,1470 1470,1620 1620,1920 1920,2070
again,| nothing has changed so
|目前为止什么都没有改变，它是一样的，

1496
00:56:38,100 --> 00:56:40,590
0,540 600,1020 1020,1200 1200,1800 2130,2490
far, {} it's identical,| and
|所以我们首先，

1497
00:56:40,590 --> 00:56:41,940
0,180 180,300 300,390 390,1020 1020,1350
so let's the first {to,sort,of}|
|

1498
00:56:41,940 --> 00:56:43,260
0,360 360,540 540,690 690,930 960,1320
follow up on this question
跟进我们刚才提出的这个问题，

1499
00:56:43,260 --> 00:56:45,210
0,90 90,210 210,420 420,1020 1290,1950
that we're just ask, {}|
|

1500
00:56:45,240 --> 00:56:47,040
0,270 270,720 720,1020 1020,1080 1080,1800
let's first consider the case
让我们首先考虑 B 处于准备状态的情况，

1501
00:56:47,310 --> 00:56:48,600
0,870
where

1502
00:56:48,740 --> 00:56:51,590
0,450 450,1110 1140,2070 2310,2760 2760,2850
{} B {} is in

1503
00:56:51,590 --> 00:56:53,080
0,90 90,480 480,930
the prepared state,|
|

1504
00:56:54,180 --> 00:56:56,400
0,150 150,540 540,1200 1260,1770 1770,2220
and then crashes right after,|
然后崩溃了，|

1505
00:56:58,050 --> 00:57:00,100
0,360 360,630 630,810 810,1560
so it is prepared,|
所以它是准备好的，|

1506
00:57:02,220 --> 00:57:03,340
0,600
it
它发回给协调者，

1507
00:57:03,340 --> 00:57:06,100
0,420 660,1200 1200,1590 1620,2280 2280,2760
{} pointed back, {send,back} to

1508
00:57:06,100 --> 00:57:09,520
0,210 210,960 960,1230 1230,1800 1800,3420
{} coordinator,| that actually is
|同意一起去做，

1509
00:57:09,610 --> 00:57:12,010
0,390 390,450 450,630 630,1140 1710,2400
agreeing to go along,| and
|然后在它发送 prepare 消息 ok 消息后，

1510
00:57:12,010 --> 00:57:13,390
0,390 390,660 660,1020 1020,1110 1110,1380
then right after it sends

1511
00:57:13,390 --> 00:57:16,060
0,390 390,1680 1680,2070 2070,2400 2400,2670
actually the prepare message ok

1512
00:57:16,060 --> 00:57:17,980
0,390 390,690 690,900 900,1530
message,| it actually crashes,|
|它崩溃了，|

1513
00:57:19,040 --> 00:57:20,820
0,300 300,390 390,540 540,960
what does that mean,|
这是什么意思，|

1514
00:57:22,500 --> 00:57:24,000
0,300 300,510 510,600 600,1020 1020,1500
what needs to happen,| how
我们需要做什么，|我们如何解决这一问题，

1515
00:57:24,000 --> 00:57:25,170
0,180 180,300 300,360 360,750 750,1170
we're going to resolve this,|
|

1516
00:57:25,730 --> 00:57:26,870
0,210 210,420 420,510 510,600 600,1140
or what is the risk,|
或者风险是什么，|

1517
00:57:28,220 --> 00:57:30,500
0,240 240,870 870,1110 1110,1770
so basically {if,B} crashes.|
如果 B 崩溃。|

1518
00:57:31,260 --> 00:57:32,670
0,660 660,1020 1020,1140 1140,1320 1320,1410
{If,B} crashes, we need to
如果 B 崩溃，我们需要中止所有东西。

1519
00:57:32,670 --> 00:57:33,990
0,240 240,330 330,540 540,750 750,1320
abort the whole thing, right.|
|

1520
00:57:34,710 --> 00:57:36,120
0,300 300,390 390,750 750,990 990,1410
Now, we cannot abort anymore,
现在，我们不能中止了，

1521
00:57:36,150 --> 00:57:37,440
0,240 240,750 750,840 840,1080 1080,1290
right,| because you know B
|因为 B 已经承诺了，

1522
00:57:37,440 --> 00:57:38,940
0,300 300,900
already promised,|
|

1523
00:57:39,060 --> 00:57:39,990
0,210 210,330 330,450 450,510 510,930
that is going to commit.|
它将会提交。|

1524
00:57:41,540 --> 00:57:42,560
0,270 270,570 570,660 660,870 870,1020
We're going to use the
我们要使用日志吗？

1525
00:57:42,560 --> 00:57:43,720
0,600
log?|
|

1526
00:57:44,410 --> 00:57:46,060
0,540 540,960 960,1140 1140,1380 1380,1650
Yeah, well, okay, so {B,is}
是的，好的，所以 B 要崩溃了，

1527
00:57:46,060 --> 00:57:47,260
0,180 180,600 600,840 840,990 990,1200
gonna crash,| at some point
|在某个时刻，会重新出现，对吧，

1528
00:57:47,260 --> 00:57:47,830
0,60 60,180 180,240 240,330 330,570
is going to come back

1529
00:57:47,830 --> 00:57:49,100
0,300 330,720
up, right,|
|

1530
00:57:49,100 --> 00:57:50,540
0,180 180,300 300,360 360,900 900,1440
it's going to recover hopefully.|
希望它会恢复。|

1531
00:57:51,210 --> 00:57:52,830
0,510 510,900 900,1200 1200,1470 1470,1620
And what state does need
哪些状态需要记住，在崩溃过程中？

1532
00:57:52,830 --> 00:57:55,420
0,90 90,540 540,1200 1350,2040
to remember across crashes?|
|

1533
00:57:56,850 --> 00:57:58,220
0,720

1534
00:57:59,130 --> 00:58:00,150
0,210 210,450 450,540 540,900 900,1020
A needs to remember that
A 需要记住是准备好的。

1535
00:58:00,150 --> 00:58:03,720
0,60 60,1260 1650,2340 3240,3390 3390,3570
{} prepared.| Yeah, and need
|是的，还需要记住，

1536
00:58:03,720 --> 00:58:04,650
0,90 90,480 480,660 660,780 780,930
to remember correct,| that it
|它准备好的事务 ID ，无论 TID 是什么，

1537
00:58:04,650 --> 00:58:06,360
0,420 420,510 510,960 960,1380 1380,1710
prepared for transaction ID, whatever

1538
00:58:06,360 --> 00:58:07,920
0,300 300,630 630,1140
the TID was,|
|

1539
00:58:08,370 --> 00:58:09,930
0,540 540,810 810,960 960,1440 1440,1560
and that is holding the
以及持有 y 的锁。

1540
00:58:09,930 --> 00:58:11,660
0,420 450,660 660,1080
lock on y.|
|

1541
00:58:12,930 --> 00:58:13,740
0,210 210,360 360,540 540,630 630,810
And so when it comes
所以，当它恢复时，

1542
00:58:13,740 --> 00:58:16,050
0,240 240,630 990,1590 1590,2070 2070,2310
back up,| {} the first
|它首先要做的是查看，

1543
00:58:16,050 --> 00:58:16,710
0,120 120,240 240,360 360,450 450,660
thing it has to do

1544
00:58:16,710 --> 00:58:17,640
0,180 180,240 240,480 480,780 780,930
sort of look, saying like

1545
00:58:17,640 --> 00:58:18,360
0,270 270,450 450,570 570,660 660,720
how,| was I in the
|我是否在分布式事务的一个参与者中间，

1546
00:58:18,360 --> 00:58:20,940
0,270 270,390 390,930 1500,2280 2280,2580
middle of a participant in

1547
00:58:20,940 --> 00:58:23,490
0,630 630,750 750,1140 1140,1800 2130,2550
a {} distributed transaction, {}|
|

1548
00:58:23,490 --> 00:58:24,360
0,420 420,570 570,630 630,780 780,870
and if you look at
如果查看状态，

1549
00:58:24,360 --> 00:58:25,620
0,120 120,630 630,810 810,1050 1050,1260
the state,| and you'll see
|你将看到，

1550
00:58:25,620 --> 00:58:26,910
0,180 180,270 270,420 420,660 660,1290
that,| it was actually prepared
|它为事务 ID TID 准备好了，

1551
00:58:26,910 --> 00:58:29,580
0,180 180,600 600,1200 1350,2040 2040,2670
for transaction ID, {} TID,|
|

1552
00:58:29,580 --> 00:58:31,230
0,570 570,720 720,1050 1050,1530 1530,1650
and it was and it
它也必须持有锁 Ly ，

1553
00:58:31,230 --> 00:58:32,460
0,240 240,480 480,540 540,990 990,1230
must hold the lock for

1554
00:58:32,460 --> 00:58:34,260
0,660 810,1170 1170,1440 1440,1740 1740,1800
Ly,| {but,the,lock,for} y before it
|获得 y 的锁在做任何其他事情之前，

1555
00:58:34,260 --> 00:58:35,460
0,210 210,630 630,1020 1020,1110 1110,1200
does anything else,| you know
|在于其他交互之前，

1556
00:58:35,460 --> 00:58:37,980
0,600 630,1080 1080,1320 1320,1890 1890,2520
before talking to anything,| once
|一旦它处于这种状态，

1557
00:58:38,190 --> 00:58:39,330
0,180 180,300 300,360 360,570 570,1140
it is in that state,|
|

1558
00:58:39,600 --> 00:58:40,680
0,420 420,540 540,660 660,900 900,1080
then it as if it
就像它没有崩溃，

1559
00:58:40,680 --> 00:58:42,900
0,240 240,720 750,1170 1260,1770 1950,2220
didn't crash, right,| and {}
|所有东西都回归正常了，

1560
00:58:42,900 --> 00:58:44,340
0,330 330,420 420,660 660,750 750,1440
things are back to normal,|
|

1561
00:58:44,490 --> 00:58:45,750
0,210 210,630 630,720 720,900 900,1260
and hopefully at some point
并且希望在某一时刻协调者将重试 commit 消息，

1562
00:58:45,750 --> 00:58:48,090
0,90 90,690 690,870 870,1770 2070,2340
the coordinated will retry the

1563
00:58:48,090 --> 00:58:50,910
0,300 300,930 1050,1860 2010,2580 2580,2820
commit message,| the B will
|B 将获得该事务 ID 的 commit 消息，

1564
00:58:50,910 --> 00:58:51,900
0,210 210,330 330,630 630,870 870,990
get up commit message for

1565
00:58:51,900 --> 00:58:53,970
0,180 180,660 660,1170 1230,1530 1530,2070
this transaction ID,| {sees,that}, yeah
|看到我确实准备好了，

1566
00:58:53,970 --> 00:58:56,250
0,330 330,690 690,1320 1410,2010 2010,2280
I'm indeed prepared,| {} and
|我希望 y 的锁，

1567
00:58:56,250 --> 00:58:56,970
0,90 90,300 300,390 390,630 630,720
I hope the lock at

1568
00:58:56,970 --> 00:58:58,350
0,480 480,630 630,870 870,1170 1170,1380
y,| and so it goes
|所以，它继续并安装 y ，等等，

1569
00:58:58,350 --> 00:58:59,820
0,330 330,450 450,960 960,1320 1320,1470
along and installs y and

1570
00:58:59,820 --> 00:59:01,760
0,480 480,900 900,1020 1020,1560
etc,| finishes the transaction.|
|完成这个事务。|

1571
00:59:04,190 --> 00:59:05,480
0,180 180,360 360,750
{Is,that} makes sense?|
这能理解吗？|

1572
00:59:05,700 --> 00:59:06,900
0,150 150,660 660,750 750,930 930,1200
So basically you know there's
所以这里有一些改进的地方，

1573
00:59:06,900 --> 00:59:08,130
0,240 240,420 420,510 510,630 630,1230
a little bit of refinement

1574
00:59:08,130 --> 00:59:10,320
0,570 600,1230 1470,1770 1770,2040 2040,2190
here,| that we actually have
|我们必须将一些数据写入到稳定存储中，

1575
00:59:10,320 --> 00:59:11,730
0,120 120,450 450,720 720,1320 1320,1410
to write some stable you

1576
00:59:11,730 --> 00:59:13,350
0,360 360,780 780,1200 1200,1320 1320,1620
know {} data to stable

1577
00:59:13,350 --> 00:59:14,670
0,510 510,600 600,750 750,990 990,1320
storage,| you know as part
|作为事务的一部分，

1578
00:59:14,670 --> 00:59:15,940
0,90 90,180 180,720
of the transaction,|
|

1579
00:59:16,340 --> 00:59:17,360
0,300 420,630 630,780 780,960 960,1020
and which was part of
这是两阶段提交的一部分，

1580
00:59:17,360 --> 00:59:18,440
0,120 120,330 330,630 810,1020 1020,1080
{2-phase -} commit,| this is
|这是两阶段提交有些昂贵的原因之一，

1581
00:59:18,440 --> 00:59:19,130
0,150 150,240 240,330 330,600 600,690
one of the reasons the

1582
00:59:19,130 --> 00:59:20,090
0,150 150,360 360,540 540,630 630,960
{2-phase -} commit is {a,little,bit}

1583
00:59:20,090 --> 00:59:22,160
0,630 780,1260 1320,1650 1650,1950 1950,2070
expensive,| because not only we
|因为我们不仅要发送多个回合的信息，

1584
00:59:22,160 --> 00:59:22,820
0,120 120,210 210,450 450,600 600,660
have to send sort of

1585
00:59:22,820 --> 00:59:24,800
0,360 360,660 660,1290 1500,1800 1800,1980
multiple round messages,| {} but
|而且参与者必须将东西写到稳定存储中，

1586
00:59:24,800 --> 00:59:27,380
0,720 840,1290 1290,1770 1770,2340 2340,2580
also { -} participant actually

1587
00:59:27,380 --> 00:59:29,060
0,210 210,360 360,810 840,1470 1470,1680
has to write {} things

1588
00:59:29,060 --> 00:59:30,560
0,90 90,390 390,1110
to stable storage,|
|

1589
00:59:30,560 --> 00:59:31,820
0,330 330,600 600,810 810,1050 1050,1260
and as we've talked about
正如我们之前讨论过的，

1590
00:59:31,820 --> 00:59:33,260
0,480 480,750 750,810 810,1110 1110,1440
before,| writing to stable storage,
|写入稳定存储是昂贵的，

1591
00:59:33,260 --> 00:59:34,970
0,450 450,600 600,810 810,1440 1440,1710
{} it's quite expensive, right,|
|

1592
00:59:34,970 --> 00:59:36,620
0,270 300,600 600,690 690,1350 1500,1650
like could be easily a
可能很容易就是几毫秒，

1593
00:59:36,620 --> 00:59:38,090
0,270 270,1020 1020,1110 1110,1200 1200,1470
couple milliseconds,| you know let's
|让我们乐观地说一毫秒，

1594
00:59:38,090 --> 00:59:41,210
0,270 780,1020 1020,1680 1830,2730 2820,3120
say one millisecond optimistically,| that
|这意味着，

1595
00:59:41,210 --> 00:59:42,620
0,210 210,630 630,810 810,930 930,1410
means basically,| that were immediately
|直接被限制在每秒 1000 个事务，

1596
00:59:42,620 --> 00:59:44,240
0,390 390,690 690,810 810,1200 1200,1620
limited to a thousand transaction

1597
00:59:44,240 --> 00:59:46,080
0,120 120,390 690,1020 1020,1380
per second,| no more.|
|不会更多。|

1598
00:59:48,080 --> 00:59:50,240
0,510 540,1140 1140,1440 1440,1650 1650,2160
Okay, let's consider another case,|
好的，让我们来考虑另一个情况，|

1599
00:59:51,750 --> 00:59:53,220
0,690 690,1110 1110,1230 1230,1380 1380,1470
{} and so let me
所以让我再复制一次这张幻灯片，

1600
00:59:53,220 --> 00:59:55,200
0,690 690,810 810,1020 1020,1410
duplicate this slide again,|
|

1601
00:59:55,740 --> 00:59:57,040
0,810

1602
01:00:01,780 --> 01:00:04,660
0,600 600,1320 1530,2400 2400,2640 2640,2880
and {} consider yet another
考虑另一种情况。

1603
01:00:04,660 --> 01:00:06,700
0,510 540,1380
case. {}|
|

1604
01:00:06,700 --> 01:00:09,120
0,240 240,930 960,1830
Let's say, {}
比如，协调者崩溃，

1605
01:00:09,580 --> 01:00:12,700
0,630 630,960 1470,1950 1980,2520 2520,3120
we {} the coordinator crashes,|
|

1606
01:00:12,730 --> 01:00:15,820
0,270 270,900 1140,2130 2280,2880 2880,3090
and so {you,know} here's red
所以，这里使用红色铅笔，

1607
01:00:15,820 --> 01:00:16,820
0,450
again,

1608
01:00:16,880 --> 01:00:19,100
0,270 270,870 1230,2010 2010,2100 2100,2220
which pencil,| and you know
|我们有一个，我们有准备好的消息，

1609
01:00:19,100 --> 01:00:21,320
0,90 90,360 360,540 540,1230 1230,2220
we got like one, {}

1610
01:00:21,470 --> 01:00:23,840
0,450 450,840 840,1560 1860,2310 2310,2370
{we,got} prepared messages,| and the
|协调者可能已经发送了一条 commit 消息，

1611
01:00:23,840 --> 01:00:25,670
0,870 870,1140 1140,1320 1320,1620 1620,1830
coordinator maybe {you,know} send one

1612
01:00:25,670 --> 01:00:27,800
0,270 270,840 1080,1350 1350,1530 1530,2130
commit message,| and then crashes
|然后在这里崩溃，

1613
01:00:27,830 --> 01:00:29,200
0,510 510,870
right here,|
|

1614
01:00:29,880 --> 01:00:33,210
0,540 900,1020 1020,1080 1080,1770 3030,3330
{} you know what, what
我们需要安排什么，

1615
01:00:33,210 --> 01:00:34,290
0,90 90,210 210,360 360,420 420,1080
do we need to arrange|
|

1616
01:00:34,320 --> 01:00:35,160
0,270 270,450 450,660 660,780 780,840
to make sure that the
确保整个方案顺利实施。

1617
01:00:35,160 --> 01:00:36,820
0,240 240,510 510,780 780,1140
whole plan works out.|
|

1618
01:00:42,210 --> 01:00:43,740
0,150 150,240 240,720 720,1020 1020,1530
So the coordinator needs to
所以协调器需要将命令持久化存储，

1619
01:00:43,770 --> 01:00:44,880
0,240 240,510 510,630 630,660 660,1110
{} store in a persistent

1620
01:00:44,880 --> 01:00:46,650
0,360 360,870 870,1290 1380,1620 1620,1770
storage what are what are

1621
01:00:46,650 --> 01:00:48,120
0,210 210,750 750,960 960,1080 1080,1470
the commands,| that were promised
|已经承诺提交，但还没有提交的。

1622
01:00:48,120 --> 01:00:49,020
0,60 60,150 150,510 510,720 720,900
to be committed, but we're

1623
01:00:49,020 --> 01:00:50,400
0,330 330,600 600,810
not committed yet.|
|

1624
01:00:50,430 --> 01:00:51,930
0,420 420,570 570,630 630,1080 1080,1500
Yeah, so the coordinator is
是的，所以协调者几乎和对 B 的分析相同，

1625
01:00:51,930 --> 01:00:53,490
0,240 240,300 300,630 630,750 750,1560
almost the same as {

1626
01:00:53,490 --> 01:00:55,740
0,90 90,900 900,1560 1560,1860 1860,2250
-} analysis, analysts to B's

1627
01:00:55,740 --> 01:00:57,180
0,300 300,720 930,1200 1200,1350 1350,1440
case, correct,| {} if we
|如果我们提交一个事务，

1628
01:00:57,180 --> 01:00:58,500
0,270 270,330 330,990 1020,1170 1170,1320
commit a transaction,| we need
|我们需要写入稳定存储，

1629
01:00:58,500 --> 01:00:59,580
0,90 90,360 360,450 450,720 720,1080
to write to stable storage,|
|

1630
01:00:59,580 --> 01:01:00,420
0,120 120,210 210,450 450,750 750,840
that we're actually committing the
我们正在提交事务，

1631
01:01:00,420 --> 01:01:01,530
0,540 540,810 810,900 900,1020 1020,1110
transaction,| so we need to
|因此我们需要写入稳定存储， commit tid ，

1632
01:01:01,530 --> 01:01:02,640
0,240 240,330 330,600 600,1020 1020,1110
write to stable storage you

1633
01:01:02,640 --> 01:01:04,540
0,180 180,540 540,720 720,1320
know commit {TID -},|
|

1634
01:01:05,660 --> 01:01:07,430
0,660 690,840 840,1110 1110,1680 1680,1770
{} so that when the
这样当协调者回来的时候，

1635
01:01:07,430 --> 01:01:09,770
0,450 450,630 630,870 870,1200 1530,2340
coordinator comes back up,| then
|然后它才能完成事务，

1636
01:01:09,770 --> 01:01:10,910
0,0 0,600 600,690 690,900 900,1140
{} it can actually finish

1637
01:01:10,910 --> 01:01:12,770
0,90 90,540 540,1020 1020,1350 1350,1860
the transaction| until actually the
|在 A 和 B 事务提交之前，

1638
01:01:13,550 --> 01:01:15,110
0,90 90,390 390,780 780,1140 1140,1560
{A,and} B {} indeed transaction

1639
01:01:15,110 --> 01:01:16,130
0,120 120,480 510,780 780,930 930,1020
is committed,| because A and
|因为 A 和 B 都在等着，

1640
01:01:16,130 --> 01:01:17,240
0,150 150,270 270,690 720,840 840,1110
B are waiting, right,| A
|A 和 B 说，是的，我们很乐意继续，

1641
01:01:17,240 --> 01:01:18,590
0,90 90,390 390,570 570,720 720,1350
and B says, like yeah

1642
01:01:18,620 --> 01:01:19,910
0,240 240,480 480,570 570,720 720,1290
we're happy to go along,|
|

1643
01:01:20,150 --> 01:01:22,460
0,420 420,990 990,1380 1380,1830 1830,2310
and they're waiting waiting| until
它们一直在等待，|直到它们听到协调者决定完成，

1644
01:01:22,460 --> 01:01:23,870
0,270 270,570 570,900 900,1260 1260,1410
actually they {} hear from

1645
01:01:23,870 --> 01:01:25,370
0,60 60,720 720,960 960,1290 1290,1500
the coordinator to decide what's

1646
01:01:25,370 --> 01:01:27,470
0,300 300,780 1110,1470 1470,1770 1770,2100
done,| because {} once they
|因为一旦它们决定，一旦它们继续，

1647
01:01:27,470 --> 01:01:29,600
0,600 1080,1410 1410,1500 1500,1710 1710,2130
decided, once they went along,|
|

1648
01:01:29,600 --> 01:01:30,590
0,0 0,450 450,540 540,930 930,990
{} once they agreed to
一旦它们同意继续，

1649
01:01:30,590 --> 01:01:31,700
0,180 180,720 780,900 900,960 960,1110
go along,| you know they
|它们就不能单方面[]，

1650
01:01:31,700 --> 01:01:34,310
0,240 240,450 450,1110 1110,1800 1830,2610
{cannot -} unilaterally anymore [],

1651
01:01:34,310 --> 01:01:36,440
0,270 270,780 1020,1560 1590,1920 1920,2130
correct,| because, {} let's say
|因为，假设它们都说完全同意，

1652
01:01:36,440 --> 01:01:37,550
0,270 270,540 540,810 810,1020 1020,1110
they actually both said that

1653
01:01:37,550 --> 01:01:39,140
0,120 120,420 420,540 540,960 1200,1590
they agreed at all, {}|
|

1654
01:01:39,140 --> 01:01:39,950
0,240 240,330 330,630 630,750 750,810
then it means that the
那就意味着协调者，

1655
01:01:39,950 --> 01:01:42,560
0,840 840,1050 1050,1410 1410,2070 2070,2610
coordinator| and they don't know
|它们不知道，

1656
01:01:42,560 --> 01:01:44,380
0,180 180,510 510,630 630,1170
they made,| the coordinator
|协调者发送 commit 信息给 A ，

1657
01:01:44,380 --> 01:01:45,880
0,570 660,930 930,960 960,1200 1200,1500
{} send a commit message

1658
01:01:45,880 --> 01:01:46,930
0,150 150,240 240,570 570,900 900,1050
to for example A| and
|表示提交事务，

1659
01:01:46,930 --> 01:01:49,120
0,330 330,480 480,840 840,1530 1800,2190
actually has commit transaction,| B
|B 还没有收到，

1660
01:01:49,120 --> 01:01:50,020
0,210 210,450 450,660 660,840 840,900
hasn't heard yet,| maybe the
|可能消息延迟了，然后协调者崩溃了，

1661
01:01:50,020 --> 01:01:51,820
0,240 240,360 360,870 870,1080 1080,1800
message got delayed, then the

1662
01:01:51,820 --> 01:01:53,830
0,420 420,480 480,1110 1260,1800 1800,2010
coordinator got crash,| and {you,know}
|在这一点上，

1663
01:01:53,830 --> 01:01:55,060
0,180 180,600 720,930 930,1080 1080,1230
that point,| it would be
|B 中止事务将是完全错误的，

1664
01:01:55,060 --> 01:01:56,530
0,510 510,990 990,1170 1170,1380 1380,1470
totally wrong for B to

1665
01:01:56,530 --> 01:01:58,420
0,450 480,690 690,1230 1410,1650 1650,1890
abort the transaction,| it really
|它必须要等到协调者回来，

1666
01:01:58,420 --> 01:01:59,830
0,270 270,390 390,720 720,1140 1140,1410
has to wait until the

1667
01:01:59,890 --> 01:02:02,170
0,600 600,810 810,1260 1350,1650 1650,2280
coordinator comes back| to tell
|判断事务的结果是什么。

1668
01:02:02,200 --> 01:02:03,310
0,180 180,390 390,510 510,930 930,1110
what actually the outcome is

1669
01:02:03,310 --> 01:02:04,460
0,90 90,180 180,750
of the transaction.|
|

1670
01:02:07,880 --> 01:02:09,780
0,720
Okay?|
好的?|

1671
01:02:12,880 --> 01:02:15,100
0,450 450,900 900,1350 1380,1890 2070,2220
So only,| {} sorry, the
所以，只有，|抱歉，协调者不会重新发送的唯一消息是 prepare ，

1672
01:02:15,100 --> 01:02:16,720
0,210 210,660 660,930 930,1170 1170,1620
only message that the coordinator

1673
01:02:16,720 --> 01:02:18,220
0,150 150,360 360,660 660,960 960,1500
is not going to resend

1674
01:02:18,220 --> 01:02:19,620
0,210 210,840
is prepare,|
|

1675
01:02:19,820 --> 01:02:20,930
0,180 180,480 480,690 690,810 810,1110
that one if it gets,
如果它没有得到 yes ，它就会中止？

1676
01:02:20,930 --> 01:02:22,580
0,510 750,1140 1140,1260 1260,1350 1350,1650
like doesn't get a yes,

1677
01:02:22,580 --> 01:02:24,060
0,210 210,450 450,960
it'll just abort?|
|

1678
01:02:24,150 --> 01:02:25,200
0,300 300,630 630,750 750,840 840,1050
Yeah, it was the next
是的，这是下一个例子，所以我们继续。

1679
01:02:25,200 --> 01:02:26,820
0,570 810,1110 1110,1320 1320,1530 1530,1620
example, {} so let's do

1680
01:02:26,820 --> 01:02:27,760
0,360
that.|
|

1681
01:02:28,010 --> 01:02:30,020
0,1260 1260,1320 1320,1740 1740,1830 1830,2010
Let me duplicate this board
让我再复制一下这个白板，

1682
01:02:30,020 --> 01:02:31,020
0,450
again,|
|

1683
01:02:31,520 --> 01:02:33,830
0,480 480,660 660,960 960,1500 1650,2310
and talk about {that,case}. {}|
然后谈谈这种情况。|

1684
01:02:33,830 --> 01:02:35,040
0,660
So,
所以，为了[]，我们把它移到下面，

1685
01:02:35,190 --> 01:02:36,930
0,480 570,930 930,1230 1230,1410 1410,1740
just for [], let's move

1686
01:02:36,930 --> 01:02:39,000
0,60 60,540 870,1080 1080,1530 1530,2070
it down,| so {[] -},|
|所以[]，|

1687
01:02:39,000 --> 01:02:41,130
0,0 750,1110 1110,1500 1500,1650 1650,2130
{} let's say you know
假设下面的事情发生，

1688
01:02:41,280 --> 01:02:44,240
0,480 480,630 630,1350 1590,2430
following thing happens, {}|
|

1689
01:02:44,270 --> 01:02:46,160
0,390 390,1080 1080,1350 1350,1650 1650,1890
the {this,prepare -} message never
这个 prepare 消息永远不会出现，

1690
01:02:46,160 --> 01:02:47,240
0,240 240,630
makes it,

1691
01:02:48,000 --> 01:02:49,020
0,450
right,|
|

1692
01:02:49,400 --> 01:02:52,010
0,870 870,1500 1500,2100 2100,2250 2250,2610
{} and then you know
然后协调者可以单方面决定中止，

1693
01:02:52,070 --> 01:02:53,840
0,210 210,510 510,1020 1020,1170 1170,1770
{} the coordinator can unilaterally

1694
01:02:53,840 --> 01:02:57,160
0,450 450,1170 1440,2250 2280,2670
decide to abort, right,|
|

1695
01:02:57,800 --> 01:02:58,910
0,510 510,690 690,930 930,1020 1020,1110
and in fact you can
事实上，你可以告诉 B 中止，

1696
01:02:58,910 --> 01:02:59,750
0,210 210,480 480,600 600,720 720,840
tell B you know to

1697
01:02:59,750 --> 01:03:01,820
0,120 120,540 660,1590 1650,1830 1830,2070
{abort -},| and A doesn't
|A 不需要知道任何关于它的事情，

1698
01:03:01,820 --> 01:03:02,960
0,210 210,420 420,480 480,810 810,1140
really need to know anything

1699
01:03:02,960 --> 01:03:06,650
0,270 270,480 510,1200 1530,2400 2790,3690
about it [],| {} the
|有些会晚点回来问协调者，

1700
01:03:07,190 --> 01:03:08,960
0,540 750,1020 1020,1440 1470,1560 1560,1770
{} someone later you know

1701
01:03:08,960 --> 01:03:09,980
0,150 150,300 300,540 540,750 750,1020
will come up and ask

1702
01:03:09,980 --> 01:03:11,600
0,120 120,810 810,900 900,1410 1410,1620
the coordinator,| the coordinator doesn't
|协调者不知道关于这个事务的任何更多信息，

1703
01:03:11,600 --> 01:03:12,560
0,180 180,480 480,660 660,780 780,960
know anything about any more

1704
01:03:12,560 --> 01:03:13,940
0,180 180,300 300,900 1110,1290 1290,1380
about this transaction,| you can
|你可以告诉 A ，那个事务已经中止，

1705
01:03:13,940 --> 01:03:15,740
0,150 150,450 450,1320 1320,1530 1530,1800
just tell A, {that,transaction} is

1706
01:03:15,740 --> 01:03:17,090
0,270 270,750 780,1080 1080,1170 1170,1350
actually abort,| because I don't
|因为我没有提交记录，

1707
01:03:17,090 --> 01:03:18,650
0,180 180,360 480,780 780,1020 1020,1560
have a commit record anymore,|
|

1708
01:03:18,650 --> 01:03:19,970
0,330 330,480 480,750 750,840 840,1320
I was not {} waiting
我没有等待通知任何人。

1709
01:03:19,970 --> 01:03:21,460
0,270 270,570 570,1020
to inform anybody.|
|

1710
01:03:22,930 --> 01:03:23,590
0,180 180,240 240,390 390,600 600,660
So in that case, we
所以在这种情况下，我们可以中止，

1711
01:03:23,590 --> 01:03:24,920
0,120 120,270 270,330 330,780
can do an abort,|
|

1712
01:03:25,520 --> 01:03:26,360
0,180 180,300 300,510 510,630 630,840
and that means that B
这意味着 B 可以释放锁，

1713
01:03:26,360 --> 01:03:27,860
0,210 210,540 540,600 600,1020 1020,1500
can release the locks, correct|
|

1714
01:03:27,860 --> 01:03:30,170
0,420 510,960 960,1140 1140,1770 2130,2310
and {B,can} just proceed,| {you,know}
B 可以继续，|尝试其他可能涉及 y 的事务。

1715
01:03:30,170 --> 01:03:32,660
0,420 420,690 690,1080 1080,1950
happily trying to {}

1716
01:03:32,780 --> 01:03:33,950
0,210 210,420 420,870 870,960 960,1170
the other transactions that might

1717
01:03:33,950 --> 01:03:36,420
0,630 810,1320 1320,1920
involve {} y.|
|

1718
01:03:38,630 --> 01:03:39,820
0,630
Okay?|
好的?|

1719
01:03:40,680 --> 01:03:41,790
0,360 360,690 690,810 810,960 960,1110
{} Sorry, so what will
抱歉，如果给 A 的信息丢失会发生什么，

1720
01:03:41,790 --> 01:03:43,500
0,510 510,930 930,1080 1080,1530 1530,1710
happen if the message to

1721
01:03:43,500 --> 01:03:45,630
0,180 180,540 540,1140 1380,1530 1530,2130
A gets lost,| the coordinator
|协调器中止，

1722
01:03:45,630 --> 01:03:46,960
0,150 150,870
{aborts -},|
|

1723
01:03:47,110 --> 01:03:48,880
0,180 180,360 360,480 480,1440 1590,1770
and then B crashes,| but
然后 B 崩溃了，|但是当它回来时，

1724
01:03:48,880 --> 01:03:50,080
0,300 300,510 510,600 600,870 870,1200
then when it comes up|
|

1725
01:03:50,110 --> 01:03:51,820
0,180 180,480 480,660 660,1230 1500,1710
is going to wait for
它将等待来自协调者的提交消息，

1726
01:03:51,820 --> 01:03:53,200
0,60 60,390 390,900 900,1140 1140,1380
{} commit message from {}

1727
01:03:53,410 --> 01:03:55,540
0,1050 1110,1260 1260,1350 1350,1920 1920,2130
coordinator,| but the transaction has
|但这个事务已经中止。

1728
01:03:55,540 --> 01:03:58,360
0,480 480,1080 1110,1740 1740,2220 2220,2820
aborted already.| Yeah, or yeah
|是的，这两种情况，

1729
01:03:58,360 --> 01:03:59,980
0,270 270,690 690,840 840,990 990,1620
so either these two cases,|
|

1730
01:04:00,010 --> 01:04:01,690
0,690 720,840 840,930 930,1590 1590,1680
{} you know presumably you
大多数协议 B 会 ping 协调者，

1731
01:04:01,690 --> 01:04:03,040
0,210 210,360 360,570 570,1050 1050,1350
know the most protocols actually

1732
01:04:03,040 --> 01:04:04,930
0,390 390,810 840,1080 1080,1710 1710,1890
{B,will} ping the coordinator,| because
|因为它知道谁是协调者，

1733
01:04:04,930 --> 01:04:06,190
0,60 60,300 300,480 480,540 540,1260
it knows who's the coordinator,|
|

1734
01:04:06,850 --> 01:04:08,710
0,480 570,1170 1170,1470 1470,1590 1590,1860
and ask what's the outcome
并询问这个事务的结果是什么。

1735
01:04:08,710 --> 01:04:09,880
0,90 90,450 450,750
of that transaction.|
|

1736
01:04:15,840 --> 01:04:16,890
0,240 240,390 390,570 570,750 750,1050
Okay, so one more case,
好的，我想再谈一种情况，

1737
01:04:16,890 --> 01:04:17,520
0,0 0,210 210,270 270,570 570,630
I want to return to

1738
01:04:17,520 --> 01:04:18,810
0,240 240,540 540,810 810,1080 1080,1290
one case,| there's actually sort
|有一种最有趣的情况，

1739
01:04:18,810 --> 01:04:21,030
0,90 90,540 930,1320 1320,1650 1650,2220
of the most interesting case,|
|

1740
01:04:21,420 --> 01:04:23,130
0,720 810,1380 1380,1440 1440,1530 1530,1710
{} one of the more
是最棘手的情况之一。

1741
01:04:23,130 --> 01:04:24,780
0,270 270,960 1110,1350 1350,1440 1440,1650
tricky cases.| So I just
|所以我有一个简单的问题。

1742
01:04:24,780 --> 01:04:26,790
0,180 720,870 870,1140 1140,1620 1710,2010
have a brief question. {}|
|

1743
01:04:26,790 --> 01:04:28,050
0,450 450,630 630,720 720,900 900,1260
Yeah, hold on one second.|
好的，等一下。|

1744
01:04:28,200 --> 01:04:30,540
0,300 600,1140 1500,1680 1680,2040 2040,2340
Sorry.| Yeah.| Yeah, so the
抱歉。|好的。|好的，所以第一个问题是，

1745
01:04:30,540 --> 01:04:32,550
0,210 210,450 450,540 540,1260 1470,2010
first question is that,| so
|假设 B 持有 y 的锁，

1746
01:04:32,580 --> 01:04:34,470
0,270 300,960 990,1230 1230,1410 1410,1890
let's B let's say holds

1747
01:04:34,470 --> 01:04:36,480
0,120 120,450 480,720 720,1350 1620,2010
the lock on y,| all
|直到把 y 放入日志，

1748
01:04:36,480 --> 01:04:38,490
0,120 120,450 450,750 750,1320 1380,2010
the way through between putting

1749
01:04:38,490 --> 01:04:39,750
0,270 270,510 510,600 600,1050 1080,1260
y into the log,| and
|把 y 安装到[]。

1750
01:04:39,750 --> 01:04:42,000
0,210 210,840 840,1470 1650,1920 1920,2250
so installing y {} to

1751
01:04:42,480 --> 01:04:44,080
0,330 420,540 540,780 840,1140
[] {}.| Yes.| Okay.|
|是的。|好的。|

1752
01:04:44,080 --> 01:04:45,310
0,390 390,600 600,900 900,990 990,1230
{} And then the second
然后是第二个问题，

1753
01:04:45,310 --> 01:04:46,570
0,300 300,690 690,810 810,1080 1080,1260
question,| so the locks here
|这里的锁是分布式的，

1754
01:04:46,570 --> 01:04:49,120
0,450 510,1620 1980,2310 2310,2370 2370,2550
are distributed,| because we are
|因为我们在处理跨服务器的问题，

1755
01:04:49,120 --> 01:04:50,560
0,240 240,390 390,630 630,1080 1080,1440
dealing with across servers,| or
|我的意思是，如果 y 只存在于服务器 B 上，

1756
01:04:50,890 --> 01:04:52,000
0,360 360,450 450,630 630,810 810,1110
{} I mean if y

1757
01:04:52,000 --> 01:04:53,290
0,270 270,660 660,840 840,900 900,1290
only exist on the server

1758
01:04:53,290 --> 01:04:54,370
0,240 240,390 390,630 630,750 750,1080
B,| then maybe we don't
|或许我们不需要对它加锁，

1759
01:04:54,370 --> 01:04:55,300
0,150 150,270 270,390 390,540 540,930
need this to be locking,|
|

1760
01:04:55,360 --> 01:04:56,290
0,150 150,360 360,660 660,750 750,930
I'm just curious of what
我只是好奇是怎么回事。

1761
01:04:56,290 --> 01:04:57,520
0,60 60,540 660,990 990,1050 1050,1230
the setup.| Yeah, the {setup
|是的，这里的设置，

1762
01:04:57,520 --> 01:04:58,840
0,60 60,390 390,810 810,1140 1140,1320
-} {is,here} basically,| that A
|A 维护它的所有分片的锁，

1763
01:04:58,840 --> 01:05:00,520
0,480 480,630 630,1020 1020,1500 1500,1680
maintains the lock for all

1764
01:05:00,520 --> 01:05:01,780
0,90 90,510 510,660 660,840 840,1260
the shards that it has,|
|

1765
01:05:01,870 --> 01:05:02,950
0,210 210,330 330,420 420,930 930,1080
for all the variables, {}
它的所有的变量，所有的记录，

1766
01:05:02,950 --> 01:05:03,790
0,90 90,210 210,510 510,660 660,840
all the records that it

1767
01:05:03,790 --> 01:05:05,440
0,330 330,630 630,1080 1080,1500 1500,1650
has,| B maintained {the,lock} for
|B 维护它所有的记录。

1768
01:05:05,440 --> 01:05:06,730
0,150 150,390 390,690 690,840 840,1290
all the records it has.|
|

1769
01:05:07,440 --> 01:05:08,430
0,240 240,390 390,540 540,870 870,990
Okay, but if we,| for
好的，但如果我们，|例如， y 在多个服务器上，

1770
01:05:08,430 --> 01:05:09,690
0,360 360,570 570,900 900,1140 1140,1260
example have y being on

1771
01:05:09,690 --> 01:05:11,130
0,390 390,840 840,1140 1140,1230 1230,1440
multiple servers,| then we need
|那么我们需要某种分布式锁？

1772
01:05:11,130 --> 01:05:12,270
0,210 210,420 420,510 510,960 960,1140
some sort of distributed lock?|
|

1773
01:05:12,720 --> 01:05:14,610
0,540 540,750 750,1230 1260,1680 1680,1890
Yeah, like we were talking
是的，我们在谈论分片的情况，

1774
01:05:14,610 --> 01:05:15,780
0,150 150,240 240,600 600,960 960,1170
about the sharded case, right,|
|

1775
01:05:15,780 --> 01:05:16,890
0,270 270,360 360,720 720,810 810,1110
where the accounts are sharded
帐户分片在多个服务器之上，

1776
01:05:16,890 --> 01:05:18,780
0,330 330,660 660,1320 1470,1680 1680,1890
across multiple servers,| and only
|只有一台服务器有特定的帐户。

1777
01:05:18,780 --> 01:05:19,860
0,150 150,450 450,690 690,720 720,1080
one server has a particular

1778
01:05:19,860 --> 01:05:20,780
0,390
account.|
|

1779
01:05:22,560 --> 01:05:23,760
0,300 300,510 510,720 810,1050 1050,1200
Awesome, thank you.| I'm Come
太棒了，谢谢。|我稍后再回到这个问题上，再说一次。

1780
01:05:23,760 --> 01:05:24,990
0,210 210,330 330,510 510,810 810,1230
back to this later, actually

1781
01:05:25,020 --> 01:05:26,400
0,270 270,420 420,810
one more time.|
|

1782
01:05:27,060 --> 01:05:27,870
0,150 150,240 240,420 420,600 600,810
So the first thing I
所以我想指出的第一件事是，

1783
01:05:27,870 --> 01:05:29,460
0,240 240,300 300,540 540,870 900,1590
wanted to point out {}

1784
01:05:29,460 --> 01:05:30,810
0,450 450,630 630,780 780,1140 1140,1350
is,| just go back to
|回来看看这种情况，

1785
01:05:30,810 --> 01:05:33,990
0,180 180,270 270,990 1290,2130 2430,3180
sort of the, {} the

1786
01:05:34,990 --> 01:05:39,200
0,840 930,1410 1410,2010 2190,2820
{} case,| where {}
|B 或 A 回复 yes ，然后崩溃了，

1787
01:05:39,230 --> 01:05:41,120
0,660 690,990 990,1470 1500,1620 1620,1890
B or A you know

1788
01:05:41,120 --> 01:05:42,860
0,210 210,780 840,1020 1020,1170 1170,1740
said yes and then crashes,

1789
01:05:45,300 --> 01:05:47,600
0,540 930,1770
correct, {}|
|

1790
01:05:47,600 --> 01:05:48,860
0,540 540,810 810,960 960,1200 1200,1260
or actually yeah, let me
或者，让我看看是不是这样，

1791
01:05:48,860 --> 01:05:50,030
0,150 150,300 300,450 450,540 540,1170
see if that's the case,|
|

1792
01:05:50,610 --> 01:05:51,720
0,210 210,720 720,840 840,1050 1050,1110
{no -}, I want the
不，我想下面这种情况，

1793
01:05:51,720 --> 01:05:52,740
0,240 240,300 300,540 540,750 750,1020
case of following case, right,|
|

1794
01:05:53,570 --> 01:05:56,620
0,1200 1410,1770 1770,1980 1980,2490
{} fix this line,|
修复这条线，|

1795
01:05:56,620 --> 01:05:58,750
0,180 180,930 960,1440 1440,1620 1620,2130
so {A,and,B} promised their thing,|
所以 A 和 B 承诺了，|

1796
01:05:59,050 --> 01:06:01,030
0,780 810,1290 1350,1740 1740,1830 1830,1980
{} but {} I want
但我想回到这个情况，

1797
01:06:01,030 --> 01:06:01,720
0,60 60,210 210,510 510,600 600,690
to go back to the

1798
01:06:01,720 --> 01:06:03,070
0,360 360,810 810,960 960,1050 1050,1350
case,| where that we already
|我们已经讨论过了，

1799
01:06:03,070 --> 01:06:05,350
0,630 750,1110 1110,1620 1800,2100 2100,2280
discussed,| which is right after
|也就是在提交点之后，

1800
01:06:05,350 --> 01:06:07,920
0,60 60,360 360,900 1200,1920
the commit point, {}|
|

1801
01:06:07,950 --> 01:06:09,700
0,180 180,630 630,1230
the coordinator crashes.|
协调者崩溃。|

1802
01:06:10,490 --> 01:06:12,820
0,450 1020,1770
Okay.| And,
好的。|而且，我们知道这段时间，从这里到那里，

1803
01:06:12,880 --> 01:06:14,950
0,270 270,450 450,810 810,1050 1050,2070
and we know correct this

1804
01:06:14,950 --> 01:06:16,560
0,330 330,420 420,1050
interval of time

1805
01:06:17,140 --> 01:06:19,090
0,240 240,750 750,900 900,1260 1260,1950
from here to there,| basically
|B 不能再单方面中止了，

1806
01:06:19,570 --> 01:06:22,540
0,480 510,1020 1020,1710 1740,2640 2640,2970
{} B cannot unilaterally abort

1807
01:06:22,540 --> 01:06:24,790
0,420 450,690 690,1050 1050,1440 1440,2250
anymore, right,| because it promised
|因为它承诺会继续，

1808
01:06:24,790 --> 01:06:27,160
0,120 120,360 360,930 1110,1920 2100,2370
to go along,| and it
|也有可能是这样的，

1809
01:06:27,160 --> 01:06:28,090
0,180 180,330 330,480 480,540 540,930
might have been the case,|
|

1810
01:06:28,090 --> 01:06:30,580
0,240 240,930 930,1530 1530,2040 2040,2490
that actually {A,did} actually already
A 已经提交了，

1811
01:06:30,580 --> 01:06:31,740
0,240 240,600
did commit,|
|

1812
01:06:31,830 --> 01:06:33,750
0,180 180,300 300,390 390,990 990,1920
and so it cannot unilaterally
所以，它不能再单方面中止了，

1813
01:06:33,810 --> 01:06:36,210
0,510 510,900 900,1470 1740,1890 1890,2400
{} abort anymore,| and so
|所以在这种情况下只有一个选择，

1814
01:06:36,240 --> 01:06:37,470
0,240 240,420 420,780 780,1140 1140,1230
there's only one option in

1815
01:06:37,470 --> 01:06:38,400
0,150 150,510 510,720 720,810 810,930
this case,| what is that
|是哪种选择？

1816
01:06:38,400 --> 01:06:39,540
0,180 180,570
one option?|
|

1817
01:06:52,380 --> 01:06:55,170
0,330 330,750 750,1380 1650,2190 2550,2790
We just wait.| Yeah, it's
我们只能等待。|是的，这很不幸，但却是真的，

1818
01:06:55,170 --> 01:06:59,670
0,1020 1080,1650 1650,2430 4080,4260 4260,4500
unfortunate but true,| the only
|我们唯一能做的就是等待，

1819
01:06:59,670 --> 01:07:00,330
0,150 150,270 270,360 360,480 480,660
thing that we can do

1820
01:07:00,330 --> 01:07:01,360
0,90 90,510
is wait,|
|

1821
01:07:01,650 --> 01:07:03,180
0,570 600,870 870,1080 1080,1440 1440,1530
and it's still holding the
它仍然持有 y 的锁，

1822
01:07:03,180 --> 01:07:04,650
0,420 450,780 780,1110 1110,1350 1350,1470
lock on y, correct,| so
|所以这意味着，

1823
01:07:04,650 --> 01:07:05,670
0,120 120,390 390,600 600,810 810,1020
that means that,| any other
|任何其他涉及 y 的事务都不能继续进行，

1824
01:07:05,670 --> 01:07:07,830
0,480 480,630 630,1020 1020,1530 1830,2160
transaction that involves y {you,know}

1825
01:07:07,830 --> 01:07:11,130
0,450 450,990 1410,1890 1890,2970 2970,3300
cannot proceed,| {} one has
|必须等待协调者回来，

1826
01:07:11,130 --> 01:07:12,360
0,120 120,570 600,720 720,870 870,1230
to wait you know until

1827
01:07:12,360 --> 01:07:14,880
0,90 90,660 660,870 870,1320 1650,2520
the coordinator comes back,| and
|宣布或重新宣布决定，

1828
01:07:14,880 --> 01:07:17,280
0,690 690,1290 1320,1620 1620,2070 2070,2400
announces or {re-announces -} whatever

1829
01:07:17,280 --> 01:07:18,570
0,480 480,720 720,840 840,1140 1140,1290
decision was,| that actually was
|那个事务的结果是什么。

1830
01:07:18,570 --> 01:07:19,650
0,120 120,390 390,510 510,660 660,1080
the outcome for that particular

1831
01:07:19,650 --> 01:07:20,660
0,480
transaction.|
|

1832
01:07:21,160 --> 01:07:22,180
0,240 240,330 330,540 540,660 660,1020
This is one of the
这是两个方面中的一个，

1833
01:07:22,180 --> 01:07:24,310
0,360 630,960 1080,1290 1290,1530 1530,2130
sort of the two aspects,|
|

1834
01:07:24,310 --> 01:07:25,210
0,180 180,450 450,630 630,810 810,900
you know this one of
这是两阶段提交的其中一个方面，

1835
01:07:25,210 --> 01:07:26,980
0,570 570,1080 1080,1470 1470,1590 1590,1770
these aspects of {2-phase -}

1836
01:07:26,980 --> 01:07:30,190
0,420 780,1170 1170,1530 1530,2250 2280,3210
commit,| {} that are been
|这些都是可取的，

1837
01:07:30,190 --> 01:07:33,430
0,600 630,930 930,1500 1710,2340 2610,3240
desirable, right,| where {} the
|在那里协议可能会被阻塞，直到机器回来。

1838
01:07:33,670 --> 01:07:36,130
0,660 900,1440 1440,1620 1620,1830 1830,2460
{} protocol might just block

1839
01:07:36,160 --> 01:07:37,990
0,570 570,960 960,1260 1260,1440 1440,1830
{until,a -} machine comes back.|
|

1840
01:07:40,450 --> 01:07:41,900
0,240 240,360 360,480 480,900
Does that make sense?|
这能理解吗？|

1841
01:07:45,720 --> 01:07:47,580
0,180 180,570 570,900 900,1440 1440,1860
So how do people deal
那么，人们在实践中是如何处理这一问题的，

1842
01:07:47,580 --> 01:07:48,930
0,90 90,240 240,330 330,810 810,1350
with this in practice,| well,
|好吧，这有点不幸，

1843
01:07:49,540 --> 01:07:50,650
0,180 180,210 210,360 360,450 450,1110
it's a little bit unfortunate,|
|

1844
01:07:50,950 --> 01:07:52,720
0,510 510,570 570,930 930,1560 1590,1770
but the here's were some
但这里是我们过去的一些技巧可以来拯救，

1845
01:07:52,720 --> 01:07:53,800
0,120 120,360 360,810 810,990 990,1080
of our techniques from the

1846
01:07:53,800 --> 01:07:55,210
0,360 360,570 570,780 780,930 930,1410
past can come to rescue,|
|

1847
01:07:55,240 --> 01:07:55,900
0,150 150,210 210,450 450,570 570,660
you know what could we
我们能对协调者做些什么，

1848
01:07:55,900 --> 01:07:57,660
0,150 150,390 390,570 570,1290
do with the coordinator,|
|

1849
01:07:58,610 --> 01:08:00,560
0,300 300,570 570,810 810,1440 1440,1950
to make this scenario unlikely.|
让这种情况变得不太可能。|

1850
01:08:06,420 --> 01:08:06,990
0,150 150,210 210,330 330,450 450,570
So we can make it
我们可以让它容错。

1851
01:08:06,990 --> 01:08:09,300
0,270 270,720 900,1320 1320,2070 2070,2310
fault tolerant, like.| Yeah, make
|是的，做容错，我们怎么做呢？

1852
01:08:09,300 --> 01:08:10,140
0,180 180,510 510,630 630,750 750,840
fault tolerant, how could we

1853
01:08:10,140 --> 01:08:11,120
0,90 90,390
do it?|
|

1854
01:08:13,110 --> 01:08:14,310
0,210 210,690 690,810 810,870 870,1200
{} Well, there are multiple
好的，有多种方法，但是，

1855
01:08:14,310 --> 01:08:16,720
0,420 420,720 720,1260
approaches, but, {}|
|

1856
01:08:17,170 --> 01:08:17,980
0,90 90,240 240,360 360,510 510,810
you can do it maybe
你可以通过 raft 来做这件事。

1857
01:08:17,980 --> 01:08:19,640
0,510 510,1050
through raft.|
|

1858
01:08:19,700 --> 01:08:22,190
0,360 1020,1530 2070,2190 2190,2310 2310,2490
{Yeah -}, you know run
是的，运行 raft

1859
01:08:22,190 --> 01:08:24,740
0,420 420,570 570,1110 1110,1650 1680,2550
raft| to basically basically run
|使协调者不是在一台机器上运行，

1860
01:08:24,740 --> 01:08:25,820
0,120 120,660 660,900 900,1020 1020,1080
the coordinator not on a

1861
01:08:25,820 --> 01:08:27,110
0,270 270,720 720,840 840,1140 1140,1290
single machine,| we basically have
|我们有一个复制状态机来实现协调者，

1862
01:08:27,110 --> 01:08:28,670
0,30 30,510 510,750 750,1140 1350,1560
a replicated state machine that

1863
01:08:28,670 --> 01:08:31,070
0,450 450,540 540,1290 1680,2280 2280,2400
implements the coordinator,| and you
|我们使用 raft

1864
01:08:31,070 --> 01:08:32,660
0,150 150,300 300,480 480,990 990,1590
know we use raft| to
|来保持复制的状态机

1865
01:08:33,080 --> 01:08:34,400
0,870
{sort,of}

1866
01:08:34,550 --> 01:08:36,140
0,270 270,360 360,780 780,990 990,1590
keep the replicated state machine|
|

1867
01:08:36,140 --> 01:08:38,090
0,210 240,420 420,780 780,1590 1590,1950
and {implement,the -} coordinator {}
实现协调者同步，

1868
01:08:38,090 --> 01:08:40,610
0,270 270,750 1110,1530 1530,2220 2220,2520
in sync,| {} and then
|然后，如果组成协调器的机器中的一台发生故障，

1869
01:08:40,610 --> 01:08:41,750
0,360 360,570 570,660 660,750 750,1140
if one of the machines

1870
01:08:41,750 --> 01:08:43,340
0,150 150,420 420,510 510,1080 1080,1590
that forms the coordinator fails,|
|

1871
01:08:43,340 --> 01:08:44,480
0,570 570,660 660,780 780,1050 1050,1140
hopefully the two others are
希望另外两个还在那里，

1872
01:08:44,480 --> 01:08:46,220
0,210 210,720 900,1350 1350,1590 1590,1740
still there,| and so we
|所以我们仍然可以继续，

1873
01:08:46,220 --> 01:08:48,200
0,120 120,300 300,750 1050,1500
can still proceed, right,|
|

1874
01:08:49,260 --> 01:08:51,720
0,480 480,990 1080,1290 1290,1740 1740,2460
and so it's potentially possible
所以有可能，

1875
01:08:51,900 --> 01:08:54,000
0,330 330,1020 1020,1110 1110,1410 1410,2100
to basically| you know replicate
|复制协调者，

1876
01:08:54,000 --> 01:08:55,200
0,60 60,570 570,750 750,1020 1020,1200
the coordinator| or actually any
|或者任何参与者使用 raft 。

1877
01:08:55,200 --> 01:08:56,700
0,120 120,210 210,780 780,1260 1290,1500
of the participants to {you,know}

1878
01:08:56,700 --> 01:08:58,040
0,270 270,840
using raft.|
|

1879
01:08:59,170 --> 01:09:00,740
0,150 150,300 300,420 420,1020
So let me actually,|
所以让我，|

1880
01:09:01,200 --> 01:09:02,640
0,330 750,930 930,1110 1110,1200 1200,1440
so {} {discuss -} this
所以让我来讨论一下，

1881
01:09:02,640 --> 01:09:03,600
0,30 30,210 210,480 480,660 660,960
a little bit and talk

1882
01:09:03,600 --> 01:09:06,560
0,60 60,240 240,540 540,960
a little bit more,|
|

1883
01:09:10,010 --> 01:09:10,970
0,60 60,270 270,330 330,690 690,960
a couple of discussion points,|
有几个讨论点，|

1884
01:09:10,970 --> 01:09:12,200
0,210 210,480 900,1020 1020,1140 1140,1230
which is you know we
我们可以使用 Raft ，

1885
01:09:12,200 --> 01:09:13,860
0,120 120,390 390,1140
could use Raft|
|

1886
01:09:17,480 --> 01:09:20,620
0,150 150,390 390,630 630,1530
to make a coordinator
使协调器容错或可用，

1887
01:09:20,620 --> 01:09:22,720
0,180 180,690 1290,1530 1530,2010 2010,2100
fault tolerant or available, if

1888
01:09:22,720 --> 01:09:23,740
0,90 90,450
you will,|
|

1889
01:09:24,480 --> 01:09:25,650
0,180 180,390 390,690 690,1050 1050,1170
it's really {} property we
这是我们关心的性质。

1890
01:09:25,650 --> 01:09:28,240
0,180 180,540
care about.|
|

1891
01:09:31,210 --> 01:09:32,700
0,330 330,420 420,540 540,900
Does that make sense?|
这能理解吗？|

1892
01:09:36,450 --> 01:09:37,710
0,150 150,540 540,690 690,810 810,1260
In fact, you will see,|
事实上，你会发现，|

1893
01:09:37,740 --> 01:09:38,700
0,480 480,660 660,780 780,900 900,960
{} if you do {lab
如果你做的是实验 4 而不是一个项目，

1894
01:09:38,700 --> 01:09:39,690
0,210 210,480 480,780 780,870 870,990
-} 4 instead of a

1895
01:09:39,690 --> 01:09:41,730
0,630 930,1140 1140,1350 1350,1440 1440,2040
project,| {} this is exactly
|这正是实验 4 要做的事情，

1896
01:09:41,730 --> 01:09:43,440
0,150 150,330 330,510 510,960 1290,1710
what lab 4 does,| lab
|实验 4 实际上也有类似的方案，

1897
01:09:43,440 --> 01:09:45,540
0,270 270,780 780,1410 1410,1680 1710,2100
4 actually has a similar

1898
01:09:45,540 --> 01:09:47,850
0,420 420,900 1170,1710 1710,2040 2040,2310
scheme,| where there's a form
|有一种形式的两阶段提交，

1899
01:09:47,850 --> 01:09:49,380
0,90 90,330 330,630 630,1200 1230,1530
of {2-phase -} {} commit,|
|

1900
01:09:49,380 --> 01:09:51,900
0,120 120,390 390,1200 1200,1470 1680,2520
that you implement and move
你实现，移动 master 分片或 master 协调者，

1901
01:09:51,900 --> 01:09:54,930
0,450 720,1020 1020,1470 1830,2640 2640,3030
the {} the master shard

1902
01:09:54,930 --> 01:09:57,390
0,210 210,630 630,1050 1050,2040 2220,2460
or the master coordinator,| and
|然后在分片服务器之间重新平衡，

1903
01:09:57,390 --> 01:10:00,930
0,210 210,900 900,1200 1200,1980 2070,3540
then rebalances shards across {}

1904
01:10:00,930 --> 01:10:03,480
0,270 270,780 1110,1650 1650,2070 2070,2550
shard servers,| uses Raft replicated
|使用 Raft 复制，

1905
01:10:03,480 --> 01:10:04,980
0,420 420,750 750,840 840,1110 1110,1500
{to,actually} {replicate,itself},| to shard servers
|分片服务器也使用 Raft 复制，

1906
01:10:04,980 --> 01:10:06,720
0,480 480,720 720,1230 1230,1530 1530,1740
itself, also replicated itself using

1907
01:10:06,720 --> 01:10:08,280
0,480 540,690 690,840 840,1050 1050,1560
Raft,| and so where many,
|所以，许多 Raft 组并行运行，

1908
01:10:08,280 --> 01:10:10,290
0,330 330,660 660,900 900,1380 1830,2010
many Raft groups running in

1909
01:10:10,290 --> 01:10:11,160
0,630
parallel,|
|

1910
01:10:12,220 --> 01:10:13,630
0,480 480,690 690,990 990,1290 1290,1410
and also the essence of
也是实验 4 的实质所在，

1911
01:10:13,630 --> 01:10:15,640
0,660 870,1470 1470,1650 1650,1860 1860,2010
{lab,4},| and so this is
|所以这就是通常的方式，

1912
01:10:15,640 --> 01:10:17,050
0,240 240,720 720,1110 1110,1260 1260,1410
like typically way,| you know
|如果你担心，

1913
01:10:17,050 --> 01:10:19,600
0,210 210,690 960,1650 1650,2190 2190,2550
if you're concerned about| having
|系统长时间阻塞，

1914
01:10:19,600 --> 01:10:21,250
0,600 630,990 990,1200 1200,1560 1560,1650
the system being blocked for

1915
01:10:21,250 --> 01:10:22,270
0,30 30,240 240,420 420,510 510,1020
a long period of time,|
|

1916
01:10:22,270 --> 01:10:23,050
0,270 270,390 390,480 480,660 660,780
one way to do it
一种方法是，

1917
01:10:23,050 --> 01:10:26,080
0,90 90,600 690,1050 1050,1470 1890,3030
is| basically make the coordinator
|使协调者容错。

1918
01:10:26,080 --> 01:10:27,100
0,150 150,630
fault tolerance.|
|

1919
01:10:29,540 --> 01:10:30,780
0,690

1920
01:10:31,460 --> 01:10:32,840
0,420 420,630 630,1050 1050,1290 1290,1380
So that [] brings me
所以[]让我想到了另一件事，

1921
01:10:32,840 --> 01:10:34,070
0,120 120,390 390,750 750,1020 1020,1230
to something else,| which a
|很多人问到，

1922
01:10:34,070 --> 01:10:35,630
0,150 150,210 210,450 450,870 900,1560
lot of people ask about,|
|

1923
01:10:35,870 --> 01:10:38,220
0,390 390,750 750,1500
{you,know} is Raft,
Raft 和两阶段提交是不是类似的东西，

1924
01:10:38,980 --> 01:10:40,540
0,210 210,690 690,1170 1170,1320 1320,1560
are Raft and {2-phase -}

1925
01:10:40,540 --> 01:10:42,960
0,390 390,510 510,930 930,1470
commits {sort,of} similar things,|
|

1926
01:10:46,000 --> 01:10:47,140
0,300 300,450 450,540 540,1020 1020,1140
or could you do {2-phase
或者你可以使用 Raft 做两阶段提交，

1927
01:10:47,140 --> 01:10:49,420
0,210 210,570 570,1050 1050,1710
-} {commit,with} raft| or
|或者你需要有一些并行，

1928
01:10:49,420 --> 01:10:51,370
0,390 1230,1620 1620,1710 1710,1890 1890,1950
you need to have a

1929
01:10:51,370 --> 01:10:52,450
0,150 150,300 300,390 390,600 600,1080
little bit of a parallel,

1930
01:10:52,450 --> 01:10:53,860
0,450 450,720 720,1170 1170,1320 1320,1410
correct,| like one thing is
|比如，一个东西叫做协调者， Raft 叫做领导者，

1931
01:10:53,860 --> 01:10:55,630
0,270 270,540 540,1170 1170,1380 1380,1770
called {} coordinator, {} raft

1932
01:10:55,630 --> 01:10:57,070
0,150 150,240 240,840 1110,1260 1260,1440
called the leader,| {} we
|我们有参与者，也许我们可以把这些当作跟随者，

1933
01:10:57,070 --> 01:10:59,950
0,840 1200,2190 2190,2280 2280,2370 2370,2880
gotta participants, you know maybe

1934
01:10:59,950 --> 01:11:00,790
0,180 180,300 300,630 630,720 720,840
we can figure out these

1935
01:11:00,790 --> 01:11:03,130
0,150 150,780 1140,1920 1920,2130 2130,2340
as followers,| { -} so
|所以似乎有一些相似之处，

1936
01:11:03,130 --> 01:11:04,240
0,180 180,480 510,810 810,930 930,1110
you know seems to have

1937
01:11:04,240 --> 01:11:05,410
0,90 90,810 810,930 930,1080 1080,1170
some similarities,| like how do
|我们怎么考虑它，

1938
01:11:05,410 --> 01:11:06,400
0,120 120,300 300,570 570,750 750,990
we think about it,| what's
|Raft 和 2PC 之间有什么关系？

1939
01:11:06,400 --> 01:11:08,620
0,90 90,720 720,1290 1410,2040 2040,2220
the relationship between Raft and

1940
01:11:08,620 --> 01:11:09,780
0,150 150,750
{2PC -}?|
|

1941
01:11:12,060 --> 01:11:13,620
0,300 300,720 720,900 900,1170 1170,1560
The difference is that, {}|
不同之处在于，|

1942
01:11:13,740 --> 01:11:16,170
0,810 1170,1350 1350,1830 1830,1980 1980,2430
{in,Raft} the coordinator can change
在 Raft 中，协调者可以改变，

1943
01:11:16,170 --> 01:11:18,960
0,660 900,1470 1800,2520 2520,2640 2640,2790
essentially,| {} otherwise it's like
|否则，它就是单点故障。

1944
01:11:18,960 --> 01:11:20,520
0,60 60,420 420,660 660,750 750,1560
the single point of failure.|
|

1945
01:11:20,670 --> 01:11:21,560
0,390
Yep,
是的，很好的观点，还有其他的吗？

1946
01:11:21,910 --> 01:11:23,700
0,240 240,600 630,1170
good point, any?|
|

1947
01:11:24,900 --> 01:11:26,220
0,390 390,570 570,870 870,1200 1200,1320
{} So another difference is
另一个不同之处是，

1948
01:11:26,220 --> 01:11:28,080
0,360 360,600 630,1050 1050,1530 1530,1860
that,| the Raft basically depends
|Raft 是基于多数的概念，

1949
01:11:28,080 --> 01:11:28,740
0,90 90,150 150,540 540,600 600,660
on the concept of a

1950
01:11:28,740 --> 01:11:29,880
0,420 420,720 720,810 810,930 930,1140
majority,| whereas in {2-phase -}
|而在两阶段提交协调者中，

1951
01:11:29,880 --> 01:11:31,140
0,300 300,810 810,990 990,1170 1170,1260
commit coordinator,| it needs to
|它需要从每个其他服务器获得响应，

1952
01:11:31,140 --> 01:11:32,160
0,150 150,210 210,540 540,780 780,1020
get a response from every

1953
01:11:32,160 --> 01:11:34,740
0,540 840,1530 1530,1830 1830,2370 2370,2580
single {} other server,| that
|所有涉及到的。

1954
01:11:34,740 --> 01:11:37,890
0,120 120,540 540,660 660,1230 2880,3150
is involved in the.| {Yeah\,,good}
|是的，很好的观点，

1955
01:11:37,890 --> 01:11:38,880
0,180 180,270 270,660 660,780 780,990
point,| so these are almost
|所以这些几乎就是关键的区别，

1956
01:11:38,910 --> 01:11:40,950
0,330 330,750 750,1320 1320,1590 1590,2040
like critical differences, right, {}|
|

1957
01:11:41,310 --> 01:11:42,720
0,540 540,660 660,780 780,930 930,1410
and you know we're wondering
我们在想，如果我们到了一个点，

1958
01:11:42,720 --> 01:11:43,920
0,210 210,600 600,810 810,1050 1050,1200
if we get to a

1959
01:11:43,920 --> 01:11:44,940
0,240 240,510 510,690 690,810 810,1020
point,| where like if there's
|比如，如果概念上的差异，

1960
01:11:44,940 --> 01:11:46,840
0,30 30,540 540,1020 1020,1320
a conceptual difference,| like
|它们是否解决了相同的问题？

1961
01:11:47,030 --> 01:11:48,080
0,330 330,450 450,750 750,810 810,1050
do they solve the same

1962
01:11:48,080 --> 01:11:49,180
0,510
problem?|
|

1963
01:11:49,730 --> 01:11:52,070
0,480 480,1110 1110,1530 1560,2250 2250,2340
Oh, {Raft,is} for replicating the
哦， Raft 是用来复制相同的东西，

1964
01:11:52,070 --> 01:11:54,080
0,360 360,750 1350,1560 1560,1800 1800,2010
same thing,| and {2-phase -
|两阶段提交是相反的，

1965
01:11:54,080 --> 01:11:55,760
0,270 270,630 630,810 810,1320 1470,1680
-} commit, when you do

1966
01:11:55,760 --> 01:11:57,560
0,120 120,570 570,750 750,1140 1470,1800
the opposite,| when you instead
|不是让一个东西传播到不同服务器上，

1967
01:11:57,560 --> 01:11:58,820
0,120 120,390 390,630 630,840 840,1260
of having one thing you

1968
01:11:58,850 --> 01:12:01,070
0,450 450,810 810,1140 1140,1920 1950,2220
spread across different servers,| then
|那你就得处理这个问题。

1969
01:12:01,070 --> 01:12:03,680
0,120 120,300 300,1950 1950,2130
you have to {deal,with,the,problem}.|
|

1970
01:12:03,680 --> 01:12:05,940
0,630 960,1710
Exactly, {}
没错，在 Raft 中，所有服务器都做同样的事情，

1971
01:12:06,060 --> 01:12:07,530
0,210 210,750 780,1020 1020,1350 1350,1470
in Raft, all servers do

1972
01:12:07,530 --> 01:12:08,780
0,90 90,330 330,660
the same thing,|
|

1973
01:12:13,880 --> 01:12:16,040
0,750 750,1170 1170,1410 1410,1680 1740,2160
implementing replicate state machine, right,|
实现复制状态机，|

1974
01:12:18,150 --> 01:12:20,880
0,720 750,1080 1080,1890 1980,2550 2550,2730
and {in,2PC -}, {actually -}
而在 2PC 中，所有服务器操作不同的数据，

1975
01:12:20,880 --> 01:12:22,650
0,450 450,720 720,870 870,1290 1320,1770
servers were all servers operate

1976
01:12:22,650 --> 01:12:24,020
0,90 90,390 390,810
on different data,|
|

1977
01:12:35,300 --> 01:12:37,430
0,270 300,870 900,1500 1500,1710 1710,2130
the first participant was actually
第一个参与者在 x 上操作，

1978
01:12:37,430 --> 01:12:39,050
0,660 660,840 840,1200 1200,1350 1350,1620
operating on x,| and second
|第二个参与者在 y 上操作，

1979
01:12:39,050 --> 01:12:41,260
0,510 510,780 780,1200 1200,1650
participate was operating {on,y},|
|

1980
01:12:41,380 --> 01:12:43,150
0,300 300,720 720,1230 1230,1680 1680,1770
so {in,2PC -}, really you
所以在 2PC 中，解决了一个与 Raft 完全不同的问题，

1981
01:12:43,150 --> 01:12:44,440
0,270 300,600 600,630 630,1020 1020,1290
know solve a completely different

1982
01:12:44,440 --> 01:12:46,030
0,420 420,570 570,1170 1170,1500 1500,1590
problem than Raft,| Raft is
|Raft 是关于高可用性，

1983
01:12:46,030 --> 01:12:48,130
0,270 270,450 450,900 930,1200 1200,2100
really all about high availability,|
|

1984
01:12:54,860 --> 01:12:57,110
0,660 900,1290 1290,1620 1620,2130 2130,2250
and {} {2PC -} is
2PC 是关于跨服务器的原子操作，

1985
01:12:57,110 --> 01:12:59,540
0,300 300,870 930,1560 1560,2100 2100,2430
really about atomic operations across

1986
01:12:59,540 --> 01:13:00,740
0,570
servers,|
|

1987
01:13:07,640 --> 01:13:09,350
0,810 810,1110 1110,1320 1320,1620 1620,1710
across data that's living on
跨位于不同服务器上的数据。

1988
01:13:09,350 --> 01:13:10,760
0,270 270,870
different servers.|
|

1989
01:13:10,760 --> 01:13:12,360
0,180 180,300 300,450 450,900
Does that make sense?|
这能理解吗？|

1990
01:13:13,700 --> 01:13:14,930
0,210 210,480 480,750 750,960 960,1230
So even though like maybe
所以，即使它们可能有一些内部技术看起来非常相似，

1991
01:13:14,930 --> 01:13:16,760
0,90 90,240 240,750 990,1440 1440,1830
they have some internal techniques

1992
01:13:16,760 --> 01:13:18,710
0,150 150,480 480,720 720,1380 1590,1950
that look very similar,| the
|这两个协议是为完全不同的问题而设计的，

1993
01:13:18,710 --> 01:13:20,930
0,480 480,1230 1230,1350 1350,1740 1740,2220
two protocols {you,knwo} are designed

1994
01:13:20,930 --> 01:13:23,000
0,210 210,660 660,930 930,1620
for completely different problems,|
|

1995
01:13:23,940 --> 01:13:25,140
0,120 120,300 300,690 690,1080 1080,1200
and not directly related,| now
没有直接的关系，|现在看起来很有趣，

1996
01:13:25,140 --> 01:13:26,190
0,150 150,450 450,540 540,750 750,1050
it's interesting to see, correct,|
|

1997
01:13:26,190 --> 01:13:27,090
0,210 390,570 570,690 690,840 840,900
but we could make {}
但我们可以做 Raft ，

1998
01:13:27,090 --> 01:13:28,530
0,570 810,930 930,1050 1050,1170 1170,1440
Raft,| we can use Raft
|我们可以使用 Raft 使协调者具有更强的容错性，

1999
01:13:28,530 --> 01:13:29,520
0,60 60,180 180,240 240,780 780,990
to make the coordinator more

2000
01:13:29,520 --> 01:13:31,230
0,210 210,600 600,660 660,1200 1200,1710
fault tolerant,| or participants made
|或者参与者更高的可用性，

2001
01:13:31,230 --> 01:13:33,750
0,660 660,960 960,1500 1770,2340 2340,2520
more highly available,| but they
|但它们本质上解决了不同的问题。

2002
01:13:33,750 --> 01:13:36,270
0,390 390,1110 1230,1650 1650,1890 1890,2520
basically essentially solve different problems.|
|

2003
01:13:43,860 --> 01:13:45,810
0,450 660,1170 1170,1440 1440,1710 1710,1950
{With,that}, {I,actually} wanted to end
说到这里，我想结束这节课，

2004
01:13:45,810 --> 01:13:48,060
0,150 150,660 690,1500 1500,1830 1830,2250
this lecture,| I'm happy to
|我很乐意回答更多的问题，

2005
01:13:48,060 --> 01:13:51,090
0,510 510,690 690,1380 1650,2910 2910,3030
entertain more questions,| hopefully this
|希望这对接下来的两篇论文有帮助，

2006
01:13:51,090 --> 01:13:52,350
0,210 210,510 510,1050 1050,1170 1170,1260
will very helpful in the

2007
01:13:52,350 --> 01:13:54,060
0,270 270,390 390,960 990,1170 1170,1710
next two papers,| so the
|所以接下来的两篇论文都是两个事务系统，

2008
01:13:54,090 --> 01:13:55,650
0,300 300,390 390,780 780,1080 1080,1560
next two papers are both

2009
01:13:55,650 --> 01:13:58,320
0,180 180,660 660,1350 1530,2040 2040,2670
two transaction systems,| {} one
|一个来自 Google ，

2010
01:13:58,320 --> 01:14:00,990
0,960 960,1170 1710,2040 2040,2130 2130,2670
{} and one from Google,|
|

2011
01:14:00,990 --> 01:14:02,400
0,90 90,270 270,360 360,780 780,1410
{one -} from Microsoft research,|
一个来自微软的研究，|

2012
01:14:02,700 --> 01:14:04,980
0,660 660,1350 1350,1650 1650,1860 1860,2280
{} and second one uses
第二个使用乐观事务，

2013
01:14:04,980 --> 01:14:07,890
0,630 630,1350 1650,2160 2160,2700 2700,2910
optimistic transactions,| {} and you'll
|当你读到这些论文的时候，你会发现，

2014
01:14:07,890 --> 01:14:08,700
0,270 270,420 420,510 510,660 660,810
see when you read these

2015
01:14:08,700 --> 01:14:09,840
0,390 390,540 540,630 630,1080 1080,1140
papers,| there's a lot of
|有很多机制，都是相当复杂的系统，

2016
01:14:09,840 --> 01:14:11,970
0,600 600,750 750,1140 1140,1530 1530,2130
machinery, are pretty complex systems,|
|

2017
01:14:12,210 --> 01:14:13,530
0,330 330,450 450,780 780,870 870,1320
{} but hopefully at least
但有希望的是，至少有一部分将被描述，

2018
01:14:13,530 --> 01:14:14,730
0,120 120,210 210,330 330,720 720,1200
some of the parts that

2019
01:14:14,730 --> 01:14:16,440
0,240 240,390 390,1050 1260,1410 1410,1710
will be described,| you will
|你现在就会明白，

2020
01:14:16,440 --> 01:14:17,550
0,180 180,690 690,870 870,960 960,1110
now understand,| because you know
|因为你知道什么是两阶段提交，

2021
01:14:17,550 --> 01:14:18,960
0,210 210,330 330,540 540,1170 1170,1410
what {2-phase -} {commit,is}| and
|而且你知道什么是两阶段锁。

2022
01:14:18,960 --> 01:14:19,590
0,90 90,180 180,360 360,420 420,630
you know what {two-phase -}

2023
01:14:19,590 --> 01:14:20,540
0,360
{locking,is}.|
|

2024
01:14:21,560 --> 01:14:23,810
0,330 330,420 420,750 1290,1860 1860,2250
Okay, with that, I'll end,|
好的，说到这里，我就结束了，|

2025
01:14:23,840 --> 01:14:26,540
0,840 1230,1710 1710,1950 1950,2010 2010,2700
and everybody needs to {go,can,go},|
每个需要离开的认就可以离开，|

2026
01:14:26,540 --> 01:14:27,830
0,420 420,810 810,1050 1050,1140 1140,1290
and anybody wants to ask
如果有人想问问题，

2027
01:14:27,830 --> 01:14:29,090
0,390 390,510 510,750 750,960 960,1260
questions,| {you,know} please feel free
|请自由提问。

2028
01:14:29,120 --> 01:14:30,280
0,120 120,270 270,630
to do so.|
|

2029
01:14:36,720 --> 01:14:38,040
0,360 360,570 570,1020 1020,1200 1200,1320
{} Sorry, this might be
抱歉，这个问题可能有点奇怪，

2030
01:14:38,040 --> 01:14:39,440
0,270 270,780
a little,

2031
01:14:39,440 --> 01:14:41,630
0,330 330,1170 1170,1560 1560,1920 1920,2190
{} a strange question,| but
|但对于两阶段锁来说，

2032
01:14:41,660 --> 01:14:44,240
0,330 330,510 510,1140 1140,1980 2370,2580
for {2-phase -} locking,| it
|它也是关于原子操作的，

2033
01:14:44,240 --> 01:14:46,730
0,210 210,630 630,1200 1230,1830 1830,2490
is also about atomic operations,|
|

2034
01:14:46,730 --> 01:14:48,620
0,300 330,930 930,1050 1050,1230 1230,1890
but there it is about
它是关于，不是跨服务器，而是在一台服务器，

2035
01:14:49,300 --> 01:14:52,090
0,840 870,1410 1740,2070 2070,2460 2460,2790
one, {} not across servers,

2036
01:14:52,090 --> 01:14:54,460
0,150 150,600 600,1020 1020,1830
but across one server,|
|

2037
01:14:54,580 --> 01:14:56,620
0,330 330,750 750,1080 1080,1470 1470,2040
{and,2-phase -} across multiple servers.|
两阶段是跨服务器的。|

2038
01:14:56,620 --> 01:14:58,600
0,570 570,930 930,1140 1140,1740 1740,1980
{Yeah\,,2-phase} locking is relevant too,
是的，如果你只有一台机器，两阶段锁也是有关的，

2039
01:14:58,600 --> 01:14:59,410
0,150 150,270 270,450 450,510 510,810
if you have a single

2040
01:14:59,410 --> 01:15:00,430
0,360 360,510 510,570 570,810 810,1020
machine,| like a {multi-core -}
|比如一台多核机器，

2041
01:15:00,430 --> 01:15:02,590
0,600 1050,1530 1530,1710 1710,2070 2070,2160
machine,| and you're implementing a
|你在一台多核机器上实现事务系统，

2042
01:15:02,590 --> 01:15:03,730
0,420 420,750 750,870 870,900 900,1140
transaction system on a {multi-core

2043
01:15:03,730 --> 01:15:05,470
0,210 210,840 1080,1470 1470,1590 1590,1740
-} machine,| {} you will
|你必须对事务中涉及的记录加锁，

2044
01:15:05,470 --> 01:15:06,370
0,150 150,270 270,660 660,720 720,900
have to lock you know

2045
01:15:06,370 --> 01:15:07,540
0,210 210,570 570,660 660,750 750,1170
the records that are involved

2046
01:15:07,540 --> 01:15:09,610
0,150 150,300 300,1050 1380,1770 1770,2070
in the transaction,| {} and
|对于这个，两阶段锁也是一个非常好的协议，

2047
01:15:09,610 --> 01:15:10,450
0,120 120,330 330,660 660,780 780,840
{2-phase -} locking is a

2048
01:15:10,450 --> 01:15:11,530
0,330 330,480 480,810 810,900 900,1080
perfectly good protocol for doing

2049
01:15:11,530 --> 01:15:12,260
0,300
so,|
|

2050
01:15:16,200 --> 01:15:17,190
0,300 300,450 450,630 630,900 900,990
where {2-phase -} commit is
而两阶段提交真正是关于分布式系统的。

2051
01:15:17,190 --> 01:15:18,540
0,240 240,420 420,510 510,810 810,1350
really about the distributed systems.|
|

2052
01:15:20,770 --> 01:15:21,910
0,270 270,480 480,570 570,810 810,1140
I guess my question was
我想我的问题是，两阶段锁，

2053
01:15:21,940 --> 01:15:23,740
0,390 390,600 600,1320
is {2-phase -}

2054
01:15:23,930 --> 01:15:25,910
0,180 180,480 480,1260 1650,1890 1890,1980
{2-phase -} locking,| can it
|它可能是两阶段提交的一部分吗？

2055
01:15:25,910 --> 01:15:27,860
0,420 480,900 900,1260 1320,1560 1560,1950
be part of {2-phase -}

2056
01:15:27,860 --> 01:15:29,180
0,780
commit?|
|

2057
01:15:30,140 --> 01:15:31,340
0,390 390,570 570,780 780,1080 1080,1200
{} I'm not sure I
我不确定那是什么意思，

2058
01:15:31,340 --> 01:15:33,020
0,120 120,270 270,420 420,930 1050,1680
know what that means, {}|
|

2059
01:15:33,020 --> 01:15:33,890
0,270 270,420 420,600 600,720 720,870
{} the way I think
我的想法是，

2060
01:15:33,890 --> 01:15:34,970
0,300 300,480 480,600 600,750 750,1080
about is that,| you solve
|你解决两个不同的问题。

2061
01:15:34,970 --> 01:15:36,540
0,120 120,390 390,1050
two different problems.|
|

2062
01:15:38,470 --> 01:15:40,570
0,630 990,1260 1260,1350 1350,1830 1830,2100
Okay.| It's the case that,|
好的。|事实是，|

2063
01:15:40,570 --> 01:15:41,980
0,150 150,300 300,630 630,1080 1080,1410
you know you you maybe
也许这就是你的意思，

2064
01:15:41,980 --> 01:15:42,670
0,120 120,180 180,330 330,390 390,690
this is what you mean,|
|

2065
01:15:42,910 --> 01:15:44,230
0,570 570,750 750,870 870,930 930,1320
{} it is a case
在这种情况下，有一个协调者，

2066
01:15:44,230 --> 01:15:45,400
0,210 210,540 540,630 630,810 810,1170
where that you know there's

2067
01:15:45,400 --> 01:15:49,240
0,360 420,1410 1710,2610 2610,3060 3570,3840
a coordinator,| {} or as
|或者作为初始设置的一部分，

2068
01:15:49,240 --> 01:15:50,710
0,240 240,480 480,630 630,1080 1080,1470
part of the initial setup,|
|

2069
01:15:50,710 --> 01:15:51,790
0,330 330,420 420,720 720,960 960,1080
when the initial puts are
当初始 put 通过事务完成时，

2070
01:15:51,790 --> 01:15:54,010
0,270 270,450 450,540 540,1170 1470,2220
done by the transaction,| the
|这个事务遵循两阶段锁，

2071
01:15:54,010 --> 01:15:55,180
0,180 180,600 600,750 750,1020 1020,1170
that transaction will follow {2-phase

2072
01:15:55,180 --> 01:15:56,320
0,210 210,690
-} locking,|
|

2073
01:15:57,080 --> 01:15:58,400
0,360 360,510 510,810 810,960 960,1320
here to lock on {}
这里需要获取 x 的锁，需要获取 B 的锁，

2074
01:15:58,400 --> 01:15:59,810
0,390 390,930 930,1050 1050,1260 1260,1410
x required, to lock on

2075
01:15:59,810 --> 01:16:01,340
0,270 270,930
B required,|
|

2076
01:16:01,880 --> 01:16:03,950
0,600 600,1050 1200,1440 1440,1680 1680,2070
{} so the lock y
需要获取 y 的锁，

2077
01:16:03,950 --> 01:16:05,510
0,90 90,690 690,900 900,1200 1200,1560
is required,| and so does
|事务做这个是使用两阶段锁的方式，

2078
01:16:05,540 --> 01:16:06,710
0,180 180,600 600,810 810,1050 1050,1170
the transaction does that in

2079
01:16:06,710 --> 01:16:07,880
0,120 120,270 270,510 510,780 780,1170
the {2-phase -} locking style,|
|

2080
01:16:08,000 --> 01:16:08,960
0,150 150,360 360,450 450,720 720,960
it could have done using
它也可以使用严格锁，

2081
01:16:08,960 --> 01:16:10,370
0,330 330,660 660,930 930,1260 1260,1410
strict locking too,| but you
|但是从两阶段提交的角度来看，

2082
01:16:10,370 --> 01:16:11,120
0,210
know

2083
01:16:11,210 --> 01:16:12,920
0,540 660,1200 1200,1380 1380,1530 1530,1710
{} from the {2-phase -}

2084
01:16:12,920 --> 01:16:14,420
0,240 240,390 390,450 450,900 1350,1500
commit point of view,| it
|这不重要，

2085
01:16:14,420 --> 01:16:15,620
0,180 180,330 330,870 870,1020 1020,1200
doesn't really matter,| at some
|在某一点上，事务将要执行，

2086
01:16:15,620 --> 01:16:17,420
0,390 390,510 510,630 630,930 1290,1800
point, you know the transaction

2087
01:16:17,420 --> 01:16:18,710
0,120 120,450 450,510 510,600 600,1290
is [] to be executed|
|

2088
01:16:19,070 --> 01:16:20,030
0,300 300,390 390,510 510,720 720,960
and the {2-phase -} commit
两阶段提交是为了达成协议，

2089
01:16:20,030 --> 01:16:22,640
0,90 90,390 390,900 1200,1920 1920,2610
is really about reaching agreement,|
|

2090
01:16:22,940 --> 01:16:25,250
0,420 420,1350 1350,1530 1530,1950 1950,2310
{} that all parties agreed
所有各方都同意继续。

2091
01:16:25,250 --> 01:16:26,380
0,60 60,240 240,660
to go along.|
|

2092
01:16:28,350 --> 01:16:29,640
0,390 390,480 480,690 690,990 990,1290
Yeah, that makes sense, thank
好的，理解了，谢谢。

2093
01:16:29,640 --> 01:16:31,650
0,420 600,810 810,1170 1650,1830 1830,2010
you.| You're welcome.| Is {2-phase
|不用谢。|两阶段提交是专门用于分片数据吗？

2094
01:16:31,650 --> 01:16:34,020
0,300 300,600 600,1290 1290,1920 1950,2370
-} commit exclusively for {like,sharded}

2095
01:16:34,020 --> 01:16:37,770
0,540 1080,1950 1950,2490 2490,2850 2850,3750
data?| No, {} actually it
|不，事实上它来自，

2096
01:16:37,770 --> 01:16:41,430
0,450 450,990 1380,2490 2580,2940 2940,3660
came out,| well, oh, yes
|好吧，是或不是，

2097
01:16:41,430 --> 01:16:44,040
0,60 60,420 720,1380 1710,1980 1980,2610
or no,| {} the original
|最初的两阶段提交来自这种情况，

2098
01:16:44,040 --> 01:16:45,240
0,150 150,360 360,690 690,930 930,1200
sort of 2-phase commit came

2099
01:16:45,240 --> 01:16:47,550
0,240 240,360 360,1050 1260,1680 1680,2310
out of the case,| where
|比如你有不同的机构，

2100
01:16:47,700 --> 01:16:49,620
0,660 660,720 720,810 810,1080 1080,1920
like you have different organizations,|
|

2101
01:16:49,620 --> 01:16:50,520
0,210 210,420 420,600 600,660 660,900
and they need to agree
它们需要同意做一些事情，

2102
01:16:50,520 --> 01:16:51,420
0,90 90,240 240,630 630,840 840,900
to do something,| like you
|比如你在旅游网站上预定，

2103
01:16:51,420 --> 01:16:53,640
0,150 150,360 360,540 540,900 1230,2220
know you book { -}

2104
01:16:53,640 --> 01:16:55,950
0,240 420,1050 1050,1410 1410,1770 1770,2310
on {} a travel website,|
|

2105
01:16:55,950 --> 01:16:57,120
0,90 90,270 270,510 510,750 750,1170
you know you book a
你预定一趟旅行，

2106
01:16:57,120 --> 01:16:58,890
0,570 570,870 870,1230 1230,1440 1440,1770
trip,| and another thing you
|还有一件事，你订了酒店，

2107
01:16:58,890 --> 01:17:01,050
0,240 240,270 270,990 1290,1860 1860,2160
book a hotel,| and you
|你想提交整个旅行，

2108
01:17:01,050 --> 01:17:02,910
0,210 210,570 960,1440 1440,1770 1770,1860
want to commit to the

2109
01:17:02,910 --> 01:17:04,320
0,150 150,510 510,900 900,1020 1020,1410
whole trip,| if you both
|如果酒店网站和旅游网站都同意，

2110
01:17:04,320 --> 01:17:08,100
0,930 960,1770 1770,2490 2820,3120 3120,3780
hotel website and { -}

2111
01:17:08,310 --> 01:17:11,340
0,930 1110,1740 1770,2160 2160,2610 2610,3030
{} the travel website {}

2112
01:17:11,370 --> 01:17:12,600
0,390 390,510 510,660 660,1050 1050,1230
agreed to go along, {}|
|

2113
01:17:12,900 --> 01:17:14,010
0,240 240,480 480,540 540,630 630,1110
{sort,of} committed to the transaction|
那么提交这个事务，|

2114
01:17:14,610 --> 01:17:16,140
0,750 750,900 900,1050 1050,1140 1140,1530
and that sort of deciding
这决定，

2115
01:17:16,140 --> 01:17:18,150
0,570 1020,1230 1230,1290 1290,1590 1590,2010
where sort of this deciding

2116
01:17:18,150 --> 01:17:19,350
0,360 360,570 570,720 720,840 840,1200
where,| came up which really
|来自不同的机构，

2117
01:17:19,350 --> 01:17:19,950
0,60 60,180 180,270 270,360 360,600
you know you have different

2118
01:17:19,950 --> 01:17:21,720
0,990 1200,1380 1380,1530 1530,1680 1680,1770
organizations,| {} they need to
|它们需要提交一个特定的操作，

2119
01:17:21,720 --> 01:17:22,460
0,420
commit

2120
01:17:22,460 --> 01:17:26,690
0,240 240,330 330,1830 1830,3210 3660,4230
to a particular operation, {}|
|

2121
01:17:26,690 --> 01:17:28,490
0,660 900,1170 1170,1290 1290,1380 1380,1800
and {} for the reasons
出于这样的原因，

2122
01:17:28,490 --> 01:17:30,830
0,450 510,720 720,1410 1680,2070 2070,2340
that,| {} that that setting
|人们并不想使用两阶段提交，

2123
01:17:30,830 --> 01:17:33,380
0,600 1200,2010 2010,2220 2220,2370 2370,2550
actually basically people don't really

2124
01:17:33,380 --> 01:17:34,160
0,150 150,210 210,450 450,570 570,780
want to use {2-phase -}

2125
01:17:34,160 --> 01:17:36,560
0,330 780,1710 1710,1890 1890,2040 2040,2400
commit,| because that would mean
|因为这就意味着，

2126
01:17:36,560 --> 01:17:39,200
0,390 720,1230 1230,1530 1530,1860 1860,2640
that,| {} the travel agency
|旅行社网站依赖于酒店预订网站，

2127
01:17:39,200 --> 01:17:41,480
0,450 450,540 540,1260 1260,1740 1740,2280
website is dependent on the

2128
01:17:41,480 --> 01:17:44,030
0,450 450,900 900,1500 1500,1890 2190,2550
hotel reservation websites,| and these
|它们来自不同的机构，

2129
01:17:44,030 --> 01:17:45,860
0,120 120,240 240,720 720,1530 1530,1830
are from different organizations,| and
|机构并不彼此信任，

2130
01:17:45,860 --> 01:17:46,580
0,90 90,180 180,450 450,540 540,720
you know people who know

2131
01:17:46,580 --> 01:17:47,690
0,120 120,540 540,690 690,840 840,1110
the organization don't really trust

2132
01:17:47,690 --> 01:17:50,150
0,120 120,510 720,1740 1950,2100 2100,2460
each other,| and if one
|如果其中一个停机了，

2133
01:17:50,150 --> 01:17:51,500
0,180 180,540 540,810 810,1050 1050,1350
goes down,| then there's actually
|然后就不能继续了，这看起来很糟糕，

2134
01:17:51,500 --> 01:17:53,360
0,270 270,810 810,1230 1470,1680 1680,1860
can't proceed and that seems

2135
01:17:53,360 --> 01:17:54,890
0,120 120,570 1020,1230 1230,1440 1440,1530
all bad,| {} so, in
|所以，两阶段提交有点负面名声，

2136
01:17:54,890 --> 01:17:55,970
0,420 420,570 570,750 750,990 990,1080
fact, {2-phase -} commit have

2137
01:17:55,970 --> 01:17:57,620
0,870 870,1050 1050,1110 1110,1170 1170,1650
a bit of a negative

2138
01:17:57,620 --> 01:17:58,860
0,870
reputation,|
|

2139
01:17:58,860 --> 01:18:00,840
0,720 720,1140 1140,1560 1560,1650 1650,1980
{} because really you know,|
因为你知道，|

2140
01:18:01,980 --> 01:18:03,480
0,210 210,300 300,570 570,1170 1170,1500
one of the original goals
两阶段提交的最初目标之一是解决这个问题，

2141
01:18:03,480 --> 01:18:04,440
0,60 60,420 420,660 660,750 750,960
of 2-phase commit to solve

2142
01:18:04,440 --> 01:18:05,580
0,120 120,390 390,600 600,930 930,1140
that problem,| that problem here,
|这里的问题，人们不希望使用两阶段提交来解决，

2143
01:18:05,580 --> 01:18:06,510
0,330 330,540 540,720 720,870 870,930
people don't really want to

2144
01:18:06,510 --> 01:18:07,350
0,240 240,330 330,420 420,630 630,840
solve with {2-phase -} commit,|
|

2145
01:18:07,860 --> 01:18:09,810
0,720 750,870 870,960 960,1410 1410,1950
however in the context where
然而，在拥有数据中心的环境中，

2146
01:18:09,810 --> 01:18:10,770
0,210 210,300 300,330 330,600 600,960
you have a data center,|
|

2147
01:18:10,770 --> 01:18:12,180
0,120 120,180 180,480 480,1290 1290,1410
it's a single organization and
是一个单一的机构，数据库是分片的，

2148
01:18:12,180 --> 01:18:14,130
0,60 60,600 600,1200 1410,1710 1710,1950
the databases sharded,| {2-phase -}
|两阶段提交是广泛流行和典型使用。

2149
01:18:14,130 --> 01:18:16,000
0,300 300,420 420,930 930,1440
commit is widely popular

2150
01:18:16,180 --> 01:18:18,120
0,660 660,960 960,1440
and typical use.|
|

2151
01:18:21,000 --> 01:18:23,130
0,420 420,660 660,900 1410,1710 1710,2130
Awesome, thank you.| You're welcome.|
太棒了，谢谢。|不用谢。|

2152
01:18:24,210 --> 01:18:25,260
0,240 240,360 360,510 510,900 900,1050
Could you go back to
你能回到第一个失败的情况吗，

2153
01:18:25,260 --> 01:18:26,910
0,210 210,630 630,990 990,1500 1500,1650
the first failure case,| that
|我们谈到的两阶段提交，

2154
01:18:26,910 --> 01:18:28,200
0,120 120,360 360,570 570,720 720,1290
we talked about with {2-phase,commit

2155
01:18:28,200 --> 01:18:30,930
0,300 300,1140 1170,1500 1500,2430 2460,2730
-},| where it fails, B
|B 在回复 prepare ok 之后崩溃，

2156
01:18:30,930 --> 01:18:33,960
0,360 360,1200 1410,1980 1980,2460 2460,3030
fails after responding prepare ok.|
|

2157
01:18:34,140 --> 01:18:36,160
0,450 480,930 930,1200 1200,1560
Yeah, is this one?|
好的，是这个吗？|

2158
01:18:36,250 --> 01:18:39,220
0,1110 1140,1830 1860,2010 2010,2520
{} Yeah, I guess.|
是的，我想是的。|

2159
01:18:39,560 --> 01:18:40,970
0,120 120,780 780,1080 1080,1260 1260,1410
I talked twice about this
关于这个情况我谈了两次，但是。

2160
01:18:40,970 --> 01:18:43,130
0,300 300,540 540,720 720,2010 2010,2160
case, but like.| Yeah, I
|是的，我想我想知道，

2161
01:18:43,130 --> 01:18:45,740
0,390 390,990 990,1170 1170,2100
guess I was wondering,|
|

2162
01:18:45,740 --> 01:18:48,530
0,1110 1320,1620 1620,1890 1890,1980 1980,2790
why B needs to persist|
为什么 B 需要持久化，|

2163
01:18:48,530 --> 01:18:49,580
0,120 120,330 330,690 690,960 960,1050
or like why needs to
或者为什么需要记住它收到了 prepare ，

2164
01:18:49,580 --> 01:18:52,910
0,720 720,1170 1170,1530 1620,2460 2460,3330
remember that it received prepare,|
|

2165
01:18:53,450 --> 01:18:54,920
0,450 450,600 600,840 840,1110 1110,1470
{} I guess my thinking
我想我的想法是，

2166
01:18:54,920 --> 01:18:56,200
0,780
was,|
|

2167
01:18:56,260 --> 01:18:57,670
0,270 270,390 390,660 660,960 960,1410
when it comes back up,|
当它恢复时，|

2168
01:18:58,060 --> 01:19:00,130
0,210 210,390 390,1230 1260,1530 1530,2070
if it receives A commit
如果它从协调者接收到 commit 消息，

2169
01:19:00,130 --> 01:19:01,690
0,390 390,570 570,690 690,1230 1230,1560
message from the coordinator,| couldn't
|它就不能假设它已经准备好了吗，

2170
01:19:01,690 --> 01:19:03,670
0,180 180,540 540,1080 1080,1500 1770,1980
it just assumed that it

2171
01:19:03,670 --> 01:19:05,170
0,240 240,840 840,900 900,1170 1170,1500
was prepared,| I guess where
|我想它在哪里使用那个信息。

2172
01:19:05,170 --> 01:19:06,400
0,150 150,270 270,450 450,600 600,1230
does it use that information.|
|

2173
01:19:06,790 --> 01:19:08,920
0,1200 1200,1680 1680,1800 1800,1950 1950,2130
Yeah, well, it could have
是的，它可能在崩溃前中止，

2174
01:19:08,920 --> 01:19:10,210
0,270 270,570 660,930 930,1230 1230,1290
{abort -} right before the

2175
01:19:10,210 --> 01:19:11,260
0,630
crash,|
|

2176
01:19:12,030 --> 01:19:12,990
0,180 180,420 420,570 570,660 660,960
and B needs to remember
B 需要记住它做了什么。

2177
01:19:12,990 --> 01:19:14,220
0,150 150,240 240,660
what it did.|
|

2178
01:19:14,430 --> 01:19:15,660
0,930
Okay.|
好的。|

2179
01:19:15,690 --> 01:19:17,520
0,210 210,390 390,750 750,1140 1140,1830
So there's another slight variation
这个方案还有另一个细微的变化，

2180
01:19:17,520 --> 01:19:19,440
0,120 120,270 270,780 780,1260 1410,1920
with this protocol,| where where
|当你假设你总是提交，

2181
01:19:19,440 --> 01:19:20,880
0,90 90,780 810,1050 1050,1200 1200,1440
you assume that you always

2182
01:19:20,880 --> 01:19:23,580
0,780 780,1020 1020,1410 1410,1830 2400,2700
commit,| so presume commit {}
|假设提交，其中一条消息略有不同，

2183
01:19:23,580 --> 01:19:24,660
0,210 210,270 270,360 360,720 720,1080
one of the messages slightly

2184
01:19:24,660 --> 01:19:26,310
0,450 540,990 990,1380 1380,1500 1500,1650
different,| {} and you know
|你可以考虑一个优化方案，

2185
01:19:26,310 --> 01:19:27,420
0,180 180,240 240,840 840,960 960,1110
there's an optimization that you

2186
01:19:27,420 --> 01:19:30,000
0,180 180,810 1140,1860 1860,2310 2310,2580
could consider,| {} and would
|在某些情况下也是有意义的，

2187
01:19:30,000 --> 01:19:31,260
0,180 180,420 420,480 480,660 660,1260
make sense in some settings,|
|

2188
01:19:31,940 --> 01:19:33,740
0,570 840,1110 1110,1380 1380,1620 1620,1800
{} I I didn't really
我并没有真的谈到那个特定的协议，

2189
01:19:33,740 --> 01:19:35,000
0,210 210,360 360,510 510,900 900,1260
talk about that particular protocol,|
|

2190
01:19:35,000 --> 01:19:35,990
0,150 150,270 270,330 330,600 600,990
but just a slight different,|
但只是略有不同，|

2191
01:19:35,990 --> 01:19:37,010
0,60 60,210 210,360 360,450 450,1020
you know sort of variation,|
一种变体，|

2192
01:19:37,010 --> 01:19:37,700
0,150 150,390 390,420 420,630 630,690
there's quite a number of
两阶段提交有相当多的变体，

2193
01:19:37,700 --> 01:19:38,990
0,570 570,720 720,840 840,1050 1050,1290
variations for {2-phase -} commit,|
|

2194
01:19:39,880 --> 01:19:41,530
0,300 300,540 750,1200 1200,1320 1320,1650
{} they change in minor
它们会有一些微小的变化。

2195
01:19:41,530 --> 01:19:42,520
0,510
ways.|
|

2196
01:19:43,120 --> 01:19:44,400
0,240 240,420 420,780

2197
01:19:45,190 --> 01:19:46,930
0,180 180,570 840,1260 1290,1500 1500,1740
Make sense?| Yep, thank you.|
理解了吗?|是的，谢谢。|

2198
01:19:54,270 --> 01:19:55,820
0,300 300,420 420,540 540,990
{Is,that} it for today?|
今天就这些吗？|

2199
01:19:57,430 --> 01:19:58,630
0,480 480,600 600,810 810,930 930,1200
Sorry, you said that it
抱歉，你说它可以，

2200
01:19:58,630 --> 01:20:00,820
0,480 510,660 660,840 840,1290 1320,2190
can,| it could have aborted
|它可以中止事务，

2201
01:20:00,820 --> 01:20:03,370
0,360 720,1590 1590,2010 2220,2430 2430,2550
the transaction,| but if it
|但如果它这样做，它将永远不会收到提交。

2202
01:20:03,370 --> 01:20:04,570
0,300 300,420 420,540 540,780 780,1200
did, that it will never

2203
01:20:04,570 --> 01:20:06,700
0,420 420,690 840,1620
receive the commit.|
|

2204
01:20:07,380 --> 01:20:08,700
0,270 270,480 480,900 900,1260 1260,1320
You mean in response to
你的意思是回应最后一个问题？

2205
01:20:08,700 --> 01:20:11,430
0,60 60,270 270,690 870,2610 2610,2730
the last question?| Yeah.| You
|是的。|这个问题是，

2206
01:20:11,430 --> 01:20:12,540
0,150 150,600 600,660 660,960 960,1110
know the the question was,|
|

2207
01:20:12,540 --> 01:20:14,100
0,180 180,510 510,960 960,1380 1380,1560
like why does B have
为什么 B 必须记录到稳定存储，

2208
01:20:14,100 --> 01:20:15,870
0,90 90,930 930,1260 1260,1620 1620,1770
to {record,on} stable storage,| what
|决定要做什么。

2209
01:20:15,870 --> 01:20:17,280
0,510 510,570 570,900
decided to do.|
|

2210
01:20:17,580 --> 01:20:19,530
0,900 930,1320 1320,1500 1500,1830 1830,1950
And {} the injury is
问题是，当 B 出现时，

2211
01:20:19,530 --> 01:20:21,330
0,510 510,1020 1020,1440 1440,1590 1590,1800
that {} when B comes

2212
01:20:21,330 --> 01:20:22,350
0,270 270,360 360,690 690,780 780,1020
up,| it knows it needs
|它需要知道是否同意提交，

2213
01:20:22,350 --> 01:20:23,700
0,60 60,210 210,570 570,810 810,1350
to know whether actually commit,

2214
01:20:23,700 --> 01:20:25,020
0,240 240,330 330,660 690,1140 1140,1320
agreed to commit,| or going
|或者同意中止，

2215
01:20:25,020 --> 01:20:26,420
0,60 60,270 270,360 360,780
to agree to abort,|
|

2216
01:20:26,760 --> 01:20:28,380
0,690 690,1110 1110,1230 1230,1440 1440,1620
{} and it doesn't write
它没有写任何东西，它不知道同意什么。

2217
01:20:28,380 --> 01:20:29,920
0,330 330,420 420,600 600,990
anything, it doesn't know

2218
01:20:30,160 --> 01:20:31,720
0,120 120,300 300,930
to what agree.|
|

2219
01:20:35,030 --> 01:20:35,600
0,180 180,270 270,360 360,450 450,570
Because it could have been
因为它可能中止，之后。

2220
01:20:35,600 --> 01:20:37,780
0,330 330,1200 1230,1830
abort, after.| Yep.|
|是的。|

2221
01:20:37,810 --> 01:20:39,120
0,1020
Yeah.|
好的。|

2222
01:20:40,540 --> 01:20:41,710
0,240 240,390 390,780 780,900 900,1170
{} I {need,to} know that,|
我需要知道，|

2223
01:20:41,710 --> 01:20:42,940
0,420 450,810 810,960 960,1050 1050,1230
you know what to do
在恢复阶段做什么。

2224
01:20:42,940 --> 01:20:44,080
0,180 180,270 270,810 810,1140 1140,1140
in the recovery stage, I

2225
01:20:44,080 --> 01:20:45,960
0,480 780,1320
see.| {Yes\,,exactly}.|
|是的，没错。|

2226
01:20:52,260 --> 01:20:53,490
0,150 150,480 480,720 720,840 840,1230
It also needs to record
它还需要记录它所做的事情，

2227
01:20:53,490 --> 01:20:55,140
0,150 150,390 390,840 840,1170 1170,1650
what it does,| because if
|因为如果它中止，

2228
01:20:55,700 --> 01:20:57,080
0,210 210,420 420,420 420,1200 1230,1380
it like {aborts -},| but
|但消息永远不会到达协调者，

2229
01:20:57,080 --> 01:20:58,160
0,90 90,510 510,690 690,960 960,1080
the message never gets to

2230
01:20:58,160 --> 01:21:00,590
0,90 90,780 810,1200 1200,1560 1920,2430
the coordinator,| needs to {}
|需要重新发送相同的消息。

2231
01:21:00,620 --> 01:21:02,090
0,210 210,540 540,630 630,900 900,1470
{resend -} the same message,

2232
01:21:02,120 --> 01:21:03,950
0,300 300,690 780,1200 1200,1320 1320,1830
right.| Yeah, well, it need
|是的，它需要记录中止那个事务 ID ，

2233
01:21:03,950 --> 01:21:05,210
0,90 90,450 450,630 630,930 930,1260
to record that actually abort

2234
01:21:05,210 --> 01:21:06,380
0,180 180,600 600,870 870,990 990,1170
that transaction ID,| so when
|所以当协调者问起你做了什么，

2235
01:21:06,380 --> 01:21:08,120
0,90 90,360 360,870 870,1350 1560,1740
the {} coordinator asks {you,know}

2236
01:21:08,120 --> 01:21:09,620
0,180 180,300 300,390 390,870 1110,1500
what did you do,| that
|它回复一个 no 。

2237
01:21:09,620 --> 01:21:10,820
0,240 240,630 630,780 780,810 810,1200
actually responds with a no.|
|

2238
01:21:11,940 --> 01:21:13,440
0,390 390,630 630,930
{Got,it}, thank you.|
明白了，谢谢。|

2239
01:21:17,530 --> 01:21:18,760
0,270 270,720
Thank you.|
谢谢。|

2240
01:21:18,910 --> 01:21:19,980
0,510
{You're,welcome}.|
不用谢。|

2241
01:21:20,790 --> 01:21:22,300
0,420 420,930
Thank you.|
谢谢。|

2242
01:21:24,010 --> 01:21:25,180
0,300 300,420 420,540 540,990 990,1170
Alright, see you all next
好的，下周见。

2243
01:21:25,180 --> 01:21:26,100
0,360
week.
