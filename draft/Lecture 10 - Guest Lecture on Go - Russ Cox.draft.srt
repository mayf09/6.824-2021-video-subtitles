1
00:00:00,300 --> 00:00:03,900
0,1110 1110,1680 2250,2580 2580,3060 3150,3600
{Okay\,,good} afternoon, good morning, good
好的，下午好，早上好，傍晚好，晚上好，无论你在哪里。

2
00:00:03,900 --> 00:00:05,520
0,360 360,840 840,1170 1170,1290 1290,1620
evening, {good,night}, wherever you are.|
|

3
00:00:06,000 --> 00:00:08,820
0,720 720,840 840,1140 1140,1530 1800,2820
Let's get started again {}.|
让我们重新开始吧。|

4
00:00:08,820 --> 00:00:10,260
0,360 360,780 900,1230 1230,1350 1350,1440
So, {} today we have
所以，今天我们有一个嘉宾课程，

5
00:00:10,260 --> 00:00:12,660
0,30 30,270 270,720 1410,1890 1890,2400
a guest lecture,| probably speaker
|可能演讲者需要一些介绍，

6
00:00:12,660 --> 00:00:16,350
0,360 360,600 600,1290 2760,3150 3150,3690
needs {a,little} introduction,| Russ Cox,
|Russ Cox 是 Go 项目的联合负责人之一，

7
00:00:16,680 --> 00:00:18,030
0,150 150,300 300,390 390,720 990,1350
is one of the {co-leads

8
00:00:18,030 --> 00:00:20,640
0,270 270,390 390,690 690,1800 1890,2610
-} on the Go project,|
|

9
00:00:20,640 --> 00:00:21,840
0,270 270,780 780,1020 1020,1050 1050,1200
and we'll talk a lot
我们会更多地讨论这个问题。

10
00:00:21,840 --> 00:00:23,490
0,180 180,420 420,600 870,1530 1530,1650
more about it.| Let me
|让我说几句话，

11
00:00:23,490 --> 00:00:25,140
0,150 150,210 210,480 480,930 960,1650
say a couple words, {}|
|

12
00:00:26,220 --> 00:00:27,750
0,630 630,810 810,900 900,1290 1290,1530
not trying to embarrass Russ
不让 Russ 太尴尬，

13
00:00:27,750 --> 00:00:29,940
0,120 120,570 600,1500 1530,1950 1950,2190
too much,| {} {Russ,has,a} long
|Russ 在分布式系统方面有着长期的经验，

14
00:00:29,940 --> 00:00:33,180
0,450 450,810 810,1260 1260,1920 2730,3240
experience with distributed systems,| he
|他是一个 Plan 9 的开发者和贡献者，

15
00:00:33,180 --> 00:00:35,460
0,210 210,720 750,1380 1380,1740 1770,2280
was a developer and contributor

16
00:00:35,460 --> 00:00:37,500
0,390 390,900 930,1200 1200,1740 1770,2040
to {} {Plan,9 -} {},|
|

17
00:00:37,500 --> 00:00:38,310
0,180 180,300 300,450 450,630 630,810
when he was a high
当他是哈佛大学的本科生时，

18
00:00:38,310 --> 00:00:40,320
0,270 270,600 600,1440 1440,1560 1560,2010
school student undergrad at Harvard,|
|

19
00:00:41,040 --> 00:00:43,080
0,300 300,660 660,1290 1320,1650 1650,2040
he joined the PHD program
他参加了麻省理工学院的博士项目，

20
00:00:43,080 --> 00:00:45,660
0,60 60,690 1830,2280 2280,2400 2400,2580
at MIT,| {which,where} we met
|我们在那里认识的，

21
00:00:45,660 --> 00:00:47,730
0,300 750,1350 1350,1830 1830,1950 1950,2070
up,| and probably if you've
|如果你上过任何形式的 PDOS 课程，

22
00:00:47,730 --> 00:00:49,440
0,270 270,720 720,960 960,1290 1530,1710
taken any sort of {PDOS

23
00:00:49,440 --> 00:00:50,880
0,300 300,720 720,840 840,960 960,1440
-} class, if you will,|
|

24
00:00:51,060 --> 00:00:52,680
0,450 450,780 780,930 930,1200 1200,1620
{} there's gonna be, {}|
那里会有，|

25
00:00:52,710 --> 00:00:54,690
0,150 150,270 270,870 900,1380 1380,1980
you will see Russ's touches
你会看到 Russ 在上面的[工作]，

26
00:00:54,690 --> 00:00:57,060
0,270 270,480 1110,1800 1830,2280 2280,2370
on it,| and certainly in
|当然，在 6.824 上，

27
00:00:57,060 --> 00:00:58,650
0,90 90,240 240,810 840,1470 1470,1590
{6.824 - -},| {} you
|对我们来说，切换到 Go 是一件很棒的事情，

28
00:00:58,650 --> 00:01:00,660
0,180 180,690 1170,1950
know the Go,

29
00:01:00,720 --> 00:01:01,770
0,330 330,420 420,720 720,900 900,1050
switch to Go for us

30
00:01:01,770 --> 00:01:03,390
0,180 180,420 420,750 750,1230 1230,1620
has been a wonderful thing,|
|

31
00:01:03,390 --> 00:01:05,880
0,750 1140,1710 1710,1890 1890,2010 2010,2490
and {} but if you
但如果你有不同的意见，

32
00:01:05,910 --> 00:01:07,950
0,450 450,690 690,1260 1320,1590 1590,2040
differ in opinion,| of course
|当然可以向 Russ 提问并提出建议，

33
00:01:07,980 --> 00:01:09,630
0,300 300,480 480,630 630,1140 1140,1650
feel free to {ask,Russ} questions

34
00:01:09,630 --> 00:01:12,360
0,300 540,900 900,1530 1530,2340 2340,2730
and make suggestions,| he's always
|他总是欢迎提出任何想法。

35
00:01:12,360 --> 00:01:14,020
0,360 360,900
welcome to

36
00:01:14,020 --> 00:01:17,050
0,720 720,1290 1290,1920 1950,2310 2460,3030
entertain any ideas.| So {with,that},
|就这样， Russ ，交给你了。

37
00:01:17,050 --> 00:01:19,210
0,300 330,750 1230,1590 1590,1950 1950,2160
Russ, {it's,yours}.| Great, thanks, can
|太好了，谢谢，你们能看到幻灯片吗，

38
00:01:19,210 --> 00:01:20,290
0,120 120,300 300,390 390,510 510,1080
you {} see the slides,|
|

39
00:01:20,900 --> 00:01:22,370
0,90 90,210 210,660 900,1110 1110,1470
is that working?| Okay, great.|
还能用吗？|好的，很好。|

40
00:01:22,790 --> 00:01:24,290
0,360 360,360 990,1170 1170,1290 1290,1500
So {} so we build
所以我们构建 Go 支持编写分布式系统，

41
00:01:24,290 --> 00:01:25,700
0,240 240,540 570,960 960,1260 1260,1410
Go to support writing the

42
00:01:25,700 --> 00:01:27,110
0,210 210,300 300,750 750,1200 1200,1410
sort of distributed systems,| that
|那些我们在 Google 构建的，

43
00:01:27,110 --> 00:01:28,280
0,150 150,300 300,540 540,630 630,1170
we were building at Google,|
|

44
00:01:28,640 --> 00:01:29,510
0,180 180,330 330,510 510,750 750,870
and that may Go a
Go 非常适合，

45
00:01:29,510 --> 00:01:30,890
0,240 240,480 480,990 990,1200 1200,1380
great fit for,| what came
|下一代的云软件，

46
00:01:30,890 --> 00:01:31,850
0,270 270,450 450,570 570,720 720,960
next which is now called

47
00:01:31,850 --> 00:01:33,470
0,300 300,930 960,1290 1290,1530 1530,1620
cloud software| and also a
|也非常适合 6.824 。

48
00:01:33,470 --> 00:01:34,190
0,210 210,390 390,510 510,570 570,720
great fit for {6.824 -

49
00:01:34,190 --> 00:01:36,290
0,420 810,1380 1410,1770 1770,1920 1920,2100
-} {}.| So in this
|所以，在这节课中，

50
00:01:36,290 --> 00:01:37,130
0,330 330,450 450,570 570,660 660,840
lecture,| I'm going to try
|我将试着解释，

51
00:01:37,130 --> 00:01:38,570
0,60 60,720 720,960 960,1200 1200,1440
to explain,| how I think
|我是如何考虑用 Go 编写程序的。

52
00:01:38,570 --> 00:01:40,580
0,360 360,780 780,1380 1380,1500 1500,2010
about writing programs in Go.|
|

53
00:01:41,070 --> 00:01:42,510
0,510 510,780 780,840 840,1110 1110,1440
I'm going to walk through
我将介绍程序的设计和实现，

54
00:01:42,510 --> 00:01:43,590
0,270 270,450 450,510 510,960 960,1080
the sort of design and

55
00:01:43,590 --> 00:01:46,320
0,750 750,1140 1290,2100 2130,2460 2460,2730
implementation of programs| for four
|通过常见的四种不同的模式。

56
00:01:46,320 --> 00:01:47,670
0,300 300,840 840,990 990,1110 1110,1350
different patterns that I see

57
00:01:47,670 --> 00:01:49,060
0,180 180,330 330,840
come up often.|
|

58
00:01:49,060 --> 00:01:49,750
0,90 90,360 360,450 450,600 600,690
And along the way, I'm
在此过程中，我将尝试强调一些提示或经验法则，

59
00:01:49,750 --> 00:01:50,650
0,120 120,180 180,360 360,420 420,900
going to try to highlight

60
00:01:50,650 --> 00:01:51,670
0,210 210,570 570,690 690,930 930,1020
some hints or rules of

61
00:01:51,670 --> 00:01:52,840
0,330 330,690 690,840 840,930 930,1170
thumb,| that you can keep
|你可以在设计自己的 Go 程序时牢记。

62
00:01:52,840 --> 00:01:54,040
0,90 90,450 450,660 660,1050 1050,1200
in mind when designing your

63
00:01:54,040 --> 00:01:55,420
0,150 150,300 300,930
own Go programs.|
|

64
00:01:55,420 --> 00:01:56,290
0,120 120,240 240,420 420,510 510,870
And I know the syllabus
我知道教学大纲链接到了一个较老版本的幻灯片，

65
00:01:56,290 --> 00:01:57,250
0,240 240,330 330,480 480,690 690,960
links to an older version

66
00:01:57,250 --> 00:01:58,420
0,60 60,150 150,600 600,840 840,1170
of the slide,| so you
|所以你可能已经见过它们了，

67
00:01:58,420 --> 00:01:59,470
0,120 120,240 240,390 390,480 480,1050
might have seen them already,|
|

68
00:01:59,680 --> 00:02:00,760
0,120 120,330 330,540 540,720 720,1080
I hope that the lecture
我希望课程的形式更容易理解，

69
00:02:00,760 --> 00:02:01,480
0,210 210,330 330,390 390,540 540,720
form is a bit more

70
00:02:01,480 --> 00:02:02,830
0,630 630,780 780,1050 1050,1260 1260,1350
intelligible| than just sort of
|比只看幻灯片。

71
00:02:02,830 --> 00:02:04,820
0,270 270,390 390,660 870,1500
looking at the slides.|
|

72
00:02:04,880 --> 00:02:06,350
0,480 960,1140 1140,1170 1170,1350 1350,1470
{} And I hope that
我希望这些模式足够通用，

73
00:02:06,350 --> 00:02:07,370
0,90 90,330 330,480 480,840 840,1020
in general these patterns are

74
00:02:07,370 --> 00:02:09,320
0,420 420,990 1020,1530 1530,1800 1800,1950
common enough,| that maybe they'll
|或许它们自己能帮上忙，

75
00:02:09,320 --> 00:02:10,460
0,90 90,420 420,540 540,1020 1020,1140
be helpful by themselves,| but
|但是你也会，

76
00:02:10,460 --> 00:02:12,530
0,270 270,540 810,1110 1110,1260 1260,2070
also that you know you'll,|
|

77
00:02:12,560 --> 00:02:14,180
0,480 480,600 600,870 870,1230 1230,1620
{the,hints} will help you {}
提示会帮助你做好需要实现的东西的准备。

78
00:02:14,210 --> 00:02:15,290
0,420 420,540 540,870 870,930 930,1080
prepare for whatever it is

79
00:02:15,290 --> 00:02:16,560
0,120 120,270 270,360 360,780
you need to implement.|
|

80
00:02:18,900 --> 00:02:20,520
0,210 210,330 330,1050 1080,1230 1230,1620
So to start, it's important
所以，首先区分并发性和并行性很重要。

81
00:02:20,520 --> 00:02:22,470
0,60 60,480 480,1050 1050,1770 1770,1950
to distinguish between concurrency and

82
00:02:22,470 --> 00:02:23,780
0,810
parallelism.|
|

83
00:02:23,810 --> 00:02:25,100
0,180 180,630 630,720 720,990 990,1290
And concurrency is about how
并发性是关于如何编写程序

84
00:02:25,100 --> 00:02:26,810
0,240 240,480 480,660 660,1380 1410,1710
you write your programs| about
|能够独立编排独立执行的控制流，

85
00:02:26,810 --> 00:02:29,330
0,180 180,420 420,750 750,1680 1890,2520
being able to compose independently

86
00:02:29,330 --> 00:02:31,310
0,690 690,1020 1050,1440 1440,1770 1770,1980
executing {} control flows,| whether
|无论你称它们为进程、线程还是 goroutine ，

87
00:02:31,310 --> 00:02:31,880
0,90 90,210 210,270 270,450 450,570
you want to call them

88
00:02:31,880 --> 00:02:33,380
0,690 690,810 810,1260 1260,1350 1350,1500
processes or threads or {goroutines

89
00:02:33,380 --> 00:02:35,450
0,570 810,1110 1110,1290 1320,1560 1560,2070
-},| so that your program
|这样你的程序就可以同时处理很多事情，

90
00:02:35,450 --> 00:02:36,650
0,150 150,420 420,780 780,930 930,1200
can be dealing with lots

91
00:02:36,650 --> 00:02:38,090
0,60 60,300 300,390 390,990 1020,1440
of things at once,| without
|而不会变得一团糟。

92
00:02:38,090 --> 00:02:39,470
0,240 240,420 420,480 480,780 780,1380
turning into a giant mess.|
|

93
00:02:40,100 --> 00:02:41,300
0,150 150,210 210,360 360,630 630,1200
On the other hand parallelism
另一方面，并行性是关于程序是如何执行的，

94
00:02:41,300 --> 00:02:42,350
0,150 150,390 390,510 510,630 630,1050
is about how the programs

95
00:02:42,350 --> 00:02:44,750
0,240 240,960 1260,1620 1620,2010 2010,2400
get executed,| about allowing multiple
|关于允许多个计算同时运行，

96
00:02:44,750 --> 00:02:47,330
0,720 720,810 810,1410 1440,2430 2430,2580
computations to run simultaneously,| so
|这样程序可以同时做很多事情，

97
00:02:47,330 --> 00:02:48,290
0,150 150,270 270,540 540,660 660,960
that the program can be

98
00:02:48,350 --> 00:02:49,520
0,450 450,780 780,840 840,1110 1110,1170
doing lots of things at

99
00:02:49,520 --> 00:02:50,660
0,390 390,570 570,750 750,1020 1020,1140
once,| not just dealing with
|而不是一次处理很多事情。

100
00:02:50,660 --> 00:02:51,680
0,210 210,300 300,510 510,570 570,1020
[lots] of things at once.|
|

101
00:02:52,120 --> 00:02:53,380
0,150 150,390 390,540 540,990 990,1260
And so {concurrency -} lends
所以并发性很自然地适合并行执行，

102
00:02:53,380 --> 00:02:55,690
0,330 330,900 900,1050 1050,1560 1560,2310
itself naturally to parallel execution,|
|

103
00:02:55,930 --> 00:02:57,250
0,510 510,720 720,840 840,1170 1170,1320
but today the focus is
但今天的关注点是，

104
00:02:57,250 --> 00:02:58,330
0,150 150,420 420,480 480,750 750,1080
on,| how to use Go's
|如何使用 Go 的并发支持来使你的程序清楚，

105
00:02:58,330 --> 00:02:59,860
0,180 180,630 630,1260 1260,1350 1350,1530
{concurrency -} support to make

106
00:02:59,860 --> 00:03:02,080
0,120 120,510 510,1140 1470,2130 2130,2220
your programs clear,| not to
|而不是让它们更快，

107
00:03:02,080 --> 00:03:02,920
0,150 150,270 270,660 660,720 720,840
make them faster,| if they
|如果它们变得更快了，那很好，

108
00:03:02,920 --> 00:03:04,300
0,150 150,360 360,690 690,870 870,1380
do get faster, that's wonderful,|
|

109
00:03:04,300 --> 00:03:05,470
0,270 270,630 630,810 810,900 900,1170
but that's not the point
但这不是今天的重点。

110
00:03:05,470 --> 00:03:06,340
0,360
today.|
|

111
00:03:07,220 --> 00:03:08,990
0,510 780,1200 1200,1410 1410,1500 1500,1770
So I said, I'd walked
所以我说，我会通过一些程序的设计和实现，

112
00:03:08,990 --> 00:03:10,550
0,150 150,210 210,720 720,840 840,1560
through the design and implementation

113
00:03:10,550 --> 00:03:12,140
0,270 270,390 390,900 900,1050 1050,1590
of some programs| for four
|我经常看到的四种常见的并发模式，

114
00:03:12,140 --> 00:03:15,530
0,810 1200,2070 2310,2880 2880,3270 3270,3390
common, {excuse,me}, concurrency patterns that

115
00:03:15,530 --> 00:03:17,330
0,90 90,270 270,750 1050,1560 1560,1800
I see often,| but before
|但在我们到达这些之前，

116
00:03:17,330 --> 00:03:18,380
0,90 90,300 300,360 360,930 960,1050
we get to those,| I
|我想从一个看似微不足道的问题开始，

117
00:03:18,380 --> 00:03:19,370
0,150 150,210 210,510 510,780 780,990
want to start with what

118
00:03:19,370 --> 00:03:20,390
0,270 270,390 390,480 480,660 660,1020
seems like a really trivial

119
00:03:20,390 --> 00:03:22,310
0,390 390,570 570,720 720,1650 1680,1920
problem,| but that illustrates one
|但这说明了一个最重要的点，

120
00:03:22,310 --> 00:03:23,420
0,60 60,120 120,360 360,780 780,1110
of the most important points|
|

121
00:03:23,420 --> 00:03:24,350
0,180 180,330 330,420 420,810 810,930
about what it means to
关于使用并发来构建程序意味着什么。

122
00:03:24,350 --> 00:03:25,940
0,180 180,330 330,1020 1050,1200 1200,1590
use {concurrency -} to structure

123
00:03:25,940 --> 00:03:27,080
0,810
programs.|
|

124
00:03:27,570 --> 00:03:28,800
0,150 150,570 570,690 690,930 930,1230
A decision that comes up
在设计并发程序时，一种反复出现的决定，

125
00:03:28,830 --> 00:03:29,730
0,300 300,420 420,630 630,780 780,900
over and over, when you

126
00:03:29,730 --> 00:03:31,740
0,330 330,720 720,1350 1500,1740 1740,2010
design concurrent programs| is whether
|是将状态表示为代码还是数据。

127
00:03:31,740 --> 00:03:34,110
0,120 120,630 630,1380 1410,1740 1740,2370
to represent states as code

128
00:03:34,140 --> 00:03:35,790
0,210 210,390 390,840 1080,1320 1320,1650
or as data.| And {by,as}
|作为代码，我指的是程序中的控制流，

129
00:03:35,790 --> 00:03:36,990
0,330 330,390 390,630 630,720 720,1200
code, I mean the control

130
00:03:36,990 --> 00:03:38,480
0,210 210,300 300,360 360,990
flow in the program,|
|

131
00:03:38,780 --> 00:03:40,550
0,510 570,1020 1020,1110 1110,1320 1320,1770
so suppose {} reading characters
假设从文件中读取字符，

132
00:03:40,550 --> 00:03:41,450
0,120 120,240 240,690 720,840 840,900
from a file,| and we
|我们需要扫描一个 C 样式的引号字符串。

133
00:03:41,450 --> 00:03:42,560
0,180 180,240 240,600 600,990 990,1110
need to scan over a

134
00:03:42,560 --> 00:03:44,630
0,240 240,600 600,900 900,1440 1620,2070
C style quoted string.| {Oh,hello,}
|哦，你好，幻灯片没有变。

135
00:03:44,630 --> 00:03:47,180
0,570 570,780 780,1560 1710,2220 2220,2550
{the,slides} aren't changing.| Yeah, it
|是的，它会的，

136
00:03:47,180 --> 00:03:48,980
0,450 450,870 1320,1530 1530,1620 1620,1800
will,| {} can you see
|你现在能看到 goroutines 状态的序言吗？

137
00:03:48,980 --> 00:03:50,300
0,420 420,900 900,960 960,1200 1200,1320
prologue goroutines for state right

138
00:03:50,300 --> 00:03:51,350
0,360 390,720 720,840 840,960 960,1050
now.| No, we see the
|不，我们看到标题幻灯片。

139
00:03:51,350 --> 00:03:53,540
0,270 270,570 840,960 960,1620 1980,2190
title slide.| Oh, no, yeah
|哦，不，是的，我在想这个问题，

140
00:03:53,540 --> 00:03:54,500
0,90 90,240 240,480 480,750 750,960
I was wondering about that,|
|

141
00:03:54,500 --> 00:03:56,600
0,930 1110,1290 1290,1470 1470,1710 1710,2100
because there was a border
因为当我开始时，这里有一个[边框]环绕着，

142
00:03:56,600 --> 00:03:57,530
0,330 330,510 510,690 690,840 840,930
around this thing, when I

143
00:03:57,530 --> 00:03:58,910
0,660 660,810 810,960 960,1140 1170,1380
started| and then it went
|然后它就消失了。

144
00:03:58,910 --> 00:04:00,100
0,690
away.|
|

145
00:04:00,220 --> 00:04:01,180
0,240 240,420 420,720 720,870 870,960
So let me let me
所以，让我先取消分享，再重新分享。

146
00:04:01,180 --> 00:04:02,230
0,240 240,420 420,750 750,870 870,1050
just {unshare -} and {reshare

147
00:04:02,230 --> 00:04:03,620
0,840
-}.|
|

148
00:04:04,280 --> 00:04:04,850
0,90 90,210 210,270 270,480 480,570
I had to figure out
我必须弄清楚如何在 Zoom 中做这个。

149
00:04:04,850 --> 00:04:06,900
0,60 60,150 150,300 300,1170
how to do that

150
00:04:06,960 --> 00:04:08,280
0,780
{in,Zoom}.|
|

151
00:04:10,760 --> 00:04:12,650
0,750 750,1200 1200,1530 1530,1800 1800,1890
Unfortunately, Keynote menu wants to
不幸的是， Keynote 菜单想要打开，

152
00:04:12,650 --> 00:04:13,280
0,120 120,330 330,420 420,480 480,630
be up| and I don't
|我不知道怎么才能进入 Zoom 菜单。

153
00:04:13,280 --> 00:04:13,730
0,60 60,150 150,210 210,360 360,450
know how to get to

154
00:04:13,730 --> 00:04:15,260
0,90 90,420 420,840
the Zoom menu.|
|

155
00:04:16,240 --> 00:04:18,900
0,2070

156
00:04:19,880 --> 00:04:21,380
0,480 510,870 870,1140 1140,1350 1350,1500
Ah, my screen sharing is
啊，我的屏幕分享暂停了，

157
00:04:21,380 --> 00:04:22,760
0,660 660,870 870,990 990,1110 1110,1380
paused,| why is my screen
|为什么我的屏幕分享暂停了，

158
00:04:22,760 --> 00:04:24,120
0,210 210,840
sharing paused,|
|

159
00:04:24,930 --> 00:04:26,600
0,210 210,420 420,1170
can I resume,|
我可以继续吗，|

160
00:04:26,600 --> 00:04:27,980
0,150 150,270 270,1020 1050,1200 1200,1380
here we go.| {Alright -
我们开始吧。|好的，我不知道，

161
00:04:27,980 --> 00:04:29,480
0,300 630,780 780,870 870,1230 1260,1500
-}, I don't know,| the
|Zoom 说你的屏幕分享暂停了，

162
00:04:29,480 --> 00:04:30,560
0,240 240,540 540,750 750,870 870,1080
Zoom [box] says your screen

163
00:04:30,560 --> 00:04:31,430
0,180 180,270 270,600 600,780 780,870
sharing is paused,| so {}
|所以，

164
00:04:31,430 --> 00:04:33,050
0,420 420,900 900,990 990,1320 1320,1620
that,| now the borders back,|
|现在边框又回来了，|

165
00:04:33,050 --> 00:04:36,200
0,210 210,360 360,600 600,990 2580,3150
so I'll watch that.| Alright
所以我会看的。|好的，我回到了这里，

166
00:04:36,200 --> 00:04:38,200
0,510 630,1290
so, {}

167
00:04:38,320 --> 00:04:40,030
0,540 630,840 840,960 960,1170 1170,1710
see, I was back here,|
|

168
00:04:40,060 --> 00:04:41,530
0,300 300,660 660,1200 1200,1410 1410,1470
so so you're reading a
所以你读取一个字符串，

169
00:04:41,530 --> 00:04:43,300
0,630 990,1170 1170,1350 1350,1410 1410,1770
string,| it's not a parallel
|这不是并行程序，

170
00:04:43,300 --> 00:04:44,530
0,390 390,510 510,690 690,870 870,1230
program,| is reading one character
|一次读取一个字符，

171
00:04:44,530 --> 00:04:45,160
0,60 60,120 120,420 420,510 510,630
at a time,| so there's
|没有并行的机会，

172
00:04:45,160 --> 00:04:46,750
0,180 180,630 630,750 750,1350 1350,1590
no opportunity for parallelism,| but
|但这是一个很好的并发机会。

173
00:04:46,750 --> 00:04:47,710
0,150 150,270 270,360 360,540 540,960
there is a good opportunity

174
00:04:47,710 --> 00:04:49,390
0,240 240,810 1230,1410 1410,1530 1530,1680
for concurrency.| So we don't
|所以我们并不关心字符串中的确切转义序列，

175
00:04:49,390 --> 00:04:51,010
0,300 300,750 750,1170 1170,1230 1230,1620
actually care about the exact

176
00:04:51,010 --> 00:04:52,660
0,300 300,810 810,900 900,990 990,1650
escape sequences in the string,|
|

177
00:04:52,960 --> 00:04:53,950
0,570 570,630 630,780 780,840 840,990
that we need to do
我们需要做的就是匹配这个正则表达式，

178
00:04:53,950 --> 00:04:55,450
0,120 120,390 390,570 570,870 870,1500
is match this regular expression,|
|

179
00:04:55,880 --> 00:04:56,480
0,180 180,360 360,450 450,540 540,600
and we don't have to
我们不必担心要准确地理解，

180
00:04:56,480 --> 00:04:58,250
0,150 150,360 360,810 810,1590 1620,1770
worry about understanding exactly,| we'll
|我们会回到它的意思上，

181
00:04:58,250 --> 00:04:58,850
0,120 120,300 300,390 390,510 510,600
come back to what it

182
00:04:58,850 --> 00:05:00,440
0,360 360,870 930,1200 1200,1470 1470,1590
means,| but that's basically all
|但你所要做的就是实现这个正则表达式。

183
00:05:00,440 --> 00:05:01,250
0,60 60,150 150,240 240,420 420,810
you have to do is

184
00:05:01,250 --> 00:05:03,170
0,270 270,390 390,630 630,1200 1710,1920
implement this regular expression.| And
|你们可能都知道，

185
00:05:03,170 --> 00:05:04,430
0,480 510,630 630,780 780,1020 1020,1260
so you know you probably

186
00:05:04,430 --> 00:05:05,450
0,150 150,360 360,510 510,780 810,1020
all know,| you can turn
|你可以将正则表达式转换为状态机，

187
00:05:05,450 --> 00:05:06,350
0,30 30,300 300,690 690,810 810,900
a regular expression into a

188
00:05:06,350 --> 00:05:07,910
0,240 240,750 930,1170 1170,1410 1410,1560
state machine,| and so we
|所以，我们可能会使用一个工具来生成这些代码，

189
00:05:07,910 --> 00:05:09,050
0,180 180,330 330,420 420,720 720,1140
might use a tool that

190
00:05:09,050 --> 00:05:10,580
0,420 420,600 600,1050
generates this code,|
|

191
00:05:10,950 --> 00:05:11,880
0,180 180,270 270,450 450,750 750,930
and in this code, there's
在这段代码中，只有一个变量状态，

192
00:05:11,880 --> 00:05:13,590
0,90 90,390 390,780 780,1410 1440,1710
a single variable state,| that's
|那就是机器的状态，

193
00:05:13,590 --> 00:05:14,730
0,90 90,330 330,420 420,480 480,1140
the state of the machine,|
|

194
00:05:14,910 --> 00:05:15,930
0,240 240,360 360,600 600,840 840,1020
and the loop goes over
循环遍历 state 一次一个字符，

195
00:05:15,930 --> 00:05:17,280
0,90 90,630 630,900 900,1290 1290,1350
the state one character at

196
00:05:17,280 --> 00:05:18,510
0,60 60,420 420,600 600,660 660,1230
a time,| reads the character
|根据状态读取字符，

197
00:05:18,510 --> 00:05:19,470
0,390 390,480 480,570 570,870 870,960
depending on the state,| and
|并且字符转为不同的状态，

198
00:05:19,470 --> 00:05:20,550
0,60 60,600 600,930 930,1020 1020,1080
the character changes to a

199
00:05:20,550 --> 00:05:22,170
0,240 240,720 960,1290 1290,1350 1350,1620
different state,| until it gets
|直到它到达结尾，

200
00:05:22,170 --> 00:05:23,520
0,60 60,210 210,450 930,1080 1080,1350
to the end,| and so
|所以这是一个完全不可读的程序，

201
00:05:23,520 --> 00:05:24,900
0,240 240,360 360,450 450,900 900,1380
this is a completely unreadable

202
00:05:24,900 --> 00:05:26,340
0,630 870,1080 1080,1200 1200,1260 1260,1440
program,| but it's the kind
|但这是一种东西，

203
00:05:26,340 --> 00:05:27,150
0,90 90,270 270,450 480,600 600,810
of thing,| that you know
|自动生成的程序可能看起来的样子。

204
00:05:27,150 --> 00:05:28,380
0,150 150,360 360,780 780,1050 1050,1230
an auto generated program might

205
00:05:28,380 --> 00:05:29,360
0,150 150,510
look like.|
|

206
00:05:29,360 --> 00:05:30,440
0,300 300,360 360,690 690,960 960,1080
And the important point is
重要的一点是，程序状态存储在数据中，

207
00:05:30,440 --> 00:05:31,790
0,180 180,360 360,750 750,1200 1200,1350
that the program state is

208
00:05:31,790 --> 00:05:33,410
0,690 720,960 960,1320 1320,1440 1440,1620
stored in data,| in this
|在这个变量中，称为状态，

209
00:05:33,410 --> 00:05:35,570
0,390 390,570 570,870 870,1320 1860,2160
variable, that's called state,| and
|如果你可以将其更改为将状态存储在代码中，

210
00:05:35,570 --> 00:05:36,530
0,120 120,300 300,450 450,780 780,960
if you can change it

211
00:05:36,530 --> 00:05:37,940
0,120 120,570 570,660 660,1200 1230,1410
to store the state in

212
00:05:37,940 --> 00:05:40,700
0,750 1050,1320 1320,1650 1650,2340
code,| that's often clearer.|
|这通常会更清楚。|

213
00:05:41,260 --> 00:05:42,490
0,330 330,540 540,690 690,720 720,1230
So here's what I mean,|
所以我的意思是，|

214
00:05:42,880 --> 00:05:44,860
0,600 630,1110 1110,1260 1260,1860 1860,1980
{} suppose we duplicate the
假设我们重复 readChar 调用到 switch 的每个 case 中，

215
00:05:44,860 --> 00:05:46,420
0,270 270,510 510,1080 1080,1320 1320,1560
{readChar -} calls into each

216
00:05:46,420 --> 00:05:48,220
0,270 270,360 360,450 450,1170 1470,1800
case of the switch,| so
|所以在这里我们没有做任何语义上的改变，

217
00:05:48,220 --> 00:05:49,390
0,120 120,360 360,540 540,750 750,1170
we haven't made any semantic

218
00:05:49,390 --> 00:05:50,230
0,300 300,450 450,540 540,690 690,840
changes here,| we just took
|我们只是将顶部的 readChar 移到了中间。

219
00:05:50,230 --> 00:05:51,070
0,120 120,510 510,600 600,750 750,840
the readChar that was at

220
00:05:51,070 --> 00:05:51,970
0,60 60,450 450,540 540,660 660,900
the top and we moved

221
00:05:51,970 --> 00:05:53,400
0,90 90,240 240,330 330,810
it into the middle.|
|

222
00:05:53,940 --> 00:05:56,190
0,690 690,1260 1260,1470 1500,1890 1890,2250
Now instead of setting state
现在，不是设置 state ，然后立即执行 switch ，

223
00:05:56,190 --> 00:05:57,060
0,90 90,180 180,570 570,780 780,870
and then immediately doing the

224
00:05:57,060 --> 00:05:58,530
0,270 270,810 840,1020 1020,1170 1170,1470
switch again,| we can change
|我们可以把它们改成 goto ，

225
00:05:58,530 --> 00:06:00,320
0,240 240,420 420,870 870,1290
those into {gotos -},|
|

226
00:06:01,920 --> 00:06:03,300
0,180 180,480 660,840 840,960 960,1380
and then we can simplify
然后我们可以进一步简化一点，

227
00:06:03,300 --> 00:06:04,080
0,60 60,210 210,330 330,630 630,780
a little bit further,| there's
|这里有一个 goto state1 ，

228
00:06:04,080 --> 00:06:05,250
0,60 60,390 390,690 690,990 990,1170
a goto {state1 -},| that's
|正好在 state1 标签之前，

229
00:06:05,250 --> 00:06:06,390
0,210 210,600 600,750 750,990 990,1140
right before the {state1 -}

230
00:06:06,390 --> 00:06:07,110
0,300 300,420 420,510 510,630 630,720
label,| we can get rid
|我们可以去掉它。

231
00:06:07,110 --> 00:06:10,260
0,60 60,540 1230,2160 2160,2370 2370,3150
of that.| Then there's, {}
|然后，我想，

232
00:06:10,880 --> 00:06:11,840
0,90 90,330 330,510 510,720 720,960
I guess,| yeah, so then
|是的，这里只有一种方法到达 state2 ，

233
00:06:11,840 --> 00:06:13,490
0,630 780,1200 1230,1350 1350,1470 1470,1650
there's {} you know there's

234
00:06:13,490 --> 00:06:14,090
0,120 120,270 270,390 390,450 450,600
only one way to get

235
00:06:14,090 --> 00:06:15,050
0,60 60,360 360,720 750,900 900,960
the {state2 -},| so we
|所以，我们不妨将 state2 代码拉上来，

236
00:06:15,050 --> 00:06:15,710
0,150 150,240 240,360 360,570 570,660
might as well pull the

237
00:06:15,710 --> 00:06:16,640
0,270 270,420 420,660 660,810 810,930
{state2 -} code up| and
|并将其放到 goto 出现的 if 中，

238
00:06:16,640 --> 00:06:17,600
0,150 150,270 270,690 690,810 810,960
put it inside the if

239
00:06:17,600 --> 00:06:19,550
0,180 180,270 270,630 630,1290 1740,1950
where the goto appears,| and
|然后，现在 if 的两边最终都到 goto state1 ，

240
00:06:19,550 --> 00:06:21,470
0,600 630,1170 1170,1590 1590,1710 1710,1920
then both sides of that

241
00:06:21,470 --> 00:06:22,490
0,240 240,450 450,720 720,840 840,1020
if now end in {goto

242
00:06:22,490 --> 00:06:23,810
0,150 150,420 420,810 1020,1230 1230,1320
-} {state1 -},| so we
|所以，我们可以把它拿出来。

243
00:06:23,810 --> 00:06:25,440
0,120 120,480 480,690 690,1110
can hoist that out.|
|

244
00:06:25,440 --> 00:06:26,730
0,90 90,450 450,930 930,1200 1200,1290
And now what's left is
现在剩下的是一个非常简单的程序，

245
00:06:26,730 --> 00:06:28,560
0,390 390,690 690,960 960,1290 1290,1830
actually a pretty simple program,|
|

246
00:06:28,590 --> 00:06:30,030
0,420 420,750 750,870 870,1140 1140,1440
{you,know,state0 -} is never jumped
state0 永远不会跳入，

247
00:06:30,030 --> 00:06:31,200
0,210 210,360 360,450 450,780 780,1170
to,| so it just begins
|所以它只是从那里开始，

248
00:06:31,200 --> 00:06:32,550
0,480 630,780 780,900 900,1140 1140,1350
there,| and then {state1 -}
|然后 state1 只是一个常规循环，

249
00:06:32,550 --> 00:06:33,630
0,120 120,270 270,330 330,630 630,1080
is just a regular loop,|
|

250
00:06:33,660 --> 00:06:34,260
0,180 180,240 240,390 390,510 510,600
so we might as well
所以我们不妨让它看起来像一个常规的循环。

251
00:06:34,260 --> 00:06:35,370
0,210 210,510 540,870 870,1050 1050,1110
make that look like a

252
00:06:35,370 --> 00:06:36,700
0,390 390,810
regular loop.|
|

253
00:06:37,240 --> 00:06:38,860
0,480 780,1020 1020,1230 1230,1440 1440,1620
{} And now like this
现在，这看起来像是一个程序，

254
00:06:38,860 --> 00:06:40,210
0,330 330,480 480,780 810,1200 1200,1350
is you know looking like

255
00:06:40,210 --> 00:06:42,100
0,60 60,720 1110,1290 1290,1470 1470,1890
a program,| and then finally
|最后，我们可以去掉一些变量，

256
00:06:42,100 --> 00:06:43,060
0,120 120,600 600,780 780,900 900,960
we can get rid of

257
00:06:43,060 --> 00:06:44,770
0,150 150,990 1020,1230 1230,1620 1620,1710
some variables| and simplify a
|进一步简化。

258
00:06:44,770 --> 00:06:46,280
0,150 150,300 300,930
little bit further.|
|

259
00:06:46,280 --> 00:06:47,420
0,390 390,750 750,900 900,990 990,1140
And, {} and we can
然后，我们可以旋转循环，

260
00:06:47,420 --> 00:06:48,710
0,450 450,570 570,810 810,1020 1020,1290
rotate the loop,| so that
|我们不会在循环中间返回 true ，

261
00:06:48,740 --> 00:06:49,670
0,120 120,420 450,600 600,780 780,930
you know we don't do

262
00:06:49,670 --> 00:06:50,420
0,60 60,420 420,600 600,690 690,750
a return true in the

263
00:06:50,420 --> 00:06:51,230
0,270 270,360 360,450 450,720 720,810
middle of the loop,| we
|我们在结束时返回 true 。

264
00:06:51,230 --> 00:06:52,040
0,120 120,210 210,570 570,750 750,810
do the return true at

265
00:06:52,040 --> 00:06:53,180
0,150 150,570
the end.|
|

266
00:06:54,220 --> 00:06:55,630
0,150 150,270 270,930 960,1230 1230,1410
And so now we've got
所以现在我们有了这个程序，

267
00:06:55,630 --> 00:06:57,190
0,120 120,570 570,750 750,840 840,1560
this program,| that is actually
|它相当不错，

268
00:06:57,220 --> 00:06:59,590
0,210 210,600 960,1530 1530,2010 2010,2370
you know reasonably nice,| and
|值得一提的是，

269
00:06:59,950 --> 00:07:01,390
0,210 210,390 390,840 840,1230 1260,1440
it's worth mentioning that,| it's
|有可能清理不那么令人震惊的例子，

270
00:07:01,390 --> 00:07:02,710
0,390 390,480 480,750 750,1080 1080,1320
possible to clean up much

271
00:07:02,710 --> 00:07:04,360
0,180 180,630 630,1260 1260,1530 1530,1650
less egregious examples,| {you,know,if} you
|如果你试着手写这个，

272
00:07:04,360 --> 00:07:05,110
0,90 90,330 330,390 390,600 600,750
had tried to write this

273
00:07:05,110 --> 00:07:06,790
0,150 150,690 870,1140 1140,1380 1380,1680
by hand,| your first attempt
|你的第一次尝试可能是左边的东西，

274
00:07:06,790 --> 00:07:07,510
0,180 180,270 270,450 450,540 540,720
might have been the thing

275
00:07:07,510 --> 00:07:08,740
0,120 120,210 210,750 810,1080 1080,1230
on the left,| where you've
|你得到了这个额外的状态，

276
00:07:08,740 --> 00:07:09,670
0,180 180,330 330,600 600,840 840,930
got this extra piece of

277
00:07:09,670 --> 00:07:11,080
0,570 750,930 930,1140 1140,1290 1290,1410
state,| and then you can
|然后，你可以应用相同类型的转换

278
00:07:11,080 --> 00:07:12,280
0,420 420,570 570,840 840,1140 1140,1200
apply the same kinds of

279
00:07:12,280 --> 00:07:14,320
0,870 870,1170 1200,1500 1500,1740 1740,2040
transformations| to move that state
|将状态移动到实际的控制流中，

280
00:07:14,320 --> 00:07:15,910
0,240 240,360 360,720 720,1110 1110,1590
into the actual control flow,|
|

281
00:07:16,030 --> 00:07:16,870
0,270 270,450 450,660 660,750 750,840
and end up, { the
最终，同一个程序会变成右边这样，

282
00:07:16,870 --> 00:07:18,160
0,330 330,900 930,1050 1050,1140 1140,1290
same program that we have

283
00:07:18,160 --> 00:07:19,360
0,120 120,210 210,540 540,690 690,1200
on the right,| that's cleaner.|
|这个程序更清楚。|

284
00:07:20,000 --> 00:07:21,920
0,180 180,360 360,540 540,1470 1470,1920
So this is a useful
所以这是一个有用的转换，

285
00:07:21,920 --> 00:07:23,630
0,780 780,840 840,1080 1080,1170 1170,1710
transformation to keep in mind,|
|

286
00:07:23,900 --> 00:07:25,190
0,540 540,630 630,750 750,1080 1080,1290
anytime you have state,| that
任何时候你有状态，|这看起来像是在[重申]，

287
00:07:25,190 --> 00:07:27,110
0,180 180,240 240,540 540,1560 1590,1920
kind of looks like it

288
00:07:27,110 --> 00:07:29,120
0,210 210,420 420,900 1020,1710 1710,2010
might be just reiterating,| what's
|程序计数器里发生了什么。

289
00:07:29,120 --> 00:07:30,200
0,240 240,570 570,660 660,750 750,1080
what's happening in the program

290
00:07:30,200 --> 00:07:31,140
0,450
counter.|
|

291
00:07:31,760 --> 00:07:34,250
0,450 1410,1590 1590,2010 2010,2340 2340,2490
{} And so you can
所以你可以看到，如果是原始 state ，

292
00:07:34,250 --> 00:07:36,140
0,240 240,540 540,840 840,1380 1710,1890
see this if the the

293
00:07:36,140 --> 00:07:37,970
0,780 780,1080 1080,1320 1320,1560 1560,1830
original state,| {like,if} state equals
|如果 state 等于 0 ，

294
00:07:37,970 --> 00:07:39,170
0,360 360,480 480,780 780,1080 1080,1200
0,| the program counter is
|程序计数器在函数的开始处，

295
00:07:39,170 --> 00:07:39,740
0,90 90,150 150,450 450,510 510,570
at the beginning of the

296
00:07:39,740 --> 00:07:41,180
0,570 690,930 930,1020 1020,1230 1230,1440
function,| and if state equals
|如果 state 等于 1 或者如果 inEscape 等于 false 或其他版本，

297
00:07:41,180 --> 00:07:42,470
0,510 540,750 750,870 870,930 930,1290
1 or if {inEscape -}

298
00:07:42,470 --> 00:07:43,340
0,210 210,540 540,630 630,690 690,870
equals false and the other

299
00:07:43,340 --> 00:07:44,870
0,540 720,870 870,1110 1110,1380 1380,1530
version,| the program counter is
|程序计数器就在 for 循环内，

300
00:07:44,870 --> 00:07:46,040
0,240 240,630 630,690 690,960 960,1170
just inside the for loop,|
|

301
00:07:46,040 --> 00:07:47,060
0,90 90,300 300,570 570,810 810,1020
and state equals 2 is
而 state 等于 2 在 for 循环中更靠下。

302
00:07:47,060 --> 00:07:48,140
0,450 450,720 720,780 780,870 870,1080
further down in the for

303
00:07:48,140 --> 00:07:48,920
0,330
loop.|
|

304
00:07:49,040 --> 00:07:50,030
0,150 150,210 210,600 600,690 690,990
And the benefit of writing
这样写而不是使用 state 的好处，

305
00:07:50,030 --> 00:07:51,140
0,120 120,330 330,630 630,1020 1020,1110
it this way instead of

306
00:07:51,140 --> 00:07:52,340
0,120 120,210 210,900 930,1080 1080,1200
with the states| is that
|是它更容易理解，

307
00:07:52,340 --> 00:07:53,780
0,120 120,480 480,780 780,840 840,1440
it's much easier to understand,|
|

308
00:07:54,140 --> 00:07:55,400
0,300 300,420 420,570 570,1050 1050,1260
like I can actually just
比如我可以浏览代码并向你解释，

309
00:07:55,400 --> 00:07:56,180
0,270 270,390 390,450 450,690 690,780
walk through the code and

310
00:07:56,180 --> 00:07:57,050
0,420 420,480 480,570 570,780 780,870
explain it to you,| you
|如果你通读代码，

311
00:07:57,050 --> 00:07:58,010
0,270 300,480 480,570 570,750 750,960
know if you just read

312
00:07:58,010 --> 00:07:58,820
0,120 120,180 180,480 480,600 600,810
through the code,| you read
|你读到一个左括号，然后开始循环，

313
00:07:58,820 --> 00:08:00,200
0,90 90,360 360,810 990,1260 1260,1380
an opening quote and then

314
00:08:00,200 --> 00:08:01,460
0,90 90,330 330,840 840,1170 1170,1260
you start looping,| and then
|然后直到你找到右括号，

315
00:08:01,460 --> 00:08:02,420
0,240 240,360 360,540 540,600 600,960
until you find the closing

316
00:08:02,420 --> 00:08:03,620
0,360 360,450 450,600 600,660 660,1200
quote,| you read a character|
|你读取一个字符，|

317
00:08:03,620 --> 00:08:04,490
0,90 90,180 180,270 270,330 330,870
and if it's a backslash,|
如果下一个字符是反斜杠，|

318
00:08:04,490 --> 00:08:05,510
0,60 60,330 330,420 420,630 630,1020
you skip the next character,|
你就跳过下一个字符，|

319
00:08:05,510 --> 00:08:06,380
0,120 120,300 300,570 570,750 750,870
and that's it right,| you
这就对了，|你可以从纸上读它，

320
00:08:06,380 --> 00:08:07,100
0,90 90,240 240,420 420,540 540,720
can just read that off

321
00:08:07,100 --> 00:08:08,240
0,90 90,480 480,720 720,840 840,1140
the page,| which you couldn't
|这是你在原始（代码）中做不到的。

322
00:08:08,240 --> 00:08:09,940
0,450 480,600 600,690 690,1260
do in the original.|
|

323
00:08:10,790 --> 00:08:12,350
0,300 300,750 750,1080 1080,1440 1440,1560
This version also happens to
这个版本也碰巧运行得更快，

324
00:08:12,350 --> 00:08:14,090
0,240 240,840 840,1200 1200,1470 1470,1740
run faster,| although that doesn't
|尽管这对我们来说并不重要。

325
00:08:14,090 --> 00:08:17,120
0,150 150,630 630,810 810,1230
really matter for us.|
|

326
00:08:17,270 --> 00:08:17,930
0,180 180,300 300,300 300,600 600,660
But as I mentioned,| I'm
但正如我提到的，|我将强调我认为重要的教训，

327
00:08:17,930 --> 00:08:18,680
0,120 120,180 180,510 510,630 630,750
going to highlight what I

328
00:08:18,680 --> 00:08:19,700
0,180 180,330 330,510 510,570 570,1020
think are kind of important

329
00:08:19,700 --> 00:08:21,170
0,450 450,600 600,960 960,1110 1110,1470
lessons| as hints for designing
|作为设计你自己的 Go 程序的提示，

330
00:08:21,170 --> 00:08:22,190
0,150 150,240 240,450 450,900 900,1020
your own Go programs,| and
|这是第一个，

331
00:08:22,190 --> 00:08:23,150
0,150 150,270 270,360 360,630 630,960
this is the first one,|
|

332
00:08:23,360 --> 00:08:25,190
0,510 540,1050 1050,1320 1320,1650 1650,1830
to convert data state into
将数据状态转换为代码状态，

333
00:08:25,190 --> 00:08:26,750
0,300 300,780 810,1230 1230,1320 1320,1560
code state,| when it makes
|它会使你的代码更清楚。

334
00:08:26,750 --> 00:08:28,340
0,120 120,540 540,1080
your programs clearer.|
|

335
00:08:28,660 --> 00:08:30,100
0,180 180,570 570,930 960,1350 1350,1440
And again like these are
再说一次，这些都是暗示，

336
00:08:30,100 --> 00:08:31,720
0,150 150,810 1080,1260 1260,1470 1500,1620
all hints,| you should you
|对于所有这些，

337
00:08:31,720 --> 00:08:33,040
0,450 480,600 600,1050 1050,1170 1170,1320
should you know for all

338
00:08:33,040 --> 00:08:33,940
0,60 60,270 270,360 360,480 480,900
of these,| you should consider
|你应该考虑它，

339
00:08:33,940 --> 00:08:35,050
0,90 90,660 660,930 930,1050 1050,1110
it as,| only if it
|你确定它有帮助的时候。

340
00:08:35,050 --> 00:08:36,780
0,420 420,570 570,660 660,1170
helps you can decide.|
|

341
00:08:38,260 --> 00:08:39,520
0,180 180,540 540,930 930,1080 1080,1260
So one problem with this
所以，这个提示的一个问题是，

342
00:08:39,520 --> 00:08:40,840
0,450 480,660 660,840 840,1110 1110,1320
hint is that,| not all
|并不是所有的程序都有权完全控制它们的控制流，

343
00:08:40,840 --> 00:08:42,730
0,570 570,780 780,900 900,1470 1470,1890
programs have the luxury of

344
00:08:42,850 --> 00:08:44,470
0,480 480,900 900,1320 1320,1470 1470,1620
having complete control over their

345
00:08:44,470 --> 00:08:46,960
0,360 360,750 1080,1620 1650,2130 2220,2490
control flow,| so {you,know} here's
|所以这里有一个不同的例子，

346
00:08:46,960 --> 00:08:48,310
0,90 90,360 360,930 930,1290 1290,1350
a different example,| instead of
|不是有一个可以调用的 readChar 函数，

347
00:08:48,310 --> 00:08:49,570
0,300 300,450 450,690 690,1080 1140,1260
having a {readChar,function - -}

348
00:08:49,570 --> 00:08:51,190
0,150 150,300 300,420 420,1080 1260,1620
that can be called,| this
|这个代码是使用 ProcessChar 方法，

349
00:08:51,190 --> 00:08:52,510
0,240 240,390 390,720 720,900 900,1320
code is written to have

350
00:08:52,510 --> 00:08:54,130
0,150 150,690 690,990 990,1440 1440,1620
a {ProcessChar -} method,| that
|你必须一次传递给一个字符，

351
00:08:54,130 --> 00:08:54,970
0,150 150,330 330,420 420,750 750,840
you have to hand the

352
00:08:54,970 --> 00:08:56,080
0,450 450,600 600,930 930,1020 1020,1110
character to one at a

353
00:08:56,080 --> 00:08:56,980
0,390
time,|
|

354
00:08:57,010 --> 00:08:58,420
0,120 120,270 270,690 690,1140 1170,1410
and then {ProcessChar -} has
然后 ProcessChar 别无选择，

355
00:08:58,420 --> 00:09:00,640
0,210 210,660 660,1170 1260,1710 1710,2220
no choice really,| but to
|只能编码 state 到一个显示的 state 变量，

356
00:09:00,850 --> 00:09:02,200
0,240 240,750 750,1140 1140,1230 1230,1350
{you,know} encoded state in an

357
00:09:02,200 --> 00:09:04,120
0,450 450,720 720,1110 1110,1560 1560,1920
explicit state variable,| because after
|因为在每个字符之后，它必须返回，

358
00:09:04,120 --> 00:09:05,020
0,210 210,570 570,660 660,810 810,900
every character, it has to

359
00:09:05,020 --> 00:09:07,060
0,480 480,780 780,1140 1440,1620 1620,2040
return back out,| and so
|所以它不能保存 state 在程序计数器和栈中，

360
00:09:07,150 --> 00:09:08,110
0,150 150,420 420,630 630,720 720,960
it can't save the state

361
00:09:08,110 --> 00:09:09,040
0,90 90,150 150,480 480,750 750,930
at the program counter and

362
00:09:09,040 --> 00:09:10,060
0,390 390,480 480,720 720,810 810,1020
stack,| it has to have
|它必须有 state 在实际变量中。

363
00:09:10,060 --> 00:09:11,830
0,60 60,570 960,1290 1290,1410 1410,1770
the state in an actual

364
00:09:11,830 --> 00:09:12,840
0,600
variable.|
|

365
00:09:13,550 --> 00:09:15,560
0,720 1020,1290 1290,1710 1710,1830 1830,2010
But in Go, we have
但是在 Go 中，我们有另一个选择，

366
00:09:15,560 --> 00:09:17,180
0,300 300,930 960,1230 1230,1500 1500,1620
another choice, right,| because we
|因为我们不能把 state 保存到栈和程序计数器中，

367
00:09:17,180 --> 00:09:18,290
0,300 300,510 510,570 570,930 930,1110
can't save the state on

368
00:09:18,290 --> 00:09:19,550
0,270 270,720 750,900 900,990 990,1260
that stack and in that

369
00:09:19,550 --> 00:09:21,800
0,330 330,840 1200,1680 1740,2100 2100,2250
program counter,| but we can
|但我们可以创建另一个 goroutine 为我们保持状态。

370
00:09:21,800 --> 00:09:23,270
0,180 180,450 450,630 630,1230 1290,1470
make another {goroutine -} to

371
00:09:23,270 --> 00:09:25,700
0,210 210,360 360,660 660,1230 2220,2430
hold that state {for,us}.| So
|所以，假设我们已经有这个调试 readString 函数，

372
00:09:25,700 --> 00:09:27,260
0,480 480,600 600,900 900,1170 1170,1560
supposing we already have this

373
00:09:27,260 --> 00:09:29,390
0,480 480,720 720,1020 1020,1590 1860,2130
debug {readString -} function,| that
|我们不想以其他方式重写，

374
00:09:29,390 --> 00:09:30,470
0,120 120,450 450,690 690,900 900,1080
we really don't want to

375
00:09:30,500 --> 00:09:32,030
0,600 600,690 690,840 840,1110 1110,1530
rewrite in this other way,|
|

376
00:09:32,060 --> 00:09:32,900
0,120 120,300 300,450 450,510 510,840
we just want to {reuse,it},|
我们只是想重复使用它，|

377
00:09:32,900 --> 00:09:34,490
0,360 360,930 930,1170 1170,1320 1320,1590
it works,| maybe it's really
它可以工作，|也许它很大很复杂，

378
00:09:34,490 --> 00:09:35,600
0,270 270,630 630,810 810,990 990,1110
{big,and} hairy,| it's much more
|它比我们看到的任何东西都要复杂，

379
00:09:35,600 --> 00:09:37,130
0,510 510,630 630,870 870,960 960,1530
complicated than anything we saw,|
|

380
00:09:37,310 --> 00:09:38,360
0,420 420,570 570,690 690,750 750,1050
we just want to reuse
我们只是想重复使用它。

381
00:09:38,360 --> 00:09:39,380
0,180 510,660 660,780 780,870 870,1020
it.| And so the way
|所以，我们在 Go 中做到的方法是，

382
00:09:39,380 --> 00:09:40,130
0,120 120,240 240,390 390,630 630,750
we can do that in

383
00:09:40,130 --> 00:09:41,210
0,330 330,510 510,600 600,720 720,1080
Go is,| we can start
|我们可以启动一个新的 goroutine 来完成 readString 部分，

384
00:09:41,210 --> 00:09:43,010
0,60 60,240 240,960 1230,1530 1530,1800
a new goroutine that does

385
00:09:43,010 --> 00:09:44,030
0,120 120,300 300,570 570,810 810,1020
the {readString -} part,| it's
|readString 与之前相同，

386
00:09:44,030 --> 00:09:45,290
0,90 90,600 600,780 780,1050 1050,1260
the same {readString -} code

387
00:09:45,290 --> 00:09:46,610
0,120 120,690 690,810 810,1170 1170,1320
as before,| we pass in
|我们传递[字符读取]。

388
00:09:46,610 --> 00:09:47,920
0,60 60,540 540,990
the character reader.|
|

389
00:09:48,070 --> 00:09:51,250
0,150 150,390 390,900 1830,2610 2640,3180
And now here {you,know,the} Init
现在， Init 方法使这个 goroutine 执行字符读取，

390
00:09:51,250 --> 00:09:52,480
0,630
method

391
00:09:52,480 --> 00:09:53,890
0,330 330,870 870,1020 1020,1320 1320,1410
makes this {goroutine -} to

392
00:09:53,890 --> 00:09:55,600
0,360 390,510 510,930 930,1320 1320,1710
do the character reading,| and
|然后，每次调用 ProcessChar 方法时，

393
00:09:55,600 --> 00:09:56,950
0,180 180,420 420,750 750,870 870,1350
then every time the {ProcessChar

394
00:09:56,950 --> 00:10:00,490
0,750 840,1230 1230,1350 1350,2100 3300,3540
-} method is called,| we
|我们通过 char channel 发送一个消息给 goroutine ，

395
00:10:00,490 --> 00:10:01,600
0,360 360,480 480,930 930,1020 1020,1110
send a message to the

396
00:10:01,600 --> 00:10:02,620
0,150 150,480 480,630 630,690 690,1020
{goroutine -} on the char

397
00:10:02,620 --> 00:10:04,000
0,360 360,510 510,960 990,1290 1290,1380
channel,| that says here's the
|表示这是下一个字符，

398
00:10:04,000 --> 00:10:05,650
0,240 240,960 1230,1410 1410,1530 1530,1650
next character,| and then we
|然后我们收到一条消息，

399
00:10:05,650 --> 00:10:06,790
0,420 420,480 480,810 810,1050 1050,1140
receive a message back,| that
|表示告诉我当前的 status ，

400
00:10:06,790 --> 00:10:07,870
0,330 330,570 570,690 690,780 780,1080
says tell me the current

401
00:10:07,870 --> 00:10:09,130
0,450 450,540 540,630 630,840 840,1260
status,| and the current status
|当前 status 总是，

402
00:10:09,130 --> 00:10:10,540
0,90 90,450 450,1020 1080,1230 1230,1410
is always,| either I need
|要么是我需要更多的输入

403
00:10:10,540 --> 00:10:12,910
0,180 180,720 1050,1740 1770,1920 1920,2370
more input| or you know
|或者它是不是好的。

404
00:10:13,000 --> 00:10:15,040
0,1560 1560,1650 1650,1770 1770,1950 1950,2040
basically you know was it

405
00:10:15,040 --> 00:10:16,100
0,270 270,360 360,720
okay or not.|
|

406
00:10:16,620 --> 00:10:18,740
0,300 300,600 600,1110
And so {}
所以，

407
00:10:18,770 --> 00:10:20,270
0,300 300,570 570,780 780,930 930,1500
{you,know},| this lets us move
|这让我们可以移动程序计数器，

408
00:10:20,270 --> 00:10:22,580
0,540 900,1410 1410,1650 1650,2010 2010,2310
the {} the program counter,|
|

409
00:10:22,580 --> 00:10:23,720
0,120 120,420 450,870 870,1020 1020,1140
that we couldn't do on
那个我们不能在第一个栈上完成的，

410
00:10:23,720 --> 00:10:24,770
0,90 90,360 360,720 720,930 930,1050
the first stack| into the
|到 goroutine 的另一个栈中。

411
00:10:24,770 --> 00:10:25,640
0,240 240,570 570,660 660,750 750,870
other stack of the {goroutine

412
00:10:25,640 --> 00:10:27,740
0,480 720,960 960,1290 1320,1650 1650,2100
-}.| And so using additional
|所以，使用额外的 goroutine 是保存额外代码状态的好方法，

413
00:10:27,740 --> 00:10:29,090
0,420 420,540 540,660 660,1110 1110,1350
goroutines is a great way

414
00:10:29,090 --> 00:10:30,770
0,120 120,750 750,1170 1170,1440 1440,1680
to hold additional code state,|
|

415
00:10:30,770 --> 00:10:32,210
0,210 210,480 480,780 780,900 900,1440
and give you the ability
并让你有能力进行这种清理，

416
00:10:32,210 --> 00:10:33,020
0,120 120,300 300,480 480,720 720,810
to do these kinds of

417
00:10:33,020 --> 00:10:34,940
0,660 810,1170 1170,1320 1320,1440 1440,1920
cleanups,| even if the original
|即使问题的原始结构看起来做不到。

418
00:10:34,940 --> 00:10:36,710
0,390 390,840 840,960 960,1500 1530,1770
structure of the problem makes

419
00:10:36,710 --> 00:10:37,730
0,90 90,330 330,510 510,600 600,1020
it look like you can't.|
|

420
00:10:40,600 --> 00:10:44,680
0,480 1560,1650 1650,2160 2160,2490 3240,4080
Russ.| Go ahead.| I assume
Russ 。|继续。|我想你不介意别人问你问题。

421
00:10:44,680 --> 00:10:45,850
0,120 120,360 360,480 480,930 930,1170
you're fine with people asking

422
00:10:45,850 --> 00:10:47,530
0,510 540,750 750,1290 1290,1530 1530,1680
questions.| Yeah, absolutely.| I just
|是的，当然。|我只是想确认一下。

423
00:10:47,530 --> 00:10:49,240
0,180 180,240 240,360 360,660 1020,1710
wanted to make {sure,that}.| Yeah,
|是的，当然可以，请随意打断。

424
00:10:49,240 --> 00:10:52,960
0,420 420,840 840,1350 1830,2430 3120,3720
definitely, please interrupt.| {} So,so
|所以，这里的提示是

425
00:10:52,960 --> 00:10:53,890
0,270 270,480 480,690 690,810 810,930
the hint here is| to
|使用额外的 goroutine 来保存额外的代码状态，

426
00:10:53,890 --> 00:10:55,870
0,210 210,600 600,1380 1380,1500 1500,1980
use additional goroutines to hold

427
00:10:55,870 --> 00:10:57,880
0,390 390,660 660,1050 1320,1800 1800,2010
additional code state,| and there's
|但有一点需要注意，

428
00:10:57,880 --> 00:10:59,770
0,180 180,690 930,1440 1440,1530 1530,1890
there's one caveat to this,|
|

429
00:10:59,770 --> 00:11:01,240
0,120 120,240 240,420 420,780 780,1470
and {} it's not free
创建 goroutine 不是免费的，

430
00:11:01,270 --> 00:11:03,040
0,660 660,900 900,1110 1110,1290 1290,1770
to just make {goroutines -},

431
00:11:03,040 --> 00:11:03,790
0,180 180,270 270,450 450,510 510,750
right,| you have to actually
|你必须确保它们退出，

432
00:11:03,790 --> 00:11:04,840
0,150 150,330 330,450 450,570 570,1050
make sure that they exit,|
|

433
00:11:04,930 --> 00:11:06,370
0,270 270,630 630,780 780,960 960,1440
because otherwise you'll just accumulate
否则，你会把它们累积起来。

434
00:11:06,370 --> 00:11:07,080
0,270
them.|
|

435
00:11:07,080 --> 00:11:07,740
0,120 120,210 210,420 420,540 540,660
And so you have to
所以你必须考虑，

436
00:11:07,740 --> 00:11:09,420
0,300 300,870 1170,1440 1440,1590 1590,1680
think about,| {} you know
|为什么 goroutine 会离开，

437
00:11:09,420 --> 00:11:10,560
0,480 480,630 630,720 720,870 870,1140
why does the {goroutine -}

438
00:11:10,560 --> 00:11:11,850
0,330 330,780 810,930 930,1080 1080,1290
exit,| like you know is
|比如它会被清理干净吗。

439
00:11:11,850 --> 00:11:12,690
0,150 150,360 360,420 420,570 570,840
it going to get cleaned

440
00:11:12,690 --> 00:11:14,430
0,360 540,750 750,840 840,1050 1050,1740
up.| And in this case,|
|在这种情况下，|

441
00:11:14,830 --> 00:11:15,970
0,210 210,420 420,840 840,930 930,1140
we know that you know
我们知道 q.parse 将会返回，

442
00:11:15,970 --> 00:11:17,500
0,180 180,450 450,1110 1140,1410 1410,1530
{q.parse - -} is going

443
00:11:17,500 --> 00:11:19,080
0,60 60,990
to return,|
|

444
00:11:19,480 --> 00:11:20,560
0,210 210,300 300,390 390,630 630,1080
where {q.parse - -} go.|
q.parse 在哪里。|

445
00:11:22,390 --> 00:11:24,370
0,330 330,480 480,630 630,990 1140,1980
Sorry that's not right {}.|
抱歉，这不对。|

446
00:11:26,420 --> 00:11:27,470
0,180 180,450 450,570 570,810 810,1050
Oh, sorry, the {readString -}
哦，抱歉，这里的 readString ，

447
00:11:27,470 --> 00:11:28,280
0,210 210,390 390,600 600,690 690,810
here,| {readString -} is going
|readString 会返回，

448
00:11:28,280 --> 00:11:29,600
0,60 60,420 420,840 840,930 930,1320
to return,| anytime it sends
|任何时候它发送一个消息，表示需要更多输入。

449
00:11:29,600 --> 00:11:31,220
0,660 660,1020 1020,1170 1170,1440 1440,1620
a message, that says need

450
00:11:31,220 --> 00:11:32,420
0,180 180,690
more input.|
|

451
00:11:32,450 --> 00:11:33,620
0,150 150,210 210,630 810,960 960,1170
Where it go, there's something
在哪里，这张幻灯片遗漏了一些东西。

452
00:11:33,620 --> 00:11:35,180
0,300 300,420 420,540 540,960
missing from this slide.|
|

453
00:11:38,600 --> 00:11:39,800
0,720
Sorry,
抱歉，我昨晚才写的这些。

454
00:11:39,950 --> 00:11:40,730
0,90 90,240 240,390 390,540 540,780
I write this until last

455
00:11:40,730 --> 00:11:41,680
0,330
night.|
|

456
00:11:41,680 --> 00:11:43,180
0,870

457
00:11:43,870 --> 00:11:45,130
0,600 630,810 810,990 990,1080 1080,1260
So so as we go
所以当我们进去的时候，我们进入了 Init ，

458
00:11:45,130 --> 00:11:45,940
0,210 210,300 300,480 480,690 690,810
in, we go into {Init

459
00:11:45,940 --> 00:11:47,440
0,360 780,1050 1050,1200 1200,1380 1380,1500
-},| we kick off this
|我们启动这个 goroutine ，

460
00:11:47,440 --> 00:11:48,340
0,150 150,390 390,540 540,690 690,900
{goroutine -},| that's gonna call
|它将多次调用 ReadChar ，

461
00:11:48,340 --> 00:11:49,120
0,210 210,450 450,510 510,720 720,780
{readChar -} a bunch of

462
00:11:49,120 --> 00:11:50,470
0,720 720,900 900,1020 1020,1170 1170,1350
times,| and then we read
|然后我们读取一次 status ，

463
00:11:50,470 --> 00:11:51,940
0,90 90,480 480,930 930,1080 1080,1470
the status once| and that
|第一个 status 就会发生，

464
00:11:51,940 --> 00:11:52,960
0,240 240,660 660,810 810,960 960,1020
first status is going to

465
00:11:52,960 --> 00:11:55,630
0,630 660,1620 1830,2250 2250,2400 2400,2670
happen,| because the the first
|因为第一次调用 readString 的 ReadChar

466
00:11:55,630 --> 00:11:56,770
0,240 240,390 390,660 660,930 930,1140
call to {readChar -} from

467
00:11:56,770 --> 00:11:57,820
0,210 210,570 570,690 690,810 810,1050
{readString -}| is going to
|会说我需要更多的输入，

468
00:11:57,850 --> 00:11:58,780
0,240 240,420 420,750 750,840 840,930
{saying,I,need} more input,| and then
|然后我们会发回一个字符，

469
00:11:58,780 --> 00:11:59,260
0,90 90,210 210,270 270,420 420,480
we're going to send a

470
00:11:59,260 --> 00:12:00,400
0,360 360,750
character back,|
|

471
00:12:01,080 --> 00:12:02,100
0,450 540,780 780,840 840,960 960,1020
we're going to send the
我们会在 ProcessChar 中发回字符，

472
00:12:02,100 --> 00:12:03,780
0,330 330,600 600,690 690,1110 1110,1680
character back in {ProcessChar -},|
|

473
00:12:04,110 --> 00:12:05,310
0,180 180,450 450,660 660,870 870,1200
and then every time {ProcessChar
然后，每次调用 ProcessChar 时，它返回一个 status ，

474
00:12:05,310 --> 00:12:06,900
0,210 210,360 360,990 1020,1230 1230,1590
-} gets called, it returns

475
00:12:06,900 --> 00:12:08,460
0,60 60,870 930,1110 1110,1350 1350,1560
a status,| and so up
|所以直到你需要更多的输入，

476
00:12:08,460 --> 00:12:10,140
0,270 270,420 420,930 960,1500 1530,1680
until you get, {} you

477
00:12:10,140 --> 00:12:11,460
0,270 300,570 570,750 750,1200 1200,1320
know need more input,| you're
|你会得到。

478
00:12:11,460 --> 00:12:12,630
0,120 120,180 180,450 450,690 690,1170
going to get the {}.|
|

479
00:12:15,000 --> 00:12:16,200
0,450 480,660 660,720 720,870 870,1200
Sorry, this is not working,|
抱歉，这不起作用，|

480
00:12:16,560 --> 00:12:18,000
0,630 780,1020 1020,1080 1080,1260 1260,1440
you're going to get any
每次你想读取一个字符时，都会得到更多的输入。

481
00:12:18,000 --> 00:12:18,930
0,150 150,420 420,540 540,750 750,930
more input for every time

482
00:12:18,930 --> 00:12:19,350
0,90 90,210 210,270 270,390 390,420
you want to read a

483
00:12:19,350 --> 00:12:20,640
0,750
character.|
|

484
00:12:20,850 --> 00:12:21,630
0,210 210,300 300,420 420,570 570,780
And then when it's done
然后当它完成读取字符后，

485
00:12:21,630 --> 00:12:22,860
0,240 240,720 720,870 870,930 930,1230
reading characters,| what I haven't
|我在这里没有展示的，似乎是遗漏的东西，

486
00:12:22,860 --> 00:12:24,360
0,300 300,390 390,930 990,1320 1320,1500
shown you here, what seems

487
00:12:24,360 --> 00:12:26,520
0,60 60,150 150,690 720,1470 1500,2160
to be missing somehow,| is
|当事情退出时。

488
00:12:26,550 --> 00:12:28,530
0,330 330,570 570,1080 1350,1740 1740,1980
when things exit and when

489
00:12:28,530 --> 00:12:30,060
0,210 210,840 1140,1350 1350,1440 1440,1530
things exit.| Let's see, if
|让我们看看，它是否在这张幻灯片上。

490
00:12:30,060 --> 00:12:31,500
0,90 90,210 210,330 330,840 1140,1440
it's on this slide.| Yeah,
|是的，所以有一个 return Success 和一个 return BadInput ，

491
00:12:31,500 --> 00:12:32,790
0,150 150,330 330,420 420,780 780,1290
so there's a return Success

492
00:12:32,790 --> 00:12:33,930
0,90 90,150 150,480 480,720 720,1140
and a return {BadInput -},|
|

493
00:12:33,930 --> 00:12:35,480
0,150 150,300 300,660 660,1050
that I'd forgotten about.|
这是我忘记的。|

494
00:12:35,480 --> 00:12:36,950
0,150 150,780 900,1290 1320,1410 1410,1470
And so, {} you know
所以，这些返回不同的 status ，然后就完成了。

495
00:12:36,950 --> 00:12:38,360
0,270 270,600 600,900 900,1290 1290,1410
these returning different status and

496
00:12:38,360 --> 00:12:40,190
0,120 120,270 270,690 1320,1590 1590,1830
then they're done.| So when
|所以，当 ProcessChar ，

497
00:12:40,190 --> 00:12:43,100
0,420 420,1230 1320,1920 1920,2340 2340,2910
{ProcessChar -},| {} in in
|在 readString 版本中，

498
00:12:43,100 --> 00:12:44,630
0,90 90,270 270,510 510,1170 1230,1530
the {readString -} version,| when
|当它返回 BadInput 或 Success 时，

499
00:12:44,630 --> 00:12:46,550
0,180 180,1080 1140,1620 1620,1860 1860,1920
it returns {BadInput -} or

500
00:12:46,550 --> 00:12:48,110
0,630 630,1080 1080,1290 1290,1500 1500,1560
Success,| we say that you
|这件事已经完成了。

501
00:12:48,110 --> 00:12:49,100
0,120 120,270 270,540 540,660 660,990
know it's done.| And so
|当调用者继续，

502
00:12:49,430 --> 00:12:51,110
0,210 210,450 450,570 570,690 690,1680
as long as the caller

503
00:12:51,170 --> 00:12:53,020
0,300 300,660 660,1410
is going through,|
|

504
00:12:53,520 --> 00:12:55,860
0,900 1140,1290 1290,1410 1410,1920 1920,2340
and you know calling until
调用直到它得到一些东西，不需要更多输入，

505
00:12:55,860 --> 00:12:57,120
0,90 90,330 330,660 660,870 870,1260
it gets something, that's not

506
00:12:57,120 --> 00:12:58,950
0,180 180,360 360,810 960,1650 1680,1830
need more input,| then the
|然后 goroutine 就会结束，

507
00:12:58,950 --> 00:13:00,390
0,210 210,420 420,540 540,990 990,1440
{goroutine -} will finish,| but
|但是如果我们早点停止，

508
00:13:00,540 --> 00:13:01,890
0,480 480,600 600,720 720,1080 1080,1350
maybe if we stop early,|
|

509
00:13:01,890 --> 00:13:03,060
0,90 90,180 180,690 690,930 930,1170
if the caller hits an
如果调用者遇到 EOF 并自动停止，

510
00:13:03,060 --> 00:13:03,990
0,90 90,330 330,450 450,810 810,930
{EOF -} and stops on

511
00:13:03,990 --> 00:13:05,190
0,150 150,360 360,690 690,990 990,1200
its own,| without telling us
|没有告诉我们已经完成，

512
00:13:05,190 --> 00:13:06,510
0,120 120,300 300,810 840,1230 1230,1320
that it's done,| there's a
|会有一个 goroutine 剩下，

513
00:13:06,510 --> 00:13:08,250
0,420 420,1110 1170,1440 1440,1530 1530,1740
goroutine leftover,| and so that
|所以，这会是一个问题。

514
00:13:08,250 --> 00:13:09,520
0,90 90,210 210,300 300,780
could be a problem.|
|

515
00:13:09,610 --> 00:13:10,510
0,120 120,390 390,570 570,780 780,900
And so you just you
所以你需要确保，

516
00:13:10,510 --> 00:13:11,200
0,150 150,240 240,420 420,600 600,690
need to make sure that|
|

517
00:13:11,200 --> 00:13:12,610
0,90 90,240 240,630 630,810 810,1410
you know when and why
什么时候以及为什么 goroutine 会退出，

518
00:13:12,820 --> 00:13:14,230
0,300 300,450 450,780 780,930 930,1410
each {goroutine -} will exit,|
|

519
00:13:14,710 --> 00:13:15,940
0,360 360,450 450,810 810,990 990,1230
and the nice thing is
好的是，

520
00:13:15,940 --> 00:13:16,810
0,240 240,390 390,510 510,660 660,870
that,| if you do make
|如果你出现一个错误，

521
00:13:16,810 --> 00:13:18,190
0,30 30,690 870,1050 1050,1140 1140,1380
a mistake| and you leave
|你让 goroutine 卡住了，

522
00:13:18,190 --> 00:13:20,110
0,420 420,900 1110,1440 1440,1710 1710,1920
goroutine stuck,| they just sit
|它们只是在那里，

523
00:13:20,110 --> 00:13:21,100
0,240 240,360 360,510 510,660 660,990
there,| it's like the best
|像是世界上最好的 bug ，

524
00:13:21,100 --> 00:13:22,330
0,510 510,750 750,840 840,930 930,1230
possible bug in the world,|
|

525
00:13:22,330 --> 00:13:23,410
0,240 240,360 360,600 600,780 780,1080
because they just sit around,
因为它们只是在那里，等着你看它们，

526
00:13:23,410 --> 00:13:24,160
0,300 300,390 390,450 450,540 540,750
waiting for you to look

527
00:13:24,160 --> 00:13:24,670
0,90 90,240 240,330 330,450 450,510
at them,| and all you
|你要做的就是记住去寻找它们。

528
00:13:24,670 --> 00:13:25,390
0,90 90,180 180,300 300,420 420,720
have to do is remember

529
00:13:25,390 --> 00:13:26,620
0,60 60,270 270,420 420,600 990,1230
to look for them.| And
|所以这是一个非常简单的程序，

530
00:13:26,620 --> 00:13:28,180
0,240 240,930 930,990 990,1230 1230,1560
so here's a very simple

531
00:13:28,180 --> 00:13:29,240
0,630
program,|
|

532
00:13:29,270 --> 00:13:30,620
0,270 270,510 510,660 660,1200 1200,1350
and these {goroutines -} and
这些 goroutine 运行一个 http 服务，

533
00:13:30,620 --> 00:13:31,910
0,90 90,300 300,390 390,840 840,1290
it runs an http server,|
|

534
00:13:32,150 --> 00:13:33,530
0,390 390,750 780,1050 1050,1140 1140,1380
and so if we run
如果我们运行这个程序，

535
00:13:33,530 --> 00:13:34,610
0,480 510,660 660,900 900,1020 1020,1080
this,| it kicks off a
|它会启动很多 f goroutine ，

536
00:13:34,610 --> 00:13:35,420
0,150 150,360 360,450 450,660 660,810
whole bunch of f {goroutines

537
00:13:35,420 --> 00:13:37,760
0,720 780,1140 1140,1320 1320,1920 1920,2340
-},| and they all block
|它们都会阻塞尝试发送到一个 channel ，

538
00:13:37,760 --> 00:13:38,450
0,240 240,300 300,540 540,630 630,690
trying to send to a

539
00:13:38,450 --> 00:13:39,560
0,510 570,750 750,840 840,900 900,1110
channel,| and then it makes
|然后它成为 http 服务器。

540
00:13:39,560 --> 00:13:40,960
0,120 120,540 540,960
the http server.|
|

541
00:13:40,990 --> 00:13:41,620
0,150 150,270 270,360 360,420 420,630
And so if I run
所以如果我运行这个程序，它就会停在那里，

542
00:13:41,620 --> 00:13:42,820
0,150 150,690 720,840 840,1020 1020,1200
this program, it just sits

543
00:13:42,820 --> 00:13:44,140
0,540 750,900 900,990 990,1080 1080,1320
there,| and if I type
|如果我在 Unix 系统上输入 ^\ ，

544
00:13:44,140 --> 00:13:45,550
0,270 270,930 930,1080 1080,1140 1140,1410
control backslash on a Unix

545
00:13:45,550 --> 00:13:46,450
0,420 420,480 480,630 630,690 690,900
system,| I get a {SIGQUIT
|我得到一个 SIGQUIT ，

546
00:13:46,450 --> 00:13:48,400
0,600 960,1230 1230,1440 1440,1530 1530,1950
-},| which makes it crash
|这使它崩溃，并 dump 出 goroutine 上的所有栈。

547
00:13:48,400 --> 00:13:49,450
0,150 150,390 390,600 600,690 690,1050
and dump all the stacks

548
00:13:49,450 --> 00:13:50,740
0,90 90,150 150,300 300,930 1140,1290
on the {goroutines -}.| And
|你可以在幻灯片上看到，

549
00:13:50,740 --> 00:13:51,520
0,120 120,240 240,540 540,660 660,780
you can see on the

550
00:13:51,520 --> 00:13:52,750
0,390 390,660 690,1020 1020,1170 1170,1230
slide,| {you,know} it's going to
|它会一遍又一遍地打印，

551
00:13:52,750 --> 00:13:53,680
0,150 150,390 390,480 480,660 660,930
print over and over again,|
|

552
00:13:53,680 --> 00:13:54,550
0,210 210,270 270,420 420,720 720,870
here's a {goroutine -} and
这是一个 goroutine ， h 调用自 g 调用自 f ，

553
00:13:54,550 --> 00:13:55,630
0,240 240,510 510,630 630,840 840,1080
h call from g call

554
00:13:55,630 --> 00:13:56,540
0,120 120,480
from f,|
|

555
00:13:56,570 --> 00:13:57,920
0,210 210,570 570,630 630,960 960,1350
and in the channel send.|
在 channel send 中。|

556
00:13:58,970 --> 00:13:59,510
0,180 180,240 240,360 360,480 480,540
And if you look at
如果你看一下行号，

557
00:13:59,510 --> 00:14:00,410
0,90 90,300 300,630 630,780 780,900
the line numbers,| you can
|你可以确切地看到它们在哪里。

558
00:14:00,410 --> 00:14:01,640
0,150 150,540 540,690 690,810 810,1230
see exactly where they are.|
|

559
00:14:02,740 --> 00:14:04,270
0,360 360,930 930,1110 1110,1320 1320,1530
Another option is that,| since
另一种选择是，|因为我们是在 http 服务器中，

560
00:14:04,270 --> 00:14:05,860
0,150 150,240 240,330 330,810 810,1590
we're in an http server,|
|

561
00:14:06,560 --> 00:14:07,910
0,510 510,690 690,810 810,1110 1110,1350
{} and the http server
http 服务器导入了 net http pprof 包，

562
00:14:07,910 --> 00:14:09,830
0,510 510,630 630,990 990,1560 1560,1920
imports the net http pprof

563
00:14:09,830 --> 00:14:11,330
0,600 690,960 960,1080 1080,1320 1320,1500
package,| you can actually just
|你可以访问 http 服务器的 /debug/pprof/goroutine 链接，

564
00:14:11,330 --> 00:14:13,130
0,300 300,450 450,870 870,1320 1320,1800
visit the http server's {/debug/pprof/goroutine

565
00:14:13,130 --> 00:14:15,180
0,390 390,540 540,840 840,1590
- - -} url,|
|

566
00:14:15,210 --> 00:14:16,410
0,210 210,390 390,720 720,870 870,1200
which gives you the stacks
这会给你所有运行的 goroutine 的堆栈，

567
00:14:16,410 --> 00:14:17,160
0,120 120,300 300,390 390,600 600,750
of all the running {goroutines

568
00:14:17,160 --> 00:14:18,960
0,630 810,1050 1050,1350 1350,1440 1440,1800
-},| and unlike the crash
|与 crash dump 不同，

569
00:14:18,960 --> 00:14:20,250
0,510 540,840 840,1050 1050,1110 1110,1290
dump,| it takes a little
|它做了更多的努力，

570
00:14:20,250 --> 00:14:22,020
0,210 210,630 630,720 720,1170 1170,1770
more effort| and it duplicates
|它根据它们的堆栈复制 goroutine ，

571
00:14:22,020 --> 00:14:23,130
0,90 90,570 570,870 870,990 990,1110
the goroutines based on their

572
00:14:23,130 --> 00:14:25,380
0,750 960,1200 1200,1530 1530,2130 2130,2250
stacks,| and so and then
|然后根据每个堆栈的[数量]对它们进行排序，

573
00:14:25,380 --> 00:14:26,340
0,90 90,480 480,600 600,750 750,960
it sorts them by how

574
00:14:26,340 --> 00:14:27,240
0,240 240,420 420,660 660,750 750,900
many there are of each

575
00:14:27,240 --> 00:14:27,960
0,360 360,450 450,570 570,660 660,720
stack,| and so if you
|所以如果你有 goroutine [泄漏]，

576
00:14:27,960 --> 00:14:29,070
0,90 90,180 180,330 330,690 690,1110
have a {goroutine -} leak,|
|

577
00:14:29,370 --> 00:14:30,300
0,240 240,480 480,750 750,840 840,930
the leak shows up at
[泄漏]出现在最高层。

578
00:14:30,300 --> 00:14:31,200
0,60 60,330 330,690 690,840 840,900
the very top.| So in
|在本例中，

579
00:14:31,200 --> 00:14:31,890
0,150 150,420 420,510 510,630 630,690
this case,| you've got a
|你获得 100 个 goroutine 堆栈，

580
00:14:31,890 --> 00:14:33,330
0,360 360,510 510,870 870,1290 1290,1440
hundred {goroutines -} stack| in
|h 调用自 g 调用自 f ，

581
00:14:33,330 --> 00:14:34,500
0,270 270,540 540,690 690,900 900,1170
h called from g called

582
00:14:34,500 --> 00:14:35,760
0,120 120,570 810,1080 1080,1170 1170,1260
from f,| and then we
|然后我们可以看到还有其他 goroutine ，

583
00:14:35,760 --> 00:14:36,780
0,120 120,210 210,510 510,930 930,1020
can see there's one of

584
00:14:36,780 --> 00:14:37,860
0,90 90,360 360,510 510,990 990,1080
a couple other goroutines {},|
|

585
00:14:37,860 --> 00:14:38,730
0,90 90,240 240,420 420,600 600,870
we don't really care about
我们并不是关心它们。

586
00:14:38,730 --> 00:14:39,380
0,270
them.|
|

587
00:14:39,670 --> 00:14:40,450
0,150 150,480 480,570 570,690 690,780
And so you know this
所以这是一个新的暗示，

588
00:14:40,450 --> 00:14:41,200
0,60 60,120 120,240 240,510 510,750
is a new hint that,|
|

589
00:14:41,470 --> 00:14:42,730
0,180 180,390 450,630 630,990 990,1260
it just it's really really
它非常有用，

590
00:14:42,730 --> 00:14:44,110
0,450 450,540 540,840 840,1080 1080,1380
useful| to look for stack
|通过这个端点获取 goroutine 堆栈。

591
00:14:44,110 --> 00:14:45,670
0,150 150,600 600,780 780,1170 1230,1560
{goroutines -} by just going

592
00:14:45,670 --> 00:14:47,040
0,120 120,270 270,750
to this endpoint.|
|

593
00:14:48,240 --> 00:14:49,830
0,420 930,1170 1170,1350 1350,1440 1440,1590
Alright, so that was kind
好的，这算是热身了。

594
00:14:49,830 --> 00:14:51,240
0,60 60,150 150,360 360,810 1020,1410
of the warm up {}.|
|

595
00:14:51,720 --> 00:14:52,440
0,270 270,360 360,510 510,570 570,720
Now I want to look
现在我想看看第一个真正的并发模式，

596
00:14:52,440 --> 00:14:54,000
0,90 90,240 240,600 720,1110 1110,1560
at the first real concurrency

597
00:14:54,000 --> 00:14:54,960
0,330 330,480 480,570 570,660 660,960
pattern,| which is a publish
|就是发布订阅服务器。

598
00:14:54,960 --> 00:14:56,320
0,450 450,870
subscribe server.|
|

599
00:14:56,690 --> 00:14:57,920
0,300 300,570 570,1080 1080,1170 1170,1230
So publish subscribe is a
发布订阅是组织程序的一种方式，

600
00:14:57,920 --> 00:14:59,330
0,150 150,270 270,720 720,810 810,1410
way of structuring a program,|
|

601
00:14:59,450 --> 00:15:00,800
0,300 300,450 450,930 930,1050 1050,1350
that you decouple the parts,|
你将不同部分解耦，|

602
00:15:00,800 --> 00:15:02,420
0,120 120,240 240,720 720,1080 1080,1620
that are publishing interesting events
将发布有趣事件的部分与订阅它们的部分（解耦），

603
00:15:02,510 --> 00:15:03,380
0,300 300,420 420,660 660,780 780,870
from the things that are

604
00:15:03,380 --> 00:15:04,880
0,600 600,750 750,1020 1140,1290 1290,1500
subscribing to them,| and there's
|中间有一个发布订阅服务器，连接这些，

605
00:15:04,880 --> 00:15:06,290
0,330 330,660 660,1080 1080,1170 1170,1410
a publish subscribe or pub

606
00:15:06,290 --> 00:15:07,340
0,180 180,540 540,630 630,690 690,1050
sub server in the middle

607
00:15:07,340 --> 00:15:08,900
0,150 150,540 540,1080 1110,1380 1380,1560
that connects those,| so the
|所以，单独的发布者和订阅者

608
00:15:08,900 --> 00:15:10,550
0,510 510,1050 1050,1140 1140,1230 1230,1650
individual publishers and the individual

609
00:15:10,550 --> 00:15:11,690
0,600 600,810 810,960 960,1050 1050,1140
subscribers| don't have to be
|不需要知道其他的确切身份。

610
00:15:11,690 --> 00:15:12,950
0,390 390,480 480,960 960,1140 1140,1260
aware of exactly who the

611
00:15:12,950 --> 00:15:14,180
0,180 180,390 390,810
other ones are.|
|

612
00:15:14,540 --> 00:15:15,980
0,390 510,750 750,930 930,1080 1080,1440
So {you,know} on your Android
比如在你的安卓手机上，

613
00:15:15,980 --> 00:15:17,870
0,540 690,1110 1110,1320 1320,1500 1500,1890
phone,| an app might publish
|一个应用可能发出电话呼叫事件，

614
00:15:17,870 --> 00:15:18,680
0,60 60,240 240,330 330,540 540,810
or make a phone call

615
00:15:18,680 --> 00:15:20,000
0,390 390,510 510,690 690,1020 1020,1320
event,| and then the dial
|然后拨号可能会订阅它，

616
00:15:20,000 --> 00:15:21,440
0,90 90,480 510,1080 1080,1170 1170,1440
{} might subscribe to that|
|

617
00:15:21,440 --> 00:15:22,580
0,120 120,480 480,990 990,1050 1050,1140
and actually start you know
然后开始帮助拨号。

618
00:15:22,580 --> 00:15:23,900
0,300 300,840
help dial.|
|

619
00:15:24,800 --> 00:15:25,730
0,420 420,570 570,630 630,720 720,930
And so in a real
所以，在真正的发布订阅服务器上，

620
00:15:25,730 --> 00:15:26,630
0,210 210,390 390,690 690,810 810,900
pub sub server,| there are
|有方法可以根据事件的类型过滤事件，

621
00:15:26,630 --> 00:15:27,950
0,210 210,300 300,690 690,1080 1080,1320
ways to filter events based

622
00:15:27,950 --> 00:15:29,030
0,180 180,390 390,690 690,810 810,1080
on what kind they are,|
|

623
00:15:29,030 --> 00:15:30,230
0,180 180,390 540,750 750,900 900,1200
so that when you publish
当你发布一个电话事件时，

624
00:15:30,230 --> 00:15:30,920
0,90 90,210 210,300 300,480 480,690
and make a phone call

625
00:15:30,920 --> 00:15:31,910
0,270 270,570 570,810 810,930 930,990
event,| it doesn't go to
|它不会进入你的电子邮件程序。

626
00:15:31,910 --> 00:15:33,920
0,180 180,420 420,930 1290,1890 1890,2010
your email program.| But for
|但是现在，

627
00:15:33,920 --> 00:15:34,640
0,300 300,420 420,540 540,660 660,720
now,| we're just going to
|我们只假设过滤是单独处理的，

628
00:15:34,640 --> 00:15:36,050
0,450 450,690 720,870 870,1260 1260,1410
assume that the filtering is

629
00:15:36,050 --> 00:15:37,460
0,210 210,390 390,480 480,1140 1170,1410
taken care of separately| and
|我们只是考虑发布和订阅，

630
00:15:37,460 --> 00:15:38,480
0,150 150,330 330,600 600,870 870,1020
we're just worried about the

631
00:15:38,480 --> 00:15:40,720
0,360 360,870 870,1110 1110,1830
actual publish and subscribe,|
|

632
00:15:41,070 --> 00:15:41,970
0,210 210,270 270,420 420,840 840,900
and the {concurrency -} of
以及它的并发性。

633
00:15:41,970 --> 00:15:42,960
0,390
that.|
|

634
00:15:43,020 --> 00:15:44,430
0,180 180,420 420,510 510,1230 1260,1410
So here's an API we
所以这是我们想要实现的 API ，

635
00:15:44,430 --> 00:15:45,800
0,210 210,300 300,780
want to implement,|
|

636
00:15:45,980 --> 00:15:47,300
0,300 300,420 420,690 690,780 780,1320
with any number of clients,|
任意数量的客户端，|

637
00:15:47,300 --> 00:15:48,890
0,180 180,300 300,570 570,1470 1470,1590
that can call Subscribe with
可以调用 Subscribe 使用一个 channel ，

638
00:15:48,890 --> 00:15:51,530
0,90 90,690 960,1170 1170,2100 2130,2640
a channel| and afterwards, events
|之后，发布的事件将发送到那个 channel ，

639
00:15:51,530 --> 00:15:52,610
0,120 120,240 240,870 870,960 960,1080
that are published will be

640
00:15:52,610 --> 00:15:54,220
0,240 240,330 330,510 510,1110
sent on that channel,|
|

641
00:15:54,480 --> 00:15:55,320
0,180 180,300 300,390 390,450 450,840
and then when a client
然后当客户端不再感兴趣时，

642
00:15:55,320 --> 00:15:56,880
0,120 120,210 210,510 510,1260 1320,1560
is no longer interested,| it
|它可以调用 Cancel 并传递相同的 channel ，

643
00:15:56,880 --> 00:15:58,290
0,90 90,330 330,930 930,1050 1050,1410
can call Cancel and passing

644
00:15:58,290 --> 00:15:59,820
0,60 60,360 360,900 930,1140 1140,1530
the same channel,| to say
|表示停止向那个 channel 发送事件，

645
00:15:59,850 --> 00:16:01,170
0,480 480,780 780,900 900,1200 1200,1320
stop sending the events on

646
00:16:01,170 --> 00:16:02,760
0,180 180,660 1080,1260 1260,1380 1380,1590
that channel,| and the way
|而 Cancel 的方式将发出信号，

647
00:16:02,760 --> 00:16:04,020
0,210 210,600 600,750 750,1110 1110,1260
the Cancel will signal that,|
|

648
00:16:04,020 --> 00:16:05,490
0,180 180,420 420,600 600,1080 1110,1470
it really is done sending
当它完成发送事件到那个 channel ，

649
00:16:05,490 --> 00:16:06,660
0,300 300,390 390,600 600,1020 1020,1170
events on that channel,| is
|它将关闭那个 channel ，

650
00:16:06,660 --> 00:16:07,890
0,90 90,210 210,600 600,720 720,1230
it will close the channel,|
|

651
00:16:08,070 --> 00:16:09,720
0,210 210,390 390,660 690,1170 1170,1650
so that the receiver caller
这样接收方呼叫方可以继续接收事件，

652
00:16:09,720 --> 00:16:11,550
0,570 570,840 840,1200 1200,1590 1590,1830
can keep receiving events| until
|直到它看到 channel 关闭，

653
00:16:11,550 --> 00:16:12,450
0,90 90,330 330,450 450,720 720,900
it sees the channel get

654
00:16:12,450 --> 00:16:13,620
0,450 450,600 600,690 690,1050 1050,1170
closed,| then it knows that
|然后它知道 Cancel 已经生效。

655
00:16:13,620 --> 00:16:14,940
0,60 60,450 450,600 600,840 840,1320
the Cancel has taken effect.|
|

656
00:16:16,800 --> 00:16:18,020
0,570

657
00:16:18,020 --> 00:16:20,030
0,390 510,1020 1020,1290 1290,1440 1440,2010
So notice that the information
所以注意到信息只在 channel 上单向流动，

658
00:16:20,030 --> 00:16:21,620
0,150 150,390 390,810 810,1260 1260,1590
is only flowing one way

659
00:16:21,620 --> 00:16:22,700
0,180 180,270 270,690 720,960 960,1080
on the channel, right,| you
|你可以发送到 channel ，

660
00:16:22,700 --> 00:16:24,530
0,150 150,750 750,1080 1080,1200 1200,1830
can send to the channel,|
|

661
00:16:24,800 --> 00:16:26,180
0,210 210,570 600,840 840,1230 1230,1380
and then the receiver can
然后接收者可以从它那里接收，

662
00:16:26,180 --> 00:16:27,020
0,360 360,540 540,630 630,720 720,840
receive from it,| and the
|信息从发送者流向接收者，

663
00:16:27,020 --> 00:16:28,550
0,630 630,930 930,1080 1080,1170 1170,1530
information flows from the sender

664
00:16:28,550 --> 00:16:29,390
0,120 120,180 180,630 630,720 720,840
to the receiver,| and it
|它从来不会走另一条路。

665
00:16:29,390 --> 00:16:30,440
0,300 300,480 480,570 570,750 750,1050
never goes the other way.|
|

666
00:16:30,470 --> 00:16:31,820
0,180 180,720 720,870 870,1230 1230,1350
So closing is also a
所以关闭也是发送者给接收者的信号，

667
00:16:31,820 --> 00:16:33,920
0,630 720,1020 1020,1110 1110,1890 1920,2100
signal from the sender to

668
00:16:33,920 --> 00:16:35,330
0,90 90,720 720,1080 1110,1320 1320,1410
the receiver,| but all the
|但是所有的发送都结束了，

669
00:16:35,330 --> 00:16:37,280
0,360 360,510 510,930 1290,1470 1470,1950
sending is over,| the receiver
|接收者不能关闭 channel

670
00:16:37,280 --> 00:16:38,540
0,390 390,630 630,750 750,1110 1110,1260
cannot close the channel| to
|告诉发送者我不希望你继续发送，

671
00:16:38,540 --> 00:16:39,710
0,180 180,270 270,780 780,990 990,1170
tell the sender I don't

672
00:16:39,710 --> 00:16:40,760
0,150 150,210 210,300 300,600 600,1050
want you to send anymore,|
|

673
00:16:40,790 --> 00:16:42,170
0,210 210,570 570,1140 1140,1320 1320,1380
because that's information going in
因为这是相反方向的信息。

674
00:16:42,170 --> 00:16:43,560
0,120 120,450 450,1020
the opposite direction.|
|

675
00:16:43,830 --> 00:16:44,580
0,150 150,240 240,420 420,480 480,750
And it's just a lot
所以这会更简单，

676
00:16:44,580 --> 00:16:46,200
0,300 300,450 450,720 720,1200 1320,1620
easier to reason about,| if
|如果信息只有一个方向，

677
00:16:46,200 --> 00:16:47,610
0,120 120,600 600,810 810,1080 1080,1410
the information only goes one

678
00:16:47,610 --> 00:16:49,350
0,450 570,810 810,900 900,1530 1560,1740
way,| and of course if
|当然，如果你需要双向通信，

679
00:16:49,350 --> 00:16:51,300
0,150 150,810 1080,1680 1680,1740 1740,1950
you need communication in both

680
00:16:51,300 --> 00:16:52,200
0,480 480,600 600,720 720,840 840,900
directions,| you can use a
|你可以使用两个 channel ，

681
00:16:52,200 --> 00:16:53,670
0,270 270,390 390,1170 1230,1380 1380,1470
pair of channels,| and it
|事实往往是，

682
00:16:53,670 --> 00:16:54,480
0,270 270,510 510,660 660,720 720,810
often turns out to be

683
00:16:54,480 --> 00:16:56,460
0,90 90,420 420,690 1050,1650 1650,1980
the case,| that those {}
|这些不同的方向可能有不同类型的数据流动，

684
00:16:56,520 --> 00:16:57,900
0,360 360,780 780,930 930,1110 1110,1380
different directions may have different

685
00:16:57,900 --> 00:16:59,490
0,270 270,360 360,630 630,1110 1170,1590
types of data flowing,| like
|就像我们之前看到的，

686
00:16:59,490 --> 00:17:00,450
0,360 360,480 480,690 690,840 840,960
before we saw that,| there
|runes 是一个方向，

687
00:17:00,450 --> 00:17:01,320
0,120 120,420 420,630 630,690 690,870
were runes going in one

688
00:17:01,320 --> 00:17:02,850
0,360 360,510 510,900 900,1320 1320,1530
direction| and status updates going
|status 更新是另一个方向。

689
00:17:02,850 --> 00:17:04,060
0,90 90,180 180,330 330,750
in the other direction.|
|

690
00:17:04,560 --> 00:17:06,420
0,630 780,1140 1140,1200 1200,1320 1320,1860
So how do we implement
那么我们如何实现这个 API ，

691
00:17:06,420 --> 00:17:07,840
0,210 210,900
this API,|
|

692
00:17:07,870 --> 00:17:09,940
0,480 480,900 900,1110 1110,1440 1440,2070
here's a pretty basic implementation,|
这里有一个非常基本的实现，|

693
00:17:09,940 --> 00:17:10,630
0,150 150,240 240,420 420,600 600,690
that you know could be
它可能已经足够好了。

694
00:17:10,630 --> 00:17:11,820
0,150 150,660
good enough.|
|

695
00:17:11,910 --> 00:17:13,410
0,240 240,330 330,390 390,1110 1290,1500
We have a Server| and
我们有一个 Server ，|Server 状态是注册发布者的 map ，

696
00:17:13,410 --> 00:17:14,520
0,60 60,450 450,930 930,1050 1050,1110
the Server state is a

697
00:17:14,520 --> 00:17:16,740
0,390 390,660 660,1140 1140,1650 1650,2220
map of registered subscriber channels,|
|

698
00:17:16,740 --> 00:17:18,480
0,450 450,540 540,660 660,1230
protected by a lock,|
由锁保护，|

699
00:17:18,630 --> 00:17:20,220
0,150 150,690 690,780 780,1320 1320,1590
we initialize the Server by
我们初始化 Server 通过分配 map ，

700
00:17:20,250 --> 00:17:22,000
0,210 210,660 660,720 720,1260
just allocating the map,|
|

701
00:17:22,210 --> 00:17:23,110
0,180 180,300 300,390 390,810 810,900
and then to publish the
然后，为了发布事件，

702
00:17:23,110 --> 00:17:24,700
0,480 510,780 780,1020 1020,1290 1290,1590
event,| we just send it
|我们只需把它发送到每个注册 channel ，

703
00:17:24,700 --> 00:17:26,680
0,150 150,420 420,870 870,1410
to every register channel,|
|

704
00:17:27,060 --> 00:17:28,380
0,150 150,750 750,810 810,990 990,1320
to subscribe a new channel,|
为了订阅新 channel ，|

705
00:17:28,380 --> 00:17:29,010
0,120 120,270 270,480 480,570 570,630
we just {add,that} to the
我们只需把它添加到 map ，

706
00:17:29,010 --> 00:17:30,690
0,630 840,990 990,1050 1050,1440 1440,1680
map| and to cancel, we
|为了取消，我们把它从 map 中删除。

707
00:17:30,690 --> 00:17:31,260
0,210 210,360 360,450 450,510 510,570
take it out of the

708
00:17:31,260 --> 00:17:32,280
0,510
map.|
|

709
00:17:32,370 --> 00:17:33,300
0,210 210,330 330,600 600,810 810,930
And then, because these are
然后，因为这些都是，

710
00:17:33,300 --> 00:17:35,370
0,660 810,1650 1680,1890 1890,1950 1950,2070
all,| {} these are all
|这些都是可以从多个 goroutine 调用的方法，

711
00:17:35,370 --> 00:17:36,480
0,360 360,450 450,630 630,750 750,1110
methods that might be called

712
00:17:36,480 --> 00:17:38,880
0,120 120,510 510,630 630,1260 1710,2400
from multiple {goroutines -},| we
|我们需要调用 lock 和 unlock 来保护 map ，

713
00:17:38,940 --> 00:17:40,650
0,330 330,600 720,1230 1230,1620 1620,1710
need to call lock and

714
00:17:40,650 --> 00:17:42,990
0,390 390,750 750,1260 1350,1830 1830,2340
unlock around these to {}

715
00:17:43,290 --> 00:17:44,800
0,570 570,630 630,1110
protect the map,|
|

716
00:17:44,890 --> 00:17:45,940
0,120 120,420 420,570 570,660 660,1050
and notice that I wrote
注意我在 lock 之后写了 defer unlock ，

717
00:17:45,940 --> 00:17:47,620
0,600 600,1080 1110,1320 1320,1590 1590,1680
defer unlock right after the

718
00:17:47,620 --> 00:17:49,030
0,690 840,1050 1050,1110 1110,1290 1290,1410
lock,| so I don't have
|这样我就不用记得之后 unlock 了，

719
00:17:49,030 --> 00:17:50,020
0,120 120,450 450,510 510,900 900,990
to remember to unlock it

720
00:17:50,020 --> 00:17:51,020
0,450
later,|
|

721
00:17:51,080 --> 00:17:52,130
0,330 330,450 450,690 690,840 840,1050
{} you probably all seen
你们可能都见过这个，

722
00:17:52,130 --> 00:17:53,030
0,420 420,540 540,660 660,840 840,900
this,| you know sort of
|一个不错的 lock unlock 的习惯用法，

723
00:17:53,030 --> 00:17:53,930
0,30 30,300 300,600 600,720 720,900
a nice idiom to just

724
00:17:53,930 --> 00:17:54,890
0,90 90,210 210,480 480,870 870,960
do the lock unlock,| and
|然后我有一个空行，

725
00:17:54,890 --> 00:17:55,700
0,210 210,360 360,600 600,690 690,810
then you know I have

726
00:17:55,700 --> 00:17:56,510
0,60 60,330 330,570 570,660 660,810
a blank line| and have
|让它在代码中有自己的段落。

727
00:17:56,510 --> 00:17:57,950
0,180 180,270 270,450 450,690 840,1440
that be its own paragraph

728
00:17:57,950 --> 00:17:59,060
0,60 60,150 150,600
in the code.|
|

729
00:18:02,620 --> 00:18:03,400
0,390 390,540 540,600 600,720 720,780
One thing I want to
我想指出的一件事是，

730
00:18:03,400 --> 00:18:04,840
0,240 240,780
point out

731
00:18:04,840 --> 00:18:05,830
0,90 90,210 210,510 510,750 750,990
is that,| using defer {}
|使用 defer 可以确保 mutex 被解锁，

732
00:18:05,830 --> 00:18:06,820
0,150 150,390 390,510 510,600 600,990
makes sure that the mutexes

733
00:18:06,820 --> 00:18:08,230
0,240 240,720 840,1140 1140,1290 1290,1410
gets unlocked,| even if you
|即使函数有多个返回值，

734
00:18:08,230 --> 00:18:09,310
0,90 90,450 450,870 870,990 990,1080
have multiple returns from the

735
00:18:09,310 --> 00:18:10,660
0,300 300,420 420,510 510,780 780,1350
function,| so you can't forget,|
|所以你不会忘记，|

736
00:18:10,870 --> 00:18:12,100
0,270 270,450 450,810 810,1020 1020,1230
but it also makes sure
但它也能确保，在你出现 panic 时，会被解锁，

737
00:18:12,100 --> 00:18:13,000
0,120 120,180 180,390 390,810 810,900
that it gets unlocked if

738
00:18:13,000 --> 00:18:14,530
0,90 90,210 210,300 300,960 1170,1530
you have a panic,| like
|比如在 Subscribe 和 Cancel 中，

739
00:18:14,530 --> 00:18:16,840
0,150 150,720 720,1410 1440,1830 1830,2310
in {Subscribe,and} Cancel,| where there's
|有 panic 的滥用。

740
00:18:16,840 --> 00:18:18,860
0,420 420,570 570,1440
panic for misuse.|
|

741
00:18:19,010 --> 00:18:20,060
0,240 240,360 360,480 480,570 570,1050
And there is a subtlety
这里有一个微妙的地方，

742
00:18:20,060 --> 00:18:21,680
0,240 240,840 1170,1350 1350,1470 1470,1620
here about,| if you might
|如果你可能不想解锁 mutex ，

743
00:18:21,680 --> 00:18:22,640
0,210 210,450 450,540 540,900 900,960
not want to unlock the

744
00:18:22,640 --> 00:18:24,620
0,510 510,930 1050,1260 1260,1650 1650,1980
mutex,| if the panic happened,|
|如果 panic 发生在，|

745
00:18:24,620 --> 00:18:25,550
0,360 360,480 480,660 660,750 750,930
while the thing that was
被锁定的东西处于某种不一致的状态时，

746
00:18:25,550 --> 00:18:27,050
0,420 420,540 540,690 690,870 870,1500
locked is in some inconsistent

747
00:18:27,050 --> 00:18:28,760
0,450 600,1110 1140,1290 1290,1440 1440,1710
state,| but I'm gonna ignore
|但我暂时忽略这一点，

748
00:18:28,760 --> 00:18:30,710
0,240 240,330 330,720 1110,1260 1260,1950
that for now,| in general,
|一般来说，你尽量避免发生可能会引起 panic 的事情，

749
00:18:31,260 --> 00:18:32,610
0,360 360,480 480,690 690,780 780,1350
{} you try to avoid

750
00:18:32,610 --> 00:18:33,960
0,390 390,840 840,1050 1050,1140 1140,1350
having the things that might

751
00:18:33,960 --> 00:18:36,030
0,600 900,1140 1140,1500 1500,1770 1770,2070
panic {} happen,| while you're
|当你可能处于不一致的状态时。

752
00:18:36,060 --> 00:18:38,320
0,660 660,1290 1290,1650
potentially {in,inconsistent} state.|
|

753
00:18:38,700 --> 00:18:39,840
0,390 510,690 690,780 780,960 960,1140
And I should also point
我还要指出，

754
00:18:39,840 --> 00:18:40,560
0,150 150,270 270,360 360,630 630,720
out that,| the use of
|在 Subscribe 和 Cancel 中使用 panic ，

755
00:18:40,560 --> 00:18:42,300
0,360 360,450 450,960 960,1140 1140,1740
panic at all in Subscribe

756
00:18:42,300 --> 00:18:44,460
0,360 360,930 1050,1710 1710,1950 1950,2160
and Cancel,| implies that you
|隐含你信任你的客户端不会滥用该接口，

757
00:18:44,460 --> 00:18:45,780
0,240 240,510 510,630 630,1050 1050,1320
really trust your clients not

758
00:18:45,780 --> 00:18:47,100
0,60 60,450 450,540 540,1050 1050,1320
to misuse the interface,| that
|这是一个程序错误，

759
00:18:47,160 --> 00:18:48,450
0,270 270,420 420,510 510,930 930,1290
it is a program error,|
|

760
00:18:48,450 --> 00:18:50,760
0,570 1170,1650 1650,1860 1860,1920 1920,2310
worth tearing down the entire
值得拆解整个程序，才有可能发生这种情况。

761
00:18:50,760 --> 00:18:52,530
0,330 330,1050 1260,1500 1500,1680 1680,1770
program potentially for that to

762
00:18:52,530 --> 00:18:53,480
0,450
happen.|
|

763
00:18:53,630 --> 00:18:54,770
0,180 180,270 270,360 360,660 660,1140
And in a bigger program
在一个更大的程序中，其他客户端正在使用这个 API ，

764
00:18:54,770 --> 00:18:56,060
0,180 180,450 450,900 900,1020 1020,1290
where other clients were using

765
00:18:56,060 --> 00:18:57,580
0,180 180,990
this API,|
|

766
00:18:57,580 --> 00:18:58,510
0,180 180,450 450,570 570,630 630,930
you probably want to return
你可能希望返回一个错误，

767
00:18:58,510 --> 00:19:00,310
0,120 120,390 390,960 1230,1530 1530,1800
an error instead,| and not
|而不会可能让整个程序停止，

768
00:19:00,310 --> 00:19:01,420
0,120 120,210 210,780 780,840 840,1110
have the possibility of taking

769
00:19:01,420 --> 00:19:02,890
0,210 210,270 270,450 450,930 1050,1470
down the whole program,| but
|但目前， panic 让事情变得简单了，

770
00:19:02,890 --> 00:19:04,600
0,420 420,960 960,1200 1200,1320 1320,1710
{panic,is} simplifies things for now,|
|

771
00:19:05,200 --> 00:19:06,130
0,210 210,300 300,420 420,660 660,930
and you know error handling
错误处理不是今天的主题。

772
00:19:06,130 --> 00:19:07,060
0,120 120,450 450,570 570,720 720,930
in general is kind of

773
00:19:07,150 --> 00:19:08,860
0,360 360,420 420,780 780,1200
not the topic today.|
|

774
00:19:10,930 --> 00:19:12,100
0,180 180,450 450,810 810,1080 1080,1170
A more important concern with
与 panic 相比，这个代码更重要的问题是，

775
00:19:12,100 --> 00:19:13,870
0,150 150,480 480,870 870,1500 1530,1770
this code than panic is,|
|

776
00:19:13,870 --> 00:19:15,760
0,240 240,1020 1050,1530 1560,1740 1740,1890
what happens if a {goroutine
如果 goroutine 接收事件的速度很慢，会发生什么？

777
00:19:15,760 --> 00:19:17,290
0,270 270,390 390,1020 1020,1170 1170,1530
-} is slow to receive

778
00:19:17,290 --> 00:19:18,480
0,750
events.|
|

779
00:19:18,630 --> 00:19:20,100
0,450 480,720 720,840 840,1350 1350,1470
So all the operations here
所以这里的所有操作都完成了持有 mutex ，

780
00:19:20,100 --> 00:19:21,600
0,150 150,480 480,840 840,900 900,1500
are done holding the mutex,|
|

781
00:19:21,600 --> 00:19:22,800
0,240 240,420 420,570 570,660 660,1200
which means all the clients
这意味着所有的客户端都必须步调一致。

782
00:19:22,800 --> 00:19:23,760
0,180 180,270 270,480 480,600 600,960
kind of have to proceed

783
00:19:23,760 --> 00:19:25,180
0,90 90,900
in lockstep.|
|

784
00:19:25,210 --> 00:19:27,250
0,360 360,600 600,900 900,1530 1530,2040
{} So during Publish, there's
所以在 Publish 中，有一个循环在 channel 发送，

785
00:19:27,250 --> 00:19:28,870
0,90 90,390 390,630 630,1320 1350,1620
a loop that's sending on

786
00:19:28,870 --> 00:19:30,520
0,120 120,930 990,1290 1290,1380 1380,1650
the channels,| sending the event
|将事件发送到每个 channel ，

787
00:19:30,520 --> 00:19:31,810
0,90 90,330 330,900 930,1200 1200,1290
to every channel,| and if
|如果一个订阅者落后了，

788
00:19:31,810 --> 00:19:34,090
0,270 270,870 870,1200 1200,1920 2040,2280
one subscriber falls behind,| the
|下一位订阅者不会收到事件，

789
00:19:34,090 --> 00:19:35,170
0,210 210,630 630,840 840,990 990,1080
next subscriber doesn't get the

790
00:19:35,170 --> 00:19:36,850
0,330 330,570 570,750 750,990 990,1680
event,| until that slow subscriber
|直到缓慢的订阅者醒来，

791
00:19:36,880 --> 00:19:38,650
0,540 540,780 780,1140 1140,1470 1470,1770
wakes up| and actually get
|并从 channel 上获取事件。

792
00:19:39,010 --> 00:19:40,150
0,180 180,450 450,690 690,900 900,1140
the event off of that

793
00:19:40,150 --> 00:19:41,000
0,420
channel.|
|

794
00:19:41,120 --> 00:19:42,800
0,150 150,240 240,570 570,840 840,1680
And so one slow subscriber
所以，一个速度慢的订阅者可能会拖慢其他所有人的速度，

795
00:19:42,860 --> 00:19:44,540
0,300 300,510 510,750 750,1020 1020,1680
can slow down everyone else,|
|

796
00:19:44,810 --> 00:19:46,070
0,240 420,540 540,630 630,1050 1050,1260
and you know forcing them
强迫它们这样步调一致地进行并不总是一个问题，

797
00:19:46,070 --> 00:19:47,360
0,180 180,630 630,720 720,1140 1140,1290
to proceed in lockstep this

798
00:19:47,360 --> 00:19:48,560
0,300 300,480 480,720 720,1110 1110,1200
way is not always a

799
00:19:48,560 --> 00:19:50,990
0,420 930,1200 1230,1530 1530,2370 2370,2430
problem,| if you document the
|如果你记录了限制，

800
00:19:50,990 --> 00:19:52,910
0,780 780,1260 1260,1380 1380,1650 1650,1920
restriction| and for whatever reason
|无论出于什么原因，你知道客户端是如何编写的，

801
00:19:52,910 --> 00:19:54,050
0,120 120,360 360,630 630,720 720,1140
you know how the clients

802
00:19:54,050 --> 00:19:55,460
0,390 390,810 960,1110 1110,1230 1230,1410
are written| and you know
|你知道它们永远不会落后太多，

803
00:19:55,460 --> 00:19:56,480
0,150 150,240 240,510 510,780 780,1020
that they won't ever fall

804
00:19:56,480 --> 00:19:57,920
0,120 120,330 330,900 990,1320 1320,1440
too far behind,| this could
|这可能完全没问题，

805
00:19:57,920 --> 00:19:58,940
0,90 90,480 480,780 780,930 930,1020
be totally fine,| it's a
|这是一个非常简单的实现，

806
00:19:58,940 --> 00:20:00,780
0,240 240,540 540,1440
really simple implementation,|
|

807
00:20:01,150 --> 00:20:03,100
0,390 690,1200 1290,1560 1560,1740 1740,1950
and {} it has nice
而且它有很好的属性，

808
00:20:03,100 --> 00:20:04,690
0,510 510,810 840,1080 1080,1410 1410,1590
properties,| like on return from
|比如从 Publish 返回，

809
00:20:04,690 --> 00:20:05,890
0,420 420,570 570,840 840,1080 1080,1200
Publish,| you know that the
|你知道事件已经被移交给其他每个 goroutine ，

810
00:20:05,890 --> 00:20:07,270
0,300 300,510 510,930 930,1080 1080,1380
event has actually been handed

811
00:20:07,270 --> 00:20:07,960
0,240 240,330 330,480 480,570 570,690
off to each of the

812
00:20:07,960 --> 00:20:09,370
0,180 180,330 330,930 1080,1290 1290,1410
other {goroutines -},| you don't
|你不知道它们已经开始处理了，

813
00:20:09,370 --> 00:20:10,600
0,150 150,270 270,450 450,780 780,1230
know that they've started processing

814
00:20:10,600 --> 00:20:11,260
0,150 150,240 240,360 360,540 540,660
it,| but you know it's
|但你知道它已经被转手了。

815
00:20:11,260 --> 00:20:12,560
0,120 120,420 420,810
been handed off.|
|

816
00:20:12,560 --> 00:20:13,880
0,150 150,540 570,990 990,1170 1170,1320
And so, maybe that's good
所以，也许这已经足够好了，你可以停在这里。

817
00:20:13,880 --> 00:20:14,780
0,300 300,390 390,480 480,600 600,900
enough and you could stop

818
00:20:14,780 --> 00:20:15,740
0,450
here.|
|

819
00:20:16,340 --> 00:20:17,510
0,300 300,420 420,720 720,1020 1020,1170
{} A second option is
第二种选择是，

820
00:20:17,510 --> 00:20:18,770
0,330 690,900 900,1020 1020,1170 1170,1260
that,| if you need to
|如果你需要容忍订阅者稍微慢一点的话，

821
00:20:18,770 --> 00:20:19,790
0,390 390,540 540,630 630,900 900,1020
tolerate just a little bit

822
00:20:19,790 --> 00:20:22,190
0,90 90,810 810,1440 1470,1620 1620,2400
of slowness on the subscribers,|
|

823
00:20:22,220 --> 00:20:23,690
0,360 360,480 480,900 960,1260 1260,1470
then you could say that,|
然后你可以说，|

824
00:20:23,690 --> 00:20:24,680
0,210 210,420 420,570 570,840 840,990
they need to give you
它们需要为你提供一个缓冲区 channel ，

825
00:20:24,680 --> 00:20:26,000
0,90 90,420 420,810 810,1020 1020,1320
a buffered channel| with room
|有空间在缓冲中有一些事件，

826
00:20:26,000 --> 00:20:26,900
0,180 180,270 270,540 540,600 600,900
for a couple of events

827
00:20:26,900 --> 00:20:28,520
0,90 90,180 180,810 870,1200 1200,1620
in the buffer,| so that
|这样当你发布的时候，

828
00:20:28,550 --> 00:20:30,050
0,210 210,300 300,540 540,660 660,1500
you know when you're publishing,|
|

829
00:20:30,610 --> 00:20:31,240
0,210 210,330 330,450 450,510 510,630
{you,know} as long as they're
只要它们不在太远的后面，

830
00:20:31,240 --> 00:20:32,320
0,180 180,330 330,540 540,930 930,1080
not too far behind,| there
|总是有空间让新事件进入 channel 缓冲区，

831
00:20:32,320 --> 00:20:33,760
0,270 270,420 420,900 900,1140 1140,1440
always be room for the

832
00:20:33,790 --> 00:20:35,080
0,510 510,840 840,900 900,1080 1080,1290
new event to go into

833
00:20:35,080 --> 00:20:36,550
0,180 180,480 480,990 1080,1350 1350,1470
the channel buffer,| and then
|然后， Publish 不会阻塞太长事件。

834
00:20:36,550 --> 00:20:38,170
0,120 120,540 540,960 960,1350 1350,1620
the actual Publish won't block

835
00:20:38,170 --> 00:20:39,340
0,90 90,240 240,600
for too long.|
|

836
00:20:39,600 --> 00:20:40,620
0,150 150,420 420,630 630,870 870,1020
And again, maybe that's good
再说一次，也许这已经足够好了，

837
00:20:40,620 --> 00:20:41,790
0,360 390,570 570,720 720,990 990,1170
enough,| if you're sure that
|如果你确定它们永远不会落后太多，

838
00:20:41,790 --> 00:20:42,810
0,120 120,420 420,690 690,900 900,1020
they won't ever fall too

839
00:20:42,810 --> 00:20:44,220
0,180 180,720 930,1170 1170,1320 1320,1410
far behind,| you get to
|你可以到此为止。

840
00:20:44,220 --> 00:20:45,440
0,330 330,720
stop there.|
|

841
00:20:45,780 --> 00:20:46,890
0,330 330,420 420,570 570,900 900,1110
But in a really big
但是在一个非常大的项目中，

842
00:20:46,890 --> 00:20:48,120
0,690
program,|
|

843
00:20:48,350 --> 00:20:49,280
0,240 240,360 360,510 510,600 600,930
you do want to cope
你希望更优雅地处理任意缓慢的订阅者，

844
00:20:49,280 --> 00:20:52,370
0,210 210,840 840,1860 1890,2700 2700,3090
more gracefully with arbitrarily slow

845
00:20:52,370 --> 00:20:53,660
0,810 810,960 960,1080 1080,1230 1230,1290
subscribers,| and so then the
|所以接下来的问题是你会做什么。

846
00:20:53,660 --> 00:20:54,620
0,360 360,480 480,780 780,870 870,960
question is what do you

847
00:20:54,620 --> 00:20:55,580
0,390
do.|
|

848
00:20:55,610 --> 00:20:56,750
0,120 120,450 450,750 750,1050 1050,1140
And so in general you
通常你有三个选择，

849
00:20:56,750 --> 00:20:58,280
0,120 120,330 330,1020 1110,1380 1380,1530
have three options,| you can
|你可以降低事件生成器的速度，

850
00:20:58,280 --> 00:20:59,750
0,270 270,480 480,570 570,840 840,1470
slow down the event generator,|
|

851
00:20:59,780 --> 00:21:00,830
0,240 240,330 330,540 540,660 660,1050
which is what the previous
这是以前的解决方案隐含的做法，

852
00:21:00,830 --> 00:21:03,530
0,780 900,1710 1710,2040 2040,2340 2340,2700
solutions implicitly do,| because publish
|因为发布停止，直到订阅者跟上。

853
00:21:03,530 --> 00:21:06,560
0,750 780,1500 1560,1800 1800,2340 2340,3030
stops until the subscribers {catch,up}.|
|

854
00:21:07,230 --> 00:21:08,760
0,270 270,390 390,510 510,840 840,1530
Or you can drop events|
或者你可以删除事件，|

855
00:21:08,940 --> 00:21:10,170
0,270 270,390 390,570 570,1110 1110,1230
or you can queue an
也可以对任意数量的过去事件进行排队，

856
00:21:10,170 --> 00:21:11,850
0,540 540,810 810,870 870,1170 1170,1680
arbitrary number of past events,|
|

857
00:21:11,850 --> 00:21:12,690
0,270 270,360 360,540 540,750 750,840
those are pretty much your
这几乎是你唯一的选择。

858
00:21:12,690 --> 00:21:14,060
0,210 210,930
only options.|
|

859
00:21:14,350 --> 00:21:15,880
0,330 330,600 600,930 930,1380 1410,1530
So we talked about you
所以我们讨论了发布和减慢事件生成器的速度。

860
00:21:15,880 --> 00:21:17,470
0,120 120,660 660,960 960,1290 1290,1590
know publish and slowing down

861
00:21:17,470 --> 00:21:19,060
0,90 90,330 330,1020
the event generator.|
|

862
00:21:19,060 --> 00:21:20,560
0,300 300,360 360,630 630,960 960,1500
There's a middle ground,| where
有一个中间立场，|你可以合并这些事件，也可以丢弃它们，

863
00:21:20,590 --> 00:21:22,150
0,330 330,1020 1020,1110 1110,1470 1470,1560
you coalesce the events or

864
00:21:22,150 --> 00:21:24,670
0,120 120,450 450,870 1950,2220 2220,2520
you drop them,| so that
|这样订阅者可能会发现，

865
00:21:25,000 --> 00:21:26,860
0,150 150,570 930,1110 1110,1590 1590,1860
you know the subscriber might

866
00:21:26,860 --> 00:21:28,390
0,330 330,630 630,960 1050,1230 1230,1530
find out that,| {you,know} hey
|嘿，你错过了一些事件，

867
00:21:28,390 --> 00:21:29,290
0,120 120,300 300,420 420,810 810,900
you missed some events| and
|我不能告诉你它们是什么，

868
00:21:29,290 --> 00:21:29,890
0,60 60,270 270,390 390,450 450,600
I can't tell you what

869
00:21:29,890 --> 00:21:30,760
0,90 90,360 360,600 600,660 660,870
they were,| because I didn't
|因为我没有保存它们，

870
00:21:30,760 --> 00:21:31,780
0,270 270,420 420,720 720,870 870,1020
save them,| but I'm at
|但我至少要告诉你，你错过了五个事件，

871
00:21:31,780 --> 00:21:32,620
0,150 150,270 270,330 330,540 540,840
least going to tell you,

872
00:21:32,620 --> 00:21:34,180
0,150 150,330 330,570 570,1140
you missed five events,|
|

873
00:21:34,180 --> 00:21:35,170
0,420 420,540 540,780 780,900 900,990
and then maybe it can
然后，也许它可以做一些事情来试图赶上。

874
00:21:35,170 --> 00:21:36,100
0,120 120,420 420,690 690,780 780,930
do something else to try

875
00:21:36,100 --> 00:21:37,280
0,90 90,330 330,690
to catch up.|
|

876
00:21:37,510 --> 00:21:38,350
0,210 210,390 390,480 480,570 570,840
And this is the kind
这是我们在 profiler 中采用的方法，

877
00:21:38,350 --> 00:21:40,480
0,90 90,660 750,1650 1680,1920 1920,2130
of approach, that we take

878
00:21:40,480 --> 00:21:41,440
0,90 90,180 180,750 750,900 900,960
in the profiler,| so in
|在 profiler 中，如果你使用过它，

879
00:21:41,440 --> 00:21:42,520
0,90 90,540 540,720 720,930 930,1080
the {profiler -}, if you've

880
00:21:42,520 --> 00:21:44,650
0,270 270,570 900,1320 1470,1860 1890,2130
used it,| if,| {} there's
|如果，|有一个 goroutine ，

881
00:21:44,650 --> 00:21:46,270
0,90 90,360 360,600 600,990 1200,1620
a {goroutine -},| that {}
|通过分析事件在一个信号处理器中填充了[分析]，

882
00:21:46,270 --> 00:21:47,710
0,390 390,480 480,990 990,1350 1350,1440
fills the profile on a

883
00:21:47,710 --> 00:21:50,020
0,270 270,600 600,1170 1200,1830 1830,2310
signal handler actually with profiling

884
00:21:50,020 --> 00:21:51,370
0,600 780,990 990,1110 1110,1290 1290,1350
events,| and then there's a
|然后有一个单独的 goroutine ，

885
00:21:51,370 --> 00:21:52,600
0,360 360,750 750,900 900,1140 1140,1230
separate goroutine,| whose job is
|它的工作是读出数据，

886
00:21:52,600 --> 00:21:53,680
0,180 180,420 420,540 540,780 780,1080
to read the data back

887
00:21:53,680 --> 00:21:54,640
0,300 300,540 570,780 780,870 870,960
out| and write it to
|将其写入磁盘或发送到 http 请求，

888
00:21:54,640 --> 00:21:55,630
0,420 420,510 510,750 750,840 840,990
disk or send it to

889
00:21:55,630 --> 00:21:57,340
0,150 150,630 630,1260 1260,1320 1320,1710
an http request| or whatever
|或者任何你使用分析数据所做的。

890
00:21:57,340 --> 00:21:57,940
0,90 90,180 180,300 300,450 450,600
it is you're doing with

891
00:21:57,940 --> 00:21:59,980
0,360 360,780 1260,1650 1710,1980 1980,2040
profile data.| And there's a
|这中间有一个缓冲区，

892
00:21:59,980 --> 00:22:01,480
0,330 330,420 420,480 480,990 1170,1500
buffer in the middle| and
|如果来自分析数据的接收者落后，

893
00:22:01,540 --> 00:22:03,070
0,270 270,630 660,1260 1260,1440 1440,1530
if the receiver from the

894
00:22:03,070 --> 00:22:05,230
0,390 390,660 660,990 990,1710 1920,2160
profile data falls behind,| when
|当缓冲区填满时，

895
00:22:05,230 --> 00:22:06,160
0,60 60,390 390,630 630,840 840,930
the buffer fills up,| we
|我们开始添加最终分析条目，

896
00:22:06,160 --> 00:22:08,350
0,300 300,660 660,1110 1110,1470 1470,2190
start adding entries to, a

897
00:22:08,350 --> 00:22:10,750
0,540 540,990 990,1530 1590,2130 2130,2400
final profile entry,| that just
|它只有一个条目，

898
00:22:10,750 --> 00:22:12,070
0,240 240,330 330,750 750,1020 1020,1320
has a single entry,| that's
|它是一个函数名为 [runtime last profile data] ，

899
00:22:12,070 --> 00:22:13,870
0,510 540,720 720,1110 1110,1410 1410,1800
that's a function called [runtime

900
00:22:13,870 --> 00:22:15,910
0,480 480,840 840,1260 1500,1770 1770,2040
last profile data],| and so
|所以如果你看一下 profile ，

901
00:22:15,910 --> 00:22:16,600
0,180 180,300 300,540 540,600 600,690
if you look at the

902
00:22:16,600 --> 00:22:17,560
0,330 330,450 450,690 690,870 870,960
profile,| you see hey the
|你看到程序花了 5% 的时间在[最后的]分析数据上，

903
00:22:17,560 --> 00:22:18,520
0,270 270,480 480,660 660,900 900,960
program spent {5% -} of

904
00:22:18,520 --> 00:22:19,600
0,90 90,330 330,420 420,720 720,1080
its time in [last] profile

905
00:22:19,600 --> 00:22:21,370
0,420 510,900 900,1080 1080,1620 1650,1770
data,| that just means you
|这意味着分析读取器太慢了，

906
00:22:21,370 --> 00:22:22,040
0,360
know

907
00:22:22,040 --> 00:22:23,930
0,420 450,1050 1050,1470 1470,1740 1740,1890
the profile reader was too

908
00:22:23,930 --> 00:22:25,100
0,390 390,480 480,720 720,930 930,1170
slow| and it didn't catch
|它没有跟上，

909
00:22:25,100 --> 00:22:26,080
0,510
up,|
|

910
00:22:26,170 --> 00:22:27,100
0,420 420,540 540,750 750,870 870,930
and we lost some of
我们丢失了一些 profile ，

911
00:22:27,100 --> 00:22:28,030
0,60 60,330 330,480 480,600 600,930
the profile,| but we're clear
|但我们很清楚知道 profile 中的错误率是多少，

912
00:22:28,030 --> 00:22:30,220
0,210 210,900 1110,1620 1620,1800 1800,2190
about exactly what the error

913
00:22:30,220 --> 00:22:31,570
0,300 300,510 510,600 600,660 660,1350
rate is in the profile,|
|

914
00:22:31,690 --> 00:22:32,920
0,450 450,630 630,810 810,1020 1020,1230
and you pretty much never
你几乎看不到这一点，

915
00:22:32,920 --> 00:22:33,790
0,210 210,390 390,630 630,750 750,870
see that,| because all the
|因为所有的读取者都跟上了，

916
00:22:33,790 --> 00:22:35,230
0,270 270,600 600,810 810,1050 1050,1440
readers actually do keep up,|
|

917
00:22:35,260 --> 00:22:36,280
0,420 420,600 600,660 660,900 900,1020
but just in case they
但是为了防止它们没有，

918
00:22:36,280 --> 00:22:37,750
0,510 750,930 930,1080 1080,1290 1290,1470
didn't,| you have a pretty
|你有一个很清晰的信号。

919
00:22:37,750 --> 00:22:38,960
0,210 210,720
clear signal.|
|

920
00:22:39,960 --> 00:22:41,430
0,390 390,540 540,960 960,1080 1080,1470
{} An example of purely
一个纯粹丢弃事件的例子是系统信号包，

921
00:22:41,430 --> 00:22:43,170
0,480 480,600 600,1140 1350,1590 1590,1740
dropping the events is the

922
00:22:43,170 --> 00:22:46,100
0,210 210,540 540,1260 1290,1830
OS signal package,| where
|那里你必须通过一个 channel ，

923
00:22:46,220 --> 00:22:47,380
0,630
{}

924
00:22:47,410 --> 00:22:48,400
0,390 390,510 510,600 600,930 930,990
you have to pass in

925
00:22:48,400 --> 00:22:49,330
0,90 90,480 480,690 690,810 810,930
a channel,| that will be
|它做好接收信号的准备，

926
00:22:49,330 --> 00:22:50,710
0,270 270,390 390,720 720,810 810,1380
ready to receive the signal,|
|

927
00:22:50,920 --> 00:22:52,480
0,270 270,630 630,840 840,1050 1050,1560
a signal like {SIGHUP -}
像 SIGHUP 或 SIGQUIT 这样的信号，

928
00:22:52,480 --> 00:22:53,960
0,210 210,420 420,810
or {SIGQUIT -},|
|

929
00:22:53,990 --> 00:22:55,070
0,240 240,510 510,570 570,870 870,1080
and when the signal comes
当信号进来的时候，

930
00:22:55,070 --> 00:22:56,600
0,450 480,750 750,1050 1050,1440 1440,1530
in,| the runtime tries to
|运行时尝试向订阅这个信号的每个 channel 发送，

931
00:22:56,600 --> 00:22:57,260
0,270 270,360 360,540 540,600 600,660
send to each of the

932
00:22:57,260 --> 00:22:58,550
0,420 420,540 540,1020 1020,1080 1080,1290
channels that subscribe to that

933
00:22:58,550 --> 00:22:59,960
0,450 810,990 990,1080 1080,1140 1140,1410
signal,| and if it can't
|如果它不能发送给它，

934
00:22:59,960 --> 00:23:00,890
0,210 210,330 330,570 600,780 780,930
send to it,| it just
|它就不发送，它就会消失，

935
00:23:00,890 --> 00:23:02,630
0,390 510,690 690,840 840,1230 1380,1740
doesn't, it's just gone {},|
|

936
00:23:02,630 --> 00:23:03,890
0,510 510,810 810,900 900,960 960,1260
because {you,know} in a signal
因为在信号处理器里，我们不能等待，

937
00:23:03,890 --> 00:23:05,480
0,240 240,360 360,570 570,930 1230,1590
handler, we can't wait,| and
|所以调用者必须做的是

938
00:23:05,480 --> 00:23:07,070
0,570 690,930 930,1020 1020,1410 1410,1590
so what the callers have

939
00:23:07,070 --> 00:23:07,670
0,90 90,300 300,420 420,510 510,600
to do is| they have
|它们必须传递给缓冲 channel ，

940
00:23:07,670 --> 00:23:08,480
0,90 90,360 360,450 450,510 510,810
to pass in a buffer

941
00:23:08,480 --> 00:23:09,710
0,510 600,750 750,810 810,960 960,1230
channel,| and if they pass
|如果它们传递给缓冲 channel ，

942
00:23:09,710 --> 00:23:11,330
0,90 90,150 150,450 450,1050 1110,1620
in a buffer channel,| that
|缓冲长度至少为 1 ，

943
00:23:11,330 --> 00:23:12,890
0,600 630,930 930,1050 1050,1230 1230,1560
has length at least one,

944
00:23:12,890 --> 00:23:14,150
0,240 240,480 480,600 600,780 780,1260
buffer length at least one,|
|

945
00:23:14,540 --> 00:23:16,220
0,600 630,810 810,1110 1110,1500 1500,1680
and they only register that
它们仅把 channel 注册到单个信号，

946
00:23:16,220 --> 00:23:18,110
0,270 270,390 390,480 480,1110 1140,1890
channel to a single signal,|
|

947
00:23:18,230 --> 00:23:19,380
0,750
then
那么如果有信号进来，

948
00:23:19,880 --> 00:23:20,930
0,240 240,570 570,780 780,990 990,1050
you know that if a

949
00:23:20,930 --> 00:23:22,040
0,300 300,540 540,660 660,780 780,1110
signal comes in,| you're definitely
|你肯定会被告知这件事，

950
00:23:22,040 --> 00:23:23,120
0,150 150,360 360,600 600,840 840,1080
gonna get told about it,|
|

951
00:23:23,450 --> 00:23:24,710
0,180 180,240 240,450 450,570 570,1260
if it comes in twice,|
如果它进来两次，|

952
00:23:24,740 --> 00:23:25,580
0,150 150,330 330,510 510,660 660,840
you might only get told
你可能只会被告知一次，

953
00:23:25,580 --> 00:23:26,990
0,180 180,270 270,900 930,1200 1200,1410
about it once,| but that's
|但这与 Unix 为信号处理提供的语义相同，

954
00:23:26,990 --> 00:23:28,250
0,270 270,330 330,600 600,1110 1110,1260
actually the same semantics that

955
00:23:28,250 --> 00:23:29,720
0,330 330,600 600,720 720,1320 1320,1470
Unix gives to processes for

956
00:23:29,720 --> 00:23:31,760
0,390 390,930 1170,1350 1350,1620 1620,2040
signals anyway,| so that's fine.|
|所以这很好。|

957
00:23:32,220 --> 00:23:33,480
0,150 150,510 510,570 570,780 780,1260
So those are both examples
所以，这两个都是放弃或合并事件的例子。

958
00:23:33,480 --> 00:23:35,610
0,360 360,810 810,960 960,1500 1500,2130
of dropping or coalescing events.|
|

959
00:23:36,840 --> 00:23:38,040
0,150 150,270 270,330 330,570 570,1200
And then the third choice
然后第三种选择是，

960
00:23:38,070 --> 00:23:39,480
0,180 180,390 480,660 660,960 960,1410
is that,| you might actually
|你可能不想丢掉任何事件，

961
00:23:39,480 --> 00:23:40,710
0,300 330,720 720,960 960,1140 1140,1230
just really not want to

962
00:23:40,710 --> 00:23:41,910
0,240 240,390 390,870 870,1020 1020,1200
lose any events,| it might
|它可能很重要，你不能丢失任何东西，

963
00:23:41,910 --> 00:23:43,230
0,150 150,300 300,630 630,1200 1200,1320
just be really important that

964
00:23:43,230 --> 00:23:44,850
0,90 90,360 360,600 600,1170 1380,1620
you never lose anything,| in
|在这种情况下，

965
00:23:44,850 --> 00:23:46,410
0,180 180,870 960,1080 1080,1320 1350,1560
which case,| you know you
|你可以对任意数量的事件进行排队，

966
00:23:46,410 --> 00:23:47,700
0,150 150,450 450,540 540,1050 1050,1290
can queue an arbitrary number

967
00:23:47,700 --> 00:23:48,930
0,90 90,510 510,630 630,810 810,1230
of events,| you can somehow
|你可以通过某种方式安排程序，

968
00:23:48,930 --> 00:23:51,390
0,600 600,1170 1230,1440 1440,2040 2340,2460
arrange for the program| to
|保存慢订阅者没有看到的所有事件，

969
00:23:51,390 --> 00:23:52,560
0,240 240,570 570,720 720,810 810,1170
just save all the events

970
00:23:52,560 --> 00:23:54,660
0,480 480,810 1020,1380 1380,1860 1860,2100
that the slow subscriber hasn't

971
00:23:54,660 --> 00:23:56,610
0,180 180,390 390,960 1230,1770 1770,1950
seen yet somewhere| and give
|稍后将它们提供给订阅者。

972
00:23:56,610 --> 00:23:57,960
0,150 150,330 330,450 450,900 900,1350
them to the subscriber later.|
|

973
00:23:58,720 --> 00:23:59,620
0,150 150,300 300,510 510,840 840,900
And it's really important to
在你这么做之前，仔细考虑一下是很重要的，

974
00:23:59,620 --> 00:24:00,760
0,210 210,630 630,900 900,1020 1020,1140
think carefully before you do

975
00:24:00,760 --> 00:24:02,350
0,330 480,990 990,1080 1080,1140 1140,1590
that,| because in a distributed
|因为在分布式系统中，

976
00:24:02,350 --> 00:24:03,600
0,690
system,|
|

977
00:24:03,600 --> 00:24:04,770
0,150 150,390 420,690 690,990 990,1170
you know there's always slow
总是有速度慢的计算机，

978
00:24:04,770 --> 00:24:06,990
0,420 420,630 630,1020 1020,1380 1950,2220
computers,| always computers that have
|总是有计算机下线或者别的什么，

979
00:24:06,990 --> 00:24:08,340
0,270 270,450 450,750 750,900 900,1350
fallen {offline -} or whatever,|
|

980
00:24:08,340 --> 00:24:09,120
0,120 120,210 210,360 360,450 450,780
and they might be gone
它们可能会离开一段时间，

981
00:24:09,120 --> 00:24:10,440
0,120 120,210 210,780 900,1230 1230,1320
for a while,| and so
|一般来说，你不想引入无界队列，

982
00:24:10,440 --> 00:24:11,490
0,120 120,330 330,570 570,660 660,1050
you don't want to introduce

983
00:24:11,490 --> 00:24:13,440
0,480 480,960 1260,1470 1470,1830 1830,1950
unbounded queuing, in general,| you
|在这样做之前，你需要非常仔细地考虑，

984
00:24:13,440 --> 00:24:14,550
0,180 180,300 300,540 540,750 750,1110
want to think very carefully

985
00:24:14,550 --> 00:24:15,420
0,270 270,360 360,480 480,750 750,870
before you do that,| and
|想想，无界是多么的[]，我能忍受吗。

986
00:24:15,420 --> 00:24:16,680
0,270 270,480 480,570 570,840 870,1260
think well you know how

987
00:24:16,680 --> 00:24:18,180
0,480 480,690 690,1170 1170,1350 1350,1500
unbounded is [] and can

988
00:24:18,180 --> 00:24:19,560
0,60 60,570 570,870
I tolerate that.|
|

989
00:24:19,620 --> 00:24:20,490
0,180 180,360 360,570 570,780 780,870
And so like that's a
所以，这就是为什么 channel 没有有无界缓冲的原因，

990
00:24:20,490 --> 00:24:21,960
0,300 300,570 570,990 990,1230 1230,1470
reason why channels don't have

991
00:24:21,960 --> 00:24:24,120
0,210 210,270 270,810 810,1410 1800,2160
{} an unbounded buffering {},|
|

992
00:24:24,120 --> 00:24:25,620
0,420 420,810 810,1170 1170,1410 1410,1500
it's really almost never the
这几乎从来都不是正确的选择，

993
00:24:25,620 --> 00:24:26,460
0,210 210,540 540,660 660,780 780,840
right choice,| and if it
|如果这是正确的选择，

994
00:24:26,460 --> 00:24:27,810
0,150 150,240 240,450 450,1170 1200,1350
is the right choice,| you
|你可能要非常仔细地构建它。

995
00:24:27,810 --> 00:24:28,560
0,240 240,390 390,480 480,690 690,750
probably want to build it

996
00:24:28,560 --> 00:24:29,920
0,240 240,780
very carefully.|
|

997
00:24:30,580 --> 00:24:32,200
0,540 840,1080 1080,1260 1260,1560 1560,1620
{} And so but we're
但是我们将构建一个，

998
00:24:32,200 --> 00:24:33,220
0,120 120,210 210,390 390,750 780,1020
going to build one,| just
|看看它会是什么样子。

999
00:24:33,220 --> 00:24:33,910
0,90 90,330 330,540 540,600 600,690
to see what it would

1000
00:24:33,910 --> 00:24:35,580
0,150 150,870
look like.|
|

1001
00:24:35,950 --> 00:24:37,180
0,240 240,600 600,690 690,840 840,1230
And before we do that,|
在此之前，|

1002
00:24:37,210 --> 00:24:38,560
0,240 240,420 420,540 540,840 870,1350
I just want to adjust
我想稍微调整一下程序，

1003
00:24:38,560 --> 00:24:39,640
0,90 90,450 450,510 510,720 720,1080
the program a little bit,|
|

1004
00:24:40,000 --> 00:24:41,530
0,690 900,1080 1080,1230 1230,1350 1350,1530
so we have this {mutex
所以我们在代码中有这个 mutex ，

1005
00:24:41,530 --> 00:24:43,360
0,390 390,510 510,600 600,1110 1470,1830
-} in the code,| and
|mutex 是保持状态的一个例子，

1006
00:24:43,360 --> 00:24:44,560
0,90 90,510 510,600 600,660 660,1200
the mutex is an example

1007
00:24:44,560 --> 00:24:46,780
0,450 480,720 720,1200 1200,1830 1860,2220
of of keeping the state,|
|

1008
00:24:46,780 --> 00:24:47,950
0,210 210,330 330,720 720,750 750,1170
whether you're locked or not
你是否在状态变量中加锁，

1009
00:24:48,100 --> 00:24:49,630
0,180 180,240 240,540 540,1050 1290,1530
in a state variable,| but
|但我们也可以把它移到程序计数器变量中，

1010
00:24:49,630 --> 00:24:50,830
0,90 90,240 240,540 540,840 840,1200
we can also move that

1011
00:24:50,830 --> 00:24:52,360
0,270 270,360 360,660 660,900 900,1530
into a program counter variable,|
|

1012
00:24:52,930 --> 00:24:53,740
0,240 240,540 540,660 660,750 750,810
by putting it in a
把它放在不同的 goroutine 中。

1013
00:24:53,740 --> 00:24:55,200
0,300 300,420 420,900
different {goroutine -}.|
|

1014
00:24:55,200 --> 00:24:56,720
0,180 180,480
And so,
在本例中，

1015
00:24:56,990 --> 00:24:58,100
0,360 360,540 540,870 870,990 990,1110
in this case,| we can
|我们可以启动一个新的 goroutine ，

1016
00:24:58,100 --> 00:24:59,450
0,300 300,360 360,570 570,750 750,1350
start a new {goroutine -},|
|

1017
00:24:59,600 --> 00:25:01,160
0,360 360,570 570,660 660,1230 1230,1560
that runs a program function
它运行一个名为 s.loop 的程序函数，

1018
00:25:01,160 --> 00:25:02,740
0,270 270,390 390,630 630,1020
called {s.loop - -},|
|

1019
00:25:02,860 --> 00:25:04,270
0,150 150,270 270,660 660,1140 1140,1410
and it handles requests sent
它处理在三个新 channel 上发送的请求，

1020
00:25:04,270 --> 00:25:05,890
0,240 240,570 570,780 780,1260 1260,1620
on three new channels,| publish
|publish subscribe 和 cancel 。

1021
00:25:05,890 --> 00:25:07,720
0,540 540,630 630,1260
subscribe and cancel.|
|

1022
00:25:07,870 --> 00:25:09,070
0,180 180,330 330,570 570,870 900,1200
And so in Init,| we
在 Init 中，|我们创建 channel ，

1023
00:25:09,070 --> 00:25:10,690
0,210 210,300 300,1080 1170,1290 1290,1620
make the channels| and then
|然后启动 s.loop 。

1024
00:25:10,690 --> 00:25:11,980
0,180 180,390 390,840 870,1050 1050,1290
we kick off {s.loop -

1025
00:25:11,980 --> 00:25:12,920
0,420
-}.|
|

1026
00:25:13,140 --> 00:25:14,550
0,180 180,300 300,570 570,1110 1170,1410
And {s.loop - -} is
而 s.loop 则是前面方法体的一种合并，

1027
00:25:14,550 --> 00:25:16,230
0,270 270,480 480,660 660,1500 1500,1680
sort of the amalgamation of

1028
00:25:16,230 --> 00:25:18,060
0,120 120,510 510,780 780,1440 1530,1830
the previous method bodies,| and
|它从三个 channel 中的任何一个接收，

1029
00:25:18,060 --> 00:25:19,650
0,120 120,420 450,1140 1140,1350 1350,1590
it just receives from any

1030
00:25:19,650 --> 00:25:21,000
0,120 120,270 270,480 480,1200 1230,1350
of the three channels,| a
|publish subscribe 或 cancel 请求，

1031
00:25:21,000 --> 00:25:22,800
0,570 570,690 690,1200 1200,1740 1740,1800
request {} publish subscribe or

1032
00:25:22,800 --> 00:25:24,690
0,360 360,870 1260,1440 1440,1590 1590,1890
cancel request,| and it does
|它会做任何被要求的事情，

1033
00:25:24,690 --> 00:25:26,640
0,360 360,510 510,1050 1440,1650 1650,1950
whatever was asked,| and now
|现在 subscriber map 可以只是 s.loop 中的一个局部变量。

1034
00:25:26,640 --> 00:25:28,650
0,270 270,690 690,810 810,1410 1410,2010
that map, the subscriber map,

1035
00:25:29,160 --> 00:25:30,300
0,300 300,480 480,690 690,720 720,1140
can be just a local

1036
00:25:30,300 --> 00:25:31,770
0,540 540,660 660,840 840,1110 1110,1470
variable in {s.loop - -}.|
|

1037
00:25:32,320 --> 00:25:34,120
0,300 300,510 510,870 870,870 1470,1800
And and so {} it's
所以这是相同的代码，

1038
00:25:34,120 --> 00:25:35,600
0,90 90,390 390,930
the same code,|
|

1039
00:25:35,690 --> 00:25:37,280
0,240 240,750 780,1110 1110,1410 1410,1590
but now that data is
但是现在这些数据显然归 s.loop 所有，

1040
00:25:37,280 --> 00:25:38,630
0,510 510,780 780,930 930,1140 1140,1350
clearly owned by {s.loop -

1041
00:25:38,630 --> 00:25:39,710
0,210 210,540 540,750 750,900 900,1080
-},| nothing else could even
|其他任何东西都不能访问它，

1042
00:25:39,710 --> 00:25:40,430
0,210 210,330 330,390 390,570 570,720
get to it,| because it's
|因为它是一个局部变量。

1043
00:25:40,430 --> 00:25:41,920
0,60 60,480 570,930
a local variable.|
|

1044
00:25:44,080 --> 00:25:45,010
0,300 300,480 480,630 630,720 720,930
{} And then we just
然后，我们只需要更改原始方法，

1045
00:25:45,010 --> 00:25:46,120
0,120 120,210 210,630 630,720 720,1110
need to change the original

1046
00:25:46,120 --> 00:25:47,410
0,450 450,570 570,900 900,990 990,1290
methods| to send the work
|将工作发送到 loop goroutine ，

1047
00:25:47,410 --> 00:25:48,370
0,330 330,420 420,540 540,780 780,960
over to the loop {goroutine

1048
00:25:48,370 --> 00:25:50,230
0,360 360,480 480,690 690,1200 1200,1860
-},| and so uppercase Publish
|大写的 Publish 现在发送给小写的 publish channel ，

1049
00:25:50,290 --> 00:25:52,510
0,750 780,1470 1470,1710 1710,1950 1950,2220
now sends on lower case

1050
00:25:52,510 --> 00:25:54,460
0,360 360,480 480,1140 1290,1560 1560,1950
publish the channel,| the event
|事件想要发送的（channel），

1051
00:25:54,460 --> 00:25:55,600
0,240 240,450 450,660 660,750 750,1140
that it wants to publish,|
|

1052
00:25:55,600 --> 00:25:57,730
0,150 150,630 630,1320 1320,1440 1440,2130
and similarly subscribe and cancel.|
类似地 subscribe 和 cancel 。|

1053
00:25:58,230 --> 00:26:00,150
0,240 240,690 690,780 780,1530 1650,1920
They create a request that
它们创建具有 channel 的请求，

1054
00:26:00,150 --> 00:26:01,980
0,180 180,270 270,960 1170,1590 1620,1830
has a channel,| {} that
|我们想要订阅，

1055
00:26:01,980 --> 00:26:03,030
0,120 120,300 300,360 360,960 960,1050
we want to subscribe| and
|也有一个 channel 可以获得回复，

1056
00:26:03,030 --> 00:26:04,200
0,450 450,570 570,900 900,1020 1020,1170
also a channel to get

1057
00:26:04,200 --> 00:26:05,580
0,120 120,390 390,840 1020,1260 1260,1380
the answer back,| and they
|它们将其发送到循环中，

1058
00:26:05,580 --> 00:26:06,960
0,300 300,480 480,750 750,900 900,1380
send that into the loop|
|

1059
00:26:07,110 --> 00:26:08,220
0,300 300,390 390,600 600,840 840,1110
and the loop sends back
循环返回答案。

1060
00:26:08,220 --> 00:26:09,340
0,120 120,630
the answer.|
|

1061
00:26:12,040 --> 00:26:13,510
0,120 120,420 810,960 960,1380 1380,1470
And so I referred to
我将程序的这种转换方式称为

1062
00:26:13,510 --> 00:26:14,980
0,660 660,750 750,1110 1110,1260 1260,1470
transforming the program this way|
|

1063
00:26:14,980 --> 00:26:16,660
0,300 300,780 780,870 870,1380 1380,1680
as converting the mutex into
将 mutex 转换为 goroutine ，

1064
00:26:16,660 --> 00:26:18,340
0,120 120,270 270,810 900,1500 1530,1680
a {goroutine -},| because we
|因为我们获取了 mutex 的数据状态，

1065
00:26:18,340 --> 00:26:19,180
0,180 180,300 300,570 570,780 780,840
took the data state of

1066
00:26:19,180 --> 00:26:20,350
0,60 60,480 480,660 660,810 810,1170
the mutex,| there's a lock
|里面有一个锁位，

1067
00:26:20,350 --> 00:26:21,400
0,150 150,600 600,750 750,840 840,1050
bit inside it,| and now
|现在锁位隐含在循环的程序计数器中。

1068
00:26:21,400 --> 00:26:22,900
0,210 210,480 480,660 660,870 870,1500
that lock bit is implicit

1069
00:26:22,900 --> 00:26:23,950
0,120 120,210 210,570 570,900 900,1050
in the program counter of

1070
00:26:23,950 --> 00:26:24,960
0,90 90,510
the loop.|
|

1071
00:26:26,050 --> 00:26:27,010
0,180 180,420 420,690 690,810 810,960
It's very clear that,| you
很明显，|发布和订阅不能同时发生，

1072
00:26:27,010 --> 00:26:28,840
0,330 330,570 570,900 900,1410 1410,1830
can't ever have a publish

1073
00:26:28,840 --> 00:26:30,040
0,180 180,690 690,1020 1020,1110 1110,1200
and subscribe happening at the

1074
00:26:30,040 --> 00:26:32,290
0,270 270,780 810,1680 1890,2070 2070,2250
same time,| because it's just
|因为这只是单线程代码，

1075
00:26:32,290 --> 00:26:33,490
0,240 240,510 510,810 810,900 900,1200
single thread code| and just
|只是序列执行。

1076
00:26:33,490 --> 00:26:35,420
0,90 90,270 270,810 810,1500
you know executed sequence.|
|

1077
00:26:36,660 --> 00:26:37,800
0,150 150,240 240,360 360,630 630,1140
On the other hand,| the
另一方面，|原始版本有一种类似的状态清晰度，

1078
00:26:37,800 --> 00:26:39,180
0,540 540,870 870,1080 1080,1140 1140,1380
original version had a kind

1079
00:26:39,180 --> 00:26:40,620
0,120 120,330 330,780 780,870 870,1440
of like clarity of state,|
|

1080
00:26:40,620 --> 00:26:41,400
0,270 270,420 420,570 570,720 720,780
where you could sort of
在那里你可以对它进行检查，

1081
00:26:41,400 --> 00:26:43,470
0,510 510,780 990,1500 1500,1770 1770,2070
inspect it,| and reason about
|推出这是一个重要的状态，

1082
00:26:43,470 --> 00:26:44,550
0,150 150,360 360,450 450,570 570,1080
well this is the important

1083
00:26:44,550 --> 00:26:46,560
0,480 810,1050 1050,1290 1290,1740 1740,2010
state,| and it's harder in
|在 goroutine 版本中，比较难看出什么是重要的状态，

1084
00:26:46,560 --> 00:26:48,090
0,450 480,720 720,1110 1110,1440 1440,1530
the the goroutine version to

1085
00:26:48,090 --> 00:26:49,620
0,300 300,570 570,990 990,1440 1440,1530
see what's important state,| and
|附带的状态是有一个 goroutine 。

1086
00:26:49,620 --> 00:26:51,570
0,330 330,480 480,750 810,1560 1560,1950
what's kind of incidental state

1087
00:26:51,570 --> 00:26:52,860
0,150 150,330 330,630 630,780 780,1290
from just having a goroutine.|
|

1088
00:26:53,680 --> 00:26:55,480
0,390 420,540 540,660 660,900 900,1800
And in a given situation,|
在给定的情况下，|

1089
00:26:55,540 --> 00:26:56,890
0,420 420,600 600,720 720,930 930,1350
one might be more important
其中一个可能比另一个更重要，

1090
00:26:56,890 --> 00:26:58,480
0,90 90,210 210,600 960,1260 1260,1590
than the other,| so a
|几年前，

1091
00:26:58,480 --> 00:26:59,440
0,240 240,450 450,660 660,780 780,960
couple years ago,| I did
|我做了所有的实验，

1092
00:26:59,440 --> 00:27:00,580
0,300 330,540 540,960 960,1080 1080,1140
all the labs for the

1093
00:27:00,580 --> 00:27:01,660
0,360 360,510 510,630 630,840 840,1080
class,| when it first switched
|当它换成 Go 的时候，

1094
00:27:01,660 --> 00:27:03,700
0,60 60,540 780,1380 1410,1950 1950,2040
to Go,| and raft is
|raft 是一个很好的例子，

1095
00:27:03,700 --> 00:27:05,470
0,90 90,300 300,900 900,1050 1050,1770
a good example| of where
|你可能更喜欢使用 mutex 状态，

1096
00:27:05,500 --> 00:27:07,000
0,240 240,870 870,1200 1200,1260 1260,1500
you probably prefer the state

1097
00:27:07,000 --> 00:27:08,260
0,90 90,150 150,300 300,810 810,1260
with the {mutex -},| because
|因为 raft 与大多数并发程序非常不同，

1098
00:27:08,380 --> 00:27:10,750
0,660 660,1350 1530,1830 1830,2220 2220,2370
raft is so different from

1099
00:27:10,750 --> 00:27:12,880
0,540 540,990 990,1530 1530,1650 1650,2130
most concurrent programs,| and that
|每个复制节点对自己的状态的不确定性，

1100
00:27:13,060 --> 00:27:14,320
0,360 360,750 750,930 930,1110 1110,1260
each replica is just kind

1101
00:27:14,320 --> 00:27:16,360
0,180 180,1080 1080,1770 1770,1890 1890,2040
of profoundly uncertain of its

1102
00:27:16,360 --> 00:27:17,710
0,420 450,750 750,930 930,1050 1050,1350
state, right,| like the state
|比如状态转换，

1103
00:27:17,710 --> 00:27:18,940
0,720
transitions,|
|

1104
00:27:18,970 --> 00:27:19,810
0,180 180,240 240,480 480,750 750,840
you know one moment you
一瞬间你是领导者，

1105
00:27:19,810 --> 00:27:20,680
0,150 150,270 270,390 390,780 780,870
think you're the leader,| and
|下一瞬间你被罢免，

1106
00:27:20,680 --> 00:27:21,520
0,60 60,270 270,600 600,720 720,840
the next moment you've been

1107
00:27:21,520 --> 00:27:22,870
0,690 690,840 840,990 990,1260 1260,1350
deposed,| like one moment your
|比如一瞬间你的日志有 10 个条目，

1108
00:27:22,870 --> 00:27:23,920
0,210 210,390 390,570 570,960 960,1050
log has ten entries,| and
|下一瞬间只有 2 个条目，

1109
00:27:23,920 --> 00:27:24,940
0,150 150,390 390,570 570,840 840,1020
next moment {} actually {you,know}

1110
00:27:24,940 --> 00:27:25,990
0,90 90,240 240,390 390,570 570,1050
it only has two entries,|
|

1111
00:27:26,170 --> 00:27:27,100
0,240 240,390 390,570 570,780 780,930
and so being able to
为了能够直接操纵这种状态，

1112
00:27:27,100 --> 00:27:29,620
0,780 780,1020 1020,1290 1290,2010 2040,2520
manipulate that state directly| rather
|而不是不得不以某种方式进出程序计数器，

1113
00:27:29,620 --> 00:27:31,420
0,150 150,450 450,810 840,1560 1560,1800
than having to somehow get

1114
00:27:31,420 --> 00:27:32,050
0,210 210,360 360,510 510,570 570,630
in and out of the

1115
00:27:32,050 --> 00:27:33,700
0,330 330,810 870,1260 1260,1470 1470,1650
program counter,| makes {a,lot} more
|对于 raft 来说更有意义。

1116
00:27:33,700 --> 00:27:35,260
0,240 240,420 420,960 1080,1350 1350,1560
sense for raft.| But that's
|但在大多数情况下，这是非常独特的，

1117
00:27:35,260 --> 00:27:37,450
0,270 270,660 660,750 750,1140 1140,2190
pretty unique in most situations,|
|

1118
00:27:38,010 --> 00:27:39,090
0,210 210,540 540,750 750,990 990,1080
it cleans things up to
将状态放在程序计数器中更清楚。

1119
00:27:39,090 --> 00:27:39,810
0,120 120,210 210,540 540,630 630,720
put the state in the

1120
00:27:39,810 --> 00:27:41,180
0,330 330,750
program counter.|
|

1121
00:27:42,620 --> 00:27:44,270
0,450 480,1110 1230,1380 1380,1560 1560,1650
Alright, so in order to
好的，为了应对缓慢的订阅者，

1122
00:27:44,270 --> 00:27:45,950
0,210 210,330 330,420 420,630 630,1680
deal with the slow subscribers,|
|

1123
00:27:46,010 --> 00:27:47,060
0,420 420,540 540,690 690,930 930,1050
now we're gonna add some
现在我们将添加一些 helper goroutine ，

1124
00:27:47,060 --> 00:27:48,620
0,330 330,450 450,1110 1200,1410 1410,1560
helper {goroutines -},| and their
|它们的工作是管理特定的订阅者积压，

1125
00:27:48,620 --> 00:27:50,390
0,690 720,1050 1050,1140 1140,1620 1620,1770
job is to manage a

1126
00:27:50,390 --> 00:27:52,640
0,450 450,1020 1020,1770 1800,2010 2010,2250
particular subscribers backlog| and keep
|并防止整个程序被阻止。

1127
00:27:52,640 --> 00:27:54,170
0,90 90,510 510,870 870,990 990,1530
the overall program from blocking.|
|

1128
00:27:54,530 --> 00:27:55,400
0,240 240,450 450,690 690,780 780,870
And so this is the
这就是 helper goroutine ，

1129
00:27:55,400 --> 00:27:56,820
0,300 300,480 480,960
helper {goroutine -},|
|

1130
00:27:56,970 --> 00:27:58,560
0,270 270,780 780,900 900,1320 1320,1590
and the the main loop
主循环 goroutine 会将事件发送给 helper ，

1131
00:27:58,560 --> 00:27:59,700
0,420 420,540 540,780 780,840 840,1140
goroutine will send the events

1132
00:27:59,700 --> 00:28:01,260
0,90 90,180 180,960 1140,1410 1410,1560
to the helper,| which we
|我们信任的，因为是我们编写的，

1133
00:28:01,260 --> 00:28:02,580
0,210 210,630 630,900 900,1050 1050,1320
then trust, because we wrote

1134
00:28:02,580 --> 00:28:04,320
0,270 330,780 780,870 870,1140 1140,1740
it,| not to fall arbitrarily
|不会随意落后，

1135
00:28:04,320 --> 00:28:05,910
0,690 840,1110 1110,1200 1200,1290 1290,1590
behind,| and then the {helper's
|然后， helper 的工作是对事件进行排队，

1136
00:28:05,910 --> 00:28:07,320
0,90 90,390 390,510 510,1050 1140,1410
-} job is to queue

1137
00:28:07,320 --> 00:28:08,520
0,360 360,480 480,840 840,960 960,1200
events it needed| and send
|并将其发送给订阅者。

1138
00:28:08,520 --> 00:28:09,810
0,90 90,330 330,420 420,510 510,1290
them off to the subscriber.|
|

1139
00:28:10,860 --> 00:28:13,230
0,630 780,1110 1110,1410 1410,1710 1710,2370
Alright, so this actually has
好的，这里有两个问题。

1140
00:28:13,260 --> 00:28:14,760
0,210 210,1020
two problems.|
|

1141
00:28:14,790 --> 00:28:16,410
0,180 180,600 600,780 780,1140 1470,1620
The first is that,| if
第一个是，|如果队列中没有任何东西，

1142
00:28:16,410 --> 00:28:17,730
0,150 150,420 420,480 480,570 570,1320
there's nothing in the queue,|
|

1143
00:28:17,760 --> 00:28:19,290
0,540 570,720 720,1080 1080,1200 1200,1530
then the select is actually
则 select 尝试提供 q[0] 是错误的，

1144
00:28:19,290 --> 00:28:20,490
0,480 480,570 570,780 780,870 870,1200
wrong to try to offer

1145
00:28:20,490 --> 00:28:21,450
0,210 210,300 300,780 780,870 870,960
queue of zero,| and in
|事实上，仅仅计算 q[0] ，

1146
00:28:21,450 --> 00:28:22,800
0,270 270,450 450,1050 1050,1230 1230,1350
fact just evaluating queue of

1147
00:28:22,800 --> 00:28:23,580
0,300 300,390 390,450 450,720 720,780
0,| at the start of
|select 的开头就会出现 panic ，

1148
00:28:23,580 --> 00:28:25,200
0,90 90,420 420,510 510,1050 1050,1620
the select will panic,| because
|因为队列是空的，

1149
00:28:25,200 --> 00:28:26,730
0,120 120,330 330,420 420,900 1380,1530
the queue is empty，| and
|因此，我们可以修复这些，

1150
00:28:26,730 --> 00:28:28,320
0,420 450,600 600,780 780,1020 1020,1590
so we can fix these,|
|

1151
00:28:28,800 --> 00:28:30,270
0,270 270,630 630,810 810,900 900,1470
by setting up the arguments
通过将参数与 select 分开设置，

1152
00:28:30,270 --> 00:28:31,980
0,600 600,810 810,900 900,1530 1560,1710
separately from the select,| and
|我们需要创建一个 channel sendOut ，

1153
00:28:31,980 --> 00:28:33,390
0,90 90,870 930,1170 1170,1320 1320,1410
in particular we need to

1154
00:28:33,390 --> 00:28:35,520
0,360 390,900 900,1350 1350,1710 1710,2130
make a channel {sendOut -},|
|

1155
00:28:35,640 --> 00:28:36,840
0,390 390,570 570,660 660,780 780,1200
that's going to be nil,|
它会是 nil ，|

1156
00:28:36,840 --> 00:28:38,400
0,570 600,780 780,1230 1230,1440 1440,1560
which is never able to
它永远不能在 select 中进行，

1157
00:28:38,400 --> 00:28:40,120
0,510 510,630 630,690 690,1230
proceed in a select,|
|

1158
00:28:41,210 --> 00:28:41,990
0,150 150,300 300,480 480,690 690,780
as we know, when we
正如我们知道的，当我们不想发送，

1159
00:28:41,990 --> 00:28:42,980
0,180 180,330 330,390 390,840 840,990
don't want to send,| and
|它将成为实际的 out channel ，

1160
00:28:42,980 --> 00:28:43,520
0,120 120,240 240,300 300,390 390,540
it's going to be the

1161
00:28:43,520 --> 00:28:44,900
0,600 600,870 870,1140 1140,1290 1290,1380
actual out channel,| when we
|当我们想要发送时，

1162
00:28:44,900 --> 00:28:46,340
0,150 150,360 360,420 420,870 1260,1440
do want to send,| and
|然后我们必须有一个单独的变量，

1163
00:28:46,340 --> 00:28:47,060
0,210 210,330 330,480 480,570 570,720
then we have to have

1164
00:28:47,060 --> 00:28:48,320
0,60 60,390 390,780 780,900 900,1260
a separate variable,| that holds
|来保存我们要发送的事件，

1165
00:28:48,320 --> 00:28:49,100
0,120 120,450 450,570 570,660 660,780
the event that we're going

1166
00:28:49,100 --> 00:28:50,810
0,60 60,420 420,480 480,990 1140,1710
to send,| it will actually
|它从 q[0] 读取，

1167
00:28:50,810 --> 00:28:51,950
0,240 240,390 390,660 660,1020 1020,1140
read from queue {of,zero},| if
|如果队列中有东西。

1168
00:28:51,950 --> 00:28:52,970
0,180 180,450 450,570 570,630 630,1020
there's something in the queue.|
|

1169
00:28:55,400 --> 00:28:56,690
0,180 180,540 540,660 660,840 840,1290
The second thing that's wrong
错误的第二件事是，

1170
00:28:57,020 --> 00:28:57,770
0,150 150,420 420,510 510,690 690,750
is that,| we need to
|我们需要处理输入 channel 的关闭，

1171
00:28:57,770 --> 00:28:59,450
0,300 300,840 840,1140 1140,1200 1200,1680
handle closing of the channel,

1172
00:28:59,450 --> 00:29:00,770
0,60 60,180 180,420 420,810 930,1320
of the input channel,| because
|因为当输入 channel 关闭时，

1173
00:29:00,770 --> 00:29:02,330
0,180 180,270 270,540 540,810 810,1560
when the input channel closes,|
|

1174
00:29:02,390 --> 00:29:03,320
0,210 210,360 360,450 450,840 840,930
we need to flush the
我们需要[冲掉]剩下的队列，

1175
00:29:03,320 --> 00:29:04,190
0,240 240,330 330,390 390,750 750,870
rest of the queue,| and
|然后我们需要关闭输出 channel 。

1176
00:29:04,190 --> 00:29:05,000
0,150 150,270 270,420 420,480 480,810
then we need to close

1177
00:29:05,000 --> 00:29:06,360
0,150 150,420 420,870
the output channel.|
|

1178
00:29:06,750 --> 00:29:07,950
0,210 210,300 300,540 540,660 660,1200
So to check for that,|
所以，为了检查这一点，|

1179
00:29:08,100 --> 00:29:09,390
0,270 270,600 600,690 690,1110 1110,1290
we change the select| from
我们修改 select ，|从 e 等于从 in 接收

1180
00:29:09,390 --> 00:29:11,400
0,420 420,780 780,1530 1530,1860 1860,2010
just doing {e,equals} receiving from

1181
00:29:11,400 --> 00:29:13,050
0,390 540,840 840,1020 1020,1260 1260,1650
in| to {e\,,ok - -}
|变为 e, ok 等于从 in 接收，

1182
00:29:13,050 --> 00:29:14,220
0,300 300,630 630,780 780,1080 1080,1170
equals receiving from in,| the
|逗号 ok 将会表示，

1183
00:29:14,220 --> 00:29:15,750
0,270 270,600 600,780 780,900 900,1530
comma ok will be told|
|

1184
00:29:15,780 --> 00:29:17,130
0,390 390,480 480,810 810,900 900,1350
whether or not the channel
channel 是否发送真正的数据，

1185
00:29:17,130 --> 00:29:18,540
0,240 240,570 570,870 870,1050 1050,1410
is actually sending real data,|
|

1186
00:29:18,540 --> 00:29:20,100
0,180 180,360 360,510 510,1170
or else it's closed.|
否则它是关闭的。|

1187
00:29:20,280 --> 00:29:21,060
0,150 150,270 270,390 390,630 630,780
And so when ok is
所以当 ok 为 false 时，

1188
00:29:21,060 --> 00:29:22,800
0,570 660,990 990,1170 1170,1410 1410,1740
false,| we can set {in,to}
|我们可以把 in 设置为 nil ，

1189
00:29:22,800 --> 00:29:24,210
0,510 540,660 660,870 870,1170 1170,1410
nil,| to say let's stop
|表示我们停止从 in 接收，

1190
00:29:24,210 --> 00:29:25,110
0,270 270,330 330,630 630,750 750,900
trying to receive from in,|
|

1191
00:29:25,110 --> 00:29:26,010
0,150 150,450 450,630 630,750 750,900
there's nothing there,| we're just
那里没有东西，|我们被告知它已经关闭了。

1192
00:29:26,010 --> 00:29:26,910
0,120 120,330 330,540 540,780 780,900
gonna keep getting told that

1193
00:29:26,910 --> 00:29:28,200
0,120 120,810
it's closed.|
|

1194
00:29:28,730 --> 00:29:30,050
0,150 150,510 570,960 960,1080 1080,1320
And then when the loop
然后，当循环正常时，

1195
00:29:30,050 --> 00:29:31,640
0,180 180,660 660,900 900,1260 1290,1590
is fine,| when the queue
|当队列最终为空时，

1196
00:29:31,640 --> 00:29:33,020
0,150 150,540 540,1020 1050,1200 1200,1380
is finally empty,| we can
|我们可以退出循环，

1197
00:29:33,020 --> 00:29:34,310
0,300 300,420 420,930 1020,1170 1170,1290
exit the loop,| and so
|所以，我们更改了 for 条件，

1198
00:29:34,310 --> 00:29:35,780
0,120 120,450 450,570 570,840 840,1470
we change the for condition,|
|

1199
00:29:35,840 --> 00:29:37,250
0,240 240,840 870,1170 1170,1350 1350,1410
to say we want to
表示我们希望继续执行循环，

1200
00:29:37,250 --> 00:29:38,150
0,180 180,450 450,540 540,780 780,900
keep executing the loop| as
|当输入 channel 为真时，

1201
00:29:38,150 --> 00:29:39,530
0,210 210,630 630,840 840,1080 1080,1380
long as there actually still

1202
00:29:39,530 --> 00:29:41,090
0,120 120,210 210,450 450,960 1350,1560
is an input channel,| and
|并且有一些内容要写回输出 channel ，

1203
00:29:41,090 --> 00:29:42,530
0,150 150,690 840,1020 1020,1260 1260,1440
there's something to write back

1204
00:29:42,530 --> 00:29:43,370
0,90 90,210 210,480 480,750 750,840
to the output channel,| and
|一旦这两个都不再为真，

1205
00:29:43,370 --> 00:29:44,330
0,90 90,300 300,510 510,600 600,960
then once both of those

1206
00:29:44,330 --> 00:29:46,220
0,360 390,720 720,960 960,1560 1680,1890
are not true anymore,| it's
|是退出循环的时候了，

1207
00:29:46,220 --> 00:29:47,870
0,180 180,900 900,1200 1200,1260 1260,1650
time to exit the loop|
|

1208
00:29:47,930 --> 00:29:48,740
0,120 120,210 210,450 450,570 570,810
and we close the output
我们关闭输出 channel ，

1209
00:29:48,740 --> 00:29:50,180
0,480 750,930 930,1020 1020,1290 1290,1440
channel| and we're done.| And
|我们就完事了。|现在我们已经正确地传播了，

1210
00:29:50,180 --> 00:29:51,890
0,120 120,300 300,450 450,900 900,1710
so now we've correctly propagated|
|

1211
00:29:52,010 --> 00:29:53,630
0,300 300,930 1050,1260 1260,1380 1380,1620
the closing of the input
输入 channel 的关闭到输出 channel ，

1212
00:29:53,630 --> 00:29:54,950
0,390 390,480 480,600 600,870 870,1320
channel to the output channel,|
|

1213
00:29:56,640 --> 00:29:57,810
0,240 240,360 360,450 450,510 510,1170
so that was the helper.|
所以那就是 helper 。|

1214
00:29:58,110 --> 00:29:59,340
0,240 240,300 300,630 630,1050 1050,1230
And the Server loop used
而 Server loop 过去是这样的，

1215
00:29:59,340 --> 00:30:01,320
0,60 60,210 210,390 390,900
to look like this,|
|

1216
00:30:01,470 --> 00:30:03,030
0,180 180,270 270,720 720,1050 1230,1560
and to update it,| we
为了更新它，|我们只需修改订阅者 map ，

1217
00:30:03,030 --> 00:30:04,650
0,210 210,540 540,630 630,1170 1170,1620
just changed the subscription map,|
|

1218
00:30:04,740 --> 00:30:06,120
0,690 690,780 780,900 900,960 960,1380
before it was a map
之前它是一个从订阅者 channel 到 bool 的映射，

1219
00:30:06,120 --> 00:30:07,770
0,210 210,720 720,1110 1110,1200 1200,1650
from subscribe channels to bools,|
|

1220
00:30:07,770 --> 00:30:08,610
0,90 90,210 210,390 390,780 780,840
it was just basically a
基本上只是一个 set ，

1221
00:30:08,610 --> 00:30:10,080
0,480 870,1050 1050,1260 1260,1410 1410,1470
set,| and now it's a
|现在它是从订阅者 channel 到 helper channel 的映射，

1222
00:30:10,080 --> 00:30:11,820
0,360 360,540 540,1080 1080,1590 1620,1740
map from subscribe channel to

1223
00:30:11,820 --> 00:30:13,440
0,300 300,390 390,930 1260,1440 1440,1620
{helper -} channel,| and every
|每次我们收到新的订阅，

1224
00:30:13,440 --> 00:30:14,040
0,180 180,270 270,390 390,450 450,600
time we get a new

1225
00:30:14,040 --> 00:30:16,140
0,840 1020,1440 1470,1740 1740,1800 1800,2100
subscription,| we make a helper
|我们创建一个 helper channel ，

1226
00:30:16,140 --> 00:30:17,790
0,510 540,690 690,1230 1230,1350 1350,1650
channel,| we kickoff a helper
|我们启动一个 helper goroutine ，

1227
00:30:17,790 --> 00:30:18,920
0,120 120,720
{goroutine -},|
|

1228
00:30:19,040 --> 00:30:20,060
0,210 210,300 300,660 660,720 720,1020
and we record the helper
我们将 helper channel 记录在订阅映射中，

1229
00:30:20,060 --> 00:30:21,710
0,450 450,600 600,690 690,1170 1170,1650
channel in the subscription map|
|

1230
00:30:21,740 --> 00:30:23,810
0,570 570,1080 1110,1290 1290,1650 1650,2070
instead of the actual channel.|
而不是实际的 channel 中。|

1231
00:30:24,510 --> 00:30:25,710
0,240 240,360 360,450 450,780 780,1200
And then the rest of,
然后，循环的其余部分几乎没有改变。

1232
00:30:26,390 --> 00:30:28,070
0,360 360,570 570,810 810,930 930,1680
{} the rest of the

1233
00:30:28,100 --> 00:30:30,080
0,360 360,990 1080,1530 1530,1890 1890,1980
loop actually barely changes at

1234
00:30:30,080 --> 00:30:31,040
0,390
all.|
|

1235
00:30:32,490 --> 00:30:33,450
0,390 390,630 630,750 750,900 900,960
So I do want to
所以我想指出的是，

1236
00:30:33,450 --> 00:30:34,410
0,180 180,330 330,420 420,810 810,960
point out that,| if you
|如果你想使用不同的策略，

1237
00:30:34,410 --> 00:30:35,670
0,360 360,450 450,840 840,960 960,1260
wanted to have a different

1238
00:30:35,670 --> 00:30:37,620
0,600 600,1080 1110,1500 1500,1680 1680,1950
strategy| for what you do
|对落后太多的客户端，

1239
00:30:37,620 --> 00:30:39,660
0,480 840,1200 1230,1710 1710,1830 1830,2040
with {} clients that fall

1240
00:30:39,660 --> 00:30:41,040
0,120 120,300 300,870 960,1260 1260,1380
too far behind,| that can
|这些都可以放在 helper goroutine 中，

1241
00:30:41,040 --> 00:30:41,850
0,210 210,390 390,450 450,510 510,810
all go in the helper

1242
00:30:41,850 --> 00:30:42,900
0,120 120,540 600,720 720,960 960,1050
{goroutine -},| the code on
|现在屏幕上的代码完全没有变化，

1243
00:30:42,900 --> 00:30:44,340
0,60 60,330 330,480 480,1110 1260,1440
the screen right now is

1244
00:30:44,340 --> 00:30:46,410
0,390 390,990 990,1140 1140,1590 1590,2070
completely unchanged,| so we've completely
|所以，我们完全分离了 pubish subscribe ，

1245
00:30:46,410 --> 00:30:48,930
0,570 570,960 990,1320 1320,1950 1950,2520
separated the publish subscribe,| maintaining
|维护了订阅者的列表映射，

1246
00:30:48,930 --> 00:30:50,730
0,600 600,990 990,1170 1170,1260 1260,1800
the actual [list] of subscribers

1247
00:30:50,730 --> 00:30:52,320
0,420 450,900 900,1110 1110,1470 1470,1590
map,| from the what do
|如果事情变得太慢，你会怎么做。

1248
00:30:52,320 --> 00:30:53,400
0,180 180,420 420,630 630,870 870,1080
you do when things get

1249
00:30:53,400 --> 00:30:55,620
0,150 150,450 450,840 1020,1680 1680,2220
too slow map {} problem.|
|

1250
00:30:55,950 --> 00:30:57,020
0,210 210,720
And so
所以，这非常好，

1251
00:30:57,220 --> 00:30:58,390
0,240 240,480 480,840 840,1050 1050,1170
it's really nice,| that you've
|你将关注点清晰地分离到完全不同的 goroutine 中，

1252
00:30:58,390 --> 00:30:59,710
0,150 150,270 270,720 720,1260 1260,1320
got this clean separation of

1253
00:30:59,710 --> 00:31:01,690
0,540 540,690 690,1110 1110,1410 1410,1980
concerns into completely different goroutines,|
|

1254
00:31:01,690 --> 00:31:02,620
0,120 120,270 270,360 360,600 600,930
and that can help you
这可以帮助你的程序更简单。

1255
00:31:02,620 --> 00:31:04,360
0,240 240,360 360,750 750,1200
keep your programs simpler.|
|

1256
00:31:04,360 --> 00:31:05,110
0,120 120,210 210,390 390,480 480,750
And so that's the general
这就是一般的提示，

1257
00:31:05,110 --> 00:31:06,400
0,210 210,300 300,570 960,1170 1170,1290
hint is that,| you can
|你可以在很多时候使用 goroutine 来分离独立的关注点。

1258
00:31:06,400 --> 00:31:07,660
0,240 240,420 420,870 870,990 990,1260
use {goroutines -} a lot

1259
00:31:07,660 --> 00:31:08,830
0,60 60,150 150,450 450,570 570,1170
of the time to separate

1260
00:31:08,830 --> 00:31:10,560
0,480 480,1260
independent concerns.|
|

1261
00:31:11,970 --> 00:31:13,700
0,510
Alright,|
好的，|

1262
00:31:14,670 --> 00:31:16,470
0,450 450,930 960,1080 1080,1320 1320,1800
so {} the second pattern
今天的第二个模式是工作调度器，

1263
00:31:16,470 --> 00:31:17,460
0,240 240,420 420,750 750,810 810,990
for today is {} work

1264
00:31:17,460 --> 00:31:19,110
0,690 1110,1290 1290,1380 1380,1500 1500,1650
scheduler,| and you did one
|你在第一个实验 mapreduce 中做了一个，

1265
00:31:19,110 --> 00:31:19,980
0,90 90,300 300,390 390,660 660,870
of these in lab 1

1266
00:31:19,980 --> 00:31:21,270
0,120 120,330 330,900 1080,1230 1230,1290
for {mapreduce -},| and I'm
|我要做的就是它，

1267
00:31:21,270 --> 00:31:22,410
0,150 150,330 330,750 750,990 990,1140
just going to build up

1268
00:31:22,410 --> 00:31:24,630
0,90 90,420 810,1290 1290,1830 1830,2220
to that,| and this doesn't
|这并做不所有的 RPC 功能，

1269
00:31:24,630 --> 00:31:25,440
0,120 120,240 240,360 360,480 480,810
do all the {RPC -}

1270
00:31:25,440 --> 00:31:26,160
0,300 300,360 360,540 540,660 660,720
stuff,| it just kind of
|它只是在某种程度上假设，

1271
00:31:26,160 --> 00:31:27,180
0,390 390,510 510,780 780,930 930,1020
assumes that,| there's kind of
|一种基于 channel 的接口，

1272
00:31:27,180 --> 00:31:28,980
0,480 510,780 780,1020 1020,1650 1650,1800
channel, channel based interfaces| to
|对于所有服务器。

1273
00:31:28,980 --> 00:31:30,820
0,510 660,840 840,1410
all the servers.|
|

1274
00:31:31,430 --> 00:31:32,750
0,450 450,540 540,870 1020,1230 1230,1320
So you know we have
所以我们有这个函数 Schedule ，

1275
00:31:32,750 --> 00:31:34,340
0,120 120,450 450,1170 1200,1380 1380,1590
this function Schedule,| it takes
|它使用一个 servers 列表，

1276
00:31:34,340 --> 00:31:35,690
0,120 120,390 390,540 540,630 630,1350
a fixed list of servers,|
|

1277
00:31:36,260 --> 00:31:37,130
0,150 150,210 210,420 420,480 480,870
and a number of tasks
和一个运行的任务数，

1278
00:31:37,130 --> 00:31:38,450
0,510 750,900 900,960 960,1110 1110,1320
{to,run},| and it has just
|它有一个抽象的函数调用，

1279
00:31:38,450 --> 00:31:40,880
0,150 150,900 900,1380 1380,2070 2160,2430
this abstracted function call,| that
|你可以调用它在特定的服务器上运行任务，

1280
00:31:40,880 --> 00:31:42,410
0,450 450,990 990,1110 1110,1470 1470,1530
you call to run the

1281
00:31:42,410 --> 00:31:43,880
0,420 420,510 510,570 570,1020 1020,1470
task on a specific server,|
|

1282
00:31:43,940 --> 00:31:45,050
0,390 390,480 480,870 870,930 930,1110
you can imagine, it was
你可以想象，它是做 RPC 等事情。

1283
00:31:45,050 --> 00:31:46,580
0,390 390,450 450,600 600,930 930,1530
doing the {RPCs -} something.|
|

1284
00:31:48,120 --> 00:31:49,230
0,390 390,570 570,690 690,900 900,1110
So we're gonna need some
所以，我们需要一些方法

1285
00:31:49,230 --> 00:31:50,100
0,150 150,210 210,420 420,750 750,870
way| to keep track of
|来跟踪哪些服务器可用于执行任务。

1286
00:31:50,100 --> 00:31:51,690
0,210 210,660 660,810 810,1440 1470,1590
which servers are available to

1287
00:31:51,690 --> 00:31:53,440
0,510 510,1200
execute tasks.|
|

1288
00:31:53,440 --> 00:31:54,250
0,90 90,180 180,360 360,660 660,810
And so one option is
一种选择是使用我们自己的堆栈或队列实现，

1289
00:31:54,250 --> 00:31:55,180
0,120 120,270 270,420 420,570 570,930
to use our own stack

1290
00:31:55,180 --> 00:31:57,430
0,120 120,450 450,1350 1470,1890 1920,2250
or queue implementation,| but another
|但是另一种选择是使用 channel ，

1291
00:31:57,430 --> 00:31:58,330
0,390 390,480 480,570 570,720 720,900
option is to use a

1292
00:31:58,330 --> 00:31:59,740
0,360 360,630 630,750 750,840 840,1410
channel,| because it's a good
|因为它是一个很好的同步队列。

1293
00:31:59,950 --> 00:32:01,460
0,630 630,990
synchronized queue.|
|

1294
00:32:01,740 --> 00:32:02,460
0,120 120,210 210,300 300,450 450,720
And so we can send
因此我们可以发送到 channel 以添加到队列中，

1295
00:32:02,460 --> 00:32:04,200
0,210 210,330 330,870 1050,1470 1470,1740
into the channel to add

1296
00:32:04,200 --> 00:32:05,340
0,60 60,150 150,570 570,750 750,1140
to the queue| and receive
|然后从它那里得到一些东西。

1297
00:32:05,340 --> 00:32:06,270
0,180 180,330 330,420 420,630 630,930
from it to pop something

1298
00:32:06,270 --> 00:32:07,300
0,510
off.|
|

1299
00:32:07,330 --> 00:32:08,290
0,180 180,240 240,420 420,810 810,960
And in this case, we'll
在本例中，我们将队列设置为服务器队列，

1300
00:32:08,290 --> 00:32:09,640
0,210 210,540 570,1050 1050,1140 1140,1350
make the {queue,be} a queue

1301
00:32:09,640 --> 00:32:11,350
0,150 150,840 1200,1350 1350,1440 1440,1710
of servers,| and we'll start
|我们将从一个空闲的服务器队列开始，

1302
00:32:11,350 --> 00:32:12,550
0,420 480,810 810,870 870,1050 1050,1200
off its a queue of

1303
00:32:12,550 --> 00:32:13,780
0,270 270,660 660,930 930,1080 1080,1230
idle servers,| servers that aren't
|现在没有为我们做任何工作的服务器。

1304
00:32:13,780 --> 00:32:14,590
0,150 150,300 300,540 540,660 660,810
doing any work for us

1305
00:32:14,590 --> 00:32:15,540
0,180 180,450
right now.|
|

1306
00:32:15,880 --> 00:32:16,750
0,210 210,390 390,570 570,660 660,870
We'll start off by just
我们开始对它进行初始化，

1307
00:32:16,750 --> 00:32:18,460
0,600 600,870 930,1230 1230,1560 1560,1710
initializing it| by sending all
|通过将所有已知服务器发送到 idle 列表。

1308
00:32:18,460 --> 00:32:19,540
0,90 90,300 300,750 750,960 960,1080
the known servers into the

1309
00:32:19,540 --> 00:32:20,760
0,270 270,780
idle list.|
|

1310
00:32:21,880 --> 00:32:22,630
0,180 180,330 330,390 390,540 540,750
And then we can loop
然后我们可以循环执行任务，

1311
00:32:22,630 --> 00:32:23,830
0,180 180,270 270,900 900,1080 1080,1200
over the tasks,| and for
|对于每一项任务，我们都启动一个 goroutine ，

1312
00:32:23,830 --> 00:32:24,880
0,150 150,540 540,630 630,960 960,1050
every task we kickoff a

1313
00:32:24,880 --> 00:32:26,380
0,120 120,720 780,930 930,1080 1080,1500
{goroutine -},| and its job
|它的工作是将一个 server 从空闲列表中拿出，

1314
00:32:26,380 --> 00:32:27,250
0,120 120,210 210,480 480,540 540,870
is to pull a server

1315
00:32:27,250 --> 00:32:28,900
0,210 210,330 330,540 540,960 1290,1650
off the idle list,| run
|运行任务，然后重新把 server 放回。

1316
00:32:28,900 --> 00:32:30,130
0,90 90,750 780,960 960,1080 1080,1230
the task, and then put

1317
00:32:30,130 --> 00:32:31,540
0,60 60,360 360,630 630,840
the server back on.|
|

1318
00:32:32,060 --> 00:32:34,190
0,450 630,1140 1440,1650 1650,1830 1830,2130
{} And this loop body
这个循环是使用 goroutine 的早期提示的另一个示例，

1319
00:32:34,190 --> 00:32:35,420
0,120 120,480 480,1020 1020,1140 1140,1230
is another example of the

1320
00:32:35,420 --> 00:32:37,160
0,360 360,660 660,780 780,1080 1080,1740
earlier hint to use goroutines,|
|

1321
00:32:37,340 --> 00:32:39,500
0,480 480,750 750,900 900,1680 1800,2160
{like,independent} things run independently,| because
比如独立的事情独立运行，|因为每个任务都作为单独的关注点运行，

1322
00:32:39,500 --> 00:32:41,000
0,150 150,600 600,720 720,1230 1260,1500
each task is running as

1323
00:32:41,000 --> 00:32:42,320
0,90 90,450 450,960 990,1140 1140,1320
a separate concern,| they're all
|它们都是并行运行的。

1324
00:32:42,320 --> 00:32:43,980
0,210 210,270 270,900
running in parallel.|
|

1325
00:32:44,960 --> 00:32:46,520
0,720 720,870 870,1020 1020,1200 1200,1560
Unfortunately, there are two problems
不幸的是，这个程序有两个问题。

1326
00:32:46,520 --> 00:32:48,060
0,120 120,300 300,990
with this program.|
|

1327
00:32:48,060 --> 00:32:49,260
0,180 180,450 450,720 720,930 930,1200
The first one is that
第一个是作为新的 goroutine 运行的闭包

1328
00:32:49,410 --> 00:32:50,730
0,300 300,750 750,900 900,1200 1200,1320
the closure that's running as

1329
00:32:50,730 --> 00:32:51,930
0,30 30,210 210,690 690,1080 1080,1200
a new goroutine| refers to
|引用循环迭代变量，即 task ，

1330
00:32:51,930 --> 00:32:53,340
0,120 120,360 360,780 780,1140 1140,1410
the loop iteration variable, which

1331
00:32:53,340 --> 00:32:54,840
0,120 120,870 1110,1260 1260,1380 1380,1500
is task,| and so by
|所以当 goroutine 开始执行时，

1332
00:32:54,840 --> 00:32:55,590
0,90 90,300 300,390 390,510 510,750
the time the {goroutine -}

1333
00:32:55,590 --> 00:32:57,120
0,240 240,780 840,1170 1170,1380 1380,1530
starts executing,| the loop has
|循环可能继续，并完成 task++ ，

1334
00:32:57,120 --> 00:32:58,230
0,240 240,780 780,870 870,1050 1050,1110
probably continued and done a

1335
00:32:58,230 --> 00:32:59,370
0,330 330,480 480,930 930,1050 1050,1140
{task++ - -},| and so
|所以，它得到了错误的 task 值。

1336
00:32:59,370 --> 00:33:00,270
0,120 120,390 390,570 570,660 660,900
it's actually getting the wrong

1337
00:33:00,270 --> 00:33:01,740
0,330 330,420 420,1050
value of task.|
|

1338
00:33:02,490 --> 00:33:03,540
0,210 210,510 510,750 750,930 930,1050
You've probably seen this by
你可能已经看过了，

1339
00:33:03,540 --> 00:33:05,130
0,390 780,1140 1140,1290 1290,1380 1380,1590
now,| {} and of course
|当然，捕捉到这种情况的最好方法是

1340
00:33:05,130 --> 00:33:06,600
0,60 60,330 330,630 630,1140 1170,1470
the best way to catch

1341
00:33:06,600 --> 00:33:07,260
0,240 240,330 330,450 450,600 600,660
this is| to run the
|运行竞态检测器。

1342
00:33:07,260 --> 00:33:08,660
0,240 240,840
race detector.|
|

1343
00:33:08,780 --> 00:33:09,590
0,150 150,240 240,510 510,630 630,810
And at Google, we even
在 Google ，我们甚至鼓励团队

1344
00:33:09,590 --> 00:33:10,700
0,390 390,660 660,780 780,960 960,1110
encourage teams| to set up
|设置金丝雀服务器来运行竞态检测器，

1345
00:33:10,700 --> 00:33:12,320
0,390 390,870 870,1140 1170,1530 1530,1620
canary servers that run the

1346
00:33:12,320 --> 00:33:13,910
0,240 240,810 900,1140 1140,1380 1380,1590
race detector,| and split off
|并将大约 0.1% 的流量分给它，

1347
00:33:13,910 --> 00:33:15,470
0,300 300,780 780,1020 1020,1200 1200,1560
something like {0.1% - -}

1348
00:33:15,470 --> 00:33:16,430
0,60 60,210 210,630 630,780 780,960
of their traffic to it,|
|

1349
00:33:16,550 --> 00:33:18,770
0,450 450,540 540,930 930,1410 1470,2220
just to catch {you,know} races
为了抓住可能存在于生产系统中的竞争。

1350
00:33:18,770 --> 00:33:19,490
0,330 330,480 480,570 570,630 630,720
that might be in the

1351
00:33:19,490 --> 00:33:20,860
0,420 420,840
production system.|
|

1352
00:33:20,860 --> 00:33:21,640
0,270 270,360 360,450 450,720 720,780
And you know finding a
用竞态检测器找到一个 bug

1353
00:33:21,640 --> 00:33:22,660
0,150 150,240 240,330 330,540 540,1020
bug with the race detector|
|

1354
00:33:22,840 --> 00:33:24,310
0,480 480,780 780,1050 1050,1200 1200,1470
is way better than having
比之后不得不调试一些错误要好。

1355
00:33:24,310 --> 00:33:26,140
0,90 90,450 450,840 930,1470 1470,1830
to debug some corruption later.|
|

1356
00:33:27,900 --> 00:33:28,710
0,210 210,330 330,390 390,570 570,810
So there are two ways
所以，有两种方法可以修复这个竞争，

1357
00:33:28,710 --> 00:33:30,300
0,120 120,360 360,570 570,1170 1290,1590
to fix this race,| the
|第一种方法是给闭包一个显式参数并将其传入，

1358
00:33:30,300 --> 00:33:31,350
0,300 300,600 600,750 750,840 840,1050
first way is to give

1359
00:33:31,350 --> 00:33:32,730
0,90 90,540 540,600 600,1050 1050,1380
the closure an explicit parameter

1360
00:33:32,730 --> 00:33:34,530
0,90 90,390 390,450 450,720 1230,1800
and pass it in,| and
|Go 语句需要专门为此进行的函数调用，

1361
00:33:34,530 --> 00:33:37,080
0,600 930,1440 1470,1950 1950,2460 2460,2550
Go {} statement requires a

1362
00:33:37,080 --> 00:33:38,760
0,300 300,540 540,1200 1200,1470 1470,1680
function call specifically for this

1363
00:33:38,760 --> 00:33:40,200
0,450 570,840 840,960 960,1080 1080,1440
reason,| so that you can
|所以你可以设置特定参数，

1364
00:33:40,560 --> 00:33:41,970
0,360 360,750 750,1140 1140,1260 1260,1410
set specific arguments,| that get
|在原始 goroutine 的上下文中计算的，

1365
00:33:41,970 --> 00:33:43,740
0,900 930,1140 1140,1200 1200,1680 1680,1770
evaluated in the context of

1366
00:33:43,740 --> 00:33:45,330
0,90 90,510 510,630 630,1170 1380,1590
the original {goroutine -}| and
|然后复制到新的 goroutine ，

1367
00:33:45,330 --> 00:33:46,170
0,120 120,270 270,660 660,750 750,840
then {you,know} copy to the

1368
00:33:46,170 --> 00:33:47,300
0,180 180,750
new goroutine,|
|

1369
00:33:47,670 --> 00:33:48,450
0,150 150,270 270,330 330,480 480,780
and so in this case,
所以在本例中，我们可以声明一个新参数 task2 ，

1370
00:33:48,450 --> 00:33:49,230
0,120 120,240 240,570 570,630 630,780
we can declare a new

1371
00:33:49,230 --> 00:33:51,180
0,360 360,720 720,1200 1260,1650 1650,1950
argument {task2 -},| {we,can} past
|我们可以将 task 传递给它，

1372
00:33:51,180 --> 00:33:52,640
0,360 360,510 510,840
task to it,|
|

1373
00:33:52,670 --> 00:33:53,480
0,180 180,270 270,600 600,660 660,810
and then inside the {goroutine
然后在 goroutine 中，

1374
00:33:53,480 --> 00:33:55,010
0,360 360,720 720,1050 1050,1260 1260,1530
-},| {task2 -} is a
|task2 是一个完全不同的 task 的复制，

1375
00:33:55,010 --> 00:33:57,290
0,450 450,690 690,1050 1050,1440 1560,2280
completely different copy of task,|
|

1376
00:33:57,880 --> 00:33:58,960
0,480 480,600 600,780 780,990 990,1080
and I only named it
我把它命名为 task2 只是为了让它更容易讨论。

1377
00:33:58,960 --> 00:33:59,950
0,330 330,480 480,630 660,900 900,990
{task2 -} to make it

1378
00:33:59,950 --> 00:34:01,580
0,180 180,240 240,480 480,1020
easier to talk about.|
|

1379
00:34:01,610 --> 00:34:02,390
0,180 180,270 270,540 540,690 690,780
But of course there's a
当然，这里有一个 bug ，

1380
00:34:02,390 --> 00:34:03,470
0,270 270,600 600,720 720,780 780,1080
bug here,| and the bug
|这个 bug 是，

1381
00:34:03,470 --> 00:34:05,180
0,630 690,1080 1110,1230 1230,1650 1650,1710
is that,| I forgot to
|我忘了更新函数内的 task ，

1382
00:34:05,180 --> 00:34:07,040
0,480 480,900 900,1380 1380,1470 1470,1860
update task inside the function|
|

1383
00:34:07,040 --> 00:34:08,090
0,90 90,360 360,450 450,810 810,1050
to refer to {task2 -}
引用 task2 而不是 task ，

1384
00:34:08,090 --> 00:34:09,890
0,270 270,360 360,960 1200,1380 1380,1800
instead of task,| and so
|我们基本上从来不这样做，

1385
00:34:09,920 --> 00:34:12,110
0,540 540,900 900,1290 1290,1500 1500,2190
we basically never do that,|
|

1386
00:34:12,110 --> 00:34:14,150
0,210 210,330 330,450 450,1200 1260,2040
what we do instead is,|
取而代之的是，|

1387
00:34:14,730 --> 00:34:15,360
0,210 210,360 360,480 480,570 570,630
we just give it the
我们给它相同的名字，

1388
00:34:15,360 --> 00:34:16,530
0,270 270,630 690,900 900,1020 1020,1170
same name,| so that it's
|所以，现在是不可能的，

1389
00:34:16,530 --> 00:34:18,210
0,600 600,1050 1080,1350 1350,1440 1440,1680
impossible now,| for the code
|对于 goroutine 中的代码引用错误的 task 复制。

1390
00:34:18,210 --> 00:34:19,470
0,300 300,390 390,810 810,930 930,1260
inside the goroutine to refer

1391
00:34:19,470 --> 00:34:20,400
0,120 120,240 240,480 480,840 840,930
to the wrong copy of

1392
00:34:20,400 --> 00:34:21,580
0,660
task.|
|

1393
00:34:22,500 --> 00:34:23,760
0,480 570,780 780,900 900,1020 1020,1260
{} That was the first
这是修复竞争的第一种方法,

1394
00:34:23,760 --> 00:34:24,600
0,90 90,180 180,390 390,510 510,840
way to fix the race,|
|

1395
00:34:24,600 --> 00:34:25,590
0,210 210,270 270,600 600,750 750,990
there's a second way which
还有另一种方式是，

1396
00:34:25,590 --> 00:34:26,310
0,240 240,330 330,420 420,630 630,720
is,| you know sort of
|第一次看到它时，你会觉得有点神秘，

1397
00:34:26,310 --> 00:34:27,270
0,390 390,480 480,720 720,870 870,960
cryptic the first time you

1398
00:34:27,270 --> 00:34:28,380
0,210 210,360 360,510 510,690 690,1110
see it,| but it amounts
|但这等同于一件事，

1399
00:34:28,380 --> 00:34:29,790
0,90 90,180 180,510 510,960 1260,1410
to the same thing,| and
|也就是，

1400
00:34:29,790 --> 00:34:30,720
0,150 150,270 270,540 570,780 780,930
that is that,| you just
|你只需在循环体内复制变量即可。

1401
00:34:30,720 --> 00:34:31,950
0,150 150,210 210,690 690,840 840,1230
make a copy of the

1402
00:34:31,980 --> 00:34:33,810
0,600 600,1080 1080,1170 1170,1380 1380,1830
variable inside the loop body.|
|

1403
00:34:34,570 --> 00:34:37,390
0,480 810,1110 1110,1770 1830,2460 2460,2820
So every time {:= -}
所以每次 := 的时候，

1404
00:34:37,390 --> 00:34:38,620
0,450 450,660 660,930 930,960 960,1230
happens,| that creates a new
|就产生一个新的变量，

1405
00:34:38,620 --> 00:34:40,090
0,540 750,1020 1020,1110 1110,1200 1200,1470
variable,| so in the for
|所以在外部 for 循环中，

1406
00:34:40,090 --> 00:34:40,990
0,240 240,300 300,450 450,690 690,900
loop, in the outer for

1407
00:34:40,990 --> 00:34:42,010
0,210 210,360 360,420 420,750 750,1020
loop,| there's a {:= -}
|开头有一个 := ，

1408
00:34:42,010 --> 00:34:43,240
0,60 60,150 150,660 660,1080 1080,1230
at the beginning,| and there's
|而循环的其余部分中没有，

1409
00:34:43,240 --> 00:34:44,260
0,270 270,600 600,690 690,960 960,1020
not one the rest of

1410
00:34:44,260 --> 00:34:45,010
0,60 60,300 300,390 390,570 570,750
the loop,| so that's all
|所以这是整个循环的一个变量，

1411
00:34:45,010 --> 00:34:46,180
0,180 180,450 450,900 900,1050 1050,1170
just one variable for the

1412
00:34:46,180 --> 00:34:47,920
0,360 360,900 1110,1530 1530,1650 1650,1740
entire loop,| whereas if we
|如果我们在函数里放一个 := ，

1413
00:34:47,920 --> 00:34:49,000
0,150 150,210 210,510 510,780 780,1080
put a {:= -} inside

1414
00:34:49,000 --> 00:34:50,230
0,90 90,540 540,870 870,1140 1140,1230
the body,| every time we
|每次我们运行循环的迭代时，

1415
00:34:50,230 --> 00:34:51,130
0,180 180,270 270,750 750,810 810,900
run an iteration of the

1416
00:34:51,130 --> 00:34:52,690
0,240 240,420 420,510 510,1020 1020,1560
loop,| that's a different variable,|
|都是一个不同的变量，|

1417
00:34:52,960 --> 00:34:54,760
0,360 360,870 900,1050 1050,1260 1260,1800
so if if the Go
所以，如果 Go 函数闭包捕获了那个变量，

1418
00:34:54,790 --> 00:34:57,040
0,390 390,900 900,1410 1410,1620 1620,2250
function closure captures that variable,|
|

1419
00:34:57,070 --> 00:34:58,420
0,390 390,510 510,630 630,750 750,1350
those will all be distinct.|
那些都是截然不同的。|

1420
00:34:59,130 --> 00:34:59,790
0,270 270,360 360,480 480,570 570,660
So we can do the
所以我们可以做和 task2 一样的事情，

1421
00:34:59,790 --> 00:35:00,900
0,270 270,450 450,570 570,750 750,1110
same thing we do {task2

1422
00:35:00,900 --> 00:35:01,590
0,180 180,300 300,420 420,630 630,690
-},| and this time I
|这一次我记得更新函数体，

1423
00:35:01,590 --> 00:35:03,030
0,360 360,450 450,840 840,930 930,1440
remember to update the body,|
|

1424
00:35:03,210 --> 00:35:05,130
0,840 1110,1290 1290,1500 1500,1590 1590,1920
but {you,know} just like before,|
但是像以前一样，|

1425
00:35:05,130 --> 00:35:06,090
0,120 120,270 270,510 510,600 600,960
it's too easy to forget
很容易忘记更新函数体，

1426
00:35:06,090 --> 00:35:07,380
0,60 60,390 390,450 450,900 990,1290
to update the body,| and
|所以通常写 task := task ，

1427
00:35:07,380 --> 00:35:08,550
0,150 150,510 510,630 630,840 840,1170
so typically {} write task

1428
00:35:08,550 --> 00:35:09,930
0,240 240,510 510,870 870,1170 1170,1380
{:= -} task,| which looks
|第一次看到它时有点神奇，

1429
00:35:09,930 --> 00:35:10,920
0,150 150,210 210,660 660,750 750,990
kind of magical the first

1430
00:35:10,920 --> 00:35:11,910
0,150 150,270 270,420 420,570 570,990
time you see it,| but
|但这就是它的作用。

1431
00:35:11,910 --> 00:35:13,100
0,210 210,300 300,420 420,780
that's what it's for.|
|

1432
00:35:14,300 --> 00:35:15,650
0,420 870,1050 1050,1110 1110,1260 1260,1350
Alright, so I said there
好的，我说程序中有两个 bug ，

1433
00:35:15,650 --> 00:35:16,310
0,90 90,240 240,510 510,570 570,660
were two bugs in the

1434
00:35:16,310 --> 00:35:17,990
0,510 840,1020 1020,1290 1290,1470 1470,1680
program,| the first one was
|第一个是任务的竞争，

1435
00:35:17,990 --> 00:35:19,640
0,150 150,390 390,540 540,1200
this race on task,|
|

1436
00:35:19,840 --> 00:35:21,430
0,240 240,480 480,750 750,1170 1260,1590
and the second one is
第二个问题是，

1437
00:35:21,430 --> 00:35:23,680
0,390 540,1020 1050,1230 1230,1440 1440,2250
that,| {} we didn't actually
|在启动所有任务后，我们没有做任何事情，

1438
00:35:23,710 --> 00:35:25,210
0,330 330,720 720,1080 1080,1260 1260,1500
do anything after we've kicked

1439
00:35:25,210 --> 00:35:26,080
0,150 150,210 210,300 300,780 780,870
off all the tasks,| we're
|我们不是在等它们完成。

1440
00:35:26,080 --> 00:35:26,770
0,150 150,390 390,480 480,600 600,690
not waiting for them to

1441
00:35:26,770 --> 00:35:27,920
0,120 120,390
be done.|
|

1442
00:35:28,560 --> 00:35:30,570
0,420 570,900 900,1050 1050,1110 1110,2010
{} And and in particular,
尤其是，我们启动得太快了，

1443
00:35:30,600 --> 00:35:31,980
0,480 510,750 750,1020 1020,1140 1140,1380
{} we're kicking them off

1444
00:35:31,980 --> 00:35:34,260
0,210 210,390 390,1020 1080,1950 2160,2280
way too fast,| because you
|因为如果有一百万个任务就会启动一百万个 goroutine ，

1445
00:35:34,260 --> 00:35:35,370
0,360 360,540 540,720 720,870 870,1110
know if there's a million

1446
00:35:35,370 --> 00:35:36,090
0,330 330,360 360,480 480,540 540,720
tasks are going to kick

1447
00:35:36,090 --> 00:35:37,170
0,120 120,180 180,420 420,960 960,1080
off a million goroutines,| and
|它们都会坐在那里等待五个服务器中的一个，

1448
00:35:37,170 --> 00:35:37,770
0,150 150,270 270,420 420,540 540,600
they're all just going to

1449
00:35:37,770 --> 00:35:38,730
0,270 270,600 600,690 690,900 900,960
sit waiting for one of

1450
00:35:38,730 --> 00:35:40,050
0,120 120,390 390,1020 1050,1230 1230,1320
the five servers,| which is
|这是一种有益的做法。

1451
00:35:40,050 --> 00:35:41,320
0,180 180,240 240,690
kind of beneficial.|
|

1452
00:35:41,520 --> 00:35:42,120
0,120 120,210 210,360 360,450 450,600
And so what we can
所以，我们所能做的是

1453
00:35:42,120 --> 00:35:43,920
0,510 630,870 870,990 990,1200 1200,1800
do is| we can pull
|将下一个空闲服务器的从 goroutine 中拿出。

1454
00:35:43,920 --> 00:35:45,960
0,510 540,1050 1050,1260 1260,1560 1590,2040
the fetching of the next

1455
00:35:45,960 --> 00:35:47,250
0,180 180,540 540,930 930,1140 1140,1290
idle server up out of

1456
00:35:47,250 --> 00:35:48,540
0,90 90,270 270,360 360,780
the {goroutine - -}.|
|

1457
00:35:48,820 --> 00:35:49,900
0,510
And,
我们把它从 goroutine 上拉出来，

1458
00:35:49,900 --> 00:35:50,530
0,150 150,330 330,390 390,540 540,630
we pull it up out

1459
00:35:50,530 --> 00:35:52,210
0,60 60,150 150,360 360,870 900,1680
of the {goroutine -},| now
|现在，我们仅在有空闲服务器可用时启动 goroutine 。

1460
00:35:52,240 --> 00:35:53,140
0,210 210,450 450,660 660,810 810,900
we'll only kick off a

1461
00:35:53,140 --> 00:35:54,100
0,180 180,390 390,540 540,690 690,960
{goroutine -} when there is

1462
00:35:54,100 --> 00:35:55,540
0,120 120,330 330,630 630,750 750,1440
an idle server to use.|
|

1463
00:35:56,290 --> 00:35:57,070
0,180 180,330 330,450 450,600 600,780
And then we can kick
然后我们就可以开始，

1464
00:35:57,070 --> 00:35:58,390
0,90 90,480 480,840 840,1200 1200,1320
it off| and and you
|使用那个服务器，然后把它放回去，

1465
00:35:58,390 --> 00:35:59,500
0,150 150,540 540,720 720,990 990,1110
know use that server and

1466
00:35:59,500 --> 00:36:00,910
0,120 120,210 210,660 750,1080 1080,1410
put it back| and using
|使用服务器并将其放回并发运行，

1467
00:36:00,910 --> 00:36:01,510
0,60 60,330 330,420 420,510 510,600
the server and put it

1468
00:36:01,510 --> 00:36:03,880
0,300 300,510 510,1260 1380,1860 1950,2370
back runs concurrently,| but doing
|但是在循环内获取空闲服务器会减慢速度，

1469
00:36:03,880 --> 00:36:04,900
0,360 360,630 630,720 720,840 840,1020
the fetch of the idle

1470
00:36:04,900 --> 00:36:06,130
0,300 300,600 600,690 690,900 900,1230
server inside the loop slows

1471
00:36:06,130 --> 00:36:07,420
0,210 210,540 540,660 660,900 1050,1290
things down,| so that there's
|现在只有正在运行的服务器数量，

1472
00:36:07,420 --> 00:36:09,010
0,270 270,540 540,1080 1110,1470 1470,1590
only ever now number of

1473
00:36:09,010 --> 00:36:10,510
0,420 420,540 540,930 930,1230 1230,1500
servers {goroutines -} running| instead
|而不是任务数量。

1474
00:36:10,510 --> 00:36:12,000
0,90 90,330 330,420 420,1200
of number of tasks.|
|

1475
00:36:12,470 --> 00:36:13,940
0,240 240,540 540,870 870,1020 1020,1470
And that receive is essentially
而接收器产生一些背压来减慢循环，

1476
00:36:13,940 --> 00:36:15,020
0,270 270,420 420,690 690,990 990,1080
creating some back pressure to

1477
00:36:15,020 --> 00:36:16,460
0,300 300,540 540,660 660,1110 1140,1440
slow down the loop,| so
|因此，它不会走得太远。

1478
00:36:16,460 --> 00:36:17,210
0,60 60,270 270,420 420,540 540,750
it doesn't get too far

1479
00:36:17,210 --> 00:36:18,120
0,390
ahead.|
|

1480
00:36:18,940 --> 00:36:19,660
0,150 150,240 240,300 300,630 630,720
And then I mentioned we
然后我提到，我们必须等待任务完成，

1481
00:36:19,660 --> 00:36:20,290
0,120 120,210 210,450 450,540 540,630
have to wait for the

1482
00:36:20,290 --> 00:36:21,880
0,360 360,450 450,1110
task to finish,|
|

1483
00:36:22,030 --> 00:36:22,630
0,120 120,240 240,330 330,450 450,600
and so we can do
所以我们可以在循环的末尾做到这一点，

1484
00:36:22,630 --> 00:36:23,470
0,210 210,330 330,570 570,690 690,840
that by just at the

1485
00:36:23,470 --> 00:36:25,120
0,150 150,240 240,330 330,870 900,1650
end of the loop,| going
|再次查看列表并取出所有服务器，

1486
00:36:25,120 --> 00:36:26,320
0,480 480,630 630,840 840,1080 1080,1200
over the list again and

1487
00:36:26,320 --> 00:36:27,430
0,270 270,420 420,480 480,870 870,1110
pulling all the servers out|
|

1488
00:36:27,430 --> 00:36:28,570
0,90 90,270 270,660 690,930 930,1140
and we've pulled the right
我们已经从空闲列表中删除了合适数量的服务器，

1489
00:36:28,570 --> 00:36:29,530
0,210 210,300 300,660 660,870 870,960
number of servers out of

1490
00:36:29,530 --> 00:36:30,790
0,150 150,390 390,840 870,1050 1050,1260
the idle list,| that means
|这意味着它们都完成了。

1491
00:36:30,790 --> 00:36:31,960
0,150 150,270 270,600
they're all done.|
|

1492
00:36:32,020 --> 00:36:33,220
0,180 180,300 300,600 600,900 900,1200
And so that's that's the
所以这就是完整的程序。

1493
00:36:33,310 --> 00:36:34,820
0,360 360,870
full program.|
|

1494
00:36:35,460 --> 00:36:36,780
0,330 330,600 600,840 840,960 960,1320
{You,know} to me the most
对我来说，最重要的部分是，

1495
00:36:36,780 --> 00:36:38,190
0,420 420,600 600,660 660,1080 1260,1410
important part of this is

1496
00:36:38,190 --> 00:36:38,940
0,150 150,360 360,510 510,660 660,750
that,| you still get to
|你仍然可以编写一个 for 循环来迭代任务，

1497
00:36:38,940 --> 00:36:40,200
0,120 120,180 180,510 510,960 1110,1260
write a for loop to

1498
00:36:40,200 --> 00:36:42,060
0,330 330,480 480,570 570,1410 1440,1860
iterate over the tasks,| there's
|在很多其他语言中，

1499
00:36:42,060 --> 00:36:43,050
0,210 210,270 270,420 420,840 840,990
lots of other languages| where
|你必须使用状态机或某种回调来完成，

1500
00:36:43,050 --> 00:36:43,650
0,120 120,210 210,300 300,420 420,600
you have to do this

1501
00:36:43,650 --> 00:36:44,580
0,120 120,330 330,690 690,780 780,930
with state machines or some

1502
00:36:44,580 --> 00:36:46,060
0,150 150,240 240,1020
sort of callbacks,|
|

1503
00:36:46,210 --> 00:36:47,260
0,420 450,690 690,810 810,930 930,1050
and you don't get the
你不能奢侈地在控制流中对此进行编码，

1504
00:36:47,260 --> 00:36:48,550
0,450 450,540 540,1020 1020,1200 1200,1290
[luxury] of encoding this in

1505
00:36:48,550 --> 00:36:50,710
0,90 90,510 510,930 1260,1590 1950,2160
the control flow,| and so
|所以这是一种更干净的方式，

1506
00:36:50,710 --> 00:36:52,600
0,210 210,330 330,930 960,1260 1260,1890
this is a much cleaner

1507
00:36:52,600 --> 00:36:53,440
0,240 240,420 420,510 510,600 600,840
way,| where you can just
|你可以只使用常规的循环。

1508
00:36:53,440 --> 00:36:55,080
0,390 390,480 480,810 810,1140
use a regular loop.|
|

1509
00:36:55,380 --> 00:36:56,520
0,240 240,330 330,510 510,780 780,1140
But there are some some
但是我们可以做一些改变，一些改进，

1510
00:36:56,520 --> 00:36:57,540
0,390 390,480 480,600 600,870 870,1020
changes we could make, some

1511
00:36:57,540 --> 00:37:00,060
0,720 990,1320 1320,1620 1920,2130 2130,2520
improvements,| and so one improvement
|一个改进是注意到，

1512
00:37:00,060 --> 00:37:01,600
0,90 90,180 180,600 600,930
is to notice that,|
|

1513
00:37:01,630 --> 00:37:03,130
0,420 420,630 630,960 960,1110 1110,1500
there's only one {goroutine -}
在特定时间，只有一个 goroutine 向服务器发出请求，

1514
00:37:03,130 --> 00:37:04,180
0,150 150,480 480,900 900,960 960,1050
that makes requests of a

1515
00:37:04,180 --> 00:37:05,500
0,390 390,450 450,510 510,840 840,1320
server at a particular time,|
|

1516
00:37:05,890 --> 00:37:06,880
0,180 180,450 450,510 510,750 750,990
so instead of having one
所以，不是为任务分配一个 goroutine ，

1517
00:37:06,880 --> 00:37:08,620
0,150 150,450 450,540 540,1290 1410,1740
{goroutine -} for task,| maybe
|也许我们应该为每个服务器分配一个 goroutine ，

1518
00:37:08,620 --> 00:37:09,370
0,120 120,240 240,360 360,600 600,750
we should have one {goroutine

1519
00:37:09,370 --> 00:37:11,710
0,270 270,390 390,930 1350,1980 1980,2340
-} per server,| because there
|因为服务器数量可能会少于任务数量。

1520
00:37:11,740 --> 00:37:12,490
0,180 180,480 480,600 600,660 660,750
are probably going to be

1521
00:37:12,490 --> 00:37:14,340
0,270 270,690 690,810 810,1470
fewer servers than tasks.|
|

1522
00:37:14,540 --> 00:37:15,410
0,180 180,270 270,420 420,780 780,870
And to do that,| we
要做到这一点，|我们必须从一个由空闲服务器组成的 channel

1523
00:37:15,410 --> 00:37:16,610
0,150 150,240 240,600 600,720 720,1200
have to change from having

1524
00:37:16,610 --> 00:37:18,020
0,180 180,540 540,660 660,930 930,1410
a channel of idle servers|
|

1525
00:37:18,020 --> 00:37:19,580
0,90 90,180 180,600 600,930 1080,1560
to a channel of yet
转变为一个由尚未完成的任务组成的 channel ，

1526
00:37:19,580 --> 00:37:21,230
0,60 60,180 180,420 420,1230 1500,1650
to be done tasks,| and
|所以，我们将空闲 channel 重命名为 work 。

1527
00:37:21,230 --> 00:37:22,310
0,120 120,270 270,630 630,750 750,1080
so we've renamed the idle

1528
00:37:22,310 --> 00:37:23,840
0,330 330,480 480,990
channel to work.|
|

1529
00:37:24,020 --> 00:37:24,860
0,150 150,240 240,360 360,660 660,840
And then we also need
然后我们还需要一个 done channel

1530
00:37:24,860 --> 00:37:26,870
0,180 180,450 450,1020 1050,1410 1410,2010
a done channel| to count
|来计算完成了多少任务，

1531
00:37:26,930 --> 00:37:28,400
0,480 510,660 660,750 750,930 930,1470
{} you know how many

1532
00:37:28,460 --> 00:37:29,900
0,750 750,810 810,1110 1110,1320 1320,1440
tasks are done,| so we
|这样我们知道什么时候完全完成了。

1533
00:37:29,900 --> 00:37:31,610
0,120 120,300 300,660 660,1080 1080,1710
know when we're completely finished.|
|

1534
00:37:32,300 --> 00:37:33,530
0,150 150,300 300,810 870,1200 1200,1230
And so here there's a
所以这里有一个新的函数 runTasks ，

1535
00:37:33,530 --> 00:37:35,180
0,180 180,600 600,840 840,1500 1500,1650
new function {runTasks -},| and
|这将是每台服务器的函数，

1536
00:37:35,180 --> 00:37:35,810
0,210 210,330 330,390 390,480 480,630
that's going to be the

1537
00:37:35,810 --> 00:37:37,850
0,390 390,810 810,1410 1800,1950 1950,2040
per server function,| and we
|我们为每个服务器启动一个。

1538
00:37:37,850 --> 00:37:38,870
0,210 210,390 390,630 630,750 750,1020
kick off one of them

1539
00:37:38,870 --> 00:37:40,260
0,120 120,300 300,930
for each server.|
|

1540
00:37:40,410 --> 00:37:41,640
0,180 180,480 480,780 780,930 930,1230
And {runTasks -}, its job
runTasks 它的工作是在 work channel 上循环，

1541
00:37:41,640 --> 00:37:42,450
0,90 90,270 270,360 360,630 630,810
is just to loop over

1542
00:37:42,450 --> 00:37:44,130
0,90 90,330 330,840 1260,1590 1590,1680
the work channel,| run the
|运行任务，

1543
00:37:44,130 --> 00:37:45,540
0,690 690,810 810,960 960,1020 1020,1410
tasks,| and when the server
|当服务器完成时，

1544
00:37:45,540 --> 00:37:46,740
0,150 150,690
is done,|
|

1545
00:37:46,800 --> 00:37:48,090
0,210 210,510 510,720 720,780 780,1290
we send true to done,|
我们发送 true 给 done ，|

1546
00:37:48,360 --> 00:37:49,890
0,630 660,840 840,1020 1020,1110 1110,1530
and you know the server
服务器告诉我们它已经完成了，

1547
00:37:49,890 --> 00:37:51,060
0,270 270,390 390,750 900,1050 1050,1170
tells us that you know

1548
00:37:51,060 --> 00:37:52,920
0,180 180,450 960,1410 1410,1500 1500,1860
it's done,| and the server
|当 work channel 关闭时，服务器退出，

1549
00:37:52,920 --> 00:37:54,210
0,420 420,720 720,780 780,1020 1020,1290
exits when the work channel

1550
00:37:54,210 --> 00:37:55,380
0,210 210,660 660,840 840,960 960,1170
gets closed,| that's what makes
|这让 for 循环停止。

1551
00:37:55,380 --> 00:37:57,060
0,210 210,420 420,690 720,1140 1140,1680
that for loop actually stop.|
|

1552
00:37:58,220 --> 00:38:00,110
0,240 240,690 1110,1350 1350,1650 1650,1890
So then you having kicked
然后你启动了服务器，

1553
00:38:00,110 --> 00:38:01,310
0,210 210,270 270,900 900,1050 1050,1200
off the servers,| we can
|我们可以在一个循环中，

1554
00:38:01,310 --> 00:38:02,090
0,150 150,360 360,540 540,720 720,780
then just sit there in

1555
00:38:02,090 --> 00:38:03,710
0,60 60,450 480,930 1050,1470 1470,1620
a loop,| and send each
|将每个任务发送到 work channel ，

1556
00:38:03,710 --> 00:38:05,360
0,600 600,780 780,870 870,1080 1080,1650
task to the work channel,|
|

1557
00:38:05,890 --> 00:38:06,910
0,420 420,510 510,690 690,930 930,1020
close the work channel and
关闭 work channel ，表示没有更多的工作要做了，

1558
00:38:06,910 --> 00:38:07,630
0,150 150,300 300,450 450,540 540,720
say hey there's no more

1559
00:38:07,630 --> 00:38:08,560
0,180 180,420 420,510 510,570 570,930
work coming,| all the servers
|所有服务器应该完成，然后退出，

1560
00:38:08,560 --> 00:38:09,520
0,90 90,240 240,570 570,690 690,960
{} should finish and then

1561
00:38:09,520 --> 00:38:10,810
0,150 150,270 270,660 930,1170 1170,1290
and then exit,| and then
|然后等待所有的服务器告诉我们它们完成了。

1562
00:38:10,810 --> 00:38:11,650
0,210 210,330 330,420 420,480 480,840
wait for all the servers

1563
00:38:11,650 --> 00:38:12,310
0,90 90,300 300,420 420,540 540,660
to tell us that they're

1564
00:38:12,310 --> 00:38:13,200
0,270
done.|
|

1565
00:38:15,320 --> 00:38:16,760
0,390 390,780 780,900 900,1290 1290,1440
So in the lab, there
所以在实验里，有一些复杂的东西，

1566
00:38:16,760 --> 00:38:18,170
0,210 210,300 300,540 540,1200 1200,1410
were a couple complications,| one
|一个是，你可能会在任何时间获得新服务器，

1567
00:38:18,170 --> 00:38:19,370
0,120 120,390 510,900 900,1050 1050,1200
was that, you might get

1568
00:38:19,370 --> 00:38:20,480
0,150 150,630 630,720 720,870 870,1110
new servers at any given

1569
00:38:20,480 --> 00:38:22,250
0,510 900,1440 1440,1560 1560,1650 1650,1770
time,| and so we could
|我们可以修改它，

1570
00:38:22,250 --> 00:38:23,390
0,300 300,630 630,780 780,1080 1080,1140
change that,| by saying the
|通过说服务器来自 channel string ，

1571
00:38:23,390 --> 00:38:24,410
0,390 390,600 600,780 780,930 930,1020
servers come in on a

1572
00:38:24,410 --> 00:38:25,980
0,330 330,420 420,1170
channel of strings,|
|

1573
00:38:26,940 --> 00:38:28,530
0,420 420,780 780,1050 1050,1350 1350,1590
{} and that actually fits
这非常适合目前的结构，

1574
00:38:28,530 --> 00:38:29,640
0,180 180,510 510,690 690,780 780,1110
pretty well into the current

1575
00:38:29,640 --> 00:38:31,290
0,420 420,960 1050,1410 1410,1530 1530,1650
structure,| where when you get
|当你获得新的服务器时，

1576
00:38:31,290 --> 00:38:32,670
0,60 60,210 210,780 810,1020 1020,1380
a new server,| you just
|你只需要启动一个新的 runTasks goroutine ，

1577
00:38:33,120 --> 00:38:34,470
0,240 240,450 450,510 510,780 780,1350
kick off a new {}

1578
00:38:34,500 --> 00:38:36,180
0,270 270,690 690,840 840,1290 1380,1680
{runTasks -} {goroutine -},| and
|所以我们现在唯一需要修改的是

1579
00:38:36,180 --> 00:38:36,720
0,90 90,210 210,360 360,450 450,540
so the only thing we

1580
00:38:36,720 --> 00:38:37,530
0,90 90,180 180,510 510,690 690,810
have to change here is|
|

1581
00:38:37,530 --> 00:38:39,000
0,90 90,330 330,600 600,1020 1050,1470
to put that loop into
把这个循环放入自己的 goroutine 中，

1582
00:38:39,000 --> 00:38:40,080
0,150 150,330 330,480 480,930 930,1080
its own {goroutine -},| so
|当我们向服务器发送任务时，

1583
00:38:40,080 --> 00:38:41,460
0,210 210,510 510,750 750,1050 1050,1380
that while we're sending tasks

1584
00:38:41,460 --> 00:38:42,420
0,90 90,510 510,600 600,720 720,960
to servers,| we can still
|我们仍然可以接受新的服务器，

1585
00:38:42,420 --> 00:38:44,160
0,390 390,540 540,1170 1170,1380 1380,1740
accept new servers| and kickoff
|并启动 runTasks goroutine 。

1586
00:38:44,160 --> 00:38:45,620
0,90 90,510 510,1110
the runTasks goroutines.|
|

1587
00:38:47,340 --> 00:38:47,940
0,150 150,300 300,390 390,480 480,600
But now we have this
但是现在我们遇到了这个问题，

1588
00:38:47,940 --> 00:38:48,930
0,300 300,450 450,570 570,780 780,990
problem,| that we don't really
|我们没有一个好的方法

1589
00:38:48,930 --> 00:38:49,590
0,150 150,240 240,390 390,510 510,660
have a good way| to
|来判断所有的服务器什么时候都完成了，

1590
00:38:49,590 --> 00:38:51,000
0,300 300,630 630,870 870,960 960,1410
tell when all the servers

1591
00:38:51,000 --> 00:38:51,960
0,90 90,450 450,720 720,810 810,960
are done,| because we don't
|因为我们不知道有多少台服务器，

1592
00:38:51,960 --> 00:38:52,920
0,60 60,210 210,390 390,810 810,960
know how many servers there

1593
00:38:52,920 --> 00:38:54,980
0,480 750,1080 1080,1590
are,| and so
|我们可以尝试保持服务器到来的数字，

1594
00:38:55,130 --> 00:38:56,570
0,180 180,300 300,510 510,840 870,1440
we could try to maintain

1595
00:38:56,570 --> 00:38:57,860
0,180 180,540 540,660 660,1110 1110,1290
that number as servers come

1596
00:38:57,860 --> 00:38:58,940
0,330 330,570 600,810 810,870 870,1080
in,| but it's a little
|但这有点棘手，

1597
00:38:58,940 --> 00:39:00,410
0,540 660,870 870,1200 1200,1290 1290,1470
tricky,| and instead we can
|取而代之的是，我们可以计算已经完成的任务的数量，

1598
00:39:00,410 --> 00:39:02,090
0,300 300,390 390,810 810,1050 1050,1680
count the number of tasks

1599
00:39:02,090 --> 00:39:03,290
0,150 150,270 270,810 840,1080 1080,1200
that have finished,| so we
|所以我们把发送 true 给 done [向上对齐]，

1600
00:39:03,290 --> 00:39:04,760
0,150 150,360 360,510 510,900 900,1470
just moved the done sending

1601
00:39:04,760 --> 00:39:06,890
0,240 240,900 930,1140 1140,1800 1830,2130
true done [up align],| so
|不是对每个服务器执行这个操作，

1602
00:39:06,890 --> 00:39:07,820
0,120 120,420 420,510 510,750 750,930
that instead of doing it

1603
00:39:07,820 --> 00:39:08,780
0,210 210,600 600,690 690,870 870,960
per server,| we now do
|我们现在每个任务这样做，

1604
00:39:08,780 --> 00:39:10,340
0,120 120,270 270,1050 1290,1470 1470,1560
it per task,| and at
|在循环结束时，

1605
00:39:10,340 --> 00:39:11,210
0,150 150,300 300,390 390,510 510,870
the end of the loop,|
|

1606
00:39:11,240 --> 00:39:11,750
0,210 210,300 300,390 390,450 450,510
at the end of the
在函数结束时，

1607
00:39:11,750 --> 00:39:12,710
0,450 450,540 540,690 690,840 840,960
function,| we just have to
|我们只需等待合适数量的任务完成即可。

1608
00:39:12,710 --> 00:39:13,490
0,210 210,300 300,360 360,570 570,780
wait for the right number

1609
00:39:13,490 --> 00:39:14,480
0,90 90,540 540,630 630,720 720,990
of tasks to be done.|
|

1610
00:39:15,640 --> 00:39:17,230
0,210 210,570 660,930 930,1170 1170,1590
And so, so now again
所以，现在我们又一次知道为什么这些将会结束，

1611
00:39:17,230 --> 00:39:19,720
0,150 150,330 330,420 420,960 2130,2490
we sort of know why

1612
00:39:19,720 --> 00:39:21,130
0,210 210,300 300,420 420,600 690,1410
these are going to finish,|
|

1613
00:39:21,460 --> 00:39:22,900
0,390 390,600 600,930 930,990 990,1440
{} there's actually a deadlock
这里仍然有死锁，

1614
00:39:22,900 --> 00:39:24,220
0,630 720,900 900,1050 1050,1170 1170,1320
still,| and that is that
|也就是，如果任务的数量太大，

1615
00:39:24,220 --> 00:39:25,960
0,180 180,540 570,990 990,1080 1080,1740
if the number of tasks

1616
00:39:25,960 --> 00:39:27,280
0,360 360,810
is {}

1617
00:39:27,700 --> 00:39:28,930
0,210 210,330 330,810 840,1140 1140,1230
is too big,| actually I
|事实上，我认为总是这样的，

1618
00:39:28,930 --> 00:39:30,550
0,120 120,720 870,1410 1410,1560 1560,1620
think always,| you'll get a
|你会得到死锁，

1619
00:39:30,550 --> 00:39:31,840
0,600 630,870 870,960 960,1080 1080,1290
deadlock,| and if you run
|如果你运行这个程序，

1620
00:39:31,840 --> 00:39:32,800
0,450 450,570 570,720 720,840 840,960
this,| you know you get
|你得到这个好东西，

1621
00:39:32,800 --> 00:39:34,210
0,180 180,450 450,630 630,990 1140,1410
this nice thing,| where goroutine
|它告诉你，你的 goroutine 停止了，

1622
00:39:34,210 --> 00:39:35,170
0,240 240,360 360,510 510,660 660,960
tells you like hey your

1623
00:39:35,170 --> 00:39:35,950
0,240 240,300 300,630 630,720 720,780
goroutines are stop,| and the
|问题是，

1624
00:39:35,950 --> 00:39:37,750
0,390 390,750 900,1320 1350,1620 1620,1800
problem is that,| we have
|我们有这个 runTasks 服务器循环，

1625
00:39:37,750 --> 00:39:39,850
0,150 150,360 360,1170 1380,1740 1740,2100
this {runTasks -} {} server

1626
00:39:39,850 --> 00:39:40,780
0,450
loop,|
|

1627
00:39:40,840 --> 00:39:41,500
0,120 120,180 180,420 420,600 600,660
and the server loop is
服务器循环试图说，嘿，我完成了，

1628
00:39:41,500 --> 00:39:42,220
0,210 210,270 270,390 390,600 600,720
trying to say hey I'm

1629
00:39:42,220 --> 00:39:43,720
0,540 810,1020 1020,1170 1170,1410 1410,1500
done,| and you're trying to
|你想说，嘿，还有更多的工作要做，

1630
00:39:43,720 --> 00:39:44,740
0,210 210,420 420,690 690,900 900,1020
say hey like here's some

1631
00:39:44,740 --> 00:39:45,550
0,150 150,510 510,660 660,720 720,810
more work,| so if you
|如果你有不止一个任务，

1632
00:39:45,550 --> 00:39:46,690
0,90 90,300 300,390 390,600 600,1140
have more than one task,|
|

1633
00:39:46,690 --> 00:39:48,040
0,180 180,330 330,540 540,690 690,1350
you'll run into this deadlock,|
你就会陷入死锁，|

1634
00:39:48,730 --> 00:39:50,530
0,720 750,1320 1320,1530 1530,1590 1590,1800
where you're trying to send
当你尝试将下一个任务发送到服务器时，

1635
00:39:50,530 --> 00:39:51,490
0,90 90,390 390,810 810,870 870,960
the next task to a

1636
00:39:51,490 --> 00:39:52,780
0,570 600,720 720,900 900,1230 1230,1290
server,| I guess it's a
|我想这是比服务器多的任务，

1637
00:39:52,780 --> 00:39:54,160
0,180 180,390 390,720 720,840 840,1380
few more tasks than servers,|
|

1638
00:39:54,340 --> 00:39:55,090
0,300 300,450 450,510 510,690 690,750
you're trying to send the
你尝试将下一个任务发送到服务器，

1639
00:39:55,090 --> 00:39:55,990
0,180 180,450 450,510 510,600 600,900
next task to a server,|
|

1640
00:39:55,990 --> 00:39:56,680
0,90 90,180 180,270 270,630 630,690
and all the servers are
所有的服务器都尝试说，嘿，我完成了前一项任务，

1641
00:39:56,680 --> 00:39:57,430
0,210 210,270 270,420 420,600 600,750
trying to say hey I'm

1642
00:39:57,430 --> 00:39:58,720
0,180 180,330 330,420 420,810 810,1290
done with the previous task,|
|

1643
00:39:58,750 --> 00:39:59,680
0,240 240,360 360,570 570,780 780,930
but you're not there to
但你不是在那里接收来自 done channel 的。

1644
00:39:59,680 --> 00:40:00,910
0,390 390,540 540,630 630,810 810,1230
receive from the done channel.|
|

1645
00:40:01,920 --> 00:40:03,750
0,150 150,480 690,1200 1200,1380 1380,1830
And so again you know
所以再一次， goroutine 等待是很好的，

1646
00:40:03,810 --> 00:40:05,040
0,240 240,450 450,780 780,900 900,1230
it's really nice that the

1647
00:40:05,070 --> 00:40:06,300
0,540 540,720 720,900 900,1140 1140,1230
goroutine just hang around,| and
|等着查看它们。

1648
00:40:06,300 --> 00:40:06,900
0,210 210,300 300,360 360,450 450,600
wait for {you,know} to look

1649
00:40:06,900 --> 00:40:08,130
0,90 90,480 630,960 960,1080 1080,1230
at them.| And we can
|我们可以解决这个问题，

1650
00:40:08,130 --> 00:40:09,360
0,240 240,810
fix this,|
|

1651
00:40:09,750 --> 00:40:10,920
0,240 240,360 360,450 450,690 690,1170
one way to fix this
解决这个问题的一种方法是添加一个单独的循环，

1652
00:40:10,950 --> 00:40:12,840
0,300 300,540 540,840 840,1470 1500,1890
would be to {} add

1653
00:40:12,840 --> 00:40:14,010
0,60 60,420 420,690 690,870 870,1170
a separate loop,| that actually
|它执行一个 select ，

1654
00:40:14,010 --> 00:40:15,450
0,120 120,180 180,870 870,1020 1020,1440
does a select,| that either
|要么发送一些 work ，

1655
00:40:15,450 --> 00:40:17,340
0,450 450,630 630,1050 1080,1440 1470,1890
sends some work| or {a,counts}
|或者一些工作完成的计数，

1656
00:40:17,340 --> 00:40:18,330
0,390 420,630 630,690 690,750 750,990
for some of the work

1657
00:40:18,330 --> 00:40:21,030
0,240 240,720 930,1410 1410,2070 2130,2700
being done,| that's fine {},|
|那很好，|

1658
00:40:21,060 --> 00:40:21,840
0,150 150,240 240,570 570,690 690,780
but a cleaner way to
但更干净的方式是，

1659
00:40:21,840 --> 00:40:23,820
0,150 150,660 840,1140 1140,1530 1620,1980
do this,| is to take
|就是把 task 发送循环，

1660
00:40:23,820 --> 00:40:25,320
0,300 330,690 690,1020 1020,1320 1320,1500
the work sending loop that

1661
00:40:25,320 --> 00:40:26,640
0,360 360,600 600,930 930,1080 1080,1320
task sending loop,| and put
|并将其放入自己的 goroutine 中，

1662
00:40:26,640 --> 00:40:27,570
0,240 240,420 420,570 570,750 750,930
it in its own {goroutine

1663
00:40:27,570 --> 00:40:29,250
0,480 600,840 840,1110 1110,1410 1410,1680
-},| so now it's running
|所以现在它独立于计数循环运行，

1664
00:40:29,250 --> 00:40:30,930
0,690 690,810 810,900 900,1290 1290,1680
independently of the counting loop,|
|

1665
00:40:31,050 --> 00:40:32,700
0,210 210,270 270,690 690,1140 1170,1650
and the counting loop can
计数循环可以运行，

1666
00:40:32,700 --> 00:40:34,320
0,150 150,780 840,1170 1170,1260 1260,1620
can run| and you know
|未阻塞的服务器某些任务已完成，

1667
00:40:34,760 --> 00:40:36,110
0,630 630,990 990,1110 1110,1170 1170,1350
unblock servers that are done

1668
00:40:36,110 --> 00:40:37,400
0,120 120,360 360,870 870,1050 1050,1290
with certain tasks,| while other
|而其他任务仍在发送中。

1669
00:40:37,400 --> 00:40:38,660
0,360 360,420 420,630 630,840 840,1260
tasks are still being sent.|
|

1670
00:40:41,400 --> 00:40:43,350
0,330 330,420 420,1080 1080,1650 1650,1950
But the simplest possible fix
但解决这一问题最简单的办法是，

1671
00:40:43,350 --> 00:40:44,640
0,120 120,720 750,930 930,1050 1050,1290
for this is| to just
|把 work channel 做得足够大，

1672
00:40:44,640 --> 00:40:45,660
0,270 270,360 360,600 600,870 870,1020
make the work channel big

1673
00:40:45,660 --> 00:40:47,460
0,510 540,990 1020,1200 1200,1470 1470,1800
enough,| that you're never gonna
|你永远不会用完空间。

1674
00:40:47,490 --> 00:40:48,860
0,210 210,330 330,390 390,1020
run out of space.|
|

1675
00:40:49,020 --> 00:40:50,340
0,450 450,540 540,690 690,1140 1140,1320
Because we might decide that,|
因为我们可能会决定，|

1676
00:40:50,340 --> 00:40:51,570
0,90 90,420 450,930 930,1080 1080,1230
you know having a {goroutine
一个 goroutine 的 task 是，

1677
00:40:51,570 --> 00:40:52,770
0,300 300,420 420,870 870,1110 1110,1200
-} for task is| you
|任务有几千字节，

1678
00:40:52,770 --> 00:40:53,970
0,90 90,180 180,480 480,1080 1080,1200
know a couple kilobytes for

1679
00:40:53,970 --> 00:40:56,010
0,570 690,1350 1350,1440 1440,1800 1800,2040
task,| but you know an
|但是 channel 中的整型是 8 个字节，

1680
00:40:56,010 --> 00:40:57,210
0,360 360,600 600,690 690,780 780,1200
[extra] int in the channel

1681
00:40:57,210 --> 00:40:58,740
0,210 210,420 420,960 990,1200 1200,1530
is 8 bytes,| so probably
|所以，你可能会在每个任务上花费 8 个字节。

1682
00:40:58,740 --> 00:40:59,730
0,120 120,300 300,630 630,750 750,990
you can spend 8 bytes

1683
00:40:59,730 --> 00:41:00,860
0,120 120,690
per task.|
|

1684
00:41:01,360 --> 00:41:02,380
0,120 120,270 270,360 360,480 480,1020
And so if you can,|
所以如果可以的话，|

1685
00:41:02,410 --> 00:41:03,220
0,270 270,390 390,510 510,600 600,810
you just make the work
你只要把 work channel 做得足够大，

1686
00:41:03,220 --> 00:41:04,420
0,210 210,360 360,840 870,1050 1050,1200
channel big enough,| that you
|你知道发送给 work 的不会阻塞，

1687
00:41:04,420 --> 00:41:05,380
0,300 300,420 420,540 540,630 630,960
know that all the sends

1688
00:41:05,380 --> 00:41:06,640
0,150 150,570 570,690 690,930 930,1260
on work are going to

1689
00:41:06,670 --> 00:41:08,050
0,270 270,780 780,870 870,1020 1020,1380
never block,| and you'll always
|你总是很快地进入到最后的计数循环。

1690
00:41:08,050 --> 00:41:09,670
0,210 210,540 540,750 750,1200 1230,1620
get down to the counting

1691
00:41:09,670 --> 00:41:10,960
0,360 420,660 660,810 810,1080 1080,1290
loop at the end pretty

1692
00:41:10,960 --> 00:41:11,940
0,420
quickly.|
|

1693
00:41:12,740 --> 00:41:14,090
0,150 150,420 420,720 720,1080 1080,1350
And so doing that actually
这样做为实验中的其他[]做好了准备，

1694
00:41:14,090 --> 00:41:15,680
0,270 270,420 420,600 600,1020 1050,1590
sets us up pretty well

1695
00:41:15,680 --> 00:41:16,520
0,120 120,240 240,480 480,780 780,840
for the other [] in

1696
00:41:16,520 --> 00:41:17,330
0,90 90,360 360,480 480,540 540,810
the lab,| which is that
|那就是有时调用可能会超时，

1697
00:41:17,450 --> 00:41:19,340
0,690 690,1020 1020,1110 1110,1680 1710,1890
sometimes calls can timeout,| and
|在这里，我通过调用返回一个 false ，

1698
00:41:19,340 --> 00:41:20,630
0,240 240,390 390,750 750,870 870,1290
here I've modeled it by

1699
00:41:20,720 --> 00:41:21,800
0,360 360,570 570,660 660,990 990,1080
the call of returning a

1700
00:41:21,800 --> 00:41:22,820
0,300 300,390 390,540 540,690 690,1020
false,| so just say it
|表示它没有工作。

1701
00:41:22,820 --> 00:41:23,900
0,180 180,510
didn't work.|
|

1702
00:41:24,560 --> 00:41:26,690
0,450 600,930 930,1500 1890,2040 2040,2130
{} And so you know
所以，在 runTasks 中，很容易看出，

1703
00:41:26,690 --> 00:41:27,710
0,150 150,360 360,720 720,840 840,1020
in {runTasks -} is really

1704
00:41:27,710 --> 00:41:29,150
0,210 210,300 300,510 510,810 810,1440
easy to see,| like if
|很容易看出，

1705
00:41:30,450 --> 00:41:31,380
0,210 210,390 390,600 600,690 690,930
it's really easy to see,|
|

1706
00:41:31,380 --> 00:41:33,930
0,210 210,330 330,420 420,1170 1320,2550
like if the call fails,
如果调用失败，那么，

1707
00:41:34,460 --> 00:41:36,410
0,630 930,1290 1290,1350 1350,1530 1530,1950
then,| {sorry,if} the call succeeds,
|抱歉，如果调用成功，你就完成了，

1708
00:41:36,410 --> 00:41:37,430
0,150 150,480 480,780 780,900 900,1020
then you're done,| but if
|但如果失败了，就把这项任务重新放回 work 列表中，

1709
00:41:37,430 --> 00:41:38,480
0,120 120,570 570,810 810,990 990,1050
it fails, just put the

1710
00:41:38,480 --> 00:41:39,650
0,420 420,720 720,810 810,900 900,1170
task back on the work

1711
00:41:39,650 --> 00:41:40,880
0,420 540,780 780,1020 1020,1140 1140,1230
list,| and because it's a
|因为它是一个队列，而不是一个堆栈，

1712
00:41:40,880 --> 00:41:42,590
0,390 390,570 570,660 660,1290 1350,1710
queue, not a stack,| putting
|把它放回 work 列表中，

1713
00:41:42,590 --> 00:41:43,220
0,60 60,270 270,360 360,420 420,630
it back on the work

1714
00:41:43,220 --> 00:41:44,180
0,180 180,300 300,510 510,840 840,960
list| is very likely to
|会把它交给其他服务器。

1715
00:41:44,180 --> 00:41:44,960
0,240 240,330 330,390 390,570 570,780
hand it to some other

1716
00:41:44,960 --> 00:41:45,980
0,570
server.|
|

1717
00:41:46,180 --> 00:41:48,160
0,450 450,720 720,1080 1110,1530 1530,1980
{} And so that will
所以，这很可能会成功，

1718
00:41:48,190 --> 00:41:50,260
0,840 840,1440 1470,1830 1830,1920 1920,2070
probably succeed,| because it's some
|因为它是另一台服务器，

1719
00:41:50,260 --> 00:41:51,160
0,210 210,540 540,630 630,810 810,900
other server,| and this is
|这都是假设的，

1720
00:41:51,160 --> 00:41:54,080
0,300 360,1230 1260,1920 1920,2400
all hypothetical,| but {
|但这是一个非常，

1721
00:41:54,490 --> 00:41:55,780
0,300 300,510 510,630 630,1170 1170,1290
-} it's a really,| you
|它非常适合我们创造的结构。

1722
00:41:55,780 --> 00:41:56,890
0,90 90,270 270,540 540,780 780,1110
know it fits really well

1723
00:41:56,890 --> 00:41:57,940
0,240 240,330 330,780 780,900 900,1050
into the structure that we've

1724
00:41:57,940 --> 00:41:59,080
0,510
created.|
|

1725
00:42:00,710 --> 00:42:02,030
0,330 330,420 420,510 510,810 810,1320
Alright, and the final change
好的，最后的修改是，

1726
00:42:02,120 --> 00:42:03,500
0,240 240,540 630,990 990,1080 1080,1380
is that,| because the server
|因为服务器 goroutine 发送工作，

1727
00:42:03,500 --> 00:42:04,460
0,90 90,390 390,480 480,810 810,960
{goroutines -} are sending on

1728
00:42:04,460 --> 00:42:06,290
0,630 720,960 960,1110 1110,1380 1380,1830
work,| we do have to
|我们必须等到关闭它，

1729
00:42:06,290 --> 00:42:07,760
0,270 270,360 360,720 720,1050 1200,1470
wait to close it| until
|直到它们发送完毕，

1730
00:42:07,760 --> 00:42:08,480
0,90 90,240 240,390 390,510 510,720
we know that they're done

1731
00:42:08,480 --> 00:42:09,600
0,540
sending,|
|

1732
00:42:09,600 --> 00:42:11,100
0,360 360,570 570,900 900,1170 1170,1500
and {} because again you
因为在它们完成发送之前，你不能关闭。

1733
00:42:11,100 --> 00:42:13,140
0,210 210,600 600,1440 1470,1740 1740,2040
can't close before they finish

1734
00:42:13,140 --> 00:42:14,160
0,390
sending.|
|

1735
00:42:14,370 --> 00:42:15,000
0,150 150,270 270,390 390,510 510,630
And so we just have
所以我们需要把 close 移动到

1736
00:42:15,000 --> 00:42:16,590
0,120 120,330 330,420 420,1140 1170,1590
to move the close| until
|我们数完所有任务之后，

1737
00:42:16,590 --> 00:42:17,850
0,390 390,600 600,1020 1020,1140 1140,1260
after we've counted that all

1738
00:42:17,850 --> 00:42:20,820
0,90 90,540 540,840 1770,2610 2610,2970
the tasks done,| and sometimes
|有时我们会走到这一步，

1739
00:42:20,820 --> 00:42:21,540
0,90 90,240 240,300 300,480 480,720
we get to this point,|
|

1740
00:42:21,540 --> 00:42:23,070
0,90 90,390 390,750 930,1320 1320,1530
and people ask why can't
人们会问为什么你不能直接杀死 goroutine ，

1741
00:42:23,070 --> 00:42:24,630
0,120 120,510 510,900 900,1050 1050,1560
you just kill {goroutines -},|
|

1742
00:42:24,630 --> 00:42:25,530
0,150 150,510 510,660 660,810 810,900
like why not just be
比如为什么不能说，

1743
00:42:25,530 --> 00:42:26,520
0,150 150,210 210,360 360,600 600,990
able to say,| look hey
|在这一点上杀死所有的服务器 goroutine ，

1744
00:42:26,520 --> 00:42:27,600
0,180 180,330 330,390 390,750 750,1080
kill all the server goroutines

1745
00:42:27,600 --> 00:42:28,260
0,60 60,210 210,390 390,480 480,660
at this point,| we know
|我们知道它们不再需要了。

1746
00:42:28,260 --> 00:42:29,340
0,150 150,270 270,450 450,660 660,1080
that they're not needed anymore.|
|

1747
00:42:29,900 --> 00:42:30,680
0,120 120,210 210,420 420,510 510,780
And the answer is that
答案是 goroutine 有状态，

1748
00:42:30,770 --> 00:42:32,270
0,300 300,540 540,780 780,1110 1110,1500
the {goroutines -} has state|
|

1749
00:42:32,270 --> 00:42:33,200
0,90 90,240 240,750 750,870 870,930
and it's interacting with the
它与程序的其余部分相互作用，

1750
00:42:33,200 --> 00:42:34,190
0,240 240,300 300,390 390,900 900,990
rest of the program,| and
|如果它突然停止了，

1751
00:42:34,190 --> 00:42:34,610
0,90 90,210 210,270 270,360 360,420
if it all of a

1752
00:42:34,610 --> 00:42:36,560
0,210 210,450 450,1260 1560,1800 1800,1950
sudden just stops,| it's sort
|有点像卡住了，

1753
00:42:36,560 --> 00:42:37,670
0,90 90,300 300,420 420,810 810,1110
of like it hung, right,|
|

1754
00:42:37,670 --> 00:42:38,870
0,360 420,720 720,780 780,930 930,1200
and maybe it was holding
也许它持有一把锁，

1755
00:42:38,870 --> 00:42:40,040
0,60 60,570 660,990 990,1050 1050,1170
a lock,| maybe it was
|也许是在通信的过程中，

1756
00:42:40,040 --> 00:42:40,730
0,60 60,120 120,420 420,540 540,690
in the middle of some

1757
00:42:40,730 --> 00:42:41,900
0,180 180,270 270,870 870,1020 1020,1170
sort of communication| with some
|与一些其他等待回复的 goroutine 。

1758
00:42:41,900 --> 00:42:42,800
0,210 210,540 540,630 630,750 750,900
other goroutines that was kind

1759
00:42:42,800 --> 00:42:44,360
0,60 60,480 480,570 570,1080
of expecting an answer.|
|

1760
00:42:44,510 --> 00:42:45,680
0,360 480,720 720,840 840,930 930,1170
So we need to find
所以我们需要想办法更优雅地关闭它们，

1761
00:42:45,680 --> 00:42:46,940
0,120 120,270 270,900 930,1140 1140,1260
some way to tear them

1762
00:42:46,940 --> 00:42:47,960
0,180 180,330 330,750 750,840 840,1020
down more gracefully,| and that's
|那就是明确地告诉它们，

1763
00:42:47,960 --> 00:42:49,460
0,180 180,600 600,720 720,1200 1200,1500
by telling them explicitly,| hey
|嘿，你完成了，你可以走了，

1764
00:42:49,460 --> 00:42:50,510
0,120 120,390 420,600 600,930 930,1050
you know you're done, you

1765
00:42:50,510 --> 00:42:51,470
0,330 330,420 420,720 720,810 810,960
can go away,| and then
|然后它们可以清理它们需要清理的东西。

1766
00:42:51,470 --> 00:42:52,760
0,120 120,270 270,540 540,690 690,1290
they can clean up however

1767
00:42:52,850 --> 00:42:53,930
0,300 300,480 480,570 570,810 810,1080
they need to clean up.|
|

1768
00:42:57,490 --> 00:42:58,960
0,630 750,930 930,1170 1170,1230 1230,1470
You know, speaking of cleaning
说到清理，

1769
00:42:58,960 --> 00:43:00,040
0,210 210,450 450,690 690,930 930,1080
up,| there's there's actually one
|我们还有一件事要做，

1770
00:43:00,040 --> 00:43:00,730
0,180 180,330 330,450 450,600 600,690
more thing we have to

1771
00:43:00,730 --> 00:43:01,540
0,150 150,390 390,480 480,600 600,810
do,| which is to shut
|就是关闭正在监视新服务器的循环，

1772
00:43:01,540 --> 00:43:02,950
0,240 240,360 360,630 630,1080 1080,1410
down the loop that's watching

1773
00:43:02,950 --> 00:43:04,690
0,120 120,360 360,990 1170,1470 1470,1740
for new servers,| and so
|所以我们必须在这里放一个 select ，

1774
00:43:04,690 --> 00:43:05,410
0,150 150,300 300,480 480,570 570,720
we do have to put

1775
00:43:05,410 --> 00:43:07,300
0,60 60,420 420,480 480,1020 1050,1890
a select in here,| where
|在那里在服务器 channel 上等待新服务器，

1776
00:43:07,910 --> 00:43:09,680
0,450 450,570 570,870 1050,1530 1530,1770
{} you know the thing

1777
00:43:09,680 --> 00:43:10,760
0,150 150,480 480,600 600,750 750,1080
that's waiting for new servers

1778
00:43:10,760 --> 00:43:11,600
0,90 90,180 180,390 390,690 690,840
on the server channel,| we
|我们必须去告诉它，

1779
00:43:11,600 --> 00:43:12,470
0,120 120,210 210,390 390,660 660,870
have to go tell it,|
|

1780
00:43:12,710 --> 00:43:13,850
0,360 360,480 480,780 780,990 990,1140
okay, we're done, just like
好的，我们已经完成了，停止监视新服务器，

1781
00:43:13,850 --> 00:43:15,290
0,330 330,630 630,780 780,1320 1320,1440
stop watching new servers,| all
|所有的服务器都不见了。

1782
00:43:15,290 --> 00:43:17,390
0,60 60,510 510,750 750,1170 1650,2100
the servers are {gone -}.|
|

1783
00:43:18,180 --> 00:43:19,110
0,180 180,270 270,570 570,780 780,930
And we could make this
我们可以把这个问题变成调用者的问题，

1784
00:43:19,110 --> 00:43:20,580
0,90 90,480 480,870 870,1170 1170,1470
the caller's problem,| but this
|但这是相当容易做到的。

1785
00:43:20,580 --> 00:43:21,600
0,120 120,420 420,720 720,930 930,1020
is actually fairly easy to

1786
00:43:21,600 --> 00:43:22,560
0,360
do.|
|

1787
00:43:24,260 --> 00:43:26,330
0,420 450,930 930,1560 1620,1830 1830,2070
Alright, so {} here pattern
好的，这里是模式3，这是一个复制服务器服务的客户端。

1788
00:43:26,330 --> 00:43:27,530
0,180 180,450 450,660 660,810 810,1200
number three, which is a

1789
00:43:27,530 --> 00:43:29,390
0,600 600,720 720,810 810,1320 1320,1860
client for a replicated server

1790
00:43:29,600 --> 00:43:30,960
0,120 120,210 210,960
{} of service.|
|

1791
00:43:31,340 --> 00:43:33,020
0,510 540,1080 1080,1200 1200,1590 1590,1680
So here's the interface that
下面是我们要实现的接口，

1792
00:43:33,020 --> 00:43:33,920
0,120 120,270 270,330 330,780 780,900
we want to implement,| we
|我们有一些我们想要的服务，为了可靠性而复制

1793
00:43:33,920 --> 00:43:36,640
0,180 180,450 450,1290 1440,2190
have some service that,

1794
00:43:36,730 --> 00:43:38,050
0,240 240,510 510,660 660,780 780,1320
we want that is replicated

1795
00:43:38,050 --> 00:43:40,120
0,150 150,1020 1350,1620 1620,1830 1830,2070
for reliability| and it's okay
|客户端可以与这些服务器中的任何一个进行对话

1796
00:43:40,120 --> 00:43:40,960
0,120 120,180 180,510 510,600 600,840
for a client to talk

1797
00:43:40,960 --> 00:43:41,950
0,90 90,300 300,570 570,660 660,990
to any one of these

1798
00:43:41,980 --> 00:43:44,710
0,720 930,1200 1200,1560 1590,1980 2010,2730
servers| and so the replicated
|因此被复制的客户端被给予服务器列表，

1799
00:43:44,710 --> 00:43:46,990
0,690 810,1200 1200,1830 1860,2010 2010,2280
client is given a list

1800
00:43:46,990 --> 00:43:49,120
0,90 90,840 870,1650 1650,2010 2010,2130
of servers,| the arguments to
|Init的参数是服务器列表

1801
00:43:49,120 --> 00:43:49,900
0,120 120,360 360,480 480,540 540,780
{Init -} is a list

1802
00:43:49,900 --> 00:43:51,820
0,90 90,660 780,1260 1260,1350 1350,1920
of servers| and a function
|还有一个函数，它允许您使用特定的参数集调用其中一个服务器并获得回复。

1803
00:43:51,820 --> 00:43:53,170
0,150 150,390 390,510 510,1020 1020,1350
that lets you call one

1804
00:43:53,170 --> 00:43:54,310
0,150 150,210 210,840 870,1110 1110,1140
of the servers with a

1805
00:43:54,310 --> 00:43:55,720
0,480 480,870 870,1170 1170,1290 1290,1410
particular argument set and get

1806
00:43:55,720 --> 00:43:56,740
0,60 60,540
a reply.|
|

1807
00:43:57,260 --> 00:43:59,360
0,180 180,540 900,1410 1410,1740 1740,2100
And then being given that
然后在初始化过程中被给予，

1808
00:43:59,360 --> 00:44:00,860
0,300 300,420 420,780 810,1050 1050,1500
during {Init -},| the replicated
|然后，复制的客户端提供一个调用方法，该方法不会告诉您它将使用哪个服务器，

1809
00:44:00,860 --> 00:44:03,170
0,390 390,540 540,1770 1800,1980 1980,2310
client then provides a call

1810
00:44:03,170 --> 00:44:05,180
0,630 780,1260 1350,1770 1770,1950 1950,2010
method that doesn't tell you

1811
00:44:05,180 --> 00:44:06,170
0,210 210,660 660,810 810,930 930,990
what server it's going to

1812
00:44:06,170 --> 00:44:07,190
0,360 360,420 420,630 630,930 930,1020
use,| it just finds a
|它只是找到一个好的服务器来使用

1813
00:44:07,190 --> 00:44:08,780
0,180 180,630 630,720 720,1320 1380,1590
good server to use| and
|它保持不变，尽可能长时间地使用同一服务器

1814
00:44:08,780 --> 00:44:09,860
0,120 120,420 420,510 510,840 840,1080
it keeps the same, keeps

1815
00:44:09,860 --> 00:44:11,030
0,210 210,300 300,540 540,1080 1080,1170
using the same server for

1816
00:44:11,030 --> 00:44:11,780
0,120 120,300 300,390 390,450 450,750
as long as it can|
|

1817
00:44:11,780 --> 00:44:12,650
0,300 300,390 390,630 630,750 750,870
until it finds out that
直到它发现该服务器不好为止。

1818
00:44:12,650 --> 00:44:13,610
0,180 180,450 450,540 540,660 660,960
that server is no good.|
|

1819
00:44:15,240 --> 00:44:16,560
0,270 270,420 420,570 570,1080 1080,1320
So in this situation, there's
因此，在这种情况下，您几乎不需要共享状态

1820
00:44:16,560 --> 00:44:17,880
0,450 450,600 600,900 900,1230 1230,1320
almost no shared state that

1821
00:44:17,880 --> 00:44:19,380
0,90 90,240 240,300 300,780 1350,1500
you need to {}| and
|因此，从一次调用到下一次调用，唯一保持的状态就是我上次使用的服务器，

1822
00:44:19,380 --> 00:44:20,280
0,180 180,420 420,510 510,660 660,900
so like the only state

1823
00:44:20,280 --> 00:44:21,300
0,90 90,450 450,600 600,780 780,1020
that persists from one call

1824
00:44:21,300 --> 00:44:22,230
0,90 90,390 390,480 480,660 660,930
to next is what server

1825
00:44:22,230 --> 00:44:23,130
0,150 150,210 210,420 420,690 690,900
did I use last time,|
|

1826
00:44:23,130 --> 00:44:23,760
0,210 210,270 270,390 390,450 450,630
because I'm going to try
因为我要试着再用一次。

1827
00:44:23,760 --> 00:44:25,160
0,60 60,240 240,420 420,870
to use that again.|
|

1828
00:44:25,500 --> 00:44:26,850
0,480 570,840 840,960 960,1170 1170,1350
So in this case that's
所以在这种情况下，这对互斥体来说是完全没有问题的，

1829
00:44:26,850 --> 00:44:28,050
0,330 330,570 570,690 690,1110 1110,1200
totally fine for mutex,| I'm
|我只想把它留在那里，

1830
00:44:28,050 --> 00:44:28,620
0,150 150,270 270,330 330,480 480,570
just going to leave it

1831
00:44:28,620 --> 00:44:30,210
0,420 510,780 780,1200 1200,1500 1500,1590
there,| it's always okay to
|使用互斥体总是可以的，

1832
00:44:30,210 --> 00:44:31,470
0,210 210,720 720,930 930,1170 1170,1260
use mutex,| if that's the
|如果这是编写代码的最干净的方式。

1833
00:44:31,470 --> 00:44:32,640
0,420 420,750 750,900 900,1110 1110,1170
cleanest way to write the

1834
00:44:32,640 --> 00:44:33,600
0,420
code.|
|

1835
00:44:33,660 --> 00:44:34,620
0,330 330,420 420,600 600,810 810,960
You know, some people get
你知道，有些人从我们谈论频道的次数中得到了错误的印象，

1836
00:44:34,620 --> 00:44:35,700
0,90 90,300 300,750 750,930 930,1080
the wrong impression from how

1837
00:44:35,700 --> 00:44:36,750
0,180 180,240 240,450 450,690 690,1050
much we talk about channels,|
|

1838
00:44:36,750 --> 00:44:37,680
0,120 120,390 390,660 660,840 840,930
but it's always okay to
但是，如果需要的话，使用互斥总是可以的。

1839
00:44:37,680 --> 00:44:38,700
0,150 150,600 600,690 690,870 870,1020
use mutex, if that's all

1840
00:44:38,700 --> 00:44:39,740
0,90 90,480
you need.|
|

1841
00:44:40,880 --> 00:44:42,020
0,570 630,870 870,930 930,1080 1080,1140
So now we need to
所以现在我们需要实现这个复制的调用方法，

1842
00:44:42,020 --> 00:44:44,000
0,420 420,750 810,1410 1410,1650 1650,1980
implement this replicated call method,|
|

1843
00:44:44,000 --> 00:44:45,320
0,210 210,540 540,660 660,930 960,1320
whose job is to try
它的工作是尝试发送到许多不同的服务器。

1844
00:44:45,320 --> 00:44:46,610
0,390 390,660 690,990 990,1050 1050,1290
sending to lots of different

1845
00:44:46,610 --> 00:44:47,740
0,630
servers.|
|

1846
00:44:47,890 --> 00:44:49,480
0,600 600,900 900,960 960,1230 1230,1590
But first to try the
但首先要试一下原来的服务器。

1847
00:44:49,510 --> 00:44:51,060
0,150 150,510 510,930
the original server.|
|

1848
00:44:51,090 --> 00:44:52,080
0,420 450,600 600,750 750,870 870,990
So, so what does it
那么，如果尝试失败了又意味着什么呢，

1849
00:44:52,080 --> 00:44:54,510
0,330 330,720 810,1110 1110,1650 1650,2430
mean if the try fails,|
|

1850
00:44:54,660 --> 00:44:57,090
0,270 270,750 1020,1650 1740,2160 2160,2430
well there's no clear way
没有明确的方法让它在上面失败，

1851
00:44:57,090 --> 00:44:58,110
0,150 150,240 240,300 300,600 600,1020
for it to fail above,|
|

1852
00:44:58,110 --> 00:44:59,100
0,60 60,300 300,630 630,930 930,990
it just always returns a
它只是总是返回一个回复

1853
00:44:59,100 --> 00:45:00,120
0,510 510,630 630,750 750,870 870,1020
reply| and so the only
|因此，它失败的唯一方式是如果它花的时间太长，

1854
00:45:00,120 --> 00:45:00,930
0,150 150,240 240,360 360,660 660,810
way it can fail is

1855
00:45:00,930 --> 00:45:01,980
0,90 90,240 240,540 540,690 690,1050
if it's taking too long,|
|

1856
00:45:02,310 --> 00:45:03,420
0,210 210,330 330,660 660,750 750,1110
so we'll assume that if
所以我们假设，如果花了太长时间，就意味着它失败了。

1857
00:45:03,420 --> 00:45:04,380
0,150 150,360 360,510 510,810 810,960
it takes too long, that

1858
00:45:04,380 --> 00:45:05,540
0,180 180,270 270,720
means it failed.|
|

1859
00:45:06,000 --> 00:45:07,110
0,300 300,420 420,660 660,840 840,1110
So in order to deal
因此，为了应对超时，

1860
00:45:07,110 --> 00:45:08,220
0,390 390,660 660,900 900,990 990,1110
with {timeouts -},| we have
|我们必须在后台的另一个Goroutine中运行该代码。

1861
00:45:08,220 --> 00:45:09,600
0,120 120,360 360,1080 1080,1320 1320,1380
to run that code in

1862
00:45:09,600 --> 00:45:10,620
0,60 60,570 570,660 660,720 720,1020
the background in a different

1863
00:45:10,620 --> 00:45:12,030
0,120 120,240 240,510 1020,1320 1320,1410
{goroutine - -}.| So we
|所以我们可以做这样的事情，

1864
00:45:12,030 --> 00:45:13,380
0,120 120,210 210,540 540,720 720,1350
can do something like this,|
|

1865
00:45:14,110 --> 00:45:15,550
0,510 630,1080 1080,1200 1200,1380 1380,1440
{} where we set a
在那里我们设置了超时，

1866
00:45:15,550 --> 00:45:17,440
0,690 690,780 780,1020 1020,1050 1050,1890
timeout,| we create a timer
|我们创建一个计时器，然后使用Goroutine在后台发送

1867
00:45:18,070 --> 00:45:19,300
0,180 180,360 360,720 720,1080 1080,1230
and then we use {goroutine

1868
00:45:19,300 --> 00:45:19,990
0,270 270,330 330,540 540,630 630,690
-} to send in the

1869
00:45:19,990 --> 00:45:21,490
0,660 960,1170 1170,1260 1260,1350 1350,1500
background| and then at the
|然后在最后，我们等待，要么我们得到超时，要么我们得到实际的回复，

1870
00:45:21,490 --> 00:45:22,810
0,360 360,480 480,930 930,1080 1080,1320
end, we wait and either

1871
00:45:22,810 --> 00:45:24,160
0,120 120,270 270,360 360,1080 1140,1350
we get the timeout or

1872
00:45:24,160 --> 00:45:25,450
0,120 120,270 270,390 390,720 720,1290
we get the actual reply,|
|

1873
00:45:25,540 --> 00:45:26,260
0,150 150,210 210,330 330,420 420,720
if we get the actual
如果我们得到了实际的回复，我们会返回它

1874
00:45:26,260 --> 00:45:28,330
0,690 720,870 870,1200 1200,1440 1860,2070
reply, we return it| and
|如果我们暂停了，我们就得做点什么，

1875
00:45:28,330 --> 00:45:29,650
0,120 120,180 180,930 960,1200 1200,1320
{if,we,get} the timeout, we have

1876
00:45:29,650 --> 00:45:30,550
0,60 60,180 180,570 660,810 810,900
to do something,| we have
|我们必须弄清楚该怎么办。

1877
00:45:30,550 --> 00:45:31,150
0,90 90,300 300,360 360,510 510,600
to figure out what to

1878
00:45:31,150 --> 00:45:31,900
0,270
do.|
|

1879
00:45:32,320 --> 00:45:33,550
0,300 300,510 510,720 720,990 990,1230
{} It's worth pointing out
值得一提的是，您必须呼叫T.Stop，

1880
00:45:33,550 --> 00:45:35,800
0,300 960,1200 1200,1440 1440,1920 1950,2250
that you have to call

1881
00:45:35,800 --> 00:45:37,930
0,120 120,360 360,1170 1200,1590 1590,2130
{t.stop - -},| because otherwise
|因为否则定时器位于定时器队列中，

1882
00:45:37,930 --> 00:45:39,010
0,60 60,480 480,780 780,930 930,1080
the timer sits in a

1883
00:45:39,010 --> 00:45:40,330
0,330 330,630 630,1140 1140,1260 1260,1320
timer queue,| that's going to
|它将在一秒钟内爆炸

1884
00:45:40,330 --> 00:45:41,500
0,150 150,360 360,450 450,660 660,1170
go off in one second|
|

1885
00:45:41,830 --> 00:45:42,490
0,180 180,360 360,480 480,570 570,660
and so you know if
所以你知道如果这通电话花了一毫秒

1886
00:45:42,490 --> 00:45:43,840
0,120 120,390 390,540 540,570 570,1350
this call took a millisecond|
|

1887
00:45:43,840 --> 00:45:44,590
0,120 120,210 210,300 300,420 420,750
and you have this timer
你有一个计时器，它会在接下来的一秒里停在那里

1888
00:45:44,590 --> 00:45:45,280
0,150 150,270 270,360 360,480 480,690
that's going to sit there

1889
00:45:45,280 --> 00:45:46,330
0,90 90,150 150,360 360,870 900,1050
for the next second| and
|然后你在一个循环中做这个

1890
00:45:46,330 --> 00:45:46,930
0,120 120,240 240,360 360,540 540,600
then you do this on

1891
00:45:46,930 --> 00:45:47,980
0,60 60,600 750,870 870,960 960,1050
a loop| and you get
|你有一千个定时器坐在那个队列里

1892
00:45:47,980 --> 00:45:49,150
0,60 60,450 450,840 840,1080 1080,1170
a thousand timers sitting in

1893
00:45:49,150 --> 00:45:51,250
0,960 1200,1440 1440,1680 1680,1980 1980,2100
that that queue| before they
|在他们开始之前，实际上你知道一个消失的过程。

1894
00:45:51,250 --> 00:45:52,960
0,390 390,1020 1080,1230 1230,1380 1380,1710
start actually you know a

1895
00:45:53,020 --> 00:45:55,040
0,630 900,1170 1170,1650
disappearing.| And so,
|所以，这是一种在API中的工作，

1896
00:45:55,160 --> 00:45:55,790
0,180 180,240 240,420 420,510 510,630
this is kind of a

1897
00:45:55,790 --> 00:45:57,110
0,330 330,390 390,510 510,1110 1110,1320
work in the API,| but
|但它一直在那里，我们从来没有修复过它

1898
00:45:57,110 --> 00:45:58,250
0,180 180,330 330,510 510,900 900,1140
it's been there forever and

1899
00:45:58,280 --> 00:46:00,200
0,180 180,450 450,690 690,900 1440,1920
we've never fixed it| and
|所以你只需要记得叫停就行了。

1900
00:46:00,740 --> 00:46:01,790
0,450 450,540 540,780 780,900 900,1050
and so you just have

1901
00:46:01,790 --> 00:46:02,960
0,60 60,300 300,390 390,600 600,1170
to remember to call stop.|
|

1902
00:46:04,230 --> 00:46:05,580
0,300 300,450 450,780 810,1260 1260,1350
{} And then now we
然后现在我们必须弄清楚在超时的情况下我们该怎么做。

1903
00:46:05,580 --> 00:46:06,270
0,90 90,150 150,300 300,450 450,690
have to figure out what

1904
00:46:06,270 --> 00:46:06,900
0,60 60,180 180,450 450,570 570,630
do we do in the

1905
00:46:06,900 --> 00:46:08,300
0,240 240,330 330,390 390,840
case of the timeout.|
|

1906
00:46:08,880 --> 00:46:09,450
0,150 150,270 270,330 330,390 390,570
And so in the case
因此，在超时的情况下，

1907
00:46:09,450 --> 00:46:10,380
0,60 60,150 150,690 690,810 810,930
of the timeout,| we're going
|我们需要尝试不同的服务器，

1908
00:46:10,380 --> 00:46:11,100
0,60 60,300 300,390 390,660 660,720
to need to try a

1909
00:46:11,100 --> 00:46:12,480
0,300 300,870 900,1110 1110,1230 1230,1380
different server,| so we'll write
|所以我们要写一个循环。

1910
00:46:12,480 --> 00:46:13,600
0,60 60,570
a loop.|
|

1911
00:46:13,660 --> 00:46:16,000
0,150 150,300 300,1170 1200,1740 1770,2340
And we'll start at {}
我们将从id开始，它说id为零

1912
00:46:16,030 --> 00:46:17,860
0,180 180,600 600,1020 1200,1500 1500,1830
the id, that id zero

1913
00:46:17,860 --> 00:46:19,630
0,90 90,1020 1080,1530 1530,1620 1620,1770
it says| and you know
|你知道，如果收到回复，那就太好了

1914
00:46:19,630 --> 00:46:20,500
0,150 150,210 210,510 510,750 750,870
if a reply comes in,

1915
00:46:20,500 --> 00:46:22,210
0,210 210,690 810,990 990,1500 1500,1710
that's great| and otherwise we'll
|否则我们将重置超时并再次循环

1916
00:46:22,210 --> 00:46:23,320
0,360 360,450 450,750 750,990 990,1110
reset the {timeout -} and

1917
00:46:23,320 --> 00:46:24,550
0,120 120,360 360,450 450,660 660,1230
go around the loop again|
|

1918
00:46:24,700 --> 00:46:25,600
0,150 150,390 390,690 690,810 810,900
and try sending to a
并尝试发送到不同的服务器。

1919
00:46:25,600 --> 00:46:28,280
0,450 480,1050 1410,1620 1620,2310
different server.| And notice,
|请注意，此程序中只有一个完成频道

1920
00:46:28,280 --> 00:46:29,840
0,300 300,480 480,780 780,1020 1020,1560
there's only one done channel

1921
00:46:29,930 --> 00:46:31,940
0,180 180,390 390,960 1320,1500 1500,2010
in this program| and so
|因此，在循环的第三次迭代中，我们可能会等待

1922
00:46:31,940 --> 00:46:33,110
0,300 300,390 390,690 690,1110 1110,1170
on the third iteration of

1923
00:46:33,110 --> 00:46:34,190
0,90 90,600 630,750 750,960 960,1080
the loop, we might be

1924
00:46:34,190 --> 00:46:36,020
0,630 960,1200 1200,1410 1410,1740 1740,1830
waiting| and then finally the
|然后最后第一个服务器给我们一个回复，

1925
00:46:36,020 --> 00:46:37,040
0,330 330,630 630,810 810,960 960,1020
first server gives us a

1926
00:46:37,040 --> 00:46:38,690
0,630 720,960 960,1260 1260,1560 1560,1650
reply,| that's totally fine, we'll
|这完全没问题，我们会接受这样的回答，太棒了。

1927
00:46:38,690 --> 00:46:40,010
0,180 180,360 360,780 810,990 990,1320
take that reply, that's great.|
|

1928
00:46:41,060 --> 00:46:42,800
0,570 630,930 930,1080 1080,1440 1440,1740
{} And so then we'll
所以我们会停下来把它还回去。

1929
00:46:42,800 --> 00:46:44,300
0,330 330,420 420,720 720,930
stop and return it.|
|

1930
00:46:45,120 --> 00:46:46,020
0,240 240,420 420,540 540,630 630,900
And, but if we get
但是，如果我们把整个循环都做完，

1931
00:46:46,020 --> 00:46:46,710
0,210 210,270 270,420 420,600 600,690
all the way through the

1932
00:46:46,710 --> 00:46:47,550
0,300 300,390 390,570 570,690 690,840
loop,| it means that we've
|这意味着我们已经将请求发送到每一台服务器，

1933
00:46:47,550 --> 00:46:48,780
0,240 240,360 360,780 780,930 930,1230
sent the request to every

1934
00:46:48,780 --> 00:46:50,460
0,270 270,810 870,1020 1020,1170 1170,1680
single server,| in which case
|在这种情况下，不会再有超时，

1935
00:46:50,460 --> 00:46:51,480
0,240 240,360 360,480 480,780 780,1020
there's no more {timeouts -},|
|

1936
00:46:51,480 --> 00:46:52,170
0,90 90,240 240,360 360,480 480,690
we just have to wait
我们只需要等他们中的一个回来

1937
00:46:52,170 --> 00:46:52,860
0,90 90,330 330,450 450,600 600,690
for one of them to

1938
00:46:52,860 --> 00:46:54,210
0,150 150,600 840,1020 1020,1110 1110,1350
come back| and so that's
|这就是平坦的接收和返回的结尾。

1939
00:46:54,210 --> 00:46:56,190
0,630 660,990 990,1440 1440,1650 1650,1980
the plain receive and return

1940
00:46:56,190 --> 00:46:57,260
0,60 60,210 210,570
at the end.|
|

1941
00:46:58,260 --> 00:46:59,280
0,180 180,390 390,600 600,960 960,1020
And then it's important to
然后需要注意的是，Done通道现在已被缓冲，

1942
00:46:59,280 --> 00:47:01,470
0,360 360,660 780,1230 1230,1470 1470,2190
notice that the done channel

1943
00:47:01,560 --> 00:47:03,570
0,450 450,930 930,1320 1350,1590 1590,2010
is buffered now,| so that
|因此，如果您将结果发送到三个不同的服务器，

1944
00:47:03,660 --> 00:47:05,010
0,360 360,750 750,960 960,1020 1020,1350
if you've sent the result

1945
00:47:05,010 --> 00:47:06,480
0,60 60,270 270,510 510,1170 1200,1470
to three different servers,| you're
|你将接受第一个回答，然后返回，

1946
00:47:06,480 --> 00:47:07,290
0,120 120,180 180,330 330,450 450,810
going to take the first

1947
00:47:07,290 --> 00:47:09,360
0,540 540,780 780,1500 1680,1950 1950,2070
reply and return,| but the
|但其他人会想要将回应发送到。

1948
00:47:09,360 --> 00:47:10,140
0,300 300,360 360,480 480,540 540,780
others are going to want

1949
00:47:10,140 --> 00:47:12,100
0,90 90,360 360,930 930,1500
to send responses to.|
|

1950
00:47:12,100 --> 00:47:12,760
0,120 120,180 180,300 300,450 450,660
And we don't want those
我们不希望这些大猩猩永远坐在那里，试图发送到一个我们没有阅读的频道，

1951
00:47:12,760 --> 00:47:13,870
0,120 120,540 540,720 720,840 840,1110
{goroutines -} just sit around

1952
00:47:13,870 --> 00:47:14,830
0,270 270,510 510,600 600,870 870,960
forever, trying to send to

1953
00:47:14,830 --> 00:47:15,610
0,60 60,360 360,480 480,570 570,780
a channel that we're not

1954
00:47:15,610 --> 00:47:16,900
0,240 240,600 870,1050 1050,1110 1110,1290
reading from,| so we make
|因此，我们将缓冲区设置得足够大，以便它们可以发送到缓冲区，然后离开

1955
00:47:16,900 --> 00:47:17,830
0,90 90,420 420,570 570,810 810,930
the buffer big enough that

1956
00:47:17,830 --> 00:47:18,580
0,90 90,210 210,480 480,660 660,750
they can send into the

1957
00:47:18,580 --> 00:47:20,380
0,570 720,870 870,1050 1050,1170 1170,1800
buffer and then go away|
|

1958
00:47:20,380 --> 00:47:21,310
0,150 150,300 300,630 630,810 810,930
and the channel just gets
而频道只会被垃圾收集。

1959
00:47:21,310 --> 00:47:22,560
0,330 330,690
garbage collected.|
|

1960
00:47:23,930 --> 00:47:24,770
0,210 210,360 360,390 390,750 750,840
We've got a question in
我们在聊天中有一个问题，

1961
00:47:24,770 --> 00:47:28,760
0,90 90,570 570,3420 3420,3810 3810,3990
the chat,| that says, why
|这就是说，为什么计时器不能在没有人引用它的情况下被垃圾收集

1962
00:47:28,760 --> 00:47:29,900
0,210 210,300 300,810 810,1050 1050,1140
can't the timer, just be

1963
00:47:29,900 --> 00:47:31,550
0,330 330,690 690,840 840,1170 1170,1650
garbage collected when nobody's referencing

1964
00:47:31,550 --> 00:47:32,750
0,180 180,450 450,510 510,780 780,1200
it| instead of having to
|而不是在它响起的时候等待

1965
00:47:32,750 --> 00:47:33,710
0,270 270,420 420,570 570,750 750,960
wait when it goes off|
|

1966
00:47:33,710 --> 00:47:34,220
0,120 120,180 180,330 330,420 420,510
when you said that you
当你说如果他在一毫秒内爆炸你会有多个人在等你。

1967
00:47:34,220 --> 00:47:35,540
0,150 150,600 630,1140 1140,1230 1230,1320
have multiple waiting if he

1968
00:47:35,540 --> 00:47:36,860
0,180 180,360 360,450 450,870 870,1320
goes off in one millisecond.|
|

1969
00:47:37,250 --> 00:47:38,390
0,120 120,480 480,600 600,750 750,1140
The problem is that timer
问题是计时器被运行时引用，

1970
00:47:38,390 --> 00:47:41,000
0,420 450,1020 1020,1380 1380,1770 1830,2610
is referenced by the runtime,|
|

1971
00:47:41,030 --> 00:47:41,960
0,240 240,420 420,570 570,840 840,930
it's in the list of
它在活动计时器列表中。

1972
00:47:41,960 --> 00:47:43,340
0,360 360,1080
active timers.|
|

1973
00:47:43,600 --> 00:47:44,740
0,180 180,300 300,600 600,930 930,1140
And so calling stop takes
因此，调用Stop会将其从活动计时器列表中删除。

1974
00:47:44,740 --> 00:47:45,370
0,120 120,270 270,360 360,420 420,630
it out of the list

1975
00:47:45,370 --> 00:47:46,840
0,60 60,330 330,990
of active timers.|
|

1976
00:47:46,840 --> 00:47:48,280
0,390 390,570 570,720 720,1020 1230,1440
And and so like that's
因此，可以说，这是一种工作，

1977
00:47:48,280 --> 00:47:49,570
0,480 480,660 660,750 750,870 870,1290
arguably kind of a work

1978
00:47:49,570 --> 00:47:50,620
0,120 120,420 450,780 780,960 960,1050
in that,| like in the
|就像在定时器的特定情况下，

1979
00:47:50,620 --> 00:47:52,030
0,540 540,840 840,900 900,990 990,1410
specific case of a timer,|
|

1980
00:47:52,030 --> 00:47:53,200
0,180 180,510
that's like
这就像是只有在这种渠道中才会被使用

1981
00:47:53,710 --> 00:47:54,940
0,360 360,570 570,840 840,960 960,1230
only gonna ever get used

1982
00:47:54,940 --> 00:47:56,020
0,90 90,240 240,570 570,810 810,1080
in this channel way| like
|就像我们可以有特殊的情况，通过拥有频道，

1983
00:47:56,020 --> 00:47:56,980
0,90 90,240 240,360 360,690 690,960
we could have special case

1984
00:47:56,980 --> 00:47:58,990
0,210 210,600 870,1410 1410,1560 1560,2010
that by having the channel,|
|

1985
00:47:58,990 --> 00:48:00,010
0,210 210,540 540,600 600,900 900,1020
because inside the timer is
因为计时器里面是这个T.C频道，

1986
00:48:00,010 --> 00:48:01,060
0,150 150,300 300,510 510,690 690,1050
this {t.C - -} channel

1987
00:48:01,060 --> 00:48:02,500
0,390 660,1020 1020,1170 1170,1320 1320,1440
right,| so we could have
|所以我们可以有一种不同类型的通道实现，

1988
00:48:02,500 --> 00:48:03,610
0,210 210,510 510,810 810,1020 1020,1110
like a different kind of

1989
00:48:03,610 --> 00:48:05,830
0,330 330,1260 1410,1620 1620,2100 2100,2220
channel implementation that inside| had
|有一点说，嘿，我是一个定时器频道，对吗？

1990
00:48:05,830 --> 00:48:06,520
0,60 60,240 240,360 360,480 480,690
a bit that said hey

1991
00:48:06,520 --> 00:48:07,810
0,180 180,240 240,540 540,900 900,1290
I'm a timer channel right|
|

1992
00:48:08,080 --> 00:48:09,820
0,390 390,870 960,1200 1200,1380 1380,1740
and and and then like
然后就像它上的SELECT一样，不想只是等待，

1993
00:48:09,820 --> 00:48:11,050
0,150 150,630 630,810 810,930 930,1230
the select on it would

1994
00:48:11,050 --> 00:48:12,250
0,240 240,450 450,570 570,780 780,1200
like no to just wait,|
|

1995
00:48:12,550 --> 00:48:13,360
0,240 240,360 360,480 480,630 630,810
but if you just let
但如果你放手，它就会消失。

1996
00:48:13,360 --> 00:48:13,990
0,180 180,300 300,420 420,510 510,630
go of it, it would

1997
00:48:13,990 --> 00:48:15,360
0,150 150,900
just disappear.|
|

1998
00:48:15,360 --> 00:48:16,560
0,180 180,420 420,750 750,990 990,1200
We've kind of thought about
我们想过这么做有一段时间了，但我们从来没有这样做过，

1999
00:48:16,560 --> 00:48:17,400
0,180 180,390 390,510 510,540 540,840
doing that for a while,

2000
00:48:17,400 --> 00:48:18,810
0,120 120,210 210,450 450,1080 1170,1410
but we never did,| so
|因此，这就像是世界的状况。

2001
00:48:18,810 --> 00:48:19,680
0,240 240,360 360,570 570,660 660,870
this is like the state

2002
00:48:19,680 --> 00:48:20,780
0,60 60,150 150,600
of the world.|
|

2003
00:48:20,810 --> 00:48:21,890
0,330 360,570 570,870 870,960 960,1080
{} But but you know
但是你知道垃圾收集器不能区分

2004
00:48:21,890 --> 00:48:23,270
0,90 90,390 390,660 660,900 900,1380
the garbage collector can't distinguish|
|

2005
00:48:23,270 --> 00:48:25,820
0,720 1560,1770 1770,2160 2160,2460 2460,2550
between the reference inside the
在运行库内部的引用和引用以及程序的其余部分之间，

2006
00:48:25,820 --> 00:48:26,870
0,450 450,540 540,600 600,960 960,1050
runtime and the reference and

2007
00:48:26,870 --> 00:48:27,500
0,60 60,210 210,270 270,330 330,630
the rest of the program,|
|

2008
00:48:27,500 --> 00:48:29,270
0,120 120,270 270,450 450,1230 1560,1770
it's all just references,| and
这些都只是参考，|因此，在我们对该频道进行特殊处理之前，

2009
00:48:29,270 --> 00:48:31,370
0,270 270,810 810,1320 1350,1830 1830,2100
so until we special case

2010
00:48:31,370 --> 00:48:32,600
0,180 180,510 510,600 600,780 780,1230
that channel,| in some way
|在某些方面，我们实际上无法摆脱这一点。

2011
00:48:32,600 --> 00:48:34,310
0,390 390,690 690,1260 1410,1590 1590,1710
we can't actually get rid

2012
00:48:34,310 --> 00:48:35,180
0,60 60,300
of that.|
|

2013
00:48:37,540 --> 00:48:39,460
0,360 360,510 750,1440 1530,1920 1920,1920
Thank you.| Sure, so {},
谢谢。|当然，所以我们剩下的唯一一件事就是

2014
00:48:40,090 --> 00:48:40,810
0,240 240,390 390,540 540,630 630,720
so the only thing we

2015
00:48:40,810 --> 00:48:42,400
0,120 120,480 480,690 690,1200 1350,1590
have left is| to have
|我们尝试使用与上一次相同的id。

2016
00:48:42,400 --> 00:48:43,600
0,180 180,690 690,900 900,1020 1020,1200
this preference where we try

2017
00:48:43,600 --> 00:48:45,190
0,90 90,330 330,420 420,990 990,1590
to use the same id

2018
00:48:45,190 --> 00:48:46,300
0,120 120,240 240,600 600,750 750,1110
that we did the previous

2019
00:48:46,300 --> 00:48:47,140
0,270
time.|
|

2020
00:48:47,390 --> 00:48:48,140
0,210 210,360 360,480 480,570 570,750
And so to do that
因此，为了实现这一偏好，

2021
00:48:48,140 --> 00:48:50,520
0,660
preference,|
|

2022
00:48:50,550 --> 00:48:51,570
0,360 360,510 510,630 630,930 930,1020
we you know had the
我们在结果频道的回复中返回了服务器ID。

2023
00:48:51,570 --> 00:48:52,770
0,300 300,540 540,810 810,1110 1110,1200
server id coming back in

2024
00:48:52,770 --> 00:48:54,000
0,90 90,480 480,990 1020,1170 1170,1230
the reply anyway in the

2025
00:48:54,000 --> 00:48:55,700
0,420 420,900
result channel.|
|

2026
00:48:55,910 --> 00:48:56,990
0,150 150,510 690,840 840,990 990,1080
And so you know we
所以你知道我们做的是同样的循环，

2027
00:48:56,990 --> 00:48:57,830
0,120 120,210 210,450 450,660 660,840
do the same sort of

2028
00:48:57,830 --> 00:48:59,120
0,270 270,390 390,630 660,1050 1050,1290
loop,| but we loop over
|但我们循环实际id的偏移量，

2029
00:48:59,120 --> 00:49:00,290
0,90 90,570 570,720 720,840 840,1170
an offset from the actual

2030
00:49:00,290 --> 00:49:01,190
0,270 270,360 360,480 480,540 540,900
id,| we're going to use
|我们将使用哪个是首选的

2031
00:49:01,190 --> 00:49:02,600
0,180 180,270 270,900 900,1020 1020,1410
which is {} the preferred

2032
00:49:02,600 --> 00:49:04,130
0,330 660,930 930,1260 1260,1350 1350,1530
one| and then we get
|然后我们得到了答案，

2033
00:49:04,130 --> 00:49:06,200
0,90 90,900 960,1530 1650,1980 1980,2070
an answer,| we set the
|我们将首选答案设置为获得答案的位置，然后进行回复

2034
00:49:06,200 --> 00:49:07,220
0,360 360,600 600,720 720,900 900,1020
preferred one to where we

2035
00:49:07,220 --> 00:49:08,240
0,150 150,270 270,510 510,840 870,1020
got the answer from and

2036
00:49:08,240 --> 00:49:09,770
0,150 150,240 240,810 1260,1410 1410,1530
then we reply| and you'll
|你会注意到我用了一个Goto语句，

2037
00:49:09,770 --> 00:49:10,580
0,330 330,480 480,540 540,750 750,810
notice that I used a

2038
00:49:10,580 --> 00:49:12,350
0,300 300,840 930,1200 1200,1650 1650,1770
goto statement,| that's okay if
|如果你需要去的话，没关系，

2039
00:49:12,350 --> 00:49:13,190
0,150 150,300 300,360 360,570 570,840
you need to {goto -}

2040
00:49:13,190 --> 00:49:15,260
0,150 150,540 1290,1560 1560,1890 1890,2070
it's fine,| it's not sort
|这并不是说这里没有[狂热]。

2041
00:49:15,260 --> 00:49:16,520
0,150 180,360 360,450 450,990 990,1260
of there's no [zealotry] here.|
|

2042
00:49:18,070 --> 00:49:20,350
0,570 990,1380 1380,1860 1890,2040 2040,2280
Alright, so, {} the fourth
好，那么，第四个问题，然后我们将做一些问题，是协议多路复用器。

2043
00:49:20,350 --> 00:49:21,790
0,330 660,840 840,1140 1140,1290 1290,1440
one and then we'll do

2044
00:49:21,790 --> 00:49:23,890
0,150 150,780 1200,1680 1680,1950 1950,2100
some questions {} is {}

2045
00:49:23,890 --> 00:49:25,520
0,390 390,1170
protocol multiplexer.|
|

2046
00:49:25,810 --> 00:49:27,400
0,300 300,510 510,810 810,1200 1200,1590
And this is the logic
这是任何RPC系统的核心的逻辑

2047
00:49:27,400 --> 00:49:28,540
0,90 90,420 420,870 870,930 930,1140
of a core of any

2048
00:49:28,540 --> 00:49:30,610
0,120 120,420 420,930 1110,1890 1890,2070
{RPC -} system| and this
|这件事经常被提起，

2049
00:49:30,610 --> 00:49:31,300
0,210 210,300 300,360 360,600 600,690
comes up a lot,| I
|我觉得我在读研究生的时候写了很多这样的东西

2050
00:49:31,300 --> 00:49:31,750
0,120 120,240 240,300 300,450 450,450
feel like I wrote a

2051
00:49:31,750 --> 00:49:32,890
0,240 240,330 330,570 570,900 900,1140
lot of these in grad

2052
00:49:32,890 --> 00:49:34,030
0,270 270,450 450,570 570,900 900,1140
school| and {sort,of} years after
|在那之后的几年里。

2053
00:49:34,030 --> 00:49:34,880
0,240
that.|
|

2054
00:49:35,760 --> 00:49:37,500
0,180 180,510 600,780 780,1140 1140,1740
And so the basic API
因此协议多路复用器的基本API是

2055
00:49:37,500 --> 00:49:39,090
0,240 240,300 300,660 660,1350 1350,1590
of a protocol multiplexer is

2056
00:49:39,090 --> 00:49:40,530
0,270 390,840 840,960 960,1200 1200,1440
that| it's in from some
|它是从某个服务传入的，我们将把它传递给Init方法。

2057
00:49:40,530 --> 00:49:41,580
0,600 600,780 780,870 870,990 990,1050
service, which we're going to

2058
00:49:41,580 --> 00:49:42,900
0,360 360,480 480,600 600,840 840,1320
pass to the Init method.|
|

2059
00:49:43,600 --> 00:49:44,830
0,180 180,270 270,570 570,690 690,1230
And then having been initialized
然后利用该服务进行了初始化，

2060
00:49:44,830 --> 00:49:46,420
0,90 90,180 180,960 1080,1410 1410,1590
with the service,| you can
|您可以拨打电话，也可以拨打电话并向消息发送请求消息

2061
00:49:46,420 --> 00:49:48,370
0,840 1020,1320 1320,1440 1440,1560 1560,1950
call and you can call

2062
00:49:48,370 --> 00:49:49,870
0,570 600,810 810,960 960,1110 1110,1500
Call and give a message

2063
00:49:49,870 --> 00:49:51,460
0,660 660,1020 1020,1350 1350,1470 1470,1590
a request message| and then
|然后它会在某个时候向您返回回复消息

2064
00:49:51,460 --> 00:49:52,510
0,450 450,630 630,720 720,960 960,1050
it'll give you back the

2065
00:49:52,510 --> 00:49:53,740
0,300 300,660 660,720 720,900 900,1230
reply message at some point|
|

2066
00:49:54,100 --> 00:49:55,060
0,180 180,270 270,540 540,660 660,960
and the things it needs
而它需要从服务中获得多路复用功能，即给定一条消息，它必须能够提取唯一标识该消息的标记

2067
00:49:55,060 --> 00:49:56,170
0,180 180,270 270,840 840,960 960,1110
from the service to do

2068
00:49:56,170 --> 00:49:57,560
0,300 300,930
{multiflexing -},

2069
00:49:57,740 --> 00:49:58,940
0,150 150,300 300,510 510,600 600,1200
is that given a message

2070
00:49:58,970 --> 00:49:59,660
0,270 270,390 390,450 450,510 510,690
it has to be able

2071
00:49:59,660 --> 00:50:00,800
0,60 60,300 300,510 510,600 600,1140
to pull out the tag

2072
00:50:00,800 --> 00:50:02,660
0,120 120,510 510,1110 1110,1200 1200,1860
that uniquely identifies the message|
|

2073
00:50:02,960 --> 00:50:04,970
0,570 570,750 750,1230 1230,1560 1560,2010
and will identify the reply,|
并将标识该回复，|

2074
00:50:04,970 --> 00:50:05,660
0,180 180,240 240,330 330,480 480,690
because it will come back
因为它会返回一个匹配的标记

2075
00:50:05,660 --> 00:50:07,100
0,120 120,240 240,540 570,900 900,1440
in with a matching tag|
|

2076
00:50:07,430 --> 00:50:08,000
0,150 150,240 240,330 330,510 510,570
and then it needs to
然后它需要能够发送和接收消息，

2077
00:50:08,000 --> 00:50:08,660
0,60 60,270 270,390 390,600 600,660
be able to send a

2078
00:50:08,660 --> 00:50:10,430
0,300 300,630 960,1170 1170,1290 1290,1770
message out and to receive

2079
00:50:10,430 --> 00:50:12,140
0,390 390,900 900,1200 1230,1440 1440,1710
a message,| but they send
|但它们发送和接收的消息都是任意的，不匹配。

2080
00:50:12,140 --> 00:50:14,360
0,120 120,900 1020,1320 1320,1830 1830,2220
and receive {} are arbitrary

2081
00:50:14,360 --> 00:50:16,120
0,420 420,480 480,690 690,1320
messages are not matched.|
|

2082
00:50:16,680 --> 00:50:18,270
0,210 210,300 300,870 870,1470 1470,1590
It's the multiplex job to
这是一项多路传输工作，实际上是为了匹配它们。

2083
00:50:18,270 --> 00:50:20,520
0,330 330,660 660,810
actually match them.|
|

2084
00:50:21,020 --> 00:50:23,150
0,690 780,1260 1260,1410 1410,1710 1710,2130
So, {} to start with,
因此，首先，我们将有一个Goroutine负责调用Send

2085
00:50:23,180 --> 00:50:24,170
0,180 180,300 300,390 390,540 540,990
we'll have a {goroutine -}

2086
00:50:24,170 --> 00:50:25,250
0,270 270,420 420,720 720,780 780,1080
that's in charge of calling

2087
00:50:25,250 --> 00:50:26,780
0,570 690,870 870,1170 1170,1290 1290,1530
send| and another {goroutine -}
|另一名猩猩负责呼叫接收，

2088
00:50:26,780 --> 00:50:27,650
0,180 180,240 240,510 510,570 570,870
that's in charge of calling

2089
00:50:27,650 --> 00:50:28,790
0,480 480,750 750,840 840,1050 1050,1140
receive,| both in just a
|两者都在一个简单的循环中。

2090
00:50:28,790 --> 00:50:30,020
0,330 330,690
simple loop.|
|

2091
00:50:30,110 --> 00:50:31,010
0,150 150,330 330,450 450,840 840,900
And so to initialize the
因此，初始化服务将设置结构

2092
00:50:31,010 --> 00:50:32,150
0,420 420,540 540,750 750,930 930,1140
service will set up the

2093
00:50:32,210 --> 00:50:33,560
0,720 720,990 990,1080 1080,1170 1170,1350
structure| and it will kick
|它将启动发送循环和接收循环

2094
00:50:33,560 --> 00:50:34,730
0,300 300,450 450,690 690,990 1020,1170
off the send loop and

2095
00:50:34,730 --> 00:50:36,020
0,60 60,390 390,810 930,1200 1200,1290
the receive loop| and then
|然后我们还有一个待处理请求的地图

2096
00:50:36,020 --> 00:50:37,070
0,90 90,390 390,540 540,600 600,1050
we also have a map

2097
00:50:37,070 --> 00:50:38,960
0,210 210,630 630,1410 1650,1830 1830,1890
of pending requests| and the
|以及我们在消息中看到的ID号标签中的地图

2098
00:50:38,960 --> 00:50:41,030
0,1050 1050,1410 1440,1590 1590,1950 1950,2070
maps from the tag that

2099
00:50:41,030 --> 00:50:42,500
0,90 90,660 690,840 840,1110 1110,1470
we saw the id number

2100
00:50:42,500 --> 00:50:44,000
0,90 90,150 150,720 720,1230 1260,1500
in the messages| to a
|发送到一个频道，该频道应该会收到回复。

2101
00:50:44,000 --> 00:50:45,260
0,360 360,600 600,720 720,1080 1080,1260
channel where the reply is

2102
00:50:45,260 --> 00:50:46,460
0,360 360,420 420,810
supposed to go.|
|

2103
00:50:47,960 --> 00:50:49,370
0,240 240,420 420,720 750,1050 1050,1410
The send loop is fairly
发送循环相当简单，

2104
00:50:49,370 --> 00:50:50,600
0,330 330,480 480,720 720,1020 1020,1230
simple,| you just range over
|您只需查看需要发送的内容，然后将它们发送出去

2105
00:50:50,600 --> 00:50:51,410
0,150 150,390 390,570 570,750 750,810
the things that need to

2106
00:50:51,410 --> 00:50:52,220
0,90 90,390 390,510 510,570 570,810
be sent and you send

2107
00:50:52,220 --> 00:50:53,390
0,330 420,630 630,810 810,990 990,1170
them| and this just has
|这只会产生串行化要发送的调用的效果，

2108
00:50:53,390 --> 00:50:54,590
0,90 90,420 420,510 510,930 930,1200
the effect of {serializing -}

2109
00:50:54,590 --> 00:50:55,790
0,90 90,390 390,480 480,900 900,1200
the calls to send,| because
|因为我们不会强制服务实现同时处理从多个Goroutine发送的内容，

2110
00:50:55,790 --> 00:50:57,050
0,120 120,360 360,480 480,570 570,1260
we're not going to force

2111
00:50:57,080 --> 00:50:59,900
0,210 210,630 630,1470 1710,2280 2310,2820
the service implementation to deal

2112
00:50:59,900 --> 00:51:01,190
0,120 120,450 450,1050 1050,1140 1140,1290
with us sending you know

2113
00:51:01,190 --> 00:51:02,510
0,150 150,480 480,900 900,1020 1020,1320
from multiple goroutines at once,|
|

2114
00:51:02,510 --> 00:51:03,530
0,90 90,510 510,750 750,900 900,1020
we're {serializing -} it, so
我们正在序列化它，这样它就可以认为您一次只发送一个包。

2115
00:51:03,530 --> 00:51:04,280
0,120 120,240 240,330 330,510 510,750
that it can just be

2116
00:51:04,280 --> 00:51:06,260
0,300 300,540 720,1020 1020,1350 1350,1980
thinking of you sending one

2117
00:51:06,260 --> 00:51:07,580
0,360 360,480 480,510 510,900
packet at a time.|
|

2118
00:51:09,200 --> 00:51:10,430
0,180 180,300 300,390 390,810 810,1230
And then the receive loop
然后接收循环稍微复杂一点，

2119
00:51:10,730 --> 00:51:11,720
0,480 480,630 630,720 720,870 870,990
{} is a little bit

2120
00:51:11,720 --> 00:51:14,030
0,120 120,720 720,840 840,1170 1170,2310
more complicated,| it pulls a
|它从服务中拉出一个回复

2121
00:51:14,030 --> 00:51:15,800
0,420 420,690 690,990 1050,1650 1650,1770
reply off the service| and
|同样，它们被序列化，或者一次只读一个

2122
00:51:15,800 --> 00:51:17,510
0,540 570,840 840,1470 1470,1530 1530,1710
again they're serialized or only

2123
00:51:17,510 --> 00:51:18,770
0,240 240,510 510,630 630,690 690,1260
reading one at a time|
|

2124
00:51:19,040 --> 00:51:19,730
0,210 210,300 300,360 360,600 600,690
and then it pulls the
然后它从回复中取出标签。

2125
00:51:19,730 --> 00:51:21,230
0,450 450,660 660,750 750,840 840,1500
tag out of the reply.|
|

2126
00:51:22,040 --> 00:51:23,030
0,150 150,270 270,390 390,720 720,990
And then it says oh
然后它说，哦，我需要找到发送这个信息的渠道，

2127
00:51:23,030 --> 00:51:23,780
0,90 90,270 270,360 360,690 690,750
I need to find the

2128
00:51:23,780 --> 00:51:25,100
0,360 360,480 480,780 780,960 960,1320
channel to send this to,|
|

2129
00:51:25,520 --> 00:51:26,330
0,270 270,420 420,510 510,720 720,810
{} so it pulls the
因此它将频道从挂起的映射中拉出，

2130
00:51:26,330 --> 00:51:27,200
0,300 300,420 420,480 480,570 570,870
channel out of the pending

2131
00:51:27,200 --> 00:51:28,790
0,510 780,990 990,1230 1230,1380 1380,1590
map,| it takes it out
|它把它从悬而未决的地图中拿出来，

2132
00:51:28,790 --> 00:51:29,720
0,90 90,180 180,450 450,750 750,930
of the pending map,| so
|这样你就知道如果我们意外地得到了另一个，

2133
00:51:29,720 --> 00:51:30,470
0,270 270,360 360,480 480,600 600,750
that you know if we

2134
00:51:30,470 --> 00:51:32,000
0,690 690,840 840,1110 1110,1440 1440,1530
accidentally get another one,| we
|我们不会尝试发送它。

2135
00:51:32,000 --> 00:51:32,900
0,180 180,330 330,420 420,720 720,900
won't try to send it.|
|

2136
00:51:33,640 --> 00:51:34,330
0,150 150,270 270,360 360,600 600,690
And then it sends the
然后它会发送回复。

2137
00:51:34,330 --> 00:51:35,620
0,720
reply.|
|

2138
00:51:36,190 --> 00:51:37,120
0,420 420,600 600,720 720,810 810,930
{} And then to do
然后再打个电话，

2139
00:51:37,120 --> 00:51:38,590
0,90 90,840 990,1170 1170,1290 1290,1470
a call,| you just have
|你只需要在地图上设置好自己，

2140
00:51:38,590 --> 00:51:39,640
0,240 270,540 540,840 840,990 990,1050
to set yourself up in

2141
00:51:39,640 --> 00:51:40,690
0,90 90,570 570,690 690,840 840,1050
the map,| and then hand
|然后递给我发送并等待回复，

2142
00:51:40,690 --> 00:51:41,710
0,90 90,180 180,690 690,810 810,1020
it to send and wait

2143
00:51:41,710 --> 00:51:43,720
0,90 90,180 180,750 780,1410 1740,2010
for the reply,| so we
|所以我们开始，把标签拿出来，

2144
00:51:43,720 --> 00:51:44,470
0,240 240,450 450,510 510,690 690,750
start off, we get the

2145
00:51:44,470 --> 00:51:46,240
0,360 360,750 1170,1350 1350,1560 1560,1770
tag out,| {} we make
|我们制作自己的Done频道，

2146
00:51:46,240 --> 00:51:48,010
0,120 120,270 270,450 450,1170 1440,1770
our own done channel,| we
|我们将标签插入地图，

2147
00:51:48,010 --> 00:51:49,240
0,480 480,540 540,930 930,1110 1110,1230
insert the tag into the

2148
00:51:49,240 --> 00:51:50,740
0,420 450,780 780,1020 1020,1380 1380,1500
map,| after first checking for
|在第一次检查错误之后。

2149
00:51:50,740 --> 00:51:51,760
0,720
bugs.|
|

2150
00:51:51,790 --> 00:51:53,060
0,210 210,750
And then,
然后，我们发送要发送的参数消息

2151
00:51:53,060 --> 00:51:54,830
0,180 180,510 510,960 960,1380 1380,1770
we send the argument message

2152
00:51:54,830 --> 00:51:56,000
0,150 150,690 810,960 960,1050 1050,1170
to Send| and then we
|然后我们等待完成后的回复，

2153
00:51:56,000 --> 00:51:56,810
0,240 240,330 330,420 420,720 720,810
wait for the reply to

2154
00:51:56,810 --> 00:51:57,950
0,210 210,300 300,480 480,840 900,1140
come in on done,| it's
|这非常非常简单，

2155
00:51:57,950 --> 00:51:59,300
0,390 390,630 630,960 960,1050 1050,1350
very very simple,| I mean
|我是说，就像我以前用C语言写这些东西一样

2156
00:51:59,300 --> 00:52:00,320
0,300 450,600 600,750 750,840 840,1020
like I used to write

2157
00:52:00,320 --> 00:52:01,010
0,150 150,330 330,390 390,570 570,690
these sort of things in

2158
00:52:01,010 --> 00:52:01,880
0,330 330,420 420,510 510,780 780,870
C| and it was it
|而且情况要糟糕得多。

2159
00:52:01,880 --> 00:52:04,440
0,180 180,480 480,720 720,1290
was much much worse.|
|

2160
00:52:04,900 --> 00:52:06,250
0,660 840,1050 1050,1170 1170,1260 1260,1350
So that was all the
这就是我想展示的所有模式

2161
00:52:06,250 --> 00:52:07,240
0,450 450,570 570,630 630,900 900,990
patterns that I wanted to

2162
00:52:07,240 --> 00:52:09,520
0,570 900,1740 1770,1980 1980,2190 2190,2280
show| and I hope that
|我希望这些东西最终会对您在未来编写的程序有所帮助

2163
00:52:09,520 --> 00:52:10,510
0,210 210,360 360,450 450,630 630,990
those end up being useful

2164
00:52:10,510 --> 00:52:12,130
0,120 120,360 360,750 750,1260 1260,1620
for you in whatever future

2165
00:52:12,130 --> 00:52:13,990
0,300 300,420 420,930 1290,1710 1710,1860
program yo're writing| and I
|我希望它们是好主意，即使是在非围棋项目中，

2166
00:52:13,990 --> 00:52:15,310
0,210 210,330 330,780 810,900 900,1320
hope that they're you know

2167
00:52:15,840 --> 00:52:17,190
0,210 210,390 390,600 600,810 810,1350
just sort of good ideas,

2168
00:52:17,190 --> 00:52:18,750
0,240 240,420 420,750 750,900 900,1560
even in non Go programs,|
|

2169
00:52:18,750 --> 00:52:19,800
0,180 180,420 420,510 510,750 750,1050
but that you know thinking
但你知道，想着他们

2170
00:52:19,800 --> 00:52:20,610
0,210 210,300 300,420 420,660 660,810
about them| and Go can
|当你去做其他事情的时候，围棋也可以帮助你。

2171
00:52:20,610 --> 00:52:21,420
0,210 210,360 360,480 480,660 660,810
help you when you go

2172
00:52:21,420 --> 00:52:22,290
0,90 90,240 240,420 420,720 720,870
to do other things as

2173
00:52:22,290 --> 00:52:23,640
0,300 840,1050 1050,1170 1170,1290 1290,1350
well.| So I'm going to
|所以我要把它们都放回去。

2174
00:52:23,640 --> 00:52:24,720
0,120 120,210 210,330 330,570 570,1080
put them all back up.|
|

2175
00:52:24,900 --> 00:52:26,400
0,210 210,1050 1080,1230 1230,1380 1380,1500
And then I have some
然后我有一些弗兰斯寄来的问题，是你们所有人发来的。

2176
00:52:26,400 --> 00:52:27,780
0,450 450,600 600,990 990,1200 1200,1380
questions that Frans sent, that

2177
00:52:27,780 --> 00:52:29,010
0,420 420,600 600,720 720,810 810,1230
were from all of you.|
|

2178
00:52:30,350 --> 00:52:31,580
0,360 360,660 660,810 810,1080 1080,1230
And, {} we'll probably have
而且，我们可能还会有一些时间来回答聊天中的问题。

2179
00:52:31,580 --> 00:52:33,920
0,150 150,420 420,1200 1350,2010 2010,2340
some time for questions from

2180
00:52:33,920 --> 00:52:35,580
0,270 270,540 540,660 660,1110
the chat as well.|
|

2181
00:52:35,640 --> 00:52:36,720
0,150 150,300 300,510 510,900 900,1080
I have no idea in
我不知道在缩放中聊天窗口在哪里，

2182
00:52:36,720 --> 00:52:38,040
0,300 300,540 540,630 630,1020 1020,1320
zoom where the chat window

2183
00:52:38,040 --> 00:52:39,630
0,240 240,750 1140,1350 1350,1440 1440,1590
is,| so when we get
|所以当我们谈到这一点时，人们可以大声疾呼，

2184
00:52:39,630 --> 00:52:40,440
0,90 90,300 300,540 540,660 660,810
to that, people can just

2185
00:52:40,440 --> 00:52:43,230
0,270 270,1320 1320,1800 2130,2610 2610,2790
speak up,| just I don't
|不幸的是，我不是每天都使用变焦。

2186
00:52:43,230 --> 00:52:44,010
0,150 150,360 360,480 480,540 540,780
use zoom on a daily

2187
00:52:44,010 --> 00:52:46,060
0,390 390,1440
basis, unfortunately.|
|

2188
00:52:46,150 --> 00:52:48,310
0,360 360,900 1050,1530 1530,1740 1740,2160
So, {} and and normally
所以，正常情况下，我知道如何经常使用变焦，

2189
00:52:48,310 --> 00:52:48,850
0,90 90,180 180,270 270,360 360,540
I know how to use

2190
00:52:48,850 --> 00:52:50,320
0,420 420,810 810,1020 1020,1290 1290,1470
zoom regularly,| but with with
|但随着演示的进行，它是放大这个最小化的东西，它没有我习惯的一半的东西。

2191
00:52:50,320 --> 00:52:51,850
0,120 120,720 720,960 960,1380 1380,1530
the presentation, it's zooms in

2192
00:52:51,850 --> 00:52:53,260
0,150 150,690 690,900 900,1110 1110,1410
this minimized thing, that doesn't

2193
00:52:53,260 --> 00:52:54,010
0,120 120,360 360,450 450,660 660,750
have half the things I'm

2194
00:52:54,010 --> 00:52:56,710
0,180 180,300 900,1470 1770,2340 2370,2700
used to.| Anyway, {} someone
|不管怎样，有人问我去花了多长时间。

2195
00:52:56,710 --> 00:52:57,790
0,210 210,330 330,540 540,660 660,1080
asked how long Go took.|
|

2196
00:52:57,970 --> 00:52:59,350
0,570 600,840 840,1110 1110,1260 1260,1380
And so far it's been
到目前为止，它已经大约13年半了，

2197
00:52:59,350 --> 00:53:00,280
0,270 270,600 600,690 690,720 720,930
about thirteen and a half

2198
00:53:00,280 --> 00:53:02,590
0,600 900,1110 1110,1530 1530,2130 2130,2310
years,| we started discussions in
|我们从2007年9月下旬开始讨论，

2199
00:53:02,590 --> 00:53:04,870
0,360 360,870 870,1290 1290,1920 2070,2280
late september {2007 -},| I
|2008年8月，当我在麻省理工学院毕业时，我加入了全职工作。

2200
00:53:04,870 --> 00:53:06,130
0,360 360,540 540,840 840,930 930,1260
joined full {time,in -} august

2201
00:53:06,130 --> 00:53:07,930
0,420 420,720 720,780 780,1170 1170,1800
2008 when I {finished,at} MIT.|
|

2202
00:53:08,530 --> 00:53:10,120
0,360 360,540 540,750 750,1110 1110,1590
We did the initial open-source
2009年11月，我们进行了最初的开源发布。

2203
00:53:10,120 --> 00:53:12,380
0,390 390,810 810,1170 1170,1680
launch november {2009 -}.|
|

2204
00:53:12,380 --> 00:53:13,970
0,510 540,720 720,1050 1050,1170 1170,1590
{} We released Go one
我们在2011年10月发布了Go One的第一个稳定版本，

2205
00:53:13,970 --> 00:53:14,990
0,150 150,330 330,390 390,660 660,1020
the sort of first stable

2206
00:53:14,990 --> 00:53:18,170
0,390 390,510 510,900 900,2760 2790,3180
version in October 2011,| sorry
|对不起，计划是2011年10月，Go One本身是2012年3月。

2207
00:53:18,170 --> 00:53:19,550
0,90 90,360 360,480 480,810 810,1380
the plan was October 2011,

2208
00:53:19,550 --> 00:53:20,810
0,180 180,570 570,720 720,990 990,1260
{Go,one} itself was march {2012

2209
00:53:20,810 --> 00:53:21,840
0,540
-}.|
|

2210
00:53:22,180 --> 00:53:23,080
0,210 210,390 390,510 510,720 720,900
And then we've just been
从那时起，我们就一直按照常规的日程安排，

2211
00:53:23,080 --> 00:53:24,910
0,600 630,780 780,1170 1170,1560 1560,1830
on a regular schedule since

2212
00:53:24,910 --> 00:53:26,680
0,300 540,810 810,1020 1020,1410 1410,1770
then,| the next major change
|当然，下一个重大变化将是仿制药

2213
00:53:26,680 --> 00:53:27,730
0,90 90,420 420,870 870,990 990,1050
of course is going to

2214
00:53:27,730 --> 00:53:30,370
0,120 120,810 1110,1950 1950,2190 2190,2640
be generics| and adding generics
|加上仿制药，可能会是18%，

2215
00:53:30,370 --> 00:53:31,660
0,120 120,330 330,960 960,1140 1140,1290
and that's probably gonna be

2216
00:53:31,660 --> 00:53:33,160
0,150 150,360 360,1080 1080,1380 1380,1500
go one eighteen,| which is
|这将是下一次在2月份。

2217
00:53:33,160 --> 00:53:34,180
0,270 270,330 330,480 480,870 870,1020
going to be next in

2218
00:53:34,180 --> 00:53:35,240
0,570
February.|
|

2219
00:53:37,260 --> 00:53:38,670
0,540 540,960 960,1050 1050,1290 1290,1410
Someone asks you how big
有人问你，构建一门像Go这样的语言需要多大的团队。

2220
00:53:38,670 --> 00:53:39,510
0,90 90,330 330,480 480,570 570,840
a team does it take

2221
00:53:39,510 --> 00:53:40,830
0,90 90,630 660,810 810,1140 1140,1320
to build a language like

2222
00:53:40,830 --> 00:53:42,330
0,480 480,990 1140,1260 1260,1350 1350,1500
Go.| And you know for
|你知道在最初的两年里，我们只有五个人

2223
00:53:42,330 --> 00:53:43,650
0,180 180,450 450,570 570,1170 1170,1320
those first two years, there

2224
00:53:43,650 --> 00:53:44,850
0,120 120,300 300,570 570,690 690,1200
were just five of us|
|

2225
00:53:45,090 --> 00:53:46,380
0,510 510,660 660,810 810,1170 1170,1290
and that was enough to
这足以让我们

2226
00:53:46,380 --> 00:53:48,000
0,240 240,450 450,840 840,1470 1500,1620
get us to| {} you
|你知道，我们发布的一些东西实际上可以在生产中运行。

2227
00:53:48,000 --> 00:53:49,200
0,180 180,510 510,600 600,750 750,1200
know something that we release

2228
00:53:49,200 --> 00:53:50,370
0,150 150,600 600,810 810,1050 1050,1170
that actually could run in

2229
00:53:50,370 --> 00:53:51,560
0,750
production.|
|

2230
00:53:51,710 --> 00:53:53,060
0,210 210,270 270,420 420,780 780,1350
But it was fairly primitive,|
但它相当原始，|

2231
00:53:53,090 --> 00:53:54,710
0,480 750,1020 1020,1140 1140,1500 1500,1620
{} you know it was
你知道这是一个很好的原型，它是一个可靠的工作原型，

2232
00:53:54,710 --> 00:53:55,730
0,90 90,300 300,840 840,900 900,1020
a good prototype, it was

2233
00:53:55,730 --> 00:53:57,110
0,60 60,390 390,690 690,1200 1200,1380
a solid working prototype,| but
|但它不像今天这样

2234
00:53:57,110 --> 00:53:58,460
0,330 330,690 690,990 1050,1230 1230,1350
it wasn't like what it

2235
00:53:58,460 --> 00:54:00,260
0,150 150,660 1200,1350 1350,1530 1530,1800
is today| and over time
|随着时间的推移，我们已经扩大了相当多的规模，

2236
00:54:00,260 --> 00:54:01,490
0,120 120,630 630,720 720,900 900,1230
we've expanded a fair amount,|
|

2237
00:54:01,490 --> 00:54:02,390
0,180 180,330 330,480 480,600 600,900
now we're up to something
现在我们直接雇佣了大约50人，受雇于谷歌，直接在Go上工作。

2238
00:54:02,390 --> 00:54:04,880
0,210 210,510 510,1110 1260,1830 1830,2490
like fifty people employed directly,

2239
00:54:04,910 --> 00:54:06,080
0,570 570,690 690,930 930,990 990,1170
employed by Google to work

2240
00:54:06,080 --> 00:54:07,540
0,360 360,540 540,990
directly on Go.|
|

2241
00:54:07,950 --> 00:54:09,120
0,150 150,270 270,540 540,1050 1050,1170
And then there's tons of
然后有大量的开源贡献者，

2242
00:54:09,120 --> 00:54:10,350
0,210 210,450 450,1020 1020,1050 1050,1230
open source contributors,| I mean
|我是说，在过去的13年里，有成千上万的演员帮助了我们

2243
00:54:10,350 --> 00:54:12,030
0,210 210,660 660,1020 1020,1110 1110,1680
there's literal cast of thousands

2244
00:54:12,030 --> 00:54:12,870
0,120 120,210 210,480 480,690 690,840
that have helped us over

2245
00:54:12,870 --> 00:54:14,550
0,60 60,300 300,630 630,1050 1320,1680
the last thirteen years| and
|即使有50个人，我们也绝对不可能做到，

2246
00:54:14,550 --> 00:54:15,570
0,210 210,600 600,720 720,930 930,1020
there's absolutely no way we

2247
00:54:15,570 --> 00:54:16,200
0,120 120,210 210,390 390,480 480,630
could have done it even

2248
00:54:16,200 --> 00:54:17,850
0,150 150,420 420,900 1020,1500 1500,1650
with fifty people,| without all
|没有来自外部的所有不同的贡献。

2249
00:54:17,850 --> 00:54:19,830
0,90 90,540 540,1320 1680,1860 1860,1980
the different contributions from the

2250
00:54:19,830 --> 00:54:20,880
0,480
outside.|
|

2251
00:54:22,800 --> 00:54:24,900
0,660 870,1170 1170,1380 1380,1740 1740,2100
{} Someone asked about design
有人问到了设计的优先顺序和动机。

2252
00:54:24,900 --> 00:54:28,710
0,930 1230,2190 2190,3120 3420,3750 3750,3810
priorities and motivations.| And you
|你知道我们是为自己建造的，

2253
00:54:28,710 --> 00:54:30,480
0,450 870,1290 1290,1530 1530,1620 1620,1770
know we built it for

2254
00:54:30,480 --> 00:54:31,620
0,270 270,450 450,540 540,990 990,1140
us right,| the priority was
|当务之急是建立一些对谷歌有帮助的东西

2255
00:54:31,620 --> 00:54:33,120
0,90 90,300 300,900 900,1230 1260,1500
to build something that was

2256
00:54:33,120 --> 00:54:33,960
0,120 120,180 180,360 360,750 750,840
going to help Google| and
|事实证明，谷歌领先了几年，

2257
00:54:33,960 --> 00:54:34,590
0,90 90,240 240,420 420,540 540,630
it just turned out that

2258
00:54:34,590 --> 00:54:35,670
0,240 240,390 390,600 600,870 870,1080
Google was a couple years

2259
00:54:35,670 --> 00:54:36,420
0,330 330,420 420,510 510,660 660,750
ahead,| we were just in
|我们只是处在一个非常幸运的位置，谷歌领先行业其他公司几年，

2260
00:54:36,420 --> 00:54:37,590
0,90 90,270 270,630 630,1020 1020,1170
a really lucky spot where

2261
00:54:37,590 --> 00:54:38,580
0,300 300,450 450,510 510,780 780,990
Google was a couple years

2262
00:54:38,580 --> 00:54:39,240
0,240 240,300 300,390 390,600 600,660
ahead of the rest of

2263
00:54:39,240 --> 00:54:41,100
0,60 60,660 840,1380 1470,1770 1770,1860
the industry,| on having to
|关于现在必须编写分布式系统，

2264
00:54:41,100 --> 00:54:42,870
0,390 570,1020 1020,1410 1410,1590 1590,1770
write distributed systems right now,|
|

2265
00:54:42,870 --> 00:54:45,240
0,390 390,930 960,1500 1500,2040 2040,2370
everyone using cloud software is
每个使用云软件的人都在编写与其他程序对话并发送消息的程序

2266
00:54:45,240 --> 00:54:46,380
0,270 270,720 720,810 810,1050 1050,1140
writing programs that talk to

2267
00:54:46,380 --> 00:54:48,030
0,210 210,750 750,870 870,1080 1080,1650
other programs and sending messages|
|

2268
00:54:48,030 --> 00:54:49,590
0,270 300,390 390,480 480,1020 1050,1560
and you know there's hardly
你知道，现在几乎没有单一的机器程序了。

2269
00:54:49,590 --> 00:54:51,900
0,180 180,780 810,1320 1320,1770 1770,2310
any single machine programs anymore.|
|

2270
00:54:52,610 --> 00:54:54,080
0,150 150,480 660,900 900,1110 1110,1470
And so you know we
所以你知道我们在某种程度上被锁定了

2271
00:54:54,080 --> 00:54:55,340
0,210 210,300 300,570 570,1110 1110,1260
sort of locked into at

2272
00:54:55,340 --> 00:54:57,530
0,210 210,720 840,1170 1170,1380 1410,2190
some level| you know building
|你知道，打造我们世界其他地方几年后需要的语言。

2273
00:54:57,590 --> 00:54:58,910
0,180 180,630 630,750 750,1080 1080,1320
the language that we the

2274
00:54:58,910 --> 00:54:59,630
0,150 150,210 210,270 270,480 480,720
rest of the world needed

2275
00:54:59,630 --> 00:55:01,120
0,60 60,330 330,570 570,930
a couple years later.|
|

2276
00:55:01,740 --> 00:55:02,790
0,270 270,480 480,600 600,810 810,1050
And then the other thing
然后是另一件真正优先考虑的事情

2277
00:55:02,790 --> 00:55:04,140
0,540 540,720 720,930 930,990 990,1350
that was really a priority|
|

2278
00:55:04,140 --> 00:55:05,220
0,150 150,390 390,540 540,840 840,1080
was making it work for
是让它为大量程序员工作

2279
00:55:05,220 --> 00:55:07,410
0,420 420,660 660,720 720,1530 1920,2190
large numbers of programmers| and
|因为谷歌有大量的程序员在一个代码库中工作

2280
00:55:07,410 --> 00:55:08,820
0,480 480,840 840,990 990,1230 1230,1410
because Google had a very

2281
00:55:08,820 --> 00:55:10,110
0,240 240,420 420,510 510,1020 1020,1290
large number of programmers working

2282
00:55:10,110 --> 00:55:12,240
0,90 90,300 300,1170 1410,1920 1920,2130
in one codebase| and now
|现在我们有了开放源码

2283
00:55:12,240 --> 00:55:13,320
0,120 120,330 330,540 540,870 870,1080
we have open source| where
|你知道，即使你是一个小团队，

2284
00:55:13,320 --> 00:55:14,340
0,210 210,300 300,540 540,630 630,1020
you know even if you're

2285
00:55:14,340 --> 00:55:15,960
0,90 90,450 450,960 990,1230 1230,1620
a small team,| you're depending
|您通常依赖于由大量其他人编写的代码。

2286
00:55:15,960 --> 00:55:16,830
0,150 150,390 390,570 570,750 750,870
on code that's written by

2287
00:55:16,830 --> 00:55:17,910
0,120 120,450 450,540 540,750 750,1080
a ton of other people

2288
00:55:17,910 --> 00:55:18,960
0,570
usually.|
|

2289
00:55:19,110 --> 00:55:20,070
0,150 150,270 270,330 330,540 540,960
And so a lot of
因此，在这种情况下，仅仅是让许多程序员出现的许多问题仍然会出现，

2290
00:55:20,130 --> 00:55:21,480
0,300 300,720 720,840 840,1020 1020,1350
the issues that come up

2291
00:55:21,510 --> 00:55:22,980
0,330 330,510 510,720 720,960 960,1470
with just having many programmers

2292
00:55:22,980 --> 00:55:23,730
0,210 210,330 330,510 510,570 570,750
still come up in that

2293
00:55:23,730 --> 00:55:25,830
0,720 1110,1350 1350,1740 1740,1890 1890,2100
context,| so those were really
|因此，这些都是我们试图解决的问题。

2294
00:55:25,830 --> 00:55:26,670
0,150 150,390 390,480 480,570 570,840
the things we were trying

2295
00:55:26,670 --> 00:55:27,740
0,90 90,600
to solve.|
|

2296
00:55:28,090 --> 00:55:29,740
0,420 990,1080 1080,1290 1290,1470 1470,1650
And you know for all
你知道，对于所有这些事情，我们花了很长时间

2297
00:55:29,740 --> 00:55:30,700
0,60 60,210 210,420 420,750 750,960
of these things we took

2298
00:55:30,700 --> 00:55:32,410
0,60 60,360 360,870 960,1440 1440,1710
a long time| before we
|在我们愿意真正致力于把一些东西放在语言中之前

2299
00:55:32,440 --> 00:55:33,790
0,180 180,480 480,630 630,990 990,1350
were willing to actually commit

2300
00:55:33,790 --> 00:55:34,870
0,360 390,630 630,930 930,990 990,1080
to putting something in the

2301
00:55:34,870 --> 00:55:36,340
0,450 450,600 600,930 930,1290 1290,1470
language| like everyone basically had
|就像每个人基本上不得不在核心原创小组中达成一致

2302
00:55:36,340 --> 00:55:37,840
0,90 90,600 600,960 990,1110 1110,1500
to agree in the core

2303
00:55:37,840 --> 00:55:40,030
0,360 360,780 1020,1710 1860,2070 2070,2190
original group| and and so
|这意味着我们花了一段时间才得到我们想要的碎片，

2304
00:55:40,030 --> 00:55:41,650
0,180 180,390 390,750 1260,1440 1440,1620
that meant that it took

2305
00:55:41,650 --> 00:55:42,790
0,90 90,180 180,570 570,870 900,1140
us a while to get

2306
00:55:42,790 --> 00:55:43,930
0,90 90,450 450,930 930,1020 1020,1140
the pieces exactly the way

2307
00:55:43,930 --> 00:55:45,010
0,120 120,420 420,570 570,870 870,1080
we wanted them,| but once
|但一旦我们把他们送到那里，他们实际上非常稳定、坚实，真的很好，他们合作得很好。

2308
00:55:45,010 --> 00:55:46,180
0,90 90,360 360,480 480,750 750,1170
we got them there, they've

2309
00:55:46,180 --> 00:55:47,800
0,330 330,510 510,810 810,1260 1260,1620
actually been very stable and

2310
00:55:47,800 --> 00:55:49,480
0,420 420,960 1020,1290 1290,1560 1560,1680
solid and really nice and

2311
00:55:49,480 --> 00:55:50,980
0,60 60,300 300,660 660,1110
they work together well.|
|

2312
00:55:50,980 --> 00:55:51,940
0,360 360,450 450,690 690,840 840,960
And the same thing is
同样的事情现在也发生在仿制药上，

2313
00:55:51,940 --> 00:55:53,080
0,180 180,240 240,570 570,690 690,1140
kind of happening with generics

2314
00:55:53,080 --> 00:55:55,240
0,420 660,1200 1350,1530 1530,1800 1800,2160
now,| where we actually feel
|我个人对仿制药的感觉真的很好，

2315
00:55:55,270 --> 00:55:56,680
0,180 180,420 420,810 810,1230 1230,1410
I feel personally really good

2316
00:55:56,680 --> 00:55:57,880
0,240 240,660 660,750 750,900 900,1200
about generics,| I feel like
|我感觉就像是围棋的其余部分，

2317
00:55:57,910 --> 00:55:59,560
0,480 480,990 990,1290 1290,1380 1380,1650
it feels like the rest

2318
00:55:59,560 --> 00:56:00,820
0,90 90,540 540,930 930,1080 1080,1260
of Go,| and that just
|但我们收到的提案却并非如此，

2319
00:56:00,820 --> 00:56:01,660
0,240 240,300 300,630 630,750 750,840
wasn't the case for the

2320
00:56:01,660 --> 00:56:03,040
0,510 510,630 630,750 750,1230 1260,1380
proposals that we had,| you
|你知道，即使在几年前，

2321
00:56:03,040 --> 00:56:04,090
0,240 270,510 510,570 570,840 840,1050
know even a couple years

2322
00:56:04,090 --> 00:56:05,980
0,390 450,930 930,1230 1230,1470 1470,1890
ago,| much less the early
|更不用说早期的那些了。

2323
00:56:05,980 --> 00:56:06,860
0,510
ones.|
|

2324
00:56:08,860 --> 00:56:10,570
0,600 630,960 960,1170 1170,1500 1500,1710
{} Someone said they really
有人说他们真的很喜欢延期，这是语言中独有的，

2325
00:56:10,570 --> 00:56:11,920
0,300 300,750 780,1050 1050,1260 1260,1350
liked defer, {} which is

2326
00:56:11,920 --> 00:56:13,300
0,330 330,720 720,1140 1140,1230 1230,1380
{unique,to} language,| and I do
|我也是，谢谢你，

2327
00:56:13,300 --> 00:56:15,250
0,360 390,630 630,900 1290,1890 1890,1950
too, thank you,| but I
|但我想指出的是，我们确实为围棋创造了延期，

2328
00:56:15,250 --> 00:56:16,390
0,150 150,210 210,390 390,570 570,1140
wanted to point out that

2329
00:56:16,390 --> 00:56:18,370
0,450 450,660 660,1410 1410,1530 1530,1980
we did absolutely {you,know} create

2330
00:56:18,370 --> 00:56:20,680
0,330 330,480 480,930 1020,1860 1890,2310
defer for Go,| but Swift
|但斯威夫特已经采用了它

2331
00:56:20,680 --> 00:56:21,610
0,120 120,570 570,750 750,840 840,930
has adopted it| and I
|我认为C++也有一个采用它的建议，

2332
00:56:21,610 --> 00:56:22,780
0,180 180,390 390,600 600,1050 1050,1170
think there's a proposal for

2333
00:56:22,780 --> 00:56:23,740
0,180 180,300 300,540 540,630 630,960
{C++ - -} to adopt

2334
00:56:23,740 --> 00:56:24,640
0,60 60,210 210,480 480,780 780,900
it as well,| so you
|所以你知道，希望它能稍微走出去一点。

2335
00:56:24,640 --> 00:56:25,600
0,60 60,480 480,570 570,720 720,960
know hopefully it kind of

2336
00:56:25,810 --> 00:56:26,830
0,360 360,540 540,570 570,780 780,1020
moves out a little bit.|
|

2337
00:56:29,280 --> 00:56:30,510
0,150 150,270 270,300 300,690 690,1230
There was a question about
有一个问题是关于围棋是用大写来出口的。

2338
00:56:30,540 --> 00:56:33,120
0,540 750,1380 1380,1620 1620,2400 2400,2580
{} {Go,is} using capitalization for

2339
00:56:33,120 --> 00:56:34,830
0,660 1050,1290 1290,1440 1440,1500 1500,1710
exporting.| And which I know
|我知道这就像是当你第一次看到它的时候，你知道的有点刺耳

2340
00:56:34,830 --> 00:56:36,450
0,150 150,450 450,810 810,1110 1110,1620
is like something that {}

2341
00:56:36,750 --> 00:56:38,010
0,150 150,450 750,1050 1050,1140 1140,1260
you know sort of is

2342
00:56:38,010 --> 00:56:39,030
0,450 450,570 570,660 660,900 900,1020
jarring when you first see

2343
00:56:39,030 --> 00:56:40,770
0,240 690,1200 1200,1260 1260,1500 1500,1740
it| and the story behind
|这背后的故事是，我们需要一些东西，我们知道我们会需要一些东西，

2344
00:56:40,770 --> 00:56:41,670
0,120 120,210 210,360 360,720 720,900
that is that, well we

2345
00:56:41,670 --> 00:56:43,470
0,300 300,990 1290,1410 1410,1530 1530,1800
needed something and we knew

2346
00:56:43,470 --> 00:56:44,310
0,90 90,210 210,330 330,510 510,840
that we would need something,|
|

2347
00:56:44,310 --> 00:56:45,210
0,330 330,390 390,450 450,810 810,900
but at the beginning, we
但一开始，我们只是说，看一切都是出口，一切都是公开的，

2348
00:56:45,210 --> 00:56:46,410
0,180 180,330 330,480 480,840 840,1200
just said look everything's export

2349
00:56:46,410 --> 00:56:48,090
0,240 240,660 660,1170 1170,1500 1500,1680
everything publicly visible,| we'll deal
|我们以后再处理这件事。

2350
00:56:48,090 --> 00:56:49,260
0,120 120,210 210,600
with it later.|
|

2351
00:56:49,520 --> 00:56:50,450
0,180 180,420 420,600 600,660 660,930
And after about a year,
大约一年后，很明显，我们需要一些方法来让程序员对其他程序员隐瞒一些事情

2352
00:56:50,450 --> 00:56:51,230
0,60 60,360 360,570 570,690 690,780
it was clear that we

2353
00:56:51,230 --> 00:56:52,910
0,270 270,480 480,810 810,1140 1530,1680
needed some way to you

2354
00:56:52,910 --> 00:56:54,530
0,240 270,540 540,1020 1020,1350 1350,1620
know let programmers hide things

2355
00:56:54,530 --> 00:56:56,980
0,150 150,330 330,1050 1440,1950
from other programmers| and
|你知道C++有这个公共冒号和私有冒号

2356
00:56:57,260 --> 00:56:58,130
0,150 150,270 270,390 390,570 570,870
you know {C++ - -}

2357
00:56:58,130 --> 00:56:59,300
0,240 240,420 420,750 750,1050 1050,1170
has this public colon and

2358
00:56:59,300 --> 00:57:00,860
0,300 300,900 1080,1320 1320,1440 1440,1560
private colon| and in a
|在一个大的结构中，你看着你看着定义，实际上真的很烦人

2359
00:57:00,860 --> 00:57:02,960
0,540 540,1020 1200,1470 1470,1830 1830,2100
large structure it's actually really

2360
00:57:02,960 --> 00:57:04,520
0,420 420,840 870,1110 1110,1410 1410,1560
annoying that you're looking you're

2361
00:57:04,520 --> 00:57:06,320
0,600 600,690 690,1320 1320,1590 1650,1800
looking at definitions| and you
|您必须向后滚动，并试图找到最近的公共冒号或私有冒号在哪里

2362
00:57:06,320 --> 00:57:07,430
0,90 90,210 210,540 540,990 990,1110
have to scroll backwards and

2363
00:57:07,430 --> 00:57:08,540
0,150 150,300 300,600 600,780 780,1110
try to find where the

2364
00:57:08,540 --> 00:57:09,680
0,210 210,480 480,780 780,1050 1050,1140
most recent public colon or

2365
00:57:09,680 --> 00:57:11,540
0,300 300,540 540,990 1260,1740 1740,1860
private colon was| and if
|如果真的很大，可能很难找到一个

2366
00:57:11,540 --> 00:57:12,410
0,150 150,390 390,660 660,750 750,870
it's really big, it can

2367
00:57:12,410 --> 00:57:13,250
0,60 60,270 270,360 360,630 630,840
be hard to find one|
|

2368
00:57:13,250 --> 00:57:14,060
0,150 150,300 300,420 420,720 720,810
and so it's hard to
因此，很难判断一个特定的定义是公共的还是私人的。

2369
00:57:14,060 --> 00:57:15,590
0,300 300,660 660,720 720,1050 1050,1530
tell whether a particular definition

2370
00:57:15,590 --> 00:57:17,100
0,120 120,420 420,510 510,960
is public or private.|
|

2371
00:57:17,220 --> 00:57:18,060
0,150 150,270 270,360 360,720 720,840
And then in Java, of
然后在Java中，它当然位于每个单独字段的开头

2372
00:57:18,060 --> 00:57:19,020
0,270 270,390 390,480 480,570 570,960
course it's at the beginning

2373
00:57:19,020 --> 00:57:21,030
0,120 120,420 420,810 810,1410 1800,2010
of every single field| and
|而且这似乎也有点过分，只是打字太多了。

2374
00:57:21,030 --> 00:57:22,320
0,210 210,450 450,660 660,750 750,1290
that seemed kind of excessive

2375
00:57:22,320 --> 00:57:23,760
0,330 330,540 540,660 660,810 810,1440
too, just too much typing.|
|

2376
00:57:24,900 --> 00:57:25,770
0,180 180,270 270,390 390,600 600,870
And so we looked around
所以我们又环顾了一下周围

2377
00:57:25,770 --> 00:57:27,060
0,90 90,360 360,600 600,930 990,1290
some more| and and someone
|有人向我们指出，虽然Python有这样的约定

2378
00:57:27,060 --> 00:57:27,870
0,270 270,420 420,510 510,630 630,810
pointed out to us that

2379
00:57:27,870 --> 00:57:29,310
0,120 120,600 600,810 810,990 990,1440
while python has this convention|
|

2380
00:57:29,310 --> 00:57:30,270
0,180 180,270 270,390 390,480 480,960
where you put an underscore
你在前面加下划线来隐藏一些东西

2381
00:57:30,270 --> 00:57:31,320
0,90 90,390 390,480 480,690 690,1050
in front to make something

2382
00:57:31,320 --> 00:57:33,690
0,540 1050,1230 1230,1410 1410,1680 1680,2370
hidden| and that seemed interesting,|
|这看起来很有趣，|

2383
00:57:33,750 --> 00:57:35,130
0,720 750,930 930,1170 1170,1260 1260,1380
but you probably don't want
但您可能不希望默认设置不被隐藏，

2384
00:57:35,130 --> 00:57:36,150
0,90 90,510 510,600 600,690 690,1020
the default to be not

2385
00:57:36,150 --> 00:57:37,380
0,450 480,630 630,780 780,870 870,1230
hidden,| you want the default
|您希望隐藏默认设置。

2386
00:57:37,380 --> 00:57:38,460
0,90 90,150 150,630
to be hidden.|
|

2387
00:57:38,580 --> 00:57:39,780
0,600 630,810 810,900 900,1020 1020,1200
{} And then we thought
然后我们想了想，我们可以在名字前面加一个加号。

2388
00:57:39,780 --> 00:57:40,650
0,210 210,420 420,510 510,630 630,870
about well we could put

2389
00:57:40,650 --> 00:57:41,640
0,90 90,570 570,690 690,900 900,990
a plus in front of

2390
00:57:41,640 --> 00:57:44,040
0,840
names.|
|

2391
00:57:44,510 --> 00:57:45,950
0,150 150,450 450,780 780,1290 1290,1440
And then someone suggested well
然后有人建议，如果可以输出大写字母，

2392
00:57:45,950 --> 00:57:47,330
0,390 390,750 750,960 960,1230 1230,1380
what about {uppercase -} could

2393
00:57:47,330 --> 00:57:48,830
0,90 90,780 1050,1230 1230,1320 1320,1500
be exported,| and it seemed
|这似乎是个愚蠢而糟糕的主意，真的是这样，

2394
00:57:48,830 --> 00:57:50,870
0,120 120,360 390,1110 1110,1590 1590,2040
like a dumb terrible idea,

2395
00:57:51,050 --> 00:57:53,390
0,180 180,390 390,750 1530,1980 2130,2340
it really did,| but as
|但当你仔细想想，

2396
00:57:53,390 --> 00:57:54,290
0,120 120,300 300,540 540,630 630,900
you think about it,| like
|好像我真的不喜欢这个主意，

2397
00:57:54,290 --> 00:57:55,220
0,180 180,450 450,630 630,780 780,930
I really didn't like this

2398
00:57:55,220 --> 00:57:57,050
0,480 840,1170 1170,1320 1320,1500 1500,1830
idea,| and I have a
|我对坐在房间里的情景记忆犹新

2399
00:57:57,080 --> 00:57:58,550
0,360 360,630 630,1020 1020,1140 1140,1470
very clear memory of sitting

2400
00:57:58,550 --> 00:58:00,140
0,330 750,1020 1020,1320 1320,1410 1410,1590
in the room| and what
|当我们讨论这个问题时，我所凝视的是，

2401
00:58:00,140 --> 00:58:01,130
0,30 30,210 210,630 630,810 810,990
I was staring at as

2402
00:58:01,130 --> 00:58:02,840
0,90 90,540 540,930 1140,1560 1560,1710
we discussed this {},| but
|但我没有任何合乎逻辑的理由反对它

2403
00:58:02,840 --> 00:58:03,920
0,60 60,210 210,390 390,780 780,1080
I had no logical argument

2404
00:58:03,920 --> 00:58:04,940
0,330 330,480 510,660 660,780 780,1020
against it| and it turned
|事实证明，这太棒了，

2405
00:58:04,940 --> 00:58:06,500
0,150 150,210 210,360 360,1110 1260,1560
out, it was fantastic,| it
|它看起来很糟糕，就像在审美上一样，

2406
00:58:06,500 --> 00:58:08,390
0,150 150,570 690,870 870,1350 1350,1890
was like it seemed bad

2407
00:58:08,390 --> 00:58:10,730
0,210 210,420 420,1260 1290,1950 2160,2340
just like aesthetically,| but it
|但这是我现在最喜欢的围棋之一

2408
00:58:10,730 --> 00:58:11,540
0,90 90,240 240,300 300,420 420,810
is one of my favorite

2409
00:58:11,540 --> 00:58:12,500
0,240 240,360 360,630 630,840 840,960
things now about Go| that
|当你看着某物的用途时，

2410
00:58:12,500 --> 00:58:13,370
0,180 180,330 330,660 660,750 750,870
when you look at a

2411
00:58:13,370 --> 00:58:14,690
0,330 330,420 420,960 990,1170 1170,1320
use of something,| you can
|你可以立即看到，你得到的是其他人在每次使用时都可以访问或不可以访问的东西，

2412
00:58:14,690 --> 00:58:16,310
0,240 240,1080 1080,1230 1230,1380 1380,1620
see immediately, you get that

2413
00:58:16,310 --> 00:58:17,780
0,270 270,570 690,930 930,1140 1140,1470
bit of is this something

2414
00:58:17,780 --> 00:58:19,160
0,150 150,390 390,690 690,840 840,1380
that other people can access

2415
00:58:19,160 --> 00:58:20,660
0,120 120,630 750,960 960,1230 1230,1500
or not at every use,|
|

2416
00:58:20,660 --> 00:58:22,010
0,180 180,390 420,870 870,1050 1050,1350
because if you see code
因为如果你看到代码调用一个函数来做你不知道的事情，

2417
00:58:22,010 --> 00:58:23,240
0,300 300,420 420,780 780,900 900,1230
calling a function to do

2418
00:58:23,270 --> 00:58:24,020
0,120 120,210 210,570 570,630 630,750
you know whatever it is

2419
00:58:24,020 --> 00:58:25,280
0,90 90,180 180,510 510,870
that it doesn't think,|
|

2420
00:58:25,310 --> 00:58:26,660
0,210 210,660 660,810 810,1200 1200,1350
oh wow {} can other
哦，哇，其他人也能这么做吗，

2421
00:58:26,660 --> 00:58:28,550
0,240 240,390 390,810 1140,1710 1710,1890
people do that,| and {you,know}
|你知道，你的大脑在某种程度上会处理这些问题，

2422
00:58:28,550 --> 00:58:29,570
0,360 360,600 600,810 810,870 870,1020
your brain sort of takes

2423
00:58:29,570 --> 00:58:30,170
0,150 150,210 210,360 360,480 480,600
care of that,| but now
|但现在我转到C++，我看到这样的调用

2424
00:58:30,170 --> 00:58:30,770
0,90 90,180 180,270 270,420 420,600
I go to {C++ -

2425
00:58:30,770 --> 00:58:31,790
0,270 270,360 360,450 450,630 630,1020
-} and I see calls

2426
00:58:31,790 --> 00:58:33,470
0,150 150,540 810,990 990,1500 1500,1680
like that| and I get
|我真的很担心的是，其他课程可以做到的

2427
00:58:33,470 --> 00:58:34,700
0,210 210,510 510,870 870,1050 1050,1230
really worried about is that

2428
00:58:34,700 --> 00:58:36,350
0,90 90,300 300,570 570,1200 1200,1650
is that something other classes

2429
00:58:36,350 --> 00:58:38,090
0,150 150,330 330,600 1020,1410 1410,1740
can get at| {} and
|事实证明，拥有这一位对于阅读代码非常有用。

2430
00:58:38,120 --> 00:58:39,440
0,360 360,570 570,780 780,1080 1080,1320
having that bit actually turns

2431
00:58:39,440 --> 00:58:40,400
0,120 120,180 180,300 300,570 570,960
out to be really useful

2432
00:58:40,400 --> 00:58:41,840
0,390 390,600 600,990
for reading code.|
|

2433
00:58:42,560 --> 00:58:43,910
0,510 540,720 720,960 960,1200 1200,1350
{} A couple people ask
有几个人问起了泛型。

2434
00:58:43,910 --> 00:58:44,930
0,150 150,660 660,780 780,870 870,1020
about generics.| If you don't
|如果你不知道，我们有一个关于仿制药的积极建议，

2435
00:58:44,930 --> 00:58:46,640
0,480 660,960 960,1260 1260,1380 1380,1710
know, we have an active

2436
00:58:46,640 --> 00:58:48,260
0,390 390,510 510,960 960,1170 1170,1620
proposal for generics,| we're actively
|我们正在积极地实施它，

2437
00:58:48,260 --> 00:58:49,910
0,330 330,420 420,900 900,1140 1380,1650
working on implementing it,| we
|我们希望在今年晚些时候发布，

2438
00:58:49,910 --> 00:58:52,190
0,390 390,1020 1050,1380 1410,2010 2010,2280
hope that the released later

2439
00:58:52,190 --> 00:58:53,450
0,90 90,180 180,720 930,1170 1170,1260
in the year,| towards the
|到今年年底，我们实际上将有一个完整版本的泛型，你可以，你可以实际使用，

2440
00:58:53,450 --> 00:58:54,050
0,120 120,180 180,240 240,480 480,600
end of the year, we'll

2441
00:58:54,050 --> 00:58:56,150
0,330 330,750 750,1230 1230,1710 1740,2100
actually have a full version

2442
00:58:56,150 --> 00:58:57,260
0,60 60,510 510,720 720,960 960,1110
of generics, you can, you

2443
00:58:57,260 --> 00:58:59,960
0,120 120,420 420,840 1020,2400 2460,2700
can actually use,| the that'll
|这将是一个预览版，

2444
00:58:59,960 --> 00:59:01,670
0,90 90,330 330,660 660,1260 1290,1710
be a preview release,| the
|我们希望这部电影的真正上映时间是18年，

2445
00:59:01,670 --> 00:59:02,750
0,270 270,660 660,780 780,870 870,1080
real release that we hope

2446
00:59:02,750 --> 00:59:03,860
0,60 60,180 180,330 330,630 630,1110
it will be in is

2447
00:59:03,890 --> 00:59:05,060
0,210 210,330 330,780 780,990 990,1170
Go on eighteen,| which is
|也就是明年的二月，

2448
00:59:05,060 --> 00:59:06,260
0,390 390,480 480,750 750,990 990,1200
February of next year,| so
|也许下一节课，我们会用到泛型，让我们拭目以待。

2449
00:59:06,260 --> 00:59:08,150
0,480 480,720 720,1320 1350,1650 1650,1890
maybe next class, {} we'll

2450
00:59:08,150 --> 00:59:09,200
0,240 240,390 390,480 480,630 630,1050
actually get to use generics,

2451
00:59:09,200 --> 00:59:09,920
0,90 90,390
we'll see.|
|

2452
00:59:10,910 --> 00:59:11,990
0,210 210,300 300,600 600,840 840,1080
But I'm certainly looking forward
但我当然很期待有一个通用的MIN和MAX，

2453
00:59:11,990 --> 00:59:13,190
0,60 60,330 330,570 570,990 990,1200
to having a generic {min,and}

2454
00:59:13,190 --> 00:59:14,240
0,390 390,510 510,810 810,900 900,1050
max,| the reason we don't
|我们没有这些的原因是，

2455
00:59:14,240 --> 00:59:15,590
0,210 210,480 480,600 600,810 1080,1350
have those is that,| we
|我们必须选择它们是哪种类型的

2456
00:59:15,590 --> 00:59:16,400
0,120 120,210 210,420 420,600 600,810
have to pick which type

2457
00:59:16,400 --> 00:59:17,270
0,120 120,270 270,630 630,780 780,870
they were for| or you
|或者你有一整套这样的东西

2458
00:59:17,270 --> 00:59:18,230
0,210 210,390 390,570 570,870 870,960
have a whole suite of

2459
00:59:18,230 --> 00:59:19,130
0,210 210,300 300,570 570,690 690,900
them| and it just seems
|这看起来很愚蠢，

2460
00:59:19,130 --> 00:59:19,940
0,300 300,420 420,570 570,690 690,810
silly,| it seems like we
|似乎我们应该等待仿制药出现。

2461
00:59:19,940 --> 00:59:21,600
0,120 120,300 300,420 420,1170
should wait for generics.|
|

2462
00:59:22,540 --> 00:59:24,850
0,780 1050,1530 1530,1950 1950,2070 2070,2310
{} Someone asked, is there
有人问，在编程领域，围棋可能不是最好的语言，但它仍然在使用。

2463
00:59:24,850 --> 00:59:25,930
0,180 180,390 390,480 480,900 900,1080
any area of programming, where

2464
00:59:25,930 --> 00:59:26,890
0,390 390,540 540,720 720,840 840,960
Go may not be the

2465
00:59:26,890 --> 00:59:28,480
0,420 420,930 930,1170 1170,1320 1320,1590
best language, but it's still

2466
00:59:28,480 --> 00:59:30,310
0,660 900,1290 1290,1470 1470,1590 1590,1830
used.| And and the answer
|答案是绝对的，

2467
00:59:30,310 --> 00:59:31,930
0,150 150,990 990,1200 1200,1380 1380,1620
is absolutely,| like that happens
|这种情况在每种语言中都会发生。

2468
00:59:31,930 --> 00:59:32,980
0,120 120,210 210,690 690,840 840,1050
all the time with every

2469
00:59:32,980 --> 00:59:34,920
0,660
language.|
|

2470
00:59:34,920 --> 00:59:35,610
0,90 90,240 240,330 330,450 450,690
I think Go is actually
我认为围棋实际上是一门很好的全能语言，

2471
00:59:35,610 --> 00:59:37,860
0,150 150,300 300,750 750,1410 1680,2250
really good all-around language {},|
|

2472
00:59:37,890 --> 00:59:38,850
0,360 420,570 570,660 660,780 780,960
but you know you might
但你知道你可能会把它用在不太完美的东西上，

2473
00:59:38,850 --> 00:59:39,990
0,150 150,540 540,690 690,960 960,1140
use it for something that's

2474
00:59:39,990 --> 00:59:42,390
0,180 180,570 570,1170 1740,2010 2010,2400
not perfect for,| just because
|仅仅因为你的程序的其余部分是用围棋写的，

2475
00:59:42,390 --> 00:59:43,290
0,120 120,390 390,450 450,570 570,900
the rest of your program

2476
00:59:43,290 --> 00:59:44,100
0,150 150,330 330,420 420,690 690,810
is written in Go,| and
|并且您想要与程序的其余部分进行互操作，

2477
00:59:44,100 --> 00:59:45,240
0,90 90,270 270,450 510,780 780,1140
you want to inter operate

2478
00:59:45,240 --> 00:59:45,810
0,120 120,210 210,420 420,480 480,570
with the rest of the

2479
00:59:45,810 --> 00:59:47,610
0,450 450,780 780,1170 1170,1290 1290,1800
program,| so there's this website
|所以有一个网站叫做在线整数序列百科全书，

2480
00:59:47,610 --> 00:59:49,050
0,210 210,420 420,780 780,1380 1380,1440
called the online encyclopedia of

2481
00:59:49,050 --> 00:59:50,820
0,240 240,930 1260,1440 1440,1500 1500,1770
integer sequences,| it's a search
|这是一个搜索引擎，你可以输入二三五七一一

2482
00:59:50,820 --> 00:59:51,810
0,360 360,480 480,720 720,810 810,990
engine you type in like

2483
00:59:51,810 --> 00:59:52,980
0,150 150,360 360,600 600,840 840,1170
two three five seven eleven|
|

2484
00:59:52,980 --> 00:59:53,610
0,90 90,180 180,390 390,480 480,630
and it tells you those
它会告诉你这些是质数

2485
00:59:53,610 --> 00:59:55,890
0,30 30,120 120,690 1800,2010 2010,2280
are the primes| and it
|事实证明，这一切的后端都是用Go编写的。

2486
00:59:55,890 --> 00:59:56,730
0,180 180,270 270,390 390,450 450,840
turns out that the backend

2487
00:59:56,730 --> 00:59:57,330
0,60 60,180 180,300 300,450 450,600
for that is all written

2488
00:59:57,330 --> 00:59:58,220
0,60 60,540
in Go.|
|

2489
00:59:58,510 --> 00:59:59,920
0,420 870,1020 1020,1140 1140,1350 1350,1410
And if you type in
如果你输入一个序列，

2490
00:59:59,920 --> 01:00:00,730
0,60 60,390 390,450 450,660 660,810
a sequence,| it doesn't no
|它不是不，它实际上做了一些非常复杂的数学运算，

2491
01:00:00,730 --> 01:00:01,810
0,90 90,360 360,540 540,720 720,1080
it actually does some pretty

2492
01:00:01,810 --> 01:00:03,370
0,600 600,900 900,1020 1020,1080 1080,1560
sophisticated math,| on the numbers
|在数字上都有大数字之类的东西

2493
01:00:03,370 --> 01:00:04,330
0,150 150,300 300,510 510,840 840,960
all with big numbers and

2494
01:00:04,330 --> 01:00:05,500
0,150 150,300 300,600 720,1050 1050,1170
things like that| and all
|所有这些都是用围棋写的，

2495
01:00:05,500 --> 01:00:06,100
0,60 60,240 240,360 360,540 540,600
of that is written in

2496
01:00:06,100 --> 01:00:07,510
0,180 180,450 450,1020 1080,1260 1260,1410
Go too,| because it was
|因为花在枫树和数学上的钱太烦人了

2497
01:00:07,510 --> 01:00:09,040
0,330 360,960 960,1080 1080,1380 1380,1530
too annoying to shell out

2498
01:00:09,040 --> 01:00:10,720
0,90 90,450 450,540 540,1290 1290,1680
to maple and mathematic| and
|然后做一些跨语言的事情，

2499
01:00:10,720 --> 01:00:11,530
0,150 150,210 210,330 330,540 540,810
sort of do that cross

2500
01:00:11,530 --> 01:00:12,550
0,330 330,540 540,720 720,810 810,1020
language thing,| even though you'd
|即使您更愿意在这些语言中实现，

2501
01:00:12,550 --> 01:00:13,780
0,330 330,570 570,930 930,1050 1050,1230
much rather implement in those

2502
01:00:13,780 --> 01:00:15,880
0,660 840,1200 1200,1680 1680,1860 1860,2100
languages,| so you run into
|所以你总是会遇到这样的妥协，这很好。

2503
01:00:15,880 --> 01:00:17,470
0,210 210,480 480,750 750,1440 1440,1590
those sorts of compromises all

2504
01:00:17,470 --> 01:00:18,430
0,60 60,420 420,510 510,690 690,960
the time and that's fine.|
|

2505
01:00:21,020 --> 01:00:22,520
0,810

2506
01:00:22,520 --> 01:00:25,070
0,300 300,570 570,1110 1110,1620 2130,2550
Someone asked about, {} go
有人问，围棋应该很简单，

2507
01:00:25,070 --> 01:00:26,300
0,90 90,330 330,390 390,450 450,1230
is supposed to be simple,|
|

2508
01:00:26,330 --> 01:00:27,470
0,270 270,480 480,630 630,960 960,1140
so that's why there's no
这就是为什么没有泛型和集合的原因，

2509
01:00:27,470 --> 01:00:29,420
0,510 510,630 630,810 810,1500 1620,1950
generics and no sets {},|
|

2510
01:00:29,420 --> 01:00:30,260
0,180 180,390 390,450 450,720 720,840
but isn't it also for
但这不也是软件开发人员的吗？软件开发人员不需要所有这些东西吗

2511
01:00:30,260 --> 01:00:32,120
0,360 360,840 840,1050 1050,1410 1410,1860
software developers and {don't,software} developers

2512
01:00:32,120 --> 01:00:33,170
0,210 210,330 330,480 480,840 840,1050
need all this stuff| and
|重建它是愚蠢的。

2513
01:00:33,170 --> 01:00:34,760
0,270 270,510 510,750 780,1380 1380,1590
it's silly to reconstruct it.|
|

2514
01:00:35,400 --> 01:00:36,810
0,150 150,240 240,390 390,690 1020,1410
And I think that it's
我认为这是真的有人有意，

2515
01:00:36,810 --> 01:00:38,160
0,150 150,270 270,510 510,840 840,1350
true that there's someone intention,|
|

2516
01:00:38,160 --> 01:00:39,930
0,210 210,480 480,1530 1530,1680 1680,1770
but but simplicity in the
但是，省略东西的简单性从来不是我们的目标，

2517
01:00:39,930 --> 01:00:41,130
0,270 270,390 390,720 720,930 930,1200
sense of leaving things out

2518
01:00:41,130 --> 01:00:42,570
0,210 210,570 570,780 780,870 870,1440
was not ever the goal,|
|

2519
01:00:42,840 --> 01:00:45,060
0,390 390,690 690,840 840,1620 1950,2220
so like for sets, it
就像布景一样，地图看起来就像是离布景很近，

2520
01:00:45,060 --> 01:00:46,140
0,150 150,300 300,630 630,990 990,1080
just seemed like maps are

2521
01:00:46,140 --> 01:00:47,130
0,210 210,450 450,540 540,900 900,990
so close to sets,| you
|你只有一个地图，其中的值为空或布尔值，这是一个集合，

2522
01:00:47,130 --> 01:00:48,570
0,120 120,270 270,990 990,1320 1320,1440
just have a map where

2523
01:00:48,570 --> 01:00:49,710
0,90 90,480 480,600 600,960 960,1140
the value is empty or

2524
01:00:49,710 --> 01:00:51,870
0,60 60,660 900,1470 1470,1530 1530,2160
a boolean, that's a set,|
|

2525
01:00:52,050 --> 01:00:53,640
0,240 240,330 330,780 780,1170 1470,1590
and for generics, like you
而对于仿制药，就像你必须记住的那样，当我们开始2007年的时候，

2526
01:00:53,640 --> 01:00:54,480
0,90 90,150 150,450 450,630 630,840
have to remember that when

2527
01:00:54,480 --> 01:00:56,940
0,150 150,570 570,1350 1350,1830 1830,2460
we started going {2007 -},|
|

2528
01:00:57,000 --> 01:00:59,730
0,720 720,900 900,1260 1260,1860 1860,2730
Java was like just finishing
Java就像是刚刚结束了泛型推出的真正失败

2529
01:00:59,730 --> 01:01:01,230
0,240 240,600 600,1290 1290,1410 1410,1500
a true fiasco of a

2530
01:01:01,230 --> 01:01:03,240
0,390 390,510 510,1290 1590,1800 1800,2010
rollout of generics| and so
|所以就好像我们真的很害怕一样，

2531
01:01:03,240 --> 01:01:04,410
0,180 180,330 330,570 570,840 840,1170
like we were really scared

2532
01:01:04,410 --> 01:01:05,340
0,60 60,330 330,450 450,810 810,930
of that,| we knew that
|我们知道，如果我们只是试着去做，你知道我们会错的

2533
01:01:05,340 --> 01:01:06,060
0,150 150,240 240,420 420,660 660,720
if we just tried to

2534
01:01:06,060 --> 01:01:08,130
0,210 210,510 870,1440 1530,1860 1860,2070
do it, you know we

2535
01:01:08,130 --> 01:01:09,300
0,120 120,270 270,390 390,870 930,1170
would get it wrong| and
|我们知道我们可以在没有泛型的情况下编写很多有用的程序。

2536
01:01:09,300 --> 01:01:09,870
0,90 90,240 240,330 330,420 420,570
we knew that we could

2537
01:01:09,870 --> 01:01:10,620
0,150 150,210 210,420 420,480 480,750
write a lot of useful

2538
01:01:10,620 --> 01:01:12,200
0,420 420,660 660,1410
programs without generics.|
|

2539
01:01:12,200 --> 01:01:12,860
0,120 120,210 210,390 390,510 510,660
And so that was what
这就是我们所做的。

2540
01:01:12,860 --> 01:01:13,960
0,90 90,480
we did.|
|

2541
01:01:14,110 --> 01:01:15,850
0,750 870,1200 1200,1290 1290,1500 1500,1740
And then we came back
然后我们又回到了这个问题上，

2542
01:01:15,850 --> 01:01:17,200
0,150 150,360 360,780 780,1110 1110,1350
to it,| when we felt
|当我们觉得没问题的时候，我们已经花了足够多的时间编写其他程序，

2543
01:01:17,200 --> 01:01:19,030
0,330 450,840 840,1230 1260,1650 1650,1830
like okay we've spent enough

2544
01:01:19,030 --> 01:01:20,260
0,210 210,420 420,600 600,1110 1110,1230
time writing other programs,| we
|我们从Go的泛型中了解了更多关于我们需要什么的信息

2545
01:01:20,260 --> 01:01:20,950
0,150 150,240 240,450 450,510 510,690
kind of know a lot

2546
01:01:20,950 --> 01:01:21,940
0,240 240,420 420,570 570,660 660,990
more about what we need

2547
01:01:21,940 --> 01:01:23,800
0,240 240,510 510,1020 1020,1260 1260,1860
from from generics for Go|
|

2548
01:01:24,010 --> 01:01:25,270
0,720 720,840 840,990 990,1200 1200,1260
and we can take the
我们可以抽出时间与真正的专家交谈

2549
01:01:25,270 --> 01:01:26,170
0,270 270,360 360,630 630,720 720,900
time to talk to real

2550
01:01:26,170 --> 01:01:28,030
0,690 810,1200 1200,1410 1410,1590 1590,1860
experts| and I think that
|我想你知道，如果在五年或十年前拥有它们会很好，

2551
01:01:28,060 --> 01:01:29,170
0,120 120,420 690,870 870,1020 1020,1110
you know it would have

2552
01:01:29,170 --> 01:01:30,190
0,150 150,480 480,600 600,870 870,1020
been nice to have them

2553
01:01:30,190 --> 01:01:31,240
0,300 300,360 360,540 540,750 750,1050
five or ten years ago,|
|

2554
01:01:31,240 --> 01:01:32,440
0,240 240,360 360,600 600,690 690,1200
but we wouldn't have had
但我们就不会有现在这样的精彩场面，

2555
01:01:32,470 --> 01:01:33,640
0,210 210,480 480,780 780,1050 1050,1170
the really nice ones that

2556
01:01:33,640 --> 01:01:34,720
0,150 150,390 390,450 450,690 690,1080
we're going to have now,|
|

2557
01:01:34,900 --> 01:01:35,470
0,210 210,270 270,390 390,450 450,570
so I think it was
所以我认为这可能是正确的决定。

2558
01:01:35,470 --> 01:01:37,080
0,420 420,510 510,720 720,1140
probably the right decision.|
|

2559
01:01:40,030 --> 01:01:41,410
0,660 780,1080 1080,1230 1230,1320 1320,1380
{} So there was a
因此出现了一个关于Goroutines以及与Plan9线程库的关系的问题，

2560
01:01:41,410 --> 01:01:42,940
0,270 270,630 630,780 780,1380 1380,1530
question about {goroutines -} and

2561
01:01:42,940 --> 01:01:43,780
0,90 90,480 480,540 540,660 660,840
the relation to the {plan9

2562
01:01:43,780 --> 01:01:45,310
0,210 210,420 420,870 870,1200 1200,1530
-} thread library,| which was
|这一切都是合作安排的，

2563
01:01:45,310 --> 01:01:47,650
0,150 150,720 720,1260 1710,1920 1920,2340
all cooperatively scheduled,| and whether
|以及是否对大猩猩的行程进行了适当的安排，以及这是否会造成问题。

2564
01:01:47,650 --> 01:01:48,730
0,150 150,480 480,540 540,720 720,1080
{goroutines -} were ever properly

2565
01:01:48,730 --> 01:01:50,080
0,450 450,780 780,870 870,1050 1050,1350
scheduled and if that caused

2566
01:01:50,080 --> 01:01:51,220
0,720
problems.|
|

2567
01:01:51,430 --> 01:01:52,480
0,240 240,420 420,540 540,990 990,1050
And it is absolutely the
绝对是这样的，就像围棋和Goroutine运行时一样，灵感来自于之前在Plan9上的经验，

2568
01:01:52,480 --> 01:01:54,760
0,240 240,390 390,600 600,1200 1410,2280
case, that like Go and

2569
01:01:54,790 --> 01:01:56,590
0,390 390,600 600,960 960,1470 1470,1800
the {goroutine -} runtime were

2570
01:01:56,620 --> 01:01:58,210
0,210 210,270 270,810 810,1170 1170,1590
sort of inspired by previous

2571
01:01:58,210 --> 01:02:00,010
0,450 450,540 540,780 780,1200 1440,1800
experience on {plan9 -},| there
|在早期版本的Plan9上，实际上有一种不同的语言，称为Alef

2572
01:02:00,010 --> 01:02:01,270
0,120 120,420 420,540 540,840 840,1260
was actually a different language

2573
01:02:01,270 --> 01:02:02,320
0,300 300,660 660,780 810,990 990,1050
called {Alef -} on an

2574
01:02:02,320 --> 01:02:04,030
0,240 240,540 540,780 780,1200 1350,1710
early version {plan9 -}| that
|那是汇编的，它有频道，它有选择，

2575
01:02:04,030 --> 01:02:06,370
0,300 300,1050 1050,1170 1170,1680 1710,2340
was compiled, it had channels,

2576
01:02:06,370 --> 01:02:08,260
0,150 150,390 390,1110 1200,1380 1380,1890
it had select,| it had
|它有一些我们称之为任务的东西，有点像猩猩程序，

2577
01:02:08,470 --> 01:02:09,700
0,270 270,330 330,600 600,1080 1080,1230
things we called tasks which

2578
01:02:09,700 --> 01:02:10,330
0,90 90,150 150,330 330,450 450,630
were a little bit like

2579
01:02:10,330 --> 01:02:11,320
0,60 60,540 540,750 750,840 840,990
{goroutines -},| but it didn't
|但它没有垃圾收集器，这在很多情况下让事情变得非常恼人，

2580
01:02:11,320 --> 01:02:12,400
0,90 90,150 150,510 510,960 960,1080
have a garbage collector and

2581
01:02:12,400 --> 01:02:13,780
0,240 240,450 450,690 690,930 930,1380
that made things really annoying

2582
01:02:13,780 --> 01:02:15,280
0,120 120,330 330,420 420,930 1140,1500
in {a,lot} of cases,| and
|以及任务的工作方式，

2583
01:02:15,280 --> 01:02:16,870
0,600 690,810 810,960 960,1140 1140,1590
also the way that tasks

2584
01:02:16,870 --> 01:02:18,010
0,270 270,360 360,540 540,1050 1050,1140
work,| they were tied to
|他们被绑在一个特定的线索上，

2585
01:02:18,010 --> 01:02:19,180
0,90 90,540 540,930 930,1050 1050,1170
a specific thread,| so you
|因此，您可能在一个线程中有三个任务，在另一个线程中有两个任务，

2586
01:02:19,180 --> 01:02:20,560
0,120 120,420 450,810 810,1290 1290,1380
might have three tasks in

2587
01:02:20,560 --> 01:02:22,150
0,210 210,810 870,1050 1050,1170 1170,1590
one thread and two tasks

2588
01:02:22,150 --> 01:02:23,380
0,90 90,390 390,930
in another thread,|
|

2589
01:02:23,600 --> 01:02:24,620
0,240 240,330 330,420 420,630 630,1020
and in the three tasks
在第一线的三个任务中，

2590
01:02:24,620 --> 01:02:26,090
0,60 60,150 150,420 420,990 1020,1470
in the first thread,| they
|他们一次只跑一次

2591
01:02:26,090 --> 01:02:27,230
0,270 270,570 570,810 810,1050 1050,1140
only one ever ran at

2592
01:02:27,230 --> 01:02:28,040
0,90 90,450 450,540 540,600 600,810
a time| and they could
|而且他们只能在渠道运营期间重新安排时间

2593
01:02:28,040 --> 01:02:29,630
0,240 240,780 780,1020 1020,1290 1290,1590
only rescheduled during a channel

2594
01:02:29,630 --> 01:02:31,220
0,720 870,1170 1170,1290 1290,1440 1440,1590
operation| and so you would
|因此，您可以编写代码，其中这三个任务都在相同的数据结构上运行，

2595
01:02:31,220 --> 01:02:32,600
0,210 210,630 630,900 900,1230 1230,1380
write code where those three

2596
01:02:32,600 --> 01:02:33,710
0,390 390,510 510,690 690,1050 1050,1110
tasks were all operating on

2597
01:02:33,710 --> 01:02:35,480
0,60 60,300 300,510 510,1230 1350,1770
the same data structure,| and
|你只是知道，因为当你写它的时候，它就在你的脑海里。

2598
01:02:35,510 --> 01:02:36,770
0,180 180,390 390,840 870,1200 1200,1260
you just knew because it

2599
01:02:36,770 --> 01:02:37,490
0,150 150,240 240,360 360,600 600,720
was in your head when

2600
01:02:37,490 --> 01:02:38,620
0,120 120,360 360,630
you wrote it.|
|

2601
01:02:38,770 --> 01:02:39,700
0,420 420,510 510,660 660,780 780,930
That you know it was
你知道，这两个不同的任务在相同的数据结构上涂鸦是可以的，

2602
01:02:39,700 --> 01:02:40,750
0,330 330,450 450,630 630,750 750,1050
okay for these two different

2603
01:02:40,750 --> 01:02:42,370
0,570 570,690 690,990 1020,1470 1470,1620
tasks to be scribbling over

2604
01:02:42,370 --> 01:02:43,330
0,90 90,270 270,480 480,780 780,960
the same data structure,| because
|因为它们永远不可能同时运行。

2605
01:02:43,330 --> 01:02:44,230
0,150 150,270 270,540 540,660 660,900
they could never be running

2606
01:02:44,230 --> 01:02:45,640
0,90 90,180 180,420 420,780
at the same time.|
|

2607
01:02:45,640 --> 01:02:46,840
0,150 150,690 690,870 870,960 960,1200
And, meanwhile in the other
同时，在另一个线程中，不同的数据和不同的任务也有相同的情况

2608
01:02:46,840 --> 01:02:47,740
0,330 330,420 420,570 570,660 660,900
thread you've got the same

2609
01:02:47,740 --> 01:02:49,030
0,480 480,660 660,840 840,990 990,1290
situation going on with different

2610
01:02:49,030 --> 01:02:50,830
0,210 210,390 390,630 630,1290 1620,1800
data and different tasks| and
|六个月后，你又回到了同样的项目，

2611
01:02:50,830 --> 01:02:51,490
0,120 120,210 210,330 330,570 570,660
then you come back to

2612
01:02:51,490 --> 01:02:52,390
0,120 120,300 300,570 570,720 720,900
the same program like six

2613
01:02:52,390 --> 01:02:53,650
0,180 180,390 390,510 510,960 960,1260
months later,| you totally forget
|您完全忘记了哪个任务可以写入不同的数据

2614
01:02:53,650 --> 01:02:55,240
0,210 210,600 600,900 1050,1470 1470,1590
which task could write to

2615
01:02:55,240 --> 01:02:56,920
0,420 420,720 720,810 810,1260 1410,1680
different pieces of data| and
|我敢肯定我们有无数的比赛，

2616
01:02:56,920 --> 01:02:57,760
0,120 120,450 450,570 570,660 660,840
I'm sure that we had

2617
01:02:57,760 --> 01:02:58,750
0,300 300,420 420,840 840,870 870,990
tons of races,| I mean
|我的意思是，它只是小程序的一个很好的模型

2618
01:02:58,750 --> 01:02:59,740
0,90 90,240 240,510 630,870 870,990
it was just it was

2619
01:02:59,740 --> 01:03:01,000
0,60 60,480 480,780 780,930 930,1260
a nice model for small

2620
01:03:01,000 --> 01:03:01,840
0,450 450,540 540,600 600,690 690,840
programs| and it was a
|在很长一段时间里，这是一个糟糕的编程模式

2621
01:03:01,840 --> 01:03:03,880
0,450 450,840 840,1380 1410,1860 1860,2040
terrible model for programming over

2622
01:03:03,880 --> 01:03:04,870
0,90 90,300 300,540 540,630 630,990
a long period of time|
|

2623
01:03:04,870 --> 01:03:05,860
0,60 60,330 330,390 390,600 600,990
or having a big program
或者有一个其他人不得不努力的大项目。

2624
01:03:05,860 --> 01:03:06,880
0,240 330,570 570,810 810,930 930,1020
that other people had to

2625
01:03:06,880 --> 01:03:07,960
0,210 210,450
work on.|
|

2626
01:03:07,960 --> 01:03:08,860
0,270 270,420 420,540 540,660 660,900
So, so that was never
所以，这从来不是围棋的模式，

2627
01:03:08,860 --> 01:03:09,910
0,60 60,360 360,690 690,750 750,1050
the model {for,Go},| the model
|围棋的模式总是有这些轻量级的大猩猩很好，

2628
01:03:09,910 --> 01:03:11,710
0,150 150,330 330,480 480,1290 1530,1800
for Go was always it's

2629
01:03:11,710 --> 01:03:12,790
0,210 210,270 270,510 510,720 720,1080
good to have these lightweight

2630
01:03:12,790 --> 01:03:14,170
0,150 150,720 720,900 900,1080 1080,1380
{goroutines -},| but they're gonna
|但它们都将独立运行

2631
01:03:14,170 --> 01:03:15,940
0,390 390,540 540,870 870,1650 1650,1770
all be running independently| and
|如果他们要分享使用锁所需的任何东西，

2632
01:03:15,940 --> 01:03:16,660
0,120 120,270 270,390 390,450 450,720
if they're going to share

2633
01:03:16,660 --> 01:03:17,530
0,360 360,450 450,660 660,720 720,870
anything they need to use

2634
01:03:17,530 --> 01:03:18,250
0,330 330,420 420,510 510,660 660,720
locks,| then they need to
|然后他们需要使用渠道进行明确的沟通和协调。

2635
01:03:18,250 --> 01:03:20,620
0,120 120,600 600,990 1170,1800 1920,2370
use channels to communicate and

2636
01:03:20,620 --> 01:03:22,340
0,450 450,1200
coordinate explicitly.|
|

2637
01:03:22,750 --> 01:03:24,310
0,420 420,810 810,1050 1050,1200 1200,1560
And that that has definitely
这无疑比以往任何一种简单的方式都要好得多，

2638
01:03:24,310 --> 01:03:25,480
0,390 390,450 450,660 660,930 930,1170
scaled a lot better than

2639
01:03:25,480 --> 01:03:26,200
0,180 180,240 240,330 330,570 570,720
any of the plain line

2640
01:03:26,200 --> 01:03:28,180
0,240 240,420 420,810 1350,1770 1800,1980
stuff ever did,| you know
|你知道吗，有时候人们听说大猩猩是合作安排的

2641
01:03:28,180 --> 01:03:29,820
0,390 390,1110
sometimes people

2642
01:03:29,910 --> 01:03:31,020
0,420 420,600 600,810 810,1050 1050,1110
hear that {goroutines -} are

2643
01:03:31,020 --> 01:03:32,550
0,540 540,1050 1050,1140 1140,1320 1320,1530
cooperatively scheduled| and they they
|他们认为你知道更多类似的事情，

2644
01:03:32,550 --> 01:03:33,780
0,390 420,540 540,690 690,1020 1020,1230
think you know something more

2645
01:03:33,780 --> 01:03:36,360
0,210 210,600 780,1350 2040,2310 2310,2580
like that,| it's it's true
|是的，在早期，大猩猩并没有像你希望的那样提前安排，

2646
01:03:36,360 --> 01:03:38,340
0,210 240,600 600,1230 1320,1500 1500,1980
that early on, the goroutines

2647
01:03:38,340 --> 01:03:40,020
0,120 120,480 480,720 720,1230 1230,1680
were not as preemptively scheduled

2648
01:03:40,020 --> 01:03:41,610
0,120 120,210 210,360 360,780 1020,1590
as you would like,| so
|所以在非常非常早期的时候，

2649
01:03:41,640 --> 01:03:42,720
0,150 150,300 300,600 600,810 810,1080
in the very very early

2650
01:03:42,720 --> 01:03:44,010
0,300 300,390 390,630 630,1020 1020,1290
days,| the only preemption points
|当您调入运行库时，唯一的抢占点是

2651
01:03:44,010 --> 01:03:44,760
0,150 150,240 240,510 510,660 660,750
when you called into the

2652
01:03:44,760 --> 01:03:47,190
0,720 900,1530 1530,1860 1860,2220 2250,2430
runtime,| shortly after that, the
|在那之后不久，抢占指的是任何时候你进入一个函数，

2653
01:03:47,190 --> 01:03:48,390
0,360 360,630 630,840 840,960 960,1200
preemption points where any time

2654
01:03:48,390 --> 01:03:50,910
0,90 90,360 360,420 420,960 2250,2520
you entered a function,| but
|但如果你在一个很长的时间里处于一个紧密的循环中，

2655
01:03:50,910 --> 01:03:51,330
0,90 90,180 180,270 270,330 330,420
if you were in a

2656
01:03:51,330 --> 01:03:52,770
0,300 300,750 810,1050 1050,1140 1140,1440
tight loop for a very

2657
01:03:52,770 --> 01:03:53,970
0,270 270,660 660,810 810,930 930,1200
long time,| that would never
|这永远不会抢占，这将导致垃圾收集器延迟，

2658
01:03:53,970 --> 01:03:55,500
0,570 570,690 690,840 840,960 960,1530
preempt and that would cause

2659
01:03:55,500 --> 01:03:56,760
0,390 390,690 690,1050 1050,1200 1200,1260
garbage collector delays,| because the
|因为垃圾收集器需要停止所有的Goroutine

2660
01:03:56,760 --> 01:03:58,020
0,270 270,480 480,660 660,810 840,1260
garbage collector need to stop

2661
01:03:58,020 --> 01:03:59,220
0,120 120,210 210,450 450,780 930,1200
all the {goroutines -}| and
|有一些大猩猩被困在一个紧密的环路中

2662
01:03:59,220 --> 01:04:00,240
0,90 90,180 180,360 360,780 780,1020
there be some goroutines stuck

2663
01:04:00,240 --> 01:04:01,020
0,90 90,150 150,450 450,690 690,780
in a tight loop| and
|而要完成这一循环将需要永远的时间。

2664
01:04:01,020 --> 01:04:01,770
0,60 60,180 180,390 390,690 690,750
it would take forever to

2665
01:04:01,770 --> 01:04:02,820
0,300 300,390 390,780
finish the loop.|
|

2666
01:04:03,100 --> 01:04:04,630
0,450 450,630 630,840 840,1350 1380,1530
{} And so actually in
所以实际上在最近的几个版本中，

2667
01:04:04,630 --> 01:04:05,830
0,60 60,360 360,630 630,1050 1050,1200
the last couple releases,| we've
|我们终于开始了，我们发现

2668
01:04:05,830 --> 01:04:07,120
0,300 300,750 750,870 870,1170 1170,1290
finally started we figured out|
|

2669
01:04:07,120 --> 01:04:08,590
0,120 120,210 210,570 600,1050 1140,1470
how to get a unique
如何以正确的方式将唯一的信号传递给线程，

2670
01:04:08,590 --> 01:04:10,090
0,570 570,690 690,990 990,1110 1110,1500
signals to deliver to threads

2671
01:04:10,090 --> 01:04:11,050
0,90 90,300 300,360 360,540 540,960
in just the right way,|
|

2672
01:04:11,170 --> 01:04:12,610
0,360 360,660 900,1140 1140,1320 1320,1440
so that {} and we
因此，我们可以有正确的簿记，真正能够将其用作先发制人机制。

2673
01:04:12,610 --> 01:04:13,630
0,120 120,240 240,300 300,480 480,1020
can have the right bookkeeping

2674
01:04:13,630 --> 01:04:14,560
0,90 90,480 480,600 600,810 810,930
to actually be able to

2675
01:04:14,560 --> 01:04:15,640
0,270 270,480 480,630 630,690 690,1080
use that as a preemption

2676
01:04:15,640 --> 01:04:16,700
0,540
mechanism.|
|

2677
01:04:16,700 --> 01:04:18,170
0,420 420,510 510,870 870,1260 1260,1470
And so now things are
所以现在的情况是，我认为垃圾收集的抢占延迟实际上最终是有界的，

2678
01:04:18,350 --> 01:04:20,330
0,150 150,900 900,1140 1140,1590 1590,1980
I think the preemption delays

2679
01:04:20,330 --> 01:04:21,410
0,120 120,420 420,750 750,810 810,1080
for garbage collection are actually

2680
01:04:21,410 --> 01:04:22,970
0,390 390,930 960,1350 1350,1470 1470,1560
bounded finally,| but from the
|但从一开始，模型就是你知道他们在抢先运行

2681
01:04:22,970 --> 01:04:24,410
0,330 330,390 390,840 840,1050 1050,1440
start, the model has been

2682
01:04:24,530 --> 01:04:25,820
0,480 510,630 630,720 720,930 930,1290
that you know they're running

2683
01:04:25,820 --> 01:04:27,620
0,810 870,1350 1350,1440 1440,1620 1620,1800
preemptively| and they don't get
|当他们被先发制人时，他们无法控制。

2684
01:04:27,620 --> 01:04:28,580
0,390 390,510 510,720 720,810 810,960
control over when they get

2685
01:04:28,580 --> 01:04:29,540
0,450
preempted.|
|

2686
01:04:30,980 --> 01:04:31,970
0,420 420,630 630,750 750,930 930,990
{} As a sort of
作为一个接下来的问题，

2687
01:04:31,970 --> 01:04:33,770
0,360 360,690 690,900 900,1080 1080,1800
following question,| someone else asked
|其他人问他们可以在源代码树中的哪里找到更多关于Goroutine和Goroutine调度器的信息。

2688
01:04:33,950 --> 01:04:35,120
0,420 420,510 510,630 630,930 930,1170
where they can look in

2689
01:04:35,120 --> 01:04:35,840
0,90 90,360 360,510 510,570 570,720
the source tree to learn

2690
01:04:35,840 --> 01:04:37,670
0,120 120,360 360,450 450,1080 1470,1830
more about {goroutines -} and

2691
01:04:38,120 --> 01:04:40,070
0,270 270,510 510,1230 1500,1830 1830,1950
{goroutine -} scheduler.| And the
|答案是，这基本上是一个小操作系统，

2692
01:04:40,070 --> 01:04:41,120
0,240 240,330 330,540 540,930 930,1050
answer is that, this is

2693
01:04:41,120 --> 01:04:42,590
0,420 420,510 510,690 690,1020 1020,1470
basically a little operating system,|
|

2694
01:04:42,620 --> 01:04:43,460
0,180 180,300 300,360 360,540 540,840
like it's a little operating
就像是一个建立在其他操作系统之上的小操作系统，

2695
01:04:43,460 --> 01:04:44,420
0,240 240,420 420,570 570,720 720,960
system that sits on top

2696
01:04:44,420 --> 01:04:45,890
0,330 450,570 570,780 780,1080 1080,1470
of the other operating system,|
|

2697
01:04:45,890 --> 01:04:47,000
0,390 390,570 570,750 750,990 990,1110
instead of on top of
而不是在CPU之上。

2698
01:04:47,000 --> 01:04:48,980
0,390 390,660 1050,1590
{CPUs -} {}.|
|

2699
01:04:49,100 --> 01:04:49,970
0,120 120,240 240,540 540,750 750,870
And so the first thing
所以首先要做的是取6.828，

2700
01:04:49,970 --> 01:04:50,750
0,60 60,150 150,360 360,570 570,780
to do is take {6.828

2701
01:04:50,750 --> 01:04:51,650
0,120 120,240 240,480 480,660 660,900
- - -},| which is
|这就像我我的意思是我我在6.828和xv6上工作

2702
01:04:51,650 --> 01:04:53,090
0,330 690,900 900,1050 1050,1200 1200,1440
like I I mean I

2703
01:04:53,090 --> 01:04:54,320
0,300 330,630 630,720 720,1080 1080,1230
I worked on {6.828 -

2704
01:04:54,320 --> 01:04:56,810
0,240 240,720 720,990 990,1560 1740,2490
-} and {xv6 -}| {like,literally}
|就像是在我去做围棋运行前的一两年

2705
01:04:56,810 --> 01:04:57,620
0,210 210,300 300,540 540,630 630,810
like the year or two

2706
01:04:57,620 --> 01:04:58,700
0,660 660,720 720,870 870,960 960,1080
before I went and did

2707
01:04:58,700 --> 01:04:59,600
0,60 60,240 240,690 690,780 780,900
the Go runtime| and so
|因此，在Go运行时有大量的位置。

2708
01:04:59,600 --> 01:05:00,530
0,300 300,330 330,630 630,840 840,930
there's a huge amount of

2709
01:05:00,530 --> 01:05:01,910
0,570 570,660 660,720 720,870 870,1380
situate in the go runtime.|
|

2710
01:05:02,400 --> 01:05:03,930
0,480 510,720 720,900 900,1110 1110,1530
{} And in the actual
在实际的Go运行时目录中，有一个名为pro.go的文件，

2711
01:05:03,930 --> 01:05:05,520
0,120 120,450 450,1080 1200,1500 1500,1590
go runtime directory, there's a

2712
01:05:05,520 --> 01:05:06,720
0,240 240,480 480,780 780,990 990,1200
file called {proc.go - -},|
|

2713
01:05:06,720 --> 01:05:07,800
0,240 240,480 480,570 570,720 720,1080
which is you know proc
这就是你知道的Proc Stand Process，

2714
01:05:07,800 --> 01:05:09,330
0,390 390,840 840,1200 1200,1410 1410,1530
stands process,| because that's what
|因为它在操作系统中就是这样的

2715
01:05:09,330 --> 01:05:10,410
0,90 90,240 240,510 630,780 780,1080
it is in the operating

2716
01:05:10,410 --> 01:05:12,360
0,510 930,1410 1410,1560 1560,1680 1680,1950
systems| and I would start
|我会从那里开始，这是开始的文件，然后有点牵线搭桥。

2717
01:05:12,360 --> 01:05:13,440
0,330 330,600 600,720 720,990 990,1080
there that's the file to

2718
01:05:13,440 --> 01:05:14,460
0,270 270,510 510,600 600,780 810,1020
start with and then sort

2719
01:05:14,460 --> 01:05:16,160
0,90 90,420 420,570 570,1260
of pull on strings.|
|

2720
01:05:17,930 --> 01:05:19,880
0,360 360,600 600,840 840,1230 1230,1950
{} Someone asked about Python,
有人问到了关于Python的问题，这是一种负索引，

2721
01:05:19,910 --> 01:05:21,680
0,180 180,270 270,660 660,1440 1530,1770
sort of negative indexing,| where
|你可以写成x减去1

2722
01:05:21,680 --> 01:05:22,610
0,90 90,210 210,390 390,630 630,930
you can write x minus

2723
01:05:22,610 --> 01:05:24,380
0,480 900,1290 1290,1470 1470,1650 1650,1770
one| and that comes up
|这一点引起了很多人的注意，尤其是来自Python程序员

2724
01:05:24,380 --> 01:05:25,730
0,60 60,420 450,870 870,1020 1020,1350
a lot especially from Python

2725
01:05:25,730 --> 01:05:27,860
0,600 990,1380 1380,1560 1560,1830 1830,2130
programmers| and and it seems
|而且这看起来是一个非常棒的想法，你写这些非常好的优雅的程序，

2726
01:05:27,860 --> 01:05:28,850
0,120 120,270 270,510 510,720 720,990
like a really great idea

2727
01:05:28,850 --> 01:05:29,900
0,120 120,270 270,450 450,810 810,1050
you write these really nice

2728
01:05:29,900 --> 01:05:31,400
0,330 330,840 840,1260 1260,1380 1380,1500
elegant programs,| where you want
|如果你想得到最后一个元素，你只需说x减去1。

2729
01:05:31,400 --> 01:05:32,210
0,60 60,150 150,240 240,540 540,810
to get the last element,

2730
01:05:32,210 --> 01:05:33,020
0,60 60,180 180,300 300,510 510,810
you just say x minus

2731
01:05:33,020 --> 01:05:33,980
0,420
one.|
|

2732
01:05:33,980 --> 01:05:35,240
0,270 270,390 390,630 630,1020 1020,1260
But the real problem is
但真正的问题是，你有i的x，

2733
01:05:35,240 --> 01:05:36,170
0,360 360,480 480,630 630,840 840,930
that you have x of

2734
01:05:36,170 --> 01:05:37,280
0,570 690,870 870,960 960,1080 1080,1110
i,| and you have a
|你有一个循环，就像从n到0倒计时

2735
01:05:37,280 --> 01:05:38,690
0,330 330,480 480,660 660,1020 1020,1410
loop that's like counting down

2736
01:05:38,690 --> 01:05:40,040
0,360 390,690 690,810 810,1110 1110,1350
from from you know n

2737
01:05:40,040 --> 01:05:41,330
0,90 90,780 840,1110 1110,1200 1200,1290
to zero| and you have
|你可以在某处减去一次，现在x减去一次

2738
01:05:41,330 --> 01:05:42,440
0,90 90,240 240,330 330,630 630,1110
an off by one somewhere

2739
01:05:42,440 --> 01:05:43,640
0,360 420,660 660,870 870,930 930,1200
and now x of minus

2740
01:05:43,640 --> 01:05:45,350
0,240 240,570 570,690 690,1200 1290,1710
one| instead of being x
|当我是负一的时候，而不是我的x，

2741
01:05:45,350 --> 01:05:46,490
0,150 150,480 480,720 720,960 960,1140
of i, when i is

2742
01:05:46,490 --> 01:05:47,750
0,300 300,690 720,1050 1050,1110 1110,1260
minus one,| instead of being
|而不是一个错误，你立即说，嘿，有一个错误，我需要找到它，

2743
01:05:47,750 --> 01:05:49,280
0,150 150,450 450,600 600,750 1080,1530
an error where you immediately

2744
01:05:49,280 --> 01:05:50,060
0,120 120,240 240,420 420,510 510,780
say hey, there's a bug

2745
01:05:50,060 --> 01:05:50,870
0,30 30,150 150,240 240,510 510,810
I need to find that,|
|

2746
01:05:50,990 --> 01:05:52,550
0,240 240,540 540,1020 1020,1470 1470,1560
it just silently grabs the
它只是静默地从数组的另一端获取元素

2747
01:05:52,550 --> 01:05:53,480
0,300 300,480 480,600 600,810 810,930
element off the other end

2748
01:05:53,480 --> 01:05:55,580
0,90 90,180 180,750 1140,1650 1650,2100
of the array| and that's
|这就是你所知道的那种巨蟒，

2749
01:05:55,580 --> 01:05:56,630
0,510 510,630 630,750 750,870 870,1050
where you know the sort

2750
01:05:56,630 --> 01:05:58,580
0,90 90,900
of Python,|
|

2751
01:05:58,610 --> 01:06:00,950
0,120 120,390 750,1650 1680,2100 2100,2340
you know, simplicity makes things
你知道，简单只会让事情变得更糟

2752
01:06:00,950 --> 01:06:02,600
0,570 930,1320 1320,1410 1410,1560 1560,1650
worse| and so that was
|这就是为什么我们把它省略了，

2753
01:06:02,600 --> 01:06:03,350
0,150 150,240 240,480 480,600 600,750
why we left it out,|
|

2754
01:06:03,350 --> 01:06:04,220
0,240 240,300 300,510 510,810 810,870
because it was going to
因为它会隐藏太多的错误，我们买了。

2755
01:06:04,220 --> 01:06:05,690
0,390 390,900 900,1050 1050,1350 1350,1470
hide bugs too much, we

2756
01:06:05,690 --> 01:06:06,580
0,330
bought.|
|

2757
01:06:07,750 --> 01:06:08,710
0,270 270,330 330,450 450,600 600,960
You know you could imagine
你可以想象这样的情况，比如x减去一美元，len减去一，不是x的直线，而是len。

2758
01:06:08,710 --> 01:06:09,610
0,270 270,390 390,540 540,690 690,900
something where you say like

2759
01:06:09,610 --> 01:06:11,080
0,270 270,510 510,900 900,1200 1200,1470
x of dollar minus one,

2760
01:06:11,080 --> 01:06:12,490
0,150 150,480 480,810 810,1170 1170,1410
{} len minus one, not

2761
01:06:12,490 --> 01:06:13,300
0,150 150,270 270,510 510,600 600,810
line of x, but just

2762
01:06:13,300 --> 01:06:14,440
0,510
len.|
|

2763
01:06:14,440 --> 01:06:15,220
0,240 270,390 390,510 510,630 630,780
But you know it seemed
但你知道，这看起来太特殊了

2764
01:06:15,220 --> 01:06:15,790
0,150 150,270 270,390 390,480 480,570
like too much of a

2765
01:06:15,790 --> 01:06:17,470
0,300 300,870 870,1140 1140,1500 1500,1680
special case| and really it
|事实上，这一点还不够多。

2766
01:06:17,470 --> 01:06:19,080
0,210 210,390 390,540 540,1110
doesn't come up enough.|
|

2767
01:06:20,430 --> 01:06:23,130
0,870 1200,1560 1560,1830 1830,2310 2310,2700
{} Someone asked about {}
有人问你，你知道围棋的哪个方面最难实施吗？

2768
01:06:23,130 --> 01:06:24,420
0,120 120,450 540,840 840,1200 1200,1290
you know what aspect of

2769
01:06:24,420 --> 01:06:25,800
0,180 180,300 300,750 750,810 810,1380
Go was hardest to implement.|
|

2770
01:06:26,780 --> 01:06:28,100
0,180 180,510 510,900 930,1080 1080,1320
And honestly like a lot
老实说，这其中的许多事情并不是很难，

2771
01:06:28,100 --> 01:06:28,730
0,60 60,180 180,300 300,450 450,630
of this is not very

2772
01:06:28,730 --> 01:06:30,740
0,420 750,1050 1050,1440 1440,1740 1740,2010
hard,| {} we've done most
|我们以前已经完成了大部分工作，我们已经编写了操作系统

2773
01:06:30,740 --> 01:06:31,910
0,60 60,210 210,780 810,990 990,1170
of this before, we've written

2774
01:06:31,910 --> 01:06:33,920
0,330 330,930 930,1140 1200,1470 1470,2010
operating systems| and reading libraries
|以及读取库和通道实现，

2775
01:06:33,920 --> 01:06:35,780
0,120 120,390 390,1230 1410,1650 1650,1860
and channel implementations,| and so
|因此，再做一次这一切是相当简单的，

2776
01:06:35,780 --> 01:06:36,680
0,210 210,360 360,510 510,750 750,900
doing all that again was

2777
01:06:36,680 --> 01:06:39,380
0,330 330,1050 1470,2010 2100,2610 2610,2700
fairly straightforward,| the hardest thing
|最难的可能是垃圾收集器。

2778
01:06:39,380 --> 01:06:40,760
0,150 150,390 390,450 450,780 780,1380
was probably the garbage collector.|
|

2779
01:06:41,680 --> 01:06:43,270
0,270 270,660 660,960 960,1380 1380,1590
{} Go is unique among
Go在垃圾收集语言中是唯一的

2780
01:06:43,270 --> 01:06:44,770
0,300 300,570 570,1080 1080,1200 1200,1500
garbage collected languages| and that
|它让程序员可以更好地控制内存布局，

2781
01:06:44,920 --> 01:06:46,090
0,300 300,510 510,930 930,990 990,1170
it gives programmers a lot

2782
01:06:46,090 --> 01:06:47,590
0,150 150,600 600,780 780,1050 1050,1500
more control over memory layout,|
|

2783
01:06:47,590 --> 01:06:48,250
0,210 210,360 360,480 480,600 600,660
so if you want to
因此，如果你想要一个内部有两个不同结构的结构，

2784
01:06:48,250 --> 01:06:49,150
0,150 150,180 180,630 630,750 750,900
have a structure with two

2785
01:06:49,150 --> 01:06:50,890
0,450 480,780 780,1140 1140,1530 1530,1740
different other structures inside it,|
|

2786
01:06:51,010 --> 01:06:52,060
0,330 330,480 480,690 690,870 870,1050
that's just one big chunk
这只是一大块内存，

2787
01:06:52,060 --> 01:06:53,890
0,90 90,600 720,1050 1050,1350 1380,1830
of memory,| it's not {a,struct}
|它不是一个指向其他内存块的指针的结构。

2788
01:06:53,890 --> 01:06:54,970
0,120 120,570 570,690 690,840 840,1080
with pointers to to other

2789
01:06:54,970 --> 01:06:56,120
0,270 270,330 330,690
chunks of memory.|
|

2790
01:06:56,330 --> 01:06:57,230
0,210 210,480 480,540 540,810 810,900
And because of that, and
正因为如此，您可以获取结构中第二个字段的地址，并将其传递

2791
01:06:57,230 --> 01:06:58,100
0,120 120,210 210,390 390,480 480,870
you can take the address

2792
01:06:58,100 --> 01:06:59,630
0,360 360,450 450,750 750,1020 1020,1530
of the second field {in,struct}

2793
01:06:59,630 --> 01:07:01,160
0,90 90,360 360,510 510,960 1380,1530
and pass that around| and
|这意味着垃圾回收器必须能够处理指针

2794
01:07:01,160 --> 01:07:02,090
0,90 90,240 240,300 300,630 630,930
that means the garbage collector

2795
01:07:02,090 --> 01:07:02,570
0,180 180,240 240,300 300,420 420,480
has to be able to

2796
01:07:02,570 --> 01:07:04,100
0,180 180,330 330,450 450,1200 1350,1530
deal with a pointer| that
|可以指向已分配对象中间的

2797
01:07:04,100 --> 01:07:05,240
0,120 120,450 450,660 660,750 750,1140
could point into the middle

2798
01:07:05,240 --> 01:07:06,470
0,90 90,150 150,630 630,1140 1140,1230
of an allocated object| and
|而这正是Java、Lisp和其他东西所不能做到的。

2799
01:07:06,470 --> 01:07:07,730
0,180 180,330 330,630 630,840 840,1260
that's just something that Java

2800
01:07:07,730 --> 01:07:08,690
0,150 150,420 420,510 510,690 690,960
and Lisp and other things

2801
01:07:08,690 --> 01:07:09,900
0,180 180,390 390,630
just don't do.|
|

2802
01:07:10,360 --> 01:07:11,830
0,450 630,900 900,990 990,1290 1290,1470
{} And so that makes
这使得垃圾收集器在如何维护其数据结构方面变得更加复杂。

2803
01:07:11,830 --> 01:07:12,730
0,90 90,360 360,660 660,720 720,900
the garbage collector a lot

2804
01:07:12,730 --> 01:07:14,320
0,270 270,810 810,1170 1170,1440 1440,1590
more complicated in how it

2805
01:07:14,320 --> 01:07:16,180
0,330 330,450 450,660 660,1440
maintains its data structures.|
|

2806
01:07:16,180 --> 01:07:17,230
0,150 150,270 270,540 540,870 870,1050
And we also knew from
我们也从一开始就知道，你真的想要低延迟，

2807
01:07:17,230 --> 01:07:18,610
0,90 90,450 450,810 870,1140 1140,1380
the start, that you really

2808
01:07:18,610 --> 01:07:19,900
0,240 240,450 450,960 960,1200 1200,1290
want low latency,| because if
|因为如果您正在处理网络请求，

2809
01:07:19,900 --> 01:07:22,450
0,120 120,510 510,1110 1110,1860 2010,2550
you're handling network requests {},|
|

2810
01:07:22,450 --> 01:07:24,640
0,180 180,810 1110,1350 1350,1680 1680,2190
you can't, you just pause
你不能，你只需暂停200毫秒

2811
01:07:24,640 --> 01:07:26,890
0,120 120,1140 1140,1440 1440,1770 1770,2250
for {200,milliseconds} while| and block
|并阻止所有正在进行的垃圾收集请求，

2812
01:07:26,890 --> 01:07:28,270
0,330 330,420 420,810 810,960 960,1380
all of those in progress

2813
01:07:28,270 --> 01:07:29,260
0,480 480,540 540,660 660,720 720,990
request to do a garbage

2814
01:07:29,260 --> 01:07:30,190
0,330 330,420 420,600 600,840 840,930
collection,| it really needs to
|它真的需要你知道低延迟，而不是停止

2815
01:07:30,190 --> 01:07:32,290
0,330 630,810 810,1290 1320,1530 1530,2100
be you know low latency

2816
01:07:32,290 --> 01:07:33,730
0,90 90,390 390,720 720,1170 1170,1440
and not stop things| and
|我们认为多核处理器在那里会是一个很好的机会，

2817
01:07:33,730 --> 01:07:34,720
0,150 150,330 330,450 450,750 750,990
we thought that {multi-core -}

2818
01:07:34,720 --> 01:07:36,250
0,150 150,240 240,390 390,930 1230,1530
would be a good good

2819
01:07:36,250 --> 01:07:37,390
0,480 480,690 690,930 930,1050 1050,1140
opportunity there,| because we could
|因为我们可以让垃圾收集器执行一个核心

2820
01:07:37,390 --> 01:07:38,680
0,120 120,210 210,510 510,810 810,1290
have the garbage collector doing

2821
01:07:38,680 --> 01:07:40,330
0,270 270,810 960,1350 1350,1440 1440,1650
one core| and the Go
|和使用其他内核的围棋程序

2822
01:07:40,330 --> 01:07:41,710
0,330 330,570 570,630 630,810 810,1380
program using the other cores|
|

2823
01:07:41,710 --> 01:07:42,700
0,360 360,480 480,630 630,810 810,990
and that might work really
这可能真的很管用

2824
01:07:42,700 --> 01:07:43,900
0,330 330,450 450,570 570,840 840,1200
well| and that actually did
|事实证明，这确实很管用，

2825
01:07:43,990 --> 01:07:44,950
0,240 240,450 450,540 540,750 750,960
turn out to work really

2826
01:07:44,950 --> 01:07:46,840
0,450 630,930 930,1050 1050,1500 1500,1890
well,| but it required hiring
|但这需要聘请一位真正的垃圾收集专家

2827
01:07:46,840 --> 01:07:48,070
0,120 120,330 330,780 780,900 900,1230
a real expert in garbage

2828
01:07:48,070 --> 01:07:50,440
0,600 720,1200 1200,1620 1680,2070 2070,2370
collection| to {} like figure
|想要弄清楚怎么做，并让它发挥作用，

2829
01:07:50,440 --> 01:07:51,190
0,90 90,180 180,270 270,450 450,750
out how to do it,

2830
01:07:51,880 --> 01:07:53,200
0,330 330,660 660,810 810,900 900,1320
{} and make it work,|
|

2831
01:07:53,290 --> 01:07:54,910
0,450 450,660 660,1140 1140,1290 1290,1620
but now it's really great.|
但现在它真的很棒。|

2832
01:07:55,700 --> 01:07:56,810
0,390 480,690 690,930 930,1020 1020,1110
{} I I have a
我有一个简短的问题，

2833
01:07:56,810 --> 01:07:59,810
0,180 180,660 690,1320 1320,2220 2610,3000
quick question,| you said like
|你说如果它是结构，

2834
01:07:59,840 --> 01:08:01,760
0,180 180,330 330,1110 1440,1680 1680,1920
if it's struct,| like it's
|就像在另一个结构中声明的一样，

2835
01:08:01,760 --> 01:08:03,800
0,420 420,750 750,1020 1020,1560 1890,2040
declared inside another struct,| it
|它实际上是一大块内存。

2836
01:08:03,800 --> 01:08:05,480
0,780 780,960 960,1200 1200,1440 1440,1680
actually is a big chunk

2837
01:08:05,480 --> 01:08:07,520
0,90 90,600 780,1140 1140,1740 1740,2040
of memory.| Yeah.| Why, why
|嗯。|为什么，你为什么要这样实施，

2838
01:08:07,520 --> 01:08:08,510
0,180 180,360 360,750 750,840 840,990
did you implement it like

2839
01:08:08,510 --> 01:08:10,010
0,390 510,780 780,870 870,1200 1200,1500
that,| what's the reason behind
|这背后的原因是什么。

2840
01:08:10,010 --> 01:08:12,470
0,300 1200,1830 1830,2100 2100,2370 2370,2460
that.| Well, so there's a
|好吧，这有几个原因，

2841
01:08:12,470 --> 01:08:13,400
0,210 210,480 480,660 660,810 810,930
couple reasons,| one is for
|一个是垃圾收集器，这是一项服务

2842
01:08:13,400 --> 01:08:14,690
0,90 90,390 390,960 960,1230 1230,1290
a garbage collector, it's a

2843
01:08:14,690 --> 01:08:16,190
0,780 810,1050 1050,1140 1140,1410 1410,1500
service| and the load on
|垃圾收集器上的负载与您分配的对象数量成正比

2844
01:08:16,190 --> 01:08:18,050
0,60 60,360 360,750 750,1140 1140,1860
the garbage collector is proportional

2845
01:08:18,050 --> 01:08:19,040
0,150 150,270 270,540 540,630 630,990
to the number of objects

2846
01:08:19,040 --> 01:08:20,570
0,90 90,570 870,1020 1020,1290 1320,1530
you allocate| and so if
|因此，如果你有一个由五件事组成的结构，

2847
01:08:20,570 --> 01:08:21,740
0,150 150,450 450,750 750,1110 1110,1170
you have a structure of

2848
01:08:21,740 --> 01:08:22,520
0,270 270,480 480,570 570,690 690,780
five things in it,| you
|你可以只分配一次，

2849
01:08:22,520 --> 01:08:23,900
0,90 90,210 210,360 360,570 570,1380
can make that one allocation,|
|

2850
01:08:23,960 --> 01:08:25,520
0,390 390,750 750,1140 1140,1260 1260,1560
that's a fifth of the
这是垃圾收集器负荷的五分之一

2851
01:08:25,550 --> 01:08:26,570
0,330 330,420 420,480 480,780 780,1020
load on the garbage collector|
|

2852
01:08:26,570 --> 01:08:27,110
0,90 90,210 210,390 390,480 480,540
and that turns out to
事实证明，这一点非常重要。

2853
01:08:27,110 --> 01:08:28,160
0,120 120,300 300,720
be really important.|
|

2854
01:08:28,450 --> 01:08:29,260
0,240 240,330 330,510 510,660 660,810
But the other thing that's
但另一件真正重要的事情是缓存位置正确，

2855
01:08:29,260 --> 01:08:31,060
0,150 150,630 810,1170 1170,1560 1560,1800
really important is cache {locality

2856
01:08:31,060 --> 01:08:32,380
0,240 690,900 900,1080 1080,1170 1170,1320
-} right,| like if you
|例如，如果处理器正在以64字节块或其他任何形式获取内存块

2857
01:08:32,380 --> 01:08:33,910
0,270 270,600 600,1110 1110,1230 1230,1530
have the processor is pulling

2858
01:08:33,910 --> 01:08:35,230
0,120 120,390 390,480 480,930 930,1320
in chunks of memory in

2859
01:08:35,380 --> 01:08:36,730
0,510 510,720 720,1020 1020,1080 1080,1350
64 byte chunks or whatever

2860
01:08:36,730 --> 01:08:37,690
0,90 90,330 450,690 690,810 810,960
it is| and it's much
|整体的阅读记忆比分散的阅读记忆要好得多。

2861
01:08:37,690 --> 01:08:39,670
0,330 330,510 510,840 840,1140 1140,1980
better reading memory that's altogether

2862
01:08:39,700 --> 01:08:41,050
0,210 210,420 420,630 630,810 810,1350
than reading memory that's scattered.|
|

2863
01:08:41,710 --> 01:08:43,780
0,180 180,510 1080,1590 1590,1770 1770,2070
And so you know we
所以你知道，我们在谷歌有一台Git服务器，名为Gerrit，

2864
01:08:43,780 --> 01:08:44,710
0,90 90,180 180,390 390,810 810,930
have a git server at

2865
01:08:44,710 --> 01:08:46,570
0,450 450,720 720,1110 1290,1740 1740,1860
Google called Gerrit,| that is
|它是用Java编写的，

2866
01:08:46,570 --> 01:08:47,590
0,180 180,240 240,810 840,960 960,1020
written in Java,| and it
|在围棋刚刚问世的时候，它才刚刚开始

2867
01:08:47,590 --> 01:08:48,580
0,150 150,420 420,840 840,930 930,990
was just starting at the

2868
01:08:48,580 --> 01:08:50,590
0,330 330,810 810,1080 1080,1680 1710,2010
time that Go was just

2869
01:08:50,590 --> 01:08:52,510
0,240 240,480 840,1200 1200,1560 1560,1920
coming out| and we just
|我们刚刚错过了Gerritt的写作，我想一年后就走了，

2870
01:08:52,510 --> 01:08:53,590
0,240 240,450 450,720 720,870 870,1080
missed like Gerrit being written

2871
01:08:53,590 --> 01:08:54,340
0,90 90,270 270,390 390,600 600,750
and Go I think by

2872
01:08:54,340 --> 01:08:56,770
0,270 270,630 1320,1860 1890,2160 2160,2430
a year,| {} we talked
|我们和给杰瑞特写信的那个人谈过

2873
01:08:56,770 --> 01:08:57,850
0,90 90,420 420,630 630,750 750,1080
to the guy who had

2874
01:08:57,850 --> 01:08:59,080
0,180 180,630 780,930 930,1050 1050,1230
written Gerrit| and he said
|他说杰里特最大的问题之一就是你只做了一次散列

2875
01:08:59,080 --> 01:09:00,370
0,210 210,390 390,450 450,780 810,1290
that one of the biggest

2876
01:09:00,370 --> 01:09:02,020
0,450 450,810 810,1110 1110,1260 1260,1650
problems in Gerrit was like

2877
01:09:02,140 --> 01:09:03,100
0,210 210,360 360,570 570,840 840,960
you have only shot one

2878
01:09:03,100 --> 01:09:04,690
0,780 840,1050 1050,1200 1200,1470 1470,1590
hashes| and just having the
|只有20个字节的想法。

2879
01:09:04,690 --> 01:09:06,540
0,300 300,420 420,810 810,1560
idea of twenty bytes.|
|

2880
01:09:06,540 --> 01:09:07,680
0,60 60,150 150,810 810,900 900,1140
It is impossible to have
在Java中是不可能有的，

2881
01:09:07,680 --> 01:09:08,580
0,90 90,390 420,570 570,750 750,900
in Java,| you can't just
|结构中不能只有20个字节，

2882
01:09:08,580 --> 01:09:10,440
0,180 180,420 420,720 720,1410 1680,1860
have twenty bytes {in,struct},| you
|您必须具有指向对象的指针

2883
01:09:10,440 --> 01:09:11,340
0,180 180,240 240,390 390,480 480,900
have to have a pointer

2884
01:09:11,340 --> 01:09:12,780
0,180 180,240 240,930 1110,1350 1350,1440
to an object| and the
|像你这样的对象，你甚至不能在对象中有20个字节，

2885
01:09:12,780 --> 01:09:14,880
0,480 510,870 1260,1740 1770,1950 1950,2100
object like you, you can't

2886
01:09:14,880 --> 01:09:15,570
0,120 120,210 210,390 390,630 630,690
even have twenty bytes in

2887
01:09:15,570 --> 01:09:16,320
0,90 90,510 510,570 570,690 690,750
the object,| you have to
|您必须声明五个类似的不同插入才能获得20个字节

2888
01:09:16,320 --> 01:09:18,210
0,480 480,870 870,1200 1200,1590 1590,1890
declare five different insert something

2889
01:09:18,210 --> 01:09:19,110
0,180 180,420 420,510 510,660 660,900
like that to get twenty

2890
01:09:19,110 --> 01:09:21,180
0,570 930,1230 1230,1470 1470,1770 1770,2070
bytes| and there's just no
|而且没有好的方法去做

2891
01:09:21,180 --> 01:09:22,170
0,150 150,270 270,360 360,570 570,990
good way to do it|
|

2892
01:09:22,170 --> 01:09:23,520
0,300 330,480 480,630 630,750 750,1350
and it's just the overhead
这只是一件如此简单的事情的开销，

2893
01:09:23,520 --> 01:09:24,450
0,150 150,360 360,420 420,780 780,930
of just a simple thing

2894
01:09:24,450 --> 01:09:26,430
0,210 210,630 870,1320 1320,1590 1590,1980
like that,| really adds up.|
|真的很有道理。|

2895
01:09:27,080 --> 01:09:28,700
0,540 570,780 780,1230 1260,1380 1380,1620
{} And so you know
所以你知道我们认为让程序员控制内存是非常重要的。

2896
01:09:28,730 --> 01:09:30,200
0,150 150,480 480,720 720,1110 1110,1470
we thought giving programmers control

2897
01:09:30,200 --> 01:09:31,550
0,150 150,480 480,630 630,870 870,1350
over memory was really important.|
|

2898
01:09:33,660 --> 01:09:34,780
0,600

2899
01:09:35,180 --> 01:09:37,130
0,660 660,1200 1200,1500 1500,1800 1800,1950
So, another question was was
所以，另一个问题是关于自动并行化，

2900
01:09:37,130 --> 01:09:38,930
0,330 330,720 720,1440 1440,1680 1680,1800
about automatic parallelization,| like for
|比如for循环之类的东西，

2901
01:09:38,930 --> 01:09:40,100
0,480 480,600 600,750 750,870 870,1170
loops and things like that,|
|

2902
01:09:40,130 --> 01:09:41,240
0,210 210,450 450,630 630,930 930,1110
we don't do anything like
我们不会做这样的事，

2903
01:09:41,240 --> 01:09:42,320
0,240 240,330 330,420 420,750 750,1080
that,| and the standard {Go,tool}
|和标准的围棋工具链，

2904
01:09:42,320 --> 01:09:44,720
0,450 570,1440 1440,1680 1680,1890 1890,2400
chain,| there are go compilers
|有针对GCC和llvm的围棋前端的围棋编译器。

2905
01:09:44,720 --> 01:09:46,310
0,420 420,810 810,960 960,1470 1470,1590
{for,Go} frontend for GCC and

2906
01:09:46,310 --> 01:09:48,080
0,750 1080,1230 1230,1590 1590,1710 1710,1770
llvm| and so to the
|因此，在某种程度上，它们在C语言中进行了这种循环优化，

2907
01:09:48,080 --> 01:09:49,160
0,300 300,420 420,720 720,840 840,1080
extent that those do those

2908
01:09:49,160 --> 01:09:50,360
0,150 150,240 240,450 450,1080 1080,1200
kind of loop optimization in

2909
01:09:50,360 --> 01:09:51,860
0,540 570,720 720,1080 1170,1290 1290,1500
C,| I think you know
|我想你知道我们从围棋朋友那里得到了同样的东西，

2910
01:09:52,010 --> 01:09:52,910
0,210 210,330 330,420 420,720 720,900
we get the same from

2911
01:09:52,910 --> 01:09:54,650
0,270 270,780 780,900 900,1260 1440,1740
the {Go,friends} for those,| but
|但这不是我们谷歌通常需要的那种并行化，

2912
01:09:54,650 --> 01:09:56,030
0,480 480,630 630,720 720,1110 1110,1380
it's not the kind of

2913
01:09:56,030 --> 01:09:57,980
0,840 840,1050 1050,1260 1260,1650 1650,1950
parallelization that we typically need

2914
01:09:57,980 --> 01:09:59,600
0,90 90,540 570,870 870,1110 1110,1620
at Google,| it's it's more,
|这是更多的，你知道很多服务器运行不同的东西

2915
01:09:59,960 --> 01:10:00,950
0,360 360,480 480,660 660,930 930,990
{} you know lots of

2916
01:10:00,950 --> 01:10:02,900
0,480 480,720 720,1020 1020,1590 1590,1950
servers running different things| and
|所以你知道那种你知道的，就像那种大的矢量数学之类的东西，

2917
01:10:02,900 --> 01:10:03,890
0,180 180,540 570,690 690,810 810,990
and so you know that

2918
01:10:03,890 --> 01:10:04,700
0,210 210,420
sort of

2919
01:10:04,980 --> 01:10:06,000
0,120 120,270 270,540 540,780 810,1020
you know, like the sort

2920
01:10:06,000 --> 01:10:07,140
0,60 60,270 270,630 630,990 990,1140
of big vector math kind

2921
01:10:07,140 --> 01:10:08,070
0,60 60,360 360,630 630,780 780,930
of stuff,| doesn't come up
|不会出现太多的问题，

2922
01:10:08,070 --> 01:10:08,910
0,120 120,330 330,450 450,660 660,840
as much,| so it just
|所以这对我们来说并不那么重要。

2923
01:10:08,910 --> 01:10:10,470
0,270 270,630 900,1080 1080,1470 1470,1560
hasn't been that important to

2924
01:10:10,470 --> 01:10:11,340
0,450
us.|
|

2925
01:10:12,140 --> 01:10:14,150
0,660 690,840 840,1170 1320,1740 1740,2010
{} And then the last
然后我现在的最后一个问题是，

2926
01:10:14,150 --> 01:10:14,840
0,210 210,270 270,360 360,450 450,690
question I have right now,|
|

2927
01:10:14,840 --> 01:10:17,120
0,180 180,390 390,900 960,2010 2010,2280
is that someone asked about
是有人问你如何决定何时获得释放锁吗？

2928
01:10:17,120 --> 01:10:18,200
0,150 150,210 210,300 300,900 900,1080
how do you decide when

2929
01:10:18,200 --> 01:10:19,460
0,90 90,510 510,810 810,1170 1170,1260
to acquire release locks| and
|你为什么不重新进入锁里。

2930
01:10:19,460 --> 01:10:20,240
0,90 90,210 210,270 270,420 420,780
why don't you have re-entered

2931
01:10:20,240 --> 01:10:21,650
0,480 720,1080 1080,1170 1170,1380 1380,1410
locks.| And for that I
|为此，我想回顾一下幻灯片，

2932
01:10:21,650 --> 01:10:22,400
0,150 150,210 210,360 360,690 690,750
want to go back a

2933
01:10:22,400 --> 01:10:24,540
0,480 480,570 570,660 660,1380
slide,| let me see,
|让我想想，是的，在这里，

2934
01:10:25,360 --> 01:10:28,150
0,210 210,780 1050,1230 1230,2280 2310,2790
yeah here,| so like during
|所以，就像在演讲中，我说了像锁，像新的保护地图或它保护数据，

2935
01:10:28,150 --> 01:10:29,230
0,90 90,450 450,570 570,810 810,1080
the lecture, I said things

2936
01:10:29,230 --> 01:10:30,700
0,270 270,390 390,870 900,1200 1200,1470
like the lock, like new

2937
01:10:30,700 --> 01:10:32,320
0,540 540,660 660,1200 1200,1290 1290,1620
protects the {map,or} it protects

2938
01:10:32,320 --> 01:10:33,700
0,120 120,570 900,1050 1050,1200 1200,1380
the data,| but what we
|但我们在这一点上真正的意思是，我们说的是，很多东西保护了一些不变性的集合

2939
01:10:33,700 --> 01:10:34,960
0,330 330,660 660,750 750,960 960,1260
really mean at that point

2940
01:10:34,960 --> 01:10:35,650
0,90 90,210 210,300 300,570 570,690
is that we're saying that

2941
01:10:35,650 --> 01:10:37,630
0,90 90,480 480,1080 1110,1440 1440,1980
a lot protects some collection

2942
01:10:37,630 --> 01:10:39,400
0,120 120,1020 1050,1230 1230,1650 1650,1770
of invariance| that apply to
|适用于数据真实的数据

2943
01:10:39,400 --> 01:10:40,330
0,120 120,390 390,630 630,690 690,930
the data that are true

2944
01:10:40,330 --> 01:10:41,770
0,120 120,180 180,570 930,1350 1350,1440
of the data| and the
|我们拥有锁的原因是为了保护依赖于不变性的操作

2945
01:10:41,770 --> 01:10:42,610
0,270 270,360 360,480 480,540 540,840
reason we have a lock

2946
01:10:42,610 --> 01:10:44,950
0,150 150,600 600,1170 1290,1710 1710,2340
is to protect the operations

2947
01:10:44,950 --> 01:10:46,420
0,120 120,540 540,630 630,720 720,1470
that depend on the invariance|
|

2948
01:10:46,420 --> 01:10:48,520
0,180 180,330 330,870 870,1530 1530,2100
and that sometimes temporarily invalidate
这有时会暂时使彼此之间的不变性失效。

2949
01:10:48,520 --> 01:10:50,140
0,90 90,750 780,1050 1050,1230 1230,1620
the invariance from each other.|
|

2950
01:10:50,860 --> 01:10:52,060
0,240 240,540 570,810 810,930 930,1200
And so when you call
所以当你调用lock时，你的意思是我需要利用这个锁保护的不变性

2951
01:10:52,060 --> 01:10:53,680
0,420 420,690 690,810 810,1170 1170,1620
lock, what you're saying is

2952
01:10:54,010 --> 01:10:55,120
0,240 240,510 510,600 600,900 900,1110
I need to make use

2953
01:10:55,120 --> 01:10:56,200
0,90 90,210 210,780 780,930 930,1080
of the invariance that this

2954
01:10:56,200 --> 01:10:57,700
0,270 270,900 1200,1350 1350,1440 1440,1500
lock protects| and when you
|当你给解锁打电话的时候，你说的是我不再需要它们了，

2955
01:10:57,700 --> 01:10:58,660
0,270 270,570 570,660 660,780 780,960
call unlock what you're saying

2956
01:10:58,660 --> 01:10:59,620
0,120 120,210 210,540 540,780 780,960
is I don't need them

2957
01:10:59,620 --> 01:11:01,630
0,630 660,930 930,1110 1110,1230 1230,2010
anymore,| and if I temporarily
|如果我暂时让他们无效，

2958
01:11:01,660 --> 01:11:03,820
0,990 990,1350 1470,1860 1860,2040 2040,2160
invalidated them,| I've put them
|我已经把它们放回去了，这样下一个调用lock的人就会看到正确的不变性。

2959
01:11:03,820 --> 01:11:05,080
0,450 480,720 720,870 870,930 930,1260
back, so that the next

2960
01:11:05,080 --> 01:11:06,100
0,270 270,330 330,570 570,900 900,1020
person who calls lock will

2961
01:11:06,100 --> 01:11:08,400
0,570 750,1200 1200,1830
see correct invariance.|
|

2962
01:11:08,980 --> 01:11:10,270
0,240 240,330 330,390 390,930 990,1290
So in the Mux, {you,know}
所以在多路复用器中，您知道我们想要的是每个注册的挂起通道最多得到一个回复的不变量。

2963
01:11:10,270 --> 01:11:11,500
0,270 270,480 480,570 570,1020 1020,1230
we want the invariant that

2964
01:11:11,500 --> 01:11:13,600
0,210 210,750 750,1080 1080,1710 1740,2100
each registered pending channel gets

2965
01:11:13,600 --> 01:11:15,240
0,90 90,330 330,540 540,1050
at most one reply.|
|

2966
01:11:15,700 --> 01:11:16,390
0,150 150,270 270,360 360,480 480,690
And so to do that
因此，当我们将Done从地图中删除时，

2967
01:11:16,390 --> 01:11:17,470
0,150 150,300 300,630 630,900 900,1080
when we take done out

2968
01:11:17,470 --> 01:11:18,700
0,90 90,180 180,660 690,960 960,1230
of the map,| we also
|我们还会在解锁之前将其从地图上删除，

2969
01:11:18,700 --> 01:11:19,810
0,300 300,450 450,600 600,690 690,1110
delete it from the map

2970
01:11:20,110 --> 01:11:21,670
0,390 390,540 540,930 930,1140 1410,1560
before we unlock it,| and
|如果也有一些单独的取消操作直接操作地图，

2971
01:11:21,670 --> 01:11:22,810
0,90 90,210 210,360 360,570 570,1140
if there was some separate

2972
01:11:22,810 --> 01:11:24,580
0,390 390,930 930,1050 1050,1200 1200,1770
cancel operation that was directly

2973
01:11:24,580 --> 01:11:26,050
0,480 480,570 570,810 810,930 930,1470
manipulating the map as well,|
|

2974
01:11:26,320 --> 01:11:27,790
0,210 210,390 390,900 900,1290 1320,1470
it could lock the, it
它可以锁定，它可以调用Lock，它可以将东西拿出来，调用Unlock。

2975
01:11:27,790 --> 01:11:29,260
0,120 120,360 360,900 1140,1290 1290,1470
could call lock it could

2976
01:11:29,260 --> 01:11:30,760
0,240 240,360 360,570 570,1050 1200,1500
take the thing out call

2977
01:11:30,760 --> 01:11:31,880
0,630
unlock.|
|

2978
01:11:32,110 --> 01:11:33,250
0,210 210,390 390,750 750,840 840,1140
And then, if it actually
然后，如果它真的找到了它会知道的，

2979
01:11:33,250 --> 01:11:34,510
0,270 270,480 480,570 570,720 720,1260
found one it would know,|
|

2980
01:11:34,600 --> 01:11:35,680
0,420 420,660 660,870 870,990 990,1080
no one is going to
再也不会有人送到那里去了，

2981
01:11:35,680 --> 01:11:36,940
0,270 270,360 360,600 600,990 990,1260
send to that anymore,| because
|因为我把它拿出来了，

2982
01:11:36,940 --> 01:11:39,160
0,330 330,540 540,660 660,1020 1230,2220
I took it out,| whereas
|然而，如果您知道我们编写此代码是为了在Done Equals Pending of标记和Delete之间进行额外的解锁和重新锁定，

2983
01:11:39,250 --> 01:11:40,450
0,450 510,690 690,810 810,960 960,1200
if you know we had

2984
01:11:40,450 --> 01:11:41,770
0,240 240,450 450,780 780,840 840,1320
written this code to have

2985
01:11:41,770 --> 01:11:43,450
0,510 510,840 840,1350 1350,1530 1530,1680
an extra unlock and {relock

2986
01:11:43,450 --> 01:11:45,460
0,450 450,870 870,1020 1020,1410 1440,2010
-} between the done equals

2987
01:11:45,490 --> 01:11:46,510
0,330 330,420 420,840 840,930 930,1020
pending of tag and the

2988
01:11:46,510 --> 01:11:48,580
0,570 720,1260 1290,1440 1440,1710 1710,2070
delete,| then you wouldn't have
|那么你就不会再有不变性的保护了，

2989
01:11:48,580 --> 01:11:50,470
0,360 390,1170 1170,1260 1260,1350 1350,1890
that protection of the invariance

2990
01:11:50,470 --> 01:11:51,730
0,420 420,720 720,840 840,960 960,1260
anymore,| because you would have
|因为你会把东西放回去，你已经解锁又重新锁上了，

2991
01:11:51,760 --> 01:11:53,530
0,480 480,720 720,1170 1170,1350 1350,1770
put things back, you've {unlocked

2992
01:11:53,530 --> 01:11:54,550
0,120 120,240 240,660 660,930 930,1020
-} and relocked,| while the
|而不变性则被打破了。

2993
01:11:54,550 --> 01:11:56,420
0,540 540,900 900,1320
invariance were broken.|
|

2994
01:11:56,420 --> 01:11:57,890
0,120 120,270 270,510 510,780 780,1470
And so it's really important
因此，正确地认为锁是保护不变性的，这一点非常重要。

2995
01:11:57,920 --> 01:12:00,260
0,570 600,1710 1740,1920 1920,2100 2100,2340
to correctness to think about

2996
01:12:00,260 --> 01:12:01,970
0,360 360,480 480,930 930,1050 1050,1710
locks is protecting {invariance -}.|
|

2997
01:12:02,860 --> 01:12:04,000
0,390 450,690 690,840 840,1020 1020,1140
And and so if you
因此，如果你有折返式锁，

2998
01:12:04,000 --> 01:12:05,900
0,270 270,390 390,720 720,1410
have {reentrant -} locks,|
|

2999
01:12:05,900 --> 01:12:07,280
0,450 750,960 960,1110 1110,1260 1260,1380
{} all that goes out
所有的东西都被扔到了窗外，

3000
01:12:07,280 --> 01:12:08,570
0,90 90,600 630,1050 1050,1140 1140,1290
the window,| without the {reentrant
|在没有可重入锁的情况下，当您在下一行调用lock时，

3001
01:12:08,570 --> 01:12:09,740
0,270 270,540 540,690 690,840 840,1170
-} lock, when you call

3002
01:12:09,740 --> 01:12:11,270
0,630 690,870 870,960 960,1260 1260,1530
lock on the next line,|
|

3003
01:12:11,270 --> 01:12:13,220
0,120 120,720 1110,1500 1500,1650 1650,1950
you know, okay, the lock
你知道，好吧，锁是刚拿到的所有环境都是真的，

3004
01:12:13,220 --> 01:12:14,540
0,240 240,390 390,1050 1050,1230 1230,1320
just got acquired all the

3005
01:12:14,540 --> 01:12:15,900
0,420 420,450 450,900
environments are true,|
|

3006
01:12:16,100 --> 01:12:16,640
0,150 150,210 210,300 300,420 420,540
if you have a {reentrant
如果你有一个可重入锁，

3007
01:12:16,640 --> 01:12:17,900
0,270 270,750 780,960 960,1080 1080,1260
-} lock,| all you know
|你所知道的是，当我们第一次出现在我的调用堆栈上时，无论是谁锁定了它，所有的变体都是真的。

3008
01:12:17,900 --> 01:12:19,880
0,180 180,990 1290,1470 1470,1650 1650,1980
is well all the variants

3009
01:12:19,880 --> 01:12:21,650
0,240 240,900 930,1080 1080,1440 1440,1770
were true for whoever locked

3010
01:12:21,650 --> 01:12:22,730
0,180 180,270 270,540 540,840 840,1080
this the first time we

3011
01:12:22,730 --> 01:12:23,510
0,180 180,300 300,480 480,600 600,780
might be way up here

3012
01:12:23,510 --> 01:12:24,900
0,90 90,210 210,420 420,870
on my call stack.|
|

3013
01:12:24,900 --> 01:12:26,280
0,420 420,570 570,780 780,900 900,1380
And you really know nothing,|
你真的什么都不知道，|

3014
01:12:26,820 --> 01:12:27,930
0,510 510,690 690,780 780,930 930,1110
{} and so that makes
这就使得你很难去推断你能假设什么

3015
01:12:27,930 --> 01:12:28,770
0,60 60,90 90,330 330,660 660,840
it a lot harder to

3016
01:12:28,770 --> 01:12:30,120
0,330 330,750 750,1080 1080,1230 1230,1350
reason about what can you

3017
01:12:30,120 --> 01:12:32,280
0,600 1380,1830 1830,1950 1950,2010 2010,2160
assume| and so I think
|所以我认为可重入锁真的是Java遗留下来的不幸的一部分。

3018
01:12:32,280 --> 01:12:33,300
0,90 90,330 330,630 630,720 720,1020
the reentrant locks are {}

3019
01:12:33,300 --> 01:12:34,620
0,180 180,660 660,840 840,960 960,1320
really unfortunate part of Java's

3020
01:12:34,620 --> 01:12:35,680
0,570
legacy.|
|

3021
01:12:35,770 --> 01:12:37,030
0,540 540,750 750,990 990,1110 1110,1260
Another big problem with {reentrant
可重入锁的另一个大问题是

3022
01:12:37,030 --> 01:12:37,840
0,210 210,480 480,570 570,690 690,810
-} locks is that| if
|如果您的代码在您知道的地方调用某些东西，并且它依赖于可重入锁

3023
01:12:37,840 --> 01:12:39,520
0,120 120,240 240,930 1050,1590 1590,1680
you have code where you

3024
01:12:39,520 --> 01:12:40,810
0,120 120,270 270,630 630,1140 1140,1290
know you call something and

3025
01:12:40,810 --> 01:12:41,800
0,240 240,390 390,780 780,900 900,990
it is depending {on -}

3026
01:12:41,800 --> 01:12:43,480
0,120 120,360 360,840 870,1410 1410,1680
a reentrant lock| for something
|因为你已经获得了上面的锁。

3027
01:12:43,480 --> 01:12:44,410
0,150 150,270 270,600 600,690 690,930
where you've acquired the lock

3028
01:12:44,410 --> 01:12:45,740
0,90 90,690
up above.|
|

3029
01:12:45,940 --> 01:12:47,260
0,480 480,750 750,900 900,1110 1110,1320
And then, at some point
然后，在某个时候，你说你知道什么，

3030
01:12:47,260 --> 01:12:47,980
0,90 90,240 240,360 360,420 420,720
you say you know what,|
|

3031
01:12:48,010 --> 01:12:49,000
0,390 390,480 480,630 630,870 870,990
actually I want to have
实际上，我想暂停一下，或者我想这么做，

3032
01:12:49,000 --> 01:12:49,930
0,90 90,480 480,600 600,840 840,930
a timeout on this or

3033
01:12:49,930 --> 01:12:50,680
0,60 60,210 210,270 270,510 510,750
I want to do it,|
|

3034
01:12:50,680 --> 01:12:51,820
0,60 60,630 630,780 780,960 960,1140
you know in some other
你知道，在我等待其他事情的时候，

3035
01:12:51,820 --> 01:12:52,840
0,390 390,570 570,690 690,930 930,1020
goroutine while I wait for

3036
01:12:52,840 --> 01:12:54,430
0,270 270,750 870,1140 1140,1260 1260,1590
something else,| when you move
|当您将该代码移动到不同的Goroutine时，

3037
01:12:54,430 --> 01:12:55,300
0,210 210,480 480,540 540,600 600,870
that code to a different

3038
01:12:55,300 --> 01:12:57,400
0,660 840,1110 1110,1470 1470,1770 1770,2100
goroutine,| {reentrant -} always means
|可重入总是意味着锁定在同一堆栈上，

3039
01:12:57,400 --> 01:12:58,810
0,420 420,540 540,600 600,930 930,1410
locked on the same stack,|
|

3040
01:12:58,810 --> 01:13:00,160
0,180 180,420 420,720 720,1200 1200,1350
that's the only plausible thing
这可能是唯一可信的意思

3041
01:13:00,160 --> 01:13:02,080
0,120 120,240 240,630 630,990 1380,1920
it could possibly mean| and
|因此，如果您将执行可重入锁的代码移动到不同的堆栈上，

3042
01:13:02,080 --> 01:13:02,800
0,150 150,240 240,360 360,630 630,720
so if you move the

3043
01:13:02,800 --> 01:13:03,970
0,330 330,480 480,630 630,930 930,1170
code that was {doing -}

3044
01:13:03,970 --> 01:13:05,440
0,150 150,480 480,930 1110,1410 1410,1470
the reentrant lock onto a

3045
01:13:05,440 --> 01:13:06,800
0,330 330,900
different stack,|
|

3046
01:13:06,800 --> 01:13:07,700
0,150 150,300 300,420 420,480 480,900
then it's going to deadlock,|
然后它就会陷入僵局，|

3047
01:13:07,700 --> 01:13:09,470
0,450 480,1230 1230,1350 1350,1500 1500,1770
because deadlock is now actually
因为死锁现在实际上将是一个真正的锁获取

3048
01:13:09,470 --> 01:13:10,100
0,120 120,180 180,300 300,420 420,630
going to be a real

3049
01:13:10,100 --> 01:13:11,270
0,300 300,810 810,930 930,1050 1050,1170
lock acquire| and it's going
|它会等着你放开锁，

3050
01:13:11,270 --> 01:13:12,170
0,90 90,180 180,510 510,690 690,900
to be waiting for you

3051
01:13:12,170 --> 01:13:12,770
0,60 60,240 240,420 420,510 510,600
to let Go of the

3052
01:13:12,770 --> 01:13:13,670
0,510 510,630 630,720 720,840 840,900
lock,| you're not going to
|你不会放手的，

3053
01:13:13,670 --> 01:13:14,300
0,120 120,240 240,330 330,420 420,630
let Go of it,| because
|因为您认为代码需要完成运行。

3054
01:13:14,300 --> 01:13:15,590
0,390 390,690 720,960 960,1140 1140,1290
you think that code needs

3055
01:13:15,590 --> 01:13:16,910
0,90 90,360 360,690 1080,1230 1230,1320
to finish running.| So it's
|因此，它实际上从根本上与重构完全不兼容，在重构中，您需要使用代码

3056
01:13:16,910 --> 01:13:19,340
0,420 420,960 960,1470 1470,2100 2100,2430
actually completely fundamentally incompatible with

3057
01:13:19,460 --> 01:13:21,260
0,930 930,1080 1080,1260 1260,1530 1530,1800
restructurings where you take code|
|

3058
01:13:21,260 --> 01:13:22,220
0,120 120,240 240,510 510,660 660,960
and run it in different
并在不同的线程或不同的Goroutine中运行它。

3059
01:13:22,220 --> 01:13:23,570
0,360 360,420 420,720 720,840 840,1350
threads or different {goroutines -}.|
|

3060
01:13:24,160 --> 01:13:25,450
0,180 180,480 480,720 720,960 960,1290
And so anyway, my advice,
因此，无论如何，我的建议是，只要考虑一下锁保护变种

3061
01:13:25,450 --> 01:13:26,470
0,210 210,330 330,450 450,870 870,1020
there is to just think

3062
01:13:26,470 --> 01:13:28,720
0,210 210,600 600,1050 1050,1770 2010,2250
about locks protecting variants| and
|然后你就知道，只要避免依赖可折入锁，

3063
01:13:28,720 --> 01:13:30,460
0,210 210,450 450,750 780,1350 1350,1740
then {you,know} just avoid depending

3064
01:13:30,460 --> 01:13:31,930
0,150 150,270 270,540 540,990 990,1470
on {reentrant -} locks,| it
|它真的不能很好地扩展到真正的程序。

3065
01:13:32,020 --> 01:13:33,700
0,270 300,630 630,1050 1050,1380 1380,1680
it really just doesn't scale

3066
01:13:33,700 --> 01:13:35,920
0,270 270,600 690,1020 1020,1620 1920,2220
well to real programs.| So
|所以我会把这张清单放回去，

3067
01:13:35,920 --> 01:13:36,670
0,150 150,270 270,390 390,540 540,750
I'll put this list back

3068
01:13:36,670 --> 01:13:38,170
0,480 510,1200 1200,1290 1290,1410 1410,1500
up,| actually we have that
|事实上，我们有足够长的时间，我可以试着想出如何停止展示。

3069
01:13:38,170 --> 01:13:38,890
0,150 150,300 300,510 510,600 600,720
up long enough I can

3070
01:13:38,890 --> 01:13:39,430
0,150 150,240 240,420 420,480 480,540
try to figure out how

3071
01:13:39,430 --> 01:13:40,800
0,90 90,360 360,900
to stop presenting.|
|

3072
01:13:41,060 --> 01:13:42,140
0,600 630,780 780,870 870,960 960,1080
{} And then I can
然后我可以再回答几个问题。

3073
01:13:42,140 --> 01:13:43,340
0,180 180,240 240,330 330,480 480,1200
take a few more questions.|
|

3074
01:13:46,560 --> 01:13:48,570
0,270 270,840 1320,1470 1470,1950 1950,2010
Anyone has.| I had a
每个人都有。|我有个问题，

3075
01:13:48,570 --> 01:13:51,360
0,690 1200,1770 1770,2190 2220,2610 2610,2790
question,| {} I mean I
|我的意思是，我，我认为来自Python的东西非常有用，

3076
01:13:51,360 --> 01:13:52,890
0,210 210,480 480,780 780,900 900,1530
I think coming from Python

3077
01:13:52,980 --> 01:13:55,350
0,300 300,690 1080,1890 1920,2250 2250,2370
gets very useful right,| it's
|使用像映射或过滤之类的标准函数操作是非常常见的，

3078
01:13:55,350 --> 01:13:57,240
0,210 210,720 1080,1230 1230,1500 1500,1890
very common to use like

3079
01:13:57,240 --> 01:13:59,820
0,480 480,900 900,1590 1590,1890 1890,2580
standard functional operations like map

3080
01:14:00,180 --> 01:14:02,820
0,600 660,1710 1980,2250 2250,2370 2370,2640
or filter stuff like that,|
|

3081
01:14:02,820 --> 01:14:04,300
0,1020
like,
就像，就像理解列表一样，

3082
01:14:04,450 --> 01:14:07,930
0,240 240,810 810,1620 2040,2730 2940,3480
like list comprehension,| and when
|当你知道我转到Go开始编程时，

3083
01:14:07,960 --> 01:14:09,010
0,120 120,270 270,510 540,930 930,1050
you know I switched over

3084
01:14:09,010 --> 01:14:10,480
0,90 90,270 270,390 390,720 720,1470
to Go and started programming,|
|

3085
01:14:10,630 --> 01:14:12,190
0,420 420,750 750,960 960,1230 1230,1560
it's used, I I looked
它是用过的，我查了一下，人们说你不应该这样做，用GO做这个。

3086
01:14:12,190 --> 01:14:13,480
0,90 90,360 360,570 570,930 930,1290
it up and people say

3087
01:14:13,480 --> 01:14:14,740
0,210 210,510 510,720 720,1080 1080,1260
you shouldn't do this, do

3088
01:14:14,740 --> 01:14:16,150
0,210 210,390 390,870 900,1260 1260,1410
this with Go.| Right.| I
|正确的。|我想知道为什么。

3089
01:14:16,150 --> 01:14:17,660
0,150 150,450 450,870
was wondering why.|
|

3090
01:14:17,750 --> 01:14:19,130
0,480 600,930 930,990 990,1170 1170,1380
Um, well, I mean one
嗯，好吧，我的意思是，你不能用另一种方式，

3091
01:14:19,130 --> 01:14:20,600
0,120 120,960 990,1140 1140,1380 1380,1470
is that you can't do

3092
01:14:20,600 --> 01:14:21,200
0,60 60,120 120,270 270,420 420,600
it the other way,| so
|所以你可以做你能做的事，

3093
01:14:21,200 --> 01:14:21,860
0,150 150,240 240,420 420,600 600,660
you might just do the

3094
01:14:21,860 --> 01:14:22,490
0,150 150,240 240,330 330,450 450,630
way you can do it,|
|

3095
01:14:23,540 --> 01:14:25,550
0,1110 1200,1470 1470,1740 1740,1800 1800,2010
but a bigger a bigger
但一个更大更大的问题是。

3096
01:14:25,550 --> 01:14:27,040
0,240 240,390 390,720
issue is that.|
|

3097
01:14:27,580 --> 01:14:29,680
0,330 330,1260 1260,1500 1500,1740 1740,2100
Well, there's, that one answer.|
好吧，有，有一个答案。|

3098
01:14:29,680 --> 01:14:30,940
0,90 90,300 300,630 630,840 840,1260
The other answer is that,|
另一个答案是，|

3099
01:14:31,390 --> 01:14:33,160
0,690 780,900 900,1290 1410,1650 1650,1770
{} you know if you
你知道如果你这么做的话，

3100
01:14:33,160 --> 01:14:33,760
0,120 120,210 210,360 360,510 510,600
do it that way,| you
|实际上，你最终制造了大量的垃圾，

3101
01:14:33,760 --> 01:14:34,600
0,300 300,390 390,540 540,780 780,840
actually end up creating a

3102
01:14:34,600 --> 01:14:35,860
0,180 180,240 240,960 990,1170 1170,1260
lot of garbage,| and if
|如果你不想给垃圾收集器带来太多的负担，

3103
01:14:35,860 --> 01:14:37,330
0,150 150,420 420,1020 1020,1260 1260,1470
you care about not putting

3104
01:14:37,330 --> 01:14:37,960
0,120 120,300 300,480 480,570 570,630
too much load on the

3105
01:14:37,960 --> 01:14:38,980
0,300 300,630 630,810 810,960 960,1020
garbage collector,| that kind of
|这是另一种避免这种情况的方式，

3106
01:14:38,980 --> 01:14:40,660
0,120 120,420 420,840 870,1260 1290,1680
is another way to avoid

3107
01:14:40,660 --> 01:14:42,610
0,330 930,1320 1320,1500 1500,1740 1770,1950
that,| {} you know, so
|你知道，如果你有一张地图，然后是一个过滤器，然后是另一张地图，

3108
01:14:42,610 --> 01:14:44,200
0,120 120,240 240,810 1020,1200 1200,1590
if you've got a map

3109
01:14:44,200 --> 01:14:45,010
0,90 90,180 180,270 270,720 720,810
and then a filter and

3110
01:14:45,010 --> 01:14:46,420
0,120 120,420 420,960 960,1260 1260,1410
then another map,| like you
|比如你可以对数据进行一次循环，而不是对数据进行三次循环，

3111
01:14:46,420 --> 01:14:47,200
0,90 90,210 210,330 330,600 600,780
can make that one loop

3112
01:14:47,200 --> 01:14:48,220
0,210 210,300 300,600 600,930 930,1020
over the data instead of

3113
01:14:48,220 --> 01:14:49,180
0,180 180,420 420,570 570,660 660,960
three loops over the data,|
|

3114
01:14:49,180 --> 01:14:50,080
0,210 210,300 300,450 450,810 810,900
each of which generate a
每一种都会产生一种新的垃圾。

3115
01:14:50,080 --> 01:14:51,740
0,270 270,480 480,570 570,1020
new piece of garbage.|
|

3116
01:14:51,860 --> 01:14:52,960
0,540

3117
01:14:53,390 --> 01:14:54,560
0,330 330,420 420,720 750,1050 1050,1170
But you know now that
但你知道现在我们有了仿制药，

3118
01:14:54,560 --> 01:14:56,540
0,90 90,180 180,570 570,960 1410,1980
we have generics coming,| you'll
|实际上，您可以编写这些函数，

3119
01:14:56,540 --> 01:14:57,290
0,210 210,270 270,420 420,540 540,750
actually be able to write

3120
01:14:57,290 --> 01:14:58,250
0,180 180,510 510,660 660,750 750,960
those functions,| like you couldn't
|就像你不能真正写出以前那些函数的类型签名一样，

3121
01:14:58,250 --> 01:14:59,240
0,300 300,540 540,660 660,750 750,990
actually write what the type

3122
01:14:59,240 --> 01:15:00,470
0,330 330,390 390,540 540,900 900,1230
signature of those functions were

3123
01:15:00,470 --> 01:15:01,970
0,480 510,690 690,840 840,1140 1140,1500
before,| and so you literally
|所以从字面上看，你不可能写出它们。

3124
01:15:01,970 --> 01:15:03,200
0,210 210,420 420,660
couldn't write them.|
|

3125
01:15:03,200 --> 01:15:04,190
0,180 180,510 510,690 690,870 870,990
And python gets away with
而且，因为没有静态类型，所以Python可以逃脱这一点。

3126
01:15:04,190 --> 01:15:05,990
0,180 180,360 360,570 570,1200 1230,1800
this, because there's no static

3127
01:15:05,990 --> 01:15:07,610
0,630 720,1050 1050,1230 1230,1380 1380,1620
types.| But now we're actually
|但现在我们实际上有一种方法可以做到这一点

3128
01:15:07,610 --> 01:15:08,150
0,120 120,180 180,330 330,390 390,540
going to have a way

3129
01:15:08,150 --> 01:15:08,750
0,60 60,240 240,420 420,510 510,600
to do that| and I
|我完全期待一旦有新的仿制药进入，

3130
01:15:08,750 --> 01:15:10,220
0,420 420,960 960,1080 1080,1380 1380,1470
totally expect that once new

3131
01:15:10,220 --> 01:15:11,030
0,240 240,540 540,630 630,720 720,810
generics {go,in} there,| will be
|将是一个包装切片，如果您导入切片，

3132
01:15:11,030 --> 01:15:12,200
0,90 90,450 450,990 990,1080 1080,1170
a package slices and if

3133
01:15:12,200 --> 01:15:13,400
0,150 150,450 450,960 960,1110 1110,1200
you import slices,| you can
|您可以执行slices.map和slics.Filter和Slics.Unique或类似的操作

3134
01:15:13,400 --> 01:15:14,510
0,120 120,510 510,690 690,990 990,1110
do {slices.map - -} and

3135
01:15:14,510 --> 01:15:16,580
0,330 330,510 510,990 1230,1710 1710,2070
{slices.filter - -} and {slices.unique

3136
01:15:16,580 --> 01:15:17,840
0,180 180,660 720,810 810,1110 1110,1260
- -} or something like

3137
01:15:17,840 --> 01:15:19,220
0,540 540,660 660,750 750,1050 1140,1380
that| and I think those
|我认为这些都会发生，

3138
01:15:19,220 --> 01:15:20,990
0,90 90,270 270,780 930,1410 1560,1770
will all happen,| {} and
|你知道如果这是对的，那就太好了。

3139
01:15:20,990 --> 01:15:21,950
0,90 90,240 240,570 600,750 750,960
you know if if that's

3140
01:15:21,950 --> 01:15:22,700
0,90 90,270 270,450 450,570 570,750
the right thing, then that's

3141
01:15:22,700 --> 01:15:23,420
0,300
great.|
|

3142
01:15:25,900 --> 01:15:28,360
0,450 720,1380
Thanks.| Sure.|
谢谢。|好的。|

3143
01:15:28,820 --> 01:15:30,470
0,270 270,390 390,960 1110,1290 1290,1650
{} I have, that one
我有，你有过的一个暗示，

3144
01:15:30,470 --> 01:15:31,430
0,90 90,240 240,660 660,810 810,960
of the hints that you

3145
01:15:31,430 --> 01:15:33,650
0,540 960,1350 1350,1470 1470,1680 1680,2220
had,| {} it was about
|它是关于同时运行独立的大猩猩程序，

3146
01:15:33,650 --> 01:15:36,170
0,660 930,1170 1170,1620 1620,1830 1830,2520
running {goroutines -} that are

3147
01:15:36,200 --> 01:15:39,700
0,990 1170,1470 1470,2160 2190,2670
independent like concurrently {},|
|

3148
01:15:40,230 --> 01:15:41,550
0,240 240,450 450,600 600,690 690,1320
and some of the examples
还有一些代码的例子，我想我能理解，

3149
01:15:41,550 --> 01:15:42,870
0,120 120,210 210,540 540,810 990,1320
of the code, I think

3150
01:15:42,870 --> 01:15:44,480
0,60 60,300 300,990
I could understand,|
|

3151
01:15:44,660 --> 01:15:45,500
0,210 210,450 450,510 510,630 630,840
it seems to me like
在我看来，您可以在同一个线程中调用函数，而不是在不同的线程中调用。

3152
01:15:45,500 --> 01:15:47,240
0,120 120,420 420,900 1200,1440 1440,1740
you can just like call

3153
01:15:47,240 --> 01:15:48,920
0,90 90,750 1110,1290 1290,1380 1380,1680
the function in the same

3154
01:15:48,920 --> 01:15:51,290
0,630 900,1560 1590,1770 1770,1920 1920,2370
thread rather than a different

3155
01:15:51,290 --> 01:15:52,280
0,450
thread.|
|

3156
01:15:52,340 --> 01:15:53,720
0,330 330,330 330,870 900,1140 1140,1380
And I was not sure
我不知道你为什么要换个思路来称呼它。

3157
01:15:53,720 --> 01:15:54,530
0,300 300,390 390,510 510,720 720,810
why you would call it

3158
01:15:54,530 --> 01:15:56,120
0,90 90,150 150,540 540,990
in a different thread.|
|

3159
01:15:56,290 --> 01:15:57,800
0,390 390,990
So, {}
所以，通常是因为你想让他们独立进行，

3160
01:15:57,860 --> 01:15:59,450
0,540 540,690 690,990 990,1140 1140,1590
usually it's because you want

3161
01:15:59,450 --> 01:16:01,790
0,240 240,390 390,870 870,1680 1800,2340
them to proceed independently,| so
|所以在其中一个例子中，我们有，

3162
01:16:01,790 --> 01:16:03,110
0,0 480,720 720,960 960,1170 1170,1320
{} so in one of

3163
01:16:03,110 --> 01:16:04,340
0,360 390,540 540,630 630,690 690,1230
the one of the examples,

3164
01:16:04,340 --> 01:16:06,080
0,120 120,480 480,1020 1050,1590 1620,1740
we had,| like the there
|例如，有一个循环将您知道的任务发送到工作队列，

3165
01:16:06,080 --> 01:16:06,800
0,150 150,210 210,480 480,570 570,720
was a loop that was

3166
01:16:06,800 --> 01:16:08,990
0,540 540,1080 1290,2010 2010,2100 2100,2190
sending {you,know} tasks to the

3167
01:16:08,990 --> 01:16:10,200
0,240 240,690
work queue,|
|

3168
01:16:10,560 --> 01:16:12,300
0,420 510,870 870,1140 1140,1260 1260,1740
but there was the servers
但服务器在不同的Goroutine中运行

3169
01:16:12,300 --> 01:16:13,230
0,120 120,330 330,450 450,810 810,930
were running in different {goroutines

3170
01:16:13,230 --> 01:16:14,520
0,510 510,750 750,1050 1050,1200 1200,1290
-}| and reading from the
|并从工作队列中读取并做工作，

3171
01:16:14,520 --> 01:16:15,750
0,240 240,390 390,510 510,720 720,1230
work queue and doing work,|
|

3172
01:16:15,900 --> 01:16:16,650
0,270 270,420 420,540 540,630 630,750
but then when they were
但是当他们完成的时候，

3173
01:16:16,650 --> 01:16:18,060
0,330 330,450 450,600 600,1080 1110,1410
done,| they would send a
|他们会把你知道的，嘿，我说完了，发到Done频道，

3174
01:16:18,060 --> 01:16:19,020
0,90 90,360 390,600 600,720 720,960
you know hey I'm done

3175
01:16:19,020 --> 01:16:20,460
0,360 390,540 540,660 660,900 900,1440
now to the done channel,|
|

3176
01:16:20,790 --> 01:16:22,920
0,300 330,1050 1050,1380 1380,1710 1710,2130
but ascending Go doesn't complete
但是，直到接收真正与之匹配时，提升的GO才会完成。

3177
01:16:22,920 --> 01:16:25,200
0,240 240,360 360,1110 1170,1830 1830,2280
until the receive actually matches

3178
01:16:25,200 --> 01:16:26,120
0,180 180,450
with it.|
|

3179
01:16:26,150 --> 01:16:27,350
0,180 180,630 660,870 870,1020 1020,1200
And so if the thing
因此，如果在工作队列中发送的内容

3180
01:16:27,350 --> 01:16:28,250
0,210 210,480 480,600 600,690 690,900
that's sending on the work

3181
01:16:28,250 --> 01:16:30,020
0,660 990,1260 1260,1500 1500,1680 1680,1770
queue| is not going to
|将不会开始从完成通道接收

3182
01:16:30,020 --> 01:16:31,220
0,240 240,750 750,900 900,990 990,1200
start receiving from the done

3183
01:16:31,220 --> 01:16:32,510
0,330 330,570 570,720 720,990 990,1290
channel| until it's done sending
|直到它完成对所有工作队列的发送

3184
01:16:32,510 --> 01:16:33,710
0,90 90,240 240,330 330,540 540,1200
to all the work queues|
|

3185
01:16:34,070 --> 01:16:35,210
0,270 270,540 540,630 630,720 720,1140
are sending all the work
正在发送工作队列中所有任务中的所有工作，

3186
01:16:35,240 --> 01:16:36,200
0,270 270,390 390,480 480,870 870,960
in all the tasks in

3187
01:16:36,200 --> 01:16:37,760
0,120 120,300 300,690 930,1380 1380,1560
the work queue,| then now
|那么现在你就陷入僵局了，

3188
01:16:37,760 --> 01:16:38,960
0,60 60,180 180,240 240,690 690,1200
you have a deadlock,| because
|因为主线程、主Goroutine正在尝试将新工作发送到服务器，

3189
01:16:38,990 --> 01:16:41,030
0,480 510,990 990,1650 1680,1830 1830,2040
the main thread, the main

3190
01:16:41,030 --> 01:16:42,380
0,120 120,780 810,1020 1020,1290 1290,1350
{goroutine -} is trying to

3191
01:16:42,380 --> 01:16:43,430
0,240 240,420 420,840 840,960 960,1050
send new work to the

3192
01:16:43,430 --> 01:16:45,140
0,720 750,1020 1020,1410 1410,1470 1470,1710
servers,| the servers are not
|服务器不接受新的工作，他们试图告诉主线程他们已经完成了，

3193
01:16:45,140 --> 01:16:46,220
0,300 300,420 420,720 720,840 840,1080
taking new work, they're trying

3194
01:16:46,220 --> 01:16:47,270
0,90 90,450 450,600 600,810 810,1050
to tell the main thread

3195
01:16:47,270 --> 01:16:48,530
0,90 90,240 240,840 960,1200 1200,1260
that they're done,| but the
|但是主线程实际上不会像从Done通道读取一样开始

3196
01:16:48,530 --> 01:16:49,280
0,240 240,420 420,480 480,630 630,750
main {thread -} not going

3197
01:16:49,280 --> 01:16:50,480
0,60 60,360 360,660 660,960 960,1200
to actually start at like

3198
01:16:50,510 --> 01:16:51,980
0,360 360,510 510,600 600,840 840,1470
reading from the done channel|
|

3199
01:16:52,160 --> 01:16:53,570
0,510 510,630 630,990 990,1260 1260,1410
until it finishes giving out
直到它完成了所有的工作

3200
01:16:53,570 --> 01:16:54,350
0,120 120,210 210,540 540,660 660,780
all the work| and so
|所以他们只是互相凝视，等待着不同的事情发生，

3201
01:16:54,350 --> 01:16:56,030
0,960 960,1110 1110,1440 1440,1530 1530,1680
there's just staring at each

3202
01:16:56,030 --> 01:16:57,170
0,210 210,510 510,630 630,930 930,1140
other, waiting for different things

3203
01:16:57,170 --> 01:16:58,880
0,60 60,540 660,1410 1440,1620 1620,1710
to happen,| whereas if we
|然而，如果我们使用这个循环，如果我们只是将小Goroutine放在发送功的循环周围，

3204
01:16:58,880 --> 01:17:00,290
0,270 270,450 450,780 780,1140 1200,1410
take that loop, that if

3205
01:17:00,290 --> 01:17:01,040
0,90 90,270 270,450 450,570 570,750
we just put the little

3206
01:17:01,040 --> 01:17:02,150
0,150 150,420 420,780 780,870 870,1110
{goroutine -} around the loop

3207
01:17:02,150 --> 01:17:03,650
0,180 180,540 540,630 630,1170 1230,1500
that's sending the work,| then
|然后就可以去别的地方了，

3208
01:17:03,650 --> 01:17:05,180
0,180 180,300 300,450 450,780 780,1530
that can go somewhere else,|
|

3209
01:17:05,210 --> 01:17:06,050
0,180 180,270 270,390 390,510 510,840
and then it can proceed
然后它就可以独立进行了，

3210
01:17:06,050 --> 01:17:07,610
0,540 540,630 630,870 870,1050 1050,1560
independently,| and while it's stuck,
|当它停滞不前，等待服务器承担更多工作时，

3211
01:17:07,640 --> 01:17:09,410
0,540 540,660 660,720 720,1230 1230,1770
waiting for the servers to

3212
01:17:09,440 --> 01:17:10,910
0,300 300,630 630,870 870,1080 1080,1470
to {} take more work,|
|

3213
01:17:10,970 --> 01:17:12,380
0,270 270,660 660,750 750,1050 1050,1410
the servers are stuck waiting
服务器停滞不前，等待主Goroutine确认它已经完成了一些工作

3214
01:17:12,380 --> 01:17:14,360
0,510 540,660 660,1260 1410,1560 1560,1980
for the main {goroutine -}

3215
01:17:14,360 --> 01:17:16,400
0,600 630,1350 1350,1590 1590,1740 1740,2040
to acknowledge that it finished

3216
01:17:16,400 --> 01:17:17,600
0,120 120,510 660,960 960,1110 1110,1200
some work| and now the
|现在，主要的大猩猩实际上进入了循环，

3217
01:17:17,600 --> 01:17:18,980
0,240 240,570 570,870 870,1080 1080,1380
main goroutine actually gets down

3218
01:17:18,980 --> 01:17:20,930
0,120 120,240 240,690 750,1260 1350,1950
to the loop,| that pulls
|那拉动它完成实际确认完成从完成通道读取的工作

3219
01:17:20,930 --> 01:17:22,670
0,120 120,510 510,690 690,1080 1110,1740
it finishes that actually acknowledges

3220
01:17:22,670 --> 01:17:23,750
0,390 390,660 660,750 750,960 960,1080
that finish the work that

3221
01:17:23,750 --> 01:17:24,800
0,210 210,360 360,450 450,660 660,1050
reads from the done channel|
|

3222
01:17:25,070 --> 01:17:25,970
0,300 300,420 420,690 690,840 840,900
and so it's just a
所以这只是一种分开的方式，

3223
01:17:25,970 --> 01:17:26,400
0,180 180,330
way to

3224
01:17:26,400 --> 01:17:27,600
0,480 480,750 750,840 840,960 960,1200
separate out,| you know these
|你知道这是两件不同的事情，从逻辑上讲，

3225
01:17:27,600 --> 01:17:28,500
0,60 60,210 210,510 510,750 750,900
are two different things that

3226
01:17:28,500 --> 01:17:30,180
0,780 840,1080 1080,1350 1350,1590 1590,1680
logically,| they didn't have to
|它们不一定要一个接一个地发生

3227
01:17:30,180 --> 01:17:31,470
0,270 270,450 450,690 690,840 840,1290
happen one after the other|
|

3228
01:17:31,650 --> 01:17:32,850
0,240 240,630 630,720 720,870 870,1200
and because they were happening
因为这些事件接二连三地发生，导致了僵局

3229
01:17:32,850 --> 01:17:33,660
0,180 180,420 420,510 510,660 660,810
one after the other that

3230
01:17:33,660 --> 01:17:34,710
0,300 300,360 360,870 870,960 960,1050
caused a deadlock| and by
|通过拿出一个并移动，它让它独立运行

3231
01:17:34,710 --> 01:17:35,910
0,330 330,600 600,840 840,930 930,1200
taking one out and moving,

3232
01:17:35,910 --> 01:17:37,350
0,150 150,270 270,360 360,630 630,1440
it let it run independently|
|

3233
01:17:38,340 --> 01:17:40,160
0,360 360,720 720,810 810,1500
that removes the deadlock.|
这就消除了僵局。|

3234
01:17:41,760 --> 01:17:43,530
0,420 420,510 510,630 630,1140 1170,1770
Thank you so much.| Sure.|
非常感谢。|好的。|

3235
01:17:44,460 --> 01:17:45,120
0,120 120,270 270,480 480,510 510,660
Could you talk a little
你能谈谈围棋的比赛检测器是如何实现的吗？

3236
01:17:45,120 --> 01:17:46,350
0,150 150,420 420,660 660,990 990,1230
bit about how Go's race

3237
01:17:46,350 --> 01:17:48,220
0,420 420,540 540,1290
detector is implemented?|
|

3238
01:17:48,250 --> 01:17:49,420
0,390 390,510 510,630 630,750 750,1170
Sure, it is the llvm
当然，这是LIVM赛车探测器，

3239
01:17:49,420 --> 01:17:52,000
0,180 180,750 1050,1440 1920,2280 2280,2580
race detector,| {} and so
|所以这可能无济于事，

3240
01:17:52,000 --> 01:17:53,500
0,150 150,360 360,570 570,1020 1020,1500
that probably doesn't help,| but
|但这正是llvm所说的线程消毒器。因此，我们实际上有一个链接到的小二进制斑点，

3241
01:17:53,500 --> 01:17:54,580
0,120 120,240 240,750 750,930 930,1080
it is exactly the thing

3242
01:17:54,580 --> 01:17:56,380
0,330 330,780 780,1110 1110,1320 1320,1800
that llvm calls thread sanitizer

3243
01:17:56,380 --> 01:17:57,180
0,330
{}.

3244
01:17:57,270 --> 01:17:58,710
0,390 390,750 960,1200 1200,1320 1320,1440
And, {} and so we

3245
01:17:58,710 --> 01:17:59,730
0,300 300,420 420,450 450,660 660,1020
actually have a little binary

3246
01:17:59,730 --> 01:18:02,430
0,600 600,1470 1530,1890 1890,2130 2130,2700
blob that we link against,|
|

3247
01:18:02,460 --> 01:18:03,270
0,450 450,540 540,630 630,750 750,810
because we don't want to
因为我们不想依赖于所有的LVM，

3248
01:18:03,270 --> 01:18:04,500
0,300 300,390 390,540 540,840 840,1230
depend on all of llvm,|
|

3249
01:18:04,650 --> 01:18:05,910
0,420 420,690 690,810 810,1140 1140,1260
but it's the llvm {race,detector
但这是LIVM赛车探测器

3250
01:18:05,910 --> 01:18:07,230
0,600 780,960 960,1050 1050,1200 1200,1320
-}| and the way {the
|而llvm竞争检测器的工作方式是它分配了大量额外的虚拟内存

3251
01:18:07,230 --> 01:18:08,640
0,450 450,570 570,900 900,1230 1230,1410
-} llvm {race,detector} works is

3252
01:18:08,640 --> 01:18:09,960
0,210 210,450 450,930 930,1050 1050,1320
that it allocates a ton

3253
01:18:09,960 --> 01:18:11,760
0,240 240,570 570,870 870,1350 1620,1800
of extra virtual memory| and
|然后根据正在读取或写入的事物的地址，

3254
01:18:11,760 --> 01:18:13,110
0,150 150,450 450,600 600,780 780,1350
then based on the address

3255
01:18:13,110 --> 01:18:14,670
0,360 510,810 810,960 960,1290 1290,1560
of of the thing being

3256
01:18:14,670 --> 01:18:16,200
0,210 210,330 330,810 960,1290 1290,1530
read or written,| it has
|它在虚拟内存中有另一个你知道的点

3257
01:18:16,200 --> 01:18:17,670
0,180 180,780 780,840 840,990 990,1470
this other you know spot

3258
01:18:17,670 --> 01:18:18,960
0,120 120,450 450,810 810,1110 1110,1290
in virtual memory| where it
|在那里它记录了关于最后一个帖子的信息，

3259
01:18:18,960 --> 01:18:21,060
0,780 810,1530 1530,1740 1740,1920 1920,2100
records information about like the

3260
01:18:21,060 --> 01:18:23,520
0,630 990,1770 1890,2190 2190,2400 2400,2460
last thread,| {you,know,it} thinks of
|你知道它想到的是线程，但它们是猩猩程序，

3261
01:18:23,520 --> 01:18:25,860
0,360 360,630 630,840 840,1380 1770,2340
threads, but they're goroutines {},|
|

3262
01:18:25,920 --> 01:18:27,120
0,390 390,600 600,720 720,990 990,1200
has where the last thread
具有执行读或写操作的最后一个线程

3263
01:18:27,120 --> 01:18:27,810
0,120 120,240 240,330 330,540 540,690
that did a read or

3264
01:18:27,810 --> 01:18:29,760
0,420 510,870 870,1230 1230,1710 1710,1950
write| and then also every
|然后，每次同步事件发生时，

3265
01:18:29,760 --> 01:18:31,440
0,210 210,270 270,870 870,1140 1140,1680
time a synchronizing event happens,|
|

3266
01:18:31,440 --> 01:18:32,730
0,330 330,390 390,540 540,630 630,1290
like you know a communication
就像你知道从一个大猩猩到另一个大猩猩的交流，

3267
01:18:32,730 --> 01:18:34,200
0,150 150,390 390,810 810,930 930,1470
from one goroutine to another,|
|

3268
01:18:34,690 --> 01:18:37,000
0,270 270,600 600,1020 1020,1410 1440,2310
{} that counts as establishing
这相当于在两个不同的猩猩之间的边缘之前确定了它的发生，

3269
01:18:37,000 --> 01:18:38,560
0,90 90,480 480,900 900,1200 1200,1560
it happens before edge between

3270
01:18:38,560 --> 01:18:40,120
0,120 120,360 360,1020 1140,1470 1470,1560
two different goroutines,| and if
|如果你得到了一些你可以读写的东西

3271
01:18:40,120 --> 01:18:41,470
0,180 180,450 450,780 780,1140 1140,1350
you ever get something where

3272
01:18:41,470 --> 01:18:43,150
0,120 120,240 240,390 390,960 1140,1680
you have a read or

3273
01:18:43,150 --> 01:18:45,220
0,540 810,1140 1140,1290 1290,1590 1590,2070
write| and they're not properly
|而且它们的序列不正确，

3274
01:18:45,220 --> 01:18:46,600
0,690 720,990 990,1170 1170,1290 1290,1380
sequence right,| like so if
|就像这样，如果你有一个读取，然后它发生在另一个Goroutine中的某个东西之前，然后再进行写入，这是很好的，

3275
01:18:46,600 --> 01:18:47,440
0,90 90,210 210,330 330,690 690,840
you have a read and

3276
01:18:47,440 --> 01:18:48,670
0,120 120,240 240,570 570,930 930,1230
then it happens before something

3277
01:18:48,670 --> 01:18:49,660
0,60 60,360 360,570 570,780 780,990
in another {goroutine -} which

3278
01:18:49,660 --> 01:18:51,220
0,570 600,930 930,1140 1140,1260 1260,1560
then later does the write,

3279
01:18:51,220 --> 01:18:52,750
0,240 240,750 960,1350 1350,1440 1440,1530
that's fine,| but if you
|但如果你有一个读取器要写，在连接它们的序列之前没有发生，那么这就是一场比赛，

3280
01:18:52,750 --> 01:18:53,500
0,90 90,210 210,390 390,510 510,750
have a read to write

3281
01:18:53,500 --> 01:18:54,640
0,90 90,270 270,420 420,810 810,1140
and there's no happens before

3282
01:18:54,640 --> 01:18:57,340
0,510 510,630 630,960 960,1350 1470,2700
sequence that connects them, then

3283
01:18:57,370 --> 01:18:58,750
0,330 330,420 420,960 990,1260 1260,1380
that's a race,| and it
|事实上，你知道，它有一些非常聪明的方法来快速动态地计算出，

3284
01:18:58,750 --> 01:19:00,130
0,630 630,720 720,960 990,1260 1260,1380
actually you know has some

3285
01:19:00,130 --> 01:19:03,280
0,240 240,960 990,1560 1560,1860 2250,3150
pretty clever ways to dynamically

3286
01:19:03,280 --> 01:19:04,750
0,390 390,600 600,1080 1080,1170 1170,1470
figure out quickly,| you know,
|您知道，这种读取发生了吗？在发生这种读取和写入之间的路径之前是否发生了这种情况

3287
01:19:04,780 --> 01:19:06,700
0,360 360,630 630,870 870,1530 1740,1920
did this read happen, is

3288
01:19:06,700 --> 01:19:07,990
0,150 150,420 420,750 750,1020 1020,1290
there happens before path between

3289
01:19:07,990 --> 01:19:08,980
0,180 180,540 540,750 750,900 900,990
this {read,and} write as they

3290
01:19:08,980 --> 01:19:10,570
0,510 690,990 990,1080 1080,1380 1380,1590
happen| and it slows down
|它可能会使程序速度减慢10倍，

3291
01:19:10,570 --> 01:19:12,130
0,60 60,450 450,960 990,1290 1290,1560
the program by maybe {10x

3292
01:19:12,130 --> 01:19:13,960
0,690 750,1170 1200,1380 1380,1650 1650,1830
-},| but you know if
|但你知道，如果你只是在那里疏导少量的交通，这可能是好的，

3293
01:19:13,960 --> 01:19:14,920
0,150 150,330 330,630 630,690 690,960
you just divert a small

3294
01:19:14,920 --> 01:19:16,210
0,180 180,240 240,600 600,1050 1080,1290
amount of traffic there, that's

3295
01:19:16,210 --> 01:19:18,100
0,300 300,780 960,1290 1290,1410 1410,1890
probably fine,| if its {for,testing},
|如果是为了测试，那可能也没问题，

3296
01:19:18,100 --> 01:19:20,020
0,180 180,420 420,720 720,1200 1470,1920
that's also probably fine,| it's
|这比不知道比赛要好得多，

3297
01:19:20,020 --> 01:19:21,370
0,180 180,420 420,840 840,1110 1110,1350
way better than not finding

3298
01:19:21,370 --> 01:19:22,450
0,90 90,270 270,360 360,870 900,1080
out about the races,| so
|所以这绝对是值得的。

3299
01:19:22,450 --> 01:19:24,010
0,150 150,420 420,660 660,840 1020,1560
it's totally worth it.| And
|老实说，十倍或二十倍是很棒的，

3300
01:19:24,010 --> 01:19:25,690
0,390 390,600 600,690 690,990 990,1680
honestly ten or twenty x

3301
01:19:25,690 --> 01:19:27,430
0,240 240,960 960,1050 1050,1530 1530,1740
is fantastic,| the original thread
|最初的线程清理或更像是10.1万倍，

3302
01:19:27,430 --> 01:19:28,510
0,450 450,510 510,630 630,810 810,1080
sanitize or was more like

3303
01:19:28,990 --> 01:19:30,100
0,120 120,420 420,540 540,870 870,1110
a hundred a thousand x,|
|

3304
01:19:30,100 --> 01:19:31,000
0,90 90,270 270,510 510,750 750,900
and that was not good
但这还不够好。

3305
01:19:31,000 --> 01:19:31,900
0,390
enough.|
|

3306
01:19:31,960 --> 01:19:32,920
0,150 150,330 330,420 420,570 570,960
Well, what's the race detector
那么，种族探测器叫什么来着，Ivm？

3307
01:19:32,920 --> 01:19:35,170
0,450 750,1170 1170,1680 1830,2100 2100,2250
called, {llvm -}?| {} It's
|它被称为线程消毒剂，但它是llvm的一部分，

3308
01:19:35,170 --> 01:19:36,370
0,210 210,450 450,930 930,1050 1050,1200
called thread sanitizer, {} but

3309
01:19:36,370 --> 01:19:38,170
0,150 150,450 450,660 660,1530 1560,1800
it's part of llvm,| which
|这就是clang C编译器，

3310
01:19:38,170 --> 01:19:39,730
0,270 270,660 690,900 900,1410 1410,1560
is {} the clang C

3311
01:19:39,730 --> 01:19:42,400
0,600 630,780 780,1110 1110,1980 2310,2670
compiler,| the one that almost
|现在几乎每个人都在用的那个，

3312
01:19:42,400 --> 01:19:45,040
0,240 240,540 540,960 1470,2040 2220,2640
everyone uses now,| {} is
|是LIVM项目的一部分。

3313
01:19:45,040 --> 01:19:46,840
0,210 210,300 300,420 420,1170 1170,1800
part of the llvm project.|
|

3314
01:19:54,740 --> 01:19:56,090
0,240 240,300 300,450 450,720 720,1350
Can you talk about slices
你能谈谈切片和设计选择吗，

3315
01:19:56,090 --> 01:19:57,650
0,390 390,600 600,930 930,1290 1290,1560
and the design choices,| having
|将它们作为数组上的视图，

3316
01:19:57,650 --> 01:19:59,360
0,180 180,390 390,750 750,1020 1020,1710
them as views on arrays,|
|

3317
01:19:59,540 --> 01:20:00,620
0,300 300,450 450,870 870,930 930,1080
which like confused me at
这让我一开始就很困惑。

3318
01:20:00,620 --> 01:20:02,660
0,510 600,1770 1770,1860 1860,1980 1980,2040
first.| Yeah, it is a
|是的，一开始有点令人困惑。

3319
01:20:02,660 --> 01:20:04,820
0,150 150,570 570,690 690,1080
little confusing at first.|
|

3320
01:20:05,420 --> 01:20:06,620
0,420 420,690 690,870 870,1020 1020,1200
The main thing is that
最重要的是，您希望它能够高效地遍历一个数组

3321
01:20:06,620 --> 01:20:07,310
0,150 150,390 390,510 510,600 600,690
you want it to be

3322
01:20:07,310 --> 01:20:08,570
0,540 540,630 630,810 810,900 900,1260
efficient to kind of walk

3323
01:20:08,570 --> 01:20:09,860
0,210 210,300 300,630 630,870 870,1290
through an array| or like
|或者，如果您可以快速排序或合并排序，或者在您拥有一组对象的情况下

3324
01:20:09,950 --> 01:20:11,150
0,300 300,390 390,570 570,780 780,1200
if you can quick sort

3325
01:20:11,210 --> 01:20:12,230
0,60 60,360 360,630 630,690 690,1020
or merge sort or something

3326
01:20:12,230 --> 01:20:12,980
0,150 150,270 270,420 420,480 480,750
where you have an array

3327
01:20:12,980 --> 01:20:14,120
0,90 90,780 780,930 930,1050 1050,1140
of things| and now you
|现在你想说，好吧，把这一半分类，把另一半分类，

3328
01:20:14,120 --> 01:20:14,780
0,120 120,180 180,330 330,510 510,660
want to say well now

3329
01:20:14,780 --> 01:20:15,950
0,300 300,480 480,810 810,930 930,1170
sort this half and sort

3330
01:20:15,950 --> 01:20:17,150
0,90 90,300 300,720 810,1080 1080,1200
the other half,| you want
|你想要能够有效地说，像这样，这是前一个的一半，你知道的，排序

3331
01:20:17,150 --> 01:20:18,260
0,90 90,210 210,450 450,570 570,1110
to be able to efficiently

3332
01:20:18,260 --> 01:20:19,730
0,240 240,570 690,1140 1140,1350 1350,1470
say like here, this is

3333
01:20:19,730 --> 01:20:20,840
0,300 300,420 420,510 510,870 870,1110
half of the previous one

3334
01:20:20,840 --> 01:20:22,790
0,360 510,750 750,1050 1050,1350 1560,1950
like {you,know} sort that| and
|所以，在C语言中，你这样做的方式是，

3335
01:20:22,790 --> 01:20:23,720
0,540
so,

3336
01:20:23,750 --> 01:20:24,800
0,300 300,480 480,810 810,900 900,1050
{} in C the way

3337
01:20:24,800 --> 01:20:25,640
0,120 120,240 240,540 540,660 660,840
you do that is,| you
|您只需传入您知道的第一个元素的指针和元素的数量

3338
01:20:25,640 --> 01:20:27,020
0,240 240,570 570,1020 1080,1230 1230,1380
just pass in you know

3339
01:20:27,020 --> 01:20:28,010
0,150 150,480 480,600 600,720 720,990
the pointer to the first

3340
01:20:28,010 --> 01:20:28,820
0,300 300,390 390,480 480,720 720,810
element and the number of

3341
01:20:28,820 --> 01:20:30,530
0,660 810,1020 1020,1230 1230,1590 1590,1710
elements| and that's basically all
|这基本上就是所有的切片

3342
01:20:30,530 --> 01:20:32,600
0,90 90,990 1170,1380 1380,1830 1920,2070
the slices| and then the
|然后是另一种模式，当您尝试高效地使用数组时，这种模式经常出现

3343
01:20:32,600 --> 01:20:33,740
0,240 240,690 690,780 780,1020 1020,1140
other pattern that comes up

3344
01:20:33,740 --> 01:20:35,480
0,30 30,390 390,570 570,1320 1380,1740
a lot when you're trying

3345
01:20:35,480 --> 01:20:36,890
0,90 90,150 150,570 570,660 660,1410
to be efficient with arrays|
|

3346
01:20:36,920 --> 01:20:38,000
0,390 390,510 510,690 690,810 810,1080
is you have to grow
就是你必须种植它们

3347
01:20:38,000 --> 01:20:39,650
0,300 600,1020 1020,1260 1260,1500 1500,1650
them| and and so you
|所以你不会想要回忆每个新元素的重新分配，

3348
01:20:39,650 --> 01:20:41,300
0,120 120,270 270,390 390,960 960,1650
don't want to recall reallocation

3349
01:20:41,300 --> 01:20:43,250
0,300 300,990 1020,1290 1290,1830 1830,1950
every single new element,| you
|你想摊销这笔钱吗

3350
01:20:43,250 --> 01:20:44,810
0,120 120,180 180,660 660,1080 1320,1560
want to amortize that| and
|所以你用C语言来做的方式是

3351
01:20:44,810 --> 01:20:45,660
0,420
so

3352
01:20:45,860 --> 01:20:46,850
0,240 240,360 360,480 480,600 600,990
the way you do that

3353
01:20:46,880 --> 01:20:48,170
0,390 390,630 630,1050 1050,1200 1200,1290
in C again is that|
|

3354
01:20:48,170 --> 01:20:49,250
0,120 120,270 270,390 390,660 660,1080
you have a base pointer,
你有一个基指针，你有你现在使用的长度

3355
01:20:49,280 --> 01:20:50,030
0,150 150,270 270,390 390,660 660,750
you have the length that

3356
01:20:50,030 --> 01:20:50,930
0,150 150,420 420,570 570,780 780,900
you're using right now| and
|你有你分配的长度

3357
01:20:50,930 --> 01:20:51,470
0,60 60,150 150,240 240,450 450,540
you have the length that

3358
01:20:51,470 --> 01:20:53,630
0,90 90,720 930,1230 1230,1620 1680,2160
you allocated| and then to
|然后，要添加一个，请检查长度是否大于分配的数量，

3359
01:20:53,630 --> 01:20:54,830
0,270 270,570 570,870 870,1080 1080,1200
add one, you check and

3360
01:20:54,830 --> 01:20:56,000
0,180 180,300 300,420 420,690 690,1170
see if the length is

3361
01:20:56,000 --> 01:20:56,810
0,270 270,420 420,480 480,720 720,810
bigger than the amount you

3362
01:20:56,810 --> 01:20:58,160
0,390 390,510 510,660 660,810 810,1350
allocate,| if so you reallocate
|如果是这样，你就重新分配，否则你就继续向前推进

3363
01:20:58,160 --> 01:20:59,150
0,180 180,570 570,660 660,840 840,990
and otherwise you just keep

3364
01:20:59,150 --> 01:21:01,190
0,270 270,390 390,840 1110,1620 1620,2040
bumping it forward| and and
|和切片实际上只是这些习语的编码，

3365
01:21:01,220 --> 01:21:02,390
0,480 480,630 630,900 900,1110 1110,1170
slices are really just an

3366
01:21:02,390 --> 01:21:04,340
0,390 390,480 480,720 720,1320 1380,1950
encoding of those idioms,| because
|因为这是管理内存的最有效方式。

3367
01:21:04,340 --> 01:21:05,720
0,270 270,570 570,690 690,960 960,1380
those are the most efficient

3368
01:21:05,720 --> 01:21:06,920
0,150 150,330 330,660 660,750 750,1200
way to manage the memory.|
|

3369
01:21:07,280 --> 01:21:08,450
0,180 180,390 390,720 720,990 990,1170
And so in any kind
所以在任何类型的C++向量或类似的东西中，

3370
01:21:08,450 --> 01:21:09,440
0,270 270,510 510,660 660,810 810,990
of like {C++ - -}

3371
01:21:09,440 --> 01:21:11,870
0,660 660,1020 1590,1920 1920,2100 2100,2430
vector or something like that,|
|

3372
01:21:11,900 --> 01:21:13,730
0,240 240,390 390,690 690,1050 1080,1830
that's what's going on underneath,|
这就是下面正在发生的事情，|

3373
01:21:13,820 --> 01:21:14,810
0,570 570,690 690,900 900,960 960,990
but it makes it a
但这使得喜欢C++向量变得更加困难，

3374
01:21:14,810 --> 01:21:16,850
0,210 210,690 690,1080 1080,1560 1710,2040
lot harder to {} like

3375
01:21:16,850 --> 01:21:18,200
0,120 120,270 270,420 420,630 630,1350
the {C++ - -} vector,|
|

3376
01:21:18,230 --> 01:21:20,390
0,420 420,510 510,1020 1020,1830 1890,2160
because of ownership reasons,| the
因为所有权的原因，|该向量被绑定到实际的底层存储器，

3377
01:21:20,390 --> 01:21:21,470
0,270 270,420 420,870 870,960 960,1080
vector is tied to the

3378
01:21:21,470 --> 01:21:22,760
0,330 330,750 750,1080 1080,1230 1230,1290
actual underlying memory,| it's a
|它很难像一个子矢量一样，

3379
01:21:22,760 --> 01:21:24,020
0,180 180,480 480,570 570,1020 1050,1260
lot harder to get like

3380
01:21:24,020 --> 01:21:25,670
0,90 90,450 450,990 990,1290 1290,1650
a sub vector,| that's just
|这只是合并排序的下半部分的视图。

3381
01:21:25,670 --> 01:21:26,900
0,90 90,390 390,780 780,930 930,1230
the view onto the second

3382
01:21:26,900 --> 01:21:28,480
0,390 390,510 510,780 780,1080
half for merge sort.|
|

3383
01:21:28,870 --> 01:21:30,400
0,540 660,1140 1140,1290 1290,1410 1410,1530
So that's sort of the
所以这就是我的想法

3384
01:21:30,400 --> 01:21:31,450
0,330 330,420 420,630 630,870 870,1050
idea| is that just like
|这就像所有这些正式访问内存的模式都来自C语言吗

3385
01:21:31,450 --> 01:21:32,230
0,120 120,180 180,270 270,390 390,780
there are all these patterns

3386
01:21:32,230 --> 01:21:33,730
0,330 360,810 810,1020 1020,1410 1410,1500
for accessing memory officially that

3387
01:21:33,730 --> 01:21:35,290
0,180 180,300 300,780 1170,1440 1440,1560
came from C| and we
|我们试图让他们以一种惯用的方式，以一种安全的方式，适应围棋。

3388
01:21:35,290 --> 01:21:36,250
0,240 240,300 300,480 480,720 720,960
tried to make them fit

3389
01:21:36,250 --> 01:21:37,870
0,180 180,600 600,750 750,1260 1260,1620
into {Go,in} an idiomatic way,

3390
01:21:38,550 --> 01:21:40,020
0,150 150,180 180,510 510,1020
in a safe way.|
|

3391
01:21:42,490 --> 01:21:43,840
0,210 210,270 270,480 480,870 870,1350
Can you talk about how
你能谈谈你是如何决定实施Go Like远程模块系统的吗，

3392
01:21:43,840 --> 01:21:46,090
0,240 240,750 750,1140 1140,1770 1830,2250
you decided to {} implement

3393
01:21:46,090 --> 01:21:47,530
0,120 120,600 630,840 840,1140 1140,1440
the Go like remote module

3394
01:21:47,530 --> 01:21:48,820
0,360 360,540 540,630 630,960 960,1290
system,| where you import directly
|您可以直接从URL导入，这类似于。

3395
01:21:48,820 --> 01:21:50,320
0,150 150,210 210,870 1200,1410 1410,1500
from a url, which is

3396
01:21:50,320 --> 01:21:52,630
0,180 180,1080 1380,1950 1980,2190 2190,2310
like.| Yeah, I mean I
|是的，我的意思是我只是不想经营一项服务

3397
01:21:52,630 --> 01:21:53,290
0,150 150,300 300,420 420,480 480,660
just didn't want to run

3398
01:21:53,290 --> 01:21:54,490
0,150 150,630 630,720 720,900 900,1200
a service| and like like
|就像你知道的那样，像红宝石这样的东西

3399
01:21:54,520 --> 01:21:55,760
0,180 180,750
you know

3400
01:21:55,760 --> 01:21:57,020
0,180 180,570 570,660 660,990 990,1260
a lot of the things

3401
01:21:57,020 --> 01:21:58,220
0,210 210,390 390,690 690,780 780,1200
like ruby gems| and those
|而这些并不是当时我脑海中浮现的，

3402
01:21:58,220 --> 01:22:00,710
0,150 150,390 390,1260 1680,2040 2160,2490
were not as for at

3403
01:22:00,710 --> 01:22:01,460
0,90 90,240 240,300 300,390 390,750
the front of my mind

3404
01:22:01,460 --> 01:22:02,510
0,120 120,210 210,630 630,810 810,1050
at the time,| just because
|仅仅因为它们是新的，

3405
01:22:02,510 --> 01:22:03,920
0,90 90,240 240,780 870,1200 1200,1410
they were newer,| but I
|但我使用Perl有一段时间了，就像CPAN一样

3406
01:22:03,920 --> 01:22:04,640
0,150 150,330 330,570 570,660 660,720
had used Perl for a

3407
01:22:04,640 --> 01:22:05,990
0,300 300,420 420,600 600,810 810,1350
while and like {CPAN -}|
|

3408
01:22:06,230 --> 01:22:07,130
0,390 390,540 540,690 690,840 840,900
and I just thought it
我只是觉得这太疯狂了

3409
01:22:07,130 --> 01:22:09,080
0,540 540,930 930,1140 1140,1470 1620,1950
was insane| that like everyone
|就像每个人都在争夺db这样的短名字一样，

3410
01:22:09,080 --> 01:22:10,160
0,120 120,450 450,660 660,840 840,1080
was fighting over these short

3411
01:22:10,160 --> 01:22:12,080
0,360 360,600 600,1170 1320,1500 1500,1920
names like db,| you know
|你知道，可能不应该有关于谁将成为数据库套餐的争论。

3412
01:22:12,200 --> 01:22:13,340
0,300 300,540 540,840 840,1020 1020,1140
there probably shouldn't be an

3413
01:22:13,340 --> 01:22:14,660
0,480 480,780 780,990 990,1200 1200,1320
argument over who gets to

3414
01:22:14,660 --> 01:22:17,580
0,330 330,510 510,900 900,1560
make the db package.|
|

3415
01:22:18,070 --> 01:22:19,150
0,180 180,330 330,570 570,870 870,1080
And so putting domain names
因此，把域名放在最前面，似乎是分散它的一个好方法

3416
01:22:19,150 --> 01:22:19,900
0,60 60,150 150,450 450,600 600,750
in the front, seemed like

3417
01:22:19,900 --> 01:22:21,010
0,60 60,210 210,360 360,420 420,1110
a good way to decentralize

3418
01:22:21,010 --> 01:22:22,570
0,150 750,1080 1080,1260 1260,1350 1350,1560
it| and it was also
|这对我们来说也是一个不运行任何服务器的好方法，

3419
01:22:22,570 --> 01:22:23,170
0,60 60,180 180,330 330,480 480,600
a good way for us

3420
01:22:23,170 --> 01:22:24,160
0,150 150,240 240,420 420,600 600,990
not to run any server,|
|

3421
01:22:24,160 --> 01:22:25,210
0,480 480,570 570,780 780,930 930,1050
because you know we could
因为你知道，我们可以说，我们会识别主机名

3422
01:22:25,210 --> 01:22:26,770
0,210 210,420 420,750 750,1080 1080,1560
just say well we'll recognize

3423
01:22:26,770 --> 01:22:28,270
0,90 90,540 540,930 990,1290 1290,1500
the hostname| and then Go
|然后从源代码管理部门，从其他人的服务器上获取它，

3424
01:22:28,270 --> 01:22:29,500
0,240 240,330 330,480 480,720 720,1230
grab it from source control,

3425
01:22:29,980 --> 01:22:31,390
0,240 240,360 360,600 600,900 900,1410
{} from someone else's server,|
|

3426
01:22:31,420 --> 01:22:32,260
0,300 300,480 480,660 660,780 780,840
and that turned out to
我认为这是一个非常棒的主意，

3427
01:22:32,260 --> 01:22:33,340
0,90 90,180 180,330 330,660 660,1080
be a really great idea

3428
01:22:33,340 --> 01:22:35,500
0,120 120,480 960,1860 1860,1980 1980,2160
I think,| because we just
|因为我们没有那种相同的基础设施，其他东西都依赖于此。

3429
01:22:35,500 --> 01:22:36,340
0,270 270,480 480,600 600,750 750,840
don't have that kind of

3430
01:22:36,340 --> 01:22:38,440
0,270 270,1110 1140,1590 1590,1830 1830,2100
same infrastructure, that other things

3431
01:22:38,440 --> 01:22:39,680
0,330 330,660
depend on.|
|

3432
01:22:40,190 --> 01:22:41,120
0,180 180,240 240,330 330,660 660,930
But in the Java world,
但在Java世界中，它实际上真的很有问题，

3433
01:22:41,120 --> 01:22:43,160
0,90 90,720 1050,1320 1320,1890 1890,2040
it's actually really problematic,| there
|有多个，没有一种标准的注册表，

3434
01:22:43,160 --> 01:22:44,960
0,150 150,900 900,1110 1110,1380 1380,1800
are multiple, there's no sort

3435
01:22:44,960 --> 01:22:46,430
0,90 90,600 600,1200 1200,1380 1380,1470
of standard registry,| but they
|但他们都用这些短名字

3436
01:22:46,430 --> 01:22:47,720
0,150 150,330 330,480 480,690 690,1290
all use these short names|
|

3437
01:22:47,840 --> 01:22:50,240
0,390 390,930 1020,1740 1740,2250 2250,2400
and so like maven can
因此，像maven一样，可以配置为从多个不同的注册表进行构建。

3438
01:22:50,240 --> 01:22:51,620
0,120 120,660 660,810 810,1230 1230,1380
be configured to build from

3439
01:22:51,620 --> 01:22:54,440
0,420 420,690 690,1500 1860,2370 2430,2820
multiple different registries| and if
|如果您是一家开源软件包提供商，

3440
01:22:54,440 --> 01:22:56,000
0,270 270,330 330,900 900,1230 1230,1560
you're an open-source software package

3441
01:22:56,000 --> 01:22:56,990
0,330 330,480 480,780 780,900 900,990
provider,| you actually have to
|你实际上必须四处走动，确保你把它上传到所有不同的注册处，

3442
01:22:56,990 --> 01:22:57,890
0,120 120,390 390,480 480,600 600,900
go around and be sure

3443
01:22:57,890 --> 01:22:58,640
0,90 90,240 240,540 540,600 600,750
that you upload it to

3444
01:22:58,640 --> 01:23:00,320
0,180 180,270 270,510 510,1170 1260,1680
all the different registries,| because
|因为如果你错过了一个，它就变得流行起来，

3445
01:23:00,320 --> 01:23:01,670
0,450 450,570 570,780 780,1200 1200,1350
if you miss one and

3446
01:23:01,670 --> 01:23:03,200
0,150 150,450 450,1020 1020,1260 1260,1530
it becomes popular,| someone else
|其他人会将不同的代码上传到该代码

3447
01:23:03,200 --> 01:23:04,190
0,120 120,390 390,690 690,930 930,990
will upload different code to

3448
01:23:04,190 --> 01:23:07,010
0,180 180,570 960,1800 2070,2460 2460,2820
that one| and then like
|然后，就像马文实际上只取先回来的那个一样，

3449
01:23:07,010 --> 01:23:08,150
0,270 270,540 540,660 660,870 870,1140
maven actually just takes whichever

3450
01:23:08,150 --> 01:23:09,080
0,90 90,300 300,510 510,840 840,930
one comes back first,| it
|它只是向所有人发送请求，无论最先返回的是什么，

3451
01:23:09,080 --> 01:23:10,100
0,330 330,600 600,660 660,930 930,1020
just sends a request to

3452
01:23:10,100 --> 01:23:10,940
0,150 150,210 210,330 330,540 540,840
all of them and whatever

3453
01:23:10,940 --> 01:23:12,410
0,180 180,330 330,600 600,900 1350,1470
comes back first,| so you
|这样你就知道如果有人想要恶意复制你的包裹，

3454
01:23:12,410 --> 01:23:13,190
0,90 90,240 240,480 480,660 660,780
know if someone wants to

3455
01:23:13,190 --> 01:23:14,180
0,180 180,210 210,630 630,930 930,990
make a malicious copy of

3456
01:23:14,180 --> 01:23:15,110
0,120 120,480 480,720 720,810 810,930
your package,| always do is
|总是要做的就是找到一些你忘记上传到的其他人使用的注册表

3457
01:23:15,110 --> 01:23:16,280
0,300 300,450 450,780 780,930 930,1170
find some register other people

3458
01:23:16,280 --> 01:23:17,030
0,210 210,300 300,390 390,690 690,750
use that you forgot to

3459
01:23:17,030 --> 01:23:18,290
0,270 270,390 390,690 720,930 930,1260
upload it to| and like
|就像你知道的，他们有时会赢得比赛，

3460
01:23:18,500 --> 01:23:19,190
0,120 120,270 270,420 420,570 570,690
you know they get to

3461
01:23:19,190 --> 01:23:21,650
0,420 450,570 570,1140 1200,2160 2220,2460
win the race sometimes,| so
|所以这是一个真正的问题，我认为在那里拥有域名确实有助于以非常重要的方式拆分所有权。

3462
01:23:21,650 --> 01:23:23,360
0,960 960,1050 1050,1200 1200,1530 1530,1710
it's a real problem, I

3463
01:23:23,360 --> 01:23:24,770
0,120 120,360 360,780 780,990 990,1410
think having domain there really

3464
01:23:24,980 --> 01:23:26,600
0,600 600,810 810,990 990,1080 1080,1620
helps split up the ownership

3465
01:23:26,630 --> 01:23:27,740
0,90 90,270 270,480 480,810 810,1110
in a really important way.|
|

3466
01:23:29,110 --> 01:23:30,180
0,450
{Thank,you.,Sure}.|
谢谢。好的。|

3467
01:23:34,920 --> 01:23:36,390
0,210 210,300 300,720 750,1320 1320,1470
{What -} the, maybe take
怎么了，也许在这里稍作停顿，

3468
01:23:36,390 --> 01:23:38,250
0,180 180,780 780,1110 1110,1500 1680,1860
a quick pause here,| most
|大多数必须去的人都可以去，

3469
01:23:38,250 --> 01:23:39,090
0,180 180,330 330,450 450,540 540,840
people that have to go

3470
01:23:39,090 --> 01:23:40,320
0,420 420,510 510,960 960,1170 1170,1230
{can,go},| I'm sure Russ is
|我相信拉斯愿意多待一段时间，并回答任何问题，

3471
01:23:40,320 --> 01:23:41,580
0,240 240,660 690,900 900,1110 1110,1260
willing to stick around for

3472
01:23:41,580 --> 01:23:43,500
0,90 90,240 240,690 1230,1650 1650,1920
a bit longer and answer

3473
01:23:43,500 --> 01:23:45,120
0,150 150,690 690,1200 1200,1500 1500,1620
any questions,| but I do
|但我真的要感谢拉斯的这次演讲，

3474
01:23:45,120 --> 01:23:46,380
0,180 180,240 240,540 540,990 1080,1260
want to thank Russ for

3475
01:23:46,380 --> 01:23:48,330
0,210 210,330 330,1230 1350,1800 1800,1950
giving this lecture,| hopefully this
|希望这将帮助您运行更多的Good Go程序，这些模式

3476
01:23:48,330 --> 01:23:49,620
0,120 120,540 540,690 690,960 960,1290
will help you running more

3477
01:23:49,620 --> 01:23:51,460
0,540 540,690 690,1320
good Go programs,

3478
01:23:51,460 --> 01:23:54,160
0,300 300,780 780,1470 1470,2070 2370,2700
{} these patterns| and so
|所以谢谢你，拉斯。

3479
01:23:54,280 --> 01:23:55,460
0,210 210,300 300,630
thank you Russ.|
|

3480
01:23:55,890 --> 01:23:56,760
0,180 180,510 510,630 630,810 810,870
You're welcome, it's nice to
不客气，很高兴来到这里。

3481
01:23:56,760 --> 01:23:57,720
0,120 120,420
be here.|
|

3482
01:23:58,810 --> 01:23:59,980
0,600

3483
01:24:00,180 --> 01:24:01,410
0,150 150,240 240,390 390,900 990,1230
And then more questions, feel
然后是更多的问题，请随时提问。

3484
01:24:01,410 --> 01:24:03,060
0,150 150,270 270,420 420,870 1230,1650
free to ask questions.| Yeah.|
|嗯。|

3485
01:24:03,780 --> 01:24:05,520
0,450 450,720 720,750 750,960 960,1740
Oh just a little logistical
哦，只是一点后勤上的事情，

3486
01:24:05,520 --> 01:24:07,650
0,390 720,1140 1140,1350 1350,1980 1980,2130
thing,| {} the slides that
|6.824网站上的幻灯片与拉斯的幻灯片并不完全相同。

3487
01:24:07,650 --> 01:24:08,610
0,150 150,390 390,510 510,810 810,960
are on the {6.824 -

3488
01:24:08,610 --> 01:24:09,960
0,150 150,330 330,810 810,930 930,1350
- -} website are not

3489
01:24:10,140 --> 01:24:11,820
0,720 720,840 840,1140 1140,1290 1290,1680
exactly the same as Russ's

3490
01:24:11,820 --> 01:24:17,200
0,600 630,3180 3180,3720
slides.| {I'll,get,Franz,a,new} PDF.|
|我去给弗兰兹买个新的PDF。|

3491
01:24:18,340 --> 01:24:20,080
0,210 210,480 480,840 840,1230 1230,1740
A more general question about
一个更普遍的问题是什么时候写一门新的语言，这是解决问题的最佳方案。

3492
01:24:20,640 --> 01:24:22,140
0,210 210,600 600,1050 1050,1110 1110,1500
when is writing a new

3493
01:24:22,140 --> 01:24:24,000
0,540 540,990 1020,1530 1530,1620 1620,1860
language, the like the best

3494
01:24:24,000 --> 01:24:26,190
0,600 900,1110 1110,1200 1200,1650 1920,2190
solution to a problem.| That's
|这是一个很好的问题，它几乎从来都不是最好的解决方案。

3495
01:24:26,190 --> 01:24:27,630
0,60 60,270 270,690 690,1200 1200,1440
a great question, it's almost

3496
01:24:27,630 --> 01:24:30,340
0,210 210,300 300,510 510,990
never the best solution.|
|

3497
01:24:30,340 --> 01:24:31,480
0,360 360,450 450,750 750,1080 1080,1140
But you know at the
但你知道，当时我们只有大量的程序员

3498
01:24:31,480 --> 01:24:33,010
0,390 390,510 510,720 720,1110 1410,1530
time we had just an

3499
01:24:33,010 --> 01:24:34,480
0,420 420,690 690,750 750,1290 1290,1470
enormous number of programmers| like
|就像数千名程序员在一个代码库中工作

3500
01:24:34,480 --> 01:24:35,710
0,360 360,450 450,870 870,1170 1170,1230
thousands of programmers working in

3501
01:24:35,710 --> 01:24:38,680
0,210 210,960 1230,1800 2100,2340 2340,2970
one codebase| and the compilations
|而汇编工作则耗费了很长时间，

3502
01:24:38,680 --> 01:24:40,300
0,90 90,240 240,540 540,1020 1050,1620
were just taking forever,| because
|因为C++不适合高效的增量编译。

3503
01:24:40,990 --> 01:24:41,980
0,330 330,480 480,720 720,810 810,990
{C++ - -} was just

3504
01:24:41,980 --> 01:24:44,800
0,450 450,720 720,1740 1950,2430 2430,2820
not meant for efficient incremental

3505
01:24:44,800 --> 01:24:45,940
0,630
compilation.|
|

3506
01:24:46,030 --> 01:24:49,300
0,570 570,1200 1680,2010 2010,2310 2310,3270
And so it, and furthermore
因此，而且在当时，像线程库这样的东西真的很糟糕

3507
01:24:49,840 --> 01:24:51,160
0,240 240,330 330,750 750,990 990,1320
at the time like threading

3508
01:24:51,160 --> 01:24:52,690
0,480 480,660 660,900 900,1350 1350,1530
libraries were really awful| like
|就像人们不用线一样，

3509
01:24:52,690 --> 01:24:53,740
0,240 240,420 420,630 630,840 840,1050
people just didn't use threads,|
|

3510
01:24:53,740 --> 01:24:54,430
0,30 30,330 330,510 510,630 630,690
I remember like one of
我记得在麻省理工学院的第一天，我和罗伯特聊天

3511
01:24:54,430 --> 01:24:55,330
0,120 120,510 510,720 720,780 780,900
the first days I was

3512
01:24:55,330 --> 01:24:56,260
0,60 60,510 510,660 660,870 870,930
at MIT and talking to

3513
01:24:56,260 --> 01:24:57,700
0,480 630,930 930,1200 1200,1380 1380,1440
Robert| and Robert said to
|罗伯特对我说，就像2001年他对我说，

3514
01:24:57,700 --> 01:24:59,620
0,480 510,1200 1200,1260 1260,1590 1590,1920
me, like in {2001,,he -}

3515
01:24:59,620 --> 01:25:00,340
0,150 150,210 210,300 300,540 540,720
said to me,| like we
|就像我们在这里不使用线程一样，因为线程很慢。

3516
01:25:00,340 --> 01:25:01,180
0,120 120,270 270,510 510,630 630,840
don't use threads here, because

3517
01:25:01,180 --> 01:25:02,320
0,210 210,270 270,750
threads are slow.|
|

3518
01:25:02,350 --> 01:25:03,550
0,420 420,570 570,720 720,840 840,1200
And and that was like
而这完全是正常的，

3519
01:25:03,580 --> 01:25:04,930
0,390 390,780 780,990 990,1170 1170,1350
totally normal,| that was just
|这就是当时的世界。

3520
01:25:04,930 --> 01:25:05,620
0,90 90,240 240,330 330,630 630,690
the way the world at

3521
01:25:05,620 --> 01:25:07,680
0,90 90,540 930,1500
the time {}.|
|

3522
01:25:07,960 --> 01:25:09,340
0,600 600,750 750,990 990,1140 1140,1380
And at Google we're having
在谷歌，我们遇到了很多麻烦，

3523
01:25:09,340 --> 01:25:10,600
0,90 90,360 360,420 420,930 990,1260
a lot of trouble,| because
|因为它都是基于事件的小回调和C++

3524
01:25:10,600 --> 01:25:11,890
0,60 60,180 180,570 600,900 900,1290
it was all event based

3525
01:25:11,890 --> 01:25:13,240
0,300 300,810 810,930 930,1170 1170,1350
little callbacks and {C++ -

3526
01:25:13,240 --> 01:25:15,040
0,420 600,1200 1290,1530 1530,1650 1650,1800
-}| and there were these
|有这些多核机器，我们实际上不知道如何在它们上工作，

3527
01:25:15,040 --> 01:25:16,180
0,240 240,390 390,810 810,900 900,1140
{multi-core -} machines and we

3528
01:25:16,180 --> 01:25:17,050
0,300 300,450 450,540 540,690 690,870
actually didn't know how to

3529
01:25:17,050 --> 01:25:17,920
0,270 270,480 480,570 570,780 780,870
get things to work on

3530
01:25:17,920 --> 01:25:19,390
0,120 120,360 360,690 810,1170 1170,1470
them,| because like Linux threads
|因为和Linux一样，线程也不是你可以依赖的东西

3531
01:25:19,390 --> 01:25:20,260
0,120 120,360 360,630 630,690 690,870
were not something you could

3532
01:25:20,260 --> 01:25:22,570
0,510 510,690 690,840 840,1320 1770,2310
rely on to work| and
|所以我们最终的结果就像你有一台四核机器，

3533
01:25:22,570 --> 01:25:23,680
0,180 180,330 330,540 540,780 780,1110
so we ended up like

3534
01:25:23,710 --> 01:25:24,460
0,240 240,360 360,450 450,510 510,750
if you had a four

3535
01:25:24,460 --> 01:25:25,480
0,150 150,540 540,660 660,840 840,1020
core machine,| you just run
|您只需在Web服务器的完全独立的进程中运行四个不同的进程

3536
01:25:25,480 --> 01:25:27,130
0,330 330,660 660,1080 1080,1260 1260,1650
four different process in completely

3537
01:25:27,130 --> 01:25:28,210
0,330 330,750 750,810 810,900 900,1080
independent processes of the web

3538
01:25:28,210 --> 01:25:28,990
0,300 300,390 390,540 540,720 720,780
server| and just treat it
|把它当作四台机器，

3539
01:25:28,990 --> 01:25:31,210
0,90 90,270 270,420 420,1110 1620,2220
as like four machines {},|
|

3540
01:25:31,480 --> 01:25:32,770
0,180 180,300 300,450 450,750 750,1290
and that was clearly not
这显然不是很有效率，

3541
01:25:32,770 --> 01:25:34,540
0,210 210,810 840,1500 1530,1680 1680,1770
very efficient,| so there were
|因此，有很多很好的理由去尝试一些东西。

3542
01:25:34,540 --> 01:25:35,710
0,180 180,420 420,540 540,750 750,1170
a lot of good reasons

3543
01:25:35,710 --> 01:25:37,460
0,420 450,780 780,1320
to try something.|
|

3544
01:25:37,580 --> 01:25:38,780
0,660

3545
01:25:38,900 --> 01:25:40,220
0,480 630,780 780,990 990,1290 1290,1320
But you know it's a
但你知道，要达到今天的围棋水平，需要做大量的工作

3546
01:25:40,220 --> 01:25:41,000
0,270 270,450 450,510 510,690 690,780
huge amount of work to

3547
01:25:41,000 --> 01:25:41,690
0,210 210,270 270,360 360,570 570,690
get to the point where

3548
01:25:41,690 --> 01:25:42,740
0,210 210,360 360,840 840,960 960,1050
Go is today| and I
|我认为，很多语言都不对劲，

3549
01:25:42,740 --> 01:25:45,200
0,480 1080,1620 1740,2040 2040,2250 2250,2460
think that, so much is

3550
01:25:45,200 --> 01:25:46,610
0,330 330,390 390,930 960,1170 1170,1410
not the language right,| there
|我们在语言中做了一些重要的事情，使其他考虑成为可能，

3551
01:25:46,610 --> 01:25:47,480
0,90 90,510 510,690 690,780 780,870
were important things that we

3552
01:25:47,480 --> 01:25:48,440
0,300 300,450 450,510 510,810 810,960
made in the language that

3553
01:25:48,440 --> 01:25:53,090
0,510 510,1050 1470,2490 2610,3930 4290,4650
enabled other considerations,| but so
|但很多成功的语言，

3554
01:25:53,090 --> 01:25:54,380
0,210 210,330 330,450 450,900 900,1290
much of the successful languages,|
|

3555
01:25:54,380 --> 01:25:55,490
0,120 120,600 600,810 810,960 960,1110
the ecosystem that built up
围绕它建立的生态系统和我们在GO命令中建立的工具，

3556
01:25:55,490 --> 01:25:56,480
0,330 330,420 420,540 540,600 600,990
around it and the tooling

3557
01:25:56,480 --> 01:25:57,140
0,120 120,240 240,540 540,600 600,660
that we built in the

3558
01:25:57,140 --> 01:25:58,340
0,210 210,690 690,780 780,990 1020,1200
Go command,| and like all
|而像所有这些都不像是语言上的东西。

3559
01:25:58,340 --> 01:25:59,510
0,180 180,330 330,690 690,780 780,1170
these like not the language

3560
01:25:59,510 --> 01:26:00,740
0,360 360,660
things.| So,
|所以，你知道，主要语言是一个专注于语言本身的人，

3561
01:26:00,740 --> 01:26:01,910
0,60 60,360 390,690 690,1170 1170,1170
you know primary language a

3562
01:26:02,480 --> 01:26:03,500
0,270 270,390 390,600 600,900 900,1020
people who are focused on

3563
01:26:03,500 --> 01:26:05,240
0,60 60,360 360,1080 1380,1530 1530,1740
the language itself,| I think
|我觉得有时候会被周围的事情分心，

3564
01:26:05,240 --> 01:26:06,830
0,360 360,480 480,960 960,1260 1260,1590
sometimes get distracted by all

3565
01:26:06,830 --> 01:26:07,700
0,90 90,330 330,630 630,750 750,870
the stuff around,| like they
|就像他们怀念周围的一切一样。

3566
01:26:07,700 --> 01:26:08,720
0,300 300,420 420,480 480,720 720,1020
miss all the stuff around

3567
01:26:08,720 --> 01:26:09,440
0,180
it.|
|

3568
01:26:15,250 --> 01:26:16,450
0,420 570,750 750,780 780,990 990,1200
Oh, can I ask a
哦，我能要求更多吗？

3569
01:26:16,450 --> 01:26:18,370
0,240 240,420 420,780 990,1590 1800,1920
lot from that.| Yeah.| I
|嗯。|我在想我现在是怎么做Go Different的

3570
01:26:18,370 --> 01:26:19,600
0,180 180,480 480,690 690,780 780,1230
was wondering how I was

3571
01:26:19,630 --> 01:26:21,580
0,390 390,510 510,690 690,1410 1440,1950
working on Go different now,|
|

3572
01:26:21,580 --> 01:26:23,170
0,300 300,510 510,660 660,1140 1140,1590
since it's more mature than
因为它比以前更成熟了。

3573
01:26:23,320 --> 01:26:24,960
0,150 150,360 360,1050
it was before.|
|

3574
01:26:26,050 --> 01:26:28,510
0,1170 1260,1710 1710,1770 1770,1980 1980,2460
Oh, that's a great question,|
哦，这是个好问题，|

3575
01:26:28,780 --> 01:26:29,830
0,540 630,750 750,840 840,990 990,1050
{} you know in the
你知道，在早期，做出改变是很容易的

3576
01:26:29,830 --> 01:26:30,790
0,240 240,480 480,540 540,690 690,960
early days, it was so

3577
01:26:30,790 --> 01:26:31,990
0,240 240,300 300,450 450,1020 1050,1200
easy to make changes| and
|现在要做出改变真的很难，

3578
01:26:31,990 --> 01:26:33,040
0,180 180,360 360,750 750,990 990,1050
now it's really hard to

3579
01:26:33,040 --> 01:26:34,180
0,150 150,630 660,780 780,900 900,1140
make changes,| I think that's
|我认为这是最重要的事情。

3580
01:26:34,180 --> 01:26:35,740
0,90 90,330 330,510 510,840 1020,1560
the number one thing {}.|
|

3581
01:26:36,500 --> 01:26:37,910
0,150 150,360 360,810 1170,1350 1350,1410
You know, {} in the
你知道，在早期，就像所有东西都在一个源代码存储库中一样，

3582
01:26:37,910 --> 01:26:40,070
0,240 240,540 540,990 1560,2010 2010,2160
early days, like everything was

3583
01:26:40,070 --> 01:26:41,300
0,90 90,390 390,660 660,810 810,1230
in one source code repository,|
|

3584
01:26:41,300 --> 01:26:42,140
0,330 330,480 480,540 540,720 720,840
literally all the Go code
从字面上看，世界上所有的围棋代码都是一个源代码仓库，

3585
01:26:42,140 --> 01:26:42,860
0,60 60,150 150,390 390,510 510,720
in the world was one

3586
01:26:42,860 --> 01:26:44,240
0,240 240,390 390,960 960,1080 1080,1380
source code repository,| and so
|因此，有几天我们改变了语法，

3587
01:26:44,240 --> 01:26:45,050
0,180 180,270 270,570 570,690 690,810
there were days where we

3588
01:26:45,050 --> 01:26:46,160
0,240 240,300 300,720 720,1050 1050,1110
changed the syntax,| used to
|以前每次开通频道都有明星在成龙之前，

3589
01:26:46,160 --> 01:26:47,720
0,120 120,210 240,690 690,1020 1020,1560
have a star before chan

3590
01:26:47,720 --> 01:26:48,800
0,450 450,510 510,660 660,750 750,1080
everytime you set a channel,|
|

3591
01:26:48,800 --> 01:26:50,000
0,570 630,750 750,870 870,930 930,1200
because it was a pointer
因为它下面是一个指针，

3592
01:26:50,000 --> 01:26:51,170
0,420 420,600 690,930 930,1050 1050,1170
underneath,| and it was all
|所有的一切都被曝光了，

3593
01:26:51,170 --> 01:26:52,130
0,150 150,210 210,750 750,840 840,960
kind of exposed,| so you'd
|所以你总是说star chan int而不是chan int

3594
01:26:52,130 --> 01:26:53,450
0,180 180,300 300,720 720,1080 1080,1320
always say star {chan,int} instead

3595
01:26:53,450 --> 01:26:55,520
0,90 90,630 1020,1560 1560,1920 1920,2070
of {chan,int}| and similarly for
|地图也是如此

3596
01:26:55,520 --> 01:26:56,870
0,420 420,630 750,1080 1080,1200 1200,1350
maps| and at some point
|在某种程度上，我们意识到这很愚蠢，

3597
01:26:56,870 --> 01:26:57,950
0,120 120,420 420,720 750,990 990,1080
we realize like this is

3598
01:26:57,950 --> 01:26:58,880
0,300 300,510 510,630 630,840 840,930
dumb,| like you have to
|就像你不得不说的那样，让我们把它拿出来

3599
01:26:58,880 --> 01:26:59,660
0,120 120,210 210,510 510,660 660,780
say the star, let's just

3600
01:26:59,660 --> 01:27:01,760
0,150 150,240 240,570 1020,1830 1860,2100
take it out| and so
|因此，就像我们对编译器进行了更改一样

3601
01:27:01,760 --> 01:27:02,540
0,180 180,270 270,450 450,540 540,780
like we made the change

3602
01:27:02,540 --> 01:27:03,530
0,60 60,120 120,780 780,930 930,990
to the compiler| and I
|我在我的编辑器中打开了世界上几百个围棋源文件

3603
01:27:03,530 --> 01:27:05,240
0,300 300,480 480,930 930,1350 1380,1710
opened up literally like the

3604
01:27:05,240 --> 01:27:06,710
0,300 300,750 750,930 930,1200 1200,1470
couple hundred Go source files

3605
01:27:06,710 --> 01:27:07,250
0,60 60,120 120,330 330,390 390,540
in the world in my

3606
01:27:07,250 --> 01:27:08,400
0,360 360,450 450,750
editor| and like
|整个团队都站在我身后

3607
01:27:08,430 --> 01:27:10,020
0,300 300,780 780,1050 1050,1260 1260,1590
the entire team stood behind

3608
01:27:10,020 --> 01:27:10,860
0,180 180,330 330,480 480,720 720,840
me| and I typed some
|我输入了一些正则表达式，我们观察了对文件的影响，

3609
01:27:10,860 --> 01:27:12,330
0,240 240,750 750,1050 1050,1200 1200,1470
regular expressions and we looked

3610
01:27:12,330 --> 01:27:13,140
0,180 180,300 300,630 630,720 720,810
at the effect on the

3611
01:27:13,140 --> 01:27:14,490
0,420 420,660 660,840 840,990 990,1350
files,| yep, that looks right,
|是的，看起来是对的，保存它，你知道编译它，我们完成了

3612
01:27:14,520 --> 01:27:15,990
0,330 330,600 600,780 780,1320 1320,1470
save it, {you,know} compile it,

3613
01:27:16,020 --> 01:27:18,150
0,120 120,510 1020,1380 1380,1620 1620,2130
we're done| and like today
|就像今天一样，你知道我们根本不能做出向后不兼容的改变。

3614
01:27:18,150 --> 01:27:19,080
0,120 120,240 240,330 330,630 630,930
you know we can't make

3615
01:27:19,080 --> 01:27:20,850
0,480 480,870 870,1200 1200,1290 1290,1770
backwards incompatible changes at all.|
|

3616
01:27:21,960 --> 01:27:23,940
0,360 360,540 540,1200 1200,1500 1500,1980
And even making new changes
甚至做出类似的新改变。

3617
01:27:23,940 --> 01:27:25,020
0,210 210,420
like it.|
|

3618
01:27:25,320 --> 01:27:26,280
0,210 210,540 540,600 600,870 870,960
It affects a lot of
它影响了很多人

3619
01:27:26,280 --> 01:27:28,770
0,480 510,780 780,1290 1710,2310 2340,2490
people| and so, {} you
|所以，你知道你提出了一些建议

3620
01:27:28,770 --> 01:27:30,270
0,270 270,960 960,1110 1110,1170 1170,1500
know you sort of propose

3621
01:27:30,270 --> 01:27:32,070
0,480 480,1020 1050,1470 1470,1620 1620,1800
something| and {you,know} put all
|你知道，把这些都放在我身上是行不通的

3622
01:27:32,070 --> 01:27:32,970
0,180 180,360 360,570 570,660 660,900
this won't work for me|
|

3623
01:27:32,970 --> 01:27:33,930
0,120 120,210 210,390 390,570 570,960
and you try to adjust
你可能会试着去调整它。

3624
01:27:33,930 --> 01:27:36,210
0,210 210,720 1260,2070 2070,2130 2130,2280
that maybe.| It's a lot
|这要困难得多，我们估计世界上至少有100万，也许200万围棋程序员

3625
01:27:36,210 --> 01:27:37,680
0,240 240,390 390,810 810,1260 1290,1470
harder we estimate there's at

3626
01:27:37,680 --> 01:27:38,670
0,210 210,270 270,600 600,840 840,990
least a million, maybe two

3627
01:27:38,670 --> 01:27:39,690
0,270 270,450 450,870 870,930 930,1020
million Go programmers in the

3628
01:27:39,690 --> 01:27:41,370
0,360 360,630 990,1170 1170,1380 1380,1680
world| and is very different
|与他们四五岁时的情况大不相同。

3629
01:27:41,370 --> 01:27:42,870
0,120 120,270 270,360 360,660 1110,1500
from when they were four

3630
01:27:42,870 --> 01:27:44,060
0,60 60,780
or five.|
|

3631
01:27:51,830 --> 01:27:52,610
0,240 240,450 450,570 570,720 720,780
Not sure if this is
不确定这是不是一个有效的问题，

3632
01:27:52,610 --> 01:27:54,170
0,30 30,270 270,600 600,780 780,1560
a valid question,| but what
|但是，什么语言被写下来，也是用Go写的，或者不是。

3633
01:27:54,170 --> 01:27:55,790
0,510 510,750 750,1140 1140,1290 1290,1620
languages Go written, is written

3634
01:27:55,790 --> 01:27:57,050
0,150 150,360 360,750 750,990 990,1260
in Go also or no.|
|

3635
01:27:57,500 --> 01:27:59,720
0,660 690,1260 1260,1380 1380,1920 1920,2220
{Now,it,is}, {now,it,is}, the original {}
现在它是，现在它是用C编写的原始编译器运行时编写，

3636
01:27:59,720 --> 01:28:01,250
0,450 450,750 750,840 840,1080 1080,1530
compiler runtime write {written,in} C,|
|

3637
01:28:01,400 --> 01:28:02,540
0,300 330,510 510,690 690,900 900,1140
but a few years ago
但几年前，我们经历了一个巨大的，

3638
01:28:02,540 --> 01:28:03,410
0,60 60,240 240,390 390,450 450,870
we went through a big,|
|

3639
01:28:03,950 --> 01:28:05,720
0,240 240,450 450,630 630,1350 1350,1770
we actually wrote a program
我们实际上编写了一个程序将C语言转换为GO，

3640
01:28:05,720 --> 01:28:07,040
0,90 90,570 570,750 750,810 810,1320
to translate C to Go,|
|

3641
01:28:07,250 --> 01:28:08,120
0,120 120,270 270,480 480,750 750,870
and it only worked for
它只适用于我们的C代码，但仍然足够好。

3642
01:28:08,120 --> 01:28:09,230
0,120 120,270 270,510 510,720 750,1110
our C code, but still

3643
01:28:09,230 --> 01:28:10,460
0,120 120,270 270,600 810,1110 1110,1230
was good enough.| So that
|这样我们就不会丢失代码中的所有编码知识，

3644
01:28:10,460 --> 01:28:12,170
0,90 90,330 330,810 1080,1350 1350,1710
we wouldn't lose all the

3645
01:28:12,380 --> 01:28:14,030
0,540 540,930 930,990 990,1170 1170,1650
encoded knowledge in that code,|
|

3646
01:28:14,090 --> 01:28:15,080
0,300 300,540 540,780 780,930 930,990
about why things were the
关于为什么事情是这样的以及事情是如何运作的，

3647
01:28:15,080 --> 01:28:15,980
0,120 120,210 210,480 480,720 720,900
way they were and how

3648
01:28:15,980 --> 01:28:16,670
0,180 180,390 390,480 480,570 570,690
things work,| so we've got
|所以我们必须从头开始，

3649
01:28:16,670 --> 01:28:18,080
0,60 60,270 270,390 390,900 990,1410
to start from scratch,| but
|但现在它都是用GO编写的，只需一点汇编。

3650
01:28:18,080 --> 01:28:19,250
0,150 150,300 300,450 450,660 660,1170
now it's all {written,in} Go

3651
01:28:19,400 --> 01:28:20,210
0,240 240,450 450,630 630,750 750,810
and a little bit of

3652
01:28:20,210 --> 01:28:21,160
0,570
assembly.|
|

3653
01:28:21,160 --> 01:28:22,690
0,150 150,330 330,630 630,1230 1230,1530
And that means that people
这意味着人们可以，

3654
01:28:22,690 --> 01:28:25,180
0,480 960,1320 1320,1440 1440,1800 2190,2490
can {},| you know people
|你知道知道围棋的人可以在围棋项目上提供帮助，

3655
01:28:25,180 --> 01:28:26,050
0,60 60,240 240,540 540,660 660,870
who know Go can help

3656
01:28:26,050 --> 01:28:28,000
0,120 120,720 750,1050 1050,1590 1590,1950
on the Go project,| whereas
|而在以前，如果您想要在编译器或运行时上工作，

3657
01:28:28,000 --> 01:28:29,380
0,390 390,720 750,1050 1050,1170 1170,1380
before like if you wanted

3658
01:28:29,380 --> 01:28:30,220
0,90 90,240 240,330 330,390 390,840
to work on the compiler

3659
01:28:30,220 --> 01:28:31,150
0,90 90,180 180,660 660,780 780,930
or the runtime,| you had
|你必须非常了解C

3660
01:28:31,150 --> 01:28:32,380
0,60 60,270 270,660 660,930 930,1230
to know C really well|
|

3661
01:28:32,380 --> 01:28:33,820
0,390 630,1020 1020,1170 1170,1380 1380,1440
{and,like} we weren't getting a
就像我们没有让很多人真正了解C一样，

3662
01:28:33,820 --> 01:28:34,600
0,120 120,180 180,390 390,510 510,780
lot of people know C

3663
01:28:34,600 --> 01:28:35,800
0,210 210,480 480,810 810,990 990,1200
really well,| there's not actually
|实际上并不是按比例有那么多，

3664
01:28:35,800 --> 01:28:37,000
0,180 180,330 330,420 420,540 540,1200
that many of them proportionately,|
|

3665
01:28:37,000 --> 01:28:38,530
0,540 540,870 870,1200 1200,1290 1290,1530
and furthermore like our entire
此外，就像我们的所有用户群一样，程序员，而不是C程序员，

3666
01:28:38,530 --> 01:28:39,880
0,150 150,420 420,630 630,1050 1050,1350
user bases Go programmers, {not,C}

3667
01:28:39,880 --> 01:28:41,800
0,720 960,1320 1320,1590 1590,1680 1680,1920
programmers,| so moving to Go
|所以搬家是一件非常重要的事情。

3668
01:28:41,800 --> 01:28:42,940
0,240 240,450 450,630 630,780 780,1140
was a really big deal.|
|

3669
01:28:46,230 --> 01:28:47,400
0,120 120,330 330,840 870,1050 1050,1170
I was wondering how do
我在想，在这一点上，您如何确定要为语言添加哪些功能的优先顺序，

3670
01:28:47,400 --> 01:28:49,890
0,480 540,1230 1230,1470 1470,2100 2100,2490
you prioritize what features {to,add,to}

3671
01:28:49,890 --> 01:28:51,450
0,150 150,540 540,930 930,1140 1140,1560
the language at this point,|
|

3672
01:28:51,450 --> 01:28:54,120
0,240 240,540 540,1080 1080,1920 2070,2670
I know genetics like we're
我了解遗传学，就像我们所要求的那样，

3673
01:28:54,150 --> 01:28:55,880
0,420 420,570 570,870 870,1110
asking for that,| like
|就像你们都知道如何选择要做的工作。

3674
01:28:55,880 --> 01:28:56,900
0,210 210,510 510,660 660,870 870,1020
did {you,all} know like how

3675
01:28:56,900 --> 01:28:58,070
0,270 270,510 510,810 810,900 900,1170
you choose what to work

3676
01:28:58,070 --> 01:28:59,000
0,180
on.|
|

3677
01:28:59,210 --> 01:29:00,620
0,150 150,510 510,720 720,1110 1110,1410
I mean we've considered language
我的意思是，我们认为语言已经冻结了一段时间

3678
01:29:00,620 --> 01:29:02,060
0,270 270,690 690,810 810,870 870,1440
mostly frozen for a while|
|

3679
01:29:02,330 --> 01:29:03,860
0,780 840,1050 1050,1140 1140,1440 1440,1530
and so we haven't been
所以我们没有增加太多，

3680
01:29:03,860 --> 01:29:05,270
0,210 210,810 870,1140 1140,1320 1320,1410
adding much,| {} there was
|有很长一段时间，我们说过我们不会增加任何东西

3681
01:29:05,270 --> 01:29:05,990
0,60 60,240 240,480 480,570 570,720
a long period, we said

3682
01:29:05,990 --> 01:29:07,070
0,60 60,240 240,480 480,960 960,1080
we weren't adding anything| and
|然后在过去的几年里，我们增加了一些东西

3683
01:29:07,070 --> 01:29:08,150
0,150 150,510 510,750 750,840 840,1080
then we added a little

3684
01:29:08,150 --> 01:29:09,110
0,120 120,210 210,810 810,900 900,960
bit of things in the

3685
01:29:09,110 --> 01:29:10,580
0,420 420,630 630,1050 1050,1230 1260,1470
last couple years| to lead
|要引导到泛型，就像甩掉了铁锈一样，

3686
01:29:10,580 --> 01:29:11,510
0,150 150,270 270,630 630,810 810,930
up to generics just kind

3687
01:29:11,510 --> 01:29:12,470
0,120 120,360 360,450 450,720 720,960
of shake the Rust off,|
|

3688
01:29:12,470 --> 01:29:13,880
0,330 330,510 510,630 630,1170 1170,1410
like all the what breaks
就像当你改变语言中的某些东西时，所有的东西都会断开一样，

3689
01:29:13,880 --> 01:29:14,630
0,120 120,240 240,450 450,690 690,750
when you change something in

3690
01:29:14,630 --> 01:29:16,070
0,60 60,570 810,1170 1170,1350 1350,1440
the language,| so you can
|所以现在您可以在数字和长数字之间加下划线

3691
01:29:16,070 --> 01:29:17,390
0,120 120,630 630,930 930,1230 1230,1320
put underscores between digits and

3692
01:29:17,390 --> 01:29:18,500
0,180 180,540 540,690 690,930 930,1110
long numbers now| and things
|诸如此类的事情。

3693
01:29:18,500 --> 01:29:19,360
0,120 120,360
like that.|
|

3694
01:29:20,620 --> 01:29:21,970
0,600 600,660 660,780 780,1200 1200,1350
But you know generics has
但你知道，泛型显然是下一步需要发生的事情

3695
01:29:21,970 --> 01:29:23,080
0,330 330,510 510,600 600,900 900,1110
clearly been the next thing

3696
01:29:23,080 --> 01:29:24,250
0,270 300,600 600,690 690,1080 1080,1170
that needed to happen| and
|我们只需要弄清楚如何做到这一点。

3697
01:29:24,250 --> 01:29:24,820
0,60 60,180 180,270 270,330 330,570
we just have to figure

3698
01:29:24,820 --> 01:29:26,040
0,90 90,660
out how.|
|

3699
01:29:26,430 --> 01:29:27,360
0,150 150,480 480,570 570,780 780,930
In general, we try to
通常，我们只尝试添加与其他功能没有奇怪干扰的内容

3700
01:29:27,360 --> 01:29:29,190
0,300 300,510 510,780 780,1110 1440,1830
only add things that don't

3701
01:29:29,190 --> 01:29:30,720
0,240 240,630 630,810 810,990 990,1530
have weird kind of interference

3702
01:29:30,720 --> 01:29:32,340
0,120 120,300 300,1020 1380,1530 1530,1620
with other features| and we
|我们试图添加真正重要的东西，这些东西将帮助许多人参加这类项目，

3703
01:29:32,340 --> 01:29:33,210
0,150 150,240 240,420 420,690 690,870
try to add things that

3704
01:29:33,210 --> 01:29:34,740
0,420 420,720 720,1260 1260,1410 1410,1530
are really important that will

3705
01:29:34,740 --> 01:29:35,610
0,210 210,270 270,420 420,480 480,870
help a lot of people

3706
01:29:35,610 --> 01:29:36,810
0,240 240,360 360,690 690,750 750,1200
for the kinds of programs,|
|

3707
01:29:36,810 --> 01:29:38,100
0,210 420,720 720,930 930,990 990,1290
that we're trying to target
我们正试图用围棋作为目标，

3708
01:29:38,100 --> 01:29:38,910
0,90 90,270 270,480 480,570 570,810
with Go,| which is like
|这就像分布式系统之类的东西。

3709
01:29:39,090 --> 01:29:40,860
0,480 480,1050 1050,1350 1440,1620 1620,1770
distributed systems and that sort

3710
01:29:40,860 --> 01:29:41,660
0,90 90,330
of thing.|
|

3711
01:29:50,050 --> 01:29:52,540
0,720 750,930 930,1170 1890,2280 2280,2490
Cool, thank you.| Oh, I
太好了，谢谢。|哦，实际上我有个问题，

3712
01:29:52,540 --> 01:29:55,120
0,180 180,240 240,660 660,1410 1950,2580
had a question actually {},|
|

3713
01:29:55,120 --> 01:29:58,030
0,1380 1710,2040 2040,2370 2370,2730 2730,2910
so, for I noticed that
所以，我注意到，就像你知道的，围棋没有像MIN或MAX这样的基本函数，

3714
01:29:58,030 --> 01:29:59,830
0,300 300,420 420,810 840,1470 1470,1800
like you know Go doesn't

3715
01:29:59,830 --> 01:30:01,360
0,210 210,510 540,960 960,1350 1350,1530
have like basic functions like

3716
01:30:01,360 --> 01:30:03,010
0,270 270,420 420,870 870,1020 1020,1650
min or max for like,|
|

3717
01:30:03,520 --> 01:30:05,080
0,480 480,780 780,1110 1110,1350 1350,1560
yeah, so is that like
是的，那么这是不是像你正在考虑的事情，比如用通用的东西来添加，

3718
01:30:05,080 --> 01:30:07,060
0,450 450,750 780,1080 1080,1740 1740,1980
something that you're considering like

3719
01:30:07,060 --> 01:30:08,590
0,210 210,600 600,900 930,1020 1020,1530
say adding with the generic

3720
01:30:08,590 --> 01:30:09,670
0,330 330,600 600,720 720,930 930,1080
stuff,| maybe is that why
|也许这就是你没有这么做的原因。

3721
01:30:09,670 --> 01:30:11,680
0,180 180,630 660,1470 1470,1680 1680,2010
you didn't.| Exactly right, because
|完全正确，因为你不能有min，你有min_int[]，

3722
01:30:11,680 --> 01:30:12,730
0,120 120,270 270,390 390,510 510,1050
you can't have a min,

3723
01:30:12,940 --> 01:30:14,740
0,180 180,330 330,780 1080,1680 1680,1800
you have min_int [],| but
|但它们有不同的名字，这有点令人恼火。

3724
01:30:14,740 --> 01:30:16,240
0,180 180,480 480,720 720,1230 1380,1500
those have different names and

3725
01:30:16,240 --> 01:30:17,110
0,120 120,240 240,390 390,450 450,870
that was kind of annoying.|
|

3726
01:30:17,540 --> 01:30:18,590
0,450 480,660 660,870 870,960 960,1050
{} So now we can
所以现在我们可以只写一个通用名称，

3727
01:30:18,590 --> 01:30:19,880
0,180 180,360 360,450 450,810 810,1290
write just a generic name,|
|

3728
01:30:20,450 --> 01:30:21,470
0,450 450,690 690,810 810,960 960,1020
{over,any} type that has a
任何具有小于运算符的类型。

3729
01:30:21,470 --> 01:30:23,720
0,210 210,360 360,960 1470,2010 2010,2250
less than operator.| Yeah.| That'll
|嗯。|那就太好了。

3730
01:30:23,720 --> 01:30:24,590
0,90 90,420 420,660 660,750 750,870
be good.| And you know
|你知道，老实说，对于最小和最大的情况。

3731
01:30:24,590 --> 01:30:26,030
0,390 390,690 720,930 930,1020 1020,1440
honestly like for the specific

3732
01:30:26,030 --> 01:30:27,500
0,210 210,300 300,450 450,570 570,1470
case of min and max.|
|

3733
01:30:27,680 --> 01:30:29,150
0,690 690,840 840,1020 1020,1170 1170,1470
{} It's not that hard
我知道，编写代码并不那么难。

3734
01:30:29,150 --> 01:30:30,470
0,150 150,840 870,1020 1020,1200 1200,1320
to code, I know.| I
|我想说，我开始觉得我们应该把它们建起来，

3735
01:30:30,470 --> 01:30:31,400
0,90 90,210 210,390 390,720 720,930
was gonna say, I'm starting

3736
01:30:31,400 --> 01:30:31,910
0,60 60,180 180,300 300,390 390,510
to feel like we should

3737
01:30:31,910 --> 01:30:33,350
0,150 150,270 270,360 360,780 780,1440
just make them buildings,| like
|就像你知道印刷品之类的东西一样，

3738
01:30:33,350 --> 01:30:34,940
0,90 90,510 810,1140 1140,1410 1410,1590
you know print and things

3739
01:30:34,940 --> 01:30:36,260
0,120 120,390 420,660 660,900 900,1320
like that,| so that you
|这样你就可以一直拥有它们，

3740
01:30:36,260 --> 01:30:37,400
0,90 90,330 330,600 600,810 810,1140
can just always have them,|
|

3741
01:30:37,520 --> 01:30:38,930
0,510 540,780 780,870 870,960 960,1410
but even if we don't,|
但即使我们不这么做，|

3742
01:30:38,930 --> 01:30:39,950
0,240 240,330 330,600 600,810 810,1020
you'll be {math.min - -}
你会成为数学。分钟，至少会在那里。

3743
01:30:39,950 --> 01:30:40,700
0,90 90,300 300,390 390,660 660,750
and that'll be there at

3744
01:30:40,700 --> 01:30:41,560
0,570
least.|
|

3745
01:30:41,620 --> 01:30:43,240
0,420 420,960 1080,1230 1230,1470 1470,1620
{} Yeah.| We really didn't
嗯。|我们真的不想让它们成为建筑物，直到我们能表达它们的类型

3746
01:30:43,240 --> 01:30:44,110
0,120 120,180 180,360 360,450 450,870
want to make them buildings

3747
01:30:44,110 --> 01:30:45,580
0,270 270,390 390,630 660,1320 1320,1470
until we could express their

3748
01:30:45,580 --> 01:30:46,570
0,510 510,630 630,720 720,900 900,990
types| and we couldn't do
|在泛型出现之前，我们无法做到这一点。

3749
01:30:46,570 --> 01:30:48,300
0,180 180,420 420,810 810,1170
that until generics happened.|
|

3750
01:30:48,300 --> 01:30:49,350
0,240 240,450 450,630 630,960 960,1050
Because there is actually a
因为浮点数实际上有一个最小值。

3751
01:30:49,350 --> 01:30:51,510
0,270 270,630 660,1110 1110,1590 1590,2160
min for floating points actually.|
|

3752
01:30:51,510 --> 01:30:52,980
0,390 390,840 840,1200 1200,1320 1320,1470
Yeah, I know it's kind
是的，我知道这有点奇怪，

3753
01:30:52,980 --> 01:30:54,330
0,60 60,390 390,930 930,1050 1050,1350
of weird,| because the math
|因为数学库基本上是从C math.h，一组东西复制过来的。

3754
01:30:54,330 --> 01:30:56,070
0,510 510,720 720,1200 1200,1590 1590,1740
library is basically copied from

3755
01:30:56,070 --> 01:30:57,450
0,90 90,420 420,660 660,840 840,1380
the C {math.h - -},

3756
01:30:57,480 --> 01:31:01,320
0,270 270,330 330,2610 2610,3270 3540,3840
set of things.| Yeah.| That's
|嗯。|这是很好的观点，

3757
01:31:01,320 --> 01:31:02,160
0,60 60,180 180,480 480,570 570,840
a good point,| we can't
|我们实际上不能把它们放在数学上，

3758
01:31:02,160 --> 01:31:03,060
0,240 240,360 360,480 480,540 540,900
actually put them in math,|
|

3759
01:31:03,060 --> 01:31:04,720
0,270 270,420 420,720 720,1080
because they're already there.|
因为他们已经在那里了。|

3760
01:31:04,720 --> 01:31:07,690
0,780 1140,1410 1410,2160 2370,2700 2700,2970
Okay. But.| Yeah.| We'll figure
好吧。但。|嗯。|我们会弄清楚的，

3761
01:31:07,690 --> 01:31:08,530
0,90 90,330 330,450 450,690 690,840
it out,| like I think
|就像我觉得我们应该把它们放进语言里，

3762
01:31:08,530 --> 01:31:09,160
0,90 90,180 180,390 390,540 540,630
we should probably just put

3763
01:31:09,160 --> 01:31:10,000
0,90 90,180 180,240 240,630 630,840
them in the language,| but
|但我们必须首先让仿制药通过。

3764
01:31:10,000 --> 01:31:10,660
0,60 60,150 150,210 210,330 330,660
we have to get generics

3765
01:31:10,660 --> 01:31:12,640
0,180 180,690 990,1230 1230,1590 1590,1980
through first.| And another thing,|
|还有一件事，|

3766
01:31:12,670 --> 01:31:13,780
0,390 390,420 420,780 780,960 960,1110
actually I noticed that you
事实上，我注意到你喜欢竞技节目，

3767
01:31:13,780 --> 01:31:14,800
0,270 270,510 510,690 690,840 840,1020
did {USACO - -} like

3768
01:31:14,800 --> 01:31:17,560
0,540 540,1170 1620,1860 1860,2190 2190,2760
competitive programming,| {I,did,it} too, actually.|
|事实上，我也这么做了。|

3769
01:31:18,100 --> 01:31:19,990
0,360 390,720 720,1260 1290,1590 1590,1890
Cool.| Yeah, so how did
凉爽的。|是的，那么你是如何，所以实际上我把这个包括在我提交的一个问题中，

3770
01:31:19,990 --> 01:31:21,400
0,210 210,390 390,810 810,900 900,1410
you, so actually I included

3771
01:31:21,400 --> 01:31:22,060
0,180 180,300 300,480 480,570 570,660
this in one of the

3772
01:31:22,060 --> 01:31:23,710
0,510 510,660 660,840 840,1500 1500,1650
questions that I submitted,| let
|让我把它拉起来，

3773
01:31:23,710 --> 01:31:25,120
0,210 210,480 480,540 540,1170 1230,1410
me pull it up,| so
|所以我的问题是，

3774
01:31:25,120 --> 01:31:28,570
0,150 150,510 510,690 690,2220 2550,3450
my question was like,| how
|你是怎么做的，从做竞技编程

3775
01:31:28,600 --> 01:31:30,250
0,270 270,390 390,570 570,1260 1380,1650
did how was like how

3776
01:31:30,250 --> 01:31:31,220
0,150 150,540
did you,

3777
01:31:31,450 --> 01:31:33,250
0,270 270,600 600,840 840,1320 1320,1800
go from doing competitive programming|
|

3778
01:31:33,250 --> 01:31:34,660
0,150 150,450 660,960 960,1170 1170,1410
to like doing what you
想要做你现在在谷歌做的事情，去做吧

3779
01:31:34,870 --> 01:31:35,920
0,180 180,390 390,600 600,690 690,1050
you're doing now at Google

3780
01:31:35,920 --> 01:31:36,790
0,270 270,420 420,600 600,690 690,870
working on Go| and how
|以及类似竞技节目到系统的过渡是如何进行的，

3781
01:31:36,790 --> 01:31:39,040
0,120 120,210 210,1050 1050,1620 1770,2250
is the transition between like

3782
01:31:39,040 --> 01:31:41,230
0,480 480,960 960,1110 1110,1770 1770,2190
competitive programming to systems,| also
|最后是什么让你决定进入系统，

3783
01:31:41,230 --> 01:31:42,670
0,240 240,450 450,930 930,1080 1080,1440
finally what made you decide

3784
01:31:42,670 --> 01:31:43,630
0,120 120,240 240,390 390,840 840,960
to go into system,| so
|那么它与编程代码有什么关系呢。

3785
01:31:43,630 --> 01:31:45,580
0,180 180,360 360,450 450,840 1560,1950
how did it {relate,to} programming

3786
01:31:45,580 --> 01:31:47,140
0,210 210,240 240,600 630,1110 1110,1560
code.| I mean competitive programming
|我指的是当时的竞技节目，

3787
01:31:47,140 --> 01:31:47,950
0,180 180,270 270,540 540,690 690,810
at the time that I

3788
01:31:47,950 --> 01:31:48,910
0,150 150,330 330,510 510,810 810,960
did,| it was not as
|它并不像我现在想象的那样耗费精力，

3789
01:31:48,910 --> 01:31:50,230
0,210 210,690 690,840 840,930 930,1320
all consuming as I gather

3790
01:31:50,230 --> 01:31:51,740
0,60 60,210 210,600 690,1080
it is now,| like,
|就像，就像你知道的，你可以实现一个简单的动态编程

3791
01:31:51,890 --> 01:31:53,210
0,330 330,420 420,1020 1080,1230 1230,1320
like you know you could

3792
01:31:53,210 --> 01:31:54,200
0,240 240,420 420,540 540,720 720,990
just like be able to

3793
01:31:54,200 --> 01:31:55,940
0,450 450,600 600,900 900,1260 1260,1740
implement a simple dynamic programming|
|

3794
01:31:55,940 --> 01:31:57,530
0,300 330,750 900,1110 1110,1290 1290,1590
like little two for loops,
就像两个小For循环，这很好

3795
01:31:57,530 --> 01:31:58,310
0,120 120,240 240,390 390,690 690,780
and that was fine| and
|现在你必须使用复杂的算法和所有我做不到的东西，

3796
01:31:58,310 --> 01:31:58,850
0,150 150,240 240,330 330,420 420,540
now you have to go

3797
01:31:58,850 --> 01:32:00,470
0,270 270,660 660,1410 1410,1530 1530,1620
with complex algorithms and all

3798
01:32:00,470 --> 01:32:01,610
0,240 360,690 690,810 810,900 900,1140
that stuff that I can't

3799
01:32:01,610 --> 01:32:03,380
0,330 450,1020 1020,1350 1350,1470 1470,1770
do,| so at some point
|所以在某种程度上，不知何故，它是不同的。

3800
01:32:03,380 --> 01:32:04,670
0,300 300,660 660,1050 1050,1170 1170,1290
like somehow like it was

3801
01:32:04,670 --> 01:32:06,420
0,480 780,1290
different {}.|
|

3802
01:32:06,480 --> 01:32:07,740
0,510 540,690 690,870 870,1080 1080,1260
But you know I was
但你知道，实际上我更感兴趣的是你从一开始就开始的那种系统

3803
01:32:07,740 --> 01:32:08,820
0,270 270,480 480,840 840,930 930,1080
actually more interested in the

3804
01:32:08,820 --> 01:32:10,050
0,210 210,360 600,990 990,1080 1080,1230
sort of systems you kind

3805
01:32:10,050 --> 01:32:11,070
0,90 90,330 330,450 450,540 540,1020
of start from the start|
|

3806
01:32:11,160 --> 01:32:13,260
0,600 600,930 1230,1620 1620,1980 1980,2100
and the program contests were
而节目竞赛只是在业余时间做一些有趣的事情。

3807
01:32:13,260 --> 01:32:14,250
0,300 300,600 600,750 750,840 840,990
just something fun to do

3808
01:32:14,250 --> 01:32:15,930
0,120 120,180 180,630 810,1350 1350,1680
on the side.| Oh.| It
|噢。|这并不是一个巨大的转变，

3809
01:32:15,930 --> 01:32:17,640
0,300 300,450 450,780 780,1260 1260,1710
wasn't a huge transition there,|
|

3810
01:32:17,670 --> 01:32:19,110
0,390 420,540 540,690 690,990 990,1440
{} I was never into
我从来不喜欢实现复杂的算法

3811
01:32:19,200 --> 01:32:22,530
0,450 450,810 810,1530 1770,2070 2490,3330
implementing complex algorithms| and {max,flow}
|最大流量和诸如此类的东西。

3812
01:32:22,530 --> 01:32:23,370
0,180 210,390 390,570 570,780 780,840
and all those sorts of

3813
01:32:23,370 --> 01:32:24,870
0,390 540,960 960,1050 1050,1200 1200,1500
things.| On the other hand,
|另一方面，就像当你开始学习一门新语言时，

3814
01:32:24,870 --> 01:32:26,160
0,390 660,870 870,1020 1020,1260 1260,1290
like when you start a

3815
01:32:26,160 --> 01:32:27,280
0,120 120,750
new language,|
|

3816
01:32:27,280 --> 01:32:28,180
0,180 180,480 480,630 630,810 810,900
you actually do get to
实际上，你确实可以把很多核心内容写对，

3817
01:32:28,180 --> 01:32:29,620
0,210 210,270 270,510 510,780 1020,1440
write a lot of core

3818
01:32:29,620 --> 01:32:31,750
0,570 570,990 1020,1710 1710,1950 1950,2130
things right,| like someone has
|就像有人必须编写排序函数一样，

3819
01:32:31,750 --> 01:32:32,980
0,90 90,300 300,390 390,750 750,1230
to write the sort function,|
|

3820
01:32:33,400 --> 01:32:34,120
0,270 270,390 390,570 570,630 630,720
and it has to be
而且它必须是一个很好的通用排序函数，

3821
01:32:34,120 --> 01:32:35,470
0,90 90,270 270,570 570,870 870,1350
a good general sort function,|
|

3822
01:32:35,470 --> 01:32:36,880
0,210 210,270 270,510 510,1080 1080,1410
like I spent {a,while} last
就像我上个月花了一段时间，比如研究[DIP]算法

3823
01:32:36,880 --> 01:32:38,410
0,270 270,570 780,1110 1110,1290 1290,1530
month, like looking into [dip]

3824
01:32:38,410 --> 01:32:41,560
0,630 630,990 990,1260 1260,2040 2490,3150
algorithms| and that's like matches
|这就像是很好地匹配了背景，

3825
01:32:41,560 --> 01:32:43,450
0,180 180,630 630,840 840,1260 1620,1890
that background pretty well,| so
|因此，它确实出现了。

3826
01:32:43,450 --> 01:32:44,780
0,240 240,420 420,540 540,900
it does come up.|
|

3827
01:32:44,810 --> 01:32:46,490
0,630 690,990 1020,1140 1140,1470 1500,1680
{} But you know it's
但你知道，这只是一种不同的计划。

3828
01:32:46,490 --> 01:32:47,420
0,240 270,450 450,630 630,690 690,930
just it's just a different

3829
01:32:47,420 --> 01:32:48,770
0,120 120,180 180,630 870,1260 1260,1350
kind of program.| {Oh,so}, you
|哦，那么，你认为它更多的是一种次要的东西，当时，没有。

3830
01:32:48,770 --> 01:32:49,370
0,210 210,270 270,360 360,480 480,600
thought of it as more

3831
01:32:49,370 --> 01:32:50,360
0,90 90,150 150,510 510,690 690,990
of a side thing, back

3832
01:32:50,360 --> 01:32:52,130
0,300 300,540 540,1560 1560,1620 1620,1770
then, no.| Yeah, it was
|是的，这绝对不是我在写程序时做的那种主要的事情。

3833
01:32:52,130 --> 01:32:53,120
0,300 300,570 570,750 750,930 930,990
definitely not the sort of

3834
01:32:53,120 --> 01:32:53,840
0,210 210,330 330,420 420,630 630,720
main thing I did when

3835
01:32:53,840 --> 01:32:55,280
0,30 30,180 180,390 390,960 1050,1440
I was writing programs.| Yeah,
|是的，因为就像今天一样，它实际上就像是主要的东西。

3836
01:32:55,280 --> 01:32:56,990
0,480 480,720 720,1020 1020,1200 1200,1710
because like today it's effectively

3837
01:32:56,990 --> 01:32:58,250
0,240 240,330 330,660 660,840 840,1260
like the main thing.| I
|我知道，如果你不全职做，就好像你根本做不到。

3838
01:32:58,250 --> 01:32:59,990
0,150 150,870 1050,1230 1230,1350 1350,1740
know, if if you don't

3839
01:32:59,990 --> 01:33:00,920
0,150 150,270 270,450 450,750 750,930
do it full time, like

3840
01:33:00,920 --> 01:33:01,760
0,240 240,420 420,540 540,720 720,840
there's just no way you

3841
01:33:01,760 --> 01:33:03,500
0,330 1050,1290 1290,1410 1410,1590 1590,1740
can.| Okay, they just want
|好吧，他们只是想要那些在1995年关心他们的人。

3842
01:33:03,500 --> 01:33:04,550
0,120 120,300 300,510 510,600 600,1050
that many people who cared

3843
01:33:04,580 --> 01:33:07,180
0,330 330,1290
in 1995.|
|

3844
01:33:07,180 --> 01:33:08,950
0,690 720,1050 1050,1230 1230,1500 1500,1770
{} Well, yeah twenty years
是啊，二十年后。

3845
01:33:08,950 --> 01:33:10,900
0,630
later.|
|

3846
01:33:15,190 --> 01:33:16,240
0,240 240,390 390,660 660,690 690,1050
I'm gonna ask a related
我要问一个相关的问题，

3847
01:33:16,240 --> 01:33:18,250
0,390 390,510 510,930 930,1260 1710,2010
question to that,| {} so
|那么，你如何决定从学术工作进入，

3848
01:33:18,250 --> 01:33:19,240
0,240 240,300 300,390 390,870 870,990
how do you decide to

3849
01:33:19,240 --> 01:33:22,330
0,360 360,930 1230,1860 1860,2460 2460,3090
go from like academic work

3850
01:33:22,570 --> 01:33:24,640
0,840 930,1200 1200,1620 1680,1890 1890,2070
into,| I mean your work
|我的意思是，你的工作仍然比平时的软件有一点不同，但仍然如此。

3851
01:33:24,640 --> 01:33:25,840
0,120 120,540 570,930 930,1110 1110,1200
is still a little bit

3852
01:33:25,840 --> 01:33:27,850
0,210 210,660 660,1110 1230,1590 1590,2010
more different than like the

3853
01:33:27,910 --> 01:33:30,220
0,630 630,810 810,1200 1200,1890 1890,2310
usual like software anything, but

3854
01:33:30,220 --> 01:33:31,160
0,510
still.|
|

3855
01:33:32,040 --> 01:33:33,820
0,1260
Yeah,
是啊，你知道我很幸运，

3856
01:33:33,850 --> 01:33:34,750
0,150 150,210 210,210 210,510 510,900
you know I got lucky,|
|

3857
01:33:34,750 --> 01:33:35,860
0,480 480,630 630,810 810,960 960,1110
I I grew up near
我我在新泽西州贝尔实验室附近长大

3858
01:33:35,860 --> 01:33:37,180
0,180 180,750 750,870 870,960 960,1320
Bell Labs in new Jersey|
|

3859
01:33:37,180 --> 01:33:38,020
0,150 150,270 270,600 600,720 720,840
and so that was how
这就是我最终在高中和大学里做了一点计划的原因。

3860
01:33:38,020 --> 01:33:38,980
0,90 90,300 300,600 600,840 840,960
I ended up working on

3861
01:33:38,980 --> 01:33:39,910
0,270 270,480 480,690 690,840 840,930
plan a little bit in

3862
01:33:39,910 --> 01:33:42,400
0,120 120,390 390,480 480,1020
high school and college.|
|

3863
01:33:42,550 --> 01:33:43,720
0,210 210,600 600,720 720,960 960,1170
And so you know I
所以你知道，我，我大概知道我会去读研究生

3864
01:33:43,720 --> 01:33:44,230
0,150 150,300 300,390 390,510 510,510
I sort of knew I

3865
01:33:44,230 --> 01:33:44,800
0,210 210,330 330,390 390,510 510,570
was going to go to

3866
01:33:44,800 --> 01:33:46,060
0,270 270,630 630,870 990,1140 1140,1260
grad school| and you know
|你知道我们的计划是回到贝尔实验室，

3867
01:33:46,060 --> 01:33:46,780
0,120 120,390 390,510 510,600 600,720
the plan was to go

3868
01:33:46,780 --> 01:33:47,590
0,210 210,300 300,420 420,720 720,810
back to Bell Labs,| but
|但当我还在读研究生的时候，它有点崩溃了，

3869
01:33:47,590 --> 01:33:48,550
0,60 60,210 210,300 300,780 780,960
it kind of imploded, while

3870
01:33:48,550 --> 01:33:49,690
0,120 120,420 420,510 510,750 750,1140
I was in grad school,|
|

3871
01:33:50,200 --> 01:33:51,550
0,240 240,480 480,570 570,1020 1020,1350
{} with the dot-com bubble,
随着互联网泡沫和互联网崩盘

3872
01:33:51,580 --> 01:33:54,250
0,120 120,180 180,630 630,1320 1710,2670
and the dot-com crash| and
|所以，就像你知道的，谷歌当时只是在清理博士、系统博士，

3873
01:33:54,400 --> 01:33:55,270
0,240 240,390 390,630 630,720 720,870
and so like you know

3874
01:33:55,270 --> 01:33:56,350
0,270 270,570 570,810 810,990 990,1080
Google was was sort of

3875
01:33:56,350 --> 01:33:58,570
0,660 810,1050 1050,1470 1470,1620 1620,2220
{} just vacuuming up PhDs,

3876
01:33:58,570 --> 01:34:00,190
0,540 540,960 960,1110 1110,1200 1200,1620
systems PhD at the time,|
|

3877
01:34:00,680 --> 01:34:01,970
0,420 420,750 750,900 900,1110 1110,1290
and and and doing really
做一些非常有趣的事情，

3878
01:34:01,970 --> 01:34:02,930
0,300 300,630 630,690 690,840 840,960
interesting things,| I mean you
|我是说，你可能有，

3879
01:34:02,930 --> 01:34:04,190
0,360 390,780 780,990 1020,1170 1170,1260
probably there's {},| I don't
|我不知道我还没看过今年的教学大纲，

3880
01:34:04,190 --> 01:34:04,880
0,210 210,330 330,480 480,630 630,690
know I haven't looked at

3881
01:34:04,880 --> 01:34:05,960
0,330 330,420 420,600 600,810 810,1080
syllabus for this year,| but
|但你知道有像扳手、大桌和胖子之类的东西

3882
01:34:05,960 --> 01:34:06,710
0,90 90,210 210,420 420,600 600,750
you know there's things like

3883
01:34:06,710 --> 01:34:08,780
0,570 570,990 1080,1530 1650,1830 1830,2070
spanner and {} {bigtable -}

3884
01:34:08,780 --> 01:34:10,340
0,90 90,420 420,660 960,1380 1380,1560
and chubby and and things

3885
01:34:10,340 --> 01:34:11,270
0,150 150,450 450,630 660,810 810,930
like that| and you know
|你知道，他们有一大堆好的分布式系统在运行。

3886
01:34:11,270 --> 01:34:12,110
0,210 210,330 330,510 510,570 570,840
they they had a whole

3887
01:34:12,110 --> 01:34:13,880
0,330 330,720 720,990 990,1410 1410,1770
host of good distributed systems

3888
01:34:13,880 --> 01:34:14,930
0,120 120,180 180,420 420,660 660,1050
kind of stuff going on.|
|

3889
01:34:15,460 --> 01:34:16,690
0,180 180,720 750,930 930,1080 1080,1230
And so it was sort
因此，能够参加这个活动也是一种幸运。

3890
01:34:16,690 --> 01:34:17,350
0,60 60,330 330,420 420,480 480,660
of lucky to be able

3891
01:34:17,350 --> 01:34:18,640
0,240 240,510 510,570 570,900 900,1290
to go to that, too.|
|

3892
01:34:19,220 --> 01:34:20,420
0,630

3893
01:34:20,660 --> 01:34:21,800
0,360 360,480 480,840 840,1050 1050,1140
And you know at the
你知道，在我毕业的时候，

3894
01:34:21,800 --> 01:34:22,760
0,240 240,300 300,780 780,840 840,960
time I graduated,| I was
|我还查看了工业研究实验室，

3895
01:34:22,760 --> 01:34:23,780
0,240 240,510 510,810 810,900 900,1020
also looking at you know

3896
01:34:23,780 --> 01:34:25,340
0,420 420,750 750,1020 1020,1170 1170,1560
industrial research labs,| like Microsoft
|就像微软的研究和类似的地方，

3897
01:34:25,340 --> 01:34:27,020
0,390 390,930 930,1230 1230,1380 1380,1680
research and places like that,|
|

3898
01:34:27,350 --> 01:34:28,550
0,540 540,660 660,750 750,900 900,1200
so you know there's definitely
所以你知道那里肯定有研究东西的机会，

3899
01:34:28,550 --> 01:34:31,220
0,420 420,900 900,1170 1170,1950 2100,2670
an opportunity there for researching

3900
01:34:31,220 --> 01:34:32,840
0,390 390,540 540,900 900,990 990,1620
things,| but not in academia,
|但不是在学术界，如果这是你想要的。

3901
01:34:32,840 --> 01:34:33,740
0,150 150,330 330,450 450,540 540,900
if that's what you want.|
|

3902
01:34:34,370 --> 01:34:35,420
0,330 330,540 540,570 570,810 810,1050
{} It's a little harder
现在更难找到了，

3903
01:34:35,420 --> 01:34:36,590
0,90 90,330 330,780 810,900 900,1170
to find, now,| I mean
|我的意思是，我拥有的大多数地方，比如微软的研究，也在几年后崩溃了。

3904
01:34:36,590 --> 01:34:37,280
0,240 240,300 300,360 360,600 600,690
most of the places I

3905
01:34:37,280 --> 01:34:38,630
0,150 150,330 330,690 690,1020 1020,1350
have like Microsoft research imploded

3906
01:34:38,630 --> 01:34:40,670
0,480 780,1200 1230,1470 1470,1650 1650,2040
too, a couple years later.|
|

3907
01:34:41,200 --> 01:34:42,910
0,300 300,690 720,900 900,1200 1350,1710
But, {} you know it's,
但是，你知道，这仍然是一种选择

3908
01:34:42,910 --> 01:34:43,900
0,450
{}

3909
01:34:44,230 --> 01:34:45,670
0,210 210,390 390,450 450,900 1080,1440
it's still an option| and
|你知道，这是一条略有不同的道路

3910
01:34:45,670 --> 01:34:47,140
0,270 270,390 390,570 570,810 810,1470
and you know just a

3911
01:34:47,140 --> 01:34:49,540
0,270 270,660 900,1440 1740,2040 2040,2400
slightly different path,| {} you
|你的结果是，

3912
01:34:49,540 --> 01:34:51,190
0,120 120,570 600,1080 1080,1530 1530,1650
end up,| the differences I
|我从学术界看到的不同之处在于，你最终更关心的是让事情百分之百地运转起来

3913
01:34:51,190 --> 01:34:52,150
0,210 210,360 360,720 720,810 810,960
see from academia is like

3914
01:34:52,150 --> 01:34:53,230
0,150 150,300 300,510 510,930 930,1080
you end up caring a

3915
01:34:53,230 --> 01:34:55,570
0,300 300,690 690,1170 1560,2010 2010,2340
ton more about actually making

3916
01:34:55,570 --> 01:34:56,530
0,240 240,510 510,570 570,750 750,960
things work a hundred percent

3917
01:34:56,530 --> 01:34:57,670
0,210 210,300 300,720 720,840 840,1140
time| and supporting them for
|并支持他们十年或更长时间

3918
01:34:57,760 --> 01:34:59,320
0,150 150,480 480,540 540,870 1050,1560
a decade or more| where
|当你完成你的论文，你可以把它放在一边

3919
01:34:59,320 --> 01:35:00,400
0,300 330,450 450,630 630,750 750,1080
as you finish your paper

3920
01:35:00,400 --> 01:35:01,150
0,90 90,180 180,330 330,420 420,750
and you kind of get

3921
01:35:01,150 --> 01:35:01,630
0,60 60,180 180,240 240,390 390,480
to put it off to

3922
01:35:01,630 --> 01:35:02,710
0,60 60,390 390,480 480,840 840,1080
the side| and that's really
|在某种程度上，这真的很好。

3923
01:35:02,710 --> 01:35:04,390
0,330 330,840 840,990 990,1170 1170,1680
nice actually at some level.|
|

3924
01:35:05,890 --> 01:35:07,780
0,390 390,390 1140,1290 1290,1560 1560,1890
It's, {} it's definitely strange
你知道，编辑我写的源文件对我来说绝对是陌生的，

3925
01:35:07,780 --> 01:35:08,770
0,90 90,300 300,420 420,810 840,990
to me to be you

3926
01:35:08,770 --> 01:35:11,020
0,330 600,990 990,1260 1260,1920 1920,2250
know editing source files that

3927
01:35:11,020 --> 01:35:13,210
0,180 180,990 1080,1200 1200,1440 1860,2190
I wrote,| you know in
|你知道，在某些情况下，实际上是在20年前，

3928
01:35:13,210 --> 01:35:14,440
0,150 150,480 480,780 780,1020 1020,1230
some cases actually twenty years

3929
01:35:14,440 --> 01:35:16,480
0,360 570,1590 1590,1590 1590,1980 1980,2040
ago,| because I used a
|因为我用了很多我已经写好的代码，当我们开始的时候。

3930
01:35:16,480 --> 01:35:17,200
0,210 210,270 270,510 510,630 630,720
bunch of code that I've

3931
01:35:17,200 --> 01:35:18,130
0,240 240,450 450,630 630,720 720,930
already written when we start

3932
01:35:18,130 --> 01:35:19,160
0,60 60,570
to go.|
|

3933
01:35:19,190 --> 01:35:20,420
0,300 300,720 720,930 930,1140 1140,1230
And it's very weird to
一想到我让这个项目运行了20年，我就觉得很奇怪。

3934
01:35:20,420 --> 01:35:21,740
0,240 240,390 390,690 690,900 930,1320
think that I've been keeping

3935
01:35:21,740 --> 01:35:22,760
0,120 120,420 420,630 630,750 750,1020
this program running for twenty

3936
01:35:22,760 --> 01:35:24,060
0,870
years.|
|

3937
01:35:26,430 --> 01:35:26,923
0,390
{Think,you}.
想想你。
