1
00:00:00,000 --> 00:00:02,610
0,180 180,930 1410,1830 1830,2130 2130,2610
Good afternoon, good evening, {good,night},
下午好，傍晚好，晚上好，无论你在哪里。

2
00:00:02,610 --> 00:00:04,950
0,300 300,450 450,810 1260,1980 2040,2340
wherever you are.| {} So
|所以今天我想谈谈 FaRM ，

3
00:00:04,950 --> 00:00:05,760
0,270 270,330 330,480 480,630 630,810
today I want to talk

4
00:00:05,760 --> 00:00:07,170
0,210 210,690 810,1080 1080,1290 1290,1410
about FaRM,| {} this is
|这是一篇 2015 年的论文，

5
00:00:07,170 --> 00:00:09,300
0,150 150,450 450,810 810,1980 1980,2130
a paper from 2015,| {so,what
|是比较近的一篇论文，

6
00:00:09,300 --> 00:00:10,050
0,210 210,300 300,450 450,570 570,750
-} a little bit more

7
00:00:10,050 --> 00:00:11,430
0,60 60,120 120,390 390,840 1200,1380
of a recent paper,| and
|这是一篇研究论文，

8
00:00:11,430 --> 00:00:13,260
0,240 240,510 510,810 810,1260 1290,1830
{it's,really} a research paper,| and
|这个研究论文的主题是，

9
00:00:13,320 --> 00:00:14,280
0,180 180,480 480,570 570,660 660,960
the topic of the research

10
00:00:14,280 --> 00:00:16,830
0,540 540,930 930,1380 1380,1860 2130,2550
paper is| trying to explore
|试图探索一些想法和技术

11
00:00:16,830 --> 00:00:18,810
0,150 150,690 690,810 810,1500 1500,1980
some ideas and technologies| to
|来获得高性能的事务，

12
00:00:18,810 --> 00:00:20,520
0,180 180,390 390,870 870,1620
get high performance transactions,|
|

13
00:00:31,700 --> 00:00:33,410
0,480 480,690 690,870 930,1140 1140,1710
and with {} high performance,|
高性能，|

14
00:00:33,410 --> 00:00:34,850
0,240 240,1020 1050,1230 1230,1380 1380,1440
just to make sure we're
为了确保我们，是我们想要的，

15
00:00:34,850 --> 00:00:36,830
0,240 240,810 1200,1590 1590,1770 1770,1980
on the, roughly what we're

16
00:00:36,830 --> 00:00:38,840
0,300 300,690 870,1470 1470,1860 1860,2010
looking for,| high performance from
|高性能意味着，

17
00:00:38,840 --> 00:00:40,430
0,210 210,750 750,990 990,1260 1260,1590
that means,| they're getting {140,million
|他们获得 1.4 亿个事务每秒，

18
00:00:40,430 --> 00:00:41,600
0,810
-}

19
00:00:43,470 --> 00:00:45,600
0,510 510,630 630,1260 1320,1770 1770,2130
transactions per second,| {} on
|在 TATP 基准上，使用 90 台机器，

20
00:00:45,600 --> 00:00:49,680
0,270 270,600 600,660 660,1500 3210,4080
this {you,know} {TATP -} benchmark,

21
00:00:50,290 --> 00:00:53,400
0,480 480,780 780,1110 1110,1770
{} using 90 machines,|
|

22
00:00:58,620 --> 00:01:00,180
0,360 360,720 720,1320 1350,1440 1440,1560
and so {} you know
所以这个数字是否令人印象深刻，

23
00:01:00,180 --> 00:01:01,410
0,150 150,360 360,510 510,810 810,1230
whether {} this {number,is} impressive,|
|

24
00:01:01,410 --> 00:01:02,790
0,150 150,600 600,930 930,1230 1230,1380
of {course,you,know} depends on {}
当然取决于你知道的数字，

25
00:01:02,790 --> 00:01:03,570
0,90 90,360 360,450 450,690 690,780
the numbers you know,| and
|有人还记得，

26
00:01:03,570 --> 00:01:05,160
0,270 270,420 510,1020 1020,1440 1440,1590
so does anybody remember,| how
|Spanner 每秒能处理多少事务吗？

27
00:01:05,160 --> 00:01:06,600
0,180 180,660 660,750 750,1080 1080,1440
many transactions per second Spanner

28
00:01:06,600 --> 00:01:07,340
0,120 120,450
could do?|
|

29
00:01:16,220 --> 00:01:17,280
0,750
Anybody?|
有人知道吗？|

30
00:01:27,130 --> 00:01:28,780
0,270 270,540 540,1020 1110,1590 1590,1650
So if we remember the
所以如果我们记得那篇论文，

31
00:01:28,780 --> 00:01:30,190
0,420 420,510 510,630 630,990 1020,1410
paper,| you know certain {}
|那里发生多少事务，

32
00:01:30,190 --> 00:01:31,690
0,450 450,810 810,930 930,1170 1170,1500
transaction there {you,know} took about|
|

33
00:01:31,960 --> 00:01:32,890
0,390 390,480 480,630 630,720 720,930
depending on what you did,|
取决于你所做的，|

34
00:01:32,890 --> 00:01:34,450
0,120 120,570 600,840 840,1410 1410,1560
you know 10 to {100
10 到 100 毫秒，

35
00:01:34,450 --> 00:01:36,280
0,240 240,840 840,1380 1380,1530 1530,1830
-} milliseconds,| so {you,know} 10
|所以每秒 10 到 100 个事务。

36
00:01:36,280 --> 00:01:38,410
0,90 90,180 180,210 210,720 1290,2130
to {} {100 -} {}

37
00:01:38,440 --> 00:01:41,800
0,810 810,1860 2190,2550 2550,2670 2670,3360
transactions { -} per second.|
|

38
00:01:41,800 --> 00:01:44,590
0,420 660,1080 1080,1710 1860,2280 2280,2790
So, {} the number transactions
所以， FaRM 可以处理的事务数量是

39
00:01:44,590 --> 00:01:45,790
0,330 360,540 540,840 840,960 960,1200
that {} FaRM can do

40
00:01:45,790 --> 00:01:47,440
0,420 420,600 600,720 720,1320 1320,1650
is| in a completely different
|在一个完全不同的数量级。

41
00:01:47,440 --> 00:01:48,620
0,330 330,390 390,1050
order of magnitude.|
|

42
00:01:49,050 --> 00:01:50,010
0,150 150,270 270,630 630,750 750,960
And that partly is because
部分是因为它们是完全不同的系统，

43
00:01:50,010 --> 00:01:52,200
0,90 90,420 420,660 660,1290 1680,2190
they're completely different systems, {}|
|

44
00:01:52,200 --> 00:01:54,510
0,870 900,1170 1170,1260 1260,1440 1440,2310
Spanner tries to do synchronous
Spanner 试图在全球范围内进行同步复制，

45
00:01:54,510 --> 00:01:56,550
0,330 330,1020 1020,1380 1380,1500 1500,2040
[] replication across the world,|
|

46
00:01:56,820 --> 00:01:58,770
0,480 480,870 870,1230 1230,1590 1590,1950
and FaRM actually everything runs
而 FaRM 的一切都在一个数据中心运行。

47
00:01:58,770 --> 00:02:00,240
0,150 150,570 570,870 870,1110 1110,1470
in a single data center.|
|

48
00:02:04,560 --> 00:02:06,240
0,210 210,360 360,480 480,1410 1410,1680
And so the applications that
所以， FaRM 和 Spanner 针对的应用程序完全不同，

49
00:02:06,240 --> 00:02:08,580
0,270 270,900 900,1350 1350,1890 1890,2340
been targeted by FaRM and

50
00:02:08,700 --> 00:02:10,560
0,390 390,540 540,810 810,1290 1380,1860
Spanner a quite different,| Spanner
|Spanner 针对不能容忍数据中心崩溃的应用程序，

51
00:02:10,560 --> 00:02:13,350
0,660 720,1530 1530,1680 1680,2070 2070,2790
targeting applications that cannot {tolerate

52
00:02:13,440 --> 00:02:15,810
0,1830 1830,1830 1830,2220 2220,2310 2310,2370
-} the crash with a

53
00:02:15,810 --> 00:02:17,400
0,210 210,690 840,1260 1260,1380 1380,1590
data center,| like you know
|比如 F1 广告服务数据库，

54
00:02:17,400 --> 00:02:19,530
0,330 330,480 480,990 990,1680 1800,2130
{} {F1 -} {} AD

55
00:02:19,530 --> 00:02:22,290
0,450 450,1200 1320,2190 2190,2640 2640,2760
serving database,| while Spanner is
|Spanner 非常好，

56
00:02:22,290 --> 00:02:24,060
0,450 450,690 690,1200 1230,1590 1590,1770
much, very well,| FaRM much
|FaRM 更针对

57
00:02:24,060 --> 00:02:25,770
0,120 120,780 990,1320 1320,1440 1440,1710
more targeting sort of| like
|比如你是所有 MySQL

58
00:02:25,770 --> 00:02:27,930
0,750 810,1110 1110,1470 1470,1650 1650,2160
you're you're using {MySQL -}|
|

59
00:02:27,930 --> 00:02:29,130
0,330 330,480 480,780 780,1110 1110,1200
or some other sort of
或某种其他类型的应用数据库系统，

60
00:02:29,130 --> 00:02:32,310
0,750 780,1710 1710,2250 2280,2730 2730,3180
{} database application database system,|
|

61
00:02:32,460 --> 00:02:33,480
0,210 210,300 300,540 540,780 780,1020
and you want much more
你想要更高性能的事务，

62
00:02:33,480 --> 00:02:36,810
0,180 180,900 900,1830 1860,2610 2820,3330
high performance {} transactions,| then
|那么 FaRM 是一种可能的设计或可能的选择。

63
00:02:36,810 --> 00:02:37,800
0,60 60,300 300,720 720,810 810,990
you know {FaRM -} sort

64
00:02:37,800 --> 00:02:39,390
0,60 60,570 570,1020 1020,1470 1470,1590
of a possible design or

65
00:02:39,390 --> 00:02:40,820
0,90 90,660 660,1320
a possible alternative.|
|

66
00:02:41,950 --> 00:02:43,840
0,120 120,300 300,990 990,1560 1590,1890
They do provide strict {serializability
它们提供了严格的可串行化，

67
00:02:43,840 --> 00:02:46,340
0,750
-},|
|

68
00:02:48,370 --> 00:02:49,870
0,360 360,420 420,810 810,1080 1080,1500
which is similar to the
类似于 Spanner 提供的外部一致性。

69
00:02:51,810 --> 00:02:55,680
0,630 630,1530 1560,2100 2700,3360 3390,3870
external consistency that {} Spanner

70
00:02:55,680 --> 00:02:56,440
0,480
offered.|
|

71
00:02:56,990 --> 00:02:58,010
0,270 270,570 600,690 690,810 810,1020
And so the whole goal
所以，整个目标是获得高性能，

72
00:02:58,010 --> 00:02:58,880
0,60 60,120 120,240 240,390 390,870
is to get high performance,|
|

73
00:02:58,880 --> 00:03:00,230
0,150 150,270 270,360 360,780 780,1350
so there are numerous ideas
有很多想法会实现高性能。

74
00:03:00,230 --> 00:03:01,340
0,90 90,210 210,360 360,750 750,1110
you know they're going to

75
00:03:01,340 --> 00:03:03,710
0,570 570,720 720,1380 1590,1920 1920,2370
achieving high performance.| {} One,
|一个是，他们分片，

76
00:03:03,710 --> 00:03:05,200
0,450 450,630 630,1230
they they shard,|
|

77
00:03:05,470 --> 00:03:07,580
0,420 420,810 810,1110 1110,1680
that's probably the main
这可能是他们使用的主要标准技术，

78
00:03:07,860 --> 00:03:09,270
0,300 300,720 720,1140 1140,1260 1260,1410
{you,know} standard technique that they

79
00:03:09,270 --> 00:03:10,080
0,330 330,480 480,630 630,750 750,810
used,| that was going to
|这将给我们带来性能，

80
00:03:10,080 --> 00:03:11,220
0,180 180,360 360,510 510,1050 1050,1140
give us the performance,| for
|例如，如果不同的记录在不同的分片上，

81
00:03:11,220 --> 00:03:13,470
0,510 510,900 930,1020 1020,1290 1470,2250
example if you know different

82
00:03:13,500 --> 00:03:14,940
0,690 690,960 960,1140 1140,1170 1170,1440
records are on a different

83
00:03:14,940 --> 00:03:17,640
0,510 510,1110 1110,1770 1770,1890 2340,2700
shards,| and transactions {you,know} touch
|事务触及不同的分片，

84
00:03:17,640 --> 00:03:18,930
0,30 30,330 330,660 660,810 810,1290
the different shard,| then these
|然后这些事务可以并行运行，

85
00:03:19,260 --> 00:03:21,210
0,570 570,780 780,1080 1110,1680 1770,1950
{transaction,can,just} run in parallel,| and
|所以，如果你有 90 台机器，

86
00:03:21,210 --> 00:03:23,040
0,300 750,1260 1260,1650 1650,1710 1710,1830
so, {} if you have

87
00:03:23,040 --> 00:03:24,660
0,300 300,690 690,960 960,1320 1320,1620
90 machines,| {you,know} get 90
|获得一台机器的性能的 90 倍。

88
00:03:24,660 --> 00:03:27,210
0,390 390,1380 1440,1800 1800,2040 2040,2550
times you know the performance

89
00:03:27,210 --> 00:03:28,080
0,90 90,150 150,390 390,720
of a single machine.|
|

90
00:03:28,520 --> 00:03:29,570
0,180 180,630 630,780 780,930 930,1050
So sharding are sort of
所以分片是一个起点，

91
00:03:29,570 --> 00:03:31,520
0,420 420,810 1320,1680 1680,1800 1800,1950
starting point,| but then they
|但他们走得更远，

92
00:03:31,520 --> 00:03:34,100
0,180 180,360 360,1590 1830,2250 2250,2580
go much further,| so they
|他们使用非易失性 DRAM ，

93
00:03:34,100 --> 00:03:37,860
0,720 720,2160 2370,3330
use non-volatile DRAM,|
|

94
00:03:39,560 --> 00:03:40,640
0,120 120,270 270,390 390,510 510,1080
and this is to avoid
这是为了避免不得不写入稳定存储设备的瓶颈，

95
00:03:40,640 --> 00:03:42,080
0,180 180,270 270,900 900,1170 1170,1440
to the bottleneck of having

96
00:03:42,080 --> 00:03:44,810
0,120 120,450 450,1080 1080,2040 2340,2730
to write to {} stable

97
00:03:44,810 --> 00:03:46,580
0,270 270,810 810,1170 1440,1620 1620,1770
storage devices,| so in their
|所以在他们的设计中，

98
00:03:46,580 --> 00:03:47,750
0,450 450,540 540,720 720,990 990,1170
design,| you don't actually have
|你不必写入关键路径到固态硬盘或磁盘，

99
00:03:47,750 --> 00:03:48,920
0,120 120,510 510,720 720,810 810,1170
to write in the [critical

100
00:03:48,920 --> 00:03:50,840
0,600 810,1050 1050,1170 1170,1710 1710,1920
path] to an SSD or

101
00:03:50,840 --> 00:03:52,370
0,90 90,720 810,1080 1080,1410 1410,1530
a disk,| {} and so
|所以，他们避免了这样做的全部花费，

102
00:03:52,370 --> 00:03:53,810
0,150 150,510 510,570 570,870 870,1440
they avoid the whole cost

103
00:03:53,810 --> 00:03:56,270
0,900 1170,1470 1470,1950 2070,2310 2310,2460
of doing so,| which can
|这可能相当昂贵，

104
00:03:56,270 --> 00:03:57,650
0,90 90,330 330,1020 1050,1230 1230,1380
be quite expensive,| and that's
|例如，你可以考虑你的 Raft 实现，

105
00:03:57,650 --> 00:03:58,910
0,300 300,660 660,780 780,960 960,1260
for example you think about

106
00:03:58,910 --> 00:04:00,440
0,450 660,1320
your {}

107
00:04:01,030 --> 00:04:02,800
0,840 840,1050 1050,1470 1470,1560 1560,1770
implementations of Raft,| you know
|他们存储或者使数据持久化，

108
00:04:02,800 --> 00:04:05,830
0,1740 2010,2220 2220,2760 2820,2910 2910,3030
they they store you know

109
00:04:05,830 --> 00:04:07,870
0,240 240,420 420,690 690,1350 1620,2040
or make data persistent, {}|
|

110
00:04:07,870 --> 00:04:09,070
0,300 300,720 720,780 780,930 930,1200
and typically you know making
通常情况下，在稳定的存储设备上进行持久化，

111
00:04:09,070 --> 00:04:10,690
0,300 300,870 870,1170 1170,1350 1350,1620
something persistent on a stable

112
00:04:10,690 --> 00:04:12,100
0,270 270,720 720,810 810,1170 1170,1410
storage device,| you know the
|几百毫秒的量级，

113
00:04:12,100 --> 00:04:15,070
0,360 360,540 960,1620 1770,2370 2370,2970
order of hundreds of milliseconds,

114
00:04:15,070 --> 00:04:17,710
0,210 210,600 600,870 1440,1920 2100,2640
or hundreds of,| a few
|几毫秒到十毫秒，

115
00:04:17,710 --> 00:04:19,720
0,870 870,990 990,1200 1200,1680 1680,2010
milliseconds you know to tens

116
00:04:19,720 --> 00:04:21,250
0,90 90,600 600,780 780,960 960,1530
of milliseconds to ten milliseconds,|
|

117
00:04:21,250 --> 00:04:22,060
0,90 90,300 300,570 570,780 780,810
if you're actually using a
如果你使用磁盘，

118
00:04:22,060 --> 00:04:22,980
0,390 390,840
magnetic disk,|
|

119
00:04:23,460 --> 00:04:24,780
0,390 390,900 900,990 990,1140 1140,1320
an SSD you know sort
一个 SSD 有几毫秒，

120
00:04:24,780 --> 00:04:25,890
0,90 90,660 690,990 990,1050 1050,1110
of, {} sort of {}

121
00:04:25,890 --> 00:04:28,830
0,510 1230,1920 2130,2520 2520,2760 2760,2940
millisecond,| and so given the
|所以，考虑到它们运作的时间，

122
00:04:28,830 --> 00:04:30,090
0,420 420,510 510,1050 1050,1140 1140,1260
{time,for} they operate,| you know
|这种方式花费太高了。

123
00:04:30,090 --> 00:04:31,560
0,210 210,390 390,810 810,930 930,1470
that way just too costly,|
|

124
00:04:31,590 --> 00:04:33,060
0,330 330,510 510,1140 1140,1260 1260,1470
so they use some people
所以他们使用一些人称为非易失性 DRAM ，

125
00:04:33,060 --> 00:04:34,530
0,90 90,300 300,900 900,1320 1320,1470
they call non-volatile DRAM,| this
|我们稍后会谈到这一点，

126
00:04:34,530 --> 00:04:35,190
0,150 150,330 330,540 540,600 600,660
we'll talk about in a

127
00:04:35,190 --> 00:04:37,800
0,360 1230,1710 1800,2100 2100,2250 2250,2610
second,| and then so that
|这样就消除了存储访问成本。

128
00:04:37,800 --> 00:04:40,260
0,390 390,600 600,930 930,1710 1740,2460
gets rid of storage {}

129
00:04:40,620 --> 00:04:42,780
0,510 510,1110 1320,1920 1920,2040 2040,2160
access cost.| And so the
|他们要解决的下两个瓶颈是

130
00:04:42,780 --> 00:04:44,700
0,660 660,1170 1170,1260 1260,1740 1740,1920
next two {} bottleneck they

131
00:04:44,700 --> 00:04:48,180
0,1020 1050,1650 1650,2400 2460,3120 3120,3480
{address,is}| CPU bottlenecks and network
|CPU 瓶颈和网络瓶颈，

132
00:04:48,180 --> 00:04:50,430
0,600 1020,1200 1200,1530 1530,1620 1620,2250
bottlenecks,| and {for,that}, to use
|要实现这一点，需要使用一种称为内核旁路的技术，

133
00:04:50,430 --> 00:04:53,260
0,510 540,1110 1110,1470 1470,2310
{} technical {called,kernel} bypass,|
|

134
00:04:57,010 --> 00:04:58,450
0,180 180,540 540,960 960,1080 1080,1440
which basically avoids the operating
这避免了操作系统与网卡交互，

135
00:04:58,450 --> 00:05:00,520
0,1050 1080,1590 1590,1680 1680,1980 1980,2070
system for, to talk to

136
00:05:00,520 --> 00:05:01,960
0,90 90,420 420,840 1080,1320 1320,1440
the network card,| and then
|然后他们使用具有 RDMA 特殊功能的网卡，

137
00:05:01,960 --> 00:05:03,130
0,120 120,360 360,660 660,1020 1020,1170
they use network cards that

138
00:05:03,130 --> 00:05:05,740
0,180 180,1230 1230,1590 1590,2190 2220,2610
have a special feature called

139
00:05:05,740 --> 00:05:06,860
0,870
RDMA,|
|

140
00:05:10,530 --> 00:05:12,420
0,360 360,840 840,1440 1470,1710 1710,1890
that allows the card to
这允许网卡从远程服务器读取内存，

141
00:05:12,420 --> 00:05:14,070
0,420 450,990 990,1350 1350,1560 1560,1650
{read,and} write memory from {}

142
00:05:14,070 --> 00:05:15,540
0,270 270,660 660,1020 1020,1260 1260,1470
remote server| without actually having
|而不必中断远程服务器，

143
00:05:15,540 --> 00:05:16,920
0,90 90,690 720,900 900,1020 1020,1380
to interrupt you know that

144
00:05:16,980 --> 00:05:18,120
0,360 360,840
remote server,|
|

145
00:05:18,420 --> 00:05:20,070
0,390 390,510 510,630 630,1080 1290,1650
{} and so this {}
所以，这为我们提供了

146
00:05:20,070 --> 00:05:21,660
0,210 210,330 330,900 930,1380 1380,1590
gives us| really {} low
|对远程服务器或远程内存的低延迟网络访问，

147
00:05:21,660 --> 00:05:23,790
0,870 870,1200 1230,1620 1620,1980 1980,2130
latency {} network access to

148
00:05:23,790 --> 00:05:24,900
0,90 90,390 390,840
{} remote server,

149
00:05:25,300 --> 00:05:26,920
0,630 630,810 810,930 930,1200 1200,1620
{} or to remote memory,|
|

150
00:05:26,950 --> 00:05:27,940
0,210 210,420 420,750 750,900 900,990
this is partially where the
这就是 FaRM 名称的来源,

151
00:05:27,940 --> 00:05:29,440
0,330 330,630 630,870 870,1320 1320,1500
name FaRM comes from,| {you,know,the}
|R 代表远程， M 代表内存， Fa 代表快速。

152
00:05:29,440 --> 00:05:31,600
0,510 510,1170 1200,1440 1440,1620 1620,2160
{R,stands,for} remote and {M,for} memory

153
00:05:31,840 --> 00:05:33,480
0,270 270,750 750,870 870,1410
and Fa for fast.|
|

154
00:05:34,810 --> 00:05:36,820
0,600 1140,1290 1290,1500 1500,1740 1740,2010
{} So, those are the,
所以，这些就是他们使用的技术，

155
00:05:37,030 --> 00:05:38,860
0,450 450,630 630,1050 1080,1680 1680,1830
those are the technologies they

156
00:05:38,860 --> 00:05:40,960
0,510 570,1080 1080,1290 1290,1830 1980,2100
use,| {} and then you
|然后，为了能够真正利用这些技术，

157
00:05:40,960 --> 00:05:41,620
0,150 150,270 270,360 360,540 540,660
know to be able to

158
00:05:41,620 --> 00:05:43,870
0,210 210,600 600,750 750,1560 1740,2250
really exploit these technologies| drives
|驱动他们设计，

159
00:05:43,870 --> 00:05:45,160
0,210 210,660 660,750 750,1170 1170,1290
them to a design,| that
|使用乐观并发控制，

160
00:05:45,160 --> 00:05:46,810
0,240 240,810 810,900 900,1230 1230,1650
uses optimistic {concurrency -} control|
|

161
00:05:47,220 --> 00:05:49,680
0,420 420,1200 1230,1530 1530,1860 1890,2460
or OCC, {} the short
或 OCC ，这个的缩写，乐观的，

162
00:05:49,680 --> 00:05:51,510
0,360 360,450 450,630 630,900 900,1830
version of this, so optimistic,|
|

163
00:05:56,230 --> 00:05:57,940
0,540 540,900 900,1410 1410,1500 1500,1710
and in contrast with many
与我们到目前为止看到的许多设计相比，

164
00:05:57,940 --> 00:05:58,780
0,90 90,180 180,570 570,720 720,840
of the designs that we've

165
00:05:58,780 --> 00:06:00,880
0,150 150,360 360,600 600,1200 1290,2100
seen so far,| where they
|它们使用通常被称为悲观并发控制方案，

166
00:06:00,880 --> 00:06:02,290
0,360 360,510 510,690 690,1020 1020,1410
use what was typically called

167
00:06:02,290 --> 00:06:04,150
0,690 690,1020 1020,1380 1380,1740 1740,1860
pessimistic concurrency control scheme,| and
|悲观控制方案获得锁

168
00:06:04,150 --> 00:06:06,940
0,570 570,1230 1230,1710 1860,2280 2280,2790
pessimistic control scheme basically acquire

169
00:06:06,940 --> 00:06:09,580
0,690 780,1680 1680,2430 2430,2490 2490,2640
locks| {} on you know
|在事务接触到对象时，

170
00:06:09,580 --> 00:06:12,070
0,750 960,2010 2010,2070 2070,2220 2220,2490
the objects are being touched

171
00:06:12,070 --> 00:06:14,680
0,120 120,240 240,960 1200,1860 1860,2610
by the transaction,| {} and
|所以当它们到达提交时间时，

172
00:06:14,680 --> 00:06:15,670
0,240 240,390 390,630 630,810 810,990
{} so when they get

173
00:06:15,670 --> 00:06:17,230
0,120 120,390 390,900 1050,1350 1350,1560
to commit time,| {} they
|它们拥有所有相关对象的所有锁，

174
00:06:17,230 --> 00:06:18,340
0,300 300,450 450,540 540,870 870,1110
own all the locks for

175
00:06:18,340 --> 00:06:19,720
0,180 180,390 390,750 750,1170 1170,1380
all the relevant objects| and
|继续并提交，

176
00:06:19,720 --> 00:06:21,430
0,210 210,360 360,660 660,780 780,1710
just go ahead and commit,|
|

177
00:06:21,580 --> 00:06:23,740
0,990 1110,1350 1350,1530 1530,2070 2070,2160
while {} with optimistic {concurrency
而使用乐观并发控制，

178
00:06:23,740 --> 00:06:25,120
0,300 300,780 780,870 870,1080 1080,1380
-} control,| you don't actually
|你不需要获取锁，

179
00:06:25,120 --> 00:06:27,370
0,720 750,1140 1140,1440 1440,1530 1530,2250
acquire {} {locks -},| particularly
|特别是在 FaRM 中，

180
00:06:27,610 --> 00:06:29,140
0,420 420,480 480,690 720,1200 1200,1530
{in,FaRM},| you don't require locks
|你不需要在读事务中获取锁，

181
00:06:29,140 --> 00:06:31,840
0,300 300,570 870,1470 1500,2160 2190,2700
on the read {} transaction,|
|

182
00:06:32,720 --> 00:06:34,760
0,600 780,1200 1200,1500 1500,1710 1710,2040
and {} when you do
当你执行提交的时候，

183
00:06:34,760 --> 00:06:35,720
0,180 180,540 540,660 660,870 870,960
go commit,| you actually have
|你必须验证，

184
00:06:35,720 --> 00:06:37,940
0,60 60,690 690,1020 1020,1410 1410,2220
to validate,| that you read,
|你读取最近的对象，

185
00:06:37,940 --> 00:06:39,770
0,360 360,1200 1200,1290 1290,1530 1530,1830
{you,know} read the most recent

186
00:06:39,770 --> 00:06:41,630
0,570 780,1200 1200,1440 1440,1560 1560,1860
objects| {} and if so,
|如果是这样，你可以提交，

187
00:06:41,630 --> 00:06:42,680
0,150 150,270 270,600 600,930 930,1050
you can go commit,| and
|如果不是，你必须中止，

188
00:06:42,680 --> 00:06:43,550
0,120 120,270 270,690 690,780 780,870
if you're not, you know

189
00:06:43,550 --> 00:06:44,900
0,150 150,300 300,390 390,900 900,1350
you have to abort| and
|也许还会再试一次。

190
00:06:44,900 --> 00:06:45,960
0,210 210,450 450,780
maybe try again.|
|

191
00:06:46,530 --> 00:06:48,360
0,420 900,1110 1110,1500 1500,1620 1620,1830
And the reason they use
他们使用乐观并发控制的原因，

192
00:06:48,360 --> 00:06:49,770
0,510 510,780 780,1140 1140,1260 1260,1410
optimization concurrence control,| as we'll
|我们稍后将会看到，

193
00:06:49,770 --> 00:06:50,490
0,180 180,240 240,300 300,630 630,720
see in a second,| is
|是由他们想要使用 RDMA 这一事实驱动的。

194
00:06:50,490 --> 00:06:51,780
0,300 300,720 720,900 900,990 990,1290
really driven by the fact

195
00:06:51,780 --> 00:06:52,890
0,120 120,300 300,510 510,600 600,1110
that they want to use

196
00:06:52,890 --> 00:06:53,840
0,150 150,690
{RDMA -}.|
|

197
00:06:54,400 --> 00:06:55,400
0,690

198
00:06:56,820 --> 00:06:57,630
0,240 240,360 360,510 510,570 570,810
Okay, so then the final
好的，那么最后一个部分是概述，

199
00:06:57,630 --> 00:06:58,890
0,390 390,690 690,870 870,1140 1140,1260
component to this is {}

200
00:06:58,890 --> 00:07:00,090
0,270 270,720 720,900 900,990 990,1200
certain overview,| this is really
|这是一个研究原型，

201
00:07:00,090 --> 00:07:01,400
0,60 60,390 390,1050
a research prototype,|
|

202
00:07:05,250 --> 00:07:06,750
0,210 210,300 300,420 420,870 930,1500
so {unlike - -} {}
与 Spanner 不同，是已部署的系统，

203
00:07:06,780 --> 00:07:07,980
0,600 600,720 720,810 810,1020 1020,1200
Spanner, you know which is

204
00:07:07,980 --> 00:07:11,160
0,210 240,1020 1230,2130 2190,2640 2640,3180
a deployed system,| you know
|它一直在活跃地使用，

205
00:07:11,550 --> 00:07:14,010
0,180 180,750 750,1080 1080,1590 1800,2460
it's been active use, {}|
|

206
00:07:14,040 --> 00:07:15,750
0,450 450,570 570,1050 1050,1350 1350,1710
FaRM is really a product
FARM 是微软研究的产品，

207
00:07:15,750 --> 00:07:17,190
0,420 480,690 690,1050 1050,1290 1290,1440
of the research [] of

208
00:07:17,190 --> 00:07:19,860
0,660 930,1680 1680,2280 2310,2580 2580,2670
Microsoft,| Microsoft research trying to
|微软研究试图探索新想法，

209
00:07:19,860 --> 00:07:22,590
0,510 510,750 750,1440 1620,2010 2010,2730
explore new ideas,| to see
|看看什么能获得更高的

210
00:07:22,590 --> 00:07:23,910
0,240 240,420 420,840 870,1020 1020,1320
how, { -} to see

211
00:07:23,910 --> 00:07:25,620
0,210 210,240 240,510 510,1080 1080,1710
what {} can achieve higher|
|

212
00:07:25,740 --> 00:07:27,300
0,240 240,480 480,690 690,1170 1170,1560
or really high performance transaction
或很高的性能的事务系统，

213
00:07:27,300 --> 00:07:28,170
0,360 360,450 450,600 600,690 690,870
systems,| and this is just
|这是一项非常活跃的研究，

214
00:07:28,170 --> 00:07:30,360
0,30 30,300 300,810 810,1500 1530,2190
a very active research,| people
|人们喜欢拥有事务的力量，

215
00:07:30,360 --> 00:07:31,620
0,180 180,360 360,570 570,660 660,1260
would just love to have

216
00:07:31,890 --> 00:07:34,050
0,570 570,1050 1050,1380 1380,1440 1440,2160
{} the power of transactions,|
|

217
00:07:34,230 --> 00:07:35,940
0,600 600,780 780,930 930,1290 1290,1710
{} and but also the
但是也想要性能。

218
00:07:36,030 --> 00:07:36,800
0,690
performance.|
|

219
00:07:37,780 --> 00:07:38,900
0,690

220
00:07:40,430 --> 00:07:41,690
0,300 300,480 480,720 720,930 930,1260
Okay, so that's sort of
好的，这是一个简短的介绍，

221
00:07:41,690 --> 00:07:43,100
0,300 300,750 750,930 930,1290 1290,1410
short introduction,| any questions so
|到目前为止，有什么问题吗？

222
00:07:43,100 --> 00:07:43,880
0,480
far?|
|

223
00:07:49,860 --> 00:07:52,200
0,630 900,1200 1200,1830 2070,2310 2310,2340
Okay, let's {} talk a
好的，让我们来谈谈 FaRM 的设置。

224
00:07:52,200 --> 00:07:54,030
0,180 180,360 360,660 660,1110 1140,1830
little bit about the setup

225
00:07:59,060 --> 00:08:00,300
0,390 390,960
for FaRM.|
|

226
00:08:00,510 --> 00:08:02,880
0,420 420,660 660,1050 1260,1980 2040,2370
And so there's basically 90
所以这里有 90 台机器，

227
00:08:02,880 --> 00:08:04,140
0,630
machines,

228
00:08:10,150 --> 00:08:11,710
0,360 360,450 450,630 630,1200 1260,1560
90 of these guys, {}|
|

229
00:08:11,710 --> 00:08:13,870
0,180 180,690 720,1320 1320,1470 1470,2160
they're connected by {} high-speed
它们通过高速数据中心网络连接，

230
00:08:13,960 --> 00:08:16,360
0,600 600,780 780,1350 1380,1950 1980,2400
data center network,| and see
|看其中一个，

231
00:08:16,360 --> 00:08:18,040
0,150 150,510 510,930 1230,1530 1530,1680
a particular one,| I'm just
|我把它画成一条线，

232
00:08:18,040 --> 00:08:19,060
0,120 120,180 180,480 480,780 780,1020
going to draw that as

233
00:08:19,060 --> 00:08:20,920
0,450 540,960 960,1350 1350,1560 1560,1860
a single line,| of course,
|当然，内部是一个交换网络，

234
00:08:20,920 --> 00:08:22,630
0,150 150,240 240,630 630,990 990,1710
it's a switch network internally,|
|

235
00:08:23,020 --> 00:08:27,970
0,720 1140,2580 2820,3570 3570,4260 4410,4950
{} and basically shard,| {the,data,is}
然后分片，|数据分片在这些不同的机器上，

236
00:08:27,970 --> 00:08:31,480
0,420 420,1230 1470,2010 2010,2850 2850,3510
sharded across these different machines,|
|

237
00:08:31,690 --> 00:08:32,880
0,930
and
根据分片的级别，一些也称为区域，

238
00:08:33,100 --> 00:08:35,170
0,720 810,1350 1350,1440 1440,1740 1740,2070
the level of sharding happens,

239
00:08:35,170 --> 00:08:36,970
0,480 480,750 750,960 960,1170 1170,1800
{} some else called region,|
|

240
00:08:37,800 --> 00:08:41,120
0,480 840,1410 1410,1560 1560,2160
so region is 2
所以区域是 2G 字节，

241
00:08:41,570 --> 00:08:42,860
0,810
gigabyte,|
|

242
00:08:44,730 --> 00:08:45,840
0,420 420,510 510,660 660,840 840,1110
and you know those regions
这些区域分片在

243
00:08:45,840 --> 00:08:47,610
0,120 120,450 450,870 870,1140 1140,1770
are sharded| across different networks
|不同的网络，不同的机器上，

244
00:08:48,230 --> 00:08:49,790
0,210 210,330 330,600 600,1140 1230,1560
and the different machines, {}|
|

245
00:08:49,790 --> 00:08:51,620
0,150 150,450 450,810 840,1230 1260,1830
the region live in memory,|
区域在内存中，|

246
00:08:52,010 --> 00:08:53,390
0,150 150,360 360,450 450,690 690,1380
so this is just DRAM,|
所以这是 DRAM ，|

247
00:08:56,490 --> 00:08:58,800
0,390 390,750 750,1290 1290,1830 1830,2310
{} and not {} in
而不是在磁盘上，

248
00:08:58,800 --> 00:09:00,120
0,270 270,360 360,420 420,930 960,1320
{for,example} on the disk,| so
|所以，你的数据库的全部数据集

249
00:09:00,120 --> 00:09:03,540
0,690 960,1920 2010,2760 2790,3150 3150,3420
basically, {} the total {dataset

250
00:09:03,540 --> 00:09:05,160
0,420 420,720 720,900 900,1380 1380,1620
-} of your database| actually
|必须与你使用的机器的联合 DRAM 相适应，

251
00:09:05,160 --> 00:09:06,390
0,240 240,330 330,690 690,1080 1080,1230
has to fit in the

252
00:09:06,390 --> 00:09:08,610
0,630 900,1770 1770,1830 1830,1920 1920,2220
joint DRAMs of the machine

253
00:09:08,610 --> 00:09:09,510
0,120 120,270 270,630 630,810 810,900
that you're using,| so if
|如果你的数据集大于你当前的计算机集，

254
00:09:09,510 --> 00:09:10,770
0,210 210,600 600,690 690,1080 1080,1260
your dataset is larger than

255
00:09:10,770 --> 00:09:11,580
0,90 90,300 300,420 420,480 480,810
your current set of machines,|
|

256
00:09:11,580 --> 00:09:12,360
0,90 90,210 210,270 270,480 480,780
you have to buy more
你必须购买更多机器，拥有更多 DRAM ，

257
00:09:12,360 --> 00:09:13,620
0,420 420,540 540,630 630,810 810,1260
machines, that get more DRAM,|
|

258
00:09:13,620 --> 00:09:14,550
0,150 150,240 240,360 360,630 630,930
so they can actually fit.|
这样它们才能适合。|

259
00:09:16,150 --> 00:09:17,320
0,180 180,480 480,540 540,810 810,1170
And again, the reason why
他们想使用 DRAM 的原因是，

260
00:09:17,320 --> 00:09:19,060
0,150 150,300 300,1350 1380,1680 1680,1740
you know they want to

261
00:09:19,060 --> 00:09:20,410
0,180 180,600 600,720 720,1050 1050,1350
use DRAM is,| because they
|他们想要[]存储设备性能方面的瓶颈，

262
00:09:20,410 --> 00:09:21,640
0,240 240,330 330,540 540,750 750,1230
want {[] - -} bottleneck

263
00:09:21,640 --> 00:09:22,360
0,390
by

264
00:09:22,710 --> 00:09:25,410
0,390 390,990 990,1530 1710,2370 2370,2700
the performance of {} storage

265
00:09:25,410 --> 00:09:28,860
0,690 870,1680 1800,1980 2880,3270 3270,3450
devices,| and of course {you,know}
|当然，机器可能出现故障，

266
00:09:28,860 --> 00:09:30,270
0,300 300,450 450,1020 1020,1290 1290,1410
machine can fail,| and if
|如果机器出现故障，它会丢失 DRAM ，

267
00:09:30,270 --> 00:09:32,130
0,30 30,330 330,720 720,1350 1350,1860
a machine fails, {it,uses} loses

268
00:09:32,130 --> 00:09:34,170
0,600 720,1200 1200,1410 1410,1740 1740,2040
DRAM,| {} and so therefore
|所以，他们使用复制，

269
00:09:34,170 --> 00:09:35,880
0,120 120,270 270,870 1080,1530 1530,1710
they use replication,| and so
|他们在多台机器上复制区域，

270
00:09:35,880 --> 00:09:37,860
0,180 180,750 750,1200 1200,1650 1650,1980
they replicate regions across multiple

271
00:09:37,860 --> 00:09:39,750
0,600 930,1170 1170,1410 1410,1770 1770,1890
machines,| {} one machine is
|一台机器是一个区域的 primary ，

272
00:09:39,750 --> 00:09:41,910
0,450 480,1020 1020,1470 1470,1590 1590,2160
{} primary for a region,|
|

273
00:09:42,210 --> 00:09:43,740
0,240 240,450 450,720 720,810 810,1530
and that makes {} machine
使区域可能被复制到另一台机器上，

274
00:09:43,740 --> 00:09:45,210
0,270 270,480 480,780 810,1350 1350,1470
region might be replicated on

275
00:09:45,210 --> 00:09:46,680
0,270 270,840 1020,1230 1230,1350 1350,1470
another machine,| which is in
|在备机上，

276
00:09:46,680 --> 00:09:48,000
0,90 90,480 480,630 630,990 990,1320
the backup,| so use primary
|所以使用主备进行复制，

277
00:09:48,000 --> 00:09:49,040
0,390 390,900
backup for

278
00:09:49,240 --> 00:09:53,380
0,840 1230,2130 2130,2550 2580,3450 3660,4140
{ - -} replication,| and
|所以这是区域 1 ，区域 2 ，

279
00:09:53,380 --> 00:09:55,060
0,210 210,540 540,840 840,1410
so this region 1,

280
00:09:55,920 --> 00:09:57,300
0,300 300,600 600,1080 1080,1290 1290,1380
{you,know} region 2,| {you,know} the
|（2的）备份可能在（1的）主机的同一台机器上，

281
00:09:57,300 --> 00:09:58,680
0,540 540,780 780,900 900,1110 1110,1380
backup might be on the

282
00:09:58,710 --> 00:10:00,390
0,300 300,630 630,810 810,1110 1140,1680
same machine as the primary|
|

283
00:10:00,390 --> 00:10:02,730
0,450 450,930 990,1410 1440,1830 1830,2340
for backup for region 2,|
作为区域 2 的备份，|

284
00:10:03,090 --> 00:10:04,440
0,330 330,960 960,1080 1080,1260 1260,1350
and here we have the
这里我们有区域 2 的主机。

285
00:10:04,440 --> 00:10:05,940
0,630 720,1020 1020,1260
primary region 2.|
|

286
00:10:06,710 --> 00:10:08,750
0,480 930,1200 1200,1440 1440,1920 1920,2040
{} So this deals you
所以这决定了，

287
00:10:08,750 --> 00:10:10,520
0,150 150,330 330,600 600,1350 1500,1770
know,| so one machine has
|一台机器出现内核 panic ，

288
00:10:10,520 --> 00:10:11,690
0,60 60,390 390,870 870,1020 1020,1170
a kernel panic| or some
|或者某个设备死机，

289
00:10:11,690 --> 00:10:13,700
0,660 660,900 900,1470 1470,1890 1920,2010
device goes that| or you
|或者只是因为其他原因而崩溃，

290
00:10:13,700 --> 00:10:15,590
0,570 600,870 870,1350 1350,1770 1770,1890
know just crashes for some

291
00:10:15,590 --> 00:10:18,110
0,210 210,660 870,1470 1470,1470 2220,2520
other reason,| then {} there's
|然后还有第二台机器，

292
00:10:18,110 --> 00:10:19,490
0,420 420,660 660,1020 1020,1140 1140,1380
a second machine,| that actually
|它有数据的复制，并从那里继续进行。

293
00:10:19,490 --> 00:10:20,810
0,210 210,270 270,930 960,1230 1230,1320
has a copy of the

294
00:10:20,810 --> 00:10:21,950
0,240 240,480 480,630 630,1020 1020,1140
data and just proceed from

295
00:10:21,950 --> 00:10:22,420
0,270
there.|
|

296
00:10:23,120 --> 00:10:24,320
0,150 150,540 690,960 960,1050 1050,1200
Of course, then we need
当然，我们需要某种方法来跟踪

297
00:10:24,320 --> 00:10:26,150
0,390 420,840 840,900 900,1200 1200,1830
some way of keeping track

298
00:10:26,240 --> 00:10:28,790
0,210 210,330 330,840 840,1470 1710,2550
of| the mapping from {}
|区域到主机和备机的映射，

299
00:10:29,330 --> 00:10:32,210
0,690 720,1560 1560,2280 2310,2640 2640,2880
regions to {} {primaries,and -}

300
00:10:32,210 --> 00:10:33,830
0,570 570,780 780,1050 1050,1260 1260,1620
backups,| and so they use
|所以，他们使用配置管理器，

301
00:10:33,830 --> 00:10:36,200
0,300 300,1110 1200,1950
a configuration manager,|
|

302
00:10:36,790 --> 00:10:38,050
0,690 690,900 900,1080 1080,1170 1170,1260
{a,CM} that sits on the
一个 CM 在这里，

303
00:10:38,050 --> 00:10:39,000
0,630
side,|
|

304
00:10:39,370 --> 00:10:40,870
0,270 270,420 420,900 900,1230 1230,1500
and CM itself actually is
CM 本身与我们之前看过的 zookeeper 相结合，

305
00:10:40,870 --> 00:10:42,670
0,570 600,1230 1230,1380 1380,1680 1680,1800
coupled with a system that

306
00:10:42,670 --> 00:10:44,140
0,150 150,360 360,750 750,930 930,1470
we've seen before {zookeeper -},|
|

307
00:10:45,780 --> 00:10:48,210
0,420 420,720 720,1020 1020,1980 1980,2430
and really the zookeeper and
zookeeper 和配置管理器跟踪，

308
00:10:48,210 --> 00:10:49,680
0,120 120,660 660,1140 1140,1290 1290,1470
the configuration management that keep

309
00:10:49,680 --> 00:10:51,820
0,600 780,930 930,1020 1020,1710
track of| the mapping
|从区域编号到主机和备机的映射，

310
00:10:55,080 --> 00:10:57,120
0,240 240,690 690,1020 1020,1620
{you,know} from region number

311
00:10:59,260 --> 00:11:01,390
0,300 300,420 420,1260 1290,1620 1620,2130
to the primary and whatever

312
00:11:01,390 --> 00:11:02,380
0,90 90,720
the backups,|
|

313
00:11:04,530 --> 00:11:05,920
0,1080
{for,every,region}.|
对于每个区域。|

314
00:11:06,390 --> 00:11:09,180
0,690 1770,2490
Okay? {}|
好的?|

315
00:11:09,690 --> 00:11:12,330
0,450 450,840 840,1290 1470,2190 2340,2640
Now there's one a serious
当然，现在这里有一个严重的问题，

316
00:11:12,330 --> 00:11:13,800
0,240 240,330 330,570 570,1110 1110,1470
problem of course here,| I
|我讨论过，

317
00:11:13,800 --> 00:11:14,790
0,120 120,390 390,630 630,810 810,990
I talked about,| like while
|使用主备方案，

318
00:11:14,790 --> 00:11:16,710
0,570 570,810 810,1080 1080,1410 1410,1920
primary with primary backup replication

319
00:11:16,710 --> 00:11:18,060
0,240 240,510 510,630 630,750 750,1350
way,| so we have fault,|
|我们会有故障，|

320
00:11:18,180 --> 00:11:19,830
0,900 930,1080 1080,1290 1290,1530 1530,1650
then {you,know} one machine can
一台机器可能会出故障，

321
00:11:19,830 --> 00:11:20,700
0,360 360,450 450,540 540,780 780,870
fail,| now the machine can
|现在机器可以接手，

322
00:11:20,700 --> 00:11:22,920
0,210 210,630 870,1470 1470,2130 2130,2220
take over,| {} except the
|除了一种棘手的情况，

323
00:11:22,920 --> 00:11:24,900
0,360 390,870 870,1380 1380,1830 1830,1980
{one,sort,of} tricky case,| that this
|到目前为止这个方案不能处理，

324
00:11:24,900 --> 00:11:27,240
0,270 270,480 480,1170 1410,1740 1740,2340
scheme can't handle so far,|
|

325
00:11:27,390 --> 00:11:28,740
0,420 420,630 630,780 780,840 840,1350
is when there's a correlated
当出现相关的故障时，

326
00:11:28,740 --> 00:11:29,700
0,300 300,360 360,750 750,900 900,960
failure,| for example there's a
|例如，数据中心停电，

327
00:11:29,700 --> 00:11:30,810
0,330 330,690 690,780 780,870 870,1110
power failure of the data

328
00:11:30,810 --> 00:11:32,820
0,480 780,1260 1260,1470 1470,1860 1860,2010
center,| and all machines should
|所有的机器都会停机，

329
00:11:32,820 --> 00:11:33,600
0,90 90,270 270,690
now go down,|
|

330
00:11:34,190 --> 00:11:35,690
0,300 300,420 420,630 630,840 840,1500
and to handle that case,|
为了处理这种情况，|

331
00:11:35,840 --> 00:11:39,140
0,690 690,810 810,1470 1500,2250 2610,3300
basically the DRAM {} has
DRAM 位于 UPS 上，

332
00:11:39,140 --> 00:11:40,610
0,180 180,420 420,600 600,990 1020,1470
it sits on a UPS,|
|

333
00:11:40,610 --> 00:11:41,900
0,150 150,360 360,930 930,1140 1140,1290
where every machine sits on
每台机器都有一个不间断的电源，

334
00:11:41,900 --> 00:11:44,600
0,120 120,1020 1020,1380 1380,2040 2460,2700
an uninterruptible power supply,| {so,I'm}
|所以我要画一个大电池放在边上，

335
00:11:44,720 --> 00:11:45,830
0,210 210,270 270,570 570,750 750,1110
going to draw these a

336
00:11:45,830 --> 00:11:47,030
0,270 270,750 750,900 900,1110 1110,1200
big battery that sits on

337
00:11:47,030 --> 00:11:47,840
0,60 60,570
the side,|
|

338
00:11:54,520 --> 00:11:56,620
0,600 810,1080 1080,1170 1170,1680 1680,2100
and {} the battery basically
电池或者 UPS 提供足够的能量，

339
00:11:56,620 --> 00:11:57,670
0,150 150,300 300,810 810,900 900,1050
or {UPS -} you know

340
00:11:57,670 --> 00:11:59,830
0,360 360,720 720,1260 1260,1830 1830,2160
provides enough energy,| that {}
|如果发生全局停电，

341
00:11:59,830 --> 00:12:01,600
0,390 390,600 600,870 900,1410 1410,1770
if there's a global power

342
00:12:01,600 --> 00:12:03,820
0,660 900,1320 1320,1620 1620,2010 2010,2220
failure,| {} the machine keep
|机器会继续运转一小段时间，

343
00:12:03,820 --> 00:12:04,900
0,300 300,420 420,480 480,720 720,1080
running for a little time,|
|

344
00:12:04,900 --> 00:12:06,220
0,120 120,330 330,450 450,720 720,1320
and ended up {a,little} time,|
这一小段时间，|

345
00:12:06,490 --> 00:12:07,780
0,480 480,660 660,930 930,1050 1050,1290
{} the machine can actually
机器可以存储，

346
00:12:07,780 --> 00:12:09,730
0,630 900,1230 1290,1710 1710,1800 1800,1950
store,| the FaRM would like
|FaRM 将数据存储在 SSD 上，

347
00:12:09,730 --> 00:12:11,440
0,120 120,480 480,570 570,840 840,1710
to store the data on

348
00:12:11,950 --> 00:12:13,390
0,270 270,720 720,840 840,930 930,1440
on {SSDs -}| or basically
|或者只是刷新它的内存中的内容，

349
00:12:13,510 --> 00:12:15,820
0,510 570,1470 1590,1710 1710,2220 2220,2310
just flush the contents of

350
00:12:15,820 --> 00:12:18,430
0,150 150,750 780,1200 1200,1470 1680,2610
its memory,| all the regions,
|所有区域，所有事务状态，所有事务日志，

351
00:12:18,430 --> 00:12:20,830
0,210 210,690 720,1230 1230,1800 1800,2400
all the transaction state, all

352
00:12:21,190 --> 00:12:24,400
0,1440 1440,1590 1590,1650 1650,2370 2580,3210
logs for the transactions,| actually
|将它们刷新到 SSD 上，

353
00:12:24,400 --> 00:12:26,020
0,390 390,630 630,1200 1230,1470 1470,1620
flushes {it,to} SSD,| so if
|所以，如果整个数据中心完全停电，

354
00:12:26,020 --> 00:12:27,700
0,180 180,210 210,720 720,1110 1110,1680
there's a complete power failure

355
00:12:27,880 --> 00:12:29,590
0,360 360,600 600,840 840,1110 1110,1710
of the whole data center,|
|

356
00:12:29,680 --> 00:12:30,640
0,300 300,420 420,660 660,870 870,960
{} the data center at
数据中心将在某个时间恢复运行，

357
00:12:30,640 --> 00:12:31,570
0,120 120,390 390,510 510,660 660,930
some point will come back

358
00:12:31,570 --> 00:12:33,010
0,420 510,630 630,750 750,930 930,1440
up,| and they can load
|它们可以从 SSD 中加载机器的内存内容，

359
00:12:33,040 --> 00:12:35,560
0,120 120,270 270,900 1260,1890 1890,2520
you know the memory contents

360
00:12:35,560 --> 00:12:37,000
0,270 270,510 510,1020 1020,1290 1290,1440
of the machines from the

361
00:12:37,000 --> 00:12:39,010
0,690 840,1170 1170,1350 1350,1650 1650,2010
SSD,| and {you,know} start basically
|重新开始运行，

362
00:12:39,010 --> 00:12:39,740
0,300 300,660
running again,|
|

363
00:12:40,560 --> 00:12:41,460
0,180 180,270 270,450 450,540 540,900
and so this is basically
这是唯一使用 SSD 的地方，

364
00:12:41,460 --> 00:12:43,350
0,90 90,420 420,960 960,1650 1740,1890
the only place where the

365
00:12:43,350 --> 00:12:44,700
0,360 360,420 420,540 540,750 750,1350
{SSDs -} are being used,|
|

366
00:12:45,000 --> 00:12:46,590
0,420 420,660 660,780 780,1110 1110,1590
{ -} to deal with
为了处理数据中心内的多台机器的相关故障。

367
00:12:46,590 --> 00:12:49,470
0,450 480,1020 1020,1710 2130,2430 2430,2880
{} correlated failure many machines

368
00:12:49,470 --> 00:12:50,740
0,390 390,480 480,690 690,1020
in the data center.|
|

369
00:12:53,750 --> 00:12:55,500
0,240 240,630 630,1050 1050,1470
Any questions so far?|
到目前为止，有什么问题吗？|

370
00:13:03,180 --> 00:13:04,020
0,210 210,420 420,600 600,750 750,840
Okay, let me say a
好的，让我简单介绍一下这个软件，

371
00:13:04,020 --> 00:13:05,790
0,180 180,330 330,630 630,1170 1170,1770
little bit about {the,software -},|
|

372
00:13:05,880 --> 00:13:07,560
0,390 390,690 690,870 870,1020 1020,1680
{} so in the regions,
所以在这些地区，我们在这里有一个地区，

373
00:13:07,650 --> 00:13:08,610
0,270 270,420 420,570 570,630 630,960
so we have a region

374
00:13:08,610 --> 00:13:09,460
0,540
here,|
|

375
00:13:09,740 --> 00:13:11,180
0,210 210,330 330,480 480,930 930,1440
{} in the region {}
在这个区域中，物体活着。

376
00:13:11,180 --> 00:13:12,680
0,660 660,1050
objects live.|
|

377
00:13:13,390 --> 00:13:14,110
0,150 150,240 240,360 360,570 570,720
So you can just think
所以你可以把一个数组区域想象成一个字节数组，

378
00:13:14,110 --> 00:13:15,730
0,300 300,510 510,1020 1020,1290 1290,1620
about an array {} region

379
00:13:15,730 --> 00:13:17,170
0,390 420,870 870,1050 1050,1350 1350,1440
as, {} an array of

380
00:13:17,170 --> 00:13:18,880
0,480 480,600 600,960 960,1020 1020,1710
bytes,| {you,know} {two,gigabytes - -}|
|你知道两千兆字节|

381
00:13:19,240 --> 00:13:20,680
0,210 210,660 660,840 840,1350 1350,1440
and in an array of
并且在字节对象的阵列中，

382
00:13:20,680 --> 00:13:22,420
0,480 480,1230
byte object,|
|

383
00:13:22,800 --> 00:13:24,630
0,450 450,900 900,1350 1350,1530 1530,1830
and objects have a unique
并且对象具有唯一的标识符OID，

384
00:13:24,630 --> 00:13:26,400
0,720
identifier

385
00:13:29,220 --> 00:13:31,180
0,480 480,1170
{oid -},|
|

386
00:13:31,550 --> 00:13:32,900
0,450 450,630 630,1170 1170,1290 1290,1350
and the oid of an
而一个对象的OID无非是它的区域编号，[三倍]的区域编号

387
00:13:32,900 --> 00:13:34,100
0,300 300,390 390,630 630,990 990,1200
object is nothing else than

388
00:13:34,100 --> 00:13:35,540
0,180 180,600 600,1140
{} {it's,region} number,

389
00:13:36,860 --> 00:13:39,020
0,600 600,750 750,1050 1050,1620 2010,2160
[triple] the region number| and
|然后是你知道的与每个物体相关联的区域内的地址，

390
00:13:39,020 --> 00:13:40,430
0,360 360,480 480,1140 1170,1290 1290,1410
then the address you know

391
00:13:40,430 --> 00:13:41,960
0,420 420,810 810,1230
within that region

392
00:13:48,860 --> 00:13:52,340
0,540 540,1440 1470,1770 1770,2340 2760,3480
{} associated with every object,|
|

393
00:13:52,340 --> 00:13:53,060
0,180 180,240 240,480 480,600 600,720
there's a little bit of
这里有一些特定对象的元数据，

394
00:13:53,060 --> 00:13:55,700
0,720 960,1620 1620,1800 1800,2130 2130,2640
metadata for that particular object,|
|

395
00:13:56,090 --> 00:13:58,460
0,270 270,510 510,1800 1800,1860 1860,2370
and in particular {} for
尤其是对于包含64位数字的对象报头，

396
00:13:58,490 --> 00:14:01,160
0,480 480,750 750,1530 1740,2190 2190,2670
object header contains a 64

397
00:14:01,160 --> 00:14:02,200
0,180 180,690
bit number,|
|

398
00:14:05,870 --> 00:14:08,240
0,390 390,510 510,1410 1470,1980 2040,2370
and the number consists is
该数字基本上由底部63的版本号组成

399
00:14:08,240 --> 00:14:11,100
0,660 1290,1620 1620,1980 1980,2520
basically a version number

400
00:14:13,420 --> 00:14:15,220
0,330 330,540 570,900 900,1650 1650,1800
in the bottom 63| and
|然后是一个锁位，就像我们在上面看到的那样，在高位。

401
00:14:15,220 --> 00:14:16,360
0,120 120,240 240,600 600,990 990,1140
then a lock bit as

402
00:14:16,360 --> 00:14:18,130
0,120 120,600 810,1140 1140,1350 1350,1770
we'll see in the top

403
00:14:18,130 --> 00:14:19,810
0,660 690,1050 1320,1470 1470,1530 1530,1680
a bit, in the high

404
00:14:19,810 --> 00:14:20,640
0,270 270,540
order bit.|
|

405
00:14:21,330 --> 00:14:23,340
0,390 450,1050 1080,1500 1500,1710 1710,2010
So every object has this
所以每个物体都有你知道的64位数字，

406
00:14:23,340 --> 00:14:25,110
0,900 930,1050 1050,1170 1170,1620 1620,1770
{} you know 64 bit

407
00:14:25,110 --> 00:14:26,400
0,390 390,630 630,960 960,1110 1110,1290
number,| {} refer to as
|称为版本号

408
00:14:26,400 --> 00:14:28,350
0,180 300,750 750,1200 1440,1770 1770,1950
a version number| and then
|然后我们将看到它在乐观并发控制中的重要作用。

409
00:14:28,350 --> 00:14:29,340
0,150 150,600 600,660 660,930 930,990
we'll see {} plays an

410
00:14:29,340 --> 00:14:31,350
0,450 450,930 930,1260 1260,1470 1470,2010
important role in the optimistic

411
00:14:31,350 --> 00:14:32,460
0,90 90,420 420,870
{concurrency -} control.|
|

412
00:14:33,720 --> 00:14:38,240
0,630 1170,1920 1920,3000 3360,4200
{} {The,way} applications {}
应用程序使用的方式显示了这个系统，

413
00:14:38,990 --> 00:14:40,850
0,390 390,750 750,930 930,1470 1470,1860
{use,you} show this system,| let
|关于这一点，让我稍微说一下，

414
00:14:40,850 --> 00:14:41,570
0,90 90,270 270,360 360,570 570,720
me say a little bit

415
00:14:41,570 --> 00:14:42,680
0,240 240,480 480,630 630,870 870,1110
about that,| so what's the
|那么，什么是应用程序编程接口。

416
00:14:42,680 --> 00:14:44,520
0,480 480,960 960,1650
application programmer interface.|
|

417
00:14:53,060 --> 00:14:54,560
0,390 390,540 540,1020 1020,1380 1380,1500
So the API is you
所以API是你知道你启动了交易，

418
00:14:54,560 --> 00:14:56,340
0,90 90,300 300,630 630,1350
know you start transaction,|
|

419
00:15:00,080 --> 00:15:01,760
0,540 540,690 690,900 900,1050 1050,1680
and you read some objects,|
你读了一些东西，|

420
00:15:05,490 --> 00:15:07,560
0,180 180,420 420,510 510,990 1410,2070
so {they're,going} to read call|
所以他们会读到Call|

421
00:15:07,560 --> 00:15:09,540
0,120 120,420 420,1080 1080,1290 1290,1980
and {read,call,takes -} {oid -}
而Read调用将OID作为参数，

422
00:15:09,720 --> 00:15:13,530
0,90 90,180 180,870 1860,2610 2910,3810
as an argument,| {} the
|然后，应用程序可以操作您知道更改对象中的字段，

423
00:15:14,290 --> 00:15:16,510
0,810 810,990 1290,1410 1410,2070 2070,2220
application then can manipulate {you,know}

424
00:15:16,510 --> 00:15:18,490
0,330 330,390 390,900 1110,1590 1590,1980
change the fields in the,

425
00:15:18,700 --> 00:15:20,470
0,270 270,360 360,990 990,1530 1530,1770
in the object,| whatever add
|不管加1是什么，

426
00:15:20,470 --> 00:15:21,820
0,210 210,420 420,630
1 to it,|
|

427
00:15:22,270 --> 00:15:23,290
0,300 300,540 540,780 780,870 870,1020
{} and then at some
然后在某个时刻编写对象，

428
00:15:23,290 --> 00:15:24,800
0,330 330,540 540,1050
point {} write

429
00:15:27,300 --> 00:15:29,000
0,330 330,1380
the object,|
|

430
00:15:31,660 --> 00:15:32,800
0,240 240,450 450,570 570,810 810,1140
write there on the object
在物体本身上写上，

431
00:15:32,800 --> 00:15:34,660
0,600 600,1200 1200,1380 1380,1770 1770,1860
itself,| {using,the} write call and
|使用WRITE调用，然后使用txCommit就知道已提交。

432
00:15:34,660 --> 00:15:36,820
0,360 360,450 450,750 1140,1650 1710,2160
then you know committed using

433
00:15:36,820 --> 00:15:38,840
0,840 840,990 990,1380
{txcommit - -}.|
|

434
00:15:41,310 --> 00:15:42,960
0,690 840,1110 1110,1320 1320,1500 1500,1650
And it might also be
也可能是这样的情况，

435
00:15:42,960 --> 00:15:45,840
0,240 240,570 570,930 930,1590 2400,2880
the case that,| {} {the,transaction}
|该事务需要执行中止，

436
00:15:45,840 --> 00:15:46,560
0,90 90,210 210,300 300,420 420,720
{} needs to do {abort

437
00:15:46,560 --> 00:15:48,090
0,570 570,810 810,930 930,1020 1020,1530
-},| because of the optimistic
|由于在该情况下的乐观并发控制，

438
00:15:48,090 --> 00:15:49,620
0,300 300,690 690,870 870,1050 1050,1530
concurrency control in that case,|
|

439
00:15:49,770 --> 00:15:51,210
0,360 360,480 480,990 990,1110 1110,1440
{} the application will typically
该应用程序通常将仅重试该事务，

440
00:15:51,210 --> 00:15:53,200
0,180 180,930 960,1140 1140,1710
just retry the transaction,|
|

441
00:15:53,830 --> 00:15:55,990
0,540 1590,1740 1740,1950 1950,2070 2070,2160
{} and so in the
因此，在交易中，这里显示的是交易，

442
00:15:55,990 --> 00:15:58,510
0,1500 1500,1560 1560,2100 2100,2370 2370,2520
{transaction,,the,way,it} shows transaction here,| there's
|只有一个物体被操纵，

443
00:15:58,510 --> 00:16:00,220
0,180 180,390 390,780 780,1380 1470,1710
only one object manipulated,| yeah
|是的，但它似乎实际上操纵了很多很多物体，

444
00:16:00,220 --> 00:16:01,810
0,150 150,240 240,420 420,900 990,1590
but it seems actually manipulate

445
00:16:01,810 --> 00:16:03,220
0,210 210,420 420,870 870,1110 1110,1410
many, many objects,| those objects
|这些对象可能位于不同的区域

446
00:16:03,220 --> 00:16:04,600
0,180 180,270 270,570 570,840 840,1380
could be on a different

447
00:16:04,630 --> 00:16:07,510
0,810 1170,1860 1860,2160 2160,2400 2400,2880
regions| and {} and so
|所以你知道他们必须有一些计划，我们会看到的，

448
00:16:07,600 --> 00:16:08,230
0,120 120,240 240,330 330,540 540,630
you know they have to

449
00:16:08,230 --> 00:16:09,670
0,120 120,330 330,780 780,930 930,1440
have some plans we'll see,|
|

450
00:16:09,700 --> 00:16:10,900
0,210 210,420 420,690 690,930 930,1200
we're running some {two-phase -}
我们正在运行一些类似两阶段提交的协议来执行原子操作

451
00:16:10,900 --> 00:16:13,330
0,300 300,540 540,1320 1380,1860 1860,2430
commit like protocol {} to

452
00:16:13,330 --> 00:16:16,420
0,240 240,630 630,1320 1320,2070 2220,3090
do atomic operations| across objects
|跨越生活在不同地区的物体。

453
00:16:16,420 --> 00:16:18,380
0,300 300,390 390,870 930,1890
living in different regions.|
|

454
00:16:20,210 --> 00:16:21,530
0,450 450,660 660,720 720,1050 1050,1320
Any sort of questions about
任何有关API和设置的问题。

455
00:16:21,530 --> 00:16:22,320
0,420
the

456
00:16:22,810 --> 00:16:25,040
0,750 750,1350 1650,1950
API {and,setup -}.|
|

457
00:16:29,910 --> 00:16:31,860
0,360 360,660 660,840 840,1590 1710,1950
{} Sorry, the address {oid
抱歉，地址是旧的，

458
00:16:31,860 --> 00:16:34,110
0,540 540,690 690,1050 1080,1530 1530,2250
-},| it is {the,address -}
|这是机器本身的地址吗？

459
00:16:34,170 --> 00:16:37,290
0,630 660,1140 1140,1560 1560,2310 2700,3120
in the machine itself?| Yeah,
|是啊，哪个是那个区域内的偏移量。

460
00:16:37,290 --> 00:16:39,930
0,210 210,300 300,1230 1230,1860 1980,2640
which is {the,or} offset {}

461
00:16:39,930 --> 00:16:41,180
0,330 330,540 540,930
within that region.|
|

462
00:16:46,300 --> 00:16:47,260
0,690
Okay?|
好吧?|

463
00:16:48,380 --> 00:16:49,700
0,180 180,480 480,630 630,990 990,1320
The region could move, correct,|
该区域可以移动，对吗，|

464
00:16:49,790 --> 00:16:51,830
0,120 120,450 480,750 750,1230 1230,2040
you know that the replicated
您知道复制的或配置管理器重新[设计]映射，

465
00:16:51,830 --> 00:16:53,930
0,240 240,330 330,1020 1020,1560 1560,2100
or the configuration manager {re,[design]}

466
00:16:53,930 --> 00:16:56,570
0,270 270,750 1110,1440 1440,2100 2190,2640
the mapping,| {} the actual
|对象可能更改的实际地址，

467
00:16:56,570 --> 00:16:57,680
0,240 240,390 390,450 450,930 930,1110
address where the object might

468
00:16:57,680 --> 00:16:59,210
0,660 900,1110 1110,1260 1260,1440 1440,1530
change,| {} so this is
|这是一个地区号加上一个偏移量，

469
00:16:59,210 --> 00:17:00,170
0,90 90,390 390,660 660,870 870,960
a region number plus an

470
00:17:00,170 --> 00:17:00,960
0,570
offset,|
|

471
00:17:02,130 --> 00:17:03,210
0,90 90,360 360,480 480,780 780,1080
a little bit there here,
在这里有一点，我应该设置偏移量。

472
00:17:03,210 --> 00:17:04,660
0,180 180,390 390,630 630,1020
I should set offset.|
|

473
00:17:09,920 --> 00:17:11,420
0,420 420,450 450,540 540,840 840,1500
Sorry, I have another question
抱歉，我还有一个问题，

474
00:17:12,320 --> 00:17:14,180
0,450 690,900 900,1410 1410,1710 1710,1860
that,| {} what was the
|创建全局地址空间背后的设计选择或设计思想是什么？

475
00:17:14,180 --> 00:17:16,010
0,510 510,900 900,1050 1050,1500 1500,1830
design choice or design thinking

476
00:17:16,010 --> 00:17:17,780
0,420 420,750 750,930 930,1440 1440,1770
behind making a global address

477
00:17:17,780 --> 00:17:18,600
0,630
space?|
|

478
00:17:19,280 --> 00:17:22,280
0,960 990,1260 1260,1950 1950,2580 2580,3000
{} Did you have everything
你把所有东西都放在内存里了吗。

479
00:17:22,280 --> 00:17:23,580
0,240 240,510 510,930
in the DRAM.|
|

480
00:17:26,480 --> 00:17:27,620
0,390 390,600 600,780 780,990 990,1140
Not sure that answers your
我不确定这是否回答了你的问题，但是，

481
00:17:27,620 --> 00:17:29,660
0,420 420,750 900,1710
question, but {},|
|

482
00:17:32,120 --> 00:17:33,380
0,180 180,750 750,840 840,1110 1110,1260
the {whole,goal} of them is
它们的全部目标是在内存数据库上实际运行事务，

483
00:17:33,380 --> 00:17:34,760
0,120 120,330 330,630 630,720 720,1380
to actually run the transactions

484
00:17:34,760 --> 00:17:36,350
0,180 180,300 300,810 810,1440 1470,1590
on an in-memory database,| you
|你知道这套数据库的整个趋势，

485
00:17:36,350 --> 00:17:37,850
0,150 150,600 600,870 870,1200 1200,1500
know this whole trend of

486
00:17:37,850 --> 00:17:39,170
0,540 540,870 870,1020 1020,1110 1110,1320
{set,of,databases},| where all the data
|其中所有数据始终在内存中，称为内存中数据库，

487
00:17:39,170 --> 00:17:40,100
0,90 90,360 360,420 420,870 870,930
is always in memory, is

488
00:17:40,100 --> 00:17:42,590
0,240 240,570 570,1020 1020,1380 1890,2490
called in-memory {databases -},| driven
|驱动因素是DRAM[合理地]便宜

489
00:17:42,590 --> 00:17:44,000
0,150 150,240 240,540 540,900 930,1410
by the fact that DRAM

490
00:17:44,000 --> 00:17:45,920
0,90 90,450 450,930 1230,1770 1770,1920
is [reasonably] cheap| and so
|因此这将允许您基本上运行事务

491
00:17:45,920 --> 00:17:46,970
0,240 240,450 450,780 780,930 930,1050
that would allow you to

492
00:17:46,970 --> 00:17:49,040
0,330 330,540 540,1260 1260,1800 1800,2070
basically run transactions| without actually
|而无需实际转到永久存储

493
00:17:49,040 --> 00:17:50,300
0,240 240,330 330,570 570,870 870,1260
having to go to persistent

494
00:17:50,300 --> 00:17:52,490
0,450 450,930 1110,1380 1380,1860 1860,2190
storage| and they're basically jumping
|他们基本上是跳上了内存中的数据库。

495
00:17:52,490 --> 00:17:54,000
0,150 150,540 570,1380
on that {}

496
00:17:54,410 --> 00:17:55,400
0,690
[train]

497
00:17:55,740 --> 00:17:57,360
0,240 240,690 690,1380
{} in-memory databases.|
|

498
00:17:58,310 --> 00:18:00,020
0,180 180,540 540,660 660,870 870,1710
I see, and that requires
我明白了，这就需要它们共享一个全球地址空间。

499
00:18:00,020 --> 00:18:01,190
0,150 150,240 240,570 570,900 900,1170
like a global address space

500
00:18:01,190 --> 00:18:02,420
0,270 270,420 420,960
they all share.|
|

501
00:18:02,680 --> 00:18:04,000
0,210 210,450 450,660 660,1110 1110,1320
{} The address {space,is} per
地址空间是按机器计算的，对吧，

502
00:18:04,000 --> 00:18:06,820
0,510 540,990 990,1020 1020,2520 2550,2820
machine, {right -},| {} every
|每台机器都有自己的地址空间，从0到任何东西，

503
00:18:06,820 --> 00:18:07,750
0,240 240,390 390,480 480,630 630,930
machine has its own address

504
00:18:07,750 --> 00:18:09,130
0,240 240,360 360,720 720,810 810,1380
space from 0 to whatever,|
|

505
00:18:09,520 --> 00:18:13,900
0,1020 1020,1800 2010,2910 2940,3630 3900,4380
{} and the {} the
这些对象实际上是全球名称的全球编号。

506
00:18:14,050 --> 00:18:15,880
0,480 600,870 870,1290 1290,1380 1380,1830
the the objects are really

507
00:18:15,880 --> 00:18:18,130
0,210 210,900 900,1350 1350,1800 1950,2250
the global {} numbers for

508
00:18:18,130 --> 00:18:19,080
0,300 300,840
global names.|
|

509
00:18:22,070 --> 00:18:23,080
0,240 240,750
Thank you.|
谢谢。|

510
00:18:26,450 --> 00:18:27,260
0,510
Okay,
好的，很好。

511
00:18:27,620 --> 00:18:29,690
0,390 720,900 900,1050 1050,1680 1710,2070
good.| So let's talk so
|那么让我们谈到目前为止，

512
00:18:29,690 --> 00:18:31,790
0,540 660,930 930,1110 1110,1320 1320,2100
far,| {} I think we
|我认为我们基本上已经建立了你知道他们已经排除了稳定的存储设备

513
00:18:31,820 --> 00:18:34,160
0,450 450,1350 1350,1470 1470,1740 1740,2340
basically {sort,of,established} you know they've

514
00:18:34,160 --> 00:18:36,050
0,330 330,570 570,1020 1020,1410 1410,1890
gotten the stable storage devices

515
00:18:36,050 --> 00:18:37,670
0,150 150,210 210,300 300,690 1110,1620
out of the way| and
|因此，读写存储设备不存在瓶颈，

516
00:18:37,670 --> 00:18:40,790
0,630 660,840 840,990 990,1710 2550,3120
so there's no bottleneck for

517
00:18:40,790 --> 00:18:42,290
0,390 390,660 660,960 960,1320 1320,1500
reading writing storage devices,| because
|因为他们基本上没有使用它们，

518
00:18:42,290 --> 00:18:43,700
0,300 300,660 660,870 870,1140 1140,1410
they're basically not using them,|
|

519
00:18:43,970 --> 00:18:45,140
0,420 420,660 660,870 870,990 990,1170
other than this is one
除此之外，这是一个例外的情况，当电源故障。

520
00:18:45,140 --> 00:18:47,510
0,480 480,1050 1200,1530 1530,2010 2040,2370
exceptional case when the power

521
00:18:47,510 --> 00:18:48,080
0,480
fails.|
|

522
00:18:48,690 --> 00:18:50,100
0,180 180,570 690,960 960,1260 1260,1410
And so the next set
因此，他们关注的下一组事情

523
00:18:50,100 --> 00:18:51,420
0,90 90,390 390,510 510,900 900,1320
of things they focus on|
|

524
00:18:51,540 --> 00:18:54,600
0,150 150,450 450,570 570,1260 1260,3060
is trying to reduce {}
正在努力降低CPU使用率

525
00:18:54,630 --> 00:18:56,460
0,750 750,1440 1440,1590 1590,1710 1710,1830
CPU utilization| or try to
|或者尝试非常高效地使用CPU

526
00:18:56,460 --> 00:18:57,240
0,90 90,240 240,600 600,690 690,780
be very efficient with the

527
00:18:57,240 --> 00:18:58,770
0,630 660,840 840,930 930,1140 1140,1530
CPU| and be very efficient
|并且在网络方面非常高效。

528
00:18:58,770 --> 00:19:00,200
0,90 90,180 180,660
at the network.|
|

529
00:19:00,830 --> 00:19:03,350
0,930 1290,1560 1560,2070 2070,2280 2280,2520
And there's two {} key
这里有两个关键的想法，

530
00:19:03,350 --> 00:19:05,330
0,390 390,960 960,1140 1140,1800 1800,1980
ideas here,| that {are,pretty} {}
|这是众所周知的，

531
00:19:05,330 --> 00:19:07,190
0,300 300,630 1050,1290 1290,1620 1620,1860
well known,| so the first
|所以第一个是内核旁路，

532
00:19:07,190 --> 00:19:08,700
0,150 150,240 240,510 510,1320
one is kernel bypass,|
|

533
00:19:20,460 --> 00:19:23,220
0,420 420,960 1230,2010 2160,2580 2580,2760
{} and the story that
这个故事很简单，

534
00:19:23,220 --> 00:19:25,290
0,240 240,450 570,1080 1080,1680 1800,2070
is {} reasonable simple,| so
|因此，我们有作为用户级进程运行的场，

535
00:19:25,290 --> 00:19:26,490
0,150 150,330 330,900 900,1110 1110,1200
we have {FaRM,that} runs as

536
00:19:26,490 --> 00:19:28,160
0,90 90,360 360,630 630,1410
a user level process,|
|

537
00:19:28,610 --> 00:19:29,620
0,720

538
00:19:31,880 --> 00:19:33,860
0,270 270,720 720,930 930,1680 1860,1980
on top of Windows, the
在Windows之上，Windows操作系统，

539
00:19:33,860 --> 00:19:35,330
0,300 300,660 660,1020 1020,1200 1200,1470
Windows operating system,| so here's
|这就是操作系统，

540
00:19:35,330 --> 00:19:37,520
0,150 150,450 450,1020 1710,2100 2100,2190
the operating system,| {let's,move} {a,little,bit
|让我们往边上挪一点，

541
00:19:37,520 --> 00:19:38,600
0,210 210,300 300,390 390,870 900,1080
-} on the side,| so
|所以这就是操作系统

542
00:19:38,600 --> 00:19:40,490
0,240 240,330 330,660 660,1260 1740,1890
here's the operating system| and
|当然，还有操作系统，而且有调度进程的所有功能，

543
00:19:40,490 --> 00:19:41,510
0,60 60,360 360,690 690,750 750,1020
the operating system, of course

544
00:19:41,510 --> 00:19:42,350
0,180 180,330 330,450 450,630 630,840
and there are all the

545
00:19:42,350 --> 00:19:44,570
0,360 360,750 750,1230 1230,2040 2040,2220
features for scheduling processes,| {you,know}
|你知道虚拟内存，标准操作系统，

546
00:19:44,570 --> 00:19:47,780
0,300 300,990 1200,1890 1920,2700 2700,3210
virtual memory, standard operating system,|
|

547
00:19:48,050 --> 00:19:50,420
0,690 690,930 930,1500 1500,1830 1830,2370
and {it,also} {have,drivers} for hardware
它也有硬件设备的驱动程序。

548
00:19:50,420 --> 00:19:53,330
0,0 990,1770 1950,2580 2580,2730 2730,2910
{} devices.| And like one
|并且类似于其中一个硬件设备是网络接口卡，

549
00:19:53,330 --> 00:19:55,100
0,90 90,150 150,450 450,1140 1140,1770
of the hardware devices is

550
00:19:55,310 --> 00:19:56,760
0,150 150,450 450,810 810,1230
a network interface card,|
|

551
00:20:00,560 --> 00:20:01,790
0,420 420,540 540,630 630,1140 1140,1230
and you know typically you
你知道，通常你知道它里面的[OSS]驱动程序，

552
00:20:01,790 --> 00:20:04,220
0,240 240,600 630,1140 1140,1890 1920,2430
know the [OSS] driver inside

553
00:20:04,220 --> 00:20:04,940
0,90 90,330
of it,|
|

554
00:20:05,140 --> 00:20:07,680
0,630 1290,1980
that {
程序、网络接口卡、

555
00:20:07,900 --> 00:20:09,610
0,240 240,990 990,1080 1080,1350 1350,1710
-} programs, the network interface

556
00:20:09,610 --> 00:20:11,650
0,330 330,540 540,900 900,1740 1740,2040
card,| so {read,and,write} registers on
|所以读写网卡上的寄存器基本上就是发送一个包

557
00:20:11,650 --> 00:20:12,820
0,210 210,450 450,780 780,1110 1110,1170
the network interface card to

558
00:20:12,820 --> 00:20:15,130
0,330 330,630 630,1080 1080,1590 1950,2310
basically send a packet| or
|或重新配置网络建议卡等。

559
00:20:15,130 --> 00:20:16,810
0,270 270,750 750,840 840,1140 1140,1680
to reconfigure the network advice

560
00:20:16,900 --> 00:20:18,180
0,330 330,660 660,1020
card, etc, etc.|
|

561
00:20:18,870 --> 00:20:20,640
0,480 750,960 960,1050 1050,1380 1380,1770
{} So the typical way
因此，了解应用程序与网卡交互的典型方式是

562
00:20:20,640 --> 00:20:22,410
0,120 120,270 270,600 600,1170 1170,1770
you know that {you,know} applications

563
00:20:22,410 --> 00:20:25,080
0,750 750,930 930,1440 1470,2010 2250,2670
interact with network card is|
|

564
00:20:25,080 --> 00:20:27,300
0,150 150,960 960,1590 1800,2010 2010,2220
they {make,system} calls to the
它们对内核进行系统调用

565
00:20:27,300 --> 00:20:29,670
0,660 660,1200 1410,1950 1950,2010 2010,2370
kernel| and ask the kernel
|并要求内核基本上发送一个包，

566
00:20:29,670 --> 00:20:30,840
0,90 90,450 450,660 660,690 690,1170
to basically send a packet,|
|

567
00:20:31,750 --> 00:20:34,300
0,540 600,1110 1110,2100 2100,2220 2220,2550
and {that,you,know} involves the operating
而且你知道，这涉及到遵循TCP堆栈的操作系统、网络堆栈、

568
00:20:34,300 --> 00:20:36,130
0,510 510,630 630,900 900,1410 1410,1830
system that follows TCP stack,

569
00:20:36,130 --> 00:20:37,810
0,90 90,420 420,960 1140,1380 1380,1680
the network stack,| {} and
|而且它往往相当昂贵

570
00:20:37,810 --> 00:20:39,010
0,180 180,390 390,450 450,870 900,1200
it tends to be quite

571
00:20:39,010 --> 00:20:41,890
0,570 1110,1890 2100,2400 2400,2700 2700,2880
expensive| and so they want
|所以他们想要避免这个开销，

572
00:20:41,890 --> 00:20:44,230
0,60 60,390 390,690 690,1740 2100,2340
to avoid this {} this

573
00:20:44,230 --> 00:20:45,700
0,510 510,690 690,1110 1110,1410 1410,1470
overhead,| {you,know} going entering the
|你知道，进入运行TCP的内核等，

574
00:20:45,700 --> 00:20:48,190
0,480 480,720 720,1380 1380,1980 2220,2490
kernel running TCP etc,| and
|他们这样做的方式是一种被称为内核旁路的技术，

575
00:20:48,190 --> 00:20:49,180
0,120 120,450 450,630 630,750 750,990
the way they do that

576
00:20:49,180 --> 00:20:49,780
0,60 60,330 330,420 420,510 510,600
is something that is {}

577
00:20:49,780 --> 00:20:51,640
0,330 330,660 660,930 930,1560 1560,1860
technique called kernel bypass,| and
|如果网络是网卡和操作系统之间的某种协作

578
00:20:51,640 --> 00:20:53,050
0,120 120,270 300,930 930,1170 1170,1410
if the network {is,sort,of} {}

579
00:20:53,050 --> 00:20:54,880
0,690 690,990 990,1050 1050,1380 1380,1830
collaboration between the network card

580
00:20:55,240 --> 00:20:57,220
0,600 600,780 780,1140 1140,1530 1860,1980
and the operating system| and
|基本上它所做的就是网络接口拥有的队列，

581
00:20:57,220 --> 00:20:58,630
0,270 270,390 390,480 480,1050 1200,1410
basically what it does {}

582
00:20:58,630 --> 00:20:59,830
0,300 300,480 480,540 540,1050 1050,1200
is that the queues that

583
00:20:59,830 --> 00:21:01,810
0,90 90,420 420,810 810,1320 1740,1980
the network interface has,| sort
|队列的种类，例如发送队列和接收队列，

584
00:21:01,810 --> 00:21:03,550
0,60 60,690 1020,1110 1110,1470 1470,1740
of queues, for example send

585
00:21:03,550 --> 00:21:04,810
0,240 240,330 330,420 420,780 780,1260
queue and {} receive queue,|
|

586
00:21:05,170 --> 00:21:06,850
0,480 480,810 810,870 870,1200 1200,1680
those queues are basically directly
这些队列基本上被直接映射或进入应用程序之外的地址空间，

587
00:21:06,850 --> 00:21:09,520
0,570 1140,1650 1650,1980 2040,2310 2310,2670
{mapped,or} into the address space

588
00:21:09,520 --> 00:21:11,040
0,360 360,750 780,1410
off the application,|
|

589
00:21:11,410 --> 00:21:13,120
0,570 600,720 720,1110 1110,1200 1200,1710
so the application can ask
因此，应用程序可以询问您是否了解操作系统，

590
00:21:13,120 --> 00:21:14,770
0,60 60,420 420,750 750,1110 1110,1650
you know operating system,| please
|请你知道，拿着网卡上的一些队列

591
00:21:14,770 --> 00:21:17,020
0,90 90,300 300,540 540,960 1230,2250
you know take some queues

592
00:21:17,020 --> 00:21:19,000
0,570 600,900 900,1440 1530,1710 1710,1980
{that,the} NIC has| and map
|并将它们映射到应用程序的地址空间中，

593
00:21:19,000 --> 00:21:20,080
0,150 150,360 360,510 510,810 810,1080
them into the address space

594
00:21:20,080 --> 00:21:21,610
0,60 60,180 180,750 1200,1380 1380,1530
of the application,| so you
|因此，您可以只考虑这一点，因为队列基本上可以从用户级应用程序直接访问。

595
00:21:21,610 --> 00:21:22,480
0,90 90,240 240,390 390,630 630,870
can just think about this

596
00:21:22,480 --> 00:21:24,400
0,120 120,930 930,1380 1380,1500 1500,1920
as queue basically is directly

597
00:21:24,400 --> 00:21:25,440
0,840
accessible

598
00:21:25,780 --> 00:21:28,270
0,690 1140,1470 1470,1530 1530,1980 1980,2490
{} from the {user,level} application.|
|

599
00:21:28,270 --> 00:21:29,710
0,180 180,240 240,480 480,750 750,1440
So the user level application,
所以用户级应用程序，你知道，现在基本上可以读写你知道的命令或包到网络接口卡，

600
00:21:29,920 --> 00:21:31,510
0,210 210,330 330,690 690,1230 1230,1590
{you,know} can basically now {read,and,write}

601
00:21:31,510 --> 00:21:33,820
0,180 180,900 960,1380 1380,1740 1740,2310
{you,know} commands or packets into

602
00:21:33,820 --> 00:21:35,680
0,150 150,420 420,840 840,1230 1290,1860
the network interface card,| {without
|而不需要真正涉及到操作系统。

603
00:21:35,680 --> 00:21:37,990
0,240 240,540 540,960 960,1590 1590,2310
-} actually having to involve

604
00:21:37,990 --> 00:21:39,100
0,90 90,420 420,720 720,810 810,1110
the operating system at all.|
|

605
00:21:39,310 --> 00:21:40,270
0,210 210,390 390,720 720,780 780,960
So this cuts the whole
所以这就把整个操作系统都排除在外了

606
00:21:40,270 --> 00:21:41,140
0,300 300,600 600,720 720,780 780,870
operating system out of the

607
00:21:41,140 --> 00:21:43,990
0,600 780,1410 1410,2100 2100,2670 2670,2850
picture| and {} improves {you,know}
|并大大提高了您知道的性能。

608
00:21:43,990 --> 00:21:46,840
0,660 750,1320 2190,2580 2580,2640 2640,2850
performance considerably.| In the case
|在农场的情况下，

609
00:21:46,840 --> 00:21:48,340
0,60 60,720 870,1170 1170,1320 1320,1500
of FaRM,| {} they also
|他们也不想使用中断，

610
00:21:48,340 --> 00:21:49,390
0,120 120,240 240,300 300,480 480,1050
don't want to use interrupts,|
|

611
00:21:49,420 --> 00:21:50,710
0,120 120,480 480,750 750,900 900,1290
so one way of delivering
因此，正确传递信息包的一种方法

612
00:21:50,710 --> 00:21:52,060
0,90 90,690 690,990 990,1080 1080,1350
a {packet,correct}| is the packet
|当分组进入时，网络接口卡向操作系统发送中断，

613
00:21:52,060 --> 00:21:53,140
0,210 210,330 330,420 420,720 720,1080
comes in, the network interface

614
00:21:53,140 --> 00:21:54,640
0,330 330,660 660,750 750,1440 1440,1500
card delivers an interrupt to

615
00:21:54,640 --> 00:21:55,930
0,90 90,450 450,870 870,960 960,1290
the operating system,| the operating
|操作系统然后警告应用该分组已经到达，

616
00:21:55,930 --> 00:21:57,610
0,360 360,510 510,990 990,1080 1080,1680
system then alerts the application

617
00:21:57,610 --> 00:21:58,980
0,300 720,1290
that {}

618
00:21:59,500 --> 00:22:01,300
0,90 90,360 360,480 480,1020 1260,1800
the packet has arrived,| and
|并且非正式地试图避免这一成本

619
00:22:01,300 --> 00:22:03,160
0,1140 1140,1350 1350,1410 1410,1680 1680,1860
informally trying to avoid that

620
00:22:03,160 --> 00:22:04,030
0,390 390,510 510,570 570,750 750,870
cost| and the way they
|避免这一成本的方法基本上是轮询接收队列。

621
00:22:04,030 --> 00:22:05,380
0,330 330,480 480,750 750,840 840,1350
avoid that cost is basically

622
00:22:05,500 --> 00:22:07,160
0,180 180,900
they poll

623
00:22:07,830 --> 00:22:09,080
0,480 480,900
{the,receive} queue.|
|

624
00:22:09,840 --> 00:22:12,150
0,360 390,630 630,1080 1080,1830 1830,2310
So there's basically {an,user,level} thread
所以基本上有一个用户级别的线程位于场应用程序中

625
00:22:12,180 --> 00:22:14,070
0,150 150,300 300,1200 1200,1350 1350,1890
you know {that,sits} in the

626
00:22:14,100 --> 00:22:16,620
0,600 630,1590 1800,1980 1980,2340 2340,2520
FaRM application| and basically does
|基本上，除了读取接收队列之外，什么也不做

627
00:22:16,620 --> 00:22:18,930
0,240 240,660 660,750 900,1620 1770,2310
nothing else than {sort,of,reading} {}

628
00:22:18,930 --> 00:22:20,520
0,540 570,1170 1170,1290 1290,1440 1440,1590
the {receive,queue}| to see if
|以查看是否确实有包可用。

629
00:22:20,520 --> 00:22:22,000
0,300 300,720 720,1260
actually {packet,is} available.|
|

630
00:22:23,520 --> 00:22:25,050
0,210 210,420 420,990 990,1440 1440,1530
And so that requires you
所以这需要你知道你需要一个充满活力的，

631
00:22:25,050 --> 00:22:26,340
0,330 330,450 450,690 690,720 720,1290
know you need a vibrant,|
|

632
00:22:26,340 --> 00:22:27,510
0,120 120,330 330,780 780,870 870,1170
so that avoids the use
这样就避免了中断的使用，

633
00:22:27,510 --> 00:22:30,780
0,270 360,1020 1290,2010 2010,2700 2880,3270
of interrupts,| {} and, {}
|而且，你知道，以基本上拥有一个投票线程为代价，

634
00:22:30,780 --> 00:22:31,560
0,90 90,180 180,330 330,390 390,780
you know at the cost

635
00:22:31,560 --> 00:22:33,270
0,120 120,480 480,750 750,1380 1380,1710
of basically having {a,polling} {}

636
00:22:33,270 --> 00:22:35,100
0,330 330,1500 1500,1620 1620,1770 1770,1830
thread,| {that's -} you know
|你知道，坐在那里除了投票什么也不做

637
00:22:35,100 --> 00:22:36,180
0,240 240,390 390,630 630,870 870,1080
sits there doing nothing else

638
00:22:36,180 --> 00:22:38,580
0,120 120,480 1230,1620 1680,2220 2220,2400
than polling| and FaRM turns
|FILM发现这个线程实际上在运行一些应用程序代码和轮询NIC之间来回切换。

639
00:22:38,580 --> 00:22:40,800
0,240 240,1020 1020,1440 1470,1860 1860,2220
out {this,thread} actually {} switches

640
00:22:40,800 --> 00:22:41,850
0,180 180,270 270,510 510,840 840,1050
back and forth between running

641
00:22:41,850 --> 00:22:43,770
0,120 120,630 630,1110 1110,1500 1710,1920
some application code and {}

642
00:22:43,770 --> 00:22:45,400
0,630 630,990 1050,1500
polling the NIC.|
|

643
00:22:46,640 --> 00:22:47,630
0,210 210,420 420,570 570,690 690,990
So that's sort of kernel
所以这是一种内核绕过，

644
00:22:47,630 --> 00:22:50,330
0,810 1260,1860 1860,2220 2220,2640 2640,2700
bypass,| {} and this is
|这是一个合理的标准，

645
00:22:50,330 --> 00:22:52,250
0,30 30,330 330,870 870,1500 1740,1920
a reasonable standard,| {} some
|有些人可能，你们中的一些人可能熟悉DPDK，

646
00:22:52,250 --> 00:22:53,480
0,240 240,840 870,1050 1050,1140 1140,1230
people may, some of you

647
00:22:53,480 --> 00:22:55,250
0,300 300,720 720,1080 1080,1380 1380,1770
maybe know familiar with {}

648
00:22:55,640 --> 00:22:57,500
0,990 1020,1620
{DPDK -

649
00:22:58,700 --> 00:23:00,200
0,960
-},|
|

650
00:23:01,570 --> 00:23:03,010
0,240 240,360 360,540 540,840 840,1440
which is a data plane
它是一个数据平面开发工具包，

651
00:23:03,010 --> 00:23:05,170
0,270 270,690 690,1020 1410,1830 1830,2160
{} development kit,| {} which
|这是一个开发工具包，基本上可以利用你知道的绕过内核。

652
00:23:05,170 --> 00:23:08,260
0,690 690,1200 1200,1440 1440,2100 2190,3090
a development kit to basically

653
00:23:08,260 --> 00:23:10,120
0,540 540,690 690,960 960,1680
leverage {you,know} kernel bypass.|
|

654
00:23:10,710 --> 00:23:12,360
0,210 210,480 480,780 780,1320
It's a reasonable {standard,thing},
这是一个合理的标准，在许多操作系统上都可以使用。

655
00:23:12,950 --> 00:23:14,930
0,390 390,870 870,1290 1290,1680 1680,1980
{} is available on many

656
00:23:14,930 --> 00:23:16,060
0,330 330,900
operating systems.|
|

657
00:23:16,720 --> 00:23:18,190
0,480 600,780 780,900 900,990 990,1470
{} So then the next
所以下一次你知道他们使用的一种技术，

658
00:23:18,190 --> 00:23:18,880
0,90 90,300 300,450 450,510 510,690
you know sort of piece

659
00:23:18,880 --> 00:23:21,010
0,90 90,660 660,810 810,1320 1320,2130
of technology they use,| {is,a}
|是一点，但也是众所周知的广泛和标准化的许多网卡支持

660
00:23:21,040 --> 00:23:22,900
0,330 330,570 570,1170 1170,1500 1500,1860
little bit but also well

661
00:23:22,900 --> 00:23:24,520
0,210 210,300 300,540 540,660 660,1620
known as wide and standardized

662
00:23:24,520 --> 00:23:27,670
0,210 210,750 750,1230 1680,2340 2370,3150
many {network,cards} {} supported| or
|或者是否支持更高端的网卡

663
00:23:27,670 --> 00:23:29,380
0,90 90,390 390,960 960,1260 1260,1710
were more high-end network card

664
00:23:29,380 --> 00:23:30,880
0,570 870,1050 1050,1230 1230,1440 1440,1500
supported| and that's {something -}
|这就是所谓的RDMA，

665
00:23:30,880 --> 00:23:32,180
0,90 90,450 450,1110
was called RDMA,|
|

666
00:23:36,210 --> 00:23:37,860
0,240 240,510 510,690 690,1380
which stands for remote,
它代表远程、远程直接存储器访问。

667
00:23:40,340 --> 00:23:44,700
0,840 840,1110 1110,1410 1410,1920
remote direct memory access.|
|

668
00:23:51,030 --> 00:23:51,960
0,90 90,330 330,600 600,690 690,930
The basic idea is that,|
基本的想法是，|

669
00:23:51,990 --> 00:23:53,970
0,600 870,990 990,1080 1080,1230 1230,1980
{} you know this requires
您知道，这需要真正理解RDMA的NIC

670
00:23:54,000 --> 00:23:56,640
0,750 750,930 930,1140 1140,1770 1770,2640
NICs that actually understand {}

671
00:23:56,730 --> 00:23:59,670
0,1050 1200,1620 1620,1890 2010,2790 2790,2940
RDMA| and so here {we,have}
|这里有电缆，另一边有网卡，

672
00:23:59,670 --> 00:24:01,320
0,630 660,960 960,1080 1080,1380 1380,1650
cable, here we have NIC

673
00:24:01,320 --> 00:24:02,940
0,90 90,180 180,360 360,900 1470,1620
on the other side,| the
|操作系统可能位于它的顶部，

674
00:24:02,940 --> 00:24:04,290
0,390 390,750 750,900 900,1080 1080,1350
operating system may be sitting

675
00:24:04,290 --> 00:24:05,670
0,60 60,360 360,480 480,720 1260,1380
on top of it,| you
|你知道我们在哪里有农场，

676
00:24:05,670 --> 00:24:06,600
0,150 150,390 390,540 540,720 720,930
know {where -} we have

677
00:24:06,600 --> 00:24:07,600
0,690
FaRM,|
|

678
00:24:12,850 --> 00:24:16,210
0,660 840,1740 2070,3120 3120,3210 3210,3360
and, {} basically you know
基本上，你知道侧边的应用程序，中间的应用程序，

679
00:24:16,210 --> 00:24:18,520
0,660 990,1710 1710,1890 1890,1980 1980,2310
the application on the side,

680
00:24:18,520 --> 00:24:19,810
0,90 90,150 150,420 420,840 1080,1290
on the center side,| you
|基本上，您可以将特定的包放入发送队列，

681
00:24:19,810 --> 00:24:21,370
0,120 120,510 510,900 900,1200 1200,1560
can basically put a particular

682
00:24:21,370 --> 00:24:24,010
0,420 420,1080 1080,1830 1860,2220 2220,2640
packet into the send queue,|
|

683
00:24:24,280 --> 00:24:26,110
0,720 720,1260 1260,1380 1380,1470 1470,1830
{} and you know send
你知道，发送一个RDMA包

684
00:24:26,110 --> 00:24:28,900
0,630 630,1410 1410,2040 2430,2580 2580,2790
an RDMA packet| and so
|所以基本上某个地方是有点，

685
00:24:28,900 --> 00:24:31,150
0,360 360,840 840,1110 1110,1950 2040,2250
basically somewhere is {a,bit} {},|
|

686
00:24:31,150 --> 00:24:32,260
0,120 120,540 540,690 690,750 750,1110
the header of the packet
该分组的报头写着，

687
00:24:32,260 --> 00:24:33,220
0,270 270,450 450,690 690,900 900,960
saying,| like hey I'm an
|就像嘿，我是个RDMA包，

688
00:24:33,220 --> 00:24:34,540
0,300 300,540 540,930
{RDMA -} packet,|
|

689
00:24:34,780 --> 00:24:36,250
0,480 480,750 750,1080 1080,1230 1230,1470
{} and then the NIC
然后NIC会将其发送到NIC，即目标NIC，

690
00:24:36,250 --> 00:24:37,030
0,120 120,330 330,420 420,660 660,780
will send it over to

691
00:24:37,030 --> 00:24:39,130
0,570 600,1020 1050,1260 1260,1770 1770,2100
the NIC, the destination NIC,|
|

692
00:24:39,400 --> 00:24:41,020
0,180 180,690 690,1290 1290,1440 1440,1620
the destination {NIC,sees} that this
目的网卡认为这是一个特殊的RDMA信息包

693
00:24:41,020 --> 00:24:42,580
0,450 480,780 780,1140 1140,1440 1440,1560
is a special packet an

694
00:24:42,580 --> 00:24:44,470
0,510 510,930 1290,1500 1500,1800 1800,1890
RDMA packet| and looks at
|并查看与RDMA分组一起的指令，

695
00:24:44,470 --> 00:24:46,570
0,90 90,720 720,1140 1140,1350 1350,2100
the instruction that goes along

696
00:24:46,570 --> 00:24:48,010
0,150 150,240 240,690 690,1020 1350,1440
with the RDMA packet,| so
|因此该指令可以被读取特定存储位置或写入特定存储位置，

697
00:24:48,010 --> 00:24:50,080
0,540 540,750 750,1020 1230,1890 1920,2070
{the,instruction} might be read a

698
00:24:50,080 --> 00:24:51,460
0,330 330,600 600,1020 1020,1140 1140,1380
particular memory location or write

699
00:24:51,460 --> 00:24:53,530
0,60 60,420 420,660 660,1170 1710,2070
a particular memory location,| so
|举个例子，假设这是一个读操作，

700
00:24:53,530 --> 00:24:54,760
0,510 510,660 660,780 780,1080 1080,1230
here so for example, let's

701
00:24:54,760 --> 00:24:56,110
0,150 150,330 330,420 420,630 630,1350
say it's a read operation,|
|

702
00:24:56,910 --> 00:24:58,920
0,690

703
00:24:59,390 --> 00:25:00,380
0,240 240,300 300,510 510,900 900,990
and the read operation will
并且读取操作将被安全地获取地址，

704
00:25:00,380 --> 00:25:02,300
0,90 90,480 480,810 810,1140 1140,1920
be safely takes an address,|
|

705
00:25:03,670 --> 00:25:05,500
0,750 900,1110 1110,1260 1260,1740 1740,1830
and, {} it allows the
而且，它允许NIC基本上直接从内存、RAM、

706
00:25:05,500 --> 00:25:07,300
0,450 570,780 780,1200 1200,1710 1710,1800
NIC to basically read the

707
00:25:07,300 --> 00:25:09,700
0,570 570,900 900,1230 1230,1470 1470,2400
address straight out of {}

708
00:25:09,790 --> 00:25:11,320
0,540 540,690 690,780 780,1140 1320,1530
memory, out of RAM,| so
|例如，假设你知道我们这里有我们的地区，

709
00:25:11,320 --> 00:25:12,730
0,390 390,570 570,990 1020,1080 1110,1410
{for,example} let's say you know

710
00:25:12,730 --> 00:25:14,140
0,390 390,510 510,690 690,870 870,1410
here we have our region,|
|

711
00:25:15,690 --> 00:25:16,680
0,210 210,330 330,480 480,870 870,990
you know with objects in
你知道，里面有东西，

712
00:25:16,680 --> 00:25:17,300
0,360
it,|
|

713
00:25:18,120 --> 00:25:21,100
0,750 780,1800 1830,2550
and, {} the
而且，发送场应用程序只需说，

714
00:25:21,300 --> 00:25:24,660
0,750 750,1170 1500,2130 2160,2760 2760,3360
sending {} {FaRM -} application

715
00:25:24,660 --> 00:25:25,830
0,120 120,270 270,660 720,1050 1050,1170
can just say,| okay I
|好的，我想读一读你知道这个特别的地址，

716
00:25:25,830 --> 00:25:28,770
0,330 330,810 840,930 930,2130 2280,2940
wanna read you know {}

717
00:25:28,950 --> 00:25:30,330
0,270 270,810 810,1230 1230,1290 1290,1380
this particular address,| you know
|您知道哪些更新对应于这个对象为o的地址，

718
00:25:30,330 --> 00:25:31,950
0,330 360,870 870,1380 1380,1440 1440,1620
which updates corresponds to this

719
00:25:31,950 --> 00:25:33,690
0,300 330,690 690,930 930,1290 1290,1740
{} address {with,this} object o,|
|

720
00:25:34,020 --> 00:25:35,940
0,630 630,1020 1020,1230 1230,1740 1740,1920
and {} we'll send an
我们将向另一端的网卡发送RDMA数据包，

721
00:25:35,940 --> 00:25:37,350
0,510 510,900 900,1110 1110,1200 1200,1410
RDMA packet to the NIC

722
00:25:37,350 --> 00:25:38,440
0,90 90,180 180,390 390,840
on the other side,|
|

723
00:25:39,830 --> 00:25:40,610
0,150 150,450 450,570 570,690 690,780
the NIC is that there
网卡是有一个RDMA数据包

724
00:25:40,610 --> 00:25:43,010
0,180 180,240 240,630 630,1140 1560,2400
{is,an -} RDMA packet| and
|基本上是从内存中读取存储在特定位置的值

725
00:25:43,310 --> 00:25:45,290
0,630 630,1230 1260,1350 1350,1590 1590,1980
basically read you know from

726
00:25:45,290 --> 00:25:47,330
0,630 810,1110 1110,1530 1530,1980 1980,2040
memory, the value stored at

727
00:25:47,330 --> 00:25:49,370
0,150 150,600 600,1320 1560,1740 1740,2040
that particular location| and sends
|然后直接把它们送回源头。

728
00:25:49,370 --> 00:25:50,720
0,150 150,480 480,990 1080,1200 1200,1350
them straight back you know

729
00:25:50,720 --> 00:25:53,460
0,450 450,870 1260,1800 1860,2490
to the {} source.|
|

730
00:25:54,260 --> 00:25:55,550
0,480 480,690 690,750 750,1080 1080,1290
And what is cool about
而这项技术的酷之处在于，

731
00:25:55,550 --> 00:25:58,160
0,180 180,1050 1200,1650 1650,2160 2250,2610
this technology is that, {}|
|

732
00:25:58,160 --> 00:25:59,180
0,180 180,330 330,480 480,660 660,1020
the NIC can do this
NIC可以在根本不中断或干扰服务器的情况下这样做，

733
00:25:59,240 --> 00:26:02,510
0,450 450,960 990,1830 1830,2460 2460,3270
without actually interrupting or interfering

734
00:26:02,510 --> 00:26:04,010
0,300 300,600 600,1050 1050,1170 1170,1500
with the server at all,|
|

735
00:26:04,490 --> 00:26:05,360
0,300 300,450 450,690 690,780 780,870
{} it doesn't have to
它不需要产生中断，

736
00:26:05,360 --> 00:26:06,740
0,390 390,480 480,960 960,1230 1230,1380
generate an interrupt,| doesn't have
|不需要在处理器上运行任何代码，

737
00:26:06,740 --> 00:26:08,810
0,60 60,360 360,660 660,1290 1440,2070
to run any code on

738
00:26:08,810 --> 00:26:11,210
0,720 780,1200 1260,1680 1680,2310 2310,2400
the {} the processors,| that
|运行操作系统、应用程序、

739
00:26:11,210 --> 00:26:12,410
0,300 300,390 390,750 750,1110 1110,1200
run the operating system, the

740
00:26:12,410 --> 00:26:14,900
0,810 1020,1440 1440,1680 1710,2190 2190,2490
application,| instead {you,know} NICs has
|相反，您知道NIC具有运行并执行这些指令的固件

741
00:26:14,900 --> 00:26:16,910
0,450 450,810 900,1140 1140,1530 1530,2010
{firmware -} {} that runs

742
00:26:16,910 --> 00:26:19,220
0,450 450,690 690,1380 1560,1740 1740,2310
executes those instructions| and loads
|并加载您知道的存储在这些内存中的值，请求内存地址，

743
00:26:19,220 --> 00:26:22,070
0,60 60,240 240,1350 1650,2520 2520,2850
you know the value stored

744
00:26:22,070 --> 00:26:24,110
0,210 210,720 720,1170 1170,1500 1500,2040
those memory, request memory addresses,|
|

745
00:26:24,470 --> 00:26:26,270
0,480 480,930 930,1020 1020,1470 1470,1800
straight into a response packet
直接进入响应分组并来回发送响应，

746
00:26:26,270 --> 00:26:27,170
0,90 90,300 300,360 360,720 720,900
and sends {} response back

747
00:26:27,170 --> 00:26:28,520
0,90 90,510 750,1020 1020,1260 1260,1350
and back,| and then of
|当然，在接收端，

748
00:26:28,520 --> 00:26:29,840
0,270 270,390 390,480 480,840 840,1320
course on the receiving side,|
|

749
00:26:30,200 --> 00:26:31,160
0,120 120,240 240,570 570,720 720,960
you know that will show
您知道这将显示在接收队列中

750
00:26:31,160 --> 00:26:32,450
0,150 150,330 330,390 390,780 780,1290
up in the receive queue|
|

751
00:26:32,600 --> 00:26:33,800
0,390 390,570 570,960 960,1080 1080,1200
and so far you know
到目前为止，你知道在某个点上，你知道，保持接收队列

752
00:26:33,800 --> 00:26:34,970
0,90 90,270 270,660 660,750 750,1170
at some point you know

753
00:26:35,000 --> 00:26:36,290
0,420 420,690 690,930 930,1050 1050,1290
{hold,the} receive queue| and see
|并实际看到RDMA的结果。

754
00:26:36,290 --> 00:26:37,940
0,420 420,750 750,1200 1200,1350 1350,1650
actually the result of that

755
00:26:37,970 --> 00:26:39,000
0,780
RDMA.|
|

756
00:26:40,560 --> 00:26:41,480
0,510

757
00:26:41,820 --> 00:26:43,710
0,360 360,600 600,1350 1380,1740 1740,1890
This, this particular version that
这个，我在这里描述的这个特定的版本，

758
00:26:43,710 --> 00:26:45,210
0,60 60,210 210,750 750,1410 1410,1500
I am describing here,| the
|本文将其称为单边RDMA，

759
00:26:45,210 --> 00:26:46,410
0,330 330,690 690,810 810,930 930,1200
paper refers to as {one-sided

760
00:26:46,410 --> 00:26:47,460
0,510
-}

761
00:26:48,510 --> 00:26:50,700
0,210 210,300 300,420 420,960
{RDMA - - -},|
|

762
00:26:53,280 --> 00:26:54,360
0,120 120,240 240,540 540,990 990,1080
and that's typically refers to
而这通常指的是阅读作业的论文。

763
00:26:54,360 --> 00:26:57,630
0,90 90,390 390,840 840,1740 2460,3270
the paper to { -}

764
00:26:57,990 --> 00:26:59,320
0,330 330,1110
read operations.|
|

765
00:27:00,480 --> 00:27:01,460
0,660

766
00:27:02,500 --> 00:27:04,660
0,690 1200,1500 1500,1620 1620,1920 1920,2160
Professor.| Yeah, go ahead.| Sorry
教授。|好的，去吧。|对不起，教授，您能重复一下LIKE NIC队列的轮询是如何在客户端上工作的吗？是的，Like。

767
00:27:04,660 --> 00:27:06,760
0,630 660,1140 1410,1800 1800,1980 1980,2100
professor, can {} can you

768
00:27:06,760 --> 00:27:08,890
0,450 450,1110 1110,1320 1320,1470 1470,2130
repeat how how the polling

769
00:27:08,920 --> 00:27:11,230
0,300 300,810 930,1440 1740,1950 1950,2310
of the {} like NIC

770
00:27:11,230 --> 00:27:13,210
0,600 600,1410 1440,1650 1650,1740 1740,1980
queues works on the on

771
00:27:13,210 --> 00:27:15,460
0,60 60,600 660,1140 1230,1710 1980,2250
the client or yeah like.|
|

772
00:27:15,460 --> 00:27:16,160
0,540

773
00:27:16,380 --> 00:27:18,000
0,420 420,780 780,1170 1170,1350 1350,1620
There's almost nothing to it,|
这几乎没什么大不了的，|

774
00:27:18,060 --> 00:27:22,080
0,780 810,1590 1830,2370 2400,3060 3540,4020
{} the the client {}
客户端只有一个读取特定内存位置的线程

775
00:27:22,080 --> 00:27:23,610
0,390 390,660 660,750 750,1200 1200,1530
just has a thread that

776
00:27:23,610 --> 00:27:25,080
0,150 150,210 210,540 540,750 750,1470
reads a particular memory location|
|

777
00:27:25,500 --> 00:27:27,630
0,900 900,1230 1230,1530 1530,1920 1920,2130
and {} which indicates whether
并且其指示分组是否已到达，

778
00:27:27,630 --> 00:27:28,380
0,60 60,330 330,420 420,720 720,750
a packet has arrived or

779
00:27:28,380 --> 00:27:29,040
0,330
not,|
|

780
00:27:29,300 --> 00:27:31,100
0,570 570,870 870,960 960,1380 1380,1800
and when the NIC receives
当NIC接收到分组时，停留在接收队列中，

781
00:27:31,100 --> 00:27:34,100
0,810 810,1140 1140,1980 2010,2520 2520,3000
packets, {sticks,in} the receive queue,|
|

782
00:27:34,340 --> 00:27:35,240
0,450 450,540 540,600 600,840 840,900
and as a side of
并且作为接收队列中设置的一侧，

783
00:27:35,240 --> 00:27:36,740
0,270 270,540 540,840 840,1170 1170,1500
set setting {in,the} receive queue,|
|

784
00:27:36,740 --> 00:27:38,870
0,90 90,270 270,720 780,1470 1530,2130
you know the flag bit,
你知道旗子的比特，你知道变成1，

785
00:27:38,870 --> 00:27:40,520
0,120 120,750 750,1050 1050,1170 1170,1650
you know turns into 1,|
|

786
00:27:40,760 --> 00:27:42,020
0,390 390,450 450,930 930,1140 1140,1260
and the application knows, oh
应用程序知道，哦，是的，那里有一个包，

787
00:27:42,020 --> 00:27:43,520
0,720 720,960 960,990 990,1260 1260,1500
yeah there's a packet there,|
|

788
00:27:46,060 --> 00:27:47,500
0,270 270,480 480,780 780,870 870,1440
{} is it a specific
你知道这是不是一个特定的帖子，会让所有人都喜欢。

789
00:27:47,500 --> 00:27:49,120
0,330 330,750 780,930 930,1320 1350,1620
thread that you know that

790
00:27:49,120 --> 00:27:51,310
0,330 330,630 660,1080 1260,1680 1680,2190
polls all, like.| Yeah, they're
|是的，他们在他们的系统里，他们有特定的线索，

791
00:27:51,310 --> 00:27:52,630
0,120 120,270 270,600 600,870 870,1320
in their system, they have

792
00:27:52,660 --> 00:27:54,070
0,390 390,690 690,840 840,1290 1290,1410
specific threads,| that actually are
|它们实际上专门用于轮询队列。

793
00:27:54,070 --> 00:27:57,160
0,510 510,600 600,1170 1200,1920 2460,3090
dedicated to polling {} {the,queues}.|
|

794
00:27:58,220 --> 00:27:58,920
0,420
Okay,
好的，谢谢。

795
00:27:59,460 --> 00:28:00,300
0,450
thanks.|
|

796
00:28:01,540 --> 00:28:02,770
0,450 450,570 570,750 750,1080 1080,1230
Sorry, I'm also confused here,|
抱歉，我也搞糊涂了，|

797
00:28:02,770 --> 00:28:04,420
0,210 210,840 840,1380 1380,1500 1500,1650
so {does,the,NIC} cooperate with this
那么，网卡是否与该系统合作呢

798
00:28:04,420 --> 00:28:06,010
0,420 420,600 780,1290 1290,1470 1470,1590
system| or regularly doing a
|或者定期工作，就像在任何普通的NIC中一样。

799
00:28:06,010 --> 00:28:07,660
0,390 510,720 720,1140 1140,1440 1440,1650
job, like as in any

800
00:28:07,660 --> 00:28:08,920
0,570 600,960
regular NIC.|
|

801
00:28:09,500 --> 00:28:12,260
0,840 1140,1890 1890,2190 2190,2310 2310,2760
{} Okay, this is not
好吧，这不是你知道的，不管你的标准网卡，对吧，

802
00:28:12,260 --> 00:28:13,280
0,90 90,210 210,510 510,660 660,1020
you know, whatever your standard

803
00:28:13,280 --> 00:28:15,080
0,360 390,780 1080,1350 1350,1590 1590,1800
NIC, right,| {} this NIC
|这款网卡同时支持内核旁路和远程直接内存访问以及RDMA，

804
00:28:15,080 --> 00:28:17,060
0,120 120,600 600,930 930,1200 1200,1980
that supports both kernel bypass

805
00:28:17,420 --> 00:28:19,610
0,660 660,1080 1080,1440 1440,1740 1740,2190
and {} remote direct {memory,access}

806
00:28:19,700 --> 00:28:20,820
0,180 180,360 360,870
and {RDMA -},|
|

807
00:28:21,230 --> 00:28:22,940
0,420 420,570 570,660 660,1140 1140,1710
{} in the, {} typically
在NIC中，通常是为了支持内核旁路，

808
00:28:22,940 --> 00:28:25,550
0,240 240,450 450,570 570,1140 1140,2610
for NIC to support {}

809
00:28:26,120 --> 00:28:27,200
0,180 180,390 390,780 780,870 870,1080
{} kernel bypass,| it means
|这意味着它必须有多个接收和发送队列

810
00:28:27,200 --> 00:28:28,610
0,120 120,300 300,360 360,540 540,1410
it has to have multiple

811
00:28:28,700 --> 00:28:30,620
0,510 510,720 720,1200 1440,1830 1830,1920
{receive,and} send queues| and it
|并且它只向应用程序提供一对发送或接收队列，

812
00:28:30,620 --> 00:28:31,550
0,180 180,390 390,510 510,810 810,930
just gives a pair of

813
00:28:31,550 --> 00:28:32,660
0,330 330,660 660,930 930,1020 1020,1110
{send,or} receive queues to an

814
00:28:32,660 --> 00:28:33,580
0,630
application,|
|

815
00:28:34,980 --> 00:28:36,120
0,210 210,300 300,780 780,990 990,1140
and it cannot like,| of
它不能像这样，|当然，您不能让计算机上运行的每个进程都有一个发送接收队列，

816
00:28:36,120 --> 00:28:37,950
0,390 390,570 570,810 810,1380 1650,1830
course you can't have a

817
00:28:37,950 --> 00:28:39,360
0,270 270,540 540,750 750,930 930,1410
send receive queue for every

818
00:28:39,360 --> 00:28:40,860
0,420 420,660 660,810 810,900 900,1500
process running on your machine,|
|

819
00:28:41,130 --> 00:28:42,540
0,300 300,690 690,870 870,1020 1020,1410
so typically they're like 16
所以他们通常是16个，或者32个

820
00:28:42,540 --> 00:28:43,470
0,90 90,360 360,660 660,840 840,930
of them, {or,32 -} of

821
00:28:43,470 --> 00:28:45,330
0,420 690,1230 1230,1350 1350,1560 1560,1860
them| and you get some
|你把其中的一些放到特定的操作系统上，

822
00:28:45,330 --> 00:28:46,800
0,90 90,600 600,750 750,1140 1140,1470
of them to particular {OS

823
00:28:46,800 --> 00:28:48,780
0,360 360,810 810,1080 1080,1350 1350,1980
-},| basically allow some applications
|基本上允许一些应用程序拥有基本的发送或接收队列。

824
00:28:48,780 --> 00:28:51,060
0,120 120,510 510,1140 1380,2040 2040,2280
to own basically {} send

825
00:28:51,060 --> 00:28:51,900
0,60 60,360 360,630
or receive queue.|
|

826
00:28:52,880 --> 00:28:54,100
0,570 570,660 660,930
Thanks so much.|
非常感谢。|

827
00:28:55,060 --> 00:28:56,050
0,270 270,480 480,690 690,930 930,990
It also means there's a
这也意味着有一个对DMA的特定支持，并使它一切顺利，

828
00:28:56,050 --> 00:28:58,090
0,510 510,930 930,1170 1170,1710 1710,2040
specific support for DMA and

829
00:28:58,090 --> 00:28:59,170
0,240 240,330 330,570 570,810 810,1080
make it all work out,|
|

830
00:29:00,050 --> 00:29:01,490
0,390 390,510 510,750 960,1140 1140,1440
{} you know, so it
你知道，所以它需要一个相当复杂的网卡，

831
00:29:01,490 --> 00:29:02,390
0,330 330,420 420,600 600,750 750,900
requires {a,NIC -} that is

832
00:29:02,390 --> 00:29:04,190
0,540 540,840 840,1440 1440,1680 1680,1800
a reasonable sophisticated,| although it's
|尽管这是一个合理的标准，但如今。

833
00:29:04,190 --> 00:29:05,600
0,180 180,480 480,840 840,990 990,1410
a reasonable standard, these days.|
|

834
00:29:07,070 --> 00:29:08,510
0,390 420,570 570,840 840,1170 1170,1440
Okay, so that's one side
好的，这是RDMA的一个方面，

835
00:29:08,510 --> 00:29:10,580
0,150 180,810 810,1500 1500,1740 1740,2070
of {} RDMA,| they also
|它们还使用RDMA进行写入

836
00:29:10,580 --> 00:29:13,610
0,420 420,1230 1260,1500 1500,2370 2370,3030
use RDMA {} {to,do} writes|
|

837
00:29:13,880 --> 00:29:15,440
0,660 660,750 750,1020 1020,1410 1410,1560
and to actually implement {RPC
要真正实现RPC，

838
00:29:15,440 --> 00:29:18,050
0,600 840,1530 1710,1980 1980,2400 2400,2610
-},| {} and so, {}
|所以，他们通常在论文中把这种写RDMA称为RDMA，

839
00:29:18,050 --> 00:29:18,840
0,240 240,570
there's, {}

840
00:29:19,150 --> 00:29:21,130
0,630 840,1380 1380,1650 1650,1800 1800,1980
{} they typically call this

841
00:29:21,130 --> 00:29:23,470
0,480 480,1050 1410,1650 1650,1740 1740,2340
write RDMA in the paper,|
|

842
00:29:24,520 --> 00:29:25,930
0,180 180,570 570,660 660,930 930,1410
is basically the same thing
基本上是相同的事情，除了发送方可以放入RDMA分组之外，

843
00:29:27,970 --> 00:29:29,980
0,750 750,810 810,1500 1500,1830 1830,2010
except the sender could put

844
00:29:29,980 --> 00:29:32,500
0,180 180,870 900,1470 1470,2010 2040,2520
in the RDMA packet, {}|
|

845
00:29:32,500 --> 00:29:33,340
0,270 270,450 450,600 600,750 750,840
saying like oh this is
像这样说，哦，这是一个写操作

846
00:29:33,340 --> 00:29:34,930
0,120 120,360 360,1050 1050,1290 1290,1590
a write operation| and write
|并将您知道的以下字节写入特定地址

847
00:29:34,930 --> 00:29:36,190
0,90 90,480 540,720 720,960 960,1260
you know {} the following

848
00:29:36,190 --> 00:29:38,020
0,540 660,870 870,930 930,1260 1260,1830
bytes to a particular address|
|

849
00:29:38,290 --> 00:29:41,620
0,750 870,1710 1830,2310 2310,2670 2670,3330
and the paper uses two
这篇论文使用了两个地方或两个东西，这些地方实际上是写作

850
00:29:41,650 --> 00:29:43,210
0,480 480,570 570,750 750,1080 1080,1560
places or two things where

851
00:29:43,210 --> 00:29:44,530
0,240 240,420 420,660 660,930 930,1320
writes are actually going to|
|

852
00:29:44,770 --> 00:29:47,740
0,630 720,1740 1740,2130 2130,2610 2610,2970
{} objectively written directly with
客观地直接用RDMA写入，

853
00:29:47,740 --> 00:29:49,750
0,840 960,1170 1170,1380 1380,1530 1530,2010
RDMA,| but there's two other
|但还有另外两个数据结构正在使用写RDMA写入。

854
00:29:49,780 --> 00:29:51,010
0,240 240,630 630,780 780,990 990,1230
data structures that are being

855
00:29:51,010 --> 00:29:52,780
0,330 330,690 690,990 1020,1290 1290,1770
written with {} write {RDMAs

856
00:29:52,780 --> 00:29:54,220
0,180 210,630 630,810 810,900 900,1440
-}.| One is a log,|
|一种是原木，|

857
00:29:56,200 --> 00:29:57,310
0,240 240,510 510,660 660,990 990,1110
you'll see the roll the
稍后你会看到圆木的卷曲，

858
00:29:57,310 --> 00:29:58,980
0,270 270,750 780,1290
log later, {}|
|

859
00:30:00,440 --> 00:30:01,340
0,270 270,420 420,540 540,660 660,900
{} and this is a
这是一笔非常不同的交易，

860
00:30:01,340 --> 00:30:02,690
0,210 210,510 510,1080 1080,1230 1230,1350
really different transactions,| so it
|所以它已经提交了记录、记录、记录等，

861
00:30:02,690 --> 00:30:04,910
0,180 180,480 480,990 1110,1590 1590,2220
has committed record logging records

862
00:30:04,940 --> 00:30:07,370
0,720 720,1500 1710,1920 1920,2070 2070,2430
etc etc,| and so if
|因此，如果您所知道的来源曾经将日志记录附加到此特定日志，

863
00:30:07,370 --> 00:30:08,630
0,120 120,660 660,840 840,1080 1080,1260
the source {you,know} once {append

864
00:30:08,630 --> 00:30:10,970
0,330 330,750 750,1200 1440,1710 1710,2340
-} {a,log} record {} to

865
00:30:10,970 --> 00:30:12,410
0,210 210,630 630,1110 1110,1260 1260,1440
this particular log,| I can
|我可以只写RDMA

866
00:30:12,410 --> 00:30:15,320
0,300 300,570 570,960 1200,2070 2280,2910
just do write RDMA| and
|然后，接收NIC只会将日志中的新条目添加到指定位置。

867
00:30:15,500 --> 00:30:17,600
0,810 810,1050 1050,1380 1380,1680 1680,2100
{} and then the receiving

868
00:30:17,600 --> 00:30:19,190
0,450 450,720 900,1350 1350,1440 1440,1590
{NIC,will} just add you know

869
00:30:19,190 --> 00:30:21,200
0,300 570,1350 1350,1800 1800,1920 1920,2010
the new entry in the

870
00:30:21,200 --> 00:30:23,870
0,420 420,930 930,1620 1800,2280 2280,2670
log to the specified location.|
|

871
00:30:24,970 --> 00:30:28,330
0,690 1710,2400 2730,2970 2970,3090 3090,3360
Okay?| And so that means
好吧?|所以这意味着就像发送者

872
00:30:28,330 --> 00:30:29,860
0,180 180,240 240,1020 1020,1290 1290,1530
like the sender| and there's
|每个发送方和接收方对都有一个队列和一个日志，

873
00:30:29,860 --> 00:30:31,150
0,180 180,270 270,420 420,1110 1140,1290
one of these queues and

874
00:30:31,150 --> 00:30:32,710
0,150 150,240 240,420 420,870 870,1560
one of these logs per

875
00:30:32,740 --> 00:30:34,750
0,480 480,780 780,1170 1170,1710 1800,2010
{} sender receiver pair,| so
|因此发送者实际上可以管理和知道日志开头和结尾是什么。

876
00:30:34,750 --> 00:30:36,100
0,180 180,330 330,840 840,960 960,1350
that sender actually can manage

877
00:30:36,100 --> 00:30:37,120
0,120 120,390 390,660 660,720 720,1020
and know what the beginning

878
00:30:37,120 --> 00:30:37,690
0,150 150,210 210,360 360,480 480,570
and the end of the

879
00:30:37,690 --> 00:30:38,480
0,300 300,600
log are.|
|

880
00:30:40,020 --> 00:30:42,150
0,750 1080,1170 1200,1770 1770,1830 1830,2130
Then, in addition to that,|
然后，除此之外，|

881
00:30:42,150 --> 00:30:43,950
0,180 180,570 570,780 780,1170 1170,1800
there's something there message queues,|
消息队列中有一些东西，|

882
00:30:46,650 --> 00:30:49,590
0,570 570,1110 1110,1770 1770,2160 2190,2940
and also one per pair,|
也是每双鞋一条，|

883
00:30:51,340 --> 00:30:52,750
0,210 210,420 420,510 510,900 900,1410
and these are basically used
这些基本用于实现RPC，

884
00:30:52,750 --> 00:30:54,970
0,90 90,810 870,1170 1170,1380 1380,2220
to implement {} {RPCs -},|
|

885
00:30:55,270 --> 00:30:56,320
0,330 330,630 630,720 720,870 870,1050
{} so if you want
因此，如果您想要进行远程过程调用，

886
00:30:56,320 --> 00:30:57,940
0,150 150,390 390,690 690,1080 1080,1620
to do remote procedure call,|
|

887
00:30:58,090 --> 00:31:01,510
0,540 540,960 1140,1830 1860,2280 2310,3420
{} the client, the sender
客户端、发送方制作并写入RDMA RDMA包，

888
00:31:01,810 --> 00:31:03,850
0,570 570,720 720,960 960,1590 1590,2040
makes and write RDMA RDMA

889
00:31:03,850 --> 00:31:05,530
0,480 780,1350 1350,1470 1470,1560 1560,1680
packet,| writes you know the
|将数据、消息基本上写入远程消息队列，

890
00:31:05,530 --> 00:31:07,240
0,210 210,420 420,750 750,1260 1260,1710
data, the message basically into

891
00:31:07,240 --> 00:31:10,000
0,330 360,990 1020,1440 1440,1950 2340,2760
the remote message queue,| there's
|在目的地一侧有一根线，

892
00:31:10,000 --> 00:31:13,060
0,390 510,1020 1020,1590 1590,2520 2520,3060
a thread sitting on the

893
00:31:13,150 --> 00:31:14,530
0,600 600,840 840,960 960,1050 1050,1380
destination side,| that is basically
|这基本上是轮询消息队列或轮询所有消息队列，

894
00:31:14,530 --> 00:31:16,840
0,630 630,810 810,1140 1140,1470 1470,2310
polling that message queue or

895
00:31:16,870 --> 00:31:18,430
0,360 360,690 690,780 780,1050 1050,1560
polling all the message queues,|
|

896
00:31:18,760 --> 00:31:19,870
0,240 240,330 330,540 540,600 600,1110
if it sees a message,
如果它看到一条消息，您知道它正在处理该消息

897
00:31:19,870 --> 00:31:20,710
0,120 120,270 270,360 360,750 750,840
you know it processes the

898
00:31:20,710 --> 00:31:22,030
0,570 720,870 870,960 960,1110 1110,1320
message| and can then send
|然后可以使用写RDMA发回响应，

899
00:31:22,030 --> 00:31:23,120
0,60 60,540 540,1020
a response back,

900
00:31:23,780 --> 00:31:26,700
0,720 780,1440 1440,2070
using {a,write} RDMA,|
|

901
00:31:32,530 --> 00:31:33,490
0,330 330,480 480,600 600,840 840,960
{} and this turns out
事实证明，使用RDMA实现远程过程调用更便宜，

902
00:31:33,490 --> 00:31:36,640
0,60 60,630 870,1710 1800,2610 2610,3150
to be cheaper implementing {remote,procedure}

903
00:31:36,640 --> 00:31:38,530
0,360 360,630 630,1410 1560,1710 1710,1890
call using RDMA,| it turns
|事实证明，它比基本上使用某种标准RPC包更便宜，

904
00:31:38,530 --> 00:31:39,310
0,90 90,150 150,240 240,630 630,780
out to be cheaper than

905
00:31:39,310 --> 00:31:42,220
0,690 720,1710 1830,2220 2220,2430 2430,2910
basically {} using {sort,of} standard

906
00:31:42,220 --> 00:31:44,680
0,450 450,1110 1230,1800 1800,1920 1920,2460
RPC packet,| that you know
|您知道，因为数据包使用了常规NIC，但没有RDMA

907
00:31:44,680 --> 00:31:47,710
0,540 570,1170 1170,2040 2310,2790 2790,3030
{} since {} packet using

908
00:31:47,710 --> 00:31:49,240
0,60 60,360 360,750 750,1140 1140,1530
a regular NIC, but without

909
00:31:49,240 --> 00:31:50,800
0,90 90,690 930,1320 1320,1500 1500,1560
{RDMA -}| and has a
|在另一边有一根线，你知道那是什么反应。

910
00:31:50,800 --> 00:31:51,850
0,240 240,300 300,390 390,600 600,1050
thread on the other side,

911
00:31:51,850 --> 00:31:53,220
0,60 60,210 210,630 630,1290
you know that response.|
|

912
00:31:54,190 --> 00:31:55,160
0,630
Okay?|
好吧?|

913
00:31:56,450 --> 00:31:58,040
0,180 180,330 330,540 540,1260 1260,1590
Are there any validation step
这里是否有任何验证步骤，

914
00:31:58,040 --> 00:31:59,060
0,210 210,270 270,510 510,690 690,1020
here,| to make sure that
|为了确保您只写入内存区域，这是明确允许RDMA的，

915
00:31:59,210 --> 00:32:01,010
0,390 390,630 630,870 870,1350 1350,1800
you're you're only writing to

916
00:32:01,010 --> 00:32:02,120
0,90 90,360 360,450 450,750 750,1110
a region of memory, that's

917
00:32:02,210 --> 00:32:04,490
0,630 630,1290 1290,1440 1440,2040 2040,2280
expressly allowed for RDMA,| {you,know}
|你知道，不要把应用程序写到应用程序内存或其他什么地方。

918
00:32:04,490 --> 00:32:06,920
0,540 660,1020 1050,1800 1800,1920 1920,2430
don't write application to application

919
00:32:06,920 --> 00:32:08,390
0,270 270,330 330,780 900,1290 1290,1470
memory or something.| Yeah, so
|是的，所以有各种各样的，

920
00:32:08,390 --> 00:32:09,380
0,150 150,510 510,630 630,840 840,990
there are all kinds of,|
|

921
00:32:09,380 --> 00:32:10,490
0,120 120,660 660,870 870,960 960,1110
you know this is sort
你知道这是一种高层次的想法，

922
00:32:10,490 --> 00:32:12,080
0,60 60,150 150,600 600,1110 1140,1590
of the high-level idea, {}|
|

923
00:32:12,140 --> 00:32:14,420
0,210 210,390 390,840 840,1470 1950,2280
talk into details here,| so
在这里讨论详细信息，|所以，当你设置这些RDMA之一时，

924
00:32:14,420 --> 00:32:17,060
0,720 870,1680 1710,2010 2010,2250 2250,2640
when, {} you sort of

925
00:32:17,060 --> 00:32:17,810
0,240 240,330 330,480 480,570 570,750
set up one of these

926
00:32:17,810 --> 00:32:21,500
0,90 90,780 780,2190 3270,3450 3450,3690
{RDMA -},| {} in order
|为了进行这种单边RDMA或写入RDMA，

927
00:32:21,500 --> 00:32:22,670
0,60 60,240 240,450 450,660 660,1170
to do this {} one-sided

928
00:32:22,670 --> 00:32:24,230
0,450 450,570 570,900 900,1320 1320,1560
RDMA or write {RDMAs -},|
|

929
00:32:24,320 --> 00:32:25,130
0,300 300,420 420,630 630,720 720,810
{} you first have to
您首先必须进行连接设置，

930
00:32:25,130 --> 00:32:27,440
0,270 270,600 600,1050 1260,1500 1500,2310
do connection setup,| there's a
|在发送者和接收者之间有一个协商步骤，

931
00:32:27,470 --> 00:32:29,900
0,900 900,1290 1290,1560 1560,2010 2040,2430
negotiation step between the sender

932
00:32:29,900 --> 00:32:31,280
0,120 120,180 180,840 1020,1200 1200,1380
and the receiver,| {} to
|将其设置为几乎就像是一个TCP通道，

933
00:32:31,280 --> 00:32:33,020
0,240 240,450 450,990 1020,1560 1560,1740
set up {} basically like

934
00:32:33,020 --> 00:32:33,980
0,180 180,390 390,480 480,540 540,960
it's almost like a TCP

935
00:32:33,980 --> 00:32:35,720
0,330 330,660 660,750 750,900 900,1740
channel,| except you know RDMA
|除了您知道RDMA不使用TCP之外，

936
00:32:35,750 --> 00:32:37,760
0,540 540,1200 1320,1710 1710,1800 1800,2010
{doesn't,use} TCP,| but it sets
|但是它建立了面向连接的可靠、有序的通道，

937
00:32:37,760 --> 00:32:40,700
0,90 90,150 150,570 570,1320 1680,2940
up a connection oriented reliable,

938
00:32:41,060 --> 00:32:43,700
0,870 870,1530 1560,2100 2100,2580
{} ordered {} channel,|
|

939
00:32:46,080 --> 00:32:47,880
0,480 480,630 630,1080 1080,1500 1500,1800
and so the security checks
因此，安全检查和访问控制检查是在设置时进行的。

940
00:32:47,880 --> 00:32:48,870
0,150 150,420 420,720 720,930 930,990
and access control checks are

941
00:32:48,870 --> 00:32:49,740
0,360 360,450 450,540 540,780 780,870
happening at the point of

942
00:32:49,740 --> 00:32:50,520
0,60 60,480
the setup.|
|

943
00:32:53,190 --> 00:32:54,030
0,360 360,510 510,630 630,750 750,840
So would you have to
那么，您需要在每一台机器之间执行此操作吗？

944
00:32:54,030 --> 00:32:55,440
0,120 120,330 330,840 840,1140 1140,1410
do that between every pair

945
00:32:55,440 --> 00:32:57,040
0,90 90,840 840,1350
of machines?| Yes.|
|是。|

946
00:32:58,600 --> 00:32:59,770
0,270 270,420 420,660 660,960 960,1170
So that would become really
所以这将变得非常昂贵的添加，

947
00:32:59,770 --> 00:33:01,540
0,540 540,660 660,1020 1050,1470 1500,1770
costly to add,| {} like
|就像一台机器对一个大集群一样，对吗？

948
00:33:01,540 --> 00:33:03,160
0,210 210,660 660,840 840,1260 1260,1620
one machine to a large

949
00:33:03,160 --> 00:33:05,350
0,450 450,840 1170,1890 1890,2070 2070,2190
cluster, right?| You have n
|您有n个方形RDMA连接，

950
00:33:05,350 --> 00:33:07,300
0,510 510,1080 1080,1740
square RDMA connections,|
|

951
00:33:08,300 --> 00:33:09,140
0,150 150,540 540,600 600,720 720,840
and otherwise we would have
否则我们将有n个正方形的TCP连接，

952
00:33:09,140 --> 00:33:10,780
0,120 120,450 450,780 780,1410
n square TCP connections,|
|

953
00:33:11,650 --> 00:33:13,960
0,1080 1200,1680 1680,1830 1830,1950 1950,2310
not clear as a major
不清楚是不是有很大的区别。

954
00:33:13,960 --> 00:33:14,920
0,330 330,630
difference there.|
|

955
00:33:18,040 --> 00:33:19,720
0,270 270,870 870,1080 1080,1200 1200,1680
And so just to clarify,
为了澄清一下，日志中的信息，

956
00:33:19,720 --> 00:33:21,220
0,480 600,1050 1050,1320 1320,1410 1410,1500
so the message in the

957
00:33:21,220 --> 00:33:23,170
0,480 480,900 900,1170 1170,1530 1530,1950
logs,| basically they both sit
|基本上，他们都坐在记忆中，

958
00:33:23,170 --> 00:33:24,610
0,300 300,690 720,1170 1170,1260 1260,1440
also in memory,| they just
|它们只是坐在不同的地方，而不是物体所在的位置。

959
00:33:24,610 --> 00:33:26,260
0,210 210,330 330,600 600,1260 1290,1650
sit in different places than

960
00:33:26,260 --> 00:33:28,120
0,210 210,300 300,840 1170,1470 1470,1860
where the {objects,sit}.| Yeah, exactly,|
|是的，就是这样，|

961
00:33:28,180 --> 00:33:29,080
0,240 240,420 420,540 540,810 810,900
so if you do, so
所以如果你这样做了，那么这就是右边的这个，

962
00:33:29,080 --> 00:33:29,980
0,180 180,240 240,480 480,660 660,900
this is sort of on

963
00:33:29,980 --> 00:33:31,330
0,210 210,300 300,390 390,780 1170,1350
here on the right,| is
|是场进程的存储器布局的图片，

964
00:33:31,360 --> 00:33:32,350
0,180 180,510 510,570 570,660 660,990
a picture of the memory

965
00:33:32,350 --> 00:33:35,530
0,510 510,630 630,1200 1290,2190 2220,3180
layout of the FaRM process,|
|

966
00:33:35,530 --> 00:33:37,240
0,180 180,300 300,570 570,1320 1350,1710
you know there's a region
你知道有一个地区表或一个对象表

967
00:33:37,240 --> 00:33:39,100
0,600 780,900 900,960 960,1290 1290,1860
table or an object table|
|

968
00:33:39,100 --> 00:33:40,780
0,210 600,810 810,900 900,1440 1440,1680
and there are regions in
并且在服务器的存储器中有区域，

969
00:33:40,780 --> 00:33:42,850
0,120 120,600 600,750 750,1440 1470,2070
the memory of the server,|
|

970
00:33:43,090 --> 00:33:45,340
0,360 360,870 870,1230 1230,1740 1770,2250
{} these regions have objects
这些区域中有对象

971
00:33:45,340 --> 00:33:46,720
0,120 120,480 750,900 900,1020 1020,1380
in them| and in addition
|除了这些地区之外，

972
00:33:46,720 --> 00:33:48,160
0,180 180,420 420,870 870,1140 1140,1440
to the regions,| there are
|有消息队列和日志。

973
00:33:48,160 --> 00:33:49,690
0,360 360,1020 1050,1230 1230,1410 1410,1530
message queues and there are

974
00:33:49,690 --> 00:33:50,360
0,600
logs.|
|

975
00:33:51,900 --> 00:33:53,670
0,180 180,540 660,1020 1020,1560 1560,1770
I see, and also for
我明白了，而且为了让网卡支持从内存直接访问，

976
00:33:53,670 --> 00:33:54,900
0,90 90,360 360,510 510,1020 1020,1230
the NIC to support the

977
00:33:54,900 --> 00:33:56,640
0,360 360,720 720,1110 1140,1560 1560,1740
direct access from memory,| so
|因此，由于我们在这里没有涉及任何软件，

978
00:33:56,640 --> 00:33:57,570
0,240 240,390 390,480 480,660 660,930
since here we don't have

979
00:33:57,570 --> 00:33:59,610
0,480 510,1260 1290,1710 1710,1950 1950,2040
any software involved,| since the
|由于NIC甚至无需通知应用程序或OS即可直接访问存储器，

980
00:33:59,610 --> 00:34:01,440
0,180 180,330 330,690 690,1110 1110,1830
NIC can directly access the

981
00:34:02,160 --> 00:34:05,100
0,570 570,990 990,1860 1890,2700 2700,2940
memory without even notifying the

982
00:34:05,100 --> 00:34:07,530
0,660 660,930 930,1230 1260,1800 2010,2430
application or the OS,| shouldn't
|不应该在硬件层面上进行一些协调，

983
00:34:07,530 --> 00:34:08,430
0,90 90,240 240,720 720,840 840,900
be some coordination on the

984
00:34:08,430 --> 00:34:10,560
0,630 660,1260 1260,1650 1650,1980 1980,2130
hardware level,| {} or at
|或者至少从处理器到该特征的一些支持。

985
00:34:10,560 --> 00:34:12,630
0,300 300,450 450,1200 1290,1620 1620,2070
least some support {} also

986
00:34:12,630 --> 00:34:15,000
0,240 240,390 390,1200 1440,1800 1800,2370
from the processor {} to

987
00:34:15,000 --> 00:34:16,960
0,780 900,1230 1230,1830
this {} feature.|
|

988
00:34:17,190 --> 00:34:18,870
0,330 330,510 510,780 780,1410 1410,1680
Yeah, so there's, {} it's
是的，基本上，你知道网卡可以自动读写读写高速缓存线

989
00:34:18,900 --> 00:34:19,830
0,480 480,570 570,660 660,810 810,930
basically you know the NIC

990
00:34:19,830 --> 00:34:22,350
0,240 240,420 420,510 510,930 2310,2520
can read or write {}

991
00:34:22,380 --> 00:34:24,900
0,870 870,1410 1440,1740 1740,2190
{read,or,write} {} cache lines

992
00:34:25,360 --> 00:34:27,550
0,330 330,750 750,1020 1320,1740 1740,2190
{} {atomically -}| and so,
|因此，为了支持这一点，

993
00:34:27,550 --> 00:34:28,930
0,390 420,600 600,960 960,1260 1260,1380
{} to support this,| you
|你知道有一个你知道的连接到记忆系统的接口，

994
00:34:28,930 --> 00:34:30,850
0,120 120,420 420,1140 1140,1860 1860,1920
know there's an interface you

995
00:34:30,850 --> 00:34:32,440
0,150 150,780 780,870 870,1170 1170,1590
know to the memory system,|
|

996
00:34:32,830 --> 00:34:34,540
0,750 750,1110 1110,1320 1320,1560 1560,1710
between NIC and this has
在NIC和之间，必须在您的操作系统之间和连接设置完成时仔细设置。

997
00:34:34,540 --> 00:34:35,500
0,60 60,150 150,570 570,750 750,960
to be carefully {setup -}

998
00:34:35,500 --> 00:34:37,930
0,570 570,810 810,1650 1650,2190 2190,2430
between your OS and when

999
00:34:37,930 --> 00:34:38,920
0,60 60,390 390,660 660,750 750,990
the connection setup is done.|
|

1000
00:34:40,710 --> 00:34:42,220
0,180 180,330 330,540 540,810
I see, thank you.|
我明白了，谢谢你。|

1001
00:34:43,780 --> 00:34:45,820
0,480 480,870 870,1080 1080,1800 1860,2040
{} Sorry, the write to
对不起，写入右侧的RDMA是红色的，在那里发生了什么？

1002
00:34:45,820 --> 00:34:47,920
0,780 780,1320 1350,1500 1500,1770 1770,2100
RDMA on the right side

1003
00:34:47,920 --> 00:34:50,410
0,120 120,330 330,930 1830,2100 2100,2490
that is red, what happens

1004
00:34:50,410 --> 00:34:51,180
0,480
there?|
|

1005
00:34:52,120 --> 00:34:54,940
0,480 480,1140 1170,1350 1350,1950 2280,2820
So, {} the sender, the
所以，发送者，左边的机器可以写RDMA，

1006
00:34:54,940 --> 00:34:57,010
0,270 270,870 1320,1500 1500,1830 1830,2070
left machine can do write

1007
00:34:57,010 --> 00:34:59,140
0,750 1080,1320 1320,1530 1530,1860 1860,2130
RDMA,| {} which basically sends
|它基本上将写入RDMA包发送到右侧，您知道目的地，

1008
00:34:59,140 --> 00:35:01,360
0,450 450,840 840,1290 1590,1830 1830,2220
{an,write} RDMA packets to the

1009
00:35:01,480 --> 00:35:03,100
0,450 450,840 840,930 930,1080 1080,1620
right side, you know the

1010
00:35:03,100 --> 00:35:05,230
0,780 1080,1380 1380,1440 1440,1920 1950,2130
destination,| and the NIC you
|您所知道的NIC会看到这是一个写RDMA包

1011
00:35:05,230 --> 00:35:06,340
0,150 150,420 420,810 810,930 930,1110
know sees this is a

1012
00:35:06,340 --> 00:35:08,800
0,330 330,1020 1020,1620 2040,2250 2250,2460
write RDMA packet| and will
|并将编写通过网络传入的内容

1013
00:35:08,800 --> 00:35:09,880
0,180 180,240 240,720 720,840 840,1080
write the content that came

1014
00:35:09,880 --> 00:35:11,260
0,120 120,390 390,450 450,1020 1230,1380
in over the network| to
|写入RDMA命令中指定的地址。

1015
00:35:11,260 --> 00:35:13,030
0,120 120,540 540,720 720,1440 1440,1770
the address that's specified in

1016
00:35:13,030 --> 00:35:15,420
0,510 540,870 870,1560 1680,2160
the write RDMA command.|
|

1017
00:35:18,950 --> 00:35:20,240
0,300 300,450 450,600 600,750 750,1290
But that would be just.|
但这将是公正的。|

1018
00:35:20,750 --> 00:35:22,370
0,240 240,360 360,570 570,1350 1350,1620
And so there's a remote
所以有一台远程机器，可以只在目标机器上写入地址的内存位置集，

1019
00:35:22,370 --> 00:35:23,330
0,330 330,420 420,570 570,870 870,960
machine, can just write the

1020
00:35:23,330 --> 00:35:25,820
0,270 270,900 1470,1770 1770,1890 1890,2490
memory location set of addresses

1021
00:35:25,820 --> 00:35:27,680
0,360 360,480 480,1020 1020,1410 1410,1860
on the destination machine,| without
|在没有你所知道的服务器参与的情况下，

1022
00:35:27,680 --> 00:35:29,300
0,270 270,540 540,630 630,1260 1500,1620
actually having the server you

1023
00:35:29,300 --> 00:35:30,960
0,390 510,870 870,1470
know being involved,|
|

1024
00:35:31,670 --> 00:35:32,690
0,270 270,390 390,600 600,930 930,1020
other than doing setup, of
当然，除了做设置之外。

1025
00:35:32,690 --> 00:35:33,360
0,420
course.|
|

1026
00:35:33,860 --> 00:35:35,220
0,540 540,1080
Thank you.|
谢谢。|

1027
00:35:35,960 --> 00:35:36,740
0,420

1028
00:35:37,030 --> 00:35:38,770
0,570 570,780 780,1080 1080,1440 1440,1740
So, quick question,| so that
所以，我有个小问题，|使得队列、队列、网卡只用于读RDMA，

1029
00:35:38,770 --> 00:35:39,740
0,660
the,

1030
00:35:40,140 --> 00:35:42,780
0,720 810,990 990,1680 1770,2370 2400,2640
{} the queue, the queue

1031
00:35:42,780 --> 00:35:44,100
0,150 150,450 450,900 930,1140 1140,1320
and the NIC is only

1032
00:35:44,100 --> 00:35:46,500
0,300 300,510 510,900 1110,1800 2190,2400
used for read RDMA,| like
|与写入类似，直接写入接收器的内存。

1033
00:35:46,500 --> 00:35:48,300
0,150 150,690 870,1230 1230,1680 1680,1800
the write, write directly to

1034
00:35:48,300 --> 00:35:50,980
0,600 870,1080 1080,1500 1710,2400
memory at the receiver.|
|

1035
00:35:51,500 --> 00:35:52,730
0,330 330,480 480,570 570,930 930,1230
Yeah, on the on the,|
是的，在路上，|

1036
00:35:52,790 --> 00:35:53,990
0,210 210,660 660,870 870,990 990,1200
{} you okay, so they're
你还好吗，所以他们正在写远程直接存储器存取，

1037
00:35:53,990 --> 00:35:55,040
0,120 120,210 210,480 480,930 930,1050
on the write RDMA,| as
|正如你可能在报纸上注意到的，

1038
00:35:55,040 --> 00:35:56,150
0,330 330,660 660,960 960,1020 1020,1110
you maybe noticed in the

1039
00:35:56,150 --> 00:35:57,470
0,480 600,870 870,1050 1050,1200 1200,1320
paper,| {} there can be
|可能会有人回来承认。

1040
00:35:57,470 --> 00:35:59,060
0,60 60,660 660,930 930,1320
an acknowledgment coming back.|
|

1041
00:35:59,400 --> 00:36:01,440
0,630 630,1170 1320,1530 1530,1860 1860,2040
{} So, {} if the
因此，如果发送方发送确实写入了RDMA，

1042
00:36:01,440 --> 00:36:03,600
0,600 720,1350 1350,1530 1530,1830 1830,2160
sender sends does write {RDMA

1043
00:36:03,600 --> 00:36:05,190
0,510 600,810 810,960 960,1140 1140,1590
-},| {} it can wait
|它可以等待来自接收网卡的确认，

1044
00:36:05,220 --> 00:36:07,320
0,510 510,660 660,1380 1380,1680 1680,2100
from an acknowledgement, from the

1045
00:36:07,380 --> 00:36:09,660
0,660 660,1110 1260,1590 1590,1890 1890,2280
receiving NIC,| that actually indeed
|这实际上执行了写RDMA。

1046
00:36:09,660 --> 00:36:11,580
0,690 690,810 810,1050 1050,1680
performed the write RDMA.|
|

1047
00:36:11,960 --> 00:36:12,980
0,570

1048
00:36:13,550 --> 00:36:15,380
0,840 1050,1380 1380,1530
Okay, {thanks -}.|
好的，谢谢。|

1049
00:36:16,630 --> 00:36:17,620
0,240 240,300 300,720 720,930 930,990
And that will play an
这将发挥重要作用。

1050
00:36:17,620 --> 00:36:18,600
0,360 360,750
important role.|
|

1051
00:36:21,300 --> 00:36:23,460
0,390 390,630 630,1020 1020,1560 1920,2160
Any more questions about this
关于这一部分还有什么问题吗？

1052
00:36:23,460 --> 00:36:24,200
0,450
part?|
|

1053
00:36:25,430 --> 00:36:26,570
0,270 270,420 420,480 480,840 870,1140
This sort of a cool
这是一种很酷的技术，

1054
00:36:26,570 --> 00:36:27,800
0,180 180,240 240,1020 1020,1080 1080,1230
piece of technology,| you know
|你知道，在过去的十年里，这种情况将会相当普遍地出现

1055
00:36:27,800 --> 00:36:29,960
0,450 450,690 690,960 960,1470 1470,2160
that's gonna come into existence

1056
00:36:29,990 --> 00:36:32,510
0,810 840,1740 2070,2310 2310,2430 2430,2520
pretty widespread {} in the

1057
00:36:32,510 --> 00:36:34,820
0,270 270,810 1140,1770 1770,2220 2220,2310
last decade| and basically they
|基本上，他们想要利用这一点，

1058
00:36:34,820 --> 00:36:36,000
0,210 210,270 270,690 690,870
want to leverage it,|
|

1059
00:36:37,620 --> 00:36:38,550
0,390 390,450 450,750 750,840 840,930
because it allows them to
因为这让他们变得非常，

1060
00:36:38,550 --> 00:36:41,010
0,150 150,450 450,1170 1440,2040 2100,2460
get very,| {you,know} again something
|你也知道，实际进行这些单边RDMA之一的延迟约为5微秒，

1061
00:36:41,010 --> 00:36:42,540
0,360 390,990 990,1140 1140,1380 1380,1530
the latency to actually do

1062
00:36:42,540 --> 00:36:44,250
0,210 210,300 300,720 750,1200 1200,1710
one of these {one-sided -}

1063
00:36:44,250 --> 00:36:46,110
0,660 660,930 1050,1350 1350,1590 1590,1860
{RDMAs -} about 5 {microseconds

1064
00:36:46,110 --> 00:36:47,180
0,600
-},|
|

1065
00:36:49,000 --> 00:36:51,700
0,450 690,1410 1440,1740 1740,2280
so very low latency,|
所以延迟非常低，|

1066
00:36:54,010 --> 00:36:55,840
0,690 690,870 870,1050 1050,1380 1380,1830
much much much faster correct,
更快的正确性，例如读取或写入磁盘

1067
00:36:55,840 --> 00:36:56,980
0,420 420,660 660,750 750,1020 1020,1140
{for,example} reading or writing a

1068
00:36:56,980 --> 00:37:00,460
0,510 810,1800 1800,2370 2370,3090 3120,3480
disk| {} and {} not
|比写你自己的记忆慢不了多少，

1069
00:37:00,460 --> 00:37:02,050
0,300 300,810 840,1200 1200,1350 1350,1590
much slower, slower than writing

1070
00:37:02,050 --> 00:37:04,570
0,210 210,630 840,1290 1290,1860 1890,2520
your own { -} memory,|
|

1071
00:37:04,660 --> 00:37:05,830
0,330 330,540 540,630 630,900 900,1170
{} but you know pretty
但你很快就会知道，

1072
00:37:05,830 --> 00:37:06,460
0,480
fast,|
|

1073
00:37:08,020 --> 00:37:08,980
0,300 300,390 390,660 660,780 780,960
because it allows you to
因为它允许你做的是一微秒，每秒一百万个包，

1074
00:37:08,980 --> 00:37:11,530
0,480 810,1140 1140,1350 1350,1920 1920,2550
do {} is one microsecond,

1075
00:37:11,530 --> 00:37:12,700
0,90 90,450 450,720 720,840 840,1170
a million packets per second,|
|

1076
00:37:14,150 --> 00:37:15,340
0,330 330,900
pretty impressive.|
令人印象深刻。|

1077
00:37:17,450 --> 00:37:18,280
0,540
Okay?|
好吧?|

1078
00:37:19,320 --> 00:37:20,460
0,120 120,300 300,450 450,660 660,1140
So this so far basically
到目前为止，这基本上是标准技术对的，

1079
00:37:20,460 --> 00:37:23,310
0,390 390,990 1020,1320 1350,2760 2790,2850
standard technology right,| {} you
|你知道[尖端]，但你知道标准。

1080
00:37:23,310 --> 00:37:24,060
0,420
know

1081
00:37:24,520 --> 00:37:25,990
0,420 420,720 720,1050 1050,1320 1320,1470
{} [cutting] edge, but you

1082
00:37:25,990 --> 00:37:27,380
0,660 660,1140
know standard.|
|

1083
00:37:27,990 --> 00:37:29,080
0,510
So,
所以，这篇论文解决的真正挑战是，

1084
00:37:29,540 --> 00:37:30,480
0,600
the

1085
00:37:30,980 --> 00:37:32,630
0,480 480,930 930,1050 1050,1320 1320,1650
real challenge that the paper

1086
00:37:32,630 --> 00:37:34,920
0,750 990,1950
addresses {},|
|

1087
00:37:36,800 --> 00:37:38,630
0,150 150,420 420,810 810,960 960,1830
it's actually how to use
这实际上是如何使用RDMA的问题，

1088
00:37:39,530 --> 00:37:42,770
0,990 1500,1980 1980,2280 2280,2910 2910,3240
RDMA,| both write RDMA and
|写入RDMA和单边RDMA都实际进行事务处理，

1089
00:37:42,770 --> 00:37:44,810
0,210 210,780 780,1230 1230,1620 1680,2040
{one-sided -} {RDMA -} actually

1090
00:37:44,810 --> 00:37:46,430
0,420 420,990 990,1170 1170,1260 1260,1620
doing transactions,| so the challenge
|因此，本文所面临的挑战是使用RDMA解决事务。

1091
00:37:46,430 --> 00:37:49,310
0,240 240,480 480,1050 1110,2250 2310,2880
this paper addresses transactions using

1092
00:37:49,340 --> 00:37:53,360
0,660
RDMA.|
|

1093
00:37:57,490 --> 00:37:58,780
0,570

1094
00:37:59,210 --> 00:38:01,430
0,600 690,900 900,1410 1890,2010 2010,2220
And you know {} sort
你知道，你可以看到这是一个挑战，

1095
00:38:01,430 --> 00:38:02,510
0,210 270,720 720,870 870,1020 1020,1080
of see that this is

1096
00:38:02,510 --> 00:38:03,860
0,120 120,630 630,1110 1140,1260 1260,1350
{} challenge,| we have to
|我们必须稍微考虑一下到目前为止我们所看到的所有协议，

1097
00:38:03,860 --> 00:38:04,700
0,180 180,240 240,420 420,570 570,840
think a little bit about

1098
00:38:04,700 --> 00:38:05,930
0,210 210,480 510,960 960,1080 1080,1230
all the protocols that we've

1099
00:38:05,930 --> 00:38:07,460
0,210 210,390 390,840 1200,1440 1440,1530
seen so far,| so it
|所以它可以说是事务、两阶段提交等协议，

1100
00:38:07,460 --> 00:38:10,280
0,120 120,240 240,930 930,1530
sort of protocols for

1101
00:38:11,650 --> 00:38:13,640
0,330 330,570 570,1470
{you,know} for transactions,

1102
00:38:14,690 --> 00:38:18,560
0,270 270,510 510,780 780,1350 2130,3870
{} {two-phase -} commit etc,|
|

1103
00:38:18,710 --> 00:38:20,330
0,330 330,540 540,900 900,1230 1230,1620
all those programs and protocols
所有这些程序和协议都需要服务器端的参与，

1104
00:38:20,330 --> 00:38:23,060
0,150 150,930 1050,1710 1710,2010 2010,2730
have required server side participation,|
|

1105
00:38:33,290 --> 00:38:35,330
0,210 210,330 330,1110 1110,1680 1680,2040
and for example, {} what
例如，我的意思是，您知道客户端发送对事务协调器的请求，

1106
00:38:35,330 --> 00:38:37,070
0,90 90,360 360,480 480,870 1110,1740
I mean with that is

1107
00:38:37,070 --> 00:38:39,980
0,1380 1620,2100 2100,2280 2280,2340 2340,2910
{you,know,the} client sends a request

1108
00:38:39,980 --> 00:38:41,480
0,150 150,330 330,780 780,1320 1320,1500
for the transaction coordinator,| sends
|向参与者之一发送请求，

1109
00:38:41,480 --> 00:38:42,260
0,60 60,420 420,510 510,690 690,780
a request to one of

1110
00:38:42,260 --> 00:38:44,120
0,90 90,870 1230,1500 1500,1560 1560,1860
the participants,| {} for example
|例如需要锁定特定对象，

1111
00:38:44,120 --> 00:38:45,830
0,90 90,690 690,750 750,1200 1230,1710
to require a lock on

1112
00:38:45,830 --> 00:38:48,410
0,0 0,540 540,1290 1290,2010 2190,2580
{} a particular object,| and
|你知道，只要在服务器或接收器上等待

1113
00:38:48,410 --> 00:38:49,790
0,240 240,480 480,1020 1020,1140 1140,1380
{you,know} just wait you know

1114
00:38:49,790 --> 00:38:52,310
0,300 300,1620 1620,2100 2100,2430 2430,2520
on the server or the

1115
00:38:52,310 --> 00:38:53,930
0,480 480,810 810,930 930,1230 1230,1620
receiver| until the lock actually
|直到锁真正变得可用

1116
00:38:53,930 --> 00:38:56,180
0,180 180,450 450,960 1470,2160 2160,2250
it becomes available| or you
|或者您知道运行，您知道服务器运行一些验证步骤

1117
00:38:56,180 --> 00:38:57,440
0,270 270,780 780,870 870,1110 1110,1260
know runs you know the

1118
00:38:57,440 --> 00:39:00,200
0,300 300,540 540,1320 1350,2250 2280,2760
server {runs,some} validation {} step|
|

1119
00:39:00,200 --> 00:39:01,300
0,60 60,180 180,300 300,810
you know to see
你知道，要看交易是否能被提交，

1120
00:39:01,910 --> 00:39:04,520
0,480 480,840 840,1590 1740,2100 2130,2610
{} if the the transaction

1121
00:39:04,520 --> 00:39:05,720
0,210 210,360 360,720 720,810 810,1200
can be committed or not,|
|

1122
00:39:06,230 --> 00:39:07,550
0,390 390,600 600,960 1020,1200 1200,1320
{} and so in all
所以基本上在所有这些案例中，

1123
00:39:07,550 --> 00:39:09,500
0,180 180,630 630,1260 1380,1800 1800,1950
those cases basically,| {} if
|如果您有一些服务器端参与，

1124
00:39:09,500 --> 00:39:11,090
0,120 120,390 390,510 510,1020 1020,1590
you have some {server,side} participation,|
|

1125
00:39:11,090 --> 00:39:12,020
0,120 120,450 450,630 630,780 780,930
that means that you have
这意味着您必须在服务器上运行代码，

1126
00:39:12,020 --> 00:39:13,100
0,120 120,420 420,900 900,1020 1020,1080
to run code on the

1127
00:39:13,100 --> 00:39:14,120
0,450
server,|
|

1128
00:39:22,550 --> 00:39:24,110
0,600 780,960 960,1230 1230,1500 1500,1560
and you know that is
你知道这与RDMA给你带来的东西是背道而驰的，对吧，

1129
00:39:24,110 --> 00:39:26,090
0,150 150,330 720,1410 1410,1590 1590,1980
sort of counter to what

1130
00:39:26,090 --> 00:39:27,410
0,480 480,690 690,870 870,1140 1140,1320
RDMA gives you, right,| {RDMA
|RDMA实际上并没有为您提供在服务器上运行代码的能力，

1131
00:39:27,410 --> 00:39:29,060
0,390 390,960 960,1320 1320,1650 1650,1650
-} actually {} doesn't {}

1132
00:39:29,690 --> 00:39:31,280
0,630 630,750 750,960 960,1440 1440,1590
provide you the ability to

1133
00:39:31,280 --> 00:39:33,110
0,240 240,720 960,1200 1200,1260 1260,1830
run code on the server,|
|

1134
00:39:33,170 --> 00:39:35,540
0,120 120,270 270,1620 1620,1740 1740,2370
and so the the designers
因此，这篇论文的设计者或作者必须想出一种协议，

1135
00:39:35,540 --> 00:39:36,230
0,120 120,210 210,330 330,630 630,690
{or -} the authors of

1136
00:39:36,230 --> 00:39:37,070
0,150 150,510 510,630 630,720 720,840
this paper have to come

1137
00:39:37,070 --> 00:39:38,540
0,150 150,330 330,510 510,630 630,1470
up with sort of protocols,|
|

1138
00:39:38,750 --> 00:39:40,640
0,600 630,1020 1020,1140 1140,1230 1230,1890
that allow you to implement
它们通常允许您实现两阶段提交和事务

1139
00:39:40,640 --> 00:39:42,440
0,120 120,360 360,900 1080,1500 1500,1800
{two-phase -} commit {} and

1140
00:39:42,440 --> 00:39:44,900
0,450 450,570 570,1260 1380,2190 2190,2460
transactions in general| to {}
|而不实际或试图减少您的服务器端参与。

1141
00:39:44,900 --> 00:39:46,670
0,630 630,1110 1110,1380 1380,1650 1650,1770
without actually or trying to

1142
00:39:46,670 --> 00:39:48,530
0,570 570,720 720,990 990,1200 1200,1860
reduce your server side participation.|
|

1143
00:39:49,480 --> 00:39:50,350
0,210 210,360 360,480 480,660 660,870
So that they can lead
以便它们可以使用RDMA进行某些操作，

1144
00:39:50,350 --> 00:39:51,190
0,120 120,420 420,660 660,750 750,840
to some part of the

1145
00:39:51,190 --> 00:39:54,250
0,600 600,900 900,1650 1830,2520 2520,3060
operations using RDMA,| {} and
|您知道，有些人使用远程过程调用，就像通常的传统做法一样，

1146
00:39:54,250 --> 00:39:55,420
0,120 120,210 210,600 600,930 930,1170
you know some using remote

1147
00:39:55,420 --> 00:39:56,890
0,360 360,780 810,1170 1170,1290 1290,1470
procedure calls as usual sort

1148
00:39:56,890 --> 00:39:58,090
0,240 240,720 720,870 870,1020 1020,1200
of traditional would do,| in
|在过去的几周里我们看到了一种传统的设计。

1149
00:39:58,090 --> 00:39:59,980
0,90 90,750 990,1560 1560,1710 1710,1890
a traditional designs that we've

1150
00:39:59,980 --> 00:40:01,150
0,180 180,270 270,360 360,810 900,1170
seen in the last couple

1151
00:40:01,150 --> 00:40:01,800
0,510
weeks.|
|

1152
00:40:02,430 --> 00:40:03,450
0,240 240,480 510,840 840,960 960,1020
And so that's sort of
这就是这篇论文的核心挑战，

1153
00:40:03,450 --> 00:40:05,730
0,90 90,510 510,1200 1290,2100 2100,2280
the central challenge {} in

1154
00:40:05,730 --> 00:40:07,980
0,420 420,600 600,750 750,1170 1830,2250
{} in this paper, {}|
|

1155
00:40:07,980 --> 00:40:10,080
0,180 180,810 840,1200 1200,1680 1680,2100
and this pushes them {}
这促使他们朝着这个方向去解决这个问题，

1156
00:40:10,080 --> 00:40:12,810
0,570 600,810 810,1470 2010,2160 2160,2730
in this direction to solve

1157
00:40:12,810 --> 00:40:15,330
0,180 180,690 1020,1350 1380,1980 1980,2520
that problem,| the high-level strategy
|他们使用的高级策略是，

1158
00:40:15,330 --> 00:40:17,880
0,150 150,270 270,840 990,1980
that they use is,|
|

1159
00:40:21,220 --> 00:40:22,720
0,180 180,390 390,480 480,930 930,1500
the {high,level -} strategy {uses,is}
高级策略使用的是乐观并发控制。

1160
00:40:22,720 --> 00:40:27,460
0,1290 2610,2730 2730,3000 3000,3570
optimistic {concurrency -} control.|
|

1161
00:40:30,750 --> 00:40:33,180
0,630 780,1140 1290,1530 1530,1800 1800,2430
And and {you,know} really did
你知道，他们真正的闪光点是在读取操作上，

1162
00:40:33,330 --> 00:40:35,490
0,810 810,1500 1530,1620 1620,2040 2040,2160
really where the shine for

1163
00:40:35,490 --> 00:40:37,050
0,240 240,330 330,570 570,780 780,1560
them is on read operations,|
|

1164
00:40:37,320 --> 00:40:39,510
0,1080 1080,1440 1440,1560 1560,1890 1890,2190
because basically the basic plan
因为基本计划是读取对象，这些对象是事务的一部分，不需要锁，

1165
00:40:39,510 --> 00:40:41,580
0,270 450,720 720,930 930,1530
is {} read objects,

1166
00:40:42,340 --> 00:40:43,180
0,360 360,450 450,660 660,720 720,840
that are part of the

1167
00:40:43,180 --> 00:40:46,600
0,810 1260,1560 1560,2070 2190,2820 2820,3420
transaction {without -} requiring locks,|
|

1168
00:40:51,240 --> 00:40:52,830
0,60 60,570 570,1050 1050,1500 1500,1590
for example require locks you
例如，需要锁，这意味着可能会中断服务器，

1169
00:40:52,830 --> 00:40:54,210
0,60 60,210 210,360 360,840 840,1380
know that would mean {}

1170
00:40:54,210 --> 00:40:56,580
0,600 600,870 870,960 960,1680 1830,2370
interrupting maybe to server {},|
|

1171
00:40:56,580 --> 00:40:58,080
0,120 120,420 420,660 660,930 930,1500
the server has {to,do,some} work|
服务器必须做一些工作|

1172
00:40:58,080 --> 00:40:59,940
0,120 120,720 720,1200 1200,1800 1800,1860
and then maybe block the
然后可能会阻止客户端实际锁定可用，然后返回对象

1173
00:40:59,940 --> 00:41:01,410
0,600 600,810 810,1050 1050,1380 1380,1470
client to actually lock is

1174
00:41:01,410 --> 00:41:03,510
0,630 630,780 780,1170 1320,2010 2010,2100
available and then return the

1175
00:41:03,510 --> 00:41:04,860
0,390 390,630 960,1050 1050,1140 1140,1350
object| and you know that
|您知道这与RDMA并不是很合适，也不是很好

1176
00:41:04,860 --> 00:41:07,140
0,120 120,390 390,960 1260,1860 1860,2280
is not really suitable or

1177
00:41:07,170 --> 00:41:09,780
0,300 300,570 570,1140 1140,1650 1860,2610
{nice -} nicely with {}

1178
00:41:09,780 --> 00:41:11,550
0,150 150,360 360,750 750,1230 1230,1770
or lines up nicely with

1179
00:41:11,820 --> 00:41:13,440
0,210 210,1050 1140,1350 1350,1470 1470,1620
{} RDMA| and so they're
|因此，他们将采取一个乐观的方案，

1180
00:41:13,440 --> 00:41:14,580
0,150 150,240 240,450 450,750 750,1140
going to go to an

1181
00:41:14,580 --> 00:41:16,950
0,570 570,1140 1230,1740 1740,2070 2070,2370
optimistic scheme,| where basically reading
|其中读取对象基本上不需要任何锁，

1182
00:41:16,950 --> 00:41:17,820
0,360 360,450 450,660 660,780 780,870
objects is not going to

1183
00:41:17,820 --> 00:41:19,110
0,450 450,600 600,870 870,960 960,1290
require any locks at all,|
|

1184
00:41:19,140 --> 00:41:20,070
0,180 180,360 360,540 540,870 870,930
you just can fetch an
您只需获取一个对象并开始使用它

1185
00:41:20,070 --> 00:41:22,500
0,600 900,1530 1530,1950 1950,2190 2190,2430
object {} and start using

1186
00:41:22,500 --> 00:41:24,300
0,300 300,630 870,1050 1050,1200 1200,1800
it| and as we'll see,
|正如我们将看到的，你知道你当然需要一些机制来发现你正在阅读的是旧版本还是新版本，

1187
00:41:24,390 --> 00:41:25,380
0,510 510,600 600,690 690,930 930,990
{} {you,know} of course you

1188
00:41:25,380 --> 00:41:26,790
0,180 180,270 270,480 480,900 900,1410
need to have some mechanism

1189
00:41:26,790 --> 00:41:28,080
0,120 120,600 600,870 870,1020 1020,1290
to discover whether you're reading

1190
00:41:28,080 --> 00:41:28,920
0,120 120,330 330,600 600,690 690,840
an old version and new

1191
00:41:28,920 --> 00:41:30,090
0,480 660,780 780,930 930,990 990,1170
version,| and this is where
|这就是版本号将发挥重要作用的地方。

1192
00:41:30,090 --> 00:41:31,050
0,60 60,360 360,780 780,840 840,960
the version numbers are going

1193
00:41:31,050 --> 00:41:32,130
0,90 90,300 300,420 420,780 780,1080
to play an important role.|
|

1194
00:41:39,130 --> 00:41:40,000
0,240 240,420 420,600 600,720 720,870
{} So when you read
所以当你在农场里读到一个物体时，

1195
00:41:40,000 --> 00:41:41,950
0,90 90,750 780,1110 1110,1350 1350,1950
an object {} in FaRM,|
|

1196
00:41:41,950 --> 00:41:42,970
0,270 270,390 390,480 480,780 780,1020
you get the object back|
你把物品拿回来|

1197
00:41:42,970 --> 00:41:43,870
0,90 90,180 180,300 300,570 570,900
and you can also the
您还可以将版本号返回到该对象，

1198
00:41:43,870 --> 00:41:44,740
0,120 120,420 420,570 570,810 810,870
{} version number back to

1199
00:41:44,740 --> 00:41:47,470
0,150 150,630 1140,1320 1320,1860 1890,2730
that object,| and then {}
|基本的想法是，在提交的时候，

1200
00:41:47,500 --> 00:41:49,330
0,810 810,1350 1350,1470 1470,1710 1710,1830
basic idea is that at

1201
00:41:49,330 --> 00:41:50,500
0,60 60,360 360,420 420,960
the point of commit,|
|

1202
00:41:50,810 --> 00:41:53,090
0,1020 1410,1950 1950,2010 2010,2190 2190,2280
we're going to do a
我们要做一个验证步骤，

1203
00:41:53,090 --> 00:41:54,480
0,510 510,1320
validation step,|
|

1204
00:41:56,300 --> 00:41:59,780
0,150 150,690 720,1110 1110,2640 2850,3480
to check that the objects
为了检查对象是否在事务开始时被[写入]，

1205
00:41:59,780 --> 00:42:01,310
0,360 360,660 690,1380 1380,1470 1470,1530
being {} [write] at the

1206
00:42:01,310 --> 00:42:02,930
0,270 270,360 360,450 450,1200 1290,1620
beginning of the transaction,| or
|或者实际上已经被修改了。

1207
00:42:02,930 --> 00:42:04,760
0,210 210,420 420,570 570,1230 1650,1830
actually having been modified.| And
|因此在验证检查步骤期间，

1208
00:42:04,760 --> 00:42:06,680
0,210 210,510 510,1080 1080,1440 1440,1920
so during validation check step,|
|

1209
00:42:06,800 --> 00:42:07,820
0,150 150,450 450,570 570,690 690,1020
we're basically going to check
我们基本上是要检查冲突，

1210
00:42:07,820 --> 00:42:09,260
0,150 150,900
for conflict,|
|

1211
00:42:15,860 --> 00:42:17,270
0,330 330,420 420,810 810,900 900,1410
and the conflict is basically
冲突基本上是如果版本号已递增

1212
00:42:17,270 --> 00:42:18,950
0,240 240,330 330,690 690,1200 1200,1680
if the version number {}

1213
00:42:18,980 --> 00:42:21,080
0,270 270,390 390,1110 1260,1620 1620,2100
has been incremented| {you,know} since
|你知道，因为你知道协调器实际上读取了对象，

1214
00:42:21,080 --> 00:42:24,470
0,120 120,840 1140,2850 2850,3090 3090,3390
you know {the,coordinator} actually read

1215
00:42:24,500 --> 00:42:26,300
0,150 150,690 870,1170 1170,1560 1560,1800
the object,| so {the,version} number
|所以版本号是不同的，

1216
00:42:26,300 --> 00:42:27,320
0,90 90,690
are different,|
|

1217
00:42:30,720 --> 00:42:33,900
0,990 1350,2160
different, then
不同，则事务中止，

1218
00:42:34,310 --> 00:42:36,620
0,240 240,990 990,1170 1170,1620
the transaction is aborted,|
|

1219
00:42:39,760 --> 00:42:41,140
0,510 510,630 630,780 780,1290 1290,1380
and if they're saying, are
如果他们说，仍然是一样的，

1220
00:42:41,140 --> 00:42:42,250
0,210 210,300 300,600 600,750 750,1110
still the same,| that basically
|这基本上意味着没有人、没有其他事务修改了事务、对象

1221
00:42:42,250 --> 00:42:43,930
0,270 270,390 390,960 990,1470 1470,1680
means that nobody no other

1222
00:42:43,930 --> 00:42:47,350
0,630 630,1290 1800,2610 2610,3270 3270,3420
transaction modified the transaction, the

1223
00:42:47,350 --> 00:42:49,270
0,660 900,1080 1080,1680 1680,1800 1800,1920
object| and then we can
|然后我们就可以继续前进，做出承诺。

1224
00:42:49,270 --> 00:42:50,350
0,240 240,420 420,630 630,720 720,1080
actually go ahead and commit.|
|

1225
00:42:52,860 --> 00:42:53,730
0,120 120,360 360,480 480,600 600,870
Of course, in the case
当然，在中止的情况下，

1226
00:42:53,730 --> 00:42:55,560
0,300 300,960 960,1290 1290,1620 1620,1830
of abort,| {you,know} typical what
|你知道，通常会发生的情况是，你认识的客户可能会再次运行整个交易，

1227
00:42:55,560 --> 00:42:57,660
0,300 300,510 510,720 720,1140 1290,2100
happen is that the {the,client}

1228
00:42:57,660 --> 00:42:59,580
0,90 90,450 480,810 810,1770 1770,1920
you know maybe run the

1229
00:42:59,610 --> 00:43:01,200
0,990 990,1290
{whole,transaction} again,|
|

1230
00:43:01,400 --> 00:43:02,660
0,600 600,870 870,990 990,1020 1020,1260
perhaps waiting for a little
也许在真正这么做之前要等一段时间，

1231
00:43:02,660 --> 00:43:04,700
0,480 480,1440 1440,1710 1710,1920 1920,2040
while before actually doing it,|
|

1232
00:43:04,730 --> 00:43:06,170
0,600 600,900 930,1140 1140,1380 1380,1440
{for,some} random {} period of
在一段随机的时间内。

1233
00:43:06,170 --> 00:43:06,840
0,330
time.|
|

1234
00:43:07,730 --> 00:43:09,920
0,270 270,510 510,630 630,1770 1770,2190
So that's the basic plan
所以这就是基本的计划，

1235
00:43:10,010 --> 00:43:12,260
0,240 240,1080 1110,1320 1320,1650 1650,2250
right,| so {this,is} optimistic scheme,|
|所以这是一个乐观的方案，|

1236
00:43:12,350 --> 00:43:14,600
0,210 210,450 450,810 810,1830 1860,2250
so that reads can completely
这样Reads就可以完全利用RDMA

1237
00:43:14,600 --> 00:43:17,540
0,720 750,1050 1050,1740 2010,2640 2640,2940
exploit {RDMA -}| {} and
|正如我们将看到的，实际上，Read需要在服务器上进行任何状态更改。

1238
00:43:17,540 --> 00:43:18,500
0,120 120,210 210,480 480,570 570,960
as we'll see, in fact

1239
00:43:18,710 --> 00:43:21,260
0,600 600,840 840,1260 1260,1890 2160,2550
read would require any state

1240
00:43:21,260 --> 00:43:23,270
0,630 660,1440 1440,1500 1500,1920 1920,2010
changes on the servers at

1241
00:43:23,270 --> 00:43:23,800
0,300
all.|
|

1242
00:43:25,500 --> 00:43:26,790
0,240 240,330 330,540 540,720 720,1290
And so this is basically
所以这基本上就是图4背后的基本思想，

1243
00:43:26,790 --> 00:43:28,650
0,180 180,270 270,630 720,1500 1500,1860
sort of the basic idea

1244
00:43:28,650 --> 00:43:32,640
0,510 570,1050 1050,1470 3060,3540 3540,3990
behind figure 4,| except {you,know}
|除了你知道，我们很快就会看到，

1245
00:43:32,640 --> 00:43:33,420
0,120 120,300 300,390 390,420 420,780
we'll see in a second,|
|

1246
00:43:33,420 --> 00:43:34,320
0,240 240,450 450,480 480,660 660,900
there's quite a bit more
这件事要复杂得多。

1247
00:43:34,320 --> 00:43:35,700
0,660 660,840 840,1140
complications to it.|
|

1248
00:43:36,190 --> 00:43:38,380
0,270 270,630 660,1170 1170,1920 2010,2190
So this again {sort,of} {}
所以这也是我想我刚才用了这个短语，

1249
00:43:38,380 --> 00:43:39,100
0,120 120,300 300,390 390,630 630,720
I think I used this

1250
00:43:39,100 --> 00:43:39,880
0,210 210,270 270,330 330,540 540,780
phrase in a little while

1251
00:43:39,880 --> 00:43:41,110
0,240 240,330 330,510 510,780 780,1230
ago,| a couple lectures ago,|
|几堂课前，|

1252
00:43:41,230 --> 00:43:43,420
0,270 270,840 840,1650 1650,1770 1770,2190
the optimistic schema in contrast
与悲观方案相反的乐观方案是，

1253
00:43:43,420 --> 00:43:44,800
0,60 60,180 180,690 690,1050 1050,1380
to the pessimistic scheme is,|
|

1254
00:43:44,950 --> 00:43:46,690
0,240 240,570 570,690 690,870 900,1740
you're basically going to assume
你基本上会认为你被允许做手术，

1255
00:43:46,690 --> 00:43:47,620
0,180 180,390 390,750 750,810 810,930
that you're allowed to do

1256
00:43:47,620 --> 00:43:49,150
0,120 120,900 1140,1290 1290,1380 1380,1530
the operation,| and if it
|如果结果是你不被允许道歉和放弃，

1257
00:43:49,150 --> 00:43:50,260
0,240 240,450 450,600 600,780 780,1110
turns out you're not allowed

1258
00:43:50,260 --> 00:43:51,370
0,60 60,240 240,300 300,990 990,1110
to sort of apologize and

1259
00:43:51,370 --> 00:43:53,290
0,510 780,1200 1200,1350 1350,1440 1440,1920
abort,| {} in the pessimistic
|在悲观的情况下，您基本上首先通过获取锁来请求批准进行操作

1260
00:43:53,290 --> 00:43:54,910
0,360 360,480 480,870 870,1380 1380,1620
case, you basically first ask

1261
00:43:54,910 --> 00:43:55,960
0,150 150,720 720,810 810,930 930,1050
for approval to do the

1262
00:43:55,960 --> 00:43:58,120
0,570 570,780 780,1260 1260,1830 1980,2160
operation by acquiring locks| and
|然后你基本上保证在提交时，你可以实际提交。

1263
00:43:58,120 --> 00:43:59,860
0,540 540,630 630,990 990,1560 1560,1740
then you basically guaranteed at

1264
00:43:59,860 --> 00:44:01,240
0,270 270,660 840,1020 1020,1140 1140,1380
commit time, you can actually

1265
00:44:01,240 --> 00:44:01,760
0,420
commit.|
|

1266
00:44:02,480 --> 00:44:03,340
0,570
Okay?|
好吧?|

1267
00:44:04,920 --> 00:44:06,390
0,210 210,630 630,990 990,1380 1380,1470
Any questions about optimistic {concurrency
对于如此高级别的乐观并发控制，有什么问题吗？

1268
00:44:06,390 --> 00:44:08,190
0,270 270,690 990,1170 1170,1590 1590,1800
-} control at this high

1269
00:44:08,190 --> 00:44:08,920
0,420
level?|
|

1270
00:44:10,670 --> 00:44:11,570
0,240 240,300 300,630 630,780 780,900
Just a question about the
只是一个关于版本号的问题，

1271
00:44:11,570 --> 00:44:12,980
0,360 360,900 900,1080 1080,1230 1230,1410
version numbers,| how do they
|他们如何确保这两个不同的对象之间具有类似的一致性，

1272
00:44:12,980 --> 00:44:15,170
0,570 570,900 930,1230 1230,1860 1860,2190
ensure that two different that

1273
00:44:15,200 --> 00:44:17,720
0,510 510,870 870,1680 1680,2220 2220,2520
there's like consistency across different

1274
00:44:17,720 --> 00:44:19,430
0,780 1050,1200 1200,1350 1350,1470 1470,1710
objects,| so that you're not
|这样你就不会先读取一个对象，然后再读取另一个对象，

1275
00:44:19,430 --> 00:44:21,590
0,630 870,1170 1170,1770 1770,1860 1860,2160
reading one object and then

1276
00:44:21,590 --> 00:44:23,180
0,390 390,630 630,930 930,1380 1380,1590
later reading another object,| but
|但这些，但一笔交易修改了其中的一些。

1277
00:44:23,180 --> 00:44:25,520
0,570 600,780 780,870 870,1560 1560,2340
those, but a transaction modified

1278
00:44:25,850 --> 00:44:27,080
0,240 240,300 300,540 540,690 690,1230
some of those in between.|
|

1279
00:44:27,350 --> 00:44:29,180
0,270 270,720 780,1020 1020,1590 1590,1830
Yeah well, {} that's a
是的，这是个很好的问题

1280
00:44:29,180 --> 00:44:31,220
0,240 240,630 780,1410 1410,1530 1530,2040
great question| and so let's,
|所以让我们，我想我们要离开了，只需要深入到图4，

1281
00:44:31,220 --> 00:44:32,480
0,300 450,750 750,930 930,1170 1170,1260
I think we're going to

1282
00:44:32,480 --> 00:44:33,770
0,300 300,480 480,720 720,900 900,1290
get out, just gotta dive

1283
00:44:33,770 --> 00:44:35,300
0,480 480,780 780,1050 1050,1410
into actually figure 4,|
|

1284
00:44:35,890 --> 00:44:36,850
0,300 300,480 480,660 660,750 750,960
{} and which I think
我认为这应该是本文的核心。

1285
00:44:36,850 --> 00:44:37,570
0,120 120,210 210,270 270,660 660,720
should be the core of

1286
00:44:37,570 --> 00:44:38,480
0,150 150,630
this paper.|
|

1287
00:44:39,440 --> 00:44:40,820
0,450 450,630 630,810 810,990 990,1380
{} So let's look at
让我们看一下图4，

1288
00:44:41,090 --> 00:44:42,800
0,600 600,870 870,1380
{} figure 4,|
|

1289
00:44:43,310 --> 00:44:44,480
0,840
and,
还有，哦，不是那个。

1290
00:44:50,860 --> 00:44:52,540
0,330 330,570 570,690 690,1080
oops, not that one.|
|

1291
00:44:53,930 --> 00:44:54,920
0,690

1292
00:44:56,630 --> 00:44:58,100
0,420 420,570 570,840 840,1170
Alright, here figure 4,|
好的，这里是图4，|

1293
00:45:00,160 --> 00:45:00,970
0,150 150,270 270,330 330,540 540,810
we're going to spend quite
我们将花相当多的时间来讨论图4。

1294
00:45:00,970 --> 00:45:02,140
0,30 30,150 150,210 210,720 750,1170
a bit of time {}

1295
00:45:02,140 --> 00:45:03,550
0,360 360,660 660,780 780,1050 1050,1410
basically talking about figure 4.|
|

1296
00:45:04,960 --> 00:45:07,480
0,720 1260,1590 1590,1860 1860,2340 2340,2520
{ -} So {the,first} {you,know}
所以你知道的第一件事就是在图4中定位，

1297
00:45:07,480 --> 00:45:09,250
0,390 390,510 510,1350 1440,1680 1680,1770
things get oriented {} in

1298
00:45:09,250 --> 00:45:11,500
0,210 210,780 780,1290 1320,2160 2160,2250
this figure 4,| {} you
|你知道我们看到了，

1299
00:45:11,500 --> 00:45:13,150
0,120 120,240 240,870 960,1290 1290,1650
know we see,| { -
|所以我们有一个事务协调器，这里的C，

1300
00:45:17,910 --> 00:45:20,220
0,600 630,870 870,1050 1050,1260 1260,2310
-} so we have a

1301
00:45:20,220 --> 00:45:22,920
0,450 450,1470 1590,1860 1860,2160 2160,2700
transaction coordinator, the C here,|
|

1302
00:45:23,190 --> 00:45:24,720
0,480 480,600 600,930 930,1170 1170,1530
and it's really the transaction
它实际上是事务协调器是一个应用程序

1303
00:45:24,720 --> 00:45:27,210
0,630 630,780 780,1200 1200,1980 2010,2490
coordinator is a application| and
|应用程序运行在同一台机器上，是这90台机器中的一台，

1304
00:45:27,510 --> 00:45:28,410
0,150 150,540 540,750 750,840 840,900
the application runs on the

1305
00:45:28,410 --> 00:45:29,340
0,270 270,630 630,690 690,870 870,930
same machine, is one of

1306
00:45:29,340 --> 00:45:31,530
0,210 210,480 480,1200 1470,2130 2130,2190
those 90 machines,| but the
|但在接下来的演讲中，我会这样想，

1307
00:45:31,530 --> 00:45:32,220
0,210 210,300 300,420 420,510 510,690
way I'm going to think

1308
00:45:32,220 --> 00:45:33,450
0,270 270,450 630,1020 1020,1080 1080,1230
about it for the rest

1309
00:45:33,450 --> 00:45:34,410
0,60 60,240 240,690 690,840 840,960
of those lectures,| that it
|它在一台单独的机器上运行，我真的不太关心它，好吗？

1310
00:45:34,410 --> 00:45:35,490
0,180 180,360 360,420 420,750 750,1080
runs on a separate machine

1311
00:45:35,490 --> 00:45:36,300
0,60 60,180 180,360 360,570 570,810
I don't really care about

1312
00:45:36,300 --> 00:45:38,380
0,270 270,450 450,840 990,1620
it that much, okay?|
|

1313
00:45:38,620 --> 00:45:40,210
0,180 180,630 630,630 630,1380 1380,1590
And then, {} there are
然后，有不同的碎片，

1314
00:45:40,210 --> 00:45:41,770
0,240 240,690 990,1290 1290,1410 1410,1560
different shards,| {} in this
|在这种情况下有3个碎片，1 2和3，

1315
00:45:41,770 --> 00:45:42,940
0,300 300,420 420,480 480,690 690,1170
case there are 3 shards,

1316
00:45:43,540 --> 00:45:46,180
0,570 570,1110 1110,1260 1260,1770 2100,2640
1 2 and 3,| and
|每个碎片被复制两次，一次在主服务器中，一次在备份服务器中。

1317
00:45:46,180 --> 00:45:48,250
0,270 270,720 720,1200 1200,1680 1680,2070
each shard is replicated twice,

1318
00:45:48,250 --> 00:45:49,330
0,270 270,330 330,420 420,900 900,1080
one's in the primary, one's

1319
00:45:49,330 --> 00:45:50,120
0,60 60,150 150,510
in the backup.|
|

1320
00:45:51,050 --> 00:45:54,050
0,690 1290,2220 2250,2370 2370,2700 2700,3000
{} Then {you,know} we'll see
你知道我们会看到的，

1321
00:45:54,050 --> 00:45:55,130
0,210 210,330 330,420 420,510 510,1080
that,| this is the execution
|这是事务的执行阶段，

1322
00:45:55,130 --> 00:45:56,300
0,240 240,360 360,450 450,1020 1020,1170
phase of the transaction,| so
|所以事务是两个阶段，一个是执行阶段，然后是提交阶段，

1323
00:45:56,300 --> 00:45:57,920
0,120 120,600 600,720 720,930 930,1620
the transaction is two phases,

1324
00:45:58,040 --> 00:45:59,450
0,360 360,480 480,540 540,1110 1110,1410
one is the execution phase,

1325
00:45:59,450 --> 00:46:02,030
0,300 300,360 360,630 630,1170 1860,2580
and then commit phase, {}|
|

1326
00:46:02,030 --> 00:46:04,190
0,780 810,1170 1170,1290 1290,1890 1890,2160
and during the execution phase,|
并且在执行阶段期间，|

1327
00:46:04,190 --> 00:46:05,600
0,150 150,300 300,870 870,960 960,1410
this is where the transaction
这是运行事务的位置，

1328
00:46:05,600 --> 00:46:07,160
0,120 120,390 390,690 690,990 990,1560
is run,| so {does,it} begin,
|那么它是否开始，是否读取，例如，在本例中，正在读取3个对象

1329
00:46:07,400 --> 00:46:09,890
0,330 330,930 1200,1620 1650,2160 2160,2490
does read, for example in

1330
00:46:09,890 --> 00:46:11,090
0,180 180,480 480,630 630,870 870,1200
this case the 3 objects

1331
00:46:11,090 --> 00:46:12,470
0,90 90,300 300,630 780,870 870,1380
are being read| and one
|还有一个，它的主要部分位于一个实际位于碎片1的物体中，

1332
00:46:12,470 --> 00:46:13,940
0,210 210,360 360,900 900,1230 1260,1470
that was located {} whose

1333
00:46:13,940 --> 00:46:15,830
0,480 480,1020 1110,1380 1380,1800 1800,1890
primaries in one object that

1334
00:46:15,830 --> 00:46:17,780
0,360 360,720 720,1020 1020,1440 1590,1950
actually {sit,in} shard 1,| one
|其中一个物体位于碎片3中，

1335
00:46:17,780 --> 00:46:19,370
0,360 360,510 510,840 840,1170 1170,1590
object that's {sit,in} shard 3,|
|

1336
00:46:19,370 --> 00:46:21,200
0,270 270,930 930,990 990,1440 1470,1830
one objects in shard 2,
一个物体在碎片2，好的区域。

1337
00:46:21,660 --> 00:46:24,450
0,390 390,690 690,930 930,1290 1890,2790
alright {} {region 2}.| And
|我们可以看到，

1338
00:46:24,600 --> 00:46:27,660
0,990 1290,2130 2250,2580 2580,2670 2670,3060
{} the we can see,|
|

1339
00:46:27,660 --> 00:46:28,740
0,360 360,690 690,870 870,930 930,1080
actually we look a little
实际上，我们向前看了一点，

1340
00:46:28,740 --> 00:46:30,570
0,90 90,570 900,1410 1410,1590 1590,1830
bit ahead,| {} we'll see
|我们将看到这两个对象实际上是在写入

1341
00:46:30,570 --> 00:46:31,560
0,270 270,720
that the

1342
00:46:31,830 --> 00:46:32,850
0,390 390,540 540,720 720,870 870,1020
{} the two of these

1343
00:46:32,850 --> 00:46:34,530
0,360 360,450 450,690 690,1110 1110,1680
objects are actually being {}

1344
00:46:34,620 --> 00:46:35,880
0,510 510,690 690,870 870,990 990,1260
written| and one of them
|其中一份正在被阅读，

1345
00:46:35,880 --> 00:46:37,440
0,180 180,450 450,810 1080,1260 1260,1560
is being read,| so the
|因此，来自数字碎片3的对象，

1346
00:46:37,500 --> 00:46:40,350
0,390 390,840 870,1920 1950,2370 2370,2850
object from number shard 3,|
|

1347
00:46:40,410 --> 00:46:41,160
0,150 150,300 300,450 450,540 540,750
this is just a read
这只是一个读操作

1348
00:46:41,160 --> 00:46:42,750
0,570 660,960 960,1200 1200,1320 1320,1590
operation| and these are write
|这些是写操作，

1349
00:46:42,750 --> 00:46:45,000
0,690 1140,1320 1320,1470 1470,1680 1680,2250
operations,| these are read operations,|
|这些是读操作，|

1350
00:46:45,000 --> 00:46:46,590
0,300 450,1080 1080,1380 1380,1470 1470,1590
but those objects are going
但这些对象将被修改。

1351
00:46:46,590 --> 00:46:47,600
0,60 60,180 180,810
to be modified.|
|

1352
00:46:48,270 --> 00:46:50,100
0,510 540,1080 1080,1290 1290,1350 1350,1830
So basically as the transaction
因此，基本上随着交易的运行，

1353
00:46:50,100 --> 00:46:51,330
0,450 450,570 570,690 690,870 870,1230
runs,| you know it fetches
|你知道，它从不同的机器获取对象，在本地修改它们

1354
00:46:51,330 --> 00:46:54,210
0,480 480,1080 1080,1380 1380,2130 2160,2880
objects from different machines, modifies

1355
00:46:54,210 --> 00:46:56,370
0,150 150,840 1020,1170 1170,1650 1650,2160
them locally| and then in
|然后在提交阶段应用更改

1356
00:46:56,370 --> 00:46:58,770
0,180 180,510 510,1140 1260,1770 1770,2400
the commit phase, {} the

1357
00:46:58,890 --> 00:47:00,690
0,510 510,720 720,930 930,1470 1620,1800
changes are being applied| and
|当然，你知道这里的整个挑战是，

1358
00:47:00,690 --> 00:47:01,650
0,60 60,450 450,540 540,720 720,960
of course you know the

1359
00:47:01,650 --> 00:47:03,180
0,330 330,780 780,1170 1170,1320 1320,1530
whole challenge here is that,|
|

1360
00:47:03,180 --> 00:47:04,380
0,90 90,180 180,480 480,660 660,1200
in the end we want
最后，我们希望实现严格的可序列化。

1361
00:47:04,740 --> 00:47:07,080
0,420 420,1260 1350,1650 1650,1950 1950,2340
to achieve {} strict {serializability

1362
00:47:07,080 --> 00:47:07,920
0,480
-}.|
|

1363
00:47:08,830 --> 00:47:10,400
0,390

1364
00:47:17,470 --> 00:47:18,540
0,840

1365
00:47:18,740 --> 00:47:20,570
0,180 180,270 270,540 540,1140 1170,1830
And in some ways, {}
在某些方面，至少写入的协议总是遵循非常类似的两阶段提交协议，这是我们过去看到的，

1366
00:47:20,600 --> 00:47:25,130
0,720 1860,3030 3810,4200 4200,4350 4350,4530
the protocol for at least

1367
00:47:25,130 --> 00:47:27,590
0,660 720,1200 1200,1800 1830,2160 2160,2460
writes, always follows a very

1368
00:47:27,590 --> 00:47:29,150
0,540 540,660 660,900 900,1140 1140,1560
similar {two-phase -} commit protocols,

1369
00:47:29,150 --> 00:47:29,810
0,150 150,300 300,510 510,570 570,660
that we've seen in the

1370
00:47:29,810 --> 00:47:30,980
0,450 450,720 720,780 780,1110 1110,1170
past,| there are differences in
|在细节上有所不同，

1371
00:47:30,980 --> 00:47:32,570
0,90 90,750 900,1260 1260,1320 1320,1590
the details,| but the basic
|但基本策略是相同的，

1372
00:47:32,570 --> 00:47:34,610
0,420 420,570 570,630 630,1140 1380,2040
strategy is the same, {}|
|

1373
00:47:34,610 --> 00:47:35,780
0,390 390,510 510,690 690,1020 1020,1170
and you know we can
你知道我们可以分类，

1374
00:47:35,780 --> 00:47:37,820
0,330 420,840 840,1170 1200,1380 1380,2040
sort,| {} so let's assume
|让我们假设现在我们已经完成了执行阶段，

1375
00:47:38,030 --> 00:47:39,020
0,390 390,540 540,660 660,870 870,990
that now we're done with

1376
00:47:39,020 --> 00:47:40,820
0,90 90,600 600,900 900,1200 1200,1800
the execution phase,| so we're
|所以我们我们在交易的末尾

1377
00:47:40,910 --> 00:47:41,570
0,240 240,330 330,450 450,570 570,660
we're at the end of

1378
00:47:41,570 --> 00:47:43,010
0,90 90,690 690,870 900,990 990,1440
the transaction| and the transaction
|事务将尝试提交，

1379
00:47:43,010 --> 00:47:43,550
0,60 60,180 180,240 240,420 420,540
is going to try to

1380
00:47:43,550 --> 00:47:44,080
0,390
commit,|
|

1381
00:47:44,250 --> 00:47:45,330
0,300 300,720 720,840 840,960 960,1080
that transaction that could be
这笔交易可能会有两种结果，

1382
00:47:45,330 --> 00:47:46,560
0,180 180,660 660,750 750,870 870,1230
two outcomes,| you know actually
|你知道，实际上你知道，成功提交或实际中止，

1383
00:47:46,560 --> 00:47:48,120
0,180 180,690 690,1020 1020,1260 1260,1560
{you,know} successfully commits or actually

1384
00:47:48,120 --> 00:47:48,900
0,570
aborts,|
|

1385
00:47:49,420 --> 00:47:51,130
0,480 600,930 930,1050 1050,1320 1320,1710
{} {and,the} {aborts -} because
并且由于某个其他事务同时运行并且修改对象之一而中止，

1386
00:47:51,130 --> 00:47:52,870
0,120 120,390 390,840 840,1050 1050,1740
some other transaction ran concurrently

1387
00:47:52,990 --> 00:47:53,950
0,150 150,630 630,810 810,900 900,960
and modifies one of the

1388
00:47:53,950 --> 00:47:55,480
0,450 450,870 870,990 990,1200 1200,1530
objects,| that we either read
|我们要么在读，要么在试着写。

1389
00:47:55,480 --> 00:47:56,680
0,240 240,480 480,690 690,810 810,1200
or were trying to write.|
|

1390
00:47:57,640 --> 00:47:58,640
0,690

1391
00:47:59,190 --> 00:48:01,170
0,570 900,1140 1140,1260 1260,1500 1500,1980
And so the first thing,
因此，第一件事，这种协议，提交阶段基本上有5个步骤，

1392
00:48:01,170 --> 00:48:02,760
0,300 300,450 450,510 510,1140 1200,1590
that sort of protocol, the

1393
00:48:02,760 --> 00:48:04,650
0,270 270,690 690,1050 1050,1530 1560,1890
commit phase basically has 5

1394
00:48:04,650 --> 00:48:06,510
0,540 540,660 660,900 900,1200 1470,1860
steps,| you know the lock
|您知道锁定步骤、验证步骤、提交备份步骤、提交主要步骤，然后是截断，

1395
00:48:06,510 --> 00:48:08,310
0,420 420,510 510,1050 1050,1680 1710,1800
step, the validation step, the

1396
00:48:08,310 --> 00:48:09,810
0,240 240,600 600,1050 1050,1170 1170,1500
commit backup step, the commit

1397
00:48:09,810 --> 00:48:11,400
0,690 780,960 960,1110 1110,1290 1290,1590
primary and then the truncate,|
|

1398
00:48:11,400 --> 00:48:13,290
0,330 330,450 450,990 990,1320 1320,1890
and the truncate basically runs
而截断基本上运行得几乎很慢

1399
00:48:13,320 --> 00:48:16,200
0,930 930,1620 1650,1920 1920,2580 2580,2880
{} almost {} lazily| and
|所以这并不是特别重要，

1400
00:48:16,200 --> 00:48:17,670
0,180 180,360 360,540 540,930 930,1470
so it's not particularly important,|
|

1401
00:48:17,880 --> 00:48:19,890
0,480 480,690 690,900 900,1440 1440,2010
basically for our perspective, basically
从我们的角度来看，基本上，事情停止的地方就是这里，

1402
00:48:19,950 --> 00:48:21,120
0,150 150,420 420,540 540,930 930,1170
the point of interest where

1403
00:48:21,120 --> 00:48:23,310
0,270 270,330 330,960 1260,1710 1710,2190
things are stopping is here,|
|

1404
00:48:23,370 --> 00:48:24,210
0,180 180,390 390,540 540,720 720,840
so that's sort of the
这就是交易的结束。

1405
00:48:24,210 --> 00:48:26,160
0,240 240,360 360,450 450,1200 1230,1950
end of the transaction is.|
|

1406
00:48:27,820 --> 00:48:28,920
0,300 300,780
Okay, so
好的，这些物体之前都说过，

1407
00:48:29,200 --> 00:48:30,490
0,510 570,720 720,810 810,960 960,1290
{} each of these objects

1408
00:48:30,490 --> 00:48:32,140
0,180 180,420 420,1050 1080,1200 1200,1650
have said before,| you know
|你知道，当你读到它们有一个版本时，这是一个版本号，

1409
00:48:32,140 --> 00:48:33,070
0,180 180,300 300,480 480,720 720,930
when you read them has

1410
00:48:33,070 --> 00:48:34,510
0,30 30,360 360,510 510,1110 1110,1440
a version, {here's} a version

1411
00:48:34,510 --> 00:48:35,440
0,540
number,|
|

1412
00:48:37,290 --> 00:48:40,050
0,690 1200,1920 1950,2220 2220,2610 2610,2760
{} and {} there are
而且它在当地有修饰语，

1413
00:48:40,050 --> 00:48:41,700
0,690 690,810 810,1320 1320,1530 1530,1650
modifiers it locally,| then at
|然后在这一点上，

1414
00:48:41,700 --> 00:48:42,570
0,90 90,360 360,450 450,780 780,870
the point of this,| you
|你知道当这是提交点的时候，

1415
00:48:42,570 --> 00:48:43,710
0,90 90,390 390,600 600,960 960,1140
know when when this this

1416
00:48:43,710 --> 00:48:45,120
0,120 120,210 210,480 480,870 1230,1410
is the commit point,| where
|其中当应用程序调用和交易时，

1417
00:48:45,120 --> 00:48:46,590
0,240 240,390 390,870 870,1230 1230,1470
when the application calls and

1418
00:48:46,590 --> 00:48:49,920
0,690 960,1080 1080,2220 2430,3150 3150,3330
transaction,| the {} protocol, but
|协议，但整个提交阶段协议才起作用。

1419
00:48:49,920 --> 00:48:51,960
0,150 150,660 780,1230 1230,1530 1530,2040
this whole commit phase protocol

1420
00:48:51,960 --> 00:48:52,720
0,330 330,510
kicks in.|
|

1421
00:48:53,550 --> 00:48:54,960
0,540 540,990 990,1110 1110,1200 1200,1410
{} And so the first
所以它做的第一件事就是

1422
00:48:54,960 --> 00:48:56,550
0,120 120,240 240,780 810,1260 1260,1590
thing it does {} is|
|

1423
00:48:56,550 --> 00:48:58,020
0,180 180,450 450,600 600,960 960,1470
what's called the locking step,
所谓的锁定步骤，步骤1

1424
00:48:58,050 --> 00:49:00,450
0,330 330,540 540,1020 1230,1890 2040,2400
step number 1| and {the,goal}
|这一步的目标基本上是获取正在写入的所有对象的锁，

1425
00:49:00,450 --> 00:49:01,470
0,420 420,540 540,720 720,960 960,1020
here, in this step is

1426
00:49:01,470 --> 00:49:03,090
0,90 90,390 390,870 870,1410 1440,1620
to basically acquire locks on

1427
00:49:03,090 --> 00:49:04,710
0,210 210,360 360,1020 1050,1440 1440,1620
all the objects that are

1428
00:49:04,710 --> 00:49:05,600
0,270 270,660
being written,|
|

1429
00:49:06,110 --> 00:49:07,010
0,390 390,570 570,690 690,810 810,900
{} and so we can
所以我们可以看到，根据这张图，

1430
00:49:07,010 --> 00:49:08,030
0,360 360,510 510,780 780,870 870,1020
see {you,know} based on this

1431
00:49:08,030 --> 00:49:10,520
0,630 630,1020 1350,1890 1890,2100 2100,2490
diagram,| that apparently two objects
|显然有两个对象正在被写入，即This对象，

1432
00:49:10,520 --> 00:49:13,880
0,930 960,1230 1230,1740 1770,2730 2730,3360
are being written namely {}

1433
00:49:14,580 --> 00:49:17,430
0,720 1080,1320 1320,2130 2130,2430 2430,2850
the this object,| because context
|因为上下文是碎片1、区域1的主要内容

1434
00:49:17,430 --> 00:49:19,380
0,60 60,330 330,870 870,1380 1590,1950
is the primary of {}

1435
00:49:19,380 --> 00:49:21,090
0,270 270,630 630,930 930,1380 1530,1710
shard 1, region 1| and
|然后这个对象被读取，

1436
00:49:21,090 --> 00:49:22,260
0,390 390,390 390,750 750,1080 1080,1170
then {} this object is

1437
00:49:22,260 --> 00:49:23,550
0,240 240,480 540,930 930,1170 1170,1290
being read,| {} that is
|实际上位于2区，对吧，

1438
00:49:23,550 --> 00:49:25,380
0,240 240,810 810,1290 1290,1590 1590,1830
actually located on region 2,

1439
00:49:25,770 --> 00:49:27,690
0,390 720,1230 1230,1350 1350,1590 1590,1920
right,| apparently the third object
|显然，我们读到的第三个物体，你知道的，是三年级的，

1440
00:49:27,690 --> 00:49:28,650
0,120 120,240 240,570 630,810 810,960
that we read you know

1441
00:49:28,650 --> 00:49:31,530
0,300 300,690 690,1230 1590,2490 2640,2880
for primary 3,| {} it's
|它没有被阅读，

1442
00:49:31,530 --> 00:49:33,870
0,510 510,660 660,900 900,1890 2040,2340
not {} {being,read},| {} because
|因为它不参与锁定阶段。

1443
00:49:33,870 --> 00:49:35,280
0,240 240,570 570,1200 1200,1320 1320,1410
it doesn't participate in the

1444
00:49:35,280 --> 00:49:36,220
0,300 300,840
locking phase.|
|

1445
00:49:36,700 --> 00:49:38,560
0,630 780,930 930,1020 1020,1290 1290,1860
So in the locking phase,|
所以在锁定阶段，|

1446
00:49:38,590 --> 00:49:39,840
0,1020

1447
00:49:40,400 --> 00:49:42,200
0,600 630,1080 1080,1350 1350,1590 1590,1800
txhe arrows actually have all
箭头实际上有各种不同的含义，

1448
00:49:42,200 --> 00:49:43,820
0,210 210,390 390,660 660,1290 1410,1620
kinds of different meanings,| so
|所以这些虚线箭头是单面RDMA。

1449
00:49:43,820 --> 00:49:47,030
0,210 210,690 690,1590 2160,2880 2910,3210
these dashed arrows are {one-sided

1450
00:49:47,030 --> 00:49:48,860
0,330 330,840 840,1200
-} {RDMAs -}.|
|

1451
00:49:57,100 --> 00:49:58,120
0,210 210,420 420,450 450,840 840,1020
So {those -} objects are
因此，这些对象是使用RDMA读取的，

1452
00:49:58,120 --> 00:49:59,680
0,240 240,540 540,780 780,1410 1410,1560
being read with RDMA,| they're
|它们只是从远程内存位置获取的

1453
00:49:59,680 --> 00:50:01,240
0,210 210,630 630,900 900,960 960,1560
just fetched from the remote

1454
00:50:01,540 --> 00:50:04,510
0,600 600,1380 1440,2100 2100,2550 2550,2970
memory location| {} and []
|和[]在本地，您知道应用程序或协调器的内存。

1455
00:50:04,510 --> 00:50:06,340
0,480 480,540 540,690 690,1020 1020,1830
locally, you know to the

1456
00:50:06,460 --> 00:50:07,840
0,180 180,240 240,540 540,690 690,1380
to the memory of the

1457
00:50:07,900 --> 00:50:09,640
0,810 810,1500
application {or,coordinator}.|
|

1458
00:50:10,050 --> 00:50:12,360
0,840 1170,2010

1459
00:50:12,810 --> 00:50:13,840
0,720

1460
00:50:14,620 --> 00:50:16,360
0,450 540,930 930,1200 1200,1470 1470,1740
The solid ones are write
坚固的是写RDMA，

1461
00:50:16,360 --> 00:50:17,400
0,120 120,480 480,810
{RDMAs - -},|
|

1462
00:50:17,960 --> 00:50:20,140
0,750 990,1710
and, {}
在这个特殊的案例中，

1463
00:50:21,420 --> 00:50:22,830
0,150 150,240 240,390 390,750 750,1410
and in this particular case,|
|

1464
00:50:26,350 --> 00:50:29,170
0,240 240,870 960,1350 1350,2250 2370,2820
they depend on lock {}
它们依赖于主服务器的锁定条目、主服务器的日志条目

1465
00:50:29,170 --> 00:50:30,880
0,420 420,720 720,1380
entry to the,

1466
00:50:32,100 --> 00:50:34,020
0,270 270,930 1140,1740 1740,1830 1830,1920
to the log of the

1467
00:50:34,020 --> 00:50:35,250
0,480 480,720 720,810 810,1140 1140,1230
primary,| so the primary has
|所以主服务器有一个日志，

1468
00:50:35,250 --> 00:50:36,960
0,60 60,660 780,1200 1200,1560 1560,1710
a log,| every primary has
|每个初选都有一个日志，

1469
00:50:36,960 --> 00:50:38,160
0,30 30,540 570,720 720,1080 1080,1200
a log,| so I'm just
|所以我就画成这样，

1470
00:50:38,160 --> 00:50:39,150
0,150 150,330 330,450 450,570 570,990
gonna draw it like this,|
|

1471
00:50:39,980 --> 00:50:42,830
0,390 390,1140 1350,1890 1890,2730 2730,2850
{} and {} actually use
实际上使用的是不同的颜色，

1472
00:50:42,830 --> 00:50:44,570
0,60 60,270 270,750 1110,1380 1440,1740
a different color,| so here
|所以在这里我们有第一个I和一个原木，

1473
00:50:44,570 --> 00:50:46,040
0,120 120,330 330,450 450,900 900,1470
we have the primary i

1474
00:50:46,070 --> 00:50:47,480
0,270 270,570 570,1140
with a log,|
|

1475
00:50:49,380 --> 00:50:52,770
0,540 540,1170 1380,1980 1980,2580 2880,3390
and basically {} the the
基本上，协调人，这是一个提交记录，

1476
00:50:54,460 --> 00:50:56,350
0,390 390,1140 1140,1440 1440,1800 1800,1890
the coordinator, {} it's a

1477
00:50:56,350 --> 00:50:57,440
0,300 300,750
commit record,|
|

1478
00:50:58,270 --> 00:50:59,290
0,180 180,330 330,540 540,630 630,1020
{} no {sorry -}, sorry,
不抱歉，抱歉，锁定记录被调用到日志中，

1479
00:50:59,470 --> 00:51:01,660
0,810 810,1200 1200,1410 1410,1890
lock record is called

1480
00:51:05,560 --> 00:51:07,540
0,540 540,900 900,1500 1530,1860 1860,1980
to the log,| I'm going
|我要让它成为一张大唱片，

1481
00:51:07,540 --> 00:51:08,050
0,60 60,180 180,270 270,300 300,510
to make it a big

1482
00:51:08,050 --> 00:51:09,400
0,390 390,540 540,720 810,1140 1140,1350
record,| I can write down
|我可以把里面的东西写下来

1483
00:51:09,400 --> 00:51:11,020
0,180 180,300 300,510 930,1350 1350,1620
what's in it| and it
|它是读或写时的新版本号

1484
00:51:11,020 --> 00:51:12,430
0,210 210,390 390,720 720,1170 1260,1410
is new version number of

1485
00:51:12,430 --> 00:51:13,780
0,90 90,420 420,540 540,900 900,1350
the time of the {read,or,write}|
|

1486
00:51:13,780 --> 00:51:14,590
0,90 90,360 360,420 420,690 690,810
and when the object is
当对象被读取时，这里出来的版本号，

1487
00:51:14,590 --> 00:51:15,790
0,300 300,420 420,600 600,900 900,1200
read, so that version number

1488
00:51:15,790 --> 00:51:17,100
0,180 180,420 420,570 570,960
that came out here,|
|

1489
00:51:18,690 --> 00:51:20,190
0,420 420,630 630,840 840,1110 1110,1500
{} that comes back into
返回到日志记录中，

1490
00:51:20,190 --> 00:51:22,140
0,270 270,570 570,1080 1260,1500 1500,1950
the log record,| the object
|正在读取的对象ID和该对象的新值，

1491
00:51:22,140 --> 00:51:24,900
0,570 600,900 900,1110 1110,1560 2160,2760
id that's being read and

1492
00:51:24,900 --> 00:51:25,800
0,90 90,270 270,690 690,810 810,900
the new value for the

1493
00:51:25,800 --> 00:51:27,380
0,690
object,|
|

1494
00:51:29,560 --> 00:51:31,150
0,420 420,870 900,1080 1080,1410 1410,1590
and so this record is
因此，这条记录只是使用写RDMA添加到第一个和第二个主数据的日志中。

1495
00:51:31,150 --> 00:51:34,210
0,330 360,840 840,1080 1170,2040 2220,3060
just {appended -} {you,know,to} the

1496
00:51:34,690 --> 00:51:37,780
0,510 660,2130 2310,2760 2760,3000 3000,3090
you know primary one and

1497
00:51:37,780 --> 00:51:41,080
0,330 330,1080 1320,1920 1920,2520 2700,3300
primary two's {} log using

1498
00:51:41,080 --> 00:51:42,880
0,540 570,930 930,1500
{} write RDMA.|
|

1499
00:51:43,360 --> 00:51:44,800
0,120 120,240 240,510 510,870 870,1440
And so there's some thread
所以这些机器上有一些线，

1500
00:51:44,830 --> 00:51:46,990
0,390 390,600 600,1050 1050,1860 1950,2160
sitting on those machines,| that
|它查看这些日志，然后实际执行一些操作，

1501
00:51:46,990 --> 00:51:48,040
0,240 240,300 300,570 570,960 960,1050
looks at these logs and

1502
00:51:48,040 --> 00:51:49,480
0,150 150,420 420,570 570,690 690,1440
then actually does some operations,|
|

1503
00:51:50,190 --> 00:51:51,390
0,390 390,630 630,750 750,870 870,1200
{} so in this particular
所以在这个特殊的案例中，

1504
00:51:51,390 --> 00:51:53,010
0,390 390,930 1020,1260 1260,1350 1350,1620
case,| if there's a thread
|如果p1和p2上有一根线，

1505
00:51:53,010 --> 00:51:55,080
0,300 300,870 1170,1530 1530,1860 1890,2070
sitting on { -} {p1

1506
00:51:55,080 --> 00:51:57,720
0,360 360,540 540,1170 1170,1860 1890,2640
-} and p2,| {you,know} monitors
|你知道监控、旋转或轮询这个日志

1507
00:51:57,720 --> 00:51:59,910
0,810 810,1080 1080,1260 1260,1710 1710,2190
or spins or polls this

1508
00:51:59,910 --> 00:52:01,470
0,600 780,1020 1020,1320 1320,1530 1530,1560
log| and sees there's a
|看到有一个新的日志记录

1509
00:52:01,470 --> 00:52:03,000
0,180 180,510 510,900 900,1080 1080,1530
new log record| and then
|然后在这种特殊的情况下，它会做什么，

1510
00:52:03,180 --> 00:52:04,290
0,240 240,390 390,720 720,960 960,1110
in this particular case, what

1511
00:52:04,290 --> 00:52:05,190
0,90 90,240 240,660 720,810 810,900
it will do,| it will
|它将尝试锁定该对象，

1512
00:52:05,190 --> 00:52:06,240
0,180 180,270 270,420 420,510 510,1050
try to get a lock

1513
00:52:06,240 --> 00:52:07,500
0,210 210,360 360,1020 1020,1110 1110,1260
on the object,| you know
|你知道，这实际上是在交易中列出的，

1514
00:52:07,500 --> 00:52:09,630
0,270 270,780 780,960 960,1380 1380,2130
that actually is listed in

1515
00:52:09,990 --> 00:52:13,200
0,90 90,1560 2190,2460 2460,3030
the {} in the

1516
00:52:13,640 --> 00:52:15,740
0,600 810,1410 1410,1830 1830,2010 2010,2100
{} transaction,| somewhere, there's an
|在某个地方，有一个物体，

1517
00:52:15,740 --> 00:52:16,860
0,660
object,|
|

1518
00:52:18,300 --> 00:52:19,560
0,450 450,540 540,720 720,1140 1140,1260
and that object have some
且该对象中包含一些数据

1519
00:52:19,560 --> 00:52:20,520
0,270 270,420 420,750 750,840 840,960
data in it| and it
|它里面有这些锁位和版本号。

1520
00:52:20,520 --> 00:52:21,960
0,210 210,450 450,750 750,1200 1200,1440
has these lock bit and

1521
00:52:21,960 --> 00:52:23,560
0,300 300,660 660,750 750,900
version number in it.|
|

1522
00:52:25,240 --> 00:52:26,950
0,240 240,510 510,660 660,1290 1290,1710
And so {p1 -} has
所以p1有一个物体，

1523
00:52:26,950 --> 00:52:28,240
0,210 210,780 780,840 840,960 960,1290
one object,| you know that
|你知道这是由协调员修改的，

1524
00:52:28,240 --> 00:52:31,420
0,120 120,600 930,2010 2010,2280 2280,3180
is being modified by {}

1525
00:52:31,690 --> 00:52:33,700
0,750 750,1140 1140,1320 1320,1620 1620,2010
coordinator,| p2 has another object
|P2有另一个由协调器修改的对象

1526
00:52:33,700 --> 00:52:34,570
0,120 120,210 210,660 660,780 780,870
that is modified by the

1527
00:52:34,570 --> 00:52:38,350
0,720 1050,1380 1380,2100 2190,3120 3180,3780
coordinator| and basically the, {}
|基本上，主对象尝试使用test和set指令对对象进行锁定。

1528
00:52:38,590 --> 00:52:39,820
0,360 360,810 810,1080 1080,1140 1140,1230
the primary tries to be

1529
00:52:39,820 --> 00:52:41,860
0,390 390,480 480,900 930,1380 1380,2040
required the lock on the,

1530
00:52:43,840 --> 00:52:44,920
0,240 240,360 360,750 750,990 990,1080
on the object, using {}

1531
00:52:44,920 --> 00:52:46,020
0,180 180,270 270,420 420,930
test and set instruction.|
|

1532
00:52:46,540 --> 00:52:48,340
0,270 270,780 870,1170 1170,1380 1380,1800
And so, {} it will
因此，它将尝试设置锁定位，

1533
00:52:48,340 --> 00:52:49,720
0,240 240,390 390,750 750,870 870,1380
try to {set,lock} {} bit,|
|

1534
00:52:52,050 --> 00:52:53,250
0,540 540,630 630,720 720,930 930,1200
{} { -} using {test,and}
使用测试和设置指令，

1535
00:52:53,250 --> 00:52:54,900
0,180 180,840 1050,1440 1440,1560 1560,1650
set instruction,| and if the
|如果锁定位为0，

1536
00:52:54,900 --> 00:52:57,930
0,240 240,450 450,570 570,1230 1470,3030
lock bit was 0, {}|
|

1537
00:52:57,930 --> 00:53:01,440
0,960 1050,2070 2250,2580 2580,3090 3090,3510
and before {} and the
并且在与锁定0之前并成功地将位设置为1，

1538
00:53:01,950 --> 00:53:03,900
0,300 300,570 570,1080 1080,1470 1470,1950
lock of 0 and successfully

1539
00:53:03,900 --> 00:53:04,920
0,180 180,270 270,450 450,540 540,1020
set the bit to 1,|
|

1540
00:53:05,190 --> 00:53:06,630
0,360 360,570 570,660 660,1110 1110,1440
{} then it knows that
然后它知道主节点知道实际获取了锁

1541
00:53:06,630 --> 00:53:09,330
0,570 900,1590 1710,2190 2190,2430 2430,2700
the {} {primary -} knows

1542
00:53:09,330 --> 00:53:10,680
0,180 180,450 450,780 780,870 870,1350
that actually acquire the lock|
|

1543
00:53:10,830 --> 00:53:12,690
0,150 150,690 750,960 960,1590 1710,1860
and {in,that} {} case and
在这种情况下，我们将发回一条RDMA消息，

1544
00:53:12,690 --> 00:53:14,490
0,120 120,360 360,720 720,1440 1440,1800
we'll send one RDMA message

1545
00:53:14,490 --> 00:53:16,110
0,480 510,750 750,1080 1080,1470 1470,1620
back,| {} to append a
|要将消息附加到协调器消息队列，

1546
00:53:16,110 --> 00:53:18,600
0,480 480,900 900,1230 1290,2160 2160,2490
message to the coordinators message

1547
00:53:18,600 --> 00:53:19,860
0,300 300,630 630,1110
queue,| saying okay,
|说好了，您就成功地获得了这些特定对象的锁。

1548
00:53:21,280 --> 00:53:23,290
0,330 330,840 840,1260 1260,1770 1830,2010
you successfully acquired {locks -}

1549
00:53:23,290 --> 00:53:24,960
0,120 120,300 300,690 690,1230
for these particular objects.|
|

1550
00:53:26,060 --> 00:53:28,260
0,510 510,1140 1170,1890
If the transaction,
如果事务、如果锁已被另一个事务获取

1551
00:53:28,460 --> 00:53:30,320
0,630 630,1020 1020,1470 1470,1770 1770,1860
{} if the lock was

1552
00:53:30,320 --> 00:53:32,420
0,240 240,780 810,1080 1080,1380 1380,2100
already taken by another transaction|
|

1553
00:53:32,750 --> 00:53:34,160
0,300 300,630 630,750 750,930 930,1410
and then at that point
然后在那个时间点，

1554
00:53:34,160 --> 00:53:35,900
0,60 60,390 390,510 510,1050 1050,1740
in time,| the transaction is
|该事务被中止

1555
00:53:35,900 --> 00:53:38,150
0,420 600,990 990,1260 1260,1650 1920,2250
aborted| {} and so {}
|所以当初选我试图拿到锁的时候，

1556
00:53:38,150 --> 00:53:39,500
0,150 150,300 300,390 390,840 840,1350
so when the primary i

1557
00:53:39,650 --> 00:53:40,910
0,420 420,510 510,660 660,750 750,1260
tries to get the lock,|
|

1558
00:53:40,940 --> 00:53:41,870
0,330 330,450 450,540 540,630 630,930
finds out that the {lock,is}
发现锁已经设置好了，

1559
00:53:41,870 --> 00:53:43,850
0,300 300,780 930,1320 1320,1560 1560,1980
already set,| {} using {test,and}
|使用测试和设置指令，

1560
00:53:43,850 --> 00:53:46,340
0,180 180,840 930,1770 1800,2250 2250,2490
set instruction,| then, {} that
|然后是那个锁，所以Try锁将失败，

1561
00:53:46,340 --> 00:53:48,620
0,420 780,1290 1290,1590 1590,1710 1710,2280
lock, {so,the,try} lock will fail,|
|

1562
00:53:51,060 --> 00:53:54,810
0,750 780,1470 1500,2220 2700,3210 3210,3750
and {} the {} the
主节点将消息添加到协调器的队列中，

1563
00:53:55,020 --> 00:53:56,820
0,450 450,720 720,1020 1020,1440 1440,1800
primary will add a message

1564
00:53:56,820 --> 00:53:58,830
0,270 270,690 990,1440 1440,1650 1650,2010
to the queue of the

1565
00:53:58,890 --> 00:54:01,350
0,1170 1170,1320 1320,1470 1470,1680 1680,2460
{to,the} queue of the coordinator,|
|

1566
00:54:01,380 --> 00:54:02,610
0,300 300,540 540,990 990,1080 1080,1230
saying like I you know
就像我说的那样，你知道我拿不到锁

1567
00:54:02,610 --> 00:54:03,780
0,330 360,570 570,750 750,1110 1110,1170
I could not acquire the

1568
00:54:03,780 --> 00:54:05,850
0,570 750,1320 1320,1530 1530,1980 1980,2070
locks| and the coordinator in
|在这种情况下，协调器将中止事务。

1569
00:54:05,850 --> 00:54:07,350
0,180 180,450 450,630 630,1140 1140,1500
that case will abort {transactions

1570
00:54:07,350 --> 00:54:08,000
0,540
-}.|
|

1571
00:54:10,060 --> 00:54:11,560
0,270 270,570 570,750 750,1200
Any questions so far?|
到目前为止还有什么问题吗？|

1572
00:54:13,040 --> 00:54:14,360
0,510 510,660 660,1020 1050,1170 1170,1320
How are the are the
这些锁是如何通过动物园管理员获得的？

1573
00:54:14,360 --> 00:54:15,410
0,270 270,360 360,630 630,840 840,1050
locks {obtained -} through {zookeeper

1574
00:54:15,410 --> 00:54:16,320
0,630
-}?|
|

1575
00:54:16,600 --> 00:54:18,640
0,450 450,660 660,1680 1680,1830 1830,2040
No, these are the other
不，这是另一套使用ZooKeeper的锁

1576
00:54:18,640 --> 00:54:19,990
0,180 180,240 240,600 600,840 840,1350
set of locks using zookeeper,|
|

1577
00:54:19,990 --> 00:54:21,610
0,240 240,420 420,570 570,1140 1140,1620
that's really for configuration management,|
这实际上是为了进行配置管理，|

1578
00:54:21,610 --> 00:54:25,090
0,510 870,1620 1770,2430 2430,2790 2790,3480
like the mapping of {
与区域编号到主和备份的映射一样，

1579
00:54:25,610 --> 00:54:27,860
0,810 840,1170 1170,1440 1440,1860 1860,2250
-} region number to {}

1580
00:54:27,860 --> 00:54:29,420
0,540 540,780 780,930 930,1320 1320,1560
primary and {} {backups -},|
|

1581
00:54:29,480 --> 00:54:30,410
0,210 210,450 450,600 600,780 780,930
{} these are just in
这些只存在于主节点维护的内存锁定中，

1582
00:54:30,410 --> 00:54:33,530
0,360 360,900 990,1470 1470,1800 1800,3120
memory locks, {} that the

1583
00:54:33,560 --> 00:54:35,390
0,450 450,990 990,1320 1320,1470 1470,1830
primary maintains,| so in the
|所以在地址空间中，稍微向后一点，对吗，

1584
00:54:35,450 --> 00:54:37,190
0,450 450,870 870,1080 1080,1530 1530,1740
address space, a little bit

1585
00:54:37,220 --> 00:54:39,440
0,660 660,1110 1470,1740 1740,2040 2040,2220
back, correct,| {} little,bit back
|有点，稍微回到这张照片上，

1586
00:54:39,440 --> 00:54:40,880
0,60 60,210 210,870 1020,1290 1290,1440
at this picture,| {} there
|有一个区域有物体，

1587
00:54:40,880 --> 00:54:42,680
0,150 150,480 510,930 930,1110 1110,1800
was a region has objects,|
|

1588
00:54:42,710 --> 00:54:44,300
0,300 300,720 720,1140 1140,1290 1290,1590
every object has some data
每个对象都有一些数据和报头，

1589
00:54:44,300 --> 00:54:46,610
0,570 570,1080 1080,1650 1860,2040 2040,2310
and a header,| and {in,that}
|在那个标题中，

1590
00:54:46,610 --> 00:54:48,710
0,390 390,660 660,1320 1320,1440 1470,2100
header,| there's basically a 64
|基本上有一个64位的数字，顶层位是锁定位

1591
00:54:48,710 --> 00:54:50,510
0,180 180,780 1020,1320 1320,1620 1620,1800
bit number {} that were

1592
00:54:50,510 --> 00:54:51,770
0,210 210,300 300,450 450,780 780,1260
{top-level - -} bit is

1593
00:54:51,770 --> 00:54:53,930
0,180 180,450 450,810 810,1470 1560,2160
the lock bit| and 63
|以及版本号的其他63位。

1594
00:54:53,930 --> 00:54:55,310
0,210 210,450 450,690 690,1080 1080,1380
other bits for {the,version} number.|
|

1595
00:54:56,010 --> 00:54:57,870
0,240 240,600 600,810 810,1050 1050,1860
Oh, what if the primary
哦，如果初选失败怎么办，

1596
00:54:57,870 --> 00:54:59,070
0,300 300,600 600,720 720,810 810,1200
goes down,| does the backup
|备份服务器是否与主服务器具有相同的锁定。

1597
00:54:59,070 --> 00:54:59,970
0,150 150,240 240,510 510,840 840,900
have the same locks of

1598
00:54:59,970 --> 00:55:01,380
0,150 150,780 810,1110
the primary. {}|
|

1599
00:55:01,780 --> 00:55:03,160
0,210 210,420 420,780 780,990 990,1380
If the primary goes down,|
如果初选失败，|

1600
00:55:03,160 --> 00:55:05,500
0,90 90,840 840,1560 1680,2160 2160,2340
the whole, {} what's gonna
整个，接下来会发生的是，

1601
00:55:05,500 --> 00:55:06,640
0,330 330,690 690,900 900,1080 1080,1140
happen is that,| there's a
|在新的恢复协议中有一个完整的重新配置协议，

1602
00:55:06,640 --> 00:55:09,190
0,210 210,1080 1110,1620 1650,2010 2010,2550
whole reconfiguration protocol {} happening

1603
00:55:09,190 --> 00:55:11,360
0,510 540,960 960,1410 1410,1920
in new recovery protocol,|
|

1604
00:55:11,780 --> 00:55:12,830
0,300 300,480 480,690 690,960 960,1050
{} the end result of
其最终结果是，

1605
00:55:12,830 --> 00:55:13,820
0,270 270,480 480,720 720,810 810,990
that is that,| in this
|在这种情况下，我们，我们希望它实际上是在船上，对，

1606
00:55:13,820 --> 00:55:15,680
0,420 420,870 900,1260 1290,1440 1440,1860
case, the, we we hope

1607
00:55:15,680 --> 00:55:16,400
0,150 150,330 330,540 540,660 660,720
that it actually would be

1608
00:55:16,400 --> 00:55:17,990
0,480 480,750 750,1020 1020,1110 1110,1590
aboart, correct,| because it never
|因为它没能坚持到最后。

1609
00:55:18,050 --> 00:55:18,920
0,270 270,390 390,450 450,600 600,870
made it to the end.|
|

1610
00:55:19,720 --> 00:55:21,250
0,270 270,780 780,960 960,1080 1080,1530
{} We'll get to {fault,torlerance}
我们将在一小段时间内讨论故障扭转法，

1611
00:55:21,250 --> 00:55:22,240
0,360 360,390 390,630 630,900 900,990
in a little while,| so
|所以让我们[]来，

1612
00:55:22,240 --> 00:55:24,670
0,210 420,720 720,1170 1350,2130 2130,2430
let's [] for,| {} I'm
|我将在几块板子里谈到

1613
00:55:24,670 --> 00:55:25,540
0,210 210,390 390,600 600,780 780,870
going to talk about in

1614
00:55:25,540 --> 00:55:26,560
0,60 60,270 270,750 750,840 840,1020
a couple boards| and I'll
|我还会谈到过错侵权。

1615
00:55:26,560 --> 00:55:27,970
0,150 150,330 330,480 480,1020 1170,1410
talk about fault torlerance.| Thank
|谢谢。

1616
00:55:27,970 --> 00:55:28,480
0,180
you.|
|

1617
00:55:31,210 --> 00:55:33,340
0,480 480,930 930,1350 1350,1680 1680,2130
{} So the version numbers
所以版本号是每个对象的，对吧。

1618
00:55:33,340 --> 00:55:35,740
0,240 240,450 450,840 840,1230 1920,2400
are per object, right.| {Sure,per,object},
|当然，每件物品，是的。

1619
00:55:35,920 --> 00:55:37,020
0,810
yeah.|
|

1620
00:55:38,620 --> 00:55:39,580
0,630
{Okay,thank,you}.|
好的谢谢。|

1621
00:55:42,080 --> 00:55:43,180
0,420 420,780
Okay, good,
好的，很好，那么，好的。

1622
00:55:43,460 --> 00:55:45,220
0,660 810,1440
so, {}

1623
00:55:45,850 --> 00:55:48,670
0,330 330,510 510,720 720,1350 2280,2820
alright.| So my question,| why
|所以我的问题是，|为什么他们选择中止事务，而不是阻塞并等待锁被释放？

1624
00:55:48,670 --> 00:55:50,200
0,150 150,300 300,840 840,1080 1110,1530
do they choose to abort

1625
00:55:50,200 --> 00:55:51,760
0,60 60,660 660,900 900,1050 1050,1560
the transaction rather than blocking

1626
00:55:51,760 --> 00:55:52,780
0,180 180,510 510,660 660,780 780,1020
and waiting for the lock

1627
00:55:52,780 --> 00:55:53,900
0,120 120,270 270,900
to be released?|
|

1628
00:55:54,660 --> 00:55:55,860
0,330 330,570 570,690 690,840 840,1200
{} Because they have read
因为他们读过旧材料，

1629
00:55:55,860 --> 00:55:57,460
0,720 720,1230
old material,|
|

1630
00:55:57,920 --> 00:55:58,670
0,150 150,270 270,510 510,660 660,750
they have not read the
他们还没有读到最新的材料价值，

1631
00:55:58,670 --> 00:56:01,430
0,360 360,810 840,1710 1740,2280 2520,2760
latest material {} value,| and
|因此，交易必须中止。

1632
00:56:01,430 --> 00:56:03,080
0,300 300,990 990,1320 1320,1560 1560,1650
so the transaction has to

1633
00:56:03,080 --> 00:56:03,780
0,420
abort.|
|

1634
00:56:04,940 --> 00:56:05,930
0,150 150,270 270,570 570,870 870,990
Oh I see,| because the
哦，我明白了，|因为锁意味着下一次它会改变。

1635
00:56:05,930 --> 00:56:07,010
0,330 330,630 630,780 780,900 900,1080
lock means that it's gonna

1636
00:56:07,010 --> 00:56:09,290
0,720 990,1440 1440,1770 1800,2040 2040,2280
change next time.| Well, they
|嗯，他们在真正写完对象后才要求加锁，对吧，

1637
00:56:09,290 --> 00:56:11,300
0,510 510,660 660,1140 1140,1680 1680,2010
ask for locks after really

1638
00:56:11,300 --> 00:56:12,600
0,360 360,480 480,1050
written the object,

1639
00:56:12,880 --> 00:56:15,490
0,480 690,1110 1140,1530 1530,2070 2070,2610
right,| so the coordinator modifies
|因此协调器基于某个版本号修改对象，

1640
00:56:15,490 --> 00:56:16,480
0,90 90,510 510,780 780,870 870,990
the object based on some

1641
00:56:16,480 --> 00:56:18,670
0,300 300,810 1170,1620 1620,2100 2100,2190
version number,| {} submits a
|提交了一堆写的东西，

1642
00:56:18,670 --> 00:56:20,830
0,210 210,300 300,900 1170,1980 1980,2160
bunch of writes,| assuming that
|假设这是正确的，最新的版本号

1643
00:56:20,830 --> 00:56:23,170
0,120 120,840 840,1140 1140,1590 1950,2340
is {right,the,latest} version number| and
|因此，当提交开始发生时

1644
00:56:23,170 --> 00:56:25,030
0,150 150,270 270,360 360,1050 1050,1860
so by the time {}

1645
00:56:25,060 --> 00:56:28,390
0,1350 1620,2130 2160,2520 2520,2850 2850,3330
the the commit starts happening|
|

1646
00:56:28,390 --> 00:56:29,080
0,150 150,270 270,450 450,540 540,690
and you try to get
然后你试着把锁

1647
00:56:29,080 --> 00:56:30,700
0,90 90,660 900,1140 1140,1320 1320,1620
the locks| and you discover
|你发现另一个人被锁住了，

1648
00:56:30,700 --> 00:56:31,720
0,90 90,390 390,600 600,750 750,1020
that somebody else is locked,|
|

1649
00:56:31,720 --> 00:56:32,620
0,90 90,270 270,510 510,690 690,900
that means somebody else already
这意味着其他人已经在修改它了

1650
00:56:32,620 --> 00:56:34,660
0,510 510,690 990,1590 1590,1800 1800,2040
modifying it| and so that
|所以这会违反序列化，对吧。

1651
00:56:34,660 --> 00:56:36,610
0,150 150,600 600,720 720,1260 1530,1950
would violate {serialization -}, right.|
|

1652
00:56:37,820 --> 00:56:39,380
0,300 330,510 510,1020 1290,1470 1470,1560
Yep, thank you.| So, in
是的，谢谢你。|所以，事实上，你在这里得到锁的点，

1653
00:56:39,380 --> 00:56:40,370
0,330 330,480 480,780 780,870 870,990
fact the point you get

1654
00:56:40,370 --> 00:56:42,230
0,90 90,480 480,1050 1410,1740 1740,1860
the lock here,| that's sort
|这在某种程度上是写事务的串行化点。

1655
00:56:42,230 --> 00:56:43,580
0,90 90,180 180,930 930,1200 1200,1350
of the serialization point for

1656
00:56:43,580 --> 00:56:44,780
0,210 210,870
write transactions.|
|

1657
00:56:45,700 --> 00:56:47,440
0,150 150,720 720,1260 1320,1590 1590,1740
At this point, {} the
此时，事务已经获取了所有锁，

1658
00:56:47,440 --> 00:56:48,790
0,420 420,540 540,1020 1020,1230 1230,1350
transaction has acquired all the

1659
00:56:48,790 --> 00:56:50,110
0,420 420,660 660,810 810,900 900,1320
locks,| for all the objects
|对于所有对象被修改，

1660
00:56:50,110 --> 00:56:52,240
0,180 180,840 1050,1440 1440,1830 1830,2130
is modified,| so nobody else
|因此，在这个特定的时间点上，其他人都不能被修改，

1661
00:56:52,240 --> 00:56:53,770
0,120 120,390 390,840 870,1440 1440,1530
can actually be modified in

1662
00:56:53,770 --> 00:56:55,120
0,180 180,660 660,840 840,900 900,1350
this particular point of time,|
|

1663
00:56:55,300 --> 00:56:56,020
0,210 210,420 420,540 540,630 630,720
so that's sort of the
这在某种程度上是事务的写入部分的串行化点。

1664
00:56:56,020 --> 00:56:57,790
0,750 750,1110 1110,1410 1410,1560 1560,1770
serialization point for the write

1665
00:56:57,790 --> 00:56:58,940
0,210 210,300 300,390 390,870
part of the transaction.|
|

1666
00:57:02,180 --> 00:57:03,060
0,180 180,510
Make sense?|
讲得通?|

1667
00:57:04,480 --> 00:57:05,760
0,390 390,630 630,900
Yes, thank you.|
好的，谢谢。|

1668
00:57:07,060 --> 00:57:09,850
0,420 720,990 990,1170 1170,1800 2100,2790
Good okay, so now, {}
很好，那么现在，你可能会觉得，

1669
00:57:09,880 --> 00:57:10,780
0,150 150,300 300,390 390,690 690,900
you might have felt like,|
|

1670
00:57:10,780 --> 00:57:12,610
0,1110 1140,1410 1410,1590 1590,1710 1710,1830
{} why not do the
为什么不对Read做同样的事情，对吗，

1671
00:57:12,610 --> 00:57:14,440
0,240 240,540 540,870 870,1350 1380,1830
same thing for read, correct,|
|

1672
00:57:14,440 --> 00:57:15,430
0,270 270,450 450,600 600,690 690,990
and {you,know} get the lock
你知道，获取读取对象的锁，

1673
00:57:15,430 --> 00:57:17,260
0,120 120,210 210,600 600,1140 1140,1830
for the read objects, {}|
|

1674
00:57:17,260 --> 00:57:18,160
0,210 210,270 270,510 510,750 750,900
get the lock from the
从读取的对象中获取锁，

1675
00:57:18,160 --> 00:57:19,540
0,420 420,660 660,1050 1050,1170 1170,1380
objects that read,| {you,know} check
|你知道的，检查一下你知道的版本号，你知道的很好。

1676
00:57:19,540 --> 00:57:20,530
0,60 60,330 330,600 600,810 810,990
the version number in {you,know}

1677
00:57:20,530 --> 00:57:21,500
0,60 60,210 210,690
in good [shape].|
|

1678
00:57:21,860 --> 00:57:24,380
0,810 870,1020 1020,1620 1620,2160 2190,2520
And the reason that that
原因是这实际上是一个独立的阶段，

1679
00:57:24,380 --> 00:57:25,700
0,90 90,420 420,510 510,900 900,1320
is actually a separate phase,|
|

1680
00:57:25,700 --> 00:57:28,100
0,300 300,390 390,900 900,1410 1830,2400
namely the validation phase is
即验证阶段基本上是为了避免这些昂贵的写RDMA，对吧，

1681
00:57:28,100 --> 00:57:30,470
0,540 540,900 900,1380 1380,1560 1560,2370
to basically avoid these expensive

1682
00:57:30,470 --> 00:57:32,420
0,270 270,720 720,930 960,1530 1800,1950
write {RDMAs -}, right,| if
|如果你看这个垂直的台阶，

1683
00:57:32,420 --> 00:57:33,320
0,120 120,270 270,360 360,510 510,900
you look at this vertical

1684
00:57:33,320 --> 00:57:34,400
0,390 390,540 540,720 720,960 960,1080
step,| you'll see there's a
|您将看到有一个写入RDMA，

1685
00:57:34,400 --> 00:57:36,260
0,210 210,810 990,1200 1200,1530 1530,1860
write RDMA,| the server has
|服务器必须运行一些东西，基本上是获取锁

1686
00:57:36,260 --> 00:57:38,480
0,210 240,600 600,1140 1170,1860 1860,2220
to run something, basically does

1687
00:57:38,480 --> 00:57:40,730
0,570 570,1110 1110,1200 1200,1710 2100,2250
{} acquiring the locks| and
|然后用另一个写RDMA进行响应。

1688
00:57:40,730 --> 00:57:42,110
0,210 210,630 630,780 780,1140 1140,1380
then responds with another write

1689
00:57:42,110 --> 00:57:43,610
0,450 450,570 570,1050 1050,1410 1410,1500
RDMA.| So here this is
|所以这是一个完整的RPC，

1690
00:57:43,610 --> 00:57:45,120
0,120 120,510 510,1230
a full RPC,|
|

1691
00:57:46,480 --> 00:57:48,610
0,240 240,450 450,1050 1050,1350 1350,2130
that actually requires server participation|
这实际上需要服务器的参与|

1692
00:57:49,360 --> 00:57:50,230
0,270 270,420 420,540 540,780 780,870
and as we'll see in
正如我们稍后将看到的，

1693
00:57:50,230 --> 00:57:52,630
0,30 30,510 750,1170 1170,1770 2190,2400
a second in the,| to
|为了处理对象已被读取的读取，

1694
00:57:52,630 --> 00:57:54,520
0,510 510,810 810,1290 1410,1620 1620,1890
handle the read the objects

1695
00:57:54,520 --> 00:57:57,190
0,180 180,390 390,780 1050,1830 1890,2670
have been read,| {} the
|农场使用该验证步骤，

1696
00:57:57,250 --> 00:57:59,410
0,300 510,900 1050,1770 1770,2010 2010,2160
the the FaRM uses this

1697
00:57:59,410 --> 00:58:00,820
0,480 480,750 750,840 840,930 930,1410
validation step,| in the validation
|在验证步骤中，仅使用了单边RDMA

1698
00:58:00,820 --> 00:58:02,920
0,390 420,780 780,1110 1110,1650 1650,2100
step, just used one-sided {RDMAs

1699
00:58:02,920 --> 00:58:04,690
0,390 540,810 810,930 930,1170 1170,1770
-}| and so there's no
|因此，不需要真正的服务器参与。

1700
00:58:04,690 --> 00:58:06,480
0,270 270,630 630,1080 1080,1650
real server involvement necessary.|
|

1701
00:58:12,080 --> 00:58:12,920
0,570
Okay?|
好吧?|

1702
00:58:13,900 --> 00:58:15,760
0,510 510,1140 1170,1410 1410,1680 1680,1860
So, {} what happens on
所以，发生了什么事，

1703
00:58:15,760 --> 00:58:17,020
0,300 300,540 600,1050 1050,1110 1110,1260
the,| so basically at this
|所以基本上在这一点上，这里的[]，

1704
00:58:17,020 --> 00:58:19,150
0,450 450,900 930,1410 1410,1590 1590,2130
point, the [] over here,|
|

1705
00:58:19,150 --> 00:58:20,920
0,90 90,510 510,1080 1080,1350 1350,1770
the transaction coordinator actually has
事务协调器实际上具有写锁定

1706
00:58:20,920 --> 00:58:23,200
0,420 750,1140 1140,1740 1950,2130 2130,2280
the write locks| and now
|而现在它唯一能做的就是，

1707
00:58:23,200 --> 00:58:24,010
0,90 90,330 330,450 450,540 540,810
the only thing it does

1708
00:58:24,010 --> 00:58:25,510
0,60 60,360 360,1080 1080,1290 1290,1500
is,| it validates the read
|它验证读锁定或基本上读版本号。

1709
00:58:25,510 --> 00:58:27,280
0,510 510,660 660,1050 1050,1470 1470,1770
locks or basically read version

1710
00:58:27,280 --> 00:58:27,980
0,540
numbers.|
|

1711
00:58:28,480 --> 00:58:30,730
0,390 390,960 1020,1470 1530,2010 2040,2250
And so it {} for
因此，对于每个已读取但未修改的对象，

1712
00:58:30,730 --> 00:58:32,140
0,540 540,900 900,1020 1020,1140 1140,1410
every object that is read

1713
00:58:32,140 --> 00:58:33,460
0,120 120,330 330,930 990,1200 1200,1320
but not modified,| so in
|因此，在我们的特定示例中，

1714
00:58:33,460 --> 00:58:34,840
0,270 270,600 600,960 960,1170 1170,1380
our particular example,| that's only
|那只是一个物体，

1715
00:58:34,840 --> 00:58:35,980
0,240 240,870 870,990 990,1050 1050,1140
one object,| this is the
|这就是真正被阅读的那个，

1716
00:58:35,980 --> 00:58:37,240
0,210 210,360 360,690 690,900 900,1260
one that actually being read,|
|

1717
00:58:37,880 --> 00:58:38,800
0,630
{the,one}
第三区的那个，

1718
00:58:39,580 --> 00:58:42,010
0,330 330,630 630,1110 1440,2010 2010,2430
at region 3,| {} so
|所以它基本上是单边的RDMA，

1719
00:58:42,010 --> 00:58:43,510
0,480 480,990 990,1080 1080,1440 1440,1500
it's, {} it basically is

1720
00:58:43,510 --> 00:58:45,880
0,120 120,870 870,1590 1620,1800 1800,2370
{} one-sided RDMA,| to read
|要读取版本号，正在读取的是对象的64位编号。

1721
00:58:45,940 --> 00:58:47,500
0,210 210,570 570,870 870,1050 1050,1560
the version number that's 64

1722
00:58:47,500 --> 00:58:49,960
0,360 390,1290 1560,2040 2040,2100 2100,2460
bit number for the object

1723
00:58:49,960 --> 00:58:50,860
0,90 90,270 270,660
is being read.|
|

1724
00:58:51,770 --> 00:58:53,180
0,300 300,480 480,570 570,780 780,1410
And when it gets back,
当它回来的时候，当它回来的时候，

1725
00:58:53,570 --> 00:58:54,920
0,510 510,750 750,810 810,1020 1020,1350
{} when it gets back

1726
00:58:54,920 --> 00:58:56,660
0,480 780,990 990,1320 1320,1560 1560,1740
here,| {} it checks two
|它检查两件事，

1727
00:58:56,660 --> 00:58:57,440
0,540
things,|
|

1728
00:58:57,660 --> 00:58:59,310
0,690 990,1170 1170,1290 1290,1530 1530,1650
{} if the lock is
如果锁定被获取，则锁定位设置，

1729
00:58:59,310 --> 00:59:00,720
0,540 720,780 780,990 990,1230 1230,1410
taken, so the lock bit

1730
00:59:00,720 --> 00:59:02,100
0,480 540,750 750,1080 1080,1200 1200,1380
set,| that means that some
|这意味着一些协调器并发事务正在被，正在试图修改，

1731
00:59:02,100 --> 00:59:04,500
0,600 600,1170 1170,1500 1500,2070 2070,2400
{coordinator -} concurrent transactions {is,being},

1732
00:59:04,500 --> 00:59:05,790
0,330 330,570 570,660 660,1080 1080,1290
is trying to {modified -},|
|

1733
00:59:06,090 --> 00:59:07,710
0,240 240,450 450,840 840,1080 1080,1620
so that point just abort.|
所以这一点就放弃了。|

1734
00:59:08,260 --> 00:59:09,670
0,690 690,960 960,1080 1080,1170 1170,1410
{} And so the old
因此，旧的事务再次中止。

1735
00:59:09,670 --> 00:59:10,920
0,390 390,630 630,870
transaction abort again.|
|

1736
00:59:11,540 --> 00:59:12,770
0,570 570,690 690,930 930,1170 1170,1230
If the first number is
如果第一个数字相同且未锁定，

1737
00:59:12,770 --> 00:59:15,710
0,720 1140,1800 1830,2100 2100,2460 2460,2940
identical and it's not locked,|
|

1738
00:59:15,830 --> 00:59:17,090
0,270 270,570 570,750 750,1080 1080,1260
that means that no other
这意味着在此特定时间点没有使用其他事务

1739
00:59:17,090 --> 00:59:18,620
0,600 600,930 930,1080 1080,1230 1230,1530
transactions using at this particular

1740
00:59:18,620 --> 00:59:20,930
0,180 180,240 240,750 990,1740 1860,2310
point of time| and {}
|交易可以继续进行，

1741
00:59:20,930 --> 00:59:23,960
0,780 990,1770 1800,2370 2370,2520 2520,3030
the {} transaction could proceed,|
|

1742
00:59:23,990 --> 00:59:26,030
0,810 840,1230 1230,1350 1350,1860 1860,2040
basically all the objects that
基本上所有正在被读取和修改的对象，

1743
00:59:26,030 --> 00:59:27,260
0,60 60,330 330,510 510,600 600,1230
are being read and modified,|
|

1744
00:59:27,560 --> 00:59:28,940
0,360 360,420 420,750 750,1230 1230,1380
have the version number at
在交易开始时具有版本号，

1745
00:59:28,940 --> 00:59:30,360
0,60 60,300 300,390 390,1290
the start of transaction,|
|

1746
00:59:30,650 --> 00:59:32,210
0,450 450,780 780,1050 1050,1230 1230,1560
{} and nothing has changed
一切都还没有改变

1747
00:59:32,210 --> 00:59:33,590
0,420 570,720 720,1050 1050,1290 1290,1380
yet| and so it is
|因此，事务提交是可以的，

1748
00:59:33,590 --> 00:59:34,790
0,450 450,630 630,690 690,1140 1140,1200
okay for the transaction to

1749
00:59:34,790 --> 00:59:36,710
0,360 420,630 630,1170 1170,1530 1530,1920
commit,| is really the true
|才是真正的序列化点。

1750
00:59:36,710 --> 00:59:38,000
0,630 630,1020
serialization point.|
|

1751
00:59:38,600 --> 00:59:39,590
0,180 180,540 540,660 660,780 780,990
And since you know the
而且由于您知道交易编号在开始时需要版本号，

1752
00:59:39,590 --> 00:59:41,390
0,720 720,1020 1020,1140 1140,1680 1680,1800
transactions numbers are required at

1753
00:59:41,390 --> 00:59:42,710
0,60 60,420 420,570 570,810 810,1320
the beginning with version number,|
|

1754
00:59:42,710 --> 00:59:43,490
0,240 240,300 300,570 570,690 690,780
{right,at} the beginning of the
就在交易开始时，

1755
00:59:43,490 --> 00:59:45,890
0,660 900,1620 1620,1740 1740,2130 2130,2400
transaction,| you know {the,transaction -}
|您知道事务将基本上按照版本号的顺序提交，

1756
00:59:45,890 --> 00:59:47,360
0,150 150,660 840,1050 1050,1110 1110,1470
will commit in the order

1757
00:59:47,360 --> 00:59:48,710
0,60 60,150 150,480 480,720 720,1350
of the version numbers basically,|
|

1758
00:59:48,890 --> 00:59:51,410
0,690 810,1410 1410,2130 2130,2370 2370,2520
and {} they also would
而且它们还将获得基本上严格的可序列化，

1759
00:59:51,410 --> 00:59:53,510
0,120 120,420 420,1020 1080,1560 1560,2100
get basically strict {serializability -},|
|

1760
00:59:54,540 --> 00:59:56,160
0,330 330,510 510,1140 1290,1500 1500,1620
because any transaction that will
因为在事务提交后启动的任何事务都将具有更高的版本号，

1761
00:59:56,160 --> 00:59:58,350
0,480 480,1080 1110,1350 1350,1770 1770,2190
start after your transaction commits,

1762
00:59:58,350 --> 00:59:59,760
0,150 150,360 360,630 630,900 900,1410
will have higher version number,|
|

1763
00:59:59,790 --> 01:00:00,930
0,180 180,540 540,750 750,870 870,1140
so therefore {it,also} will commit
因此，它也会在以后承诺。

1764
01:00:00,930 --> 01:00:01,540
0,300
later.|
|

1765
01:00:04,710 --> 01:00:06,060
0,330 330,480 480,660 660,810 810,1350
Okay, so this is the
好的，这就是交易协调人说，

1766
01:00:06,390 --> 01:00:08,490
0,660 660,1020 1020,1140 1140,1830 1860,2100
point basically {} where {}

1767
01:00:08,490 --> 01:00:11,430
0,390 390,960 960,1470 1770,2610 2700,2940
transaction coordinator says,| {} {you,know}
|你知道在这一点上你知道，

1768
01:00:11,430 --> 01:00:12,480
0,120 120,270 270,780 810,900 900,1050
at this point you know

1769
01:00:12,480 --> 01:00:13,560
0,420
the,|
|

1770
01:00:14,230 --> 01:00:15,460
0,450 450,660 660,870 870,1050 1050,1230
{} we know that all
我们知道所有我们必须做的事，我们已经得到了锁，

1771
01:00:15,460 --> 01:00:16,570
0,450 450,600 600,720 720,990 990,1110
the we have to, we

1772
01:00:16,570 --> 01:00:17,890
0,120 120,480 480,570 570,1080 1080,1320
have acquired the locks,| we
|我们已验证以验证读取对象的版本号

1773
01:00:17,890 --> 01:00:19,810
0,300 300,870 870,930 930,1500 1500,1920
have verified to validate the

1774
01:00:19,870 --> 01:00:21,580
0,450 450,720 720,870 870,1500 1500,1710
version numbers for the read

1775
01:00:21,580 --> 01:00:22,570
0,390 390,510 510,660 660,870 870,990
objects| and so this is
|因此，这基本上是提交点或提交点的开始，

1776
01:00:22,570 --> 01:00:24,180
0,480 480,570 570,840 840,1080
basically the commit point

1777
01:00:26,000 --> 01:00:26,690
0,150 150,240 240,540 540,600 600,690
or the start of the

1778
01:00:26,690 --> 01:00:28,310
0,270 270,480 480,840 900,1170 1170,1620
commit point,| so this point
|所以这一点实际上是在说，

1779
01:00:28,340 --> 01:00:29,180
0,210 210,330 330,630 630,780 780,840
that is actually going to

1780
01:00:29,180 --> 01:00:30,650
0,480 750,960 960,1170 1170,1320 1320,1470
say,| {} okay, I'm gonna
|好了，我要走了，我要去承诺了。

1781
01:00:30,650 --> 01:00:31,700
0,330 330,480 480,720 720,870 870,1050
go, {} I'm gonna go

1782
01:00:31,700 --> 01:00:32,480
0,510
commit.|
|

1783
01:00:34,120 --> 01:00:35,290
0,420 420,540 540,690 690,900 900,1170
And you know there's a
您知道提交点需要多条消息，

1784
01:00:35,290 --> 01:00:37,900
0,840 930,1500 1500,2280 2280,2340 2340,2610
multiple messages necessary to commit

1785
01:00:37,900 --> 01:00:39,370
0,300 300,540 540,810 810,1200 1200,1470
point,| we'll {see,in,a} second| and
|我们一会儿就会看到|而这些主要是出于容错的原因。

1786
01:00:39,400 --> 01:00:40,750
0,360 360,450 450,960 960,1140 1140,1350
those are mostly for fault

1787
01:00:40,750 --> 01:00:41,860
0,900
{tolerance,reasons}.|
|

1788
01:00:42,480 --> 01:00:43,760
0,810

1789
01:00:44,400 --> 01:00:45,930
0,420 420,720 720,1050 1080,1320 1320,1530
And so at this point,|
所以在这一点上，|

1790
01:00:45,930 --> 01:00:48,120
0,540 540,570 570,1380 1380,1500 1500,2190
namely {} only the primary
即仅主对象已被，仅主对象已被联系正被修改的对象，

1791
01:00:48,360 --> 01:00:50,610
0,420 420,900 930,1320 1620,2100 2100,2250
has been the, only the

1792
01:00:50,610 --> 01:00:53,220
0,750 780,1050 1050,1230 1230,2010 2190,2610
primaries have been contacted of

1793
01:00:53,220 --> 01:00:55,890
0,660 1110,1890 2190,2340 2340,2400 2400,2670
the {} of the objects

1794
01:00:55,890 --> 01:00:56,850
0,120 120,180 180,330 330,840 840,960
that are being modified,| but
|但不包括备份。

1795
01:00:56,850 --> 01:00:57,900
0,210 210,270 270,480 480,900
not the {backups -}.|
|

1796
01:00:58,120 --> 01:00:59,080
0,180 180,240 240,540 540,810 810,960
And of course we want
当然，我们想要确保这一点，并写下，

1797
01:00:59,080 --> 01:01:00,640
0,60 60,510 510,810 810,1350 1350,1560
to ensure that {} and

1798
01:01:00,670 --> 01:01:02,020
0,510 510,600 600,840 870,1260 1260,1350
write,| you know once you
|你知道一旦你做出承诺就能挺过失败，对吧，

1799
01:01:02,020 --> 01:01:04,930
0,480 750,1290 1290,1560 1560,2310 2340,2910
commit {} will survive f

1800
01:01:04,930 --> 01:01:06,490
0,450 480,750 750,1020 1020,1140 1140,1560
failures, right,| system is designed
|系统设计为f+1个故障，

1801
01:01:06,490 --> 01:01:09,640
0,1230 1230,1470 1530,1770 1770,2310 2970,3150
to {f+1 -} failures,| in
|在我们的特殊设计中，有一个备份

1802
01:01:09,640 --> 01:01:11,920
0,150 150,540 540,1200 1230,1770 1770,2280
our particular designs, there's {}

1803
01:01:12,310 --> 01:01:13,810
0,450 450,1020 1020,1200 1200,1410 1410,1500
one backup| and so it
|因此它只能在一次失败中幸存下来。

1804
01:01:13,810 --> 01:01:15,430
0,120 120,540 540,960 960,1200 1200,1620
can only survive one failure.|
|

1805
01:01:16,930 --> 01:01:17,920
0,240 240,390 390,570 570,900 900,990
And so what happens is
所以发生的是最后一个阶段，

1806
01:01:17,920 --> 01:01:19,720
0,330 330,840 1020,1470 1470,1710 1710,1800
this {} final phase, {}|
|

1807
01:01:19,720 --> 01:01:21,370
0,270 270,540 540,1020 1080,1290 1290,1650
commit backup phase is actually
提交备份阶段实际上是我们要写入主备份的日志，

1808
01:01:21,370 --> 01:01:23,350
0,120 120,240 240,390 390,930 1200,1980
we're going to write to

1809
01:01:23,560 --> 01:01:25,750
0,540 720,1440 1440,1590 1590,1740 1740,2190
the logs of the primary

1810
01:01:25,780 --> 01:01:27,880
0,150 150,210 210,870 870,1290 1950,2100
of the backups,| so the
|所以备份有日志，

1811
01:01:27,880 --> 01:01:29,660
0,450 450,750 780,1560
backups have log,|
|

1812
01:01:30,210 --> 01:01:31,710
0,150 150,450 450,690 690,810 810,1500
so here's {backup -} i,|
所以这是备份I，|

1813
01:01:31,770 --> 01:01:32,670
0,120 120,240 240,660 660,840 840,900
you know similar there's a
你知道，类似的，里面有一个日志条目

1814
01:01:32,670 --> 01:01:35,040
0,300 300,630 630,750 750,990 1620,2370
log entry in it| and
|我们要做的是写下所谓的提交备份记录，

1815
01:01:35,340 --> 01:01:37,680
0,660 1230,1530 1530,1620 1620,1830 1830,2340
{} what we're gonna do

1816
01:01:37,710 --> 01:01:40,170
0,810 960,1470 1500,1950 1950,2220 2220,2460
is write {} what's called

1817
01:01:40,170 --> 01:01:41,980
0,120 120,510 510,900 900,1350
{} commit backup record,|
|

1818
01:01:42,980 --> 01:01:43,560
0,60

1819
01:01:50,500 --> 01:01:51,700
0,270 270,390 390,900 900,1110 1110,1200
and the commit {backup -}
并且提交备份记录与我们前面看到的锁定记录完全相同的信息，

1820
01:01:51,700 --> 01:01:53,200
0,540 540,960 960,1110 1110,1170 1170,1500
record exactly as the same

1821
01:01:53,200 --> 01:01:56,650
0,600 600,1440 1770,2160 2160,3060 3090,3450
information as the locking record

1822
01:01:56,650 --> 01:01:57,880
0,120 120,210 210,420 420,870 870,1230
that we saw earlier,| so
|因此，它将包含版本号、OID和新值。

1823
01:01:57,940 --> 01:01:58,990
0,240 240,540 750,870 870,990 990,1050
in it is going to

1824
01:01:58,990 --> 01:02:00,550
0,120 120,180 180,540 540,1170 1410,1560
be the version number, the

1825
01:02:00,550 --> 01:02:03,880
0,900 1230,2070 2130,2550 2550,3120 3150,3330
oid and {} the new

1826
01:02:03,880 --> 01:02:04,520
0,420
value.|
|

1827
01:02:07,870 --> 01:02:11,290
0,780 1710,2400 2490,2760 2760,2940 2940,3420
Okay, and this is {you,know}
好的，这是你知道的，就像在使用写RDMA完成这项工作之前，

1828
01:02:11,290 --> 01:02:12,670
0,240 240,870 900,1050 1050,1140 1140,1380
like before this is actually

1829
01:02:12,670 --> 01:02:16,030
0,390 390,930 1320,1710 1710,2250 2610,3360
done using a write RDMA,|
|

1830
01:02:21,190 --> 01:02:22,360
0,270 270,360 360,750 750,990 990,1170
now the backup doesn't really
现在，备份在这一点上并不需要执行任何操作，

1831
01:02:22,360 --> 01:02:24,160
0,150 150,240 240,390 390,870 900,1800
have to do any operation

1832
01:02:24,160 --> 01:02:25,240
0,450 450,600 600,900 900,1020 1020,1080
at this point,| like the
|就像备份的服务器端实际上不需要运行任何东西一样，

1833
01:02:25,240 --> 01:02:26,260
0,360 360,600 600,660 660,750 750,1020
server side of the backup

1834
01:02:26,260 --> 01:02:27,190
0,240 240,420 420,570 570,690 690,930
doesn't really have to run

1835
01:02:27,190 --> 01:02:29,590
0,540 630,960 960,1200 1200,1530 1560,2400
anything,| {} just need {}
|只是需要，所以这就是这个诀窍，

1836
01:02:29,590 --> 01:02:31,630
0,510 690,870 870,1050 1050,1350 1590,2040
and and so the the

1837
01:02:31,660 --> 01:02:33,730
0,270 270,450 450,960 1050,1530 1530,2070
here's this trick,| {} where
|其中基本上是中心[]和对NIC的确认。

1838
01:02:33,760 --> 01:02:34,990
0,450 450,540 540,840 840,1080 1080,1230
basically the center [] and

1839
01:02:34,990 --> 01:02:36,340
0,600 600,690 690,780 780,1170
acknowledgement of the NIC.|
|

1840
01:02:36,800 --> 01:02:38,900
0,240 240,720 810,1410 1740,1920 1920,2100
And so this you know
所以你知道这不是单方面的，也不是写RDMA的，

1841
01:02:38,900 --> 01:02:40,610
0,630 630,750 750,960 960,1050 1050,1710
this is not {} one-sided

1842
01:02:40,850 --> 01:02:43,070
0,570 600,990 990,1710 1830,2130 2130,2220
or write RDMA,| this is
|这只是确认它已获得写入RDMA

1843
01:02:43,070 --> 01:02:44,600
0,240 240,510 510,1200 1200,1380 1380,1530
just make acknowledging that it

1844
01:02:44,600 --> 01:02:46,070
0,330 330,450 450,720 720,1350 1350,1470
got the write RDMA| and
|并且已经执行了写入RDMA。

1845
01:02:46,070 --> 01:02:47,300
0,210 210,450 450,930 930,1080 1080,1230
the write RDMA has been

1846
01:02:47,300 --> 01:02:48,040
0,570
performed.|
|

1847
01:02:48,380 --> 01:02:49,910
0,150 150,240 240,450 450,750 750,1530
And so that basically acknowledges
因此，这基本上是在确认，当我们在协议中获得这一特定点时，

1848
01:02:49,910 --> 01:02:50,720
0,120 120,210 210,420 420,510 510,810
you know when we get

1849
01:02:50,810 --> 01:02:51,920
0,330 330,690 690,960 960,1020 1020,1110
this particular point in the

1850
01:02:51,920 --> 01:02:54,710
0,750 960,1140 1140,1710 1710,2190 2190,2790
protocol,| the transaction coordinator knows
|事务协调器知道该对象在所有主数据库的日志中

1851
01:02:54,860 --> 01:02:57,380
0,690 1350,2010 2040,2310 2310,2400 2400,2520
the object is in the

1852
01:02:57,380 --> 01:02:58,790
0,330 330,450 450,570 570,660 660,1410
log of all the primaries|
|

1853
01:02:59,150 --> 01:03:00,770
0,330 330,690 690,1020 1050,1470 1470,1620
and objects in {} in
以及所有备份日志中的对象。

1854
01:03:00,770 --> 01:03:01,310
0,60 60,270 270,360 360,450 450,540
the log of all the

1855
01:03:01,310 --> 01:03:02,120
0,660
backups.|
|

1856
01:03:02,420 --> 01:03:03,290
0,180 180,360 360,630 630,810 810,870
And so now we're in
所以现在我们在容错性方面处于有利地位，对吗，

1857
01:03:03,290 --> 01:03:04,250
0,60 60,240 240,660 660,750 750,960
{} good position in {terms,of}

1858
01:03:04,250 --> 01:03:06,170
0,90 90,300 300,780 780,1140 1140,1920
of fault tolerance, correct,| because
|因为如果两者中的任何一个失败了，

1859
01:03:06,380 --> 01:03:08,300
0,750 840,1050 1050,1590 1620,1830 1830,1920
{} if any one of

1860
01:03:08,300 --> 01:03:09,710
0,90 90,270 270,870 960,1230 1230,1410
the two fails,| the other
|另一个可以实际应用写操作。

1861
01:03:09,710 --> 01:03:10,910
0,390 390,510 510,780 780,1110 1110,1200
one can actually apply the

1862
01:03:10,910 --> 01:03:12,180
0,300 300,810
write operation.|
|

1863
01:03:13,870 --> 01:03:17,230
0,240 240,600 630,960 960,1560 2610,3360
Then there's one more step
然后还有一个步骤需要执行，

1864
01:03:17,230 --> 01:03:18,670
0,360 360,570 570,660 660,780 780,1440
that needs to be performed,|
|

1865
01:03:18,940 --> 01:03:21,340
0,150 150,360 360,480 480,1500 1770,2400
and that is to commit
那就是进行初选，

1866
01:03:21,340 --> 01:03:22,480
0,540 570,780 780,930 930,1110 1110,1140
primary,| I'll talk about a
|稍后我会更详细地谈到，

1867
01:03:22,480 --> 01:03:23,590
0,180 180,360 360,660 660,960 960,1110
little bit later in more

1868
01:03:23,590 --> 01:03:26,320
0,600 810,1590 2070,2310 2310,2430 2430,2730
detail,| but this is the
|但这是最后一步，

1869
01:03:26,320 --> 01:03:28,330
0,330 330,630 630,1320 1470,1830 1830,2010
final step,| where {} there's
|在多写一条日志记录的地方，

1870
01:03:28,330 --> 01:03:30,010
0,210 210,720 750,1050 1050,1350 1350,1680
one more log record written,|
|

1871
01:03:30,010 --> 01:03:32,470
0,1230 1230,1620 1620,1860 1860,2160 2160,2460
the primary namely {} commit
主要即提交记录，

1872
01:03:32,470 --> 01:03:36,020
0,420
record,|
|

1873
01:03:38,620 --> 01:03:39,490
0,150 150,210 210,450 450,750 750,870
and the commit record is
提交记录是[评估]，是实际正在提交的事务ID。

1874
01:03:39,490 --> 01:03:41,740
0,570 570,840 840,1110 1110,1680 1920,2250
[assessment], is transaction id, that

1875
01:03:41,740 --> 01:03:43,220
0,300 300,420 420,630 630,1170
actually is being committed.|
|

1876
01:03:44,390 --> 01:03:46,220
0,630 780,960 960,1170 1170,1560 1560,1830
{} So like every, {}|
所以就像每个人一样，|

1877
01:03:46,220 --> 01:03:47,210
0,150 150,390 390,600 600,720 720,990
I didn't write that down
我没有把它写在其他记录里，

1878
01:03:47,210 --> 01:03:48,260
0,90 90,180 180,450 450,870 870,1050
in the other records,| but
|但是每个记录都有一个交易ID，

1879
01:03:48,260 --> 01:03:49,490
0,300 300,570 570,750 750,810 810,1230
every record has a transaction

1880
01:03:49,490 --> 01:03:50,420
0,240 240,360 360,540 540,690 690,930
id,| so we know which
|这样我们就知道我们谈论的是哪一笔交易。

1881
01:03:50,420 --> 01:03:51,960
0,480 480,600 600,960 960,1290
transaction we're talking about.|
|

1882
01:03:53,380 --> 01:03:55,780
0,630 660,1350 1500,1860 1860,2070 2070,2400
And, {} again this {}
同样，这也使用了相同的策略，

1883
01:03:55,870 --> 01:03:57,910
0,360 360,480 480,1110 1110,1830 1830,2040
use the same strategy,| there's
|有一个写入RDMA要附加到日志、日志和日志

1884
01:03:57,910 --> 01:03:59,680
0,360 360,660 660,1320
a write RDMA

1885
01:04:00,750 --> 01:04:01,980
0,390 390,840
to appends,

1886
01:04:05,350 --> 01:04:07,750
0,210 210,690 690,1470 1500,2370 2370,2400
to the, { - -}

1887
01:04:07,750 --> 01:04:09,580
0,180 180,270 270,840 1140,1710 1710,1830
to the log| and you
|您知道有一个确认，NIC确认写入RDMA，

1888
01:04:09,580 --> 01:04:11,020
0,150 150,420 420,510 510,1170 1170,1440
know there's an acknowledgement, the

1889
01:04:11,020 --> 01:04:15,310
0,390 420,1350 1650,2310 2310,3810 3840,4290
NIC acknowledges {} the write

1890
01:04:15,340 --> 01:04:16,870
0,420 420,900 930,1230 1230,1380 1380,1530
{RDMA -},| and so but
|所以，但它不需要任何中断

1891
01:04:16,870 --> 01:04:18,700
0,60 60,360 360,900 900,1200 1200,1830
it doesn't require any interrupts|
|

1892
01:04:19,030 --> 01:04:20,830
0,330 330,540 540,960 990,1410 1410,1800
or there's no server itself
或者没有服务器本身不受干扰，

1893
01:04:20,830 --> 01:04:22,540
0,90 90,330 330,750 750,1350 1350,1710
is not being interfered with,|
|

1894
01:04:22,630 --> 01:04:23,890
0,390 390,660 660,690 690,1050 1080,1260
{} just {} NIC is
只有NIC参与了这两项操作。

1895
01:04:23,890 --> 01:04:25,510
0,390 390,450 450,660 660,810 810,1620
involved in these two operations.|
|

1896
01:04:26,800 --> 01:04:28,380
0,630 630,690 690,960 960,1350
Then as soon as,
然后，一旦其中一个NIC确认其中一个主服务器上的提交记录，

1897
01:04:28,730 --> 01:04:30,620
0,270 270,540 540,690 690,1170 1200,1890
{} one of the NICs

1898
01:04:30,710 --> 01:04:32,870
0,510 510,660 660,1230 1230,1650 1650,2160
{} {acknowledges -} the commit

1899
01:04:33,050 --> 01:04:34,220
0,510 510,810 810,960 960,1050 1050,1170
record on one of the

1900
01:04:34,220 --> 01:04:35,960
0,690 780,1020 1020,1230 1230,1560 1560,1740
primaries,| at that particular point
|在那个特定的时间点，

1901
01:04:35,960 --> 01:04:37,310
0,90 90,660 750,960 960,1080 1080,1350
of time,| which is actually
|它实际上是真正承诺的，

1902
01:04:37,310 --> 01:04:38,760
0,270 270,720 720,1200
really truly committed,|
|

1903
01:04:39,000 --> 01:04:39,960
0,150 150,330 330,420 420,690 720,960
so this is the true
所以这才是真正的提交点。

1904
01:04:39,960 --> 01:04:41,100
0,270 270,690
commit point.|
|

1905
01:04:43,820 --> 01:04:45,350
0,180 180,510 510,870 870,1230 1230,1530
The commit starts basically here|
提交基本上从这里开始|

1906
01:04:45,350 --> 01:04:46,070
0,90 90,210 210,330 330,600 600,720
and this is actually the
这实际上是实际的提交点，

1907
01:04:46,070 --> 01:04:47,720
0,330 330,600 600,1020 1290,1470 1470,1650
actual commit point,| at that
|在该特定时间点，事务协调器通知应用程序，

1908
01:04:47,720 --> 01:04:49,610
0,300 300,480 480,540 540,1140 1290,1890
particular point in time, the

1909
01:04:49,640 --> 01:04:51,890
0,600 600,1110 1110,1530 1530,1590 1590,2250
transaction coordinator informs the application,|
|

1910
01:04:51,980 --> 01:04:53,900
0,540 570,750 750,1230 1230,1410 1410,1920
yes, your transaction has committed,
是的，您的交易已提交，并已完成。

1911
01:04:54,020 --> 01:04:55,780
0,810 810,1050 1050,1410
and is done.|
|

1912
01:04:57,470 --> 01:04:58,820
0,480 630,780 780,960 960,1110 1110,1350
Then, of course your point
那么，当然你稍后要说的是，

1913
01:04:58,820 --> 01:04:59,750
0,330 330,420 420,720 720,840 840,930
later,| the logs need to
|日志需要清理、缩短和截断，诸如此类的事情

1914
01:04:59,750 --> 01:05:01,370
0,90 90,750 750,990 990,1380 1380,1620
be cleaned and shortened up

1915
01:05:01,370 --> 01:05:02,300
0,120 120,630 630,720 720,840 840,930
and truncated and all that

1916
01:05:02,300 --> 01:05:02,960
0,150 150,210 210,450 450,540 540,660
kind of stuff| and this
|这就像是截断阶段

1917
01:05:02,960 --> 01:05:04,910
0,90 90,240 240,300 300,870 870,1950
is like the truncate {phase

1918
01:05:04,940 --> 01:05:07,310
0,540 750,930 930,1110 1110,1590 1590,2370
-}| and that's basically {[],back}
|这基本上是回到后面的锁定阶段和验证阶段。

1919
01:05:07,310 --> 01:05:09,080
0,240 240,750 750,1230 1230,1680 1680,1770
on later locking phases and

1920
01:05:09,080 --> 01:05:10,680
0,480 480,1140
validation phases.|
|

1921
01:05:10,950 --> 01:05:12,030
0,480 480,660 660,750 750,900 900,1080
{} And so I'm not
所以我不会真的谈论它，

1922
01:05:12,030 --> 01:05:12,810
0,150 150,270 270,360 360,570 570,780
really going to talk about

1923
01:05:12,810 --> 01:05:14,340
0,120 120,240 240,570 570,1080 1080,1530
it at all,| but basically
|但基本上，他们必须截断日志，

1924
01:05:14,340 --> 01:05:15,180
0,90 90,180 180,330 330,750 750,840
they have to truncate the

1925
01:05:15,180 --> 01:05:16,620
0,780 780,900 900,1050 1050,1200 1200,1440
logs,| so that they don't
|这样它们就不会无限生长。

1926
01:05:16,620 --> 01:05:18,020
0,390 390,960
grow unbounded.|
|

1927
01:05:23,640 --> 01:05:27,330
0,510 780,1440 1440,1920 1920,2400 2640,3690
{} Sorry, but the hardware
抱歉，硬件会起作用，它们只是直接进入协调器的网卡。

1928
01:05:27,360 --> 01:05:29,730
0,600 600,1020 1020,1470 1470,1620 1620,2370
acts, they just go directly

1929
01:05:29,790 --> 01:05:30,920
0,870
into,

1930
01:05:31,460 --> 01:05:33,800
0,510 510,1140 1560,1920 1920,2100 2100,2340
into the NIC of the

1931
01:05:33,800 --> 01:05:36,590
0,600 600,2310 2310,2460 2460,2580 2580,2790
coordinator.| Yeah, let's go back
|是的，让我们回到RDMA的照片上，对吧，

1932
01:05:36,590 --> 01:05:37,970
0,60 60,150 150,600 600,1020 1050,1380
to the RDMA picture, right,|
|

1933
01:05:38,360 --> 01:05:39,590
0,240 240,390 390,510 510,780 780,1230
so if a write RDMA
因此，如果发生写入RDMA，

1934
01:05:39,590 --> 01:05:40,460
0,660
happens,|
|

1935
01:05:41,090 --> 01:05:43,100
0,570 570,720 720,1080 1080,1320 1320,2010
{} so here're write RDMA,|
所以下面是写RDMA，|

1936
01:05:43,250 --> 01:05:45,410
0,690 750,1230 1230,1800 1800,1920 1920,2160
the sender coordinator was running
发送方协调人在这里运行，对吧，

1937
01:05:45,410 --> 01:05:46,640
0,90 90,420 420,750 780,990 990,1230
{} here, right,| and here's
|这可能是备份的主要方式之一，

1938
01:05:46,640 --> 01:05:47,270
0,150 150,270 270,450 450,540 540,630
may be one of the

1939
01:05:47,270 --> 01:05:49,080
0,510 510,690 690,1530
primary for backups,|
|

1940
01:05:49,600 --> 01:05:51,550
0,660 660,900 900,1260 1260,1530 1530,1950
and so the write RDMA
于是写入RDMA进入，

1941
01:05:51,550 --> 01:05:53,080
0,240 240,630 660,1170 1170,1470 1470,1530
goes in,| write maybe an
|可能在日志中写入一个条目，

1942
01:05:53,080 --> 01:05:54,970
0,390 390,510 510,630 630,1230 1590,1890
entry to the log, {}|
|

1943
01:05:54,970 --> 01:05:56,650
0,150 150,390 390,630 630,1050 1170,1680
the NIC does that, NIC
NIC执行此操作，NIC发回确认，

1944
01:05:56,740 --> 01:05:58,520
0,300 300,390 390,960 960,1410
sends an acknowledgement back,|
|

1945
01:06:00,170 --> 01:06:01,820
0,390 390,480 480,1080 1080,1200 1200,1650
and the coordinator will see
并且协调器将在接收到的队列中看到该确认，

1946
01:06:01,820 --> 01:06:03,170
0,180 180,810 810,930 930,990 990,1350
that acknowledgment in the received

1947
01:06:03,170 --> 01:06:03,760
0,240
queue,|
|

1948
01:06:07,180 --> 01:06:08,140
0,210 210,450 450,780 780,870 870,960
and so soon as the
一旦协调员看到你所知道的ACK，

1949
01:06:08,140 --> 01:06:09,970
0,510 510,840 840,1020 1020,1470 1530,1830
coordinator sees the ack {you,know}

1950
01:06:09,970 --> 01:06:12,040
0,570 570,990 990,1350 1350,1620 1620,2070
for,| {} it's {} one
|这是一次写入RDMA，它可以继续，

1951
01:06:12,040 --> 01:06:14,770
0,390 390,1110 1260,1770 1770,2100 2100,2730
write RDMA, {} it can

1952
01:06:14,980 --> 01:06:15,880
0,540
proceed,|
|

1953
01:06:16,380 --> 01:06:17,370
0,180 180,540 540,660 660,750 750,990
and knows that the write
并且知道它们成功地写入RDMA。

1954
01:06:17,370 --> 01:06:18,700
0,180 180,390 390,1020
RDMA they succeeded.|
|

1955
01:06:23,920 --> 01:06:26,230
0,210 210,600 600,1230 1260,1710 1740,2310
So does the write RDMA
所以写RDMA只是写日志，它们。

1956
01:06:26,230 --> 01:06:27,280
0,150 150,480 480,840 840,930 930,1050
is only write to the

1957
01:06:27,280 --> 01:06:30,010
0,450 450,1020 1650,2190 2190,2580 2580,2730
log, they.| They're used in
|它们被用在两种情况下，

1958
01:06:30,010 --> 01:06:31,930
0,180 180,840 900,1410 1410,1620 1620,1920
two cases,| {} they're both
|它们都用于这些消息队列和日志附加。

1959
01:06:31,930 --> 01:06:33,490
0,270 270,510 510,690 690,1050 1050,1560
used for these message queues

1960
01:06:33,520 --> 01:06:36,220
0,270 270,540 540,1800 2280,2550 2550,2700
and for the {} the

1961
01:06:36,220 --> 01:06:37,440
0,450 480,840
log append.|
|

1962
01:06:41,620 --> 01:06:42,400
0,210 210,330 330,450 450,570 570,780
And so when we say
因此，当我们说已经执行了写入RDMA时，

1963
01:06:42,400 --> 01:06:44,380
0,660 660,960 960,1290 1290,1830 1830,1980
that a write RDMA has

1964
01:06:44,380 --> 01:06:45,670
0,150 150,660 660,780 780,1050 1050,1290
been performed,| we mean that
|我们的意思是它已被附加到日志中

1965
01:06:45,670 --> 01:06:46,510
0,90 90,240 240,390 390,780 780,840
it has been appended to

1966
01:06:46,510 --> 01:06:47,950
0,90 90,510 540,810 810,1110 1110,1440
the log| and not actually
|并且不一定由应用程序实际执行。

1967
01:06:47,950 --> 01:06:49,990
0,600 600,1200 1200,1440 1440,1560 1560,2040
executed necessarily by the application.|
|

1968
01:06:50,050 --> 01:06:52,030
0,300 300,720 720,900 900,1320 1710,1980
That's correct, that's correct, {}|
对，对，对，|

1969
01:06:52,030 --> 01:06:53,440
0,270 270,900 900,1020 1020,1170 1170,1410
so {for,example} you know to
例如，您知道要执行备份以实际执行对象的更新，

1970
01:06:53,440 --> 01:06:54,880
0,60 60,360 360,630 630,870 930,1440
for example do the backup

1971
01:06:54,880 --> 01:06:57,850
0,90 90,630 870,1860 1890,2730 2760,2970
to actually {} perform the

1972
01:06:57,850 --> 01:06:59,020
0,300 300,390 390,480 480,990 990,1170
update to the object,| you
|您需要读取日志条目，然后应用更新。

1973
01:06:59,020 --> 01:07:00,430
0,300 300,750 750,990 990,1080 1080,1410
need to read the log

1974
01:07:00,430 --> 01:07:01,450
0,390 390,480 480,600 600,930 930,1020
entry and then apply the

1975
01:07:01,450 --> 01:07:02,000
0,420
update.|
|

1976
01:07:03,730 --> 01:07:04,810
0,150 150,360 360,480 480,810 810,1080
I see, and also for
我明白了，还有每个对象的日志位，

1977
01:07:04,810 --> 01:07:06,400
0,210 210,570 570,840 840,1110 1110,1590
the log bit for every

1978
01:07:06,400 --> 01:07:08,140
0,450 450,690 690,960 960,1320 1320,1740
object,| so since everything resides
|因此，由于一切都驻留在内存中，

1979
01:07:08,140 --> 01:07:09,190
0,270 300,690 690,780 780,900 900,1050
in memory,| and we have
|我们有64位的版本号加上日志位，

1980
01:07:09,190 --> 01:07:10,300
0,480 480,630 630,870 870,1050 1050,1110
{like,64 -} bits for the

1981
01:07:10,300 --> 01:07:11,980
0,270 270,780 990,1350 1350,1410 1410,1680
version number plus the log

1982
01:07:11,980 --> 01:07:13,330
0,270 450,750 750,900 900,1230 1230,1350
bit,| so I'm assuming that
|所以我假设它可以放入一个单一的存储地址，

1983
01:07:13,330 --> 01:07:14,230
0,90 90,300 300,630 630,810 810,900
it can fit in a

1984
01:07:14,230 --> 01:07:16,450
0,540 540,930 930,1470 1680,2130 2130,2220
single memory address,| but we
|但我们仍然会有这样的问题，

1985
01:07:16,450 --> 01:07:17,350
0,120 120,330 330,450 450,540 540,900
can still have the problem

1986
01:07:17,350 --> 01:07:19,240
0,150 150,510 510,660 660,1080 1080,1890
of,| let's say the processor
|假设处理器将该内存地址提取到寄存器中

1987
01:07:19,270 --> 01:07:21,040
0,570 570,780 780,1110 1110,1500 1500,1770
fetching that memory address into

1988
01:07:21,040 --> 01:07:22,930
0,840 1110,1410 1410,1560 1560,1680 1680,1890
register| {} and then maybe
|然后，如果我们有一台多核计算机，

1989
01:07:22,930 --> 01:07:23,890
0,210 210,300 300,480 480,690 690,960
if we have a multi

1990
01:07:23,890 --> 01:07:26,770
0,600 1200,1710 1710,2010 2010,2400 2400,2880
core machine,| then another core
|然后另一个内核获取相同的地址

1991
01:07:26,830 --> 01:07:29,440
0,480 480,1350 1620,1980 1980,2220 2220,2610
fetching that that same address|
|

1992
01:07:29,440 --> 01:07:30,730
0,120 120,420 420,660 660,780 780,1290
and then both of them
然后它们都从0翻到1，

1993
01:07:30,790 --> 01:07:32,140
0,420 420,570 570,810 810,930 930,1350
flipping from 0 to 1,|
|

1994
01:07:32,500 --> 01:07:34,270
0,540 540,1230 1230,1470 1470,1590 1590,1770
so I'm assuming that there's
所以我假设有一些来自硬件的支持？

1995
01:07:34,270 --> 01:07:35,800
0,150 150,660 660,750 750,810 810,1530
some support from the hardware?|
|

1996
01:07:35,920 --> 01:07:37,420
0,360 360,510 510,690 690,1170 1170,1500
Yeah, so like I mentioned
是的，就像我之前提到的，

1997
01:07:37,420 --> 01:07:38,680
0,60 60,180 180,630 630,750 750,1260
a bit earlier,| the primary
|当它获得的时候，主要的

1998
01:07:38,680 --> 01:07:40,150
0,210 210,300 300,870 870,1080 1080,1470
when it acquires,| the primaries
|初选中涉及的初选实际上是正确的，

1999
01:07:40,150 --> 01:07:42,010
0,270 270,810 810,1170 1170,1470 1530,1860
actually involved correct in the

2000
01:07:42,010 --> 01:07:45,160
0,420 420,1110 1500,2490 2640,3150 3150,3150
primary on { -},| {so,the}
|所以协调人发送，

2001
01:07:45,160 --> 01:07:47,110
0,720 720,1200 1200,1380 1380,1620 1620,1950
coordinator sends {},| so in
|所以在像这样的锁定步骤中，第一步，

2002
01:07:47,110 --> 01:07:48,460
0,90 90,360 360,870 900,1140 1140,1350
the lock step like this,

2003
01:07:48,460 --> 01:07:50,950
0,180 180,870 1110,1470 1470,1920 2130,2490
this step step one,| the
|主顺序协调器向主顺序协调器发送写RDMA，

2004
01:07:50,950 --> 01:07:52,990
0,570 570,930 930,1470 1470,1800 1800,2040
primary order coordinator sends an

2005
01:07:52,990 --> 01:07:56,710
0,780 810,1260 1260,1860 1860,2610 2820,3720
{} write RDMA to the

2006
01:07:57,070 --> 01:07:58,660
0,120 120,240 240,870 900,1470 1470,1590
to the primaries,| asking the
|要求初选人员锁定该物体

2007
01:07:58,660 --> 01:08:00,940
0,480 480,630 630,1200 1410,2160
primaries to lock the

2008
01:08:00,990 --> 01:08:04,710
0,600 600,1230 1740,2490 2580,3150 3180,3720
{} object| and the primaries
|初选用一条信息明确地回答，那就是回复，

2009
01:08:04,710 --> 01:08:06,420
0,480 480,1230 1260,1470 1470,1650 1650,1710
answer explicitly {} with a

2010
01:08:06,420 --> 01:08:09,270
0,510 540,810 810,1410 1800,2460 2460,2850
message, that reply,| and so
|所以发生的这一关键步骤是，

2011
01:08:09,300 --> 01:08:11,280
0,390 390,810 810,1350 1350,1530 1530,1980
this crucial step that happens

2012
01:08:11,280 --> 01:08:12,390
0,300 300,450 450,540 540,930 930,1110
is,| that the primary when
|当它实际尝试获取锁时，主服务器

2013
01:08:12,390 --> 01:08:13,170
0,120 120,300 300,570 570,660 660,780
it actually tries to get

2014
01:08:13,170 --> 01:08:14,850
0,90 90,510 840,990 990,1170 1170,1680
the lock| and that lock
|锁就设置好了，

2015
01:08:15,030 --> 01:08:17,010
0,720 720,930 930,1350 1380,1590 1590,1980
{} is set,| you know
|你知道为什么这是一个单一的64位数字，

2016
01:08:17,010 --> 01:08:18,270
0,390 390,570 570,690 690,960 960,1260
reason this is one single

2017
01:08:18,270 --> 01:08:19,920
0,480 480,660 660,1230 1350,1530 1530,1650
64 bit number,| is so
|这样您就可以使用原子的[]test和set指令来设置锁。

2018
01:08:19,920 --> 01:08:20,460
0,120 120,240 240,330 330,480 480,540
that you can use []

2019
01:08:20,460 --> 01:08:22,110
0,240 240,330 330,510 510,1170 1320,1650
test and set instruction which

2020
01:08:22,110 --> 01:08:23,640
0,90 90,720 960,1170 1170,1290 1290,1530
is atomic {} to set

2021
01:08:23,640 --> 01:08:24,260
0,90 90,540
the lock.|
|

2022
01:08:25,640 --> 01:08:27,950
0,360 360,600 600,1080 1650,2160 2160,2310
So if two, {} so
因此，如果是两个，那么就永远不会有这种情况，

2023
01:08:27,950 --> 01:08:29,780
0,750 750,1020 1020,1110 1110,1470 1470,1830
there's never the case,| there's
|只有当两个测试和设置指令完全同时运行时，

2024
01:08:29,780 --> 01:08:31,580
0,300 300,510 510,780 780,1500 1500,1800
only if two {test,and,set} instructions

2025
01:08:31,580 --> 01:08:33,410
0,180 180,1080 1080,1170 1170,1380 1380,1830
run exactly the same time,|
|

2026
01:08:33,500 --> 01:08:34,370
0,240 240,330 330,450 450,510 510,870
one is going to win,
一个会赢，另一个会输。

2027
01:08:34,400 --> 01:08:34,910
0,120 120,240 240,330 330,450 450,510
the other is going to

2028
01:08:34,910 --> 01:08:35,560
0,480
lose.|
|

2029
01:08:36,500 --> 01:08:38,570
0,180 180,390 390,660 660,900 1590,2070
I see, thank you.| That's
我明白了，谢谢你。|这是一个关键点，对。

2030
01:08:38,570 --> 01:08:40,220
0,60 60,450 450,900 930,1350
a crucial point, right.|
|

2031
01:08:42,350 --> 01:08:44,900
0,330 330,510 510,660 660,1860 1890,2550
I've got a question about
我有一个关于蓝色提交点的问题。

2032
01:08:44,990 --> 01:08:46,680
0,210 210,540 540,930 930,1380
the blue commit point.|
|

2033
01:08:47,190 --> 01:08:48,540
0,540 540,990
Yeah. {}|
嗯。|

2034
01:08:49,220 --> 01:08:52,100
0,390 390,690 690,1200 1440,1950 2310,2880
Wouldn't it, so.| {Should,I}, {let,me},
不是吗，所以。|我应该，让我，也许实际上再打开一张带有照片的新幻灯片更好

2035
01:08:52,100 --> 01:08:53,120
0,210 210,420 420,540 540,840 840,1020
{} maybe it's better to

2036
01:08:53,120 --> 01:08:54,890
0,720 720,1320 1320,1350 1350,1500 1500,1770
actually open a new slide

2037
01:08:54,890 --> 01:08:55,910
0,120 120,240 240,480 480,840 840,1020
with the picture again| and
|与其在这件事上涂鸦，

2038
01:08:55,910 --> 01:08:58,220
0,300 1260,1560 1560,1620 1620,2130 2130,2310
just instead of scribbling even

2039
01:08:58,220 --> 01:08:59,240
0,270 270,450 450,810
more over this,|
|

2040
01:08:59,490 --> 01:09:00,540
0,120 120,510 510,720 720,870 870,1050
I mean, let's get one
我是说，让我们再拍一张，

2041
01:09:00,540 --> 01:09:01,680
0,180 180,570 570,690 690,810 810,1140
more picture,| so we can
|这样我们就可以讨论其他场景了，

2042
01:09:01,890 --> 01:09:03,740
0,270 270,450 450,630 630,1380
talk about other scenarios,|
|

2043
01:09:14,240 --> 01:09:14,870
0,120 120,270 270,300 300,480 480,630
I think a little bit
我想再大一点，

2044
01:09:14,870 --> 01:09:16,760
0,480 660,900 900,1410 1410,1710 1710,1890
bigger,| I think should do
|我认为应该这么做。

2045
01:09:16,760 --> 01:09:17,640
0,390
[that].|
|

2046
01:09:18,410 --> 01:09:20,720
0,510 540,990 990,1290 1290,2010
Okay, {} so you're
好吧，所以你担心的是，

2047
01:09:20,920 --> 01:09:23,860
0,420 420,990 1020,1320 1320,1800 2670,2940
worried about,| {let,me} see.| {Yeah,the}
|让我想想。|是步骤之间的提交点，在步骤3之后，在步骤3之前。

2048
01:09:23,860 --> 01:09:25,750
0,270 270,480 480,870 870,1440 1470,1890
commit point between step, after

2049
01:09:25,750 --> 01:09:27,520
0,210 210,420 420,990 990,1320 1320,1770
step 3, before step 3.|
|

2050
01:09:27,670 --> 01:09:29,500
0,300 300,420 420,1440 1470,1770 1770,1830
Yeah, so here, here's the
是的，所以，这是决定，正确的。

2051
01:09:29,500 --> 01:09:31,900
0,480 480,870 870,1260 1740,2250 2250,2400
decision, correct.| Right.| {Starting,to,commit} and
|正确的。|开始提交，然后基本上是实际提交点，对吧。

2052
01:09:31,900 --> 01:09:34,220
0,480 780,1290 1290,1650 1650,2040
then basically here's the

2053
01:09:34,470 --> 01:09:36,520
0,870 870,1290 1320,1740
{actually,commit} point, right.|
|

2054
01:09:37,090 --> 01:09:39,220
0,600 630,1380 1440,1740 1740,1860 1860,2130
Okay, {} yeah I guess
好吧，是的，我想我是在想这个场景，

2055
01:09:39,220 --> 01:09:40,360
0,120 120,540 540,840 840,930 930,1140
I was trying to think

2056
01:09:40,360 --> 01:09:42,140
0,240 240,330 330,780 780,1470
about the scenario,| where,
|在这种情况下，一个完全独立的并发事务是否可能，

2057
01:09:42,580 --> 01:09:44,710
0,390 390,510 510,660 660,1680 1710,2130
would it be possible for

2058
01:09:44,710 --> 01:09:47,440
0,90 90,690 690,1350 1350,1770 1770,2730
a completely separate concurrent transaction,|
|

2059
01:09:47,830 --> 01:09:50,410
0,240 240,510 510,1020 1020,2250 2430,2580
that writes only p3 to
仅写入p3即可进行交错，

2060
01:09:50,410 --> 01:09:52,120
0,180 180,450 450,840 840,1410 1440,1710
get {interleaved - -},| {to,like}
|要想在那个空间里开始和完成，

2061
01:09:52,150 --> 01:09:54,610
0,510 510,660 660,1380 1980,2190 2190,2460
start and complete in that

2062
01:09:54,610 --> 01:09:55,540
0,780
space,|
|

2063
01:09:55,840 --> 01:09:57,220
0,150 150,300 300,630 630,1050
and then wasn't that?|
然后不是这样吗？|

2064
01:09:57,450 --> 01:09:59,970
0,450 450,720 720,1620 2040,2280 2280,2520
No, [],| yeah yeah we're
不，[]，|是的，是的，我们有问题，但不能，对吧，

2065
01:09:59,970 --> 01:10:01,590
0,450 450,630 630,990 990,1320 1320,1620
problematic, but can't, correct,| because
|因为当它写入时，它在某个点上不会获得锁，

2066
01:10:01,590 --> 01:10:02,490
0,150 150,330 330,570 570,630 630,900
when it writes, it doesn't

2067
01:10:02,490 --> 01:10:03,270
0,150 150,240 240,510 510,600 600,780
get the lock at some

2068
01:10:03,270 --> 01:10:03,920
0,390
point,|
|

2069
01:10:04,580 --> 01:10:05,750
0,510 510,840 840,960 960,1080 1080,1170
and when we get the
当我们获得锁时，我们检查版本号和锁位。

2070
01:10:05,750 --> 01:10:06,620
0,210 210,300 300,510 510,570 570,870
lock, we check the version

2071
01:10:06,620 --> 01:10:07,580
0,270 270,390 390,480 480,750 750,960
number and the lock bit.|
|

2072
01:10:10,580 --> 01:10:12,200
0,210 210,390 390,1110 1200,1440 1440,1620
Does the read, does the
读，读p3会影响版本号并锁定它吗？

2073
01:10:12,200 --> 01:10:13,520
0,240 240,360 360,810 810,1230 1230,1320
read the p3 affect the

2074
01:10:13,520 --> 01:10:14,630
0,270 270,540 540,630 630,870 870,1110
version number and lock it?|
|

2075
01:10:15,290 --> 01:10:16,490
0,270 270,630 630,780 780,960 960,1200
No, no, it just gets
不，不，它只获取版本号。

2076
01:10:16,490 --> 01:10:17,740
0,330 330,600 600,960
the version number.|
|

2077
01:10:19,350 --> 01:10:22,410
0,210 210,1440 2130,2310 2310,2790 2790,3060
But if you, let let
但如果你，让我来回答这个问题，

2078
01:10:22,410 --> 01:10:23,610
0,120 120,480 480,630 630,960 960,1200
me hold that question,| you're
|你会在这个问题上回来的。

2079
01:10:23,610 --> 01:10:24,180
0,120 120,180 180,270 270,510 510,570
going to come back at

2080
01:10:24,180 --> 01:10:24,800
0,390
this.|
|

2081
01:10:25,250 --> 01:10:26,660
0,390 390,630 630,750 750,1020 1020,1410
Okay, then we'll see what
好的，那我们就看看会发生什么吧？

2082
01:10:26,660 --> 01:10:27,660
0,240 240,810
actually happens?|
|

2083
01:10:28,820 --> 01:10:29,820
0,330 330,750
Okay, thanks.|
好的，谢谢。|

2084
01:10:31,640 --> 01:10:32,900
0,210 210,390 390,990
Any other questions?|
还有其他问题吗？|

2085
01:10:34,930 --> 01:10:35,710
0,270 270,420 420,510 510,690 690,780
This might be like a
这可能像是一个单独的场景，

2086
01:10:35,710 --> 01:10:37,150
0,360 360,780 780,870 870,1020 1020,1440
separate scenario,| but what happens
|但如果你在行刑阶段之后知道了会发生什么，

2087
01:10:37,150 --> 01:10:40,030
0,990 1380,1800 1980,2130 2130,2430 2460,2880
if {} you know after

2088
01:10:40,030 --> 01:10:41,640
0,90 90,780 780,1380
the execution phase,|
|

2089
01:10:41,980 --> 01:10:43,780
0,720 780,960 960,1230 1230,1380 1380,1800
{} you know it tries
你知道它试图获取一个锁

2090
01:10:43,780 --> 01:10:45,400
0,90 90,630 630,840 840,1380 1410,1620
to acquire a lock| and
|然后就在那之后坠毁了

2091
01:10:45,400 --> 01:10:47,530
0,150 150,690 690,870 870,1440 1590,2130
then crashes right {after,that}, {}|
|

2092
01:10:47,800 --> 01:10:49,120
0,150 150,420 420,660 660,810 810,1320
{and,the} lock has been acquired,|
并且锁已经被获取，|

2093
01:10:49,120 --> 01:10:49,990
0,120 120,210 210,360 360,600 600,870
but no one else after
但在那之后，其他任何人都无法获得它。

2094
01:10:49,990 --> 01:10:51,100
0,210 210,330 330,690 690,840
that can acquire it.|
|

2095
01:10:51,830 --> 01:10:53,270
0,690 690,960 960,1110 1110,1260 1260,1440
Yeah, okay so well first
是的，好的，首先，机器从地球上消失了，对吗？

2096
01:10:53,270 --> 01:10:54,680
0,60 60,150 150,270 270,810 840,1410
of all the machine disappears

2097
01:10:54,680 --> 01:10:56,060
0,180 180,270 270,570 570,1050 1050,1380
from the earth, correct| and
|而记忆内容也消失了，

2098
01:10:56,060 --> 01:10:57,320
0,300 300,660 660,720 720,990 990,1260
memory content is gone too,|
|

2099
01:10:59,200 --> 01:11:01,180
0,690 690,1320 1320,1620 1620,1680 1680,1980
and, {} in the whole
并且，在论文的下一节中描述的整个恢复协议中，

2100
01:11:01,180 --> 01:11:03,280
0,660 690,1290 1290,1560 1560,1680 1680,2100
recovery protocol that is described

2101
01:11:03,280 --> 01:11:04,060
0,60 60,150 150,390 390,720 720,780
in the next section in

2102
01:11:04,060 --> 01:11:05,520
0,90 90,570 600,870 870,1110
the paper kicks in,|
|

2103
01:11:05,760 --> 01:11:07,680
0,780 780,1200 1200,1470 1470,1860 1860,1920
and, {} that protocol in
并且，该协议最终将中止该事务，

2104
01:11:07,680 --> 01:11:09,150
0,120 120,360 360,870 870,1350 1350,1470
the end will abort the

2105
01:11:09,150 --> 01:11:10,040
0,540
transaction,|
|

2106
01:11:17,640 --> 01:11:19,050
0,210 210,630 630,960 960,1140 1140,1410
so it will get cleaned
因此，它将得到清理。

2107
01:11:19,050 --> 01:11:19,660
0,330
up.|
|

2108
01:11:22,790 --> 01:11:23,960
0,120

2109
01:11:26,440 --> 01:11:28,630
0,330 330,630 630,1230 1260,1740 1800,2190
Just another question,| {} so
再问一个问题，|所以这里就像协调员是客户端一样，对，就像它是应用程序一样。

2110
01:11:28,630 --> 01:11:30,970
0,330 330,570 570,690 690,1740 2130,2340
here like the coordinator is

2111
01:11:30,970 --> 01:11:32,320
0,120 120,660 660,960 960,1110 1110,1350
the client, right, like it's

2112
01:11:32,320 --> 01:11:36,250
0,210 210,870 870,2100 2100,3480 3690,3930
the application.| Yeah yeah.| And
|对，对。|所以客户基本上是在做所有的步骤，

2113
01:11:36,250 --> 01:11:37,660
0,210 210,360 360,810 810,960 960,1410
so the client is basically

2114
01:11:37,660 --> 01:11:38,980
0,360 360,600 600,690 690,1140 1140,1320
doing all the steps,| of
|就像把那个记下来一样。

2115
01:11:38,980 --> 01:11:41,650
0,270 300,840 870,1410 1650,2460 2460,2670
like log that.| Yeah, yeah,
|是的，是的，所以你可以考虑在同一组90台机器上运行的应用程序，对吧，

2116
01:11:41,650 --> 01:11:42,850
0,420 420,780 780,870 870,1020 1020,1200
so you could think about

2117
01:11:42,850 --> 01:11:43,870
0,120 120,630 630,900 900,960 960,1020
the applications running on the

2118
01:11:43,870 --> 01:11:45,340
0,330 330,570 570,660 660,930 930,1470
same set of 90 machines,

2119
01:11:45,400 --> 01:11:47,230
0,360 360,930 930,1500 1500,1590 1590,1830
right,| {} and you know
|你知道，运行这个事务，很显然，你知道每个事务都会写两个对象

2120
01:11:47,230 --> 01:11:49,450
0,330 330,480 480,1140 1320,1590 1590,2220
running this transaction which apparently

2121
01:11:49,450 --> 01:11:50,500
0,60 60,240 240,540 540,690 690,1050
you know writes two objects

2122
01:11:50,500 --> 01:11:53,140
0,150 150,270 270,720 1020,2220 2250,2640
of each one| and runs
|并运行该协议。

2123
01:11:53,140 --> 01:11:53,820
0,120 120,600
the protocol.|
|

2124
01:11:54,540 --> 01:11:56,880
0,450 480,1020 1110,1710 1830,1950 1950,2340
And so, {} I guess
所以，我想令人困惑的是，

2125
01:11:57,030 --> 01:11:58,770
0,240 240,630 630,1050 1230,1500 1500,1740
what's confusing is,| so does
|所以主节点并不直接与备份节点通信，它是。

2126
01:11:58,770 --> 01:12:00,600
0,120 120,630 630,1140 1140,1710 1710,1830
the primary not communicate with

2127
01:12:00,600 --> 01:12:02,760
0,90 90,660 660,1470 1620,1920 1920,2160
the backup directly, it's the.|
|

2128
01:12:02,790 --> 01:12:04,830
0,660 660,840 840,1140 1140,1560 1590,2040
No, it's actually indeed {},|
不，实际上是这样的，|

2129
01:12:04,830 --> 01:12:05,970
0,120 120,390 390,570 570,750 750,1140
the primary does not directly
主节点不直接与备份节点通信。

2130
01:12:05,970 --> 01:12:07,220
0,450 450,540 540,600 600,960
communicate with the backup.|
|

2131
01:12:07,720 --> 01:12:08,660
0,600
{I,see}.|
我明白了。|

2132
01:12:09,980 --> 01:12:11,630
0,360 360,480 480,750 750,1260 1260,1650
Other than during recovery protocol,|
除了在恢复协议期间之外，|

2133
01:12:11,630 --> 01:12:12,680
0,210 210,300 300,480 480,540 540,1050
there's all kinds of communication
有各种各样的交流正在发生，

2134
01:12:12,680 --> 01:12:13,760
0,360 360,450 450,630 630,810 810,1080
happening,| but that's not shown
|但这并没有在这里展示。

2135
01:12:13,760 --> 01:12:14,360
0,300
here.|
|

2136
01:12:18,590 --> 01:12:20,180
0,210 210,450 450,1110 1110,1350 1350,1590
So the coordinator just uses
因此，协调员只使用来自动物园管理员的配置。

2137
01:12:20,180 --> 01:12:21,950
0,120 120,1050 1050,1410 1410,1530 1530,1770
the configuration from the {zookeeper

2138
01:12:21,950 --> 01:12:24,590
0,390 390,900 930,2100 2100,2310 2310,2640
-}.| Yeah yeah, you go
|是的，是的，你回到第一张照片，

2139
01:12:24,590 --> 01:12:25,610
0,240 240,330 330,510 510,750 750,1020
back to the very first

2140
01:12:25,610 --> 01:12:27,770
0,480 930,1620 1620,1710 1710,2010 2010,2160
picture,| {} you know there's
|你知道，你知道有各种各样的事情和这个有关，

2141
01:12:27,770 --> 01:12:28,610
0,120 120,270 270,330 330,690 720,840
all kinds of stuff you

2142
01:12:28,610 --> 01:12:29,690
0,180 180,510 510,570 570,720 720,1080
know related to this {to,that},|
|

2143
01:12:29,690 --> 01:12:31,340
0,90 90,240 240,570 570,960 1260,1650
I'm not talking about {}
我不是在谈论这种精确的会员资格之类的事情，

2144
01:12:31,340 --> 01:12:32,660
0,240 240,390 390,750 750,1230 1230,1320
like this precise membership and

2145
01:12:32,660 --> 01:12:33,320
0,120 120,210 210,360 360,420 420,660
all that kind of thing,|
|

2146
01:12:33,650 --> 01:12:35,540
0,420 420,960 960,1320 1320,1770 1770,1890
but basically the zookeeper and
但基本上是由动物园管理员和连接经理决定的，

2147
01:12:35,540 --> 01:12:37,430
0,360 360,810 810,1170 1170,1770 1770,1890
connection manager really decide,| well
|这是一个配置，当前的配置，我们正在运行，

2148
01:12:37,430 --> 01:12:39,290
0,510 510,600 600,780 780,1620 1620,1860
this is a configuration, the

2149
01:12:39,290 --> 01:12:40,820
0,270 270,810 810,960 960,1230 1230,1530
current configuration, we're running in,|
|

2150
01:12:41,120 --> 01:12:42,590
0,330 330,570 570,720 720,1260 1260,1470
these are the regions,| how
这些是区域，|它们如何映射主备份和所有这些内容，

2151
01:12:42,590 --> 01:12:44,690
0,210 210,720 720,1110 1110,1800 1950,2100
they're mapped primary backups and

2152
01:12:44,690 --> 01:12:45,420
0,90 90,240 240,630
all that stuff,|
|

2153
01:12:46,600 --> 01:12:48,070
0,90 90,270 270,510 510,960 960,1470
and in any failure happens,|
在任何失败发生时，|

2154
01:12:48,070 --> 01:12:49,030
0,90 90,240 240,420 420,480 480,960
you know there's a whole
你知道，在复苏过程中，有一个完整的重新配置过程。

2155
01:12:49,030 --> 01:12:50,680
0,600 600,900 900,1140 1140,1380 1410,1650
reconfiguration process going on in

2156
01:12:50,680 --> 01:12:51,520
0,510
recovery.|
|

2157
01:12:53,370 --> 01:12:54,880
0,420 420,810
{I,see}, {thank,you}.|
我明白了，谢谢你。|

2158
01:13:00,820 --> 01:13:02,800
0,510 540,1170 1260,1680 1680,1830 1830,1980
Okay, {} maybe I'm gonna
好吧，也许我会跳过休息室，

2159
01:13:02,800 --> 01:13:05,320
0,390 390,1050 1080,1440 1440,1770 1830,2520
skip the breakout room, {}|
|

2160
01:13:05,320 --> 01:13:06,640
0,210 210,330 330,420 420,750 780,1320
and so I can go
所以我可以走得更远，

2161
01:13:06,640 --> 01:13:08,260
0,60 60,210 210,330 330,810 960,1620
a little bit further {},|
|

2162
01:13:08,380 --> 01:13:09,820
0,690 690,810 810,1110 1110,1200 1200,1440
{the,question} you know I wanted
你知道我想要回答的问题，

2163
01:13:09,820 --> 01:13:10,690
0,60 60,300 300,390 390,720 720,870
to answer the question,| that
|在演讲中问帖子的那个人，

2164
01:13:10,690 --> 01:13:12,820
0,420 420,720 720,1140 1860,2010 2010,2130
{} in the that was

2165
01:13:12,820 --> 01:13:13,900
0,360 360,660 690,960 960,1020 1020,1080
asking the post in the

2166
01:13:13,900 --> 01:13:15,790
0,330 330,540 540,960 1320,1590 1590,1890
lecture,| I'm gonna lecture question
|我将讲授问题，我将通过谈论一个交易的例子来实现这个目标

2167
01:13:15,790 --> 01:13:16,570
0,180 180,450 450,570 570,720 720,780
and I'm just going to

2168
01:13:16,570 --> 01:13:18,310
0,150 150,420 420,900 1080,1560 1560,1740
do that by talking about

2169
01:13:18,310 --> 01:13:19,900
0,90 90,780 780,870 870,1350 1350,1590
an example of transaction| and
|这也涉及到早先的问题，

2170
01:13:19,900 --> 01:13:20,650
0,180 180,420 420,600 600,690 690,750
this also comes to the

2171
01:13:20,650 --> 01:13:22,570
0,390 390,690 690,1050 1440,1800 1800,1920
earlier question about,| {} you
|您知道会发生什么，您知道两个事务运行并读取一个版本

2172
01:13:22,570 --> 01:13:23,560
0,60 60,270 270,780 780,870 870,990
know what happens, you know

2173
01:13:23,560 --> 01:13:25,600
0,150 150,660 660,1140 1320,1830 1830,2040
two transactions run and read

2174
01:13:25,600 --> 01:13:27,070
0,210 210,840 840,1140 1140,1350 1350,1470
one version| and then it
|然后它犯下了所有这些事情，

2175
01:13:27,070 --> 01:13:29,320
0,510 570,1020 1020,1890 1890,2010 2010,2250
commits {blah,blah,blah} all this stuff,|
|

2176
01:13:29,350 --> 01:13:31,300
0,330 840,1350 1620,1770 1770,1890 1890,1950
so {} so this is
所以这就是我们要讨论的话题

2177
01:13:31,300 --> 01:13:32,620
0,420 420,540 540,810 810,1170 1170,1320
really the topic here| is
|我们得到了严格的可序列化。

2178
01:13:32,620 --> 01:13:33,280
0,120 120,180 180,300 300,450 450,660
going to do we get

2179
01:13:33,280 --> 01:13:34,500
0,330 330,720 720,1140
strict {serializability -}.|
|

2180
01:13:39,620 --> 01:13:40,520
0,240 240,360 360,480 480,660 660,900
And what I'm gonna do
我要做的是，

2181
01:13:40,520 --> 01:13:41,390
0,210 210,420 420,660 660,720 720,870
is,| I'm {not,going} to give
|我不会给你证据，

2182
01:13:41,390 --> 01:13:42,290
0,90 90,180 180,690 720,780 780,900
you {} proof,| you know
|你知道我得到了严格的可序列化，

2183
01:13:42,290 --> 01:13:43,670
0,210 210,420 420,660 660,1110 1110,1380
I'm getting {strict,serializability -} will

2184
01:13:43,670 --> 01:13:44,510
0,90 90,450 450,570 570,690 690,840
be,| instead what I'm gonna
|相反，我要做的是，

2185
01:13:44,510 --> 01:13:45,140
0,150 150,300 300,360 360,480 480,630
do is,| I'm going to
|我来举一两个例子，

2186
01:13:45,140 --> 01:13:45,830
0,240 240,360 360,510 510,570 570,690
walk for one or two

2187
01:13:45,830 --> 01:13:46,960
0,690
examples,|
|

2188
01:13:47,100 --> 01:13:48,210
0,480 480,600 600,780 780,990 990,1110
{} to get build up
为了建立一些直觉，

2189
01:13:48,210 --> 01:13:49,240
0,150 150,690
some intuition,|
|

2190
01:13:49,500 --> 01:13:50,790
0,150 150,450 450,540 540,1230 1230,1290
and hopefully the intuition you
希望你的直觉能让你确信，事情可能真的会好起来。

2191
01:13:50,790 --> 01:13:51,930
0,150 150,360 360,420 420,780 780,1140
know sort of convinced you

2192
01:13:51,930 --> 01:13:53,130
0,180 180,390 420,810 810,990 990,1200
know that things might actually

2193
01:13:53,130 --> 01:13:53,900
0,90 90,390
be fine.|
|

2194
01:13:54,370 --> 01:13:55,720
0,360 360,660 660,1230 1230,1290 1290,1350
So let's look at the
那么让我们来看一下下面的交易，

2195
01:13:55,720 --> 01:13:57,190
0,210 210,960 1020,1140 1140,1290 1290,1470
{following,transaction -},| we have {TxnBegin
|我们有TxnBegin，

2196
01:13:57,190 --> 01:13:58,380
0,240 240,750
- -},|
|

2197
01:13:59,740 --> 01:14:00,790
0,180 180,300 300,780 780,960 960,1050
and this transaction is,| you
这笔交易是，|你知道，就像在一开始，它读取的是一个对象加1，

2198
01:14:00,790 --> 01:14:02,560
0,330 360,1020 1020,1140 1140,1200 1200,1770
know like in the beginning,

2199
01:14:02,860 --> 01:14:04,240
0,210 210,390 390,480 480,1080
it reads an object

2200
01:14:08,620 --> 01:14:09,880
0,270 270,780
adds 1,|
|

2201
01:14:13,260 --> 01:14:14,580
0,180 180,390 390,960
and then write
然后写入对象并提交或以失败提交结束，

2202
01:14:18,180 --> 01:14:19,540
0,750
{the,object}

2203
01:14:20,040 --> 01:14:22,500
0,450 450,1080 1110,1590 1620,2160
and commits or ends

2204
01:14:23,240 --> 01:14:24,760
0,270 270,510 510,1170
with commit {by,fail},|
|

2205
01:14:26,030 --> 01:14:27,460
0,150 150,360 360,420 420,1110
so that's a transaction.|
所以这是一笔交易。|

2206
01:14:27,810 --> 01:14:29,340
0,690 990,1170 1170,1290 1290,1410 1410,1530
And you know we want
你知道我们想问你自己，

2207
01:14:29,340 --> 01:14:31,170
0,660 660,1080 1080,1560 1560,1740 1740,1830
to ask yourself,| what are
|法律后果是什么，

2208
01:14:31,170 --> 01:14:32,790
0,210 210,570 570,1050 1050,1500 1500,1620
the legal outcomes,| what are
|结果是什么是正确的。

2209
01:14:32,790 --> 01:14:34,580
0,120 120,600 600,990 990,1470
the {outcomes -} correct.|
|

2210
01:14:38,910 --> 01:14:41,380
0,1770 1770,1830

2211
01:14:42,100 --> 01:14:43,480
0,720 750,930 930,1050 1050,1140 1140,1380
{} So what are the
那么，这种拒绝的可能结果是什么，

2212
01:14:43,510 --> 01:14:45,880
0,390 390,720 720,810 810,1020 1020,2370
possible outcomes of this rejection,|
|

2213
01:14:47,290 --> 01:14:48,160
0,240 240,390 390,480 480,570 570,870
what could be the state
会是什么样的状态，

2214
01:14:48,160 --> 01:14:49,540
0,240 330,540 540,810 810,1050 1050,1380
of,| let's say x started
|假设x从0开始

2215
01:14:49,540 --> 01:14:51,580
0,150 150,1200 1320,1560 1560,1680 1680,2040
at 0| and we're running
|我们正在运行两个事务，你知道T1和T2，

2216
01:14:51,580 --> 01:14:52,810
0,150 150,810 810,900 900,1020 1020,1230
two transactions, you know {T1

2217
01:14:52,810 --> 01:14:55,840
0,1260 1860,2280 2280,2730
-} {T2 -},|
|

2218
01:14:57,530 --> 01:14:58,820
0,300 300,360 360,450 450,870 870,1290
what are the possible outcomes
有哪些可能的结果是好的。

2219
01:14:58,820 --> 01:14:59,740
0,180 180,630
that are

2220
01:15:00,260 --> 01:15:01,120
0,660
fine.|
|

2221
01:15:04,080 --> 01:15:05,760
0,420 420,780 780,1230 1230,1380 1380,1680
{} Either one of them
他们中的任何一个都可以承诺，还是他们两个都可以承诺？

2222
01:15:05,760 --> 01:15:06,840
0,180 180,570 570,750 750,990 990,1080
could commit or both of

2223
01:15:06,840 --> 01:15:07,900
0,120 120,330 330,750
them could commit?|
|

2224
01:15:08,260 --> 01:15:09,880
0,420 450,1050 1080,1380 1380,1500 1500,1620
Yeah, and so we can
对，所以我们可以得到x2是正确的，都是x1，

2225
01:15:09,880 --> 01:15:11,680
0,450 450,720 720,1110 1110,1440 1440,1800
have x 2 correct, both

2226
01:15:11,680 --> 01:15:12,480
0,360
commit

2227
01:15:12,930 --> 01:15:15,120
0,390 390,690 690,1140 1320,1980 1980,2190
{} x 1,| possibility one
|一次提交，另一次放弃的可能性，

2228
01:15:15,120 --> 01:15:16,650
0,390 390,450 450,630 630,1110 1110,1530
commit, and one another abort,|
|

2229
01:15:16,650 --> 01:15:18,210
0,420 420,510 510,900 900,1080 1080,1560
general {} truly run concurrently
一般真的是同时运行还是什么的。

2230
01:15:18,210 --> 01:15:18,940
0,90 90,420
or something.|
|

2231
01:15:19,360 --> 01:15:21,370
0,630 720,930 930,1140 1140,1470 1470,2010
And any other possible outcomes?|
还有其他可能的结果吗？|

2232
01:15:23,940 --> 01:15:27,450
0,420 990,1800 1830,2460 2490,2970 3000,3510
0.| Yeah 0,| if basically
0。|是的，0，|如果基本上两个都流产了，对吧，

2233
01:15:27,450 --> 01:15:29,100
0,240 240,660 690,1020 1110,1470 1470,1650
both abort, right,| maybe there's
|也许是撞车了，

2234
01:15:29,100 --> 01:15:29,980
0,60 60,660
a crash,|
|

2235
01:15:30,920 --> 01:15:31,820
0,330 330,450 450,690 690,750 750,900
okay, so those are the
好的，这就是三种法律后果。

2236
01:15:31,820 --> 01:15:33,280
0,240 240,540 540,1200
three legal outcomes.|
|

2237
01:15:33,620 --> 01:15:36,140
0,660 1110,1290 1290,1740 1800,2430 2430,2520
{} So this, you have
所以这个，你必须确保是这样的，

2238
01:15:36,140 --> 01:15:36,800
0,90 90,210 210,330 330,480 480,660
to make sure that is

2239
01:15:36,800 --> 01:15:37,880
0,90 90,330 330,720 780,960 960,1080
the case,| so let's say
|假设T1运行，读取操作也运行，

2240
01:15:37,880 --> 01:15:39,800
0,210 210,450 450,990 1560,1800 1800,1920
{T1 -} runs and so

2241
01:15:39,800 --> 01:15:41,600
0,180 180,240 240,420 420,1110 1560,1800
does a read operation,| get
|将x取回，也许是版本0，

2242
01:15:41,600 --> 01:15:43,190
0,330 330,780 810,1170 1170,1290 1290,1590
x back, maybe at version

2243
01:15:43,190 --> 01:15:45,170
0,570 930,1260 1260,1620 1620,1830 1830,1980
0,| same thing with {T2
|T2也是一样，它写着你知道x0，

2244
01:15:45,170 --> 01:15:46,850
0,510 510,660 660,1140 1140,1260 1260,1680
-}, it reads you know

2245
01:15:46,850 --> 01:15:47,800
0,750
{}

2246
01:15:48,130 --> 01:15:51,040
0,480 570,1470 1560,2430 2550,2760 2760,2910
x 0,| {} and so
|所以它基本上是真正地同时运行

2247
01:15:51,040 --> 01:15:52,390
0,270 270,720 720,840 840,1050 1050,1350
it's basically to run truly

2248
01:15:52,390 --> 01:15:54,940
0,660 1020,1710 2010,2400 2400,2490 2490,2550
concurrent| and this is the
|这是被问到的问题，或者说是我们做的最后一个问题，

2249
01:15:54,940 --> 01:15:56,620
0,270 270,630 630,930 930,1530 1530,1680
question that was asked or

2250
01:15:56,620 --> 01:15:57,760
0,240 240,450 450,720 720,870 870,1140
{the,last} question we do,| lock
|锁x，我们做锁x，

2251
01:15:57,760 --> 01:15:59,410
0,540 540,660 660,810 810,1050 1050,1650
x, we do lock x,|
|

2252
01:16:00,140 --> 01:16:03,170
0,930 1350,2130 2370,2820 2820,2970 2970,3030
and {} here sort of
这是[关键]的一步，正确的，

2253
01:16:03,170 --> 01:16:04,490
0,60 60,360 360,630 630,1020 1020,1320
{} [crucial] step, correct,| because
|因为在这个特殊的时刻，

2254
01:16:04,490 --> 01:16:06,470
0,90 90,240 240,600 600,1140 1170,1980
at this particular point, {}|
|

2255
01:16:06,560 --> 01:16:08,060
0,630 810,1080 1080,1290 1290,1350 1350,1500
where we're trying to get
我们试图锁定对象0，但两个都能成功。

2256
01:16:08,060 --> 01:16:09,350
0,90 90,540 540,900 900,1020 1020,1290
the locks on {object -}

2257
01:16:09,350 --> 01:16:12,260
0,810 1020,1770 2070,2460 2460,2700 2700,2910
0 and {} can both

2258
01:16:12,260 --> 01:16:13,100
0,600
succeed.|
|

2259
01:16:14,860 --> 01:16:18,320
0,270 270,750 1230,1560 1770,2400
In reading.| {In,getting,the,lock,x -}.|
在阅读中。|在获得X锁的过程中。|

2260
01:16:18,610 --> 01:16:19,930
0,420 420,570 570,810 810,930 930,1320
Oh in getting the lock,|
哦，在拿到锁的时候，|

2261
01:16:19,960 --> 01:16:21,250
0,450 450,660 660,750 750,840 840,1290
{} not at the same
不是在同一时间。

2262
01:16:21,250 --> 01:16:23,350
0,600 1230,1380 1380,1560 1560,1650 1650,2100
time.| So one is gonna
|所以有人会成功，有人会成功，对吗？

2263
01:16:23,350 --> 01:16:24,340
0,300 300,390 390,510 510,570 570,990
one is going to succeed,

2264
01:16:24,340 --> 01:16:25,060
0,450
correct.|
|

2265
01:16:25,440 --> 01:16:26,370
0,270 270,390 390,570 570,810 810,930
And so let's say the
让我们假设第一个成功并获得了锁，

2266
01:16:26,370 --> 01:16:27,600
0,240 240,360 360,930 930,1050 1050,1230
first one succeeds and gets

2267
01:16:27,600 --> 01:16:28,480
0,90 90,600
the lock,|
|

2268
01:16:28,820 --> 01:16:29,960
0,210 210,420 420,570 570,690 690,1140
that means it can commit,
这意味着它可以承诺，对，

2269
01:16:29,990 --> 01:16:30,700
0,390
right,|
|

2270
01:16:31,430 --> 01:16:32,630
0,240 240,390 390,600 600,720 720,1200
so this guy will commit,|
所以这家伙会承诺，|

2271
01:16:33,290 --> 01:16:35,390
0,690 720,1260 1290,1590 1590,1860 1860,2100
{} and {} what happens
以及第二个人会发生什么。

2272
01:16:35,390 --> 01:16:36,460
0,90 90,180 180,420 420,780
with the second guy.|
|

2273
01:16:36,870 --> 01:16:38,820
0,600 600,720 720,1020 1020,1620 1680,1950
{} The second one, if
第二个，如果它同时试图获取锁，

2274
01:16:38,820 --> 01:16:39,660
0,90 90,330 330,420 420,750 750,840
it tries to obtain the

2275
01:16:39,660 --> 01:16:40,560
0,270 270,360 360,420 420,660 660,900
lock at the same time,|
|

2276
01:16:40,560 --> 01:16:41,190
0,90 90,210 210,420 420,540 540,630
that the first one is
第一个人拿着锁，

2277
01:16:41,190 --> 01:16:42,060
0,300 300,390 390,630 630,720 720,870
holding the lock,| it will
|它将中止并停止，

2278
01:16:42,060 --> 01:16:44,160
0,240 240,390 390,840 1260,1770 1770,2100
abort and stop,| {} if
|如果第一个事务一直通过并且锁被释放，

2279
01:16:44,160 --> 01:16:45,540
0,150 150,450 450,930 930,1170 1170,1380
the first transaction goes through

2280
01:16:45,540 --> 01:16:46,050
0,90 90,150 150,330 330,450 450,510
all the way and the

2281
01:16:46,050 --> 01:16:48,060
0,240 240,360 360,1110 1380,1860 1860,2010
lock is released,| then it
|然后它将获得锁

2282
01:16:48,060 --> 01:16:49,080
0,150 150,420 420,540 540,900 900,1020
will obtain the lock| and
|然后检查x的版本是否仍然正确，

2283
01:16:49,080 --> 01:16:51,120
0,270 270,810 840,990 990,1410 1410,2040
then check to see whether

2284
01:16:51,120 --> 01:16:52,380
0,270 270,690 690,810 810,900 900,1260
the version that it has

2285
01:16:52,380 --> 01:16:54,120
0,180 180,570 570,810 810,1020 1020,1740
for x is still correct,|
|

2286
01:16:54,210 --> 01:16:55,380
0,510 510,660 660,750 750,930 930,1170
{} and it will find
它会发现版本已经被更改，

2287
01:16:55,380 --> 01:16:56,550
0,330 330,450 450,840 840,1020 1020,1170
that the version has been

2288
01:16:56,550 --> 01:16:57,630
0,630 630,720 720,810 810,900 900,1080
changed,| and then it will
|然后它就会中止。

2289
01:16:57,630 --> 01:16:58,140
0,390
abort.|
|

2290
01:16:58,350 --> 01:17:00,120
0,450 630,960 960,1080 1080,1140 1140,1770
Yep, yep, this is exactly
是的，是的，这就是这两起案件的真相，

2291
01:17:00,120 --> 01:17:02,040
0,180 180,720 1020,1140 1140,1380 1380,1920
the true the two cases,|
|

2292
01:17:02,160 --> 01:17:02,880
0,150 150,270 270,360 360,540 540,720
so let me talk about
所以让我来谈谈验证案例，

2293
01:17:02,880 --> 01:17:05,220
0,510 510,2100 2100,2160 2160,2280 2280,2340
validation case,| {in,this,in,a,second}, with a
|稍等片刻，举一个稍有不同的例子，也许更有趣，

2294
01:17:05,220 --> 01:17:06,510
0,270 270,540 540,930 930,1140 1140,1290
slightly different example, maybe more

2295
01:17:06,510 --> 01:17:08,310
0,510 810,1200 1200,1350 1350,1680 1680,1800
interesting,| {} but this is
|但这基本上就是结果，对吧。

2296
01:17:08,310 --> 01:17:10,160
0,570 570,750 750,1140 1170,1500
basically the outcome, right.|
|

2297
01:17:11,520 --> 01:17:13,860
0,360 510,810 810,1890 1920,2220 2220,2340
Good, and so even though
很好，所以即使这些交易意味着这个特定的画面在准确的同一时间运行，

2298
01:17:13,860 --> 01:17:15,330
0,150 150,630 630,840 840,1050 1080,1470
these transactions mean this particular

2299
01:17:15,330 --> 01:17:16,740
0,270 270,660 660,750 750,1320 1320,1410
picture run {you,know} exactly at

2300
01:17:16,740 --> 01:17:18,720
0,60 60,300 300,840 870,1770 1800,1980
the same time,| {} they
|他们实际上是在被订购

2301
01:17:18,720 --> 01:17:20,190
0,180 180,360 360,570 570,1140 1320,1470
are actually getting ordered| and
|一个赢了另一个输了，

2302
01:17:20,190 --> 01:17:20,940
0,240 240,480 480,570 570,630 630,750
one wins and the other

2303
01:17:20,940 --> 01:17:22,530
0,150 150,750 990,1230 1230,1410 1410,1590
one loses,| that means the
|这意味着另一个输了的人又可以跑了，

2304
01:17:22,530 --> 01:17:23,670
0,120 120,240 240,360 360,720 720,1140
other one that {lost,can} run

2305
01:17:23,670 --> 01:17:25,560
0,480 720,900 900,1050 1050,1590 1590,1890
again,| it will then read
|然后它将读取RX1，然后有望在重试中成功。

2306
01:17:25,560 --> 01:17:27,000
0,240 240,510 510,1020 1110,1230 1230,1440
{Rx1 - -} and then

2307
01:17:27,000 --> 01:17:28,590
0,390 390,870 870,960 960,1080 1080,1590
hopefully succeed in the retry.|
|

2308
01:17:29,370 --> 01:17:30,320
0,660
Okay?|
好吧?|

2309
01:17:32,710 --> 01:17:34,320
0,270 270,600 660,1290
Okay, so. {}|
好的，所以。|

2310
01:17:36,430 --> 01:17:37,460
0,720

2311
01:17:37,700 --> 01:17:38,780
0,1020

2312
01:17:39,910 --> 01:17:41,350
0,300 300,570 570,840 840,1020 1020,1440
Okay, let me do one
好的，让我举个例子，

2313
01:17:41,350 --> 01:17:42,730
0,450 450,540 540,690 690,1050 1050,1380
example,| and then I'll stop
|然后我会停下来，在周四的比赛中继续，

2314
01:17:42,730 --> 01:17:44,290
0,90 90,240 240,630 630,900 900,1560
and I'll resume on the

2315
01:17:44,380 --> 01:17:46,140
0,390 390,870 900,1200 1200,1380
on the {Thursday -},|
|

2316
01:17:46,760 --> 01:17:47,960
0,450 540,750 750,960 960,1050 1050,1200
{} what time is it
现在几点了。

2317
01:17:47,960 --> 01:17:49,040
0,540 570,720 720,810 810,900 900,1080
[24].| Let me make sure
|让我确保你停在这里，

2318
01:17:49,040 --> 01:17:50,720
0,120 120,450 450,870 1080,1260 1260,1680
you stop here,| and then
|然后我会做第二个例子，

2319
01:17:50,720 --> 01:17:52,340
0,480 480,630 630,690 690,960 960,1620
I'll do a second example,|
|

2320
01:17:52,340 --> 01:17:54,620
0,510 990,1320 1320,1440 1440,1830 1830,2280
that answers that earlier question|
这回答了前面的问题|

2321
01:17:54,740 --> 01:17:57,740
0,780 780,1470 1470,1680 1680,2340 2340,3000
{} on on Thursday and
也谈到了容错，

2322
01:17:57,740 --> 01:17:59,330
0,570 570,750 750,930 930,1080 1080,1590
also talk about fault tolerance,|
|

2323
01:18:00,120 --> 01:18:01,440
0,480 480,630 630,780 780,1200 1200,1320
{} I don't want too
随着时间的推移我不想要太多，

2324
01:18:01,440 --> 01:18:02,660
0,360 360,450 450,540 540,900
much {over -} time,|
|

2325
01:18:03,940 --> 01:18:05,470
0,330 330,750 750,930 930,990 990,1530
{} anybody has to go,
任何人都必须离开，请随时离开，

2326
01:18:05,500 --> 01:18:06,520
0,180 180,390 390,540 540,630 630,1020
please feel free to go,|
|

2327
01:18:06,550 --> 01:18:09,010
0,960 1530,1890 1890,2100 2100,2250 2250,2460
{} and {I'll,see} {you,in} {Thursday
我们周四见，

2328
01:18:09,010 --> 01:18:10,630
0,300 300,990 990,1110 1110,1590 1590,1620
-},| anybody who asks I
|如果有人问我，我想问更多的问题，

2329
01:18:10,630 --> 01:18:11,830
0,210 210,390 390,450 450,690 690,1200
would like to ask for

2330
01:18:12,010 --> 01:18:13,210
0,210 210,600 600,1020 1020,1110 1110,1200
{} more questions,| you know,
|你知道，请不要客气

2331
01:18:13,210 --> 01:18:14,590
0,240 240,750 750,930 930,1020 1020,1380
please feel free to stay|
|

2332
01:18:14,590 --> 01:18:16,030
0,240 240,510 510,900 900,990 990,1440
and I'll try the best
我会尽最大努力回答他们，

2333
01:18:16,030 --> 01:18:17,500
0,90 90,510 960,1110 1110,1230 1230,1470
to {answer,them},| as you see,
|如你所见，这是一篇复杂的论文，

2334
01:18:17,500 --> 01:18:19,300
0,150 150,270 270,600 660,1260 1260,1800
this is a complicated paper,|
|

2335
01:18:19,570 --> 01:18:22,150
0,750 750,1950 2010,2220 2220,2490 2490,2580
{} and I'm glad that
我很高兴我们要出去了，

2336
01:18:22,150 --> 01:18:23,140
0,120 120,420 420,630 630,810 810,990
we're going out,| we're able
|我们能够深入到某种程度，并试图真正理解，

2337
01:18:23,140 --> 01:18:23,650
0,90 90,210 210,300 300,450 450,510
to go and sort of

2338
01:18:23,650 --> 01:18:24,640
0,360 360,480 480,720 720,780 780,990
depth and trying to really

2339
01:18:24,640 --> 01:18:26,000
0,450 450,510 510,840
understand,| at least
|至少是正常运行的协议。

2340
01:18:26,600 --> 01:18:29,060
0,510 630,1290 1290,1530 1530,1950 1950,2460
the protocol for normal operation.|
|

2341
01:18:32,490 --> 01:18:33,570
0,270 270,450 450,720 720,930 930,1080
So with that, I just
说到这里，我想结束这堂课，

2342
01:18:33,570 --> 01:18:34,800
0,120 120,330 360,630 630,750 750,1230
like to finish this lecture,|
|

2343
01:18:34,830 --> 01:18:36,600
0,720 1080,1290 1290,1440 1440,1560 1560,1770
and you see your first
你看到了你的第一天，或者如果你有任何问题，请留下来。

2344
01:18:36,600 --> 01:18:37,560
0,240 240,630 630,750 750,840 840,960
day or if you have

2345
01:18:37,560 --> 01:18:38,730
0,150 150,510 510,720 720,870 870,1170
any questions, please hang around.|
|

2346
01:18:40,680 --> 01:18:42,450
0,480 510,600 600,990 990,1290 1290,1770
{} I had two like
我有两个像高级问题一样的问题，

2347
01:18:42,630 --> 01:18:45,630
0,420 510,1050 1050,1560 1560,2100 2310,3000
the high-level questions,| {one,was} {}
|一个是他们正在使用的这个，这个整个硬件结构，

2348
01:18:45,690 --> 01:18:46,640
0,660
this,

2349
01:18:47,300 --> 01:18:50,090
0,330 330,1020 1050,2250 2280,2640 2640,2790
this whole hardware structure that

2350
01:18:50,090 --> 01:18:51,440
0,120 120,240 240,810 930,1230 1230,1350
they are using,| would it
|它到底有没有用，

2351
01:18:51,440 --> 01:18:53,180
0,450 600,1080 1080,1200 1200,1560 1560,1740
be useful at all,| if
|如果您将其与悲观的并发控制一起使用。

2352
01:18:53,180 --> 01:18:54,650
0,210 210,510 510,600 600,780 780,1470
you're using it with pessimistic

2353
01:18:54,650 --> 01:18:56,160
0,120 120,540 540,1260
{concurrency -} control.|
|

2354
01:18:56,680 --> 01:18:58,450
0,870 870,1320 1320,1560 1560,1650 1650,1770
Yes, I'm sure you can
是的，我相信你可以让悲观的协议变得更好，

2355
01:18:58,450 --> 01:19:00,100
0,180 180,420 450,900 900,1350 1350,1650
make the pessimistic {protocol -}

2356
01:19:00,100 --> 01:19:01,870
0,240 240,540 540,1020 1020,1290 1290,1770
also better,| because {you,know,RPC -}
|因为你知道RPC更便宜，对吧，

2357
01:19:01,870 --> 01:19:04,060
0,120 120,360 360,870 900,1290 1770,2190
are just cheaper, right,| but
|但真正我没有的是，我还没能指出这一点，

2358
01:19:04,060 --> 01:19:05,740
0,120 120,360 360,750 750,1080 1080,1680
the real thing I haven't,

2359
01:19:05,740 --> 01:19:06,520
0,210 210,420 420,570 570,720 720,780
I haven't been able to

2360
01:19:06,520 --> 01:19:07,270
0,210 210,330 330,480 480,660 660,750
point this out yet,| but
|但我试过了，

2361
01:19:07,270 --> 01:19:08,650
0,60 60,180 180,480 480,810 1140,1380
I was trying to {},|
|

2362
01:19:08,650 --> 01:19:09,640
0,210 210,270 270,360 360,480 480,990
what I can do now,|
我现在能做的是，|

2363
01:19:09,880 --> 01:19:11,440
0,510 510,1020 1020,1140 1140,1260 1260,1560
{} is if you look
如果你看一下这里的只读交易。

2364
01:19:11,440 --> 01:19:12,610
0,150 150,270 270,450 450,690 690,1170
at the {read-only -} transactions

2365
01:19:12,610 --> 01:19:13,220
0,450
here.|
|

2366
01:19:13,740 --> 01:19:16,500
0,420 450,690 690,930 930,1980 2610,2760
So {read-only -} transactions,| so
因此，只读事务、|因此，如果这里的事务基本上只读取一个对象或多个对象，

2367
01:19:16,500 --> 01:19:17,340
0,120 120,270 270,300 300,300 300,840
if {here -} {} transaction

2368
01:19:17,340 --> 01:19:18,420
0,90 90,390 390,450 450,750 750,1080
that basically the only {reads,an}

2369
01:19:18,420 --> 01:19:24,240
0,450 450,1110 1140,1590 1590,2250
object or multiple objects,|
|

2370
01:19:24,920 --> 01:19:26,060
0,210 210,300 300,780 780,930 930,1140
what's the performance, how good
表演得怎么样，有多好，

2371
01:19:26,060 --> 01:19:27,170
0,120 120,420 450,630 630,870 870,1110
is that,| like how well
|比如它的表现会有多好。

2372
01:19:27,170 --> 01:19:28,380
0,120 120,270 270,390 390,900
is that gonna perform.|
|

2373
01:19:30,520 --> 01:19:32,410
0,420 660,1080 1080,1380 1380,1620 1620,1890
{} Probably pretty well, since
可能很好，因为你只做单边的。

2374
01:19:32,410 --> 01:19:34,990
0,120 120,360 360,570 570,1050 1680,2580
you only do the one-sided.|
|

2375
01:19:35,350 --> 01:19:36,790
0,600 600,1050 1050,1140 1140,1260 1260,1440
Yeah, correct, if you look
是的，正确，如果你看一下存储在区域3的物体，正确的，

2376
01:19:36,790 --> 01:19:37,570
0,90 90,210 210,570 570,690 690,780
at the object that is

2377
01:19:37,570 --> 01:19:40,900
0,720 900,1860 2220,2850 2850,3060 3060,3330
{stored,at} {} region 3, correct,|
|

2378
01:19:40,900 --> 01:19:41,710
0,120 120,210 210,330 330,660 660,810
which is the object that's
它是正在被读取的对象，

2379
01:19:41,710 --> 01:19:43,270
0,210 210,600 750,990 990,1410 1410,1560
being read,| the only thing
|唯一发生的事情是单边读取或单边RDMA，对吗，

2380
01:19:43,270 --> 01:19:44,590
0,120 120,600 600,750 750,990 990,1320
that happens is {one-sided -}

2381
01:19:44,590 --> 01:19:45,740
0,420
reads

2382
01:19:48,350 --> 01:19:50,090
0,150 150,360 360,660 660,1200 1200,1740
or {one-sided -} RDMA, correct,|
|

2383
01:19:51,410 --> 01:19:56,570
0,630 690,3510 3540,4620 4620,4740 4740,5160
{} {and,there's,no,writes}, nothing at all,|
没有文字，什么都没有，|

2384
01:19:56,630 --> 01:19:58,940
0,450 450,900 1140,1620 1650,2040 2040,2310
{} so, {} those {
所以，那些因为这个，

2385
01:19:58,940 --> 01:20:01,280
0,210 210,660 660,750 750,1260 1860,2340
-} because of the this,|
|

2386
01:20:02,670 --> 01:20:04,350
0,360 360,780 810,1110 1110,1470 1470,1680
because the read operation don't
因为读取操作不需要锁定，

2387
01:20:04,350 --> 01:20:05,640
0,420 420,870 870,1020 1020,1230 1230,1290
require locks,| there's nothing to
|没有什么可写的，

2388
01:20:05,640 --> 01:20:07,800
0,150 150,660 960,1410 1470,2040 2040,2160
be written,| {} only thing
|唯一需要做的就是这个验证步骤，

2389
01:20:07,800 --> 01:20:08,490
0,90 90,270 270,360 360,600 600,690
that needs to happen is

2390
01:20:08,490 --> 01:20:10,260
0,450 450,750 750,1200 1230,1530 1530,1770
{this,validation -} step,| which also
|也是单边RDMA，

2391
01:20:10,260 --> 01:20:11,820
0,90 90,150 150,600 600,1290
is {} one-sided RDMA,|
|

2392
01:20:11,990 --> 01:20:13,190
0,360 360,570 570,810 810,1140 1140,1200
so {read-only -} transaction, you
所以只读事务，您可以只使用两个单边RDMA运行，

2393
01:20:13,190 --> 01:20:14,120
0,150 150,300 300,600 600,750 750,930
can just run with two

2394
01:20:14,120 --> 01:20:15,800
0,240 240,570 570,1260
{one-sided -} RDMAs,|
|

2395
01:20:16,180 --> 01:20:17,860
0,600 600,990 990,1470 1470,1620 1620,1680
{} and that's where the
而这就是大地震的由来

2396
01:20:17,860 --> 01:20:20,260
0,240 240,390 390,690 690,990 1560,2400
big one comes from| and
|而这一点的原因是，

2397
01:20:20,260 --> 01:20:21,400
0,90 90,420 420,750 750,1050 1050,1140
the reason that point is

2398
01:20:21,400 --> 01:20:22,420
0,270 270,390 390,660 660,810 810,1020
there is,| because of the
|这是因为乐观的并发控制。

2399
01:20:22,420 --> 01:20:24,040
0,540 540,630 630,930 930,1380
optimistic {concurrency -} control.|
|

2400
01:20:24,400 --> 01:20:25,330
0,150 150,210 210,420 420,810 810,930
So I think basically to
所以我认为基本上是在利用RDMA[愚蠢的]，

2401
01:20:25,330 --> 01:20:26,770
0,720 720,870 870,1230 1230,1350 1350,1440
exploit {RDMAs - -} {}

2402
01:20:26,770 --> 01:20:29,320
0,990 1050,1710 1710,2070 2070,2310 2310,2550
[foolish],| [foolish] and I'm trying
|[愚蠢的]我正试着让只读交易变得非常快，

2403
01:20:29,320 --> 01:20:30,220
0,60 60,360 360,540 540,720 720,900
to make a {read-only -}

2404
01:20:30,220 --> 01:20:33,880
0,510 510,1050 1050,1560 1950,2670 2970,3660
transactions really fast,| { -}
|他们得到了乐观的并发控制。

2405
01:20:33,880 --> 01:20:35,530
0,240 240,510 510,720 720,1020 1020,1650
they got went to optimistic

2406
01:20:35,530 --> 01:20:36,540
0,90 90,420 420,780
{concurrency -} control.|
|

2407
01:20:38,390 --> 01:20:39,830
0,450 450,600 600,930 930,1020 1020,1440
Okay, I see, I see,
好的，我明白了，明白了，有道理，

2408
01:20:40,070 --> 01:20:41,900
0,330 330,810 1020,1440 1440,1710 1710,1830
makes sense,| another question was
|另一个问题是关于安全的，

2409
01:20:41,900 --> 01:20:44,360
0,630 630,1710 1740,2250
about security,| is
|这东西会安全吗，如果它是，

2410
01:20:44,850 --> 01:20:45,960
0,300 300,540 540,750 750,990 990,1110
this thing is gonna be

2411
01:20:45,960 --> 01:20:47,360
0,450 450,660 660,1140
secure, if it's,|
|

2412
01:20:47,540 --> 01:20:48,460
0,630

2413
01:20:48,770 --> 01:20:50,330
0,150 150,390 390,780 960,1290 1290,1560
I guess if someone already
我想如果有人已经问过这件事，

2414
01:20:50,330 --> 01:20:51,680
0,210 210,420 420,570 570,960
asked about this,| but
|但网卡只是读取内存的那部分，

2415
01:20:51,820 --> 01:20:53,830
0,450 450,810 810,1290 1290,1650 1650,2010
The part where the NIC

2416
01:20:53,830 --> 01:20:55,870
0,360 390,780 780,1470 1590,1980 1980,2040
just reads memory,| {it,seems} a
|这看起来有点吓人。

2417
01:20:55,870 --> 01:20:58,810
0,210 210,960 1080,2100 2100,2250 2520,2940
little {scary,so}.| Yeah, {it's,totally} scary,|
|是啊，真的很吓人，|

2418
01:20:59,410 --> 01:21:01,150
0,480 480,690 690,810 810,1320 1320,1740
{} and so there's there's
因此，有一系列的互动，

2419
01:21:01,150 --> 01:21:02,620
0,120 120,330 330,390 390,1080 1080,1470
a bunch of interaction {}

2420
01:21:02,620 --> 01:21:03,940
0,630 630,690 690,840 840,1110 1110,1320
between,| you know when the
|您知道何时在应用程序中设置RDMA连接和操作系统。

2421
01:21:03,940 --> 01:21:05,530
0,540 540,960 960,1050 1050,1260 1260,1590
RDMA connection is {setup -}

2422
01:21:05,680 --> 01:21:06,880
0,360 360,480 480,840 840,1140 1140,1200
{} the operating system in

2423
01:21:06,880 --> 01:21:07,800
0,90 90,690
the application.|
|

2424
01:21:09,780 --> 01:21:10,800
0,180 180,270 270,540 540,780 780,1020
So the operating system won't
因此，操作系统不允许网卡写入任何任意位置，

2425
01:21:10,800 --> 01:21:12,390
0,480 480,810 810,1140 1140,1260 1260,1590
allow the NIC to write

2426
01:21:12,390 --> 01:21:14,220
0,90 90,690 690,1200 1200,1740 1740,1830
to any arbitrary location,| will
|我会告诉它，你知道这里的地址，这是你可以写入的VM，虚拟内存地址。

2427
01:21:14,220 --> 01:21:16,410
0,390 780,930 930,1260 1260,1650 1680,2190
{tell,it}, {you,know} here the addresses,

2428
01:21:16,410 --> 01:21:18,510
0,510 510,930 1200,1680 1680,1830 1860,2100
here's the VM, {} virtual

2429
01:21:18,510 --> 01:21:19,530
0,270 270,660 660,810 810,900 900,1020
memory addresses, that you can

2430
01:21:19,530 --> 01:21:20,320
0,180 180,300
write to.|
|

2431
01:21:21,230 --> 01:21:22,700
0,300 300,390 390,510 510,960 1140,1470
Okay so you can make
好的，所以你可以让它变得[富有成效]。

2432
01:21:22,700 --> 01:21:24,620
0,510 690,1440
that [productive].|
|

2433
01:21:24,790 --> 01:21:25,840
0,300 300,720
Okay.| Exactly.|
好吧。|一点儿没错。|

2434
01:21:26,150 --> 01:21:30,260
0,1050 1050,1350 1350,1860 2100,3060 3780,4110
Question about the performance,| so
关于表演的问题，|因此，如果你有，所以阅读是快速的，

2435
01:21:30,260 --> 01:21:31,910
0,270 270,420 420,840 960,1200 1200,1650
if you have, so the

2436
01:21:31,910 --> 01:21:33,680
0,300 300,570 570,930 1020,1410 1410,1770
reads are {} quick,| because
|由于RDMA的片面性，

2437
01:21:33,680 --> 01:21:35,180
0,180 180,540 540,840 840,1230 1230,1500
of the {one-sided -} {RDMAs

2438
01:21:35,180 --> 01:21:37,010
0,600 1380,1530 1530,1620 1620,1710 1710,1830
-},| but if you have
|但如果你有大量的写作，

2439
01:21:37,010 --> 01:21:38,720
0,60 60,300 300,690 750,1200 1200,1710
a lot of writes happening,|
|

2440
01:21:38,720 --> 01:21:39,680
0,330 330,480 480,660 660,720 720,960
like a lot of data
喜欢大量的数据和争论。

2441
01:21:39,680 --> 01:21:41,900
0,150 150,900 1020,1560 1740,1980 1980,2220
and contention.| { -} Yeah.|
|嗯。|

2442
01:21:41,900 --> 01:21:44,000
0,240 240,420 420,870 900,1470 1530,2100
So like is, or.| No,
就像是，或者。|不，正确，

2443
01:21:44,000 --> 01:21:45,230
0,630 630,780 780,1020 1020,1140 1140,1230
correct,| what happens if you
|如果你有争执会发生什么

2444
01:21:45,230 --> 01:21:46,730
0,120 120,630 750,1230 1230,1380 1380,1500
have contention,| actually we saw
|实际上我们在这个特殊的案例中看到了这一点，对吧。

2445
01:21:46,730 --> 01:21:47,780
0,180 180,270 270,390 390,750 750,1050
this in this particular case,

2446
01:21:47,780 --> 01:21:48,340
0,420
correct.|
|

2447
01:21:49,590 --> 01:21:52,240
0,1260 1830,2370
Yeah, {}
是啊，如果我们有很多争执，

2448
01:21:52,860 --> 01:21:53,370
0,180 180,270 270,360 360,360 360,510
if we have a lot

2449
01:21:53,370 --> 01:21:54,480
0,90 90,420 420,570 570,660 660,1110
of contention,| one of the
|其中一个事务将中止。

2450
01:21:54,510 --> 01:21:55,740
0,390 390,930
transaction {will,abort}.|
|

2451
01:21:57,310 --> 01:21:58,510
0,210 210,390 390,480 480,1110 1110,1200
So this is really you
所以这真的是对交易有好处，

2452
01:21:58,510 --> 01:22:00,010
0,120 120,390 390,570 570,1140 1140,1500
know good for transactions,| that
|不满足于或不写入相同记录或相同对象的。

2453
01:22:00,010 --> 01:22:01,960
0,240 240,870 1080,1380 1380,1650 1650,1950
don't content or not writing

2454
01:22:01,960 --> 01:22:03,100
0,90 90,180 180,480 480,930 960,1140
to the same records or

2455
01:22:03,100 --> 01:22:04,120
0,240 240,750
same objects.|
|

2456
01:22:05,200 --> 01:22:06,580
0,330 330,540 540,630 630,960 960,1380
And even the reads, right?|
甚至是阅读，对吗？|

2457
01:22:07,510 --> 01:22:08,830
0,360 360,600 600,870 870,1260 1260,1320
Yeah, even {the,reads},| because the
是啊，即使是读物，|因为版本号可能会改变。

2458
01:22:08,830 --> 01:22:10,300
0,270 270,540 540,660 660,1200
version numbers may change.|
|

2459
01:22:13,200 --> 01:22:14,370
0,210 210,420 420,630 630,720 720,1170
So what's like the main,
那么，我想主要的用例是什么。

2460
01:22:14,370 --> 01:22:15,840
0,390 420,570 570,870 870,1110 1110,1470
{} I guess use case

2461
01:22:15,840 --> 01:22:16,740
0,600
for.|
|

2462
01:22:17,030 --> 01:22:17,810
0,210 210,360 360,420 420,570 570,780
{} There's a lot of,
有很多，你知道的，有很多研究

2463
01:22:17,810 --> 01:22:19,010
0,90 90,540 540,870 870,960 960,1200
you know there's a lot

2464
01:22:19,010 --> 01:22:20,990
0,60 60,600 600,1110 1110,1680 1680,1980
of studies| independent {of,this,paper} about
|与这篇关于悲观与乐观并发控制的文章无关，

2465
01:22:20,990 --> 01:22:22,550
0,510 510,750 750,1170 1170,1260 1260,1560
pessimistic versus optimistic {concurrency -}

2466
01:22:22,550 --> 01:22:23,440
0,480
control,|
|

2467
01:22:23,640 --> 01:22:25,680
0,510 510,1260 1260,1410 1410,1590 1590,2040
{} and you know clearly
从这两个基准中，你可以清楚地知道，

2468
01:22:25,680 --> 01:22:27,150
0,270 270,540 540,690 690,1230 1230,1470
from the two benchmarks,| they
|他们在论文中使用的，如TPC-C和TATP，

2469
01:22:27,150 --> 01:22:28,560
0,300 300,390 390,750 750,930 930,1410
{use,in} the paper, like {TPC-C

2470
01:22:28,560 --> 01:22:30,360
0,330 330,450 450,1290 1440,1620 1620,1800
-} and TATP,| {} there's
|没有太多的冲突，

2471
01:22:30,360 --> 01:22:33,030
0,690 690,1500 1530,1980 1980,2040 2040,2670
not a lot of conflicts,|
|

2472
01:22:35,670 --> 01:22:36,990
0,240 240,720 720,810 810,1080 1080,1320
{so,this,is} {actually -} submitted maybe
所以这实际上可能是由不同的用户或不同的客户端提交的

2473
01:22:36,990 --> 01:22:38,220
0,120 120,360 360,900 900,990 990,1230
by different users or different

2474
01:22:38,220 --> 01:22:39,540
0,480 480,600 600,720 720,1050 1050,1320
clients| and they basically touch
|它们基本上接触的是不同的桌子。

2475
01:22:39,540 --> 01:22:40,620
0,240 240,780
different tables.|
|

2476
01:22:45,650 --> 01:22:47,180
0,210 210,300 300,510 510,720 720,1530
So I have a question,|
所以我有一个问题，|

2477
01:22:47,210 --> 01:22:49,670
0,660 690,930 930,1200 1200,1710 1710,2460
{} if there's multiple clients
如果有多个客户端在同一对象上执行事务，

2478
01:22:50,170 --> 01:22:52,210
0,420 420,1410 1410,1590 1590,1680 1680,2040
doing transactions on the same

2479
01:22:52,210 --> 01:22:54,940
0,810 930,1470 1590,2340
object, { -}|
|

2480
01:22:55,170 --> 01:22:56,910
0,870 930,1170 1170,1440 1440,1650 1650,1740
how should,| they want to
应该怎么做，|他们想要执行写入RDMA，写入到日志，

2481
01:22:56,910 --> 01:22:58,680
0,150 150,510 510,870 870,1440 1440,1770
do a write RDMA, write

2482
01:22:58,680 --> 01:23:00,540
0,690 690,840 840,960 960,1560
to to the log,|
|

2483
01:23:00,970 --> 01:23:02,080
0,810

2484
01:23:02,960 --> 01:23:04,310
0,210 210,390 390,960 960,1140 1140,1350
is it possible that there
有没有可能会发生冲突，

2485
01:23:04,310 --> 01:23:05,750
0,120 120,240 240,450 450,1170 1170,1440
would be {} conflict,| like
|您是否希望其中一个会重写另一个日志，或者。

2486
01:23:05,750 --> 01:23:06,650
0,120 120,270 270,540 540,810 810,900
do you like one of

2487
01:23:06,650 --> 01:23:07,580
0,180 180,330 330,570 570,840 840,930
them will write over the

2488
01:23:07,580 --> 01:23:09,170
0,270 270,750 750,1050 1050,1110 1110,1590
other log, or.| {No,no -},
|不，不，每对都有一把锁，

2489
01:23:09,170 --> 01:23:11,180
0,240 240,450 450,750 750,1410 1440,2010
there's one lock per pair,|
|

2490
01:23:11,860 --> 01:23:13,930
0,300 300,690 690,810 870,1740 1770,2070
{} One {lock,per,pair}, okay.| So
一把锁一把，好的。|因此，这正是原因所在。

2491
01:23:13,930 --> 01:23:15,250
0,420 420,660 660,960 960,1050 1050,1320
every this exactly the reason

2492
01:23:15,250 --> 01:23:16,040
0,420
why.|
|

2493
01:23:17,040 --> 01:23:18,690
0,240 240,420 420,660 660,660 1260,1650
And and then, {} but
然后，但在[时代]这样的交易中，

2494
01:23:18,720 --> 01:23:21,600
0,690 690,1230 1260,2130 2130,2370 2370,2880
{} in transactions like [time],|
|

2495
01:23:21,630 --> 01:23:23,880
0,120 120,420 420,1500 1530,1560 1560,2250
is it like {} to
它是否喜欢提供可序列化、

2496
01:23:23,880 --> 01:23:26,940
0,690 780,1830 2190,2340 2340,2550 2550,3060
provide serializability,| is it time
|是不是时候基于什么。

2497
01:23:27,000 --> 01:23:29,040
0,1140 1140,1290 1290,1740
based on what.|
|

2498
01:23:29,260 --> 01:23:30,500
0,240 240,300 300,510 510,930
On the version number.|
在版本号上。|

2499
01:23:30,880 --> 01:23:31,680
0,480

2500
01:23:31,940 --> 01:23:33,170
0,210 210,570 570,720 720,930 930,1230
There's nothing like true type
这里没有真正的类型或类似的东西，

2501
01:23:33,170 --> 01:23:34,280
0,120 120,390 390,600 600,780 780,1110
or anything like that here,|
|

2502
01:23:34,740 --> 01:23:36,060
0,360 360,540 540,870 870,1170 1170,1320
{} these logical numbers, like
这些逻辑数字，就像在实验3中一样，

2503
01:23:36,060 --> 01:23:36,960
0,90 90,390 390,630 630,810 810,900
in same way as in

2504
01:23:36,960 --> 01:23:39,000
0,750 750,1050 1050,1230 1230,1620 1620,2040
{lab,3},| where you have logical
|其中，您有用于实现键值存储的逻辑序列号，

2505
01:23:39,000 --> 01:23:40,200
0,360 360,840
sequence numbers,

2506
01:23:40,670 --> 01:23:42,320
0,330 330,750 750,1230 1230,1320 1320,1650
for implementing your {key-value -}

2507
01:23:42,320 --> 01:23:43,020
0,390
store,|
|

2508
01:23:43,460 --> 01:23:44,840
0,390 390,720 720,1080 1080,1320 1320,1380
there's numbers basically played the
数字基本上起到了同样的作用。

2509
01:23:44,840 --> 01:23:45,740
0,240 240,630
same role.|
|

2510
01:23:53,940 --> 01:23:55,560
0,240 240,540 540,900 900,1440 1440,1620
Well, if two number of
好吧，如果两笔交易中的两笔交易得到了相同的数字，

2511
01:23:55,560 --> 01:23:57,240
0,180 180,780 780,990 990,1050 1050,1680
two transactions got the same

2512
01:23:57,720 --> 01:23:59,790
0,780 780,1200 1440,1770 1770,1860 1860,2070
number,| then only the one
|那么只有最先到达提交点的那个才会离开。

2513
01:23:59,790 --> 01:24:01,140
0,390 390,720 720,810 810,960 960,1350
that got to the commit

2514
01:24:01,140 --> 01:24:03,300
0,360 360,840 840,960 960,1380 1800,2160
point first is going.| Yeah.|
|嗯。|

2515
01:24:03,300 --> 01:24:03,960
0,480
Okay.|
好吧。|

2516
01:24:04,640 --> 01:24:05,570
0,180 180,390 390,450 450,630 630,930
Yeah, this is this case,
是的，就是这个案子，对吧，

2517
01:24:05,570 --> 01:24:06,200
0,330
right,|
|

2518
01:24:06,770 --> 01:24:07,970
0,240 240,450 450,840 840,1050 1050,1200
one {abort -}, {the,other} {one
一次失败，另一次成功。

2519
01:24:07,970 --> 01:24:08,880
0,150 150,600
-} succeed.|
|

2520
01:24:11,880 --> 01:24:13,980
0,930 1590,1770 1770,1890 1890,2040 2040,2100
Okay.| If there is a
好吧。|如果在每一对之间基本上建立了消息队列，

2521
01:24:13,980 --> 01:24:15,720
0,390 390,630 630,840 840,1110 1320,1740
message queue that is basically

2522
01:24:15,720 --> 01:24:18,120
0,630 630,960 960,1200 1200,1740 2010,2400
established between every pair,| then
|那你怎么知道，

2523
01:24:18,120 --> 01:24:20,040
0,270 270,360 360,540 540,1230 1680,1920
how do you know,| so
|因此，在给定主队列的情况下，您将拥有多个消息队列，

2524
01:24:20,040 --> 01:24:21,750
0,210 210,360 360,690 690,1110 1110,1710
then you'd have multiple message

2525
01:24:21,750 --> 01:24:24,270
0,690 1410,1860 1860,2280 2280,2430 2430,2520
queues, given primary,| how do
|你怎么知道读这些东西的顺序呢？

2526
01:24:24,270 --> 01:24:25,320
0,90 90,300 300,630 630,930 930,1050
you know which order to

2527
01:24:25,320 --> 01:24:27,090
0,210 210,510 510,810 1350,1590 1590,1770
read those| and you don't
|而且你不会乱读它们的顺序。

2528
01:24:27,090 --> 01:24:28,170
0,150 150,300 300,450 450,540 540,1080
read them out of order.|
|

2529
01:24:28,650 --> 01:24:32,760
0,2790 2790,3090 3390,3660 3660,3900 3900,4110
{There,is -} you read all
你以相同的顺序阅读来自同一来源的所有消息，对吗，

2530
01:24:32,760 --> 01:24:34,410
0,90 90,480 480,660 660,1110 1110,1650
the messages from one source

2531
01:24:34,410 --> 01:24:35,370
0,90 90,180 180,450 450,720 720,960
in the same order, correct,|
|

2532
01:24:35,370 --> 01:24:36,570
0,240 240,420 420,570 570,720 720,1200
because they're all gonna be
因为他们都会排在一个队里，

2533
01:24:36,600 --> 01:24:37,620
0,150 150,390 390,900
in one queue,|
|

2534
01:24:37,810 --> 01:24:39,130
0,240 240,510 510,810 810,1050 1050,1320
so one source {writes,to} one
因此一个源写入一个队列，

2535
01:24:39,130 --> 01:24:39,820
0,390
queue,|
|

2536
01:24:40,240 --> 01:24:43,720
0,480 510,1560 1710,2520 2550,3210 3210,3480
{} multiple {} machines like
像这样的多台机器同时写入不同的队列，

2537
01:24:43,720 --> 01:24:45,250
0,390 390,480 480,570 570,1020 1020,1530
write you know concurrently to

2538
01:24:45,250 --> 01:24:47,170
0,300 300,660 660,1200 1440,1800 1800,1920
{} different queues,| {} you
|不管怎么说，你不知道顺序是什么，

2539
01:24:47,170 --> 01:24:47,950
0,150 150,270 270,450 450,540 540,780
don't know what the order

2540
01:24:47,950 --> 01:24:48,940
0,810
anyway,|
|

2541
01:24:49,770 --> 01:24:51,390
0,270 270,840 840,1110 1110,1410 1410,1620
so it could affect the
因此，它可能会影响协议的正确性。

2542
01:24:51,750 --> 01:24:53,140
0,390 390,480 480,570 570,1080
correctness of the protocol.|
|

2543
01:24:54,270 --> 01:24:55,110
0,150 150,390 390,540 540,630 630,840
I see, so we don't
我明白了，所以我们不依赖于传入并发消息的顺序。

2544
01:24:55,110 --> 01:24:56,400
0,240 240,360 360,450 450,1080 1080,1290
rely on the orderings of

2545
01:24:56,400 --> 01:24:59,130
0,480 870,1350 1350,1830 1830,2460 2490,2730
the incoming concurrent messages.| That's
|没错，你是按一定的顺序投票的

2546
01:24:59,130 --> 01:25:00,240
0,390 390,660 660,900 900,1050 1050,1110
correct, you poll them in

2547
01:25:00,240 --> 01:25:01,560
0,240 240,660 660,750 750,1170 1230,1320
some order| and then you
|然后你按一定的顺序轮询队列，

2548
01:25:01,560 --> 01:25:02,370
0,210 210,270 270,510 510,600 600,810
poll the queues in some

2549
01:25:02,370 --> 01:25:03,570
0,360 360,600 600,690 690,1020 1020,1200
order,| that's the way, that's
|这就是方式，这就是要处理的方式。

2550
01:25:03,570 --> 01:25:04,380
0,90 90,300 300,480 480,720 720,810
the way that's going to

2551
01:25:04,380 --> 01:25:05,360
0,240 240,810
be processed.|
|

2552
01:25:06,950 --> 01:25:08,780
0,270 270,540 600,1140 1140,1350 1350,1830
Got it, also one more
明白了，还有一个更具体的问题，

2553
01:25:08,900 --> 01:25:11,900
0,540 540,1230 1500,2100 2370,2820 2820,3000
specific question,| {} there's a
|有一部分，这是一份提供无锁定读取的文件，

2554
01:25:11,900 --> 01:25:12,890
0,300 300,540 540,840 840,930 930,990
part where this is a

2555
01:25:12,890 --> 01:25:14,930
0,420 420,690 690,1230 1230,1710 1740,2040
paper that provides lock {lock-free,reads

2556
01:25:14,930 --> 01:25:16,310
0,450 450,690 690,930 930,1140 1140,1380
-},| which we've just talked
|也就是我们刚才谈到的

2557
01:25:16,310 --> 01:25:18,410
0,420 780,1230 1230,1440 1440,1710 1710,2100
about,| but it also says
|但它也表示，它还提供了地点提示，

2558
01:25:18,410 --> 01:25:20,330
0,210 210,570 660,1140 1140,1440 1440,1920
it { -} also provides

2559
01:25:20,330 --> 01:25:23,480
0,750 750,1350 1500,1860 1860,2400 2400,3150
locality hints,| which enable programmers
|这使得程序员能够将同一组机器上的相关对象相互关联，

2560
01:25:23,480 --> 01:25:25,550
0,210 240,570 570,1050 1050,1530 1530,2070
to co relate related objects

2561
01:25:25,550 --> 01:25:26,450
0,180 180,270 270,630 630,840 840,900
on the same set of

2562
01:25:26,450 --> 01:25:28,370
0,840 870,1050 1050,1410 1590,1770 1770,1920
machines,| you know and I
|你知道，我不理解那个锁，句子的后半部分。

2563
01:25:28,370 --> 01:25:29,680
0,150 150,390 390,840 840,1140
do not understand that

2564
01:25:29,820 --> 01:25:31,200
0,450 450,570 570,1050 1050,1290 1290,1380
lock, the latter part of

2565
01:25:31,200 --> 01:25:32,320
0,60 60,870
the sentence.|
|

2566
01:25:32,550 --> 01:25:34,530
0,690 690,900 900,1020 1020,1530 1530,1980
{} Okay, so I I
好的，所以我我得查一下细节是什么，

2567
01:25:34,530 --> 01:25:35,070
0,120 120,180 180,330 330,450 450,540
have to look up the

2568
01:25:35,070 --> 01:25:35,910
0,330 330,450 450,570 570,720 720,840
details what it is,| but
|但我想你指的是，

2569
01:25:35,910 --> 01:25:36,780
0,30 30,210 210,330 330,480 480,870
I think what you're referring

2570
01:25:36,780 --> 01:25:38,040
0,180 180,360 360,600 600,750 750,1260
to is that,| if you
|如果您愿意，如果您的对象是各种不同的区域，对吗，

2571
01:25:38,220 --> 01:25:39,660
0,420 510,750 750,1020 1020,1320 1320,1440
like if your objects are

2572
01:25:39,660 --> 01:25:40,920
0,270 270,450 450,540 540,810 810,1260
all kinds of different regions,

2573
01:25:40,920 --> 01:25:41,880
0,240 240,450 480,780 780,900 900,960
correct,| like let's look at
|比如，让我们看看这张照片，

2574
01:25:41,880 --> 01:25:43,060
0,150 150,480 480,990
this picture here,|
|

2575
01:25:43,230 --> 01:25:44,220
0,510 510,630 630,750 750,930 930,990
then you would have to
然后你就必须和很多不同的初选进行交流，对吧，

2576
01:25:44,220 --> 01:25:45,600
0,240 240,390 390,660 660,750 750,1380
talk to lots of different

2577
01:25:45,630 --> 01:25:47,670
0,900 1140,1440 1440,1590 1590,1920 1920,2040
primaries, right,| so if you
|所以如果你反对第一个物体在这个主要物体中，物体二在这个主要物体中，

2578
01:25:47,670 --> 01:25:49,680
0,390 390,840 840,1050 1050,1350 1350,2010
object one {is,in} this primary,

2579
01:25:49,710 --> 01:25:51,330
0,420 420,600 600,660 660,960 960,1620
object two {is,in} this primary,|
|

2580
01:25:51,630 --> 01:25:52,920
0,720 720,990 990,1050 1050,1200 1200,1290
{} and if you are
如果你接触到很多人，

2581
01:25:52,920 --> 01:25:54,720
0,300 300,630 630,1350 1350,1500 1500,1800
touching many,| if you're touching
|如果你总是在触摸一堆物体，

2582
01:25:54,720 --> 01:25:55,860
0,360 360,420 420,720 720,780 780,1140
always a cluster of objects

2583
01:25:55,860 --> 01:25:57,240
0,540 630,750 750,930 930,1050 1050,1380
together,| it would be nice
|如果所有对象集群都在同一主服务器上，

2584
01:25:57,240 --> 01:25:58,230
0,60 60,210 210,480 480,570 570,990
if that cluster of objects

2585
01:25:58,230 --> 01:25:59,310
0,180 180,270 270,330 330,570 570,1080
all at the same primary,|
|

2586
01:25:59,910 --> 01:26:00,690
0,180 180,360 360,570 570,690 690,780
so you only have to
所以你只需联系一个小学，而不是多个。

2587
01:26:00,690 --> 01:26:01,920
0,330 330,540 540,930 930,1170 1170,1230
contact one primary instead of

2588
01:26:01,920 --> 01:26:02,620
0,390
many.|
|

2589
01:26:05,520 --> 01:26:07,040
0,270 270,630 660,930 930,1200
I see, thank you.|
我明白了，谢谢你。|

2590
01:26:13,170 --> 01:26:14,660
0,450 450,690 690,1230
Any further questions?|
还有什么问题吗？|

2591
01:26:18,180 --> 01:26:20,160
0,510 510,1110 1170,1440 1440,1860 1860,1980
So this, so FaRM is
所以这个，所以农场不是很适合做多的交易，对，

2592
01:26:20,160 --> 01:26:22,050
0,270 270,450 450,960 960,1440 1470,1890
not really suitable for long

2593
01:26:22,050 --> 01:26:26,220
0,1230 1350,1890 1920,2730 2970,3600 3750,4170
transactions, right,| because because most.|
|因为大多数人。|

2594
01:26:27,240 --> 01:26:28,560
0,450 450,660 660,1020 1020,1110 1110,1320
Yeah, you're worried {} long
是的，你担心长时间的交易会导致冲突。

2595
01:26:28,560 --> 01:26:29,520
0,60 60,540 540,690 690,810 810,960
of transactions that you get

2596
01:26:29,520 --> 01:26:30,320
0,630
conflicts.|
|

2597
01:26:32,290 --> 01:26:33,970
0,150 150,390 390,600 600,1230 1290,1680
I mean, it also is
我的意思是，它也假设我猜只读交易，

2598
01:26:33,970 --> 01:26:36,190
0,720 720,810 810,1350 1620,2010 2010,2220
assuming I guess {read-only -}

2599
01:26:36,190 --> 01:26:38,770
0,720 720,1290 1530,1770 1770,1980 1980,2580
transactions,| since we're really optimized
|因为我们真的为他们做了优化，对吧。

2600
01:26:38,770 --> 01:26:41,410
0,90 90,270 270,660 720,1200 1620,2640
for them, right.| Yeah, absolutely,|
|是啊，当然了，|

2601
01:26:41,410 --> 01:26:43,000
0,300 300,870 870,1200 1200,1410 1410,1590
many transactions {you,know} people don't
很多你知道的人们不会研究的交易

2602
01:26:43,000 --> 01:26:44,350
0,420 420,660 660,780 780,1140 1140,1350
studies| and you know you
|你知道你在扳手纸上也看到了，对吗？

2603
01:26:44,350 --> 01:26:45,400
0,180 180,330 330,450 450,900 900,1050
saw in Spanner paper too,

2604
01:26:45,400 --> 01:26:46,060
0,360
correct,|
|

2605
01:26:46,250 --> 01:26:47,720
0,570 600,690 690,990 990,1380 1380,1470
where a large fraction of
其中很大一部分事务是只读事务。

2606
01:26:47,720 --> 01:26:49,040
0,270 270,780 780,930 930,1110 1110,1320
the transactions are {read-only -}

2607
01:26:49,040 --> 01:26:49,960
0,660
transactions.|
|

2608
01:26:53,710 --> 01:26:54,670
0,180 180,300 300,630 630,690 690,960
But it's clearly {} property
但这显然是工作量所致。

2609
01:26:54,670 --> 01:26:55,620
0,60 60,150 150,630
of the workload.|
|

2610
01:27:01,300 --> 01:27:03,130
0,660 750,900 900,1260 1290,1440 1440,1830
{} I had, I think,
我想，回到我之前的问题，

2611
01:27:03,650 --> 01:27:04,910
0,330 330,750 750,840 840,960 960,1260
going back to my earlier

2612
01:27:04,910 --> 01:27:06,620
0,330 330,480 480,630 630,870 870,1710
question,| I think I realized,
|我想我意识到，我误解了BASIC关于严格序列化的概念，

2613
01:27:07,100 --> 01:27:10,070
0,240 240,510 510,1590 1650,2640 2640,2970
I was misunderstanding basic about

2614
01:27:10,070 --> 01:27:13,370
0,270 270,750 750,1470 2880,3120 3120,3300
strict {serializability -},| is it,
|是不是很严格，

2615
01:27:13,370 --> 01:27:16,160
0,600 1320,1980 1980,2370 2370,2580 2580,2790
so {} strict,| so okay,
|所以好的，这是一个情况，

2616
01:27:16,160 --> 01:27:17,750
0,150 150,540 540,720 720,900 900,1590
so here's here's a situation,|
|

2617
01:27:18,350 --> 01:27:20,480
0,630 810,1020 1020,1290 1290,1530 1530,2130
{} say here's one transaction
假设这里有一笔交易首先开始，

2618
01:27:20,480 --> 01:27:22,940
0,180 180,630 630,1170 1170,1500 1590,2460
that begins first,| that writes
|它写入碎片1、碎片2和读取碎片3，

2619
01:27:23,030 --> 01:27:24,890
0,390 390,720 720,1140 1140,1470 1470,1860
{} shard 1, shard 2

2620
01:27:24,890 --> 01:27:26,220
0,180 180,390 390,750 750,1170
and read shard 3,|
|

2621
01:27:27,700 --> 01:27:28,900
0,120 120,240 240,540 600,930 930,1200
and so that that begins
所以这就像第一次一样开始了。

2622
01:27:28,900 --> 01:27:32,290
0,180 180,600 600,990 1110,2610 2610,3390
like first time.| Write object,
|写对象，写0，写x 0，写y 0。

2623
01:27:33,100 --> 01:27:37,000
0,390 390,1200 1380,2880 2880,3060 3060,3900
write 0, write x 0,

2624
01:27:37,030 --> 01:27:38,830
0,600 600,780 780,1440 1530,1650 1650,1800
{write,y} {} 0.| And then
|然后读z。

2625
01:27:38,830 --> 01:27:42,400
0,510 510,1020 1320,1620 1620,2130 2160,3570
reads z.| Okay, reads z0.|
|好的，读的是Z0。|

2626
01:27:43,180 --> 01:27:45,430
0,810 1020,1320 1320,1590 1590,1980 1980,2250
And then say, there's this
然后，假设有第二个事务在事务开始后开始。

2627
01:27:45,430 --> 01:27:48,310
0,390 390,1350 1470,1710 1710,2130 2130,2880
second transaction that begins after

2628
01:27:48,310 --> 01:27:50,290
0,630 630,780 780,1350 1680,1860 1860,1980
transaction has started.| You know
|你知道，就像这里。

2629
01:27:50,290 --> 01:27:52,930
0,210 210,690 1230,2160 2250,2430 2430,2640
like here.| Yeah, and it
|是的，它写的是z。

2630
01:27:52,930 --> 01:27:53,700
0,690
writes

2631
01:27:53,940 --> 01:27:54,860
0,600
z.|
|

2632
01:27:55,670 --> 01:27:57,710
0,270 270,720 720,1230 1230,1740 1770,2040
So before before {} write
所以在写z之前，

2633
01:27:57,710 --> 01:27:58,940
0,180 180,270 270,540 540,930 930,1230
z,| the must write z
|必须在这里写上z。

2634
01:27:58,940 --> 01:28:01,310
0,420 750,1170 1170,1770 1800,2070 2070,2370
here.| {} Yeah.| And so
|嗯。|如果z是什么版本号，它会读取。

2635
01:28:01,310 --> 01:28:03,260
0,120 120,1020 1230,1470 1470,1740 1740,1950
if z what version number

2636
01:28:03,260 --> 01:28:04,140
0,180 180,270 270,600
does it read.|
|

2637
01:28:05,740 --> 01:28:06,740
0,630

2638
01:28:07,260 --> 01:28:08,520
0,150 150,600 630,780 780,1020 1020,1260
The same, the same one
一样的，一样的。

2639
01:28:09,810 --> 01:28:12,120
0,600 840,1260 1260,1380 1380,1650 1650,2310
[].| And then say reads
|然后说尝试写z的读数，

2640
01:28:12,120 --> 01:28:13,440
0,270 270,510 510,630 630,870 870,1320
that tries to write z,|
|

2641
01:28:16,500 --> 01:28:17,670
0,300 300,570 570,690 690,930 930,1170
{} and then say {T2
然后说T2在T1提交之前提交。

2642
01:28:17,670 --> 01:28:19,260
0,300 300,840 840,1170 1170,1380 1380,1590
-} commits before {T1 -}

2643
01:28:19,260 --> 01:28:20,220
0,720
commits.|
|

2644
01:28:21,900 --> 01:28:23,540
0,1290

2645
01:28:23,860 --> 01:28:25,480
0,780 780,960 960,1080 1080,1230 1230,1620
Yes, okay, so this commits
是的，好的，所以这件事证明了是的。

2646
01:28:25,480 --> 01:28:26,180
0,390
yep.|
|

2647
01:28:26,600 --> 01:28:27,770
0,210 210,540 540,720 720,900 900,1170
And then {T1 -} commits
然后T1在T2提交之后提交。

2648
01:28:27,770 --> 01:28:29,360
0,300 300,780 810,1170 1170,1410 1410,1590
after T2 commits.| {We'll -}
|我们会努力承诺的，正确的，

2649
01:28:29,360 --> 01:28:31,220
0,270 270,390 390,780 810,1290 1470,1860
try to commit, correct,| now,
|现在，我们将开始做整个锁，为了验证诸如此类的，正确的。

2650
01:28:31,220 --> 01:28:33,080
0,240 240,510 510,780 780,960 960,1860
we'll start doing this whole

2651
01:28:33,080 --> 01:28:35,630
0,420 420,630 630,1410 1410,2130 2130,2550
lock, for validation {blah,blah,blah}, correct.|
|

2652
01:28:36,750 --> 01:28:39,420
0,330 330,1140 1830,2370 2370,2490 2490,2670
So before before, so what's
所以在之前，所以什么会发生正确的，

2653
01:28:39,420 --> 01:28:40,770
0,210 210,480 480,1020 1020,1140 1140,1350
gonna happen correct,| you know
|你知道我要给你举这个例子，

2654
01:28:40,770 --> 01:28:41,460
0,180 180,300 300,420 420,480 480,690
I was going to give

2655
01:28:41,460 --> 01:28:42,780
0,150 150,300 300,900 960,1140 1140,1320
you this example,| {} this
|这是我在下一节课上讲的一个例子，

2656
01:28:42,780 --> 01:28:43,620
0,60 60,150 210,660 660,750 750,840
is an example that I'm

2657
01:28:43,620 --> 01:28:44,760
0,300 300,420 420,600 600,930 930,1140
saying for next lecture,| but
|但是基本上C发生的事情是好的，

2658
01:28:45,840 --> 01:28:48,150
0,870 870,1230 1230,1350 1350,1830 1830,2310
yeah basically what happened C

2659
01:28:48,150 --> 01:28:49,170
0,150 150,240 240,600 660,870 870,1020
would be good,| C will
|C将得到1，

2660
01:28:49,170 --> 01:28:50,220
0,390 390,780
get 1,|
|

2661
01:28:50,970 --> 01:28:52,650
0,180 180,330 330,780 780,1230 1260,1680
at this point, the z
在这一点上，z将是1的版本，

2662
01:28:52,650 --> 01:28:53,370
0,180 180,330 330,390 390,660 660,720
will be a version of

2663
01:28:53,370 --> 01:28:55,410
0,240 240,660 1260,1470 1470,1530 1530,2040
1, correct,| so the validation
|因此，验证阶段将在提交之后运行，

2664
01:28:55,410 --> 01:28:56,400
0,270 270,420 420,630 630,930 930,990
phase will run after the

2665
01:28:56,400 --> 01:28:57,540
0,330 330,540 540,630 630,780 780,1140
commit,| that's what you said.|
|你就是这么说的。|

2666
01:28:57,990 --> 01:28:59,430
0,420 750,1020 1020,1110 1110,1410 1410,1440
Right.| And so here's a
正确的。|所以这是对z的验证，

2667
01:28:59,430 --> 01:29:00,820
0,570 570,660 660,1080
validation of z,|
|

2668
01:29:01,220 --> 01:29:02,570
0,720 720,840 840,990 990,1200 1200,1350
and you know it has
你知道它有0，对吧，

2669
01:29:02,570 --> 01:29:04,190
0,510 510,750 930,1350 1350,1470 1470,1620
0, right,| and now it's
|现在是1，这些交易将被中止。

2670
01:29:04,190 --> 01:29:06,050
0,390 390,720 720,1080 1080,1380 1410,1860
1 and will those transactions

2671
01:29:06,050 --> 01:29:07,880
0,120 120,210 210,600 1080,1590 1590,1830
will be abort.| Okay, so
|好的，这就是我想知道的，

2672
01:29:07,880 --> 01:29:08,420
0,150 150,240 240,360 360,420 420,540
this is what I was

2673
01:29:08,420 --> 01:29:10,040
0,270 270,480 480,690 690,1170 1170,1620
wondering about that,| so because
|所以因为在验证阶段过去之后，

2674
01:29:10,100 --> 01:29:13,010
0,360 360,450 450,1080 1080,1800 1860,2910
after the validation phase passes,|
|

2675
01:29:13,160 --> 01:29:13,820
0,180 180,270 270,330 330,600 600,660
there was a period of
有一段时间，

2676
01:29:13,820 --> 01:29:14,800
0,780
time,|
|

2677
01:29:16,190 --> 01:29:18,740
0,390 390,450 450,1290 1590,2100 2100,2550
after the validation phase passes,
在验证阶段过去之后，经过一段时间，它提交，

2678
01:29:18,740 --> 01:29:19,580
0,120 120,330 330,390 390,540 540,840
a period of time passes,

2679
01:29:19,580 --> 01:29:21,500
0,240 240,840 1020,1350 1350,1650 1650,1920
it commits,| what if this
|如果此验证发生在T2提交之前，

2680
01:29:21,500 --> 01:29:23,660
0,720 720,1200 1200,1770 1770,2010 2010,2160
validation happened before {T2 -}

2681
01:29:23,660 --> 01:29:24,860
0,480 480,600 600,720 720,960 960,1200
committed,| so it's still sort
|所以它仍然是某种旧的版本号。

2682
01:29:24,860 --> 01:29:26,700
0,60 60,540 750,1140 1140,1590
of old version number.|
|

2683
01:29:26,950 --> 01:29:29,680
0,300 300,810 810,1050 1050,2130 2280,2730
It cannot happen,| because after
这不可能发生，|因为在验证之后，在提交之后，在提交完成之后，正确地，

2684
01:29:29,680 --> 01:29:33,700
0,840 840,2160 2460,2880 2880,3180 3630,4020
{the,validation}, {} after commit, after

2685
01:29:33,700 --> 01:29:36,340
0,210 210,360 360,870 870,1290 1770,2640
commit has completed, correct,| the
|您知道的提交备份已记录

2686
01:29:36,400 --> 01:29:38,260
0,360 360,930 930,1140 1140,1350 1350,1860
commit backup {you,know} has recorded|
|

2687
01:29:38,260 --> 01:29:39,790
0,90 90,150 150,600 600,930 930,1530
and the primary after []
和[]做出改变后的初选，

2688
01:29:39,790 --> 01:29:41,040
0,180 180,390 390,450 450,1080
have made the change,|
|

2689
01:29:42,200 --> 01:29:44,240
0,870 870,1020 1020,1530 1530,1680 1680,2040
before the application was returned,|
在申请被退回之前，|

2690
01:29:44,240 --> 01:29:45,920
0,240 240,420 420,840 840,1350 1350,1680
before the upcoming returns,| z
在即将到来的回归之前，|Z已更新。

2691
01:29:45,920 --> 01:29:47,020
0,150 150,270 270,660
has been updated.|
|

2692
01:29:49,010 --> 01:29:50,280
0,840

2693
01:29:51,130 --> 01:29:52,300
0,510 570,720 720,720 720,1080 1080,1170
Wouldn't, {} I guess what
不会，我想我要说的是，

2694
01:29:52,300 --> 01:29:53,290
0,90 90,300 300,450 450,780 780,990
I'm saying is,| isn't it
|T1的验证阶段是否有可能发生在

2695
01:29:53,290 --> 01:29:56,350
0,540 540,1080 1080,1710 1710,2610 2610,3060
possible {for,T1's -} validation phase

2696
01:29:56,350 --> 01:29:59,020
0,120 120,840 840,1770 2100,2460 2550,2670
to happen before| or I
|或者我想我想说的是，

2697
01:29:59,020 --> 01:29:59,620
0,150 150,300 300,390 390,480 480,600
guess maybe what I'm trying

2698
01:29:59,620 --> 01:30:00,610
0,60 60,270 270,570 570,840 840,990
to say is,| isn't it
|是否可能T2的提交发生在T1的验证之间，

2699
01:30:00,610 --> 01:30:02,920
0,480 480,750 750,1050 1050,1740 1740,2310
possible that {T2's -} commit

2700
01:30:03,100 --> 01:30:05,800
0,480 480,1020 1020,1290 1290,1830 1830,2700
happens between {T1's -} validate,|
|

2701
01:30:06,070 --> 01:30:07,930
0,120 120,450 450,930 930,1230 1230,1860
what happens after T1 validate
T1之后发生的情况在t1提交之前进行验证。

2702
01:30:07,930 --> 01:30:10,300
0,660 660,1530 1530,1800 1800,2190
before {T1's -} commit.|
|

2703
01:30:11,940 --> 01:30:13,260
0,990

2704
01:30:13,680 --> 01:30:14,580
0,450 450,540 540,660 660,840 840,900
Clearly, you know there's a
显然，你知道这是有风险的，必须排除，并被处决，

2705
01:30:14,580 --> 01:30:17,100
0,450 480,1380 1470,1800 1800,1920 1920,2520
risk and must be excluded,

2706
01:30:17,700 --> 01:30:20,600
0,960 1410,2640

2707
01:30:21,520 --> 01:30:24,250
0,360 390,720 720,1620 1620,2490 2490,2730
and is executed,| {} so
|所以好吧，你是在担心，

2708
01:30:24,250 --> 01:30:25,780
0,210 210,360 360,600 600,1230
okay so you're worried,|
|

2709
01:30:26,340 --> 01:30:27,480
0,180 180,510 510,840 840,930 930,1140
let me construct this case
让我来解释一下，这个案子很可能会在下周送回给你，

2710
01:30:27,480 --> 01:30:28,140
0,150 150,270 270,390 390,570 570,660
may well come back to

2711
01:30:28,140 --> 01:30:29,190
0,180 180,420 420,630 630,840 840,1050
you in next week,| we're
|不管怎样，我们还是要谈一谈，

2712
01:30:29,190 --> 01:30:31,080
0,150 150,480 660,1230 1260,1710 1740,1890
gonna {talk,it} anyway,| {} but
|但我觉得你很担心这件事，

2713
01:30:31,080 --> 01:30:31,740
0,90 90,240 240,330 330,390 390,660
I think you are worried

2714
01:30:31,740 --> 01:30:33,030
0,300 300,480 720,930 930,1140 1140,1290
about it,| you could get
|你可以把照片拿回来，

2715
01:30:33,030 --> 01:30:34,000
0,60 60,330 330,720
the picture back,|
|

2716
01:30:34,110 --> 01:30:36,750
0,540 540,960 960,1410 1860,2100 2100,2640
{} you're here, we did,|
你来了，我们来了，|

2717
01:30:36,780 --> 01:30:38,220
0,1140

2718
01:30:38,530 --> 01:30:40,540
0,450 480,870 870,1710
so this guy
所以这个人承诺了，

2719
01:30:41,560 --> 01:30:43,510
0,690 960,1170 1170,1410 1410,1770 1770,1950
committed,| so you basically doing
|所以你基本上是在做提交阶段，

2720
01:30:43,510 --> 01:30:44,710
0,90 90,360 360,750 750,1080 1080,1200
the commit phase,| this is
|这是T2之后的T1，实际上是T2，

2721
01:30:44,710 --> 01:30:45,840
0,180 180,660
{T1 -}

2722
01:30:46,830 --> 01:30:48,510
0,300 300,360 360,810 810,930 930,1680
after {} T2 who actually

2723
01:30:49,020 --> 01:30:50,660
0,720 720,1290
{} T2,|
|

2724
01:30:51,290 --> 01:30:52,850
0,480 480,660 660,930 930,1350 1350,1560
{} so {T2 -} is
所以T2是关于在这里做的，对吧，

2725
01:30:52,850 --> 01:30:54,620
0,360 360,690 690,870 870,1470
about doing is here,

2726
01:30:55,130 --> 01:30:57,170
0,480 930,1380 1380,1590 1590,1920 1920,2040
right,| then {T1 -} is
|然后T1在一切发生之前就进来了，

2727
01:30:57,170 --> 01:31:01,400
0,270 270,780 1020,2190 2250,3810 3930,4230
coming in before {} everything

2728
01:31:01,400 --> 01:31:03,500
0,690 720,1170 1170,1320 1320,1710 1710,2100
happens,| before the T2 {is,finished,correct}.|
|在T2正确完成之前。|

2729
01:31:04,480 --> 01:31:05,380
0,600
Right.|
正确的。|

2730
01:31:05,810 --> 01:31:07,520
0,330 330,630 630,870 870,1110 1110,1710
So like {T1 -} validation
因此，就像T1验证一样，

2731
01:31:07,520 --> 01:31:09,530
0,240 240,450 450,570 570,960 1590,2010
also comes in here,| so
|所以也许，

2732
01:31:09,530 --> 01:31:10,820
0,450 450,570 570,780 780,930 930,1290
maybe,| okay, let me rewrite
|好的，让我重写一遍，

2733
01:31:10,820 --> 01:31:11,540
0,180 180,270 270,420 420,510 510,720
it,| and I'll get back
|我会给你回电的。

2734
01:31:11,540 --> 01:31:14,300
0,90 90,210 210,1650 2130,2610 2610,2760
to you.| Okay.| Exactly what
|好吧。|这正是我想要谈的。

2735
01:31:14,300 --> 01:31:15,350
0,270 300,540 540,600 600,780 780,1050
I wanted to talk about.|
|

2736
01:31:15,650 --> 01:31:18,380
0,120 120,780 780,1020 1020,1200 2490,2730
All right, thank you.| So
好的，谢谢你。|所以只要确保，你问的是T2，就像是在T1的第二阶段和第三阶段之间。

2737
01:31:18,380 --> 01:31:19,610
0,210 210,390 390,630 630,870 870,1230
just make sure, you're asking

2738
01:31:19,610 --> 01:31:20,960
0,300 300,480 480,780 780,1020 1020,1350
about {T2 -} being like

2739
01:31:21,230 --> 01:31:22,640
0,210 210,750 750,1110 1110,1290 1290,1410
in between stage two and

2740
01:31:22,640 --> 01:31:25,760
0,330 330,420 420,660 660,2010
three of T1.| Yeah.|
|嗯。|

2741
01:31:26,880 --> 01:31:28,170
0,180 180,270 270,540 540,990 990,1290
But in that case,| then
但在这种情况下，|然后我们可以，我们可以把它序列化为t1，对吧，

2742
01:31:28,170 --> 01:31:29,670
0,240 240,870 930,1080 1080,1410 1410,1500
{T2 -} we could, we

2743
01:31:29,670 --> 01:31:31,170
0,150 150,840 840,1020 1020,1290 1290,1500
could serialize it as {T2

2744
01:31:31,170 --> 01:31:33,690
0,150 150,570 570,1380 1410,1860 2130,2520
-} coming {for,T1}, right,| Yep.|
|是啊。|

2745
01:31:35,550 --> 01:31:37,260
0,180 180,990 990,1260 1260,1500 1500,1710
So, let's, let's get, let's
所以，让我们在周四回到这个话题上，

2746
01:31:37,260 --> 01:31:38,430
0,120 120,330 330,390 390,600 600,1170
get back to this on

2747
01:31:38,430 --> 01:31:40,050
0,450 900,1020 1020,1200 1200,1260 1260,1620
Thursday,| I have an example
|我有一个例子可以说明这一点。

2748
01:31:40,050 --> 01:31:41,640
0,390 390,780 780,1380 1380,1530 1530,1590
{for,that} exactly was going to

2749
01:31:41,640 --> 01:31:42,600
0,150 150,300 300,480 480,630 630,960
go over top of this.|
|

2750
01:31:46,330 --> 01:31:47,980
0,510 510,600 600,660 660,1260 1260,1650
Sorry in the validation stage,|
抱歉，在验证阶段，|

2751
01:31:47,980 --> 01:31:51,130
0,120 120,420 600,1500 1590,2310 2790,3150
you just read, {} read
你只要读，读版本号就行了。

2752
01:31:51,130 --> 01:31:53,200
0,270 270,750 750,1410
the version number.|
|

2753
01:31:53,480 --> 01:31:54,320
0,270 270,660
Yeah.| Okay.|
嗯。|好吧。|

2754
01:31:58,180 --> 01:32:00,160
0,300 300,930 930,1380 1380,1800 1800,1980
And {serializability -} allows us
可串行化使我们能够对事务重新排序。

2755
01:32:00,160 --> 01:32:02,260
0,150 150,540 540,1740 1770,1980 1980,2100
to reorder transactions.| Yeah, but
|是的，但严格的可序列化不会，对吧，

2756
01:32:02,260 --> 01:32:03,910
0,450 450,660 660,870 870,1200 1200,1650
{strict,serializability -} will not, correct,|
|

2757
01:32:04,060 --> 01:32:06,550
0,390 390,870 870,1650 1680,2160 2160,2490
even if transaction structure []
即使事务结构[]或要求甚至事务实际开始，

2758
01:32:06,550 --> 01:32:07,810
0,240 240,750 750,930 930,1110 1110,1260
or requires that even transaction

2759
01:32:07,810 --> 01:32:09,400
0,210 210,660 660,780 780,1260 1260,1590
actually starts,| if somebody after
|如果有人在追杀某人，

2760
01:32:09,400 --> 01:32:11,020
0,300 300,780 930,1110 1110,1530 1530,1620
somebody committed,| that transaction is
|该事务也在该事务之后提交。

2761
01:32:11,020 --> 01:32:12,550
0,210 210,540 540,870 870,1020 1020,1530
also committed after that transaction.|
|

2762
01:32:14,200 --> 01:32:15,700
0,360 360,960 990,1290 1290,1380 1380,1500
Right.| {} Which is {protocol
正确的。|这是协议保证，

2763
01:32:15,700 --> 01:32:16,750
0,90 90,300 300,720 720,930 930,1050
- -} guarantee,| because of
|因为，版本号。

2764
01:32:16,750 --> 01:32:17,500
0,420
the,

2765
01:32:17,790 --> 01:32:18,920
0,150 150,420 420,810
the version numbers.|
|

2766
01:32:19,830 --> 01:32:21,180
0,330 330,450 450,660 660,960
Got it, thank you.|
知道了，谢谢。|

2767
01:32:21,980 --> 01:32:24,420
0,180 180,510 510,1290 1320,2130
But strict serializability doesn't,|
但严格的可序列化并非如此，|

2768
01:32:24,650 --> 01:32:25,700
0,210 210,270 270,390 390,660 660,1050
if I give {T2 -}
如果我给T2，在T2结束后，这对T1来说是不够的，

2769
01:32:25,700 --> 01:32:26,640
0,660
and

2770
01:32:27,000 --> 01:32:28,350
0,180 180,390 390,720 720,1080 1080,1350
it's not enough for {T1

2771
01:32:28,350 --> 01:32:30,030
0,510 510,690 690,930 930,1380 1380,1680
-} the end after {T2

2772
01:32:30,030 --> 01:32:32,060
0,690 1050,1800
-} ends,|
|

2773
01:32:32,400 --> 01:32:33,570
0,210 210,360 360,810 810,1110 1110,1170
{T1 -} have had to
T1必须已经开始

2774
01:32:33,570 --> 01:32:35,700
0,240 240,1020 1050,1380 1680,2070 2070,2130
have started| or maybe I
|或许我需要考虑一下这个问题，

2775
01:32:35,700 --> 01:32:36,510
0,120 120,180 180,300 300,480 480,810
need to think about this,|
|

2776
01:32:36,510 --> 01:32:38,070
0,300 540,750 750,1290 1290,1470 1470,1560
but I think this is
但我觉得这总能把我绊倒，

2777
01:32:38,070 --> 01:32:38,970
0,210 210,450 450,570 570,720 720,900
always tripping me up,| this
|这就像是关于交易何时开始也有一条规则。

2778
01:32:38,970 --> 01:32:40,890
0,180 180,360 360,720 720,1560 1590,1920
like there's also a rule

2779
01:32:40,890 --> 01:32:42,600
0,270 270,660 660,750 750,1290 1290,1710
about when the transaction starts.|
|

2780
01:32:42,600 --> 01:32:44,490
0,450 450,750 750,900 900,1410 1500,1890
Yeah, well, they're very well
是啊，它们很好地描述了现实生活中发生的事情，

2781
01:32:44,760 --> 01:32:45,870
0,240 240,510 510,630 630,810 810,1110
what happens in real life,|
|

2782
01:32:45,870 --> 01:32:47,580
0,960 960,1200 1200,1290 1290,1410 1410,1710
exactly starts from some particular
准确地从某个特定的时间点开始

2783
01:32:47,580 --> 01:32:48,990
0,180 180,240 240,600 600,840 960,1410
point of time| and basically
|基本上，如果T1，如果T2在T1提交后开始。

2784
01:32:48,990 --> 01:32:50,900
0,660 690,1740
if T1,

2785
01:32:51,240 --> 01:32:52,830
0,330 330,540 540,900 900,1350 1350,1590
{} if T2 starts after

2786
01:32:52,830 --> 01:32:54,180
0,420 420,1110
T1 commits.|
|

2787
01:32:56,250 --> 01:32:57,900
0,360 450,690 690,780 780,1230 1350,1650
Right.| So and so then
正确的。|某某，肯定是这样的，

2788
01:32:57,900 --> 01:32:58,830
0,150 150,450 450,540 540,630 630,930
it must be the case,|
|

2789
01:32:58,830 --> 01:33:01,080
0,240 240,600 600,1470 1650,1800 1800,2250
that T2 observes {you,know} {T2
T2观察到，T2 T1改变了严格的可序列化。

2790
01:33:01,080 --> 01:33:03,120
0,360 360,750 750,1440 1470,1680 1680,2040
-} T1 changes that {strict,serializability

2791
01:33:03,120 --> 01:33:04,120
0,750
-}.|
|

2792
01:33:04,700 --> 01:33:05,520
0,540
Right.|
正确的。|

2793
01:33:05,790 --> 01:33:07,380
0,150 150,270 270,690 690,1170 1170,1590
But what happened {T2 -}
但T2所发生的一切完全是从内部开始的。

2794
01:33:07,380 --> 01:33:09,930
0,510 510,750 750,1200 1200,1710 1710,2550
starts and commits solely within.|
|

2795
01:33:10,170 --> 01:33:11,850
0,240 540,780 780,1290 1290,1440 1440,1680
{Then,concurrent -} transaction and either
那么并发事务和任何一个结果都是好的。

2796
01:33:11,850 --> 01:33:17,730
0,270 270,360 360,720 1020,1530 1740,5880
outcome is fine.| Okay.| {Is,that,answer,your,question}.|
|好吧。|这就是你的问题的答案。|

2797
01:33:17,730 --> 01:33:20,700
0,330 330,1470 1680,2160 2160,2310 2310,2970
{Yeah,I,think,that,I,confused}, so.| Exactly, they literally
是的，我想我搞混了，所以。|确切地说，当T2在T1提交之前开始时，

2798
01:33:20,970 --> 01:33:23,400
0,540 600,1050 1050,1200 1200,1680 1680,2430
when {T2 -} starts before

2799
01:33:23,400 --> 01:33:25,170
0,180 180,420 420,1050 1170,1410 1410,1770
{T1 -} commits,| it's considered
|它被认为是并发事务，

2800
01:33:25,170 --> 01:33:26,360
0,120 120,450 450,990
the concurrent transaction,|
|

2801
01:33:27,200 --> 01:33:28,550
0,450 450,690 690,900 900,1200 1200,1350
and so {T1 -} or
所以T1或者你知道T2可以观察到，可以在之前或之后订购，

2802
01:33:28,550 --> 01:33:30,050
0,270 270,570 600,930 930,1050 1050,1500
you know T2 can observe

2803
01:33:30,050 --> 01:33:31,610
0,330 330,600 600,750 750,1080 1080,1560
either can be ordered before

2804
01:33:31,610 --> 01:33:33,530
0,210 210,510 570,840 840,1170 1380,1920
either after,| doesn't matter.| Okay,
|无关紧要。|好的，好的。

2805
01:33:33,770 --> 01:33:34,340
0,480
okay.|
|

2806
01:33:34,810 --> 01:33:36,040
0,450 660,900 900,1020 1020,1080 1080,1230
Okay, thank you.| I think
好的谢谢。|我认为这也是你的例子的答案。

2807
01:33:36,040 --> 01:33:37,000
0,240 240,510 510,630 630,870 870,960
there's also the answer to

2808
01:33:37,000 --> 01:33:40,000
0,330 330,930 1170,1860 2190,2670 2730,3000
your example.| Right, okay, thank
|好的，好的，谢谢。

2809
01:33:40,000 --> 01:33:41,770
0,240 270,960 960,1110 1110,1590 1590,1770
you.| {Okay,we} have we got
|好吧，我们已经拿到了，反正我们已经拿到了。

2810
01:33:41,770 --> 01:33:44,710
0,60 60,330 330,750 2460,2730 2730,2940
it anyway already.| You'd say
|你会说，如果T2开始于T1开始提交之间，对，就像。

2811
01:33:44,710 --> 01:33:46,570
0,420 600,840 840,1050 1050,1560 1560,1860
if {T2 -} started like

2812
01:33:46,570 --> 01:33:48,970
0,870 1110,1320 1320,1620 1620,2010 2010,2400
between the {T1 -} started

2813
01:33:48,970 --> 01:33:51,340
0,390 390,750 750,1680 1710,2130 2130,2370
commit, right, like.| You know,
|你知道，我们可以去还是去之后，这都不重要。

2814
01:33:51,340 --> 01:33:52,690
0,270 270,600 600,810 810,1140 1140,1350
can we go for or

2815
01:33:52,690 --> 01:33:54,340
0,240 240,330 330,510 510,870
after, it doesn't matter.|
|

2816
01:33:56,010 --> 01:33:56,940
0,240 240,390 390,450 450,870 870,930
{} Can I ask a
我能问个后勤问题吗，

2817
01:33:56,940 --> 01:33:59,730
0,510 510,1230 1290,1830 1890,2370 2370,2790
logistics question,| {} {I,remember} in
|我记得在6.S081你也贴了这些幻灯片。

2818
01:33:59,730 --> 01:34:02,700
0,840 870,1140 1140,1740 1920,2370 2370,2970
{6.S081 - -} you post

2819
01:34:02,700 --> 01:34:04,540
0,270 270,900 900,1650
these slides too.|
|

2820
01:34:05,160 --> 01:34:06,450
0,390 390,540 540,1050 1050,1170 1170,1290
Yes, I, yeah, yeah I
是的，我，是的，是的，我不是在这里做的，

2821
01:34:06,450 --> 01:34:08,250
0,240 240,360 360,600 600,1020 1050,1800
didn't do that here, {}|
|

2822
01:34:08,700 --> 01:34:09,870
0,180 180,360 360,570 570,870 870,1170
would you like to be
你想上这个网站吗？

2823
01:34:09,870 --> 01:34:11,080
0,180 180,450 450,930
on the website.|
|

2824
01:34:11,290 --> 01:34:12,520
0,180 180,390 390,720 720,840 840,1230
I think slides are useful,
我认为幻灯片是有用的，如果你只需要看这张幻灯片，

2825
01:34:12,520 --> 01:34:13,960
0,510 720,900 900,1020 1020,1260 1260,1440
if if you just need

2826
01:34:13,960 --> 01:34:15,790
0,390 420,870 900,1170 1170,1290 1290,1830
to look at this slides,|
|

2827
01:34:15,790 --> 01:34:17,110
0,180 180,450 450,630 660,1200 1200,1320
you need to scroll through
你需要滚动浏览视频。

2828
01:34:17,110 --> 01:34:20,200
0,120 120,840 930,1440 1470,2280 2730,3090
the video.| Okay, {} you're
|好的，你首先会问，为什么我没有这么做，

2829
01:34:20,200 --> 01:34:22,420
0,240 240,690 1530,1830 1830,2010 2010,2220
first asking, why {I,haven't} {done,it},|
|

2830
01:34:23,080 --> 01:34:25,270
0,1410 1410,1680 1680,1920 1920,2040 2040,2190
yeah, I'm happy to do
是的，我很乐意这么做，

2831
01:34:25,270 --> 01:34:26,620
0,300 300,390 390,900 900,1110 1110,1350
it,| I I do save
|现在，我确实把他们都救了。

2832
01:34:26,620 --> 01:34:28,020
0,90 90,540 660,1200
them all, now.|
|

2833
01:34:29,690 --> 01:34:30,950
0,210 210,360 360,510 510,990 1020,1260
Thank you so much,| thank
非常感谢,|谢谢你那些有趣的演讲。

2834
01:34:30,950 --> 01:34:32,720
0,180 180,630 810,1140 1140,1380 1380,1770
you for those fun lecture

2835
01:34:32,720 --> 01:34:33,400
0,420
things.|
|

2836
01:34:33,700 --> 01:34:34,600
0,600
{You're,welcome}.
不用谢。
