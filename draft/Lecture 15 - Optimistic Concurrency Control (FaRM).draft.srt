1
00:00:00,000 --> 00:00:02,610
0,180 180,930 1410,1830 1830,2130 2130,2610
Good afternoon, good evening, {good,night},
下午好，傍晚好，晚上好，无论你在哪里。

2
00:00:02,610 --> 00:00:04,950
0,300 300,450 450,810 1260,1980 2040,2340
wherever you are.| {} So
|所以今天我想谈谈 FaRM ，

3
00:00:04,950 --> 00:00:05,760
0,270 270,330 330,480 480,630 630,810
today I want to talk

4
00:00:05,760 --> 00:00:07,170
0,210 210,690 810,1080 1080,1290 1290,1410
about FaRM,| {} this is
|这是一篇 2015 年的论文，

5
00:00:07,170 --> 00:00:09,300
0,150 150,450 450,810 810,1980 1980,2130
a paper from 2015,| {so,what
|是比较近的一篇论文，

6
00:00:09,300 --> 00:00:10,050
0,210 210,300 300,450 450,570 570,750
-} a little bit more

7
00:00:10,050 --> 00:00:11,430
0,60 60,120 120,390 390,840 1200,1380
of a recent paper,| and
|这是一篇研究论文，

8
00:00:11,430 --> 00:00:13,260
0,240 240,510 510,810 810,1260 1290,1830
{it's,really} a research paper,| and
|这个研究论文的主题是，

9
00:00:13,320 --> 00:00:14,280
0,180 180,480 480,570 570,660 660,960
the topic of the research

10
00:00:14,280 --> 00:00:16,830
0,540 540,930 930,1380 1380,1860 2130,2550
paper is| trying to explore
|试图探索一些想法和技术

11
00:00:16,830 --> 00:00:18,810
0,150 150,690 690,810 810,1500 1500,1980
some ideas and technologies| to
|来获得高性能的事务，

12
00:00:18,810 --> 00:00:20,520
0,180 180,390 390,870 870,1620
get high performance transactions,|
|

13
00:00:31,700 --> 00:00:33,410
0,480 480,690 690,870 930,1140 1140,1710
and with {} high performance,|
高性能，|

14
00:00:33,410 --> 00:00:34,850
0,240 240,1020 1050,1230 1230,1380 1380,1440
just to make sure we're
为了确保我们，是我们想要的，

15
00:00:34,850 --> 00:00:36,830
0,240 240,810 1200,1590 1590,1770 1770,1980
on the, roughly what we're

16
00:00:36,830 --> 00:00:38,840
0,300 300,690 870,1470 1470,1860 1860,2010
looking for,| high performance from
|高性能意味着，

17
00:00:38,840 --> 00:00:40,430
0,210 210,750 750,990 990,1260 1260,1590
that means,| they're getting {140,million
|他们获得 1.4 亿个事务每秒，

18
00:00:40,430 --> 00:00:41,600
0,810
-}

19
00:00:43,470 --> 00:00:45,600
0,510 510,630 630,1260 1320,1770 1770,2130
transactions per second,| {} on
|在 TATP 基准上，使用 90 台机器，

20
00:00:45,600 --> 00:00:49,680
0,270 270,600 600,660 660,1500 3210,4080
this {you,know} {TATP -} benchmark,

21
00:00:50,290 --> 00:00:53,400
0,480 480,780 780,1110 1110,1770
{} using 90 machines,|
|

22
00:00:58,620 --> 00:01:00,180
0,360 360,720 720,1320 1350,1440 1440,1560
and so {} you know
所以这个数字是否令人印象深刻，

23
00:01:00,180 --> 00:01:01,410
0,150 150,360 360,510 510,810 810,1230
whether {} this {number,is} impressive,|
|

24
00:01:01,410 --> 00:01:02,790
0,150 150,600 600,930 930,1230 1230,1380
of {course,you,know} depends on {}
当然取决于你知道的数字，

25
00:01:02,790 --> 00:01:03,570
0,90 90,360 360,450 450,690 690,780
the numbers you know,| and
|有人还记得，

26
00:01:03,570 --> 00:01:05,160
0,270 270,420 510,1020 1020,1440 1440,1590
so does anybody remember,| how
|Spanner 每秒能处理多少事务吗？

27
00:01:05,160 --> 00:01:06,600
0,180 180,660 660,750 750,1080 1080,1440
many transactions per second Spanner

28
00:01:06,600 --> 00:01:07,340
0,120 120,450
could do?|
|

29
00:01:16,220 --> 00:01:17,280
0,750
Anybody?|
有人知道吗？|

30
00:01:27,130 --> 00:01:28,780
0,270 270,540 540,1020 1110,1590 1590,1650
So if we remember the
所以如果我们记得那篇论文，

31
00:01:28,780 --> 00:01:30,190
0,420 420,510 510,630 630,990 1020,1410
paper,| you know certain {}
|那里发生多少事务，

32
00:01:30,190 --> 00:01:31,690
0,450 450,810 810,930 930,1170 1170,1500
transaction there {you,know} took about|
|

33
00:01:31,960 --> 00:01:32,890
0,390 390,480 480,630 630,720 720,930
depending on what you did,|
取决于你所做的，|

34
00:01:32,890 --> 00:01:34,450
0,120 120,570 600,840 840,1410 1410,1560
you know 10 to {100
10 到 100 毫秒，

35
00:01:34,450 --> 00:01:36,280
0,240 240,840 840,1380 1380,1530 1530,1830
-} milliseconds,| so {you,know} 10
|所以每秒 10 到 100 个事务。

36
00:01:36,280 --> 00:01:38,410
0,90 90,180 180,210 210,720 1290,2130
to {} {100 -} {}

37
00:01:38,440 --> 00:01:41,800
0,810 810,1860 2190,2550 2550,2670 2670,3360
transactions { -} per second.|
|

38
00:01:41,800 --> 00:01:44,590
0,420 660,1080 1080,1710 1860,2280 2280,2790
So, {} the number transactions
所以， FaRM 可以处理的事务数量是

39
00:01:44,590 --> 00:01:45,790
0,330 360,540 540,840 840,960 960,1200
that {} FaRM can do

40
00:01:45,790 --> 00:01:47,440
0,420 420,600 600,720 720,1320 1320,1650
is| in a completely different
|在一个完全不同的数量级。

41
00:01:47,440 --> 00:01:48,620
0,330 330,390 390,1050
order of magnitude.|
|

42
00:01:49,050 --> 00:01:50,010
0,150 150,270 270,630 630,750 750,960
And that partly is because
部分是因为它们是完全不同的系统，

43
00:01:50,010 --> 00:01:52,200
0,90 90,420 420,660 660,1290 1680,2190
they're completely different systems, {}|
|

44
00:01:52,200 --> 00:01:54,510
0,870 900,1170 1170,1260 1260,1440 1440,2310
Spanner tries to do synchronous
Spanner 试图在全球范围内进行同步复制，

45
00:01:54,510 --> 00:01:56,550
0,330 330,1020 1020,1380 1380,1500 1500,2040
[] replication across the world,|
|

46
00:01:56,820 --> 00:01:58,770
0,480 480,870 870,1230 1230,1590 1590,1950
and FaRM actually everything runs
而 FaRM 的一切都在一个数据中心运行。

47
00:01:58,770 --> 00:02:00,240
0,150 150,570 570,870 870,1110 1110,1470
in a single data center.|
|

48
00:02:04,560 --> 00:02:06,240
0,210 210,360 360,480 480,1410 1410,1680
And so the applications that
所以， FaRM 和 Spanner 针对的应用程序完全不同，

49
00:02:06,240 --> 00:02:08,580
0,270 270,900 900,1350 1350,1890 1890,2340
been targeted by FaRM and

50
00:02:08,700 --> 00:02:10,560
0,390 390,540 540,810 810,1290 1380,1860
Spanner a quite different,| Spanner
|Spanner 针对不能容忍数据中心崩溃的应用程序，

51
00:02:10,560 --> 00:02:13,350
0,660 720,1530 1530,1680 1680,2070 2070,2790
targeting applications that cannot {tolerate

52
00:02:13,440 --> 00:02:15,810
0,1830 1830,1830 1830,2220 2220,2310 2310,2370
-} the crash with a

53
00:02:15,810 --> 00:02:17,400
0,210 210,690 840,1260 1260,1380 1380,1590
data center,| like you know
|比如 F1 广告服务数据库，

54
00:02:17,400 --> 00:02:19,530
0,330 330,480 480,990 990,1680 1800,2130
{} {F1 -} {} AD

55
00:02:19,530 --> 00:02:22,290
0,450 450,1200 1320,2190 2190,2640 2640,2760
serving database,| while Spanner is
|Spanner 非常好，

56
00:02:22,290 --> 00:02:24,060
0,450 450,690 690,1200 1230,1590 1590,1770
much, very well,| FaRM much
|FaRM 更针对

57
00:02:24,060 --> 00:02:25,770
0,120 120,780 990,1320 1320,1440 1440,1710
more targeting sort of| like
|比如你是所有 MySQL

58
00:02:25,770 --> 00:02:27,930
0,750 810,1110 1110,1470 1470,1650 1650,2160
you're you're using {MySQL -}|
|

59
00:02:27,930 --> 00:02:29,130
0,330 330,480 480,780 780,1110 1110,1200
or some other sort of
或某种其他类型的应用数据库系统，

60
00:02:29,130 --> 00:02:32,310
0,750 780,1710 1710,2250 2280,2730 2730,3180
{} database application database system,|
|

61
00:02:32,460 --> 00:02:33,480
0,210 210,300 300,540 540,780 780,1020
and you want much more
你想要更高性能的事务，

62
00:02:33,480 --> 00:02:36,810
0,180 180,900 900,1830 1860,2610 2820,3330
high performance {} transactions,| then
|那么 FaRM 是一种可能的设计或可能的选择。

63
00:02:36,810 --> 00:02:37,800
0,60 60,300 300,720 720,810 810,990
you know {FaRM -} sort

64
00:02:37,800 --> 00:02:39,390
0,60 60,570 570,1020 1020,1470 1470,1590
of a possible design or

65
00:02:39,390 --> 00:02:40,820
0,90 90,660 660,1320
a possible alternative.|
|

66
00:02:41,950 --> 00:02:43,840
0,120 120,300 300,990 990,1560 1590,1890
They do provide strict {serializability
它们提供了严格的可串行化，

67
00:02:43,840 --> 00:02:46,340
0,750
-},|
|

68
00:02:48,370 --> 00:02:49,870
0,360 360,420 420,810 810,1080 1080,1500
which is similar to the
类似于 Spanner 提供的外部一致性。

69
00:02:51,810 --> 00:02:55,680
0,630 630,1530 1560,2100 2700,3360 3390,3870
external consistency that {} Spanner

70
00:02:55,680 --> 00:02:56,440
0,480
offered.|
|

71
00:02:56,990 --> 00:02:58,010
0,270 270,570 600,690 690,810 810,1020
And so the whole goal
所以，整个目标是获得高性能，

72
00:02:58,010 --> 00:02:58,880
0,60 60,120 120,240 240,390 390,870
is to get high performance,|
|

73
00:02:58,880 --> 00:03:00,230
0,150 150,270 270,360 360,780 780,1350
so there are numerous ideas
有很多想法会实现高性能。

74
00:03:00,230 --> 00:03:01,340
0,90 90,210 210,360 360,750 750,1110
you know they're going to

75
00:03:01,340 --> 00:03:03,710
0,570 570,720 720,1380 1590,1920 1920,2370
achieving high performance.| {} One,
|一个是，他们分片，

76
00:03:03,710 --> 00:03:05,200
0,450 450,630 630,1230
they they shard,|
|

77
00:03:05,470 --> 00:03:07,580
0,420 420,810 810,1110 1110,1680
that's probably the main
这可能是他们使用的主要标准技术，

78
00:03:07,860 --> 00:03:09,270
0,300 300,720 720,1140 1140,1260 1260,1410
{you,know} standard technique that they

79
00:03:09,270 --> 00:03:10,080
0,330 330,480 480,630 630,750 750,810
used,| that was going to
|这将给我们带来性能，

80
00:03:10,080 --> 00:03:11,220
0,180 180,360 360,510 510,1050 1050,1140
give us the performance,| for
|例如，如果不同的记录在不同的分片上，

81
00:03:11,220 --> 00:03:13,470
0,510 510,900 930,1020 1020,1290 1470,2250
example if you know different

82
00:03:13,500 --> 00:03:14,940
0,690 690,960 960,1140 1140,1170 1170,1440
records are on a different

83
00:03:14,940 --> 00:03:17,640
0,510 510,1110 1110,1770 1770,1890 2340,2700
shards,| and transactions {you,know} touch
|事务触及不同的分片，

84
00:03:17,640 --> 00:03:18,930
0,30 30,330 330,660 660,810 810,1290
the different shard,| then these
|然后这些事务可以并行运行，

85
00:03:19,260 --> 00:03:21,210
0,570 570,780 780,1080 1110,1680 1770,1950
{transaction,can,just} run in parallel,| and
|所以，如果你有 90 台机器，

86
00:03:21,210 --> 00:03:23,040
0,300 750,1260 1260,1650 1650,1710 1710,1830
so, {} if you have

87
00:03:23,040 --> 00:03:24,660
0,300 300,690 690,960 960,1320 1320,1620
90 machines,| {you,know} get 90
|获得一台机器的性能的 90 倍。

88
00:03:24,660 --> 00:03:27,210
0,390 390,1380 1440,1800 1800,2040 2040,2550
times you know the performance

89
00:03:27,210 --> 00:03:28,080
0,90 90,150 150,390 390,720
of a single machine.|
|

90
00:03:28,520 --> 00:03:29,570
0,180 180,630 630,780 780,930 930,1050
So sharding are sort of
所以分片是一个起点，

91
00:03:29,570 --> 00:03:31,520
0,420 420,810 1320,1680 1680,1800 1800,1950
starting point,| but then they
|但他们走得更远，

92
00:03:31,520 --> 00:03:34,100
0,180 180,360 360,1590 1830,2250 2250,2580
go much further,| so they
|他们使用非易失性 DRAM ，

93
00:03:34,100 --> 00:03:37,860
0,720 720,2160 2370,3330
use non-volatile DRAM,|
|

94
00:03:39,560 --> 00:03:40,640
0,120 120,270 270,390 390,510 510,1080
and this is to avoid
这是为了避免不得不写入稳定存储设备的瓶颈，

95
00:03:40,640 --> 00:03:42,080
0,180 180,270 270,900 900,1170 1170,1440
to the bottleneck of having

96
00:03:42,080 --> 00:03:44,810
0,120 120,450 450,1080 1080,2040 2340,2730
to write to {} stable

97
00:03:44,810 --> 00:03:46,580
0,270 270,810 810,1170 1440,1620 1620,1770
storage devices,| so in their
|所以在他们的设计中，

98
00:03:46,580 --> 00:03:47,750
0,450 450,540 540,720 720,990 990,1170
design,| you don't actually have
|你不必写入关键路径到固态硬盘或磁盘，

99
00:03:47,750 --> 00:03:48,920
0,120 120,510 510,720 720,810 810,1170
to write in the [critical

100
00:03:48,920 --> 00:03:50,840
0,600 810,1050 1050,1170 1170,1710 1710,1920
path] to an SSD or

101
00:03:50,840 --> 00:03:52,370
0,90 90,720 810,1080 1080,1410 1410,1530
a disk,| {} and so
|所以，他们避免了这样做的全部花费，

102
00:03:52,370 --> 00:03:53,810
0,150 150,510 510,570 570,870 870,1440
they avoid the whole cost

103
00:03:53,810 --> 00:03:56,270
0,900 1170,1470 1470,1950 2070,2310 2310,2460
of doing so,| which can
|这可能相当昂贵，

104
00:03:56,270 --> 00:03:57,650
0,90 90,330 330,1020 1050,1230 1230,1380
be quite expensive,| and that's
|例如，你可以考虑你的 Raft 实现，

105
00:03:57,650 --> 00:03:58,910
0,300 300,660 660,780 780,960 960,1260
for example you think about

106
00:03:58,910 --> 00:04:00,440
0,450 660,1320
your {}

107
00:04:01,030 --> 00:04:02,800
0,840 840,1050 1050,1470 1470,1560 1560,1770
implementations of Raft,| you know
|他们存储或者使数据持久化，

108
00:04:02,800 --> 00:04:05,830
0,1740 2010,2220 2220,2760 2820,2910 2910,3030
they they store you know

109
00:04:05,830 --> 00:04:07,870
0,240 240,420 420,690 690,1350 1620,2040
or make data persistent, {}|
|

110
00:04:07,870 --> 00:04:09,070
0,300 300,720 720,780 780,930 930,1200
and typically you know making
通常情况下，在稳定的存储设备上进行持久化，

111
00:04:09,070 --> 00:04:10,690
0,300 300,870 870,1170 1170,1350 1350,1620
something persistent on a stable

112
00:04:10,690 --> 00:04:12,100
0,270 270,720 720,810 810,1170 1170,1410
storage device,| you know the
|几百毫秒的量级，

113
00:04:12,100 --> 00:04:15,070
0,360 360,540 960,1620 1770,2370 2370,2970
order of hundreds of milliseconds,

114
00:04:15,070 --> 00:04:17,710
0,210 210,600 600,870 1440,1920 2100,2640
or hundreds of,| a few
|几毫秒到十毫秒，

115
00:04:17,710 --> 00:04:19,720
0,870 870,990 990,1200 1200,1680 1680,2010
milliseconds you know to tens

116
00:04:19,720 --> 00:04:21,250
0,90 90,600 600,780 780,960 960,1530
of milliseconds to ten milliseconds,|
|

117
00:04:21,250 --> 00:04:22,060
0,90 90,300 300,570 570,780 780,810
if you're actually using a
如果你使用磁盘，

118
00:04:22,060 --> 00:04:22,980
0,390 390,840
magnetic disk,|
|

119
00:04:23,460 --> 00:04:24,780
0,390 390,900 900,990 990,1140 1140,1320
an SSD you know sort
一个 SSD 有几毫秒，

120
00:04:24,780 --> 00:04:25,890
0,90 90,660 690,990 990,1050 1050,1110
of, {} sort of {}

121
00:04:25,890 --> 00:04:28,830
0,510 1230,1920 2130,2520 2520,2760 2760,2940
millisecond,| and so given the
|所以，考虑到它们运作的时间，

122
00:04:28,830 --> 00:04:30,090
0,420 420,510 510,1050 1050,1140 1140,1260
{time,for} they operate,| you know
|这种方式花费太高了。

123
00:04:30,090 --> 00:04:31,560
0,210 210,390 390,810 810,930 930,1470
that way just too costly,|
|

124
00:04:31,590 --> 00:04:33,060
0,330 330,510 510,1140 1140,1260 1260,1470
so they use some people
所以他们使用一些人称为非易失性 DRAM ，

125
00:04:33,060 --> 00:04:34,530
0,90 90,300 300,900 900,1320 1320,1470
they call non-volatile DRAM,| this
|我们稍后会谈到这一点，

126
00:04:34,530 --> 00:04:35,190
0,150 150,330 330,540 540,600 600,660
we'll talk about in a

127
00:04:35,190 --> 00:04:37,800
0,360 1230,1710 1800,2100 2100,2250 2250,2610
second,| and then so that
|这样就消除了存储访问成本。

128
00:04:37,800 --> 00:04:40,260
0,390 390,600 600,930 930,1710 1740,2460
gets rid of storage {}

129
00:04:40,620 --> 00:04:42,780
0,510 510,1110 1320,1920 1920,2040 2040,2160
access cost.| And so the
|他们要解决的下两个瓶颈是

130
00:04:42,780 --> 00:04:44,700
0,660 660,1170 1170,1260 1260,1740 1740,1920
next two {} bottleneck they

131
00:04:44,700 --> 00:04:48,180
0,1020 1050,1650 1650,2400 2460,3120 3120,3480
{address,is}| CPU bottlenecks and network
|CPU 瓶颈和网络瓶颈，

132
00:04:48,180 --> 00:04:50,430
0,600 1020,1200 1200,1530 1530,1620 1620,2250
bottlenecks,| and {for,that}, to use
|要实现这一点，需要使用一种称为内核旁路的技术，

133
00:04:50,430 --> 00:04:53,260
0,510 540,1110 1110,1470 1470,2310
{} technical {called,kernel} bypass,|
|

134
00:04:57,010 --> 00:04:58,450
0,180 180,540 540,960 960,1080 1080,1440
which basically avoids the operating
这避免了操作系统与网卡交互，

135
00:04:58,450 --> 00:05:00,520
0,1050 1080,1590 1590,1680 1680,1980 1980,2070
system for, to talk to

136
00:05:00,520 --> 00:05:01,960
0,90 90,420 420,840 1080,1320 1320,1440
the network card,| and then
|然后他们使用具有 RDMA 特殊功能的网卡，

137
00:05:01,960 --> 00:05:03,130
0,120 120,360 360,660 660,1020 1020,1170
they use network cards that

138
00:05:03,130 --> 00:05:05,740
0,180 180,1230 1230,1590 1590,2190 2220,2610
have a special feature called

139
00:05:05,740 --> 00:05:06,860
0,870
RDMA,|
|

140
00:05:10,530 --> 00:05:12,420
0,360 360,840 840,1440 1470,1710 1710,1890
that allows the card to
这允许网卡从远程服务器读取内存，

141
00:05:12,420 --> 00:05:14,070
0,420 450,990 990,1350 1350,1560 1560,1650
{read,and} write memory from {}

142
00:05:14,070 --> 00:05:15,540
0,270 270,660 660,1020 1020,1260 1260,1470
remote server| without actually having
|而不必中断远程服务器，

143
00:05:15,540 --> 00:05:16,920
0,90 90,690 720,900 900,1020 1020,1380
to interrupt you know that

144
00:05:16,980 --> 00:05:18,120
0,360 360,840
remote server,|
|

145
00:05:18,420 --> 00:05:20,070
0,390 390,510 510,630 630,1080 1290,1650
{} and so this {}
所以，这为我们提供了

146
00:05:20,070 --> 00:05:21,660
0,210 210,330 330,900 930,1380 1380,1590
gives us| really {} low
|对远程服务器或远程内存的低延迟网络访问，

147
00:05:21,660 --> 00:05:23,790
0,870 870,1200 1230,1620 1620,1980 1980,2130
latency {} network access to

148
00:05:23,790 --> 00:05:24,900
0,90 90,390 390,840
{} remote server,

149
00:05:25,300 --> 00:05:26,920
0,630 630,810 810,930 930,1200 1200,1620
{} or to remote memory,|
|

150
00:05:26,950 --> 00:05:27,940
0,210 210,420 420,750 750,900 900,990
this is partially where the
这就是 FaRM 名称的来源,

151
00:05:27,940 --> 00:05:29,440
0,330 330,630 630,870 870,1320 1320,1500
name FaRM comes from,| {you,know,the}
|R 代表远程， M 代表内存， Fa 代表快速。

152
00:05:29,440 --> 00:05:31,600
0,510 510,1170 1200,1440 1440,1620 1620,2160
{R,stands,for} remote and {M,for} memory

153
00:05:31,840 --> 00:05:33,480
0,270 270,750 750,870 870,1410
and Fa for fast.|
|

154
00:05:34,810 --> 00:05:36,820
0,600 1140,1290 1290,1500 1500,1740 1740,2010
{} So, those are the,
所以，这些就是他们使用的技术，

155
00:05:37,030 --> 00:05:38,860
0,450 450,630 630,1050 1080,1680 1680,1830
those are the technologies they

156
00:05:38,860 --> 00:05:40,960
0,510 570,1080 1080,1290 1290,1830 1980,2100
use,| {} and then you
|然后，为了能够真正利用这些技术，

157
00:05:40,960 --> 00:05:41,620
0,150 150,270 270,360 360,540 540,660
know to be able to

158
00:05:41,620 --> 00:05:43,870
0,210 210,600 600,750 750,1560 1740,2250
really exploit these technologies| drives
|驱动他们设计，

159
00:05:43,870 --> 00:05:45,160
0,210 210,660 660,750 750,1170 1170,1290
them to a design,| that
|使用乐观并发控制，

160
00:05:45,160 --> 00:05:46,810
0,240 240,810 810,900 900,1230 1230,1650
uses optimistic {concurrency -} control|
|

161
00:05:47,220 --> 00:05:49,680
0,420 420,1200 1230,1530 1530,1860 1890,2460
or OCC, {} the short
或 OCC ，这个的缩写，乐观的，

162
00:05:49,680 --> 00:05:51,510
0,360 360,450 450,630 630,900 900,1830
version of this, so optimistic,|
|

163
00:05:56,230 --> 00:05:57,940
0,540 540,900 900,1410 1410,1500 1500,1710
and in contrast with many
与我们到目前为止看到的许多设计相比，

164
00:05:57,940 --> 00:05:58,780
0,90 90,180 180,570 570,720 720,840
of the designs that we've

165
00:05:58,780 --> 00:06:00,880
0,150 150,360 360,600 600,1200 1290,2100
seen so far,| where they
|它们使用通常被称为悲观并发控制方案，

166
00:06:00,880 --> 00:06:02,290
0,360 360,510 510,690 690,1020 1020,1410
use what was typically called

167
00:06:02,290 --> 00:06:04,150
0,690 690,1020 1020,1380 1380,1740 1740,1860
pessimistic concurrency control scheme,| and
|悲观控制方案获得锁

168
00:06:04,150 --> 00:06:06,940
0,570 570,1230 1230,1710 1860,2280 2280,2790
pessimistic control scheme basically acquire

169
00:06:06,940 --> 00:06:09,580
0,690 780,1680 1680,2430 2430,2490 2490,2640
locks| {} on you know
|在事务接触到对象时，

170
00:06:09,580 --> 00:06:12,070
0,750 960,2010 2010,2070 2070,2220 2220,2490
the objects are being touched

171
00:06:12,070 --> 00:06:14,680
0,120 120,240 240,960 1200,1860 1860,2610
by the transaction,| {} and
|所以当它们到达提交时间时，

172
00:06:14,680 --> 00:06:15,670
0,240 240,390 390,630 630,810 810,990
{} so when they get

173
00:06:15,670 --> 00:06:17,230
0,120 120,390 390,900 1050,1350 1350,1560
to commit time,| {} they
|它们拥有所有相关对象的所有锁，

174
00:06:17,230 --> 00:06:18,340
0,300 300,450 450,540 540,870 870,1110
own all the locks for

175
00:06:18,340 --> 00:06:19,720
0,180 180,390 390,750 750,1170 1170,1380
all the relevant objects| and
|继续并提交，

176
00:06:19,720 --> 00:06:21,430
0,210 210,360 360,660 660,780 780,1710
just go ahead and commit,|
|

177
00:06:21,580 --> 00:06:23,740
0,990 1110,1350 1350,1530 1530,2070 2070,2160
while {} with optimistic {concurrency
而使用乐观并发控制，

178
00:06:23,740 --> 00:06:25,120
0,300 300,780 780,870 870,1080 1080,1380
-} control,| you don't actually
|你不需要获取锁，

179
00:06:25,120 --> 00:06:27,370
0,720 750,1140 1140,1440 1440,1530 1530,2250
acquire {} {locks -},| particularly
|特别是在 FaRM 中，

180
00:06:27,610 --> 00:06:29,140
0,420 420,480 480,690 720,1200 1200,1530
{in,FaRM},| you don't require locks
|你不需要在读事务中获取锁，

181
00:06:29,140 --> 00:06:31,840
0,300 300,570 870,1470 1500,2160 2190,2700
on the read {} transaction,|
|

182
00:06:32,720 --> 00:06:34,760
0,600 780,1200 1200,1500 1500,1710 1710,2040
and {} when you do
当你执行提交的时候，

183
00:06:34,760 --> 00:06:35,720
0,180 180,540 540,660 660,870 870,960
go commit,| you actually have
|你必须验证，

184
00:06:35,720 --> 00:06:37,940
0,60 60,690 690,1020 1020,1410 1410,2220
to validate,| that you read,
|你读取最近的对象，

185
00:06:37,940 --> 00:06:39,770
0,360 360,1200 1200,1290 1290,1530 1530,1830
{you,know} read the most recent

186
00:06:39,770 --> 00:06:41,630
0,570 780,1200 1200,1440 1440,1560 1560,1860
objects| {} and if so,
|如果是这样，你可以提交，

187
00:06:41,630 --> 00:06:42,680
0,150 150,270 270,600 600,930 930,1050
you can go commit,| and
|如果不是，你必须中止，

188
00:06:42,680 --> 00:06:43,550
0,120 120,270 270,690 690,780 780,870
if you're not, you know

189
00:06:43,550 --> 00:06:44,900
0,150 150,300 300,390 390,900 900,1350
you have to abort| and
|也许还会再试一次。

190
00:06:44,900 --> 00:06:45,960
0,210 210,450 450,780
maybe try again.|
|

191
00:06:46,530 --> 00:06:48,360
0,420 900,1110 1110,1500 1500,1620 1620,1830
And the reason they use
他们使用乐观并发控制的原因，

192
00:06:48,360 --> 00:06:49,770
0,510 510,780 780,1140 1140,1260 1260,1410
optimization concurrence control,| as we'll
|我们稍后将会看到，

193
00:06:49,770 --> 00:06:50,490
0,180 180,240 240,300 300,630 630,720
see in a second,| is
|是由他们想要使用 RDMA 这一事实驱动的。

194
00:06:50,490 --> 00:06:51,780
0,300 300,720 720,900 900,990 990,1290
really driven by the fact

195
00:06:51,780 --> 00:06:52,890
0,120 120,300 300,510 510,600 600,1110
that they want to use

196
00:06:52,890 --> 00:06:53,840
0,150 150,690
{RDMA -}.|
|

197
00:06:54,400 --> 00:06:55,400
0,690

198
00:06:56,820 --> 00:06:57,630
0,240 240,360 360,510 510,570 570,810
Okay, so then the final
好的，那么最后一个部分是概述，

199
00:06:57,630 --> 00:06:58,890
0,390 390,690 690,870 870,1140 1140,1260
component to this is {}

200
00:06:58,890 --> 00:07:00,090
0,270 270,720 720,900 900,990 990,1200
certain overview,| this is really
|这是一个研究原型，

201
00:07:00,090 --> 00:07:01,400
0,60 60,390 390,1050
a research prototype,|
|

202
00:07:05,250 --> 00:07:06,750
0,210 210,300 300,420 420,870 930,1500
so {unlike - -} {}
与 Spanner 不同，是已部署的系统，

203
00:07:06,780 --> 00:07:07,980
0,600 600,720 720,810 810,1020 1020,1200
Spanner, you know which is

204
00:07:07,980 --> 00:07:11,160
0,210 240,1020 1230,2130 2190,2640 2640,3180
a deployed system,| you know
|它一直在活跃地使用，

205
00:07:11,550 --> 00:07:14,010
0,180 180,750 750,1080 1080,1590 1800,2460
it's been active use, {}|
|

206
00:07:14,040 --> 00:07:15,750
0,450 450,570 570,1050 1050,1350 1350,1710
FaRM is really a product
FARM 是微软研究的产品，

207
00:07:15,750 --> 00:07:17,190
0,420 480,690 690,1050 1050,1290 1290,1440
of the research [] of

208
00:07:17,190 --> 00:07:19,860
0,660 930,1680 1680,2280 2310,2580 2580,2670
Microsoft,| Microsoft research trying to
|微软研究试图探索新想法，

209
00:07:19,860 --> 00:07:22,590
0,510 510,750 750,1440 1620,2010 2010,2730
explore new ideas,| to see
|看看什么能获得更高的

210
00:07:22,590 --> 00:07:23,910
0,240 240,420 420,840 870,1020 1020,1320
how, { -} to see

211
00:07:23,910 --> 00:07:25,620
0,210 210,240 240,510 510,1080 1080,1710
what {} can achieve higher|
|

212
00:07:25,740 --> 00:07:27,300
0,240 240,480 480,690 690,1170 1170,1560
or really high performance transaction
或很高的性能的事务系统，

213
00:07:27,300 --> 00:07:28,170
0,360 360,450 450,600 600,690 690,870
systems,| and this is just
|这是一项非常活跃的研究，

214
00:07:28,170 --> 00:07:30,360
0,30 30,300 300,810 810,1500 1530,2190
a very active research,| people
|人们喜欢拥有事务的力量，

215
00:07:30,360 --> 00:07:31,620
0,180 180,360 360,570 570,660 660,1260
would just love to have

216
00:07:31,890 --> 00:07:34,050
0,570 570,1050 1050,1380 1380,1440 1440,2160
{} the power of transactions,|
|

217
00:07:34,230 --> 00:07:35,940
0,600 600,780 780,930 930,1290 1290,1710
{} and but also the
但是也想要性能。

218
00:07:36,030 --> 00:07:36,800
0,690
performance.|
|

219
00:07:37,780 --> 00:07:38,900
0,690

220
00:07:40,430 --> 00:07:41,690
0,300 300,480 480,720 720,930 930,1260
Okay, so that's sort of
好的，这是一个简短的介绍，

221
00:07:41,690 --> 00:07:43,100
0,300 300,750 750,930 930,1290 1290,1410
short introduction,| any questions so
|到目前为止，有什么问题吗？

222
00:07:43,100 --> 00:07:43,880
0,480
far?|
|

223
00:07:49,860 --> 00:07:52,200
0,630 900,1200 1200,1830 2070,2310 2310,2340
Okay, let's {} talk a
好的，让我们来谈谈 FaRM 的设置。

224
00:07:52,200 --> 00:07:54,030
0,180 180,360 360,660 660,1110 1140,1830
little bit about the setup

225
00:07:59,060 --> 00:08:00,300
0,390 390,960
for FaRM.|
|

226
00:08:00,510 --> 00:08:02,880
0,420 420,660 660,1050 1260,1980 2040,2370
And so there's basically 90
所以这里有 90 台机器，

227
00:08:02,880 --> 00:08:04,140
0,630
machines,

228
00:08:10,150 --> 00:08:11,710
0,360 360,450 450,630 630,1200 1260,1560
90 of these guys, {}|
|

229
00:08:11,710 --> 00:08:13,870
0,180 180,690 720,1320 1320,1470 1470,2160
they're connected by {} high-speed
它们通过高速数据中心网络连接，

230
00:08:13,960 --> 00:08:16,360
0,600 600,780 780,1350 1380,1950 1980,2400
data center network,| and see
|看其中一个，

231
00:08:16,360 --> 00:08:18,040
0,150 150,510 510,930 1230,1530 1530,1680
a particular one,| I'm just
|我把它画成一条线，

232
00:08:18,040 --> 00:08:19,060
0,120 120,180 180,480 480,780 780,1020
going to draw that as

233
00:08:19,060 --> 00:08:20,920
0,450 540,960 960,1350 1350,1560 1560,1860
a single line,| of course,
|当然，内部是一个交换网络，

234
00:08:20,920 --> 00:08:22,630
0,150 150,240 240,630 630,990 990,1710
it's a switch network internally,|
|

235
00:08:23,020 --> 00:08:27,970
0,720 1140,2580 2820,3570 3570,4260 4410,4950
{} and basically shard,| {the,data,is}
然后分片，|数据分片在这些不同的机器上，

236
00:08:27,970 --> 00:08:31,480
0,420 420,1230 1470,2010 2010,2850 2850,3510
sharded across these different machines,|
|

237
00:08:31,690 --> 00:08:32,880
0,930
and
根据分片的级别，一些也称为区域，

238
00:08:33,100 --> 00:08:35,170
0,720 810,1350 1350,1440 1440,1740 1740,2070
the level of sharding happens,

239
00:08:35,170 --> 00:08:36,970
0,480 480,750 750,960 960,1170 1170,1800
{} some else called region,|
|

240
00:08:37,800 --> 00:08:41,120
0,480 840,1410 1410,1560 1560,2160
so region is 2
所以区域是 2G 字节，

241
00:08:41,570 --> 00:08:42,860
0,810
gigabyte,|
|

242
00:08:44,730 --> 00:08:45,840
0,420 420,510 510,660 660,840 840,1110
and you know those regions
这些区域分片在

243
00:08:45,840 --> 00:08:47,610
0,120 120,450 450,870 870,1140 1140,1770
are sharded| across different networks
|不同的网络，不同的机器上，

244
00:08:48,230 --> 00:08:49,790
0,210 210,330 330,600 600,1140 1230,1560
and the different machines, {}|
|

245
00:08:49,790 --> 00:08:51,620
0,150 150,450 450,810 840,1230 1260,1830
the region live in memory,|
区域在内存中，|

246
00:08:52,010 --> 00:08:53,390
0,150 150,360 360,450 450,690 690,1380
so this is just DRAM,|
所以这是 DRAM ，|

247
00:08:56,490 --> 00:08:58,800
0,390 390,750 750,1290 1290,1830 1830,2310
{} and not {} in
而不是在磁盘上，

248
00:08:58,800 --> 00:09:00,120
0,270 270,360 360,420 420,930 960,1320
{for,example} on the disk,| so
|所以，你的数据库的全部数据集

249
00:09:00,120 --> 00:09:03,540
0,690 960,1920 2010,2760 2790,3150 3150,3420
basically, {} the total {dataset

250
00:09:03,540 --> 00:09:05,160
0,420 420,720 720,900 900,1380 1380,1620
-} of your database| actually
|必须与你使用的机器的联合 DRAM 相适应，

251
00:09:05,160 --> 00:09:06,390
0,240 240,330 330,690 690,1080 1080,1230
has to fit in the

252
00:09:06,390 --> 00:09:08,610
0,630 900,1770 1770,1830 1830,1920 1920,2220
joint DRAMs of the machine

253
00:09:08,610 --> 00:09:09,510
0,120 120,270 270,630 630,810 810,900
that you're using,| so if
|如果你的数据集大于你当前的计算机集，

254
00:09:09,510 --> 00:09:10,770
0,210 210,600 600,690 690,1080 1080,1260
your dataset is larger than

255
00:09:10,770 --> 00:09:11,580
0,90 90,300 300,420 420,480 480,810
your current set of machines,|
|

256
00:09:11,580 --> 00:09:12,360
0,90 90,210 210,270 270,480 480,780
you have to buy more
你必须购买更多机器，拥有更多 DRAM ，

257
00:09:12,360 --> 00:09:13,620
0,420 420,540 540,630 630,810 810,1260
machines, that get more DRAM,|
|

258
00:09:13,620 --> 00:09:14,550
0,150 150,240 240,360 360,630 630,930
so they can actually fit.|
这样它们才能适合。|

259
00:09:16,150 --> 00:09:17,320
0,180 180,480 480,540 540,810 810,1170
And again, the reason why
他们想使用 DRAM 的原因是，

260
00:09:17,320 --> 00:09:19,060
0,150 150,300 300,1350 1380,1680 1680,1740
you know they want to

261
00:09:19,060 --> 00:09:20,410
0,180 180,600 600,720 720,1050 1050,1350
use DRAM is,| because they
|他们想要[]存储设备性能方面的瓶颈，

262
00:09:20,410 --> 00:09:21,640
0,240 240,330 330,540 540,750 750,1230
want {[] - -} bottleneck

263
00:09:21,640 --> 00:09:22,360
0,390
by

264
00:09:22,710 --> 00:09:25,410
0,390 390,990 990,1530 1710,2370 2370,2700
the performance of {} storage

265
00:09:25,410 --> 00:09:28,860
0,690 870,1680 1800,1980 2880,3270 3270,3450
devices,| and of course {you,know}
|当然，机器可能出现故障，

266
00:09:28,860 --> 00:09:30,270
0,300 300,450 450,1020 1020,1290 1290,1410
machine can fail,| and if
|如果机器出现故障，它会丢失 DRAM ，

267
00:09:30,270 --> 00:09:32,130
0,30 30,330 330,720 720,1350 1350,1860
a machine fails, {it,uses} loses

268
00:09:32,130 --> 00:09:34,170
0,600 720,1200 1200,1410 1410,1740 1740,2040
DRAM,| {} and so therefore
|所以，他们使用复制，

269
00:09:34,170 --> 00:09:35,880
0,120 120,270 270,870 1080,1530 1530,1710
they use replication,| and so
|他们在多台机器上复制区域，

270
00:09:35,880 --> 00:09:37,860
0,180 180,750 750,1200 1200,1650 1650,1980
they replicate regions across multiple

271
00:09:37,860 --> 00:09:39,750
0,600 930,1170 1170,1410 1410,1770 1770,1890
machines,| {} one machine is
|一台机器是一个区域的 primary ，

272
00:09:39,750 --> 00:09:41,910
0,450 480,1020 1020,1470 1470,1590 1590,2160
{} primary for a region,|
|

273
00:09:42,210 --> 00:09:43,740
0,240 240,450 450,720 720,810 810,1530
and that makes {} machine
使区域可能被复制到另一台机器上，

274
00:09:43,740 --> 00:09:45,210
0,270 270,480 480,780 810,1350 1350,1470
region might be replicated on

275
00:09:45,210 --> 00:09:46,680
0,270 270,840 1020,1230 1230,1350 1350,1470
another machine,| which is in
|在备机上，

276
00:09:46,680 --> 00:09:48,000
0,90 90,480 480,630 630,990 990,1320
the backup,| so use primary
|所以使用主备进行复制，

277
00:09:48,000 --> 00:09:49,040
0,390 390,900
backup for

278
00:09:49,240 --> 00:09:53,380
0,840 1230,2130 2130,2550 2580,3450 3660,4140
{ - -} replication,| and
|所以这是区域 1 ，区域 2 ，

279
00:09:53,380 --> 00:09:55,060
0,210 210,540 540,840 840,1410
so this region 1,

280
00:09:55,920 --> 00:09:57,300
0,300 300,600 600,1080 1080,1290 1290,1380
{you,know} region 2,| {you,know} the
|（2的）备份可能在（1的）主机的同一台机器上，

281
00:09:57,300 --> 00:09:58,680
0,540 540,780 780,900 900,1110 1110,1380
backup might be on the

282
00:09:58,710 --> 00:10:00,390
0,300 300,630 630,810 810,1110 1140,1680
same machine as the primary|
|

283
00:10:00,390 --> 00:10:02,730
0,450 450,930 990,1410 1440,1830 1830,2340
for backup for region 2,|
作为区域 2 的备份，|

284
00:10:03,090 --> 00:10:04,440
0,330 330,960 960,1080 1080,1260 1260,1350
and here we have the
这里我们有区域 2 的主机。

285
00:10:04,440 --> 00:10:05,940
0,630 720,1020 1020,1260
primary region 2.|
|

286
00:10:06,710 --> 00:10:08,750
0,480 930,1200 1200,1440 1440,1920 1920,2040
{} So this deals you
所以这决定了，

287
00:10:08,750 --> 00:10:10,520
0,150 150,330 330,600 600,1350 1500,1770
know,| so one machine has
|一台机器出现内核 panic ，

288
00:10:10,520 --> 00:10:11,690
0,60 60,390 390,870 870,1020 1020,1170
a kernel panic| or some
|或者某个设备死机，

289
00:10:11,690 --> 00:10:13,700
0,660 660,900 900,1470 1470,1890 1920,2010
device goes that| or you
|或者只是因为其他原因而崩溃，

290
00:10:13,700 --> 00:10:15,590
0,570 600,870 870,1350 1350,1770 1770,1890
know just crashes for some

291
00:10:15,590 --> 00:10:18,110
0,210 210,660 870,1470 1470,1470 2220,2520
other reason,| then {} there's
|然后还有第二台机器，

292
00:10:18,110 --> 00:10:19,490
0,420 420,660 660,1020 1020,1140 1140,1380
a second machine,| that actually
|它有数据的复制，并从那里继续进行。

293
00:10:19,490 --> 00:10:20,810
0,210 210,270 270,930 960,1230 1230,1320
has a copy of the

294
00:10:20,810 --> 00:10:21,950
0,240 240,480 480,630 630,1020 1020,1140
data and just proceed from

295
00:10:21,950 --> 00:10:22,420
0,270
there.|
|

296
00:10:23,120 --> 00:10:24,320
0,150 150,540 690,960 960,1050 1050,1200
Of course, then we need
当然，我们需要某种方法来跟踪

297
00:10:24,320 --> 00:10:26,150
0,390 420,840 840,900 900,1200 1200,1830
some way of keeping track

298
00:10:26,240 --> 00:10:28,790
0,210 210,330 330,840 840,1470 1710,2550
of| the mapping from {}
|区域到主机和备机的映射，

299
00:10:29,330 --> 00:10:32,210
0,690 720,1560 1560,2280 2310,2640 2640,2880
regions to {} {primaries,and -}

300
00:10:32,210 --> 00:10:33,830
0,570 570,780 780,1050 1050,1260 1260,1620
backups,| and so they use
|所以，他们使用配置管理器，

301
00:10:33,830 --> 00:10:36,200
0,300 300,1110 1200,1950
a configuration manager,|
|

302
00:10:36,790 --> 00:10:38,050
0,690 690,900 900,1080 1080,1170 1170,1260
{a,CM} that sits on the
一个 CM 在这里，

303
00:10:38,050 --> 00:10:39,000
0,630
side,|
|

304
00:10:39,370 --> 00:10:40,870
0,270 270,420 420,900 900,1230 1230,1500
and CM itself actually is
CM 本身与我们之前看过的 zookeeper 相结合，

305
00:10:40,870 --> 00:10:42,670
0,570 600,1230 1230,1380 1380,1680 1680,1800
coupled with a system that

306
00:10:42,670 --> 00:10:44,140
0,150 150,360 360,750 750,930 930,1470
we've seen before {zookeeper -},|
|

307
00:10:45,780 --> 00:10:48,210
0,420 420,720 720,1020 1020,1980 1980,2430
and really the zookeeper and
zookeeper 和配置管理器跟踪，

308
00:10:48,210 --> 00:10:49,680
0,120 120,660 660,1140 1140,1290 1290,1470
the configuration management that keep

309
00:10:49,680 --> 00:10:51,820
0,600 780,930 930,1020 1020,1710
track of| the mapping
|从区域编号到主机和备机的映射，

310
00:10:55,080 --> 00:10:57,120
0,240 240,690 690,1020 1020,1620
{you,know} from region number

311
00:10:59,260 --> 00:11:01,390
0,300 300,420 420,1260 1290,1620 1620,2130
to the primary and whatever

312
00:11:01,390 --> 00:11:02,380
0,90 90,720
the backups,|
|

313
00:11:04,530 --> 00:11:05,920
0,1080
{for,every,region}.|
对于每个区域。|

314
00:11:06,390 --> 00:11:09,180
0,690 1770,2490
Okay? {}|
好的?|

315
00:11:09,690 --> 00:11:12,330
0,450 450,840 840,1290 1470,2190 2340,2640
Now there's one a serious
当然，现在这里有一个严重的问题，

316
00:11:12,330 --> 00:11:13,800
0,240 240,330 330,570 570,1110 1110,1470
problem of course here,| I
|我讨论过，

317
00:11:13,800 --> 00:11:14,790
0,120 120,390 390,630 630,810 810,990
I talked about,| like while
|使用主备方案，

318
00:11:14,790 --> 00:11:16,710
0,570 570,810 810,1080 1080,1410 1410,1920
primary with primary backup replication

319
00:11:16,710 --> 00:11:18,060
0,240 240,510 510,630 630,750 750,1350
way,| so we have fault,|
|我们会有故障，|

320
00:11:18,180 --> 00:11:19,830
0,900 930,1080 1080,1290 1290,1530 1530,1650
then {you,know} one machine can
一台机器可能会出故障，

321
00:11:19,830 --> 00:11:20,700
0,360 360,450 450,540 540,780 780,870
fail,| now the machine can
|现在机器可以接手，

322
00:11:20,700 --> 00:11:22,920
0,210 210,630 870,1470 1470,2130 2130,2220
take over,| {} except the
|除了一种棘手的情况，

323
00:11:22,920 --> 00:11:24,900
0,360 390,870 870,1380 1380,1830 1830,1980
{one,sort,of} tricky case,| that this
|到目前为止这个方案不能处理，

324
00:11:24,900 --> 00:11:27,240
0,270 270,480 480,1170 1410,1740 1740,2340
scheme can't handle so far,|
|

325
00:11:27,390 --> 00:11:28,740
0,420 420,630 630,780 780,840 840,1350
is when there's a correlated
当出现相关的故障时，

326
00:11:28,740 --> 00:11:29,700
0,300 300,360 360,750 750,900 900,960
failure,| for example there's a
|例如，数据中心停电，

327
00:11:29,700 --> 00:11:30,810
0,330 330,690 690,780 780,870 870,1110
power failure of the data

328
00:11:30,810 --> 00:11:32,820
0,480 780,1260 1260,1470 1470,1860 1860,2010
center,| and all machines should
|所有的机器都会停机，

329
00:11:32,820 --> 00:11:33,600
0,90 90,270 270,690
now go down,|
|

330
00:11:34,190 --> 00:11:35,690
0,300 300,420 420,630 630,840 840,1500
and to handle that case,|
为了处理这种情况，|

331
00:11:35,840 --> 00:11:39,140
0,690 690,810 810,1470 1500,2250 2610,3300
basically the DRAM {} has
DRAM 位于 UPS 上，

332
00:11:39,140 --> 00:11:40,610
0,180 180,420 420,600 600,990 1020,1470
it sits on a UPS,|
|

333
00:11:40,610 --> 00:11:41,900
0,150 150,360 360,930 930,1140 1140,1290
where every machine sits on
每台机器都有一个不间断的电源，

334
00:11:41,900 --> 00:11:44,600
0,120 120,1020 1020,1380 1380,2040 2460,2700
an uninterruptible power supply,| {so,I'm}
|所以我要画一个大电池放在边上，

335
00:11:44,720 --> 00:11:45,830
0,210 210,270 270,570 570,750 750,1110
going to draw these a

336
00:11:45,830 --> 00:11:47,030
0,270 270,750 750,900 900,1110 1110,1200
big battery that sits on

337
00:11:47,030 --> 00:11:47,840
0,60 60,570
the side,|
|

338
00:11:54,520 --> 00:11:56,620
0,600 810,1080 1080,1170 1170,1680 1680,2100
and {} the battery basically
电池或者 UPS 提供足够的能量，

339
00:11:56,620 --> 00:11:57,670
0,150 150,300 300,810 810,900 900,1050
or {UPS -} you know

340
00:11:57,670 --> 00:11:59,830
0,360 360,720 720,1260 1260,1830 1830,2160
provides enough energy,| that {}
|如果发生全局停电，

341
00:11:59,830 --> 00:12:01,600
0,390 390,600 600,870 900,1410 1410,1770
if there's a global power

342
00:12:01,600 --> 00:12:03,820
0,660 900,1320 1320,1620 1620,2010 2010,2220
failure,| {} the machine keep
|机器会继续运转一小段时间，

343
00:12:03,820 --> 00:12:04,900
0,300 300,420 420,480 480,720 720,1080
running for a little time,|
|

344
00:12:04,900 --> 00:12:06,220
0,120 120,330 330,450 450,720 720,1320
and ended up {a,little} time,|
这一小段时间，|

345
00:12:06,490 --> 00:12:07,780
0,480 480,660 660,930 930,1050 1050,1290
{} the machine can actually
机器可以存储，

346
00:12:07,780 --> 00:12:09,730
0,630 900,1230 1290,1710 1710,1800 1800,1950
store,| the FaRM would like
|FaRM 将数据存储在 SSD 上，

347
00:12:09,730 --> 00:12:11,440
0,120 120,480 480,570 570,840 840,1710
to store the data on

348
00:12:11,950 --> 00:12:13,390
0,270 270,720 720,840 840,930 930,1440
on {SSDs -}| or basically
|或者只是刷新它的内存中的内容，

349
00:12:13,510 --> 00:12:15,820
0,510 570,1470 1590,1710 1710,2220 2220,2310
just flush the contents of

350
00:12:15,820 --> 00:12:18,430
0,150 150,750 780,1200 1200,1470 1680,2610
its memory,| all the regions,
|所有区域，所有事务状态，所有事务日志，

351
00:12:18,430 --> 00:12:20,830
0,210 210,690 720,1230 1230,1800 1800,2400
all the transaction state, all

352
00:12:21,190 --> 00:12:24,400
0,1440 1440,1590 1590,1650 1650,2370 2580,3210
logs for the transactions,| actually
|将它们刷新到 SSD 上，

353
00:12:24,400 --> 00:12:26,020
0,390 390,630 630,1200 1230,1470 1470,1620
flushes {it,to} SSD,| so if
|所以，如果整个数据中心完全停电，

354
00:12:26,020 --> 00:12:27,700
0,180 180,210 210,720 720,1110 1110,1680
there's a complete power failure

355
00:12:27,880 --> 00:12:29,590
0,360 360,600 600,840 840,1110 1110,1710
of the whole data center,|
|

356
00:12:29,680 --> 00:12:30,640
0,300 300,420 420,660 660,870 870,960
{} the data center at
数据中心将在某个时间恢复运行，

357
00:12:30,640 --> 00:12:31,570
0,120 120,390 390,510 510,660 660,930
some point will come back

358
00:12:31,570 --> 00:12:33,010
0,420 510,630 630,750 750,930 930,1440
up,| and they can load
|它们可以从 SSD 中加载机器的内存内容，

359
00:12:33,040 --> 00:12:35,560
0,120 120,270 270,900 1260,1890 1890,2520
you know the memory contents

360
00:12:35,560 --> 00:12:37,000
0,270 270,510 510,1020 1020,1290 1290,1440
of the machines from the

361
00:12:37,000 --> 00:12:39,010
0,690 840,1170 1170,1350 1350,1650 1650,2010
SSD,| and {you,know} start basically
|重新开始运行，

362
00:12:39,010 --> 00:12:39,740
0,300 300,660
running again,|
|

363
00:12:40,560 --> 00:12:41,460
0,180 180,270 270,450 450,540 540,900
and so this is basically
这是唯一使用 SSD 的地方，

364
00:12:41,460 --> 00:12:43,350
0,90 90,420 420,960 960,1650 1740,1890
the only place where the

365
00:12:43,350 --> 00:12:44,700
0,360 360,420 420,540 540,750 750,1350
{SSDs -} are being used,|
|

366
00:12:45,000 --> 00:12:46,590
0,420 420,660 660,780 780,1110 1110,1590
{ -} to deal with
为了处理数据中心内的多台机器的相关故障。

367
00:12:46,590 --> 00:12:49,470
0,450 480,1020 1020,1710 2130,2430 2430,2880
{} correlated failure many machines

368
00:12:49,470 --> 00:12:50,740
0,390 390,480 480,690 690,1020
in the data center.|
|

369
00:12:53,750 --> 00:12:55,500
0,240 240,630 630,1050 1050,1470
Any questions so far?|
到目前为止，有什么问题吗？|

370
00:13:03,180 --> 00:13:04,020
0,210 210,420 420,600 600,750 750,840
Okay, let me say a
好的，让我简单介绍一下软件，

371
00:13:04,020 --> 00:13:05,790
0,180 180,330 330,630 630,1170 1170,1770
little bit about {the,software -},|
|

372
00:13:05,880 --> 00:13:07,560
0,390 390,690 690,870 870,1020 1020,1680
{} so in the regions,|
所以在区域里，|

373
00:13:07,650 --> 00:13:08,610
0,270 270,420 420,570 570,630 630,960
so we have a region
我们在这里有一个区域，

374
00:13:08,610 --> 00:13:09,460
0,540
here,|
|

375
00:13:09,740 --> 00:13:11,180
0,210 210,330 330,480 480,930 930,1440
{} in the region {}
在区域中有一些对象，

376
00:13:11,180 --> 00:13:12,680
0,660 660,1050
objects live,|
|

377
00:13:13,390 --> 00:13:14,110
0,150 150,240 240,360 360,570 570,720
so you can just think
所以你可以把区域想象成一个字节数组，

378
00:13:14,110 --> 00:13:15,730
0,300 300,510 510,1020 1020,1290 1290,1620
about an array, {} region

379
00:13:15,730 --> 00:13:17,170
0,390 420,870 870,1050 1050,1350 1350,1440
as {} an array of

380
00:13:17,170 --> 00:13:18,880
0,480 480,600 600,960 960,1020 1020,1710
bytes,| {you,know} {2,gigabytes - -},|
|2G 字节，|

381
00:13:19,240 --> 00:13:20,680
0,210 210,660 660,840 840,1350 1350,1440
and in {you,know} array of
在字节对象数组中，有一些对象，

382
00:13:20,680 --> 00:13:22,420
0,480 480,1230
bytes, {objects,live},|
|

383
00:13:22,800 --> 00:13:24,630
0,450 450,900 900,1350 1350,1530 1530,1830
and objects have a unique
对象有唯一的标识符 oid ，

384
00:13:24,630 --> 00:13:26,400
0,720
identifier

385
00:13:29,220 --> 00:13:31,180
0,480 480,1170
{oid -},|
|

386
00:13:31,550 --> 00:13:32,900
0,450 450,630 630,1170 1170,1290 1290,1350
and the oid of an
对象 oid 不是别的，

387
00:13:32,900 --> 00:13:34,100
0,300 300,390 390,630 630,990 990,1200
object is nothing else, {}|
|

388
00:13:34,100 --> 00:13:35,540
0,180 180,600 600,1140
{} {it's,region} number,
它是[]区域编号和区域内的地址，

389
00:13:36,860 --> 00:13:39,020
0,600 600,750 750,1050 1050,1620 2010,2160
[] the region number and

390
00:13:39,020 --> 00:13:40,430
0,360 360,480 480,1140 1170,1290 1290,1410
then the address you know

391
00:13:40,430 --> 00:13:41,960
0,420 420,810 810,1230
within that region,|
|

392
00:13:48,860 --> 00:13:52,340
0,540 540,1440 1470,1770 1770,2340 2760,3480
{} associated with every object,|
与每个对象绑定，|

393
00:13:52,340 --> 00:13:53,060
0,180 180,240 240,480 480,600 600,720
there's a little bit of
这里有一些对象的元数据，

394
00:13:53,060 --> 00:13:55,700
0,720 960,1620 1620,1800 1800,2130 2130,2640
metadata for that particular object,|
|

395
00:13:56,090 --> 00:13:58,460
0,270 270,510 510,1800 1800,1860 1860,2370
and in particular {} for
对象头部包含一个 64 位数字，

396
00:13:58,490 --> 00:14:01,160
0,480 480,750 750,1530 1740,2190 2190,2670
object header contains a 64

397
00:14:01,160 --> 00:14:02,200
0,180 180,690
bit number,|
|

398
00:14:05,870 --> 00:14:08,240
0,390 390,510 510,1410 1470,1980 2040,2370
and the number consists is
该数字包含底部 63 位版本号，

399
00:14:08,240 --> 00:14:11,100
0,660 1290,1620 1620,1980 1980,2520
basically a version number

400
00:14:13,420 --> 00:14:15,220
0,330 330,540 570,900 900,1650 1650,1800
in the bottom 63| and
|然后是一个锁位，我们会在顶部看到，

401
00:14:15,220 --> 00:14:16,360
0,120 120,240 240,600 600,990 990,1140
then a lock bit, as

402
00:14:16,360 --> 00:14:18,130
0,120 120,600 810,1140 1140,1350 1350,1770
we'll see in the top

403
00:14:18,130 --> 00:14:19,810
0,660 690,1050 1320,1470 1470,1530 1530,1680
{} bit, in the high

404
00:14:19,810 --> 00:14:20,640
0,270 270,540
order bit,|
|

405
00:14:21,330 --> 00:14:23,340
0,390 450,1050 1080,1500 1500,1710 1710,2010
so every object has this
所以每个对象都有这个 64 位数字，

406
00:14:23,340 --> 00:14:25,110
0,900 930,1050 1050,1170 1170,1620 1620,1770
{} you know 64 bit

407
00:14:25,110 --> 00:14:26,400
0,390 390,630 630,960 960,1110 1110,1290
number,| {} refer to as
|称为版本号，

408
00:14:26,400 --> 00:14:28,350
0,180 300,750 750,1200 1440,1770 1770,1950
a version number,| and then
|然后我们将看到它在乐观并发控制中起重要作用。

409
00:14:28,350 --> 00:14:29,340
0,150 150,600 600,660 660,930 930,990
we'll see {} plays an

410
00:14:29,340 --> 00:14:31,350
0,450 450,930 930,1260 1260,1470 1470,2010
important role in the optimistic

411
00:14:31,350 --> 00:14:32,460
0,90 90,420 420,870
{concurrency -} control.|
|

412
00:14:33,720 --> 00:14:38,240
0,630 1170,1920 1920,3000 3360,4200
{} {The,way} applications {}
应用程序使用这个系统的方式，

413
00:14:38,990 --> 00:14:40,850
0,390 390,750 750,930 930,1470 1470,1860
{use,you} know this system,| let
|让我稍微说一下，

414
00:14:40,850 --> 00:14:41,570
0,90 90,270 270,360 360,570 570,720
me say a little bit

415
00:14:41,570 --> 00:14:42,680
0,240 240,480 480,630 630,870 870,1110
about that,| so what's the
|应用程序编程接口是什么。

416
00:14:42,680 --> 00:14:44,520
0,480 480,960 960,1650
application programmer interface.|
|

417
00:14:53,060 --> 00:14:54,560
0,390 390,540 540,1020 1020,1380 1380,1500
So the API is| you
所以 API 是，|你启动事务，

418
00:14:54,560 --> 00:14:56,340
0,90 90,300 300,630 630,1350
know you start transaction,|
|

419
00:15:00,080 --> 00:15:01,760
0,540 540,690 690,900 900,1050 1050,1680
and you read some objects,|
读取一些对象，|

420
00:15:05,490 --> 00:15:07,560
0,180 180,420 420,510 510,990 1410,2070
so there is read call,|
这是 read 调用，|

421
00:15:07,560 --> 00:15:09,540
0,120 120,420 420,1080 1080,1290 1290,1980
and {read,call,takes -} {oid -}
read 调用将 oid 作为参数，

422
00:15:09,720 --> 00:15:13,530
0,90 90,180 180,870 1860,2610 2910,3810
as an argument,| {} the
|然后，应用程序可以操作，

423
00:15:14,290 --> 00:15:16,510
0,810 810,990 1290,1410 1410,2070 2070,2220
application then can manipulate,| {you,know}
|修改对象中的字段，

424
00:15:16,510 --> 00:15:18,490
0,330 330,390 390,900 1110,1590 1590,1980
change the fields in the,

425
00:15:18,700 --> 00:15:20,470
0,270 270,360 360,990 990,1530 1530,1770
in the object,| whatever add
|不管什么，比如加 1 ，

426
00:15:20,470 --> 00:15:21,820
0,210 210,420 420,630
1 to it,|
|

427
00:15:22,270 --> 00:15:23,290
0,300 300,540 540,780 780,870 870,1020
{} and then at some
然后在某个时刻写入对象，

428
00:15:23,290 --> 00:15:24,800
0,330 330,540 540,1050
point {} write

429
00:15:27,300 --> 00:15:29,000
0,330 330,1380
the object,|
|

430
00:15:31,660 --> 00:15:32,800
0,240 240,450 450,570 570,810 810,1140
write {update -} the object
使用 write 调用更新对象自己，

431
00:15:32,800 --> 00:15:34,660
0,600 600,1200 1200,1380 1380,1770 1770,1860
itself {using,the} write call| and
|然后使用 txcommit 提交它。

432
00:15:34,660 --> 00:15:36,820
0,360 360,450 450,750 1140,1650 1710,2160
then you know {commit,it} using

433
00:15:36,820 --> 00:15:38,840
0,840 840,990 990,1380
{txcommit - -}.|
|

434
00:15:41,310 --> 00:15:42,960
0,690 840,1110 1110,1320 1320,1500 1500,1650
And it might also be
也可能是这种情况，

435
00:15:42,960 --> 00:15:45,840
0,240 240,570 570,930 930,1590 2400,2880
the case that,| {} {the,transaction}
|事务需要中止，

436
00:15:45,840 --> 00:15:46,560
0,90 90,210 210,300 300,420 420,720
{} needs to {abort -

437
00:15:46,560 --> 00:15:48,090
0,570 570,810 810,930 930,1020 1020,1530
-},| because of the optimistic
|因为是乐观并发控制，

438
00:15:48,090 --> 00:15:49,620
0,300 300,690 690,870 870,1050 1050,1530
concurrency control,| in that case,
|在这种情况下，应用程序将重试事务，

439
00:15:49,770 --> 00:15:51,210
0,360 360,480 480,990 990,1110 1110,1440
{} the application will typically

440
00:15:51,210 --> 00:15:53,200
0,180 180,930 960,1140 1140,1710
just retry the transaction,|
|

441
00:15:53,830 --> 00:15:55,990
0,540 1590,1740 1740,1950 1950,2070 2070,2160
{} and so in the
所以，在这里显示的事务中，

442
00:15:55,990 --> 00:15:58,510
0,1500 1500,1560 1560,2100 2100,2370 2370,2520
{transaction\,,the,way,it} shows transaction here,| there's
|只有一个对象操作，

443
00:15:58,510 --> 00:16:00,220
0,180 180,390 390,780 780,1380 1470,1710
only one object manipulated,| yeah,
|但它实际操作很多对象，

444
00:16:00,220 --> 00:16:01,810
0,150 150,240 240,420 420,900 990,1590
but it seems actually manipulate

445
00:16:01,810 --> 00:16:03,220
0,210 210,420 420,870 870,1110 1110,1410
many, many objects,| those objects
|这些对象可能位于不同的区域，

446
00:16:03,220 --> 00:16:04,600
0,180 180,270 270,570 570,840 840,1380
could be on a different

447
00:16:04,630 --> 00:16:07,510
0,810 1170,1860 1860,2160 2160,2400 2400,2880
regions,| and {} and so
|所以它们必须有一些方案，

448
00:16:07,600 --> 00:16:08,230
0,120 120,240 240,330 330,540 540,630
you know they have to

449
00:16:08,230 --> 00:16:09,670
0,120 120,330 330,780 780,930 930,1440
have some plans,| we'll see,|
|我们将会看到，|

450
00:16:09,700 --> 00:16:10,900
0,210 210,420 420,690 690,930 930,1200
we're running some {two-phase -}
我们使用类似两阶段提交的协议来执行原子操作，

451
00:16:10,900 --> 00:16:13,330
0,300 300,540 540,1320 1380,1860 1860,2430
commit like protocol {} to

452
00:16:13,330 --> 00:16:16,420
0,240 240,630 630,1320 1320,2070 2220,3090
do atomic operations| across objects
|跨不同地区的对象。

453
00:16:16,420 --> 00:16:18,380
0,300 300,390 390,870 930,1890
living in different regions.|
|

454
00:16:20,210 --> 00:16:21,530
0,450 450,660 660,720 720,1050 1050,1320
Any sort of questions about
关于 API 和设置，有什么问题吗？

455
00:16:21,530 --> 00:16:22,320
0,420
the

456
00:16:22,810 --> 00:16:25,040
0,750 750,1350 1650,1950
API {and,setup -}?|
|

457
00:16:29,910 --> 00:16:31,860
0,360 360,660 660,840 840,1590 1710,1950
{} Sorry, the address {oid
抱歉，地址 oid ，是在机器本身的地址吗？

458
00:16:31,860 --> 00:16:34,110
0,540 540,690 690,1050 1080,1530 1530,2250
-}, it is {the,address -}

459
00:16:34,170 --> 00:16:37,290
0,630 660,1140 1140,1560 1560,2310 2700,3120
in the machine itself?| Yeah,
|是的，是那个区域内的偏移量。

460
00:16:37,290 --> 00:16:39,930
0,210 210,300 300,1230 1230,1860 1980,2640
which is the offset {}

461
00:16:39,930 --> 00:16:41,180
0,330 330,540 540,930
within that region.|
|

462
00:16:46,300 --> 00:16:47,260
0,690
Okay?|
好的？|

463
00:16:48,380 --> 00:16:49,700
0,180 180,480 480,630 630,990 990,1320
The region could move, correct,|
区域可以移动，|

464
00:16:49,790 --> 00:16:51,830
0,120 120,450 480,750 750,1230 1230,2040
you know that the replicated
复制或配置管理器[]映射，

465
00:16:51,830 --> 00:16:53,930
0,240 240,330 330,1020 1020,1560 1560,2100
or the configuration manager []

466
00:16:53,930 --> 00:16:56,570
0,270 270,750 1110,1440 1440,2100 2190,2640
the mapping,| {} the actual
|对象可能更改的地址，

467
00:16:56,570 --> 00:16:57,680
0,240 240,390 390,450 450,930 930,1110
address where the object might

468
00:16:57,680 --> 00:16:59,210
0,660 900,1110 1110,1260 1260,1440 1440,1530
change,| {} so this is
|所以这是一个区域编号加上一个偏移量，

469
00:16:59,210 --> 00:17:00,170
0,90 90,390 390,660 660,870 870,960
a region number plus an

470
00:17:00,170 --> 00:17:00,960
0,570
offset,|
|

471
00:17:02,130 --> 00:17:03,210
0,90 90,360 360,480 480,780 780,1080
a little bit there here,
在这里，我应该设置偏移量。

472
00:17:03,210 --> 00:17:04,660
0,180 180,390 390,630 630,1020
I should set offset.|
|

473
00:17:09,920 --> 00:17:11,420
0,420 420,450 450,540 540,840 840,1500
Sorry, I have another question
抱歉，我也有一个问题，

474
00:17:12,320 --> 00:17:14,180
0,450 690,900 900,1410 1410,1710 1710,1860
that,| {} what was the
|创建全局地址空间背后的设计选择或设计思想是什么？

475
00:17:14,180 --> 00:17:16,010
0,510 510,900 900,1050 1050,1500 1500,1830
design choice or design thinking

476
00:17:16,010 --> 00:17:17,780
0,420 420,750 750,930 930,1440 1440,1770
behind making a global address

477
00:17:17,780 --> 00:17:18,600
0,630
space?|
|

478
00:17:19,280 --> 00:17:22,280
0,960 990,1260 1260,1950 1950,2580 2580,3000
{} The to have everything
把所有东西都放在内存中，

479
00:17:22,280 --> 00:17:23,580
0,240 240,510 510,930
in the DRAM,|
|

480
00:17:26,480 --> 00:17:27,620
0,390 390,600 600,780 780,990 990,1140
not sure that answers your
我不确定这是否回答了你的问题，但是，

481
00:17:27,620 --> 00:17:29,660
0,420 420,750 900,1710
question, but {},|
|

482
00:17:32,120 --> 00:17:33,380
0,180 180,750 750,840 840,1110 1110,1260
the {whole,goal} of them is
它们的全部目标是在内存数据库上运行事务，

483
00:17:33,380 --> 00:17:34,760
0,120 120,330 330,630 630,720 720,1380
to actually run the transactions

484
00:17:34,760 --> 00:17:36,350
0,180 180,300 300,810 810,1440 1470,1590
on an in-memory database,| you
|这是数据库的整体趋势，

485
00:17:36,350 --> 00:17:37,850
0,150 150,600 600,870 870,1200 1200,1500
know this whole trend of

486
00:17:37,850 --> 00:17:39,170
0,540 540,870 870,1020 1020,1110 1110,1320
{set,of,databases},| where all the data
|所有数据始终在内存中，称为内存数据库，

487
00:17:39,170 --> 00:17:40,100
0,90 90,360 360,420 420,870 870,930
is always in memory, is

488
00:17:40,100 --> 00:17:42,590
0,240 240,570 570,1020 1020,1380 1890,2490
called in-memory {databases -},| driven
|因为 DRAM 很便宜，

489
00:17:42,590 --> 00:17:44,000
0,150 150,240 240,540 540,900 930,1410
by the fact that DRAM

490
00:17:44,000 --> 00:17:45,920
0,90 90,450 450,930 1230,1770 1770,1920
is [reasonably] cheap,| and so
|这将允许你运行事务，

491
00:17:45,920 --> 00:17:46,970
0,240 240,450 450,780 780,930 930,1050
that would allow you to

492
00:17:46,970 --> 00:17:49,040
0,330 330,540 540,1260 1260,1800 1800,2070
basically run transactions| without actually
|不需要访问持久化存储，

493
00:17:49,040 --> 00:17:50,300
0,240 240,330 330,570 570,870 870,1260
having to go to persistent

494
00:17:50,300 --> 00:17:52,490
0,450 450,930 1110,1380 1380,1860 1860,2190
storage,| and they're basically jumping
|他们跳上了内存数据库。

495
00:17:52,490 --> 00:17:54,000
0,150 150,540 570,1380
on that {}

496
00:17:54,410 --> 00:17:55,400
0,690
[]

497
00:17:55,740 --> 00:17:57,360
0,240 240,690 690,1380
{} in-memory databases.|
|

498
00:17:58,310 --> 00:18:00,020
0,180 180,540 540,660 660,870 870,1710
I see, and that requires
我明白了，这需要它们共享一个全局地址空间。

499
00:18:00,020 --> 00:18:01,190
0,150 150,240 240,570 570,900 900,1170
like a global address space

500
00:18:01,190 --> 00:18:02,420
0,270 270,420 420,960
they all share.|
|

501
00:18:02,680 --> 00:18:04,000
0,210 210,450 450,660 660,1110 1110,1320
{} The address {space,is} per
地址空间是按机器的，

502
00:18:04,000 --> 00:18:06,820
0,510 540,990 990,1020 1020,2520 2550,2820
machine, {right -},| {} every
|每台机器都有自己的地址空间，从 0 到任何东西，

503
00:18:06,820 --> 00:18:07,750
0,240 240,390 390,480 480,630 630,930
machine has its own address

504
00:18:07,750 --> 00:18:09,130
0,240 240,360 360,720 720,810 810,1380
space from 0 to whatever,|
|

505
00:18:09,520 --> 00:18:13,900
0,1020 1020,1800 2010,2910 2940,3630 3900,4380
{} and the {} the
这些对象是全球编号或全局名称。

506
00:18:14,050 --> 00:18:15,880
0,480 600,870 870,1290 1290,1380 1380,1830
the the objects are really

507
00:18:15,880 --> 00:18:18,130
0,210 210,900 900,1350 1350,1800 1950,2250
the global {} numbers or

508
00:18:18,130 --> 00:18:19,080
0,300 300,840
global names.|
|

509
00:18:22,070 --> 00:18:23,080
0,240 240,750
Thank you.|
谢谢。|

510
00:18:26,450 --> 00:18:27,260
0,510
Okay,
好的，很好。

511
00:18:27,620 --> 00:18:29,690
0,390 720,900 900,1050 1050,1680 1710,2070
good.| So let's talk so
|那么我们谈到目前为止，

512
00:18:29,690 --> 00:18:31,790
0,540 660,930 930,1110 1110,1320 1320,2100
far,| {} I think we
|我认为我们已经建立了

513
00:18:31,820 --> 00:18:34,160
0,450 450,1350 1350,1470 1470,1740 1740,2340
basically {sort,of,established}| you know they've
|他们已经排除了稳定的存储设备，

514
00:18:34,160 --> 00:18:36,050
0,330 330,570 570,1020 1020,1410 1410,1890
gotten the stable storage devices

515
00:18:36,050 --> 00:18:37,670
0,150 150,210 210,300 300,690 1110,1620
out of the way,| and
|所以，读写存储设备不存在瓶颈，

516
00:18:37,670 --> 00:18:40,790
0,630 660,840 840,990 990,1710 2550,3120
so there's no bottleneck for

517
00:18:40,790 --> 00:18:42,290
0,390 390,660 660,960 960,1320 1320,1500
reading writing storage devices,| because
|因为他们没有使用它们，

518
00:18:42,290 --> 00:18:43,700
0,300 300,660 660,870 870,1140 1140,1410
they're basically not using them,|
|

519
00:18:43,970 --> 00:18:45,140
0,420 420,660 660,870 870,990 990,1170
other than this is one
一个例外的情况是电源故障。

520
00:18:45,140 --> 00:18:47,510
0,480 480,1050 1200,1530 1530,2010 2040,2370
exceptional case when the power

521
00:18:47,510 --> 00:18:48,080
0,480
fails.|
|

522
00:18:48,690 --> 00:18:50,100
0,180 180,570 690,960 960,1260 1260,1410
And so the next set
他们关注的下一组事情是是，

523
00:18:50,100 --> 00:18:51,420
0,90 90,390 390,510 510,900 900,1320
of things they focus on

524
00:18:51,540 --> 00:18:54,600
0,150 150,450 450,570 570,1260 1260,3060
is| trying to reduce {}
|试图降低 CPU 使用率

525
00:18:54,630 --> 00:18:56,460
0,750 750,1440 1440,1590 1590,1710 1710,1830
CPU utilization| or try to
|或者试图高效地使用 CPU

526
00:18:56,460 --> 00:18:57,240
0,90 90,240 240,600 600,690 690,780
be very efficient with the

527
00:18:57,240 --> 00:18:58,770
0,630 660,840 840,930 930,1140 1140,1530
CPU| and be very efficient
|并且在网络方面非常高效。

528
00:18:58,770 --> 00:19:00,200
0,90 90,180 180,660
at the network.|
|

529
00:19:00,830 --> 00:19:03,350
0,930 1290,1560 1560,2070 2070,2280 2280,2520
And there's two {} key
这里有两个关键的想法，

530
00:19:03,350 --> 00:19:05,330
0,390 390,960 960,1140 1140,1800 1800,1980
ideas here,| that {are,pretty} {}
|是众所周知的。

531
00:19:05,330 --> 00:19:07,190
0,300 300,630 1050,1290 1290,1620 1620,1860
well known.| So the first
|第一个是内核旁路，

532
00:19:07,190 --> 00:19:08,700
0,150 150,240 240,510 510,1320
one is kernel bypass,|
|

533
00:19:20,460 --> 00:19:23,220
0,420 420,960 1230,2010 2160,2580 2580,2760
{} and the story that
这个故事很简单，

534
00:19:23,220 --> 00:19:25,290
0,240 240,450 570,1080 1080,1680 1800,2070
is {} reasonable simple,| so
|我们 FaRM 作为用户进程运行，

535
00:19:25,290 --> 00:19:26,490
0,150 150,330 330,900 900,1110 1110,1200
we have {FaRM,that} runs as

536
00:19:26,490 --> 00:19:28,160
0,90 90,360 360,630 630,1410
a user level process,|
|

537
00:19:28,610 --> 00:19:29,620
0,720

538
00:19:31,880 --> 00:19:33,860
0,270 270,720 720,930 930,1680 1860,1980
on top of Windows, the
在 Windows 操作系统上面，

539
00:19:33,860 --> 00:19:35,330
0,300 300,660 660,1020 1020,1200 1200,1470
Windows operating system,| so here's
|这是操作系统，

540
00:19:35,330 --> 00:19:37,520
0,150 150,450 450,1020 1710,2100 2100,2190
the operating system,| {let's,move} {a,little,bit
|让我们往边上移一点，

541
00:19:37,520 --> 00:19:38,600
0,210 210,300 300,390 390,870 900,1080
-} on the side,| so
|所以这是操作系统，

542
00:19:38,600 --> 00:19:40,490
0,240 240,330 330,660 660,1260 1740,1890
here's the operating system,| and
|操作系统当然，

543
00:19:40,490 --> 00:19:41,510
0,60 60,360 360,690 690,750 750,1020
the operating system of course|
|

544
00:19:41,510 --> 00:19:42,350
0,180 180,330 330,450 450,630 630,840
and there are all the
有所有的功能，进程调度，虚拟内存，

545
00:19:42,350 --> 00:19:44,570
0,360 360,750 750,1230 1230,2040 2040,2220
features for scheduling processes {you,know}

546
00:19:44,570 --> 00:19:47,780
0,300 300,990 1200,1890 1920,2700 2700,3210
virtual memory,| standard operating system,|
|标准的操作系统，|

547
00:19:48,050 --> 00:19:50,420
0,690 690,930 930,1500 1500,1830 1830,2370
and {it,also} {have,drivers} for hardware
它也有硬件设备的驱动程序，

548
00:19:50,420 --> 00:19:53,330
0,0 990,1770 1950,2580 2580,2730 2730,2910
{} devices,| and like one
|并且其中一个硬件设备是网卡，

549
00:19:53,330 --> 00:19:55,100
0,90 90,150 150,450 450,1140 1140,1770
of the hardware devices is

550
00:19:55,310 --> 00:19:56,760
0,150 150,450 450,810 810,1230
a network interface card,|
|

551
00:20:00,560 --> 00:20:01,790
0,420 420,540 540,630 630,1140 1140,1230
and you know typically you
通常操作系统驱动程序在里面，

552
00:20:01,790 --> 00:20:04,220
0,240 240,600 630,1140 1140,1890 1920,2430
know the OS driver inside

553
00:20:04,220 --> 00:20:04,940
0,90 90,330
of it,|
|

554
00:20:05,140 --> 00:20:07,680
0,630 1290,1980
that {
对那个网卡编程，

555
00:20:07,900 --> 00:20:09,610
0,240 240,990 990,1080 1080,1350 1350,1710
-} programs the network interface

556
00:20:09,610 --> 00:20:11,650
0,330 330,540 540,900 900,1740 1740,2040
card,| so {read,and,write} registers on
|所以读写网卡上的寄存器发送包，

557
00:20:11,650 --> 00:20:12,820
0,210 210,450 450,780 780,1110 1110,1170
the network interface card to

558
00:20:12,820 --> 00:20:15,130
0,330 330,630 630,1080 1080,1590 1950,2310
basically send a packet| or
|或者重新配置网卡，等等。

559
00:20:15,130 --> 00:20:16,810
0,270 270,750 750,840 840,1140 1140,1680
to reconfigure the network interface

560
00:20:16,900 --> 00:20:18,180
0,330 330,660 660,1020
card, etc, etc.|
|

561
00:20:18,870 --> 00:20:20,640
0,480 750,960 960,1050 1050,1380 1380,1770
{} So the typical way
应用程序与网卡交互的通常方式是，

562
00:20:20,640 --> 00:20:22,410
0,120 120,270 270,600 600,1170 1170,1770
you know that {you,know} applications

563
00:20:22,410 --> 00:20:25,080
0,750 750,930 930,1440 1470,2010 2250,2670
interact with network card is,|
|

564
00:20:25,080 --> 00:20:27,300
0,150 150,960 960,1590 1800,2010 2010,2220
they {make,system} calls to the
它们对内核进行系统调用，

565
00:20:27,300 --> 00:20:29,670
0,660 660,1200 1410,1950 1950,2010 2010,2370
kernel,| and ask the kernel
|要求内核发送一个包，

566
00:20:29,670 --> 00:20:30,840
0,90 90,450 450,660 660,690 690,1170
to basically send a packet,|
|

567
00:20:31,750 --> 00:20:34,300
0,540 600,1110 1110,2100 2100,2220 2220,2550
and {that,you,know} involves the operating
这涉及操作系统，

568
00:20:34,300 --> 00:20:36,130
0,510 510,630 630,900 900,1410 1410,1830
system,| {involves -} TCP stack,
|涉及到 TCP 栈，网络栈，

569
00:20:36,130 --> 00:20:37,810
0,90 90,420 420,960 1140,1380 1380,1680
the network stack,| {} and
|它往往相当昂贵，

570
00:20:37,810 --> 00:20:39,010
0,180 180,390 390,450 450,870 900,1200
it tends to be quite

571
00:20:39,010 --> 00:20:41,890
0,570 1110,1890 2100,2400 2400,2700 2700,2880
expensive,| and so they want
|所以他们想要避免这个开销，

572
00:20:41,890 --> 00:20:44,230
0,60 60,390 390,690 690,1740 2100,2340
to avoid this {} this

573
00:20:44,230 --> 00:20:45,700
0,510 510,690 690,1110 1110,1410 1410,1470
overhead,| {you,know} going entering the
|进入内核，运行 TCP 等，

574
00:20:45,700 --> 00:20:48,190
0,480 480,720 720,1380 1380,1980 2220,2490
kernel running TCP, etc,| and
|他们这样做的方式是一种被称为内核旁路的技术，

575
00:20:48,190 --> 00:20:49,180
0,120 120,450 450,630 630,750 750,990
the way they do that

576
00:20:49,180 --> 00:20:49,780
0,60 60,330 330,420 420,510 510,600
is something that is {}

577
00:20:49,780 --> 00:20:51,640
0,330 330,660 660,930 930,1560 1560,1860
technique called kernel bypass,| and
|网卡是网卡和操作系统之间的协作，

578
00:20:51,640 --> 00:20:53,050
0,120 120,270 300,930 930,1170 1170,1410
{ -} {network,card} {is,sort,of} {}

579
00:20:53,050 --> 00:20:54,880
0,690 690,990 990,1050 1050,1380 1380,1830
collaboration between the network card

580
00:20:55,240 --> 00:20:57,220
0,600 600,780 780,1140 1140,1530 1860,1980
and the operating system,| and
|它所做的是，

581
00:20:57,220 --> 00:20:58,630
0,270 270,390 390,480 480,1050 1200,1410
basically what it does {}

582
00:20:58,630 --> 00:20:59,830
0,300 300,480 480,540 540,1050 1050,1200
is,| that the queues that
|它对网卡的队列排序，

583
00:20:59,830 --> 00:21:01,810
0,90 90,420 420,810 810,1320 1740,1980
the network interface has,| here're
|这是一些队列，比如发送队列和接收队列，

584
00:21:01,810 --> 00:21:03,550
0,60 60,690 1020,1110 1110,1470 1470,1740
some queues, for example send

585
00:21:03,550 --> 00:21:04,810
0,240 240,330 330,420 420,780 780,1260
queue and {} receive queue,|
|

586
00:21:05,170 --> 00:21:06,850
0,480 480,810 810,870 870,1200 1200,1680
those queues are basically directly
这些队列直接映射或进入应用程序的地址空间，

587
00:21:06,850 --> 00:21:09,520
0,570 1140,1650 1650,1980 2040,2310 2310,2670
{mapped,or} into the address space

588
00:21:09,520 --> 00:21:11,040
0,360 360,750 780,1410
of the application,|
|

589
00:21:11,410 --> 00:21:13,120
0,570 600,720 720,1110 1110,1200 1200,1710
so the application can ask
所以，应用程序可以请求操作系统，

590
00:21:13,120 --> 00:21:14,770
0,60 60,420 420,750 750,1110 1110,1650
you know operating system,| please
|请取出网卡所有的一些队列，

591
00:21:14,770 --> 00:21:17,020
0,90 90,300 300,540 540,960 1230,2250
you know take some queues

592
00:21:17,020 --> 00:21:19,000
0,570 600,900 900,1440 1530,1710 1710,1980
{that,the} NIC has| and map
|并将它们映射到应用程序的地址空间中，

593
00:21:19,000 --> 00:21:20,080
0,150 150,360 360,510 510,810 810,1080
them into the address space

594
00:21:20,080 --> 00:21:21,610
0,60 60,180 180,750 1200,1380 1380,1530
of the application,| so you
|所以，你可以考虑这些队列，

595
00:21:21,610 --> 00:21:22,480
0,90 90,240 240,390 390,630 630,870
can just think about this

596
00:21:22,480 --> 00:21:24,400
0,120 120,930 930,1380 1380,1500 1500,1920
{sort,of} queue| basically is directly
|可以从用户级应用程序直接访问，

597
00:21:24,400 --> 00:21:25,440
0,840
accessible

598
00:21:25,780 --> 00:21:28,270
0,690 1140,1470 1470,1530 1530,1980 1980,2490
{} from the {user,level} application,|
|

599
00:21:28,270 --> 00:21:29,710
0,180 180,240 240,480 480,750 750,1440
so the user level application,
所以用户应用程序现在可以，

600
00:21:29,920 --> 00:21:31,510
0,210 210,330 330,690 690,1230 1230,1590
{you,know} can basically now| {read,and,write}
|读写命令或包到网卡，

601
00:21:31,510 --> 00:21:33,820
0,180 180,900 960,1380 1380,1740 1740,2310
{you,know} commands or packets into

602
00:21:33,820 --> 00:21:35,680
0,150 150,420 420,840 840,1230 1290,1860
the network interface card,| {without
|而不需要涉及到操作系统。

603
00:21:35,680 --> 00:21:37,990
0,240 240,540 540,960 960,1590 1590,2310
-} actually having to involve

604
00:21:37,990 --> 00:21:39,100
0,90 90,420 420,720 720,810 810,1110
the operating system at all.|
|

605
00:21:39,310 --> 00:21:40,270
0,210 210,390 390,720 720,780 780,960
So this cuts the whole
所以这把整个操作系统都排除在外了，

606
00:21:40,270 --> 00:21:41,140
0,300 300,600 600,720 720,780 780,870
operating system out of the

607
00:21:41,140 --> 00:21:43,990
0,600 780,1410 1410,2100 2100,2670 2670,2850
picture| and {} improves {you,know}
|大大提高了性能。

608
00:21:43,990 --> 00:21:46,840
0,660 750,1320 2190,2580 2580,2640 2640,2850
performance considerably.| In the case
|在 FaRM 的情况下，

609
00:21:46,840 --> 00:21:48,340
0,60 60,720 870,1170 1170,1320 1320,1500
of FaRM,| {} they also
|他们也不想使用中断，

610
00:21:48,340 --> 00:21:49,390
0,120 120,240 240,300 300,480 480,1050
don't want to use interrupts,|
|

611
00:21:49,420 --> 00:21:50,710
0,120 120,480 480,750 750,900 900,1290
so one way of delivering
一种传递包的方式是，

612
00:21:50,710 --> 00:21:52,060
0,90 90,690 690,990 990,1080 1080,1350
a {packet\,,correct} is| the packet
|当包进入的时候，

613
00:21:52,060 --> 00:21:53,140
0,210 210,330 330,420 420,720 720,1080
comes in,| the network interface
|网卡向操作系统发送中断，

614
00:21:53,140 --> 00:21:54,640
0,330 330,660 660,750 750,1440 1440,1500
card delivers an interrupt to

615
00:21:54,640 --> 00:21:55,930
0,90 90,450 450,870 870,960 960,1290
the operating system,| the operating
|然后操作系统告诉应用包已经到达，

616
00:21:55,930 --> 00:21:57,610
0,360 360,510 510,990 990,1080 1080,1680
system then alerts the application

617
00:21:57,610 --> 00:21:58,980
0,300 720,1290
that {}

618
00:21:59,500 --> 00:22:01,300
0,90 90,360 360,480 480,1020 1260,1800
the packet has arrived,| and
|试图避免这一成本，

619
00:22:01,300 --> 00:22:03,160
0,1140 1140,1350 1350,1410 1410,1680 1680,1860
[] trying to avoid that

620
00:22:03,160 --> 00:22:04,030
0,390 390,510 510,570 570,750 750,870
cost,| and the way they
|避免这一成本的方法是

621
00:22:04,030 --> 00:22:05,380
0,330 330,480 480,750 750,840 840,1350
avoid that cost is| basically
|他们轮询接收队列。

622
00:22:05,500 --> 00:22:07,160
0,180 180,900
they poll

623
00:22:07,830 --> 00:22:09,080
0,480 480,900
{the,receive} queue.|
|

624
00:22:09,840 --> 00:22:12,150
0,360 390,630 630,1080 1080,1830 1830,2310
So there's basically {an,user,level} thread,|
所以有一个用户级别的线程，|

625
00:22:12,180 --> 00:22:14,070
0,150 150,300 300,1200 1200,1350 1350,1890
you know {that,sits} in the
它位于 FaRM 应用程序中，

626
00:22:14,100 --> 00:22:16,620
0,600 630,1590 1800,1980 1980,2340 2340,2520
FaRM application,| and basically does
|除了读取接收队列之外，什么也不做，

627
00:22:16,620 --> 00:22:18,930
0,240 240,660 660,750 900,1620 1770,2310
nothing else than {sort,of,reading} {}

628
00:22:18,930 --> 00:22:20,520
0,540 570,1170 1170,1290 1290,1440 1440,1590
the {receive,queue},| to see if
|查看包是否可用。

629
00:22:20,520 --> 00:22:22,000
0,300 300,720 720,1260
actually {packet,is} available.|
|

630
00:22:23,520 --> 00:22:25,050
0,210 210,420 420,990 990,1440 1440,1530
And so that requires you
所以这需要一个[]，

631
00:22:25,050 --> 00:22:26,340
0,330 330,450 450,690 690,720 720,1290
know you need a [],|
|

632
00:22:26,340 --> 00:22:27,510
0,120 120,330 330,780 780,870 870,1170
so that avoids the use
这就避免了中断的使用，

633
00:22:27,510 --> 00:22:30,780
0,270 360,1020 1290,2010 2010,2700 2880,3270
of interrupts,| {} and {}
|有一个轮询线程的代价，

634
00:22:30,780 --> 00:22:31,560
0,90 90,180 180,330 330,390 390,780
you know and the cost

635
00:22:31,560 --> 00:22:33,270
0,120 120,480 480,750 750,1380 1380,1710
of basically having {a,polling} {}

636
00:22:33,270 --> 00:22:35,100
0,330 330,1500 1500,1620 1620,1770 1770,1830
thread,| {that's -} you know
|在那里，除了轮询什么也不做，

637
00:22:35,100 --> 00:22:36,180
0,240 240,390 390,630 630,870 870,1080
sits there doing nothing else

638
00:22:36,180 --> 00:22:38,580
0,120 120,480 1230,1620 1680,2220 2220,2400
than polling,| and FaRM turns
|FaRM 这个线程来回切换，

639
00:22:38,580 --> 00:22:40,800
0,240 240,1020 1020,1440 1470,1860 1860,2220
out {this,thread} actually {} switches

640
00:22:40,800 --> 00:22:41,850
0,180 180,270 270,510 510,840 840,1050
back and forth| between running
|在运行应用程序代码和轮询网卡之间。

641
00:22:41,850 --> 00:22:43,770
0,120 120,630 630,1110 1110,1500 1710,1920
some application code and {}

642
00:22:43,770 --> 00:22:45,400
0,630 630,990 1050,1500
polling the NIC.|
|

643
00:22:46,640 --> 00:22:47,630
0,210 210,420 420,570 570,690 690,990
So that's sort of kernel
所以这是内核旁路，

644
00:22:47,630 --> 00:22:50,330
0,810 1260,1860 1860,2220 2220,2640 2640,2700
bypass,| {} and this is
|这是一个[合理的标准]，

645
00:22:50,330 --> 00:22:52,250
0,30 30,330 330,870 870,1500 1740,1920
a reasonable standard,| {} some
|你们中的一些人可能熟悉 DPDK ，

646
00:22:52,250 --> 00:22:53,480
0,240 240,840 870,1050 1050,1140 1140,1230
people may, some of you

647
00:22:53,480 --> 00:22:55,250
0,300 300,720 720,1080 1080,1380 1380,1770
maybe know familiar with {}

648
00:22:55,640 --> 00:22:57,500
0,990 1020,1620
{DPDK -

649
00:22:58,700 --> 00:23:00,200
0,960
-},|
|

650
00:23:01,570 --> 00:23:03,010
0,240 240,360 360,540 540,840 840,1440
which is {} data plane
它是数据平面开发工具包，

651
00:23:03,010 --> 00:23:05,170
0,270 270,690 690,1020 1410,1830 1830,2160
{} development kit,| {} which
|是一个可以利用内核旁路的开发工具包。

652
00:23:05,170 --> 00:23:08,260
0,690 690,1200 1200,1440 1440,2100 2190,3090
a development kit to basically

653
00:23:08,260 --> 00:23:10,120
0,540 540,690 690,960 960,1680
leverage {you,know} kernel bypass.|
|

654
00:23:10,710 --> 00:23:12,360
0,210 210,480 480,780 780,1320
It's a reasonable {standard,thing},|
这是一个合理的标准，|

655
00:23:12,950 --> 00:23:14,930
0,390 390,870 870,1290 1290,1680 1680,1980
{} is available on many
在许多操作系统上都可以使用。

656
00:23:14,930 --> 00:23:16,060
0,330 330,900
operating systems.|
|

657
00:23:16,720 --> 00:23:18,190
0,480 600,780 780,900 900,990 990,1470
{} So then the next
下一个他们使用的技术，

658
00:23:18,190 --> 00:23:18,880
0,90 90,300 300,450 450,510 510,690
you know sort of piece

659
00:23:18,880 --> 00:23:21,010
0,90 90,660 660,810 810,1320 1320,2130
of technology they use,| {is,a}
|有一点，但也是众所周知，广泛和标准化的，

660
00:23:21,040 --> 00:23:22,900
0,330 330,570 570,1170 1170,1500 1500,1860
little bit but also well

661
00:23:22,900 --> 00:23:24,520
0,210 210,300 300,540 540,660 660,1620
known as wide and standardized,|
|

662
00:23:24,520 --> 00:23:27,670
0,210 210,750 750,1230 1680,2340 2370,3150
many {network,cards} {} supported| or
许多网卡支持，|或者更高端的网卡支持，

663
00:23:27,670 --> 00:23:29,380
0,90 90,390 390,960 960,1260 1260,1710
{} more high-end network card

664
00:23:29,380 --> 00:23:30,880
0,570 870,1050 1050,1230 1230,1440 1440,1500
supported,| and that's {something -}
|这就是所谓的 RDMA ，

665
00:23:30,880 --> 00:23:32,180
0,90 90,450 450,1110
was called RDMA,|
|

666
00:23:36,210 --> 00:23:37,860
0,240 240,510 510,690 690,1380
which stands for remote,
它表示远程直接内存访问。

667
00:23:40,340 --> 00:23:44,700
0,840 840,1110 1110,1410 1410,1920
remote direct memory access.|
|

668
00:23:51,030 --> 00:23:51,960
0,90 90,330 330,600 600,690 690,930
The basic idea is that,|
基本的想法是，|

669
00:23:51,990 --> 00:23:53,970
0,600 870,990 990,1080 1080,1230 1230,1980
{} you know this requires
这需要网卡理解 RDMA ，

670
00:23:54,000 --> 00:23:56,640
0,750 750,930 930,1140 1140,1770 1770,2640
NICs that actually understand {}

671
00:23:56,730 --> 00:23:59,670
0,1050 1200,1620 1620,1890 2010,2790 2790,2940
RDMA,| and so here {we,have}
|这里有电缆，

672
00:23:59,670 --> 00:24:01,320
0,630 660,960 960,1080 1080,1380 1380,1650
cable,| here we have NIC
|另一边有网卡，

673
00:24:01,320 --> 00:24:02,940
0,90 90,180 180,360 360,900 1470,1620
on the other side,| the
|操作系统可能在它的上面，

674
00:24:02,940 --> 00:24:04,290
0,390 390,750 750,900 900,1080 1080,1350
operating system may be sitting

675
00:24:04,290 --> 00:24:05,670
0,60 60,360 360,480 480,720 1260,1380
on top of it,| you
|这里我们有 FaRM ，

676
00:24:05,670 --> 00:24:06,600
0,150 150,390 390,540 540,720 720,930
know {where -} we have

677
00:24:06,600 --> 00:24:07,600
0,690
FaRM,|
|

678
00:24:12,850 --> 00:24:16,210
0,660 840,1740 2070,3120 3120,3210 3210,3360
and {} basically you know
应用程序在旁边，

679
00:24:16,210 --> 00:24:18,520
0,660 990,1710 1710,1890 1890,1980 1980,2310
the application on the side,

680
00:24:18,520 --> 00:24:19,810
0,90 90,150 150,420 420,840 1080,1290
on the center side,| {you,know}
|可以把特定的包放入发送队列，

681
00:24:19,810 --> 00:24:21,370
0,120 120,510 510,900 900,1200 1200,1560
can basically put {} particular

682
00:24:21,370 --> 00:24:24,010
0,420 420,1080 1080,1830 1860,2220 2220,2640
packet into the send queue,|
|

683
00:24:24,280 --> 00:24:26,110
0,720 720,1260 1260,1380 1380,1470 1470,1830
{} and you know send
发送 RDMA 包，

684
00:24:26,110 --> 00:24:28,900
0,630 630,1410 1410,2040 2430,2580 2580,2790
{} RDMA packet,| and so
|在数据包的头部有一位，

685
00:24:28,900 --> 00:24:31,150
0,360 360,840 840,1110 1110,1950 2040,2250
basically somewhere is {a,bit} {}

686
00:24:31,150 --> 00:24:32,260
0,120 120,540 540,690 690,750 750,1110
the header of the packet,|
|

687
00:24:32,260 --> 00:24:33,220
0,270 270,450 450,690 690,900 900,960
saying, like hey I'm an
表示，我是个 RDMA 包，

688
00:24:33,220 --> 00:24:34,540
0,300 300,540 540,930
{RDMA -} packet,|
|

689
00:24:34,780 --> 00:24:36,250
0,480 480,750 750,1080 1080,1230 1230,1470
{} and then the NIC
然后网卡会将其发送到目标网卡，

690
00:24:36,250 --> 00:24:37,030
0,120 120,330 330,420 420,660 660,780
will send it over to

691
00:24:37,030 --> 00:24:39,130
0,570 600,1020 1050,1260 1260,1770 1770,2100
the NIC, the destination NIC,|
|

692
00:24:39,400 --> 00:24:41,020
0,180 180,690 690,1290 1290,1440 1440,1620
the destination {NIC,sees} that this
目标网卡看出这是一个特殊的包，一个 RDMA 包，

693
00:24:41,020 --> 00:24:42,580
0,450 480,780 780,1140 1140,1440 1440,1560
is a special packet, an

694
00:24:42,580 --> 00:24:44,470
0,510 510,930 1290,1500 1500,1800 1800,1890
RDMA packet,| and looks at
|并查看与 RDMA 包一起的指令，

695
00:24:44,470 --> 00:24:46,570
0,90 90,720 720,1140 1140,1350 1350,2100
the instruction that goes along

696
00:24:46,570 --> 00:24:48,010
0,150 150,240 240,690 690,1020 1350,1440
with the RDMA packet,| so
|这个指令可能是，

697
00:24:48,010 --> 00:24:50,080
0,540 540,750 750,1020 1230,1890 1920,2070
{the,instruction} might be| read a
|读取特定内存位置或写入特定内存位置，

698
00:24:50,080 --> 00:24:51,460
0,330 330,600 600,1020 1020,1140 1140,1380
particular memory location or write

699
00:24:51,460 --> 00:24:53,530
0,60 60,420 420,660 660,1170 1710,2070
a particular memory location,| so
|举个例子，

700
00:24:53,530 --> 00:24:54,760
0,510 510,660 660,780 780,1080 1080,1230
here so for example,| let's
|假设这是一个读操作，

701
00:24:54,760 --> 00:24:56,110
0,150 150,330 330,420 420,630 630,1350
say it's a read operation,|
|

702
00:24:56,910 --> 00:24:58,920
0,690

703
00:24:59,390 --> 00:25:00,380
0,240 240,300 300,510 510,900 900,990
and the read operation will
读取操作将安全地获取地址，

704
00:25:00,380 --> 00:25:02,300
0,90 90,480 480,810 810,1140 1140,1920
be safely takes an address,|
|

705
00:25:03,670 --> 00:25:05,500
0,750 900,1110 1110,1260 1260,1740 1740,1830
and {} it allows the
并且它允许网卡，

706
00:25:05,500 --> 00:25:07,300
0,450 570,780 780,1200 1200,1710 1710,1800
NIC| to basically read the
|直接从内存中读取地址，

707
00:25:07,300 --> 00:25:09,700
0,570 570,900 900,1230 1230,1470 1470,2400
address straight out of {}

708
00:25:09,790 --> 00:25:11,320
0,540 540,690 690,780 780,1140 1320,1530
memory, out of RAM,| so
|假设这里有我们的区域，

709
00:25:11,320 --> 00:25:12,730
0,390 390,570 570,990 1020,1080 1110,1410
{for,example} let's say you know

710
00:25:12,730 --> 00:25:14,140
0,390 390,510 510,690 690,870 870,1410
here we have our region,|
|

711
00:25:15,690 --> 00:25:16,680
0,210 210,330 330,480 480,870 870,990
you know with objects in
里面有对象，

712
00:25:16,680 --> 00:25:17,300
0,360
it,|
|

713
00:25:18,120 --> 00:25:21,100
0,750 780,1800 1830,2550
and {} the
发送 FaRM 应用程序可以说，

714
00:25:21,300 --> 00:25:24,660
0,750 750,1170 1500,2130 2160,2760 2760,3360
sending {} {FaRM -} application

715
00:25:24,660 --> 00:25:25,830
0,120 120,270 270,660 720,1050 1050,1170
can just say,| okay, I
|好的，我想读取这个特定地址，

716
00:25:25,830 --> 00:25:28,770
0,330 330,810 840,930 930,2130 2280,2940
wanna read you know {}

717
00:25:28,950 --> 00:25:30,330
0,270 270,810 810,1230 1230,1290 1290,1380
this particular address,| you know
|对应于这个对象 o 的地址，

718
00:25:30,330 --> 00:25:31,950
0,330 360,870 870,1380 1380,1440 1440,1620
which {} corresponds to {}

719
00:25:31,950 --> 00:25:33,690
0,300 330,690 690,930 930,1290 1290,1740
{} address {with,this} object o,|
|

720
00:25:34,020 --> 00:25:35,940
0,630 630,1020 1020,1230 1230,1740 1740,1920
and {} will send an
将向另一端的网卡发送 RDMA 数据包，

721
00:25:35,940 --> 00:25:37,350
0,510 510,900 900,1110 1110,1200 1200,1410
RDMA packet to the NIC

722
00:25:37,350 --> 00:25:38,440
0,90 90,180 180,390 390,840
on the other side,|
|

723
00:25:39,830 --> 00:25:40,610
0,150 150,450 450,570 570,690 690,780
the NIC is that there
网卡是有一个 RDMA 数据包，

724
00:25:40,610 --> 00:25:43,010
0,180 180,240 240,630 630,1140 1560,2400
{is,an -} RDMA packet,| and
|从内存中读取，

725
00:25:43,310 --> 00:25:45,290
0,630 630,1230 1260,1350 1350,1590 1590,1980
basically read you know from

726
00:25:45,290 --> 00:25:47,330
0,630 810,1110 1110,1530 1530,1980 1980,2040
memory,| the value stored at
|存储在特定位置的值，

727
00:25:47,330 --> 00:25:49,370
0,150 150,600 600,1320 1560,1740 1740,2040
that particular location,| and sends
|然后直接把它们送回源头。

728
00:25:49,370 --> 00:25:50,720
0,150 150,480 480,990 1080,1200 1200,1350
them straight back you know

729
00:25:50,720 --> 00:25:53,460
0,450 450,870 1260,1800 1860,2490
to the {} source.|
|

730
00:25:54,260 --> 00:25:55,550
0,480 480,690 690,750 750,1080 1080,1290
And what is cool about
这项技术的酷的地方在于，

731
00:25:55,550 --> 00:25:58,160
0,180 180,1050 1200,1650 1650,2160 2250,2610
this technology is that, {}|
|

732
00:25:58,160 --> 00:25:59,180
0,180 180,330 330,480 480,660 660,1020
the NIC can do this|
网卡可以做这个，|

733
00:25:59,240 --> 00:26:02,510
0,450 450,960 990,1830 1830,2460 2460,3270
without actually interrupting or interfering
根本不需要中断或干扰服务器，

734
00:26:02,510 --> 00:26:04,010
0,300 300,600 600,1050 1050,1170 1170,1500
with the server at all,|
|

735
00:26:04,490 --> 00:26:05,360
0,300 300,450 450,690 690,780 780,870
{} it doesn't have to
它不需要产生中断，

736
00:26:05,360 --> 00:26:06,740
0,390 390,480 480,960 960,1230 1230,1380
generate an interrupt,| doesn't have
|不需要在处理器上运行任何代码，

737
00:26:06,740 --> 00:26:08,810
0,60 60,360 360,660 660,1290 1440,2070
to run any code on

738
00:26:08,810 --> 00:26:11,210
0,720 780,1200 1260,1680 1680,2310 2310,2400
the {} the processors,| that
|运行操作系统，应用程序，

739
00:26:11,210 --> 00:26:12,410
0,300 300,390 390,750 750,1110 1110,1200
run the operating system, the

740
00:26:12,410 --> 00:26:14,900
0,810 1020,1440 1440,1680 1710,2190 2190,2490
application,| instead {you,know} NICs has
|相反，网卡具有固件执行这些命令，

741
00:26:14,900 --> 00:26:16,910
0,450 450,810 900,1140 1140,1530 1530,2010
{firmware -} {} that runs

742
00:26:16,910 --> 00:26:19,220
0,450 450,690 690,1380 1560,1740 1740,2310
executes those instructions,| and loads
|加载存储在这些内存中的值，

743
00:26:19,220 --> 00:26:22,070
0,60 60,240 240,1350 1650,2520 2520,2850
you know the value stored

744
00:26:22,070 --> 00:26:24,110
0,210 210,720 720,1170 1170,1500 1500,2040
those memory,| request memory addresses
|请求内存地址直接进入响应包，

745
00:26:24,470 --> 00:26:26,270
0,480 480,930 930,1020 1020,1470 1470,1800
straight into a response packet|
|

746
00:26:26,270 --> 00:26:27,170
0,90 90,300 300,360 360,720 720,900
and sends {} response {packet
并发回数据包，

747
00:26:27,170 --> 00:26:28,520
0,90 90,510 750,1020 1020,1260 1260,1350
-} back,| and then of
|当然，在接收端，

748
00:26:28,520 --> 00:26:29,840
0,270 270,390 390,480 480,840 840,1320
course on the receiving side,|
|

749
00:26:30,200 --> 00:26:31,160
0,120 120,240 240,570 570,720 720,960
you know that will show
这将显示在接收队列中，

750
00:26:31,160 --> 00:26:32,450
0,150 150,330 330,390 390,780 780,1290
up in the receive queue,|
|

751
00:26:32,600 --> 00:26:33,800
0,390 390,570 570,960 960,1080 1080,1200
and so far, you know
到目前为止，在某个点上，

752
00:26:33,800 --> 00:26:34,970
0,90 90,270 270,660 660,750 750,1170
at some point,| you know
|持有接收队列，并看到 RDMA 的结果。

753
00:26:35,000 --> 00:26:36,290
0,420 420,690 690,930 930,1050 1050,1290
{hold,the} receive queue and see

754
00:26:36,290 --> 00:26:37,940
0,420 420,750 750,1200 1200,1350 1350,1650
actually the result of that

755
00:26:37,970 --> 00:26:39,000
0,780
RDMA.|
|

756
00:26:40,560 --> 00:26:41,480
0,510

757
00:26:41,820 --> 00:26:43,710
0,360 360,600 600,1350 1380,1740 1740,1890
This, this particular version that
我在这里描述的这个版本，

758
00:26:43,710 --> 00:26:45,210
0,60 60,210 210,750 750,1410 1410,1500
I am describing here,| the
|论文将其称为单边 RDMA ，

759
00:26:45,210 --> 00:26:46,410
0,330 330,690 690,810 810,930 930,1200
paper refers to as {one-sided

760
00:26:46,410 --> 00:26:47,460
0,510
-}

761
00:26:48,510 --> 00:26:50,700
0,210 210,300 300,420 420,960
{RDMA - - -},|
|

762
00:26:53,280 --> 00:26:54,360
0,120 120,240 240,540 540,990 990,1080
and that's typically refers to
这通常指的是读取操作。

763
00:26:54,360 --> 00:26:57,630
0,90 90,390 390,840 840,1740 2460,3270
the paper to { -}

764
00:26:57,990 --> 00:26:59,320
0,330 330,1110
read operations.|
|

765
00:27:00,480 --> 00:27:01,460
0,660

766
00:27:02,500 --> 00:27:04,660
0,690 1200,1500 1500,1620 1620,1920 1920,2160
Professor.| Yeah, go ahead.| Sorry
教授。|好的，继续。|抱歉，教授，

767
00:27:04,660 --> 00:27:06,760
0,630 660,1140 1410,1800 1800,1980 1980,2100
professor,| can {} can you
|你能重复一下，

768
00:27:06,760 --> 00:27:08,890
0,450 450,1110 1110,1320 1320,1470 1470,2130
repeat,| how how the polling
|客户端的网卡队列是如何工作的，

769
00:27:08,920 --> 00:27:11,230
0,300 300,810 930,1440 1740,1950 1950,2310
of the {} like NIC

770
00:27:11,230 --> 00:27:13,210
0,600 600,1410 1440,1650 1650,1740 1740,1980
queues works on the on

771
00:27:13,210 --> 00:27:15,460
0,60 60,600 660,1140 1230,1710 1980,2250
the client| or yeah like.|
|或者，是的。|

772
00:27:15,460 --> 00:27:16,160
0,540

773
00:27:16,380 --> 00:27:18,000
0,420 420,780 780,1170 1170,1350 1350,1620
There's almost nothing to it,|
这几乎没有什么，|

774
00:27:18,060 --> 00:27:22,080
0,780 810,1590 1830,2370 2400,3060 3540,4020
{} the the client {}
客户端只有一个读取特定内存位置的线程，

775
00:27:22,080 --> 00:27:23,610
0,390 390,660 660,750 750,1200 1200,1530
just has a thread that

776
00:27:23,610 --> 00:27:25,080
0,150 150,210 210,540 540,750 750,1470
reads a particular memory location,|
|

777
00:27:25,500 --> 00:27:27,630
0,900 900,1230 1230,1530 1530,1920 1920,2130
and {} which indicates whether
表示数据包是否已经到达，

778
00:27:27,630 --> 00:27:28,380
0,60 60,330 330,420 420,720 720,750
a packet has arrived or

779
00:27:28,380 --> 00:27:29,040
0,330
not,|
|

780
00:27:29,300 --> 00:27:31,100
0,570 570,870 870,960 960,1380 1380,1800
and when the NIC receives
当网卡接收到包，放入接收队列中，

781
00:27:31,100 --> 00:27:34,100
0,810 810,1140 1140,1980 2010,2520 2520,3000
packets, {sticks,in} the receive queue,|
|

782
00:27:34,340 --> 00:27:35,240
0,450 450,540 540,600 600,840 840,900
and as a side of
作为接收队列中设置的一侧，

783
00:27:35,240 --> 00:27:36,740
0,270 270,540 540,840 840,1170 1170,1500
{} setting {in,the} receive queue,|
|

784
00:27:36,740 --> 00:27:38,870
0,90 90,270 270,720 780,1470 1530,2130
you know the flag bit
标志位变为 1 ，

785
00:27:38,870 --> 00:27:40,520
0,120 120,750 750,1050 1050,1170 1170,1650
you know turns into 1,|
|

786
00:27:40,760 --> 00:27:42,020
0,390 390,450 450,930 930,1140 1140,1260
and the application knows, oh
应用程序知道那里有一个包。

787
00:27:42,020 --> 00:27:43,520
0,720 720,960 960,990 990,1260 1260,1500
yeah there's a packet there.|
|

788
00:27:46,060 --> 00:27:47,500
0,270 270,480 480,780 780,870 870,1440
{} Is it a specific
是不是一个特殊的线程轮询？

789
00:27:47,500 --> 00:27:49,120
0,330 330,750 780,930 930,1320 1350,1620
thread that you know that

790
00:27:49,120 --> 00:27:51,310
0,330 330,630 660,1080 1260,1680 1680,2190
polls or like?| Yeah, they're
|是的，他们的系统里，有特定的线程，

791
00:27:51,310 --> 00:27:52,630
0,120 120,270 270,600 600,870 870,1320
in their system, they have

792
00:27:52,660 --> 00:27:54,070
0,390 390,690 690,840 840,1290 1290,1410
specific threads,| that actually are
|专门用于轮询队列。

793
00:27:54,070 --> 00:27:57,160
0,510 510,600 600,1170 1200,1920 2460,3090
dedicated to polling {} {the,queues}.|
|

794
00:27:58,220 --> 00:27:58,920
0,420
Okay,
好的，谢谢。

795
00:27:59,460 --> 00:28:00,300
0,450
thanks.|
|

796
00:28:01,540 --> 00:28:02,770
0,450 450,570 570,750 750,1080 1080,1230
Sorry, I'm also confused here,|
抱歉，这里我也比较疑惑，|

797
00:28:02,770 --> 00:28:04,420
0,210 210,840 840,1380 1380,1500 1500,1650
so {does,the,NIC} cooperate with this
那么，网卡是否与系统合作，正常工作，

798
00:28:04,420 --> 00:28:06,010
0,420 420,600 780,1290 1290,1470 1470,1590
system or regularly doing a

799
00:28:06,010 --> 00:28:07,660
0,390 510,720 720,1140 1140,1440 1440,1650
job,| like as in any
|就像普通的网卡一样。

800
00:28:07,660 --> 00:28:08,920
0,570 600,960
regular NIC.|
|

801
00:28:09,500 --> 00:28:12,260
0,840 1140,1890 1890,2190 2190,2310 2310,2760
{} Okay, this is not
好的，这不是普通网卡，

802
00:28:12,260 --> 00:28:13,280
0,90 90,210 210,510 510,660 660,1020
you know whatever your standard

803
00:28:13,280 --> 00:28:15,080
0,360 390,780 1080,1350 1350,1590 1590,1800
NIC, right,| {} this NIC
|这个网卡同时支持内核旁路和远程直接内存访问 RDMA ，

804
00:28:15,080 --> 00:28:17,060
0,120 120,600 600,930 930,1200 1200,1980
that supports both kernel bypass

805
00:28:17,420 --> 00:28:19,610
0,660 660,1080 1080,1440 1440,1740 1740,2190
and {} remote direct {memory,access}

806
00:28:19,700 --> 00:28:20,820
0,180 180,360 360,870
{} {RDMA -},|
|

807
00:28:21,230 --> 00:28:22,940
0,420 420,570 570,660 660,1140 1140,1710
{} in the, {} typically
通常，网卡为了支持内核旁路，

808
00:28:22,940 --> 00:28:25,550
0,240 240,450 450,570 570,1140 1140,2610
for NIC to support {}

809
00:28:26,120 --> 00:28:27,200
0,180 180,390 390,780 780,870 870,1080
{} kernel bypass,| it means
|这意味着它必须有多个接收和发送队列，

810
00:28:27,200 --> 00:28:28,610
0,120 120,300 300,360 360,540 540,1410
it has to have multiple

811
00:28:28,700 --> 00:28:30,620
0,510 510,720 720,1200 1440,1830 1830,1920
{receive,and} send queues,| and it
|它只向应用程序提供一对发送或接收队列，

812
00:28:30,620 --> 00:28:31,550
0,180 180,390 390,510 510,810 810,930
just gives a pair of

813
00:28:31,550 --> 00:28:32,660
0,330 330,660 660,930 930,1020 1020,1110
{send,or} receive queues to an

814
00:28:32,660 --> 00:28:33,580
0,630
application,|
|

815
00:28:34,980 --> 00:28:36,120
0,210 210,300 300,780 780,990 990,1140
and it cannot like,| of
它不能，|当然，

816
00:28:36,120 --> 00:28:37,950
0,390 390,570 570,810 810,1380 1650,1830
course,| you can't have a
|你不能让计算机上运行的每个进程都有一个发送接收队列，

817
00:28:37,950 --> 00:28:39,360
0,270 270,540 540,750 750,930 930,1410
send receive queue for every

818
00:28:39,360 --> 00:28:40,860
0,420 420,660 660,810 810,900 900,1500
process running on your machine,|
|

819
00:28:41,130 --> 00:28:42,540
0,300 300,690 690,870 870,1020 1020,1410
so typically they're like 16
所以它们通常是 16 个或者 32 个，

820
00:28:42,540 --> 00:28:43,470
0,90 90,360 360,660 660,840 840,930
of them, {or,32 -} of

821
00:28:43,470 --> 00:28:45,330
0,420 690,1230 1230,1350 1350,1560 1560,1860
them,| and {you,know} get some
|把其中的一些放到特定的操作系统上，

822
00:28:45,330 --> 00:28:46,800
0,90 90,600 600,750 750,1140 1140,1470
of them to particular {OS

823
00:28:46,800 --> 00:28:48,780
0,360 360,810 810,1080 1080,1350 1350,1980
-},| basically allow some applications
|允许一些应用程序拥有发送接收队列。

824
00:28:48,780 --> 00:28:51,060
0,120 120,510 510,1140 1380,2040 2040,2280
to own basically {} send

825
00:28:51,060 --> 00:28:51,900
0,60 60,360 360,630
and receive queue.|
|

826
00:28:52,880 --> 00:28:54,100
0,570 570,660 660,930
Thanks so much.|
非常感谢。|

827
00:28:55,060 --> 00:28:56,050
0,270 270,480 480,690 690,930 930,990
It also means there's a
这也意味着有对 RDMA 的支持，并使它正常工作，

828
00:28:56,050 --> 00:28:58,090
0,510 510,930 930,1170 1170,1710 1710,2040
specific support for RDMA and

829
00:28:58,090 --> 00:28:59,170
0,240 240,330 330,570 570,810 810,1080
make it all work out,|
|

830
00:29:00,050 --> 00:29:01,490
0,390 390,510 510,750 960,1140 1140,1440
{} you know, so it
所以它需要一个相当复杂的网卡，

831
00:29:01,490 --> 00:29:02,390
0,330 330,420 420,600 600,750 750,900
requires {a,NIC -} that is

832
00:29:02,390 --> 00:29:04,190
0,540 540,840 840,1440 1440,1680 1680,1800
a reasonable sophisticated,| although it's
|尽管如今这是一个合理的标准。

833
00:29:04,190 --> 00:29:05,600
0,180 180,480 480,840 840,990 990,1410
a reasonable standard, these days.|
|

834
00:29:07,070 --> 00:29:08,510
0,390 420,570 570,840 840,1170 1170,1440
Okay, so that's one side
好的，这是 RDMA 的一个方面，

835
00:29:08,510 --> 00:29:10,580
0,150 180,810 810,1500 1500,1740 1740,2070
of {} RDMA,| they also
|它们还使用 RDMA 进行写入，

836
00:29:10,580 --> 00:29:13,610
0,420 420,1230 1260,1500 1500,2370 2370,3030
use RDMA {} {to,do} writes,|
|

837
00:29:13,880 --> 00:29:15,440
0,660 660,750 750,1020 1020,1410 1410,1560
and to actually implement {RPC
真正实现 RPC ，

838
00:29:15,440 --> 00:29:18,050
0,600 840,1530 1710,1980 1980,2400 2400,2610
-},| {} and so, {}
|他们在论文中把这个称为 写 RDMA ，

839
00:29:18,050 --> 00:29:18,840
0,240 240,570
there's, {}

840
00:29:19,150 --> 00:29:21,130
0,630 840,1380 1380,1650 1650,1800 1800,1980
{} they typically call this

841
00:29:21,130 --> 00:29:23,470
0,480 480,1050 1410,1650 1650,1740 1740,2340
write RDMA in the paper,|
|

842
00:29:24,520 --> 00:29:25,930
0,180 180,570 570,660 660,930 930,1410
is basically the same thing,|
基本上是相同的事情，|

843
00:29:27,970 --> 00:29:29,980
0,750 750,810 810,1500 1500,1830 1830,2010
except the sender could put
除了发送方可以放入 RDMA 包，

844
00:29:29,980 --> 00:29:32,500
0,180 180,870 900,1470 1470,2010 2040,2520
in the RDMA packet, {}|
|

845
00:29:32,500 --> 00:29:33,340
0,270 270,450 450,600 600,750 750,840
saying like oh this is
说这是一个写操作，

846
00:29:33,340 --> 00:29:34,930
0,120 120,360 360,1050 1050,1290 1290,1590
a write operation,| and write
|将以下字节写入特定地址，

847
00:29:34,930 --> 00:29:36,190
0,90 90,480 540,720 720,960 960,1260
you know {} the following

848
00:29:36,190 --> 00:29:38,020
0,540 660,870 870,930 930,1260 1260,1830
bytes to a particular address,|
|

849
00:29:38,290 --> 00:29:41,620
0,750 870,1710 1830,2310 2310,2670 2670,3330
and the paper uses two
这篇论文使用了两个地方或两个东西，

850
00:29:41,650 --> 00:29:43,210
0,480 480,570 570,750 750,1080 1080,1560
places or two things,| where
|这些地方用到了写入，

851
00:29:43,210 --> 00:29:44,530
0,240 240,420 420,660 660,930 930,1320
writes are actually going to,|
|

852
00:29:44,770 --> 00:29:47,740
0,630 720,1740 1740,2130 2130,2610 2610,2970
{} [] written directly with
直接用 RDMA 写入，

853
00:29:47,740 --> 00:29:49,750
0,840 960,1170 1170,1380 1380,1530 1530,2010
RDMA,| but there's two other
|但还有另外两个数据结构使用 写RDMA 写入，

854
00:29:49,780 --> 00:29:51,010
0,240 240,630 630,780 780,990 990,1230
data structures that are being

855
00:29:51,010 --> 00:29:52,780
0,330 330,690 690,990 1020,1290 1290,1770
written with {} write {RDMAs

856
00:29:52,780 --> 00:29:54,220
0,180 210,630 630,810 810,900 900,1440
-},| one is a log,|
|一个是日志，|

857
00:29:56,200 --> 00:29:57,310
0,240 240,510 510,660 660,990 990,1110
you'll see the [rule] the
稍后你会看到日志的规则，

858
00:29:57,310 --> 00:29:58,980
0,270 270,750 780,1290
log later, {}|
|

859
00:30:00,440 --> 00:30:01,340
0,270 270,420 420,540 540,660 660,900
{} and this is a
这是一个事务，

860
00:30:01,340 --> 00:30:02,690
0,210 210,510 510,1080 1080,1230 1230,1350
really [] transactions,| so it
|所以它有提交记录，日志记录，等等，

861
00:30:02,690 --> 00:30:04,910
0,180 180,480 480,990 1110,1590 1590,2220
has committed record, logging records,

862
00:30:04,940 --> 00:30:07,370
0,720 720,1500 1710,1920 1920,2070 2070,2430
etc etc,| and so if
|所以，如果源头将日志记录附加到这个日志，

863
00:30:07,370 --> 00:30:08,630
0,120 120,660 660,840 840,1080 1080,1260
the source {you,know} once {append

864
00:30:08,630 --> 00:30:10,970
0,330 330,750 750,1200 1440,1710 1710,2340
-} {a,log} record {} to

865
00:30:10,970 --> 00:30:12,410
0,210 210,630 630,1110 1110,1260 1260,1440
this particular log,| I can
|我可以执行 写RDMA ，

866
00:30:12,410 --> 00:30:15,320
0,300 300,570 570,960 1200,2070 2280,2910
just do write RDMA,| and
|然后，接收网卡会

867
00:30:15,500 --> 00:30:17,600
0,810 810,1050 1050,1380 1380,1680 1680,2100
{} and then the receiving

868
00:30:17,600 --> 00:30:19,190
0,450 450,720 900,1350 1350,1440 1440,1590
{NIC,will}| {} add you know
|将日志中的新条目添加到指定位置。

869
00:30:19,190 --> 00:30:21,200
0,300 570,1350 1350,1800 1800,1920 1920,2010
the new entry in the

870
00:30:21,200 --> 00:30:23,870
0,420 420,930 930,1620 1800,2280 2280,2670
log to the specified location.|
|

871
00:30:24,970 --> 00:30:28,330
0,690 1710,2400 2730,2970 2970,3090 3090,3360
Okay?| And so that means
好的?|所以这意味着就像发送者，

872
00:30:28,330 --> 00:30:29,860
0,180 180,240 240,1020 1020,1290 1290,1530
like the sender,| and there's
|每个发送方和接收方对都有一个队列和一个日志，

873
00:30:29,860 --> 00:30:31,150
0,180 180,270 270,420 420,1110 1140,1290
one of these queues and

874
00:30:31,150 --> 00:30:32,710
0,150 150,240 240,420 420,870 870,1560
one of these logs per

875
00:30:32,740 --> 00:30:34,750
0,480 480,780 780,1170 1170,1710 1800,2010
{} sender receiver pair,| so
|所以发送者可以管理和知道

876
00:30:34,750 --> 00:30:36,100
0,180 180,330 330,840 840,960 960,1350
that sender actually can manage

877
00:30:36,100 --> 00:30:37,120
0,120 120,390 390,660 660,720 720,1020
and know| what the beginning
|日志开头和结尾是什么。

878
00:30:37,120 --> 00:30:37,690
0,150 150,210 210,360 360,480 480,570
and the end of the

879
00:30:37,690 --> 00:30:38,480
0,300 300,600
log are.|
|

880
00:30:40,020 --> 00:30:42,150
0,750 1080,1170 1200,1770 1770,1830 1830,2130
Then, in addition to that,|
然后，除此之外，|

881
00:30:42,150 --> 00:30:43,950
0,180 180,570 570,780 780,1170 1170,1800
there's something there message queues
有一些消息队列也是每对一个，

882
00:30:46,650 --> 00:30:49,590
0,570 570,1110 1110,1770 1770,2160 2190,2940
and also one per pair,|
|

883
00:30:51,340 --> 00:30:52,750
0,210 210,420 420,510 510,900 900,1410
and these are basically used
这些用于实现 RPC ，

884
00:30:52,750 --> 00:30:54,970
0,90 90,810 870,1170 1170,1380 1380,2220
to implement {} {RPCs -},|
|

885
00:30:55,270 --> 00:30:56,320
0,330 330,630 630,720 720,870 870,1050
{} so if you want
所以，如果你想要进行远程过程调用，

886
00:30:56,320 --> 00:30:57,940
0,150 150,390 390,690 690,1080 1080,1620
to do remote procedure call,|
|

887
00:30:58,090 --> 00:31:01,510
0,540 540,960 1140,1830 1860,2280 2310,3420
{} the client, the sender
客户端，发送方制作 写RDMA 包，

888
00:31:01,810 --> 00:31:03,850
0,570 570,720 720,960 960,1590 1590,2040
makes {} write RDMA RDMA

889
00:31:03,850 --> 00:31:05,530
0,480 780,1350 1350,1470 1470,1560 1560,1680
packet,| writes you know the
|将数据，消息写入远程消息队列，

890
00:31:05,530 --> 00:31:07,240
0,210 210,420 420,750 750,1260 1260,1710
data, the message basically into

891
00:31:07,240 --> 00:31:10,000
0,330 360,990 1020,1440 1440,1950 2340,2760
the remote message queue,| there's
|在目标一侧也有一个线程，

892
00:31:10,000 --> 00:31:13,060
0,390 510,1020 1020,1590 1590,2520 2520,3060
a thread sitting on the

893
00:31:13,150 --> 00:31:14,530
0,600 600,840 840,960 960,1050 1050,1380
destination side,| that is basically
|轮询消息队列或轮询所有消息队列，

894
00:31:14,530 --> 00:31:16,840
0,630 630,810 810,1140 1140,1470 1470,2310
polling that message queue or

895
00:31:16,870 --> 00:31:18,430
0,360 360,690 690,780 780,1050 1050,1560
polling all the message queues,|
|

896
00:31:18,760 --> 00:31:19,870
0,240 240,330 330,540 540,600 600,1110
if it sees a message,
如果它看到一条消息，它会处理消息，

897
00:31:19,870 --> 00:31:20,710
0,120 120,270 270,360 360,750 750,840
you know it processes the

898
00:31:20,710 --> 00:31:22,030
0,570 720,870 870,960 960,1110 1110,1320
message,| and can then send
|然后可以使用 写RDMA 发回响应，

899
00:31:22,030 --> 00:31:23,120
0,60 60,540 540,1020
a response back,

900
00:31:23,780 --> 00:31:26,700
0,720 780,1440 1440,2070
using {a,write} RDMA,|
|

901
00:31:32,530 --> 00:31:33,490
0,330 330,480 480,600 600,840 840,960
{} and this turns out
使用 RDMA 实现远程过程调用更[便宜]，

902
00:31:33,490 --> 00:31:36,640
0,60 60,630 870,1710 1800,2610 2610,3150
to be cheaper implementing {remote,procedure}

903
00:31:36,640 --> 00:31:38,530
0,360 360,630 630,1410 1560,1710 1710,1890
call using RDMA,| it turns
|它比使用某种标准 RPC 包更[便宜]，

904
00:31:38,530 --> 00:31:39,310
0,90 90,150 150,240 240,630 630,780
out to be cheaper than

905
00:31:39,310 --> 00:31:42,220
0,690 720,1710 1830,2220 2220,2430 2430,2910
basically {} using {sort,of} standard

906
00:31:42,220 --> 00:31:44,680
0,450 450,1110 1230,1800 1800,1920 1920,2460
RPC packet,| that you know
|数据包使用普通网卡，但没有 RDMA ，

907
00:31:44,680 --> 00:31:47,710
0,540 570,1170 1170,2040 2310,2790 2790,3030
{} since {} packet using

908
00:31:47,710 --> 00:31:49,240
0,60 60,360 360,750 750,1140 1140,1530
a regular NIC, but without

909
00:31:49,240 --> 00:31:50,800
0,90 90,690 930,1320 1320,1500 1500,1560
{RDMA -}| and has a
|在另一边有一个线程响应。

910
00:31:50,800 --> 00:31:51,850
0,240 240,300 300,390 390,600 600,1050
thread on the other side

911
00:31:51,850 --> 00:31:53,220
0,60 60,210 210,630 630,1290
you know that response.|
|

912
00:31:54,190 --> 00:31:55,160
0,630
Okay?|
好的?|

913
00:31:56,450 --> 00:31:58,040
0,180 180,330 330,540 540,1260 1260,1590
Is there any validation step
这里是否有任何验证步骤，

914
00:31:58,040 --> 00:31:59,060
0,210 210,270 270,510 510,690 690,1020
here,| to make sure that
|为了确保你只写入内存区域，

915
00:31:59,210 --> 00:32:01,010
0,390 390,630 630,870 870,1350 1350,1800
you're you're only writing to

916
00:32:01,010 --> 00:32:02,120
0,90 90,360 360,450 450,750 750,1110
a region of memory,| that's
|这是明确允许 RDMA 的，

917
00:32:02,210 --> 00:32:04,490
0,630 630,1290 1290,1440 1440,2040 2040,2280
expressly allowed for RDMA,| {you,know}
|不要写到应用程序内存或其他什么地方。

918
00:32:04,490 --> 00:32:06,920
0,540 660,1020 1050,1800 1800,1920 1920,2430
don't write application to application

919
00:32:06,920 --> 00:32:08,390
0,270 270,330 330,780 900,1290 1290,1470
memory or something.| Yeah, so
|是的，有各种各样的，

920
00:32:08,390 --> 00:32:09,380
0,150 150,510 510,630 630,840 840,990
there are all kinds of,|
|

921
00:32:09,380 --> 00:32:10,490
0,120 120,660 660,870 870,960 960,1110
you know this is sort
这是一种高层次的想法，

922
00:32:10,490 --> 00:32:12,080
0,60 60,150 150,600 600,1110 1140,1590
of the high-level idea, {}|
|

923
00:32:12,140 --> 00:32:14,420
0,210 210,390 390,840 840,1470 1950,2280
talk into details here,| so
在这里讨论详细信息，|所以，当你设置这些 RDMA 时，

924
00:32:14,420 --> 00:32:17,060
0,720 870,1680 1710,2010 2010,2250 2250,2640
when {} you sort of

925
00:32:17,060 --> 00:32:17,810
0,240 240,330 330,480 480,570 570,750
set up one of these

926
00:32:17,810 --> 00:32:21,500
0,90 90,780 780,2190 3270,3450 3450,3690
{RDMA -},| {} in order
|为了做这种单边 RDMA 或写入 RDMA ，

927
00:32:21,500 --> 00:32:22,670
0,60 60,240 240,450 450,660 660,1170
to do this {} one-sided

928
00:32:22,670 --> 00:32:24,230
0,450 450,570 570,900 900,1320 1320,1560
RDMA or write {RDMAs -},|
|

929
00:32:24,320 --> 00:32:25,130
0,300 300,420 420,630 630,720 720,810
{} you first have to
你首先必须进行连接设置，

930
00:32:25,130 --> 00:32:27,440
0,270 270,600 600,1050 1260,1500 1500,2310
do connection setup,| there's a
|在发送者和接收者之间有一个协商步骤来设置，

931
00:32:27,470 --> 00:32:29,900
0,900 900,1290 1290,1560 1560,2010 2040,2430
negotiation step between the sender

932
00:32:29,900 --> 00:32:31,280
0,120 120,180 180,840 1020,1200 1200,1380
and the receiver {} to

933
00:32:31,280 --> 00:32:33,020
0,240 240,450 450,990 1020,1560 1560,1740
{setup -},| {} basically like
|它就像一个 TCP 通道，

934
00:32:33,020 --> 00:32:33,980
0,180 180,390 390,480 480,540 540,960
it's almost like a TCP

935
00:32:33,980 --> 00:32:35,720
0,330 330,660 660,750 750,900 900,1740
channel,| except you know RDMA
|除了 RDMA 不使用 TCP ，

936
00:32:35,750 --> 00:32:37,760
0,540 540,1200 1320,1710 1710,1800 1800,2010
{doesn't,use} TCP,| but it sets
|但是它建立了面向连接的可靠、有序的通道，

937
00:32:37,760 --> 00:32:40,700
0,90 90,150 150,570 570,1320 1680,2940
up a connection oriented reliable,

938
00:32:41,060 --> 00:32:43,700
0,870 870,1530 1560,2100 2100,2580
{} ordered {} channel,|
|

939
00:32:46,080 --> 00:32:47,880
0,480 480,630 630,1080 1080,1500 1500,1800
and so the security checks
所以，安全检查和访问控制检查

940
00:32:47,880 --> 00:32:48,870
0,150 150,420 420,720 720,930 930,990
and access control checks| are
|是在设置时进行的。

941
00:32:48,870 --> 00:32:49,740
0,360 360,450 450,540 540,780 780,870
happening at the point of

942
00:32:49,740 --> 00:32:50,520
0,60 60,480
the setup.|
|

943
00:32:53,190 --> 00:32:54,030
0,360 360,510 510,630 630,750 750,840
So would you have to
那么，你需要在每一对机器之间执行这个操作吗？

944
00:32:54,030 --> 00:32:55,440
0,120 120,330 330,840 840,1140 1140,1410
do that between every pair

945
00:32:55,440 --> 00:32:57,040
0,90 90,840 840,1350
of machines?| Yes.|
|是的。|

946
00:32:58,600 --> 00:32:59,770
0,270 270,420 420,660 660,960 960,1170
So that would become really
所以这将变得非常昂贵的添加，

947
00:32:59,770 --> 00:33:01,540
0,540 540,660 660,1020 1050,1470 1500,1770
costly to add,| {} like
|比如一台机器对一个大集群，是吗？

948
00:33:01,540 --> 00:33:03,160
0,210 210,660 660,840 840,1260 1260,1620
one machine to a large

949
00:33:03,160 --> 00:33:05,350
0,450 450,840 1170,1890 1890,2070 2070,2190
cluster, right?| You have n
|你有 n 的平方个连接，

950
00:33:05,350 --> 00:33:07,300
0,510 510,1080 1080,1740
square RDMA connections,|
|

951
00:33:08,300 --> 00:33:09,140
0,150 150,540 540,600 600,720 720,840
and otherwise we would have
否则我们将有 n 的平方个 TCP 连接，

952
00:33:09,140 --> 00:33:10,780
0,120 120,450 450,780 780,1410
n square TCP connections,|
|

953
00:33:11,650 --> 00:33:13,960
0,1080 1200,1680 1680,1830 1830,1950 1950,2310
not clear as a major
不清楚是不是有很大的区别。

954
00:33:13,960 --> 00:33:14,920
0,330 330,630
difference there.|
|

955
00:33:18,040 --> 00:33:19,720
0,270 270,870 870,1080 1080,1200 1200,1680
And so just to clarify,|
为了确认一下，|

956
00:33:19,720 --> 00:33:21,220
0,480 600,1050 1050,1320 1320,1410 1410,1500
so the message in the
日志中的信息，

957
00:33:21,220 --> 00:33:23,170
0,480 480,900 900,1170 1170,1530 1530,1950
logs,| basically they both sit
|它们也在内存中，

958
00:33:23,170 --> 00:33:24,610
0,300 300,690 720,1170 1170,1260 1260,1440
also in memory,| they just
|它们只是在与对象不同的地方。

959
00:33:24,610 --> 00:33:26,260
0,210 210,330 330,600 600,1260 1290,1650
sit in different places than

960
00:33:26,260 --> 00:33:28,120
0,210 210,300 300,840 1170,1470 1470,1860
where the {objects,sit}.| Yeah, exactly,|
|是的，没错，|

961
00:33:28,180 --> 00:33:29,080
0,240 240,420 420,540 540,810 810,900
so if you do,| so
所以如果你这样做，|那么这就是右边的这个，

962
00:33:29,080 --> 00:33:29,980
0,180 180,240 240,480 480,660 660,900
this is sort of on

963
00:33:29,980 --> 00:33:31,330
0,210 210,300 300,390 390,780 1170,1350
here on the right,| is
|是 FaRM 进程的内存布局图片，

964
00:33:31,360 --> 00:33:32,350
0,180 180,510 510,570 570,660 660,990
a picture of the memory

965
00:33:32,350 --> 00:33:35,530
0,510 510,630 630,1200 1290,2190 2220,3180
layout of the FaRM process,|
|

966
00:33:35,530 --> 00:33:37,240
0,180 180,300 300,570 570,1320 1350,1710
you know there's a region
有一个区域表或一个对象表，

967
00:33:37,240 --> 00:33:39,100
0,600 780,900 900,960 960,1290 1290,1860
table or an object table,|
|

968
00:33:39,100 --> 00:33:40,780
0,210 600,810 810,900 900,1440 1440,1680
and there are regions in
在服务器的内存中有区域，

969
00:33:40,780 --> 00:33:42,850
0,120 120,600 600,750 750,1440 1470,2070
the memory of the server,|
|

970
00:33:43,090 --> 00:33:45,340
0,360 360,870 870,1230 1230,1740 1770,2250
{} these regions have objects
这些区域中有对象，

971
00:33:45,340 --> 00:33:46,720
0,120 120,480 750,900 900,1020 1020,1380
in them,| and in addition
|除了这些区域之外，

972
00:33:46,720 --> 00:33:48,160
0,180 180,420 420,870 870,1140 1140,1440
to the regions,| there are
|还有消息队列和日志。

973
00:33:48,160 --> 00:33:49,690
0,360 360,1020 1050,1230 1230,1410 1410,1530
message queues and there are

974
00:33:49,690 --> 00:33:50,360
0,600
logs.|
|

975
00:33:51,900 --> 00:33:53,670
0,180 180,540 660,1020 1020,1560 1560,1770
I see,| and also for
我明白了，|而且为了让网卡支持从内存直接访问，

976
00:33:53,670 --> 00:33:54,900
0,90 90,360 360,510 510,1020 1020,1230
the NIC to support the

977
00:33:54,900 --> 00:33:56,640
0,360 360,720 720,1110 1140,1560 1560,1740
direct access from memory,| so
|由于我们在这里没有涉及任何软件，

978
00:33:56,640 --> 00:33:57,570
0,240 240,390 390,480 480,660 660,930
since here we don't have

979
00:33:57,570 --> 00:33:59,610
0,480 510,1260 1290,1710 1710,1950 1950,2040
any software involved,| since the
|网卡可以直接访问内存，

980
00:33:59,610 --> 00:34:01,440
0,180 180,330 330,690 690,1110 1110,1830
NIC can directly access the

981
00:34:02,160 --> 00:34:05,100
0,570 570,990 990,1860 1890,2700 2700,2940
memory| without even notifying the
|甚至不需要通知应用或操作系统，

982
00:34:05,100 --> 00:34:07,530
0,660 660,930 930,1230 1260,1800 2010,2430
application or the OS,| shouldn't
|不应该在硬件层面上进行一些协调，

983
00:34:07,530 --> 00:34:08,430
0,90 90,240 240,720 720,840 840,900
be some coordination on the

984
00:34:08,430 --> 00:34:10,560
0,630 660,1260 1260,1650 1650,1980 1980,2130
hardware level,| {} or at
|或者至少从处理器支持这个特性。

985
00:34:10,560 --> 00:34:12,630
0,300 300,450 450,1200 1290,1620 1620,2070
least some support {} also

986
00:34:12,630 --> 00:34:15,000
0,240 240,390 390,1200 1440,1800 1800,2370
from the processor {} to

987
00:34:15,000 --> 00:34:16,960
0,780 900,1230 1230,1830
this {} feature.|
|

988
00:34:17,190 --> 00:34:18,870
0,330 330,510 510,780 780,1410 1410,1680
Yeah, so there's, {} it's
是的，所以，

989
00:34:18,900 --> 00:34:19,830
0,480 480,570 570,660 660,810 810,930
basically,| you know the NIC
|网卡可以原子地读写缓存行，

990
00:34:19,830 --> 00:34:22,350
0,240 240,420 420,510 510,930 2310,2520
can read or write {}

991
00:34:22,380 --> 00:34:24,900
0,870 870,1410 1440,1740 1740,2190
{read,or,write} {} cache lines

992
00:34:25,360 --> 00:34:27,550
0,330 330,750 750,1020 1320,1740 1740,2190
{} {atomically -}| and so
|为了支持这一点，

993
00:34:27,550 --> 00:34:28,930
0,390 420,600 600,960 960,1260 1260,1380
{} to support this,| you
|有一个接口在内存系统和网卡之间，

994
00:34:28,930 --> 00:34:30,850
0,120 120,420 420,1140 1140,1860 1860,1920
know there's an interface you

995
00:34:30,850 --> 00:34:32,440
0,150 150,780 780,870 870,1170 1170,1590
know to the memory system

996
00:34:32,830 --> 00:34:34,540
0,750 750,1110 1110,1320 1320,1560 1560,1710
between NIC,| and this has
|必须在操作系统仔细设置，

997
00:34:34,540 --> 00:34:35,500
0,60 60,150 150,570 570,750 750,960
to be carefully {setup -}

998
00:34:35,500 --> 00:34:37,930
0,570 570,810 810,1650 1650,2190 2190,2430
{you,know,between} {} OS| and when
|当连接设置完成时。

999
00:34:37,930 --> 00:34:38,920
0,60 60,390 390,660 660,750 750,990
the connection setup is done.|
|

1000
00:34:40,710 --> 00:34:42,220
0,180 180,330 330,540 540,810
I see, thank you.|
我明白了，谢谢。|

1001
00:34:43,780 --> 00:34:45,820
0,480 480,870 870,1080 1080,1800 1860,2040
{} Sorry, the write to
抱歉，右侧的 写入RDMA 是红色的，

1002
00:34:45,820 --> 00:34:47,920
0,780 780,1320 1350,1500 1500,1770 1770,2100
RDMA on the right side

1003
00:34:47,920 --> 00:34:50,410
0,120 120,330 330,930 1830,2100 2100,2490
that is red,| what happens
|那里发生了什么？

1004
00:34:50,410 --> 00:34:51,180
0,480
there?|
|

1005
00:34:52,120 --> 00:34:54,940
0,480 480,1140 1170,1350 1350,1950 2280,2820
So, {} the sender, the
所以，发送者，左边的机器可以执行 写入RDMA ，

1006
00:34:54,940 --> 00:34:57,010
0,270 270,870 1320,1500 1500,1830 1830,2070
left machine can do write

1007
00:34:57,010 --> 00:34:59,140
0,750 1080,1320 1320,1530 1530,1860 1860,2130
RDMA,| {} which basically sends
|发送 写入RDMA 包到右侧，

1008
00:34:59,140 --> 00:35:01,360
0,450 450,840 840,1290 1590,1830 1830,2220
{an,write} RDMA packets| to the
|到右边的目标，

1009
00:35:01,480 --> 00:35:03,100
0,450 450,840 840,930 930,1080 1080,1620
right side you know the

1010
00:35:03,100 --> 00:35:05,230
0,780 1080,1380 1380,1440 1440,1920 1950,2130
destination,| and the NIC you
|网卡会看到这是一个 写入RDMA 包，

1011
00:35:05,230 --> 00:35:06,340
0,150 150,420 420,810 810,930 930,1110
know sees this is a

1012
00:35:06,340 --> 00:35:08,800
0,330 330,1020 1020,1620 2040,2250 2250,2460
write RDMA packet,| and will
|并将写入网络来的内容，

1013
00:35:08,800 --> 00:35:09,880
0,180 180,240 240,720 720,840 840,1080
write the content that came

1014
00:35:09,880 --> 00:35:11,260
0,120 120,390 390,450 450,1020 1230,1380
in over the network| to
|写入 RDMA 命令中指定的地址。

1015
00:35:11,260 --> 00:35:13,030
0,120 120,540 540,720 720,1440 1440,1770
the address that's specified in

1016
00:35:13,030 --> 00:35:15,420
0,510 540,870 870,1560 1680,2160
the write RDMA command.|
|

1017
00:35:18,950 --> 00:35:20,240
0,300 300,450 450,600 600,750 750,1290
But that would be just.|
但这将是。|

1018
00:35:20,750 --> 00:35:22,370
0,240 240,360 360,570 570,1350 1350,1620
And so there's a remote
所以有一台远程机器，

1019
00:35:22,370 --> 00:35:23,330
0,330 330,420 420,570 570,870 870,960
machine,| can just write the
|可以写入内存地址在目标机器上，

1020
00:35:23,330 --> 00:35:25,820
0,270 270,900 1470,1770 1770,1890 1890,2490
memory location set of addresses

1021
00:35:25,820 --> 00:35:27,680
0,360 360,480 480,1020 1020,1410 1410,1860
on the destination machine,| without
|在没有服务器参与的情况下，

1022
00:35:27,680 --> 00:35:29,300
0,270 270,540 540,630 630,1260 1500,1620
actually having the server you

1023
00:35:29,300 --> 00:35:30,960
0,390 510,870 870,1470
know being involved,|
|

1024
00:35:31,670 --> 00:35:32,690
0,270 270,390 390,600 600,930 930,1020
other than doing setup, of
当然，除了设置之外。

1025
00:35:32,690 --> 00:35:33,360
0,420
course.|
|

1026
00:35:33,860 --> 00:35:35,220
0,540 540,1080
Thank you.|
谢谢。|

1027
00:35:35,960 --> 00:35:36,740
0,420

1028
00:35:37,030 --> 00:35:38,770
0,570 570,780 780,1080 1080,1440 1440,1740
So, quick question,| so that
所以，我有个小问题，|所以队列和网卡只用于读 RDMA ，

1029
00:35:38,770 --> 00:35:39,740
0,660
the,

1030
00:35:40,140 --> 00:35:42,780
0,720 810,990 990,1680 1770,2370 2400,2640
{} the queue, the queue

1031
00:35:42,780 --> 00:35:44,100
0,150 150,450 450,900 930,1140 1140,1320
and the NIC is only

1032
00:35:44,100 --> 00:35:46,500
0,300 300,510 510,900 1110,1800 2190,2400
used for read RDMA,| like
|（因为）写入直接到接收者的内存。

1033
00:35:46,500 --> 00:35:48,300
0,150 150,690 870,1230 1230,1680 1680,1800
the write, write directly to

1034
00:35:48,300 --> 00:35:50,980
0,600 870,1080 1080,1500 1710,2400
memory at the receiver.|
|

1035
00:35:51,500 --> 00:35:52,730
0,330 330,480 480,570 570,930 930,1230
Yeah, on the on the,|
是的，在，|

1036
00:35:52,790 --> 00:35:53,990
0,210 210,660 660,870 870,990 990,1200
{ -} okay, so there
好的，在写入 RDMA 中，

1037
00:35:53,990 --> 00:35:55,040
0,120 120,210 210,480 480,930 930,1050
on the write RDMA,| as
|你可能在报纸上注意到的，

1038
00:35:55,040 --> 00:35:56,150
0,330 330,660 660,960 960,1020 1020,1110
you maybe noticed in the

1039
00:35:56,150 --> 00:35:57,470
0,480 600,870 870,1050 1050,1200 1200,1320
paper,| {} there can be
|可能会有确认，

1040
00:35:57,470 --> 00:35:59,060
0,60 60,660 660,930 930,1320
an acknowledgment coming back,|
|

1041
00:35:59,400 --> 00:36:01,440
0,630 630,1170 1320,1530 1530,1860 1860,2040
{} so, {} if the
所以，如果发送方发送写入 RDMA ，

1042
00:36:01,440 --> 00:36:03,600
0,600 720,1350 1350,1530 1530,1830 1830,2160
sender sends does write {RDMA

1043
00:36:03,600 --> 00:36:05,190
0,510 600,810 810,960 960,1140 1140,1590
-},| {} it can wait
|它可以等待来自接收网卡的确认，

1044
00:36:05,220 --> 00:36:07,320
0,510 510,660 660,1380 1380,1680 1680,2100
from an acknowledgement, from the

1045
00:36:07,380 --> 00:36:09,660
0,660 660,1110 1260,1590 1590,1890 1890,2280
receiving NIC,| that actually indeed
|表示执行了写入 RDMA 。

1046
00:36:09,660 --> 00:36:11,580
0,690 690,810 810,1050 1050,1680
performed the write RDMA.|
|

1047
00:36:11,960 --> 00:36:12,980
0,570

1048
00:36:13,550 --> 00:36:15,380
0,840 1050,1380 1380,1530
Okay, {thanks -}.|
好的，谢谢。|

1049
00:36:16,630 --> 00:36:17,620
0,240 240,300 300,720 720,930 930,990
And that will play an
这将发挥重要作用。

1050
00:36:17,620 --> 00:36:18,600
0,360 360,750
important role.|
|

1051
00:36:21,300 --> 00:36:23,460
0,390 390,630 630,1020 1020,1560 1920,2160
Any more questions about this
关于这一部分，还有什么问题吗？

1052
00:36:23,460 --> 00:36:24,200
0,450
part?|
|

1053
00:36:25,430 --> 00:36:26,570
0,270 270,420 420,480 480,840 870,1140
This sort of a cool
这是一种很酷的技术，

1054
00:36:26,570 --> 00:36:27,800
0,180 180,240 240,1020 1020,1080 1080,1230
piece of technology,| you know
|在过去的十年里，这种情况相当普遍地出现，

1055
00:36:27,800 --> 00:36:29,960
0,450 450,690 690,960 960,1470 1470,2160
that's {} come into existence

1056
00:36:29,990 --> 00:36:32,510
0,810 840,1740 2070,2310 2310,2430 2430,2520
pretty widespread {} in the

1057
00:36:32,510 --> 00:36:34,820
0,270 270,810 1140,1770 1770,2220 2220,2310
last decade,| and basically they
|他们想要利用这一点，

1058
00:36:34,820 --> 00:36:36,000
0,210 210,270 270,690 690,870
want to leverage it,|
|

1059
00:36:37,620 --> 00:36:38,550
0,390 390,450 450,750 750,840 840,930
because it allows them to
因为这让他们获得延迟，

1060
00:36:38,550 --> 00:36:41,010
0,150 150,450 450,1170 1440,2040 2100,2460
get very, {} get something

1061
00:36:41,010 --> 00:36:42,540
0,360 390,990 990,1140 1140,1380 1380,1530
the latency| to actually do
|进行单边 RDMA 约为 5 微秒，

1062
00:36:42,540 --> 00:36:44,250
0,210 210,300 300,720 750,1200 1200,1710
one of these {one-sided -}

1063
00:36:44,250 --> 00:36:46,110
0,660 660,930 1050,1350 1350,1590 1590,1860
{RDMAs -} about 5 {microseconds

1064
00:36:46,110 --> 00:36:47,180
0,600
-},|
|

1065
00:36:49,000 --> 00:36:51,700
0,450 690,1410 1440,1740 1740,2280
so very low latency,|
所以非常低的延迟，|

1066
00:36:54,010 --> 00:36:55,840
0,690 690,870 870,1050 1050,1380 1380,1830
much much much faster, correct,|
非常快，|

1067
00:36:55,840 --> 00:36:56,980
0,420 420,660 660,750 750,1020 1020,1140
{for,example} reading or writing a
例如，读取或写入磁盘，

1068
00:36:56,980 --> 00:37:00,460
0,510 810,1800 1800,2370 2370,3090 3120,3480
disk,| {} and {} not
|比写入你自己的内存慢不了多少，

1069
00:37:00,460 --> 00:37:02,050
0,300 300,810 840,1200 1200,1350 1350,1590
much slower, slower than writing

1070
00:37:02,050 --> 00:37:04,570
0,210 210,630 840,1290 1290,1860 1890,2520
your own { -} memory,|
|

1071
00:37:04,660 --> 00:37:05,830
0,330 330,540 540,630 630,900 900,1170
{} but you know pretty
非常快，

1072
00:37:05,830 --> 00:37:06,460
0,480
fast,|
|

1073
00:37:08,020 --> 00:37:08,980
0,300 300,390 390,660 660,780 780,960
because it allows you to
因为它允许你做一微秒，每秒一百万个包，

1074
00:37:08,980 --> 00:37:11,530
0,480 810,1140 1140,1350 1350,1920 1920,2550
do {} is one microsecond,

1075
00:37:11,530 --> 00:37:12,700
0,90 90,450 450,720 720,840 840,1170
a million packets per second,|
|

1076
00:37:14,150 --> 00:37:15,340
0,330 330,900
pretty impressive.|
令人印象深刻。|

1077
00:37:17,450 --> 00:37:18,280
0,540
Okay?|
好的?|

1078
00:37:19,320 --> 00:37:20,460
0,120 120,300 300,450 450,660 660,1140
So this so far basically
到目前为止，这是标准技术，

1079
00:37:20,460 --> 00:37:23,310
0,390 390,990 1020,1320 1350,2760 2790,2850
standard technology, right,| {} you
|前沿的，但是标准的。

1080
00:37:23,310 --> 00:37:24,060
0,420
know

1081
00:37:24,520 --> 00:37:25,990
0,420 420,720 720,1050 1050,1320 1320,1470
{} cutting edge, but you

1082
00:37:25,990 --> 00:37:27,380
0,660 660,1140
know standard.|
|

1083
00:37:27,990 --> 00:37:29,080
0,510
So,
所以，这篇论文解决的真正挑战是，

1084
00:37:29,540 --> 00:37:30,480
0,600
the

1085
00:37:30,980 --> 00:37:32,630
0,480 480,930 930,1050 1050,1320 1320,1650
real challenge that the paper

1086
00:37:32,630 --> 00:37:34,920
0,750 990,1950
{address,is} {},|
|

1087
00:37:36,800 --> 00:37:38,630
0,150 150,420 420,810 810,960 960,1830
it's actually how to use
是如何使用 RDMA ，

1088
00:37:39,530 --> 00:37:42,770
0,990 1500,1980 1980,2280 2280,2910 2910,3240
RDMA,| both write RDMA and
|写入 RDMA 和单边 RDMA 进行事务，

1089
00:37:42,770 --> 00:37:44,810
0,210 210,780 780,1230 1230,1620 1680,2040
{one-sided -} {RDMA -} actually

1090
00:37:44,810 --> 00:37:46,430
0,420 420,990 990,1170 1170,1260 1260,1620
doing transactions,| so the challenge
|所以，论文所解决的挑战是事务使用 RDMA 。

1091
00:37:46,430 --> 00:37:49,310
0,240 240,480 480,1050 1110,2250 2310,2880
this paper {address,is} transactions using

1092
00:37:49,340 --> 00:37:53,360
0,660
RDMA.|
|

1093
00:37:57,490 --> 00:37:58,780
0,570

1094
00:37:59,210 --> 00:38:01,430
0,600 690,900 900,1410 1890,2010 2010,2220
And you know {} sort
你可以看到这是一个挑战，

1095
00:38:01,430 --> 00:38:02,510
0,210 270,720 720,870 870,1020 1020,1080
of see that this is

1096
00:38:02,510 --> 00:38:03,860
0,120 120,630 630,1110 1140,1260 1260,1350
{} challenge,| we have to
|我们必须考虑一下，

1097
00:38:03,860 --> 00:38:04,700
0,180 180,240 240,420 420,570 570,840
think a little bit about,|
|

1098
00:38:04,700 --> 00:38:05,930
0,210 210,480 510,960 960,1080 1080,1230
all the protocols that we've
到目前为止我们看到的所有协议，

1099
00:38:05,930 --> 00:38:07,460
0,210 210,390 390,840 1200,1440 1440,1530
seen so far,| so it
|事务的协议，两阶段提交等，

1100
00:38:07,460 --> 00:38:10,280
0,120 120,240 240,930 930,1530
sort of protocols for

1101
00:38:11,650 --> 00:38:13,640
0,330 330,570 570,1470
{you,know} for transactions,

1102
00:38:14,690 --> 00:38:18,560
0,270 270,510 510,780 780,1350 2130,3870
{} {two-phase -} commit, etc,|
|

1103
00:38:18,710 --> 00:38:20,330
0,330 330,540 540,900 900,1230 1230,1620
all those { -} protocols
所有这些协议都需要服务器端参与，

1104
00:38:20,330 --> 00:38:23,060
0,150 150,930 1050,1710 1710,2010 2010,2730
have required {server-side -} participation,|
|

1105
00:38:33,290 --> 00:38:35,330
0,210 210,330 330,1110 1110,1680 1680,2040
and for example, {} what
例如，我的意思是，

1106
00:38:35,330 --> 00:38:37,070
0,90 90,360 360,480 480,870 1110,1740
I mean with that is|
|

1107
00:38:37,070 --> 00:38:39,980
0,1380 1620,2100 2100,2280 2280,2340 2340,2910
{you,know,the} client sends a request
客户端发送请求到事务协调者，

1108
00:38:39,980 --> 00:38:41,480
0,150 150,330 330,780 780,1320 1320,1500
for the transaction coordinator,| sends
|发送请求到其中一个参与者，

1109
00:38:41,480 --> 00:38:42,260
0,60 60,420 420,510 510,690 690,780
a request to one of

1110
00:38:42,260 --> 00:38:44,120
0,90 90,870 1230,1500 1500,1560 1560,1860
the participants,| {} for example
|比如获取某个对象的锁，

1111
00:38:44,120 --> 00:38:45,830
0,90 90,690 690,750 750,1200 1230,1710
to require a lock on

1112
00:38:45,830 --> 00:38:48,410
0,0 0,540 540,1290 1290,2010 2190,2580
{} a particular object,| and
|等待服务器或接收者，

1113
00:38:48,410 --> 00:38:49,790
0,240 240,480 480,1020 1020,1140 1140,1380
{you,know} just wait you know

1114
00:38:49,790 --> 00:38:52,310
0,300 300,1620 1620,2100 2100,2430 2430,2520
on the server or the

1115
00:38:52,310 --> 00:38:53,930
0,480 480,810 810,930 930,1230 1230,1620
receiver| until the lock actually
|直到锁变得可用，

1116
00:38:53,930 --> 00:38:56,180
0,180 180,450 450,960 1470,2160 2160,2250
it becomes available,| or you
|或者服务器运行一些验证步骤，

1117
00:38:56,180 --> 00:38:57,440
0,270 270,780 780,870 870,1110 1110,1260
know runs you know the

1118
00:38:57,440 --> 00:39:00,200
0,300 300,540 540,1320 1350,2250 2280,2760
server {runs,some} validation {} step,|
|

1119
00:39:00,200 --> 00:39:01,300
0,60 60,180 180,300 300,810
you know to see
查看事务是否能被提交，

1120
00:39:01,910 --> 00:39:04,520
0,480 480,840 840,1590 1740,2100 2130,2610
{} if the the transaction

1121
00:39:04,520 --> 00:39:05,720
0,210 210,360 360,720 720,810 810,1200
can be committed or not,|
|

1122
00:39:06,230 --> 00:39:07,550
0,390 390,600 600,960 1020,1200 1200,1320
{} and so in all
所以在所有这些情况中，

1123
00:39:07,550 --> 00:39:09,500
0,180 180,630 630,1260 1380,1800 1800,1950
those cases basically,| {} if
|如果你有一些服务器端参与，

1124
00:39:09,500 --> 00:39:11,090
0,120 120,390 390,510 510,1020 1020,1590
you have some server-side participation,|
|

1125
00:39:11,090 --> 00:39:12,020
0,120 120,450 450,630 630,780 780,930
that means that you have
意味着你必须在服务器上运行代码，

1126
00:39:12,020 --> 00:39:13,100
0,120 120,420 420,900 900,1020 1020,1080
to run code on the

1127
00:39:13,100 --> 00:39:14,120
0,450
server,|
|

1128
00:39:22,550 --> 00:39:24,110
0,600 780,960 960,1230 1230,1500 1500,1560
and you know that is
这与 RDMA 给你带来的是相反的，

1129
00:39:24,110 --> 00:39:26,090
0,150 150,330 720,1410 1410,1590 1590,1980
sort of counter to what

1130
00:39:26,090 --> 00:39:27,410
0,480 480,690 690,870 870,1140 1140,1320
RDMA gives you, right,| {RDMA
|RDMA 没有为你提供在服务器上运行代码的能力，

1131
00:39:27,410 --> 00:39:29,060
0,390 390,960 960,1320 1320,1650 1650,1650
-} actually {} doesn't {}

1132
00:39:29,690 --> 00:39:31,280
0,630 630,750 750,960 960,1440 1440,1590
provide you the ability to

1133
00:39:31,280 --> 00:39:33,110
0,240 240,720 960,1200 1200,1260 1260,1830
run code on the server,|
|

1134
00:39:33,170 --> 00:39:35,540
0,120 120,270 270,1620 1620,1740 1740,2370
and so the the designers
所以，这篇论文的设计者或作者

1135
00:39:35,540 --> 00:39:36,230
0,120 120,210 210,330 330,630 630,690
{or -} the authors of

1136
00:39:36,230 --> 00:39:37,070
0,150 150,510 510,630 630,720 720,840
this paper| have to come
|必须想出一种协议，

1137
00:39:37,070 --> 00:39:38,540
0,150 150,330 330,510 510,630 630,1470
up with sort of protocols,|
|

1138
00:39:38,750 --> 00:39:40,640
0,600 630,1020 1020,1140 1140,1230 1230,1890
that allow you to implement
允许你实现两阶段提交和事务

1139
00:39:40,640 --> 00:39:42,440
0,120 120,360 360,900 1080,1500 1500,1800
{two-phase -} commit {} and

1140
00:39:42,440 --> 00:39:44,900
0,450 450,570 570,1260 1380,2190 2190,2460
transactions in general| to {}
|不使用或试着减少服务器端参与，

1141
00:39:44,900 --> 00:39:46,670
0,630 630,1110 1110,1380 1380,1650 1650,1770
without actually or trying to

1142
00:39:46,670 --> 00:39:48,530
0,570 570,720 720,990 990,1200 1200,1860
reduce your {server-side -} participation,|
|

1143
00:39:49,480 --> 00:39:50,350
0,210 210,360 360,480 480,660 660,870
so that they can {reuse
他们可以重用 RDMA 进行某些操作，

1144
00:39:50,350 --> 00:39:51,190
0,120 120,420 420,660 660,750 750,840
-} some part of the

1145
00:39:51,190 --> 00:39:54,250
0,600 600,900 900,1650 1830,2520 2520,3060
operations using RDMA,| {} and
|有些使用远程过程调用，

1146
00:39:54,250 --> 00:39:55,420
0,120 120,210 210,600 600,930 930,1170
you know some using remote

1147
00:39:55,420 --> 00:39:56,890
0,360 360,780 810,1170 1170,1290 1290,1470
procedure calls,| as usual sort
|像传统做法一样，

1148
00:39:56,890 --> 00:39:58,090
0,240 240,720 720,870 870,1020 1020,1200
of traditional would do,| in
|在过去的几周里我们看到的传统设计。

1149
00:39:58,090 --> 00:39:59,980
0,90 90,750 990,1560 1560,1710 1710,1890
{} traditional designs, that we've

1150
00:39:59,980 --> 00:40:01,150
0,180 180,270 270,360 360,810 900,1170
seen in the last couple

1151
00:40:01,150 --> 00:40:01,800
0,510
weeks.|
|

1152
00:40:02,430 --> 00:40:03,450
0,240 240,480 510,840 840,960 960,1020
And so that's sort of
这就是这篇论文的核心挑战，

1153
00:40:03,450 --> 00:40:05,730
0,90 90,510 510,1200 1290,2100 2100,2280
the central challenge {} in

1154
00:40:05,730 --> 00:40:07,980
0,420 420,600 600,750 750,1170 1830,2250
{} in this paper, {}|
|

1155
00:40:07,980 --> 00:40:10,080
0,180 180,810 840,1200 1200,1680 1680,2100
and this pushes them {}
这促使他们朝着这个方向去解决这个问题，

1156
00:40:10,080 --> 00:40:12,810
0,570 600,810 810,1470 2010,2160 2160,2730
in this direction to solve

1157
00:40:12,810 --> 00:40:15,330
0,180 180,690 1020,1350 1380,1980 1980,2520
that problem,| the high-level strategy
|他们使用的高级策略是，

1158
00:40:15,330 --> 00:40:17,880
0,150 150,270 270,840 990,1980
that they use is,|
|

1159
00:40:21,220 --> 00:40:22,720
0,180 180,390 390,480 480,930 930,1500
the {high,level -} strategy {uses,is}
使用的高级策略是乐观并发控制。

1160
00:40:22,720 --> 00:40:27,460
0,1290 2610,2730 2730,3000 3000,3570
optimistic {concurrency -} control.|
|

1161
00:40:30,750 --> 00:40:33,180
0,630 780,1140 1290,1530 1530,1800 1800,2430
And and {you,know} really did
他们真正的闪光点是在读取操作上，

1162
00:40:33,330 --> 00:40:35,490
0,810 810,1500 1530,1620 1620,2040 2040,2160
really where the shine for

1163
00:40:35,490 --> 00:40:37,050
0,240 240,330 330,570 570,780 780,1560
them is on read operations,|
|

1164
00:40:37,320 --> 00:40:39,510
0,1080 1080,1440 1440,1560 1560,1890 1890,2190
because basically the basic plan
因为基本计划是读取对象，

1165
00:40:39,510 --> 00:40:41,580
0,270 450,720 720,930 930,1530
is {} read objects,|
|

1166
00:40:42,340 --> 00:40:43,180
0,360 360,450 450,660 660,720 720,840
that are part of the
这些是不需要锁的事务部分，

1167
00:40:43,180 --> 00:40:46,600
0,810 1260,1560 1560,2070 2190,2820 2820,3420
transaction {without -} requiring locks,|
|

1168
00:40:51,240 --> 00:40:52,830
0,60 60,570 570,1050 1050,1500 1500,1590
for example require locks you
例如，需要锁，这意味着可能会中断服务器，

1169
00:40:52,830 --> 00:40:54,210
0,60 60,210 210,360 360,840 840,1380
know that would mean {}

1170
00:40:54,210 --> 00:40:56,580
0,600 600,870 870,960 960,1680 1830,2370
interrupting maybe the server {},|
|

1171
00:40:56,580 --> 00:40:58,080
0,120 120,420 420,660 660,930 930,1500
the server has {to,do,some} work,|
服务器必须做一些工作，|

1172
00:40:58,080 --> 00:40:59,940
0,120 120,720 720,1200 1200,1800 1800,1860
and then maybe block the
可能会阻止客户端，

1173
00:40:59,940 --> 00:41:01,410
0,600 600,810 810,1050 1050,1380 1380,1470
client| until the lock is
|直到锁可用，然后返回对象，

1174
00:41:01,410 --> 00:41:03,510
0,630 630,780 780,1170 1320,2010 2010,2100
available and then return the

1175
00:41:03,510 --> 00:41:04,860
0,390 390,630 960,1050 1050,1140 1140,1350
object,| and you know that
|这与 RDMA 并不是很合适，

1176
00:41:04,860 --> 00:41:07,140
0,120 120,390 390,960 1260,1860 1860,2280
is not really suitable or

1177
00:41:07,170 --> 00:41:09,780
0,300 300,570 570,1140 1140,1650 1860,2610
{nice -} nicely with {}

1178
00:41:09,780 --> 00:41:11,550
0,150 150,360 360,750 750,1230 1230,1770
or lines up nicely with

1179
00:41:11,820 --> 00:41:13,440
0,210 210,1050 1140,1350 1350,1470 1470,1620
{} RDMA,| and so they're
|所以，他们将采取乐观的方案，

1180
00:41:13,440 --> 00:41:14,580
0,150 150,240 240,450 450,750 750,1140
going to go to {}

1181
00:41:14,580 --> 00:41:16,950
0,570 570,1140 1230,1740 1740,2070 2070,2370
optimistic scheme,| where basically reading
|其中读取对象不需要任何锁，

1182
00:41:16,950 --> 00:41:17,820
0,360 360,450 450,660 660,780 780,870
objects is not going to

1183
00:41:17,820 --> 00:41:19,110
0,450 450,600 600,870 870,960 960,1290
require {} locks at all,|
|

1184
00:41:19,140 --> 00:41:20,070
0,180 180,360 360,540 540,870 870,930
you {} can fetch an
你获取一个对象并开始使用它，

1185
00:41:20,070 --> 00:41:22,500
0,600 900,1530 1530,1950 1950,2190 2190,2430
object {} and start using

1186
00:41:22,500 --> 00:41:24,300
0,300 300,630 870,1050 1050,1200 1200,1800
it,| and as we'll see,|
|正如我们将看到的，|

1187
00:41:24,390 --> 00:41:25,380
0,510 510,600 600,690 690,930 930,990
{} {you,know} of course you
当然你需要一些机制

1188
00:41:25,380 --> 00:41:26,790
0,180 180,270 270,480 480,900 900,1410
need to have some mechanism|
|

1189
00:41:26,790 --> 00:41:28,080
0,120 120,600 600,870 870,1020 1020,1290
to discover whether you're reading
来发现读取的是旧版本还是新版本，

1190
00:41:28,080 --> 00:41:28,920
0,120 120,330 330,600 600,690 690,840
an old version or new

1191
00:41:28,920 --> 00:41:30,090
0,480 660,780 780,930 930,990 990,1170
version,| and this is where
|这就是版本号将发挥重要作用的地方。

1192
00:41:30,090 --> 00:41:31,050
0,60 60,360 360,780 780,840 840,960
the version numbers are going

1193
00:41:31,050 --> 00:41:32,130
0,90 90,300 300,420 420,780 780,1080
to play an important role.|
|

1194
00:41:39,130 --> 00:41:40,000
0,240 240,420 420,600 600,720 720,870
{} So when you read
所以当你读取 FaRM 中的一个对象，

1195
00:41:40,000 --> 00:41:41,950
0,90 90,750 780,1110 1110,1350 1350,1950
an object {} in FaRM,|
|

1196
00:41:41,950 --> 00:41:42,970
0,270 270,390 390,480 480,780 780,1020
you get the object back,|
你把对象拿回来，|

1197
00:41:42,970 --> 00:41:43,870
0,90 90,180 180,300 300,570 570,900
and you get also the
你也把那个对象的版本号拿回来，

1198
00:41:43,870 --> 00:41:44,740
0,120 120,420 420,570 570,810 810,870
{} version number back to

1199
00:41:44,740 --> 00:41:47,470
0,150 150,630 1140,1320 1320,1860 1890,2730
that object,| and then {}
|然后基本的想法是，

1200
00:41:47,500 --> 00:41:49,330
0,810 810,1350 1350,1470 1470,1710 1710,1830
basic idea is that,| at
|在提交的时候，

1201
00:41:49,330 --> 00:41:50,500
0,60 60,360 360,420 420,960
the point of commit,|
|

1202
00:41:50,810 --> 00:41:53,090
0,1020 1410,1950 1950,2010 2010,2190 2190,2280
we're going to do a
我们要做一个验证步骤，

1203
00:41:53,090 --> 00:41:54,480
0,510 510,1320
validation step,|
|

1204
00:41:56,300 --> 00:41:59,780
0,150 150,690 720,1110 1110,2640 2850,3480
to check that the objects
检查事务开始时写入的对象，

1205
00:41:59,780 --> 00:42:01,310
0,360 360,660 690,1380 1380,1470 1470,1530
being {} write at the

1206
00:42:01,310 --> 00:42:02,930
0,270 270,360 360,450 450,1200 1290,1620
beginning of the transaction, {}|
|

1207
00:42:02,930 --> 00:42:04,760
0,210 210,420 420,570 570,1230 1650,1830
actually having been modified.| And
已经被修改了。|所以，在验证检查步骤期间，

1208
00:42:04,760 --> 00:42:06,680
0,210 210,510 510,1080 1080,1440 1440,1920
so during validation check step,|
|

1209
00:42:06,800 --> 00:42:07,820
0,150 150,450 450,570 570,690 690,1020
we're basically going to check
我们要检查冲突，

1210
00:42:07,820 --> 00:42:09,260
0,150 150,900
for conflict,|
|

1211
00:42:15,860 --> 00:42:17,270
0,330 330,420 420,810 810,900 900,1410
and the conflict is basically,|
冲突是，|

1212
00:42:17,270 --> 00:42:18,950
0,240 240,330 330,690 690,1200 1200,1680
if the version number {}
如果版本号已递增，

1213
00:42:18,980 --> 00:42:21,080
0,270 270,390 390,1110 1260,1620 1620,2100
has been incremented,| {you,know} since
|从协调者读取了对象，

1214
00:42:21,080 --> 00:42:24,470
0,120 120,840 1140,2850 2850,3090 3090,3390
you know {the,coordinator} actually read

1215
00:42:24,500 --> 00:42:26,300
0,150 150,690 870,1170 1170,1560 1560,1800
the object,| so {if,the,version} number
|所以如果版本号是不同的，

1216
00:42:26,300 --> 00:42:27,320
0,90 90,690
are different,|
|

1217
00:42:30,720 --> 00:42:33,900
0,990 1350,2160
different, then
是不同的，则事务中止，

1218
00:42:34,310 --> 00:42:36,620
0,240 240,990 990,1170 1170,1620
the transaction is aborted,|
|

1219
00:42:39,760 --> 00:42:41,140
0,510 510,630 630,780 780,1290 1290,1380
and if they're saying, are
如果仍然是一样的，

1220
00:42:41,140 --> 00:42:42,250
0,210 210,300 300,600 600,750 750,1110
still the same,| that basically
|这意味着没有其他事务修改了对象，

1221
00:42:42,250 --> 00:42:43,930
0,270 270,390 390,960 990,1470 1470,1680
means that nobody, no other

1222
00:42:43,930 --> 00:42:47,350
0,630 630,1290 1800,2610 2610,3270 3270,3420
transaction modified the transaction, the

1223
00:42:47,350 --> 00:42:49,270
0,660 900,1080 1080,1680 1680,1800 1800,1920
object,| and then we can
|然后我们可以继续并提交。

1224
00:42:49,270 --> 00:42:50,350
0,240 240,420 420,630 630,720 720,1080
actually go ahead and commit.|
|

1225
00:42:52,860 --> 00:42:53,730
0,120 120,360 360,480 480,600 600,870
Of course, in the case
当然，在中止的情况下，

1226
00:42:53,730 --> 00:42:55,560
0,300 300,960 960,1290 1290,1620 1620,1830
of abort,| {you,know} typical what
|通常会发生的情况是，

1227
00:42:55,560 --> 00:42:57,660
0,300 300,510 510,720 720,1140 1290,2100
happen is that,| the {the,client}
|客户端可能会再次运行整个事务，

1228
00:42:57,660 --> 00:42:59,580
0,90 90,450 480,810 810,1770 1770,1920
you know maybe run the

1229
00:42:59,610 --> 00:43:01,200
0,990 990,1290
{whole,transaction} again,|
|

1230
00:43:01,400 --> 00:43:02,660
0,600 600,870 870,990 990,1020 1020,1260
perhaps waiting for a little
也许在开始之前等一段时间，

1231
00:43:02,660 --> 00:43:04,700
0,480 480,1440 1440,1710 1710,1920 1920,2040
while before actually doing it,|
|

1232
00:43:04,730 --> 00:43:06,170
0,600 600,900 930,1140 1140,1380 1380,1440
{for,some} random {} period of
一段随机的时间。

1233
00:43:06,170 --> 00:43:06,840
0,330
time.|
|

1234
00:43:07,730 --> 00:43:09,920
0,270 270,510 510,630 630,1770 1770,2190
So that's the basic plan,
所以这就是基本的计划，

1235
00:43:10,010 --> 00:43:12,260
0,240 240,1080 1110,1320 1320,1650 1650,2250
right,| so {this,is} optimistic scheme,|
|这是一个乐观的方案，|

1236
00:43:12,350 --> 00:43:14,600
0,210 210,450 450,810 810,1830 1860,2250
so that reads can completely
这样读取可以完全利用 RDMA ，

1237
00:43:14,600 --> 00:43:17,540
0,720 750,1050 1050,1740 2010,2640 2640,2940
exploit {RDMA -},| {} and
|正如我们将看到的，

1238
00:43:17,540 --> 00:43:18,500
0,120 120,210 210,480 480,570 570,960
as we'll see,| in fact,
|读取不需要服务器上的任何状态变化。

1239
00:43:18,710 --> 00:43:21,260
0,600 600,840 840,1260 1260,1890 2160,2550
read won't require any state

1240
00:43:21,260 --> 00:43:23,270
0,630 660,1440 1440,1500 1500,1920 1920,2010
changes on the servers at

1241
00:43:23,270 --> 00:43:23,800
0,300
all.|
|

1242
00:43:25,500 --> 00:43:26,790
0,240 240,330 330,540 540,720 720,1290
And so this is basically
所以这是图 4 背后的基本思想，

1243
00:43:26,790 --> 00:43:28,650
0,180 180,270 270,630 720,1500 1500,1860
sort of the basic idea

1244
00:43:28,650 --> 00:43:32,640
0,510 570,1050 1050,1470 3060,3540 3540,3990
behind figure 4,| except {you,know}
|除了，我们很快就会看到，

1245
00:43:32,640 --> 00:43:33,420
0,120 120,300 300,390 390,420 420,780
we'll see in a second,|
|

1246
00:43:33,420 --> 00:43:34,320
0,240 240,450 450,480 480,660 660,900
there's quite a bit more
这件事要复杂得多。

1247
00:43:34,320 --> 00:43:35,700
0,660 660,840 840,1140
complications to it.|
|

1248
00:43:36,190 --> 00:43:38,380
0,270 270,630 660,1170 1170,1920 2010,2190
So this again, {sort,of} {}
所以这也是，我想我用过了这个短语，

1249
00:43:38,380 --> 00:43:39,100
0,120 120,300 300,390 390,630 630,720
I think I used this

1250
00:43:39,100 --> 00:43:39,880
0,210 210,270 270,330 330,540 540,780
phrase in a little while

1251
00:43:39,880 --> 00:43:41,110
0,240 240,330 330,510 510,780 780,1230
ago,| a couple lectures ago,|
|几节课前，|

1252
00:43:41,230 --> 00:43:43,420
0,270 270,840 840,1650 1650,1770 1770,2190
the optimistic schema in contrast
乐观方案与悲观方案相反的是，

1253
00:43:43,420 --> 00:43:44,800
0,60 60,180 180,690 690,1050 1050,1380
to the pessimistic scheme is,|
|

1254
00:43:44,950 --> 00:43:46,690
0,240 240,570 570,690 690,870 900,1740
you're basically going to assume
你假设你被允许执行操作，

1255
00:43:46,690 --> 00:43:47,620
0,180 180,390 390,750 750,810 810,930
that you're allowed to do

1256
00:43:47,620 --> 00:43:49,150
0,120 120,900 1140,1290 1290,1380 1380,1530
the operation,| and if it
|如果你不被允许，只需要道歉和中止，

1257
00:43:49,150 --> 00:43:50,260
0,240 240,450 450,600 600,780 780,1110
turns out you're not allowed,

1258
00:43:50,260 --> 00:43:51,370
0,60 60,240 240,300 300,990 990,1110
to sort of apologize and

1259
00:43:51,370 --> 00:43:53,290
0,510 780,1200 1200,1350 1350,1440 1440,1920
abort,| {} in the pessimistic
|在悲观的情况下，

1260
00:43:53,290 --> 00:43:54,910
0,360 360,480 480,870 870,1380 1380,1620
case,| you basically first ask
|你首先通过获取锁来请求批准进行操作，

1261
00:43:54,910 --> 00:43:55,960
0,150 150,720 720,810 810,930 930,1050
for approval to do the

1262
00:43:55,960 --> 00:43:58,120
0,570 570,780 780,1260 1260,1830 1980,2160
operation by acquiring locks,| and
|然后你被保证，

1263
00:43:58,120 --> 00:43:59,860
0,540 540,630 630,990 990,1560 1560,1740
then {you,know,you} basically guaranteed,| at
|在提交时，你可以提交。

1264
00:43:59,860 --> 00:44:01,240
0,270 270,660 840,1020 1020,1140 1140,1380
commit time, you can actually

1265
00:44:01,240 --> 00:44:01,760
0,420
commit.|
|

1266
00:44:02,480 --> 00:44:03,340
0,570
Okay?|
好的?|

1267
00:44:04,920 --> 00:44:06,390
0,210 210,630 630,990 990,1380 1380,1470
Any questions about optimistic {concurrency
对于高级别的乐观并发控制，有什么问题吗？

1268
00:44:06,390 --> 00:44:08,190
0,270 270,690 990,1170 1170,1590 1590,1800
-} control at this high

1269
00:44:08,190 --> 00:44:08,920
0,420
level?|
|

1270
00:44:10,670 --> 00:44:11,570
0,240 240,300 300,630 630,780 780,900
Just a question about the
只是一个关于版本号的问题，

1271
00:44:11,570 --> 00:44:12,980
0,360 360,900 900,1080 1080,1230 1230,1410
version numbers,| how do they
|他们如何确保两个不同的[]，

1272
00:44:12,980 --> 00:44:15,170
0,570 570,900 930,1230 1230,1860 1860,2190
ensure that two {different,[]}, that
|两个不同的对象之间具有一致性，

1273
00:44:15,200 --> 00:44:17,720
0,510 510,870 870,1680 1680,2220 2220,2520
there's like consistency across different

1274
00:44:17,720 --> 00:44:19,430
0,780 1050,1200 1200,1350 1350,1470 1470,1710
objects,| so that you're now
|你先读取一个对象，然后再读取另一个对象，

1275
00:44:19,430 --> 00:44:21,590
0,630 870,1170 1170,1770 1770,1860 1860,2160
reading one object and then

1276
00:44:21,590 --> 00:44:23,180
0,390 390,630 630,930 930,1380 1380,1590
later reading another object,| but
|但是一个事务修改了其中的一些。

1277
00:44:23,180 --> 00:44:25,520
0,570 600,780 780,870 870,1560 1560,2340
those, but a transaction modified

1278
00:44:25,850 --> 00:44:27,080
0,240 240,300 300,540 540,690 690,1230
some of those in between.|
|

1279
00:44:27,350 --> 00:44:29,180
0,270 270,720 780,1020 1020,1590 1590,1830
Yeah, well, {} that's a
是的，这是个很好的问题，

1280
00:44:29,180 --> 00:44:31,220
0,240 240,630 780,1410 1410,1530 1530,2040
great question,| and so let's,
|所以，我想我们要离开了，

1281
00:44:31,220 --> 00:44:32,480
0,300 450,750 750,930 930,1170 1170,1260
I think we're going to

1282
00:44:32,480 --> 00:44:33,770
0,300 300,480 480,720 720,900 900,1290
get out,| just gotta dive
|只需要深入到图 4 ，

1283
00:44:33,770 --> 00:44:35,300
0,480 480,780 780,1050 1050,1410
into actually figure 4,|
|

1284
00:44:35,890 --> 00:44:36,850
0,300 300,480 480,660 660,750 750,960
{} and which I think
我认为这是论文的核心。

1285
00:44:36,850 --> 00:44:37,570
0,120 120,210 210,270 270,660 660,720
should be the core of

1286
00:44:37,570 --> 00:44:38,480
0,150 150,630
this paper.|
|

1287
00:44:39,440 --> 00:44:40,820
0,450 450,630 630,810 810,990 990,1380
{} So let's look at
让我们看一下图 4 ，

1288
00:44:41,090 --> 00:44:42,800
0,600 600,870 870,1380
{} figure 4,|
|

1289
00:44:43,310 --> 00:44:44,480
0,840
and,
糟糕，不是那个。

1290
00:44:50,860 --> 00:44:52,540
0,330 330,570 570,690 690,1080
oops, not that one.|
|

1291
00:44:53,930 --> 00:44:54,920
0,690

1292
00:44:56,630 --> 00:44:58,100
0,420 420,570 570,840 840,1170
Alright, here figure 4,|
好的，这是图 4 ，|

1293
00:45:00,160 --> 00:45:00,970
0,150 150,270 270,330 330,540 540,810
we're going to spend quite
我们将花相当多的时间来讨论图 4 。

1294
00:45:00,970 --> 00:45:02,140
0,30 30,150 150,210 210,720 750,1170
a bit of time {}

1295
00:45:02,140 --> 00:45:03,550
0,360 360,660 660,780 780,1050 1050,1410
basically talking about figure 4.|
|

1296
00:45:04,960 --> 00:45:07,480
0,720 1260,1590 1590,1860 1860,2340 2340,2520
{ -} So {the,first} {you,know}
所以图 4 中的第一个东西，

1297
00:45:07,480 --> 00:45:09,250
0,390 390,510 510,1350 1440,1680 1680,1770
things get oriented {} in

1298
00:45:09,250 --> 00:45:11,500
0,210 210,780 780,1290 1320,2160 2160,2250
this figure 4,| {} you
|我们看到，

1299
00:45:11,500 --> 00:45:13,150
0,120 120,240 240,870 960,1290 1290,1650
know we see, { -}|
|

1300
00:45:17,910 --> 00:45:20,220
0,600 630,870 870,1050 1050,1260 1260,2310
{} so we have a
所以我们有一个事务协调者，这里的 C ，

1301
00:45:20,220 --> 00:45:22,920
0,450 450,1470 1590,1860 1860,2160 2160,2700
transaction coordinator, the C here,|
|

1302
00:45:23,190 --> 00:45:24,720
0,480 480,600 600,930 930,1170 1170,1530
and it's really the transaction
事务协调者是一个应用程序，

1303
00:45:24,720 --> 00:45:27,210
0,630 630,780 780,1200 1200,1980 2010,2490
coordinator is an application,| and
|应用程序运行在相同的机器上，

1304
00:45:27,510 --> 00:45:28,410
0,150 150,540 540,750 750,840 840,900
the application runs on the

1305
00:45:28,410 --> 00:45:29,340
0,270 270,630 630,690 690,870 870,930
same machine,| is one of
|是 90 台机器中的一台，

1306
00:45:29,340 --> 00:45:31,530
0,210 210,480 480,1200 1470,2130 2130,2190
those 90 machines,| but the
|但我会这样考虑，

1307
00:45:31,530 --> 00:45:32,220
0,210 210,300 300,420 420,510 510,690
way I'm going to think

1308
00:45:32,220 --> 00:45:33,450
0,270 270,450 630,1020 1020,1080 1080,1230
about it,| for the rest
|对于剩余的课程，

1309
00:45:33,450 --> 00:45:34,410
0,60 60,240 240,690 690,840 840,960
of those lectures,| that it
|它在一台单独的机器上运行，

1310
00:45:34,410 --> 00:45:35,490
0,180 180,360 360,420 420,750 750,1080
runs on a separate machine,|
|

1311
00:45:35,490 --> 00:45:36,300
0,60 60,180 180,360 360,570 570,810
I don't really care about
我不太关心它，好吗？

1312
00:45:36,300 --> 00:45:38,380
0,270 270,450 450,840 990,1620
it that much, okay?|
|

1313
00:45:38,620 --> 00:45:40,210
0,180 180,630 630,630 630,1380 1380,1590
And then, {} there are
然后，有不同的分片，

1314
00:45:40,210 --> 00:45:41,770
0,240 240,690 990,1290 1290,1410 1410,1560
different shards,| {} in this
|在这种情况下，有 3 个分片， 1 2 和 3 ，

1315
00:45:41,770 --> 00:45:42,940
0,300 300,420 420,480 480,690 690,1170
case there are 3 shards,

1316
00:45:43,540 --> 00:45:46,180
0,570 570,1110 1110,1260 1260,1770 2100,2640
1 2 and 3,| and
|每个分片被复制两次，

1317
00:45:46,180 --> 00:45:48,250
0,270 270,720 720,1200 1200,1680 1680,2070
each shard is replicated twice,|
|

1318
00:45:48,250 --> 00:45:49,330
0,270 270,330 330,420 420,900 900,1080
one's in the primary, one's
一个在主服务器，一个在备服务器。

1319
00:45:49,330 --> 00:45:50,120
0,60 60,150 150,510
in the backup.|
|

1320
00:45:51,050 --> 00:45:54,050
0,690 1290,2220 2250,2370 2370,2700 2700,3000
{} Then {you,know} we'll see
然后我们会看到，

1321
00:45:54,050 --> 00:45:55,130
0,210 210,330 330,420 420,510 510,1080
that,| this is the execution
|这是事务的执行阶段，

1322
00:45:55,130 --> 00:45:56,300
0,240 240,360 360,450 450,1020 1020,1170
phase of the transaction,| so
|所以事务有两个阶段，

1323
00:45:56,300 --> 00:45:57,920
0,120 120,600 600,720 720,930 930,1620
the transaction is two phases,|
|

1324
00:45:58,040 --> 00:45:59,450
0,360 360,480 480,540 540,1110 1110,1410
one is the execution phase,
一个是执行阶段，然后是提交阶段，

1325
00:45:59,450 --> 00:46:02,030
0,300 300,360 360,630 630,1170 1860,2580
and then commit phase, {}|
|

1326
00:46:02,030 --> 00:46:04,190
0,780 810,1170 1170,1290 1290,1890 1890,2160
and during the execution phase,|
在执行阶段期间，|

1327
00:46:04,190 --> 00:46:05,600
0,150 150,300 300,870 870,960 960,1410
this is where the transaction
这是事务运行的地方，

1328
00:46:05,600 --> 00:46:07,160
0,120 120,390 390,690 690,990 990,1560
is run,| so {does,it} begin,
|那么它执行开始，执行读取，

1329
00:46:07,400 --> 00:46:09,890
0,330 330,930 1200,1620 1650,2160 2160,2490
does read,| for example, in
|例如，在这种情况中， 3 个对象被读取，

1330
00:46:09,890 --> 00:46:11,090
0,180 180,480 480,630 630,870 870,1200
this case, the 3 objects

1331
00:46:11,090 --> 00:46:12,470
0,90 90,300 300,630 780,870 870,1380
are being read,| and one
|一个位于，它的主服务器，

1332
00:46:12,470 --> 00:46:13,940
0,210 210,360 360,900 900,1230 1260,1470
that was located, {} whose

1333
00:46:13,940 --> 00:46:15,830
0,480 480,1020 1110,1380 1380,1800 1800,1890
primary in,| one object that
|一个对象在分片 1 ，

1334
00:46:15,830 --> 00:46:17,780
0,360 360,720 720,1020 1020,1440 1590,1950
actually {sit,in} shard 1,| one
|一个对象在分片 3 ，

1335
00:46:17,780 --> 00:46:19,370
0,360 360,510 510,840 840,1170 1170,1590
object that's {sit,in} shard 3,|
|

1336
00:46:19,370 --> 00:46:21,200
0,270 270,930 930,990 990,1440 1470,1830
one objects {sit,in} shard 2,
一个对象在分片 2 ，区域 2 。

1337
00:46:21,660 --> 00:46:24,450
0,390 390,690 690,930 930,1290 1890,2790
alright, {} {region 2}.| And
|我们可以看到，

1338
00:46:24,600 --> 00:46:27,660
0,990 1290,2130 2250,2580 2580,2670 2670,3060
{} the we can see,|
|

1339
00:46:27,660 --> 00:46:28,740
0,360 360,690 690,870 870,930 930,1080
actually we look a little
我们向前看一点，

1340
00:46:28,740 --> 00:46:30,570
0,90 90,570 900,1410 1410,1590 1590,1830
bit ahead,| {} we'll see
|我们将会看到，

1341
00:46:30,570 --> 00:46:31,560
0,270 270,720
that the,|
|

1342
00:46:31,830 --> 00:46:32,850
0,390 390,540 540,720 720,870 870,1020
{} the two of these
两个对象正在被写入，

1343
00:46:32,850 --> 00:46:34,530
0,360 360,450 450,690 690,1110 1110,1680
objects are actually being {}

1344
00:46:34,620 --> 00:46:35,880
0,510 510,690 690,870 870,990 990,1260
written,| and one of them
|一个正在被读取，

1345
00:46:35,880 --> 00:46:37,440
0,180 180,450 450,810 1080,1260 1260,1560
is being read,| so the
|所以，来自分片 3 的对象，

1346
00:46:37,500 --> 00:46:40,350
0,390 390,840 870,1920 1950,2370 2370,2850
object from number shard 3,|
|

1347
00:46:40,410 --> 00:46:41,160
0,150 150,300 300,450 450,540 540,750
this is just a read
这是一个读操作，

1348
00:46:41,160 --> 00:46:42,750
0,570 660,960 960,1200 1200,1320 1320,1590
operation,| and these are write
|这些是写操作，

1349
00:46:42,750 --> 00:46:45,000
0,690 1140,1320 1320,1470 1470,1680 1680,2250
operations,| {or,these} are read operations,|
|或者这些是读操作，|

1350
00:46:45,000 --> 00:46:46,590
0,300 450,1080 1080,1380 1380,1470 1470,1590
but those objects are going
但这些对象将被修改。

1351
00:46:46,590 --> 00:46:47,600
0,60 60,180 180,810
to be modified.|
|

1352
00:46:48,270 --> 00:46:50,100
0,510 540,1080 1080,1290 1290,1350 1350,1830
So basically as the transaction
所以，随着事务的运行，

1353
00:46:50,100 --> 00:46:51,330
0,450 450,570 570,690 690,870 870,1230
runs,| you know it fetches
|它从不同的机器获取对象，在本地修改它们，

1354
00:46:51,330 --> 00:46:54,210
0,480 480,1080 1080,1380 1380,2130 2160,2880
objects from different machines, modifies

1355
00:46:54,210 --> 00:46:56,370
0,150 150,840 1020,1170 1170,1650 1650,2160
them locally,| and then in
|然后在提交阶段，应用更改，

1356
00:46:56,370 --> 00:46:58,770
0,180 180,510 510,1140 1260,1770 1770,2400
the commit phase, {} the

1357
00:46:58,890 --> 00:47:00,690
0,510 510,720 720,930 930,1470 1620,1800
changes are being applied,| and
|当然，这里的整个挑战是，

1358
00:47:00,690 --> 00:47:01,650
0,60 60,450 450,540 540,720 720,960
of course you know the

1359
00:47:01,650 --> 00:47:03,180
0,330 330,780 780,1170 1170,1320 1320,1530
whole challenge here is that,|
|

1360
00:47:03,180 --> 00:47:04,380
0,90 90,180 180,480 480,660 660,1200
in the end we want
最终，我们希望实现严格的可串行化。

1361
00:47:04,740 --> 00:47:07,080
0,420 420,1260 1350,1650 1650,1950 1950,2340
to achieve {} strict {serializability

1362
00:47:07,080 --> 00:47:07,920
0,480
-}.|
|

1363
00:47:08,830 --> 00:47:10,400
0,390

1364
00:47:17,470 --> 00:47:18,540
0,840

1365
00:47:18,740 --> 00:47:20,570
0,180 180,270 270,540 540,1140 1170,1830
And in some ways, {}
在某些方面，协议，

1366
00:47:20,600 --> 00:47:25,130
0,720 1860,3030 3810,4200 4200,4350 4350,4530
the protocol for,| at least
|至少写入的协议总是遵循非常类似的两阶段提交协议，

1367
00:47:25,130 --> 00:47:27,590
0,660 720,1200 1200,1800 1830,2160 2160,2460
writes always follows a very

1368
00:47:27,590 --> 00:47:29,150
0,540 540,660 660,900 900,1140 1140,1560
similar {two-phase -} commit protocols,|
|

1369
00:47:29,150 --> 00:47:29,810
0,150 150,300 300,510 510,570 570,660
that we've seen in the
这是我们过去看到的，

1370
00:47:29,810 --> 00:47:30,980
0,450 450,720 720,780 780,1110 1110,1170
past,| there are differences in
|在细节上有所不同，

1371
00:47:30,980 --> 00:47:32,570
0,90 90,750 900,1260 1260,1320 1320,1590
the details,| but the basic
|但基本策略是相同的，

1372
00:47:32,570 --> 00:47:34,610
0,420 420,570 570,630 630,1140 1380,2040
strategy is the same, {}|
|

1373
00:47:34,610 --> 00:47:35,780
0,390 390,510 510,690 690,1020 1020,1170
and you know we can
我们可以，

1374
00:47:35,780 --> 00:47:37,820
0,330 420,840 840,1170 1200,1380 1380,2040
{sort,of},| {} so let's assume
|我们假设我们已经完成了执行阶段，

1375
00:47:38,030 --> 00:47:39,020
0,390 390,540 540,660 660,870 870,990
that {you,know} we're done with

1376
00:47:39,020 --> 00:47:40,820
0,90 90,600 600,900 900,1200 1200,1800
the execution phase,| so we're
|所以我们在事务的末尾，

1377
00:47:40,910 --> 00:47:41,570
0,240 240,330 330,450 450,570 570,660
we're at the end of

1378
00:47:41,570 --> 00:47:43,010
0,90 90,690 690,870 900,990 990,1440
the transaction,| and the transaction
|事务将尝试提交，

1379
00:47:43,010 --> 00:47:43,550
0,60 60,180 180,240 240,420 420,540
is going to try to

1380
00:47:43,550 --> 00:47:44,080
0,390
commit,|
|

1381
00:47:44,250 --> 00:47:45,330
0,300 300,720 720,840 840,960 960,1080
that transaction that could be
事务可能会有两种结果，

1382
00:47:45,330 --> 00:47:46,560
0,180 180,660 660,750 750,870 870,1230
two outcomes,| you know actually
|成功提交或中止，

1383
00:47:46,560 --> 00:47:48,120
0,180 180,690 690,1020 1020,1260 1260,1560
{you,know} successfully commits or actually

1384
00:47:48,120 --> 00:47:48,900
0,570
aborts,|
|

1385
00:47:49,420 --> 00:47:51,130
0,480 600,930 930,1050 1050,1320 1320,1710
{} {and,the} {aborts -} because
中止是因为其他事务同时运行，

1386
00:47:51,130 --> 00:47:52,870
0,120 120,390 390,840 840,1050 1050,1740
some other transaction ran concurrently|
|

1387
00:47:52,990 --> 00:47:53,950
0,150 150,630 630,810 810,900 900,960
and modifies one of the
并且修改了其中一个对象，

1388
00:47:53,950 --> 00:47:55,480
0,450 450,870 870,990 990,1200 1200,1530
objects,| that we {} write
|我们写入或想要写入。

1389
00:47:55,480 --> 00:47:56,680
0,240 240,480 480,690 690,810 810,1200
or were trying to write.|
|

1390
00:47:57,640 --> 00:47:58,640
0,690

1391
00:47:59,190 --> 00:48:01,170
0,570 900,1140 1140,1260 1260,1500 1500,1980
And so the first thing,|
所以，第一件事，|

1392
00:48:01,170 --> 00:48:02,760
0,300 300,450 450,510 510,1140 1200,1590
that sort of protocol, the
协议的提交阶段有 5 个步骤，

1393
00:48:02,760 --> 00:48:04,650
0,270 270,690 690,1050 1050,1530 1560,1890
commit phase basically has 5

1394
00:48:04,650 --> 00:48:06,510
0,540 540,660 660,900 900,1200 1470,1860
steps,| you know the locking
|加锁步骤，验证步骤，

1395
00:48:06,510 --> 00:48:08,310
0,420 420,510 510,1050 1050,1680 1710,1800
step, the validation step,| the
|提交备份步骤，提交 primary 步骤，

1396
00:48:08,310 --> 00:48:09,810
0,240 240,600 600,1050 1050,1170 1170,1500
commit backup step, the commit

1397
00:48:09,810 --> 00:48:11,400
0,690 780,960 960,1110 1110,1290 1290,1590
primary| and then the truncate,|
|然后是截断，|

1398
00:48:11,400 --> 00:48:13,290
0,330 330,450 450,990 990,1320 1320,1890
and the truncate basically runs
截断运行得[很慢]，

1399
00:48:13,320 --> 00:48:16,200
0,930 930,1620 1650,1920 1920,2580 2580,2880
{} almost {} lazily| and
|所以这并不是很重要，

1400
00:48:16,200 --> 00:48:17,670
0,180 180,360 360,540 540,930 930,1470
so it's not particularly important,|
|

1401
00:48:17,880 --> 00:48:19,890
0,480 480,690 690,900 900,1440 1440,2010
basically for our perspective,| basically
从我们的角度来看，|有趣的事情停止的地方就是这里，

1402
00:48:19,950 --> 00:48:21,120
0,150 150,420 420,540 540,930 930,1170
the point of interest where

1403
00:48:21,120 --> 00:48:23,310
0,270 270,330 330,960 1260,1710 1710,2190
things are stopping is here,|
|

1404
00:48:23,370 --> 00:48:24,210
0,180 180,390 390,540 540,720 720,840
so that's sort of the
这就是事务的结束。

1405
00:48:24,210 --> 00:48:26,160
0,240 240,360 360,450 450,1200 1230,1950
end of the transaction is.|
|

1406
00:48:27,820 --> 00:48:28,920
0,300 300,780
Okay, so
好的，这些对象之前都说过，

1407
00:48:29,200 --> 00:48:30,490
0,510 570,720 720,810 810,960 960,1290
{} each of these objects

1408
00:48:30,490 --> 00:48:32,140
0,180 180,420 420,1050 1080,1200 1200,1650
have said before,| you know
|当你读到它们，有一个版本号，

1409
00:48:32,140 --> 00:48:33,070
0,180 180,300 300,480 480,720 720,930
when you read them has

1410
00:48:33,070 --> 00:48:34,510
0,30 30,360 360,510 510,1110 1110,1440
a {version,number},| {here's} a version
|这是一个版本号，

1411
00:48:34,510 --> 00:48:35,440
0,540
number,|
|

1412
00:48:37,290 --> 00:48:40,050
0,690 1200,1920 1950,2220 2220,2610 2610,2760
{} and {} there are
在本地修改它们，

1413
00:48:40,050 --> 00:48:41,700
0,690 690,810 810,1320 1320,1530 1530,1650
modifies it locally,| then at
|然后在这一点上，

1414
00:48:41,700 --> 00:48:42,570
0,90 90,360 360,450 450,780 780,870
the point of this,| you
|这是提交点，

1415
00:48:42,570 --> 00:48:43,710
0,90 90,390 390,600 600,960 960,1140
know when when this this

1416
00:48:43,710 --> 00:48:45,120
0,120 120,210 210,480 480,870 1230,1410
is the commit point,| where
|当应用调用结束事务时，

1417
00:48:45,120 --> 00:48:46,590
0,240 240,390 390,870 870,1230 1230,1470
when the application calls {end,of}

1418
00:48:46,590 --> 00:48:49,920
0,690 960,1080 1080,2220 2430,3150 3150,3330
transaction,| the {} protocol, but
|整个提交阶段协议才起作用。

1419
00:48:49,920 --> 00:48:51,960
0,150 150,660 780,1230 1230,1530 1530,2040
this whole commit phase protocol

1420
00:48:51,960 --> 00:48:52,720
0,330 330,510
kicks in.|
|

1421
00:48:53,550 --> 00:48:54,960
0,540 540,990 990,1110 1110,1200 1200,1410
{} And so the first
所以它做的第一件事是，

1422
00:48:54,960 --> 00:48:56,550
0,120 120,240 240,780 810,1260 1260,1590
thing it does {} is,|
|

1423
00:48:56,550 --> 00:48:58,020
0,180 180,450 450,600 600,960 960,1470
what's called the locking step,
所谓的锁步骤，步骤 1 ，

1424
00:48:58,050 --> 00:49:00,450
0,330 330,540 540,1020 1230,1890 2040,2400
step number 1,| and {the,goal}
|这一步的目标是，

1425
00:49:00,450 --> 00:49:01,470
0,420 420,540 540,720 720,960 960,1020
here, in this step is|
|

1426
00:49:01,470 --> 00:49:03,090
0,90 90,390 390,870 870,1410 1440,1620
to basically acquire locks on
获取正在写入的所有对象的锁，

1427
00:49:03,090 --> 00:49:04,710
0,210 210,360 360,1020 1050,1440 1440,1620
all the objects that are

1428
00:49:04,710 --> 00:49:05,600
0,270 270,660
being written,|
|

1429
00:49:06,110 --> 00:49:07,010
0,390 390,570 570,690 690,810 810,900
{} and so we can
所以我们可以看到，根据这张图，

1430
00:49:07,010 --> 00:49:08,030
0,360 360,510 510,780 780,870 870,1020
see {you,know} based on this

1431
00:49:08,030 --> 00:49:10,520
0,630 630,1020 1350,1890 1890,2100 2100,2490
diagram,| that apparently two objects
|显然有两个对象正在被写入，

1432
00:49:10,520 --> 00:49:13,880
0,930 960,1230 1230,1740 1770,2730 2730,3360
are being written,| namely {}
|即这个对象，

1433
00:49:14,580 --> 00:49:17,430
0,720 1080,1320 1320,2130 2130,2430 2430,2850
the this object,| because context
|因为上下文是分片 1 ，区域 1 ，

1434
00:49:17,430 --> 00:49:19,380
0,60 60,330 330,870 870,1380 1590,1950
is the primary of {}

1435
00:49:19,380 --> 00:49:21,090
0,270 270,630 630,930 930,1380 1530,1710
shard 1, region 1,| and
|然后这个对象被读取，

1436
00:49:21,090 --> 00:49:22,260
0,390 390,390 390,750 750,1080 1080,1170
then {} this object is

1437
00:49:22,260 --> 00:49:23,550
0,240 240,480 540,930 930,1170 1170,1290
being read,| {} that is
|它位于区域 2 ，

1438
00:49:23,550 --> 00:49:25,380
0,240 240,810 810,1290 1290,1590 1590,1830
actually located on region 2,

1439
00:49:25,770 --> 00:49:27,690
0,390 720,1230 1230,1350 1350,1590 1590,1920
right,| apparently the third object,
|显然，我们读取第三个对象是 primary 3 的，

1440
00:49:27,690 --> 00:49:28,650
0,120 120,240 240,570 630,810 810,960
that we read you know

1441
00:49:28,650 --> 00:49:31,530
0,300 300,690 690,1230 1590,2490 2640,2880
for primary 3,| {} it's
|它没有被写入，

1442
00:49:31,530 --> 00:49:33,870
0,510 510,660 660,900 900,1890 2040,2340
not {} {being,write},| {} because
|因为它不参与锁阶段。

1443
00:49:33,870 --> 00:49:35,280
0,240 240,570 570,1200 1200,1320 1320,1410
it doesn't participate in the

1444
00:49:35,280 --> 00:49:36,220
0,300 300,840
locking phase.|
|

1445
00:49:36,700 --> 00:49:38,560
0,630 780,930 930,1020 1020,1290 1290,1860
So in the locking phase,|
所以在锁阶段，|

1446
00:49:38,590 --> 00:49:39,840
0,1020

1447
00:49:40,400 --> 00:49:42,200
0,600 630,1080 1080,1350 1350,1590 1590,1800
the arrows actually have all
箭头有各种不同的含义。

1448
00:49:42,200 --> 00:49:43,820
0,210 210,390 390,660 660,1290 1410,1620
kinds of different meanings.| So
|所以这些虚线箭头是单面 RDMA ，

1449
00:49:43,820 --> 00:49:47,030
0,210 210,690 690,1590 2160,2880 2910,3210
these dashed arrows are {one-sided

1450
00:49:47,030 --> 00:49:48,860
0,330 330,840 840,1200
-} {RDMAs -},|
|

1451
00:49:57,100 --> 00:49:58,120
0,210 210,420 420,450 450,840 840,1020
so {those -} objects are
这些对象是使用 RDMA 读取的，

1452
00:49:58,120 --> 00:49:59,680
0,240 240,540 540,780 780,1410 1410,1560
being read with RDMA,| they're
|它们从远程内存位置获取，

1453
00:49:59,680 --> 00:50:01,240
0,210 210,630 630,900 900,960 960,1560
just fetched from the remote

1454
00:50:01,540 --> 00:50:04,510
0,600 600,1380 1440,2100 2100,2550 2550,2970
memory location,| {} and []
|[]本地到应用程序或协调者的内存。

1455
00:50:04,510 --> 00:50:06,340
0,480 480,540 540,690 690,1020 1020,1830
locally you know to the

1456
00:50:06,460 --> 00:50:07,840
0,180 180,240 240,540 540,690 690,1380
to the memory of the

1457
00:50:07,900 --> 00:50:09,640
0,810 810,1500
application {or,coordinator}.|
|

1458
00:50:10,050 --> 00:50:12,360
0,840 1170,2010

1459
00:50:12,810 --> 00:50:13,840
0,720

1460
00:50:14,620 --> 00:50:16,360
0,450 540,930 930,1200 1200,1470 1470,1740
The solid ones are write
实线的是写入 RDMA ，

1461
00:50:16,360 --> 00:50:17,400
0,120 120,480 480,810
{RDMAs - -},|
|

1462
00:50:17,960 --> 00:50:20,140
0,750 990,1710
and {}
在这个案例中，

1463
00:50:21,420 --> 00:50:22,830
0,150 150,240 240,390 390,750 750,1410
and in this particular case,|
|

1464
00:50:26,350 --> 00:50:29,170
0,240 240,870 960,1350 1350,2250 2370,2820
they depend on lock {}
它们依赖于主服务器的锁条目，

1465
00:50:29,170 --> 00:50:30,880
0,420 420,720 720,1380
entry to the,

1466
00:50:32,100 --> 00:50:34,020
0,270 270,930 1140,1740 1740,1830 1830,1920
to the log of the

1467
00:50:34,020 --> 00:50:35,250
0,480 480,720 720,810 810,1140 1140,1230
primary,| so the primary has
|所以主服务器有一个日志，

1468
00:50:35,250 --> 00:50:36,960
0,60 60,660 780,1200 1200,1560 1560,1710
a log,| every primary has
|每个主服务器都有一个日志，

1469
00:50:36,960 --> 00:50:38,160
0,30 30,540 570,720 720,1080 1080,1200
a log,| so I'm just
|所以我画成这样，

1470
00:50:38,160 --> 00:50:39,150
0,150 150,330 330,450 450,570 570,990
gonna draw it like this,|
|

1471
00:50:39,980 --> 00:50:42,830
0,390 390,1140 1350,1890 1890,2730 2730,2850
{} and {} actually use
使用不同的颜色，

1472
00:50:42,830 --> 00:50:44,570
0,60 60,270 270,750 1110,1380 1440,1740
a different color,| so here
|所以这里我们有 Pi 日志，

1473
00:50:44,570 --> 00:50:46,040
0,120 120,330 330,450 450,900 900,1470
we have the primary i

1474
00:50:46,070 --> 00:50:47,480
0,270 270,570 570,1140
with a log,|
|

1475
00:50:49,380 --> 00:50:52,770
0,540 540,1170 1380,1980 1980,2580 2880,3390
and basically {} the the
协调者，这是一个提交记录，

1476
00:50:54,460 --> 00:50:56,350
0,390 390,1140 1140,1440 1440,1800 1800,1890
the coordinator, {} it's a

1477
00:50:56,350 --> 00:50:57,440
0,300 300,750
commit record,|
|

1478
00:50:58,270 --> 00:50:59,290
0,180 180,330 330,540 540,630 630,1020
{} no, {sorry -}, sorry,
不是，抱歉，锁记录到日志中，

1479
00:50:59,470 --> 00:51:01,660
0,810 810,1200 1200,1410 1410,1890
lock record is called

1480
00:51:05,560 --> 00:51:07,540
0,540 540,900 900,1500 1530,1860 1860,1980
to the log,| I'm going
|我让它是一个大的记录，

1481
00:51:07,540 --> 00:51:08,050
0,60 60,180 180,270 270,300 300,510
to make it a big

1482
00:51:08,050 --> 00:51:09,400
0,390 390,540 540,720 810,1140 1140,1350
record,| I can write down
|我可以写下里面的东西，

1483
00:51:09,400 --> 00:51:11,020
0,180 180,300 300,510 930,1350 1350,1620
what's in it,| and it
|它是版本号，读写时间，

1484
00:51:11,020 --> 00:51:12,430
0,210 210,390 390,720 720,1170 1260,1410
is [] version number, {}

1485
00:51:12,430 --> 00:51:13,780
0,90 90,420 420,540 540,900 900,1350
the time of the {read,or,write}|
|

1486
00:51:13,780 --> 00:51:14,590
0,90 90,360 360,420 420,690 690,810
and when the object is
当对象被读取时，

1487
00:51:14,590 --> 00:51:15,790
0,300 300,420 420,600 600,900 900,1200
read,| so that version number
|版本号从这里出来，

1488
00:51:15,790 --> 00:51:17,100
0,180 180,420 420,570 570,960
that came out here,|
|

1489
00:51:18,690 --> 00:51:20,190
0,420 420,630 630,840 840,1110 1110,1500
{} that goes back into
回到日志记录中的，

1490
00:51:20,190 --> 00:51:22,140
0,270 270,570 570,1080 1260,1500 1500,1950
the log record,| the object
|读取的对象 id 和对象的新值，

1491
00:51:22,140 --> 00:51:24,900
0,570 600,900 900,1110 1110,1560 2160,2760
id that's being read and

1492
00:51:24,900 --> 00:51:25,800
0,90 90,270 270,690 690,810 810,900
the new value for the

1493
00:51:25,800 --> 00:51:27,380
0,690
object,|
|

1494
00:51:29,560 --> 00:51:31,150
0,420 420,870 900,1080 1080,1410 1410,1590
and so this record is
所以，这条记录追加到

1495
00:51:31,150 --> 00:51:34,210
0,330 360,840 840,1080 1170,2040 2220,3060
just {appended -} {you,know,to} the|
|

1496
00:51:34,690 --> 00:51:37,780
0,510 660,2130 2310,2760 2760,3000 3000,3090
you know primary 1 and
primary 1 和 primary 2 的日志，

1497
00:51:37,780 --> 00:51:41,080
0,330 330,1080 1320,1920 1920,2520 2700,3300
primary 2's {} log,| using
|使用写入 RDMA ，

1498
00:51:41,080 --> 00:51:42,880
0,540 570,930 930,1500
{} write RDMA.|
|

1499
00:51:43,360 --> 00:51:44,800
0,120 120,240 240,510 510,870 870,1440
And so there's some thread
所以这些机器上有一些线程，

1500
00:51:44,830 --> 00:51:46,990
0,390 390,600 600,1050 1050,1860 1950,2160
sitting on those machines,| that
|查看这些日志，然后执行一些操作，

1501
00:51:46,990 --> 00:51:48,040
0,240 240,300 300,570 570,960 960,1050
looks at these logs and

1502
00:51:48,040 --> 00:51:49,480
0,150 150,420 420,570 570,690 690,1440
then actually does some operations,|
|

1503
00:51:50,190 --> 00:51:51,390
0,390 390,630 630,750 750,870 870,1200
{} so in this particular
所以在这个案例中，

1504
00:51:51,390 --> 00:51:53,010
0,390 390,930 1020,1260 1260,1350 1350,1620
case,| if there's a thread
|有线程在 P1 P2 上，

1505
00:51:53,010 --> 00:51:55,080
0,300 300,870 1170,1530 1530,1860 1890,2070
sitting on { -} {P1

1506
00:51:55,080 --> 00:51:57,720
0,360 360,540 540,1170 1170,1860 1890,2640
-} and P2,| {you,know} monitors
|监控、旋转或轮询这个日志，

1507
00:51:57,720 --> 00:51:59,910
0,810 810,1080 1080,1260 1260,1710 1710,2190
or spins or polls this

1508
00:51:59,910 --> 00:52:01,470
0,600 780,1020 1020,1320 1320,1530 1530,1560
log,| and sees there's a
|看到有一个新的日志记录，

1509
00:52:01,470 --> 00:52:03,000
0,180 180,510 510,900 900,1080 1080,1530
new log record,| and then
|然后在这种情况下，它会做什么，

1510
00:52:03,180 --> 00:52:04,290
0,240 240,390 390,720 720,960 960,1110
in this particular case, what

1511
00:52:04,290 --> 00:52:05,190
0,90 90,240 240,660 720,810 810,900
it will do,| it will
|它将尝试获取对象的锁，

1512
00:52:05,190 --> 00:52:06,240
0,180 180,270 270,420 420,510 510,1050
try to get a lock

1513
00:52:06,240 --> 00:52:07,500
0,210 210,360 360,1020 1020,1110 1110,1260
on the object,| you know
|在事务中列出的，

1514
00:52:07,500 --> 00:52:09,630
0,270 270,780 780,960 960,1380 1380,2130
that actually is listed in

1515
00:52:09,990 --> 00:52:13,200
0,90 90,1560 2190,2460 2460,3030
the {} in the

1516
00:52:13,640 --> 00:52:15,740
0,600 810,1410 1410,1830 1830,2010 2010,2100
{} transaction,| somewhere, there's an
|在某个地方，有一个对象，

1517
00:52:15,740 --> 00:52:16,860
0,660
object,|
|

1518
00:52:18,300 --> 00:52:19,560
0,450 450,540 540,720 720,1140 1140,1260
and that object have some
对象中包含一些数据，

1519
00:52:19,560 --> 00:52:20,520
0,270 270,420 420,750 750,840 840,960
data in it| and it
|它里面有这些锁位和版本号。

1520
00:52:20,520 --> 00:52:21,960
0,210 210,450 450,750 750,1200 1200,1440
has these lock bit and

1521
00:52:21,960 --> 00:52:23,560
0,300 300,660 660,750 750,900
version number in it.|
|

1522
00:52:25,240 --> 00:52:26,950
0,240 240,510 510,660 660,1290 1290,1710
And so {P1 -} has
所以 P1 有一个对象，

1523
00:52:26,950 --> 00:52:28,240
0,210 210,780 780,840 840,960 960,1290
one object,| you know that
|这是由协调者修改的，

1524
00:52:28,240 --> 00:52:31,420
0,120 120,600 930,2010 2010,2280 2280,3180
is being modified by {}

1525
00:52:31,690 --> 00:52:33,700
0,750 750,1140 1140,1320 1320,1620 1620,2010
coordinator,| P2 has another object,
|P2 有另一个对象，由协调者修改，

1526
00:52:33,700 --> 00:52:34,570
0,120 120,210 210,660 660,780 780,870
that is modified by the

1527
00:52:34,570 --> 00:52:38,350
0,720 1050,1380 1380,2100 2190,3120 3180,3780
coordinator,| and basically the, {}
|primary 尝试获取对象的锁，

1528
00:52:38,590 --> 00:52:39,820
0,360 360,810 810,1080 1080,1140 1140,1230
the primary tries to be

1529
00:52:39,820 --> 00:52:41,860
0,390 390,480 480,900 930,1380 1380,2040
required the lock on the,

1530
00:52:43,840 --> 00:52:44,920
0,240 240,360 360,750 750,990 990,1080
on the object,| using {}
|使用 test-and-set 指令，

1531
00:52:44,920 --> 00:52:46,020
0,180 180,270 270,420 420,930
{test-and-set - -} instruction.|
|

1532
00:52:46,540 --> 00:52:48,340
0,270 270,780 870,1170 1170,1380 1380,1800
And so {} it will
所以，它将尝试设置锁位，

1533
00:52:48,340 --> 00:52:49,720
0,240 240,390 390,750 750,870 870,1380
try to {set,lock} {} bit,|
|

1534
00:52:52,050 --> 00:52:53,250
0,540 540,630 630,720 720,930 930,1200
{} { -} using {test-and-set -
使用 test-and-set 指令，

1535
00:52:53,250 --> 00:52:54,900
0,180 180,840 1050,1440 1440,1560 1560,1650
-} instruction,| and if the
|如果锁位为 0 ，

1536
00:52:54,900 --> 00:52:57,930
0,240 240,450 450,570 570,1230 1470,3030
lock bit is 0, {}|
|

1537
00:52:57,930 --> 00:53:01,440
0,960 1050,2070 2250,2580 2580,3090 3090,3510
and { -} and the
锁位是 0 ，

1538
00:53:01,950 --> 00:53:03,900
0,300 300,570 570,1080 1080,1470 1470,1950
lock {bit,is} 0| and successfully
|并成功地将位设置为 1 ，

1539
00:53:03,900 --> 00:53:04,920
0,180 180,270 270,450 450,540 540,1020
set the bit to 1,|
|

1540
00:53:05,190 --> 00:53:06,630
0,360 360,570 570,660 660,1110 1110,1440
{} then it knows that,
然后 primary 知道获取了锁，

1541
00:53:06,630 --> 00:53:09,330
0,570 900,1590 1710,2190 2190,2430 2430,2700
the {} {primary -} knows

1542
00:53:09,330 --> 00:53:10,680
0,180 180,450 450,780 780,870 870,1350
that actually acquire the lock,|
|

1543
00:53:10,830 --> 00:53:12,690
0,150 150,690 750,960 960,1590 1710,1860
and {in,that} {} case and
在这种情况下，我们将发回一条 RDMA 消息，

1544
00:53:12,690 --> 00:53:14,490
0,120 120,360 360,720 720,1440 1440,1800
we'll send one RDMA message

1545
00:53:14,490 --> 00:53:16,110
0,480 510,750 750,1080 1080,1470 1470,1620
back,| {} to append a
|将消息附加到协调者的消息队列，

1546
00:53:16,110 --> 00:53:18,600
0,480 480,900 900,1230 1290,2160 2160,2490
message to the coordinator's message

1547
00:53:18,600 --> 00:53:19,860
0,300 300,630 630,1110
queue,| saying okay,
|说好的，你成功地获得了这些对象的锁。

1548
00:53:21,280 --> 00:53:23,290
0,330 330,840 840,1260 1260,1770 1830,2010
you successfully acquired {locks -}

1549
00:53:23,290 --> 00:53:24,960
0,120 120,300 300,690 690,1230
for these particular objects.|
|

1550
00:53:26,060 --> 00:53:28,260
0,510 510,1140 1170,1890
If the transaction,
如果锁已经被另一个事务获取，

1551
00:53:28,460 --> 00:53:30,320
0,630 630,1020 1020,1470 1470,1770 1770,1860
{} if the lock was

1552
00:53:30,320 --> 00:53:32,420
0,240 240,780 810,1080 1080,1380 1380,2100
already taken by another transaction,|
|

1553
00:53:32,750 --> 00:53:34,160
0,300 300,630 630,750 750,930 930,1410
and then at that point
然后在那个时间点，

1554
00:53:34,160 --> 00:53:35,900
0,60 60,390 390,510 510,1050 1050,1740
in time,| the transaction is
|事务被中止，

1555
00:53:35,900 --> 00:53:38,150
0,420 600,990 990,1260 1260,1650 1920,2250
aborted,| {} and so {}
|所以当 primary i 试图获取锁的时候，

1556
00:53:38,150 --> 00:53:39,500
0,150 150,300 300,390 390,840 840,1350
so when the primary i

1557
00:53:39,650 --> 00:53:40,910
0,420 420,510 510,660 660,750 750,1260
tries to get the lock,|
|

1558
00:53:40,940 --> 00:53:41,870
0,330 330,450 450,540 540,630 630,930
finds out that the {lock,is}
发现锁已经设置好了，

1559
00:53:41,870 --> 00:53:43,850
0,300 300,780 930,1320 1320,1560 1560,1980
already set,| {} using {test-and
|使用 test-and-set 指令，

1560
00:53:43,850 --> 00:53:46,340
0,180 180,840 930,1770 1800,2250 2250,2490
-} instruction,| then, {} that
|然后试着获取锁会失败，

1561
00:53:46,340 --> 00:53:48,620
0,420 780,1290 1290,1590 1590,1710 1710,2280
lock, {so,the,try} lock will fail,|
|

1562
00:53:51,060 --> 00:53:54,810
0,750 780,1470 1500,2220 2700,3210 3210,3750
and {} the {} the
primary 将添加一条消息

1563
00:53:55,020 --> 00:53:56,820
0,450 450,720 720,1020 1020,1440 1440,1800
primary will add a message|
|

1564
00:53:56,820 --> 00:53:58,830
0,270 270,690 990,1440 1440,1650 1650,2010
to the queue of the
到协调者的队列中，

1565
00:53:58,890 --> 00:54:01,350
0,1170 1170,1320 1320,1470 1470,1680 1680,2460
{to,the} queue of the coordinator,|
|

1566
00:54:01,380 --> 00:54:02,610
0,300 300,540 540,990 990,1080 1080,1230
saying, like I you know
说，我不能获取锁，

1567
00:54:02,610 --> 00:54:03,780
0,330 360,570 570,750 750,1110 1110,1170
I could not acquire the

1568
00:54:03,780 --> 00:54:05,850
0,570 750,1320 1320,1530 1530,1980 1980,2070
locks,| and the coordinator in
|在这种情况下，协调者将中止事务。

1569
00:54:05,850 --> 00:54:07,350
0,180 180,450 450,630 630,1140 1140,1500
that case will abort {transactions

1570
00:54:07,350 --> 00:54:08,000
0,540
-}.|
|

1571
00:54:10,060 --> 00:54:11,560
0,270 270,570 570,750 750,1200
Any questions so far?|
到目前为止，还有什么问题吗？|

1572
00:54:13,040 --> 00:54:14,360
0,510 510,660 660,1020 1050,1170 1170,1320
How are the are the
这些锁是如何获取的，通过 zookeeper 吗？

1573
00:54:14,360 --> 00:54:15,410
0,270 270,360 360,630 630,840 840,1050
locks {obtained -}, through {zookeeper

1574
00:54:15,410 --> 00:54:16,320
0,630
-}?|
|

1575
00:54:16,600 --> 00:54:18,640
0,450 450,660 660,1680 1680,1830 1830,2040
No, these are the other
不，是另一套锁使用 zookeeper ，

1576
00:54:18,640 --> 00:54:19,990
0,180 180,240 240,600 600,840 840,1350
set of locks using zookeeper,|
|

1577
00:54:19,990 --> 00:54:21,610
0,240 240,420 420,570 570,1140 1140,1620
that's really for configuration management,|
是为了进行配置管理，|

1578
00:54:21,610 --> 00:54:25,090
0,510 870,1620 1770,2430 2430,2790 2790,3480
like the mapping of {
比如区域编号到 primary 和 backup 的映射，

1579
00:54:25,610 --> 00:54:27,860
0,810 840,1170 1170,1440 1440,1860 1860,2250
-} region number to {}

1580
00:54:27,860 --> 00:54:29,420
0,540 540,780 780,930 930,1320 1320,1560
primary and {} {backups -},|
|

1581
00:54:29,480 --> 00:54:30,410
0,210 210,450 450,600 600,780 780,930
{} these are just in
这些只是内存锁，由 primary 维护，

1582
00:54:30,410 --> 00:54:33,530
0,360 360,900 990,1470 1470,1800 1800,3120
memory locks, {} that the

1583
00:54:33,560 --> 00:54:35,390
0,450 450,990 990,1320 1320,1470 1470,1830
primary maintains,| so in the
|所以在地址空间中，

1584
00:54:35,450 --> 00:54:37,190
0,450 450,870 870,1080 1080,1530 1530,1740
address space,| a little bit
|稍微向后一点，

1585
00:54:37,220 --> 00:54:39,440
0,660 660,1110 1470,1740 1740,2040 2040,2220
back, correct,| {} little,bit back
|回到这张图片上，

1586
00:54:39,440 --> 00:54:40,880
0,60 60,210 210,870 1020,1290 1290,1440
at this picture,| {} there
|有一个区域有对象，

1587
00:54:40,880 --> 00:54:42,680
0,150 150,480 510,930 930,1110 1110,1800
was a region has objects,|
|

1588
00:54:42,710 --> 00:54:44,300
0,300 300,720 720,1140 1140,1290 1290,1590
every object has some data
每个对象都有一些数据和头部，

1589
00:54:44,300 --> 00:54:46,610
0,570 570,1080 1080,1650 1860,2040 2040,2310
and a header,| and {in,that}
|在那个头部中，有一个 64 位编号，

1590
00:54:46,610 --> 00:54:48,710
0,390 390,660 660,1320 1320,1440 1470,2100
header, there's basically a 64

1591
00:54:48,710 --> 00:54:50,510
0,180 180,780 1020,1320 1320,1620 1620,1800
bit number,| {} that were
|最高位是锁位，

1592
00:54:50,510 --> 00:54:51,770
0,210 210,300 300,450 450,780 780,1260
{top-level - -} bit is

1593
00:54:51,770 --> 00:54:53,930
0,180 180,450 450,810 810,1470 1560,2160
the lock bit,| and 63
|其他 63 位是版本编号。

1594
00:54:53,930 --> 00:54:55,310
0,210 210,450 450,690 690,1080 1080,1380
other bits for {the,version} number.|
|

1595
00:54:56,010 --> 00:54:57,870
0,240 240,600 600,810 810,1050 1050,1860
Oh, what if the primary
哦，如果 primary 停机怎么办，

1596
00:54:57,870 --> 00:54:59,070
0,300 300,600 600,720 720,810 810,1200
goes down,| does the backup
|backup 是否有与 primary 相同的锁？

1597
00:54:59,070 --> 00:54:59,970
0,150 150,240 240,510 510,840 840,900
have the same locks of

1598
00:54:59,970 --> 00:55:01,380
0,150 150,780 810,1110
the primary? {}|
|

1599
00:55:01,780 --> 00:55:03,160
0,210 210,420 420,780 780,990 990,1380
If the primary goes down,|
如果 primary 停机，|

1600
00:55:03,160 --> 00:55:05,500
0,90 90,840 840,1560 1680,2160 2160,2340
the whole, {} what's gonna
接下来会发生的是，

1601
00:55:05,500 --> 00:55:06,640
0,330 330,690 690,900 900,1080 1080,1140
happen is that,| there's a
|有一个完整的重新配置协议，

1602
00:55:06,640 --> 00:55:09,190
0,210 210,1080 1110,1620 1650,2010 2010,2550
whole reconfiguration protocol,| {} happening
|在一个新的恢复协议中，

1603
00:55:09,190 --> 00:55:11,360
0,510 540,960 960,1410 1410,1920
in new recovery protocol,|
|

1604
00:55:11,780 --> 00:55:12,830
0,300 300,480 480,690 690,960 960,1050
{} the end result of
其最终结果是，

1605
00:55:12,830 --> 00:55:13,820
0,270 270,480 480,720 720,810 810,990
that is that,| in this
|在这种情况下，我们希望事务会中止，

1606
00:55:13,820 --> 00:55:15,680
0,420 420,870 900,1260 1290,1440 1440,1860
case, the, we we hope

1607
00:55:15,680 --> 00:55:16,400
0,150 150,330 330,540 540,660 660,720
that {transaction -} would be

1608
00:55:16,400 --> 00:55:17,990
0,480 480,750 750,1020 1020,1110 1110,1590
abort, correct,| because it never
|因为它不会到达最后。

1609
00:55:18,050 --> 00:55:18,920
0,270 270,390 390,450 450,600 600,870
made it to the end.|
|

1610
00:55:19,720 --> 00:55:21,250
0,270 270,780 780,960 960,1080 1080,1530
{} We'll get to {fault,tolerance}
我们稍后会讨论容错，

1611
00:55:21,250 --> 00:55:22,240
0,360 360,390 390,630 630,900 900,990
in a little while,| so
|所以让我们来，

1612
00:55:22,240 --> 00:55:24,670
0,210 420,720 720,1170 1350,2130 2130,2430
let's [] for,| {} I'm
|我会再讨论几个白板，

1613
00:55:24,670 --> 00:55:25,540
0,210 210,390 390,600 600,780 780,870
going to talk about in

1614
00:55:25,540 --> 00:55:26,560
0,60 60,270 270,750 750,840 840,1020
a couple boards,| and I'll
|我会谈到容错。

1615
00:55:26,560 --> 00:55:27,970
0,150 150,330 330,480 480,1020 1170,1410
talk about fault tolerance.| Thank
|谢谢。

1616
00:55:27,970 --> 00:55:28,480
0,180
you.|
|

1617
00:55:31,210 --> 00:55:33,340
0,480 480,930 930,1350 1350,1680 1680,2130
{} So the version number
所以版本号是每个对象的，对吧？

1618
00:55:33,340 --> 00:55:35,740
0,240 240,450 450,840 840,1230 1920,2400
are per object, right?| {Sure\,,per,object},
|当然，每个对象的，是的。

1619
00:55:35,920 --> 00:55:37,020
0,810
yeah.|
|

1620
00:55:38,620 --> 00:55:39,580
0,630
[].|
[]。|

1621
00:55:42,080 --> 00:55:43,180
0,420 420,780
Okay, good,
好的，那么，好的。

1622
00:55:43,460 --> 00:55:45,220
0,660 810,1440
so, {}

1623
00:55:45,850 --> 00:55:48,670
0,330 330,510 510,720 720,1350 2280,2820
alright.| {Can,I} {ask,a} question,| why
|我能问个问题吗，|为什么他们选择中止事务，

1624
00:55:48,670 --> 00:55:50,200
0,150 150,300 300,840 840,1080 1110,1530
do they choose to abort

1625
00:55:50,200 --> 00:55:51,760
0,60 60,660 660,900 900,1050 1050,1560
the transaction| rather than blocking
|而不是阻塞并等待锁被释放？

1626
00:55:51,760 --> 00:55:52,780
0,180 180,510 510,660 660,780 780,1020
and waiting for the lock

1627
00:55:52,780 --> 00:55:53,900
0,120 120,270 270,900
to be released?|
|

1628
00:55:54,660 --> 00:55:55,860
0,330 330,570 570,690 690,840 840,1200
{} Because they have read
因为它们读到了旧的[材料]，

1629
00:55:55,860 --> 00:55:57,460
0,720 720,1230
old [material],|
|

1630
00:55:57,920 --> 00:55:58,670
0,150 150,270 270,510 510,660 660,750
they have not read the
它们没有读到最新的值，

1631
00:55:58,670 --> 00:56:01,430
0,360 360,810 840,1710 1740,2280 2520,2760
latest material {} value,| and
|所以，事务必须中止。

1632
00:56:01,430 --> 00:56:03,080
0,300 300,990 990,1320 1320,1560 1560,1650
so the transaction has to

1633
00:56:03,080 --> 00:56:03,780
0,420
abort.|
|

1634
00:56:04,940 --> 00:56:05,930
0,150 150,270 270,570 570,870 870,990
Oh I see,| because the
哦，我明白了，|因为锁意味着下一次它会改变。

1635
00:56:05,930 --> 00:56:07,010
0,330 330,630 630,780 780,900 900,1080
lock means that it's gonna

1636
00:56:07,010 --> 00:56:09,290
0,720 990,1440 1440,1770 1800,2040 2040,2280
change next time.| Well, they
|好的，它们在写完对象后才要求加锁，

1637
00:56:09,290 --> 00:56:11,300
0,510 510,660 660,1140 1140,1680 1680,2010
ask for locks after really

1638
00:56:11,300 --> 00:56:12,600
0,360 360,480 480,1050
written the object,

1639
00:56:12,880 --> 00:56:15,490
0,480 690,1110 1140,1530 1530,2070 2070,2610
right,| so the coordinator modifies
|协调者基于某个版本号修改对象，

1640
00:56:15,490 --> 00:56:16,480
0,90 90,510 510,780 780,870 870,990
the object based on some

1641
00:56:16,480 --> 00:56:18,670
0,300 300,810 1170,1620 1620,2100 2100,2190
version number,| {} submits a
|提交了一些写入，

1642
00:56:18,670 --> 00:56:20,830
0,210 210,300 300,900 1170,1980 1980,2160
bunch of writes,| assuming that
|假设写入最新的版本号，

1643
00:56:20,830 --> 00:56:23,170
0,120 120,840 840,1140 1140,1590 1950,2340
is {write,the,latest} version number,| and
|这个时刻，提交开始，

1644
00:56:23,170 --> 00:56:25,030
0,150 150,270 270,360 360,1050 1050,1860
so by the time {}

1645
00:56:25,060 --> 00:56:28,390
0,1350 1620,2130 2160,2520 2520,2850 2850,3330
the the commit starts happening,|
|

1646
00:56:28,390 --> 00:56:29,080
0,150 150,270 270,450 450,540 540,690
and you try to get
然后你试图获取锁，

1647
00:56:29,080 --> 00:56:30,700
0,90 90,660 900,1140 1140,1320 1320,1620
the locks,| and you discover
|你发现另一个已经获取了锁，

1648
00:56:30,700 --> 00:56:31,720
0,90 90,390 390,600 600,750 750,1020
that somebody else is locked,|
|

1649
00:56:31,720 --> 00:56:32,620
0,90 90,270 270,510 510,690 690,900
that means somebody else already
这意味着其他人已经修改它了，

1650
00:56:32,620 --> 00:56:34,660
0,510 510,690 990,1590 1590,1800 1800,2040
modifying it,| and so that
|所以这会违反串行化。

1651
00:56:34,660 --> 00:56:36,610
0,150 150,600 600,720 720,1260 1530,1950
would violate {serialization -}, right.|
|

1652
00:56:37,820 --> 00:56:39,380
0,300 330,510 510,1020 1290,1470 1470,1560
Yep, thank you.| So, in
是的，谢谢。|所以，你在这里得到锁的时候，

1653
00:56:39,380 --> 00:56:40,370
0,330 330,480 480,780 780,870 870,990
fact the point you get

1654
00:56:40,370 --> 00:56:42,230
0,90 90,480 480,1050 1410,1740 1740,1860
the lock here,| that's sort
|这在某种程度上是写事务的串行化点，

1655
00:56:42,230 --> 00:56:43,580
0,90 90,180 180,930 930,1200 1200,1350
of the serialization point for

1656
00:56:43,580 --> 00:56:44,780
0,210 210,870
write transactions,|
|

1657
00:56:45,700 --> 00:56:47,440
0,150 150,720 720,1260 1320,1590 1590,1740
at this point, {} the
在这个点，事务已经获取了所有锁，

1658
00:56:47,440 --> 00:56:48,790
0,420 420,540 540,1020 1020,1230 1230,1350
transaction has acquired all the

1659
00:56:48,790 --> 00:56:50,110
0,420 420,660 660,810 810,900 900,1320
locks,| for all the objects
|对于所有被修改的对象，

1660
00:56:50,110 --> 00:56:52,240
0,180 180,840 1050,1440 1440,1830 1830,2130
is modified,| so nobody else
|在这个时间点上，其他人都不能修改，

1661
00:56:52,240 --> 00:56:53,770
0,120 120,390 390,840 870,1440 1440,1530
can actually {} modify in

1662
00:56:53,770 --> 00:56:55,120
0,180 180,660 660,840 840,900 900,1350
this particular point of time,|
|

1663
00:56:55,300 --> 00:56:56,020
0,210 210,420 420,540 540,630 630,720
so that's sort of the
这在某种程度上是事务的写入部分的串行化点。

1664
00:56:56,020 --> 00:56:57,790
0,750 750,1110 1110,1410 1410,1560 1560,1770
serialization point for the write

1665
00:56:57,790 --> 00:56:58,940
0,210 210,300 300,390 390,870
part of the transaction.|
|

1666
00:57:02,180 --> 00:57:03,060
0,180 180,510
Make sense?|
能理解吗?|

1667
00:57:04,480 --> 00:57:05,760
0,390 390,630 630,900
Yes, thank you.|
是的，谢谢。|

1668
00:57:07,060 --> 00:57:09,850
0,420 720,990 990,1170 1170,1800 2100,2790
Good okay, so now, {}
好的，现在你可能会觉得，

1669
00:57:09,880 --> 00:57:10,780
0,150 150,300 300,390 390,690 690,900
you might have felt like,|
|

1670
00:57:10,780 --> 00:57:12,610
0,1110 1140,1410 1410,1590 1590,1710 1710,1830
{} why not do the
为什么不对读取做同样的事情，

1671
00:57:12,610 --> 00:57:14,440
0,240 240,540 540,870 870,1350 1380,1830
same thing for read, correct,|
|

1672
00:57:14,440 --> 00:57:15,430
0,270 270,450 450,600 600,690 690,990
and {you,know} get the lock
获取读取对象的锁，

1673
00:57:15,430 --> 00:57:17,260
0,120 120,210 210,600 600,1140 1140,1830
for the read objects, {}|
|

1674
00:57:17,260 --> 00:57:18,160
0,210 210,270 270,510 510,750 750,900
get the lock from the
从读取的对象中获取锁，

1675
00:57:18,160 --> 00:57:19,540
0,420 420,660 660,1050 1050,1170 1170,1380
objects that read,| {you,know} check
|检查版本号[]。

1676
00:57:19,540 --> 00:57:20,530
0,60 60,330 330,600 600,810 810,990
the version number in {you,know}

1677
00:57:20,530 --> 00:57:21,500
0,60 60,210 210,690
in good [].|
|

1678
00:57:21,860 --> 00:57:24,380
0,810 870,1020 1020,1620 1620,2160 2190,2520
And the reason that that
原因是这是一个独立的阶段，

1679
00:57:24,380 --> 00:57:25,700
0,90 90,420 420,510 510,900 900,1320
is actually a separate phase,|
|

1680
00:57:25,700 --> 00:57:28,100
0,300 300,390 390,900 900,1410 1830,2400
namely the validation phase| is
即验证阶段，|是为了避免这些昂贵的写入 RDMA ，

1681
00:57:28,100 --> 00:57:30,470
0,540 540,900 900,1380 1380,1560 1560,2370
to basically avoid these expensive

1682
00:57:30,470 --> 00:57:32,420
0,270 270,720 720,930 960,1530 1800,1950
write {RDMAs -}, right,| if
|如果你看这个竖直的步骤，

1683
00:57:32,420 --> 00:57:33,320
0,120 120,270 270,360 360,510 510,900
you look at this vertical

1684
00:57:33,320 --> 00:57:34,400
0,390 390,540 540,720 720,960 960,1080
step,| you'll see there's a
|你将看到有一个写入 RDMA ，

1685
00:57:34,400 --> 00:57:36,260
0,210 210,810 990,1200 1200,1530 1530,1860
write RDMA,| the server has
|服务器必须运行一些东西，

1686
00:57:36,260 --> 00:57:38,480
0,210 240,600 600,1140 1170,1860 1860,2220
to run something,| basically does
|基本上是获取锁，

1687
00:57:38,480 --> 00:57:40,730
0,570 570,1110 1110,1200 1200,1710 2100,2250
{} acquiring the locks,| and
|然后用另一个写入 RDMA 进行响应。

1688
00:57:40,730 --> 00:57:42,110
0,210 210,630 630,780 780,1140 1140,1380
then responds with another write

1689
00:57:42,110 --> 00:57:43,610
0,450 450,570 570,1050 1050,1410 1410,1500
RDMA.| So here this is
|所以这是一个完整的 RPC ，

1690
00:57:43,610 --> 00:57:45,120
0,120 120,510 510,1230
a full RPC,|
|

1691
00:57:46,480 --> 00:57:48,610
0,240 240,450 450,1050 1050,1350 1350,2130
that actually requires server participation,|
需要服务器的参与，|

1692
00:57:49,360 --> 00:57:50,230
0,270 270,420 420,540 540,780 780,870
and as we'll see in
正如我们稍后将看到的，

1693
00:57:50,230 --> 00:57:52,630
0,30 30,510 750,1170 1170,1770 2190,2400
a second,| in the, to
|为了处理对象已被读取，

1694
00:57:52,630 --> 00:57:54,520
0,510 510,810 810,1290 1410,1620 1620,1890
handle the read the objects

1695
00:57:54,520 --> 00:57:57,190
0,180 180,390 390,780 1050,1830 1890,2670
have been read,| {} the
|FaRM 使用这个校验步骤，

1696
00:57:57,250 --> 00:57:59,410
0,300 510,900 1050,1770 1770,2010 2010,2160
the the FaRM uses this

1697
00:57:59,410 --> 00:58:00,820
0,480 480,750 750,840 840,930 930,1410
validation step,| in the validation
|在验证步骤中，仅使用了单边 RDMA ，

1698
00:58:00,820 --> 00:58:02,920
0,390 420,780 780,1110 1110,1650 1650,2100
step, just used one-sided {RDMAs

1699
00:58:02,920 --> 00:58:04,690
0,390 540,810 810,930 930,1170 1170,1770
-},| and so there's no
|所以，不需要真正的服务器参与。

1700
00:58:04,690 --> 00:58:06,480
0,270 270,630 630,1080 1080,1650
real server involvement necessary.|
|

1701
00:58:12,080 --> 00:58:12,920
0,570
Okay?|
好的?|

1702
00:58:13,900 --> 00:58:15,760
0,510 510,1140 1170,1410 1410,1680 1680,1860
So, {} what happens on
所以，发生了什么，

1703
00:58:15,760 --> 00:58:17,020
0,300 300,540 600,1050 1050,1110 1110,1260
the,| so basically at this
|所以我们在这一点上，

1704
00:58:17,020 --> 00:58:19,150
0,450 450,900 930,1410 1410,1590 1590,2130
point, the where we here,|
|

1705
00:58:19,150 --> 00:58:20,920
0,90 90,510 510,1080 1080,1350 1350,1770
the transaction coordinator actually has
事务协调者具有写锁，

1706
00:58:20,920 --> 00:58:23,200
0,420 750,1140 1140,1740 1950,2130 2130,2280
the write locks,| and now
|现在它唯一做的就是，

1707
00:58:23,200 --> 00:58:24,010
0,90 90,330 330,450 450,540 540,810
the only thing it does

1708
00:58:24,010 --> 00:58:25,510
0,60 60,360 360,1080 1080,1290 1290,1500
is,| it validates the read
|它验证读锁或读版本号，

1709
00:58:25,510 --> 00:58:27,280
0,510 510,660 660,1050 1050,1470 1470,1770
locks or basically read version

1710
00:58:27,280 --> 00:58:27,980
0,540
numbers,|
|

1711
00:58:28,480 --> 00:58:30,730
0,390 390,960 1020,1470 1530,2010 2040,2250
and so it {} for
所以，对于每个已读取但未修改的对象，

1712
00:58:30,730 --> 00:58:32,140
0,540 540,900 900,1020 1020,1140 1140,1410
every object that is read

1713
00:58:32,140 --> 00:58:33,460
0,120 120,330 330,930 990,1200 1200,1320
but not modified,| so in
|在我们的示例中，

1714
00:58:33,460 --> 00:58:34,840
0,270 270,600 600,960 960,1170 1170,1380
our particular example,| that's only
|只有一个对象，

1715
00:58:34,840 --> 00:58:35,980
0,240 240,870 870,990 990,1050 1050,1140
one object,| this is the
|这是那个被读取的，

1716
00:58:35,980 --> 00:58:37,240
0,210 210,360 360,690 690,900 900,1260
one that actually being read,|
|

1717
00:58:37,880 --> 00:58:38,800
0,630
{the,one}
区域 3 的那个，

1718
00:58:39,580 --> 00:58:42,010
0,330 330,630 630,1110 1440,2010 2010,2430
at region 3,| {} so
|所以它是单边 RDMA 读取版本编号，

1719
00:58:42,010 --> 00:58:43,510
0,480 480,990 990,1080 1080,1440 1440,1500
it's, {} it basically is

1720
00:58:43,510 --> 00:58:45,880
0,120 120,870 870,1590 1620,1800 1800,2370
{} one-sided RDMA to read

1721
00:58:45,940 --> 00:58:47,500
0,210 210,570 570,870 870,1050 1050,1560
the version number,| that 64
|那个正在读取的对象的 64 位编号。

1722
00:58:47,500 --> 00:58:49,960
0,360 390,1290 1560,2040 2040,2100 2100,2460
bit number for the object

1723
00:58:49,960 --> 00:58:50,860
0,90 90,270 270,660
is being read.|
|

1724
00:58:51,770 --> 00:58:53,180
0,300 300,480 480,570 570,780 780,1410
And when it gets back,
当它回来这里的时候，

1725
00:58:53,570 --> 00:58:54,920
0,510 510,750 750,810 810,1020 1020,1350
{} when it gets back

1726
00:58:54,920 --> 00:58:56,660
0,480 780,990 990,1320 1320,1560 1560,1740
here,| {} it checks two
|它检查两件事，

1727
00:58:56,660 --> 00:58:57,440
0,540
things,|
|

1728
00:58:57,660 --> 00:58:59,310
0,690 990,1170 1170,1290 1290,1530 1530,1650
{} if the lock is
如果锁被获取，锁位被设置，

1729
00:58:59,310 --> 00:59:00,720
0,540 720,780 780,990 990,1230 1230,1410
taken, so the lock bit

1730
00:59:00,720 --> 00:59:02,100
0,480 540,750 750,1080 1080,1200 1200,1380
set,| that means that some
|这意味着一些并发事务正在试图修改，

1731
00:59:02,100 --> 00:59:04,500
0,600 600,1170 1170,1500 1500,2070 2070,2400
{coordinator -} concurrent transactions {is,being},

1732
00:59:04,500 --> 00:59:05,790
0,330 330,570 570,660 660,1080 1080,1290
is trying to {modified -},|
|

1733
00:59:06,090 --> 00:59:07,710
0,240 240,450 450,840 840,1080 1080,1620
so that point just abort,|
所以在这一点上，就中止，|

1734
00:59:08,260 --> 00:59:09,670
0,690 690,960 960,1080 1080,1170 1170,1410
{} and so the {all,the}
所有事务再次中止，

1735
00:59:09,670 --> 00:59:10,920
0,390 390,630 630,870
transaction abort again,|
|

1736
00:59:11,540 --> 00:59:12,770
0,570 570,690 690,930 930,1170 1170,1230
if the first number is
如果第一个数字是[相同的]且未锁定，

1737
00:59:12,770 --> 00:59:15,710
0,720 1140,1800 1830,2100 2100,2460 2460,2940
identical and it's not locked,|
|

1738
00:59:15,830 --> 00:59:17,090
0,270 270,570 570,750 750,1080 1080,1260
that means that no other
这意味着在此特定时间点没有使用其他事务，

1739
00:59:17,090 --> 00:59:18,620
0,600 600,930 930,1080 1080,1230 1230,1530
transactions using at this particular

1740
00:59:18,620 --> 00:59:20,930
0,180 180,240 240,750 990,1740 1860,2310
point of time,| and {}
|事务可以继续进行，

1741
00:59:20,930 --> 00:59:23,960
0,780 990,1770 1800,2370 2370,2520 2520,3030
the {} transaction could proceed,|
|

1742
00:59:23,990 --> 00:59:26,030
0,810 840,1230 1230,1350 1350,1860 1860,2040
basically all the objects that
所有读取和修改的对象，

1743
00:59:26,030 --> 00:59:27,260
0,60 60,330 330,510 510,600 600,1230
are being read and modified,|
|

1744
00:59:27,560 --> 00:59:28,940
0,360 360,420 420,750 750,1230 1230,1380
have the version number at
在事务开始时具有版本号，

1745
00:59:28,940 --> 00:59:30,360
0,60 60,300 300,390 390,1290
the start of transaction,|
|

1746
00:59:30,650 --> 00:59:32,210
0,450 450,780 780,1050 1050,1230 1230,1560
{} and nothing has changed
一切都还没有改变，

1747
00:59:32,210 --> 00:59:33,590
0,420 570,720 720,1050 1050,1290 1290,1380
yet,| and so it is
|所以，事务提交是可以的，

1748
00:59:33,590 --> 00:59:34,790
0,450 450,630 630,690 690,1140 1140,1200
okay for the transaction to

1749
00:59:34,790 --> 00:59:36,710
0,360 420,630 630,1170 1170,1530 1530,1920
commit,| {it,is} really the true
|它是真正的串行化点。

1750
00:59:36,710 --> 00:59:38,000
0,630 630,1020
serialization point.|
|

1751
00:59:38,600 --> 00:59:39,590
0,180 180,540 540,660 660,780 780,990
And since you know the
而且由于事务编号

1752
00:59:39,590 --> 00:59:41,390
0,720 720,1020 1020,1140 1140,1680 1680,1800
transactions numbers| are required at
|在开始时需要版本号，

1753
00:59:41,390 --> 00:59:42,710
0,60 60,420 420,570 570,810 810,1320
the beginning with version number,|
|

1754
00:59:42,710 --> 00:59:43,490
0,240 240,300 300,570 570,690 690,780
{right,at} the beginning of the
在事务开始时，

1755
00:59:43,490 --> 00:59:45,890
0,660 900,1620 1620,1740 1740,2130 2130,2400
transaction,| you know {the,transaction -}
|事务将按照版本号的顺序提交，

1756
00:59:45,890 --> 00:59:47,360
0,150 150,660 840,1050 1050,1110 1110,1470
will commit in the order

1757
00:59:47,360 --> 00:59:48,710
0,60 60,150 150,480 480,720 720,1350
of the version numbers basically,|
|

1758
00:59:48,890 --> 00:59:51,410
0,690 810,1410 1410,2130 2130,2370 2370,2520
and {} they also would
它们将获得严格的可串行化，

1759
00:59:51,410 --> 00:59:53,510
0,120 120,420 420,1020 1080,1560 1560,2100
get basically strict {serializability -},|
|

1760
00:59:54,540 --> 00:59:56,160
0,330 330,510 510,1140 1290,1500 1500,1620
because any transaction that will
因为在你的事务提交后启动的任何事务

1761
00:59:56,160 --> 00:59:58,350
0,480 480,1080 1110,1350 1350,1770 1770,2190
start after your transaction commits,|
|

1762
00:59:58,350 --> 00:59:59,760
0,150 150,360 360,630 630,900 900,1410
will have higher version number,|
都将具有更高的版本号，|

1763
00:59:59,790 --> 01:00:00,930
0,180 180,540 540,750 750,870 870,1140
so therefore {it,also} will commit
所以，它也会晚点提交。

1764
01:00:00,930 --> 01:00:01,540
0,300
later.|
|

1765
01:00:04,710 --> 01:00:06,060
0,330 330,480 480,660 660,810 810,1350
Okay, so this is the
好的，这就是那个点，

1766
01:00:06,390 --> 01:00:08,490
0,660 660,1020 1020,1140 1140,1830 1860,2100
point,| basically {} where {}
|事务协调者说，

1767
01:00:08,490 --> 01:00:11,430
0,390 390,960 960,1470 1770,2610 2700,2940
transaction coordinator says,| {} {you,know}
|在这一点上，

1768
01:00:11,430 --> 01:00:12,480
0,120 120,270 270,780 810,900 900,1050
at this point you know

1769
01:00:12,480 --> 01:00:13,560
0,420
the,|
|

1770
01:00:14,230 --> 01:00:15,460
0,450 450,660 660,870 870,1050 1050,1230
{} we know that all
我们知道我们必须获得锁，

1771
01:00:15,460 --> 01:00:16,570
0,450 450,600 600,720 720,990 990,1110
the we have to, we

1772
01:00:16,570 --> 01:00:17,890
0,120 120,480 480,570 570,1080 1080,1320
have acquired the locks,| we
|我们已验证读取对象的版本号，

1773
01:00:17,890 --> 01:00:19,810
0,300 300,870 870,930 930,1500 1500,1920
have verified to validate the

1774
01:00:19,870 --> 01:00:21,580
0,450 450,720 720,870 870,1500 1500,1710
version numbers for the read

1775
01:00:21,580 --> 01:00:22,570
0,390 390,510 510,660 660,870 870,990
objects,| and so this is
|所以，这是提交点或提交点的开始，

1776
01:00:22,570 --> 01:00:24,180
0,480 480,570 570,840 840,1080
basically the commit point

1777
01:00:26,000 --> 01:00:26,690
0,150 150,240 240,540 540,600 600,690
or the start of the

1778
01:00:26,690 --> 01:00:28,310
0,270 270,480 480,840 900,1170 1170,1620
commit point,| so this point
|所以这一点是在说，

1779
01:00:28,340 --> 01:00:29,180
0,210 210,330 330,630 630,780 780,840
that is actually going to

1780
01:00:29,180 --> 01:00:30,650
0,480 750,960 960,1170 1170,1320 1320,1470
say,| {} okay, I'm gonna
|好的，我要提交了。

1781
01:00:30,650 --> 01:00:31,700
0,330 330,480 480,720 720,870 870,1050
go, {} I'm gonna go

1782
01:00:31,700 --> 01:00:32,480
0,510
commit.|
|

1783
01:00:34,120 --> 01:00:35,290
0,420 420,540 540,690 690,900 900,1170
And you know there's {}
提交点需要多条消息，

1784
01:00:35,290 --> 01:00:37,900
0,840 930,1500 1500,2280 2280,2340 2340,2610
multiple messages necessary to commit

1785
01:00:37,900 --> 01:00:39,370
0,300 300,540 540,810 810,1200 1200,1470
point,| we'll {see,in,a} second,| and
|我们一会儿就会看到，|这些主要是出于容错的原因。

1786
01:00:39,400 --> 01:00:40,750
0,360 360,450 450,960 960,1140 1140,1350
those are mostly for fault

1787
01:00:40,750 --> 01:00:41,860
0,900
{tolerance,reasons}.|
|

1788
01:00:42,480 --> 01:00:43,760
0,810

1789
01:00:44,400 --> 01:00:45,930
0,420 420,720 720,1050 1080,1320 1320,1530
And so at this point,|
所以在这一点上，|

1790
01:00:45,930 --> 01:00:48,120
0,540 540,570 570,1380 1380,1500 1500,2190
namely {} only the primary
只有 primary 已经，

1791
01:00:48,360 --> 01:00:50,610
0,420 420,900 930,1320 1620,2100 2100,2250
has been the,| only the
|只有 primary 已经联系正被修改的对象，

1792
01:00:50,610 --> 01:00:53,220
0,750 780,1050 1050,1230 1230,2010 2190,2610
primary have been contacted of

1793
01:00:53,220 --> 01:00:55,890
0,660 1110,1890 2190,2340 2340,2400 2400,2670
the {} of the objects

1794
01:00:55,890 --> 01:00:56,850
0,120 120,180 180,330 330,840 840,960
that are being modified,| but
|但不包括 backup 。

1795
01:00:56,850 --> 01:00:57,900
0,210 210,270 270,480 480,900
not the {backups -}.|
|

1796
01:00:58,120 --> 01:00:59,080
0,180 180,240 240,540 540,810 810,960
And of course we want
当然，我们想要确保这一点，并写下，

1797
01:00:59,080 --> 01:01:00,640
0,60 60,510 510,810 810,1350 1350,1560
to ensure that {} and

1798
01:01:00,670 --> 01:01:02,020
0,510 510,600 600,840 870,1260 1260,1350
write,| you know once you
|一旦你提交，就能容忍 f 个故障，

1799
01:01:02,020 --> 01:01:04,930
0,480 750,1290 1290,1560 1560,2310 2340,2910
commit {} will survive f

1800
01:01:04,930 --> 01:01:06,490
0,450 480,750 750,1020 1020,1140 1140,1560
failures, right,| system is designed
|系统设计为处理 f+1 个故障，

1801
01:01:06,490 --> 01:01:09,640
0,1230 1230,1470 1530,1770 1770,2310 2970,3150
to {handle,f+1 -} failures,| in
|在我们的设计中，有一个备份，

1802
01:01:09,640 --> 01:01:11,920
0,150 150,540 540,1200 1230,1770 1770,2280
our particular designs, there's {}

1803
01:01:12,310 --> 01:01:13,810
0,450 450,1020 1020,1200 1200,1410 1410,1500
one backup,| and so it
|所以它只能容忍一个故障。

1804
01:01:13,810 --> 01:01:15,430
0,120 120,540 540,960 960,1200 1200,1620
can only survive one failure.|
|

1805
01:01:16,930 --> 01:01:17,920
0,240 240,390 390,570 570,900 900,990
And so what happens in
所以发生在最后一个阶段，提交备份阶段，

1806
01:01:17,920 --> 01:01:19,720
0,330 330,840 1020,1470 1470,1710 1710,1800
this {} final phase, {}

1807
01:01:19,720 --> 01:01:21,370
0,270 270,540 540,1020 1080,1290 1290,1650
commit backup phase,| is actually
|是我们要写入备份的日志，

1808
01:01:21,370 --> 01:01:23,350
0,120 120,240 240,390 390,930 1200,1980
we're going to write to

1809
01:01:23,560 --> 01:01:25,750
0,540 720,1440 1440,1590 1590,1740 1740,2190
the logs of the primary

1810
01:01:25,780 --> 01:01:27,880
0,150 150,210 210,870 870,1290 1950,2100
of the backups,| so the
|所以备份有日志，

1811
01:01:27,880 --> 01:01:29,660
0,450 450,750 780,1560
backups have log,|
|

1812
01:01:30,210 --> 01:01:31,710
0,150 150,450 450,690 690,810 810,1500
so here's {backup -} i,|
所以这是 Bi ，|

1813
01:01:31,770 --> 01:01:32,670
0,120 120,240 240,660 660,840 840,900
you know similar there's a
类似的，里面有一个日志条目，

1814
01:01:32,670 --> 01:01:35,040
0,300 300,630 630,750 750,990 1620,2370
log entry in it,| and
|我们要做的是，

1815
01:01:35,340 --> 01:01:37,680
0,660 1230,1530 1530,1620 1620,1830 1830,2340
{} what we're gonna do

1816
01:01:37,710 --> 01:01:40,170
0,810 960,1470 1500,1950 1950,2220 2220,2460
is| write {} what's called
|写下所谓的提交备份记录，

1817
01:01:40,170 --> 01:01:41,980
0,120 120,510 510,900 900,1350
{} commit backup record,|
|

1818
01:01:42,980 --> 01:01:43,560
0,60

1819
01:01:50,500 --> 01:01:51,700
0,270 270,390 390,900 900,1110 1110,1200
and the commit {backup -}
提交备份记录与锁记录相同的信息，

1820
01:01:51,700 --> 01:01:53,200
0,540 540,960 960,1110 1110,1170 1170,1500
record exactly as the same

1821
01:01:53,200 --> 01:01:56,650
0,600 600,1440 1770,2160 2160,3060 3090,3450
information as the locking record,|
|

1822
01:01:56,650 --> 01:01:57,880
0,120 120,210 210,420 420,870 870,1230
that we saw earlier,| so
我们之前看到的，|所以，它将包含版本号 oid 和新值。

1823
01:01:57,940 --> 01:01:58,990
0,240 240,540 750,870 870,990 990,1050
in it, is going to

1824
01:01:58,990 --> 01:02:00,550
0,120 120,180 180,540 540,1170 1410,1560
be the version number, the

1825
01:02:00,550 --> 01:02:03,880
0,900 1230,2070 2130,2550 2550,3120 3150,3330
oid and {} the new

1826
01:02:03,880 --> 01:02:04,520
0,420
value.|
|

1827
01:02:07,870 --> 01:02:11,290
0,780 1710,2400 2490,2760 2760,2940 2940,3420
Okay?| And this is {you,know}
好的？|像之前一样，这是使用写入 RDMA ，

1828
01:02:11,290 --> 01:02:12,670
0,240 240,870 900,1050 1050,1140 1140,1380
like before this is actually

1829
01:02:12,670 --> 01:02:16,030
0,390 390,930 1320,1710 1710,2250 2610,3360
done using {} write RDMA,|
|

1830
01:02:21,190 --> 01:02:22,360
0,270 270,360 360,750 750,990 990,1170
now the backup doesn't really
现在，备份在这一点上并不需要执行任何操作，

1831
01:02:22,360 --> 01:02:24,160
0,150 150,240 240,390 390,870 900,1800
have to do any operation

1832
01:02:24,160 --> 01:02:25,240
0,450 450,600 600,900 900,1020 1020,1080
at this point,| like the
|备份服务器端不需要运行任何东西，

1833
01:02:25,240 --> 01:02:26,260
0,360 360,600 600,660 660,750 750,1020
server side of the backup

1834
01:02:26,260 --> 01:02:27,190
0,240 240,420 420,570 570,690 690,930
doesn't really have to run

1835
01:02:27,190 --> 01:02:29,590
0,540 630,960 960,1200 1200,1530 1560,2400
anything,| {} just need {}
|所以这是这个技巧，

1836
01:02:29,590 --> 01:02:31,630
0,510 690,870 870,1050 1050,1350 1590,2040
and and so the the

1837
01:02:31,660 --> 01:02:33,730
0,270 270,450 450,960 1050,1530 1530,2070
here's this trick,| {} where
|发送者等待网卡的确认，

1838
01:02:33,760 --> 01:02:34,990
0,450 450,540 540,840 840,1080 1080,1230
basically the sender waits the

1839
01:02:34,990 --> 01:02:36,340
0,600 600,690 690,780 780,1170
acknowledgement of the NIC,|
|

1840
01:02:36,800 --> 01:02:38,900
0,240 240,720 810,1410 1740,1920 1920,2100
and so this you know
所以这不是单方面的，也不是写入 RDMA ，

1841
01:02:38,900 --> 01:02:40,610
0,630 630,750 750,960 960,1050 1050,1710
this is not {} one-sided

1842
01:02:40,850 --> 01:02:43,070
0,570 600,990 990,1710 1830,2130 2130,2220
or write RDMA,| this is
|这只是确认它已获得写入 RDMA ，

1843
01:02:43,070 --> 01:02:44,600
0,240 240,510 510,1200 1200,1380 1380,1530
just make acknowledging that it

1844
01:02:44,600 --> 01:02:46,070
0,330 330,450 450,720 720,1350 1350,1470
got the write RDMA,| and
|并且已经执行了写入 RDMA 。

1845
01:02:46,070 --> 01:02:47,300
0,210 210,450 450,930 930,1080 1080,1230
the write RDMA has been

1846
01:02:47,300 --> 01:02:48,040
0,570
performed.|
|

1847
01:02:48,380 --> 01:02:49,910
0,150 150,240 240,450 450,750 750,1530
And so that basically acknowledges,|
所以，这是在确认，|

1848
01:02:49,910 --> 01:02:50,720
0,120 120,210 210,420 420,510 510,810
you know when we get
当我们在协议中这一点时，

1849
01:02:50,810 --> 01:02:51,920
0,330 330,690 690,960 960,1020 1020,1110
this particular point in the

1850
01:02:51,920 --> 01:02:54,710
0,750 960,1140 1140,1710 1710,2190 2190,2790
protocol,| the transaction coordinator knows,|
|事务协调者知道，|

1851
01:02:54,860 --> 01:02:57,380
0,690 1350,2010 2040,2310 2310,2400 2400,2520
the object is in the
对象在所有 primary 的日志中，

1852
01:02:57,380 --> 01:02:58,790
0,330 330,450 450,570 570,660 660,1410
log of all the primaries,|
|

1853
01:02:59,150 --> 01:03:00,770
0,330 330,690 690,1020 1050,1470 1470,1620
and objects in {} in
以及对象在所有备份日志中。

1854
01:03:00,770 --> 01:03:01,310
0,60 60,270 270,360 360,450 450,540
the log of all the

1855
01:03:01,310 --> 01:03:02,120
0,660
backups.|
|

1856
01:03:02,420 --> 01:03:03,290
0,180 180,360 360,630 630,810 810,870
And so now we're in
所以现在我们在容错性方面处于有利地位，

1857
01:03:03,290 --> 01:03:04,250
0,60 60,240 240,660 660,750 750,960
{} good position in {terms,of}

1858
01:03:04,250 --> 01:03:06,170
0,90 90,300 300,780 780,1140 1140,1920
of fault tolerance, correct,| because
|因为如果两者中的任何一个失败了，

1859
01:03:06,380 --> 01:03:08,300
0,750 840,1050 1050,1590 1620,1830 1830,1920
{} if any one of

1860
01:03:08,300 --> 01:03:09,710
0,90 90,270 270,870 960,1230 1230,1410
the two fails,| the other
|另一个可以应用写操作。

1861
01:03:09,710 --> 01:03:10,910
0,390 390,510 510,780 780,1110 1110,1200
one can actually apply the

1862
01:03:10,910 --> 01:03:12,180
0,300 300,810
write operation.|
|

1863
01:03:13,870 --> 01:03:17,230
0,240 240,600 630,960 960,1560 2610,3360
Then there's one more step
然后还有一个步骤需要执行，

1864
01:03:17,230 --> 01:03:18,670
0,360 360,570 570,660 660,780 780,1440
that needs to be performed,|
|

1865
01:03:18,940 --> 01:03:21,340
0,150 150,360 360,480 480,1500 1770,2400
and that is {} commit
那就是提交 primary ，

1866
01:03:21,340 --> 01:03:22,480
0,540 570,780 780,930 930,1110 1110,1140
primary,| I'll talk about a
|稍后我会更详细地谈到，

1867
01:03:22,480 --> 01:03:23,590
0,180 180,360 360,660 660,960 960,1110
little bit later in more

1868
01:03:23,590 --> 01:03:26,320
0,600 810,1590 2070,2310 2310,2430 2430,2730
detail,| but this is the
|但这是最后一步，

1869
01:03:26,320 --> 01:03:28,330
0,330 330,630 630,1320 1470,1830 1830,2010
final step,| where {} there's
|更多日志记录写入，

1870
01:03:28,330 --> 01:03:30,010
0,210 210,720 750,1050 1050,1350 1350,1680
one more log record written,|
|

1871
01:03:30,010 --> 01:03:32,470
0,1230 1230,1620 1620,1860 1860,2160 2160,2460
{in,the} primary, namely {} commit
在 primary 中，也就是提交记录，

1872
01:03:32,470 --> 01:03:36,020
0,420
record,|
|

1873
01:03:38,620 --> 01:03:39,490
0,150 150,210 210,450 450,750 750,870
and the commit record is
提交记录是正在提交的事务 id 。

1874
01:03:39,490 --> 01:03:41,740
0,570 570,840 840,1110 1110,1680 1920,2250
{} is transaction id, that

1875
01:03:41,740 --> 01:03:43,220
0,300 300,420 420,630 630,1170
actually is being committed.|
|

1876
01:03:44,390 --> 01:03:46,220
0,630 780,960 960,1170 1170,1560 1560,1830
{} So like every, {}|
所以像每个，|

1877
01:03:46,220 --> 01:03:47,210
0,150 150,390 390,600 600,720 720,990
I didn't write that down
我没有把它写在其他记录里，

1878
01:03:47,210 --> 01:03:48,260
0,90 90,180 180,450 450,870 870,1050
in the other records,| but
|但是每个记录都有一个事务 id ，

1879
01:03:48,260 --> 01:03:49,490
0,300 300,570 570,750 750,810 810,1230
every record has a transaction

1880
01:03:49,490 --> 01:03:50,420
0,240 240,360 360,540 540,690 690,930
id,| so we know which
|我们知道我们谈论的是哪一个事务。

1881
01:03:50,420 --> 01:03:51,960
0,480 480,600 600,960 960,1290
transaction we're talking about.|
|

1882
01:03:53,380 --> 01:03:55,780
0,630 660,1350 1500,1860 1860,2070 2070,2400
And, {} again this {}
同样，这也使用了相同的策略，

1883
01:03:55,870 --> 01:03:57,910
0,360 360,480 480,1110 1110,1830 1830,2040
use the same strategy,| there's
|有一个写入 RDMA 要附加到日志，

1884
01:03:57,910 --> 01:03:59,680
0,360 360,660 660,1320
a write RDMA

1885
01:04:00,750 --> 01:04:01,980
0,390 390,840
to appends,

1886
01:04:05,350 --> 01:04:07,750
0,210 210,690 690,1470 1500,2370 2370,2400
to the, { - -}

1887
01:04:07,750 --> 01:04:09,580
0,180 180,270 270,840 1140,1710 1710,1830
to the log,| and you
|有一个网卡确认写入 RDMA ，

1888
01:04:09,580 --> 01:04:11,020
0,150 150,420 420,510 510,1170 1170,1440
know there's an acknowledgement, the

1889
01:04:11,020 --> 01:04:15,310
0,390 420,1350 1650,2310 2310,3810 3840,4290
NIC acknowledges {} the write

1890
01:04:15,340 --> 01:04:16,870
0,420 420,900 930,1230 1230,1380 1380,1530
{RDMA -},| and so but
|但它不需要任何中断，

1891
01:04:16,870 --> 01:04:18,700
0,60 60,360 360,900 900,1200 1200,1830
it doesn't require any interrupts,|
|

1892
01:04:19,030 --> 01:04:20,830
0,330 330,540 540,960 990,1410 1410,1800
or there's no server itself
或者没有服务器，本身不受干扰，

1893
01:04:20,830 --> 01:04:22,540
0,90 90,330 330,750 750,1350 1350,1710
is not being interfered with,|
|

1894
01:04:22,630 --> 01:04:23,890
0,390 390,660 660,690 690,1050 1080,1260
{} just {} NIC is
只有网卡参与了这两个操作。

1895
01:04:23,890 --> 01:04:25,510
0,390 390,450 450,660 660,810 810,1620
involved in these two operations.|
|

1896
01:04:26,800 --> 01:04:28,380
0,630 630,690 690,960 960,1350
Then as soon as,
一旦其中一个网卡确认提交记录，

1897
01:04:28,730 --> 01:04:30,620
0,270 270,540 540,690 690,1170 1200,1890
{} one of the NICs

1898
01:04:30,710 --> 01:04:32,870
0,510 510,660 660,1230 1230,1650 1650,2160
{} {acknowledges -} the commit

1899
01:04:33,050 --> 01:04:34,220
0,510 510,810 810,960 960,1050 1050,1170
record| on one of the
|在一个 primary 上，

1900
01:04:34,220 --> 01:04:35,960
0,690 780,1020 1020,1230 1230,1560 1560,1740
primaries,| at that particular point
|在那个时间点，

1901
01:04:35,960 --> 01:04:37,310
0,90 90,660 750,960 960,1080 1080,1350
of time,| which is actually
|它是真正提交的，

1902
01:04:37,310 --> 01:04:38,760
0,270 270,720 720,1200
really truly committed,|
|

1903
01:04:39,000 --> 01:04:39,960
0,150 150,330 330,420 420,690 720,960
so this is the true
所以这是真正的提交点，

1904
01:04:39,960 --> 01:04:41,100
0,270 270,690
commit point,|
|

1905
01:04:43,820 --> 01:04:45,350
0,180 180,510 510,870 870,1230 1230,1530
the commit starts basically here,|
提交从这里开始，|

1906
01:04:45,350 --> 01:04:46,070
0,90 90,210 210,330 330,600 600,720
and this is actually the
这是实际的提交点，

1907
01:04:46,070 --> 01:04:47,720
0,330 330,600 600,1020 1290,1470 1470,1650
actual commit point,| at that
|在这个特定时间点上，

1908
01:04:47,720 --> 01:04:49,610
0,300 300,480 480,540 540,1140 1290,1890
particular point in time,| the
|事务协调者通知应用程序，

1909
01:04:49,640 --> 01:04:51,890
0,600 600,1110 1110,1530 1530,1590 1590,2250
transaction coordinator informs the application,|
|

1910
01:04:51,980 --> 01:04:53,900
0,540 570,750 750,1230 1230,1410 1410,1920
yes, your transaction has committed,
是的，你的事务已经提交，并且已经完成。

1911
01:04:54,020 --> 01:04:55,780
0,810 810,1050 1050,1410
and is done.|
|

1912
01:04:57,470 --> 01:04:58,820
0,480 630,780 780,960 960,1110 1110,1350
Then, of course some point
当然，稍后某个时刻，

1913
01:04:58,820 --> 01:04:59,750
0,330 330,420 420,720 720,840 840,930
later,| the logs need to
|日志需要清理、缩短和截断，诸如此类的事情，

1914
01:04:59,750 --> 01:05:01,370
0,90 90,750 750,990 990,1380 1380,1620
be cleaned and shortened up

1915
01:05:01,370 --> 01:05:02,300
0,120 120,630 630,720 720,840 840,930
and truncated and all that

1916
01:05:02,300 --> 01:05:02,960
0,150 150,210 210,450 450,540 540,660
kind of stuff,| and this
|这就是截断阶段，

1917
01:05:02,960 --> 01:05:04,910
0,90 90,240 240,300 300,870 870,1950
is like the truncate {phase

1918
01:05:04,940 --> 01:05:07,310
0,540 750,930 930,1110 1110,1590 1590,2370
-},| and that's basically {[],back}
|这是[]后面的锁阶段和验证阶段，

1919
01:05:07,310 --> 01:05:09,080
0,240 240,750 750,1230 1230,1680 1680,1770
on later locking phases and

1920
01:05:09,080 --> 01:05:10,680
0,480 480,1140
validation phases,|
|

1921
01:05:10,950 --> 01:05:12,030
0,480 480,660 660,750 750,900 900,1080
{} and so I'm not
所以我不会讨论它，

1922
01:05:12,030 --> 01:05:12,810
0,150 150,270 270,360 360,570 570,780
really going to talk about

1923
01:05:12,810 --> 01:05:14,340
0,120 120,240 240,570 570,1080 1080,1530
it at all,| but basically
|但是，它们必须截断日志，

1924
01:05:14,340 --> 01:05:15,180
0,90 90,180 180,330 330,750 750,840
they have to truncate the

1925
01:05:15,180 --> 01:05:16,620
0,780 780,900 900,1050 1050,1200 1200,1440
logs,| so that they don't
|这样它们不会无限生长。

1926
01:05:16,620 --> 01:05:18,020
0,390 390,960
grow unbounded.|
|

1927
01:05:23,640 --> 01:05:27,330
0,510 780,1440 1440,1920 1920,2400 2640,3690
{} Sorry, but the hardware
抱歉，硬件会起作用，

1928
01:05:27,360 --> 01:05:29,730
0,600 600,1020 1020,1470 1470,1620 1620,2370
acts,| they just go directly
|它们只是直接进入协调者的网卡？

1929
01:05:29,790 --> 01:05:30,920
0,870
into,

1930
01:05:31,460 --> 01:05:33,800
0,510 510,1140 1560,1920 1920,2100 2100,2340
into the NIC of the

1931
01:05:33,800 --> 01:05:36,590
0,600 600,2310 2310,2460 2460,2580 2580,2790
coordinator?| Yeah, let's go back
|是的，让我们回到 RDMA 的图片上，

1932
01:05:36,590 --> 01:05:37,970
0,60 60,150 150,600 600,1020 1050,1380
to the RDMA picture, right,|
|

1933
01:05:38,360 --> 01:05:39,590
0,240 240,390 390,510 510,780 780,1230
so if a write RDMA
如果发生写入 RDMA ，

1934
01:05:39,590 --> 01:05:40,460
0,660
happens,|
|

1935
01:05:41,090 --> 01:05:43,100
0,570 570,720 720,1080 1080,1320 1320,2010
{} so here're write RDMA,|
所以这是写入 RDMA ，|

1936
01:05:43,250 --> 01:05:45,410
0,690 750,1230 1230,1800 1800,1920 1920,2160
the sender coordinator was running
发送者协调者在这里运行，

1937
01:05:45,410 --> 01:05:46,640
0,90 90,420 420,750 780,990 990,1230
{} here, right,| and here's
|这可能是 primary 和 backup 之一，

1938
01:05:46,640 --> 01:05:47,270
0,150 150,270 270,450 450,540 540,630
may be one of the

1939
01:05:47,270 --> 01:05:49,080
0,510 510,690 690,1530
primary, {so,the} backups,|
|

1940
01:05:49,600 --> 01:05:51,550
0,660 660,900 900,1260 1260,1530 1530,1950
and so the write RDMA
所以写入 RDMA 进入，

1941
01:05:51,550 --> 01:05:53,080
0,240 240,630 660,1170 1170,1470 1470,1530
goes in,| write maybe an
|可能写入一个条目到日志中，

1942
01:05:53,080 --> 01:05:54,970
0,390 390,510 510,630 630,1230 1590,1890
entry to the log, {}|
|

1943
01:05:54,970 --> 01:05:56,650
0,150 150,390 390,630 630,1050 1170,1680
the NIC does that, NIC
网卡发回一个确认，

1944
01:05:56,740 --> 01:05:58,520
0,300 300,390 390,960 960,1410
sends an acknowledgement back,|
|

1945
01:06:00,170 --> 01:06:01,820
0,390 390,480 480,1080 1080,1200 1200,1650
and the coordinator will see
协调者将在接收队列中看到确认，

1946
01:06:01,820 --> 01:06:03,170
0,180 180,810 810,930 930,990 990,1350
that acknowledgment in the received

1947
01:06:03,170 --> 01:06:03,760
0,240
queue,|
|

1948
01:06:07,180 --> 01:06:08,140
0,210 210,450 450,780 780,870 870,960
and so soon as the
一旦协调者看到它的写入 RDMA 的 ack ，

1949
01:06:08,140 --> 01:06:09,970
0,510 510,840 840,1020 1020,1470 1530,1830
coordinator sees the ack {you,know}

1950
01:06:09,970 --> 01:06:12,040
0,570 570,990 990,1350 1350,1620 1620,2070
for {} it's {} {}

1951
01:06:12,040 --> 01:06:14,770
0,390 390,1110 1260,1770 1770,2100 2100,2730
write RDMA,| {} it can
|它可以继续，

1952
01:06:14,980 --> 01:06:15,880
0,540
proceed,|
|

1953
01:06:16,380 --> 01:06:17,370
0,180 180,540 540,660 660,750 750,990
and knows that the write
并且知道写入 RDMA 成功了。

1954
01:06:17,370 --> 01:06:18,700
0,180 180,390 390,1020
{RDMA -} succeeded.|
|

1955
01:06:23,920 --> 01:06:26,230
0,210 210,600 600,1230 1260,1710 1740,2310
So does the write RDMA
所以写入 RDMA 只是写入日志，它们。

1956
01:06:26,230 --> 01:06:27,280
0,150 150,480 480,840 840,930 930,1050
is only write to the

1957
01:06:27,280 --> 01:06:30,010
0,450 450,1020 1650,2190 2190,2580 2580,2730
log, they.| They're used in
|它们用在两种情况下，

1958
01:06:30,010 --> 01:06:31,930
0,180 180,840 900,1410 1410,1620 1620,1920
two cases,| {} they're both
|它们用于这些消息队列和日志追加。

1959
01:06:31,930 --> 01:06:33,490
0,270 270,510 510,690 690,1050 1050,1560
used for these message queues

1960
01:06:33,520 --> 01:06:36,220
0,270 270,540 540,1800 2280,2550 2550,2700
and for the {} the

1961
01:06:36,220 --> 01:06:37,440
0,450 480,840
log append.|
|

1962
01:06:41,620 --> 01:06:42,400
0,210 210,330 330,450 450,570 570,780
And so when we say
所以，当我们说已经执行了写入 RDMA 时，

1963
01:06:42,400 --> 01:06:44,380
0,660 660,960 960,1290 1290,1830 1830,1980
that a write RDMA has

1964
01:06:44,380 --> 01:06:45,670
0,150 150,660 660,780 780,1050 1050,1290
been performed,| we mean that
|我们的意思是它已被附加到日志中，

1965
01:06:45,670 --> 01:06:46,510
0,90 90,240 240,390 390,780 780,840
it has been appended to

1966
01:06:46,510 --> 01:06:47,950
0,90 90,510 540,810 810,1110 1110,1440
the log| and not actually
|并不一定由应用程序实际执行。

1967
01:06:47,950 --> 01:06:49,990
0,600 600,1200 1200,1440 1440,1560 1560,2040
executed necessarily by the application.|
|

1968
01:06:50,050 --> 01:06:52,030
0,300 300,720 720,900 900,1320 1710,1980
That's correct, that's correct, {}|
对，对，|

1969
01:06:52,030 --> 01:06:53,440
0,270 270,900 900,1020 1020,1170 1170,1410
so {for,example} you know to,|
例如，|

1970
01:06:53,440 --> 01:06:54,880
0,60 60,360 360,630 630,870 930,1440
for example to the backup
例如，备份执行对象的更新，

1971
01:06:54,880 --> 01:06:57,850
0,90 90,630 870,1860 1890,2730 2760,2970
to actually {} perform the

1972
01:06:57,850 --> 01:06:59,020
0,300 300,390 390,480 480,990 990,1170
update to the object,| you
|你需要读取日志条目，然后应用更新。

1973
01:06:59,020 --> 01:07:00,430
0,300 300,750 750,990 990,1080 1080,1410
need to read the log

1974
01:07:00,430 --> 01:07:01,450
0,390 390,480 480,600 600,930 930,1020
entry and then apply the

1975
01:07:01,450 --> 01:07:02,000
0,420
update.|
|

1976
01:07:03,730 --> 01:07:04,810
0,150 150,360 360,480 480,810 810,1080
I see,| and also for
我明白了，|还有每个对象的锁位，

1977
01:07:04,810 --> 01:07:06,400
0,210 210,570 570,840 840,1110 1110,1590
the lock bit for every

1978
01:07:06,400 --> 01:07:08,140
0,450 450,690 690,960 960,1320 1320,1740
object,| so since everything resides
|由于一切都驻留在内存中，

1979
01:07:08,140 --> 01:07:09,190
0,270 300,690 690,780 780,900 900,1050
in memory,| and we have
|我们有 64 位的版本号加上锁位，

1980
01:07:09,190 --> 01:07:10,300
0,480 480,630 630,870 870,1050 1050,1110
{like,64 -} bits for the

1981
01:07:10,300 --> 01:07:11,980
0,270 270,780 990,1350 1350,1410 1410,1680
version number plus the lock

1982
01:07:11,980 --> 01:07:13,330
0,270 450,750 750,900 900,1230 1230,1350
bit,| so I'm assuming that
|所以我想它可以放入一个单一的内存地址，

1983
01:07:13,330 --> 01:07:14,230
0,90 90,300 300,630 630,810 810,900
it can fit in a

1984
01:07:14,230 --> 01:07:16,450
0,540 540,930 930,1470 1680,2130 2130,2220
single memory address,| but we
|但我们仍然会有这样的问题，

1985
01:07:16,450 --> 01:07:17,350
0,120 120,330 330,450 450,540 540,900
can still have the problem

1986
01:07:17,350 --> 01:07:19,240
0,150 150,510 510,660 660,1080 1080,1890
of,| let's say the processor
|假设处理器将该内存地址提取到寄存器中，

1987
01:07:19,270 --> 01:07:21,040
0,570 570,780 780,1110 1110,1500 1500,1770
fetching that memory address into

1988
01:07:21,040 --> 01:07:22,930
0,840 1110,1410 1410,1560 1560,1680 1680,1890
register,| {} and then maybe
|然后，如果我们有一台多核计算机，

1989
01:07:22,930 --> 01:07:23,890
0,210 210,300 300,480 480,690 690,960
if we have a {multi-core

1990
01:07:23,890 --> 01:07:26,770
0,600 1200,1710 1710,2010 2010,2400 2400,2880
-} machine,| then another core
|然后另一个内核获取相同的地址，

1991
01:07:26,830 --> 01:07:29,440
0,480 480,1350 1620,1980 1980,2220 2220,2610
fetching that that same address,|
|

1992
01:07:29,440 --> 01:07:30,730
0,120 120,420 420,660 660,780 780,1290
and then both of them
然后它们都从 0 翻到 1 ，

1993
01:07:30,790 --> 01:07:32,140
0,420 420,570 570,810 810,930 930,1350
flipping from 0 to 1,|
|

1994
01:07:32,500 --> 01:07:34,270
0,540 540,1230 1230,1470 1470,1590 1590,1770
so I'm assuming that there's
所以我假设有一些来自硬件的支持？

1995
01:07:34,270 --> 01:07:35,800
0,150 150,660 660,750 750,810 810,1530
some support from the hardware?|
|

1996
01:07:35,920 --> 01:07:37,420
0,360 360,510 510,690 690,1170 1170,1500
Yeah, so like I mentioned
是的，就像我之前提到的，

1997
01:07:37,420 --> 01:07:38,680
0,60 60,180 180,630 630,750 750,1260
a bit earlier,| the primary
|当 primary 获取，

1998
01:07:38,680 --> 01:07:40,150
0,210 210,300 300,870 870,1080 1080,1470
when it acquires,| the primaries
|primary 涉及到，

1999
01:07:40,150 --> 01:07:42,010
0,270 270,810 810,1170 1170,1470 1530,1860
actually involved correct in the

2000
01:07:42,010 --> 01:07:45,160
0,420 420,1110 1500,2490 2640,3150 3150,3150
primary on { -},| {so,the}
|所以协调者发送，

2001
01:07:45,160 --> 01:07:47,110
0,720 720,1200 1200,1380 1380,1620 1620,1950
coordinator sends {},| so in
|所以在锁阶段，这个阶段一，

2002
01:07:47,110 --> 01:07:48,460
0,90 90,360 360,870 900,1140 1140,1350
the lock step like this,

2003
01:07:48,460 --> 01:07:50,950
0,180 180,870 1110,1470 1470,1920 2130,2490
this step, step one,| the
|primary 或 coordinator 发送写入 RDMA 到 primary ，

2004
01:07:50,950 --> 01:07:52,990
0,570 570,930 930,1470 1470,1800 1800,2040
primary {or,the} coordinator sends an

2005
01:07:52,990 --> 01:07:56,710
0,780 810,1260 1260,1860 1860,2610 2820,3720
{} write RDMA to the

2006
01:07:57,070 --> 01:07:58,660
0,120 120,240 240,870 900,1470 1470,1590
to the primaries,| asking the
|要求 primary 将对象加锁，

2007
01:07:58,660 --> 01:08:00,940
0,480 480,630 630,1200 1410,2160
primaries to lock the

2008
01:08:00,990 --> 01:08:04,710
0,600 600,1230 1740,2490 2580,3150 3180,3720
{} object,| and the primaries
|primary 用一条信息明确地回答，然后回复，

2009
01:08:04,710 --> 01:08:06,420
0,480 480,1230 1260,1470 1470,1650 1650,1710
answer explicitly {} with a

2010
01:08:06,420 --> 01:08:09,270
0,510 540,810 810,1410 1800,2460 2460,2850
message, then reply,| and so
|所以发生的这一关键步骤是，

2011
01:08:09,300 --> 01:08:11,280
0,390 390,810 810,1350 1350,1530 1530,1980
this crucial step that happens

2012
01:08:11,280 --> 01:08:12,390
0,300 300,450 450,540 540,930 930,1110
is,| that the primary when
|当 primary 试着获取锁，

2013
01:08:12,390 --> 01:08:13,170
0,120 120,300 300,570 570,660 660,780
it actually tries to get

2014
01:08:13,170 --> 01:08:14,850
0,90 90,510 840,990 990,1170 1170,1680
the lock,| and that lock
|锁已经设置了，

2015
01:08:15,030 --> 01:08:17,010
0,720 720,930 930,1350 1380,1590 1590,1980
{} is set,| you know
|这是一个单一的 64 位数字的原因，

2016
01:08:17,010 --> 01:08:18,270
0,390 390,570 570,690 690,960 960,1260
reason this is one single

2017
01:08:18,270 --> 01:08:19,920
0,480 480,660 660,1230 1350,1530 1530,1650
64 bit number,| is so
|是因为你可以使用 test-and-set 指令，

2018
01:08:19,920 --> 01:08:20,460
0,120 120,240 240,330 330,480 480,540
that you can use []

2019
01:08:20,460 --> 01:08:22,110
0,240 240,330 330,510 510,1170 1320,1650
{test-and-set - -} instruction,| which
|它是原子地设置锁。

2020
01:08:22,110 --> 01:08:23,640
0,90 90,720 960,1170 1170,1290 1290,1530
is atomic {} to set

2021
01:08:23,640 --> 01:08:24,260
0,90 90,540
the lock.|
|

2022
01:08:25,640 --> 01:08:27,950
0,360 360,600 600,1080 1650,2160 2160,2310
So if two, {} so
所以，永远不会有这种情况，

2023
01:08:27,950 --> 01:08:29,780
0,750 750,1020 1020,1110 1110,1470 1470,1830
there's never the case,| there's
|当两个 test-and-set 指令完全同时运行，

2024
01:08:29,780 --> 01:08:31,580
0,300 300,510 510,780 780,1500 1500,1800
only, if two test-and-set instructions

2025
01:08:31,580 --> 01:08:33,410
0,180 180,1080 1080,1170 1170,1380 1380,1830
run exactly the same time,|
|

2026
01:08:33,500 --> 01:08:34,370
0,240 240,330 330,450 450,510 510,870
one is going to win,
一个会赢，另一个会输。

2027
01:08:34,400 --> 01:08:34,910
0,120 120,240 240,330 330,450 450,510
the other is going to

2028
01:08:34,910 --> 01:08:35,560
0,480
lose.|
|

2029
01:08:36,500 --> 01:08:38,570
0,180 180,390 390,660 660,900 1590,2070
I see, thank you.| That's
我明白了，谢谢。|这是一个关键点。

2030
01:08:38,570 --> 01:08:40,220
0,60 60,450 450,900 930,1350
a crucial point, right.|
|

2031
01:08:42,350 --> 01:08:44,900
0,330 330,510 510,660 660,1860 1890,2550
I've got a question about
我有一个关于蓝色提交点的问题。

2032
01:08:44,990 --> 01:08:46,680
0,210 210,540 540,930 930,1380
the blue commit point.|
|

2033
01:08:47,190 --> 01:08:48,540
0,540 540,990
Yeah. {}|
嗯。|

2034
01:08:49,220 --> 01:08:52,100
0,390 390,690 690,1200 1440,1950 2310,2880
Wouldn't it, so.| {Should,I}, {let,me},|
它不会，所以。|我应该，让我，|

2035
01:08:52,100 --> 01:08:53,120
0,210 210,420 420,540 540,840 840,1020
{} maybe it's better to
也许再打开一张带有图片的新幻灯片更好，

2036
01:08:53,120 --> 01:08:54,890
0,720 720,1320 1320,1350 1350,1500 1500,1770
actually open a new slide

2037
01:08:54,890 --> 01:08:55,910
0,120 120,240 240,480 480,840 840,1020
with the picture again,| and
|不是在这个上面继续涂鸦，

2038
01:08:55,910 --> 01:08:58,220
0,300 1260,1560 1560,1620 1620,2130 2130,2310
just instead of scribbling even

2039
01:08:58,220 --> 01:08:59,240
0,270 270,450 450,810
more over this,|
|

2040
01:08:59,490 --> 01:09:00,540
0,120 120,510 510,720 720,870 870,1050
I mean, let's get one
我是说，我们再来一张图，

2041
01:09:00,540 --> 01:09:01,680
0,180 180,570 570,690 690,810 810,1140
more picture,| so we can
|这样我们就可以讨论其他场景了，

2042
01:09:01,890 --> 01:09:03,740
0,270 270,450 450,630 630,1380
talk about other scenarios,|
|

2043
01:09:14,240 --> 01:09:14,870
0,120 120,270 270,300 300,480 480,630
I think a little bit
我想再大一点，

2044
01:09:14,870 --> 01:09:16,760
0,480 660,900 900,1410 1410,1710 1710,1890
bigger,| I think should do
|我认为应该这么做。

2045
01:09:16,760 --> 01:09:17,640
0,390
that.|
|

2046
01:09:18,410 --> 01:09:20,720
0,510 540,990 990,1290 1290,2010
Okay, {} so you're
好的，所以你担心的是，

2047
01:09:20,920 --> 01:09:23,860
0,420 420,990 1020,1320 1320,1800 2670,2940
worried about,| {let,me} see.| {Yeah\,,the}
|让我看一下。|是的，那个提交点在步骤 2 和步骤 3 之间。

2048
01:09:23,860 --> 01:09:25,750
0,270 270,480 480,870 870,1440 1470,1890
commit point between step, after

2049
01:09:25,750 --> 01:09:27,520
0,210 210,420 420,990 990,1320 1320,1770
step 2, before step 3.|
|

2050
01:09:27,670 --> 01:09:29,500
0,300 300,420 420,1440 1470,1770 1770,1830
Yeah, so here, here's the
是的，这是[决定点]。

2051
01:09:29,500 --> 01:09:31,900
0,480 480,870 870,1260 1740,2250 2250,2400
decision, correct.| Right.| {Starting,to,commit} and
|是的。|开始提交，然后是实际提交点。

2052
01:09:31,900 --> 01:09:34,220
0,480 780,1290 1290,1650 1650,2040
then basically here's the

2053
01:09:34,470 --> 01:09:36,520
0,870 870,1290 1320,1740
{actually,commit} point, right.|
|

2054
01:09:37,090 --> 01:09:39,220
0,600 630,1380 1440,1740 1740,1860 1860,2130
Okay, {} yeah I guess
好的，我想我是在想这个场景，

2055
01:09:39,220 --> 01:09:40,360
0,120 120,540 540,840 840,930 930,1140
I was trying to think

2056
01:09:40,360 --> 01:09:42,140
0,240 240,330 330,780 780,1470
about the scenario,| where,
|对于一个完全独立的并发事务是否可能，

2057
01:09:42,580 --> 01:09:44,710
0,390 390,510 510,660 660,1680 1710,2130
would it be possible for

2058
01:09:44,710 --> 01:09:47,440
0,90 90,690 690,1350 1350,1770 1770,2730
a completely separate concurrent transaction,|
|

2059
01:09:47,830 --> 01:09:50,410
0,240 240,510 510,1020 1020,2250 2430,2580
that writes only P3 to
只写入 P3 进行交错，

2060
01:09:50,410 --> 01:09:52,120
0,180 180,450 450,840 840,1410 1440,1710
get {interleaved - -},| {to,like}
|在那个空间里开始和完成，

2061
01:09:52,150 --> 01:09:54,610
0,510 510,660 660,1380 1980,2190 2190,2460
start and complete in that

2062
01:09:54,610 --> 01:09:55,540
0,780
space,|
|

2063
01:09:55,840 --> 01:09:57,220
0,150 150,300 300,630 630,1050
and then wasn't that?|
然后这样不是？|

2064
01:09:57,450 --> 01:09:59,970
0,450 450,720 720,1620 2040,2280 2280,2520
No, [],| {} yeah, we're
不，[]，|是的，我们有问题，但不能，

2065
01:09:59,970 --> 01:10:01,590
0,450 450,630 630,990 990,1320 1320,1620
problematic, but can't, correct,| because
|因为当它写入时，

2066
01:10:01,590 --> 01:10:02,490
0,150 150,330 330,570 570,630 630,900
when it writes,| it does
|它在某个点上获得锁，

2067
01:10:02,490 --> 01:10:03,270
0,150 150,240 240,510 510,600 600,780
get the lock at some

2068
01:10:03,270 --> 01:10:03,920
0,390
point,|
|

2069
01:10:04,580 --> 01:10:05,750
0,510 510,840 840,960 960,1080 1080,1170
and when we get the
当我们获得锁时，

2070
01:10:05,750 --> 01:10:06,620
0,210 210,300 300,510 510,570 570,870
lock,| we check the version
|我们检查版本号和锁位。

2071
01:10:06,620 --> 01:10:07,580
0,270 270,390 390,480 480,750 750,960
number and the lock bit.|
|

2072
01:10:10,580 --> 01:10:12,200
0,210 210,390 390,1110 1200,1440 1440,1620
{But\,,does} the read, does the
但是，读取 P3 会影响版本号和锁位吗？

2073
01:10:12,200 --> 01:10:13,520
0,240 240,360 360,810 810,1230 1230,1320
read the P3 affect the

2074
01:10:13,520 --> 01:10:14,630
0,270 270,540 540,630 630,870 870,1110
version number and lock bit?|
|

2075
01:10:15,290 --> 01:10:16,490
0,270 270,630 630,780 780,960 960,1200
No, no, it just gets
不，它只获取版本号。

2076
01:10:16,490 --> 01:10:17,740
0,330 330,600 600,960
the version number.|
|

2077
01:10:19,350 --> 01:10:22,410
0,210 210,1440 2130,2310 2310,2790 2790,3060
But if you, let let
但如果你，让我保留这个问题，

2078
01:10:22,410 --> 01:10:23,610
0,120 120,480 480,630 630,960 960,1200
me hold that question,| you're
|你会回到这个问题上。

2079
01:10:23,610 --> 01:10:24,180
0,120 120,180 180,270 270,510 510,570
going to come back at

2080
01:10:24,180 --> 01:10:24,800
0,390
this.|
|

2081
01:10:25,250 --> 01:10:26,660
0,390 390,630 630,750 750,1020 1020,1410
Okay, then we'll see what
好的，我们看看会发生什么？

2082
01:10:26,660 --> 01:10:27,660
0,240 240,810
actually happens?|
|

2083
01:10:28,820 --> 01:10:29,820
0,330 330,750
Okay, thanks.|
好的，谢谢。|

2084
01:10:31,640 --> 01:10:32,900
0,210 210,390 390,990
Any other questions?|
还有其他问题吗？|

2085
01:10:34,930 --> 01:10:35,710
0,270 270,420 420,510 510,690 690,780
This might be like a
这可能像是一个单独的场景，

2086
01:10:35,710 --> 01:10:37,150
0,360 360,780 780,870 870,1020 1020,1440
separate scenario,| but what happens
|但如果你在执行阶段之后，会发生什么，

2087
01:10:37,150 --> 01:10:40,030
0,990 1380,1800 1980,2130 2130,2430 2460,2880
if {} you know after

2088
01:10:40,030 --> 01:10:41,640
0,90 90,780 780,1380
the execution phase,|
|

2089
01:10:41,980 --> 01:10:43,780
0,720 780,960 960,1230 1230,1380 1380,1800
{} you know it tries
它试图获取一个锁，

2090
01:10:43,780 --> 01:10:45,400
0,90 90,630 630,840 840,1380 1410,1620
to acquire a lock,| and
|然后就在那之后崩溃了，

2091
01:10:45,400 --> 01:10:47,530
0,150 150,690 690,870 870,1440 1590,2130
then crashes right {after,that}, {}|
|

2092
01:10:47,800 --> 01:10:49,120
0,150 150,420 420,660 660,810 810,1320
{and,the} lock has been acquired,|
锁已经被获取，|

2093
01:10:49,120 --> 01:10:49,990
0,120 120,210 210,360 360,600 600,870
but no one else after
但在那之后，其他任何人都无法获得它。

2094
01:10:49,990 --> 01:10:51,100
0,210 210,330 330,690 690,840
that can acquire it.|
|

2095
01:10:51,830 --> 01:10:53,270
0,690 690,960 960,1110 1110,1260 1260,1440
Yeah, okay, so well first
是的，好的，首先，机器从地球上消失了，

2096
01:10:53,270 --> 01:10:54,680
0,60 60,150 150,270 270,810 840,1410
of all, the machine disappears

2097
01:10:54,680 --> 01:10:56,060
0,180 180,270 270,570 570,1050 1050,1380
from the earth, correct,| and
|内存内容也消息了，

2098
01:10:56,060 --> 01:10:57,320
0,300 300,660 660,720 720,990 990,1260
memory content is gone too,|
|

2099
01:10:59,200 --> 01:11:01,180
0,690 690,1320 1320,1620 1620,1680 1680,1980
and {} in the whole
在整个恢复协议中，

2100
01:11:01,180 --> 01:11:03,280
0,660 690,1290 1290,1560 1560,1680 1680,2100
recovery protocol,| that is described
|在论文的下一节描述的，

2101
01:11:03,280 --> 01:11:04,060
0,60 60,150 150,390 390,720 720,780
in the next section in

2102
01:11:04,060 --> 01:11:05,520
0,90 90,570 600,870 870,1110
the paper kicks in,|
|

2103
01:11:05,760 --> 01:11:07,680
0,780 780,1200 1200,1470 1470,1860 1860,1920
and {} that protocol in
协议最终中止了事务，

2104
01:11:07,680 --> 01:11:09,150
0,120 120,360 360,870 870,1350 1350,1470
the end will abort the

2105
01:11:09,150 --> 01:11:10,040
0,540
transaction,|
|

2106
01:11:17,640 --> 01:11:19,050
0,210 210,630 630,960 960,1140 1140,1410
so it will get cleaned
所以，它将得到清理。

2107
01:11:19,050 --> 01:11:19,660
0,330
up.|
|

2108
01:11:22,790 --> 01:11:23,960
0,120

2109
01:11:26,440 --> 01:11:28,630
0,330 330,630 630,1230 1260,1740 1800,2190
Just another question,| {} so
再问一个问题，|所以这里协调者是客户端，就像应用程序一样。

2110
01:11:28,630 --> 01:11:30,970
0,330 330,570 570,690 690,1740 2130,2340
here like the coordinator is

2111
01:11:30,970 --> 01:11:32,320
0,120 120,660 660,960 960,1110 1110,1350
the client, right, like it's

2112
01:11:32,320 --> 01:11:36,250
0,210 210,870 870,2100 2100,3480 3690,3930
the application.| Yeah, yeah.| And
|是的。|所以客户端做所有的步骤，

2113
01:11:36,250 --> 01:11:37,660
0,210 210,360 360,810 810,960 960,1410
so the client is basically

2114
01:11:37,660 --> 01:11:38,980
0,360 360,600 600,690 690,1140 1140,1320
doing all the steps,| of
|比如 lock 。

2115
01:11:38,980 --> 01:11:41,650
0,270 300,840 870,1410 1650,2460 2460,2670
like lock that.| Yeah, yeah,
|是的，所以你可以考虑

2116
01:11:41,650 --> 01:11:42,850
0,420 420,780 780,870 870,1020 1020,1200
so you could think about|
|

2117
01:11:42,850 --> 01:11:43,870
0,120 120,630 630,900 900,960 960,1020
the applications running on the
应用程序在 90 台机器上运行，

2118
01:11:43,870 --> 01:11:45,340
0,330 330,570 570,660 660,930 930,1470
same set of 90 machines,

2119
01:11:45,400 --> 01:11:47,230
0,360 360,930 930,1500 1500,1590 1590,1830
right,| {} and you know
|运行这个事务，

2120
01:11:47,230 --> 01:11:49,450
0,330 330,480 480,1140 1320,1590 1590,2220
running this transaction,| which apparently
|很显然，写入两个对象，读取一个，

2121
01:11:49,450 --> 01:11:50,500
0,60 60,240 240,540 540,690 690,1050
you know writes two objects

2122
01:11:50,500 --> 01:11:53,140
0,150 150,270 270,720 1020,2220 2250,2640
and read one,| and runs
|并且运行这个协议。

2123
01:11:53,140 --> 01:11:53,820
0,120 120,600
the protocol.|
|

2124
01:11:54,540 --> 01:11:56,880
0,450 480,1020 1110,1710 1830,1950 1950,2340
And so, {} I guess
所以，我想令人困惑的是，

2125
01:11:57,030 --> 01:11:58,770
0,240 240,630 630,1050 1230,1500 1500,1740
what's confusing is,| so does
|所以 primary 并不直接与 backup 通信吗，它是。

2126
01:11:58,770 --> 01:12:00,600
0,120 120,630 630,1140 1140,1710 1710,1830
the primary not communicate with

2127
01:12:00,600 --> 01:12:02,760
0,90 90,660 660,1470 1620,1920 1920,2160
the backup directly, it's the.|
|

2128
01:12:02,790 --> 01:12:04,830
0,660 660,840 840,1140 1140,1560 1590,2040
No, it's actually indeed {},|
不，是这样的，|

2129
01:12:04,830 --> 01:12:05,970
0,120 120,390 390,570 570,750 750,1140
the primary does not directly
primary 不直接与 backup 通信。

2130
01:12:05,970 --> 01:12:07,220
0,450 450,540 540,600 600,960
communicate with the backup.|
|

2131
01:12:07,720 --> 01:12:08,660
0,600
{I,see}.|
我明白了。|

2132
01:12:09,980 --> 01:12:11,630
0,360 360,480 480,750 750,1260 1260,1650
Other than during recovery protocol,|
除了在恢复协议期间，|

2133
01:12:11,630 --> 01:12:12,680
0,210 210,300 300,480 480,540 540,1050
there's all kinds of communication
有各种各样的通信发生，

2134
01:12:12,680 --> 01:12:13,760
0,360 360,450 450,630 630,810 810,1080
happening,| but that's not shown
|但并没有在这里展示。

2135
01:12:13,760 --> 01:12:14,360
0,300
here.|
|

2136
01:12:18,590 --> 01:12:20,180
0,210 210,450 450,1110 1110,1350 1350,1590
So the coordinator just uses
所以，协调者使用来 zookeeper 的配置？

2137
01:12:20,180 --> 01:12:21,950
0,120 120,1050 1050,1410 1410,1530 1530,1770
the configuration from the {zookeeper

2138
01:12:21,950 --> 01:12:24,590
0,390 390,900 930,2100 2100,2310 2310,2640
-}?| Yeah, yeah, you go
|是的，回到第一张图片，

2139
01:12:24,590 --> 01:12:25,610
0,240 240,330 330,510 510,750 750,1020
back to the very first

2140
01:12:25,610 --> 01:12:27,770
0,480 930,1620 1620,1710 1710,2010 2010,2160
picture,| {} you know there's
|有各种各样的事情和这个有关，

2141
01:12:27,770 --> 01:12:28,610
0,120 120,270 270,330 330,690 720,840
all kinds of stuff you

2142
01:12:28,610 --> 01:12:29,690
0,180 180,510 510,570 570,720 720,1080
know related to this {to,that},|
|

2143
01:12:29,690 --> 01:12:31,340
0,90 90,240 240,570 570,960 1260,1650
I'm not talking about {}
我不是在谈论，这种精确的关系之类的事情，

2144
01:12:31,340 --> 01:12:32,660
0,240 240,390 390,750 750,1230 1230,1320
like this precise membership and

2145
01:12:32,660 --> 01:12:33,320
0,120 120,210 210,360 360,420 420,660
all that kind of thing,|
|

2146
01:12:33,650 --> 01:12:35,540
0,420 420,960 960,1320 1320,1770 1770,1890
but basically the zookeeper and
但是由 zookeepr 和连接管理者决定，

2147
01:12:35,540 --> 01:12:37,430
0,360 360,810 810,1170 1170,1770 1770,1890
connection manager really decide,| well
|这是我们运行的当前配置，

2148
01:12:37,430 --> 01:12:39,290
0,510 510,600 600,780 780,1620 1620,1860
this is a configuration, the

2149
01:12:39,290 --> 01:12:40,820
0,270 270,810 810,960 960,1230 1230,1530
current configuration, we're running in,|
|

2150
01:12:41,120 --> 01:12:42,590
0,330 330,570 570,720 720,1260 1260,1470
these are the regions,| how
这些是区域，|它们如何映射主备份和所有这些内容，

2151
01:12:42,590 --> 01:12:44,690
0,210 210,720 720,1110 1110,1800 1950,2100
they're mapped primary backups and

2152
01:12:44,690 --> 01:12:45,420
0,90 90,240 240,630
all that stuff,|
|

2153
01:12:46,600 --> 01:12:48,070
0,90 90,270 270,510 510,960 960,1470
and in any failure happens,|
在任何失败发生时，|

2154
01:12:48,070 --> 01:12:49,030
0,90 90,240 240,420 420,480 480,960
you know there's a whole
有一个完整的重新配置进程并恢复。

2155
01:12:49,030 --> 01:12:50,680
0,600 600,900 900,1140 1140,1380 1410,1650
reconfiguration process going on and

2156
01:12:50,680 --> 01:12:51,520
0,510
recovery.|
|

2157
01:12:53,370 --> 01:12:54,880
0,420 420,810
{I,see}, {thank,you}.|
我明白了，谢谢。|

2158
01:13:00,820 --> 01:13:02,800
0,510 540,1170 1260,1680 1680,1830 1830,1980
Okay, {} maybe I'm gonna
好的，也许我会跳过分组会议室，

2159
01:13:02,800 --> 01:13:05,320
0,390 390,1050 1080,1440 1440,1770 1830,2520
skip the breakout room, {}|
|

2160
01:13:05,320 --> 01:13:06,640
0,210 210,330 330,420 420,750 780,1320
and so I can go
所以我可以走得更远，

2161
01:13:06,640 --> 01:13:08,260
0,60 60,210 210,330 330,810 960,1620
a little bit further {},|
|

2162
01:13:08,380 --> 01:13:09,820
0,690 690,810 810,1110 1110,1200 1200,1440
{the,question} you know I wanted
我想要回答的问题，

2163
01:13:09,820 --> 01:13:10,690
0,60 60,300 300,390 390,720 720,870
to answer the question,| that
|在课程中贴出的，

2164
01:13:10,690 --> 01:13:12,820
0,420 420,720 720,1140 1860,2010 2010,2130
{} in the that was

2165
01:13:12,820 --> 01:13:13,900
0,360 360,660 690,960 960,1020 1020,1080
asking the post in the

2166
01:13:13,900 --> 01:13:15,790
0,330 330,540 540,960 1320,1590 1590,1890
lecture,| I'm gonna lecture question,|
|课程问题，|

2167
01:13:15,790 --> 01:13:16,570
0,180 180,450 450,570 570,720 720,780
and I'm just going to
我将通过谈论一个事务的例子来回答，

2168
01:13:16,570 --> 01:13:18,310
0,150 150,420 420,900 1080,1560 1560,1740
do that by talking about

2169
01:13:18,310 --> 01:13:19,900
0,90 90,780 780,870 870,1350 1350,1590
an example of transaction,| and
|这也涉及到之前的问题，

2170
01:13:19,900 --> 01:13:20,650
0,180 180,420 420,600 600,690 690,750
this also comes to the

2171
01:13:20,650 --> 01:13:22,570
0,390 390,690 690,1050 1440,1800 1800,1920
earlier question about,| {} you
|会发生什么，

2172
01:13:22,570 --> 01:13:23,560
0,60 60,270 270,780 780,870 870,990
know what happens,| you know
|两个事务运行并读取一个版本，

2173
01:13:23,560 --> 01:13:25,600
0,150 150,660 660,1140 1320,1830 1830,2040
two transactions run and read

2174
01:13:25,600 --> 01:13:27,070
0,210 210,840 840,1140 1140,1350 1350,1470
one version,| and then it
|然后它提交了，等等，这些东西。

2175
01:13:27,070 --> 01:13:29,320
0,510 570,1020 1020,1890 1890,2010 2010,2250
commits {blah,blah,blah} all this stuff.|
|

2176
01:13:29,350 --> 01:13:31,300
0,330 840,1350 1620,1770 1770,1890 1890,1950
So {} so this is
所以这是我们要讨论的话题，

2177
01:13:31,300 --> 01:13:32,620
0,420 420,540 540,810 810,1170 1170,1320
really the topic here| is
|我们是否得到了严格的可串行化？

2178
01:13:32,620 --> 01:13:33,280
0,120 120,180 180,300 300,450 450,660
going to do we get

2179
01:13:33,280 --> 01:13:34,500
0,330 330,720 720,1140
strict {serializability -}?|
|

2180
01:13:39,620 --> 01:13:40,520
0,240 240,360 360,480 480,660 660,900
And what I'm gonna do
我要做的是，

2181
01:13:40,520 --> 01:13:41,390
0,210 210,420 420,660 660,720 720,870
is,| I'm {not,going} to give
|我不会给你严格串行化的证据，

2182
01:13:41,390 --> 01:13:42,290
0,90 90,180 180,690 720,780 780,900
you {} proof you know

2183
01:13:42,290 --> 01:13:43,670
0,210 210,420 420,660 660,1110 1110,1380
that getting {strict,serializability -} will

2184
01:13:43,670 --> 01:13:44,510
0,90 90,450 450,570 570,690 690,840
be,| instead what I'm gonna
|相反，我要做的是，

2185
01:13:44,510 --> 01:13:45,140
0,150 150,300 300,360 360,480 480,630
do is,| I'm going to
|我来举一两个例子，

2186
01:13:45,140 --> 01:13:45,830
0,240 240,360 360,510 510,570 570,690
walk for one or two

2187
01:13:45,830 --> 01:13:46,960
0,690
examples,|
|

2188
01:13:47,100 --> 01:13:48,210
0,480 480,600 600,780 780,990 990,1110
{} to get build up
建立一些直觉，

2189
01:13:48,210 --> 01:13:49,240
0,150 150,690
some intuition,|
|

2190
01:13:49,500 --> 01:13:50,790
0,150 150,450 450,540 540,1230 1230,1290
and hopefully the intuition you
希望直觉能让你确信，

2191
01:13:50,790 --> 01:13:51,930
0,150 150,360 360,420 420,780 780,1140
know sort of convinced| you
|事情可能是好的。

2192
01:13:51,930 --> 01:13:53,130
0,180 180,390 420,810 810,990 990,1200
know that things might actually

2193
01:13:53,130 --> 01:13:53,900
0,90 90,390
be fine.|
|

2194
01:13:54,370 --> 01:13:55,720
0,360 360,660 660,1230 1230,1290 1290,1350
So let's look at the
那么让我们来看下面的事务，

2195
01:13:55,720 --> 01:13:57,190
0,210 210,960 1020,1140 1140,1290 1290,1470
{following,transaction -},| we have {TxnBegin
|我们有 TxnBegin ，

2196
01:13:57,190 --> 01:13:58,380
0,240 240,750
- -},|
|

2197
01:13:59,740 --> 01:14:00,790
0,180 180,300 300,780 780,960 960,1050
and this transaction is,| you
这个事务是，|在一开始，它读取一个对象，

2198
01:14:00,790 --> 01:14:02,560
0,330 360,1020 1020,1140 1140,1200 1200,1770
know like in the beginning,

2199
01:14:02,860 --> 01:14:04,240
0,210 210,390 390,480 480,1080
it reads an object,|
|

2200
01:14:08,620 --> 01:14:09,880
0,270 270,780
adds 1,
加 1 ，然后写入对象，

2201
01:14:13,260 --> 01:14:14,580
0,180 180,390 390,960
and then write

2202
01:14:18,180 --> 01:14:19,540
0,750
{the,object},|
|

2203
01:14:20,040 --> 01:14:22,500
0,450 450,1080 1110,1590 1620,2160
and commits or ends
提交或以失败提交结束，

2204
01:14:23,240 --> 01:14:24,760
0,270 270,510 510,1170
with commit {by,fail},|
|

2205
01:14:26,030 --> 01:14:27,460
0,150 150,360 360,420 420,1110
so that's a transaction.|
所以这是一个事务。|

2206
01:14:27,810 --> 01:14:29,340
0,690 990,1170 1170,1290 1290,1410 1410,1530
And you know we want
我们想问你自己，

2207
01:14:29,340 --> 01:14:31,170
0,660 660,1080 1080,1560 1560,1740 1740,1830
to ask yourself,| what are
|合法的结果是什么，

2208
01:14:31,170 --> 01:14:32,790
0,210 210,570 570,1050 1050,1500 1500,1620
the legal outcomes,| what are
|正确的结果是什么。

2209
01:14:32,790 --> 01:14:34,580
0,120 120,600 600,990 990,1470
the {outcomes -} correct.|
|

2210
01:14:38,910 --> 01:14:41,380
0,1770 1770,1830

2211
01:14:42,100 --> 01:14:43,480
0,720 750,930 930,1050 1050,1140 1140,1380
{} So what are the
那么，这个事务可能的结果是什么，

2212
01:14:43,510 --> 01:14:45,880
0,390 390,720 720,810 810,1020 1020,2370
possible outcomes of this transaction,|
|

2213
01:14:47,290 --> 01:14:48,160
0,240 240,390 390,480 480,570 570,870
what could be the state
会是什么状态，

2214
01:14:48,160 --> 01:14:49,540
0,240 330,540 540,810 810,1050 1050,1380
of,| let's say x started
|假设 x 从 0 开始，

2215
01:14:49,540 --> 01:14:51,580
0,150 150,1200 1320,1560 1560,1680 1680,2040
at 0,| and we're running
|我们运行两个事务， T1 和 T2 ，

2216
01:14:51,580 --> 01:14:52,810
0,150 150,810 810,900 900,1020 1020,1230
two transactions, you know {T1

2217
01:14:52,810 --> 01:14:55,840
0,1260 1860,2280 2280,2730
-} {and,T2 -},|
|

2218
01:14:57,530 --> 01:14:58,820
0,300 300,360 360,450 450,870 870,1290
what are the possible outcomes
有哪些可能的结果是好的。

2219
01:14:58,820 --> 01:14:59,740
0,180 180,630
that are

2220
01:15:00,260 --> 01:15:01,120
0,660
fine.|
|

2221
01:15:04,080 --> 01:15:05,760
0,420 420,780 780,1230 1230,1380 1380,1680
{} Either one of them
它们中的一个可以提交，

2222
01:15:05,760 --> 01:15:06,840
0,180 180,570 570,750 750,990 990,1080
could commit| or both of
|或者它们两个都可以提交？

2223
01:15:06,840 --> 01:15:07,900
0,120 120,330 330,750
them could commit?|
|

2224
01:15:08,260 --> 01:15:09,880
0,420 450,1050 1080,1380 1380,1500 1500,1620
Yeah, and so we can
是的，所以我们可以得到 x=2 ，两个都提交，

2225
01:15:09,880 --> 01:15:11,680
0,450 450,720 720,1110 1110,1440 1440,1800
have {x=2 -}, correct, both

2226
01:15:11,680 --> 01:15:12,480
0,360
commit,|
|

2227
01:15:12,930 --> 01:15:15,120
0,390 390,690 690,1140 1320,1980 1980,2190
{} {x=1 -}, possibility one
x=1 ，可能一个提交，另一个中止。

2228
01:15:15,120 --> 01:15:16,650
0,390 390,450 450,630 630,1110 1110,1530
commit, and one another abort,|
|

2229
01:15:16,650 --> 01:15:18,210
0,420 420,510 510,900 900,1080 1080,1560
general {} two run concurrently
一般是两个同时运行，

2230
01:15:18,210 --> 01:15:18,940
0,90 90,420
or something,|
|

2231
01:15:19,360 --> 01:15:21,370
0,630 720,930 930,1140 1140,1470 1470,2010
and any other possible outcomes?|
还有其他可能的结果吗？|

2232
01:15:23,940 --> 01:15:27,450
0,420 990,1800 1830,2460 2490,2970 3000,3510
0.| Yeah 0,| if {you,know,basically}
0 。|是的， 0 ，|如果两个都中止了，

2233
01:15:27,450 --> 01:15:29,100
0,240 240,660 690,1020 1110,1470 1470,1650
both abort, right,| maybe there's
|也许崩溃了。

2234
01:15:29,100 --> 01:15:29,980
0,60 60,660
a crash.|
|

2235
01:15:30,920 --> 01:15:31,820
0,330 330,450 450,690 690,750 750,900
Okay, so those are the
好的，这就是三种合法的结果，

2236
01:15:31,820 --> 01:15:33,280
0,240 240,540 540,1200
three legal outcomes,|
|

2237
01:15:33,620 --> 01:15:36,140
0,660 1110,1290 1290,1740 1800,2430 2430,2520
{} so this, you have
你必须确保是这样的。

2238
01:15:36,140 --> 01:15:36,800
0,90 90,210 210,330 330,480 480,660
to make sure that is

2239
01:15:36,800 --> 01:15:37,880
0,90 90,330 330,720 780,960 960,1080
the case.| So let's say
|假设 T1 运行，执行一个读取操作，

2240
01:15:37,880 --> 01:15:39,800
0,210 210,450 450,990 1560,1800 1800,1920
{T1 -} runs and so

2241
01:15:39,800 --> 01:15:41,600
0,180 180,240 240,420 420,1110 1560,1800
does a read operation,| get
|将 x 从版本 0 取回，

2242
01:15:41,600 --> 01:15:43,190
0,330 330,780 810,1170 1170,1290 1290,1590
x back, maybe at version

2243
01:15:43,190 --> 01:15:45,170
0,570 930,1260 1260,1620 1620,1830 1830,1980
0,| same thing with {T2
|T2 也是一样，它读取 x0 ，

2244
01:15:45,170 --> 01:15:46,850
0,510 510,660 660,1140 1140,1260 1260,1680
-}, it reads you know

2245
01:15:46,850 --> 01:15:47,800
0,750
{}

2246
01:15:48,130 --> 01:15:51,040
0,480 570,1470 1560,2430 2550,2760 2760,2910
x 0,| {} and so
|所以它是真正地同时运行，

2247
01:15:51,040 --> 01:15:52,390
0,270 270,720 720,840 840,1050 1050,1350
it's basically to run truly

2248
01:15:52,390 --> 01:15:54,940
0,660 1020,1710 2010,2400 2400,2490 2490,2550
concurrent,| and this is the
|这是我们问的问题，

2249
01:15:54,940 --> 01:15:56,620
0,270 270,630 630,930 930,1530 1530,1680
question that we ask,| {you,know}
|那个锁的问题，

2250
01:15:56,620 --> 01:15:57,760
0,240 240,450 450,720 720,870 870,1140
{the,lock} question,| we do lock
|我们执行对 x 加锁，我们执行对 x 加锁，

2251
01:15:57,760 --> 01:15:59,410
0,540 540,660 660,810 810,1050 1050,1650
x, we do lock x,|
|

2252
01:16:00,140 --> 01:16:03,170
0,930 1350,2130 2370,2820 2820,2970 2970,3030
and {} here sort of
这是关键的一步，

2253
01:16:03,170 --> 01:16:04,490
0,60 60,360 360,630 630,1020 1020,1320
{} crucial step, correct,| because
|因为在这个时刻，

2254
01:16:04,490 --> 01:16:06,470
0,90 90,240 240,600 600,1140 1170,1980
at this particular point, {}|
|

2255
01:16:06,560 --> 01:16:08,060
0,630 810,1080 1080,1290 1290,1350 1350,1500
there we're trying to get
我们试图获取对象 0 的锁，

2256
01:16:08,060 --> 01:16:09,350
0,90 90,540 540,900 900,1020 1020,1290
the locks on {object -}

2257
01:16:09,350 --> 01:16:12,260
0,810 1020,1770 2070,2460 2460,2700 2700,2910
0| and {} can both
|两个都能成功吗？

2258
01:16:12,260 --> 01:16:13,100
0,600
succeed?|
|

2259
01:16:14,860 --> 01:16:18,320
0,270 270,750 1230,1560 1770,2400
In reading?| {In,getting,the,lock,x -}.|
在读取中吗？|在获取 x 锁的过程中。|

2260
01:16:18,610 --> 01:16:19,930
0,420 420,570 570,810 810,930 930,1320
Oh, in getting the lock,|
哦，在获取锁的时候，|

2261
01:16:19,960 --> 01:16:21,250
0,450 450,660 660,750 750,840 840,1290
{} not at the same
不是在同一时间。

2262
01:16:21,250 --> 01:16:23,350
0,600 1230,1380 1380,1560 1560,1650 1650,2100
time.| So one is gonna,
|所以一个会成功。

2263
01:16:23,350 --> 01:16:24,340
0,300 300,390 390,510 510,570 570,990
one is going to succeed,

2264
01:16:24,340 --> 01:16:25,060
0,450
correct.|
|

2265
01:16:25,440 --> 01:16:26,370
0,270 270,390 390,570 570,810 810,930
And so let's say the
我们假设第一个成功，并获得了锁，

2266
01:16:26,370 --> 01:16:27,600
0,240 240,360 360,930 930,1050 1050,1230
first one succeeds and gets

2267
01:16:27,600 --> 01:16:28,480
0,90 90,600
the lock,|
|

2268
01:16:28,820 --> 01:16:29,960
0,210 210,420 420,570 570,690 690,1140
that means it can commit,
这意味着它可以提交，

2269
01:16:29,990 --> 01:16:30,700
0,390
right,|
|

2270
01:16:31,430 --> 01:16:32,630
0,240 240,390 390,600 600,720 720,1200
so this guy will commit,|
所以这个会提交，|

2271
01:16:33,290 --> 01:16:35,390
0,690 720,1260 1290,1590 1590,1860 1860,2100
{} and {} what happens
那个第二个会发生什么？

2272
01:16:35,390 --> 01:16:36,460
0,90 90,180 180,420 420,780
with the second guy?|
|

2273
01:16:36,870 --> 01:16:38,820
0,600 600,720 720,1020 1020,1620 1680,1950
{} The second one, if
第二个，如果它同时试图获取锁，

2274
01:16:38,820 --> 01:16:39,660
0,90 90,330 330,420 420,750 750,840
it tries to obtain the

2275
01:16:39,660 --> 01:16:40,560
0,270 270,360 360,420 420,660 660,900
lock at the same time,|
|

2276
01:16:40,560 --> 01:16:41,190
0,90 90,210 210,420 420,540 540,630
that the first one is
第一个持有锁，

2277
01:16:41,190 --> 01:16:42,060
0,300 300,390 390,630 630,720 720,870
holding the lock,| it will
|它将中止并停止，

2278
01:16:42,060 --> 01:16:44,160
0,240 240,390 390,840 1260,1770 1770,2100
abort and stop,| {} if
|如果第一个事务通过并且锁被释放，

2279
01:16:44,160 --> 01:16:45,540
0,150 150,450 450,930 930,1170 1170,1380
the first transaction goes through

2280
01:16:45,540 --> 01:16:46,050
0,90 90,150 150,330 330,450 450,510
{} the way and the

2281
01:16:46,050 --> 01:16:48,060
0,240 240,360 360,1110 1380,1860 1860,2010
lock is released,| then it
|然后它将获得锁，

2282
01:16:48,060 --> 01:16:49,080
0,150 150,420 420,540 540,900 900,1020
will obtain the lock,| and
|然后检查 x 的版本是否仍然正确，

2283
01:16:49,080 --> 01:16:51,120
0,270 270,810 840,990 990,1410 1410,2040
then check to see whether

2284
01:16:51,120 --> 01:16:52,380
0,270 270,690 690,810 810,900 900,1260
the version that it has

2285
01:16:52,380 --> 01:16:54,120
0,180 180,570 570,810 810,1020 1020,1740
for x is still correct,|
|

2286
01:16:54,210 --> 01:16:55,380
0,510 510,660 660,750 750,930 930,1170
{} and it will find
它会发现版本已经被更改，

2287
01:16:55,380 --> 01:16:56,550
0,330 330,450 450,840 840,1020 1020,1170
that the version has been

2288
01:16:56,550 --> 01:16:57,630
0,630 630,720 720,810 810,900 900,1080
changed,| and then it will
|然后它会中止。

2289
01:16:57,630 --> 01:16:58,140
0,390
abort.|
|

2290
01:16:58,350 --> 01:17:00,120
0,450 630,960 960,1080 1080,1140 1140,1770
Yep, {} this is exactly
是的，是这两种情况。

2291
01:17:00,120 --> 01:17:02,040
0,180 180,720 1020,1140 1140,1380 1380,1920
the two, the two cases.|
|

2292
01:17:02,160 --> 01:17:02,880
0,150 150,270 270,360 360,540 540,720
So let me talk about
所以让我稍后来谈谈验证案例，

2293
01:17:02,880 --> 01:17:05,220
0,510 510,2100 2100,2160 2160,2280 2280,2340
validation case {in,in,a,second},| with a
|使用一个稍有不同的例子，也许更有趣，

2294
01:17:05,220 --> 01:17:06,510
0,270 270,540 540,930 930,1140 1140,1290
slightly different example, maybe more

2295
01:17:06,510 --> 01:17:08,310
0,510 810,1200 1200,1350 1350,1680 1680,1800
interesting,| {} but this is
|但这就是结果。

2296
01:17:08,310 --> 01:17:10,160
0,570 570,750 750,1140 1170,1500
basically the outcome, right.|
|

2297
01:17:11,520 --> 01:17:13,860
0,360 510,810 810,1890 1920,2220 2220,2340
Good, and so even though
很好，所以即使这张图中的事务，

2298
01:17:13,860 --> 01:17:15,330
0,150 150,630 630,840 840,1050 1080,1470
these transactions in this particular

2299
01:17:15,330 --> 01:17:16,740
0,270 270,660 660,750 750,1320 1320,1410
picture| run {you,know} exactly at
|同时运行，

2300
01:17:16,740 --> 01:17:18,720
0,60 60,300 300,840 870,1770 1800,1980
the same time,| {} they
|它们也是排序的，

2301
01:17:18,720 --> 01:17:20,190
0,180 180,360 360,570 570,1140 1320,1470
are actually getting ordered,| and
|一个赢了，另一个输了，

2302
01:17:20,190 --> 01:17:20,940
0,240 240,480 480,570 570,630 630,750
one wins and the other

2303
01:17:20,940 --> 01:17:22,530
0,150 150,750 990,1230 1230,1410 1410,1590
one loses,| that means the
|这意味着另一个输了的可以再次运行，

2304
01:17:22,530 --> 01:17:23,670
0,120 120,240 240,360 360,720 720,1140
other one that {lost,can} run

2305
01:17:23,670 --> 01:17:25,560
0,480 720,900 900,1050 1050,1590 1590,1890
again,| it will then read
|然后它将读取 Rx1 ，然后希望在重试中成功。

2306
01:17:25,560 --> 01:17:27,000
0,240 240,510 510,1020 1110,1230 1230,1440
{Rx1 - -} and then

2307
01:17:27,000 --> 01:17:28,590
0,390 390,870 870,960 960,1080 1080,1590
hopefully succeed in the retry.|
|

2308
01:17:29,370 --> 01:17:30,320
0,660
Okay?|
好的?|

2309
01:17:32,710 --> 01:17:34,320
0,270 270,600 660,1290
Okay, so. {}|
好的，所以。|

2310
01:17:36,430 --> 01:17:37,460
0,720

2311
01:17:37,700 --> 01:17:38,780
0,1020

2312
01:17:39,910 --> 01:17:41,350
0,300 300,570 570,840 840,1020 1020,1440
Okay, let me do one
好的，让我举个例子，

2313
01:17:41,350 --> 01:17:42,730
0,450 450,540 540,690 690,1050 1050,1380
example,| and then I'll stop
|然后我会停下来，在周四继续，

2314
01:17:42,730 --> 01:17:44,290
0,90 90,240 240,630 630,900 900,1560
and I'll resume on the

2315
01:17:44,380 --> 01:17:46,140
0,390 390,870 900,1200 1200,1380
on the {Thursday -},|
|

2316
01:17:46,760 --> 01:17:47,960
0,450 540,750 750,960 960,1050 1050,1200
{} what time is it
现在时间是 24 分。

2317
01:17:47,960 --> 01:17:49,040
0,540 570,720 720,810 810,900 900,1080
24.| Let me {actually -}
|让我停在这里，

2318
01:17:49,040 --> 01:17:50,720
0,120 120,450 450,870 1080,1260 1260,1680
{you,know} stop here,| and then
|然后我会做第二个例子，

2319
01:17:50,720 --> 01:17:52,340
0,480 480,630 630,690 690,960 960,1620
I'll do {} second example,|
|

2320
01:17:52,340 --> 01:17:54,620
0,510 990,1320 1320,1440 1440,1830 1830,2280
that answers that earlier question,|
回答前面的问题，|

2321
01:17:54,740 --> 01:17:57,740
0,780 780,1470 1470,1680 1680,2340 2340,3000
{} on on Thursday and
在周四，也会讨论一下容错。

2322
01:17:57,740 --> 01:17:59,330
0,570 570,750 750,930 930,1080 1080,1590
also talk about fault tolerance,|
|

2323
01:18:00,120 --> 01:18:01,440
0,480 480,630 630,780 780,1200 1200,1320
{} I don't want too
我不想超过太多时间，

2324
01:18:01,440 --> 01:18:02,660
0,360 360,450 450,540 540,900
much {over -} time,|
|

2325
01:18:03,940 --> 01:18:05,470
0,330 330,750 750,930 930,990 990,1530
{} anybody has to go,
任何人必须离开，请随意离开，

2326
01:18:05,500 --> 01:18:06,520
0,180 180,390 390,540 540,630 630,1020
please feel free to go,|
|

2327
01:18:06,550 --> 01:18:09,010
0,960 1530,1890 1890,2100 2100,2250 2250,2460
{} and {I'll,see} {you,in} {Thursday
我们周四见，

2328
01:18:09,010 --> 01:18:10,630
0,300 300,990 990,1110 1110,1590 1590,1620
-},| anybody who asks, {
|如果有人想问更多的问题，

2329
01:18:10,630 --> 01:18:11,830
0,210 210,390 390,450 450,690 690,1200
-} like to ask for

2330
01:18:12,010 --> 01:18:13,210
0,210 210,600 600,1020 1020,1110 1110,1200
{} more questions,| you know
|可以继续停留，

2331
01:18:13,210 --> 01:18:14,590
0,240 240,750 750,930 930,1020 1020,1380
please feel free to stay,|
|

2332
01:18:14,590 --> 01:18:16,030
0,240 240,510 510,900 900,990 990,1440
and I'll try the best
我会尽最大努力回答它们，

2333
01:18:16,030 --> 01:18:17,500
0,90 90,510 960,1110 1110,1230 1230,1470
to {answer,them},| as you see,
|如你所见，这是一篇复杂的论文，

2334
01:18:17,500 --> 01:18:19,300
0,150 150,270 270,600 660,1260 1260,1800
this is a complicated paper,|
|

2335
01:18:19,570 --> 01:18:22,150
0,750 750,1950 2010,2220 2220,2490 2490,2580
{} and I'm glad that
我很高兴我们，

2336
01:18:22,150 --> 01:18:23,140
0,120 120,420 420,630 630,810 810,990
we're going {},| we're able
|我们能够深入，并试图理解，

2337
01:18:23,140 --> 01:18:23,650
0,90 90,210 210,300 300,450 450,510
to go and sort of

2338
01:18:23,650 --> 01:18:24,640
0,360 360,480 480,720 720,780 780,990
depth and trying to really

2339
01:18:24,640 --> 01:18:26,000
0,450 450,510 510,840
understand,| at least
|至少是正常操作的协议。

2340
01:18:26,600 --> 01:18:29,060
0,510 630,1290 1290,1530 1530,1950 1950,2460
the protocol for normal operation.|
|

2341
01:18:32,490 --> 01:18:33,570
0,270 270,450 450,720 720,930 930,1080
So with that, I just
说到这里，我想结束这节课，

2342
01:18:33,570 --> 01:18:34,800
0,120 120,330 360,630 630,750 750,1230
like to finish this lecture,|
|

2343
01:18:34,830 --> 01:18:36,600
0,720 1080,1290 1290,1440 1440,1560 1560,1770
and {you,know} see you Thursday
周四再见，

2344
01:18:36,600 --> 01:18:37,560
0,240 240,630 630,750 750,840 840,960
day| or if you have
|或者如果你有任何问题，请留下来。

2345
01:18:37,560 --> 01:18:38,730
0,150 150,510 510,720 720,870 870,1170
any questions, please hang around.|
|

2346
01:18:40,680 --> 01:18:42,450
0,480 510,600 600,990 990,1290 1290,1770
{} I had two like
我有两个高级别问题，

2347
01:18:42,630 --> 01:18:45,630
0,420 510,1050 1050,1560 1560,2100 2310,3000
the high-level questions,| {one,was} {}
|一个是，他们使用的这个整个硬件结构，

2348
01:18:45,690 --> 01:18:46,640
0,660
this,

2349
01:18:47,300 --> 01:18:50,090
0,330 330,1020 1050,2250 2280,2640 2640,2790
this whole hardware structure that

2350
01:18:50,090 --> 01:18:51,440
0,120 120,240 240,810 930,1230 1230,1350
they are using,| would it
|它是否有用，

2351
01:18:51,440 --> 01:18:53,180
0,450 600,1080 1080,1200 1200,1560 1560,1740
be useful at all,| if
|如果你将它与悲观并发控制一起使用？

2352
01:18:53,180 --> 01:18:54,650
0,210 210,510 510,600 600,780 780,1470
you're using it with pessimistic

2353
01:18:54,650 --> 01:18:56,160
0,120 120,540 540,1260
{concurrency -} control?|
|

2354
01:18:56,680 --> 01:18:58,450
0,870 870,1320 1320,1560 1560,1650 1650,1770
Yes, I'm sure you can
是的，我相信你也可以让悲观协议变得更好，

2355
01:18:58,450 --> 01:19:00,100
0,180 180,420 450,900 900,1350 1350,1650
make the pessimistic {protocol -}

2356
01:19:00,100 --> 01:19:01,870
0,240 240,540 540,1020 1020,1290 1290,1770
also better,| because {you,know,RPC -}
|因为 RPC 更便宜，

2357
01:19:01,870 --> 01:19:04,060
0,120 120,360 360,870 900,1290 1770,2190
are just cheaper, right,| but
|但真正的东西，我还没能指出这一点，

2358
01:19:04,060 --> 01:19:05,740
0,120 120,360 360,750 750,1080 1080,1680
the real thing I haven't,

2359
01:19:05,740 --> 01:19:06,520
0,210 210,420 420,570 570,720 720,780
I haven't been able to

2360
01:19:06,520 --> 01:19:07,270
0,210 210,330 330,480 480,660 660,750
point this out yet,| but
|但我试过了，

2361
01:19:07,270 --> 01:19:08,650
0,60 60,180 180,480 480,810 1140,1380
I was trying to {},|
|

2362
01:19:08,650 --> 01:19:09,640
0,210 210,270 270,360 360,480 480,990
what I can do now,|
我现在可以做，|

2363
01:19:09,880 --> 01:19:11,440
0,510 510,1020 1020,1140 1140,1260 1260,1560
{} is if you look
如果你看一下这里的只读事务，

2364
01:19:11,440 --> 01:19:12,610
0,150 150,270 270,450 450,690 690,1170
at the {read-only -} transactions

2365
01:19:12,610 --> 01:19:13,220
0,450
here,|
|

2366
01:19:13,740 --> 01:19:16,500
0,420 450,690 690,930 930,1980 2610,2760
so {read-only -} transactions,| so
只读事务，|如果这里的事务只读取一个对象或多个对象，

2367
01:19:16,500 --> 01:19:17,340
0,120 120,270 270,300 300,300 300,840
if {here -} {} transaction

2368
01:19:17,340 --> 01:19:18,420
0,90 90,390 390,450 450,750 750,1080
that basically the only {reads,an}

2369
01:19:18,420 --> 01:19:24,240
0,450 450,1110 1140,1590 1590,2250
object or multiple objects,|
|

2370
01:19:24,920 --> 01:19:26,060
0,210 210,300 300,780 780,930 930,1140
what's the performance, how good
性能会怎么样，会有多好，

2371
01:19:26,060 --> 01:19:27,170
0,120 120,420 450,630 630,870 870,1110
is that,| like how well
|它的表现会有多好？

2372
01:19:27,170 --> 01:19:28,380
0,120 120,270 270,390 390,900
is that gonna perform?|
|

2373
01:19:30,520 --> 01:19:32,410
0,420 660,1080 1080,1380 1380,1620 1620,1890
{} Probably pretty well, since
可能很好，因为你只做单边的（RDMA）。

2374
01:19:32,410 --> 01:19:34,990
0,120 120,360 360,570 570,1050 1680,2580
you only do the one-sided.|
|

2375
01:19:35,350 --> 01:19:36,790
0,600 600,1050 1050,1140 1140,1260 1260,1440
Yeah, correct, if you look
是的，如果你看一下保存在区域 3 的对象，

2376
01:19:36,790 --> 01:19:37,570
0,90 90,210 210,570 570,690 690,780
at the object that is

2377
01:19:37,570 --> 01:19:40,900
0,720 900,1860 2220,2850 2850,3060 3060,3330
{stored,at} {} region 3, correct,|
|

2378
01:19:40,900 --> 01:19:41,710
0,120 120,210 210,330 330,660 660,810
which is the object that's
它是被读取的对象，

2379
01:19:41,710 --> 01:19:43,270
0,210 210,600 750,990 990,1410 1410,1560
being read,| the only thing
|唯一发生的事情是单边读取或单边 RDMA ，

2380
01:19:43,270 --> 01:19:44,590
0,120 120,600 600,750 750,990 990,1320
that happens is {one-sided -}

2381
01:19:44,590 --> 01:19:45,740
0,420
reads

2382
01:19:48,350 --> 01:19:50,090
0,150 150,360 360,660 660,1200 1200,1740
or {one-sided -} RDMA, correct,|
|

2383
01:19:51,410 --> 01:19:56,570
0,630 690,3510 3540,4620 4620,4740 4740,5160
{} {and,there's,no,writes}, nothing at all,|
没有写入，什么都没有，|

2384
01:19:56,630 --> 01:19:58,940
0,450 450,900 1140,1620 1650,2040 2040,2310
{} so, {} those {
所以，因为这个，

2385
01:19:58,940 --> 01:20:01,280
0,210 210,660 660,750 750,1260 1860,2340
-} because of the this,|
|

2386
01:20:02,670 --> 01:20:04,350
0,360 360,780 810,1110 1110,1470 1470,1680
because the read operation don't
因为读取操作不需要锁，

2387
01:20:04,350 --> 01:20:05,640
0,420 420,870 870,1020 1020,1230 1230,1290
require locks,| there's nothing to
|没有什么可写，

2388
01:20:05,640 --> 01:20:07,800
0,150 150,660 960,1410 1470,2040 2040,2160
be written,| {} only thing
|唯一需要做的就是这个验证步骤，

2389
01:20:07,800 --> 01:20:08,490
0,90 90,270 270,360 360,600 600,690
that needs to happen is

2390
01:20:08,490 --> 01:20:10,260
0,450 450,750 750,1200 1230,1530 1530,1770
{this,validation -} step,| which also
|也是单边 RDMA ，

2391
01:20:10,260 --> 01:20:11,820
0,90 90,150 150,600 600,1290
is {} one-sided RDMA,|
|

2392
01:20:11,990 --> 01:20:13,190
0,360 360,570 570,810 810,1140 1140,1200
so {read-only -} transaction, you
所以只读事务，你可以只使用两个单边 RDMA 运行，

2393
01:20:13,190 --> 01:20:14,120
0,150 150,300 300,600 600,750 750,930
can just run with two

2394
01:20:14,120 --> 01:20:15,800
0,240 240,570 570,1260
{one-sided -} RDMAs,|
|

2395
01:20:16,180 --> 01:20:17,860
0,600 600,990 990,1470 1470,1620 1620,1680
{} and that's where the
这就是好处的来源，

2396
01:20:17,860 --> 01:20:20,260
0,240 240,390 390,690 690,990 1560,2400
big win comes from| and
|而这一点的原因是，

2397
01:20:20,260 --> 01:20:21,400
0,90 90,420 420,750 750,1050 1050,1140
the reason that point is

2398
01:20:21,400 --> 01:20:22,420
0,270 270,390 390,660 660,810 810,1020
there is,| because of the
|因为是乐观并发控制。

2399
01:20:22,420 --> 01:20:24,040
0,540 540,630 630,930 930,1380
optimistic {concurrency -} control.|
|

2400
01:20:24,400 --> 01:20:25,330
0,150 150,210 210,420 420,810 810,930
So I think basically to
所以我认为利用 RDMA []，

2401
01:20:25,330 --> 01:20:26,770
0,720 720,870 870,1230 1230,1350 1350,1440
exploit {RDMAs - -} {}

2402
01:20:26,770 --> 01:20:29,320
0,990 1050,1710 1710,2070 2070,2310 2310,2550
[], []| and I'm trying
|我试着让只读交易变得非常快，

2403
01:20:29,320 --> 01:20:30,220
0,60 60,360 360,540 540,720 720,900
to make a {read-only -}

2404
01:20:30,220 --> 01:20:33,880
0,510 510,1050 1050,1560 1950,2670 2970,3660
transactions really fast,| { -}
|它们必须是乐观并发控制。

2405
01:20:33,880 --> 01:20:35,530
0,240 240,510 510,720 720,1020 1020,1650
they got went to optimistic

2406
01:20:35,530 --> 01:20:36,540
0,90 90,420 420,780
{concurrency -} control.|
|

2407
01:20:38,390 --> 01:20:39,830
0,450 450,600 600,930 930,1020 1020,1440
Okay, I see, I see,
好的，我明白了，有道理。

2408
01:20:40,070 --> 01:20:41,900
0,330 330,810 1020,1440 1440,1710 1710,1830
makes sense.| Another question was
|另一个问题是关于安全的，

2409
01:20:41,900 --> 01:20:44,360
0,630 630,1710 1740,2250
about security,| is
|这东西安全吗，如果它是，

2410
01:20:44,850 --> 01:20:45,960
0,300 300,540 540,750 750,990 990,1110
this thing is gonna be

2411
01:20:45,960 --> 01:20:47,360
0,450 450,660 660,1140
secure, if it's,|
|

2412
01:20:47,540 --> 01:20:48,460
0,630

2413
01:20:48,770 --> 01:20:50,330
0,150 150,390 390,780 960,1290 1290,1560
I guess, {} someone already
我想已经有人已经问过这件事，

2414
01:20:50,330 --> 01:20:51,680
0,210 210,420 420,570 570,960
asked about this,| but
|但是网卡读取内存的那部分，

2415
01:20:51,820 --> 01:20:53,830
0,450 450,810 810,1290 1290,1650 1650,2010
the part where the NIC

2416
01:20:53,830 --> 01:20:55,870
0,360 390,780 780,1470 1590,1980 1980,2040
just reads memory,| {it,seems} a
|这看起来有点吓人，所以。

2417
01:20:55,870 --> 01:20:58,810
0,210 210,960 1080,2100 2100,2250 2520,2940
little {scary\,,so}.| Yeah, {it's,totally} scary,|
|是的，真的很吓人，|

2418
01:20:59,410 --> 01:21:01,150
0,480 480,690 690,810 810,1320 1320,1740
{} and so there's there's
所以，有一系列的交互，

2419
01:21:01,150 --> 01:21:02,620
0,120 120,330 330,390 390,1080 1080,1470
a bunch of interaction {}

2420
01:21:02,620 --> 01:21:03,940
0,630 630,690 690,840 840,1110 1110,1320
between,| you know when the
|当设置 RDMA 时，

2421
01:21:03,940 --> 01:21:05,530
0,540 540,960 960,1050 1050,1260 1260,1590
RDMA connection is {setup -}|
|

2422
01:21:05,680 --> 01:21:06,880
0,360 360,480 480,840 840,1140 1140,1200
{} the operating system and
在操作系统和应用程序之间，

2423
01:21:06,880 --> 01:21:07,800
0,90 90,690
the application,|
|

2424
01:21:09,780 --> 01:21:10,800
0,180 180,270 270,540 540,780 780,1020
so the operating system won't
所以，操作系统不允许网卡写入任何任意位置，

2425
01:21:10,800 --> 01:21:12,390
0,480 480,810 810,1140 1140,1260 1260,1590
allow the NIC to write

2426
01:21:12,390 --> 01:21:14,220
0,90 90,690 690,1200 1200,1740 1740,1830
to any arbitrary location,| will
|会告诉它，这里的地址，

2427
01:21:14,220 --> 01:21:16,410
0,390 780,930 930,1260 1260,1650 1680,2190
{tell,it}, {you,know} here the addresses,|
|这是你可以写入的虚拟内存地址。

2428
01:21:16,410 --> 01:21:18,510
0,510 510,930 1200,1680 1680,1830 1860,2100
here's the VM, {} virtual

2429
01:21:18,510 --> 01:21:19,530
0,270 270,660 660,810 810,900 900,1020
memory addresses, that you can

2430
01:21:19,530 --> 01:21:20,320
0,180 180,300
write to.|
|

2431
01:21:21,230 --> 01:21:22,700
0,300 300,390 390,510 510,960 1140,1470
Okay, so you can make
好的，所以你可以让它[]。

2432
01:21:22,700 --> 01:21:24,620
0,510 690,1440
that [].|
|

2433
01:21:24,790 --> 01:21:25,840
0,300 300,720
Okay.| Exactly.|
好的。|没错。|

2434
01:21:26,150 --> 01:21:30,260
0,1050 1050,1350 1350,1860 2100,3060 3780,4110
Question about the performance,| so
关于性能的问题，|所以读取是很快的，

2435
01:21:30,260 --> 01:21:31,910
0,270 270,420 420,840 960,1200 1200,1650
if you have, so the

2436
01:21:31,910 --> 01:21:33,680
0,300 300,570 570,930 1020,1410 1410,1770
reads are {} quick,| because
|因为单边的 RDMA ，

2437
01:21:33,680 --> 01:21:35,180
0,180 180,540 540,840 840,1230 1230,1500
of the {one-sided -} {RDMAs

2438
01:21:35,180 --> 01:21:37,010
0,600 1380,1530 1530,1620 1620,1710 1710,1830
-},| but if you have
|但如果你有大量的写入，

2439
01:21:37,010 --> 01:21:38,720
0,60 60,300 300,690 750,1200 1200,1710
a lot of writes happening,|
|

2440
01:21:38,720 --> 01:21:39,680
0,330 330,480 480,660 660,720 720,960
like a lot of data
比如大量的数据和争执。

2441
01:21:39,680 --> 01:21:41,900
0,150 150,900 1020,1560 1740,1980 1980,2220
and contention.| { -} Yeah.|
|是的。|

2442
01:21:41,900 --> 01:21:44,000
0,240 240,420 420,870 900,1470 1530,2100
So the case, or.| No,
所以这种情况，还是。|不，如果有争执会发生什么，

2443
01:21:44,000 --> 01:21:45,230
0,630 630,780 780,1020 1020,1140 1140,1230
correct, what happens if you

2444
01:21:45,230 --> 01:21:46,730
0,120 120,630 750,1230 1230,1380 1380,1500
have contention,| actually we saw
|我们在这个案例中看到了，

2445
01:21:46,730 --> 01:21:47,780
0,180 180,270 270,390 390,750 750,1050
this in this particular case,

2446
01:21:47,780 --> 01:21:48,340
0,420
correct,|
|

2447
01:21:49,590 --> 01:21:52,240
0,1260 1830,2370
yeah, {}
如果我们有很多争执，

2448
01:21:52,860 --> 01:21:53,370
0,180 180,270 270,360 360,360 360,510
if we have a lot

2449
01:21:53,370 --> 01:21:54,480
0,90 90,420 420,570 570,660 660,1110
of contention,| one of the
|其中一个事务将中止，

2450
01:21:54,510 --> 01:21:55,740
0,390 390,930
transaction {will,abort},|
|

2451
01:21:57,310 --> 01:21:58,510
0,210 210,390 390,480 480,1110 1110,1200
so this is really you
所以这是对事务有好处的，

2452
01:21:58,510 --> 01:22:00,010
0,120 120,390 390,570 570,1140 1140,1500
know good for transactions,| that
|不[]或不写入相同记录或相同对象。

2453
01:22:00,010 --> 01:22:01,960
0,240 240,870 1080,1380 1380,1650 1650,1950
don't content or not writing

2454
01:22:01,960 --> 01:22:03,100
0,90 90,180 180,480 480,930 960,1140
to the same records or

2455
01:22:03,100 --> 01:22:04,120
0,240 240,750
same objects.|
|

2456
01:22:05,200 --> 01:22:06,580
0,330 330,540 540,630 630,960 960,1380
And even the reads, right?|
甚至是读取，是吗？|

2457
01:22:07,510 --> 01:22:08,830
0,360 360,600 600,870 870,1260 1260,1320
Yeah, even {the,reads},| because the
是的，即使是读取，|因为版本号可能会改变。

2458
01:22:08,830 --> 01:22:10,300
0,270 270,540 540,660 660,1200
version numbers may change.|
|

2459
01:22:13,200 --> 01:22:14,370
0,210 210,420 420,630 630,720 720,1170
So what's like the main,
那么，我想主要的用例是什么？

2460
01:22:14,370 --> 01:22:15,840
0,390 420,570 570,870 870,1110 1110,1470
{} I guess use case

2461
01:22:15,840 --> 01:22:16,740
0,600
for?|
|

2462
01:22:17,030 --> 01:22:17,810
0,210 210,360 360,420 420,570 570,780
{} There's a lot of,
有很多研究独立于这个论文，

2463
01:22:17,810 --> 01:22:19,010
0,90 90,540 540,870 870,960 960,1200
you know there's a lot

2464
01:22:19,010 --> 01:22:20,990
0,60 60,600 600,1110 1110,1680 1680,1980
of studies independent {of,this,paper}| about
|关于悲观与乐观并发控制，

2465
01:22:20,990 --> 01:22:22,550
0,510 510,750 750,1170 1170,1260 1260,1560
pessimistic versus optimistic {concurrency -}

2466
01:22:22,550 --> 01:22:23,440
0,480
control,|
|

2467
01:22:23,640 --> 01:22:25,680
0,510 510,1260 1260,1410 1410,1590 1590,2040
{} and you know clearly
从这两个基准中，

2468
01:22:25,680 --> 01:22:27,150
0,270 270,540 540,690 690,1230 1230,1470
from the two benchmarks,| they
|他们在论文中使用的，比如 TPC-C 和 TATP ，

2469
01:22:27,150 --> 01:22:28,560
0,300 300,390 390,750 750,930 930,1410
{use,in} the paper, like {TPC-C

2470
01:22:28,560 --> 01:22:30,360
0,330 330,450 450,1290 1440,1620 1620,1800
-} and TATP,| {} there's
|没有太多的冲突，

2471
01:22:30,360 --> 01:22:33,030
0,690 690,1500 1530,1980 1980,2040 2040,2670
not a lot of conflicts,|
|

2472
01:22:35,670 --> 01:22:36,990
0,240 240,720 720,810 810,1080 1080,1320
{so,this,is} {actually -} submitted maybe
所以可能是由不同的用户或不同的客户端提交的，

2473
01:22:36,990 --> 01:22:38,220
0,120 120,360 360,900 900,990 990,1230
by different users or different

2474
01:22:38,220 --> 01:22:39,540
0,480 480,600 600,720 720,1050 1050,1320
clients,| and they basically touch
|它们接触的是不同的[表]。

2475
01:22:39,540 --> 01:22:40,620
0,240 240,780
different [tables].|
|

2476
01:22:45,650 --> 01:22:47,180
0,210 210,300 300,510 510,720 720,1530
So I have a question,|
我有一个问题，|

2477
01:22:47,210 --> 01:22:49,670
0,660 690,930 930,1200 1200,1710 1710,2460
{} if there's multiple clients
如果有多个客户端在同一对象上执行事务，

2478
01:22:50,170 --> 01:22:52,210
0,420 420,1410 1410,1590 1590,1680 1680,2040
doing transactions on the same

2479
01:22:52,210 --> 01:22:54,940
0,810 930,1470 1590,2340
object, { -}|
|

2480
01:22:55,170 --> 01:22:56,910
0,870 930,1170 1170,1440 1440,1650 1650,1740
how, so they want to
它们想要执行写入 RDMA ，写入到日志，

2481
01:22:56,910 --> 01:22:58,680
0,150 150,510 510,870 870,1440 1440,1770
do a write RDMA, write

2482
01:22:58,680 --> 01:23:00,540
0,690 690,840 840,960 960,1560
to to the log,|
|

2483
01:23:00,970 --> 01:23:02,080
0,810

2484
01:23:02,960 --> 01:23:04,310
0,210 210,390 390,960 960,1140 1140,1350
is it possible that there
有没有可能会发生冲突，

2485
01:23:04,310 --> 01:23:05,750
0,120 120,240 240,450 450,1170 1170,1440
would be {} conflict,| like
|比如其中一个会重写另一个日志，或者。

2486
01:23:05,750 --> 01:23:06,650
0,120 120,270 270,540 540,810 810,900
{ -} like one of

2487
01:23:06,650 --> 01:23:07,580
0,180 180,330 330,570 570,840 840,930
them will write over the

2488
01:23:07,580 --> 01:23:09,170
0,270 270,750 750,1050 1050,1110 1110,1590
other log, or.| {No,no -},
|不，不，每对都有一把锁，

2489
01:23:09,170 --> 01:23:11,180
0,240 240,450 450,750 750,1410 1440,2010
there's one lock per pair,|
|

2490
01:23:11,860 --> 01:23:13,930
0,300 300,690 690,810 870,1740 1770,2070
{} One {lock,per,pair}, okay.| So
每对都有一把锁，好的。|所以，这正是原因所在。

2491
01:23:13,930 --> 01:23:15,250
0,420 420,660 660,960 960,1050 1050,1320
every this exactly the reason

2492
01:23:15,250 --> 01:23:16,040
0,420
why.|
|

2493
01:23:17,040 --> 01:23:18,690
0,240 240,420 420,660 660,660 1260,1650
And and then, {} but
然后，但是在事务中，比如时间，

2494
01:23:18,720 --> 01:23:21,600
0,690 690,1230 1260,2130 2130,2370 2370,2880
{} in transactions like time,|
|

2495
01:23:21,630 --> 01:23:23,880
0,120 120,420 420,1500 1530,1560 1560,2250
is it like {you,know} to
它是否提供可串行化，

2496
01:23:23,880 --> 01:23:26,940
0,690 780,1830 2190,2340 2340,2550 2550,3060
provide serializability,| is it time
|时间基于什么？

2497
01:23:27,000 --> 01:23:29,040
0,1140 1140,1290 1290,1740
based on what?|
|

2498
01:23:29,260 --> 01:23:30,500
0,240 240,300 300,510 510,930
On the version number.|
基于版本号。|

2499
01:23:30,880 --> 01:23:31,680
0,480

2500
01:23:31,940 --> 01:23:33,170
0,210 210,570 570,720 720,930 930,1230
There's nothing like {TrueTime -}
这里没有 TrueTime 或类似的东西，

2501
01:23:33,170 --> 01:23:34,280
0,120 120,390 390,600 600,780 780,1110
or anything like that here,|
|

2502
01:23:34,740 --> 01:23:36,060
0,360 360,540 540,870 870,1170 1170,1320
{} these logical numbers, like
这些逻辑编号，就像实验 3 中一样，

2503
01:23:36,060 --> 01:23:36,960
0,90 90,390 390,630 630,810 810,900
in same way as in

2504
01:23:36,960 --> 01:23:39,000
0,750 750,1050 1050,1230 1230,1620 1620,2040
{lab,3},| where you have logical
|你有逻辑编号，

2505
01:23:39,000 --> 01:23:40,200
0,360 360,840
sequence numbers,|
|

2506
01:23:40,670 --> 01:23:42,320
0,330 330,750 750,1230 1230,1320 1320,1650
for implementing your {key-value -}
用于实现键值存储，

2507
01:23:42,320 --> 01:23:43,020
0,390
store,|
|

2508
01:23:43,460 --> 01:23:44,840
0,390 390,720 720,1080 1080,1320 1320,1380
there's numbers basically played the
这些编号起到了同样的作用。

2509
01:23:44,840 --> 01:23:45,740
0,240 240,630
same role.|
|

2510
01:23:53,940 --> 01:23:55,560
0,240 240,540 540,900 900,1440 1440,1620
Well, if two number of
如果两个事务得到了相同的编号，

2511
01:23:55,560 --> 01:23:57,240
0,180 180,780 780,990 990,1050 1050,1680
two transactions got the same

2512
01:23:57,720 --> 01:23:59,790
0,780 780,1200 1440,1770 1770,1860 1860,2070
number,| then only the one
|那么只有先到达提交点的那个才会。

2513
01:23:59,790 --> 01:24:01,140
0,390 390,720 720,810 810,960 960,1350
that got to the commit

2514
01:24:01,140 --> 01:24:03,300
0,360 360,840 840,960 960,1380 1800,2160
point first is going.| Yeah,
|好的。

2515
01:24:03,300 --> 01:24:03,960
0,480
okay.|
|

2516
01:24:04,640 --> 01:24:05,570
0,180 180,390 390,450 450,630 630,930
Yeah, this is this case,
是的，就是这个案例，

2517
01:24:05,570 --> 01:24:06,200
0,330
right,|
|

2518
01:24:06,770 --> 01:24:07,970
0,240 240,450 450,840 840,1050 1050,1200
one {abort -}, {the,other} {one
一个中止，另一个成功。

2519
01:24:07,970 --> 01:24:08,880
0,150 150,600
-} succeed.|
|

2520
01:24:11,880 --> 01:24:13,980
0,930 1590,1770 1770,1890 1890,2040 2040,2100
Okay.| If there is a
好的。|如果在每一对之间建立了消息队列，

2521
01:24:13,980 --> 01:24:15,720
0,390 390,630 630,840 840,1110 1320,1740
message queue that is basically

2522
01:24:15,720 --> 01:24:18,120
0,630 630,960 960,1200 1200,1740 2010,2400
established between every pair,| then
|那你怎么知道，

2523
01:24:18,120 --> 01:24:20,040
0,270 270,360 360,540 540,1230 1680,1920
how do you know,| so
|你将拥有多个消息队列，给 primary ，

2524
01:24:20,040 --> 01:24:21,750
0,210 210,360 360,690 690,1110 1110,1710
then you have multiple message

2525
01:24:21,750 --> 01:24:24,270
0,690 1410,1860 1860,2280 2280,2430 2430,2520
queues, given primary,| how do
|你怎么知道读取这些东西的顺序，

2526
01:24:24,270 --> 01:24:25,320
0,90 90,300 300,630 630,930 930,1050
you know which order to

2527
01:24:25,320 --> 01:24:27,090
0,210 210,510 510,810 1350,1590 1590,1770
read those| and you don't
|而且不会乱读它们的顺序。

2528
01:24:27,090 --> 01:24:28,170
0,150 150,300 300,450 450,540 540,1080
read them out of order.|
|

2529
01:24:28,650 --> 01:24:32,760
0,2790 2790,3090 3390,3660 3660,3900 3900,4110
{There,is -}, you read all
你以相同的顺序读取同一来源的所有消息，

2530
01:24:32,760 --> 01:24:34,410
0,90 90,480 480,660 660,1110 1110,1650
the messages from one source

2531
01:24:34,410 --> 01:24:35,370
0,90 90,180 180,450 450,720 720,960
in the same order, correct,|
|

2532
01:24:35,370 --> 01:24:36,570
0,240 240,420 420,570 570,720 720,1200
because they're all gonna be
因为它们都会在一个队列里，

2533
01:24:36,600 --> 01:24:37,620
0,150 150,390 390,900
in one queue,|
|

2534
01:24:37,810 --> 01:24:39,130
0,240 240,510 510,810 810,1050 1050,1320
so one source {writes,to} one
所以一个来源写入一个队列，

2535
01:24:39,130 --> 01:24:39,820
0,390
queue,|
|

2536
01:24:40,240 --> 01:24:43,720
0,480 510,1560 1710,2520 2550,3210 3210,3480
{} multiple {} machines like
多台机器同时写入不同的队列，

2537
01:24:43,720 --> 01:24:45,250
0,390 390,480 480,570 570,1020 1020,1530
write you know concurrently to

2538
01:24:45,250 --> 01:24:47,170
0,300 300,660 660,1200 1440,1800 1800,1920
{} different queues,| {} you
|你不知道顺序是什么，

2539
01:24:47,170 --> 01:24:47,950
0,150 150,270 270,450 450,540 540,780
don't know what the order

2540
01:24:47,950 --> 01:24:48,940
0,810
anyway,|
|

2541
01:24:49,770 --> 01:24:51,390
0,270 270,840 840,1110 1110,1410 1410,1620
so it couldn't affect the
所以，它不能影响协议的正确性。

2542
01:24:51,750 --> 01:24:53,140
0,390 390,480 480,570 570,1080
correctness of the protocol.|
|

2543
01:24:54,270 --> 01:24:55,110
0,150 150,390 390,540 540,630 630,840
I see, so we don't
我明白了，所以我们不依赖于传入并发消息的顺序。

2544
01:24:55,110 --> 01:24:56,400
0,240 240,360 360,450 450,1080 1080,1290
rely on the orderings of

2545
01:24:56,400 --> 01:24:59,130
0,480 870,1350 1350,1830 1830,2460 2490,2730
the incoming concurrent messages.| That's
|没错，你是按一定的顺序轮询的，

2546
01:24:59,130 --> 01:25:00,240
0,390 390,660 660,900 900,1050 1050,1110
correct, you poll them in

2547
01:25:00,240 --> 01:25:01,560
0,240 240,660 660,750 750,1170 1230,1320
some order,| and then you
|然后你按一定的顺序轮询队列，

2548
01:25:01,560 --> 01:25:02,370
0,210 210,270 270,510 510,600 600,810
poll the queues in some

2549
01:25:02,370 --> 01:25:03,570
0,360 360,600 600,690 690,1020 1020,1200
order,| that's the way, that's
|这就是要处理的方式。

2550
01:25:03,570 --> 01:25:04,380
0,90 90,300 300,480 480,720 720,810
the way that's going to

2551
01:25:04,380 --> 01:25:05,360
0,240 240,810
be processed.|
|

2552
01:25:06,950 --> 01:25:08,780
0,270 270,540 600,1140 1140,1350 1350,1830
Got it,| also one more
明白了，|还有一个更具体的问题，

2553
01:25:08,900 --> 01:25:11,900
0,540 540,1230 1500,2100 2370,2820 2820,3000
specific question,| {} there's a
|论文中的一部分提供了无锁读取，

2554
01:25:11,900 --> 01:25:12,890
0,300 300,540 540,840 840,930 930,990
part where this is a

2555
01:25:12,890 --> 01:25:14,930
0,420 420,690 690,1230 1230,1710 1740,2040
paper, that provides lock {lock-free,reads

2556
01:25:14,930 --> 01:25:16,310
0,450 450,690 690,930 930,1140 1140,1380
-},| which we've just talked
|也就是我们刚才谈到的，

2557
01:25:16,310 --> 01:25:18,410
0,420 780,1230 1230,1440 1440,1710 1710,2100
about,| but it also says,
|但它也表示，它还提供了本地线索，

2558
01:25:18,410 --> 01:25:20,330
0,210 210,570 660,1140 1140,1440 1440,1920
it { -} also provides

2559
01:25:20,330 --> 01:25:23,480
0,750 750,1350 1500,1860 1860,2400 2400,3150
locality hints,| which enable programmers
|使程序员能够将同一组机器上的相关对象相互关联。

2560
01:25:23,480 --> 01:25:25,550
0,210 240,570 570,1050 1050,1530 1530,2070
to co relate related objects

2561
01:25:25,550 --> 01:25:26,450
0,180 180,270 270,630 630,840 840,900
on the same set of

2562
01:25:26,450 --> 01:25:28,370
0,840 870,1050 1050,1410 1590,1770 1770,1920
machines.| {Yeah -}.| And I
|是的。|我不理解那个，

2563
01:25:28,370 --> 01:25:29,680
0,150 150,390 390,840 840,1140
do not understand that,|
|

2564
01:25:29,820 --> 01:25:31,200
0,450 450,570 570,1050 1050,1290 1290,1380
{} the latter part of
句子的后半部分。

2565
01:25:31,200 --> 01:25:32,320
0,60 60,870
the sentence.|
|

2566
01:25:32,550 --> 01:25:34,530
0,690 690,900 900,1020 1020,1530 1530,1980
{} Okay, so I I
好的，我得查一下细节是什么，

2567
01:25:34,530 --> 01:25:35,070
0,120 120,180 180,330 330,450 450,540
have to look up the

2568
01:25:35,070 --> 01:25:35,910
0,330 330,450 450,570 570,720 720,840
details what it is,| but
|但我想你指的是，

2569
01:25:35,910 --> 01:25:36,780
0,30 30,210 210,330 330,480 480,870
I think what you're referring

2570
01:25:36,780 --> 01:25:38,040
0,180 180,360 360,600 600,750 750,1260
to is that,| if you,
|如果你的对象在各种不同的区域，

2571
01:25:38,220 --> 01:25:39,660
0,420 510,750 750,1020 1020,1320 1320,1440
like if your objects are

2572
01:25:39,660 --> 01:25:40,920
0,270 270,450 450,540 540,810 810,1260
all kinds of different regions,

2573
01:25:40,920 --> 01:25:41,880
0,240 240,450 480,780 780,900 900,960
correct,| like, let's look at
|比如，让我们看看这张图片，

2574
01:25:41,880 --> 01:25:43,060
0,150 150,480 480,990
this picture here,|
|

2575
01:25:43,230 --> 01:25:44,220
0,510 510,630 630,750 750,930 930,990
then you would have to
然后你必须和很多不同的 primary 进行交互，

2576
01:25:44,220 --> 01:25:45,600
0,240 240,390 390,660 660,750 750,1380
talk to lots of different

2577
01:25:45,630 --> 01:25:47,670
0,900 1140,1440 1440,1590 1590,1920 1920,2040
primaries, right,| so if {you,like}
|如果对象 1 在这个 primary ，

2578
01:25:47,670 --> 01:25:49,680
0,390 390,840 840,1050 1050,1350 1350,2010
object one {is,in} this primary,|
|

2579
01:25:49,710 --> 01:25:51,330
0,420 420,600 600,660 660,960 960,1620
object two {is,in} this primary,|
对象 2 在这个 primary ，|

2580
01:25:51,630 --> 01:25:52,920
0,720 720,990 990,1050 1050,1200 1200,1290
{} and if you are
如果你接触到很多，

2581
01:25:52,920 --> 01:25:54,720
0,300 300,630 630,1350 1350,1500 1500,1800
touching many,| if you're touching
|如果你总是接触一个集群的对象，

2582
01:25:54,720 --> 01:25:55,860
0,360 360,420 420,720 720,780 780,1140
always a cluster of objects

2583
01:25:55,860 --> 01:25:57,240
0,540 630,750 750,930 930,1050 1050,1380
together,| it would be nice,
|这是好的，如果所有对象集群都在同一个 primary 上，

2584
01:25:57,240 --> 01:25:58,230
0,60 60,210 210,480 480,570 570,990
if that cluster of objects

2585
01:25:58,230 --> 01:25:59,310
0,180 180,270 270,330 330,570 570,1080
all at the same primary,|
|

2586
01:25:59,910 --> 01:26:00,690
0,180 180,360 360,570 570,690 690,780
so you only have to
所以你只需联系一个 primary ，而不是多个。

2587
01:26:00,690 --> 01:26:01,920
0,330 330,540 540,930 930,1170 1170,1230
contact one primary instead of

2588
01:26:01,920 --> 01:26:02,620
0,390
many.|
|

2589
01:26:05,520 --> 01:26:07,040
0,270 270,630 660,930 930,1200
I see, thank you.|
我明白了，谢谢。|

2590
01:26:13,170 --> 01:26:14,660
0,450 450,690 690,1230
Any further questions?|
还有什么问题吗？|

2591
01:26:18,180 --> 01:26:20,160
0,510 510,1110 1170,1440 1440,1860 1860,1980
So this, so FaRM is
所以 FaRM 不是很适合长的事务，

2592
01:26:20,160 --> 01:26:22,050
0,270 270,450 450,960 960,1440 1470,1890
not really suitable for long

2593
01:26:22,050 --> 01:26:26,220
0,1230 1350,1890 1920,2730 2970,3600 3750,4170
transactions, right,| because because most.|
|因为大多数。|

2594
01:26:27,240 --> 01:26:28,560
0,450 450,660 660,1020 1020,1110 1110,1320
Yeah, you're worried {} long
是的，你担心长的事务会导致冲突。

2595
01:26:28,560 --> 01:26:29,520
0,60 60,540 540,690 690,810 810,960
of transactions that you get

2596
01:26:29,520 --> 01:26:30,320
0,630
conflicts.|
|

2597
01:26:32,290 --> 01:26:33,970
0,150 150,390 390,600 600,1230 1290,1680
I mean, it also is
我的意思是，我猜只读交易，

2598
01:26:33,970 --> 01:26:36,190
0,720 720,810 810,1350 1620,2010 2010,2220
assuming, I guess {read-only -}

2599
01:26:36,190 --> 01:26:38,770
0,720 720,1290 1530,1770 1770,1980 1980,2580
transactions,| since we're really optimized
|因为我们为它们做了优化。

2600
01:26:38,770 --> 01:26:41,410
0,90 90,270 270,660 720,1200 1620,2640
for them, right.| Yeah, absolutely,|
|是的，当然，|

2601
01:26:41,410 --> 01:26:43,000
0,300 300,870 870,1200 1200,1410 1410,1590
many transactions {you,know} people done
很多事务人们都在研究，

2602
01:26:43,000 --> 01:26:44,350
0,420 420,660 660,780 780,1140 1140,1350
studies,| and you know you
|你在 Spanner 论文上也看到了，

2603
01:26:44,350 --> 01:26:45,400
0,180 180,330 330,450 450,900 900,1050
saw in Spanner paper too,

2604
01:26:45,400 --> 01:26:46,060
0,360
correct,|
|

2605
01:26:46,250 --> 01:26:47,720
0,570 600,690 690,990 990,1380 1380,1470
where a large fraction of
其中很大一部分事务是只读事务，

2606
01:26:47,720 --> 01:26:49,040
0,270 270,780 780,930 930,1110 1110,1320
the transactions are {read-only -}

2607
01:26:49,040 --> 01:26:49,960
0,660
transactions,|
|

2608
01:26:53,710 --> 01:26:54,670
0,180 180,300 300,630 630,690 690,960
but that's clearly {} property
但这显然是工作量所致。

2609
01:26:54,670 --> 01:26:55,620
0,60 60,150 150,630
of the workload.|
|

2610
01:27:01,300 --> 01:27:03,130
0,660 750,900 900,1260 1290,1440 1440,1830
{} I had, I think,
我想回到我之前的问题，

2611
01:27:03,650 --> 01:27:04,910
0,330 330,750 750,840 840,960 960,1260
going back to my earlier

2612
01:27:04,910 --> 01:27:06,620
0,330 330,480 480,630 630,870 870,1710
question,| I think I realized,
|我想我意识到，我误解了严格串行化的基础，

2613
01:27:07,100 --> 01:27:10,070
0,240 240,510 510,1590 1650,2640 2640,2970
I was misunderstanding [basic] about

2614
01:27:10,070 --> 01:27:13,370
0,270 270,750 750,1470 2880,3120 3120,3300
strict {serializability -},| is it,
|是不是，严格，

2615
01:27:13,370 --> 01:27:16,160
0,600 1320,1980 1980,2370 2370,2580 2580,2790
so {} strict,| so okay,
|好的，这是一个情况，

2616
01:27:16,160 --> 01:27:17,750
0,150 150,540 540,720 720,900 900,1590
so here's here's a situation,|
|

2617
01:27:18,350 --> 01:27:20,480
0,630 810,1020 1020,1290 1290,1530 1530,2130
{} say here's one transaction
假设有一个事务先开始，

2618
01:27:20,480 --> 01:27:22,940
0,180 180,630 630,1170 1170,1500 1590,2460
that begins first,| that writes
|它写入分片 1 ， 分片 2 以及读取分片 3 ，

2619
01:27:23,030 --> 01:27:24,890
0,390 390,720 720,1140 1140,1470 1470,1860
{} shard 1, shard 2

2620
01:27:24,890 --> 01:27:26,220
0,180 180,390 390,750 750,1170
and read shard 3,|
|

2621
01:27:27,700 --> 01:27:28,900
0,120 120,240 240,540 600,930 930,1200
and so that that begins
所以像第一次那样开始。

2622
01:27:28,900 --> 01:27:32,290
0,180 180,600 600,990 1110,2610 2610,3390
like first time.| Write object.|
|写入对象。|

2623
01:27:33,100 --> 01:27:37,000
0,390 390,1200 1380,2880 2880,3060 3060,3900
Write 0.| Write x 0,
写入 0 。|写入 x0 ，写入 y0 。

2624
01:27:37,030 --> 01:27:38,830
0,600 600,780 780,1440 1530,1650 1650,1800
{write,y} {} 0.| And then
|然后读取 z 。

2625
01:27:38,830 --> 01:27:42,400
0,510 510,1020 1320,1620 1620,2130 2160,3570
reads z.| Okay, reads z0.|
|好的，读取 z0 。|

2626
01:27:43,180 --> 01:27:45,430
0,810 1020,1320 1320,1590 1590,1980 1980,2250
And then say, there's this
然后，假设有第二个事务在事务 1 开始后开始。

2627
01:27:45,430 --> 01:27:48,310
0,390 390,1350 1470,1710 1710,2130 2130,2880
second transaction that begins after

2628
01:27:48,310 --> 01:27:50,290
0,630 630,780 780,1350 1680,1860 1860,1980
transaction 1 started.| You know
|比如在这里？

2629
01:27:50,290 --> 01:27:52,930
0,210 210,690 1230,2160 2250,2430 2430,2640
like here?| Yeah, and it
|是的，它写入 z 。

2630
01:27:52,930 --> 01:27:53,700
0,690
writes

2631
01:27:53,940 --> 01:27:54,860
0,600
z.|
|

2632
01:27:55,670 --> 01:27:57,710
0,270 270,720 720,1230 1230,1740 1770,2040
So before before {} write
所以在写入 z 之前，

2633
01:27:57,710 --> 01:27:58,940
0,180 180,270 270,540 540,930 930,1230
z,| it must read z
|必须读取 z 。

2634
01:27:58,940 --> 01:28:01,310
0,420 750,1170 1170,1770 1800,2070 2070,2370
[].| {} Yeah.| And so
|是的。|所以读取 z ，它读取的版本号是什么？

2635
01:28:01,310 --> 01:28:03,260
0,120 120,1020 1230,1470 1470,1740 1740,1950
read z, what version number

2636
01:28:03,260 --> 01:28:04,140
0,180 180,270 270,600
does it read?|
|

2637
01:28:05,740 --> 01:28:06,740
0,630

2638
01:28:07,260 --> 01:28:08,520
0,150 150,600 630,780 780,1020 1020,1260
The same, the same one
一样的。

2639
01:28:09,810 --> 01:28:12,120
0,600 840,1260 1260,1380 1380,1650 1650,2310
to.| And then say reads
|然后尝试写入 z ，

2640
01:28:12,120 --> 01:28:13,440
0,270 270,510 510,630 630,870 870,1320
that tries to write z,|
|

2641
01:28:16,500 --> 01:28:17,670
0,300 300,570 570,690 690,930 930,1170
{} and then say {T2
然后加入 T2 在 T1 提交之前提交。

2642
01:28:17,670 --> 01:28:19,260
0,300 300,840 840,1170 1170,1380 1380,1590
-} commits before {T1 -}

2643
01:28:19,260 --> 01:28:20,220
0,720
commits.|
|

2644
01:28:21,900 --> 01:28:23,540
0,1290

2645
01:28:23,860 --> 01:28:25,480
0,780 780,960 960,1080 1080,1230 1230,1620
Yes, okay, so this commits
好的，所以这个提交。

2646
01:28:25,480 --> 01:28:26,180
0,390
yep.|
|

2647
01:28:26,600 --> 01:28:27,770
0,210 210,540 540,720 720,900 900,1170
And then {T1 -} commits
然后 T1 在 T2 提交之后提交。

2648
01:28:27,770 --> 01:28:29,360
0,300 300,780 810,1170 1170,1410 1410,1590
after T2 commits.| {We'll -}
|我们试着提交，

2649
01:28:29,360 --> 01:28:31,220
0,270 270,390 390,780 810,1290 1470,1860
try to commit, correct,| now,
|现在，我们将持有锁，为了验证，等等，

2650
01:28:31,220 --> 01:28:33,080
0,240 240,510 510,780 780,960 960,1860
we'll start doing this hold

2651
01:28:33,080 --> 01:28:35,630
0,420 420,630 630,1410 1410,2130 2130,2550
lock for validation {blah,blah,blah}, correct,|
|

2652
01:28:36,750 --> 01:28:39,420
0,330 330,1140 1830,2370 2370,2490 2490,2670
so before before, so what's
所以什么会发生，

2653
01:28:39,420 --> 01:28:40,770
0,210 210,480 480,1020 1020,1140 1140,1350
gonna happen, correct,| you know
|我要给你举这个例子，

2654
01:28:40,770 --> 01:28:41,460
0,180 180,300 300,420 420,480 480,690
I was going to give

2655
01:28:41,460 --> 01:28:42,780
0,150 150,300 300,900 960,1140 1140,1320
you this example,| {} this
|这是我在下一节课上讲的一个例子，

2656
01:28:42,780 --> 01:28:43,620
0,60 60,150 210,660 660,750 750,840
is an example that I'm

2657
01:28:43,620 --> 01:28:44,760
0,300 300,420 420,600 600,930 930,1140
saying for next lecture,| but,
|但是发生的是， z 会获得，

2658
01:28:45,840 --> 01:28:48,150
0,870 870,1230 1230,1350 1350,1830 1830,2310
{} basically what happened z

2659
01:28:48,150 --> 01:28:49,170
0,150 150,240 240,600 660,870 870,1020
would be get,| z will
|z 会获得 1 ，

2660
01:28:49,170 --> 01:28:50,220
0,390 390,780
get 1,|
|

2661
01:28:50,970 --> 01:28:52,650
0,180 180,330 330,780 780,1230 1260,1680
at this point, the z
在这一点上， z 是版本 1 ，

2662
01:28:52,650 --> 01:28:53,370
0,180 180,330 330,390 390,660 660,720
will be a version of

2663
01:28:53,370 --> 01:28:55,410
0,240 240,660 1260,1470 1470,1530 1530,2040
1, correct,| so the validation
|所以，验证阶段将在提交之后运行，

2664
01:28:55,410 --> 01:28:56,400
0,270 270,420 420,630 630,930 930,990
phase will run after the

2665
01:28:56,400 --> 01:28:57,540
0,330 330,540 540,630 630,780 780,1140
commit,| that's what you said.|
|这就是你说的。|

2666
01:28:57,990 --> 01:28:59,430
0,420 750,1020 1020,1110 1110,1410 1410,1440
Right.| And so here's a
是的。|所以这里是对 z 的验证，

2667
01:28:59,430 --> 01:29:00,820
0,570 570,660 660,1080
validation of z,|
|

2668
01:29:01,220 --> 01:29:02,570
0,720 720,840 840,990 990,1200 1200,1350
and you know it has
它有 0 ，

2669
01:29:02,570 --> 01:29:04,190
0,510 510,750 930,1350 1350,1470 1470,1620
0, right,| and now it's
|现在是 1 ，事务将被中止。

2670
01:29:04,190 --> 01:29:06,050
0,390 390,720 720,1080 1080,1380 1410,1860
1 and will {} transaction

2671
01:29:06,050 --> 01:29:07,880
0,120 120,210 210,600 1080,1590 1590,1830
will be abort.| Okay, so
|好的，这就是我想知道的，

2672
01:29:07,880 --> 01:29:08,420
0,150 150,240 240,360 360,420 420,540
this is what I was

2673
01:29:08,420 --> 01:29:10,040
0,270 270,480 480,690 690,1170 1170,1620
wondering about that,| so because
|因为在验证阶段过去之后，

2674
01:29:10,100 --> 01:29:13,010
0,360 360,450 450,1080 1080,1800 1860,2910
after the validation phase passes,|
|

2675
01:29:13,160 --> 01:29:13,820
0,180 180,270 270,330 330,600 600,660
there was a period of
有一段时间，

2676
01:29:13,820 --> 01:29:14,800
0,780
time,|
|

2677
01:29:16,190 --> 01:29:18,740
0,390 390,450 450,1290 1590,2100 2100,2550
after the validation phase passes,|
在验证阶段过去之后，|

2678
01:29:18,740 --> 01:29:19,580
0,120 120,330 330,390 390,540 540,840
a period of time passes,
经过一段时间，它提交，

2679
01:29:19,580 --> 01:29:21,500
0,240 240,840 1020,1350 1350,1650 1650,1920
it commits,| what if this
|如果验证发生在 T2 提交之前，

2680
01:29:21,500 --> 01:29:23,660
0,720 720,1200 1200,1770 1770,2010 2010,2160
validation happened before {T2 -}

2681
01:29:23,660 --> 01:29:24,860
0,480 480,600 600,720 720,960 960,1200
committed,| so it's still sort
|所以它仍然是旧的版本号。

2682
01:29:24,860 --> 01:29:26,700
0,60 60,540 750,1140 1140,1590
of old version number.|
|

2683
01:29:26,950 --> 01:29:29,680
0,300 300,810 810,1050 1050,2130 2280,2730
It cannot happen,| because after
这不可能发生，|因为在验证之后，

2684
01:29:29,680 --> 01:29:33,700
0,840 840,2160 2460,2880 2880,3180 3630,4020
{the,validation},| {} after commit, after
|在提交完成之后，

2685
01:29:33,700 --> 01:29:36,340
0,210 210,360 360,870 870,1290 1770,2640
commit has completed, correct,| the
|提交备份已经记录，

2686
01:29:36,400 --> 01:29:38,260
0,360 360,930 930,1140 1140,1350 1350,1860
commit backup {you,know} has recorded|
|

2687
01:29:38,260 --> 01:29:39,790
0,90 90,150 150,600 600,930 930,1530
and the primary have {}
primary 必须做出改变，

2688
01:29:39,790 --> 01:29:41,040
0,180 180,390 390,450 450,1080
have made the change,|
|

2689
01:29:42,200 --> 01:29:44,240
0,870 870,1020 1020,1530 1530,1680 1680,2040
before the application was returned,|
在应用程序返回之前，|

2690
01:29:44,240 --> 01:29:45,920
0,240 240,420 420,840 840,1350 1350,1680
before the application returns,| z
在应用程序返回之前，|z 已经更新。

2691
01:29:45,920 --> 01:29:47,020
0,150 150,270 270,660
has been updated.|
|

2692
01:29:49,010 --> 01:29:50,280
0,840

2693
01:29:51,130 --> 01:29:52,300
0,510 570,720 720,720 720,1080 1080,1170
Wouldn't, {} I guess what
会不会，我想我要说的是，

2694
01:29:52,300 --> 01:29:53,290
0,90 90,300 300,450 450,780 780,990
I'm saying is,| isn't it
|T1 的验证阶段是否有可能发生在，

2695
01:29:53,290 --> 01:29:56,350
0,540 540,1080 1080,1710 1710,2610 2610,3060
possible {for,T1's -} validation phase

2696
01:29:56,350 --> 01:29:59,020
0,120 120,840 840,1770 2100,2460 2550,2670
to happen before| or I
|或者我想说的是，

2697
01:29:59,020 --> 01:29:59,620
0,150 150,300 300,390 390,480 480,600
guess maybe what I'm trying

2698
01:29:59,620 --> 01:30:00,610
0,60 60,270 270,570 570,840 840,990
to say is,| isn't it
|是否可能 T2 的提交发生在，

2699
01:30:00,610 --> 01:30:02,920
0,480 480,750 750,1050 1050,1740 1740,2310
possible that {T2's -} commit

2700
01:30:03,100 --> 01:30:05,800
0,480 480,1020 1020,1290 1290,1830 1830,2700
happens| between {T1's -} validate,
|发生在 T1 验证之后提交之前？

2701
01:30:06,070 --> 01:30:07,930
0,120 120,450 450,930 930,1230 1230,1860
{} happens after T1 validate
T1之后发生的情况在t1提交之前进行验证。

2702
01:30:07,930 --> 01:30:10,300
0,660 660,1530 1530,1800 1800,2190
before {T1's -} commit?|
|

2703
01:30:11,940 --> 01:30:13,260
0,990

2704
01:30:13,680 --> 01:30:14,580
0,450 450,540 540,660 660,840 840,900
Clearly, you know there's a
显然，这是有风险的，必须排除，

2705
01:30:14,580 --> 01:30:17,100
0,450 480,1380 1470,1800 1800,1920 1920,2520
risk and must be excluded,

2706
01:30:17,700 --> 01:30:20,600
0,960 1410,2640
{ -}

2707
01:30:21,520 --> 01:30:24,250
0,360 390,720 720,1620 1620,2490 2490,2730
and is executed,| {} so
|所以，你是在担心，

2708
01:30:24,250 --> 01:30:25,780
0,210 210,360 360,600 600,1230
okay so you're worried,|
|

2709
01:30:26,340 --> 01:30:27,480
0,180 180,510 510,840 840,930 930,1140
let me construct this case,|
让我来解释这个案例，|

2710
01:30:27,480 --> 01:30:28,140
0,150 150,270 270,390 390,570 570,660
may we'll come back to
也许我们下周回来，

2711
01:30:28,140 --> 01:30:29,190
0,180 180,420 420,630 630,840 840,1050
{} in next week,| we're
|我们讨论一下，

2712
01:30:29,190 --> 01:30:31,080
0,150 150,480 660,1230 1260,1710 1740,1890
gonna {talk,it} anyway,| {} but
|但我觉得你担心的，

2713
01:30:31,080 --> 01:30:31,740
0,90 90,240 240,330 330,390 390,660
I think you are worried

2714
01:30:31,740 --> 01:30:33,030
0,300 300,480 720,930 930,1140 1140,1290
about it,| {} could get
|可以回到这张图片，

2715
01:30:33,030 --> 01:30:34,000
0,60 60,330 330,720
the picture back,|
|

2716
01:30:34,110 --> 01:30:36,750
0,540 540,960 960,1410 1860,2100 2100,2640
{} here here's, we did,|
这里，我们做了，|

2717
01:30:36,780 --> 01:30:38,220
0,1140

2718
01:30:38,530 --> 01:30:40,540
0,450 480,870 870,1710
so this guy
这个提交了，

2719
01:30:41,560 --> 01:30:43,510
0,690 960,1170 1170,1410 1410,1770 1770,1950
committed,| so you basically doing
|所以你是在做提交阶段，

2720
01:30:43,510 --> 01:30:44,710
0,90 90,360 360,750 750,1080 1080,1200
the commit phase,| this is
|这是 T1 ，应该是 T2 ，

2721
01:30:44,710 --> 01:30:45,840
0,180 180,660
{T1 -},

2722
01:30:46,830 --> 01:30:48,510
0,300 300,360 360,810 810,930 930,1680
after {} T2, {} actually

2723
01:30:49,020 --> 01:30:50,660
0,720 720,1290
{} T2,|
|

2724
01:30:51,290 --> 01:30:52,850
0,480 480,660 660,930 930,1350 1350,1560
{} so {T2 -} is
所以 T2 在这里，

2725
01:30:52,850 --> 01:30:54,620
0,360 360,690 690,870 870,1470
about doing is here,

2726
01:30:55,130 --> 01:30:57,170
0,480 930,1380 1380,1590 1590,1920 1920,2040
right,| then {T1 -} is
|然后 T1 在一切发生之前进来，

2727
01:30:57,170 --> 01:31:01,400
0,270 270,780 1020,2190 2250,3810 3930,4230
coming in before {} everything

2728
01:31:01,400 --> 01:31:03,500
0,690 720,1170 1170,1320 1320,1710 1710,2100
happens,| before the T2 {is,finished\,,correct}.|
|在 T2 完成之前。|

2729
01:31:04,480 --> 01:31:05,380
0,600
Right.|
是的。|

2730
01:31:05,810 --> 01:31:07,520
0,330 330,630 630,870 870,1110 1110,1710
So like {T1 -} validation
所以， T1 也从这里进来，

2731
01:31:07,520 --> 01:31:09,530
0,240 240,450 450,570 570,960 1590,2010
also comes in here,| so
|所以也许，

2732
01:31:09,530 --> 01:31:10,820
0,450 450,570 570,780 780,930 930,1290
maybe,| okay, let me rewrite
|好的，让我重写一遍，

2733
01:31:10,820 --> 01:31:11,540
0,180 180,270 270,420 420,510 510,720
it,| and I'll get back
|我会回复你。

2734
01:31:11,540 --> 01:31:14,300
0,90 90,210 210,1650 2130,2610 2610,2760
to you.| Okay.| Exactly what
|好的。|这正是我想要谈的。

2735
01:31:14,300 --> 01:31:15,350
0,270 300,540 540,600 600,780 780,1050
I wanted to talk about.|
|

2736
01:31:15,650 --> 01:31:18,380
0,120 120,780 780,1020 1020,1200 2490,2730
Okay, okay, thank you.| So
好的，谢谢。|所以想确认一下，

2737
01:31:18,380 --> 01:31:19,610
0,210 210,390 390,630 630,870 870,1230
just make sure,| you're asking
|你问的是 T2 在 T1 的第二阶段和第三阶段之间？

2738
01:31:19,610 --> 01:31:20,960
0,300 300,480 480,780 780,1020 1020,1350
about {T2 -} being like

2739
01:31:21,230 --> 01:31:22,640
0,210 210,750 750,1110 1110,1290 1290,1410
in between stage two and

2740
01:31:22,640 --> 01:31:25,760
0,330 330,420 420,660 660,2010
three of T1?| Yeah.|
|是的。|

2741
01:31:26,880 --> 01:31:28,170
0,180 180,270 270,540 540,990 990,1290
But in that case,| then
但在这种情况下，|我们可以串行化，让 T2 在 T1 之前。

2742
01:31:28,170 --> 01:31:29,670
0,240 240,870 930,1080 1080,1410 1410,1500
{T2 -}, we could, we

2743
01:31:29,670 --> 01:31:31,170
0,150 150,840 840,1020 1020,1290 1290,1500
could serialize it as {T2

2744
01:31:31,170 --> 01:31:33,690
0,150 150,570 570,1380 1410,1860 2130,2520
-} coming {before,T1}, right.| Yep.|
|是的。|

2745
01:31:35,550 --> 01:31:37,260
0,180 180,990 990,1260 1260,1500 1500,1710
So, let's, let's get, let's
所以，让我们在周四回到这个话题上，

2746
01:31:37,260 --> 01:31:38,430
0,120 120,330 330,390 390,600 600,1170
get back to this on

2747
01:31:38,430 --> 01:31:40,050
0,450 900,1020 1020,1200 1200,1260 1260,1620
Thursday,| I have an example
|我有一个例子可以说明这一点。

2748
01:31:40,050 --> 01:31:41,640
0,390 390,780 780,1380 1380,1530 1530,1590
{for,that} exactly was going to

2749
01:31:41,640 --> 01:31:42,600
0,150 150,300 300,480 480,630 630,960
go over top of this.|
|

2750
01:31:46,330 --> 01:31:47,980
0,510 510,600 600,660 660,1260 1260,1650
Sorry, in the validation stage,
抱歉，在验证阶段，你只读取版本号？

2751
01:31:47,980 --> 01:31:51,130
0,120 120,420 600,1500 1590,2310 2790,3150
you just read, {} read

2752
01:31:51,130 --> 01:31:53,200
0,270 270,750 750,1410
the version number?|
|

2753
01:31:53,480 --> 01:31:54,320
0,270 270,660
Yeah.| Okay.|
是的。|好的。|

2754
01:31:58,180 --> 01:32:00,160
0,300 300,930 930,1380 1380,1800 1800,1980
And {serializability -} allows us
可串行化使我们能够对事务重新排序。

2755
01:32:00,160 --> 01:32:02,260
0,150 150,540 540,1740 1770,1980 1980,2100
to reorder transactions.| Yeah, but
|是的，但严格的可串行化不会，

2756
01:32:02,260 --> 01:32:03,910
0,450 450,660 660,870 870,1200 1200,1650
{strict,serializability -} will not, correct,|
|

2757
01:32:04,060 --> 01:32:06,550
0,390 390,870 870,1650 1680,2160 2160,2490
if, if transaction, strict {serializability
严格串行化要求，

2758
01:32:06,550 --> 01:32:07,810
0,240 240,750 750,930 930,1110 1110,1260
-} requires that,| if transaction
|如果事务在某个提交之后开始，

2759
01:32:07,810 --> 01:32:09,400
0,210 210,660 660,780 780,1260 1260,1590
actually starts, {} somebody, after

2760
01:32:09,400 --> 01:32:11,020
0,300 300,780 930,1110 1110,1530 1530,1620
somebody committed,| that transaction is
|事务也要在那个事务之后提交。

2761
01:32:11,020 --> 01:32:12,550
0,210 210,540 540,870 870,1020 1020,1530
also committed after that transaction.|
|

2762
01:32:14,200 --> 01:32:15,700
0,360 360,960 990,1290 1290,1380 1380,1500
Right.| {} Which is {protocol
是的。|这是协议保证的，

2763
01:32:15,700 --> 01:32:16,750
0,90 90,300 300,720 720,930 930,1050
- -} guarantee,| because of
|因为版本号。

2764
01:32:16,750 --> 01:32:17,500
0,420
the,

2765
01:32:17,790 --> 01:32:18,920
0,150 150,420 420,810
the version number.|
|

2766
01:32:19,830 --> 01:32:21,180
0,330 330,450 450,660 660,960
Got it, thank you.|
知道了，谢谢。|

2767
01:32:21,980 --> 01:32:24,420
0,180 180,510 510,1290 1320,2130
But strict serializability doesn't,|
但严格的可串行化不是，|

2768
01:32:24,650 --> 01:32:25,700
0,210 210,270 270,390 390,660 660,1050
if I get {T2 -}
如果我得到 T2 结束，

2769
01:32:25,700 --> 01:32:26,640
0,660
ends,|
|

2770
01:32:27,000 --> 01:32:28,350
0,180 180,390 390,720 720,1080 1080,1350
it's not {refer -} {T1
它不是 T1 在 T2 结束之后结束，

2771
01:32:28,350 --> 01:32:30,030
0,510 510,690 690,930 930,1380 1380,1680
-} the end after {T2

2772
01:32:30,030 --> 01:32:32,060
0,690 1050,1800
-} ends,|
|

2773
01:32:32,400 --> 01:32:33,570
0,210 210,360 360,810 810,1110 1110,1170
{T1 -} have had to
T1 必须已经开始，

2774
01:32:33,570 --> 01:32:35,700
0,240 240,1020 1050,1380 1680,2070 2070,2130
have started,| or maybe I
|或许我需要考虑一下这个问题，

2775
01:32:35,700 --> 01:32:36,510
0,120 120,180 180,300 300,480 480,810
need to think about this,|
|

2776
01:32:36,510 --> 01:32:38,070
0,300 540,750 750,1290 1290,1470 1470,1560
but I think this is
但我觉得这把我弄糊涂了，

2777
01:32:38,070 --> 01:32:38,970
0,210 210,450 450,570 570,720 720,900
always tripping me out,| this
|这里也有一个关于事务开始的规则。

2778
01:32:38,970 --> 01:32:40,890
0,180 180,360 360,720 720,1560 1590,1920
like there's also a rule

2779
01:32:40,890 --> 01:32:42,600
0,270 270,660 660,750 750,1290 1290,1710
about when the transaction starts.|
|

2780
01:32:42,600 --> 01:32:44,490
0,450 450,750 750,900 900,1410 1500,1890
Yeah, well, { -} well
是的，好的，在真实生活中会发生什么，

2781
01:32:44,760 --> 01:32:45,870
0,240 240,510 510,630 630,810 810,1110
what happens in real life,|
|

2782
01:32:45,870 --> 01:32:47,580
0,960 960,1200 1200,1290 1290,1410 1410,1710
exactly starts from some particular
准确地从某个特定的时间点开始，

2783
01:32:47,580 --> 01:32:48,990
0,180 180,240 240,600 600,840 960,1410
point of time,| and basically
|如果 T2 在 T1 提交后开始。

2784
01:32:48,990 --> 01:32:50,900
0,660 690,1740
if T1,

2785
01:32:51,240 --> 01:32:52,830
0,330 330,540 540,900 900,1350 1350,1590
{} if T2 starts after

2786
01:32:52,830 --> 01:32:54,180
0,420 420,1110
T1 commits.|
|

2787
01:32:56,250 --> 01:32:57,900
0,360 450,690 690,780 780,1230 1350,1650
Right.| So and so then
是的。|所以，肯定是这样的，

2788
01:32:57,900 --> 01:32:58,830
0,150 150,450 450,540 540,630 630,930
it must be the case,|
|

2789
01:32:58,830 --> 01:33:01,080
0,240 240,600 600,1470 1650,1800 1800,2250
that T2 observes {you,know} {T2
T2 观察到 T1 的改变，

2790
01:33:01,080 --> 01:33:03,120
0,360 360,750 750,1440 1470,1680 1680,2040
-} T1 changes,| that's {strict,serializability
|这就是严格可串行化。

2791
01:33:03,120 --> 01:33:04,120
0,750
-}.|
|

2792
01:33:04,700 --> 01:33:05,520
0,540
Right.|
是的。|

2793
01:33:05,790 --> 01:33:07,380
0,150 150,270 270,690 690,1170 1170,1590
But what happened {T2 -}
但如果 T2 发生的[]，会怎么样？

2794
01:33:07,380 --> 01:33:09,930
0,510 510,750 750,1200 1200,1710 1710,2550
starts and commits [] within?|
|

2795
01:33:10,170 --> 01:33:11,850
0,240 540,780 780,1290 1290,1440 1440,1680
{Then,concurrent -} transaction and either
那么并发事务，任何一个结果都是好的。

2796
01:33:11,850 --> 01:33:17,730
0,270 270,360 360,720 1020,1530 1740,5880
outcome is fine.| Okay.| {Is,that,answer,your,question}?|
|好的。|这回答了你的问题吗？|

2797
01:33:17,730 --> 01:33:20,700
0,330 330,1470 1680,2160 2160,2310 2310,2970
{Yeah\,,I,think,that,I,confused}, so.| When they literally,
是的，我想这就是我困惑的，所以。|确切地说，当 T2 在 T1 提交之前开始时，

2798
01:33:20,970 --> 01:33:23,400
0,540 600,1050 1050,1200 1200,1680 1680,2430
when {T2 -} starts before

2799
01:33:23,400 --> 01:33:25,170
0,180 180,420 420,1050 1170,1410 1410,1770
{T1 -} commits,| it's considered
|它被认为是并发事务，

2800
01:33:25,170 --> 01:33:26,360
0,120 120,450 450,990
the concurrent transaction,|
|

2801
01:33:27,200 --> 01:33:28,550
0,450 450,690 690,900 900,1200 1200,1350
and so {T1 -} or
所以 T1 或 T2 可以观察到彼此，

2802
01:33:28,550 --> 01:33:30,050
0,270 270,570 600,930 930,1050 1050,1500
you know T2 can observe

2803
01:33:30,050 --> 01:33:31,610
0,330 330,600 600,750 750,1080 1080,1560
either,| can be ordered before
|可以排序在前或在后，没有关系。

2804
01:33:31,610 --> 01:33:33,530
0,210 210,510 570,840 840,1170 1380,1920
either after, doesn't matter.| Okay,
|好的，好的。

2805
01:33:33,770 --> 01:33:34,340
0,480
okay.|
|

2806
01:33:34,810 --> 01:33:36,040
0,450 660,900 900,1020 1020,1080 1080,1230
Okay, thank you.| I think
好的，谢谢。|我认为这也是你的例子的答案。

2807
01:33:36,040 --> 01:33:37,000
0,240 240,510 510,630 630,870 870,960
there's also the answer to

2808
01:33:37,000 --> 01:33:40,000
0,330 330,930 1170,1860 2190,2670 2730,3000
your example.| Right, okay, thank
|是的，好的，谢谢。

2809
01:33:40,000 --> 01:33:41,770
0,240 270,960 960,1110 1110,1590 1590,1770
you.| {Okay\,,we} have we got
|好的，我们已经得到了结果。

2810
01:33:41,770 --> 01:33:44,710
0,60 60,330 330,750 2460,2730 2730,2940
it anyway already.| You're say
|你是说，如果 T2 开始于 T1 开始和提交之间。

2811
01:33:44,710 --> 01:33:46,570
0,420 600,840 840,1050 1050,1560 1560,1860
if {T2 -} started like

2812
01:33:46,570 --> 01:33:48,970
0,870 1110,1320 1320,1620 1620,2010 2010,2400
between the {T1 -} {start,and}

2813
01:33:48,970 --> 01:33:51,340
0,390 390,750 750,1680 1710,2130 2130,2370
commit, right, like.| {Yeah\,,you} know,
|是的，可以在前面或后面，没有关系。

2814
01:33:51,340 --> 01:33:52,690
0,270 270,600 600,810 810,1140 1140,1350
can be go for or

2815
01:33:52,690 --> 01:33:54,340
0,240 240,330 330,510 510,870
after, it doesn't matter.|
|

2816
01:33:56,010 --> 01:33:56,940
0,240 240,390 390,450 450,870 870,930
{} Can I ask a
我能问个后勤问题吗，

2817
01:33:56,940 --> 01:33:59,730
0,510 510,1230 1290,1830 1890,2370 2370,2790
logistics question,| {} {I,remember} in
|我记得在 6.S081 ，你也贴了这些幻灯片。

2818
01:33:59,730 --> 01:34:02,700
0,840 870,1140 1140,1740 1920,2370 2370,2970
{6.S081 - -}, you post

2819
01:34:02,700 --> 01:34:04,540
0,270 270,900 900,1650
these slides too.|
|

2820
01:34:05,160 --> 01:34:06,450
0,390 390,540 540,1050 1050,1170 1170,1290
Yes, I, yeah, yeah I
是的，我没有在这里做，

2821
01:34:06,450 --> 01:34:08,250
0,240 240,360 360,600 600,1020 1050,1800
didn't do that here, {}|
|

2822
01:34:08,700 --> 01:34:09,870
0,180 180,360 360,570 570,870 870,1170
would you like to be
你想它在网站上吗？

2823
01:34:09,870 --> 01:34:11,080
0,180 180,450 450,930
on the website?|
|

2824
01:34:11,290 --> 01:34:12,520
0,180 180,390 390,720 720,840 840,1230
I think slides are useful,|
我想幻灯片是有用的，|

2825
01:34:12,520 --> 01:34:13,960
0,510 720,900 900,1020 1020,1260 1260,1440
if if you just need
如果你只需要看幻灯片，

2826
01:34:13,960 --> 01:34:15,790
0,390 420,870 900,1170 1170,1290 1290,1830
to look at this slides,|
|

2827
01:34:15,790 --> 01:34:17,110
0,180 180,450 450,630 660,1200 1200,1320
you need to scroll through
你需要滚动浏览视频。

2828
01:34:17,110 --> 01:34:20,200
0,120 120,840 930,1440 1470,2280 2730,3090
the video.| Okay, {} you're
|好的，你是第一个问的，为什么我没有这么做，

2829
01:34:20,200 --> 01:34:22,420
0,240 240,690 1530,1830 1830,2010 2010,2220
first asking, why {I,haven't} {done,it},|
|

2830
01:34:23,080 --> 01:34:25,270
0,1410 1410,1680 1680,1920 1920,2040 2040,2190
yeah, I'm happy to do
是的，我很乐意这么做，

2831
01:34:25,270 --> 01:34:26,620
0,300 300,390 390,900 900,1110 1110,1350
it,| I I do save
|我把它们保存下来。

2832
01:34:26,620 --> 01:34:28,020
0,90 90,540 660,1200
them all {}.|
|

2833
01:34:29,690 --> 01:34:30,950
0,210 210,360 360,510 510,990 1020,1260
Thank you so much,| thank
非常感谢,|谢谢你的有趣的课程。

2834
01:34:30,950 --> 01:34:32,720
0,180 180,630 810,1140 1140,1380 1380,1770
you for those fun lecture

2835
01:34:32,720 --> 01:34:33,400
0,420
things.|
|

2836
01:34:33,700 --> 01:34:34,600
0,600
{You're,welcome}.
不用谢。
