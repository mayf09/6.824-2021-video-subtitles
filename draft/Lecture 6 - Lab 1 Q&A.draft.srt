1
00:00:05,230 --> 00:00:07,390
0,570 930,1440 1440,1590 1590,1800 1800,2160
Alright, well, it's five after,|
好的，已经五点了，|

2
00:00:07,390 --> 00:00:08,620
0,300 300,570 570,750 750,870 870,1230
so I'll just go ahead
所以我就开始了。

3
00:00:08,620 --> 00:00:11,500
0,450 690,960 960,1530 1530,2370 2430,2880
started.| So today's lecture is
|所以今天的课程是第一个实验的问答，

4
00:00:11,500 --> 00:00:12,490
0,150 150,390 390,480 480,690 690,990
the {Q&A - -} on

5
00:00:12,490 --> 00:00:13,900
0,450 480,810 810,1110 1110,1170 1170,1410
the first lab,| the {MapReduce
|MapReduce 实验，

6
00:00:13,900 --> 00:00:15,820
0,300 300,720 1020,1320 1320,1590 1590,1920
-} lab,| and also some
|还有一些关于 Go 编程的通用编码问答，

7
00:00:15,820 --> 00:00:18,010
0,390 390,1110 1140,1860 1860,2040 2040,2190
just general coding {Q&As -

8
00:00:18,010 --> 00:00:19,660
0,420 420,720 720,930 930,1470 1470,1650
-} for Go programming,| that
|可能会对未来的实验有所帮助。

9
00:00:19,660 --> 00:00:21,010
0,150 150,420 420,510 510,810 810,1350
might help in future labs.|
|

10
00:00:21,100 --> 00:00:22,510
0,540 540,720 720,870 870,1020 1020,1410
So feel free to stop
所以你可以随时停下来，

11
00:00:22,510 --> 00:00:23,620
0,60 60,240 240,600 600,840 840,1110
at any time| or put
|或者在聊天中提出问题，

12
00:00:23,620 --> 00:00:24,520
0,360 360,420 420,510 510,810 810,900
questions in the chat,| and
|我会偶尔检查一下，

13
00:00:24,520 --> 00:00:26,620
0,120 120,480 480,810 810,1140 1170,2100
I'll be checking it occasionally,|
|

14
00:00:27,280 --> 00:00:28,630
0,390 390,540 540,870 870,1050 1050,1350
and I'm sure like other
我相信其他[]也能提供帮助，

15
00:00:28,630 --> 00:00:30,640
0,300 300,450 450,870 1650,1860 1860,2010
[] can also help as

16
00:00:30,640 --> 00:00:32,680
0,360 930,1230 1230,1560 1560,1770 1770,2040
well,| {} if you are
|如果你未静音并且正在打字，

17
00:00:32,680 --> 00:00:34,340
0,60 60,570 570,720 720,1290
{unmuted -} and typing,|
|

18
00:00:34,340 --> 00:00:35,120
0,90 90,240 240,330 330,630 630,780
it would be helpful if
如果你静音，会很有帮助，

19
00:00:35,120 --> 00:00:39,260
0,180 180,360 2640,3030 3090,3540 3630,4140
you muted,| but yeah.| Alright,
|不过，是的。|好的，那么今天的议程，

20
00:00:39,260 --> 00:00:41,000
0,600 630,870 870,1200 1200,1350 1350,1740
so the agenda for today,|
|

21
00:00:41,000 --> 00:00:41,990
0,150 150,390 390,540 540,840 840,990
the first thing I'm going
我要做的第一件事是，

22
00:00:41,990 --> 00:00:43,040
0,90 90,300 300,450 450,750 750,1050
to do is,| actually walk
|演示实验 1 的解决方案，

23
00:00:43,040 --> 00:00:44,600
0,240 240,390 390,840 840,930 930,1560
through a solution of {lab,1},|
|

24
00:00:44,900 --> 00:00:46,760
0,480 480,780 780,1200 1230,1470 1470,1860
and this is my personal
这是我个人的解决方案，

25
00:00:46,760 --> 00:00:48,800
0,570 570,900 900,1380 1440,1830 1830,2040
solution,| {} it's probably not
|它可能并不完美，

26
00:00:48,800 --> 00:00:50,780
0,570 570,960 990,1230 1230,1290 1290,1980
perfect,| but it's an example
|但这是你可以做的一个例子，

27
00:00:50,780 --> 00:00:51,620
0,90 90,360 390,570 570,720 720,840
of what you could have

28
00:00:51,620 --> 00:00:53,720
0,420 840,1410 1470,1830 1830,1920 1920,2100
done,| {} second, we're going
|第二，我们将讨论一些替代的解决方案设计，

29
00:00:53,720 --> 00:00:55,490
0,90 90,480 480,690 690,1410 1410,1770
to discuss some alternative solution

30
00:00:55,490 --> 00:01:00,740
0,660 1320,1620 1920,2520 2520,3120 4290,5250
designs,| {} {someone,is,still} typing {}.|
|还有人在打字。|

31
00:01:00,740 --> 00:01:02,000
0,810
{[]\,,stop,typing}.|
[]，停止打字。|

32
00:01:02,980 --> 00:01:05,470
0,630 630,1020 1020,1470 1470,1650 1650,2490
Alright, it's helpful to {},
好的，很有帮助，

33
00:01:06,520 --> 00:01:09,070
0,480 780,1410 1440,2190 2220,2370 2370,2550
[],| {} third, we're going
|第三，我们将讨论一些常见的设计错误和一些 bug ，

34
00:01:09,070 --> 00:01:10,180
0,330 360,720 720,870 870,960 960,1110
to discuss some of the

35
00:01:10,180 --> 00:01:11,830
0,270 270,570 570,1050 1050,1410 1440,1650
common design mistakes and some

36
00:01:11,830 --> 00:01:12,580
0,60 60,150 150,420 420,630 630,750
of the bugs,| that you
|在你们的解决方案中，

37
00:01:12,580 --> 00:01:14,620
0,300 300,720 750,1140 1140,1350 1350,2040
guys had in your solutions,|
|

38
00:01:14,980 --> 00:01:17,050
0,390 390,1110 1200,1650 1650,1860 1860,2070
{} four, just over some
第四，一些一般性的提示，

39
00:01:17,050 --> 00:01:18,700
0,360 360,720 720,840 840,990 990,1650
general tips,| and then finally
|最后，如果有时间，我们会进行一些问答，

40
00:01:18,880 --> 00:01:20,770
0,240 240,720 810,1350 1500,1680 1680,1890
we're going to, if there's

41
00:01:20,770 --> 00:01:21,790
0,330 330,510 510,660 660,840 840,1020
time, go to some {Q&As

42
00:01:21,790 --> 00:01:23,710
0,90 90,390 390,840 1230,1830 1830,1920
- -},| both questions you
|你现在可能会有的问题，

43
00:01:23,710 --> 00:01:25,810
0,150 150,300 300,480 480,1020 1080,2100
might have right now| and
|还有你在讲课前提交的问题。

44
00:01:25,810 --> 00:01:28,720
0,870 900,1770 1770,2010 2010,2160 2160,2910
also questions that you submitted

45
00:01:28,750 --> 00:01:29,820
0,630
{}

46
00:01:29,820 --> 00:01:31,220
0,270 270,840
before lecture.|
|

47
00:01:31,750 --> 00:01:33,610
0,420 420,960 960,1110 1110,1380 1380,1860
So first for the lab
所以，首先是实验解决方案演示，

48
00:01:33,640 --> 00:01:36,400
0,570 570,960 960,1950 2040,2670 2670,2760
solution {walkthrough -},| let me
|如果字体太小，请告诉我，

49
00:01:36,400 --> 00:01:38,350
0,240 240,420 420,1020 1530,1830 1830,1950
know if the fonts too

50
00:01:38,350 --> 00:01:39,730
0,450 450,960 960,1110 1110,1290 1290,1380
small,| I'll just stick with
|我还是放在这里。

51
00:01:39,730 --> 00:01:40,680
0,480
this.|
|

52
00:01:40,950 --> 00:01:44,480
0,300 300,870 900,1560 1560,2850
Alright, so I basically,
好的，所以我基本上一步一步地，

53
00:01:45,050 --> 00:01:46,400
0,300 300,570 570,840 840,960 960,1350
{} one step by step,|
|

54
00:01:46,400 --> 00:01:47,450
0,120 120,240 240,630 630,930 930,1050
and I'll show how I
我将展示我是如何开发我的解决方案的。

55
00:01:47,450 --> 00:01:49,430
0,390 390,480 480,1050 1320,1860 1860,1980
developed my solution.| So the
|所以我做的第一件事是，

56
00:01:49,430 --> 00:01:51,530
0,270 270,390 390,540 540,1080 1380,2100
first thing I did was,|
|

57
00:01:51,800 --> 00:01:53,210
0,360 360,690 690,870 870,1170 1170,1410
this is {rpc.go - -
这是 rpc.go ，

58
00:01:53,210 --> 00:01:54,500
0,420 750,960 960,1020 1020,1200 1200,1290
-},| and the first thing
|我做的第一件事就是弄清楚 API ，

59
00:01:54,500 --> 00:01:56,090
0,90 90,270 270,720 780,1320 1320,1590
I did was figure out

60
00:01:56,090 --> 00:01:57,380
0,150 150,870 870,1050 1050,1290 1290,1290
the API,| in which I
|我想让 worker 和 coordinator 进行交流，

61
00:01:57,380 --> 00:01:59,090
0,480 480,630 630,870 870,1140 1140,1710
wanted my {worker,and -} coordinator

62
00:01:59,090 --> 00:02:02,630
0,120 120,750 1440,1770 1770,2430 3390,3540
to communicate,| and so the
|所以我做的第一件事就是定义有哪些类型的任务，

63
00:02:02,630 --> 00:02:03,530
0,210 210,330 330,420 420,720 720,900
first thing I did was

64
00:02:03,530 --> 00:02:05,480
0,720 810,1170 1170,1470 1470,1560 1560,1950
define what types of tasks

65
00:02:05,480 --> 00:02:07,190
0,180 180,570 990,1410 1410,1530 1530,1710
there are,| and so there
|所以这里有 Map 和 Reduce 任务，

66
00:02:07,190 --> 00:02:08,660
0,270 270,360 360,660 660,1110 1110,1470
Map and Reduce tasks,| and
|并且为了表示，

67
00:02:08,660 --> 00:02:10,430
0,180 180,540 540,780 780,1320 1320,1770
in order to signal that,|
|

68
00:02:10,550 --> 00:02:12,410
0,240 240,840 840,1350 1380,1680 1680,1860
the coordinator has, things the
coordinator 任务已完成，是 Done 任务，

69
00:02:12,410 --> 00:02:13,790
0,240 240,300 300,750 870,1140 1140,1380
{} is done, {is,the} Done

70
00:02:13,790 --> 00:02:14,600
0,600
task,|
|

71
00:02:14,940 --> 00:02:16,140
0,210 210,360 360,780 780,960 960,1200
and so, these are the
所以，这些都是任务的类型。

72
00:02:16,140 --> 00:02:17,640
0,330 330,420 420,990
types of task.|
|

73
00:02:17,820 --> 00:02:19,290
0,660 660,810 810,900 900,1260 1290,1470
Zoom in a bit, can
你能放大一点吗，这个文件？

74
00:02:19,290 --> 00:02:20,730
0,60 60,330 330,480 480,570 570,1440
you zoom in a bit,

75
00:02:20,850 --> 00:02:22,620
0,720 720,1170
{the,files}?| Yeah,
|好的，这样可以吗？

76
00:02:23,220 --> 00:02:24,920
0,450 450,1110
{is,that} okay?|
|

77
00:02:26,410 --> 00:02:28,580
0,840 870,1680
Yeah, thanks.|
好的，谢谢。|

78
00:02:29,060 --> 00:02:30,440
0,420 510,960 960,1080 1080,1260 1260,1380
Cool, yeah, it's hard for
酷，是的，我很难确定它看起来是什么样子，

79
00:02:30,440 --> 00:02:32,000
0,240 240,630 660,1170 1200,1410 1410,1560
me to tell how it

80
00:02:32,000 --> 00:02:33,260
0,750
looked,|
|

81
00:02:33,740 --> 00:02:35,600
0,420 420,720 720,1530 1530,1740 1740,1860
yeah, so {I,hopefully} this is
好的，我希望这是好的。

82
00:02:35,600 --> 00:02:39,220
0,330 600,1560 2340,3090
good.| {} And
|所以，我决定实现这两个 RPC ，

83
00:02:39,340 --> 00:02:40,840
0,360 360,900 900,1140 1140,1350 1350,1500
so the there two {RPCs

84
00:02:40,840 --> 00:02:42,550
0,510 510,660 660,1110 1110,1170 1170,1710
-} I decided to implement,|
|

85
00:02:42,730 --> 00:02:44,290
0,240 240,630 630,1020 1020,1110 1110,1560
the first is a worker
第一个是 worker 请求 coordinator 给它一个任务，

86
00:02:44,290 --> 00:02:45,670
0,420 420,480 480,1110 1110,1230 1230,1380
asking the coordinator to give

87
00:02:45,670 --> 00:02:46,960
0,90 90,180 180,720 870,1110 1110,1290
it a task,| so one
|Map Reduce 中的一个或 Done 用来退出，

88
00:02:46,960 --> 00:02:48,820
0,240 300,720 720,1110 1110,1530 1560,1860
of {Map,Reduce -} or Done

89
00:02:48,820 --> 00:02:51,670
0,240 240,510 510,1140 1470,2190 2310,2850
in please exit,| and basically
|基本上就是这些参数，

90
00:02:51,670 --> 00:02:52,720
0,240 240,600
there's like

91
00:02:52,780 --> 00:02:54,250
0,90 90,1050 1050,1140 1140,1260 1260,1470
the argument,| {you,know} don't really
|并没有参数，只是请求一个任务，

92
00:02:54,250 --> 00:02:56,320
0,510 630,960 960,1680 1680,1890 1890,2070
have any arguments or just

93
00:02:56,320 --> 00:02:58,540
0,300 300,390 390,450 450,1080 1110,2220
asking for a task,| and
|coordinator 回答这是什么任务，

94
00:02:58,690 --> 00:03:00,490
0,360 360,930 930,1380 1380,1590 1590,1800
the coordinator replies with what

95
00:03:00,490 --> 00:03:02,290
0,300 300,420 420,930 960,1290 1290,1800
task is this,| which task
|你应该做哪种类型的任务，

96
00:03:02,320 --> 00:03:03,670
0,150 150,390 390,870 990,1200 1200,1350
of that type should you

97
00:03:03,670 --> 00:03:04,720
0,570
do,|
|

98
00:03:05,240 --> 00:03:07,340
0,270 270,600 600,1260 1290,1710 1710,2100
and also some extra data
还有一些 Map 或 Reduce 任务需要的额外数据，

99
00:03:07,340 --> 00:03:09,320
0,240 240,720 930,1440 1440,1590 1590,1980
that's needed for the Map

100
00:03:09,320 --> 00:03:10,640
0,150 150,480 480,900 900,1140 1140,1320
or Reduce tasks,| such as
|例如系统中 Map 任务的数量，

101
00:03:10,640 --> 00:03:11,810
0,150 150,390 390,480 480,690 690,1170
the number of Map tasks

102
00:03:11,810 --> 00:03:13,040
0,120 120,210 210,780 870,1140 1140,1230
in the system| or the
|或者 Reduce 任务的数量。

103
00:03:13,040 --> 00:03:14,700
0,330 330,660 660,1260
{number,of} Reduce tasks.|
|

104
00:03:15,380 --> 00:03:17,270
0,570 570,690 690,990 990,1620 1620,1890
And the second RPC is
第二个 RPC 是完成任务的 RPC ，

105
00:03:17,270 --> 00:03:19,310
0,450 480,930 930,1170 1170,1770 1800,2040
a finished task RPC,| that
|worker 用它来通知 coordinator ，

106
00:03:19,310 --> 00:03:20,780
0,90 90,480 480,870 870,990 990,1470
the worker uses to notify

107
00:03:20,780 --> 00:03:22,550
0,90 90,900 1200,1440 1440,1560 1560,1770
the coordinator,| that it has
|它已经完成了任务，

108
00:03:22,550 --> 00:03:24,620
0,390 390,540 540,1110 1170,1680 1680,2070
finished the task,| {} and
|它将哪项任务已完成作为参数传递，

109
00:03:24,620 --> 00:03:26,720
0,450 480,1050 1050,1290 1290,1830 1830,2100
it passes as arguments which

110
00:03:26,720 --> 00:03:28,300
0,360 360,570 570,1140
task has finished,|
|

111
00:03:28,450 --> 00:03:29,890
0,300 300,420 420,630 630,1170 1170,1440
and they don't actually really
它们并不需要得到回复。

112
00:03:29,890 --> 00:03:30,580
0,180 180,240 240,360 360,390 390,690
need to get a reply

113
00:03:30,580 --> 00:03:31,640
0,120 120,570
for this.|
|

114
00:03:32,000 --> 00:03:33,200
0,150 150,300 300,420 420,690 690,1200
So that's the first step
所以这是实现的第一步，

115
00:03:33,260 --> 00:03:39,350
0,630 630,720 720,1560 5130,5550 5580,6090
of the implementation,| so [].|
|所以。|

116
00:03:40,190 --> 00:03:41,840
0,630 630,1050 1050,1230 1230,1320 1320,1650
Alright, so as a second
好的，作为第二步，

117
00:03:41,840 --> 00:03:43,190
0,480 510,750 750,870 870,1140 1140,1350
step,| what I did is
|我所做的是为所有这些 RPC 实现处理程序，

118
00:03:43,190 --> 00:03:44,840
0,480 480,570 570,1380 1380,1560 1560,1650
implement the handlers for all

119
00:03:44,840 --> 00:03:46,520
0,210 210,720 720,900 1140,1590 1590,1680
these {RPCs -},| and so
|所以这在 coordinator 中，

120
00:03:46,520 --> 00:03:50,540
0,300 300,510 510,1380 2550,3420
that's in coordinator,| so,
|因此，首先我必须用 coordinator 状态填充 coordinator ，

121
00:03:50,570 --> 00:03:51,590
0,330 330,420 420,600 600,690 690,1020
first I had to actually

122
00:03:51,590 --> 00:03:52,940
0,480 480,570 570,1140 1140,1260 1260,1350
populate the coordinator with the

123
00:03:52,940 --> 00:03:55,010
0,480 480,930 1260,1530 1530,1710 1710,2070
coordinator state| and so there's
|这里有一个 Mutex 保护状态的并发访问，

124
00:03:55,010 --> 00:03:56,480
0,90 90,630 630,870 870,1350 1350,1470
the Mutex, which protects the

125
00:03:56,480 --> 00:03:58,100
0,300 300,450 450,930 930,1350 1350,1620
state from concurrent access,| because
|因为 coordinator 将有多个并发运行的线程，

126
00:03:58,100 --> 00:03:59,390
0,90 90,630 630,750 750,930 930,1290
the coordinator will have multiple

127
00:03:59,390 --> 00:04:02,960
0,360 360,840 1620,2490 2790,3480 3480,3570
threads running concurrently,| then the
|第二部分是跟踪我们在 Map 任务所需要的文件，

128
00:04:02,960 --> 00:04:05,180
0,540 600,1440 1440,1800 1800,1920 1920,2220
second part is to keep

129
00:04:05,180 --> 00:04:06,410
0,300 300,420 420,630 630,990 990,1230
track of just like the

130
00:04:06,410 --> 00:04:07,880
0,450 450,570 570,690 690,1050 1050,1470
files that {we,need} {for,Map} task,|
|

131
00:04:08,030 --> 00:04:08,990
0,270 270,330 330,630 630,720 720,960
and the number of Map
以及 Map 和 Reduce 任务的数量，

132
00:04:08,990 --> 00:04:10,360
0,90 90,450 450,870
and Reduce tasks,|
|

133
00:04:10,510 --> 00:04:14,170
0,810 1620,1920 1920,2340 2400,3120 3120,3660
and {} this metadata is
这些元数据被用来跟踪我们发出了哪些任务，

134
00:04:14,170 --> 00:04:15,910
0,510 510,630 630,1080 1080,1380 1380,1740
used to track which tasks

135
00:04:15,910 --> 00:04:17,560
0,150 150,270 270,870 1020,1380 1380,1650
have we issued,| and which
|以及哪些任务已经完成，

136
00:04:17,560 --> 00:04:20,770
0,300 300,420 420,1020 1320,2040 2490,3210
tasks have finished,| {} the
|一旦我们发布，我们会跟踪时间戳，

137
00:04:20,800 --> 00:04:21,730
0,240 240,330 330,510 510,870 870,930
once that we've issued, we

138
00:04:21,730 --> 00:04:22,630
0,240 240,510 510,570 570,660 660,900
keep track of the {timestamps

139
00:04:22,630 --> 00:04:24,130
0,420 420,570 570,660 660,1170 1230,1500
-},| that we know if
|我们知道如果这些任务没有在一定的时间内完成，

140
00:04:24,130 --> 00:04:25,330
0,210 210,480 480,630 630,720 720,1200
these tasks {haven't -} completed

141
00:04:25,330 --> 00:04:26,050
0,240 240,300 300,510 510,660 660,720
within a certain amount of

142
00:04:26,050 --> 00:04:28,570
0,270 270,420 420,1080 1080,1470 2340,2520
time,| to reissue them,| and
|就重新发布它们，|最后，我们有，有所有的，

143
00:04:28,570 --> 00:04:31,000
0,390 390,540 540,1110 1290,1860 1860,2430
finally we have {} the,

144
00:04:31,120 --> 00:04:32,980
0,390 390,690 690,1380 1560,1800 1800,1860
like has all,| has a
|有一个 coordinator 完成的布尔值。

145
00:04:32,980 --> 00:04:35,440
0,480 480,1020 1020,1350 1500,2070
coordinator finished {} boolean.|
|

146
00:04:36,780 --> 00:04:38,460
0,420 420,570 570,1140 1140,1290 1290,1680
So to handle the {GetTask
所以，为了处理 GetTask RPC ，我们有一个处理程序，

147
00:04:38,490 --> 00:04:39,630
0,390 390,540 540,930 930,1020 1020,1140
-} {RPC -}, we have

148
00:04:39,630 --> 00:04:42,750
0,60 60,690 960,2100 2190,2880 2880,3120
a handler,| that essentially what
|从本质上讲，它所做的是，

149
00:04:42,750 --> 00:04:44,940
0,90 90,630 870,1560 1680,2040 2040,2190
it does is,| it will
|它会设置 reply 字段，

150
00:04:44,940 --> 00:04:47,100
0,240 240,330 330,690 690,1440 1710,2160
set the reply fields,| right
|现在，我还没有实现发布任务的部分，

151
00:04:47,100 --> 00:04:49,380
0,210 210,390 390,750 750,1290 1410,2280
now, I haven't yet implemented

152
00:04:49,380 --> 00:04:50,880
0,390 390,600 600,810 810,1200 1200,1500
the part, that actually issues

153
00:04:50,880 --> 00:04:53,370
0,90 90,660 1110,1650 1890,2190 2220,2490
the task,| and if all
|如果所有的 Map 和 Reduce 任务都完成了，

154
00:04:53,370 --> 00:04:54,450
0,210 210,450 450,570 570,840 840,1080
the Map and Reduce tasks

155
00:04:54,450 --> 00:04:55,800
0,90 90,600 690,870 870,1020 1020,1350
are done,| it will send
|它将发送一个 Done 任务给 worker 并退出。

156
00:04:55,800 --> 00:04:56,910
0,210 210,480 480,900 900,990 990,1110
a Done task to the

157
00:04:56,910 --> 00:04:58,660
0,510 750,990 990,1320
worker and exit.|
|

158
00:04:59,190 --> 00:05:01,140
0,750 1110,1290 1290,1440 1440,1560 1560,1950
{} And then we have
然后我们有 FinishedTask RPC 的处理程序，

159
00:05:01,140 --> 00:05:03,360
0,600 990,1410 1410,1950 1950,2130 2130,2220
the the handler for the

160
00:05:03,360 --> 00:05:06,150
0,510 540,1530 1530,1650 1650,2160 2460,2790
{FinishedTask -} {RPC -},| and
|这个所做的是，

161
00:05:06,150 --> 00:05:07,230
0,150 150,300 300,720 720,930 930,1080
what this does is,| it
|它取决于是什么任务，

162
00:05:07,230 --> 00:05:09,720
0,930 1110,1890 1890,2010 2010,2190 2190,2490
basically depending on what task

163
00:05:09,720 --> 00:05:13,530
0,90 90,570 1200,1680 1680,2310 3090,3810
it was,| set that flag
|将那个标志设置为 true ，

164
00:05:13,530 --> 00:05:14,910
0,120 120,450 450,750 750,1020 1020,1380
to true,| that has that
|那个任务已经完成。

165
00:05:15,120 --> 00:05:16,760
0,510 510,690 690,1290
task has finished.|
|

166
00:05:17,550 --> 00:05:19,020
0,420 420,780 780,840 840,1140 1140,1470
So that's the second step,|
这就是第二步，|

167
00:05:19,020 --> 00:05:20,460
0,270 270,420 420,930 930,1020 1020,1440
which is implementing the handlers
实现 RPC 的处理程序。

168
00:05:20,460 --> 00:05:24,960
0,120 120,240 240,780 3660,4290 4350,4500
with {RPCs -}.| So the
|所以，我的第三步是发送 RPC ，

169
00:05:24,960 --> 00:05:26,310
0,270 270,510 510,600 600,930 930,1350
third step I have is

170
00:05:27,090 --> 00:05:28,890
0,480 480,960 960,1050 1050,1200 1200,1800
actually sending the {RPCs -},|
|

171
00:05:29,610 --> 00:05:32,480
0,570 810,1020 1020,1470 1740,2460
and so that happened
就是这里的工作。

172
00:05:32,840 --> 00:05:35,060
0,180 180,480 480,1050
is the {work,here}.|
|

173
00:05:35,930 --> 00:05:39,100
0,1830
So,
所以，这个最上面，

174
00:05:39,340 --> 00:05:40,440
0,300
{}

175
00:05:40,700 --> 00:05:42,380
0,330 330,420 420,660 660,990 1290,1680
top of this is,| we
|我们提供的是，

176
00:05:42,410 --> 00:05:44,000
0,540 780,1050 1050,1170 1170,1440 1440,1590
provided what it does is,|
|

177
00:05:44,000 --> 00:05:45,200
0,120 120,390 390,510 510,660 660,1200
it starts up this loop,|
它启动这个循环，|

178
00:05:45,560 --> 00:05:48,320
0,240 240,1170 1350,1770 1770,2310 2310,2760
that basically for every loop,|
在每个循环中，|

179
00:05:48,320 --> 00:05:50,270
0,180 180,840 930,1140 1140,1560 1560,1950
it calls the handler {for,GetTask
它调用在 coordinator 中 GetTask 的处理程序，

180
00:05:50,270 --> 00:05:53,000
0,480 810,990 990,1110 1110,1890 2490,2730
-} in the coordinator,| and
|根据它获得的任务的不同，

181
00:05:53,000 --> 00:05:54,140
0,420 420,540 540,720 720,1020 1020,1140
depending on what task it

182
00:05:54,140 --> 00:05:55,550
0,330 330,420 420,540 540,1050 1050,1410
gets,| it will either perform
|它将使用相关数据执行 Map 任务，

183
00:05:55,550 --> 00:05:58,010
0,270 270,810 990,1230 1230,1680 1920,2460
Map task with the relevant

184
00:05:58,010 --> 00:05:59,810
0,420 420,660 660,1080 1080,1290 1290,1800
data| or metadata that needs
|或需要执行 Reduce 任务的元数据，

185
00:05:59,840 --> 00:06:01,430
0,630 630,720 720,1020 1020,1470 1470,1590
perform the Reduce task,| or
|或者在 Done 的情况下，它将退出。

186
00:06:01,430 --> 00:06:02,360
0,60 60,150 150,390 390,510 510,930
in the case of done,

187
00:06:02,360 --> 00:06:03,420
0,120 120,240 240,630
it will exit.|
|

188
00:06:03,570 --> 00:06:05,370
0,750 840,1320 1320,1470 1470,1620 1620,1800
{} And so it's very
所以这很简单，

189
00:06:05,370 --> 00:06:06,360
0,300 300,420 420,570 570,690 690,990
simple,| and once it's finished
|一旦它完成了这项任务，

190
00:06:06,360 --> 00:06:08,040
0,150 150,600 810,1020 1020,1170 1170,1680
that task,| it will send
|它将发送一个 FinishedTask RPC 给 coordinator 。

191
00:06:08,040 --> 00:06:10,140
0,150 150,630 630,1200 1380,1590 1590,2100
a {FinishedTask -} {RPC -}

192
00:06:10,140 --> 00:06:11,620
0,120 120,210 210,930
to the coordinator.|
|

193
00:06:11,620 --> 00:06:12,910
0,420 420,630 630,750 750,1110 1110,1290
So this is just the
所以，这只是 worker 发送 RPC 的框架代码。

194
00:06:12,910 --> 00:06:16,510
0,780 870,1710 1710,2400 2640,3090 3090,3600
skeleton code for the worker

195
00:06:16,510 --> 00:06:18,120
0,360 360,540 540,1140
sending {RPCs -}.|
|

196
00:06:19,100 --> 00:06:19,790
0,240 240,360 360,450 450,540 540,690
Alright, so we have {RPCs
好的，我们有 RPC ，我们有处理程序，我们有发送者，

197
00:06:19,790 --> 00:06:21,320
0,540 540,630 630,780 780,1320 1320,1530
-}, we have handlers, {we,have}

198
00:06:21,320 --> 00:06:22,940
0,60 60,630 840,1230 1230,1320 1320,1620
the senders,| and so now,
|所以现在，让我们来实现一些东西。

199
00:06:22,940 --> 00:06:24,800
0,210 210,750 750,1230 1230,1350 1350,1860
let's actually implement some stuff.|
|

200
00:06:25,220 --> 00:06:30,320
0,810 3660,3840 3840,4110 4110,4680 4710,5100
So in step four,| it's
所以在第四步中，|我只是添加了大量的处理程序来管理这个中间文件，

201
00:06:31,340 --> 00:06:32,750
0,210 210,390 390,750 750,1110 1170,1410
I just added a ton

202
00:06:32,750 --> 00:06:34,940
0,270 330,990 990,1440 1470,1950 1950,2190
of handlers to manage this

203
00:06:34,940 --> 00:06:37,400
0,630 630,1050 1650,2100 2100,2370 2370,2460
intermediate file,| {} which a
|你们中的许多人也这样做了，

204
00:06:37,400 --> 00:06:38,780
0,180 180,240 240,600 600,900 900,1380
lot of you also did,|
|

205
00:06:39,200 --> 00:06:40,880
0,450 450,930 930,1170 1170,1440 1440,1680
and basically it uses like
基本上它使用了比如 os.Rename ，

206
00:06:40,880 --> 00:06:42,410
0,150 150,420 420,1110 1110,1320 1320,1530
{} {os.Rename -},| it gets
|它会得到一个临时文件，

207
00:06:42,410 --> 00:06:45,410
0,240 240,690 690,1320 2490,2790 2790,3000
a temporary file,| so it's
|所以这并不太有趣，

208
00:06:45,410 --> 00:06:47,570
0,210 210,480 480,1140 1740,1980 1980,2160
not too interesting,| and then
|然后，下一步，

209
00:06:47,570 --> 00:06:49,310
0,90 90,360 360,960 990,1290 1290,1740
the next step,| let's actually
|让我们实现一些 worker 的功能。

210
00:06:49,310 --> 00:06:51,020
0,840 960,1200 1200,1290 1290,1380 1380,1710
implement some of the worker

211
00:06:51,020 --> 00:06:53,560
0,870 1410,2130
functionality.| So,
|所以，我们又回到了 worker ，

212
00:06:53,880 --> 00:06:54,930
0,120 120,330 330,390 390,480 480,1050
we're back in the worker,|
|

213
00:06:55,900 --> 00:06:57,670
0,600 600,960 960,1230 1230,1680 1680,1770
and now let's implement the
现在让我们实现 PerformMap 函数，

214
00:06:57,670 --> 00:06:59,540
0,480 480,690 690,1260
{performMap -} function,|
|

215
00:07:00,270 --> 00:07:02,280
0,450 450,690 690,870 870,1350 1350,2010
and what this does is,
这样做的目的是，你们中许多已经做的是，

216
00:07:02,850 --> 00:07:04,050
0,330 330,630 630,810 810,990 990,1200
as many you have to

217
00:07:04,050 --> 00:07:05,880
0,360 360,690 720,1050 1050,1140 1140,1830
do is| read the file,
|读取文件，将它们映射到键上，

218
00:07:05,910 --> 00:07:08,070
0,660 660,810 810,900 900,1740 1800,2160
map them to keys,| and
|然后创建临时文件，将它们写入中间文件，

219
00:07:08,070 --> 00:07:10,110
0,450 450,780 780,1110 1110,1770 1770,2040
then create temporary files, write

220
00:07:10,110 --> 00:07:12,360
0,330 330,930 1080,1230 1230,1710 1710,2250
them to the intermediate files,|
|

221
00:07:12,360 --> 00:07:13,830
0,150 150,540 570,720 720,900 900,1470
and then we use an
然后我们使用原子重命名，

222
00:07:13,860 --> 00:07:16,200
0,540 540,1140 1170,1470 1470,1950 1950,2340
atomic rename| to ensure that
|以确保映射不会冲突

223
00:07:16,380 --> 00:07:18,060
0,420 420,630 630,1140 1140,1320 1320,1680
maps aren't conflicting| as they
|在处理键和写入键时。

224
00:07:18,060 --> 00:07:19,290
0,480 480,540 540,870 870,1020 1020,1230
process the keys and write

225
00:07:19,290 --> 00:07:20,020
0,300
them.|
|

226
00:07:20,550 --> 00:07:22,650
0,660 720,1050 1050,1530 1560,1800 1800,2100
So this is pretty much
所以这在很大程度上是从顺序实现中提取出来的，

227
00:07:22,650 --> 00:07:25,410
0,510 510,1230 1230,1440 1440,1890 1890,2760
taken from the sequential implementation|
|

228
00:07:25,440 --> 00:07:26,550
0,390 420,600 600,720 720,840 840,1110
and how you would apply
以及如何应用 Map 函数。

229
00:07:26,550 --> 00:07:29,340
0,90 90,390 390,840 2040,2250 2250,2790
the Map function.| And then
|然后，类似地，我们实现 Reduce 函数，

230
00:07:30,150 --> 00:07:33,990
0,930 930,1470 2400,3270 3360,3510 3510,3840
similarly, we implement the Reduce

231
00:07:33,990 --> 00:07:36,780
0,600 870,1650 1710,2100 2100,2160 2160,2790
function,| so here's a performMap,|
|这里有一个 performMap ，|

232
00:07:36,900 --> 00:07:38,040
0,450 450,540 540,630 630,780 780,1140
and then we have {performReduce
然后我们有一个 performReduce ，

233
00:07:38,040 --> 00:07:40,050
0,600 960,1320 1320,1680 1680,1860 1860,2010
-},| and so what that
|所以它所做的就是，

234
00:07:40,050 --> 00:07:41,010
0,240 240,390 390,540 540,750 750,960
does is,| it gets all
|它会获取所有中间文件，

235
00:07:41,010 --> 00:07:43,380
0,60 60,570 570,1170 2040,2280 2280,2370
the intermediate files with the

236
00:07:43,380 --> 00:07:45,570
0,660 960,1560 1620,1890 1890,2100 2100,2190
appropriate,| {} from all the
|从所有 Map 任务，到这个 Reduce 任务，

237
00:07:45,570 --> 00:07:47,430
0,240 240,750 840,1350 1350,1560 1560,1860
Map tasks, for this Reduce

238
00:07:47,430 --> 00:07:50,610
0,420 1080,1770 1800,2280 2280,2850 2940,3180
tasks,| and sorts them, so
|并对它们进行排序，排序发生在 worker 上，

239
00:07:50,610 --> 00:07:53,120
0,390 390,1080 1110,1470 1470,2100
sorting happens in the,

240
00:07:53,740 --> 00:07:55,930
0,180 180,300 300,900 930,1560 1860,2190
in the worker,| because the
|因为 worker 需要，

241
00:07:55,930 --> 00:07:58,000
0,330 330,780 870,1080 1080,1650 1650,2070
worker needs,| the reducer needs
|reducer 需要访问这个类型的所有键，

242
00:07:58,000 --> 00:07:59,470
0,510 510,810 810,1110 1110,1380 1380,1470
access to all keys of

243
00:07:59,470 --> 00:08:01,330
0,150 150,600 630,780 780,1200 1260,1860
that type,| and then {to,sort}
|然后对它们进行排序。

244
00:08:01,330 --> 00:08:02,340
0,510
them.|
|

245
00:08:03,240 --> 00:08:04,350
0,390 390,630 630,810 810,990 990,1110
It wouldn't make sense for
对于 mapper 是没有意义的，

246
00:08:04,350 --> 00:08:05,220
0,60 60,420 420,570 570,780 780,870
the mapper,| just sort them
|在之前对它们进行排序，

247
00:08:05,220 --> 00:08:07,170
0,660 690,1350 1350,1440 1440,1770 1770,1950
before,| because the mapper only
|因为 mapper 只访问一些键。

248
00:08:07,170 --> 00:08:10,160
0,780 810,1170 1170,1260 1260,1770
has {access,some} the keys.|
|

249
00:08:10,440 --> 00:08:11,130
0,150 150,240 240,390 390,630 630,690
And then we apply the
然后我们对同一个键的所有值应用 reduce 函数，

250
00:08:11,130 --> 00:08:13,050
0,330 330,720 720,1230 1380,1590 1590,1920
reduce function to all values

251
00:08:13,050 --> 00:08:14,280
0,90 90,150 150,360 360,810 810,1230
of the same key,| and
|然后，我们将临时 reduce 文件原子重命名为最终的 reduce 文件。

252
00:08:14,280 --> 00:08:16,080
0,210 210,390 390,870 870,1140 1140,1800
then we {atomically -} rename

253
00:08:16,140 --> 00:08:17,730
0,180 180,600 600,960 960,1410 1410,1590
the temporary reduce file to

254
00:08:17,730 --> 00:08:19,760
0,330 360,720 720,1050 1050,1350
the final reduce file.|
|

255
00:08:20,470 --> 00:08:22,810
0,330 330,810 810,1110 1110,1710 2010,2340
So, now this loop we've
所以，现在我们实现的这个循环，

256
00:08:22,810 --> 00:08:24,940
0,750 750,1560
implemented basically,|
|

257
00:08:25,000 --> 00:08:26,320
0,180 180,660 660,1140 1140,1230 1230,1320
the actual perform {} the
执行任务，

258
00:08:26,320 --> 00:08:29,380
0,870 900,1440 1860,2430 2430,2910 2910,3060
task,| and we're basically done
|我们基本上完成了 worker 的实现。

259
00:08:29,380 --> 00:08:31,280
0,150 150,240 240,510 510,1290
with the worker implementation.|
|

260
00:08:31,820 --> 00:08:33,350
0,270 270,480 480,690 690,960 960,1530
So one last step remains,|
所以还剩下最后一步，|

261
00:08:33,410 --> 00:08:35,390
0,360 360,510 510,720 720,1230 1230,1980
{} and that's actually implementing,|
这是实现，|

262
00:08:35,390 --> 00:08:37,970
0,690 720,1620 1650,2190 2190,2310 2310,2580
{how,this} coordinator tells the worker
coordinator 如何告诉 worker 要做哪些任务，

263
00:08:37,970 --> 00:08:39,830
0,330 330,720 720,840 840,1290 1650,1860
which tasks to do,| and
|这可能是，

264
00:08:39,830 --> 00:08:42,950
0,150 150,390 390,1200 1200,1860 2940,3120
this is probably| where you
|你在 coordinator 中遇到的最复杂的同步问题。

265
00:08:42,950 --> 00:08:45,080
0,150 150,330 330,450 450,1080 1440,2130
ran into the most complexity

266
00:08:45,080 --> 00:08:46,940
0,210 210,960 960,1170 1170,1320 1320,1860
with synchronization in the coordinator.|
|

267
00:08:49,040 --> 00:08:50,450
0,270 270,420 420,510 510,600 600,1410
{So\,,go} back to the coordinator,|
所以，回到 coordinator ，|

268
00:08:51,500 --> 00:08:53,210
0,600 690,1110 1110,1290 1290,1590 1590,1710
so nothing has changed in
所以这个状态什么都没有改变，

269
00:08:53,210 --> 00:08:55,940
0,510 600,1380 1800,2100 2100,2400 2400,2730
the state,| so, but now
|但现在我们所做的是，

270
00:08:55,940 --> 00:08:56,960
0,180 180,360 360,600 600,780 780,1020
what we've done is,| we've
|我们在 coordinate 中添加了一个循环，

271
00:08:56,960 --> 00:08:57,890
0,300 300,390 390,750 750,840 840,930
added a loop in the

272
00:08:57,890 --> 00:09:00,260
0,810 840,1140 1140,1890 1890,2310 2310,2370
coordinator,| that handles sending the
|它负责将任务发送给 worker 。

273
00:09:00,260 --> 00:09:01,820
0,360 360,420 420,540 540,1050
task to the worker.|
|

274
00:09:02,720 --> 00:09:05,760
0,630 720,1410 1440,1740 1740,2460
And {} when we're
当我们发布 Map 任务时，

275
00:09:05,760 --> 00:09:07,770
0,570 570,660 660,900 900,1410 1410,2010
issuing the Map task,| so
|所以首先我们想要发布所有的 Map 任务，

276
00:09:07,800 --> 00:09:08,640
0,270 270,360 360,540 540,630 630,840
first we want to issue

277
00:09:08,640 --> 00:09:10,080
0,90 90,150 150,360 360,780 1140,1440
all the Map task,| and
|基本上这个循环在这里所做的是，

278
00:09:10,080 --> 00:09:12,120
0,420 660,1200 1200,1500 1500,1740 1740,2040
so essentially what this loop

279
00:09:12,120 --> 00:09:15,300
0,300 300,840 1320,1890 1920,2850 2910,3180
does here is,| until there's
|在有任务要发布之前，

280
00:09:15,300 --> 00:09:17,130
0,90 90,510 510,630 630,1350 1530,1830
a task to issue,| the
|coordinator 只是迭代这个循环，

281
00:09:17,130 --> 00:09:21,270
0,930 960,1590 1890,2760 3510,4020 4020,4140
coordinator will just iterate to

282
00:09:21,270 --> 00:09:22,950
0,180 180,660 930,1380 1380,1560 1560,1680
this loop,| and if we're
|如果我们完成了所有的 Map 任务，

283
00:09:22,950 --> 00:09:23,640
0,180 180,300 300,390 390,480 480,690
done with all the Map

284
00:09:23,640 --> 00:09:24,570
0,270 270,360 360,510 510,750 750,930
tasks,| that will break out
|这将打破这个循环，

285
00:09:24,570 --> 00:09:25,400
0,90 90,420
the loop,|
|

286
00:09:26,730 --> 00:09:27,780
0,330 330,570 570,780 780,960 960,1050
and then, if all the
然后，如果所有 Map 任务都完成了，

287
00:09:27,780 --> 00:09:28,860
0,420 420,510 510,780 780,960 960,1080
{Map,tasks} are done,| then we
|然后我们发布 Reduce 任务，

288
00:09:28,860 --> 00:09:30,680
0,330 330,660 660,1290
issue Reduce task,|
|

289
00:09:31,080 --> 00:09:32,310
0,330 330,480 480,720 720,870 870,1230
which is what's in here.|
就是这里的东西。|

290
00:09:35,380 --> 00:09:38,620
0,600 1320,1860 2490,2700 2700,3180 3180,3240
So, yeah, I have, I
所以，是的，我想我还有最后一步，

291
00:09:38,620 --> 00:09:40,390
0,180 180,540 990,1230 1230,1500 1500,1770
guess I have one last

292
00:09:40,390 --> 00:09:42,880
0,360 360,750 750,1170 1170,2100 2220,2490
step,| which is actually what
|就是我们所做的，

293
00:09:42,880 --> 00:09:44,350
0,150 150,510 510,810 810,900 900,1470
we do,| when the maps
|当 maps 或 reduces ，当没有任务要发布时，

294
00:09:44,350 --> 00:09:46,810
0,210 210,1080 1290,1890 1980,2250 2250,2460
or reduces, {} when there's

295
00:09:46,810 --> 00:09:48,520
0,270 270,630 630,690 690,1260 1290,1710
no task to issue| and
|所以我们想做的是，

296
00:09:48,520 --> 00:09:49,360
0,150 150,270 270,450 450,570 570,840
so we want to do

297
00:09:49,360 --> 00:09:51,100
0,600 690,930 930,1020 1020,1560 1560,1740
then,| is the coordinator should
|coordinator 应该等待任务发布，

298
00:09:51,100 --> 00:09:53,020
0,330 360,840 870,1470 1500,1620 1620,1920
just wait for a task

299
00:09:53,020 --> 00:09:55,480
0,660 930,1440 1440,1710 1710,2010
issue,| and once it,
|一旦发生，就会出现任务发布，

300
00:09:55,570 --> 00:09:57,550
0,420 420,480 480,750 750,1350 1350,1980
there's a task issue,| {or,to,another}
|或者到另一个发布循环的迭代，

301
00:09:57,550 --> 00:09:59,020
0,480 480,600 600,720 720,1140 1170,1470
issue iteration the loop| and
|然后发布任务。

302
00:09:59,020 --> 00:10:00,940
0,180 180,630 630,1110 1290,1380 1380,1920
then actually issue the task.|
|

303
00:10:01,650 --> 00:10:03,120
0,270 270,540 540,960 960,1260 1260,1470
{} I'll continue until all
我将继续，直到所有的 Map 或 Reduce 任务完成，

304
00:10:03,120 --> 00:10:04,290
0,90 90,390 390,600 600,780 780,1170
the Map were all Reduce

305
00:10:04,290 --> 00:10:05,600
0,270 270,360 360,720
tasks are done,|
|

306
00:10:06,720 --> 00:10:08,070
0,330 330,570 570,840 840,1050 1050,1350
and after done, I'll return
完成后，我会再回来，

307
00:10:08,070 --> 00:10:10,380
0,480 510,1140 1710,1890 1890,1980 1980,2310
again,| so let me {go,to}.|
|所以让我去。|

308
00:10:13,620 --> 00:10:16,350
0,450 690,1350 1470,1680 1680,2100 2100,2730
Right, so in order to
所以为了支持那个等待，

309
00:10:16,530 --> 00:10:19,120
0,720 720,1080 1080,1830
support that waiting,|
|

310
00:10:19,640 --> 00:10:21,650
0,420 420,570 570,1380 1410,1860 1860,2010
what my solution does is
我的解决方案是使用条件变量，

311
00:10:21,650 --> 00:10:23,360
0,120 120,570 570,780 780,1170 1170,1710
it uses a condition variable,|
|

312
00:10:24,610 --> 00:10:27,520
0,870 1560,2310
{} and
从本质上讲，它所做的是，

313
00:10:27,790 --> 00:10:29,650
0,510 510,720 720,900 900,1320 1320,1860
essentially what that does is,|
|

314
00:10:29,890 --> 00:10:31,780
0,450 450,630 630,750 750,1440 1530,1890
if there are no Map
如果没有 Map 任务发布，

315
00:10:31,780 --> 00:10:34,870
0,390 390,1110 1470,1890 1920,2370 2370,3090
task issue,| but the mappers,
|但是 mappers ，但是这里，

316
00:10:34,900 --> 00:10:38,530
0,570 1170,1590 1620,2010 2040,2790 2940,3630
{ -} but there,| because
|因为我们已经分配了它们所有，

317
00:10:38,530 --> 00:10:39,610
0,210 210,570 570,660 660,720 720,1080
we've assigned all of them,

318
00:10:39,610 --> 00:10:40,960
0,150 150,750 780,930 930,1050 1050,1350
for example,| and we're waiting
|我们在们它们，

319
00:10:40,960 --> 00:10:42,550
0,120 120,510 540,1020 1020,1290 1290,1590
for them,| and they haven't
|它们还没有超时，

320
00:10:42,550 --> 00:10:44,020
0,240 240,420 420,810 900,1290 1290,1470
timed out yet,| then we
|那么我们要做的就是等待，

321
00:10:44,020 --> 00:10:45,610
0,180 180,240 240,510 510,1050 1050,1590
want to do is wait,|
|

322
00:10:45,670 --> 00:10:48,340
0,750 810,1380 1380,1470 1470,2070 2220,2670
{} because we cannot issue
因为我们不能发布 Reduce 任务，

323
00:10:48,340 --> 00:10:49,510
0,120 120,510 510,870 870,1020 1020,1170
a Reduce task,| if all
|如果所有的 mappers 都没有完成，

324
00:10:49,510 --> 00:10:50,740
0,90 90,420 420,540 540,720 720,1230
the mappers have not finished,|
|

325
00:10:51,040 --> 00:10:52,510
0,810 930,1110 1110,1260 1260,1380 1380,1470
so we're just going to
所以我们就在这里等着，

326
00:10:52,510 --> 00:10:54,580
0,240 240,780 900,1170 1170,1560 1560,2070
wait here,| and then once
|一旦我们收到某种信号，

327
00:10:54,580 --> 00:10:55,690
0,150 150,570 570,810 810,1020 1020,1110
we get some type of

328
00:10:55,690 --> 00:10:57,190
0,720 780,990 990,1170 1170,1350 1350,1500
signal,| we're just going to
|我们回到这个循环的顶端，

329
00:10:57,190 --> 00:10:58,120
0,180 180,450 450,540 540,690 690,930
go back to the top

330
00:10:58,120 --> 00:10:59,040
0,120 120,270 270,660
of this loop,|
|

331
00:10:59,130 --> 00:11:00,060
0,240 240,480 480,690 690,780 780,930
and check whether we can
检查我们是否可以再次发布任务。

332
00:11:00,060 --> 00:11:01,680
0,210 210,270 270,570 570,990
issue a task again.|
|

333
00:11:02,510 --> 00:11:05,600
0,1140 1650,2220 2250,2520 2520,2580 2580,3090
Similarly, if all the reducers
同样，如果所有 reducers 都没有完成，

334
00:11:05,600 --> 00:11:06,800
0,270 270,570 570,690 690,780 780,1200
aren't done,| but we can't
|我们不能给 worker 发布任务，

335
00:11:06,800 --> 00:11:08,450
0,360 360,690 690,1050 1080,1500 1530,1650
actually issue the worker a

336
00:11:08,450 --> 00:11:10,520
0,540 570,900 900,1170 1170,1530 1530,2070
task,| we're going to wait
|我们要等待出现某种信号，

337
00:11:10,580 --> 00:11:11,960
0,630 780,1020 1020,1110 1110,1230 1230,1380
for there to be some

338
00:11:11,960 --> 00:11:12,980
0,180 180,270 270,720 720,840 840,1020
type of signals,| so when
|那么信号到底是什么时候出现？

339
00:11:12,980 --> 00:11:14,810
0,150 150,240 240,630 630,1170 1170,1830
does the signal actually happen?|
|

340
00:11:15,380 --> 00:11:16,520
0,690
Well,
好的，我们想要在任何时候发出信号，

341
00:11:16,850 --> 00:11:18,590
0,210 210,480 480,750 750,1290 1290,1740
we want to signal any

342
00:11:18,590 --> 00:11:21,350
0,660 810,1680 1830,2010 2010,2490 2490,2760
time| either a task has
|无论任务完成或时间太长，我们没有收到回复，

343
00:11:21,350 --> 00:11:22,340
0,240 240,390 390,540 540,720 720,990
done or for too long

344
00:11:22,340 --> 00:11:23,300
0,90 90,180 180,450 450,660 660,960
and we haven't heard back,|
|

345
00:11:23,300 --> 00:11:23,960
0,120 120,270 270,420 420,540 540,660
so there might have been
所以可能会有失败，

346
00:11:23,960 --> 00:11:28,070
0,120 120,750 1470,2160 2490,3060 3090,4110
a failure,| or if the,
|或者如果一个 worker 完成了一项任务，

347
00:11:28,100 --> 00:11:29,030
0,150 150,270 270,570 570,690 690,930
if a worker has actually

348
00:11:29,030 --> 00:11:30,470
0,450 450,540 540,930 930,1320 1320,1440
completed a task,| because for
|因为这可能意味着所有 Map 任务都已经完成，

349
00:11:30,470 --> 00:11:31,730
0,420 420,600 600,840 840,1140 1140,1260
example that might mean all

350
00:11:31,730 --> 00:11:33,050
0,90 90,360 360,660 660,780 780,1320
the Map tasks has finished,|
|

351
00:11:33,050 --> 00:11:33,740
0,120 120,270 270,450 450,600 600,690
we can move on to
我们可以继续执行一项 Reduce 任务。

352
00:11:33,740 --> 00:11:34,920
0,90 90,390 390,840
a Reduce task.|
|

353
00:11:35,430 --> 00:11:38,910
0,390 390,510 510,870 870,1500 3150,3480
So in order to do
所以，为了做到这一点，

354
00:11:38,910 --> 00:11:41,610
0,300 300,480 480,660 660,1380 1710,2700
that,| what we have are,|
|我们有的是，|

355
00:11:42,420 --> 00:11:43,400
0,270 270,480

356
00:11:45,020 --> 00:11:45,980
0,150 150,300 300,420 420,750 750,960
we have a {goroutine -}
我们这里有一个 goroutine ，

357
00:11:45,980 --> 00:11:47,800
0,510 540,1290
here,| that's
|这是当 coordinator 开始时发出的，

358
00:11:48,190 --> 00:11:49,380
0,630
{}

359
00:11:50,070 --> 00:11:51,870
0,270 270,330 330,660 660,1080 1140,1800
kind of spawn off immediately

360
00:11:51,870 --> 00:11:53,940
0,150 150,240 240,840 840,1500 1620,2070
as the coordinator starts,| and
|它所做的是每隔一段时间，

361
00:11:53,940 --> 00:11:55,440
0,180 180,360 360,720 720,1230 1230,1500
what this does is every

362
00:11:55,440 --> 00:11:57,900
0,210 210,300 300,960 1260,1950 2010,2460
once in awhile,| {} after
|在一些或许每秒，

363
00:11:57,900 --> 00:11:59,760
0,510 600,720 720,1020 1260,1620 1620,1860
some you know maybe every

364
00:11:59,760 --> 00:12:01,260
0,360 360,480 480,1020 1050,1380 1380,1500
second or so,| when a
|当一项任务可能已经完成时，

365
00:12:01,260 --> 00:12:03,220
0,480 480,720 720,930 930,1560
task might have finished,|
|

366
00:12:03,310 --> 00:12:04,330
0,120 120,360 360,750 750,810 810,1020
or maybe this is ten
或许这是十秒，我记不清了，

367
00:12:04,330 --> 00:12:05,920
0,330 330,390 390,930 1050,1260 1260,1590
seconds, {I,can't,remeber -},| {} actually
|事实上，这并不重要，

368
00:12:05,920 --> 00:12:07,210
0,60 60,270 270,480 480,960 990,1290
it doesn't really matter,| it
|它只是时不时地唤醒 coordinator ，

369
00:12:07,210 --> 00:12:08,140
0,210 210,420 420,540 540,810 810,930
just wants to wake up

370
00:12:08,140 --> 00:12:09,370
0,60 60,570 570,810 810,960 960,1230
the coordinator every so often,|
|

371
00:12:09,370 --> 00:12:10,840
0,210 210,330 330,1140 1170,1320 1320,1470
so the coordinator will do
所以 coordinator 会再做一次检查，

372
00:12:10,840 --> 00:12:12,400
0,450 450,870 1020,1140 1140,1290 1290,1560
another check| to see whether
|查看是否有要发布的任务，

373
00:12:12,400 --> 00:12:13,360
0,330 360,510 510,570 570,900 900,960
there is a task to

374
00:12:13,360 --> 00:12:14,890
0,600 750,1050 1050,1140 1140,1290 1290,1530
issue,| and so it just
|所以它就这样循环着，

375
00:12:14,890 --> 00:12:17,350
0,210 210,750 960,1440 1680,2070 2070,2460
loops around,| and every second
|每一秒它都会广播唤醒 coordinator 。

376
00:12:17,350 --> 00:12:18,940
0,180 180,900 930,1110 1110,1500 1500,1590
{it,will} broadcast to {wake,up} the

377
00:12:18,940 --> 00:12:21,920
0,750
coordinator.|
|

378
00:12:22,620 --> 00:12:24,630
0,630 930,1290 1290,1620 1620,1920 1920,2010
And the other time we
另一个我们想要在任务完成时发出信号，

379
00:12:24,630 --> 00:12:25,470
0,150 150,240 240,570 570,780 780,840
want to signal when a

380
00:12:25,470 --> 00:12:28,140
0,270 270,450 450,1080 1500,2160 2160,2670
task is finished,| so that's
|所以，这将在这个 HandleFinishedTask 中发生，

381
00:12:28,350 --> 00:12:29,430
0,330 330,450 450,540 540,930 930,1080
actually going to happen in

382
00:12:29,430 --> 00:12:31,110
0,180 180,510 510,750 750,1410 1440,1680
this {HandleFinishedTask - -},| which
|当一个 worker FinishedTask 任务 RPC 完成时，

383
00:12:31,110 --> 00:12:34,470
0,390 390,1080 1140,1620 1620,2760 2760,3360
is called when a worker

384
00:12:34,590 --> 00:12:36,090
0,300 300,870 900,1110 1110,1440 1440,1500
like [] {} {FinishedTask -}

385
00:12:36,090 --> 00:12:38,760
0,420 420,1050 1590,1920 1920,2310 2310,2670
task RPC,| and so here
|所以，在这里有一个 Broadcast ，

386
00:12:38,760 --> 00:12:40,890
0,150 150,690 900,1200 1200,1890 1890,2130
we have a Broadcast| right
|在我们将[]设置为 Done 之后，

387
00:12:40,890 --> 00:12:43,590
0,510 510,810 810,1260 1290,1860 2370,2700
after we set the []

388
00:12:44,010 --> 00:12:46,560
0,360 360,900 1200,1530 1530,2070 2100,2550
to done or to complete

389
00:12:46,560 --> 00:12:48,660
0,150 150,240 240,690 1170,1740
it to done,| and
|当 coordinator 回去检查其中一个循环时，

390
00:12:48,890 --> 00:12:50,960
0,420 420,780 810,1440 1440,1680 1680,2070
when the coordinator goes back

391
00:12:50,960 --> 00:12:52,010
0,180 180,600 600,840 840,960 960,1050
to go check one of

392
00:12:52,010 --> 00:12:53,060
0,210 210,510 510,660 660,780 780,1050
these loops,| and see whether
|看看有没有任务要完成，

393
00:12:53,060 --> 00:12:54,950
0,240 240,270 270,690 690,1050 1110,1890
there's a task to finish,|
|

394
00:12:54,980 --> 00:12:56,570
0,210 210,330 330,570 570,810 810,1590
it will see that updated
它将看到更新后 Done 状态。

395
00:12:56,930 --> 00:12:58,520
0,420 420,1140
Done status.|
|

396
00:12:59,120 --> 00:13:02,240
0,690 1110,1440 1440,2310 2310,2490 2490,3120
So that's essentially my solution,|
所以这就是我的解决方案，|

397
00:13:02,510 --> 00:13:04,850
0,690 1050,1260 1260,1590 1590,1890 1890,2340
{} it uses cond vars
它使用条件变量和 Mutex 来保护 coordinator 的共享状态。

398
00:13:04,850 --> 00:13:08,330
0,660 660,840 840,1440 1440,2040 2430,3480
and {Mutex -} to protect

399
00:13:08,330 --> 00:13:10,260
0,330 330,600 600,1350
shared {state,of} coordinator.|
|

400
00:13:11,000 --> 00:13:11,960
0,150 150,330 330,480 480,720 720,960
So this is only one
所以这只是一种可能的解决方案，

401
00:13:11,960 --> 00:13:14,450
0,360 360,960 1560,2160 2160,2340 2340,2490
possible solution| and I'll get
|然后我会回到这里，

402
00:13:14,450 --> 00:13:18,470
0,240 240,810 1140,1830 2430,3840 3840,4020
back to here,| and so
|这就是我采取的步骤的布局。

403
00:13:18,470 --> 00:13:20,600
0,270 270,480 480,1080 1320,2070 2070,2130
this is the kind of

404
00:13:20,600 --> 00:13:21,530
0,330 330,480 480,600 600,870 870,930
layout of the steps I

405
00:13:21,530 --> 00:13:22,380
0,390
took.|
|

406
00:13:22,860 --> 00:13:24,540
0,300 300,480 480,600 600,930 930,1680
{} Are there any questions
在我继续之前，对这个解决方案，有什么问题吗？

407
00:13:24,540 --> 00:13:26,640
0,360 360,750 750,1410 1410,1860 1860,2100
on that particular solution before

408
00:13:26,640 --> 00:13:27,920
0,90 90,300 300,690
I move on?|
|

409
00:13:30,910 --> 00:13:32,530
0,300 300,450 450,600 600,990 990,1620
{} Can you please elaborate
你能更详细地说明一下条件变量吗？

410
00:13:32,530 --> 00:13:33,790
0,120 120,360 360,720 720,1050 1050,1260
a little more on the

411
00:13:33,790 --> 00:13:35,780
0,660 660,1410
conditional variable?|
|

412
00:13:36,770 --> 00:13:39,080
0,660 690,1440
Sure, {}
当然，所以，我想条件变量是，

413
00:13:40,400 --> 00:13:43,310
0,630 720,1290 1530,2100 2100,2790 2790,2910
so, {} what exactly, I

414
00:13:43,310 --> 00:13:45,320
0,180 180,450 450,1170 1290,1410 1410,2010
guess like {} a conditional

415
00:13:45,320 --> 00:13:47,520
0,750 780,1740
variable is,|
|

416
00:13:47,730 --> 00:13:49,560
0,600 600,1200 1200,1440 1440,1710 1710,1830
very useful,| for when you
非常有用，|当你想要等待特定断言或特定条件变为真时，

417
00:13:49,560 --> 00:13:50,550
0,210 210,390 390,720 720,900 900,990
want to wait for a

418
00:13:50,550 --> 00:13:53,820
0,720 720,1350 1440,1740 1740,2550 2550,3270
particular predicate or particular condition

419
00:13:53,820 --> 00:13:55,860
0,120 120,480 480,1050 1260,1920 1920,2040
to become true,| so in
|所以在这种情况下，条件变量是自然的，

420
00:13:55,860 --> 00:13:57,140
0,180 180,780
this case,

421
00:13:57,680 --> 00:13:59,630
0,210 210,660 660,1200 1200,1710 1770,1950
{} condition variable is a

422
00:13:59,630 --> 00:14:02,870
0,960 1110,1590 1590,1740 1740,2070 3030,3240
natural,| let me just go
|让我到我用到的地方，

423
00:14:02,870 --> 00:14:04,490
0,120 120,480 480,570 570,930 1020,1620
to where I use, {}|
|

424
00:14:05,300 --> 00:14:07,160
0,300 300,360 360,1170 1200,1560 1560,1860
is a natural way to
是实现等待可用任务的自然方式，

425
00:14:07,160 --> 00:14:09,440
0,780 810,1590 1620,1980 1980,2160 2160,2280
implement waiting for there to

426
00:14:09,440 --> 00:14:12,170
0,150 150,330 330,720 720,1530 1620,2730
be a task available,| because
|因为这是一种特殊的条件，

427
00:14:12,560 --> 00:14:13,610
0,120 120,300 300,450 450,630 630,1050
you know it's a particular

428
00:14:13,610 --> 00:14:16,520
0,750 1020,1740 1890,2430
condition,| and it
|而且它是异步发生的，

429
00:14:17,500 --> 00:14:20,380
0,750 750,900 900,1710 1710,2340 2460,2880
occurs {asynchronously -},| so for
|例如，有一项任务可用时，

430
00:14:20,380 --> 00:14:22,240
0,390 390,570 570,900 900,1020 1020,1860
example a task is available,|
|

431
00:14:22,270 --> 00:14:24,610
0,720 720,1200 1200,1590 1590,1860 1860,2340
when a worker has finished
当 worker 完成一项任务时，

432
00:14:24,610 --> 00:14:26,890
0,30 30,570 900,1470 1530,1830 1830,2280
a task,| {} or task
|或任务可能可用，在发生故障时，

433
00:14:26,890 --> 00:14:30,700
0,270 420,630 630,1380 1770,2670 2850,3810
might be available when the,

434
00:14:31,210 --> 00:14:33,910
0,600 720,1050 1050,1200 1200,2010 2040,2700
{} when a failure occurs,|
|

435
00:14:33,910 --> 00:14:35,110
0,150 150,270 270,510 510,690 690,1200
and we need to reissue
我们需要重新发布这项任务，

436
00:14:35,110 --> 00:14:36,910
0,120 120,600 690,1470 1470,1620 1620,1800
the task,| so you can
|所以你可以想到，

437
00:14:36,910 --> 00:14:38,080
0,210 210,630
think of,|
|

438
00:14:38,140 --> 00:14:40,140
0,300 300,660 660,780 780,1500
any case in which,
在任何情况下，你需要等待特定的条件，

439
00:14:40,450 --> 00:14:41,880
0,690 690,690
{ -

440
00:14:42,330 --> 00:14:43,380
0,300 300,480 480,630 630,780 780,1050
-} you need to wait

441
00:14:43,380 --> 00:14:45,450
0,120 120,180 180,660 660,1410 1440,2070
for a particular condition,| that's
|这就是条件变量非常有用的地方。

442
00:14:45,660 --> 00:14:47,430
0,540 540,900 900,1290 1290,1530 1530,1770
where condition variables become very

443
00:14:47,430 --> 00:14:48,600
0,570
helpful.|
|

444
00:14:48,840 --> 00:14:50,670
0,570 570,840 840,1320 1320,1620 1620,1830
Does that help a little
这会有一点帮助吗？

445
00:14:50,670 --> 00:14:51,720
0,330
bit?|
|

446
00:14:51,970 --> 00:14:53,620
0,510 510,810 810,1110
Yeah, thank you.|
是的，谢谢。|

447
00:14:56,000 --> 00:14:58,340
0,240 240,360 360,1110 1170,1740 1980,2340
You can also,| {} like
你也可以，|比如所有这些更高级的，

448
00:14:58,340 --> 00:15:00,590
0,240 240,390 390,1230 1590,2010 2010,2250
all of these higher level,|
|

449
00:15:00,590 --> 00:15:03,110
0,210 210,690 690,1110 1110,1710 2220,2520
like channels, condition variables, {}|
比如通道、条件变量，|

450
00:15:03,110 --> 00:15:04,550
0,150 150,330 330,510 510,750 750,1440
all these higher level synchronization
所有这些更高级的同步原语，

451
00:15:04,550 --> 00:15:06,740
0,420 420,1050 1050,1470 1470,1950 1950,2190
primitives actually,| they're built on
|它们都是构建在锁上的，

452
00:15:06,740 --> 00:15:08,360
0,270 270,390 390,990 1110,1500 1500,1620
top of locks,| so they're
|所以它们都是使用锁实现的，

453
00:15:08,360 --> 00:15:10,250
0,210 210,900 900,1170 1170,1680 1680,1890
all implemented using locks,| is
|是一种，

454
00:15:10,250 --> 00:15:11,920
0,300 300,600 600,1170
just there, {}|
|

455
00:15:12,430 --> 00:15:13,630
0,240 240,330 330,510 510,870 870,1200
kind of a higher level
一种更高层次的思考同步的方式，

456
00:15:13,630 --> 00:15:15,400
0,240 240,390 390,870 870,1110 1110,1770
way of thinking about synchronization,|
|

457
00:15:15,400 --> 00:15:16,510
0,120 120,390 390,480 480,630 630,1110
that allows you to [reason]
这让你可以推断条件。

458
00:15:16,510 --> 00:15:19,420
0,120 120,540 540,810 810,1620
for example about conditions.|
|

459
00:15:22,050 --> 00:15:23,520
0,630 720,960 960,1140 1140,1380 1380,1470
{} Would that have the
这会有同样的效果吗，

460
00:15:23,520 --> 00:15:25,380
0,300 300,810 810,1260 1290,1470 1470,1860
same effect,| as for example
|比如在那个循环里，

461
00:15:25,380 --> 00:15:28,020
0,750 1080,1500 1500,1950 1980,2490 2490,2640
sleeping in that loop,| that
|你在 GetTask 函数中，

462
00:15:28,020 --> 00:15:30,330
0,150 150,570 600,870 870,1350 1800,2310
you have in the {}

463
00:15:30,360 --> 00:15:32,190
0,420 420,900 900,1350 1350,1710 1710,1830
{GetTask -} function| instead of
|不是使用条件变量，

464
00:15:32,190 --> 00:15:35,100
0,330 360,1290 1320,1740 1740,2160 2160,2910
like having a condition variable,|
|

465
00:15:35,850 --> 00:15:38,520
0,480 1080,1560 1560,1890 1920,2430 2430,2670
that makes the loop run
它使循环每秒运行一次，

466
00:15:38,520 --> 00:15:39,980
0,240 240,900
every second,|
|

467
00:15:40,250 --> 00:15:42,440
0,450 450,990 1020,1650
{I,guess}.| Yeah, so,
我想。|是的，所以，它本质上和睡眠一样，

468
00:15:42,530 --> 00:15:44,270
0,480 660,840 840,1200 1230,1560 1560,1740
it it is, like it's

469
00:15:44,270 --> 00:15:45,860
0,450 450,540 540,840 840,990 990,1590
essentially the same as sleeping,|
|

470
00:15:45,890 --> 00:15:48,860
0,510 1320,2430
{} the,
这里的超时循环，

471
00:15:49,980 --> 00:15:52,710
0,540 570,1530 1620,2370 2370,2610 2610,2730
so the loop here, the

472
00:15:52,710 --> 00:15:55,300
0,450 450,690 690,1170 1350,2070
timeout loop here, {}|
|

473
00:15:55,780 --> 00:15:58,460
0,240 240,810 810,1440 1440,2160
the difference is that,|
不同的是，|

474
00:15:58,970 --> 00:16:01,700
0,240 240,1200 1350,1680 1680,2160 2160,2730
for example, the condition variable,|
例如，条件变量，|

475
00:16:01,700 --> 00:16:02,810
0,180 180,330 330,450 450,630 630,1110
or you could be woken
你可能被一项已经完成的任务唤醒，

476
00:16:02,810 --> 00:16:04,580
0,420 600,1140 1140,1290 1290,1650 1650,1770
up by a task that

477
00:16:04,580 --> 00:16:06,140
0,240 240,1020
has completed,|
|

478
00:16:06,140 --> 00:16:07,700
0,480 480,840 840,1170 1170,1470 1470,1560
where in a loop, in
在循环中，例如睡眠每秒循环一次，

479
00:16:07,700 --> 00:16:09,170
0,210 210,390 390,870 870,1050 1050,1470
which you sleep for example

480
00:16:09,170 --> 00:16:10,880
0,180 180,570 570,840 840,1110 1110,1710
a second every single loop,|
|

481
00:16:11,210 --> 00:16:12,620
0,390 390,840 840,1050 1050,1320 1320,1410
you have to wait a
你必须等待一秒，

482
00:16:12,620 --> 00:16:13,740
0,600
second,|
|

483
00:16:13,830 --> 00:16:15,750
0,750 780,990 990,1050 1050,1440 1440,1920
whereas with a condition variable,|
而对于条件变量，|

484
00:16:15,750 --> 00:16:16,770
0,150 150,330 330,480 480,840 840,1020
you could be woken up
你可会在大约 10 毫秒后被唤醒，

485
00:16:16,770 --> 00:16:18,380
0,480 480,570 570,720 720,1050
after you know like

486
00:16:18,380 --> 00:16:20,060
0,210 210,870 870,1260 1260,1350 1350,1680
ten milliseconds,| because the worker
|因为 worker 已经完成了一项任务，

487
00:16:20,060 --> 00:16:22,220
0,150 150,630 630,750 750,1320 1590,2160
has completed a task,| so
|所以，它可能具有更好的灵活性。

488
00:16:22,250 --> 00:16:23,300
0,480
it

489
00:16:23,300 --> 00:16:25,760
0,630 630,900 900,1230 1230,1650 1650,2460
potentially has better liveness properties.|
|

490
00:16:27,800 --> 00:16:29,150
0,300 330,600 600,780 780,1170 1170,1350
{} By this case, we
在这种情况下，我们使用，

491
00:16:29,150 --> 00:16:30,680
0,420 420,750 750,1050 1050,1200 1200,1530
do like say,| if every
|如果每项任务总是占用 5 秒左右的时间，

492
00:16:30,680 --> 00:16:33,230
0,390 390,870 870,1500 1890,2220 2220,2550
task always takes over like

493
00:16:33,820 --> 00:16:36,160
0,300 300,750 750,870 870,1410 1470,2340
five seconds or something,| then
|那么，是的，这本质上非常类似于每个循环睡眠一秒。

494
00:16:36,400 --> 00:16:39,070
0,480 480,870 870,1320 1530,2280 2310,2670
yes, this is essentially very

495
00:16:39,070 --> 00:16:40,990
0,420 420,540 540,1050 1080,1620 1680,1920
similar to sleeping for one

496
00:16:40,990 --> 00:16:42,360
0,300 300,510 510,840
second every loop.|
|

497
00:16:43,680 --> 00:16:46,050
0,420 1140,1770 1770,1860 1860,2250 2250,2370
I have a question,| I
我有个问题，|我想我错过了你运行的部分，

498
00:16:46,050 --> 00:16:47,010
0,210 210,300 300,540 540,630 630,960
think I missed the part

499
00:16:47,010 --> 00:16:48,400
0,210 210,360 360,870
where you run,|
|

500
00:16:48,580 --> 00:16:50,830
0,570 570,720 720,1290 1290,1740 1950,2250
how you handle, {} when
当任务请求到来时，你如何处理，

501
00:16:50,830 --> 00:16:52,420
0,630 630,1110 1110,1410 1410,1530 1530,1590
a request comes for a

502
00:16:52,420 --> 00:16:54,400
0,540 540,1350 1380,1590 1590,1770 1770,1980
task,| but you're like there's
|但你目前没有任务要分配，

503
00:16:54,400 --> 00:16:55,450
0,90 90,600 600,690 690,840 840,1050
no tasks to give out

504
00:16:55,450 --> 00:16:57,130
0,420 420,630 630,1200 1500,1620 1620,1680
currently,| like you, how do
|你怎么告诉 worker 要么回来

505
00:16:57,130 --> 00:16:58,390
0,60 60,240 240,330 330,630 630,1260
you tell the worker to

506
00:16:58,660 --> 00:16:59,770
0,240 240,450 450,660 660,900 900,1110
like sort of either come

507
00:16:59,770 --> 00:17:01,120
0,300 300,390 390,450 450,810 1140,1350
back| or do you keep
|还是让它们等待，

508
00:17:01,120 --> 00:17:03,010
0,150 150,600 630,1080 1410,1650 1650,1890
them waiting| and sort of
|一带而过地，

509
00:17:03,250 --> 00:17:05,440
0,600 600,690 690,1110 1140,1710
[tangentially] to that, {}|
|

510
00:17:05,860 --> 00:17:07,300
0,210 210,570 570,840 840,1020 1020,1440
I'm curious why you chose
我很好奇，你为什么选择这种睡眠的方式，

511
00:17:07,300 --> 00:17:09,640
0,240 240,480 480,1290 1350,2280 2280,2340
this like sleep way of

512
00:17:09,640 --> 00:17:10,930
0,270 270,390 390,720 720,810 810,1290
doing it,| instead of just
|而不是收到任务请求时查看时间，

513
00:17:11,490 --> 00:17:12,660
0,210 210,570 570,660 660,1020 1020,1170
like checking the time when

514
00:17:12,660 --> 00:17:13,720
0,150 150,570
you get

515
00:17:13,720 --> 00:17:15,040
0,210 210,600 600,690 690,1200 1200,1320
{} request for tasks,| and
|比如当你收到请求时，

516
00:17:15,040 --> 00:17:16,140
0,480
seeing,

517
00:17:16,260 --> 00:17:17,010
0,210 210,390 390,510 510,660 660,750
like when you get a

518
00:17:17,010 --> 00:17:18,570
0,510 510,720 720,900 900,1260 1260,1560
request,| what has timed out
|已经超时，并重新发布它，

519
00:17:18,570 --> 00:17:20,080
0,150 150,630 630,900
and reissuing it,|
|

520
00:17:20,320 --> 00:17:22,990
0,480 480,870 870,1320 1470,2160 2190,2670
then instead of like constanly
而不是不间断的检查。

521
00:17:22,990 --> 00:17:24,100
0,510
checking.|
|

522
00:17:24,160 --> 00:17:26,640
0,1320 1320,1350 1350,1890
Yeah, okay, so,|
是的，好的，所以，|

523
00:17:26,790 --> 00:17:28,500
0,480 480,810 810,1260 1260,1500 1500,1710
yeah, so I'll just your
是的，所以我先问你的第一个问题，

524
00:17:28,500 --> 00:17:31,740
0,570 570,960 960,1440 1830,2460 2640,3240
first question first,| {} so
|所以我是如何处理已经完成的任务的，

525
00:17:31,740 --> 00:17:34,680
0,1020 1500,1800 1800,1950 1950,2400 2400,2940
basically how I handle the

526
00:17:34,740 --> 00:17:37,650
0,330 330,780 780,870 870,1410 2280,2910
{} completed the task,| is
|是一旦所有的 Map 任务完成，

527
00:17:39,290 --> 00:17:41,600
0,780 960,1560 1560,1740 1740,2010 2010,2310
{} once all Map tasks

528
00:17:41,600 --> 00:17:43,010
0,150 150,660 660,900 900,1050 1050,1410
have finished,| once all Reduce
|一旦所有 Reduce 任务都已完成，

529
00:17:43,010 --> 00:17:45,740
0,360 390,840 840,1140 1140,1740 1800,2730
{} tasks have finished,| then
|然后我们返回给 worker 的任务，

530
00:17:45,800 --> 00:17:47,810
0,180 180,630 630,810 810,1290 1350,2010
the task that we return

531
00:17:47,810 --> 00:17:49,250
0,120 120,240 240,870 1020,1350 1350,1440
to the worker,| because the
|因为 worker 调用的任务，

532
00:17:49,250 --> 00:17:50,810
0,270 270,450 450,750 750,1080 1080,1560
worker has called us {}

533
00:17:50,870 --> 00:17:54,050
0,690 690,1290 1320,1560 1560,2070 2640,3180
{task,for} task| is this extra
|是这个额外的我称为 Done 的任务类型，

534
00:17:54,050 --> 00:17:55,250
0,420 420,720 720,840 840,930 930,1200
task type, that I called

535
00:17:55,250 --> 00:17:56,120
0,420
Done,|
|

536
00:17:56,680 --> 00:17:58,960
0,720 900,1500 1500,1680 1680,1920 1920,2280
and then I also set
然后我设置 coordinator 的 isDone 为 true ，

537
00:17:59,110 --> 00:18:00,910
0,360 630,810 810,1410 1410,1620 1620,1800
that the coordinator {isDone -}

538
00:18:00,910 --> 00:18:03,010
0,120 120,600 1320,1590 1590,1830 1830,2100
to true,| and so in
|所以在 worker 中，

539
00:18:03,010 --> 00:18:04,000
0,120 120,720 720,840 840,930 930,990
the workers,| I'll go to
|我现在去 worker 中，

540
00:18:04,000 --> 00:18:06,490
0,90 90,390 1530,1680 1680,1770 1770,2490
the worker,| and the worker
|worker 中我们有这个循环，

541
00:18:06,550 --> 00:18:10,480
0,240 240,1200 1890,2820 2820,3390 3390,3930
we have this loop,| that
|当 worker 要求任务时，

542
00:18:10,750 --> 00:18:11,890
0,510 510,630 630,750 750,1050 1050,1140
basically as the worker is

543
00:18:11,890 --> 00:18:14,410
0,480 480,960 990,1650 2040,2250 2250,2520
asking for tasks,| if it
|如果返回的任务是 Done 任务，它就退出。

544
00:18:14,560 --> 00:18:16,750
0,780 780,1260 1260,1830 1830,2100 2100,2190
that returned tasks is a

545
00:18:16,750 --> 00:18:18,250
0,210 210,630 630,780 780,930 930,1500
Done task, then it exits.|
|

546
00:18:18,680 --> 00:18:20,270
0,600 780,1110 1110,1320 1320,1470 1470,1590
{} So that's how I
所以这就是我向 worker 传达信息的方式，

547
00:18:20,270 --> 00:18:21,950
0,630 630,1110 1110,1230 1230,1350 1350,1680
handle conveying to the worker,|
|

548
00:18:21,950 --> 00:18:24,050
0,270 360,720 720,990 990,1590 1620,2100
that it should exit.| I
它应该退出。|我想我是在问，

549
00:18:24,050 --> 00:18:25,280
0,210 210,270 270,390 390,780 780,1230
guess I was asking like,|
|

550
00:18:25,310 --> 00:18:27,320
0,390 390,810 990,1680 1680,1800 1800,2010
sorry, if you know let's
抱歉，比如你还在完成 Map 任务，

551
00:18:27,320 --> 00:18:29,000
0,540 540,690 690,1170 1170,1560 1560,1680
say you're still finishing up

552
00:18:29,000 --> 00:18:30,560
0,120 120,240 240,480 480,1110
on your Map tasks,|
|

553
00:18:30,560 --> 00:18:32,150
0,390 390,540 540,780 780,1380 1380,1590
and you get requests for
你收到任务的请求，

554
00:18:32,150 --> 00:18:33,650
0,60 60,630 1020,1170 1170,1290 1290,1500
a task,| and you still
|你仍然不能给出你的 Reduce 任务，

555
00:18:33,650 --> 00:18:34,670
0,210 210,360 360,480 480,600 600,1020
can't give out your Reduce

556
00:18:34,670 --> 00:18:36,560
0,540 960,1350 1380,1530 1530,1680 1680,1890
tasks,| how do you tell
|你怎么告诉 worker 呢？

557
00:18:36,560 --> 00:18:37,680
0,90 90,600
the worker?|
|

558
00:18:38,060 --> 00:18:41,020
0,360 360,840
Oh, so,
哦，所以，你们中的很多人都是，

559
00:18:41,170 --> 00:18:42,850
0,180 180,450 450,600 600,1080 1080,1680
a lot of you are,|
|

560
00:18:43,000 --> 00:18:45,070
0,300 300,570 570,1140 1140,1680 1680,2070
{} an alternative design is
另一种设计是，

561
00:18:45,070 --> 00:18:47,290
0,690 780,1410 1410,1590 1590,1740 1740,2220
to,| basically if the worker,
|如果没有任务给 worker ，

562
00:18:47,290 --> 00:18:48,280
0,150 150,360 360,510 510,900 900,990
if there's no task to

563
00:18:48,280 --> 00:18:50,980
0,150 150,270 270,840 1290,1890 2280,2700
give the worker,| then the
|然后 coordinator 立即向 worker 返回回复，

564
00:18:50,980 --> 00:18:52,810
0,690 690,1200 1200,1230 1230,1710 1710,1830
coordinator returns a reply to

565
00:18:52,810 --> 00:18:54,700
0,120 120,420 420,1320 1560,1770 1770,1890
the worker immediately,| and the
|而 worker 在它的循环中睡眠，

566
00:18:54,700 --> 00:18:56,470
0,330 330,990 990,1140 1140,1380 1380,1770
worker sleeps in its loop,|
|

567
00:18:56,770 --> 00:18:58,600
0,780 840,1050 1050,1290 1290,1530 1530,1830
but you can see here,
但你可以在这里看到，

568
00:18:58,600 --> 00:19:00,010
0,390 390,540 540,840 840,1200 1200,1410
right,| the worker loop, there
|worker 循环，没有睡眠，

569
00:19:00,010 --> 00:19:01,220
0,120 120,300 300,810
is no sleep,|
|

570
00:19:01,820 --> 00:19:02,960
0,180 180,270 270,630 630,840 840,1140
and the reason for this
其中的原因是，

571
00:19:02,960 --> 00:19:05,510
0,300 300,960 1170,1620 1620,2250 2250,2550
is,| because this call will
|因为这个调用会阻塞直到 coordinator 回复，

572
00:19:05,510 --> 00:19:08,150
0,660 690,1080 1080,1200 1200,1800 1800,2640
block until the coordinator replies,|
|

573
00:19:09,130 --> 00:19:11,460
0,270 270,360 360,540 540,1290
and in my solution,|
在我的解决方案中，|

574
00:19:11,490 --> 00:19:13,200
0,480 480,660 660,720 720,810 810,1710
going back to the coordinator,|
回到 coordinator ，|

575
00:19:13,560 --> 00:19:14,850
0,330 330,780 780,990 990,1170 1170,1290
for example like if you
例如，如果你查看 mapDone ，

576
00:19:14,850 --> 00:19:16,760
0,180 180,330 330,570 570,1050
look at {mapDone -},|
|

577
00:19:17,180 --> 00:19:19,340
0,270 270,540 540,1380 1380,1530 1530,2160
in this solution, the coordinator
在这个解决方案中， coordinator 处理程序不会向那个调用返回回复，

578
00:19:19,340 --> 00:19:20,660
0,780
handler

579
00:19:20,780 --> 00:19:24,110
0,270 270,810 810,1650 2100,2550 2580,3330
will not return that reply

580
00:19:24,110 --> 00:19:26,450
0,150 150,330 330,930 1140,2130 2160,2340
to that call,| unless it
|除非它有任务要返回，

581
00:19:26,450 --> 00:19:28,430
0,450 450,570 570,1020 1020,1290 1290,1980
has a task to return,|
|

582
00:19:28,820 --> 00:19:30,770
0,570 570,1020 1110,1380 1380,1800 1800,1950
so it's, we're waiting in
所以，我们是在 coordinator 那里等待，而不是在 worker 那里。

583
00:19:30,770 --> 00:19:33,020
0,90 90,1140 1290,1800 1800,2040 2040,2250
the coordinator rather than in

584
00:19:33,020 --> 00:19:34,200
0,120 120,690
the worker.|
|

585
00:19:34,660 --> 00:19:36,430
0,420 420,690 690,810 810,1530 1530,1770
{} So the coordinator is
所以 coordinator 就是那个，

586
00:19:36,430 --> 00:19:38,950
0,120 120,750 930,1440 1590,1890 1890,2520
the one,| that is constantly
|不断地检查是否有任务和睡眠，

587
00:19:38,950 --> 00:19:40,390
0,420 420,540 540,690 690,1140 1140,1440
checking to see whether there's

588
00:19:40,390 --> 00:19:43,360
0,60 60,810 900,1200 1200,1890 2010,2970
a task and sleeping,| whereas
|而 worker 只是简单地阻塞在这个调用上，

589
00:19:43,360 --> 00:19:45,550
0,120 120,540 540,960 990,1470 1470,2190
the worker just simply blocks

590
00:19:45,550 --> 00:19:47,220
0,360 360,570 570,1170
on this call,|
|

591
00:19:47,220 --> 00:19:48,900
0,450 450,540 540,1170 1170,1560 1560,1680
until the coordinator returns to
直到 coordinator 返回给它。

592
00:19:48,900 --> 00:19:49,660
0,180
it.|
|

593
00:19:49,690 --> 00:19:51,820
0,330 510,840 840,1020 1020,1980 2010,2130
Is there any advantage to
在 coordinator 中这样做，有什么好处吗？

594
00:19:51,820 --> 00:19:54,700
0,360 360,720 720,1350 1350,1680 1680,2880
doing it in the coordinator?|
|

595
00:19:55,870 --> 00:19:58,160
0,750

596
00:19:59,550 --> 00:20:01,830
0,420 420,570 570,1020 1380,1680 1680,2280
So I think one advantage
所以我认为一个优势是，

597
00:20:01,830 --> 00:20:03,260
0,300 300,840
is that,|
|

598
00:20:04,940 --> 00:20:07,400
0,330 330,480 480,960 960,1320 1320,2460
all the workers aren't constantly
并不是所有的 worker 都不断地发送 RPC ，

599
00:20:08,130 --> 00:20:10,020
0,420 420,540 540,1200 1470,1650 1650,1890
sending {RPCs -},| you send
|你发送一个 RPC ，

600
00:20:10,020 --> 00:20:11,250
0,90 90,570 570,780 780,1050 1050,1230
an RPC,| it's one {RPC
|这是每个任务一个 RPC ，

601
00:20:11,250 --> 00:20:14,820
0,570 570,840 840,1440 1560,2040 2670,3570
-} per task, right,| whereas
|而如果 worker 不断地循环和睡眠，并且不断地回答，

602
00:20:14,820 --> 00:20:15,900
0,150 150,240 240,510 510,600 600,1080
if the worker is constantly

603
00:20:15,900 --> 00:20:17,910
0,330 330,450 450,1140 1290,1680 1680,2010
looping and sleeping and constantly

604
00:20:17,910 --> 00:20:18,810
0,270 270,420 420,540 540,600 600,900
reply,| you have a lot
|你会有更多的网络流量。

605
00:20:18,810 --> 00:20:20,360
0,150 150,510 510,1080
more network traffic.|
|

606
00:20:20,660 --> 00:20:23,390
0,600 960,1470 1530,1980 2010,2310 2310,2730
Okay.| Yeah, I think that's,
好的。|是的，我认为这是，但这两种解决方案都是可行的，

607
00:20:23,600 --> 00:20:25,880
0,390 390,870 870,1140 1140,1860 1860,2280
but definitely both solutions are

608
00:20:25,910 --> 00:20:27,710
0,600 600,900 900,1050 1050,1320 1320,1800
feasible,| and they both work.|
|它们都是可工作的。|

609
00:20:28,510 --> 00:20:29,580
0,750
Great.|
太棒了。|

610
00:20:29,580 --> 00:20:31,440
0,540 630,780 780,1320 1350,1590 1590,1860
{} I had {} one
我还有一个问题，

611
00:20:31,440 --> 00:20:32,820
0,210 210,690 690,930 930,1140 1140,1380
other question,| which is I
|我看到你经常对锁使用 defer ，

612
00:20:32,820 --> 00:20:34,200
0,330 360,510 510,810 810,1020 1020,1380
I I see you use

613
00:20:34,200 --> 00:20:38,100
0,510 720,1740 1770,2790 2850,3630 3660,3900
a defer for {the,locking} quite

614
00:20:38,100 --> 00:20:40,560
0,90 90,540 1830,2190 2190,2310 2310,2460
a bit,| while I was
|当我在做我的实现时，

615
00:20:40,560 --> 00:20:42,480
0,210 210,630 660,1320 1320,1500 1500,1920
doing my implementation,| I I
|我意识到，

616
00:20:42,480 --> 00:20:43,800
0,570 570,720 720,1080 1110,1230 1230,1320
realized,| I mean in a
|我的意思是，在一个简单的函数中，

617
00:20:43,800 --> 00:20:46,240
0,1020 1020,1650 1650,1980
straightforward function,| it,
|它很明显，

618
00:20:46,240 --> 00:20:47,920
0,180 180,900 930,1260 1260,1410 1410,1680
it's clear,| when it gives
|什么时候放弃对锁的控制，

619
00:20:47,920 --> 00:20:49,630
0,450 450,900 900,1020 1020,1140 1140,1710
up control of the lock,|
|

620
00:20:50,210 --> 00:20:52,130
0,510 540,1140 1140,1260 1260,1770 1770,1920
{} but for example if
但是如果你有一个从函数内部创建的 goroutine ，

621
00:20:52,130 --> 00:20:53,280
0,600
you,

622
00:20:53,760 --> 00:20:54,860
0,510
like

623
00:20:54,860 --> 00:20:57,530
0,300 300,840 870,1110 1110,1860 1890,2670
have a {goroutine -} created

624
00:20:57,560 --> 00:20:59,780
0,420 420,810 810,930 930,1650
from within the function,|
|

625
00:21:00,020 --> 00:21:02,480
0,1140 1140,1380 1380,1650 1650,2130 2130,2460
it's not very clear, when
就不是很清楚，何时放弃控制。

626
00:21:02,480 --> 00:21:04,140
0,90 90,300 300,450 450,1200
it gives up control.|
|

627
00:21:05,100 --> 00:21:06,870
0,330 330,510 510,780 780,1410 1440,1770
So, a {goroutine -} runs
所以，一个 goroutine 在单独的线程上运行，

628
00:21:06,870 --> 00:21:07,860
0,120 120,180 180,600 600,900 900,990
on a separate thread,| so
|goroutine 永远不会从获取的锁开始，

629
00:21:07,860 --> 00:21:10,200
0,150 150,570 570,1440 1650,2160 2160,2340
the goroutine never starts with

630
00:21:10,200 --> 00:21:11,670
0,120 120,420 420,1020 1020,1350 1350,1470
the lock acquired,| even if
|即使当你持有锁时，开始那个 goroutine 。

631
00:21:11,670 --> 00:21:12,960
0,150 150,450 450,630 630,810 810,1290
you spin off the goroutine,

632
00:21:12,960 --> 00:21:14,370
0,420 420,570 570,840 840,960 960,1410
while you hold the lock.|
|

633
00:21:14,640 --> 00:21:17,340
0,150 150,450 480,930 1230,1920 2280,2700
{Okay - -}.| Yeah.| If
好的。|嗯。|如果我们创建一个 goroutine ，

634
00:21:17,340 --> 00:21:19,020
0,270 270,420 420,930 960,1500 1500,1680
we, if we issue like

635
00:21:19,020 --> 00:21:20,160
0,240 240,570 570,720 720,810 810,1140
a Go, if we create

636
00:21:20,160 --> 00:21:21,810
0,90 90,270 270,870 930,1290 1290,1650
a {goroutine -},| it'll just
|它只会在一个线程中旋转，

637
00:21:21,810 --> 00:21:23,460
0,270 270,420 420,510 510,1080 1230,1650
spin up a thread,| and
|而且从一开始，它就不会有锁，对吗？

638
00:21:23,520 --> 00:21:25,080
0,240 240,330 330,870 870,1050 1050,1560
from the beginning, it won't

639
00:21:25,080 --> 00:21:27,360
0,180 180,270 270,780 840,1260 1260,2280
have a lock, right?| Yeah,
|是的，实际上就像，

640
00:21:27,360 --> 00:21:29,120
0,330 330,720 720,960 960,1320
it's actually just like,|
|

641
00:21:29,150 --> 00:21:30,080
0,150 150,240 240,480 480,630 630,930
you know you think about
你认为另一个线程

642
00:21:30,080 --> 00:21:31,310
0,300 300,540 540,720 720,1110 1110,1230
another thread| just starting to
|开始运行 Go 函数。

643
00:21:31,310 --> 00:21:32,900
0,240 240,540 540,990 1020,1350 1350,1590
run that Go, like Go

644
00:21:32,900 --> 00:21:37,700
0,480 480,720 720,1260 2820,4050
func, that function.| Yeah.|
|嗯。|

645
00:21:37,700 --> 00:21:40,970
0,540 780,1080 1080,1740 1770,2730 3000,3270
{Yeah\,,go,ahead}.| {And,then} defer unlocks at
好的，继续。|然后 defer 在任何 return 语句解锁？

646
00:21:40,970 --> 00:21:43,190
0,420 420,1260 1290,1590 1590,1860 1860,2220
any return, like any return

647
00:21:43,190 --> 00:21:44,640
0,510 510,900
statement there?|
|

648
00:21:44,730 --> 00:21:46,500
0,390 420,720 720,960 960,1230 1230,1770
Yep, yeah, it's pushed onto
是的，它推到一个，

649
00:21:46,500 --> 00:21:49,320
0,840 990,1530 2010,2490 2490,2700 2700,2820
a,| like basically like the
|比如函数运行，

650
00:21:49,320 --> 00:21:51,840
0,450 450,570 570,840 840,1410 1650,2520
functions to run when the,|
|

651
00:21:52,380 --> 00:21:53,730
0,210 210,300 300,690 690,840 840,1350
there's a stack of functions,|
有一个函数的堆栈，|

652
00:21:53,730 --> 00:21:55,140
0,240 240,840
that the
比如 HandleGetTask 运行返回，

653
00:21:55,520 --> 00:21:57,680
0,570 570,1140 1140,1530 1560,1950 1950,2160
returning from like {HandleGetTask -

654
00:21:57,680 --> 00:22:00,470
0,390 390,570 570,930 1380,2100 2460,2790
-} will run,| so, {}
|所以，我在幻灯片中也有这个，

655
00:22:00,470 --> 00:22:01,490
0,390 390,630 630,810 810,960 960,1020
I also have this in

656
00:22:01,490 --> 00:22:02,330
0,90 90,450 450,540 540,750 750,840
the slides,| so you'll be
|所以你稍后可以看的这个，

657
00:22:02,330 --> 00:22:03,080
0,120 120,180 180,450 450,540 540,750
able to refer to this

658
00:22:03,080 --> 00:22:05,900
0,450 750,1230 1560,2010 2010,2220 2220,2820
later,| but defer just ensures
|但 defer 只是确保当这个函数退出时，

659
00:22:05,900 --> 00:22:07,400
0,180 180,390 390,540 540,900 900,1500
that when this function exits,|
|

660
00:22:07,760 --> 00:22:09,170
0,210 210,660 810,1020 1020,1320 1320,1410
you over you around {unlock
你使用解锁，

661
00:22:09,170 --> 00:22:10,520
0,510 540,750 750,990 990,1170 1170,1350
-},| and then I could
|我还可以做一些事情，比如 unlocking ，

662
00:22:10,520 --> 00:22:16,280
0,390 390,600 600,1020 1020,4860 4890,5760
also do something, like unlocking,|
|

663
00:22:17,240 --> 00:22:19,070
0,630 960,1200 1200,1320 1320,1560 1560,1830
and like I could just
我也可以做一些事情，比如 before the last println ，

664
00:22:19,070 --> 00:22:22,100
0,90 90,360 360,1290 1320,2010 2040,3030
do something, like {} before

665
00:22:22,680 --> 00:22:24,510
0,180 180,540 540,1080 1200,1470 1470,1830
the last printf or println,|
|

666
00:22:25,110 --> 00:22:27,180
0,690 870,1320 1320,1590 1590,1830 1830,2070
so these are all pushed
所以这些都被压到一个堆栈上，

667
00:22:27,180 --> 00:22:28,500
0,210 210,270 270,930 960,1110 1110,1320
onto a stack,| and then
|然后它们按先进先出的顺序弹出，不，是后进先出的顺序。

668
00:22:28,500 --> 00:22:30,750
0,240 240,630 630,870 870,1350 1530,2250
they're popped off in FIFO

669
00:22:30,750 --> 00:22:33,140
0,540 600,990 1380,1890
order, no, {LIFO,order}.|
|

670
00:22:33,470 --> 00:22:35,900
0,660 840,1950
{} {What,FIFO}?|
什么 FIFO ？|

671
00:22:36,490 --> 00:22:38,530
0,390 390,660 660,1080 1080,1470 1770,2040
First in first out, no
先入先出，不，它们是后进先出，是的，

672
00:22:38,530 --> 00:22:39,800
0,660
they're

673
00:22:39,800 --> 00:22:44,990
0,540 540,1560 1980,2880 3660,4440 4920,5190
run in {last,in,first,out}, yeah,| so
|所以这是一个堆栈，

674
00:22:44,990 --> 00:22:47,860
0,480 480,810 810,1320 1620,2250
{it's,a,stack} right,| so {}
|所以这将在解锁之前运行，

675
00:22:48,010 --> 00:22:50,440
0,420 420,600 600,900 900,1260 1260,2430
this will run before unlocking,|
|

676
00:22:50,440 --> 00:22:51,970
0,300 300,630 660,1050 1050,1230 1230,1530
which will actually run before
在锁之前运行，

677
00:22:51,970 --> 00:22:53,950
0,390 630,1260 1290,1650 1650,1830 1830,1980
the lock,| so if you're
|如果你准备使用多个 defer ，

678
00:22:53,950 --> 00:22:55,360
0,150 150,240 240,420 420,840 840,1410
ready to use multiple defers,|
|

679
00:22:55,360 --> 00:22:56,440
0,120 120,450 450,540 540,600 600,1080
be careful in the order,
注意顺序，然后使用它们，

680
00:22:56,500 --> 00:22:58,750
0,270 270,480 480,840 1050,1770 1770,2250
then use them,| but defer
|但 defer unlock 是一个非常有用的策略，

681
00:22:58,750 --> 00:23:00,100
0,150 150,720 720,840 840,1140 1140,1350
the unlock at least is

682
00:23:00,100 --> 00:23:03,140
0,90 90,390 390,840 870,1620
a very useful strategy,|
|

683
00:23:03,260 --> 00:23:04,280
0,210 210,330 330,480 480,570 570,1020
that will come in handy.|
这会派上用场的。|

684
00:23:05,040 --> 00:23:07,380
0,390 420,1050 1140,1470 2100,2280 2280,2340
Okay, { -} so the
好的，那么最后一件事是，

685
00:23:07,380 --> 00:23:09,300
0,330 330,480 480,870 900,1560 1650,1920
last thing is,| {} if
|如果我们在函数内调用函数，

686
00:23:09,300 --> 00:23:11,550
0,420 420,780 780,1050 1050,1590 1590,2250
we call a function within

687
00:23:11,850 --> 00:23:12,980
0,600
{}

688
00:23:14,330 --> 00:23:16,970
0,600 600,1260 1290,1800 1800,2400 2430,2640
within our our function,| where
|在那里我们获得了锁，

689
00:23:16,970 --> 00:23:18,680
0,210 210,570 570,720 720,1230 1350,1710
we acquire the lock,| it
|它不会返回锁，对吧，

690
00:23:18,680 --> 00:23:20,720
0,510 510,900 900,990 990,1500 1530,2040
doesn't return the lock, right,|
|

691
00:23:21,170 --> 00:23:22,400
0,360 360,660 660,840 840,1110 1110,1230
{} when it goes to
当它转到另一个函数时，

692
00:23:22,400 --> 00:23:24,110
0,90 90,330 330,960 1380,1530 1530,1710
the other function,| the other
|另一函数返回到这个函数，

693
00:23:24,110 --> 00:23:25,820
0,330 330,720 720,840 840,1050 1050,1710
function returns to this function,|
|

694
00:23:26,600 --> 00:23:28,160
0,180 180,330 330,660 660,1050 1170,1560
and then until we, like
然后，比如线程保持者锁，通过跳来跳去。

695
00:23:28,160 --> 00:23:29,510
0,150 150,450 450,750 750,840 840,1350
the thread keeps a lock,

696
00:23:29,960 --> 00:23:32,690
0,660 780,1200 1200,1500 1500,1920 1920,2730
like through like jumping around.|
|

697
00:23:34,880 --> 00:23:36,380
0,420 420,660 660,1050 1050,1140 1140,1500
Yeah, so like a function,|
是的，一个函数，|

698
00:23:36,380 --> 00:23:37,460
0,210 210,540 540,690 690,750 750,1080
that's just like a normal
就像一个线程中的普通函数调用，

699
00:23:37,460 --> 00:23:39,260
0,360 360,660 660,930 930,1170 1170,1800
function call within one thread,|
|

700
00:23:39,350 --> 00:23:40,970
0,630 690,900 900,1350 1350,1500 1500,1620
will be called with the
将在锁的情况下被调用，是的。

701
00:23:40,970 --> 00:23:42,540
0,150 150,540 630,1080
{lock,out -}, yes.|
|

702
00:23:43,570 --> 00:23:45,240
0,390 390,900
Cool, thanks.|
好的，谢谢。|

703
00:23:46,360 --> 00:23:47,320
0,390
Yep.|
好的。|

704
00:23:48,540 --> 00:23:49,740
0,420 420,630 630,810 810,1050 1050,1200
Alright, so you guys have
好的，你们已经讨论了

705
00:23:49,740 --> 00:23:51,060
0,510 510,720 720,810 810,1200 1200,1320
already kind of discussed| some
|一些备用的同步设计，

706
00:23:51,060 --> 00:23:53,130
0,120 120,180 180,660 750,1410 1410,2070
of the alternate synchronization designs,|
|

707
00:23:53,520 --> 00:23:54,870
0,330 360,810 810,900 900,990 990,1350
like waiting in the worker
比如在 worker 而不是在 coordinator 等待，

708
00:23:54,870 --> 00:23:56,520
0,300 300,450 450,540 540,1500 1500,1650
rather than the coordinator,| and
|我们讨论了这样做的一些利弊，

709
00:23:56,520 --> 00:23:57,270
0,150 150,390 390,570 570,690 690,750
we've talked about some of

710
00:23:57,270 --> 00:23:58,050
0,90 90,360 360,480 480,720 720,780
the pros and cons of

711
00:23:58,050 --> 00:23:58,900
0,360
that,|
|

712
00:23:58,900 --> 00:24:00,490
0,330 330,540 540,1140 1170,1500 1500,1590
{} using time,| actually I
使用 time ，|事实上，我认为已经涵盖了所有这些，可能除了通道，

713
00:24:00,490 --> 00:24:01,180
0,120 120,210 210,510 510,630 630,690
think already covered all of

714
00:24:01,180 --> 00:24:02,800
0,240 240,630 630,750 750,1140 1140,1620
these except for channels maybe,|
|

715
00:24:03,130 --> 00:24:04,520
0,600

716
00:24:04,640 --> 00:24:06,380
0,510 510,1020 1230,1500 1500,1620 1620,1740
so there's one thing I
所以有一件事我想知道，

717
00:24:06,380 --> 00:24:07,340
0,270 270,360 360,570 570,810 810,960
wanted to know,| because there
|因为对此有几个问题，

718
00:24:07,340 --> 00:24:08,450
0,90 90,180 180,450 450,870 870,1110
are a couple questions about

719
00:24:08,450 --> 00:24:10,850
0,360 570,930 930,1290 1290,1890 1980,2400
this,| so waiting for map
|所以等待 map 完成，

720
00:24:10,850 --> 00:24:11,750
0,270 270,330 330,420 420,780 780,900
has to be done| or
|或者我们展示的任何同步

721
00:24:11,750 --> 00:24:14,420
0,270 270,570 570,1740 1950,2370 2400,2670
like any synchronization that we've

722
00:24:14,420 --> 00:24:16,400
0,630 930,1170 1170,1410 1410,1470 1470,1980
shown| is on a single
|都在一台服务器上，

723
00:24:16,400 --> 00:24:19,070
0,750 810,1260 1260,1620 1620,1890 1890,2670
server,| so {cross-server -} communication
|所以 worker 和 coordinator 之间的跨服务器通信，

724
00:24:19,070 --> 00:24:20,720
0,480 480,600 600,1140 1140,1440 1440,1650
between the worker and the

725
00:24:20,720 --> 00:24:22,100
0,750
coordinator,|
|

726
00:24:22,250 --> 00:24:23,660
0,270 270,510 510,990 990,1200 1200,1410
{} they're only, it's only
它们只是通过 RPC ，

727
00:24:23,660 --> 00:24:25,340
0,270 270,570 570,750 750,960 960,1680
done ever by {RPCs -},|
|

728
00:24:25,520 --> 00:24:27,080
0,420 420,540 540,930 930,1170 1170,1560
so for example like locking
例如，在 coordinator 的锁，

729
00:24:27,080 --> 00:24:28,430
0,120 120,210 210,840 840,1050 1050,1350
in the coordinator| has nothing
|与 worker 的锁无关，

730
00:24:28,430 --> 00:24:29,300
0,90 90,210 210,390 390,750 750,870
to do with locking on

731
00:24:29,300 --> 00:24:31,550
0,90 90,630 810,1350 1410,1650 1650,2250
the worker,| or on interactive
|或者在不同服务器上的交互实现锁上，

732
00:24:31,550 --> 00:24:33,560
0,570 570,990 990,1110 1110,1410 1410,2010
implementation locking on different servers,|
|

733
00:24:33,980 --> 00:24:35,750
0,390 420,1020 1020,1440 1440,1620 1620,1770
like don't interfere with each
不会互相干扰，

734
00:24:35,750 --> 00:24:36,600
0,420
other,|
|

735
00:24:37,110 --> 00:24:37,740
0,120 120,300 300,420 420,510 510,630
I just want to be
我只想澄清这一点。

736
00:24:37,740 --> 00:24:40,050
0,240 240,750 1530,1950 1950,2130 2130,2310
clear {about,that}.| {} So one
|所以我觉得有一件事会很有趣的是，

737
00:24:40,050 --> 00:24:41,580
0,450 450,1050 1050,1260 1260,1410 1410,1530
thing I thought would be

738
00:24:41,580 --> 00:24:42,870
0,660 660,930 930,1050 1050,1200 1200,1290
interesting is,| for you to
|为了让你看到一种使用通道的例子，

739
00:24:42,870 --> 00:24:45,180
0,420 420,1050 1080,1410 1410,1800
see a kind of

740
00:24:45,530 --> 00:24:47,390
0,360 360,810 810,1050 1050,1620 1620,1860
an example using channels,| because
|因为这里也有一些问题关于使用通道。

741
00:24:47,390 --> 00:24:48,620
0,90 90,180 180,390 390,750 750,1230
there are also some questions

742
00:24:48,620 --> 00:24:50,780
0,270 270,900 930,1260 1260,1500 1500,2160
using channels, about using channels.|
|

743
00:24:51,680 --> 00:24:54,200
0,840 1530,1800 1800,2010 2010,2340 2340,2520
So this is kind of,|
所以这是一种，|

744
00:24:54,200 --> 00:24:58,700
0,960 1410,1980 2190,3060 3270,4110 4110,4500
{is,a} not complete implementation of
不是一种完全使用通道的实现，

745
00:24:58,730 --> 00:25:00,800
0,300 300,870 1080,1620 1620,1830 1830,2070
using channels,| {} but it's
|但这是一种潜在的方式，

746
00:25:00,800 --> 00:25:03,160
0,180 180,930 930,1320 1320,1890
a potential way to,|
|

747
00:25:03,160 --> 00:25:04,120
0,180 180,300 300,510 510,690 690,960
but you could think about
你可以考虑在 MapReduce 中使用通道。

748
00:25:04,120 --> 00:25:05,770
0,330 330,600 600,1050 1050,1380 1380,1650
having used channels in {MapReduce

749
00:25:05,770 --> 00:25:06,820
0,540
-}.|
|

750
00:25:06,910 --> 00:25:09,160
0,330 330,900 930,1140 1140,1350 1350,2250
And so in this example,|
所以在这个例子中，|

751
00:25:09,340 --> 00:25:10,960
0,360 360,840 840,900 900,1020 1020,1620
the input to the coordinator
到 coordinator 的输入包含一个通道，

752
00:25:10,960 --> 00:25:13,440
0,480 480,1170 1170,1320 1320,1950
actually includes a channel,|
|

753
00:25:13,530 --> 00:25:15,780
0,180 180,840 1050,1440 1440,2100 2100,2250
in which the coordinator is
其中 coordinator 被告知哪些 worker 存在，

754
00:25:15,780 --> 00:25:18,840
0,540 540,990 1020,1440 1440,2130 2130,3060
told of what workers exist,|
|

755
00:25:19,140 --> 00:25:21,480
0,630 630,840 840,1230 1260,1530 1530,2340
and this is to handle
这是为了应对 worker 失败的可能性，

756
00:25:22,030 --> 00:25:24,820
0,1020 1260,2130 2130,2340 2340,2670 2670,2790
the possibility that workers are

757
00:25:24,820 --> 00:25:26,920
0,660 690,1020 1020,1230 1230,1470 1470,2100
failing,| and then some client
|然后某个客户端告诉 coordinator ，

758
00:25:26,920 --> 00:25:28,960
0,600 630,1080 1080,1140 1140,1770 1770,2040
is telling the coordinator,| hey,
|嘿，另一个 worker 加入了我们的集群，

759
00:25:28,960 --> 00:25:30,160
0,180 180,480 480,810 810,1080 1080,1200
this other worker joined our

760
00:25:30,160 --> 00:25:31,870
0,690 720,1110 1110,1140 1140,1350 1350,1710
cluster,| here's a new worker,
|这是一个新 worker ，你可以给它分配任务，

761
00:25:31,870 --> 00:25:32,770
0,120 120,210 210,330 330,510 510,900
that you can give tasks

762
00:25:32,770 --> 00:25:34,450
0,330 540,750 750,900 900,1290 1290,1680
to,| so it's slightly different
|所以，这与我们在实验中的略有不同。

763
00:25:34,450 --> 00:25:36,280
0,120 120,360 360,810 840,1260 1260,1830
than what we had in

764
00:25:36,310 --> 00:25:37,400
0,180 180,660
the lab.|
|

765
00:25:37,950 --> 00:25:40,980
0,630 1020,1530 1530,1650 1650,2460 2460,3030
{} So the coordinator has
所以 coordinator 有两个通道，

766
00:25:40,980 --> 00:25:42,320
0,210 210,840
two channels,|
|

767
00:25:42,440 --> 00:25:45,380
0,810 960,1260 1260,1650 1650,2460 2610,2940
one in which it will
其中一个，它会发送任务给 worker ，

768
00:25:45,380 --> 00:25:48,140
0,600 600,1290 1290,1500 1500,2100 2220,2760
send tasks to workers| or
|或者它不向 worker 发送任务，

769
00:25:48,350 --> 00:25:49,790
0,600 600,870 870,1050 1050,1320 1320,1440
it won't send tasks to

770
00:25:49,790 --> 00:25:51,170
0,360 360,480 480,780 780,1170 1170,1380
workers,| will send tasks to
|将任务发送到线程，线程将向 worker 发送任务，

771
00:25:51,170 --> 00:25:53,030
0,540 570,1200 1200,1320 1320,1500 1500,1860
a thread, that will issue

772
00:25:53,030 --> 00:25:55,220
0,330 330,420 420,1080 1830,2040 2040,2190
tasks to workers,| and then
|然后它有一个 done 通道。

773
00:25:55,220 --> 00:25:56,810
0,150 150,570 570,780 780,1050 1050,1590
it has a done channel.|
|

774
00:25:57,310 --> 00:26:00,780
0,660 930,1860 1890,2580 2580,2880
So again, just like,|
所以再一次，|

775
00:26:01,080 --> 00:26:02,370
0,270 270,450 450,660 660,1020 1020,1290
I I know I said
我知道我说了一些奇怪的话，

776
00:26:02,370 --> 00:26:03,780
0,390 390,480 480,780 780,1200 1200,1410
something a little strange,| which
|你可以通过通道向 worker 发送任务，

777
00:26:03,780 --> 00:26:04,650
0,0 0,270 270,600 600,720 720,870
I was like you can

778
00:26:04,650 --> 00:26:06,180
0,390 450,840 840,930 930,1320 1320,1530
send tasks to workers over

779
00:26:06,180 --> 00:26:07,170
0,120 120,480 480,600 600,720 720,990
the channel,| but you actually
|但实际上不能，

780
00:26:07,170 --> 00:26:09,360
0,480 600,840 840,1260 1260,1740 1740,2190
can't,| the channel is only
|通道只在你的服务器上的 coordinator ，

781
00:26:09,360 --> 00:26:10,860
0,180 180,240 240,750 810,990 990,1500
on the coordinator {on,your} server,|
|

782
00:26:11,070 --> 00:26:11,790
0,270 270,360 360,480 480,570 570,720
and we'll see how that
稍后我们再来看它是如何工作的。

783
00:26:11,790 --> 00:26:13,180
0,270 270,360 360,450 450,870
works in a second.|
|

784
00:26:13,660 --> 00:26:15,250
0,210 210,330 330,840 840,1440 1440,1590
So the first thread of
所以，我们创建的 coordinator 的第一个线程是 goroutine ，

785
00:26:15,250 --> 00:26:16,780
0,90 90,630 630,750 750,870 870,1530
the coordinator that we create

786
00:26:17,200 --> 00:26:18,700
0,270 270,420 420,630 630,1110 1110,1500
is a {goroutine -},| that
|对于每一个 worker ，开始 issueWorkerTaskThread 。

787
00:26:18,730 --> 00:26:21,520
0,870 870,1380 1410,1710 1710,2010 2010,2790
basically will for every worker,

788
00:26:22,300 --> 00:26:25,030
0,810 810,1140 1140,1920 1950,2340 2340,2730
start the {issueWorkerTaskThread - -

789
00:26:25,030 --> 00:26:25,980
0,450
-}.|
|

790
00:26:25,980 --> 00:26:27,280
0,690
So,
所以，这样做的目的是，

791
00:26:27,280 --> 00:26:28,660
0,240 240,450 450,870 870,1200 1200,1380
what this does is,| as
|作为 worker 来来去去，

792
00:26:28,660 --> 00:26:30,820
0,570 570,1110 1230,1440 1440,1740 1770,2160
workers are you know coming

793
00:26:30,820 --> 00:26:32,320
0,150 150,540 540,810 810,960 960,1500
and going,| because they're failing
|因为它们失败了，然后又重启，

794
00:26:32,320 --> 00:26:34,390
0,120 120,300 300,1110 1290,1680 1680,2070
and then restarting,| this channel
|这个通道表示，

795
00:26:34,390 --> 00:26:35,920
0,420 420,810 810,1140 1140,1290 1290,1530
basically says,| okay, we want
|好的，我们想要，对于任何一个 worker ，

796
00:26:35,920 --> 00:26:37,120
0,390 420,690 690,900 900,1020 1020,1200
to, for any of these

797
00:26:37,120 --> 00:26:39,670
0,600 900,1620 1650,1800 1800,2400 2400,2550
workers,| start a thread that
|启动一个将会发布这个 worker 任务的线程。

798
00:26:39,670 --> 00:26:41,260
0,150 150,450 450,630 630,960 960,1590
will issue this worker tasks.|
|

799
00:26:41,960 --> 00:26:44,150
0,570 750,960 960,1110 1110,1590 1740,2190
{} So this is one
所以这里一个 goroutine ，

800
00:26:44,150 --> 00:26:45,760
0,180 180,330 330,690 690,1050
{goroutine - -} here,|
|

801
00:26:46,620 --> 00:26:47,940
0,360 360,450 450,1020 1020,1170 1170,1320
then the coordinator what it
然后 coordinator 所做的是，

802
00:26:47,940 --> 00:26:49,800
0,420 420,750 750,1080 1500,1740 1740,1860
does is it,| for all
|对于所有给出的任务，

803
00:26:49,800 --> 00:26:50,760
0,90 90,390 390,510 510,600 600,960
the tasks that were giving,|
|

804
00:26:50,760 --> 00:26:51,880
0,210 210,630
it just
它只是将这些任务推到这个 tasks 通道，

805
00:26:51,880 --> 00:26:53,020
0,180 180,360 360,690 690,900 900,1140
push those tasks onto this

806
00:26:53,020 --> 00:26:54,260
0,210 210,660
tasks channel,|
|

807
00:26:54,590 --> 00:26:56,570
0,540 630,1020 1020,1350 1350,1830 1830,1980
and this tasks channel,| we
而这个 tasks 通道，|我们让它是一个缓冲通道，

808
00:26:56,570 --> 00:26:57,950
0,330 330,570 570,750 780,990 990,1380
actually made it a buffer

809
00:26:57,950 --> 00:26:59,780
0,540 780,1230 1230,1350 1350,1470 1470,1830
channel,| so that we know
|这样我们知道它能准确地容纳 numTask 个任务，

810
00:26:59,780 --> 00:27:01,430
0,120 120,240 240,540 540,1350 1350,1650
it will hold exactly {numTask

811
00:27:01,430 --> 00:27:03,320
0,480 480,840 840,1260 1290,1530 1530,1890
-} tasks,| which are the
|这就是任务数量，

812
00:27:04,130 --> 00:27:05,570
0,360 360,720 750,1200 1200,1350 1350,1440
that's the limit of the

813
00:27:05,570 --> 00:27:07,250
0,300 300,360 360,870 900,1260 1260,1680
number of tasks,| that will
|将存在于系统中的，

814
00:27:07,280 --> 00:27:08,690
0,390 390,480 480,540 540,870 870,1410
exist on the system,| so
|所以这也意味着，

815
00:27:09,080 --> 00:27:10,190
0,210 210,360 360,660 660,1020 1020,1110
what this also means is

816
00:27:10,190 --> 00:27:11,840
0,180 180,270 270,480 480,1140
that,| we can push
|我们可以在不阻塞的情况下将 numTask 个任务推到通道，

817
00:27:11,870 --> 00:27:13,850
0,330 330,630 630,690 690,1290 1410,1980
the {numTask - -} {}

818
00:27:13,880 --> 00:27:16,400
0,870 1110,1500 1500,1650 1650,2040 2040,2520
tasks onto this channel without

819
00:27:16,400 --> 00:27:18,350
0,660 840,1110 1110,1200 1200,1800 1800,1950
blocking,| so the coordinator will
|所以， coordinator 不会阻塞将任务推送到 tasks 通道。

820
00:27:18,350 --> 00:27:20,390
0,360 360,960 1020,1410 1410,1710 1710,2040
not block on pushing task

821
00:27:20,390 --> 00:27:21,700
0,90 90,180 180,480 480,780
to the tasks channel.|
|

822
00:27:22,170 --> 00:27:24,690
0,450 450,870 900,1020 1020,1860 1860,2520
And then the coordinator will
然后 coordinator 将从这个 done 通道读取，

823
00:27:24,720 --> 00:27:27,000
0,480 480,1080 1080,1320 1320,1590 1590,2280
read from this done channel|
|

824
00:27:27,030 --> 00:27:29,700
0,900 930,1320 1350,1980 1980,2250 2250,2670
until it has done so
直到它完成 numTask 次，

825
00:27:29,700 --> 00:27:31,350
0,330 330,420 420,750 750,1320 1500,1650
{numTask - -} times,| in
|在这种情况下，它知道它已经完成了，

826
00:27:31,350 --> 00:27:33,240
0,510 810,1230 1230,1380 1380,1650 1650,1890
which case, it knows it's

827
00:27:33,240 --> 00:27:34,710
0,420 420,750 750,900 900,1140 1140,1470
done,| in this case, where
|在这个例子中，我没有区分 map 或 reduce 任务，

828
00:27:34,920 --> 00:27:36,540
0,540 540,780 780,1290 1290,1530 1530,1620
I'm not separating map or

829
00:27:36,540 --> 00:27:37,800
0,330 330,540 540,690 690,870 870,1260
reduce tasks,| let's just imagine
|想象一下它们在那里，

830
00:27:37,800 --> 00:27:39,270
0,180 180,390 390,720 750,1170 1170,1470
that there are,| some number
|coordinator 的一些任务需要运行。

831
00:27:39,270 --> 00:27:40,800
0,60 60,360 360,510 510,840 900,1530
of tasks that the coordinator

832
00:27:40,800 --> 00:27:42,200
0,270 270,420 420,810
needs to run.|
|

833
00:27:42,700 --> 00:27:44,800
0,630 630,900 900,1410 1590,1920 1920,2100
And once it knows that
一旦它知道所有的任务都完成了，

834
00:27:44,800 --> 00:27:45,730
0,270 270,450 450,540 540,810 810,930
tasks, all the tasks have

835
00:27:45,730 --> 00:27:47,230
0,540 540,690 690,1080 1080,1170 1170,1500
finished,| it closes the tasks
|它关闭 tasks 通道，然后将退出。

836
00:27:47,230 --> 00:27:51,280
0,510 1230,1410 1410,2010 2040,2520 2550,4050
channel, and then {} basically

837
00:27:51,580 --> 00:27:52,980
0,390 390,870
will exit.|
|

838
00:27:53,520 --> 00:27:56,640
0,270 270,750 780,1620 2280,2910 2910,3120
And so the, where some
所以，其中一些有趣的部分是，

839
00:27:56,640 --> 00:27:58,110
0,180 180,600 600,1050 1050,1260 1260,1470
of the interesting part comes

840
00:27:58,110 --> 00:28:00,480
0,180 180,630 870,1380 1380,1920 1920,2370
in is,| these worker task
|这些 worker 任务线程，

841
00:28:00,480 --> 00:28:01,800
0,360 360,540 540,720 720,1140 1140,1320
threads,| which I've separated out
|我把它们拿出来，放在这里。

842
00:28:01,800 --> 00:28:04,160
0,120 120,480 510,1350 1350,1740
and just function here.|
|

843
00:28:04,420 --> 00:28:06,220
0,180 180,480 480,780 780,1170 1170,1800
So, these all run on
所以，这些都是在子 goroutine 上运行，

844
00:28:06,220 --> 00:28:07,880
0,510 510,1170
sub goroutines,|
|

845
00:28:07,910 --> 00:28:10,010
0,210 210,420 420,540 540,1200 1470,2100
and what it does is
它所做的是为了，

846
00:28:10,190 --> 00:28:11,900
0,1170
for,|
|

847
00:28:11,990 --> 00:28:13,100
0,210 210,600 600,780 780,1020 1020,1110
as long as there are
只要 task 队列中有任务，

848
00:28:13,100 --> 00:28:14,540
0,450 450,570 570,660 660,1020 1020,1440
tasks in the task queue,|
|

849
00:28:14,990 --> 00:28:16,340
0,180 180,600 600,900 900,960 960,1350
it will pull a task
它将拉出一项任务，

850
00:28:16,340 --> 00:28:19,640
0,360 840,1050 1050,1530 1680,2220 3060,3300
out,| and then oops, I
|然后，哦，我不是故意的，

851
00:28:19,640 --> 00:28:20,870
0,240 240,390 390,480 480,750 900,1230
didn't mean to that,| and
|然后调用一个 RPC ，

852
00:28:20,870 --> 00:28:24,350
0,270 270,630 630,1470 1770,2880 2880,3480
then {} call basically an

853
00:28:24,930 --> 00:28:26,490
0,750 750,930 930,1050 1050,1500 1500,1560
RPC,| that will send the
|它会将任务发送给 worker ，

854
00:28:26,490 --> 00:28:28,860
0,360 360,450 450,570 570,1110 1500,2370
task to the worker,| so
|所以注意到，

855
00:28:28,950 --> 00:28:31,140
0,360 360,510 510,690 690,1470 1530,2190
note that,| this channel actually
|这个通道正在与 coordinator 的另一个线程交互，

856
00:28:31,140 --> 00:28:33,150
0,450 630,1080 1080,1200 1200,1620 1620,2010
is talking to another thread

857
00:28:33,150 --> 00:28:35,100
0,90 90,210 210,1080 1140,1650 1650,1950
of the coordinator,| and that
|而那个线程是负责调用 worker 的那个线程，

858
00:28:35,100 --> 00:28:36,480
0,480 480,690 690,990 990,1080 1080,1380
thread is actually the one

859
00:28:36,480 --> 00:28:38,850
0,450 720,930 930,1350 1350,1530 1530,2370
that's in charge of calling

860
00:28:39,150 --> 00:28:41,420
0,660 720,1140 1200,1830
{} the worker,|
|

861
00:28:42,020 --> 00:28:43,700
0,540 540,1080 1140,1440 1440,1560 1560,1680
and then once it's done
然后一旦它完成了任务，它就会说已经完成了，

862
00:28:43,700 --> 00:28:44,990
0,120 120,180 180,630 630,840 840,1290
with the task, it says

863
00:28:44,990 --> 00:28:46,180
0,180 180,630
it's done,|
|

864
00:28:46,620 --> 00:28:48,330
0,210 210,420 420,780 780,1350 1350,1710
if it's not able to,
如果它不能，如果调用失败，

865
00:28:48,330 --> 00:28:49,710
0,390 390,510 510,780 780,1260 1260,1380
if the call fails,| for
|因为某些原因，比如它超时了，

866
00:28:49,710 --> 00:28:51,150
0,210 210,840 840,960 960,1350 1350,1440
some reason, for example it

867
00:28:51,150 --> 00:28:53,520
0,300 300,720 840,1830
times out,| then,
|然后，这个循环所做的是，

868
00:28:53,520 --> 00:28:54,570
0,270 270,450 450,660 660,930 930,1050
what this loop does is,|
|

869
00:28:54,570 --> 00:28:56,160
0,270 270,600 600,840 840,1260 1260,1590
it'll push that task back
它会将该任务推回到 tasks 频道，

870
00:28:56,160 --> 00:28:58,260
0,300 300,390 390,750 750,1320 1530,2100
onto the tasks channel,| so
|所以，另一个 worker 或这个线程可能会再次执行这个任务。

871
00:28:58,260 --> 00:29:00,120
0,480 480,990 990,1200 1200,1590 1590,1860
another worker or potentially this

872
00:29:00,120 --> 00:29:01,320
0,240 240,630 630,870 870,1050 1050,1200
thread again could pick up

873
00:29:01,320 --> 00:29:02,460
0,180 180,690
that task.|
|

874
00:29:03,360 --> 00:29:05,580
0,600 630,1080 1080,1410 1410,1860 1860,2220
So just to clarify how
因此，为了说明通道通信是如何工作的，

875
00:29:05,580 --> 00:29:07,440
0,180 180,570 570,1200 1200,1620 1620,1860
the channel communication works,| so
|所以 worker 发送任务到 tasks 通道，

876
00:29:07,440 --> 00:29:09,180
0,180 180,930 960,1350 1350,1650 1650,1740
the worker sends tasks on

877
00:29:09,180 --> 00:29:10,230
0,90 90,300 300,660 660,870 870,1050
the tasks channel,| which is
|通过这些循环读取，

878
00:29:10,230 --> 00:29:12,360
0,330 330,480 480,720 720,1320
read through these loops,|
|

879
00:29:12,680 --> 00:29:15,110
0,810 840,1230 1230,1530 1530,1740 1740,2430
and this loop will exit
这个循环将在 coordinator 关闭信道时退出，

880
00:29:15,140 --> 00:29:17,930
0,600 600,990 1230,2160 2160,2700 2700,2790
when the coordinator closes the

881
00:29:17,930 --> 00:29:22,670
0,570 2160,3180 3840,4140 4140,4500 4500,4740
channel,| done, it's sent on
|done ，它被发送到这些发送的 worker 线程，

882
00:29:22,670 --> 00:29:24,830
0,330 330,870 870,1170 1170,1500 1500,2160
these worker, issue worker threads,|
|

883
00:29:25,940 --> 00:29:27,290
0,630 660,930 930,1140 1140,1260 1260,1350
and it's read by the
它被原始的 coordinator 线程读取，

884
00:29:27,290 --> 00:29:29,540
0,840 840,960 960,1350 1350,1860 1860,2250
coordinator, the original coordinator thread|
|

885
00:29:30,320 --> 00:29:32,510
0,720 960,1560 1560,1740 1740,1920 1920,2190
and this {exit -} equals
这个 exit 等于 true ，

886
00:29:32,510 --> 00:29:34,730
0,510 510,720 720,1230 1230,1950 2100,2220
true,| will basically tell the
|将会告诉 coordinator ，

887
00:29:34,730 --> 00:29:36,170
0,810 810,1050 1050,1050 1050,1290 1290,1440
coordinator,| like, oh, I don't
|哦，我不需要听更多的 worker 到来或 worker 开始，

888
00:29:36,170 --> 00:29:37,070
0,150 150,240 240,600 600,780 780,900
need to listen for any

889
00:29:37,070 --> 00:29:38,990
0,210 210,600 600,1170 1230,1530 1530,1920
more workers coming or workers

890
00:29:38,990 --> 00:29:39,900
0,300 300,600
starting up,|
|

891
00:29:40,020 --> 00:29:41,910
0,300 300,450 450,810 840,1350 1350,1890
so it will cause this
所以它会导致另一个 goroutine 退出。

892
00:29:42,180 --> 00:29:43,800
0,390 390,540 540,930 930,990 990,1620
other {goroutine -} to exit.|
|

893
00:29:44,850 --> 00:29:45,810
0,300 300,450 450,600 600,780 780,960
So I know that this
我知道这是一个相当复杂的例子，

894
00:29:45,810 --> 00:29:47,370
0,90 90,240 240,660 660,1140 1140,1560
is a pretty complex example,|
|

895
00:29:47,370 --> 00:29:48,810
0,180 180,420 420,900 900,1290 1290,1440
it's also not quite what
这也完全不是我们在实验里指定的，

896
00:29:48,810 --> 00:29:51,570
0,570 1410,2250 2250,2310 2310,2430 2430,2760
we specified in the lab,|
|

897
00:29:51,570 --> 00:29:52,560
0,150 150,270 270,360 360,900 900,990
but as an example of
但是作为如何使用通道的一个例子，

898
00:29:52,560 --> 00:29:54,000
0,240 240,600 600,780 780,930 930,1440
how channels can be used,|
|

899
00:29:54,060 --> 00:29:55,500
0,360 360,750 750,1020 1020,1230 1230,1440
to implement something like {MapReduce
来实现 MapReduce 或类似 MapReduce 的东西。

900
00:29:55,500 --> 00:29:57,060
0,600 780,930 930,1140 1140,1440 1440,1560
-} or something similar to

901
00:29:57,060 --> 00:29:58,640
0,180 180,720
{MapReduce -}.|
|

902
00:30:00,380 --> 00:30:01,640
0,210 210,390 390,480 480,780 780,1260
There is a question in
聊天中有一个问题，

903
00:30:02,150 --> 00:30:03,740
0,360 360,660 660,900 900,1320 1320,1590
the chat,| about where's exit
|关于 exit 在代码中的哪里定义？

904
00:30:03,740 --> 00:30:05,800
0,360 360,900 900,1080 1080,1530
define in this code?|
|

905
00:30:08,640 --> 00:30:10,380
0,360 360,570 570,1020 1050,1290 1290,1740
That is a good question,|
这是个好问题，|

906
00:30:10,380 --> 00:30:13,770
0,330 330,750 1680,2160 2160,2910 2940,3390
it's not,| so it'll, it'll
它没有，|它会跟 done 一样，

907
00:30:13,770 --> 00:30:14,910
0,120 120,660 660,750 750,990 990,1140
be exactly the same thing

908
00:30:14,910 --> 00:30:16,650
0,180 180,660 1320,1440 1440,1530 1530,1740
is done,| it will just
|它将是另一个布尔值的通道，是的，

909
00:30:16,650 --> 00:30:18,280
0,150 150,1110
be another

910
00:30:18,370 --> 00:30:20,380
0,600 600,900 900,1470
channel that's {}

911
00:30:20,710 --> 00:30:22,920
0,180 180,510 510,660 660,1260
a {boolean -}, yeah,|
|

912
00:30:23,160 --> 00:30:25,020
0,450 450,960 960,1230 1230,1590 1620,1860
that's a good, a good
这是一个很好的发现。

913
00:30:25,020 --> 00:30:26,140
0,600
catch.|
|

914
00:30:27,020 --> 00:30:28,790
0,330 330,510 510,720 720,1230 1230,1770
Oh, can I?| I've seen.|
哦，我可以？|我看到。|

915
00:30:28,970 --> 00:30:30,860
0,420 420,510 510,990 1320,1620 1620,1890
How do you add things
如何将东西添加到 workers 通道，

916
00:30:30,860 --> 00:30:31,760
0,90 90,210 210,570 570,780 780,900
to the workers channel,| or
|或者当你向 workers 通道添加东西时，

917
00:30:31,760 --> 00:30:32,450
0,210 210,330 330,420 420,630 630,690
when you add things to

918
00:30:32,450 --> 00:30:33,470
0,60 60,360 360,660 660,840 840,1020
the workers channel,| like how
|在这种情况下，你是怎么处理它们的？

919
00:30:33,470 --> 00:30:34,310
0,90 90,270 270,480 480,630 630,840
do you handle them {in,this}

920
00:30:34,310 --> 00:30:35,260
0,420
case?|
|

921
00:30:35,410 --> 00:30:37,180
0,450 450,780 780,990 990,1200 1200,1770
Yeah, so in this case,|
是的，所以在这种情况下，|

922
00:30:37,420 --> 00:30:39,370
0,510 540,1110 1110,1230 1230,1560 1560,1950
{} worker, the workers channel
workers 通道提供给 coordinator ，

923
00:30:39,370 --> 00:30:41,320
0,450 450,1050 1050,1110 1110,1200 1200,1950
is provided to the coordinator,|
|

924
00:30:41,410 --> 00:30:43,690
0,270 270,900 900,1320 1350,1590 1590,2280
so imagine that, for example,|
想象一下，举个例子，|

925
00:30:43,690 --> 00:30:45,760
0,660 900,1050 1050,1140 1140,1740 1770,2070
and you know how your
你的 Coordinator

926
00:30:45,760 --> 00:30:48,970
0,1020 1050,1260 1260,1950 2070,2760 2790,3210
Coordinator| was actually called or
|是被 main 中的 MR coordinator 调用或创建的，

927
00:30:49,150 --> 00:30:51,080
0,780 780,1440
created by

928
00:30:51,120 --> 00:30:54,930
0,840 900,1830 1860,2760 3000,3300 3300,3810
the MR coordinator in main,|
|

929
00:30:54,960 --> 00:30:57,720
0,630 690,1320 1470,2190 2310,2610 2610,2760
in the {that,[]},| so we
在那个[]中，|所以，我们可以想象，在 MR coordinator 中，

930
00:30:57,720 --> 00:31:00,330
0,300 300,900 900,1350 1740,2100 2100,2610
would imagine that in MR

931
00:31:00,330 --> 00:31:02,160
0,900 900,1080 1080,1290 1290,1680 1680,1830
coordinator,| we would create a
|我们会创建一个 workers 通道，

932
00:31:02,160 --> 00:31:04,100
0,780 810,1470
workers channel,|
|

933
00:31:04,460 --> 00:31:06,620
0,270 270,540 540,1200 1200,1380 1380,2160
and MR coordinator would basically
MR coordinator 将负责跟踪，

934
00:31:06,710 --> 00:31:08,990
0,270 270,450 450,1230 1230,1470 1470,2280
be in charged of tracking,|
|

935
00:31:09,140 --> 00:31:11,360
0,330 330,840 840,1680 1770,1980 1980,2220
when workers crash and when
什么时候 workers 崩溃，什么时候 workers 加入，

936
00:31:11,360 --> 00:31:13,580
0,480 480,1080 1110,1620 1620,1860 1860,2220
workers join,| so this is
|所以这是一个例子，

937
00:31:13,760 --> 00:31:15,170
0,240 240,810 810,900 900,990 990,1410
for example in a case,|
|

938
00:31:15,170 --> 00:31:17,690
0,570 960,1140 1140,1320 1320,2010 2010,2520
where you know maybe new
可能稍后会有新服务器添加到我们的集群中，

939
00:31:17,690 --> 00:31:18,800
0,540 540,630 630,900 900,1020 1020,1110
servers are added to our

940
00:31:18,800 --> 00:31:20,390
0,450 450,630 630,750 750,1050 1050,1590
cluster at some later point|
|

941
00:31:20,450 --> 00:31:22,070
0,510 510,720 720,1200 1200,1530 1530,1620
or some worker crashed and
或者某个 worker 崩溃，然后又回来了，

942
00:31:22,070 --> 00:31:23,780
0,240 240,570 570,990 1020,1590 1590,1710
then came back,| and MR
|而 MR coordinator 会不断地发送，

943
00:31:23,780 --> 00:31:26,450
0,540 540,720 720,810 810,1710 1770,2670
coordinator would be constantly sending,|
|

944
00:31:26,510 --> 00:31:29,030
0,600 600,960 960,1290 1290,1890 1920,2520
like these worker ids to
这些 worker id 给我们的 Coordinator ，

945
00:31:29,060 --> 00:31:30,580
0,270 270,1170
our Coordinator,|
|

946
00:31:30,960 --> 00:31:32,070
0,210 210,510 510,660 660,930 930,1110
in order to tell it,
为了告诉它，嘿，这里有一个新的 worker ，

947
00:31:32,070 --> 00:31:33,480
0,240 240,480 480,690 690,900 900,1410
hey, like there's new worker,|
|

948
00:31:33,480 --> 00:31:34,740
0,150 150,480 480,750 750,1110 1110,1260
you should start issuing it
你应该给它发布任务，

949
00:31:34,740 --> 00:31:36,990
0,630 1350,1560 1560,1920 1920,2160 2160,2250
tasks,| so that part is
|这部分没有显示出来。

950
00:31:36,990 --> 00:31:38,140
0,210 210,630
not shown.|
|

951
00:31:38,350 --> 00:31:40,270
0,540 540,930 930,1230 1230,1740 1770,1920
{Got,it}, yeah, I just I
明白了，是的，我只是在想，

952
00:31:40,270 --> 00:31:42,580
0,300 300,780 810,1320 1320,1680 1710,2310
just {} wondering like,| so
|所以这真的很酷，

953
00:31:42,850 --> 00:31:43,840
0,180 180,510 510,840 840,900 900,990
that's really cool,| I was
|我只是想在实验 1 中，

954
00:31:43,840 --> 00:31:46,690
0,150 150,510 510,1230 1410,2040 2490,2850
just wondering inside the lab

955
00:31:46,690 --> 00:31:48,190
0,330 330,570 570,1140 1170,1380 1380,1500
1,| like how I think
|我想调用 worker ，你发送 RPC 给 worker ，

956
00:31:48,190 --> 00:31:49,480
0,150 150,510 660,930 930,1200 1200,1290
it's like call worker and

957
00:31:49,480 --> 00:31:50,560
0,150 150,510 510,660 660,960 960,1080
you've sends {RPC -} to

958
00:31:50,560 --> 00:31:51,700
0,90 90,660
the worker,|
|

959
00:31:51,700 --> 00:31:53,350
0,720 720,930 1050,1200 1200,1410 1410,1650
{} if if that's something
我们在实验 1 中可以这么做吗？

960
00:31:53,350 --> 00:31:53,830
0,90 90,180 180,270 270,390 390,480
we could have done in

961
00:31:53,830 --> 00:31:55,120
0,240 240,660
lab 1?|
|

962
00:31:57,100 --> 00:31:59,560
0,570 720,1320 1320,1800 1800,2220 2220,2460
It's possible it,| but it
这是可能的，|但这绝对不是我们让你们去做的，

963
00:31:59,560 --> 00:32:00,910
0,420 420,660 690,1020 1020,1200 1200,1350
definitely was not what we

964
00:32:00,910 --> 00:32:03,070
0,270 270,390 390,900 1110,1680 1680,2160
pushed you toward,| {} because
|因为需要，

965
00:32:03,070 --> 00:32:04,600
0,120 120,240 240,990 990,1320 1320,1530
you would basically,| instead of
|不是将 coordinator 设置为 RPC 服务器，

966
00:32:04,630 --> 00:32:06,040
0,270 270,390 390,480 480,1170 1170,1410
setting up the coordinator as

967
00:32:06,040 --> 00:32:07,510
0,300 300,540 540,840 840,1410 1410,1470
being {RPC -} server,| you
|你必须在 worker 是设置 RPC 服务器，

968
00:32:07,510 --> 00:32:08,260
0,120 120,270 270,360 360,540 540,750
would have to set up

969
00:32:08,380 --> 00:32:10,000
0,390 390,510 510,780 780,1230 1230,1620
like {RPC -} servers on

970
00:32:10,000 --> 00:32:12,550
0,300 330,1050 1440,2160 2220,2430 2430,2550
the workers,| {} you can
|你可以认为，

971
00:32:12,550 --> 00:32:13,930
0,300 300,570 570,960 990,1200 1200,1380
also think of,| in this
|在这个实现中， call_worker 可以为每个 worker 设置处理程序，

972
00:32:13,930 --> 00:32:17,600
0,1020 1200,1950 1950,2430 2490,3330
implementation, call_worker could have

973
00:32:17,600 --> 00:32:19,850
0,780 780,1200 1200,1410 1410,1620 1620,2250
handlers actually for each worker,|
|

974
00:32:20,210 --> 00:32:22,400
0,630 1110,1350 1350,1920 1920,2070 2070,2190
and each worker could be
每个 worker 可以发送 task RPC 给 coordinator ，

975
00:32:22,400 --> 00:32:24,710
0,540 540,630 630,1590 1620,2070 2070,2310
sending the coordinator like that

976
00:32:24,710 --> 00:32:26,480
0,360 360,480 480,1080 1110,1590 1590,1770
task {RPCs -},| but a
|但这有点[]，

977
00:32:26,480 --> 00:32:28,120
0,1110
little,

978
00:32:28,850 --> 00:32:30,350
0,240 240,270 270,570 570,1080 1110,1500
that's a little [], {}|
|

979
00:32:30,350 --> 00:32:31,490
0,210 210,330 330,510 510,990 990,1140
so in this example is
所以在这个例子中，可以更自然的想象，

980
00:32:31,490 --> 00:32:33,230
0,300 300,480 480,900 900,1020 1020,1740
actually more natural to imagine,|
|

981
00:32:33,260 --> 00:32:35,810
0,300 300,1140 1260,1650 1650,1920 1920,2550
that call_worker, {} the coordinator
那个 call_worker ， coordinator 是一个客户端，

982
00:32:35,810 --> 00:32:37,040
0,150 150,180 180,660 660,810 810,1230
is a client,| and the
|而 worker 就是处理那个 RPC 的人。

983
00:32:37,400 --> 00:32:38,810
0,450 450,600 600,690 690,1050 1050,1410
workers are the ones that

984
00:32:39,110 --> 00:32:40,940
0,210 210,720 720,990 1020,1200 1200,1830
are handling that {RPCs -}.|
|

985
00:32:41,510 --> 00:32:43,820
0,750 750,1140 1140,1620 1620,1890 1890,2310
Yeah, okay, thanks, very cool.|
好的，谢谢，很酷。|

986
00:32:45,230 --> 00:32:46,850
0,120 120,240 240,420 420,1050 1080,1620
I have two questions, {}|
我有两个问题，|

987
00:32:47,150 --> 00:32:48,650
0,420 420,840 870,1140 1140,1200 1200,1500
first is just a generally
首先，这只是一个一般性的 Go 问题，

988
00:32:48,650 --> 00:32:49,940
0,360 360,690 690,870 870,990 990,1290
Go question,| so in that
|所以，在左侧底部第二个 for 循环中，

989
00:32:49,970 --> 00:32:51,260
0,390 390,630 630,900 900,1200 1200,1290
second for loop on the

990
00:32:51,260 --> 00:32:52,760
0,480 540,870 870,990 990,1110 1110,1500
left, {} at the bottom,|
|

991
00:32:53,700 --> 00:32:54,540
0,180 180,300 300,510 510,840 840,840
if you don't use i,
如果你不使用 i ， Go 会在 for 循环中抱怨吗？

992
00:32:54,960 --> 00:32:57,620
0,360 360,570 570,1230 1380,2010
will Go complain for,

993
00:32:57,620 --> 00:32:58,940
0,270 270,720
{in,a} {for,loop}?|
|

994
00:32:59,480 --> 00:33:02,090
0,810 810,1530 1800,2130 2130,2400 2400,2610
{} So I run like
所以我运行了所有的 Go linter 以及类似的东西，

995
00:33:02,090 --> 00:33:03,500
0,150 150,300 300,780 780,1290 1290,1410
all the Go linter and

996
00:33:03,500 --> 00:33:05,960
0,90 90,330 330,900 1080,1560 1800,2460
all that stuff| and it's
|我觉得这是可以的，

997
00:33:06,080 --> 00:33:08,700
0,600 780,1050 1050,1470 1500,1980
fine, I think,| like,
|在这种情况下，你需要 i ，

998
00:33:08,790 --> 00:33:10,780
0,210 210,420 420,840 840,1440
in this case, you

999
00:33:10,870 --> 00:33:12,460
0,120 120,360 360,1050 1080,1260 1260,1590
do you need to have

1000
00:33:12,460 --> 00:33:15,070
0,480 510,1140 1230,1710 1710,2370 2370,2610
i,| because you're incremented and
|因为你是递增的，在整个过程中保持 i 的状态。

1001
00:33:15,070 --> 00:33:16,390
0,480 480,570 570,930 930,1050 1050,1320
keeping the state of i

1002
00:33:16,390 --> 00:33:19,420
0,690 720,1710 1980,2490
around through the.|
|

1003
00:33:19,420 --> 00:33:20,350
0,360 360,450 450,570 570,660 660,930
Can you do the same
你能做同样的事情，

1004
00:33:20,350 --> 00:33:21,700
0,180 180,330 330,510 510,1050 1170,1350
thing,| with like a like
|比如一个 while 循环，

1005
00:33:21,700 --> 00:33:24,190
0,1260 1260,1560 1560,1860 1860,2190 2190,2490
a while loop,| like just
|比如空的 for 循环加上一个 select ，

1006
00:33:24,190 --> 00:33:25,690
0,360 360,600 600,840 840,1260 1260,1500
for empty for loop with

1007
00:33:25,690 --> 00:33:26,920
0,120 120,720
a select,|
|

1008
00:33:27,430 --> 00:33:29,830
0,510 510,840 840,1020 1020,1770 1830,2400
{} where it's like popping
在那里弹出 done 。

1009
00:33:29,830 --> 00:33:32,080
0,210 210,330 330,810 1080,1710
off of done. {}|
|

1010
00:33:32,250 --> 00:33:33,920
0,1110
So,
所以，你不能，

1011
00:33:35,240 --> 00:33:38,210
0,690 870,1920 1920,2340 2340,2760 2790,2970
you can't actually,| well, you
|好的，你还是需要记录一下你读了多少次 done ，

1012
00:33:38,210 --> 00:33:39,530
0,270 270,450 450,540 540,900 900,1320
still need to keep track

1013
00:33:39,530 --> 00:33:41,360
0,180 180,570 570,1110 1110,1590 1590,1830
of how many times you've

1014
00:33:41,360 --> 00:33:43,250
0,270 270,480 480,960 1140,1590 1590,1890
read from done, right,| because
|因为你不能只读一次，

1015
00:33:43,250 --> 00:33:46,100
0,180 180,600 600,930 930,1620 1980,2850
you can't just read once,|
|

1016
00:33:46,130 --> 00:33:47,630
0,150 150,330 330,480 480,1050 1080,1500
you have to read {numTask
你必须读取 numTask 次。

1017
00:33:47,630 --> 00:33:49,160
0,90 90,540 540,1140
- -} times.|
|

1018
00:33:52,070 --> 00:33:54,830
0,420 420,960 1470,2130 2190,2430 2430,2760
{I,see\,,okay}.| Yeah, yeah, so you
我明白了，好的。|是的，所以你需要某种类型的状态来追踪这个。

1019
00:33:54,830 --> 00:33:56,510
0,150 150,540 540,840 840,1140 1140,1680
do need some type of

1020
00:33:57,640 --> 00:33:59,260
0,540 540,720 720,930 930,1290 1290,1620
state that will track that.|
|

1021
00:33:59,710 --> 00:34:01,220
0,660

1022
00:34:02,800 --> 00:34:04,300
0,150 150,420 420,1290 1290,1410 1410,1500
And then for for the
然后对于右边的那个，

1023
00:34:04,300 --> 00:34:05,470
0,270 270,390 390,510 510,870 870,1170
one on the right,| like
|你从 tasks 中读取并重新添加它，

1024
00:34:05,470 --> 00:34:07,120
0,300 300,660 690,1080 1080,1230 1260,1650
where you're reading from tasks

1025
00:34:07,120 --> 00:34:08,710
0,120 120,240 240,780 780,1020 1050,1590
and {re-populating -} it,| is
|这有什么不好的地方吗，

1026
00:34:09,100 --> 00:34:10,840
0,270 270,420 420,1020 1200,1650 1650,1740
there like any downside to

1027
00:34:10,840 --> 00:34:12,080
0,300 300,660
that, {}|
|

1028
00:34:12,530 --> 00:34:13,610
0,240 240,360 360,540 540,720 720,1080
if you're like just constantly
如果你不断地读取和添加到同一个通道？

1029
00:34:13,610 --> 00:34:15,050
0,330 330,570 570,1020 1050,1350 1350,1440
reading and adding back and

1030
00:34:15,050 --> 00:34:17,200
0,300 300,600 600,930 930,1560
forth {to,the} same channel?|
|

1031
00:34:17,290 --> 00:34:18,660
0,630

1032
00:34:19,740 --> 00:34:21,140
0,180 180,630
I don't,
我想不出来，

1033
00:34:21,140 --> 00:34:22,340
0,300 300,660 660,810 810,960 960,1200
I can't think of that

1034
00:34:22,340 --> 00:34:23,090
0,90 90,270 270,360 360,570 570,750
the top my head,| so
|所以在这种情况下，至少你不会阻塞，

1035
00:34:23,090 --> 00:34:24,440
0,360 360,570 570,810 810,930 930,1350
in this case, at least

1036
00:34:24,470 --> 00:34:26,540
0,330 330,570 570,1110 1440,1860 1860,2070
you won't block,| because every
|因为每次你读到它，

1037
00:34:26,540 --> 00:34:28,040
0,390 390,600 600,780 780,1050 1050,1500
time you read it,| you're
|你会在通道上弹出一些东西，

1038
00:34:28,040 --> 00:34:29,990
0,570 570,960 960,1230 1230,1380 1380,1950
popping something off the channel,|
|

1039
00:34:30,020 --> 00:34:31,940
0,300 300,480 480,960 1500,1770 1770,1920
every time you add it,
每次你添加它，你推送一些东西，

1040
00:34:31,940 --> 00:34:34,970
0,180 180,480 480,1050 1230,2160 2430,3030
you're pushing something,| so because
|因为我们有 tasks 是一个缓冲通道，

1041
00:34:34,970 --> 00:34:36,830
0,180 180,570 570,900 1020,1380 1380,1860
we have that the tasks

1042
00:34:36,830 --> 00:34:38,450
0,180 180,390 390,720 720,1290 1320,1620
is a buffer channel,| but
|但你永远不会阻塞这个。

1043
00:34:38,450 --> 00:34:40,010
0,150 150,420 420,900 930,1200 1200,1560
you'll never block on that.|
|

1044
00:34:41,160 --> 00:34:42,240
0,540
So,
所以，对于性能方面，

1045
00:34:42,520 --> 00:34:45,010
0,210 210,510 510,660 660,1140 1170,2490
in terms of like performance,|
|

1046
00:34:45,430 --> 00:34:46,880
0,150 150,540
I think,
我的意思是，通道是用锁建造的，

1047
00:34:46,940 --> 00:34:48,710
0,150 150,360 360,900 1080,1410 1410,1770
I mean channels are built

1048
00:34:48,710 --> 00:34:50,630
0,240 240,690 690,1200 1200,1650 1650,1920
using locks,| so locks are
|所以锁通常更轻，

1049
00:34:50,630 --> 00:34:53,990
0,300 300,540 540,1260 1800,2700 3210,3360
usually more lightweight,| but I
|但我不认为，你会看到一个大的性能，

1050
00:34:53,990 --> 00:34:55,010
0,240 240,570 570,720 720,870 870,1020
don't think, I don't think,

1051
00:34:55,010 --> 00:34:56,990
0,150 150,390 390,750 750,1410 1440,1980
you'll see a huge performance

1052
00:34:56,990 --> 00:34:58,670
0,120 120,630 900,1350 1350,1560 1560,1680
in fact,| doing something like
|做这样的事。

1053
00:34:58,670 --> 00:34:59,540
0,450
this.|
|

1054
00:34:59,630 --> 00:35:00,980
0,600 630,780 780,990 990,1200 1200,1350
Okay, I guess, I've like
好的，我想，比如，

1055
00:35:00,980 --> 00:35:02,570
0,420 660,990 990,1140 1140,1230 1230,1590
a,| sorry, just like a
|抱歉，比如一个一般的问题，

1056
00:35:02,570 --> 00:35:04,860
0,600 720,1140 1140,1290 1290,1680
general question of like,|
|

1057
00:35:04,860 --> 00:35:06,060
0,240 240,390 390,540 540,1080 1080,1200
what's your like calculus for
你是如何计算并选择，

1058
00:35:06,060 --> 00:35:07,640
0,390 390,990
choosing| between
|在 Mutex 和通道或混合之间，

1059
00:35:07,790 --> 00:35:09,530
0,180 180,750 750,1140 1140,1650 1650,1740
{Mutex -} and channels or

1060
00:35:09,530 --> 00:35:11,380
0,180 180,510 540,1050 1050,1050
like a hybrid {},|
|

1061
00:35:11,380 --> 00:35:13,060
0,150 150,210 210,450 450,960
at the very beginning.|
在最开始的时候。|

1062
00:35:13,560 --> 00:35:16,080
0,780 780,1440 1650,1890 1890,2340 2340,2520
Yeah, so {Mutex -} are
是的，所以 Mutex 对于保护一个状态来说是非常自然的，

1063
00:35:16,080 --> 00:35:17,850
0,300 300,870 870,1020 1020,1260 1260,1770
very natural for just protecting

1064
00:35:17,850 --> 00:35:19,530
0,150 150,420 420,540 540,1290 1380,1680
a piece of state,| so
|比如你的 Coordinator 或你的 Raft 服务器有日志，

1065
00:35:19,530 --> 00:35:22,230
0,420 750,1020 1020,2190 2220,2490 2490,2700
like your Coordinator or like

1066
00:35:22,230 --> 00:35:23,280
0,150 150,420 420,810 810,990 990,1050
your Raft servers have a

1067
00:35:23,280 --> 00:35:25,140
0,600 750,900 900,1140 1140,1350 1350,1860
log,| I want to protect
|我想在每次添加日志时保护，

1068
00:35:25,140 --> 00:35:26,820
0,420 420,510 510,870 870,1020 1020,1680
everytime I append the log,|
|

1069
00:35:26,910 --> 00:35:31,080
0,660 810,1710 1710,2130 2130,2940 3060,4170
{} that seems very difficult
这看起来很难或很不自然，

1070
00:35:31,110 --> 00:35:32,730
0,240 240,360 360,750 750,1020 1020,1620
or it seems very unnatural|
|

1071
00:35:32,730 --> 00:35:33,600
0,90 90,300 300,420 420,540 540,870
to try and do using
在这里尝试使用通道，

1072
00:35:33,600 --> 00:35:36,120
0,660 870,1680 1740,2250 2250,2430 2430,2520
channels,| because essentially, you'd be
|因为从本质上讲，你使用通道锁，

1073
00:35:36,120 --> 00:35:37,830
0,240 240,330 330,780 780,1320 1380,1710
using the channels lock,| you'd
|你想要确保没有其他人在修改状态，

1074
00:35:37,830 --> 00:35:39,630
0,300 300,900 1020,1470 1470,1650 1650,1800
want to ensure that no

1075
00:35:39,630 --> 00:35:40,770
0,180 180,360 360,480 480,1020 1020,1140
one else is modifying the

1076
00:35:40,770 --> 00:35:42,360
0,420 420,630 630,840 840,1350 1350,1590
state,| while you're modifying it,|
|当你修改它的时候，|

1077
00:35:42,600 --> 00:35:43,530
0,240 240,480 480,600 600,690 690,930
and then you would have
然后在你修改它之前，

1078
00:35:43,530 --> 00:35:45,690
0,450 540,1260 1260,1620 1620,1740 1740,2160
to essentially before you modify

1079
00:35:45,690 --> 00:35:46,680
0,300 330,510 510,660 660,900 900,990
it,| try to read on
|试着从通道读取，确认也没有人，

1080
00:35:46,680 --> 00:35:47,880
0,90 90,510 510,660 660,1020 1020,1200
the channel to ensure that

1081
00:35:47,880 --> 00:35:48,920
0,120 120,240 240,780
no one else,|
|

1082
00:35:48,920 --> 00:35:50,300
0,450 750,960 960,1170 1170,1260 1260,1380
alright, like someone would have
好的，比如某些人必须发送东西给通道，

1083
00:35:50,300 --> 00:35:51,110
0,120 120,360 360,630 630,720 720,810
to send something on the

1084
00:35:51,110 --> 00:35:52,220
0,360 360,570 570,720 720,900 900,1110
channel,| just show that they've
|只是表示它们已经完成，

1085
00:35:52,220 --> 00:35:54,350
0,420 480,840 840,1020 1020,1350 1350,2130
done,| they've been finished modifying
|它们已经完成了这样或那样的修改。

1086
00:35:54,350 --> 00:35:56,360
0,270 270,510 510,690 690,1380 1410,2010
so and so forth.| So,
|所以，在这种情况下，很难想象你如何使用通道，

1087
00:35:57,520 --> 00:35:58,450
0,120 120,360 360,570 570,660 660,930
in that case, it's actually

1088
00:35:58,450 --> 00:35:59,650
0,270 270,480 480,570 570,990 990,1200
very hard to imagine how

1089
00:35:59,650 --> 00:36:01,330
0,180 180,510 510,870 870,1260 1410,1680
you do channel,| where {Mutex
|Mutex 会让这个变得非常简单，

1090
00:36:01,330 --> 00:36:02,920
0,390 390,570 570,750 750,1050 1080,1590
-} would make that completely

1091
00:36:02,920 --> 00:36:06,520
0,780 2340,2610 2610,3030 3030,3270 3270,3600
straightforward,| where channels come in
|通道非常方便的地方是，

1092
00:36:06,520 --> 00:36:08,800
0,330 330,1050 1230,1830 1860,2160 2160,2280
very handy is,| like I
|我认为我们的实现已经有了 apply 通道，

1093
00:36:08,800 --> 00:36:11,440
0,360 390,1110 1260,2130 2130,2370 2370,2640
think our implementation already has

1094
00:36:11,440 --> 00:36:13,450
0,120 120,630 630,1140 1410,1710 1710,2010
this apply channel,| is where
|是你必须等待的地方，

1095
00:36:13,450 --> 00:36:15,400
0,210 210,570 570,750 750,1170 1170,1950
you have to wait for,|
|

1096
00:36:16,640 --> 00:36:17,960
0,240 240,660 660,840 840,1050 1050,1320
{} in some ways, it's
在某些方面，它就像条件变量的特定实例，

1097
00:36:17,990 --> 00:36:21,290
0,720 720,960 960,1500 1950,2850 2850,3300
almost like a specific instance

1098
00:36:21,290 --> 00:36:23,060
0,150 150,240 240,690 690,1380 1440,1770
of a condition variable,| in
|在这种情况下，你想要等待什么东西准备好，

1099
00:36:23,060 --> 00:36:24,020
0,240 240,360 360,570 570,690 690,960
which you want to wait

1100
00:36:24,020 --> 00:36:25,850
0,120 120,780 780,960 960,1200 1200,1830
for something to be ready,|
|

1101
00:36:26,030 --> 00:36:28,460
0,330 330,900 1140,1920
{} or a,
或者像是一种要完成的非常具体的命令，

1102
00:36:28,840 --> 00:36:30,140
0,750
{}

1103
00:36:30,900 --> 00:36:33,000
0,330 360,870 900,1290 1290,1860 1860,2100
like a very specific type

1104
00:36:33,000 --> 00:36:34,980
0,390 510,1080 1080,1170 1170,1410 1410,1980
of command to be finished,|
|

1105
00:36:35,010 --> 00:36:37,980
0,810 1050,1860 2130,2520 2520,2790 2790,2970
{} so for something like
所以，对于像发布任务这样的事情来说，是一个不错的例子，

1106
00:36:37,980 --> 00:36:39,570
0,420 420,840 840,960 960,1320 1320,1590
issuing tasks is actually not

1107
00:36:39,570 --> 00:36:42,240
0,120 120,360 360,1020 2160,2310 2310,2670
a bad example| or something
|或者诸如阻塞在一个队列上，

1108
00:36:42,240 --> 00:36:43,260
0,420
like

1109
00:36:43,260 --> 00:36:45,630
0,660 660,1530 1740,1920 1920,2100 2100,2370
blocking until you have something

1110
00:36:45,630 --> 00:36:47,310
0,150 150,210 210,1020 1080,1320 1320,1680
on a queue,| like is
|你可以把它想象成一个队列系统，

1111
00:36:47,370 --> 00:36:48,120
0,150 150,240 240,450 450,600 600,750
you can almost think of

1112
00:36:48,120 --> 00:36:49,110
0,180 180,330 330,480 480,600 600,990
it as like a queuing

1113
00:36:49,110 --> 00:36:50,820
0,540 990,1260 1260,1380 1380,1530 1530,1710
system,| or at least that's
|或者至少我是这么想的，

1114
00:36:50,820 --> 00:36:51,810
0,90 90,450 480,720 720,840 840,990
how I like to think

1115
00:36:51,810 --> 00:36:53,260
0,210 210,420 420,930
about it,| but,
|但是，对于共享状态的几乎所有修改，

1116
00:36:53,260 --> 00:36:55,390
0,330 330,810 810,1320 1320,2040 2040,2130
for almost all modifications to

1117
00:36:55,390 --> 00:36:56,620
0,330 330,750 750,930 930,1020 1020,1230
shared state,| like the race
|比如竞争条件，遇到锁要简单得多，

1118
00:36:56,620 --> 00:36:58,060
0,450 450,900
conditions [],

1119
00:36:58,150 --> 00:37:01,580
0,360 360,1110 1140,1770 1770,2430
{} encounter locks are

1120
00:37:01,920 --> 00:37:03,180
0,390 390,870 870,1020 1020,1110 1110,1260
much simpler| and in some
|在某些方面，推理要容易得多，

1121
00:37:03,180 --> 00:37:04,200
0,330 330,420 420,630 630,900 900,1020
ways, a lot easier to

1122
00:37:04,200 --> 00:37:05,500
0,300 300,720
reason about,|
|

1123
00:37:07,990 --> 00:37:09,000
0,450
but,
但是，是的。

1124
00:37:09,000 --> 00:37:11,200
0,750 780,1200 1200,1410
yeah.| Thank you.|
|谢谢。|

1125
00:37:11,580 --> 00:37:12,660
0,390 390,510 510,720 720,960 960,1080
Sorry, I {have,a} follow up
抱歉，我有一个关于这张幻灯片的后续问题，

1126
00:37:12,660 --> 00:37:15,270
0,390 390,900 930,1110 1110,1680 1710,2610
question to this slide, {}|
|

1127
00:37:15,360 --> 00:37:17,550
0,210 210,690 690,1170 1470,2010 2010,2190
what happens if the,| so
如果，会发生什么，|所以，你调用 Go issueWorkerTaskThread ，

1128
00:37:17,550 --> 00:37:19,110
0,120 120,450 450,600 600,810 810,1560
you call the Go {issueWorkerTaskThread

1129
00:37:19,290 --> 00:37:20,880
0,390 390,780 780,1020 1020,1260 1260,1590
- - -},| which spins
|它会启动另一个 goroutine ，

1130
00:37:20,880 --> 00:37:23,100
0,150 150,870 900,1140 1140,2040 2070,2220
up another {goroutine -},| I
|我的意思是，它遍历通道中的所有任务，

1131
00:37:23,100 --> 00:37:24,420
0,180 180,510 510,900 900,1200 1200,1320
mean, it goes through all

1132
00:37:24,420 --> 00:37:25,500
0,90 90,510 510,630 630,720 720,1080
the tasks in the channel,|
|

1133
00:37:25,500 --> 00:37:26,620
0,240 240,360 360,630
what if it
如果它失败了，

1134
00:37:26,710 --> 00:37:28,690
0,900 900,1140 1140,1590 1620,1770 1770,1980
fails,| when it's what if
|如果 goroutine 失败了，

1135
00:37:28,690 --> 00:37:30,040
0,180 180,360 360,720 720,1170 1170,1350
the {goroutine -} fails,| when
|当它位于 if call_worker 时。

1136
00:37:30,040 --> 00:37:31,660
0,420 510,1020 1020,1260 1260,1410 1410,1620
it's sitting on the if

1137
00:37:31,660 --> 00:37:33,100
0,330 330,930
{call_worker -}.|
|

1138
00:37:34,550 --> 00:37:37,500
0,900 1020,1620
So, {}
所以，如果它失败了，

1139
00:37:38,030 --> 00:37:40,520
0,210 210,570 570,1530
if it fails,|
|

1140
00:37:40,520 --> 00:37:42,440
0,240 240,450 450,1020 1050,1500 1500,1920
then I guess you've taken
那么我想你拿出了一个任务，没有把它放回去，

1141
00:37:42,440 --> 00:37:44,120
0,150 150,600 600,1110
a task out

1142
00:37:45,380 --> 00:37:47,700
0,240 240,570 570,930 1020,1770
and not put back,|
|

1143
00:37:48,860 --> 00:37:51,440
0,660 1050,1650 1650,1890 1890,2250 2280,2580
I'm actually not sure, that
其实我也不确定，这看起来像是，

1144
00:37:51,440 --> 00:37:53,060
0,240 240,450 450,1080
seems like {},|
|

1145
00:37:53,980 --> 00:37:55,270
0,300 300,420 420,870 900,1080 1080,1290
like you're not,| you're saying
比如你不是，|你说的是整个线程崩溃，而不是 call_worker ，

1146
00:37:55,270 --> 00:37:57,310
0,210 210,330 330,840 840,1230 1230,2040
like the entire thread crashes,

1147
00:37:58,130 --> 00:38:00,620
0,390 390,720 720,960 960,1800 1830,2490
rather than as call_worker,| not
|不是返回失败或什么东西。

1148
00:38:00,710 --> 00:38:02,420
0,330 330,720 720,1050 1050,1140 1140,1710
like returning fails or something.|
|

1149
00:38:02,690 --> 00:38:04,640
0,330 330,510 510,1440 1440,1620 1620,1950
Yeah, like the {goroutine -}
是的，比如 goroutine 崩溃，

1150
00:38:04,640 --> 00:38:05,860
0,750
crashes,|
|

1151
00:38:06,010 --> 00:38:07,570
0,240 240,330 330,690 690,1290 1290,1560
or is that possible for
或者单个 goroutine 可能失败吗，

1152
00:38:07,570 --> 00:38:09,280
0,120 120,720 720,930 930,1500 1500,1710
a single {goroutine -} to

1153
00:38:09,280 --> 00:38:10,870
0,480 480,810 810,1170 1260,1500 1500,1590
fail| or would like the
|或者整个事情都没了？

1154
00:38:10,870 --> 00:38:12,070
0,300 300,480 480,690 690,900 900,1200
entire thing just blow up?|
|

1155
00:38:14,180 --> 00:38:15,800
0,300 300,720 720,960 1260,1500 1500,1620
Hey, {Frans\,,you,know}?| {} I think
嘿， Frans ，你知道吗？|我认为你应该拥有的模型是，

1156
00:38:15,800 --> 00:38:16,670
0,60 60,390 390,510 510,630 630,870
the model you should have

1157
00:38:16,670 --> 00:38:18,440
0,90 90,270 270,1170 1200,1590 1590,1770
is that,| if a {goroutine
|如果 goroutine 崩溃，那么进程也会崩溃。

1158
00:38:18,440 --> 00:38:20,090
0,270 270,690 690,780 780,1140 1140,1650
-} crashes, the process crashes.|
|

1159
00:38:21,580 --> 00:38:23,780
0,570 570,630 630,840 840,1350
Yeah, that {would,solve} it.|
是的，这样就能解决了。|

1160
00:38:25,580 --> 00:38:27,830
0,450 450,780 780,1230 1260,1800 1830,2250
{} Sorry, so if just
抱歉，如果只有 worker 崩溃了，

1161
00:38:27,830 --> 00:38:31,700
0,660 690,1260 1260,2100 2610,3300 3330,3870
the worker crashes,| then you
|然后你选择一个不同的任务，

1162
00:38:32,060 --> 00:38:33,260
0,690
pick

1163
00:38:33,260 --> 00:38:35,300
0,120 120,480 480,990 990,1470
a different task,| but,
|但是，如果你，

1164
00:38:35,300 --> 00:38:37,430
0,360 360,900 1170,1590 1590,1950 1980,2130
should you,| I guess you
|我想你仍然会有相同的 worker ，

1165
00:38:37,430 --> 00:38:38,990
0,90 90,300 300,600 600,750 750,1560
would still have the same

1166
00:38:39,540 --> 00:38:41,520
0,930 960,1350
worker,| like
|比如 worker 编号，

1167
00:38:41,840 --> 00:38:43,420
0,330 330,1020
worker number,|
|

1168
00:38:43,420 --> 00:38:44,600
0,630

1169
00:38:44,660 --> 00:38:46,580
0,720 720,1290 1290,1740 1740,1830 1830,1920
{so,you} still connect to the
所以，你仍然连接相同的 worker ，即使它们崩溃了。

1170
00:38:46,580 --> 00:38:47,930
0,270 270,780 780,1020 1020,1200 1200,1350
same worker, even though they

1171
00:38:47,930 --> 00:38:50,540
0,480 480,1350 1980,2280 2280,2520 2520,2610
have failed.| Yeah, so in
|是的，所以在这种情况下，

1172
00:38:50,540 --> 00:38:52,730
0,180 180,540 540,1440 1500,1830 1830,2190
this case,| basically {call_worker -}
|call_worker 只会继续返回 false ，

1173
00:38:52,730 --> 00:38:54,620
0,150 150,300 300,870 900,1320 1320,1890
would just continue returning false,|
|

1174
00:38:55,100 --> 00:38:57,470
0,600 600,690 690,870 870,1410 1530,2370
and you know this goroutine
这个 worker 专门的 goroutine ，

1175
00:38:57,470 --> 00:38:59,540
0,510 510,900 900,1680 1680,1890 1890,2070
that's {} specific for this

1176
00:38:59,540 --> 00:39:00,800
0,300 300,450 450,570 570,810 810,1260
{worker -},| we just continue
|我们只是继续循环，

1177
00:39:00,800 --> 00:39:03,100
0,120 120,660 690,1440
to loop, {}|
|

1178
00:39:03,420 --> 00:39:06,540
0,360 390,1110 1110,1860 1890,2760 2790,3120
and eventually when the map,|
最终，当 map ，|

1179
00:39:06,540 --> 00:39:08,640
0,240 240,330 330,930 930,1440 1590,2100
when the coordinator has determined
当 coordinator 确定所有任务都已完成时，

1180
00:39:08,640 --> 00:39:09,360
0,90 90,210 210,300 300,570 570,720
that all the tasks have

1181
00:39:09,360 --> 00:39:11,220
0,630 630,960 960,1050 1050,1620 1650,1860
finished,| {it'll,close} the channel and
|它将关闭通道，然后这个 goroutine 将退出。

1182
00:39:11,220 --> 00:39:12,510
0,150 150,570 570,750 750,900 900,1290
then {this,goroutine -} will exit.|
|

1183
00:39:13,220 --> 00:39:15,560
0,600 600,1230 1440,1710 1710,2160 2160,2340
So there could potentially like,|
所以有这种可能性，|

1184
00:39:15,560 --> 00:39:17,780
0,150 150,480 480,660 660,1500 1800,2220
if all your workers continue
如果你所有的 worker 持续崩溃，

1185
00:39:17,780 --> 00:39:19,160
0,510 510,630 630,750 750,900 900,1380
crashing,| you have like hundreds
|你有数以百计的 worker 加入，

1186
00:39:19,160 --> 00:39:20,930
0,120 120,300 300,750 750,1290 1440,1770
of new workers joining,| like
|你可以会在这里有很多 goroutine ，

1187
00:39:20,930 --> 00:39:21,890
0,120 120,270 270,690 690,900 900,960
you could potentially have a

1188
00:39:21,890 --> 00:39:23,390
0,300 300,480 480,690 690,1110 1110,1500
lot of {goroutines -} just

1189
00:39:23,390 --> 00:39:24,410
0,270 270,450 450,690 690,780 780,1020
there,| just like I can't
|我不能联系我的 worker ，

1190
00:39:24,410 --> 00:39:25,310
0,390 390,480 480,720 720,810 810,900
contact my worker,| {} I
|我不能联系我的 worker ，

1191
00:39:25,310 --> 00:39:27,350
0,210 210,570 570,660 660,1230 1530,2040
can't contact my worker,| but
|但是一旦任务完成，

1192
00:39:27,380 --> 00:39:28,850
0,330 330,420 420,720 720,900 900,1470
once the task is finished,|
|

1193
00:39:28,850 --> 00:39:30,260
0,450 510,1050 1050,1110 1110,1260 1260,1410
this all of them will
这一切都将正常退出。

1194
00:39:30,260 --> 00:39:31,200
0,480
exit

1195
00:39:31,200 --> 00:39:32,500
0,750
properly.|
|

1196
00:39:39,440 --> 00:39:41,480
0,480 510,960 990,1530 1530,1920 1920,2040
Cool, alright,| so that's an
酷，好的，|这是一个通道的例子，

1197
00:39:41,480 --> 00:39:44,030
0,480 480,840 840,1500 1800,2310 2310,2550
example with channels,| and now
|现在让我们转到一些

1198
00:39:44,030 --> 00:39:45,230
0,210 210,390 390,630 630,900 900,1200
let's move on to some

1199
00:39:45,230 --> 00:39:46,600
0,210 210,780
of the|
|

1200
00:39:46,600 --> 00:39:48,850
0,330 330,780 1050,1380 1380,2100 2100,2250
more like your questions and
你们的问题和错误之类的事情上。

1201
00:39:48,850 --> 00:39:49,810
0,360 360,480 480,660 660,810 810,960
bugs and things like that.|
|

1202
00:39:49,810 --> 00:39:51,340
0,120 120,390 390,840 840,1170 1170,1530
So some common but passing
所以，我们看到的一些常见但通过的设计错误

1203
00:39:51,340 --> 00:39:52,690
0,300 300,690 690,780 780,900 900,1350
design mistakes that we saw|
|

1204
00:39:52,900 --> 00:39:54,760
0,540 570,1140 1140,1380 1380,1620 1620,1860
was pushing too much work
是把太多的工作交给了 coordinator ，

1205
00:39:54,760 --> 00:39:56,620
0,90 90,180 180,870 1140,1470 1470,1860
to the coordinator,| so essentially
|这会使 coordinator 成为瓶颈，

1206
00:39:56,620 --> 00:39:59,260
0,270 270,360 360,1140 1140,1830 1920,2640
making the coordinator bottleneck,| and
|这包括 coordinator [] ，

1207
00:39:59,260 --> 00:40:01,540
0,330 330,1020 1020,1500 1500,1590 1590,2280
this included both the coordinator

1208
00:40:01,540 --> 00:40:04,750
0,360 1050,1770 1770,1830 1830,2610 2700,3210
[],| sorting the results or
|对结果排序或 coordinator 读取文件内容，

1209
00:40:04,750 --> 00:40:06,790
0,60 60,720 720,1050 1050,1380 1380,2040
the coordinator reading file contents,|
|

1210
00:40:06,820 --> 00:40:08,620
0,540 540,780 780,1020 1020,1230 1230,1800
whereas a lot of the
然而， MapReduce 的许多优点在于，

1211
00:40:09,140 --> 00:40:10,340
0,480 510,750 750,810 810,1140 1140,1200
{} kind of beauty of

1212
00:40:10,340 --> 00:40:12,560
0,240 240,720 720,900 900,1290 1830,2220
{MapReduce -} is that,| all
|所有的状态，所有的计算都发生在 worker 上。

1213
00:40:12,560 --> 00:40:15,110
0,150 150,720 720,900 900,1410 1440,2550
the state, all the computation

1214
00:40:15,110 --> 00:40:17,240
0,570 570,840 840,960 960,1680
happens on the workers.|
|

1215
00:40:17,660 --> 00:40:20,630
0,540 540,720 720,1260 1260,1920 2310,2970
{} And another con, {}
还有另一个缺点，这并不是一个真正的错误，

1216
00:40:20,840 --> 00:40:22,250
0,390 390,600 600,810 810,930 930,1410
it's not really a mistake,|
|

1217
00:40:22,250 --> 00:40:23,720
0,360 360,750 750,1110 1110,1290 1290,1470
but potentially something to think
但潜在的需要考虑的是，

1218
00:40:23,720 --> 00:40:24,950
0,300 300,510 540,960 960,1140 1140,1230
about is,| how many {RPCs
|你要发送多少 RPC ，

1219
00:40:24,950 --> 00:40:26,720
0,390 390,480 480,570 570,1080 1080,1770
-} are you sending,| and
|你是否真的需要发送那么多 RPC 。

1220
00:40:26,930 --> 00:40:27,840
0,420
like,

1221
00:40:28,070 --> 00:40:29,210
0,270 270,510 510,810 810,1050 1050,1140
do you really need to

1222
00:40:29,210 --> 00:40:30,530
0,210 210,390 390,600 600,1140 1140,1320
send that many {RPCs -}.|
|

1223
00:40:30,800 --> 00:40:32,330
0,360 360,480 480,1200 1200,1440 1440,1530
So for example sending an
例如，发送 RPC 检查是否有可用的 Map 任务，

1224
00:40:32,330 --> 00:40:33,890
0,480 480,600 600,990 990,1350 1350,1560
RPC to check whether there's

1225
00:40:33,890 --> 00:40:35,510
0,60 60,360 360,660 660,1380 1440,1620
a Map task available,| and
|然后发送另一个 RPC 要求给我一个任务，

1226
00:40:35,510 --> 00:40:36,830
0,150 150,390 390,810 810,1200 1200,1320
then sending another RPC to

1227
00:40:36,830 --> 00:40:37,910
0,420 420,720 720,870 870,1020 1020,1080
ask like give me a

1228
00:40:37,910 --> 00:40:39,820
0,750 780,1470
task,| is
|是有点多余的

1229
00:40:39,820 --> 00:40:41,320
0,150 150,450 450,990 990,1380 1380,1500
a little redundant| and you
|你想试着减少，

1230
00:40:41,320 --> 00:40:42,820
0,180 180,270 270,570 570,840 870,1500
want to try and reduce

1231
00:40:42,850 --> 00:40:45,190
0,420 450,1260 1260,1680 1680,2010 2010,2340
the number and types of,|
|

1232
00:40:45,280 --> 00:40:46,930
0,360 360,660 660,780 780,1290 1290,1650
like reduce the API between
减少 coordinator 和 worker 之间的 API ，

1233
00:40:46,930 --> 00:40:48,730
0,180 300,900 930,1170 1170,1290 1290,1800
the master, {} the coordinator

1234
00:40:48,730 --> 00:40:49,980
0,120 120,210 210,750
and the worker,|
|

1235
00:40:50,460 --> 00:40:52,260
0,390 420,600 600,780 780,1170 1470,1800
{} but these were, like
但这些，它们通过了测试，

1236
00:40:52,260 --> 00:40:53,280
0,120 120,270 270,510 510,570 570,1020
they were passed the test,|
|

1237
00:40:53,280 --> 00:40:54,720
0,480 660,900 900,1140 1140,1350 1350,1440
and it's just things we
这只是我们想指出的一些事情。

1238
00:40:54,720 --> 00:40:56,220
0,240 240,330 330,630 630,930
wanted to point out.|
|

1239
00:40:57,610 --> 00:41:00,160
0,750 780,1860 1890,2160 2160,2370 2370,2550
So now, okay cool, what
所以，现在，好的，酷，我接下来的课程。

1240
00:41:00,160 --> 00:41:01,060
0,210 210,420 420,630 630,720 720,900
about like how I do

1241
00:41:01,060 --> 00:41:03,000
0,570 630,1380
lecture.| So,
|所以，接下来，比如 5 6 分钟，

1242
00:41:03,060 --> 00:41:04,470
0,240 240,360 360,750 750,1020 1020,1410
for the next, say like

1243
00:41:04,470 --> 00:41:06,780
0,540 540,810 810,1380 1710,2190 2190,2310
5 6 minutes,| what we're
|我们要做的是分组会议室，

1244
00:41:06,780 --> 00:41:07,950
0,180 180,270 270,420 420,780 780,1170
going to do breakout rooms,|
|

1245
00:41:07,950 --> 00:41:09,900
0,750 840,1260 1260,1380 1380,1710 1710,1950
let let me stop sharing
让我来停止分享，

1246
00:41:09,900 --> 00:41:11,970
0,510 1140,1440 1440,1620 1620,1770 1770,2070
actually,| alright, so do breakout
|好的，开始分组会议室，

1247
00:41:11,970 --> 00:41:14,140
0,390 810,1650
rooms,| and
|哦，糟糕，让我看看，

1248
00:41:14,200 --> 00:41:18,490
0,630 630,1200 2850,3150 3150,3600 3630,4290
oh shoot, let's see, {}|
|

1249
00:41:21,690 --> 00:41:22,950
0,210 210,480 480,720 720,930 930,1260
I think Zoom just crashed
我想我的 Zoom 刚刚崩溃了。

1250
00:41:22,950 --> 00:41:23,960
0,120 120,450
on me.|
|

1251
00:41:28,050 --> 00:41:28,980
0,210 210,300 300,510 510,750 750,930
We could still hear and
我们仍然可以听到和看到你。

1252
00:41:28,980 --> 00:41:31,380
0,210 210,600 1050,1920 1950,2160 2160,2400
see you.| Alright, I'm back,|
|好了，我回来了，|

1253
00:41:31,380 --> 00:41:34,500
0,1770 1830,2310 2310,2790 2790,2880 2880,3120
yeah, I upgraded {Zoom -}
是的，我在这节课之前升级了 Zoom ，

1254
00:41:34,500 --> 00:41:35,400
0,180 180,360 360,660 660,750 750,900
before this lecture,| that was
|这不是个好主意，

1255
00:41:35,400 --> 00:41:37,080
0,60 60,270 270,690 870,1320 1320,1680
a bad idea,| but, alright,
|但是，好的，在接下来的五六分钟里，

1256
00:41:37,080 --> 00:41:37,710
0,90 90,150 150,420 420,570 570,630
for the next 5 or

1257
00:41:37,710 --> 00:41:39,420
0,210 210,600 660,1110 1110,1260 1260,1710
6 minutes,| {} you should
|你应该讨论，

1258
00:41:39,750 --> 00:41:41,610
0,390 390,870 870,1020 1020,1380 1710,1860
talk about just like| you
|你在实验中任何有趣的 bug 或观察，

1259
00:41:41,610 --> 00:41:43,470
0,210 210,810 810,1230 1230,1710 1710,1860
know any interesting bugs or

1260
00:41:43,470 --> 00:41:45,240
0,630 630,750 750,900 900,1200 1200,1770
observations, you had about lab,|
|

1261
00:41:45,630 --> 00:41:46,740
0,180 180,270 270,570 600,750 750,1110
or you could you know
或者你可以抱怨你花了太长时间才找到某个漏洞，

1262
00:41:46,770 --> 00:41:47,910
0,540 540,720 720,840 840,1050 1050,1140
complain about how long it

1263
00:41:47,910 --> 00:41:48,630
0,180 180,330 330,420 420,660 660,720
took you to find a

1264
00:41:48,630 --> 00:41:50,700
0,270 270,720 1080,1440 1440,1650 1650,2070
certain bug| or ask questions
|或者互相提问，

1265
00:41:50,700 --> 00:41:52,260
0,120 120,240 240,720 1050,1290 1290,1560
to each other,| and then
|然后我们会回来，讨论你们的一些问题。

1266
00:41:52,260 --> 00:41:53,640
0,150 150,330 330,810 810,1200 1230,1380
we'll come back and go

1267
00:41:53,640 --> 00:41:54,750
0,180 180,330 330,390 390,510 510,1110
over some of your questions.|
|

1268
00:41:55,940 --> 00:41:57,220
0,570
Alright.|
好的。|

1269
00:41:57,650 --> 00:41:59,280
0,840

1270
00:42:00,910 --> 00:42:02,420
0,720
Okay.|
好的。|

1271
00:42:03,060 --> 00:42:04,080
0,450 480,840 840,900 900,960 960,1020
Alright, see you in a
好的，待会见。

1272
00:42:04,080 --> 00:42:04,940
0,300
bit.|
|

1273
00:42:23,780 --> 00:42:24,780
0,150

1274
00:42:27,340 --> 00:42:28,270
0,210 210,360 360,510 510,720 720,930
Oh, so { - -}
哦， [] 和 Frans 一起，

1275
00:42:28,270 --> 00:42:29,320
0,210 210,750 750,840 840,900 900,1050
with Frans,| do you want
|你想让我重新分到别的组吗？

1276
00:42:29,320 --> 00:42:30,430
0,90 90,150 150,420 420,720 720,1110
me to [] somewhere else?|
|

1277
00:42:30,610 --> 00:42:32,200
0,660 660,930 930,1380 1380,1500 1500,1590
Probably best, but let me
也许是最好的，但让我看看我自己能不能做到。

1278
00:42:32,200 --> 00:42:32,680
0,150 150,240 240,300 300,390 390,480
see if I can do

1279
00:42:32,680 --> 00:42:33,760
0,60 60,540
it myself.|
|

1280
00:42:33,790 --> 00:42:35,120
0,780
Okay,
好的，我马上回来。

1281
00:42:35,180 --> 00:42:35,960
0,270 270,420 420,510 510,630 630,780
I'm going to be right

1282
00:42:35,960 --> 00:42:36,980
0,420
back.|
|

1283
00:49:12,240 --> 00:49:16,600
0,720

1284
00:49:37,790 --> 00:49:41,330
0,570 1020,1620 1620,2040 2040,3060 3060,3540
Alright, are we mostly back,
好的，我想我们差不多都回来了。

1285
00:49:41,360 --> 00:49:42,580
0,450
{I,think}.|
|

1286
00:49:43,880 --> 00:49:45,220
0,690
{Alright,cool}.|
好的，酷。|

1287
00:49:46,680 --> 00:49:47,940
0,360 360,750 870,960 960,1140 1140,1260
Okay, so I hope that
好的，我希望这很有趣，

1288
00:49:47,940 --> 00:49:49,320
0,300 570,840 840,1170 1170,1290 1290,1380
was pretty fun| or at
|或者至少你可以谈谈你在实验中的一些挫败感。

1289
00:49:49,320 --> 00:49:50,310
0,270 300,540 540,720 720,780 780,990
least you got to talk

1290
00:49:50,310 --> 00:49:51,750
0,210 210,330 330,420 420,780 810,1440
about some of your frustrations

1291
00:49:51,750 --> 00:49:54,900
0,240 240,630 1860,2550 2580,2940 2940,3150
during {the,lab}.| {} Yeah, so
|是的，对于剩下的课程，

1292
00:49:54,900 --> 00:49:55,440
0,90 90,180 180,420 420,480 480,540
for the rest of the

1293
00:49:55,440 --> 00:49:56,580
0,510 510,630 630,840 840,930 930,1140
lecture,| we're going to go
|我们要去，

1294
00:49:56,580 --> 00:49:59,670
0,570 1410,1830 1830,2190 2190,2760 2760,3090
to,| first, before questions,| take
|首先，在提问之前，|给出一些一般的提示，

1295
00:49:59,730 --> 00:50:01,080
0,210 210,570 570,900 900,1080 1080,1350
some general tips,| that you'll
|你要在未来的实验中注意。

1296
00:50:01,080 --> 00:50:01,950
0,210 210,270 270,480 480,630 630,870
want to look out for

1297
00:50:01,950 --> 00:50:04,530
0,240 270,630 630,1080 1560,2130 2250,2580
for future labs.| {} So
|所以，首先，

1298
00:50:04,530 --> 00:50:06,990
0,240 240,330 330,870 900,1770 2040,2460
first of all,| the one
|你会发现调试非常方便的一件事是，

1299
00:50:06,990 --> 00:50:09,030
0,300 300,540 540,900 900,1200 1200,2040
thing you'll find very handy

1300
00:50:09,300 --> 00:50:10,590
0,180 180,540 540,690 690,1110 1170,1290
for debugging is just| you
|经典的 printf ，

1301
00:50:10,590 --> 00:50:12,570
0,240 240,660 660,840 840,1260 1350,1980
know classic {printfs -}| and
|你可以使用有条件的 printf ，

1302
00:50:12,570 --> 00:50:13,830
0,300 300,480 480,570 570,720 720,1260
so you can have conditional

1303
00:50:13,830 --> 00:50:16,050
0,420 420,630 630,1020 1020,1530 1680,2220
printfs,| which only print when
|只有当你想 debug 时打印，

1304
00:50:16,050 --> 00:50:17,400
0,180 180,510 510,630 630,1020 1020,1350
you want to debug,| so
|所以，你不必遍历代码，

1305
00:50:17,400 --> 00:50:18,270
0,150 150,540 540,600 600,750 750,870
for example you don't have

1306
00:50:18,270 --> 00:50:19,080
0,120 120,270 270,390 390,480 480,810
to go through your code|
|

1307
00:50:19,080 --> 00:50:20,520
0,120 120,510 870,1050 1050,1230 1230,1440
and comment them all out,|
把它们都注释掉，|

1308
00:50:20,520 --> 00:50:21,570
0,270 270,360 360,780 780,840 840,1050
before you submit or something
在你提交或做类似的东西之前，

1309
00:50:21,570 --> 00:50:23,460
0,150 150,390 810,1140 1140,1560 1560,1890
like that,| and so in
|所以在 Raft 实验里，

1310
00:50:23,460 --> 00:50:25,710
0,90 90,510 510,1080 1290,1590 1590,2250
the Raft lab,| we provide
|我们提供了 DPrintf 在 util.go 文件中，

1311
00:50:25,710 --> 00:50:27,450
0,330 330,570 570,1110 1110,1620 1620,1740
this {DPrintf -} in the

1312
00:50:27,450 --> 00:50:28,960
0,600 600,1230
{util.go,file -},|
|

1313
00:50:29,290 --> 00:50:30,670
0,360 360,570 570,690 690,840 840,1380
{} and you can modify
你可以对其修改，打印出比如 server ID ，

1314
00:50:30,670 --> 00:50:32,800
0,450 810,1080 1080,1230 1230,1650 1650,2130
that to for example also

1315
00:50:32,800 --> 00:50:35,170
0,450 450,780 930,1320 1320,1680 1680,2370
{print,out} like the server ID,|
|

1316
00:50:35,170 --> 00:50:36,370
0,360 360,600 600,840 840,930 930,1200
every single time you call
每次你调用 DPrintf 或类似的地方，

1317
00:50:36,370 --> 00:50:37,390
0,120 120,330 330,600 600,690 690,1020
{DPrintf - -} or something

1318
00:50:37,390 --> 00:50:39,460
0,180 180,630 750,1500
like that,| so,
|所以，是的，我定制了它

1319
00:50:39,580 --> 00:50:41,200
0,150 150,270 270,900 900,1260 1260,1620
yeah, I customize it| to
|用不同的颜色来打印不同 RPC ，

1320
00:50:41,230 --> 00:50:42,400
0,150 150,360 360,600 600,900 900,1170
you know print out different

1321
00:50:42,400 --> 00:50:44,170
0,390 390,510 510,900 900,1410 1410,1770
colors for different {RPCs -},|
|

1322
00:50:44,170 --> 00:50:45,300
0,180 180,450
like that,|
就像这样，|

1323
00:50:45,390 --> 00:50:47,610
0,660 720,1050 1050,1500 1500,1770 1770,2220
{} and also like redirecting
还可以重定向你的输出文件，

1324
00:50:47,610 --> 00:50:49,140
0,120 120,420 420,1140 1200,1410 1410,1530
your output files,| just so
|如果你需要搜索就会很方便。

1325
00:50:49,140 --> 00:50:50,010
0,180 180,270 270,420 420,690 690,870
you can like search the

1326
00:50:50,010 --> 00:50:51,630
0,540 540,780 780,960 960,1080 1080,1620
files will come in handly.|
|

1327
00:50:52,620 --> 00:50:54,220
0,1080
Another
另一个你可能要记住的技巧是，

1328
00:50:54,220 --> 00:50:55,420
0,240 240,390 390,690 690,990 990,1200
trick that you probably want

1329
00:50:55,420 --> 00:50:56,650
0,420 450,630 630,720 720,1020 1020,1230
to keep in mind is,|
|

1330
00:50:56,650 --> 00:50:57,720
0,150 150,480
you can
你可以查看所有 goroutine ，

1331
00:50:57,720 --> 00:50:58,800
0,300 300,480 480,690 690,810 810,1080
look at all the {goroutines

1332
00:50:58,800 --> 00:51:00,060
0,330 330,420 420,690 690,1140 1140,1260
-}| to see where and
|看看它们在哪里运行，

1333
00:51:00,060 --> 00:51:03,840
0,450 930,1620 1620,2250 2550,3120 3360,3780
their execution, they're running,| and
|只需要输入 Ctrl-\ 来做到这个。

1334
00:51:03,840 --> 00:51:06,270
0,150 150,420 420,600 600,1470 1500,2430
so just type {Ctrl-\ -}

1335
00:51:06,270 --> 00:51:07,200
0,180 180,360 360,480 480,600 600,930
in order to do that.|
|

1336
00:51:08,260 --> 00:51:09,910
0,690 690,840 840,1110 1110,1320 1320,1650
And the final thing which
最后一个是我们已经谈到过的 defer ，

1337
00:51:09,910 --> 00:51:11,080
0,330 330,540 540,600 600,870 870,1170
already sort of talked about

1338
00:51:11,080 --> 00:51:12,880
0,150 150,390 390,960 960,1500 1530,1800
are these defers,| and these
|这些幻灯片也将被上传，

1339
00:51:12,880 --> 00:51:14,110
0,240 240,360 360,480 480,900 900,1230
slides will be uploaded also,|
|

1340
00:51:14,110 --> 00:51:14,950
0,150 150,270 270,360 360,630 630,840
so you can refer back
所以你可以回来参考它们，

1341
00:51:14,950 --> 00:51:17,230
0,90 90,420 750,1500 1530,1770 1770,2280
to them,| {} but actually
|但是你可以推入多个函数，

1342
00:51:17,230 --> 00:51:18,340
0,120 120,570
you can

1343
00:51:18,340 --> 00:51:20,830
0,420 420,1530 1560,2100 2100,2220 2220,2490
push multiple functions| to run
|在函数返回之前运行，

1344
00:51:20,830 --> 00:51:23,350
0,240 240,630 630,1320 1410,1860 1860,2520
right before the function returns|
|

1345
00:51:23,650 --> 00:51:25,750
0,540 600,1290 1320,1560 1560,1710 1710,2100
and they just be careful
只是要注意它们的顺序。

1346
00:51:25,750 --> 00:51:27,060
0,90 90,210 210,780
of the ordering.|
|

1347
00:51:27,920 --> 00:51:29,900
0,600 630,930 930,1440 1440,1740 1740,1980
Alright, so now let's get
好的，现在来回答你们的一些问题，

1348
00:51:29,900 --> 00:51:31,220
0,180 180,360 360,420 420,630 630,1320
to some of your questions,|
|

1349
00:51:32,720 --> 00:51:33,530
0,300 300,480 480,630 630,690 690,810
{} a lot of you
你们中的许多人也提交了关于 Raft 的问题，

1350
00:51:33,530 --> 00:51:35,360
0,390 390,690 690,1110 1110,1380 1380,1830
submitted also questions about Raft,|
|

1351
00:51:35,360 --> 00:51:37,010
0,330 330,750 750,960 960,1230 1230,1650
so those will get to
这些会放到 Raft 的问答，

1352
00:51:37,010 --> 00:51:39,170
0,450 720,900 900,1260 1260,1620 1620,2160
for the {Raft,Q&A -}| or
|或者办公时间

1353
00:51:39,560 --> 00:51:41,720
0,300 300,660 660,1200 1200,1950 1950,2160
maybe office hours| or {you,can,put,that,on,Piazza}.|
|或者你可以把它放在 Piazza 上。|

1354
00:51:41,720 --> 00:51:42,620
0,90 90,300 360,690 690,810 810,900
I'm {} {going -} to
我将主要集中在 MapReduce 中的那些，

1355
00:51:42,620 --> 00:51:44,120
0,390 390,990 990,1170 1170,1260 1260,1500
focus mostly on the ones

1356
00:51:44,120 --> 00:51:45,710
0,150 150,390 390,900 930,1230 1230,1590
from {MapReduce -}| or maybe
|或者，也许有时间，我们也可以看一些 Raft 问题。

1357
00:51:45,710 --> 00:51:46,490
0,120 120,330 330,600 600,660 660,780
have time, then we can

1358
00:51:46,490 --> 00:51:48,380
0,270 270,480 480,840 840,1500
also get Raft questions.|
|

1359
00:51:49,950 --> 00:51:51,740
0,480 510,1230
Alright, so
好的，第一类问题，

1360
00:51:51,740 --> 00:51:53,810
0,210 210,720 750,1350 1350,1470 1470,2070
the first category of questions|
|

1361
00:51:53,810 --> 00:51:56,270
0,240 240,360 360,630 630,1200 1440,2460
kind of falls under questions
是专门关于 MapReduce 的问题，

1362
00:51:56,270 --> 00:51:59,060
0,660 660,930 930,1170 1170,1860 2310,2790
specifically about {MapReduce -}, {}|
|

1363
00:51:59,090 --> 00:52:01,220
0,270 270,540 540,840 840,1530 1710,2130
so some more complex tasks
所以，你可能需要使用 MapReduce 来执行一些更复杂的任务，

1364
00:52:01,220 --> 00:52:02,150
0,240 240,360 360,630 630,840 840,930
that you might want to

1365
00:52:02,150 --> 00:52:04,220
0,240 240,900 900,1470 1680,1950 1950,2070
use MapReduce for,| {} it's
|它在机器学习、数据挖掘、统计应用中被大量使用，

1366
00:52:04,220 --> 00:52:05,180
0,300 300,510 510,540 540,870 870,960
actually used a lot in

1367
00:52:05,180 --> 00:52:06,770
0,570 570,750 750,930 930,1200 1200,1590
ML, or like data mining,

1368
00:52:06,770 --> 00:52:09,770
0,900 930,1920 2040,2550 2550,2700 2700,3000
statistical applications,| {} I linked
|我在这里链接到 Hadoop ，

1369
00:52:09,770 --> 00:52:11,260
0,390 390,1080
here to

1370
00:52:11,380 --> 00:52:13,180
0,480 510,870 870,1170 1170,1410 1410,1800
{} Hadoop,| which is {}
|它实现了 MapReduce ，

1371
00:52:13,240 --> 00:52:15,250
0,900 1110,1380 1380,1770 1770,1830 1830,2010
implements {MapReduce -},| a lot
|很多人使用它来运行这些类型的任务。

1372
00:52:15,250 --> 00:52:16,060
0,60 60,300 300,450 450,630 630,810
of people use it to

1373
00:52:16,060 --> 00:52:17,770
0,540 570,780 780,1020 1020,1080 1080,1710
run these types of tasks.|
|

1374
00:52:18,250 --> 00:52:20,740
0,450 450,750 750,870 870,1800 2100,2490
{} And for example, here's
例如，这是一个简单的，

1375
00:52:20,740 --> 00:52:21,900
0,660
a

1376
00:52:21,900 --> 00:52:24,360
0,900 1260,1680 1710,2100 2100,2340 2340,2460
simple,| or maybe not so
|也可能不是那么简单的，

1377
00:52:24,360 --> 00:52:27,390
0,390 390,570 570,1320 1350,2400 2400,3030
simple,| but basically matrix multiplication
|但是矩阵乘法的例子，

1378
00:52:27,390 --> 00:52:28,650
0,600 600,750 750,900 900,1020 1020,1260
example,| of how you would
|你如何使用 MapReduce 来[]它。

1379
00:52:28,680 --> 00:52:30,060
0,210 210,390 390,600 600,810 810,1380
[] that using {MapReduce -}.|
|

1380
00:52:31,340 --> 00:52:34,160
0,660 870,1290 1290,1650 1710,2100 2340,2820
{} Second, like you for
第二，对于 coordinator 的容错，

1381
00:52:34,160 --> 00:52:35,660
0,240 240,630 630,720 720,810 810,1500
fault tolerance of the coordinator,|
|

1382
00:52:35,660 --> 00:52:37,010
0,90 90,450 450,900 900,1050 1050,1350
the paper proposes a very
论文提出了一种非常简单的检查点机制，

1383
00:52:37,010 --> 00:52:40,600
0,690 930,1500 1530,2100 2100,3060
simple {} {checkpointing -}

1384
00:52:40,990 --> 00:52:42,520
0,720 720,840 840,1110 1110,1260 1260,1530
mechanism,| in which you'll just
|你只需要启动一个新的 coordinator ，

1385
00:52:42,520 --> 00:52:44,500
0,300 300,570 570,1080 1080,1260 1260,1980
start up a new coordinator,|
|

1386
00:52:44,500 --> 00:52:45,880
0,360 360,480 480,780 780,960 960,1380
using the last {checkpoint -}
使用最新的检查点状态，

1387
00:52:45,880 --> 00:52:47,620
0,480 930,1290 1290,1440 1440,1560 1560,1740
state,| and in some ways,
|在某些方面，这是 MapReduce 非常自然的设计，

1388
00:52:47,620 --> 00:52:48,760
0,120 120,240 240,600 600,810 810,1140
this is a very natural

1389
00:52:48,760 --> 00:52:50,680
0,570 630,810 810,1110 1110,1410 1410,1920
design for {MapReduce -},| because
|因为一切都是确定性的，

1390
00:52:50,680 --> 00:52:52,570
0,360 360,480 480,1080 1290,1620 1620,1890
everything is {deterministic -},| there's
|这里没有，

1391
00:52:52,570 --> 00:52:55,120
0,570 930,1560 1590,1770 1770,2310 2310,2550
no,| {} the coordinator really
|coordinator 没有那么多的状态要保持，

1392
00:52:55,120 --> 00:52:56,170
0,300 300,450 450,570 570,750 750,1050
doesn't have that much state

1393
00:52:56,170 --> 00:52:56,980
0,90 90,360 360,510 510,570 570,810
to hold,| all I need
|我所需要知道的是

1394
00:52:56,980 --> 00:52:57,970
0,90 90,270 270,480 480,780 780,990
to know is| which have
|哪些已经结束，哪些已经发生。

1395
00:52:57,970 --> 00:52:59,470
0,540 540,630 630,810 810,1050 1050,1500
finished and which has happened.|
|

1396
00:52:59,770 --> 00:53:01,020
0,840

1397
00:53:01,210 --> 00:53:02,860
0,390 390,600 600,870 870,1110 1110,1650
So you could use Raft
当然，你可以使用 Raft 来实现容错，

1398
00:53:02,890 --> 00:53:05,350
0,150 150,540 540,1050 1290,2040 2040,2460
of course to enable fault

1399
00:53:05,350 --> 00:53:08,020
0,510 510,660 660,1110 1860,2370 2400,2670
tolerance,| and have a set
|并拥有一组 coordinator ，

1400
00:53:08,020 --> 00:53:09,340
0,90 90,720 720,900 900,1020 1020,1320
of coordinators,| that all agree
|这些 coordinator 都同意之前的命令和当前状态，

1401
00:53:09,340 --> 00:53:11,650
0,480 750,1260 1290,1830 1830,2160 2160,2310
on the commands issued so

1402
00:53:11,650 --> 00:53:13,720
0,420 420,540 540,720 720,1200 1200,2070
far and the current state,|
|

1403
00:53:13,750 --> 00:53:15,100
0,660 690,840 840,990 990,1260 1260,1350
but in some ways, it
但在某些方面，这对 coordinator 来说有点过了，

1404
00:53:15,100 --> 00:53:16,750
0,210 210,300 300,630 630,1260 1260,1650
seems a little overkill for

1405
00:53:19,580 --> 00:53:21,950
0,510 510,660 660,1470 1950,2100 2100,2370
{} the coordinator,| for something
|对于更有状态的东西，

1406
00:53:21,950 --> 00:53:23,570
0,180 180,390 390,720 720,1050 1050,1620
that's more {stateful -},| it's
|比如键值存储或其他什么东西，

1407
00:53:23,780 --> 00:53:25,460
0,660 660,870 870,1080 1080,1410 1410,1680
like a key value store

1408
00:53:25,460 --> 00:53:27,020
0,60 60,390 390,1020 1020,1290 1290,1560
or something,| it's much more
|使用 Raft 要自然得多。

1409
00:53:27,020 --> 00:53:28,460
0,450 450,570 570,750 750,960 960,1440
natural to use a Raft.|
|

1410
00:53:30,400 --> 00:53:32,440
0,570 600,1140 1230,1470 1470,1680 1680,2040
{} So some other questions
所以关于 MapReduce 的其他一些问题，

1411
00:53:32,440 --> 00:53:33,940
0,150 150,270 270,840 840,1110 1110,1500
about {MapReduce -},| the shuffle
|shuffle 或组合器步骤，

1412
00:53:33,940 --> 00:53:35,590
0,180 180,540 540,660 660,1020 1110,1650
or combiner step,| when
|它在什么时候发生，它是做什么的，

1413
00:53:35,590 --> 00:53:36,460
0,150 150,240 240,630 630,720 720,870
does it happen and what

1414
00:53:36,460 --> 00:53:38,410
0,180 180,300 300,660 660,1200 1290,1950
does it do,| so combining
|组合就发生在 Map 函数应用之后，

1415
00:53:38,410 --> 00:53:40,120
0,150 150,690 720,1320 1320,1440 1440,1710
{} occurs like right after

1416
00:53:40,120 --> 00:53:41,260
0,60 60,270 270,600 600,1050 1050,1140
the Map functions applied,| for
|例如，组合特定单词的单词计数，

1417
00:53:41,260 --> 00:53:42,940
0,600 630,870 870,1350 1350,1470 1470,1680
example, in combining the word

1418
00:53:42,940 --> 00:53:44,710
0,480 480,690 690,930 930,1380 1380,1770
counts of a particular word,|
|

1419
00:53:44,830 --> 00:53:45,850
0,390 390,600 600,660 660,870 870,1020
because having a lot of
因为有很多条目，

1420
00:53:45,850 --> 00:53:47,320
0,450 450,810 900,1050 1050,1200 1200,1470
entries,| that you know like
|你可以把它们组合在一起，

1421
00:53:47,320 --> 00:53:49,870
0,330 330,1020 1650,1860 1860,2220 2370,2550
the one you could you

1422
00:53:49,870 --> 00:53:51,550
0,210 210,600 600,960 960,1140 1140,1680
know combine them,| and then
|然后将其写入中间文件，

1423
00:53:51,610 --> 00:53:53,050
0,420 420,930 930,1230 1230,1350 1350,1440
write only that to the

1424
00:53:53,050 --> 00:53:54,340
0,450 450,930
mediate file,

1425
00:53:54,750 --> 00:53:57,570
0,360 360,1080 1080,1530 1980,2340 2340,2820
{} intermediate file,| {} sorting
|排序在 reduce 时进行，

1426
00:53:57,570 --> 00:53:59,100
0,390 390,450 450,570 570,1020 1020,1530
occurs at the reduce,| after
|在 reducer 读取了 map 的所有输出之后。

1427
00:53:59,100 --> 00:54:00,270
0,420 420,540 540,990 990,1080 1080,1170
all the outputs of the

1428
00:54:00,270 --> 00:54:01,710
0,270 270,390 390,750 990,1320 1320,1440
map are read by the

1429
00:54:01,710 --> 00:54:02,860
0,600
reducer.|
|

1430
00:54:03,540 --> 00:54:05,070
0,630 630,840 840,960 960,1020 1020,1530
{} Let's see,| {} {is,successor,to}
让我们看看,|是否有 MapReduce 的后继者，

1431
00:54:05,070 --> 00:54:06,810
0,210 210,750 750,930 930,1140 1140,1740
{MapReduce -},| yeah, so actually,
|是的，我不是很熟悉，

1432
00:54:06,810 --> 00:54:08,460
0,390 390,660 660,990 990,1470 1470,1650
I'm not super familiar with

1433
00:54:08,460 --> 00:54:09,360
0,180 180,450 450,570 570,720 720,900
it,| but you can look
|但你可以看看比如 Google Cloud Dataflow ，

1434
00:54:09,360 --> 00:54:10,680
0,150 150,540 540,780 780,1110 1110,1320
at stuff like Google Cloud

1435
00:54:10,680 --> 00:54:13,440
0,330 330,870 1110,1740 2010,2190 2190,2760
{Dataflow -},| {} and other
|以及其他的有向图计算，

1436
00:54:13,440 --> 00:54:16,140
0,240 240,600 690,1380 1380,1740 1740,2700
sort of directed graph computations,|
|

1437
00:54:16,200 --> 00:54:18,450
0,870 900,1410 1410,1800 1800,2130 2130,2250
where inputs flow into a
在输入流入节点的情况下，

1438
00:54:18,450 --> 00:54:19,710
0,450 450,600 600,990 990,1110 1110,1260
node,| so you can think
|所以你可以把它想象成一张图，

1439
00:54:19,710 --> 00:54:20,610
0,90 90,300 300,630 630,720 720,900
of as graph,| and then
|然后它们可能会流向其他节点，

1440
00:54:20,610 --> 00:54:22,050
0,420 450,720 720,1020 1020,1320 1320,1440
they might flow out to

1441
00:54:22,050 --> 00:54:23,970
0,300 300,780 810,1110 1110,1380 1470,1920
other nodes,| and that node
|中间的节点执行 map 计算，

1442
00:54:23,970 --> 00:54:24,870
0,150 150,210 210,600 600,720 720,900
in the middle {[] -}

1443
00:54:24,870 --> 00:54:27,240
0,780 810,900 900,1320 1320,1620 1620,2370
performs for example map computation,|
|

1444
00:54:27,240 --> 00:54:29,340
0,150 150,600 600,1170 1170,1650 1830,2100
and produces intermediate data,| is
并产生中间数据，|然后发送到其他图中的 reducer ，

1445
00:54:29,340 --> 00:54:30,450
0,210 210,450 450,540 540,900 900,1110
then sent to other like

1446
00:54:30,480 --> 00:54:31,590
0,450 450,600 600,900 900,1020 1020,1110
{reducer -} that in the

1447
00:54:31,590 --> 00:54:33,810
0,390 540,1050 1050,1350 1350,1650 1650,2220
graph,| so it's a {}
|所以这是一种有趣的方式，

1448
00:54:34,420 --> 00:54:35,920
0,510 510,990 990,1200 1200,1380 1380,1500
interesting way,| it's like a
|是一种数据流的方式来思考 MapReduce 。

1449
00:54:35,920 --> 00:54:37,270
0,390 420,780 780,1020 1020,1170 1170,1350
data {dataflow -} way to

1450
00:54:37,270 --> 00:54:39,460
0,180 180,660 660,900 900,1680
think about {MapReduce -}.|
|

1451
00:54:39,900 --> 00:54:40,950
0,420 420,510 510,690 690,840 840,1050
And I'm sure that there's
我相信还会有其他的，

1452
00:54:40,950 --> 00:54:43,200
0,450 450,780 810,1020 1020,1410 1470,2250
others that,| I'm not []
|我不知道在哪里。

1453
00:54:43,200 --> 00:54:44,880
0,180 180,390 390,750 1230,1470 1470,1680
like that where.| I did,
|我知道，可能其中一个是 Spark ，

1454
00:54:44,880 --> 00:54:46,650
0,480 480,870 930,1350 1350,1590 1590,1770
{ -} one, maybe one

1455
00:54:46,650 --> 00:54:47,880
0,150 150,360 360,840 840,1050 1050,1230
of them Spark,| which we'll
|我们将在后面读到。

1456
00:54:47,880 --> 00:54:50,400
0,180 180,450 450,900
read later about.|
|

1457
00:54:52,700 --> 00:54:54,650
0,510 510,1080 1110,1440 1440,1740 1740,1950
Yeah, so, but I I
是的，但是我喜欢用图的方式来思考 MapReduce ，

1458
00:54:54,650 --> 00:54:56,120
0,480 570,870 870,1170 1170,1350 1350,1470
like the graph way of

1459
00:54:56,120 --> 00:54:57,770
0,300 300,720 720,870 870,1320 1350,1650
thinking about {MapReduce -},| because
|因为现在我们考虑的只是两步操作，

1460
00:54:57,770 --> 00:54:58,580
0,150 150,270 270,390 390,570 570,810
right now we're only really

1461
00:54:58,580 --> 00:55:00,980
0,270 270,600 600,780 780,1470 1620,2400
thinking about a two-step operation,|
|

1462
00:55:00,980 --> 00:55:02,270
0,270 270,360 360,660 690,1170 1170,1290
where it could actually be
在那里，它可能是很多很多步。

1463
00:55:02,270 --> 00:55:04,370
0,450 660,780 780,1140 1320,1770 1770,2100
like you know many many

1464
00:55:04,370 --> 00:55:05,360
0,570
steps.|
|

1465
00:55:06,260 --> 00:55:07,610
0,630 660,750 750,960 960,1140 1140,1350
{} Oh, yeah, then how
哦，是的，那么在实践中输入是如何划分的，

1466
00:55:07,610 --> 00:55:10,360
0,420 420,930 930,1440 1440,2010
input {partitioned,in} practice,| so,
|通常情况下，因为输入空间是特定于应用程序的，

1467
00:55:10,700 --> 00:55:12,560
0,450 450,1350
usually, because

1468
00:55:12,650 --> 00:55:14,240
0,210 210,570 570,1110 1110,1350 1350,1590
the input space is very

1469
00:55:14,240 --> 00:55:16,250
0,600 600,1110 1110,1260 1260,1620 1620,2010
application specific,| and output {space,is}
|并且输出空间也是特定于应用的，

1470
00:55:16,250 --> 00:55:18,770
0,300 300,870 870,1650 1680,2130 2130,2520
also application specific,| {} it's
|这是要由程序员来指定，

1471
00:55:18,770 --> 00:55:20,180
0,330 330,480 480,600 600,810 810,1410
really up to the programmer

1472
00:55:20,180 --> 00:55:23,390
0,300 330,1290 1680,1920 1920,2580 2580,3210
to specify,| {} there's sometimes
|有时会有自然划分，

1473
00:55:23,390 --> 00:55:25,020
0,1170
a

1474
00:55:30,050 --> 00:55:31,400
0,450 450,660 660,750 750,1050 1050,1350
natural division,| for example make
|比如做一个本地的矩阵计算，

1475
00:55:31,400 --> 00:55:34,310
0,480 750,1530 1590,1830 1830,2220 2220,2910
a local {} matrix computation,|
|

1476
00:55:34,310 --> 00:55:35,090
0,150 150,240 240,390 390,450 450,780
then you want to combine
然后你想把它们组合起来，等等，

1477
00:55:35,090 --> 00:55:36,770
0,300 330,720 840,1380 1380,1530 1530,1680
them or so on so

1478
00:55:36,770 --> 00:55:38,930
0,570 600,1140 1200,1650 1650,1860 1860,2160
forth,| {} or you could
|或者，如果它只是一个巨大的文档或巨大的文本文件，

1479
00:55:39,050 --> 00:55:40,010
0,210 210,510 510,690 690,870 870,960
if it's just like an

1480
00:55:40,010 --> 00:55:42,020
0,600 600,1260 1260,1440 1440,1620 1620,2010
enormous document or like enormous

1481
00:55:42,020 --> 00:55:44,090
0,300 540,1080 1110,1680 1740,1980 1980,2070
text text files,| you can
|你可以把它分成合理大小的工作，

1482
00:55:44,090 --> 00:55:45,050
0,210 210,450 450,540 540,720 720,960
just split it up into

1483
00:55:45,050 --> 00:55:46,100
0,120 120,390 390,660 660,780 780,1050
a reasonable size of work,|
|

1484
00:55:46,100 --> 00:55:47,690
0,150 150,300 300,450 450,780 930,1590
so you know like applying
所以应用 map 函数会[]，

1485
00:55:47,690 --> 00:55:48,890
0,90 90,330 330,750 750,1020 1020,1200
the map function is going

1486
00:55:48,890 --> 00:55:50,750
0,90 90,300 300,900 1050,1530 1530,1860
to take []| and also
|还取决于你的集群的大小，

1487
00:55:50,750 --> 00:55:52,010
0,390 390,750 810,930 930,1200 1200,1260
depends on the size of

1488
00:55:52,010 --> 00:55:53,090
0,150 150,660 660,780 780,930 930,1080
your cluster,| so how many
|你有多少 worker 。

1489
00:55:53,090 --> 00:55:54,200
0,360 360,480 480,720
workers you have.|
|

1490
00:55:54,590 --> 00:55:55,680
0,570

1491
00:55:57,300 --> 00:55:58,620
0,420 420,630 630,900 900,1080 1080,1320
So some further {MapReduce -}
还有一些关于 MapReduce 的问题，

1492
00:55:58,620 --> 00:56:00,990
0,750 1080,1320 1320,1440 1440,1980 1980,2370
questions,| why do {mapper,store} files
|为什么 mapper 在本地保存文件，

1493
00:56:00,990 --> 00:56:02,670
0,420 420,630 630,870 870,1020 1020,1680
locally,| so in the paper,|
|所以在这篇论文中，|

1494
00:56:02,700 --> 00:56:04,290
0,300 300,420 420,1200 1230,1380 1380,1590
this is because at that
这是因为在当时，网络带宽是他们的瓶颈，

1495
00:56:04,290 --> 00:56:06,510
0,270 270,390 390,720 720,1890 1890,2220
time, the network bandwidth was

1496
00:56:06,510 --> 00:56:08,960
0,210 210,1050
their bottleneck,|
|

1497
00:56:09,180 --> 00:56:10,200
0,240 240,360 360,480 480,690 690,1020
that's why they don't use
这就是为什么他们不使用 GFS ，

1498
00:56:10,200 --> 00:56:11,910
0,480 480,690 690,960 960,1200 1200,1710
GFS,| they only use GFS
|他们只使用 GFS 写入，

1499
00:56:11,910 --> 00:56:14,260
0,120 120,510 510,1170 1200,1770
to write the, {}|
|

1500
00:56:16,240 --> 00:56:17,470
0,360 390,570 570,840 840,930 930,1230
yeah, to write the output
是的，写入输出文件。

1501
00:56:17,470 --> 00:56:18,480
0,480
files.|
|

1502
00:56:18,760 --> 00:56:20,770
0,390 390,720 720,1410 1410,1560 1560,2010
Are leaders necessary for distributed
领导者是分布式系统所必需的吗，

1503
00:56:20,770 --> 00:56:24,140
0,630 720,1170 1170,1890 1920,2490
systems,| not necessarily, {}|
|不一定，|

1504
00:56:24,260 --> 00:56:26,360
0,990 990,1290 1290,1530 1530,1680 1680,2100
there, like, think of Bitcoin,
考虑比特币，其他去中心化系统，

1505
00:56:26,360 --> 00:56:28,070
0,240 240,570 570,1200 1200,1620 1620,1710
like other decentralized systems,| in
|其中所有节点都进行了竞争，

1506
00:56:28,070 --> 00:56:29,420
0,420 510,720 720,810 810,1140 1140,1350
which all the nodes sort

1507
00:56:29,420 --> 00:56:31,580
0,150 150,450 450,1020 1020,1410 1590,2160
of perform competition,| and some
|网络中的某个随机节点或某个节点，

1508
00:56:31,580 --> 00:56:32,750
0,330 330,690 690,840 840,1020 1020,1170
random node or like some

1509
00:56:32,750 --> 00:56:33,800
0,180 180,270 270,360 360,720 720,1050
node in the network| is
|负责提交它们，

1510
00:56:33,800 --> 00:56:35,570
0,570 570,930 960,1380 1380,1650 1650,1770
responsible for committing that,| so
|所以肯定有更平等主义的设计。

1511
00:56:35,570 --> 00:56:36,650
0,210 210,300 300,630 630,870 870,1080
there are definitely more like

1512
00:56:36,650 --> 00:56:38,540
0,780 780,1500
egalitarian designs.|
|

1513
00:56:38,910 --> 00:56:41,490
0,780 1170,1770 1770,1950 1950,2460 2460,2580
{} {Oh\,,yeah}, our challenge was|
哦，是的，我们的挑战是|

1514
00:56:41,490 --> 00:56:42,870
0,330 330,570 570,840 840,1080 1080,1380
actually to run {MapReduce -}
在不同的服务器上运行 MapReduce ，

1515
00:56:42,870 --> 00:56:44,910
0,360 450,810 810,1230 1230,1560 1560,2040
on like actual different servers|
|

1516
00:56:44,910 --> 00:56:47,730
0,330 330,900 1770,2040 2040,2550 2580,2820
rather than what we kind
而不是我们让你在实验里所做的，

1517
00:56:47,730 --> 00:56:48,660
0,210 210,450 450,540 540,810 810,930
of had you do in

1518
00:56:48,660 --> 00:56:51,090
0,90 90,600 1020,1650 1920,2310 2310,2430
the lab,| and so in
|所以，为了做到这一点，

1519
00:56:51,090 --> 00:56:52,020
0,180 180,360 360,480 480,750 750,930
order to do this,| like
|你需要，

1520
00:56:52,020 --> 00:56:53,040
0,150 150,630
you just,|
|

1521
00:56:53,040 --> 00:56:54,450
0,360 360,420 420,660 660,1260 1260,1410
instead of using sockets to
不是使用 sockets 来为 RPC 通信，

1522
00:56:54,450 --> 00:56:56,730
0,750 960,1350 1350,1890 1890,2070 2070,2280
communicate {} over for like

1523
00:56:56,730 --> 00:56:58,950
0,330 330,870 1110,1320 1320,1650 1680,2220
{RPCs -},| you would use
|你应该使用 TCP/IP ，

1524
00:56:58,950 --> 00:57:00,900
0,240 240,720 720,1170 1170,1740 1740,1950
like {TCP/IP -},| basically like
|正常地通过网络进行通信，

1525
00:57:00,900 --> 00:57:03,120
0,660 990,1740
normal, {}

1526
00:57:03,430 --> 00:57:05,380
0,330 330,600 600,810 810,1170 1170,1950
like over the network communication,|
|

1527
00:57:05,830 --> 00:57:07,720
0,540 540,750 750,1170 1410,1800 1800,1890
and you would use a
你可以使用像 GFS 这样的共享文件系统，

1528
00:57:07,720 --> 00:57:09,370
0,300 300,540 540,990 990,1230 1230,1650
shared file system like GFS,|
|

1529
00:57:09,370 --> 00:57:11,230
0,480 480,840 870,1320 1320,1470 1470,1860
so the [] I think
我认为你们所有人都可以访问 Athena ，

1530
00:57:11,260 --> 00:57:12,340
0,180 180,270 270,510 510,690 690,1080
all of you have access

1531
00:57:12,340 --> 00:57:13,870
0,150 150,660 780,1140 1140,1260 1260,1530
to Athena,| if at least
|至少在麻省理工学院，

1532
00:57:13,870 --> 00:57:16,240
0,210 210,900 930,1230 1230,1620 1770,2370
at MIT,| and you know
|ssh 到多台 Athena 机器，

1533
00:57:16,300 --> 00:57:17,740
0,420 420,690 690,810 810,1140 1140,1440
{ssh -} to multiple Athena

1534
00:57:17,740 --> 00:57:19,270
0,480 480,660 660,960 960,1050 1050,1530
machines,| and use {AFS -}
|并使用 AFS 文件共享系统，

1535
00:57:19,270 --> 00:57:21,970
0,210 210,570 960,1800 1830,2250 2310,2700
which is the file, shared

1536
00:57:21,970 --> 00:57:24,480
0,330 330,840 840,1470 1470,2010
{file,system},| {I,think} {Athena,uses} too,|
|我想 Athena 也用了，|

1537
00:57:24,950 --> 00:57:26,600
0,900 900,1050 1050,1170 1170,1500 1500,1650
basically, you can access your
基本上，你可以从任何机器访问你在 Athena 上的文件，

1538
00:57:26,600 --> 00:57:27,890
0,360 360,480 480,840 840,1080 1080,1290
files on Athena from any

1539
00:57:27,890 --> 00:57:30,530
0,510 1020,1590 1620,2310 2310,2430 2430,2640
machine,| {} similarly you could
|同样，你也可以通过租用 AWS 实例并使用 S3 来做同样的事情。

1540
00:57:30,530 --> 00:57:31,610
0,150 150,300 300,510 510,870 870,1080
do the same thing by

1541
00:57:31,610 --> 00:57:33,620
0,450 450,990 990,1620 1620,1740 1740,2010
rent AWS instances and using

1542
00:57:33,620 --> 00:57:36,890
0,210 210,720 1320,2010 2250,2850 3000,3270
{S3 -},| but we didn't
|但我们没想到你会花钱来运行我们的实验。

1543
00:57:36,890 --> 00:57:38,030
0,420 420,570 570,690 690,960 960,1140
expect you to spend any

1544
00:57:38,030 --> 00:57:40,100
0,330 330,810 930,1380 1380,1530 1530,2070
money to run our lab.|
|

1545
00:57:43,180 --> 00:57:44,620
0,330 330,540 540,840 840,1320 1320,1440
Right, so some questions that
好的，有一些问题，比如通用代码设计，

1546
00:57:44,620 --> 00:57:46,090
0,210 210,570 570,720 720,990 990,1470
came about, just like general

1547
00:57:46,090 --> 00:57:47,530
0,210 210,570 570,720 720,1110 1200,1440
code design,| so we've some
|所以我们也讨论了其中的一些，

1548
00:57:47,530 --> 00:57:48,790
0,120 120,360 360,540 540,1080 1080,1260
of these we've discussed as

1549
00:57:48,790 --> 00:57:51,460
0,420 840,1650 1770,2190 2190,2370 2370,2670
well,| so {lab,1} was pretty
|所以实验 1 很小，

1550
00:57:51,460 --> 00:57:53,140
0,600 630,990 990,1200 1200,1380 1380,1680
small,| lab 2 is going
|实验 2 将变得更大，

1551
00:57:53,140 --> 00:57:54,220
0,90 90,570
to be

1552
00:57:54,220 --> 00:57:56,290
0,420 420,960 990,1890 1890,1980 1980,2070
much larger,| especially as you
|尤其是当你进入后期阶段时，

1553
00:57:56,290 --> 00:57:57,460
0,120 120,180 180,300 300,570 570,1170
get to the later stages,|
|

1554
00:57:57,520 --> 00:57:59,710
0,870 1290,1650 1650,1890 1890,2070 2070,2190
and as lab 3 and
实验 3 和实验 4 也是一样。

1555
00:57:59,710 --> 00:58:00,670
0,210 210,420 420,570 570,840 840,960
lab 4 come along as

1556
00:58:00,670 --> 00:58:02,840
0,360 1020,1650
well.| And
|我个人觉得很方便的一件事是，

1557
00:58:02,990 --> 00:58:04,520
0,300 300,570 660,960 960,1110 1110,1530
one thing that I personally

1558
00:58:04,520 --> 00:58:06,020
0,330 330,600 600,1080 1080,1290 1290,1500
find very handy is,| just
|按其用途分隔不同的代码块，

1559
00:58:06,020 --> 00:58:07,300
0,720
separate

1560
00:58:07,300 --> 00:58:08,650
0,360 360,660 660,750 750,1170 1170,1350
different chunks of code by

1561
00:58:08,650 --> 00:58:11,180
0,210 210,960 1050,1980
their purpose,| so,
|在我如何实现代码的每一步时，

1562
00:58:11,330 --> 00:58:12,710
0,480 480,780 780,1080 1080,1200 1200,1380
{} and also in how

1563
00:58:12,710 --> 00:58:14,960
0,240 240,1200 1440,1740 1740,2040 2040,2250
I implement each step of

1564
00:58:14,960 --> 00:58:17,360
0,570 600,1230 1320,1740 1740,2250 2250,2400
my code,| so separating them
|所以把它们分开，

1565
00:58:17,360 --> 00:58:18,710
0,270 270,510 510,630 630,1140 1140,1350
out by,| for example {RPCs
|比如 RPC ，以及发送者和操作者，

1566
00:58:18,710 --> 00:58:20,960
0,810 810,1380 1470,1620 1620,2130 2130,2250
-} and the senders and

1567
00:58:20,960 --> 00:58:23,570
0,600 930,1380 1380,1650 1650,2160 2160,2610
handlers,| and feel free to
|可以自由地将它们物理地分开放在不同的文件中，

1568
00:58:23,570 --> 00:58:25,820
0,720 720,1110 1110,1290 1290,1650 1650,2250
actually separate these out physically

1569
00:58:25,820 --> 00:58:27,530
0,150 150,480 480,960 1080,1530 1530,1710
in different files,| {} that
|那不会，

1570
00:58:27,530 --> 00:58:29,300
0,420 570,990 1110,1410 1410,1650 1650,1770
won't,| like that's fine for
|这对测试来说也是可以的，

1571
00:58:29,300 --> 00:58:30,920
0,90 90,570 570,960 960,1350 1380,1620
a test,| and it will
|它可能会对你有所帮助，

1572
00:58:30,920 --> 00:58:33,320
0,420 420,660 660,1110 1500,2070 2160,2400
probably help you,| {} like
|不会在一个巨大的文件中有数千行代码。

1573
00:58:33,320 --> 00:58:34,550
0,210 210,450 450,840 840,960 960,1230
not have thousands of lines

1574
00:58:34,550 --> 00:58:36,020
0,60 60,390 390,480 480,900 930,1470
of code in one gigantic

1575
00:58:36,020 --> 00:58:36,820
0,450
file.|
|

1576
00:58:37,110 --> 00:58:38,280
0,630

1577
00:58:38,280 --> 00:58:39,960
0,510 510,1080 1080,1440 1440,1590 1590,1680
I I personally like to
我个人喜欢把所有状态的定义放在一起，

1578
00:58:39,960 --> 00:58:41,730
0,240 240,360 360,900 900,1020 1020,1770
put all definitions of state

1579
00:58:41,790 --> 00:58:45,030
0,630 630,780 780,1230 1320,2280 2520,3240
together,| and then functions are
|然后，函数是分开的，

1580
00:58:45,450 --> 00:58:46,710
0,240 240,450 450,540 540,1050 1050,1260
like sort of separate,| but
|但这是我的个人喜好，

1581
00:58:46,710 --> 00:58:48,540
0,300 300,480 480,810 810,1380 1380,1830
that's my personal preference, {}|
|

1582
00:58:49,910 --> 00:58:51,350
0,510 510,690 690,990 990,1320 1320,1440
factoring out common pieces of
将常见的代码片段分解为函数也将非常有用，

1583
00:58:51,350 --> 00:58:52,760
0,270 270,480 480,960 960,1080 1080,1410
code into functions will also

1584
00:58:52,760 --> 00:58:54,800
0,120 120,420 420,990 1020,1350 1350,2040
be very helpful,| for example
|例如你在 Raft 中的每个单独的 RPC ，

1585
00:58:54,830 --> 00:58:57,020
0,360 360,630 630,1470 1890,2070 2070,2190
every single RPC, you will

1586
00:58:57,020 --> 00:58:58,130
0,270 270,360 360,840 840,960 960,1110
get in Raft,| you need
|你需要检查过期的 term ，

1587
00:58:58,130 --> 00:58:59,330
0,60 60,300 300,480 480,720 720,1200
to check for stale term,|
|

1588
00:58:59,450 --> 00:59:01,520
0,750 810,1140 1140,1380 1380,1590 1590,2070
so putting all that logic,|
所以将所有的逻辑，|

1589
00:59:01,520 --> 00:59:02,870
0,180 180,600 600,1110 1110,1260 1260,1350
so that resets all the
把重置所有状态和所有东西

1590
00:59:02,870 --> 00:59:04,370
0,330 330,780 780,870 870,1290 1290,1500
state properly and everything| into
|放到你要调用的一个函数中，

1591
00:59:04,370 --> 00:59:05,510
0,360 360,720 720,810 810,960 960,1140
one function, that you just

1592
00:59:05,510 --> 00:59:08,540
0,540 810,1440 1470,2160 2160,2910 2910,3030
call,| will help,| because you
|将会有所帮助，|因为你不想不小心忘记

1593
00:59:08,540 --> 00:59:09,320
0,270 270,390 390,480 480,660 660,780
know you don't want to

1594
00:59:09,320 --> 00:59:11,660
0,390 390,750 750,1020 1230,1800 1800,2340
accidentally forget to| reset your
|重置选举定时器或重置 votedFor 或某些东西，

1595
00:59:11,690 --> 00:59:13,130
0,420 420,690 690,840 840,1050 1050,1440
election timer or like reset

1596
00:59:13,130 --> 00:59:15,660
0,360 360,690 690,1260 1590,2190
{votedFor -} {or,something}, {}|
|

1597
00:59:16,890 --> 00:59:18,060
0,330 330,450 450,840 840,1110 1110,1170
although you shouldn't reset the
虽然你不应该重置选举定时器，

1598
00:59:18,060 --> 00:59:19,020
0,300 300,510 510,600 600,780 780,960
election timer,| {} so don't
|所以不要那么做，

1599
00:59:19,020 --> 00:59:20,430
0,90 90,480 510,690 690,1110 1260,1410
do that,| that was an
|这只是我脑海中浮现的一个例子。

1600
00:59:20,430 --> 00:59:21,330
0,330 330,420 420,690 690,810 810,900
example I pulled off the

1601
00:59:21,330 --> 00:59:23,460
0,150 150,210 210,600 690,1530 1920,2130
top of my head.| And
|最后有一个好的环境，

1602
00:59:23,460 --> 00:59:25,230
0,540 570,1140 1140,1410 1410,1620 1620,1770
also finally have a good

1603
00:59:25,230 --> 00:59:27,210
0,720 720,1080 1080,1380 1380,1860 1860,1980
environment| with {like,autocomplete -} or
|比如 autocomplete 或者能够在代码中搜索某些关键字，

1604
00:59:27,210 --> 00:59:28,500
0,210 210,390 390,540 540,630 630,1290
like being able to search

1605
00:59:28,680 --> 00:59:30,000
0,300 300,600 600,1110 1110,1170 1170,1320
for certain keywords in your

1606
00:59:30,000 --> 00:59:31,170
0,360 360,510 510,660 660,960 960,1170
code,| and so forth can
|这样的事情会有很大帮助。

1607
00:59:31,170 --> 00:59:33,740
0,240 240,780 870,2100
help a lot.|
|

1608
00:59:33,770 --> 00:59:35,180
0,570 570,840 840,990 990,1200 1200,1410
So if you need any
所以如果你需要任何帮助来设置这个，

1609
00:59:35,180 --> 00:59:36,350
0,240 240,510 510,660 660,990 990,1170
help setting this,| like come
|可以在工作时间来，

1610
00:59:36,350 --> 00:59:37,760
0,90 90,360 360,840 840,1020 1020,1410
to office hours| or there's
|或者网上有大量的教程，

1611
00:59:37,850 --> 00:59:39,740
0,330 330,420 420,870 870,1470 1500,1890
tons of tutorials online,| you
|你可以找一个好的编辑器，

1612
00:59:39,740 --> 00:59:41,060
0,240 240,450 450,690 690,1110 1110,1320
can look up a good

1613
00:59:41,060 --> 00:59:43,310
0,570 840,1290 1440,1620 1620,1800 1800,2250
editor,| but it's not necessary,
|但这不是必要的，绝对不是必要的，

1614
00:59:43,310 --> 00:59:44,870
0,120 120,510 510,690 690,1290 1290,1560
it's definitely not necessary,| but
|但这可能会有所帮助。

1615
00:59:44,870 --> 00:59:46,370
0,150 150,450 480,840 840,1080 1080,1500
it could it does help.|
|

1616
00:59:48,020 --> 00:59:49,490
0,210 210,660 690,960 960,1170 1170,1470
And then, {oh,yeah}, so has
然后，是的，使用 Go 减少了学生花在调试上的时间，

1617
00:59:49,490 --> 00:59:50,960
0,180 180,630 630,1020 1020,1410 1410,1470
{using -} Go decrease the

1618
00:59:50,960 --> 00:59:52,280
0,180 180,270 270,480 480,870 870,1320
amount of time students spend

1619
00:59:52,280 --> 00:59:54,200
0,630 840,1110 1110,1320 1320,1530 1530,1920
debugging,| so I've never actually
|所以我从来没有用 C++ 实现过这些实验，

1620
00:59:54,200 --> 00:59:55,550
0,480 480,570 570,960 960,1140 1140,1350
implemented the {labs,in} {C++ -

1621
00:59:55,550 --> 00:59:57,080
0,360 360,540 540,900 900,1050 1050,1530
-},| but according to Frans,
|但根据 Frans 的说法，

1622
00:59:57,080 --> 00:59:57,800
0,330
like,|
|

1623
00:59:58,080 --> 01:00:01,110
0,510 690,1440 1470,2040 2070,2550 2550,3030
well, the one huge advantage
Go 的一个巨大优势是它的内存管理，

1624
01:00:01,110 --> 01:00:02,520
0,120 120,390 390,810 810,1080 1080,1410
of Go is its memory

1625
01:00:02,520 --> 01:00:05,070
0,780 990,1350 1350,1680 1680,2010 2010,2550
management,| so uses garbage collection,|
|使用垃圾收集，|

1626
01:00:05,070 --> 01:00:06,000
0,150 150,330 330,540 540,690 690,930
and don't have to deal
你不需要处理，

1627
01:00:06,000 --> 01:00:08,580
0,180 180,810 1080,1200 1200,1620 2280,2580
with,| like you know there
|这里有指针，

1628
01:00:08,580 --> 01:00:09,990
0,180 180,840 840,1140 1140,1260 1260,1410
are pointers,| but you don't
|但你不必像 C++ 那样处理它们，

1629
01:00:09,990 --> 01:00:10,650
0,90 90,180 180,420 420,540 540,660
have to deal with them

1630
01:00:10,650 --> 01:00:11,370
0,90 90,180 180,390 390,600 600,720
in the same way you

1631
01:00:11,370 --> 01:00:12,420
0,300 300,510 510,690 690,840 840,1050
would see your {C++ -

1632
01:00:12,420 --> 01:00:14,840
0,450 900,1380 1410,1620 1620,1980
-},| {} so like,
|我不知道你们中有多少人遇到了分段错误，

1633
01:00:14,930 --> 01:00:15,680
0,120 120,270 270,360 360,570 570,750
I don't know how many

1634
01:00:15,680 --> 01:00:17,060
0,90 90,210 210,390 390,630 630,1380
of you run into segfaults

1635
01:00:17,090 --> 01:00:18,860
0,270 270,630 630,960 990,1230 1230,1770
so far,| but I'm guessing
|但我猜你们中很少人，

1636
01:00:18,860 --> 01:00:19,910
0,360 360,570 570,630 630,810 810,1050
very few of you| or
|或者它们很容易修复，

1637
01:00:19,910 --> 01:00:20,870
0,120 120,300 300,570 570,810 810,960
they were very easy to

1638
01:00:20,870 --> 01:00:23,680
0,450 720,1530 1650,2340
fix,| and this
|这无疑使调试变得更容易，

1639
01:00:23,920 --> 01:00:25,540
0,660 660,960 960,1110 1110,1500 1500,1620
definitely makes it easier to

1640
01:00:25,540 --> 01:00:27,400
0,870 1020,1170 1170,1350 1350,1590 1590,1860
debug,| or they're just certain
|或者它们是你不需要担心的特定类型的 bug 。

1641
01:00:27,400 --> 01:00:28,240
0,300 300,390 390,630 630,720 720,840
types of bugs that you

1642
01:00:28,240 --> 01:00:29,320
0,180 180,330 330,480 480,780 780,1080
don't need to worry about.|
|

1643
01:00:30,710 --> 01:00:31,670
0,330 330,360 360,450 450,540 540,960
Sorry, I have a question.|
抱歉，我有个问题。|

1644
01:00:32,120 --> 01:00:33,620
0,480 600,990 990,1140 1140,1350 1350,1500
Yeah.| This is like a
好的。|这是一个 Go 的问题，

1645
01:00:33,620 --> 01:00:35,960
0,450 450,660 660,1140 1140,1590 1980,2340
more Go specific question, {}|
|

1646
01:00:35,960 --> 01:00:37,340
0,420 510,810 810,1140 1140,1260 1260,1380
but {} when you have
但当你有一个可以接受的函数时，

1647
01:00:37,340 --> 01:00:38,810
0,120 120,690 690,990 1050,1230 1230,1470
a function that can take

1648
01:00:38,810 --> 01:00:40,490
0,360 390,930 1110,1350 1350,1530 1530,1680
in,| {} let's say you
|假设你有一个 appendEntries 参数，

1649
01:00:40,490 --> 01:00:41,780
0,120 120,300 300,690 960,1140 1140,1290
have like a, you have

1650
01:00:41,780 --> 01:00:43,070
0,270 270,570 570,930 930,1200 1200,1290
a {appendEntries -} arg,| and
|而且你也有一个 requestVote 参数，

1651
01:00:43,070 --> 01:00:44,780
0,60 60,240 240,360 360,840 1110,1710
you also have like a

1652
01:00:44,960 --> 01:00:46,610
0,720 720,1020 1020,1350 1350,1590 1590,1650
{requestVote -} arg,| both of
|它们里面都有一个 term 变量，

1653
01:00:46,610 --> 01:00:47,990
0,120 120,330 330,450 450,900 900,1380
them have a term variable

1654
01:00:47,990 --> 01:00:49,430
0,690 720,990 990,1080 1080,1170 1170,1440
inside,| but when you pass
|但当你将其传递给函数时，

1655
01:00:49,430 --> 01:00:50,960
0,90 90,180 180,330 330,1020
it to a function,|
|

1656
01:00:50,960 --> 01:00:52,370
0,150 150,240 240,570 750,1260 1260,1410
how do you tell the
你怎么告诉这个函数，

1657
01:00:52,370 --> 01:00:53,450
0,360 360,570 570,690 690,930 930,1080
function,| that's like, hey I
|比如，我想要一个结构，它有一个 term 字段，

1658
01:00:53,450 --> 01:00:55,760
0,510 600,780 780,1350 1530,1980 1980,2310
expect a struct, that has

1659
01:00:55,760 --> 01:00:57,600
0,210 210,690 690,1320
a term field,|
|

1660
01:01:00,270 --> 01:01:02,000
0,120 120,300 300,1140
is that possible?|
这有可能吗？|

1661
01:01:02,200 --> 01:01:05,050
0,330 330,810 810,1860 1860,2100 2130,2850
So you define the types
所以，你定义了类型，

1662
01:01:05,050 --> 01:01:07,510
0,480 540,1170 1410,1890 1890,2190 2190,2460
right,| so it's like any
|它就像任何其他类型，

1663
01:01:07,510 --> 01:01:09,000
0,960
other

1664
01:01:09,090 --> 01:01:10,470
0,450 450,780 780,1050 1080,1260 1260,1380
type,| { -} when you
|当你传递到函数中时，

1665
01:01:10,470 --> 01:01:11,670
0,300 300,600 600,720 720,1080 1080,1200
pass into the function,| the
|函数需要特定类型的参数，

1666
01:01:11,670 --> 01:01:13,620
0,330 330,1050 1230,1410 1410,1860 1860,1950
function expects an argument of

1667
01:01:13,620 --> 01:01:15,160
0,120 120,570 570,1050
a particular type,|
|

1668
01:01:15,190 --> 01:01:16,930
0,540 540,900 930,1260 1260,1500 1500,1740
and {} that's type {}.|
这是类型。|

1669
01:01:17,050 --> 01:01:18,520
0,750 900,1110 1110,1290 1290,1410 1410,1470
Yeah.| Yeah, let's say I
嗯。|是的，假设我想在这两种类型之间共享一个函数。

1670
01:01:18,520 --> 01:01:19,840
0,210 210,300 300,630 630,960 960,1320
want to share one function

1671
01:01:19,840 --> 01:01:22,690
0,540 570,870 870,1530 2280,2430 2430,2850
across both types.| I believe
|我相信你可以使用 interface ，

1672
01:01:22,690 --> 01:01:24,250
0,150 150,330 330,510 510,630 630,1560
you can use an interface,|
|

1673
01:01:24,250 --> 01:01:26,220
0,450 450,510 510,750 750,1410
but I'm not sure.|
但我不确定。|

1674
01:01:26,570 --> 01:01:28,580
0,330 330,390 390,570 570,1140 1650,2010
So I tried to, but
所以我试过了，但当我做 .term 时，

1675
01:01:28,580 --> 01:01:29,810
0,180 180,270 270,450 450,780 780,1230
when I do {.term -},|
|

1676
01:01:29,810 --> 01:01:31,310
0,120 120,690 1080,1200 1200,1350 1350,1500
it says I don't know
它说我不知道这个字段，

1677
01:01:31,310 --> 01:01:32,930
0,330 330,900 1020,1200 1200,1440 1440,1620
this field| or like it
|或者它不存在。

1678
01:01:32,930 --> 01:01:34,490
0,180 180,600 1080,1230 1230,1440 1440,1560
doesn't exists.| I think you
|我想你需要转换它，

1679
01:01:34,490 --> 01:01:35,870
0,180 180,270 270,690 690,1020 1140,1380
need to convert it| or
|或者你需要转换，

1680
01:01:35,870 --> 01:01:37,640
0,150 150,300 300,840 1230,1650 1650,1770
you need to just {give,a}

1681
01:01:37,640 --> 01:01:39,050
0,540 540,660 660,810 810,1200 1230,1410
casting,| I can't remember,| but
|我想不起来了，|但有一种方法可以强制。

1682
01:01:39,050 --> 01:01:41,270
0,150 150,240 240,450 450,1110 1410,2220
there's a way to coerce.|
|

1683
01:01:41,570 --> 01:01:42,590
0,150 150,240 240,360 360,930 930,1020
You have to {type,cast} it
你必须对它进行类型转换，

1684
01:01:42,590 --> 01:01:43,850
0,450 450,540 540,660 660,810 810,1260
back,| you know to whatever
|到你想要访问的 struct 。

1685
01:01:43,850 --> 01:01:45,760
0,510 510,720 720,1440
struct you want

1686
01:01:45,760 --> 01:01:48,430
0,420 1140,1590 1590,1680 1680,2190 2190,2670
access.| Like you basically need
|比如你需要高数 Go ，

1687
01:01:48,430 --> 01:01:51,370
0,120 120,1200 1200,1860 2190,2640 2700,2940
to talk Go,| that by
|这个时间，我使用这个变量，

1688
01:01:51,370 --> 01:01:53,140
0,150 150,810 810,1050 1050,1530 1530,1770
the time, I actually use

1689
01:01:53,140 --> 01:01:54,610
0,210 210,840 840,1080 1080,1260 1260,1470
this variable,| it is of
|它是一种特定的类型。

1690
01:01:54,610 --> 01:01:56,160
0,180 180,690 690,1080
a particular type.|
|

1691
01:01:56,630 --> 01:01:57,890
0,270 270,510 540,780 780,990 1020,1260
Got it, thank you.| So
知道了，谢谢。|所以，如果你想对多个不同类型重复使用该函数，

1692
01:01:57,890 --> 01:01:58,910
0,300 300,570 570,750 750,840 840,1020
one thing if you want

1693
01:01:58,910 --> 01:02:00,230
0,120 120,510 510,630 630,1080 1080,1320
to reuse the function for

1694
01:02:00,230 --> 01:02:02,150
0,480 480,750 750,1260 1470,1680 1680,1920
multiple different types,| you can
|你可以传入一个接口，

1695
01:02:02,150 --> 01:02:03,920
0,360 360,480 480,600 600,1290 1320,1770
pass in an interface,| but
|但你可能还需要传递，

1696
01:02:03,920 --> 01:02:04,940
0,150 150,420 420,720 720,930 930,1020
you might also need to

1697
01:02:04,940 --> 01:02:07,120
0,360 360,630 630,750 750,1530
pass in,| for example,
|例如，比如某些东西来告诉它，

1698
01:02:07,120 --> 01:02:09,040
0,840 900,1350
{} like

1699
01:02:09,190 --> 01:02:10,960
0,480 480,690 690,990 990,1410 1410,1770
{} {you,know} more [] something

1700
01:02:10,960 --> 01:02:12,280
0,150 150,450 450,750 870,1080 1080,1320
that tells it,| like, hey
|嘿，这将是这种类型的，

1701
01:02:12,280 --> 01:02:13,000
0,180 180,270 270,480 480,540 540,720
this is going to be

1702
01:02:13,000 --> 01:02:13,930
0,240 240,540 540,630 630,840 840,930
this type,| and then you
|在使用它之前，需要将该接口转换为正确的类型。

1703
01:02:13,930 --> 01:02:15,550
0,120 120,210 210,570 570,750 750,1620
need to cast that interface

1704
01:02:15,670 --> 01:02:17,050
0,540 540,660 660,900 900,1110 1110,1380
into the right type, before

1705
01:02:17,050 --> 01:02:18,560
0,120 120,330 330,570
you use it.|
|

1706
01:02:19,540 --> 01:02:21,080
0,720
Okay.|
好的。|

1707
01:02:21,080 --> 01:02:21,950
0,60 60,210 210,270 270,600 600,870
I think the way people
我认为人们通常处理这件事的方式是，

1708
01:02:21,950 --> 01:02:23,150
0,240 240,480 480,720 720,870 870,1200
usually handle this is,| by
|通过在接口中放置 setter 和 getter ，

1709
01:02:23,810 --> 01:02:25,220
0,360 360,810 810,960 960,1350 1350,1410
putting setters and getters in

1710
01:02:25,220 --> 01:02:26,870
0,90 90,810 990,1170 1170,1290 1290,1650
the interface,| you don't actually
|你不知道它是哪种类型的，

1711
01:02:26,870 --> 01:02:28,970
0,240 240,510 510,1230 1290,1500 1500,2100
know which type it is

1712
01:02:29,000 --> 01:02:30,920
0,420 420,1170 1170,1290 1290,1500 1500,1920
in actuality,| you just access
|你只需使用接口访问变量。

1713
01:02:30,920 --> 01:02:33,300
0,210 210,780 810,1260 1260,1950
the variable using interface.|
|

1714
01:02:34,330 --> 01:02:35,300
0,420
Yeah.|
嗯。|

1715
01:02:36,940 --> 01:02:37,900
0,390

1716
01:02:38,260 --> 01:02:39,790
0,450 480,690 690,990 990,1230 1230,1530
Yeah, I don't think it,|
是的，我不这么认为，|

1717
01:02:40,120 --> 01:02:41,980
0,330 330,750 750,1320 1320,1620 1620,1860
you shouldn't need to use
你不应该在 Raft 中使用很多 interface ，

1718
01:02:41,980 --> 01:02:44,440
0,960 990,1260 1260,1530 1530,1740 1740,2460
interfaces that much in Raft,|
|

1719
01:02:44,440 --> 01:02:45,550
0,120 120,360 360,570 570,810 810,1110
I don't think I used
我不认为我使用了它，

1720
01:02:45,550 --> 01:02:46,420
0,150 150,300 300,630 630,780 780,870
it all,| other than the
|除了已经提供的命令。

1721
01:02:46,420 --> 01:02:49,360
0,630 750,1500 1530,1740 1740,2430
command which is provided.|
|

1722
01:02:49,670 --> 01:02:50,760
0,540

1723
01:02:53,410 --> 01:02:55,780
0,540 570,1140 1350,1470 1470,1950 1980,2370
Yeah, like, I guess factoring
是的，我想分解出常见的代码片段是很好的，

1724
01:02:55,780 --> 01:02:56,740
0,120 120,360 360,630 630,720 720,960
out common pieces of code

1725
01:02:56,740 --> 01:02:58,000
0,120 120,420 420,780 780,870 870,1260
is good,| unless it adds
|除非它增加了额外的复杂性，

1726
01:02:58,000 --> 01:02:59,820
0,450 450,1200
additional complexity,|
|

1727
01:03:00,330 --> 01:03:01,360
0,480

1728
01:03:02,220 --> 01:03:03,030
0,120 120,270 270,360 360,630 630,810
{} like I wouldn't try
我不会试着强迫你的类型，

1729
01:03:03,030 --> 01:03:05,730
0,240 240,690 690,1320 1680,2430 2430,2700
and force your types,| to
|为了所有都能够在相同的函数上运行，

1730
01:03:05,730 --> 01:03:07,470
0,780 780,900 900,1170 1170,1500 1530,1740
all be able to run

1731
01:03:07,470 --> 01:03:08,610
0,270 270,360 360,570 570,900 900,1140
on the same function,| like
|它可能是相似的类型，

1732
01:03:08,610 --> 01:03:09,870
0,60 60,450 450,720 720,840 840,1260
it might just be similar

1733
01:03:09,870 --> 01:03:12,270
0,270 390,840 840,1290 1290,1710 1710,2400
type,| two slightly different functions.|
|两个略有不同的函数。|

1734
01:03:13,150 --> 01:03:14,110
0,240 240,330 330,450 450,750 750,960
Or, if the only like
或者，如果你使用的唯一分享是 term ，

1735
01:03:14,140 --> 01:03:15,250
0,330 330,540 540,720 720,990 990,1110
shared piece you're using is

1736
01:03:15,250 --> 01:03:16,270
0,120 120,390 390,480 480,600 600,1020
the term,| you can have
|你可以有相同的函数只接受 term ，

1737
01:03:16,450 --> 01:03:17,950
0,120 120,390 390,810 810,1260 1260,1500
the same function taken just

1738
01:03:17,950 --> 01:03:19,150
0,60 60,480 480,750 750,990 990,1200
the term,| and in both
|在这两种情况下，都传入 struct 的 .term 。

1739
01:03:19,150 --> 01:03:20,860
0,450 450,960 960,1110 1110,1440 1440,1710
cases, {pass,in} the {.term -}

1740
01:03:20,860 --> 01:03:23,540
0,240 240,660 1050,1560 1560,1950
of the struct using.|
|

1741
01:03:27,020 --> 01:03:29,120
0,720 720,870 870,1620 1620,1830 1830,2100
Alright, some other code design
好的，还有其他代码设计问题吗？

1742
01:03:29,120 --> 01:03:33,740
0,720 1410,2070 2280,3000 3150,3570 3570,4620
questions?| {} Once when separating
|当将代码分成多个文件时，

1743
01:03:33,740 --> 01:03:35,870
0,180 180,600 600,1110 1110,1680 1680,2130
the code into multiple files,|
|

1744
01:03:35,870 --> 01:03:38,330
0,150 150,360 360,720 720,1950 2010,2460
is there naming conventional like
有没有按要求命名的惯例，

1745
01:03:38,330 --> 01:03:40,370
0,750 750,1290 1350,1620 1620,1740 1740,2040
required,| because when we make
|因为当我们做实验的时候，

1746
01:03:40,370 --> 01:03:41,480
0,150 150,540 570,690 690,990 990,1110
the lab,| it seems like
|它是复制源文件，

1747
01:03:41,480 --> 01:03:43,250
0,180 180,720 720,960 960,1410 1410,1770
it's copying the source file,|
|

1748
01:03:43,250 --> 01:03:44,240
0,150 150,270 270,450 450,630 630,990
so is there any naming
那么有没有什么命名约定呢？

1749
01:03:44,240 --> 01:03:45,680
0,780
convention?|
|

1750
01:03:46,060 --> 01:03:47,740
0,720 930,1080 1080,1350 1350,1470 1470,1680
{} I mean, I would
我的意思是，我会把它们放在 raft 文件夹中，

1751
01:03:47,740 --> 01:03:49,180
0,180 180,420 420,630 630,1260 1290,1440
put them in raft, the

1752
01:03:49,180 --> 01:03:51,310
0,300 300,990 1020,1590 1590,2010 2010,2130
raft folder,| but there's no
|但没有命名约定，

1753
01:03:51,310 --> 01:03:52,450
0,300 300,750 750,930 930,1050 1050,1140
naming convention,| like you can
|你可以随意地命名你的文件。

1754
01:03:52,450 --> 01:03:53,470
0,150 150,270 270,540 540,930 930,1020
name your files whatever you

1755
01:03:53,470 --> 01:03:54,960
0,420
want.|
|

1756
01:03:55,220 --> 01:03:57,140
0,450 870,1050 1050,1350 1350,1680 1680,1920
Okay, our grading scripts will
好的，我们的评分脚本将替换任何东西，

1757
01:03:57,140 --> 01:03:59,630
0,690 720,1200 1200,1410 1410,2130 2130,2490
replace anything,| that's necessary for
|属于测试框架的任何东西，

1758
01:03:59,630 --> 01:04:01,430
0,390 390,810 810,1200 1290,1740 1740,1800
or anything that belongs to

1759
01:04:01,430 --> 01:04:04,580
0,90 90,450 450,1200 1320,2250 2580,3150
the testing framework,| so the
|所以，配置文件或测试文件，

1760
01:04:04,610 --> 01:04:05,990
0,270 270,510 510,960 960,1170 1170,1380
{config -} file or like

1761
01:04:05,990 --> 01:04:07,910
0,120 120,420 420,1080 1200,1710 1710,1920
the test file,| anything that
|你在里面修改的任何东西都会被抹去。

1762
01:04:07,910 --> 01:04:09,140
0,180 180,480 480,600 600,930 930,1230
you change in there will

1763
01:04:09,140 --> 01:04:10,240
0,150 150,450 450,630
be wiped out.|
|

1764
01:04:10,720 --> 01:04:11,660
0,390

1765
01:04:12,540 --> 01:04:13,720
0,630
Yeah.|
嗯。|

1766
01:04:14,550 --> 01:04:16,440
0,540 570,900 900,1170 1170,1530 1530,1890
Like also be slightly careful
在使用外部依赖时也要稍加小心，

1767
01:04:16,440 --> 01:04:19,350
0,240 240,450 450,960 960,1860 2280,2910
about using external dependencies, {}|
|

1768
01:04:20,220 --> 01:04:21,420
0,330 330,570 570,810 810,930 930,1200
I ran into a couple
一些评分脚本，我遇到一些问题，

1769
01:04:21,420 --> 01:04:23,740
0,360 360,630 630,1260 1260,1740
issues with grading some

1770
01:04:23,740 --> 01:04:26,140
0,450 450,990 1080,1380 1380,1830 1830,2400
scripts,| {I,had} {} external dependencies,|
|我有外部依赖时，

1771
01:04:26,140 --> 01:04:28,690
0,330 360,930 930,1470 1500,1890 1890,2550
like using some github package,
比如使用一些 gitHub Go 包，

1772
01:04:28,720 --> 01:04:31,360
0,210 210,780 810,1680 1800,2340 2340,2640
Go package,| but those were
|但这些都是我能修好的，

1773
01:04:31,360 --> 01:04:32,530
0,270 270,420 420,630 630,930 960,1170
I was able to fix

1774
01:04:32,530 --> 01:04:33,430
0,210 210,510 510,660 660,720 720,900
it,| just be a little
|如果你这么做了，要小心一点。

1775
01:04:33,430 --> 01:04:34,600
0,510 540,660 660,780 780,870 870,1170
careful, if you do that.|
|

1776
01:04:35,130 --> 01:04:36,960
0,270 270,660 780,1230 1230,1350 1350,1830
But, yeah, create as many
但是，是的，创建你所需要的 .go 文件。

1777
01:04:36,960 --> 01:04:38,490
0,450 450,840 840,1080 1080,1380 1380,1530
.go files in raft as

1778
01:04:38,490 --> 01:04:40,600
0,90 90,570
you want.|
|

1779
01:04:40,660 --> 01:04:42,020
0,810

1780
01:04:42,110 --> 01:04:44,540
0,240 240,630 630,1080 1080,2010 2190,2430
Yeah, so pointer versus a
是的，所以指针和值比较，传递引用会更便宜，

1781
01:04:44,540 --> 01:04:46,370
0,510 510,960 960,1290 1290,1440 1440,1830
value, while passing by reference

1782
01:04:46,370 --> 01:04:48,200
0,240 240,360 360,900 930,1560 1560,1830
can be cheaper,| because Go
|因为 Go 不会复制那个 struct ，

1783
01:04:48,200 --> 01:04:50,090
0,390 390,600 990,1350 1350,1440 1440,1890
won't just copy the struct,|
|

1784
01:04:50,420 --> 01:04:51,840
0,270 270,480 480,930
{} this was,
这个问题被问到，

1785
01:04:52,020 --> 01:04:54,120
0,180 180,450 450,570 570,1260 1290,2100
this question was asked| in
|特别是为什么调用使用参数，

1786
01:04:54,150 --> 01:04:57,060
0,660 660,1320 1500,2010 2010,2340 2340,2910
particular for why call takes

1787
01:04:57,060 --> 01:04:58,830
0,510 540,1110 1110,1200 1200,1260 1260,1770
the arguments| and the reply
|而回复使用指针，

1788
01:04:58,830 --> 01:05:02,370
0,660 960,2010 2370,2670 2670,3240 3270,3540
as pointers,| and so yeah
|是的，这些可能是非常大的，

1789
01:05:02,370 --> 01:05:04,170
0,180 180,390 390,840 840,1320 1320,1800
those could be potentially extremely

1790
01:05:04,170 --> 01:05:05,340
0,390 390,540 540,720 720,900 900,1170
large,| and so Go doesn't
|所以 Go 不需要复制它们，当你调用函数时，

1791
01:05:05,340 --> 01:05:06,570
0,150 150,270 270,630 630,900 1050,1230
have to copy them, when

1792
01:05:06,570 --> 01:05:07,650
0,90 90,270 270,360 360,750 750,1080
you call the function,| that's
|这是主要原因。

1793
01:05:07,650 --> 01:05:09,480
0,120 120,300 300,780 1230,1560 1560,1830
the main reason.| {} Using
|可以同时使用锁和通道吗？

1794
01:05:09,480 --> 01:05:10,860
0,390 390,510 510,900 900,990 990,1380
{both,locks} and channels are possible?|
|

1795
01:05:10,860 --> 01:05:12,630
0,540 630,1260 1290,1500 1500,1680 1680,1770
Yes, {} you'll give them
是的，你可以在 Raft 中同时是因为它们，

1796
01:05:12,630 --> 01:05:14,580
0,180 180,240 240,720 1110,1770 1800,1950
both in Raft,| so you
|所以你肯定会看到这是如何可能的。

1797
01:05:14,580 --> 01:05:15,600
0,150 150,570 570,750 750,900 900,1020
will definitely see how it's

1798
01:05:15,600 --> 01:05:16,400
0,390
possible.|
|

1799
01:05:18,560 --> 01:05:19,400
0,150 150,390 390,570 570,720 720,840
Oh yeah, and then we're
哦，是的，然后我们收到了很多关于超时的问题，

1800
01:05:19,400 --> 01:05:20,270
0,210 210,300 300,480 480,540 540,870
getting a lot of questions

1801
01:05:20,270 --> 01:05:22,940
0,210 210,990 1020,1620 2160,2520 2520,2670
about timeouts,| {} so in
|所以在 MapReduce 实验里，

1802
01:05:22,940 --> 01:05:24,680
0,330 360,1080 1110,1230 1230,1440 1440,1740
map, in the {MapReduce -}

1803
01:05:24,680 --> 01:05:26,570
0,360 390,510 510,930 930,1650 1710,1890
lab,| the timeout {was,sort,of},| well,
|超时时间是，|我们给 worker 任务 10 秒钟时间，

1804
01:05:26,570 --> 01:05:27,470
0,90 90,270 270,480 480,600 600,900
we gave you a {}

1805
01:05:27,470 --> 01:05:29,150
0,240 240,750 750,1140 1170,1320 1320,1680
10 seconds for the worker

1806
01:05:29,150 --> 01:05:30,830
0,330 330,480 480,600 600,1020 1080,1680
tasks when they [],| but
|但对于睡眠时间来说，

1807
01:05:30,830 --> 01:05:31,760
0,60 60,300 300,510 510,720 720,930
in terms of how long

1808
01:05:31,760 --> 01:05:32,720
0,90 90,210 210,540 540,690 690,960
do you sleep,| and that
|可以选择其他的任何时间。

1809
01:05:32,720 --> 01:05:33,860
0,330 330,600 600,840 840,1050 1050,1140
were pretty much able to

1810
01:05:33,860 --> 01:05:35,460
0,270 270,570 570,840 840,1140
choose anything other that.|
|

1811
01:05:35,610 --> 01:05:37,170
0,570 570,1080 1080,1230 1230,1440 1440,1560
For Raft, you have to
对于 Raft ，你必须更仔细地选择超时，

1812
01:05:37,170 --> 01:05:38,190
0,390 390,660 660,780 780,840 840,1020
choose {timeout -} a little

1813
01:05:38,190 --> 01:05:40,440
0,120 120,780 810,1620
more carefully,| and
|我们的测试有点敏感，但不是非常敏感，

1814
01:05:40,530 --> 01:05:41,820
0,180 180,510 510,660 660,960 960,1290
our tests are like kind

1815
01:05:41,820 --> 01:05:43,350
0,90 90,690 690,900 900,1170 1170,1530
of sensitive, but not super

1816
01:05:43,350 --> 01:05:45,240
0,630 750,1110 1110,1440 1440,1590 1590,1890
sensitive,| like you'll be []
|例如，你可能[]，

1817
01:05:45,240 --> 01:05:46,830
0,120 120,660 660,1110 1110,1320 1320,1590
for example,| probably be within
|可能在 100 到 200 毫秒的范围内，

1818
01:05:46,830 --> 01:05:47,940
0,90 90,330 330,450 450,900 900,1110
a range of one to

1819
01:05:48,030 --> 01:05:50,220
0,840 840,1020 1020,1980 1980,2070 2070,2190
{100\,,to} {200,milliseconds -},| and be
|都是可以的。

1820
01:05:50,220 --> 01:05:52,120
0,450 600,1410
fine. {}|
|

1821
01:05:52,460 --> 01:05:53,760
0,780
Yeah,
是的，对选择它们来说，

1822
01:05:53,760 --> 01:05:55,230
0,510 510,660 660,900 900,1020 1020,1470
{} in terms of choosing

1823
01:05:55,230 --> 01:05:56,420
0,630
them,|
|

1824
01:05:57,160 --> 01:05:58,160
0,420

1825
01:05:58,470 --> 01:06:00,480
0,600 600,1230 1230,1530 1530,1830 1830,2010
probably helps to first think
可能会有帮助，先想想你为什么需要等待，

1826
01:06:00,480 --> 01:06:02,010
0,270 270,720 720,1050 1050,1410 1410,1530
about why you're waiting at

1827
01:06:02,010 --> 01:06:03,380
0,390
all,|
|

1828
01:06:03,440 --> 01:06:05,630
0,690 720,930 930,1410 1410,1560 1560,2190
and for example in the,
例如，对于 Raft ，

1829
01:06:05,930 --> 01:06:07,850
0,330 330,870 900,1290 1290,1740 1740,1920
for Raft,| your leader is
|你的领导者发送心跳，

1830
01:06:07,850 --> 01:06:09,300
0,240 240,960
sending heartbeat,|
|

1831
01:06:09,330 --> 01:06:11,310
0,420 420,570 570,1320 1530,1830 1830,1980
and your timeout is to
你的超时用来检测领导者停机，

1832
01:06:11,310 --> 01:06:12,750
0,480 480,720 720,840 840,1260 1260,1440
detect when the leader is

1833
01:06:12,750 --> 01:06:14,560
0,450
dead,|
|

1834
01:06:14,620 --> 01:06:16,000
0,810
so,
所以，你想给领导者几次机会

1835
01:06:16,000 --> 01:06:16,990
0,270 270,540 540,660 660,870 870,990
you kind of want to

1836
01:06:16,990 --> 01:06:18,220
0,210 210,300 300,720 720,870 870,1230
give the leader a couple

1837
01:06:18,220 --> 01:06:19,660
0,510 510,600 600,900 900,1170 1170,1440
chances| to tell you that
|告诉你它还活着，

1838
01:06:19,660 --> 01:06:22,690
0,150 150,780 900,2100 2490,2640 2640,3030
it's alive,| otherwise you know
|否则你会一直认为它已经死了，

1839
01:06:22,810 --> 01:06:24,340
0,240 240,480 480,1200 1200,1350 1350,1530
you'll just continuously think it's

1840
01:06:24,340 --> 01:06:26,860
0,360 570,1440 1740,2190 2190,2340 2340,2520
dead,| so depending on what
|所以，根据你设置的心跳超时，

1841
01:06:26,860 --> 01:06:28,390
0,120 120,390 390,510 510,1020 1020,1530
you set your heartbeat timeout

1842
01:06:28,390 --> 01:06:29,710
0,120 120,510 600,840 840,990 990,1320
to be| or your heartbeat
|或者你的心跳间隔，

1843
01:06:29,710 --> 01:06:31,060
0,420 420,540 540,930 1050,1260 1260,1350
interval to be,| which I
|我认为这会给你一些指导，

1844
01:06:31,060 --> 01:06:31,660
0,150 150,240 240,360 360,450 450,600
think will give you some

1845
01:06:31,660 --> 01:06:32,680
0,480 480,600 600,720 720,900 900,1020
guidelines of,| it can't be
|它每秒不可能超过十次，或者类似的东西，

1846
01:06:32,680 --> 01:06:33,730
0,300 300,480 480,600 600,780 780,1050
ten more than ten times

1847
01:06:33,730 --> 01:06:35,440
0,150 150,630 930,1080 1080,1290 1290,1710
per second or something like

1848
01:06:36,040 --> 01:06:37,000
0,510
that,|
|

1849
01:06:37,640 --> 01:06:38,840
0,480 480,720 720,960 960,1050 1050,1200
depending on what you set
取决于你设定的心跳，

1850
01:06:38,840 --> 01:06:40,400
0,150 150,540 540,1140 1170,1350 1350,1560
your {heartbeat -},| you'll want
|你会希望你的超时时间是合理的，

1851
01:06:40,400 --> 01:06:41,060
0,120 120,360 360,480 480,540 540,660
your {timeout -} to be

1852
01:06:41,060 --> 01:06:42,800
0,510 510,810 810,1140 1140,1500 1500,1740
something, like pretty reasonable,| like
|也许可以有机会得到两到三次心跳，

1853
01:06:42,800 --> 01:06:44,750
0,480 480,810 810,1230 1500,1710 1710,1950
maybe allow for the chance

1854
01:06:44,750 --> 01:06:45,440
0,90 90,300 300,420 420,540 540,690
to get two to three

1855
01:06:45,440 --> 01:06:47,690
0,210 210,690 1350,1530 1530,2010 2040,2250
{heartbeats -},| and then you'll
|然后你必须随机化一些范围，

1856
01:06:47,690 --> 01:06:49,490
0,150 150,240 240,1020 1020,1440 1440,1800
have to randomize some like

1857
01:06:50,000 --> 01:06:52,100
0,810 840,1500 1530,1740 1740,1860 1860,2100
range,| because you don't want
|因为你不想让你所有的服务器同时开始选举，

1858
01:06:52,100 --> 01:06:53,390
0,150 150,420 420,810 810,1080 1080,1290
all your servers start elections

1859
01:06:53,390 --> 01:06:55,340
0,180 180,270 270,510 510,990 1530,1950
at the same time,| and
|要做到这一点，你可以有一个范围，

1860
01:06:55,340 --> 01:06:56,840
0,120 120,270 270,600 600,720 720,1500
to do that, you can

1861
01:06:57,110 --> 01:06:58,070
0,120 120,270 270,450 450,600 600,960
you know like a range

1862
01:06:58,070 --> 01:06:59,080
0,510
of,|
|

1863
01:06:59,650 --> 01:07:01,320
0,780 780,1110
maybe like
可能有两到五次心跳，

1864
01:07:01,630 --> 01:07:04,900
0,450 450,870 870,1200 1200,1980 2610,3270
two to five heartbeats,| {some,timeout
|在这两者之间的某个超时时间是合理的，

1865
01:07:04,900 --> 01:07:07,030
0,210 210,600 600,990 1020,1410 1410,2130
-} between there is reasonable,|
|

1866
01:07:07,630 --> 01:07:09,460
0,330 330,450 450,750 750,1290
but in terms of
但是对于测试，

1867
01:07:09,460 --> 01:07:11,470
0,240 240,630 630,1260 1290,1650 1650,2010
the test,| you'll see whether
|你将看到是否发送了太多的 RPC ，

1868
01:07:11,470 --> 01:07:12,490
0,180 180,510 510,660 660,870 870,1020
you're sending too many {RPCs

1869
01:07:12,490 --> 01:07:14,290
0,630 900,1200 1200,1380 1380,1560 1560,1800
-}| or too many bits
|或者网络上传输的比特太多，

1870
01:07:14,290 --> 01:07:15,100
0,60 60,240 240,360 360,450 450,810
are going over the network|
|

1871
01:07:15,100 --> 01:07:17,620
0,390 390,510 510,1080
as the {test,go}
随着测试在后面的实验中，

1872
01:07:17,650 --> 01:07:19,270
0,180 180,450 450,1050 1170,1530 1530,1620
in later labs,| and you
|你可以很容易地调整你的超时时间，

1873
01:07:19,270 --> 01:07:20,500
0,150 150,390 390,540 540,990 990,1230
can tweak your timeout very

1874
01:07:20,500 --> 01:07:23,530
0,540 600,960 960,1470 1650,2430 2640,3030
easily,| {} it's slightly {}
|它稍微依赖于实现，

1875
01:07:23,530 --> 01:07:26,700
0,690 690,1380 1560,2610
implementation dependent,| so,
|所以，我不能告诉你最适合你的数字是多少，

1876
01:07:26,760 --> 01:07:28,140
0,270 270,540 540,720 720,1140 1140,1380
I can't tell you like

1877
01:07:28,140 --> 01:07:29,250
0,240 240,330 330,690 690,960 960,1110
what's the perfect number for

1878
01:07:29,250 --> 01:07:31,080
0,390 720,1170 1200,1530 1530,1680 1680,1830
you,| but thinking of it,
|但考虑，为什么我要超时，

1879
01:07:31,080 --> 01:07:32,340
0,90 90,390 390,600 600,1080 1080,1260
in terms of why am

1880
01:07:32,340 --> 01:07:33,600
0,90 90,510 510,900 1020,1170 1170,1260
I timing out in the

1881
01:07:33,600 --> 01:07:35,730
0,240 240,840 960,1410 1560,1890 1890,2130
first place,| and how many
|在超时之前，我希望其他服务器获得多少 RPC ，

1882
01:07:35,730 --> 01:07:36,570
0,150 150,510 510,570 570,660 660,840
{RPCs -} do I want

1883
01:07:36,570 --> 01:07:37,920
0,90 90,330 330,540 540,900 1020,1350
to get from like other

1884
01:07:37,920 --> 01:07:40,200
0,480 480,840 840,1440 1470,1950 1950,2280
servers before timeout,| is a
|是一个值得牢记的好的指标，

1885
01:07:40,200 --> 01:07:41,160
0,240 240,600 600,660 660,870 870,960
good metric to keep in

1886
01:07:41,160 --> 01:07:42,020
0,360
mind,|
|

1887
01:07:43,390 --> 01:07:44,860
0,930 930,1050 1050,1260 1260,1320 1320,1470
hopefully, that helps a lot
希望这对超时有很大帮助。

1888
01:07:44,860 --> 01:07:46,320
0,180 180,480 480,930
of {timeouts -}.|
|

1889
01:07:46,900 --> 01:07:48,400
0,660 660,930 930,1080 1080,1290 1290,1500
{} Okay, yeah, so some
好的，是的，所以一些实现的问题，

1890
01:07:48,400 --> 01:07:51,490
0,750 750,1470 1470,1920 2160,2790 2820,3090
implementation questions,| that {} came
|关于 MapReduce 实验，

1891
01:07:51,490 --> 01:07:52,990
0,300 330,870 870,960 960,1140 1140,1500
up about the {MapReduce -}

1892
01:07:52,990 --> 01:07:54,100
0,330 330,420 420,720 720,810 810,1110
lab,| and also the labs
|还有一般的实验。

1893
01:07:54,100 --> 01:07:55,340
0,90 90,690
in general.|
|

1894
01:07:55,400 --> 01:07:56,720
0,780
So,
所以，有些人实现了备份任务，

1895
01:07:56,970 --> 01:07:59,520
0,390 390,1050 1410,1890 1890,2130 2130,2550
some people actually did implement

1896
01:07:59,520 --> 01:08:00,750
0,360 360,630 630,810 810,990 990,1230
backup tasks,| which is pretty
|这是相当酷的，

1897
01:08:00,750 --> 01:08:01,860
0,360 360,540 540,660 660,960 960,1110
cool,| and we definitely did
|我们在这个实验中绝对不需要这样做，

1898
01:08:01,860 --> 01:08:03,390
0,210 210,630 630,1110 1170,1320 1320,1530
not require that for this

1899
01:08:03,390 --> 01:08:06,400
0,630 1020,1680 1890,2460
lab,| {} and
|我认为需要记住的重要一点是，

1900
01:08:06,650 --> 01:08:07,970
0,150 150,360 360,720 720,1020 1020,1320
I think something that was

1901
01:08:07,970 --> 01:08:09,020
0,450 450,540 540,720 720,840 840,1050
important to keep in mind

1902
01:08:09,020 --> 01:08:10,820
0,120 120,270 270,360 360,1020 1290,1800
is that,| the paper has
|论文对开始任务和重启任务做了区分，

1903
01:08:10,850 --> 01:08:13,400
0,270 270,330 330,1260 1320,2040 2070,2550
makes a distinction between starting,

1904
01:08:13,400 --> 01:08:15,140
0,600 600,690 690,1290
restarting a task,|
|

1905
01:08:15,140 --> 01:08:16,610
0,330 330,420 420,660 660,930 930,1470
because a worker has failed,|
因为一个 worker 失败了，|

1906
01:08:17,250 --> 01:08:18,400
0,570
and
并再次发布任务，

1907
01:08:18,660 --> 01:08:20,670
0,540 540,630 630,1020 1020,1620 1860,2010
issuing the task again,| to
|加快滞后任务的速度，

1908
01:08:20,670 --> 01:08:22,860
0,450 450,630 660,1020 1020,1560 1560,2190
speed up a lagging task,|
|

1909
01:08:22,860 --> 01:08:24,960
0,450 540,870 870,1110 1110,1470 1470,2100
that the worker hasn't failed,|
worker 并没有失败，|

1910
01:08:25,380 --> 01:08:26,730
0,420 450,630 630,930 930,1020 1020,1350
but you want the task
但是你希望更快地完成任务，

1911
01:08:26,730 --> 01:08:28,800
0,90 90,540 540,1200 1560,1920 1920,2070
to complete faster,| and so
|所以，备份任务用于落后者，

1912
01:08:28,800 --> 01:08:30,060
0,390 390,780 780,900 900,1140 1140,1260
backup tasks are used for

1913
01:08:30,060 --> 01:08:31,710
0,120 120,780 930,1200 1200,1500 1500,1650
the lagger,| when tasks are
|当任务还没有失败时，

1914
01:08:31,710 --> 01:08:33,750
0,330 330,600 600,930 930,1230 1230,2040
haven't failed yet,| but there's
|但是速度很慢并超时，

1915
01:08:33,750 --> 01:08:36,450
0,300 300,510 510,1080 1620,2010 2010,2700
there just slow and timeout,|
|

1916
01:08:36,820 --> 01:08:38,710
0,300 300,630 630,1080 1080,1410 1410,1890
we start task,| when workers
我们开始任务，|当 worker 检测到失败时。

1917
01:08:38,710 --> 01:08:40,240
0,150 150,420 420,870 870,960 960,1530
are actually detect to fail.|
|

1918
01:08:40,330 --> 01:08:42,340
0,630 630,810 810,930 930,1620 1620,2010
So when the paper,| the
所以，在论文中，|coordinator 从 worker 那里得到心跳，

1919
01:08:42,370 --> 01:08:44,500
0,600 600,930 930,1230 1230,1890 1890,2130
coordinator actually gets heartbeats from

1920
01:08:44,500 --> 01:08:47,320
0,90 90,720 840,1920 1980,2280 2280,2820
the workers,| whereas in the
|而在我们为你的实验提出的设计中，

1921
01:08:47,350 --> 01:08:48,760
0,390 390,540 540,690 690,1200 1200,1410
design that we propose for

1922
01:08:48,760 --> 01:08:50,500
0,270 270,780 900,1260 1260,1470 1470,1740
your lab,| we use {timeouts
|我们使用超时来检测 worker 可能出现失败，

1923
01:08:50,500 --> 01:08:52,270
0,270 270,750 750,840 840,1470 1500,1770
-} both to detect that

1924
01:08:52,270 --> 01:08:54,580
0,300 300,630 660,1200 1200,1740 1800,2310
worker has probably failed| and
|同时还检测缓慢的任务，

1925
01:08:54,580 --> 01:08:56,500
0,450 450,600 600,1080 1080,1350 1350,1920
also to detect slow tasks,|
|

1926
01:08:56,590 --> 01:08:58,330
0,690 720,900 900,1080 1080,1500 1500,1740
so in some ways, we
所以，在某些方面，我们没有这种区别，

1927
01:08:58,330 --> 01:08:59,620
0,240 240,570 600,780 780,1050 1050,1290
make that we don't have

1928
01:08:59,620 --> 01:09:01,600
0,150 150,900 1110,1410 1410,1590 1590,1980
that distinction,| we just assume
|我们只是假设，

1929
01:09:01,600 --> 01:09:02,980
0,480 510,660 660,870 870,1230 1230,1380
that,| if this task hasn't
|如果在这段时间内没有完成这项任务，

1930
01:09:02,980 --> 01:09:04,420
0,120 120,750 750,1050 1050,1260 1260,1440
been completed in this set

1931
01:09:04,420 --> 01:09:05,980
0,90 90,660 720,1290 1290,1380 1380,1560
of time,| that you know
|可能是 worker 失败了，

1932
01:09:05,980 --> 01:09:07,150
0,360 360,690 690,780 780,1050 1050,1170
like probably the worker has

1933
01:09:07,150 --> 01:09:08,050
0,330 330,390 390,600 600,690 690,900
failed| or maybe it's just
|或许它只是慢得让人抓狂，

1934
01:09:08,050 --> 01:09:09,760
0,480 480,810 810,930 930,1230 1230,1710
insanely slow,| and let's reissue
|让我们重新发布它，

1935
01:09:09,760 --> 01:09:11,890
0,240 480,810 810,990 990,1440 1470,2130
it,| so that's why {}
|这就是为什么我们的实验没有提到备份任务。

1936
01:09:12,370 --> 01:09:14,470
0,480 480,1170 1170,1470 1470,1740 1740,2100
our labs don't really mention

1937
01:09:14,470 --> 01:09:15,960
0,240 240,360 360,990
{backup -} tasks.|
|

1938
01:09:16,630 --> 01:09:19,480
0,1050 1170,1860 1860,2070 2070,2550 2580,2850
{} So, and then, yeah
所以，然后，是的，所以，这又回到了困惑，

1939
01:09:19,480 --> 01:09:20,740
0,180 180,630 630,840 840,930 930,1260
so there, this is again

1940
01:09:20,740 --> 01:09:21,850
0,180 180,390 390,480 480,540 540,1110
going back to the confusion,|
|

1941
01:09:21,850 --> 01:09:24,190
0,60 60,270 270,840 1170,1740 1770,2340
the next question, {} about
下一个问题，关于同步，

1942
01:09:24,340 --> 01:09:26,050
0,240 240,1140 1140,1230 1230,1320 1320,1710
like synchronization,| if the servers
|如果服务器位于不同的机器上，

1943
01:09:26,050 --> 01:09:27,070
0,150 150,300 300,570 570,930 930,1020
are on different machines,| so
|所以，服务器位于不同的计算机上，

1944
01:09:27,070 --> 01:09:28,840
0,60 60,510 750,1350 1350,1500 1500,1770
the servers are on different

1945
01:09:28,840 --> 01:09:31,270
0,540 570,990 990,1230 1230,1740 1740,2430
machines,| and they only communicate
|而且它们只使用 RPC 进行通信，

1946
01:09:31,270 --> 01:09:33,790
0,240 240,390 390,990 1080,1530 1530,2520
using {RPCs -},| all synchronization
|所有同步只是同步一台服务器上的线程，

1947
01:09:33,790 --> 01:09:35,920
0,210 210,450 450,1170 1170,1500 1500,2130
is just protecting or synchronizing

1948
01:09:35,920 --> 01:09:37,480
0,90 90,450 450,600 600,960 960,1560
the threads on one server,|
|

1949
01:09:38,080 --> 01:09:39,880
0,510 810,1110 1110,1260 1260,1350 1350,1800
I just want to emphasize
我只想再强调一次。

1950
01:09:39,880 --> 01:09:41,640
0,300 390,630 630,750 750,1110
that one more time.|
|

1951
01:09:43,190 --> 01:09:44,660
0,540 540,870 870,1110 1110,1260 1260,1470
{} Common source of race
通常的代码竞态条件，比如日志，

1952
01:09:44,660 --> 01:09:47,450
0,780 780,1230 1380,1590 1590,2040 2070,2790
conditions, just you know logging,|
|

1953
01:09:48,020 --> 01:09:49,540
0,810

1954
01:09:49,570 --> 01:09:50,560
0,420
I,
在某些方面我认为，

1955
01:09:50,880 --> 01:09:51,930
0,180 180,360 360,570 570,720 720,1050
in some ways I think,|
|

1956
01:09:51,930 --> 01:09:54,180
0,660 780,1470 1470,1740 1740,1920 1920,2250
{} someone's talking about,| like
有人在说，|什么时候使用锁，

1957
01:09:54,420 --> 01:09:55,080
0,150 150,270 270,480 480,570 570,660
you know how do you

1958
01:09:55,080 --> 01:09:56,130
0,120 120,390 390,510 510,930 930,1050
know when to lock,| and
|以及什么时候使用同步，

1959
01:09:56,130 --> 01:09:56,760
0,120 120,180 180,270 270,390 390,630
how do you know when

1960
01:09:56,760 --> 01:10:00,780
0,510 780,1500 1500,2310 2550,3180 3180,4020
to use synchronization,| so anytime
|所以，每当你修改文件的状态时，

1961
01:10:00,780 --> 01:10:03,150
0,270 270,930 930,1020 1020,1800 2010,2370
you're modifying the state of

1962
01:10:03,150 --> 01:10:05,070
0,780 900,1260 1260,1440 1440,1590 1590,1920
the file,| like your Raft
|比如 Raft 服务器或 coordinator ，

1963
01:10:05,070 --> 01:10:07,200
0,330 330,480 480,570 570,1410 1650,2130
server or the coordinator,| anytime
|任何时候你修改状态时，

1964
01:10:07,200 --> 01:10:09,020
0,120 120,600 600,720 720,1290
you modify the state,|
|

1965
01:10:09,020 --> 01:10:11,000
0,120 120,360 360,540 540,990 1410,1980
you want to lock,| and
你需要加锁，|你会注意到，

1966
01:10:11,030 --> 01:10:12,740
0,240 240,480 480,960 960,1140 1140,1710
what you'll notice is that,|
|

1967
01:10:13,960 --> 01:10:15,850
0,480 480,870 870,1170 1170,1710 1710,1890
for almost every function in
例如，对于你的 Raft 实现中的几乎每个函数，

1968
01:10:15,850 --> 01:10:18,220
0,510 540,930 930,1620 1620,1710 1710,2370
your Raft implementation, for example,|
|

1969
01:10:18,250 --> 01:10:20,260
0,420 420,600 600,1020 1020,1440 1470,2010
you will have a lock|
你会有一个锁，|

1970
01:10:20,260 --> 01:10:21,550
0,120 120,450 480,690 690,1140 1140,1290
and then a defer {unlock
然后在那之后，一个 defer unlock 。

1971
01:10:21,550 --> 01:10:22,990
0,330 330,570 570,780 780,1140 1140,1440
-}, like right after that.|
|

1972
01:10:23,940 --> 01:10:25,950
0,330 330,630 630,1050 1290,1770 1770,2010
The only time you need
你唯一需要确保你没有被锁的时候是，

1973
01:10:25,950 --> 01:10:26,730
0,90 90,300 300,510 510,630 630,780
to make sure that you're

1974
01:10:26,730 --> 01:10:28,050
0,300 300,780 810,990 990,1200 1200,1320
not lock is,| when you
|当你在可能阻塞的地方调用时，

1975
01:10:28,050 --> 01:10:28,800
0,150 150,240 240,510 510,600 600,750
make a call on might

1976
01:10:28,800 --> 01:10:31,230
0,570 720,1740 1770,2160 2160,2250 2250,2430
block,| so sending an {RPC
|所以，发送 RPC ，

1977
01:10:31,230 --> 01:10:34,380
0,870 990,1890 2100,2640 2640,2850 2850,3150
-},| {} you know sending
|通过通道发送一些东西，

1978
01:10:34,380 --> 01:10:36,690
0,330 330,570 570,1410 1710,2070 2070,2310
something over channel,| those type
|那些类型的操作，你不应该锁在那里，

1979
01:10:36,690 --> 01:10:38,160
0,90 90,780 780,900 900,1260 1260,1470
of operations, you shouldn't lock

1980
01:10:38,160 --> 01:10:39,780
0,240 240,570 570,750 750,1230 1320,1620
around,| because then you're, you're
|因为然后那个线程会被阻塞，

1981
01:10:39,780 --> 01:10:40,710
0,270 270,480 480,570 570,810 810,930
that thread will just be

1982
01:10:40,710 --> 01:10:42,150
0,390 390,480 480,750 870,1080 1080,1440
blocked on that,| and hold
|然后持有锁并停止服务器，

1983
01:10:42,150 --> 01:10:43,920
0,90 90,540 570,930 930,1650 1650,1770
the lock and stop the

1984
01:10:43,920 --> 01:10:45,210
0,540 540,840 840,1110 1110,1200 1200,1290
server,| any thread on the
|服务器上的任何线程都不会取得进展。

1985
01:10:45,210 --> 01:10:46,940
0,330 330,480 480,780 780,1380
server from making progress.|
|

1986
01:10:47,720 --> 01:10:49,310
0,690 750,1080 1080,1200 1200,1440 1440,1590
{} Yeah, and then there
是的，然后有一些问题，

1987
01:10:49,310 --> 01:10:50,720
0,150 150,420 420,840 840,1080 1080,1410
are some questions about like,|
|

1988
01:10:51,670 --> 01:10:53,680
0,360 360,510 510,720 720,1800 1800,2010
there are some {data,races} they're
有些数据竞争是良性的，

1989
01:10:53,680 --> 01:10:55,060
0,480 480,690 690,780 780,1260 1260,1380
benign,| like for example you
|例如，你可以设置 isDone 为 true ，

1990
01:10:55,060 --> 01:10:56,800
0,120 120,300 300,540 540,1080 1380,1740
could set {isDone -} to

1991
01:10:56,800 --> 01:10:58,510
0,120 120,630 630,1140 1290,1410 1410,1710
be true,| and you know
|你并不需要把对它加锁，

1992
01:10:58,510 --> 01:10:59,530
0,330 330,420 420,630 630,840 840,1020
like you don't really need

1993
01:10:59,530 --> 01:11:00,280
0,60 60,300 300,480 480,660 660,750
to lock around that,| but
|但是竞争检测器会抱怨，

1994
01:11:00,280 --> 01:11:01,810
0,90 90,330 330,720 720,840 840,1530
the race detector is complaining,|
|

1995
01:11:02,050 --> 01:11:03,820
0,750 960,1200 1200,1380 1380,1650 1650,1770
{} you could use an
你可以使用原子[]，

1996
01:11:03,820 --> 01:11:05,530
0,510 510,900 900,1320 1350,1620 1620,1710
atomic []| which has the
|它具有相同的行为，先锁定后解锁，

1997
01:11:05,530 --> 01:11:07,300
0,240 240,690 690,930 930,1290 1290,1770
same behavior, like locking before

1998
01:11:07,300 --> 01:11:09,020
0,720 720,1260
unlocking after,|
|

1999
01:11:09,580 --> 01:11:11,350
0,600 990,1290 1290,1410 1410,1560 1560,1770
but even though you might
但是，即使你认为这个数据竞争是良性的，

2000
01:11:11,350 --> 01:11:12,910
0,180 180,330 330,570 570,900 900,1560
think this data {race,is} benign,|
|

2001
01:11:13,060 --> 01:11:15,940
0,480 570,1020 1020,1830 1950,2610 2640,2880
it's undefined behavior,| so it
这是一种未定义的行为，|所以碰巧的是，最终下一次读取，

2002
01:11:15,940 --> 01:11:17,320
0,240 240,450 450,1080 1080,1320 1320,1380
just so happens, that you

2003
01:11:17,320 --> 01:11:19,360
0,180 180,990 990,1110 1110,1440 1440,2040
know eventually the next read,|
|

2004
01:11:19,660 --> 01:11:21,520
0,360 360,540 540,870 870,1290 1290,1860
like your read might miss
你的读取会忽略 isDone 的事实，

2005
01:11:21,550 --> 01:11:22,510
0,150 150,390 390,510 510,630 630,960
the fact, that {isDone -},|
|

2006
01:11:22,510 --> 01:11:23,230
0,150 150,210 210,450 450,600 600,720
but the next time you
但下次你调用 isDone 时，它会说是 true ，

2007
01:11:23,230 --> 01:11:24,310
0,270 270,450 450,870 870,990 990,1080
call {isDone -}, it will

2008
01:11:24,310 --> 01:11:25,570
0,360 360,750 750,870 870,1050 1050,1260
say true,| and then you're
|然后你就好了，

2009
01:11:25,570 --> 01:11:28,900
0,450 630,1680 1800,2280 2280,2880 2880,3330
fine,| but undefined behavior could
|但从技术上讲，未定义的行为可以实现为任何东西，

2010
01:11:28,900 --> 01:11:31,660
0,930 990,1290 1290,1860 1860,2070 2070,2760
technically be implemented as anything,|
|

2011
01:11:31,720 --> 01:11:33,130
0,300 300,420 420,780 780,990 990,1410
like it just so happens
比如碰巧你的编译器，

2012
01:11:33,130 --> 01:11:35,230
0,120 120,240 240,1080 1320,1860 1860,2100
that your compiler| and your
|你的处理器会做一些合理的事情，

2013
01:11:35,230 --> 01:11:37,450
0,450 450,600 600,930 930,1680 1740,2220
processor does something reasonable,| when
|当出现数据竞争时，

2014
01:11:37,450 --> 01:11:39,580
0,240 240,300 300,960 1080,1800 1950,2130
there's a {data,race},| so you
|所以你应该处理它们，特别是当它们很简单的时候，

2015
01:11:39,580 --> 01:11:40,870
0,120 120,420 420,720 720,1080 1080,1290
should handle them especially when

2016
01:11:40,870 --> 01:11:42,040
0,300 300,870
they're simple,|
|

2017
01:11:42,100 --> 01:11:43,360
0,510 510,720 720,810 810,1020 1020,1260
{} and they don't really
而且它们对性能的影响并不是很大。

2018
01:11:43,360 --> 01:11:45,680
0,690 690,1230 1230,1380 1380,1800
affect performance that much.|
|

2019
01:11:45,900 --> 01:11:48,520
0,330 330,660 660,1110 1320,2040
{} Another thing is,|
另一件事是，|

2020
01:11:48,550 --> 01:11:49,880
0,480
well,
嗯，在理论上，这种[]数据竞争，

2021
01:11:50,120 --> 01:11:52,400
0,600 810,1260 1260,1950 1950,2100 2100,2280
in in theory, you could

2022
01:11:52,400 --> 01:11:54,500
0,600 720,1170 1170,1410 1410,1680 1680,2100
have this like is {[],data}

2023
01:11:54,500 --> 01:11:56,210
0,420 420,810 810,1260 1260,1500 1500,1710
race,| could potentially mean that
|可能意味着你的进程永远不会退出，

2024
01:11:56,210 --> 01:11:58,490
0,570 690,1110 1110,1230 1230,1590 1590,2280
your process would never exit,|
|

2025
01:11:58,550 --> 01:12:00,560
0,990 1110,1350 1350,1440 1440,1620 1620,2010
because you know the write
因为写入到 isDone ，将它设置为 true ，

2026
01:12:00,560 --> 01:12:01,970
0,270 270,510 510,990 990,1290 1290,1410
to {isDone -}, setting it

2027
01:12:01,970 --> 01:12:03,950
0,120 120,660 750,1320 1320,1530 1530,1980
to true,| might ever actually
|可能会传播到正在读取的线程，

2028
01:12:03,950 --> 01:12:05,390
0,600 600,810 810,930 930,1170 1170,1440
propagate to the thread that's

2029
01:12:05,390 --> 01:12:07,610
0,600 630,1170 1380,1800 1800,1950 1950,2220
reading,| what whether it's true
|无论它是否为 true ，

2030
01:12:07,610 --> 01:12:08,720
0,120 120,420 420,900 900,990 990,1110
or not,| because it could
|因为它可以存储在某种缓冲区中，并且永远不会被刷新，

2031
01:12:08,720 --> 01:12:09,740
0,120 120,420 420,600 630,840 840,1020
be stored in some like

2032
01:12:09,740 --> 01:12:11,810
0,570 630,810 810,1080 1080,1620 1650,2070
buffer and never flushed,| what
|锁确保的是，

2033
01:12:11,810 --> 01:12:13,700
0,360 360,510 510,1170 1320,1500 1500,1890
locks {ensure -} is that,|
|

2034
01:12:13,700 --> 01:12:14,780
0,210 210,720
your write
你的写入，下一个读取的 isDone ，

2035
01:12:14,840 --> 01:12:16,310
0,540 540,750 750,1050 1050,1260 1260,1470
{} the next thread that

2036
01:12:16,310 --> 01:12:19,700
0,600 990,1290 1290,1980 2400,2790 2790,3390
reads is done,| will see
|将看到最新的写入 isDone ，

2037
01:12:19,700 --> 01:12:22,730
0,270 270,870 1620,2220 2220,2520 2520,3030
the last write {isDone -},|
|

2038
01:12:22,760 --> 01:12:23,990
0,270 270,390 390,720 720,1050 1050,1230
and {} actually flush it,|
并且刷新它，|

2039
01:12:23,990 --> 01:12:25,970
0,450 540,720 720,1350 1410,1590 1590,1980
from for example a potential
从写入可以保存的可能的缓存区中。

2040
01:12:25,970 --> 01:12:27,140
0,420 420,690 690,810 810,1020 1020,1170
buffer that the write could

2041
01:12:27,140 --> 01:12:28,340
0,150 150,720
be stored.|
|

2042
01:12:28,400 --> 01:12:30,980
0,570 870,1290 1290,1740 1740,1980 1980,2580
So, yeah, that's just emphasizing,|
所以，是的，这只是强调，|

2043
01:12:30,980 --> 01:12:32,840
0,390 600,780 780,990 990,1140 1140,1860
like you don't want {data,races},|
你不想要数据竞争，|

2044
01:12:32,840 --> 01:12:33,770
0,240 240,330 330,480 480,720 720,930
even if you think that
即使你认为它们很友好。

2045
01:12:33,770 --> 01:12:35,500
0,210 210,450 450,960
they're really friendly.|
|

2046
01:12:35,590 --> 01:12:37,630
0,870 900,1170 1170,1290 1290,1410 1410,2040
{} Clean way to exit?|
干净的退出方法？|

2047
01:12:38,230 --> 01:12:41,140
0,990 1260,1980 1980,2460 2460,2730 2730,2910
So sending an exit {RPC
所以，发送一个 exit RPC 从 coordinator 到 worker ，

2048
01:12:41,170 --> 01:12:43,810
0,360 360,540 540,1050 1050,1740 1890,2640
-} from {coordinator,to} worker, workers,|
|

2049
01:12:43,990 --> 01:12:45,960
0,360 360,660 660,1410
also like the
也像引号中的 Exit ，

2050
01:12:46,180 --> 01:12:48,490
0,420 420,570 570,1080 1080,1620 1620,2310
{quote,unquote} like messy Exit,| where
|worker 尝试发送 RPC ，

2051
01:12:48,610 --> 01:12:50,290
0,150 150,870 900,1320 1320,1410 1410,1680
the worker tries to send

2052
01:12:50,290 --> 01:12:51,790
0,180 180,810 810,960 990,1380 1380,1500
{RPCs -},| the socket is
|socket 已经关闭，

2053
01:12:51,790 --> 01:12:53,350
0,450 480,870 870,1140 1140,1290 1290,1560
closed,| like those are also
|这也是可以的，

2054
01:12:53,350 --> 01:12:54,720
0,840
fine,|
|

2055
01:12:54,720 --> 01:12:55,900
0,600

2056
01:12:56,080 --> 01:12:58,930
0,300 300,900 1050,1740 1740,2220 2400,2850
like most solutions are equally
大多数解决方案也是可以接受的。

2057
01:12:58,930 --> 01:13:01,260
0,720 1140,1770
acceptable. {}|
|

2058
01:13:01,780 --> 01:13:03,400
0,180 180,480 480,690 720,1350 1350,1620
And then {unexpected -} {EOF
然后是意外的 EOF 错误，

2059
01:13:03,400 --> 01:13:05,820
0,360 360,900 900,1860
-} errors,| so,
|所以，你可以看到，我在这里有一个链接，

2060
01:13:05,820 --> 01:13:06,900
0,150 150,420 420,690 690,900 900,1080
you can look I have

2061
01:13:06,900 --> 01:13:08,310
0,330 330,600 600,840 840,1050 1050,1410
a link here,| that it
|当它被客户端调用时它会显示，

2062
01:13:08,310 --> 01:13:09,510
0,330 330,540 540,720 720,1110 1110,1200
shows when it's invoked the

2063
01:13:09,510 --> 01:13:11,220
0,480 480,690 690,840 840,930 930,1710
client,| but it's a little
|但这让人有点困惑，在什么时候发生，

2064
01:13:12,390 --> 01:13:14,010
0,960 960,1110 1110,1230 1230,1410 1410,1620
confusing as to when that

2065
01:13:14,010 --> 01:13:15,300
0,270 270,630 630,780 780,930 930,1290
actually happens,| so I would
|所以我不会太担心，

2066
01:13:15,900 --> 01:13:16,860
0,300 300,510 510,720 720,840 840,960
not worry about it too

2067
01:13:16,860 --> 01:13:18,120
0,450 510,690 690,870 870,990 990,1260
much,| if any one has
|如果有人能观察到，

2068
01:13:18,120 --> 01:13:19,880
0,480 480,1110
insights into,|
|

2069
01:13:21,340 --> 01:13:23,260
0,690 1230,1380 1380,1500 1500,1710 1710,1920
{} if they got this
如果他们在一个非常奇怪的时刻得到这个错误，

2070
01:13:23,260 --> 01:13:24,940
0,420 420,540 540,660 660,1140 1170,1680
error at a very strange

2071
01:13:24,940 --> 01:13:26,260
0,450 450,870 900,1020 1020,1170 1170,1320
moment,| then we could look
|然后我们可以调查一下，

2072
01:13:26,260 --> 01:13:27,490
0,210 210,510 600,960 960,1080 1080,1230
into it,| but I think
|但我认为这对你的实现是非常具体的，

2073
01:13:27,490 --> 01:13:28,840
0,240 240,570 570,990 990,1140 1140,1350
it's very specific on your

2074
01:13:28,840 --> 01:13:29,680
0,450 450,570 570,600 600,690 690,840
implementation,| so I would have
|所以我必须专门看一下，

2075
01:13:29,680 --> 01:13:30,640
0,90 90,240 240,330 330,660 780,960
to look at that, in

2076
01:13:30,640 --> 01:13:32,230
0,720 1020,1200 1200,1290 1290,1530 1530,1590
particular,| but we got a
|我们有一堆问题是关于它的。

2077
01:13:32,230 --> 01:13:35,830
0,180 180,270 270,630 630,1080 2580,3600
bunch of questions {about,that}.| Yeah,
|是的，我想这就是出现的大多数问题，

2078
01:13:35,830 --> 01:13:37,990
0,180 180,450 450,600 600,1020 1020,2160
I think so that's basically

2079
01:13:38,080 --> 01:13:39,220
0,480 480,540 540,630 630,1020 1020,1140
most of the questions that

2080
01:13:39,220 --> 01:13:40,810
0,210 210,480 480,930 1230,1380 1380,1590
came up,| and I think
|我想现在如果你有任何关于 Go MapReduce 的问题，

2081
01:13:40,810 --> 01:13:41,740
0,360 360,570 570,660 660,780 780,930
now if you have any

2082
01:13:41,740 --> 01:13:44,020
0,480 480,870 870,960 960,1410 1440,2280
questions about you know Go,

2083
01:13:44,170 --> 01:13:45,970
0,360 390,1080 1080,1530 1560,1680 1680,1800
{MapReduce -}| or if you
|或者如果你想向工作人员询问实验的情况。

2084
01:13:45,970 --> 01:13:47,320
0,150 150,480 600,930 930,1110 1110,1350
want to ask staff about

2085
01:13:47,320 --> 01:13:48,660
0,360 420,1080
the labs.|
|

2086
01:13:48,930 --> 01:13:50,220
0,120 120,210 210,270 270,780 780,1290
I had a question about
我有一个关于干净退出方式的问题。

2087
01:13:50,220 --> 01:13:52,410
0,540 600,1230 1320,1830 1830,2070 2070,2190
{} the clean way to

2088
01:13:52,410 --> 01:13:53,640
0,630
exit.|
|

2089
01:13:53,870 --> 01:13:55,940
0,510 960,1560 1560,1680 1680,1890 1890,2070
{} So you're saying like
所以你说 Exit RPC ，

2090
01:13:55,940 --> 01:13:58,460
0,450 480,1230 1230,2130 2220,2430 2430,2520
something Exit RPC,| I was
|我只是想知道有没有，

2091
01:13:58,460 --> 01:13:59,390
0,150 150,450 450,600 600,780 780,930
just wondering if there were

2092
01:13:59,390 --> 01:14:00,530
0,240 240,450 450,600 600,780 780,1140
like,| if there was like
|是否有这种情况，

2093
01:14:00,650 --> 01:14:03,680
0,360 360,1140 1380,1710 1710,2070 2070,3030
a case,| where a worker
|worker 出于某种原因需要很长时间才能到达服务器，

2094
01:14:03,740 --> 01:14:05,060
0,300 300,600 600,930 930,1110 1110,1320
for some reason just takes

2095
01:14:05,060 --> 01:14:07,400
0,900 900,1170 1170,1440 1440,1950 1980,2340
a very long time to

2096
01:14:07,400 --> 01:14:08,750
0,270 270,390 390,960 960,1200 1200,1350
reach the server, right,| like
|服务器如何知道，

2097
01:14:08,750 --> 01:14:09,500
0,180 180,390 390,510 510,660 660,750
how like how does the

2098
01:14:09,500 --> 01:14:11,140
0,360 360,1170
server know,|
|

2099
01:14:11,170 --> 01:14:13,750
0,390 390,1020 1020,1230 1230,1800 2160,2580
like when to like {shutdown
比如什么时候关闭，

2100
01:14:13,750 --> 01:14:16,540
0,420 660,1110 1110,1830 2070,2370 2370,2790
-},| because, because because the
|因为 coordinator 在某个时候关闭，

2101
01:14:16,540 --> 01:14:17,980
0,630 630,960 960,1170 1170,1260 1260,1440
coordinator {shutdown -} at some

2102
01:14:17,980 --> 01:14:19,300
0,240 240,390 390,510 510,840 870,1320
point, {correct -},| when, when,
|当它说 done ， done 返回 true 时，

2103
01:14:19,330 --> 01:14:20,830
0,240 240,360 360,690 690,1050 1080,1500
when it says like done,

2104
01:14:20,830 --> 01:14:22,880
0,270 270,600 600,990 990,1560
when done returns true,|
|

2105
01:14:22,970 --> 01:14:24,980
0,720 960,1140 1140,1410 1410,1830 1830,2010
{} it {shutdown -} and
它关闭，停止回复 worker ，

2106
01:14:24,980 --> 01:14:26,810
0,270 270,420 420,810 810,1620 1620,1830
so it stops replying to

2107
01:14:26,810 --> 01:14:28,220
0,150 150,900
the workers,|
|

2108
01:14:28,280 --> 01:14:29,600
0,360 360,510 510,660 660,780 780,1320
{} how does it decide
它如何决定什么时候这样做，

2109
01:14:29,600 --> 01:14:30,830
0,450 450,570 570,810 810,1080 1080,1230
when to do that,| if
|如果它在等待 worker 自己关闭。

2110
01:14:30,830 --> 01:14:32,620
0,150 150,750 750,1320
it's waiting for,

2111
01:14:32,620 --> 01:14:35,620
0,270 270,1170 1530,2250 2370,2790 2790,3000
for workers to {shutdown -}

2112
01:14:35,620 --> 01:14:36,960
0,810
themselves.|
|

2113
01:14:37,570 --> 01:14:39,310
0,600 600,870 870,1110 1110,1320 1320,1740
Oh, so in this case,
哦，所以在这种情况下， coordinator 不会，

2114
01:14:39,310 --> 01:14:42,420
0,330 360,1350 1590,2520
the coordinator isn't,|
|

2115
01:14:42,540 --> 01:14:43,920
0,300 300,480 480,840 840,1110 1110,1380
oh I guess,| so send
哦，我想，|所以发送可能是个错误的词，

2116
01:14:43,920 --> 01:14:45,330
0,300 420,690 690,780 780,990 990,1410
is probably the wrong word,|
|

2117
01:14:45,360 --> 01:14:46,710
0,120 120,630 630,900 900,1230 1230,1350
the coordinator isn't waiting for
coordinator 不是在等待 worker 回复，

2118
01:14:46,710 --> 01:14:48,420
0,90 90,450 450,540 540,1110 1260,1710
the workers to respond,| the
|coordinator 没有回复 worker 的请求，

2119
01:14:48,450 --> 01:14:50,910
0,630 630,1140 1500,1980 1980,2310 2310,2460
coordinator is not sending it's

2120
01:14:50,910 --> 01:14:53,460
0,720 720,900 900,1440 1770,2340 2340,2550
replying to the request from

2121
01:14:53,460 --> 01:14:55,440
0,510 510,780 780,1320 1590,1890 1890,1980
workers,| with a, like the
|比如任务已经完成，请退出，

2122
01:14:55,440 --> 01:14:57,120
0,360 360,570 570,840 840,1140 1140,1680
task is done, please exit,|
|

2123
01:14:57,420 --> 01:14:59,160
0,210 210,570 570,1110 1260,1530 1530,1740
the worker isn't,| {} the
worker 不是，|coordinator 根本不是在等待 worker ，

2124
01:14:59,160 --> 01:15:00,810
0,540 540,780 780,1050 1050,1320 1320,1650
coordinator isn't actually {} waiting

2125
01:15:00,810 --> 01:15:01,740
0,120 120,240 240,540 540,630 630,930
for the workers at all,|
|

2126
01:15:01,770 --> 01:15:02,790
0,360 360,510 510,600 600,750 750,1020
and so in this case,|
所以，在这种情况下，|

2127
01:15:02,790 --> 01:15:05,100
0,90 90,720 720,900 900,1560 1560,2310
the coordinator could actually still
coordinator 仍然可以在 worker 之前退出，

2128
01:15:05,130 --> 01:15:06,900
0,390 390,630 630,750 750,1290 1350,1770
exit before the workers,| and
|并让 worker ，

2129
01:15:06,900 --> 01:15:08,700
0,270 270,360 360,840 840,1350 1380,1800
cause the workers to like,|
|

2130
01:15:09,300 --> 01:15:11,970
0,510 750,1320 1320,1650 1650,2340 2340,2670
{you,know} have a disconnected socket
出现套接字断开错误并退出。

2131
01:15:11,970 --> 01:15:13,780
0,480 480,660 660,1200
error and exit.|
|

2132
01:15:14,130 --> 01:15:15,600
0,450 450,870 870,870 870,1350 1350,1470
Yeah, I I guess, that
是的，我想我的问题是，

2133
01:15:15,600 --> 01:15:16,680
0,120 120,240 240,600 600,750 750,1080
was my question really,| like
|如果我可以的话，

2134
01:15:16,860 --> 01:15:18,630
0,270 270,630 660,1320 1410,1650 1650,1770
like if if it I

2135
01:15:18,630 --> 01:15:19,980
0,180 180,900
could though,|
|

2136
01:15:20,040 --> 01:15:23,130
0,780 780,1560 1830,2010 2010,2670 2670,3090
coordinator replying to workers, right,|
coordinator 回复 worker ，|

2137
01:15:23,130 --> 01:15:25,260
0,180 180,540 570,810 810,1320 1320,2130
that are like potentially like
可能在请求任务，

2138
01:15:25,290 --> 01:15:27,990
0,480 480,1140 1350,1770 1770,2070 2070,2700
asking for {} get task,|
|

2139
01:15:28,320 --> 01:15:30,600
0,510 510,780 780,1290 1290,1980 2010,2280
but what happens if the
但如果 worker 关机会发生什么，

2140
01:15:30,600 --> 01:15:32,940
0,420 420,810 810,1470 1710,1890 1890,2340
worker {shutdown -},| or sorry
|或者抱歉， coordinator 关闭，

2141
01:15:32,940 --> 01:15:34,920
0,120 120,720 720,1020 1020,1260 1260,1980
the coordinator {shutdown -},| before
|在它从 worker 获得 RPC 之前。

2142
01:15:35,070 --> 01:15:37,410
0,270 270,510 510,900 900,900 900,2340
it gets, {} {} get

2143
01:15:37,440 --> 01:15:39,240
0,120 120,330 330,780 780,1200 1200,1800
{} get task RPC from

2144
01:15:39,300 --> 01:15:40,420
0,150 150,750
the worker.|
|

2145
01:15:40,900 --> 01:15:41,890
0,240 240,420 420,510 510,750 750,990
Oh, then the next time
哦，那么下一次 worker 试图联系 coordinator 时，

2146
01:15:41,890 --> 01:15:43,390
0,270 270,660 660,960 960,1110 1110,1500
the worker tries to contact

2147
01:15:43,390 --> 01:15:44,680
0,60 60,600 600,750 750,1110 1110,1290
the coordinator,| the worker will
|worker 将看到连接已关闭，然后退出。

2148
01:15:44,680 --> 01:15:45,700
0,270 270,450 450,540 540,900 900,1020
see that the connection is

2149
01:15:45,700 --> 01:15:48,220
0,390 390,480 480,660 660,1140
closed and then exit.|
|

2150
01:15:48,340 --> 01:15:51,400
0,510 660,1080 1080,1290 1290,2070 2250,3060
Yeah.| That's as clean {}
嗯。|这是我们能得到的最干净的关闭了。

2151
01:15:51,400 --> 01:15:53,460
0,540 540,720 720,900 900,1380
shutdown as we'll get.|
|

2152
01:15:54,460 --> 01:15:55,420
0,420

2153
01:15:56,060 --> 01:15:57,770
0,1080 1080,1170 1170,1350 1350,1470 1470,1710
Essentially, I mean you could
基本上，我的意思是你可以想象，

2154
01:15:57,770 --> 01:15:59,420
0,540 540,960
imagine that,|
|

2155
01:15:59,480 --> 01:16:00,320
0,150 150,300 300,480 480,630 630,840
you know you could set
您可以将 worker 设置为 RPC 服务器，

2156
01:16:00,320 --> 01:16:01,940
0,180 180,420 420,900 900,1020 1020,1620
up the workers to be

2157
01:16:02,270 --> 01:16:03,620
0,450 450,990 990,1170 1170,1230 1230,1350
RPC servers,| then you would
|然后 coordinator 会发送这些，比如请退出，

2158
01:16:03,620 --> 01:16:04,850
0,390 390,570 570,630 630,1110 1110,1230
actually have the coordinator be

2159
01:16:04,850 --> 01:16:07,460
0,690 990,1140 1140,1560 1560,1980 2220,2610
sending {these -}, like please

2160
01:16:07,460 --> 01:16:08,510
0,360 360,450 450,750 750,930 930,1050
exit,| the coordinator will have
|coordinator 必须等待 worker 退出，

2161
01:16:08,510 --> 01:16:09,410
0,120 120,360 360,450 450,570 570,900
to wait for the workers

2162
01:16:09,410 --> 01:16:11,000
0,90 90,510 660,870 870,1050 1050,1590
to exit,| but it's not,|
|但它不是，|

2163
01:16:11,520 --> 01:16:13,340
0,720

2164
01:16:15,340 --> 01:16:16,480
0,330 330,540 540,810 810,990 990,1140
or it doesn't seem like
看起来你不会从中得到任何效用。

2165
01:16:16,480 --> 01:16:17,740
0,90 90,240 240,390 390,750 750,1260
you won't get any utility

2166
01:16:17,740 --> 01:16:19,620
0,510
{out,that}.|
|

2167
01:16:20,530 --> 01:16:22,720
0,540 810,2010
Thanks.| Yeah.|
谢谢。|嗯。|

2168
01:16:22,750 --> 01:16:24,190
0,570 600,930 930,1050 1050,1230 1230,1440
{} Kat, I see you
Kat ，我看到你举手了。

2169
01:16:24,190 --> 01:16:26,120
0,180 180,630 870,1440
have your hands.|
|

2170
01:16:26,240 --> 01:16:28,160
0,1020 1050,1380 1380,1590 1590,1710 1710,1920
Yeah, something that I was
是的，我想知道的是，

2171
01:16:28,160 --> 01:16:29,810
0,450 450,900 900,1260 1260,1440 1440,1650
wondering about is,| for the
|对于未来的实验室，我们允许有更多的文件，

2172
01:16:29,840 --> 01:16:31,040
0,420 420,750 750,870 870,960 960,1200
future labs, are we allowed

2173
01:16:31,040 --> 01:16:32,510
0,90 90,270 270,510 510,1110 1110,1470
to have more files,| {I,think}
|我认为在 MapReduce 实验中，

2174
01:16:32,510 --> 01:16:33,800
0,600 600,690 690,750 750,990 990,1290
explicitly in the {MapReduce -}

2175
01:16:33,800 --> 01:16:34,580
0,240 240,300 300,390 390,600 600,780
lab,| we were only supposed
|我们只有三个，

2176
01:16:34,580 --> 01:16:36,020
0,60 60,210 210,660
to have three,|
|

2177
01:16:36,700 --> 01:16:38,770
0,480 510,990 990,1380 1410,1710 1710,2070
and it didn't read something
它并没有读到像这样的东西，

2178
01:16:38,770 --> 01:16:39,970
0,120 120,180 180,360 360,750 810,1200
where it was like,| hey,
|嘿，你应该把你所有的东西都放在一个里面。

2179
01:16:39,970 --> 01:16:40,540
0,120 120,240 240,360 360,480 480,570
you should have all of

2180
01:16:40,540 --> 01:16:42,400
0,150 150,540 930,1410 1410,1500 1500,1860
your stuff contained in one.|
|

2181
01:16:43,540 --> 01:16:44,830
0,270 270,570 570,960 960,1140 1140,1290
Oh, yeah, so you can
哦，是的，你肯定可以添加更多的文件，

2182
01:16:44,830 --> 01:16:48,220
0,630 630,930 930,1110 1110,1680 2610,3390
definitely add more files,| that's
|我会鼓励你那样做，

2183
01:16:48,250 --> 01:16:50,320
0,600 750,900 900,1110 1110,1560 1560,2070
like I would almost encourage

2184
01:16:50,320 --> 01:16:52,240
0,960
that,|
|

2185
01:16:52,240 --> 01:16:53,560
0,510 510,660 660,780 780,930 930,1320
I, did we {say,that} about
我们有没有说过这个，关于 MapReduce ，

2186
01:16:53,560 --> 01:16:54,900
0,750
MapReduce,|
|

2187
01:16:55,160 --> 01:16:56,210
0,210 210,210 210,690 690,810 810,1050
I I don't, I can't
我不记得有没有。

2188
01:16:56,210 --> 01:16:58,970
0,420 420,690 690,2100 2130,2400 2430,2760
remember whether.| {What,you,saying\,,you} couldn't edit
|你说你不能编辑其他任何主文件，

2189
01:16:58,970 --> 01:17:00,110
0,210 210,300 300,420 420,690 690,1140
any of the other main

2190
01:17:00,110 --> 01:17:02,660
0,630 630,840 840,1020 1020,1260 1260,2550
files,| it like.| Yeah, {you,couldn't,edit,the,[]}.|
|它就像是。|是的，你不能编辑[]，是的。|

2191
01:17:02,750 --> 01:17:05,360
0,1170 1170,1740 1770,1890 1890,2340 2340,2610
yeah,| Okay, I misread that,
|好的，我理解错了，谢谢，

2192
01:17:05,360 --> 01:17:06,650
0,300 300,450 450,630 630,900 1080,1290
thanks,| this makes me feel
|这让我感觉好多了。

2193
01:17:06,650 --> 01:17:09,290
0,120 120,360 360,720 960,1590 1590,2640
a lot better.| Yeah, yeah,
|是的，但是带上你的代码肯定是有用的。

2194
01:17:09,780 --> 01:17:11,550
0,300 300,870 870,1200 1200,1500 1500,1770
but definitely like bring your

2195
01:17:11,550 --> 01:17:14,160
0,330 330,600 600,1170 1200,1830 2010,2610
code will be useful. {}|
|

2196
01:17:16,300 --> 01:17:17,590
0,270 270,390 390,570 600,1050 1050,1290
I have a question about
我有一个关于良性数据竞争的问题，

2197
01:17:17,590 --> 01:17:19,690
0,450 480,780 780,990 990,1590 1590,2100
the benign data races, {}|
|

2198
01:17:21,100 --> 01:17:22,420
0,150 150,390 390,750
I guess like,|
我想是这样的，|

2199
01:17:22,630 --> 01:17:24,220
0,300 300,780 780,1170 1170,1260 1260,1590
because sometimes there's for example
因为有时候比如 Raft ，

2200
01:17:24,220 --> 01:17:25,180
0,330 330,450 450,630 630,750 750,960
raft,| you just want to
|你只需要读取 Raft 服务器的当前状态，

2201
01:17:25,210 --> 01:17:27,040
0,300 300,480 480,780 780,1260 1380,1830
read the current state of

2202
01:17:27,040 --> 01:17:29,500
0,480 660,1050 1050,1380 1410,1770 1770,2460
the of the Raft server,|
|

2203
01:17:29,590 --> 01:17:32,350
0,600 720,1140 1140,1560 1830,2400 2400,2760
{} why would multiple write,
为什么多个线程写入和一个读取，

2204
01:17:32,380 --> 01:17:33,910
0,450 450,720 720,1050 1050,1230 1230,1530
multiple threads writing to it

2205
01:17:34,120 --> 01:17:35,890
0,180 180,390 390,810 840,1380 1560,1770
and one reading,| so why
|那么为什么对同一变量的读取和写入，

2206
01:17:35,890 --> 01:17:37,210
0,150 150,300 300,690 690,1200 1200,1320
would a {read,and} write to

2207
01:17:37,210 --> 01:17:38,830
0,90 90,420 420,1140 1170,1350 1350,1620
the same variable,| end up
|最终导致未定义的行为，

2208
01:17:39,520 --> 01:17:41,290
0,330 330,840 840,1260 1260,1470 1470,1770
cause undefined behavior,| because it
|因为它在写入之前或之后读取。

2209
01:17:41,290 --> 01:17:42,520
0,240 240,510 510,870 870,960 960,1230
read comes before or after

2210
01:17:42,520 --> 01:17:43,660
0,120 120,570
the write.|
|

2211
01:17:44,020 --> 01:17:45,300
0,690
So,
所以，有一件事可能会发生，

2212
01:17:45,330 --> 01:17:47,700
0,360 360,660 660,1080 1110,1560 1560,2370
one thing that can happen,|
|

2213
01:17:47,700 --> 01:17:50,130
0,840 870,1290 1290,1980 1980,2250 2250,2430
and most processors don't do
大多数处理器不会这样做，

2214
01:17:50,130 --> 01:17:52,060
0,510 540,1380
this,| but,
|但是，每次你有一个，

2215
01:17:52,660 --> 01:17:55,120
0,390 390,780 780,1050 1050,1590 1590,2460
every time you have a,|
|

2216
01:17:56,140 --> 01:17:57,850
0,300 300,480 480,900 990,1290 1290,1710
like so these any thread
比如，任何线程都可以在单独的核心上运行，

2217
01:17:57,850 --> 01:17:59,680
0,240 240,450 450,630 630,1410 1410,1830
can run on a separate

2218
01:17:59,680 --> 01:18:00,700
0,420
core,|
|

2219
01:18:00,700 --> 01:18:03,490
0,600 720,1380 1740,2070 2070,2340 2340,2790
{} and every core has
每个核心都有一个缓冲区，

2220
01:18:03,490 --> 01:18:06,340
0,720 750,1590 1740,2340 2340,2460 2460,2850
a buffer,| for the data
|对于它读取或写入的数据，

2221
01:18:06,340 --> 01:18:07,840
0,240 240,480 480,870 870,990 990,1500
that it's reading or writing,|
|

2222
01:18:08,470 --> 01:18:09,490
0,210 210,540 540,690 690,900 900,1020
or writing, I guess like
或者写入，我想是一个存储缓冲区，

2223
01:18:09,490 --> 01:18:11,020
0,90 90,330 330,810 870,1350 1350,1530
a store buffer,| so for
|所以，例如线程 1 可以向状态写入一个值，

2224
01:18:11,020 --> 01:18:13,420
0,810 810,1140 1140,1560 1560,1830 1830,2400
example thread 1 could write

2225
01:18:14,580 --> 01:18:16,920
0,270 270,900 900,1440 1440,1680 1680,2340
one value to the state,|
|

2226
01:18:17,280 --> 01:18:18,870
0,330 330,570 570,960 960,1380 1380,1590
and thread 2 could try
线程 2 可以尝试读取它，

2227
01:18:18,870 --> 01:18:20,310
0,150 150,360 360,630 810,1200 1200,1440
to read it,| {} or
|或者多个线程可以写入，

2228
01:18:20,310 --> 01:18:21,240
0,150 150,480 480,720 720,840 840,930
like multiple threads can be

2229
01:18:21,240 --> 01:18:24,540
0,510 1050,1710 1800,2220 2220,2700 2700,3300
writing,| and thread 1 without
|线程 1 没有使用锁，

2230
01:18:24,540 --> 01:18:26,820
0,180 180,570 570,780 780,1410 1500,2280
a lock,| so locks essentially
|锁会刷新缓冲区，

2231
01:18:26,820 --> 01:18:30,270
0,450 450,600 600,1170 2550,3120 3120,3450
flush the buffer,| without that
|而没有锁，

2232
01:18:30,270 --> 01:18:31,340
0,600
lock,|
|

2233
01:18:31,340 --> 01:18:33,230
0,360 360,750 750,1020 1020,1440 1590,1890
this write might just like
这个写入会永远停留在线程 1 的存储，

2234
01:18:33,230 --> 01:18:35,420
0,270 270,540 540,810 810,1620 1680,2190
stay in thread 1's, {like,store}

2235
01:18:35,420 --> 01:18:38,210
0,510 510,1140 1620,2190 2250,2490 2490,2790
for forever,| and the read
|而读取将永远不会返回更新值，

2236
01:18:38,210 --> 01:18:41,000
0,270 270,840 840,1530 1890,2580 2610,2790
will never return {} the

2237
01:18:41,000 --> 01:18:44,330
0,420 420,990 1320,2160 2190,2460 2460,3330
updated value,| so this behavior
|这种行为在实践中并不经常发生，

2238
01:18:45,100 --> 01:18:46,990
0,600 600,990 990,1320 1320,1440 1440,1890
doesn't quite happen in practice,|
|

2239
01:18:46,990 --> 01:18:48,850
0,150 150,360 360,600 600,1200 1200,1860
but it's an allowable behavior,|
但这是一种允许的行为，|

2240
01:18:48,880 --> 01:18:49,810
0,390 390,480 480,570 570,750 750,930
because you do not have
因为你拥有的并不多。

2241
01:18:49,810 --> 01:18:50,800
0,60 60,420
a lot.|
|

2242
01:18:51,240 --> 01:18:52,440
0,390 390,540 540,720 720,1050 1050,1200
Sorry, so what happens if
抱歉，如果写操作有锁会发生什么，

2243
01:18:52,440 --> 01:18:53,460
0,150 150,390 390,600 600,660 660,1020
the write has a lock,|
|

2244
01:18:53,460 --> 01:18:55,260
0,120 120,300 300,570 570,1260
but the read doesn't,|
但是读取没有，|

2245
01:18:55,380 --> 01:18:57,030
0,240 240,420 420,750 780,1140 1140,1650
like does the read always
比如，读取总是需要锁吗？

2246
01:18:57,030 --> 01:18:58,520
0,270 270,450 450,930
need a lock?|
|

2247
01:19:02,970 --> 01:19:05,360
0,1830
Yes,
是的，因为，我想是的。

2248
01:19:06,560 --> 01:19:08,220
0,1170
because,

2249
01:19:11,440 --> 01:19:12,860
0,630 630,840
{I,think} {of,it}.|
|

2250
01:19:13,970 --> 01:19:15,140
0,240 240,240 240,870 870,990 990,1170
I I googled a little
我用谷歌搜索了一下，

2251
01:19:15,140 --> 01:19:16,160
0,210 210,360 360,630 630,750 750,1020
bit,| and people are like,
|人们会想，是的，不要尝试无锁共享数据，

2252
01:19:16,160 --> 01:19:17,720
0,330 330,660 660,870 870,1080 1080,1560
yeah, don't, don't even try

2253
01:19:17,930 --> 01:19:20,060
0,390 390,1020 1320,1680 1680,1980 1980,2130
{lock-less -} share data,| but
|但我真的不明白为什么这会是个问题。

2254
01:19:20,060 --> 01:19:21,440
0,60 60,330 330,630 630,1080 1080,1380
I don't really understand why

2255
01:19:21,440 --> 01:19:22,550
0,180 180,330 330,450 450,540 540,1110
that would be a problem.|
|

2256
01:19:23,270 --> 01:19:25,120
0,420 420,510 510,780 780,1290
{So,it's}.| You could like.|
所以，它是。|你可能会。|

2257
01:19:25,490 --> 01:19:26,620
0,570
{Go,ahead}.|
继续。|

2258
01:19:27,140 --> 01:19:28,100
0,150 150,330 330,600 600,750 750,960
You could like be doing
你可能做一些假设事情是 true 的事情，

2259
01:19:28,100 --> 01:19:29,300
0,330 330,510 510,930 930,1050 1050,1200
something that assumes the thing

2260
01:19:29,300 --> 01:19:30,440
0,180 180,600 600,720 720,960 960,1140
was true,| and then like
|然后当你读取时，

2261
01:19:30,440 --> 01:19:31,790
0,120 120,270 270,690 720,1110 1110,1350
when you read,| it's not
|它还不是 true ，

2262
01:19:31,790 --> 01:19:33,410
0,330 330,600 600,990 1170,1470 1470,1620
actually true yet,| like there
|这里可能有多个事情，

2263
01:19:33,410 --> 01:19:34,850
0,240 240,360 360,780 780,1080 1080,1440
might be multiple things, right,|
|

2264
01:19:36,620 --> 01:19:37,490
0,180 180,420 420,510 510,720 720,870
that's why you don't want
这就是你为什么不对读取加锁。

2265
01:19:37,490 --> 01:19:39,060
0,90 90,360 360,660 660,1020
to lock this read.|
|

2266
01:19:39,340 --> 01:19:41,800
0,420 450,990 1110,1590 1590,2040 2040,2460
So the only time you
所以你能避免这个的机会是，

2267
01:19:41,800 --> 01:19:43,930
0,660 1020,1350 1350,1620 1620,1800 1800,2130
might be able to even

2268
01:19:43,930 --> 01:19:45,580
0,240 240,540 540,750 750,1290 1320,1650
get away with this is,|
|

2269
01:19:45,580 --> 01:19:47,140
0,300 300,660 720,1260 1260,1470 1470,1560
if you only read a
如果你只读取一个字，

2270
01:19:47,140 --> 01:19:49,990
0,660 660,1200 1470,2040 2130,2490 2490,2850
single word,| and that's all
|这就是线程所做的一切，

2271
01:19:49,990 --> 01:19:50,980
0,150 150,420 420,720 720,840 840,990
the thread does,| and it
|它不进行多次读取，

2272
01:19:50,980 --> 01:19:53,340
0,450 450,690 690,1290 1290,1890
never does multiple reads,|
|

2273
01:19:54,050 --> 01:19:55,430
0,180 180,300 300,540 540,840 870,1380
but I think you still
但我认为你还是有一些问题。

2274
01:19:55,430 --> 01:19:58,600
0,240 240,1020 1380,2070 2070,2730
have some issues with.|
|

2275
01:20:01,150 --> 01:20:02,860
0,270 270,330 330,750 780,1230 1230,1710
One of the other things
另一件事是，

2276
01:20:02,860 --> 01:20:05,230
0,750 1440,1680 1680,1830 1830,2100 2100,2370
is,| if you're reading more
|如果你读取多个数据，

2277
01:20:05,230 --> 01:20:06,400
0,120 120,330 330,600 600,690 690,1170
than one piece of data,|
|

2278
01:20:06,490 --> 01:20:07,720
0,270 270,390 390,480 480,750 750,1230
like if on one thread,
比如在一个线程上，你获取锁，分配 a ，分配 b ，

2279
01:20:07,720 --> 01:20:09,670
0,450 480,780 780,1170 1170,1620 1620,1950
you take lock, assign a

2280
01:20:09,670 --> 01:20:12,610
0,450 450,900 1020,1710 1710,2400 2640,2940
assign b,| another thread, it
|另一个线程，它没有获取锁，

2281
01:20:12,610 --> 01:20:14,290
0,330 330,510 510,600 600,1200 1230,1680
doesn't take a lock,| might
|可能会看到 b 的新值，

2282
01:20:14,290 --> 01:20:16,570
0,600 630,1290 1350,1890 1890,1980 1980,2280
see b, the new value

2283
01:20:16,570 --> 01:20:17,590
0,120 120,360 360,690 690,780 780,1020
of b,| before it sees
|在它看到 a 的新值之前，

2284
01:20:17,590 --> 01:20:18,610
0,60 60,180 180,540 540,660 660,1020
the new value of a,|
|

2285
01:20:18,790 --> 01:20:19,960
0,300 300,690 690,780 780,900 900,1170
the ordering that you messed
你弄乱了顺序，

2286
01:20:19,960 --> 01:20:20,650
0,150 150,360 360,450 450,540 540,690
up,| and so if you
|所以，如果你从一个变量中读取 term ，

2287
01:20:20,650 --> 01:20:23,590
0,210 210,510 810,1020 1020,1890 2700,2940
read like a term from

2288
01:20:23,590 --> 01:20:25,750
0,420 420,810 990,1320 1320,1530 1530,2160
one that, from one variable|
|

2289
01:20:25,750 --> 01:20:27,880
0,420 750,1200 1350,1740 1740,2010 2010,2130
and like whether not the
而领导者从另一个变量中读取，

2290
01:20:27,880 --> 01:20:29,620
0,270 270,390 390,660 660,1260 1560,1740
leader from another variable,| you
|你可能会读到一对根本不存在的值，

2291
01:20:29,620 --> 01:20:31,210
0,330 360,810 810,1080 1110,1500 1500,1590
might read a pair of

2292
01:20:31,210 --> 01:20:33,370
0,510 510,690 690,1020 1020,1410 1410,2160
values that never actually existed,|
|

2293
01:20:33,580 --> 01:20:34,760
0,720
because
因为没有保证，

2294
01:20:35,070 --> 01:20:36,780
0,240 240,450 450,450 450,900 900,1710
{there -} aren't the guarantees,|
|

2295
01:20:36,810 --> 01:20:38,130
0,630 660,870 870,960 960,1230 1230,1320
like when you're [] to
当你[]具体的系统时，

2296
01:20:38,130 --> 01:20:40,740
0,450 450,1170 1380,2130 2160,2490 2490,2610
concrete systems,| you need to
|你需要基于平台提供的保证来构建所有内容，

2297
01:20:40,740 --> 01:20:42,330
0,480 480,870 870,1140 1140,1350 1350,1590
build everything based off what

2298
01:20:42,330 --> 01:20:43,890
0,60 60,630 630,930 930,1050 1050,1560
the guarantees are the platform

2299
01:20:43,890 --> 01:20:45,360
0,600 600,810 810,1200 1200,1290 1290,1470
provides you,| and if you
|如果你不这么做，

2300
01:20:45,360 --> 01:20:47,010
0,300 300,870 870,1200 1200,1560 1560,1650
don't,| there's all kinds of
|有各种各样奇怪的边缘情况会让你不知所措，

2301
01:20:47,010 --> 01:20:48,780
0,540 540,780 780,1200 1200,1350 1350,1770
weird edge cases that can

2302
01:20:48,810 --> 01:20:51,360
0,330 330,480 480,930 1140,2070
throw you off,| and
|而且，是的。

2303
01:20:51,600 --> 01:20:52,640
0,660
yeah.|
|

2304
01:20:52,640 --> 01:20:53,540
0,300 300,420 420,600 600,810 810,900
Yes, so I think the
是的，所以我认为唯一能让你，

2305
01:20:53,540 --> 01:20:54,950
0,330 330,780 780,930 930,1260 1260,1410
only case in which you

2306
01:20:54,950 --> 01:20:56,960
0,150 150,690 1020,1410 1410,1800 1800,2010
can even,| like try to
|比如对此进行推理，

2307
01:20:56,960 --> 01:20:58,580
0,300 300,630 630,960 990,1260 1260,1620
reason about this,| is this,
|就是系统中只有一个字，

2308
01:20:58,730 --> 01:20:59,930
0,150 150,390 390,690 690,960 960,1200
is this there's only ever

2309
01:20:59,930 --> 01:21:02,450
0,450 450,750 900,1080 1080,1530 1680,2520
one like you know word

2310
01:21:02,450 --> 01:21:03,680
0,180 180,270 270,750 750,870 870,1230
in the system,| that you're
|你试图读写的，

2311
01:21:03,680 --> 01:21:04,730
0,270 270,600 600,750 750,930 930,1050
ever trying to read and

2312
01:21:04,730 --> 01:21:06,320
0,240 240,540 630,1110 1110,1440 1440,1590
write to,| as soon as
|只要你尝试写入或读取多个数据片段，

2313
01:21:06,320 --> 01:21:08,000
0,120 120,600 600,1200
you try to

2314
01:21:08,060 --> 01:21:11,270
0,480 480,660 660,930 930,2160 2460,3210
write or read multiple pieces

2315
01:21:11,270 --> 01:21:13,280
0,120 120,390 390,990 990,1320 1650,2010
of data,| then it's like
|如果没有锁，你就不能对任何事情进行推理。

2316
01:21:13,310 --> 01:21:14,240
0,180 180,420 420,480 480,780 780,930
you won't be able to

2317
01:21:14,240 --> 01:21:16,040
0,210 210,480 480,930 930,1260 1260,1800
reason about anything without locks.|
|

2318
01:21:17,480 --> 01:21:19,310
0,930 930,1050 1050,1170 1170,1440 1440,1830
Basically, if you want to
基本上，如果你想玩这个游戏，

2319
01:21:19,520 --> 01:21:20,630
0,300 300,570 570,660 660,930 930,1110
play games with this,| you
|你必须真正理解编译器，

2320
01:21:20,630 --> 01:21:22,610
0,300 300,690 780,1290 1290,1890 1890,1980
have to really understand the

2321
01:21:22,610 --> 01:21:24,680
0,930 930,1110 1110,1410 1440,1770 1770,2070
compiler,| the whole [] language
|整个[]语言和内存模型，

2322
01:21:24,680 --> 01:21:26,720
0,150 150,510 510,1110 1170,1380 1380,2040
and memory model,| the processor
|你正在使用的处理器，

2323
01:21:26,720 --> 01:21:28,550
0,150 150,750 750,990 1200,1590 1590,1830
you're using| and it's like
|比如内存一致性系统，

2324
01:21:28,580 --> 01:21:31,940
0,420 420,990 990,1620 2550,2910 2910,3360
memory consistency system,| it gets
|它变得极其复杂。

2325
01:21:31,940 --> 01:21:34,580
0,540 540,1170 1170,1770 1770,2190
{} complicated, incredibly [].|
|

2326
01:21:34,800 --> 01:21:35,880
0,270 270,420 420,630 630,990 990,1080
Yeah, it's also like, I
是的，这也是，我是说，这都是不确定的行为，

2327
01:21:35,880 --> 01:21:36,990
0,270 270,420 420,540 540,840 840,1110
mean this is all {undefined

2328
01:21:36,990 --> 01:21:38,160
0,240 240,630 630,840 840,1110 1110,1170
-} behavior,| so even if
|所以即使它现在起作用了，

2329
01:21:38,160 --> 01:21:39,990
0,120 120,360 360,870 1110,1590 1710,1830
it works now,| like you
|比如，我可以，有人可以编写一个新的编译器，

2330
01:21:39,990 --> 01:21:41,370
0,180 180,330 330,750 810,1140 1140,1380
know I could, someone could

2331
01:21:41,370 --> 01:21:42,810
0,180 180,510 510,630 630,1320 1320,1440
write a new compiler,| and
|然后整件事，

2332
01:21:42,810 --> 01:21:45,210
0,390 420,1380 1680,1920 1920,2130 2130,2400
then you're, like that's where

2333
01:21:45,210 --> 01:21:46,710
0,90 90,840 840,990 990,1200 1200,1500
the whole thing about,| like
|就像恶魔可以从你的鼻子飞出（http://catb.org/jargon/html/N/nasal-demons.html），

2334
01:21:46,710 --> 01:21:47,850
0,480 480,660 660,900 900,990 990,1140
demons can fly {out,of} your

2335
01:21:47,850 --> 01:21:49,890
0,510 510,870 1140,1290 1290,1620 1620,2040
nose,| like it can literally
|比如它可以做任何事情，如果你有数据的话，

2336
01:21:49,890 --> 01:21:50,820
0,180 180,660 660,750 750,840 840,930
do anything, if you have

2337
01:21:50,820 --> 01:21:51,870
0,60 60,300 300,540 540,900 900,1050
a data,| it's because like
|因为其他程序没有任何语义，

2338
01:21:51,870 --> 01:21:53,320
0,270 270,750 750,990
other programs like,
|

2339
01:21:53,320 --> 01:21:54,850
0,450 480,720 720,870 870,1380 1380,1530
doesn't have any semantic,| so
|所以我们可能导致疯狂，

2340
01:21:54,850 --> 01:21:57,160
0,120 120,570 780,1110 1290,1710 1710,2310
we can like go crazy,|
|

2341
01:21:57,580 --> 01:21:58,930
0,330 330,510 510,900 1080,1230 1230,1350
so I would I would
所以我不会冒险。

2342
01:21:58,930 --> 01:22:00,640
0,330 330,570 570,1140
not risk it.|
|

2343
01:22:01,860 --> 01:22:02,940
0,210 210,270 270,480 480,870 870,1080
Okay, it makes sense, thank
好的，理解了，谢谢。

2344
01:22:02,940 --> 01:22:03,880
0,300
you.|
|

2345
01:22:04,270 --> 01:22:05,560
0,450 450,690 690,930 930,1140 1140,1290
So, so even when we're
所以，即使当我们读取任何东西时，

2346
01:22:05,560 --> 01:22:07,630
0,570 570,1050 1080,1530 1530,1710 1710,2070
accessing like anything,| just reading,
|比如只是读取 Raft 服务器的状态，

2347
01:22:07,630 --> 01:22:09,310
0,390 390,570 570,840 840,1110 1110,1680
let's say {Raft,server -} state,|
|

2348
01:22:09,370 --> 01:22:10,570
0,150 150,300 300,750 750,1020 1020,1200
we should still wrap it
我们还是应该对它加锁。

2349
01:22:10,570 --> 01:22:12,060
0,330 360,510 510,960
in a lock.|
|

2350
01:22:12,280 --> 01:22:13,960
0,900 900,990 990,1140 1140,1350 1350,1680
Yeah.| It just gets annoying
是的。|有时候会很烦人，

2351
01:22:13,960 --> 01:22:15,040
0,600 600,810 810,870 870,960 960,1080
sometimes,| because you have to
|因为你必须，

2352
01:22:15,040 --> 01:22:16,000
0,420
like,|
|

2353
01:22:16,120 --> 01:22:18,370
0,960 960,1050 1050,1470 1470,1770 1770,2250
wrap the single read in
把单个读取放在 lock 和 unlock 之间，

2354
01:22:18,460 --> 01:22:19,930
0,180 180,450 450,540 540,1110 1110,1470
a lock and unlock,| but
|但我不确定[]。

2355
01:22:20,080 --> 01:22:21,540
0,150 150,330 330,690
I'm not sure

2356
01:22:21,770 --> 01:22:23,480
0,360 360,690 690,1110
like knows [].|
|

2357
01:22:24,540 --> 01:22:27,300
0,810 870,1170 1170,1440 1440,1890 1890,2760
{} That shouldn't happen super
这种情况不应该经常发生，

2358
01:22:27,300 --> 01:22:29,580
0,660
often,|
|

2359
01:22:29,640 --> 01:22:31,290
0,330 330,420 420,960 990,1500 1500,1650
like I mean, maybe if
我的意思是，也许如果你想确认你仍然是领导者，

2360
01:22:31,290 --> 01:22:32,190
0,120 120,300 300,420 420,540 540,900
you want to for example

2361
01:22:32,190 --> 01:22:33,690
0,240 240,420 420,690 690,1260 1290,1500
check you're {still,a} leader,| if
|如果你不退出或诸如此类的，

2362
01:22:33,690 --> 01:22:34,860
0,150 150,450 450,750 750,870 870,1170
you're not exit or something

2363
01:22:34,860 --> 01:22:37,020
0,150 150,450 1020,1620
like that,| but,
|但是，是的，我不是，

2364
01:22:40,500 --> 01:22:42,570
0,630 630,780 780,1200 1260,1680 1680,2070
yeah, I don't, like, I

2365
01:22:42,570 --> 01:22:43,680
0,420 420,510 510,570 570,930 930,1110
forget,| do you use like
|你是不是用原子布尔型表示杀死状态，

2366
01:22:43,680 --> 01:22:46,140
0,450 450,840 840,1470 1800,2100 2100,2460
atomic bools for like killed

2367
01:22:46,140 --> 01:22:47,900
0,540 540,630 630,1260
state for example,|
|

2368
01:22:49,440 --> 01:22:50,820
0,420 480,930 930,1050 1050,1200 1200,1380
that like you could use
你可以使用[]，

2369
01:22:50,820 --> 01:22:52,440
0,90 90,750 750,1020 1020,1470 1470,1620
a [],| which essentially is
|在访问它之前和之后，加锁和解锁，

2370
01:22:52,440 --> 01:22:54,060
0,300 330,750 750,870 870,1410 1410,1620
like locking and unlocking right

2371
01:22:54,060 --> 01:22:55,440
0,480 570,840 840,930 930,1110 1110,1380
before {accessing - -} it

2372
01:22:56,020 --> 01:22:57,400
0,120 120,270 270,810
and right after,|
|

2373
01:22:58,520 --> 01:22:59,500
0,540
but,
但是，是的，

2374
01:23:00,000 --> 01:23:01,260
0,660
yeah,|
|

2375
01:23:03,900 --> 01:23:07,200
0,660 1530,2010 2010,2580 2610,2880 2880,3300
I think you'll like having
我想在某些方面有非常粗粒度的锁，

2376
01:23:07,200 --> 01:23:08,490
0,120 120,270 270,570 570,990 990,1290
in some ways very {coarse-grain

2377
01:23:08,490 --> 01:23:10,200
0,210 210,600 600,840 840,1350 1350,1710
-} locks,| and knowing that
|知道你是唯一访问状态的那个，

2378
01:23:10,350 --> 01:23:11,580
0,450 450,540 540,750 750,900 900,1230
you're the only one touching

2379
01:23:11,580 --> 01:23:12,420
0,90 90,270 270,360 360,690 690,840
a piece of state,| will
|将在你对实现进行推理时变得非常方便。

2380
01:23:12,420 --> 01:23:13,500
0,600
become

2381
01:23:13,500 --> 01:23:15,150
0,450 450,1020 1020,1230 1230,1350 1350,1650
very handy as you reason

2382
01:23:15,150 --> 01:23:17,540
0,360 360,750 780,1380
about your implementations.|
|

2383
01:23:17,860 --> 01:23:19,300
0,330 330,630
Thank you.|
谢谢。|

2384
01:23:21,930 --> 01:23:22,950
0,420 420,510 510,600 600,690 690,1020
{} I have a question
我有一个关于通道的问题，

2385
01:23:22,950 --> 01:23:25,890
0,570 870,1260 1260,1830 1830,2490 2670,2940
about the channels,| so when
|所以当你制作一个通道时，

2386
01:23:25,890 --> 01:23:27,240
0,330 330,600 600,690 690,1200 1200,1350
you make a channel,| it's
|它只是在两个线程之间，

2387
01:23:27,240 --> 01:23:30,120
0,240 240,870 1020,1440 1440,2370 2400,2880
only between two threads, right,|
|

2388
01:23:30,120 --> 01:23:31,140
0,270 270,360 360,600 600,720 720,1020
or it can be between
或者它可以在多个线程之间，

2389
01:23:31,140 --> 01:23:33,120
0,390 390,750 750,930 930,1590 1620,1980
multiple threads,| but like if
|但是如果你没有缓冲，

2390
01:23:33,120 --> 01:23:35,010
0,540 600,1320 1320,1410 1410,1620 1620,1890
you not, if you don't

2391
01:23:35,010 --> 01:23:38,280
0,1170 1470,2190 2340,2490 2490,2760 2760,3270
have buffered,| it can potentially
|它可能会永远阻塞，

2392
01:23:38,280 --> 01:23:39,540
0,240 240,510 510,600 600,870 870,1260
just lock and block forever,

2393
01:23:39,540 --> 01:23:41,310
0,330 330,780 930,1290 1290,1650 1650,1770
right,| so, for example, if
|所以，比如，如果你想在 Raft 中做一件事，

2394
01:23:41,310 --> 01:23:42,240
0,180 180,330 330,390 390,540 540,930
you want to do something

2395
01:23:42,240 --> 01:23:43,560
0,450 450,570 570,900 930,1110 1110,1320
{in,Raft},| and then you have
|然后你有一个选举，

2396
01:23:43,560 --> 01:23:44,920
0,150 150,870
an election,|
|

2397
01:23:45,010 --> 01:23:45,880
0,120 120,210 210,300 300,630 630,870
you have a channel that
你有一个通道，

2398
01:23:45,880 --> 01:23:46,840
0,390
like,|
|

2399
01:23:46,840 --> 01:23:48,310
0,300 300,570 570,840 840,1230 1230,1470
does something about election {timeouts
做一些关于选举超时的事情，

2400
01:23:48,310 --> 01:23:49,300
0,420 420,570 570,660 660,870 870,990
-},| you will need a
|你需要一个缓冲通道，

2401
01:23:49,300 --> 01:23:51,250
0,300 300,930 1230,1680 1680,1860 1860,1950
buffer channel,| that's like the
|就是服务器数量的大小，

2402
01:23:51,250 --> 01:23:52,300
0,360 360,600 630,750 750,990 990,1050
size of the amount of

2403
01:23:52,300 --> 01:23:54,130
0,540 540,930 930,1350 1350,1530 1530,1830
servers, correct,| because you could
|因为你可以发送一些东西，然后它会阻塞，

2404
01:23:54,130 --> 01:23:55,840
0,450 660,990 990,1380 1380,1530 1530,1710
like send something and then

2405
01:23:55,840 --> 01:23:58,100
0,210 210,360 360,1020 1020,1830
like it blocks,| because,
|因为，你可以，

2406
01:23:58,300 --> 01:23:59,110
0,180 180,270 270,570 570,720 720,810
you can be,| you can
|你可以有多个像选举这样的东西，

2407
01:23:59,110 --> 01:24:01,510
0,240 240,750 750,1110 1140,2010 2010,2400
have multiple like election {}

2408
01:24:01,600 --> 01:24:04,270
0,600 630,1380 1380,1950 1950,2250 2250,2670
things,| election messages sent between
|在通道之间发送的选举信息，

2409
01:24:04,270 --> 01:24:05,680
0,180 180,900
the channels,

2410
01:24:05,930 --> 01:24:07,040
0,390 390,630 630,810 810,900 900,1110
correct,| so if you want
|所以如果你想要一个没有缓冲的通道，

2411
01:24:07,040 --> 01:24:08,270
0,330 330,690 690,990 990,1050 1050,1230
a unbuffered channel,| it should
|它应该只在两个线程之间，是吗？

2412
01:24:08,270 --> 01:24:09,830
0,150 150,210 210,720 1230,1380 1380,1560
only be between, it should

2413
01:24:09,830 --> 01:24:11,120
0,180 180,360 360,720 720,870 870,1290
only be between two threads

2414
01:24:11,120 --> 01:24:13,060
0,450 810,1410
only, correct?|
|

2415
01:24:13,420 --> 01:24:15,100
0,510 540,840 840,1050 1050,1530 1530,1680
I mean not necessarily,| like
我的意思是不需要，|例如，如果两个线程是消费者，

2416
01:24:15,100 --> 01:24:16,420
0,150 150,300 300,570 570,690 690,1320
if two threads are consumers,|
|

2417
01:24:16,420 --> 01:24:17,440
0,120 120,300 300,570 570,630 630,1020
and one thread is producer,|
一个线程是生产者，|

2418
01:24:17,440 --> 01:24:19,080
0,180 180,300 300,600
that the {}.|
那是。|

2419
01:24:20,070 --> 01:24:22,050
0,480 480,840 840,1200 1200,1860 1860,1980
Okay, but multiple producers, I
好的，但是多个生产者，我想你需要，是吗？

2420
01:24:22,050 --> 01:24:23,550
0,300 300,570 570,690 690,1020 1110,1500
guess you would need that,

2421
01:24:23,580 --> 01:24:24,720
0,600
correct?|
|

2422
01:24:25,790 --> 01:24:27,440
0,570 600,960 960,1380 1380,1500 1500,1650
Well, not necessarily,| I mean,
嗯，不需要，|我的意思是，如果消费者只是，

2423
01:24:27,440 --> 01:24:29,510
0,90 90,180 180,1230 1230,1770 1920,2070
if the consumer is,| you
|在做一个循环，并不断读取，

2424
01:24:29,510 --> 01:24:30,230
0,120 120,270 270,420 420,480 480,720
know just doing a loop

2425
01:24:30,230 --> 01:24:32,570
0,270 270,810 810,1170 1170,1680 2130,2340
and constantly reading,| then all
|然后所有的生产者都会，

2426
01:24:32,570 --> 01:24:35,260
0,420 540,1560 1590,1800 1800,2250
the producers would just,|
|

2427
01:24:35,850 --> 01:24:36,760
0,360
like,
我想这取决于它们是怎么调度的，

2428
01:24:37,490 --> 01:24:38,390
0,180 180,330 330,450 450,810 810,900
I guess it depends on

2429
01:24:38,390 --> 01:24:40,430
0,120 120,240 240,960 1380,1800 1800,2040
how they schedule,| {} by
|如果，

2430
01:24:40,430 --> 01:24:41,640
0,660
if,|
|

2431
01:24:41,640 --> 01:24:43,080
0,180 180,360 360,450 450,540 540,1440
you're like you would eventually
最终会有人从通道上读出，

2432
01:24:43,080 --> 01:24:44,670
0,480 570,900 900,1200 1200,1380 1380,1590
have someone reading from the

2433
01:24:44,700 --> 01:24:46,440
0,600 1050,1230 1230,1350 1350,1590 1590,1740
channel,| so you can have
|所以你可以有多个生产者和一个消费者。

2434
01:24:46,440 --> 01:24:48,660
0,300 300,810 810,990 990,1500 1500,2220
multiple producers and one consumer.|
|

2435
01:24:51,040 --> 01:24:52,270
0,300 300,510 510,810 810,930 930,1230
Actually, does anyone know about
有没有人知道，比如 Frans ，

2436
01:24:52,270 --> 01:24:54,760
0,510 540,1020 1020,1530 2280,2400 2400,2490
the, {like,Frans -},| do you
|你知道通道的顺序保证吗，

2437
01:24:54,760 --> 01:24:55,930
0,90 90,300 300,420 420,750 750,1170
know about the ordering guarantees

2438
01:24:55,930 --> 01:24:57,310
0,90 90,750 780,1050 1050,1230 1230,1380
of channels,| like is their
|是否有[]保证给你，

2439
01:24:57,310 --> 01:24:59,740
0,510 510,1050 1050,1290 1290,1920
[] guarantee on you,|
|

2440
01:25:02,620 --> 01:25:03,460
0,180 180,330 330,480 480,690 690,840
I feel like there is
我觉得有一个[]保证，

2441
01:25:03,460 --> 01:25:04,630
0,90 90,570 570,960 960,1080 1080,1170
an [] guarantee,| so I
|所以我想如果你有，

2442
01:25:04,630 --> 01:25:06,220
0,210 210,360 360,510 510,990
guess if you have,|
|

2443
01:25:06,220 --> 01:25:07,180
0,420 420,600 600,750 750,810 810,960
{} it's kind of like
有点像锁，

2444
01:25:07,180 --> 01:25:08,800
0,480 480,870 1050,1290 1290,1440 1440,1620
lock, right,| like if you're
|比如，你总是试图获取锁，

2445
01:25:08,800 --> 01:25:09,850
0,330 330,570 570,660 660,960 960,1050
always trying to acquire the

2446
01:25:09,850 --> 01:25:11,530
0,300 300,630 630,870 870,1080 1380,1680
lock,| another thread is also
|另一个线程也试图获取锁，

2447
01:25:11,530 --> 01:25:12,820
0,450 450,750 750,960 960,1020 1020,1290
spinning and trying to acquire

2448
01:25:12,820 --> 01:25:15,460
0,90 90,450 480,780 780,1320 1440,2640
the lock,| there's no guarantee
|不能保证你会获取它，

2449
01:25:15,490 --> 01:25:17,110
0,390 390,570 570,750 750,1020 1020,1620
that you will ever require

2450
01:25:17,110 --> 01:25:17,950
0,180 240,480 480,600 600,810 810,840
it,| which is why {}
|这就是为什么在这种情况下随机化可能是必要的，

2451
01:25:17,950 --> 01:25:18,820
0,360
like

2452
01:25:18,850 --> 01:25:20,440
0,780 780,960 960,1050 1050,1530 1530,1590
randomization might be necessary in

2453
01:25:20,440 --> 01:25:21,560
0,150 150,600
that case,|
|

2454
01:25:26,040 --> 01:25:27,390
0,300 300,420 420,930 930,1080 1080,1350
also I realized I think
我意识到，我认为这节课从技术上讲已经结束了，

2455
01:25:27,390 --> 01:25:29,610
0,330 330,480 480,990 990,1500 1770,2220
{this,lecture} is technically over, {}|
|

2456
01:25:29,700 --> 01:25:30,810
0,210 210,360 360,630 630,750 750,1110
I am holding the office
我现在继续在办公时间，

2457
01:25:30,810 --> 01:25:32,220
0,360 360,510 510,840 840,1230 1230,1410
hours right now,| so if
|所以如果你有问题要问，

2458
01:25:32,220 --> 01:25:33,450
0,150 150,300 300,630 630,960 960,1230
you have questions along to|
|

2459
01:25:33,450 --> 01:25:34,590
0,210 210,390 390,450 450,870 870,1140
or want to continue asking
或者想继续提问，

2460
01:25:34,590 --> 01:25:36,450
0,570 570,690 690,810 810,1200 1500,1860
questions,| I'll be there| and
|我会在那里，|我想也许 Frans ，

2461
01:25:36,450 --> 01:25:38,010
0,270 270,600 600,1200 1200,1500 1500,1560
I think maybe Frans,| if
|如果你想留下来或其他人。

2462
01:25:38,010 --> 01:25:39,000
0,90 90,210 210,270 270,480 480,990
you want to stick around

2463
01:25:39,000 --> 01:25:40,520
0,330 360,1050
or other,

2464
01:25:40,640 --> 01:25:41,760
0,630
others.|
|

2465
01:25:42,060 --> 01:25:43,410
0,150 150,270 270,450 450,780 780,1350
But I will move to
但我现在要去办公时间了，

2466
01:25:43,680 --> 01:25:46,020
0,90 90,600 600,870 870,1350
the office hours, now,|
|

2467
01:25:46,620 --> 01:25:47,800
0,570
so,
所以，非常感谢你们的到来。

2468
01:25:48,740 --> 01:25:49,580
0,300 300,420 420,540 540,690 690,840
thank you all so much

2469
01:25:49,580 --> 01:25:52,240
0,120 120,480 840,1230 1230,1500
for coming.| Thank you.|
|谢谢。|

2470
01:25:52,820 --> 01:25:54,240
0,450 450,810
Thank you.|
谢谢。|

2471
01:25:56,010 --> 01:25:57,380
0,960

2472
01:25:59,590 --> 01:26:00,880
0,390 390,540 540,630 630,1020 1020,1290
Oh, can I just ask
哦，我能问个简单的问题吗？

2473
01:26:00,880 --> 01:26:02,300
0,60 60,240 240,930
a quick question?|
|

2474
01:26:03,440 --> 01:26:04,610
0,300 360,510 510,690 690,930 930,1170
Yeah, {alright -}, Frans, you're
是的，好的， Frans ，你现在是主持人了，

2475
01:26:04,610 --> 01:26:05,720
0,420 420,660 660,780 780,900 900,1110
{the,host} now,| so I'm going
|我要去我的办公时间了。

2476
01:26:05,720 --> 01:26:06,890
0,210 210,540 570,810 810,1020 1020,1170
to just hop off to

2477
01:26:06,890 --> 01:26:08,570
0,150 150,720 720,870 870,1290 1290,1680
my {office,hour}.| And {} what
|你的 Vim 的主题是什么？

2478
01:26:08,570 --> 01:26:09,410
0,120 120,270 270,570 570,690 690,840
is the theme of the

2479
01:26:09,410 --> 01:26:10,780
0,330 330,420 420,840
{your -} Vim?|
|

2480
01:26:11,600 --> 01:26:13,190
0,180 180,390 390,450 450,1140 1380,1590
Oh, what's the scheme, like
哦，方案是什么，我的配色方案。

2481
01:26:13,190 --> 01:26:15,400
0,150 150,420 420,870 1170,1620
my color scheme.| Yeah.|
|嗯。|

2482
01:26:16,180 --> 01:26:17,380
0,360 360,480 480,660 660,1080 1080,1200
That's a good question,| I'm
这是个好问题，|我不太确定，让我检查一下。

2483
01:26:17,380 --> 01:26:20,170
0,150 150,390 390,870 2010,2670 2670,2790
not actually sure, let me

2484
01:26:20,170 --> 01:26:24,480
0,540
check.|
|

2485
01:26:24,620 --> 01:26:29,000
0,540 540,1410 2820,3480 3780,4140 4140,4380
{[] -}.| {} {Sorry -}?|
[]。|抱歉?|

2486
01:26:29,000 --> 01:26:30,170
0,180 180,420 420,510 510,630 630,1170
I'll type in the chat.|
我会输入到聊天内容中。|

2487
01:26:30,200 --> 01:26:33,740
0,780
{Ha,ha}.
哈哈。
