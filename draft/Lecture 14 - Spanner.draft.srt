1
00:00:00,000 --> 00:00:01,230
0,120 120,540 540,720 720,1080 1080,1230
Good afternoon, good evening, good
下午好，傍晚好，晚上好，早上好，

2
00:00:01,230 --> 00:00:02,880
0,390 390,540 540,960 960,1500 1500,1650
night, good morning,| wherever you
|无论你在哪里或者无论你什么时候看。

3
00:00:02,880 --> 00:00:04,680
0,390 720,1080 1080,1410 1410,1500 1500,1800
are or whenever you're watching

4
00:00:04,680 --> 00:00:07,890
0,360 900,1650 1650,2310 2310,2940 2970,3210
this.| So today I wanna
|所以今天我想谈谈 Spanner ，

5
00:00:07,890 --> 00:00:10,260
0,210 210,810 1320,2130
talk about {}

6
00:00:10,410 --> 00:00:12,480
0,900 1410,1590 1590,1710 1710,1920 1920,2070
Spanner,| is a paper from
|是一篇 2012 年的论文，

7
00:00:12,480 --> 00:00:15,870
0,1740 1740,2190 2190,2310 2310,3030 3030,3390
2012,| but the Spanner {}
|但 Spanner 系统仍在使用中，

8
00:00:15,870 --> 00:00:17,340
0,390 390,570 570,690 690,1050 1050,1470
system is in active use,|
|

9
00:00:17,340 --> 00:00:19,470
0,360 360,900 900,1170 1170,1680 1680,2130
and also still continuously under
而且还在不断地开发中，

10
00:00:19,470 --> 00:00:20,360
0,630
development,|
|

11
00:00:20,970 --> 00:00:22,410
0,240 240,510 510,930 930,1110 1110,1440
so it's a real system.|
所以这是一个真正的系统。|

12
00:00:23,130 --> 00:00:25,200
0,570 660,1020 1020,1680 1680,1800 1800,2070
The main topic and why
主要主题和为什么 Spanner 很有趣，

13
00:00:25,200 --> 00:00:26,520
0,120 120,390 390,510 510,750 750,1320
{you,know} Spanner is really interesting,|
|

14
00:00:26,550 --> 00:00:28,710
0,390 390,960 960,1320 1320,1590 1590,2160
{} is supports {[wide-area],transactions -},|
是支持[广域]事务，|

15
00:00:38,400 --> 00:00:40,140
0,300 300,930 930,1080 1080,1200 1200,1740
and this is a really
这是一个非常强大的编程模型，

16
00:00:40,140 --> 00:00:42,840
0,300 300,1320 1350,1980 1980,2370 2370,2700
{} powerful programming model,| so
|所以即使数据，

17
00:00:43,080 --> 00:00:45,150
0,300 300,720 720,840 840,1470 1740,2070
even though the data,| maybe
|数据可能分片在多个服务器上，

18
00:00:45,150 --> 00:00:47,250
0,60 60,360 360,690 690,1140 1140,2100
the data sharded across multiple

19
00:00:47,280 --> 00:00:48,630
0,510 510,630 630,690 690,1050 1050,1350
servers,| and the servers being
|服务器位于不同的数据中心，

20
00:00:48,630 --> 00:00:49,920
0,210 210,540 540,750 750,1110 1110,1290
in different data centers| and
|在地球上的不同地方，

21
00:00:49,920 --> 00:00:52,110
0,930 930,1320 1320,1770 1770,2130 2130,2190
different place on on the

22
00:00:52,110 --> 00:00:53,610
0,480 840,1080 1080,1230 1230,1350 1350,1500
planet,| {} you can just
|你可以运行事务，

23
00:00:53,610 --> 00:00:56,670
0,540 570,1380 1380,2460 2490,2700 2700,3060
run transactions,| and they have
|它们有 ACID 语义，

24
00:00:56,670 --> 00:00:59,640
0,600 1260,1890 1890,2130 2130,2430 2430,2970
ACID semantics,| and there atomic
|以及失败的原子性，

25
00:00:59,640 --> 00:01:00,840
0,150 150,570 570,930 930,1050 1050,1200
{you,know} respect failure,| that all
|所有的写入都发生，或者一个也没有，

26
00:01:00,840 --> 00:01:01,680
0,120 120,330 330,570 570,660 660,840
the writes happen or none

27
00:01:01,680 --> 00:01:03,840
0,90 90,450 750,1290 1290,1830 1860,2160
of them,| and they provide
|并且它们提供了可串行化。

28
00:01:03,840 --> 00:01:04,720
0,810
serializability.|
|

29
00:01:05,230 --> 00:01:07,870
0,270 270,720 750,1020 1020,1800 1800,2640
And so {that's,an} incredibly powerful
所以这是一个非常强大的编程抽象，

30
00:01:07,900 --> 00:01:10,330
0,720 750,1200 1200,1890 2160,2370 2370,2430
{} programming abstraction,| and of
|当然，挑战在于如何有效地实施它，

31
00:01:10,330 --> 00:01:12,070
0,270 270,990 990,1410 1410,1650 1650,1740
course the challenge is to

32
00:01:12,070 --> 00:01:14,560
0,450 600,1050 1050,1620 1680,2190 2190,2490
implement it efficiently,| {} and
|其中一个很大的挑战是，

33
00:01:14,920 --> 00:01:16,720
0,540 540,900 900,1590 1590,1740 1740,1800
one big {challenge,is}| like the
|物理定律光速，

34
00:01:16,720 --> 00:01:17,650
0,180 180,270 270,690 690,810 810,930
law of physics you know

35
00:01:17,650 --> 00:01:18,640
0,210 210,450 450,540 540,900 900,990
the speed of light,| you
|从一端发送一个包，

36
00:01:18,640 --> 00:01:19,690
0,240 240,510 510,570 570,930 930,1050
know sending a packet from

37
00:01:19,690 --> 00:01:21,520
0,270 270,510 1200,1410 1410,1620 1620,1830
one end| in one part
|在美国的一个地方到美国的另一个地方，

38
00:01:21,520 --> 00:01:22,060
0,60 60,120 120,360 360,450 450,540
of the US to the

39
00:01:22,060 --> 00:01:22,810
0,180 180,330 330,390 390,480 480,750
other part of the US|
|

40
00:01:22,810 --> 00:01:24,310
0,210 210,360 360,600 600,1230 1350,1500
or to another continent,| and
或者去另一个大陆，|这需要很长时间，

41
00:01:24,310 --> 00:01:24,820
0,90 90,270 270,300 300,450 450,510
it takes a lot of

42
00:01:24,820 --> 00:01:26,560
0,390 600,1320 1320,1440 1440,1560 1560,1740
time,| {} you know we're
|我们谈论的是几十毫秒。

43
00:01:26,560 --> 00:01:28,000
0,270 270,450 450,660 660,720 720,1440
talking about tens of milliseconds.|
|

44
00:01:28,870 --> 00:01:30,790
0,510 690,1170 1170,1440 1440,1620 1620,1920
So, {} what we see
所以，我们在这篇论文中看到的是，

45
00:01:30,790 --> 00:01:32,080
0,90 90,420 450,810 810,900 900,1290
in this paper is that,|
|

46
00:01:32,080 --> 00:01:34,060
0,540 660,1020 1020,1230 1230,1800 1800,1980
{} {read-write -} transactions are
读写事务确实是相当昂贵的，

47
00:01:34,060 --> 00:01:36,280
0,420 420,600 600,1080 1080,1410 1410,2220
actually, are indeed quite expensive,|
|

48
00:01:36,520 --> 00:01:38,380
0,360 360,570 570,780 780,1500 1500,1860
{} but they work very
但他们非常努力地让只读事务变得非常便宜。

49
00:01:38,380 --> 00:01:40,660
0,600 1110,1380 1380,1830 1830,1980 1980,2280
hard to make {read-only -}

50
00:01:40,660 --> 00:01:43,220
0,810 840,1500 1500,2280
transactions very inexpensive.|
|

51
00:01:43,780 --> 00:01:46,870
0,330 330,720 810,1530 1920,2550 2730,3090
And so the {} {read-write
读写事务由两阶段提交实现，

52
00:01:46,870 --> 00:01:48,940
0,330 330,1110
-} transactions

53
00:01:50,020 --> 00:01:51,910
0,540 630,1020 1020,1530 1530,1770 1770,1890
are are implemented using {2-phase

54
00:01:51,910 --> 00:01:53,100
0,240 240,780
-} commit,|
|

55
00:01:53,810 --> 00:01:55,130
0,180 180,270 270,510 510,780 780,1320
as we talked about last
正如我们上周所谈到的，

56
00:01:55,160 --> 00:01:56,900
0,420 420,630 630,780 780,1050 1050,1740
week,| and {2-phase -} locking,|
|以及两阶段锁，|

57
00:01:57,260 --> 00:01:58,730
0,540 540,1020 1020,1320 1320,1410 1410,1470
{} and one of the
其中有趣的一件事是，

58
00:01:58,730 --> 00:02:00,530
0,210 210,390 390,810 1140,1530 1530,1800
things that is interesting about

59
00:02:00,530 --> 00:02:02,240
0,180 180,270 270,600 930,1230 1230,1710
it is that,| {} the
|这个协议的参与者都是 Paxos 组。

60
00:02:02,240 --> 00:02:04,100
0,630 630,810 810,990 990,1590 1620,1860
participants in this protocol are

61
00:02:04,100 --> 00:02:05,900
0,180 180,510 510,1020 1020,1500
just basically Paxos groups.|
|

62
00:02:11,400 --> 00:02:14,060
0,690 780,1170 1170,1470 1470,2250
{} The read-only transactions
只读事务可以在任何数据中心执行，

63
00:02:14,590 --> 00:02:16,840
0,240 240,900 900,1200 1200,1740 1800,2250
can execute at any {}

64
00:02:16,840 --> 00:02:18,020
0,240 240,750
data center,|
|

65
00:02:19,570 --> 00:02:20,500
0,390 390,540 540,690 690,750 750,930
and they're going to run
它们会运行得很快，

66
00:02:20,500 --> 00:02:21,730
0,240 240,570 570,660 660,960 960,1230
very fast,| in fact you
|事实上，你可以看看论文后面的表六，

67
00:02:21,760 --> 00:02:22,870
0,210 210,330 330,390 390,990 990,1110
look at the table {}

68
00:02:22,870 --> 00:02:23,710
0,330 330,420 420,480 480,780 780,840
six in the back of

69
00:02:23,710 --> 00:02:25,030
0,90 90,660 780,1020 1020,1200 1200,1320
the paper,| you'll see that
|你将看到只读事务

70
00:02:25,030 --> 00:02:26,770
0,180 180,480 630,1290 1290,1530 1530,1740
{read-only -} transaction| somewhere like
|大约比读写事务快十倍。

71
00:02:26,770 --> 00:02:28,300
0,210 210,630 630,1080 1140,1350 1350,1530
ten times faster {read-write -}

72
00:02:28,300 --> 00:02:29,240
0,750
transactions.|
|

73
00:02:29,630 --> 00:02:30,590
0,240 240,330 330,360 360,720 720,960
And there are two key
这里有两个关键的想法，

74
00:02:30,590 --> 00:02:32,240
0,450 450,840 960,1380 1380,1560 1560,1650
ideas there,| {} and we'll
|我们将在这节课上讨论，

75
00:02:32,240 --> 00:02:33,410
0,210 210,390 390,600 600,870 870,1170
talk about this lecture,| one
|一个是快照隔离，

76
00:02:33,410 --> 00:02:34,960
0,180 180,1050
is snapshot

77
00:02:35,540 --> 00:02:37,580
0,930 1410,1620 1620,1860 1860,1950 1950,2040
isolation,| which actually is a
|这是一个标准的数据库概念，

78
00:02:37,580 --> 00:02:40,040
0,600 630,1380 1380,1860 1860,2310 2310,2460
standard database idea,| {} but
|但在这里使用它为了让读取更快，

79
00:02:40,040 --> 00:02:41,300
0,60 60,330 330,420 420,930 1140,1260
{} use it here to

80
00:02:41,300 --> 00:02:43,430
0,390 390,510 510,720 720,1200 1650,2130
make the read fast, {}|
|

81
00:02:43,430 --> 00:02:44,660
0,270 270,840 840,930 930,1080 1080,1230
in particular you know to
特别是，让它运行良好，

82
00:02:44,660 --> 00:02:46,340
0,210 210,300 300,660 660,1230 1230,1680
make it actually work well|
|

83
00:02:46,370 --> 00:02:47,810
0,240 240,330 330,870 870,1140 1140,1440
in a distributed {wide-area -}
在分布式广域环境中，

84
00:02:47,810 --> 00:02:49,790
0,480 570,930 930,1380 1380,1500 1500,1980
setting,| they rely on synchronized
|它们依赖同步时钟，

85
00:02:49,790 --> 00:02:53,280
0,540 930,1260 1260,1740
clocks or {},|
|

86
00:02:54,300 --> 00:02:55,620
0,210 210,420 420,720 720,930 930,1320
{you,know} those clocks are perfectly
那些时钟是完全同步的，

87
00:02:55,620 --> 00:02:58,710
0,840 1350,1860 1860,2100 2100,2610 2700,3090
synchronized,| {} and so, {}
|所以，他们的事务方案必须处理

88
00:02:58,710 --> 00:03:00,420
0,420 420,840 840,1170 1170,1410 1410,1710
their transaction scheme must deal

89
00:03:00,420 --> 00:03:01,170
0,150 150,210 210,420 420,690 690,750
with| a little bit of
|一点[]或漂移或错误容限，

90
00:03:01,200 --> 00:03:04,680
0,450 450,1080 1110,1350 1350,2040 2730,3480
{} [] or drift {or,error}

91
00:03:04,680 --> 00:03:06,780
0,600 630,1170 1170,1650 1650,1830 1830,2100
margin,| in exactly know what
|知道 TrueTime 是什么。

92
00:03:06,780 --> 00:03:08,520
0,360 390,630 630,990 990,1530
the {TrueTime -} is.|
|

93
00:03:09,590 --> 00:03:11,300
0,360 360,570 570,660 660,1050 1050,1710
{As,I} said is widely used,|
正如我所说的被广泛使用，|

94
00:03:14,460 --> 00:03:16,290
0,480 480,600 600,810 810,1320 1320,1830
both in {} internal Google,|
无论是在 Google 内部，|

95
00:03:16,380 --> 00:03:18,480
0,870 900,1080 1080,1800 1800,2040 2040,2100
{} but also as a
但作为 Google 的客户，你也可以使用它，

96
00:03:18,480 --> 00:03:19,920
0,270 270,780 780,900 900,1020 1020,1440
Google customer, you can use

97
00:03:19,980 --> 00:03:21,210
0,300 300,750 750,840 840,1200 1200,1230
it,| Spanner is basically a
|Spanner 是一项云服务，

98
00:03:21,210 --> 00:03:22,440
0,300 300,720 720,870 870,1080 1080,1230
cloud service,| that you can
|你可以作为 Google 客户使用，

99
00:03:22,440 --> 00:03:24,600
0,330 330,450 450,720 720,1320 1470,2160
use {as,a} Google customer, {}|
|

100
00:03:24,600 --> 00:03:26,850
0,180 180,870 870,1080 1080,1860 1980,2250
if you use Gmail, {}|
如果你使用 Gmail ，|

101
00:03:26,850 --> 00:03:28,950
0,450 450,930 930,1440 1470,1920 1920,2100
probably your email or parts
很可能你的电子邮件或部分电子邮件系统是通过 Spanner 的。

102
00:03:28,950 --> 00:03:29,850
0,90 90,180 180,420 420,690 690,900
of the email system actually

103
00:03:29,850 --> 00:03:31,120
0,180 180,600 600,930
go through Spanner.|
|

104
00:03:32,520 --> 00:03:34,980
0,600 750,1080 1080,1500 1500,1950 1950,2460
{} Maybe before diving into
也许在深入讨论更多细节之前，

105
00:03:34,980 --> 00:03:37,770
0,510 510,1050 1050,1530 1860,2400 2400,2790
{} more detail,| {} I
|我想做一个逻辑上的解释，

106
00:03:37,770 --> 00:03:39,150
0,180 180,240 240,420 420,750 750,1380
want to make one logistic

107
00:03:39,150 --> 00:03:41,580
0,540 570,1440 1440,1830 1830,1920 1920,2430
comment,| not related to Spanner,|
|与 Spanner 无关，|

108
00:03:41,760 --> 00:03:43,950
0,660 660,930 930,1620 1650,1920 1920,2190
{} as you may already
正如你可能已经看到的，

109
00:03:43,950 --> 00:03:45,420
0,90 90,600 630,1080 1080,1290 1290,1470
have seen,| {} we made
|我们对即将到来的长周末做了一些调整，

110
00:03:45,420 --> 00:03:47,730
0,150 150,690 690,960 960,1320 1800,2310
some adjustments for the long

111
00:03:47,730 --> 00:03:50,430
0,330 330,630 630,1020 1020,2220 2490,2700
weekend, long upcoming weekend,| first
|首先，实验 4a 的工作量不像其他实验那么重，

112
00:03:50,430 --> 00:03:51,600
0,60 60,330 330,630 630,900 900,1170
of all, {} lab {4a

113
00:03:51,600 --> 00:03:54,120
0,420 540,1260 1260,1860 1890,2430 2430,2520
-} {} is not as

114
00:03:54,120 --> 00:03:55,560
0,240 240,750 750,1020 1020,1260 1260,1440
heavy duty as the other

115
00:03:55,560 --> 00:03:57,060
0,450 450,660 660,1170 1170,1350 1350,1500
labs,| and hopefully take them
|希望能少花点时间，

116
00:03:57,060 --> 00:03:58,740
0,210 210,750 990,1290 1290,1440 1440,1680
less time,| {} we also
|我们还取消了下周的课程，

117
00:03:58,740 --> 00:04:00,450
0,570 570,840 840,1080 1080,1440 1440,1710
cancelled next week's lecture,| so
|这样你就可以把它当做 4a 的工作时间，

118
00:04:00,450 --> 00:04:01,440
0,150 150,270 270,420 420,750 750,990
that you can actually use

119
00:04:01,440 --> 00:04:02,940
0,270 270,630 630,930 960,1260 1260,1500
that as {} time to

120
00:04:02,940 --> 00:04:05,130
0,300 300,1020 1020,1320 1320,1680 1920,2190
work on {4a -},| and
|我们把 4a 的最后期限改得更灵活了，

121
00:04:05,130 --> 00:04:06,720
0,120 120,360 360,540 540,1110 1110,1590
we made the deadline for

122
00:04:06,720 --> 00:04:08,340
0,300 300,390 390,690 690,1230 1260,1620
{4a -} more flexible,| so
|所以下个星期五对你来说很方便，

123
00:04:08,370 --> 00:04:09,540
0,240 240,480 480,840 840,960 960,1170
{} next Friday is now

124
00:04:09,540 --> 00:04:11,010
0,360 360,480 480,840 1080,1350 1350,1470
convenient for you,| you can
|你可以选择晚些时候

125
00:04:11,010 --> 00:04:12,870
0,330 330,630 630,1110 1140,1350 1350,1860
actually choose to have another

126
00:04:12,900 --> 00:04:14,700
0,450 450,690 690,1140 1230,1410 1410,1800
extra late hours| {} to
|晚点提交它，

127
00:04:14,700 --> 00:04:16,000
0,300 330,630 630,750 750,1140
{} submit it later,|
|

128
00:04:16,870 --> 00:04:18,130
0,330 330,510 510,810 810,930 930,1260
{} and hopefully that will
希望这能让你享受这个长周末，

129
00:04:18,130 --> 00:04:20,470
0,540 540,720 720,1290 1290,2010 2010,2340
allow you to enjoy the

130
00:04:20,470 --> 00:04:22,180
0,240 240,660 660,930 1200,1560 1560,1710
long weekend,| and perhaps get
|也许可以睡一觉，

131
00:04:22,180 --> 00:04:24,340
0,300 300,900 900,1350 1530,2070 2070,2160
some sleep| and maybe do
|或者做些别的事情，而不是调试你的实验。

132
00:04:24,340 --> 00:04:27,070
0,240 240,540 540,870 870,870 1920,2730
something else than {} debugging

133
00:04:27,070 --> 00:04:28,200
0,150 150,270 270,990
{} your labs.|
|

134
00:04:29,100 --> 00:04:30,450
0,420 660,990 990,1170 1170,1200 1200,1350
{} {The,second} point I want
我想说的第二点是与 Spanner 直接相关的，

135
00:04:30,450 --> 00:04:31,890
0,60 60,270 270,660 750,1140 1140,1440
to make is directly related

136
00:04:31,890 --> 00:04:33,540
0,90 90,390 390,690 840,1200 1200,1650
to {Spanner -},| {} you
|你们中的一些人注意到了这一点，

137
00:04:33,870 --> 00:04:34,800
0,60 120,330 330,450 450,630 630,930
know some of you noticed

138
00:04:34,800 --> 00:04:36,780
0,150 150,270 270,450 450,840 840,1980
this| and came through the
|并通过提问，

139
00:04:37,050 --> 00:04:38,670
0,600 780,1050 1050,1230 1230,1470 1470,1620
questions,| {} this paper is
|这篇论文很复杂，

140
00:04:38,670 --> 00:04:41,640
0,420 420,1200 1860,2190 2190,2520 2820,2970
quite complicated,| and there are
|它之所以复杂，原因有很多，

141
00:04:41,640 --> 00:04:43,020
0,210 210,450 450,540 540,630 630,1380
many reasons why it's complicated,|
|

142
00:04:43,020 --> 00:04:44,460
0,420 420,690 690,990 990,1260 1260,1440
but one reason is that,|
但其中一个原因是，|

143
00:04:44,460 --> 00:04:45,810
0,450 450,810 810,870 870,1260 1260,1350
actually there's a lot of
有很多事情正在发生，

144
00:04:45,810 --> 00:04:47,730
0,210 210,450 450,690 1560,1860 1860,1920
things going on,| that's a
|这是一个强大的系统，

145
00:04:47,730 --> 00:04:49,050
0,360 360,870 870,1110 1110,1170 1170,1320
powerful system,| has a lot
|有很多不同的组件，

146
00:04:49,050 --> 00:04:50,310
0,90 90,330 330,840 840,1050 1050,1260
of different components to it,|
|

147
00:04:50,550 --> 00:04:52,170
0,570 570,1140 1140,1200 1200,1350 1350,1620
{} and you know the
不同组件之间的相互作用很重要，

148
00:04:52,170 --> 00:04:53,970
0,450 450,720 720,960 960,1560 1560,1800
interaction between different components is

149
00:04:53,970 --> 00:04:56,640
0,660 1020,1560 1800,2220 2220,2370 2370,2670
important,| {} and so there's
|这篇论文中有很多材料，

150
00:04:56,640 --> 00:04:58,440
0,150 150,900 900,960 960,1530 1530,1800
a lot of material in

151
00:04:58,590 --> 00:04:59,910
0,150 150,540 540,690 690,930 1020,1320
this paper,| and so although
|尽管我会在这节课中努力做到，

152
00:04:59,910 --> 00:05:01,050
0,120 120,420 420,540 540,990 990,1140
I'll try to do in

153
00:05:01,050 --> 00:05:02,040
0,180 180,600 600,720 720,930 930,990
this lecture,| is {try,to} to
|试图说的更清楚，

154
00:05:02,040 --> 00:05:03,690
0,150 150,270 270,450 450,960 1170,1650
make that more clear,| by
|通过关注这篇论文的几个方面，

155
00:05:03,690 --> 00:05:05,340
0,510 510,630 630,720 720,1200 1200,1650
focusing on a couple aspects

156
00:05:05,340 --> 00:05:06,540
0,60 60,150 150,570 570,840 840,1200
of the paper,| and I'm
|我不打算对这篇论文做一个全面的处理，

157
00:05:06,540 --> 00:05:07,290
0,300 300,420 420,480 480,630 630,750
not going to do a

158
00:05:07,290 --> 00:05:08,970
0,240 240,720 720,1140 1140,1230 1230,1680
full treatment of the paper,|
|

159
00:05:09,210 --> 00:05:11,220
0,420 420,1710 1710,1770 1770,1920 1920,2010
{} {but,you,know} of course I
但是当然我认为最重要的想法，

160
00:05:11,220 --> 00:05:12,030
0,150 150,330 330,420 420,540 540,810
think what are the most

161
00:05:12,030 --> 00:05:13,380
0,330 330,810 810,900 900,1140 1140,1350
important ideas| and why we're
|以及为什么我们会在 6.824 阅读它，

162
00:05:13,380 --> 00:05:15,120
0,240 240,450 450,750 870,1590
reading it in 6.824,|
|

163
00:05:15,830 --> 00:05:18,530
0,540 1050,1350 1350,1440 1440,1890 1890,2700
that took me actually a
这花了我一些时间，

164
00:05:18,530 --> 00:05:19,490
0,210 210,330 330,390 390,810 810,960
little bit of time| or
|或者几年的时间来弄清楚如何展示这篇论文，

165
00:05:19,490 --> 00:05:21,800
0,840 1140,1470 1470,1770 1770,2010 2010,2310
{} few years to figure

166
00:05:21,800 --> 00:05:23,390
0,150 150,420 420,690 690,1230 1260,1590
out actually how to present

167
00:05:23,390 --> 00:05:24,470
0,120 120,480 480,630 630,960 960,1080
this paper,| or explain it
|或者用一种我认为更容易理解的方式来解释，

168
00:05:24,470 --> 00:05:25,160
0,60 60,150 150,390 390,570 570,690
in a way that I

169
00:05:25,160 --> 00:05:27,920
0,660 690,930 930,1650 1770,2460 2460,2760
think it's a maybe easier

170
00:05:27,920 --> 00:05:29,150
0,90 90,630 630,780 780,1050 1050,1230
to understand,| you know if
|如果对于 6.824 的概念。

171
00:05:29,150 --> 00:05:30,860
0,150 150,390 390,930 1200,1380 1380,1710
you are for the concept

172
00:05:30,860 --> 00:05:31,700
0,90 90,270 270,390 390,480 480,840
of {6.824 - - -}.|
|

173
00:05:32,210 --> 00:05:33,800
0,510 630,810 810,1020 1020,1440 1440,1590
Okay, but ask questions as
好的，但还是像往常一样问问题。

174
00:05:33,800 --> 00:05:34,660
0,570
always.|
|

175
00:05:36,650 --> 00:05:39,260
0,420 420,930 960,1170 1170,1740 2160,2610
Okay, {} so let's dive
好的，让我们深入讨论一下高层组织架构。

176
00:05:39,260 --> 00:05:40,340
0,180 180,600 630,840 840,870 870,1080
in and talk a little

177
00:05:40,340 --> 00:05:42,410
0,210 210,360 360,630 630,1170 1170,2070
bit of the high-level organization.|
|

178
00:05:42,800 --> 00:05:43,780
0,660

179
00:05:49,430 --> 00:05:50,690
0,420 420,750 750,900 900,1080 1080,1260
And more from the point
从更多的角度来看，

180
00:05:50,690 --> 00:05:52,400
0,60 60,930 930,1230 1230,1500 1500,1710
of view| from the way
|从我想在这节课中谈论 Spanner 的方式来看。

181
00:05:52,400 --> 00:05:53,540
0,90 90,420 420,600 600,870 870,1140
I want to talk about

182
00:05:53,540 --> 00:05:55,190
0,210 210,930 1020,1410 1410,1500 1500,1650
this {} Spanner in this

183
00:05:55,190 --> 00:05:55,820
0,330
lecture.|
|

184
00:05:56,240 --> 00:05:57,470
0,180 180,360 360,660 660,900 900,1230
So there's multiple data centers,|
所以，有多个数据中心，|

185
00:05:57,470 --> 00:05:59,540
0,180 210,420 420,1020 1200,1560 1560,2070
and {you,know} for {} convenience
为了方便起见，

186
00:05:59,540 --> 00:06:01,910
0,900 930,1590 1590,1680 1680,1830 1830,2370
for simplicity,| you know just
|只考虑三个数据中心， A B 和 C ，

187
00:06:01,910 --> 00:06:03,020
0,210 210,420 420,630 630,840 840,1110
think about there 3 data

188
00:06:03,020 --> 00:06:05,510
0,390 630,1170 1200,1770 1770,1950 1950,2490
centers, A B and C,|
|

189
00:06:08,900 --> 00:06:09,680
0,120 120,480 480,540 540,660 660,780
I mean it can be
它可以在世界的任何地方，

190
00:06:09,680 --> 00:06:11,100
0,360 360,420 420,480 480,990
anywhere in the world,|
|

191
00:06:12,480 --> 00:06:14,610
0,660 840,1560 1560,1830 1830,1980 1980,2130
and the goal is that,|
目标是，|

192
00:06:14,610 --> 00:06:15,960
0,450 450,570 570,750 750,1170 1170,1350
basically you know data will
数据会是，

193
00:06:15,960 --> 00:06:16,680
0,240 240,480 480,570 570,690 690,720
be like,| we have {}
|我们数据在分片中，

194
00:06:16,680 --> 00:06:18,480
0,600 600,870 990,1590 1590,1740 1740,1800
data like {} like a

195
00:06:18,480 --> 00:06:19,590
0,540 540,630 630,750 750,1020 1020,1110
shard,| you know that you
|包含一些数据库行或一些键值对，

196
00:06:19,590 --> 00:06:22,110
0,270 480,1140 1140,1590 1590,2040 2040,2520
know contains some database rows

197
00:06:22,110 --> 00:06:23,790
0,360 450,630 630,810 810,1110 1110,1680
or some key value pairs,|
|

198
00:06:24,350 --> 00:06:26,440
0,330 330,570 570,1080 1080,1920
{} so {at,the} shard,|
在分片中，|

199
00:06:26,840 --> 00:06:28,220
0,300 300,390 390,660 660,750 750,1380
maybe it has the {keys,a}
也许它有键 a 到 m ，

200
00:06:28,220 --> 00:06:30,140
0,690 720,780 780,990 990,1410
to you know m,|
|

201
00:06:31,080 --> 00:06:32,160
0,270 270,330 330,690 690,930 930,1080
and the basic idea is
基本的想法是在数据中心之间复制这个分片，

202
00:06:32,160 --> 00:06:33,570
0,330 330,630 630,720 720,1200 1200,1410
actually going to replicate that

203
00:06:33,570 --> 00:06:35,380
0,270 270,690 690,900 900,1260
shard across data centers,|
|

204
00:06:37,440 --> 00:06:38,520
0,360 360,630 630,780 780,840 840,1080
{} and with the goal
目标是即使整个数据中心出现故障，

205
00:06:38,520 --> 00:06:39,780
0,180 180,360 360,690 690,840 840,1260
that like even if complete

206
00:06:39,780 --> 00:06:41,400
0,240 240,540 540,750 750,1320
data center goes down,|
|

207
00:06:41,890 --> 00:06:44,350
0,600 720,990 990,1350 1350,1920 1980,2460
{then,you,know} we can proceed, {}|
我们可以继续，|

208
00:06:44,350 --> 00:06:45,430
0,120 120,510 510,690 690,930 930,1080
you know the way we're
我们安排的方式，

209
00:06:45,430 --> 00:06:46,300
0,120 120,240 240,630 630,750 750,870
going to arrange,| that we're
|我们将能够继续进行的是，

210
00:06:46,300 --> 00:06:46,810
0,120 120,180 180,240 240,420 420,510
going to be able to

211
00:06:46,810 --> 00:06:49,840
0,390 390,600 600,930 1080,1770 1770,3030
proceed is that,| basically {these,shards}
|这些分片将形成，

212
00:06:49,840 --> 00:06:51,440
0,420 420,540 540,600 600,1320
you're going to form,|
|

213
00:06:52,380 --> 00:06:53,640
0,180 180,780 780,930 930,1020 1020,1260
these replicas that are sitting
这些复制位于不同数据中心将组成一个 Paxos 组，

214
00:06:53,640 --> 00:06:54,960
0,90 90,360 360,540 540,1020 1140,1320
in different data center will

215
00:06:54,960 --> 00:06:56,980
0,390 390,900 900,1350 1350,1770
form one Paxos group,|
|

216
00:07:03,520 --> 00:07:04,810
0,210 210,300 300,660 660,1020 1020,1290
so if you're thinking about
所以如果你考虑这个，

217
00:07:04,810 --> 00:07:05,530
0,150 150,300 300,510 510,570 570,720
this,| we're trying to think
|我们试着从实验 3 的角度来考虑，

218
00:07:05,530 --> 00:07:06,370
0,240 240,390 390,480 480,750 750,840
about this in terms of

219
00:07:06,370 --> 00:07:08,560
0,480 510,810 810,1320 1470,1890 1890,2190
lab {} 3,| then you
|然后你可以考虑，

220
00:07:08,560 --> 00:07:09,340
0,90 90,210 210,480 480,690 690,780
can think about that,| you
|我们有一个键值存储，

221
00:07:09,340 --> 00:07:10,120
0,210 210,330 330,570 570,630 630,780
know we have a key

222
00:07:10,120 --> 00:07:11,560
0,360 360,900 1020,1230 1230,1290 1290,1440
value store,| where the key
|键值服务器分布在不同的数据中心，

223
00:07:11,560 --> 00:07:14,380
0,300 300,930 960,2100 2130,2460 2460,2820
value servers are spread around

224
00:07:14,380 --> 00:07:16,780
0,240 240,450 450,990 1230,2010 2010,2400
different data centers,| and the
|键被更新，

225
00:07:17,560 --> 00:07:19,960
0,300 300,420 420,930 930,1620 1620,2400
keys are updated,| the []
|[]Raft写入，通过 Raft 日志，

226
00:07:19,960 --> 00:07:22,000
0,360 390,990 1080,1770 1770,1890 1890,2040
{} Raft writes, you know

227
00:07:22,000 --> 00:07:23,800
0,330 330,570 570,900 900,1440 1590,1800
through the Raft log,| and
|然后我们到不同的 kv ，

228
00:07:23,800 --> 00:07:24,370
0,240 240,330 330,420 420,480 480,570
then we go to the

229
00:07:24,370 --> 00:07:26,950
0,780 780,1020 1020,1410 1440,2220 2310,2580
individual key {} kvs,| {you,know}
|更新它们的状态，

230
00:07:26,950 --> 00:07:27,980
0,360 360,450 450,930
update their state,|
|

231
00:07:28,750 --> 00:07:29,500
0,180 180,300 300,420 420,570 570,750
and so you can think
所以你可以想象实验 3 在这里，

232
00:07:29,500 --> 00:07:31,180
0,390 390,480 480,690 810,1350 1350,1680
about you know lab 3

233
00:07:31,180 --> 00:07:32,620
0,270 270,480 480,870 870,1080 1080,1440
being here,| instead of running
|不是在你的机器上运行 3 台 kv 服务器，

234
00:07:32,620 --> 00:07:33,520
0,120 120,270 270,660 660,780 780,900
you know 3 {} kv

235
00:07:33,520 --> 00:07:35,080
0,330 330,420 420,510 510,1110 1200,1560
servers on your machine, {}|
|

236
00:07:35,080 --> 00:07:36,130
0,240 240,360 360,420 420,660 660,1050
you're going to run one
你将在不同的数据中心运行 kv 服务器。

237
00:07:36,220 --> 00:07:39,100
0,300 300,660 660,810 810,1470 1530,2880
kv server in different data

238
00:07:39,100 --> 00:07:39,800
0,480
centers.|
|

239
00:07:42,080 --> 00:07:43,980
0,750 870,1590
Okay? {}|
好的?|

240
00:07:44,170 --> 00:07:46,510
0,450 450,1050 1140,1530 1530,1740 1740,2340
So we, then {} there's
所以，然后每个分片有一个 Paxos 组，

241
00:07:46,510 --> 00:07:47,560
0,150 150,270 270,360 360,630 630,1050
gonna be a Paxos group

242
00:07:47,560 --> 00:07:49,690
0,510 540,990 990,1470 1470,1860 1890,2130
per shard,| so { -}
|所以，

243
00:07:49,720 --> 00:07:51,720
0,660 960,1620
there, {}|
|

244
00:07:54,570 --> 00:07:55,800
0,300 300,510 510,600 600,810 810,1230
it might be other shards|
可能是其他分片，|

245
00:07:55,800 --> 00:07:57,030
0,270 270,600 600,810 810,1110 1110,1230
that hold other parts of
持有其他部分的键值空间或数据库行，

246
00:07:57,030 --> 00:07:58,380
0,570
the,

247
00:07:59,620 --> 00:08:01,660
0,150 150,720 720,1200 1200,1500 1500,2040
the key-value space or database

248
00:08:01,660 --> 00:08:03,520
0,660 1020,1230 1230,1440 1440,1770 1770,1860
rows,| so let's say you
|假设我们只有两个分片，

249
00:08:03,520 --> 00:08:04,300
0,120 120,240 240,360 360,600 600,780
know we have only two

250
00:08:04,300 --> 00:08:05,260
0,510 510,630 630,720 720,810 810,960
shards,| you know for this
|对于这个数据库，

251
00:08:05,260 --> 00:08:07,330
0,330 330,1020 1230,1830 1830,1920 1920,2070
particular database,| {} you know
|分片包含 a 到 m ，

252
00:08:07,330 --> 00:08:08,680
0,330 330,750 750,960 960,1020 1020,1350
shards containing a to m,|
|

253
00:08:08,680 --> 00:08:09,640
0,120 120,210 210,270 270,570 570,960
and then another shard containing
然后其他分片包含 n 到 z ，

254
00:08:09,640 --> 00:08:10,480
0,150 150,240 240,570
n to z,|
|

255
00:08:11,280 --> 00:08:12,840
0,450 510,960 960,1170 1170,1410 1410,1560
then they have form their
然后它们组成自己的 Paxos 组。

256
00:08:12,840 --> 00:08:14,480
0,420 480,870 870,1440
own Paxos group.|
|

257
00:08:17,110 --> 00:08:18,100
0,180 180,240 240,600 600,720 720,990
And the reason we want
我们想要获得多个分片的原因是为了获得并行性，

258
00:08:18,100 --> 00:08:19,390
0,60 60,210 210,240 240,600 600,1290
to get {} multiple shards

259
00:08:20,020 --> 00:08:21,960
0,360 360,480 480,870 870,1530
is to get parallelism,|
|

260
00:08:31,110 --> 00:08:31,920
0,210 210,330 330,420 420,720 720,810
so that we can you
这样如果事务涉及不同的分片，

261
00:08:31,920 --> 00:08:35,490
0,1380 1770,2520 2520,2880 2880,3150 3150,3570
know {if,the,transaction} involve different shards,|
|

262
00:08:35,490 --> 00:08:38,310
0,1860 1860,2070 2070,2130 2130,2430 2430,2820
{you,know,disjoint - -} {set,of} shards,|
一组不相连的分片，|

263
00:08:38,580 --> 00:08:39,480
0,90 90,210 210,360 360,450 450,900
{you,know} they can be used
它们可以不相交，

264
00:08:39,480 --> 00:08:41,340
0,330 330,660 660,960 960,1350 1350,1860
disjoint,| {can,actually} proceed completely {in,parallel}.|
|可以完全并行地进行。|

265
00:08:42,860 --> 00:08:44,120
0,300 300,450 450,660 660,960 960,1260
{} So, as mentioned earlier,|
所以，正如前面提到的，|

266
00:08:44,120 --> 00:08:45,920
0,120 120,420 420,1410 1410,1710 1710,1800
we have {} {Paxos -}
我们每个分片有 Paxos 组，用于复制，

267
00:08:45,920 --> 00:08:48,580
0,270 270,390 390,1200
group per shard

268
00:08:52,920 --> 00:08:54,120
0,270 270,330 330,450 450,570 570,1200
{} you know for replication,|
|

269
00:08:54,120 --> 00:08:55,620
0,210 210,390 390,690 690,990 990,1500
but {you,know} Paxos actually provides
但是， Paxos 实际上给我们提供了额外的好处，

270
00:08:55,620 --> 00:08:57,300
0,390 570,1140 1140,1260 1260,1500 1500,1680
us {} you know {}

271
00:08:57,300 --> 00:08:59,160
0,390 390,540 540,630 630,1230 1260,1860
additional sort of benefit, {}|
|

272
00:08:59,850 --> 00:09:01,950
0,570 570,1140 1140,1560 1560,1770 1770,2100
{you,know,the} communication cost, right,| from
这个通信成本，|从 a 到 b 或从 b 到 c 的可能非常昂贵，

273
00:09:01,980 --> 00:09:02,760
0,150 150,270 270,510 510,660 660,780
a to b or from

274
00:09:02,760 --> 00:09:03,600
0,90 90,210 210,390 390,600 600,840
b to c might be

275
00:09:03,600 --> 00:09:05,730
0,180 180,420 420,1080 1290,1830 1830,2130
{} very expensive,| {} and
|看起来 Paxos 允许继续，

276
00:09:05,730 --> 00:09:07,170
0,420 420,510 510,630 630,1080 1080,1440
seems you know Paxos allows

277
00:09:07,170 --> 00:09:08,550
0,120 120,600 600,810 810,1110 1110,1380
to proceed,| or Raft allows
|或者 Raft 允许我们在只有多数的情况下继续，

278
00:09:08,550 --> 00:09:09,510
0,90 90,180 180,600 600,720 720,960
us to proceed with just

279
00:09:09,510 --> 00:09:11,010
0,30 30,720 870,1290 1290,1380 1380,1500
{} majority,| {} you know
|速度较慢的机器可能不会对性能产生太大影响，

280
00:09:11,010 --> 00:09:12,450
0,120 120,420 420,930 930,1140 1140,1440
the slow machine might actually

281
00:09:12,450 --> 00:09:13,770
0,210 210,450 450,660 660,900 900,1320
have not that much performance

282
00:09:13,770 --> 00:09:15,990
0,600 960,1290 1290,1800 1860,2130 2130,2220
impact,| and so we can
|所以我们可以很容易地容忍速度慢的机器，

283
00:09:15,990 --> 00:09:17,850
0,180 180,270 270,570 570,1410 1440,1860
sort of easily tolerate either

284
00:09:17,850 --> 00:09:19,800
0,330 330,900 930,1140 1140,1380 1380,1950
slow machines| or actually one
|或者一个数据中心停机，

285
00:09:19,800 --> 00:09:21,210
0,90 90,180 180,450 450,930 930,1410
you know data center {}

286
00:09:21,240 --> 00:09:22,180
0,330 330,480 480,870
being {} down,|
|

287
00:09:22,830 --> 00:09:25,170
0,600 750,1110 1110,1260 1260,1920 1920,2340
so {} the majority rule
所以，多数原则在两个方面帮助了我们，

288
00:09:25,170 --> 00:09:26,970
0,330 330,660 750,930 930,1140 1140,1800
helps us in two ways,|
|

289
00:09:27,700 --> 00:09:28,840
0,210 210,300 300,420 420,780 780,1140
you know we get {}
我们有了数据中心容错能力，

290
00:09:28,840 --> 00:09:32,320
0,300 300,930 1290,1680 1680,2460
data center fault tolerance,|
|

291
00:09:35,920 --> 00:09:39,060
0,720 720,900 900,1290 1290,1650
and [through] {slowness -}.|
并且绕过慢的（机器）。|

292
00:09:40,170 --> 00:09:41,160
0,660

293
00:09:41,480 --> 00:09:43,430
0,360 360,540 540,1020 1020,1620 1650,1950
The {} final goal, as
我们将更详细地看到的最终目标是，

294
00:09:43,430 --> 00:09:45,590
0,180 180,480 480,690 690,1620 1650,2160
we'll see in a little

295
00:09:45,590 --> 00:09:46,700
0,90 90,210 210,600 600,780 780,1110
bit more detail is that,|
|

296
00:09:46,940 --> 00:09:49,730
0,480 480,870 870,1470 1470,2130 2160,2790
{} a client of {}
一个 Spanner 的客户端，

297
00:09:50,030 --> 00:09:52,130
0,720 720,960 990,1680 1770,1950 1950,2100
{ -} Spanner,| so let's
|假设这里有一些使用 Spanner 的服务器，

298
00:09:52,130 --> 00:09:53,560
0,180 180,390 390,540 540,1200
say here's some server

299
00:09:54,460 --> 00:09:56,530
0,420 420,1050 1320,1590 1590,1770 1770,2070
{that,uses} Spanner,| {} would like
|希望是这样的，

300
00:09:56,530 --> 00:09:57,460
0,120 120,180 180,330 330,390 390,930
it to be the case,|
|

301
00:09:57,460 --> 00:09:58,630
0,360 360,510 510,630 630,810 810,1170
that you know this server
这台服务器可以使用近距离的 replica ，

302
00:09:58,630 --> 00:09:59,890
0,120 120,540 540,900 900,960 960,1260
can actually use a close

303
00:09:59,890 --> 00:10:00,700
0,540
replica,|
|

304
00:10:01,200 --> 00:10:03,330
0,510 510,900 1050,1290 1290,1980 1980,2130
and so the replica {you,know}
所以， replica 通常放的很近，

305
00:10:03,330 --> 00:10:04,880
0,450 450,570 570,1260
typically are placed

306
00:10:06,450 --> 00:10:09,240
0,840 870,1410 1410,2010 2100,2310 2310,2790
closed,| close to the clients
|靠近使用它们的客户端。

307
00:10:09,240 --> 00:10:10,170
0,150 150,210 210,390 390,600 600,930
that {actually -} use them.|
|

308
00:10:11,760 --> 00:10:12,990
0,150 150,420 420,540 540,840 840,1230
In fact, we'll see that,|
事实上，我们将看到，|

309
00:10:13,230 --> 00:10:15,780
0,510 510,750 750,1980 2070,2340 2340,2550
{read-only -} transactions can be
只读事务可以由本地 replica 执行，

310
00:10:15,780 --> 00:10:17,550
0,540 540,990 990,1320 1320,1440 1440,1770
executed basically by the local

311
00:10:17,550 --> 00:10:20,400
0,600 750,1350 1350,1590 1590,2310 2310,2850
replica,| without any communication to
|不用与其他数据中心进行任何通信。

312
00:10:20,400 --> 00:10:21,740
0,150 150,330 330,570 570,1080
the other data centers.|
|

313
00:10:22,210 --> 00:10:22,960
0,210 210,360 360,360 360,570 570,750
And when I talk about
当我谈到客户端时，

314
00:10:22,960 --> 00:10:25,030
0,570 660,870 870,1320 1620,1950 1950,2070
client,| {} here,| this is
|这里，|这通常是一些 Google 服务的后端服务器，

315
00:10:25,030 --> 00:10:27,370
0,840 840,1020 1020,1110 1110,1560 1680,2340
typically sort of the backend

316
00:10:27,370 --> 00:10:30,940
0,720 750,1410 1440,2430 2460,3090 3090,3570
servers of some Google service,|
|

317
00:10:30,970 --> 00:10:32,020
0,60 90,510 510,630 630,840 840,1050
for example, this might be
例如，这可能是 Gmail 服务器，

318
00:10:32,020 --> 00:10:34,360
0,180 180,960 990,1650 1650,1890 1890,2340
the Gmail server,| that's sitting
|它也位于某个数据中心，

319
00:10:34,690 --> 00:10:37,360
0,1320 1320,1860 1860,2010 2010,2250 2250,2670
{} {also,in} some data center,|
|

320
00:10:37,360 --> 00:10:38,590
0,420 420,690 690,780 780,990 990,1230
and maybe the same data
也许是同一个数据中心，

321
00:10:38,590 --> 00:10:39,520
0,330 330,450 450,750 750,840 840,930
center,| and talks to the
|并与那个数据中心中的 replica 进行通信，

322
00:10:39,520 --> 00:10:40,810
0,480 480,570 570,750 750,1050 1050,1290
replica in that particular data

323
00:10:40,810 --> 00:10:42,730
0,450 900,1080 1080,1170 1170,1440 1440,1920
centers,| and of course outside
|当然，再外面是真正的客户端，

324
00:10:42,730 --> 00:10:44,500
0,150 150,390 390,930 930,1110 1110,1770
are real clients,| like users
|比如读取邮件的用户。

325
00:10:45,640 --> 00:10:47,170
0,540 540,720 720,1200 1200,1470 1470,1530
you know {} read or

326
00:10:47,170 --> 00:10:47,940
0,240 240,690
write email.|
|

327
00:10:48,860 --> 00:10:50,180
0,660 690,840 840,1080 1080,1260 1260,1320
Okay, {any -} sort of
好的，关于这个高层组织架构，有什么问题吗？

328
00:10:50,180 --> 00:10:53,000
0,330 330,570 570,690 690,1560 1680,2820
questions about this high-level organization?|
|

329
00:11:01,470 --> 00:11:04,200
0,360 360,570 570,780 780,1650 2190,2730
Okay, let me {sort,of -}
好的，让我来列出一些挑战，

330
00:11:04,230 --> 00:11:06,420
0,570 600,1080 1110,1500 1500,1590 1590,2190
{ -} layout the challenges,|
|

331
00:11:06,420 --> 00:11:08,130
0,210 210,330 330,390 390,930 1050,1710
{} that I wanna focus
我在这节课中想要关注的，

332
00:11:08,130 --> 00:11:10,170
0,150 150,240 240,390 390,840 1470,2040
on in this lecture, {}|
|

333
00:11:10,820 --> 00:11:13,280
0,30 150,510 510,1080 1860,2220 2220,2460
{I mean\,,so} {really -} {sort,of}
所以，有三个主要挑战。

334
00:11:13,280 --> 00:11:15,400
0,570 570,960 960,1590
three main challenges.|
|

335
00:11:17,490 --> 00:11:20,580
0,450 450,1050 1440,2130 2310,2940 2940,3090
One is, {} {the,way} is
一是，就像我说的那样，

336
00:11:20,580 --> 00:11:21,450
0,180 180,420 420,600 600,780 780,870
it like I said,| we
|我们希望只读事务，

337
00:11:21,450 --> 00:11:22,800
0,180 180,240 240,570 570,750 750,1350
want to actually {read-only -}

338
00:11:22,800 --> 00:11:24,360
0,540 540,990 990,1230 1230,1470 1470,1560
transactions| without actually having to
|不需要与任何其他服务器通信，

339
00:11:24,360 --> 00:11:26,160
0,780 810,1320 1320,1500 1500,1650 1650,1800
communicate {} with any other

340
00:11:26,160 --> 00:11:27,990
0,570 810,1260 1260,1650 1650,1740 1740,1830
server,| {} but you know
|但我们要确保读取看到最新的写入，

341
00:11:27,990 --> 00:11:28,830
0,120 120,240 240,300 300,450 450,840
we got to make sure

342
00:11:28,830 --> 00:11:29,670
0,150 150,240 240,480 480,750 750,840
that the reads sees the

343
00:11:29,670 --> 00:11:30,720
0,300 300,720
latest write,|
|

344
00:11:47,960 --> 00:11:49,400
0,210 210,480 480,570 570,1050 1050,1440
this sort of classic {}
这种我们以前见过的典型的挑战，

345
00:11:49,430 --> 00:11:50,930
0,390 390,540 540,720 720,930 930,1500
challenge that we've seen before,|
|

346
00:11:50,930 --> 00:11:52,760
0,240 240,420 420,1170 1170,1500 1530,1830
{you,know} {zookeeper -},| {} zookeeper
比如 zookeeper ，|zookeeper 并没有真正直接面对挑战，

347
00:11:52,760 --> 00:11:55,010
0,300 300,810 1380,1830 1830,2010 2010,2250
{sort,of} avoid, doesn't really address

348
00:11:55,010 --> 00:11:56,180
0,90 90,360 360,600 600,810 810,1170
the challenge direct head on,|
|

349
00:11:56,180 --> 00:11:57,890
0,210 210,420 420,600 600,990 990,1710
and just like weaken consistency,|
只是弱一致性，|

350
00:11:58,340 --> 00:11:59,990
0,420 420,780 780,840 840,1140 1140,1650
but here in this {}
但在这个设计中，

351
00:11:59,990 --> 00:12:01,430
0,480 480,630 630,810 810,1020 1020,1440
design,| we'd like to arrange
|我们希望以一种方式安排，

352
00:12:01,430 --> 00:12:02,510
0,180 180,270 270,600 600,840 840,1080
in a way,| that actually
|它仍然保持线性一致性，

353
00:12:02,510 --> 00:12:04,610
0,90 90,750 900,1380 1380,1740 1740,2100
we still keep {linearizability -},|
|

354
00:12:04,610 --> 00:12:06,680
0,90 90,510 510,960 1470,1890 1890,2070
in fact, {you,know} Spanner shoot
事实上， Spanner 追求的是比线性一致性更强的性质。

355
00:12:06,680 --> 00:12:08,660
0,180 180,630 630,900 900,1530 1530,1980
for [] {} stronger property

356
00:12:08,660 --> 00:12:09,700
0,180 180,510 510,870
than {linearizability -}.|
|

357
00:12:10,940 --> 00:12:12,290
0,330 330,570 570,930 1020,1290 1290,1350
Second thing is,| {we -}
第二件事是，|我们希望支持，

358
00:12:12,290 --> 00:12:14,090
0,180 180,240 240,840 870,1440 1470,1800
want to support,| {} Spanner
|Spanner 想要支持跨分片的事务，

359
00:12:14,090 --> 00:12:16,340
0,270 270,570 570,1140 1140,1590 1590,2250
{wants,to} support transactions across shards,|
|

360
00:12:21,240 --> 00:12:22,770
0,390 390,870 870,1140 1140,1410 1410,1530
so {even,this,is} actually like we
所以即使我们执行一个银行转账，

361
00:12:22,770 --> 00:12:24,420
0,120 120,180 180,450 450,1170 1170,1650
do a bank transfer,| and
|一个账户在一个分片中，

362
00:12:24,510 --> 00:12:26,070
0,330 330,780 780,870 870,1080 1080,1560
one account in one shard,|
|

363
00:12:26,070 --> 00:12:27,360
0,90 90,270 270,750 750,840 840,1290
the other account, the destination
另一个账户，目标帐户，在另一个分片中，

364
00:12:27,360 --> 00:12:28,950
0,210 210,330 330,630 630,1080 1290,1590
account, there's another shard,| we
|我们想安排它，

365
00:12:28,950 --> 00:12:30,690
0,150 150,210 210,660 660,750 750,1740
want to {arrange,that},| you know
|它仍然可以像事务一样执行，并且具有 ACID 语义。

366
00:12:30,690 --> 00:12:32,820
0,210 210,1260 1290,1470 1470,1560 1560,2130
it still can be executed

367
00:12:32,820 --> 00:12:34,590
0,240 240,900 900,1020 1020,1350 1350,1770
{like,a} transaction and have ACID

368
00:12:34,890 --> 00:12:36,600
0,780
semantics.|
|

369
00:12:36,960 --> 00:12:38,670
0,600 600,690 690,840 840,1020 1020,1710
Finally, you know the transactions
最后，只读和读写的事务都必须是串行化的，

370
00:12:38,670 --> 00:12:40,860
0,270 270,540 540,780 780,1140 1140,2190
both {read-only -} ones and

371
00:12:40,890 --> 00:12:43,470
0,450 450,960 1020,1650 1650,1890 1890,2580
read-write ones must be serializable,|
|

372
00:12:45,420 --> 00:12:46,890
0,600 600,630 630,780 780,870 870,1470
{in,fact}, a little bit stronger
事实上，比可串行化的要强一点。

373
00:12:46,890 --> 00:12:48,460
0,150 180,930
than serializable.|
|

374
00:12:48,920 --> 00:12:51,040
0,60 60,480 480,630 630,960

375
00:12:53,150 --> 00:12:56,060
0,600 600,960 960,1200 1200,2070 2190,2910
And {you,know,we'll} see that, {}|
我们会看到，|

376
00:12:56,210 --> 00:12:57,350
0,360 360,480 480,570 570,660 660,1140
{} you know for this,
对于读写事务，

377
00:12:57,350 --> 00:12:59,630
0,120 120,210 210,720 1080,2040 2130,2280
you know for basically for

378
00:12:59,630 --> 00:13:01,100
0,120 120,330 330,540 540,1290 1290,1470
the {read-write -} transactions,| we're
|我们将使用两阶段锁，两阶段提交，

379
00:13:01,100 --> 00:13:01,910
0,120 120,180 180,360 360,480 480,810
going to use {2-phase -}

380
00:13:01,910 --> 00:13:04,520
0,480 480,600 600,810 810,1200 1560,2610
locking, {2-phase -} commit,| and
|我们在上一节课中谈到的两个协议。

381
00:13:04,550 --> 00:13:07,160
0,660 1080,1740 1740,2100 2100,2520 2520,2610
{the,protocol}, basically two protocol, that

382
00:13:07,160 --> 00:13:08,660
0,60 60,300 300,690 690,1320 1320,1500
we talked about {} in

383
00:13:08,660 --> 00:13:09,540
0,90 90,390 390,690
the last lecture.|
|

384
00:13:10,300 --> 00:13:11,470
0,330 330,660 720,960 960,1050 1050,1170
And so what I'd like
所以我首先想做的是谈谈读写事务，

385
00:13:11,470 --> 00:13:13,180
0,60 60,240 240,810 1020,1470 1470,1710
to do first is talk

386
00:13:13,180 --> 00:13:14,920
0,480 480,600 600,810 810,990 990,1740
about {} {read-write -} transactions|
|

387
00:13:15,190 --> 00:13:17,020
0,450 450,1020 1020,1500 1530,1770 1770,1830
and then {} talk in
然后更详细地讨论只读事务如何执行，

388
00:13:17,020 --> 00:13:19,630
0,180 180,930 930,1890 1920,2220 2220,2610
more detail how {read-only -}

389
00:13:19,630 --> 00:13:20,980
0,450 450,540 540,1020 1020,1200 1200,1350
transactions are executed,| so that
|它们可以非常高效地运行。

390
00:13:20,980 --> 00:13:23,650
0,300 480,660 660,1200 1320,2430 2430,2670
they can run {} very

391
00:13:23,650 --> 00:13:24,420
0,540
efficiently.|
|

392
00:13:27,370 --> 00:13:29,020
0,270 270,690 720,960 960,1140 1140,1650
Okay, so {read-write -} transactions|
好的，所以读写事务是|

393
00:13:29,020 --> 00:13:29,980
0,180 180,210 210,570 570,750 750,960
{you,know -} basically {2-phase -}
两阶段锁和两阶段提交。

394
00:13:29,980 --> 00:13:31,600
0,330 330,450 450,540 540,1050 1080,1620
locking and {2-phase -} {}

395
00:13:31,600 --> 00:13:32,380
0,480
commit.|
|

396
00:13:33,300 --> 00:13:34,860
0,570 600,960 960,1110 1110,1200 1200,1560
So hopefully this is pretty
所以希望这很容易理解，

397
00:13:35,610 --> 00:13:38,600
0,810 810,960 960,1650
easy to understand,|
|

398
00:13:42,650 --> 00:13:43,370
0,330 330,510 510,540 540,660 660,720
and {there -} going to
这将涉及到这些复杂的时序图，

399
00:13:43,370 --> 00:13:45,080
0,420 420,720 720,930 930,1320 1320,1710
involve these {sort,of} complex timing

400
00:13:45,080 --> 00:13:46,850
0,570 570,810 810,1260 1260,1530 1530,1770
diagrams,| that we looked at
|我们在上周看到的。

401
00:13:46,850 --> 00:13:50,390
0,1230 1230,1500 2220,2700 2700,3150 3270,3540
last week.| And so the
|所以它的设置方式，

402
00:13:50,390 --> 00:13:52,070
0,480 480,660 660,900 900,1320 1470,1680
way it's set up| and
|我要简化一下，

403
00:13:52,070 --> 00:13:53,630
0,870 870,990 990,1050 1050,1470 1470,1560
I'm going to simplify a

404
00:13:53,630 --> 00:13:54,500
0,240 270,510 510,660 660,750 750,870
bit,| looking at the way
|看看在 Spanner 中的设置方式，

405
00:13:54,500 --> 00:13:56,330
0,870 870,1050 1050,1230 1230,1680 1680,1830
it's set up in {}

406
00:13:56,330 --> 00:13:58,370
0,570 660,1140 1140,1650 1680,1980 1980,2040
Spanner,| is we have the
|我们有客户端，

407
00:13:58,370 --> 00:14:00,200
0,480 1080,1260 1260,1320 1320,1740 1740,1830
client,| and the client is
|客户端在某种程度上负责运行事务，

408
00:14:00,200 --> 00:14:01,400
0,360 360,450 450,540 540,990 990,1200
sort of in charge of

409
00:14:01,400 --> 00:14:03,500
0,270 270,600 600,720 720,1290 1470,2100
really running the transaction| and
|使用事务 manager ，事务库，

410
00:14:03,500 --> 00:14:06,290
0,330 330,750 750,1620 1680,2190 2190,2790
{use,the} transaction manager, transaction library,|
|

411
00:14:06,620 --> 00:14:08,840
0,690 780,1320 1320,1710 1710,1920 1920,2220
{} actually runs on the
运行在客户端机器上，

412
00:14:08,840 --> 00:14:12,020
0,270 270,1080 1710,2220 2220,2550 2550,3180
client machine,| and in charge
|负责安排这个事务，

413
00:14:12,050 --> 00:14:14,340
0,180 180,600 600,840 840,1740
of basically {you,know} orchestrate

414
00:14:14,670 --> 00:14:16,380
0,480 480,750 750,1200 1260,1410 1410,1710
{} this transaction,| and again
|再次，这里的客户端不是用户 Web 浏览器或 Gmail ，

415
00:14:16,380 --> 00:14:17,790
0,90 90,510 510,810 810,930 930,1410
the client here is not

416
00:14:17,790 --> 00:14:18,570
0,90 90,180 180,330 330,600 600,780
you know the user web

417
00:14:18,570 --> 00:14:20,790
0,570 570,930 1020,1530 1530,1770 1770,2220
browser or Gmail,| but basically
|而是数据中心的 Gmail 服务器，

418
00:14:20,790 --> 00:14:22,860
0,120 120,840 840,1410 1440,1920 1920,2070
the servers, {} server on,

419
00:14:22,860 --> 00:14:24,390
0,360 390,930 930,1380 1380,1440 1440,1530
the Gmail server in the

420
00:14:24,390 --> 00:14:26,250
0,240 240,690 810,1080 1080,1380 1380,1860
data center,| {} that's {the,client}
|这是 Spanner 的客户端。

421
00:14:26,250 --> 00:14:27,080
0,120 120,600
of Spanner.|
|

422
00:14:28,100 --> 00:14:29,210
0,150 150,270 270,480 480,990 990,1110
And so let's make the
所以让我们把这图简单一点，

423
00:14:29,210 --> 00:14:30,890
0,330 330,630 630,1140 1170,1560 1560,1680
picture reasonable simple,| {} so
|所以我们有两个分片而不是三、五个，

424
00:14:30,890 --> 00:14:32,210
0,210 210,330 330,480 480,1050 1050,1320
we have two shards instead

425
00:14:32,210 --> 00:14:34,580
0,90 90,630 870,1200 1200,1830 2100,2370
of three or five,| so
|所以我们有分片 A 和分片 B 。

426
00:14:34,580 --> 00:14:35,960
0,90 90,210 210,510 510,990 1020,1380
we have shard A and

427
00:14:35,960 --> 00:14:37,800
0,120 120,240 240,540 540,1020
we have shard B.|
|

428
00:14:38,000 --> 00:14:39,230
0,450 450,630 630,990 990,1110 1110,1230
And let's assume we're going
假设我们执行转账事务，

429
00:14:39,230 --> 00:14:41,900
0,510 540,870 870,1650 1680,1920 1920,2670
to just execute the transfer

430
00:14:41,930 --> 00:14:43,280
0,360 360,960 960,1020 1020,1230 1230,1350
{} transaction,| the same one
|和前面一样，

431
00:14:43,280 --> 00:14:44,330
0,120 120,600 600,870 870,990 990,1050
as before,| we're going to
|我们要从一个账户中减去一些钱，

432
00:14:44,330 --> 00:14:45,620
0,390 390,510 510,930 930,1110 1110,1290
deduct some money from one

433
00:14:45,620 --> 00:14:46,520
0,360 360,510 510,660 660,780 780,900
account,| then add it to
|然后把它加到另一个账户上。

434
00:14:46,520 --> 00:14:47,480
0,300 300,750
another account.|
|

435
00:14:48,690 --> 00:14:49,650
0,180 180,660 660,780 780,900 900,960
And initially, I'm going to
首先，我在没有时间戳的情况下讨论这个问题，

436
00:14:49,650 --> 00:14:50,640
0,180 180,390 390,570 570,720 720,990
talk about this {without -}

437
00:14:50,640 --> 00:14:52,620
0,90 90,330 330,870
the {timestamps -},|
|

438
00:14:57,690 --> 00:14:58,530
0,90 90,300 300,630 630,690 690,840
in some ways, you know
在某些方面，这么做的一个原因是，

439
00:14:58,530 --> 00:15:00,000
0,480 600,990 990,1260 1260,1350 1350,1470
the one reason to do

440
00:15:00,000 --> 00:15:01,140
0,270 270,450 450,750 750,1020 1020,1140
so is that,| actually for
|对于读写事务，时间戳并不是很重要，

441
00:15:01,140 --> 00:15:02,430
0,120 120,360 360,570 570,1050 1050,1290
the {read-write -} transaction, {timestamps

442
00:15:02,430 --> 00:15:04,050
0,270 270,360 360,780 780,1020 1020,1620
-} are not very important,|
|

443
00:15:04,560 --> 00:15:05,490
0,150 150,360 360,630 630,840 840,930
the {timestamps -} actually are
时间戳主要用于只读事务，

444
00:15:05,490 --> 00:15:07,020
0,570 570,870 870,1080 1080,1260 1260,1530
mostly there for {read-only -}

445
00:15:07,020 --> 00:15:08,520
0,720 870,1050 1050,1200 1200,1410 1410,1500
transactions,| and they need a
|它们需要对读写事务进行一些调整

446
00:15:08,520 --> 00:15:10,080
0,360 360,930 930,1050 1050,1320 1320,1560
little tweaking to the read-write

447
00:15:10,080 --> 00:15:12,270
0,660 660,990 1080,1800 1860,2040 2040,2190
transactions| to support {} the
|去支持只读事务，

448
00:15:12,270 --> 00:15:13,350
0,90 90,270 270,420 420,960 960,1080
{read-only - -} transactions,| and
|所以，时间戳在某种程度上也能漂移到读写事务，

449
00:15:13,350 --> 00:15:14,490
0,270 270,360 360,570 570,960 960,1140
therefore the {timestamps -} are

450
00:15:14,490 --> 00:15:17,850
0,300 720,1320 1710,2190 2190,2490 2520,3360
{sort,of} { -} in drifting

451
00:15:17,850 --> 00:15:19,560
0,360 360,540 540,720 720,1200 1200,1710
to {read-write -} transactions too,|
|

452
00:15:19,590 --> 00:15:21,090
0,360 360,630 630,870 870,1410 1410,1500
{} but in essence, you
但在本质上，读写事务是

453
00:15:21,090 --> 00:15:22,230
0,150 150,270 270,450 450,630 630,1140
know the {read-write -} transactions

454
00:15:22,230 --> 00:15:23,970
0,210 210,540 540,1140 1170,1500 1500,1740
are| basically straight {} {2-phase
|直接的两阶段锁和两阶段提交。

455
00:15:23,970 --> 00:15:25,080
0,240 240,630 630,780 780,900 900,1110
-} locking and {2-phase -}

456
00:15:25,080 --> 00:15:25,600
0,270
commit.|
|

457
00:15:26,610 --> 00:15:27,690
0,390 390,570 570,900 900,960 960,1080
So the client is going
所以，客户端将读取这些帐户，

458
00:15:27,690 --> 00:15:29,100
0,90 90,360 360,540 540,1050 1050,1410
to reads these accounts,| for
|假设读取 x ，

459
00:15:29,100 --> 00:15:31,140
0,450 450,660 660,1170 1170,1380 1980,2040
example, let's assume that you

460
00:15:31,140 --> 00:15:32,720
0,300 300,540 540,1230
know read x,|
|

461
00:15:33,220 --> 00:15:34,540
0,360 360,540 540,720 720,1170 1170,1320
{} so we just gonna
所以我们只需要做转账事务，

462
00:15:34,540 --> 00:15:35,980
0,120 120,240 240,630 630,1110 1110,1440
do the transfer transaction,| from
|转移钱，把 1 加到 x ，

463
00:15:35,980 --> 00:15:37,780
0,390 390,630 630,900 900,1260 1260,1800
moving money, {} adding {}

464
00:15:37,780 --> 00:15:38,980
0,240 240,390 390,960 960,1080 1080,1200
1 to x,| you know
|x 中减去 1 美元，

465
00:15:38,980 --> 00:15:42,070
0,750 750,1170 1860,2310 2310,2580 2580,3090
subtracting, {} subtracting 1 dollar

466
00:15:42,070 --> 00:15:43,630
0,210 210,510 510,720 720,1020 1020,1560
from x| and adding a
|y 中加入 1 美元，

467
00:15:43,630 --> 00:15:45,220
0,330 330,420 420,840 1290,1470 1470,1590
dollar to y,| it's going
|它将是 x ，

468
00:15:45,220 --> 00:15:46,180
0,90 90,240 240,690 690,810 810,960
to be x,| and let's
|我们假设 x 位于一个分片中，

469
00:15:46,180 --> 00:15:47,470
0,390 390,720 720,1020 1020,1230 1230,1290
assume that x sits in

470
00:15:47,470 --> 00:15:49,120
0,210 210,720 990,1230 1230,1350 1350,1650
one shard,| {} so it's
|所以，这将是一个跨分片事务，

471
00:15:49,120 --> 00:15:50,110
0,120 120,180 180,420 420,570 570,990
going to be a cross

472
00:15:50,110 --> 00:15:52,930
0,150 150,930 1290,1980 2100,2670 2670,2820
shard transaction,| and and you
|你必须读取 y ，

473
00:15:52,930 --> 00:15:55,270
0,120 120,270 270,540 540,1080 1530,2340
have to read of y,|
|

474
00:15:55,770 --> 00:15:57,640
0,690 690,1410
{} and,
将会有，

475
00:15:58,310 --> 00:15:59,340
0,720
{}

476
00:15:59,640 --> 00:16:01,260
0,330 330,480 480,960 990,1230 1230,1620
there's gonna be,| {} when
|当客户端执行这些读取操作时，

477
00:16:01,260 --> 00:16:03,960
0,90 90,450 450,900 900,1170 1170,2700
the client executes these {}

478
00:16:03,960 --> 00:16:05,160
0,210 210,810 810,960 960,1110 1110,1200
read operations,| they go to
|它们去分片，而分片保持着锁表，

479
00:16:05,160 --> 00:16:06,360
0,120 120,510 510,660 660,960 960,1200
the shards and shards actually

480
00:16:06,360 --> 00:16:09,720
0,780 1440,2130 2160,2700
keep lock table,|
|

481
00:16:10,090 --> 00:16:11,800
0,210 210,390 390,540 540,1170 1170,1710
and so they record basically
所以它们记录了这个事务，

482
00:16:11,800 --> 00:16:13,450
0,210 210,1020 1050,1140 1140,1260 1260,1650
this transaction,| you know so
|我们假设这个事务 TID ，

483
00:16:13,450 --> 00:16:14,650
0,180 180,300 300,510 510,630 630,1200
let's say this is transaction,

484
00:16:14,650 --> 00:16:16,340
0,390 390,570 570,1140
whatever {TID -},|
|

485
00:16:16,620 --> 00:16:18,510
0,810 810,1110 1110,1260 1260,1410 1410,1890
{} and they're gonna record
它们会记录下来， x 被拥有，

486
00:16:18,510 --> 00:16:20,250
0,420 450,570 570,720 720,1020 1020,1740
that you know the {x,is}

487
00:16:20,250 --> 00:16:21,660
0,300 450,630 630,930
owned you know,|
|

488
00:16:22,050 --> 00:16:23,670
0,330 330,630 630,900 900,1080 1080,1620
lock table actually owned by
锁表实际上由客户端拥有，

489
00:16:23,700 --> 00:16:25,290
0,90 90,720 720,810 810,1260 1260,1590
the client,| you know and
|y 由客户端拥有，

490
00:16:25,290 --> 00:16:26,790
0,150 150,990 990,1260 1260,1440 1440,1500
here {is,y} owned by the

491
00:16:26,790 --> 00:16:29,190
0,600 1320,1830 1830,2160 2160,2310 2310,2400
client,| and that sort of
|这是一种我们之前见过的标准。

492
00:16:29,190 --> 00:16:31,350
0,330 360,660 660,1620 1620,1980 1980,2160
a very standard {you,know,we've} seen

493
00:16:31,350 --> 00:16:32,100
0,540
before.|
|

494
00:16:32,630 --> 00:16:33,800
0,120 120,270 270,600 660,990 990,1170
You know the thing that
这里略有不同，

495
00:16:33,800 --> 00:16:36,560
0,180 180,930 930,1290 1290,1680 1680,2760
is slightly different here,| and
|在这里没有完全画出来的是，

496
00:16:36,770 --> 00:16:38,180
0,540 540,810 810,1110 1110,1230 1230,1410
not fully drawing it out

497
00:16:38,180 --> 00:16:39,590
0,300 300,480 480,810 1020,1290 1290,1410
here is that,| when we're
|当我们说分片 A 时，

498
00:16:39,590 --> 00:16:41,240
0,420 420,570 570,810 810,1200 1200,1650
talking to one shard A,|
|

499
00:16:41,300 --> 00:16:43,220
0,420 420,870 930,1110 1110,1650 1650,1920
shard A is really one
分片 A 是这些 Paxos 组的一个，

500
00:16:43,220 --> 00:16:44,520
0,90 90,270 270,630 630,1140
of these Paxos groups,|
|

501
00:16:44,800 --> 00:16:45,850
0,240 240,390 390,570 570,630 630,1050
and so {it,has - -}
所以，它有三个，

502
00:16:45,850 --> 00:16:47,830
0,90 90,240 240,780 780,1980 1980,1980
you know three { -},|
|

503
00:16:48,100 --> 00:16:49,180
0,270 270,540 540,690 690,960 960,1080
{} in this case, you
在这种情况下，一个三节点的组，

504
00:16:49,180 --> 00:16:51,130
0,150 150,1350 1350,1710 1710,1770 1770,1950
know a group of three

505
00:16:51,130 --> 00:16:53,770
0,510 840,1470 1590,2010 2010,2220 2220,2640
peers,| and {so,SA - -}
|所以， SA 是一个复制服务器，包含多个节点，

506
00:16:53,800 --> 00:16:57,460
0,330 330,1170 1320,2580 2580,3240 3240,3660
really {a,replicated} {} servers consisting

507
00:16:57,460 --> 00:16:59,860
0,120 120,480 480,990 1440,2160 2190,2400
of multiple peers,| in when
|在执行只读事务时，

508
00:16:59,860 --> 00:17:01,900
0,480 480,600 600,840 840,1530 1680,2040
executing {read-only -} transaction,| we're
|我们要访问那些节点的领导者，

509
00:17:01,900 --> 00:17:02,710
0,150 150,240 240,540 540,630 630,810
gonna be talking to the

510
00:17:02,710 --> 00:17:04,000
0,480 480,750 750,930 930,1170 1170,1290
leader of that peers,| so
|所以，如果你从 Raft 的角度考虑，

511
00:17:04,000 --> 00:17:04,720
0,90 90,180 180,390 390,450 450,720
if you think in {terms,of}

512
00:17:04,720 --> 00:17:05,770
0,330 330,720 720,810 810,900 900,1050
Raft style,| you can just
|你可以想一想，

513
00:17:05,770 --> 00:17:07,480
0,150 150,390 390,600 840,1260 1260,1710
think about it,| {} the
|读请求到达 Paxos 组的领导者。

514
00:17:07,510 --> 00:17:09,070
0,240 240,720 720,1020 1020,1260 1260,1560
read request goes to the

515
00:17:09,100 --> 00:17:12,400
0,630 630,930 930,1500 1980,2640 2820,3300
leader of the {} Paxos

516
00:17:12,400 --> 00:17:12,920
0,450
group.|
|

517
00:17:13,760 --> 00:17:17,690
0,420 810,1350 1500,2310 2340,2970 2970,3930
And, {} another,| {} so
还有另一个，|所以每次我在这里为 SA 或 SB 画一个箭头，

518
00:17:17,690 --> 00:17:18,440
0,180 180,420 420,510 510,690 690,750
every time I sort of

519
00:17:18,440 --> 00:17:19,640
0,240 240,450 450,630 630,930 930,1200
draw this one single arrow

520
00:17:19,640 --> 00:17:22,040
0,270 270,750 750,1260 1260,1800 1800,2400
here for SA or {for,SB},|
|

521
00:17:22,100 --> 00:17:23,510
0,570 570,900 900,1050 1050,1260 1260,1410
{you,know} it's a much more
这是一个复杂得多的故事，

522
00:17:23,510 --> 00:17:26,060
0,720 1290,1740 1740,2100 2100,2280 2280,2550
complicated story,| particularly when writes
|尤其是当涉及到写入时，

523
00:17:26,060 --> 00:17:27,470
0,120 120,600 750,1020 1020,1290 1290,1410
get involved,| {because,writes -} actually
|因为写入要经过 Paxos 或 Raft 组。

524
00:17:27,470 --> 00:17:29,000
0,120 120,210 210,480 480,1260 1260,1530
going to go through the

525
00:17:29,000 --> 00:17:30,540
0,570 570,900 900,1200
{Paxos,or} Raft group.|
|

526
00:17:31,480 --> 00:17:32,700
0,600

527
00:17:33,100 --> 00:17:35,350
0,360 390,630 630,1230 1410,2070 2070,2250
The {read-only -} {} or
只读或锁表不是复制的，

528
00:17:35,350 --> 00:17:37,180
0,330 330,660 660,870 870,1170 1170,1830
lock tables actually not replicated,|
|

529
00:17:37,270 --> 00:17:39,520
0,930 930,1290 1290,1440 1440,2070 2070,2250
{} it is stored at
它存储在 Paxos 组的领导者处，

530
00:17:39,520 --> 00:17:41,740
0,120 120,720 720,1230 1230,1650 1680,2220
the leader of the Paxos

531
00:17:41,770 --> 00:17:44,200
0,840 1320,1860 1860,1950 1950,2040 2040,2430
group,| and if the leader
|如果领导者在事务过程中停机，

532
00:17:44,200 --> 00:17:46,090
0,210 210,690 690,1080 1080,1170 1170,1890
goes down during the transaction,|
|

533
00:17:46,330 --> 00:17:48,370
0,450 450,1140 1170,1860 1860,1980 1980,2040
{} then {} you know
那么事务必须重新开始，

534
00:17:48,370 --> 00:17:49,450
0,330 330,420 420,870 870,990 990,1080
basically the transaction has to

535
00:17:49,450 --> 00:17:50,920
0,150 150,720 720,960 960,1080 1080,1470
be restarted,| where the transaction
|事务将被中止，

536
00:17:50,920 --> 00:17:52,690
0,150 150,240 240,810 990,1530 1530,1770
will be aborted,| {} because
|因为锁信息丢失了。

537
00:17:52,690 --> 00:17:54,160
0,90 90,330 330,810 810,930 930,1470
the lock information is lost.|
|

538
00:17:55,320 --> 00:17:57,570
0,540 960,1350 1350,1530 1530,1950 1950,2250
The reason that these lock
这些锁表不是复制的原因，

539
00:17:57,570 --> 00:18:00,990
0,300 300,480 480,1020 1020,1980 2790,3420
table is not, { -

540
00:18:01,880 --> 00:18:03,620
0,240 240,720 720,900 900,990 990,1740
-} is not the replica,|
|

541
00:18:03,620 --> 00:18:05,240
0,150 150,360 360,810 810,1380
{this,is,make} read operation fast.|
这使读操作很快。|

542
00:18:05,840 --> 00:18:07,730
0,300 300,750 1110,1650 1650,1800 1800,1890
Okay, so once you know
好的，一旦客户端得到了 x 和 y 的值，

543
00:18:07,730 --> 00:18:08,700
0,660
the

544
00:18:08,970 --> 00:18:11,130
0,420 420,630 630,720 720,1020 1020,2160
client actually has gotten the

545
00:18:11,220 --> 00:18:13,320
0,1020 1020,1140 1140,1320 1320,1440 1440,2100
values of x and y,|
|

546
00:18:13,320 --> 00:18:14,310
0,330 330,450 450,750 750,900 900,990
and it's taken out the
它去掉锁，使用两阶段锁的风格，

547
00:18:14,310 --> 00:18:15,420
0,510 510,630 630,870 870,1050 1050,1110
locks you know sort of

548
00:18:15,420 --> 00:18:18,990
0,390 390,660 660,1290 1470,2310 2970,3570
2-phase locking style,| the {}
|它将从 x 减去 1 ， y 加上 1 ，

549
00:18:18,990 --> 00:18:21,300
0,300 300,840 1050,1680 1680,1980 1980,2310
it's gonna subtract one from

550
00:18:21,300 --> 00:18:22,740
0,420 420,510 510,690 690,900 900,1440
x, you know add one

551
00:18:22,740 --> 00:18:24,840
0,90 90,360 480,1260 1500,1950 1950,2100
you know {to,y},| and then
|然后提交这个事务。

552
00:18:24,840 --> 00:18:26,010
0,270 270,420 420,480 480,1050 1080,1170
basically going to submit the

553
00:18:26,010 --> 00:18:26,840
0,630
transaction.|
|

554
00:18:27,430 --> 00:18:28,480
0,210 210,450 450,690 690,930 930,1050
{} So basically all the
所以，所有写入都在客户端本地完成，

555
00:18:28,480 --> 00:18:29,740
0,270 270,390 390,600 600,1110 1110,1260
writes are done locally at

556
00:18:29,740 --> 00:18:31,390
0,420 450,930 930,1230 1230,1350 1350,1650
the client,| again so this
|同样，这是 Gmail 服务器，

557
00:18:31,390 --> 00:18:33,700
0,120 120,240 240,690 690,1350 1590,2310
is the Gmail server, {}|
|

558
00:18:33,700 --> 00:18:35,290
0,630 630,810 810,1200 1200,1380 1380,1590
and {} one [] thing
一件[]事是，

559
00:18:35,290 --> 00:18:37,240
0,300 300,1320 1350,1650 1650,1740 1740,1950
is,| {} {when,the,client} is done
|当客户端完成事务时，

560
00:18:37,240 --> 00:18:38,890
0,210 210,750 750,840 840,1170 1170,1650
with transaction,| it submits transaction
|它将事务提交给 Spanner ，

561
00:18:38,890 --> 00:18:41,880
0,330 330,1050 1860,2130 2130,2700
to {} to Spanner,|
|

562
00:18:42,320 --> 00:18:44,990
0,510 780,1320 1560,1770 1770,2190 2190,2670
and {} it submits to
它提交给事务协调者，

563
00:18:44,990 --> 00:18:46,640
0,90 90,570 570,1350
a transaction coordinator,|
|

564
00:18:48,600 --> 00:18:50,220
0,480 480,1050 1200,1350 1350,1470 1470,1620
so some you know set
所以，一些服务器或一些机器，

565
00:18:50,220 --> 00:18:51,990
0,90 90,690 720,1500 1500,1680 1680,1770
of servers {} you know

566
00:18:51,990 --> 00:18:53,670
0,270 360,690 690,1200 1200,1440 1440,1680
or some machines| you pick
|你选择作为事务协调者，

567
00:18:53,670 --> 00:18:55,530
0,210 210,360 360,750 750,1500 1710,1860
as the transaction coordinator,| and
|同样，事务协调者也是 Paxos 组，

568
00:18:55,530 --> 00:18:57,270
0,450 450,570 570,960 960,1560 1560,1740
again the transaction coordinator is

569
00:18:57,270 --> 00:18:59,040
0,420 420,840 1290,1440 1440,1620 1620,1770
Paxos group,| {as,I} said, it's
|如我所说，它是在不同数据中心的多个节点。

570
00:18:59,040 --> 00:19:02,280
0,810 840,2220 2220,2760 2790,2970 2970,3240
multiple pears in {} different

571
00:19:02,280 --> 00:19:03,160
0,210 210,690
data centers.|
|

572
00:19:03,890 --> 00:19:05,810
0,360 420,780 780,1170 1170,1650 1650,1920
And one reason we want
我们希望这是一个 Paxos 组的一个原因是，

573
00:19:05,810 --> 00:19:06,680
0,150 150,270 270,420 420,480 480,870
this to be a Paxos

574
00:19:06,680 --> 00:19:08,930
0,570 750,1080 1080,1230 1230,1680 2040,2250
group is,| so that as
|正如我们之前看到的，

575
00:19:08,930 --> 00:19:11,060
0,510 510,750 750,1260 1260,1680 1680,2130
we've seen before,| {in,2-phase -}
|在两阶段协议或两阶段提交中，

576
00:19:11,060 --> 00:19:12,680
0,660 690,900 900,990 990,1320 1320,1620
protocol or the 2-phase commit,|
|

577
00:19:12,830 --> 00:19:15,290
0,300 300,510 510,780 780,1740 1740,2460
that if the coordinator fails,|
如果协调者失败了，|

578
00:19:15,560 --> 00:19:17,780
0,210 210,420 420,720 720,1350 1380,2220
it might actually block {}
它可能会阻止参与者，

579
00:19:17,810 --> 00:19:19,850
0,330 330,990 990,1320 1320,1440 1440,2040
the participants, right,| if participants
|如果参与者已经准备好并同意进行事务，

580
00:19:19,850 --> 00:19:21,530
0,330 330,990 990,1200 1200,1590 1590,1680
have prepared and agreed to

581
00:19:21,530 --> 00:19:23,030
0,210 210,660 660,840 840,930 930,1500
go along with the transaction,|
|

582
00:19:23,240 --> 00:19:24,560
0,180 180,330 330,420 420,900 900,1320
but then the coordinator fails,|
但如果协调者失败了，|

583
00:19:24,560 --> 00:19:25,910
0,150 150,330 330,690 690,1050 1080,1350
{you,knwo} those {participants -} have
这些参与者必须持有它们的锁，

584
00:19:25,910 --> 00:19:26,750
0,60 60,360 360,510 510,600 600,840
to hold on to their

585
00:19:26,750 --> 00:19:28,220
0,360 540,960 960,1140 1140,1230 1230,1470
locks,| and have to wait
|必须等到协调者回来，

586
00:19:28,220 --> 00:19:30,740
0,330 330,690 1020,1890 1890,2100 2100,2520
until the coordinator comes back,|
|

587
00:19:30,800 --> 00:19:33,200
0,420 420,1110 1110,1410 1440,2160 2160,2400
by replicating the coordinator using
通过使用 Paxos 复制协调者，

588
00:19:33,200 --> 00:19:35,510
0,720 930,1290 1290,1440 1440,1620 1620,2310
Paxos,| and we make the
|我们使协调者高可用，

589
00:19:35,600 --> 00:19:37,580
0,600 600,990 990,1560 1560,1710 1710,1980
coordinator highly available,| and so
|从而避免那种灾难情景。

590
00:19:37,580 --> 00:19:40,730
0,570 1170,1800 1800,1980 1980,2700 2760,3150
basically avoid that particular sort

591
00:19:40,730 --> 00:19:42,120
0,60 60,660 660,1320
of disaster scenario.|
|

592
00:19:43,340 --> 00:19:46,190
0,540 1080,1320 1320,1590 1590,2010 2010,2850
Okay?| So the transaction coordinators,|
好的?|所以，事务协调者，|

593
00:19:46,190 --> 00:19:47,300
0,180 180,540 540,600 600,930 930,1110
then basically in charge of
负责运行两阶段提交协议，

594
00:19:47,300 --> 00:19:48,620
0,450 450,600 600,780 780,1050 1050,1320
running the {2-phase -} commit

595
00:19:48,620 --> 00:19:50,480
0,630 930,1290 1290,1440 1440,1560 1560,1860
protocol,| and so it will
|它将发送 x 和 y 的更新到分片 A 的领导者，

596
00:19:50,480 --> 00:19:52,970
0,330 330,1650 1650,2100 2100,2250 2250,2490
send {you,know,the} updates for {x,and}

597
00:19:52,970 --> 00:19:54,340
0,600 600,1110
y to

598
00:19:55,060 --> 00:19:57,580
0,570 690,1320 1320,1710 1710,2040 2040,2520
the leader of shard A,|
|

599
00:19:57,670 --> 00:19:59,290
0,510 510,810 810,1140 1140,1410 1410,1620
{} x y to the
（发送） x y 到分片 B 的领导者，

600
00:19:59,320 --> 00:20:01,420
0,540 540,1020 1050,1260 1260,1560 1560,2100
leaders of {} shard B,|
|

601
00:20:01,780 --> 00:20:02,860
0,780

602
00:20:03,390 --> 00:20:04,770
0,480 510,870 870,960 960,1110 1110,1380
the they you know grab
它们获取锁，

603
00:20:04,770 --> 00:20:05,700
0,90 90,600 600,720 720,810 810,930
the locks,| {you,know} in this
|在这种情况下，

604
00:20:05,700 --> 00:20:07,560
0,390 390,480 480,660 660,1350 1740,1860
case, you know,| {} you
|它们已经持有锁，

605
00:20:07,560 --> 00:20:09,120
0,120 120,480 480,750 750,960 960,1560
know they already hold {the,locks},|
|

606
00:20:09,120 --> 00:20:10,980
0,420 450,930 930,1290 1290,1710 1710,1860
or promote locks write, {read-write
或升级为读写锁，

607
00:20:10,980 --> 00:20:15,090
0,210 210,750 1170,2040 2070,3150 3150,4110
-} locks,| and basically prepare
|准备事务，

608
00:20:15,210 --> 00:20:16,470
0,690 690,840 840,900 900,1080 1080,1260
{you,know,transaction},| so they don't really
|所以它们还没有执行它，

609
00:20:16,470 --> 00:20:18,180
0,540 540,870 870,1290 1290,1500 1500,1710
{execute,it} yet,| but just make
|只是，通常使用预写式日志，

610
00:20:18,180 --> 00:20:20,760
0,480 720,840 840,1680 2010,2340 2340,2580
the, you know typically using

611
00:20:20,760 --> 00:20:21,810
0,180 180,360 360,780 780,900 900,1050
{write-ahead -} logging,| you know
|准备修改，

612
00:20:21,810 --> 00:20:24,360
0,750 750,930 930,1590 1920,2460 2460,2550
prepared to changes,| and if
|如果一切都好的话，

613
00:20:24,360 --> 00:20:26,820
0,270 270,360 360,960 1020,1470 1470,2460
everything is okay,| then they
|然后，它们提交事务，

614
00:20:26,850 --> 00:20:28,950
0,900 990,1230 1230,1740 1770,1980 1980,2100
basically {} commit to the

615
00:20:28,950 --> 00:20:31,200
0,450 450,960 1200,1740 1740,2070 2070,2250
transaction| by {} entering sort
|通过进入这种准备状态，

616
00:20:31,200 --> 00:20:32,500
0,60 60,240 240,690 690,1080
of this prepared state,|
|

617
00:20:35,460 --> 00:20:36,360
0,240 240,360 360,480 480,690 690,900
and this is {sort,of,a} big
这是一个重要的时刻，

618
00:20:36,360 --> 00:20:37,500
0,600
moment,|
|

619
00:20:37,750 --> 00:20:39,220
0,390 390,630 630,720 720,900 900,1470
{} because at this point,|
因为在这一点上，|

620
00:20:39,430 --> 00:20:41,380
0,150 150,930 930,1260 1260,1470 1470,1950
the transaction is {} appears,|
事务出现，|

621
00:20:41,380 --> 00:20:43,300
0,120 300,1110 1110,1440 1440,1830 1830,1920
when participants are committed to
当参与者提交给这个事务时，

622
00:20:43,300 --> 00:20:45,340
0,360 390,1290 1290,1470 1470,1590 1590,2040
this transaction,| and we know
|我们从上节课中知道，

623
00:20:45,460 --> 00:20:46,720
0,240 240,540 540,930 930,1020 1020,1260
from last lecture,| you know
|参与者必须记录状态，

624
00:20:46,720 --> 00:20:48,310
0,630 630,1140 1140,1260 1260,1500 1500,1590
the participants do actually have

625
00:20:48,310 --> 00:20:50,140
0,90 90,630 630,1200 1350,1590 1590,1830
to record state,| so that
|如果它们失败了，它们又回来，

626
00:20:50,140 --> 00:20:51,340
0,210 210,390 390,960 960,1110 1110,1200
if they fail and they

627
00:20:51,340 --> 00:20:52,750
0,120 120,390 390,570 570,780 780,1410
come back up,| they can
|它们可以恢复从它们停止的地方重新开始，

628
00:20:52,750 --> 00:20:53,980
0,360 360,480 480,660 660,900 930,1230
recover and pick up from

629
00:20:53,980 --> 00:20:55,930
0,270 270,390 390,660 660,960 1440,1950
where they left off,| so,
|所以，在准备状态下，

630
00:20:55,960 --> 00:20:57,700
0,270 270,450 450,540 540,1410 1410,1740
{} at the prepared state,|
|

631
00:20:57,700 --> 00:20:59,380
0,390 390,570 570,1050 1050,1530 1530,1680
basically this results into a
这会导致 Paxos 写入，

632
00:20:59,380 --> 00:21:00,420
0,390 390,930
Paxos write,|
|

633
00:21:04,370 --> 00:21:05,600
0,210 210,780 780,870 870,1140 1140,1230
{you,know} recording the state of
记录事务状态和 2PC 状态，

634
00:21:05,600 --> 00:21:08,930
0,90 90,900 1170,2250 2250,3180 3180,3330
the transaction {} and {2PC

635
00:21:08,930 --> 00:21:14,120
0,390 390,1110 3450,4290 4290,4290 4290,5190
-} {state -}| {} {the,logs}
|以及参与者持有的日志，等等，

636
00:21:14,330 --> 00:21:18,470
0,690 1860,2580 2580,3120 3150,3690 3690,4140
that participate holding, etc etc,|
|

637
00:21:18,500 --> 00:21:20,210
0,180 180,600 720,1080 1080,1380 1380,1710
and so {} this Paxos
所以这个 Paxos 写入，

638
00:21:20,210 --> 00:21:22,160
0,480 750,870 870,1200 1200,1740 1770,1950
write,| so the leader of
|所以这个分片的领导者，

639
00:21:22,160 --> 00:21:23,660
0,180 180,510 510,870 870,1440 1440,1500
this particular shard,| there's a
|有一个推 Paxos 写入到组中的不同节点，

640
00:21:23,660 --> 00:21:25,670
0,480 480,480 480,1170 1170,1440 1440,2010
[push] {} Paxos write across

641
00:21:25,670 --> 00:21:27,470
0,120 120,330 330,540 540,1170 1260,1800
you know the different peers

642
00:21:27,470 --> 00:21:29,030
0,90 90,150 150,600 810,1080 1080,1560
in the group| to ensure
|以确保状态复制，具有容错能力，

643
00:21:29,030 --> 00:21:31,040
0,480 510,900 900,1260 1260,1380 1380,2010
that {} state is replicated,

644
00:21:31,040 --> 00:21:31,880
0,210 210,720
fault tolerant,|
|

645
00:21:33,480 --> 00:21:35,610
0,630 1050,1380 1380,1920 1920,2010 2010,2130
{} so once you know
所以一旦参与者准备好，同意准备好，

646
00:21:35,610 --> 00:21:36,540
0,630
the,

647
00:21:36,780 --> 00:21:39,450
0,690 840,1410 1410,2010 2040,2580 2580,2670
the participants have prepared and

648
00:21:39,450 --> 00:21:41,310
0,270 270,330 330,930 1200,1770 1770,1860
agreed to prepared,| then you
|然后它们发回 ok ，

649
00:21:41,310 --> 00:21:42,810
0,120 120,210 210,390 390,810 810,1500
know they sent back ok,|
|

650
00:21:42,840 --> 00:21:44,900
0,150 150,630 690,1530
you know, ok,
ok 跟我们之前讨论的两阶段协议很像，

651
00:21:45,560 --> 00:21:46,640
0,240 240,390 390,630 630,930 930,1080
this is very similar {2-phase

652
00:21:46,640 --> 00:21:47,990
0,300 330,690 690,780 780,1200 1200,1350
- -} {protocol -} that

653
00:21:47,990 --> 00:21:50,180
0,60 60,300 300,870 1200,1890 1890,2190
we talked before,| and at
|在这一点上，协调者可以提交，

654
00:21:50,180 --> 00:21:51,260
0,180 180,660 660,750 750,870 870,1080
this point, you know the

655
00:21:51,260 --> 00:21:52,880
0,510 510,600 600,1080
coordinator can commit,|
|

656
00:21:55,180 --> 00:21:56,260
0,120 120,180 180,540 540,750 750,1080
and of course the point
当然，要提交的点，

657
00:21:56,260 --> 00:21:58,120
0,60 60,510 660,720 720,720 1260,1860
to commit,| the {} coordinator
|具有一些记录的协调者做出提交的决定，

658
00:21:58,120 --> 00:21:59,590
0,180 180,900 900,1170 1170,1380 1380,1470
with {some,record} actually made the

659
00:21:59,590 --> 00:22:01,360
0,300 300,930 960,1590 1590,1680 1680,1770
commit decision,| because {that -}
|因为参与者可能晚些时候回来，

660
00:22:01,360 --> 00:22:02,830
0,480 480,630 630,960 960,1230 1230,1470
participants may come back later,|
|

661
00:22:02,830 --> 00:22:03,640
0,90 90,210 210,300 300,690 690,810
and want to know and
知道并发现这一点，

662
00:22:03,640 --> 00:22:04,660
0,210 210,360 360,660 660,780 780,1020
find out about it,| and
|我们可能会失败，

663
00:22:04,660 --> 00:22:06,490
0,390 390,540 540,660 660,1110 1560,1830
we might have failures,| so
|所以， Paxos 状态或两阶段提交状态

664
00:22:06,490 --> 00:22:08,380
0,570 600,720 720,1080 1080,1560 1560,1890
again the Paxos state {or,the}

665
00:22:08,650 --> 00:22:10,570
0,840 840,960 960,1200 1200,1440 1440,1920
PC {2-phase -} commit state|
|

666
00:22:10,690 --> 00:22:13,810
0,540 540,810 810,1350 1350,2340 2370,3120
{} is written {} to
写入使用 Paxos ，复制使用 Paxos 。

667
00:22:13,810 --> 00:22:16,900
0,300 300,930 1320,1590 1590,2340 2550,3090
using Paxos and replicated using

668
00:22:16,900 --> 00:22:17,540
0,570
Paxos.|
|

669
00:22:18,790 --> 00:22:21,130
0,240 240,360 360,1080 1110,1680 1680,2340
And from this whole presentation,|
从整个介绍来看，|

670
00:22:21,130 --> 00:22:22,030
0,150 150,270 270,450 450,600 600,900
you can just think about
你可以把 Paxos 看作是

671
00:22:22,030 --> 00:22:24,010
0,330 330,480 480,720 720,1230 1260,1980
Paxos as| being complete substitute
|Raft 的完全替代品或等价物，

672
00:22:24,010 --> 00:22:25,840
0,150 150,660 660,780 780,1320 1350,1830
or equivalent to Raft,| you
|Spanner 在 Raft 之前，

673
00:22:26,200 --> 00:22:29,950
0,540 1500,2130 2130,2730 2730,3570 3570,3750
know Spanner predates Raft,| but
|但是从感觉上，[]，

674
00:22:29,950 --> 00:22:31,750
0,330 330,570 570,1260 1260,1680 1680,1800
{like,you,know} for perceptually and you

675
00:22:31,750 --> 00:22:33,640
0,150 150,330 330,600 600,1140 1290,1890
know through {[] -}, {}|
|

676
00:22:33,640 --> 00:22:34,360
0,120 120,180 180,300 300,420 420,720
you know for this paper
对于这篇论文来说，基本上是一样的。

677
00:22:34,360 --> 00:22:35,660
0,270 270,660 660,750 750,1110
is basically the same.|
|

678
00:22:36,630 --> 00:22:37,800
0,570

679
00:22:38,150 --> 00:22:39,740
0,480 750,990 990,1200 1200,1380 1380,1590
So this point is actually
所以这一点提交，

680
00:22:39,740 --> 00:22:41,750
0,330 330,750 750,1200 1200,1500 1500,2010
commits,| this {you,know,is} really commit,|
|这个是提交，|

681
00:22:42,080 --> 00:22:45,020
0,150 150,480 480,1680 1710,2340 2340,2940
which once {} transaction coordinator
一旦事务协调器写下事务已提交，

682
00:22:45,020 --> 00:22:46,970
0,150 150,420 420,990 990,1530 1530,1950
has written down the transaction

683
00:22:46,970 --> 00:22:48,890
0,120 120,630 930,1500 1500,1770 1770,1920
is committed,| {} that is
|这就是提交点，

684
00:22:48,890 --> 00:22:50,750
0,540 540,870 870,1440 1440,1710 1710,1860
{} actual {commit,point},| and then
|然后通知它们的参与者，

685
00:22:50,750 --> 00:22:52,520
0,630 630,720 720,840 840,1050 1050,1770
informs you know their participants,|
|

686
00:22:52,520 --> 00:22:53,880
0,120 120,390
you know
这发生了，

687
00:22:55,000 --> 00:22:57,980
0,210 210,450 450,1230
that has happened,|
|

688
00:22:58,650 --> 00:22:59,610
0,420 420,540 540,690 690,840 840,960
and you know they're going
它们将回复 ok ，事务已经提交，

689
00:22:59,610 --> 00:23:01,170
0,60 60,420 420,750 750,990 990,1560
to respond back, {you,know} ok,

690
00:23:01,170 --> 00:23:02,820
0,420 420,840 840,930 930,1440 1440,1650
great, transaction is committed,| and
|事务协调器可以清理它的状态，

691
00:23:02,820 --> 00:23:04,200
0,120 120,540 540,1050 1050,1170 1170,1380
the transaction coordinator can clean

692
00:23:04,200 --> 00:23:06,240
0,120 120,240 240,690 1020,1680 1680,2040
up its state,| {} and
|在之后的某个时刻，分片也可以清理它们的状态，

693
00:23:06,240 --> 00:23:07,380
0,120 120,240 240,420 420,750 750,1140
at some point later, the

694
00:23:07,380 --> 00:23:08,490
0,390 390,540 540,750 750,960 960,1110
shards can also clean up

695
00:23:08,490 --> 00:23:11,040
0,510 630,1050 1050,1590 1800,2310 2310,2550
their {} state,| {} and
|在提交时，参与者释放它们的锁。

696
00:23:11,040 --> 00:23:12,420
0,330 330,390 390,570 570,1050 1110,1380
that at {the,point,of} commit and

697
00:23:12,420 --> 00:23:14,760
0,330 360,810 810,1680 1680,1830 1830,2340
the participants release their locks.|
|

698
00:23:25,860 --> 00:23:27,540
0,240 240,810 900,1410 1410,1500 1500,1680
Okay, so that is sort
好的，这是读写事务的基本情况，

699
00:23:27,540 --> 00:23:29,700
0,90 90,660 690,1110 1110,1740 1740,2160
of the basic story for

700
00:23:29,700 --> 00:23:32,250
0,450 450,1200 1290,1590 1590,2190 2190,2550
read-write transactions,| and so any
|对此有什么问题吗？

701
00:23:32,250 --> 00:23:33,440
0,360 360,600 600,1020
questions about this?|
|

702
00:23:34,250 --> 00:23:35,480
0,360 360,510 510,690 690,870 900,1230
And I think the simple
我认为简单的思考方式是，

703
00:23:35,480 --> 00:23:36,500
0,120 120,240 240,390 390,750 750,1020
way to think about is,|
|

704
00:23:36,530 --> 00:23:38,060
0,210 210,420 420,570 570,1050 1050,1530
this is {two-phase -} commit,
这是两阶段提交，两阶段锁，

705
00:23:38,090 --> 00:23:39,890
0,180 180,420 420,990 1260,1590 1590,1800
{two-phase -} locking,| {} with
|与我们上周谈到的主要区别，

706
00:23:39,890 --> 00:23:41,630
0,120 120,390 390,810 810,1470 1470,1740
the main difference between what

707
00:23:41,630 --> 00:23:42,710
0,90 90,360 360,540 540,840 840,1080
we talked about last week,|
|

708
00:23:42,710 --> 00:23:44,330
0,210 210,630 630,900 900,1260 1260,1620
and this week is that,|
这周的是，|

709
00:23:44,510 --> 00:23:46,850
0,240 240,870 870,1440 1440,1650 1830,2340
the {participant -}, the transaction
事务协调者，参与者都是 Paxos 组，

710
00:23:46,850 --> 00:23:49,850
0,810 930,1500 1530,2220 2280,2490 2490,3000
coordinator, the participants are all
参与者都是帕克索斯团体，

711
00:23:49,850 --> 00:23:51,560
0,420 420,720 720,900 900,990 990,1710
Paxos groups,| so they replicated
|它们复制高可用，

712
00:23:51,560 --> 00:23:53,390
0,120 120,450 450,1080 1170,1650 1650,1830
{} highly available,| {} and
|上次我们谈到的两阶段提交的一些问题

713
00:23:53,390 --> 00:23:54,200
0,180 180,240 240,300 300,660 660,810
some of the problems that

714
00:23:54,200 --> 00:23:55,160
0,330 330,570 570,750 750,810 810,960
we talked about the {two-phase

715
00:23:55,160 --> 00:23:57,080
0,270 270,540 540,810 810,1260 1410,1920
-} commit last time {}|
|

716
00:23:57,080 --> 00:23:59,420
0,720 750,1230 1230,1470 1470,1950 1950,2340
are less, less relevant here,|
在这里不太相关，|

717
00:23:59,420 --> 00:24:01,610
0,270 270,360 360,930 930,1410 1620,2190
because the participants are much
因为参与者的可用性要高得多。

718
00:24:01,610 --> 00:24:02,620
0,120 120,450 450,930
more highly available.|
|

719
00:24:04,420 --> 00:24:06,310
0,240 240,750 960,1290 1290,1530 1530,1890
So the {} each shard
所以，每个分片是否都复制了锁表？

720
00:24:06,310 --> 00:24:08,710
0,420 450,1290 1290,1380 1380,1710 1710,2400
is replicating the lock table

721
00:24:08,740 --> 00:24:09,820
0,180 180,810
or not?|
|

722
00:24:10,410 --> 00:24:11,970
0,420 420,660 660,1020 1020,1440 1440,1560
{Yeah\,,well}, it's not replicating the
是的，好的，它不是在复制锁表，

723
00:24:11,970 --> 00:24:13,470
0,270 270,720 720,870 870,1380 1380,1500
lock table,| it's replicating the
|它复制准备好后持有的锁。

724
00:24:13,470 --> 00:24:14,910
0,360 360,570 570,1080 1080,1320 1320,1440
lock that's holding when it

725
00:24:14,910 --> 00:24:16,100
0,240 240,330 330,930
does the prepare.|
|

726
00:24:17,000 --> 00:24:17,990
0,180 180,390 390,480 480,840 840,990
So only the lock when
所以只有当它持有锁时。

727
00:24:17,990 --> 00:24:19,430
0,330 330,630 630,780 780,1170 1170,1440
it's that it's holding during.|
|

728
00:24:20,360 --> 00:24:21,590
0,450 450,720 720,840 840,930 930,1230
{Yeah\,,the} state that it needs
是的，它需要执行两阶段提交时。

729
00:24:21,590 --> 00:24:22,760
0,120 120,420 420,570 570,780 780,1170
to do {two-phase -} commit.|
|

730
00:24:25,870 --> 00:24:28,060
0,570 570,1020 1020,1500 1620,2070 2070,2190
So then they like the
所以，如果当前一些事务的锁

731
00:24:28,060 --> 00:24:30,130
0,690 690,1200 1200,1350 1350,1770 1800,2070
current locks for {} some

732
00:24:30,130 --> 00:24:32,000
0,570 570,720 720,1440
transaction,| that hasn't
|没有达到准备阶段，

733
00:24:32,210 --> 00:24:33,860
0,300 300,390 390,810 810,1470 1500,1650
reach the prepared stage,| it
|它们会丢失吗？

734
00:24:33,860 --> 00:24:36,240
0,480 510,750 750,1080 1290,2100
will, they just lost?|
|

735
00:24:36,390 --> 00:24:37,290
0,270 270,360 360,480 480,810 810,900
They will be lost and
它们会丢失，然后事务中止，

736
00:24:37,290 --> 00:24:38,550
0,120 120,210 210,600 600,780 780,1260
then the transaction will abort,|
|

737
00:24:38,580 --> 00:24:40,350
0,240 240,840 840,960 960,1140 1140,1770
{} participant does not participate,|
参与者不参与，|

738
00:24:41,710 --> 00:24:42,820
0,240 240,390 390,480 480,930 930,1110
and tell the coordinator hey
告诉协调者，我的锁丢失了，不能这么做。

739
00:24:42,820 --> 00:24:43,780
0,60 60,330 330,420 420,840 840,960
I lost my locks to

740
00:24:43,780 --> 00:24:45,280
0,360 510,810 810,900 900,1200
that, can't do it.|
|

741
00:24:46,000 --> 00:24:46,980
0,480

742
00:24:47,100 --> 00:24:48,380
0,450 450,960
Thank you.|
谢谢。|

743
00:24:50,230 --> 00:24:51,820
0,510 870,1050 1050,1200 1200,1320 1320,1590
Okay, so that the rest
好的，这节课剩下的部分是关于只读事务的，

744
00:24:51,820 --> 00:24:53,560
0,390 390,570 570,1110 1110,1470 1470,1740
of this lecture is about

745
00:24:53,560 --> 00:24:55,000
0,60 60,210 210,360 360,1260
the {read-only -} transactions,|
|

746
00:24:55,350 --> 00:24:56,880
0,480 480,1230
{} and,
这些事务只进行读而不进行写，

747
00:25:03,750 --> 00:25:05,130
0,270 270,540 540,1080 1080,1170 1170,1380
so these transactions are only

748
00:25:05,130 --> 00:25:08,000
0,150 150,570 1530,2040 2040,2580
do reads no writes,|
|

749
00:25:09,360 --> 00:25:10,980
0,270 270,390 390,780 810,1200 1200,1620
and they are {} common,|
它们是很常见的，|

750
00:25:11,220 --> 00:25:12,540
0,270 270,510 510,1170 1170,1230 1230,1320
and so one of the
所以，其中一个目标是让它们变得非常快。

751
00:25:12,540 --> 00:25:13,560
0,360 360,450 450,630 630,840 840,1020
goals is to actually make

752
00:25:13,560 --> 00:25:14,700
0,90 90,360 360,900
them very fast.|
|

753
00:25:18,560 --> 00:25:19,970
0,390 390,690 690,780 780,1020 1020,1410
{} And the way, {}
他们实现高性能的方式是

754
00:25:19,970 --> 00:25:22,370
0,450 450,1050 1440,1860 1890,2220 2220,2400
{} there, the way they

755
00:25:22,370 --> 00:25:24,350
0,540 570,660 660,1140 1170,1380 1380,1980
achieve you know high performance

756
00:25:24,350 --> 00:25:25,850
0,540 570,870 870,1230 1230,1410 1410,1500
is| {they,gone} arrange that the
|它们安排读取，

757
00:25:25,850 --> 00:25:27,950
0,420 870,1290 1290,1530 1530,1680 1680,2100
reads,| Spanner makes high performance,|
|Spanner 的性能很高，|

758
00:25:27,950 --> 00:25:29,990
0,240 240,720 1080,1560 1560,1860 1860,2040
because reads are only for
因为读取只对本地分片，

759
00:25:29,990 --> 00:25:31,480
0,330 330,840
local shards,|
|

760
00:25:36,570 --> 00:25:37,760
0,900

761
00:25:38,040 --> 00:25:40,800
0,570 570,1590 1620,1890 1890,2100 2100,2760
and they have no locks,|
而且它们没有锁，|

762
00:25:43,040 --> 00:25:44,030
0,180 180,360 360,630 630,720 720,990
and no lock is good,|
没有锁是好的，|

763
00:25:44,030 --> 00:25:45,170
0,330 330,540 540,780 780,990 990,1140
because it means that {read-write
因为这意味着读写事务可以阻塞读写事务，

764
00:25:45,170 --> 00:25:47,150
0,150 150,690 690,990 1050,1860 1860,1980
-} transactions can block {the,read-write}

765
00:25:47,150 --> 00:25:48,920
0,600 600,840 840,1200 1200,1530 1530,1770
transactions,| or {another,way} saying is,
|或者另一种说法是，只读事务不会阻塞读写事务，

766
00:25:49,070 --> 00:25:50,630
0,240 240,450 450,930 930,1170 1170,1560
{read-only -} transactions can't block

767
00:25:50,630 --> 00:25:51,960
0,150 150,330 330,1080
{read-write -} transactions,|
|

768
00:25:52,370 --> 00:25:54,980
0,420 420,900 900,1320 1470,2130 2400,2610
{} and no no {two-phase
并且没有两阶段提交，

769
00:25:54,980 --> 00:25:57,350
0,240 240,630 1920,2130 2130,2220 2220,2370
-} commit,| and so that
|所以，这也意味着不需要广域通信，

770
00:25:57,350 --> 00:25:58,520
0,180 180,450 450,630 630,870 870,1170
means also no {wide-area -}

771
00:25:58,520 --> 00:26:00,920
0,480 480,1110 1230,1650 1650,2100 2100,2400
communication necessary,| and so {}
|所以，读取操作可以从本地 replica 执行。

772
00:26:00,920 --> 00:26:02,180
0,240 240,330 330,540 540,630 630,1260
that the reads can definitely

773
00:26:02,180 --> 00:26:03,830
0,630 630,810 810,840 840,1110 1110,1650
execute from a local replica.|
|

774
00:26:05,320 --> 00:26:06,910
0,660 900,1110 1110,1320 1320,1470 1470,1590
And {you,know} also see of
当然，也会看到，

775
00:26:06,910 --> 00:26:08,260
0,420 420,510 510,630 630,1170 1170,1350
course,| you know this is
|这是从本地分片读取的数据，

776
00:26:08,260 --> 00:26:09,130
0,240 240,420 420,570 570,600 600,870
the read from a local

777
00:26:09,130 --> 00:26:10,960
0,420 420,900 900,1380 1380,1560 1560,1830
shards,| {} the the real
|这里真正的挑战是，

778
00:26:10,960 --> 00:26:12,430
0,420 420,780 780,1080 1080,1260 1260,1470
challenge here is| like how
|如何仍然获得一致性或者串行化，

779
00:26:12,430 --> 00:26:15,220
0,210 210,510 510,720 720,1380
to still get consistency

780
00:26:15,690 --> 00:26:17,520
0,660 660,810 810,1500
or {you,know} serializability,|
|

781
00:26:18,010 --> 00:26:19,480
0,450 660,840 840,1170 1170,1230 1230,1470
{} {but,it's} important to point
但重要的是要指出，

782
00:26:19,480 --> 00:26:20,740
0,390 390,480 480,930 960,1140 1140,1260
out, you know,| but for
|但有一段时间假设，

783
00:26:20,740 --> 00:26:22,960
0,120 120,570 570,1260 1260,1830 1830,2220
a moment {you,know} assume,| that
|我们知道怎么做，

784
00:26:22,960 --> 00:26:23,530
0,90 90,210 210,390 390,450 450,570
we know how to do

785
00:26:23,530 --> 00:26:24,460
0,300 300,510 510,600 600,780 780,930
this,| {} you know we
|你知道我们可以，

786
00:26:24,460 --> 00:26:26,620
0,300 690,1350 1350,1560 1560,1710 1710,2160
could,| then reading from only
|仅从本地分片读取，不持有锁，不执行两阶段提交，

787
00:26:26,650 --> 00:26:29,410
0,840 840,1380 1620,2220 2220,2580 2580,2760
local shard, {} holding no

788
00:26:29,410 --> 00:26:31,270
0,600 630,900 900,1110 1110,1530 1530,1860
locks, not doing two-phase commit,|
|

789
00:26:31,270 --> 00:26:32,650
0,210 210,540 540,750 750,810 810,1380
means that all the communication
意味着所有通信都是本地的

790
00:26:32,650 --> 00:26:34,390
0,90 90,420 420,900 1050,1470 1470,1740
is local| within {} within
|在一个数据中心内，

791
00:26:34,390 --> 00:26:36,670
0,180 180,510 510,750 750,1200 1590,2280
that particular data center,| and
|而且它可以非常快，

792
00:26:36,850 --> 00:26:37,780
0,360 360,480 480,600 600,660 660,930
{} it can be very

793
00:26:37,780 --> 00:26:38,980
0,450 450,720 720,900 900,1020 1020,1200
fast,| then if you look
|如果你看一下论文中表 3 和表 6 ，

794
00:26:38,980 --> 00:26:40,600
0,90 90,240 240,600 810,1290 1320,1620
at the end in table

795
00:26:40,600 --> 00:26:41,880
0,210 210,300 300,870
3 and 6

796
00:26:42,220 --> 00:26:44,340
0,180 180,240 240,870
in the paper,|
|

797
00:26:45,260 --> 00:26:46,940
0,300 300,450 450,810 810,1170 1170,1680
{} you basically see that,|
你可以看到，|

798
00:26:46,970 --> 00:26:48,740
0,630 660,1320 1320,1380 1380,1560 1560,1770
{} basically you know {read-only
基本上只读事务

799
00:26:48,740 --> 00:26:53,450
0,330 330,1200 3330,3900 3990,4410 4410,4710
-} transactions| are ten times
|比读写事务快十倍，

800
00:26:53,450 --> 00:26:54,380
0,630
faster

801
00:26:54,640 --> 00:26:57,280
0,480 480,600 600,1560 1710,1920 1920,2640
than read-write transactions,| read-write transactions
|读写事务在数百毫秒的量级，

802
00:26:57,280 --> 00:26:58,000
0,150 150,240 240,330 330,660 660,720
are in the order of

803
00:26:58,000 --> 00:26:59,710
0,330 330,420 420,1170 1290,1560 1560,1710
hundreds of milliseconds,| which sort
|这在某种程度上说得通，

804
00:26:59,710 --> 00:27:00,880
0,60 60,240 240,600 600,1080 1080,1170
of makes sense,| because they
|因为它们要远距离通信，

805
00:27:00,880 --> 00:27:02,950
0,180 180,480 780,1080 1080,1830 1830,2070
have to {} communicate long

806
00:27:02,950 --> 00:27:05,200
0,660 900,1440 1440,1890 1890,2040 2040,2250
distance,| {} and but {read-only
|但是只读事务在 5 到 10 毫秒的数量级。

807
00:27:05,200 --> 00:27:06,280
0,210 210,690 690,840 840,900 900,1080
-} transactions on a new

808
00:27:06,280 --> 00:27:09,190
0,330 330,690 990,1830 2370,2790 2790,2910
order of {} 5 to

809
00:27:09,190 --> 00:27:10,260
0,180 180,960
10 milliseconds.|
|

810
00:27:12,940 --> 00:27:14,560
0,240 240,420 420,660 660,1290 1320,1620
Okay, so the key challenge
好的，所以关键的挑战当然是，

811
00:27:14,560 --> 00:27:15,340
0,60 60,300 300,390 390,660 660,780
of course is always going

812
00:27:15,340 --> 00:27:17,080
0,60 60,450 480,930 930,1170 1170,1740
to be,| {} we execute
|我们执行本地副本，如何获得正确性。

813
00:27:17,080 --> 00:27:18,700
0,330 330,960 990,1290 1290,1440 1440,1620
local replica, how to get

814
00:27:18,700 --> 00:27:20,200
0,870
correctness.|
|

815
00:27:21,240 --> 00:27:21,840
0,180 180,300 300,360 360,540 540,600
So let me talk a
所以让我稍微谈谈，

816
00:27:21,840 --> 00:27:22,860
0,210 210,360 360,630 630,750 750,1020
little bit about it,| because
|因为它与我们以前看到的略有不同，

817
00:27:22,860 --> 00:27:25,740
0,240 240,840 840,1410 1860,2490 2490,2880
it's slightly different than what

818
00:27:25,740 --> 00:27:27,540
0,120 120,300 300,900 1050,1620 1620,1800
we've seen before,| {} so
|所以，正确性在这里意味着两件事，

819
00:27:27,540 --> 00:27:28,920
0,360 360,570 570,810 810,1110 1110,1380
correctness means two things here,|
|

820
00:27:28,920 --> 00:27:30,420
0,480 510,630 630,750 750,930 930,1500
one, you know that transactions
一个是，事务是可串行化的，

821
00:27:30,420 --> 00:27:31,840
0,150 150,720
are serializable,|
|

822
00:27:32,860 --> 00:27:34,120
0,180 180,300 300,600 600,1110 1110,1260
so they must execute in
所以它们必须按某种顺序执行，

823
00:27:34,120 --> 00:27:35,800
0,270 270,630 630,1200 1380,1590 1590,1680
some serial order,| so if
|所以如果你仔细想想，

824
00:27:35,800 --> 00:27:36,670
0,90 90,270 270,510 510,750 750,870
you think about it,| we
|我们有一个读写事务，

825
00:27:36,670 --> 00:27:38,080
0,150 150,240 240,450 450,690 690,1410
have a {read-write -} transaction,|
|

826
00:27:39,220 --> 00:27:40,750
0,360 360,810 840,1110 1110,1440 1440,1530
{ - -} and we
我们有另一个读写事务，

827
00:27:40,750 --> 00:27:42,130
0,90 90,330 330,510 510,750 750,1380
have another {read-write -} transaction,|
|

828
00:27:42,550 --> 00:27:43,420
0,450 450,540 540,630 630,660 660,870
then we have a {read-only
然后我们有一个只读事务，

829
00:27:43,420 --> 00:27:45,580
0,270 270,930 1170,1530 1530,1740 1740,2160
-} transaction,| {you,know,the,read-only -} transaction
|只读事务必须

830
00:27:45,580 --> 00:27:46,390
0,150 150,210 210,360 360,420 420,810
has to| sort of fit
|介于两个读写事务之间，

831
00:27:46,420 --> 00:27:47,890
0,450 450,570 570,1020 1020,1230 1230,1470
between the two {read-write -}

832
00:27:47,890 --> 00:27:50,170
0,720 960,1380 1380,1560 1560,1770 1770,2280
transactions,| and {read-only -} transaction
|只读事务不应该观察到

833
00:27:50,170 --> 00:27:52,630
0,210 210,450 450,1110 1200,1740 1740,2460
should not observe| some part
|读写事务的某些部分，

834
00:27:52,990 --> 00:27:54,700
0,420 420,750 750,1320 1350,1530 1530,1710
{} of the {read-write -}

835
00:27:54,700 --> 00:27:55,900
0,480 480,750 750,870 870,1050 1050,1200
transaction,| so the {read-write -}
|所以读写事务进行多次写入，像第一次那样，

836
00:27:55,900 --> 00:27:57,430
0,510 510,930 930,1290 1290,1440 1440,1530
transactions {does,multiple} writes, like the

837
00:27:57,430 --> 00:27:58,600
0,240 240,600
first one,|
|

838
00:27:58,800 --> 00:28:00,480
0,570 570,630 630,810 810,1020 1020,1680
then the {read-only -} transaction
然后，只读事务看到所有这些写入或没有一个，

839
00:28:00,480 --> 00:28:01,530
0,180 180,420 420,600 600,810 810,1050
{you,know} see all those writes

840
00:28:01,530 --> 00:28:02,420
0,120 120,300 300,360 360,570
or none of them,|
|

841
00:28:03,190 --> 00:28:04,180
0,360 360,480 480,810 810,930 930,990
{} and similarly for the
与[]的那个类似。

842
00:28:04,180 --> 00:28:05,560
0,180 180,300 300,660 660,930 930,1380
one that actually is [].|
|

843
00:28:05,800 --> 00:28:08,740
0,690 1140,1350 1350,1440 1440,2460 2460,2940
Okay?| So the second,| this
好的?|第二，|这是我们上周谈到的标准问题，可串行化，

844
00:28:08,740 --> 00:28:09,580
0,120 120,180 180,570 570,720 720,840
is a standard thing that

845
00:28:09,580 --> 00:28:11,440
0,90 90,330 330,720 720,1680 1680,1860
we talked about last week,

846
00:28:11,440 --> 00:28:13,330
0,150 150,660 660,780 780,1170 1380,1890
{serializability -},| and then would
|然后他们会选择更强的东西吗，

847
00:28:13,330 --> 00:28:14,440
0,60 60,240 240,330 330,540 540,1110
they go for something stronger,|
|

848
00:28:14,950 --> 00:28:16,270
0,180 180,360 360,480 480,900 900,1320
and what they call external
他们所说的外部一致性，

849
00:28:16,270 --> 00:28:17,520
0,840
consistency,|
|

850
00:28:24,900 --> 00:28:26,970
0,570 570,930 930,1500 1500,1830 1830,2070
and external consistency means that,|
外部一致性意味着，|

851
00:28:26,970 --> 00:28:28,560
0,330 330,450 450,1200
if {} transaction
如果事务 2 在事务 1 提交之后开始，

852
00:28:30,250 --> 00:28:33,370
0,690 780,1530 1560,2040 2040,2520 2520,3120
2 start after transaction 1

853
00:28:33,520 --> 00:28:34,940
0,360 360,930
has committed,|
|

854
00:28:35,820 --> 00:28:37,320
0,420 420,1020 1050,1140 1140,1260 1260,1500
{} then you know {T2
那么 T2 必须看到 T1 的写入。

855
00:28:37,320 --> 00:28:38,420
0,540
-}

856
00:28:38,660 --> 00:28:40,120
0,510 510,1050
must see

857
00:28:41,720 --> 00:28:43,960
0,240 240,990 1440,2010
{T1's -} write.|
|

858
00:28:48,250 --> 00:28:49,540
0,270 270,780 780,900 900,1170 1170,1290
So we'll go back into
所以，我们回到之前的这张图片，

859
00:28:49,540 --> 00:28:50,920
0,150 150,480 480,930 930,1110 1110,1380
this previous picture,| like if
|如果只读事务，

860
00:28:50,920 --> 00:28:52,810
0,210 210,390 390,660 660,1290 1710,1890
{} {read-only -} transaction,| this
|这个在第一个事务提交之后开始，

861
00:28:52,810 --> 00:28:55,930
0,420 870,1380 1380,2160 2190,2700 2700,3120
one started after { -}

862
00:28:55,930 --> 00:28:57,670
0,120 120,330 330,750 750,1260 1380,1740
the first transaction committed,| then
|那么这个只读事务必须看到事务 T1 的写入，

863
00:28:57,670 --> 00:28:59,020
0,150 150,330 330,540 540,1020 1020,1350
this {read-only -} transaction must

864
00:28:59,020 --> 00:29:01,960
0,480 540,1080 1080,1740 1770,2280 2790,2940
see {} the reads, the

865
00:29:01,960 --> 00:29:03,610
0,330 330,600 600,840 840,1200 1230,1650
writes of that {} transaction

866
00:29:03,610 --> 00:29:04,760
0,390
T1,|
|

867
00:29:05,080 --> 00:29:07,570
0,570 840,1380 1740,2250 2250,2370 2370,2490
and, {} and so the
所以想法是，如果你想想这个，

868
00:29:07,570 --> 00:29:09,400
0,1050 1050,1140 1350,1530 1530,1650 1650,1830
idea is, if you think

869
00:29:09,400 --> 00:29:11,440
0,210 210,600 630,1380 1380,1530 1530,2040
about this,| basically this sort
|这种外部一致性意味着

870
00:29:11,440 --> 00:29:13,330
0,150 150,510 510,1140 1140,1530 1530,1890
of external consistency means| {serializability
|可串行化加上这种实时需求，

871
00:29:13,330 --> 00:29:15,880
0,720 960,1200 1200,1380 1380,1890 1890,2550
-} plus this real-time requirement,|
|

872
00:29:16,270 --> 00:29:17,080
0,150 150,210 210,570 570,630 630,810
and in fact you know
事实上，它与线性一致性非常相似，

873
00:29:17,080 --> 00:29:19,180
0,360 360,510 510,810 810,1470 1590,2100
it is very similar to

874
00:29:19,180 --> 00:29:20,360
0,330 330,510 510,990
{linearizability - -},|
|

875
00:29:28,560 --> 00:29:31,500
0,630 1380,2100 2100,2670 2670,2760 2760,2940
{ -} except you know
除了一种方式

876
00:29:31,500 --> 00:29:34,020
0,690 750,1050 1050,1260 1260,1530 1950,2520
the one way| to contrast
|用于对比事务的外部一致性和线性一致性的是，

877
00:29:34,020 --> 00:29:36,540
0,390 390,1200 1200,1710 1710,1830 1830,2520
external consistency {} for transactions

878
00:29:36,900 --> 00:29:38,340
0,240 240,510 510,1020 1020,1170 1170,1440
with {linearizability -} is that,|
|

879
00:29:38,340 --> 00:29:40,290
0,510 510,870 870,1230 1230,1500 1500,1950
{} external consistency really transaction
外部一致性是事务级别的属性，

880
00:29:40,290 --> 00:29:41,970
0,240 240,810 1110,1410 1410,1470 1470,1680
level property,| and the way
|到目前为止，我们谈论线性一致性的方式，

881
00:29:41,970 --> 00:29:43,140
0,330 330,480 480,750 750,930 930,1170
we've been talking about {linearizability

882
00:29:43,140 --> 00:29:44,640
0,120 120,480 480,690 690,1230 1350,1500
- -} so far,| and
|总是单独的读写，

883
00:29:44,640 --> 00:29:45,660
0,240 240,390 390,600 600,840 840,1020
always has been sort of

884
00:29:45,660 --> 00:29:47,120
0,540 540,810 810,1350
individual {reads,and} writes,|
|

885
00:29:47,410 --> 00:29:49,600
0,690 1080,1560 1590,1830 1830,2130 2160,2190
{} and {} but {
但对于第一[层次]来说，

886
00:29:49,600 --> 00:29:51,160
0,480 600,750 750,1080 1080,1500 1500,1560
-} {to,the} first order,| you
|我认为你应该以完全相同的方式思考。

887
00:29:51,160 --> 00:29:51,940
0,90 90,210 210,420 420,600 600,780
know I think you should

888
00:29:51,940 --> 00:29:53,230
0,180 180,510 510,960 960,1020 1020,1290
think about exactly the same

889
00:29:53,230 --> 00:29:53,720
0,180
way.|
|

890
00:29:54,340 --> 00:29:57,010
0,510 660,1290 1290,1410 1410,2100 2100,2670
And like {} linearizability,| external
和线性一致性一样，|外部一致性对于程序员来说也是令人愉快的，

891
00:29:57,010 --> 00:29:58,630
0,420 420,690 690,990 990,1110 1110,1620
consistency is pleasant for programmers,|
|

892
00:29:59,290 --> 00:30:02,830
0,2010 2010,2280 2280,2550 2550,3090 3090,3540
{} is very strong consistency
是非常强的一致性。

893
00:30:02,830 --> 00:30:04,500
0,90 90,810 840,1410
{ -} property.|
|

894
00:30:06,200 --> 00:30:07,550
0,270 270,420 420,750 750,990 990,1350
Okay, any questions,| about the
好的，有什么问题吗，|关于这里的正确性定义

895
00:30:07,580 --> 00:30:08,900
0,420 420,900 900,1110 1110,1230 1230,1320
correctness definition there| or the
|或者 Spanner 拥有的正确性目标？

896
00:30:08,900 --> 00:30:09,720
0,540
correctness

897
00:30:10,100 --> 00:30:12,140
0,690 690,900 900,1260 1260,1620 1620,2040
goal that the Spanner has?|
|

898
00:30:17,900 --> 00:30:18,820
0,540
Okay.|
好的。|

899
00:30:18,980 --> 00:30:20,150
0,330 330,570 570,720 720,930 930,1170
Okay, let's then talk about,|
好的，那么我们来谈谈，|

900
00:30:20,150 --> 00:30:21,530
0,180 180,450 450,750 750,1230 1230,1380
how to actually achieve this
如何实现只读事务的这种正确性。

901
00:30:21,530 --> 00:30:23,300
0,450 450,660 660,840 840,1050 1050,1770
correctness for {read-only -} transactions.|
|

902
00:30:23,780 --> 00:30:25,100
0,360 360,600 600,780 780,930 930,1320
{} And let me start
让我首先解释一个实际上不工作的坏的方案，

903
00:30:25,100 --> 00:30:27,020
0,420 420,750 750,1410 1410,1680 1680,1920
out by explaining {a,bad} plan

904
00:30:27,020 --> 00:30:28,670
0,120 120,330 330,630 630,1050 1470,1650
that actually doesn't work,| and
|然后我们将讨论一个更好的方案。

905
00:30:28,670 --> 00:30:29,990
0,660 660,900 900,1050 1050,1110 1110,1320
then we're going to talk

906
00:30:29,990 --> 00:30:32,180
0,300 300,630 630,900 900,1230
about a better plan.|
|

907
00:30:33,520 --> 00:30:34,780
0,150 150,210 210,450 450,690 690,1260
So the bad plan is,|
所以坏的方案是，|

908
00:30:34,840 --> 00:30:37,600
0,660 660,780 780,870 870,1410 2520,2760
we're going to read,| {you,know}
我们将读取，|我们安排总是读取最新提交的值，

909
00:30:37,600 --> 00:30:38,890
0,390 390,600 600,750 750,990 990,1290
arrange that we read always

910
00:30:38,890 --> 00:30:40,520
0,60 60,360 360,600 600,990
the latest committed value,|
|

911
00:30:43,550 --> 00:30:45,880
0,360 360,870 900,1320 1320,1950
that seems about write,
这是关于写入的，

912
00:30:46,520 --> 00:30:47,690
0,420 510,810 810,930 930,1110 1110,1170
right,| because we have to
|因为我们必须安排，如果 T2 在 T1 提交之后开始，

913
00:30:47,690 --> 00:30:49,340
0,420 420,630 630,1020 1020,1410 1440,1650
arrange that if {} {T2

914
00:30:49,340 --> 00:30:51,560
0,300 300,780 780,1440 1470,1860 1860,2220
-} starts after T1 committed,|
|

915
00:30:51,560 --> 00:30:52,550
0,300 300,540 540,690 690,780 780,990
{we'll,see}, you have to see
你必须看到它的写入，

916
00:30:52,550 --> 00:30:54,200
0,390 390,720 720,1050 1080,1410 1410,1650
it's writes,| so why not
|所以为什么不读取最新的提交值，

917
00:30:54,200 --> 00:30:55,340
0,150 150,240 240,540 540,780 780,1140
read the latest committed value,|
|

918
00:30:55,340 --> 00:30:56,360
0,90 90,270 270,450 450,750 750,1020
then we should be, maybe
我们可能是好的。

919
00:30:56,360 --> 00:30:57,240
0,240 240,510
we're good.|
|

920
00:30:58,270 --> 00:30:59,860
0,180 180,870 870,990 990,1050 1080,1590
So here is the,| the
所以这是，|问题当然是，它实际上并不起作用，

921
00:31:00,220 --> 00:31:01,570
0,420 420,630 630,690 690,1020 1020,1350
problem case of course it

922
00:31:01,570 --> 00:31:02,820
0,270 270,510 510,960
doesn't actually work,|
|

923
00:31:03,120 --> 00:31:05,850
0,690 690,870 870,1410 1740,2310 2310,2730
so {T1 -}, {maybe,T1 -}
所以 T1 ，可能 T1 写入 x ，写入 y ，并提交转账，

924
00:31:06,000 --> 00:31:08,020
0,300 300,600 600,1080 1140,1650
does a write of

925
00:31:08,960 --> 00:31:10,970
0,360 360,570 570,930 930,1260 1290,2010
x, does write of y,

926
00:31:11,030 --> 00:31:13,220
0,630 630,780 780,1320 1320,1950
{} does transfer commits,|
|

927
00:31:13,670 --> 00:31:15,650
0,690 1050,1170 1170,1380 1380,1590 1590,1980
then you know we have
那么我们有另一个事务，

928
00:31:15,650 --> 00:31:17,420
0,360 360,840 840,1440 1440,1560 1560,1770
another {} transaction,| we have
|我们有事务 T3 ，

929
00:31:17,420 --> 00:31:18,950
0,600 630,840 840,1200 1200,1350 1350,1530
transaction {T3 -},| or {t3
|或者 T3 是只读操作，

930
00:31:18,950 --> 00:31:19,820
0,240 240,360 360,480 480,660 660,870
-} is the {read-only -}

931
00:31:19,820 --> 00:31:21,350
0,600 630,930 930,1230 1230,1410 1410,1530
action,| it actually does a
|它读取 x ，

932
00:31:21,350 --> 00:31:23,210
0,180 180,270 270,870 1500,1710 1710,1860
read of x,| so this
|所以这是一种实时的，

933
00:31:23,210 --> 00:31:24,830
0,60 60,300 300,510 510,1080 1350,1620
is {sort,of} real time,| and
|然后在 T2 之后，

934
00:31:24,830 --> 00:31:27,710
0,390 420,1260 1290,1680 1680,2310 2550,2880
then after {T2 -},| then
|然后在 T1 T3 开始之后，

935
00:31:27,710 --> 00:31:29,150
0,390 390,540 540,1020 1020,1260 1260,1440
after {T1 -} {T3 -}

936
00:31:29,150 --> 00:31:31,850
0,330 330,930 930,1200 1200,1740 2130,2700
starts,| {T2 -} runs, {}
|T2 运行，

937
00:31:31,970 --> 00:31:33,350
0,210 210,390 390,960 960,1290 1290,1380
{runs -} [],| [] the
|写入 x ，写入 y ，提交，

938
00:31:33,350 --> 00:31:34,640
0,240 240,420 420,900 900,990 990,1290
write of x, the write

939
00:31:34,640 --> 00:31:37,400
0,630 870,1530 1800,1980 1980,2490 2490,2760
{of,y}, commits,| and then {you,know}
|然后 T3 有一点延迟，

940
00:31:37,400 --> 00:31:37,970
0,120 120,270 270,390 390,420 420,570
{T3 -} get a little

941
00:31:37,970 --> 00:31:39,080
0,90 90,480 480,600 600,780 780,1110
bit delayed,| and then actually
|然后第二次读取 y ，

942
00:31:39,080 --> 00:31:40,400
0,240 240,540 540,870 870,1170 1170,1320
does {second -} read {}

943
00:31:40,400 --> 00:31:41,100
0,210 210,270 270,600
read of y,|
|

944
00:31:42,510 --> 00:31:45,120
0,570 990,1920 1920,2010 2010,2400 2400,2610
{} sort of time you
时间像往常一样，是这个方向。

945
00:31:45,120 --> 00:31:46,170
0,150 150,270 270,660 660,870 870,1050
know as usual going that

946
00:31:46,170 --> 00:31:47,020
0,240
way.|
|

947
00:31:50,100 --> 00:31:53,880
0,720 870,1260 1260,1830 1830,2220 2220,3780
{} And {you,know,if,you're} following the
如果你遵守读取最新的提交值（的规则），

948
00:31:54,240 --> 00:31:55,710
0,690 690,870 870,1140 1140,1380 1380,1470
read the latest {committed -}

949
00:31:55,710 --> 00:31:56,940
0,270 270,450 450,930 930,1170 1170,1230
{value -},| then what is
|那么这会返回什么，

950
00:31:56,940 --> 00:31:58,200
0,210 210,390 390,540 540,630 630,1260
this really going to return,|
|

951
00:31:58,470 --> 00:31:59,670
0,210 210,330 330,390 390,930 930,1200
it's going to return the
它会返回事务 T1 的值，

952
00:31:59,730 --> 00:32:01,470
0,600 600,870 870,1080 1080,1500 1500,1740
value from this transaction {T1

953
00:32:01,470 --> 00:32:02,120
0,390
-},|
|

954
00:32:02,360 --> 00:32:04,610
0,600 600,960 960,1350 1350,1650 1650,2250
and this read {is,going,to} return
这个读取将返回来自这个事务的 y 的值，

955
00:32:05,210 --> 00:32:06,470
0,390 390,750 750,870 870,1170 1170,1260
the value of y from

956
00:32:06,470 --> 00:32:07,580
0,150 150,600 600,870 870,960 960,1110
that transaction,| because you know
|因为这是最新提交值。

957
00:32:07,580 --> 00:32:09,230
0,240 240,480 480,720 720,1170 1170,1650
that's {the,latest -} commited value.|
|

958
00:32:09,910 --> 00:32:11,260
0,420 420,630 630,750 750,990 990,1350
And that would be wrong,
这是不对的，对吧，

959
00:32:11,290 --> 00:32:12,020
0,390
right,|
|

960
00:32:19,360 --> 00:32:20,440
0,390 390,630 630,780 780,1020 1020,1080
because now we're actually in
因为现在我们处于一种情况，

961
00:32:20,440 --> 00:32:21,610
0,30 30,540 540,660 660,1110 1110,1170
a situation,| where basically you
|T3 观察到来自不同事务的写入，

962
00:32:21,610 --> 00:32:23,230
0,180 180,390 390,810 810,1500 1500,1620
know {T3 -} observes the

963
00:32:23,230 --> 00:32:25,000
0,450 450,600 600,840 840,1380 1410,1770
writes you know from {}

964
00:32:25,000 --> 00:32:26,830
0,270 270,1020 1080,1320 1320,1680 1680,1830
different transactions,| and not get
|而不是得到一致的[]。

965
00:32:26,830 --> 00:32:28,140
0,60 60,480 480,930
a consistent [].|
|

966
00:32:29,620 --> 00:32:31,690
0,510 510,1410 1500,1680 1680,1860 1860,2070
So, {} so this rule
所以这个规则还不够好，

967
00:32:31,690 --> 00:32:32,880
0,90 90,300 300,480 480,1050
is not good enough,|
|

968
00:32:33,080 --> 00:32:36,320
0,600 600,1260 1500,2190 2220,2580 2580,3240
{} and {} to avoid
为了避免这个问题，不使用这个糟糕的方案，

969
00:32:36,470 --> 00:32:37,940
0,180 180,510 510,660 660,1050 1050,1470
this problem and not use

970
00:32:37,940 --> 00:32:39,770
0,150 150,390 390,810 960,1440 1470,1830
this bad plan,| {} Spanner
|Spanner 使用了不同的方案，

971
00:32:39,770 --> 00:32:41,140
0,270 270,360 360,660 660,1110
uses a different plan,|
|

972
00:32:41,480 --> 00:32:43,850
0,540 540,870 870,1620 1680,2220 2220,2370
and that's plan {} is
这一方案称为快照隔离，

973
00:32:43,850 --> 00:32:47,280
0,240 240,840 840,1470
called snapshot isolation,|
|

974
00:32:53,520 --> 00:32:55,020
0,270 270,510 510,570 570,570 570,1500
this actually is a standard
这是一个标准的数据库概念，

975
00:32:55,020 --> 00:33:00,390
0,780 780,1560 1650,2640 2640,3900 4500,5370
database idea,| {} and mostly
|主要是一些本地数据库，

976
00:33:00,390 --> 00:33:02,580
0,240 240,330 330,720 720,1500 1620,2190
sort of local databases, {}|
|

977
00:33:02,580 --> 00:33:04,260
0,480 480,840 840,1230 1230,1590 1590,1680
{} not actually across the
并不是在广域内，

978
00:33:04,260 --> 00:33:05,020
0,180 180,540
{wide-area -},|
|

979
00:33:05,820 --> 00:33:06,810
0,120 120,270 270,510 510,690 690,990
and so we'll talk about
我们稍后讨论广域方面，

980
00:33:06,810 --> 00:33:10,080
0,180 180,1380 1830,2580 2580,2880 2880,3270
in {the,sort,of} {wide-area -} aspect

981
00:33:10,080 --> 00:33:11,190
0,120 120,150 150,480 480,960 960,1110
in a second,| but just
|但首先让我解释一下什么是快照隔离。

982
00:33:11,190 --> 00:33:12,240
0,150 150,240 240,450 450,750 750,1050
let me first explain what's

983
00:33:12,240 --> 00:33:13,640
0,300 300,870 870,1170
snapshot isolation is.|
|

984
00:33:14,230 --> 00:33:15,100
0,270 270,360 360,480 480,720 720,870
And so what {snapshot -}
所以，快照隔离所做的是，

985
00:33:15,100 --> 00:33:16,810
0,420 420,690 690,1290 1350,1590 1590,1710
isolation does is,| we're going
|我们为事务分配一个时间戳，

986
00:33:16,810 --> 00:33:18,250
0,60 60,540 540,630 630,900 900,1440
to assign a {timestamp -}

987
00:33:21,930 --> 00:33:24,000
0,780 780,1140 1140,1650
to a transaction,|
|

988
00:33:26,930 --> 00:33:27,980
0,450 450,540 540,660 660,900 900,1050
and you know there's two
我们分配时间戳，有两个不同的点，

989
00:33:27,980 --> 00:33:29,360
0,240 240,540 540,780 780,1050 1050,1380
different points, we're gonna assign

990
00:33:29,360 --> 00:33:33,020
0,180 180,1080 1680,2670 2670,3150 3210,3660
{ -} {timestamps -},| for
|对于读写事务，是提交开始提交的时候，

991
00:33:33,020 --> 00:33:34,760
0,210 210,390 390,1230
{read-write -} transactions,

992
00:33:35,420 --> 00:33:36,350
0,210 210,360 360,720 720,780 780,930
it's gonna be you know

993
00:33:36,350 --> 00:33:37,880
0,210 210,540 630,1050 1050,1110 1110,1530
the commit started to commit,|
|

994
00:33:40,690 --> 00:33:42,610
0,330 330,540 540,750 750,990 990,1920
and for {read-only -} transactions,
对于只读事务，是事务开始的时候，

995
00:33:43,270 --> 00:33:44,320
0,300 300,630 630,750 750,810 810,1050
it is going to be

996
00:33:44,320 --> 00:33:46,030
0,330 330,810 810,900 900,990 990,1710
the start of the transactions,|
|

997
00:33:48,900 --> 00:33:50,130
0,210 210,720 720,720 720,1110 1110,1230
and then {} we're gonna
然后我们将按时间戳顺序执行所有事务，

998
00:33:50,130 --> 00:33:51,240
0,780
execute

999
00:33:53,160 --> 00:33:54,700
0,270 270,1080
all operations,

1000
00:33:55,920 --> 00:33:58,860
0,1170 1170,1830 1890,2220 2220,2490 2490,2940
transaction in {timestamp -} order,|
|

1001
00:34:01,950 --> 00:34:02,850
0,150 150,390 390,510 510,840 840,900
{} I will explain in
我一会儿再解释，但是这个意思，

1002
00:34:02,850 --> 00:34:03,870
0,30 30,330 330,570 570,930 930,1020
a second, but what I

1003
00:34:03,870 --> 00:34:04,880
0,330 330,690
mean that,|
|

1004
00:34:05,180 --> 00:34:07,220
0,630 720,1050 1050,1290 1290,1530 1530,2040
{} {and,be} able to execute
能够按时间戳顺序执行所有操作，

1005
00:34:07,220 --> 00:34:08,840
0,150 150,210 210,630 630,1020 1020,1620
all the operation {in,timestamp} order,|
|

1006
00:34:09,080 --> 00:34:10,540
0,270 270,960
{you,know,each} replica,|
每个 replica ，|

1007
00:34:11,750 --> 00:34:13,100
0,210 210,300 300,570 570,900 900,1350
this is store one value
每个键保存一个值，

1008
00:34:13,100 --> 00:34:15,140
0,180 180,240 240,660 660,1140 1530,2040
for a particular key, {}|
|

1009
00:34:15,560 --> 00:34:18,170
0,540 540,810 810,1440 1470,1920 1920,2610
replica actually stores multiple values
replica 保存多个键的值以及它们的时间戳，

1010
00:34:18,500 --> 00:34:20,330
0,360 360,630 630,1110 1110,1680 1680,1830
for key namely with their

1011
00:34:20,330 --> 00:34:21,240
0,510
timestamp,|
|

1012
00:34:34,670 --> 00:34:35,780
0,210 210,270 270,780 780,1020 1020,1110
so for example at a
例如，在一个 replica 中，

1013
00:34:35,780 --> 00:34:37,190
0,330 330,720 720,810 810,930 930,1410
particular replica,| we can ask,
|我们可以说，请给我在时间 10 的 x 的值，

1014
00:34:37,190 --> 00:34:38,510
0,300 300,510 510,900 900,990 990,1320
please give me the value

1015
00:34:38,510 --> 00:34:39,920
0,120 120,480 480,690 690,1050 1050,1410
of x at time 10|
|

1016
00:34:39,980 --> 00:34:41,360
0,390 390,540 540,840 840,930 930,1380
or give me the value
或者给我时间戳 20 的 x 的值，

1017
00:34:41,360 --> 00:34:44,390
0,450 630,930 930,1320 1350,2370 2550,3030
of {timestamp -} {x,at} 20,|
|

1018
00:34:44,840 --> 00:34:46,130
0,210 210,630 690,1110 1110,1230 1230,1290
and so sometimes this is
有时这被称为多版本数据库或多版本存储，

1019
00:34:46,130 --> 00:34:48,710
0,240 240,630 630,1260 1680,2130 2130,2580
called multi version {} {databases

1020
00:34:48,710 --> 00:34:50,030
0,90 90,210 210,420 420,750 750,1320
-} or multi version storage,|
|

1021
00:34:50,030 --> 00:34:51,710
0,120 120,360 360,780 780,1110 1110,1680
you know {what,basically} keep,| for
保存，|对于每次更新，保存数据项的一个版本，

1022
00:34:51,710 --> 00:34:53,090
0,240 240,720 720,840 840,1140 1140,1380
every update, {you,know} basically keep

1023
00:34:53,090 --> 00:34:54,680
0,30 30,570 870,1140 1140,1350 1350,1590
a version of the data

1024
00:34:54,680 --> 00:34:55,520
0,270 270,420 420,600 600,720 720,840
item,| so you can go
|这样你可以回到过去。

1025
00:34:55,520 --> 00:34:56,400
0,270 270,360 360,720
back in time.|
|

1026
00:34:58,340 --> 00:35:00,020
0,630 630,750 750,900 900,1110 1110,1680
And, {} so this fixes
所以，这解决了我在第一种情况中展示的问题，

1027
00:35:00,050 --> 00:35:01,850
0,120 120,270 270,1140 1260,1650 1650,1800
you know the problem that

1028
00:35:01,850 --> 00:35:03,050
0,330 360,810 810,870 870,960 960,1200
I showed in the first

1029
00:35:03,050 --> 00:35:04,250
0,300 300,570 570,870 870,1080 1080,1200
case,| because basically what's going
|因为将要发生的事情，

1030
00:35:04,250 --> 00:35:05,210
0,60 60,480 480,690 690,870 870,960
to happen,| let's look at
|让我们再看看这三个事务，

1031
00:35:05,210 --> 00:35:06,770
0,90 90,300 300,810 810,1230 1350,1560
the three transaction again,| so
|我们有 T1 ，我们有 T2 ，我们有 T3 ，

1032
00:35:06,770 --> 00:35:08,180
0,90 90,300 300,510 510,1020 1290,1410
we got {T1 -}, we've

1033
00:35:08,180 --> 00:35:09,920
0,180 180,420 420,990 1080,1320 1320,1740
got {T2 -}, we got

1034
00:35:11,020 --> 00:35:13,390
0,270 270,840 1170,1650 1650,2190 2190,2370
{T3 -},| {} T1 just
|T1 写入 x ，写入 y ，以及提交，

1035
00:35:13,390 --> 00:35:14,920
0,330 330,960 1050,1230 1230,1320 1320,1530
write one, you know there's

1036
00:35:14,920 --> 00:35:16,990
0,150 150,480 810,1410 1620,1980 1980,2070
a write, {} write of

1037
00:35:16,990 --> 00:35:19,060
0,360 360,630 630,1140 1290,1530 1530,2070
x, {write,of} y, [] commit,|
|

1038
00:35:19,300 --> 00:35:20,740
0,480 480,750 750,870 870,1140 1140,1440
let's say the commit actually
我们假设提交发生在 10 ，

1039
00:35:20,740 --> 00:35:23,290
0,510 510,840 840,960 960,2100 2130,2550
happens at you know 10,|
|

1040
00:35:24,220 --> 00:35:26,200
0,270 270,450 450,1200 1200,1620 1620,1980
so this transaction basically runs
所以这个事务在时间戳 10 运行，

1041
00:35:26,200 --> 00:35:27,420
0,90 90,330 330,1020
at timestamp 10,|
|

1042
00:35:27,970 --> 00:35:30,160
0,720 840,1560 1590,1860 1860,2070 2070,2190
{} then you know at
然后在某个时刻，

1043
00:35:30,160 --> 00:35:31,280
0,150 150,690
some point,|
|

1044
00:35:31,500 --> 00:35:32,100
0,120 120,240 240,300 300,450 450,600
we're going to get {}
我们读取 x ，

1045
00:35:32,100 --> 00:35:33,720
0,210 210,870 930,1290 1290,1470 1470,1620
{read,of} x,| we'll talk about
|我们稍后会谈到这一点，

1046
00:35:33,720 --> 00:35:35,370
0,180 180,270 270,330 330,870 1230,1650
that in a second, {}|
|

1047
00:35:35,370 --> 00:35:36,630
0,300 300,690 690,870 870,1170 1170,1260
and here we have this
在这里我们有另一个事务，

1048
00:35:36,630 --> 00:35:38,400
0,210 210,840 840,1530 1530,1680 1680,1770
other transaction,| we get the
|我们有写入 y ，

1049
00:35:38,400 --> 00:35:39,780
0,330 330,420 420,1050
write of y,|
|

1050
00:35:39,990 --> 00:35:41,760
0,450 450,840 930,1470 1470,1530 1530,1770
the write, {sorry -} write
写入 x ，写入 y ，并提交，

1051
00:35:41,760 --> 00:35:43,710
0,300 300,1050 1050,1320 1320,1830 1860,1950
{} x, write y, the

1052
00:35:43,710 --> 00:35:45,480
0,540 810,1020 1020,1140 1140,1350 1350,1770
commit,| let's say this transaction
|假设这个事务在时间戳 20 提交，

1053
00:35:45,480 --> 00:35:46,980
0,390 390,570 570,780 780,990 990,1500
commit at {timestamp -} 20,|
|

1054
00:35:47,580 --> 00:35:50,460
0,540 540,1020
{just,run} basically
在这个时间戳运行，

1055
00:35:50,700 --> 00:35:52,590
0,510 510,990 990,1590 1590,1680 1680,1890
{} {at -} that {timestamp

1056
00:35:52,590 --> 00:35:53,820
0,390 750,930 930,1050 1050,1140 1140,1230
-}| and then we have
|然后我们有读取 x ，

1057
00:35:53,820 --> 00:35:54,570
0,90 90,240 240,300 300,600 600,750
to read of x,| and
|我们有读取 y ，

1058
00:35:54,570 --> 00:35:55,500
0,150 150,240 240,330 330,540 540,930
we have the {read,of} y,|
|

1059
00:35:56,250 --> 00:35:57,030
0,300 300,480 480,540 540,690 690,780
now when the read of
现在当读取 x 发生时，

1060
00:35:57,030 --> 00:35:58,980
0,330 330,1110 1440,1770 1770,1890 1890,1950
x happens,| it's going to
|它将被分配一个时间戳，事务开始的时间，

1061
00:35:58,980 --> 00:36:00,210
0,120 120,420 420,510 510,720 720,1230
be assigned to {timestamp -}

1062
00:36:00,360 --> 00:36:02,250
0,450 450,840 870,1170 1170,1290 1290,1890
starting time, time of transaction,|
|

1063
00:36:02,280 --> 00:36:04,290
0,360 600,1050 1050,1500 1500,1770 1770,2010
so starting times,| let's say
所以开始的时间，|假设这个事务的开始时间是 15 ，

1064
00:36:04,290 --> 00:36:05,520
0,240 240,570 570,840 840,960 960,1230
the starting time of this

1065
00:36:05,520 --> 00:36:07,260
0,390 390,870 870,990 990,1560
{} transaction is 15,|
|

1066
00:36:07,670 --> 00:36:09,890
0,330 330,600 600,1140 1260,1860 1860,2220
so {T2 -} runs at
所以 T2 的运行在 15 ，

1067
00:36:10,670 --> 00:36:12,100
0,840
15,|
|

1068
00:36:12,940 --> 00:36:13,870
0,150 150,270 270,540 540,780 780,930
and so when the read
所以当执行读取 x 时，

1069
00:36:13,870 --> 00:36:16,000
0,90 90,450 450,690 690,1320 1530,2130
of x is executed, {}|
|

1070
00:36:16,000 --> 00:36:17,710
0,510 510,750 750,1260 1260,1440 1440,1710
it needs basically to read
它需要读取 15 之前的 x 的最新值，

1071
00:36:17,710 --> 00:36:20,320
0,120 120,450 450,1050 1170,2460 2460,2610
the latest value {} of

1072
00:36:20,320 --> 00:36:24,010
0,540 570,1350 1350,2550 2580,3030 3030,3690
x, after, {} after, {}

1073
00:36:24,040 --> 00:36:26,590
0,690 690,1380 1680,2010 2010,2490 2490,2550
before 15,| {} and you
|对于时间戳 15 的最新提交值，

1074
00:36:26,590 --> 00:36:28,030
0,510 660,900 900,1020 1020,1320 1320,1440
know to do that, you

1075
00:36:28,030 --> 00:36:29,710
0,120 120,390 420,840 840,1140 1140,1680
know the latest committed value

1076
00:36:29,710 --> 00:36:32,410
0,540 780,1440 1470,1710 1710,1890 1890,2700
for {} {timestamp -} 15,|
|

1077
00:36:32,410 --> 00:36:33,850
0,330 330,570 570,930 930,1350 1350,1440
{before -} timestamp 15 is
在时间戳 15 之前是来自这个时间这个事务的值。

1078
00:36:33,850 --> 00:36:35,230
0,150 150,210 210,450 450,930 930,1380
going to be times the

1079
00:36:35,290 --> 00:36:37,660
0,510 600,1170 1170,1440 1440,2250
the values from {this,transaction}.|
|

1080
00:36:38,720 --> 00:36:40,490
0,210 210,810 810,1140 1140,1380 1410,1770
So {read,x}, reads the value
所以读取 x 读取事务 1 的值，

1081
00:36:40,490 --> 00:36:42,290
0,60 60,480 480,900 1260,1620 1620,1800
of transaction 1,| {} but
|当然，读取 y 也将在事务开始的时间戳执行，

1082
00:36:42,290 --> 00:36:43,850
0,90 90,540 540,1050 1050,1410 1410,1560
of course, {read,y} also will

1083
00:36:43,850 --> 00:36:45,110
0,450 450,540 540,630 630,900 900,1260
execute at the {timestamp -}

1084
00:36:45,260 --> 00:36:46,430
0,390 390,720 720,1020 1020,1110 1110,1170
of the start of the

1085
00:36:46,430 --> 00:36:47,660
0,600 600,810 810,930 930,1080 1080,1230
transaction,| so it's going to
|所以它也会读取时间 15 的 y ，

1086
00:36:47,660 --> 00:36:49,070
0,270 270,930 930,1020 1020,1110 1110,1410
also {read,y} at that time

1087
00:36:49,340 --> 00:36:51,350
0,150 150,960 1320,1830 1830,1920 1920,2010
at 15,| and you know
|在时间戳 15 ， y 只有一个值，

1088
00:36:51,350 --> 00:36:52,010
0,180 180,300 300,360 360,450 450,660
there's going to be only

1089
00:36:52,010 --> 00:36:54,260
0,180 180,720 720,960 990,1620 1620,2250
one value for y 15,|
|

1090
00:36:54,290 --> 00:36:55,760
0,540 540,750 750,930 930,1080 1080,1470
namely that is the one
也就是由事务 T1 产生的，

1091
00:36:55,760 --> 00:36:57,650
0,480 480,780 780,1050 1050,1680 1680,1890
produced by the transaction {T1

1092
00:36:57,650 --> 00:36:59,300
0,330 330,900 900,1050 1050,1200 1200,1650
-},| and so read one,
|所以读取 y 也会从 T1 开始，

1093
00:36:59,570 --> 00:37:01,400
0,510 570,900 900,1170 1170,1350 1350,1830
{} read y will also

1094
00:37:01,460 --> 00:37:03,710
0,750 1140,1350 1350,1830 1830,2130 2130,2250
reads from {T1 -},| and
|所以，我们避免了之前遇到的这个问题，

1095
00:37:03,710 --> 00:37:05,300
0,120 120,300 300,810 1080,1230 1230,1590
so we avoid this problem

1096
00:37:05,300 --> 00:37:06,950
0,150 150,270 270,420 420,1050 1230,1650
that we had before,| where
|那个我们从不同的事务中读取。

1097
00:37:06,950 --> 00:37:09,650
0,810 840,1440 1440,1560 1560,2070 2070,2700
we read from different transactions.|
|

1098
00:37:10,590 --> 00:37:12,180
0,270 270,390 390,570 570,1020 1260,1590
And so this gives the
所以，这提供了我们寻找的线性一致性或串行化，

1099
00:37:12,210 --> 00:37:14,400
0,900 900,1050 1050,1350 1350,1770 1770,2190
linearizability or {} {serializability -}

1100
00:37:14,400 --> 00:37:15,990
0,150 150,420 420,690 690,1140 1380,1590
that we're looking for,| all
|所有事务都以全局时间戳顺序执行。

1101
00:37:15,990 --> 00:37:17,340
0,90 90,600 600,750 750,1230 1230,1350
the transactions are executed in

1102
00:37:17,340 --> 00:37:19,080
0,210 300,750 750,1020 1020,1320 1350,1740
a global {timestamp -} order.|
|

1103
00:37:22,770 --> 00:37:23,840
0,150 150,240 240,360 360,780
Does that make sense?|
这能理解吗？|

1104
00:37:25,670 --> 00:37:26,450
0,150 150,450 450,540 540,630 630,780
So what you can think
所以你可以考虑的是，

1105
00:37:26,450 --> 00:37:27,590
0,240 240,330 330,480 480,750 750,1140
about is that,| every replica
|每个 replica 有一个表，

1106
00:37:27,590 --> 00:37:30,340
0,420 420,690 690,780 780,1290
basically keeps a table,|
|

1107
00:37:30,700 --> 00:37:33,400
0,1350 1350,1500 1500,1710 1710,2400 2400,2700
{write,of,values} and {timestamps -},| and
写入值和时间戳，|所以我们有 x 值为 9@10 ，

1108
00:37:33,400 --> 00:37:34,570
0,390 390,570 570,720 720,960 960,1170
so we're gonna have like

1109
00:37:34,570 --> 00:37:38,560
0,570 570,1110 1380,2070 2070,2820 3600,3990
x at value {9@10 -

1110
00:37:38,560 --> 00:37:41,890
0,630 960,1440 1440,1950 1950,2370 2370,3330
-}| and x at value
|以及 x 值为 8@20 。

1111
00:37:41,890 --> 00:37:44,920
0,480 990,1590 1620,2340
{8@20 - -}.|
|

1112
00:37:45,260 --> 00:37:46,130
0,210 210,330 330,570 570,660 660,870
And so when the read
所以当读取到达一个 replica 时，

1113
00:37:46,130 --> 00:37:47,000
0,180 180,510 510,600 600,780 780,870
comes in you know at

1114
00:37:47,000 --> 00:37:49,070
0,30 30,360 360,1140 1290,1710 1710,2070
a particular replica,| {you,know,reads} 15
|读取 15 进来，

1115
00:37:49,070 --> 00:37:49,850
0,180 180,330 330,390 390,510 510,780
comes in,| I can just
|我可以挑选它的时间戳之前的最新的写入。

1116
00:37:49,880 --> 00:37:50,990
0,270 270,540 540,660 660,780 780,1110
pick out you know the

1117
00:37:51,050 --> 00:37:53,300
0,780 810,1500 1500,1590 1590,1710 1710,2250
latest write you know preceding

1118
00:37:53,300 --> 00:37:54,300
0,150 150,420 420,810
its {timestamp -}.|
|

1119
00:37:56,690 --> 00:37:57,560
0,240 240,330 330,480 480,540 540,870
So I have a question,|
所以我有一个问题，|

1120
00:37:57,560 --> 00:37:58,850
0,330 330,720 720,1020 1020,1110 1110,1290
so {} when we do
当我们读取 x 的时候，

1121
00:37:58,850 --> 00:38:00,350
0,270 270,510 510,1020 1080,1320 1320,1500
the read x,| let's say,
|假设我们只关注读取 x ，

1122
00:38:00,350 --> 00:38:01,130
0,120 120,240 240,390 390,660 660,780
so let's just focus on

1123
00:38:01,130 --> 00:38:03,320
0,150 150,450 780,1380 1380,1590 1590,2190
read x,| so x itself
|x 本身存在于一些分片上，

1124
00:38:03,350 --> 00:38:05,270
0,720 720,900 900,1110 1110,1650 1650,1920
exists on some shard,| which
|被复制在 Paxos 组上，

1125
00:38:05,270 --> 00:38:05,900
0,480
is

1126
00:38:06,100 --> 00:38:08,020
0,600 600,690 690,780 780,1470 1500,1920
replicated on a Paxos group,|
|

1127
00:38:08,020 --> 00:38:09,670
0,210 210,420 420,1080 1410,1560 1560,1650
which let's say you know
假设有三台服务器复制 x ，

1128
00:38:09,670 --> 00:38:10,930
0,240 240,330 330,570 570,750 750,1260
there are like three servers

1129
00:38:10,930 --> 00:38:13,000
0,570 600,1050 1050,1290 1650,1890 1890,2070
that replicate x,| and when
|当你读取 x 时，

1130
00:38:13,000 --> 00:38:13,990
0,150 150,300 300,450 450,690 690,990
you read from x,| because
|因为我们希望只读事务非常快，

1131
00:38:13,990 --> 00:38:14,770
0,90 90,330 330,420 420,570 570,780
we want to {read-only -}

1132
00:38:14,770 --> 00:38:16,150
0,540 540,630 630,690 690,960 960,1380
transactions to be very fast,|
|

1133
00:38:16,150 --> 00:38:17,440
0,480 510,840 840,1050 1050,1200 1200,1290
we just read from the
我们只从本地 replica 中读取，

1134
00:38:17,440 --> 00:38:20,050
0,660 840,1560 1620,2070 2160,2430 2430,2610
local replica,| which need not
|它不一定是领导者，

1135
00:38:20,050 --> 00:38:22,540
0,480 480,570 570,690 690,1140 2190,2490
necessarily be the leader,| so
|那么，我们如何保证我们不会读到旧的，

1136
00:38:22,540 --> 00:38:23,530
0,150 150,390 390,480 480,600 600,990
like how do we guarantee

1137
00:38:23,530 --> 00:38:24,340
0,120 120,210 210,480 510,720 720,810
that we don't read the

1138
00:38:24,340 --> 00:38:26,650
0,690 1230,1350 1350,1680 1710,2160 2160,2310
stale,| how do that {we,don't}
|我们如何不获取旧的？

1139
00:38:26,650 --> 00:38:27,640
0,180 180,240 240,780
make a stale?|
|

1140
00:38:28,190 --> 00:38:30,350
0,150 150,390 390,960 960,1500 1530,2160
You know brilliant question,| and
好问题，|这正是我接下来想要谈论的话题。

1141
00:38:30,380 --> 00:38:32,420
0,510 870,1080 1080,1620 1620,1710 1710,2040
{} that's exactly the topic

1142
00:38:32,420 --> 00:38:33,170
0,60 60,270 270,360 360,570 570,750
I want to talk about

1143
00:38:33,170 --> 00:38:33,900
0,540
next.|
|

1144
00:38:34,520 --> 00:38:37,730
0,780 1410,1980 1980,2610 2610,2910 2910,3210
{} {The,problem} as you point
正如你所指出的问题，

1145
00:38:37,730 --> 00:38:39,290
0,330 330,450 450,1260 1290,1500 1500,1560
out,| you know there's a
|这里有一个挑战，

1146
00:38:39,290 --> 00:38:40,640
0,360 360,540 540,870 870,990 990,1350
challenge,| that maybe the replica
|replica 可能没有看到，

1147
00:38:40,640 --> 00:38:42,660
0,300 300,780
hasn't seen,|
|

1148
00:38:45,920 --> 00:38:47,630
0,210 210,300 300,930 960,1170 1170,1710
{hasn't -} seen the write
没有看到写入 x 在时间戳 10 ，

1149
00:38:47,780 --> 00:38:50,120
0,150 150,810 810,1230 1680,2010 2010,2340
to x at {timestamp -}

1150
00:38:50,120 --> 00:38:52,040
0,360 360,750
whatever 10,

1151
00:38:52,320 --> 00:38:53,220
0,480
right,|
|

1152
00:38:54,500 --> 00:38:56,360
0,570 780,960 960,1140 1140,1260 1260,1860
{} and so the way
在 Spanner 中解决这个问题的方法，

1153
00:38:56,360 --> 00:38:58,730
0,750 780,1080 1080,1440 1440,1740 1740,2370
{} {you,know} this problem solved

1154
00:38:58,790 --> 00:39:01,040
0,450 450,1080 1080,1560 1590,2160 2160,2250
{} in the Spanner,| the
|解决方案他们称为 "safe time" ，

1155
00:39:01,040 --> 00:39:02,420
0,330 330,450 450,930 930,1200 1200,1380
solution they called something that's

1156
00:39:02,420 --> 00:39:04,060
0,390 390,570 570,900 900,1290
called {} "safe time",|
|

1157
00:39:09,560 --> 00:39:11,600
0,780 810,1260 1260,1620 1620,1830 1830,2040
and, {} so the way
所以，这个结果是这样的，

1158
00:39:11,600 --> 00:39:13,250
0,450 450,1050 1050,1140 1140,1350 1350,1650
this result is that,| basically
|Paxos 或 Raft 也按时间戳顺序发送所有写入，

1159
00:39:13,250 --> 00:39:17,000
0,810 1740,2490 2790,2970 2970,3450 3450,3750
Paxos {or,Raft} you know sends

1160
00:39:17,000 --> 00:39:18,380
0,240 240,840
all writes

1161
00:39:19,840 --> 00:39:21,670
0,690 690,810 810,1020 1020,1290 1290,1830
also in {timestamp -} order,|
|

1162
00:39:25,280 --> 00:39:27,770
0,180 180,390 390,630 630,840 2040,2490
so there's not,| {} {you,know,you}
所以没有，|你可以考虑总顺序是一个计数，

1163
00:39:27,770 --> 00:39:28,850
0,120 120,240 240,690 690,780 780,1080
can think about the total

1164
00:39:28,850 --> 00:39:30,110
0,270 270,420 420,570 570,630 630,1260
order is now a counter,|
|

1165
00:39:30,110 --> 00:39:31,490
0,150 150,450 450,930 930,1020 1020,1380
as usual {for,example -} maybe
类似比如在实验 3 中，

1166
00:39:31,490 --> 00:39:35,390
0,240 240,1200 1230,2130 2670,3270 3300,3900
in {} lab, {} lab

1167
00:39:35,390 --> 00:39:36,530
0,420 450,690 690,810 810,1080 1080,1140
3,| but it actually is
|但它实际上是一个时间戳，

1168
00:39:36,530 --> 00:39:37,850
0,360 360,420 420,630 630,990 1080,1320
literally a {timestamp -},| and
|由于时间戳形成了全局顺序，

1169
00:39:37,850 --> 00:39:39,170
0,210 210,270 270,750 750,1050 1050,1320
since the timestamp also form

1170
00:39:39,170 --> 00:39:41,450
0,330 330,1200 1470,1800 1800,2100 2100,2280
global order,| that global order
|时间戳的全局顺序足够对所有写入进行排序。

1171
00:39:41,450 --> 00:39:42,410
0,90 90,300 300,690 690,780 780,960
of {timestamps -} you know

1172
00:39:42,410 --> 00:39:43,700
0,510 510,810 810,1110 1110,1200 1200,1290
sufficient to order all the

1173
00:39:43,700 --> 00:39:44,340
0,450
writes.|
|

1174
00:39:45,000 --> 00:39:46,680
0,540 540,780 780,1290 1320,1590 1590,1680
{} And then there's a
然后有一条规则，

1175
00:39:46,680 --> 00:39:48,120
0,480 480,630 630,720 720,1170 1170,1440
rule,| there's an additional rule
|对于读取，还有一个额外的规则，

1176
00:39:48,120 --> 00:39:49,080
0,210 210,660
for read,|
|

1177
00:39:49,800 --> 00:39:51,600
0,600 600,690 690,960 960,1500
before you do read,|
在你读取之前，|

1178
00:39:52,980 --> 00:39:54,360
0,240 240,570 570,750 750,810 810,1380
so before read of x
所以在读取时间戳 15 的 x 之前，

1179
00:39:54,820 --> 00:40:00,640
0,780 1230,1830 2610,2790 2790,3030 3030,5820
{} at you know {timestamp,15},|
|

1180
00:40:00,820 --> 00:40:02,340
0,450 450,600 600,720 720,1260
{the,replica} has to wait
replica 必须等待时间戳大于 15 的写入，

1181
00:40:02,990 --> 00:40:03,780
0,240
{}

1182
00:40:04,580 --> 00:40:06,400
0,390 390,1050
for write,

1183
00:40:07,020 --> 00:40:09,180
0,480 480,1050 1260,1710 1710,1950 1950,2160
that is with {timestamp -}

1184
00:40:09,180 --> 00:40:10,580
0,300 300,840
{bigger,than} 15,|
|

1185
00:40:11,810 --> 00:40:13,670
0,390 390,720 720,1110 1110,1320 1320,1860
this sees write with timestamp
看到时间戳大于 15 的写入，

1186
00:40:13,670 --> 00:40:15,350
0,180 180,300 300,900 1140,1350 1350,1680
bigger than 15,| it knows
|它就知道在 15 之前不会再有写入，

1187
00:40:15,350 --> 00:40:16,340
0,120 120,240 240,540 540,750 750,990
that there's certainly no writes

1188
00:40:16,340 --> 00:40:18,040
0,420 420,810 810,1440
anymore before 15,|
|

1189
00:40:18,300 --> 00:40:19,890
0,540 540,660 660,1080 1080,1350 1350,1590
and so therefore { -}
所以安全地在时间戳 15 执行读取，

1190
00:40:19,920 --> 00:40:21,300
0,420 420,510 510,900 900,990 990,1380
safe to execute the read

1191
00:40:21,330 --> 00:40:23,060
0,510 510,750 750,1410
at timestamp 15,|
|

1192
00:40:23,270 --> 00:40:24,680
0,180 180,510 510,780 780,1140 1140,1410
and know what value actually
并且知道需要返回什么值。

1193
00:40:24,680 --> 00:40:25,960
0,180 180,270 270,390 390,870
needs to be returned.|
|

1194
00:40:26,520 --> 00:40:28,140
0,240 240,660 690,1050 1050,1470 1470,1620
And so for services that
所以，对于服务而言，

1195
00:40:28,140 --> 00:40:29,520
0,360 630,870 870,1020 1020,1260 1260,1380
are,| so this means that,|
|所以，这意味着，|

1196
00:40:29,520 --> 00:40:30,540
0,60 60,540 540,780 780,960 960,1020
the {read,actually} may have to
读取可能必须稍微延迟一点，直到下一次写入，

1197
00:40:30,540 --> 00:40:31,410
0,150 150,240 240,630 630,660 660,870
get a delayed a little

1198
00:40:31,410 --> 00:40:32,610
0,240 240,600 600,660 660,870 870,1200
bit, until the next write,|
|

1199
00:40:32,610 --> 00:40:33,420
0,90 90,150 150,420 420,570 570,810
{you,know} of course for busy
当然，对于忙的服务器，

1200
00:40:33,420 --> 00:40:34,920
0,630 630,990 990,1230 1230,1350 1350,1500
servers,| these writes will come
|这些写入一直到来，

1201
00:40:34,920 --> 00:40:36,570
0,330 330,600 600,690 690,1170 1380,1650
along all the time,| and
|所以，等待可能不存在或几乎不存在。

1202
00:40:36,570 --> 00:40:38,850
0,150 150,390 390,780 780,1230 1230,2280
so that wait probably non-existence

1203
00:40:38,850 --> 00:40:40,240
0,150 150,480 480,630 630,1200
or almost {non-existence -}.|
|

1204
00:40:40,930 --> 00:40:42,460
0,600 900,1170 1170,1320 1320,1410 1410,1530
Okay?| But this is the
好的?|但这是需要遵循的规则，

1205
00:40:42,460 --> 00:40:43,240
0,270 270,420 420,600 600,660 660,780
rule that needs to be

1206
00:40:43,240 --> 00:40:44,380
0,390 390,480 480,660 660,930 930,1140
followed,| to make sure that
|为了确保（避免）这个问题，

1207
00:40:44,380 --> 00:40:47,080
0,330 330,510 510,1050 1350,2130 2160,2700
indeed this problem,| of replica
|没有看到写入的 write 返回错误的值。

1208
00:40:47,080 --> 00:40:48,130
0,270 270,300 300,420 420,690 690,1050
actually {} have not seen

1209
00:40:48,130 --> 00:40:49,990
0,90 90,300 300,660 930,1590 1590,1860
the write yet { -}

1210
00:40:49,990 --> 00:40:51,300
0,360 360,420 420,600 600,1020
returning the wrong value.|
|

1211
00:40:52,250 --> 00:40:54,110
0,150 150,360 360,900 900,1080 1080,1860
The real slightly more complicated,|
真正的情况要稍微复杂一些，|

1212
00:40:54,470 --> 00:40:55,730
0,630 660,840 840,1020 1020,1140 1140,1260
{} you also have to
你也必须等待，

1213
00:40:55,730 --> 00:40:56,720
0,720
wait,|
|

1214
00:40:57,260 --> 00:40:58,970
0,480 480,750 750,1020 1020,1110 1110,1710
{} also wait for transactions
还要等待已准备好但未提交的事务，

1215
00:40:58,970 --> 00:41:00,140
0,180 180,330 330,870 870,960 960,1170
that have prepared but not

1216
00:41:00,140 --> 00:41:01,020
0,480
committed,|
|

1217
00:41:19,410 --> 00:41:20,580
0,180 180,630 630,780 780,990 990,1170
for example, this transaction might
例如，这个事务已经准备好了，在时间戳 14 ，

1218
00:41:20,580 --> 00:41:22,320
0,120 120,510 540,1050 1050,1470 1470,1740
have been prepared, basically {}

1219
00:41:22,350 --> 00:41:23,730
0,120 120,390 450,810 840,1110 1110,1380
you know {} {timestamp -}

1220
00:41:23,730 --> 00:41:25,470
0,750 960,1170 1170,1320 1320,1440 1440,1740
14,| {} but it hasn't
|但它可能还没有提交写入到键值存储，

1221
00:41:25,470 --> 00:41:27,000
0,270 270,900 900,1140 1140,1440 1440,1530
maybe committed write yet you

1222
00:41:27,000 --> 00:41:29,340
0,150 150,480 480,1410 1890,2040 2040,2340
know to the key value

1223
00:41:29,340 --> 00:41:30,660
0,570 750,990 990,1110 1110,1200 1200,1320
store,| and so we got
|所以，我们要确保，

1224
00:41:30,660 --> 00:41:31,530
0,60 60,210 210,570 570,750 750,870
to make sure that,| you
|任何在我们读取时间戳前准备好的事务，

1225
00:41:31,530 --> 00:41:33,450
0,360 510,1020 1020,1410 1410,1830 1830,1920
know {} any transaction that

1226
00:41:33,450 --> 00:41:34,560
0,240 240,360 360,420 420,840 840,1110
was { -} {prepared -}

1227
00:41:34,650 --> 00:41:37,140
0,1020 1020,1560 1560,1770 1770,2010 2010,2490
before our read {timestamp -},|
|

1228
00:41:37,170 --> 00:41:38,730
0,210 210,540 540,960 960,1440 1440,1560
that actually commits before we
必须在我们返回读取值之前提交。

1229
00:41:38,730 --> 00:41:39,780
0,180 180,420 420,480 480,900 900,1050
actually return the value of

1230
00:41:39,780 --> 00:41:42,540
0,270 660,1110 1140,1740
the read.| Okay?|
|好的?|

1231
00:41:44,050 --> 00:41:45,200
0,150 150,300 300,420 420,870
Does this make sense?|
这能理解吗？|

1232
00:41:46,510 --> 00:41:48,880
0,270 270,600 600,960 960,1680 1710,2370
{} Would this also be
不同的分片是否也是这样，

1233
00:41:49,060 --> 00:41:50,710
0,180 180,600 600,750 750,1200 1200,1650
the case for different shards,|
|

1234
00:41:50,710 --> 00:41:51,940
0,60 60,180 180,360 360,810 810,1230
{} do we consider different
我们是否单独考虑不同的分片？

1235
00:41:51,940 --> 00:41:54,120
0,600 600,1890
shards separately?|
|

1236
00:41:55,770 --> 00:41:57,570
0,570 600,870 870,960 960,1410 1410,1800
{ -} The {read,just} hit
读取只命中本地的分片，本地的 replica ，

1237
00:41:57,570 --> 00:41:59,180
0,210 210,690 690,1320
the local shard,

1238
00:42:01,740 --> 00:42:04,470
0,270 270,570 570,900 900,1440 1800,2730
right, the local replica, {}|
|

1239
00:42:05,090 --> 00:42:06,140
0,270 270,420 420,600 600,810 810,1050
so I'm not hundred percent
所以我不是百分之百确定你问我的问题。

1240
00:42:06,140 --> 00:42:07,250
0,180 180,510 510,600 600,1020 1020,1110
sure what the question you

1241
00:42:07,250 --> 00:42:08,570
0,240 240,420 630,840 840,1080 1080,1320
ask me.| I think I
|我想我的问题是，

1242
00:42:08,570 --> 00:42:09,620
0,180 180,240 240,570 570,690 690,1050
think the question I'm asking

1243
00:42:09,620 --> 00:42:12,980
0,330 690,1140 1140,1890 1890,2940 3060,3360
is,| the correctness guarantees do
|正确性保证适用于跨分片吗？

1244
00:42:12,980 --> 00:42:15,960
0,210 210,1020 1110,1890 1890,2790
they apply across shards?|
|

1245
00:42:16,830 --> 00:42:18,330
0,570 570,720 720,1050 1050,1200 1200,1500
Yes, you know they apply
是的，它们适用于事务级别，

1246
00:42:18,330 --> 00:42:19,860
0,240 240,450 450,540 540,1230 1260,1530
the level of transactions, right,|
|

1247
00:42:19,860 --> 00:42:21,780
0,480 690,1320 1320,1500 1500,1860 1860,1920
so {} so if a
如果只读读取本地 replica ，

1248
00:42:21,780 --> 00:42:22,890
0,240 240,510 510,720 720,780 780,1110
{read-only -} read a local

1249
00:42:22,890 --> 00:42:24,150
0,630 690,840 840,1050 1050,1200 1200,1260
replica,| we still have to
|我们仍然需要确保事务的一致性，

1250
00:42:24,150 --> 00:42:25,440
0,150 150,420 420,600 600,720 720,1290
make sure that the transactions

1251
00:42:25,440 --> 00:42:27,600
0,510 540,1290 1290,1920
are extremely consistent,|
|

1252
00:42:27,810 --> 00:42:29,250
0,450 450,630 630,930 930,1110 1110,1440
and by following these rules,
通过遵循这些规则，我们实现了这个目标。

1253
00:42:29,250 --> 00:42:30,660
0,360 360,660 660,810 810,1110
we achieved that goal.|
|

1254
00:42:31,910 --> 00:42:33,770
0,690 720,930 930,1200 1200,1440 1440,1860
Okay, make sense, thank you.|
好的，理解了，谢谢。|

1255
00:42:37,150 --> 00:42:40,450
0,600 630,1260 1440,2040 2040,2790 3120,3300
Okay, {} now, { -
好的，现在，我们要看 Spanner 论文的核心部分，

1256
00:42:40,450 --> 00:42:41,980
0,180 180,870 870,1080 1080,1200 1200,1530
-} we're going to {sort,of}

1257
00:42:41,980 --> 00:42:45,370
0,1920 1950,2340 2340,2670 2670,2790 2790,3390
the core part of the

1258
00:42:45,490 --> 00:42:46,540
0,330 330,510 510,780 780,990 990,1050
{Spanner -} paper,| which is
|这将是，

1259
00:42:46,540 --> 00:42:48,370
0,510 750,870 870,1380 1410,1770 1770,1830
really {to,be},| we want to
|我们想要理解时间，比如时间戳，

1260
00:42:48,370 --> 00:42:49,510
0,240 240,480 480,780 780,930 930,1140
reason about time, like {timestamps

1261
00:42:49,510 --> 00:42:50,260
0,600
-},|
|

1262
00:42:50,700 --> 00:42:51,870
0,180 180,300 300,450 450,720 720,1170
{} in this case, then
在这种情况下，时钟，

1263
00:42:51,960 --> 00:42:53,100
0,150 150,240 240,450 450,1020 1020,1140
you know the clocks,| you
|不同服务器的时钟必须准确，

1264
00:42:53,100 --> 00:42:57,280
0,870 1200,1890 2370,2730 2730,3180
know {} different servers

1265
00:42:57,780 --> 00:43:00,270
0,390 390,690 690,1500 1530,2100 2160,2490
{} must be, {} clock

1266
00:43:00,270 --> 00:43:01,410
0,180 180,240 240,600 870,960 960,1140
must be good,| it must
|它必须是完美的，

1267
00:43:01,410 --> 00:43:02,970
0,90 90,540 660,990 990,1410 1410,1560
be perfect,| people must, {you,know}
|不同的参与者必须就时间戳顺序达成一致，

1268
00:43:02,970 --> 00:43:04,650
0,270 270,750 750,1170 1170,1530 1530,1680
different participants must agree on

1269
00:43:04,650 --> 00:43:07,020
0,240 570,840 840,1080 1080,1680 1800,2370
the {timestamp -} order,| and
|如果事务使用特定的时间戳，

1270
00:43:07,020 --> 00:43:08,340
0,360 360,810 810,1080 1080,1290 1290,1320
{} if {the,transaction} takes a

1271
00:43:08,340 --> 00:43:09,900
0,390 390,660 660,1110 1350,1440 1440,1560
particular {timestamp -},| you know
|在系统的中任何地方，时间戳都必须是相同的，

1272
00:43:09,900 --> 00:43:10,980
0,180 180,390 390,720 720,930 930,1080
that {timestamp -} must be

1273
00:43:10,980 --> 00:43:11,910
0,120 120,300 300,360 360,690 690,930
the sort of same {timestamp

1274
00:43:11,910 --> 00:43:13,200
0,270 270,750 750,840 840,930 930,1290
-} everywhere in the system,|
|

1275
00:43:14,060 --> 00:43:15,920
0,420 420,750 990,1470 1470,1710 1710,1860
{} so, {} and so
所以，就像我在之前的幻灯片中描述的那样，

1276
00:43:15,920 --> 00:43:17,690
0,150 150,690 1050,1320 1320,1710 1710,1770
the way I've described it

1277
00:43:17,690 --> 00:43:21,200
0,90 90,210 210,960 1020,2430 2490,3510
in {} previous {} slides,|
|

1278
00:43:21,200 --> 00:43:22,790
0,90 90,660 660,1020 1020,1140 1140,1590
you know whatever {} {participants
参与者选择读取事务，

1279
00:43:22,790 --> 00:43:24,830
0,390 390,780 780,1020 1020,1260 1260,2040
-} picks the the {read,transaction},|
|

1280
00:43:24,920 --> 00:43:26,210
0,450 450,480 480,750 750,1050 1050,1290
assigns a {timestamp -} to
分配一个像 15 这样的时间戳，

1281
00:43:26,210 --> 00:43:27,980
0,210 210,960 1230,1410 1410,1710 1710,1770
like 15,| which {maybe -}
|可能往回一点，

1282
00:43:27,980 --> 00:43:28,970
0,120 120,390 390,420 420,660 660,990
go back a little bit,|
|

1283
00:43:29,210 --> 00:43:30,350
0,120 120,390 420,930 930,1020 1020,1140
you know here you know
这里，我们为这些事务分配时间戳，

1284
00:43:30,350 --> 00:43:31,880
0,180 180,360 360,870 870,1320 1350,1530
we're just assigning {} {timestamp

1285
00:43:31,880 --> 00:43:33,980
0,330 330,420 420,570 570,1320 1620,2100
-} to these transactions,| and
|最好是这种情况，

1286
00:43:33,980 --> 00:43:34,910
0,150 150,390 390,510 510,570 570,930
it better be the case,|
|

1287
00:43:34,910 --> 00:43:35,900
0,240 240,480 480,630 630,780 780,990
that like actually {T1 -}
T1 T2 T3 就这些时间戳达成一致，

1288
00:43:35,900 --> 00:43:36,980
0,120 120,240 240,450 450,840 840,1080
and {T2 -} {T3 -}

1289
00:43:36,980 --> 00:43:38,540
0,540 540,720 720,840 840,1080 1080,1560
agree on these {timestamps -},|
|

1290
00:43:39,650 --> 00:43:40,790
0,630 630,870 870,990 990,1050 1050,1140
{} and that they are
而且它们具有可比性，

1291
00:43:40,790 --> 00:43:43,520
0,630 1380,1680 1680,2070 2220,2610 2610,2730
comparable,| and so as we'll
|我们稍后会看到，

1292
00:43:43,520 --> 00:43:46,310
0,540 570,1770 1770,2370 2370,2700 2700,2790
see {} in a, in

1293
00:43:46,310 --> 00:43:48,710
0,60 60,570 810,1410 1470,2160 2160,2400
a second,| {} this only
|这只对只读事务非常重要，

1294
00:43:48,710 --> 00:43:49,820
0,330 330,540 540,660 660,840 840,1110
matters really for {read-only -}

1295
00:43:49,820 --> 00:43:52,140
0,780
transactions,|
|

1296
00:43:54,830 --> 00:43:56,240
0,810

1297
00:44:05,250 --> 00:44:07,230
0,600 810,1020 1020,1290 1290,1650 1650,1980
{} and we {can,you} know
我们可以考虑这两种情况，

1298
00:44:07,230 --> 00:44:08,820
0,600 600,720 720,810 810,1320 1320,1590
consider the two cases,| like
|会发生什么，

1299
00:44:08,820 --> 00:44:10,500
0,540 540,1080 1110,1320 1320,1440 1440,1680
what happens,| here's a question
|我们想问的问题是，

1300
00:44:10,500 --> 00:44:11,220
0,90 90,180 180,330 330,420 420,720
that we want to ask

1301
00:44:11,220 --> 00:44:12,390
0,270 420,600 600,900 900,1020 1020,1170
is,| what happens is like
|如果一个 replica 或服务器时间错误会发生什么，

1302
00:44:12,390 --> 00:44:14,130
0,270 270,780 780,840 840,1230 1230,1740
one replica or one server

1303
00:44:14,130 --> 00:44:15,570
0,210 210,600 600,690 690,990 990,1440
just has the wrong {time\,,right},|
|

1304
00:44:16,400 --> 00:44:17,930
0,300 300,450 450,540 540,840 840,1530
and so it doesn't agree
所以它与其他服务器的时间不一致，

1305
00:44:17,930 --> 00:44:18,770
0,210 210,300 300,600 600,720 720,840
with the time that the

1306
00:44:18,770 --> 00:44:21,650
0,180 180,720 1350,1890 1890,2730 2730,2880
other servers,| {} what kind
|会带来什么样的问题，

1307
00:44:21,650 --> 00:44:23,420
0,60 60,360 360,1020 1020,1590 1590,1770
of problems could introduce,| so
|那么我们先来考虑一下这种情况，

1308
00:44:23,420 --> 00:44:24,290
0,180 180,450 450,600 600,810 810,870
let's first think about the

1309
00:44:24,290 --> 00:44:25,910
0,540 870,1020 1020,1080 1080,1320 1320,1620
case,| what the {timestamp -}
|如果时间戳太大了，会怎么样？

1310
00:44:25,910 --> 00:44:27,140
0,180 180,330 330,1020
is too large?|
|

1311
00:44:28,800 --> 00:44:29,920
0,90

1312
00:44:32,740 --> 00:44:34,540
0,570 570,960 960,1050 1050,1740 1740,1800
{} So, for example you
例如，我们回到这里的版本，

1313
00:44:34,540 --> 00:44:35,530
0,240 240,420 420,540 540,810 810,990
know, let's go back to

1314
00:44:35,530 --> 00:44:38,530
0,450 1170,1650 1650,1980 1980,2190 2190,3000
our {version,here},| with this case,|
|在这种情况下，|

1315
00:44:38,860 --> 00:44:41,410
0,180 180,390 390,780 780,1410 2340,2550
so let's say the {read-only
假设只读事务开始读取，

1316
00:44:41,410 --> 00:44:43,780
0,240 240,630 630,900 900,1500 1740,2370
-} transaction starts reading,| and
|它读取不是 15 ，

1317
00:44:43,780 --> 00:44:45,880
0,420 420,1080 1080,1410 1410,1770 1770,2100
{it,reads} actually {} instead of

1318
00:44:45,880 --> 00:44:46,700
0,0
{}

1319
00:44:47,020 --> 00:44:49,330
0,630 960,1080 1080,1260 1260,1920 1920,2310
{} you know 15,| maybe
|也许实际上返回的值是 25 ，

1320
00:44:49,330 --> 00:44:51,160
0,360 360,450 450,840 840,1350 1350,1830
whatever the value returns actually

1321
00:44:51,160 --> 00:44:51,980
0,600
is

1322
00:44:52,220 --> 00:44:53,700
0,360 360,1200
{} 25,|
|

1323
00:44:55,630 --> 00:44:57,250
0,480 480,990 990,1140 1140,1230 1230,1620
and what would that do,|
会发生什么，|

1324
00:44:58,930 --> 00:44:59,740
0,300 300,570 570,690 690,780 780,810
or let make it a
或者让它简单一点 18 ，

1325
00:44:59,740 --> 00:45:01,420
0,210 210,780 780,870 870,1080 1080,1680
little simpler you know 18,|
|

1326
00:45:04,310 --> 00:45:05,700
0,150 150,330 330,480 480,1050
to get less confusion,|
为了减少混乱，|

1327
00:45:06,210 --> 00:45:07,200
0,120 120,210 210,450 450,900 900,990
you know what, what is
时间戳偏差的结果是什么，

1328
00:45:07,200 --> 00:45:08,340
0,150 150,510 510,630 630,900 900,1140
the outcome of actually having

1329
00:45:08,340 --> 00:45:09,600
0,60 60,270 270,600 600,840 1050,1260
{} {timestamp -} that is

1330
00:45:09,600 --> 00:45:10,980
0,450 450,750 750,1080 1080,1200 1200,1380
off,| but off in the
|但是偏差往大的方向。

1331
00:45:10,980 --> 00:45:12,540
0,450 450,540 540,720 720,870 870,1560
direction of being too large.|
|

1332
00:45:15,780 --> 00:45:17,280
0,180 180,450 450,660 660,840 840,1500
It's still less than 25,|
它仍然小于 25 ，|

1333
00:45:17,280 --> 00:45:19,260
0,300 300,420 420,750 750,1200 1500,1980
does it still read []
如果它仍然读取[]于 20 ，

1334
00:45:19,260 --> 00:45:20,790
0,360 390,900 930,1200 1200,1290 1290,1530
than 20,| does it still
|它仍然读取第一个，

1335
00:45:20,790 --> 00:45:22,980
0,270 270,510 510,1020 1380,1920 1920,2190
read from the first one,|
|

1336
00:45:22,980 --> 00:45:23,970
0,150 150,240 240,420 420,810 810,990
but if it's later,| it'll
但是如果晚一点，|它将读取第二个。

1337
00:45:23,970 --> 00:45:25,500
0,240 240,420 420,720 780,1260 1260,1530
read from the second one.|
|

1338
00:45:25,680 --> 00:45:26,910
0,390 390,780 780,900 900,1080 1080,1230
Yeah, which {} either one
是的，两个都没问题，

1339
00:45:26,910 --> 00:45:28,590
0,120 120,420 420,660 660,1410 1410,1680
is fine, correct,| the real
|这里真正的关键问题是，

1340
00:45:28,590 --> 00:45:30,180
0,450 450,780 780,1110 1110,1230 1230,1590
key issue here is that,|
|

1341
00:45:30,210 --> 00:45:30,920
0,510

1342
00:45:31,200 --> 00:45:32,790
0,150 150,300 300,720 720,1020 1020,1590
you know before reading, remember,
在读取之前，你必须等到看到写入，

1343
00:45:32,970 --> 00:45:33,840
0,180 180,270 270,390 390,660 660,870
you have to wait until

1344
00:45:33,840 --> 00:45:34,960
0,120 120,240 240,360 360,810
you see a write,

1345
00:45:35,250 --> 00:45:36,360
0,300 300,480 480,600 600,810 810,1110
right,| so if you are,|
|如果你是，|

1346
00:45:36,450 --> 00:45:37,260
0,150 150,300 300,570 570,660 660,810
so what happens if your
那么如果你的时间戳太大，会发生什么，

1347
00:45:37,260 --> 00:45:38,760
0,240 240,540 540,690 690,810 810,1500
{timestamp -} is too large,|
|

1348
00:45:40,220 --> 00:45:41,180
0,240 240,510 510,720 720,810 810,960
we're off to the too
我们偏差往太大的方向。

1349
00:45:41,180 --> 00:45:42,200
0,300 300,720
large side.|
|

1350
00:45:42,370 --> 00:45:44,830
0,210 210,390 390,690 690,1110 1110,2460
You have to wait for.|
你得等待。|

1351
00:45:44,860 --> 00:45:47,880
0,2370 2370,2460
{Yeah\,you,have,to,wait},| {a,little,longer,maybe},|
是的，你必须等待，|也许再多等一会儿，|

1352
00:45:48,740 --> 00:45:53,260
0,360 360,540 540,1200
nothing goes wrong.|
不会出什么问题。|

1353
00:45:54,920 --> 00:45:56,330
0,660 780,990 990,1170 1170,1260 1260,1410
{} So now the other
所以现在另一个问题是，

1354
00:45:56,330 --> 00:45:58,880
0,570 840,1290 1290,1620 1620,2070 2070,2550
question {} is,| what if
|如果时间戳太小，会怎么样，

1355
00:45:58,880 --> 00:46:00,080
0,120 120,390 390,720 720,990 990,1200
the {timestamp -} is too

1356
00:46:00,080 --> 00:46:03,380
0,630
small,|
|

1357
00:46:04,010 --> 00:46:05,630
0,330 330,420 420,1080 1080,1230 1230,1620
so for example the read,|
比如，读取，|

1358
00:46:05,750 --> 00:46:07,250
0,360 360,660 660,840 840,1050 1050,1500
{} when the {T3 -}
当执行 T3 的机器询问时间时，

1359
00:46:07,250 --> 00:46:08,540
0,210 210,540 540,660 660,1110 1110,1290
the machine that executes {T3

1360
00:46:08,540 --> 00:46:09,440
0,300 300,360 360,510 510,810 810,900
-} you know ask for

1361
00:46:09,440 --> 00:46:11,210
0,180 180,600 990,1410 1410,1710 1710,1770
{the,time},| { -} instead of
|不是时间 10 ，而是 9 ，

1362
00:46:11,210 --> 00:46:13,340
0,390 390,990 1110,1530 1530,1680 1680,2130
time 10, actually gets back

1363
00:46:13,340 --> 00:46:14,840
0,150 150,360 360,810 810,1350 1350,1500
{you,know} say 9,| then this
|这是课程问题的一个变体，

1364
00:46:14,840 --> 00:46:16,760
0,120 120,150 150,1140 1320,1710 1710,1920
is a variation of the

1365
00:46:16,760 --> 00:46:18,590
0,750 750,810 810,1230 1230,1440 1440,1830
lecture {} question,| so basically
|T3 在时间 9 运行。

1366
00:46:18,590 --> 00:46:20,510
0,240 240,480 480,1050 1470,1770 1770,1920
like {T3 -} runs at

1367
00:46:20,540 --> 00:46:21,620
0,540
9.|
|

1368
00:46:22,840 --> 00:46:23,920
0,450 450,690 690,840 840,930 930,1080
And maybe this is a
也许这是一个很好的时机开始一个分组讨论室，

1369
00:46:23,920 --> 00:46:25,390
0,270 270,570 570,840 840,1170 1170,1470
good time for actually to

1370
00:46:25,390 --> 00:46:26,470
0,150 150,210 210,450 450,630 630,1080
take a {breakout -} room,|
|

1371
00:46:26,710 --> 00:46:28,300
0,810 810,960 960,1050 1050,1470 1470,1590
and you can think and
你们可以思考和争论，结果是什么，

1372
00:46:28,300 --> 00:46:29,650
0,360 360,840 840,1110 1110,1200 1200,1350
argue, what, what is the

1373
00:46:29,650 --> 00:46:31,390
0,600 780,1080 1080,1140 1140,1230 1230,1740
outcome,| what is the potential
|潜在的结果是什么，

1374
00:46:31,390 --> 00:46:32,800
0,630 630,720 720,960 960,1110 1110,1410
outcomes,| you know or what
|或者会出什么问题，

1375
00:46:32,800 --> 00:46:34,780
0,120 120,270 270,810 930,1470 1470,1980
could go wrong,| if actually
|如果 T3 分配的时间戳是 9 而不是 10 。

1376
00:46:34,780 --> 00:46:36,670
0,540 570,840 840,1350 1350,1710 1710,1890
the {timestamp -} that got

1377
00:46:36,670 --> 00:46:38,710
0,480 480,660 660,1170 1170,1620 1830,2040
assigned at {T3 -} is

1378
00:46:38,710 --> 00:46:40,520
0,690 780,1080 1080,1170 1170,1590
9 instead of 10.|
|

1379
00:46:43,630 --> 00:46:44,380
0,300 300,510 510,570 570,660 660,750
So maybe we can do
所以也许我们可以进行一个分组会议室，

1380
00:46:44,380 --> 00:46:45,640
0,60 60,420 420,690 720,1050 1050,1260
a breakout room,| Lily, {would,that}
|Lily ，可以吗，

1381
00:46:45,640 --> 00:46:46,640
0,120 120,690
be possible,|
|

1382
00:46:49,270 --> 00:46:51,040
0,360 360,630 630,1050 1050,1350 1350,1770
okay, {I,think} {Lily,is} back soon,|
好的，我想 Lily 很快就会回来，|

1383
00:46:59,210 --> 00:47:00,620
0,390 390,570 570,630 630,960 960,1410
hold on a second here.|
稍等片刻。|

1384
00:47:18,080 --> 00:47:20,510
0,690 1050,1890 1890,2100 2100,2280 2280,2430
Okay, anybody else getting that
好了，还有其他人听到那个噪音吗？

1385
00:47:20,510 --> 00:47:23,640
0,510
noise?|
|

1386
00:47:24,630 --> 00:47:26,500
0,1440

1387
00:49:07,030 --> 00:49:08,800
0,240 240,1470

1388
00:49:45,700 --> 00:49:46,880
0,720

1389
00:51:23,010 --> 00:51:24,360
0,180 180,1080

1390
00:52:45,780 --> 00:52:46,660
0,60

1391
00:53:42,920 --> 00:53:44,300
0,180 180,750 750,1020 1020,1110 1110,1380
Okay, everybody back and everybody
好了，大家回来，大家能听到我说话吗？

1392
00:53:44,300 --> 00:53:45,340
0,90 90,240 240,360 360,690
can hear me again?|
|

1393
00:53:46,800 --> 00:53:47,760
0,900
Yep.|
是的。|

1394
00:53:51,630 --> 00:53:52,540
0,570
{We're,all,good}?|
我们都是好的吗？|

1395
00:53:57,090 --> 00:53:59,040
0,780 780,1230 1230,1320 1320,1680
Assume we're all good.|
假设我们都是好的。|

1396
00:54:00,090 --> 00:54:01,680
0,300 300,540 540,660 660,1020 1170,1590
Yes, yes, we're good.| We're
是的，是的，我们是好的。|我们都是好的。

1397
00:54:01,680 --> 00:54:02,420
0,90 90,420
all good.|
|

1398
00:54:04,250 --> 00:54:06,560
0,510 600,1170 1560,1740 1740,1860 1860,2310
Okay, {} okay, so back,
好的，所以回到这个问题，

1399
00:54:06,590 --> 00:54:07,640
0,90 90,210 210,360 360,660 660,1050
you know so this {}

1400
00:54:07,670 --> 00:54:10,220
0,450 450,1020 1020,1020 2040,2430 2430,2550
question here,| { -} usual
|我们调查，我们依靠的方案，

1401
00:54:10,220 --> 00:54:12,500
0,360 360,1290 1290,1650 1650,1920 1920,2280
we're investigating, {} we're relying

1402
00:54:12,500 --> 00:54:14,420
0,90 90,570 570,1440 1470,1860 1860,1920
on scheme,| where {the,clocks} on
|不同机器上的时钟是完全同步的，

1403
00:54:14,420 --> 00:54:16,400
0,240 240,540 540,600 600,960 960,1980
different machines are perfectly synchronized,|
|

1404
00:54:16,400 --> 00:54:19,610
0,600 1380,1890 2220,2640 2640,2970 2970,3210
{} {as,I,mentioned}, matters only for
正如我所提到的，这只影响只读事务，

1405
00:54:19,610 --> 00:54:20,960
0,150 150,360 360,930 930,1170 1170,1350
{read-only -} transactions,| because {read-write
|因为读写事务会抓取日志

1406
00:54:20,960 --> 00:54:22,280
0,180 180,810 810,900 900,1020 1020,1320
-} transactions you know grab

1407
00:54:22,280 --> 00:54:23,720
0,630 690,840 840,1050 1050,1200 1200,1440
logs| and use {two-phase -}
|并使用两阶段锁来获得整体顺序，

1408
00:54:23,720 --> 00:54:24,830
0,360 360,570 570,750 750,810 810,1110
locking to get a total

1409
00:54:24,830 --> 00:54:25,460
0,450
order,|
|

1410
00:54:25,870 --> 00:54:27,310
0,150 150,300 300,480 480,990 990,1440
so they were executing some
所以它们执行一些可串行化的，外部一致顺序，

1411
00:54:27,670 --> 00:54:30,340
0,510 510,1080 1080,1950 1980,2280 2280,2670
{} {serializable -}, external consistent

1412
00:54:30,340 --> 00:54:31,990
0,450 750,1110 1110,1320 1320,1440 1440,1650
order,| {} where we see
|我们看到，对于只读事务，时间戳至关重要，

1413
00:54:31,990 --> 00:54:34,540
0,210 210,690 690,1080 1080,1800 1800,2550
that for read-only transactions, {}

1414
00:54:34,570 --> 00:54:36,970
0,360 360,900 900,990 990,1590 2070,2400
{the,timestamps -} {} crucial,| at
|至少，我们认为是至关重要的，

1415
00:54:36,970 --> 00:54:38,170
0,240 240,450 480,690 690,810 810,1200
least, we think it's crucial,|
|

1416
00:54:38,170 --> 00:54:39,400
0,300 300,420 420,600 600,750 750,1230
for if they're too large,|
如果它们太大，|

1417
00:54:39,400 --> 00:54:40,510
0,90 90,210 210,480 480,930 930,1110
you know not maybe just
可能不是，只是负面影响性能，

1418
00:54:40,510 --> 00:54:42,970
0,330 330,720 720,1440 1620,2250 2400,2460
affect performance negatively,| but the
|但问题是，如果时间戳太小，会发生什么，

1419
00:54:42,970 --> 00:54:43,900
0,270 270,330 330,510 510,810 810,930
question is what happens if

1420
00:54:43,900 --> 00:54:45,580
0,360 390,870 870,990 990,1110 1110,1680
the timestamp is too small,|
|

1421
00:54:45,880 --> 00:54:48,670
0,210 210,600 1020,1650 1770,2370 2370,2790
and so the particular question
所以我们要问的具体问题是，

1422
00:54:48,670 --> 00:54:50,080
0,330 330,720 720,900 900,1080 1080,1410
we're asking is,| like what,
|会发生什么，

1423
00:54:50,080 --> 00:54:52,990
0,210 210,390 390,900 1080,2070 2070,2910
what would happen,| if {}
|如果我们稍后会看到的场景，

1424
00:54:53,610 --> 00:54:56,430
0,510 510,1290 1590,2550 2550,2700 2700,2820
in {} {the,scenario}, that we

1425
00:54:56,430 --> 00:54:58,140
0,240 240,660 660,690 690,1140 1530,1710
looked at a second, {}|
|

1426
00:54:58,140 --> 00:54:59,550
0,270 270,390 390,570 570,1050 1050,1410
where we have transactions {you,know}
我们有事务 T1 ，

1427
00:54:59,580 --> 00:55:01,500
0,210 210,780 930,1560 1560,1830 1830,1920
{T1 -},| {} actually I
|这里写错了，是 T2 和 T3 ，

1428
00:55:01,500 --> 00:55:02,550
0,240 240,390 390,870 870,930 930,1050
wrote this wrong, you know

1429
00:55:02,550 --> 00:55:04,050
0,240 240,600 600,750 750,960 960,1500
{T2 -} and {T3 -},|
|

1430
00:55:04,350 --> 00:55:05,220
0,120 120,300 300,540 540,660 660,870
or {t3 -} is doing
T3 正在进行读取，

1431
00:55:05,220 --> 00:55:07,710
0,90 90,630 900,1680 1680,2160 2160,2490
the read,| and {} this
|这个读取不是发生在 15 ，

1432
00:55:07,710 --> 00:55:09,690
0,300 300,720 720,840 840,1260 1260,1980
read instead of actually happening

1433
00:55:09,690 --> 00:55:12,840
0,540 540,1050 1050,1440 1770,2640 2670,3150
{} maybe at 15,| and
|它实际上发生在，

1434
00:55:12,840 --> 00:55:14,220
0,120 120,450 450,1170 1170,1260 1260,1380
it actually happens,| you know
|因为 3 的时钟是错的，

1435
00:55:14,220 --> 00:55:15,570
0,330 330,420 420,870 870,990 990,1350
because the clock you know

1436
00:55:15,660 --> 00:55:17,640
0,420 420,720 720,1230 1260,1620 1620,1980
{} 3 wrong,| {it,actually} happens
|它实际发生在 9 ，

1437
00:55:17,640 --> 00:55:18,380
0,150 150,570
at 9,|
|

1438
00:55:19,800 --> 00:55:21,570
0,750 840,960 960,1050 1050,1260 1260,1770
and you know how bad
那会有多糟糕？

1439
00:55:21,570 --> 00:55:22,520
0,120 120,270 270,600
would that be?|
|

1440
00:55:27,830 --> 00:55:30,020
0,540 540,840 840,1350 1350,1800
Break our {serializability -}.|
破坏我们的串行化。|

1441
00:55:30,820 --> 00:55:31,840
0,720
Anybody?|
有人知道吗？|

1442
00:55:32,270 --> 00:55:34,040
0,450 480,690 690,840 840,1470
Okay, looks like {},|
好的，看起来，|

1443
00:55:34,320 --> 00:55:35,730
0,330 360,900 900,990 990,1230 1230,1410
okay, sorry, I didn't hear
好的，抱歉，我没听到你说的，

1444
00:55:35,730 --> 00:55:36,930
0,90 90,330 330,450 450,780 780,1200
you,| because I actually had
|因为我这边今晚出了点问题，

1445
00:55:36,960 --> 00:55:39,000
0,330 330,750 750,810 810,1080 1080,2040
some problem {on,my} side tonight,|
|

1446
00:55:39,000 --> 00:55:40,290
0,840 840,990 990,1200 1200,1290 1290,1290
I can hear you I
我想我能听到你的声音，

1447
00:55:40,290 --> 00:55:41,460
0,450 510,690 690,780 780,1050 1050,1170
think,| can you repeat the
|你能重复一下答案吗？

1448
00:55:41,460 --> 00:55:43,260
0,510 870,1230 1230,1320 1320,1500 1500,1800
answer?| Sorry, I said it
|抱歉，我说它会破坏可串行化。

1449
00:55:43,260 --> 00:55:45,180
0,150 150,390 390,930 930,1530 1740,1920
would break {serializability -}.| {Yeah
|是的，为什么？

1450
00:55:45,180 --> 00:55:45,940
0,60 60,510
-}, why?|
|

1451
00:55:46,440 --> 00:55:49,020
0,360 360,870 870,1350 1350,2160 2220,2580
{} Because then here here
因为这里读取会发生，

1452
00:55:49,020 --> 00:55:51,360
0,270 270,420 420,1020 1380,2220 2220,2340
read would happen,| would {}
|会假设发生在最新的写入之后，

1453
00:55:51,360 --> 00:55:52,740
0,330 330,420 420,570 570,930 930,1380
assume to be happening after

1454
00:55:52,740 --> 00:55:54,270
0,180 180,570 570,990 1080,1380 1380,1530
your latest write,| would then
|然后会发生在你没有写入之前。

1455
00:55:54,270 --> 00:55:56,190
0,330 330,930 960,1170 1170,1440 1470,1920
happen before which you wouldn't

1456
00:55:56,190 --> 00:55:58,110
0,300 300,420 420,660 660,960 1230,1920
yield the the write.| Yeah,
|是的，所以把故事说完整，

1457
00:55:58,110 --> 00:55:59,340
0,360 360,540 540,690 690,960 960,1230
so just make the story

1458
00:55:59,340 --> 00:56:01,740
0,480 480,870 870,1410 1590,2250 2250,2400
complete,| {you,know} T3 really is
|T3 实际上在 15 执行，

1459
00:56:01,740 --> 00:56:04,530
0,600 600,960 960,1470 1470,2310 2340,2790
executing at time 15, right,|
|

1460
00:56:04,920 --> 00:56:07,050
0,330 330,570 570,750 750,1680 1710,2130
{} which is after {T2
在 T2 T1 提交之后，

1461
00:56:07,050 --> 00:56:08,500
0,360 360,510 510,810 810,1320
-} {T1 -} committed,|
|

1462
00:56:08,710 --> 00:56:10,540
0,360 360,570 570,810 810,1320 1320,1830
so, {T3 -} must see
所以， T3 必须看到 T1 的写入，

1463
00:56:10,540 --> 00:56:12,340
0,510 510,810 810,1290 1440,1710 1710,1800
{T1's -} write,| but if
|但是如果时钟错误，

1464
00:56:12,340 --> 00:56:14,140
0,90 90,450 450,570 570,1200 1230,1800
the clock is wrong,| and
|时间戳 9 分配给 T3 ，

1465
00:56:14,260 --> 00:56:15,820
0,480 480,840 840,1020 1020,1380 1380,1560
{} {timestamp -} 9 got

1466
00:56:15,820 --> 00:56:17,770
0,630 630,780 780,1290 1560,1740 1740,1950
assigned to {} to {T3

1467
00:56:17,770 --> 00:56:19,210
0,390 540,720 720,870 870,1260 1260,1440
-},| and {T3 -} will
|T3 将在执行事务 T1 之前读取 x 的值，

1468
00:56:19,210 --> 00:56:20,890
0,420 420,930 960,1140 1140,1530 1530,1680
actually read the value of

1469
00:56:20,890 --> 00:56:24,070
0,390 390,1020 1050,1920 2160,2670 2700,3180
x {} before {} transaction

1470
00:56:24,070 --> 00:56:26,320
0,180 180,510 510,1260 1500,2040 2040,2250
{T1 -} executed,| and {that,will}
|这将是错误的，

1471
00:56:26,320 --> 00:56:27,580
0,120 120,540 540,780 780,990 990,1260
be wrong,| that will break
|这将打破外部一致性。

1472
00:56:27,580 --> 00:56:29,200
0,570 570,1470
external {}

1473
00:56:29,450 --> 00:56:30,480
0,720
consistency.|
|

1474
00:56:32,630 --> 00:56:33,420
0,540
Okay?|
好的?|

1475
00:56:34,100 --> 00:56:35,400
0,330 330,570 570,630 630,960
Everybody clear on that?|
大家都清楚了吗？|

1476
00:56:50,590 --> 00:56:52,930
0,330 330,900 1080,1710 1860,2190 2190,2340
Okay, so clearly we'd like
好的，所以很明显我们想避免这种情况，

1477
00:56:52,930 --> 00:56:55,840
0,60 60,330 330,810 1260,2130 2130,2910
to avoid this,| and {}
|还有一些核心问题，

1478
00:56:56,080 --> 00:56:57,550
0,750 750,900 900,960 960,1110 1110,1470
and sort of the central

1479
00:56:57,550 --> 00:57:01,030
0,540 540,1710 1740,2400 2400,2820 3030,3480
problems,| {} the [] is
|问题是我们如何获得时钟，

1480
00:57:01,030 --> 00:57:02,110
0,150 150,240 240,390 390,600 600,1080
how do we get clocks,|
|

1481
00:57:02,140 --> 00:57:03,040
0,210 210,300 300,360 360,570 570,900
how do we keep clocks
我们如何保持时钟同步。

1482
00:57:03,040 --> 00:57:05,020
0,90 90,630 1290,1500 1500,1740 1740,1980
{synchronized -}.| Oh, wait, I
|哦，稍等，我还有一个问题。

1483
00:57:05,020 --> 00:57:06,100
0,240 240,390 390,540 540,690 690,1080
just have one more question

1484
00:57:06,100 --> 00:57:09,010
0,570 1080,1620 1620,1920 1920,2430 2430,2910
about.| So this scenario basically
|所以这种情况是可以发生的，

1485
00:57:09,010 --> 00:57:12,370
0,210 210,780 780,1620 1680,2400 2670,3360
can happen,| because {} it's
|因为总是由协调者为读写事务分配时间戳，

1486
00:57:12,370 --> 00:57:15,220
0,840 840,1080 1080,2070 2070,2370 2370,2850
always the coordinator for {}

1487
00:57:15,460 --> 00:57:17,350
0,510 510,990 990,1260 1260,1800 1800,1890
read-write transaction that assigns the

1488
00:57:17,350 --> 00:57:19,690
0,390 390,870 900,1320 1800,2160 2160,2340
{timestamp -},| so even if
|所以，即使读取发生在本地，

1489
00:57:19,690 --> 00:57:20,800
0,210 210,420 420,600 600,960 960,1110
the read is local and

1490
00:57:20,800 --> 00:57:22,090
0,120 120,570 570,900 930,1110 1110,1290
it happens on,| so it's
|所以，机器可能落后，

1491
00:57:22,090 --> 00:57:23,500
0,480 480,660 660,780 780,1200 1200,1410
possible for the machine that

1492
00:57:23,500 --> 00:57:26,470
0,480 570,1050 1050,1650 1890,2250 2250,2970
was running behind| to have
|有一个对于本地时钟的未来的版本。

1493
00:57:27,030 --> 00:57:28,320
0,210 210,810 810,1050 1050,1170 1170,1290
a version, that's in the

1494
00:57:28,320 --> 00:57:30,180
0,570 570,780 780,960 960,1290 1290,1860
future of its local clock.|
|

1495
00:57:30,570 --> 00:57:32,440
0,1230 1230,1260
Yeah, {or,in,the,past},
是的，或者是在过去，是在未来，是的。

1496
00:57:32,980 --> 00:57:34,120
0,390 390,450 450,510 510,810 810,1140
that in the future, yeah.|
|

1497
00:57:35,620 --> 00:57:36,640
0,270 270,390 390,540 540,720 720,1020
Okay, and that can happen,|
好的，这是可能发生的，|

1498
00:57:36,640 --> 00:57:38,530
0,570 570,810 810,1140 1140,1290 1290,1890
because it's not at machine
因为不是在决定时间戳的机器上。

1499
00:57:38,530 --> 00:57:40,120
0,180 180,840 840,930 930,1230 1230,1590
who decided the {timestamp -}.|
|

1500
00:57:40,870 --> 00:57:42,640
0,780 780,960 960,1080 1080,1560 1560,1770
No, okay, so forget about
不，好的，忘了是哪台机器，

1501
00:57:42,640 --> 00:57:43,600
0,180 180,450 450,570 570,810 810,960
which machine it is,| like
|T3 会决定事务的时间戳，

1502
00:57:43,600 --> 00:57:45,700
0,210 210,720 810,1530 1530,1980 1980,2100
{T3 -} {} is going

1503
00:57:45,700 --> 00:57:46,480
0,90 90,420 420,510 510,570 570,780
to decide on the {timestamp

1504
00:57:46,480 --> 00:57:48,460
0,210 210,360 360,960 990,1320 1710,1980
-} for transaction, right, {}|
|

1505
00:57:48,460 --> 00:57:49,390
0,150 150,270 270,540 540,840 840,930
we go back here to
我们回到这张图片上，

1506
00:57:49,390 --> 00:57:50,340
0,180 180,690
this picture,|
|

1507
00:57:50,790 --> 00:57:51,810
0,240 240,540 540,630 630,840 840,1020
so here we got {T3
所以这里我们有 T3 ，

1508
00:57:51,810 --> 00:57:52,660
0,510
-},|
|

1509
00:57:52,900 --> 00:57:56,170
0,690 690,900 900,1290 1290,1980 2460,3270
{} so T3 starts {}|
T3 开始，|

1510
00:57:56,170 --> 00:57:58,480
0,450 450,630 630,1050 1050,1680 1680,2310
and {T3 -} starts {}
原则上， T3 开始绝对时间是在 10 之后的，

1511
00:57:58,510 --> 00:58:01,480
0,630 1020,1620 1980,2550 2550,2880 2880,2970
{in,principle} a absolute time in

1512
00:58:01,480 --> 00:58:03,520
0,210 210,540 540,870 870,1260 1860,2040
true time after 10, right,|
|

1513
00:58:03,520 --> 00:58:05,350
0,240 240,870 870,1410 1410,1560 1560,1830
because {T3,starts} after {T1 -},|
因为 T3 开始在 T1 之后，|

1514
00:58:05,350 --> 00:58:05,980
0,180 180,270 270,360 360,480 480,630
as we can see from
正如我们在这张图片中看到的，

1515
00:58:05,980 --> 00:58:07,020
0,120 120,540
this picture,|
|

1516
00:58:08,100 --> 00:58:10,140
0,390 630,930 930,1320 1320,1590 1590,2040
so this particular read x
所以这个读取 x ，

1517
00:58:10,140 --> 00:58:11,310
0,120 120,360 360,660 660,780 780,1170
you know,| and so we
|所以，我们将时间戳分配给只读事务，

1518
00:58:11,310 --> 00:58:12,300
0,210 210,270 270,510 510,750 750,990
assign the {timestamp -} to

1519
00:58:12,300 --> 00:58:13,590
0,270 270,450 450,660 660,1200 1200,1290
{} {read-only -} transaction,| we
|我们将时间戳分配给只读事务，

1520
00:58:13,590 --> 00:58:15,000
0,300 300,690 810,1110 1110,1200 1200,1410
start, we assign the {timestamp

1521
00:58:15,000 --> 00:58:16,320
0,210 210,390 390,540 540,870 1140,1320
-} for {read-only -} transactions,|
|

1522
00:58:16,320 --> 00:58:17,070
0,240 240,330 330,540 540,630 630,750
at the point of the
在事务开始的时刻，

1523
00:58:17,070 --> 00:58:18,420
0,300 300,390 390,1080
start of transaction,|
|

1524
00:58:18,620 --> 00:58:19,340
0,240 240,360 360,540 540,600 600,720
so the read of the
所以读取 x 是 T3 的事务的开始，

1525
00:58:19,340 --> 00:58:20,810
0,420 420,540 540,870 870,930 930,1470
{x,is} the {start,of} the transaction

1526
00:58:20,810 --> 00:58:23,660
0,900 1320,1620 1620,1950 1950,2610 2640,2850
{for,T3},| {T3 -} basically needs
|T3 需要得到时间戳，

1527
00:58:23,660 --> 00:58:24,590
0,90 90,270 270,360 360,630 630,930
to get the {timestamp -},|
|

1528
00:58:24,590 --> 00:58:25,460
0,120 120,210 210,510 510,630 630,870
so it asks {you,know} please
所以它会说，请给我时钟当前的值，

1529
00:58:25,460 --> 00:58:26,660
0,180 180,390 390,570 570,840 840,1200
give me the current value

1530
00:58:26,660 --> 00:58:27,680
0,120 120,270 270,780
of its clock,|
|

1531
00:58:28,110 --> 00:58:29,880
0,780 780,990 1020,1170 1170,1290 1290,1770
and {} you know if
如果时钟是可靠和准确的，

1532
00:58:29,880 --> 00:58:30,540
0,90 90,180 180,270 270,540 540,660
you know the clock is

1533
00:58:30,540 --> 00:58:32,520
0,720 720,930 930,1440 1440,1530 1530,1980
reliable and correct,| you know
|它当然会给出一个 10 之后的时间，

1534
00:58:32,520 --> 00:58:34,260
0,270 270,750 750,930 930,1170 1170,1740
{it,will,give} back {you,know -} {some,time}

1535
00:58:34,260 --> 00:58:36,180
0,390 390,720 720,840 840,1230 1260,1920
after 10 for sure,| because
|因为 T3 是在 10 之后开始的，

1536
00:58:36,600 --> 00:58:38,460
0,330 330,870 870,1260 1260,1620
T3 started after 10,|
|

1537
00:58:39,210 --> 00:58:40,290
0,390 390,690 690,780 780,900 900,1080
but let's you know we
但是我们假设 T3 的时钟不是，

1538
00:58:40,290 --> 00:58:42,750
0,600 630,1860 1860,1980 1980,2040 2040,2460
were hypothesizes that the clock

1539
00:58:42,750 --> 00:58:43,950
0,270 270,480 480,720 720,810 810,1200
of {T3 -} is not,|
|

1540
00:58:43,980 --> 00:58:45,330
0,120 120,300 300,630 660,1050 1050,1350
you know {} clear []
[]准确同步的，

1541
00:58:45,330 --> 00:58:47,430
0,810 1080,1560 1560,1650 1650,1980 1980,2100
synchronized,| and the clock actually
|时钟实际上返回了 9 ，

1542
00:58:47,430 --> 00:58:48,580
0,420 420,900
return 9,|
|

1543
00:58:49,210 --> 00:58:51,220
0,120 120,240 240,930 930,1290 1290,2010
and so now {} transaction
现在事务 3 将执行时间戳 9 ，

1544
00:58:51,640 --> 00:58:53,050
0,420 420,660 660,810 810,1230 1230,1410
{} 3 will execute {}

1545
00:58:53,050 --> 00:58:54,790
0,210 210,480 480,1020 1140,1590 1590,1740
{timestamp -} 9,| and that
|这将导致你读取 T1 之前的值，

1546
00:58:54,790 --> 00:58:55,780
0,120 120,390 390,510 510,600 600,990
will cause you to read

1547
00:58:55,780 --> 00:58:57,340
0,60 60,540 540,720 720,870 870,1560
the value from {before -}

1548
00:58:57,400 --> 00:58:58,510
0,240 240,630 630,720 720,870 870,1110
{T1 -},| and that will
|这将打破外部一致性。

1549
00:58:58,600 --> 00:59:00,240
0,180 180,630 660,1380
{} break {}

1550
00:59:00,430 --> 00:59:01,760
0,420 420,1020
external consistency.|
|

1551
00:59:03,520 --> 00:59:05,540
0,450 450,720 720,1050 1050,1680
Okay, but {} if,
好的，但是如果，

1552
00:59:05,730 --> 00:59:07,320
0,510 510,1290
if the,|
|

1553
00:59:08,340 --> 00:59:10,200
0,180 180,300 300,900 900,1320 1320,1860
if the replica which we
如果我们执行 T3 的 replica 有，

1554
00:59:10,230 --> 00:59:12,820
0,510 510,690 690,1260 1740,2220
execute the T3 had

1555
00:59:13,320 --> 00:59:14,520
0,810
the,|
|

1556
00:59:17,460 --> 00:59:20,130
0,210 210,540 540,1050 1050,1590 1620,2670
it may have the version
它可能有版本 10 的变量 x ，对吧？

1557
00:59:20,880 --> 00:59:23,490
0,660 840,1140 1140,1710 1710,2100 2100,2610
10 of variable x, right?|
|

1558
00:59:24,750 --> 00:59:29,550
0,330 330,3810 3810,3870 3900,4560 4560,4800
{It,might\,but,you,know,it's,executing,transaction,at,time -} {} 9,| so
它可能会，但它在时间 9 执行事务，|所以我们会得到 10 之前的值，这个版本的[内存]。

1559
00:59:29,550 --> 00:59:30,570
0,150 150,360 360,450 450,870 870,1020
we'll get the value for

1560
00:59:30,570 --> 00:59:32,250
0,360 360,810 810,930 930,1350 1350,1680
before 10, this version [memory].|
|

1561
00:59:32,250 --> 00:59:33,940
0,600 1080,1500
{Yeah\,,yeah}.| Yep?|
是的，是的。|是吗？|

1562
00:59:35,510 --> 00:59:36,440
0,240 240,420 420,600 600,780 780,930
Yeah.| Just making sure this
是的。|这是一个很好的问题，

1563
00:59:36,440 --> 00:59:37,340
0,120 120,210 210,450 450,600 600,900
is a very good question,|
|

1564
00:59:37,340 --> 00:59:38,600
0,300 300,450 450,720 720,1080 1080,1260
{I,think} this very important point
我认为这一点非常重要，让我们清楚地知道这里发生了什么。

1565
00:59:38,600 --> 00:59:40,190
0,270 270,510 660,1140 1140,1410 1410,1590
to get crystal clear what's

1566
00:59:40,190 --> 00:59:41,180
0,180 180,450 450,690
going on here.|
|

1567
00:59:42,790 --> 00:59:44,590
0,270 270,690 1080,1350 1350,1590 1590,1800
Okay, so so I think
好的，所以我希望我们现在达成一致，

1568
00:59:44,590 --> 00:59:45,580
0,90 90,390 390,690 690,900 900,990
we're now hopefully on the

1569
00:59:45,580 --> 00:59:47,230
0,180 180,540 540,900 900,1410 1410,1650
same page,| you know it's
|这是非常重要的，

1570
00:59:47,230 --> 00:59:49,090
0,510 510,930 930,1110 1110,1320 1320,1860
very important,| that these clocks
|这些在不同机器上的时钟是完全同步的，

1571
00:59:49,090 --> 00:59:50,260
0,150 150,330 330,570 570,930 930,1170
{} at different machines are

1572
00:59:50,260 --> 00:59:52,510
0,510 510,1260 1770,1950 1950,2010 2010,2250
perfectly synchronized,| and of course
|当然，你知道不可能实现完美的时钟同步，

1573
00:59:52,510 --> 00:59:54,820
0,360 360,780 780,1170 1170,1260 1260,2310
{you,know,it's} not possible to get

1574
00:59:54,820 --> 00:59:56,770
0,630 630,990 990,1290 1290,1860 1860,1950
perfect {} clock synchronization,| and
|有一些困难，

1575
00:59:56,770 --> 00:59:58,120
0,150 150,210 210,510 510,600 600,1350
{sort,of} a couple of difficulties,|
|

1576
01:00:01,590 --> 01:00:02,820
0,300 300,660 660,720 720,900 900,1230
it's difficult to get clocks
很难实现时钟同步，

1577
01:00:02,820 --> 01:00:05,490
0,780 840,1440 1440,1680 1680,2160 2160,2670
synchronization,| because of clocks naturally
|因为时钟会自然漂移，

1578
01:00:05,490 --> 01:00:07,340
0,570
drift,|
|

1579
01:00:09,160 --> 01:00:10,750
0,690 690,900 900,1350 1350,1500 1500,1590
{} and so you know
所以当你认为，

1580
01:00:10,750 --> 01:00:11,710
0,210 210,420 420,660 660,870 870,960
when you think,| it's you
|它是晚上 10 点加上 1 毫秒，

1581
01:00:11,710 --> 01:00:13,420
0,150 150,480 480,690 690,1290 1290,1710
know whatever {10pm -} and

1582
01:00:13,420 --> 01:00:15,010
0,210 210,360 360,1080 1080,1200 1200,1590
plus one microsecond,| you know
|我的机器可能会认为，

1583
01:00:15,310 --> 01:00:16,750
0,420 420,810 810,1050 1050,1260 1260,1440
my machine might think,| it's
|它是晚上 10 点加上 2 微秒，

1584
01:00:16,750 --> 01:00:18,580
0,150 150,300 300,1020 1050,1260 1260,1830
you know {} {10pm -}

1585
01:00:18,580 --> 01:00:20,080
0,540 540,690 690,1020 1020,1200 1200,1500
and two plus two {microseconds

1586
01:00:20,080 --> 01:00:22,300
0,480 750,1290 1290,1530 1530,1770 1770,2220
-},| {} and just basically
|这是因为在你的机器或服务器中，

1587
01:00:22,300 --> 01:00:23,110
0,270 270,330 330,480 480,630 630,810
because you know they're sort

1588
01:00:23,110 --> 01:00:24,880
0,120 810,990 990,1170 1170,1620 1620,1770
of in your machine or

1589
01:00:24,880 --> 01:00:26,560
0,150 150,270 270,690 690,870 870,1680
in the servers,| that oscillators
|振荡器跟踪时间，

1590
01:00:26,560 --> 01:00:27,550
0,90 90,180 180,420 480,720 720,990
you know that keep track

1591
01:00:27,550 --> 01:00:29,410
0,90 90,720 870,1230 1230,1380 1380,1860
of time,| they are supposed
|它们以特定的频率运行，

1592
01:00:29,410 --> 01:00:32,140
0,420 630,1410 1500,2580 2580,2670 2670,2730
to {} run at a

1593
01:00:32,140 --> 01:00:33,790
0,360 360,900 900,1020 1020,1110 1110,1650
particular frequency,| but the frequency
|但是它的频率并不完美，

1594
01:00:33,790 --> 01:00:35,170
0,120 120,240 240,360 360,720 840,1380
you know it's not perfect,|
|

1595
01:00:35,380 --> 01:00:36,640
0,540 540,630 630,720 720,990 990,1260
{} you know and better
更好的时钟，

1596
01:00:36,640 --> 01:00:38,500
0,480 480,600 600,1140 1140,1440 1440,1860
clocks,| you know atom clocks
|原子钟有更好的振荡器，更精确，

1597
01:00:38,500 --> 01:00:40,660
0,90 90,480 720,1260 1260,1920 1920,2160
{you,know} have better oscillators, that

1598
01:00:40,660 --> 01:00:43,360
0,150 150,480 480,1050 1080,1920 2130,2700
are much more precise, {}|
|

1599
01:00:43,360 --> 01:00:43,900
0,150 150,240 240,390 390,450 450,540
and as sort of the
作为 Spanner 依赖的那种时钟，

1600
01:00:43,900 --> 01:00:45,640
0,180 180,240 240,660 660,1020 1020,1740
kind of clocks that {}

1601
01:00:46,390 --> 01:00:47,530
0,420 420,510 510,660 660,750 750,1140
Spanner is sort of relying

1602
01:00:47,530 --> 01:00:48,640
0,240 240,390 390,510 510,810 840,1110
on,| that you know pretty
|相当高的精确度，

1603
01:00:48,640 --> 01:00:50,710
0,270 270,870 990,1290 1290,1710 1710,2070
high precision,| but there's still
|但是他们仍然需要

1604
01:00:50,710 --> 01:00:52,180
0,150 150,300 300,690 750,1260 1260,1470
they need to| synchronize once
|偶尔与通用全球时间同步，

1605
01:00:52,180 --> 01:00:53,290
0,60 60,90 90,360 360,480 480,1110
in a while with common

1606
01:00:53,290 --> 01:00:55,000
0,90 90,360 480,900 900,1410 1410,1710
you know global time, {}|
|

1607
01:00:55,390 --> 01:00:56,020
0,540

1608
01:00:56,340 --> 01:00:58,560
0,570 780,1140 1140,1740 1770,1950 1950,2220
so to avoid the problem
为了避免漂移的问题，

1609
01:00:58,560 --> 01:01:00,750
0,90 90,510 510,1170 1170,1860 1860,2190
of drift,| {} {you,know,pretty} precise
|非常精确的时钟，他们使用原子钟，

1610
01:01:00,750 --> 01:01:02,730
0,420 420,720 720,1020 1020,1410 1410,1980
clocks, they use atomic clocks,|
|

1611
01:01:04,600 --> 01:01:06,370
0,270 270,360 360,960 1110,1530 1530,1770
which are more precise than
比你的计算机里的时钟更精确，

1612
01:01:06,370 --> 01:01:07,210
0,240 240,330 330,660 660,720 720,840
like the clocks in your

1613
01:01:07,210 --> 01:01:09,370
0,570 990,1590 1590,1860 1860,2010 2010,2160
computer,| {} and then they
|然后它们与全球时间同步，

1614
01:01:09,370 --> 01:01:14,020
0,570 570,720 720,1470 1470,1920 4380,4650
synchronize with global time,| {so,to}
|为了确保所有时钟在全球时间上一致，

1615
01:01:14,020 --> 01:01:16,390
0,150 150,690 720,990 990,1650 1680,2370
make sure like all {}

1616
01:01:16,420 --> 01:01:18,700
0,390 390,510 510,1050 1050,1980 1980,2280
clocks {sort,of} agree on the

1617
01:01:18,730 --> 01:01:19,690
0,300 300,600 600,690 690,840 840,960
global time,| and then they
|它们保持滴答滴答滴答，

1618
01:01:19,690 --> 01:01:20,740
0,180 180,240 240,450 450,750 750,1050
sort of keep ticking ticking

1619
01:01:20,740 --> 01:01:22,690
0,480 780,930 930,1260 1260,1440 1440,1950
ticking| and then {resynchronized -}
|然后周期性地重新同步，

1620
01:01:22,690 --> 01:01:23,520
0,630
periodically,|
|

1621
01:01:25,040 --> 01:01:27,500
0,240 240,600 600,1050 1050,1710 2280,2460
{} synchronized clocks and {}
同步时钟，使用全球时间，

1622
01:01:27,500 --> 01:01:28,940
0,240 240,510 510,780 780,1020 1020,1440
with global time,| and they
|他们使用 GPS 全球定位系统广播时间，

1623
01:01:28,940 --> 01:01:31,220
0,240 240,690 690,990 990,1500 1590,2280
use GPS global position system

1624
01:01:31,550 --> 01:01:34,400
0,150 150,360 360,1140 1170,1860 2040,2850
{} that broadcast time, {}|
|

1625
01:01:34,400 --> 01:01:36,410
0,480 480,690 690,930 930,1470 1470,2010
as a way to {}
作为同步不同原子钟的一种方式，

1626
01:01:36,410 --> 01:01:38,210
0,510 510,660 660,930 930,1350 1350,1800
synchronize these different atom clocks,|
|

1627
01:01:38,210 --> 01:01:39,860
0,300 300,750 870,1170 1170,1410 1410,1650
and then keep them running
然后保持它们同步运行。

1628
01:01:39,860 --> 01:01:40,520
0,90 90,450
in sync.|
|

1629
01:01:41,210 --> 01:01:42,860
0,300 300,420 420,540 540,690 690,1650
And so it looks like,|
所以看起来，|

1630
01:01:42,890 --> 01:01:44,000
0,270 270,480 480,630 630,870 870,1110
{the,paper} doesn't really say too
这篇论文并没有太多地谈到真实时间系统是如何工作的，

1631
01:01:44,000 --> 01:01:45,980
0,330 330,660 660,900 900,1200 1200,1980
much about actually how the

1632
01:01:46,190 --> 01:01:48,140
0,210 210,510 510,870 870,1350 1590,1950
true time system works,| but
|但看起来是，

1633
01:01:48,140 --> 01:01:49,310
0,90 90,270 270,450 450,780 780,1170
it looks like,| they have
|他们的每个数据中心可能有少量的或一个原子钟，

1634
01:01:49,310 --> 01:01:50,960
0,450 450,690 690,990 990,1140 1140,1650
maybe {} few or one

1635
01:01:50,990 --> 01:01:53,060
0,510 510,990 990,1290 1290,1560 1560,2070
atomic clock per data center,|
|

1636
01:01:53,570 --> 01:01:55,820
0,630 630,870 870,1620 1620,1710 1710,2250
servers {you,know} synchronize,| {you,know} {with,that},
服务器同步，|使用这个，时间服务器常规地

1637
01:01:55,820 --> 01:01:59,330
0,240 240,810 810,1080 1080,2100 3060,3510
time server to regularly| synchronize
|与时间 master 同步它们的本地时间，

1638
01:01:59,330 --> 01:02:01,370
0,120 120,450 450,840 840,1590 1620,2040
their local clocks with that

1639
01:02:01,400 --> 01:02:03,290
0,210 210,810 1320,1590 1590,1620 1620,1890
time master| and {} different
|在不同数据中心的不同时间 master ，

1640
01:02:03,290 --> 01:02:04,430
0,180 180,630 630,720 720,960 960,1140
time master {in,the} different data

1641
01:02:04,430 --> 01:02:09,080
0,390 390,2250 3270,3780 3780,4530 4530,4650
centers,| {you,know,synchronize,themselves} {} through the
|通过 GPS 系统进行同步。

1642
01:02:09,080 --> 01:02:09,900
0,360 360,720
GPS system.|
|

1643
01:02:11,260 --> 01:02:12,790
0,450 450,720 720,960 960,1290 1290,1530
{} But and so as
但结果就是，

1644
01:02:12,790 --> 01:02:14,530
0,90 90,720 720,810 810,1410 1440,1740
a result,| the clocks are
|位于不同的服务器上的时钟非常接近，

1645
01:02:14,530 --> 01:02:15,940
0,360 360,600 600,750 750,1050 1050,1410
actually on the different servers

1646
01:02:15,940 --> 01:02:18,340
0,180 180,480 480,1170 1320,2100 2100,2400
are pretty close,| {} in
|他们谈论的 ε ，

1647
01:02:18,340 --> 01:02:19,210
0,300 300,540 540,690 690,780 780,870
terms of you know they

1648
01:02:19,210 --> 01:02:20,410
0,180 180,360 360,450 450,1110 1110,1200
talk about the ε| you
|也就是错误率是，

1649
01:02:20,410 --> 01:02:21,580
0,90 90,270 270,480 480,930 930,1170
know what the error rate

1650
01:02:21,580 --> 01:02:22,600
0,300 300,510 510,660 660,780 780,1020
is,| and so it seems
|似乎他们时钟的 ε ，

1651
01:02:22,600 --> 01:02:24,640
0,150 150,270 270,870 1110,1890 1890,2040
like the ε for their

1652
01:02:24,640 --> 01:02:25,450
0,360 360,420 420,540 540,690 690,810
clocks,| you can look at
|你可以在论文结尾看到一个表，

1653
01:02:25,450 --> 01:02:26,470
0,150 150,240 240,480 630,960 960,1020
one of the tables at

1654
01:02:26,470 --> 01:02:27,520
0,150 150,300 300,390 390,450 450,1050
the end of the paper,|
|

1655
01:02:27,580 --> 01:02:28,420
0,150 150,240 240,300 300,690 690,840
is in the order of
只有几微秒到几毫秒的量级。

1656
01:02:28,420 --> 01:02:29,820
0,120 120,360 360,660 660,1260
a few {microseconds -}

1657
01:02:30,060 --> 01:02:33,520
0,750 780,1020 1020,1260 1260,2190
to {you,know,a} few milliseconds.|
|

1658
01:02:34,470 --> 01:02:35,000
0,120

1659
01:02:35,440 --> 01:02:37,210
0,210 210,390 390,930 960,1110 1110,1770
And so when a machine
所以，当机器到达，

1660
01:02:37,210 --> 01:02:39,190
0,540 570,690 690,870 870,1710 1710,1980
reach,| you know ask the
|问操作系统，请告诉我现在的时间，

1661
01:02:39,190 --> 01:02:40,510
0,420 420,750 750,1020 1020,1200 1200,1320
operating system, please give me

1662
01:02:40,510 --> 01:02:41,890
0,180 180,420 420,720 720,1020 1020,1380
what the current time is,|
|

1663
01:02:42,220 --> 01:02:43,540
0,300 300,420 420,690 690,1050 1050,1320
{} the current time that
返回的当前时间可能与实际时间相差几微秒，

1664
01:02:43,540 --> 01:02:45,520
0,270 270,840 1320,1710 1710,1770 1770,1980
gets returned maybe a few

1665
01:02:45,520 --> 01:02:47,590
0,270 270,660 660,1140 1440,1920 1920,2070
{microseconds -} off from ture

1666
01:02:47,590 --> 01:02:48,940
0,540 570,810 810,1080 1080,1140 1140,1350
time| or even a few
|或者甚至比真实时间差几毫秒。

1667
01:02:48,940 --> 01:02:50,680
0,810 810,1080 1080,1230 1230,1350 1350,1740
milliseconds off from true time.|
|

1668
01:02:53,160 --> 01:02:54,120
0,660
Okay?|
好的?|

1669
01:02:55,110 --> 01:02:55,800
0,180 180,360 360,450 450,570 570,690
So there's a bit of.|
所以，这有一点。|

1670
01:02:55,800 --> 01:02:56,940
0,180 180,480 480,690 690,810 810,1140
{} [], yeah, go ahead
[]，是的，请继续。

1671
01:02:57,030 --> 01:02:59,640
0,810 1170,1470 1470,1830 1830,2400 2430,2610
before.| Yeah so, {} so
|是的，所以，比如在论文中，

1672
01:02:59,640 --> 01:03:01,380
0,150 150,240 240,1290 1290,1590 1590,1740
like the paper, { -}|
|

1673
01:03:01,380 --> 01:03:02,130
0,120 120,210 210,510 510,630 630,750
as you mentioned, we did
就像你提到的，我们并没有深入这一点，

1674
01:03:02,130 --> 01:03:03,720
0,210 210,390 390,600 600,1350 1350,1590
not really go into that,|
|

1675
01:03:03,720 --> 01:03:05,490
0,240 660,1080 1080,1230 1230,1320 1320,1770
but just like the process
但就像同步时钟

1676
01:03:05,490 --> 01:03:07,050
0,180 180,780 780,870 870,1320 1320,1560
of synchronizing the clocks| or
|甚至测量它们有多不同。

1677
01:03:07,050 --> 01:03:09,210
0,570 690,1290 1290,1590 1590,2040 2040,2160
even measuring how different they

1678
01:03:09,210 --> 01:03:10,560
0,210 210,600 750,840 840,1080 1080,1350
are.| Yeah.| I mean, shouldn't
|是的。|我的意思是，我们不应该也考虑到信息传递的时间吗。

1679
01:03:10,560 --> 01:03:11,670
0,90 90,390 390,750 750,930 930,1110
we also account for the

1680
01:03:11,670 --> 01:03:13,620
0,480 480,780 780,870 870,1320 1320,1950
time of the message travel,

1681
01:03:13,650 --> 01:03:15,510
0,90 90,270 270,1110 1110,1560 1560,1860
I mean.| Yeah, yeah, I
|是的，我想这就是他们的意思，

1682
01:03:15,510 --> 01:03:16,350
0,150 150,300 300,450 450,600 600,840
think that's what they mean,|
|

1683
01:03:16,350 --> 01:03:17,160
0,90 90,390 390,510 510,690 690,810
I'm sorry, I didn't say
抱歉，我没说太多，

1684
01:03:17,160 --> 01:03:17,970
0,180 180,420 420,540 540,690 690,810
much about this,| but that's
|但这就是他们的意思，

1685
01:03:17,970 --> 01:03:18,960
0,180 180,300 300,570 570,690 690,990
what they mean,| so they
|所以他们对自己的想法保持着持续的估计，

1686
01:03:18,990 --> 01:03:19,890
0,210 210,270 270,480 480,600 600,900
sort of keep a running

1687
01:03:19,890 --> 01:03:21,390
0,480 480,690 690,870 870,1050 1050,1500
estimate about what they think,|
|

1688
01:03:21,390 --> 01:03:23,070
0,90 90,300 300,840 1050,1380 1380,1680
you know the for example
例如，与时间 master 同步，

1689
01:03:23,070 --> 01:03:24,000
0,90 90,510 510,600 600,690 690,930
to synchronize with the time

1690
01:03:24,000 --> 01:03:26,910
0,630 840,1470 1500,1920 1920,2550 2580,2910
master,| the presumably the time
|本地计算机上的时间库

1691
01:03:26,910 --> 01:03:28,440
0,450 450,570 570,630 630,840 840,1530
library on the local machine|
|

1692
01:03:28,440 --> 01:03:30,630
0,480 480,840 840,1290 1290,1680 1710,2190
keeps {} track of the
可能会跟踪开始时间以进行估计，

1693
01:03:30,870 --> 01:03:31,890
0,300 300,360 360,540 540,600 600,1020
start to make an estimate,|
|

1694
01:03:31,890 --> 01:03:33,480
0,90 90,690 690,840 840,1170 1170,1590
of what is the average
平均延迟或正常延迟是多少，

1695
01:03:33,480 --> 01:03:36,120
0,330 330,600 870,1590 1590,2040 2040,2640
delay or normal delay,| for
|向时间 master 发送或接收消息，

1696
01:03:36,150 --> 01:03:37,290
0,330 330,390 390,750 750,810 810,1140
sending or receiving a message

1697
01:03:37,290 --> 01:03:38,970
0,90 90,180 180,390 390,810 1410,1680
to the time master,| and
|用它来纠正任何小错误，

1698
01:03:38,970 --> 01:03:41,010
0,360 360,570 570,990 990,1350 1350,2040
basically use that to correct

1699
01:03:41,010 --> 01:03:43,920
0,270 270,870 900,1650 1680,2190 2190,2910
for any {} small mistakes,|
|

1700
01:03:45,300 --> 01:03:47,220
0,660 690,930 930,1350 1350,1470 1470,1920
then they also the protocol
他们协议也支持离散值，

1701
01:03:47,220 --> 01:03:49,020
0,360 360,510 510,900 900,1110 1110,1800
clearly have support for outliers,|
|

1702
01:03:49,020 --> 01:03:50,490
0,210 210,480 480,810 810,1440 1440,1470
and so [] outliers,| I
所以[]离群值，|我是说网络中发生的不好的事情，

1703
01:03:50,490 --> 01:03:51,570
0,240 240,480 480,720 720,990 990,1080
mean something bad happened in

1704
01:03:51,570 --> 01:03:53,250
0,60 60,420 420,510 510,1140 1260,1680
the network,| and therefore {}
|因此你的时间戳延迟了很多，

1705
01:03:53,250 --> 01:03:54,570
0,210 210,420 420,720 720,900 900,1320
your {timestamp -} got delayed

1706
01:03:54,570 --> 01:03:55,080
0,60 60,150 150,450
in a lot,|
|

1707
01:03:55,110 --> 01:03:56,520
0,300 300,720 720,870 870,1080 1080,1410
so you should not include
所以你不应该包括那些，

1708
01:03:56,520 --> 01:03:58,140
0,510 630,1290 1290,1410 1410,1470 1470,1620
those,| {} and I guess
|我想还有第三个问题，

1709
01:03:58,140 --> 01:03:59,190
0,150 150,210 210,480 480,840 840,1050
there's a third problem,| which
|有时这些振荡器会失灵，

1710
01:03:59,190 --> 01:04:00,660
0,210 210,570 570,630 630,1140 1140,1470
is you know sometimes these

1711
01:04:00,660 --> 01:04:03,480
0,780 780,1440 1440,1830 1920,2010 2010,2820
oscillators go [kaput],| you know
|不再是正确的了，

1712
01:04:03,480 --> 01:04:05,460
0,360 780,930 930,1110 1110,1440 1440,1980
just are not correct anymore,|
|

1713
01:04:05,610 --> 01:04:06,870
0,180 180,300 300,390 390,630 630,1260
and so they may return
它们可能返回不正确的值，

1714
01:04:06,930 --> 01:04:09,660
0,420 420,1080 1080,1380 1380,2130 2610,2730
incorrect values,| and so you
|所以再次，他们没有谈论大量的细节，

1715
01:04:09,660 --> 01:04:10,770
0,150 150,480 480,660 660,990 990,1110
know again the, {} they

1716
01:04:10,770 --> 01:04:11,640
0,210 210,450 450,600 600,690 690,870
don't talk about the great

1717
01:04:11,640 --> 01:04:12,870
0,180 180,240 240,660 660,930 1080,1230
amount of detail,| but it
|但它们似乎使用了 ntp 类似的技术，

1718
01:04:12,870 --> 01:04:14,730
0,240 240,480 480,900 900,1440 1440,1860
seems those just use similar

1719
01:04:14,730 --> 01:04:16,920
0,420 420,630 630,1500 1680,1980 1980,2190
techniques like ntp| to deal
|来处理这类问题。

1720
01:04:16,920 --> 01:04:18,030
0,90 90,240 240,420 420,480 480,1110
with those kinds of problems.|
|

1721
01:04:19,680 --> 01:04:21,140
0,240 240,360 360,570 570,870
I see, thank you.|
我明白了，谢谢。|

1722
01:04:23,600 --> 01:04:24,590
0,270 270,330 330,510 510,900 900,990
So if you're interested in
所以如果你对这类东西感兴趣，

1723
01:04:24,590 --> 01:04:26,420
0,180 180,360 360,420 420,870 1080,1830
this kind of stuff, {}|
|

1724
01:04:26,420 --> 01:04:28,160
0,390 390,750 750,930 930,1560 1560,1740
there's protocol called ntp,| that
有一种称为 ntp 的协议，|当你的计算机和[]用来

1725
01:04:28,160 --> 01:04:29,600
0,450 450,660 660,930 930,1320 1320,1440
actually when your computer and

1726
01:04:29,600 --> 01:04:31,430
0,330 330,690 690,870 870,1380 1380,1830
[] uses to| actually synchronize
|将它的时钟与全球时间同步，

1727
01:04:31,430 --> 01:04:33,860
0,120 120,570 1470,1950 1950,2130 2130,2430
its clock with {you,know} global

1728
01:04:33,860 --> 01:04:36,080
0,510 810,1260 1260,1650 1650,2100 2100,2220
time,| {} and ntp has
|ntp 有所有这些内置的机制，

1729
01:04:36,080 --> 01:04:37,640
0,150 150,300 300,480 480,570 570,1560
all these kind of mechanism

1730
01:04:37,670 --> 01:04:39,590
0,600 600,930 930,1110 1350,1530 1530,1920
built into it,| but ntp
|但 ntp 不是，

1731
01:04:39,590 --> 01:04:41,000
0,120 120,570 570,1050 1050,1260 1260,1410
is not,| it doesn't have
|它没有相同的位置，也没有同样的小差值，

1732
01:04:41,000 --> 01:04:42,410
0,90 90,480 480,1170 1170,1320 1320,1410
the same position or the

1733
01:04:42,410 --> 01:04:45,770
0,480 1320,1680 1680,2250 2520,2910 2910,3360
same small margins,| {} that
|就是真正的时间，

1734
01:04:45,770 --> 01:04:47,320
0,600 600,780 780,1050 1050,1470
actually true time, {}|
|

1735
01:04:49,390 --> 01:04:50,170
0,210 210,330 330,390 390,690 690,780
and so I think ntp
所以我认为 ntp 可能是，你应该认为，

1736
01:04:50,170 --> 01:04:50,800
0,90 90,300 300,390 390,510 510,630
could be, you know you

1737
01:04:50,800 --> 01:04:51,880
0,120 120,240 240,630 630,780 780,1080
should be thinking that,| these
|这些错误率是从几毫秒到十毫秒的数量级，

1738
01:04:51,880 --> 01:04:53,080
0,180 180,450 450,600 600,720 720,1200
error rates are in order

1739
01:04:53,080 --> 01:04:55,270
0,180 540,1230 1230,1380 1380,1500 1500,2190
of {} you know milliseconds

1740
01:04:55,270 --> 01:04:56,650
0,90 90,270 270,870 870,1260 1260,1380
to ten milliseconds,| basically it
|它主要与往返时间有关。

1741
01:04:56,650 --> 01:04:57,730
0,180 180,240 240,420 420,900 900,1080
has to do mostly with

1742
01:04:57,730 --> 01:04:58,760
0,90 90,480 480,780
the roundtrip time.|
|

1743
01:04:59,790 --> 01:05:00,960
0,780

1744
01:05:03,060 --> 01:05:04,020
0,210 210,360 360,540 540,810 810,960
{Any -} further questions about
对于这个，还有其他问题吗？

1745
01:05:04,020 --> 01:05:04,600
0,300
this?|
|

1746
01:05:07,600 --> 01:05:09,880
0,300 300,720 1050,1650 1770,2160 2160,2280
Okay, so {} clocks {are,not}
好吧，所以时钟并不是完全同步的，

1747
01:05:09,880 --> 01:05:11,620
0,300 300,960 990,1260 1260,1440 1440,1740
perfectly synchronized,| you know there's
|有一个误差范围，

1748
01:05:11,620 --> 01:05:12,850
0,360 360,630 630,660 660,1110 1110,1230
basically, there's a margin of

1749
01:05:12,850 --> 01:05:15,610
0,450 870,1350 1350,1590 1590,2130 2130,2760
error,| and what basically the
|true time 所做的是，

1750
01:05:15,640 --> 01:05:17,320
0,120 120,360 360,750 750,1140 1140,1680
true time does is,| actually
|true time 给出一个答案，

1751
01:05:17,320 --> 01:05:19,420
0,510 510,1080 1380,1650 1650,1800 1800,2100
{} giving {} true time

1752
01:05:19,420 --> 01:05:21,340
0,270 270,330 330,1260 1260,1830 1830,1920
gives {} an answer,| you
|它会给你最佳估计值，

1753
01:05:21,340 --> 01:05:22,510
0,180 180,420 420,540 540,900 900,1170
know gives you certain best

1754
01:05:22,510 --> 01:05:23,530
0,510 510,720 720,780 780,960 960,1020
estimated guess| of what the
|当前的绝对时间或真实时间是什么，

1755
01:05:23,530 --> 01:05:25,390
0,420 420,870 870,1350 1350,1740 1740,1860
current {} absolute time {or,true}

1756
01:05:25,390 --> 01:05:26,980
0,300 300,660 900,1080 1080,1500 1500,1590
time is| {} plus you
|加上机器的误差范围。

1757
01:05:26,980 --> 01:05:28,450
0,60 60,450 450,870 870,1200 1200,1470
know what the machine things

1758
01:05:28,450 --> 01:05:29,470
0,120 120,210 210,540 540,660 660,1020
is the margin of error.|
|

1759
01:05:30,400 --> 01:05:34,420
0,360 360,840 1200,1890 2460,3240 3360,4020
And so, {} and {}
所以解决这个时钟漂移的办法，

1760
01:05:34,420 --> 01:05:35,980
0,210 210,360 360,480 480,1200 1200,1560
and so the solution or

1761
01:05:36,280 --> 01:05:38,350
0,420 420,630 630,1200 1200,1530 1560,2070
{} to solve to deal

1762
01:05:38,350 --> 01:05:40,840
0,330 330,600 600,990 990,1530 1980,2490
with this clock drift, {}|
|

1763
01:05:40,840 --> 01:05:43,930
0,870 870,1500 1620,2010 2010,2580 2790,3090
is to not use {timestamps
不使用真实时间的时间戳，

1764
01:05:43,930 --> 01:05:45,940
0,720 870,1020 1020,1200 1200,1440 1440,2010
-} you know true time,|
|

1765
01:05:45,940 --> 01:05:47,080
0,120 120,390 390,630 630,870 870,1140
or just just pure {timestamps
或者仅仅是纯粹的时间戳，

1766
01:05:47,080 --> 01:05:49,150
0,570 750,1230 1230,1470 1470,1860 1860,2070
-},| {} but basically {timestamps
|而是时间戳是时间间隔。

1767
01:05:49,150 --> 01:05:50,480
0,330 330,480 480,1170
-} are intervals.|
|

1768
01:06:00,120 --> 01:06:03,150
0,210 210,420 420,990 1380,1980 2310,3030
And so every {} value
所以每个从当前时间返回的值，

1769
01:06:03,150 --> 01:06:05,940
0,510 510,1020 1020,1740 1770,2280 2280,2790
return from {} now, from

1770
01:06:05,940 --> 01:06:08,490
0,90 90,360 360,900 1140,1980 1980,2550
the current time,| basically has
|包含最早的和最晚的，

1771
01:06:09,090 --> 01:06:10,500
0,330 330,1020
the earliest

1772
01:06:11,080 --> 01:06:14,480
0,450 450,630 630,1470
and the latest,|
|

1773
01:06:15,190 --> 01:06:16,630
0,240 240,390 390,450 450,1110 1110,1440
and so, for example {}
例如，我们询问当前时间，

1774
01:06:16,630 --> 01:06:17,560
0,210 210,450 450,570 570,630 630,930
we ask for the current

1775
01:06:17,560 --> 01:06:20,530
0,600 810,1740 1740,2190 2190,2400 2400,2970
time,| {} and it is
|它的真实时间是上午 10 点或下午 2 点，

1776
01:06:20,530 --> 01:06:22,180
0,180 180,510 510,780 990,1230 1230,1650
true time is {10am -}

1777
01:06:22,180 --> 01:06:24,070
0,120 120,300 300,840 960,1680 1680,1890
or {2pm -},| {} it
|它可能返回间隔，

1778
01:06:24,070 --> 01:06:26,080
0,240 240,510 510,1140 1140,1530 1530,2010
might return interval,| saying well
|最早的可能是下午 1:59 ，

1779
01:06:26,080 --> 01:06:27,250
0,90 90,510 510,750 750,900 900,1170
the earliest it could be

1780
01:06:27,250 --> 01:06:29,170
0,420 420,570 570,870 870,1380 1560,1920
is you know {} 1

1781
01:06:29,170 --> 01:06:31,020
0,570 570,870 870,1140 1140,1650
pm {1:59 - -},|
|

1782
01:06:31,340 --> 01:06:33,380
0,510 510,570 570,690 690,1530 1530,2040
and you know 59 seconds
59 秒以及 20 微秒，

1783
01:06:33,380 --> 01:06:36,380
0,660 660,810 810,930 930,1590 1920,3000
and you know whatever {}

1784
01:06:36,410 --> 01:06:38,570
0,480 480,750 750,1320 1620,1740 1740,2160
20 {microseconds -},| you know
|最晚的可能是下午 2 点加上 2 微秒，

1785
01:06:38,570 --> 01:06:40,190
0,210 210,930 930,1200 1200,1500 1500,1620
and latest might be you

1786
01:06:40,190 --> 01:06:42,560
0,270 390,1050 1050,1320 1320,1920 1920,2370
know {} {2pm -} and

1787
01:06:42,560 --> 01:06:43,520
0,390 390,450 450,540 540,690 690,960
plus you know 2 {microseconds

1788
01:06:43,520 --> 01:06:44,240
0,480
-},|
|

1789
01:06:45,340 --> 01:06:46,660
0,210 210,360 360,690 690,870 870,1320
and some machines might be
有些机器可能不止几微秒，

1790
01:06:46,660 --> 01:06:47,560
0,270 270,540 540,690 690,750 750,900
{} more than a couple

1791
01:06:47,560 --> 01:06:48,790
0,60 60,300 300,720 720,870 870,1230
of {microseconds -},| some machine
|有些机器甚至可能有几毫秒，

1792
01:06:48,790 --> 01:06:50,800
0,210 210,480 480,1230 1590,1920 1920,2010
might even milliseconds,| and I
|我猜论文中的一些东西，

1793
01:06:50,800 --> 01:06:51,880
0,270 270,480 480,960 960,1020 1020,1080
guess some things in the

1794
01:06:51,880 --> 01:06:53,590
0,510 510,630 630,930 930,1320 1320,1710
paper,| the margin sometimes are
|误差有时是 10 毫秒或多毫秒的量级，

1795
01:06:53,590 --> 01:06:55,090
0,240 240,480 480,630 630,840 840,1500
in order of 10 milliseconds

1796
01:06:55,090 --> 01:06:57,790
0,300 360,810 810,1440 2400,2640 2640,2700
or multiple milliseconds,| but it
|但它给出了一个间隔，

1797
01:06:57,790 --> 01:06:59,560
0,180 180,480 690,810 810,1440 1530,1770
gives {} an interval,| and
|而且可以保证真实时间在这个时间间隔内。

1798
01:06:59,560 --> 01:07:00,940
0,330 330,960 960,1110 1110,1170 1170,1380
it's guaranteed that the true

1799
01:07:00,940 --> 01:07:02,830
0,450 480,750 750,1260 1260,1440 1440,1890
time is within that interval.|
|

1800
01:07:04,110 --> 01:07:06,000
0,210 210,420 420,540 540,1170 1170,1890
It's a, is the interval
时间间隔是 ε 还是 2ε ？

1801
01:07:06,030 --> 01:07:07,860
0,570 570,720 720,900 900,1500
ε or {2ε -}?|
|

1802
01:07:08,850 --> 01:07:11,240
0,1140 1170,1590 1590,1680 1680,2130

1803
01:07:11,560 --> 01:07:12,520
0,90 90,330 330,540 540,690 690,960
The paper doesn't really talk
论文并没有谈到这一点，

1804
01:07:12,520 --> 01:07:13,690
0,420 420,540 540,780 780,960 960,1170
about it,| {} in that
|从这个意义上说，

1805
01:07:13,690 --> 01:07:15,340
0,510 630,990 990,1170 1170,1350 1350,1650
sense,| {} it is just
|这只是对误差范围的估计，

1806
01:07:15,340 --> 01:07:16,630
0,300 300,780 780,1020 1020,1200 1200,1290
an estimate about what the

1807
01:07:16,630 --> 01:07:18,280
0,300 300,420 420,750 750,1170
margin of error is,|
|

1808
01:07:22,170 --> 01:07:23,250
0,300 300,300 300,750 750,870 870,1080
and I think if you
我认为如果你看一下协议的细节，

1809
01:07:23,250 --> 01:07:24,420
0,270 270,360 360,510 510,1080 1080,1170
look at the details of

1810
01:07:24,420 --> 01:07:26,280
0,510 540,960 960,1260 1260,1440 1440,1860
the protocol,| often that margin
|通常，这个误差范围[] 2ε 。

1811
01:07:26,280 --> 01:07:27,360
0,330 330,540 540,780 780,960 960,1080
error {} {[] -} to

1812
01:07:27,360 --> 01:07:28,360
0,180 180,600
{2ε -}.|
|

1813
01:07:32,570 --> 01:07:33,380
0,540
Okay?|
好的?|

1814
01:07:34,840 --> 01:07:36,040
0,240 240,390 390,840 840,990 990,1200
Now, to deal,| so now
现在，为了解决，|所以现在我们需要调整我们的协议，

1815
01:07:36,040 --> 01:07:38,050
0,90 90,210 210,270 270,900 1200,2010
we need to adjust {}

1816
01:07:38,050 --> 01:07:39,910
0,570 600,1260 1260,1530 1530,1740 1740,1860
our protocols, right,| because our
|因为我们的协议有一些规则，

1817
01:07:39,910 --> 01:07:41,740
0,570 570,720 720,870 870,1410 1410,1830
protocols have some rules,| that
|来设置时间戳的开始时间，

1818
01:07:42,190 --> 01:07:43,930
0,840 840,870 990,1350 1350,1410 1410,1740
{ -} setting the start

1819
01:07:43,930 --> 01:07:46,120
0,540 570,930 930,1200 1200,1830 1860,2190
time for {timestamp -}| or
|或者使用时间戳设置事务的开始时间，

1820
01:07:46,120 --> 01:07:47,500
0,270 270,360 360,630 630,900 900,1380
setting the start time for

1821
01:07:47,500 --> 01:07:48,850
0,390 390,840 840,1050 1050,1140 1140,1350
{} transaction using a {timestamp

1822
01:07:48,850 --> 01:07:51,820
0,450 840,1530 1530,2280 2280,2520 2520,2970
-},| and { - -}
|读取下一个写入的规则，

1823
01:07:51,820 --> 01:07:54,460
0,480 480,1050 1320,2100 2130,2310 2310,2640
rule for {} you know

1824
01:07:54,580 --> 01:07:56,950
0,870 870,1650 1740,2040 2040,2250 2250,2370
reads the way to the

1825
01:07:56,950 --> 01:07:58,480
0,420 420,870 1050,1260 1260,1440 1440,1530
next write,| and {we'll,see} you
|我们会看到，

1826
01:07:58,480 --> 01:07:59,650
0,150 150,540 540,720 720,870 930,1170
know,| basically there's a couple
|有几条规则需要改变，

1827
01:07:59,650 --> 01:08:00,280
0,60 60,330 330,420 420,570 570,630
of rules that need to

1828
01:08:00,280 --> 01:08:02,320
0,90 90,780 810,1080 1080,1410 1410,2040
be changed| to deal with
|处理时间间隔而不是真正的时间。

1829
01:08:02,320 --> 01:08:04,960
0,900 1050,1680 1680,1830 1830,2250 2250,2640
{} intervals as opposed to

1830
01:08:04,960 --> 01:08:06,820
0,600 600,1170 1200,1410 1410,1800
with {} true time.|
|

1831
01:08:08,030 --> 01:08:08,990
0,450 480,690 690,750 750,870 870,960
So, first of all the
首先，开始规则是不同的，

1832
01:08:08,990 --> 01:08:10,540
0,300 300,810
start rule

1833
01:08:11,020 --> 01:08:13,200
0,270 270,750
is different,|
|

1834
01:08:14,480 --> 01:08:17,480
0,660 660,1200 1230,1590 1590,2310 2400,3000
{} so start rule {
所以开始规则是，

1835
01:08:18,180 --> 01:08:19,700
0,1200
-}

1836
01:08:19,940 --> 01:08:22,100
0,330 330,450 450,750 750,1230 1950,2160
is,| the current time,| {you,know,we}
|当前时间，|我们问计算机，请告诉当前时间，

1837
01:08:22,100 --> 01:08:23,600
0,690 690,780 780,1110 1110,1350 1350,1500
asked the computer, please tell

1838
01:08:23,600 --> 01:08:24,530
0,120 120,240 240,480 480,750 750,930
me the current time is,|
|

1839
01:08:24,530 --> 01:08:26,270
0,150 150,270 270,600 600,1080 1350,1740
get {interval -} back,| and
获得时间间隔，|然后我们选择的开始时间是 latest ，

1840
01:08:26,270 --> 01:08:27,560
0,270 270,480 510,930 930,1170 1170,1290
then the start time that

1841
01:08:27,560 --> 01:08:29,660
0,150 150,600 720,1200 1200,1350 1350,2100
we pick is the latest,|
|

1842
01:08:32,690 --> 01:08:34,190
0,480 480,600 600,780 780,1020 1020,1500
and so that just means,
所以这意味着，

1843
01:08:34,190 --> 01:08:36,710
0,270 270,1710 1710,1950 1950,2370 2370,2520
correct,| whatever {timestamp -}, the
|无论时间戳是什么，开始规则是[]，

1844
01:08:36,710 --> 01:08:38,690
0,270 270,570 570,900 900,1530 1560,1980
start rule {actually,is} [],| is
|肯定在真实时间之后，

1845
01:08:38,690 --> 01:08:41,030
0,960 990,1110 1110,1380 1380,2130 2160,2340
guaranteed to be after true

1846
01:08:41,030 --> 01:08:41,660
0,360
time,|
|

1847
01:08:42,540 --> 01:08:43,440
0,330 330,450 450,630 630,810 810,900
so we know that true
我们知道真实时间在过去，

1848
01:08:43,440 --> 01:08:44,700
0,330 330,390 390,480 480,990
{time,is} in the past,|
|

1849
01:08:45,300 --> 01:08:46,170
0,240 240,450 450,540 540,720 720,870
and {} for {read-only -}
对于只读事务，

1850
01:08:46,170 --> 01:08:47,520
0,120 120,810 960,1050 1050,1140 1140,1350
{} transactions,| you know this
|这被分配到事务的开始处，

1851
01:08:47,520 --> 01:08:48,720
0,120 120,240 240,510 510,600 600,1200
is {assign -} to the

1852
01:08:48,720 --> 01:08:51,440
0,270 270,360 360,450 450,1200
start of the transaction,|
|

1853
01:08:53,180 --> 01:08:55,760
0,330 330,900 900,1470 1470,1890 1890,2580
and for read-write transaction,| {as,before},
对于读写交易，|像之前一样，它是在提交开始时，

1854
01:08:55,880 --> 01:08:56,870
0,240 240,600 600,810 810,930 930,990
it actually has at the

1855
01:08:56,870 --> 01:08:58,100
0,300 300,450 450,540 540,840 840,1230
point that the commit starts,|
|

1856
01:09:00,250 --> 01:09:01,660
0,150 150,360 360,570 570,810 810,1410
so that part doesn't change,|
所以这一部分不会改变，|

1857
01:09:01,720 --> 01:09:02,530
0,150 150,330 330,480 480,600 600,810
the only part that really
唯一改变的是，

1858
01:09:02,530 --> 01:09:03,970
0,450 450,660 660,1020 1140,1320 1320,1440
changes is that,| you get
|你得到时间间隔的终点，

1859
01:09:03,970 --> 01:09:05,170
0,150 150,570 570,660 660,750 750,1200
the {end,point} of the interval,|
|

1860
01:09:06,050 --> 01:09:06,740
0,180 180,330 330,450 450,600 600,690
and we can get the
我们可以得到时间间隔的终点，

1861
01:09:06,740 --> 01:09:07,880
0,360 360,420 420,510 510,990 990,1140
{end,point} of the interval,| so
|所以，至少真正的时间已经过去了。

1862
01:09:07,880 --> 01:09:08,960
0,150 150,300 300,570 570,720 720,1080
that at least true time

1863
01:09:08,960 --> 01:09:11,760
0,600
past,

1864
01:09:12,080 --> 01:09:13,040
0,210 210,660
has past.|
|

1865
01:09:13,480 --> 01:09:16,150
0,360 360,810 1080,2340 2340,2400 2400,2670
Okay, then there's a second
好的，还有第二条我们以前没有的规则，

1866
01:09:16,150 --> 01:09:17,470
0,570 600,840 840,930 930,1110 1110,1320
rule that we didn't have

1867
01:09:17,470 --> 01:09:19,450
0,630 1230,1500 1500,1590 1590,1680 1680,1980
before,| which is to commit
|那就是提交等待规则，

1868
01:09:19,450 --> 01:09:20,660
0,240 240,690
wait rule,|
|

1869
01:09:21,260 --> 01:09:23,270
0,660 870,1320 1320,1470 1470,1650 1650,2010
and {} we're gonna delay
我们会在事务中推迟，

1870
01:09:23,270 --> 01:09:25,940
0,120 120,750 750,1620 2040,2460 2460,2670
in transaction,| so if the
|所以，如果事务在提交时获得某个时间戳，

1871
01:09:25,940 --> 01:09:26,840
0,120 120,360 360,510 510,630 630,900
{transaction -} got some {timestamp

1872
01:09:26,840 --> 01:09:28,340
0,510 510,630 630,780 780,1050 1050,1500
-} at the commit time,|
|

1873
01:09:28,580 --> 01:09:30,350
0,690 690,900 900,1260 1260,1320 1320,1770
{} {with,the} start to commit,|
使用提交的开始，|

1874
01:09:30,350 --> 01:09:31,850
0,150 150,390 390,1140 1170,1440 1440,1500
and then we get to
然后我们到达提交的末尾，

1875
01:09:31,850 --> 01:09:32,750
0,150 150,330 330,450 450,510 510,900
the end of the commit,|
|

1876
01:09:33,310 --> 01:09:34,510
0,480 480,630 630,750 750,810 810,1200
then we're going to delay
然后我们将推迟这一提交，

1877
01:09:34,510 --> 01:09:35,540
0,180 180,660
that commit,|
|

1878
01:09:36,260 --> 01:09:39,950
0,450 450,750 750,1080 1080,1800 3060,3690
{} delay commit until the
延迟提交直到在提交开始时分配的时间戳，

1879
01:09:39,980 --> 01:09:41,720
0,390 390,840 840,990 990,1140 1140,1740
{timestamp -} that was assigned

1880
01:09:41,720 --> 01:09:42,590
0,180 180,270 270,690 690,780 780,870
at the starting of the

1881
01:09:42,590 --> 01:09:43,320
0,420
commit,|
|

1882
01:09:43,520 --> 01:09:45,240
0,780 810,1410
{} is
是过去的，

1883
01:09:45,410 --> 01:09:46,620
0,900
{

1884
01:09:49,340 --> 01:09:51,110
0,180 180,360 360,1110 1110,1410 1410,1770
-} is {the,past},| {oh -},
|哦，我的笔记错了，

1885
01:09:51,110 --> 01:09:52,310
0,90 90,390 390,750 750,1050 1050,1200
my notes {are,wrong} here,| {hold,on}
|稍等一下，

1886
01:09:52,310 --> 01:09:53,840
0,300 300,690
one second,|
|

1887
01:10:11,180 --> 01:10:14,450
0,600 600,720 720,780 780,1470 1590,3270
we're going to delay until
我们要推迟到时间戳早于 now.earliest ，

1888
01:10:14,880 --> 01:10:15,920
0,660
{}

1889
01:10:16,230 --> 01:10:19,020
0,300 300,630 630,930 930,1890 1920,2790
{the,timestamp -} is before {}

1890
01:10:19,290 --> 01:10:20,900
0,480 480,1290
{now.earliest -},|
|

1891
01:10:26,390 --> 01:10:27,410
0,330 330,510 510,600 600,780 780,1020
{} so we know that
我们知道这肯定在真实时间之前。

1892
01:10:27,410 --> 01:10:28,640
0,300 300,390 390,780 780,1080 1080,1230
actually is definitely before true

1893
01:10:28,640 --> 01:10:29,300
0,300
time.|
|

1894
01:10:32,180 --> 01:10:34,670
0,600 810,1320 1320,1830 2130,2310 2310,2490
Okay, {} so so that's
好的，这就是对协议的修改，

1895
01:10:34,670 --> 01:10:36,140
0,150 150,240 240,390 390,1140 1140,1470
sort of the modifications to

1896
01:10:36,140 --> 01:10:37,460
0,90 90,690 690,930 930,1110 1110,1320
the protocol,| and let's see
|让我们看看这是如何工作的，

1897
01:10:37,460 --> 01:10:38,840
0,360 360,570 570,990 990,1200 1200,1380
how that works,| {} with
|举个简单的例子，

1898
01:10:38,840 --> 01:10:40,040
0,30 30,330 330,960 960,1080 1080,1200
a simple example,| {} get
|对此有更多的感受。

1899
01:10:40,040 --> 01:10:41,360
0,60 60,300 300,780 810,1050 1050,1320
a little more {} feel

1900
01:10:41,360 --> 01:10:42,120
0,270 270,510
for it.|
|

1901
01:10:48,890 --> 01:10:49,790
0,150 150,330 330,690 690,780 780,900
So, for example, I'm going
例如，我将使用比前一个简单的，

1902
01:10:49,790 --> 01:10:51,410
0,60 60,510 510,720 720,1320 1320,1620
to use a slightly simpler

1903
01:10:51,410 --> 01:10:52,190
0,90 90,180 180,480 480,690 690,780
than the previous one,| I'm
|我将只关注写入 x 的事务，

1904
01:10:52,190 --> 01:10:53,030
0,150 150,300 300,660 660,780 780,840
just gonna focus on the

1905
01:10:53,030 --> 01:10:54,770
0,480 480,660 660,840 840,1170 1170,1740
transaction that does writes x,|
|

1906
01:10:55,750 --> 01:10:57,070
0,180 180,390 390,660 660,1170 1170,1320
and we still have 3
我们还是有 3 个事务，

1907
01:10:57,070 --> 01:10:58,260
0,930
transactions,|
|

1908
01:10:58,730 --> 01:11:00,410
0,180 180,720 720,870 870,1110 1110,1680
so here's {} {T1 -},|
所以这是 T1 ，|

1909
01:11:01,110 --> 01:11:03,260
0,540 540,720 720,1140 1140,1830
and T1 does write
T1 执行写入 x ，然后提交，

1910
01:11:03,460 --> 01:11:05,140
0,300 300,780 780,930 930,1050 1050,1680
to x and then commits,|
|

1911
01:11:05,560 --> 01:11:07,150
0,570 570,990 990,1080 1080,1230 1230,1590
and { - -}, let's
我们并不太关心这些事务，

1912
01:11:07,150 --> 01:11:07,720
0,90 90,180 180,270 270,390 390,570
you know we don't really

1913
01:11:07,720 --> 01:11:08,590
0,240 240,360 360,540 540,720 720,870
care too much about these

1914
01:11:08,590 --> 01:11:10,330
0,540 540,630 630,960 960,1350 1350,1740
transactions,| so let's say the
|所以我们假设提交在 1 ，真实时间 1 ，

1915
01:11:10,450 --> 01:11:11,820
0,510 510,900
{commit,at} 1,

1916
01:11:12,360 --> 01:11:13,840
0,330 330,450 450,750 750,1140
so true time 1,|
|

1917
01:11:14,950 --> 01:11:16,030
0,240 240,390 390,480 480,660 660,1080
so now we're gonna run
所以现在我们将运行事务 T2 ，

1918
01:11:16,060 --> 01:11:19,060
0,510 510,750 750,1290 1860,2700 2700,3000
transaction {T2 -},| and it's
|它会写入，

1919
01:11:19,060 --> 01:11:20,080
0,240 240,750
gonna write,|
|

1920
01:11:21,020 --> 01:11:22,250
0,210 210,420 420,840 840,1020 1020,1230
yeah, so transaction {T2 -}
是的，事务 T2 当然在 T1 之后运行，

1921
01:11:22,250 --> 01:11:23,870
0,90 90,450 450,810 810,1410 1410,1620
of course runs after {T1

1922
01:11:23,870 --> 01:11:24,860
0,480
-},|
|

1923
01:11:25,900 --> 01:11:27,790
0,750 750,930 930,1470 1470,1650 1650,1890
and it writes {you,know} say
它写入比如 x2 ，

1924
01:11:27,790 --> 01:11:29,020
0,930
x2,|
|

1925
01:11:29,280 --> 01:11:30,840
0,150 150,450 450,660 660,960 960,1560
so here write {x1 -},|
所以这里写入 x1 ，|

1926
01:11:30,840 --> 01:11:32,910
0,330 330,570 570,720 720,1260 1500,2070
writes 2 to x, {}|
将 2 写入 x ，|

1927
01:11:32,910 --> 01:11:34,140
0,150 150,480 480,570 570,1080 1080,1230
it starts to prepare, which
它开始准备，这是提交的开始，

1928
01:11:34,140 --> 01:11:34,920
0,180 180,270 270,600 600,720 720,780
was the beginning of the

1929
01:11:34,920 --> 01:11:35,640
0,480
commit,|
|

1930
01:11:35,860 --> 01:11:37,450
0,240 240,750 930,1350 1350,1530 1530,1590
and so {} at the
所以在提交开始时，请求一个时间，

1931
01:11:37,450 --> 01:11:38,650
0,240 240,300 300,390 390,870 870,1200
beginning of the commit, {you,know,going,to}

1932
01:11:38,650 --> 01:11:40,820
0,390 390,990 990,1320 1320,1830
ask for a time,|
|

1933
01:11:41,320 --> 01:11:43,240
0,930 1230,1620 1620,1710 1710,1800 1800,1920
{} and so it's going
它将得到一个时间间隔，

1934
01:11:43,240 --> 01:11:44,290
0,60 60,180 180,240 240,600 600,1050
to get an interval back,|
|

1935
01:11:44,770 --> 01:11:46,600
0,810 1050,1230 1230,1350 1350,1440 1440,1830
and you know we know
我们知道真实时间会回来，

1936
01:11:46,600 --> 01:11:49,000
0,510 540,1290 1500,1830 1830,2220 2220,2400
that {} true time that's

1937
01:11:49,000 --> 01:11:49,690
0,120 120,180 180,330 330,600 600,690
going to get back| as
|作为[]在时间间隔中，

1938
01:11:49,690 --> 01:11:52,420
0,630 960,1530 1530,1890 1890,2070 2070,2730
some [] {lie,in} that interval,|
|

1939
01:11:52,540 --> 01:11:53,740
0,510 510,660 660,960 960,1050 1050,1200
{} but somewhere in that
但在时间间隔的某个时候，

1940
01:11:53,740 --> 01:11:55,030
0,420 600,780 780,870 870,1200 1200,1290
interval,| so the interval in
|所以，时间间隔可能开始在真实时间之前，

1941
01:11:55,030 --> 01:11:56,050
0,240 240,360 360,810 810,900 900,1020
fact {you,know} might you know

1942
01:11:56,050 --> 01:11:57,580
0,420 480,870 870,1380 1380,1500 1500,1530
start well before you know

1943
01:11:57,580 --> 01:11:59,530
0,0 0,210 210,720 1110,1680 1680,1950
{} true time,| let's say
|比如时间间隔开始于 1 ，

1944
01:11:59,530 --> 01:12:00,490
0,90 90,180 180,390 390,630 630,960
you know {interval -} starts

1945
01:12:00,490 --> 01:12:01,720
0,210 210,480 510,660 660,720 720,1230
[] at you know 1,|
|

1946
01:12:01,960 --> 01:12:03,850
0,240 240,870 870,1110 1110,1320 1440,1890
which overlaps with the transaction
与事务 T1 重叠，

1947
01:12:03,850 --> 01:12:05,650
0,180 180,600 870,1590 1590,1710 1710,1800
{T1 -},| and you know
|也许时间间隔的最新值是 10 ，

1948
01:12:05,650 --> 01:12:07,630
0,540 540,780 780,1080 1080,1710 1740,1980
maybe the latest value of

1949
01:12:07,630 --> 01:12:08,890
0,120 120,450 450,870 870,1140 1140,1260
true times {is -}, of

1950
01:12:08,890 --> 01:12:10,660
0,420 420,780 960,1230 1230,1410 1410,1770
{interval,is} 10,| so that's what
|这就是它得到的，

1951
01:12:10,660 --> 01:12:12,700
0,270 270,480 480,960 1140,1710 1710,2040
it gets back,| and what
|我们要选择作为时间戳的是，

1952
01:12:12,700 --> 01:12:14,110
0,450 630,960 960,1080 1080,1260 1260,1410
we're going to pick as

1953
01:12:14,110 --> 01:12:15,370
0,90 90,390 390,840 960,1110 1110,1260
the {timestamp -} is| going
|选择这个值 10 ，

1954
01:12:15,370 --> 01:12:16,930
0,120 120,510 540,900 900,1260 1260,1560
to pick this value 10,|
|

1955
01:12:19,930 --> 01:12:20,830
0,270 270,390 390,540 540,690 690,900
and we want to pick
我们想要选择最新的值，

1956
01:12:20,830 --> 01:12:22,630
0,120 120,720 720,1350 1350,1650 1650,1800
the latest value,| because we
|因为我们想绝对确定，

1957
01:12:22,630 --> 01:12:23,920
0,150 150,210 210,330 330,810 810,1290
want to be absolutely sure

1958
01:12:23,920 --> 01:12:25,030
0,390 420,570 570,720 720,900 900,1110
that,| you know if there's
|如果有一个事务在真实时间之前开始，

1959
01:12:25,030 --> 01:12:27,640
0,90 90,750 1110,1500 1500,1860 1860,2610
a transaction that started before

1960
01:12:27,670 --> 01:12:29,260
0,690 690,840 840,960 960,1350 1380,1590
{} you know the true

1961
01:12:29,260 --> 01:12:30,910
0,480 630,960 960,1380 1380,1500 1500,1650
time,| {} that you know
|我们选的时间肯定是在真实时间之后，

1962
01:12:30,910 --> 01:12:31,780
0,210 210,390 390,420 420,720 720,870
we pick a time that

1963
01:12:31,780 --> 01:12:33,220
0,120 120,480 480,810 810,1080 1080,1440
is definitely after that transaction,

1964
01:12:33,220 --> 01:12:34,330
0,390 390,480 480,630 630,930 930,1110
{that -} true time,| so
|所以我们选择 10 ，绝对超过 1 ，

1965
01:12:34,330 --> 01:12:35,350
0,120 120,270 270,420 420,750 750,1020
we're gonna pick 10, which

1966
01:12:35,350 --> 01:12:37,270
0,90 90,510 510,990 990,1440 1680,1920
is definitely beyond 1,| and
|我们永远不会对之前的事务感到困惑，

1967
01:12:37,270 --> 01:12:38,440
0,210 210,450 450,630 630,750 750,1170
so we'll never get confused

1968
01:12:38,440 --> 01:12:40,220
0,240 240,510 540,1020 1020,1560
about this previous transactions,|
|

1969
01:12:41,460 --> 01:12:42,900
0,390 390,450 450,630 630,1140
then, at some point,|
然后，在某个时刻，|

1970
01:12:43,270 --> 01:12:44,530
0,120 120,300 300,420 420,600 600,1260
you know, so this transaction
这个事务选择了时间戳 10 ，

1971
01:12:44,530 --> 01:12:46,180
0,90 90,360 420,1170 1200,1440 1440,1650
you know {} takes {timestamp

1972
01:12:46,180 --> 01:12:47,740
0,300 300,390 390,960 960,1110 1110,1560
-} 10,| {and,the} {} 10
|10 可能比真实时间更远一点，

1973
01:12:47,740 --> 01:12:48,700
0,120 120,600 600,810 810,900 900,960
you know might be a

1974
01:12:48,700 --> 01:12:49,390
0,150 150,300 300,540 540,630 630,690
little bit further in the

1975
01:12:49,390 --> 01:12:50,740
0,330 330,480 480,660 660,990 1020,1350
future of true time, right,|
|

1976
01:12:51,370 --> 01:12:54,250
0,420 420,930 960,1740 1770,2250 2250,2880
so {} transaction doesn't prepare,|
所以，事务不会准备，|

1977
01:12:54,250 --> 01:12:56,110
0,210 210,600 600,930 930,1410 1410,1860
or {} whatever necessary work
或者两阶段提交所需的工作，

1978
01:12:56,110 --> 01:12:56,830
0,90 90,240 240,390 390,510 510,720
you know the {two-phase -}

1979
01:12:56,830 --> 01:12:58,450
0,690 690,960 960,1230 1230,1380 1380,1620
commit,| actually hits the real
|（直到）到达真正的提交点，

1980
01:12:58,450 --> 01:12:59,420
0,270 270,720
commit point,|
|

1981
01:13:00,160 --> 01:13:02,170
0,570 690,960 960,1110 1110,1560 1680,2010
{} and {there -} and
那里，可能需要等待，

1982
01:13:02,170 --> 01:13:03,460
0,240 240,420 420,510 510,990
may have to wait,

1983
01:13:03,760 --> 01:13:04,750
0,360 360,570 570,780 780,840 840,990
right,| because this is a
|因为这是提交规则，

1984
01:13:04,750 --> 01:13:06,070
0,330 330,870 870,1050 1050,1200 1200,1320
commit rule,| {} we have
|我们得等一会儿，

1985
01:13:06,070 --> 01:13:07,270
0,90 90,360 360,420 420,660 660,1200
to wait a little while,|
|

1986
01:13:07,300 --> 01:13:09,490
0,420 420,750 750,1200 1200,1860 1890,2190
until {} absolutely sure that
直到我们确定 10 已经过去，

1987
01:13:09,490 --> 01:13:11,830
0,720 780,1230 1230,2130 2130,2280 2280,2340
10 {} exactly in the

1988
01:13:11,830 --> 01:13:12,600
0,570
past,|
|

1989
01:13:13,280 --> 01:13:15,290
0,240 240,720 870,1230 1230,1620 1620,2010
and so {} this basically
所以，这就是提交时间，

1990
01:13:15,290 --> 01:13:17,330
0,210 210,450 450,900 1110,1500 1500,2040
the {commit,time},| { -} what
|事务协调者所要做的是，

1991
01:13:17,330 --> 01:13:19,580
0,180 180,930 1080,1920 1920,2070 2070,2250
you know {} {transaction -}

1992
01:13:19,580 --> 01:13:20,450
0,300 300,420 420,600 600,750 750,870
coordinator will do is,| look
|查看提交时间，

1993
01:13:20,450 --> 01:13:21,680
0,120 120,330 330,630 660,990 990,1230
at commit time,| just keep
|继续读取它的本地时钟，

1994
01:13:21,680 --> 01:13:23,390
0,240 240,390 390,630 630,1170 1440,1710
reading its local clock,| and
|我们会继续读取它的本地时钟，直到获得时间间隔，

1995
01:13:23,390 --> 01:13:24,380
0,150 150,360 360,630 630,750 750,990
we'll keep reading its local

1996
01:13:24,380 --> 01:13:25,310
0,360 360,630 630,690 690,870 870,930
clock until it gets an

1997
01:13:25,310 --> 01:13:27,260
0,390 390,810 1050,1380 1380,1470 1470,1950
interval back,| where the earliest
|那里的 earliest 时间已经过了 10 ，

1998
01:13:27,260 --> 01:13:29,720
0,630 720,930 930,1740 1770,2280
time is past 10,|
|

1999
01:13:30,870 --> 01:13:32,070
0,180 180,450 450,570 570,750 750,1200
so maybe at some point,
所以也许在某一时刻，读取，

2000
01:13:32,070 --> 01:13:33,690
0,90 90,450 450,870 870,1350 1350,1620
you know reading {boom,boom} reading,|
|

2001
01:13:33,690 --> 01:13:35,250
0,510 510,750 750,1020 1020,1290 1290,1560
reading gets actual interval back,|
读取获得时间间隔，|

2002
01:13:35,250 --> 01:13:36,870
0,90 90,210 210,810 1020,1410 1410,1620
and then interval and the
然后时间间隔从 9 或 7 开始，

2003
01:13:36,870 --> 01:13:38,040
0,330 330,630 630,720 720,960 960,1170
interval starts to say at

2004
01:13:38,040 --> 01:13:39,630
0,390 390,510 510,990 1110,1260 1260,1590
9 or 7,| it keeps
|它一直读取，直到得到一个大于 10 的值，

2005
01:13:39,630 --> 01:13:41,490
0,480 660,1230 1230,1320 1320,1620 1620,1860
reading until it actually gets

2006
01:13:41,490 --> 01:13:43,170
0,30 30,390 390,600 600,1140 1170,1680
a value that's bigger than

2007
01:13:43,380 --> 01:13:45,540
0,420 420,1050 1200,1410 1410,2040 2040,2160
{} 10,| and then we
|然后我们确定真正的时间已经过去了，

2008
01:13:45,540 --> 01:13:48,330
0,240 240,330 330,1050 1170,1920 1950,2790
know for sure that {}

2009
01:13:48,480 --> 01:13:50,700
0,420 420,720 720,1050 1050,1680 1890,2220
true time has passed,| and
|它是安全的来提交事务，

2010
01:13:50,700 --> 01:13:52,410
0,480 480,720 720,1050 1050,1380 1380,1710
so it safe actually to

2011
01:13:52,410 --> 01:13:54,000
0,630 660,990 990,1440
{} commit transaction,|
|

2012
01:13:55,550 --> 01:13:57,080
0,210 210,630 660,930 930,1410 1410,1530
and so any transaction that
所以现在 T3 之后运行的任何事务

2013
01:13:57,080 --> 01:13:59,480
0,210 210,570 570,960 960,1770 1890,2400
now runs after T3 {}|
|

2014
01:13:59,480 --> 01:14:02,030
0,330 330,870 1170,1470 1470,1860 1860,2550
will have must run after
都必须在真实时间 10 之后运行。

2015
01:14:02,030 --> 01:14:03,500
0,360 360,540 540,840 840,1140
{} true time 10.|
|

2016
01:14:05,660 --> 01:14:07,250
0,210 210,390 390,930 1350,1470 1470,1590
So let's say you know
假设事务 3 在某个时间点开始，

2017
01:14:07,250 --> 01:14:09,020
0,300 300,540 540,810 810,1020 1020,1770
{transaction - -} 3 start

2018
01:14:09,730 --> 01:14:12,250
0,210 210,360 360,900 1290,2130 2130,2520
at some point,| and {}
|并且事务 3 在 T2 之后开始，

2019
01:14:12,250 --> 01:14:13,810
0,300 300,510 510,720 720,1140 1140,1560
{transaction -} 3 starts after

2020
01:14:13,810 --> 01:14:15,520
0,420 420,750 780,1020 1020,1380 1410,1710
{T2 -},| so we have
|所以我们现在绝对确定，

2021
01:14:15,520 --> 01:14:16,780
0,60 60,270 270,510 510,900 900,1260
to now make absolutely sure,|
|

2022
01:14:16,780 --> 01:14:18,100
0,420 420,570 570,1020 1020,1140 1140,1320
that we read you know
我们读到 x 是 2 ，

2023
01:14:18,100 --> 01:14:19,720
0,690 690,870 870,1020 1020,1110 1110,1620
{x,is,2}, is going to read,|
|

2024
01:14:19,990 --> 01:14:22,240
0,450 480,690 690,870 870,1260 1590,2250
so it's gonna read x,|
所以它将是读取 x ，|

2025
01:14:23,020 --> 01:14:26,240
0,750 1110,1770 2010,2910
{} and {
我们将询问当前时间，

2026
01:14:26,750 --> 01:14:29,030
0,630 720,930 930,1110 1110,2070 2070,2280
-} and so we will

2027
01:14:29,030 --> 01:14:30,470
0,210 210,390 390,570 570,870 870,1440
ask for the current time,|
|

2028
01:14:30,710 --> 01:14:31,820
0,390 390,510 510,660 660,840 840,1110
{} it's gonna get maybe
可能会得到一个时间间隔，

2029
01:14:31,820 --> 01:14:35,300
0,90 90,420 420,1560 2250,2970 2970,3480
an interval back,| interval {}
|时间间隔可能稍微重叠 T2 ，

2030
01:14:35,330 --> 01:14:38,330
0,630 630,1530 1530,1650 1650,1860 1860,3000
might overlap a little bit

2031
01:14:38,330 --> 01:14:41,150
0,180 180,720 1080,1860 2070,2400 2400,2820
{T2 -},| { -} but
|但是这个时钟的真实时间可能是相当精确的，

2032
01:14:41,150 --> 01:14:42,860
0,210 210,300 300,510 510,930 930,1710
{you,know} the true time {}

2033
01:14:42,890 --> 01:14:44,480
0,600 900,1080 1080,1230 1230,1500 1500,1590
maybe from this clock is

2034
01:14:44,480 --> 01:14:45,950
0,240 240,750 750,1050 1050,1170 1170,1470
pretty precise,| and true time,
|时间间隔是从 10 到 12 ，

2035
01:14:45,950 --> 01:14:46,880
0,90 90,420 420,600 600,840 840,930
the interval get back is

2036
01:14:46,880 --> 01:14:48,050
0,150 150,330 330,420 420,900 930,1170
from 10 to 12,| so
|所以，真实时间是在 10 到 12 之间，

2037
01:14:48,050 --> 01:14:49,280
0,150 150,450 450,540 540,900 900,1230
true time is somewhere between

2038
01:14:49,280 --> 01:14:50,060
0,150 150,240 240,690
10 to 12,|
|

2039
01:14:50,980 --> 01:14:52,090
0,240 240,600 600,780 780,990 990,1110
{} we know which are
我们知道必须超过 10 ，

2040
01:14:52,090 --> 01:14:53,350
0,360 360,540 540,600 600,720 720,1260
basically has to be past

2041
01:14:53,350 --> 01:14:54,460
0,60 60,180 180,540 540,990 990,1110
you know 10,| because you
|因为我们定义 T3 读取在 T2 之后，

2042
01:14:54,460 --> 01:14:55,900
0,180 180,390 390,660 660,870 870,1440
know we're going {T3,reads -

2043
01:14:55,900 --> 01:14:58,900
0,450 450,630 630,1380 1800,2460 2460,3000
-} by definition {} after

2044
01:14:58,900 --> 01:14:59,780
0,180 180,720
{T2 -},|
|

2045
01:15:00,170 --> 01:15:02,060
0,480 720,1260 1260,1440 1440,1740 1740,1890
{} and {} that's gonna
这会正常的，

2046
01:15:02,060 --> 01:15:03,680
0,210 210,510 510,720 720,1170 1170,1620
work out,| because basically t
|因为 T3 将选择它的时间戳，

2047
01:15:03,710 --> 01:15:05,420
0,840 900,1230 1230,1350 1350,1500 1500,1710
{} T3 is gonna pick

2048
01:15:05,420 --> 01:15:07,400
0,240 240,900 900,1170 1170,1500 1500,1980
{} its {} {timestamp -}|
|

2049
01:15:07,610 --> 01:15:08,690
0,240 240,450 450,540 540,660 660,1080
the end of the interval
时间间隔的结束，根据最新的规则，

2050
01:15:08,720 --> 01:15:10,700
0,450 450,570 570,870 870,1230 1710,1980
by the latest rule,| so
|所以， T3 会运行时间戳真实时间 12 ，

2051
01:15:10,700 --> 01:15:11,540
0,180 180,420 420,510 510,720 720,840
{T3 -} is actually going

2052
01:15:11,540 --> 01:15:13,040
0,60 60,480 600,720 720,990 990,1500
to run {} {timestamp -}

2053
01:15:13,130 --> 01:15:14,450
0,120 120,210 210,390 390,690 690,1320
you know true time 12,

2054
01:15:14,630 --> 01:15:17,120
0,240 240,390 390,810 1020,1980 1980,2490
if you will,| {} and
|这将保证，

2055
01:15:17,120 --> 01:15:18,710
0,150 150,270 270,870 870,1260 1260,1590
that will guarantee, correct,| that
|这个时间间隔我们知道一定会超过真实时间 10 ，

2056
01:15:18,710 --> 01:15:19,580
0,120 120,660
you know

2057
01:15:19,700 --> 01:15:21,230
0,390 390,900 900,1110 1110,1380 1380,1530
this interval we know for

2058
01:15:21,230 --> 01:15:22,790
0,540 540,1020 1020,1140 1140,1290 1290,1560
sure pass the true time

2059
01:15:22,790 --> 01:15:24,890
0,510 990,1230 1230,1500 1500,1890 1890,2100
10,| and so when {T3
|所以当 T3 读取时，读到 x 是 2 ，

2060
01:15:24,890 --> 01:15:26,150
0,300 300,900 930,1080 1080,1140 1140,1260
-} reads you know is

2061
01:15:26,150 --> 01:15:27,950
0,120 120,210 210,720 810,1200 1200,1800
going to read {x,is,2 -},|
|

2062
01:15:30,140 --> 01:15:32,810
0,1020 1050,1140 1140,1290 1290,1950 1980,2670
{because,it,will,observe} you know the value
因为它会观察到事务 2 的值，

2063
01:15:32,810 --> 01:15:34,520
0,240 240,690 690,1020 1020,1320 1320,1710
of transaction 2,| because {you,know}
|因为它的读取超过了真实时间，

2064
01:15:34,520 --> 01:15:37,100
0,360 660,1440 1590,1830 1830,2220 2220,2580
the, {} it's reading well

2065
01:15:37,100 --> 01:15:38,840
0,570 600,930 930,1110 1110,1440
beyond {} true time,|
|

2066
01:15:39,260 --> 01:15:40,010
0,120 120,240 240,450 450,720 720,750
and this must cost a
这肯定要付出一点延迟的代价，

2067
01:15:40,010 --> 01:15:41,120
0,210 210,360 360,450 450,570 570,1110
little bit of {} delay,|
|

2068
01:15:41,180 --> 01:15:42,470
0,420 420,780 780,930 930,990 990,1290
but hopefully if the clocks
但如果时钟相当精确，

2069
01:15:42,470 --> 01:15:44,300
0,60 60,300 300,1080 1170,1560 1560,1830
are pretty precise,| {} as
|正如我们之前所说的，

2070
01:15:44,300 --> 01:15:45,110
0,300 300,510 510,570 570,720 720,810
we talked a little bit

2071
01:15:45,110 --> 01:15:46,220
0,390 390,540 540,780 780,900 900,1110
earlier,| that delay is actually
|这个延迟是很小的。

2072
01:15:46,220 --> 01:15:47,240
0,150 150,210 210,300 300,810
going to be small.|
|

2073
01:15:51,290 --> 01:15:52,420
0,120 120,270 270,420 420,840
Does this make sense?|
这能理解吗？|

2074
01:15:57,390 --> 01:15:58,410
0,300 300,570 570,690 690,870 870,1020
{} Sorry, I had a
抱歉，我有个问题，

2075
01:15:58,410 --> 01:16:01,710
0,630 750,1290 1290,1950 1980,2670 2700,3300
question,| so if {} {T2
|如果 T2 表示它将在时间 10 开始一个事务，

2076
01:16:01,710 --> 01:16:03,300
0,570 600,870 870,1290 1290,1440 1440,1590
-} is saying that it's

2077
01:16:03,300 --> 01:16:05,460
0,270 270,810 1140,1530 1530,1590 1590,2160
going to start a transaction

2078
01:16:05,460 --> 01:16:08,000
0,150 150,480 480,1110 1260,2280
at time 10,| then
|然后当我们读到某个东西，

2079
01:16:08,490 --> 01:16:11,160
0,360 360,570 570,930 930,1650 2040,2670
when we read something do,|
|

2080
01:16:11,190 --> 01:16:12,360
0,330 330,420 420,510 510,660 660,1170
like in the same transaction,|
在同一个事务中，|

2081
01:16:12,360 --> 01:16:13,290
0,120 120,270 270,570 570,810 810,930
do we also need to
我们还需要确保 10 在外面吗，

2082
01:16:13,290 --> 01:16:14,610
0,180 180,420 420,600 600,870 870,1320
make sure that 10 is

2083
01:16:15,300 --> 01:16:17,720
0,870 870,1200 1200,2130
outside,| like before
|在 now 时间间隔之前。

2084
01:16:18,160 --> 01:16:20,680
0,690 720,1470 1500,2220
the now interval.|
|

2085
01:16:21,040 --> 01:16:22,780
0,600 600,840 840,1170 1170,1320 1320,1740
{} The question is,| let's
这个问题是，|假设 T2 所做的不仅是写入，

2086
01:16:22,780 --> 01:16:23,650
0,180 180,360 360,510 510,690 690,870
say {T2 -} does more

2087
01:16:23,650 --> 01:16:25,450
0,120 120,690 690,1290 1290,1470 1470,1800
than writes,| and does {reads,or}
|进行读或写，

2088
01:16:25,450 --> 01:16:27,730
0,510 810,990 990,1320 1320,1920 1950,2280
writes,| you know {} T2
|T2 应该观察到它自己的写入，

2089
01:16:27,730 --> 01:16:29,020
0,210 210,600 600,720 720,930 930,1290
should observe its own write,|
|

2090
01:16:29,440 --> 01:16:30,310
0,120 120,360 360,450 450,750 750,870
is that the question you're
这是你要问的问题吗？

2091
01:16:30,310 --> 01:16:31,020
0,420
asking?|
|

2092
01:16:32,030 --> 01:16:35,420
0,660 690,1440 1560,1980 2010,2430 2790,3390
{} T2, like when when
T2，当我们读取的时候，

2093
01:16:35,420 --> 01:16:36,830
0,420 420,750 750,840 840,1200 1200,1410
we reads,| for example is
|比如，读取 y 。

2094
01:16:37,070 --> 01:16:39,590
0,420 420,720 750,1260 1380,2130 2190,2520
going to read y.| {Yep
|是的，所以我们把这个加进去。

2095
01:16:39,590 --> 01:16:41,810
0,420 420,600 600,840 840,1860 2040,2220
-}, so let's {add,this} to

2096
01:16:41,810 --> 01:16:42,340
0,210
it.|
|

2097
01:16:46,810 --> 01:16:49,030
0,480 480,930 960,1770 1800,2100 2100,2220
Yeah, or yeah after that.|
是的，或者在那之后。|

2098
01:16:49,030 --> 01:16:51,340
0,1410 1410,1620 1620,1830 1830,2010 2010,2310
Yeah, your way [I really
是的，你的方式，在准备好之前是读取 y 。

2099
01:16:51,340 --> 01:16:53,080
0,360 390,780 780,870 870,1470 1470,1740
care], before the prepare actually

2100
01:16:53,080 --> 01:16:53,940
0,180 180,570
reads y.|
|

2101
01:16:54,820 --> 01:16:55,880
0,240 240,420 420,720
Okay, let me,
好的，让我来，好的。

2102
01:16:59,580 --> 01:17:00,420
0,570
yep.|
|

2103
01:17:03,330 --> 01:17:05,360
0,750 960,1740
And then,
然后，哦，

2104
01:17:06,420 --> 01:17:07,300
0,630
oh,|
|

2105
01:17:09,530 --> 01:17:12,200
0,660 660,1230 1320,2100 2100,2250 2250,2670
okay, this may be.| The
好的，这可能是。|原因是读写事务并不那么关心，

2106
01:17:12,200 --> 01:17:13,520
0,420 420,600 600,930 930,1170 1170,1320
reason {read-write -} transaction don't

2107
01:17:13,520 --> 01:17:15,890
0,240 240,480 480,630 630,1080 1380,2370
really matter that much,| because
|如果你回到刚开始，

2108
01:17:15,890 --> 01:17:16,940
0,120 120,210 210,330 330,810 840,1050
if you go back at

2109
01:17:16,940 --> 01:17:18,160
0,90 90,360 360,930
the very beginning,|
|

2110
01:17:18,630 --> 01:17:20,780
0,870 870,1140 1140,1290 1290,1860
{} at this picture
在这张图片上，

2111
01:17:21,110 --> 01:17:23,210
0,270 270,360 360,930 1200,1740 1740,2100
you know the,| {} if
|如果读写事务进行读取，

2112
01:17:23,210 --> 01:17:24,560
0,0 0,240 240,420 420,960 960,1350
a {read-write -} transaction {does,reads},

2113
01:17:24,560 --> 01:17:26,870
0,360 390,1140 1170,1830 1830,2100 2100,2310
right,| {} the reads will
|读取将发送给分片 master 或分片领导者，

2114
01:17:26,870 --> 01:17:30,560
0,240 240,1260 1710,2520 2820,3240 3240,3690
go {to,the} {} shard masters

2115
01:17:30,560 --> 01:17:31,820
0,150 150,420 420,1020 1020,1140 1140,1260
or shard leaders,| that will
|如果你取消读取锁，

2116
01:17:31,820 --> 01:17:32,630
0,150 150,270 270,390 390,630 630,810
[take], if you take read

2117
01:17:32,630 --> 01:17:33,600
0,330 330,720
locks out,|
|

2118
01:17:33,820 --> 01:17:36,730
0,840 840,1710 1710,2190 2190,2670 2670,2910
{} and {} the reads
读取会，

2119
01:17:36,730 --> 01:17:38,830
0,360 390,1020 1020,1500 1500,1920 1920,2100
are basically,| {the,client} executes all
|客户端在本地执行所有操作，

2120
01:17:38,830 --> 01:17:40,220
0,90 90,570 570,1110
the operations locally,

2121
01:17:40,450 --> 01:17:41,950
0,480 540,840 840,1170 1170,1290 1290,1500
right,| and so it gets
|它会获得读取值，

2122
01:17:41,950 --> 01:17:44,140
0,240 240,990 1020,1860 1860,2010 2010,2190
read values,| and we'll read
|我们会读到最新的读取值，

2123
01:17:44,140 --> 01:17:46,480
0,60 60,330 330,870 1050,1530 1560,2340
the most recent read value,|
|

2124
01:17:46,480 --> 01:17:47,350
0,150 150,240 240,480 480,810 810,870
that we got after it
在我们获得锁之后，

2125
01:17:47,350 --> 01:17:48,980
0,300 450,570 570,720 720,1320
locks you know the

2126
01:17:49,270 --> 01:17:50,320
0,750
{}

2127
01:17:50,840 --> 01:17:53,210
0,270 270,570 570,1080 1410,1710 1710,2370
the lock variable,| so basically
|所以，在读写事务中，

2128
01:17:53,210 --> 01:17:54,960
0,120 120,270 270,540 540,1410
in {read-write -} transactions,|
|

2129
01:17:55,040 --> 01:17:56,600
0,360 360,840 840,1110 1110,1410 1410,1560
the locks really do all
锁完成了所有的全局排序，

2130
01:17:56,600 --> 01:17:57,840
0,90 90,420 420,810
the global ordering,|
|

2131
01:17:58,040 --> 01:17:59,150
0,270 270,330 330,480 480,720 720,1110
here's the {two-phase -} locking
两阶段锁确保全局排序，

2132
01:17:59,150 --> 01:18:00,720
0,390 390,630 630,1080
ensures global ordering,|
|

2133
01:18:02,280 --> 01:18:03,540
0,120 120,270 270,540 540,660 660,1260
and so really the interaction
所以真正有趣的互动是，

2134
01:18:03,540 --> 01:18:05,250
0,240 240,360 360,840 840,1260 1380,1710
that is interesting is,| the
|只读事务之间的交互，

2135
01:18:05,250 --> 01:18:07,290
0,510 510,1110 1320,1500 1500,1680 1680,2040
interaction between {you,know} the read-only

2136
01:18:07,290 --> 01:18:09,360
0,690 1110,1290 1290,1410 1410,1620 1620,2070
transaction,| which is {T3 -}
|即 T3 和读取事务之间。

2137
01:18:11,340 --> 01:18:12,720
0,240 240,300 300,510 510,690 690,1380
and the {read-write -} transactions.|
|

2138
01:18:14,170 --> 01:18:16,150
0,270 270,480 480,720 720,1050 1050,1980
One is {T2 -} actually
一个是 T2 实际提交，

2139
01:18:16,270 --> 01:18:17,920
0,570 870,1380
commit,| and
|我们在它提交之前读取。

2140
01:18:18,170 --> 01:18:19,370
0,240 240,540 540,780 780,1140 1140,1200
we're reading it before it

2141
01:18:19,370 --> 01:18:20,240
0,600
commits.|
|

2142
01:18:20,760 --> 01:18:22,530
0,390 390,660 660,810 810,1470 1500,1770
Yeah, so the protocol in
是的，所以读写事务中的协议是，

2143
01:18:22,530 --> 01:18:24,150
0,180 180,360 360,870 870,1320 1320,1620
{read-write -} transaction is,| we're
|我们首先完成所有工作，

2144
01:18:24,150 --> 01:18:25,920
0,510 570,900 900,1260 1260,1470 1470,1770
reading right early, we first

2145
01:18:25,920 --> 01:18:27,060
0,90 90,330 330,420 420,870
do all the work,|
|

2146
01:18:27,400 --> 01:18:28,270
0,150 150,510 510,630 630,780 780,870
and then we go to
然后我们进入提交阶段，

2147
01:18:28,270 --> 01:18:29,800
0,90 90,360 360,900 930,1110 1110,1530
the commit phase,| so here's
|所以这里是提交点，

2148
01:18:29,800 --> 01:18:31,240
0,180 180,450 450,540 540,960 990,1440
like, here's the commit point|
|

2149
01:18:31,630 --> 01:18:33,100
0,420 420,690 690,990
{or,here's} where the
或者这里是客户端提交事务的地方，

2150
01:18:33,250 --> 01:18:35,410
0,720 720,900 900,1140 1140,1470 1470,2160
clients like please commit transaction|
|

2151
01:18:35,890 --> 01:18:37,750
0,210 210,720 720,1170 1170,1770 1770,1860
and {sends,it,to,the} transaction coordinator,| and
并将其发送给事务协调者，|然后事务协调者运行两阶段提交协议。

2152
01:18:37,750 --> 01:18:39,220
0,90 90,150 150,570 570,1260 1260,1470
then the transaction coordinator runs

2153
01:18:39,220 --> 01:18:40,960
0,60 60,210 210,690 690,1200 1200,1740
the {two-phase -} commit protocol.|
|

2154
01:18:42,250 --> 01:18:43,870
0,330 330,720 720,810 810,960 960,1620
{} But you know the
但是所有的分片，

2155
01:18:43,900 --> 01:18:45,310
0,330 330,840 840,1110 1110,1320 1320,1410
{all,the} shards,| {you,know} need to
|需要锁，

2156
01:18:45,310 --> 01:18:47,590
0,240 240,840 900,1590 1590,1740 1740,2280
have locks,| {} the values
|事务实际使用的值（的锁）。

2157
01:18:47,590 --> 01:18:48,850
0,180 180,390 390,570 570,1110 1110,1260
that actually that transaction is

2158
01:18:48,850 --> 01:18:50,380
0,660 690,1170
actually using.|
|

2159
01:19:02,340 --> 01:19:03,200
0,600
Okay?|
好的?|

2160
01:19:10,860 --> 01:19:11,820
0,660
Okay.|
好的。|

2161
01:19:12,280 --> 01:19:14,230
0,300 300,390 390,780 1380,1800 1800,1950
Alright, so let's try to
好的，让我们试着总结一下。

2162
01:19:14,230 --> 01:19:15,940
0,420 420,480 480,630 630,1020 1110,1710
summarize a little bit. {}|
|

2163
01:19:23,560 --> 01:19:25,420
0,690 750,1290 1320,1560 1560,1770 1770,1860
So {} {read-write -} {transactions
所以，读写事务是全局有序的，

2164
01:19:25,420 --> 01:19:26,580
0,990
-}

2165
01:19:27,220 --> 01:19:28,780
0,240 240,390 390,1170
{you,know} are basically

2166
01:19:30,200 --> 01:19:32,480
0,480 480,840 840,1110 1110,1890 1890,2280
global ordered,| or serializable {external,consistency},
|或可串行化加上外部一致性，

2167
01:19:32,990 --> 01:19:36,140
0,690 690,1050 1080,1770 1770,2520 2670,3150
serializability plus external consistency,| due
|因为它们执行两阶段提交加上两阶段锁，

2168
01:19:36,140 --> 01:19:37,280
0,240 240,360 360,720 720,870 870,1140
to the fact that they

2169
01:19:37,280 --> 01:19:39,260
0,360 360,540 540,690 690,1320 1440,1980
basically do {two-phase -} commit

2170
01:19:39,290 --> 01:19:41,640
0,300 300,450 450,660 660,1050
plus {two-phase -} locking,|
|

2171
01:19:42,760 --> 01:19:44,290
0,240 240,450 450,720 720,1350 1380,1530
the {read-only -} transactions are
只读事务比较特殊，

2172
01:19:44,290 --> 01:19:45,670
0,60 60,330 330,480 480,690 690,1380
the ones that are special,|
|

2173
01:19:46,450 --> 01:19:48,910
0,690 690,960 960,1440 1440,1950 1950,2460
because they are only contact
因为它们只联系本地 replica ，

2174
01:19:48,910 --> 01:19:50,440
0,60 60,360 360,990 1140,1470 1470,1530
a local replica,| and the
|而它们能看到正确的值的原因是，

2175
01:19:50,440 --> 01:19:52,150
0,270 270,540 540,870 870,1560 1590,1710
reason they actually see you

2176
01:19:52,150 --> 01:19:53,620
0,120 120,210 210,510 510,1050 1050,1470
know the correct value is,|
|

2177
01:19:53,620 --> 01:19:55,400
0,270 270,360 360,810 810,1470
because of snapshot isolation,|
因为快照隔离，|

2178
01:19:59,950 --> 01:20:03,640
0,660 1680,2490 2490,2820 2820,2940 2940,3690
each data item is actually
每个数据项都是版本化的，

2179
01:20:03,640 --> 01:20:05,680
0,120 120,570 750,1380 1380,1530 1530,2040
{} versioned,| and {} stamped
|并加了修改过的时间戳，

2180
01:20:05,680 --> 01:20:07,810
0,240 240,1260 1260,1470 1470,1800 1800,2130
with the {timestamp -} which

2181
01:20:07,810 --> 01:20:09,850
0,300 300,450 450,1110 1530,1680 1680,2040
actually was modified,| and so,
|所以，你可以使用快照隔离读取过去的内容，

2182
01:20:09,850 --> 01:20:11,050
0,660 690,780 780,930 930,1050 1050,1200
{} you know you can

2183
01:20:11,050 --> 01:20:13,060
0,240 240,330 330,390 390,1020 1080,2010
read in the past {}

2184
01:20:13,060 --> 01:20:15,310
0,240 240,480 480,1110 1620,1770 1770,2250
using snapshot isolation,| and then
|然后为了确保，

2185
01:20:15,430 --> 01:20:16,840
0,300 300,840 840,1020 1020,1290 1290,1410
to ensure that,| {} so
|所以，快照隔离为我们提供了可串行化，

2186
01:20:16,840 --> 01:20:18,610
0,210 210,750 750,1320 1320,1560 1560,1770
this snapshot isolation really gives

2187
01:20:18,610 --> 01:20:22,340
0,420 450,720 720,1380 1380,1980
us {} {serializability -},|
|

2188
01:20:25,090 --> 01:20:27,310
0,330 330,450 450,780 1590,1860 1860,2220
but you know {} Spanner
但是， Spanner 是为了更强的东西，

2189
01:20:27,310 --> 01:20:28,690
0,180 180,450 450,570 570,810 810,1380
actually shoots for something stronger,|
|

2190
01:20:28,720 --> 01:20:30,640
0,450 450,540 540,1020 1020,1320 1320,1920
namely it actually shoots for
也就是，它是为了外部一致性属性，

2191
01:20:30,730 --> 01:20:32,590
0,270 270,720 720,1260 1260,1710 1710,1860
this external consistency property,| which
|就像是线性一致性，

2192
01:20:32,590 --> 01:20:34,270
0,120 120,390 390,1290 1290,1500 1500,1680
is like linearizability,| {} so
|所以它有一个实时的组件，

2193
01:20:34,270 --> 01:20:35,890
0,300 300,840 840,1290 1290,1440 1440,1620
there's real-time component to it,|
|

2194
01:20:38,990 --> 01:20:41,030
0,240 240,360 360,660 660,1380 1800,2040
and to actually ensure that
为了确保我们得到外部一致性，

2195
01:20:41,030 --> 01:20:42,830
0,870 900,1140 1140,1290 1290,1500 1500,1800
{} we got actually external

2196
01:20:42,830 --> 01:20:44,960
0,810 1050,1260 1260,1530 1530,1950 1950,2130
consistency,| {} we execute the
|我们按时间戳顺序执行只读操作，

2197
01:20:44,960 --> 01:20:46,790
0,240 240,480 480,1200 1200,1590 1590,1830
{read-only -} operations in {timestamp

2198
01:20:46,790 --> 01:20:48,060
0,330 330,810
-} order,|
|

2199
01:20:52,890 --> 01:20:54,390
0,510 510,720 720,1260 1260,1380 1380,1500
and {you,know} because you know
因为时间戳顺序，

2200
01:20:54,390 --> 01:20:56,130
0,270 270,600 600,1140 1140,1230 1230,1740
{timestamp -} order,| it requires
|它需要完全同步的时钟，

2201
01:20:56,130 --> 01:20:58,740
0,570 570,1170 1200,1620 1620,2100 2100,2610
on {} perfectly synchronized clocks,|
|

2202
01:20:59,010 --> 01:21:01,860
0,510 510,1350 1350,2220 2250,2760 2760,2850
{} the Spanner relies the
Spanner 有点[依赖]规则

2203
01:21:01,860 --> 01:21:03,750
0,210 210,270 270,510 510,870 1080,1890
rules a little bit| by
|通过使用时间间隔，

2204
01:21:03,750 --> 01:21:08,100
0,360 360,1050 1470,2340 2370,3690 3690,4350
actually using {} time intervals,|
|

2205
01:21:11,640 --> 01:21:12,460
0,600

2206
01:21:14,520 --> 01:21:16,230
0,540 540,630 630,870 870,1230 1230,1710
and the whole goal, correctly,
而整个目标，

2207
01:21:16,230 --> 01:21:17,820
0,90 90,600 690,1170 1170,1470 1470,1590
the whole,| by using this
|通过使用这些技术，

2208
01:21:17,820 --> 01:21:19,470
0,180 180,270 270,960 1080,1410 1410,1650
set of techniques,| it turns
|结果是，只读事务非常快，

2209
01:21:19,470 --> 01:21:21,090
0,180 180,360 360,510 510,780 780,1620
out that {read-only -} transactions

2210
01:21:21,330 --> 01:21:23,280
0,330 330,600 600,1170
are very fast,|
|

2211
01:21:24,840 --> 01:21:26,430
0,180 180,360 360,840 870,1500 1500,1590
so {read-write -} transactions are
读写事务不是特别快，

2212
01:21:26,430 --> 01:21:27,570
0,510 510,570 570,660 660,930 930,1140
basically you know not actually

2213
01:21:27,570 --> 01:21:28,830
0,390 390,780 780,990 990,1110 1110,1260
particularly fast,| if you look
|如果你看一下表 6 ，

2214
01:21:28,830 --> 01:21:30,810
0,120 120,840 870,1170 1170,1530 1530,1980
at the table 6,| {you,know}
|读写事务的时间是 100 毫秒，

2215
01:21:30,810 --> 01:21:32,190
0,210 210,330 330,570 570,870 1020,1380
it's you know 100 {milliseconds

2216
01:21:32,190 --> 01:21:33,900
0,330 330,900 900,1080 1080,1260 1260,1710
-} for {read-write -} transaction,|
|

2217
01:21:33,900 --> 01:21:34,800
0,150 150,360 360,690 690,780 780,900
that means basically you can
也就是说每秒只能做 10 个事务，

2218
01:21:34,800 --> 01:21:35,880
0,180 180,300 300,540 540,990 990,1080
only do 10 transactions per

2219
01:21:35,880 --> 01:21:37,680
0,300 360,750 930,1260 1260,1380 1380,1800
second, right,| this is really
|这真的不算多，

2220
01:21:37,680 --> 01:21:39,810
0,240 240,660 960,1500 1500,1770 1770,2130
not much,| but the read-only
|但只读事务速度很快。

2221
01:21:39,810 --> 01:21:41,560
0,780 870,1050 1050,1620
transactions are fast.|
|

2222
01:21:42,450 --> 01:21:43,290
0,240 240,420 420,510 510,600 600,840
Now, this is the case
现在，情况就是这样，

2223
01:21:43,290 --> 01:21:44,850
0,210 210,450 450,510 510,990 990,1560
though like you know, {}|
|

2224
01:21:45,090 --> 01:21:46,620
0,270 270,540 750,1080 1080,1320 1320,1530
you know the although the
尽管读写事务可能没有那么快，

2225
01:21:46,620 --> 01:21:48,330
0,300 300,630 630,870 870,1500 1500,1710
read-write transactions are maybe not

2226
01:21:48,330 --> 01:21:50,070
0,180 180,660 750,1080 1080,1350 1350,1740
that fast,| they they are
|它们非常强大，

2227
01:21:50,070 --> 01:21:52,320
0,240 240,720 780,1230 1230,1680 1680,2250
very powerful,| {you,know,you're} basically doing
|你是在跨多个分片执行事务性操作，

2228
01:21:52,590 --> 01:21:55,830
0,810 900,1920 1920,2550 2550,2880 2880,3240
{} transactional operations across multiple

2229
01:21:55,830 --> 01:21:56,850
0,390 390,570 570,660 660,900 900,1020
shards,| that is sitting in
|位于世界不同地区的不同数据中心，

2230
01:21:56,850 --> 01:21:58,410
0,270 270,480 480,1230 1230,1320 1320,1560
different data centers in different

2231
01:21:58,410 --> 01:21:59,360
0,210 210,270 270,360 360,690
parts of the world,|
|

2232
01:21:59,700 --> 01:22:00,750
0,240 240,390 390,540 540,780 780,1050
and that {just -} for
对于程序员来说，这是一个非常方便和强大的工具，

2233
01:22:00,750 --> 01:22:03,720
0,600 600,1110 1110,1740 2100,2580 2580,2970
programmers incredibly convenient and powerful

2234
01:22:03,720 --> 01:22:05,310
0,540 750,1110 1110,1260 1260,1410 1410,1590
tool,| {} that you can
|你可以在世界各地复制跨分片的 ACID 语义。

2235
01:22:05,310 --> 01:22:08,490
0,330 330,930 930,1560 1560,1980 2250,3180
ACID semantics across shards in

2236
01:22:08,610 --> 01:22:11,370
0,630 660,1560 1560,2250 2250,2550 2550,2760
{} replicated in all over

2237
01:22:11,370 --> 01:22:12,020
0,90 90,420
the world.|
|

2238
01:22:15,900 --> 01:22:16,950
0,360 360,720 750,870 870,930 930,1050
So, {} this is all
所以，这是我想说的关于 Spanner 的所有事情，

2239
01:22:16,950 --> 01:22:18,120
0,60 60,300 300,360 360,600 600,1170
I wanted to say actually

2240
01:22:18,120 --> 01:22:20,070
0,330 330,750 750,1290 1320,1800 1800,1950
about Spanner,| I hope this
|我希望这是有帮助的，

2241
01:22:20,070 --> 01:22:21,690
0,600 600,750 750,1290 1290,1500 1500,1620
actually was helpful,| and that
|你也许更少困惑或更多困惑，

2242
01:22:21,690 --> 01:22:24,090
0,180 180,540 1020,1650 1770,2190 2190,2400
you're not, {} maybe less

2243
01:22:24,090 --> 01:22:26,400
0,420 420,540 540,900 900,1560 1560,2310
confused and more confused,| because
|因为这次课程，

2244
01:22:26,400 --> 01:22:27,960
0,60 60,210 210,810 810,1020 1290,1560
of this lecture,| but, {}
|但是，如果你有问题，请随意留在这里，

2245
01:22:27,960 --> 01:22:29,490
0,150 150,270 270,660 690,1200 1200,1530
if you have questions, feel

2246
01:22:29,490 --> 01:22:30,630
0,180 180,240 240,420 420,810 810,1140
free to hang around,| and
|我很乐意讨论这一点或 Spanner 的任何其他方面。

2247
01:22:30,630 --> 01:22:32,730
0,300 300,390 390,1110 1140,1530 1560,2100
I'll be happy to discuss

2248
01:22:33,240 --> 01:22:34,470
0,390 390,540 540,690 690,900 900,1230
this or any other aspect

2249
01:22:34,470 --> 01:22:35,080
0,60 60,480
of Spanner.|
|

2250
01:22:37,240 --> 01:22:39,130
0,480 480,630 630,840 840,1230 1230,1890
And good luck finishing 3b,|
祝你好运完成 3b ，|

2251
01:22:39,160 --> 01:22:40,660
0,720 720,960 960,1260 1260,1380 1380,1500
and I hope you get
我希望你有时间享受这个长周末。

2252
01:22:40,660 --> 01:22:42,520
0,210 210,390 390,750 750,1260 1590,1860
time to enjoy the long

2253
01:22:42,520 --> 01:22:43,240
0,390
weekend.|
|

2254
01:22:47,560 --> 01:22:49,220
0,150 150,660 660,1020
{} Thank you.|
谢谢。|

2255
01:22:51,000 --> 01:22:52,110
0,210 210,420 420,750 780,1020 1020,1110
{} So I have a
所以我有一个问题，也许在前面的幻灯片，

2256
01:22:52,110 --> 01:22:53,310
0,420 420,720 720,1020 1020,1110 1110,1200
question, maybe early in the

2257
01:22:53,310 --> 01:22:54,330
0,540 540,660 660,780 780,900 900,1020
slides,| so when you have
|当你有两阶段提交的图表时，

2258
01:22:54,330 --> 01:22:57,570
0,60 60,780 810,1380 1680,2370 2640,3240
{} diagram for {} the

2259
01:22:57,570 --> 01:22:58,710
0,120 120,360 360,690 690,960 960,1140
{two-phase -} commit,| for the
|对于读写事务，

2260
01:22:58,710 --> 01:23:01,860
0,210 210,630 750,1650 1890,2670 2700,3150
{read-write -} transaction,| so before
|所以在我们与 TC 通信之前，

2261
01:23:01,860 --> 01:23:04,740
0,540 630,1110 1110,1260 1260,1680 2610,2880
we communicate with the, with

2262
01:23:04,740 --> 01:23:06,000
0,780
the,

2263
01:23:06,320 --> 01:23:07,820
0,240 240,390 390,960 1020,1200 1200,1500
with the TC,| the TC
|TC 表示协调者吗？

2264
01:23:07,820 --> 01:23:09,680
0,420 420,600 600,690 690,1350 1410,1860
stands for the coordinator?| Yeah,
|是的，表示协调者，是的。

2265
01:23:09,890 --> 01:23:11,870
0,540 540,1020 1020,1350 1500,1800 1830,1980
{stands,for} coordinator, yeah.| Okay, {}
|好的，所以在我们和事务协调者通信之前，

2266
01:23:11,870 --> 01:23:13,070
0,270 270,540 540,690 690,1110 1110,1200
so before we communicate with

2267
01:23:13,070 --> 01:23:14,600
0,60 60,540 540,990 990,1380 1380,1530
the transaction coordinator,| when we
|当我们最初读取 x 和 y 时，

2268
01:23:14,600 --> 01:23:15,950
0,360 360,660 660,930 930,1140 1140,1350
read x and read y

2269
01:23:15,950 --> 01:23:17,870
0,600 840,1080 1080,1470 1470,1770 1770,1920
initially,| {} we don't do
|我们不和 TC 做任何通信，

2270
01:23:17,870 --> 01:23:19,940
0,450 450,660 660,1320 1320,1470 1470,2070
any {} communication with TC,|
|

2271
01:23:21,440 --> 01:23:22,460
0,300 300,450 450,720 720,810 810,1020
so my question is what
所以我的问题是，这些读取的本质是什么，

2272
01:23:22,460 --> 01:23:23,780
0,90 90,180 180,570 570,930 990,1320
is the nature of these

2273
01:23:23,780 --> 01:23:25,160
0,480 480,630 630,870 870,1170 1170,1380
reads,| do we treat them
|我们是否将它们视为只读的，

2274
01:23:25,160 --> 01:23:26,570
0,300 300,540 540,1020 1050,1260 1260,1410
as {read-only -},| so we
|所以我们从离我们最近的 replica 中读取，

2275
01:23:26,570 --> 01:23:27,560
0,210 210,390 390,480 480,870 870,990
read from the replica that

2276
01:23:27,560 --> 01:23:28,400
0,90 90,450 450,510 510,660 660,840
is closest to us,| or
|或者我们执行大多数类型的通信。

2277
01:23:28,400 --> 01:23:30,110
0,120 120,270 270,900 1260,1560 1560,1710
do we actually do like

2278
01:23:30,110 --> 01:23:31,550
0,60 60,840 840,1140 1140,1350 1350,1440
{} majority {} type of

2279
01:23:31,550 --> 01:23:33,770
0,660 1320,1740 1740,1800 1800,1980 1980,2220
communication.| {} You know we
|我们是去找参与者的领导者，

2280
01:23:33,770 --> 01:23:36,110
0,360 360,510 510,810 810,1560 2040,2340
we go actually to go

2281
01:23:36,110 --> 01:23:38,000
0,120 120,210 210,780 780,1350 1650,1890
to the participants leader,| goes
|去找 Paxos 领导者。

2282
01:23:38,000 --> 01:23:39,180
0,90 90,180 180,660 660,1110
to the Paxos leader.|
|

2283
01:23:40,610 --> 01:23:41,420
0,150 150,300 300,480 480,600 600,810
I see, so it goes
我明白了，所以是这样的，

2284
01:23:41,420 --> 01:23:42,920
0,390 420,990 990,1170 1170,1320 1320,1500
the,| okay, so it goes
|好的，就像实验 3 一样。

2285
01:23:42,920 --> 01:23:44,100
0,150 150,240 240,480 480,870
like in lab 3.|
|

2286
01:23:45,160 --> 01:23:47,290
0,480 750,1080 1080,1320 1320,1860 1860,2130
Sorry?| So it's basically, so
抱歉?|所以，这里的读取 x 和实验 3 中的一样，

2287
01:23:47,290 --> 01:23:49,390
0,390 390,720 720,1050 1050,1560 1590,2100
the read x here basically

2288
01:23:49,480 --> 01:23:50,650
0,450 450,630 630,870 870,1050 1050,1170
was the same thing as

2289
01:23:50,650 --> 01:23:51,400
0,90 90,330 330,510 510,660 660,750
in lab 3,| so it
|所以它通过领导者，

2290
01:23:51,400 --> 01:23:52,330
0,180 180,390 390,480 480,810 810,930
goes through the leader,| and
|它会复制到整个。

2291
01:23:52,330 --> 01:23:53,890
0,90 90,420 690,1290 1290,1470 1470,1560
it gets replicated through the

2292
01:23:53,890 --> 01:23:55,630
0,510 540,930 930,1020 1020,1320 1320,1740
whole.| No, it actually does,
|不，它是，没有，

2293
01:23:55,630 --> 01:23:56,830
0,270 270,900 900,1170 1170,1200 1200,1200
{} there's no,| {} I
|我相信没有读取通过 Paxos ，

2294
01:23:57,400 --> 01:23:58,750
0,210 210,360 360,570 570,1050 1050,1350
believe there's no actually {}

2295
01:23:58,750 --> 01:24:00,730
0,240 240,420 420,1200 1200,1560 1590,1980
reads go inside {} running

2296
01:24:00,730 --> 01:24:01,930
0,150 150,630 630,870 870,990 990,1200
through Paxos,| but you know
|通过事务领导者，抱歉， Paxos 领导者，

2297
01:24:01,930 --> 01:24:03,010
0,150 150,300 300,480 480,540 540,1080
and go through the transaction

2298
01:24:03,010 --> 01:24:05,860
0,480 720,1140 1140,1530 1530,2160 2340,2850
leader, {} {oh,sorry} the Paxos

2299
01:24:05,860 --> 01:24:07,630
0,420 420,840 840,930 930,1200 1200,1770
leader| and the Paxos leader
|Paxos 领导者当然知道上一次写的是什么。

2300
01:24:07,630 --> 01:24:08,470
0,270 270,480 480,690 690,780 780,840
of course knows what the

2301
01:24:08,470 --> 01:24:09,420
0,270 270,510 510,870
last write was.|
|

2302
01:24:09,840 --> 01:24:11,070
0,240 240,420 420,570 570,1080 1110,1230
But what if the, for
但是，如果，比如，我们有一些失败，

2303
01:24:11,070 --> 01:24:12,360
0,360 360,450 450,600 600,750 750,1290
example we have some failure,|
|

2304
01:24:12,360 --> 01:24:13,980
0,300 300,450 450,1140 1200,1500 1500,1620
and the leader thinks that
领导者认为它是领导者，

2305
01:24:13,980 --> 01:24:14,790
0,150 150,270 270,540 540,660 660,810
it's the leader,| but {}
|但是在某些分区中，

2306
01:24:14,790 --> 01:24:15,900
0,60 60,240 240,780 780,900 900,1110
in some partition,| and it
|它更新了信息。

2307
01:24:15,900 --> 01:24:17,400
0,240 240,420 420,810 810,1260
actually has updated information.|
|

2308
01:24:18,800 --> 01:24:20,480
0,540 600,930 930,990 990,1590 1590,1680
I don't know exactly,| you
我不太清楚，|他们是怎么处理这种情况的。

2309
01:24:20,480 --> 01:24:21,320
0,150 150,300 300,510 510,720 720,840
know how they deal with

2310
01:24:21,320 --> 01:24:23,120
0,150 150,630 630,630 630,1200 1200,1800
this case.| {I,think}, I think
|我认为租约让这变得不可能。

2311
01:24:23,120 --> 01:24:24,680
0,180 180,600 600,810 810,930 930,1560
their leases make that impossible.|
|

2312
01:24:24,710 --> 01:24:27,710
0,510 810,1950 1980,2340 2340,2550 2550,3000
Yeah, {} so they have
是的，所以他们有，

2313
01:24:27,740 --> 01:24:30,770
0,570 1020,1680 2070,2280 2280,2550 2550,3030
{} the,| so every leader
|所以每个领导者在一段时间内是领导者，

2314
01:24:30,770 --> 01:24:31,820
0,330 330,600 600,750 750,810 810,1050
is leader for a period

2315
01:24:31,820 --> 01:24:32,540
0,90 90,510
of time,|
|

2316
01:24:33,460 --> 01:24:35,530
0,210 210,390 390,750 750,1680 1680,2070
and { -} during that
在那段时间里，

2317
01:24:35,560 --> 01:24:36,970
0,630 630,690 690,960 960,1170 1170,1410
period of time,| no other
|没有其他领导者可以成为领导者。

2318
01:24:36,970 --> 01:24:38,140
0,240 240,420 420,540 540,870
leader can be leader.|
|

2319
01:24:38,560 --> 01:24:40,450
0,420 450,570 570,840 1290,1590 1590,1890
Okay, I see, awesome, thank
好的，我明白了，太棒了，谢谢。

2320
01:24:40,450 --> 01:24:41,480
0,270
you.|
|

2321
01:24:42,360 --> 01:24:43,830
0,390 390,510 510,840 870,1230 1230,1470
Thank you {} remind me.|
谢谢你提醒。|

2322
01:24:44,860 --> 01:24:46,510
0,420 420,810 810,990 990,1080 1080,1650
{} I had a question
我对上一张时间间隔的图有个问题，

2323
01:24:46,510 --> 01:24:48,280
0,270 270,630 660,1110 1110,1650 1650,1770
with the last diagram with

2324
01:24:48,280 --> 01:24:50,420
0,60 60,420 420,990
{} time interval,|
|

2325
01:24:51,160 --> 01:24:52,990
0,810 810,960 960,1110 1110,1470 1470,1830
yeah, I was wondering if
我在想如果读取 T3 ，

2326
01:24:52,990 --> 01:24:55,900
0,360 450,660 660,840 840,1410 1440,2910
like if the read {for,T3},|
|

2327
01:24:56,050 --> 01:24:57,550
0,360 360,600 600,840 840,1080 1080,1500
or let's say the write
或者假设 T2 中的写入，

2328
01:24:57,580 --> 01:25:00,580
0,1140 1530,1920 1920,2460 2460,2640 2640,3000
{at,T2},| time intervals from 1
|时间间隔也从 1 到 12 ，

2329
01:25:00,580 --> 01:25:02,500
0,150 150,600 600,1170 1200,1620 1620,1920
to 12 also,| such that
|这样， T2 的写入发生在 12 ，

2330
01:25:02,500 --> 01:25:05,320
0,150 150,480 480,930 930,1080 1080,2820
the write happens at {12,for,T2},|
|

2331
01:25:05,320 --> 01:25:06,850
0,270 270,540 540,840 840,1140 1140,1530
{and,T3 -} reads also happens
而 T3 读取也发生在 12 ，

2332
01:25:06,850 --> 01:25:07,930
0,150 150,450 450,600 600,1020 1020,1080
at 12,| what happens in
|在这种情况下会发生什么？

2333
01:25:07,930 --> 01:25:08,920
0,180 180,780
that scenario?|
|

2334
01:25:09,710 --> 01:25:12,380
0,660 660,1080 1080,1200 1200,1680 2490,2670
{} Okay, you gotta, like
好的，如果你[说更多]。

2335
01:25:12,380 --> 01:25:13,520
0,450 450,570 570,690 690,870 870,1140
what if you one more.|
|

2336
01:25:13,520 --> 01:25:16,280
0,1470 1470,1710 1710,2190 2190,2430 2430,2760
Yeah, so {for,T2 -} {in,T2
好的，所以对于 T2 ，

2337
01:25:16,280 --> 01:25:17,330
0,270 270,450 450,810 810,930 930,1050
-},| the write right now,
|现在的写入，是从 1 到 10 ，

2338
01:25:17,330 --> 01:25:18,290
0,210 210,360 360,570 570,690 690,960
it's from 1 to 10,

2339
01:25:18,290 --> 01:25:21,470
0,360 720,1530 1770,2790 2790,3000 3000,3180
right,| {then,what,happens -} at like
|然后在 12 会发生什么，

2340
01:25:21,470 --> 01:25:22,430
0,450 450,570 570,690 690,840 840,960
12,| so that it's like
|它与事务 3 一样。

2341
01:25:22,430 --> 01:25:24,230
0,120 120,450 450,810 810,1140 1170,1800
the same as the transaction

2342
01:25:24,230 --> 01:25:26,860
0,450 720,1860 1860,2070 2070,2430
3.| 12 not 2.|
|12 不是 2 。|

2343
01:25:27,160 --> 01:25:28,480
0,150 150,330 330,630 630,930 930,1320
I think 12, sorry, {}
我想的是 12 ，抱歉，我的意思是。

2344
01:25:28,480 --> 01:25:31,600
0,720 720,1350 1380,1920
meaning both, interested.|
|

2345
01:25:31,800 --> 01:25:35,040
0,630 660,1080 1110,1710 1740,2520 2550,3240
{} So if {} the,|
所以如果这个，|

2346
01:25:35,070 --> 01:25:36,510
0,210 210,600 750,1110 1170,1440 1440,1440
{} so {the -} {}
所以，事务 2 会使用 12 作为开始时间，

2347
01:25:38,040 --> 01:25:39,780
0,390 390,720 870,1230 1230,1500 1500,1740
P correct transaction 2 would

2348
01:25:39,780 --> 01:25:42,120
0,240 240,750 750,1290 1320,1920 1950,2340
take 12 as {} start

2349
01:25:42,120 --> 01:25:42,760
0,390
time,|
|

2350
01:25:43,240 --> 01:25:46,900
0,270 270,1560 1680,1920 1920,3450 3450,3660
of the of the read-write
在读写事务的情况下，

2351
01:25:46,900 --> 01:25:49,270
0,630 1110,1440 1440,1620 1620,1830 1830,2370
transaction,| {} it would wait,
|它将等待，直到在时间间隔中出现 12 ，然后提交，

2352
01:25:49,270 --> 01:25:50,080
0,540
correct,

2353
01:25:50,280 --> 01:25:52,470
0,270 270,1080 1140,1560 1560,1830 1830,2190
{} until 12 shows up

2354
01:25:52,500 --> 01:25:54,390
0,330 330,480 480,1200 1230,1800 1800,1890
in the interval, before it

2355
01:25:54,390 --> 01:25:55,260
0,570
commits,|
|

2356
01:25:55,740 --> 01:25:57,120
0,270 270,480 480,840 840,960 960,1380
so true time is somewhere
所以，真实时间在 1 到 12 之间，

2357
01:25:57,120 --> 01:25:58,650
0,330 330,540 540,630 630,1200 1260,1530
between 1 and 12,| and
|至少要等到 13 ，

2358
01:25:58,650 --> 01:26:00,690
0,330 330,630 630,840 840,1260 1260,2040
wait until at least 13,

2359
01:26:01,350 --> 01:26:02,400
0,240 240,330 330,480 480,690 690,1050
right,| and so true time
|真实时间现在肯定已经过了 12 。

2360
01:26:02,400 --> 01:26:04,230
0,150 150,450 450,1080 1140,1470 1470,1830
is now beyond {} 12

2361
01:26:04,230 --> 01:26:06,540
0,90 90,660 1020,1530 1770,2040 2040,2310
for sure.| Yeah.| And now
|是的。|现在我们知道 T3 在 T2 之后开始，

2362
01:26:06,540 --> 01:26:07,770
0,120 120,360 360,540 540,720 720,1230
we know that {T3 -}

2363
01:26:07,980 --> 01:26:10,470
0,840 870,1500 1500,1710 1710,2040 2070,2490
starts after {T2 -}, right,|
|

2364
01:26:11,060 --> 01:26:12,770
0,450 450,810 900,1140 1140,1320 1320,1710
you know it could never
它永远不会返回这个时间间隔，

2365
01:26:12,770 --> 01:26:13,970
0,300 300,450 450,570 570,630 630,1200
got this {interval,back - -},|
|

2366
01:26:13,970 --> 01:26:15,500
0,390 390,480 480,660 660,1080 1080,1530
because the true {time,is} already
因为真正的时间已经过了 13 ，

2367
01:26:15,530 --> 01:26:17,480
0,600 600,1080 1080,1260 1260,1680
definitely pass {13 -},|
|

2368
01:26:18,020 --> 01:26:19,220
0,330 330,390 390,840 840,1050 1050,1200
or you know you know
或者已经过了 12 ，

2369
01:26:19,220 --> 01:26:20,300
0,330 330,780
past 12,|
|

2370
01:26:21,420 --> 01:26:22,980
0,210 210,780 870,1200 1200,1410 1410,1560
so when this guy now
所以当这个现在读取它的时钟时，

2371
01:26:22,980 --> 01:26:25,170
0,600 600,810 810,1410 1650,1860 1860,2190
reads its clock,| we know
|我们知道会有一个时间间隔，

2372
01:26:25,170 --> 01:26:26,040
0,300 300,420 420,480 480,600 600,870
there's going to be some

2373
01:26:26,040 --> 01:26:27,780
0,750 1050,1230 1230,1380 1380,1650 1650,1740
interval,| you know, maybe it
|也许还包括 10 ，

2374
01:26:27,780 --> 01:26:30,360
0,240 240,600 600,1140 1410,2190 2220,2580
still includes 10,| {} but
|但是将包括 14 或 13 ，

2375
01:26:30,360 --> 01:26:31,740
0,120 120,450 450,600 600,720 720,1380
you know and will include

2376
01:26:31,770 --> 01:26:32,820
0,240 240,810
{} 14

2377
01:26:33,330 --> 01:26:34,460
0,240 240,840
or 13,|
|

2378
01:26:35,540 --> 01:26:36,710
0,480 480,630 630,840 840,930 930,1170
and we'll pick the latest
我们会选择 latest 值，

2379
01:26:36,710 --> 01:26:38,660
0,630 690,1110 1260,1440 1440,1680 1680,1950
value, right,| so let's say
|所以我们假设选择 14 ，

2380
01:26:38,660 --> 01:26:39,940
0,210 210,930
pick 14,|
|

2381
01:26:40,540 --> 01:26:41,680
0,360 360,630 630,780 780,930 930,1140
and so it will do
所以它会在 14 做时间戳。

2382
01:26:41,680 --> 01:26:43,600
0,240 240,660 690,1230 1230,1380 1380,1920
{timestamp -} actually at 14.|
|

2383
01:26:46,230 --> 01:26:47,700
0,270 270,480 480,600 600,1080 1080,1470
{Actually -}, so basically like
所以，这种情况就不会发生，

2384
01:26:47,700 --> 01:26:49,650
0,300 300,960 990,1380 1380,1500 1500,1950
that scenario wouldn't have happened,|
|

2385
01:26:49,650 --> 01:26:51,750
0,570 660,960 960,1320 1320,1860 1860,2100
because the time interval thing
因为时间间隔可以保证最早的和最晚的。

2386
01:26:51,750 --> 01:26:53,370
0,180 180,420 420,1080 1080,1230 1230,1620
would have guaranteed the earliest

2387
01:26:53,370 --> 01:26:54,930
0,90 90,600 780,1170 1170,1440 1440,1560
and latest.| Yes, and that
|是的，这是 T3 肯定是在 T2 之后开始的情况，

2388
01:26:54,930 --> 01:26:55,620
0,150 150,240 240,450 450,570 570,690
is the case that the

2389
01:26:55,620 --> 01:26:57,180
0,210 210,630 630,1020 1020,1350 1350,1560
T3 definitely started after {T2

2390
01:26:57,180 --> 01:26:57,720
0,270
-},|
|

2391
01:26:59,340 --> 01:27:00,990
0,390 390,1050 1050,1230 1230,1470 1470,1650
by definition,| that's the way
根据定义，|这就是我们建立示例的方式。

2392
01:27:00,990 --> 01:27:01,980
0,120 120,270 270,360 360,450 450,990
we set up the example.|
|

2393
01:27:02,980 --> 01:27:04,000
0,150 150,300 300,630 630,840 840,1020
And then also then like
然后如果，

2394
01:27:04,000 --> 01:27:06,040
0,390 720,1080 1170,1650 1650,1860 1860,2040
if if,| instead like the
|读取发生在提交的同一时间，

2395
01:27:06,040 --> 01:27:07,810
0,480 750,930 930,1350 1350,1680 1680,1770
read was happening around the

2396
01:27:07,810 --> 01:27:08,950
0,180 180,390 390,540 540,990 990,1140
same time as committed| not
|不一定是在严格的之后，

2397
01:27:08,950 --> 01:27:10,660
0,540 540,990 990,1410 1410,1650 1650,1710
necessarily strictly after,| as in
|在这种情况下，有什么保证，

2398
01:27:10,660 --> 01:27:12,760
0,210 210,540 540,810 990,1560 1950,2100
this case, like what is

2399
01:27:12,760 --> 01:27:14,080
0,210 210,390 390,930 930,1080 1080,1320
there any guaranteed on that,|
|

2400
01:27:14,440 --> 01:27:16,810
0,240 240,390 390,450 450,540 540,2370
like does it have {}.|
比如它有没有。|

2401
01:27:17,080 --> 01:27:18,580
0,600 600,990 990,1140 1140,1260 1260,1500
Great question,| so {} remember
好问题，|所以记得线性一致性的定义，

2402
01:27:18,580 --> 01:27:19,510
0,120 120,180 180,600 600,690 690,930
what the definition of {linearizability

2403
01:27:19,510 --> 01:27:21,460
0,600 600,870 870,1410 1470,1740 1740,1950
-}, right,| if {T2 -}
|如果 T2 和 T3 几乎同时运行，

2404
01:27:21,460 --> 01:27:22,870
0,120 120,300 300,540 540,900 900,1410
and {T3 -} basically run

2405
01:27:22,870 --> 01:27:25,570
0,330 330,1020 1020,1680 1680,2100 2100,2700
roughly concurrently,| {like,run} truly concurrent,|
|真的同时运行，|

2406
01:27:26,500 --> 01:27:27,910
0,600 630,780 780,960 960,1350 1350,1410
then it doesn't matter,| you
也没有关系，|T3 可以在 T2 之前或之后。

2407
01:27:27,910 --> 01:27:28,900
0,60 60,420 420,540 540,750 750,990
know T3 can go before

2408
01:27:28,900 --> 01:27:30,480
0,420 420,720 720,990 990,1500
{T2 -} or after.|
|

2409
01:27:32,200 --> 01:27:33,340
0,750
Okay.|
好的。|

2410
01:27:33,850 --> 01:27:35,140
0,150 150,330 330,480 480,720 720,1290
But then what about {serializability
那么可串行化方面呢，

2411
01:27:35,140 --> 01:27:37,630
0,480 480,990 1260,1530 1530,1800 1800,2490
-} aspects,| if they execute
|如果它们再次执行，

2412
01:27:37,630 --> 01:27:38,680
0,390 390,600 600,690 690,900 900,1050
again,| like it might not
|可能不一定是相同的顺序。

2413
01:27:38,680 --> 01:27:39,940
0,600 600,720 720,810 810,900 900,1260
necessarily be in the same

2414
01:27:39,940 --> 01:27:41,200
0,540
order.|
|

2415
01:27:41,880 --> 01:27:43,800
0,480 630,990 990,1350 1350,1710 1710,1920
{} The order executed some
以一个整体顺序执行，

2416
01:27:43,800 --> 01:27:45,270
0,270 270,660 660,990 990,1260 1260,1470
total order,| and {T3,either -}
|T3 或者在 T2 之前或者在 T2 之后，

2417
01:27:45,270 --> 01:27:47,310
0,210 360,450 450,750 750,1770 1770,2040
go to before T2 or

2418
01:27:47,310 --> 01:27:49,980
0,360 360,870 870,1320 1320,1530 2010,2670
after {T2 - -},| but
|但这两种顺序都没问题，

2419
01:27:50,070 --> 01:27:51,270
0,270 270,510 510,630 630,1020 1020,1200
either order is fine,| which
|两者都是可串行化或线性一致性所允许的，

2420
01:27:51,270 --> 01:27:52,710
0,480 480,570 570,900 900,990 990,1440
both are allowed by {serializability

2421
01:27:52,710 --> 01:27:54,930
0,390 390,510 510,1500 1620,2070 2070,2220
-} or linearizability,| because the
|因为执行是真正同时进行的，

2422
01:27:54,930 --> 01:27:56,540
0,480 480,570 570,870 870,1350
execution is truly concurrent,|
|

2423
01:27:57,030 --> 01:28:00,960
0,1230 1230,1770 2220,3150 3150,3240 3240,3930
{T3 -} starts {before,T2 -}
T3 在 T2 提交之前开始。

2424
01:28:00,960 --> 01:28:01,780
0,510
committed.|
|

2425
01:28:02,200 --> 01:28:03,700
0,630 660,780 780,1110 1110,1230 1230,1500
Gotcha, and then for the
明白了，然后对于 T3 来说，

2426
01:28:03,760 --> 01:28:04,840
0,240 240,390 390,690 690,930 930,1080
{T3 -},| like the if
|如果提交和读取同时发生，

2427
01:28:04,840 --> 01:28:05,860
0,90 90,390 390,510 510,690 690,1020
the commit and read happens

2428
01:28:05,860 --> 01:28:07,000
0,90 90,180 180,360 360,750 810,1140
at the same time,| the
|T3 会读到什么，

2429
01:28:07,000 --> 01:28:07,990
0,270 270,480 480,660 660,870 870,990
{} what {T3 -} is

2430
01:28:07,990 --> 01:28:09,430
0,480 480,750 750,1020 1050,1320 1320,1440
actually gonna read,| just gonna
|将取决于 replica 是否读取到那个提交。

2431
01:28:09,430 --> 01:28:11,110
0,390 390,690 720,1050 1050,1170 1170,1680
depend on if the replica

2432
01:28:11,110 --> 01:28:12,520
0,270 270,570 570,750 750,1050 1050,1410
is reading from has that

2433
01:28:12,550 --> 01:28:14,680
0,420
commit.|
|

2434
01:28:14,980 --> 01:28:16,030
0,90 90,540 540,630 630,720 720,1050
Yeah.| Thank you so much.|
是的。|非常感谢。|

2435
01:28:16,360 --> 01:28:18,080
0,600 720,1410
{You're,welcome\,,good} questions.|
不用谢，好问题。|

2436
01:28:19,240 --> 01:28:21,040
0,390 390,570 570,750 750,1020 1020,1800
{} I had a question
我有一个问题，

2437
01:28:21,070 --> 01:28:23,600
0,660 1290,2010
about,| like
|如果我在这张图片上看到，

2438
01:28:23,990 --> 01:28:25,640
0,690 720,960 960,1050 1050,1260 1260,1650
if, if I saw this

2439
01:28:25,640 --> 01:28:28,010
0,180 180,330 330,960 1020,1680 1860,2370
in this picture,| and they
|而当它试图提交 12 的时候，并不在那里，

2440
01:28:28,040 --> 01:28:29,180
0,240 240,330 330,600 600,720 720,1140
when it tries to commit

2441
01:28:29,180 --> 01:28:30,200
0,300 300,420 420,600 600,900 900,1020
12 is not there,| it's
|它会重试并再次等待。

2442
01:28:30,200 --> 01:28:32,060
0,210 210,720 960,1500 1500,1650 1650,1860
just gonna retry and wait

2443
01:28:32,060 --> 01:28:35,030
0,870 990,2370 2370,2640 2640,2790 2790,2970
again.| Okay.| It's just keep
|好的。|它继续读取时钟直到获得时间间隔，

2444
01:28:35,030 --> 01:28:37,280
0,270 270,330 330,810 840,1650 2100,2250
reading the clock until it

2445
01:28:37,280 --> 01:28:38,600
0,180 180,270 270,630 630,960 960,1320
gets {interval -} back,| where
|earliest 已经超过了它的时间戳。

2446
01:28:38,600 --> 01:28:40,610
0,300 300,930 930,1080 1080,1740 1740,2010
the earliest is past {}

2447
01:28:40,610 --> 01:28:43,420
0,660 960,1770 2010,2250 2250,2670
its {} {timestamp -}.|
|

2448
01:28:44,640 --> 01:28:47,220
0,690 720,1620 1710,1950 1950,2190 2190,2580
Okay, {} I also have
好的，我还要确认一下，

2449
01:28:47,460 --> 01:28:48,750
0,360 360,540 540,990 990,1200 1200,1290
just {} clear just to

2450
01:28:48,750 --> 01:28:50,790
0,180 180,690 1080,1440 1440,1920 1920,2040
make sure,| the guarantee that
|它提供的保证是，

2451
01:28:50,790 --> 01:28:53,010
0,150 150,720 720,840 840,1230 1560,2220
it provides is that,| if
|如果在时间戳 x ，

2452
01:28:53,910 --> 01:28:56,070
0,270 270,810 810,1260 1410,1710 1710,2160
if [] in {timestamp -}

2453
01:28:56,070 --> 01:28:57,140
0,690
x,|
|

2454
01:28:57,740 --> 01:28:59,240
0,240 240,330 330,480 480,990 990,1500
and by the time where
当 x 在 now 时间间隔之前，

2455
01:28:59,240 --> 01:29:02,150
0,240 240,330 330,690 750,1980 2190,2910
x is like before the

2456
01:29:02,180 --> 01:29:05,560
0,360 360,1140 2370,3210
now interval,| this
|这个机器或 Paxos 组将看到一切正常，

2457
01:29:05,770 --> 01:29:07,600
0,540 540,960 960,1410 1410,1710 1710,1830
machine {or,this,Paxos -} group will

2458
01:29:07,600 --> 01:29:08,300
0,420
have

2459
01:29:08,550 --> 01:29:11,490
0,960 1350,2040 2040,2580 2580,2640 2640,2940
seen everything worked,| I guess
|我想机器已经看到了发生的一切，

2460
01:29:11,490 --> 01:29:13,290
0,300 300,420 420,630 630,1200 1350,1800
machine will have seen everything

2461
01:29:13,290 --> 01:29:14,600
0,150 150,360 360,990
that has happened,|
|

2462
01:29:15,740 --> 01:29:18,420
0,900 1020,1320 1320,1830 1830,2340
at like before x,
在 x 之前，对吗？

2463
01:29:18,880 --> 01:29:19,860
0,90 90,270 270,690
is that right?|
|

2464
01:29:20,050 --> 01:29:21,040
0,510 510,630 630,780 780,960 960,990
Yeah, I think more or
是的，我想或多或少是这样的，

2465
01:29:21,040 --> 01:29:22,210
0,180 180,600 600,780 780,990 990,1170
less yes,| I've not heard
|我没听说过，在你提问之前，

2466
01:29:22,210 --> 01:29:23,620
0,120 120,390 390,990 990,1230 1230,1410
of since you're what you're

2467
01:29:23,620 --> 01:29:25,150
0,450 450,690 990,1110 1110,1320 1320,1530
asking,| but you know we
|但我们获得时间间隔，

2468
01:29:25,150 --> 01:29:26,410
0,450 450,570 570,630 630,960 960,1260
we get an interval back,|
|

2469
01:29:26,410 --> 01:29:27,580
0,330 330,420 420,780 780,960 960,1170
what we know is that,|
我们所知道的是，|

2470
01:29:27,580 --> 01:29:28,750
0,120 120,330 330,750 750,870 870,1170
the true time is somewhere
真正的时间是在这个时间间隔的某个地方，

2471
01:29:28,750 --> 01:29:29,740
0,90 90,240 240,750
in this interval,|
|

2472
01:29:30,600 --> 01:29:31,960
0,120 120,360 360,570 570,1170
so here's true time,|
所以这是真正的时间，|

2473
01:29:34,610 --> 01:29:35,570
0,210 210,360 360,570 570,690 690,960
and so when we start
所以当我们开始准备的时候，

2474
01:29:35,570 --> 01:29:38,660
0,90 90,900 1020,1920 1920,2160 2160,3090
this prepare,| {} you know
|真正的时间没有超过 12 ，

2475
01:29:38,660 --> 01:29:40,070
0,120 120,450 450,630 630,870 870,1410
true {time,is} not past 12,|
|

2476
01:29:40,760 --> 01:29:42,380
0,750 780,930 930,1080 1080,1380 1380,1620
{} but it's somewhere between
但它在 1 到 12 之间，

2477
01:29:42,380 --> 01:29:43,700
0,180 180,300 300,780 1020,1200 1200,1320
1 and 12,| and so
|所以当我们提交的时候，

2478
01:29:43,700 --> 01:29:45,080
0,210 210,300 300,480 480,1020 1050,1380
when we do commit,| we
|我们必须确保，

2479
01:29:45,080 --> 01:29:45,980
0,180 180,360 360,660 660,840 840,900
gotta make sure that,| the
|提交确实发生在真实时间之后，

2480
01:29:45,980 --> 01:29:47,960
0,270 270,540 540,960 960,1230 1230,1980
commit actually happens really after

2481
01:29:47,960 --> 01:29:48,820
0,180 180,570
true time,|
|

2482
01:29:49,160 --> 01:29:50,150
0,330 330,450 450,570 570,720 720,990
and so we're gonna wait
所以我们要再等一段时间，

2483
01:29:50,150 --> 01:29:51,650
0,60 60,270 270,690 690,780 780,1500
a little bit,| you know,
|所以我们知道我们大于 12 ，

2484
01:29:51,650 --> 01:29:52,790
0,330 360,510 510,780 780,900 900,1140
so we know we got

2485
01:29:52,790 --> 01:29:54,080
0,210 210,780 930,1110 1110,1170 1170,1290
{big,than} 12,| and we're going
|我们等到时钟给出一个时间间隔，

2486
01:29:54,080 --> 01:29:55,490
0,90 90,420 420,960 960,1230 1230,1410
to wait until actually our

2487
01:29:55,490 --> 01:29:58,100
0,540 720,1020 1020,1140 1140,1770 1920,2610
clock gives an interval,| where
|真实时间肯定过了 12 。

2488
01:29:58,100 --> 01:29:59,570
0,210 210,540 540,720 720,1140 1140,1470
true time is definitely past

2489
01:29:59,570 --> 01:30:00,240
0,540
12.|
|

2490
01:30:01,570 --> 01:30:02,540
0,540

2491
01:30:03,040 --> 01:30:03,880
0,270 270,510 510,570 570,720 720,840
I think I think what
我想我想问的是，

2492
01:30:03,880 --> 01:30:05,530
0,30 30,210 210,630 630,1050 1050,1650
I was asking was {more,like},|
|

2493
01:30:05,620 --> 01:30:06,910
0,180 180,330 330,600 600,1110 1140,1290
if you pick 12,| and
如果你选择 12 ，|然后你的时间间隔返回了 13 到 20 ，

2494
01:30:06,910 --> 01:30:09,130
0,570 750,1020 1020,1590 1590,1800 1800,2220
then your interval is returned

2495
01:30:09,130 --> 01:30:11,020
0,90 90,390 540,1080 1080,1230 1230,1890
to be 13 to 20,|
|

2496
01:30:11,080 --> 01:30:12,370
0,270 270,600 720,840 840,990 990,1290
{ -} do you know
你知道任何，

2497
01:30:12,370 --> 01:30:14,200
0,390 660,1140 1140,1590
that anything that,|
|

2498
01:30:14,800 --> 01:30:16,690
0,420 420,690 720,1050 1050,1350 1350,1890
{} like with {timestamp -}
例如小于或等于 12 的时间戳，

2499
01:30:17,050 --> 01:30:18,190
0,420 420,630 630,720 720,990 990,1140
less than or equal to

2500
01:30:18,190 --> 01:30:20,500
0,630 870,1230 1230,1320 1320,1860 1860,2310
12,| that the changes for
|对这些事务的更改，

2501
01:30:20,530 --> 01:30:22,600
0,210 210,900 900,1320 1680,1950 1950,2070
those transactions,| that you're gonna
|你就能看到它们了。

2502
01:30:22,600 --> 01:30:23,740
0,90 90,360 360,480 480,720 720,1140
be able to see them.|
|

2503
01:30:23,830 --> 01:30:24,700
0,600
Yes.|
是的。|

2504
01:30:25,250 --> 01:30:26,080
0,510
Okay.|
好的。|

2505
01:30:27,140 --> 01:30:28,360
0,240 240,330 330,480 480,990
Okay, that makes sense,
好的，理解了，谢谢。

2506
01:30:29,070 --> 01:30:30,700
0,390 390,990
thank you.|
|

2507
01:30:32,710 --> 01:30:34,060
0,390 390,540 540,720 720,930 930,1350
So I don't totally understand
所以我不完全理解提交等待的是什么，

2508
01:30:34,060 --> 01:30:35,500
0,330 330,450 450,930 930,1080 1080,1440
what the point of commit

2509
01:30:35,500 --> 01:30:38,200
0,270 270,690 690,1200 1590,2130 2490,2700
wait actually is,| because it
|因为看起来是，

2510
01:30:38,200 --> 01:30:39,940
0,360 360,810 840,1290 1320,1560 1560,1740
seems like,| {} commit wait
|提交等待发生在你选择了时间戳之后，

2511
01:30:39,940 --> 01:30:40,870
0,90 90,330 330,630 630,750 750,930
will happen after you've already

2512
01:30:40,870 --> 01:30:42,400
0,600 600,780 780,1080 1080,1410 1410,1530
selected the {timestamp -}| for
|对于你感兴趣的事务，

2513
01:30:42,400 --> 01:30:44,200
0,60 60,720 720,930 990,1350 1350,1800
the transaction that you're interested

2514
01:30:44,290 --> 01:30:45,970
0,390 720,900 900,960 960,1230 1230,1680
in,| and you simply delay
|你只需推迟真实时间，

2515
01:30:45,970 --> 01:30:47,860
0,180 180,810 960,1590 1590,1830 1830,1890
the actual absolute time| at
|这让你提交只是为了确保。

2516
01:30:47,860 --> 01:30:48,610
0,210 210,390 390,510 510,600 600,750
which the thing will let

2517
01:30:48,610 --> 01:30:49,570
0,60 60,180 180,600 600,870 870,960
you get committed just to

2518
01:30:49,570 --> 01:30:50,540
0,240 240,480 480,780
make sure that.

2519
01:30:50,760 --> 01:30:52,830
0,510 510,840 840,1170 1350,1980 1980,2070
{ -}.| {} {No\,,but} the
|不，但是提交时间，你已经开始更新数据库。

2520
01:30:52,830 --> 01:30:54,030
0,240 240,480 480,600 600,840 840,1200
commit time, you really start

2521
01:30:54,030 --> 01:30:55,440
0,390 390,480 480,1170
updating the database.|
|

2522
01:30:56,500 --> 01:30:58,930
0,720 720,1380 1380,1680 1680,2040 2040,2430
Aha.| And so at {commit,time},
嗯。|所以在提交的时候，你必须提交，

2523
01:30:58,930 --> 01:30:59,770
0,150 150,330 330,390 390,720 720,840
you have to commit,| you
|比如 T3 不会运行直到 C 之后。

2524
01:30:59,770 --> 01:31:01,690
0,600 780,1050 1050,1140 1140,1380 1380,1920
return like {} {T3 -}

2525
01:31:01,720 --> 01:31:02,980
0,330 330,720 720,870 870,930 930,1260
didn't run {until -} after

2526
01:31:02,980 --> 01:31:03,940
0,120 120,240 240,690
of the C.|
|

2527
01:31:04,680 --> 01:31:07,710
0,780 1260,1830 1830,2310 2310,2820 2820,3030
Right.| {Because,that,was} our definition,| like
是的。|因为这是我们的定义，|T3 在 T2 提交之后开始。

2528
01:31:07,710 --> 01:31:09,090
0,180 180,360 360,720 720,1170 1170,1380
{T3 -} started after {T2

2529
01:31:09,090 --> 01:31:09,980
0,150 150,600
-} committed.|
|

2530
01:31:10,250 --> 01:31:11,990
0,330 330,540 540,1050 1290,1560 1560,1740
Right, right right,| but like
是的，|如果不这样，会发生什么，

2531
01:31:11,990 --> 01:31:12,890
0,300 300,420 420,660 660,720 720,900
what would happen if you

2532
01:31:12,890 --> 01:31:14,000
0,360 360,570 570,930 930,990 990,1110
didn't,| like what do you
|你会失去什么，

2533
01:31:14,000 --> 01:31:15,950
0,240 240,330 330,420 420,960 1260,1950
lose,| if you don't have.|
|如果你没有。|

2534
01:31:16,250 --> 01:31:17,420
0,180 180,360 360,510 510,750 750,1170
{Then,T3 -} would run concurrently
那么， T3 将与 T2 同时运行。

2535
01:31:17,420 --> 01:31:18,400
0,150 150,330 330,630
with {T2 -}.|
|

2536
01:31:20,980 --> 01:31:23,710
0,630 660,1080 1080,1650 1950,2340 2340,2730
{Okay\,,hold,on}.| I see.| {} I'm
好的，稍等。|我明白了。|我不确定你想探索哪种场景，

2537
01:31:23,710 --> 01:31:24,730
0,150 150,270 270,570 570,930 930,1020
not sure which scenario you

2538
01:31:24,730 --> 01:31:26,320
0,150 150,210 210,570 570,780 1080,1590
want to explore,| but, {}
|但是，如果我们允许 T3 在 C 之前开始，

2539
01:31:26,320 --> 01:31:28,150
0,810 840,960 960,1170 1170,1380 1380,1830
if you know we allow

2540
01:31:28,150 --> 01:31:29,980
0,450 450,570 570,840 840,1260 1260,1830
T3 to start before C,|
|

2541
01:31:30,470 --> 01:31:31,700
0,690 720,870 870,990 990,1110 1110,1230
then you know we have
那么我们的故事完全不同了，

2542
01:31:31,700 --> 01:31:32,960
0,90 90,450 450,660 660,1020 1020,1260
{} completely different story, correct,|
|

2543
01:31:32,960 --> 01:31:34,340
0,210 210,540 540,750 750,840 840,1380
because there's nothing to discuss,|
因为没什么好讨论的，|

2544
01:31:34,370 --> 01:31:36,080
0,600 600,810 810,1050 1050,1290 1290,1710
because {T3 -} runs concurrently
因为 T3 与 T2 同时运行，

2545
01:31:36,080 --> 01:31:37,700
0,510 510,630 630,990 990,1440 1440,1620
T2,| and {it,could} observe to
|它可以观察到 T 或不会，然后结束。

2546
01:31:37,700 --> 01:31:39,410
0,210 210,330 330,690 690,930 930,1710
T or not, then over.|
|

2547
01:31:39,800 --> 01:31:40,660
0,600
Okay,
好的，我明白了。

2548
01:31:42,020 --> 01:31:43,020
0,300 300,720
I see.|
|

2549
01:31:43,620 --> 01:31:44,850
0,450 450,600 600,690 690,930 930,1230
And so the {timestamp -}
所以 C 的时间戳，

2550
01:31:44,850 --> 01:31:46,320
0,150 150,690 690,930 930,1110 1110,1470
for C,| we are waiting
|我们在等待那些，

2551
01:31:46,320 --> 01:31:47,940
0,360 360,720 720,960 960,1410 1410,1620
those,| {} we pass true
|我们传递真实时间，

2552
01:31:47,940 --> 01:31:48,800
0,540
time|
|

2553
01:31:49,060 --> 01:31:51,160
0,840 840,1320 1320,1440 1440,1800 1800,2100
{} of you know {}
我们得到准备好的编号的开始，

2554
01:31:51,160 --> 01:31:53,110
0,420 420,1110 1110,1350 1350,1500 1500,1950
the starting of the prepared

2555
01:31:53,110 --> 01:31:54,100
0,210 210,330 330,420 420,570 570,990
number that we get back,|
|

2556
01:31:54,190 --> 01:31:55,510
0,270 270,390 390,690 690,930 930,1320
so we know that the
所以我们知道真实时间已经过去了。

2557
01:31:55,750 --> 01:31:57,460
0,180 180,510 510,840 840,1080 1080,1710
true time really has passed.|
|

2558
01:31:58,270 --> 01:32:01,540
0,510 510,870 870,960 960,3060 3060,3270
And this is.| {T3 -}
这是。|T3 永远不会选择一个真实时间，

2559
01:32:01,540 --> 01:32:02,710
0,270 270,570 570,720 720,810 810,1170
could never pick a time

2560
01:32:02,710 --> 01:32:04,570
0,840 840,990 990,1290 1290,1440 1440,1860
{} true time,| that actually
|在 T2 提交之前。

2561
01:32:04,570 --> 01:32:07,000
0,180 180,510 540,930 930,1260 1350,2430
would be would be before

2562
01:32:07,090 --> 01:32:08,860
0,210 210,690 690,1110 1110,1500 1500,1770
{T2 -} {} committed on.|
|

2563
01:32:11,610 --> 01:32:12,840
0,270 270,930
I see,
我明白了，好的。

2564
01:32:14,360 --> 01:32:17,060
0,240 240,600 630,1170 1530,2160 2370,2700
I see, okay.| {} I
|我想像是一切都已经是版本了，

2565
01:32:17,060 --> 01:32:18,260
0,150 150,240 240,450 450,720 900,1200
guess it seemed like everything

2566
01:32:18,260 --> 01:32:19,940
0,120 120,360 360,930 930,1380 1530,1680
was already version,| that if
|如果你修改数据，

2567
01:32:19,940 --> 01:32:22,100
0,210 870,1500 1500,1620 1620,1830 1830,2160
you modify the data,| you
|你修改了之前的数据，这是可以的，

2568
01:32:22,100 --> 01:32:23,720
0,390 390,750 750,1080 1080,1320 1320,1620
physically modified data [early], like

2569
01:32:24,050 --> 01:32:25,010
0,150 150,270 270,450 450,780 780,960
that would be okay,| because
|因为每样东西都有时间戳，

2570
01:32:25,010 --> 01:32:26,990
0,270 270,1170 1440,1590 1590,1800 1800,1980
everything has a {timestamp -}

2571
01:32:26,990 --> 01:32:27,770
0,390 390,480 480,570 570,690 690,780
attached to it,| so no
|所以没有，

2572
01:32:27,770 --> 01:32:29,720
0,180 180,540 870,1170 1410,1770 1770,1950
one would,| {} from far
|从很远的地方看，这似乎是不做错事，

2573
01:32:29,720 --> 01:32:30,650
0,210 210,300 300,420 420,570 570,930
away, it seemed like no

2574
01:32:30,650 --> 01:32:32,720
0,150 150,240 240,660 660,1350 1680,2070
do the wrong thing,| like
|比如查看他们定义的外部一致性，

2575
01:32:32,720 --> 01:32:34,100
0,630 690,1020 1020,1110 1110,1290 1290,1380
looking more at what they

2576
01:32:34,100 --> 01:32:37,040
0,240 240,690 690,1680 1680,2040 2040,2940
actually define as external consistency,|
|

2577
01:32:37,250 --> 01:32:38,510
0,330 330,570 570,690 690,1020 1020,1260
I don't really understand how
我不明白它和线性一致性有什么相似之处，

2578
01:32:38,510 --> 01:32:39,980
0,270 300,750 780,1140 1140,1230 1230,1470
it is similar to {linearizability

2579
01:32:39,980 --> 01:32:40,880
0,270 270,420 420,480 480,630 630,900
-},| because it just says
|因为它只是说，

2580
01:32:40,880 --> 01:32:41,380
0,270
that,|
|

2581
01:32:41,550 --> 01:32:43,620
0,240 240,300 300,1170 1170,1620 1620,2070
if a transaction actually commits
如果一个事务在另一个事务开始之前提交，

2582
01:32:43,620 --> 01:32:45,480
0,270 270,480 480,600 600,1290 1470,1860
before another one starts,| then
|然后第一个会有比后一个较小的时间戳，

2583
01:32:45,480 --> 01:32:46,590
0,210 210,540 540,780 780,990 990,1110
they'll have, the first will

2584
01:32:46,590 --> 01:32:47,850
0,90 90,180 180,570 570,870 870,1260
have a smaller {timestamp -}

2585
01:32:47,850 --> 01:32:49,200
0,90 90,360 360,780 930,1110 1110,1350
than latter one,| is also
|这在某种程度上也隐含了，

2586
01:32:49,200 --> 01:32:50,700
0,150 150,510 540,1020 1020,1080 1080,1500
sort of implicit in that,|
|

2587
01:32:50,970 --> 01:32:52,950
0,390 390,1050 1050,1740 1740,1830 1830,1980
{} transactions execute in the
事务按其时间戳顺序执行。

2588
01:32:52,950 --> 01:32:54,270
0,360 360,450 450,570 570,840 840,1320
order of their {timestamps -}

2589
01:32:54,270 --> 01:32:57,210
0,300 300,660 660,1320 1320,1500 1500,2940
for sure.| Yeah, maybe {my,short}
|是的，也许我的短暂[]没那么好，

2590
01:32:57,210 --> 01:32:58,590
0,450 450,570 570,720 720,870 870,1380
[] was not so brilliant,|
|

2591
01:32:58,950 --> 01:33:01,920
0,990 1020,1200 1200,1590 1590,2220 2460,2970
{} but, yeah, absolutely, {}|
但是，是的，当然，|

2592
01:33:01,920 --> 01:33:03,780
0,360 360,780 780,1290 1290,1470 1470,1860
the real requirement is that,|
真正的要求是，|

2593
01:33:03,990 --> 01:33:05,400
0,450 450,540 540,1260
if a transaction
如果事务在之后开始，

2594
01:33:05,810 --> 01:33:08,300
0,570 780,1500 1500,1980 1980,2190 2220,2490
{} start after,| if {T2
|如果 T2 在 T1 提交之后开始，

2595
01:33:08,300 --> 01:33:10,280
0,240 240,720 720,1020 1020,1620 1620,1980
-} starts after T1 committed,|
|

2596
01:33:10,820 --> 01:33:12,830
0,600 600,930 930,1620 1620,1890 1890,2010
T2 must observe all the
T2 必须观察到 T1 的所有写入。

2597
01:33:12,830 --> 01:33:15,170
0,390 390,870 870,1050 1050,1500 1860,2340
writes from {T1 -}.| Aha,
|嗯，是的。

2598
01:33:15,200 --> 01:33:16,820
0,300 330,840 930,1380
right, right, right.|
|

2599
01:33:19,250 --> 01:33:20,810
0,300 300,510 510,630 630,930 930,1560
I see,| I guess the,
我明白了，|我想时间，

2600
01:33:20,840 --> 01:33:21,920
0,90 90,270 270,390 390,720 720,1080
I guess the time,| knowing
|知道 T2 的时间戳大于 T1 会告诉你，

2601
01:33:21,920 --> 01:33:22,820
0,90 90,180 180,480 480,720 720,900
that the {timestamp -} of

2602
01:33:22,820 --> 01:33:24,290
0,480 480,780 780,900 900,1050 1050,1470
T2 larger than {t1 -}

2603
01:33:24,500 --> 01:33:25,850
0,570 600,960 960,1110 1110,1200 1200,1350
will tell you,| that you're
|你将会观察到 T1 的所有东西。

2604
01:33:25,850 --> 01:33:26,930
0,150 150,210 210,300 300,660 660,1080
going to have observed everything

2605
01:33:27,290 --> 01:33:29,720
0,150 150,780 960,1410 1980,2250 2250,2430
{T1 -}.| {Okay\,,I,see}, makes sense.|
|好的，我明白了，理解了。|

2606
01:33:29,720 --> 01:33:30,620
0,720
Yeah.|
好的。|

2607
01:33:30,940 --> 01:33:32,780
0,240 240,690 1020,1260 1260,1560
Okay, thanks.| You're welcome.|
好的，谢谢。|不用谢。|

2608
01:33:40,240 --> 01:33:41,560
0,240 240,390 390,1050
Any other questions,
还有没有其他问题，如果还有人的话。

2609
01:33:42,310 --> 01:33:43,880
0,300 300,600 600,900 900,1260
{if,there's} still anybody there.|
|

2610
01:33:46,820 --> 01:33:48,350
0,300 300,420 420,780 780,1110 1110,1530
{I,had} a question about {}
我对 4.2.3 部分有一个问题，

2611
01:33:48,590 --> 01:33:50,140
0,660 660,1230
part {}

2612
01:33:50,390 --> 01:33:52,010
0,360 360,630 630,810 810,1110 1110,1620
{4.2.3 - - - -},|
|

2613
01:33:52,430 --> 01:33:54,710
0,420 420,690 690,1140 1140,1500 1500,2280
section of {schema-change -} transactions.|
事务模式更改一节。|

2614
01:33:54,710 --> 01:33:56,720
0,1350 1350,1440 1440,1680 1680,1860 1860,2010
Yeah, {I,didn't} talk about it
是的，我没有讲这个。

2615
01:33:56,720 --> 01:33:58,970
0,360 1350,1500 1500,1620 1620,1860 1860,2250
{at,all}.| I was just curious
|我只是好奇，

2616
01:33:58,970 --> 01:34:00,800
0,360 360,690 720,960 960,1500 1500,1830
about like,| because essentially there
|因为，他们谈论的预测提交的时间。

2617
01:34:00,800 --> 01:34:02,120
0,150 150,390 390,600 600,840 840,1320
they talk about like predicting

2618
01:34:02,120 --> 01:34:03,140
0,120 120,450 450,540 540,630 630,1020
the time of the commit.|
|

2619
01:34:04,050 --> 01:34:05,240
0,870

2620
01:34:05,490 --> 01:34:06,930
0,390 390,660 660,780 780,1230 1230,1440
Well, you may be,| let
好的，可能是，|让我想想,

2621
01:34:06,930 --> 01:34:08,130
0,240 240,570 570,870 870,1110 1110,1200
me see,| I'll tell you
|我会告诉你我怎么想的，

2622
01:34:08,130 --> 01:34:09,150
0,270 270,510 510,630 630,780 780,1020
whatever way I think about

2623
01:34:09,150 --> 01:34:10,110
0,210 390,540 540,720 720,870 870,960
it,| and then you can
|然后你可以告诉我困惑在哪里，

2624
01:34:10,110 --> 01:34:11,100
0,210 210,480 480,780 780,870 870,990
say me, you can tell

2625
01:34:11,100 --> 01:34:12,780
0,120 120,360 510,1260 1260,1590 1590,1680
me where where where the

2626
01:34:12,780 --> 01:34:15,240
0,390 390,720 990,1560 1650,2040 2040,2460
confusion is,| so {} {schema-change
|所以模式更改意味着，

2627
01:34:15,240 --> 01:34:16,650
0,300 300,510 510,630 630,930 930,1410
-} correct that means,| basically
|向表中添加列或删除表中的列，

2628
01:34:16,650 --> 01:34:17,640
0,240 240,300 300,750 750,900 900,990
adding {} column to a

2629
01:34:17,640 --> 01:34:19,290
0,690 900,1050 1050,1320 1320,1350 1350,1650
table or delete a column

2630
01:34:19,290 --> 01:34:20,490
0,120 120,180 180,720 720,960 960,1200
of a table| or something
|或这些行的其他内容，

2631
01:34:20,490 --> 01:34:21,810
0,210 210,450 450,600 630,780 780,1320
along those lines,| so it
|所以它改变了数据库的布局，

2632
01:34:21,840 --> 01:34:23,340
0,330 330,930 930,1110 1110,1200 1200,1500
really changes you know the

2633
01:34:23,370 --> 01:34:26,300
0,540 540,660 660,1050 1410,2790
layout of the database,|
|

2634
01:34:26,750 --> 01:34:29,180
0,600 810,1380 1380,1650 1650,2010 2040,2430
and, {} and so schema
模式更改通常代价高昂，

2635
01:34:29,180 --> 01:34:31,430
0,450 450,930 960,1290 1290,1890 1890,2250
changes are generally expensive,| and
|他们确保原子的，

2636
01:34:31,430 --> 01:34:32,870
0,150 150,480 480,690 690,930 930,1440
the way they make sure

2637
01:34:32,870 --> 01:34:33,950
0,150 150,300 300,690 690,810 810,1080
that their atomic,| they're running
|在遥远的未来运行，

2638
01:34:33,950 --> 01:34:35,000
0,150 150,510 510,570 570,630 630,1050
in far in the future,|
|

2639
01:34:36,080 --> 01:34:37,490
0,720 720,960 960,1080 1080,1260 1260,1410
{} so they run over
所以他们使用时间戳，

2640
01:34:37,490 --> 01:34:38,450
0,90 90,360 360,720 720,840 840,960
the {timestamp -},| you know
|超越了当前的时间，

2641
01:34:38,450 --> 01:34:39,800
0,360 360,720 720,780 780,1050 1050,1350
well beyond the current time,|
|

2642
01:34:40,600 --> 01:34:42,010
0,450 450,630 630,780 780,1080 1080,1410
and so I guess that's
所以我想事务做自己的事，

2643
01:34:42,010 --> 01:34:43,600
0,390 390,780 780,1020 1020,1200 1200,1590
transaction {} do its stuff,

2644
01:34:43,600 --> 01:34:45,340
0,300 300,660 660,1260 1260,1530 1530,1740
correct,| because {} every other
|因为其他所有事务都使用版本内存，

2645
01:34:45,340 --> 01:34:46,600
0,180 180,510 510,870 870,960 960,1260
{transaction -} reading or writing

2646
01:34:46,600 --> 01:34:48,460
0,240 240,360 360,660 660,1200 1350,1860
using this version [memory],| and
|他们创建版本内存直到遥远的未来，

2647
01:34:48,460 --> 01:34:49,690
0,90 90,240 240,450 450,930 930,1230
you know they're creating version

2648
01:34:49,690 --> 01:34:50,950
0,360 360,690 690,1080 1080,1170 1170,1260
memory way farther in the

2649
01:34:50,950 --> 01:34:51,800
0,600
future,|
|

2650
01:34:52,240 --> 01:34:53,170
0,150 150,270 270,360 360,600 600,930
and so it can't affect
所以，它不会影响当前运行的任何事务，

2651
01:34:53,170 --> 01:34:54,580
0,240 240,360 360,450 450,960 990,1410
any of the current transaction

2652
01:34:54,580 --> 01:34:55,980
0,60 60,480
is running,|
|

2653
01:34:56,250 --> 01:34:58,830
0,300 300,1020 1020,1320 1320,2220 2220,2580
now communicate you know {}
现在通信要花很长时间，

2654
01:34:58,860 --> 01:34:59,610
0,90 90,180 180,360 360,570 570,750
you know this takes so

2655
01:34:59,610 --> 01:35:02,370
0,540 660,1380 1770,1920 1920,2550 2550,2760
long, { - - -}|
|

2656
01:35:02,370 --> 01:35:03,480
0,180 180,270 270,630 630,780 780,1110
by the time they actually
在他们想要提交模式迁移部分时，

2657
01:35:03,480 --> 01:35:07,470
0,210 210,330 1080,1770 2010,3390 3570,3990
want to commit the schema

2658
01:35:07,470 --> 01:35:10,320
0,600 600,1110 1440,2100 2130,2700 2700,2850
migration part,| {} there, there
|那里的事务，

2659
01:35:10,320 --> 01:35:11,700
0,120 120,330 330,900 900,1050 1050,1380
are actually transactions,| they're starting
|他们开始[]迁移事务开始的时间，

2660
01:35:11,700 --> 01:35:14,040
0,450 450,1320 1320,1650 1650,1830 1830,2340
to [] on the time

2661
01:35:14,190 --> 01:35:17,280
0,780 1080,1620 1620,2130 2130,2550 2550,3090
that {} migration transaction started,|
|

2662
01:35:18,540 --> 01:35:19,410
0,90 90,450 450,570 570,630 630,870
so those you know, those
所以那些事务是按时间前进的，

2663
01:35:19,410 --> 01:35:21,030
0,90 90,360 360,690 750,1290 1290,1620
{transactions -} actually times marches

2664
01:35:21,030 --> 01:35:22,290
0,390 390,450 450,690 690,930 930,1260
on,| you know we're doing
|我们执行事务，

2665
01:35:22,290 --> 01:35:23,880
0,510 870,1020 1020,1140 1140,1230 1230,1590
transactions,| and then the rule
|然后规则是任何读写事务

2666
01:35:23,880 --> 01:35:25,230
0,180 180,330 330,810 810,1170 1170,1350
is that basically any {read-write

2667
01:35:25,230 --> 01:35:26,940
0,210 210,720 720,840 840,1200 1200,1710
-} transaction| or any read-only
|或者任何只读或任何事务都必须停止，

2668
01:35:26,940 --> 01:35:28,920
0,210 210,390 390,990 1260,1830 1830,1980
or any transaction basically {have,to}

2669
01:35:28,920 --> 01:35:29,720
0,600
stop,|
|

2670
01:35:31,620 --> 01:35:34,920
0,360 360,1080 1080,1560 1560,2370 2490,3300
{} until basically the transfer,
直到迁移事务完成，

2671
01:35:34,920 --> 01:35:37,410
0,180 720,1440 1440,1920 1920,2070 2070,2490
the migration transaction was completed,|
|

2672
01:35:39,220 --> 01:35:40,960
0,390 390,660 660,1110 1110,1620 1620,1740
because the migration transaction is
因为迁移事务时间戳是新值，

2673
01:35:40,960 --> 01:35:43,420
0,270 270,900 1050,1110 1110,2070 2100,2460
{timestamping -} {you,know,the} {} new

2674
01:35:43,420 --> 01:35:44,620
0,660 660,750 750,870 870,1050 1050,1200
values,| you know with its
|有它的时间戳。

2675
01:35:44,620 --> 01:35:45,520
0,240 240,630
{timestamp -}.|
|

2676
01:35:46,820 --> 01:35:48,500
0,570 630,1020 1020,1290 1290,1590 1590,1680
So when when there's a
所以，当有迁移请求时，

2677
01:35:48,500 --> 01:35:50,660
0,480 480,990 990,1170 1170,1350 1350,2160
request essentially for this migration,|
|

2678
01:35:50,690 --> 01:35:51,560
0,540

2679
01:35:52,020 --> 01:35:53,550
0,180 180,630 630,780 780,1140 1140,1530
it chooses a commit time
它选择一个遥远的未来的提交时间，并且。

2680
01:35:53,550 --> 01:35:54,980
0,210 210,390 390,510 510,1140
far into the future,

2681
01:35:55,320 --> 01:35:58,080
0,900 1110,1290 1290,1740 1740,2370
and.| You hope basically,
|你希望那个事务也提交了。

2682
01:35:58,360 --> 01:35:59,860
0,240 240,450 450,840 840,1290 1290,1500
you hope basically the that

2683
01:35:59,860 --> 01:36:01,420
0,450 450,750 750,1230 1230,1320 1320,1560
transaction also commits, you know

2684
01:36:01,420 --> 01:36:04,810
0,360 360,930 960,1380 1380,1800 2730,3390
not.| Yeah, by then.| So
|是的，到那时。|所以，在此之前的任何读取都是从当前提供的。

2685
01:36:05,080 --> 01:36:06,840
0,420 420,720 720,930 930,1560
any reads that come

2686
01:36:07,180 --> 01:36:08,530
0,180 180,240 240,750 780,990 990,1350
at a time up until

2687
01:36:08,530 --> 01:36:10,540
0,540 600,870 870,1350 1350,1650 1650,2010
then are served from the

2688
01:36:10,570 --> 01:36:12,640
0,630 660,1230 1230,1740 1740,1980 1980,2070
current.| Local replicas from at
|所有的本地的 replica ，

2689
01:36:12,640 --> 01:36:13,930
0,240 240,570 570,900 900,1080 1080,1290
all, correct,| because they could
|因为它们已经看到写入了。

2690
01:36:13,930 --> 01:36:15,280
0,150 150,390 390,810 810,990 990,1350
have even seen that write.|
|

2691
01:36:16,940 --> 01:36:20,210
0,570 930,1470 1530,2490 2850,3060 3060,3270
Okay, and it's a cool
好的，这是个很酷的技巧，

2692
01:36:20,210 --> 01:36:21,170
0,240 240,510 510,570 570,690 690,960
trick,| if you have version
|如果你有版本内存，

2693
01:36:21,170 --> 01:36:22,280
0,390 390,510 510,630 630,750 750,1110
memory,| you can you schedule
|你可以把事情安排在未来。

2694
01:36:22,280 --> 01:36:24,290
0,240 240,300 300,360 360,840 1740,2010
things in the future.| Yeah,
|是的，这是个很酷的技巧，

2695
01:36:24,290 --> 01:36:24,950
0,120 120,180 180,360 360,600 600,660
it's a cool trick,| I
|我只是在想，

2696
01:36:24,950 --> 01:36:25,910
0,90 90,270 270,570 570,810 810,960
was just wondering,| how they
|他们到底是怎么想出未来的这一点的。

2697
01:36:25,910 --> 01:36:28,580
0,540 540,1500 1530,2070 2070,2250 2250,2670
actually like figure out that

2698
01:36:28,930 --> 01:36:31,330
0,420 420,510 510,600 600,1200 1230,2400
point in the future. {}|
|

2699
01:36:32,790 --> 01:36:36,390
0,930 930,1050 1050,1320 1320,1800 2640,3600
Yeah, it's probably some some
是的，可能是[]或什么东西，好的。

2700
01:36:36,390 --> 01:36:37,890
0,300 300,540 540,600 600,960 960,1500
{[] -} or something, okay.|
|

2701
01:36:38,390 --> 01:36:40,310
0,300 300,660 660,1080 1080,1260 1260,1920
So, but essentially,| so if
所以，但从本质上说，|如果你不选择一个足够远的时间，

2702
01:36:40,310 --> 01:36:41,960
0,540 750,1350
you don't

2703
01:36:42,400 --> 01:36:44,440
0,630 630,720 720,1380 1380,1560 1560,2040
choose a time, that's far

2704
01:36:44,440 --> 01:36:45,900
0,270 270,330 330,420 420,1140
enough in the future,|
|

2705
01:36:46,360 --> 01:36:47,530
0,210 210,450 450,690 690,780 780,1170
then you run the risk
那你就得冒着风险。

2706
01:36:47,530 --> 01:36:50,200
0,540 660,1500 1590,1980 2010,2250 2460,2670
of.| Exactly.| Okay, so then
|没错。|好的，那么会有错误的结果。

2707
01:36:50,200 --> 01:36:53,470
0,90 90,360 360,720 720,1230 2070,3270
you have incorrect results.| To
|为避免错误结果的风险，这会阻塞。

2708
01:36:53,470 --> 01:36:55,090
0,390 390,690 690,840 840,1200 1200,1620
avoid risk of incorrect results,

2709
01:36:55,090 --> 01:36:56,340
0,270 270,570 570,1020
which actually block.|
|

2710
01:36:56,730 --> 01:36:58,760
0,690 840,1080 1080,1650
Yeah, I see,
是的，我明白了，好的。

2711
01:36:59,870 --> 01:37:00,800
0,630
okay.|
|

2712
01:37:01,060 --> 01:37:03,490
0,570 570,930 930,1050 1050,1500 1860,2430
Awesome, thanks so much.| {You're,welcome}.|
太棒了，非常感谢。|不用谢。|

2713
01:37:03,640 --> 01:37:07,360
0,360
Bye.
再见。
