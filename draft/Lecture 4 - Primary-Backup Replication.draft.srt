1
00:00:03,200 --> 00:00:05,720
0,690 720,960 960,1680 1710,2220 2220,2520
Okay, good afternoon, good morning
好的，下午好，早上好，晚上好，无论你在哪里。

2
00:00:05,720 --> 00:00:07,400
0,150 150,300 300,720 900,1500 1500,1680
or good evening, wherever you

3
00:00:07,400 --> 00:00:08,440
0,420
are.|
|

4
00:00:08,820 --> 00:00:10,080
0,210 210,600 690,930 930,1020 1020,1260
{} I want to talk
今天我想谈谈主/备复制，

5
00:00:10,080 --> 00:00:11,580
0,270 270,750 750,930 930,1200 1200,1500
today about {} {primary/backup -}

6
00:00:11,580 --> 00:00:13,080
0,720 750,1230 1230,1380 1380,1440 1440,1500
replication,| really sort of an
|是对主/备应用程序的介绍。

7
00:00:13,080 --> 00:00:15,570
0,570 570,1080 1110,1470 1470,1770 1770,2490
introduction to {primary/backup -} application.|
|

8
00:00:16,350 --> 00:00:18,150
0,240 240,480 480,1290 1410,1590 1590,1800
{} And we'll come back
我们将在本学期的多节课中讨论这一点，

9
00:00:18,150 --> 00:00:19,650
0,90 90,480 480,780 780,1140 1140,1500
to this in multiple lectures

10
00:00:19,650 --> 00:00:21,660
0,240 240,870 1260,1710 1710,1860 1860,2010
during semester,| but this is
|但这是[]或 VMware 容错论文，

11
00:00:21,660 --> 00:00:25,020
0,1260 1830,2070 2070,2580 2580,2970 2970,3360
{} {[] - - -

12
00:00:25,020 --> 00:00:27,030
0,540 540,600 600,1020 1020,1800 1800,2010
-} or a VMware fault

13
00:00:27,030 --> 00:00:29,370
0,600 960,1620 1620,1800 1800,2100 2100,2340
tolerance paper,| is a really
|是一个非常好的介绍，引出了很多问题，

14
00:00:29,370 --> 00:00:30,600
0,240 240,750 750,870 870,1110 1110,1230
nice introduction that brings out

15
00:00:30,600 --> 00:00:32,250
0,30 30,300 300,420 420,1020 1230,1650
a lot of issues,| that
|在整个学期都会出现这样的问题。

16
00:00:32,250 --> 00:00:33,690
0,150 150,330 330,480 480,1050 1050,1440
are gonna come up throughout

17
00:00:33,690 --> 00:00:35,000
0,240 270,870
the semester.|
|

18
00:00:35,860 --> 00:00:37,480
0,420 420,690 690,1020 1050,1320 1320,1620
The plan for lecture today
今天课程的计划如下。

19
00:00:37,480 --> 00:00:38,940
0,120 120,240 240,930
is as follows.|
|

20
00:00:41,170 --> 00:00:41,950
0,240 240,390 390,510 510,570 570,780
I'm just going to talk
我想谈谈失败，

21
00:00:41,950 --> 00:00:43,900
0,600 600,1140 1140,1290 1290,1680 1710,1950
about failures,| that you might
|你可能希望使用主/备复制来容错，

22
00:00:43,900 --> 00:00:47,200
0,540 690,1080 1080,1770 1770,2310 2670,3300
hope to tolerate using {primary/backup

23
00:00:47,200 --> 00:00:49,450
0,480 510,1380 1380,1800 1800,2100 2100,2250
-} replication,| and some that
|而有些你可能做不到。

24
00:00:49,450 --> 00:00:50,980
0,90 90,240 240,690 720,1290 1290,1530
you might not be able

25
00:00:50,980 --> 00:00:51,820
0,330
to.|
|

26
00:00:51,990 --> 00:00:52,890
0,510 510,600 600,720 720,780 780,900
Then I want to talk
然后我想谈谈主要挑战，

27
00:00:52,890 --> 00:00:53,550
0,60 60,240 240,390 390,600 600,660
a little bit about the

28
00:00:53,550 --> 00:00:55,410
0,270 270,1020 1410,1560 1560,1710 1710,1860
main challenges,| in sort of
|关于备份的方案，

29
00:00:55,410 --> 00:00:58,700
0,600 900,1590 1590,2220
any backup scheme,|
|

30
00:00:58,980 --> 00:01:00,570
0,450 450,600 600,660 660,1020 1020,1590
{} sort of broad speaking.|
从广义上来讲。|

31
00:01:00,570 --> 00:01:02,760
0,240 240,480 480,750 750,1440 1800,2190
Then talk about two {you,know}
然后谈谈两种主要方法，两种应用，

32
00:01:02,760 --> 00:01:04,620
0,540 540,1320
dominant approaches,

33
00:01:04,700 --> 00:01:07,460
0,420 420,930 930,1800
{} two application,|
|

34
00:01:08,300 --> 00:01:10,520
0,930 930,1260 1260,1710 1710,2010 2010,2220
one is what's typically called
一种是通常称为状态转移复制，

35
00:01:10,520 --> 00:01:13,740
0,330 330,630 630,1080 1350,2460
state {transfer -} replication,|
|

36
00:01:15,330 --> 00:01:16,740
0,210 210,270 270,870 960,1110 1110,1410
and the second is typically
第二个通常称为复制状态机。

37
00:01:16,740 --> 00:01:19,200
0,300 300,840 840,1080 1080,1680
called replicated state machines.|
|

38
00:01:24,980 --> 00:01:26,000
0,240 240,540 540,840 840,930 930,1020
And today's paper is an
今天的论文是复制状态机方法的一个例子，

39
00:01:26,000 --> 00:01:27,620
0,750 750,870 870,930 930,1380 1380,1620
example of a replicated state

40
00:01:27,620 --> 00:01:29,780
0,360 390,1440 1830,1980 1980,2100 2100,2160
machine approach,| and if {in,fact}
|实际上，实验 2 或实验 3 ，实验 4 ，

41
00:01:29,780 --> 00:01:31,550
0,90 90,360 360,720 720,1320 1320,1770
you know lab 2 {or,lab}

42
00:01:31,550 --> 00:01:32,930
0,240 240,540 540,930 930,1110 1110,1380
3, lab 4| {you,know} also
|也将使用复制状态机方法，

43
00:01:32,930 --> 00:01:34,190
0,90 90,390 390,600 600,1020 1020,1260
will be using replicated state

44
00:01:34,190 --> 00:01:35,630
0,390 390,750 750,960 960,1050 1050,1440
machine approach,| and the fact
|以及 GFS 论文复制块

45
00:01:35,630 --> 00:01:38,330
0,120 120,450 540,1170 1170,1830 1890,2700
that the GFS paper is

46
00:01:38,360 --> 00:01:40,190
0,540 540,1110 1170,1410 1410,1770 1770,1830
replicating chunks| was using a
|也是使用复制状态机方法。

47
00:01:40,190 --> 00:01:41,900
0,420 420,630 630,840 840,1320
replicated state machine approach.|
|

48
00:01:42,160 --> 00:01:43,180
0,450 450,630 630,720 720,930 930,1020
{} Since it's quite a
因为这是一种相当常见的方法。

49
00:01:43,180 --> 00:01:44,890
0,270 270,840 1110,1260 1260,1650 1650,1710
common approach.| And then you
|然后为了让事情更具体，

50
00:01:44,890 --> 00:01:45,460
0,120 120,300 300,360 360,510 510,570
know what I sort of

51
00:01:45,460 --> 00:01:46,930
0,210 210,600 600,660 660,930 930,1470
make everything a little concrete,|
|

52
00:01:46,930 --> 00:01:48,310
0,540 540,810 810,930 930,1050 1050,1380
by looking at this case
通过观察这个案例研究，

53
00:01:48,310 --> 00:01:49,940
0,210 300,570 570,960
the case study,|
|

54
00:01:52,140 --> 00:01:54,780
0,630 630,840 840,960 960,1620 2190,2640
{} of the VM VMware
VMware 容错方案或实施或系统。

55
00:01:54,780 --> 00:01:58,590
0,0 960,2190 2220,2940 2970,3150 3150,3810
fault tolerance scheme or implementation

56
00:01:58,590 --> 00:01:59,720
0,120 120,570
or system.|
|

57
00:02:00,020 --> 00:02:01,970
0,480 960,1350 1350,1650 1650,1890 1890,1950
{} Any questions before I
在我开始之前有什么问题吗，

58
00:02:01,970 --> 00:02:04,490
0,90 90,1050 1050,1260 1260,1710 2130,2520
get started,| just to, {}|
|只是为了，|

59
00:02:04,490 --> 00:02:07,070
0,360 1680,1860 1860,2190 2190,2310 2310,2580
{ -} I have tried
我试着回答你们通过电子邮件发送的所有问题，

60
00:02:07,070 --> 00:02:07,940
0,90 90,390 390,450 450,540 540,870
to answer all the questions

61
00:02:07,940 --> 00:02:09,380
0,120 120,240 240,420 420,510 510,1440
that you send by email,|
|

62
00:02:10,040 --> 00:02:11,690
0,600 780,1320 1320,1410 1410,1500 1500,1650
{} ones you know they're
在前半夜之前来的，

63
00:02:11,690 --> 00:02:13,160
0,210 210,480 480,930 930,1230 1230,1470
coming before midnight,| generally all
|一般都会在后半夜回答，

64
00:02:13,160 --> 00:02:14,240
0,540 540,630 630,840 840,930 930,1080
answer the ones that come

65
00:02:14,240 --> 00:02:15,500
0,150 150,450 450,1050 1050,1140 1140,1260
in after midnight,| you know
|尽可能多地回答，

66
00:02:15,500 --> 00:02:16,880
0,270 270,510 510,1080 1080,1230 1230,1380
try to answer as many

67
00:02:16,880 --> 00:02:18,350
0,90 90,180 180,480 930,1350 1350,1470
as I can,| but if
|但如果我没有回答你的问题，

68
00:02:18,350 --> 00:02:19,520
0,0 0,390 390,630 630,720 720,1170
I didn't answer your question,|
|

69
00:02:19,520 --> 00:02:21,110
0,450 450,870 870,1110 1110,1260 1260,1590
then you and the topic
然后，这个话题在上课时或任何时候出现，

70
00:02:21,110 --> 00:02:22,250
0,240 240,360 360,450 450,960 960,1140
comes up at {lecture,or} at

71
00:02:22,250 --> 00:02:23,240
0,150 150,420 420,600 600,660 660,990
any point by the time,|
|

72
00:02:23,240 --> 00:02:24,770
0,150 150,330 330,570 570,930 930,1530
{you,know} feel free to interrupt
可以随意打断，然后提问。

73
00:02:24,770 --> 00:02:25,980
0,270 270,600 600,840
and ask it.|
|

74
00:02:26,920 --> 00:02:29,050
0,270 270,450 450,1080 1290,1770 1770,2130
Okay, any questions, before we
好了，在我们开始之前，有什么问题吗？

75
00:02:29,080 --> 00:02:30,420
0,330 330,630
dive in.|
|

76
00:02:35,720 --> 00:02:37,100
0,750

77
00:02:39,010 --> 00:02:40,380
0,720

78
00:02:40,440 --> 00:02:41,740
0,570

79
00:02:41,740 --> 00:02:43,120
0,240 240,390 390,600 600,840 840,1380
So let's talk about failures
所以，让我们从非常广泛的意义上讨论失败，

80
00:02:43,180 --> 00:02:45,550
0,330 360,690 690,960 960,1530 1740,2370
in a very broad sense,|
|

81
00:02:45,790 --> 00:02:46,600
0,180 180,330 330,360 360,660 660,810
you get a sense of|
你可以大致了解|

82
00:02:46,600 --> 00:02:47,590
0,210 210,420 420,540 540,750 750,990
like what we might hope
我们希望复制方案能够处理的（失败）。

83
00:02:47,590 --> 00:02:49,960
0,390 390,660 660,1230 1230,1830 2040,2370
for that replication scheme can

84
00:02:49,960 --> 00:02:51,160
0,510
handle.|
|

85
00:02:58,610 --> 00:02:59,810
0,210 210,420 420,480 480,750 750,1200
So, first of all, the
所以，首先，通常情况下，

86
00:03:00,230 --> 00:03:01,850
0,510 510,870 900,1200 1200,1320 1320,1620
typically,| the papers that where
|论文中所要构建的系统，

87
00:03:01,850 --> 00:03:02,510
0,90 90,150 150,450 450,570 570,660
in the system that we're

88
00:03:02,510 --> 00:03:03,680
0,120 120,180 180,270 270,600 600,1170
going to be about building|
|

89
00:03:03,890 --> 00:03:05,630
0,480 480,780 780,1050 1050,1470 1470,1740
{} will only deal with
只会处理一些事情，

90
00:03:05,630 --> 00:03:07,010
0,150 150,390 390,870 870,1050 1050,1380
some things| called were typically
|通常称为 fail-stop 失败，

91
00:03:07,010 --> 00:03:09,760
0,300 300,540 540,1170 1290,2130
called {fail-stop -} failures,|
|

92
00:03:11,940 --> 00:03:12,960
0,540

93
00:03:14,250 --> 00:03:15,330
0,300 300,360 360,600 600,990 990,1080
and the basic idea is
基本的想法是，

94
00:03:15,330 --> 00:03:16,950
0,180 180,300 300,900 900,1380 1380,1620
that,| the infrastructure failure| or
|基础设施故障|或计算机组件不能很好地工作，

95
00:03:16,950 --> 00:03:18,060
0,420 420,510 510,570 570,870 870,1110
component of the computer doesn't

96
00:03:18,060 --> 00:03:20,640
0,180 180,420 420,900 1410,1950 1980,2580
really work well,| that actually
|使计算机停止运行，

97
00:03:20,640 --> 00:03:22,400
0,540 540,660 660,1170
stops the computer,|
|

98
00:03:24,560 --> 00:03:25,620
0,810

99
00:03:28,120 --> 00:03:29,140
0,150 150,240 240,660 660,840 840,1020
so the assumption is that,|
所以假设是，|

100
00:03:29,140 --> 00:03:30,760
0,660 660,900 930,1260 1260,1470 1470,1620
basically the computer goes from
计算机瞬间从工作到不工作，

101
00:03:30,760 --> 00:03:32,260
0,510 510,690 690,930 930,1260 1260,1500
working to not working, so

102
00:03:32,260 --> 00:03:34,810
0,930 1110,1500 1500,1950 1950,2280 2280,2550
instantaneously,| {it,doesn't} produce like weird
|它不会产生奇怪的结果，

103
00:03:34,810 --> 00:03:35,890
0,420 420,690 690,750 750,1020 1020,1080
results,| because the computer is
|因为计算机不能正常工作。

104
00:03:35,890 --> 00:03:37,630
0,180 180,600 660,1350 1380,1620 1620,1740
not working, correctly.| So it
|所以跟据这个协议，

105
00:03:37,630 --> 00:03:39,730
0,150 150,480 480,540 540,1350 1590,2100
just follows the protocols, {}|
|

106
00:03:39,730 --> 00:03:40,900
0,120 120,180 180,540 570,1020 1020,1170
you know when does to
当你对寄存器值相加，

107
00:03:40,900 --> 00:03:43,210
0,690 690,810 810,1260 1260,1770 1770,2310
adds it to register values,|
|

108
00:03:43,210 --> 00:03:44,080
0,90 90,210 210,360 360,810 810,870
you know that produces are
它会产生相加值，

109
00:03:44,080 --> 00:03:46,420
0,450 450,720 720,1290 1620,2100 2100,2340
correct, add value,| {} and
|所以我们假设，

110
00:03:46,420 --> 00:03:47,530
0,120 120,240 240,480 480,930 930,1110
so we're just assuming that,|
|

111
00:03:47,530 --> 00:03:49,060
0,150 150,210 210,510 510,1020 1230,1530
when the computer works, it
当计算机工作时，它就会正确工作，

112
00:03:49,060 --> 00:03:50,800
0,210 210,780 780,1200 1200,1560 1560,1740
works correctly,| and when there's
|当有失败的时候，它就会停止。

113
00:03:50,800 --> 00:03:52,120
0,60 60,510 510,630 630,780 780,1320
a failure, it just stops.|
|

114
00:03:53,030 --> 00:03:54,770
0,450 660,930 930,1260 1260,1470 1470,1740
{} This covers in many
这会包括许多情况，

115
00:03:54,770 --> 00:03:56,660
0,750 810,870 870,1440 1440,1800 1800,1890
scenarios,| for example whatever {you,know}
|比如，无论计算机风扇出现故障，

116
00:03:56,660 --> 00:03:57,980
0,270 270,390 390,450 450,1020 1290,1320
fan of the computer {

117
00:03:57,980 --> 00:04:00,320
0,0 1170,2040 2040,2130 2130,2250 2250,2340
-} fails,| you know the
|计算机过热，

118
00:04:00,320 --> 00:04:02,120
0,390 390,1140 1170,1530 1530,1740 1740,1800
computer overheat,| and then the
|然后计算机自动关机，

119
00:04:02,120 --> 00:04:03,900
0,300 300,540 540,750 750,1320
computer shuts down itself,|
|

120
00:04:04,080 --> 00:04:07,740
0,750 1020,2100 2820,3060 3060,3390 3390,3660
{} the other cases are
其他情况是有人跨过电源线，

121
00:04:07,740 --> 00:04:09,210
0,480 540,960 960,1230 1230,1380 1380,1470
where somebody steps over the

122
00:04:09,210 --> 00:04:10,650
0,300 300,660 810,1020 1020,1380 1380,1440
power cord,| and boom, you
|然后突然，整个电脑都消失了，

123
00:04:10,650 --> 00:04:12,000
0,120 120,210 210,360 360,690 690,1350
know the whole computer disappears,|
|

124
00:04:12,090 --> 00:04:13,620
0,360 360,450 450,1200 1200,1440 1440,1530
or you know cuts the
或者切断网络连接，

125
00:04:13,620 --> 00:04:15,540
0,330 330,750 780,1230 1620,1800 1800,1920
network link,| and at that
|在这个时刻，

126
00:04:15,540 --> 00:04:17,040
0,300 300,390 390,540 540,1080 1200,1500
point,| you know the computer
|计算机保持运行，

127
00:04:17,040 --> 00:04:19,080
0,120 120,360 360,840 840,1380 1380,2040
by keeping running| about {}
|但完全断开了连接。

128
00:04:19,080 --> 00:04:20,840
0,360 360,720 720,1290
is completely disconnected.|
|

129
00:04:21,780 --> 00:04:23,640
0,600 600,660 660,1050 1080,1710 1710,1860
Sometimes you know systems or
有时计算机本身的系统或软件，

130
00:04:23,640 --> 00:04:24,780
0,300 300,570 570,780 780,840 840,1140
{software -} on the computer

131
00:04:24,780 --> 00:04:26,130
0,390 390,480 480,810 810,1290 1290,1350
itself,| it does best you
|最好的做法是将部分故障转变为 fail-stop 失败，

132
00:04:26,130 --> 00:04:27,270
0,90 90,240 240,600 600,780 780,1140
know to turn these partial

133
00:04:27,270 --> 00:04:29,040
0,360 360,870 870,1230 1260,1620 1620,1770
failures into a stop {fail-stop

134
00:04:29,040 --> 00:04:30,840
0,270 270,780 1200,1320 1320,1710 1710,1800
-} failures,| for example you
|例如，软件计算数据的校验和，

135
00:04:30,840 --> 00:04:32,610
0,390 750,1050 1050,1230 1230,1560 1560,1770
might software might compute {checksums

136
00:04:32,610 --> 00:04:34,350
0,390 390,600 600,870 870,1230 1230,1740
-} on data,| and then
|然后，如果它发现校验和不正确，

137
00:04:34,350 --> 00:04:35,160
0,240 240,330 330,600 600,720 720,810
if it sees that the

138
00:04:35,160 --> 00:04:36,360
0,360 360,450 450,960 960,1050 1050,1200
checksum is incorrect,| you know
|可以直接停止计算机。

139
00:04:36,360 --> 00:04:37,650
0,360 480,990 1020,1110 1110,1200 1200,1290
just stop you know the

140
00:04:37,650 --> 00:04:38,620
0,510
computer.|
|

141
00:04:39,080 --> 00:04:41,150
0,540 1110,1530 1530,1680 1680,1800 1800,2070
{ -} And so those
所以这些都是很常见的，

142
00:04:41,150 --> 00:04:43,040
0,210 240,540 540,1140 1140,1680 1680,1890
are quite common| {} and
|要做到这一点，

143
00:04:43,040 --> 00:04:44,030
0,90 90,210 210,390 390,570 570,990
to do so,| the basic
|这个词的意思是，

144
00:04:44,030 --> 00:04:45,200
0,240 240,300 300,390 390,780 780,1170
model of the word is,|
|

145
00:04:45,620 --> 00:04:46,760
0,120 120,300 300,480 480,960 960,1140
{computer -} work correctly, then
计算机正常工作，然后计算停止。

146
00:04:46,760 --> 00:04:48,020
0,60 60,360 360,780
the computer stops.|
|

147
00:04:48,810 --> 00:04:50,130
0,240 240,360 360,510 510,660 660,1320
So what does this exclude,|
那么，这排除了什么，|

148
00:04:50,160 --> 00:04:51,120
0,150 150,300 300,480 480,660 660,960
you know there's a whole
有一大堆的失败被排除了，

149
00:04:51,120 --> 00:04:52,320
0,270 270,360 360,540 540,660 660,1200
bunch of sort of failures

150
00:04:52,320 --> 00:04:54,180
0,270 270,600 600,720 720,1320 1560,1860
that exclude,| for example {}
|例如，它不能很好地处理逻辑错误，

151
00:04:54,180 --> 00:04:55,470
0,120 120,330 330,570 570,840 840,1290
it doesn't really deal well

152
00:04:55,470 --> 00:04:57,080
0,180 180,480 480,930
with logic bugs,|
|

153
00:04:57,140 --> 00:04:58,400
0,210 210,420 420,630 630,1140 1170,1260
like if you have an
比如，如果你的软件有错误，

154
00:04:58,400 --> 00:04:59,540
0,300 300,390 390,510 510,780 780,1140
error in your software,| {you,know}
|无论你除以零，

155
00:04:59,600 --> 00:05:01,220
0,480 480,570 570,960 960,1050 1050,1620
whatever you divide by zero|
|

156
00:05:01,220 --> 00:05:03,890
0,960 1140,1800 1800,1950 1950,2370 2490,2670
and incorrectly you were where
或者你不应该有的错误，

157
00:05:03,890 --> 00:05:05,570
0,60 60,360 360,690 1050,1500 1500,1680
you shouldn't have,| then {you,know}
|然后非常可能，

158
00:05:05,570 --> 00:05:06,560
0,120 120,180 180,390 390,810 810,990
it is very likely,| that
|备份也会做同样的事情，

159
00:05:06,560 --> 00:05:07,640
0,90 90,420 420,510 510,600 600,1080
the backup will do exactly

160
00:05:07,640 --> 00:05:08,990
0,90 90,300 300,570 630,1170 1170,1350
the same thing,| because one
|因为其中一个软件是坏的，

161
00:05:08,990 --> 00:05:09,560
0,60 60,120 120,330 330,480 480,570
of the software which is

162
00:05:09,560 --> 00:05:11,840
0,570 570,1080 1080,1500 1740,1950 1950,2280
broken,| and so it's broken
|所以，它在主机上出现故障，也在备份机上出现故障，

163
00:05:11,840 --> 00:05:12,920
0,90 90,150 150,690 690,810 810,1080
on the primary, it's broken

164
00:05:12,920 --> 00:05:14,090
0,90 90,150 150,480 630,960 960,1170
on the backup,| and so
|所以，复制不能

165
00:05:14,090 --> 00:05:16,550
0,480 480,570 570,1080 1230,1830 1830,2460
nothing you know basically replication

166
00:05:16,550 --> 00:05:17,870
0,270 270,720 720,900 900,1080 1080,1320
really not| does not solve
|不能为你解决这类问题。

167
00:05:17,870 --> 00:05:20,270
0,150 150,450 450,690 690,840 1650,2400
that problem for you.| Similar,
|类似地，如果你有配置错误，

168
00:05:20,360 --> 00:05:22,190
0,360 360,480 480,630 630,1230 1230,1830
if you have configuration errors,|
|

169
00:05:26,150 --> 00:05:27,560
0,630 630,990 990,1170 1170,1290 1290,1410
{primary/backup -} is not going
主/备不会为你解决这类问题，

170
00:05:27,560 --> 00:05:28,730
0,120 120,420 420,750 750,900 900,1170
to solve you the problem

171
00:05:28,730 --> 00:05:29,900
0,180 180,390 510,870 870,960 960,1170
for you,| if you know
|如果你指定的文件，复制说不正确，

172
00:05:29,900 --> 00:05:31,040
0,510
the,

173
00:05:31,160 --> 00:05:32,870
0,630 750,960 960,1350 1350,1560 1560,1710
{} the files that you

174
00:05:32,870 --> 00:05:34,550
0,600 600,720 720,1080 1080,1440 1440,1680
specify the replica said that

175
00:05:34,550 --> 00:05:36,590
0,450 480,1290 1380,1590 1590,1890 1890,2040
incorrect,| then the system will
|那么系统将不能正常工作。

176
00:05:36,590 --> 00:05:39,260
0,210 210,390 390,840 1440,1980 1980,2670
not work correctly.| {} Similarly,
|同样，我们不在这节课上，

177
00:05:39,440 --> 00:05:40,490
0,210 210,480 480,780 780,900 900,1050
we're not really in this

178
00:05:40,490 --> 00:05:41,810
0,510 510,900 900,1080 1080,1140 1140,1320
class,| we'll talk a little
|我们会在学期末讨论，

179
00:05:41,810 --> 00:05:42,530
0,150 150,360 360,480 480,630 630,720
bit at the end of

180
00:05:42,530 --> 00:05:44,630
0,210 210,630 630,840 840,1320 1500,2100
the semester,| but {we're,not} dealing
|但我们不能处理恶意错误，

181
00:05:44,630 --> 00:05:48,740
0,150 150,900 1080,1770 3540,3900 3900,4110
with malicious errors,| {so,we're} not
|所以不能处理试图伪造协议的攻击者，

182
00:05:48,740 --> 00:05:50,750
0,330 330,480 480,1110 1110,1500 1530,2010
dealing with attackers {you,know} try

183
00:05:50,750 --> 00:05:53,420
0,330 330,570 570,660 660,1560 1770,2670
to fake the protocol, {}|
|

184
00:05:53,420 --> 00:05:54,440
0,120 120,270 270,330 330,720 750,1020
you know {} have run
运行服务器发送错误消息，

185
00:05:54,440 --> 00:05:56,660
0,420 420,630 630,900 900,1350 1350,2220
servers that send incorrect messages|
|

186
00:05:56,840 --> 00:05:57,920
0,240 240,540 540,810 810,960 960,1080
and try to sort of
并试图戏弄整个系统，

187
00:05:57,920 --> 00:05:59,870
0,630 630,750 750,990 990,1380 1500,1950
spoof the whole system,| we're
|这不在我们考虑之列。

188
00:05:59,870 --> 00:06:01,190
0,150 150,390 390,480 480,1050 1050,1320
just not in consideration.| So
|所以在这学期的大部分时间里，

189
00:06:01,190 --> 00:06:02,570
0,240 240,750 870,1050 1050,1290 1290,1380
in the for most of

190
00:06:02,570 --> 00:06:04,040
0,60 60,690 750,960 960,1350 1350,1470
the semester,| we assume that
|我们假设软件工作正常，

191
00:06:04,040 --> 00:06:05,660
0,210 210,510 510,750 750,1380 1410,1620
the software works correctly,| does
|没有逻辑错误，

192
00:06:05,660 --> 00:06:07,100
0,180 180,330 330,660 660,1200 1230,1440
not have logic bugs,| that
|没有配置错误，

193
00:06:07,100 --> 00:06:08,420
0,120 120,330 330,450 450,780 780,1320
no {configuration - -} errors,|
|

194
00:06:08,510 --> 00:06:09,020
0,120 120,180 180,300 300,390 390,510
and the thing that we're
我们关注的事情是处理停止失败。

195
00:06:09,020 --> 00:06:10,640
0,510 510,720 720,810 810,1140 1140,1620
focusing on is actually handling

196
00:06:10,640 --> 00:06:11,720
0,300 300,810
stop failures.|
|

197
00:06:12,950 --> 00:06:14,270
0,210 210,630 630,1050 1050,1170 1170,1320
There's some failures that sort
有一些失败，

198
00:06:14,270 --> 00:06:16,610
0,60 60,1080 1260,1950 1950,2130 2130,2340
of fail,| {} {that,could} be
|是可以使用主备复制处理的，

199
00:06:16,610 --> 00:06:18,440
0,570 630,1140 1140,1350 1350,1470 1470,1830
handled or may be handled

200
00:06:18,440 --> 00:06:21,770
0,390 390,930 1590,2220 2220,2520 2520,3330
with {} {primary/backup -} replication|
|

201
00:06:22,010 --> 00:06:24,200
0,600 600,780 780,1230 1530,2010 2010,2190
or or not,| {} as
或者不可以，|比如，你可能会想到地震，

202
00:06:24,200 --> 00:06:25,280
0,90 90,600 600,750 750,930 930,1080
an example, you might think

203
00:06:25,280 --> 00:06:27,000
0,360 360,660 660,1290
about an earthquake,|
|

204
00:06:29,690 --> 00:06:30,860
0,180 180,330 330,450 450,840 840,1170
{you,know} if the {primary/backup -}
如果主备在物理上是分开的，

205
00:06:30,860 --> 00:06:32,480
0,180 180,690 690,1410 1410,1500 1500,1620
{} are physically you know

206
00:06:32,480 --> 00:06:34,850
0,780 930,1500 1500,1770 1770,2160 2160,2370
separated,| {} in completely different
|在完全不同的地方，

207
00:06:34,850 --> 00:06:36,380
0,390 390,510 510,690 690,930 930,1530
parts,| you know different continents
|在不同的大陆或同一大陆的不同部分，

208
00:06:36,440 --> 00:06:37,220
0,240 240,480 480,660 660,720 720,780
or different parts of the

209
00:06:37,220 --> 00:06:38,870
0,180 180,810 1080,1320 1320,1440 1440,1650
same continent,| when {} that,
|在这种情况下，你可能会希望，

210
00:06:38,870 --> 00:06:40,130
0,90 90,270 270,630 630,930 930,1260
you might hope that,| you
|你可能会希望，

211
00:06:40,130 --> 00:06:41,090
0,150 150,270 270,450 450,720 720,960
might have some hope that,|
|

212
00:06:41,090 --> 00:06:43,550
0,450 810,1800 1800,1980 1980,2160 2160,2460
the backup could take over,|
备机可以接管，|

213
00:06:43,550 --> 00:06:45,890
0,750 780,930 930,1350 1350,1920 1980,2340
if the primary fails due
如果主机因为地震发生故障，

214
00:06:45,890 --> 00:06:48,260
0,90 90,210 210,690 870,1800 1890,2370
to an earthquake,| but {}
|但是其他一些复制方案，

215
00:06:48,260 --> 00:06:49,910
0,390 390,540 540,750 750,1320 1350,1650
you know some other primary

216
00:06:49,910 --> 00:06:51,380
0,570 570,990 990,1230 1230,1350 1350,1470
replication schemes,| this is not
|情况不会是这样的，

217
00:06:51,380 --> 00:06:52,160
0,120 120,180 180,270 270,360 360,780
going to be the case,|
|

218
00:06:52,160 --> 00:06:53,240
0,90 90,510 540,930 930,1020 1020,1080
{you,know} [] { - -}
主备在同一个数据中心，

219
00:06:53,240 --> 00:06:54,230
0,390 390,480 480,540 540,840 840,990
primary and the backup on

220
00:06:54,230 --> 00:06:55,370
0,120 120,420 420,660 660,1020 1020,1140
the same data center,| and
|整个数据中心都会消失，

221
00:06:55,370 --> 00:06:57,260
0,60 60,240 240,480 480,1230 1230,1890
the whole data center disappears,|
|

222
00:06:57,470 --> 00:06:58,460
0,450 480,570 570,750 750,900 900,990
then you know sort of
那么故事就结束了。

223
00:06:58,460 --> 00:06:59,440
0,150 150,240 240,600
end of story.|
|

224
00:07:00,220 --> 00:07:01,990
0,630 840,1230 1230,1590 1590,1710 1710,1770
Okay?| So {hopefully,that} gives you
好的?|希望这能给你一些背景知识，

225
00:07:01,990 --> 00:07:02,830
0,60 60,240 240,330 330,390 390,840
a little bit of context|
|

226
00:07:02,830 --> 00:07:04,000
0,300 300,390 390,630 630,690 690,1170
of the type of failures
关于你试图解决的失败类型。

227
00:07:04,000 --> 00:07:05,500
0,360 360,870 870,960 960,1200 1200,1500
you're trying to shoot for.|
|

228
00:07:06,510 --> 00:07:07,530
0,150 150,510 510,690 690,840 840,1020
{You,know}, even with this sort
即使只关注 fail-stop 故障，

229
00:07:07,530 --> 00:07:09,690
0,150 510,960 960,1440 1440,1680 1680,2160
of just focusing on stop

230
00:07:09,720 --> 00:07:11,520
0,510 510,690 690,930 930,1410 1620,1800
{} {fail-stop -} failures,| that
|也很难建立容错系统，

231
00:07:11,520 --> 00:07:13,110
0,210 210,300 300,360 360,990 1020,1590
turns out to be difficult

232
00:07:13,110 --> 00:07:14,880
0,60 60,450 630,870 870,1170 1170,1770
to build fault tolerant systems,|
|

233
00:07:15,060 --> 00:07:15,600
0,150 150,270 270,330 330,510 510,540
we're going to talk a
我们将讨论一下会出现的一般性问题，

234
00:07:15,600 --> 00:07:16,920
0,180 180,330 330,660 660,930 930,1320
little bit about the general

235
00:07:16,920 --> 00:07:18,120
0,360 360,510 510,630 630,870 870,1200
issues that will show up,|
|

236
00:07:18,120 --> 00:07:18,900
0,90 90,300 300,510 510,660 660,780
you know if we're going
如果我们要建立一个主备系统，

237
00:07:18,900 --> 00:07:21,960
0,60 60,420 420,1650 2130,2760 2760,3060
to build a {primary/backup -}

238
00:07:21,960 --> 00:07:23,460
0,390
system,|
|

239
00:07:25,040 --> 00:07:26,870
0,420 420,690 690,1020 1020,1380 1380,1830
and also concrete {} instances
在 VM FT 论文中有具体的这些问题。

240
00:07:26,870 --> 00:07:27,920
0,90 90,240 240,810 810,870 870,1050
of these problems in {}

241
00:07:27,920 --> 00:07:30,350
0,330 330,840 870,1050 1050,2070 2070,2430
in the the {VM,FT} paper.|
|

242
00:07:31,010 --> 00:07:33,980
0,570 750,900 900,1080 1080,2010 2310,2970
So {you,know} one {challenge,is} {}|
所以一个挑战是，|

243
00:07:33,980 --> 00:07:35,720
0,270 270,360 360,990 1020,1440 1440,1740
you know if a failure
如果失败发生，

244
00:07:35,720 --> 00:07:37,640
0,690 840,1050 1050,1500 1530,1830 1830,1920
happens,| you know has the
|主机真的失败了吗？

245
00:07:37,640 --> 00:07:39,840
0,420 420,630 630,1170
primary actually failed?|
|

246
00:07:47,690 --> 00:07:49,190
0,390 390,840 840,1290 1290,1440 1440,1500
A issue here you know
让这件事变得具有挑战性的一个问题是，

247
00:07:49,190 --> 00:07:50,360
0,150 150,360 360,510 510,1020 1020,1170
that makes this challenging is

248
00:07:50,360 --> 00:07:51,800
0,210 210,750 750,1110 1110,1200 1200,1440
that,| {in,distributed} systems,| you can't
|在分布式系统中，|你无法区分网络分区和机器故障，

249
00:07:51,800 --> 00:07:52,790
0,240 240,330 330,630 630,930 930,990
tell the difference between a

250
00:07:52,790 --> 00:07:54,080
0,330 330,720 720,870 870,930 930,1290
network partition and a machine

251
00:07:54,080 --> 00:07:54,950
0,330 330,540 540,630 630,780 780,870
failed,| so it might be
|所以完全有可能，

252
00:07:54,950 --> 00:07:57,350
0,450 450,900 900,1080 1080,1320 1560,2400
perfectly possible,| that the network,
|网络， primary 还在运行，

253
00:07:57,770 --> 00:07:58,790
0,330 330,540 540,630 630,960 960,1020
{} that the primary is
初选还在继续，

254
00:07:58,790 --> 00:07:59,870
0,240 240,510 510,690 690,900 900,1080
still up,| but you know
|但是有些计算机不能与 primary 交互，

255
00:07:59,870 --> 00:08:01,280
0,180 180,360 360,750 750,1110 1110,1410
that some computers cannot talk

256
00:08:01,280 --> 00:08:03,350
0,90 90,180 180,660 660,1380 1470,2070
to the primary,| because the
|因为网络已经分区，

257
00:08:03,350 --> 00:08:04,730
0,330 330,450 450,960 960,1230 1230,1380
network has partitioned,| and so
|比如， backup 可能会决定，

258
00:08:04,730 --> 00:08:05,780
0,60 60,390 390,480 480,870 870,1050
for example the backup might

259
00:08:05,780 --> 00:08:06,800
0,450 450,720 720,810 810,930 930,1020
decide,| that you know the
|primary 已经失效，

260
00:08:06,800 --> 00:08:08,120
0,360 360,420 420,690 690,960 960,1320
primary is dead,| because networks
|因为网络分区，

261
00:08:08,120 --> 00:08:09,830
0,540 720,990 990,1230 1230,1320 1320,1710
partitioned,| {but,in} fact the {primary,is}
|但是实际上 primary 并没有，

262
00:08:09,830 --> 00:08:11,300
0,240 240,510 870,1230 1230,1380 1380,1470
not that,| maybe some of
|也许有些客户端还能访问 primary ，

263
00:08:11,300 --> 00:08:12,320
0,60 60,450 450,510 510,750 750,1020
the clients are still able

264
00:08:12,320 --> 00:08:13,280
0,90 90,330 330,450 450,540 540,960
to talk to the primary,|
|

265
00:08:13,400 --> 00:08:14,060
0,180 180,330 330,450 450,540 540,660
so you have to have
所以你必须有一些[故事]

266
00:08:14,060 --> 00:08:16,490
0,240 240,870 1020,1710 1710,2010 2010,2430
some story| of making sure
|来确保你不会陷入有两个 primary 的情况。

267
00:08:16,490 --> 00:08:17,720
0,300 300,480 480,840 840,1080 1080,1230
that you don't end up

268
00:08:17,720 --> 00:08:19,670
0,150 150,180 180,930 1020,1770 1770,1950
in a situation where you

269
00:08:19,670 --> 00:08:20,960
0,120 120,330 330,1050
have two primaries.|
|

270
00:08:21,360 --> 00:08:22,860
0,150 150,510 510,600 600,1410 1410,1500
And again, you know we
同样地，我们上一次讨论了，

271
00:08:22,860 --> 00:08:23,760
0,210 210,270 270,480 480,630 630,900
talked a little bit about

272
00:08:23,760 --> 00:08:24,660
0,240 240,480 480,570 570,750 750,900
last time,| it shows up
|它再次出现在这篇论文中，

273
00:08:24,660 --> 00:08:25,560
0,60 60,240 240,510 510,810 810,900
in this paper again,| will
|下周也会出现，

274
00:08:25,560 --> 00:08:26,970
0,210 210,660 660,900 900,1110 1110,1410
show up next week too,|
|

275
00:08:27,120 --> 00:08:28,050
0,240 240,330 330,510 510,780 780,930
which is like we want
我们想要避免陷入这样的境地，

276
00:08:28,050 --> 00:08:29,100
0,60 60,630 660,810 810,900 900,1050
to avoid that we get

277
00:08:29,100 --> 00:08:30,210
0,180 180,210 210,720 720,930 930,1110
into a situation,| where there's
|有一个脑裂系统，

278
00:08:30,210 --> 00:08:32,680
0,300 300,690 690,1020 1020,1530
a {split-brain -} system,|
|

279
00:08:35,090 --> 00:08:36,020
0,390 390,540 540,750 750,840 840,930
where we {basically -} have
我们有两个 primary ，

280
00:08:36,020 --> 00:08:38,600
0,570 600,1440 1440,1710 1710,2220 2220,2580
two primaries,| and one subset
|一个客户端子集访问一个 primary ，

281
00:08:38,600 --> 00:08:40,160
0,60 60,450 450,840 840,1140 1140,1560
of client {talks,to} one primary,|
|

282
00:08:40,160 --> 00:08:40,880
0,120 120,210 210,360 360,660 660,720
and the other subset of
另一个客户端子集访问另一个 primary ，

283
00:08:40,880 --> 00:08:41,780
0,330 330,540 540,630 630,720 720,900
client talks to the other

284
00:08:41,780 --> 00:08:43,370
0,270 540,900 900,1260 1260,1440 1440,1590
primary,| and clearly that's going
|很明显这会产生系统状态的分歧，

285
00:08:43,370 --> 00:08:45,050
0,210 300,1050 1050,1200 1200,1380 1380,1680
to diverge {you,know} the state

286
00:08:45,050 --> 00:08:47,360
0,120 120,210 210,1110 1230,2010 2040,2310
of the system| {and,when} the
|当网络恢复时，我们处于错误的状态，

287
00:08:47,360 --> 00:08:49,580
0,300 300,990 1140,1530 1530,1800 1800,2220
network heals, {} we are

288
00:08:49,580 --> 00:08:51,320
0,150 150,330 330,810 810,1260 1410,1740
in an incorrect state,| so
|所以，我们必须不惜一切代价避免这种情况。

289
00:08:51,320 --> 00:08:52,160
0,90 90,210 210,270 270,540 540,840
we have to avoid this

290
00:08:52,160 --> 00:08:53,360
0,240 240,390 390,840
at all cost.|
|

291
00:08:54,230 --> 00:08:56,540
0,270 270,780 810,2100 2100,2160 2160,2310
The second { -} general
第二个挑战是，

292
00:08:56,540 --> 00:08:59,030
0,960 1290,1650 1650,1740 1740,1890 1890,2490
{challenge,is},| how do we keep
|我们如何才能保持，

293
00:08:59,330 --> 00:09:01,100
0,930 960,1290 1290,1500 1500,1680 1680,1770
the,| you know how do
|如何使主备保持同步。

294
00:09:01,100 --> 00:09:03,050
0,90 90,390 390,780 960,1500 1500,1950
we keep the {primary/backup -}

295
00:09:03,050 --> 00:09:04,160
0,90 90,570
in sync.|
|

296
00:09:14,000 --> 00:09:14,780
0,270 270,540 540,600 600,720 720,780
Our goal is going to
我们的目标是，

297
00:09:14,780 --> 00:09:16,820
0,210 210,570 570,1200 1200,1770 1770,2040
be that,| {} if the
|如果 primary 出现故障，

298
00:09:16,820 --> 00:09:17,900
0,360 360,750 750,870 870,960 960,1080
primary fails,| then we can
|然后，我们可以正常地切换到 backup ，

299
00:09:17,900 --> 00:09:19,850
0,300 300,720 720,1110 1110,1410 1410,1950
just gracefully fail over to

300
00:09:19,880 --> 00:09:21,140
0,510 510,600 600,660 660,990 990,1260
backup,| and the backup just
|backup 在 primary 停止的地方重新开始，

301
00:09:21,170 --> 00:09:22,340
0,270 270,420 420,750 750,960 960,1170
picks up right where the

302
00:09:22,340 --> 00:09:23,800
0,330 330,600 600,900
primary left off,|
|

303
00:09:23,920 --> 00:09:25,330
0,270 270,780 780,900 900,960 960,1410
that requires that the backup
这要求 backup 总是最新的，

304
00:09:25,330 --> 00:09:26,350
0,360 360,480 480,630 630,720 720,1020
actually is up to date,|
|

305
00:09:26,350 --> 00:09:27,700
0,480 480,600 600,900 900,1110 1110,1350
like the latest things that
有 primary 已经写入的最新状态，

306
00:09:27,700 --> 00:09:29,140
0,210 210,570 570,840 840,960 960,1440
are primary actually has written

307
00:09:29,410 --> 00:09:32,230
0,1080 1230,2070 2070,2250 2250,2520 2520,2820
{} {to,its,state},| so that actually
|以便操作可以无缝进行，

308
00:09:32,230 --> 00:09:33,700
0,180 180,390 390,720 720,1350 1350,1470
can pick up seamlessly| and
|而不会向客户端返回错误或无法响应，

309
00:09:33,700 --> 00:09:36,610
0,780 780,1230 1230,1710 1710,2130 2160,2910
don't return errors or responses

310
00:09:36,610 --> 00:09:37,750
0,90 90,510 510,570 570,690 690,1140
to {the,client} to {} completely

311
00:09:37,750 --> 00:09:38,920
0,720
unexpected,|
|

312
00:09:38,980 --> 00:09:40,720
0,210 210,270 270,630 630,1290 1380,1740
from the client's perspective,| really
从客户的角度来看，|真正看起来，

313
00:09:40,720 --> 00:09:41,530
0,120 120,270 270,450 450,720 720,810
what should look like,| you
|即使它是复制的，

314
00:09:41,530 --> 00:09:42,580
0,210 210,300 300,510 510,840 840,1050
know the whole thing even

315
00:09:42,580 --> 00:09:43,870
0,120 120,210 210,870 990,1170 1170,1290
though it's replicated,| like a
|就像一台计算机，

316
00:09:43,870 --> 00:09:45,220
0,270 270,780 810,1050 1050,1290 1290,1350
single computer,| just happens to
|只是比一台计算机具有更强的容错能力。

317
00:09:45,220 --> 00:09:46,360
0,90 90,150 150,360 360,510 510,1140
be a little more {fault,tolerant}

318
00:09:46,360 --> 00:09:47,740
0,120 120,180 180,450 450,870
than a single computer.|
|

319
00:09:48,680 --> 00:09:49,430
0,270 270,360 360,570 570,660 660,750
And that turns out to
事实证明，这是困难的，

320
00:09:49,430 --> 00:09:51,140
0,420 420,630 630,1260 1290,1410 1410,1710
be {} difficult,| you know
|首先，

321
00:09:51,140 --> 00:09:52,310
0,270 270,360 360,570 570,960 990,1170
first of all,| we have
|我们必须确保我们应用所有的变更，

322
00:09:52,310 --> 00:09:53,000
0,90 90,240 240,480 480,600 600,690
to make sure that we

323
00:09:53,000 --> 00:09:54,770
0,660 780,1110 1110,1560 1560,1680 1680,1770
apply all changes,| we have
|我们必须按正确的顺序应用变更，

324
00:09:54,770 --> 00:09:55,670
0,60 60,300 300,450 450,750 750,900
to apply the changes in

325
00:09:55,670 --> 00:09:57,160
0,90 90,300 300,780
the right order,|
|

326
00:10:01,880 --> 00:10:04,460
0,330 330,1170 1170,1830 1830,2100 2100,2580
and {you,know} {in,continuous} {} issue
在连续性问题中，

327
00:10:04,460 --> 00:10:06,530
0,150 150,510 510,1140 1530,1920 1920,2070
in {} that,| we have
|我们必须避免非决定论，

328
00:10:06,530 --> 00:10:07,460
0,90 90,300 300,360 360,720 720,930
to sort of avoid {non-determinism

329
00:10:07,460 --> 00:10:09,560
0,720 1200,1530 1530,1830 1830,2010 2010,2100
-},| or we have to
|或者我们必须解决非决定论，

330
00:10:09,560 --> 00:10:11,500
0,270 270,420 420,630 630,1320
deal with {non-determinism -},|
|

331
00:10:13,610 --> 00:10:14,930
0,240 240,330 330,420 420,750 750,1320
I mean the same change
我的意思是，相同的更改在 primary 的行为与在 backup 上的不同，

332
00:10:14,960 --> 00:10:16,820
0,240 240,330 330,1080 1080,1470 1470,1860
on the primary behaves different

333
00:10:16,820 --> 00:10:17,960
0,150 150,240 240,300 300,720 720,1140
{} on the backup,| because
|因为出于某种原因，这样并不好，

334
00:10:17,960 --> 00:10:19,010
0,90 90,270 270,630 630,930 930,1050
for some reason, that would

335
00:10:19,010 --> 00:10:20,060
0,90 90,300 300,570 600,720 720,1050
be not good,| you know
|我们必须确保，

336
00:10:20,060 --> 00:10:20,780
0,120 120,240 240,300 300,480 480,720
we got to make sure,|
|

337
00:10:20,780 --> 00:10:21,710
0,210 210,420 420,570 570,660 660,930
that we make a change
我们在主备上做的变更，

338
00:10:21,710 --> 00:10:22,730
0,90 90,150 150,480 480,780 780,1020
in the {primary/backup -}| very
|对主备有完全相同的作用。

339
00:10:22,730 --> 00:10:25,280
0,720 720,1320 1800,2010 2010,2160 2160,2550
identical effects to the {primary/backup

340
00:10:25,280 --> 00:10:26,280
0,510
-}.|
|

341
00:10:27,740 --> 00:10:30,080
0,360 360,1050 1380,1680 1680,1830 1830,2340
A similar issue that always
一个经常出现的问题，

342
00:10:30,080 --> 00:10:31,700
0,210 210,630 630,840 840,1140 1140,1620
shows up,| you know {challenge,is}
|一个挑战就是故障转移，

343
00:10:31,700 --> 00:10:33,020
0,300 300,690
fail over,|
|

344
00:10:35,460 --> 00:10:37,740
0,270 270,690 690,1230 1260,1920 1920,2280
{you,have} actually the primary fails,|
你的主机出现故障，|

345
00:10:37,740 --> 00:10:38,400
0,150 150,210 210,360 360,420 420,660
and we need to fail
我们需要切换到备机，

346
00:10:38,400 --> 00:10:40,320
0,480 480,870 870,960 960,1470 1710,1920
over to the backup,| and
|当然我们必须确保，

347
00:10:40,320 --> 00:10:41,130
0,150 150,450 450,630 630,750 750,810
of course we've got to

348
00:10:41,130 --> 00:10:42,840
0,150 150,390 390,1020 1470,1650 1650,1710
make sure that,| there are
|其他主机已经停机，

349
00:10:42,840 --> 00:10:45,180
0,210 210,510 510,990 990,1440 1560,2340
other {primary,is} definitely {} dead,|
|

350
00:10:45,390 --> 00:10:47,430
0,510 510,570 570,1230 1230,1590 1620,2040
but for example the primary
但是，比如主机可能在操作过程中，

351
00:10:47,430 --> 00:10:48,390
0,330 330,630 660,840 840,900 900,960
might have was in the

352
00:10:48,390 --> 00:10:50,130
0,240 240,330 330,390 390,1110 1110,1740
middle of an operation,| and
|它即将发送一个数据包，

353
00:10:50,370 --> 00:10:51,540
0,540 540,660 660,780 780,1110 1110,1170
{} it was about to

354
00:10:51,540 --> 00:10:52,350
0,210 210,240 240,570 570,750 750,810
send a packet out,| to
|对客户端进行回复，

355
00:10:52,350 --> 00:10:53,580
0,120 120,480 480,540 540,630 630,1230
the response to the client,|
|

356
00:10:53,760 --> 00:10:55,530
0,120 120,390 390,870 1140,1620 1620,1770
or maybe not,| and so
也可能不是，|所以我们要弄清楚，

357
00:10:55,530 --> 00:10:56,370
0,120 120,270 270,330 330,630 630,840
we got to figure out,|
|

358
00:10:56,370 --> 00:10:57,300
0,210 210,360 360,690 690,810 810,930
what that response that being
响应已经发送或没有发送，

359
00:10:57,300 --> 00:10:58,290
0,210 210,300 300,540 540,660 660,990
send or not being sent,|
|

360
00:10:58,320 --> 00:10:59,340
0,330 330,510 510,600 600,870 870,1020
or is it okay for
或者我们可以再发一次。

361
00:10:59,340 --> 00:11:00,120
0,60 60,180 180,360 360,450 450,780
us to send it again.|
|

362
00:11:01,960 --> 00:11:03,140
0,570

363
00:11:04,300 --> 00:11:05,890
0,660 660,720 720,990 990,1200 1200,1590
There's a question {in,the} chat,|
聊天中有一个问题，|

364
00:11:05,890 --> 00:11:07,150
0,150 150,570 600,810 810,1020 1020,1260
like when would fail over
什么时候需要进行故障转移，

365
00:11:07,150 --> 00:11:08,410
0,180 180,360 360,690 690,930 930,1260
need to happen,| {you,know} {fail,over}
|当主机停机后需要故障转移，

366
00:11:08,410 --> 00:11:09,190
0,180 180,240 240,510 510,690 690,780
need to happen when the

367
00:11:09,190 --> 00:11:11,440
0,420 420,750 810,1170 1350,1920 1920,2250
{primary,is} gone, right,| because then
|因为我们想要故障转移到备机，

368
00:11:11,440 --> 00:11:12,310
0,150 150,330 330,390 390,660 660,870
we want to fail over

369
00:11:12,310 --> 00:11:13,720
0,120 120,180 180,660 660,1020 1020,1410
to the backup,| that determine
|这取决于你的使用。

370
00:11:13,720 --> 00:11:15,000
0,240 240,360 360,780
all you used.|
|

371
00:11:16,860 --> 00:11:18,660
0,150 150,300 300,720 720,1410 1410,1800
And then often another issue
然后，另一个故障转移的问题是，

372
00:11:18,660 --> 00:11:20,160
0,120 120,330 330,690 690,1050 1170,1500
we fail over is,| who
|我们有多个备份，

373
00:11:20,160 --> 00:11:21,090
0,270 270,540 540,600 600,840 840,930
actually has to know we

374
00:11:21,090 --> 00:11:22,500
0,150 150,480 480,990 990,1260 1260,1410
have multiple backups,| which is
|不是今天论文中的情况，

375
00:11:22,500 --> 00:11:23,340
0,180 180,240 240,450 450,510 510,840
not the case in today's

376
00:11:23,340 --> 00:11:24,810
0,480 540,900 900,1020 1020,1230 1230,1470
paper,| {} yeah we actually
|是的，我们要问的是最新的[阶段]，

377
00:11:24,810 --> 00:11:25,890
0,180 180,270 270,570 570,930 930,1080
ask the latest [stage],| like
|比如，可能在一些操作后，它们都会崩溃，

378
00:11:25,890 --> 00:11:26,910
0,60 60,450 450,690 690,810 810,1020
for example, maybe they all

379
00:11:26,910 --> 00:11:28,650
0,450 450,750 750,870 870,1110 1110,1740
crash after a few operations,|
|

380
00:11:28,650 --> 00:11:30,180
0,150 150,270 270,540 540,870 900,1530
they come back up| and
它们回来，|我们要确保，

381
00:11:30,510 --> 00:11:33,120
0,540 540,1140 1140,1980 2250,2460 2460,2610
{} and {} and we're

382
00:11:33,120 --> 00:11:33,720
0,120 120,180 180,300 300,480 480,600
going to make sure that,|
|

383
00:11:33,720 --> 00:11:34,680
0,90 90,270 270,540 540,690 690,960
we're actually talking to one
我们与有最新的状态服务器交互，

384
00:11:34,680 --> 00:11:36,450
0,480 480,960 960,1380 1380,1710 1710,1770
that {has,the,most,recent} states,| this is
|这不是今天的一个问题，

385
00:11:36,450 --> 00:11:37,200
0,120 120,180 180,270 270,540 540,750
going to not an issue

386
00:11:37,200 --> 00:11:38,850
0,300 300,600 600,750 750,1200 1440,1650
today {} so much,| as
|我们稍后会知道为什么，

387
00:11:38,850 --> 00:11:39,570
0,90 90,270 270,360 360,390 390,720
we'll see in a second

388
00:11:39,570 --> 00:11:40,950
0,570 630,930 930,1050 1050,1200 1200,1380
why,| but we'll come up
|但我们之后会在其他复制协议中介绍。

389
00:11:40,950 --> 00:11:42,930
0,360 360,630 630,900 900,1320 1320,1980
later in other replication protocols.|
|

390
00:11:45,640 --> 00:11:46,720
0,180 180,330 330,630 630,870 870,1080
Yeah, so basically fail over
是的，所以故障转移意味着备机接管。

391
00:11:46,720 --> 00:11:48,190
0,390 390,600 600,930 930,1140 1140,1470
means the backup takes over.|
|

392
00:11:51,280 --> 00:11:53,170
0,540 660,1230 1350,1500 1500,1770 1770,1890
{} Okay, so that's sort
好的，这就是主要失败，

393
00:11:53,170 --> 00:11:54,520
0,270 420,630 630,1050 1080,1230 1230,1350
of the main you know

394
00:11:54,520 --> 00:11:55,900
0,510 510,630 630,930 930,1020 1020,1380
failure,| the type of failures
|我们希望处理的失败类型和主要挑战，

395
00:11:55,900 --> 00:11:57,100
0,90 90,180 180,420 420,630 630,1200
that we hope to handle

396
00:11:57,100 --> 00:11:59,320
0,240 240,480 480,720 720,1440 1740,2220
and the main challenges, {}|
|

397
00:11:59,320 --> 00:12:00,940
0,240 240,690 690,990 990,1170 1170,1620
in we'll deepen those challenges
随着我们继续，将会深入讨论这些挑战。

398
00:12:00,940 --> 00:12:02,770
0,180 180,330 330,540 540,1020 1140,1830
out as we go. {}|
|

399
00:12:03,070 --> 00:12:04,030
0,270 270,630 630,750 750,810 810,960
You {know,I} want to talk
我想谈谈两种主要的方法，

400
00:12:04,030 --> 00:12:06,160
0,420 420,960 960,1230 1230,1440 1440,2130
about two two main approaches,|
|

401
00:12:06,190 --> 00:12:06,970
0,240 240,420 420,630 630,720 720,780
that we'll see in a
我们将在一个学期内看到，

402
00:12:06,970 --> 00:12:09,490
0,660 810,1260 1260,1470 1470,2190 2190,2520
semester,| {} for dealing with
|用于处理主备复制。

403
00:12:09,490 --> 00:12:11,420
0,300 300,780 810,1500
{primary/backup -} replication.|
|

404
00:12:19,000 --> 00:12:20,140
0,480 480,570 570,780 780,810 810,1140
One is as I mentioned
一个是我前面提到的状态转移，

405
00:12:20,140 --> 00:12:23,050
0,660 1170,1410 1410,1680 1710,2160 2160,2910
earlier, that is state transfer,|
|

406
00:12:27,780 --> 00:12:29,070
0,120 120,240 240,480 480,1200 1200,1290
{you,know} {} these reasonable at
这些从高层来说是非常直截了当的，

407
00:12:29,070 --> 00:12:30,570
0,60 60,540 540,780 780,1440 1440,1500
a high-level very straightforward,| you
|我们有主机，

408
00:12:30,570 --> 00:12:31,740
0,120 120,240 240,390 390,450 450,1170
know we've got a primary,|
|

409
00:12:32,360 --> 00:12:33,380
0,360 360,450 450,570 570,930 930,1020
{} you know if you
如果客户端与主机交互，

410
00:12:33,380 --> 00:12:34,250
0,150 150,240 240,570 570,810 810,870
know the clients talk to

411
00:12:34,250 --> 00:12:36,320
0,90 90,810 1140,1410 1410,1500 1500,2070
the primary,| and the primary
|主机更新状态，

412
00:12:36,320 --> 00:12:38,270
0,600 600,990 990,1260 1260,1560 1560,1950
updated state,| once {} updated
|响应于客户端请求而更新状态，

413
00:12:38,270 --> 00:12:39,680
0,270 270,330 330,780 780,1080 1080,1410
state in response to client

414
00:12:39,680 --> 00:12:41,420
0,630 720,960 960,1170 1170,1260 1260,1740
request,| and once a while,
|每隔一段时间，会有一个检查点，

415
00:12:41,420 --> 00:12:43,400
0,270 270,480 480,1230
it {sort,of,makes} checkpoint,|
|

416
00:12:46,280 --> 00:12:47,400
0,570

417
00:12:48,240 --> 00:12:50,010
0,150 150,270 270,420 420,960 960,1770
once a while, basically checkpoints
每隔一段时间，检查点将状态给备机，

418
00:12:50,010 --> 00:12:51,780
0,120 120,720
{} state,

419
00:12:56,160 --> 00:12:58,000
0,210 210,360 360,540 540,1170
it's state {to,the} backup,|
|

420
00:13:01,120 --> 00:13:01,750
0,150 150,210 210,450 450,570 570,630
and of course if we
当然，如果我们希望备机和主机同步，

421
00:13:01,750 --> 00:13:02,920
0,210 210,450 450,1020 1020,1110 1110,1170
want the {backup -} and

422
00:13:02,920 --> 00:13:03,970
0,90 90,540 540,660 660,900 900,1050
the primary to be in

423
00:13:03,970 --> 00:13:05,200
0,540 540,660 660,900 900,1050 1050,1230
sync,| that means that every
|这意味着每次主机执行操作，

424
00:13:05,200 --> 00:13:06,610
0,180 180,270 270,690 690,990 990,1410
time the primary actually performs

425
00:13:06,610 --> 00:13:08,950
0,60 60,840 1140,1830 1830,1920 1920,2340
the operation,| before it responds
|在响应客户端之前，

426
00:13:08,950 --> 00:13:10,660
0,90 90,780 840,990 990,1350 1350,1710
to {the,client},| it basically has
|它必须传输操作所做的状态变更到备机。

427
00:13:10,660 --> 00:13:12,400
0,90 90,660 660,990 990,1320 1320,1740
to transfer whatever state changes

428
00:13:12,400 --> 00:13:13,240
0,120 120,270 270,630 630,750 750,840
that were made by the

429
00:13:13,240 --> 00:13:14,860
0,570 570,1110
operation {to,the,backup}.|
|

430
00:13:15,480 --> 00:13:17,580
0,450 450,570 570,900 900,1470 1500,2100
{} So that's one scheme.|
所以这是一个方案。|

431
00:13:17,970 --> 00:13:20,100
0,360 360,960 960,1200 1260,1830 1830,2130
{} One of high-level approach,
另一种高级别的方法，第二种方法是，

432
00:13:20,100 --> 00:13:22,140
0,60 60,270 270,960 1080,1800 1800,2040
{} second approach {} is,|
|

433
00:13:22,140 --> 00:13:23,910
0,690 990,1140 1140,1350 1350,1380 1380,1770
what is called {} replicated
称为复制状态机，状态机复制，

434
00:13:23,910 --> 00:13:26,460
0,240 240,900
state machine,

435
00:13:27,510 --> 00:13:29,660
0,360 360,660 660,1470
state machine replication,|
|

436
00:13:32,920 --> 00:13:35,110
0,690 720,1290 1290,1470 1470,1740 1740,2190
often shortened to {RSM -}.|
通常简称为 RSM 。|

437
00:13:36,180 --> 00:13:37,440
0,150 150,600 600,690 690,810 810,1260
And here you know the
在这里，图片是，

438
00:13:37,830 --> 00:13:39,060
0,510 510,600 600,690 690,840 840,1230
{} you know the picture

439
00:13:39,060 --> 00:13:40,440
0,630 690,960 960,1170 1170,1290 1290,1380
is,| we still got the
|我们仍然有主机，

440
00:13:40,440 --> 00:13:41,820
0,480 480,630 630,750 750,810 810,1380
primary,| we've got the client
|我们有客户端访问主机，

441
00:13:41,910 --> 00:13:43,470
0,300 300,390 390,480 480,1170 1410,1560
talking to the primary,| and
|当然，我们有主机与备机交互，

442
00:13:43,470 --> 00:13:44,400
0,120 120,420 420,690 690,840 840,930
of course we have the

443
00:13:44,400 --> 00:13:45,690
0,300 300,540 540,750 750,1200 1200,1290
primary talking to backup| to
|以保持备备机同步，

444
00:13:45,690 --> 00:13:46,830
0,180 180,240 240,570 570,690 690,1140
keep the backup in sync,|
|

445
00:13:47,040 --> 00:13:48,360
0,240 240,660 660,780 780,960 960,1320
but instead it { -}
但是不是发送状态变更，

446
00:13:48,360 --> 00:13:51,240
0,240 240,420 450,1140 2010,2760 2760,2880
sending the state changes or

447
00:13:51,240 --> 00:13:52,410
0,630 630,720 720,810 810,1080 1080,1170
modifications to the state| from
|从主机到备机，

448
00:13:52,410 --> 00:13:53,310
0,90 90,330 330,420 420,480 480,900
the primary to the backup,|
|

449
00:13:53,400 --> 00:13:54,390
0,210 210,300 300,420 420,750 750,990
but we do actually sent
而是发送操作给备机，

450
00:13:54,390 --> 00:13:55,780
0,120 120,1020
the operations

451
00:13:56,190 --> 00:13:57,580
0,210 210,270 270,750
to the backup,|
|

452
00:13:58,990 --> 00:14:00,730
0,330 330,690 690,870 870,1290 1290,1740
so before the primary response
所以，在主机响应客户端之前，

453
00:14:00,730 --> 00:14:02,290
0,150 150,840 840,960 960,1080 1080,1560
to {the,client},| you know executing
|执行它的操作，

454
00:14:02,290 --> 00:14:04,240
0,120 120,810 1020,1320 1320,1590 1590,1950
its operation,| we sent the
|我们将客户端发送给我们的操作发送给备机，

455
00:14:04,240 --> 00:14:05,560
0,480 480,570 570,960 960,1200 1200,1320
operation that {the,client} sent to

456
00:14:05,560 --> 00:14:07,090
0,210 210,510 510,600 600,1140 1320,1530
us to the backup,| the
|备机也可以执行操作，

457
00:14:07,090 --> 00:14:08,530
0,360 360,480 480,870 870,960 960,1440
backup can execute the operation

458
00:14:08,530 --> 00:14:11,470
0,540 840,1320 1320,1830 1830,2430 2430,2940
too,| {} updated state, {acknowledge,it}
|更新状态，向主机确认，

459
00:14:11,470 --> 00:14:12,820
0,150 150,240 240,690 690,1050 1050,1350
to the primary,| primary actually
|主机也更新它的状态，

460
00:14:12,820 --> 00:14:14,140
0,300 300,450 450,720 720,990 990,1320
updates its state too,| {you,know}
|执行操作，

461
00:14:14,140 --> 00:14:15,550
0,420 420,510 510,1080 1080,1260 1260,1410
execute the operation,| and then
|然后将响应发送回客户端。

462
00:14:15,550 --> 00:14:17,110
0,240 240,300 300,690 690,930 930,1560
sends a response back to

463
00:14:17,260 --> 00:14:18,200
0,60 60,510
the client.|
|

464
00:14:19,500 --> 00:14:21,360
0,540 570,840 840,990 990,1470 1470,1860
And so in all these
所以在所有这两种方法中，

465
00:14:21,390 --> 00:14:23,490
0,270 270,540 960,1470 1470,1650 1650,2100
sort of, in all these

466
00:14:23,520 --> 00:14:25,560
0,630 630,1290 1350,1470 1470,1590 1590,2040
both approaches,| you know the
|计划是主机有一些状态，

467
00:14:25,560 --> 00:14:27,030
0,360 360,690 690,1020 1020,1410 1410,1470
scheme is the primary of

468
00:14:27,030 --> 00:14:28,980
0,150 150,480 480,1020 1380,1770 1770,1950
some particular state,| {} we
|我们应用变更到这些状态，

469
00:14:28,980 --> 00:14:30,690
0,480 480,960 960,1080 1080,1170 1170,1710
apply changes to the state,|
|

470
00:14:31,020 --> 00:14:32,940
0,600 690,870 870,1110 1110,1260 1260,1920
{} and we do exactly
我们对备机做完全相同的操作，

471
00:14:32,940 --> 00:14:33,510
0,90 90,300 300,450 450,510 510,570
the same thing as the

472
00:14:33,510 --> 00:14:34,650
0,360 360,450 450,540 540,870 870,1140
backup,| so the backup system
|备机与主机有相同的开始状态，

473
00:14:34,650 --> 00:14:35,520
0,330 330,510 510,570 570,630 630,870
starts out in the same

474
00:14:35,520 --> 00:14:36,870
0,300 300,450 450,540 540,1140 1200,1350
state as the primary,| we
|我们将同样的变更应用于状态，

475
00:14:36,870 --> 00:14:38,100
0,270 270,390 390,630 630,1110 1110,1230
apply the same changes to

476
00:14:38,100 --> 00:14:38,910
0,60 60,360 360,510 510,630 630,810
the state,| where it's through
|通过操作状态转移，

477
00:14:38,910 --> 00:14:40,500
0,60 60,720 720,960 960,1200 1200,1590
an operation state {transfer -},|
|

478
00:14:40,530 --> 00:14:41,100
0,180 180,300 300,420 420,510 510,570
we end up in a
我们最终进入了一个新的状态，

479
00:14:41,100 --> 00:14:42,330
0,210 210,660 780,870 870,990 990,1230
new state,| and that state
|并且该状态必须与主机的状态相同。

480
00:14:42,330 --> 00:14:43,290
0,150 150,210 210,300 300,840 840,960
has to be identical to

481
00:14:43,290 --> 00:14:44,220
0,60 60,330 330,420 420,510 510,930
the state that the primary

482
00:14:44,220 --> 00:14:44,920
0,390
has.|
|

483
00:14:45,200 --> 00:14:46,580
0,120 120,240 240,750 780,1140 1140,1380
And so even ever there's
所以，如果失败了，

484
00:14:46,580 --> 00:14:48,170
0,60 60,690 870,1350 1350,1440 1440,1590
a failure,| {} you know,
|我们故障切换到备份时，

485
00:14:48,170 --> 00:14:49,250
0,180 180,570 570,750 750,960 960,1080
we know that when we

486
00:14:49,250 --> 00:14:50,450
0,180 180,390 390,570 570,1050 1050,1200
fail over to backup,| and
|它与主机的状态完全相同，

487
00:14:50,450 --> 00:14:51,800
0,120 120,660 660,750 750,1020 1020,1350
it's exactly the same state

488
00:14:51,800 --> 00:14:52,790
0,120 120,210 210,720 720,810 810,990
as the primary,| and so
|所以，它可以接管。

489
00:14:52,790 --> 00:14:54,440
0,390 390,570 570,780 780,1110
it can take over.|
|

490
00:14:55,750 --> 00:14:56,900
0,600

491
00:14:57,190 --> 00:14:58,090
0,330 330,540 540,600 600,720 720,900
We'll see you know this
我们会看到这是一种挑战，

492
00:14:58,090 --> 00:14:59,470
0,60 60,300 300,960 960,1110 1110,1380
is actually challenging to actually

493
00:14:59,470 --> 00:15:00,700
0,150 150,570 570,840 840,1140 1140,1230
make happen,| but that's the
|但这是基本的计划，

494
00:15:00,700 --> 00:15:04,240
0,330 330,720 1290,1890 2370,2970
basic plan,| {} the
|两种方法都是很受欢迎的，

495
00:15:04,300 --> 00:15:06,130
0,930 930,1200 1200,1500 1500,1740 1740,1830
primary {} both approach is

496
00:15:06,130 --> 00:15:08,110
0,330 330,660 660,1470 1470,1650 1650,1980
actually reasonable popular,| the primary
|状态转移方法的主要缺点是，

497
00:15:08,110 --> 00:15:10,720
0,960 960,1620 1620,2040 2040,2460 2460,2610
disadvantages, {the,state} transfer approach is

498
00:15:10,720 --> 00:15:12,340
0,300 300,630 630,690 690,1230 1230,1620
that,| if an operation generates
|如果一个操作生成很多状态，

499
00:15:12,340 --> 00:15:13,870
0,60 60,300 300,360 360,930 1290,1530
a lot of state, {}|
|

500
00:15:13,870 --> 00:15:14,410
0,180 180,300 300,420 420,480 480,540
then it's going to be
那就会很昂贵了，

501
00:15:14,410 --> 00:15:16,540
0,660 1230,1350 1350,1380 1380,1650 1650,2130
expensive,| for a single operation
|对于单个操作写入千兆字节的数据，

502
00:15:16,540 --> 00:15:17,530
0,210 210,270 270,630 630,690 690,990
writes {} gigabyte of data,|
|

503
00:15:17,530 --> 00:15:18,880
0,480 480,840 840,930 930,1200 1200,1350
then gigabyte of data needs
然后千兆字节的数据需要传输到备机，

504
00:15:18,880 --> 00:15:20,590
0,90 90,180 180,630 630,1140 1170,1710
to be transferred to {the,primary}

505
00:15:20,890 --> 00:15:22,060
0,180 180,240 240,510 510,780 930,1170
{} to {the,backup -},| and
|而且它可能要昂贵得多，便宜得多，

506
00:15:22,060 --> 00:15:22,960
0,120 120,300 300,390 390,720 720,900
it might be much more

507
00:15:22,960 --> 00:15:25,090
0,480 480,720 720,960 960,1560 1560,2130
expensive, much more, less expensive|
|

508
00:15:25,090 --> 00:15:26,290
0,120 120,540 540,720 720,930 930,1200
to basically just send over
只把操作发送给备机，

509
00:15:26,290 --> 00:15:27,520
0,120 120,630 630,750 750,810 810,1230
the operation to the backups,|
|

510
00:15:27,670 --> 00:15:29,820
0,600 600,750 750,1200 1200,1740
backup can executing operation.|
备机就可以执行操作。|

511
00:15:30,710 --> 00:15:32,120
0,420 450,780 780,870 870,930 930,1410
So many of the systems
我们讨论的许多系统，

512
00:15:32,120 --> 00:15:35,210
0,330 330,1860 1920,2490 2490,2760 2760,3090
that we're talking about,| actually
|它们使用第二种方法，

513
00:15:35,210 --> 00:15:36,800
0,360 360,600 600,720 720,990 990,1590
they're follow the second approach|
|

514
00:15:37,010 --> 00:15:38,840
0,600 600,780 780,1050 1050,1170 1170,1830
where they send the operation,
它们发送操作，而不是状态转移。

515
00:15:38,840 --> 00:15:40,220
0,150 150,420 420,510 510,780 780,1380
but not the state transfer.|
|

516
00:15:41,080 --> 00:15:43,000
0,630 780,1260 1260,1380 1380,1650 1650,1920
And {} in fact if
事实上，如果你想一想 GFS ，

517
00:15:43,000 --> 00:15:45,580
0,420 450,690 690,1230 1260,1740 1740,2580
you think about {} GFS,|
|

518
00:15:45,640 --> 00:15:47,590
0,720 720,1170 1170,1560 1560,1650 1650,1950
{} the discussion from last
上周讨论的，

519
00:15:47,590 --> 00:15:49,030
0,390 540,870 870,1110 1110,1260 1260,1440
week,| when we just saw
|我们可以看到，

520
00:15:49,030 --> 00:15:50,500
0,180 180,480 480,570 570,1140 1140,1470
that,| basically the primary sends
|主机发送追加操作或写入操作给备机，

521
00:15:50,500 --> 00:15:52,540
0,450 480,1110 1110,1290 1290,1920 1920,2040
the {append -} operations or

522
00:15:52,540 --> 00:15:54,340
0,120 120,390 390,1140 1350,1740 1740,1800
the write operations to the

523
00:15:54,340 --> 00:15:56,260
0,630 750,1290 1290,1410 1410,1500 1500,1920
backups,| doesn't do the append
|不是执行追加操作，然后将结果发送到备机，

524
00:15:56,260 --> 00:15:57,400
0,120 120,240 240,450 450,540 540,1140
and then send the result

525
00:15:57,580 --> 00:15:58,960
0,210 210,600 630,1020 1020,1140 1140,1380
to the backups,| that actually
|它实际上发送操作，

526
00:15:58,960 --> 00:16:00,370
0,210 210,330 330,1050 1050,1170 1170,1410
sends the operations,| so that's
|所以这是复制状态机方法的一个示例，

527
00:16:00,370 --> 00:16:01,990
0,90 90,750 780,1080 1080,1140 1140,1620
an example of a replicated

528
00:16:01,990 --> 00:16:03,550
0,210 210,450 450,1080 1170,1410 1410,1560
state machine approach,| where we'll
|我们将发送操作。

529
00:16:03,550 --> 00:16:05,060
0,90 90,390 390,1110
be sending operations.|
|

530
00:16:05,060 --> 00:16:06,500
0,420 420,510 510,750 750,840 840,1440
And the paper of today
今天的论文也遵循了复制状态机的方法，

531
00:16:06,590 --> 00:16:08,060
0,360 360,630 630,750 750,1260 1260,1470
also follows this replicated state

532
00:16:08,060 --> 00:16:09,770
0,240 240,660 660,1080 1080,1170 1170,1710
machine approach,| where the operations
|操作不是追加和写入，

533
00:16:09,770 --> 00:16:11,750
0,120 120,660 810,1350 1350,1560 1560,1980
are not {you,know,append} and write,|
|

534
00:16:12,050 --> 00:16:13,220
0,300 300,540 540,840 840,960 960,1170
{} file system {append -},
文件系统附加，文件系统写入，

535
00:16:13,220 --> 00:16:14,480
0,240 240,510 510,930 960,1170 1170,1260
file system write,| but the
|而是这些操作是 x86 指令，

536
00:16:14,480 --> 00:16:16,670
0,480 480,690 690,990 990,1650 1650,2190
operations are actually x86 instructions,|
|

537
00:16:16,670 --> 00:16:18,650
0,360 510,1020 1350,1770 1770,1920 1920,1980
you know we'll see {}
我们稍后会看到，

538
00:16:18,650 --> 00:16:19,520
0,390
later,|
|

539
00:16:19,640 --> 00:16:21,920
0,300 300,450 450,1200 1410,2220 2220,2280
{} but they both you
但它们都是发送操作。

540
00:16:21,920 --> 00:16:23,500
0,90 90,330 330,1080
know send operations.|
|

541
00:16:24,560 --> 00:16:26,810
0,720 1200,1800 1800,1920 1920,1950 1950,2250
In labs, as I mentioned
在实验中，正如我前面提到的，

542
00:16:26,810 --> 00:16:28,280
0,330 330,660 660,840 840,960 960,1470
earlier,| lab 3 and 4
|实验 3 和实验 4 也是复制状态机方法，

543
00:16:28,340 --> 00:16:30,590
0,540 540,780 780,1740 1740,1860 1860,2250
{} are also a replicated

544
00:16:30,590 --> 00:16:32,570
0,180 180,630 690,1170 1170,1710 1710,1980
state machine {} approach,| where
|我们发送操作从主机到备机。

545
00:16:32,570 --> 00:16:34,070
0,330 330,480 480,600 600,900 900,1500
we're gonna be sending operations

546
00:16:34,070 --> 00:16:35,660
0,180 180,570 570,690 690,1050
from primary to backup.|
|

547
00:16:40,710 --> 00:16:42,120
0,150 150,390 390,840
{} As a.|
作为。|

548
00:16:47,330 --> 00:16:48,350
0,330 330,330 330,660 660,750 750,1020
Okay, {there's,a} question in chat,|
聊天中有个问题，|

549
00:16:48,350 --> 00:16:49,340
0,180 180,390 390,480 480,870 870,990
why does the client do
为什么客户端不需要发送数据给备机，

550
00:16:49,340 --> 00:16:50,810
0,390 390,780 900,1200 1200,1380 1380,1470
not send not need to

551
00:16:50,810 --> 00:16:51,950
0,330 330,450 450,720 720,870 870,1140
send the data to {backup

552
00:16:51,950 --> 00:16:53,240
0,150 150,390 390,810 810,990 990,1290
-}| {in,our} replication state machine,|
|在我们的复制状态机中，|

553
00:16:53,240 --> 00:16:55,730
0,480 660,1380 1560,1830 1830,2250 2250,2490
because the the idea is
因为这个想法是这些操作是确定性的，

554
00:16:55,730 --> 00:16:57,530
0,120 120,300 300,780 780,900 900,1800
that these operations are deterministic,|
|

555
00:16:57,560 --> 00:16:58,700
0,270 270,480 480,600 600,1020 1020,1140
and so the primary and
所以主机，你记得，

556
00:16:58,700 --> 00:16:59,960
0,210 210,450 450,570 570,990 990,1260
this you know remember,| we'll
|我们会更详细地讨论这个，

557
00:17:00,110 --> 00:17:00,920
0,300 300,450 450,570 570,630 630,810
talk about this in much

558
00:17:00,920 --> 00:17:01,790
0,90 90,330 330,420 420,510 510,870
more detail,| but the {primary/backup
|但是主备处于相同的状态，

559
00:17:01,790 --> 00:17:02,780
0,390 390,570 570,660 660,720 720,990
-} are in the same

560
00:17:02,780 --> 00:17:04,680
0,360 360,630 630,930 930,1350
state,| same state as
|相同的状态，

561
00:17:04,680 --> 00:17:07,320
0,540 690,1260 1650,2160 2160,2550 2550,2640
{} the,| {} if the
|如果操作是确定性的，

562
00:17:07,320 --> 00:17:09,270
0,480 480,570 570,1500 1530,1860 1860,1950
operation is deterministic,| and you
|你把它应用于相同的状态，

563
00:17:09,270 --> 00:17:10,020
0,240 240,360 360,420 420,510 510,750
apply it to the same

564
00:17:10,020 --> 00:17:10,980
0,480 480,570 570,690 690,840 840,960
state,| you know they will
|它们最终会和主机处于相同的状态，

565
00:17:10,980 --> 00:17:11,730
0,180 180,330 330,420 420,480 480,750
end up in the same

566
00:17:11,730 --> 00:17:13,220
0,360 360,510 510,960
state as primary,|
|

567
00:17:13,400 --> 00:17:14,480
0,180 180,330 330,570 570,720 720,1080
and so there's no reason
所以，应用程序、客户端没有理由发送数据，

568
00:17:14,480 --> 00:17:15,890
0,330 330,600 600,930 960,1350 1350,1410
for the application, {the,client} to

569
00:17:15,890 --> 00:17:17,060
0,180 180,240 240,750 780,1050 1050,1170
send the data,| in this
|在这种情况下，

570
00:17:17,060 --> 00:17:18,470
0,210 210,480 480,660 660,990 990,1410
case,| because by just sending
|因为只要发送这个确定性的操作，

571
00:17:18,470 --> 00:17:20,480
0,180 180,840 840,1470 1590,1800 1800,2010
this deterministic operation,| it is
|就可以保证，

572
00:17:20,480 --> 00:17:22,340
0,720 720,1020 1020,1410 1410,1500 1500,1860
guaranteed,| that operation will generate
|操作将生成相同的数据。

573
00:17:22,340 --> 00:17:23,520
0,60 60,300 300,660
the same data.|
|

574
00:17:26,800 --> 00:17:28,420
0,270 300,510 510,1110 1110,1470 1470,1620
{} So subsequent {question,is},| how
所以接下来的问题是，|怎么知道所有程序和操作，

575
00:17:28,420 --> 00:17:29,350
0,90 90,240 240,630 630,780 780,930
do you know for all

576
00:17:29,350 --> 00:17:30,670
0,450 450,540 540,660 660,1140 1140,1320
programs and their operations,| whether
|它们是确定性的还是非确定性的，

577
00:17:30,670 --> 00:17:31,930
0,90 90,270 300,720 810,930 930,1260
they are deterministic or {non-deterministic

578
00:17:31,930 --> 00:17:33,490
0,570 690,840 840,960 960,1140 1140,1560
-},| to know what information
|知道需要发送哪些信息。

579
00:17:33,490 --> 00:17:34,870
0,120 120,180 180,270 270,660 1140,1380
needs to be sent. {}|
|

580
00:17:34,870 --> 00:17:36,280
0,150 150,270 270,600 600,1110 1110,1410
So the typical approaches do
所以在复制状态机方法中的典型做法是，

581
00:17:36,280 --> 00:17:37,330
0,120 120,150 150,540 540,720 720,1050
in a replicated state machine

582
00:17:37,330 --> 00:17:38,620
0,420 420,630 630,750 750,1020 1020,1290
approach is| to make all
|使所有操作都是确定性的，

583
00:17:38,620 --> 00:17:40,320
0,450 450,1230
operations deterministic,|
|

584
00:17:40,320 --> 00:17:42,060
0,450 450,990 990,1410 1410,1500 1500,1740
{non-deterministic -} operations are not
不允许非确定性操作，

585
00:17:42,060 --> 00:17:43,290
0,450 540,840 840,990 990,1170 1170,1230
allowed,| and we'll see in
|我们很快会看到如何做到这个。

586
00:17:43,290 --> 00:17:43,920
0,30 30,300 300,420 420,540 540,630
a second how to do

587
00:17:43,920 --> 00:17:44,800
0,300
that.|
|

588
00:17:48,650 --> 00:17:50,750
0,570 660,840 840,1380 1380,1500 1500,2100
Okay, so before {you,know} go
好的，在你知道更多细节之前，

589
00:17:50,750 --> 00:17:51,440
0,240 240,270 270,420 420,540 540,690
into a little bit more

590
00:17:51,440 --> 00:17:53,840
0,660 990,1830
specific, {}|
|

591
00:17:54,660 --> 00:17:56,610
0,390 390,480 480,780 780,1440 1620,1950
and a hybrid approach,| {yes
有一种混合方法，|是的，有一种混合方法，

592
00:17:56,610 --> 00:17:58,200
0,390 390,540 540,840 840,1410 1440,1590
-} you know {} {there,a}

593
00:17:58,200 --> 00:17:59,400
0,390 390,960 960,1050 1050,1140 1140,1200
hybrid approach,| you know for
|例如，你可以运行

594
00:17:59,400 --> 00:18:01,020
0,300 300,570 570,720 750,1470 1470,1620
example you can run sort

595
00:18:01,020 --> 00:18:01,830
0,60 60,210 210,660 660,750 750,810
of| by default in a
|默认情况下以复制状态机方法，

596
00:18:01,830 --> 00:18:05,670
0,420 420,630 630,870 870,1560 1830,3840
replicated state machine approach, {}|
|

597
00:18:05,670 --> 00:18:07,020
0,480 480,810 810,960 960,1140 1140,1350
{in,the,fact}, so in some ways
实际上，这篇论文在某些方面做了这一点，

598
00:18:07,020 --> 00:18:09,180
0,90 90,870 870,1140 1140,1590 1710,2160
the paper does this,| then
|如果备机失败或主机失败，

599
00:18:09,180 --> 00:18:12,690
0,780 780,2130 2160,2790 2790,3300 3300,3510
if a backup fails or

600
00:18:12,690 --> 00:18:13,650
0,360 360,660 660,750 750,870 870,960
primary fails,| and you go
|你回到一台单独的机器，

601
00:18:13,650 --> 00:18:14,850
0,210 210,300 300,360 360,630 630,1200
back to a single machine,|
|

602
00:18:15,030 --> 00:18:16,620
0,600 600,720 720,930 930,1320 1320,1590
then you need to create
然后，你需要创建一个新副本，

603
00:18:16,620 --> 00:18:18,060
0,30 30,180 180,690 720,870 870,1440
a new replica,| and often
|通常对于你创建的新副本，

604
00:18:18,120 --> 00:18:19,200
0,300 300,720 720,810 810,990 990,1080
new replica the way you

605
00:18:19,200 --> 00:18:20,190
0,180 180,300 300,420 420,660 660,990
do,| it is actually by
|它是通过转移现有副本的状态，

606
00:18:20,280 --> 00:18:21,930
0,690 690,780 780,1080 1080,1290 1290,1650
transferring the state from the

607
00:18:22,080 --> 00:18:23,730
0,600 600,1080 1080,1230 1230,1290 1290,1650
existing replica| or {} copy
|或复制现有副本的状态到新的副本，

608
00:18:23,730 --> 00:18:24,630
0,60 60,150 150,390 390,480 480,900
of the state of existing

609
00:18:24,630 --> 00:18:25,800
0,360 360,450 450,510 510,690 690,1170
replica to the new replica,|
|

610
00:18:26,990 --> 00:18:29,150
0,450 450,1020 1050,1560 1560,1800 1800,2160
without like hopefully less frequent
不是那么频繁的操作。

611
00:18:29,150 --> 00:18:30,360
0,630
operation.|
|

612
00:18:30,760 --> 00:18:32,080
0,240 240,420 420,810 810,900 900,1320
And then actually {you,know} during,|
然后在，|

613
00:18:32,080 --> 00:18:35,950
0,0 1260,1950 2460,3210 3210,3300 3300,3870
{} then replicating the operations
然后频繁地复制你正在做的操作。

614
00:18:35,950 --> 00:18:37,150
0,150 150,450 450,630 630,750 750,1200
you're doing much more frequently.|
|

615
00:18:39,810 --> 00:18:41,400
0,480 540,900 900,1200 1200,1440 1440,1590
{} Also free, {} feel
同时可以实时自由地提问，

616
00:18:41,400 --> 00:18:42,930
0,180 180,270 270,540 540,1170 1200,1530
free to ask questions in

617
00:18:42,930 --> 00:18:44,460
0,180 180,480 480,600 600,960 960,1530
real time| as opposed to
|而不是在聊天中打字，

618
00:18:44,490 --> 00:18:45,510
0,270 270,450 450,540 540,810 840,1020
typing in the chat,| either
|哪种方式都可以，但是。

619
00:18:45,510 --> 00:18:46,980
0,150 150,240 240,570 630,930 1110,1470
way is fine, but. {}|
|

620
00:18:48,080 --> 00:18:49,970
0,600 630,1140 1440,1620 1620,1800 1800,1890
Okay, so, {} as I
好的，正如我提到的，

621
00:18:49,970 --> 00:18:51,530
0,540 630,780 780,1020 1020,1140 1140,1560
hinted,| {you,know} with this replicated
|使用这种复制状态机方法，

622
00:18:51,530 --> 00:18:53,030
0,180 180,390 390,930 1110,1470 1470,1500
state machine approach,| there's a
|有一个问题，

623
00:18:53,030 --> 00:18:55,540
0,330 330,810 930,1320 1320,1950
question about| what level
|执行什么级别的复制，

624
00:18:56,660 --> 00:18:58,340
0,660 660,810 810,1320 1320,1380 1380,1680
{} of replication are doing|
|

625
00:18:58,340 --> 00:19:00,080
0,120 120,270 270,600 600,780 780,1740
or what level of operations
或要复制什么级别的操作。

626
00:19:04,380 --> 00:19:06,100
0,150 150,750
to replicate.|
|

627
00:19:10,320 --> 00:19:12,020
0,720

628
00:19:12,540 --> 00:19:14,910
0,240 240,330 330,870 1320,1710 1710,2370
So {one - - -}
一种可能是应用程序级别的操作，

629
00:19:14,910 --> 00:19:16,770
0,90 90,420 420,1110 1110,1290 1290,1860
one of possibilities {sort,of} application

630
00:19:16,770 --> 00:19:18,420
0,330 330,1170
level operations,|
|

631
00:19:35,600 --> 00:19:37,310
0,210 210,360 360,450 450,1140 1140,1710
so what I mean is,|
所以我的意思是，|

632
00:19:37,310 --> 00:19:39,590
0,120 120,750 750,930 930,1560 1560,2280
you know think back GFS,|
回想一下 GFS ，|

633
00:19:39,770 --> 00:19:41,120
0,180 180,510 510,750 750,870 870,1350
like whether it's {append -}
比如它的文件追加或写入。

634
00:19:41,150 --> 00:19:42,900
0,330 330,780
file append

635
00:19:46,800 --> 00:19:48,180
0,720
{or,write}.|
|

636
00:19:50,900 --> 00:19:54,620
0,660 750,1410 1800,2100 2100,3300 3300,3720
{} Another and okay and|
另一方面，好的，|

637
00:19:54,950 --> 00:19:56,330
0,300 330,600 600,900 900,990 990,1380
if you play a game
如果你玩一个复制状态机的游戏，

638
00:19:56,330 --> 00:19:57,650
0,180 180,600 600,810 810,1080 1080,1320
{sort,of} replicate state machine game|
|

639
00:19:57,650 --> 00:19:58,550
0,90 90,180 180,510 510,630 630,900
at the level of these
在应用程序级别的操作上，

640
00:19:58,550 --> 00:20:00,230
0,600 600,810 810,1260 1260,1410 1410,1680
application level operations,| that means
|这意味着必须涉及到应用程序，

641
00:20:00,230 --> 00:20:01,100
0,150 150,210 210,630 630,780 780,870
that the application has to

642
00:20:01,100 --> 00:20:02,840
0,90 90,660 720,1230 1260,1470 1470,1740
be involved,| because it knows
|因为它知道这些操作的语义是什么。

643
00:20:02,840 --> 00:20:03,860
0,150 150,210 210,780 780,870 870,1020
what the semantics of these

644
00:20:03,860 --> 00:20:05,220
0,600 600,900
operations are,|
|

645
00:20:05,280 --> 00:20:06,270
0,120 120,360 360,570 570,810 810,990
and then it knows what
它知道追加实际应该做什么，

646
00:20:06,270 --> 00:20:07,350
0,120 120,540 540,750 750,1020 1020,1080
{append -} actually supposed to

647
00:20:07,350 --> 00:20:09,270
0,420 840,1290 1290,1470 1470,1710 1710,1920
do,| {} or what write
|或者写入应该做什么，

648
00:20:09,270 --> 00:20:10,140
0,90 90,390 390,450 450,720 720,870
you're supposed to do,| and
|所以，如果你使用复制状态机方法，

649
00:20:10,140 --> 00:20:11,670
0,360 540,840 840,930 930,1140 1140,1530
so, {} if you're playing

650
00:20:11,670 --> 00:20:13,320
0,390 390,810 810,1020 1020,1260 1260,1650
a replicated state machine approach|
|

651
00:20:13,320 --> 00:20:14,940
0,570 630,810 810,960 960,1140 1140,1620
at that kind of application
在应用程序级别，

652
00:20:14,940 --> 00:20:16,530
0,420 450,630 630,720 720,1170 1170,1590
level,| then the application itself
|那么需要修改应用程序本身

653
00:20:16,530 --> 00:20:17,940
0,150 150,210 210,330 330,1020 1020,1410
needs to be modified| to
|以执行或作为复制状态机方法的一部分。

654
00:20:17,940 --> 00:20:20,460
0,390 1050,1590 1590,1950 1950,2190 2190,2520
actually perform or play part

655
00:20:20,460 --> 00:20:21,510
0,60 60,150 150,600 600,780 780,1050
of the replicated state machine

656
00:20:21,510 --> 00:20:22,420
0,510
approach.|
|

657
00:20:22,740 --> 00:20:24,060
0,330 330,510 510,690 690,900 900,1320
One thing that's cool about
今天我们看的论文，有一件很酷的事情，

658
00:20:24,180 --> 00:20:25,170
0,210 210,480 480,780 780,930 930,990
the paper today that we're

659
00:20:25,170 --> 00:20:26,730
0,330 330,540 540,810 1200,1410 1410,1560
looking at to,| it's like
|今天看的是，

660
00:20:26,730 --> 00:20:29,040
0,390 390,510 510,930 1050,1770 1830,2310
looking at today is {},|
|

661
00:20:29,340 --> 00:20:31,200
0,420 480,780 780,780 780,1770 1770,1860
{it,you,know - -} operations at
在机器层面的操作，

662
00:20:31,200 --> 00:20:32,540
0,90 90,450 450,810
the machine level,|
|

663
00:20:32,660 --> 00:20:34,010
0,270 270,360 360,900 900,1140 1140,1350
or the processor level or
或处理器级别或计算机级别，

664
00:20:34,010 --> 00:20:36,440
0,390 390,780 1260,1710 1710,1980 1980,2430
computer level,| {} and so
|所以状态是 x86 寄存器，内存状态，

665
00:20:36,470 --> 00:20:39,380
0,240 240,900 990,1590 1590,2130 2130,2910
the state {} is registers

666
00:20:39,800 --> 00:20:42,410
0,600 600,1350 1350,1770 1770,2100 2100,2610
x86 registers, the memory state,|
|

667
00:20:42,830 --> 00:20:46,340
0,1770 1770,2430 2460,2790 2790,3360 3360,3510
{} and the operations are
操作是传统的计算机指令，

668
00:20:46,340 --> 00:20:48,200
0,210 210,300 300,870 870,1170 1170,1860
just an ordinary computer instructions|
|

669
00:20:48,230 --> 00:20:50,660
0,690 810,1290 1290,1770 1770,2340 2340,2430
and {} by replicating at
通过在这个级别进行复制，

670
00:20:50,660 --> 00:20:52,640
0,210 210,780 870,1620 1620,1830 1830,1980
that level,| then you can
|可以使你的应用程序完全透明，

671
00:20:52,640 --> 00:20:54,540
0,750 810,1530
basically {}

672
00:20:54,730 --> 00:20:56,650
0,450 450,960 960,1170 1170,1590 1590,1920
{} make your application completely

673
00:20:56,650 --> 00:20:58,450
0,690 1170,1500 1500,1590 1590,1680 1680,1800
transparent,| because you can take
|因为你可以使用一台计算机，

674
00:20:58,450 --> 00:21:00,160
0,210 210,690 690,1260 1290,1620 1620,1710
one computer,| {} run the
|在它上面运行应用程序和操作系统，

675
00:21:00,160 --> 00:21:01,630
0,540 540,870 870,1170 1170,1260 1260,1470
application operating system on top

676
00:21:01,630 --> 00:21:03,640
0,90 90,360 360,570 600,1260 1290,2010
of it,| just runs x86
|只是运行 x86 指令，

677
00:21:03,640 --> 00:21:06,130
0,720 1080,1650 1650,1830 1830,2250 2250,2490
instructions,| and this replicated state
|并且这个复制状态机方法

678
00:21:06,130 --> 00:21:09,310
0,240 240,840 1050,1560 1560,2550 2580,3180
machine approach| {} automatically creates
|自动创建特定执行的备份，

679
00:21:09,310 --> 00:21:12,550
0,450 450,1080 1110,2400 2520,2880 2880,3240
{} backup of that particular

680
00:21:12,550 --> 00:21:14,020
0,540 540,720 720,810 810,1290 1290,1470
execution,| so the application doesn't
|所以应用程序根本不需要修改，

681
00:21:14,020 --> 00:21:14,860
0,180 180,240 240,360 360,750 750,840
have to be modified at

682
00:21:14,860 --> 00:21:15,610
0,240 240,330 330,570 570,630 630,750
all,| in fact, in this
|实际上，在这个论文中，操作系统并没有被修改，

683
00:21:15,610 --> 00:21:18,220
0,540 660,1320 1350,2280 2280,2520 2520,2610
paper, the operating system is

684
00:21:18,220 --> 00:21:19,690
0,150 150,810 840,960 960,1380 1380,1470
not modified,| the application is
|应用程序没有被修改，

685
00:21:19,690 --> 00:21:20,920
0,150 150,780 870,1020 1020,1110 1110,1230
not modified,| you can take
|你可以使用普通的应用程序，

686
00:21:20,920 --> 00:21:22,750
0,90 90,660 660,1200 1200,1410 1410,1830
an ordinary application,| not even
|甚至在编写时都不用考虑容错，

687
00:21:22,780 --> 00:21:24,220
0,630 630,810 810,1020 1020,1320 1320,1440
written with fault tolerance in

688
00:21:24,220 --> 00:21:25,840
0,420 660,840 840,1080 1080,1230 1230,1620
mind,| and using this sort
|使用这种机器级或指令级复制，

689
00:21:26,080 --> 00:21:28,150
0,360 360,930 930,1440 1500,1860 1860,2070
of machine level {} or

690
00:21:28,150 --> 00:21:30,730
0,510 510,960 960,1800 1890,2310 2310,2580
instruction level replication,| {} it
|它可以透明地复制。

691
00:21:30,730 --> 00:21:33,180
0,330 360,750 750,1500 1500,2130
can be transparently replicated.|
|

692
00:21:33,210 --> 00:21:34,050
0,240 240,330 330,390 390,690 690,840
One of the things that's
一件非常酷的事情，

693
00:21:34,050 --> 00:21:35,550
0,240 240,510 510,900 900,1050 1110,1500
very cool| about {you,know} paper
|关于今天的论文，它是完全透明的。

694
00:21:35,550 --> 00:21:37,740
0,90 90,660 810,1200 1200,1530 1530,2190
of today is completely transparent.|
|

695
00:21:42,350 --> 00:21:44,600
0,660 1080,1680
{You,know} {}
这让你想知道怎么去做，

696
00:21:45,180 --> 00:21:46,110
0,120 120,270 270,360 360,810 810,930
that makes you wonder you

697
00:21:46,110 --> 00:21:47,430
0,330 570,870 870,960 960,1080 1080,1320
know how to do that,|
|

698
00:21:47,430 --> 00:21:48,840
0,330 330,630 630,1050 1050,1350 1350,1410
because what happens,| if you
因为会发生什么，|如果你查看机器，

699
00:21:48,840 --> 00:21:50,220
0,150 150,330 330,1020 1020,1290 1290,1380
look at machine| and an
|一个中断发生，

700
00:21:50,220 --> 00:21:52,560
0,390 390,1050 1290,1440 1440,1950 2130,2340
interrupt happens,| you know that
|那个中断需要以某种方式直接传播到备份，

701
00:21:52,560 --> 00:21:54,720
0,390 390,630 630,1200 1200,1560 1560,2160
interrupt needs to be propagated

702
00:21:54,720 --> 00:21:56,520
0,60 60,330 330,690 690,1140 1530,1800
in some way directly to

703
00:21:56,520 --> 00:21:57,660
0,150 150,540 540,870 870,1020 1020,1140
the backup,| because like if
|因为如果你考虑 x86 机器，

704
00:21:57,660 --> 00:21:58,950
0,60 60,240 240,510 510,630 630,1290
you think about the x86

705
00:21:58,950 --> 00:22:00,810
0,570 750,1080 1080,1410 1410,1530 1530,1860
machine,| of course the regular
|当然，应用程序执行的常规指令，

706
00:22:00,810 --> 00:22:02,640
0,480 480,600 600,720 720,1260 1260,1830
instructions that the applications execute,|
|

707
00:22:02,790 --> 00:22:04,590
0,510 510,600 600,810 810,1170 1170,1800
{like,add}, you know whatever divide,
比如加法，除法，条件分支过程调用，

708
00:22:04,590 --> 00:22:06,960
0,120 120,480 540,1110 1110,1590 1590,2370
you know conditional branch branching

709
00:22:07,170 --> 00:22:08,970
0,690 690,1260 1290,1650 1650,1740 1740,1800
procedure calls,| but there are
|但是还有其他事件，比如中断，

710
00:22:08,970 --> 00:22:10,320
0,240 240,510 510,960 960,1230 1230,1350
also other events like an

711
00:22:10,320 --> 00:22:12,030
0,690 690,1230 1230,1440 1440,1650 1650,1710
interrupts,| and they need to
|它们也需要被处理，

712
00:22:12,030 --> 00:22:13,320
0,450 450,540 540,630 630,1020 1020,1290
be you know handled with,|
|

713
00:22:13,380 --> 00:22:13,980
0,180 180,270 270,360 360,480 480,600
so how do you do
那么你如何做到这个。

714
00:22:13,980 --> 00:22:14,660
0,270
that.|
|

715
00:22:15,020 --> 00:22:18,470
0,210 210,570 870,1440 1620,2550 2760,3450
And so a traditional, a
所以，一种传统的进行机器级别复制的方式，

716
00:22:18,500 --> 00:22:20,690
0,990 990,1260 1260,1590 1590,1740 1740,2190
way of doing a machine

717
00:22:20,690 --> 00:22:22,880
0,300 300,1200 1410,1920 1920,2130 2130,2190
level replication,| {} used to
|使用起来相当昂贵，

718
00:22:22,880 --> 00:22:24,140
0,210 210,360 360,420 420,780 780,1260
be sort of quite expensive,|
|

719
00:22:24,140 --> 00:22:25,730
0,120 120,180 180,510 510,840 1020,1590
in the sense that, {}|
从某种意义上说，|

720
00:22:25,760 --> 00:22:27,680
0,690 840,1020 1020,1170 1170,1380 1380,1920
the you could buy computers
你可以购买计算机或者处理器，

721
00:22:27,680 --> 00:22:29,120
0,210 210,450 450,1020 1020,1200 1200,1440
or whatever processors,| like maybe
|可能复制两到三次，

722
00:22:29,120 --> 00:22:30,860
0,450 450,870 870,960 960,1110 1110,1740
replicated twice or three times|
|

723
00:22:31,100 --> 00:22:32,720
0,420 420,480 480,810 810,1440 1440,1620
and the hardware itself would
硬件本身会组织这些处理器，

724
00:22:32,720 --> 00:22:34,820
0,840 840,930 930,1260 1260,1530 1530,2100
organize you know these processors|
|

725
00:22:34,820 --> 00:22:37,040
0,180 180,900 900,1560 1560,1830 1830,2220
{sort,of} ran exactly {in,lockstep -},|
完全同步地运行，|

726
00:22:38,080 --> 00:22:39,580
0,480 480,840 840,930 930,1050 1050,1500
{} and you know there's
有很多硬件设备可以实现这一点，

727
00:22:39,580 --> 00:22:40,720
0,90 90,240 240,300 300,630 630,1140
a lot of hardware machinery

728
00:22:40,720 --> 00:22:41,710
0,120 120,330 330,480 480,600 600,990
to actually make this happen,|
|

729
00:22:41,710 --> 00:22:42,610
0,150 150,450 450,750 750,870 870,900
and this paper has a
这篇论文有一个很酷的观察，

730
00:22:42,610 --> 00:22:45,610
0,240 240,960 1170,1920 2220,2580 2580,3000
cool observation that,| {} you
|你并不需要进行真正的硬件复制，

731
00:22:45,610 --> 00:22:47,080
0,180 180,420 420,690 690,990 990,1470
don't really need to do

732
00:22:47,080 --> 00:22:49,570
0,300 300,870 870,1680 1740,1950 1950,2490
really hardware replication,| {} instead
|相反，你可以使用虚拟机，

733
00:22:49,570 --> 00:22:50,620
0,120 120,240 240,510 510,750 750,1050
you can actually use virtual

734
00:22:50,620 --> 00:22:51,780
0,630
machines,|
|

735
00:22:57,520 --> 00:22:58,360
0,330 330,540 540,630 630,750 750,840
and that's the way they
这就是他们的做法，

736
00:22:58,360 --> 00:22:59,360
0,120 120,390
do it,|
|

737
00:22:59,360 --> 00:23:01,790
0,480 690,1290 1290,1590 1590,2070 2070,2430
that pure hardware replication happens
纯硬件复制也会发生，

738
00:23:01,790 --> 00:23:03,320
0,480 510,1290 1290,1350 1350,1470 1470,1530
too,| {} you know, for
|例如，在[]或[]中，

739
00:23:03,320 --> 00:23:08,690
0,480 480,930 1170,2160 2160,3750 4350,5370
example in {} in []

740
00:23:08,690 --> 00:23:10,640
0,420 420,1050 1050,1560 1560,1620 1650,1950
or {} whatever {} []

741
00:23:10,640 --> 00:23:12,560
0,630 660,1200 1200,1290 1290,1710 1710,1920
over,| you know often the
|硬件模块通常是

742
00:23:12,560 --> 00:23:13,700
0,270 270,630 630,720 720,990 990,1140
hardware modules are just like|
|

743
00:23:13,700 --> 00:23:16,820
0,210 210,900 900,1500 1920,2550 2550,3120
{ - -} duplex replicated
双重复制或三重复制，

744
00:23:16,820 --> 00:23:17,930
0,60 60,120 120,420 420,1020 1020,1110
to {} triple {replication -}|
|

745
00:23:17,930 --> 00:23:18,950
0,180 180,360 360,420 420,720 720,1020
and have a hardware voting
并且有使硬件表决方案，

746
00:23:18,950 --> 00:23:21,230
0,570 1080,1200 1200,1620 1620,1740 1740,2280
scheme| to keep the processors
|使处理器保持同步以检测故障，

747
00:23:21,230 --> 00:23:23,270
0,150 150,570 570,990 990,1590 1740,2040
in sync {to,detect} failures,| but
|但是这种级别的容错，

748
00:23:23,270 --> 00:23:25,100
0,390 390,750 750,930 930,1680 1680,1830
{that,sort,of} level of {fault,tolerance},| that
|不是 VM-FT 论文所讨论的级别，

749
00:23:25,100 --> 00:23:28,940
0,1020 1020,1110 1110,1650 1650,3090
{} is not the

750
00:23:29,420 --> 00:23:31,220
0,210 210,660 660,750 750,900 900,1800
the level, is that {VM-FT

751
00:23:31,220 --> 00:23:33,110
0,600 600,960 960,1230 1230,1560 1560,1890
-} paper not actually shooting

752
00:23:33,110 --> 00:23:34,640
0,300 420,540 540,810 810,1170 1170,1530
for,| is really thinking about
|考虑一下，

753
00:23:34,640 --> 00:23:35,390
0,210 210,270 270,360 360,510 510,750
like,| you know you got
|你在计算机上运行商业应用程序，

754
00:23:35,390 --> 00:23:37,520
0,630 630,810 810,900 900,1230 1230,2130
{} in a business application

755
00:23:37,520 --> 00:23:39,020
0,540 540,1020 1050,1290 1290,1440 1440,1500
running on {} on the

756
00:23:39,020 --> 00:23:40,160
0,420 420,600 600,900 900,990 990,1140
computer,| and now you want
|你希望使业务应用程序具有更强的容错能力，

757
00:23:40,160 --> 00:23:41,300
0,60 60,180 180,330 330,630 630,1140
to make that business application

758
00:23:41,300 --> 00:23:43,310
0,180 180,330 330,810 1260,1770 1770,2010
more fault tolerant,| and the
|而采取的方法是利用虚拟化。

759
00:23:43,340 --> 00:23:44,690
0,390 390,540 540,750 750,900 900,1350
approach to take is to

760
00:23:44,690 --> 00:23:46,480
0,570 570,1320
exploit virtualization.|
|

761
00:23:48,550 --> 00:23:49,540
0,150 150,270 270,450 450,630 630,990
So the {situation -} to
所以， VM-FT 的情况是利用虚拟化，

762
00:23:49,540 --> 00:23:51,700
0,510 510,1170
{VM-FT -}

763
00:23:53,330 --> 00:23:56,480
0,480 480,1110 1320,2550 2610,2940 2940,3150
is exploit virtualization,| that's the
|这是主要的想法，

764
00:23:56,480 --> 00:23:58,080
0,780
main

765
00:24:00,210 --> 00:24:02,460
0,420 420,870 870,1050 1050,1800 1950,2250
big idea,| that they bring
|他们为解决这个问题而提出的，

766
00:24:02,460 --> 00:24:04,020
0,390 390,630 630,720 720,1170 1170,1560
along to this problem,| and
|通过这样做，

767
00:24:04,020 --> 00:24:04,950
0,120 120,210 210,360 360,600 600,930
you know by doing so,|
|

768
00:24:04,950 --> 00:24:06,420
0,180 180,300 300,480 480,870 900,1470
they can make this replication
他们可以使复制对应用程序透明。

769
00:24:06,420 --> 00:24:08,860
0,690 930,1050 1050,1170 1170,1920
transparent to the application,|
|

770
00:24:16,580 --> 00:24:17,330
0,240 240,360 360,570 570,690 690,750
{of,course}, you don't have to
当然，你不需要设计，

771
00:24:17,330 --> 00:24:19,220
0,540 540,660 660,720 720,1200 1200,1890
design,| as an application design
|比如应用程序的复制方案，

772
00:24:19,220 --> 00:24:21,050
0,120 120,480 480,750 780,1350 1350,1830
and then the replication scheme,|
|

773
00:24:21,050 --> 00:24:22,100
0,120 120,540 540,600 600,960 960,1050
where like for example the
例如在 GFS 中的复制方式，

774
00:24:22,100 --> 00:24:23,390
0,150 150,270 270,480 480,630 630,1290
way it's done in, {

775
00:24:23,900 --> 00:24:26,990
0,1260 1260,1560 1590,2310 2610,2910 2910,3090
-} in GFS,| {} it
|使用这个方案，

776
00:24:26,990 --> 00:24:29,390
0,630 930,1860 1860,1950 1950,2250 2250,2400
appears using the scheme,| this
|VM-FT 使用的复制方案，

777
00:24:29,390 --> 00:24:31,310
0,450 450,720 720,870 870,1410 1410,1920
replication scheme that {VM-FT -}

778
00:24:31,310 --> 00:24:33,770
0,420 420,840 1080,1740 1740,2190 2190,2460
{} uses,| appears basically that
|呈现给客户端，

779
00:24:33,770 --> 00:24:34,720
0,300
the

780
00:24:35,280 --> 00:24:37,360
0,540 540,1230
{appears,to} client,|
|

781
00:24:37,560 --> 00:24:38,430
0,150 150,240 240,660 660,780 780,870
but the server is a
服务器是单独一台机器，

782
00:24:38,430 --> 00:24:41,100
0,270 270,870
single machine,|
|

783
00:24:44,430 --> 00:24:46,710
0,690 690,810 810,1110 1680,1830 1830,2280
meaning {} just you know
意思是，我们稍后会看到是怎么回事，

784
00:24:46,710 --> 00:24:48,210
0,240 240,480 480,810 810,1140 1140,1500
seeing {in,a,second} how,| but basically
|但它们会提供非常强的一致性，

785
00:24:48,210 --> 00:24:49,290
0,90 90,270 270,600 600,840 840,1080
they're gonna provide very strong

786
00:24:49,290 --> 00:24:51,780
0,630 630,840 840,1530 2010,2430 2430,2490
consistency,| {you,know} the client on
|外部的客户端甚至看不出来。

787
00:24:51,780 --> 00:24:53,070
0,120 120,390 390,570 570,750 750,1290
the outside can't even tell.|
|

788
00:24:53,560 --> 00:24:56,050
0,510 840,1530 1560,1980 1980,2160 2160,2490
{} And, {} it actually
而且，这篇论文是很酷的论文，

789
00:24:56,050 --> 00:24:57,040
0,60 60,210 210,330 330,780 780,990
you know the paper {sort,of,cool}

790
00:24:57,040 --> 00:24:58,630
0,270 270,540 540,600 600,1380 1380,1590
paper,| because it actually is,
|因为它是一个真正的产品，

791
00:24:58,630 --> 00:25:00,240
0,240 240,330 330,480 480,1110
it's a real product,|
|

792
00:25:04,210 --> 00:25:05,770
0,450 450,630 630,870 870,960 960,1560
and it's still in use,|
而且它还在使用中，|

793
00:25:06,160 --> 00:25:08,170
0,150 150,870 870,1140 1140,1380 1380,2010
you know you can {}
如果你愿意的话，可以获得这种支持。

794
00:25:08,470 --> 00:25:11,440
0,840 840,1080 1080,1650 2010,2580 2640,2970
get this, { -} there's

795
00:25:11,440 --> 00:25:12,610
0,150 150,720 720,930 930,1080 1080,1170
this support {} if you

796
00:25:12,610 --> 00:25:13,520
0,180 180,330
want to.|
|

797
00:25:13,730 --> 00:25:15,830
0,420 660,930 930,1530 1530,1920 1920,2100
{} {The,current} product I think
我认为目前的产品有些不同，

798
00:25:15,830 --> 00:25:16,760
0,60 60,300 300,630 630,870 870,930
is quite different from the

799
00:25:16,760 --> 00:25:18,020
0,210 210,360 360,510 510,870 900,1260
one,| that we actually read
|与我们在论文上看到的，

800
00:25:18,020 --> 00:25:19,610
0,270 270,360 360,420 420,960 1140,1590
about in the paper, {}|
|

801
00:25:19,610 --> 00:25:20,810
0,330 330,450 450,780 780,1110 1110,1200
but you know at a
但是在高的级别上，

802
00:25:20,810 --> 00:25:22,280
0,210 210,360 360,900 930,990 990,1470
very high level,| you know
|这些问题非常相似，

803
00:25:22,490 --> 00:25:23,690
0,180 180,480 480,540 540,780 780,1200
the issues are very similar,|
|

804
00:25:24,170 --> 00:25:25,880
0,300 300,630 630,720 720,1350 1380,1710
in fact you know one
事实上，最大的缺点之一，

805
00:25:25,880 --> 00:25:28,190
0,120 120,480 600,1290 1440,2190 2190,2310
of the big shortcomings| as
|就像你们中的许多人在问题中指出的那样，

806
00:25:28,190 --> 00:25:29,030
0,210 210,300 300,420 420,750 750,840
many of you noted in

807
00:25:29,030 --> 00:25:31,430
0,60 60,690 930,1500 1500,1740 1740,2400
the questions,| {} of the
|论文中的一个[]，

808
00:25:31,700 --> 00:25:32,870
0,450 450,750 750,870 870,1110 1110,1170
the one that [] in

809
00:25:32,870 --> 00:25:34,100
0,60 60,330 330,840 840,900 900,1230
the paper,| it's a single
|这是一个单核心解决方案，

810
00:25:34,100 --> 00:25:36,020
0,510 510,1050 1350,1500 1500,1680 1680,1920
core solution,| so there's no
|所以不存在多核支持，

811
00:25:36,020 --> 00:25:37,880
0,270 270,510 510,1080 1290,1440 1440,1860
{multi-core -} support,| so multiple
|所以一台计算机上的多个程序或多个线程不能并行运行，

812
00:25:37,880 --> 00:25:39,470
0,510 510,600 600,990 990,1350 1350,1590
applications or multiple threads on

813
00:25:39,470 --> 00:25:40,610
0,180 180,480 480,900 900,1050 1050,1140
one computer cannot run in

814
00:25:40,610 --> 00:25:42,350
0,510 990,1290 1290,1380 1380,1530 1530,1740
parallel,| then we'll talk about
|稍后我们将会讨论，

815
00:25:42,350 --> 00:25:43,340
0,60 60,90 90,330 330,720 720,990
in a second,| why this
|为什么这个解决方案不支持，

816
00:25:43,340 --> 00:25:44,630
0,300 300,480 480,660 660,990 990,1290
solution doesn't really support that,|
|

817
00:25:44,870 --> 00:25:46,310
0,330 330,720 720,900 900,1080 1080,1440
{} in I think later
我想后来的 FT 版本可以支持，

818
00:25:46,310 --> 00:25:49,190
0,330 330,840 840,1080 1080,1800 1860,2880
later versions of {} FT

819
00:25:49,190 --> 00:25:51,800
0,180 180,810 810,1320 1350,1950 2130,2610
does actually works,| and {}
|但是没有论文详细描述它，

820
00:25:51,800 --> 00:25:54,320
0,120 120,780 780,1710 1710,2130 2130,2520
I think {there's,no} paper detail

821
00:25:54,320 --> 00:25:56,270
0,240 240,360 360,900 900,1020 1290,1950
paper that describes it, {}|
|

822
00:25:56,300 --> 00:25:57,260
0,90 90,240 240,480 480,720 720,960
but I actually think that,|
但是我认为，|

823
00:25:57,260 --> 00:25:58,640
0,480 480,840 840,960 960,1140 1140,1380
{} instead of using actually
不是使用复制状态机方法，

824
00:25:58,640 --> 00:26:00,380
0,420 420,660 660,1080 1080,1470 1470,1740
replicated state machine approach,| actually
|而是使用状态转移方法，

825
00:26:00,380 --> 00:26:02,240
0,300 300,480 480,780 780,1230 1230,1860
using {} state transfer approach,|
|

826
00:26:02,920 --> 00:26:04,450
0,570 600,810 810,1110 1110,1320 1320,1530
but I really don't know
但是我也不知道任何细节。

827
00:26:04,450 --> 00:26:05,410
0,210 210,510 510,720 720,840 840,960
any {} {really -} the

828
00:26:05,410 --> 00:26:06,600
0,690
details.|
|

829
00:26:07,420 --> 00:26:08,350
0,120 120,390 390,510 510,600 600,930
{} We're going to focus
我们将重点介绍复制状态机方法，

830
00:26:08,350 --> 00:26:09,400
0,120 120,210 210,600 600,810 810,1050
on the replicated state machine

831
00:26:09,400 --> 00:26:10,660
0,420 420,660 660,900 900,1170 1170,1260
approach,| because one reason I
|因为我喜欢这篇论文的一个原因是，

832
00:26:10,660 --> 00:26:11,770
0,240 240,360 360,690 690,780 780,1110
like this paper is,| because
|因为它以一种非常清晰的方式说明了复制状态机方法，

833
00:26:11,770 --> 00:26:13,120
0,90 90,270 270,330 330,900 900,1350
it sort of illustrates replicated

834
00:26:13,120 --> 00:26:14,290
0,240 240,690 690,1020 1020,1110 1110,1170
state machine approach in a

835
00:26:14,290 --> 00:26:16,660
0,420 420,720 720,1230 1440,2070 2070,2370
very clean manner,| and all
|所有后续的复制方案，

836
00:26:16,660 --> 00:26:17,830
0,480 510,690 690,840 840,1080 1080,1170
the you know all the

837
00:26:17,830 --> 00:26:20,350
0,780 870,2100 2100,2340 2340,2430 2430,2520
subsequent replication schemes,| that were
|我们要看的（复制方案）

838
00:26:20,350 --> 00:26:21,160
0,120 120,180 180,270 270,540 540,810
going to be looking at|
|

839
00:26:21,190 --> 00:26:23,620
0,690 720,1380 1380,1560 1560,1800 1800,2430
are replicated state machine approaches.|
都是复制状态机方法。|

840
00:26:26,290 --> 00:26:28,460
0,600 930,1620
Okay, so,
好的，让我们来描述这个系统的概况。

841
00:26:28,700 --> 00:26:29,860
0,600
{}

842
00:26:30,760 --> 00:26:32,470
0,150 150,420 420,810 810,1320 1350,1710
so let's sketch out the

843
00:26:32,470 --> 00:26:34,140
0,960
overview

844
00:26:35,600 --> 00:26:37,100
0,330 330,930
{of,the} system.|
|

845
00:26:37,250 --> 00:26:38,390
0,360 360,480 480,570 570,750 750,1140
And so the first thing
所以首先要注意的是，

846
00:26:38,600 --> 00:26:41,030
0,750 750,1230 1230,1590 1590,2250 2250,2430
{} {sort,of} {need,to} realizes that,|
|

847
00:26:41,030 --> 00:26:42,590
0,210 210,270 270,720 750,1260 1260,1560
there's a virtual virtual machine
有一个虚拟机监控器，

848
00:26:42,590 --> 00:26:44,060
0,450 450,1020 1110,1260 1260,1380 1380,1470
monitor involved,| so what is
|那么什么是虚拟机监控器，

849
00:26:44,060 --> 00:26:45,860
0,30 30,300 300,540 540,1110 1350,1800
a virtual machine monitor,| well
|虚拟机监控器使用一块硬件，

850
00:26:45,890 --> 00:26:47,390
0,420 420,690 690,960 960,1290 1290,1500
virtual machine monitor basically takes

851
00:26:47,390 --> 00:26:49,250
0,60 60,240 240,330 330,990 1080,1860
a piece of hardware| and
|并产生 n 块硬件，

852
00:26:49,280 --> 00:26:51,590
0,690 690,1140 1140,1560 1560,1620 1620,2310
{} it makes it appear

853
00:26:51,590 --> 00:26:52,640
0,60 60,150 150,510 510,750 780,1050
you know basically makes n

854
00:26:52,640 --> 00:26:53,720
0,330 330,420 420,840 840,960 960,1080
pieces of hardware out of

855
00:26:53,720 --> 00:26:54,360
0,210
it.|
|

856
00:26:54,760 --> 00:26:56,290
0,510 510,900 960,1170 1170,1380 1380,1530
{} So if we look
如果我们看一下 x86 盒子，

857
00:26:56,290 --> 00:26:58,630
0,90 90,300 1110,1410 1410,1830 1830,2340
at the {x86 -} box,|
|

858
00:26:58,630 --> 00:26:59,200
0,90 90,210 210,270 270,390 390,570
you know we can take
我们可以在它上面运行一个虚拟机监视器，

859
00:26:59,200 --> 00:27:00,550
0,30 30,300 300,600 600,1140 1140,1350
a virtual machine monitor run

860
00:27:00,550 --> 00:27:01,330
0,120 120,180 180,450 450,540 540,780
it on top of it,|
|

861
00:27:03,280 --> 00:27:04,660
0,720 720,900 900,1140 1140,1200 1200,1380
{and,you,know} on top of it,
在它之上，我们可以有虚拟机，

862
00:27:04,660 --> 00:27:05,830
0,120 120,240 240,390 390,660 660,1170
we can have virtual machines,|
|

863
00:27:06,310 --> 00:27:08,110
0,240 240,480 480,1170 1200,1680 1680,1800
and virtual machine, we're gonna
我们有多个虚拟机，

864
00:27:08,110 --> 00:27:09,790
0,90 90,450 450,750 750,1260 1260,1680
have multiple virtual machines,| although
|尽管篇论文的大部分内容我们讨论的是，

865
00:27:09,820 --> 00:27:10,840
0,300 300,390 390,570 570,930 930,1020
most of this paper we're

866
00:27:10,840 --> 00:27:11,710
0,120 120,180 180,360 360,630 630,870
going to be talking about,|
|

867
00:27:11,710 --> 00:27:12,880
0,180 180,510 510,840 840,1110 1110,1170
running one virtual machine on
在虚拟机监视器之上运行一个虚拟机。

868
00:27:12,880 --> 00:27:13,960
0,240 240,330 330,510 510,810 810,1080
top of the virtual machine

869
00:27:13,960 --> 00:27:15,260
0,510
monitor.|
|

870
00:27:15,320 --> 00:27:16,610
0,690 690,810 810,930 930,990 990,1290
{} And so for example
例如，我们可能有一个 Linux 操作系统

871
00:27:16,610 --> 00:27:17,600
0,60 60,270 270,540 540,690 690,990
we might actually have a

872
00:27:17,600 --> 00:27:20,030
0,600 720,1230 1230,1650 1650,2190 2250,2430
Linux operating system| running on
|和它的应用程序一起运行在虚拟机上。

873
00:27:20,030 --> 00:27:21,560
0,270 270,360 360,450 450,720 720,1530
top of the virtual machine

874
00:27:21,560 --> 00:27:24,080
0,180 180,420 420,1470
with its applications.|
|

875
00:27:28,260 --> 00:27:29,400
0,570 570,720 720,840 840,1080 1080,1140
And you know here is
这里是实际的硬件。

876
00:27:29,400 --> 00:27:30,720
0,240 240,390 390,720 720,930 930,1320
actually the actual {hardware -}.|
|

877
00:27:31,920 --> 00:27:34,830
0,300 300,1020 1020,1410 1410,1800 1800,2910
And why you know {so,and,so}
为什么虚拟机，

878
00:27:34,860 --> 00:27:37,200
0,840 1020,1410 1410,1560 1560,2040 2040,2340
VM,| {} the terminology used
|这里使用的术语有时称为 hypervisor ，

879
00:27:37,200 --> 00:27:38,370
0,270 270,600 600,780 780,840 840,1170
here sometimes called a {hypervisor

880
00:27:38,370 --> 00:27:39,540
0,570 570,690 690,870 870,900 900,1170
-},| it's called a virtual
|它被称为虚拟机监控器，

881
00:27:39,540 --> 00:27:42,360
0,270 270,1020 1290,2040 2280,2670 2670,2820
machine monitor,| {} and so
|在我们的例子中，这里的虚拟机监视器，

882
00:27:42,360 --> 00:27:43,800
0,360 360,510 510,930 930,1230 1230,1440
in our case, {you,know} {will

883
00:27:43,800 --> 00:27:44,910
0,120 120,450 450,540 540,810 810,1110
-} the the {hypervisor -}

884
00:27:44,910 --> 00:27:46,560
0,480 480,750 750,960 960,1530 1560,1650
here,| this is actually {you,know}
|实际上就是 VM-FT ，

885
00:27:46,560 --> 00:27:48,640
0,600 600,1170
{VM-FT -},|
|

886
00:27:50,400 --> 00:27:51,990
0,60 60,360 360,750 750,1500 1500,1590
{so,it's,a} {hypervisor -} modified,| you
它是经过修改的虚拟机监视器程序，|包括 VM-FT 的想法。

887
00:27:51,990 --> 00:27:53,190
0,120 120,270 270,990 990,1080 1080,1200
know to include you know

888
00:27:53,190 --> 00:27:54,540
0,120 120,570 570,750 750,1170 1170,1350
the ideas that were {VM-FT

889
00:27:54,540 --> 00:27:56,340
0,180 180,360 360,900 900,1230 1230,1800
- - -} {} has.|
|

890
00:27:57,570 --> 00:27:58,950
0,270 270,360 360,510 510,870 870,1380
Why is this cool,| well,
为什么这很酷，|这很酷的原因是，

891
00:27:58,980 --> 00:27:59,820
0,150 150,330 330,480 480,570 570,840
the reason this is cool,

892
00:27:59,820 --> 00:28:01,830
0,420 420,780 780,1470 1500,1920 1920,2010
because,| or useful {for -}
|或者对复制状态机很有用的原因是，

893
00:28:01,830 --> 00:28:02,970
0,60 60,450 450,630 630,990 990,1140
{} replicated state machines is,|
|

894
00:28:02,970 --> 00:28:04,980
0,240 240,510 510,600 600,1140 1380,2010
because even a hardware interrupt
因为即使一个硬件中断发生，

895
00:28:04,980 --> 00:28:07,050
0,270 270,900 1140,1380 1380,1710 1710,2070
actually happens,| that hardware interrupt
|硬件中断不会直接到 Linux ，

896
00:28:07,050 --> 00:28:08,640
0,270 270,510 510,690 690,1470 1470,1590
doesn't really go straight to

897
00:28:08,640 --> 00:28:09,840
0,390 390,480 480,810 810,900 900,1200
Linux,| in fact, the hardware
|事实上，硬件中断首先通过虚拟机监视器，

898
00:28:09,840 --> 00:28:10,920
0,240 240,420 420,870 870,990 990,1080
interrupt goes first through the

899
00:28:10,920 --> 00:28:12,200
0,330 330,810
VM monitor,|
|

900
00:28:12,500 --> 00:28:13,670
0,150 150,480 480,840 840,1050 1050,1170
the VM monitor actually {decides
虚拟机监视器决定

901
00:28:13,670 --> 00:28:14,720
0,420 420,510 510,630 630,930 930,1050
-}| you know when to
|什么时候将中断传递给 Linux 。

902
00:28:14,720 --> 00:28:16,340
0,630 660,750 750,870 870,1050 1050,1620
deliver you know that interrupt

903
00:28:16,340 --> 00:28:17,680
0,180 180,810
to Linux.|
|

904
00:28:17,800 --> 00:28:20,110
0,180 180,720 750,1020 1020,1590 1590,2310
And so any external events
所以，任何外部事件在被虚拟机观察到之前，

905
00:28:20,140 --> 00:28:21,700
0,870 870,960 960,1320 1320,1500 1500,1560
before they actually sort of

906
00:28:21,700 --> 00:28:24,040
0,780 810,1320 1320,1590 1590,1890 1890,2340
observed by the virtual machines|
|

907
00:28:24,100 --> 00:28:25,570
0,210 210,480 480,1050 1050,1350 1350,1470
{} actually captured by or
可以由虚拟机监视器捕获。

908
00:28:25,570 --> 00:28:27,100
0,240 240,360 360,750 750,990 990,1530
can be captured by the

909
00:28:27,130 --> 00:28:28,500
0,480 480,870
{hypervisor -}.|
|

910
00:28:28,650 --> 00:28:30,000
0,300 300,720 750,1020 1020,1230 1230,1350
And so this gets us
所以这让我们摆脱了这个困境，

911
00:28:30,000 --> 00:28:31,260
0,90 90,330 330,570 570,1110 1140,1260
out of this mess,| you
|就像我刚才提到的，

912
00:28:31,260 --> 00:28:32,610
0,360 360,570 570,780 780,840 840,1350
know like what I mentioned

913
00:28:32,610 --> 00:28:33,990
0,60 60,180 180,570 570,1080 1230,1380
a bit earlier,| where you
|如果有外部中断会发生什么，

914
00:28:33,990 --> 00:28:35,520
0,300 540,900 900,1260 1260,1380 1380,1530
know what happens if there's

915
00:28:35,520 --> 00:28:37,140
0,90 90,510 510,1050 1050,1410 1410,1620
an external interrupt,| how can
|我们如何才能复制它，

916
00:28:37,140 --> 00:28:39,330
0,270 300,930 930,1200 1500,2070 2070,2190
we replicate that,| and the
|我们要在这里复制的方式是，

917
00:28:39,330 --> 00:28:40,350
0,180 180,330 330,450 450,600 600,1020
way we're going to replicate

918
00:28:40,350 --> 00:28:41,460
0,150 150,690 690,810 810,1050 1050,1110
{} here is,| because the
|因为虚拟机监视器会控制它。

919
00:28:41,460 --> 00:28:42,690
0,270 270,510 510,900 900,1050 1050,1230
virtual machine monitor just get

920
00:28:42,690 --> 00:28:43,920
0,390 390,660
control {over,it}.|
|

921
00:28:44,480 --> 00:28:45,950
0,510 720,930 930,1170 1170,1320 1320,1470
{} And {we'll,see} you know
我们会看到一个非常强大的工具

922
00:28:45,950 --> 00:28:46,550
0,180 180,300 300,360 360,480 480,600
there's going to be an

923
00:28:46,550 --> 00:28:48,650
0,480 480,930 930,1350 1380,1890 1890,2100
extremely powerful tool| {} to
|真正使指令具有确定性，

924
00:28:48,650 --> 00:28:52,130
0,660 930,1530 1560,2100 2100,2520 2520,3480
actually {} make instruction deterministic,|
|

925
00:28:52,130 --> 00:28:53,930
0,120 120,240 240,600 600,1050 1050,1800
you know handle external operations,
处理外部操作，等等。

926
00:28:53,930 --> 00:28:55,160
0,300 300,750
etc etc.|
|

927
00:28:55,620 --> 00:28:56,640
0,150 150,210 210,480 480,780 780,1020
So the basic plan is,|
所以基本的计划是，|

928
00:28:56,640 --> 00:28:57,980
0,210 210,750
like if
如果出现中断，

929
00:28:57,980 --> 00:28:59,480
0,390 390,570 570,900 900,1080 1080,1500
{} an interrupt comes in,|
|

930
00:28:59,510 --> 00:29:00,440
0,90 90,180 180,570 570,750 750,930
you know where there's an
无论是从网络来的中断，

931
00:29:00,440 --> 00:29:01,940
0,480 480,630 630,690 690,1200 1200,1500
interrupt from the network| or
|或者来自硬件本身，比如定时器中断，

932
00:29:01,940 --> 00:29:06,050
0,540 870,1590 2580,3360 3630,3930 3930,4110
from { -} from the

933
00:29:06,050 --> 00:29:07,310
0,390 390,750 750,870 870,930 930,1260
hardware itself, like a timer

934
00:29:07,310 --> 00:29:08,870
0,480 780,900 900,990 990,1410 1410,1560
interrupt,| you know basically the
|基本上定时器中断被传送到虚拟机监视器，

935
00:29:08,870 --> 00:29:10,700
0,330 330,720 720,840 840,1380 1620,1830
timer interrupt is delivered to

936
00:29:10,700 --> 00:29:13,310
0,390 420,870 870,1170 1170,1770 2010,2610
the virtual machine monitor, {}|
|

937
00:29:13,340 --> 00:29:15,620
0,360 360,660 660,1500 1590,2040 2040,2280
virtual machine monitor, then in
然后在 VM-FT 的情况下，虚拟机监视器会做两件事，

938
00:29:15,620 --> 00:29:16,460
0,60 60,270 270,390 390,720 720,840
the case of {VMFT -

939
00:29:16,460 --> 00:29:17,630
0,240 240,480 480,600 600,1050 1050,1170
-}, does two things,| you
|不仅会在某个时刻把它传递给应用程序，

940
00:29:17,630 --> 00:29:19,130
0,360 420,660 660,990 990,1380 1380,1500
know not only delivers it

941
00:29:19,130 --> 00:29:19,760
0,90 90,240 240,450 450,510 510,630
at some point to the

942
00:29:19,760 --> 00:29:21,170
0,600 720,870 870,1080 1080,1320 1320,1410
application,| it also sends it
|它还通过日志通道将其发送到备份计算机，

943
00:29:21,170 --> 00:29:23,270
0,300 300,360 360,750 750,1290 1500,2100
over a logging channel to

944
00:29:23,270 --> 00:29:24,700
0,120 120,480 480,990
a backup computer,|
|

945
00:29:25,130 --> 00:29:26,540
0,390 390,750 750,840 840,1320 1320,1410
backup computer is constructed in
备份计算机与硬件相同的方式构建，

946
00:29:26,540 --> 00:29:28,250
0,60 60,300 300,720 720,1080 1080,1710
the same way as hardware,|
|

947
00:29:28,580 --> 00:29:31,670
0,300 300,450 450,1020 1500,3090 3090,3090
{} it {has -} {virtual,machine}
它有一个虚拟机监视器，

948
00:29:31,670 --> 00:29:32,720
0,390 390,630 630,690 690,930 930,1050
monitor sitting on top of

949
00:29:32,720 --> 00:29:34,100
0,120 120,420 450,630 630,960 960,1380
it,| so there's another copy
|所以还有另一个 VM-FT ，

950
00:29:34,100 --> 00:29:36,860
0,210 660,1590 1770,2340 2340,2490 2490,2760
of VM-FT,| and on top
|在它上面是一台虚拟机，

951
00:29:36,860 --> 00:29:38,270
0,120 120,270 270,300 300,570 570,1410
of is a virtual machine,|
|

952
00:29:38,270 --> 00:29:40,580
0,630 630,1530 1530,1860 1860,2130 2130,2310
were identical software running on
是运行的确定的软件，比如 Linux ，

953
00:29:40,580 --> 00:29:42,470
0,210 210,420 420,990 1320,1650 1650,1890
it like Linux,| same version
|相同版本的 Linux ，

954
00:29:42,470 --> 00:29:43,760
0,90 90,570 570,630 630,870 870,1290
of Linux,| you know with
|以及不管什么应用程序。

955
00:29:43,760 --> 00:29:45,200
0,300 300,480 480,660 660,720 720,1440
whatever some set of applications.|
|

956
00:29:47,840 --> 00:29:49,280
0,900
Okay?|
好的?|

957
00:29:49,560 --> 00:29:50,490
0,240 240,480 480,750 750,810 810,930
And so like you know
如你所知，这些机器在网络上都使用日志通道，

958
00:29:50,490 --> 00:29:54,180
0,630 660,1200 1200,1950 2190,2760 3030,3690
these machines both on networks

959
00:29:54,180 --> 00:29:56,340
0,270 270,360 360,720 720,1290
use the logging channel,|
|

960
00:29:58,180 --> 00:30:00,400
0,390 390,690 690,960 960,1620
and maybe your client
也许你的客户端和硬件交互，

961
00:30:00,580 --> 00:30:03,010
0,180 180,630 630,1080 1080,1620 1980,2430
{you,know} talking basically to the

962
00:30:03,010 --> 00:30:05,260
0,450 450,1350 1380,1890 1920,2010 2010,2250
hardware,| {} do the send
|通过网络发送数据包，

963
00:30:05,260 --> 00:30:06,430
0,30 30,300 300,540 540,630 630,1170
a packet over the network,|
|

964
00:30:06,700 --> 00:30:08,860
0,540 540,1050 1170,1530 1530,1980 1980,2160
{} the actual hardware {you,know}
实际的硬件会收到那个数据包，

965
00:30:08,860 --> 00:30:10,480
0,420 420,630 630,1140
receive the packet,|
|

966
00:30:10,480 --> 00:30:12,550
0,360 360,540 540,1110 1320,1830 1830,2070
{} and then {} that
然后，它会发送它，

967
00:30:12,550 --> 00:30:14,590
0,510 510,510 510,1410 1410,1830 1830,2040
will {} and deliver it,|
|

968
00:30:14,620 --> 00:30:15,790
0,90 90,480 480,810 810,930 930,1170
you know and the virtual
虚拟机监视器获得控制权并发送它，

969
00:30:15,790 --> 00:30:17,440
0,210 210,660 660,930 930,1170 1170,1650
machine monitor just gets control

970
00:30:17,440 --> 00:30:18,610
0,120 120,540 540,750 750,900 900,1170
and delivers it,| and hardware
|硬件发送给虚拟机监视器，

971
00:30:18,610 --> 00:30:19,810
0,450 450,570 570,660 660,930 930,1200
delivers to the virtual machine

972
00:30:19,810 --> 00:30:21,220
0,420 420,510 510,810 810,1080 1080,1410
monitor,| {} virtual machine monitor
|虚拟机监视器获得它。

973
00:30:21,220 --> 00:30:22,210
0,120 120,300 300,570 570,690 690,990
{} will pick it up.|
|

974
00:30:22,900 --> 00:30:24,780
0,180 180,660 840,1410
And so, {}
所以，如果你仔细想想，

975
00:30:25,180 --> 00:30:26,260
0,240 240,390 390,600 600,870 870,1080
if you think about it,|
|

976
00:30:26,260 --> 00:30:27,670
0,90 90,270 270,570 570,900 900,1410
you know this, this package,
这个数据包结果是中断，

977
00:30:27,670 --> 00:30:30,120
0,120 120,420 510,1230 1350,1830
you know results in,

978
00:30:31,470 --> 00:30:32,760
0,240 240,330 330,870 870,960 960,1290
in an interrupt,| that deliver
|发送给虚拟机监控器，

979
00:30:32,760 --> 00:30:34,050
0,120 120,210 210,510 510,750 750,1290
to the virtual machine monitor,|
|

980
00:30:34,110 --> 00:30:35,880
0,450 450,720 720,990 990,1590 1590,1770
the virtual machine monitor will
虚拟机监视器将发送中断，

981
00:30:35,880 --> 00:30:38,130
0,330 330,750 930,1650 1740,2070 2070,2250
send that interrupt,| you'll see
|你会在稍后看到，

982
00:30:38,130 --> 00:30:39,000
0,90 90,120 120,570 570,690 690,870
in a second,| and go
|然后发送给备机，

983
00:30:39,000 --> 00:30:40,940
0,510 510,660 660,840 840,1440
forward to the backup,|
|

984
00:30:41,380 --> 00:30:43,600
0,330 330,1170 1590,1710 1710,2070 2070,2220
{} deliver it, deliver it
也将它发送给本地虚拟机。

985
00:30:43,600 --> 00:30:45,790
0,480 480,720 720,1020 1170,1890 1890,2190
also to the local virtual

986
00:30:45,790 --> 00:30:46,880
0,570
machine,|
|

987
00:30:47,120 --> 00:30:48,350
0,180 180,420 420,660 660,1170 1170,1230
the local virtual machine you
本地虚拟机只是在运行 Linux ，

988
00:30:48,350 --> 00:30:49,610
0,240 240,450 450,660 660,930 930,1260
know it's just Linux running,|
|

989
00:30:49,610 --> 00:30:50,330
0,150 150,390 390,450 450,630 630,720
it saw I got an
它看到我被中断了，

990
00:30:50,330 --> 00:30:51,710
0,480 510,720 720,900 900,1050 1050,1380
interrupt,| and so it does
|所以它会进行正常的处理，

991
00:30:51,710 --> 00:30:52,970
0,360 360,720 720,870 870,1170 1170,1260
normal processing,| it always will
|它总是会处理中断，

992
00:30:52,970 --> 00:30:54,290
0,240 240,390 390,930 960,1170 1170,1320
doing an interrupt,| and so
|在某个时刻，它可能会产生回应，

993
00:30:54,290 --> 00:30:55,190
0,90 90,270 270,690 690,780 780,900
at some point, you know

994
00:30:55,190 --> 00:30:56,570
0,300 300,420 420,750 780,1320 1320,1380
maybe it will generate a

995
00:30:56,570 --> 00:30:57,720
0,720
response,|
|

996
00:30:57,720 --> 00:30:59,490
0,480 480,780 780,960 960,1350 1350,1770
and also for example write
例如，可以写入网卡，

997
00:30:59,490 --> 00:31:00,480
0,90 90,210 210,570 570,660 660,990
you know to the network

998
00:31:00,480 --> 00:31:01,200
0,300 330,390 390,480 480,660 660,720
card,| or at least it
|或者至少它认为写入网卡，

999
00:31:01,200 --> 00:31:02,460
0,180 180,630 630,840 840,1140 1140,1260
will think it's writing to

1000
00:31:02,460 --> 00:31:04,110
0,90 90,360 360,750 750,1170 1380,1650
the network interface card,| but
|但它实际上是一个虚拟网卡，

1001
00:31:04,110 --> 00:31:05,010
0,270 270,420 420,510 510,750 750,900
really what it is, is

1002
00:31:05,010 --> 00:31:06,510
0,60 60,510 510,810 810,1200 1200,1500
a virtual network interface card,|
|

1003
00:31:06,510 --> 00:31:09,270
0,120 120,450 870,1320 1320,2160 2220,2760
that is like emulated by
是由虚拟机监视器模拟的，

1004
00:31:09,270 --> 00:31:10,500
0,150 150,420 420,660 660,1050 1050,1230
the virtual machine monitor,| so
|所以，当写入很多指令到这个虚拟网卡时，

1005
00:31:10,500 --> 00:31:11,610
0,180 180,270 270,600 600,1050 1050,1110
when the writes actually you

1006
00:31:11,610 --> 00:31:13,200
0,270 360,390 390,660 660,750 750,1590
know a bunch of instructions

1007
00:31:13,230 --> 00:31:15,270
0,510 540,1080 1170,1530 1530,1920 1920,2040
{} to {} this you

1008
00:31:15,270 --> 00:31:17,130
0,270 300,810 810,1350 1410,1710 1710,1860
know virtual card,| really what
|实际写入到虚拟机监视器，

1009
00:31:17,130 --> 00:31:18,270
0,120 120,480 480,690 690,1020 1020,1140
it is actually writing to

1010
00:31:18,270 --> 00:31:19,320
0,90 90,360 360,600 600,960 960,1050
the virtual machine monitor,| and
|而虚拟机监控器会看到，

1011
00:31:19,320 --> 00:31:20,550
0,180 180,420 420,870 870,1110 1110,1230
the virtual {machine,monitor} seems like

1012
00:31:20,580 --> 00:31:22,140
0,300 300,390 390,510 510,990 990,1560
{} you know,| here's a
|这是操作系统想要发送数据包，

1013
00:31:22,290 --> 00:31:23,760
0,480 480,870 870,1170 1170,1260 1260,1470
operating system trying to actually

1014
00:31:23,760 --> 00:31:24,880
0,180 180,240 240,720
send the packet,|
|

1015
00:31:25,190 --> 00:31:26,630
0,180 180,570 690,990 990,1230 1230,1440
and then the virtual machine
然后，虚拟机监视器可以

1016
00:31:26,630 --> 00:31:28,010
0,660 660,780 780,1020 1020,1290 1290,1380
monitor can| actually send the
|将数据包发送到操作系统之外，

1017
00:31:28,010 --> 00:31:28,820
0,330 330,510 510,660 660,720 720,810
packet away out of the

1018
00:31:28,820 --> 00:31:30,500
0,360 360,720 720,1050 1080,1560 1560,1680
operating system,| by programming the
|通过对真实硬件进行编程，

1019
00:31:30,500 --> 00:31:31,820
0,180 180,750 1020,1170 1170,1260 1260,1320
real hardware,| and then the
|然后是真正的硬件发送响应给客户端。

1020
00:31:31,820 --> 00:31:33,020
0,180 180,570 570,780 780,1020 1020,1200
real hardware, it sends off

1021
00:31:33,020 --> 00:31:34,310
0,270 270,660 660,780 780,840 840,1290
in response to the client.|
|

1022
00:31:36,140 --> 00:31:37,820
0,150 150,390 390,840 840,930 960,1680
Right, that has a normal
这是一次正常的执行，

1023
00:31:37,820 --> 00:31:39,560
0,570 570,810 810,1050 1050,1440 1440,1740
execution,| for what here's the
|这里是主机，这里是备机，

1024
00:31:39,920 --> 00:31:42,470
0,990 1350,1740 1740,1890 1890,2190 2190,2550
primary, here's the {backup -},|
|

1025
00:31:44,820 --> 00:31:45,750
0,120 120,450 450,540 540,810 810,930
and basically the backup of
基本上，在备机上也会发生同样的事，

1026
00:31:45,750 --> 00:31:46,710
0,60 60,240 240,390 390,840 840,960
the same thing happens,| you
|如果机器在完全相同的状态下启动，

1027
00:31:46,710 --> 00:31:48,180
0,90 90,540 540,840 840,1170 1170,1470
know if the machines started

1028
00:31:48,180 --> 00:31:49,950
0,510 510,570 570,630 630,1290 1290,1770
exactly in the same states,|
|

1029
00:31:49,950 --> 00:31:50,760
0,90 90,210 210,390 390,690 690,810
you know they take the
它们同时接收中断，

1030
00:31:50,760 --> 00:31:52,530
0,600 1020,1140 1140,1470 1470,1530 1530,1770
interrupt {you,know} at the same

1031
00:31:52,530 --> 00:31:53,490
0,330 330,390 390,480 480,720 720,960
time,| and the virtual machine
|虚拟机监视器控制何时中断，

1032
00:31:53,490 --> 00:31:55,200
0,300 300,960 960,1260 1260,1350 1350,1710
monitor control when to deliver

1033
00:31:55,200 --> 00:31:56,790
0,60 60,450 450,660 660,780 780,1590
the interrupt,| it can arrange
|它可以安排来确保，

1034
00:31:56,790 --> 00:31:57,570
0,90 90,300 300,600 600,720 720,780
to make sure,| that the
|中断在完全相同的时间发送，

1035
00:31:57,570 --> 00:31:59,220
0,420 420,660 660,750 750,1110 1110,1650
interrupt to be delivered exactly

1036
00:31:59,220 --> 00:32:00,450
0,60 60,150 150,420 420,690 690,1230
at the same time,| exactly
|以主机得到的完全相同的指令（发送）。

1037
00:32:00,450 --> 00:32:01,980
0,90 90,330 330,1080
the same instruction,

1038
00:32:01,980 --> 00:32:02,940
0,180 180,450 450,540 540,780 780,960
{that,the} primary {} got it.|
|

1039
00:32:03,270 --> 00:32:04,590
0,240 240,330 330,690 690,780 780,1320
So {it,will} deliver the interrupt
所以，它会将中断发送到，

1040
00:32:04,590 --> 00:32:06,420
0,750 900,1170 1170,1440 1440,1740 1740,1830
to the,| {you,know,will} receive the
|将从主机接收到中断，

1041
00:32:06,420 --> 00:32:07,920
0,360 360,480 480,540 540,1140 1290,1500
interrupt from the primary,| may
|可能会缓冲一段时间，

1042
00:32:07,920 --> 00:32:09,690
0,120 120,480 480,570 570,1230 1230,1770
be buffered for {a,while},| until
|直到备机随后得到主机同样的指令，

1043
00:32:09,690 --> 00:32:10,770
0,180 210,510 510,570 570,720 720,1080
the {backup -} {} machine

1044
00:32:10,770 --> 00:32:12,240
0,360 360,660 660,1020 1020,1080 1080,1470
second hits there's a same

1045
00:32:12,240 --> 00:32:14,130
0,510 510,690 690,1050 1050,1350 1440,1890
instruction the primary does,| then
|然后将中断发送给 Linux ，

1046
00:32:14,130 --> 00:32:16,020
0,420 420,540 540,1230 1230,1350 1350,1890
delivers the interrupt the Linux,|
|

1047
00:32:16,110 --> 00:32:17,580
0,630 630,810 810,900 900,1200 1200,1470
Linux is a usual way,|
Linux 是一种常见的方式，|

1048
00:32:17,580 --> 00:32:18,480
0,120 120,270 270,570 600,720 720,900
it will be,| you know
它会，|因为它和主机的状态完全一样，

1049
00:32:18,480 --> 00:32:19,770
0,240 240,360 360,930 930,1020 1020,1290
since it's exactly the same

1050
00:32:19,770 --> 00:32:20,910
0,420 420,510 510,600 600,690 690,1140
state as in the primary,|
|

1051
00:32:20,910 --> 00:32:21,840
0,90 90,180 180,270 270,840 840,930
it will do exactly the
它将与主机做完全相同的事情，

1052
00:32:21,840 --> 00:32:22,860
0,270 270,420 420,540 540,660 660,1020
same thing as the primary

1053
00:32:22,860 --> 00:32:24,210
0,390 540,780 780,840 840,1020 1020,1350
does,| so at some point,
|在某个时刻，它会，

1054
00:32:24,210 --> 00:32:25,280
0,90 90,270 270,720
{you,know} it will,|
|

1055
00:32:25,460 --> 00:32:27,740
0,300 300,1230 1230,1560 1560,1860 1860,2280
{you,know} program virtual network card
编程虚拟网卡发送响应数据包，

1056
00:32:27,740 --> 00:32:29,930
0,90 90,810 810,1230 1230,1710 2100,2190
to {actually,send,a} response packet,| you
|所有这些事情都会发生，

1057
00:32:29,930 --> 00:32:30,800
0,210 210,390 390,570 570,780 780,870
know all that stuff will

1058
00:32:30,800 --> 00:32:32,150
0,570 720,900 900,990 990,1110 1110,1350
happen,| and at some points
|在某些情况下，发送一个数据包，

1059
00:32:32,150 --> 00:32:32,960
0,180 180,360 360,420 420,540 540,810
as like you know send

1060
00:32:32,960 --> 00:32:34,250
0,150 150,630 720,780 780,1020 1020,1290
a packet,| {you,know} the virtual
|虚拟机监视器将获得控制，

1061
00:32:34,250 --> 00:32:36,680
0,330 330,1530 1530,1650 1650,1830 1830,2430
machine monitor will get control,|
|

1062
00:32:36,920 --> 00:32:38,090
0,240 240,480 480,630 630,1080 1080,1170
it knows its backup| and
它知道自己的备机，|所以它什么也不做，

1063
00:32:38,090 --> 00:32:39,440
0,150 150,630 630,900 900,1050 1050,1350
so it doesn't do anything,|
|

1064
00:32:39,440 --> 00:32:40,430
0,180 180,390 390,660 660,930 930,990
it actually doesn't send the
它并不会向网络上发送数据包，

1065
00:32:40,430 --> 00:32:41,720
0,330 330,450 450,510 510,930 960,1290
packet on the network,| because
|因为这是备机。

1066
00:32:41,720 --> 00:32:42,800
0,150 150,210 210,600
it's the backup.|
|

1067
00:32:43,170 --> 00:32:44,380
0,690
Okay,
好的，这是基本的计划，

1068
00:32:44,380 --> 00:32:46,240
0,120 120,450 450,660 750,1350 1350,1860
that's {} the basic plan,|
|

1069
00:32:46,900 --> 00:32:48,880
0,480 480,930 1110,1500 1500,1860 1860,1980
then there's {} one more
然后，这个故事还有一个组成部分，

1070
00:32:48,880 --> 00:32:50,650
0,450 450,540 540,660 660,1290 1380,1770
component in this story, {}|
|

1071
00:32:50,650 --> 00:32:51,910
0,210 210,300 300,690 690,780 780,1260
that is important to realize,|
认识到这一点很重要，|

1072
00:32:51,910 --> 00:32:52,660
0,210 210,330 330,480 480,630 630,750
which is that there is
那就是在一边，

1073
00:32:52,660 --> 00:32:54,100
0,210 210,480 600,1050 1050,1230 1230,1440
on the side, {} on

1074
00:32:54,100 --> 00:32:55,380
0,60 60,600
the side,|
|

1075
00:32:56,130 --> 00:32:57,960
0,330 330,420 420,630 630,1290
on the machine network,|
在机器网络上，|

1076
00:32:58,140 --> 00:32:59,400
0,210 210,300 300,390 390,780 780,1260
there is a storage server,|
有一台存储服务器，|

1077
00:33:07,730 --> 00:33:08,660
0,210 210,300 300,450 450,720 720,930
you can think about this
你可以把它想象成硬盘，

1078
00:33:08,660 --> 00:33:10,310
0,150 150,810 810,930 930,1200 1200,1650
as {} the hard disk,|
|

1079
00:33:10,460 --> 00:33:12,320
0,210 210,510 510,1410 1470,1710 1710,1860
for these for these two
对于这两个虚拟机，

1080
00:33:12,320 --> 00:33:14,630
0,270 270,840 1230,1530 1530,2100 2100,2310
virtual machines or for,| and
|当应用程序写入文件时，

1081
00:33:14,630 --> 00:33:16,910
0,120 120,600 690,900 900,1710 1980,2280
so when an application here

1082
00:33:16,910 --> 00:33:18,110
0,240 240,390 390,480 480,990 990,1200
writes to a file,| really
|它会变成，内核将会，

1083
00:33:18,110 --> 00:33:20,090
0,150 150,270 270,510 510,1110 1320,1980
what it turns into is

1084
00:33:20,090 --> 00:33:21,770
0,120 120,300 300,570 570,1140 1140,1680
you know the kernel will,|
|

1085
00:33:22,040 --> 00:33:23,450
0,120 120,270 270,750 750,1020 1020,1410
you know that file systems
文件系统可能会挂载在本地 Linux 操作系统上，

1086
00:33:23,450 --> 00:33:25,520
0,120 120,240 240,930 990,1290 1290,2070
may be mounted {} on

1087
00:33:25,520 --> 00:33:27,440
0,240 270,690 690,1080 1080,1440 1440,1920
the local Linux operating system,|
|

1088
00:33:27,440 --> 00:33:28,820
0,90 90,300 300,630 630,930 930,1380
the Linux operating system sees
Linux 操作系统认为这是一个远程磁盘，

1089
00:33:28,820 --> 00:33:30,260
0,210 210,300 300,630 630,960 960,1440
this is a remote disk,|
|

1090
00:33:30,500 --> 00:33:32,060
0,360 360,540 540,960 960,1080 1080,1560
and will format the packet|
将会格式化数据包，|

1091
00:33:32,060 --> 00:33:33,020
0,180 180,420 420,540 540,810 810,960
and then will send a
并将数据包发送给，

1092
00:33:33,020 --> 00:33:34,700
0,450 450,570 570,690 690,1260
packet you know to,|
|

1093
00:33:34,700 --> 00:33:35,750
0,60 60,210 210,390 390,750 840,1050
you know, let me draw
让我使用不同的颜色画一下，

1094
00:33:35,750 --> 00:33:36,470
0,120 120,330 330,420 420,480 480,720
out maybe in a slightly

1095
00:33:36,470 --> 00:33:37,670
0,240 240,360 360,540 540,600 600,1200
different,| will send a packet
|将会发送数据包到虚拟机监视器，

1096
00:33:37,670 --> 00:33:39,050
0,120 120,210 210,510 510,780 780,1380
to the virtual machine monitor

1097
00:33:39,410 --> 00:33:40,490
0,150 150,390 390,750 750,870 870,1080
the same place,| and virtual
|虚拟机监控器将它发送出去，

1098
00:33:40,490 --> 00:33:41,810
0,240 240,750 750,1050 1050,1260 1260,1320
machine monitor like send it

1099
00:33:41,810 --> 00:33:43,340
0,360 360,450 450,660 660,900 900,1530
off,| the virtual machine monitor
|虚拟机监视器发送，

1100
00:33:43,340 --> 00:33:44,360
0,60 60,360 360,570 570,870 870,1020
you know go off,| and
|通过网络将它发送到存储服务器，

1101
00:33:44,360 --> 00:33:45,620
0,180 180,210 210,540 540,1050 1050,1260
send it over network {you,know}

1102
00:33:45,620 --> 00:33:47,340
0,240 240,510 510,900 900,1080
to the storage server,|
|

1103
00:33:48,300 --> 00:33:49,860
0,150 150,720 720,1050 1050,1470 1470,1560
the {storage,server} will respond at
存储服务器将在某个时刻响应，

1104
00:33:49,860 --> 00:33:51,120
0,180 180,540 540,780 780,990 990,1260
some point,| in some ways
|在某些方面，这种通信是一样的，

1105
00:33:51,120 --> 00:33:52,770
0,150 150,690 690,870 870,1530 1530,1650
this communication looks identical,| as
|就像有一个客户端在网络的另一边，

1106
00:33:52,770 --> 00:33:54,390
0,240 240,480 480,960 960,1410 1410,1620
if there's a client sitting

1107
00:33:54,390 --> 00:33:54,930
0,60 60,120 120,270 270,450 450,540
on the other side of

1108
00:33:54,930 --> 00:33:56,670
0,90 90,480 1050,1230 1230,1410 1410,1740
the network,| the only difference
|唯一的区别是，

1109
00:33:56,670 --> 00:33:59,340
0,300 300,1230 1620,1980 1980,2400 2400,2670
{being,that},| in the storage server
|在存储服务器的情况下， Linux 启动通信，

1110
00:33:59,340 --> 00:34:02,130
0,600 660,1170 1200,1650 1650,2190 2220,2790
case, the Linux {} starts

1111
00:34:02,130 --> 00:34:03,630
0,390 390,1020 1020,1230 1230,1290 1290,1500
the communication,| while in other
|而在其他情况下，客户端启动通信，

1112
00:34:03,630 --> 00:34:04,680
0,270 270,360 360,720 720,960 960,1050
cases, the client starts the

1113
00:34:04,680 --> 00:34:05,740
0,600
communication,|
|

1114
00:34:06,280 --> 00:34:08,350
0,510 570,960 960,1230 1230,1650 1650,2070
{} green array represent communication
绿色箭头表示与存储服务器的通信，

1115
00:34:08,350 --> 00:34:09,370
0,90 90,180 180,480 480,810 810,1020
to the storage server,| so
|所以一个网络数据包发送

1116
00:34:09,370 --> 00:34:10,750
0,0 0,420 420,780 780,1020 1020,1380
a network packets being sent|
|

1117
00:34:10,750 --> 00:34:13,210
0,510 720,1380 1380,1800 1800,2100 2100,2460
from through Linux, through virtual
通过 Linux ，再通过虚拟机监视器到存储服务器。

1118
00:34:13,210 --> 00:34:14,830
0,240 240,600 600,810 810,1260 1260,1620
machine monitor to storage server.|
|

1119
00:34:15,660 --> 00:34:18,300
0,150 150,300 300,600 630,1770 2160,2640
And so we {} write
所以，应用程序向文件写入，

1120
00:34:18,300 --> 00:34:19,530
0,150 150,240 240,720 720,930 930,1230
by an application to file,|
|

1121
00:34:19,530 --> 00:34:21,150
0,330 330,750 750,840 840,990 990,1620
basically results in these messages,|
会导致这些消息，|

1122
00:34:21,150 --> 00:34:23,190
0,300 300,870 870,1290 1290,1710 1710,2040
and then {it,will} whatever update
然后更新任何状态，

1123
00:34:23,190 --> 00:34:25,050
0,180 180,630 630,720 720,930 1410,1860
any states,| you know persistent
|在存储服务器上持久化状态。

1124
00:34:25,050 --> 00:34:26,670
0,390 390,570 570,750 750,1200 1200,1620
state, that you know on

1125
00:34:26,670 --> 00:34:27,990
0,330 390,600 600,660 660,990 990,1320
the on the storage server.|
|

1126
00:34:30,040 --> 00:34:30,640
0,150 150,240 240,360 360,540 540,600
{You,know} as we saw in
正如我们在论文中看到的，

1127
00:34:30,640 --> 00:34:32,500
0,90 90,660 720,990 990,1290 1290,1860
the paper,| the storage server
|存储服务器扮演一个额外的角色，

1128
00:34:32,500 --> 00:34:35,200
0,750 1140,1320 1320,1920 1920,2520 2550,2700
plays an additional role,| on
|在存储服务器的基础上，

1129
00:34:35,200 --> 00:34:37,740
0,450 450,1020
top of,

1130
00:34:37,850 --> 00:34:39,650
0,630 720,1050 1050,1230 1230,1590 1590,1800
{} {on,top} of basically being

1131
00:34:39,650 --> 00:34:41,270
0,630 660,1230 1230,1440 1440,1560 1560,1620
{storate,server},| namely, there's sort of
|也就是，这里有一个特殊的标志在旁边，

1132
00:34:41,270 --> 00:34:43,140
0,150 150,630 630,1290
a special flag

1133
00:34:43,670 --> 00:34:44,810
0,180 180,390 390,510 510,570 570,1140
that sits on the side,|
|

1134
00:34:45,170 --> 00:34:46,670
0,330 330,540 540,600 600,1170 1170,1500
or there's a {block,in} storage
或者在存储服务器上有一个块，

1135
00:34:46,670 --> 00:34:47,800
0,570
server,|
|

1136
00:34:48,030 --> 00:34:50,070
0,630 900,1290 1290,1530 1530,1950 1950,2040
{} that's being used to
它用来仲裁失败后谁将成为主机。

1137
00:34:50,070 --> 00:34:53,220
0,930 1080,1830 1860,2310 2310,2430 2430,3150
arbitrate who becomes the primary

1138
00:34:53,220 --> 00:34:54,820
0,480 480,570 570,1080
after a failure.|
|

1139
00:34:55,190 --> 00:34:58,250
0,570 780,1380 1560,1950 1950,2490 2670,3060
{} So, {} so this
所以，这一切都归结为，

1140
00:34:58,250 --> 00:34:59,570
0,180 180,330 330,540 540,930 930,1320
all comes down to,| this
|这是失败转移计划的一部分，

1141
00:34:59,570 --> 00:35:00,260
0,150 150,270 270,510 510,630 630,690
is the part of the

1142
00:35:00,260 --> 00:35:02,030
0,300 300,540 540,990 1380,1560 1560,1770
failure over plan,| so let's
|所以，我们看看日志通道中断，

1143
00:35:02,030 --> 00:35:04,130
0,570 570,720 720,900 900,1500 1560,2100
see you know the {}

1144
00:35:04,160 --> 00:35:06,860
0,570 570,1140 1170,1860 1860,2250 2250,2700
logging channel breaks| or in
|或者到虚拟机监视器的方法是，

1145
00:35:06,860 --> 00:35:08,060
0,90 90,480 480,600 600,750 750,1200
the way you know this

1146
00:35:08,210 --> 00:35:10,100
0,1020 1020,1230 1230,1350 1350,1650 1650,1890
manifest to the virtual machine

1147
00:35:10,100 --> 00:35:11,690
0,390 390,630 630,930 1020,1350 1350,1590
monitor is that,| it sends
|它定期通过日志通道发送数据包，

1148
00:35:11,690 --> 00:35:13,550
0,630 630,1140 1140,1260 1260,1710 1710,1860
periodically packets {you,know} over this

1149
00:35:13,550 --> 00:35:15,080
0,330 330,840 990,1170 1170,1260 1260,1530
logging channel,| and it doesn't
|而且它没有从另一边得到任何回应，

1150
00:35:15,080 --> 00:35:18,100
0,150 150,330 330,1110 1140,2610
get any responses {

1151
00:35:18,100 --> 00:35:19,480
0,360 360,900 930,1080 1080,1200 1200,1380
-} from {} the other

1152
00:35:19,480 --> 00:35:21,730
0,480 540,780 780,1350 1350,1530 1530,2250
side,| then assumes that the
|然后假设另一边，有一个问题，

1153
00:35:21,760 --> 00:35:23,380
0,480 480,870 900,1140 1140,1200 1200,1620
other side, there's a problem,|
|

1154
00:35:23,500 --> 00:35:24,430
0,300 300,390 390,600 600,690 690,930
and of course it can't
当然，它不能决定，

1155
00:35:24,430 --> 00:35:26,290
0,690 720,1320 1320,1410 1410,1650 1650,1860
decide,| whether you know just
|只是网络不工作，

1156
00:35:26,290 --> 00:35:27,430
0,60 60,390 390,510 510,690 690,1140
a network is not working,|
|

1157
00:35:27,460 --> 00:35:29,530
0,900 990,1410 1410,1680 1680,1800 1800,2070
or whether actually the virtual
或者是计算机真的崩溃了。

1158
00:35:29,530 --> 00:35:30,790
0,270 270,900 900,1020 1020,1170 1170,1260
machine monitor you know the

1159
00:35:30,790 --> 00:35:32,320
0,330 330,540 540,1140
computers really crashed.|
|

1160
00:35:32,440 --> 00:35:33,400
0,150 150,330 330,540 540,900 900,960
If it's really crashed,| of
如果它真的崩溃了，|当然，你应该接手，

1161
00:35:33,400 --> 00:35:34,420
0,210 210,300 300,510 510,660 660,1020
course, it should you know

1162
00:35:34,450 --> 00:35:36,100
0,270 270,780 960,1140 1140,1350 1350,1650
take over,| and {if,it's} really
|如果它没有真的崩溃，

1163
00:35:36,100 --> 00:35:37,600
0,270 270,570 570,900 900,1350 1350,1500
not crash,| then {you,know} {we,have}
|那么我们需要某种方式来仲裁，

1164
00:35:37,600 --> 00:35:38,740
0,150 150,630 630,690 690,870 870,1140
to arbitrate in some way,|
|

1165
00:35:38,740 --> 00:35:39,460
0,120 120,270 270,420 420,540 540,720
will make sure that only
确保他们中只有一个继续。

1166
00:35:39,460 --> 00:35:41,050
0,240 240,330 330,630 660,990 990,1590
one of them actually proceeds.|
|

1167
00:35:41,540 --> 00:35:42,530
0,270 270,420 420,630 630,720 720,990
So let's say the network
让我们假设网络分区，

1168
00:35:42,530 --> 00:35:43,680
0,660
partitions,|
|

1169
00:35:44,520 --> 00:35:45,420
0,150 150,270 270,720 720,840 840,900
and so this is a
当网络分区时，这是一个更困难的情况，

1170
00:35:45,420 --> 00:35:46,530
0,270 270,600 600,780 780,840 840,1110
harder case when the network

1171
00:35:46,530 --> 00:35:48,180
0,660 720,930 930,1260 1260,1380 1380,1650
partitions,| {} instead of like
|比起它们中的一个崩溃，

1172
00:35:48,180 --> 00:35:49,470
0,270 270,330 330,480 480,660 660,1290
one of them two crashes,|
|

1173
00:35:49,680 --> 00:35:51,980
0,330 360,690 720,1110 1110,1830
so here network partitions,|
所以，这里发生网络分区，|

1174
00:35:52,010 --> 00:35:53,960
0,480 510,930 930,1110 1110,1590 1590,1950
{} but {you,know} notice that
但是注意到这两个仍然可以通信，

1175
00:35:53,960 --> 00:35:55,880
0,390 600,930 930,1080 1080,1290 1290,1920
the two could still communicate,|
|

1176
00:35:55,880 --> 00:35:57,290
0,330 330,630 660,930 930,1050 1050,1410
both the primary and backup
主机和备机都可以与存储服务器通信。

1177
00:35:57,290 --> 00:35:58,640
0,150 150,570 570,630 630,780 780,1350
can communicate to the {storage,server}.|
|

1178
00:35:59,610 --> 00:36:00,960
0,180 180,600 720,840 840,990 990,1350
And so in this particular
所以在这种特殊情况下，

1179
00:36:00,960 --> 00:36:02,460
0,540 570,780 780,960 960,1260 1260,1500
case,| what will happen is,|
|接下来会发生的是，|

1180
00:36:02,460 --> 00:36:03,540
0,210 210,390 390,900 900,990 990,1080
they will notice,| you know
它们会注意到，|双方都会注意到，

1181
00:36:03,540 --> 00:36:04,920
0,360 360,630 630,720 720,1290 1290,1380
both sides will notice,| the
|主机和备机将注意到，

1182
00:36:04,920 --> 00:36:06,180
0,240 240,420 420,690 690,780 780,1260
primary and backup will notice,|
|

1183
00:36:06,510 --> 00:36:07,770
0,300 300,480 480,600 600,1140 1140,1260
{} there's some problems,| I
这里有些问题，|我不能与主机通信，

1184
00:36:07,770 --> 00:36:09,420
0,240 240,450 450,540 540,1170 1170,1650
can't talk to {} primary

1185
00:36:09,420 --> 00:36:11,280
0,450 450,660 660,1230 1590,1710 1710,1860
anymore [] [],| and so
|所以在某种程度上，

1186
00:36:11,280 --> 00:36:12,240
0,300 300,450 450,660 660,720 720,960
at some point to say,|
|

1187
00:36:12,240 --> 00:36:13,170
0,270 270,360 360,510 510,720 720,930
well the other guy most
另一个服务器很可能已经崩溃了，

1188
00:36:13,170 --> 00:36:15,000
0,510 540,750 750,870 870,1350 1350,1830
probably could be dead,| and
|我想把自己提升为主机，

1189
00:36:15,000 --> 00:36:16,290
0,180 180,330 330,420 420,720 720,1290
I want to promote myself

1190
00:36:16,290 --> 00:36:17,490
0,150 150,570 570,720 720,810 810,1200
to primary,| so the backup
|所以备机想把自己提升为主机，

1191
00:36:17,490 --> 00:36:18,030
0,120 120,270 270,360 360,480 480,540
is like I want to

1192
00:36:18,030 --> 00:36:19,560
0,300 300,600 600,660 660,1140 1350,1530
promote myself to primary,| or
|或者主机说只想继续为客户端请求提供服务，

1193
00:36:19,560 --> 00:36:20,910
0,330 330,630 630,810 810,1140 1170,1350
primary says like well I

1194
00:36:20,910 --> 00:36:22,110
0,120 120,270 270,330 330,570 570,1200
just want to really continue

1195
00:36:22,110 --> 00:36:25,050
0,1410 1470,1950 1950,2370 2370,2790 2790,2940
{} serving client request| and
|现在只想忽略备机。

1196
00:36:25,050 --> 00:36:26,430
0,60 60,210 210,360 360,660 840,1380
I just want to ignore

1197
00:36:26,430 --> 00:36:27,640
0,90 90,390 390,510 510,870
the backup for now.|
|

1198
00:36:27,970 --> 00:36:29,320
0,240 240,660 660,960 960,1260 1260,1350
So basically says this is
这就是他们所说的继续存活，

1199
00:36:29,320 --> 00:36:30,430
0,180 180,270 270,780 810,960 960,1110
what they call they want

1200
00:36:30,430 --> 00:36:31,760
0,60 60,180 180,270 270,780
to goes {live -},|
|

1201
00:36:32,910 --> 00:36:34,470
0,690 690,960 960,1110 1110,1380 1380,1560
basically we go back into
我们会回到单一模式，

1202
00:36:34,470 --> 00:36:36,030
0,330 330,720 750,1140 1140,1290 1290,1560
single mode| and we want
|我们想要一个主机。

1203
00:36:36,030 --> 00:36:37,440
0,390 390,600 600,780 780,990 990,1410
to and {we,want} one primary.|
|

1204
00:36:38,440 --> 00:36:39,370
0,300 300,390 390,480 480,660 660,930
And so the way this
所以，发生这种情况的方式是，

1205
00:36:39,370 --> 00:36:40,870
0,420 420,540 540,1140 1140,1410 1410,1500
happens is that,| both of
|它们两个都会试着读取，

1206
00:36:40,870 --> 00:36:42,520
0,330 330,510 510,840 1080,1410 1410,1650
them {you,know,send -} try to

1207
00:36:42,520 --> 00:36:44,560
0,480 540,1020 1080,1170 1620,1920 1920,2040
read,| {} they call {}
|它们称为 test-and-set 操作。

1208
00:36:44,560 --> 00:36:46,360
0,270 270,360 360,600 600,1260
{test-and-set - -} operation.|
|

1209
00:36:49,340 --> 00:36:50,090
0,210 210,390 390,420 420,600 600,750
I'll talk a little bit
我会更详细地谈一谈，

1210
00:36:50,090 --> 00:36:50,930
0,210 210,330 330,420 420,570 570,840
about it in more detail,|
|

1211
00:36:50,930 --> 00:36:52,370
0,300 300,630 630,990 990,1260 1260,1440
but basically both reach out
但两者都连接到存储服务器，

1212
00:36:52,370 --> 00:36:53,600
0,60 60,180 180,480 480,960 990,1230
to the storage server,| and
|并试着写入一个标志，比如 1 ，

1213
00:36:53,600 --> 00:36:54,980
0,420 420,660 660,960 960,1020 1020,1380
try to write a flag

1214
00:36:54,980 --> 00:36:57,020
0,480 480,870 870,930 930,1380
saying set to 1,|
|

1215
00:36:57,340 --> 00:36:59,140
0,720 840,1290 1290,1500 1500,1590 1590,1800
{} and if the flag
如果该标志已经被设置为 1 ，

1216
00:36:59,140 --> 00:37:00,220
0,120 120,390 390,600 600,810 840,1080
was already set to set

1217
00:37:00,220 --> 00:37:02,380
0,60 60,510 630,1590 1590,1920 1920,2160
to 1,| then {it,end},| like
|然后就结束了，|因为另一个写入 1 更早，

1218
00:37:02,380 --> 00:37:03,790
0,360 360,450 450,600 600,870 870,1410
the the other guy 1

1219
00:37:03,790 --> 00:37:05,500
0,240 240,750 930,1380 1380,1590 1590,1710
was earlier,| actually goes from
|从 0 到 1 。

1220
00:37:05,500 --> 00:37:06,920
0,240 240,300 300,780
0 to 1.|
|

1221
00:37:07,040 --> 00:37:08,030
0,360 360,480 480,750 750,900 900,990
{} They both try to
它们都试图以原子的方式来做这件事，

1222
00:37:08,030 --> 00:37:09,560
0,120 120,270 270,690 690,1050 1260,1530
do this {atomically -},| one
|其中一个首先完成，

1223
00:37:09,560 --> 00:37:10,910
0,240 240,420 420,570 570,1140 1200,1350
is gonna go first,| you
|将成功地设置为 1 ，

1224
00:37:10,910 --> 00:37:12,770
0,210 210,510 510,660 660,1350 1530,1860
know that will succeed setting

1225
00:37:12,770 --> 00:37:13,640
0,60 60,390 390,570 570,660 660,870
to 1,| and we could
|我们可以返回到旧值 0 ，

1226
00:37:13,640 --> 00:37:15,440
0,420 420,510 510,720 720,1170 1200,1800
return to old value 0,|
|

1227
00:37:15,530 --> 00:37:17,120
0,210 210,420 420,870 870,1230 1230,1590
so it knows that nobody
所以它知道没有其他人成功地写入 1 ，

1228
00:37:17,120 --> 00:37:18,560
0,240 240,690 690,1020 1020,1170 1170,1440
else succeeded actually in writing

1229
00:37:18,560 --> 00:37:19,550
0,90 90,330 330,390 390,630 630,990
to flat to 1 yet,|
|

1230
00:37:19,610 --> 00:37:21,320
0,210 210,900 1050,1290 1290,1470 1470,1710
and therefore I should become
因此，我应该成为主机，让它继续运行。

1231
00:37:21,320 --> 00:37:22,160
0,90 90,480 480,600 600,750 750,840
the primary to keep it

1232
00:37:22,160 --> 00:37:22,940
0,270
running.|
|

1233
00:37:23,370 --> 00:37:24,510
0,150 150,240 240,540 540,1020 1050,1140
And the second guy, you
主备的第二个，

1234
00:37:24,510 --> 00:37:25,830
0,90 90,300 300,420 420,780 780,1320
know what's the {primary/backup -},|
|

1235
00:37:25,830 --> 00:37:27,390
0,60 60,330 330,1230 1230,1470 1470,1560
you know that comes in
来的第二个服务器，

1236
00:37:27,390 --> 00:37:28,740
0,420 540,840 840,1140 1140,1260 1260,1350
second,| {you,know,we'll} see,| we will
|我们会看到，|我们尝试将标志设置为 1 ，

1237
00:37:28,740 --> 00:37:29,490
0,210 210,330 330,480 480,540 540,750
try to set the flag

1238
00:37:29,490 --> 00:37:30,510
0,60 60,420 420,570 570,840 840,1020
to 1,| is already set
|已经设置为 1 ，

1239
00:37:30,510 --> 00:37:31,680
0,60 60,480 480,570 570,900 900,1170
to 1,| the return value
|返回值将是 1 ，

1240
00:37:31,680 --> 00:37:32,640
0,90 90,210 210,510 510,720 720,960
would be 1,| because that's
|因为这是旧的值，

1241
00:37:32,640 --> 00:37:34,080
0,90 90,270 270,810 1020,1350 1350,1440
the old value,| by the
|当进行 test-and-set 操作时，

1242
00:37:34,080 --> 00:37:35,700
0,210 270,720 720,840 840,1410 1410,1620
time you know did test-and-set

1243
00:37:35,700 --> 00:37:37,350
0,630 810,990 990,1440 1440,1530 1530,1650
operation,| and therefore it will
|因此，它将决定，

1244
00:37:37,350 --> 00:37:38,490
0,390 390,750 750,840 840,1080 1080,1140
decide,| well, I'm going to
|好的，我要放弃，

1245
00:37:38,490 --> 00:37:40,050
0,150 150,420 450,1170 1170,1260 1260,1560
give up,| because you know
|因为已经有人接替我了，

1246
00:37:40,050 --> 00:37:41,970
0,420 420,990 990,1380 1380,1710 1710,1920
there's already somebody else who

1247
00:37:41,970 --> 00:37:43,340
0,180 180,540 540,720 720,960
took over for me,|
|

1248
00:37:43,840 --> 00:37:45,100
0,360 360,810 810,960 960,1110 1110,1260
and basically you know as
正如论文中所说的，它们会终止自己。

1249
00:37:45,100 --> 00:37:46,090
0,150 150,390 390,720 720,870 870,990
the paper calls, you know

1250
00:37:46,090 --> 00:37:48,080
0,420 450,930 930,1440
they terminate itself.|
|

1251
00:37:49,990 --> 00:37:51,080
0,570
Okay?|
好的?|

1252
00:37:51,080 --> 00:37:52,100
0,120 120,330 330,450 450,540 540,1020
So that's sort of the
所以这是一种高级别的操作，

1253
00:37:52,130 --> 00:37:56,630
0,750 750,1980 2040,2190 2190,2970 3330,4500
high-level operation,| { - -}
|故障高级操作。

1254
00:37:56,660 --> 00:37:58,490
0,210 210,390 390,870 870,1410 1500,1830
{high-level -} operation failure.| There's
|在聊天中有一个问题，是一个好问题，

1255
00:37:58,490 --> 00:38:00,170
0,180 180,570 570,630 630,630 1260,1680
a {quick,question} in {} chat

1256
00:38:00,170 --> 00:38:01,370
0,60 60,120 120,240 240,720 1020,1200
is a good question,| and
|标志何时重置为 0 。

1257
00:38:01,370 --> 00:38:02,240
0,180 180,270 270,360 360,570 570,870
when is the flag reset

1258
00:38:02,240 --> 00:38:03,240
0,60 60,510
to 0.|
|

1259
00:38:03,490 --> 00:38:04,930
0,540 570,870 870,1050 1050,1410 1410,1440
Well, there's {sort,of} basically a
嗯，这是一个完全不同的故事，

1260
00:38:04,930 --> 00:38:06,640
0,240 240,570 570,1200 1230,1590 1590,1710
whole separate story,| that I'm
|我还在讨论，会逐渐看到，

1261
00:38:06,640 --> 00:38:08,050
0,270 270,480 480,780 810,900 900,1410
talking about yet, you know

1262
00:38:08,050 --> 00:38:09,610
0,240 240,510 510,810 1050,1260 1260,1560
{see,it} get through,| {} is
|就是一旦主机运行，

1263
00:38:09,610 --> 00:38:10,960
0,360 540,1050 1050,1170 1170,1260 1260,1350
that once you know the

1264
00:38:10,960 --> 00:38:12,850
0,360 360,870 900,1140 1140,1770 1770,1890
primary runs,| on when we
|当我们有一个服务器运行时，

1265
00:38:12,850 --> 00:38:14,740
0,150 150,690 720,1200 1200,1440 1440,1890
have one server running now,|
|

1266
00:38:14,980 --> 00:38:16,390
0,300 300,570 570,840 840,1050 1050,1410
{} would like to make
会做第二个备份，

1267
00:38:16,390 --> 00:38:17,680
0,150 150,420 420,930 960,1110 1110,1290
a second backup,| you know
|所以我们又有一个备机，

1268
00:38:17,680 --> 00:38:18,880
0,330 330,480 480,690 690,840 840,1200
and so get into position

1269
00:38:18,880 --> 00:38:19,960
0,150 150,270 270,600 600,840 840,1080
that we're basically having {backup

1270
00:38:19,960 --> 00:38:20,860
0,60 60,600 600,690 690,810 810,900
-} again,| we have to
|我们必须做修复，

1271
00:38:20,860 --> 00:38:22,180
0,90 90,270 270,510 510,1080 1110,1320
do what's called repair,| because
|因为我们不做修复，

1272
00:38:22,180 --> 00:38:23,800
0,120 120,300 300,420 420,1020 1140,1620
we don't do repair,| then
|那么从两台计算机开始，

1273
00:38:23,860 --> 00:38:25,000
0,120 120,270 270,540 660,1020 1020,1140
you know the start with

1274
00:38:25,000 --> 00:38:26,380
0,120 120,630 630,900 900,1260 1260,1380
two computers,| one fails, then
|一台计算机出现故障，我们就只有一台计算机，

1275
00:38:26,380 --> 00:38:27,490
0,60 60,150 150,360 360,840 870,1110
we have one computer,| and
|然后过一会儿，

1276
00:38:27,490 --> 00:38:28,390
0,60 60,240 240,330 330,720 720,900
a little bit later,| one
|一台计算机可能出现故障，那么我们就没有计算机了。

1277
00:38:28,390 --> 00:38:29,200
0,270 270,390 390,660 660,750 750,810
computer may fail, then we

1278
00:38:29,200 --> 00:38:30,540
0,90 90,240 240,600 600,990
have no computers anymore.|
|

1279
00:38:30,720 --> 00:38:31,410
0,180 180,300 300,540 540,600 600,690
So it has to be
所以必须是这样，

1280
00:38:31,410 --> 00:38:32,100
0,60 60,360 360,510 510,630 630,690
the case,| there has to
|必须有一个修复方案，

1281
00:38:32,100 --> 00:38:34,200
0,120 120,270 270,780 780,1140 1590,2100
be a repair plan,| and
|在 VMFT 中，修复方案是人工执行的，

1282
00:38:34,200 --> 00:38:36,540
0,720 750,1500 1500,2010 2010,2220 2220,2340
in VMFT, repair plan is

1283
00:38:36,540 --> 00:38:38,730
0,420 420,930 1080,1440 1440,2100 2100,2190
executed manually,| if somebody you
|如果有人收到监控的通知，

1284
00:38:38,730 --> 00:38:42,390
0,120 120,870 870,1590 1950,3000 3000,3660
know monitors, where monitor software

1285
00:38:42,570 --> 00:38:44,010
0,480 480,690 690,750 750,1140 1140,1440
{} sort of noticed this,|
|

1286
00:38:44,010 --> 00:38:45,690
0,180 180,600 600,1050 1050,1410 1410,1680
and basically creates a new
然后创建一个新的复制，

1287
00:38:45,690 --> 00:38:48,240
0,630 810,1650 1650,1950 1950,2370 2370,2550
replica,| {} or based on
|或者基于第一个虚拟机镜像，

1288
00:38:48,240 --> 00:38:49,830
0,420 450,840 840,1140 1140,1290 1290,1590
the VM image of the

1289
00:38:49,830 --> 00:38:52,740
0,120 120,360 360,780 1050,1710 2160,2910
the first one,| {} {ensures,that}
|确保它们同步，

1290
00:38:52,740 --> 00:38:54,270
0,120 120,600 720,960 960,1440 1440,1530
in sync,| and then you
|然后它会重置标志，

1291
00:38:54,270 --> 00:38:56,520
0,240 240,720 720,1470 1560,2070 2070,2250
know it {} reset that

1292
00:38:56,520 --> 00:38:58,020
0,420 420,1020 1020,1170 1170,1320 1320,1500
flag,| and you know in
|当日志重新开始时，

1293
00:38:58,020 --> 00:39:00,240
0,420 930,1440 1440,1740 1740,2100 2100,2220
log log starts again,| and
|然后标志会重置，

1294
00:39:00,240 --> 00:39:01,560
0,480 480,570 570,810 810,930 930,1320
then the flag is reset,|
|

1295
00:39:01,560 --> 00:39:03,240
0,330 420,810 810,990 990,1260 1260,1680
so once that second primary
当第二个主机完成备份，

1296
00:39:03,240 --> 00:39:04,500
0,360 360,630 630,990
completely {backup -},|
|

1297
00:39:04,530 --> 00:39:07,050
0,930 930,1410 1440,1710 1710,2430 2430,2520
yeah and {} following the
跟据协议，标志就重置了。

1298
00:39:07,050 --> 00:39:09,060
0,510 510,990 990,1110 1110,1440 1470,2010
protocol, then the flag reset.|
|

1299
00:39:09,690 --> 00:39:10,740
0,510
Okay?|
好的?|

1300
00:39:13,590 --> 00:39:15,700
0,540 660,1530
Okay. {}|
好的。|

1301
00:39:17,550 --> 00:39:18,390
0,300 300,480 480,600 600,630 630,840
Okay, great, there's a great
好的，有一个好问题，

1302
00:39:18,390 --> 00:39:20,280
0,360 360,630 630,1080 1080,1710 1710,1890
question,| like why, {you,know} may
|比如可能日志通道中断，

1303
00:39:20,280 --> 00:39:21,570
0,90 90,450 450,930 930,1170 1170,1290
be logging channel broke,| that
|可能通道到服务器也中断了，

1304
00:39:21,570 --> 00:39:25,860
0,390 390,1140 1770,2400 2430,3180 3630,4290
maybe the the the the

1305
00:39:26,220 --> 00:39:27,630
0,450 450,540 540,600 600,1140 1140,1410
channel to the server broke

1306
00:39:27,630 --> 00:39:29,850
0,300 480,930 930,1680 1680,1980 1980,2220
too,| and {} and so
|所以我们不会得到回应，

1307
00:39:29,850 --> 00:39:30,840
0,240 240,420 420,600 600,810 810,990
you know we're not gonna

1308
00:39:30,840 --> 00:39:32,160
0,150 150,210 210,930
get a response,|
|

1309
00:39:32,160 --> 00:39:33,510
0,240 240,570 570,990 990,1110 1110,1350
and that basically that point
这就是系统停止的时刻，

1310
00:39:33,510 --> 00:39:34,830
0,60 60,360 360,480 480,1020 1050,1320
the system just stops,| if
|直到某些东西修复，

1311
00:39:34,830 --> 00:39:36,660
0,120 120,510 540,1320 1320,1680 1680,1830
you will, until something {repairs

1312
00:39:36,660 --> 00:39:38,580
0,510 870,1500 1500,1710 1710,1830 1830,1920
-},| because nothing can be
|因为什么都做不了，

1313
00:39:38,580 --> 00:39:39,450
0,240 270,480 480,570 570,690 690,870
done,| so at that point
|所以从那时起，

1314
00:39:39,450 --> 00:39:40,470
0,90 90,270 270,570 570,720 720,1020
from then on,| no clients
|没有客户端请求处理，

1315
00:39:40,470 --> 00:39:43,320
0,330 330,690 690,1380 1710,2520 2520,2850
request actually process,| {} because
|因为我们不知道我们是什么状态，

1316
00:39:43,320 --> 00:39:44,490
0,240 240,480 480,600 600,870 870,1170
we don't know what state

1317
00:39:44,490 --> 00:39:45,380
0,90 90,420
we are,|
|

1318
00:39:46,300 --> 00:39:47,260
0,270 270,570 570,630 630,750 750,960
and maybe at some point
也许在某个时刻，网络连接得到修复，

1319
00:39:47,260 --> 00:39:49,210
0,360 360,630 630,870 870,1170 1170,1950
network link will get {}

1320
00:39:49,240 --> 00:39:51,040
0,570 570,840 840,1440 1440,1650 1650,1800
repaired,| and {that,point} things get
|那么事情又开始向前发展，

1321
00:39:51,040 --> 00:39:52,870
0,330 360,660 660,990 990,1230 1620,1830
started moving forward again,| so
|所以这是一个灾难案例，

1322
00:39:52,870 --> 00:39:54,340
0,150 150,270 270,570 570,1110 1110,1470
this is a disaster case,|
|

1323
00:39:54,370 --> 00:39:56,410
0,720 960,1350 1350,1530 1530,1620 1620,2040
where {} you know disaster
灾难案例是，

1324
00:39:56,410 --> 00:39:57,340
0,240 240,330 330,540 540,630 630,930
case is,| actually the primary
|主备都在运行，

1325
00:39:57,340 --> 00:39:59,080
0,330 330,990 1020,1350 1350,1620 1620,1740
backup or both actually up

1326
00:39:59,080 --> 00:39:59,770
0,90 90,300 300,420 420,600 600,690
and running,| but all the
|但是所有网线都断了。

1327
00:39:59,770 --> 00:40:01,200
0,240 240,570 570,960
network cables broken.|
|

1328
00:40:01,230 --> 00:40:02,160
0,390 390,690 690,750 750,870 870,930
And which is sort of
与这个案例有些相似，

1329
00:40:02,160 --> 00:40:03,330
0,330 330,720 720,840 840,930 930,1170
similar basically to the case,|
|

1330
00:40:03,330 --> 00:40:04,800
0,270 300,510 510,600 600,960 960,1470
where both the primary {backup,failed}
主备同时失败的情况。

1331
00:40:04,800 --> 00:40:05,940
0,60 60,120 120,360 360,600
at the same time.|
|

1332
00:40:09,090 --> 00:40:12,000
0,330 330,900 1800,2220 2220,2490 2490,2910
Okay.| Question, could you explain
好的。|问题，你能再解释一遍吗，

1333
00:40:12,000 --> 00:40:13,380
0,390 390,570 570,810 810,1260 1260,1380
again real quick,| when the
|当客户端从存储服务器读取数据时。

1334
00:40:13,380 --> 00:40:15,000
0,540 540,690 690,1050 1050,1320 1320,1620
client is reading from the

1335
00:40:15,000 --> 00:40:16,480
0,480 480,960
storage server.|
|

1336
00:40:16,540 --> 00:40:17,710
0,360 360,570 570,840 840,1050 1050,1170
{The,client} never read really from
客户端完全不从存储服务器读取数据，

1337
00:40:17,710 --> 00:40:20,440
0,60 60,360 360,810 840,1170 1980,2730
the storage server,| that's the
|可能是 Linux ，

1338
00:40:20,470 --> 00:40:21,760
0,690 690,840 840,1080 1080,1200 1200,1290
Linux that might,| or the
|或者在 Linux 上运行的应用程序

1339
00:40:21,760 --> 00:40:22,720
0,390 390,600 600,690 690,870 870,960
application running on top of

1340
00:40:22,720 --> 00:40:23,620
0,270 270,450 450,540 540,780 780,900
Linux| might be running from
|可能从存储服务器运行，

1341
00:40:23,620 --> 00:40:24,850
0,60 60,360 360,810 840,1020 1020,1230
the storage server,| and that's
|这是一种情况。

1342
00:40:24,850 --> 00:40:25,570
0,90 90,330 330,600 600,660 660,720
the one case.| And the
|第二种情况，

1343
00:40:25,570 --> 00:40:27,190
0,300 300,750 960,1290 1290,1470 1470,1620
second case,| the {VM-FT -
|VM-FT 可能从存储服务器运行，

1344
00:40:27,190 --> 00:40:28,180
0,330 330,510 510,600 600,870 870,990
-} might be running from

1345
00:40:28,180 --> 00:40:29,290
0,90 90,600 600,750 750,930 930,1110
the {storage,server}| to read that
|以读取 test-and-set 标志。

1346
00:40:29,290 --> 00:40:30,670
0,420 420,660 720,1020 1020,1230 1230,1380
flag or {test-and-set -} {}

1347
00:40:30,670 --> 00:40:31,500
0,360
flag.|
|

1348
00:40:31,690 --> 00:40:32,650
0,210 210,360 360,540 540,750 750,960
So that like green arrow
所以底部的绿色箭头，

1349
00:40:32,650 --> 00:40:33,400
0,90 90,150 150,510 510,660 660,750
at the bottom| from the
|从存储服务器到 C ，是。

1350
00:40:33,400 --> 00:40:35,660
0,330 330,750 750,1140 1140,1740
storage server to C,

1351
00:40:36,910 --> 00:40:39,130
0,510 510,1020 1230,1590 1590,1800 1800,2220
is a.| {} I'm sorry,
|抱歉，那个绿色的，是个错误的绿色箭头，

1352
00:40:39,130 --> 00:40:41,500
0,30 30,390 1650,1890 1890,2070 2070,2370
that green, that's a bad

1353
00:40:41,500 --> 00:40:42,400
0,180 180,480 480,660 660,780 780,900
green arrow,| that should have
|应该一直到这里的。

1354
00:40:42,400 --> 00:40:44,260
0,480 480,630 630,690 690,930 1290,1860
gone all the way.| Okay,
|好的，谢谢。

1355
00:40:44,290 --> 00:40:45,520
0,330 330,510 750,900 900,1050 1050,1230
thank you.| And just going
|只是通过网络，

1356
00:40:45,520 --> 00:40:46,540
0,180 180,240 240,660 660,840 840,1020
over the network| and not
|并不打算去 C ，

1357
00:40:46,540 --> 00:40:47,320
0,300 300,390 390,540 540,630 630,780
intended to go to C,|
|

1358
00:40:47,320 --> 00:40:48,010
0,90 90,210 210,540 540,600 600,690
it was intended to go
它是打算通过网络。

1359
00:40:48,010 --> 00:40:49,080
0,120 120,180 180,630
over the network.|
|

1360
00:40:49,820 --> 00:40:51,840
0,360 360,660 660,1140 1140,1440
Thanks for clarifying that,
谢谢你澄清这一点，认识到这一点。

1361
00:40:52,100 --> 00:40:54,830
0,330 330,660 660,900 1080,1800 2100,2730
and realize that.| Okay, so.|
|好的，所以。|

1362
00:40:55,010 --> 00:40:56,160
0,570

1363
00:40:56,950 --> 00:40:57,910
0,180 180,300 300,450 450,660 660,960
So what I'd like, {}
所以我想，

1364
00:40:57,910 --> 00:40:59,020
0,120 120,210 210,330 330,570 600,1110
so I want to,| maybe
|也许我们可以中断一下，

1365
00:40:59,020 --> 00:41:00,670
0,120 120,240 240,420 420,990 1020,1650
if we take a quick

1366
00:41:00,700 --> 00:41:02,350
0,660 690,990 990,1050 1050,1200 1200,1650
{} break at this point,|
|

1367
00:41:02,530 --> 00:41:03,730
0,240 240,360 360,450 450,870 870,1200
or do a breakout room,|
或者一个分组会议室，|

1368
00:41:03,880 --> 00:41:05,770
0,750 750,1260 1260,1590 1590,1710 1710,1890
{} in particular, would like
特别想请大家做的，

1369
00:41:05,770 --> 00:41:06,760
0,120 120,180 180,600 600,810 810,990
you to do,| and talk
|讨论一下家庭作业的问题，

1370
00:41:06,760 --> 00:41:07,390
0,60 60,240 240,360 360,570 570,630
a little bit about the

1371
00:41:07,390 --> 00:41:09,760
0,360 360,930 1230,1830 1830,2130 2130,2370
homework question,| {} which we
|我们在这里谈到了，

1372
00:41:09,760 --> 00:41:11,800
0,420 420,540 540,1050 1110,1770 1770,2040
sort of covered {} at

1373
00:41:11,800 --> 00:41:13,270
0,180 180,810 930,1320 1320,1350 1350,1470
this instance,| but I want
|但是我想你好好想想，

1374
00:41:13,270 --> 00:41:14,440
0,90 90,210 210,360 360,840 840,1170
you to think about it,|
|

1375
00:41:15,990 --> 00:41:17,220
0,450 450,540 540,900 900,1080 1080,1230
understand or argue with each
理解或互相讨论，

1376
00:41:17,220 --> 00:41:19,050
0,420 420,780 780,1050 1050,1410 1410,1830
other,| and {you,know} convince yourself,|
|说服自己，|

1377
00:41:19,050 --> 00:41:21,120
0,120 120,210 210,540 540,1050 1200,2070
that the scheme actually provides
这个方案避免了[]，

1378
00:41:21,150 --> 00:41:23,250
0,480 480,1170 1170,1320 1320,1620 1650,2100
{} avoids this sort of

1379
00:41:23,760 --> 00:41:25,410
0,720 720,990 990,1110 1110,1410 1410,1650
[],| you know {split-brain -}
|脑裂问题，

1380
00:41:25,410 --> 00:41:26,460
0,450 450,540 540,600 600,870 870,1050
syndrome,| in the sense, that
|永远不会出现两个主机。

1381
00:41:26,460 --> 00:41:27,510
0,210 210,630 630,870 870,930 930,1050
there's never going to be

1382
00:41:27,510 --> 00:41:28,760
0,150 150,810
two primaries.|
|

1383
00:41:28,760 --> 00:41:29,810
0,120 120,360 360,630 630,720 720,1050
The second thing you know
第二件事要讨论的是，

1384
00:41:29,810 --> 00:41:31,970
0,270 270,510 510,1110 1110,1770 1890,2160
maybe to debate is,| this
|这是一个合理的设计，

1385
00:41:31,970 --> 00:41:33,230
0,90 90,450 450,1020 1020,1200 1200,1260
a reasonable design,| because it
|因为看起来我们所做的是，

1386
00:41:33,230 --> 00:41:34,550
0,210 210,540 540,870 870,990 990,1320
looks like what we've done

1387
00:41:34,550 --> 00:41:35,660
0,150 150,450 450,660 660,810 810,1110
is,| we put all the
|我们把真正的硬容错部分都放到了存储服务器中，

1388
00:41:35,690 --> 00:41:36,980
0,360 360,720 720,960 960,1020 1020,1290
real hard part of fault

1389
00:41:36,980 --> 00:41:38,240
0,300 300,510 510,600 600,900 900,1260
tolerance into the storage server,|
|

1390
00:41:38,300 --> 00:41:39,020
0,180 180,270 270,420 420,630 630,720
and it's not really the
事实并非如此，

1391
00:41:39,020 --> 00:41:39,920
0,330 330,480 480,570 570,720 720,900
case,| why is that not
|为什么不是这样？

1392
00:41:39,920 --> 00:41:41,540
0,60 60,510 900,1200 1200,1440 1440,1620
the case.| {} So that
|所以这是我想让你们讨论的两件事，

1393
00:41:41,540 --> 00:41:42,800
0,210 210,720 780,930 930,1140 1140,1260
seems like two things that

1394
00:41:42,800 --> 00:41:44,420
0,600 600,810 810,900 900,990 990,1620
I'd like you to discuss,|
|

1395
00:41:44,540 --> 00:41:45,980
0,480 480,600 600,720 720,1110 1110,1440
{} in these breakout rooms.|
在分组会议室里。|

1396
00:41:46,010 --> 00:41:46,760
0,150 150,210 210,330 330,450 450,750
So I'm going to stop
所以我要停止分享。

1397
00:41:46,760 --> 00:41:47,860
0,90 90,660
the sharing.|
|

1398
00:41:50,530 --> 00:41:53,360
0,600 600,1530 1620,1890 1890,2250
{} And {I'm,gonna}, {}
我要做的参与，

1399
00:41:54,870 --> 00:41:57,480
0,1110 1170,1680 1680,1860 1860,2130 2130,2610
participants,| I'm gonna make Lily
|我要让 Lily 来主持，

1400
00:41:57,480 --> 00:41:58,660
0,690
host,|
|

1401
00:41:59,210 --> 00:41:59,930
0,180 180,330 330,420 420,510 510,720
so that you can set
这样你们可以设置分组会议室，

1402
00:41:59,930 --> 00:42:02,260
0,90 90,540 810,1170 1170,1800
up the {breakout,rooms -},|
|

1403
00:42:03,490 --> 00:42:05,470
0,570 660,840 840,1440 1470,1860 1860,1980
and {you,know} enjoy talk to
享受互相讨论。

1404
00:42:05,470 --> 00:42:06,420
0,120 120,390
each other.|
|

1405
00:42:08,180 --> 00:42:09,320
0,450 450,570 570,690 690,960 960,1140
Lily, you got this under
Lily ，控制权交给你了。

1406
00:42:09,320 --> 00:42:10,420
0,570
control.|
|

1407
00:46:19,440 --> 00:46:20,340
0,510 510,570 570,720 720,810 810,900
Testing to see if I
测试看看我能不能加入不同的房间，

1408
00:46:20,340 --> 00:46:21,660
0,210 210,510 510,930 930,990 990,1320
can {} join a different

1409
00:46:21,660 --> 00:46:23,220
0,240 240,420 420,990
room this time,|
|

1410
00:46:28,000 --> 00:46:29,080
0,120 120,300 300,510 510,720 720,1080
it's not looking good though.|
情况看起来并不乐观。|

1411
00:46:34,000 --> 00:46:35,760
0,990

1412
00:47:04,190 --> 00:47:06,140
0,330 360,600 600,1110 1290,1590 1590,1950
Well, yes, I'm stuck here.|
是的，我被困在这里了。|

1413
00:49:28,440 --> 00:49:29,880
0,60

1414
00:49:40,930 --> 00:49:42,260
0,780

1415
00:49:54,720 --> 00:49:56,420
0,180 180,1020
The {screen,again},|
又是屏幕，|

1416
00:50:01,020 --> 00:50:03,080
0,270 270,480 480,870 870,1410
can everyone {see,my} screen?|
大家能看到我的屏幕吗？|

1417
00:50:06,380 --> 00:50:07,420
0,480
Yes.|
是的。|

1418
00:50:07,420 --> 00:50:09,640
0,480 510,930 1050,1650
Okay, good. {}|
好的，很好。|

1419
00:50:09,640 --> 00:50:10,570
0,360 480,630 630,780 780,840 840,930
So I hope you had
所以我希望你们讨论得很愉快，

1420
00:50:10,570 --> 00:50:12,130
0,30 30,150 150,690 720,1170 1200,1560
a good discussion,| and hopefully
|希望班上有比以前更多的新学生。

1421
00:50:12,130 --> 00:50:13,900
0,150 150,270 270,750 780,1440 1440,1770
get {} more new students

1422
00:50:13,900 --> 00:50:16,030
0,60 60,150 150,720 1110,1470 1470,2130
in the class {} than

1423
00:50:16,060 --> 00:50:17,520
0,240 240,390 390,930
you knew before.|
|

1424
00:50:17,580 --> 00:50:19,530
0,870 870,1080 1080,1290 1290,1380 1380,1950
And let's sort of proceed,|
让我们继续，|

1425
00:50:19,800 --> 00:50:20,850
0,330 330,630 630,690 690,870 870,1050
{} talking a little bit
讨论一下 VM-FT 的设计，

1426
00:50:20,850 --> 00:50:24,000
0,360 360,1350 1830,2040 2040,2580 2580,3150
about the the design of

1427
00:50:24,090 --> 00:50:26,560
0,750 1200,1950
{ -}

1428
00:50:26,620 --> 00:50:27,850
0,300 300,510 510,630 630,1140 1140,1230
of {} the VMFT,| and
|并且快速总结。

1429
00:50:27,850 --> 00:50:29,650
0,180 180,720 720,1260 1260,1740 1740,1800
there's like summarize quickly, you

1430
00:50:29,650 --> 00:50:31,990
0,330 660,900 900,1200 1230,1950 1950,2340
know.| {Sorry,could} you repeat like
|抱歉，您能重复一下标志是什么时候设置为 0 吗，

1431
00:50:32,170 --> 00:50:33,580
0,330 330,450 450,810 810,960 960,1410
when the flag is reset

1432
00:50:33,580 --> 00:50:34,420
0,150 150,420 420,510 510,660 660,840
to 0,| I feel like
|我觉得我们中的一些人可能错过了解释。

1433
00:50:34,420 --> 00:50:35,260
0,150 150,270 270,570 570,720 720,840
some of us might have

1434
00:50:35,260 --> 00:50:37,640
0,300 300,1320 1350,1830
missed explanation.| Okay,
|好的，很好。

1435
00:50:37,700 --> 00:50:39,440
0,540 540,810 810,1230 1230,1500 1500,1740
{} okay, so okay, good

1436
00:50:39,440 --> 00:50:40,460
0,360 360,510 510,750 750,870 870,1020
good good.| Okay, so let
|好的，让我，

1437
00:50:40,460 --> 00:50:42,290
0,270 780,1140 1140,1290 1290,1560 1560,1830
me,| okay, so here let's
|好的，让我们再画一遍，

1438
00:50:42,290 --> 00:50:43,850
0,210 210,330 330,600 600,1020 1080,1560
draw the picture again, {}|
|

1439
00:50:43,850 --> 00:50:45,080
0,270 270,420 420,480 480,870 870,1230
it's sort of similar way,|
这是类似的方式，|

1440
00:50:45,080 --> 00:50:46,970
0,450 450,720 720,1410 1470,1710 1710,1890
here's our primary with the
这是我们的主机虚拟机，所有东西都在其中，

1441
00:50:46,970 --> 00:50:48,620
0,630 660,1020 1020,1200 1200,1380 1380,1650
VM, everything in it,| here's
|这是备机，以及里面的所有东西，

1442
00:50:48,620 --> 00:50:49,800
0,60 60,690
the backup,

1443
00:50:49,800 --> 00:50:51,180
0,240 240,750 750,900 900,1230 1260,1380
with everything in it,| you
|日志频道在中间，

1444
00:50:51,180 --> 00:50:52,530
0,270 270,510 510,720 720,1080 1080,1350
know and just logging channel

1445
00:50:52,530 --> 00:50:54,690
0,90 90,780 1020,1170 1170,1800 1830,2160
in between,| {you,know} connected to
|连接到一个存储服务器。

1446
00:50:54,690 --> 00:50:56,670
0,0 0,420 420,900 1200,1740 1860,1980
a storage server.| And you
|有一件事需要考虑一下，

1447
00:50:56,670 --> 00:50:57,390
0,60 60,270 270,450 450,540 540,720
know one thing to think

1448
00:50:57,390 --> 00:50:58,320
0,240 240,420 420,540 540,600 600,930
about this,| that the storage
|存储服务器扮演两个角色，

1449
00:50:58,320 --> 00:50:59,880
0,360 360,630 630,870 870,1050 1050,1560
servers to playing two roles,|
|

1450
00:50:59,910 --> 00:51:01,000
0,210 210,630
so let's
所以让我们把这两个角色分开，

1451
00:51:01,150 --> 00:51:02,590
0,420 420,480 480,630 630,1050 1080,1440
separate the two roles,| one
|一个是存储，

1452
00:51:02,590 --> 00:51:03,850
0,300 300,450 450,600 600,1140 1140,1260
is {you,knwo} to storage you

1453
00:51:03,850 --> 00:51:05,800
0,90 90,720 780,1020 1020,1410 1410,1950
know for,| {} disk basically
|用于主机和备机的磁盘，

1454
00:51:05,800 --> 00:51:07,060
0,300 300,570 570,690 690,780 780,1260
for you know the primary

1455
00:51:07,060 --> 00:51:08,620
0,540 540,900 900,1290 1290,1410 1410,1560
{and,backup},| when we could just
|我们可以拆分它们，

1456
00:51:08,620 --> 00:51:10,210
0,240 240,480 510,870 1140,1470 1470,1590
split that,| and attach the
|并将磁盘连接到主备机，

1457
00:51:10,210 --> 00:51:11,500
0,300 300,360 360,450 450,810 810,1290
disk to the primary backup,|
|

1458
00:51:11,950 --> 00:51:13,810
0,600 690,900 900,1320 1320,1770 1770,1860
then where basically have the
然后另一个角色是仲裁服务器，

1459
00:51:13,810 --> 00:51:15,130
0,330 330,780 780,990 990,1230 1230,1320
role here is really the

1460
00:51:15,130 --> 00:51:16,580
0,570 570,990
arbitration server,|
|

1461
00:51:18,540 --> 00:51:18,960
0,90

1462
00:51:19,450 --> 00:51:20,380
0,60

1463
00:51:20,440 --> 00:51:22,090
0,480 480,750 750,960 960,990 990,1650
and it has a flag,|
它有一个标志，|

1464
00:51:24,010 --> 00:51:24,940
0,150 150,210 210,420 420,540 540,930
and the flag was initially
标志最初是 0 ，

1465
00:51:24,940 --> 00:51:26,860
0,450 630,1110 1110,1260 1260,1470 1470,1920
0, right.| And so now
|所以现在假设，

1466
00:51:26,860 --> 00:51:28,870
0,210 210,450 450,720 720,990 1560,2010
let's say,| there's a partition
|主备之间有一个分区，

1467
00:51:28,870 --> 00:51:30,250
0,120 120,570 570,990 990,1110 1110,1380
to primary backup| can actually
|不能再相互通信，

1468
00:51:30,250 --> 00:51:32,980
0,360 780,1500 1500,2280 2310,2550 2550,2730
not talk to each other

1469
00:51:32,980 --> 00:51:33,700
0,330 330,450 450,540 540,660 660,720
anymore,| so they're going to
|所以它们要访问仲裁服务器，

1470
00:51:33,700 --> 00:51:35,320
0,270 270,390 390,870 870,1170 1170,1620
talk to arbitration server,| basically
|试着提高自己作为单独存活的服务器，

1471
00:51:35,320 --> 00:51:37,210
0,390 510,900 900,990 990,1320 1320,1890
to try to promote themselves

1472
00:51:37,210 --> 00:51:39,250
0,180 180,270 270,1020 1020,1770 1800,2040
to the single {} {to,go}

1473
00:51:39,250 --> 00:51:40,780
0,450 450,690 690,870 870,1260 1260,1530
live,| and {sort,of} do single
|作为单台服务器为客户端请求提供服务。

1474
00:51:40,780 --> 00:51:42,900
0,390 390,750 750,1140 1140,1650
server, server {the,client} request.|
|

1475
00:51:43,470 --> 00:51:44,220
0,180 180,240 240,480 480,690 690,750
So they both send the
所以它们都将数据包发送到 test-and-set 操作，

1476
00:51:44,220 --> 00:51:45,390
0,360 360,690 690,870 870,1080 1080,1170
packet to the {test-and-set -

1477
00:51:45,390 --> 00:51:47,190
0,180 180,900 1140,1320 1320,1590 1590,1800
-} operation,| {} one get
|一个得到 0 ，

1478
00:51:47,190 --> 00:51:48,180
0,330 330,660 660,720 720,810 810,990
0 back,| {the,other - -}
|另一个得到 1 ，

1479
00:51:48,180 --> 00:51:49,380
0,150 150,450 450,780 780,1050 1050,1200
get 1 back,| one gets
|得到 1 的知道它是第二个尝试的，

1480
00:51:49,380 --> 00:51:50,430
0,270 270,510 510,810 810,930 930,1050
1 back, knows that it

1481
00:51:50,430 --> 00:51:51,600
0,150 150,510 510,690 690,1050 1050,1170
was actually the second who

1482
00:51:51,600 --> 00:51:54,480
0,510 840,1020 1020,1470 1470,1470 1470,2880
tried,| and then, {} and
|然后，第一个会成功，并继续存活，

1483
00:51:54,480 --> 00:51:55,500
0,120 120,240 240,480 480,870 870,1020
so the first one will

1484
00:51:55,500 --> 00:51:56,550
0,420 420,510 510,630 630,750 750,1050
succeed, and will go alive,|
|

1485
00:51:56,550 --> 00:51:57,450
0,180 180,360 360,510 510,690 690,900
so let's say this guy
所以让我们假设这个存活，

1486
00:51:57,450 --> 00:51:59,400
0,210 210,600 1320,1500 1500,1650 1650,1950
goes live,| and this guy
|然后这个就消失了，

1487
00:51:59,400 --> 00:52:01,060
0,510 510,1230
just disappears,|
|

1488
00:52:01,210 --> 00:52:03,550
0,300 300,570 570,1080 1080,1560 1890,2340
the virtual machine is terminate
虚拟机会自己终止，然后完成，

1489
00:52:03,550 --> 00:52:06,160
0,630 630,1350 1350,1620 1620,2010
itself and is done,|
|

1490
00:52:06,890 --> 00:52:08,300
0,300 300,600 600,810 810,900 900,1410
and so now the {flag,is,set}
现在标志设置为 1 。

1491
00:52:08,300 --> 00:52:09,420
0,570
1.|
|

1492
00:52:12,020 --> 00:52:12,710
0,120 120,180 180,420 420,600 600,690
And of course now at
当然，在这一点上，

1493
00:52:12,710 --> 00:52:13,880
0,120 120,300 300,450 450,570 570,1170
this point,| there's no arbitration
|不再需要仲裁了，

1494
00:52:13,880 --> 00:52:15,110
0,480 480,720 720,930 930,1110 1110,1230
necessary more,| because there's no
|因为没有第二个复制，

1495
00:52:15,110 --> 00:52:17,240
0,720 720,1230 1260,1620 1620,1740 1740,2130
secondary replica,| there's no backup
|根本没有备机，

1496
00:52:17,240 --> 00:52:18,500
0,90 90,330 690,930 930,1170 1170,1260
at all,| so really the
|所以真正的问题是接下来会发生什么，

1497
00:52:18,500 --> 00:52:19,880
0,330 330,480 480,750 750,1110 1110,1380
question is like what happens

1498
00:52:19,880 --> 00:52:21,500
0,480 780,1290 1290,1350 1350,1560 1560,1620
next,| and in terms of
|在修复方面，

1499
00:52:21,500 --> 00:52:22,520
0,510 510,630 630,870 870,930 930,1020
repair,| that has to be
|会是这种情况，

1500
00:52:22,520 --> 00:52:23,480
0,60 60,390 390,510 510,600 600,960
the case,| that the second
|第二个新的备机拉起存活，

1501
00:52:23,480 --> 00:52:25,010
0,390 420,750 750,1140 1140,1260 1260,1530
backup, new backup is brought

1502
00:52:25,010 --> 00:52:26,120
0,150 150,450 450,540 540,870 870,1110
up to {alive -}, correct,|
|

1503
00:52:26,120 --> 00:52:27,830
0,570 810,1140 1140,1290 1290,1650 1650,1710
and section {3.1 -} the
这篇论文的 3.1 节对此进行了详细的讨论，

1504
00:52:27,830 --> 00:52:28,730
0,270 270,480 480,690 690,810 810,900
paper talks about this in

1505
00:52:28,730 --> 00:52:29,660
0,210 210,240 240,390 390,450 450,930
quite a bit of detail,|
|

1506
00:52:30,230 --> 00:52:31,670
0,600 660,810 810,960 960,1080 1080,1440
and the way it works
它的工作方式是，

1507
00:52:31,670 --> 00:52:33,140
0,270 270,690 690,840 840,1140 1140,1470
is that,| you know on
|在用户接口上，

1508
00:52:33,140 --> 00:52:34,310
0,120 120,420 420,990 990,1080 1080,1170
the user interface,| you know
|对于系统来说， VMware VMotion ，

1509
00:52:34,310 --> 00:52:35,630
0,120 120,240 240,630 630,1170 1170,1320
to the system, you know

1510
00:52:35,630 --> 00:52:37,520
0,120 120,750 990,1470 1470,1620 1620,1890
VMware motion,| {} you're basically
|你是在说，

1511
00:52:37,520 --> 00:52:38,330
0,240 240,360 360,600 600,660 660,810
saying like,| hey I want
|嘿，我想复制这个主机，

1512
00:52:38,330 --> 00:52:40,280
0,60 60,660 660,810 810,1290 1350,1950
to clone this primary,| and
|复制操作会，

1513
00:52:40,580 --> 00:52:44,360
0,420 450,840 840,1650 1680,3330 3360,3780
the clone operation basically, {}|
|

1514
00:52:45,620 --> 00:52:47,780
0,600 600,900 900,1470 1470,1920 1920,2160
well, basically stop processing processing
停止处理客户端，

1515
00:52:47,780 --> 00:52:50,930
0,450 1110,1320 1320,1770 1770,2700 2730,3150
client,| during cloning, the primary
|在复制过程中，主机不需要担心，

1516
00:52:50,930 --> 00:52:52,040
0,270 270,540 540,690 690,930 930,1110
won't actually worried about,| the
|只有一个运行的系统，

1517
00:52:52,040 --> 00:52:53,630
0,210 210,540 540,750 750,1080 1230,1590
one system still running,| one
|一个服务于任何客户端请求，

1518
00:52:53,630 --> 00:52:54,560
0,150 150,210 210,480 480,630 630,930
{actually -} serve any client

1519
00:52:54,560 --> 00:52:58,580
0,570 720,1530 2550,3210 3330,3630 3630,4020
request,| the the {VMotion -}
|VMotion 复制虚拟机，

1520
00:52:58,580 --> 00:53:01,340
0,450 450,900 900,1170 1170,1890 1950,2760
thing makes them VM clone|
|

1521
00:53:01,430 --> 00:53:03,620
0,180 180,540 540,1380 1410,1740 1740,2190
and basically copies the state
将虚拟机的状态复制到备机，

1522
00:53:03,620 --> 00:53:04,940
0,90 90,390 390,900 900,1170 1170,1320
of this VM up to

1523
00:53:04,940 --> 00:53:06,230
0,90 90,480 750,930 930,1200 1200,1290
tho backup,| so here we
|所以，这里我们有一个完全相同的主机的复制，

1524
00:53:06,230 --> 00:53:08,030
0,120 120,210 210,960 1170,1710 1710,1800
have an identical copy of

1525
00:53:08,030 --> 00:53:09,410
0,60 60,570 630,780 780,1020 1020,1380
the backup, of the primary,|
|

1526
00:53:09,410 --> 00:53:10,720
0,150 150,390 390,450 450,870
that becomes the backup,|
它成为备机，|

1527
00:53:10,810 --> 00:53:12,160
0,180 180,300 300,720 720,1260 1260,1350
and so the state of
所以，虚拟机的状态是相同的。

1528
00:53:12,160 --> 00:53:13,480
0,90 90,330 330,630 630,720 720,1320
the virtual machine is identical.|
|

1529
00:53:14,040 --> 00:53:15,270
0,480 480,600 600,750 750,1050 1050,1230
Once you know the sort
一旦发生了复制操作，

1530
00:53:15,270 --> 00:53:17,760
0,60 60,540 540,1080 1080,1680 2070,2490
of cloning operations happened,| then
|然后它可以自由地，

1531
00:53:17,760 --> 00:53:20,370
0,360 360,870 870,1020 1020,1020 2250,2610
it's free,| {user -} user
|用户接口也可以自由地将这个（标志）设置为 0 ，

1532
00:53:20,370 --> 00:53:21,210
0,330 330,390 390,570 570,660 660,840
interface is free to set

1533
00:53:21,210 --> 00:53:22,530
0,450 450,660 660,900 900,990 990,1320
this guy back to 0

1534
00:53:22,530 --> 00:53:23,520
0,480
too,|
|

1535
00:53:24,480 --> 00:53:25,560
0,300 300,600 600,660 660,900 900,1080
client requests are still not
客户端请求仍未得到处理，

1536
00:53:25,560 --> 00:53:27,630
0,180 180,840 1200,1680 1680,1920 1920,2070
being processed,| when that has
|当这种情况真的发生时，

1537
00:53:27,630 --> 00:53:28,980
0,420 420,750 750,900 900,1080 1080,1350
actually happened,| then this system
|这个系统就可以重新开始工作了，

1538
00:53:28,980 --> 00:53:30,030
0,150 150,450 450,630 630,780 780,1050
can go sort of live

1539
00:53:30,030 --> 00:53:31,560
0,390 390,600 600,840 840,1020 1020,1530
again,| but now with two
|但现在有两台机器，一台主机，一台备机，

1540
00:53:31,590 --> 00:53:33,120
0,630 630,900 900,960 960,1350 1350,1530
machines, with a primary and

1541
00:53:33,120 --> 00:53:34,350
0,30 30,570 690,840 840,930 930,1230
a backup,| and the client
|并且处理客户端请求，

1542
00:53:34,350 --> 00:53:35,850
0,360 360,480 480,660 660,1440 1440,1500
requests are being processed,| they
|它们通过通道发送，

1543
00:53:35,850 --> 00:53:36,960
0,90 90,330 330,480 480,570 570,1110
are sent over the channel

1544
00:53:36,960 --> 00:53:38,100
0,90 90,420 420,780 810,960 960,1140
and etc etc,| so we're
|所以我们又回到运行中。

1545
00:53:38,100 --> 00:53:39,380
0,270 270,330 330,870
back in business.|
|

1546
00:53:40,120 --> 00:53:41,740
0,210 210,480 480,540 540,1050
So answer the question?|
所以回答了你的问题吗？|

1547
00:53:47,960 --> 00:53:50,240
0,120 120,630 1530,1980 1980,2190 2190,2280
I {hope,it,does}.| If not, I'm
我希望是这样的。|如果不是，我很乐意重温这一点，

1548
00:53:50,240 --> 00:53:52,220
0,360 360,930 960,1380 1380,1530 1530,1980
happy to revisit this actually,|
|

1549
00:53:52,220 --> 00:53:52,850
0,120 120,330 330,420 420,510 510,630
and maybe at the end
也许在讲座的最后仍然令人困惑。

1550
00:53:52,850 --> 00:53:54,170
0,90 90,180 180,960 960,1110 1110,1320
of the lecture is still

1551
00:53:54,170 --> 00:53:55,160
0,420
confusing.|
|

1552
00:53:55,560 --> 00:53:59,340
0,810 1110,2160 2640,3480 3480,3660 3660,3780
Okay.| {Okay,good}.| Okay, I want
好的。|好的，很好。|好的，现在我想回到

1553
00:53:59,340 --> 00:54:00,300
0,60 60,180 180,450 450,660 660,960
to go back now| to
|这个系统的整体架构，

1554
00:54:00,300 --> 00:54:02,010
0,510 510,600 600,840 840,1110 1230,1710
sort of like the overall

1555
00:54:02,010 --> 00:54:03,390
0,420 420,630 630,690 690,840 840,1380
architecture {} of this system,|
|

1556
00:54:03,630 --> 00:54:04,950
0,330 330,450 450,600 600,900 900,1320
now I want to dive
现在我想更深入一点，

1557
00:54:04,950 --> 00:54:06,030
0,60 60,150 150,360 360,630 630,1080
in a little bit more,|
|

1558
00:54:06,030 --> 00:54:07,920
0,450 600,930 930,1380 1470,1830 1830,1890
and {} talk {} you
我们决定考虑，

1559
00:54:07,920 --> 00:54:09,030
0,90 90,270 270,660 660,750 750,1110
know we decided to think,|
|

1560
00:54:09,060 --> 00:54:10,680
0,90 90,660 660,930 930,1380 1380,1620
you know this arbitration scheme
这个仲裁方案至少可以让你指出脑裂问题，

1561
00:54:10,680 --> 00:54:11,610
0,330 330,450 450,600 600,750 750,930
allows you to at least

1562
00:54:11,610 --> 00:54:13,080
0,240 240,420 420,720 720,990 990,1470
point to {split-brain -} syndrome,|
|

1563
00:54:13,380 --> 00:54:16,020
0,330 330,630 630,1830 1890,2340 2340,2640
{} but {you,know,this,sort,of} larger issue,|
但这种更大的问题，|

1564
00:54:16,020 --> 00:54:17,370
0,180 180,510 600,780 780,990 990,1350
that if {you,know} two machines
如果有两台机器在运行，

1565
00:54:17,370 --> 00:54:18,320
0,90 90,570
are running,|
|

1566
00:54:18,590 --> 00:54:19,580
0,480 480,570 570,690 690,810 810,990
{} you know, our goal
我们的目标是，

1567
00:54:19,580 --> 00:54:20,880
0,90 90,210 210,270 270,690
is going to be,|
|

1568
00:54:22,870 --> 00:54:24,250
0,480 480,900 900,1080 1080,1140 1140,1380
basically behave like a single
像一台机器一样运行。

1569
00:54:24,250 --> 00:54:25,380
0,480
machine.|
|

1570
00:54:29,950 --> 00:54:31,210
0,210 210,360 360,420 420,720 720,1260
So from the client perspective,|
所以从客户的角度来看，|

1571
00:54:31,210 --> 00:54:32,320
0,120 120,270 270,480 480,600 600,1110
it should not be possible
应该不可能辨别出，

1572
00:54:32,320 --> 00:54:34,480
0,90 90,630 900,1830 1860,2100 2100,2160
to really discern,| or at
|或者至少在某种程度上证明了这一点，

1573
00:54:34,480 --> 00:54:35,620
0,240 240,360 360,810 810,1020 1020,1140
least in a sort of

1574
00:54:35,650 --> 00:54:37,900
0,870 870,960 960,1320 1320,1680 1680,2250
demonstrate a bad way,| that
|我们实际上有两台机器。

1575
00:54:37,900 --> 00:54:39,160
0,120 120,360 360,570 570,720 720,1260
we actually have two machines,

1576
00:54:39,880 --> 00:54:41,800
0,390 750,930 930,1320 1350,1710 1710,1920
right.| And so there's this
|所以回退一步，

1577
00:54:41,800 --> 00:54:43,720
0,180 180,420 420,870 1080,1710 1710,1920
big step back,| if we
|如果我们在非常高的级别考虑，

1578
00:54:43,720 --> 00:54:44,950
0,120 120,300 300,540 540,660 660,1230
{think,at} a very high level,|
|

1579
00:54:44,950 --> 00:54:45,850
0,90 90,210 210,330 330,570 570,900
you know we have here
这里我们有主机，

1580
00:54:45,850 --> 00:54:47,470
0,300 300,690 870,1020 1020,1530 1530,1620
{primary -},| and {it,has} you
|它有虚拟机寄存器，

1581
00:54:47,470 --> 00:54:49,060
0,300 300,660 660,990 990,1500 1500,1590
know like machine registers, the

1582
00:54:49,060 --> 00:54:51,910
0,240 240,810 840,1590 1590,1740 2280,2850
virtual machine { -} registers,|
|

1583
00:54:51,910 --> 00:54:53,950
0,210 210,810 1110,1650 1650,1770 1770,2040
there's memory,| and our basic
这里有内存，|我们的基本方案是，

1584
00:54:53,950 --> 00:54:56,170
0,330 330,600 600,1110 1530,1680 1680,2220
plan is to {sort,of} forward|
|

1585
00:54:56,170 --> 00:54:57,490
0,180 180,450 450,690 690,840 840,1320
to make sure that basically
确保执行完全相同的指令。

1586
00:54:57,490 --> 00:54:59,380
0,420 420,930 930,1020 1020,1260 1260,1890
executes exactly the same instructions.|
|

1587
00:55:01,590 --> 00:55:02,980
0,840

1588
00:55:02,980 --> 00:55:04,990
0,600 600,840 840,1410 1500,1800 1800,2010
Boom, boom, boom, here's our
砰，砰，砰，这是我们的，

1589
00:55:04,990 --> 00:55:07,140
0,480 480,810 810,1440
own,| here's backup,
|这是备机，这是主机，

1590
00:55:07,310 --> 00:55:09,470
0,300 300,1050 1380,1950 1950,2040 2040,2160
here's primary,| and you know
|基本上当主机，

1591
00:55:09,470 --> 00:55:11,030
0,540 540,660 660,750 750,1050 1050,1560
basically you know when the,

1592
00:55:11,330 --> 00:55:14,420
0,1500 2040,2430 2430,2490 2490,2910 2910,3090
{} when the primary,| so
|所以我们开始在相同的状态下映射，

1593
00:55:14,420 --> 00:55:15,230
0,120 120,390 390,450 450,720 720,810
we started to map in

1594
00:55:15,230 --> 00:55:16,460
0,60 60,300 300,840 840,1110 1110,1230
the same state,| and they
|然后它们开始执行指令，

1595
00:55:16,460 --> 00:55:18,470
0,210 210,660 660,1200 1440,1800 1800,2010
start executing instructions,| like maybe
|例如，可能第一条指令是 inc ，

1596
00:55:18,470 --> 00:55:20,660
0,60 60,300 300,840 840,1230 1740,2190
the first instruction {is,inc},| second
|第二条指令是 dec ，

1597
00:55:20,660 --> 00:55:22,700
0,330 330,450 450,960 1350,1590 1590,2040
instruction is dec,| you know
|第三条指令是 branch ，

1598
00:55:22,730 --> 00:55:24,080
0,210 210,300 300,690 690,780 780,1350
third {instruction -} is branch,|
|

1599
00:55:24,970 --> 00:55:26,860
0,420 420,570 570,1170 1200,1530 1530,1890
and if they start all
如果它们都是从相同的状态开始，

1600
00:55:26,860 --> 00:55:27,940
0,120 120,210 210,450 450,840 840,1080
in the same state, correct,|
|

1601
00:55:27,940 --> 00:55:29,110
0,300 300,510 510,570 570,750 750,1170
then at the third instruction
第三条指令是 branch ，

1602
00:55:29,110 --> 00:55:30,130
0,150 150,450 450,600 600,690 690,1020
is branch,| that will branch
|它将 branch 向同一个方向，

1603
00:55:30,130 --> 00:55:31,630
0,150 150,300 300,510 510,990 1290,1500
into the same direction,| and
|也许 branch 到一些指令，

1604
00:55:31,630 --> 00:55:32,830
0,390 420,720 720,810 810,1080 1080,1200
so maybe the branch to

1605
00:55:32,830 --> 00:55:34,510
0,150 150,900 930,1110 1110,1590 1590,1680
some instruction,| and then we
|然后比如下一条指令是 divide 等等。

1606
00:55:34,510 --> 00:55:35,740
0,150 150,540 540,660 660,840 840,1230
know whatever the next instruction

1607
00:55:35,740 --> 00:55:38,920
0,180 180,630 1110,2070 2070,2760
is divide etc, etc.|
|

1608
00:55:39,600 --> 00:55:41,070
0,330 330,510 510,780 780,1350 1350,1470
{You,know} all these instructions are
所有这些指令都是确定性的，

1609
00:55:41,070 --> 00:55:42,660
0,690 690,810 810,1080 1110,1350 1350,1590
deterministic,| so that's {} pretty
|所以这是非常直截了当的，

1610
00:55:42,660 --> 00:55:44,310
0,600 630,900 900,1080 1080,1410 1530,1650
straightforward, right,| like if you
|比如如果我们都是从同一个状态开始，

1611
00:55:44,310 --> 00:55:45,180
0,120 120,270 270,540 540,780 780,870
know we both start at

1612
00:55:45,180 --> 00:55:47,250
0,60 60,810 810,1260 1260,1620 1620,2070
the same state,| they execute
|它们以相同的顺序执行完全相同的指令集，

1613
00:55:47,250 --> 00:55:49,410
0,420 420,690 1590,1890 1890,2070 2070,2160
exactly the same set of

1614
00:55:49,410 --> 00:55:50,910
0,570 570,660 660,720 720,1020 1020,1500
instructions in the same order,|
|

1615
00:55:51,060 --> 00:55:51,930
0,210 210,360 360,480 480,690 690,870
then we're going to end
然后我们到达状态 S' ，

1616
00:55:51,930 --> 00:55:52,980
0,210 210,330 330,570 570,900 900,1050
up in {} state {S'

1617
00:55:52,980 --> 00:55:54,080
0,630
-},|
|

1618
00:55:54,080 --> 00:55:55,610
0,390 390,750 750,1110 1110,1410 1410,1530
and those two states have
这两个状态肯定是相同的。

1619
00:55:55,610 --> 00:55:57,000
0,90 90,240 240,810
to be identical,

1620
00:55:57,620 --> 00:55:58,600
0,420
right.|
|

1621
00:55:58,800 --> 00:56:00,570
0,660 840,1200 1200,1500 1500,1680 1680,1770
Now the thing that is
现在，在设计中遇到的挑战是，

1622
00:56:00,570 --> 00:56:02,190
0,210 210,270 270,360 360,1110 1140,1620
sort of a challenge in

1623
00:56:02,190 --> 00:56:05,010
0,1050 1140,1920 1920,2370 2370,2640 2640,2820
{} design,| where any sort
|任何种类的复制方案都是，

1624
00:56:05,010 --> 00:56:06,840
0,120 120,600 600,930 930,1350 1410,1830
of replication scheme is,| there
|可能会有差异来源，

1625
00:56:06,840 --> 00:56:08,790
0,240 240,360 360,1050 1050,1260 1260,1950
might be sources of divergence,|
|

1626
00:56:08,790 --> 00:56:09,930
0,120 120,210 210,720 720,870 870,1140
you know so our goal
我们的目标是让它们完全一样的状态 S' ，

1627
00:56:09,930 --> 00:56:10,650
0,120 120,240 240,510 510,630 630,720
is to actually get them

1628
00:56:10,650 --> 00:56:13,200
0,510 510,690 690,1230 1440,1980 2130,2550
exactly the same {} state

1629
00:56:13,200 --> 00:56:14,490
0,150 150,690 750,1050 1050,1170 1170,1290
{S' -},| but you know
|但是会有差异来源。

1630
00:56:14,490 --> 00:56:16,080
0,180 180,570 570,780 780,1470 1470,1590
there source or sources of

1631
00:56:16,080 --> 00:56:17,420
0,690
divergence.|
|

1632
00:56:22,760 --> 00:56:24,350
0,390 390,510 510,870 870,1320 1320,1590
And it's pretty obvious, correct,
这是很明显的，

1633
00:56:24,350 --> 00:56:26,630
0,390 390,570 570,900 930,1500 1500,2280
what those are,| {for,example} instructions
|例如，不确定的指令就是我们的问题，

1634
00:56:26,660 --> 00:56:28,310
0,270 270,390 390,630 630,1410 1440,1650
that are {non-deterministic -} our

1635
00:56:28,310 --> 00:56:29,380
0,450
problems,|
|

1636
00:56:35,300 --> 00:56:37,010
0,210 210,330 330,870 870,1290 1320,1710
and so what are one
那么非确定性指令的例子是什么？

1637
00:56:37,010 --> 00:56:38,300
0,390 390,450 450,480 480,780 780,1290
example of {} {non-deterministic -}

1638
00:56:38,300 --> 00:56:39,360
0,480
instruction?|
|

1639
00:56:42,410 --> 00:56:44,200
0,450 450,600 600,1230
Getting the time.|
获取时间。|

1640
00:56:44,200 --> 00:56:45,220
0,240 240,510 510,600 600,840 840,1020
Yeah, getting the time, why
是的，获取时间，为什么它是不确定的？

1641
00:56:45,220 --> 00:56:46,860
0,90 90,180 180,420 420,1050
is it {non-deterministic -}?|
|

1642
00:56:47,360 --> 00:56:50,220
0,390 390,510 510,1140
Because it didn't,|
因为它没有，|

1643
00:56:50,280 --> 00:56:52,080
0,480 630,780 780,1230 1230,1350 1350,1800
and the machines are not
比如备机没有执行。

1644
00:56:52,110 --> 00:56:53,820
0,300 300,870 900,1320 1320,1470 1470,1710
like the backup is not

1645
00:56:53,820 --> 00:57:00,020
0,600 630,3000 4230,5430
executing. { -}|
|

1646
00:57:00,050 --> 00:57:02,060
0,660 990,1410 1410,1620 1620,1920 1920,2010
{Yeah,the} issue here correctly is
是的，这里的问题是，

1647
00:57:02,060 --> 00:57:04,400
0,300 300,690 690,1140 1140,1440 1830,2340
that,| if there's the primary
|如果有主机和备机，

1648
00:57:04,400 --> 00:57:05,360
0,90 90,180 180,720 720,810 810,960
and the backup,| you know
|在某一时刻，会执行这个获取时间的指令，

1649
00:57:05,360 --> 00:57:06,350
0,120 120,240 240,480 480,630 630,990
at some point will execute

1650
00:57:06,350 --> 00:57:07,460
0,210 210,330 330,660 660,900 900,1110
this you know get time

1651
00:57:07,460 --> 00:57:08,360
0,90 90,240 240,690 690,780 780,900
of day instruction,| if you
|如果你愿意，

1652
00:57:08,360 --> 00:57:09,860
0,390 600,1080 1080,1170 1170,1320 1320,1500
will,| and they might not
|它们可能不在同一时间执行，

1653
00:57:09,860 --> 00:57:10,910
0,360 360,450 450,900 900,960 960,1050
execute it exactly at the

1654
00:57:10,910 --> 00:57:12,200
0,240 240,570 570,750 750,870 870,1290
same time,| so the values
|所以指令返回的值将会不同，

1655
00:57:12,200 --> 00:57:13,970
0,690 720,1140 1140,1260 1260,1680 1680,1770
returned by the instruction is

1656
00:57:13,970 --> 00:57:15,220
0,120 120,180 180,270 270,780
going to be different,

1657
00:57:15,740 --> 00:57:17,900
0,330 330,450 450,900 900,1620 1620,2160
right,| so that's a source
|所以，这是可能的差异来源，

1658
00:57:17,960 --> 00:57:20,750
0,720 720,1140 1320,1860 1860,2130 2130,2790
of, the potential source of

1659
00:57:21,230 --> 00:57:23,090
0,570 600,1230 1230,1350 1350,1650 1650,1860
{} divergence,| that we need
|我们需要控制的。

1660
00:57:23,090 --> 00:57:24,240
0,90 90,630
to control.|
|

1661
00:57:24,240 --> 00:57:25,230
0,150 150,390 390,480 480,810 810,990
In fact,| we basically have
事实上，|我们要把每一条非确定性指令变成确定性指令，

1662
00:57:25,230 --> 00:57:26,730
0,90 90,420 420,660 660,960 960,1500
to turn every {non-deterministic -}

1663
00:57:26,730 --> 00:57:28,980
0,630 630,900 900,990 990,1740 1740,2250
instruction into a deterministic instruction,|
|

1664
00:57:29,040 --> 00:57:30,930
0,270 270,750 750,1110 1110,1530 1650,1890
{we'll,see,in,a} second and how, how
我们稍后会看到如何做到这一点。

1665
00:57:30,930 --> 00:57:32,540
0,180 180,300 300,420 420,750
could that be done.|
|

1666
00:57:32,800 --> 00:57:35,100
0,750 780,1050 1050,1800
Similarly, {} inputs,
同样，数据包输入，

1667
00:57:35,490 --> 00:57:36,870
0,180 180,660 660,930 930,1080 1080,1380
{} packet inputs,| like when
|例如当数据包通过网络到达时，

1668
00:57:36,870 --> 00:57:37,770
0,270 270,330 330,660 660,840 840,900
packet the arrives over the

1669
00:57:37,770 --> 00:57:39,720
0,600 840,960 960,1080 1080,1230 1230,1950
network,| you know the primary,|
|你知道主机，|

1670
00:57:40,050 --> 00:57:41,460
0,840 840,1020 1020,1170 1170,1290 1290,1410
{} you know we got
我们必须确保，

1671
00:57:41,460 --> 00:57:42,420
0,60 60,210 210,600 600,840 840,960
to make sure,| that you
|数据包执行或处理，

1672
00:57:42,420 --> 00:57:45,000
0,180 180,870 990,1590 1590,2040 2040,2580
know the that packets executed

1673
00:57:45,000 --> 00:57:46,280
0,120 120,840
or processed,|
|

1674
00:57:46,550 --> 00:57:48,170
0,450 450,960 960,1140 1140,1500 1500,1620
the interrupt goes along with
数据包带来的中断传送

1675
00:57:48,170 --> 00:57:50,030
0,120 120,420 660,810 810,1320 1320,1860
that packet is exactly delivered|
|

1676
00:57:50,030 --> 00:57:51,290
0,570 570,630 630,930 930,1200 1200,1260
exactly the same point in
与指令流中完全相同。

1677
00:57:51,290 --> 00:57:53,090
0,60 60,630 630,930 1170,1410 1410,1800
the {instruction,stream -}, right.| So
|所以，我们回到上一页，

1678
00:57:53,180 --> 00:57:53,780
0,150 150,240 240,420 420,510 510,600
we go back to our

1679
00:57:53,780 --> 00:57:55,730
0,330 330,810 810,930 930,1590 1770,1950
previous paper, {at,previous} page,| and
|备机也会执行这些指令，

1680
00:57:55,730 --> 00:57:57,350
0,390 390,540 540,960 960,1170 1170,1620
like the {backup,is} also executing

1681
00:57:57,350 --> 00:57:58,720
0,150 150,930
these instructions,|
|

1682
00:57:59,140 --> 00:58:01,060
0,660 690,1200 1200,1320 1320,1620 1620,1920
and dec, blah blah blah,|
和 dec 等等，|

1683
00:58:01,060 --> 00:58:01,660
0,60 60,180 180,270 270,510 510,600
{exactly - - - -}
完全相同的顺序，

1684
00:58:01,660 --> 00:58:02,830
0,60 60,330 330,750 780,930 930,1170
the same order,| so {}
|所以如果主机，

1685
00:58:02,830 --> 00:58:04,150
0,120 120,210 210,660 660,750 750,1320
if the primary for example,|
|

1686
00:58:04,330 --> 00:58:05,050
0,120 120,180 180,300 300,630 630,720
you know we get the
我们得到中断传送在指令 1 2 之间，

1687
00:58:05,050 --> 00:58:07,120
0,840 840,900 900,1320 1320,1620 1620,2070
interrupt is delivered between instruction

1688
00:58:07,120 --> 00:58:08,320
0,270 270,780 900,1050 1050,1140 1140,1200
1 2,| we've got to
|我们必须确保，

1689
00:58:08,320 --> 00:58:09,610
0,120 120,480 480,720 720,780 780,1290
make sure that,| the backup
|备机也在 1 和 2 之间传送，

1690
00:58:09,640 --> 00:58:11,110
0,180 180,420 420,930 930,1260 1260,1470
it also delivered between 1

1691
00:58:11,110 --> 00:58:12,040
0,120 120,390
and 2,|
|

1692
00:58:12,040 --> 00:58:13,420
0,240 240,360 360,510 510,840 840,1380
because it really delivered exactly
因为它在指令流中以相同方式传送，

1693
00:58:13,420 --> 00:58:14,920
0,90 90,480 870,1350 1350,1440 1440,1500
the same point in the

1694
00:58:14,920 --> 00:58:16,720
0,420 420,870 930,1200 1200,1530 1530,1800
instruction stream,| the interrupt handler
|中断处理程序将运行，

1695
00:58:16,720 --> 00:58:18,160
0,150 150,510 570,780 780,1290 1290,1440
will run and will do

1696
00:58:18,160 --> 00:58:19,510
0,330 330,570 570,900 900,1260 1260,1350
this,| they both execute the
|它们都会再次执行相同的指令。

1697
00:58:19,510 --> 00:58:21,060
0,180 180,600 600,990
same instructions again.|
|

1698
00:58:22,030 --> 00:58:23,740
0,570 570,930 930,1050 1050,1260 1260,1710
However, if you know {for,example}
不过，备机会执行

1699
00:58:23,740 --> 00:58:24,940
0,60 60,630
the backup

1700
00:58:25,000 --> 00:58:26,650
0,120 120,240 240,360 360,990 1020,1650
you know would process| this
|这个时钟中断或数据包到达中断，

1701
00:58:26,680 --> 00:58:28,090
0,300 300,390 390,1020 1020,1350 1350,1410
{timer -} interrupt or is

1702
00:58:28,090 --> 00:58:29,620
0,480 480,870 870,1320 1320,1380 1380,1530
packet arrival interrupt| a little
|稍晚一些在另一个流中（执行），

1703
00:58:29,620 --> 00:58:31,030
0,120 120,630 780,900 900,960 960,1410
bit later in a different

1704
00:58:31,030 --> 00:58:32,170
0,360 390,540 540,630 630,1050 1050,1140
{side,of,stream},| then the state of
|然后系统的状态可能会有所不同，

1705
00:58:32,170 --> 00:58:33,370
0,60 60,420 420,570 570,690 690,1200
the system might be different,|
|

1706
00:58:33,490 --> 00:58:34,630
0,150 150,450 450,540 540,990 990,1140
and therefore the result of
所以计算结果可能会有所不同，

1707
00:58:34,630 --> 00:58:35,950
0,210 210,600 600,1110 1110,1260 1260,1320
you know computation might be

1708
00:58:35,950 --> 00:58:37,300
0,330 570,720 720,870 870,1140 1140,1350
different,| so we can't have
|所以我们不能这样，

1709
00:58:37,300 --> 00:58:38,110
0,210 210,390 390,510 510,720 720,810
that,| so it has to
|所以，它必须是，

1710
00:58:38,110 --> 00:58:40,480
0,90 90,150 150,750 840,1320 1530,2370
be the case,| that interrupts
|数据包或时钟中断都会同时传送，

1711
00:58:40,570 --> 00:58:42,100
0,330 330,450 450,870 870,960 960,1530
{whatever -} packets and timers

1712
00:58:42,130 --> 00:58:43,840
0,420 420,600 600,1110 1140,1620 1620,1710
all get delivered exactly at

1713
00:58:43,840 --> 00:58:44,900
0,60 60,300 300,660
the same time,|
|

1714
00:58:45,140 --> 00:58:46,010
0,210 210,270 270,600 600,780 780,870
for the same input in
与指令流的输入一样，

1715
00:58:46,010 --> 00:58:48,110
0,90 90,540 540,900 1230,1470 1470,2100
the instruction stream,| so input
|所以输入数据包或计时器中断，

1716
00:58:48,670 --> 00:58:53,080
0,720 1950,2610 2610,3270
packets {or,timer} interrupts,|
|

1717
00:58:56,380 --> 00:58:57,640
0,390 390,450 450,810 810,900 900,1260
need to basically be delivered
需要在指令流中的同一点上传送。

1718
00:58:57,640 --> 00:58:58,420
0,90 90,240 240,480 480,720 720,780
at the same point in

1719
00:58:58,420 --> 00:58:59,820
0,90 90,510 510,810
the instruction stream.|
|

1720
00:59:00,630 --> 00:59:01,920
0,720

1721
00:59:02,940 --> 00:59:04,110
0,150 150,240 240,570 570,690 690,1170
And so those are sources
所以这些都是差异的来源，

1722
00:59:04,110 --> 00:59:05,730
0,150 150,960 1080,1350 1350,1530 1530,1620
of divergence,| {} that we
|我们需要处理的，

1723
00:59:05,730 --> 00:59:06,780
0,120 120,180 180,600 600,840 840,1050
need to handle,| any other
|还有其他差异来源吗？

1724
00:59:06,780 --> 00:59:08,800
0,270 270,390 390,1020 1020,1380
source of divergence that?|
|

1725
00:59:09,440 --> 00:59:11,240
0,360 390,870 900,1050 1050,1470 1590,1800
{} So I think, like
所以我想论文中提到过，

1726
00:59:11,240 --> 00:59:12,080
0,90 90,300 300,390 390,540 540,840
I think it was mentioned

1727
00:59:12,080 --> 00:59:13,520
0,90 90,150 150,510 510,960 990,1440
in the paper,| that concurrency
|并发也会产生非确定性，

1728
00:59:13,520 --> 00:59:15,080
0,270 270,480 480,780 780,960 960,1560
also can produce {non-determinism -},|
|

1729
00:59:15,350 --> 00:59:17,150
0,390 390,810 810,1050 1050,1590 1590,1800
but from my understanding here,|
但据我所知，|

1730
00:59:17,150 --> 00:59:18,380
0,240 240,330 330,630 630,960 960,1230
since the {hypervisor -} actually
由于管理程序控制中断，

1731
00:59:18,380 --> 00:59:20,090
0,480 480,570 570,1140 1350,1530 1530,1710
controls the interrupts,| and since
|因为我们有单独的处理器，

1732
00:59:20,090 --> 00:59:21,530
0,90 90,240 240,330 330,780 780,1440
we have a unique processor,|
|

1733
00:59:21,770 --> 00:59:23,810
0,360 360,540 540,1050 1080,1620 1650,2040
wouldn't the thread switch be
线程切换不是管理程序通过中断进行的吗，

1734
00:59:24,020 --> 00:59:25,310
0,480 480,660 660,720 720,990 990,1290
conducted to the {hypervisor -}

1735
00:59:25,310 --> 00:59:26,990
0,300 330,750 780,1290 1290,1500 1500,1680
by by interrupts,| so if
|所以如果我们控制中断，

1736
00:59:26,990 --> 00:59:28,040
0,90 90,420 420,510 510,960 960,1050
we control the interrupts,| and
|我们可以准确地将它们传输到正确的位置，

1737
00:59:28,040 --> 00:59:30,050
0,120 120,450 750,1230 1230,1350 1350,2010
we can transmit them exactly

1738
00:59:30,050 --> 00:59:32,360
0,330 360,720 720,1110 1140,1740 1980,2310
at the right location,| wouldn't
|我们不是也可以控制并发的非确定性吗？

1739
00:59:32,360 --> 00:59:33,770
0,120 120,900 930,1200 1200,1290 1290,1410
we also control the {non-determinism

1740
00:59:33,770 --> 00:59:35,420
0,480 480,780 780,1230
-} from concurrency.|
|

1741
00:59:35,450 --> 00:59:36,500
0,360 360,630 630,750 750,930 930,1050
Yeah, so I think there's
是的，我认为这是一个很好的观察，

1742
00:59:36,500 --> 00:59:37,550
0,90 90,300 300,780 780,900 900,1050
a great observation,| so let
|所以让我来，

1743
00:59:37,550 --> 00:59:39,140
0,210 210,390 840,1050 1050,1200 1200,1590
me,| {} it's a potential
|这是一种可能的差异，

1744
00:59:39,140 --> 00:59:40,400
0,630 660,870 870,1020 1020,1200 1200,1260
diverge,| okay, so first of
|好的，首先，

1745
00:59:40,400 --> 00:59:41,330
0,60 60,240 240,480 480,750 750,930
all,| let's first agree that
|让我们首先同意这是一个可能的差异来源，

1746
00:59:41,330 --> 00:59:43,130
0,120 120,180 180,660 660,930 930,1800
it's a potential source of

1747
00:59:43,520 --> 00:59:47,220
0,1260 1260,1590 2010,2310 2310,2790
divergence,| so {multicore -}.|
|多核。|

1748
00:59:49,120 --> 00:59:50,380
0,120 120,300 300,690 690,780 780,1260
And let's see,| you know
我们看到，|这篇论文中的解决方案，

1749
00:59:50,410 --> 00:59:52,600
0,660 660,750 750,1080 1080,1500 1530,2190
basically the way the solution

1750
00:59:52,600 --> 00:59:53,860
0,330 330,510 510,810 810,1170 1170,1260
in this particular paper| {to
|避免这个问题是，

1751
00:59:53,860 --> 00:59:54,760
0,90 90,330 330,450 450,780 780,900
-} avoid this problem is

1752
00:59:54,760 --> 00:59:56,140
0,90 90,300 300,900 930,1200 1200,1380
to say,| well, there's {disallow
|这是不允许的，不允许有（多核），

1753
00:59:56,140 --> 00:59:57,540
0,450
-},

1754
00:59:58,790 --> 00:59:59,780
0,180 180,330 330,540 540,600 600,990
we're not allow to {have,that},|
|

1755
01:00:00,020 --> 01:00:01,370
0,510 510,720 720,900 900,1140 1140,1350
and so just only uniq
所以，只有单个处理器，

1756
01:00:01,370 --> 01:00:03,050
0,630 810,1080 1080,1230 1230,1410 1410,1680
processor,| let's say we had
|假设我们有多核，

1757
01:00:03,050 --> 01:00:05,240
0,270 270,750 1110,2010 2010,2100 2100,2190
{multi-core -},| and you know
|为了确保我们了解问题所在，

1758
01:00:05,240 --> 01:00:06,140
0,420 420,600 600,660 660,780 780,900
what just to make sure

1759
01:00:06,140 --> 01:00:06,860
0,120 120,210 210,540 540,660 660,720
that we understand what the

1760
01:00:06,860 --> 01:00:08,300
0,270 270,600 780,960 960,1200 1200,1440
issue is,| the issue here
|这里的问题是，

1761
01:00:08,300 --> 01:00:09,410
0,120 120,420 420,540 540,870 900,1110
is correct,| we have two
|我们有两个线程在同一处理器上运行，

1762
01:00:09,410 --> 01:00:10,760
0,540 540,900 900,1020 1020,1080 1080,1350
threads running on the same

1763
01:00:10,760 --> 01:00:11,920
0,690
processor,|
|

1764
01:00:12,040 --> 01:00:13,510
0,270 270,360 360,570 570,900 900,1470
sort of on different cores,|
在不同的核心上，|

1765
01:00:13,930 --> 01:00:15,460
0,600 630,780 780,1200 1200,1260 1260,1530
and they arranged for example
它们抢夺一把锁，

1766
01:00:15,460 --> 01:00:16,690
0,90 90,450 450,690 690,750 750,1230
to grab grab a lock,|
|

1767
01:00:17,630 --> 01:00:18,620
0,510 510,720 720,810 810,930 930,990
and one of them is
它们中的一个会赢，

1768
01:00:18,620 --> 01:00:19,820
0,120 120,180 180,420 750,1050 1050,1200
going to win,| and so
|这就是接下来要运行的线程，

1769
01:00:19,820 --> 01:00:20,900
0,480 480,600 600,840 840,960 960,1080
that's the thread that's going

1770
01:00:20,900 --> 01:00:22,070
0,90 90,270 270,780 810,1110 1110,1170
to run next,| and the
|而另一个会暂停一段时间，

1771
01:00:22,070 --> 01:00:22,670
0,120 120,240 240,390 390,540 540,600
other one is going to

1772
01:00:22,670 --> 01:00:23,420
0,120 120,450 450,540 540,570 570,750
be stopped for a little

1773
01:00:23,420 --> 01:00:24,300
0,360
while,|
|

1774
01:00:24,300 --> 01:00:24,900
0,150 150,270 270,420 420,480 480,600
if we want to do
如果我们想要在备机执行这种复制状态机方法，

1775
01:00:24,900 --> 01:00:26,370
0,180 180,600 600,810 810,1050 1050,1470
this replicated state machine approach

1776
01:00:26,370 --> 01:00:27,030
0,90 90,180 180,480 480,600 600,660
at the backup,| {} the
|同样的事情也必须发生，

1777
01:00:27,030 --> 01:00:28,470
0,270 270,450 450,630 630,1080 1080,1440
same thing would have {to,happen},

1778
01:00:28,590 --> 01:00:29,460
0,270 270,510 510,630 630,720 720,870
right,| where if the two
|如果两个线程运行，同时争夺锁，

1779
01:00:29,460 --> 01:00:31,710
0,480 510,1110 1110,1440 1470,2100 2100,2250
threads run, {you,know} race for

1780
01:00:31,710 --> 01:00:32,520
0,120 120,420 420,480 480,570 570,810
that lock at the same

1781
01:00:32,520 --> 01:00:33,780
0,510 660,930 930,1020 1020,1170 1170,1260
time,| then we got to
|然后我们必须安排在主机的胜者，

1782
01:00:33,780 --> 01:00:35,670
0,150 150,600 600,990 1080,1530 1530,1890
be arrange that whatever winner

1783
01:00:35,670 --> 01:00:36,660
0,90 90,180 180,660 660,870 870,990
on the primary,| also the
|也是备机的胜者。

1784
01:00:36,660 --> 01:00:38,080
0,330 330,390 390,450 450,870
winner on the backup.|
|

1785
01:00:38,310 --> 01:00:39,360
0,300 300,450 450,540 540,690 690,1050
{} And so that requires
所以，这需要很多机制，

1786
01:00:39,360 --> 01:00:40,860
0,30 30,510 510,750 750,840 840,1500
a whole bunch of machinery,|
|

1787
01:00:40,890 --> 01:00:43,650
0,840 870,1110 1110,1710 1920,2340 2340,2760
{} that {you,know} additional machinery
额外的机制复杂性，

1788
01:00:43,650 --> 01:00:45,000
0,570 570,720 720,1050 1050,1200 1200,1350
complexities,| that you know the
|这篇论文显然不想处理，

1789
01:00:45,000 --> 01:00:46,050
0,360 360,690 690,870 870,990 990,1050
paper clearly didn't want to

1790
01:00:46,050 --> 01:00:47,040
0,390 390,510 510,690 690,810 810,990
address| or didn't know how
|或者不知道该如何处理，

1791
01:00:47,040 --> 01:00:48,660
0,90 90,570 870,1110 1110,1500 1500,1620
to address,| and basically just
|只是说，

1792
01:00:48,660 --> 01:00:49,440
0,150 150,330 330,540 540,630 630,780
said, like,| okay, we're just
|好的，我们只是排除这种差异的可能性，

1793
01:00:49,440 --> 01:00:51,600
0,120 120,630 660,1020 1080,2100 2100,2160
gonna exclude that possibility of

1794
01:00:51,600 --> 01:00:53,700
0,630 630,900 900,1050 1050,1890 1950,2100
divergence,| but just declaring that
|只是宣布处理器为单处理器。

1795
01:00:53,700 --> 01:00:55,540
0,90 90,660 660,900 900,1350
the processor {uni-processor -}.|
|

1796
01:00:55,660 --> 01:00:56,800
0,120 120,210 210,510 510,750 750,1140
And so then thread switching
然后线程切换和诸如此类的事情就不再重要了，

1797
01:00:56,800 --> 01:00:57,280
0,90 90,210 210,300 300,420 420,480
and all that kind of

1798
01:00:57,280 --> 01:00:58,450
0,150 150,360 360,630 630,1020 1020,1170
stuff doesn't matter anymore,| there's
|总是一种计算在计算机、处理器上运行，

1799
01:00:58,450 --> 01:00:59,920
0,300 300,780 780,840 840,930 930,1470
always one you know computation

1800
01:00:59,920 --> 01:01:00,790
0,240 240,330 330,390 390,780 780,870
running on the computer, on

1801
01:01:00,790 --> 01:01:02,680
0,90 90,780 990,1500 1530,1740 1740,1890
the processor,| and it will
|它会切换，

1802
01:01:02,680 --> 01:01:04,420
0,540 570,960 960,1020 1020,1380 1380,1740
switch,| if the primary switches
|如果主机切换到不同的线程，

1803
01:01:04,420 --> 01:01:05,440
0,90 90,180 180,450 450,810 870,1020
to a different thread,| the
|备机也会切换到不同的线程，

1804
01:01:05,440 --> 01:01:06,580
0,450 450,720 720,930 930,1050 1050,1140
backup switch also to the

1805
01:01:06,580 --> 01:01:08,260
0,630 720,870 870,1200 1200,1440 1440,1680
same {} different thread,| because
|因为这是单一的指令，

1806
01:01:08,260 --> 01:01:10,060
0,120 120,270 270,600 600,1020 1590,1800
it's a single [instruction],| and
|它们同时获得外部输入。

1807
01:01:10,060 --> 01:01:11,380
0,120 120,360 360,600 600,990 990,1320
they get their external inputs

1808
01:01:11,380 --> 01:01:12,400
0,450 450,510 510,570 570,780 780,1020
exactly at the same time.|
|

1809
01:01:15,640 --> 01:01:16,820
0,150 150,300 300,630
That makes sense?|
这能理解吗?|

1810
01:01:17,760 --> 01:01:18,480
0,150 150,210 210,360 360,630 630,720
So in some ways a
所以在某些方面有点差劲，

1811
01:01:18,480 --> 01:01:19,710
0,240 240,330 330,690 690,1020 1020,1230
little bit lame,| they just
|他们放弃了多核。

1812
01:01:19,710 --> 01:01:20,700
0,150 150,330 330,450 450,660 660,990
give up on {multi-core -}.|
|

1813
01:01:21,980 --> 01:01:23,450
0,240 240,390 390,420 420,870 870,1470
And as I mentioned {}
正如我提到的，后来的系统，

1814
01:01:23,480 --> 01:01:25,370
0,300 300,960 1110,1590 1590,1830 1830,1890
later systems,| {} in the
|在这个产品的较新系统中，可以处理多核。

1815
01:01:25,370 --> 01:01:26,540
0,180 180,480 480,810 810,900 900,1170
more recent systems of this

1816
01:01:26,570 --> 01:01:29,240
0,1110 1320,1740 1740,2070 2070,2280 2280,2670
product, do handle {multi-core -}.|
|

1817
01:01:29,780 --> 01:01:31,520
0,300 300,390 390,1050 1050,1380 1380,1740
And you know and yeah
我想讨论一下，

1818
01:01:32,210 --> 01:01:33,200
0,240 240,450 450,540 540,780 780,990
I want to talk to,|
|

1819
01:01:33,200 --> 01:01:34,610
0,120 120,330 330,780 780,1080 1080,1410
I don't actually understand exactly
我并不完全知道他们是如何做到的，

1820
01:01:34,610 --> 01:01:36,170
0,150 150,360 360,540 540,930 930,1560
how they do it,| potential
|可能是不同的方案，

1821
01:01:36,170 --> 01:01:38,150
0,300 300,1230 1230,1500 1500,1890 1890,1980
difference potential difference schemes,| that
|你可以想到去做的事情，

1822
01:01:38,150 --> 01:01:39,140
0,120 120,240 240,450 450,630 630,990
you could think of doing,|
|

1823
01:01:39,140 --> 01:01:41,660
0,450 690,1050 1050,1320 1320,1830 2100,2520
{} people have gone {}
人们进行了多核重播，

1824
01:01:41,660 --> 01:01:43,070
0,330 330,630 630,1110 1110,1320 1320,1410
{multi-core -} replay,| which I
|我想是一件必要的事情，

1825
01:01:43,070 --> 01:01:43,880
0,180 180,390 390,480 480,660 660,810
really want the thing that

1826
01:01:43,880 --> 01:01:45,710
0,90 90,840 930,1380 1380,1680 1680,1830
is necessary,| so, {} but
|但我也不是很清楚，

1827
01:01:45,710 --> 01:01:46,520
0,60 60,210 210,360 360,450 450,810
I don't really know exactly,|
|

1828
01:01:46,520 --> 01:01:47,390
0,120 120,270 270,390 390,630 630,870
I'm not gonna talk about
我不会再谈论这个，

1829
01:01:47,390 --> 01:01:48,710
0,180 180,300 300,720 840,1170 1170,1320
that at all,| I'm just
|我只想把重点放在前三项上，

1830
01:01:48,710 --> 01:01:49,790
0,150 150,360 360,570 570,750 750,1080
gonna talk about that focus

1831
01:01:49,790 --> 01:01:51,140
0,120 120,210 210,480 480,750 750,1350
on the first three items,|
|

1832
01:01:51,440 --> 01:01:52,910
0,750 750,990 990,1110 1110,1290 1290,1470
{} and see how they
看看他们在这件事上，是怎么处理的。

1833
01:01:52,910 --> 01:01:54,020
0,300 300,390 390,480 480,660 660,1110
handle it in this case.|
|

1834
01:01:58,130 --> 01:01:59,340
0,870
Okay,
好的，有什么问题吗？

1835
01:01:59,400 --> 01:02:00,700
0,180 180,750
any questions?|
|

1836
01:02:02,760 --> 01:02:04,170
0,150 150,450 450,720 720,960 960,1410
Oh, sorry, just make sure,|
哦，抱歉，只是确认一下，|

1837
01:02:04,200 --> 01:02:06,900
0,390 390,720 720,1500 1500,2190 2370,2700
it only transmits the {}
它只传输应用程序发出的指令，

1838
01:02:06,900 --> 01:02:10,680
0,690 690,1170 1470,2280 2670,2940 2940,3780
instructions that the the application

1839
01:02:10,680 --> 01:02:12,480
0,480 480,750 750,810 810,1230 1230,1800
makes, right,| it doesn't transmit
|它不会传输 Linux 生成的指令。

1840
01:02:12,480 --> 01:02:13,940
0,60 60,1020
the instructions

1841
01:02:13,940 --> 01:02:15,520
0,270 270,1080
that Linux

1842
01:02:15,580 --> 01:02:16,920
0,750
makes.|
|

1843
01:02:17,010 --> 01:02:19,470
0,390 390,1170 1230,1410 1410,1740 1740,2460
Yeah, exactly,| so here's {interesting,thing}
是的，没错，|这是我们接下来会看到的有趣的事情，

1844
01:02:19,470 --> 01:02:20,790
0,690 690,840 840,900 900,960 960,1320
we'll see in a second,|
|

1845
01:02:21,000 --> 01:02:22,050
0,450 450,660 660,780 780,930 930,1050
but let me make it
但让我现在说得更清楚，

1846
01:02:22,050 --> 01:02:24,810
0,360 360,1140 1140,1440 1440,1950 2160,2760
more clear right away,| the,
|实际上，这些指令 inc dec branch

1847
01:02:25,580 --> 01:02:27,530
0,510 510,810 810,1020 1020,1440 1440,1950
in fact, these instructions {inc,dec}

1848
01:02:27,530 --> 01:02:29,150
0,270 270,360 360,870 1260,1530 1530,1620
branch| are not sent to
|不会发送到主机或备机，

1849
01:02:29,150 --> 01:02:30,320
0,90 90,660 660,960 960,1020 1020,1170
the primary backup at all,|
|

1850
01:02:30,320 --> 01:02:31,130
0,150 150,480 480,570 570,690 690,810
they basically have their own
它们都有自己的复制，

1851
01:02:31,130 --> 01:02:32,210
0,450 480,750 750,840 840,930 930,1080
copy, right,| and we're just
|我们只是在程序中的同一时间点启动它们，

1852
01:02:32,210 --> 01:02:33,350
0,330 330,540 540,630 630,690 690,1140
starting them at the same

1853
01:02:33,380 --> 01:02:34,550
0,420 420,510 510,570 570,1050 1050,1170
point in the program,| and
|所以，它们的运行完全是步调一致的，

1854
01:02:34,550 --> 01:02:36,290
0,90 90,420 420,690 690,1110 1140,1740
so therefore they run exactly

1855
01:02:36,290 --> 01:02:37,550
0,180 180,360 360,420 420,930 930,1260
the sort of lockstep,| almost
|几乎没有步调一致，

1856
01:02:37,580 --> 01:02:39,590
0,630 630,810 810,1200 1200,1410 1410,2010
{} there's {[no],one} running lockstep,|
|

1857
01:02:39,620 --> 01:02:40,400
0,210 210,300 300,600 600,720 720,780
but they execute them in
但它们以相同的顺序执行这些命令，

1858
01:02:40,400 --> 01:02:41,580
0,60 60,360 360,660
the same order,|
|

1859
01:02:41,900 --> 01:02:43,190
0,360 360,600 600,990 990,1200 1200,1290
only something special has to
只有发生一些特殊的事情，

1860
01:02:43,190 --> 01:02:44,750
0,450 450,930 930,1140 1140,1470 1470,1560
happen| at these points of
|在那些可能的差异点上，

1861
01:02:44,750 --> 01:02:46,900
0,420 420,870 870,1650
diversion possible divergence,|
|

1862
01:02:47,140 --> 01:02:48,430
0,300 300,450 450,570 570,720 720,1290
and you know the assumption
这篇论文假设，

1863
01:02:48,430 --> 01:02:49,480
0,150 150,330 330,420 420,660 660,1050
that sort of paper makes,|
|

1864
01:02:49,480 --> 01:02:51,280
0,360 360,600 600,1020 1020,1110 1110,1800
the most instructions are deterministic,|
大多数指令都是确定性的，|

1865
01:02:51,280 --> 01:02:51,910
0,120 120,210 210,360 360,510 510,630
so we don't really have
所以我们不需要做什么事情，

1866
01:02:51,910 --> 01:02:53,590
0,60 60,150 150,540 930,1140 1140,1680
to do anything,| it's only
|只有可能出错的指令，

1867
01:02:53,590 --> 01:02:54,610
0,90 90,570 570,690 690,930 930,1020
the instructions were things that

1868
01:02:54,610 --> 01:02:56,050
0,270 270,750 750,930 930,1290 1290,1440
could potentially go wrong,| we
|我们得做点什么。

1869
01:02:56,050 --> 01:02:57,040
0,150 150,210 210,330 330,690 690,990
have to do something.| And
|可能出现问题的来源之一就是中断。

1870
01:02:57,040 --> 01:02:58,330
0,300 360,720 720,810 810,990 990,1290
so one of those sources

1871
01:02:58,330 --> 01:02:59,320
0,120 120,390 390,540 540,720 720,990
where something could go wrong

1872
01:02:59,320 --> 01:03:00,400
0,60 60,660
is interrupts.|
|

1873
01:03:01,590 --> 01:03:02,310
0,210 210,330 330,510 510,540 540,720
So let's talk a little
所以，让我们来谈谈中断的问题。

1874
01:03:02,310 --> 01:03:03,720
0,120 120,330 330,900
bit about interrupts.|
|

1875
01:03:10,880 --> 01:03:12,470
0,120 120,210 210,810 810,1290 1290,1590
And so here basically the
所以，这里虚拟机用来

1876
01:03:12,920 --> 01:03:14,450
0,390 390,900 900,1170 1170,1440 1440,1530
virtual machine sort comes to|
|

1877
01:03:14,450 --> 01:03:15,600
0,600
rescue
修复和解决这个问题，

1878
01:03:15,600 --> 01:03:17,940
0,630 630,1020 1020,1350 1350,1980 1980,2340
{} and really helps solve

1879
01:03:17,940 --> 01:03:18,960
0,120 120,450 450,600 600,780 780,1020
this problem,| so let's say
|我们假设这里有虚拟机管理程序，

1880
01:03:18,960 --> 01:03:20,760
0,330 330,510 510,780 780,1200 1470,1800
here we have our {hypervisor

1881
01:03:20,760 --> 01:03:22,420
0,630
-},|
|

1882
01:03:22,800 --> 01:03:25,740
0,630 780,930 930,1830 1830,2580 2730,2940
{} and interrupt happens,| that
中断发生时，|中断将出现在管理程序中，

1883
01:03:25,740 --> 01:03:26,910
0,90 90,510 510,630 630,930 930,1170
the interrupt will show up

1884
01:03:26,940 --> 01:03:28,440
0,150 150,210 210,480 480,960
at the {hypervisor -},|
|

1885
01:03:28,860 --> 01:03:30,180
0,570 570,660 660,930 930,1140 1140,1320
and the {hypervisor -} knows
并且管理程序确切地知道，

1886
01:03:30,180 --> 01:03:33,060
0,750 750,840 840,1080 1080,2070 2370,2880
exactly at,| what instruction the
|应用程序在什么指令上，

1887
01:03:33,060 --> 01:03:34,500
0,600 600,1020 1020,1170 1170,1350 1350,1440
application was| or where the
|或在这种级别上，虚拟机（在什么指令上），

1888
01:03:34,500 --> 01:03:35,790
0,390 390,690 690,750 750,930 930,1290
VM was at this level,|
|

1889
01:03:36,120 --> 01:03:37,560
0,210 210,480 480,900 900,1170 1170,1440
so here Linux running inside
这里， Linux 在这个虚拟机中运行，

1890
01:03:37,560 --> 01:03:38,970
0,60 60,210 210,780 1020,1290 1290,1410
of this VM,| {} the
|中断发生，

1891
01:03:38,970 --> 01:03:40,950
0,360 360,1020 1140,1650 1650,1710 1710,1980
interrupt happens,| {} of course
|当然管理程序已经接管了控制权，

1892
01:03:40,950 --> 01:03:44,220
0,420 420,990 1080,1470 1830,2400 2670,3270
you know the the {}

1893
01:03:44,220 --> 01:03:45,600
0,90 90,540 540,810 810,1080 1080,1380
the hypervisor already has taken

1894
01:03:45,600 --> 01:03:47,250
0,180 180,870 900,1140 1140,1260 1260,1650
over control,| and it knows
|它知道在什么地方停止 Linux ，以接受中断。

1895
01:03:47,250 --> 01:03:49,140
0,420 420,540 540,1200 1260,1440 1440,1890
where it stopped {you,know} Linux

1896
01:03:49,140 --> 01:03:50,070
0,90 90,300 300,480 480,570 570,930
to actually take the interrupt.|
|

1897
01:03:50,070 --> 01:03:51,240
0,180 180,510 510,600 600,780 780,1170
So maybe you know whatever
也许执行它，

1898
01:03:51,240 --> 01:03:52,380
0,30 30,240 240,540
it took it,|
|

1899
01:03:52,780 --> 01:03:54,220
0,450 450,570 570,1020 1020,1080 1080,1440
it has executed a hundred
到目前为止，它已经执行了 100 条指令，

1900
01:03:54,220 --> 01:03:55,760
0,450 450,660 660,990
instruction so far,|
|

1901
01:03:56,160 --> 01:03:57,720
0,300 300,870 870,1050 1050,1380 1380,1560
and then this interrupt comes
然后这个中断进来了，

1902
01:03:57,720 --> 01:03:59,160
0,330 540,690 690,750 750,1020 1020,1440
in,| and the {hypervisor -}
|管理程序想要

1903
01:03:59,160 --> 01:04:01,920
0,180 180,420 420,930 1110,2100 2340,2760
that wants to| deliver that
|传递中断在 100 指令之后，

1904
01:04:01,920 --> 01:04:04,160
0,420 420,720 720,1260 1260,1650
interrupt basically instruction {after,100},|
|

1905
01:04:04,220 --> 01:04:05,510
0,120 120,450 450,690 690,960 960,1290
and before doing that actually,|
在此之前，|

1906
01:04:05,510 --> 01:04:06,350
0,120 120,270 270,510 510,750 750,840
it just sends over the
它只是通过记录通道发送，

1907
01:04:06,350 --> 01:04:08,030
0,390 390,900 1080,1170 1170,1620 1620,1680
logging channel,| a message you
|一条信息给备机，

1908
01:04:08,030 --> 01:04:09,400
0,90 90,240 240,330 330,810
know to the backup,|
|

1909
01:04:10,390 --> 01:04:13,630
0,360 630,1290 1770,2520 2850,3090 3090,3240
{so,here's} backup FT,| and in
这是备机 FT ，|在那条消息中，

1910
01:04:13,630 --> 01:04:14,770
0,150 150,480 480,540 540,870 870,1140
that message,| it basically says
|它会说在指令 100 ，

1911
01:04:14,770 --> 01:04:16,840
0,180 180,630 780,1080 1080,1560 1560,2070
like okay at instruction 100,|
|

1912
01:04:17,440 --> 01:04:18,010
0,90 90,300 300,390 390,510 510,570
{you,know} when you get the
当你到达指令 100 时，

1913
01:04:18,010 --> 01:04:20,050
0,420 420,870 1140,1350 1350,1530 1530,2040
instruction 100,| you know delivered
|传递这个中断，

1914
01:04:20,050 --> 01:04:21,790
0,90 90,660 690,1350 1350,1620 1620,1740
this interrupt,| and maybe some
|以及可能与该中断相关的一些数据。

1915
01:04:21,790 --> 01:04:23,350
0,300 300,900 900,1020 1020,1110 1110,1560
data associated with the interrupt.|
|

1916
01:04:24,860 --> 01:04:25,670
0,150 150,330 330,420 420,660 660,810
So this is just two
所以这是两件中断发生的事情，

1917
01:04:25,670 --> 01:04:26,870
0,300 300,510 510,630 630,840 840,1200
things {interrupt -} comes in,|
|

1918
01:04:26,900 --> 01:04:27,950
0,270 270,360 360,420 420,840 840,1050
sees what the instruction number
查看指令号是多少，

1919
01:04:27,950 --> 01:04:28,790
0,300 300,390 390,510 510,600 600,840
was,| and then it sends
|然后给备份发送这条消息，

1920
01:04:28,790 --> 01:04:30,140
0,150 150,510 510,690 690,1050 1050,1350
to backup this message,| saying
|说，在某个时候，

1921
01:04:30,140 --> 01:04:31,190
0,180 180,540 780,900 900,990 990,1050
like hey you know at

1922
01:04:31,190 --> 01:04:32,420
0,150 150,540 540,900 900,1020 1020,1230
some point,| when you get
|当你到了指令 100 ，

1923
01:04:32,420 --> 01:04:33,470
0,180 180,330 330,630 630,870 870,1050
to {} {instruction,100},| {you,know} {}
|执行这个中断。

1924
01:04:33,680 --> 01:04:35,210
0,720 720,840 840,930 930,1050 1050,1530
process you know this interrupt.|
|

1925
01:04:36,800 --> 01:04:37,790
0,540 540,600 600,690 690,840 840,990
And you know some point
过了一会儿，中断 1 和中断 2 进来，

1926
01:04:37,790 --> 01:04:40,430
0,450 450,780 780,1140 1140,1530 2040,2640
later, this interrupt 1 and

1927
01:04:40,430 --> 01:04:42,470
0,480 480,660 660,840 1140,1710 1710,2040
{interrupt,2} comes in,| {} and
|管理程序又是完全相同的事情，

1928
01:04:42,470 --> 01:04:43,970
0,240 240,570 570,900 930,1230 1230,1500
so then the {hypervisor -}

1929
01:04:43,970 --> 01:04:45,260
0,420 420,480 480,720 720,1170 1170,1290
exactly the same thing you

1930
01:04:45,260 --> 01:04:46,720
0,210 240,780
know again,|
|

1931
01:04:46,810 --> 01:04:48,880
0,270 270,540 540,960 1230,1740 1740,2070
they'll send out, {} say
它们会发出这是指令 200 ，

1932
01:04:48,880 --> 01:04:51,640
0,210 210,270 270,720 720,1170 1170,2760
this is {} instruction 200,|
|

1933
01:04:51,640 --> 01:04:52,630
0,210 210,360 360,570 570,630 630,990
{you,know} will send a message
可能发送一条消息 200 中断，

1934
01:04:52,630 --> 01:04:55,120
0,1770 1770,2160 2160,2280 2280,2400 2400,2490
{200,interrupt},| perhaps {} and any
|以及任何与中断有关的数据到 FT ，

1935
01:04:55,120 --> 01:04:56,650
0,210 210,720 720,810 810,1410 1410,1530
data associated the interrupt to

1936
01:04:56,650 --> 01:04:58,260
0,300 510,1110
the FT.|
|

1937
01:04:59,590 --> 01:05:01,210
0,240 240,960 1020,1170 1170,1350 1350,1620
So when you know the
所以，当备机收到第一条消息时，

1938
01:05:01,210 --> 01:05:02,460
0,630
backup

1939
01:05:03,080 --> 01:05:05,030
0,330 330,720 720,1290 1290,1710 1710,1950
gets the first message,| just
|只需缓冲消息，

1940
01:05:05,030 --> 01:05:06,500
0,330 330,390 390,990
buffers the message,|
|

1941
01:05:06,890 --> 01:05:08,210
0,420 420,480 480,720 720,1140 1140,1320
because it doesn't know how
因为它不知道在这条消息之后会运行多长时间，

1942
01:05:08,210 --> 01:05:09,440
0,240 240,330 330,450 450,960 960,1230
long it can run after

1943
01:05:09,440 --> 01:05:11,510
0,120 120,510 510,1290 1410,1620 1620,2070
that message,| until it knows
|直到它知道下一步必须交付一些东西。

1944
01:05:11,510 --> 01:05:12,740
0,210 210,300 300,630 630,1050 1050,1230
what the next point is

1945
01:05:12,740 --> 01:05:13,580
0,180 180,270 270,450 450,510 510,840
that it has to deliver

1946
01:05:13,580 --> 01:05:14,540
0,390
something.|
|

1947
01:05:14,900 --> 01:05:15,710
0,270 270,360 360,450 450,720 720,810
So at the point that
所以在第二条消息进来的时候，

1948
01:05:15,710 --> 01:05:16,880
0,90 90,420 420,690 690,900 900,1170
the second message comes in,|
|

1949
01:05:16,910 --> 01:05:17,510
0,90 90,210 210,300 300,360 360,600
you know for the second
对于第二次中断，

1950
01:05:17,510 --> 01:05:19,250
0,480 570,840 840,1380 1380,1500 1500,1740
interrupt,| it knows you know
|启动一台计算机是完全正常的，

1951
01:05:19,250 --> 01:05:20,600
0,180 180,540 540,990 990,1110 1110,1350
it's perfectly fine to start

1952
01:05:20,600 --> 01:05:22,550
0,60 60,630 1020,1350 1350,1530 1530,1950
a computer,| {} and instruction
|指令 100 传送中断，

1953
01:05:22,550 --> 01:05:24,500
0,510 630,1050 1050,1110 1110,1650 1800,1950
100 delivered to interrupt,| and
|并且继续运行到指令 200 。

1954
01:05:24,500 --> 01:05:26,210
0,270 270,510 540,990 990,1260 1260,1710
basically keep running into instruction

1955
01:05:26,210 --> 01:05:27,320
0,630
200.|
|

1956
01:05:28,360 --> 01:05:28,990
0,120 120,180 180,330 330,420 420,630
And the way it does,|
它说做的方式，|

1957
01:05:28,990 --> 01:05:30,730
0,150 150,390 390,960 960,1350 1350,1740
it is basically most processors
大多数处理器都有这个，

1958
01:05:30,730 --> 01:05:32,290
0,240 240,390 390,570 570,1140 1140,1560
have this,| but x86 {has,this}
|x86 也有这个，

1959
01:05:32,290 --> 01:05:33,490
0,450 510,720 720,780 780,870 870,1200
too,| where you can basically
|你可以对 x86 进行编程，

1960
01:05:33,490 --> 01:05:35,350
0,540 540,660 660,1320 1320,1440 1440,1860
program the x86| and say
|表示你应该在执行 100 指令后停止，

1961
01:05:35,410 --> 01:05:36,760
0,360 390,540 540,660 660,1110 1110,1350
well you should stop after

1962
01:05:36,760 --> 01:05:38,950
0,390 390,480 480,720 720,1440 1740,2190
executing {} 100 instruction,| so
|所以，处理器会在执行 100 条指令后停止，

1963
01:05:38,950 --> 01:05:40,150
0,180 180,450 450,540 540,900 900,1200
the processor will stop where

1964
01:05:40,150 --> 01:05:42,160
0,450 450,810 810,1080 1080,1830 1860,2010
executing after 100 instructions,| and
|将控制权交还给操作系统，

1965
01:05:42,160 --> 01:05:43,630
0,120 120,270 270,660 660,1170 1170,1470
this give back control to

1966
01:05:43,630 --> 01:05:45,040
0,390 420,840 840,1170 1170,1260 1260,1410
the operating system,| in this
|在这种情况下，就是虚拟机监视器。

1967
01:05:45,040 --> 01:05:46,540
0,330 330,600 600,840 840,1050 1050,1500
case, the virtual machine monitor.|
|

1968
01:05:47,720 --> 01:05:49,580
0,120 120,540 570,690 690,1500 1650,1860
And so you know so
所以，这是我们的方案，

1969
01:05:49,580 --> 01:05:50,720
0,150 150,270 270,390 390,990 990,1140
this is the scheme,| this
|这是 VM-FT 使用的方案，

1970
01:05:50,720 --> 01:05:53,060
0,90 90,150 150,510 510,1230 1230,2340
is a scheme that {VM-FT

1971
01:05:53,060 --> 01:05:54,350
0,150 150,330 330,480 480,1020 1050,1290
- - -} uses| to
|用来传递中断，

1972
01:05:54,350 --> 01:05:56,240
0,540 540,600 600,720 720,1200 1200,1890
basically you know deliver interrupts,|
|

1973
01:05:56,270 --> 01:05:57,890
0,630 630,750 750,1080 1110,1530 1530,1620
both at the primary and
在主机和备机上，

1974
01:05:57,890 --> 01:05:59,360
0,90 90,570 600,1290 1290,1380 1380,1470
the backup,| exactly at the
|完全按照同样的指令，

1975
01:05:59,360 --> 01:06:00,920
0,240 240,840 900,1080 1080,1200 1200,1560
same instruction,| so that {they,sort,of}
|这样它们完全相同，

1976
01:06:01,100 --> 01:06:03,260
0,720 720,990 1020,1680 1680,2100 2100,2160
stay in exactly| execute the
|按照相同的顺序执行指令。

1977
01:06:03,260 --> 01:06:04,880
0,510 510,960 960,1050 1050,1320 1320,1620
instructions exactly the same order.|
|

1978
01:06:06,250 --> 01:06:07,210
0,120 120,450 450,630 630,720 720,960
To arrange this,| of course
要安排这一点，|当然备机会落后一条消息。

1979
01:06:07,210 --> 01:06:08,470
0,180 180,240 240,600 600,960 960,1260
going to backup which needs

1980
01:06:08,470 --> 01:06:11,060
0,960 960,1350 1350,1920
lag behind one,

1981
01:06:13,700 --> 01:06:15,480
0,240 240,510 510,660 660,1170
lag behind one message.|
|

1982
01:06:19,870 --> 01:06:21,040
0,660
Okay?|
好的?|

1983
01:06:23,970 --> 01:06:25,080
0,450 450,660 660,720 720,810 810,1110
So just to be clear,|
所以我只想确认，|

1984
01:06:25,080 --> 01:06:27,060
0,150 150,360 360,1020 1020,1560 1560,1980
so the deterministic operations don't|
确定性操作不会|

1985
01:06:27,210 --> 01:06:28,770
0,300 300,510 510,1200 1290,1470 1470,1560
don't get communicated through the
不会通过日志通道进行通信，

1986
01:06:28,770 --> 01:06:30,480
0,300 300,690 690,1110 1140,1560 1560,1710
logging channel,| it's only the
|只是可能出现差异的操作。

1987
01:06:30,480 --> 01:06:32,200
0,690 690,1170
operations that

1988
01:06:32,290 --> 01:06:34,900
0,420 420,630 630,1410 1680,2370 2370,2610
perhaps might diverged.| Exactly.| Usually
|没错。|通常都是这样。

1989
01:06:34,900 --> 01:06:36,730
0,390 750,1350 1350,1440 1440,1500 1500,1830
got.| Exactly, what it does,|
|确实是这样做的，|

1990
01:06:36,760 --> 01:06:37,510
0,180 180,330 330,510 510,570 570,750
so let's look at one
所以让我们再来看看[]，

1991
01:06:37,510 --> 01:06:38,890
0,390 390,780 780,900 900,1080 1080,1380
more {actually -} get the

1992
01:06:38,920 --> 01:06:41,650
0,300 300,1020 1230,1770 1950,2430 2430,2730
flavor,| {then,we'll,talk}.| Yeah, go ahead.|
|然后我们再讨论。|好的，继续。|

1993
01:06:41,830 --> 01:06:45,100
0,480 480,1080 1110,2250 2250,2910 3090,3270
Sorry, so deterministic operations,| is
抱歉，所以确定性操作，|不需要通过日志通道吗？

1994
01:06:45,100 --> 01:06:46,870
0,510 510,810 810,1020 1020,1590 1590,1770
that don't get communicated through

1995
01:06:46,870 --> 01:06:48,820
0,90 90,360 360,930 1170,1590 1770,1950
the logging channel.| No, there's
|是的，它们不需要，

1996
01:06:48,820 --> 01:06:51,430
0,120 120,330 330,720 1050,1830 1860,2610
no need {for,them},| because both
|因为它们都有一份所有指令的复制，

1997
01:06:51,430 --> 01:06:52,390
0,120 120,270 270,390 390,600 600,960
of them of course have

1998
01:06:52,390 --> 01:06:53,290
0,150 150,570 570,660 660,810 810,900
a copy of all the

1999
01:06:53,290 --> 01:06:54,940
0,690 690,900 900,960 960,1470 1470,1650
instructions,| like the binary that,
|比如二进制，比如 Linux 运行的任何东西，

2000
01:06:54,940 --> 01:06:56,500
0,180 180,540 540,810 810,1140 1140,1560
like whatever Linux runs, correct,|
|

2001
01:06:56,830 --> 01:06:57,910
0,390 390,600 600,720 720,840 840,1080
{} but you know the
但是指令不是通过日志通道通信的，

2002
01:06:57,910 --> 01:06:59,260
0,480 480,540 540,720 720,1260 1260,1350
instructions are not communicated {}

2003
01:06:59,260 --> 01:07:00,730
0,240 240,600 600,1050 1050,1380 1380,1470
over logging channel,| only the
|只有非确定性的（指令）需要。

2004
01:07:00,730 --> 01:07:02,340
0,390 390,870 870,1320
{non-deterministic -} wants.|
|

2005
01:07:02,400 --> 01:07:04,410
0,420 840,1140 1140,1320 1320,1500 1500,2010
{} So {like,in} this interrupt
就像这个中断，我们一会儿会看到，

2006
01:07:04,410 --> 01:07:05,010
0,210 210,330 330,510 510,570 570,600
and we'll see in a

2007
01:07:05,010 --> 01:07:06,270
0,360 360,720 720,900 900,1080 1080,1260
second,| here let's talk about
|这里我们来谈谈第二个问题，非确定性指令，

2008
01:07:06,270 --> 01:07:08,520
0,60 60,330 330,690 1140,1440 1440,2250
the second one, {non-deterministic -}

2009
01:07:08,580 --> 01:07:10,400
0,900
instructions,|
|

2010
01:07:11,190 --> 01:07:12,510
0,390 390,570 570,780 780,870 870,1320
like you get the timer,
比如定时器。

2011
01:07:12,510 --> 01:07:13,980
0,210 210,420 420,480 480,900
get timer of day.|
|

2012
01:07:14,260 --> 01:07:15,100
0,150 150,210 210,360 360,540 540,840
So the way that works
所以工作的方式是，

2013
01:07:15,100 --> 01:07:17,290
0,450 960,1500 1530,1680 1680,2070 2070,2190
is,| {} so here's we
|这里我们有 Linux 在虚拟机上运行，

2014
01:07:17,290 --> 01:07:18,640
0,210 210,420 420,840 840,1230 1230,1350
got our Linux running in

2015
01:07:18,640 --> 01:07:20,080
0,60 60,660 690,990 990,1200 1200,1440
the VM,| we got our
|我们有 FT 运行，

2016
01:07:20,080 --> 01:07:21,940
0,450 450,960
FT running,|
|

2017
01:07:22,000 --> 01:07:24,100
0,630 630,1290 1290,1860 1890,1980 1980,2100
and basically when you know
这个 Linux 使用一个镜像，

2018
01:07:24,100 --> 01:07:26,530
0,240 240,870 1170,1590 1590,2190 2190,2430
this Linux {} use a

2019
01:07:26,530 --> 01:07:28,570
0,600 780,1260 1260,1620 1620,1770 1770,2040
image,| program image that Linux
|Linux 运行的程序镜像，

2020
01:07:28,570 --> 01:07:30,370
0,600 960,1230 1230,1530 1530,1650 1650,1800
runs,| and maybe you know
|也许这里有一些非确定性的指令，

2021
01:07:30,370 --> 01:07:32,200
0,300 300,690 690,870 870,1140 1140,1830
here's are {} {non-deterministic -}

2022
01:07:32,200 --> 01:07:33,320
0,510
instruction,|
|

2023
01:07:33,830 --> 01:07:35,780
0,480 480,960 960,1290 1290,1740 1740,1950
and basically what FT has
基本上 FT 所做的，

2024
01:07:35,780 --> 01:07:37,820
0,510 720,990 990,1590 1590,1680 1680,2040
done,| {} before it started
|在启动 Linux 之前，

2025
01:07:37,820 --> 01:07:39,770
0,570 630,840 840,960 960,1350 1350,1950
Linux,| you {sort,of} gone through
|你浏览 Linux 二进制文件，

2026
01:07:39,770 --> 01:07:41,720
0,150 150,420 420,1110 1140,1620 1620,1950
the Linux binary| and found
|找到所有不确定的指令，

2027
01:07:41,720 --> 01:07:42,620
0,210 210,300 300,690 690,840 840,900
all the instruction that the

2028
01:07:42,620 --> 01:07:44,300
0,240 240,900 900,1290 1290,1470 1470,1680
{non-deterministic -},| like get time
|比如获取时间，

2029
01:07:44,300 --> 01:07:46,400
0,60 60,420 750,900 900,1440 1440,2100
of day,| and basically ensure
|确保把它们转为无效指令，

2030
01:07:46,400 --> 01:07:48,020
0,360 420,720 720,1170 1170,1230 1230,1620
{you,know} turn them {in,sort,of} invalid

2031
01:07:48,020 --> 01:07:50,510
0,630 990,1350 1350,1500 1500,2130 2130,2490
instruction,| and so when Linux
|所以当 Linux 执行这些非确定性指令时，

2032
01:07:50,510 --> 01:07:52,550
0,600 600,990 990,1200 1200,1440 1440,2040
execute, executes that {non-deterministic -}

2033
01:07:52,550 --> 01:07:55,040
0,630 840,1170 1170,1530 1530,2100 2100,2490
instruction,| it actually controls transfers
|它将控制权交给管理程序，

2034
01:07:55,040 --> 01:07:57,200
0,450 450,630 630,1080 1320,1710 1710,2160
control to the {hypervisor -},|
|

2035
01:07:57,610 --> 01:07:58,840
0,240 240,510 510,630 630,720 720,1230
{} this is the trap.|
这就是 trap 。|

2036
01:07:59,600 --> 01:08:00,860
0,300 300,510 510,660 660,930 930,1260
And now the {hypervisor -}
现在监控程序知道，

2037
01:08:00,860 --> 01:08:02,300
0,480 480,690 690,1020 1020,1200 1200,1440
knows,| okay, well this was
|好的，这是指令 341 ，

2038
01:08:02,360 --> 01:08:05,300
0,540 540,960 1170,2070 2370,2700 2700,2940
whatever instruction 341,| I know
|我知道这是一个非确定性指令，

2039
01:08:05,300 --> 01:08:06,770
0,240 240,360 360,630 630,900 900,1470
that is a {non-deterministic -}

2040
01:08:06,770 --> 01:08:08,090
0,450 450,630 630,840 840,1260 1260,1320
instruction,| because I wrote you
|因为我写了导致 trap 的位，

2041
01:08:08,090 --> 01:08:09,590
0,120 120,630 630,1080 1080,1170 1170,1500
know those bits you know

2042
01:08:09,590 --> 01:08:11,660
0,210 210,540 540,630 630,1170 1440,2070
that caused the trap,| and
|它会模拟这条指令，

2043
01:08:11,690 --> 01:08:13,700
0,180 180,360 360,1080 1320,1410 1410,2010
it will emulate that instruction,|
|

2044
01:08:13,880 --> 01:08:15,050
0,360 360,690 690,870 870,1020 1020,1170
and so it will do
所以，它会实现执行的所有效果，

2045
01:08:15,050 --> 01:08:16,430
0,240 240,330 330,690 690,960 960,1380
all the effects that instruction

2046
01:08:16,430 --> 01:08:18,110
0,480 540,810 810,1440 1440,1590 1590,1680
has,| but record what the
|但是记录下效果的结果，

2047
01:08:18,110 --> 01:08:19,640
0,360 360,450 450,540 540,1350 1350,1530
results of the effects are,|
|

2048
01:08:19,670 --> 01:08:21,380
0,150 150,780 990,1140 1140,1290 1290,1710
so {for,example}, you know whatever
例如，我们记录下执行指令结果，

2049
01:08:21,380 --> 01:08:22,700
0,90 90,570 570,690 690,780 780,1320
we record what the result

2050
01:08:23,090 --> 01:08:25,070
0,510 510,1080 1080,1170 1170,1500 1500,1980
execution instruction,| the result stays
|结果放到 a0 ，

2051
01:08:25,100 --> 01:08:27,020
0,300 300,540 540,630 630,1260 1530,1920
goes into {a0 -}, {}|
|

2052
01:08:27,020 --> 01:08:28,730
0,330 330,690 690,1080 1080,1230 1230,1710
it records {the,value} {a0 -}|
它记录值 a0 ，|

2053
01:08:28,760 --> 01:08:29,810
0,150 150,300 300,630 630,960 960,1050
and then basically sends to
然后发送到备机，

2054
01:08:29,810 --> 01:08:30,840
0,120 120,720
the backup,|
|

2055
01:08:32,020 --> 01:08:33,460
0,120 120,240 240,450 450,1200 1230,1440
you know the outcome you
那个指令的输出，

2056
01:08:33,460 --> 01:08:34,660
0,120 120,240 240,390 390,900 900,1200
know of that instruction,| so
|比如它在 a0 中的值是 221 ，

2057
01:08:34,660 --> 01:08:36,460
0,570 570,930 930,1560 1560,1650 1650,1800
whatever its value in {a0

2058
01:08:36,460 --> 01:08:38,470
0,330 330,690 690,1170 1530,1770 1770,2010
-} is whatever {221 -

2059
01:08:38,470 --> 01:08:40,150
0,420 690,1050 1050,1170 1170,1620 1620,1680
-},| then of all you
|然后所有发送回，

2060
01:08:40,150 --> 01:08:40,990
0,90 90,300 300,630 630,720 720,840
know send back,| you know
|表示有不确定的指令，

2061
01:08:40,990 --> 01:08:41,830
0,270 270,330 330,450 450,660 660,840
saying you know there's {non-deterministic

2062
01:08:41,830 --> 01:08:43,720
0,630 630,1380
-} instruction,|
|

2063
01:08:43,720 --> 01:08:45,400
0,510 540,960 960,1080 1080,1200 1200,1680
{} result of it is
它的结果是 221 ，

2064
01:08:45,400 --> 01:08:46,700
0,150 150,720
{221 -},|
|

2065
01:08:47,600 --> 01:08:48,560
0,150 150,210 210,360 360,630 630,960
and at some point, correct,|
在某个时刻，|

2066
01:08:48,560 --> 01:08:49,400
0,300 300,420 420,480 480,720 720,840
you know the {backup -}
备机是落后的，

2067
01:08:49,400 --> 01:08:52,070
0,390 390,930 1470,1860 1860,2040 2040,2670
legs behind,| {} it will
|它会执行，

2068
01:08:52,280 --> 01:08:54,020
0,150 150,510 510,1260 1290,1620 1620,1740
you know execute,| because it's
|因为它以相同的顺序，以相同的方式执行这些指令，

2069
01:08:54,020 --> 01:08:55,100
0,420 420,570 570,930 930,1020 1020,1080
executing these instructions in the

2070
01:08:55,100 --> 01:08:56,420
0,360 360,660 660,720 720,1050 1050,1320
same order, in the same

2071
01:08:56,420 --> 01:08:57,800
0,450 510,660 660,750 750,1020 1020,1380
way,| it will also execute
|它也会执行非确定性指令，

2072
01:08:57,800 --> 01:08:59,750
0,90 90,420 420,810 810,1380 1380,1950
the {non-deterministic - -} instruction,|
|

2073
01:08:59,780 --> 01:09:00,800
0,300 300,420 420,750 750,930 930,1020
that will trap into the
会 trap 到内核，

2074
01:09:00,800 --> 01:09:01,780
0,510
kernel,|
|

2075
01:09:01,870 --> 01:09:03,490
0,510 510,840 840,930 930,1290 1290,1620
{} and that usually wait|
这通常会等待，|

2076
01:09:03,490 --> 01:09:05,140
0,630 660,780 780,960 960,1410 1410,1650
until you know {since -}
因为落后，

2077
01:09:05,140 --> 01:09:06,370
0,210 210,510 510,630 630,960 960,1230
legs behind,| the already receives
|直到收到消息，

2078
01:09:06,370 --> 01:09:08,380
0,330 330,390 390,990 1140,1530 1530,2010
probably the message| and basically
|确保它使用相同的值，

2079
01:09:08,380 --> 01:09:09,760
0,180 180,510 510,720 720,1080 1080,1380
make sure that it sticks

2080
01:09:09,760 --> 01:09:11,230
0,90 90,330 330,960 990,1140 1140,1470
the same value,| you know
|返回与主机上的相同的值。

2081
01:09:11,290 --> 01:09:12,730
0,570 570,630 630,810 810,1320 1320,1440
returns the same value as

2082
01:09:12,730 --> 01:09:13,570
0,90 90,300 300,360 360,420 420,840
it did on the primary,

2083
01:09:14,410 --> 01:09:15,430
0,300 300,450 450,630 630,720 720,1020
right.| So this is how
|所以，这就是非确定性指令的处理方式。

2084
01:09:15,430 --> 01:09:17,260
0,330 330,870 870,1290 1290,1380 1380,1830
{non-deterministic -} instructions are handled.|
|

2085
01:09:21,160 --> 01:09:23,800
0,840 840,1170 1170,1440 1440,2130 2160,2640
Sorry, so that happens, {}|
抱歉，这种情况发生在，|

2086
01:09:23,890 --> 01:09:25,420
0,300 300,570 600,1350 1350,1440 1440,1530
like the modification of the
比如修改二进制文件，

2087
01:09:25,420 --> 01:09:27,400
0,450 450,570 570,990 990,1440
binary,| it happens when
|发生在当它创建虚拟机时？

2088
01:09:27,490 --> 01:09:30,070
0,540 570,780 780,1500 1500,2130 2400,2580
{} it creates the {virtual,machines}?|
|

2089
01:09:30,070 --> 01:09:31,990
0,1140 1140,1320 1320,1500 1500,1710 1710,1920
Yeah, we {} think about
是的，我们认为是在引导虚拟机的时候。

2090
01:09:31,990 --> 01:09:32,650
0,60 60,210 210,300 300,390 390,660
it, when it to boot

2091
01:09:32,650 --> 01:09:33,740
0,60 60,240 240,540
to the VM.|
|

2092
01:09:33,890 --> 01:09:35,320
0,810
Okay.|
好的。|

2093
01:09:35,580 --> 01:09:37,200
0,270 270,510 510,750 750,1260 1290,1620
But so the {} the
但是备机重新执行非确定性指令，

2094
01:09:37,320 --> 01:09:40,410
0,840 870,1140 1140,1830 1830,2250 2700,3090
backup {re-executes -} the {non-deterministic

2095
01:09:40,410 --> 01:09:42,720
0,1080 1110,1830 1830,1980 1980,2100 2100,2310
-} instruction,| and then just
|然后只是验证结果？

2096
01:09:42,720 --> 01:09:45,240
0,570 570,930 960,1530 1740,2280 2280,2520
verifies the result?| No, what
|不，它实际上做的是，

2097
01:09:45,240 --> 01:09:46,860
0,90 90,300 300,480 480,630 630,1620
it actually does is,| if
|如果虚拟机监视器执行该指令，

2098
01:09:46,920 --> 01:09:49,530
0,480 720,1080 1080,1560 1560,2130 2160,2610
the virtual machine monitor executes

2099
01:09:49,530 --> 01:09:50,740
0,90 90,720
the instruction,|
|

2100
01:09:51,000 --> 01:09:53,070
0,240 240,1080 1080,1200 1200,1740 1740,2070
and then you know, {}|
然后你知道，|

2101
01:09:53,100 --> 01:09:54,270
0,390 420,720 720,960 960,1080 1080,1170
actually virtual machine monitor that
虚拟机监视器根本不会执行该指令，

2102
01:09:54,270 --> 01:09:55,650
0,180 180,480 480,870 870,990 990,1380
doesn't execute instruction at all,|
|

2103
01:09:55,860 --> 01:09:58,050
0,480 510,840 1020,1920 1920,2070 2070,2190
{} it knows that this
它知道需要执行这个指令，

2104
01:09:58,050 --> 01:09:59,340
0,360 360,480 480,570 570,660 660,1290
instruction needs to be executed,|
|

2105
01:09:59,550 --> 01:10:00,660
0,150 150,270 270,690 690,900 900,1110
and it knows what things
它知道事情会发生什么变化，

2106
01:10:00,660 --> 01:10:01,830
0,120 120,210 210,720 720,870 870,1170
will be changed,| like what
|比如哪些寄存器需要更新，

2107
01:10:01,830 --> 01:10:03,120
0,510 510,630 630,720 720,810 810,1290
registers need to be updated,|
|

2108
01:10:03,120 --> 01:10:03,900
0,90 90,120 120,420 420,510 510,780
as a result of this
作为这个指令的结果，

2109
01:10:03,900 --> 01:10:06,060
0,720 720,1350 1440,1650 1650,1740 1740,2160
{} instruction,| and it sticks
|它将消息中的值放到寄存器中，

2110
01:10:06,060 --> 01:10:07,680
0,90 90,570 570,840 840,930 930,1620
the value from the message

2111
01:10:07,800 --> 01:10:09,570
0,360 360,480 480,1350 1380,1560 1560,1770
into the register,| so that
|所以，在备机上运行的 Linux

2112
01:10:09,570 --> 01:10:11,520
0,1140 1170,1590 1590,1830 1830,1890 1890,1950
the Linux running on the

2113
01:10:11,520 --> 01:10:12,900
0,480 480,570 570,1020 1020,1110 1110,1380
backups| is exactly the same
|与主机上运行的 Linux 的效果完全相同。

2114
01:10:12,900 --> 01:10:15,000
0,360 360,480 480,1260 1470,1890 1890,2100
effect as a Linux running

2115
01:10:15,000 --> 01:10:16,000
0,90 90,150 150,600
on the primary.|
|

2116
01:10:20,560 --> 01:10:21,550
0,150 150,300 300,510 510,660 660,990
And so like this assumes
所以，这样假设管理程序事先做一些工作，

2117
01:10:21,550 --> 01:10:22,510
0,120 120,180 180,450 450,810 810,960
that the {hypervisor -} will

2118
01:10:22,510 --> 01:10:24,190
0,120 120,360 360,600 600,990 990,1680
do some work before| even
|在启动虚拟机之前，

2119
01:10:24,370 --> 01:10:25,840
0,390 390,570 570,960 960,1290 1290,1470
{} or while putting up

2120
01:10:25,840 --> 01:10:27,850
0,540 540,1020 1020,1410 1410,1500 1500,2010
VM| just where the locations
|找出这些不确定（指令）的位置。

2121
01:10:27,850 --> 01:10:29,440
0,120 120,330 330,450 450,1260 1410,1590
of these {non-deterministic -}.| {Yeah,that}
|是的，管理程序执行这些[]。

2122
01:10:29,440 --> 01:10:30,790
0,210 210,390 390,900 900,1080 1080,1350
with {} hypervisor does these

2123
01:10:30,790 --> 01:10:31,620
0,390
[].|
|

2124
01:10:31,680 --> 01:10:32,800
0,270 270,360 360,600

2125
01:10:32,920 --> 01:10:33,820
0,150 150,330 330,450 450,570 570,900
So this is a standard
所以这是一个标准的管理程序，

2126
01:10:33,820 --> 01:10:34,990
0,240 240,510 510,750 750,900 900,1170
{hypervisor -} stuff,| there's nothing
|对于 FT 没有什么新的，

2127
01:10:34,990 --> 01:10:38,440
0,360 360,900 900,1890 2220,2790 2790,3450
new to FT,| other than
|除了这些人拥有丰富的管理程序经验，

2128
01:10:38,440 --> 01:10:39,370
0,150 150,390 390,540 540,840 840,930
these guys a ton of

2129
01:10:39,370 --> 01:10:41,080
0,510 510,630 630,900 900,1380 1380,1710
experience do {hypervisor -},| because
|因为 VMware ，

2130
01:10:41,080 --> 01:10:43,780
0,660 1020,1470 1470,1830 1830,2190 2190,2700
VMware,| and so they understand
|所以他们明白这需要什么，

2131
01:10:43,780 --> 01:10:45,400
0,180 180,870 870,1050 1050,1140 1140,1620
like what what it takes,|
|

2132
01:10:45,940 --> 01:10:47,020
0,210 210,390 390,810 810,900 900,1080
and which instructions are {non-deterministic
以及哪些指令是非确定性的。

2133
01:10:47,020 --> 01:10:49,380
0,570 840,1320
-}. {}|
|

2134
01:10:51,420 --> 01:10:53,880
0,480 720,990 990,1530 1530,2340 2340,2460
Okay, so.| I I had
好的，所以。|我还有一个问题，

2135
01:10:53,880 --> 01:10:55,290
0,270 270,750 810,1080 1080,1290 1290,1410
one more, {} one more

2136
01:10:55,290 --> 01:10:58,410
0,450 450,900 1920,2400 2550,2730 2730,3120
question,| so if you know
|如果这是一个完全确定性指令的程序，

2137
01:10:58,560 --> 01:11:00,090
0,270 270,420 420,990 990,1080 1080,1530
it's a program of fully

2138
01:11:00,090 --> 01:11:02,280
0,180 180,840 840,1740
like deterministic instructions,|
|

2139
01:11:02,400 --> 01:11:03,880
0,330 330,900
{} could,
备机能不能比主机运行得更快。

2140
01:11:04,090 --> 01:11:06,160
0,300 300,450 450,1140 1170,1470 1470,2070
could the backup run faster

2141
01:11:06,160 --> 01:11:07,660
0,120 120,240 240,930
than the primary.|
|

2142
01:11:08,180 --> 01:11:10,070
0,810 840,1350 1350,1680 1680,1830 1830,1890
{} Okay, so you know
好的，论文中有一个完整的讨论，

2143
01:11:10,070 --> 01:11:10,910
0,180 180,240 240,390 390,780 780,840
there's a whole discussion in

2144
01:11:10,910 --> 01:11:11,810
0,60 60,330 330,600 600,840 840,900
the paper| about like the
|关于主备的速度，

2145
01:11:11,810 --> 01:11:12,890
0,420 420,480 480,600 600,960 960,1080
speed of the primary and

2146
01:11:12,890 --> 01:11:14,120
0,450 450,570 570,780 780,1080 1080,1230
backup,| and making sure that
|确保它们以大致相同的速度运行，

2147
01:11:14,150 --> 01:11:15,410
0,510 510,900 900,990 990,1050 1050,1260
run roughly at the same

2148
01:11:15,410 --> 01:11:16,310
0,330 330,540 540,630 630,750 750,900
speed,| because you don't want
|因为你不想领先太多或落后太多，

2149
01:11:16,310 --> 01:11:17,990
0,120 120,330 330,690 690,960 960,1680
to get one far ahead

2150
01:11:17,990 --> 01:11:19,190
0,120 120,300 300,480 480,690 690,1200
and one {} far behind,|
|

2151
01:11:19,610 --> 01:11:21,080
0,480 540,1050 1050,1170 1170,1290 1290,1470
I think you should think
我认为你应该考虑，

2152
01:11:21,080 --> 01:11:21,890
0,240 240,390 390,510 510,720 720,810
about them,| they're running on
|它们在相同的硬件上运行，

2153
01:11:21,890 --> 01:11:23,150
0,120 150,300 300,390 390,780 780,1260
the sort of identical hardware,|
|

2154
01:11:23,150 --> 01:11:24,050
0,90 90,210 210,360 360,600 600,900
and so they're running roughly
所以它们以大致相同的速度运行。

2155
01:11:24,050 --> 01:11:25,300
0,60 60,150 150,360 360,810
at the same speed.|
|

2156
01:11:25,300 --> 01:11:26,590
0,270 390,600 600,840 840,930 930,1290
{} It's also the case
事实也是这样的，

2157
01:11:26,590 --> 01:11:28,160
0,300 330,990
that, {}|
|

2158
01:11:28,160 --> 01:11:29,300
0,360 360,480 480,540 540,660 660,1140
there's going to be always
在这个通道上总会有一些通信，

2159
01:11:29,300 --> 01:11:31,400
0,330 330,870 870,1140 1140,1440 1470,2100
some communication over this channel,|
|

2160
01:11:31,460 --> 01:11:33,950
0,810 930,1380 1380,2040 2040,2190 2190,2490
{} because interrupts are happening
因为中断是周期性发生的，

2161
01:11:33,950 --> 01:11:36,290
0,660 690,1170 1530,2160 2160,2280 2280,2340
periodically, right,| {like,every} you know
|比如每几毫秒，

2162
01:11:36,290 --> 01:11:38,240
0,600 630,780 780,870 870,990 1650,1950
whatever you know a couple

2163
01:11:38,240 --> 01:11:39,560
0,90 90,810 810,1080 1080,1290 1290,1320
of milliseconds,| or maybe a
|或者可能是一百毫秒或十毫秒，

2164
01:11:39,560 --> 01:11:41,150
0,240 240,720 720,750 750,960 960,1590
hundred milliseconds or ten milliseconds,|
|

2165
01:11:41,150 --> 01:11:43,340
0,390 390,1020 1080,1260 1260,1770 1830,2190
depending on how Linux what
根据 Linux 编程硬件定时器的速率，

2166
01:11:43,340 --> 01:11:44,480
0,270 270,540 540,900 900,990 990,1140
rate Linux program the hardware

2167
01:11:44,480 --> 01:11:45,830
0,630 690,990 990,1170 1170,1290 1290,1350
timer,| there will be a
|会有一个定时器中断，

2168
01:11:45,830 --> 01:11:47,300
0,330 330,780 960,1080 1080,1170 1170,1470
timer interrupt,| and {} timer
|定时器中断会传送到备机，

2169
01:11:47,300 --> 01:11:48,920
0,360 360,480 480,600 600,1410 1410,1620
interrupt will be propagated to

2170
01:11:48,920 --> 01:11:50,690
0,360 540,1200 1200,1320 1320,1680 1680,1770
the backup,| and {sort,of,be -}
|如果你愿意，也可以说是同步点。

2171
01:11:50,690 --> 01:11:51,740
0,240 240,570 570,690 690,750 750,1050
sync points if you want.|
|

2172
01:11:53,630 --> 01:11:55,430
0,360 360,720 750,1170 1200,1440 1440,1800
Right, but {} my question
是的，但我的问题是，

2173
01:11:55,430 --> 01:11:57,500
0,150 150,480 720,1020 1020,1560 1560,2070
is like,| for example say
|比如，你有一堆确定性的指令，

2174
01:11:57,500 --> 01:11:58,970
0,420 420,600 600,750 750,1110 1110,1470
you have a bunch of

2175
01:11:58,970 --> 01:12:01,250
0,630 630,1140 1140,1500 1620,2100 2100,2280
deterministic instructions, right,| instructions that
|通过日志通道发送指令，

2176
01:12:01,250 --> 01:12:02,390
0,240 240,540 540,750 750,810 810,1140
are sent through the logging

2177
01:12:02,390 --> 01:12:03,800
0,480
channel,|
|

2178
01:12:03,800 --> 01:12:05,720
0,540 540,930 930,1350 1350,1500 1500,1920
{} which means you know
这意味着主机和备机

2179
01:12:06,050 --> 01:12:07,970
0,390 420,870 870,990 990,1560 1560,1920
the primary and backup| can
|可以按照自己的速度运行这些指令，对吗？

2180
01:12:07,970 --> 01:12:09,530
0,240 240,480 480,1110 1110,1380 1380,1560
run those instructions at at

2181
01:12:09,530 --> 01:12:11,420
0,120 120,270 270,780 810,1320 1560,1890
their own pace, correct.| Yes.|
|是的。|

2182
01:12:11,630 --> 01:12:13,610
0,510 540,780 780,1260 1380,1620 1620,1980
So, say what I mean,|
所以，我的意思是，|

2183
01:12:13,610 --> 01:12:14,330
0,270 270,390 390,480 480,540 540,720
I don't know if this
我不知道这是否会发生，

2184
01:12:14,330 --> 01:12:16,580
0,210 210,570 570,750 750,1020 1020,2250
could happen,| but say like
|但是比如 100 条指令，

2185
01:12:16,610 --> 01:12:18,470
0,480 480,630 630,960 1080,1260 1260,1860
it's you know a 100

2186
01:12:18,500 --> 01:12:20,960
0,810 810,1230 1230,1500 1500,1980 1980,2460
instructions,| and the primary goes
|并且主机转到指令 50 ，

2187
01:12:21,290 --> 01:12:24,140
0,330 330,690 690,1200 1200,2010 2280,2850
to like instruction 50| and
|并获得定时器中断，

2188
01:12:24,140 --> 01:12:26,420
0,420 420,780 780,1230 1260,1650 1650,2280
gets gets a timer interrupt,|
|

2189
01:12:26,880 --> 01:12:28,140
0,270 270,510 510,630 630,1110 1110,1260
{} but the backup is
但是备机已经是 60 的定时器了，

2190
01:12:28,140 --> 01:12:29,820
0,390 390,480 480,810 810,1050 1080,1680
already a timer like 60

2191
01:12:29,820 --> 01:12:31,290
0,90 90,600 630,900 900,1110 1110,1470
or something,| could could that.|
|这有可能吗。|

2192
01:12:31,620 --> 01:12:32,790
0,270 270,420 420,630 630,960 960,1170
It could not happen, right,|
这是不可能的，|

2193
01:12:32,790 --> 01:12:34,110
0,240 240,780 810,900 900,1170 1170,1320
because remember the {backup -}
因为记得备机落后一个消息。

2194
01:12:34,110 --> 01:12:35,400
0,300 300,810 840,1050 1050,1110 1110,1290
legs behind one of these

2195
01:12:35,400 --> 01:12:36,480
0,630
messages.|
|

2196
01:12:36,770 --> 01:12:38,400
0,990

2197
01:12:38,400 --> 01:12:39,450
0,210 210,300 300,600 600,780 780,1050
So the backup won't start
所以，在主机完成之前，备机不会开始执行下一个日志。

2198
01:12:39,450 --> 01:12:41,040
0,450 450,540 540,780 780,1260 1290,1590
executing the next log until

2199
01:12:41,040 --> 01:12:43,530
0,210 240,810 810,960 960,1500 1950,2490
the primary has finished.| Okay.|
|好的。|

2200
01:12:44,380 --> 01:12:45,940
0,270 270,330 330,1140 1170,1500 1500,1560
This is why this is
这就是为什么它落后一个（消息）。

2201
01:12:45,940 --> 01:12:46,960
0,150 150,270 270,450 450,690 690,1020
why it lags behind one.|
|

2202
01:12:47,560 --> 01:12:50,400
0,960
Hmm.|
好的。|

2203
01:12:50,430 --> 01:12:51,440
0,510

2204
01:12:51,440 --> 01:12:52,850
0,240 240,420 420,540 540,1170 1170,1410
{} Like, to ensure that
确认备份落后一条指令，

2205
01:12:52,850 --> 01:12:54,290
0,90 90,480 480,600 600,840 870,1440
the backup is like lagging

2206
01:12:54,320 --> 01:12:55,970
0,510 510,660 660,1290 1290,1470 1470,1650
behind one instruction,| that does
|这就意味着。

2207
01:12:55,970 --> 01:12:57,740
0,150 150,690 690,1020 1020,1230 1230,1770
that mean.| {No,not} one instruction,
|不，不是一条指令，是通道上的一条消息。

2208
01:12:57,740 --> 01:12:59,150
0,240 240,690 690,930 930,1020 1020,1410
one message on the channel.|
|

2209
01:13:00,180 --> 01:13:01,650
0,330 330,390 390,780 780,990 990,1470
But the interrupt is [interrupt],
但中断是中断，

2210
01:13:01,650 --> 01:13:02,550
0,240 240,450 450,600 600,690 690,900
right,| so if we have,|
|所以，如果我们有，|

2211
01:13:02,550 --> 01:13:03,480
0,330 330,420 420,750 750,870 870,930
as you said, if we
如你所说，如果我们有 100 行指令，

2212
01:13:03,480 --> 01:13:04,980
0,180 180,360 360,630 630,1110 1350,1500
have a hundred lines of

2213
01:13:04,980 --> 01:13:06,140
0,630
instructions,|
|

2214
01:13:06,200 --> 01:13:07,610
0,480 510,780 780,900 900,960 960,1410
and running on the backup
然后在备份和主机上运行。

2215
01:13:07,610 --> 01:13:09,440
0,240 240,360 360,720 810,1170 1380,1830
as well as the primary,

2216
01:13:09,440 --> 01:13:10,880
0,360 360,450 450,780 960,1260 1260,1440
then.| The primary backup would
|备机还不会开始，

2217
01:13:10,880 --> 01:13:12,440
0,180 180,300 300,720 720,1050 1320,1560
not have started yet, right,|
|

2218
01:13:12,440 --> 01:13:14,780
0,150 150,450 450,810 810,1140 1140,2340
so the primary runs {200,instructions},|
所以主机运行 200 条指令，|

2219
01:13:14,990 --> 01:13:17,180
0,120 120,510 510,780 780,1320 1320,2190
the backup actually wait| until
备机会等待，|直到主机完成这 100 条指令，

2220
01:13:17,450 --> 01:13:19,520
0,690 690,1080 1110,1500 1500,1830 1830,2070
{} the primary actually just

2221
01:13:19,520 --> 01:13:21,860
0,840 840,1170 1170,1350 1350,1590 1590,2340
completed whatever those 100 instructions,|
|

2222
01:13:21,920 --> 01:13:23,360
0,630 630,750 750,1020 1020,1260 1260,1440
before it starts running those
在它开始运行这 100 条指令之前。

2223
01:13:23,360 --> 01:13:24,640
0,240 240,900
100 instructions.|
|

2224
01:13:25,580 --> 01:13:26,660
0,180 180,660 660,870 870,990 990,1080
So just one way to
所以有一种方式可以考虑，

2225
01:13:26,660 --> 01:13:27,770
0,120 120,330 330,600 600,870 870,1110
think about,| it always runs
|它总是落后了一个时期。

2226
01:13:27,770 --> 01:13:29,840
0,150 150,360 360,720 720,1230 1590,2070
like one epoch behind.| Oh,
|哦，所以这是一种分批计划。

2227
01:13:30,020 --> 01:13:31,070
0,300 300,450 450,630 630,720 720,1050
so it's kind of a

2228
01:13:31,070 --> 01:13:33,500
0,420 420,660 660,750 750,1170 2040,2430
batching kind of scheme.| Yeah.|
|是的。|

2229
01:13:33,500 --> 01:13:34,340
0,210 210,330
{Alright\,,thank} you.|
好的，谢谢。|

2230
01:13:34,670 --> 01:13:35,810
0,390 390,810 870,960 960,1080 1080,1140
Okay, so I want to
好的，我想谈一谈关于失败的问题，

2231
01:13:35,810 --> 01:13:36,410
0,90 90,150 150,300 300,420 420,600
talk a little bit about

2232
01:13:36,410 --> 01:13:37,490
0,240 240,480 480,660 660,840 840,1080
failure over,| because there's a
|因为有几件有趣的事，

2233
01:13:37,490 --> 01:13:38,780
0,270 270,750 750,900 900,1080 1080,1290
couple interesting,| there's one more
|还有一条规则需要确保，

2234
01:13:38,780 --> 01:13:39,710
0,390 390,540 540,720 720,840 840,930
rule that needs to be

2235
01:13:39,710 --> 01:13:41,060
0,570 570,690 690,780 780,1320 1320,1350
ensured,| that we actually {}
|我们得到正确的行为。

2236
01:13:41,060 --> 01:13:43,500
0,1140 1140,1200 1200,1410 1410,1890
get the right behavior.|
|

2237
01:13:43,500 --> 01:13:45,270
0,210 210,660 750,1260 1290,1470 1470,1770
And so, {} so let's
所以，让我们来看看一些场景，

2238
01:13:45,840 --> 01:13:47,280
0,390 390,510 510,660 660,1140 1140,1440
walk through some scenarios,| here's
|这是主机，

2239
01:13:47,280 --> 01:13:49,110
0,60 60,720 1050,1380 1380,1530 1530,1830
the primary,| here's our {hypervisor
|这是我们的管理程序 FT ，

2240
01:13:49,110 --> 01:13:51,240
0,540 540,810 810,1560
-} correct FT,|
|

2241
01:13:51,240 --> 01:13:53,340
0,480 480,570 570,960 960,1530
here's our logging channel,
这是我们的日志通道 FT ，

2242
01:13:54,570 --> 01:13:56,550
0,870 1170,1440 1440,1530 1530,1890 1890,1980
FT,| {you,know} they both on
|它们都在网络上，

2243
01:13:56,550 --> 01:13:58,540
0,60 60,540 540,810 810,1440
the network,| here's {a,client},|
|这里有一个客户端，|

2244
01:13:59,430 --> 01:14:01,080
0,540 540,720 720,1020 1020,1290 1290,1650
and here's our {backup -}.|
这是我们的备机。|

2245
01:14:04,010 --> 01:14:04,790
0,360 360,450 450,570 570,630 630,780
And I'm going to talk
接下来我要讲几个场景，

2246
01:14:04,790 --> 01:14:06,410
0,150 150,210 210,540 540,840 840,1620
about a couple of scenarios,|
|

2247
01:14:06,830 --> 01:14:08,640
0,630 630,1260
so {}
所以第一种情况是正常的情况，

2248
01:14:08,840 --> 01:14:10,190
0,330 330,630 630,1080 1080,1260 1260,1350
the first scenario are the

2249
01:14:10,190 --> 01:14:13,220
0,270 270,660 660,990 1020,1740 2220,3030
normal case,| a client {sends,a}
|客户端向主机发送消息，

2250
01:14:13,250 --> 01:14:14,440
0,750
message

2251
01:14:14,530 --> 01:14:16,000
0,120 120,210 210,780 780,930 930,1470
you know to the primary,|
|

2252
01:14:16,000 --> 01:14:17,290
0,450 450,510 510,930 930,1170 1170,1290
where the servers running on
在主机上运行的服务器，

2253
01:14:17,290 --> 01:14:18,460
0,90 90,690 690,810 810,900 900,1170
the primary,| you know that's
|当然是送到主机的，

2254
01:14:18,460 --> 01:14:20,000
0,390 390,510 510,1020
delivered of course

2255
01:14:20,000 --> 01:14:21,470
0,210 210,720 720,840 840,1260 1260,1470
{} to the primary,| also
|也在通道上发送。

2256
01:14:21,470 --> 01:14:23,420
0,540 540,720 720,1080 1080,1320 1320,1950
sent {you,know} to {on,the} channel.|
|

2257
01:14:24,000 --> 01:14:25,800
0,750 960,1380 1380,1650 1650,1740 1740,1800
And let's assume for a
让我们假设一下，

2258
01:14:25,800 --> 01:14:27,180
0,240 240,690 690,780 780,1260 1260,1380
second,| {that,actually} the message you
|消息到达了管理程序，

2259
01:14:27,180 --> 01:14:28,980
0,390 390,1380 1380,1470 1470,1650 1650,1800
know arrives you know at

2260
01:14:28,980 --> 01:14:31,140
0,450 840,1470 1470,1830 1830,2010 2010,2160
the {hypervisor -},| so it
|所以它知道这是一个中断，

2261
01:14:31,140 --> 01:14:32,190
0,270 270,600 600,750 750,870 870,1050
actually knows that this was

2262
01:14:32,190 --> 01:14:34,200
0,90 90,750 750,930 930,1320 1350,2010
an interrupt,| some packet arrived,|
|一些数据包到达，|

2263
01:14:35,640 --> 01:14:36,900
0,390 390,510 510,810 810,990 990,1260
and so now let's say
所以现在让我们假设主机发回响应，

2264
01:14:36,900 --> 01:14:39,330
0,420 510,1290 1290,2130 2160,2400 2400,2430
the primary who sent a

2265
01:14:39,330 --> 01:14:40,880
0,480 480,1020
response back,|
|

2266
01:14:41,030 --> 01:14:42,470
0,600 600,720 720,870 870,1350 1350,1440
and at that point, the
在这个时刻，计算机崩溃了，

2267
01:14:42,470 --> 01:14:43,900
0,300 300,870
computer crashes,|
|

2268
01:14:44,860 --> 01:14:46,180
0,240 240,390 390,750 750,1260 1260,1320
so the primary fails,| the
所以主机出现故障，|客户端尚未收到响应。

2269
01:14:46,180 --> 01:14:47,020
0,270 270,390 390,570 570,780 780,840
client has not gotten a

2270
01:14:47,020 --> 01:14:48,260
0,390 390,690
response yet.|
|

2271
01:14:48,900 --> 01:14:49,680
0,210 210,360 360,570 570,690 690,780
Now, this turns out to
现在，这是非常好的，

2272
01:14:49,680 --> 01:14:51,600
0,180 180,420 420,810 810,1530 1530,1920
work out perfectly fine,| because
|因为在备机真正接管之前，

2273
01:14:51,600 --> 01:14:53,100
0,780 810,900 900,990 990,1110 1110,1500
before you know the backup

2274
01:14:53,100 --> 01:14:54,420
0,240 240,480 480,870 870,990 990,1320
actually takes over,| it first
|它首先处理所有收到的消息，

2275
01:14:54,420 --> 01:14:57,930
0,600 600,1020 1020,1350 2370,3090 3120,3510
processes all it's {} message

2276
01:14:57,930 --> 01:14:59,160
0,150 150,420 420,780 780,990 990,1230
that has received yet,| because
|因为像我们之前说的，落后一个（消息），

2277
01:14:59,160 --> 01:15:00,510
0,240 240,450 450,990 1020,1290 1290,1350
lags one behind, as we

2278
01:15:00,510 --> 01:15:02,310
0,240 240,840 1140,1560 1560,1680 1680,1800
talked before,| so you know
|所以这个东西是要传送。

2279
01:15:02,310 --> 01:15:03,900
0,210 210,540 540,690 690,1140
this thing will be

2280
01:15:03,900 --> 01:15:06,330
0,480 480,1080 1080,1410 1800,2130 2130,2430
{} delivery.| So it will,
|它会，抱歉。

2281
01:15:06,360 --> 01:15:07,360
0,390
sorry.|
|

2282
01:15:09,430 --> 01:15:10,600
0,630

2283
01:15:11,340 --> 01:15:12,520
0,600

2284
01:15:12,640 --> 01:15:13,930
0,300 390,600 600,750 750,990 990,1290
{} Okay, let me a
好的，让我再小心一点，

2285
01:15:13,930 --> 01:15:15,490
0,150 150,240 240,360 360,810 1080,1560
little bit more careful, {}|
|

2286
01:15:15,490 --> 01:15:16,870
0,210 210,360 360,660 660,870 870,1380
okay, so it gets delivered
好的，它被传送到主备机，

2287
01:15:16,870 --> 01:15:17,740
0,60 60,150 150,390 390,630 630,870
to the primary backup does

2288
01:15:17,740 --> 01:15:19,000
0,570 570,690 690,780 780,990 990,1260
it,| but it actually won't
|但它不会发出任何回应，

2289
01:15:19,000 --> 01:15:20,680
0,300 300,540 540,1230
send any response,|
|

2290
01:15:20,930 --> 01:15:22,190
0,330 330,450 450,810 810,1020 1020,1260
because it's still,| so you
因为它仍然，|做主机所做的事情，

2291
01:15:22,190 --> 01:15:23,660
0,360 450,870 870,1290 1290,1410 1410,1470
know doing exactly what the

2292
01:15:23,660 --> 01:15:25,580
0,540 540,690 690,1140 1350,1800 1800,1920
primary has done,| gets through
|通过那个点，然后停下来。

2293
01:15:25,580 --> 01:15:26,930
0,180 180,480 480,720 720,810 810,1350
that particular point and stops.|
|

2294
01:15:27,610 --> 01:15:29,110
0,390 390,690 690,900 900,960 960,1500
Then point {you,know} {} []|
然后那个点[]，|

2295
01:15:29,110 --> 01:15:29,800
0,90 90,210 210,450 450,630 630,690
you know or like the
或者备机成为主机，

2296
01:15:29,800 --> 01:15:30,610
0,240 240,300 300,480 480,720 720,810
{backup -} {} becomes the

2297
01:15:30,610 --> 01:15:31,600
0,540 540,660 660,780 780,900 900,990
primary,| you know through the
|通过仲裁服务器，

2298
01:15:31,600 --> 01:15:33,580
0,480 480,990 1380,1620 1620,1680 1680,1980
arbitration server,| and the client
|客户端将会超时并重试，

2299
01:15:33,580 --> 01:15:35,140
0,90 90,330 330,900 900,1020 1020,1560
will just timeout and retry,|
|

2300
01:15:35,200 --> 01:15:36,940
0,450 450,600 600,1170 1170,1500 1500,1740
because like TCP packet, then
因为就像 TCP 包，然后得到响应，

2301
01:15:36,940 --> 01:15:38,050
0,120 120,180 180,660 660,870 870,1110
get a response,| so {retry,actually}
|所以重试把事情做得完美。

2302
01:15:38,050 --> 01:15:39,430
0,510 510,660 660,870 870,990 990,1380
trying to work out perfect.|
|

2303
01:15:41,100 --> 01:15:43,080
0,120 120,450 450,720 720,1410 1560,1980
The interesting case is,| what
有趣的案例是，|在以下情况下会发生什么，

2304
01:15:43,080 --> 01:15:44,340
0,750
happens

2305
01:15:44,840 --> 01:15:46,550
0,120 120,180 180,480 480,1050 1080,1710
in the following scenario,| where
|客户端发送请求的情况下，

2306
01:15:48,420 --> 01:15:49,540
0,570
the

2307
01:15:49,710 --> 01:15:51,420
0,420 420,660 660,720 720,1290 1440,1710
client sends a request,| {it,can}
|它可以到达主机，

2308
01:15:51,420 --> 01:15:52,410
0,120 120,390 390,450 450,510 510,990
it arrives at the primary,|
|

2309
01:15:52,410 --> 01:15:54,840
0,780 780,1530 1530,1620 1620,2250 2250,2430
primary does the operation,| or
主机进行操作，|或者客户端请求的任何流程，

2310
01:15:54,840 --> 01:15:56,850
0,330 330,660 660,1020 1020,1590 1650,2010
whatever process {the,client} request,| since
|因为消息是给容错服务器的，

2311
01:15:56,850 --> 01:15:57,870
0,90 90,420 420,540 540,900 900,1020
the message to fault {tolerance

2312
01:15:57,870 --> 01:16:00,630
0,30 30,720 840,1530 1740,2580 2580,2760
-} server,| {} {in,the,meantime},| okay,
|与此同时，|好的，它也会发送给日志通道，

2313
01:16:00,630 --> 01:16:01,860
0,120 120,270 270,780 780,1110 1110,1230
it was also sent on

2314
01:16:01,860 --> 01:16:03,240
0,60 60,390 390,930 1050,1200 1200,1380
the logging channel,| but let's
|但是假设我们运气不好，

2315
01:16:03,240 --> 01:16:04,620
0,150 150,300 300,480 480,1050 1200,1380
say we got unlucky,| and
|这条消息从未通过日志通道，

2316
01:16:04,620 --> 01:16:05,820
0,60 60,360 360,570 570,900 900,1200
the message actually never made

2317
01:16:05,820 --> 01:16:06,990
0,90 90,300 300,360 360,660 660,1170
it over the logging channel,|
|

2318
01:16:07,860 --> 01:16:10,180
0,840 870,1740
and, {}|
同时，|

2319
01:16:10,300 --> 01:16:11,600
0,720

2320
01:16:12,520 --> 01:16:14,920
0,780 1260,1500 1500,1770 1770,2070 2070,2400
{} but the primary actually
但是主机发送响应，

2321
01:16:14,920 --> 01:16:16,750
0,90 90,690 720,1110 1110,1170 1170,1830
you know sends a response,|
|

2322
01:16:16,750 --> 01:16:20,770
0,1140 1230,2400 2760,3390 3420,3840 3840,4020
before {just,sends,a} response and then
在发送响应之前，然后它失败了，

2323
01:16:20,770 --> 01:16:21,860
0,120 120,630
it fails,

2324
01:16:22,700 --> 01:16:23,930
0,300 300,480 480,690 690,750 750,1230
right,| and so for example
|比如，

2325
01:16:23,930 --> 01:16:25,040
0,240 240,690 690,780 780,900 900,1110
like,| maybe you know this
|可能这个请求是将变量从 10 增加到 11 ，

2326
01:16:25,040 --> 01:16:26,840
0,420 420,570 570,720 720,1530 1530,1800
request was to increase the

2327
01:16:26,840 --> 01:16:28,580
0,450 450,540 540,1140 1230,1350 1350,1740
variable from 10 to 11,|
|

2328
01:16:28,580 --> 01:16:30,600
0,420 840,1380
so inc
所以 inc ，旧的状态是 10 ，现在新的状态是 11 ，

2329
01:16:30,600 --> 01:16:31,950
0,240 240,450 450,630 630,780 780,1350
the old state was 10

2330
01:16:32,340 --> 01:16:33,330
0,120 120,450 450,540 540,690 690,990
and now the new state

2331
01:16:33,330 --> 01:16:34,440
0,90 90,570
is 11,

2332
01:16:36,190 --> 01:16:37,200
0,450
right.|
|

2333
01:16:38,300 --> 01:16:39,980
0,360 360,480 480,630 630,1350 1500,1680
And is this problematic, this
这种情况有问题吗？

2334
01:16:39,980 --> 01:16:41,180
0,660
scenario?|
|

2335
01:16:41,810 --> 01:16:44,060
0,810 810,1560 1590,1830 1830,1890 1890,2250
Yeah, because when the backup
是的，因为当备机接手的时候，

2336
01:16:44,060 --> 01:16:46,440
0,300 300,660 660,990 1080,1770
takes over,| it won't
|它不知道这个增长，

2337
01:16:46,440 --> 01:16:49,680
0,270 270,690 690,1680 1770,2190 2340,3240
{} know about that increase,|
|

2338
01:16:49,710 --> 01:16:51,390
0,540 930,1140 1140,1320 1320,1500 1500,1680
{} and so it'll just
所以，它将继续执行，就像它没有发生一样，

2339
01:16:51,390 --> 01:16:52,890
0,360 360,1140 1140,1320 1320,1440 1440,1500
continue execution as if it

2340
01:16:52,890 --> 01:16:55,410
0,240 240,690 690,1110 1200,1530 1530,2520
didn't happen,| and this provides
|我想这会造成不一致的输出，

2341
01:16:55,470 --> 01:16:59,220
0,900 1140,2310 2400,2910 2910,3450 3450,3750
like inconsistent {} output| to
|对于外部的世界。

2342
01:16:59,220 --> 01:17:01,650
0,90 90,1290 1440,1710 1710,2160 2160,2430
the external like [facing] world

2343
01:17:01,650 --> 01:17:03,540
0,60 60,480 720,1170 1170,1590 1650,1890
I guess.| Yeah, exactly, right,|
|是的，没错，|

2344
01:17:03,540 --> 01:17:04,860
0,270 270,330 330,630 630,990 990,1320
because the primary will takeover,
因为备机将会接管，

2345
01:17:04,860 --> 01:17:05,820
0,90 90,360 360,450 450,630 630,960
the backup will take over,|
|

2346
01:17:05,820 --> 01:17:07,140
0,60 60,510 510,810 810,900 900,1320
the value still be 10,|
而值仍是 10 ，|

2347
01:17:07,410 --> 01:17:09,030
0,570 570,870 870,1200 1200,1530 1530,1620
{} and now if the
现在如果客户端执行 inc ，

2348
01:17:09,030 --> 01:17:10,200
0,270 270,510 510,780 780,1050 1050,1170
client does inc,| it can
|它会得到 11 ，

2349
01:17:10,200 --> 01:17:11,730
0,480 480,810 810,1050 1050,1320 1320,1530
actually {} gets 11 back,|
|

2350
01:17:11,730 --> 01:17:13,050
0,210 210,300 300,660 960,1260 1260,1320
instead of 10, instead of
而不是 12 。

2351
01:17:13,050 --> 01:17:13,840
0,480
12,

2352
01:17:13,900 --> 01:17:15,190
0,390 690,870 870,1050 1050,1140 1140,1290
right.| So this is no
|所以这是不好的，

2353
01:17:15,190 --> 01:17:16,450
0,360 810,930 930,1020 1020,1140 1140,1260
good,| and so how is
|那么如何避免这个问题呢？

2354
01:17:16,450 --> 01:17:18,380
0,150 150,690 690,840 840,1380
this avoided this problem?|
|

2355
01:17:18,570 --> 01:17:21,540
0,660 660,1500 1530,2100 2100,2280 2280,2970
{} The primary will send
主机将数据发送到备机，

2356
01:17:21,630 --> 01:17:23,910
0,840 840,1410 1410,1710 1710,2160 2160,2280
things to the backup| and
|然后等待确认，

2357
01:17:23,910 --> 01:17:25,560
0,180 180,420 420,690 690,1500 1500,1650
then wait for acknowledgement,| and
|一旦接收到确认，

2358
01:17:25,560 --> 01:17:28,590
0,240 240,1050 1770,2490 2490,2640 2640,3030
once that acknowledgement is received,|
|

2359
01:17:28,590 --> 01:17:31,140
0,90 90,360 360,810 1350,1950 1980,2550
it can {} send output,|
它可以发送输出，|

2360
01:17:31,590 --> 01:17:32,640
0,360 360,510 510,600 600,900 900,1050
{} and it doesn't matter
备机是否运行该命令并不重要，

2361
01:17:32,640 --> 01:17:34,440
0,270 270,360 360,810 810,1350 1350,1800
whether the backup actually runs

2362
01:17:34,440 --> 01:17:35,520
0,120 120,600 600,720 720,900 900,1080
the command,| it just has
|它只是必须拥有它，

2363
01:17:35,520 --> 01:17:37,440
0,390 510,870 870,1320 1350,1560 1560,1920
to have it,| so that
|如果它需要接手主机的工作，

2364
01:17:37,500 --> 01:17:39,210
0,660 660,810 810,1020 1020,1350 1350,1710
if it ever needs to

2365
01:17:39,210 --> 01:17:40,620
0,300 300,660 660,810 810,1260 1260,1410
take over as primary,| it
|它有它的日志，

2366
01:17:40,620 --> 01:17:41,880
0,330 330,630 630,750 750,900 900,1260
has that and it's logs,|
|

2367
01:17:41,880 --> 01:17:42,720
0,90 90,150 150,240 240,540 540,840
and it will catch up
在成为主机之前，它会赶上。

2368
01:17:42,720 --> 01:17:44,980
0,780 930,1530 1530,1920
before actually like

2369
01:17:45,610 --> 01:17:47,140
0,390 420,540 540,930 930,1410 1410,1530
become primary.| Exactly right, so
|完全正确，这就是所谓的输出规则，

2370
01:17:47,140 --> 01:17:47,980
0,180 180,240 240,420 420,720 720,840
this is what's called the

2371
01:17:47,980 --> 01:17:49,740
0,450 450,780
output rule,|
|

2372
01:17:51,520 --> 01:17:52,660
0,240 240,300 300,630 630,810 810,1140
and the rule is that
规则是在你可以输出之前，

2373
01:17:52,660 --> 01:17:53,620
0,120 120,180 180,720 720,840 840,960
you know before you can

2374
01:17:53,620 --> 01:17:55,090
0,570 900,1110 1110,1230 1230,1290 1290,1470
output,| you got to make
|你必须确保，

2375
01:17:55,090 --> 01:17:58,450
0,600 600,1170 1170,1860 2130,2790 2790,3360
sure that,| the preceding messages
|前面发送给备机的消息，

2376
01:17:58,450 --> 01:17:59,500
0,180 180,270 270,390 390,900 900,1050
that you were sent to

2377
01:17:59,500 --> 01:18:00,640
0,120 120,570 570,810 810,960 960,1140
the backup| actually have been
|已经在备机接收到了。

2378
01:18:00,640 --> 01:18:02,320
0,570 570,690 690,780 780,1170
received by the backup.|
|

2379
01:18:02,610 --> 01:18:03,660
0,180 180,330 330,750 750,840 840,1050
So this scenario I just
所以我刚才提出的这个场景实际上不会发生，

2380
01:18:03,660 --> 01:18:05,070
0,270 270,540 540,930 930,1140 1140,1410
drew out going actually never

2381
01:18:05,070 --> 01:18:06,160
0,510
happen,|
|

2382
01:18:06,220 --> 01:18:07,120
0,420 420,570 570,720 720,810 810,900
because you know at that
因为在这一点上，

2383
01:18:07,120 --> 01:18:08,800
0,510 510,600 600,750 750,1170 1200,1680
point,| you know the primary
|主机想要在网络上发送响应，

2384
01:18:08,800 --> 01:18:09,910
0,270 270,360 360,540 540,570 570,1110
wants to send a response

2385
01:18:09,910 --> 01:18:11,800
0,240 240,330 330,420 420,930 1380,1890
out on the network,| the
|主机 FT 将会等待

2386
01:18:11,920 --> 01:18:14,200
0,600 600,690 690,1050 1050,1560 1590,2280
FT, the primary FT {will,wait}|
|

2387
01:18:14,200 --> 01:18:16,030
0,330 330,570 570,900 900,1170 1170,1830
until this message actually has
直到该消息已经被备机接收到，

2388
01:18:16,060 --> 01:18:17,920
0,390 390,600 600,1050 1050,1200 1200,1860
has been received by the

2389
01:18:17,920 --> 01:18:18,960
0,540
backup,|
|

2390
01:18:18,960 --> 01:18:20,370
0,360 360,750 750,930 930,1050 1050,1410
and only when it received
并且仅当它从备机 FT 收到确认时，

2391
01:18:20,370 --> 01:18:23,140
0,90 90,990 1350,1710 1710,2070
an acknowledgement from the

2392
01:18:23,660 --> 01:18:25,910
0,630 630,840 840,1230 1530,2040 2040,2250
backup {FT -},| {} and
|现在知道备机有一份这个输入的副本，

2393
01:18:25,910 --> 01:18:27,320
0,180 180,930 930,1050 1050,1140 1140,1410
now knows you know that

2394
01:18:27,320 --> 01:18:29,540
0,510 510,780 780,1140 1140,1710 1740,2220
basically the backup has a

2395
01:18:29,540 --> 01:18:31,360
0,480 480,570 570,720 720,1290
copy of this input,|
|

2396
01:18:31,450 --> 01:18:33,070
0,390 390,540 540,690 690,1500 1530,1620
{} and so whatever you
所以不管它失败了，

2397
01:18:33,070 --> 01:18:34,120
0,60 60,420 420,510 510,960 960,1050
know whatever it fails,| you
|备机会执行那个输入，

2398
01:18:34,120 --> 01:18:35,770
0,150 150,420 660,1170 1170,1590 1590,1650
know the backup will you

2399
01:18:35,770 --> 01:18:37,000
0,180 300,690 690,840 840,1140 1140,1230
know process that input,| and
|并且得到一台与主机处于相同状态的计算机，

2400
01:18:37,000 --> 01:18:38,350
0,390 390,720 750,960 960,1290 1290,1350
basically get a computer in

2401
01:18:38,350 --> 01:18:39,520
0,60 60,300 300,630 630,1050 1080,1170
the same state as the

2402
01:18:39,520 --> 01:18:41,350
0,540 720,900 900,1110 1110,1380 1380,1830
primary,| so at that point
|所以在这一时刻，发出回应是安全的。

2403
01:18:41,380 --> 01:18:43,060
0,150 150,450 450,1110 1320,1440 1440,1680
and actually safe to send

2404
01:18:43,060 --> 01:18:44,360
0,180 180,270 270,810
out the reply.|
|

2405
01:18:45,080 --> 01:18:45,830
0,150 150,270 270,420 420,630 630,750
And so this is the
这就是输出规则，

2406
01:18:45,830 --> 01:18:47,780
0,390 390,750 750,1020 1020,1410 1710,1950
output rule,| is that you
|就是你不会输出，

2407
01:18:47,780 --> 01:18:49,970
0,240 240,780 780,1560 1680,1860 1860,2190
don't output| until {} all
|直到前面所有你通过日志通道发送的消息

2408
01:18:49,970 --> 01:18:51,740
0,660 660,1200 1200,1380 1380,1500 1500,1770
preceding messages that you send

2409
01:18:51,740 --> 01:18:53,390
0,270 270,630 630,1020 1050,1380 1380,1650
over log channel| actually have
|已经被备机接收到。

2410
01:18:53,390 --> 01:18:54,770
0,180 180,720 720,870 870,930 930,1380
been received by the backup.|
|

2411
01:18:55,760 --> 01:18:57,050
0,180 180,450 450,720 720,810 810,1290
And so just to clarify,|
我想确认一下，|

2412
01:18:57,050 --> 01:18:58,790
0,420 420,720 720,990 990,1320 1320,1740
it seems that the output
看起来输出规则就是用来解决这种不一致的，

2413
01:18:58,790 --> 01:19:00,410
0,480 570,720 720,960 960,1290 1290,1620
rule {} is here to

2414
01:19:00,410 --> 01:19:02,300
0,510 630,960 960,1050 1050,1710 1710,1890
{} solve the inconsistency,| that
|如果我们有一些非确定性的，

2415
01:19:02,300 --> 01:19:03,530
0,180 180,630 630,840 840,990 990,1230
could happen if we have

2416
01:19:03,530 --> 01:19:06,110
0,180 180,330 330,1050 1350,2070 2130,2580
some {non-determinism -},| so like
|比如，我们的输出操作是指令 60 ，

2417
01:19:06,170 --> 01:19:07,100
0,420 420,540 540,690 690,780 780,930
let's say that we have

2418
01:19:07,100 --> 01:19:08,330
0,90 90,450 450,1050 1050,1140 1140,1230
the output operation to be

2419
01:19:08,330 --> 01:19:11,240
0,480 480,1050 1410,2610 2640,2850 2850,2910
instruction 60,| and we do
|而且我们没有输出规则，

2420
01:19:11,240 --> 01:19:13,400
0,270 270,480 480,1440 1470,1890 1890,2160
not have the output rule,|
|

2421
01:19:13,580 --> 01:19:15,050
0,270 270,450 450,540 540,900 900,1470
and so the backup actually
所以备机实际上并没有，

2422
01:19:15,050 --> 01:19:16,370
0,240 240,720 750,990 990,1140 1140,1320
did not,| let's say for
|假设由于某种原因没有接收到输出操作，

2423
01:19:16,370 --> 01:19:17,870
0,210 210,480 480,660 660,930 930,1500
some reason did not receive

2424
01:19:17,900 --> 01:19:21,500
0,570 600,1230 1260,2040 2310,3270 3270,3600
the output operation,| {} or
|或者直到输出操作才接收到，

2425
01:19:21,500 --> 01:19:22,310
0,90 90,180 180,360 360,630 630,810
it did not receive up

2426
01:19:22,310 --> 01:19:24,050
0,270 270,360 360,660 660,1260 1440,1740
until the output operation,| if
|如果指令在点之间是确定性的，

2427
01:19:24,050 --> 01:19:26,150
0,330 330,870 870,1020 1020,1770 1770,2100
the instructions are deterministic between

2428
01:19:26,150 --> 01:19:27,830
0,120 120,570 630,1050 1050,1140 1140,1680
the point,| where the backup
|备机没有收到消息，

2429
01:19:27,920 --> 01:19:30,410
0,210 210,480 480,960 1050,1710 1950,2490
did not receive messages| until
|直到我们进行输出操作时，

2430
01:19:30,410 --> 01:19:31,520
0,90 90,360 360,810 840,960 960,1110
the point where we have

2431
01:19:31,520 --> 01:19:33,590
0,90 90,420 420,1110 1380,1650 1650,2070
an output operation,| do we
|我们还会遇到不一致的问题吗？

2432
01:19:33,590 --> 01:19:34,730
0,360 360,480 480,660 660,750 750,1140
still run into the problem

2433
01:19:34,730 --> 01:19:36,160
0,150 150,270 270,1110
of the inconsistency?|
|

2434
01:19:36,280 --> 01:19:37,270
0,240 240,480 480,540 540,840 840,990
Yeah, because the client might
是的，因为客户端可能会注意到这一点，

2435
01:19:37,270 --> 01:19:39,520
0,420 420,660 1020,1380 1380,1740 1890,2250
observe that, right,| the client
|客户端可能会注意到现在的值是 11 。

2436
01:19:39,520 --> 01:19:40,810
0,180 180,300 300,900 900,1020 1020,1290
might have observed that actually

2437
01:19:40,810 --> 01:19:42,440
0,390 390,450 450,630 630,1080
value is now 11.|
|

2438
01:19:43,600 --> 01:19:44,890
0,210 210,330 330,690 690,810 810,1290
And so when it actually
所以，当它在主机发生故障后，访问备机时，

2439
01:19:44,920 --> 01:19:46,690
0,360 360,450 450,780 780,1230 1230,1770
talks to the backup after

2440
01:19:46,690 --> 01:19:48,490
0,390 540,1140 1140,1290 1290,1740 1740,1800
the primary has failed,| you
|值应该只是 10 ，

2441
01:19:48,490 --> 01:19:49,840
0,300 300,690 690,900 900,1170 1170,1350
know then the value should

2442
01:19:49,840 --> 01:19:50,920
0,150 150,510
only 10,|
|

2443
01:19:51,180 --> 01:19:52,110
0,330 330,390 390,660 660,870 870,930
and {you,know} that can't be
那是不可能的，

2444
01:19:52,110 --> 01:19:53,100
0,450
true,|
|

2445
01:19:53,490 --> 01:19:54,780
0,240 240,510 540,690 690,810 810,1290
so that you know that
这显示它的行为不像一个单一的系统。

2446
01:19:54,810 --> 01:19:56,340
0,660 660,840 840,960 960,1200 1200,1530
reveals that is not behaving

2447
01:19:56,340 --> 01:19:57,880
0,180 180,240 240,480 480,960
like a single system.|
|

2448
01:19:58,300 --> 01:19:59,360
0,180 180,450
I see.|
我明白了。|

2449
01:19:59,450 --> 01:20:01,880
0,1260 1260,1380 1380,1950 1950,2310 2310,2430
It's the external thing you
外部客户端会观察到一些错误，

2450
01:20:01,880 --> 01:20:03,080
0,120 120,240 240,660 660,1080 1080,1200
know the external client that

2451
01:20:03,080 --> 01:20:04,220
0,180 180,510 510,750 750,1050 1050,1140
will observe something wrong,| and
|这就是输出规则存在的原因，

2452
01:20:04,220 --> 01:20:05,090
0,150 150,240 240,450 450,570 570,870
this is why the output

2453
01:20:05,090 --> 01:20:07,340
0,300 300,780 1110,1380 1380,1770 1770,2250
rule exists,| in any replication
|在任何复制系统中，

2454
01:20:07,340 --> 01:20:08,210
0,330 330,480 480,570 570,720 720,870
system,| that we'll see this
|我们在这学期会看到的，

2455
01:20:08,210 --> 01:20:10,040
0,570 600,930 930,1380 1380,1680 1680,1830
semester| has something like the
|都有类似输出规则的东西。

2456
01:20:10,040 --> 01:20:11,160
0,330 330,630
output rule.|
|

2457
01:20:11,160 --> 01:20:11,880
0,90 90,270 270,480 480,630 630,720
And it turns out to
结果是，

2458
01:20:11,880 --> 01:20:13,440
0,270 270,360 360,480 480,1200 1380,1560
be,| you know {for,example} you'll
|比如，你会在 raft 论文中看到，

2459
01:20:13,440 --> 01:20:15,540
0,240 240,360 360,1500 1560,1980 1980,2100
see in the, even in

2460
01:20:15,540 --> 01:20:17,850
0,120 120,480 480,1440 1470,1830 1830,2310
the raft paper,| but also
|也在 zookeeper 中，

2461
01:20:17,850 --> 01:20:19,410
0,300 300,600 600,750 750,1200 1380,1560
in the {zookeeper -}, {}|
|

2462
01:20:19,410 --> 01:20:20,790
0,270 270,450 450,510 510,900 900,1380
there's sort of this notion,|
有这样一种概念，|

2463
01:20:20,790 --> 01:20:21,570
0,180 180,270 270,360 360,690 690,780
that you know sometimes you
有时你想直接回复读取，

2464
01:20:21,570 --> 01:20:23,520
0,150 150,210 210,1350 1380,1830 1830,1950
want to like respond to

2465
01:20:23,520 --> 01:20:25,110
0,480 510,1020 1020,1140 1140,1260 1260,1590
reads immediately,| but you can't
|但你不能这么做，

2466
01:20:25,110 --> 01:20:26,580
0,270 270,420 420,750 750,1230 1290,1470
really do that,| because you
|因为你冒着这种风险，

2467
01:20:26,580 --> 01:20:28,020
0,180 180,360 360,720 720,870 870,1440
run this risk| and sort
|相当于一条输出规则，

2468
01:20:28,020 --> 01:20:28,890
0,90 90,150 150,690 690,780 780,870
of an equivalent of an

2469
01:20:28,890 --> 01:20:30,360
0,390 390,810 930,1170 1170,1410 1410,1470
output rule,| that tries to
|试图避免像这样的问题。

2470
01:20:30,360 --> 01:20:32,490
0,480 480,540 540,1050 1080,1440 1440,2130
avoid you know problems like

2471
01:20:32,520 --> 01:20:33,440
0,210 210,510
like that.|
|

2472
01:20:35,770 --> 01:20:38,890
0,330 330,540 540,660 660,2130 2730,3120
So does the client {re-execute
因此客户端会重新执行该命令吗，

2473
01:20:38,890 --> 01:20:41,140
0,570 570,660 660,1230 1860,2160 2160,2250
-} the command,| like do
|比如它们会不会得到某种信号，

2474
01:20:41,140 --> 01:20:41,980
0,120 120,300 300,450 450,690 690,840
they get some sort of

2475
01:20:41,980 --> 01:20:43,460
0,510 510,960
signal that,|
|

2476
01:20:43,460 --> 01:20:45,380
0,270 270,540 1080,1560 1560,1710 1710,1920
because the command was never
因为备机从未确认过该命令。

2477
01:20:45,380 --> 01:20:46,700
0,330 330,570 570,690 690,1080 1080,1320
ack by the {backup -

2478
01:20:46,700 --> 01:20:47,540
0,300
-}.|
|

2479
01:20:47,540 --> 01:20:49,280
0,720 750,1110 1110,1290 1290,1530 1530,1740
Okay, okay so let's say
好的，我们假设没有收到确认，

2480
01:20:49,280 --> 01:20:50,660
0,750 750,870 870,1140 1140,1290 1290,1380
we did not get the

2481
01:20:50,660 --> 01:20:52,260
0,390 570,1020
ack, right,|
|

2482
01:20:52,890 --> 01:20:53,820
0,150 150,300 300,510 510,660 660,930
so, I've got to {backup
所以，我回到备机没有确认，

2483
01:20:53,820 --> 01:20:54,450
0,150 150,240 240,420 420,510 510,630
-} but not to the

2484
01:20:54,450 --> 01:20:55,420
0,390
ack,|
|

2485
01:20:55,650 --> 01:20:58,740
0,750 780,1380 1380,1800 1800,2550
then {} {the,client} {will,not}|
那么客户端不会，|

2486
01:20:58,930 --> 01:20:59,860
0,150 150,270 270,420 420,780 780,930
you know this response would
这个响应还没有发送到客户端，

2487
01:20:59,860 --> 01:21:00,880
0,120 120,360 360,450 450,900 900,1020
have not been sent to

2488
01:21:00,880 --> 01:21:02,640
0,60 60,390 390,720 750,1170
the client yet, right,|
|

2489
01:21:02,930 --> 01:21:04,580
0,480 480,780 780,930 930,1140 1140,1650
the backup will take over,|
备机将会接管，|

2490
01:21:04,670 --> 01:21:05,810
0,150 150,420 420,750 750,870 870,1140
the client presumably will {timeout
客户端可能会超时，

2491
01:21:05,810 --> 01:21:07,220
0,390 420,900 900,1020 1020,1350 1350,1410
-},| and do whatever it
|做任何它需要做的事，

2492
01:21:07,220 --> 01:21:08,510
0,180 180,240 240,540 570,1230 1230,1290
needs to do,| either you
|要么什么都不做，

2493
01:21:08,510 --> 01:21:09,680
0,150 150,330 330,780 840,1020 1020,1170
know does nothing,| you know
|如果这是它们的一部分，

2494
01:21:09,680 --> 01:21:11,300
0,300 330,450 450,990 1110,1440 1440,1620
if you know that's part

2495
01:21:11,300 --> 01:21:12,740
0,180 180,630 630,1200 1200,1380 1380,1440
of their,| that's part of
|这是服务器和客户端之间协议的一部分，

2496
01:21:12,740 --> 01:21:14,000
0,90 90,480 480,750 750,1110 1110,1260
the protocol between servers and

2497
01:21:14,000 --> 01:21:15,740
0,390 420,870 870,1230 1230,1560 1560,1740
clients,| most likely {the,client} will
|最有可能的是，客户端会重新发送 TCP 连接，

2498
01:21:15,740 --> 01:21:18,680
0,480 930,990 990,1440 1440,2070 2370,2940
re-send the TCP connection, {}|
|

2499
01:21:18,680 --> 01:21:20,630
0,780 810,1200 1200,1440 1440,1650 1650,1950
the response packet didn't get
没有收到响应包，

2500
01:21:20,750 --> 01:21:22,790
0,810 810,960 960,1260 1260,1710 1920,2040
received,| and so {it,will} you
|所以它会试着重新发送，

2501
01:21:22,790 --> 01:21:25,080
0,120 120,750 960,1350 1350,1890
know {try,to} {} re-send,|
|

2502
01:21:25,340 --> 01:21:26,300
0,270 270,390 390,480 480,600 600,960
and so it will re-send
所以它会重新发送到备机，

2503
01:21:26,300 --> 01:21:27,520
0,630
{to,backup},|
|

2504
01:21:28,020 --> 01:21:29,160
0,180 180,330 330,570 570,660 660,1140
and then finish the operation,|
然后完成操作，|

2505
01:21:30,530 --> 01:21:31,790
0,210 210,270 270,690 720,1170 1170,1260
but it won't observe an
但它不会观察到旧的值。

2506
01:21:31,790 --> 01:21:32,960
0,180 180,600
old value.|
|

2507
01:21:38,390 --> 01:21:39,560
0,630
Okay?|
好的?|

2508
01:21:47,580 --> 01:21:48,560
0,510

2509
01:21:50,850 --> 01:21:53,020
0,540 750,1320
Okay, {}
好了，现在我想说一件事，

2510
01:21:53,190 --> 01:21:54,720
0,600 600,720 720,870 870,1200 1230,1530
now I want to talk

2511
01:21:54,720 --> 01:21:56,040
0,450 450,660 660,720 720,960 960,1320
one thing a little bit,|
|

2512
01:21:56,040 --> 01:21:57,900
0,420 420,720 720,840 840,1320 1320,1860
{} then so this system
所以我认为这个系统非常酷，

2513
01:21:57,930 --> 01:21:58,890
0,270 270,450 450,540 540,720 720,960
I think it's actually very

2514
01:21:58,890 --> 01:22:00,480
0,270 270,360 360,450 450,840 840,1590
cool,| it's a very clean
|这是一个非常清楚的状态机复制版本，

2515
01:22:00,840 --> 01:22:04,410
0,840 840,1230 1230,1410 1410,3300 3330,3570
{} version of state machine

2516
01:22:04,410 --> 01:22:06,390
0,690 960,1470 1470,1620 1620,1890 1890,1980
replication,| {} it brings out
|它解决了非确定性的问题，

2517
01:22:06,390 --> 01:22:08,130
0,120 120,510 510,600 600,840 840,1740
this issue of {non-determinism -},|
|

2518
01:22:08,130 --> 01:22:09,480
0,270 270,600 600,780 780,1080 1080,1350
the issues like the output
像输出规则这样的问题，

2519
01:22:09,480 --> 01:22:10,620
0,420 420,570 570,690 690,960 960,1140
rule,| that we'll see in
|我们将在一个版本中看到，

2520
01:22:10,620 --> 01:22:12,030
0,390 420,1020 1020,1110 1110,1320 1320,1410
a version of that,| we'll
|我们将在其他系统中看到类似的情况，

2521
01:22:12,030 --> 01:22:14,280
0,360 360,510 510,1230 1530,2070 2070,2250
see a similar {} in

2522
01:22:14,280 --> 01:22:17,280
0,510 510,990 1860,2520 2670,2970 2970,3000
in other systems,| but I
|但我想谈一谈性能，

2523
01:22:17,280 --> 01:22:17,910
0,120 120,180 180,270 270,330 330,630
want to talk a little

2524
01:22:17,910 --> 01:22:19,710
0,120 120,330 330,1050 1050,1380 1380,1800
bit about performance,| {} because
|因为这个系统的一个缺点是，

2525
01:22:19,710 --> 01:22:21,510
0,180 180,930 930,1560 1560,1650 1650,1800
like one downside of this

2526
01:22:21,510 --> 01:22:23,910
0,630 870,1650 1650,1770 1770,1860 1860,2400
system is,| you know because
|因为你做事情

2527
01:22:23,910 --> 01:22:24,810
0,180 180,390 390,690 690,810 810,900
you're doing things| at the
|在机器指令或中断的级别上，

2528
01:22:24,810 --> 01:22:27,150
0,420 420,600 600,990 1020,1650 1650,2340
level of the machine instructions

2529
01:22:27,150 --> 01:22:29,490
0,300 300,690 690,1320 1560,1830 1830,2340
or level interrupts,| {} there
|你会付出性能的代价。

2530
01:22:29,490 --> 01:22:32,070
0,450 450,900 930,1440 1440,2070 2070,2580
you pay {} performance hit.|
|

2531
01:22:32,980 --> 01:22:35,110
0,630 690,1200 1200,1350 1350,1830 1860,2130
{} So like {1,and,2 -
所以像论文中的表格 1 和 2 ，

2532
01:22:35,110 --> 01:22:36,220
0,180 180,360 360,810 810,960 960,1110
- -} tables that are

2533
01:22:36,220 --> 01:22:37,440
0,90 90,180 180,660
in the paper,|
|

2534
01:22:37,660 --> 01:22:39,400
0,660 780,960 960,1440 1440,1530 1530,1740
{} and one the first
首先要观察的一件事是，

2535
01:22:39,400 --> 01:22:40,210
0,120 120,180 180,540 540,660 660,810
thing to observe is that,|
|

2536
01:22:40,210 --> 01:22:41,590
0,360 360,660 690,1020 1020,1290 1290,1380
actually the left table is
左边的表格非常好，

2537
01:22:41,590 --> 01:22:43,100
0,660 660,960
extremely good,|
|

2538
01:22:43,420 --> 01:22:44,800
0,390 390,630 630,990 990,1320 1320,1380
{} so the backup and
所以备机和主机，

2539
01:22:44,800 --> 01:22:45,940
0,90 90,630 630,870 870,1050 1050,1140
the primary,| you run the
|运行备机和主机的性能非常接近于，

2540
01:22:45,940 --> 01:22:47,890
0,390 390,810 810,1410 1410,1650 1650,1950
backup primary performance was very

2541
01:22:47,890 --> 01:22:48,850
0,360 360,540 540,690 690,810 810,960
close to| as if you
|像没有使用备机运行，

2542
01:22:48,850 --> 01:22:50,140
0,90 90,390 390,630 630,840 840,1290
were not running with a

2543
01:22:50,440 --> 01:22:52,240
0,690 690,1080 1080,1230 1230,1560 1560,1800
backup,| which is very very
|这非常令人印象深刻，

2544
01:22:52,240 --> 01:22:54,010
0,630 630,810 810,1110 1110,1320 1320,1770
impressive,| and in fact including
|包括你运行的是一台虚拟机，

2545
01:22:54,010 --> 01:22:54,700
0,90 90,270 270,360 360,480 480,690
the fact that you're running

2546
01:22:54,700 --> 01:22:55,920
0,30 30,300 300,720
a virtual machine,|
|

2547
01:22:56,300 --> 01:23:00,080
0,510 540,1350 1380,2070 2520,3210 3210,3780
{} {the,more}, the more {}
更麻烦的部分是这边的事情，

2548
01:23:00,780 --> 01:23:02,760
0,540 540,960 990,1230 1230,1440 1440,1980
troublesome part is this side

2549
01:23:02,760 --> 01:23:05,010
0,180 180,450 450,990 1140,1860 2040,2250
of things,| where if you
|如果你不在主/备模式下运行，

2550
01:23:05,010 --> 01:23:06,780
0,180 180,720 780,1020 1020,1470 1470,1770
don't run in a {primary/backup

2551
01:23:06,780 --> 01:23:07,830
0,300 300,600 600,660 660,810 810,1050
-} mode,| you know like
|比如你的带宽和收发相当高，

2552
01:23:07,830 --> 01:23:09,300
0,240 240,750 750,870 870,1380 1380,1470
your bandwidth and receiving and

2553
01:23:09,300 --> 01:23:10,710
0,360 360,660 660,990 990,1350 1350,1410
sending actually pretty high,| you
|至少在他们所做的实验中。

2554
01:23:10,710 --> 01:23:12,780
0,270 270,750 750,1650 1650,1770 1770,2070
know {at,least,in,the,particular} experiment they did.|
|

2555
01:23:13,310 --> 01:23:14,180
0,420 450,540 540,600 600,750 750,870
But you know when you're
但是当你运行备机模式时，

2556
01:23:14,180 --> 01:23:15,740
0,270 270,360 360,720 720,1170 1320,1560
running the backup mode,| things
|其实不是很好，

2557
01:23:15,740 --> 01:23:16,670
0,120 120,300 300,510 510,630 630,930
are actually not so good,

2558
01:23:16,790 --> 01:23:17,960
0,270 270,330 330,420 420,810 810,1170
right,| you know these numbers
|这些数字有很大的不同，

2559
01:23:17,960 --> 01:23:19,910
0,210 210,570 570,1020 1170,1530 1530,1950
are quite different,| {} {in,fact}
|事实上，性能下降了 30% 。

2560
01:23:19,910 --> 01:23:21,800
0,210 210,270 270,750 750,1320 1320,1890
like {} {30%,reduction -} in

2561
01:23:21,830 --> 01:23:23,000
0,720
performance.|
|

2562
01:23:23,190 --> 01:23:24,270
0,210 210,390 390,480 480,630 630,1080
And where is that {30%,coming
这 30% 是从哪里来的，

2563
01:23:24,270 --> 01:23:25,530
0,270 270,510 510,720 720,1020 1020,1260
-} from,| like why, why
|为什么会这样。

2564
01:23:25,530 --> 01:23:26,880
0,90 90,240 240,300 300,840
is that the case.|
|

2565
01:23:34,240 --> 01:23:36,010
0,570 570,930 930,1170 1170,1620 1620,1770
{} Because the primary is
因为主机是接受外部输入的。

2566
01:23:36,010 --> 01:23:37,540
0,330 330,420 420,630 630,1110 1110,1530
actually the one receiving inputs

2567
01:23:37,540 --> 01:23:38,860
0,180 180,720
from outside.|
|

2568
01:23:39,080 --> 01:23:40,730
0,930 930,1230 1230,1380 1380,1560 1560,1650
Yeah, I think there's two
是的，我想有两种情况，

2569
01:23:40,730 --> 01:23:42,710
0,510 510,1110 1110,1410 1410,1560 1560,1980
cases,| {} in on receiving
|在接收的情况下，

2570
01:23:42,710 --> 01:23:43,850
0,240 240,540 540,690 690,750 750,1140
a case,| where the primary
|主机接收来自外部的输入，

2571
01:23:43,850 --> 01:23:45,620
0,480 480,930 930,1110 1110,1260 1260,1770
receiving input from the outside,|
|

2572
01:23:45,620 --> 01:23:46,340
0,240 240,390 390,510 510,660 660,720
where does that need to
这需要放在哪里。

2573
01:23:46,340 --> 01:23:47,220
0,360
go.|
|

2574
01:23:48,020 --> 01:23:48,860
0,120 120,210 210,330 330,450 450,840
If you see a packet
如果你看到来自客户端的数据包，

2575
01:23:48,860 --> 01:23:51,320
0,270 270,1110 1500,1680 1680,2310 2310,2460
from the from {the,client},| so
|数据包必须发送到备机。

2576
01:23:51,320 --> 01:23:52,310
0,360 360,630 630,810 810,900 900,990
that packet has to be

2577
01:23:52,310 --> 01:23:54,560
0,390 390,1140 1140,1680
sent to the

2578
01:23:54,680 --> 01:23:55,980
0,750
{}

2579
01:23:56,490 --> 01:23:58,200
0,240 240,300 300,750 930,1440 1440,1710
to the backup, {sort,of}.| Wait,
|等等，但是主机也是将输出发送回客户端的服务器，

2580
01:23:58,200 --> 01:23:59,580
0,300 450,660 660,1020 1020,1140 1140,1380
but the primary is also

2581
01:23:59,580 --> 01:24:02,940
0,90 90,360 360,1260 1290,2190 2220,3360
the one sending output back

2582
01:24:02,940 --> 01:24:04,050
0,180 180,270 270,690 690,1020 1020,1110
to the clients,| so is
|所以这就是使用带宽的原因。

2583
01:24:04,050 --> 01:24:05,190
0,120 120,330 330,540 540,630 630,1140
that what's using the bandwidth.|
|

2584
01:24:05,660 --> 01:24:07,610
0,600 600,660 690,1080 1080,1440 1590,1950
{} Yeah, well, there's that
是的，这是一个原因，

2585
01:24:07,610 --> 01:24:10,970
0,2520 2520,2970 2970,3060 3060,3150 3150,3360
one reason,| but the real
|但我认为这里真正发生的事情是，

2586
01:24:10,970 --> 01:24:11,660
0,150 150,240 240,360 360,480 480,690
thing I think is going

2587
01:24:11,660 --> 01:24:13,130
0,240 240,570 570,810 810,1110 1110,1470
on here is that,| the
|主机必须等待，

2588
01:24:13,460 --> 01:24:15,710
0,900 900,1110 1110,1260 1260,1830 1860,2250
primary has to wait| until
|直到它可以向客户端发送响应，

2589
01:24:15,710 --> 01:24:16,790
0,90 90,210 210,510 510,570 570,1080
it can send a response

2590
01:24:16,790 --> 01:24:18,530
0,330 360,690 690,1200 1200,1680 1680,1740
to a client| until the
|直到备份确认该响应。

2591
01:24:18,530 --> 01:24:19,790
0,240 240,330 330,600 600,750 750,1260
{backup -} actually has acknowledged

2592
01:24:19,790 --> 01:24:20,420
0,210
it.|
|

2593
01:24:20,960 --> 01:24:22,280
0,450 450,660 660,870 870,1110 1110,1320
And so just came like
所以处理数据包，

2594
01:24:22,280 --> 01:24:24,050
0,420 420,870 870,930 930,1170 1170,1770
process packets,| the same speed
|可以获得没有备机相同的速度。

2595
01:24:24,050 --> 01:24:25,550
0,240 240,570 570,930 930,1230 1230,1500
as good without actually {backup

2596
01:24:25,550 --> 01:24:26,300
0,240
-}.|
|

2597
01:24:27,500 --> 01:24:28,880
0,210 210,540 540,960 960,1200 1200,1380
And therefore we should see
所以，我们会看到性能下降。

2598
01:24:28,880 --> 01:24:30,980
0,90 90,570 570,780 780,1590
a reduction in performance.|
|

2599
01:24:32,230 --> 01:24:33,490
0,480 480,630 630,990 990,1050 1050,1260
Nevertheless, this performance is pretty
尽管如此，性能还是相当令人印象深刻，

2600
01:24:33,490 --> 01:24:36,070
0,540 540,780 780,870 870,2280 2310,2580
impressive,| but you know there's
|但这是有性能代价的。

2601
01:24:36,070 --> 01:24:37,440
0,60 60,450 450,870
a performance cost.|
|

2602
01:24:37,500 --> 01:24:38,340
0,150 150,270 270,330 330,570 570,840
And this is one reason,|
这是一个原因，|

2603
01:24:38,340 --> 01:24:41,130
0,120 120,1410 1440,2100 2130,2430 2430,2790
that people play this game
人们不在指令层面上使用复制状态机，

2604
01:24:41,130 --> 01:24:42,570
0,420 420,630 630,990 990,1290 1290,1440
replicated state machines not at

2605
01:24:42,570 --> 01:24:44,490
0,300 300,840 840,1260 1260,1500 1500,1920
the instruction level,| but at
|而是在应用程序级别，

2606
01:24:44,490 --> 01:24:46,560
0,180 180,660 660,990 1050,1380 1560,2070
the application level,| and basically
|能够获得更高的性能，

2607
01:24:46,560 --> 01:24:47,610
0,120 120,270 270,330 330,630 750,1050
be able to get higher

2608
01:24:47,610 --> 01:24:50,220
0,810 900,1140 1140,1350 1350,2070 2070,2610
performance,| but that requires modification
|但这需要修改应用程序，

2609
01:24:50,220 --> 01:24:51,180
0,120 120,210 210,750 750,870 870,960
to the applications,| as we
|就像我们在 GFS 中看到的那样。

2610
01:24:51,180 --> 01:24:52,600
0,210 210,360 360,1020
saw in GFS.|
|

2611
01:24:56,380 --> 01:24:57,580
0,420 450,690 690,870 870,1020 1020,1200
Okay, I think I'm running
好的，我想我有点超时了，

2612
01:24:57,580 --> 01:24:58,270
0,60 60,240 240,330 330,480 480,690
a little bit over time,|
|

2613
01:24:58,270 --> 01:24:59,020
0,120 120,180 180,330 330,600 600,750
so I'm gonna stop right
所以我现在要停止了，

2614
01:24:59,020 --> 01:25:00,850
0,390 390,780 780,930 930,1260 1470,1830
now,| {} so I hope
|所以我希望需要离开的人已经离开了，

2615
01:25:00,850 --> 01:25:02,770
0,210 210,360 360,990 1350,1830 1830,1920
people that actually needed to

2616
01:25:02,770 --> 01:25:04,660
0,210 210,630 630,1170 1170,1680 1680,1890
leave already left,| {} but
|但我会留下来，

2617
01:25:04,660 --> 01:25:05,800
0,150 150,360 360,750 810,1050 1050,1140
I'll stick around,| and see
|看大家有更多的问题，

2618
01:25:05,800 --> 01:25:07,030
0,120 120,300 300,390 390,540 540,1230
if people have more questions,|
|

2619
01:25:07,030 --> 01:25:10,510
0,510 510,600 600,1290 1740,3270 3270,3480
I'll be happy to answer
我很乐意回答。

2620
01:25:10,510 --> 01:25:11,360
0,420
those.|
|

2621
01:25:12,550 --> 01:25:13,300
0,240 240,330 330,540 540,600 600,750
And I'll talk to you
我周二再跟你们讨论。

2622
01:25:13,300 --> 01:25:14,540
0,210 210,660
on Tuesday.|
|

2623
01:25:14,540 --> 01:25:15,480
0,150 150,390
Thank you.|
谢谢。|

2624
01:25:18,320 --> 01:25:20,030
0,510 780,960 960,1170 1170,1260 1260,1710
{} I had a question
我对之前的图像有一个问题，

2625
01:25:20,030 --> 01:25:23,570
0,330 330,660 720,1800 2010,2850 2940,3540
about the previous image, {}|
|

2626
01:25:23,660 --> 01:25:26,340
0,240 240,630 660,1380 1410,2160
that you drew with,
你画的那个，

2627
01:25:26,340 --> 01:25:28,170
0,210 210,690 720,1260 1290,1680 1680,1830
with the,| {} yeah that
|是的，就是那个，

2628
01:25:28,170 --> 01:25:30,480
0,360 420,1140 1500,1590 1590,1770 1770,2310
one,| {} I was confused
|我很困惑，因为，

2629
01:25:30,480 --> 01:25:31,620
0,630
because,|
|

2630
01:25:31,740 --> 01:25:33,720
0,390 390,660 840,990 990,1470 1470,1980
wasn't it the case that,|
不是这种情况，|如果那个数字 10 ，它停留在内存中，

2631
01:25:34,420 --> 01:25:36,160
0,300 300,690 720,1140 1140,1560 1560,1740
if that number 10, it

2632
01:25:36,160 --> 01:25:37,660
0,270 270,570 570,690 690,750 750,1500
just sits in the memory,|
|

2633
01:25:37,690 --> 01:25:39,520
0,480 480,600 600,810 810,930 930,1830
then we do an increment,|
然后我们做一个增加，|

2634
01:25:40,220 --> 01:25:41,360
0,210 210,450 450,690 690,810 810,1140
we don't need to send
我们不需要发送任何东西给备机，对吗。

2635
01:25:41,360 --> 01:25:42,720
0,810
anything

2636
01:25:42,780 --> 01:25:44,960
0,210 210,330 330,660 660,1620
to the {backup,right -}.|
|

2637
01:25:45,730 --> 01:25:46,780
0,390 390,570 570,690 690,900 900,1050
There, okay, so there's two
好的，这里有两件事，

2638
01:25:46,780 --> 01:25:48,070
0,300 300,540 540,870 870,1080 1080,1290
things going on here,| so
|所以我们看到，

2639
01:25:48,070 --> 01:25:49,360
0,210 210,390 390,660 660,900 900,1290
we do see,| at the
|在消息到达的时刻，

2640
01:25:49,390 --> 01:25:50,050
0,150 150,240 240,480 480,600 600,660
at the point that the

2641
01:25:50,050 --> 01:25:51,460
0,300 300,540 540,840 960,1200 1200,1410
message comes in,| like this
|比如来自客户端的这个增加，

2642
01:25:51,460 --> 01:25:53,160
0,540 540,750 750,1020
increment comes in

2643
01:25:53,380 --> 01:25:56,020
0,360 360,840 870,1530 1890,2490 2490,2640
from the client,| arrives at
|到达主机管理程序的 FT ，

2644
01:25:56,020 --> 01:25:59,260
0,480 810,1440 1440,1560 1560,2820 2850,3240
the FT at the hyper,

2645
01:25:59,260 --> 01:26:01,000
0,180 180,510 510,750 750,1200
the primary {hypervisor -},|
|

2646
01:26:01,150 --> 01:26:02,410
0,300 300,570 570,660 660,1110 1110,1260
it needs to forward that
它需要将该消息转发到备机 FT ，

2647
01:26:02,410 --> 01:26:06,070
0,420 420,1140 1230,2370 2400,2880 2880,3660
message to the backup FT,|
|

2648
01:26:06,070 --> 01:26:07,660
0,150 150,330 330,540 540,900 990,1590
so that it can process,|
这样它才能处理，|

2649
01:26:07,660 --> 01:26:09,070
0,540 540,900 900,960 960,1080 1080,1410
it needs to be processed
当它需要处理的时候，

2650
01:26:09,070 --> 01:26:09,610
0,150 150,210 210,360 360,420 420,540
when it needs to be

2651
01:26:09,610 --> 01:26:12,580
0,420 510,1170 1620,2010 2010,2460 2460,2970
processed,| when it processes exactly
|它处理这个指令流中的完全相同的点。

2652
01:26:12,580 --> 01:26:13,390
0,90 90,330 330,570 570,690 690,810
the same point in this

2653
01:26:13,390 --> 01:26:14,720
0,510 510,840
instruction stream,

2654
01:26:14,870 --> 01:26:15,820
0,450
right.|
|

2655
01:26:16,710 --> 01:26:17,850
0,300 300,420 420,660 660,750 750,1140
So it sends it off,|
所以它发送出去，|

2656
01:26:17,880 --> 01:26:19,080
0,150 150,540 540,600 600,780 780,1200
and then you know delivers
然后把它发送到主机，

2657
01:26:19,080 --> 01:26:20,220
0,120 120,240 240,330 330,810 900,1140
it to the primary,| and
|然后主机上线，做它自己的事情，

2658
01:26:20,220 --> 01:26:21,060
0,150 150,240 240,540 540,720 720,840
then the primary goes up

2659
01:26:21,060 --> 01:26:22,620
0,90 90,270 270,390 390,870 1020,1560
and does its thing,| primary
|主机回复一个消息，

2660
01:26:22,620 --> 01:26:23,970
0,120 120,600 630,1170 1170,1320 1320,1350
{you,know} may respond with a

2661
01:26:23,970 --> 01:26:25,740
0,600 960,1170 1170,1350 1350,1680 1680,1770
message,| and so if the
|所以，如果主机回复了一条消息，

2662
01:26:25,740 --> 01:26:27,120
0,270 270,660 660,810 810,840 840,1380
primary responds with a message,|
|

2663
01:26:27,150 --> 01:26:29,040
0,210 210,840 870,1230 1230,1380 1380,1890
the output of that message
消息输出会停止，

2664
01:26:29,070 --> 01:26:30,810
0,120 120,690 690,780 780,1020 1020,1740
is stop| or { -}
|或者直到备机确认这个增加的回复，

2665
01:26:30,810 --> 01:26:33,390
0,600 690,1530 1680,2010 2010,2100 2100,2580
hold until {} the backup

2666
01:26:33,390 --> 01:26:35,370
0,180 180,870 870,930 930,1680 1770,1980
as acknowledged the reception of

2667
01:26:35,370 --> 01:26:36,540
0,180 180,750
this increment,|
|

2668
01:26:39,860 --> 01:26:40,910
0,180 180,270 270,750 750,900 900,1050
which will ensure that if
这将确保如果备机必须接管，

2669
01:26:40,910 --> 01:26:41,870
0,150 150,510 510,660 660,750 750,960
the backup has to take

2670
01:26:41,870 --> 01:26:43,820
0,540 540,1290 1290,1440 1440,1560 1560,1950
over,| whatever it will process
|它会首先处理这个增加，

2671
01:26:43,820 --> 01:26:44,930
0,150 150,510 510,870 870,990 990,1110
that increment first,| and it
|它也会是 11 ，在发送回复之前。

2672
01:26:44,930 --> 01:26:46,640
0,210 210,420 420,600 600,1080
also will be 11

2673
01:26:46,640 --> 01:26:48,560
0,540 540,1020 1020,1350
before response sent.|
|

2674
01:26:52,140 --> 01:26:55,400
0,720 1050,2010 2010,2310 2310,2580
Okay, okay, thank you.|
好的，好的，谢谢。|

2675
01:26:55,430 --> 01:26:57,710
0,450 960,1140 1140,1800 1800,2160 2160,2280
{ -} One thing I'm
我搞不懂的一件事是，

2676
01:26:57,710 --> 01:26:59,300
0,420 420,660 660,810 810,1110 1110,1590
confused about is,| is the
|系统的目标是帮助提高服务器的性能吗，

2677
01:26:59,300 --> 01:27:01,220
0,510 510,660 660,810 810,1320 1320,1920
goal of the system to

2678
01:27:01,930 --> 01:27:03,700
0,630 900,1050 1050,1350 1350,1530 1530,1770
{} to help with like

2679
01:27:03,700 --> 01:27:05,320
0,360 360,690 720,840 840,1200 1200,1620
bucking up an actual server,|
|

2680
01:27:05,320 --> 01:27:07,390
0,480 660,1500 1500,1650 1650,1860 1860,2070
where because it's not easy
因为在没有管理程序的情况下处理中断并不简单，

2681
01:27:07,390 --> 01:27:09,250
0,150 150,450 450,540 540,1170 1560,1860
to handle the interrupt {}

2682
01:27:09,250 --> 01:27:10,720
0,300 300,360 360,690 690,1020 1020,1470
without a {hypervisor -}| or
|或者它是为了帮助分发虚拟机本身。

2683
01:27:10,900 --> 01:27:12,490
0,180 180,270 270,720 720,1110 1110,1590
is it actually to help

2684
01:27:13,040 --> 01:27:16,200
0,990 990,1620 1620,1950 1950,2640
distribute virtual machines themselves.|
|

2685
01:27:16,350 --> 01:27:17,670
0,180 180,330 330,870 870,1050 1050,1320
And it's purely to make
它纯粹是为了让应用程序，

2686
01:27:17,670 --> 01:27:18,660
0,90 90,300 330,750 750,870 870,990
an app,| like you have
|比如你有一个在一台机器上运行的业务应用程序，

2687
01:27:18,660 --> 01:27:20,010
0,60 60,360 360,990 990,1140 1140,1350
a business application that runs

2688
01:27:20,010 --> 01:27:21,660
0,90 90,300 300,600 600,1080 1500,1650
on a single machine,| and
|你想让它具有更强的容错性，

2689
01:27:21,660 --> 01:27:22,110
0,90 90,210 210,270 270,390 390,450
you want to make it

2690
01:27:22,110 --> 01:27:23,500
0,180 180,360 360,900
more fault tolerance,|
|

2691
01:27:23,500 --> 01:27:26,200
0,810 810,1410 1440,2100 2130,2550 2550,2700
and {} the what this
而这一方案的作用是，

2692
01:27:26,200 --> 01:27:27,400
0,240 240,600 600,840 840,990 990,1200
scheme does is,| it makes
|它透明地为你提供容错功能，

2693
01:27:27,400 --> 01:27:29,260
0,120 120,600 600,840 840,1020 1110,1860
it {fault,tolerance} for you transparently,|
|

2694
01:27:30,140 --> 01:27:31,640
0,330 330,510 510,600 600,900 900,1500
you run the business applications
你在 FT 虚拟机管理程序上运行业务应用程序和虚拟机，

2695
01:27:31,640 --> 01:27:32,960
0,300 300,570 570,990 990,1260 1260,1320
and both machines on the

2696
01:27:32,960 --> 01:27:34,790
0,480 480,660 660,990 990,1290 1290,1830
on the FT {hypervisor -}|
|

2697
01:27:34,940 --> 01:27:36,440
0,240 240,660 660,930 930,1350 1350,1500
and FT {hypervisor -} will
FT 管理程序将确保，

2698
01:27:36,440 --> 01:27:37,700
0,540 540,690 690,810 810,930 930,1260
ensure that,| you know basically
|这些应用程序不是按字面意思同步运行，

2699
01:27:37,700 --> 01:27:39,260
0,180 180,780 780,1020 1020,1080 1080,1560
these applications more or less

2700
01:27:39,260 --> 01:27:41,060
0,240 240,630 630,1200 1200,1440 1440,1800
not literally running {lockstep -},|
|

2701
01:27:41,090 --> 01:27:43,460
0,180 180,720 720,1020 1800,2160
but basically you know
基本上是容错复制的。

2702
01:27:44,000 --> 01:27:46,260
0,390 390,1080 1080,1680
{} {fault,tolerance} replicated.|
|

2703
01:27:46,820 --> 01:27:47,990
0,240 240,390 390,780 780,1050 1050,1170
So the VM using the
所以，使用虚拟机本身在某种程度上是一个设计决策。

2704
01:27:47,990 --> 01:27:49,010
0,270 270,630 630,720 720,930 930,1020
VM itself is kind of

2705
01:27:49,010 --> 01:27:51,080
0,60 60,390 390,840 960,1560
a design decision.| Yes,
|是的，这是一个很好的设计决策，

2706
01:27:51,200 --> 01:27:52,580
0,150 150,840 840,1110 1110,1200 1200,1380
and that is a good

2707
01:27:52,580 --> 01:27:54,560
0,270 270,690 690,1200 1350,1860 1860,1980
design decision,| because {it,allows} you
|因为它允许你在透明级别执行复制。

2708
01:27:54,560 --> 01:27:55,880
0,60 60,240 240,450 450,1170 1170,1320
to do this replication at

2709
01:27:55,880 --> 01:27:57,440
0,180 180,660 660,1020
a transparent level.|
|

2710
01:27:57,650 --> 01:27:58,580
0,210 210,360 360,570 570,630 630,930
Got it, thanks so much.|
明白了，非常感谢。|

2711
01:27:59,200 --> 01:28:00,220
0,480
{You're,welcome}.|
不客气。|

2712
01:28:02,730 --> 01:28:03,870
0,420 420,510 510,900 900,990 990,1140
Yeah, the question in the
是的，聊天中的问题，

2713
01:28:03,870 --> 01:28:05,640
0,240 240,480 480,660 660,990 990,1770
chat,| about can be a
|关于输出规则，

2714
01:28:05,850 --> 01:28:06,810
0,240 240,510 510,780 780,900 900,960
the output rule,| is it
|客户端是否可能看到相同的响应两次。

2715
01:28:06,810 --> 01:28:07,800
0,360 360,450 450,510 510,810 810,990
possible that the client sees

2716
01:28:07,800 --> 01:28:08,940
0,90 90,360 360,720 720,1050 1050,1140
the same response twice.| And
|答案是肯定的，

2717
01:28:08,940 --> 01:28:10,180
0,60 60,240 240,300 300,780
the answer is yes,|
|

2718
01:28:10,600 --> 01:28:11,920
0,180 180,420 420,810 810,1170 1170,1320
{} it's absolutely possible,| that
这是可能的，|客户端完全有可能收到两次回复，

2719
01:28:11,920 --> 01:28:12,700
0,90 90,420 420,510 510,660 660,780
the client will see you

2720
01:28:12,700 --> 01:28:15,310
0,210 210,810 840,1380 1380,2010 2340,2610
get the response twice, {}|
|

2721
01:28:15,310 --> 01:28:16,960
0,300 300,690 690,870 870,960 960,1650
and basically what they argue
他们说是可以的，

2722
01:28:17,140 --> 01:28:19,540
0,390 390,720 720,1530 1680,2070 2070,2400
{} that's okay,| {} because
|因为在网络的容错模型中，

2723
01:28:19,540 --> 01:28:20,380
0,210 210,420 420,510 510,630 630,840
in sort of the fault

2724
01:28:20,380 --> 01:28:21,640
0,300 300,570 570,660 660,750 750,1260
tolerant model of the network,|
|

2725
01:28:21,670 --> 01:28:23,110
0,180 180,300 300,720 720,840 840,1440
it is always {assumed -}
总是假设网络可能重复消息，

2726
01:28:23,110 --> 01:28:24,490
0,330 330,630 630,720 720,960 960,1380
the network can actually duplicate

2727
01:28:24,490 --> 01:28:26,830
0,420 420,930 1350,1530 1530,1830 1830,2340
messages anyway,| and so protocols
|所以，像 TCP 这样的协议完全是为处理重复消息而设计的。

2728
01:28:26,830 --> 01:28:29,050
0,180 180,1050 1140,1320 1320,1650 1650,2220
like TCP are totally designed

2729
01:28:29,080 --> 01:28:30,520
0,180 180,450 450,540 540,870 870,1440
to deal with duplicate messages.|
|

2730
01:28:32,180 --> 01:28:34,070
0,690 720,1200 1230,1410 1410,1620 1620,1890
So yes, it's okay, because
所以，是的，因为 TCP ，

2731
01:28:34,070 --> 01:28:35,180
0,240 240,570
{TCP -},|
|

2732
01:28:35,430 --> 01:28:37,020
0,300 300,1020
or whatever
或任何复制方案，

2733
01:28:37,020 --> 01:28:39,360
0,630 660,1320 1320,1830 1830,2250 2250,2340
{} replication duplication scheme,| the
|应用程序使用，客户端使用的。

2734
01:28:39,360 --> 01:28:41,010
0,570 570,990 990,1230 1230,1290 1290,1650
application uses, where the client

2735
01:28:41,010 --> 01:28:41,940
0,420
uses.|
|

2736
01:28:42,950 --> 01:28:44,390
0,360 450,660 660,930 930,1230 1230,1440
I was curious about {}
我对[]问题很好奇，

2737
01:28:44,390 --> 01:28:46,490
0,450 450,1020 1050,1470 1470,1680 1680,2100
[] question,| which is {}
|比如主机停机了几分钟，

2738
01:28:46,850 --> 01:28:48,890
0,750 750,1110 1260,1530 1530,1740 1740,2040
primary like sort of goes

2739
01:28:48,890 --> 01:28:50,030
0,210 210,360 360,420 420,600 600,1140
down for a few minutes,|
|

2740
01:28:50,600 --> 01:28:53,870
0,720 810,1200 1200,1710 1740,2490 2850,3270
backup goes live,| then sets
备机开始运行，|然后建立自己的备机，

2741
01:28:53,870 --> 01:28:55,760
0,540 570,840 840,1140 1140,1710 1710,1890
up its {} its own

2742
01:28:55,760 --> 01:28:57,760
0,570 870,1020 1020,1470
backup,| you know
|把标志位换回 0 ，

2743
01:28:57,790 --> 01:29:00,730
0,690 690,900 900,1440 1470,1920 1920,2940
switches the bit back to

2744
01:29:00,760 --> 01:29:03,700
0,750 1050,1320 1320,1500 1500,2220 2250,2940
0,| and then suddenly somehow
|然后突然第一个主机又回来了，

2745
01:29:03,700 --> 01:29:04,940
0,630
the

2746
01:29:04,940 --> 01:29:06,980
0,690 750,1470
first primary

2747
01:29:07,170 --> 01:29:08,610
0,270 270,540 540,870 870,1170 1170,1440
goes back,| like goes back.|
|比如，回来。|

2748
01:29:08,610 --> 01:29:09,570
0,420 420,600 600,750 750,810 810,960
Yeah, I think we're going
是的，我想我们会有这种情况，

2749
01:29:09,570 --> 01:29:10,650
0,90 90,210 210,720 720,870 870,1080
to have {the,case},| that first
|第一个主机肯定会被终止，

2750
01:29:10,650 --> 01:29:12,210
0,270 270,360 360,810 810,1410 1410,1560
primary is definitely terminated,| it's
|它被清理干净，然后就消失了。

2751
01:29:12,210 --> 01:29:15,380
0,360 360,720 1470,2010 2040,2580
cleaned up and gone.|
|

2752
01:29:15,410 --> 01:29:17,440
0,690 900,1410
Hmm, nice,
嗯，好的，谢谢。

2753
01:29:18,590 --> 01:29:20,000
0,720
thanks.|
|

2754
01:29:21,860 --> 01:29:23,510
0,120 120,540 540,900 1140,1380 1380,1650
To ask a question something
问一个类似的问题，

2755
01:29:23,510 --> 01:29:24,920
0,720 720,870 870,960 960,1080 1080,1410
similar,| may be too broad
|可能是个过于宽泛的问题，

2756
01:29:24,920 --> 01:29:26,090
0,510 510,690 690,960 960,1050 1050,1170
question,| but like will you
|你是否需要保存更多东西，

2757
01:29:26,090 --> 01:29:27,980
0,150 150,300 300,420 420,1170 1230,1890
ever need to store more

2758
01:29:27,980 --> 01:29:31,040
0,720 720,1170 1170,1350 1350,2190 2490,3060
things| besides an arbitration flag
|除了仲裁标志和服务器之外，

2759
01:29:31,040 --> 01:29:32,540
0,150 150,210 210,960 960,1140 1140,1500
and the server,| I mean
|我的意思是除了仲裁服务器标志位之外，

2760
01:29:33,170 --> 01:29:34,730
0,480 480,540 540,840 840,930 930,1560
besides the flag an arbitration

2761
01:29:34,730 --> 01:29:37,100
0,1050 1830,2010 2010,2070 2070,2190 2190,2370
server,| if you have like
|如果你有多个备机。

2762
01:29:37,100 --> 01:29:39,700
0,960 1080,2040
multiple like

2763
01:29:39,820 --> 01:29:42,610
0,1020 1710,1890 1890,2190 2190,2550 2550,2790
backups.| Oh yeah, like {}
|是的，这是一个方案[]对于一个备机，

2764
01:29:42,610 --> 01:29:43,930
0,330 330,420 420,480 480,900 900,1320
this is a scheme []

2765
01:29:43,930 --> 01:29:45,400
0,360 360,480 480,750 750,1200 1200,1470
to at one backup,| not
|不会超过一个备机，

2766
01:29:45,400 --> 01:29:46,360
0,150 150,270 270,450 450,840 840,960
more than one backup,| so
|所以如果你有更多的备机，

2767
01:29:46,360 --> 01:29:47,320
0,90 90,180 180,330 330,570 570,960
if you had more backups,|
|

2768
01:29:47,320 --> 01:29:49,760
0,60 60,240 240,690 690,1560
you know, you know,
我们还有其他问题需要解决，

2769
01:29:49,980 --> 01:29:51,060
0,330 330,540 540,900 900,990 990,1080
there's other issues that we

2770
01:29:51,060 --> 01:29:52,020
0,120 120,210 210,630 630,720 720,960
need to resolve,| in fact
|事实上，我们将在周二回到这个问题上，

2771
01:29:52,020 --> 01:29:53,250
0,390 390,540 540,870 870,990 990,1230
we'll come back to this,

2772
01:29:53,250 --> 01:29:54,330
0,120 120,630 630,780 780,900 900,1080
on Tuesday,| you know with
|使用更复杂的协议，

2773
01:29:54,330 --> 01:29:56,520
0,180 180,780 780,1350 1350,1560 1560,2190
more sophisticated protocols,| that handle
|更干净地处理这些情况。

2774
01:29:56,520 --> 01:29:58,180
0,240 240,510 510,690 690,1050
those cases much cleaner.|
|

2775
01:29:58,440 --> 01:30:00,030
0,480 810,1170 1170,1200 1200,1320 1320,1590
Okay, {} that was just
好的，这太酷了，谢谢。

2776
01:30:00,030 --> 01:30:02,160
0,270 270,600 780,1020 1020,1200
perfect cool, thank you.|
|

2777
01:30:04,100 --> 01:30:05,360
0,180 180,390 390,600 600,930 930,1260
I have one question about
我有一个关于性能的问题，

2778
01:30:05,360 --> 01:30:07,600
0,90 90,1050
the performance,|
|

2779
01:30:07,600 --> 01:30:08,980
0,420 420,990 1020,1170 1170,1260 1260,1380
{} so can you go
所以你能回到那个表格吗？

2780
01:30:08,980 --> 01:30:10,990
0,240 240,540 540,990 990,1590 1650,2010
back to that table?| Yes,
|好的，我的问题是，

2781
01:30:10,990 --> 01:30:12,790
0,180 180,540 540,960 1260,1500 1500,1800
my question is,| is it
|是不是只在第一个数据包上才能看到延迟，

2782
01:30:12,820 --> 01:30:14,830
0,240 240,780 780,1200 1200,1380 1380,2010
the delay only be viewed

2783
01:30:14,830 --> 01:30:16,240
0,270 270,420 420,720 720,1170 1170,1410
on the first packet,| like
|在第一个数据包之后，

2784
01:30:16,240 --> 01:30:17,380
0,330 330,450 450,690 690,1020 1020,1140
after the first packet,| it
|它只会流过通道，

2785
01:30:17,380 --> 01:30:19,180
0,150 150,480 480,900 900,1590 1590,1800
will just flow through the

2786
01:30:19,180 --> 01:30:20,860
0,450 450,630 630,900 900,1080 1080,1680
channel,| and there's no extra
|链路上没有额外的延迟，

2787
01:30:21,070 --> 01:30:23,500
0,690 690,1110 1140,1410 1410,1980 2010,2430
delay on the link,| so
|所以，带宽应该大致相同，或者不是。

2788
01:30:23,500 --> 01:30:24,850
0,150 150,570 570,780 780,930 930,1350
the bandwidth should be roughly

2789
01:30:24,850 --> 01:30:26,980
0,150 150,600 600,900 900,1530 1530,2130
the same, or no.| No,
|不是，对于主机接收到的每个数据包，

2790
01:30:26,980 --> 01:30:28,480
0,270 270,420 420,660 660,960 960,1500
okay for every packet received

2791
01:30:28,480 --> 01:30:29,860
0,330 330,450 450,690 690,1290 1290,1380
correctly by the primary,| you
|数据包必须被转发到备机，

2792
01:30:29,860 --> 01:30:30,700
0,120 120,300 300,600 600,750 750,840
know that packet has to

2793
01:30:30,700 --> 01:30:32,170
0,180 180,690 690,810 810,900 900,1470
be forwarded to the backup,|
|

2794
01:30:33,040 --> 01:30:34,360
0,300 300,510 510,1110 1110,1200 1200,1320
for every response you know
对于每个响应，备机等待，

2795
01:30:34,360 --> 01:30:35,470
0,330 330,420 420,510 510,780 780,1110
{backup -} the left wait|
|

2796
01:30:35,500 --> 01:30:36,160
0,120 120,180 180,450 450,570 570,660
for the primary has to
主机必须等待，

2797
01:30:36,160 --> 01:30:37,630
0,210 210,600 600,810 810,1170 1170,1470
wait| until the output rule
|直到满足输出规则，

2798
01:30:37,630 --> 01:30:39,040
0,90 90,780 780,1170 1170,1260 1260,1410
is satisfied,| then it can
|然后它就可以发送响应。

2799
01:30:39,040 --> 01:30:40,120
0,240 240,300 300,810
send a response.|
|

2800
01:30:41,850 --> 01:30:44,190
0,390 390,540 540,810 810,1560 1620,2340
{} So there's some lag
所以在备机上会有一些延迟处理，

2801
01:30:44,250 --> 01:30:46,680
0,660 660,870 870,960 960,1890 1980,2430
processing on the backups,| backup
|在返回到主机之前。

2802
01:30:46,680 --> 01:30:48,600
0,390 390,870 900,1380 1380,1680 1680,1920
server to before getting back

2803
01:30:48,600 --> 01:30:49,890
0,270 270,420 420,780 780,1110 1110,1290
to the primary.| Yeah, so
|是的，他们稍微讨论了一下，

2804
01:30:49,890 --> 01:30:50,820
0,270 270,510 510,570 570,780 780,930
they talk a little bit

2805
01:30:50,820 --> 01:30:52,140
0,240 240,390 390,810 810,990 990,1320
about that, correctly,| the particular
|需要完成的处理是，

2806
01:30:52,140 --> 01:30:52,980
0,360 360,480 480,660 660,750 750,840
processing that needs to be

2807
01:30:52,980 --> 01:30:54,870
0,240 240,390 390,690 690,1320 1320,1890
done is,| actually acknowledging the
|确认在日志通道上数据包的接收。

2808
01:30:54,900 --> 01:30:56,820
0,810 810,900 900,990 990,1500 1590,1920
reception of the packet on

2809
01:30:56,820 --> 01:30:58,260
0,240 240,570 570,960
the logging channel.|
|

2810
01:30:58,320 --> 01:30:59,250
0,300 300,480 480,690 690,750 750,930
And they talk a little
他们还谈了一些如何减少延迟，

2811
01:30:59,250 --> 01:31:01,290
0,180 180,660 660,960 960,1500 1500,2040
bit about how to reduce

2812
01:31:01,290 --> 01:31:02,940
0,120 120,870 1170,1290 1290,1440 1440,1650
the delay| to make sure
|以确保这种确认是非常迅速的。

2813
01:31:02,940 --> 01:31:04,560
0,360 390,720 720,930 930,1020 1020,1620
that {} sort of acknowledgment

2814
01:31:04,560 --> 01:31:05,760
0,90 90,300 300,690
is very quick.|
|

2815
01:31:06,700 --> 01:31:08,650
0,450 450,750 750,930 930,1290 1500,1950
I see, I see okay,
我明白了，好的，谢谢。

2816
01:31:08,650 --> 01:31:10,600
0,360 360,660 870,1170 1620,1860 1860,1950
thank you.| I have a
|我有一个关于日志通道的问题，

2817
01:31:10,600 --> 01:31:12,610
0,360 360,600 600,870 900,1470 1470,2010
question about the logging channel,|
|

2818
01:31:12,640 --> 01:31:13,960
0,270 270,540 540,750 750,1140 1140,1320
so they they mentioned that
所以他们提到他们使用的 UDP ，

2819
01:31:13,960 --> 01:31:16,810
0,420 840,1140 1140,1920 1950,2490 2700,2850
they use UDP,| and I
|我想这主要是为了性能，

2820
01:31:16,810 --> 01:31:18,670
0,300 300,600 600,900 900,1050 1050,1860
assume that's mostly for performance,|
|

2821
01:31:19,000 --> 01:31:21,310
0,330 330,900 990,1560 1590,2130 2130,2310
but then so basically if
但是，如果发生一次故障，

2822
01:31:21,310 --> 01:31:23,170
0,240 240,630 630,990 990,1620 1620,1860
a single failure happens, the

2823
01:31:23,170 --> 01:31:24,300
0,690
primary,|
|

2824
01:31:24,360 --> 01:31:25,710
0,240 240,300 300,690 690,1200 1200,1350
if a single packet is
如果单个数据包未被确认，

2825
01:31:25,710 --> 01:31:27,900
0,360 360,1140 1410,1590 1590,1680 1680,2190
{unacknowledged -},| then it assumes
|然后，它假设备机失败，

2826
01:31:27,900 --> 01:31:29,880
0,210 210,420 420,870 870,1320 1590,1980
that the backup failed,| without
|没有任何重播。

2827
01:31:29,880 --> 01:31:32,130
0,150 150,390 390,1200 1410,1770 1770,2250
any like retransmission.| No, no,
|不，不，是的，因为有计时器中断，

2828
01:31:32,160 --> 01:31:34,380
0,540 540,1590 1590,1860 1860,2160 2160,2220
{} yeah, because there's a

2829
01:31:34,380 --> 01:31:35,660
0,330 330,840
timer interrupt,|
|

2830
01:31:35,690 --> 01:31:37,370
0,690 690,930 930,1020 1020,1320 1320,1680
{} and the timer interrupt
定时器中断大约每 10 毫秒或更长时间触发一次，

2831
01:31:37,370 --> 01:31:38,330
0,180 180,390 390,540 540,780 780,960
goes off like every ten

2832
01:31:38,330 --> 01:31:41,510
0,510 510,570 570,960 1350,1980 1980,3180
milliseconds or something,| {} there's
|总是有多个数据包，

2833
01:31:41,510 --> 01:31:43,580
0,630 630,780 780,1140 1140,1470 1770,2070
always {} multiple packet,| one
|发送一个数据包，

2834
01:31:43,580 --> 01:31:44,960
0,330 330,690 690,840 840,1110 1110,1380
packet sent,| that packet doesn't
|那个数据包不会收到任何心跳，

2835
01:31:44,960 --> 01:31:47,120
0,330 330,1110 1140,1500 1500,1920 1920,2160
get {} no heartbeat coming

2836
01:31:47,120 --> 01:31:48,830
0,450 780,1290 1290,1470 1470,1590 1590,1710
back,| then it will do
|然后它会中断几次这样的时间，

2837
01:31:48,830 --> 01:31:49,940
0,90 90,540 570,690 690,840 840,1110
a couple of these time

2838
01:31:49,940 --> 01:31:51,170
0,450 450,750 750,810 810,990 990,1230
interrupt,| before it gives up.|
|在它放弃之前。|

2839
01:31:52,000 --> 01:31:54,960
0,450 450,870 900,1380 1410,2430
Okay, and the heartbeats,
好的，心跳是从主机开始[]的吗，

2840
01:31:54,990 --> 01:31:56,370
0,180 180,540 570,930 930,1170 1170,1380
are they [] from the

2841
01:31:56,370 --> 01:31:58,260
0,540 540,1050 1350,1440 1440,1560 1560,1890
primary| or it was going
|或者它将从系统中的其他地方应用它。

2842
01:31:58,260 --> 01:31:59,370
0,60 60,270 270,660 660,780 780,1110
to apply it from somewhere

2843
01:31:59,370 --> 01:32:00,780
0,210 210,330 330,390 390,900 1050,1410
else in the system.| Well,
|好的，它们从某种程度上来说来自定时器，

2844
01:32:00,780 --> 01:32:01,620
0,270 270,480 480,540 540,720 720,840
they sort of come from

2845
01:32:01,620 --> 01:32:02,790
0,90 90,300 300,630 690,810 810,1170
the timer,| when the heartbeat
|心跳是间接的作用，

2846
01:32:02,790 --> 01:32:04,620
0,330 330,870 870,1170 1170,1620 1620,1830
{} basically an indirect side

2847
01:32:04,620 --> 01:32:06,750
0,720 720,1230 1230,1470 1470,1650 1650,2130
effect,| because every ten milliseconds,|
|因为每隔 10 毫秒，|

2848
01:32:06,750 --> 01:32:07,620
0,90 90,210 210,420 420,510 510,870
you're gonna send an interrupt
你会通过日志通道发送一条中断消息。

2849
01:32:07,620 --> 01:32:09,060
0,330 330,630 630,810 810,1140 1140,1440
message to the over logging

2850
01:32:09,060 --> 01:32:10,200
0,270 270,660
channel anyway.|
|

2851
01:32:12,440 --> 01:32:14,440
0,210 210,630 900,1620
I see, okay.|
我明白了，好的。|

2852
01:32:16,020 --> 01:32:18,120
0,570 600,870 870,1140 1470,1710 1710,2100
Alright, thank you.| You're welcome.|
好的，谢谢。|不用谢。|

2853
01:32:21,570 --> 01:32:22,920
0,570 570,690 690,930 930,1020 1020,1350
Actually I wanted to follow
我想要跟进这件事，

2854
01:32:22,920 --> 01:32:24,210
0,180 180,300 300,570 570,930 990,1290
up on that,| I think
|我想它说的是要等几秒钟。

2855
01:32:24,210 --> 01:32:25,530
0,120 120,420 420,690 870,1080 1080,1320
it said that it's gonna

2856
01:32:25,530 --> 01:32:27,120
0,450 600,780 780,1080 1080,1380 1380,1590
wait a couple a few

2857
01:32:27,120 --> 01:32:28,420
0,840
seconds.|
|

2858
01:32:28,450 --> 01:32:30,130
0,630 1050,1230 1230,1320 1320,1410 1410,1680
Yeah, yeah, it can wait
是的，可以等待一段时间，

2859
01:32:30,130 --> 01:32:31,090
0,60 60,450 450,540 540,810 810,960
a while,| you know they
|他们会做几次心跳，然后等一段时间，

2860
01:32:31,090 --> 01:32:31,990
0,90 90,180 180,360 360,420 420,900
do a couple of heartbeats

2861
01:32:31,990 --> 01:32:32,980
0,180 180,360 360,420 420,840 840,990
and wait a while,| and
|如果没有一个能通过，

2862
01:32:32,980 --> 01:32:33,790
0,180 180,330 330,510 510,720 720,810
if they're really, none of

2863
01:32:33,790 --> 01:32:35,020
0,150 150,390 390,900 930,1140 1140,1230
them come through,| then it
|然后它就会停止。

2864
01:32:35,020 --> 01:32:36,040
0,90 90,510
will stop.|
|

2865
01:32:36,590 --> 01:32:38,750
0,630 780,1170 1170,1350 1350,1980 1980,2160
Okay, and is a few
好的，几秒钟够多了吧。

2866
01:32:38,750 --> 01:32:40,610
0,510 510,1080 1080,1170 1170,1500 1500,1860
seconds that's a lot, right.|
|

2867
01:32:41,180 --> 01:32:42,350
0,330 330,690 690,930 930,1080 1080,1170
{I,don't} remember exactly all the
我记不清所有的数字了，

2868
01:32:42,350 --> 01:32:43,490
0,450 510,840 840,960 960,1050 1050,1140
numbers,| so you could be
|所以可能是几秒钟，

2869
01:32:43,490 --> 01:32:44,480
0,210 210,330 330,390 390,570 570,990
right in a few seconds,|
|

2870
01:32:44,480 --> 01:32:45,500
0,150 150,360 360,870 870,930 930,1020
I would imagine a bit
我想可能会短一点，但也许不是。

2871
01:32:45,500 --> 01:32:46,610
0,330 330,480 480,690 690,810 810,1110
shorter, but maybe it's not.|
|

2872
01:32:47,250 --> 01:32:49,560
0,1140 1170,1530 1530,1620 1620,1800 1800,2310
I think, I'd like something
我想几秒钟左右的东西，

2873
01:32:49,590 --> 01:32:50,670
0,210 210,300 300,750 750,960 960,1080
in the order of a

2874
01:32:50,670 --> 01:32:52,380
0,150 150,720 720,1110
few seconds,| but
|但它是坏的吗？

2875
01:32:52,580 --> 01:32:53,930
0,180 180,390 390,900 930,1110 1110,1350
is it bad?| {} {That
|复制的时间要更长，

2876
01:32:53,930 --> 01:32:55,040
0,90 90,630 630,930 930,1020 1020,1110
-} much longer for the

2877
01:32:55,040 --> 01:32:56,540
0,840
cloning,|
|

2878
01:32:56,870 --> 01:32:58,130
0,360 390,570 570,900 930,1080 1080,1260
but you know I can't
但我记不起来了。

2879
01:32:58,130 --> 01:32:59,755
0,810 810,1020 1020,1530
remember it like.
