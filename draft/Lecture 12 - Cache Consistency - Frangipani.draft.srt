1
00:00:01,280 --> 00:00:03,860
0,390 390,1020 1050,1590 1770,2100 2100,2580
Okay, {} so good morning,
好的，早上好，下午好，晚上好，不管你在哪里，

2
00:00:03,890 --> 00:00:05,690
0,270 270,960 960,1110 1110,1320 1320,1800
good afternoon or good evening

3
00:00:05,690 --> 00:00:07,520
0,240 240,630 630,780 780,1140 1680,1830
or wherever you are,| and
|我说过今天的计划是谈论蛋黄，

4
00:00:07,520 --> 00:00:08,480
0,180 180,360 360,540 540,840 840,960
I said the plan for

5
00:00:08,480 --> 00:00:09,980
0,480 750,900 900,990 990,1200 1200,1500
today is to talk about

6
00:00:09,980 --> 00:00:11,570
0,270 270,570 570,1080 1140,1380 1380,1590
the {Frangipani -},| {} this
|这是一篇1997年的论文，

7
00:00:11,570 --> 00:00:13,520
0,120 120,210 210,570 570,1080 1470,1950
is a paper from {}

8
00:00:13,550 --> 00:00:15,590
0,810 810,1410 1410,1530 1530,1710 1740,2040
1997,| so it's a bit
|所以这是一份有点老的报纸，

9
00:00:15,590 --> 00:00:16,780
0,120 120,210 210,510 510,1020
of an older paper,|
|

10
00:00:17,240 --> 00:00:18,500
0,330 330,450 450,990 990,1080 1080,1260
{} the context of this
本文的研究背景是网络文件系统，

11
00:00:18,500 --> 00:00:21,230
0,870 930,1410 1410,1740 1740,2010 2010,2730
paper is network file systems,|
|

12
00:00:29,510 --> 00:00:30,470
0,450 450,570 570,660 660,840 840,960
and you know you should
你知道，你应该考虑像雅典娜AFS这样的系统

13
00:00:30,470 --> 00:00:31,910
0,150 150,420 420,810 810,1080 1080,1440
think about systems such as

14
00:00:31,910 --> 00:00:33,260
0,150 150,450 450,720 720,1080 1080,1350
you know {Athena -} {AFS

15
00:00:33,260 --> 00:00:34,820
0,450 750,900 900,1020 1020,1260 1260,1560
-}| {that,you,know} the file system
|你知道雅典娜Dropbox的文件系统，

16
00:00:34,820 --> 00:00:38,000
0,90 90,660 960,1500 1500,2460 2490,3180
at Athena {} dropbox,| a
|一个更现代的版本，

17
00:00:38,030 --> 00:00:39,650
0,510 510,900 900,1170 1170,1260 1260,1620
more modern version of this,|
|

18
00:00:40,040 --> 00:00:41,840
0,690 690,780 780,1200 1200,1470 1470,1800
but the general goal here
但这里的总体目标是

19
00:00:41,840 --> 00:00:43,010
0,120 120,210 210,600 600,840 840,1170
is| to basically share files
|基本上是在一组用户之间共享文件。

20
00:00:43,010 --> 00:00:44,750
0,510 540,810 810,1140 1140,1230 1230,1740
between a collection of users.|
|

21
00:00:45,520 --> 00:00:48,610
0,570 870,1260 1260,1530 1530,2340 2370,3090
{} {Frangipani -} itself {}
蛋黄本身，你知道它并没有被广泛使用

22
00:00:48,610 --> 00:00:49,600
0,180 180,240 240,360 360,600 600,990
you know it's not widely

23
00:00:49,600 --> 00:00:51,400
0,540 630,900 900,1200 1200,1500 1500,1800
used| or wasn't widely used
|或者在甲板外并没有被广泛使用。

24
00:00:51,400 --> 00:00:53,410
0,330 330,420 420,720 720,1230 1410,2010
outside of the deck {}.|
|

25
00:00:53,410 --> 00:00:54,760
0,240 240,360 360,480 480,780 780,1350
And so the real focus
所以今天你应该从这篇文章中得到的真正的焦点是三个想法

26
00:00:54,880 --> 00:00:56,110
0,450 570,750 750,960 960,1140 1140,1230
of the things you should

27
00:00:56,110 --> 00:00:56,890
0,180 180,300 300,360 360,510 510,780
get out of this paper

28
00:00:56,890 --> 00:01:00,910
0,570 840,1620 1680,2520 2550,3540 3540,4020
today are three ideas| and
|而这些想法实际上将在未来几周内反复出现。

29
00:01:00,910 --> 00:01:02,380
0,420 420,600 600,990 990,1200 1200,1470
ideas that actually will show

30
00:01:02,380 --> 00:01:03,520
0,210 240,540 540,660 660,990 990,1140
up over and over in

31
00:01:03,520 --> 00:01:04,570
0,90 90,570 570,660 660,840 840,1050
a couple of, next couple

32
00:01:04,570 --> 00:01:05,920
0,60 60,510 750,1200 1200,1260 1260,1350
of weeks.| First of all
|首先，高速缓存一致性，

33
00:01:05,920 --> 00:01:07,900
0,330 330,1080
cache coherence,|
|

34
00:01:08,800 --> 00:01:12,280
0,690 690,810 810,1080 1080,1890
protocols for cache coherence,|
用于高速缓存一致性的协议，|

35
00:01:13,310 --> 00:01:17,000
0,330 330,840 840,1290 1290,1860
{} second, distributed locking,
第二，分布式锁定，第三，分布式崩溃恢复。

36
00:01:23,430 --> 00:01:26,580
0,270 270,540 540,1710 1950,2460 2460,3150
and third, distributed crash recovery.|
|

37
00:01:32,830 --> 00:01:33,970
0,270 270,510 510,660 660,900 900,1140
And these are gonna be
这将是三个想法，

38
00:01:33,970 --> 00:01:35,200
0,210 210,570 570,660 660,810 810,1230
three ideas,| are gonna be
|就像我提到的那样，在接下来的几周里，

39
00:01:35,200 --> 00:01:36,310
0,150 150,600 600,780 780,930 930,1110
as {I,mentioned} show up in

40
00:01:36,310 --> 00:01:37,570
0,480 480,570 570,660 660,840 840,1260
the, in the next couple

41
00:01:37,570 --> 00:01:38,890
0,90 90,360 630,780 780,1260 1260,1320
of weeks,| in particular, we're
|特别是，我们将阅读，

42
00:01:38,890 --> 00:01:40,540
0,120 120,510 540,1020 1050,1530 1530,1650
going to read,| {} {you,know}
|你知道我们下周要开始使用一些重型交易系统

43
00:01:40,540 --> 00:01:41,920
0,120 120,360 360,630 630,1080 1080,1380
we're starting next week to

44
00:01:41,920 --> 00:01:43,870
0,150 150,210 210,810 810,1290 1290,1950
sort of heavy-duty transaction systems|
|

45
00:01:44,140 --> 00:01:47,410
0,750 750,2100 2130,2670 2670,2730 2730,3270
and they build a lot
他们在给定的一些技术上建立了很大的基础

46
00:01:47,470 --> 00:01:49,450
0,780 810,1530 1530,1740 1740,1890 1890,1980
on {} given some of

47
00:01:49,450 --> 00:01:50,440
0,210 210,600 600,660 660,750 750,990
the techniques| or to use
|或者使用Frangipani实际上也使用的一些技术。

48
00:01:50,440 --> 00:01:51,430
0,150 150,270 270,420 420,840 840,990
some of the techniques that

49
00:01:51,430 --> 00:01:52,750
0,390 390,510 510,780 780,1080 1080,1320
actually {} {Frangipani -} also

50
00:01:52,750 --> 00:01:53,380
0,510
uses.|
|

51
00:01:53,730 --> 00:01:55,110
0,150 150,540 570,840 840,1170 1170,1380
And so {Frangipani -} {is,sort,of}
所以Frangipani在某种程度上是对这三个主题的更温和的介绍，

52
00:01:55,110 --> 00:01:57,600
0,240 240,420 420,720 720,1410 1710,2490
a more gentle introduction to

53
00:01:57,630 --> 00:01:59,580
0,300 420,870 900,1380 1380,1800 1800,1950
these three topics,| before we
|在我们谈到重型交易系统之前。

54
00:01:59,580 --> 00:02:01,740
0,210 210,300 300,1140 1140,1560 1560,2160
get to heavy-duty transaction systems.|
|

55
00:02:02,560 --> 00:02:03,820
0,330 570,840 840,990 990,1200 1200,1260
And {} the idea is
而且这个想法也是Frangipani本身的一个有趣的设计，

56
00:02:03,820 --> 00:02:05,230
0,360 360,510 510,870 870,1320 1320,1410
also {Frangipani's -} itself is

57
00:02:05,230 --> 00:02:07,300
0,90 90,420 420,900 1170,1740 1740,2070
an interesting design,| {} from
|从分布式系统角度来看，

58
00:02:07,300 --> 00:02:09,850
0,600 600,960 960,1230 1230,1920 2100,2550
a distribute system perspective, {}|
|

59
00:02:09,850 --> 00:02:11,050
0,150 150,300 300,900 900,930 930,1200
it is {} a cool
这是一个很酷的系统。

60
00:02:11,050 --> 00:02:13,780
0,450 1020,1500 1500,2040 2250,2490 2490,2730
system.| Let me {} make
|让我通过某种[信任]网络文件系统的传统设计来说明这一点，

61
00:02:13,780 --> 00:02:16,240
0,210 210,660 660,1320 1350,2010 2100,2460
that point by {} sort

62
00:02:16,240 --> 00:02:18,430
0,150 150,780 780,1140 1140,1620 1620,2190
of {[trusting],sort,of} the traditional designs

63
00:02:18,430 --> 00:02:20,560
0,330 330,660 660,900 900,1320 1680,2130
for network file system,| so
|所以传统的或最常见的网络文件系统设计，

64
00:02:20,590 --> 00:02:21,920
0,810
traditional

65
00:02:22,860 --> 00:02:24,600
0,570 630,720 720,1020 1020,1440 1440,1740
or the most common network

66
00:02:24,600 --> 00:02:26,010
0,240 240,540 540,990 990,1320 1320,1410
file system design,| since if
|因为如果你想像雅典娜上的AFS，

67
00:02:26,010 --> 00:02:28,230
0,120 120,300 300,630 630,1500 1950,2220
you think about like {

68
00:02:28,230 --> 00:02:30,360
0,510 540,690 690,930 930,1560 1560,2130
-} AFS on Athena,| if
|如果你有一组客户，

69
00:02:30,510 --> 00:02:31,680
0,750 750,870 870,930 930,1110 1110,1170
you have a set of

70
00:02:31,680 --> 00:02:32,780
0,690
clients,|
|

71
00:02:33,710 --> 00:02:35,030
0,390 390,600 600,840 840,1050 1050,1320
{and,this} is a very simple
这是一组客户的简单图片，

72
00:02:35,030 --> 00:02:36,500
0,510 1140,1200 1200,1260 1260,1410 1410,1470
picture of a set of

73
00:02:36,500 --> 00:02:37,940
0,600 600,690 690,810 810,1230 1230,1440
clients,| you know connected to
|你知道，连接到某个网络，

74
00:02:37,940 --> 00:02:40,310
0,240 240,930 1440,2040 2040,2100 2100,2370
some network,| represent the network
|表示网络基本上是一条单线，

75
00:02:40,310 --> 00:02:41,570
0,300 300,390 390,660 660,900 900,1260
basically a single {wire -},|
|

76
00:02:41,720 --> 00:02:43,250
0,150 150,990 990,1200 1200,1440 1440,1530
{you,know} sharing a number of
您知道，共享多个文件服务器

77
00:02:43,250 --> 00:02:45,980
0,270 270,870 1890,2160 2160,2490 2490,2730
file servers| and {then,a} file
|然后一个文件服务器拥有他们的磁盘。

78
00:02:45,980 --> 00:02:48,380
0,540 570,810 810,990 990,2040
servers have their disk.|
|

79
00:02:52,740 --> 00:02:54,870
0,510 510,870 870,1200 1830,1980 1980,2130
And basically all the all
基本上所有的复杂性，尽管，

80
00:02:54,870 --> 00:02:57,240
0,60 60,840 1140,2070
the complexity {}

81
00:02:57,580 --> 00:02:59,020
0,420 420,900 900,1140 1140,1320 1320,1440
although,| okay, I'll get to
|好的，稍后我将详细介绍缓存一致性，

82
00:02:59,020 --> 00:03:01,000
0,480 480,1140 1140,1320 1320,1650 1650,1980
cache coherence in a detail

83
00:03:01,000 --> 00:03:03,580
0,90 90,120 120,450 930,1560 1920,2580
in a second,| {} the,
|设计中的所有复杂性基本上都在这里，在文件服务器上，

84
00:03:04,060 --> 00:03:05,500
0,150 150,240 240,780 780,900 900,1440
all the complexity in the

85
00:03:05,500 --> 00:03:07,510
0,390 390,480 480,1350 1350,1920 1920,2010
design is basically here, at

86
00:03:07,510 --> 00:03:09,790
0,60 60,330 330,780 1560,1920 1920,2280
the file servers,| file servers
|文件服务器实施您知道的文件系统操作，

87
00:03:09,790 --> 00:03:10,930
0,540 540,630 630,810 810,900 900,1140
implement you know the file

88
00:03:10,930 --> 00:03:12,970
0,270 270,930 930,1230 1230,1710 1710,2040
system operations,| open close read
|打开关闭读写，你知道统计一切

89
00:03:12,970 --> 00:03:14,200
0,420 420,480 480,600 600,1080 1080,1230
write, you know stat on

90
00:03:14,200 --> 00:03:17,320
0,390 810,1170 1170,2280 2310,2940 2940,3120
everything| and they write things
|它们以抗崩溃或抗崩溃的方式将数据写入磁盘

91
00:03:17,320 --> 00:03:18,460
0,90 90,450 450,630 630,750 750,1140
to disk in the crash

92
00:03:18,460 --> 00:03:21,370
0,630 870,1560 1560,2100 2100,2460 2760,2910
{} resilient {or,resistant} way| and
|而客户真的有点傻或者很简单，

93
00:03:21,370 --> 00:03:22,330
0,60 60,450 450,540 540,780 780,960
the clients are really sort

94
00:03:22,330 --> 00:03:24,010
0,90 90,510 810,960 960,1440 1500,1680
of dumb or simple,| they
|他们并没有真正做太多事情，

95
00:03:24,010 --> 00:03:25,150
0,180 180,390 390,540 540,1020 1020,1140
didn't really do much,| {you,know}
|您知道，也许可以像在AFS中那样进行一些缓存，

96
00:03:25,150 --> 00:03:26,530
0,420 420,660 660,840 840,1260 1260,1380
perhaps do some caching as

97
00:03:26,530 --> 00:03:28,150
0,120 120,270 270,420 420,1050 1170,1620
they do in AFS, {}|
|

98
00:03:28,150 --> 00:03:29,170
0,210 210,450 450,570 570,840 840,1020
but you know most of
但你知道，大多数都是，

99
00:03:29,170 --> 00:03:31,330
0,420 420,900 930,1170 1170,1830 1830,2160
these is,| they're relaying file
|它们从客户端、从正在运行的程序转发文件系统操作

100
00:03:31,330 --> 00:03:33,100
0,270 270,930 930,1170 1170,1620 1620,1770
system operations from client, from

101
00:03:33,100 --> 00:03:34,780
0,510 510,630 630,720 720,1200 1470,1680
programs that are running| like
|就像你的第一个客户身上的任何东西

102
00:03:34,780 --> 00:03:36,460
0,360 360,540 540,1050 1050,1560 1560,1680
whatever the [] on you're

103
00:03:36,460 --> 00:03:37,510
0,270 270,600 600,690 690,810 810,1050
client one| and it does
|它确实打开了，关闭了，

104
00:03:37,510 --> 00:03:38,980
0,270 270,780 990,1170 1170,1410 1410,1470
open close,| and most of
|而客户端所做的大部分工作都是将这些操作转发到文件服务器。

105
00:03:38,980 --> 00:03:40,180
0,90 90,150 150,450 450,720 720,1200
what the client does relaying

106
00:03:40,180 --> 00:03:41,800
0,180 180,690 690,810 810,1050 1050,1620
those operations to file servers.|
|

107
00:03:42,510 --> 00:03:43,500
0,180 180,450 450,750 750,900 900,990
And one reason that the
该设计受欢迎的一个原因是

108
00:03:43,500 --> 00:03:45,630
0,450 450,780 810,1440 1440,1650 1650,2130
design is popular is| because
|因为你知道，从安全的角度来说，

109
00:03:45,630 --> 00:03:46,950
0,210 210,450 450,870 900,1140 1140,1320
you know like [] from

110
00:03:46,950 --> 00:03:48,780
0,60 60,420 420,1110 1200,1650 1650,1830
{} security perspective,| {} it
|这是一个很好的设计，

111
00:03:48,780 --> 00:03:49,800
0,90 90,150 150,420 420,780 780,1020
is a nice design,| because
|因为大多数文件服务器必须是可信的，

112
00:03:49,800 --> 00:03:52,170
0,300 300,600 960,1500 1650,2010 2010,2370
most of the file servers

113
00:03:52,170 --> 00:03:53,550
0,180 180,270 270,480 480,1110 1230,1380
have to be trusted,| but
|但客户不一定要被信任。

114
00:03:53,550 --> 00:03:54,420
0,60 60,420 420,660 660,810 810,870
the clients don't have to

115
00:03:54,420 --> 00:03:55,380
0,120 120,630
be trusted.|
|

116
00:03:56,760 --> 00:03:57,690
0,240 240,570 570,630 630,690 690,930
And certainly in a setting
当然，在麻省理工学院这样的环境中，

117
00:03:57,690 --> 00:03:59,370
0,180 180,720 720,990 990,1260 1260,1680
like MIT,| we're like machines
|我们就像机器只是在公共场合

118
00:03:59,370 --> 00:04:00,360
0,90 90,240 240,360 360,900 900,990
are just in public| and
|谁知道是谁在上面安装了什么样的软件，

119
00:04:00,360 --> 00:04:01,620
0,240 240,540 540,780 780,1110 1110,1260
who knows who installs what

120
00:04:01,620 --> 00:04:02,550
0,150 150,210 210,600 600,750 750,930
kind of software on it,|
|

121
00:04:02,550 --> 00:04:04,590
0,450 720,1020 1020,1290 1290,1410 1410,2040
you know that is a
你知道那是一处不错的房产，

122
00:04:04,590 --> 00:04:07,350
0,420 420,960 1350,2370 2370,2490 2490,2760
nice property,| Frangipani {on,the,other,end -},
|在蛋黄的另一端，有一个非常不同的设计和更分散的设计。

123
00:04:07,350 --> 00:04:08,700
0,120 120,180 180,630 630,930 930,1350
has a very different design

124
00:04:08,910 --> 00:04:10,860
0,300 300,540 540,810 810,1500 1500,1950
and much more decentralized design.|
|

125
00:04:14,300 --> 00:04:15,440
0,600 600,810 810,870 870,1080 1080,1140
{} And in {Frangipani -
而在Frangipani实际上有很多文件服务器，

126
00:04:15,440 --> 00:04:16,520
0,300 300,690 690,780 780,990 990,1080
-} actually a lot of

127
00:04:16,520 --> 00:04:19,220
0,360 360,660 660,1260 1500,2490 2490,2700
the file server,| {} it's
|它实际上没有真正的文件服务器，在这个字面上发送工作，

128
00:04:19,220 --> 00:04:20,570
0,450 450,660 660,930 930,1170 1170,1350
really there's actually no real

129
00:04:20,570 --> 00:04:21,680
0,270 270,660 660,750 750,990 990,1110
file server in this {}

130
00:04:21,680 --> 00:04:23,180
0,300 300,510 510,630 630,1200 1290,1500
literally sends the work, {}|
|

131
00:04:23,180 --> 00:04:25,190
0,330 480,870 900,1020 1020,1590 1590,2010
but the the clients basically
但客户端实现的基本上是运行文件服务器代码本身。

132
00:04:25,190 --> 00:04:27,380
0,690 1140,1620 1620,1710 1710,1950 1950,2190
implement run the file server

133
00:04:27,380 --> 00:04:28,360
0,210 210,810
code itself.|
|

134
00:04:28,790 --> 00:04:30,200
0,240 240,540 540,750 750,930 930,1410
So let's say with two
假设有两个客户端和大部分文件系统代码本身，

135
00:04:30,440 --> 00:04:32,360
0,810 1050,1530 1530,1770 1770,1830 1830,1920
clients and most of the

136
00:04:32,360 --> 00:04:34,430
0,240 240,1050 1080,1410 1410,1890 1890,2070
file system code itself,| like
|就像实际上有索引节点管理器一样，

137
00:04:34,430 --> 00:04:35,720
0,120 120,270 270,420 420,930 930,1290
the thing that actually has

138
00:04:35,720 --> 00:04:37,220
0,240 240,420 420,840 840,990 990,1500
{inode -} managers,| {inode -}
|Inode更新您知道的文件，创建目录，

139
00:04:37,250 --> 00:04:39,020
0,270 270,840 840,930 930,1170 1170,1770
{} updates you know files,

140
00:04:39,110 --> 00:04:40,880
0,420 420,1020 1140,1290 1290,1380 1380,1770
creates directories,| all the code
|所有代码，而不是居住在文件服务器上，

141
00:04:40,880 --> 00:04:42,080
0,270 270,360 360,630 630,810 810,1200
instead of living on the

142
00:04:42,110 --> 00:04:43,520
0,240 240,810 840,1170 1170,1290 1290,1410
file server,| looks like it
|看起来它是靠客户生活的。

143
00:04:43,520 --> 00:04:45,060
0,330 330,510 510,750 750,1380
lives on the clients.|
|

144
00:04:45,630 --> 00:04:46,950
0,420 570,750 750,960 960,1170 1170,1320
{You,know} the only thing that
您知道，文件服务器真正共享的唯一东西是一个大虚拟磁盘。

145
00:04:46,950 --> 00:04:49,710
0,570 690,1440 1740,2220 2220,2490 2490,2760
really the the file server

146
00:04:49,710 --> 00:04:52,530
0,630 660,1440 1440,1620 1620,2130 2160,2820
share is a big virtual

147
00:04:52,530 --> 00:04:53,500
0,510
disk.|
|

148
00:04:53,690 --> 00:04:54,480
0,180

149
00:04:58,730 --> 00:04:59,930
0,150 150,240 240,390 390,1020 1020,1200
And if you will may
如果你愿意成为一个好的形象，你在你的脑海里

150
00:04:59,930 --> 00:05:01,100
0,120 120,180 180,390 390,1050 1050,1170
be a good image you

151
00:05:01,100 --> 00:05:02,090
0,180 180,270 270,450 450,900 900,990
have in your head| or
|或者你脑海中的概念性形象

152
00:05:02,090 --> 00:05:03,140
0,150 150,570 570,810 810,900 900,1050
a conceptual image you have

153
00:05:03,140 --> 00:05:03,860
0,90 90,210 210,420 420,600 600,720
in your head| is that
|虚拟磁盘基本上就像一个大型固态硬盘驱动器，

154
00:05:03,860 --> 00:05:05,270
0,90 90,330 330,600 600,750 870,1410
the virtual disk is {basically,like}

155
00:05:05,270 --> 00:05:07,910
0,240 240,660 660,1230 1230,1830 1980,2640
a big ssd drive, {}|
|

156
00:05:07,910 --> 00:05:09,500
0,690 690,810 810,900 900,1170 1170,1590
and so the file servers,
所以文件服务器基本上共享一个固态硬盘，你知道彼此共享一个磁盘，

157
00:05:09,500 --> 00:05:11,720
0,180 180,540 540,990 990,1530 1530,2220
there's basically share one ssd,

158
00:05:11,720 --> 00:05:14,390
0,90 90,870 1110,1500 1500,2040 2190,2670
you know one disk {}

159
00:05:14,390 --> 00:05:15,950
0,240 240,390 390,750 930,1440 1440,1560
with each other,| now of
|现在，当然在内部，这个虚拟磁盘是使用一个名为Petal的系统实现的

160
00:05:15,950 --> 00:05:18,110
0,210 210,870 870,1230 1260,1830 1830,2160
course internally this virtual disk

161
00:05:18,110 --> 00:05:19,670
0,360 360,990 990,1260 1260,1290 1290,1560
is implemented using a system

162
00:05:19,670 --> 00:05:21,470
0,180 180,720 1080,1530 1530,1650 1650,1800
called Petal| and you know
|你知道，实际上是由许多机器组成的，

163
00:05:21,470 --> 00:05:22,880
0,360 360,660 660,810 810,1140 1140,1410
consists actually of {} many

164
00:05:22,880 --> 00:05:26,180
0,930 1230,2190 2460,2880 2880,3180 3180,3300
machines,| {} and but you
|但是你知道，你知道机器复制你知道的磁盘块，

165
00:05:26,180 --> 00:05:27,680
0,120 120,480 480,1050 1050,1140 1140,1500
know you know the machine

166
00:05:27,680 --> 00:05:29,090
0,540 540,600 600,720 720,930 930,1410
replicate you know disk blocks,|
|

167
00:05:29,090 --> 00:05:30,860
0,450 450,570 570,960 960,1620 1620,1770
there are patches internally to
内部有补丁，以确保操作员可以按正确的顺序应用补丁

168
00:05:30,860 --> 00:05:32,450
0,150 150,450 450,660 660,1440 1500,1590
make sure that like you

169
00:05:32,450 --> 00:05:33,680
0,240 240,750 750,870 870,1140 1140,1230
know operators can apply it

170
00:05:33,680 --> 00:05:34,970
0,60 60,150 150,390 390,930 1080,1290
in the right order| and
|诸如此类的事情，

171
00:05:34,970 --> 00:05:35,780
0,120 120,210 210,330 330,420 420,810
all that kind of stuff,|
|

172
00:05:35,780 --> 00:05:37,640
0,210 210,450 450,690 690,1170 1170,1860
but from the outside perspective,|
但从外部来看，|

173
00:05:37,790 --> 00:05:38,660
0,120 120,180 180,330 330,750 750,870
you know the interface is
您知道，该接口实际上是一个读块，或写块。

174
00:05:38,660 --> 00:05:40,400
0,540 570,1020 1020,1170 1170,1260 1260,1740
really a {read -} block,

175
00:05:40,700 --> 00:05:42,180
0,420 420,720 720,1200
or write block.|
|

176
00:05:42,420 --> 00:05:43,140
0,210 210,300 300,390 390,570 570,720
And so it just looks
所以它看起来就像一个普通的磁盘。

177
00:05:43,140 --> 00:05:44,540
0,150 150,240 240,720 720,1170
like an ordinary disk.|
|

178
00:05:45,150 --> 00:05:46,920
0,630 750,1200 1200,1410 1410,1620 1620,1770
And, {} as over those
而且，和那些对此感兴趣的人一样，

179
00:05:46,920 --> 00:05:48,000
0,330 330,420 420,750 750,870 870,1080
interesting in this,| you know
|你知道你签约设计的设计，

180
00:05:48,000 --> 00:05:49,650
0,420 420,600 600,1110 1110,1200 1200,1650
design you contracted to {design's

181
00:05:49,650 --> 00:05:50,610
0,180 240,630 630,690 690,840 840,960
-},| actually a lot of
|实际上，此设计中的许多复杂性都在客户端。

182
00:05:50,610 --> 00:05:52,500
0,780 810,1050 1050,1230 1230,1740 1740,1890
complexity in this design is

183
00:05:52,500 --> 00:05:55,180
0,180 180,390 390,810 810,1200
on the client side.|
|

184
00:05:56,100 --> 00:05:57,360
0,540 540,690 690,750 750,960 960,1260
And you know one reason
你知道你喜欢这个的一个原因，

185
00:05:57,360 --> 00:05:58,350
0,90 90,210 210,420 420,810 810,990
that you like that,| or
|或者为什么呢，

186
00:05:58,350 --> 00:05:59,940
0,510 840,1140 1140,1380 1380,1470 1470,1590
why is that,| you know
|您知道，您可以通过增加工作站数量来扩展文件系统，

187
00:05:59,940 --> 00:06:01,560
0,180 180,300 300,990 990,1350 1350,1620
you can grow the file

188
00:06:01,560 --> 00:06:03,480
0,510 810,1170 1170,1560 1560,1680 1680,1920
system {} with the number

189
00:06:03,480 --> 00:06:04,740
0,60 60,630 630,780 780,870 870,1260
of workstations,| so if you
|因此，如果您增加客户数量，

190
00:06:04,740 --> 00:06:06,210
0,330 330,450 450,720 720,810 810,1470
increase the number of clients,|
|

191
00:06:06,360 --> 00:06:07,890
0,390 390,750 750,930 930,1170 1170,1530
you basically get more CPU
基本上，你可以获得更多的CPU能力，

192
00:06:07,890 --> 00:06:08,850
0,360 360,600 600,660 660,780 780,960
power,| because you get more
|因为你得到了更多的客户

193
00:06:08,850 --> 00:06:10,020
0,510 510,780 780,840 840,990 990,1170
clients| and you know each
|而且您知道，每个客户端都可以在其自己的文件系统上驱动。

194
00:06:10,020 --> 00:06:10,980
0,90 90,330 330,660 660,780 780,960
of the clients can drive

195
00:06:10,980 --> 00:06:12,060
0,210 210,330 330,480 480,750 750,1080
on its own file system.|
|

196
00:06:12,590 --> 00:06:13,940
0,180 180,720 840,990 990,1260 1260,1350
And so a lot of
因此，很多非常繁重的计算都可以在客户机上完成

197
00:06:13,940 --> 00:06:15,710
0,360 360,630 630,990 990,1530 1530,1770
the really heavy-duty computation can

198
00:06:15,710 --> 00:06:16,370
0,180 180,270 270,480 480,570 570,660
all be done on the

199
00:06:16,370 --> 00:06:18,320
0,240 240,750 900,1020 1020,1260 1260,1950
client machines| and doesn't involve
|并且根本不涉及任何文件服务器，

200
00:06:18,350 --> 00:06:19,610
0,360 360,570 570,870 870,960 960,1260
any file server at all,|
|

201
00:06:19,760 --> 00:06:20,720
0,150 150,270 270,450 450,780 780,960
and it is true that
确实，在左边，

202
00:06:20,720 --> 00:06:21,980
0,480 480,690 690,930 930,1170 1170,1260
in the left side,| the
|网络传统的网络文件系统设计

203
00:06:21,980 --> 00:06:23,480
0,360 360,780 780,1050 1050,1260 1260,1500
network traditional network file system

204
00:06:23,480 --> 00:06:25,220
0,630 930,1080 1080,1290 1290,1380 1380,1740
design| is often the case
|通常情况下，您知道性能瓶颈出现在文件服务器中，

205
00:06:25,220 --> 00:06:26,660
0,210 210,300 300,540 540,960 990,1440
that you know the performance

206
00:06:26,660 --> 00:06:28,790
0,570 570,1170 1170,1290 1290,1470 1470,2130
bottlenecks arise you know in

207
00:06:29,180 --> 00:06:31,490
0,660 1170,1470 1470,1560 1560,1770 1770,2310
the, in the file server,|
|

208
00:06:31,490 --> 00:06:32,540
0,300 300,390 390,630 630,720 720,1050
when the number of clients
当客户端数量实际上变得太多时

209
00:06:32,540 --> 00:06:34,760
0,510 510,1200 1230,1560 1560,1680 1680,2220
actually {} becomes too large|
|

210
00:06:34,790 --> 00:06:35,870
0,330 330,600 600,660 660,840 840,1080
and often in that case
例如，通常在这种情况下，我们会将文件系统拆分到不同的文件服务器。

211
00:06:35,870 --> 00:06:36,920
0,90 90,570 600,750 750,990 990,1050
for example we split the

212
00:06:36,920 --> 00:06:38,870
0,270 270,810 840,1410 1410,1680 1680,1950
file system across different files

213
00:06:38,870 --> 00:06:39,540
0,180 180,540
{servers -}.|
|

214
00:06:40,900 --> 00:06:41,680
0,270 270,330 330,450 450,630 630,780
{Okay - -}, that's sort
好吧，这是一种，

215
00:06:41,680 --> 00:06:43,510
0,120 120,600 930,1260 1260,1590 1650,1830
of the,| {} so from
|因此，从我们的角度来看，至少从分布式系统设计来看，

216
00:06:43,510 --> 00:06:44,860
0,150 150,660 660,780 780,1170 1170,1350
our perspective at least from

217
00:06:44,860 --> 00:06:46,630
0,660 690,1080 1080,1380 1380,1530 1530,1770
a distributed systems {design -

218
00:06:46,630 --> 00:06:48,160
0,390 600,960 960,1050 1050,1440 1440,1530
-},| {Frangipani - -} is
|煎蛋卷很有趣，

219
00:06:48,160 --> 00:06:49,480
0,360 360,630 630,930 930,1200 1200,1320
interesting,| because it's much more
|因为它更加分散，

220
00:06:49,480 --> 00:06:50,890
0,930 930,1080 1080,1230 1230,1320 1320,1410
decentralized,| than sort of the
|而不是传统的网络文件系统设计。

221
00:06:50,890 --> 00:06:53,170
0,780 780,1440 1440,1650 1650,1920 1920,2280
traditional network file system design.|
|

222
00:06:56,190 --> 00:06:58,920
0,300 570,750 750,1500 1530,2370 2400,2730
And the reason they wanted
他们想要探索这种设计的原因与用例有很大关系，

223
00:06:58,920 --> 00:07:01,260
0,60 60,840 870,1470 1470,1770 1770,2340
to explore {} this design

224
00:07:01,350 --> 00:07:02,100
0,120 120,180 180,390 390,480 480,750
has a lot to do

225
00:07:02,100 --> 00:07:03,420
0,180 180,240 240,510 510,840 840,1320
with the use case,| that
|他们想象的或他们的目标

226
00:07:03,420 --> 00:07:04,830
0,180 180,690 690,990 990,1320 1320,1410
they imagine or that they

227
00:07:04,830 --> 00:07:05,940
0,150 150,570 570,840 840,960 960,1110
were targeting| and I want
|我想说一点关于用例的事情，

228
00:07:05,940 --> 00:07:06,480
0,60 60,180 180,240 240,420 420,540
to say a little bit

229
00:07:06,480 --> 00:07:07,620
0,210 210,300 300,510 510,780 780,1140
about the use case,| because,
|因为，在电子邮件中有很多与此相关的问题。

230
00:07:07,800 --> 00:07:08,640
0,450 450,570 570,660 660,690 690,840
{} there were a lot

231
00:07:08,640 --> 00:07:09,810
0,60 60,480 480,810 810,870 870,1170
of questions related to that

232
00:07:09,810 --> 00:07:11,800
0,300 300,630 630,1020 1020,1320
in {} email.| So,
|那么，它的用例是什么？

233
00:07:13,340 --> 00:07:14,060
0,150 150,330 330,420 420,510 510,720
so what is the use

234
00:07:14,060 --> 00:07:16,010
0,510 930,1230 1230,1410 1410,1620 1620,1950
case,| {} the use case
|用例基本上是一些研究人员和工程师，

235
00:07:16,010 --> 00:07:18,380
0,690 720,2010 2010,2070 2070,2280 2280,2370
is basically a number of

236
00:07:18,380 --> 00:07:20,460
0,660 840,960 960,1830
researchers and engineers,|
|

237
00:07:24,370 --> 00:07:26,880
0,630 630,720 720,840 840,1890
{} you know compiling,
你知道编译、编译、编辑他们的程序或编写文档。

238
00:07:29,490 --> 00:07:32,580
0,810 810,1560 1740,2190 2190,2880 2880,3090
compiling editing their programs or

239
00:07:32,580 --> 00:07:33,900
0,270 270,1080
writing documents.|
|

240
00:07:39,710 --> 00:07:41,360
0,210 210,360 360,600 600,1020 1020,1650
So it's really designed to
因此，它实际上是为来自著名研究实验室的论文而设计的。

241
00:07:41,390 --> 00:07:43,520
0,450 450,720 720,1470 1500,1830 1830,2130
papers from a famous research

242
00:07:43,520 --> 00:07:45,980
0,390 390,1410 1410,1560 1560,2070 2070,2460
{lab -} {[] - -},|
|

243
00:07:46,430 --> 00:07:48,920
0,720 750,1170 1170,1800 1830,2130 2130,2490
and Thekkath like tens of
而Thekkath喜欢几十个研究人员，比如50到100个

244
00:07:48,950 --> 00:07:50,390
0,390 390,750 750,1080 1080,1350 1350,1440
{} researcher like 50 to

245
00:07:50,390 --> 00:07:52,310
0,60 60,540 870,1530 1530,1680 1680,1920
{} 100| and they're really
|他们真正在做的是为他们的用例设计一个文件系统，

246
00:07:52,310 --> 00:07:53,480
0,180 180,360 360,660 660,750 750,1170
what they're doing is designing

247
00:07:53,480 --> 00:07:55,040
0,90 90,360 360,1110 1110,1290 1290,1560
a file system for their

248
00:07:55,040 --> 00:07:58,520
0,210 210,630 1470,1680 1680,2580 2580,3480
use case,| so everybody is
|所以每个人都是可信的，

249
00:07:58,520 --> 00:08:00,650
0,630 840,1260 1260,1530 1530,1650 1650,2130
trusted,| {} all the machines
|所有机器都是可信的，所有运行的软件都是可信的

250
00:08:00,650 --> 00:08:01,700
0,60 60,540 540,630 630,720 720,1050
are trusted, all the software

251
00:08:01,700 --> 00:08:03,500
0,270 270,1140 1470,1620 1620,1710 1710,1800
running trusted| and so the
|因此，事情的安全方面确实不是一个问题，

252
00:08:03,500 --> 00:08:04,730
0,570 570,780 780,870 870,1080 1080,1230
security side of things is

253
00:08:04,730 --> 00:08:06,050
0,420 420,600 600,690 690,990 990,1320
really not an issue for

254
00:08:06,590 --> 00:08:08,600
0,720 720,1080 1080,1380 1380,1530 1530,2010
that,| all the these researchers
|所有这些研究人员都是重负荷计算机用户

255
00:08:08,600 --> 00:08:10,730
0,30 30,930 930,930 930,1800 1800,2130
are heavy-duty {} {} computer

256
00:08:10,730 --> 00:08:12,800
0,510 840,1470 1470,1530 1530,1860 1860,2070
users| and you know and
|你知道，所以他们想要，

257
00:08:12,800 --> 00:08:13,790
0,90 90,180 180,360 360,750 780,990
so they want to,| but
|但大多数情况下，他们正在处理自己的私人文件

258
00:08:13,790 --> 00:08:14,990
0,540 540,690 690,960 960,1050 1050,1200
mostly they're working on their

259
00:08:14,990 --> 00:08:16,400
0,390 390,720 720,1110 1110,1230 1230,1410
own private files| and they're
|他们正在编写自己的程序，编写自己的文档，

260
00:08:16,400 --> 00:08:17,720
0,270 270,420 420,570 570,1170 1170,1320
writing their own programs, their

261
00:08:17,720 --> 00:08:20,390
0,330 330,900 900,990 990,1680 2070,2670
writing their own documents, {}|
|

262
00:08:20,390 --> 00:08:21,620
0,240 240,540 660,1020 1020,1170 1170,1230
and so [] want to
因此[]希望与高性能文件系统的文件进行交互。

263
00:08:21,620 --> 00:08:22,850
0,390 390,510 510,600 600,1020 1020,1230
interact with the files with

264
00:08:22,850 --> 00:08:24,440
0,210 210,630 630,870 870,1320
high performance file system.|
|

265
00:08:24,780 --> 00:08:26,550
0,540 780,1260 1260,1320 1320,1440 1440,1770
Of course, you know they
当然，你知道他们可能会分享，

266
00:08:26,550 --> 00:08:28,620
0,240 240,780 870,1590 1590,1920 1920,2070
might share,| otherwise sharing would
|否则分享就不会有什么意思，

267
00:08:28,620 --> 00:08:32,820
0,210 210,720 840,1530 3930,4110 4110,4200
not be interesting,| so they
|因此，它们都可能共享文件和目录。

268
00:08:32,820 --> 00:08:34,410
0,330 330,780 780,1050 1050,1500 1500,1590
both potentially share files and

269
00:08:34,410 --> 00:08:35,720
0,690
directories.|
|

270
00:08:36,030 --> 00:08:37,500
0,570 630,750 750,990 990,1140 1140,1470
And it shows up in
它以两种方式表现出来

271
00:08:37,500 --> 00:08:39,030
0,180 180,840 1140,1290 1290,1410 1410,1530
two ways| you know they
|你知道他们可能会一起工作，一起合作写一篇论文

272
00:08:39,030 --> 00:08:40,680
0,270 270,570 570,930 930,1350 1350,1650
may work together, collaborate together

273
00:08:40,680 --> 00:08:42,150
0,300 300,540 540,600 600,990 990,1470
around writing a paper| like
|就像我们今天读到的报纸，

274
00:08:42,210 --> 00:08:43,590
0,330 330,480 480,690 690,930 930,1380
paper that we're reading today,|
|

275
00:08:43,890 --> 00:08:45,720
0,390 390,540 540,1050 1050,1290 1290,1830
{} and so {} they
因此他们希望能够访问共享文件

276
00:08:45,720 --> 00:08:46,950
0,180 180,300 300,660 660,900 900,1230
want have access to a

277
00:08:46,980 --> 00:08:49,140
0,420 420,1140 1260,1530 1530,1770 1770,2160
shared files| for the directory
|对于保存该特定论文的目录，

278
00:08:49,140 --> 00:08:50,520
0,120 120,390 390,510 510,870 870,1380
that holds that particular paper,|
|

279
00:08:50,820 --> 00:08:52,890
0,570 570,840 840,1170 1170,1800 1800,2070
{} and so to user
因此对于用户到用户共享，

280
00:08:52,890 --> 00:08:54,580
0,90 90,390 390,900
to user sharing,|
|

281
00:08:57,770 --> 00:08:58,520
0,150 150,270 270,420 420,480 480,750
and then there's a second
然后还有第二种形式的分享，

282
00:08:58,520 --> 00:08:59,570
0,210 210,270 270,720 720,960 960,1050
form of sharing,| like the
|就像同一用户可能登录到多个工作站一样，

283
00:08:59,570 --> 00:09:00,860
0,270 270,600 600,810 810,1080 1080,1290
same user might log into

284
00:09:00,860 --> 00:09:02,560
0,360 360,1230
multiple workstations,|
|

285
00:09:10,740 --> 00:09:12,440
0,120 120,240 240,600 600,1260
more than one workstation,|
一个以上的工作站，|

286
00:09:12,840 --> 00:09:14,340
0,270 270,420 420,810 810,1350 1350,1500
so again whatever, user one
所以再说一次，用户之一的研究人员去了公共图书馆[]

287
00:09:14,340 --> 00:09:15,090
0,90 90,180 180,480 480,660 660,750
of the researchers goes to

288
00:09:15,090 --> 00:09:16,860
0,90 90,360 360,780 780,900 900,1770
the public library of []|
|

289
00:09:16,860 --> 00:09:18,300
0,360 390,750 750,1170 1170,1320 1320,1440
or their library and the
或他们的图书馆和带有索引器的长通用公共工作站

290
00:09:18,300 --> 00:09:20,070
0,270 270,690 750,1050 1050,1620 1620,1770
long general public workstation with

291
00:09:20,070 --> 00:09:21,450
0,570 930,1050 1050,1110 1110,1290 1290,1380
indexer| and it wants to
|它还希望能够从该计算机读取或写入他们的文件。

292
00:09:21,450 --> 00:09:22,050
0,120 120,270 270,360 360,540 540,600
be able to read or

293
00:09:22,050 --> 00:09:23,370
0,270 270,630 630,780 780,1050 1050,1320
write {} their files from

294
00:09:23,730 --> 00:09:24,700
0,210 210,480 480,690
that machine too.|
|

295
00:09:25,000 --> 00:09:26,260
0,330 330,540 540,600 600,810 810,1260
So that's {} use case|
这就是用例|

296
00:09:26,710 --> 00:09:28,840
0,540 690,1110 1110,1590 1590,1860 1860,2130
{} and in this use
在这个用例中有许多设计含义，

297
00:09:28,840 --> 00:09:29,890
0,270 270,480 480,660 660,960 960,1050
case has a number of

298
00:09:29,890 --> 00:09:33,280
0,780 900,1860 1860,2790
design {} implications,|
|

299
00:09:33,480 --> 00:09:35,010
0,480 510,630 630,750 750,1140 1140,1530
or you know design choices
或者你知道，设计选择是由一个巨大的案例驱动的。

300
00:09:35,010 --> 00:09:36,810
0,150 150,240 240,1050 1080,1680 1680,1800
that were motivated by a

301
00:09:36,810 --> 00:09:38,900
0,270 270,810
huge case.|
|

302
00:09:40,180 --> 00:09:42,220
0,300 300,450 450,990 1020,1560 1620,2040
{} And so the one
因此，主要的一种，

303
00:09:42,220 --> 00:09:43,990
0,90 90,180 180,840 840,1380 1470,1770
of the primary ones, {}|
|

304
00:09:43,990 --> 00:09:45,340
0,210 210,330 330,840 840,990 990,1350
that was motivated by this
这是由用例缓存所激发的。

305
00:09:45,340 --> 00:09:47,160
0,420 420,990 990,1470
use cases caching.|
|

306
00:09:51,560 --> 00:09:53,330
0,180 180,510 510,600 600,1230 1230,1770
So instead of leaving the
例如，与将数据全部保留在Petal中不同

307
00:09:53,360 --> 00:09:54,470
0,300 300,450 450,780 780,990 990,1110
data for example all in

308
00:09:54,470 --> 00:09:55,460
0,390 390,510 510,750 750,930 930,990
Petal| and every read or
|并且每个读或写操作都要经过Petal，

309
00:09:55,460 --> 00:09:56,990
0,240 240,690 690,900 900,1020 1020,1530
write operation goes through Petal,|
|

310
00:09:57,110 --> 00:09:58,220
0,360 360,450 450,660 660,720 720,1110
{} they want to arrange
他们想要安排，

311
00:09:58,220 --> 00:09:59,450
0,180 180,300 300,390 390,870 870,1230
it,| so the motive actually
|所以动机实际上发生在工作站上

312
00:09:59,450 --> 00:10:01,160
0,390 390,690 690,750 750,810 810,1710
actually happens in the workstations|
|

313
00:10:01,430 --> 00:10:03,200
0,180 180,390 390,900 900,1020 1020,1770
and so that the researchers
所以研究人员因为他们主要是在研究他们自己的私人文件，

314
00:10:03,440 --> 00:10:04,550
0,210 210,360 360,660 660,990 990,1110
since they're mostly working on

315
00:10:04,550 --> 00:10:05,930
0,150 150,270 270,630 630,1170 1170,1380
their own private files,| it
|这似乎很有道理，

316
00:10:05,930 --> 00:10:06,650
0,150 150,390 390,510 510,570 570,720
seems to make a lot

317
00:10:06,650 --> 00:10:07,430
0,90 90,450 450,570 570,720 720,780
of sense,| they're sort of
|它们是在工作站上本地捕获的数据，

318
00:10:07,430 --> 00:10:08,780
0,450 450,720 720,1140 1140,1260 1260,1350
captured data locally on the

319
00:10:08,780 --> 00:10:10,880
0,810 1170,1470 1470,1860 1860,2010 2010,2100
workstation,| {} then as you
|然后，当您读取或写入文件时，

320
00:10:10,880 --> 00:10:12,050
0,180 180,270 270,480 480,900 900,1170
read or write files,| there's
|基本上不需要网络流量，

321
00:10:12,050 --> 00:10:13,550
0,300 300,630 630,960 960,1320 1320,1500
basically no network traffic really

322
00:10:13,550 --> 00:10:15,830
0,840 1140,1740 1740,2070 2070,2160 2160,2280
necessary,| {} and you can
|您可以在某种程度上以高性能进行写入

323
00:10:15,830 --> 00:10:17,630
0,270 420,720 750,1470 1470,1620 1620,1800
sort of write at high

324
00:10:17,630 --> 00:10:20,300
0,750 1050,1560 1560,1890 1890,2250 2250,2670
performance| and one reason one
|其中一个原因是他们避免了前往佩塔尔的大量交通

325
00:10:20,300 --> 00:10:21,980
0,270 270,450 450,1020 1020,1440 1440,1680
way they avoid having a

326
00:10:21,980 --> 00:10:23,570
0,180 180,330 330,780 780,1020 1020,1590
lot of traffic to Petal|
|

327
00:10:23,690 --> 00:10:24,590
0,420 420,510 510,630 630,690 690,900
is to have a write
是使用回写式高速缓存而不是直写式，

328
00:10:24,590 --> 00:10:28,070
0,360 360,1020 2700,3090 3090,3180 3180,3480
back cache instead of write

329
00:10:28,070 --> 00:10:30,140
0,600 660,990 990,1230 1230,1740 1740,2070
through,| so if operations happen
|所以如果操作发生了，你真的留在缓存中了吗

330
00:10:30,140 --> 00:10:30,980
0,270 270,450 450,570 570,780 780,840
actually did you stay in

331
00:10:30,980 --> 00:10:31,910
0,90 90,510 510,660 660,750 750,930
the cache| and at some
|在后来的某个时候，他们渗透到了花瓣，

332
00:10:31,910 --> 00:10:34,010
0,240 240,600 600,720 720,1380 1650,2100
point later they percolated to

333
00:10:34,010 --> 00:10:34,880
0,330 330,420 420,570 570,690 690,870
Petal,| as {} we'll see
|正如我们稍后将看到的。

334
00:10:34,880 --> 00:10:37,940
0,90 90,150 150,480 1590,2190
in a second. {}|
|

335
00:10:38,180 --> 00:10:40,100
0,600 720,1230 1230,1500 1500,1650 1650,1920
So, combine that, like even
因此，将它们结合起来，即使它们主要是您知道的工作负载将被用于私人，

336
00:10:40,100 --> 00:10:41,690
0,360 360,780 780,1350 1350,1470 1470,1590
though they're mostly you know

337
00:10:41,690 --> 00:10:42,470
0,420 420,480 480,600 600,660 660,780
workloads are going to be

338
00:10:42,470 --> 00:10:44,000
0,210 210,300 300,870 990,1230 1230,1530
used for private,| {} where
|他们没有分享的地方正在进行，

339
00:10:44,000 --> 00:10:45,650
0,360 360,540 540,840 840,1350 1350,1650
they're not sharing going on,|
|

340
00:10:45,770 --> 00:10:46,880
0,90 90,300 300,750 750,930 930,1110
of course indicates they do
当然表明他们确实分享了，

341
00:10:46,880 --> 00:10:48,110
0,570 720,900 900,1020 1020,1170 1170,1230
share,| {} they want to
|他们想要有很强的一致性，

342
00:10:48,110 --> 00:10:50,000
0,510 540,900 900,1650
have strong consistency,|
|

343
00:10:50,480 --> 00:10:52,760
0,450 450,810 810,1230 1230,1410 1410,2280
or sometimes called {you,know} coherence.|
或者有时被称为连贯一致。|

344
00:11:00,870 --> 00:11:02,940
0,810 810,1170 1170,1470 1470,1620 1620,2070
{} And so the meaning
所以举个例子，它的意思是，

345
00:11:02,940 --> 00:11:06,090
0,270 270,960 960,1590 1590,2370 2670,3150
for example,| if a one
|如果一个用户写入文件，

346
00:11:06,090 --> 00:11:07,590
0,450 450,690 690,780 780,1260 1260,1500
user writes a file,| then
|然后另一个用户，许多工作站访问该文件，

347
00:11:07,590 --> 00:11:09,150
0,690 690,1050 1050,1380 1380,1410 1410,1560
{} another user, a lot

348
00:11:09,150 --> 00:11:10,830
0,90 90,330 330,870 1110,1590 1590,1680
of {workstation -} reached the

349
00:11:10,830 --> 00:11:12,720
0,540 540,840 840,1290 1290,1530 1530,1890
file,| we graded that user
|我们对该用户实际看到的更改进行了评分

350
00:11:12,720 --> 00:11:15,090
0,270 270,690 690,1050 1050,1650 1650,2370
actually saw the changes| that
|其他用户制作的另一台工作站

351
00:11:15,090 --> 00:11:16,140
0,120 120,300 300,810 810,870 870,1050
the other workstation the other

352
00:11:16,140 --> 00:11:18,360
0,300 300,510 510,900 1530,2040 2040,2220
user has made| {} and
|因此，他们想要更强的一致性。

353
00:11:18,360 --> 00:11:20,310
0,210 210,360 360,750 750,1320 1320,1950
so they want {strong -}

354
00:11:20,310 --> 00:11:21,100
0,660
consistency.|
|

355
00:11:22,360 --> 00:11:23,980
0,600 750,930 930,1320 1320,1500 1500,1620
{} So, those are the
所以，这是真正推动这一设计的两个设计选择

356
00:11:23,980 --> 00:11:26,470
0,930 930,1530 1530,1860 1860,2220 2220,2490
two {} design choices that

357
00:11:26,470 --> 00:11:28,840
0,270 270,1140 1140,1170 1170,1830 1830,2370
really drive {} this design|
|

358
00:11:29,260 --> 00:11:31,930
0,270 270,540 540,780 780,1290 1530,2670
as well as this basically
以及这个基本的表现。

359
00:11:32,140 --> 00:11:33,080
0,720
{}

360
00:11:34,230 --> 00:11:36,100
0,1320
performance.|
|

361
00:11:42,120 --> 00:11:45,090
0,630 1440,1890 1890,2070 2070,2250 2250,2970
So it may be helpful
因此，稍微考虑一下可能会有所帮助

362
00:11:45,120 --> 00:11:45,960
0,300 300,450 450,480 480,690 690,840
to think a little bit

363
00:11:45,960 --> 00:11:47,100
0,240 240,480 480,750 750,930 930,1140
about| like what other use
|例如，对于文件系统，您可以有哪些其他使用情形

364
00:11:47,100 --> 00:11:48,420
0,330 330,480 480,600 600,960 1200,1320
cases could you have {}

365
00:11:48,420 --> 00:11:49,500
0,210 210,450 450,870 870,960 960,1080
for file systems| and so
|因此，也许我们经常谈到的一个很好的问题是，考虑一下GFS，

366
00:11:49,500 --> 00:11:51,000
0,390 390,930 930,1080 1080,1290 1290,1500
maybe one good one that

367
00:11:51,000 --> 00:11:51,990
0,90 90,300 300,330 330,570 570,990
we talked a lot about

368
00:11:52,290 --> 00:11:53,970
0,420 420,540 540,690 690,900 900,1680
is to think about GFS,|
|

369
00:11:54,360 --> 00:11:56,190
0,750 750,870 870,990 990,1290 1290,1830
{} you know would GFS
你知道GFS会成为Frangipani的替代品吗？或者反过来，他们的对比如何？

370
00:11:56,190 --> 00:11:57,990
0,510 510,930 930,1380 1380,1500 1500,1800
be a substitute for {Frangipani

371
00:11:57,990 --> 00:11:58,830
0,390 390,480 480,570 570,720 720,840
-} or the other way

372
00:11:58,830 --> 00:12:00,420
0,420 420,540 540,690 690,870 870,1590
around how do they contrast.|
|

373
00:12:00,870 --> 00:12:01,980
0,510 570,780 780,870 870,960 960,1110
And one way to think
思考这一问题的一种方式是

374
00:12:01,980 --> 00:12:03,780
0,180 180,330 330,420 420,990 1020,1800
about this is| that GFS
|GFS实际上是为MapReduceTM应用程序设计的文件系统

375
00:12:03,780 --> 00:12:05,460
0,90 90,300 300,570 570,930 930,1680
is really file system designed

376
00:12:05,460 --> 00:12:07,620
0,90 90,300 300,630 630,1470 1800,2160
for {mapreduce -} applications| and
|因此它是一个文件系统，其中的文件不会被缓存，

377
00:12:07,620 --> 00:12:08,850
0,360 360,510 510,570 570,840 840,1230
so it's a file system

378
00:12:08,850 --> 00:12:12,840
0,690 810,2340 2340,2910 2940,3390 3390,3990
where files are not cached,|
|

379
00:12:12,840 --> 00:12:14,100
0,300 300,690 690,780 780,1080 1080,1260
in fact the files tend
事实上，这些文件往往非常大，

380
00:12:14,100 --> 00:12:14,850
0,60 60,180 180,360 360,630 630,750
to be so big,| that
|它们甚至都不合身

381
00:12:14,850 --> 00:12:16,020
0,120 120,420 420,600 600,960 960,1170
they wouldn't even fit| in
|在我们所说的这种类型的缓存中，

382
00:12:16,020 --> 00:12:16,980
0,150 150,330 330,390 390,780 780,960
the type of cache that

383
00:12:16,980 --> 00:12:18,810
0,360 360,750 750,1140 1440,1620 1620,1830
we're talking about,| it's also
|它也基本上是从头到尾按顺序阅读的，

384
00:12:18,810 --> 00:12:20,490
0,300 300,480 480,570 570,990 990,1680
basically sort of read sequentially

385
00:12:20,490 --> 00:12:21,630
0,150 150,480 480,600 600,960 990,1140
from beginning to end,| and
|仅此而已，

386
00:12:21,630 --> 00:12:23,280
0,210 210,450 810,1020 1020,1560 1560,1650
that's it,| and maybe you
|也许你知道其他计算机会读取该文件，

387
00:12:23,280 --> 00:12:25,170
0,120 120,270 270,810 810,1530 1530,1890
know some other {} computer

388
00:12:25,170 --> 00:12:26,400
0,180 180,330 330,480 480,870 870,1230
will read that file,| because
|因为一些其他的MapReduce应用程序运行在。

389
00:12:26,400 --> 00:12:27,690
0,120 120,330 330,540 540,810 810,1290
some other {mapreduce -} application

390
00:12:27,690 --> 00:12:28,420
0,240 240,450
running on.|
|

391
00:12:28,830 --> 00:12:30,210
0,270 270,540 540,750 750,930 930,1380
So think, you think about
想一想，你想一想GFS，

392
00:12:30,210 --> 00:12:32,010
0,540 600,900 900,1140 1140,1470 1470,1800
GFS,| there's really no data
|实际上根本就没有数据缓存，

393
00:12:32,010 --> 00:12:33,180
0,360 360,570 570,810 810,870 870,1170
caching going on at all,|
|

394
00:12:33,210 --> 00:12:33,930
0,330 330,390 390,540 540,630 630,720
there's a little bit of
需要使用一些缓存来跟踪

395
00:12:33,930 --> 00:12:35,310
0,300 300,510 510,750 750,1140 1170,1380
caching going on to keep

396
00:12:35,310 --> 00:12:38,100
0,390 390,600 960,1770 1770,1770 2430,2790
track of| where a chunk
|块服务器所在的位置，

397
00:12:38,100 --> 00:12:39,630
0,300 300,720 840,1170 1170,1350 1350,1530
servers were,| but there's actually
|但实际上在GFS中根本没有进行数据缓存，

398
00:12:39,630 --> 00:12:40,860
0,210 210,630 630,690 690,990 990,1230
no caching of data going

399
00:12:40,860 --> 00:12:42,090
0,210 210,300 300,540 540,660 660,1230
on at all in GFS,|
|

400
00:12:42,240 --> 00:12:43,200
0,150 150,300 300,510 510,630 630,960
so there's also no cache
因此，在GFS中也可能没有缓存一致性

401
00:12:43,200 --> 00:12:45,300
0,570 570,990 990,1080 1080,1770 1980,2100
consistency probably in GFS| and
|因此，他们的目标是某种类型的应用程序

402
00:12:45,300 --> 00:12:46,170
0,120 120,390 390,480 480,780 780,870
so there's a type of

403
00:12:46,170 --> 00:12:47,760
0,600 600,720 720,780 780,930 930,1590
applications that they were targeting|
|

404
00:12:47,850 --> 00:12:49,020
0,180 180,360 360,720 720,930 930,1170
that just didn't make sense
这完全说不通。

405
00:12:49,020 --> 00:12:49,780
0,90 90,450
at all.|
|

406
00:12:50,080 --> 00:12:52,150
0,450 450,540 540,1230 1320,1860 1860,2070
Similarly in GFS,| GFS actually
同样，在GFS中，|GFS实际上它并不是一个真正的文件系统

407
00:12:52,150 --> 00:12:53,500
0,90 90,300 300,630 630,1110 1110,1350
it's not really a real

408
00:12:53,500 --> 00:12:54,520
0,300 300,600 600,690 690,750 750,1020
file system| in the sense
|从这个意义上来说，这里并不打算像VI，GCC，

409
00:12:54,520 --> 00:12:55,990
0,90 90,570 600,1050 1050,1260 1260,1470
of the here was not

410
00:12:55,990 --> 00:12:57,790
0,390 390,480 480,780 780,1020 1020,1800
intended to run like VI,

411
00:12:57,880 --> 00:13:00,040
0,1110 1260,1650 1650,1830 1830,1950 1950,2160
GCC,| {} and so didn't
|因此没有提供直接的[积极的]或独特的兼容性，

412
00:13:00,040 --> 00:13:01,870
0,660 660,1080 1080,1230 1230,1710 1710,1830
provide straight {sort,of} [positive] or

413
00:13:01,870 --> 00:13:04,840
0,270 270,1020 1050,2490 2520,2850 2850,2970
unique compatibility,| {in,Frangipani -}, you
|在Frangipani中，您只需运行您的标准Unix应用程序

414
00:13:04,840 --> 00:13:06,130
0,90 90,240 240,810 810,930 930,1290
can just run your standard

415
00:13:06,130 --> 00:13:08,260
0,240 240,1050 1350,1740 1740,1950 1950,2130
Unix applications| and things should
|一切都会好起来的

416
00:13:08,260 --> 00:13:10,390
0,210 210,540 690,1470 1500,1590 1590,2130
work out| and the applications
|并且应用程序的行为方式与没有分布式文件系统一样，

417
00:13:10,390 --> 00:13:12,070
0,600 900,1050 1050,1110 1110,1500 1500,1680
behave in the same way

418
00:13:12,070 --> 00:13:13,180
0,180 180,360 360,690 690,900 900,1110
as if there was not

419
00:13:13,180 --> 00:13:14,470
0,60 60,450 450,660 660,930 930,1290
a distributed file system,| basically
|基本上是单一文件系统。

420
00:13:14,470 --> 00:13:15,480
0,300 300,570 570,900
single file system.|
|

421
00:13:16,990 --> 00:13:23,800
0,600 630,1230 1260,1920 1950,6300 6300,6810
Again in GFS, {there,is} {basically,a,little,bit,of}
同样，在GFS中，基本上有一些库

422
00:13:23,800 --> 00:13:25,600
0,540 540,690 690,990 990,1290 1290,1800
library| you know actually application
|您知道，实际上应用程序用于读取或写入文件，

423
00:13:25,600 --> 00:13:26,800
0,510 510,660 660,840 840,930 930,1200
used to read or write

424
00:13:26,800 --> 00:13:28,660
0,630 840,1080 1080,1500 1500,1710 1710,1860
files,| {} {in,GFS -}, but
|在政府飞行服务队，但它根本不是百分之百的关税兼容。

425
00:13:28,660 --> 00:13:29,950
0,60 60,180 180,510 510,990 990,1290
it was not one hundred

426
00:13:29,950 --> 00:13:31,480
0,300 300,540 540,1110 1110,1200 1200,1530
percent duties compatible at all.|
|

427
00:13:32,640 --> 00:13:33,540
0,150 150,540 570,720 720,780 780,900
{} So let me give
所以让我给你一个感觉，

428
00:13:33,540 --> 00:13:34,470
0,60 60,120 120,480 480,720 720,930
you a sense,| that we
|我们知道这些工作负载确实推动了这些不同系统的设计，

429
00:13:34,470 --> 00:13:37,080
0,120 120,420 420,1230 1380,2220 2220,2610
know these workloads drives really

430
00:13:37,080 --> 00:13:38,340
0,120 120,600 600,720 720,870 870,1260
the design of these different

431
00:13:38,550 --> 00:13:39,930
0,600 600,720 720,840 840,1080 1080,1380
systems,| you know in case
|你知道，以防GFS，

432
00:13:39,930 --> 00:13:41,970
0,210 210,600 810,1140 1140,1440 1440,2040
{GFS -},| {mapreduce -} application
|驱动设计的MapReduceTM应用程序，

433
00:13:41,970 --> 00:13:43,770
0,150 150,480 480,540 540,1080 1290,1800
that drive the design, {}|
|

434
00:13:43,770 --> 00:13:45,390
0,330 330,630 630,1050 1080,1200 1200,1620
in case of you know
如果您从Frangipani知道，或者共享文件系统是在共享文件系统上工作的用户的集合，

435
00:13:45,420 --> 00:13:46,440
0,180 180,570 570,720 720,810 810,1020
from Frangipani or the shared

436
00:13:46,440 --> 00:13:47,610
0,210 210,450 450,570 570,810 810,1170
file system is a collection

437
00:13:47,610 --> 00:13:49,590
0,60 60,540 570,1320 1470,1620 1620,1980
of users working on shared

438
00:13:49,590 --> 00:13:50,730
0,300 300,630 630,750 750,1020 1020,1140
file system,| but most of
|但你知道，他们执行的大多数操作可能只是文件本身

439
00:13:50,730 --> 00:13:52,560
0,90 90,840 840,1290 1290,1560 1560,1830
the operations {you,know} their performing

440
00:13:52,650 --> 00:13:54,480
0,390 390,600 660,1170 1170,1380 1380,1830
probably just files day own|
|

441
00:13:54,540 --> 00:13:56,900
0,720 720,840 1470,1830 1830,2220
{} and performed locally.|
并在当地演出。|

442
00:13:57,900 --> 00:13:59,070
0,240 240,420 420,720 720,900 900,1170
That makes sense in terms
这在环境的对比度方面是有意义的，

443
00:13:59,070 --> 00:14:00,990
0,240 240,870 870,1050 1050,1650 1710,1920
of contrast in settings,| so
|因此，您可以看到，实际上有非常不同数量的文件系统，

444
00:14:00,990 --> 00:14:01,710
0,120 120,300 300,540 540,660 660,720
you see actually there are

445
00:14:01,710 --> 00:14:02,640
0,180 180,270 270,600 600,870 870,930
quite a different number of

446
00:14:02,640 --> 00:14:04,680
0,270 270,630 630,1080 1320,1860 1860,2040
file systems around,| {like,zookeeper} yet
|像ZooKeeper还有另一种类型提供文件系统接口，

447
00:14:04,680 --> 00:14:06,330
0,300 300,510 510,630 960,1410 1410,1650
another sort of provides file

448
00:14:06,330 --> 00:14:07,380
0,270 270,660 660,750 750,840 840,1050
system interface,| but it's not
|但它并不是真正的文件系统，

449
00:14:07,380 --> 00:14:08,670
0,180 180,270 270,510 510,930 930,1290
really a file system,| it's
|它更像是一种协调服务，

450
00:14:08,670 --> 00:14:10,050
0,180 180,690 690,1200 1200,1290 1290,1380
like more intended as a

451
00:14:10,050 --> 00:14:11,550
0,510 510,870 870,960 960,1170 1170,1500
coordination service,| you wouldn't store
|你不会在动物园管理员里存储大文件的。

452
00:14:11,550 --> 00:14:13,380
0,210 210,840 1020,1440 1440,1650 1650,1830
big files {} in {zookeeper

453
00:14:13,380 --> 00:14:13,960
0,390
-}.|
|

454
00:14:16,130 --> 00:14:18,590
0,240 240,570 570,780 780,1320 1680,2460
Any questions about this {}
对这个设置有什么问题吗？

455
00:14:18,920 --> 00:14:19,960
0,630
setting?|
|

456
00:14:20,220 --> 00:14:21,560
0,480

457
00:14:21,780 --> 00:14:23,700
0,210 210,390 390,630 630,1530 1560,1920
{} Can you briefly repeat
您能简单重复一下为什么在客户机上运行文件服务器代码可以增强可伸缩性吗？

458
00:14:23,700 --> 00:14:25,080
0,270 270,600 600,750 750,990 990,1380
why having the file server

459
00:14:25,080 --> 00:14:26,490
0,330 330,600 600,870 870,990 990,1410
code running on the client

460
00:14:26,490 --> 00:14:29,880
0,540 1290,2010 2010,2340 2340,3150
machine enhances {} scalability,|
|

461
00:14:30,110 --> 00:14:31,250
0,360 360,630 630,690 690,1050 1050,1140
versus having the client and
而不是让客户端和文件服务器

462
00:14:31,250 --> 00:14:32,810
0,90 90,270 270,780 1050,1380 1380,1560
the file server| being on
|在不同的机器或不同的机器上。

463
00:14:32,810 --> 00:14:34,490
0,270 270,750 930,1140 1140,1260 1260,1680
different machines or on different.|
|

464
00:14:34,490 --> 00:14:35,420
0,390

465
00:14:35,840 --> 00:14:36,680
0,210 210,360 360,420 420,720 720,840
Yeah, so, for example if
是的，举个例子，如果你想回到上一张幻灯片，

466
00:14:36,680 --> 00:14:37,880
0,600 600,750 750,810 810,960 960,1200
you'd like to go back

467
00:14:37,880 --> 00:14:39,650
0,90 90,390 420,870 870,1170 1170,1770
to this previous slide here,|
|

468
00:14:39,650 --> 00:14:40,610
0,150 150,270 270,600 600,690 690,960
on the left the network
在左侧是网络文件系统，

469
00:14:40,610 --> 00:14:41,930
0,240 240,720 720,930 930,1050 1050,1320
file system go,| so there's
|所以有很多客户，

470
00:14:41,930 --> 00:14:43,820
0,240 240,420 420,630 630,1290 1440,1890
many many many clients,| let's
|我们假设只有一个人，

471
00:14:43,820 --> 00:14:45,470
0,300 300,480 480,720 720,1170 1200,1650
figure there's only one,| there's
|让我把这张图简化一下

472
00:14:45,470 --> 00:14:46,550
0,120 120,240 240,690 690,840 840,1080
let me simplify this picture

473
00:14:46,550 --> 00:14:48,350
0,90 90,120 120,480 870,1200 1230,1800
for a second| and ignore
|并忽略第二文件服务器、一个文件服务器

474
00:14:48,350 --> 00:14:49,430
0,90 90,360 360,570 570,900 900,1080
the second file server, one

475
00:14:49,430 --> 00:14:50,720
0,270 270,540 540,810 810,990 990,1290
one file server,| so everybody
|这样每个人都可以共享文件服务器上的文件，

476
00:14:50,720 --> 00:14:51,770
0,90 90,330 330,420 420,810 900,1050
can share the files from

477
00:14:51,770 --> 00:14:53,060
0,120 120,360 360,750 900,1140 1140,1290
the file server,| then all
|然后所有这些客户端都将在该单一文件服务器上处理，

478
00:14:53,060 --> 00:14:54,290
0,210 210,630 630,750 750,840 840,1230
these clients will be handling

479
00:14:54,290 --> 00:14:55,640
0,120 120,390 390,720 720,990 990,1350
on that single file server,|
|

480
00:14:56,300 --> 00:14:57,200
0,270 270,450 450,690 690,840 840,900
and so {all,the} read or
因此所有的读或写操作都将被发送到文件服务器，

481
00:14:57,200 --> 00:14:58,250
0,240 240,630 630,720 720,990 990,1050
write operations are going to

482
00:14:58,250 --> 00:14:58,970
0,90 90,300 300,360 360,450 450,720
be sent to the file

483
00:14:58,970 --> 00:15:00,980
0,510 510,600 600,840 840,1200 1440,2010
server,| the file server directory
|文件服务器目录查找，

484
00:15:00,980 --> 00:15:04,070
0,630 660,1530 1950,2130 2130,2460 2460,3090
lookout,| {} it opens files
|它可以打开文件并调整安全检查

485
00:15:04,070 --> 00:15:05,780
0,90 90,390 390,840 840,1470 1530,1710
and adjust security checks| and
|诸如此类的事情，

486
00:15:05,780 --> 00:15:06,410
0,120 120,210 210,360 360,420 420,630
all that kind of stuff,|
|

487
00:15:06,410 --> 00:15:07,910
0,90 90,270 270,360 360,1080 1080,1500
so all the computation really
所以所有的计算实际上都是针对文件系统本身，

488
00:15:07,910 --> 00:15:09,590
0,600 630,720 720,1020 1020,1320 1320,1680
for the file system itself,|
|

489
00:15:09,590 --> 00:15:11,030
0,90 90,270 270,870 1080,1350 1350,1440
it's all happening on the
在传统的网络文件系统设计中，这一切都发生在文件服务器本身上，

490
00:15:11,030 --> 00:15:12,800
0,240 240,480 480,990 1020,1410 1410,1770
file server itself in the

491
00:15:12,830 --> 00:15:14,510
0,570 570,840 840,1020 1020,1290 1290,1680
traditional network file system design,|
|

492
00:15:14,840 --> 00:15:15,710
0,240 240,300 300,510 510,780 780,870
in the {Frangipani - -},
在蛋黄中，情况并非如此，

493
00:15:15,710 --> 00:15:17,090
0,240 240,390 390,450 450,990 1320,1380
that's not the case,| in
|在Frangipani中，所有文件系统操作都在工作站上执行。

494
00:15:17,090 --> 00:15:18,050
0,240 240,540 540,690 690,870 870,960
{Frangipani - -} all the

495
00:15:18,050 --> 00:15:19,670
0,210 210,450 450,990 990,1110 1110,1620
file system operations are executed

496
00:15:19,670 --> 00:15:20,820
0,150 150,240 240,1080
on the workstations.|
|

497
00:15:21,260 --> 00:15:22,820
0,210 210,450 450,750 750,1020 1020,1560
And so we have multiple
因此我们有多个工作站

498
00:15:22,820 --> 00:15:24,350
0,750 750,840 840,1320 1320,1380 1380,1530
workstations| are basically you know
|您是否基本上知道文件系统可以扩展的工作负载

499
00:15:24,350 --> 00:15:26,150
0,240 240,960 960,1110 1110,1200 1200,1800
the workload that the {file,system}

500
00:15:26,150 --> 00:15:27,260
0,120 120,660 660,870 870,960 960,1110
can scale| or it can
|或者，它可以支持随着工作站数量的增加而扩展。

501
00:15:27,260 --> 00:15:28,430
0,450 450,780 780,900 900,990 990,1170
support scales with the number

502
00:15:28,430 --> 00:15:29,540
0,90 90,870
of workstations.|
|

503
00:15:31,330 --> 00:15:32,230
0,210 210,420 420,570 570,690 690,900
I see, and then be
我明白了，然后成为一个传统的建筑，

504
00:15:32,230 --> 00:15:34,600
0,270 270,1230 1260,1800 1800,2130 2130,2370
a traditional architecture,| so every
|因此，每个文件服务器都包含或存储

505
00:15:34,600 --> 00:15:37,240
0,180 180,510 510,1170 1170,1620 1950,2640
file server contains or stores,|
|

506
00:15:37,240 --> 00:15:38,740
0,330 330,540 540,660 660,1140 1140,1500
let's say a section of
让我们假设整个文件系统的一部分权利，

507
00:15:38,800 --> 00:15:40,390
0,420 450,660 660,1050 1050,1290 1290,1590
the the entire file system

508
00:15:40,390 --> 00:15:41,680
0,210 210,450 450,840 840,1050 1050,1290
right,| so it so it's
|因此，并不是每个文件服务器都有整个系统的副本，

509
00:15:41,680 --> 00:15:42,820
0,180 180,270 270,540 540,870 870,1140
not the case that {}

510
00:15:43,260 --> 00:15:44,880
0,300 300,540 540,780 780,1110 1110,1620
every single file server has

511
00:15:44,880 --> 00:15:46,110
0,330 330,690 690,780 780,870 870,1230
a copy of the entire

512
00:15:46,110 --> 00:15:47,790
0,450 840,1020 1020,1290 1290,1500 1500,1680
system,| is that it might
|它可能是跨文件分区的。

513
00:15:47,790 --> 00:15:51,270
0,120 120,570 600,1140 1170,1680 1860,3480
be partitioned across files.| {Yes,,that,might,be}
|是的，这可能是对的，

514
00:15:51,270 --> 00:15:52,620
0,630 630,840 840,1080 1080,1140 1140,1350
across,| {for,example} AFS you know
|例如，AFS您知道有不同的卷

515
00:15:52,620 --> 00:15:55,650
0,420 420,600 600,870 870,1680 1860,3030
there are different volumes| and
|和文件服务器管理不同的卷

516
00:15:55,680 --> 00:15:57,720
0,300 300,720 720,1320 1320,1560 1560,2040
file servers managed different volumes|
|

517
00:15:57,720 --> 00:15:58,740
0,90 90,180 180,480 480,750 750,1020
and the data of all
麻省理工学院所有用户的数据分布在不同的卷上。

518
00:15:58,740 --> 00:16:00,510
0,390 390,840 840,1140 1140,1500 1500,1770
users MIT spread across different

519
00:16:00,510 --> 00:16:01,360
0,630
volumes.|
|

520
00:16:01,710 --> 00:16:02,910
0,210 210,390 390,480 480,1020 1050,1200
But all the data for
但是一个卷的所有数据都将是一个文件服务器，

521
00:16:02,910 --> 00:16:03,870
0,210 210,720 720,780 780,900 900,960
one volumes are going to

522
00:16:03,870 --> 00:16:05,190
0,150 150,480 480,750 750,1140 1140,1320
be one file server,| and
|因此，该文件卷命中头部，

523
00:16:05,190 --> 00:16:06,570
0,150 150,390 390,840 840,1200 1200,1380
so that file volume gets

524
00:16:06,570 --> 00:16:07,950
0,150 150,630 720,900 900,1050 1050,1380
hit head,| you know you're
|你知道你会遇到性能瓶颈。

525
00:16:07,950 --> 00:16:09,480
0,150 150,210 210,540 540,870 870,1530
going to get performance bottlenecks.|
|

526
00:16:10,000 --> 00:16:11,360
0,390 420,720 720,870 870,1050
Okay awesome, thank you.|
好的，太棒了，谢谢。|

527
00:16:13,700 --> 00:16:14,810
0,270 270,450 450,780 780,960 960,1110
Any more questions about sort
如果有更多关于这里环境的问题，

528
00:16:14,810 --> 00:16:16,850
0,90 90,330 330,780 780,1260 1290,2040
of the setting here,| before
|在我们深入了解更多的蛋黄之前。

529
00:16:16,850 --> 00:16:18,040
0,210 210,510 510,870
we dive in

530
00:16:18,300 --> 00:16:20,220
0,420 420,690 690,1170 1170,1470 1470,1920
to {} more {Frangipani -}.|
|

531
00:16:25,660 --> 00:16:26,660
0,330 330,660
Okay good.|
好的很好。|

532
00:16:26,920 --> 00:16:29,410
0,510 840,1470 1470,1800 1800,2190 2190,2490
So now the design choices
所以现在他们所做的设计选择，

533
00:16:29,410 --> 00:16:31,270
0,120 120,570 600,1170 1170,1590 1590,1860
they made,| {} immediately leads
|这立即带来了一些挑战。

534
00:16:31,270 --> 00:16:32,470
0,150 150,210 210,450 450,510 510,1200
to a number of challenges.|
|

535
00:16:33,720 --> 00:16:34,500
0,150 150,210 210,540 570,720 720,780
So I wanna talk a
所以我想谈一谈这些挑战。

536
00:16:34,500 --> 00:16:35,850
0,180 180,300 300,510 510,690 690,1350
little bit about the challenges.|
|

537
00:16:40,980 --> 00:16:44,370
0,600 600,1170 1350,2100 2160,2850 2850,3390
{} And the main one
而驱动了几乎大量设计的主要因素是

538
00:16:44,760 --> 00:16:46,530
0,120 120,540 540,990 990,1110 1110,1770
that drives almost of a

539
00:16:46,530 --> 00:16:48,330
0,240 240,360 360,450 450,1140 1290,1800
ton of the design is|
|

540
00:16:48,330 --> 00:16:49,110
0,180 180,390 390,450 450,570 570,780
let's say you have one
假设您有一台工作站，

541
00:16:49,110 --> 00:16:52,590
0,960 1620,2340 2340,2850 3060,3240 3240,3480
workstations,| workstation one, in those
|一号工作站，那时候人们有工作站

542
00:16:52,590 --> 00:16:54,750
0,360 780,1080 1080,1350 1350,1950 1950,2160
days people had workstations| and
|笔记本电脑实际上还不是真正存在的，

543
00:16:54,750 --> 00:16:56,580
0,510 510,750 750,1050 1050,1590 1590,1830
laptops were actually not not

544
00:16:56,580 --> 00:16:58,860
0,330 330,900 900,1230 1560,1950 1980,2280
really existed yet,| {} today
|今天可能会是各种各样的笔记本电脑，

545
00:16:58,860 --> 00:16:59,700
0,330 330,420 420,540 540,690 690,840
probably will be all kinds

546
00:16:59,700 --> 00:17:01,350
0,90 90,540 540,960 1260,1590 1590,1650
of laptops,| but there's a
|但是有一个工作站和一些读文件的人，

547
00:17:01,350 --> 00:17:03,420
0,750 870,1320 1320,1560 1560,1860 1860,2070
workstation {} and somebody like

548
00:17:03,420 --> 00:17:04,760
0,330 330,510 510,600 600,1200
whatever read a file,|
|

549
00:17:05,100 --> 00:17:07,080
0,330 330,630 630,750 750,1320 1830,1980
read file f whatever,| you
读取文件f不管是什么，|你知道，也许成绩数据库里有成绩档案，

550
00:17:07,080 --> 00:17:08,730
0,450 480,750 750,840 840,1170 1170,1650
know maybe the grades database

551
00:17:08,730 --> 00:17:10,350
0,120 120,180 180,420 420,870 1290,1620
with a grades file,| and
|基本上，这意味着该文件实际上被缓存在工作站内部。

552
00:17:10,350 --> 00:17:12,330
0,600 750,1350 1350,1560 1560,1830 1830,1980
so basically, that means that

553
00:17:12,330 --> 00:17:13,950
0,210 210,570 570,810 810,900 900,1620
that file actually is cached

554
00:17:13,950 --> 00:17:15,840
0,450 450,570 570,930 960,1620
inside of the workstation.|
|

555
00:17:16,340 --> 00:17:17,450
0,270 270,360 360,570 570,1020 1020,1110
And so the client you
因此，无论运行VI的程序是什么，客户端，

556
00:17:17,450 --> 00:17:20,030
0,150 150,630 630,990 990,1440 1830,2580
know whatever program running VI,|
|

557
00:17:20,030 --> 00:17:21,260
0,120 120,270 270,420 420,660 720,1230
you know get to update
你知道，你可以更新和操作文件，

558
00:17:21,260 --> 00:17:23,510
0,120 120,840 840,1110 1140,1770 2010,2250
and manipulate the file,| and
|然后晚些时候起床，

559
00:17:23,510 --> 00:17:24,680
0,360 360,450 450,540 540,900 900,1170
then get up sometime later,|
|

560
00:17:24,680 --> 00:17:25,550
0,120 120,420 420,540 540,660 660,870
the result will be written
结果将按您的方式写回磁盘的花瓣

561
00:17:25,550 --> 00:17:27,860
0,480 570,990 990,1710 1830,2310 2310,2310
back to {Petal -} the

562
00:17:27,860 --> 00:17:30,140
0,660 690,870 870,1350 1950,2160 2160,2280
disk as {you,will}| and so
|因此，这个模型面临的挑战基本上是三个缺陷，

563
00:17:30,140 --> 00:17:32,210
0,210 210,690 690,870 870,1650 1680,2070
the challenges that are basically

564
00:17:32,210 --> 00:17:33,500
0,300 300,420 420,690 690,840 840,1290
around this model are {3,faults},|
|

565
00:17:33,980 --> 00:17:36,650
0,690 720,1440 1650,1980 1980,2340 2340,2670
{} one, {} somebody else
一台，另一台工作站2可能会在某一时刻做一种f，

566
00:17:36,650 --> 00:17:37,980
0,90 90,570 570,1080
{} workstation two

567
00:17:38,750 --> 00:17:39,620
0,330 330,480 480,600 600,810 810,870
maybe {at -} some point

568
00:17:39,620 --> 00:17:40,730
0,240 240,360 360,570 570,690 690,1110
do a kind of f,|
|

569
00:17:41,870 --> 00:17:43,880
0,510 510,600 600,990 990,1380 1680,2010
get the file f| and
获取文件%f|当然，情况应该是这样的

570
00:17:43,880 --> 00:17:44,960
0,60 60,360 360,840 840,990 990,1080
of course it should be

571
00:17:44,960 --> 00:17:46,280
0,60 60,390 390,600 600,720 720,1320
the case that| you know
|你知道，至少在正常情况下，我们有一个传统的Unix文件系统，

572
00:17:46,280 --> 00:17:48,380
0,180 180,480 690,1440 1440,1950 1950,2100
at least normally expected we

573
00:17:48,380 --> 00:17:49,580
0,150 150,240 240,720 720,960 960,1200
have a traditional Unix file

574
00:17:49,580 --> 00:17:51,290
0,510 780,1170 1170,1290 1290,1560 1560,1710
system,| that you know you
|你知道你会看到对那个特定的f的最后一次写入，

575
00:17:51,290 --> 00:17:52,490
0,150 150,300 300,420 420,780 780,1200
will see the last write

576
00:17:52,730 --> 00:17:53,990
0,150 150,360 360,720 720,1050 1080,1260
to that particular f,| so
|因此，即使写入可能发生在不同的工作站上，

577
00:17:53,990 --> 00:17:55,070
0,270 270,600 600,750 750,960 960,1080
even though the write might

578
00:17:55,070 --> 00:17:55,880
0,90 90,390 390,510 510,540 540,810
have happened at a different

579
00:17:55,880 --> 00:17:57,950
0,750 990,1410 1410,1650 1650,1800 1800,2070
workstation,| {} when the second
|当第二工作站读取该文件时，

580
00:17:57,950 --> 00:17:59,930
0,780 780,960 960,1050 1050,1530 1680,1980
workstation reads the file, {}|
|

581
00:17:59,930 --> 00:18:01,310
0,660 660,810 810,960 960,1050 1050,1380
we would like to see
我们希望看到数据显示出来，

582
00:18:01,310 --> 00:18:03,590
0,1020 1020,1290 1290,1530 1530,1800 2130,2280
that data show up,| and
|这就是他们将会是什么样子，

583
00:18:03,590 --> 00:18:04,700
0,120 120,180 180,300 300,780 810,1110
this is what they were

584
00:18:04,700 --> 00:18:06,500
0,120 120,180 180,420 480,1230 1590,1800
going to be roughly,| this
|这大致归结为高速缓存一致性，

585
00:18:06,500 --> 00:18:07,700
0,390 390,630 630,810 810,1080 1080,1200
roughly comes to cache {coherence

586
00:18:07,700 --> 00:18:08,440
0,210 210,510
- -},|
|

587
00:18:10,800 --> 00:18:12,720
0,300 300,540 540,900 900,1470 1470,1920
and other words synonyms for
换言之，一致性的同义词是高速缓存一致性，

588
00:18:12,720 --> 00:18:15,450
0,570 570,810 810,1080 1080,2130 2280,2730
coherence are cache consistency,| which
|这就像我们在之前的论文中看到的更多的术语，

589
00:18:15,450 --> 00:18:16,740
0,120 120,270 270,360 360,750 750,1290
is like the term we've

590
00:18:16,740 --> 00:18:18,900
0,240 240,900 1500,1740 1740,1860 1860,2160
seen more in the previous

591
00:18:18,900 --> 00:18:20,490
0,480 720,1020 1020,1260 1260,1470 1470,1590
papers,| {} but in the
|但在某种程度上脱离了计算机体系结构的世界，

592
00:18:20,490 --> 00:18:21,660
0,180 180,420 780,1020 1020,1110 1110,1170
sort of out of the

593
00:18:21,660 --> 00:18:23,370
0,300 300,780 780,1080 1080,1410 1410,1710
computer architecture world,| actually the
|实际上，连贯这个术语来自于那个世界。

594
00:18:23,370 --> 00:18:25,530
0,120 120,480 480,900 900,1320 1320,2160
the term coherence comes, {}

595
00:18:26,190 --> 00:18:27,940
0,210 210,360 360,750 780,1620
comes from that world.|
|

596
00:18:28,410 --> 00:18:29,280
0,270 270,480 480,630 630,750 750,870
And so you can think
所以你可以把它们想象成同义词。

597
00:18:29,280 --> 00:18:30,940
0,240 240,360 360,1050 1050,1440
about them as synonyms.|
|

598
00:18:32,660 --> 00:18:34,670
0,390 390,1170 1200,1320 1320,1620 1620,2010
{} Two, the second problem
第二，你所知道的即将发生的第二个问题

599
00:18:34,670 --> 00:18:36,590
0,210 210,330 330,540 540,930 1230,1920
that you know you {}

600
00:18:36,710 --> 00:18:38,180
0,480 480,600 600,690 690,1260 1260,1470
that's going to occur| and
|我们需要处理的是，

601
00:18:38,180 --> 00:18:39,020
0,150 150,300 300,360 360,600 600,840
we need to deal with

602
00:18:39,020 --> 00:18:40,340
0,300 300,600 690,960 960,1110 1110,1320
is that,| let's say that
|假设工作站1和工作站2都想要在共享目录中创建文件，

603
00:18:40,340 --> 00:18:42,060
0,540 540,1140
workstation one

604
00:18:42,770 --> 00:18:44,870
0,330 330,840 840,1410 1590,1980 1980,2100
and workstation two both want

605
00:18:44,870 --> 00:18:45,950
0,60 60,300 300,360 360,930 930,1080
to create a file in

606
00:18:45,950 --> 00:18:48,350
0,600 600,870 870,1350 1350,1710 1830,2400
the shared directory,| so here's
|所以这里的工作站1在目录d中创建了一个文件f，

607
00:18:49,010 --> 00:18:50,660
0,600 600,810 810,1110 1110,1170 1170,1650
workstation one creates a file

608
00:18:50,690 --> 00:18:52,220
0,510 510,630 630,720 720,1110 1110,1530
f in the directory d,|
|

609
00:18:52,310 --> 00:18:54,500
0,900 1110,1530 1530,1800 1800,2100 2100,2190
workstation two also creates a
工作站2还在目录d中创建文件g和。

610
00:18:54,500 --> 00:18:56,870
0,330 330,1080 1260,1770 1770,1980 1980,2370
file g and in directory

611
00:18:56,870 --> 00:18:57,420
0,360
d.|
|

612
00:18:57,910 --> 00:18:58,930
0,330 420,630 630,750 750,900 900,1020
And now we want to
现在我们希望至少安排在1号工作站进行更改

613
00:18:58,930 --> 00:19:00,550
0,330 330,780 780,930 930,1200 1200,1620
be arranged at least at

614
00:19:00,550 --> 00:19:02,350
0,450 450,660 660,900 900,1290 1320,1800
workstation 1 makes the changes|
|

615
00:19:02,350 --> 00:19:03,460
0,90 90,210 210,630 630,840 840,1110
and then workstation 2 makes
然后工作站2进行改变，

616
00:19:03,460 --> 00:19:05,260
0,60 60,480 870,1260 1260,1500 1500,1800
the changes,| like both files
|我喜欢这里的两个文件

617
00:19:05,260 --> 00:19:06,580
0,450 510,750 750,900 900,1050 1050,1320
here| and that like one
|就像一个文件不会被覆盖一样，

618
00:19:06,580 --> 00:19:09,040
0,270 270,510 510,1170 1470,2160 2160,2460
file doesn't overwrite,| say the
|说出对方的通讯录

619
00:19:09,040 --> 00:19:12,220
0,780 780,1770 1800,1920 1920,2820 2820,3180
directory of the other| or
|或者以实际上其他文件消失的方式直接覆盖。

620
00:19:12,250 --> 00:19:13,510
0,300 300,540 540,870 870,1200 1200,1260
this {overwrite -} directly in

621
00:19:13,510 --> 00:19:14,620
0,60 60,270 270,480 480,810 810,1110
a way that actually other

622
00:19:14,620 --> 00:19:15,920
0,390 390,930
files disappears.|
|

623
00:19:16,350 --> 00:19:17,100
0,210 210,390 390,570 570,660 660,750
So this has to do
所以这就是第二个主题，

624
00:19:17,100 --> 00:19:18,450
0,330 330,570 570,900 900,1110 1110,1350
the second topic,| {} really
|真正的是原子性，

625
00:19:18,450 --> 00:19:19,900
0,210 210,270 270,420 420,750
is {atomicity - -},|
|

626
00:19:22,980 --> 00:19:24,930
0,420 420,1140 1140,1440 1440,1530 1530,1950
these operations creating a file,|
这些操作创建文件，|

627
00:19:24,930 --> 00:19:25,590
0,90 90,270 270,420 420,510 510,660
{} really have to be
真的必须是某种原子操作，

628
00:19:25,590 --> 00:19:26,790
0,840 840,900 900,990 990,1140 1140,1200
has to be sort of

629
00:19:26,790 --> 00:19:28,260
0,60 60,450 450,1020 1020,1260 1260,1470
an atomic operation,| so they
|这样它们就不会交错，

630
00:19:28,260 --> 00:19:29,400
0,210 210,390 390,870 870,1050 1050,1140
don't get interleaved,| then we
|那么我们得到的结果是错误的。

631
00:19:29,400 --> 00:19:31,000
0,150 180,840 840,1350
get wrong results.|
|

632
00:19:32,300 --> 00:19:33,500
0,120 120,210 210,300 300,600 600,1200
And then the final problem,|
然后是最后一个问题，|

633
00:19:33,890 --> 00:19:35,120
0,390 390,900 900,1020 1020,1170 1170,1230
{} that we need to
我们需要处理的是

634
00:19:35,120 --> 00:19:37,040
0,210 210,420 420,660 660,1140 1260,1920
deal with is that {}|
|

635
00:19:37,040 --> 00:19:38,900
0,60 60,270 270,780 780,1290
{} {you,know} workstation 1,
你知道1号工作站，你知道可能会崩溃

636
00:19:40,060 --> 00:19:42,670
0,120 120,390 390,1170 1200,1890 1890,2610
{you,know} might crash| while doing
|同时执行这些复杂的文件系统操作之一。

637
00:19:42,820 --> 00:19:43,930
0,240 240,330 330,480 480,870 870,1110
one of these complex file

638
00:19:43,930 --> 00:19:45,220
0,270 270,1080
system operations.|
|

639
00:19:50,160 --> 00:19:51,120
0,180 180,480 480,720 720,870 870,960
And so it has to
所以它必须是故事，

640
00:19:51,120 --> 00:19:52,290
0,120 120,660 660,720 720,900 900,1170
be story,| you know how
|您知道文件系统实际上是如何恢复的。

641
00:19:52,290 --> 00:19:54,390
0,450 450,720 720,1020 1020,1440 1440,2100
actually the file system recovers.|
|

642
00:19:55,140 --> 00:19:56,250
0,300 300,510 510,690 690,840 840,1110
And so this is really
因此，这实际上是一个关于崩溃恢复的故事。

643
00:19:56,250 --> 00:19:57,660
0,60 60,360 360,600 600,870 870,1410
a story about crash recovery.|
|

644
00:20:01,990 --> 00:20:02,950
0,150 150,240 240,690 690,870 870,960
So, for example like in
举个例子，就像第一个例子

645
00:20:02,950 --> 00:20:04,240
0,120 120,390 390,660 660,960 960,1290
this first case| where like
|其中类似于工作站生成文件和目录D，

646
00:20:04,270 --> 00:20:05,980
0,450 450,1050 1050,1260 1260,1350 1350,1710
{} workstation makes a file

647
00:20:05,980 --> 00:20:07,960
0,180 180,720 720,1260 1440,1740 1740,1980
and directory d,| there's actually
|实际上，这是一个复杂的操作，

648
00:20:07,960 --> 00:20:09,310
0,30 30,450 450,1080 1080,1140 1140,1350
a complex operation,| you know
|您知道目录需要修改，

649
00:20:09,310 --> 00:20:10,180
0,120 120,480 480,690 690,780 780,870
the directory needs to be

650
00:20:10,180 --> 00:20:11,590
0,750 750,870 870,1020 1020,1200 1200,1410
modified,| and {inode -} needs
|并且需要分配索引节点

651
00:20:11,590 --> 00:20:12,730
0,90 90,210 210,810 810,1050 1050,1140
to be allocated| and {inode
|和要初始化的inode

652
00:20:12,730 --> 00:20:14,650
0,180 180,240 240,360 360,1170 1380,1920
-} to be initialized {}|
|

653
00:20:14,650 --> 00:20:15,460
0,120 120,240 240,330 330,600 600,810
and then the inode number
然后需要将索引节点号写入目录，

654
00:20:15,460 --> 00:20:16,450
0,210 210,270 270,420 420,660 660,990
needs to be written into

655
00:20:16,450 --> 00:20:18,010
0,90 90,660 750,900 900,1050 1050,1560
the directory,| so there's multiple
|因此它涉及多种类型的文件系统操作

656
00:20:18,010 --> 00:20:19,120
0,150 150,210 210,450 450,690 690,1110
sort of file system operations

657
00:20:19,120 --> 00:20:20,050
0,390 390,480 480,630 630,750 750,930
involved in it| and we
|我们希望成为这样的情况

658
00:20:20,050 --> 00:20:20,830
0,270 270,330 330,420 420,510 510,780
wanted to be the case

659
00:20:20,830 --> 00:20:21,910
0,210 210,540 540,600 600,870 870,1080
that| if the file system
|如果文件系统在上述任一步骤之间崩溃

660
00:20:21,910 --> 00:20:23,800
0,480 480,870 870,1200 1200,1410 1410,1890
crashes between any of these

661
00:20:24,040 --> 00:20:25,630
0,960 1050,1260 1260,1350 1350,1530 1530,1590
steps| in this sort of
|在这种复杂的文件系统操作中，

662
00:20:25,630 --> 00:20:27,340
0,330 330,570 570,810 810,1410 1500,1710
complex file system operation,| there
|最好有这样的情况

663
00:20:27,340 --> 00:20:28,150
0,180 180,300 300,390 390,690 690,810
better be the case that|
|

664
00:20:28,150 --> 00:20:29,140
0,90 90,330 330,570 570,690 690,990
the file system {recovers -}
文件系统恢复正常。

665
00:20:29,140 --> 00:20:29,720
0,510
correctly.|
|

666
00:20:30,170 --> 00:20:30,890
0,240 240,420 420,480 480,540 540,720
And what {we -} mean,|
我们的意思是，|

667
00:20:30,890 --> 00:20:32,240
0,90 90,300 300,600 600,1200 1200,1350
we file {something,recover} correctly,| at
如果我们提交了一些正确的恢复文件，|至少它的内部数据结构是正确的

668
00:20:32,240 --> 00:20:33,830
0,210 210,480 480,900 900,1140 1140,1590
least its internal data structures

669
00:20:33,830 --> 00:20:35,090
0,90 90,600 900,1110 1110,1200 1200,1260
are correct| and so for
|因此，例如索引节点不会丢失，

670
00:20:35,090 --> 00:20:36,080
0,330 330,600 600,720 720,840 840,990
example the {inode -} does

671
00:20:36,080 --> 00:20:37,160
0,180 180,540 540,780 780,840 840,1080
not lost,| because it doesn't
|因为它不会显示在目录中，等等

672
00:20:37,160 --> 00:20:38,270
0,210 210,330 330,450 450,510 510,1110
show up in the directory,

673
00:20:38,570 --> 00:20:40,430
0,690 690,1200 1230,1470 1470,1620 1620,1860
etc etc| or like even
|或者，甚至整个内部结构都是一致的。

674
00:20:40,430 --> 00:20:41,540
0,150 150,570 570,690 690,780 780,1110
the whole of the internal

675
00:20:41,540 --> 00:20:42,900
0,450 450,510 510,1140
structures are consistent.|
|

676
00:20:43,640 --> 00:20:44,450
0,180 180,360 360,420 420,510 510,810
So this is the topic
这就是反腐的主题

677
00:20:44,450 --> 00:20:46,460
0,90 90,390 390,930 1770,1920 1920,2010
of corruption recover| and so
|所以Petal基本上是在Frangipani需要解决所有这些问题

678
00:20:46,460 --> 00:20:47,750
0,300 300,750 750,1020 1020,1080 1080,1290
Petal basically were in {Frangipani

679
00:20:47,750 --> 00:20:49,070
0,90 90,210 210,510 510,720 720,1320
- -} need to address

680
00:20:49,100 --> 00:20:52,010
0,420 420,750 1110,1800 1800,2250 2250,2910
all these problems| and my
|我的计划是一个接一个地走进去，

681
00:20:52,040 --> 00:20:54,710
0,330 330,540 540,990 1320,2040 2130,2670
{plan,is} just go {} walk

682
00:20:54,710 --> 00:20:55,910
0,180 180,570 600,810 810,1050 1050,1200
through in {} one by

683
00:20:55,910 --> 00:20:57,890
0,570 570,1140 1140,1500 1500,1650 1650,1980
one,| and discuss how {Frangipani
|并讨论Frangipani如何解决这些问题。

684
00:20:57,890 --> 00:20:59,200
0,420 420,900 900,1050
-} addresses them.|
|

685
00:21:00,520 --> 00:21:01,630
0,390 390,690 690,840 840,900 900,1110
Any questions about the top
对顶级挑战赛有什么问题吗？

686
00:21:01,630 --> 00:21:02,980
0,210 210,1080
level challenges?|
|

687
00:21:09,820 --> 00:21:11,900
0,420 420,990 990,1200 1200,1770
Okay, let's {you,know} proceed.|
好的，让我们知道，开始吧。|

688
00:21:12,030 --> 00:21:12,900
0,300 300,360 360,600 600,750 750,870
So the first thing is
因此，第一件事是缓存一致性或缓存一致性。

689
00:21:12,900 --> 00:21:15,510
0,300 300,960 1290,1530 1530,1770 1770,2610
caching coherence or cache consistency.|
|

690
00:21:27,740 --> 00:21:29,120
0,570 570,1080
And, {}
因此，解决方案中的关键方面是

691
00:21:29,790 --> 00:21:32,610
0,330 330,960 1080,1860 1980,2670 2670,2820
so the key aspect in

692
00:21:32,610 --> 00:21:35,280
0,330 330,840 840,1290 1290,2340 2460,2670
the solution that| {} {Frangipani
|实际上，鸡蛋花在某个地方使用的是锁服务器，

693
00:21:35,280 --> 00:21:36,690
0,60 60,270 270,840 840,1260 1260,1410
- -} uses actually a

694
00:21:36,690 --> 00:21:37,960
0,240 240,540 540,990
lock server somewhere,|
|

695
00:21:38,580 --> 00:21:40,360
0,1110
{and,so},
因此，锁服务器基本上有一个表

696
00:21:40,670 --> 00:21:43,100
0,360 360,450 450,660 660,1320
and the lock server

697
00:21:43,790 --> 00:21:47,810
0,780 780,840 840,1620 2220,2790 2790,4020
{basically,has} a table| and for
|并且对于每个文件和每个文件的实际索引节点号，

698
00:21:47,840 --> 00:21:49,340
0,270 270,660 660,930 930,1320 1320,1500
every file and actually {inode

699
00:21:49,340 --> 00:21:50,390
0,240 240,570 570,690 690,840 840,1050
-} number {} for every

700
00:21:50,390 --> 00:21:51,220
0,570
file,|
|

701
00:21:51,760 --> 00:21:53,710
0,1110 1110,1410 1410,1530 1530,1860 1860,1950
who has to lock at
谁必须在这个特定的时间点锁定，

702
00:21:53,710 --> 00:21:54,850
0,150 150,660 660,840 840,900 900,1140
this particular point of time,|
|

703
00:21:54,850 --> 00:21:56,140
0,150 150,360 360,480 480,930
so who's the owner.|
那么谁是车主呢。|

704
00:21:58,070 --> 00:21:58,850
0,300 300,390 390,600 600,690 690,780
So we might have to
所以我们可能要把f

705
00:21:58,850 --> 00:22:00,140
0,300 300,630 660,810 810,930 930,1290
file f| and it basically
|它基本上是说你知道工作，并且网络服务器有一台工作站的记录，

706
00:22:00,140 --> 00:22:01,370
0,330 330,420 420,570 570,900 900,1230
says you know works and

707
00:22:01,370 --> 00:22:03,200
0,90 90,570 1110,1380 1380,1530 1530,1830
for which the web server

708
00:22:03,200 --> 00:22:04,070
0,150 150,210 210,540 540,630 630,870
has a record of the

709
00:22:04,070 --> 00:22:05,840
0,480 480,840 840,1080 1080,1230 1230,1770
workstation one,| owns that particular
|拥有那把特别的锁，

710
00:22:05,840 --> 00:22:08,480
0,450 1200,1800 1800,2280 2280,2340 2340,2640
lock,| {} and the locks
|而锁本身就是一个分布式服务，

711
00:22:08,480 --> 00:22:10,220
0,120 120,180 180,870 930,1200 1200,1740
are for itself {} is

712
00:22:10,220 --> 00:22:13,580
0,150 150,1020 1050,1830 1830,2430 3150,3360
a distributed {} service, {}|
|

713
00:22:13,580 --> 00:22:14,690
0,240 240,360 360,630 630,780 780,1110
you can almost think about
你几乎可以把它想象成动物园管理员，

714
00:22:14,690 --> 00:22:16,280
0,480 480,900 900,1020 1020,1200 1200,1590
it almost like {zookeeper -},|
|

715
00:22:16,310 --> 00:22:19,040
0,870 870,1110 1560,2160 2160,2310 2310,2730
{you,know} it's, {} it provides
你知道它是，它提供了一个获取释放锁，

716
00:22:19,040 --> 00:22:21,410
0,150 150,660 660,1020 1020,1710 1800,2370
an acquire release locks, {}|
|

717
00:22:21,410 --> 00:22:23,300
0,330 330,570 570,1260 1260,1530 1530,1890
it's fault tolerant,| {} in
它是容错的，|在Frangipani使用基于Paxos的实现的情况下，

718
00:22:23,300 --> 00:22:24,650
0,60 60,330 330,600 600,1140 1170,1350
the case of a {Frangipani

719
00:22:24,650 --> 00:22:26,060
0,360 360,600 600,840 840,930 930,1410
-} either use {} {Paxos

720
00:22:26,060 --> 00:22:29,000
0,480 510,1050 1050,1860 2190,2670 2670,2940
-} based implementation,| {} and
|以及分布在多台机器上的高容错性等。

721
00:22:29,000 --> 00:22:30,530
0,150 150,390 420,840 840,1170 1170,1530
what is spread across multiple

722
00:22:30,530 --> 00:22:33,080
0,660 720,1260 1260,1590 1590,1770 1770,2550
machines {} highly fault tolerance,

723
00:22:33,230 --> 00:22:34,900
0,1110 1110,1590
etc, etc.|
|

724
00:22:36,390 --> 00:22:39,540
0,270 270,540 540,1200 1290,2010 2310,3150
So that's the the the
这就是锁服务器

725
00:22:39,630 --> 00:22:41,550
0,540 570,990 1230,1410 1410,1710 1710,1920
lock server| and it turns
|结果是，工作站也应该为他们的锁保留一张桌子，

726
00:22:41,550 --> 00:22:42,420
0,90 90,210 210,300 300,540 540,870
out that the {workstation -}

727
00:22:42,420 --> 00:22:44,070
0,210 210,570 570,900 900,990 990,1650
should also keep a table

728
00:22:44,310 --> 00:22:45,680
0,870
for

729
00:22:46,040 --> 00:22:47,960
0,300 300,930 1380,1590 1590,1710 1710,1920
their locks,| so {here's -}
|这是一号工作站

730
00:22:47,960 --> 00:22:50,060
0,480 480,990 1230,1860 1860,1950 1950,2100
workstation one| and you know
|你知道这可能是，

731
00:22:50,060 --> 00:22:51,050
0,90 90,300 300,720 750,870 870,990
it might be,| you know
|你知道，假设工作站1缓存文件f和g，

732
00:22:51,050 --> 00:22:52,700
0,180 180,450 450,870 870,1050 1050,1650
let's say workstation one cache

733
00:22:52,700 --> 00:22:55,180
0,390 420,1140 1140,1290 1290,1740
file f and g,|
|

734
00:22:55,920 --> 00:22:57,420
0,270 270,630 630,1080 1080,1410 1410,1500
{you,know} maybe h cached by
您知道，可能由工作站1高速缓存的H，

735
00:22:57,420 --> 00:23:00,510
0,810 1380,2190 2190,2820 2820,2970 2970,3090
workstation {workstation,1},| h may be
|H可以由工作站2高速缓存。

736
00:23:00,510 --> 00:23:02,160
0,330 330,390 390,870 870,1350
cached by workstation 2.|
|

737
00:23:02,700 --> 00:23:04,590
0,540 780,930 930,1320 1320,1440 1440,1890
{} And then the workstation
然后，工作站1具有类似的桌子

738
00:23:04,590 --> 00:23:06,270
0,300 300,750 750,840 840,1140 1140,1680
1 has a similar table|
|

739
00:23:06,450 --> 00:23:08,550
0,480 480,1020 1050,1500 1500,1830 1830,2100
and that list for every
以及每个锁的每个文件的列表，

740
00:23:08,550 --> 00:23:09,990
0,600 600,720 720,900 900,1260 1260,1440
file for every lock that

741
00:23:09,990 --> 00:23:12,210
0,720 750,1290 1290,1470 1470,1740 1740,2220
holds,| where it's either busy
|在忙碌或空闲的地方，

742
00:23:12,210 --> 00:23:15,060
0,240 240,720 2160,2490 2490,2700 2700,2850
or idle,| so it may
|因此，如果您知道锁定状态为忙碌，

743
00:23:15,060 --> 00:23:17,520
0,180 180,480 510,600 600,1890 1920,2460
be f you know lock

744
00:23:17,520 --> 00:23:18,960
0,330 330,450 450,990 1170,1320 1320,1440
status is busy| and it
|这实际上意味着文件服务器只是在操作该文件，

745
00:23:18,960 --> 00:23:20,340
0,270 270,600 600,810 810,1170 1170,1380
really means that actually the

746
00:23:20,340 --> 00:23:21,720
0,240 240,510 510,660 660,900 900,1380
file server is just operating

747
00:23:21,720 --> 00:23:22,770
0,90 90,270 270,660 690,870 870,1050
on that file,| so it's
|因此，它正在积极使用该文件，

748
00:23:22,770 --> 00:23:26,280
0,630 630,960 960,1110 1110,1530 2190,3510
actively using that {file -},|
|

749
00:23:26,280 --> 00:23:28,230
0,180 180,480 480,960 990,1590 1590,1950
the second state namely, let's
第二种状态是，假设我们有文件g，

750
00:23:28,230 --> 00:23:29,220
0,120 120,270 270,420 420,840 840,990
say we have {file,g},| which
|它也在那里缓存

751
00:23:29,220 --> 00:23:30,660
0,210 210,480 480,840 1050,1200 1200,1440
also cache there| and maybe
|并且可能G实际上处于呼叫空闲的状态，

752
00:23:30,660 --> 00:23:32,310
0,180 180,300 300,810 810,990 990,1650
g is actually {} {in,the,state}

753
00:23:32,310 --> 00:23:34,350
0,570 570,750 750,1260 1620,1800 1800,2040
that call idle,| {} that
|这意味着该点上的g实际上没有被修改

754
00:23:34,350 --> 00:23:35,910
0,330 330,690 690,900 900,1440 1440,1560
means actually the g at

755
00:23:35,910 --> 00:23:36,780
0,180 180,390 390,480 480,660 660,870
that point is not being

756
00:23:36,780 --> 00:23:39,360
0,750 750,930 930,930 2070,2400 2400,2580
modified| and {} were not
|并且没有被文件处理过

757
00:23:39,360 --> 00:23:41,370
0,420 630,1170 1170,1740 1740,1890 1890,2010
being worked on by the

758
00:23:41,370 --> 00:23:42,750
0,330 330,540 540,720 720,1020 1020,1380
files| for that particular instant
|对于那个特定的瞬间时间，

759
00:23:42,750 --> 00:23:44,490
0,450 720,1020 1020,1200 1200,1350 1350,1740
time,| {} but it's basically
|但这基本上就是他们所说的粘性锁。

760
00:23:44,490 --> 00:23:45,330
0,240 240,390 390,510 510,780 780,840
{} what they call a

761
00:23:45,330 --> 00:23:46,280
0,360 360,720
sticky lock.|
|

762
00:23:47,480 --> 00:23:48,980
0,300 300,570 570,1140 1170,1290 1290,1500
So that if you know
因此，如果您在不久的将来知道文件服务器，

763
00:23:48,980 --> 00:23:50,060
0,180 180,450 450,780 780,900 900,1080
the file server at some

764
00:23:50,060 --> 00:23:51,770
0,240 240,960 960,1080 1080,1320 1320,1710
point soon,| it's gonna use
|它将再次使用文件g，

765
00:23:51,770 --> 00:23:53,300
0,450 450,870 1020,1170 1170,1290 1290,1530
{file,g} again,| it can actually
|它实际上可以做到这一点，而不必真正与Petal通信

766
00:23:53,300 --> 00:23:54,470
0,180 180,510 510,780 780,990 990,1170
do so without actually having

767
00:23:54,470 --> 00:23:56,090
0,60 60,570 570,690 690,1290 1410,1620
to communicate with Petal| or
|或者重新加载它的高速缓存或任何类似的东西，

768
00:23:56,090 --> 00:23:57,560
0,420 420,540 540,1020 1020,1140 1140,1470
reload it's cache or anything

769
00:23:57,560 --> 00:23:59,060
0,330 330,420 420,720 720,1110 1170,1500
like that at all,| because
|因为它有一个粘性的锁，

770
00:23:59,060 --> 00:24:00,110
0,90 90,330 330,390 390,720 720,1050
it has a sticky lock,|
|

771
00:24:00,110 --> 00:24:01,490
0,150 150,660 660,780 780,1110 1110,1380
it knows that nobody else
它知道没有其他人真正需要，

772
00:24:01,490 --> 00:24:02,690
0,210 210,390 390,840 840,990 990,1200
actually has required,| no other
|在此期间，没有其他需要锁定的工作站。

773
00:24:02,690 --> 00:24:04,040
0,210 210,540 540,660 660,1260 1260,1350
{workstation -} as required to

774
00:24:04,040 --> 00:24:05,180
0,270 270,330 330,420 420,930
lock in the meantime.|
|

775
00:24:06,060 --> 00:24:07,890
0,360 360,690 780,1260 1260,1440 1440,1830
{} So that's the sticky
这就是粘性锁

776
00:24:07,890 --> 00:24:09,600
0,450 870,1320 1320,1410 1410,1620 1620,1710
lock| and it turns out
|事实证明，

777
00:24:09,600 --> 00:24:13,320
0,330 450,1500 1650,2490 2970,3570 3600,3720
that,| the the {} you
|你知道，这是两个大楼的锁，

778
00:24:13,320 --> 00:24:14,610
0,60 60,270 270,660 660,930 930,1290
know these are two building

779
00:24:14,610 --> 00:24:15,930
0,450 450,810 810,930 930,1110 1110,1320
locks,| that are then being
|然后习惯了他们所说的，

780
00:24:15,930 --> 00:24:17,250
0,420 420,570 570,840 840,990 990,1320
used to what they call,|
|

781
00:24:17,250 --> 00:24:18,930
0,570 570,780 780,1170 1170,1260 1260,1680
what's {} what is called
什么叫缓存一致性协议

782
00:24:18,930 --> 00:24:21,390
0,630 840,1350 1350,1680 1680,2160 2160,2460
{} cache coherence protocol| and
|和一套信息，我们是一套被遵守的规则

783
00:24:21,540 --> 00:24:22,800
0,210 210,300 300,810 810,1110 1110,1260
set of messages, we're set

784
00:24:22,800 --> 00:24:23,640
0,90 90,420 420,540 540,600 600,840
of rules that are being

785
00:24:23,640 --> 00:24:25,440
0,540 720,960 960,1380 1380,1530 1530,1800
followed| to actually {} get
|要真正获得缓存一致性

786
00:24:25,440 --> 00:24:27,900
0,240 240,960 1380,1950 1950,2070 2070,2460
cache consistency| and the basic
|基本规则是，

787
00:24:27,900 --> 00:24:30,030
0,330 330,510 510,900 1200,1980 1980,2130
rule is that,| {} you
|你知道，指导原则是缓存一个文件，

788
00:24:30,030 --> 00:24:32,310
0,300 510,1110 1110,1440 1440,1770 1770,2280
know guiding rule is to

789
00:24:32,670 --> 00:24:33,740
0,360 360,450 450,990
cache a file,|
|

790
00:24:38,890 --> 00:24:40,390
0,420 420,720 720,990 990,1410 1410,1500
you first must acquire a
你首先必须获得一把锁，

791
00:24:40,390 --> 00:24:41,640
0,450
lock,|
|

792
00:24:43,670 --> 00:24:45,710
0,210 210,390 390,1050 1050,1770 1770,2040
you'll see that rules {}
您将看到这些规则是实际获得缓存一致性或缓存一致性的垫脚石。

793
00:24:45,710 --> 00:24:48,740
0,1320 1320,1500 1500,1740 1740,2190 2430,3030
{stepping,stone} for actually getting {}

794
00:24:48,800 --> 00:24:51,050
0,240 240,1320 1320,1410 1410,1710 1710,2250
cache consistency or cache coherence.|
|

795
00:24:52,260 --> 00:24:53,010
0,150 150,450 450,510 510,660 660,750
I'm going to make a
我要做一个更小的简化，

796
00:24:53,010 --> 00:24:56,130
0,690 690,1560 1650,2550 2550,2970 2970,3120
smaller simplification,| {} in the
|在报纸上，他们描述了他们自己的锁，

797
00:24:56,130 --> 00:24:57,240
0,330 330,420 420,840 840,990 990,1110
paper, they describe their own

798
00:24:57,240 --> 00:24:59,370
0,390 390,780 780,1080 1080,1710 1710,2130
locks,| basically being exclusive or
|基本上是独占或读写锁，

799
00:24:59,370 --> 00:25:00,660
0,240 240,390 390,690 690,780 780,1290
{} {read-write -} {} locks,|
|

800
00:25:00,780 --> 00:25:01,740
0,390 390,510 510,630 630,690 690,960
I'm just going to assume
在接下来的演讲中，我只会假设，

801
00:25:01,740 --> 00:25:02,700
0,510 540,660 660,840 840,900 900,960
for the rest of the

802
00:25:02,700 --> 00:25:04,020
0,420 420,510 510,1050 1080,1140 1140,1320
lecture,| the exclusive it doesn't
|独家报道并不重要，

803
00:25:04,020 --> 00:25:05,160
0,150 150,480 510,690 690,1050 1050,1140
really matter,| but there's an
|但这是一种优化，

804
00:25:05,160 --> 00:25:07,710
0,660 660,900 900,1050 1050,1650 1800,2550
optimization,| based on multiple workstations
|基于多个工作站可以在只读模式下拥有文件缓存。

805
00:25:07,710 --> 00:25:09,240
0,120 120,480 480,660 660,930 930,1530
can have a file cache

806
00:25:09,300 --> 00:25:10,600
0,270 270,630 630,1170
in read-only mode.|
|

807
00:25:12,530 --> 00:25:14,090
0,300 300,750 1050,1200 1200,1440 1440,1560
Okay, so with that,| let
好的，所以有了这个，|让我简单地谈一下，

808
00:25:14,090 --> 00:25:14,660
0,90 90,240 240,300 300,450 450,570
me talk a little bit

809
00:25:14,660 --> 00:25:16,670
0,270 270,780 900,1530 1530,1830 1830,2010
about,| {} let's catch out
|让我们来了解一下Frangipani使用的协议。

810
00:25:16,670 --> 00:25:19,440
0,90 90,750
the protocol

811
00:25:19,710 --> 00:25:21,500
0,360 360,600 600,810 810,1530
that {Frangipani -} uses.|
|

812
00:25:22,010 --> 00:25:23,810
0,540 720,960 960,1320 1320,1410 1410,1800
{} And again you know
同样，您知道高速缓存一致性或高速缓存一致性，

813
00:25:23,870 --> 00:25:26,360
0,330 330,960 960,1200 1200,1500 1500,2490
cache coherence or cache {consistency

814
00:25:26,600 --> 00:25:29,780
0,1530 1530,1950 1950,2460 2460,2970 2970,3180
-},| {the,goal} actually for even
|实际上，目标是即使文件系统是分布式的，

815
00:25:29,780 --> 00:25:31,340
0,120 120,240 240,480 480,810 810,1560
though the file systems distributed,|
|

816
00:25:31,580 --> 00:25:32,930
0,240 240,450 450,900 900,1110 1110,1350
it should behave like a
它应该像单个文件系统一样运行，

817
00:25:32,930 --> 00:25:34,550
0,600 600,900 900,1290 1290,1470 1470,1620
single file system,| so you
|因此，您只有一台文件服务器，

818
00:25:34,550 --> 00:25:36,050
0,210 210,330 330,540 540,840 840,1500
only have one file server,|
|

819
00:25:36,050 --> 00:25:37,280
0,270 270,510 510,600 600,1020 1020,1230
you want to basically the
您希望分布式文件系统返回的结果基本相同，

820
00:25:37,280 --> 00:25:39,290
0,630 750,1440 1440,1530 1530,1620 1620,2010
same results will be returned

821
00:25:39,290 --> 00:25:40,610
0,120 120,240 240,690 690,930 930,1320
by the distributed file system,|
|

822
00:25:41,000 --> 00:25:41,750
0,210 210,300 300,510 510,690 690,750
so you can't tell the
所以你不能区分它是不是分布的，

823
00:25:41,750 --> 00:25:42,830
0,330 330,510 510,630 630,1020 1020,1080
difference whether it's distributed or

824
00:25:42,830 --> 00:25:45,200
0,360 930,1440 1590,1830 1830,2070 2070,2370
not,| and so this is
|这就是你让我想起可能的线性化的方式，

825
00:25:45,200 --> 00:25:46,250
0,60 60,180 180,450 450,660 660,1050
how you remind me of

826
00:25:46,250 --> 00:25:47,540
0,300 300,540 540,960 960,1170 1170,1290
likely {linearizability -},| so in
|所以事实上你知道我我相信实际上弗拉吉帕尼想要的是什么，

827
00:25:47,540 --> 00:25:49,100
0,330 330,390 390,780 780,1290 1380,1560
fact you know I I

828
00:25:49,100 --> 00:25:50,540
0,300 300,570 570,960 960,1170 1170,1440
believe actually what {Frangipani -

829
00:25:50,540 --> 00:25:53,120
0,780 1290,1830 1830,2100 2100,2430 2430,2580
-} {} shoot for,| it's
|它实际上是可线性化的文件系统操作。

830
00:25:53,120 --> 00:25:54,320
0,300 300,600 600,780 780,990 990,1200
actually {linearizable - -} file

831
00:25:54,320 --> 00:25:55,360
0,360 360,960
system operations.|
|

832
00:25:56,200 --> 00:25:57,760
0,540 630,1200 1260,1380 1380,1500 1500,1560
Okay, so we got the
好的，我们找到了锁服务器，

833
00:25:57,760 --> 00:25:58,960
0,300 300,780
lock server,|
|

834
00:26:00,790 --> 00:26:02,380
0,330 330,540 540,690 690,1110 1110,1590
{} we got workstation 1,|
我们有1号工作站，|

835
00:26:04,200 --> 00:26:06,480
0,360 360,510 510,960 960,1260
and there's workstation 2.|
这是2号工作站。|

836
00:26:07,600 --> 00:26:09,400
0,630 660,1140 1140,1290 1290,1530 1530,1800
And, {} there are four
这里有四个重要的信息，

837
00:26:09,400 --> 00:26:11,050
0,540 540,750 750,930 930,1380 1380,1650
messages that are important here,|
|

838
00:26:11,050 --> 00:26:13,090
0,270 270,960 960,1470 1470,1560 1560,2040
there's namely requesting a lock
即请求一个锁授予一个锁

839
00:26:13,390 --> 00:26:16,000
0,780 780,870 870,1380 1710,2160 2160,2610
granting a lock| and revoking
|撤销锁并实际释放锁，

840
00:26:16,000 --> 00:26:17,800
0,90 90,600 630,1110 1110,1350 1350,1800
a lock and actually releasing

841
00:26:17,800 --> 00:26:18,460
0,90 90,330 330,420 420,600 600,660
the lock,| so those are
|这就是往返传递的四条信息，

842
00:26:18,460 --> 00:26:20,170
0,60 60,330 330,780 780,900 900,1710
the four messages that fly

843
00:26:20,170 --> 00:26:21,790
0,510 510,720 720,810 810,1050 1050,1620
between back and forth,| between
|在工作站和锁服务器之间

844
00:26:22,000 --> 00:26:24,190
0,720 720,870 870,1440 1440,1560 1560,2190
workstations and {lock,server}| and {lock,server}
|和锁定服务器等工作站，

845
00:26:24,190 --> 00:26:26,470
0,120 120,300 300,1080 1620,2070 2100,2280
and other workstations,| so let's
|那么让我们来看看这个，

846
00:26:26,470 --> 00:26:27,640
0,450 450,570 570,810 810,990 990,1170
look at this,| let's say
|比方说服务器有锁，

847
00:26:27,640 --> 00:26:30,370
0,420 420,690 690,1410 2190,2580 2580,2730
locks server has,| nobody has
|任何时候都没有人有锁，

848
00:26:30,370 --> 00:26:31,660
0,180 180,480 480,600 600,900 900,1290
any locks at any time,|
|

849
00:26:31,660 --> 00:26:33,220
0,150 150,420 420,630 630,750 750,1560
so let's draw some timelines,|
所以让我们画一些时间线，|

850
00:26:33,910 --> 00:26:36,100
0,450 450,960 960,1290 1290,1560 1560,2190
and workstation 1 wants to
并且工作站1想要请求，

851
00:26:36,130 --> 00:26:37,500
0,1200
request,|
|

852
00:26:38,080 --> 00:26:40,210
0,390 390,480 480,840 840,1380 1440,2130
once they read write {}
一旦它们读取写入文件F，

853
00:26:40,210 --> 00:26:42,220
0,360 360,720 1020,1170 1170,1680 1680,2010
file f,| {you,know} basically sends
|你知道，基本上就是发送一个锁的请求，

854
00:26:42,220 --> 00:26:43,570
0,240 240,630 630,780 780,840 840,1350
a request for a lock,|
|

855
00:26:43,600 --> 00:26:44,650
0,150 150,390 390,510 510,720 720,1050
{you,know} to the lock server
你知道文件f的锁服务器，

856
00:26:44,650 --> 00:26:45,760
0,180 180,510 510,870
for file f,|
|

857
00:26:46,580 --> 00:26:48,530
0,630 630,1170 1350,1620 1620,1830 1830,1950
so workstation, but can't do
所以是工作站，但目前还不能做任何事情，

858
00:26:48,530 --> 00:26:49,520
0,330 330,540 540,630 630,780 780,990
anything really at this point

859
00:26:49,520 --> 00:26:51,170
0,330 600,1020 1020,1200 1200,1410 1410,1650
yet,| {} the lock server
|你知道的锁服务器检查它是稳定的

860
00:26:51,170 --> 00:26:52,910
0,240 240,660 660,870 870,990 990,1740
{you,know} checks {} it's stable|
|

861
00:26:53,180 --> 00:26:54,530
0,300 300,540 540,690 690,930 930,1350
and sees that f actually
并且发现f实际上根本没有人使用，

862
00:26:54,530 --> 00:26:55,790
0,180 180,570 570,750 750,870 870,1260
is not used by anybody

863
00:26:55,790 --> 00:26:57,500
0,90 90,540 540,780 780,1200 1200,1710
at all,| at least workstation
|至少作为锁拥有者的工作站1基本上发回消息

864
00:26:57,500 --> 00:26:59,360
0,420 420,660 660,930 930,1230 1230,1860
1 as the lock owner

865
00:26:59,420 --> 00:27:01,670
0,300 300,630 630,930 930,1440 1470,2250
sends basically message backs| {and,granting}
|并为f授予锁，

866
00:27:03,780 --> 00:27:05,220
0,120 120,450 450,630 630,1110
the lock for f,|
|

867
00:27:06,160 --> 00:27:08,110
0,150 150,210 210,360 360,900 1200,1950
so at this point, workstation
因此在这一点上，工作站1需要锁定f，

868
00:27:08,110 --> 00:27:09,940
0,690 930,1320 1320,1410 1410,1710 1710,1830
1 requires to lock for

869
00:27:09,940 --> 00:27:11,050
0,300 330,660 660,750 750,870 870,1110
f,| now it can actually
|现在它可以实际读取或写入我们现在可以从Petal读取文件的位置，

870
00:27:11,050 --> 00:27:12,100
0,240 240,360 360,720 720,930 930,1050
read or write where now

871
00:27:12,100 --> 00:27:13,270
0,120 120,210 210,450 450,840 840,1170
we can actually read the

872
00:27:13,270 --> 00:27:15,220
0,330 330,480 480,990
file from Petal,|
|

873
00:27:18,660 --> 00:27:20,970
0,630 840,1260 1260,1380 1380,1650 1650,2310
{} actually can make modifications
其实也可以对它进行修改，

874
00:27:20,970 --> 00:27:22,140
0,120 120,270 270,690 780,990 990,1170
to it too,| {you,know} those
|你知道，这些修改应该留在当地，

875
00:27:22,140 --> 00:27:24,630
0,660 660,960 1020,1350 1350,1890 1980,2490
modifications should stay local,| nothing
|真正发生的事情不是写回缓存，而不是直写缓存。

876
00:27:24,630 --> 00:27:26,040
0,180 180,510 510,690 690,990 990,1410
really happens is a write

877
00:27:26,130 --> 00:27:27,510
0,630 630,900 900,1080 1080,1140 1140,1380
back cache, not a write

878
00:27:27,510 --> 00:27:28,340
0,150 150,660
through cache.|
|

879
00:27:28,600 --> 00:27:29,560
0,150 150,240 240,330 330,720 720,960
And so it just stays
因此，它只是愉快地留在客户端。

880
00:27:29,560 --> 00:27:31,240
0,480 480,720 720,810 810,1620 1620,1680
happily on the on the

881
00:27:31,240 --> 00:27:32,280
0,330 330,750
client side.|
|

882
00:27:32,640 --> 00:27:33,750
0,300 300,420 420,630 630,720 720,1110
{} In fact the workstation
事实上，你甚至可以在工作站上释放锁，

883
00:27:33,750 --> 00:27:35,370
0,90 90,180 180,600 840,1530 1530,1620
you can even release the

884
00:27:35,370 --> 00:27:36,690
0,480 510,600 600,720 720,1170 1170,1320
lock,| you know here in
|你知道，在这里基本上是从忙碌到空闲，

885
00:27:36,690 --> 00:27:38,280
0,450 750,960 960,1110 1110,1440 1440,1590
basically go from busy to

886
00:27:38,280 --> 00:27:39,140
0,540
idle,|
|

887
00:27:42,370 --> 00:27:44,170
0,270 270,450 450,660 660,1200 1410,1800
and so it actually {}
因此，它实际上需要再次锁定，

888
00:27:44,170 --> 00:27:45,190
0,240 240,420 420,510 510,720 720,1020
would need to lock again,|
|

889
00:27:45,190 --> 00:27:46,420
0,60 60,390 390,600 600,930 930,1230
for example once write after
例如再次一次接着一次写入，

890
00:27:46,420 --> 00:27:48,160
0,540 540,1020 1020,1200 1200,1410 1410,1740
write again,| we can actually
|我们实际上可以在不与锁服务器进行任何交互的情况下执行完整的本地操作。

891
00:27:48,160 --> 00:27:49,510
0,150 150,240 240,630 630,990 990,1350
do the complete local without

892
00:27:49,510 --> 00:27:51,490
0,240 240,930 1080,1650 1650,1740 1740,1980
any interaction with the lock

893
00:27:51,490 --> 00:27:52,180
0,420
server.|
|

894
00:27:52,710 --> 00:27:54,420
0,180 180,240 240,540 540,1140 1140,1710
There's a slight simplification here,|
这里有一个轻微的简化，|

895
00:27:54,420 --> 00:27:55,230
0,300 300,480 480,690 690,750 750,810
there's we'll see in a
这一点我们一会儿就会看到，

896
00:27:55,230 --> 00:27:56,880
0,420 450,690 690,900 1140,1470 1470,1650
second,| that the lock has
|该锁与其关联最少，

897
00:27:56,880 --> 00:27:58,260
0,390 390,930 930,1110 1110,1230 1230,1380
least associated with it,| so
|因此客户端至少必须定期刷新磁盘，

898
00:27:58,260 --> 00:27:59,040
0,60 60,360 360,450 450,630 630,780
the client at least has

899
00:27:59,040 --> 00:28:00,660
0,90 90,510 510,600 600,870 870,1620
to refresh the disk periodically,|
|

900
00:28:00,750 --> 00:28:02,220
0,240 240,300 300,540 540,660 660,1470
but it doesn't have to
但它不必从实际的花瓣读取或重新读取文件F，

901
00:28:02,250 --> 00:28:04,800
0,1140 1260,1590 1590,2010 2010,2220 2220,2550
{read,write,or,reread} the file f from

902
00:28:04,800 --> 00:28:05,720
0,300 300,690
actually Petal,|
|

903
00:28:06,120 --> 00:28:07,500
0,210 210,300 300,510 510,750 750,1380
if the lease has expired.|
如果租约已到期。|

904
00:28:08,880 --> 00:28:10,320
0,330 330,690 810,990 990,1260 1260,1440
Okay, so the instant case
好的，所以立竿见影的情况当然会发生，

905
00:28:10,320 --> 00:28:11,490
0,60 60,240 240,630 630,870 870,1170
of course happens,| like what
|例如如果工作站2想要读取文件F，

906
00:28:11,490 --> 00:28:13,860
0,270 270,840 840,1410 1620,2130 2130,2370
if workstation 2 wants to

907
00:28:13,860 --> 00:28:15,780
0,480 510,900 900,1050 1050,1530 1530,1920
read {} the file f,|
|

908
00:28:15,930 --> 00:28:17,010
0,450 660,780 780,840 840,990 990,1080
so you know what will
因此，您知道工作站2将会发生什么情况

909
00:28:17,010 --> 00:28:18,270
0,270 270,480 480,480 480,1020 1020,1260
happen with {} workstation 2

910
00:28:18,270 --> 00:28:19,200
0,180 180,270 270,510 510,630 630,930
want to read| and basically
|基本上它也会做同样的事情，

911
00:28:19,200 --> 00:28:19,830
0,120 120,210 210,330 330,390 390,630
it will do the same

912
00:28:19,830 --> 00:28:21,540
0,180 180,270 270,600 630,1170 1320,1710
thing,| it will send a
|它将发送获取或请求消息，

913
00:28:21,540 --> 00:28:24,240
0,930 930,1110 1110,1380 1380,1980 2250,2700
acquire or request message,| request
|向锁定服务器请求消息说我想要f，

914
00:28:24,240 --> 00:28:26,310
0,390 390,780 1080,1650 1650,1800 1800,2070
message to {lock,server} for saying

915
00:28:26,310 --> 00:28:27,140
0,90 90,300 300,690
I want f,|
|

916
00:28:27,790 --> 00:28:28,660
0,120 120,180 180,330 330,540 540,870
and the way it works
它的工作原理是，

917
00:28:28,660 --> 00:28:30,070
0,150 150,480 600,840 840,1020 1020,1410
is that,| the lock server
|锁服务器实际上查看了这个表，

918
00:28:30,070 --> 00:28:31,900
0,540 660,1230 1230,1320 1320,1470 1470,1830
actually looks at this table,|
|

919
00:28:31,900 --> 00:28:33,400
0,270 270,510 510,840 840,930 930,1500
sees the f is actually
看到f实际归工作站1所有

920
00:28:33,400 --> 00:28:35,380
0,570 570,1140 1170,1380 1380,1560 1560,1980
owned by {workstation -} 1|
|

921
00:28:35,530 --> 00:28:36,340
0,180 180,330 330,570 570,750 750,810
and then will send the
然后将该撤销消息发送到工作站1

922
00:28:36,340 --> 00:28:37,660
0,480 480,1080
revoke message

923
00:28:37,890 --> 00:28:40,950
0,510 510,1140 1140,1650 1920,2640 2640,3060
to workstation 1| asking {you,know}
|问你知道锁是怎么回事，

924
00:28:40,950 --> 00:28:43,860
0,450 480,900 900,1380 1560,2010 2400,2910
the lock back,| {so,that,will} {revoke,f},|
|所以这将撤销f，|

925
00:28:44,520 --> 00:28:46,180
0,390 390,510 510,720 720,1350
and at this point,|
在这点上，|

926
00:28:46,490 --> 00:28:47,750
0,630 630,960 960,1080 1080,1110 1110,1260
Petal actually do a little
花瓣实际上做得更多一点，

927
00:28:47,750 --> 00:28:49,040
0,180 180,390 390,510 510,780 990,1290
bit more of,| {} {Frangipani
|实际上，蛋黄煎蛋卷需要做一点工作，

928
00:28:49,040 --> 00:28:50,030
0,270 270,630 630,780 780,930 930,990
-} actually little bit of

929
00:28:50,030 --> 00:28:51,740
0,420 600,1290 1290,1440 1440,1620 1620,1710
work,| because we have to
|因为我们必须确保工作站2观察到写入，

930
00:28:51,740 --> 00:28:53,240
0,150 150,540 540,660 660,1170 1170,1500
make sure the workstation 2

931
00:28:53,240 --> 00:28:55,370
0,570 570,690 690,1290 1380,1680 1680,2130
observes the writes,| that workstation
|该工作站1已完成

932
00:28:55,370 --> 00:28:56,510
0,210 210,330 330,660 870,1050 1050,1140
1 is done| and so
|所以这样做的方式是，基本上在这一刻，

933
00:28:56,510 --> 00:28:57,290
0,90 90,240 240,480 480,570 570,780
the way that is done

934
00:28:57,290 --> 00:28:58,580
0,90 90,210 210,540 540,870 870,1290
is that basically this instant

935
00:28:58,580 --> 00:28:59,660
0,120 120,720
of time,|
|

936
00:29:00,700 --> 00:29:01,740
0,690

937
00:29:02,180 --> 00:29:03,500
0,150 150,540 540,780 780,1050 1050,1320
the workstation 1 writes actually
如果你知道，工作站1实际上会写给花瓣

938
00:29:03,500 --> 00:29:05,120
0,450 480,630 630,720 720,1020 1020,1620
f you know to Petal|
|

939
00:29:06,020 --> 00:29:06,590
0,180 180,300 300,450 450,510 510,570
and we'll see in a
我们很快就会看到，将f写到Petal实际上是一个稍微复杂的操作，

940
00:29:06,590 --> 00:29:08,030
0,450 450,690 690,1050 1050,1350 1350,1440
second, actually writing f to

941
00:29:08,030 --> 00:29:09,740
0,360 360,780 780,900 900,1200 1200,1710
Petal actually a slightly complicated

942
00:29:09,740 --> 00:29:11,300
0,570 570,750 750,1350 1350,1440 1440,1560
operations,| more sophisticated than I'm
|比我所说的更老练，

943
00:29:11,300 --> 00:29:11,990
0,150 150,420 420,510 510,630 630,690
just making it out to

944
00:29:11,990 --> 00:29:13,220
0,360 480,720 720,840 840,1020 1020,1230
be,| but just think about
|但在这一点上考虑一下，

945
00:29:13,220 --> 00:29:14,630
0,120 120,390 390,540 540,990 1230,1410
it at this point,| {workstation
|工作站1基本上正在刷新其与F和花瓣相关的状态。

946
00:29:14,630 --> 00:29:16,280
0,270 270,690 750,870 870,1200 1200,1650
-} 1 is basically flushing

947
00:29:16,280 --> 00:29:17,780
0,120 120,510 510,870 870,960 960,1500
its states related to f

948
00:29:17,810 --> 00:29:18,940
0,240 240,450 450,930
and to Petal.|
|

949
00:29:19,580 --> 00:29:21,290
0,510 510,690 690,1050 1050,1500 1500,1710
Once that actually completed,| so
一旦这项工作真正完成，|所以，就像花瓣一旦被认可，

950
00:29:21,290 --> 00:29:22,910
0,240 240,540 540,900 900,1020 1020,1620
like once Petal are acknowledged,|
|

951
00:29:22,910 --> 00:29:24,080
0,120 120,390 390,540 540,840 840,1170
that actually it actually has
实际上它已经收到了所有的数据

952
00:29:24,080 --> 00:29:25,460
0,360 360,420 420,510 510,990 1170,1380
received all the data| and
|并实际发送回一条消息，释放f。

953
00:29:25,460 --> 00:29:26,840
0,300 300,540 540,570 570,870 870,1380
actually sends a message back,

954
00:29:26,960 --> 00:29:28,200
0,510 510,930
releasing f.|
|

955
00:29:32,100 --> 00:29:33,540
0,480 480,600 600,690 690,990 990,1440
And you know once {lock,server}
你知道，一旦锁定服务器得到f的释放，

956
00:29:33,540 --> 00:29:34,830
0,240 240,360 360,750 750,870 870,1290
gets the release of f,|
|

957
00:29:34,860 --> 00:29:35,820
0,90 90,180 180,330 330,450 450,960
you know that can update
你知道，可以更新它的表，并将锁分配到工作站2

958
00:29:35,820 --> 00:29:37,530
0,330 330,990 990,1230 1230,1650 1650,1710
its table and allocate the

959
00:29:37,530 --> 00:29:40,200
0,330 330,420 420,1230 1380,1980 2160,2670
lock the workstation 2| and
|把你知道的从f到2的奖励金。

960
00:29:40,200 --> 00:29:43,350
0,510 510,660 660,870 870,1500 2700,3150
sends {you,know} a grant for

961
00:29:43,350 --> 00:29:44,500
0,360 390,540 540,900
f to 2.|
|

962
00:29:45,070 --> 00:29:45,980
0,390
Oops.|
哎呀。|

963
00:29:52,420 --> 00:29:54,130
0,150 150,210 210,360 360,840 870,1710
And at this point, {}|
在这点上，|

964
00:29:54,160 --> 00:29:56,200
0,510 510,900 900,1440 1440,1860 1860,2040
workstation 2 requires lock| and
工作站2需要锁定|现在它实际上可以读取花瓣文件中的所有信息，

965
00:29:56,200 --> 00:29:58,030
0,270 270,540 540,690 690,990 990,1830
now it can actually read

966
00:29:58,030 --> 00:29:59,560
0,120 120,240 240,1050 1050,1320 1350,1530
all the information from the

967
00:29:59,560 --> 00:30:01,150
0,270 270,480 480,960 1140,1410 1410,1590
file f Petal,| at that
|在这一点上，可以保证我们将看到文件F的最新变化，

968
00:30:01,150 --> 00:30:02,800
0,240 240,360 360,510 510,1380 1410,1650
point it is guaranteed that

969
00:30:02,800 --> 00:30:04,630
0,180 180,660 690,870 870,1230 1230,1830
we'll see the latest changes

970
00:30:04,870 --> 00:30:07,060
0,630 930,1440 1440,1590 1590,1920 1920,2190
to {} the file f,|
|

971
00:30:07,060 --> 00:30:09,490
0,690 810,1260 1260,1620 1620,2010 2010,2430
because the previous owner must
因为之前的主人肯定把你知道的状态冲到了花瓣上，

972
00:30:09,490 --> 00:30:11,020
0,180 180,750 840,930 930,1440 1440,1530
have flushed the state you

973
00:30:11,020 --> 00:30:14,020
0,120 120,480 480,1050 1380,2070 2280,3000
know to the {} Petal,|
|

974
00:30:14,110 --> 00:30:15,820
0,810 810,900 900,1260 1260,1620 1620,1710
before it actually released the
在它实际释放锁并将其返回给锁服务器之前

975
00:30:15,820 --> 00:30:16,690
0,300 300,420 420,570 570,630 630,870
lock and gave it back

976
00:30:16,690 --> 00:30:17,860
0,60 60,240 240,360 360,840 1020,1170
to the lock server| and
|并且保证工作站2实际观察到这些变化

977
00:30:17,860 --> 00:30:19,360
0,540 540,750 750,870 870,1410 1410,1500
workstation 2 is guaranteed to

978
00:30:19,360 --> 00:30:21,010
0,480 480,960 960,1140 1140,1560 1560,1650
actually observe those changes| and
|所以这就是我们强大的一致性的用武之地，

979
00:30:21,010 --> 00:30:22,120
0,90 90,330 330,570 570,750 750,1110
so here's where our strong

980
00:30:22,120 --> 00:30:24,220
0,510 510,780 780,990 1500,1890 1890,2100
consistency comes in,| these strong
|这些强大的一致性与锁管理密切相关。

981
00:30:24,220 --> 00:30:26,290
0,420 420,540 540,1320 1320,1590 1590,2070
consistency are tied to the

982
00:30:26,380 --> 00:30:27,500
0,450 450,1050
lock management.|
|

983
00:30:29,860 --> 00:30:31,460
0,210 210,480 480,690 690,990
Any questions about this?|
对此有什么问题吗？|

984
00:30:34,410 --> 00:30:36,030
0,180 180,540 540,960 960,1080 1080,1620
{ -} There's a question.|
我有个问题。|

985
00:30:36,720 --> 00:30:38,060
0,810
Okay,|
好吧,|

986
00:30:39,860 --> 00:30:40,940
0,240 240,510 510,690 690,810 810,1080
{} we need to write,|
我们需要写，|

987
00:30:40,940 --> 00:30:42,320
0,660 660,990 990,1050 1050,1140 1140,1380
one question in the chat,|
聊天中有一个问题，|

988
00:30:42,320 --> 00:30:43,670
0,150 150,480 480,840 840,930 930,1350
let me address the first,|
让我来谈谈第一个问题，|

989
00:30:43,910 --> 00:30:45,110
0,330 330,630 630,780 780,900 900,1200
{} we need to write
我们需要写信给佩托，

990
00:30:45,110 --> 00:30:46,430
0,90 90,390 390,630 630,1020 1020,1320
to Petal,| when releasing both
|当同时释放读和写锁定时，

991
00:30:46,430 --> 00:30:47,870
0,270 270,390 390,600 600,1050 1170,1440
read and write locks,| why
|为什么我们需要在释放读锁定时写入Petal。

992
00:30:47,870 --> 00:30:48,860
0,90 90,300 300,420 420,540 540,990
do we need to write

993
00:30:48,860 --> 00:30:49,970
0,90 90,420 420,720 720,1020 1020,1110
to Petal when releasing a

994
00:30:49,970 --> 00:30:53,120
0,180 180,570 960,1590 1710,2490 2490,3150
read lock.| {} Let's ignore
|让我们忽略读写，即读和写之间的区别，

995
00:30:53,120 --> 00:30:55,100
0,330 330,600 600,960 960,1470 1470,1980
{} read write, the distinction

996
00:30:55,100 --> 00:30:57,470
0,540 540,840 1140,1680 1680,2100 2100,2370
between {read,and,write},| exclusive locks and
|排他锁和读写锁，

997
00:30:57,470 --> 00:30:59,810
0,180 180,390 390,930 1170,1920 1920,2340
read write locks,| {} in
|只关注排他性锁，

998
00:30:59,810 --> 00:31:00,580
0,600
the,

999
00:31:00,760 --> 00:31:02,650
0,720 1050,1380 1380,1530 1530,1770 1770,1890
{} and just focus on

1000
00:31:02,650 --> 00:31:04,480
0,420 420,870 900,1020 1020,1380 1380,1830
exclusive locks,| you know read
|你知道，阅读整个阅读只是一个小[应用程序]，

1001
00:31:04,480 --> 00:31:05,800
0,60 60,300 300,780 780,1230 1230,1320
the whole {reading -} is

1002
00:31:05,800 --> 00:31:06,880
0,150 150,210 210,600 600,840 840,1080
just a small [app],| as
|因为它发生了一个重要的优化，

1003
00:31:06,880 --> 00:31:08,410
0,60 60,420 420,510 510,900 900,1530
it happens an important optimization,|
|

1004
00:31:08,590 --> 00:31:09,610
0,420 420,540 540,600 600,810 810,1020
{} but it doesn't really
但它并没有真正戏剧性地改变设计师体系。

1005
00:31:09,610 --> 00:31:12,580
0,600 600,1560 1560,2010 2010,2310 2310,2970
change the designer system dramatically.|
|

1006
00:31:17,180 --> 00:31:18,360
0,180 180,330 330,870
Any other questions?|
还有其他问题吗？|

1007
00:31:19,150 --> 00:31:20,680
0,270 270,450 450,750 750,900 900,1530
So this sort of design,
所以这种设计，效率真的很低，

1008
00:31:20,680 --> 00:31:22,450
0,210 210,510 510,960 990,1620 1620,1770
would be really inefficient,| if
|如果我们有两个不同的工作站

1009
00:31:22,450 --> 00:31:23,470
0,120 120,360 360,540 540,690 690,1020
we have like two different

1010
00:31:23,470 --> 00:31:25,180
0,690 690,810 810,930 930,1200 1200,1710
workstations| that are both modifying
|这两个都在修改同一个文件。

1011
00:31:25,180 --> 00:31:27,010
0,60 60,360 360,960 1170,1590 1650,1830
the same file.| Yeah.| You
|嗯。|你就像是缓存来回跳动。

1012
00:31:27,010 --> 00:31:28,660
0,390 390,570 570,690 690,1050 1050,1650
just get like cache bouncing

1013
00:31:28,690 --> 00:31:30,190
0,240 240,360 360,840 870,1380 1380,1500
back and forth.| Yeah, you
|是的，如果你们是两个工作站或两个不同的工程师，

1014
00:31:30,190 --> 00:31:31,570
0,300 300,510 510,780 780,1080 1080,1380
maybe if you're two {workstations

1015
00:31:31,570 --> 00:31:33,340
0,390 390,450 450,900 900,1290 1290,1770
-} or two different engineers,|
|

1016
00:31:33,340 --> 00:31:34,780
0,540 540,750 750,900 900,1320 1320,1440
{that,server} would be banging on
那个服务器会敲打同一个文件，

1017
00:31:34,780 --> 00:31:35,740
0,90 90,330 330,780 780,840 840,960
the same file,| you know
|你知道这份文件会来回翻阅。

1018
00:31:35,740 --> 00:31:36,760
0,300 330,600 600,720 720,840 840,1020
the file would go back

1019
00:31:36,760 --> 00:31:37,360
0,90 90,480
and forth.|
|

1020
00:31:38,290 --> 00:31:40,750
0,750 750,1860 1860,2010 2010,2250 2250,2460
{} And so is not
所以并不是真的合适，

1021
00:31:40,750 --> 00:31:41,680
0,180 180,600 600,720 720,840 840,930
really suitable,| so you can
|所以你可以看到这里，

1022
00:31:41,680 --> 00:31:43,030
0,300 300,720 720,840 840,1230 1230,1350
see here,| the influence of
|比如他们为之设计的工作量的影响，

1023
00:31:43,030 --> 00:31:45,400
0,240 240,690 1530,2070 2070,2220 2220,2370
like the workload that they're

1024
00:31:45,400 --> 00:31:47,020
0,450 450,780 870,1380 1380,1500 1500,1620
designing for,| {} you know
|你知道他们真正的假设是

1025
00:31:47,020 --> 00:31:48,160
0,180 180,390 390,840 840,990 990,1140
they're really assumption is that|
|

1026
00:31:48,160 --> 00:31:50,170
0,600 810,1200 1200,1620 1620,1710 1710,2010
basically most engineers are working
基本上，大多数工程师都在处理他们的私人文件

1027
00:31:50,170 --> 00:31:52,420
0,120 120,300 300,630 630,1290 1530,2250
on their private files| and
|你知道，有时候，他们会共享文件，

1028
00:31:52,420 --> 00:31:52,900
0,60 60,240 240,390 390,450 450,480
you know once in a

1029
00:31:52,900 --> 00:31:54,190
0,210 210,450 450,750 750,1140 1140,1290
while, they'll share files,| but
|但他们可能并不是在和同一个共享文件发生关系。

1030
00:31:54,190 --> 00:31:55,300
0,60 60,240 240,480 480,720 720,1110
they were probably not banging

1031
00:31:55,300 --> 00:31:56,350
0,120 120,180 180,420 420,690 690,1050
on the same shared file.|
|

1032
00:32:02,980 --> 00:32:04,240
0,330 330,510 510,720 720,1020 1020,1260
We're not using git,| but
我们不是在用Git，|但您可以想象，如果他们共享您的代码库，

1033
00:32:04,240 --> 00:32:05,170
0,90 90,180 180,570 570,780 780,930
you could imagine if they

1034
00:32:05,170 --> 00:32:06,250
0,120 120,210 210,540 540,870 870,1080
have a share your code

1035
00:32:06,250 --> 00:32:07,630
0,720 720,900 900,990 990,1230 1230,1380
repositories,| or you check out
|或者你签出你自己的代码库副本，

1036
00:32:07,630 --> 00:32:08,830
0,150 150,270 270,600 600,690 690,1200
your own copy of the

1037
00:32:08,860 --> 00:32:10,780
0,210 210,810 810,1080 1080,1740 1740,1920
code repository,| {make,all} modifications| and
|进行所有修改|到了某个时候，你会把它写回来。

1038
00:32:10,780 --> 00:32:11,830
0,150 150,360 360,420 420,660 660,1050
some point you {write,it} back.|
|

1039
00:32:14,850 --> 00:32:15,810
0,240 240,480 480,660 660,750 750,960
I'm sorry, just to make
我很抱歉，只是为了确保你说，

1040
00:32:15,810 --> 00:32:16,980
0,180 180,240 240,600 750,900 900,1170
sure you say,| you can
|您可以在缓存中仍有文件的情况下释放锁定。

1041
00:32:16,980 --> 00:32:19,020
0,450 450,570 570,1170 1200,1530 1530,2040
release the lock {} while

1042
00:32:19,020 --> 00:32:20,280
0,120 120,570 570,900 900,990 990,1260
you still have the file

1043
00:32:20,280 --> 00:32:21,700
0,60 60,330 360,1140
in the cache.|
|

1044
00:32:23,040 --> 00:32:25,440
0,750 750,1140 1170,2100
You can, {}
你可以的，好的，所以我会非常小心地

1045
00:32:25,730 --> 00:32:26,840
0,300 300,720 720,930 930,1050 1050,1110
okay, so I'm going to

1046
00:32:26,840 --> 00:32:27,890
0,90 90,330 330,630 630,810 810,1050
be very careful with| when
|当我遇到解锁的时候，

1047
00:32:27,890 --> 00:32:28,820
0,30 30,300 300,450 450,840 840,930
I met with releasing the

1048
00:32:28,820 --> 00:32:30,380
0,270 270,780 840,1020 1020,1260 1260,1560
lock there,| is not releasing
|不会将其发布到锁服务器，

1049
00:32:30,380 --> 00:32:31,520
0,120 120,210 210,330 330,570 570,1140
it to the lock server,|
|

1050
00:32:31,670 --> 00:32:32,900
0,330 330,540 540,1050 1050,1110 1110,1230
{} but locally you know
但在当地，你知道将状态从繁忙改变为空闲，

1051
00:32:32,900 --> 00:32:34,460
0,510 510,600 600,1020 1020,1230 1230,1560
changing the states from busy

1052
00:32:34,460 --> 00:32:35,220
0,120 120,510
to idle,|
|

1053
00:32:37,020 --> 00:32:37,980
0,300 300,480 480,600 600,720 720,960
and {since -} you know
既然你知道这把锁很粘

1054
00:32:37,980 --> 00:32:39,240
0,330 330,600 600,1080 1080,1170 1170,1260
the {lock,is} sticky| you know
|你知道它还在1号工作站

1055
00:32:39,240 --> 00:32:40,410
0,90 90,330 330,600 600,690 690,1170
it still sits at workstation

1056
00:32:40,410 --> 00:32:41,640
0,330 330,450 450,750 750,990 990,1230
1| and lock server still
|而锁服务器上的东西其实都是工作站1上的锁。

1057
00:32:41,640 --> 00:32:43,230
0,450 450,840 840,1050 1050,1320 1320,1590
things actually {workstation -} 1

1058
00:32:43,230 --> 00:32:44,220
0,210 210,330 330,720
has the lock.|
|

1059
00:32:48,850 --> 00:32:50,280
0,270 270,510 510,630 630,1110
{Is,that} answering your question?|
这是在回答你的问题吗？|

1060
00:32:51,330 --> 00:32:53,500
0,450 480,750 750,990 990,1410
Yeah, yeah, thank you.|
好的，好的，谢谢。|

1061
00:32:54,600 --> 00:32:56,260
0,210 210,330 330,780 780,1290
So what happens, {}
那么，如果来自两个人的请求在一段时间内变得繁忙，会发生什么呢？

1062
00:32:56,510 --> 00:32:58,250
0,300 300,420 420,960 960,1380 1500,1740
if the request from {}

1063
00:32:58,250 --> 00:33:01,190
0,570 570,1050 1350,2160 2160,2280 2280,2940
two comes awhile to busy?|
|

1064
00:33:01,930 --> 00:33:03,010
0,390 390,540 540,870 870,1020 1020,1080
Yes, good question, what do
是的，问得好，你认为会发生什么？

1065
00:33:03,010 --> 00:33:04,200
0,60 60,330 330,810
you think happens?|
|

1066
00:33:10,100 --> 00:33:11,180
0,180 180,270 270,450 450,780 780,1080
Does it just reject them?|
它只是拒绝他们吗？|

1067
00:33:11,880 --> 00:33:13,290
0,600 600,810 810,1080 1080,1260 1260,1410
No, that's I think it
不，那是我认为它不会拒绝它，只是等待

1068
00:33:13,290 --> 00:33:14,640
0,210 210,510 510,660 660,870 870,1350
doesn't reject it, just waits|
|

1069
00:33:14,880 --> 00:33:16,530
0,120 120,390 390,1140 1170,1440 1440,1650
and waits until {} {workstation
并等待直到工作站1完成，

1070
00:33:16,530 --> 00:33:19,170
0,270 270,840 960,1170 1170,1680 1740,2640
-} 1 is done,| modifying
|修改文件f以执行其文件系统操作，

1071
00:33:19,170 --> 00:33:20,550
0,90 90,450 450,660 660,960 960,1380
the file f for executing

1072
00:33:20,550 --> 00:33:22,440
0,150 150,420 420,690 690,1290 1680,1890
its file system operation,| and
|然后Frangipani代码将在本地释放锁，

1073
00:33:22,440 --> 00:33:25,140
0,540 690,1170 1170,1530 1770,2430 2430,2700
then {} the Frangipani code

1074
00:33:25,140 --> 00:33:27,480
0,390 510,1230 1230,1710 1710,1830 1830,2340
will release locally the lock,|
|

1075
00:33:27,750 --> 00:33:29,010
0,330 330,630 630,810 810,1110 1110,1260
will see that someone is
会看到有人在等它

1076
00:33:29,010 --> 00:33:30,630
0,330 330,630 630,810 1200,1440 1440,1620
waiting for it| and so
|因此不会将其更改为忙碌，

1077
00:33:30,630 --> 00:33:32,250
0,510 510,750 750,840 840,1320 1320,1620
doesn't change it to {}

1078
00:33:32,250 --> 00:33:33,870
0,540 600,840 840,1020 1020,1260 1260,1620
busy,| but actually starts flushing
|但实际上开始将所有操作都刷新到Petal

1079
00:33:33,870 --> 00:33:35,520
0,180 180,240 240,840 840,1260 1260,1650
all the operations to Petal|
|

1080
00:33:35,520 --> 00:33:36,750
0,120 120,390 390,750 750,840 840,1230
and then releases the lock.|
然后释放锁。|

1081
00:33:38,530 --> 00:33:39,880
0,180 180,330 330,540 540,870 870,1350
So this comes actually nicely
所以这实际上很好地谈到了第二点，

1082
00:33:39,880 --> 00:33:41,260
0,90 90,180 180,480 480,870 900,1380
to the second point,| {}|
||

1083
00:33:41,260 --> 00:33:42,610
0,180 180,270 270,390 390,990 990,1350
which is this atomicity point,|
这就是原子点，|

1084
00:33:42,640 --> 00:33:43,630
0,180 180,420 420,630 630,840 840,990
so maybe that will make
因此，这或许会让事情变得更清楚。

1085
00:33:43,630 --> 00:33:44,880
0,90 90,270 270,690
it more clear.|
|

1086
00:33:45,330 --> 00:33:46,020
0,240 240,300 300,480 480,510 510,690
Let me talk a little
让我简单地谈谈原子性，

1087
00:33:46,020 --> 00:33:47,220
0,150 150,390 390,840 840,1020 1020,1200
bit about atomicity,| because it
|因为它还使用相同的锁来实现原子文件系统操作。

1088
00:33:47,220 --> 00:33:49,620
0,570 630,1290 1290,1380 1380,1740 1740,2400
also use the same locks

1089
00:33:49,740 --> 00:33:52,830
0,780 930,1890 1920,2640 2640,2850 2850,3090
to achieve atomic file system

1090
00:33:52,830 --> 00:33:53,780
0,720
operations.|
|

1091
00:33:56,260 --> 00:34:03,100
0,960 960,1110 1110,1260 1260,2190 4770,6840
{} you {using -} locks,|
你用的是锁，|

1092
00:34:03,130 --> 00:34:04,120
0,750
so
例如，当您创建操作时，

1093
00:34:04,200 --> 00:34:06,180
0,870 900,1350 1350,1440 1440,1650 1650,1980
when {for,example} you do create

1094
00:34:06,180 --> 00:34:07,830
0,600 600,810 810,960 960,1560 1560,1650
operation,| like you execute the
|就像您执行创建文件系统操作或任何创建f一样，

1095
00:34:07,830 --> 00:34:10,110
0,330 330,600 600,870 870,1560 2130,2280
create file system operation or

1096
00:34:10,110 --> 00:34:12,040
0,420 420,750 750,1350
whatever create f,|
|

1097
00:34:12,850 --> 00:34:13,870
0,210 210,420 420,570 570,690 690,1020
{you,know} {whatever -} the usual
你知道，不管是什么惯常的争论。

1098
00:34:13,870 --> 00:34:14,900
0,630
arguments.|
|

1099
00:34:15,150 --> 00:34:16,800
0,270 270,570 570,660 660,900 900,1650
And there's of course internally
当然，在内部，尽管应用程序会创建文件系统，

1100
00:34:16,800 --> 00:34:18,270
0,210 210,330 330,660 690,1260 1260,1470
even though the application makes

1101
00:34:18,270 --> 00:34:19,440
0,150 150,450 450,690 690,930 930,1170
this create file system,| called
|在内部称为这实际上具有多个文件系统修改，

1102
00:34:19,440 --> 00:34:21,150
0,90 90,540 540,780 780,990 990,1710
this internally actually has multiple

1103
00:34:21,630 --> 00:34:24,120
0,750 750,960 960,1200 1200,1980 2280,2490
a file system modifications,| {you,know,for}
|例如，您知道需要修改目录，

1104
00:34:24,120 --> 00:34:25,980
0,510 510,780 780,1050 1110,1680 1680,1860
example {} the directory needs

1105
00:34:25,980 --> 00:34:27,780
0,90 90,180 180,1020 1080,1500 1500,1800
to be modified,| actually {let,me}
|实际上，让我以稍微不同的顺序来做，

1106
00:34:27,810 --> 00:34:28,980
0,330 330,450 450,600 630,930 930,1170
{do,it} in a slightly different

1107
00:34:28,980 --> 00:34:30,780
0,450 540,810 810,960 960,1320 1350,1800
order,| we need to allocate
|我们需要为f分配一个信息节点，

1108
00:34:30,780 --> 00:34:31,980
0,90 90,240 240,840 900,1080 1080,1200
an {inode -} you know

1109
00:34:31,980 --> 00:34:33,380
0,270 270,1140
for f,|
|

1110
00:34:34,260 --> 00:34:35,460
0,330 330,390 390,930 930,1080 1080,1200
{we,need} to initialize that {inode
我们需要初始化该inode，写入inode，

1111
00:34:35,460 --> 00:34:38,550
0,510 1500,2130 2130,2280 2280,2400 2400,3090
-}, write the {inode -},|
|

1112
00:34:39,790 --> 00:34:40,960
0,150 150,510 510,600 600,810 810,1170
and then you know update
然后你知道，更新目录，

1113
00:34:40,960 --> 00:34:42,020
0,60 60,750
the directory,|
|

1114
00:34:44,150 --> 00:34:46,460
0,300 300,360 360,1110 1380,1770 1770,2310
update the directory to {}
更新目录以添加条目，

1115
00:34:46,490 --> 00:34:48,500
0,240 240,330 330,810 810,1290 1290,2010
add an entry,| basically {for,you,know}
|基本上，你知道的[]f，

1116
00:34:48,500 --> 00:34:50,270
0,90 90,510 510,1170 1290,1440 1440,1770
the [] f,| and whatever
|并且无论为f分配了什么索引节点号，

1117
00:34:50,270 --> 00:34:52,430
0,150 150,390 390,960 1500,1650 1650,2160
{inode -} number was allocated

1118
00:34:52,430 --> 00:34:53,100
0,450
{for,f},|
|

1119
00:34:53,980 --> 00:34:55,120
0,30 30,660 660,870 870,960 960,1140
{so,there's} typical way in which
因此，Unix文件系统实现文件有几种典型方式

1120
00:34:55,120 --> 00:34:56,650
0,90 90,330 330,570 570,930 930,1530
a Unix file system implements

1121
00:34:56,650 --> 00:34:58,210
0,540 1080,1230 1230,1320 1320,1410 1410,1560
files| and so we need
|因此我们需要安排这些操作以原子方式进行，

1122
00:34:58,210 --> 00:34:59,770
0,60 60,570 570,720 720,870 870,1560
to arrange that these operations

1123
00:34:59,770 --> 00:35:02,770
0,690 690,1080 1080,1380 1800,2790 2790,3000
happen {atomically -},| {} because
|因为我们不想让其他工作站看到中间结果

1124
00:35:02,770 --> 00:35:03,460
0,90 90,300 300,450 450,540 540,690
we don't want to sort

1125
00:35:03,460 --> 00:35:05,080
0,90 90,630 630,1050 1050,1170 1170,1620
of intermediate results be visible

1126
00:35:05,080 --> 00:35:06,400
0,120 120,570 570,1140 1140,1230 1230,1320
to other workstations| in the
|发生的方式是通过获取这些锁获取锁，

1127
00:35:06,400 --> 00:35:07,990
0,240 240,420 420,780 780,990 990,1590
way that happens is using

1128
00:35:08,020 --> 00:35:10,570
0,390 390,840 840,990 990,1500 1920,2550
by acquiring those locks {acquire,the}

1129
00:35:10,570 --> 00:35:11,240
0,540
lock,|
|

1130
00:35:13,440 --> 00:35:14,910
0,300 300,780 810,990 990,1350 1350,1470
{} for this particular {inode
对于该特定索引节点，

1131
00:35:14,910 --> 00:35:16,140
0,450 450,540 540,630 630,720 720,1230
-},| you know, for example
|你知道，例如后来的索引节点10，

1132
00:35:16,140 --> 00:35:17,460
0,330 330,570 570,720 720,1080 1080,1320
later {inode -} 10,| so
|因此，您需要为f设置一个锁，

1133
00:35:17,460 --> 00:35:18,300
0,150 150,390 390,450 450,750 750,840
you require a lock for

1134
00:35:18,300 --> 00:35:19,740
0,360 390,510 510,630 630,870 930,1440
f,| I'm just gonna use
|我想我还是用锁吧，

1135
00:35:19,770 --> 00:35:22,170
0,360 360,750 1440,2010 2010,2160 2160,2400
f the lock I think,|
|

1136
00:35:22,170 --> 00:35:23,700
0,180 180,1140 1140,1290 1290,1440 1440,1530
but yeah it's gonna be
但是，是的，它将是索引节点编号

1137
00:35:23,700 --> 00:35:24,600
0,270 270,480 480,600 600,810 810,900
inode number| and then at
|然后在某个时刻，它释放[]处的文件系统，本身释放锁。

1138
00:35:24,600 --> 00:35:26,850
0,120 120,390 390,630 630,1290 1830,2250
some point, it releases file

1139
00:35:26,850 --> 00:35:28,230
0,270 270,360 360,600 600,1050 1050,1380
system at {[] -}, itself

1140
00:35:28,230 --> 00:35:29,580
0,420 420,540 540,960
releases the lock.|
|

1141
00:35:30,360 --> 00:35:31,860
0,120 120,390 390,810 810,1410 1410,1500
And again this releases a
这又一次释放了本地释放操作，

1142
00:35:31,860 --> 00:35:33,570
0,390 390,690 690,1290 1290,1470 1470,1710
local release operation,| it doesn't
|这并不意味着立即将其释放回锁定服务器，

1143
00:35:33,570 --> 00:35:36,720
0,390 390,750 750,1380 1710,2550 2580,3150
really mean immediately {} releasing

1144
00:35:36,720 --> 00:35:37,500
0,60 60,360 360,480 480,600 600,780
it back to the lock

1145
00:35:37,500 --> 00:35:39,240
0,420 420,900 900,1290 1290,1380 1380,1740
server,| just changing the status
|正在将状态从繁忙更改为空闲。

1146
00:35:39,240 --> 00:35:40,590
0,150 150,450 450,840 900,1350 1350,1350
from busy to {} {idle

1147
00:35:40,590 --> 00:35:41,320
0,480
-}.|
|

1148
00:35:42,220 --> 00:35:44,080
0,150 150,540 630,1170 1170,1350 1350,1860
And so, {} so if
所以，所以，如果在任何特定的时间点，

1149
00:35:44,110 --> 00:35:45,070
0,210 210,390 390,720 720,900 900,960
at any particular point in

1150
00:35:45,070 --> 00:35:46,870
0,570 630,1110 1110,1230 1230,1410 1410,1800
time,| as we just ask
|就像我们刚才问的那样，你知道有一个要求撤销锁的请求，

1151
00:35:46,870 --> 00:35:47,770
0,90 90,210 210,450 450,510 510,900
you know there's a request

1152
00:35:47,770 --> 00:35:51,670
0,240 240,450 450,1020 1290,2070 2670,3900
coming in for {} revoke

1153
00:35:51,820 --> 00:35:52,880
0,810
{the,lock},|
|

1154
00:35:55,860 --> 00:35:58,470
0,540 540,960 1080,1740 1770,2490 2490,2610
{you,know} {revoke,f}, that request is
您知道revoke f，该请求实际上并没有被提供给文件系统，

1155
00:35:58,470 --> 00:36:00,780
0,210 210,450 450,630 630,1260 1380,2310
not actually being served into

1156
00:36:00,870 --> 00:36:02,160
0,300 300,630 630,960 960,1050 1050,1290
the file system,| the local
|工作站1上的本地文件系统，

1157
00:36:02,160 --> 00:36:03,900
0,210 210,600 600,840 840,1200 1200,1740
{[] -} file system {at,workstation}

1158
00:36:03,900 --> 00:36:04,760
0,420
1,|
|

1159
00:36:04,970 --> 00:36:06,920
0,480 480,1200 1230,1530 1530,1620 1620,1950
{} has called the local
已调用本地释放操作。

1160
00:36:06,920 --> 00:36:08,100
0,300 300,870
release operation.|
|

1161
00:36:08,300 --> 00:36:09,410
0,180 180,450 450,570 570,960 960,1110
And then it sees that
然后它看到本地释放操作什么时候进行，

1162
00:36:09,410 --> 00:36:10,610
0,240 240,300 300,600 600,900 900,1200
when does the local release

1163
00:36:10,610 --> 00:36:12,050
0,480 480,570 570,960 960,1200 1200,1440
operation,| it sees that there's
|它看到有一个撤销等待着，

1164
00:36:12,050 --> 00:36:14,360
0,420 420,810 810,1290 1320,1770 1770,2310
{} a revoke {} waiting,|
|

1165
00:36:14,600 --> 00:36:15,830
0,180 180,270 270,450 450,960 1080,1230
so at this point, it's
因此，在这一点上，它将刷新其缓存状态，即您对Petal知道的缓存状态。

1166
00:36:15,830 --> 00:36:18,110
0,120 120,180 180,990 1500,1920 1920,2280
going to flush its cache

1167
00:36:18,110 --> 00:36:19,020
0,540
state,

1168
00:36:21,730 --> 00:36:23,590
0,540 540,990 990,1080 1080,1230 1230,1860
cache state you know to

1169
00:36:23,680 --> 00:36:25,160
0,570
Petal.|
|

1170
00:36:26,180 --> 00:36:27,260
0,240 240,510 510,630 630,900 900,1080
And ones that actually have
以及实际上将高速缓存状态刷新为花瓣的那些，

1171
00:36:27,260 --> 00:36:28,400
0,270 270,600 600,840 840,1050 1050,1140
a flush cache state to

1172
00:36:28,400 --> 00:36:31,040
0,570 690,1080 1080,1350 1350,2040 2070,2640
Petal,| {} it will grant
|它将基本上授予撤销或接受撤销

1173
00:36:31,040 --> 00:36:33,260
0,450 450,1050 1290,1680 1740,2130 2130,2220
basically revoke or accept the

1174
00:36:33,260 --> 00:36:35,210
0,540 660,1200 1200,1440 1440,1770 1770,1950
revoke| and send back a
|并向锁定服务器发回释放，

1175
00:36:35,210 --> 00:36:36,260
0,300 300,390 390,540 540,690 690,1050
release {to -} lock server,|
|

1176
00:36:36,260 --> 00:36:37,310
0,120 120,480 480,540 540,750 750,1050
so then the lock can
那么锁就可以分配给2号工作站了。这有意义吗？

1177
00:36:37,310 --> 00:36:39,770
0,300 300,750 990,1680 1680,2340 2340,2460
there be assigned to {}

1178
00:36:39,770 --> 00:36:40,760
0,450 450,720
workstation 2.

1179
00:36:43,590 --> 00:36:44,540
0,150 150,300 300,600
{Is,that} makes sense?|
|

1180
00:36:48,620 --> 00:36:50,450
0,330 330,810 1080,1380 1380,1650 1650,1830
{} So just make sure,|
所以只要确保，|

1181
00:36:50,450 --> 00:36:51,830
0,210 210,480 480,660 660,960 960,1380
so in this create operation
因此，在这里的创建操作中，

1182
00:36:51,830 --> 00:36:52,880
0,150 150,300 300,420 420,510 510,1050
here,| we have to modify
|我们必须修改inode，

1183
00:36:52,880 --> 00:36:54,980
0,450 450,600 600,990 1050,1500 1530,2100
the {inode -} for,| so
|因此，我们必须修改f的inode

1184
00:36:55,490 --> 00:36:56,450
0,360 360,510 510,600 600,900 900,960
we have to modify the

1185
00:36:56,450 --> 00:36:57,440
0,150 150,300 300,540 540,780 780,990
{inode -} for f| and
|和包含f的目录的inode，

1186
00:36:57,440 --> 00:36:58,370
0,120 120,240 240,450 450,540 540,930
{inode -} for the directory

1187
00:36:58,370 --> 00:36:59,570
0,120 120,450 450,870 870,1110 1110,1200
that contains f,| because we
|因为我们必须更新参考资料

1188
00:36:59,570 --> 00:37:01,130
0,180 180,450 480,870 870,960 960,1560
have to update the references|
|

1189
00:37:01,340 --> 00:37:02,690
0,180 180,600 600,840 840,1050 1050,1350
and so that means that,|
这就意味着，|

1190
00:37:02,690 --> 00:37:05,210
0,1170 1170,1230 1260,1830 1830,2220 2220,2520
{} is like technically speaking
从技术上讲，我们实际上持有两把锁，

1191
00:37:05,210 --> 00:37:07,020
0,150 150,480 480,870 870,1530
we're actually holding two

1192
00:37:07,260 --> 00:37:09,060
0,330 330,1020 1020,1470 1470,1620 1620,1800
{} locks,| and we have
|在回复撤销请求之前，我们必须释放这两个人。

1193
00:37:09,060 --> 00:37:10,020
0,120 120,450 450,660 660,780 780,960
to release both of them

1194
00:37:10,020 --> 00:37:11,010
0,270 270,390 390,750 750,900 900,990
before we reply back to

1195
00:37:11,010 --> 00:37:15,390
0,180 1170,3840 3840,4020 4020,4170 4170,4380
the {the,revoke,request}.| {Yes,actually,} this read
|是的，实际上这是读了报纸，然后真正谈到了这个问题，

1196
00:37:15,390 --> 00:37:16,230
0,60 60,300 300,390 390,540 540,840
the paper and then really

1197
00:37:16,230 --> 00:37:17,310
0,180 180,360 360,540 540,870 870,1080
talk about this issue,| but
|但从根本上说，他们有一些，

1198
00:37:17,310 --> 00:37:18,540
0,450 450,630 630,840 840,900 900,1230
basically they sort of have,|
|

1199
00:37:19,210 --> 00:37:20,770
0,480 480,960 960,1110 1110,1380 1380,1560
not very {coarse-grained - -}
不是非常粗粒度的锁，

1200
00:37:20,770 --> 00:37:22,270
0,330 330,480 480,660 660,990 990,1500
locks,| but also very fine-grained
|而且还有非常细粒度的锁，锁，

1201
00:37:22,270 --> 00:37:24,070
0,600 600,900 900,1350 1350,1470 1470,1800
lock, [] locks,| they basically
|他们基本上每个信息节点都有一个锁

1202
00:37:24,070 --> 00:37:26,140
0,150 150,180 180,1440 1440,1590 1590,2070
have a {lock,you,know,per} {inode -}|
|

1203
00:37:26,440 --> 00:37:27,490
0,360 360,450 450,600 600,690 690,1050
and you know the {directory's
您知道目录的索引节点、文件的索引节点

1204
00:37:27,490 --> 00:37:28,450
0,120 120,240 240,540 540,870 870,960
-} {inode -}, {file's -}

1205
00:37:28,450 --> 00:37:30,070
0,150 150,600 870,1350 1350,1560 1560,1620
{inode -}| {} and in
|事实上，该目录只不过是具有特定格式、格式

1206
00:37:30,070 --> 00:37:30,940
0,210 210,270 270,570 570,630 630,870
fact the directory is nothing

1207
00:37:30,940 --> 00:37:32,170
0,210 210,300 300,390 390,720 720,1230
else than a file with

1208
00:37:32,380 --> 00:37:34,400
0,840 930,1080 1080,1770
specific a format,

1209
00:37:34,580 --> 00:37:36,290
0,630 810,1110 1110,1320 1320,1470 1470,1710
format,| {} and so {}
|所以真正地创建f，

1210
00:37:36,290 --> 00:37:37,910
0,300 300,600 600,990 990,1320 1320,1620
really create f,| we actually
|我们实际上必须分配，首先分配锁，或者需要目录d中的锁

1211
00:37:37,910 --> 00:37:39,920
0,210 210,360 360,930 1020,1500 1500,2010
have to allocate, first allocate

1212
00:37:39,920 --> 00:37:41,600
0,60 60,540 750,1140 1170,1620 1620,1680
the lock or require the

1213
00:37:41,600 --> 00:37:42,920
0,270 270,360 360,420 420,810 810,1320
lock in the directory d|
|

1214
00:37:43,160 --> 00:37:44,750
0,210 210,660 660,810 810,1080 1080,1590
and then you would allocate
然后为f分配或请求inode上的锁，

1215
00:37:44,750 --> 00:37:46,070
0,270 270,600 600,990 990,1050 1050,1320
{} or require the lock

1216
00:37:46,070 --> 00:37:48,800
0,390 390,1470 1530,1620 1620,2160 2190,2730
on {} {inode -} {}

1217
00:37:48,920 --> 00:37:49,840
0,450 450,810
for f,|
|

1218
00:37:49,950 --> 00:37:50,940
0,270 270,450 450,600 600,840 840,990
and so do hold two
所以一定要有两把锁。

1219
00:37:50,940 --> 00:37:51,740
0,540
locks.|
|

1220
00:37:52,060 --> 00:37:53,860
0,390 390,540 540,1020 1050,1680 1680,1800
And as you probably have
正如你可能已经注意到的，你知道

1221
00:37:53,860 --> 00:37:55,300
0,420 420,480 480,870 870,1170 1170,1440
noticed you know| of course
|当然，当您必须获取多个锁时，

1222
00:37:55,300 --> 00:37:55,990
0,90 90,330 330,390 390,510 510,690
you soon as you have

1223
00:37:55,990 --> 00:37:57,340
0,150 150,480 480,810 810,1110 1110,1350
to acquire multiple locks,| there's
|存在陷入僵局的潜在风险，

1224
00:37:57,340 --> 00:37:59,650
0,390 750,1350 1350,1650 1650,1740 1740,2310
a potential risk of deadlock,|
|

1225
00:37:59,650 --> 00:38:02,260
0,360 360,690 690,930 930,1440 1920,2610
if one {workstation -} allocates
如果一个工作站以不同的顺序分配锁，

1226
00:38:02,260 --> 00:38:03,580
0,270 270,360 360,420 420,720 720,1320
locks in a different order,|
|

1227
00:38:03,580 --> 00:38:04,720
0,90 90,180 180,330 330,540 540,1140
you can have a deadlock,|
你可能会陷入僵局，|

1228
00:38:04,990 --> 00:38:06,940
0,390 390,690 690,1080 1080,1380 1380,1950
so {Frangipani -} follows rules
因此，Frangipani遵循的规则是，基本上所有的锁都以特定的方式排序

1229
00:38:06,940 --> 00:38:08,620
0,90 90,540 540,810 810,1260 1260,1680
that basically all locks ordered

1230
00:38:08,620 --> 00:38:09,940
0,150 150,210 210,570 570,1050 1140,1320
in a particular way| be
|被要求按固定顺序锁上锁。

1231
00:38:09,940 --> 00:38:11,920
0,540 540,600 600,930 930,1710 1710,1980
required the locks {in,a} fixed

1232
00:38:11,920 --> 00:38:12,420
0,360
order.|
|

1233
00:38:14,370 --> 00:38:15,510
0,150 150,270 270,450 450,630 900,1140
I say, thank you.| I
我说，谢谢你。|我想锁是按锁、信息节点号排序的。

1234
00:38:15,510 --> 00:38:16,590
0,150 150,210 210,450 450,810 810,1080
think the locks ordered by

1235
00:38:16,590 --> 00:38:17,940
0,300 300,570 570,720 720,870 870,1350
lock, {} {inode -} number.|
|

1236
00:38:21,480 --> 00:38:22,620
0,210 210,330 330,480 480,870
So {does,that} makes sense?|
那么，这说得通吗？|

1237
00:38:23,840 --> 00:38:24,620
0,180 180,300 300,480 480,540 540,780
Yeah, so there's a bunch
是的，所以那里有很多更复杂的东西。

1238
00:38:24,620 --> 00:38:25,900
0,210 210,660 660,960
more complexity there.|
|

1239
00:38:29,180 --> 00:38:31,020
0,480 510,900 930,1500
Okay, so the.|
好的，所以。|

1240
00:38:31,660 --> 00:38:33,670
0,120 120,240 240,840 1110,1500 1500,2010
You know, so having discussed
您知道，至少在崩溃期间讨论了文件系统操作的[]和其他[]，

1241
00:38:33,670 --> 00:38:34,900
0,300 300,450 450,660 660,1170 1170,1230
[] and other [] of

1242
00:38:34,900 --> 00:38:36,400
0,240 240,480 480,1020 1020,1080 1080,1500
file system operations at least

1243
00:38:36,400 --> 00:38:38,350
0,330 330,870 1260,1410 1410,1710 1710,1950
during crashes,| you know if
|你知道，如果没有撞车，

1244
00:38:38,350 --> 00:38:39,670
0,150 150,300 300,840 990,1200 1200,1320
there's no crashes,| {you,know} at
|你知道，至少可以保证这些操作是自动进行的，

1245
00:38:39,670 --> 00:38:40,960
0,180 180,330 330,870 870,990 990,1290
least it's guaranteed that these

1246
00:38:40,960 --> 00:38:43,570
0,630 630,1440 1440,1800 1800,2340 2340,2610
{} operations happen atomically,| because
|因为锁确保了原子性，

1247
00:38:43,570 --> 00:38:45,310
0,90 90,510 510,1140 1140,1470 1470,1740
the locks ensure {atomicity -},|
|

1248
00:38:45,760 --> 00:38:47,080
0,150 150,690 750,990 990,1230 1230,1320
of course it could be
当然有可能是这样的，

1249
00:38:47,080 --> 00:38:48,190
0,90 90,480 480,720 720,900 900,1110
the case,| that like we're
|好像我们不走运一样，对吗？

1250
00:38:48,190 --> 00:38:50,530
0,660 690,1020 1020,1230 1230,1620 2040,2340
unlucky right| and so {}
|因此工作站1崩溃，

1251
00:38:50,530 --> 00:38:52,780
0,150 150,780 780,1110 1110,1650 1650,2250
the workstation 1 crashes,| right
|就在这些行动的中间，

1252
00:38:52,780 --> 00:38:53,530
0,150 150,210 210,480 480,570 570,750
in the middle of these

1253
00:38:53,530 --> 00:38:55,360
0,570 570,660 660,1050 1050,1260 1260,1830
operations,| for example as allocated
|例如在分配给索引节点时，

1254
00:38:55,360 --> 00:38:56,980
0,720 720,840 840,990 990,1380 1500,1620
allocated the {inode -},| it
|它实际上还没有更新目录。

1255
00:38:56,980 --> 00:38:58,000
0,210 210,330 330,540 540,930 930,1020
actually has not updated the

1256
00:38:58,000 --> 00:38:58,780
0,420 420,720
directory yet.|
|

1257
00:38:59,540 --> 00:39:01,520
0,420 630,1320 1440,1800 1800,1890 1890,1980
And, {} let's say the
让我们假设坠机发生在这里，

1258
00:39:01,520 --> 00:39:02,840
0,270 270,600 600,960
crash happens here,|
|

1259
00:39:04,270 --> 00:39:05,900
0,420 420,510 510,690 690,1320
{} you know and
你知道，如果我们不做些特别的事，

1260
00:39:06,160 --> 00:39:06,910
0,150 150,210 210,390 390,450 450,750
if we don't do anything

1261
00:39:06,910 --> 00:39:08,110
0,450 450,690 690,930 930,1080 1080,1200
special,| like what is the
|比如我们可能会有什么顾虑。

1262
00:39:08,110 --> 00:39:09,130
0,60 60,570 570,690 690,810 810,1020
the concern that we might

1263
00:39:09,130 --> 00:39:09,920
0,450
have.|
|

1264
00:39:17,100 --> 00:39:18,870
0,240 240,390 390,600 600,1080 1290,1770
Okay, let me {} concern
好吧，让我来考虑一下我们可能会有，

1265
00:39:18,870 --> 00:39:20,010
0,120 120,330 330,660 690,960 960,1140
we might have,| you know
|您知道，某些文件系统操作实际上只部分应用于Petal，

1266
00:39:20,010 --> 00:39:21,720
0,210 210,810 810,960 960,1500 1500,1710
some file system operation actually

1267
00:39:21,720 --> 00:39:23,070
0,180 180,390 390,930 930,1230 1230,1350
is only partially apply to

1268
00:39:23,070 --> 00:39:23,840
0,450
Petal,|
|

1269
00:39:24,220 --> 00:39:25,750
0,600 600,1110 1110,1230 1230,1380 1380,1530
{} and you know that
你知道这一点变得更清楚了，

1270
00:39:25,750 --> 00:39:27,070
0,270 270,390 390,960 1020,1200 1200,1320
becomes more clear,| if we
|如果我们真的想一想这个场景

1271
00:39:27,070 --> 00:39:29,110
0,240 240,450 450,930 960,1380 1410,2040
actually think about the scenario|
|

1272
00:39:29,110 --> 00:39:30,340
0,270 270,510 510,930 930,1020 1020,1230
what actually happens in this
在这个特殊的状态下到底发生了什么，

1273
00:39:30,340 --> 00:39:32,890
0,360 360,840 840,1050 1050,1830 2070,2550
particular state,| like when the
|就像缓存的状态实际上刷新为花瓣时一样。

1274
00:39:32,920 --> 00:39:34,540
0,690 720,840 840,930 930,1350 1350,1620
state of the cache actually

1275
00:39:34,540 --> 00:39:36,400
0,630 780,1170 1170,1620
flushed to Petal.|
|

1276
00:39:36,650 --> 00:39:37,430
0,270 270,390 390,570 570,660 660,780
And so this is the
因此，这就是崩溃恢复的主题。

1277
00:39:37,430 --> 00:39:38,960
0,330 330,390 390,690 690,1230
topic of crash recovery.|
|

1278
00:39:50,240 --> 00:39:51,170
0,120 120,360 360,540 540,690 690,930
It turns out that actually
事实证明，实际上更新中的状态，

1279
00:39:51,170 --> 00:39:53,720
0,330 330,420 420,780 780,1260 1290,2550
updating the state in {},|
|

1280
00:39:54,140 --> 00:39:56,780
0,930 930,1380 1380,1980 2010,2310 2310,2640
updating {state,in} Petal also follows
更新Petal中的状态实际上也遵循了非常仔细的协议，

1281
00:39:56,780 --> 00:39:59,120
0,330 330,540 540,930 930,1500 1950,2340
actually pretty careful protocol,| and
|这种协议通常被称为预写日志记录。

1282
00:39:59,120 --> 00:40:00,950
0,180 180,600 600,810 810,1290 1290,1830
this protocol some is typically

1283
00:40:00,950 --> 00:40:02,440
0,240 240,450 450,600 600,1020
called {write-ahead -} logging.|
|

1284
00:40:21,570 --> 00:40:22,320
0,210 210,360 360,480 480,660 660,750
And this is {} you
这可能是我们已经看到的术语

1285
00:40:22,320 --> 00:40:23,190
0,90 90,420 420,510 510,750 750,870
know probably the term we've

1286
00:40:23,190 --> 00:40:24,840
0,270 270,840 840,1230 1230,1470 1470,1650
already seen| {} and you've
|你们可能已经在6.033中看到过，

1287
00:40:24,840 --> 00:40:27,120
0,270 270,630 630,1590 1830,2250 2250,2280
seen probably {in,6.033}, { -}|
|

1288
00:40:27,120 --> 00:40:28,500
0,600 600,900 900,1020 1020,1110 1110,1380
and {} you know Petal
你知道花瓣使用它也是一种非常常见的技术，

1289
00:40:28,500 --> 00:40:29,730
0,390 390,630 630,750 750,930 930,1230
{use,it} too is a very

1290
00:40:29,730 --> 00:40:31,020
0,300 300,840 870,990 990,1170 1170,1290
common technique,| and it will
|它也将在随后的论文中发挥重要作用，这些论文将看到

1291
00:40:31,020 --> 00:40:32,310
0,240 240,450 450,570 570,870 870,1290
also play a big important

1292
00:40:32,310 --> 00:40:34,260
0,330 330,870 990,1530 1530,1830 1830,1950
role in subsequent papers that

1293
00:40:34,260 --> 00:40:36,030
0,120 120,450 660,870 870,1260 1320,1770
will see| and so {}
|所以花瓣实际上是一个很好的重新引入

1294
00:40:36,030 --> 00:40:37,020
0,270 270,330 330,570 570,600 600,990
Petal is actually a nice

1295
00:40:37,020 --> 00:40:39,330
0,870 870,1260 1260,1590 1680,1920 1920,2310
reintroduction| to {} this idea
|对于这种预写日志记录的想法

1296
00:40:39,330 --> 00:40:41,490
0,210 210,720 750,1020 1020,1410 1980,2160
of {} write-ahead logging| and
|以及一种思考写作的方式，

1297
00:40:41,490 --> 00:40:42,240
0,60 60,300 300,420 420,540 540,750
a way to think about

1298
00:40:42,240 --> 00:40:45,210
0,300 300,540 540,630 630,1110 2250,2970
write,| {you,know} {} gonna Petal
|你知道吗，Will Petal是为预写日志设计的，

1299
00:40:45,210 --> 00:40:46,110
0,360 360,420 420,630 630,690 690,900
designed to {write-ahead - -}

1300
00:40:46,110 --> 00:40:47,790
0,480 630,1170 1170,1290 1290,1500 1500,1680
logging,| use of {wirte-ahead -}
|预写日志记录的使用与任何其他预写日志记录方案非常相似

1301
00:40:47,790 --> 00:40:49,200
0,270 270,390 390,600 600,1050 1050,1410
logging is very similar to

1302
00:40:49,200 --> 00:40:50,340
0,300 300,480 480,660 660,870 870,1140
any other {write-ahead -} logging

1303
00:40:50,340 --> 00:40:51,930
0,450 780,930 930,1290 1410,1500 1500,1590
scheme| and so you know
|所以你知道思考它的方式如下，

1304
00:40:51,930 --> 00:40:52,560
0,90 90,210 210,300 300,420 420,630
the way to think about

1305
00:40:52,560 --> 00:40:53,700
0,90 90,240 240,870 870,960 960,1140
it as follows,| you know
|您知道，我们有我们的磁盘、虚拟磁盘、

1306
00:40:53,700 --> 00:40:55,260
0,120 120,360 360,570 570,1050 1080,1560
we have our disk, virtual

1307
00:40:55,260 --> 00:40:55,680
0,360
disk,|
|

1308
00:40:56,390 --> 00:40:57,320
0,120 120,300 300,480 480,660 660,930
I mean just think about
我的意思是，只要把磁盘想象成一个很长、很长、很长的块阵列，

1309
00:40:57,320 --> 00:40:59,510
0,270 270,480 480,660 660,930 1500,2190
disk as like a long

1310
00:40:59,510 --> 00:41:01,310
0,330 390,780 780,1050 1050,1140 1140,1800
general long array of blocks,|
|

1311
00:41:01,900 --> 00:41:03,670
0,480 480,960 960,1230 1230,1500 1500,1770
and what they've done is
他们所做的是将磁盘的一部分保留为日志，

1312
00:41:03,670 --> 00:41:05,320
0,300 300,390 390,900 990,1500 1500,1650
part of the disk is

1313
00:41:05,320 --> 00:41:08,260
0,780 780,900 900,960 960,1530 2820,2940
reserved as a log,| in
|事实上，在花瓣的案例中，

1314
00:41:08,260 --> 00:41:09,370
0,330 330,630 630,810 810,1050 1050,1110
fact in the case of

1315
00:41:09,370 --> 00:41:10,600
0,510 540,720 720,750 750,1080 1080,1230
Petal,| there's a log per
|每台服务器都有一个日志，

1316
00:41:10,600 --> 00:41:12,220
0,510 540,750 750,960 960,1290 1290,1620
server,| but let's, for now,
|但现在，让我们假设有一个单一的日志

1317
00:41:12,220 --> 00:41:13,480
0,270 270,510 510,870 870,1110 1110,1260
let's just assume there's like

1318
00:41:13,480 --> 00:41:15,070
0,210 210,480 480,960 1290,1470 1470,1590
one single log| and then
|然后是文件系统，

1319
00:41:15,070 --> 00:41:16,280
0,150 150,240 240,480 480,960
there's the file system,|
|

1320
00:41:17,060 --> 00:41:18,200
0,420 420,750 750,960 960,1050 1050,1140
so there's part of the
所以有一部分磁盘是为日志保留的

1321
00:41:18,200 --> 00:41:19,970
0,300 300,570 570,1020 1020,1170 1170,1770
disk is reserved for logging|
|

1322
00:41:19,970 --> 00:41:20,720
0,150 150,330 330,390 390,480 480,750
or part of the disk
或者磁盘的一部分是文件系统

1323
00:41:20,720 --> 00:41:21,800
0,150 150,360 360,660 660,990 990,1080
is the file system| and
|并且文件系统包含索引节点，

1324
00:41:21,800 --> 00:41:23,090
0,90 90,330 330,600 600,960 960,1290
the file system contains {inodes

1325
00:41:23,090 --> 00:41:24,260
0,600
-},|
|

1326
00:41:24,560 --> 00:41:25,670
0,120 120,510 510,720 720,870 870,1110
you know, and some data
你知道，还有一些数据块等等。

1327
00:41:25,670 --> 00:41:27,640
0,630 630,960 960,1620
block, etc, etc.|
|

1328
00:41:28,120 --> 00:41:29,920
0,570 690,900 900,1200 1200,1380 1380,1800
And the rule is that
规则是，当您更新Petal中的状态时，

1329
00:41:30,130 --> 00:41:32,020
0,690 720,990 990,1530 1530,1620 1620,1890
when you update the state

1330
00:41:32,020 --> 00:41:32,980
0,120 120,660
in Petal,|
|

1331
00:41:33,160 --> 00:41:34,360
0,240 240,510 510,660 660,750 750,1200
the first thing you do
你要做的第一件事实际上是你的第一次日志更新，

1332
00:41:34,450 --> 00:41:36,940
0,150 150,420 420,870 1200,1740 1740,2490
is actually your first log

1333
00:41:36,940 --> 00:41:37,600
0,360
update,|
|

1334
00:41:43,840 --> 00:41:45,190
0,210 210,690 720,1140 1140,1260 1260,1350
so when, {} if we
所以，如果我们回到上一张照片，

1335
00:41:45,190 --> 00:41:46,270
0,90 90,300 300,600 600,720 720,1080
go back to the previous

1336
00:41:46,270 --> 00:41:49,030
0,630 750,1620 1620,2130 2130,2250 2250,2760
picture,| and after the point
|在工作站1上的鸡蛋饼点之后，

1337
00:41:49,030 --> 00:41:51,020
0,120 120,120
that the

1338
00:41:51,580 --> 00:41:53,620
0,660 660,750 750,1230 1230,1740 1950,2040
Frangipani on workstation 1,| I
|我想把锁还给你，

1339
00:41:53,620 --> 00:41:54,610
0,300 300,390 390,570 570,900 900,990
wanted to give back the

1340
00:41:54,610 --> 00:41:55,930
0,420 420,570 570,750 750,870 870,1320
lock,| {you,know} to the {lock,server},|
|你知道对锁服务器来说，|

1341
00:41:55,930 --> 00:41:57,460
0,180 180,780 780,960 960,1230 1230,1530
it first has to write
它首先要把它的状态写给花瓣

1342
00:41:57,460 --> 00:41:58,600
0,150 150,630 630,720 720,870 870,1140
its state you know to

1343
00:41:58,600 --> 00:41:59,650
0,420 420,540 540,720 720,960 960,1050
Petal| and that goes in
|这分为两个步骤，

1344
00:41:59,650 --> 00:42:01,390
0,150 150,720 930,1170 1170,1440 1440,1740
two steps,| the first step
|第一步是锁定，更新更新的描述，

1345
00:42:01,390 --> 00:42:03,910
0,330 390,900 900,1440 1440,2430 2430,2520
is lock the, update the

1346
00:42:03,910 --> 00:42:05,170
0,540 540,630 630,720 720,1200 1200,1260
description of the update,| you
|你知道日志，锁定操作，

1347
00:42:05,170 --> 00:42:07,120
0,120 120,780 780,1020 1050,1680 1800,1950
know to the log, the

1348
00:42:07,120 --> 00:42:08,890
0,330 330,810 810,900 900,1170 1170,1770
lock operation,| {} {here,for} example
|例如，在这里，我们将获得一张记录，

1349
00:42:09,070 --> 00:42:10,540
0,330 330,510 510,570 570,1110
we'll get a record,|
|

1350
00:42:10,910 --> 00:42:12,980
0,480 480,1050 1050,1140 1140,1320 1320,2070
that's says you know create
这就是说，您知道CREATE BASIC描述了创建操作，

1351
00:42:13,010 --> 00:42:15,200
0,540 540,1230 1230,1380 1380,1710 1710,2190
basic describes the create operation,|
|

1352
00:42:15,200 --> 00:42:16,970
0,360 360,540 540,750 750,1230 1590,1770
so that will have you
因此这将使您知道分配了什么inode，

1353
00:42:16,970 --> 00:42:18,620
0,120 120,450 450,900 900,1140 1140,1650
know whatever allocate {inode -},|
|

1354
00:42:19,690 --> 00:42:21,130
0,150 150,330 330,810 810,1200 1200,1440
{inode -} number whatever {}
索引节点号，不管结果是什么，

1355
00:42:21,130 --> 00:42:22,420
0,510 510,630 630,1050 1050,1170 1170,1290
basically the result that would

1356
00:42:22,420 --> 00:42:23,560
0,90 90,450 450,570 570,660 660,1140
have happened,| if you allocated
|如果您分配了inode并且目录发生了更改。

1357
00:42:23,560 --> 00:42:26,260
0,420 420,900 900,1440 1470,2040 2040,2700
{inode -} {and,the} directory changed.|
|

1358
00:42:30,900 --> 00:42:31,650
0,270 270,420 420,540 540,600 600,750
It will be a little
稍后我们会更具体一点，

1359
00:42:31,650 --> 00:42:32,370
0,120 120,240 240,600 600,660 660,720
bit more specific in a

1360
00:42:32,370 --> 00:42:33,240
0,270 270,450 450,630 630,750 750,870
second,| but that's sort of
|但这在某种程度上是更新包含了修改，

1361
00:42:33,240 --> 00:42:35,490
0,510 660,840 840,1260 1260,2010 2040,2250
the the update contains the

1362
00:42:35,490 --> 00:42:36,720
0,300 300,660 660,900 900,1020 1020,1230
{modifications -},| need to be
|需要发生在文件系统块上，

1363
00:42:36,780 --> 00:42:38,340
0,300 300,390 390,900 1020,1380 1380,1560
made to happen to the

1364
00:42:38,340 --> 00:42:40,710
0,270 270,540 540,1110 1170,1770 1770,2370
file system blocks,| {to,actually} {}
|为了真正反映这一变化，

1365
00:42:40,740 --> 00:42:43,230
0,720 720,810 810,1320 1800,2010 2010,2490
reflect the change,| so first
|所以首先登录到，

1366
00:42:43,260 --> 00:42:45,270
0,540 540,600 600,840 840,1680 1710,2010
log to the,| {} first
|首先记录更新

1367
00:42:45,270 --> 00:42:46,980
0,300 300,390 390,930 1170,1320 1320,1710
log the update| and then
|然后，一旦您更新了日志，

1368
00:42:46,980 --> 00:42:48,570
0,300 300,420 420,540 540,1500 1500,1590
once you have updated the

1369
00:42:48,570 --> 00:42:49,260
0,540
log,|
|

1370
00:42:49,610 --> 00:42:51,740
0,540 540,1260 1290,1380 1380,1680 1680,2130
then we, the second operation
然后我们，客户端的第二个操作执行，

1371
00:42:51,740 --> 00:42:53,720
0,120 120,630 660,1080 1080,1680 1740,1980
of the client executes,| the
|执行的工作站实际上是在安装更新，

1372
00:42:53,720 --> 00:42:55,790
0,420 420,990 1020,1200 1200,1470 1470,2070
workstation executes is actually installing

1373
00:42:55,790 --> 00:42:57,620
0,90 90,600
the update,|
|

1374
00:43:01,870 --> 00:43:02,960
0,780

1375
00:43:03,370 --> 00:43:06,040
0,630 840,1380 1440,2040 2040,2040 2040,2670
and {the -} {} reason
你知道做两个步骤的原因是，

1376
00:43:06,160 --> 00:43:07,300
0,210 210,360 360,570 570,960 960,1140
you know for doing sort

1377
00:43:07,300 --> 00:43:09,070
0,60 60,210 210,810 930,1230 1230,1770
of two steps is that,|
|

1378
00:43:09,160 --> 00:43:11,080
0,210 210,330 330,990 1020,1590 1590,1920
you know once you've log
你知道，一旦你记录了所有的变化，

1379
00:43:11,080 --> 00:43:13,450
0,150 150,300 300,960 1320,2070 2100,2370
all your changes,| then {}
|那么更新数据块就完全安全了，

1380
00:43:13,450 --> 00:43:14,920
0,150 150,540 540,990 990,1080 1080,1470
it's completely safe to update

1381
00:43:14,920 --> 00:43:15,940
0,60 60,360 360,660 660,900 900,1020
the data blocks,| because they
|因为它们总是会结束并更新文件系统

1382
00:43:15,940 --> 00:43:17,830
0,600 600,750 750,930 930,1230 1230,1890
always will end up and

1383
00:43:18,100 --> 00:43:19,240
0,300 300,360 360,780 780,870 870,1140
update the {file,system}| and it
|它应该总是以一致的状态结束

1384
00:43:19,240 --> 00:43:20,200
0,120 120,510 510,630 630,810 810,960
should always will end up

1385
00:43:20,200 --> 00:43:22,570
0,90 90,150 150,600 600,1110 1710,2370
in a consistent state {}|
|

1386
00:43:22,870 --> 00:43:24,010
0,510 510,720 720,870 870,990 990,1140
and the way to see
而理解这一点的方法基本上是，

1387
00:43:24,010 --> 00:43:25,930
0,180 180,300 300,1020 1050,1320 1320,1920
this is basically,| let's assume
|让我们假设您知道客户端工作站

1388
00:43:25,930 --> 00:43:26,760
0,90 90,210 210,660
you know the

1389
00:43:27,130 --> 00:43:28,720
0,390 390,960 960,1110 1110,1290 1290,1590
client workstation| that was actually
|这实际上是将它的数据刷新到Petal，就在这里崩溃。

1390
00:43:28,720 --> 00:43:30,400
0,390 390,540 540,720 720,1140 1140,1680
flushing it's data to Petal,

1391
00:43:31,330 --> 00:43:33,160
0,600 600,1140 1140,1560
crashes right here.|
|

1392
00:43:34,840 --> 00:43:35,900
0,750

1393
00:43:36,870 --> 00:43:37,920
0,150 150,300 300,780
Is that okay?|
可以吗？|

1394
00:43:43,900 --> 00:43:45,820
0,480 480,930 930,1260 1260,1740 1740,1920
Yes, because since everything is
是的，因为所有东西都被锁住了，

1395
00:43:45,820 --> 00:43:47,950
0,450 450,990 1380,1710 1710,1950 1950,2130
locked,| they {} what was
|他们所谓的恶魔恢复服务。

1396
00:43:47,950 --> 00:43:50,890
0,90 90,420 420,660 900,1710 1740,2940
it called the demon recovery

1397
00:43:50,890 --> 00:43:53,770
0,690 900,2280 2280,2400 2400,2700 2700,2880
service.| Yeah, the demon just
|是啊，恶魔又要回去了，

1398
00:43:53,770 --> 00:43:55,930
0,570 600,780 780,1080 1080,1770 1890,2160
gonna go back to,| there's
|会有一个恶魔，

1399
00:43:55,930 --> 00:43:56,800
0,150 150,270 270,330 330,660 660,870
gonna be a demon,| when
|当发生撞车事故时，基本上就是恶魔，

1400
00:43:56,800 --> 00:43:57,910
0,150 150,210 210,570 570,780 780,1110
there's a crash, there's basically

1401
00:43:57,910 --> 00:43:59,170
0,420 420,690 690,810 810,960 960,1260
demon,| sees if there's anything
|看看日志里有没有什么东西，

1402
00:43:59,170 --> 00:44:00,040
0,120 120,210 210,600 600,690 690,870
in the log,| if there's
|如果日志里有什么，

1403
00:44:00,040 --> 00:44:00,940
0,240 240,300 300,390 390,690 690,900
anything in the log,| just
|仅适用于文件系统。

1404
00:44:00,940 --> 00:44:02,170
0,480 480,570 570,660 660,930 930,1230
applies to the file system.|
|

1405
00:44:03,830 --> 00:44:06,380
0,420 480,1980 1980,2250 2250,2400 2400,2550
And why actually do this
为什么要这样做呢？

1406
00:44:06,380 --> 00:44:07,340
0,90 90,270 270,570 570,780 780,960
in the way,| why not
|为什么不立即写入或更新文件系统？

1407
00:44:07,340 --> 00:44:08,750
0,180 180,450 450,900 900,1110 1110,1410
just write immediately or update

1408
00:44:08,750 --> 00:44:09,660
0,60 60,300 300,630
the file system?|
|

1409
00:44:14,950 --> 00:44:16,060
0,390 390,480 480,660 660,1020 1020,1110
Because we can crash in
因为我们可能会在更新过程中崩溃

1410
00:44:16,060 --> 00:44:17,200
0,60 60,390 390,510 510,780 780,1140
the middle of that update|
|

1411
00:44:17,200 --> 00:44:18,280
0,90 90,180 180,390 390,810 900,1080
and we don't know what
我们不知道我们做了什么，我们做不到。

1412
00:44:18,280 --> 00:44:20,110
0,150 150,420 420,690 690,1290 1320,1830
we've done, we can't.| Yeah,
|是的，完全正确，

1413
00:44:20,110 --> 00:44:21,940
0,450 450,690 690,900 900,1530 1530,1830
exactly correct,| so we're serving,
|所以我们正在提供服务，这是我们之前的例子，

1414
00:44:21,940 --> 00:44:23,290
0,180 180,270 270,600 600,1260 1260,1350
there's our previous example,| you
|您知道，分配inode大概是为了在某个地方进行一些更改，

1415
00:44:23,290 --> 00:44:25,960
0,360 1050,1590 1590,1800 1800,2190 2190,2670
know allocating {inode -} {is,presumably}

1416
00:44:25,960 --> 00:44:26,740
0,60 60,210 210,300 300,540 540,780
you know to making some

1417
00:44:26,740 --> 00:44:28,690
0,300 300,900 1110,1410 1410,1680 1680,1950
change somewhere,| like onto {inode
|类似于索引节点数据块

1418
00:44:28,690 --> 00:44:30,700
0,180 180,630 1020,1470 1470,1710 1710,2010
-} block| and actually adding
|并且实际将目录添加到特定目录或将文件f添加到特定目录，

1419
00:44:30,700 --> 00:44:33,280
0,90 90,810 810,1530 1740,2340 2340,2580
the directory to {} or

1420
00:44:33,280 --> 00:44:34,720
0,300 300,390 390,750 750,1080 1080,1440
adding the file f to

1421
00:44:34,720 --> 00:44:36,850
0,300 300,720 870,1350 1350,1740 1740,2130
particular directory,| updates directory block,
|更新目录块、某处的数据块

1422
00:44:36,850 --> 00:44:38,710
0,240 240,510 510,1110 1470,1680 1680,1860
data block somewhere,| so these
|所以这是两个不同的写入，对吧，

1423
00:44:38,710 --> 00:44:40,060
0,60 60,210 210,570 570,1080 1110,1350
are two separate writes, right,|
|

1424
00:44:40,060 --> 00:44:41,140
0,90 90,420 420,870 870,960 960,1080
two separate {disk,los} and they're
两个独立的圆盘丢失，它们不是原子的，

1425
00:44:41,140 --> 00:44:42,280
0,210 210,630 630,840 840,990 990,1140
not atomic,| so we would
|所以我们会在两者中的一个之间坠毁，

1426
00:44:42,280 --> 00:44:43,300
0,300 300,600 600,810 810,900 900,1020
crash between one of the

1427
00:44:43,300 --> 00:44:44,590
0,480 660,870 870,960 960,1170 1170,1290
two,| then we might have
|那么我们可能已经分配了索引节点，

1428
00:44:44,590 --> 00:44:45,700
0,480 480,570 570,720 720,990 990,1110
allocated the {inode -},| but
|但不会卡在目录中。

1429
00:44:45,700 --> 00:44:46,840
0,210 210,390 390,570 570,630 630,1140
not stuck in the directory.|
|

1430
00:44:47,540 --> 00:44:49,550
0,300 300,630 630,1290 1290,1560 1560,2010
Then basically what will happen
那么基本上，如果我们坠毁并恢复，会发生什么，

1431
00:44:49,550 --> 00:44:50,930
0,120 120,360 360,690 690,780 780,1380
if we crash and recover,|
|

1432
00:44:50,960 --> 00:44:52,340
0,450 450,690 690,810 810,930 930,1380
basically lose the {inode -},|
基本上失去了inode，|

1433
00:44:52,970 --> 00:44:54,170
0,450 450,720 720,840 840,1140 1140,1200
unless we could scan the
除非我们能扫描整个磁盘，但那是非常昂贵的。

1434
00:44:54,170 --> 00:44:55,160
0,180 180,450 450,570 570,780 780,990
whole disk, but that's very

1435
00:44:55,160 --> 00:44:55,980
0,600
expensive.|
|

1436
00:44:57,380 --> 00:44:58,220
0,120 120,330 330,450 450,720 720,840
And so they said what
所以他们说我们正在做的是，

1437
00:44:58,220 --> 00:44:59,540
0,120 120,540 540,780 780,960 960,1320
we're doing is,| we're basically
|我们基本上是先记录这两个更改，

1438
00:44:59,540 --> 00:45:01,340
0,420 420,510 510,780 780,1290 1290,1800
logging the two changes first,|
|

1439
00:45:01,340 --> 00:45:04,100
0,1080 1110,1560 1560,2010 2010,2490 2490,2760
we're logging records describing both
我们首先记录描述这两个更改的记录

1440
00:45:04,100 --> 00:45:06,680
0,480 480,960 1320,1560 1560,2070 2100,2580
changes first| and then apply
|然后应用更改。

1441
00:45:06,680 --> 00:45:07,520
0,90 90,660
the changes.|
|

1442
00:45:08,800 --> 00:45:09,430
0,180 180,330 330,480 480,570 570,630
{} So how do we
那么我们如何确保行动是原子的，

1443
00:45:09,430 --> 00:45:10,960
0,240 240,330 330,960 960,1050 1050,1530
ensure the operation is atomic,|
|

1444
00:45:11,080 --> 00:45:12,070
0,270 270,420 420,720 720,900 900,990
so the first log to
所以第一个要更新的日志。

1445
00:45:12,070 --> 00:45:12,780
0,390
update.|
|

1446
00:45:13,140 --> 00:45:14,520
0,120 120,300 300,510 510,960 1110,1380
The first log update,| yeah
第一次日志更新，|是啊，这很有趣，

1447
00:45:14,520 --> 00:45:16,560
0,150 150,600 660,930 930,1380 1590,2040
that's interesting,| so the paper
|所以追踪100%的论文符合这一点，

1448
00:45:16,560 --> 00:45:18,120
0,270 270,360 360,630 630,1200 1200,1560
tracking a hundred percent correspond

1449
00:45:18,120 --> 00:45:19,290
0,180 180,420 600,900 900,930 930,1170
this,| but there's a couple
|但有几种方法可以做到这一点，

1450
00:45:19,290 --> 00:45:21,030
0,150 150,210 210,450 450,690 960,1740
ways of doing {it -},|
|

1451
00:45:21,030 --> 00:45:22,890
0,240 240,660 660,1260 1260,1860 1860,1860
they mention that every {}
他们提到每个日志记录都有一个校验和，

1452
00:45:23,910 --> 00:45:25,560
0,420 420,660 660,990 990,1260 1260,1650
log record has a checksum,|
|

1453
00:45:26,380 --> 00:45:28,750
0,690 690,1290 1290,1470 1470,1620 1620,2370
and, {} so they use
因此，他们使用校验和来查看是否真的存在，

1454
00:45:28,750 --> 00:45:29,800
0,390 390,510 510,750 750,870 870,1050
checksum to see if there's

1455
00:45:29,800 --> 00:45:32,110
0,570 750,1350 1530,1680 1680,1950 1950,2310
actually,| before the read log
|在读日志记录之前，你知道读日志记录，

1456
00:45:32,110 --> 00:45:33,490
0,300 300,570 570,810 810,1080 1080,1380
record, {you,know} read log record,|
|

1457
00:45:33,490 --> 00:45:34,840
0,120 120,390 390,450 450,990 1080,1350
we compute a checksum,| just
我们计算一个校验和，|只是为了确保整个记录是完整的。

1458
00:45:34,840 --> 00:45:35,440
0,60 60,210 210,390 390,540 540,600
to make sure that the

1459
00:45:35,440 --> 00:45:36,840
0,270 270,540 540,630 630,1140
whole record is complete.|
|

1460
00:45:38,620 --> 00:45:40,030
0,210 210,420 480,690 690,840 900,1410
I see, thank you.| Another
我明白了，谢谢你。|另一种方法是，

1461
00:45:40,030 --> 00:45:40,720
0,120 120,210 210,420 420,540 540,690
way of doing it,| which
|这是你写作时的一种方式，

1462
00:45:40,720 --> 00:45:41,440
0,120 120,240 240,510 510,660 660,720
is a couple way of

1463
00:45:41,440 --> 00:45:42,370
0,180 180,270 270,390 390,540 540,930
doing it as you write,|
|

1464
00:45:42,370 --> 00:45:43,510
0,90 90,180 180,180 180,480 480,1140
you know a couple blocks
你知道几个街区就像一二

1465
00:45:43,750 --> 00:45:44,800
0,270 270,450 450,840 840,960 960,1050
like one two| and then
|然后你写一个提交记录，

1466
00:45:44,800 --> 00:45:45,820
0,120 120,270 270,300 300,600 600,1020
you write a commit record,|
|

1467
00:45:46,620 --> 00:45:48,300
0,690 690,780 780,1230 1230,1380 1380,1680
and the assumption is that|
我们的假设是|

1468
00:45:48,300 --> 00:45:49,650
0,210 210,300 300,720 720,1200 1230,1350
running a single block, {}
运行单个块、单个512扇区是原子操作，

1469
00:45:49,650 --> 00:45:51,720
0,300 300,1410 1410,1860 1860,1980 1980,2070
single 512 sector is an

1470
00:45:51,720 --> 00:45:53,430
0,390 390,900 900,1110 1110,1410 1410,1710
atomic operation,| so either happens
|所以要么发生，要么不发生，

1471
00:45:53,430 --> 00:45:54,720
0,60 60,120 120,360 360,690 1080,1290
or it doesn't happen,| so
|所以你需要提交记录，说

1472
00:45:54,720 --> 00:45:55,560
0,60 60,150 150,270 270,510 510,840
you need to commit {records,says

1473
00:45:55,560 --> 00:45:57,180
0,390 420,750 750,840 840,1320 1410,1620
-}| writes are done or
|已完成写入或未完成写入

1474
00:45:57,180 --> 00:45:58,770
0,210 210,270 270,450 450,780 1170,1590
writes are not done| and
|因此，您只需查看提交记录，

1475
00:45:58,770 --> 00:45:59,400
0,120 120,240 240,330 330,510 510,630
so you can just look

1476
00:45:59,400 --> 00:46:00,420
0,60 60,120 120,390 390,750 750,1020
at the commit record,| and
|如果提交记录不在那里，

1477
00:46:00,420 --> 00:46:02,100
0,120 120,210 210,450 450,870 870,1680
if the commit records is

1478
00:46:02,100 --> 00:46:03,930
0,390 390,900 930,1110 1110,1200 1200,1830
not there,| then you know
|那么你就知道手术还没有完全记录下来

1479
00:46:03,930 --> 00:46:05,970
0,510 540,1080 1080,1200 1200,1650 1650,2040
the operation is not completely

1480
00:46:05,970 --> 00:46:07,350
0,390 390,720 870,1050 1050,1110 1110,1380
recorded yet| and you shouldn't
|你不应该执行其中任何一项。

1481
00:46:07,350 --> 00:46:08,360
0,330 330,540 540,660 660,870
execute any of it.|
|

1482
00:46:10,000 --> 00:46:11,470
0,150 150,420 510,810 810,1230 1230,1470
I see, and also to
我明白了，再仔细检查一下上一张幻灯片，

1483
00:46:11,470 --> 00:46:13,630
0,690 690,750 750,870 870,1380 1380,2160
double-check on the previous slide,|
|

1484
00:46:13,630 --> 00:46:15,370
0,210 210,390 390,780 780,1230 1230,1740
if the crash happens before
如果坠机发生在我们把东西冲到花瓣之前，

1485
00:46:15,370 --> 00:46:17,680
0,360 480,900 900,1260 1260,1710 1830,2310
we flush things to Petal,|
|

1486
00:46:17,980 --> 00:46:18,850
0,360 360,540 540,630 630,780 780,870
then this is not a
那么这不是问题，对吧，

1487
00:46:18,850 --> 00:46:20,830
0,390 390,600 600,1080 1080,1890 1890,1980
problem right,| because if the
|因为如果工作站崩溃，

1488
00:46:20,830 --> 00:46:22,390
0,480 480,960 960,1170 1170,1260 1260,1560
workstation crashes,| well the cash
|好吧，现金随工作站一起送，

1489
00:46:22,390 --> 00:46:23,590
0,240 240,360 360,420 420,1020 1020,1200
goes with the workstation,| but
|但其他任何工作站都没有不一致的状态。

1490
00:46:23,590 --> 00:46:25,030
0,300 300,450 450,1080 1080,1320 1320,1440
there's no inconsistent state for

1491
00:46:25,030 --> 00:46:27,400
0,120 120,330 330,840 1080,1650 2040,2370
any other workstation.| {That's,correct,,just} data
|这是正确的，只是数据会丢失，

1492
00:46:27,400 --> 00:46:30,280
0,90 90,180 180,660 1350,2490 2550,2880
would be lost,| if it's
|如果没有写到花瓣上，就不会有任何可见性问题。

1493
00:46:30,280 --> 00:46:31,390
0,270 270,450 450,540 540,690 690,1110
not written to the Petals,

1494
00:46:31,390 --> 00:46:33,250
0,270 270,360 360,480 480,1470 1470,1860
won't be any visibility problem.|
|

1495
00:46:33,670 --> 00:46:34,600
0,180 180,300 300,750 750,840 840,930
So it's really you know
所以这真的是你知道的坠机事件，对吧，

1496
00:46:34,600 --> 00:46:36,580
0,90 90,630 840,1170 1170,1590 1590,1980
the crash crash here, correct,|
|

1497
00:46:37,480 --> 00:46:38,710
0,150 150,360 360,540 540,720 720,1230
{} one doesn't really matter
在某些方面，一个并不重要，

1498
00:46:38,740 --> 00:46:40,030
0,90 90,270 270,810 960,1140 1140,1290
in some ways,| the one
|真正重要的是这个刷新操作中的崩溃。

1499
00:46:40,030 --> 00:46:40,960
0,90 90,360 360,690 690,810 810,930
that actually matters is the

1500
00:46:40,960 --> 00:46:42,790
0,360 360,780 780,960 960,1260 1260,1830
crash during this flush operation.|
|

1501
00:46:43,790 --> 00:46:45,260
0,690 780,990 990,1170
Mhm, thank you.|
嗯，谢谢你。|

1502
00:46:51,140 --> 00:46:52,940
0,450 480,930 1020,1590 1590,1680 1680,1800
Okay, so, {} you know
好的，所以，你知道在弗拉吉帕尼有一个巧妙的，

1503
00:46:52,940 --> 00:46:54,920
0,210 210,540 540,1320 1380,1620 1620,1980
there's one subtly {} in

1504
00:46:54,920 --> 00:46:56,240
0,240 240,300 300,720 720,930 930,1320
{Frangipani - -},| which we'll
|我们稍后会更详细地讨论这一点，

1505
00:46:56,240 --> 00:46:57,140
0,210 210,450 450,540 540,600 600,900
talk about in a second

1506
00:46:57,140 --> 00:46:58,610
0,30 30,180 180,300 300,450 480,1470
a little bit more detail,|
|

1507
00:46:58,610 --> 00:47:00,620
0,480 480,840 930,1320 1320,1740 1740,2010
namely that {in,Frangipani -} there's
也就是说，在Frangipani中，每个服务器都有一个锁，

1508
00:47:00,620 --> 00:47:01,220
0,300
{}

1509
00:47:03,320 --> 00:47:04,740
0,270 270,990
a lock

1510
00:47:05,030 --> 00:47:06,380
0,480 480,1050
per server,|
|

1511
00:47:07,300 --> 00:47:09,100
0,240 240,390 390,480 480,1230
that's sort of unusual,|
这有点不寻常，|

1512
00:47:09,410 --> 00:47:10,730
0,660 660,900 900,1050 1050,1260 1260,1320
and, {} we'll see in
而且，我们稍后会看到，

1513
00:47:10,730 --> 00:47:11,930
0,30 30,510 540,720 720,930 930,1200
a second,| you know how
|你知道，真正制造一些问题的是什么，

1514
00:47:11,930 --> 00:47:13,400
0,360 390,900 900,990 990,1230 1230,1470
the one that actually creates

1515
00:47:13,400 --> 00:47:15,650
0,120 120,780 810,1440 1740,2040 2040,2250
some problems,| {} and so
|所以我们将会看到，

1516
00:47:15,650 --> 00:47:17,900
0,780 780,960 960,1710 1710,1770 1770,2250
we'll see,| there's a small
|协议有一个小的扩展

1517
00:47:17,900 --> 00:47:19,160
0,510 510,600 600,690 690,1140 1140,1260
extension to the protocol| to
|才能真正把这一切解决掉。

1518
00:47:19,160 --> 00:47:20,210
0,360 360,600 600,780 780,900 900,1050
actually {} make this all

1519
00:47:20,210 --> 00:47:20,960
0,240 240,480
work out.|
|

1520
00:47:22,600 --> 00:47:24,190
0,390 420,720 720,1230 1260,1500 1500,1590
Okay, let me say a
好的，让我简单地说一下[]，

1521
00:47:24,190 --> 00:47:25,360
0,180 180,330 330,570 570,960 960,1170
little bit about [],| what
|其中一个日志记录中有什么，

1522
00:47:25,360 --> 00:47:26,050
0,120 120,240 240,420 420,480 480,690
is in one of those

1523
00:47:26,050 --> 00:47:27,160
0,300 300,840
log records,|
|

1524
00:47:32,570 --> 00:47:33,230
0,120 120,330 330,480 480,540 540,660
it turns out to be
事实证明，这对崩盘复苏非常重要，

1525
00:47:33,230 --> 00:47:36,320
0,540 540,1200 1230,2100 2130,2730 2760,3090
important for {} the crash

1526
00:47:36,320 --> 00:47:39,350
0,630 900,1980 1980,2250 2250,2430 2430,3030
recovery,| particularly because we have
|特别是因为我们每台服务器都有多个Frangipani日志。

1527
00:47:39,410 --> 00:47:41,390
0,240 240,660 660,990 990,1560 1650,1980
{Frangipani -} multiple logs per

1528
00:47:41,390 --> 00:47:42,140
0,510
server.|
|

1529
00:47:43,000 --> 00:47:44,260
0,150 150,360 360,720 720,930 930,1260
So every log has a,|
所以每根木头都有一个，|

1530
00:47:44,810 --> 00:47:46,940
0,480 750,1110 1110,1470 1470,2040 2040,2130
so your log, basically you
所以你的日志，基本上你知道里面有记录，

1531
00:47:46,940 --> 00:47:48,170
0,150 150,360 360,720 720,870 870,1230
know {there,are} records in it,|
|

1532
00:47:48,500 --> 00:47:49,580
0,270 270,390 390,600 600,660 660,1080
{} they have a sequence
它们有一个序列号，

1533
00:47:49,580 --> 00:47:50,420
0,540
number,|
|

1534
00:47:51,060 --> 00:47:53,970
0,300 300,900 1470,1830 1830,2400 2430,2910
{you,know} whatever number two, one
你知道吗，2号，1号，2号

1535
00:47:53,970 --> 00:47:55,770
0,570 930,1350 1350,1470 1470,1590 1590,1800
two| and you know what
|你知道日志的结尾是什么，

1536
00:47:55,770 --> 00:47:56,460
0,120 120,210 210,300 300,390 390,690
the end of the log

1537
00:47:56,460 --> 00:47:57,870
0,270 270,630 630,840 840,1080 1080,1410
is,| if the next sequence
|如果下一个序列号现在更高，比您的高一个。

1538
00:47:57,870 --> 00:47:58,950
0,270 270,390 390,570 570,810 810,1080
number is now higher, one

1539
00:47:58,950 --> 00:48:00,620
0,420 420,810 900,1470
higher than yours.|
|

1540
00:48:01,220 --> 00:48:02,390
0,420 420,600 600,900 900,1050 1050,1170
So there's another way they
所以他们还有另一种标价的方法，

1541
00:48:02,390 --> 00:48:04,220
0,330 330,420 420,750 990,1680 1680,1830
mark it up,| basically in
|基本上在这些记录中的一个是更新数组，

1542
00:48:04,220 --> 00:48:06,680
0,210 210,300 300,750 990,1980 2160,2460
one of these records is

1543
00:48:06,680 --> 00:48:08,940
0,1080 1080,1200 1200,1830
array of updates,|
|

1544
00:48:12,930 --> 00:48:14,520
0,390 390,990 990,1080 1080,1320 1320,1590
now describe the file system
现在描述文件系统操作，

1545
00:48:14,520 --> 00:48:16,440
0,630 1020,1260 1260,1410 1410,1530 1530,1920
operation,| and so it contains
|因此它包含需要更新的块号，

1546
00:48:16,440 --> 00:48:17,600
0,90 90,390 390,870
the block number,

1547
00:48:18,120 --> 00:48:19,350
0,210 210,390 390,480 480,570 570,1230
that needs to be updated,|
|

1548
00:48:19,380 --> 00:48:20,460
0,210 210,570 570,660 660,810 810,1080
for example in our case,
例如，在我们的示例中，这通常是inode编号，

1549
00:48:20,460 --> 00:48:22,350
0,120 120,330 330,810 870,1380 1380,1890
that would usually be {

1550
00:48:22,740 --> 00:48:24,060
0,300 300,630 630,810 810,960 960,1320
-} the {inode -} number,|
|

1551
00:48:24,060 --> 00:48:25,110
0,90 90,330 330,510 510,900 900,1050
the block that contains the
包含信息节点的块，

1552
00:48:25,110 --> 00:48:26,190
0,90 90,480 480,840 840,990 990,1080
{inodes -},| that would be
|它将导航到一个版本号，

1553
00:48:26,190 --> 00:48:28,700
0,660 900,1200 1200,1500 1500,2010
navigated a version number,|
|

1554
00:48:29,010 --> 00:48:30,210
0,300 300,420 420,630 630,1020 1020,1200
because in that record, we've
因为在这一记录中，我们看到了第二个，为什么这很重要

1555
00:48:30,210 --> 00:48:31,740
0,210 210,720 930,1260 1260,1440 1440,1530
seen second, why that is

1556
00:48:31,740 --> 00:48:33,330
0,600 750,900 900,1230 1230,1350 1350,1590
important| and basically the new
|基本上是该块编号的新字节。

1557
00:48:33,330 --> 00:48:35,910
0,630 1530,1710 1710,1830 1830,2130 2130,2580
bytes for that block number.|
|

1558
00:48:37,840 --> 00:48:38,950
0,240 240,510 510,750 750,1050 1050,1110
And so, for example, in
例如，在创建文件的情况下，创建f，

1559
00:48:38,950 --> 00:48:40,150
0,60 60,300 300,390 390,930 930,1200
the case of creating {}

1560
00:48:40,150 --> 00:48:42,490
0,540 540,960 960,1410 2040,2190 2190,2340
file, creating f,| it's gonna
|这个数组中有两个条目，

1561
00:48:42,490 --> 00:48:43,960
0,300 300,510 510,1200
be {you,know} two

1562
00:48:44,190 --> 00:48:45,990
0,510 510,960 960,1050 1050,1200 1200,1800
{} entries in this array,|
|

1563
00:48:46,260 --> 00:48:47,700
0,420 420,1080
two entries,
两个条目，一个描述对索引节点块的更新，

1564
00:48:49,140 --> 00:48:51,540
0,360 360,1170 1260,1740 1740,2220 2220,2400
one describing the update to

1565
00:48:51,540 --> 00:48:53,730
0,180 180,480 480,990 990,1320 1320,2190
the inode block,| one describing
|一个描述对目录块、目录的数据块的新更新。

1566
00:48:53,910 --> 00:48:56,190
0,210 210,630 630,840 840,1380 1620,2280
new update to the directory

1567
00:48:56,190 --> 00:48:57,120
0,300 300,360 360,600 600,840 840,930
block, the data block of

1568
00:48:57,120 --> 00:48:58,000
0,90 90,600
the directory.|
|

1569
00:48:58,500 --> 00:48:59,620
0,1020

1570
00:49:05,140 --> 00:49:06,340
0,150 150,330 330,690 690,870 870,1200
And so basically what happens
因此，基本上复制过程中会发生什么，

1571
00:49:06,340 --> 00:49:07,690
0,180 180,810 810,990 990,1140 1140,1350
on replication,| just to like
|只是想把这一点说得非常清楚，

1572
00:49:07,690 --> 00:49:10,270
0,330 870,1020 1020,1500 1500,2190 2190,2580
make this abundantly clear,| when
|当对[]块的请求传入时

1573
00:49:10,270 --> 00:49:11,830
0,180 180,600 600,780 780,1290 1290,1560
{} request to [] block

1574
00:49:11,830 --> 00:49:13,450
0,210 210,600 900,1020 1020,1140 1140,1620
comes in| you know the
|你知道，发生的第一件事是将原木强行移到花瓣上，

1575
00:49:13,780 --> 00:49:15,190
0,510 510,630 630,780 780,1230 1230,1410
first thing that happens is

1576
00:49:15,190 --> 00:49:16,680
0,420 420,510 510,1080
force the log

1577
00:49:18,810 --> 00:49:20,360
0,390 390,960
to Petal,|
|

1578
00:49:20,750 --> 00:49:22,400
0,300 300,480 480,570 570,1050 1230,1650
once that is done,| send
一旦完成，|发送，更新已发送块，更新块发送给Petal，

1579
00:49:22,400 --> 00:49:23,750
0,270 330,930 930,1050 1050,1260 1260,1350
the, updates were sent the

1580
00:49:23,750 --> 00:49:25,400
0,660 750,900 900,1260 1260,1560 1560,1650
blocks, the updated blocks to

1581
00:49:25,400 --> 00:49:26,200
0,510
Petal,|
|

1582
00:49:34,660 --> 00:49:36,190
0,210 210,690 690,1020 1020,1110 1110,1530
and then release the lock.|
然后释放锁。|

1583
00:49:41,790 --> 00:49:43,440
0,330 330,480 480,960 960,1380 1440,1650
And this ensures that you
这可以确保你知道有几件事

1584
00:49:43,440 --> 00:49:44,400
0,90 90,330 330,570 570,810 810,960
know there's a couple things|
|

1585
00:49:44,400 --> 00:49:45,450
0,120 120,180 180,360 360,870 870,1050
that we need to think
我们需要考虑的是，

1586
00:49:45,450 --> 00:49:47,790
0,420 690,1770 1770,1830 1980,2190 2190,2340
about,| {} if if there's
|如果中间没有碰撞，

1587
00:49:47,790 --> 00:49:48,810
0,150 150,510 510,600 600,660 660,1020
no crashes in the middle,|
|

1588
00:49:48,810 --> 00:49:49,770
0,300 300,390 390,480 480,690 690,960
then you know this is
那么您就知道这总是如前所述

1589
00:49:49,770 --> 00:49:53,070
0,810 810,1170 1620,2040 2040,2670 2790,3300
always as previously described| really
|你真的知道一些有趣的案例，

1590
00:49:53,070 --> 00:49:54,750
0,60 60,210 210,570 570,1230 1230,1680
you know interesting cases,| when
|当在将日志强制为P之后立即发生崩溃时，

1591
00:49:54,750 --> 00:49:57,600
0,540 570,1080 1080,1740 1830,2550 2550,2850
a crash happens right after

1592
00:49:57,600 --> 00:49:58,920
0,330 330,420 420,690 690,780 780,1320
forcing the log to P,|
|

1593
00:49:59,040 --> 00:50:01,110
0,390 390,840 840,1320 1320,1680 1680,2070
{} but before updating Petal.|
但在更新花瓣之前。|

1594
00:50:02,550 --> 00:50:03,240
0,150 150,300 300,450 450,480 480,690
So let's talk a little
因此，让我们稍微谈谈这一点。

1595
00:50:03,240 --> 00:50:04,320
0,120 120,330 330,750
bit about that.|
|

1596
00:50:06,670 --> 00:50:07,540
0,390 390,540 540,630 630,690 690,870
Sorry, what do you mean
对不起，你说的新字节是什么意思？

1597
00:50:07,540 --> 00:50:09,120
0,270 270,630 630,1350
by new bytes?|
|

1598
00:50:09,730 --> 00:50:11,320
0,420 420,780 840,1020 1020,1170 1170,1590
{} Good, let me {}
很好，让我回去吧，

1599
00:50:13,070 --> 00:50:14,450
0,150 150,660 900,1110 1110,1260 1260,1380
go back,| so with another
|因此，通过另一种方式，更改信息节点块，

1600
00:50:14,450 --> 00:50:16,310
0,120 120,750 750,1200 1200,1560 1560,1860
{} mean, changes to {inode

1601
00:50:16,310 --> 00:50:17,960
0,240 240,810 810,1020 1020,1530 1530,1650
-} blocks,| {so,for} example the
|以inode块为例，

1602
00:50:17,960 --> 00:50:20,300
0,150 150,330 330,870 1200,2190 2190,2340
{inode -} block,| {} you
|你知道，也许你知道更新，

1603
00:50:20,300 --> 00:50:21,980
0,120 120,660 660,1230 1230,1590 1590,1680
know maybe {you,know} updating,| you
|您知道inode的某些部分，

1604
00:50:21,980 --> 00:50:22,940
0,210 210,600 600,780 780,870 870,960
know some part of the

1605
00:50:22,940 --> 00:50:23,840
0,120 120,330 330,510 510,630 630,900
{inode -},| then you {sort,of}
|然后你可以写下字节发生了变化，

1606
00:50:23,840 --> 00:50:27,050
0,300 300,2130 2160,2550 2550,2760 2760,3210
write down {the,bytes} have changed,|
|

1607
00:50:27,050 --> 00:50:29,090
0,450 750,1320 1320,1680 1680,1800 1800,2040
like bytes zero to five
类似于字节0到5和12的下列值，

1608
00:50:29,090 --> 00:50:30,410
0,120 120,540 540,630 630,900 900,1320
and twelve the following value,|
|

1609
00:50:30,740 --> 00:50:32,150
0,330 330,540 540,930 1020,1290 1290,1410
or {bytes -} ten to
或字节10到20具有以下新值。

1610
00:50:32,150 --> 00:50:33,410
0,510 510,810 810,900 900,1080 1080,1260
twenty have the following new

1611
00:50:33,410 --> 00:50:34,180
0,450
value.|
|

1612
00:50:36,200 --> 00:50:37,670
0,300 300,510 510,840 840,1290 1290,1470
But can those changes be
但这些变化会不会像，

1613
00:50:37,670 --> 00:50:38,840
0,420 480,720 720,870 870,1080 1080,1170
like,| because each one of
|因为这些块中的每一个最多为512字节，

1614
00:50:38,840 --> 00:50:40,160
0,300 300,780 780,930 930,1050 1050,1320
these blocks is at most

1615
00:50:40,160 --> 00:50:43,880
0,990 990,1350 1920,2670 2670,2820 2820,3720
512 bytes,| but the modifications
|但您所做的修改可能比512字节大得多，

1616
00:50:43,880 --> 00:50:44,510
0,120 120,240 240,420 420,510 510,630
that you make can be

1617
00:50:44,510 --> 00:50:47,030
0,300 300,570 570,1050 1050,1440 1650,2520
a lot larger than 512

1618
00:50:47,030 --> 00:50:48,650
0,720 810,1200 1200,1380 1380,1500 1500,1620
bytes,| {} there's gonna be
|每一个街区都会有记录。

1619
00:50:48,650 --> 00:50:50,330
0,90 90,360 360,480 480,900 900,1680
a record for every {}

1620
00:50:50,330 --> 00:50:50,960
0,450
block.|
|

1621
00:50:51,980 --> 00:50:52,970
0,360 360,480 480,750 750,900 900,990
So, in fact in the,
所以，事实上，好的，所以有几点，

1622
00:50:52,970 --> 00:50:54,320
0,270 270,420 420,630 630,870 870,1350
okay, so a couple points,|
|

1623
00:50:55,110 --> 00:50:56,780
0,570 600,840 840,930 930,1380
{} first of all,|
首先，|

1624
00:50:57,000 --> 00:50:59,220
0,570 840,1530 1530,1830 1830,2100 2100,2220
{} data writes actually are
数据写入实际上不会通过日志，

1625
00:50:59,220 --> 00:51:00,420
0,300 300,510 510,690 690,810 810,1200
not going through the log,|
|

1626
00:51:00,450 --> 00:51:01,470
0,120 120,420 420,480 480,810 810,1020
so there's an important point,|
所以有一点很重要，|

1627
00:51:01,470 --> 00:51:02,250
0,120 120,360 360,420 420,690 690,780
so thank you, thank you
所以谢谢你，谢谢你问这个问题，

1628
00:51:02,250 --> 00:51:03,690
0,120 120,390 390,510 510,900 1230,1440
for asking that question,| so
|所以当你写一个文件时，

1629
00:51:03,690 --> 00:51:04,920
0,330 330,450 450,600 600,690 690,1230
when you write a file,|
|

1630
00:51:05,190 --> 00:51:07,230
0,420 420,810 810,870 870,1410 1410,2040
{} in the application {calls,like}
在诸如写入文件F和一整串数据的应用调用中，

1631
00:51:07,230 --> 00:51:08,580
0,300 300,660 660,990 990,1200 1200,1350
write file f and a

1632
00:51:08,580 --> 00:51:10,020
0,150 150,330 330,420 420,870 1140,1440
whole bunch of data,| all
|所有这些数据实际上都不会通过日志，

1633
00:51:10,020 --> 00:51:11,340
0,240 240,480 480,720 720,900 900,1320
that data actually does not

1634
00:51:11,340 --> 00:51:12,460
0,180 180,390 390,480 480,930
go through the log,|
|

1635
00:51:12,670 --> 00:51:14,020
0,360 360,660 660,810 810,1020 1020,1350
{} that just goes straight
直接传给了花瓣，

1636
00:51:14,020 --> 00:51:15,250
0,90 90,540 570,840 840,1080 1080,1230
to Petal,| like once you
|就像一旦你冲走了这个州，

1637
00:51:15,250 --> 00:51:17,440
0,630 660,1290 1320,1860
flush the state,|
|

1638
00:51:17,680 --> 00:51:19,600
0,360 390,690 690,1260 1260,1800 1800,1920
{} the only changes that
通过日志的唯一更改是元更新更改，

1639
00:51:19,600 --> 00:51:20,590
0,150 150,360 360,450 450,870 870,990
go through the log are

1640
00:51:20,590 --> 00:51:23,230
0,360 360,1110 1200,1920 1950,2160 2160,2640
meta update changes,| so {metadata
|所以元数据会发生变化，

1641
00:51:23,260 --> 00:51:25,240
0,360 360,1050
-} changes,|
|

1642
00:51:26,100 --> 00:51:28,110
0,180 180,660 900,1530 1530,1860 1860,2010
and what metadata means is
元数据的真正含义是关于文件的信息，

1643
00:51:28,110 --> 00:51:30,160
0,330 330,780 780,1170 1170,1770
really information about files,|
|

1644
00:51:30,640 --> 00:51:32,440
0,480 480,690 690,900 900,1290 1380,1800
so {inodes -} {} {directories
所以索引节点目录，

1645
00:51:32,440 --> 00:51:33,700
0,480 510,720 720,870 870,930 930,1260
-},| that kind of stuff
|这类东西实际上会被记录在日志中。

1646
00:51:33,700 --> 00:51:35,020
0,210 210,450 450,660 660,780 780,1320
that actually goes through {the,log}.|
|

1647
00:51:35,660 --> 00:51:38,330
0,360 360,780 1020,1830 1950,2160 2160,2670
And so {} the description
所以你在这里看到的描述是

1648
00:51:38,330 --> 00:51:39,500
0,150 150,270 270,540 540,660 660,1170
that you see in here

1649
00:51:39,500 --> 00:51:40,460
0,120 120,570 570,630 630,780 780,960
is| really you know the
|实际上，您知道文件系统元数据块的更新，

1650
00:51:40,460 --> 00:51:42,260
0,480 480,600 600,750 750,1260 1260,1800
updates to the metadata blocks

1651
00:51:42,290 --> 00:51:43,970
0,210 210,300 300,570 570,990 1320,1680
of the file system,| so
|索引节点和目录数据也是如此。

1652
00:51:43,970 --> 00:51:46,280
0,180 180,780 960,1530 1530,1890 1890,2310
{inodes -} and directory data.|
|

1653
00:51:48,300 --> 00:51:50,460
0,480 480,780 810,1500 1500,1740 1740,2160
And the application level data
以及像实际构成文件的文件块一样的应用层数据，

1654
00:51:50,490 --> 00:51:52,020
0,660 660,780 780,1110 1110,1410 1410,1530
like the file blocks that

1655
00:51:52,020 --> 00:51:54,120
0,210 210,810 810,870 870,1380 1740,2100
actually constitute a file,| and
|实际上，这些数据块直接写入到Petal

1656
00:51:54,120 --> 00:51:55,650
0,330 330,690 690,1140 1140,1470 1470,1530
that actually those blocks are

1657
00:51:55,650 --> 00:51:56,910
0,180 180,390 390,840 840,930 930,1260
just written straight to Petal|
|

1658
00:51:56,910 --> 00:51:57,600
0,120 120,300 300,480 480,660 660,690
and they'll go for a
他们会去一个街区。

1659
00:51:57,600 --> 00:51:58,300
0,480
block.|
|

1660
00:51:59,620 --> 00:52:01,270
0,180 180,270 270,630 630,780 780,1650
So it's interesting to contemplate
因此，思考这一点的含义是很有趣的，

1661
00:52:01,270 --> 00:52:02,320
0,270 270,330 330,450 450,960 960,1050
what is the implications of

1662
00:52:02,320 --> 00:52:04,270
0,360 570,930 930,1080 1080,1440 1440,1950
that,| like that design choice,|
|就像那个设计选择，|

1663
00:52:07,130 --> 00:52:08,630
0,240 240,360 360,1080 1110,1230 1230,1500
what's the downside of not
不把每件事都记录下来有什么坏处？

1664
00:52:08,630 --> 00:52:10,200
0,210 210,570 570,720 720,1290
running everything through {the,log}?|
|

1665
00:52:12,330 --> 00:52:13,220
0,630
Assel.|
阿塞尔。|

1666
00:52:17,130 --> 00:52:18,420
0,300 300,690 690,780 780,930 930,1290
The updates to the data
对数据的更新可能会丢失。

1667
00:52:18,420 --> 00:52:20,120
0,150 150,360 360,450 450,1260
they can be lost.|
|

1668
00:52:20,840 --> 00:52:22,360
0,270 270,570 570,870 870,1200
{They,can} get lost, yeah,|
他们可能会迷路，是的，|

1669
00:52:23,010 --> 00:52:24,360
0,210 210,420 420,600 600,840 870,1350
what other sort of scenarios
还有哪些其他类型的场景是可能的，

1670
00:52:24,360 --> 00:52:25,440
0,90 90,510 510,630 630,810 810,1080
are possible,| so let's say
|假设您知道文件由10个数据块组成，

1671
00:52:25,440 --> 00:52:27,030
0,120 120,300 300,960 990,1290 1290,1590
you know the file consists

1672
00:52:27,030 --> 00:52:29,130
0,90 90,300 300,900 1260,1950 1950,2100
of 10 blocks,| {} we're
|我们开始写10个区块，

1673
00:52:29,130 --> 00:52:30,780
0,510 510,840 870,1080 1080,1560 1560,1650
{start,writing} the 10 blocks,| you
|你知道哪些州有什么可以提交的最终结果是什么。

1674
00:52:30,780 --> 00:52:32,430
0,180 180,630 630,870 870,1350 1350,1650
know what's in what states

1675
00:52:32,430 --> 00:52:33,690
0,210 210,570 570,810 810,960 960,1260
can file actually end up.|
|

1676
00:52:36,910 --> 00:52:39,490
0,420 420,1380 1740,2160 2160,2400 2400,2580
Being consistent.| Yeah, well yeah
始终如一。|是的，嗯，是的，一致性可能有一些笔迹，

1677
00:52:39,490 --> 00:52:40,570
0,480 480,600 600,810 810,990 990,1080
consistent could have some of

1678
00:52:40,570 --> 00:52:41,440
0,90 90,480 480,660 660,780 780,870
the writes,| none of the
|没有一个写的，所有的都是，

1679
00:52:41,440 --> 00:52:42,820
0,390 390,600 600,750 750,1110 1110,1380
writes, all of them,| who
|谁知道是什么，对吧。

1680
00:52:42,820 --> 00:52:44,120
0,270 270,600 600,1020
knows what, right.|
|

1681
00:52:44,680 --> 00:52:45,730
0,180 180,300 300,510 510,900 900,1050
But does not guarantee that
但并不能保证所有10条规则都会同时适用。

1682
00:52:45,730 --> 00:52:46,510
0,180 180,360 360,420 420,570 570,780
all 10 of them will

1683
00:52:46,510 --> 00:52:47,700
0,90 90,420 420,900
be applied together.|
|

1684
00:52:48,470 --> 00:52:50,120
0,360 390,570 570,870 900,1410 1470,1650
{} This is, so this
这是，所以这是很重要的

1685
00:52:50,120 --> 00:52:51,290
0,120 120,630 630,810 810,930 930,1170
is important| when you have
|当你有像这样的需要原子写的时候。

1686
00:52:51,290 --> 00:52:53,200
0,510 780,990 990,1230 1230,1560
like like this like

1687
00:52:53,370 --> 00:52:56,540
0,420 420,540 540,1320 1350,2190
need for atomic write.|
|

1688
00:52:56,980 --> 00:52:58,000
0,690

1689
00:52:58,350 --> 00:53:00,060
0,510 690,990 990,1320 1320,1470 1470,1710
Yeah, like if you didn't
是啊，如果你不需要原子性，

1690
00:53:00,060 --> 00:53:02,910
0,270 300,1620 1620,2040 2220,2580 2580,2850
need {atomicity -},| {} with
|有了这个，我们能不能去掉那些原木。

1691
00:53:02,910 --> 00:53:04,980
0,300 300,810 900,1110 1110,1470 1770,2070
this, like could we get

1692
00:53:04,980 --> 00:53:05,820
0,180 180,330 330,570 570,720 720,840
rid of that of the

1693
00:53:05,820 --> 00:53:06,620
0,540
log.|
|

1694
00:53:07,500 --> 00:53:09,810
0,660 660,1260 1320,1470 1470,1710 1890,2310
{} The I think so,|
我想是的，|

1695
00:53:09,810 --> 00:53:11,040
0,120 120,540 540,600 600,930 930,1230
holds on the question {a,second},|
抓住这个问题不放，|

1696
00:53:11,040 --> 00:53:11,760
0,150 150,360 360,510 510,630 630,720
let's first talk about the
让我们首先来谈谈应用程序

1697
00:53:11,760 --> 00:53:13,380
0,600 600,900 900,1410 1410,1530 1530,1620
applications| and then we'll come
|然后我们再回到那个问题上。

1698
00:53:13,380 --> 00:53:16,720
0,510 900,1650 1800,2400 2430,3060
back {to,that}.| So, {}
|所以，好的，那个。

1699
00:53:16,830 --> 00:53:20,420
0,540 660,1260 1470,2250 2550,3270
okay, {} the {}.|
|

1700
00:53:21,480 --> 00:53:23,260
0,720

1701
00:53:23,460 --> 00:53:25,140
0,330 360,510 510,1080 1080,1410 1410,1680
So the applications can't really
因此，应用程序不能真正将它们的数据原子地写入日志，

1702
00:53:25,140 --> 00:53:26,280
0,450 450,540 540,660 660,840 840,1140
write you know their data

1703
00:53:26,280 --> 00:53:27,930
0,600 630,930 930,1170 1170,1410 1410,1650
atomically {} {to,the} log,| because
|因为现在已为日志写入数据

1704
00:53:27,930 --> 00:53:28,950
0,300 300,510 510,600 600,780 780,1020
the data is now written

1705
00:53:28,950 --> 00:53:31,050
0,270 270,1110 1110,1650 1680,1920 1920,2100
for log| and so now
|所以现在写入日志，然后应用，

1706
00:53:31,050 --> 00:53:31,890
0,210 210,360 360,630 630,720 720,840
written to log and then

1707
00:53:31,890 --> 00:53:33,900
0,360 390,810 1350,1530 1530,1680 1680,2010
apply,| so so that means
|因此，这意味着，例如，如果您希望某个应用程序原子性地将您写入特定文件，

1708
00:53:33,900 --> 00:53:34,980
0,180 180,240 240,570 570,990 990,1080
that for example if an

1709
00:53:34,980 --> 00:53:36,000
0,480 480,600 600,840 840,960 960,1020
application you want {atomicity -

1710
00:53:36,000 --> 00:53:37,440
0,360 360,600 600,1230
-} of {}

1711
00:53:37,640 --> 00:53:39,410
0,270 270,420 420,1050 1110,1410 1410,1770
of your writes into particular

1712
00:53:39,410 --> 00:53:40,280
0,390 390,540 540,660 660,810 810,870
file,| then you have to
|那你就得自己安排了

1713
00:53:40,280 --> 00:53:42,230
0,330 330,510 510,780 810,1410 1830,1950
arrange that for yourself| and
|事实证明，大多数Unix文件都是这种情况，

1714
00:53:42,230 --> 00:53:42,980
0,150 150,390 390,600 600,690 690,750
this actually turns out to

1715
00:53:42,980 --> 00:53:43,760
0,120 120,180 180,450 450,540 540,780
be the case on most

1716
00:53:43,760 --> 00:53:45,920
0,240 240,660 660,780 780,1350 1740,2160
Unix files in anyway,| so
|所以从Frangipani的角度来看，

1717
00:53:45,920 --> 00:53:47,060
0,150 150,360 360,600 600,810 810,1140
in that way from Frangipani,|
|

1718
00:53:47,060 --> 00:53:48,140
0,90 90,330 330,540 540,990 990,1080
it doesn't really change the
这并不能真正改变游戏规则，

1719
00:53:48,140 --> 00:53:50,570
0,510 840,1560 1830,2040 2040,2250 2250,2430
game,| you know you write
|你知道你在Unix文件系统中写了一个文件，

1720
00:53:50,570 --> 00:53:51,350
0,60 60,390 390,450 450,510 510,780
a file in the Unix

1721
00:53:51,350 --> 00:53:53,120
0,270 270,810 990,1440 1440,1530 1530,1770
file system,| {} you write
|你写得就像一个虚拟机映像，

1722
00:53:53,120 --> 00:53:54,680
0,150 150,570 600,960 960,1350 1350,1560
like a VM image,| it's
|这不能保证整个图像在一次拍摄中就能一致地写出来，

1723
00:53:54,680 --> 00:53:56,510
0,240 240,1020 1020,1230 1230,1320 1320,1830
not guaranteed like the whole

1724
00:53:56,540 --> 00:53:58,130
0,510 510,600 600,930 930,1530 1530,1590
image is written consistently in

1725
00:53:58,130 --> 00:53:59,300
0,270 270,570 570,990 990,1080 1080,1170
one single shot,| you know
|您知道，对于文件系统，

1726
00:53:59,300 --> 00:54:01,400
0,180 180,510 510,780 780,1170 1530,2100
to the file system, {}|
|

1727
00:54:01,610 --> 00:54:03,050
0,330 330,570 570,720 720,810 810,1440
even when they're a crash.|
即使是在他们坠毁的时候。|

1728
00:54:03,470 --> 00:54:04,550
0,180 180,270 270,630 630,960 960,1080
So the typical way you
所以你知道人们在应用程序中解决这个问题的典型方式是，

1729
00:54:04,550 --> 00:54:06,590
0,510 570,1110 1110,1440 1440,1560 1560,2040
know people solve this problem

1730
00:54:06,590 --> 00:54:08,510
0,510 510,720 720,1440 1440,1620 1620,1920
{} in applications is that,|
|

1731
00:54:08,750 --> 00:54:09,740
0,150 150,390 390,540 540,600 600,990
it first write a temporary
它首先写入一个临时文件，

1732
00:54:09,740 --> 00:54:10,880
0,480 510,720 720,1020 1020,1110 1110,1140
file,| write everything in a
|将所有内容写入临时文件

1733
00:54:10,880 --> 00:54:12,200
0,360 360,870 930,1080 1080,1200 1200,1320
temporary file| and then do
|然后对目标文件执行原子重命名。

1734
00:54:12,200 --> 00:54:14,030
0,90 90,510 510,990 1380,1710 1710,1830
an atomic rename into the

1735
00:54:14,030 --> 00:54:15,240
0,510 510,870
destination file.|
|

1736
00:54:15,720 --> 00:54:17,370
0,360 360,660 660,900 900,1290 1290,1650
So {Frangipani -} basically relies
因此，Frangipani基本上完全依赖于相同的设置，

1737
00:54:17,370 --> 00:54:20,550
0,600 600,690 690,780 780,1470 1740,3180
exactly on the same {}

1738
00:54:20,580 --> 00:54:21,840
0,330 330,600 630,1020 1020,1200 1200,1260
set up,| {} sort of
|一种普通的Unix就可以了，

1739
00:54:21,840 --> 00:54:23,760
0,450 450,780 780,960 960,1230 1440,1920
normal Unix would do,| like
|就像弗拉吉帕尼不会改变游戏规则

1740
00:54:23,760 --> 00:54:24,660
0,210 210,450 450,690 690,840 840,900
{Frangipani -} doesn't change the

1741
00:54:24,660 --> 00:54:25,800
0,270 270,360 360,450 450,540 540,1140
game| and this is why
|这就是为什么文件写入实际上不会通过日志记录的原因。

1742
00:54:26,220 --> 00:54:28,890
0,60 60,60 1020,1770 1770,1950 1950,2670
as a writes of files

1743
00:54:28,920 --> 00:54:30,690
0,180 180,390 390,660 660,1410 1470,1770
are actually not logged through

1744
00:54:30,690 --> 00:54:31,500
0,120 120,600
the log.|
|

1745
00:54:31,960 --> 00:54:32,890
0,150 150,390 390,480 480,570 570,930
And what is the advantage
不伐木有什么好处，

1746
00:54:32,890 --> 00:54:33,940
0,90 90,270 270,660 660,810 810,1050
of not logging,| so clearly
|所以很明显这也有不利的一面，对吧，

1747
00:54:33,940 --> 00:54:35,560
0,240 240,300 300,870 900,1170 1170,1620
there's a downside, right,| because
|因为您不能使用日志自动执行文件写入，

1748
00:54:35,950 --> 00:54:37,000
0,150 150,390 390,660 660,780 780,1050
you can't do a file

1749
00:54:37,000 --> 00:54:38,050
0,180 180,540 540,690 690,960 960,1050
writes {atomically -} using the

1750
00:54:38,050 --> 00:54:39,010
0,390 390,510 510,630 630,780 780,960
log,| you have to have
|你必须有自己的原子性计划，

1751
00:54:39,010 --> 00:54:40,600
0,180 180,390 390,810 810,1260 1290,1590
your own plan for {atomicity

1752
00:54:40,600 --> 00:54:42,700
0,240 240,720 960,1320 1320,1440 1440,2100
-},| and {what,is} the advantage?|
|它的优势是什么？|

1753
00:54:45,780 --> 00:54:48,210
0,510 960,1440 1440,1920 1950,2340 2340,2430
Well, performance, because metadata is
性能，因为与实际用户数据相比，元数据非常小。

1754
00:54:48,210 --> 00:54:49,080
0,180 180,450 450,690 690,750 750,870
very small compared to the

1755
00:54:49,080 --> 00:54:51,240
0,600 630,960 960,1320 1530,1920 1920,2160
actual user data.| Yeah.| And
|嗯。|记忆也是如此。

1756
00:54:51,240 --> 00:54:53,670
0,510 720,1230 1410,1530 1530,1830 2040,2430
also memory, as well.| Yeah,
|是的，就是这样，

1757
00:54:53,670 --> 00:54:55,800
0,390 390,570 570,750 750,1590 1770,2130
exactly,| so do the like
|所以，如果你写一个巨大的文件，就会这样做，对吗，

1758
00:54:55,800 --> 00:54:57,420
0,390 390,540 540,780 780,1110 1110,1620
if you write a gigantic

1759
00:54:57,420 --> 00:54:59,400
0,390 390,810 1020,1260 1260,1680 1680,1980
file, correct,| saying gigabyte file,|
|说的是千兆字节文件，|

1760
00:54:59,400 --> 00:55:00,120
0,150 150,330 330,540 540,600 600,720
that really means you have
这实际上意味着你必须写入2千兆字节，

1761
00:55:00,120 --> 00:55:01,770
0,90 90,270 270,390 390,870 1230,1650
to write two gigabytes,| first
|首先，将千兆字节写入日志

1762
00:55:01,770 --> 00:55:03,000
0,150 150,390 390,810 810,1140 1140,1230
you're write gigabyte to the

1763
00:55:03,000 --> 00:55:03,750
0,300 300,390 390,570 570,720 720,750
log| and then write {}
|然后将你知道的千兆字节写入磁盘

1764
00:55:03,750 --> 00:55:04,770
0,450 450,510 510,690 690,870 870,1020
gigabyte you know to the

1765
00:55:04,770 --> 00:55:06,150
0,420 780,900 900,960 960,1230 1230,1380
disk| and so basically this
|因此，这基本上会极大地降低他们的表现

1766
00:55:06,150 --> 00:55:07,860
0,330 330,570 570,1020 1020,1290 1290,1710
cuts their performance in a

1767
00:55:07,890 --> 00:55:09,930
0,390 390,1020 1500,1710 1710,1830 1830,2040
pretty dramatically| and so which
|这就是为什么您知道通常不会将用户数据写入日志。

1768
00:55:09,930 --> 00:55:10,890
0,60 60,390 390,540 540,660 660,960
is why {} you know

1769
00:55:10,920 --> 00:55:12,990
0,720 720,810 810,1080 1080,1890 1920,2070
typically the user data is

1770
00:55:12,990 --> 00:55:14,040
0,240 240,420 420,540 540,990
not written for log.|
|

1771
00:55:15,500 --> 00:55:17,060
0,450 600,870 870,990 990,1200 1200,1560
{} Yeah, it's very important
是的，这是回到前面这个问题的非常重要的部分，

1772
00:55:17,060 --> 00:55:18,020
0,330 330,420 420,630 630,870 870,960
portion of come back to

1773
00:55:18,020 --> 00:55:19,040
0,120 120,420 420,750 750,840 840,1020
this earlier question,| is very
|内部文件系统结构保持一致是非常重要的，

1774
00:55:19,040 --> 00:55:20,690
0,330 330,480 480,690 840,1380 1380,1650
important that the internal file

1775
00:55:20,690 --> 00:55:23,000
0,270 270,960 990,1530 1560,1800 1800,2310
system structures are kept consistent,|
|

1776
00:55:23,000 --> 00:55:25,070
0,180 180,480 480,930 930,1650 1650,2070
where you're not you're not
在你不在的地方，你并不矛盾

1777
00:55:25,070 --> 00:55:28,580
0,570 960,1830 2070,2340 2340,2790 2850,3510
{} inconsistent| and so {}
|因此，元数据更新都会通过日志，

1778
00:55:28,610 --> 00:55:30,770
0,660 660,930 930,1410 1410,1800 1800,2160
therefore, the metadata updates all

1779
00:55:30,770 --> 00:55:32,780
0,150 150,330 330,900 1290,1560 1560,2010
go through {the,log},| so basically
|所以基本上你知道，当你创建文件时，

1780
00:55:32,780 --> 00:55:33,350
0,90 90,240 240,360 360,480 480,570
you know like when you

1781
00:55:33,350 --> 00:55:34,190
0,180 180,240 240,630 630,690 690,840
create the file,| you need
|您需要更新inode块

1782
00:55:34,190 --> 00:55:35,180
0,60 60,300 300,390 390,630 630,990
to update the inode block|
|

1783
00:55:35,180 --> 00:55:35,960
0,120 120,210 210,360 360,450 450,780
and you need to update
并且您需要更新目录块，

1784
00:55:35,960 --> 00:55:37,940
0,60 60,390 390,720 750,1140 1200,1980
the directory block,| that's guaranteed
|这肯定会一起发生。

1785
00:55:37,940 --> 00:55:38,840
0,60 60,330 330,810
to happen together.|
|

1786
00:55:42,490 --> 00:55:44,470
0,330 330,630 630,810 810,1290 1320,1980
{} So would the data
因此，数据块日期是否会介于步骤2和步骤3之间。

1787
00:55:44,500 --> 00:55:46,390
0,480 480,870 870,1050 1050,1530 1530,1890
block date go between step

1788
00:55:46,390 --> 00:55:47,520
0,150 150,330 330,780
2 and 3.|
|

1789
00:55:48,300 --> 00:55:51,570
0,1380 1830,2220 2580,2910 2910,3150 3150,3270
Yeah, I think they just
是的，我想他们只是把他们送出去，

1790
00:55:51,570 --> 00:55:52,800
0,120 120,210 210,450 450,810 810,1230
send them out,| probably they
|可能它们可能在一个之后，它们可能并行发送数据块，作为第二步的一部分，并直接发送到Petal，

1791
00:55:52,800 --> 00:55:55,020
0,450 450,1170 1170,1800 1800,1950 1950,2220
probably after one they probably

1792
00:55:55,020 --> 00:55:56,340
0,300 300,480 480,720 720,1110 1110,1320
sent the data blocks in

1793
00:55:56,340 --> 00:55:57,960
0,600 600,990 990,1350
parallel to {

1794
00:55:58,170 --> 00:56:00,120
0,720 720,1200 1200,1530 1530,1740 1740,1950
- -} {as,part,of} step two

1795
00:56:00,120 --> 00:56:01,590
0,300 300,600 600,1020 1020,1230 1230,1470
and straight to {Petal -},|
|

1796
00:56:02,500 --> 00:56:03,920
0,390 390,660 660,1110
{to,the,file} system area.|
添加到文件系统区域。|

1797
00:56:13,770 --> 00:56:14,640
0,570
Okay?|
好吧?|

1798
00:56:15,620 --> 00:56:17,480
0,630 930,1140 1140,1350 1350,1800 1800,1860
So I I had a
所以我我有个问题，

1799
00:56:17,480 --> 00:56:19,460
0,510 540,720 720,1050 1080,1620
question,| I think, {}
|我想，我记不清木头有多大了，

1800
00:56:19,910 --> 00:56:21,290
0,120 120,210 210,570 570,1110 1110,1380
I don't remember exactly how

1801
00:56:21,290 --> 00:56:22,640
0,270 270,420 420,810 810,1200 1200,1350
big the log was,| but
|但我相信它可以跨越两个街区。

1802
00:56:22,640 --> 00:56:24,680
0,90 90,600 630,870 1080,1590 1590,2040
I believe it could span

1803
00:56:24,680 --> 00:56:26,100
0,210 210,390 390,1110
like two blocks.|
|

1804
00:56:26,810 --> 00:56:32,090
0,1170 1170,1680 1680,2100 2100,2640 4260,5280
{It,can,log} is multiple records, yeah.|
它可以记录多条记录，是的。|

1805
00:56:32,480 --> 00:56:34,760
0,720 720,960 960,1290 1590,2160 2160,2280
Yeah, that's right, up to
是的，没错，最高可达TB，

1806
00:56:34,760 --> 00:56:36,350
0,180 180,630 630,780 780,1200 1200,1590
to terabytes,| so what happens
|那么，如果我们，如果我们发送，

1807
00:56:36,350 --> 00:56:37,380
0,150 150,420 420,780
if we, {}

1808
00:56:38,060 --> 00:56:39,400
0,150 150,300 300,900
if we send,|
|

1809
00:56:39,940 --> 00:56:42,280
0,720 990,1200 1200,1560 1560,2070 2070,2340
like a lot like part
就像是木头的一部分，然后它就会崩溃，

1810
00:56:42,280 --> 00:56:43,030
0,90 90,150 150,480 480,600 600,750
of a log and then

1811
00:56:43,030 --> 00:56:44,740
0,90 90,720 720,1200 1200,1320 1320,1710
it crashes,| as you're sending
|当您发送日志时，

1812
00:56:44,740 --> 00:56:46,180
0,390 390,900 900,1020 1020,1260 1260,1440
log,| when we get like
|当我们和LIKE有问题的时候。

1813
00:56:46,180 --> 00:56:47,710
0,270 450,690 690,1020 1020,1200 1200,1530
{} an issue with like.|
|

1814
00:56:48,460 --> 00:56:51,730
0,150 150,300 300,360 360,930 960,3270
That's exactly what {I,want,to} {talk,about},
这正是我想说的，谢谢。

1815
00:56:51,790 --> 00:56:54,280
0,390 390,600 870,1500 1740,2190 2250,2490
thank you.| {} So there's
|所以可能会发生一系列正确的撞车事故，

1816
00:56:54,280 --> 00:56:55,060
0,60 60,240 240,300 300,660 660,780
a bunch of crashes that

1817
00:56:55,060 --> 00:56:56,500
0,120 120,450 450,780 780,990 990,1440
could happen right,| like so
|就像这样，如果我们坠毁了，

1818
00:56:56,740 --> 00:56:58,000
0,630 630,990
{} so,

1819
00:56:58,580 --> 00:56:59,870
0,150 150,240 240,570 570,960 960,1290
if we crash,| {} considered
|考虑了一大堆案子，

1820
00:56:59,870 --> 00:57:00,650
0,30 30,210 210,270 270,600 600,780
a bunch of cases,| like
|就像我们在写入日志之前运行崩溃一样。

1821
00:57:00,650 --> 00:57:01,970
0,90 90,270 270,360 360,690 690,1320
we run a crash before

1822
00:57:01,970 --> 00:57:03,200
0,300 300,390 390,510 510,930
writing to the log.|
|

1823
00:57:10,440 --> 00:57:11,340
0,60

1824
00:57:11,530 --> 00:57:12,940
0,210 210,450 450,570 570,720 720,1410
So what, in that case
那么，在这种情况下，结果会是什么呢？

1825
00:57:13,120 --> 00:57:14,420
0,300 300,450 450,990
what's the outcome?|
|

1826
00:57:18,910 --> 00:57:22,150
0,630 1020,1800 1800,2310 2340,2610 2610,3240
Hmm, it's lost.| Yeah, lost.|
嗯，丢了。|是啊，迷路了。|

1827
00:57:25,060 --> 00:57:27,490
0,540 540,1140 1530,2070 2070,2160 2160,2430
So, {} then we go
所以，然后我们来看这个场景，

1828
00:57:27,490 --> 00:57:29,110
0,120 120,180 180,840 840,1140 1140,1620
the {} scenario,| like we
|就像我们在写完锁之后崩溃一样，然后会发生什么呢？

1829
00:57:29,140 --> 00:57:30,760
0,420 420,840 840,1140 1140,1230 1230,1620
crash after writing the lock,

1830
00:57:39,550 --> 00:57:40,700
0,210 210,420 420,840
what happens then?|
|

1831
00:57:42,180 --> 00:57:43,950
0,120 120,390 390,720 720,1200 1200,1770
It's actually {a,slightly} complicated scenario.|
这实际上是一个稍微复杂的场景。|

1832
00:57:44,620 --> 00:57:46,420
0,330 330,630 630,930 930,1320 1320,1800
{} Is this after writing
这是在写完之后，像圆木写到花瓣上一样。

1833
00:57:46,420 --> 00:57:47,650
0,180 180,300 300,600 600,900 900,1230
like the log to a

1834
00:57:47,680 --> 00:57:49,800
0,600
Petal.|
|

1835
00:57:50,500 --> 00:57:52,450
0,300 300,420 420,960 1080,1500 1500,1950
Then the demon steps then.|
然后恶魔就会走出来。|

1836
00:57:52,540 --> 00:57:53,650
0,270 270,480 480,540 540,810 810,1110
Yes, then the deamon steps,|
是的，然后守护神走了一步，|

1837
00:57:53,650 --> 00:57:54,460
0,360 360,450 450,600 600,720 720,810
it's a little bit of
这是一个有点复杂的故事，对吧

1838
00:57:54,460 --> 00:57:56,260
0,60 60,510 510,870 900,1260 1260,1800
a complicated story, correct,| because
|因为你知道这一切是怎么发现的，实际发生了什么。

1839
00:57:56,620 --> 00:57:58,510
0,150 150,330 330,1260 1290,1740 1740,1890
you know how, how does

1840
00:57:58,510 --> 00:57:59,830
0,150 150,240 240,840 840,1050 1050,1320
this all discovered, what actually

1841
00:57:59,830 --> 00:58:00,540
0,540
happens.|
|

1842
00:58:01,480 --> 00:58:02,500
0,150 150,510 510,660 660,930 930,1020
So presumably what happens if
因此，假设如果其他人希望此文件上的锁正确，

1843
00:58:02,500 --> 00:58:03,760
0,270 270,600 600,840 840,930 930,1260
somebody else wants the lock

1844
00:58:03,760 --> 00:58:04,870
0,150 150,270 270,570 570,1050 1050,1110
{ - -} correct on

1845
00:58:04,870 --> 00:58:06,370
0,120 120,720 750,1140 1140,1260 1260,1500
this file,| that you know
|你知道崩溃的工作站能支撑得住。

1846
00:58:06,370 --> 00:58:08,560
0,420 420,630 660,1080 1080,1560 1560,2190
that the crashed workstation holds.|
|

1847
00:58:10,050 --> 00:58:11,100
0,420 420,540 540,600 600,870 870,1050
And you know here's where
你知道租约在这里很重要，

1848
00:58:11,100 --> 00:58:13,770
0,360 360,630 630,1170 1170,1770 2190,2670
leases coming important,| so every
|所以每把锁都有租约，

1849
00:58:13,770 --> 00:58:15,200
0,330 330,510 510,630 630,1170
lock has a lease,|
|

1850
00:58:15,400 --> 00:58:16,690
0,390 390,570 570,660 660,1050 1050,1290
and what the {lock,server} will
以及锁服务器将执行的操作，

1851
00:58:16,690 --> 00:58:18,520
0,510 660,1230 1230,1410 1410,1560 1560,1830
do,| {} it will not
|它不会授权给你锁服务器会问一号工作站，

1852
00:58:18,520 --> 00:58:20,800
0,600 630,990 1320,1740 1740,2100 2100,2280
grant you the {lock,server} will

1853
00:58:20,800 --> 00:58:22,240
0,420 420,540 540,990 990,1230 1230,1440
ask {} workstation one,| please
|请把你的锁还给我

1854
00:58:22,240 --> 00:58:24,220
0,180 180,690 690,1410 1440,1710 1710,1980
give me your lock f

1855
00:58:24,220 --> 00:58:26,200
0,450 780,1230 1230,1380 1380,1890 1890,1980
back,| {workstation -} one, it
|一号工作站，它没有反应，因为它崩溃了，

1856
00:58:26,200 --> 00:58:27,760
0,180 180,600 600,840 840,930 930,1560
doesn't respond, because it's crashed,|
|

1857
00:58:28,090 --> 00:58:31,210
0,810 810,1140 1140,1470 1470,2100 2280,3120
and {} what the {lock,server}
以及锁服务器所做的工作，

1858
00:58:31,210 --> 00:58:32,470
0,450 480,690 690,930 930,1140 1140,1260
does,| it waits until the
|它会一直等到锁的租约到期。

1859
00:58:32,470 --> 00:58:33,850
0,240 240,810 810,930 930,990 990,1380
lease expires on the lock.|
|

1860
00:58:36,800 --> 00:58:37,910
0,270 270,600 600,750 750,840 840,1110
And why does it wait
为什么要等到锁，租约到期。

1861
00:58:37,910 --> 00:58:39,170
0,210 210,270 270,660 660,960 960,1260
until the lock, the {lease,is}

1862
00:58:39,170 --> 00:58:40,160
0,660
expired.|
|

1863
00:58:44,180 --> 00:58:45,140
0,150 150,330 330,690 690,810 810,960
I I think I think
我我想我想在这种情况下，

1864
00:58:45,140 --> 00:58:46,970
0,120 120,360 360,810 810,1200 1350,1830
in this case,| the {}
|服务器，

1865
00:58:47,730 --> 00:58:49,640
0,960 1080,1590
the {}

1866
00:58:50,060 --> 00:58:52,340
0,960 1470,1980
server {},|
|

1867
00:58:52,570 --> 00:58:53,950
0,210 210,270 270,570 570,690 690,1380
yeah the server that crashed
是的，崩溃的服务器也知道，

1868
00:58:53,980 --> 00:58:55,480
0,270 270,570 570,1200
like also knows,|
|

1869
00:58:55,740 --> 00:58:57,600
0,480 510,690 690,1020 1020,1260 1500,1860
{} it didn't like renew
它不喜欢续签租约，

1870
00:58:57,600 --> 00:58:58,590
0,210 210,510 510,690 690,810 810,990
its lease,| so it can
|这样它就可以自己清理了。

1871
00:58:58,590 --> 00:59:00,090
0,240 240,450 450,570 570,1170 1170,1500
clean up by its own.|
|

1872
00:59:00,570 --> 00:59:03,690
0,300 300,660 660,2310 2310,2820 2820,3120
Yeah, {clean,up} {its,own,stuff},| {what's,the,fundamental} problem
是的，清理自己的东西，|这里的根本问题是什么，

1873
00:59:03,690 --> 00:59:04,590
0,180 180,330 330,450 450,690 690,900
here,| that we're actually trying
|我们实际上是在试图挑战，

1874
00:59:04,590 --> 00:59:05,820
0,60 60,390 390,630 630,780 780,1230
to challenge,| almost like the
|几乎就像我们在之前的课程中反复看到的场景一样，

1875
00:59:05,820 --> 00:59:07,440
0,630 630,810 810,990 990,1200 1200,1620
scenario that we've seen over

1876
00:59:07,440 --> 00:59:08,790
0,120 120,450 450,540 540,990 990,1350
and over in previous lecture

1877
00:59:08,790 --> 00:59:10,290
0,240 240,510 510,840 840,900 900,1500
stuff,| there's always a challenge.|
|挑战总是存在的。|

1878
00:59:11,070 --> 00:59:13,590
0,480 480,1170 1320,1530 1530,2010 2010,2520
The partition.| {} Partition, exactly,|
分区。|分区，准确地说，|

1879
00:59:15,060 --> 00:59:17,280
0,450 450,540 540,600 600,1260 1680,2220
could be the case that
可能是这样的，你知道实际上一号工作站并没有崩溃，

1880
00:59:17,280 --> 00:59:18,930
0,150 150,600 660,1080 1080,1530 1530,1650
you know actually workstation one

1881
00:59:18,930 --> 00:59:20,670
0,150 150,390 390,990 1350,1650 1650,1740
did not crash,| but the
|但锁服务器无法与工作站通信，

1882
00:59:20,670 --> 00:59:23,100
0,510 510,810 810,1500 1500,1740 1740,2430
{lock,server} can't talk to the

1883
00:59:23,220 --> 00:59:24,600
0,750 750,960 960,1020 1020,1080 1080,1380
workstation,| because of the network
|由于网络分区，

1884
00:59:24,600 --> 00:59:25,860
0,450 660,840 840,930 930,1170 1170,1260
partition,| but the log in
|但是工作站里的日志你可以和Petal谈谈，

1885
00:59:25,860 --> 00:59:26,490
0,90 90,360 360,480 480,540 540,630
the {workstation -}  you can

1886
00:59:26,490 --> 00:59:27,440
0,210 210,300 300,750
talk to Petal,|
|

1887
00:59:28,100 --> 00:59:29,120
0,240 240,360 360,510 510,810 810,1020
and so it might still
所以它可能还是会做出改变，对吧，

1888
00:59:29,120 --> 00:59:31,880
0,720 720,1140 1140,1680 1710,2160 2340,2760
may make changes, right,| but
|但正如你刚才所说，无论我们保证什么，

1889
00:59:31,880 --> 00:59:33,140
0,330 330,420 420,960 960,1080 1080,1260
whatever we guaranteed as you

1890
00:59:33,140 --> 00:59:34,280
0,180 180,450 450,810 810,1080 1080,1140
just pointed out,| once the
|一旦租约到期，一号工作站肯定不会做任何更改。

1891
00:59:34,280 --> 00:59:36,440
0,210 210,780 780,1200 1200,1560 1560,2160
lease expires, {workstation,one} will definitely

1892
00:59:36,440 --> 00:59:37,840
0,240 240,420 420,600 600,1230
not make any changes.|
|

1893
00:59:38,830 --> 00:59:39,880
0,360 360,450 450,540 540,750 750,1050
Okay, it is not allowed
好吧，这是不允许的，

1894
00:59:39,880 --> 00:59:41,290
0,120 360,660 660,750 750,1320 1320,1410
to,| follow the protocol is
|遵守协议，不允许再做任何更改。

1895
00:59:41,290 --> 00:59:42,070
0,180 180,390 390,450 450,600 600,780
not allowed to make any

1896
00:59:42,070 --> 00:59:43,100
0,300 300,720
changes anymore.|
|

1897
00:59:44,340 --> 00:59:45,750
0,240 240,360 360,540 540,750 750,1410
And so this is {}
因此，这就是为什么锁服务器要等到租约到期，

1898
00:59:45,750 --> 00:59:47,490
0,210 210,300 300,690 690,1200 1200,1740
why the {lock,server} waits until

1899
00:59:47,490 --> 00:59:48,660
0,90 90,300 300,930 930,1110 1110,1170
the lease expires,| then at
|然后在这一点上，并肯定地知道，没有人再持有锁

1900
00:59:48,660 --> 00:59:49,500
0,180 180,450 450,540 540,750 750,840
that point and knows for

1901
00:59:49,500 --> 00:59:51,030
0,450 450,630 630,1080 1080,1470 1470,1530
sure that nobody holds a

1902
00:59:51,030 --> 00:59:52,860
0,240 240,840 1170,1380 1380,1650 1650,1830
lock anymore| or couldn't hold
|或者如果再也没有人给花瓣写信，就拿不住锁

1903
00:59:52,860 --> 00:59:53,970
0,60 60,300 300,390 390,750 750,1110
the lock if nobody's writing

1904
00:59:53,970 --> 00:59:55,380
0,90 90,360 360,990 1170,1290 1290,1410
to Petal anymore| and so
|因此，在这一点上，它将要求剩余的一个工作站，

1905
00:59:55,380 --> 00:59:56,700
0,60 60,210 210,630 630,930 930,1320
at this point, it will

1906
00:59:56,700 --> 00:59:58,260
0,390 390,570 570,720 720,990 1020,1560
ask one of the remaining

1907
00:59:58,260 --> 01:00:00,690
0,690 690,1140 1350,1920 1920,2280 2280,2430
workstations to,| {} basically what
|基本上就是他们所说的恶魔，恢复恶魔，

1908
01:00:00,690 --> 01:00:02,440
0,120 120,390 390,930 930,1530
they call the demon,

1909
01:00:06,020 --> 01:00:09,830
0,630 630,1110 1920,2910 2910,3300 3300,3810
recovery demon,| the recovery demon,
|恢复魔头，和恢复魔头基本都会应用，在工作站上读取日志每一条日志

1910
01:00:10,720 --> 01:00:12,250
0,150 150,210 210,600 600,870 870,1530
and the recovery demon basically

1911
01:00:12,340 --> 01:00:14,680
0,300 300,1110 1140,1710 1710,1920 1920,2340
will apply, {} will read

1912
01:00:14,680 --> 01:00:16,210
0,300 300,420 420,870 870,990 990,1530
the the log the workstation

1913
01:00:16,210 --> 01:00:18,520
0,480 930,1260 1260,1710 1740,1950 1950,2310
one each log| and basically
|并基本上应用该日志中的操作。

1914
01:00:18,520 --> 01:00:19,810
0,300 300,390 390,960 960,1110 1110,1290
apply the operations that are

1915
01:00:19,810 --> 01:00:20,700
0,60 60,240 240,660
in that log.|
|

1916
01:00:22,200 --> 01:00:23,080
0,600
Okay?|
好吧?|

1917
01:00:25,110 --> 01:00:27,090
0,420 420,600 600,750 750,1050 1320,1980
{} You know the way
你知道思考恶魔的方式，

1918
01:00:27,090 --> 01:00:28,080
0,90 90,210 210,390 390,480 480,990
to think about the demon,|
|

1919
01:00:28,230 --> 01:00:29,460
0,450 450,660 660,990 990,1050 1050,1230
{} it's sort of like,
这有点像，这是术语，

1920
01:00:29,460 --> 01:00:31,680
0,450 480,690 690,900 930,1830 1830,2220
{} this is terminology,| it's
|它通常只是一项服务或服务器或服务器进程，

1921
01:00:31,680 --> 01:00:33,240
0,360 360,570 570,600 600,1290 1320,1560
typically just a service or

1922
01:00:33,240 --> 01:00:35,070
0,30 30,780 930,1290 1290,1470 1470,1830
a server {} or server

1923
01:00:35,070 --> 01:00:36,900
0,750 840,1140 1140,1320 1320,1650 1650,1830
process,| {} that basically does
|基本上做的是打扫房子或打扫房子的任务

1924
01:00:36,900 --> 01:00:39,240
0,180 180,300 300,1320 1320,1440 1440,2340
sort of {house,cleaning} or house

1925
01:00:39,270 --> 01:00:41,130
0,420 420,1020 1020,1230 1230,1710 1710,1860
cleaning tasks| and those kind
|以及那些不是真正持续使用的服务，

1926
01:00:41,130 --> 01:00:42,420
0,60 60,570 570,720 720,930 930,1290
of services that are not

1927
01:00:42,420 --> 01:00:45,030
0,210 210,630 630,960 1050,1980 2190,2610
really used {} continuously,| they're
|他们通常被称为恶魔。

1928
01:00:45,030 --> 01:00:46,140
0,390 390,1020
{often,called} demons.|
|

1929
01:00:48,950 --> 01:00:49,850
0,210 210,450 450,510 510,780 780,900
So once the demon is
所以一旦恶魔被杀了，

1930
01:00:49,850 --> 01:00:51,530
0,390 420,720 720,1050 1050,1560 1590,1680
done,| then actually {the,lock} you
|那么实际上你知道的锁可以是，

1931
01:00:51,530 --> 01:00:53,090
0,120 120,300 300,870 1050,1350 1350,1560
know can be,| lock server
|锁服务器可以对锁进行退锁，

1932
01:00:53,090 --> 01:00:55,070
0,210 210,780 780,1560 1560,1770 1770,1980
can resign {the,lock},| or grant
|或将锁授权给某人到另一台工作站。

1933
01:00:55,070 --> 01:00:56,210
0,90 90,360 360,810 810,900 900,1140
the {lock,to} somebody to another

1934
01:00:56,210 --> 01:00:57,100
0,570
workstation.|
|

1935
01:00:58,820 --> 01:00:59,540
0,150 150,330 330,450 450,540 540,720
{} But just to double
但为了再检查一遍，

1936
01:00:59,540 --> 01:01:01,400
0,210 210,540 540,540 1080,1410 1710,1860
check,| so, { -} if
|因此，如果您在写入日志后崩溃，

1937
01:01:01,400 --> 01:01:02,720
0,120 120,330 330,750 870,1230 1230,1320
you crash after writing the

1938
01:01:02,720 --> 01:01:03,860
0,270 270,390 390,540 540,750 750,1140
log,| then you'll get you're
|然后你会得到一个一致的状态，

1939
01:01:03,860 --> 01:01:04,700
0,120 120,180 180,330 330,390 390,840
going to have a consistent

1940
01:01:04,700 --> 01:01:05,540
0,240 240,330 330,420 420,630 630,840
state,| when it comes to
|当涉及元数据时，

1941
01:01:05,600 --> 01:01:06,920
0,180 180,630 630,840 870,1050 1050,1320
the metadata,| but the user
|但不能保证用户已经完成了用户数据的写入。

1942
01:01:06,920 --> 01:01:07,790
0,120 120,300 300,630 630,720 720,870
is not guaranteed to have

1943
01:01:07,790 --> 01:01:09,230
0,360 420,840 840,930 930,1200 1200,1440
finished writing the user data.|
|

1944
01:01:09,860 --> 01:01:11,900
0,1200 1200,1560 1560,1740 1740,1830 1830,2040
{Yeah,absolutely,,no} guarantees about the user
是的，绝对不能保证用户数据。

1945
01:01:11,900 --> 01:01:12,440
0,300
data.|
|

1946
01:01:13,060 --> 01:01:14,620
0,210 210,420 420,750 750,960 960,1560
So the only thing the
所以唯一的保证就是

1947
01:01:14,620 --> 01:01:16,330
0,120 120,750 750,960 960,1380 1380,1710
the guarantees| that like really
|这就像真正的日志系统帮助实现的是

1948
01:01:16,330 --> 01:01:18,820
0,120 120,480 480,1380 1560,2010 2010,2490
the logging system helps achieving

1949
01:01:18,820 --> 01:01:20,200
0,180 180,510 510,1110 1110,1290 1290,1380
is| basically consistency of the
|内部文件系统数据结构基本一致。

1950
01:01:20,200 --> 01:01:22,300
0,630 630,930 930,1200 1200,1500 1500,2100
internal file system data structures.|
|

1951
01:01:23,830 --> 01:01:25,220
0,420 600,870 870,1080
Okay, sounds good.|
好的，听起来不错。|

1952
01:01:27,120 --> 01:01:28,350
0,270 270,330 330,720 720,1020 1020,1230
Which is important, correct,| because
这是重要的，正确的，|因为这将是相当糟糕的，如果文件内部文件系统数据结构混乱，

1953
01:01:28,350 --> 01:01:29,430
0,90 90,210 210,330 330,540 540,1080
it would be pretty bad,

1954
01:01:29,460 --> 01:01:30,660
0,270 270,600 600,780 780,1020 1020,1200
{if,file} internal file system data

1955
01:01:30,660 --> 01:01:31,940
0,360 360,420 420,690 690,990
structures are messed up,|
|

1956
01:01:32,110 --> 01:01:33,250
0,150 150,450 450,810 810,960 960,1140
you know, everybody might lose
你知道，每个人都可能会丢失他们的数据。

1957
01:01:33,250 --> 01:01:34,140
0,120 120,480
their data.|
|

1958
01:01:37,420 --> 01:01:39,520
0,330 330,840 870,1560 1590,1800 1800,2100
Okay, so then there's another
好的，然后还有另一个即时的案例，会发生什么，

1959
01:01:39,520 --> 01:01:40,580
0,300 300,840
instant case,

1960
01:01:40,900 --> 01:01:43,330
0,900 1350,1740 1740,1830 1830,2190 2190,2430
{} what can happen,| okay,
|好的，把日志写到P，

1961
01:01:43,330 --> 01:01:44,860
0,360 360,750 750,1020 1020,1080 1080,1530
so writing {the,log} to P,|
|

1962
01:01:44,890 --> 01:01:46,240
0,360 360,750 750,1110 1110,1230 1230,1350
{} what happens if we
如果我们在写入日志的过程中崩溃，会发生什么情况。

1963
01:01:46,240 --> 01:01:48,060
0,510 510,1170
crash during

1964
01:01:51,110 --> 01:01:52,740
0,420 420,540 540,960
writing the log.|
|

1965
01:02:05,250 --> 01:02:06,780
0,240 240,450 450,690 690,870 870,1530
Is this what you mentioned
这就是你之前提到的他们的校验和

1966
01:02:06,780 --> 01:02:08,760
0,450 450,780 780,1320 1320,1650 1650,1980
before that their {checksums -}|
|

1967
01:02:08,760 --> 01:02:09,750
0,150 150,270 270,450 450,690 690,990
and we can check whether
我们可以检查它是不是完整的。

1968
01:02:09,750 --> 01:02:10,770
0,120 120,360 360,480 480,930 930,1020
it was a complete or

1969
01:02:10,770 --> 01:02:15,270
0,420 480,2220 2250,2970 2970,3330 3360,4500
not.| Yeah, good point,| so
|是啊，说得好，|所以在这种情况下会发生什么，

1970
01:02:15,420 --> 01:02:16,620
0,300 300,570 570,660 660,810 810,1200
what happens in this case,|
|

1971
01:02:16,620 --> 01:02:18,090
0,360 360,540 540,630 630,1200 1200,1470
is that a prefix might
前缀可能会以，

1972
01:02:18,120 --> 01:02:19,760
0,180 180,480 510,750 750,1050
end up in the,|
|

1973
01:02:20,850 --> 01:02:21,990
0,120 120,570 570,780 780,930 930,1140
the prefix might end {up,in}
前缀可能会在日志中结束，对吧，

1974
01:02:21,990 --> 01:02:23,120
0,90 90,480 480,720
the log, right,|
|

1975
01:02:24,500 --> 01:02:26,480
0,540 900,1260 1260,1410 1410,1560 1560,1980
{} but each of the
但是每个前缀可能包含具有多个操作的多个日志记录，

1976
01:02:26,870 --> 01:02:29,480
0,600 600,780 780,1140 1140,1890 1890,2610
prefix might contain multiple {}

1977
01:02:29,540 --> 01:02:31,550
0,690 690,960 960,1080 1080,1410 1410,2010
log records with multiple operations,

1978
01:02:31,550 --> 01:02:32,870
0,420 420,510 510,660 660,990 990,1320
correct,| you know whatever sequence
|你知道，无论是序号1，序号2，还是多个记录，

1979
01:02:32,870 --> 01:02:34,280
0,210 210,600 600,780 780,990 990,1410
number one, sequence number two,

1980
01:02:34,280 --> 01:02:37,370
0,270 300,1080 1080,1620 2160,2790 2940,3090
the multiple records,| {} if
|如果我们在其中一个记录更新期间崩溃

1981
01:02:37,370 --> 01:02:38,720
0,210 210,630 630,930 930,1260 1260,1350
we crash during one of

1982
01:02:38,720 --> 01:02:40,280
0,420 420,780 780,1350 1350,1440 1440,1560
these records updates| you know
|你知道，这样校验和就不会结账了

1983
01:02:40,280 --> 01:02:42,050
0,480 480,480 480,1200 1200,1530 1530,1770
then {} the checksum won't

1984
01:02:42,050 --> 01:02:43,460
0,450 450,630 630,870 870,1020 1020,1410
checkout| and so will basically
|所以基本上就会停止，你知道，复苏的恶魔会在这个记录上停止。

1985
01:02:43,460 --> 01:02:45,110
0,480 510,600 600,1200 1200,1440 1440,1650
stop you know the the

1986
01:02:45,110 --> 01:02:46,220
0,330 330,600 600,690 690,1050 1050,1110
recovery demon will stop at

1987
01:02:46,220 --> 01:02:46,980
0,210 210,570
that record.|
|

1988
01:02:47,190 --> 01:02:48,420
0,210 210,450 450,660 660,930 930,1230
So what will be in
那么日志中会有什么呢，

1989
01:02:48,420 --> 01:02:49,740
0,120 120,480 480,630 630,930 930,1320
the log,| will be {
|将是操作的正确前缀，

1990
01:02:49,980 --> 01:02:51,990
0,390 390,780 780,1290 1290,1830 1860,2010
- -} correct prefix of

1991
01:02:51,990 --> 01:02:54,060
0,120 120,900 1080,1350 1350,1410 1410,2070
the operations,| so for example
|例如，您知道文件f的创建在其中，

1992
01:02:54,060 --> 01:02:55,320
0,60 60,240 240,480 480,1140 1140,1260
you know the create of

1993
01:02:55,320 --> 01:02:57,180
0,720 720,990 990,1200 1200,1320 1320,1860
file f is in there,|
|

1994
01:02:57,210 --> 01:02:58,650
0,270 270,360 360,660 660,1140 1140,1440
maybe to create file {g,is}
也许创建文件g就在那里，

1995
01:02:58,650 --> 01:03:00,210
0,180 180,660 690,990 990,1080 1080,1560
in there,| but the create
|但是创建文件H不在其中，

1996
01:03:00,210 --> 01:03:01,560
0,510 540,870 870,1020 1020,1260 1260,1350
file h is not in

1997
01:03:01,560 --> 01:03:02,040
0,270
there,|
|

1998
01:03:02,190 --> 01:03:03,900
0,270 270,480 480,600 600,1290 1290,1710
{} but each individual record
但描述一个原子文件系统操作的每个单独记录，

1999
01:03:03,930 --> 01:03:05,490
0,210 210,630 630,900 900,1440 1470,1560
that describes one atomic you

2000
01:03:05,490 --> 01:03:07,200
0,150 150,360 360,600 600,1350 1560,1710
know file system operation,| you
|你知道，它就在那里，而且是完整的。

2001
01:03:07,200 --> 01:03:08,400
0,90 90,630 630,750 750,1080 1080,1200
know is in there and

2002
01:03:08,400 --> 01:03:09,240
0,90 90,570
is complete.|
|

2003
01:03:09,910 --> 01:03:11,350
0,210 210,570 660,960 960,1110 1110,1440
And so what will happen
所以接下来会发生的是

2004
01:03:11,350 --> 01:03:12,460
0,120 120,240 240,660 660,810 810,1110
is| that basically we apply
|基本上，我们在工作站上应用前缀的操作正在执行

2005
01:03:12,460 --> 01:03:14,800
0,60 60,750 780,1080 1080,1710 1740,2340
the prefix of the operations

2006
01:03:14,800 --> 01:03:16,570
0,90 90,180 180,720 720,1080 1080,1770
at the workstation is {}

2007
01:03:16,600 --> 01:03:18,340
0,540 660,840 840,930 930,1290 1290,1740
doing| and we basically lose
|我们基本上丢掉了前缀的结尾

2008
01:03:18,340 --> 01:03:19,510
0,180 180,330 330,450 450,570 570,1170
the end of the prefix|
|

2009
01:03:19,870 --> 01:03:20,800
0,180 180,300 300,420 420,570 570,930
or the end of {}
或其更新的结束，

2010
01:03:20,800 --> 01:03:22,960
0,150 150,540 540,750 750,1140 1440,2160
its updates,| but {you,know} undesirable,
|但你知道不受欢迎，但我们完全没问题，

2011
01:03:22,960 --> 01:03:24,460
0,180 180,360 360,690 690,1050 1050,1500
but we're totally okay,| because,
|因为，你知道，在另一个案例中，

2012
01:03:24,950 --> 01:03:26,150
0,420 450,840 840,930 930,1020 1020,1200
you know in the other

2013
01:03:26,150 --> 01:03:27,200
0,240 240,360 360,510 510,630 630,1050
case,| we might have lost
|我们可能已经失去了所有的更新。

2014
01:03:27,200 --> 01:03:28,480
0,180 180,480 480,600 600,1050
{} all {updates -}.|
|

2015
01:03:31,210 --> 01:03:32,350
0,300 300,420 420,510 510,750 750,1140
But in the first case,|
但在第一种情况下，|

2016
01:03:32,920 --> 01:03:33,820
0,270 270,450 450,570 570,630 630,900
{} we were {} crashed
我们在第一次坠毁之前坠毁了，

2017
01:03:33,820 --> 01:03:34,690
0,300 300,360 360,630 630,720 720,870
before the one,| we would
|我们对此一无所知。

2018
01:03:34,690 --> 01:03:35,860
0,150 150,450 450,570 570,930
have nothing on this.|
|

2019
01:03:40,660 --> 01:03:42,180
0,120 120,300 300,420 420,750
Does that make sense?|
这说得通吗？|

2020
01:03:46,760 --> 01:03:49,640
0,390 390,720 720,1260 1440,2220 2550,2880
Okay, there's one, {} one
好的，还有一个，一个棘手的案子，

2021
01:03:49,640 --> 01:03:51,950
0,150 150,450 450,1020 1050,2070 2100,2310
more tricky case,| {} you
|你知道我们需要考虑

2022
01:03:51,950 --> 01:03:52,880
0,90 90,180 180,330 330,390 390,930
know we need to consider|
|

2023
01:03:53,210 --> 01:03:53,930
0,240 240,330 330,480 480,630 630,720
{} and that has to
这与这样一个事实有关，

2024
01:03:53,930 --> 01:03:54,860
0,120 120,330 330,390 390,720 720,930
do with the fact,| that
|实际上，Petal在每个服务器上都有一个锁，或者在每个服务器上有一个日志。

2025
01:03:54,860 --> 01:03:56,420
0,480 480,780 780,960 960,1050 1050,1560
actually Petal has a lock

2026
01:03:56,420 --> 01:03:58,190
0,120 120,600 600,810 810,1410 1590,1770
per server or log per

2027
01:03:58,190 --> 01:03:59,160
0,510
server.|
|

2028
01:03:59,570 --> 01:04:00,380
0,180 180,420 420,600 600,630 630,810
So I talked a little
所以我稍微谈了一下，

2029
01:04:00,380 --> 01:04:01,670
0,120 120,300 300,870 960,1170 1170,1290
bit about that,| and these
|这些都与你在阅读中所知道的帖子中的问题有关。

2030
01:04:01,670 --> 01:04:03,290
0,90 90,390 390,660 660,990 1020,1620
are related to the question

2031
01:04:03,500 --> 01:04:04,790
0,150 150,210 210,780 810,930 930,1290
in a post you know

2032
01:04:05,240 --> 01:04:06,440
0,270 270,360 360,900
for the reading.|
|

2033
01:04:06,760 --> 01:04:07,600
0,210 210,330 330,390 390,600 600,840
And this is about many
这是关于许多原木的

2034
01:04:07,600 --> 01:04:09,460
0,600 960,1410 1410,1560 1560,1710 1710,1860
logs| and so let's say
|因此，假设我们有工作站，

2035
01:04:09,460 --> 01:04:11,600
0,180 180,660 690,1920
we have workstations,|
|

2036
01:04:12,160 --> 01:04:13,330
0,180 180,330 330,480 480,570 570,1170
each with their own log.|
每个人都有自己的日志。|

2037
01:04:13,920 --> 01:04:15,720
0,180 180,420 420,870 870,1290 1290,1800
So here's workstation 1, workstation
这是工作站1，工作站2，工作站3。

2038
01:04:15,720 --> 01:04:18,380
0,600 960,1620 1620,2130
2, workstation 3.|
|

2039
01:04:19,480 --> 01:04:21,070
0,570 570,1020 1020,1320 1320,1440 1440,1590
And workstation 1, at some
而工作站1在某一时刻删除碰巧之前存在的文件F，

2040
01:04:21,070 --> 01:04:23,320
0,330 330,540 540,630 630,1410 2010,2250
point, does a delete of

2041
01:04:23,320 --> 01:04:24,490
0,360 360,600 600,780 780,1080 1080,1170
file f that happened to

2042
01:04:24,490 --> 01:04:26,180
0,660 660,1320
exist before,|
|

2043
01:04:27,480 --> 01:04:30,630
0,810 810,1560 1860,2400 2400,2940 2970,3150
then {} workstation 2 does
那么工作站2是否创建f的fd

2044
01:04:30,630 --> 01:04:32,120
0,120 120,810
it create

2045
01:04:33,270 --> 01:04:35,880
0,300 300,840 870,1110 1110,1980 2190,2610
{fd -} of f| and
|但这创造了，

2046
01:04:35,880 --> 01:04:37,020
0,120 120,300 300,660 660,1050 1050,1140
but that create,| remember has
|记得写了他自己的日志，

2047
01:04:37,020 --> 01:04:38,130
0,270 270,390 390,510 510,660 660,1110
written to his own log,|
|

2048
01:04:38,190 --> 01:04:41,160
0,960 960,1560 1860,2100 2100,2580 2580,2970
{so,this} delete is written to
因此该删除被写入到工作站1的日志中，

2049
01:04:41,160 --> 01:04:42,840
0,150 150,600 600,720 720,1230 1230,1680
the log of workstation 1,|
|

2050
01:04:43,020 --> 01:04:44,250
0,270 270,630 630,750 750,1050 1050,1230
this create is written to
该创建被写入到工作站2的日志中。

2051
01:04:44,250 --> 01:04:45,840
0,90 90,540 540,750 750,1260 1260,1590
the log of workstation 2.|
|

2052
01:04:46,990 --> 01:04:48,880
0,420 420,630 630,1230
Now, let's say,
现在，假设1号工作站崩溃了

2053
01:04:49,420 --> 01:04:51,100
0,270 270,600 600,720 720,930 930,1680
{} {workstation -} 1 crashes

2054
01:04:52,950 --> 01:04:55,920
0,750 780,1890 2040,2280 2280,2520 2520,2970
in| {} and then workstation
|然后工作站3，你知道，基本上你知道，恢复恶魔运行，

2055
01:04:55,920 --> 01:04:57,390
0,510 570,690 690,810 810,1380 1380,1470
3 you know basically you

2056
01:04:57,390 --> 01:04:59,100
0,210 210,390 390,810 810,1110 1110,1710
know the recovery demon runs,|
|

2057
01:05:07,600 --> 01:05:09,430
0,90 90,240 240,870 900,1530 1530,1830
you know for workstation 1,|
您知道，对于1号工作站，|

2058
01:05:14,700 --> 01:05:15,960
0,570 570,720 720,810 810,930 930,1260
and you know the bad
正确地说，你知道可能出现的坏结果，

2059
01:05:15,960 --> 01:05:17,730
0,420 420,870 870,1230 1230,1410 1410,1770
possible outcome, correctly,| that would
|这将删除、重播删除，

2060
01:05:17,730 --> 01:05:19,640
0,420 420,900 900,1020 1020,1620
delete, replay the delete,|
|

2061
01:05:19,960 --> 01:05:22,210
0,180 180,390 390,1170 1260,1590 1590,2250
which would overwrite the changes,|
这将覆盖更改，|

2062
01:05:22,210 --> 01:05:24,040
0,60 60,690 690,900 900,1230 1500,1830
{} that {workstation -} 2
给花瓣做的那个工作站2，对，

2063
01:05:24,040 --> 01:05:25,020
0,270 270,690
{make,to} Petal,

2064
01:05:26,180 --> 01:05:27,470
0,180 180,270 270,510 510,600 600,1290
right,| so that's the context|
|所以这就是背景|

2065
01:05:28,130 --> 01:05:29,180
0,450 450,540 540,810 810,900 900,1050
and the question is how
问题是这是如何解决的

2066
01:05:29,180 --> 01:05:30,710
0,240 240,780 810,1230 1230,1290 1290,1530
is {this,fixed}| and I think
|我认为这就是我想要解决的问题

2067
01:05:30,710 --> 01:05:31,760
0,390 390,690 720,900 900,960 960,1050
this the way I would

2068
01:05:31,760 --> 01:05:32,630
0,150 150,210 210,510 510,720 720,870
like to address this| is
|就是让你在休息室里待上几分钟，

2069
01:05:32,630 --> 01:05:34,190
0,180 180,780 780,960 960,1350 1350,1560
by actually having you spend

2070
01:05:34,190 --> 01:05:34,850
0,30 30,240 240,510 510,600 600,660
a couple minutes in the

2071
01:05:34,850 --> 01:05:36,620
0,390 390,840 1110,1440 1440,1620 1620,1770
breakout room,| debate this with
|彼此或花瓣的任何其他方面都在争论这一点，

2072
01:05:36,620 --> 01:05:37,640
0,120 120,480 480,660 660,810 810,1020
each other or any other

2073
01:05:37,640 --> 01:05:39,980
0,390 390,480 930,1740 1740,1890 1890,2340
aspect of Petal,| if you
|如果你想的话。

2074
01:05:40,010 --> 01:05:40,720
0,240 240,420
want to.|
|

2075
01:05:42,020 --> 01:05:43,300
0,270 270,1110
And so.|
所以。|

2076
01:05:43,880 --> 01:05:44,800
0,480

2077
01:05:45,040 --> 01:05:46,930
0,390 390,900 930,1320 1320,1680 1680,1890
Lily or anybody else, any
莉莉或其他任何人，任何其他助教

2078
01:05:46,930 --> 01:05:49,060
0,360 360,750 750,1020 1410,1800 1830,2130
other TAs,| so you send
|所以你把人送到休息室。

2079
01:05:49,060 --> 01:05:50,020
0,180 180,240 240,300 300,570 570,960
people to {} breakout rooms.|
|

2080
01:06:02,130 --> 01:06:03,210
0,210 210,240 240,390 390,600 600,1080
Should I do it, or.|
我应该这么做，还是。|

2081
01:06:03,240 --> 01:06:05,130
0,150 150,210 210,510 1110,1470 1470,1890
{Yeah,it'll} be great.| Okay cool,
是啊，会很棒的。|好的，酷，好的。

2082
01:06:06,210 --> 01:06:07,400
0,690
right.|
|

2083
01:06:12,110 --> 01:06:13,880
0,690 720,1140 1140,1320 1320,1410 1410,1770
I'll close them in about
我大约五分钟后就会关门。

2084
01:06:13,880 --> 01:06:16,020
0,180 180,630
five minutes.|
|

2085
01:06:16,370 --> 01:06:17,120
0,390

2086
01:11:44,020 --> 01:11:45,280
0,510

2087
01:11:53,050 --> 01:11:53,940
0,660

2088
01:12:04,230 --> 01:12:05,080
0,630

2089
01:12:12,740 --> 01:12:13,580
0,510

2090
01:12:13,970 --> 01:12:14,680
0,510

2091
01:12:16,070 --> 01:12:16,760
0,60

2092
01:12:22,020 --> 01:12:23,140
0,270 270,840
Everybody back?|
大家都回来了吗？|

2093
01:12:28,360 --> 01:12:29,500
0,870

2094
01:12:32,010 --> 01:12:33,780
0,240 240,420 420,630 630,1080 1560,1770
Okay, so just, {} just
好的，所以，简单地总结一下，

2095
01:12:33,780 --> 01:12:36,900
0,420 450,1170 1170,1950 2100,2880 2880,3120
{} quickly {} summarized,| so
|因此，我们有3台工作站，

2096
01:12:36,900 --> 01:12:39,030
0,90 90,210 210,390 390,1320 1620,2130
we have 3 workstations,| workstation
|一号工作站在某个时刻删除了日志中的文件，

2097
01:12:39,030 --> 01:12:40,350
0,360 360,450 450,600 600,840 840,1320
one at some point deleted

2098
01:12:40,350 --> 01:12:42,270
0,510 870,1410 1410,1710 1710,1830 1830,1920
the file that's in the

2099
01:12:42,270 --> 01:12:44,910
0,750 930,1650 1650,2130 2130,2460 2460,2640
log,| {} workstation 2 at
|工作站2在稍后创建创建文件F时，

2100
01:12:44,910 --> 01:12:47,190
0,120 120,330 330,750 750,1200 1200,2280
some point later create {}

2101
01:12:47,250 --> 01:12:48,540
0,390 390,630 630,900 930,1140 1140,1290
{create,a} file f,| it is
|这在他的日志里

2102
01:12:48,540 --> 01:12:50,340
0,150 150,270 270,690 1080,1500 1500,1800
in his log| and then
|然后其中一个崩溃，并且工作站3实际上在工作站1的日志上运行恢复恶魔。

2103
01:12:50,340 --> 01:12:52,170
0,330 330,930 930,1140 1140,1590 1590,1830
one crashes and workstation 3

2104
01:12:52,170 --> 01:12:53,730
0,240 240,600 600,960 960,1320 1320,1560
actually runs recovery demon on

2105
01:12:53,730 --> 01:12:54,900
0,90 90,510 510,660 660,960 960,1170
the log of {workstation -}

2106
01:12:54,900 --> 01:12:55,620
0,480
1.|
|

2107
01:12:55,840 --> 01:12:56,740
0,360 360,450 450,660 660,840 840,900
And of course, {it,would} be
当然，这将是一场灾难，

2108
01:12:56,740 --> 01:12:58,300
0,30 30,630 630,780 780,1140 1170,1560
{} disaster,| if the delete
|如果删除将被重播，

2109
01:12:58,300 --> 01:13:00,010
0,120 120,270 270,930 1110,1650 1650,1710
would be replayed,| because {}
|因为后来的创建是在另一个工作站上进行的，

2110
01:13:00,010 --> 01:13:01,180
0,300 300,570 570,720 720,1020 1020,1170
later create has happened on

2111
01:13:01,180 --> 01:13:02,290
0,240 240,750 750,840 840,990 990,1110
another workstation,| but it's in
|但它在另一个日志中，

2112
01:13:02,290 --> 01:13:04,120
0,270 270,660 690,1200 1230,1620 1620,1830
another log,| so demon doesn't
|所以恶魔不知道是什么，

2113
01:13:04,120 --> 01:13:05,350
0,150 150,390 600,870 870,960 960,1230
know what,| how is this
|这个问题怎么解决，

2114
01:13:05,380 --> 01:13:06,680
0,510 510,1050
problem solved,|
|

2115
01:13:07,670 --> 01:13:09,950
0,240 240,420 420,810 1050,1710 1710,2280
or has this potential disaster
或者这场潜在的灾难已经避免了。

2116
01:13:09,950 --> 01:13:10,820
0,540
avoided.|
|

2117
01:13:14,590 --> 01:13:17,620
0,720 810,1170 1170,1500 1500,2220 2460,3030
We said version numbers.| Yeah,
我们说的是版本号。|是的，是的，如果你想的话你可以多说一点。

2118
01:13:19,300 --> 01:13:20,170
0,330 330,450 450,600 600,780 780,870
yes, you could say a

2119
01:13:20,170 --> 01:13:20,740
0,180 180,270 270,450 450,510 510,570
little bit more if you

2120
01:13:20,740 --> 01:13:21,500
0,150 150,450
want to.|
|

2121
01:13:21,820 --> 01:13:24,910
0,510 540,1140 1230,1950 2010,2580 2790,3090
Sure, {} so like it's
当然，就像这是有保证的，

2122
01:13:24,910 --> 01:13:26,560
0,720 720,1200 1200,1320 1320,1530 1530,1650
guaranteed,| because we had the
|因为我们有锁

2123
01:13:26,560 --> 01:13:29,380
0,390 390,600 600,930 1020,2550 2580,2820
lock| that the operations have
|服务器1的操作已完成

2124
01:13:29,380 --> 01:13:33,250
0,330 330,990 1020,1890 2220,2730 3420,3870
already completed for {} server

2125
01:13:33,250 --> 01:13:37,630
0,510 1680,2430 2430,3180 3360,3900 3930,4380
one| and so the like
|因此，类似于将日志的版本号写在花瓣中，

2126
01:13:37,630 --> 01:13:39,370
0,390 540,1080 1080,1410 1410,1620 1620,1740
the version number for the

2127
01:13:39,370 --> 01:13:41,470
0,600 690,990 990,1590 1590,1890 1890,2100
log is written in {}

2128
01:13:41,470 --> 01:13:43,180
0,210 210,660 960,1260 1260,1350 1350,1710
the Petal,| like the last
|就像上一次手术一样

2129
01:13:43,180 --> 01:13:45,580
0,570 570,720 720,1080 1110,1620 1890,2400
operation| and so the recovery
|因此，恢复恶魔不会在当前版本号之前执行任何操作。

2130
01:13:45,580 --> 01:13:47,830
0,270 270,510 510,660 660,1200 1410,2250
demon won't do anything previous

2131
01:13:47,860 --> 01:13:48,480
0,150 150,480
to the

2132
01:13:49,070 --> 01:13:51,500
0,270 270,600 600,870 870,1350 1710,2430
{} current version number.| Yeah,
|是的，这是绝对正确的，

2133
01:13:51,500 --> 01:13:53,450
0,210 210,870 870,1380 1380,1620 1620,1950
that's yeah absolutely right,| so
|所以只要总结一下，

2134
01:13:53,450 --> 01:13:54,980
0,510 510,1110 1110,1290 1290,1410 1410,1530
just summarize,| so we have
|所以我们有两个日志，对吗，

2135
01:13:54,980 --> 01:13:55,880
0,600
two

2136
01:13:56,130 --> 01:13:58,050
0,420 420,750 750,1140 1140,1410 1440,1920
logs, correct,| actually of {}
|实际上很重要

2137
01:13:58,050 --> 01:13:59,520
0,660 660,1050 1050,1170 1170,1350 1350,1470
importance| and we have some
|我们有一些文件系统状态，

2138
01:13:59,520 --> 01:14:00,860
0,240 240,540 540,1020
file system state,|
|

2139
01:14:01,250 --> 01:14:02,720
0,480 480,660 660,840 840,1050 1050,1470
that's in the Petal right,|
这在花瓣的右边，|

2140
01:14:02,720 --> 01:14:03,620
0,150 150,330 330,420 420,510 510,900
so these are the logs|
这些就是日志|

2141
01:14:03,620 --> 01:14:04,610
0,120 120,390 390,630 630,690 690,990
and then here's the actual
然后是实际的文件系统。

2142
01:14:04,610 --> 01:14:05,620
0,270 270,660
file system.|
|

2143
01:14:07,740 --> 01:14:09,390
0,540 540,780 780,1140 1140,1530 1530,1650
And {} here was you
这就是你知道的目录d，

2144
01:14:09,390 --> 01:14:10,470
0,120 120,390 390,570 570,720 720,1080
know like this is directory

2145
01:14:10,470 --> 01:14:12,900
0,720 720,1110 1110,1290 1890,2220 2220,2430
d,| {you,know} and directory d
|您知道，目录d在文件f中被修改了

2146
01:14:12,900 --> 01:14:14,010
0,120 120,720 720,780 780,840 840,1110
was modified in the file

2147
01:14:14,010 --> 01:14:15,660
0,480 480,660 660,1140 1140,1380 1380,1650
f| and deleted that has
|删除了一个我说是10的日志编号，

2148
01:14:15,660 --> 01:14:17,700
0,60 60,330 330,870 870,1470 1500,2040
a log number i say

2149
01:14:17,790 --> 01:14:18,860
0,540
10,|
|

2150
01:14:19,920 --> 01:14:21,990
0,1110 1170,1290 1290,1350 1350,1440 1440,2070
and this is {} workstation
这是2号工作站

2151
01:14:21,990 --> 01:14:23,670
0,690 690,1080 1080,1440 1440,1560 1560,1680
2| and here is {}
|这是D，

2152
01:14:23,670 --> 01:14:24,520
0,540
d,|
|

2153
01:14:24,730 --> 01:14:27,250
0,300 300,780 780,2070 2070,2370 2370,2520
those deleting d, {f,and,d},| and
删除d、f和d，|您正在创建f和d，以及此条目中的日志编号，版本号，抱歉。

2154
01:14:27,250 --> 01:14:28,540
0,120 120,600 600,930 930,1170 1170,1290
you're creating {f,and} d and

2155
01:14:28,540 --> 01:14:29,680
0,390 390,630 630,840 840,990 990,1140
what log number will be

2156
01:14:29,680 --> 01:14:32,400
0,90 90,480 480,1500 1860,2460
in this {} entry,

2157
01:14:34,420 --> 01:14:35,800
0,480 480,720 720,1110
version number, sorry.|
|

2158
01:14:37,840 --> 01:14:42,760
0,1980 3240,3960 3960,4290 4290,4740 4740,4920
11?| {11,yep,basically} totally ordered and
11岁？|11是的基本上是完全有序的，锁定协议确保了他们完全有序。

2159
01:14:42,760 --> 01:14:44,680
0,540 540,990 990,1500 1500,1590 1590,1920
locking protocols ensured they totally

2160
01:14:44,680 --> 01:14:45,420
0,390
ordered.|
|

2161
01:14:45,620 --> 01:14:47,060
0,360 360,660 660,990 1230,1380 1380,1440
And on the, in the
在包含元数据块的文件系统中

2162
01:14:47,060 --> 01:14:48,590
0,270 270,720 720,990 990,1080 1080,1530
file system with the metadata

2163
01:14:48,590 --> 01:14:49,940
0,480 510,750 750,840 840,1260 1260,1350
blocks| like for example if
|例如，如果索引节点块用于F，

2164
01:14:49,940 --> 01:14:50,720
0,90 90,210 210,420 420,690 690,780
the {inode -} block for

2165
01:14:50,720 --> 01:14:51,460
0,480
f,|
|

2166
01:14:52,290 --> 01:14:53,220
0,180 180,360 360,570 570,750 750,930
{} {inode -} have one
具有一个版本号的inode将位于磁盘上或位于Petal中。

2167
01:14:53,220 --> 01:14:54,480
0,270 270,840 900,1080 1080,1200 1200,1260
version number is going to

2168
01:14:54,480 --> 01:14:55,700
0,150 150,360 360,450 450,960
be on the disk

2169
01:14:55,890 --> 01:14:57,020
0,240 240,330 330,840
or in Petal.|
|

2170
01:15:04,490 --> 01:15:05,400
0,600
11?|
11岁？|

2171
01:15:06,000 --> 01:15:06,870
0,300 300,390 390,450 450,720 720,870
Yeah, in the case that
是的，在实际应用于文件系统的操作将是11的情况下，正确。

2172
01:15:06,870 --> 01:15:08,580
0,330 330,600 600,1140 1140,1290 1290,1710
actually the operation was applied

2173
01:15:08,580 --> 01:15:09,720
0,270 270,360 360,750 750,1050 1050,1140
to the {file,system} will be

2174
01:15:09,720 --> 01:15:10,960
0,510 510,810
11, correct.|
|

2175
01:15:11,540 --> 01:15:13,910
0,390 390,690 690,1260 1260,1680 1710,2370
And so when the demon
所以当恶魔我们，

2176
01:15:14,440 --> 01:15:16,690
0,720 750,780 810,1620 1830,2100 2100,2250
we,| { -} what role
|主人公的角色是什么？

2177
01:15:16,690 --> 01:15:18,140
0,180 180,270 270,570 570,1170
does the deme follow?|
|

2178
01:15:20,520 --> 01:15:22,740
0,480 480,1290 1290,1860
Never replace {}
永远不要替换已经应用过的东西。

2179
01:15:22,930 --> 01:15:24,640
0,420 420,600 600,840 840,1050 1050,1710
something that's already been applied.|
|

2180
01:15:25,180 --> 01:15:26,380
0,270 270,420 420,660 660,1050 1050,1200
Yeah, {does,it} just decided it's
是啊，它是不是决定了它适用于。

2181
01:15:26,380 --> 01:15:27,220
0,480
applied.|
|

2182
01:15:28,520 --> 01:15:30,620
0,360 360,690 690,990 990,1410 1800,2100
Like a version number.| {Yeah,version}
就像一个版本号。|是的，版本号，对，

2183
01:15:30,620 --> 01:15:31,520
0,240 270,480 480,600 600,780 780,900
number, right,| so if the
|所以如果版本号

2184
01:15:31,520 --> 01:15:33,200
0,300 300,510 510,660 660,1050 1050,1680
version number| and only replies
|并且只回复一个条目，如果日志记录中的版本号，

2185
01:15:33,200 --> 01:15:34,670
0,90 90,600 600,900 900,1170 1170,1470
an entry, if the version

2186
01:15:34,670 --> 01:15:35,900
0,300 300,420 420,540 540,870 870,1230
number in the log record,|
|

2187
01:15:37,160 --> 01:15:39,040
0,360 360,990 990,1530
log version number
日志版本号高于索引节点或元数据版本号，

2188
01:15:39,380 --> 01:15:41,000
0,450 450,1140 1140,1350 1350,1440 1440,1620
is higher than the {inode

2189
01:15:41,000 --> 01:15:43,340
0,360 360,810 810,1470 1560,1950 1950,2340
-} {or,the} metadata version number,|
|

2190
01:15:45,980 --> 01:15:47,680
0,210 210,510 510,1020
you {know,then} replay,
你知道然后重播，好吗？

2191
01:15:48,450 --> 01:15:49,340
0,480
okay?|
|

2192
01:15:49,970 --> 01:15:50,930
0,210 210,270 270,420 420,870 870,960
So in this case,| you
所以在这种情况下，|您知道，恢复恶魔将在日志记录中看到版本号为10

2193
01:15:50,930 --> 01:15:52,460
0,330 330,600 630,1080 1080,1410 1410,1530
know the recovery demon will

2194
01:15:52,460 --> 01:15:54,470
0,210 210,1020 1200,1590 1590,1890 1890,2010
see the version number in

2195
01:15:54,470 --> 01:15:55,610
0,240 240,540 540,750 750,870 870,1140
the log record is 10|
|

2196
01:15:55,610 --> 01:15:57,080
0,240 240,300 300,780 780,930 930,1470
which is smaller than 11
哪个小于11或等于11，都无关紧要

2197
01:15:57,380 --> 01:15:59,030
0,210 210,570 570,900 900,1110 1110,1650
or equals 11, doesn't matter|
|

2198
01:15:59,120 --> 01:16:00,050
0,180 180,300 300,360 360,570 570,930
and so it won't replay
所以它不会重播，

2199
01:16:00,050 --> 01:16:00,890
0,240 240,330 330,420 420,570 570,840
it,| and so this problem
|因此，这个问题不能出现。

2200
01:16:00,890 --> 01:16:01,780
0,270 270,630
cannot appear.|
|

2201
01:16:02,380 --> 01:16:04,060
0,270 270,450 450,570 570,900 900,1680
So does the 10 necessarily
这10个人也不一定是这样，

2202
01:16:04,060 --> 01:16:06,220
0,360 390,810 810,1590 1590,1890 1890,2160
not,| does it okay such
|是否可以使LIKE 10不在WS工作区2的日志中。

2203
01:16:06,220 --> 01:16:07,480
0,180 180,390 390,630 630,1050 1080,1260
that like that 10 is

2204
01:16:07,480 --> 01:16:09,490
0,240 240,450 450,600 600,1290 1320,2010
not on the ws workspace

2205
01:16:09,490 --> 01:16:10,780
0,540 540,1020
2's log.|
|

2206
01:16:11,850 --> 01:16:14,140
0,1290 1290,1470 1470,1620 1620,1980
Yeah, it's not there.|
是的，它不在那里。|

2207
01:16:14,520 --> 01:16:15,660
0,210 210,480 480,690 690,810 810,1140
So like in the work,|
所以就像在工作中一样，|

2208
01:16:15,660 --> 01:16:16,740
0,240 240,300 300,480 480,720 720,1080
because the {workstation -} 2
因为工作站2实际上在工作站1之后写入了索引节点，

2209
01:16:16,740 --> 01:16:19,890
0,1050 1080,1590 1590,2010 2010,2880 2970,3150
{} wrote actually the {inode

2210
01:16:19,890 --> 01:16:22,410
0,270 270,870 1620,1950 1950,2310 2310,2520
-} after workstation 1,| so
|因此其版本号为11，

2211
01:16:22,410 --> 01:16:24,600
0,210 210,990 990,1350 1350,1710 1710,2190
its version number be 11,|
|

2212
01:16:24,780 --> 01:16:25,740
0,420 420,600 600,660 660,750 750,960
basically what you do to
基本上，你要做的就是准备和更新

2213
01:16:25,740 --> 01:16:27,990
0,360 360,480 480,990 1320,1890 1920,2250
prepare and update| the version
|更新记录中的版本号始终是一加索引节点中的当前版本号。

2214
01:16:27,990 --> 01:16:29,190
0,300 300,420 420,510 510,810 810,1200
number in the update record

2215
01:16:29,190 --> 01:16:30,900
0,90 90,780 810,1530
is always one

2216
01:16:31,270 --> 01:16:32,680
0,690 720,840 840,930 930,1020 1020,1410
plus you know the current

2217
01:16:32,680 --> 01:16:33,520
0,270 270,510 510,600 600,720 720,840
version number in the {inode

2218
01:16:33,520 --> 01:16:34,200
0,420
-}.|
|

2219
01:16:37,960 --> 01:16:38,980
0,390 420,570 570,660 660,750 750,1020
Okay?| This is a small
好吧?|这是一个小问题，

2220
01:16:38,980 --> 01:16:40,090
0,330 330,450 450,780 780,900 900,1110
question,| but what does the
|但是D代表什么呢？

2221
01:16:40,090 --> 01:16:43,540
0,210 210,540 540,810 810,1650 2730,3450
d stand for.| It's directory,
|它是目录，在目录d中创建一个文件，

2222
01:16:45,220 --> 01:16:46,270
0,480 480,600 600,900 900,990 990,1050
creating a file in the

2223
01:16:46,270 --> 01:16:47,590
0,360 360,660 660,810 810,1230 1230,1320
directory d,| we're deleting a
|我们要从目录d中删除一个文件，

2224
01:16:47,590 --> 01:16:48,730
0,300 300,480 480,540 540,900 900,1140
file from the directory d,|
|

2225
01:16:49,860 --> 01:16:51,420
0,300 300,390 390,780 780,960 960,1560
and the update must include
并且更新必须包括一些有关目录的信息。

2226
01:16:51,420 --> 01:16:52,950
0,90 90,720 720,930 930,1380 1380,1530
you know some information about

2227
01:16:52,950 --> 01:16:53,760
0,60 60,480
the directory.|
|

2228
01:16:57,440 --> 01:16:59,540
0,540 780,1260 1560,1830 1830,1950 1950,2100
Okay.| {} Sorry, I had
好吧。|抱歉，我有个小问题，

2229
01:16:59,540 --> 01:17:00,980
0,60 60,210 210,690 720,1230 1260,1440
a quick question,| so are
|它们的版本号也是如此，就像总是绑定到正在编辑的特定inode一样。

2230
01:17:00,980 --> 01:17:02,870
0,360 390,840 840,1290 1290,1500 1530,1890
their version numbers like always

2231
01:17:02,870 --> 01:17:04,100
0,390 390,540 540,630 630,1170 1170,1230
tied to the specific {inode

2232
01:17:04,100 --> 01:17:06,500
0,330 330,510 510,720 720,1260 1740,2400
-} that's being edited.| Yes.|
|是。|

2233
01:17:07,000 --> 01:17:07,800
0,510
Okay.|
好吧。|

2234
01:17:08,520 --> 01:17:10,320
0,780 780,1020 1020,1410 1410,1650 1650,1800
Absolutely, the version number for
当然，每次更新的版本号，对，

2235
01:17:10,320 --> 01:17:11,670
0,270 270,750 780,1050 1050,1200 1200,1350
every update, right,| like there's
|就像目录有一个版本号，

2236
01:17:11,670 --> 01:17:12,990
0,30 30,300 300,600 600,810 810,1320
a version number for directory,|
|

2237
01:17:12,990 --> 01:17:13,800
0,150 150,180 180,450 450,690 690,810
there's a version number for
文件有一个版本号，

2238
01:17:13,800 --> 01:17:14,970
0,60 60,390 390,690 690,870 870,1170
the file,| {} like showing
|就像在这里显示出一点错误一样。

2239
01:17:14,970 --> 01:17:15,930
0,90 90,240 240,360 360,690 690,960
a little bit wrong here.|
|

2240
01:17:16,290 --> 01:17:17,070
0,300 300,390 390,480 480,540 540,780
Like if you go back
比如，如果你回到日志记录中。

2241
01:17:17,070 --> 01:17:18,340
0,90 90,180 180,480 480,990
to the log record.|
|

2242
01:17:18,830 --> 01:17:21,410
0,870 1260,1680 1680,2100 2100,2280 2280,2580
{} Here, basically there's array
在这里，基本上有一系列更新

2243
01:17:21,410 --> 01:17:23,180
0,90 90,690 690,930 930,1200 1200,1770
of updates| and every update
|并且阵列中的每一次更新都在新字节中完成块编号版本号。

2244
01:17:23,240 --> 01:17:24,260
0,150 150,240 240,720 720,870 870,1020
in the array {completes -

2245
01:17:24,260 --> 01:17:25,550
0,240 240,540 540,780 780,1080 1080,1290
-} block number version number

2246
01:17:25,550 --> 01:17:26,540
0,90 90,150 150,300 300,780
in the new bytes.|
|

2247
01:17:28,590 --> 01:17:29,700
0,570
Thanks.|
谢谢。|

2248
01:17:32,440 --> 01:17:34,000
0,240 240,630 630,750 750,1020 1020,1560
Okay, so just stepping back
好了，退一步，结束这篇论文的讨论。

2249
01:17:34,210 --> 01:17:35,560
0,240 240,570 570,750 750,900 900,1350
and closing off the discussion

2250
01:17:35,560 --> 01:17:37,080
0,90 90,840
of {this,paper}.|
|

2251
01:17:38,320 --> 01:17:39,250
0,210 210,420 420,510 510,690 690,930
It's probably the first paper
这可能是我们读到的第一篇论文

2252
01:17:39,250 --> 01:17:41,140
0,150 150,660 960,1350 1350,1500 1500,1890
that we've read| that basically
|基本上按顺序，系统本身并不是

2253
01:17:41,140 --> 01:17:42,310
0,60 60,300 300,360 360,660 660,1170
in order, the system itself

2254
01:17:42,310 --> 01:17:43,120
0,120 120,330 330,390 390,720 720,810
is not the one| you
|你知道它不会是主要的用途，

2255
01:17:43,120 --> 01:17:43,810
0,150 150,300 300,450 450,630 630,690
know it's not going to

2256
01:17:43,810 --> 01:17:45,010
0,60 60,510 510,810 810,900 900,1200
be dominant use,| and therefore
|因此谈论这件事真的很有趣，

2257
01:17:45,010 --> 01:17:45,970
0,120 120,360 360,660 660,750 750,960
it's really interesting to talk

2258
01:17:45,970 --> 01:17:48,880
0,450 660,1290 1290,2280 2310,2820 2820,2910
about,| {} but what is
|但这个系统的有趣之处在于它里面的想法

2259
01:17:48,880 --> 01:17:50,050
0,300 300,540 540,660 660,1020 1020,1170
interesting about this system is

2260
01:17:50,050 --> 01:17:51,700
0,150 150,630 630,780 780,1050 1350,1650
the ideas in it| and
|因此高速缓存一致性协议或高速缓存一致性C协议，

2261
01:17:51,700 --> 01:17:54,120
0,450 480,780 780,1110 1110,1860
so cache coherence protocol

2262
01:17:56,270 --> 01:17:57,940
0,300 300,570 570,1410
or cache consistence

2263
01:17:58,180 --> 01:18:00,100
0,540 540,1260
c protocol,|
|

2264
01:18:03,320 --> 01:18:05,020
0,240 240,720 720,1290
{} distributed locking,
分布式锁定、锁定服务器租用、授予要求撤销、

2265
01:18:07,280 --> 01:18:09,860
0,510 510,1110 1170,1830 1830,2160
lock servers {leases -},

2266
01:18:11,000 --> 01:18:14,930
0,480 480,1230 1710,2670 2670,3120 3150,3930
{} granting requiring {} revoking,|
|

2267
01:18:15,620 --> 01:18:18,580
0,780 810,1710 1710,2280
and distributed recovery,|
和分布式恢复，|

2268
01:18:18,980 --> 01:18:20,930
0,360 360,660 660,1140 1140,1710 1710,1950
where one workstation crashes,| but
当一个工作站崩溃时，|但就像另一个工作站上的恶魔一样，实际上是在进行恢复

2269
01:18:20,930 --> 01:18:23,420
0,360 360,660 660,810 810,1410 1710,2490
like demon on another workstation

2270
01:18:23,420 --> 01:18:25,730
0,270 270,480 480,540 540,1260 1800,2310
actually does the recovery| and
|特别有趣的是，

2271
01:18:25,730 --> 01:18:27,320
0,480 480,840 840,1170 1170,1320 1320,1590
what particularly interesting is that|
|

2272
01:18:27,470 --> 01:18:28,850
0,210 210,510 510,660 660,900 900,1380
what's interesting is the interaction
有趣的是这三个部分之间的互动。

2273
01:18:28,850 --> 01:18:30,260
0,240 240,300 300,600 600,1260
between the three pieces.|
|

2274
01:18:32,140 --> 01:18:33,980
0,240 240,450 450,1230
Then they interact.|
然后他们就会互动。|

2275
01:18:35,180 --> 01:18:36,260
0,390 390,600 600,690 690,990 990,1080
And what we'll see in
我们将在接下来的几篇论文中看到

2276
01:18:36,260 --> 01:18:37,490
0,90 90,480 480,570 570,690 690,1230
the next you know couple

2277
01:18:37,490 --> 01:18:39,200
0,150 150,690 810,1170 1170,1380 1380,1710
of papers| {} next week
|下周尤其不是第一天，

2278
01:18:39,200 --> 01:18:40,550
0,360 360,930 930,1020 1020,1110 1110,1350
particularly not on the first

2279
01:18:40,550 --> 01:18:42,500
0,180 180,390 390,780 1320,1710 1710,1950
day,| but the papers after
|但在那之后的文件，我们将谈论一些繁重的、相当复杂的交易系统，

2280
01:18:42,500 --> 01:18:43,610
0,300 480,690 690,870 870,1020 1020,1110
that, which we're going to

2281
01:18:43,610 --> 01:18:44,330
0,240 240,510 510,600 600,660 660,720
talk about some of the

2282
01:18:44,330 --> 01:18:46,130
0,240 240,840 840,960 960,1230 1230,1800
{heavy-duty -} {} pretty involved

2283
01:18:46,130 --> 01:18:48,110
0,510 510,1050 1230,1560 1560,1770 1770,1980
transaction systems,| we'll see these
|我们也会看到这三个主题

2284
01:18:48,110 --> 01:18:49,430
0,180 180,600 600,810 810,960 960,1320
three topics that come up

2285
01:18:49,760 --> 01:18:52,040
0,990 1020,1440 1650,1860 1860,1980 1980,2280
{} too| and so hopefully
|因此，希望这能帮助你阅读这些文件，

2286
01:18:52,040 --> 01:18:53,330
0,120 120,270 270,510 510,870 870,1290
this will help you in

2287
01:18:53,330 --> 01:18:54,980
0,210 210,750 750,1230 1230,1500 1500,1650
reading {those,papers},| understand actually what
|了解什么是高速缓存一致性，

2288
01:18:54,980 --> 01:18:56,930
0,420 420,930 1290,1740 1740,1830 1830,1950
{cache,coherence} is,| what's you know
|你知道崩溃恢复是什么吗？

2289
01:18:56,930 --> 01:18:59,780
0,270 270,780 780,1140 1140,1830 2070,2850
crash recovery is| and {}
|而且你知道分布式锁。

2290
01:18:59,780 --> 01:19:01,020
0,120 120,240 240,660 660,1140
you know distributed lock.|
|

2291
01:19:02,160 --> 01:19:03,990
0,480 480,720 720,1110 1110,1410 1410,1830
{} And {the,other} probably point
另一点可能很有趣的是，

2292
01:19:03,990 --> 01:19:06,150
0,570 570,1050 1050,1110 1110,1530 1740,2160
it's interesting to make is

2293
01:19:06,150 --> 01:19:07,830
0,300 300,390 390,1140 1170,1590 1590,1680
that| you know Petal is
|你知道，花瓣真的很好，对他们设计它的特定背景很有用。

2294
01:19:07,830 --> 01:19:10,200
0,210 210,750 750,1230 1770,2250 2250,2370
really good for useful for

2295
01:19:10,200 --> 01:19:12,030
0,90 90,720 720,1170 1170,1470 1470,1830
the particular setting they designed

2296
01:19:12,030 --> 01:19:12,740
0,120 120,450
it for.|
|

2297
01:19:16,110 --> 01:19:18,240
0,570 570,660 660,1260 1740,2040 2040,2130
There's the performance part of
这是报纸上的表演部分，

2298
01:19:18,240 --> 01:19:19,080
0,60 60,390 390,600 600,780 780,840
the papers,| but hard to
|但很难理解，

2299
01:19:19,080 --> 01:19:20,220
0,450 450,720 720,870 870,1020 1020,1140
understand,| because it's like from
|因为这好像是从1999年开始的，

2300
01:19:20,220 --> 01:19:22,290
0,450 450,1500 1500,1740 1740,1890 1890,2070
{1999 -},| but I give
|但我看了一下图表，

2301
01:19:22,290 --> 01:19:23,280
0,30 30,210 210,270 270,360 360,990
a look at the graph,|
|

2302
01:19:23,490 --> 01:19:25,800
0,210 210,450 450,690 690,1020 1500,2310
you'll see that the file
您将看到，文件系统的工作负载基本上可以随着工作站数量的增加而增加，

2303
01:19:25,800 --> 01:19:27,540
0,270 270,900 900,1170 1170,1650 1650,1740
system basically {} workload can

2304
01:19:27,540 --> 01:19:28,560
0,480 480,630 630,720 720,960 960,1020
increase with the number of

2305
01:19:28,560 --> 01:19:30,540
0,780 930,1350 1350,1470 1470,1650 1650,1980
workstations,| you know that's exactly
|你知道这正是我们努力的目标

2306
01:19:30,540 --> 01:19:33,330
0,270 270,450 450,750 750,1200 1470,2790
what we're shooting for| and
|他们实现了这一目标，

2307
01:19:33,570 --> 01:19:34,950
0,330 330,570 570,810 810,990 990,1380
and they achieve that goal,|
|

2308
01:19:35,550 --> 01:19:36,690
0,360 390,750 750,870 870,1020 1020,1140
{} anyway I hope you
无论如何，我希望你对这个设计感兴趣

2309
01:19:36,690 --> 01:19:38,220
0,180 180,510 510,810 810,1320 1320,1530
find this design interesting| sort
|有点不像你通常的设计

2310
01:19:38,220 --> 01:19:39,510
0,60 60,330 330,450 450,810 810,1290
of not your usual design|
|

2311
01:19:39,510 --> 01:19:40,500
0,180 180,510 510,600 600,900 900,990
and so I hopefully will
所以我希望我会发人深省。

2312
01:19:40,500 --> 01:19:41,440
0,210 210,420 420,810
have thought provoking.|
|

2313
01:19:42,340 --> 01:19:44,350
0,630 750,1020 1020,1290 1290,1470 1470,2010
And with that I'll stop,|
说到这里，我会停下来，|

2314
01:19:44,650 --> 01:19:46,000
0,180 180,630 630,720 720,900 930,1350
of course you know stick
当然你知道，如果你想问更多的问题，就留下来

2315
01:19:46,000 --> 01:19:46,570
0,240 240,300 300,390 390,510 510,570
around, if you want to

2316
01:19:46,570 --> 01:19:48,610
0,210 210,330 330,930 1260,1620 1620,2040
ask more questions| and otherwise
|否则我第一天就会见到你。

2317
01:19:48,610 --> 01:19:49,420
0,60 60,210 210,330 330,570 570,810
I'll see you first day.|
|

2318
01:19:53,400 --> 01:19:54,630
0,450 510,720 720,1050 1080,1200 1200,1230
{} Can I can I
我能问你两个问题吗，

2319
01:19:54,630 --> 01:19:56,850
0,300 300,420 420,1110 1110,1410 1680,2220
ask two questions,| so, {}
|所以，我的第一个问题是

2320
01:19:57,000 --> 01:19:58,350
0,240 240,510 510,810 810,1050 1050,1350
my first question was just|
|

2321
01:19:58,350 --> 01:20:00,660
0,210 210,930 960,1380 1410,1770 1770,2310
in general the cache coherence
一般而言，这里的高速缓存一致性协议，

2322
01:20:00,660 --> 01:20:02,120
0,540 540,1260
protocol here,|
|

2323
01:20:02,330 --> 01:20:04,310
0,360 360,630 630,1170 1170,1590 1590,1980
it's not have one file
它不是在两个地方有一个文件缓存，对吧。

2324
01:20:04,310 --> 01:20:05,140
0,600
cache

2325
01:20:05,900 --> 01:20:08,420
0,210 210,360 360,1260 1290,1920 2040,2520
in two places, right.| Yep.|
|是啊。|

2326
01:20:08,840 --> 01:20:10,730
0,660 960,1380 1380,1530 1530,1650 1650,1890
Okay, {} and my other
好吧，我的另一个问题是关于，

2327
01:20:10,730 --> 01:20:13,280
0,360 360,540 540,840 840,1320 1560,2550
question was about the,| there
|有一页有日志，

2328
01:20:13,280 --> 01:20:14,960
0,660 720,1410
was {}

2329
01:20:15,110 --> 01:20:17,270
0,270 270,930 930,1260 1260,1470 1470,2160
a page with the log,|
|

2330
01:20:17,420 --> 01:20:18,890
0,480 480,900 930,1110 1110,1350 1350,1470
{} in you have the
在你有日志记录的地方，有。

2331
01:20:18,890 --> 01:20:22,520
0,660 690,2070 2070,2730 2910,3420 3450,3630
log records, there.| Yep, let
|是的，让我回到这里，是的。

2332
01:20:22,520 --> 01:20:24,080
0,90 90,180 180,420 420,780 1020,1560
me go back here, Yep.|
|

2333
01:20:24,080 --> 01:20:26,680
0,540 570,1200 1590,2400
Yeah, I was,
是的，我是，我很好奇你说每一张，每一张唱片都是原子的，

2334
01:20:26,970 --> 01:20:28,140
0,120 120,270 270,750 750,960 960,1170
I was wondering you said

2335
01:20:28,140 --> 01:20:29,520
0,360 390,1110
that each,

2336
01:20:30,060 --> 01:20:31,140
0,330 330,780
each like

2337
01:20:31,610 --> 01:20:34,340
0,150 150,900 930,1500 1500,2430
{} record is atomic,|
|

2338
01:20:35,170 --> 01:20:36,310
0,390 390,600 600,900 900,1080 1080,1140
but each record has a
但每条记录也有一些更新，对吧。

2339
01:20:36,310 --> 01:20:38,920
0,360 360,480 480,1440 1650,2040 2040,2610
number of updates too, right.|
|

2340
01:20:38,950 --> 01:20:41,650
0,600 630,1440 1440,2400 2400,2490 2490,2700
Yes, {} again I think
是的，我再一次认为这份文件有点含糊，

2341
01:20:41,650 --> 01:20:42,760
0,120 120,360 360,660 660,930 930,1110
the paper slightly vague here,|
|

2342
01:20:42,760 --> 01:20:43,810
0,180 180,510 510,660 660,720 720,1050
what exactly what it does,|
它到底是做什么的，|

2343
01:20:43,840 --> 01:20:44,770
0,300 300,360 360,660 660,840 840,930
either it always fits in
它要么始终适合512个字节

2344
01:20:44,770 --> 01:20:46,060
0,630 630,1110
512 bytes|
|

2345
01:20:46,390 --> 01:20:47,710
0,360 360,540 540,630 630,870 870,1320
and then the single sector
然后单个扇区512字节是原子的

2346
01:20:47,710 --> 01:20:50,380
0,690 690,1020 1020,1500 1500,2100 2100,2670
{512 -} bytes is {}

2347
01:20:50,380 --> 01:20:53,050
0,540 600,1170 1170,1560 1560,2340 2400,2670
atomic| or they {} use
|或者他们使用这种校验和技巧。

2348
01:20:53,050 --> 01:20:54,400
0,210 210,660 660,1110
this checksum trick.|
|

2349
01:20:54,570 --> 01:20:56,550
0,600 810,1290 1290,1470 1470,1650 1650,1980
So, {} you read to
所以，你读到五个[]扇区，

2350
01:20:56,550 --> 01:21:00,150
0,510 510,780 780,2010 2100,2670 3060,3600
five {[] -} sectors,| {re-compute
|重新计算校验和并将其与存储的校验和进行比较，

2351
01:21:00,150 --> 01:21:01,800
0,630 630,1080 1080,1200 1200,1560 1560,1650
-} checksum and compare it

2352
01:21:01,800 --> 01:21:03,300
0,150 150,240 240,660 660,1020 1020,1500
with the checksum stored,| it's
|没错，那它一定是一张完整的唱片。

2353
01:21:03,300 --> 01:21:04,680
0,450 450,840 870,1140 1140,1320 1320,1380
right then it must be

2354
01:21:04,680 --> 01:21:05,700
0,60 60,390 390,780
a complete record.|
|

2355
01:21:07,390 --> 01:21:08,830
0,420 420,720 720,930 930,1050 1050,1440
Okay, okay, so if it's
好的，好的，如果它比，

2356
01:21:08,830 --> 01:21:09,970
0,450 450,600 600,810 810,930 930,1140
shorter than,| good, if it's
|很好，如果不是，那你就玩这个把戏，

2357
01:21:09,970 --> 01:21:10,840
0,240 240,480 510,660 660,780 780,870
not then you do the

2358
01:21:10,840 --> 01:21:13,000
0,390 390,630 630,750 750,1140 1560,2160
trick,| okay, I see.| Yeah,
|好的，我明白了。|是啊，我不确定他们到底是做什么的。

2359
01:21:13,000 --> 01:21:14,140
0,60 60,240 240,420 420,840 840,1140
I'm not sure what exactly

2360
01:21:14,140 --> 01:21:16,380
0,90 90,420 1140,1980
they do.| Okay,
|好的，好的，非常感谢。

2361
01:21:16,660 --> 01:21:18,310
0,480 540,900 900,990 990,1140 1140,1650
okay, thank you so much.|
|

2362
01:21:18,310 --> 01:21:19,860
0,210 210,630
You're welcome.|
不用谢。|

2363
01:21:22,090 --> 01:21:23,560
0,210 210,420 420,1230
Any more questions?|
还有什么问题吗？|

2364
01:21:29,260 --> 01:21:31,510
0,390 390,600 600,690 690,1110 1320,2250
{} If you go back
如果你向后或向前看三张幻灯片。

2365
01:21:31,540 --> 01:21:34,570
0,180 180,870 1020,1470 1470,2520 2520,3030
or forward three slides.| Yep.|
|是啊。|

2366
01:21:35,210 --> 01:21:36,580
0,420 450,570 570,1110
Here, it was.|
在这里，就是这样。|

2367
01:21:36,910 --> 01:21:38,080
0,270 270,270 270,780 780,1050 1050,1170
Oh, {} maybe back one
哦，也许可以倒回一张幻灯片，

2368
01:21:38,080 --> 01:21:39,580
0,510 540,840 840,930 930,1290 1290,1500
slide,| there's a section where
|有一节你谈到了如果撞车

2369
01:21:39,580 --> 01:21:41,040
0,180 180,480 480,750 750,1140
you talked about how

2370
01:21:41,330 --> 01:21:42,080
0,450
if

2371
01:21:42,320 --> 01:21:44,420
0,450 960,1380 1380,1800 1800,2010 2010,2100
{} crash happens| during the
|在写入过程中

2372
01:21:44,420 --> 01:21:45,320
0,330 330,420 420,510 510,810 810,900
middle of a write| and
|我们会在日志中看到类似的前缀，

2373
01:21:45,320 --> 01:21:46,460
0,90 90,240 240,390 390,690 690,1140
we get like yeah prefix

2374
01:21:46,460 --> 01:21:48,290
0,90 90,180 180,720 1140,1440 1440,1830
in the log log,| that's
|你介意重复一遍你的意思吗？

2375
01:21:48,290 --> 01:21:49,370
0,210 210,540 540,630 630,990 990,1080
like okay or something do

2376
01:21:49,370 --> 01:21:50,630
0,90 90,270 270,750 750,930 930,1260
you mind repeating what you

2377
01:21:50,630 --> 01:21:52,670
0,300 300,690 960,1470 1470,1650 1650,2040
meant there.| Yeah, okay, so
|是的，好的，那么让我们回到最后一张照片，

2378
01:21:52,670 --> 01:21:54,860
0,780 1110,1590 1620,1860 1860,1980 1980,2190
{} so let's go back

2379
01:21:54,860 --> 01:21:55,760
0,90 90,270 270,510 510,810 810,900
to this last picture,| I
|我刚才在这里展示了，

2380
01:21:55,760 --> 01:21:58,940
0,180 180,660 1680,2460 2640,3000 3000,3180
just showed earlier here,| so
|所以我们有我们的，所以工作站1可以执行很多很多文件系统操作，对吗，

2381
01:21:58,940 --> 01:22:01,940
0,390 390,600 600,870 870,1230 1530,3000
we have our, so the

2382
01:22:02,480 --> 01:22:03,560
0,270 270,510 510,840 840,990 990,1080
{workstation -} 1 could have

2383
01:22:03,560 --> 01:22:05,030
0,450 450,780 780,990 990,1230 1230,1470
executed many, many file system

2384
01:22:05,030 --> 01:22:06,920
0,480 480,840 1350,1590 1590,1800 1800,1890
operations, correct,| each one of
|它们中的每一个由这些锁中的一个通过日志中的条目描述，

2385
01:22:06,920 --> 01:22:08,930
0,960 960,1410 1410,1710 1710,1920 1920,2010
them described by one of

2386
01:22:08,930 --> 01:22:10,160
0,150 150,510 510,780 780,900 900,1230
these lock by an entry

2387
01:22:10,160 --> 01:22:11,690
0,60 60,150 150,540 1050,1320 1320,1530
in the log,| so like
|因此，就像它可能创建文件f的第一个条目一样，

2388
01:22:11,690 --> 01:22:12,980
0,120 120,510 510,990 990,1080 1080,1290
the first entry it might

2389
01:22:12,980 --> 01:22:14,150
0,120 120,420 420,660 660,960 960,1170
be creating file f, {}|
|

2390
01:22:14,150 --> 01:22:15,260
0,300 300,660 660,750 750,840 840,1110
second entry in the log
日志中的第二个条目可以是创建文件G，

2391
01:22:15,260 --> 01:22:16,700
0,240 240,420 420,720 720,1320 1320,1440
might be creating {file,g},| you
|你知道，不管第三个会创建什么，删除文件f。

2392
01:22:16,700 --> 01:22:17,660
0,150 150,480 480,540 540,780 780,960
know whatever the third one

2393
01:22:17,660 --> 01:22:19,550
0,180 180,720 720,1140 1140,1530 1530,1890
might creating deleting file f.|
|

2394
01:22:20,140 --> 01:22:21,130
0,210 210,420 420,600 600,750 750,990
And so there's a whole
所以有一个完整的操作序列，

2395
01:22:21,130 --> 01:22:23,140
0,360 360,450 450,960 960,1200 1200,2010
sequence of operations,| because remember
|因为请记住，工作站只是继续执行文件系统操作，

2396
01:22:23,170 --> 01:22:24,910
0,150 150,630 630,810 810,1080 1080,1740
the workstation just keeps executing

2397
01:22:24,910 --> 01:22:28,060
0,480 510,720 720,960 960,1710 2190,3150
{} file system operations, {}|
|

2398
01:22:28,060 --> 01:22:29,320
0,150 150,360 360,510 510,810 810,1260
as long as {it,holds} locks|
只要它能锁住|

2399
01:22:29,320 --> 01:22:30,610
0,180 180,630 630,930 930,1170 1170,1290
and nobody else wants the
而且没有其他人想要这把锁。

2400
01:22:30,610 --> 01:22:31,340
0,570
lock.|
|

2401
01:22:31,590 --> 01:22:32,820
0,300 300,480 480,690 690,1080 1080,1230
And so the lock could
因此，锁可以是包含一大堆文件系统操作，

2402
01:22:32,820 --> 01:22:34,680
0,360 360,960 990,1410 1410,1470 1470,1860
be a contained a whole

2403
01:22:34,680 --> 01:22:37,020
0,690 720,990 990,1320 1320,1590 1590,2340
bunch of file system operations,|
|

2404
01:22:37,110 --> 01:22:38,370
0,270 270,420 420,720 720,990 990,1260
now for each file system
现在，对于每个文件系统操作，对于每个单独的操作，

2405
01:22:38,370 --> 01:22:39,870
0,450 450,570 570,660 660,1140 1140,1500
operation, for each individual one,|
|

2406
01:22:39,900 --> 01:22:41,160
0,240 240,300 300,600 600,1050
there's a log record.|
有一份日志记录。|

2407
01:22:42,180 --> 01:22:43,890
0,630 750,870 870,1200 1200,1620 1620,1710
And the log records, you
而日志记录，你知道的，是原子文件系统操作

2408
01:22:43,890 --> 01:22:46,080
0,420 480,1200 1200,1590 1590,2010 2010,2190
know is the atomic file

2409
01:22:46,080 --> 01:22:47,580
0,240 240,720 720,1290 1290,1410 1410,1500
system operations| description of the
|需要进行的更改的说明

2410
01:22:47,580 --> 01:22:48,480
0,420 420,570 570,720 720,780 780,900
changes that need to be

2411
01:22:48,480 --> 01:22:49,560
0,270 270,360 360,480 480,720 720,1080
made| to the actual files
|到要锁定的实际文件

2412
01:22:49,560 --> 01:22:52,260
0,120 120,660 840,1320 1320,2070 2100,2700
to lock| to {} reflect
|以反映该文件系统操作。

2413
01:22:52,290 --> 01:22:54,020
0,480 480,690 690,930 930,1470
that file system operation.|
|

2414
01:22:54,590 --> 01:22:55,700
0,240 240,360 360,510 510,660 660,1110
And so what could happen,
那么会发生什么呢，对吗？

2415
01:22:55,700 --> 01:22:58,490
0,270 270,570 570,960 1200,2010 2130,2790
right| is that {} {the,revoke}
|撤销消息进入了工作站1，

2416
01:22:58,490 --> 01:23:00,950
0,300 300,570 570,1020 1140,1920 1950,2460
message comes in the workstation

2417
01:23:00,950 --> 01:23:02,660
0,300 300,630 630,960 960,1140 1140,1710
1,| starts writing its log
|开始把它的日志写给花瓣，

2418
01:23:02,690 --> 01:23:04,310
0,90 90,210 210,900 900,1080 1080,1620
you know to {} Petal,|
|

2419
01:23:04,550 --> 01:23:05,630
0,360 360,480 480,690 690,930 930,1080
but it just doesn't get
但这并不能一直持续到最后，

2420
01:23:05,630 --> 01:23:06,380
0,60 60,360 360,540 540,630 630,750
the whole way to the

2421
01:23:06,380 --> 01:23:07,430
0,270 270,420 420,600 600,930 930,1050
end,| it just happens to
|它只是碰巧坠毁了，就像在中间的某个地方，任何地方，对吧，

2422
01:23:07,430 --> 01:23:08,330
0,390 390,540 540,780 780,840 840,900
crash, like somewhere in the

2423
01:23:08,330 --> 01:23:10,850
0,330 360,660 660,1230 1530,1980 2370,2520
middle like anywhere, right,| in
|在这种情况下，工作站1的前缀在磁盘上或在花瓣中。

2424
01:23:10,850 --> 01:23:13,130
0,360 360,960 960,1380 1380,2040 2040,2280
that case, the prefix of

2425
01:23:13,130 --> 01:23:14,930
0,330 360,900 900,1440 1470,1650 1650,1800
the workstation 1 is on

2426
01:23:14,930 --> 01:23:15,600
0,90 90,600
the disk

2427
01:23:16,870 --> 01:23:18,040
0,240 240,420 420,870
or in Petal.|
|

2428
01:23:18,530 --> 01:23:19,970
0,540 540,900 900,1050 1050,1320 1320,1440
{} And that means that
这意味着操作中的最后几个文件基本上只是日志，

2429
01:23:19,970 --> 01:23:21,470
0,360 360,480 480,930 930,1200 1200,1500
basically the last couple files

2430
01:23:21,470 --> 01:23:22,940
0,180 180,660 660,720 720,960 960,1470
from operation are just logs,|
|

2431
01:23:27,370 --> 01:23:29,200
0,270 270,570 570,960 990,1560 1560,1830
and only the prefix will
并且只有前缀将被重播。

2432
01:23:29,200 --> 01:23:30,240
0,150 150,690
be replayed.|
|

2433
01:23:31,300 --> 01:23:32,170
0,240 240,480 480,600 600,720 720,870
I see and we're just
我明白了，我们只是在说没关系。

2434
01:23:32,170 --> 01:23:33,790
0,210 210,450 450,930 1170,1380 1380,1620
saying that's okay.| Yeah, we're
|是的，我们接受这一结果。

2435
01:23:33,790 --> 01:23:35,020
0,360 360,540 540,930
accepting that outcome.|
|

2436
01:23:35,690 --> 01:23:36,920
0,270 270,390 390,600 600,810 900,1230
Got it, thank you.| Because
知道了，谢谢。|因为我们早些时候已经接受了这一结果，

2437
01:23:36,920 --> 01:23:37,940
0,120 120,330 330,720 720,810 810,1020
we're already accepted to that

2438
01:23:37,940 --> 01:23:39,470
0,270 270,840 870,1260 1260,1380 1380,1530
outcome earlier,| because it could
|因为在这种情况下是可以的，

2439
01:23:39,470 --> 01:23:40,940
0,570 570,690 690,870 870,1230 1230,1470
{in,the,case},| that we've got the
|在您收到撤销消息之前或之后我们的文件系统崩溃了，

2440
01:23:40,940 --> 01:23:43,400
0,210 210,480 480,810 1530,1920 1920,2460
file system crashed right before

2441
01:23:43,400 --> 01:23:44,270
0,180 180,390 390,660 660,720 720,870
or right after you got

2442
01:23:44,270 --> 01:23:45,380
0,90 90,510 510,840 840,990 990,1110
the revoke message,| but it
|但它实际上没有向Petal写入任何日志条目。

2443
01:23:45,380 --> 01:23:46,490
0,180 180,360 360,570 570,840 840,1110
actually didn't write any log

2444
01:23:46,490 --> 01:23:48,640
0,480 540,780 780,1440 1500,1920
entries get to Petal.|
|

2445
01:23:56,790 --> 01:23:58,020
0,240 240,390 390,930
Any more questions?|
还有什么问题吗？|

2446
01:23:58,500 --> 01:23:59,180
0,390

2447
01:24:01,880 --> 01:24:03,800
0,180 180,420 420,690 690,1260 1260,1920
I have a completely unrelated
我有一个与6.824完全无关的问题，

2448
01:24:03,830 --> 01:24:06,980
0,750 1590,2310 2370,2790 2790,3030 3030,3150
question {} to {6.824 -

2449
01:24:06,980 --> 01:24:09,080
0,450 450,1110 1290,1560 1560,1710 1710,2100
-},| but I was wondering
|但我想知道你是否知道下学期的6.858，

2450
01:24:09,080 --> 01:24:11,450
0,240 240,360 360,840 1110,1740 1770,2370
if you knew {} anything

2451
01:24:11,450 --> 01:24:12,980
0,630 630,900 900,1170 1170,1260 1260,1530
about {} {6.858 - -

2452
01:24:12,980 --> 01:24:14,810
0,540 570,870 870,1050 1050,1320 1320,1830
-} {} for next semester,|
|

2453
01:24:14,810 --> 01:24:16,220
0,90 90,300 300,720 720,1290 1290,1410
I saw professor Zeldovich is
我看到泽尔多维奇教授要教6.860。

2454
01:24:16,220 --> 01:24:18,020
0,120 120,180 180,360 360,960 1320,1800
going to be teaching {}

2455
01:24:18,080 --> 01:24:20,720
0,630 630,1080 1080,1380 1380,2130 2130,2640
{6.860 - - -}.| Yeah,
|是的，我想我们，目前的计划不会在秋季提供6.858，

2456
01:24:20,720 --> 01:24:22,250
0,150 150,330 330,870 900,1170 1170,1530
I think we're, {} the

2457
01:24:22,250 --> 01:24:23,960
0,240 240,420 420,540 540,930 930,1710
current plan does not offer

2458
01:24:23,960 --> 01:24:25,640
0,150 150,390 390,570 570,930 930,1680
{} {6.858 -} in the

2459
01:24:26,240 --> 01:24:29,510
0,840 1200,1950 1980,2370 2370,2520 2520,3270
Fall,| {} but we're hoping
|但我们希望能在春季推出。

2460
01:24:29,510 --> 01:24:30,710
0,570 570,930 930,1020 1020,1140 1140,1200
to offer it in the

2461
01:24:30,710 --> 01:24:31,440
0,390
Spring.|
|

2462
01:24:31,790 --> 01:24:33,380
0,510 540,1050 1110,1410 1410,1500 1500,1590
Okay, awesome, {} do you
好的，太棒了，你知道6.860是什么吗，

2463
01:24:33,380 --> 01:24:35,870
0,120 120,510 600,960 960,1260 1740,2490
know what {6.860 - -}

2464
01:24:35,900 --> 01:24:37,190
0,360 360,540 540,720 720,1020 1020,1290
is,| I I couldn't find
|我找不到太多关于我的信息。

2465
01:24:37,190 --> 01:24:42,410
0,240 240,840 840,2430 2430,4230 4950,5220
much information for.| Yeah, that's
|是啊，这是个好问题，

2466
01:24:42,410 --> 01:24:43,910
0,60 60,180 180,600 810,1350 1350,1500
a good question,| {} it's
|这是一门本科生课程。

2467
01:24:43,910 --> 01:24:47,210
0,450 450,540 540,900 900,2220 2220,3300
intended to be a undergraduate

2468
01:24:47,210 --> 01:24:47,820
0,480
class.|
|

2469
01:24:48,380 --> 01:24:49,260
0,660
Okay.|
好吧。|

2470
01:24:49,560 --> 01:24:50,740
0,480 510,870
Okay, nice.|
好的，很好。|

2471
01:24:51,320 --> 01:24:52,820
0,300 300,480 480,750 750,930 930,1500
So like {6.858 - -
大概6.858岁，但还是本科生。

2472
01:24:52,820 --> 01:24:54,890
0,570 600,870 870,1140 1140,1410 1410,2070
- - - -} but

2473
01:24:55,100 --> 01:24:57,800
0,510 750,1590 1920,2280 2280,2490 2490,2700
{} undergrad.| {Yeah -}, sort
|是的，有点像，也许是6.857和6.858的入门。

2474
01:24:57,800 --> 01:25:00,470
0,90 90,270 270,1470 2190,2610 2610,2670
of like, {} maybe an

2475
01:25:00,470 --> 01:25:01,580
0,390 390,480 480,750 750,960 960,1110
intro to both {6.857 -

2476
01:25:01,580 --> 01:25:02,780
0,210 210,570 570,840 840,990 990,1200
- -} {and,6.858 - -

2477
01:25:02,780 --> 01:25:03,300
0,270
-}.|
|

2478
01:25:04,960 --> 01:25:06,180
0,660
Okay,
好的，电话号码是多少？

2479
01:25:06,540 --> 01:25:07,860
0,300 300,390 390,1020
what's the number?|
|

2480
01:25:08,070 --> 01:25:09,540
0,300 300,450 450,600 600,1170 1170,1470
{} It's an experimental number,|
这是一个实验性的数字，|

2481
01:25:09,540 --> 01:25:10,620
0,90 90,240 240,300 300,450 450,1080
it's one of these experimental,|
这是一种实验性的，|

2482
01:25:10,620 --> 01:25:11,880
0,420 420,480 480,720 720,930 930,1260
because the class doesn't exist
因为这个类还不存在

2483
01:25:11,880 --> 01:25:13,560
0,510 930,1140 1140,1260 1260,1380 1380,1680
yet| and will be offered
|并将提供，因为您知道，目标是提供它在秋季首次。

2484
01:25:13,560 --> 01:25:14,490
0,420 420,540 540,660 660,750 750,930
for you know the goal

2485
01:25:14,490 --> 01:25:15,120
0,90 90,150 150,420 420,510 510,630
is to offer it for

2486
01:25:15,120 --> 01:25:15,810
0,60 60,360 360,540 540,600 600,690
the first time in the

2487
01:25:15,810 --> 01:25:16,440
0,390
Fall.|
|

2488
01:25:17,530 --> 01:25:19,500
0,840 1080,1680
Okay, {}
好的，那么，这是不是主要是因为，

2489
01:25:20,060 --> 01:25:21,380
0,420 420,630 630,900 900,1110 1110,1320
so, is it gonna be

2490
01:25:21,380 --> 01:25:23,690
0,510 510,990 990,1230 1230,1650 2100,2310
mostly content from,| like is
|就像6.858是不是会保持它原来的样子，或者是它。

2491
01:25:23,690 --> 01:25:25,070
0,150 150,390 390,570 570,840 990,1380
{6.858 - -} gonna keep

2492
01:25:25,070 --> 01:25:26,600
0,180 180,630 630,1140 1140,1380 1380,1530
its original form, or is

2493
01:25:26,600 --> 01:25:29,570
0,240 330,1410 2130,2640 2640,2880 2880,2970
it.| {} You're asking me
|你在问我问题，我没有。

2494
01:25:29,570 --> 01:25:31,580
0,390 390,420 420,750 750,1110 1110,2010
questions, I don't.| Sorry.| Yeah,
|抱歉的。|是的，我认为参与设计这门课的人

2495
01:25:31,610 --> 01:25:36,200
0,2400 2430,2850 2850,3960 3960,4200 4200,4590
I think the people involved

2496
01:25:36,200 --> 01:25:37,760
0,180 180,900 900,1110 1110,1470 1470,1560
in {} in designing the

2497
01:25:37,760 --> 01:25:38,960
0,330 330,780 810,1050 1050,1170 1170,1200
class| are people that are
|有没有参与6.857的人

2498
01:25:38,960 --> 01:25:40,010
0,300 300,390 390,510 510,720 720,1050
involved in {6.857 - -}|
|

2499
01:25:40,010 --> 01:25:40,880
0,180 180,240 240,510 510,810 810,870
and the people involved in
以及6.858事件的涉案人员。

2500
01:25:40,880 --> 01:25:42,230
0,90 90,300 300,720 720,1140 1140,1350
{6.858 -}.| Yeah.| I'm not
|嗯。|我实际上并没有参与其中。

2501
01:25:42,230 --> 01:25:43,080
0,240 240,750
actually involved.|
|

2502
01:25:43,280 --> 01:25:44,900
0,540 570,810 810,1080 1080,1350 1350,1620
Okay, yet another reason,| but
好吧，还有一个原因，|但是，他们正在努力制定课程，这将是

2503
01:25:45,140 --> 01:25:47,300
0,720 990,1530 1530,1860 1860,2070 2070,2160
{} and they're trying to

2504
01:25:47,300 --> 01:25:48,110
0,180 180,300 300,390 390,450 450,810
work out with the curriculum

2505
01:25:48,110 --> 01:25:49,040
0,360 360,450 450,570 570,630 630,930
exactly it's going to be|
|

2506
01:25:49,040 --> 01:25:49,820
0,150 150,330 330,420 420,690 690,780
and then of course he's
当然，他会对6.858，6.857进行一些计算。

2507
01:25:49,820 --> 01:25:50,930
0,120 120,180 180,330 330,540 540,1110
going to have some calculations

2508
01:25:50,930 --> 01:25:52,010
0,300 300,390 390,630 630,960 960,1080
for {6.858 - -} {6.857

2509
01:25:52,010 --> 01:25:52,740
0,180 180,450
- -}.|
|

2510
01:25:53,580 --> 01:25:55,380
0,570 780,1170 1170,1500
Okay, sounds good.|
好的，听起来不错。|

2511
01:25:55,630 --> 01:25:56,650
0,270 270,540 540,660 660,840 840,1020
But {6.858 - -}, {6.857
但是6.858，6.857，我不会离开，这就是。

2512
01:25:56,650 --> 01:25:57,610
0,390 390,510 510,660 660,840 840,960
-}, I'm not gonna go

2513
01:25:57,610 --> 01:25:59,740
0,390 930,1320 1320,1800
away, that's the.|
|

2514
01:26:01,960 --> 01:26:04,360
0,630 870,1020 1020,1170 1170,1440 2130,2400
{Great,thanks}.| You're {welcome -}.| {I,have}
非常感谢。|不用谢。|我有个问题，

2515
01:26:04,360 --> 01:26:06,040
0,450 660,1410 1410,1530 1530,1620 1620,1680
a question,| I don't know
|我不知道它有多快，

2516
01:26:06,040 --> 01:26:07,150
0,120 120,390 390,480 480,690 690,1110
how quick it is,| but
|但在论文中，在页末，

2517
01:26:07,630 --> 01:26:09,190
0,540 540,750 750,870 870,1410 1410,1560
{} in the paper, at

2518
01:26:09,190 --> 01:26:11,470
0,180 180,420 420,750 1050,1650 1650,2280
the end of page, {}|
|

2519
01:26:12,190 --> 01:26:14,320
0,840 840,990 990,1260 1260,1620 1620,2130
like right before section seven,
就像在第七节之前，他们谈到了一起败诉案件，

2520
01:26:14,470 --> 01:26:16,540
0,420 420,750 750,1230 1230,1320 1320,2070
they talk about a case

2521
01:26:16,660 --> 01:26:18,240
0,300 300,840 840,1410
{} failure,| where
|哪里像租约到期了？

2522
01:26:18,520 --> 01:26:19,990
0,480 480,750 750,960 960,1140 1140,1470
{} with like the lease

2523
01:26:19,990 --> 01:26:21,760
0,780 780,1140 1140,1230 1230,1560 1560,1770
expiring| and the server not
|而且服务器并没有真的崩溃。

2524
01:26:21,760 --> 01:26:24,040
0,180 180,870 1080,1530 1650,1950 1950,2280
really crashing.| Yeah.| And then
|嗯。|然后谈论这样的事情

2525
01:26:24,040 --> 01:26:26,700
0,330 330,900 930,1590 1650,2400
talk about like {}|
|

2526
01:26:26,970 --> 01:26:28,560
0,570 570,840 840,1110 1110,1320 1320,1590
basically that there's no real
基本上，没有真正的解决方案。

2527
01:26:28,560 --> 01:26:32,520
0,510 990,2700 2700,3660 3660,3750 3750,3960
solution.| {Well,there,is,a,solution},| {there,is} a real
|嗯，有一个解决方案，|有一个真正的解决方案。

2528
01:26:32,520 --> 01:26:36,440
0,510 510,2010 2520,2880 2880,3600
solution.| Like human intervention.|
|比如人类的干预。|

2529
01:26:36,730 --> 01:26:37,960
0,420 420,690 720,930 930,1080 1080,1230
Yeah, okay, so I think
是的，好的，所以我认为论文主题的[]中的问题是

2530
01:26:37,960 --> 01:26:38,680
0,60 60,330 330,570 570,630 630,720
the problem here in the

2531
01:26:38,680 --> 01:26:39,850
0,570 570,780 780,870 870,1080 1080,1170
[] of the theme of

2532
01:26:39,850 --> 01:26:40,690
0,90 90,330 330,540 540,690 690,840
the paper works| like a
|就像花瓣和Frangipani是独立设计的

2533
01:26:40,690 --> 01:26:42,430
0,480 480,690 690,1290 1290,1410 1410,1740
Petal and Frangipani are designed

2534
01:26:42,430 --> 01:26:44,470
0,780 1170,1500 1500,1650 1650,1980 1980,2040
independently| and that has a
|它有很多很好的特性，

2535
01:26:44,470 --> 01:26:46,330
0,150 150,210 210,450 450,1200 1470,1860
lot of nice properties, {}|
|

2536
01:26:46,330 --> 01:26:46,990
0,150 150,300 300,390 390,570 570,660
and this is going to
这将是一个只有一个地方，

2537
01:26:46,990 --> 01:26:48,250
0,180 180,420 420,660 660,1050 1050,1260
where one one place,| where
|这将是非常有帮助的，

2538
01:26:48,250 --> 01:26:49,480
0,90 90,240 240,300 300,600 600,1230
it would be very helpful,|
|

2539
01:26:49,480 --> 01:26:50,770
0,420 420,660 660,870 870,1140 1140,1290
hopefully that your Petal has
希望你的花瓣得到一些支持，以帮助弗拉吉帕尼。

2540
01:26:50,770 --> 01:26:52,870
0,150 150,810 1080,1170 1170,1500 1500,2100
some support to help Frangipani

2541
01:26:52,870 --> 01:26:53,500
0,90 90,450
{along -}.|
|

2542
01:26:53,760 --> 01:26:55,500
0,660 750,1020 1020,1410 1410,1530 1530,1740
And that support would be
该支持实际上会在写入Petal上有一个时间戳，

2543
01:26:55,500 --> 01:26:56,610
0,270 270,480 480,540 540,780 780,1110
actually have a {timestamp -}

2544
01:26:56,610 --> 01:26:58,110
0,150 150,300 300,870 900,1080 1080,1500
on the writes to Petal,|
|

2545
01:26:58,110 --> 01:26:59,310
0,120 120,390 420,690 690,810 810,1200
so that Petal could see
这样花瓣就可以看到写出来的地方基本上太旧了。

2546
01:26:59,310 --> 01:27:00,270
0,180 180,240 240,570 570,870 870,960
{where -} write actually is

2547
01:27:00,270 --> 01:27:02,100
0,300 360,990 990,1440
out basically {too,old}.|
|

2548
01:27:04,010 --> 01:27:04,920
0,630
Okay.|
好吧。|

2549
01:27:05,120 --> 01:27:06,290
0,210 210,510 510,660 660,810 810,1170
So unless you do that,|
所以除非你这么做，|

2550
01:27:06,290 --> 01:27:07,310
0,120 120,330 330,450 450,720 720,1020
you need to like fiddle
你需要喜欢摆弄喜欢的边际。

2551
01:27:07,310 --> 01:27:08,720
0,390 390,510 510,690 690,780 780,1410
around with like the margin.|
|

2552
01:27:10,790 --> 01:27:11,700
0,630
Okay.|
好吧。|

2553
01:27:11,920 --> 01:27:13,810
0,150 150,330 330,780 780,1230 1230,1890
And what happens if, {}|
如果，|

2554
01:27:14,610 --> 01:27:18,060
0,1290 1530,1950 1980,2280 2280,2940 2940,3450
like that error occurs,| like
就像那个错误发生一样，|就像在边际边界之外。

2555
01:27:18,760 --> 01:27:19,750
0,480 480,540 540,660 660,930 930,990
outside of the bounds of

2556
01:27:19,750 --> 01:27:21,370
0,60 60,600 990,1230 1230,1500 1500,1620
the margin.| {} It'll be
|会很酷的，

2557
01:27:21,370 --> 01:27:24,670
0,240 240,660 1230,3000 3000,3120 3120,3300
that's cool,| basically you get
|基本上，你得到的是较旧的写入

2558
01:27:24,670 --> 01:27:26,200
0,90 90,570 570,1050 1050,1200 1200,1530
an older writes| you show
|你出现在基本上其他人可能已经锁定了文件的地方，对吗，

2559
01:27:26,200 --> 01:27:28,810
0,210 210,360 360,720 1140,2130 2220,2610
up in the basically somebody

2560
01:27:28,810 --> 01:27:29,740
0,210 210,360 360,450 450,690 690,930
else might have that point

2561
01:27:29,740 --> 01:27:30,700
0,240 240,330 330,720 750,870 870,960
gotten the lock on the

2562
01:27:30,700 --> 01:27:32,170
0,360 360,720 720,1050 1050,1320 1320,1470
file, correct,| started writing to
|开始给它写信

2563
01:27:32,170 --> 01:27:33,280
0,240 300,600 600,780 780,900 900,1110
it| and then there's old
|然后又出现了旧笔迹

2564
01:27:33,280 --> 01:27:34,660
0,240 240,480 480,720 720,810 810,1380
write shows up| and basically
|基本上可以改写其中的某一部分。

2565
01:27:34,690 --> 01:27:35,770
0,240 240,330 330,720 720,870 870,1080
{presumably -} overwrite some part

2566
01:27:35,770 --> 01:27:36,180
0,60 60,210
of it.|
|

2567
01:27:37,210 --> 01:27:38,100
0,630
Okay.|
好吧。|

2568
01:27:38,870 --> 01:27:40,460
0,240 240,360 360,600 600,1290
So will break consistency.|
因此，这将打破一致性。|

2569
01:27:42,460 --> 01:27:44,700
0,360 360,630 630,930
So, {thank,you}.| {You're,welcome}.|
所以，谢谢你。|不用谢。|

2570
01:27:49,280 --> 01:27:50,280
0,750
Okay.|
好吧。|

2571
01:27:51,740 --> 01:27:53,120
0,300 300,420 420,720 720,1080
Because we'll stop that.
因为我们会阻止这一切的。

2572
01:27:55,370 --> 01:27:56,360
0,690

