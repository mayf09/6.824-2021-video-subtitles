1
00:00:01,280 --> 00:00:03,860
0,390 390,1020 1050,1590 1770,2100 2100,2580
Okay, {} so good morning,
好的，早上好，下午好，晚上好，不管你在哪里，

2
00:00:03,890 --> 00:00:05,690
0,270 270,960 960,1110 1110,1320 1320,1800
good afternoon or good evening

3
00:00:05,690 --> 00:00:07,520
0,240 240,630 630,780 780,1140 1680,1830
or wherever you are,| and
|今天的计划是讨论 Frangipani ，

4
00:00:07,520 --> 00:00:08,480
0,180 180,360 360,540 540,840 840,960
{ -} the plan for

5
00:00:08,480 --> 00:00:09,980
0,480 750,900 900,990 990,1200 1200,1500
today is to talk about

6
00:00:09,980 --> 00:00:11,570
0,270 270,570 570,1080 1140,1380 1380,1590
the {Frangipani -},| {} this
|这是一篇 1997 年的论文，

7
00:00:11,570 --> 00:00:13,520
0,120 120,210 210,570 570,1080 1470,1950
is a paper from {}

8
00:00:13,550 --> 00:00:15,590
0,810 810,1410 1410,1530 1530,1710 1740,2040
1997,| so it's a bit
|所以这是一篇有点老的论文，

9
00:00:15,590 --> 00:00:16,780
0,120 120,210 210,510 510,1020
of an older paper,|
|

10
00:00:17,240 --> 00:00:18,500
0,330 330,450 450,990 990,1080 1080,1260
{} the context of this
本文的研究背景是网络文件系统，

11
00:00:18,500 --> 00:00:21,230
0,870 930,1410 1410,1740 1740,2010 2010,2730
paper is network file systems,|
|

12
00:00:29,510 --> 00:00:30,470
0,450 450,570 570,660 660,840 840,960
and you know you should
你应该考虑像 Athena AFS 这样的系统，

13
00:00:30,470 --> 00:00:31,910
0,150 150,420 420,810 810,1080 1080,1440
think about systems such as

14
00:00:31,910 --> 00:00:33,260
0,150 150,450 450,720 720,1080 1080,1350
you know {Athena -} {AFS

15
00:00:33,260 --> 00:00:34,820
0,450 750,900 900,1020 1020,1260 1260,1560
-},| {that,you,know} the file system
|像 Athena 的文件系统，

16
00:00:34,820 --> 00:00:38,000
0,90 90,660 960,1500 1500,2460 2490,3180
like Athena,| {} Dropbox, a
|Dropbox 一个更现代的版本，

17
00:00:38,030 --> 00:00:39,650
0,510 510,900 900,1170 1170,1260 1260,1620
more modern version of this,|
|

18
00:00:40,040 --> 00:00:41,840
0,690 690,780 780,1200 1200,1470 1470,1800
but the general goal here
但这里的总体目标是，

19
00:00:41,840 --> 00:00:43,010
0,120 120,210 210,600 600,840 840,1170
is| to basically share files
|在一组用户之间共享文件。

20
00:00:43,010 --> 00:00:44,750
0,510 540,810 810,1140 1140,1230 1230,1740
between a collection of users.|
|

21
00:00:45,520 --> 00:00:48,610
0,570 870,1260 1260,1530 1530,2340 2370,3090
{} {Frangipani -} itself {}
Frangipani 本身没有被广泛使用，

22
00:00:48,610 --> 00:00:49,600
0,180 180,240 240,360 360,600 600,990
you know it's not widely

23
00:00:49,600 --> 00:00:51,400
0,540 630,900 900,1200 1200,1500 1500,1800
used| or wasn't widely used
|或者没有在[]之外被广泛使用。

24
00:00:51,400 --> 00:00:53,410
0,330 330,420 420,720 720,1230 1410,2010
outside of the [] {}.|
|

25
00:00:53,410 --> 00:00:54,760
0,240 240,360 360,480 480,780 780,1350
And so the {view,to} focus,|
所以今天关注的观点，|

26
00:00:54,880 --> 00:00:56,110
0,450 570,750 750,960 960,1140 1140,1230
{you,know} the things you should
你应该从这篇论文中得到的三个想法，

27
00:00:56,110 --> 00:00:56,890
0,180 180,300 300,360 360,510 510,780
get out of this paper

28
00:00:56,890 --> 00:01:00,910
0,570 840,1620 1680,2520 2550,3540 3540,4020
today are three ideas| and
|这些想法将在未来几周内反复出现。

29
00:01:00,910 --> 00:01:02,380
0,420 420,600 600,990 990,1200 1200,1470
ideas that actually will show

30
00:01:02,380 --> 00:01:03,520
0,210 240,540 540,660 660,990 990,1140
up over and over in

31
00:01:03,520 --> 00:01:04,570
0,90 90,570 570,660 660,840 840,1050
a couple of, next couple

32
00:01:04,570 --> 00:01:05,920
0,60 60,510 750,1200 1200,1260 1260,1350
of weeks.| First of all
|第一，缓存一致性协议，

33
00:01:05,920 --> 00:01:07,900
0,330 330,1080
cache coherence,

34
00:01:08,800 --> 00:01:12,280
0,690 690,810 810,1080 1080,1890
protocols for cache coherence,|
|

35
00:01:13,310 --> 00:01:17,000
0,330 330,840 840,1290 1290,1860
{} second, distributed locking,|
第二，分布式锁，|

36
00:01:23,430 --> 00:01:26,580
0,270 270,540 540,1710 1950,2460 2460,3150
and third, distributed crash recovery.|
第三，分布式崩溃恢复。|

37
00:01:32,830 --> 00:01:33,970
0,270 270,510 510,660 660,900 900,1140
And these are gonna be,
这三个想法将会，

38
00:01:33,970 --> 00:01:35,200
0,210 210,570 570,660 660,810 810,1230
three ideas are gonna be,|
|

39
00:01:35,200 --> 00:01:36,310
0,150 150,600 600,780 780,930 930,1110
as {I,mentioned} show up in
如我所说，会在接下来的几周里出现，

40
00:01:36,310 --> 00:01:37,570
0,480 480,570 570,660 660,840 840,1260
the, in the next couple

41
00:01:37,570 --> 00:01:38,890
0,90 90,360 630,780 780,1260 1260,1320
of weeks,| in particular, we're
|特别是，我们将阅读，

42
00:01:38,890 --> 00:01:40,540
0,120 120,510 540,1020 1050,1530 1530,1650
going to read,| {} {you,know}
|从下周要开始，

43
00:01:40,540 --> 00:01:41,920
0,120 120,360 360,630 630,1080 1080,1380
{} starting next week,| {you,know,two}
|两个[重型]事务系统，

44
00:01:41,920 --> 00:01:43,870
0,150 150,210 210,810 810,1290 1290,1950
sort of heavy-duty transaction systems,|
|

45
00:01:44,140 --> 00:01:47,410
0,750 750,2100 2130,2670 2670,2730 2730,3270
and they build a lot
它们构建于，

46
00:01:47,470 --> 00:01:49,450
0,780 810,1530 1530,1740 1740,1890 1890,1980
on| {} get some of
|获取或使用一些技术，

47
00:01:49,450 --> 00:01:50,440
0,210 210,600 600,660 660,750 750,990
the techniques or to use

48
00:01:50,440 --> 00:01:51,430
0,150 150,270 270,420 420,840 840,990
some of the techniques,| that
|实际上 Frangipani 也在使用的。

49
00:01:51,430 --> 00:01:52,750
0,390 390,510 510,780 780,1080 1080,1320
actually {} {Frangipani -} also

50
00:01:52,750 --> 00:01:53,380
0,510
uses.|
|

51
00:01:53,730 --> 00:01:55,110
0,150 150,540 570,840 840,1170 1170,1380
And so {Frangipani -} {is,sort,of}
所以， Frangipani 是对这三个主题更平和的介绍，

52
00:01:55,110 --> 00:01:57,600
0,240 240,420 420,720 720,1410 1710,2490
a more gentle introduction to

53
00:01:57,630 --> 00:01:59,580
0,300 420,870 900,1380 1380,1800 1800,1950
these three topics,| before we
|在我们谈到重型事务系统之前。

54
00:01:59,580 --> 00:02:01,740
0,210 210,300 300,1140 1140,1560 1560,2160
get to heavy-duty transaction systems.|
|

55
00:02:02,560 --> 00:02:03,820
0,330 570,840 840,990 990,1200 1200,1260
And {} the idea is
Frangipani 本身的想法也是一个有趣的设计，

56
00:02:03,820 --> 00:02:05,230
0,360 360,510 510,870 870,1320 1320,1410
also {Frangipani's -} itself is

57
00:02:05,230 --> 00:02:07,300
0,90 90,420 420,900 1170,1740 1740,2070
an interesting design,| {} from
|从分布式系统角度来看，

58
00:02:07,300 --> 00:02:09,850
0,600 600,960 960,1230 1230,1920 2100,2550
{} distribute system perspective, {}|
|

59
00:02:09,850 --> 00:02:11,050
0,150 150,300 300,900 900,930 930,1200
it is {} a cool
这是一个很酷的系统。

60
00:02:11,050 --> 00:02:13,780
0,450 1020,1500 1500,2040 2250,2490 2490,2730
system.| Let me {} make
|让我来说明这个，

61
00:02:13,780 --> 00:02:16,240
0,210 210,660 660,1320 1350,2010 2100,2460
that point| by {} sort
|通过[]网络文件系统的传统设计，

62
00:02:16,240 --> 00:02:18,430
0,150 150,780 780,1140 1140,1620 1620,2190
of {[],sort,of} the traditional designs

63
00:02:18,430 --> 00:02:20,560
0,330 330,660 660,900 900,1320 1680,2130
for network file system,| so
|所以传统的或最常见的网络文件系统设计，

64
00:02:20,590 --> 00:02:21,920
0,810
traditional

65
00:02:22,860 --> 00:02:24,600
0,570 630,720 720,1020 1020,1440 1440,1740
or the most common network

66
00:02:24,600 --> 00:02:26,010
0,240 240,540 540,990 990,1320 1320,1410
file system design,| since if
|如果考虑 Athena 上的 AFS ，

67
00:02:26,010 --> 00:02:28,230
0,120 120,300 300,630 630,1500 1950,2220
you think about like {

68
00:02:28,230 --> 00:02:30,360
0,510 540,690 690,930 930,1560 1560,2130
-} AFS on Athena,| if
|如果你有一组客户端，

69
00:02:30,510 --> 00:02:31,680
0,750 750,870 870,930 930,1110 1110,1170
you have a set of

70
00:02:31,680 --> 00:02:32,780
0,690
clients,|
|

71
00:02:33,710 --> 00:02:35,030
0,390 390,600 600,840 840,1050 1050,1320
{and,this} is a very simple
这是一个很简单的图，

72
00:02:35,030 --> 00:02:36,500
0,510 1140,1200 1200,1260 1260,1410 1410,1470
picture| of a set of
|一组客户端连接到某个网络，

73
00:02:36,500 --> 00:02:37,940
0,600 600,690 690,810 810,1230 1230,1440
clients you know connected to

74
00:02:37,940 --> 00:02:40,310
0,240 240,930 1440,2040 2040,2100 2100,2370
some network,| represent the network
|表示网络的是一条线，

75
00:02:40,310 --> 00:02:41,570
0,300 300,390 390,660 660,900 900,1260
basically a single {wire -},|
|

76
00:02:41,720 --> 00:02:43,250
0,150 150,990 990,1200 1200,1440 1440,1530
{you,know} sharing a number of
共享多个文件服务器，

77
00:02:43,250 --> 00:02:45,980
0,270 270,870 1890,2160 2160,2490 2490,2730
file servers,| and the file
|然后文件服务器有数据在磁盘上。

78
00:02:45,980 --> 00:02:48,380
0,540 570,810 810,990 990,2040
servers have {data,on} disk.|
|

79
00:02:52,740 --> 00:02:54,870
0,510 510,870 870,1200 1830,1980 1980,2130
And basically all the all
基本上所有的复杂性，

80
00:02:54,870 --> 00:02:57,240
0,60 60,840 1140,2070
the complexity, {}

81
00:02:57,580 --> 00:02:59,020
0,420 420,900 900,1140 1140,1320 1320,1440
{all,the},| okay, I'll get to
|好的，稍后我将详细介绍缓存一致性，

82
00:02:59,020 --> 00:03:01,000
0,480 480,1140 1140,1320 1320,1650 1650,1980
cache coherence in a detail

83
00:03:01,000 --> 00:03:03,580
0,90 90,120 120,450 930,1560 1920,2580
in a second,| {} the,
|设计中的所有复杂性基本上都在这里，

84
00:03:04,060 --> 00:03:05,500
0,150 150,240 240,780 780,900 900,1440
all the complexity in the

85
00:03:05,500 --> 00:03:07,510
0,390 390,480 480,1350 1350,1920 1920,2010
design is basically here,| at
|在文件服务器上，

86
00:03:07,510 --> 00:03:09,790
0,60 60,330 330,780 1560,1920 1920,2280
the file servers,| file servers
|文件服务器实现文件系统操作，

87
00:03:09,790 --> 00:03:10,930
0,540 540,630 630,810 810,900 900,1140
implement you know the file

88
00:03:10,930 --> 00:03:12,970
0,270 270,930 930,1230 1230,1710 1710,2040
system operations,| open close read
|open close read write stat 等东西，

89
00:03:12,970 --> 00:03:14,200
0,420 420,480 480,600 600,1080 1080,1230
write you know stat on

90
00:03:14,200 --> 00:03:17,320
0,390 810,1170 1170,2280 2310,2940 2940,3120
everything,| and they write things
|它们以抗崩溃方式将数据写入磁盘，

91
00:03:17,320 --> 00:03:18,460
0,90 90,450 450,630 630,750 750,1140
to disk in the crash

92
00:03:18,460 --> 00:03:21,370
0,630 870,1560 1560,2100 2100,2460 2760,2910
{} resilient {or,resistant} way,| and
|而客户端很简单，

93
00:03:21,370 --> 00:03:22,330
0,60 60,450 450,540 540,780 780,960
the clients are really sort

94
00:03:22,330 --> 00:03:24,010
0,90 90,510 810,960 960,1440 1500,1680
of dumb or simple,| they
|它们并没有做太多事情，

95
00:03:24,010 --> 00:03:25,150
0,180 180,390 390,540 540,1020 1020,1140
didn't really do much,| {you,know}
|也许像在 AFS 中那样进行一些缓存，

96
00:03:25,150 --> 00:03:26,530
0,420 420,660 660,840 840,1260 1260,1380
perhaps do some caching as

97
00:03:26,530 --> 00:03:28,150
0,120 120,270 270,420 420,1050 1170,1620
they do in AFS, {}|
|

98
00:03:28,150 --> 00:03:29,170
0,210 210,450 450,570 570,840 840,1020
but you know most of
但是大多数都是，

99
00:03:29,170 --> 00:03:31,330
0,420 420,900 930,1170 1170,1830 1830,2160
these is,| they're relaying file
|它们转发正在运行的程序的文件系统操作，

100
00:03:31,330 --> 00:03:33,100
0,270 270,930 930,1170 1170,1620 1620,1770
system operations from client, from

101
00:03:33,100 --> 00:03:34,780
0,510 510,630 630,720 720,1200 1470,1680
programs that are running,| like
|比如 Vi 在客户端 1 上，

102
00:03:34,780 --> 00:03:36,460
0,360 360,540 540,1050 1050,1560 1560,1680
whatever {Vi -} on {}

103
00:03:36,460 --> 00:03:37,510
0,270 270,600 600,690 690,810 810,1050
client 1,| and it does
|它执行 open close ，

104
00:03:37,510 --> 00:03:38,980
0,270 270,780 990,1170 1170,1410 1410,1470
open close,| and most of
|而客户端所做的大部分工作都是，

105
00:03:38,980 --> 00:03:40,180
0,90 90,150 150,450 450,720 720,1200
what the client does| relaying
|将这些操作转发到文件服务器。

106
00:03:40,180 --> 00:03:41,800
0,180 180,690 690,810 810,1050 1050,1620
those operations to file servers.|
|

107
00:03:42,510 --> 00:03:43,500
0,180 180,450 450,750 750,900 900,990
And one reason that the
这设计受欢迎的一个原因是，

108
00:03:43,500 --> 00:03:45,630
0,450 450,780 810,1440 1440,1650 1650,2130
design is popular is,| because
|因为，从安全的角度来说，

109
00:03:45,630 --> 00:03:46,950
0,210 210,450 450,870 900,1140 1140,1320
you know like [] from

110
00:03:46,950 --> 00:03:48,780
0,60 60,420 420,1110 1200,1650 1650,1830
{} security perspective,| {} it
|这是一个很好的设计，

111
00:03:48,780 --> 00:03:49,800
0,90 90,150 150,420 420,780 780,1020
is a nice design,| because
|因为大多数文件服务器都是可信的，

112
00:03:49,800 --> 00:03:52,170
0,300 300,600 960,1500 1650,2010 2010,2370
most of the file servers

113
00:03:52,170 --> 00:03:53,550
0,180 180,270 270,480 480,1110 1230,1380
have to be trusted,| but
|但客户端不一定是可信的。

114
00:03:53,550 --> 00:03:54,420
0,60 60,420 420,660 660,810 810,870
the clients don't have to

115
00:03:54,420 --> 00:03:55,380
0,120 120,630
be trusted.|
|

116
00:03:56,760 --> 00:03:57,690
0,240 240,570 570,630 630,690 690,930
And certainly in a setting
当然，在 MIT 的环境中，

117
00:03:57,690 --> 00:03:59,370
0,180 180,720 720,990 990,1260 1260,1680
like MIT,| where like machines
|机器是公开的，

118
00:03:59,370 --> 00:04:00,360
0,90 90,240 240,360 360,900 900,990
are just in public,| and
|谁知道是谁在上面安装了什么样的软件，

119
00:04:00,360 --> 00:04:01,620
0,240 240,540 540,780 780,1110 1110,1260
who knows who installs what

120
00:04:01,620 --> 00:04:02,550
0,150 150,210 210,600 600,750 750,930
kind of software on it,|
|

121
00:04:02,550 --> 00:04:04,590
0,450 720,1020 1020,1290 1290,1410 1410,2040
you know that is a
那是一个不错的性质。

122
00:04:04,590 --> 00:04:07,350
0,420 420,960 1350,2370 2370,2490 2490,2760
nice property.| Frangipani { -}
|Frangipani 有一个非常不同的设计，

123
00:04:07,350 --> 00:04:08,700
0,120 120,180 180,630 630,930 930,1350
has a very different design,|
|

124
00:04:08,910 --> 00:04:10,860
0,300 300,540 540,810 810,1500 1500,1950
a much more decentralized design.|
一个更分散的设计。|

125
00:04:14,300 --> 00:04:15,440
0,600 600,810 810,870 870,1080 1080,1140
{} And in {Frangipani -
在 Frangipani 中有很多文件服务器，

126
00:04:15,440 --> 00:04:16,520
0,300 300,690 690,780 780,990 990,1080
-} actually a lot of

127
00:04:16,520 --> 00:04:19,220
0,360 360,660 660,1260 1500,2490 2490,2700
the file server,| {} it's
|它没有真正的文件服务器，

128
00:04:19,220 --> 00:04:20,570
0,450 450,660 660,930 930,1170 1170,1350
really there's actually no real

129
00:04:20,570 --> 00:04:21,680
0,270 270,660 660,750 750,990 990,1110
file server| in this {}
|在字面意思上，

130
00:04:21,680 --> 00:04:23,180
0,300 300,510 510,630 630,1200 1290,1500
literally {} the word, {}|
|

131
00:04:23,180 --> 00:04:25,190
0,330 480,870 900,1020 1020,1590 1590,2010
but the the clients basically
而是客户端本身运行文件服务器代码。

132
00:04:25,190 --> 00:04:27,380
0,690 1140,1620 1620,1710 1710,1950 1950,2190
implement run the file server

133
00:04:27,380 --> 00:04:28,360
0,210 210,810
code itself.|
|

134
00:04:28,790 --> 00:04:30,200
0,240 240,540 540,750 750,930 930,1410
So let's say {you,know} two
假设有两个客户端，

135
00:04:30,440 --> 00:04:32,360
0,810 1050,1530 1530,1770 1770,1830 1830,1920
clients| and most of the
|大多数文件系统代码本身，

136
00:04:32,360 --> 00:04:34,430
0,240 240,1050 1080,1410 1410,1890 1890,2070
file system code itself,| like
|比如有索引节点管理器，

137
00:04:34,430 --> 00:04:35,720
0,120 120,270 270,420 420,930 930,1290
the thing that actually has

138
00:04:35,720 --> 00:04:37,220
0,240 240,420 420,840 840,990 990,1500
{inode -} managers,| {inode -}
|inode 更新文件，创建目录，

139
00:04:37,250 --> 00:04:39,020
0,270 270,840 840,930 930,1170 1170,1770
{} updates you know files,

140
00:04:39,110 --> 00:04:40,880
0,420 420,1020 1140,1290 1290,1380 1380,1770
creates directories,| all the code
|所有代码不是在文件服务器上，

141
00:04:40,880 --> 00:04:42,080
0,270 270,360 360,630 630,810 810,1200
instead of living on the

142
00:04:42,110 --> 00:04:43,520
0,240 240,810 840,1170 1170,1290 1290,1410
file server,| looks like it
|而是在客户端上，

143
00:04:43,520 --> 00:04:45,060
0,330 330,510 510,750 750,1380
lives on the clients,|
|

144
00:04:45,630 --> 00:04:46,950
0,420 570,750 750,960 960,1170 1170,1320
{you,know} the only thing that
文件服务器共享的唯一东西是一个大的虚拟磁盘。

145
00:04:46,950 --> 00:04:49,710
0,570 690,1440 1740,2220 2220,2490 2490,2760
really the the file server

146
00:04:49,710 --> 00:04:52,530
0,630 660,1440 1440,1620 1620,2130 2160,2820
share is a big virtual

147
00:04:52,530 --> 00:04:53,500
0,510
disk.|
|

148
00:04:53,690 --> 00:04:54,480
0,180

149
00:04:58,730 --> 00:04:59,930
0,150 150,240 240,390 390,1020 1020,1200
And if you will,| {you,know,may}
如果你愿意，|在你的脑海里中有一个图像，

150
00:04:59,930 --> 00:05:01,100
0,120 120,180 180,390 390,1050 1050,1170
be a good image you

151
00:05:01,100 --> 00:05:02,090
0,180 180,270 270,450 450,900 900,990
have in your head| or
|或者脑海中有一个概念性图像是，

152
00:05:02,090 --> 00:05:03,140
0,150 150,570 570,810 810,900 900,1050
a conceptual image you have

153
00:05:03,140 --> 00:05:03,860
0,90 90,210 210,420 420,600 600,720
in your head is that,|
|

154
00:05:03,860 --> 00:05:05,270
0,90 90,330 330,600 600,750 870,1410
the virtual disk is {basically,like}
虚拟磁盘就像一个大型固态硬盘驱动器，

155
00:05:05,270 --> 00:05:07,910
0,240 240,660 660,1230 1230,1830 1980,2640
a big SSD drive, {}|
|

156
00:05:07,910 --> 00:05:09,500
0,690 690,810 810,900 900,1170 1170,1590
and so the file servers,|
所以文件服务器，|

157
00:05:09,500 --> 00:05:11,720
0,180 180,540 540,990 990,1530 1530,2220
there's basically share one SSD,|
共享一个固态硬盘，|

158
00:05:11,720 --> 00:05:14,390
0,90 90,870 1110,1500 1500,2040 2190,2670
you know one disk {}
彼此共享一个磁盘，|

159
00:05:14,390 --> 00:05:15,950
0,240 240,390 390,750 930,1440 1440,1560
with each other,| now of
|当然在内部，

160
00:05:15,950 --> 00:05:18,110
0,210 210,870 870,1230 1260,1830 1830,2160
course internally,| this virtual disk
|这个虚拟磁盘是使用一个名为 Petal 的系统实现的，

161
00:05:18,110 --> 00:05:19,670
0,360 360,990 990,1260 1260,1290 1290,1560
is implemented using a system

162
00:05:19,670 --> 00:05:21,470
0,180 180,720 1080,1530 1530,1650 1650,1800
called Petal,| and you know
|是由许多机器组成的，

163
00:05:21,470 --> 00:05:22,880
0,360 360,660 660,810 810,1140 1140,1410
consists actually of {} many

164
00:05:22,880 --> 00:05:26,180
0,930 1230,2190 2460,2880 2880,3180 3180,3300
machines,| {} and but you
|但是机器复制磁盘块，

165
00:05:26,180 --> 00:05:27,680
0,120 120,480 480,1050 1050,1140 1140,1500
know you know the machine

166
00:05:27,680 --> 00:05:29,090
0,540 540,600 600,720 720,930 930,1410
replicate you know disk blocks,|
|

167
00:05:29,090 --> 00:05:30,860
0,450 450,570 570,960 960,1620 1620,1770
there are Paxos internally to
内部有 Paxos ，用来确保，

168
00:05:30,860 --> 00:05:32,450
0,150 150,450 450,660 660,1440 1500,1590
make sure that,| like you
|操作可以按正确的顺序应用，

169
00:05:32,450 --> 00:05:33,680
0,240 240,750 750,870 870,1140 1140,1230
know opertations can apply {}

170
00:05:33,680 --> 00:05:34,970
0,60 60,150 150,390 390,930 1080,1290
in the right order| and
|诸如此类的事情，

171
00:05:34,970 --> 00:05:35,780
0,120 120,210 210,330 330,420 420,810
all that kind of stuff,|
|

172
00:05:35,780 --> 00:05:37,640
0,210 210,450 450,690 690,1170 1170,1860
but from the outside perspective,|
但从外部来看，|

173
00:05:37,790 --> 00:05:38,660
0,120 120,180 180,330 330,750 750,870
you know the interface is
接口是 read 块，或 write 块，

174
00:05:38,660 --> 00:05:40,400
0,540 570,1020 1020,1170 1170,1260 1260,1740
really {} {read -} block,

175
00:05:40,700 --> 00:05:42,180
0,420 420,720 720,1200
or write block,|
|

176
00:05:42,420 --> 00:05:43,140
0,210 210,300 300,390 390,570 570,720
and so it just looks
所以它看起来就像一个普通的磁盘。

177
00:05:43,140 --> 00:05:44,540
0,150 150,240 240,720 720,1170
like an ordinary disk.|
|

178
00:05:45,150 --> 00:05:46,920
0,630 750,1200 1200,1410 1410,1620 1620,1770
And {} as over those
这个设计有趣的是，

179
00:05:46,920 --> 00:05:48,000
0,330 330,420 420,750 750,870 870,1080
interesting in this you know

180
00:05:48,000 --> 00:05:49,650
0,420 420,600 600,1110 1110,1200 1200,1650
design,| {you,know} contract to {design's
|设计协议，

181
00:05:49,650 --> 00:05:50,610
0,180 240,630 630,690 690,840 840,960
-},| actually a lot of
|这个设计中的许多复杂性都在客户端。

182
00:05:50,610 --> 00:05:52,500
0,780 810,1050 1050,1230 1230,1740 1740,1890
complexity in this design is

183
00:05:52,500 --> 00:05:55,180
0,180 180,390 390,810 810,1200
on the client side.|
|

184
00:05:56,100 --> 00:05:57,360
0,540 540,690 690,750 750,960 960,1260
And you know one reason
你喜欢这个的一个原因，

185
00:05:57,360 --> 00:05:58,350
0,90 90,210 210,420 420,810 810,990
that you like that,| or
|或者为什么这样，

186
00:05:58,350 --> 00:05:59,940
0,510 840,1140 1140,1380 1380,1470 1470,1590
why is that,| you know
|你可以通过增加工作站数量来扩展文件系统，

187
00:05:59,940 --> 00:06:01,560
0,180 180,300 300,990 990,1350 1350,1620
you can grow the file

188
00:06:01,560 --> 00:06:03,480
0,510 810,1170 1170,1560 1560,1680 1680,1920
system {} with the number

189
00:06:03,480 --> 00:06:04,740
0,60 60,630 630,780 780,870 870,1260
of workstations,| so if you
|所以，如果你增加客户端数量，

190
00:06:04,740 --> 00:06:06,210
0,330 330,450 450,720 720,810 810,1470
increase the number of clients,|
|

191
00:06:06,360 --> 00:06:07,890
0,390 390,750 750,930 930,1170 1170,1530
you basically get more CPU
你可以获得更多的 CPU 能力，

192
00:06:07,890 --> 00:06:08,850
0,360 360,600 600,660 660,780 780,960
power,| because you get more
|因为你得到了更多的客户端，

193
00:06:08,850 --> 00:06:10,020
0,510 510,780 780,840 840,990 990,1170
clients,| and you know each
|每个客户端可以在自己的文件系统上运行。

194
00:06:10,020 --> 00:06:10,980
0,90 90,330 330,660 660,780 780,960
of the clients can run

195
00:06:10,980 --> 00:06:12,060
0,210 210,330 330,480 480,750 750,1080
on its own file system.|
|

196
00:06:12,590 --> 00:06:13,940
0,180 180,720 840,990 990,1260 1260,1350
And so a lot of
所以，很多非常繁重的计算

197
00:06:13,940 --> 00:06:15,710
0,360 360,630 630,990 990,1530 1530,1770
the really heavy-duty computation| can
|都可以在客户端机器上完成，

198
00:06:15,710 --> 00:06:16,370
0,180 180,270 270,480 480,570 570,660
all be done on the

199
00:06:16,370 --> 00:06:18,320
0,240 240,750 900,1020 1020,1260 1260,1950
client machines| and doesn't involve
|根本不涉及任何文件服务器，

200
00:06:18,350 --> 00:06:19,610
0,360 360,570 570,870 870,960 960,1260
any file server at all,|
|

201
00:06:19,760 --> 00:06:20,720
0,150 150,270 270,450 450,780 780,960
and it is true,| that
这是真的，|在左边，

202
00:06:20,720 --> 00:06:21,980
0,480 480,690 690,930 930,1170 1170,1260
in the left side,| the
|传统的网络文件系统设计通常是这种情况，

203
00:06:21,980 --> 00:06:23,480
0,360 360,780 780,1050 1050,1260 1260,1500
network, traditional network file system

204
00:06:23,480 --> 00:06:25,220
0,630 930,1080 1080,1290 1290,1380 1380,1740
design is often the case,|
|

205
00:06:25,220 --> 00:06:26,660
0,210 210,300 300,540 540,960 990,1440
that you know the performance
性能瓶颈出现在文件服务器中，

206
00:06:26,660 --> 00:06:28,790
0,570 570,1170 1170,1290 1290,1470 1470,2130
bottlenecks arise you know in

207
00:06:29,180 --> 00:06:31,490
0,660 1170,1470 1470,1560 1560,1770 1770,2310
the, in the file server,|
|

208
00:06:31,490 --> 00:06:32,540
0,300 300,390 390,630 630,720 720,1050
when the number of clients
当客户端数量变得太大时，

209
00:06:32,540 --> 00:06:34,760
0,510 510,1200 1230,1560 1560,1680 1680,2220
actually {} becomes too large,|
|

210
00:06:34,790 --> 00:06:35,870
0,330 330,600 600,660 660,840 840,1080
and often in that case
通常在这种情况下，

211
00:06:35,870 --> 00:06:36,920
0,90 90,570 600,750 750,990 990,1050
for example,| we split the
|我们将文件系统拆分到不同的文件服务器中。

212
00:06:36,920 --> 00:06:38,870
0,270 270,810 840,1410 1410,1680 1680,1950
file system across different files

213
00:06:38,870 --> 00:06:39,540
0,180 180,540
{servers -}.|
|

214
00:06:40,900 --> 00:06:41,680
0,270 270,330 330,450 450,630 630,780
{Okay - -}, that's sort
好吧，这是一种，

215
00:06:41,680 --> 00:06:43,510
0,120 120,600 930,1260 1260,1590 1650,1830
of the,| {} so from
|所以，从我们的角度来看，

216
00:06:43,510 --> 00:06:44,860
0,150 150,660 660,780 780,1170 1170,1350
our perspective,| at least from
|至少从分布式系统设计来看，

217
00:06:44,860 --> 00:06:46,630
0,660 690,1080 1080,1380 1380,1530 1530,1770
a distributed systems {design -

218
00:06:46,630 --> 00:06:48,160
0,390 600,960 960,1050 1050,1440 1440,1530
-},| {Frangipani - -} is
|Frangipani 很有趣，

219
00:06:48,160 --> 00:06:49,480
0,360 360,630 630,930 930,1200 1200,1320
interesting,| because it's much more
|因为它更加分散，

220
00:06:49,480 --> 00:06:50,890
0,930 930,1080 1080,1230 1230,1320 1320,1410
decentralized,| than sort of the
|比起传统的网络文件系统设计。

221
00:06:50,890 --> 00:06:53,170
0,780 780,1440 1440,1650 1650,1920 1920,2280
traditional network file system design.|
|

222
00:06:56,190 --> 00:06:58,920
0,300 570,750 750,1500 1530,2370 2400,2730
And the reason they wanted
他们想要探索这种设计的原因

223
00:06:58,920 --> 00:07:01,260
0,60 60,840 870,1470 1470,1770 1770,2340
to explore {} this design|
|

224
00:07:01,350 --> 00:07:02,100
0,120 120,180 180,390 390,480 480,750
has a lot to do
与用例有很大关系，

225
00:07:02,100 --> 00:07:03,420
0,180 180,240 240,510 510,840 840,1320
with the use case,| that
|他们想象的或他们的目标，

226
00:07:03,420 --> 00:07:04,830
0,180 180,690 690,990 990,1320 1320,1410
they imagine or that they

227
00:07:04,830 --> 00:07:05,940
0,150 150,570 570,840 840,960 960,1110
were targeting,| and I want
|我想说一点关于用例的事情，

228
00:07:05,940 --> 00:07:06,480
0,60 60,180 180,240 240,420 420,540
to say a little bit

229
00:07:06,480 --> 00:07:07,620
0,210 210,300 300,510 510,780 780,1140
about the use case,| because,
|因为，在电子邮件中有很多与此相关的问题。

230
00:07:07,800 --> 00:07:08,640
0,450 450,570 570,660 660,690 690,840
{} there were a lot

231
00:07:08,640 --> 00:07:09,810
0,60 60,480 480,810 810,870 870,1170
of questions related to that

232
00:07:09,810 --> 00:07:11,800
0,300 300,630 630,1020 1020,1320
in {} email.| So,
|那么，它的用例是什么，

233
00:07:13,340 --> 00:07:14,060
0,150 150,330 330,420 420,510 510,720
so what is the use

234
00:07:14,060 --> 00:07:16,010
0,510 930,1230 1230,1410 1410,1620 1620,1950
case,| {} the use case
|用例是，

235
00:07:16,010 --> 00:07:18,380
0,690 720,2010 2010,2070 2070,2280 2280,2370
is basically| a number of
|一些研究人员和工程师

236
00:07:18,380 --> 00:07:20,460
0,660 840,960 960,1830
researchers and engineers|
|

237
00:07:24,370 --> 00:07:26,880
0,630 630,720 720,840 840,1890
{} you know compiling,
编译、编辑他们的程序或编写文档。

238
00:07:29,490 --> 00:07:32,580
0,810 810,1560 1740,2190 2190,2880 2880,3090
compiling editing their programs or

239
00:07:32,580 --> 00:07:33,900
0,270 270,1080
writing documents.|
|

240
00:07:39,710 --> 00:07:41,360
0,210 210,360 360,600 600,1020 1020,1650
So it's really designed {you,know}
它的设计来自著名研究实验室[]的论文，

241
00:07:41,390 --> 00:07:43,520
0,450 450,720 720,1470 1500,1830 1830,2130
paper from a famous research

242
00:07:43,520 --> 00:07:45,980
0,390 390,1410 1410,1560 1560,2070 2070,2460
{lab -} {[] - -},|
|

243
00:07:46,430 --> 00:07:48,920
0,720 750,1170 1170,1800 1830,2130 2130,2490
and [] like tens of,
[]研究人员有 50 到 100 个，

244
00:07:48,950 --> 00:07:50,390
0,390 390,750 750,1080 1080,1350 1350,1440
{} researcher like 50 to

245
00:07:50,390 --> 00:07:52,310
0,60 60,540 870,1530 1530,1680 1680,1920
{} 100,| and {you,know} really
|他们所做的是，

246
00:07:52,310 --> 00:07:53,480
0,180 180,360 360,660 660,750 750,1170
what they're doing is| designing
|为他们的用例设计一个文件系统，

247
00:07:53,480 --> 00:07:55,040
0,90 90,360 360,1110 1110,1290 1290,1560
a file system for their

248
00:07:55,040 --> 00:07:58,520
0,210 210,630 1470,1680 1680,2580 2580,3480
use case,| so everybody is
|所以每个人都是可信的，

249
00:07:58,520 --> 00:08:00,650
0,630 840,1260 1260,1530 1530,1650 1650,2130
trusted,| {} all the machines
|所有机器都是可信的，

250
00:08:00,650 --> 00:08:01,700
0,60 60,540 540,630 630,720 720,1050
are trusted,| all the software
|所有运行的软件都是可信的，

251
00:08:01,700 --> 00:08:03,500
0,270 270,1140 1470,1620 1620,1710 1710,1800
running trusted,| and so the
|所以，安全方面的事情不是一个问题，

252
00:08:03,500 --> 00:08:04,730
0,570 570,780 780,870 870,1080 1080,1230
security side of things is

253
00:08:04,730 --> 00:08:06,050
0,420 420,600 600,690 690,990 990,1320
really not an issue for

254
00:08:06,590 --> 00:08:08,600
0,720 720,1080 1080,1380 1380,1530 1530,2010
that,| all the these researchers
|所有这些研究人员都是重负荷计算机用户，

255
00:08:08,600 --> 00:08:10,730
0,30 30,930 930,930 930,1800 1800,2130
are heavy-duty {} {} computer

256
00:08:10,730 --> 00:08:12,800
0,510 840,1470 1470,1530 1530,1860 1860,2070
users,| and you know and
|所以他们想要，

257
00:08:12,800 --> 00:08:13,790
0,90 90,180 180,360 360,750 780,990
so they want to,| but
|但大多数情况下，他们在自己的私人文件上工作，

258
00:08:13,790 --> 00:08:14,990
0,540 540,690 690,960 960,1050 1050,1200
mostly, they're working on their

259
00:08:14,990 --> 00:08:16,400
0,390 390,720 720,1110 1110,1230 1230,1410
own private files,| and they're
|他们编写自己的程序，

260
00:08:16,400 --> 00:08:17,720
0,270 270,420 420,570 570,1170 1170,1320
writing their own programs,| they're
|他们编写自己的文档，

261
00:08:17,720 --> 00:08:20,390
0,330 330,900 900,990 990,1680 2070,2670
writing their own documents, {}|
|

262
00:08:20,390 --> 00:08:21,620
0,240 240,540 660,1020 1020,1170 1170,1230
and so [] want to
所以，[]希望与高性能文件系统的文件进行交互。

263
00:08:21,620 --> 00:08:22,850
0,390 390,510 510,600 600,1020 1020,1230
interact with the files with

264
00:08:22,850 --> 00:08:24,440
0,210 210,630 630,870 870,1320
high performance file system.|
|

265
00:08:24,780 --> 00:08:26,550
0,540 780,1260 1260,1320 1320,1440 1440,1770
Of course, you know they
当然，他们可能会分享，

266
00:08:26,550 --> 00:08:28,620
0,240 240,780 870,1590 1590,1920 1920,2070
might share,| otherwise sharing would
|否则，分享就不会很有趣，

267
00:08:28,620 --> 00:08:32,820
0,210 210,720 840,1530 3930,4110 4110,4200
not be interesting,| so they
|它们可能分享文件和目录，

268
00:08:32,820 --> 00:08:34,410
0,330 330,780 780,1050 1050,1500 1500,1590
both potentially share files and

269
00:08:34,410 --> 00:08:35,720
0,690
directories,|
|

270
00:08:36,030 --> 00:08:37,500
0,570 630,750 750,990 990,1140 1140,1470
and it shows up in
它以两种方式表现出来，

271
00:08:37,500 --> 00:08:39,030
0,180 180,840 1140,1290 1290,1410 1410,1530
two ways,| you know they
|他们可能会一起工作，

272
00:08:39,030 --> 00:08:40,680
0,270 270,570 570,930 930,1350 1350,1650
may work together,| collaborate together
|一起合作写一篇论文，

273
00:08:40,680 --> 00:08:42,150
0,300 300,540 540,600 600,990 990,1470
around writing a paper,| like
|像我们今天读到的论文，

274
00:08:42,210 --> 00:08:43,590
0,330 330,480 480,690 690,930 930,1380
paper that we're reading today,|
|

275
00:08:43,890 --> 00:08:45,720
0,390 390,540 540,1050 1050,1290 1290,1830
{} and so {} they
所以他们希望能够访问共享文件，

276
00:08:45,720 --> 00:08:46,950
0,180 180,300 300,660 660,900 900,1230
want {} access to a

277
00:08:46,980 --> 00:08:49,140
0,420 420,1140 1260,1530 1530,1770 1770,2160
shared files| for the directory
|对于保存特定论文的目录，

278
00:08:49,140 --> 00:08:50,520
0,120 120,390 390,510 510,870 870,1380
that holds that particular paper,|
|

279
00:08:50,820 --> 00:08:52,890
0,570 570,840 840,1170 1170,1800 1800,2070
{} and so this user
所以用户到用户的共享。

280
00:08:52,890 --> 00:08:54,580
0,90 90,390 390,900
to user sharing.|
|

281
00:08:57,770 --> 00:08:58,520
0,150 150,270 270,420 420,480 480,750
And then there's a second
然后还有第二种形式的共享，

282
00:08:58,520 --> 00:08:59,570
0,210 210,270 270,720 720,960 960,1050
form of sharing,| like the
|比如同一用户可能登录到多个工作站，

283
00:08:59,570 --> 00:09:00,860
0,270 270,600 600,810 810,1080 1080,1290
same user might {login,to -}

284
00:09:00,860 --> 00:09:02,560
0,360 360,1230
multiple workstations,|
|

285
00:09:10,740 --> 00:09:12,440
0,120 120,240 240,600 600,1260
more than one workstation,|
一个以上的工作站，|

286
00:09:12,840 --> 00:09:14,340
0,270 270,420 420,810 810,1350 1350,1500
so again whatever,| user one
所以再说一次，|其中一个研究人员去了公共图书馆或他们的图书馆，

287
00:09:14,340 --> 00:09:15,090
0,90 90,180 180,480 480,660 660,750
of the researchers goes to

288
00:09:15,090 --> 00:09:16,860
0,90 90,360 360,780 780,900 900,1770
the public library of []

289
00:09:16,860 --> 00:09:18,300
0,360 390,750 750,1170 1170,1320 1320,1440
or their library,| and the
|[]的公共工作站，

290
00:09:18,300 --> 00:09:20,070
0,270 270,690 750,1050 1050,1620 1620,1770
{[] -} public workstation with

291
00:09:20,070 --> 00:09:21,450
0,570 930,1050 1050,1110 1110,1290 1290,1380
[],| and {} wants to
|也希望能够从那个计算机读取或写入他们的文件。

292
00:09:21,450 --> 00:09:22,050
0,120 120,270 270,360 360,540 540,600
be able to read or

293
00:09:22,050 --> 00:09:23,370
0,270 270,630 630,780 780,1050 1050,1320
write {} their files from

294
00:09:23,730 --> 00:09:24,700
0,210 210,480 480,690
that machine too.|
|

295
00:09:25,000 --> 00:09:26,260
0,330 330,540 540,600 600,810 810,1260
So that's {} use case,|
这就是用例，|

296
00:09:26,710 --> 00:09:28,840
0,540 690,1110 1110,1590 1590,1860 1860,2130
{} and in this use
在这个用例中，有许多设计含义，

297
00:09:28,840 --> 00:09:29,890
0,270 270,480 480,660 660,960 960,1050
case has a number of

298
00:09:29,890 --> 00:09:33,280
0,780 900,1860 1860,2790
design {} implications,|
|

299
00:09:33,480 --> 00:09:35,010
0,480 510,630 630,750 750,1140 1140,1530
or you know design choices
或者由用例驱动的设计选择。

300
00:09:35,010 --> 00:09:36,810
0,150 150,240 240,1050 1080,1680 1680,1800
that were motivated by {use

301
00:09:36,810 --> 00:09:38,900
0,270 270,810
-} case.|
|

302
00:09:40,180 --> 00:09:42,220
0,300 300,450 450,990 1020,1560 1620,2040
{} And so the one
所以，主要的一个，

303
00:09:42,220 --> 00:09:43,990
0,90 90,180 180,840 840,1380 1470,1770
of the primary ones, {}|
|

304
00:09:43,990 --> 00:09:45,340
0,210 210,330 330,840 840,990 990,1350
that was motivated by this
由这个用例驱动的就是缓存。

305
00:09:45,340 --> 00:09:47,160
0,420 420,990 990,1470
use {case,is} caching.|
|

306
00:09:51,560 --> 00:09:53,330
0,180 180,510 510,600 600,1230 1230,1770
So instead of leaving the
所以，不是将数据全部保留在 Petal 中，

307
00:09:53,360 --> 00:09:54,470
0,300 300,450 450,780 780,990 990,1110
data for example all in

308
00:09:54,470 --> 00:09:55,460
0,390 390,510 510,750 750,930 930,990
Petal| and every read or
|并且每个读或写操作都要经过 Petal ，

309
00:09:55,460 --> 00:09:56,990
0,240 240,690 690,900 900,1020 1020,1530
write operation goes through Petal,|
|

310
00:09:57,110 --> 00:09:58,220
0,360 360,450 450,660 660,720 720,1110
{} they want to arrange
他们想要安排，

311
00:09:58,220 --> 00:09:59,450
0,180 180,300 300,390 390,870 870,1230
it,| so the mostly [actually]
|所以大多数发生在工作站上，

312
00:09:59,450 --> 00:10:01,160
0,390 390,690 690,750 750,810 810,1710
actually happens in the workstations,|
|

313
00:10:01,430 --> 00:10:03,200
0,180 180,390 390,900 900,1020 1020,1770
and so that the researchers,|
所以研究人员，|

314
00:10:03,440 --> 00:10:04,550
0,210 210,360 360,660 660,990 990,1110
since they're mostly working on
因为他们主要工作在自己的私人文件上，

315
00:10:04,550 --> 00:10:05,930
0,150 150,270 270,630 630,1170 1170,1380
their own private files,| it
|这似乎很有道理，

316
00:10:05,930 --> 00:10:06,650
0,150 150,390 390,510 510,570 570,720
seems to make a lot

317
00:10:06,650 --> 00:10:07,430
0,90 90,450 450,570 570,720 720,780
of sense,| they're sort of
|它们在本地工作站上缓存数据，

318
00:10:07,430 --> 00:10:08,780
0,450 450,720 720,1140 1140,1260 1260,1350
{cache,the} data locally on the

319
00:10:08,780 --> 00:10:10,880
0,810 1170,1470 1470,1860 1860,2010 2010,2100
workstation,| {} then as you
|然后，当读取或写入文件时，

320
00:10:10,880 --> 00:10:12,050
0,180 180,270 270,480 480,900 900,1170
read or write files,| there's
|基本上不需要网络传输，

321
00:10:12,050 --> 00:10:13,550
0,300 300,630 630,960 960,1320 1320,1500
basically no network traffic really

322
00:10:13,550 --> 00:10:15,830
0,840 1140,1740 1740,2070 2070,2160 2160,2280
necessary,| {} and you can
|你可以以高性能进行写入。

323
00:10:15,830 --> 00:10:17,630
0,270 420,720 750,1470 1470,1620 1620,1800
sort of write at high

324
00:10:17,630 --> 00:10:20,300
0,750 1050,1560 1560,1890 1890,2250 2250,2670
performance.| And one reason, one
|他们避免传输到 Petal 的一种方法，

325
00:10:20,300 --> 00:10:21,980
0,270 270,450 450,1020 1020,1440 1440,1680
way they avoid having a

326
00:10:21,980 --> 00:10:23,570
0,180 180,330 330,780 780,1020 1020,1590
lot of traffic to Petal|
|

327
00:10:23,690 --> 00:10:24,590
0,420 420,510 510,630 630,690 690,900
is to have a write
是使用回写式缓存而不是直写式，

328
00:10:24,590 --> 00:10:28,070
0,360 360,1020 2700,3090 3090,3180 3180,3480
{back-cache -} instead of {write-through

329
00:10:28,070 --> 00:10:30,140
0,600 660,990 990,1230 1230,1740 1740,2070
-},| so if operations happen
|所以如果操作发生留在缓存中，

330
00:10:30,140 --> 00:10:30,980
0,270 270,450 450,570 570,780 780,840
actually { -} stay in

331
00:10:30,980 --> 00:10:31,910
0,90 90,510 510,660 660,750 750,930
the cache,| and at some
|在后来的某个时候，他们逐渐传输到 Petal ，

332
00:10:31,910 --> 00:10:34,010
0,240 240,600 600,720 720,1380 1650,2100
point later, they percolated to

333
00:10:34,010 --> 00:10:34,880
0,330 330,420 420,570 570,690 690,870
Petal,| as {} we'll see
|我们稍后将会看到。

334
00:10:34,880 --> 00:10:37,940
0,90 90,150 150,480 1590,2190
in a second. {}|
|

335
00:10:38,180 --> 00:10:40,100
0,600 720,1230 1230,1500 1500,1650 1650,1920
So, combine that,| like even
所以，将它们结合起来，|即使它们主要是，

336
00:10:40,100 --> 00:10:41,690
0,360 360,780 780,1350 1350,1470 1470,1590
though they're mostly,| you know
|工作负载是私有的，

337
00:10:41,690 --> 00:10:42,470
0,420 420,480 480,600 600,660 660,780
workloads are going to be

338
00:10:42,470 --> 00:10:44,000
0,210 210,300 300,870 990,1230 1230,1530
used for private,| {} where
|他们没有共享的地方，

339
00:10:44,000 --> 00:10:45,650
0,360 360,540 540,840 840,1350 1350,1650
they're not sharing going on,|
|

340
00:10:45,770 --> 00:10:46,880
0,90 90,300 300,750 750,930 930,1110
{or -} {in,the,case} they do
或者他们确实共享了，

341
00:10:46,880 --> 00:10:48,110
0,570 720,900 900,1020 1020,1170 1170,1230
share,| {} they want to
|他们想要有很强的一致性，

342
00:10:48,110 --> 00:10:50,000
0,510 540,900 900,1650
have strong consistency,|
|

343
00:10:50,480 --> 00:10:52,760
0,450 450,810 810,1230 1230,1410 1410,2280
or sometimes called {you,know} coherence.|
或者有时被称为连贯性。|

344
00:11:00,870 --> 00:11:02,940
0,810 810,1170 1170,1470 1470,1620 1620,2070
{} And so the meaning,|
所以它的意思是，|

345
00:11:02,940 --> 00:11:06,090
0,270 270,960 960,1590 1590,2370 2670,3150
for example, if {} one
例如，如果一个用户写入文件，

346
00:11:06,090 --> 00:11:07,590
0,450 450,690 690,780 780,1260 1260,1500
user writes a file,| then
|然后另一个用户，许多工作站读取这个文件，

347
00:11:07,590 --> 00:11:09,150
0,690 690,1050 1050,1380 1380,1410 1410,1560
{} another user, a lot

348
00:11:09,150 --> 00:11:10,830
0,90 90,330 330,870 1110,1590 1590,1680
of {workstation -} reads the

349
00:11:10,830 --> 00:11:12,720
0,540 540,840 840,1290 1290,1530 1530,1890
file,| and [] that user
|那个用户会看到改动，

350
00:11:12,720 --> 00:11:15,090
0,270 270,690 690,1050 1050,1650 1650,2370
actually saw the changes,| that
|其他工作站，其他用户所做的，

351
00:11:15,090 --> 00:11:16,140
0,120 120,300 300,810 810,870 870,1050
the other workstation the other

352
00:11:16,140 --> 00:11:18,360
0,300 300,510 510,900 1530,2040 2040,2220
user has made,| {} and
|所以，他们想要强一致性。

353
00:11:18,360 --> 00:11:20,310
0,210 210,360 360,750 750,1320 1320,1950
so they want {strong -}

354
00:11:20,310 --> 00:11:21,100
0,660
consistency.|
|

355
00:11:22,360 --> 00:11:23,980
0,600 750,930 930,1320 1320,1500 1500,1620
{} So, those are the
所以，这是推动这一设计的两个设计选择，

356
00:11:23,980 --> 00:11:26,470
0,930 930,1530 1530,1860 1860,2220 2220,2490
two {} design choices that

357
00:11:26,470 --> 00:11:28,840
0,270 270,1140 1140,1170 1170,1830 1830,2370
really drive {} this design|
|

358
00:11:29,260 --> 00:11:31,930
0,270 270,540 540,780 780,1290 1530,2670
as well as this basically
以及性能。

359
00:11:32,140 --> 00:11:33,080
0,720
{}

360
00:11:34,230 --> 00:11:36,100
0,1320
performance.|
|

361
00:11:42,120 --> 00:11:45,090
0,630 1440,1890 1890,2070 2070,2250 2250,2970
So it may be helpful
所以，稍微考虑一下可能会有所帮助，

362
00:11:45,120 --> 00:11:45,960
0,300 300,450 450,480 480,690 690,840
to think a little bit

363
00:11:45,960 --> 00:11:47,100
0,240 240,480 480,750 750,930 930,1140
about,| like what other use
|例如，对于文件系统，还有哪些其他用例，

364
00:11:47,100 --> 00:11:48,420
0,330 330,480 480,600 600,960 1200,1320
cases could you have {}

365
00:11:48,420 --> 00:11:49,500
0,210 210,450 450,870 870,960 960,1080
for file systems,| and so
|我们经常谈到的一个很好的是，

366
00:11:49,500 --> 00:11:51,000
0,390 390,930 930,1080 1080,1290 1290,1500
maybe one good one that

367
00:11:51,000 --> 00:11:51,990
0,90 90,300 300,330 330,570 570,990
we talked a lot about

368
00:11:52,290 --> 00:11:53,970
0,420 420,540 540,690 690,900 900,1680
is| to think about GFS,|
|考虑一下 GFS ，|

369
00:11:54,360 --> 00:11:56,190
0,750 750,870 870,990 990,1290 1290,1830
{} you know would GFS
GFS 会不会成为 Frangipani 的替代品

370
00:11:56,190 --> 00:11:57,990
0,510 510,930 930,1380 1380,1500 1500,1800
be a substitute for {Frangipani

371
00:11:57,990 --> 00:11:58,830
0,390 390,480 480,570 570,720 720,840
-}| or the other way
|或者反过来，他们的对比起来如何？

372
00:11:58,830 --> 00:12:00,420
0,420 420,540 540,690 690,870 870,1590
around how do they contrast?|
|

373
00:12:00,870 --> 00:12:01,980
0,510 570,780 780,870 870,960 960,1110
And one way to think
思考这一问题的一种方式是，

374
00:12:01,980 --> 00:12:03,780
0,180 180,330 330,420 420,990 1020,1800
about this is,| that GFS
|GFS 是为 mapreduce 应用程序设计的文件系统，

375
00:12:03,780 --> 00:12:05,460
0,90 90,300 300,570 570,930 930,1680
is really file system designed

376
00:12:05,460 --> 00:12:07,620
0,90 90,300 300,630 630,1470 1800,2160
for {mapreduce -} applications,| and
|它是一个文件系统，其中的文件不会被缓存，

377
00:12:07,620 --> 00:12:08,850
0,360 360,510 510,570 570,840 840,1230
so it's a file system

378
00:12:08,850 --> 00:12:12,840
0,690 810,2340 2340,2910 2940,3390 3390,3990
where files are not cached,|
|

379
00:12:12,840 --> 00:12:14,100
0,300 300,690 690,780 780,1080 1080,1260
in fact the files tend
事实上，这些文件往往非常大，

380
00:12:14,100 --> 00:12:14,850
0,60 60,180 180,360 360,630 630,750
to be so big,| that
|它们甚至不适合在我们所说的这种类型的缓存中，

381
00:12:14,850 --> 00:12:16,020
0,120 120,420 420,600 600,960 960,1170
they wouldn't even fit in

382
00:12:16,020 --> 00:12:16,980
0,150 150,330 330,390 390,780 780,960
the type of cache that

383
00:12:16,980 --> 00:12:18,810
0,360 360,750 750,1140 1440,1620 1620,1830
we're talking about,| it's also
|它也是从头到尾按顺序读取的，

384
00:12:18,810 --> 00:12:20,490
0,300 300,480 480,570 570,990 990,1680
basically sort of read sequentially

385
00:12:20,490 --> 00:12:21,630
0,150 150,480 480,600 600,960 990,1140
from begin to end,| and
|仅此而已，

386
00:12:21,630 --> 00:12:23,280
0,210 210,450 810,1020 1020,1560 1560,1650
that's it,| and maybe you
|也许其他计算机会读取该文件，

387
00:12:23,280 --> 00:12:25,170
0,120 120,270 270,810 810,1530 1530,1890
know some other {} computer

388
00:12:25,170 --> 00:12:26,400
0,180 180,330 330,480 480,870 870,1230
will read that file,| because
|因为一些其他的 mapreduce 应用程序运行。

389
00:12:26,400 --> 00:12:27,690
0,120 120,330 330,540 540,810 810,1290
some other {mapreduce -} application

390
00:12:27,690 --> 00:12:28,420
0,240 240,450
running on.|
|

391
00:12:28,830 --> 00:12:30,210
0,270 270,540 540,750 750,930 930,1380
So think, you think about
所以，你想想 GFS ，

392
00:12:30,210 --> 00:12:32,010
0,540 600,900 900,1140 1140,1470 1470,1800
GFS,| there's really no data
|根本就没有数据缓存，

393
00:12:32,010 --> 00:12:33,180
0,360 360,570 570,810 810,870 870,1170
caching going on at all,|
|

394
00:12:33,210 --> 00:12:33,930
0,330 330,390 390,540 540,630 630,720
there's a little bit of
需要使用一些缓存来跟踪，

395
00:12:33,930 --> 00:12:35,310
0,300 300,510 510,750 750,1140 1170,1380
caching going on to keep

396
00:12:35,310 --> 00:12:38,100
0,390 390,600 960,1770 1770,1770 2430,2790
track of| where a chunk
|块服务器所在的位置，

397
00:12:38,100 --> 00:12:39,630
0,300 300,720 840,1170 1170,1350 1350,1530
servers were,| but there's actually
|但在 GFS 中根本没有进行数据缓存，

398
00:12:39,630 --> 00:12:40,860
0,210 210,630 630,690 690,990 990,1230
no caching of data going

399
00:12:40,860 --> 00:12:42,090
0,210 210,300 300,540 540,660 660,1230
on at all in GFS,|
|

400
00:12:42,240 --> 00:12:43,200
0,150 150,300 300,510 510,630 630,960
so there's also no cache
所以，在 GFS 中也没有缓存一致性，

401
00:12:43,200 --> 00:12:45,300
0,570 570,990 990,1080 1080,1770 1980,2100
consistency probably in GFS,| and
|所以，他们的目标是某种类型的应用程序，

402
00:12:45,300 --> 00:12:46,170
0,120 120,390 390,480 480,780 780,870
so there's a type of

403
00:12:46,170 --> 00:12:47,760
0,600 600,720 720,780 780,930 930,1590
applications that they were targeting,|
|

404
00:12:47,850 --> 00:12:49,020
0,180 180,360 360,720 720,930 930,1170
that just didn't make sense
这完全说不通。

405
00:12:49,020 --> 00:12:49,780
0,90 90,450
at all.|
|

406
00:12:50,080 --> 00:12:52,150
0,450 450,540 540,1230 1320,1860 1860,2070
Similarly, in GFS,| GFS actually
同样地，在 GFS 中，|GFS 并不是一个真正的文件系统，

407
00:12:52,150 --> 00:12:53,500
0,90 90,300 300,630 630,1110 1110,1350
it's not really a real

408
00:12:53,500 --> 00:12:54,520
0,300 300,600 600,690 690,750 750,1020
file system,| in the sense
|从这个意义上来说，

409
00:12:54,520 --> 00:12:55,990
0,90 90,570 600,1050 1050,1260 1260,1470
of the here,| was not
|并不打算运行 VI GCC ，

410
00:12:55,990 --> 00:12:57,790
0,390 390,480 480,780 780,1020 1020,1800
intended to run like VI,

411
00:12:57,880 --> 00:13:00,040
0,1110 1260,1650 1650,1830 1830,1950 1950,2160
GCC,| {} and so didn't
|所以，没有提供直接的 POSIX 或 Unix 兼容性，

412
00:13:00,040 --> 00:13:01,870
0,660 660,1080 1080,1230 1230,1710 1710,1830
provide straight {sort,of} POSIX or

413
00:13:01,870 --> 00:13:04,840
0,270 270,1020 1050,2490 2520,2850 2850,2970
Unix compatibility,| {in,Frangipani -}, you
|在 Frangipani 中，你可以运行标准 Unix 应用程序，

414
00:13:04,840 --> 00:13:06,130
0,90 90,240 240,810 810,930 930,1290
can just run your standard

415
00:13:06,130 --> 00:13:08,260
0,240 240,1050 1350,1740 1740,1950 1950,2130
Unix applications| and things should
|应该能正常运行，

416
00:13:08,260 --> 00:13:10,390
0,210 210,540 690,1470 1500,1590 1590,2130
work out,| and the application
|应用程序的行为方式与没有分布式文件系统一样，

417
00:13:10,390 --> 00:13:12,070
0,600 900,1050 1050,1110 1110,1500 1500,1680
behave in the same way

418
00:13:12,070 --> 00:13:13,180
0,180 180,360 360,690 690,900 900,1110
as if there was not

419
00:13:13,180 --> 00:13:14,470
0,60 60,450 450,660 660,930 930,1290
a distributed file system,| basically
|而是单一文件系统。

420
00:13:14,470 --> 00:13:15,480
0,300 300,570 570,900
single file system.|
|

421
00:13:16,990 --> 00:13:23,800
0,600 630,1230 1260,1920 1950,6300 6300,6810
Again in GFS,| {you,know,there,is} {basically,a,little,bit,of}
同样，在 GFS 中，|有一些库，

422
00:13:23,800 --> 00:13:25,600
0,540 540,690 690,990 990,1290 1290,1800
library,| you know actually application
|应用程序用来在 GFS 中读取或写入文件，

423
00:13:25,600 --> 00:13:26,800
0,510 510,660 660,840 840,930 930,1200
used to read or write

424
00:13:26,800 --> 00:13:28,660
0,630 840,1080 1080,1500 1500,1710 1710,1860
files {} {in,GFS -},| but
|但它不是 100% Unix 兼容的。

425
00:13:28,660 --> 00:13:29,950
0,60 60,180 180,510 510,990 990,1290
it was not {100% -

426
00:13:29,950 --> 00:13:31,480
0,300 300,540 540,1110 1110,1200 1200,1530
-} Unix compatible at all.|
|

427
00:13:32,640 --> 00:13:33,540
0,150 150,540 570,720 720,780 780,900
{} So {that -} give
所以这给你一个感觉，

428
00:13:33,540 --> 00:13:34,470
0,60 60,120 120,480 480,720 720,930
you a sense,| that you
|这些工作负载推动了这些不同系统的设计，

429
00:13:34,470 --> 00:13:37,080
0,120 120,420 420,1230 1380,2220 2220,2610
know these workloads drives really

430
00:13:37,080 --> 00:13:38,340
0,120 120,600 600,720 720,870 870,1260
the design of these different

431
00:13:38,550 --> 00:13:39,930
0,600 600,720 720,840 840,1080 1080,1380
systems,| you know in case
|在 GFS 的情况中，

432
00:13:39,930 --> 00:13:41,970
0,210 210,600 810,1140 1140,1440 1440,2040
{GFS -},| {mapreduce -} application
|mapreduce 驱动了设计，

433
00:13:41,970 --> 00:13:43,770
0,150 150,480 480,540 540,1080 1290,1800
that drive the design, {}|
|

434
00:13:43,770 --> 00:13:45,390
0,330 330,630 630,1050 1080,1200 1200,1620
in case of you know
在 Frangipani 或共享文件系统的情况中，

435
00:13:45,420 --> 00:13:46,440
0,180 180,570 570,720 720,810 810,1020
{Frangipani -} or the shared

436
00:13:46,440 --> 00:13:47,610
0,210 210,450 450,570 570,810 810,1170
file system| is a question
|是在共享文件系统上工作的用户的问题，

437
00:13:47,610 --> 00:13:49,590
0,60 60,540 570,1320 1470,1620 1620,1980
of users working on shared

438
00:13:49,590 --> 00:13:50,730
0,300 300,630 630,750 750,1020 1020,1140
file system,| but most of
|但是他们执行的大多数操作，

439
00:13:50,730 --> 00:13:52,560
0,90 90,840 840,1290 1290,1560 1560,1830
the operations {you,know} their performing,|
|

440
00:13:52,650 --> 00:13:54,480
0,390 390,600 660,1170 1170,1380 1380,1830
probably just files [] own
可能只是文件本身，并在本地执行。

441
00:13:54,540 --> 00:13:56,900
0,720 720,840 1470,1830 1830,2220
{} and performed locally.|
|

442
00:13:57,900 --> 00:13:59,070
0,240 240,420 420,720 720,900 900,1170
That makes sense in terms
这在设置的对比上是有意义的，

443
00:13:59,070 --> 00:14:00,990
0,240 240,870 870,1050 1050,1650 1710,1920
of contrast in settings,| so
|所以，你可以看到，有很多不同的文件系统，

444
00:14:00,990 --> 00:14:01,710
0,120 120,300 300,540 540,660 660,720
you see actually there are

445
00:14:01,710 --> 00:14:02,640
0,180 180,270 270,600 600,870 870,930
quite a different number of

446
00:14:02,640 --> 00:14:04,680
0,270 270,630 630,1080 1320,1860 1860,2040
file systems around,| {like,zookeeper} yet
|比如 zookeeper 也是一种提供文件系统接口，

447
00:14:04,680 --> 00:14:06,330
0,300 300,510 510,630 960,1410 1410,1650
another sort of provides file

448
00:14:06,330 --> 00:14:07,380
0,270 270,660 660,750 750,840 840,1050
system interface,| but it's not
|但它并不是真正的文件系统，

449
00:14:07,380 --> 00:14:08,670
0,180 180,270 270,510 510,930 930,1290
really a file system,| {you,know,it's}
|它更像是一种协调服务，

450
00:14:08,670 --> 00:14:10,050
0,180 180,690 690,1200 1200,1290 1290,1380
like more intended as a

451
00:14:10,050 --> 00:14:11,550
0,510 510,870 870,960 960,1170 1170,1500
coordination service,| you wouldn't store
|你不会在 zookeeper 保存大文件。

452
00:14:11,550 --> 00:14:13,380
0,210 210,840 1020,1440 1440,1650 1650,1830
big files {} in {zookeeper

453
00:14:13,380 --> 00:14:13,960
0,390
-}.|
|

454
00:14:16,130 --> 00:14:18,590
0,240 240,570 570,780 780,1320 1680,2460
Any questions about this {}
对这个设置，有什么问题吗？

455
00:14:18,920 --> 00:14:19,960
0,630
setting?|
|

456
00:14:20,220 --> 00:14:21,560
0,480

457
00:14:21,780 --> 00:14:23,700
0,210 210,390 390,630 630,1530 1560,1920
{} Can you briefly repeat,|
你能简单重复一下，|

458
00:14:23,700 --> 00:14:25,080
0,270 270,600 600,750 750,990 990,1380
why having the file server
为什么在客户机上运行文件服务器代码可以增强可伸缩性，

459
00:14:25,080 --> 00:14:26,490
0,330 330,600 600,870 870,990 990,1410
code running on the client

460
00:14:26,490 --> 00:14:29,880
0,540 1290,2010 2010,2340 2340,3150
machine enhances {} scalability,|
|

461
00:14:30,110 --> 00:14:31,250
0,360 360,630 630,690 690,1050 1050,1140
versus having the client and
而不是让客户端和文件服务器

462
00:14:31,250 --> 00:14:32,810
0,90 90,270 270,780 1050,1380 1380,1560
the file server| being on
|在不同的机器上。

463
00:14:32,810 --> 00:14:34,490
0,270 270,750 930,1140 1140,1260 1260,1680
different machines or on different.|
|

464
00:14:34,490 --> 00:14:35,420
0,390

465
00:14:35,840 --> 00:14:36,680
0,210 210,360 360,420 420,720 720,840
Yeah, so, for example you
是的，比如，

466
00:14:36,680 --> 00:14:37,880
0,600 600,750 750,810 810,960 960,1200
know,| like to go back
|如果回到上一张幻灯片，

467
00:14:37,880 --> 00:14:39,650
0,90 90,390 420,870 870,1170 1170,1770
to this previous slide here,|
|

468
00:14:39,650 --> 00:14:40,610
0,150 150,270 270,600 600,690 690,960
on the left the network
在左边的网络文件系统，

469
00:14:40,610 --> 00:14:41,930
0,240 240,720 720,930 930,1050 1050,1320
file system {},| so there's
|有很多客户端，

470
00:14:41,930 --> 00:14:43,820
0,240 240,420 420,630 630,1290 1440,1890
many many many clients,| let's
|我们假设只有一个，

471
00:14:43,820 --> 00:14:45,470
0,300 300,480 480,720 720,1170 1200,1650
figure there's only one,| there's
|让我把这张图简化一下，

472
00:14:45,470 --> 00:14:46,550
0,120 120,240 240,690 690,840 840,1080
let me simplify this picture

473
00:14:46,550 --> 00:14:48,350
0,90 90,120 120,480 870,1200 1230,1800
for a second,| and ignore
|忽略第二文件服务器，只有一个文件服务器，

474
00:14:48,350 --> 00:14:49,430
0,90 90,360 360,570 570,900 900,1080
the second file server, one

475
00:14:49,430 --> 00:14:50,720
0,270 270,540 540,810 810,990 990,1290
one file server,| so everybody
|这样每个人都可以共享这个文件服务器上的文件，

476
00:14:50,720 --> 00:14:51,770
0,90 90,330 330,420 420,810 900,1050
can share the files from

477
00:14:51,770 --> 00:14:53,060
0,120 120,360 360,750 900,1140 1140,1290
the file server,| then all
|然后这些客户端都将在该单一文件服务器上处理，

478
00:14:53,060 --> 00:14:54,290
0,210 210,630 630,750 750,840 840,1230
these clients will be handling

479
00:14:54,290 --> 00:14:55,640
0,120 120,390 390,720 720,990 990,1350
on that single file server,|
|

480
00:14:56,300 --> 00:14:57,200
0,270 270,450 450,690 690,840 840,900
and so {all,the} read or
所有的读或写操作都将被发送到文件服务器，

481
00:14:57,200 --> 00:14:58,250
0,240 240,630 630,720 720,990 990,1050
write operations are going to

482
00:14:58,250 --> 00:14:58,970
0,90 90,300 300,360 360,450 450,720
be sent to the file

483
00:14:58,970 --> 00:15:00,980
0,510 510,600 600,840 840,1200 1440,2010
server,| the file server directly
|文件服务器直接查找，

484
00:15:00,980 --> 00:15:04,070
0,630 660,1530 1950,2130 2130,2460 2460,3090
lookout,| {} it opens files
|它打开文件并做安全检查，

485
00:15:04,070 --> 00:15:05,780
0,90 90,390 390,840 840,1470 1530,1710
and does security checks| and
|诸如此类的事情，

486
00:15:05,780 --> 00:15:06,410
0,120 120,210 210,360 360,420 420,630
all that kind of stuff,|
|

487
00:15:06,410 --> 00:15:07,910
0,90 90,270 270,360 360,1080 1080,1500
so all the computation really
所有的计算都是针对文件系统本身，

488
00:15:07,910 --> 00:15:09,590
0,600 630,720 720,1020 1020,1320 1320,1680
for the file system itself,|
|

489
00:15:09,590 --> 00:15:11,030
0,90 90,270 270,870 1080,1350 1350,1440
it's all happening on the
这一切都发生在文件服务器身上，

490
00:15:11,030 --> 00:15:12,800
0,240 240,480 480,990 1020,1410 1410,1770
file server itself| in the
|在传统的网络文件系统设计中，

491
00:15:12,830 --> 00:15:14,510
0,570 570,840 840,1020 1020,1290 1290,1680
traditional network file system design,|
|

492
00:15:14,840 --> 00:15:15,710
0,240 240,300 300,510 510,780 780,870
in the {Frangipani - -},
在 Frangipani 中，情况并非如此，

493
00:15:15,710 --> 00:15:17,090
0,240 240,390 390,450 450,990 1320,1380
that's not the case,| in
|在 Frangipani 中，所有文件系统操作都在工作站上执行。

494
00:15:17,090 --> 00:15:18,050
0,240 240,540 540,690 690,870 870,960
{Frangipani - -}, all the

495
00:15:18,050 --> 00:15:19,670
0,210 210,450 450,990 990,1110 1110,1620
file system operations are executed

496
00:15:19,670 --> 00:15:20,820
0,150 150,240 240,1080
on the workstations.|
|

497
00:15:21,260 --> 00:15:22,820
0,210 210,450 450,750 750,1020 1020,1560
And so we have multiple
我们有多个工作站，

498
00:15:22,820 --> 00:15:24,350
0,750 750,840 840,1320 1320,1380 1380,1530
workstations| are basically you know
|文件系统可以扩展的工作负载，

499
00:15:24,350 --> 00:15:26,150
0,240 240,960 960,1110 1110,1200 1200,1800
the workload that the {file,system}

500
00:15:26,150 --> 00:15:27,260
0,120 120,660 660,870 870,960 960,1110
can scale| or it can
|或者它可以支持随着工作站数量的增加而扩展。

501
00:15:27,260 --> 00:15:28,430
0,450 450,780 780,900 900,990 990,1170
support scales with the number

502
00:15:28,430 --> 00:15:29,540
0,90 90,870
of workstations.|
|

503
00:15:31,330 --> 00:15:32,230
0,210 210,420 420,570 570,690 690,900
I see,| and then be
我明白了，|在传统的架构中，

504
00:15:32,230 --> 00:15:34,600
0,270 270,1230 1260,1800 1800,2130 2130,2370
a traditional architecture,| so every
|每个文件服务器都包含或存储，

505
00:15:34,600 --> 00:15:37,240
0,180 180,510 510,1170 1170,1620 1950,2640
file server contains or stores,|
|

506
00:15:37,240 --> 00:15:38,740
0,330 330,540 540,660 660,1140 1140,1500
let's say a section of
我们假设整个文件系统的一部分，

507
00:15:38,800 --> 00:15:40,390
0,420 450,660 660,1050 1050,1290 1290,1590
the the entire file system,

508
00:15:40,390 --> 00:15:41,680
0,210 210,450 450,840 840,1050 1050,1290
right,| so it so it's
|所以，不是这种情况，

509
00:15:41,680 --> 00:15:42,820
0,180 180,270 270,540 540,870 870,1140
not the case,| that {}
|每个文件服务器都有整个系统的副本，

510
00:15:43,260 --> 00:15:44,880
0,300 300,540 540,780 780,1110 1110,1620
every single file server has

511
00:15:44,880 --> 00:15:46,110
0,330 330,690 690,780 780,870 870,1230
a copy of the entire

512
00:15:46,110 --> 00:15:47,790
0,450 840,1020 1020,1290 1290,1500 1500,1680
system,| is that it might
|它可能是拆分跨文件服务器的。

513
00:15:47,790 --> 00:15:51,270
0,120 120,570 600,1140 1170,1680 1860,3480
be partitioned cross {file,servers}.| {Yeah\,,that,might,be}
|是的，它可能是，

514
00:15:51,270 --> 00:15:52,620
0,630 630,840 840,1080 1080,1140 1140,1350
cross,| {for,example} AFS you know
|例如， AFS 有不同的卷，

515
00:15:52,620 --> 00:15:55,650
0,420 420,600 600,870 870,1680 1860,3030
there are different volumes| and
|文件服务器管理不同的卷，

516
00:15:55,680 --> 00:15:57,720
0,300 300,720 720,1320 1320,1560 1560,2040
file servers managed different volumes,|
|

517
00:15:57,720 --> 00:15:58,740
0,90 90,180 180,480 480,750 750,1020
and the data of all
MIT 所有用户的数据分布在不同的卷上，

518
00:15:58,740 --> 00:16:00,510
0,390 390,840 840,1140 1140,1500 1500,1770
users MIT spread across different

519
00:16:00,510 --> 00:16:01,360
0,630
volumes,|
|

520
00:16:01,710 --> 00:16:02,910
0,210 210,390 390,480 480,1020 1050,1200
but all the data for
但是一个卷的所有数据都将是一个文件服务器，

521
00:16:02,910 --> 00:16:03,870
0,210 210,720 720,780 780,900 900,960
one volumes are going to

522
00:16:03,870 --> 00:16:05,190
0,150 150,480 480,750 750,1140 1140,1320
be one file server,| and
|所以，那个文件卷命中太多，

523
00:16:05,190 --> 00:16:06,570
0,150 150,390 390,840 840,1200 1200,1380
so that file volume gets

524
00:16:06,570 --> 00:16:07,950
0,150 150,630 720,900 900,1050 1050,1380
hit hard,| you know you're
|你会遇到性能瓶颈。

525
00:16:07,950 --> 00:16:09,480
0,150 150,210 210,540 540,870 870,1530
going to get performance bottlenecks.|
|

526
00:16:10,000 --> 00:16:11,360
0,390 420,720 720,870 870,1050
Okay, awesome, thank you.|
好的，太棒了，谢谢。|

527
00:16:13,700 --> 00:16:14,810
0,270 270,450 450,780 780,960 960,1110
Any more questions about sort
关于这个设置，有什么问题吗，

528
00:16:14,810 --> 00:16:16,850
0,90 90,330 330,780 780,1260 1290,2040
of the setting here,| before
|在我们深入了解更多 Frangipani 之前？

529
00:16:16,850 --> 00:16:18,040
0,210 210,510 510,870
we dive in

530
00:16:18,300 --> 00:16:20,220
0,420 420,690 690,1170 1170,1470 1470,1920
to {} more {Frangipani -}?|
|

531
00:16:25,660 --> 00:16:26,660
0,330 330,660
Okay, good.|
好的，很好。|

532
00:16:26,920 --> 00:16:29,410
0,510 840,1470 1470,1800 1800,2190 2190,2490
So now the design choice
所以他们所做的设计选择，

533
00:16:29,410 --> 00:16:31,270
0,120 120,570 600,1170 1170,1590 1590,1860
they made,| {} immediately leads
|带来了一些挑战，

534
00:16:31,270 --> 00:16:32,470
0,150 150,210 210,450 450,510 510,1200
to a number of challenges,|
|

535
00:16:33,720 --> 00:16:34,500
0,150 150,210 210,540 570,720 720,780
so I wanna talk a
所以我想谈谈这些挑战。

536
00:16:34,500 --> 00:16:35,850
0,180 180,300 300,510 510,690 690,1350
little bit about the challenges.|
|

537
00:16:40,980 --> 00:16:44,370
0,600 600,1170 1350,2100 2160,2850 2850,3390
{} And the main one
驱动几乎大量设计的主要因素是，

538
00:16:44,760 --> 00:16:46,530
0,120 120,540 540,990 990,1110 1110,1770
that drives almost of a

539
00:16:46,530 --> 00:16:48,330
0,240 240,360 360,450 450,1140 1290,1800
ton of the design is,|
|

540
00:16:48,330 --> 00:16:49,110
0,180 180,390 390,450 450,570 570,780
let's say you have one
假设你有一个工作站，工作站 1 ，

541
00:16:49,110 --> 00:16:52,590
0,960 1620,2340 2340,2850 3060,3240 3240,3480
workstation, workstation 1,| in those
|那时候，人们有工作站，

542
00:16:52,590 --> 00:16:54,750
0,360 780,1080 1080,1350 1350,1950 1950,2160
days, people had workstations,| and
|笔记本电脑还不存在，

543
00:16:54,750 --> 00:16:56,580
0,510 510,750 750,1050 1050,1590 1590,1830
laptops were actually not not

544
00:16:56,580 --> 00:16:58,860
0,330 330,900 900,1230 1560,1950 1980,2280
really existed yet,| {} today
|今天可能是各种各样的笔记本电脑，

545
00:16:58,860 --> 00:16:59,700
0,330 330,420 420,540 540,690 690,840
probably will be all kinds

546
00:16:59,700 --> 00:17:01,350
0,90 90,540 540,960 1260,1590 1590,1650
of laptops,| {but,you,know} there's a
|但是有一个工作站，

547
00:17:01,350 --> 00:17:03,420
0,750 870,1320 1320,1560 1560,1860 1860,2070
workstation| {} and somebody like
|一些人读取文件，读取文件 f ，

548
00:17:03,420 --> 00:17:04,760
0,330 330,510 510,600 600,1200
whatever read a file,

549
00:17:05,100 --> 00:17:07,080
0,330 330,630 630,750 750,1320 1830,1980
read file f whatever,| you
|也许是成绩数据库，成绩文件，

550
00:17:07,080 --> 00:17:08,730
0,450 480,750 750,840 840,1170 1170,1650
know maybe the grades database,

551
00:17:08,730 --> 00:17:10,350
0,120 120,180 180,420 420,870 1290,1620
{the -} grades file,| and
|所以，

552
00:17:10,350 --> 00:17:12,330
0,600 750,1350 1350,1560 1560,1830 1830,1980
so basically,| that means that
|这意味着那个文件缓存在工作站中。

553
00:17:12,330 --> 00:17:13,950
0,210 210,570 570,810 810,900 900,1620
that file actually is cached

554
00:17:13,950 --> 00:17:15,840
0,450 450,570 570,930 960,1620
inside of the workstation.|
|

555
00:17:16,340 --> 00:17:17,450
0,270 270,360 360,570 570,1020 1020,1110
And so the client you
所以，运行 VI 的程序的客户端，

556
00:17:17,450 --> 00:17:20,030
0,150 150,630 630,990 990,1440 1830,2580
know whatever program running VI,|
|

557
00:17:20,030 --> 00:17:21,260
0,120 120,270 270,420 420,660 720,1230
you know get to update
可以更新和操作文件，

558
00:17:21,260 --> 00:17:23,510
0,120 120,840 840,1110 1140,1770 2010,2250
and manipulate the file,| and
|然后晚些时候，

559
00:17:23,510 --> 00:17:24,680
0,360 360,450 450,540 540,900 900,1170
then {you,know -} sometime later,|
|

560
00:17:24,680 --> 00:17:25,550
0,120 120,420 420,540 540,660 660,870
the result will be written
结果将写回 Petal ，

561
00:17:25,550 --> 00:17:27,860
0,480 570,990 990,1710 1830,2310 2310,2310
back to {Petal -},| the
|或者如果你愿意，（写入）磁盘。

562
00:17:27,860 --> 00:17:30,140
0,660 690,870 870,1350 1950,2160 2160,2280
disk, as {you,will}.| And so
|所以，这个模型面临的挑战是三个[]，

563
00:17:30,140 --> 00:17:32,210
0,210 210,690 690,870 870,1650 1680,2070
the challenges that are basically

564
00:17:32,210 --> 00:17:33,500
0,300 300,420 420,690 690,840 840,1290
around this model are {3,[]},|
|

565
00:17:33,980 --> 00:17:36,650
0,690 720,1440 1650,1980 1980,2340 2340,2670
{} one, {} somebody else
第一，其他人，工作站 2 ，

566
00:17:36,650 --> 00:17:37,980
0,90 90,570 570,1080
{} workstation 2,|
|

567
00:17:38,750 --> 00:17:39,620
0,330 330,480 480,600 600,810 810,870
maybe {at -} some point,|
可能在某一时刻，|

568
00:17:39,620 --> 00:17:40,730
0,240 240,360 360,570 570,690 690,1110
do {cat -} of f,|
执行 cat f ，|

569
00:17:41,870 --> 00:17:43,880
0,510 510,600 600,990 990,1380 1680,2010
get the file f,| and
获取文件 f ，|当然，情况应该是这样的，

570
00:17:43,880 --> 00:17:44,960
0,60 60,360 360,840 840,990 990,1080
of course it should be

571
00:17:44,960 --> 00:17:46,280
0,60 60,390 390,600 600,720 720,1320
the case that,| you know
|至少在正常情况下，我们有一个传统的 Unix 文件系统，

572
00:17:46,280 --> 00:17:48,380
0,180 180,480 690,1440 1440,1950 1950,2100
at least normally expected we

573
00:17:48,380 --> 00:17:49,580
0,150 150,240 240,720 720,960 960,1200
have a traditional Unix file

574
00:17:49,580 --> 00:17:51,290
0,510 780,1170 1170,1290 1290,1560 1560,1710
system,| that you know you
|你会看到那个 f 的最后一次写入，

575
00:17:51,290 --> 00:17:52,490
0,150 150,300 300,420 420,780 780,1200
will see the last write

576
00:17:52,730 --> 00:17:53,990
0,150 150,360 360,720 720,1050 1080,1260
to that particular f,| so
|所以，即使写入可能发生在不同的工作站上，

577
00:17:53,990 --> 00:17:55,070
0,270 270,600 600,750 750,960 960,1080
even though the write might

578
00:17:55,070 --> 00:17:55,880
0,90 90,390 390,510 510,540 540,810
have happened at a different

579
00:17:55,880 --> 00:17:57,950
0,750 990,1410 1410,1650 1650,1800 1800,2070
workstation,| {} when the second
|当第二工作站读取该文件时，

580
00:17:57,950 --> 00:17:59,930
0,780 780,960 960,1050 1050,1530 1680,1980
workstation reads the file, {}|
|

581
00:17:59,930 --> 00:18:01,310
0,660 660,810 810,960 960,1050 1050,1380
we would like to see
我们会看到数据显示出来，

582
00:18:01,310 --> 00:18:03,590
0,1020 1020,1290 1290,1530 1530,1800 2130,2280
that data show up,| and
|这就是他们将会是什么样子，

583
00:18:03,590 --> 00:18:04,700
0,120 120,180 180,300 300,780 810,1110
this is what they were

584
00:18:04,700 --> 00:18:06,500
0,120 120,180 180,420 480,1230 1590,1800
going to be roughly,| this
|大致归结为缓存一致性，

585
00:18:06,500 --> 00:18:07,700
0,390 390,630 630,810 810,1080 1080,1200
roughly comes to cache {coherence

586
00:18:07,700 --> 00:18:08,440
0,210 210,510
- -},|
|

587
00:18:10,800 --> 00:18:12,720
0,300 300,540 540,900 900,1470 1470,1920
and other words synonyms for
其他说法，连贯性的同义词是缓存一致性，

588
00:18:12,720 --> 00:18:15,450
0,570 570,810 810,1080 1080,2130 2280,2730
coherence are cache consistency,| which
|就像我们在之前的论文中看到的更多的术语，

589
00:18:15,450 --> 00:18:16,740
0,120 120,270 270,360 360,750 750,1290
is like the term we've

590
00:18:16,740 --> 00:18:18,900
0,240 240,900 1500,1740 1740,1860 1860,2160
seen more in the previous

591
00:18:18,900 --> 00:18:20,490
0,480 720,1020 1020,1260 1260,1470 1470,1590
papers,| {} but in the
|但是在计算机体系结构的领域，

592
00:18:20,490 --> 00:18:21,660
0,180 180,420 780,1020 1020,1110 1110,1170
sort of, {at -} the

593
00:18:21,660 --> 00:18:23,370
0,300 300,780 780,1080 1080,1410 1410,1710
computer architecture world,| actually the
|连贯性这个术语来自于那个领域，

594
00:18:23,370 --> 00:18:25,530
0,120 120,480 480,900 900,1320 1320,2160
the term coherence comes, {}

595
00:18:26,190 --> 00:18:27,940
0,210 210,360 360,750 780,1620
comes from that world,|
|

596
00:18:28,410 --> 00:18:29,280
0,270 270,480 480,630 630,750 750,870
and so you can think
所以你可以把它们当成同义词。

597
00:18:29,280 --> 00:18:30,940
0,240 240,360 360,1050 1050,1440
about them as synonyms.|
|

598
00:18:32,660 --> 00:18:34,670
0,390 390,1170 1200,1320 1320,1620 1620,2010
{} Two, the second problem
第二，第二个会发生的问题，

599
00:18:34,670 --> 00:18:36,590
0,210 210,330 330,540 540,930 1230,1920
that you know you {}

600
00:18:36,710 --> 00:18:38,180
0,480 480,600 600,690 690,1260 1260,1470
that's going to occur,| and
|我们需要处理的是，

601
00:18:38,180 --> 00:18:39,020
0,150 150,300 300,360 360,600 600,840
we need to deal with

602
00:18:39,020 --> 00:18:40,340
0,300 300,600 690,960 960,1110 1110,1320
is that,| let's say that
|假设工作站 1 和工作站 2

603
00:18:40,340 --> 00:18:42,060
0,540 540,1140
workstation 1

604
00:18:42,770 --> 00:18:44,870
0,330 330,840 840,1410 1590,1980 1980,2100
and workstation 2| both want
|都想要在共享目录中创建文件，

605
00:18:44,870 --> 00:18:45,950
0,60 60,300 300,360 360,930 930,1080
to create a file in

606
00:18:45,950 --> 00:18:48,350
0,600 600,870 870,1350 1350,1710 1830,2400
the share directory,| so here's
|所以工作站 1 在目录 d 中创建了一个文件 f ，

607
00:18:49,010 --> 00:18:50,660
0,600 600,810 810,1110 1110,1170 1170,1650
workstation 1 creates a file

608
00:18:50,690 --> 00:18:52,220
0,510 510,630 630,720 720,1110 1110,1530
f in the directory d,|
|

609
00:18:52,310 --> 00:18:54,500
0,900 1110,1530 1530,1800 1800,2100 2100,2190
workstation 2 also creates a
工作站 2 也在目录 d 中创建文件 g 。

610
00:18:54,500 --> 00:18:56,870
0,330 330,1080 1260,1770 1770,1980 1980,2370
file g {} in directory

611
00:18:56,870 --> 00:18:57,420
0,360
d.|
|

612
00:18:57,910 --> 00:18:58,930
0,330 420,630 630,750 750,900 900,1020
And now we want to
现在我们希望至少安排，

613
00:18:58,930 --> 00:19:00,550
0,330 330,780 780,930 930,1200 1200,1620
be arranged at least,| like
|工作站 1 进行变更，

614
00:19:00,550 --> 00:19:02,350
0,450 450,660 660,900 900,1290 1320,1800
workstation 1 makes the changes|
|

615
00:19:02,350 --> 00:19:03,460
0,90 90,210 210,630 630,840 840,1110
and then workstation 2 makes
然后工作站 2 进行变更，

616
00:19:03,460 --> 00:19:05,260
0,60 60,480 870,1260 1260,1500 1500,1800
the changes,| like both files
|这里的两个文件，

617
00:19:05,260 --> 00:19:06,580
0,450 510,750 750,900 900,1050 1050,1320
here,| and that like one
|一个文件不会覆盖其他的文件夹，

618
00:19:06,580 --> 00:19:09,040
0,270 270,510 510,1170 1470,2160 2160,2460
file doesn't overwrite say the

619
00:19:09,040 --> 00:19:12,220
0,780 780,1770 1800,1920 1920,2820 2820,3180
directory of the other| or
|或者覆盖文件夹导致其他文件消失。

620
00:19:12,250 --> 00:19:13,510
0,300 300,540 540,870 870,1200 1200,1260
basically {overwrite -} directory in

621
00:19:13,510 --> 00:19:14,620
0,60 60,270 270,480 480,810 810,1110
a way that actually other

622
00:19:14,620 --> 00:19:15,920
0,390 390,930
files disappears.|
|

623
00:19:16,350 --> 00:19:17,100
0,210 210,390 390,570 570,660 660,750
So this has to do
所以这就是第二个主题，原子性，

624
00:19:17,100 --> 00:19:18,450
0,330 330,570 570,900 900,1110 1110,1350
the second topic, {} really

625
00:19:18,450 --> 00:19:19,900
0,210 210,270 270,420 420,750
is {atomicity - -},|
|

626
00:19:22,980 --> 00:19:24,930
0,420 420,1140 1140,1440 1440,1530 1530,1950
these operations creating a file,|
这些操作创建文件，|

627
00:19:24,930 --> 00:19:25,590
0,90 90,270 270,420 420,510 510,660
{} really have to be
必须是某种原子操作，

628
00:19:25,590 --> 00:19:26,790
0,840 840,900 900,990 990,1140 1140,1200
has to be sort of

629
00:19:26,790 --> 00:19:28,260
0,60 60,450 450,1020 1020,1260 1260,1470
an atomic operation,| so they
|这样它们不会交错，

630
00:19:28,260 --> 00:19:29,400
0,210 210,390 390,870 870,1050 1050,1140
don't get interleaved,| then we
|使我们得到错误的结果。

631
00:19:29,400 --> 00:19:31,000
0,150 180,840 840,1350
get wrong results.|
|

632
00:19:32,300 --> 00:19:33,500
0,120 120,210 210,300 300,600 600,1200
And then the final problem,|
然后是最后一个问题，|

633
00:19:33,890 --> 00:19:35,120
0,390 390,900 900,1020 1020,1170 1170,1230
{} that we need to
我们需要处理的是，

634
00:19:35,120 --> 00:19:37,040
0,210 210,420 420,660 660,1140 1260,1920
deal with is that, {}|
|

635
00:19:37,040 --> 00:19:38,900
0,60 60,270 270,780 780,1290
{} {you,know} workstation 1
工作站 1 可能会崩溃，

636
00:19:40,060 --> 00:19:42,670
0,120 120,390 390,1170 1200,1890 1890,2610
{you,know} might crash,| while doing
|当执行一个复杂的文件系统操作时，

637
00:19:42,820 --> 00:19:43,930
0,240 240,330 330,480 480,870 870,1110
one of these complex file

638
00:19:43,930 --> 00:19:45,220
0,270 270,1080
system operations,|
|

639
00:19:50,160 --> 00:19:51,120
0,180 180,480 480,720 720,870 870,960
and so it has to
所以它必须有故事，

640
00:19:51,120 --> 00:19:52,290
0,120 120,660 660,720 720,900 900,1170
be story,| you know how
|文件系统是如何恢复的，

641
00:19:52,290 --> 00:19:54,390
0,450 450,720 720,1020 1020,1440 1440,2100
actually the file system recovers,|
|

642
00:19:55,140 --> 00:19:56,250
0,300 300,510 510,690 690,840 840,1110
and so this is really
所以，这是一个关于崩溃恢复的故事。

643
00:19:56,250 --> 00:19:57,660
0,60 60,360 360,600 600,870 870,1410
a story about crash recovery.|
|

644
00:20:01,990 --> 00:20:02,950
0,150 150,240 240,690 690,870 870,960
So, for example like in
比如，在第一个例子中，

645
00:20:02,950 --> 00:20:04,240
0,120 120,390 390,660 660,960 960,1290
this first case,| where like
|工作站在目录 d 中生成一个文件，

646
00:20:04,270 --> 00:20:05,980
0,450 450,1050 1050,1260 1260,1350 1350,1710
{} workstation makes a file

647
00:20:05,980 --> 00:20:07,960
0,180 180,720 720,1260 1440,1740 1740,1980
in directory d,| there's actually
|这是一个复杂的操作，

648
00:20:07,960 --> 00:20:09,310
0,30 30,450 450,1080 1080,1140 1140,1350
a complex operation,| you know
|目录需要修改，

649
00:20:09,310 --> 00:20:10,180
0,120 120,480 480,690 690,780 780,870
the directory needs to be

650
00:20:10,180 --> 00:20:11,590
0,750 750,870 870,1020 1020,1200 1200,1410
modified,| and {inode -} needs
|inode 需要分配，

651
00:20:11,590 --> 00:20:12,730
0,90 90,210 210,810 810,1050 1050,1140
to be allocated| and {inode
|inode 需要初始化，

652
00:20:12,730 --> 00:20:14,650
0,180 180,240 240,360 360,1170 1380,1920
-} to be initialized, {}|
|

653
00:20:14,650 --> 00:20:15,460
0,120 120,240 240,330 330,600 600,810
and then the inode number
然后 inode 编号需要写入目录，

654
00:20:15,460 --> 00:20:16,450
0,210 210,270 270,420 420,660 660,990
needs to be written into

655
00:20:16,450 --> 00:20:18,010
0,90 90,660 750,900 900,1050 1050,1560
the directory,| so there's multiple
|所以它涉及多种类型的文件系统操作，

656
00:20:18,010 --> 00:20:19,120
0,150 150,210 210,450 450,690 690,1110
sort of file system operations

657
00:20:19,120 --> 00:20:20,050
0,390 390,480 480,630 630,750 750,930
involved in it,| and we
|我们希望是这样的情况，

658
00:20:20,050 --> 00:20:20,830
0,270 270,330 330,420 420,510 510,780
wanted to be the case

659
00:20:20,830 --> 00:20:21,910
0,210 210,540 540,600 600,870 870,1080
that,| if the file system
|如果文件系统在任何步骤之间崩溃，

660
00:20:21,910 --> 00:20:23,800
0,480 480,870 870,1200 1200,1410 1410,1890
crashes between any of these

661
00:20:24,040 --> 00:20:25,630
0,960 1050,1260 1260,1350 1350,1530 1530,1590
steps,| in this sort of
|在这种复杂的文件系统操作中，

662
00:20:25,630 --> 00:20:27,340
0,330 330,570 570,810 810,1410 1500,1710
complex file system operation,| there
|最好是这样的情况，

663
00:20:27,340 --> 00:20:28,150
0,180 180,300 300,390 390,690 690,810
better be the case that,|
|

664
00:20:28,150 --> 00:20:29,140
0,90 90,330 330,570 570,690 690,990
the file system {recovers -}
文件系统恢复正常。

665
00:20:29,140 --> 00:20:29,720
0,510
correctly.|
|

666
00:20:30,170 --> 00:20:30,890
0,240 240,420 420,480 480,540 540,720
And what {I -} mean,|
我的意思是，|

667
00:20:30,890 --> 00:20:32,240
0,90 90,300 300,600 600,1200 1200,1350
{you,know} file {system,recover} correctly,| at
文件系统正确恢复，|至少它的内部数据结构是正确的，

668
00:20:32,240 --> 00:20:33,830
0,210 210,480 480,900 900,1140 1140,1590
least its internal data structures

669
00:20:33,830 --> 00:20:35,090
0,90 90,600 900,1110 1110,1200 1200,1260
are correct,| and so for
|比如， inode 不会丢失，

670
00:20:35,090 --> 00:20:36,080
0,330 330,600 600,720 720,840 840,990
example the {inode -} does

671
00:20:36,080 --> 00:20:37,160
0,180 180,540 540,780 780,840 840,1080
not lost,| because it doesn't
|因为它不会显示在目录中，等等，

672
00:20:37,160 --> 00:20:38,270
0,210 210,330 330,450 450,510 510,1110
show up in the directory,

673
00:20:38,570 --> 00:20:40,430
0,690 690,1200 1230,1470 1470,1620 1620,1860
etc etc,| or like even
|或者，甚至整个内部结构都是一致的，

674
00:20:40,430 --> 00:20:41,540
0,150 150,570 570,690 690,780 780,1110
the whole of the internal

675
00:20:41,540 --> 00:20:42,900
0,450 450,510 510,1140
structures are consistent,|
|

676
00:20:43,640 --> 00:20:44,450
0,180 180,360 360,420 420,510 510,810
so this is the topic
所以这是崩溃恢复的主题。

677
00:20:44,450 --> 00:20:46,460
0,90 90,390 390,930 1770,1920 1920,2010
of crash recover.| And so
|所以 Petal 在 Frangipani 需要解决所有这些问题，

678
00:20:46,460 --> 00:20:47,750
0,300 300,750 750,1020 1020,1080 1080,1290
Petal basically were in {Frangipani

679
00:20:47,750 --> 00:20:49,070
0,90 90,210 210,510 510,720 720,1320
- -} need to address

680
00:20:49,100 --> 00:20:52,010
0,420 420,750 1110,1800 1800,2250 2250,2910
all these problems,| and my
|我的计划是一个接一个地查看，

681
00:20:52,040 --> 00:20:54,710
0,330 330,540 540,990 1320,2040 2130,2670
{plan,is} just go {} walk

682
00:20:54,710 --> 00:20:55,910
0,180 180,570 600,810 810,1050 1050,1200
through in {} one by

683
00:20:55,910 --> 00:20:57,890
0,570 570,1140 1140,1500 1500,1650 1650,1980
one,| and discuss how {Frangipani
|讨论 Frangipani 如何解决这些问题。

684
00:20:57,890 --> 00:20:59,200
0,420 420,900 900,1050
-} addresses them.|
|

685
00:21:00,520 --> 00:21:01,630
0,390 390,690 690,840 840,900 900,1110
Any questions about the top
对于顶级挑战，有什么问题吗？

686
00:21:01,630 --> 00:21:02,980
0,210 210,1080
level challenges?|
|

687
00:21:09,820 --> 00:21:11,900
0,420 420,990 990,1200 1200,1770
Okay, let's {you,know} proceed.|
好的，让我们继续。|

688
00:21:12,030 --> 00:21:12,900
0,300 300,360 360,600 600,750 750,870
So the first thing is
所以，第一件事是缓存连贯性或缓存一致性。

689
00:21:12,900 --> 00:21:15,510
0,300 300,960 1290,1530 1530,1770 1770,2610
caching coherence or cache consistency.|
|

690
00:21:27,740 --> 00:21:29,120
0,570 570,1080
And, {}
所以， Frangipani 使用的解决方案中的关键方面是，

691
00:21:29,790 --> 00:21:32,610
0,330 330,960 1080,1860 1980,2670 2670,2820
so the key aspect in

692
00:21:32,610 --> 00:21:35,280
0,330 330,840 840,1290 1290,2340 2460,2670
the solution that {} {Frangipani

693
00:21:35,280 --> 00:21:36,690
0,60 60,270 270,840 840,1260 1260,1410
- -} uses| actually a
|实际上是一个锁服务器，

694
00:21:36,690 --> 00:21:37,960
0,240 240,540 540,990
lock server somewhere,|
|

695
00:21:38,580 --> 00:21:40,360
0,1110
{and,so},
锁服务器有一个表，

696
00:21:40,670 --> 00:21:43,100
0,360 360,450 450,660 660,1320
and the lock server

697
00:21:43,790 --> 00:21:47,810
0,780 780,840 840,1620 2220,2790 2790,4020
{basically,has} a table,| and for
|对于每个文件的 inode 编号，

698
00:21:47,840 --> 00:21:49,340
0,270 270,660 660,930 930,1320 1320,1500
every file and actually {inode

699
00:21:49,340 --> 00:21:50,390
0,240 240,570 570,690 690,840 840,1050
-} number {} for every

700
00:21:50,390 --> 00:21:51,220
0,570
file,|
|

701
00:21:51,760 --> 00:21:53,710
0,1110 1110,1410 1410,1530 1530,1860 1860,1950
who has to lock at
谁必须在这个时间点加锁，

702
00:21:53,710 --> 00:21:54,850
0,150 150,660 660,840 840,900 900,1140
this particular point of time,|
|

703
00:21:54,850 --> 00:21:56,140
0,150 150,360 360,480 480,930
so who's the owner.|
谁是拥有者。|

704
00:21:58,070 --> 00:21:58,850
0,300 300,390 390,600 600,690 690,780
So we might have a
所以我们可能有文件 f ，

705
00:21:58,850 --> 00:22:00,140
0,300 300,630 660,810 810,930 930,1290
file f| and it basically
|它表示工作站，

706
00:22:00,140 --> 00:22:01,370
0,330 330,420 420,570 570,900 900,1230
says you know {workstation -}

707
00:22:01,370 --> 00:22:03,200
0,90 90,570 1110,1380 1380,1530 1530,1830
for which,| the lock server
|锁服务器有一个记录，

708
00:22:03,200 --> 00:22:04,070
0,150 150,210 210,540 540,630 630,870
has a record| of the
|工作站 1 拥有那把锁，

709
00:22:04,070 --> 00:22:05,840
0,480 480,840 840,1080 1080,1230 1230,1770
workstation 1 owns that particular

710
00:22:05,840 --> 00:22:08,480
0,450 1200,1800 1800,2280 2280,2340 2340,2640
lock,| {} and the {lock,server
|锁服务本身是一个分布式服务，

711
00:22:08,480 --> 00:22:10,220
0,120 120,180 180,870 930,1200 1200,1740
- -} itself {} is

712
00:22:10,220 --> 00:22:13,580
0,150 150,1020 1050,1830 1830,2430 3150,3360
a distributed {} service, {}|
|

713
00:22:13,580 --> 00:22:14,690
0,240 240,360 360,630 630,780 780,1110
you can almost think about
你可以把它大致想象成 zookeeper ，

714
00:22:14,690 --> 00:22:16,280
0,480 480,900 900,1020 1020,1200 1200,1590
it almost like {zookeeper -},|
|

715
00:22:16,310 --> 00:22:19,040
0,870 870,1110 1560,2160 2160,2310 2310,2730
{you,know} it, {} it provides
它提供获取释放锁，

716
00:22:19,040 --> 00:22:21,410
0,150 150,660 660,1020 1020,1710 1800,2370
{} acquire release locks, {}|
|

717
00:22:21,410 --> 00:22:23,300
0,330 330,570 570,1260 1260,1530 1530,1890
it's fault tolerant,| {} in
它是容错的，|在 Frangipani 的情况，

718
00:22:23,300 --> 00:22:24,650
0,60 60,330 330,600 600,1140 1170,1350
the case of {} {Frangipani

719
00:22:24,650 --> 00:22:26,060
0,360 360,600 600,840 840,930 930,1410
-},| that use {} {Paxos
|使用的是基于 Paxos 的实现，

720
00:22:26,060 --> 00:22:29,000
0,480 510,1050 1050,1860 2190,2670 2670,2940
-} based implementation,| {} and
|分布在多台机器上，高容错性等。

721
00:22:29,000 --> 00:22:30,530
0,150 150,390 420,840 840,1170 1170,1530
what {you,know} spread across multiple

722
00:22:30,530 --> 00:22:33,080
0,660 720,1260 1260,1590 1590,1770 1770,2550
machines, {} highly fault tolerance,

723
00:22:33,230 --> 00:22:34,900
0,1110 1110,1590
etc, etc.|
|

724
00:22:36,390 --> 00:22:39,540
0,270 270,540 540,1200 1290,2010 2310,3150
So that's the the the
所以，这是锁服务器，

725
00:22:39,630 --> 00:22:41,550
0,540 570,990 1230,1410 1410,1710 1710,1920
lock server,| and it turns
|事实证明，

726
00:22:41,550 --> 00:22:42,420
0,90 90,210 210,300 300,540 540,870
out,| that the {workstation -}
|工作站也应该为它们的锁维护一张表，

727
00:22:42,420 --> 00:22:44,070
0,210 210,570 570,900 900,990 990,1650
should also keep a table

728
00:22:44,310 --> 00:22:45,680
0,870
for

729
00:22:46,040 --> 00:22:47,960
0,300 300,930 1380,1590 1590,1710 1710,1920
their locks,| so {here's -}
|这是工作站 1 ，

730
00:22:47,960 --> 00:22:50,060
0,480 480,990 1230,1860 1860,1950 1950,2100
workstation 1,| and you know
|这可能是，

731
00:22:50,060 --> 00:22:51,050
0,90 90,300 300,720 750,870 870,990
it might be,| you know
|假设工作站 1 缓存文件 f 和 g ，

732
00:22:51,050 --> 00:22:52,700
0,180 180,450 450,870 870,1050 1050,1650
let's say workstation 1 cache

733
00:22:52,700 --> 00:22:55,180
0,390 420,1140 1140,1290 1290,1740
file f and g,|
|

734
00:22:55,920 --> 00:22:57,420
0,270 270,630 630,1080 1080,1410 1410,1500
{you,know} maybe h cached by
可能 h 缓存在工作站 1 ，

735
00:22:57,420 --> 00:23:00,510
0,810 1380,2190 2190,2820 2820,2970 2970,3090
workstation {workstation,1},| h {maybe -}
|h 可能缓存在工作站 2 ，

736
00:23:00,510 --> 00:23:02,160
0,330 330,390 390,870 870,1350
cached by workstation 2,|
|

737
00:23:02,700 --> 00:23:04,590
0,540 780,930 930,1320 1320,1440 1440,1890
{} and then the workstation
然后工作站 1 有一张类似的表，

738
00:23:04,590 --> 00:23:06,270
0,300 300,750 750,840 840,1140 1140,1680
1 has a similar table,|
|

739
00:23:06,450 --> 00:23:08,550
0,480 480,1020 1050,1500 1500,1830 1830,2100
and that list for every
列举了它所持有的每个锁，

740
00:23:08,550 --> 00:23:09,990
0,600 600,720 720,900 900,1260 1260,1440
file, for every lock that

741
00:23:09,990 --> 00:23:12,210
0,720 750,1290 1290,1470 1470,1740 1740,2220
holds,| where it's either busy
|它是忙的还是闲的，

742
00:23:12,210 --> 00:23:15,060
0,240 240,720 2160,2490 2490,2700 2700,2850
or idle,| so it {maybe
|可能 f 的锁状态是忙的，

743
00:23:15,060 --> 00:23:17,520
0,180 180,480 510,600 600,1890 1920,2460
-} f you know lock

744
00:23:17,520 --> 00:23:18,960
0,330 330,450 450,990 1170,1320 1320,1440
status is busy,| and it
|这意味着文件服务器在操作那个文件，

745
00:23:18,960 --> 00:23:20,340
0,270 270,600 600,810 810,1170 1170,1380
really means that actually the

746
00:23:20,340 --> 00:23:21,720
0,240 240,510 510,660 660,900 900,1380
file server is just operating

747
00:23:21,720 --> 00:23:22,770
0,90 90,270 270,660 690,870 870,1050
on that file,| so it's
|所以，它正在使用那个文件，

748
00:23:22,770 --> 00:23:26,280
0,630 630,960 960,1110 1110,1530 2190,3510
actually using that {file -},|
|

749
00:23:26,280 --> 00:23:28,230
0,180 180,480 480,960 990,1590 1590,1950
the second state namely,| let's
第二种状态是，|假设文件 g 也缓存在这里，

750
00:23:28,230 --> 00:23:29,220
0,120 120,270 270,420 420,840 840,990
say we have {file,g}, which

751
00:23:29,220 --> 00:23:30,660
0,210 210,480 480,840 1050,1200 1200,1440
also cache there,| and maybe
|g 可能在闲的状态，

752
00:23:30,660 --> 00:23:32,310
0,180 180,300 300,810 810,990 990,1650
g is actually {} {in,the,state}

753
00:23:32,310 --> 00:23:34,350
0,570 570,750 750,1260 1620,1800 1800,2040
that call idle,| {} that
|这意味着， g 在这一时刻没有被修改，

754
00:23:34,350 --> 00:23:35,910
0,330 330,690 690,900 900,1440 1440,1560
means actually the g at

755
00:23:35,910 --> 00:23:36,780
0,180 180,390 390,480 480,660 660,870
that point is not being

756
00:23:36,780 --> 00:23:39,360
0,750 750,930 930,930 2070,2400 2400,2580
modified,| and {} were not
|在那个瞬时时间，没有被文件处理，

757
00:23:39,360 --> 00:23:41,370
0,420 630,1170 1170,1740 1740,1890 1890,2010
being worked on by the

758
00:23:41,370 --> 00:23:42,750
0,330 330,540 540,720 720,1020 1020,1380
files, for that particular instant

759
00:23:42,750 --> 00:23:44,490
0,450 720,1020 1020,1200 1200,1350 1350,1740
time,| {} but it's basically
|但这就是他们所说的粘锁。

760
00:23:44,490 --> 00:23:45,330
0,240 240,390 390,510 510,780 780,840
{} what they call a

761
00:23:45,330 --> 00:23:46,280
0,360 360,720
sticky lock.|
|

762
00:23:47,480 --> 00:23:48,980
0,300 300,570 570,1140 1170,1290 1290,1500
So that if you know
所以，如果文件服务器在某个时刻[]，

763
00:23:48,980 --> 00:23:50,060
0,180 180,450 450,780 780,900 900,1080
the file server at some

764
00:23:50,060 --> 00:23:51,770
0,240 240,960 960,1080 1080,1320 1320,1710
point [],| it's gonna use
|它将再次使用文件 g ，

765
00:23:51,770 --> 00:23:53,300
0,450 450,870 1020,1170 1170,1290 1290,1530
{file,g} again,| it can actually
|它可以这样做，

766
00:23:53,300 --> 00:23:54,470
0,180 180,510 510,780 780,990 990,1170
do so,| without actually having
|不必与 Petal 通信，

767
00:23:54,470 --> 00:23:56,090
0,60 60,570 570,690 690,1290 1410,1620
to communicate with Petal| or
|或者重新加载缓存或任何类似的东西，

768
00:23:56,090 --> 00:23:57,560
0,420 420,540 540,1020 1020,1140 1140,1470
reload it's cache or anything

769
00:23:57,560 --> 00:23:59,060
0,330 330,420 420,720 720,1110 1170,1500
like that at all,| because
|因为它有一个粘锁，

770
00:23:59,060 --> 00:24:00,110
0,90 90,330 330,390 390,720 720,1050
it has a sticky lock,|
|

771
00:24:00,110 --> 00:24:01,490
0,150 150,660 660,780 780,1110 1110,1380
it knows that nobody else
它知道没有其他（工作站）获取，

772
00:24:01,490 --> 00:24:02,690
0,210 210,390 390,840 840,990 990,1200
actually has required,| no other
|在这期间，没有其他工作站获取锁。

773
00:24:02,690 --> 00:24:04,040
0,210 210,540 540,660 660,1260 1260,1350
{workstation -} has required the

774
00:24:04,040 --> 00:24:05,180
0,270 270,330 330,420 420,930
lock in the meantime.|
|

775
00:24:06,060 --> 00:24:07,890
0,360 360,690 780,1260 1260,1440 1440,1830
{} So that's the sticky
所以，这是粘锁，

776
00:24:07,890 --> 00:24:09,600
0,450 870,1320 1320,1410 1410,1620 1620,1710
lock| and it turns out
|事实证明，

777
00:24:09,600 --> 00:24:13,320
0,330 450,1500 1650,2490 2970,3570 3600,3720
that,| the the {} you
|这是两种[]的锁，

778
00:24:13,320 --> 00:24:14,610
0,60 60,270 270,660 660,930 930,1290
know these are two building

779
00:24:14,610 --> 00:24:15,930
0,450 450,810 810,930 930,1110 1110,1320
locks,| that are then being
|用于他们所说的，

780
00:24:15,930 --> 00:24:17,250
0,420 420,570 570,840 840,990 990,1320
used to what they call,|
|

781
00:24:17,250 --> 00:24:18,930
0,570 570,780 780,1170 1170,1260 1260,1680
what's {} what is called
所说的缓存一致性协议。

782
00:24:18,930 --> 00:24:21,390
0,630 840,1350 1350,1680 1680,2160 2160,2460
{} cache coherence protocol.| And
|一套信息或一套规则被遵守，

783
00:24:21,540 --> 00:24:22,800
0,210 210,300 300,810 810,1110 1110,1260
set of messages or set

784
00:24:22,800 --> 00:24:23,640
0,90 90,420 420,540 540,600 600,840
of rules that are being

785
00:24:23,640 --> 00:24:25,440
0,540 720,960 960,1380 1380,1530 1530,1800
followed| to actually {} get
|来获得缓存一致性，

786
00:24:25,440 --> 00:24:27,900
0,240 240,960 1380,1950 1950,2070 2070,2460
cache consistency,| and the basic
|基本规则是，

787
00:24:27,900 --> 00:24:30,030
0,330 330,510 510,900 1200,1980 1980,2130
rule is that,| {} you
|指导原则是，

788
00:24:30,030 --> 00:24:32,310
0,300 510,1110 1110,1440 1440,1770 1770,2280
know guiding rule is| to
|为了缓存一个文件，

789
00:24:32,670 --> 00:24:33,740
0,360 360,450 450,990
cache a file,|
|

790
00:24:38,890 --> 00:24:40,390
0,420 420,720 720,990 990,1410 1410,1500
you first must acquire a
你首先必须获取一把锁，

791
00:24:40,390 --> 00:24:41,640
0,450
lock,|
|

792
00:24:43,670 --> 00:24:45,710
0,210 210,390 390,1050 1050,1770 1770,2040
you'll see that rules {}
你会看到这些规则是垫脚石，

793
00:24:45,710 --> 00:24:48,740
0,1320 1320,1500 1500,1740 1740,2190 2430,3030
{stepping,stone}| for actually getting {}
|来获得缓存一致性或缓存连贯性。

794
00:24:48,800 --> 00:24:51,050
0,240 240,1320 1320,1410 1410,1710 1710,2250
cache consistency or cache coherence.|
|

795
00:24:52,260 --> 00:24:53,010
0,150 150,450 450,510 510,660 660,750
I'm going to make a
我要做一个小的简化，

796
00:24:53,010 --> 00:24:56,130
0,690 690,1560 1650,2550 2550,2970 2970,3120
small simplification,| {} in the
|在论文中，

797
00:24:56,130 --> 00:24:57,240
0,330 330,420 420,840 840,990 990,1110
paper,| they describe {you,know -}
|他们描述的锁是排它的或读写锁。

798
00:24:57,240 --> 00:24:59,370
0,390 390,780 780,1080 1080,1710 1710,2130
locks basically being exclusive or

799
00:24:59,370 --> 00:25:00,660
0,240 240,390 390,690 690,780 780,1290
{} {read-write -} {} locks,|
|

800
00:25:00,780 --> 00:25:01,740
0,390 390,510 510,630 630,690 690,960
I'm just going to assume,|
我会假设，|

801
00:25:01,740 --> 00:25:02,700
0,510 540,660 660,840 840,900 900,960
for the rest of the
在接下来的课程中，

802
00:25:02,700 --> 00:25:04,020
0,420 420,510 510,1050 1080,1140 1140,1320
lecture,| the [exclusive] it doesn't
|[排它的]并不重要，

803
00:25:04,020 --> 00:25:05,160
0,150 150,480 510,690 690,1050 1050,1140
really matter,| but there's an
|但这是一种优化，

804
00:25:05,160 --> 00:25:07,710
0,660 660,900 900,1050 1050,1650 1800,2550
optimization,| based on multiple workstations
|多个工作站可以在只读模式下拥有文件缓存。

805
00:25:07,710 --> 00:25:09,240
0,120 120,480 480,660 660,930 930,1530
can have a file cache

806
00:25:09,300 --> 00:25:10,600
0,270 270,630 630,1170
in read-only mode.|
|

807
00:25:12,530 --> 00:25:14,090
0,300 300,750 1050,1200 1200,1440 1440,1560
Okay, so with that,| let
好的，所以有了这个，|让我简单地谈一下，

808
00:25:14,090 --> 00:25:14,660
0,90 90,240 240,300 300,450 450,570
me talk a little bit

809
00:25:14,660 --> 00:25:16,670
0,270 270,780 900,1530 1530,1830 1830,2010
about,| {} let's catch out
|我们来了解一下 Frangipani 使用的协议。

810
00:25:16,670 --> 00:25:19,440
0,90 90,750
the protocol

811
00:25:19,710 --> 00:25:21,500
0,360 360,600 600,810 810,1530
that {Frangipani -} uses.|
|

812
00:25:22,010 --> 00:25:23,810
0,540 720,960 960,1320 1320,1410 1410,1800
{} And again you know
同样的，缓存连贯性或缓存一致性，

813
00:25:23,870 --> 00:25:26,360
0,330 330,960 960,1200 1200,1500 1500,2490
cache coherence or cache {consistency

814
00:25:26,600 --> 00:25:29,780
0,1530 1530,1950 1950,2460 2460,2970 2970,3180
-},| {the,goal} actually for even
|即使分布式文件系统的目标，

815
00:25:29,780 --> 00:25:31,340
0,120 120,240 240,480 480,810 810,1560
though the file systems distributed,|
|

816
00:25:31,580 --> 00:25:32,930
0,240 240,450 450,900 900,1110 1110,1350
it should behave like a
它应该像单个文件系统一样，

817
00:25:32,930 --> 00:25:34,550
0,600 600,900 900,1290 1290,1470 1470,1620
single file system,| so you
|你只有一台文件服务器，

818
00:25:34,550 --> 00:25:36,050
0,210 210,330 330,540 540,840 840,1500
only have one file server,|
|

819
00:25:36,050 --> 00:25:37,280
0,270 270,510 510,600 600,1020 1020,1230
you want to basically the
你希望有相同的结果

820
00:25:37,280 --> 00:25:39,290
0,630 750,1440 1440,1530 1530,1620 1620,2010
same results| will be returned
|由分布式文件系统返回的（结果），

821
00:25:39,290 --> 00:25:40,610
0,120 120,240 240,690 690,930 930,1320
by the distributed file system,|
|

822
00:25:41,000 --> 00:25:41,750
0,210 210,300 300,510 510,690 690,750
so you can't tell the
你不能区分它是不是分布式的，

823
00:25:41,750 --> 00:25:42,830
0,330 330,510 510,630 630,1020 1020,1080
difference whether it's distributed or

824
00:25:42,830 --> 00:25:45,200
0,360 930,1440 1590,1830 1830,2070 2070,2370
not,| and so this is
|所以这提醒我线性一致性，

825
00:25:45,200 --> 00:25:46,250
0,60 60,180 180,450 450,660 660,1050
{} {you,know} remind me of

826
00:25:46,250 --> 00:25:47,540
0,300 300,540 540,960 960,1170 1170,1290
{} {linearizability -},| so in
|事实上，我相信 Frangipani 的目标，

827
00:25:47,540 --> 00:25:49,100
0,330 330,390 390,780 780,1290 1380,1560
fact, you know I I

828
00:25:49,100 --> 00:25:50,540
0,300 300,570 570,960 960,1170 1170,1440
believe actually what {Frangipani -

829
00:25:50,540 --> 00:25:53,120
0,780 1290,1830 1830,2100 2100,2430 2430,2580
-} {} shoot for,| it's
|它是可线性化的文件系统操作。

830
00:25:53,120 --> 00:25:54,320
0,300 300,600 600,780 780,990 990,1200
actually {linearizable - -} file

831
00:25:54,320 --> 00:25:55,360
0,360 360,960
system operations.|
|

832
00:25:56,200 --> 00:25:57,760
0,540 630,1200 1260,1380 1380,1500 1500,1560
Okay, so we got the
好的，我们有锁服务器，

833
00:25:57,760 --> 00:25:58,960
0,300 300,780
lock server,|
|

834
00:26:00,790 --> 00:26:02,380
0,330 330,540 540,690 690,1110 1110,1590
{} we got workstation 1,|
我们工作站 1 ，|

835
00:26:04,200 --> 00:26:06,480
0,360 360,510 510,960 960,1260
and there's workstation 2.|
以及工作站 2 。|

836
00:26:07,600 --> 00:26:09,400
0,630 660,1140 1140,1290 1290,1530 1530,1800
And {} there {sort,of} four
这里有四个重要的信息，

837
00:26:09,400 --> 00:26:11,050
0,540 540,750 750,930 930,1380 1380,1650
messages that are important here,|
|

838
00:26:11,050 --> 00:26:13,090
0,270 270,960 960,1470 1470,1560 1560,2040
there's namely requesting a lock,
也就是请求锁，授予锁，

839
00:26:13,390 --> 00:26:16,000
0,780 780,870 870,1380 1710,2160 2160,2610
granting a lock| and revoking
|撤销锁，释放锁，

840
00:26:16,000 --> 00:26:17,800
0,90 90,600 630,1110 1110,1350 1350,1800
a lock and actually releasing

841
00:26:17,800 --> 00:26:18,460
0,90 90,330 330,420 420,600 600,660
the lock,| so those are
|这就是往返传递的四条信息，

842
00:26:18,460 --> 00:26:20,170
0,60 60,330 330,780 780,900 900,1710
the four messages that fly

843
00:26:20,170 --> 00:26:21,790
0,510 510,720 720,810 810,1050 1050,1620
between back and forth,| between
|在工作站和锁服务器，

844
00:26:22,000 --> 00:26:24,190
0,720 720,870 870,1440 1440,1560 1560,2190
workstations and {lock,server}| and {lock,server}
|以及锁服务器和其他工作站之间。

845
00:26:24,190 --> 00:26:26,470
0,120 120,300 300,1080 1620,2070 2100,2280
and other workstations.| So let's
|让我们来看看这个，

846
00:26:26,470 --> 00:26:27,640
0,450 450,570 570,810 810,990 990,1170
look at this,| let's say
|假设锁服务器有，

847
00:26:27,640 --> 00:26:30,370
0,420 420,690 690,1410 2190,2580 2580,2730
lock server has,| nobody has
|任何时候都没有人有锁，

848
00:26:30,370 --> 00:26:31,660
0,180 180,480 480,600 600,900 900,1290
any locks at any time,|
|

849
00:26:31,660 --> 00:26:33,220
0,150 150,420 420,630 630,750 750,1560
so let's draw some timelines,|
所以让我们画一些时间线，|

850
00:26:33,910 --> 00:26:36,100
0,450 450,960 960,1290 1290,1560 1560,2190
and workstation 1 wants to
工作站 1 想要请求，

851
00:26:36,130 --> 00:26:37,500
0,1200
request,|
|

852
00:26:38,080 --> 00:26:40,210
0,390 390,480 480,840 840,1380 1440,2130
wants to read write {}
希望读写文件 f ，

853
00:26:40,210 --> 00:26:42,220
0,360 360,720 1020,1170 1170,1680 1680,2010
file f,| {you,know} basically sends
|发送一个锁请求，

854
00:26:42,220 --> 00:26:43,570
0,240 240,630 630,780 780,840 840,1350
a request for a lock,|
|

855
00:26:43,600 --> 00:26:44,650
0,150 150,390 390,510 510,720 720,1050
{you,know} to the lock server
到锁服务器，为了文件 f ，

856
00:26:44,650 --> 00:26:45,760
0,180 180,510 510,870
for file f,|
|

857
00:26:46,580 --> 00:26:48,530
0,630 630,1170 1350,1620 1620,1830 1830,1950
so workstation that can't do
所以是工作站现在还不能做任何事情，

858
00:26:48,530 --> 00:26:49,520
0,330 330,540 540,630 630,780 780,990
anything really at this point

859
00:26:49,520 --> 00:26:51,170
0,330 600,1020 1020,1200 1200,1410 1410,1650
yet,| {} the lock server
|锁服务器检查它的表，

860
00:26:51,170 --> 00:26:52,910
0,240 240,660 660,870 870,990 990,1740
{you,know} checks {} it's table,|
|

861
00:26:53,180 --> 00:26:54,530
0,300 300,540 540,690 690,930 930,1350
and sees that f actually
发现 f 没有人使用，

862
00:26:54,530 --> 00:26:55,790
0,180 180,570 570,750 750,870 870,1260
is not used by anybody

863
00:26:55,790 --> 00:26:57,500
0,90 90,540 540,780 780,1200 1200,1710
at all,| {you,know} list workstation
|将工作站 1 列为锁持有者，

864
00:26:57,500 --> 00:26:59,360
0,420 420,660 660,930 930,1230 1230,1860
1 as the lock owner,|
|

865
00:26:59,420 --> 00:27:01,670
0,300 300,630 630,930 930,1440 1470,2250
sends basically message back {and,granting}
发回消息，授予 f 锁，

866
00:27:03,780 --> 00:27:05,220
0,120 120,450 450,630 630,1110
the lock for f,|
|

867
00:27:06,160 --> 00:27:08,110
0,150 150,210 210,360 360,900 1200,1950
so at this point, workstation
所以，在这个时刻，工作站 1 获得 f 锁，

868
00:27:08,110 --> 00:27:09,940
0,690 930,1320 1320,1410 1410,1710 1710,1830
1 requires the lock for

869
00:27:09,940 --> 00:27:11,050
0,300 330,660 660,750 750,870 870,1110
f,| now it can actually
|现在它可以读或写，

870
00:27:11,050 --> 00:27:12,100
0,240 240,360 360,720 720,930 930,1050
read or write,| where now
|现在它可以从 Petal 读取文件，

871
00:27:12,100 --> 00:27:13,270
0,120 120,210 210,450 450,840 840,1170
it can actually read the

872
00:27:13,270 --> 00:27:15,220
0,330 330,480 480,990
file from Petal,|
|

873
00:27:18,660 --> 00:27:20,970
0,630 840,1260 1260,1380 1380,1650 1650,2310
{} actually can make modifications
其实也可以对它进行修改，

874
00:27:20,970 --> 00:27:22,140
0,120 120,270 270,690 780,990 990,1170
to it too,| now those
|现在这些修改保留在本地，什么都没有发生，

875
00:27:22,140 --> 00:27:24,630
0,660 660,960 1020,1350 1350,1890 1980,2490
modifications just stay local, nothing

876
00:27:24,630 --> 00:27:26,040
0,180 180,510 510,690 690,990 990,1410
really happens,| is a {write-back
|是一个写会缓存，而不是直写缓存，

877
00:27:26,130 --> 00:27:27,510
0,630 630,900 900,1080 1080,1140 1140,1380
-} cache, not a {write-through

878
00:27:27,510 --> 00:27:28,340
0,150 150,660
-} cache,|
|

879
00:27:28,600 --> 00:27:29,560
0,150 150,240 240,330 330,720 720,960
and so it just stays
所以，它只是留在客户端。

880
00:27:29,560 --> 00:27:31,240
0,480 480,720 720,810 810,1620 1620,1680
happily on the on the

881
00:27:31,240 --> 00:27:32,280
0,330 330,750
client side.|
|

882
00:27:32,640 --> 00:27:33,750
0,300 300,420 420,630 630,720 720,1110
{} In fact, the workstation
事实上，工作站甚至可以释放锁，

883
00:27:33,750 --> 00:27:35,370
0,90 90,180 180,600 840,1530 1530,1620
{} can even release the

884
00:27:35,370 --> 00:27:36,690
0,480 510,600 600,720 720,1170 1170,1320
lock,| you know here in
|在这里从忙变为闲，

885
00:27:36,690 --> 00:27:38,280
0,450 750,960 960,1110 1110,1440 1440,1590
basically go from busy to

886
00:27:38,280 --> 00:27:39,140
0,540
idle,|
|

887
00:27:42,370 --> 00:27:44,170
0,270 270,450 450,660 660,1200 1410,1800
and so it actually {}
所以，它需要再次加锁，

888
00:27:44,170 --> 00:27:45,190
0,240 240,420 420,510 510,720 720,1020
would need to lock again,|
|

889
00:27:45,190 --> 00:27:46,420
0,60 60,390 390,600 600,930 930,1230
for example once write after
例如，写入之后再次写入，

890
00:27:46,420 --> 00:27:48,160
0,540 540,1020 1020,1200 1200,1410 1410,1740
write again,| we can actually
|我们可以完全在本地操作，

891
00:27:48,160 --> 00:27:49,510
0,150 150,240 240,630 630,990 990,1350
do the complete local| without
|而不用与锁服务器交互。

892
00:27:49,510 --> 00:27:51,490
0,240 240,930 1080,1650 1650,1740 1740,1980
any interaction with the lock

893
00:27:51,490 --> 00:27:52,180
0,420
server.|
|

894
00:27:52,710 --> 00:27:54,420
0,180 180,240 240,540 540,1140 1140,1710
That's a slight simplification here,|
这是一个轻微的简化，|

895
00:27:54,420 --> 00:27:55,230
0,300 300,480 480,690 690,750 750,810
{you,know,actually} we'll see in a
稍后我们会看到，

896
00:27:55,230 --> 00:27:56,880
0,420 450,690 690,900 1140,1470 1470,1650
second,| that the lock has
|锁绑定一个租期，

897
00:27:56,880 --> 00:27:58,260
0,390 390,930 930,1110 1110,1230 1230,1380
{a,lease} associated with it,| so
|所以客户端至少要定期更新租期，

898
00:27:58,260 --> 00:27:59,040
0,60 60,360 360,450 450,630 630,780
the client at least has

899
00:27:59,040 --> 00:28:00,660
0,90 90,510 510,600 600,870 870,1620
to refresh the lease periodically,|
|

900
00:28:00,750 --> 00:28:02,220
0,240 240,300 300,540 540,660 660,1470
but it doesn't have to
但它不必从 Petal 重新读取文件 f ，

901
00:28:02,250 --> 00:28:04,800
0,1140 1260,1590 1590,2010 2010,2220 2220,2550
{read,write,or,reread} the file f from

902
00:28:04,800 --> 00:28:05,720
0,300 300,690
actually Petal,|
|

903
00:28:06,120 --> 00:28:07,500
0,210 210,300 300,510 510,750 750,1380
if the lease has expired.|
如果租期已到。|

904
00:28:08,880 --> 00:28:10,320
0,330 330,690 810,990 990,1260 1260,1440
Okay, so the instant case
好的，所以会发生的情况，

905
00:28:10,320 --> 00:28:11,490
0,60 60,240 240,630 630,870 870,1170
of course happens,| like what
|例如，如果工作站 2 想要读取文件 f ，

906
00:28:11,490 --> 00:28:13,860
0,270 270,840 840,1410 1620,2130 2130,2370
if workstation 2 wants to

907
00:28:13,860 --> 00:28:15,780
0,480 510,900 900,1050 1050,1530 1530,1920
read {} the file f,|
|

908
00:28:15,930 --> 00:28:17,010
0,450 660,780 780,840 840,990 990,1080
so you know what will
会发生什么情况，

909
00:28:17,010 --> 00:28:18,270
0,270 270,480 480,480 480,1020 1020,1260
happen,| with {} workstation 2
|工作站 2 想要读取，

910
00:28:18,270 --> 00:28:19,200
0,180 180,270 270,510 510,630 630,930
want to read,| and basically
|基本上它也会做同样的事情，

911
00:28:19,200 --> 00:28:19,830
0,120 120,210 210,330 330,390 390,630
it will do the same

912
00:28:19,830 --> 00:28:21,540
0,180 180,270 270,600 630,1170 1320,1710
thing,| it will send {}
|它会发送获取或请求消息，

913
00:28:21,540 --> 00:28:24,240
0,930 930,1110 1110,1380 1380,1980 2250,2700
acquire or request message,| request
|向锁服务器的请求消息，

914
00:28:24,240 --> 00:28:26,310
0,390 390,780 1080,1650 1650,1800 1800,2070
message to {lock,server -},| saying
|表示我想要 f ，

915
00:28:26,310 --> 00:28:27,140
0,90 90,300 300,690
I want f,|
|

916
00:28:27,790 --> 00:28:28,660
0,120 120,180 180,330 330,540 540,870
and the way it works
它的工作原理是，

917
00:28:28,660 --> 00:28:30,070
0,150 150,480 600,840 840,1020 1020,1410
is that,| the lock server
|锁服务器查看这个表，

918
00:28:30,070 --> 00:28:31,900
0,540 660,1230 1230,1320 1320,1470 1470,1830
actually looks at this table,|
|

919
00:28:31,900 --> 00:28:33,400
0,270 270,510 510,840 840,930 930,1500
sees the f is actually
看到 f 归工作站 1 所有，

920
00:28:33,400 --> 00:28:35,380
0,570 570,1140 1170,1380 1380,1560 1560,1980
owned by {workstation -} 1,|
|

921
00:28:35,530 --> 00:28:36,340
0,180 180,330 330,570 570,750 750,810
and then will send the
然后发送撤销消息到工作站 1 ，

922
00:28:36,340 --> 00:28:37,660
0,480 480,1080
revoke message

923
00:28:37,890 --> 00:28:40,950
0,510 510,1140 1140,1650 1920,2640 2640,3060
to workstation 1,| asking {you,know}
|想要拿回锁，

924
00:28:40,950 --> 00:28:43,860
0,450 480,900 900,1380 1560,2010 2400,2910
the lock back,| {so,that,will} {revoke,f},|
|所以这将是 revoke f ，|

925
00:28:44,520 --> 00:28:46,180
0,390 390,510 510,720 720,1350
and at this point,|
在这一点上，|

926
00:28:46,490 --> 00:28:47,750
0,630 630,960 960,1080 1080,1110 1110,1260
Petal actually do a little
Petal 实际上做得更多一点，

927
00:28:47,750 --> 00:28:49,040
0,180 180,390 390,510 510,780 990,1290
bit more of,| {} {Frangipani
|Frangipani 做得更多一点，

928
00:28:49,040 --> 00:28:50,030
0,270 270,630 630,780 780,930 930,990
-} actually little bit of

929
00:28:50,030 --> 00:28:51,740
0,420 600,1290 1290,1440 1440,1620 1620,1710
work,| because we have to
|因为我们必须确保工作站 2 观察到写入，

930
00:28:51,740 --> 00:28:53,240
0,150 150,540 540,660 660,1170 1170,1500
make sure the workstation 2

931
00:28:53,240 --> 00:28:55,370
0,570 570,690 690,1290 1380,1680 1680,2130
observes the writes,| that workstation
|工作站 1 已完成的，

932
00:28:55,370 --> 00:28:56,510
0,210 210,330 330,660 870,1050 1050,1140
1 is done,| and so
|所以这样做的方式是，

933
00:28:56,510 --> 00:28:57,290
0,90 90,240 240,480 480,570 570,780
the way that is done

934
00:28:57,290 --> 00:28:58,580
0,90 90,210 210,540 540,870 870,1290
is| that basically this instant
|在这一时刻，

935
00:28:58,580 --> 00:28:59,660
0,120 120,720
of time,|
|

936
00:29:00,700 --> 00:29:01,740
0,690

937
00:29:02,180 --> 00:29:03,500
0,150 150,540 540,780 780,1050 1050,1320
the workstation 1 writes actually
工作站 1 将 f 写入 Petal ，

938
00:29:03,500 --> 00:29:05,120
0,450 480,630 630,720 720,1020 1020,1620
f you know to Petal,|
|

939
00:29:06,020 --> 00:29:06,590
0,180 180,300 300,450 450,510 510,570
and we'll see in a
我们很快会看到，

940
00:29:06,590 --> 00:29:08,030
0,450 450,690 690,1050 1050,1350 1350,1440
second,| actually writing f to
|将 f 写到 Petal 是一个稍微复杂的操作，

941
00:29:08,030 --> 00:29:09,740
0,360 360,780 780,900 900,1200 1200,1710
Petal actually a slightly complicated

942
00:29:09,740 --> 00:29:11,300
0,570 570,750 750,1350 1350,1440 1440,1560
operations,| more sophisticated than I'm
|比我所说的更复杂，

943
00:29:11,300 --> 00:29:11,990
0,150 150,420 420,510 510,630 630,690
just making it out to

944
00:29:11,990 --> 00:29:13,220
0,360 480,720 720,840 840,1020 1020,1230
be,| but just think about
|但是考虑一下，

945
00:29:13,220 --> 00:29:14,630
0,120 120,390 390,540 540,990 1230,1410
it,| at this point,| {workstation
|在这个点上，|工作站 1 刷新它的状态到 Petal ，

946
00:29:14,630 --> 00:29:16,280
0,270 270,690 750,870 870,1200 1200,1650
-} 1 is basically flushing

947
00:29:16,280 --> 00:29:17,780
0,120 120,510 510,870 870,960 960,1500
its states really to f,

948
00:29:17,810 --> 00:29:18,940
0,240 240,450 450,930
{} to Petal,|
|

949
00:29:19,580 --> 00:29:21,290
0,510 510,690 690,1050 1050,1500 1500,1710
once that actually completed,| so
一旦这项工作完成，|一旦 Petal 确认，

950
00:29:21,290 --> 00:29:22,910
0,240 240,540 540,900 900,1020 1020,1620
like once Petal are acknowledged,|
|

951
00:29:22,910 --> 00:29:24,080
0,120 120,390 390,540 540,840 840,1170
that actually it actually has
它已经收到了所有的数据，

952
00:29:24,080 --> 00:29:25,460
0,360 360,420 420,510 510,990 1170,1380
received all the data,| and
|并发回一条消息， release f ，

953
00:29:25,460 --> 00:29:26,840
0,300 300,540 540,570 570,870 870,1380
actually sends a message back,

954
00:29:26,960 --> 00:29:28,200
0,510 510,930
release f,|
|

955
00:29:32,100 --> 00:29:33,540
0,480 480,600 600,690 690,990 990,1440
and you know once {lock,server}
一旦锁服务器得到 release f ，

956
00:29:33,540 --> 00:29:34,830
0,240 240,360 360,750 750,870 870,1290
gets the release of f,|
|

957
00:29:34,860 --> 00:29:35,820
0,90 90,180 180,330 330,450 450,960
you know that can update
它可以更新它的表，

958
00:29:35,820 --> 00:29:37,530
0,330 330,990 990,1230 1230,1650 1650,1710
its table| and allocate the
|并将锁分配给工作站 2 ，

959
00:29:37,530 --> 00:29:40,200
0,330 330,420 420,1230 1380,1980 2160,2670
lock the workstation 2| and
|发送 grant f 给 2 。

960
00:29:40,200 --> 00:29:43,350
0,510 510,660 660,870 870,1500 2700,3150
sends {you,know} a grant for

961
00:29:43,350 --> 00:29:44,500
0,360 390,540 540,900
f to 2.|
|

962
00:29:45,070 --> 00:29:45,980
0,390
Oops.|
糟糕。|

963
00:29:52,420 --> 00:29:54,130
0,150 150,210 210,360 360,840 870,1710
And at this point, {}|
在这一点上，|

964
00:29:54,160 --> 00:29:56,200
0,510 510,900 900,1440 1440,1860 1860,2040
workstation 2 requires lock,| and
工作站 2 获得锁，|现在它可以读取 Petal 中 f 文件中的所有信息，

965
00:29:56,200 --> 00:29:58,030
0,270 270,540 540,690 690,990 990,1830
now it can actually read

966
00:29:58,030 --> 00:29:59,560
0,120 120,240 240,1050 1050,1320 1350,1530
all the information from the

967
00:29:59,560 --> 00:30:01,150
0,270 270,480 480,960 1140,1410 1410,1590
file f Petal,| at that
|在这一点上，可以保证我们将看到文件 f 的最新变化，

968
00:30:01,150 --> 00:30:02,800
0,240 240,360 360,510 510,1380 1410,1650
point it is guaranteed that

969
00:30:02,800 --> 00:30:04,630
0,180 180,660 690,870 870,1230 1230,1830
we'll see the latest changes

970
00:30:04,870 --> 00:30:07,060
0,630 930,1440 1440,1590 1590,1920 1920,2190
to {} the file f,|
|

971
00:30:07,060 --> 00:30:09,490
0,690 810,1260 1260,1620 1620,2010 2010,2430
because the previous owner must
因为之前的拥有者肯定已经把状态刷新到 Petal ，

972
00:30:09,490 --> 00:30:11,020
0,180 180,750 840,930 930,1440 1440,1530
have flushed the state you

973
00:30:11,020 --> 00:30:14,020
0,120 120,480 480,1050 1380,2070 2280,3000
know to the {} Petal,|
|

974
00:30:14,110 --> 00:30:15,820
0,810 810,900 900,1260 1260,1620 1620,1710
before it actually released the
在它释放锁，并将其返回给锁服务器之前，

975
00:30:15,820 --> 00:30:16,690
0,300 300,420 420,570 570,630 630,870
lock and gave it back

976
00:30:16,690 --> 00:30:17,860
0,60 60,240 240,360 360,840 1020,1170
to the lock server,| and
|工作站 2 保证能观察到这些变化，

977
00:30:17,860 --> 00:30:19,360
0,540 540,750 750,870 870,1410 1410,1500
workstation 2 is guaranteed to

978
00:30:19,360 --> 00:30:21,010
0,480 480,960 960,1140 1140,1560 1560,1650
actually observe those changes,| and
|所以这就是强一致性的来源，

979
00:30:21,010 --> 00:30:22,120
0,90 90,330 330,570 570,750 750,1110
so here's where are strong

980
00:30:22,120 --> 00:30:24,220
0,510 510,780 780,990 1500,1890 1890,2100
consistency comes in,| these strong
|这些强一致性与锁管理密切相关。

981
00:30:24,220 --> 00:30:26,290
0,420 420,540 540,1320 1320,1590 1590,2070
consistency are tied to the

982
00:30:26,380 --> 00:30:27,500
0,450 450,1050
lock management.|
|

983
00:30:29,860 --> 00:30:31,460
0,210 210,480 480,690 690,990
Any questions about this?|
对于这个，有什么问题吗？|

984
00:30:34,410 --> 00:30:36,030
0,180 180,540 540,960 960,1080 1080,1620
{ -} There's a {question,in,chat}.|
在聊天中有一个问题。|

985
00:30:36,720 --> 00:30:38,060
0,810
Okay,|
好的,|

986
00:30:39,860 --> 00:30:40,940
0,240 240,510 510,690 690,810 810,1080
{} we need to write,|
我们需要写，|

987
00:30:40,940 --> 00:30:42,320
0,660 660,990 990,1050 1050,1140 1140,1380
one question in the chat,|
聊天中有一个问题，|

988
00:30:42,320 --> 00:30:43,670
0,150 150,480 480,840 840,930 930,1350
let me address the first,|
让我来谈谈第一个问题，|

989
00:30:43,910 --> 00:30:45,110
0,330 330,630 630,780 780,900 900,1200
{} we need to write
我们需要写入 Petal ，

990
00:30:45,110 --> 00:30:46,430
0,90 90,390 390,630 630,1020 1020,1320
to Petal,| when releasing both
|当释放读和写锁时，

991
00:30:46,430 --> 00:30:47,870
0,270 270,390 390,600 600,1050 1170,1440
read and write locks,| why
|为什么我们需要在释放读锁时写入 Petal ？

992
00:30:47,870 --> 00:30:48,860
0,90 90,300 300,420 420,540 540,990
do we need to write

993
00:30:48,860 --> 00:30:49,970
0,90 90,420 420,720 720,1020 1020,1110
to Petal when releasing a

994
00:30:49,970 --> 00:30:53,120
0,180 180,570 960,1590 1710,2490 2490,3150
read lock?| {} Let's ignore
|让我们忽略读写，

995
00:30:53,120 --> 00:30:55,100
0,330 330,600 600,960 960,1470 1470,1980
{} read write,| the distinction
|读和写之间的区别，

996
00:30:55,100 --> 00:30:57,470
0,540 540,840 1140,1680 1680,2100 2100,2370
between {read,and,write},| exclusive locks and
|排它锁和读写锁，

997
00:30:57,470 --> 00:30:59,810
0,180 180,390 390,930 1170,1920 1920,2340
read write locks,| {} in
|只关注排它锁，

998
00:30:59,810 --> 00:31:00,580
0,600
the,

999
00:31:00,760 --> 00:31:02,650
0,720 1050,1380 1380,1530 1530,1770 1770,1890
{} and just focus on

1000
00:31:02,650 --> 00:31:04,480
0,420 420,870 900,1020 1020,1380 1380,1830
exclusive locks,| you know read
|读取（锁）只是一个小的[应用]，

1001
00:31:04,480 --> 00:31:05,800
0,60 60,300 300,780 780,1230 1230,1320
you know {read,thing -} is

1002
00:31:05,800 --> 00:31:06,880
0,150 150,210 210,600 600,840 840,1080
just a small [app],| as
|它发生一个重要的优化，

1003
00:31:06,880 --> 00:31:08,410
0,60 60,420 420,510 510,900 900,1530
it happens an important optimization,|
|

1004
00:31:08,590 --> 00:31:09,610
0,420 420,540 540,600 600,810 810,1020
{} but it doesn't really
但它并没有明显地改变设计体系。

1005
00:31:09,610 --> 00:31:12,580
0,600 600,1560 1560,2010 2010,2310 2310,2970
change the design system dramatically.|
|

1006
00:31:17,180 --> 00:31:18,360
0,180 180,330 330,870
Any other questions?|
还有其他问题吗？|

1007
00:31:19,150 --> 00:31:20,680
0,270 270,450 450,750 750,900 900,1530
So this sort of design,
所以这种设计效率会很低，

1008
00:31:20,680 --> 00:31:22,450
0,210 210,510 510,960 990,1620 1620,1770
would be really inefficient,| if
|如果我们有两个不同的工作站，

1009
00:31:22,450 --> 00:31:23,470
0,120 120,360 360,540 540,690 690,1020
we have like two different

1010
00:31:23,470 --> 00:31:25,180
0,690 690,810 810,930 930,1200 1200,1710
workstations,| that are both modifying
|它们都在修改同一个文件。

1011
00:31:25,180 --> 00:31:27,010
0,60 60,360 360,960 1170,1590 1650,1830
the same file.| Yeah.| You
|是的。|你是让缓存来回跳动。

1012
00:31:27,010 --> 00:31:28,660
0,390 390,570 570,690 690,1050 1050,1650
just get like cache bouncing

1013
00:31:28,690 --> 00:31:30,190
0,240 240,360 360,840 870,1380 1380,1500
back and forth.| Yeah, you
|是的，如果你们是两个工作站或两个不同的工程师，

1014
00:31:30,190 --> 00:31:31,570
0,300 300,510 510,780 780,1080 1080,1380
maybe if you're two {workstations

1015
00:31:31,570 --> 00:31:33,340
0,390 390,450 450,900 900,1290 1290,1770
-} or two different engineers,|
|

1016
00:31:33,340 --> 00:31:34,780
0,540 540,750 750,900 900,1320 1320,1440
{that,server} would be banging on
那个服务器会[敲打]同一个文件，

1017
00:31:34,780 --> 00:31:35,740
0,90 90,330 330,780 780,840 840,960
the same file,| you know
|这个文件会来回跳动。

1018
00:31:35,740 --> 00:31:36,760
0,300 330,600 600,720 720,840 840,1020
the file would go back

1019
00:31:36,760 --> 00:31:37,360
0,90 90,480
and forth.|
|

1020
00:31:38,290 --> 00:31:40,750
0,750 750,1860 1860,2010 2010,2250 2250,2460
{} And so is not
所以并不是很合适，

1021
00:31:40,750 --> 00:31:41,680
0,180 180,600 600,720 720,840 840,930
really suitable,| so you can
|所以你可以看到，

1022
00:31:41,680 --> 00:31:43,030
0,300 300,720 720,840 840,1230 1230,1350
see here,| the influence of
|比如他们设计的工作量的影响，

1023
00:31:43,030 --> 00:31:45,400
0,240 240,690 1530,2070 2070,2220 2220,2370
like the workload that they're

1024
00:31:45,400 --> 00:31:47,020
0,450 450,780 870,1380 1380,1500 1500,1620
designing for,| {} you know
|他们真正的假设是，

1025
00:31:47,020 --> 00:31:48,160
0,180 180,390 390,840 840,990 990,1140
they're really assumption is that,|
|

1026
00:31:48,160 --> 00:31:50,170
0,600 810,1200 1200,1620 1620,1710 1710,2010
basically most engineers are working
大多数工程师都在处理他们的私人文件，

1027
00:31:50,170 --> 00:31:52,420
0,120 120,300 300,630 630,1290 1530,2250
on their private files,| and
|有时候，他们会共享文件，

1028
00:31:52,420 --> 00:31:52,900
0,60 60,240 240,390 390,450 450,480
you know once in a

1029
00:31:52,900 --> 00:31:54,190
0,210 210,450 450,750 750,1140 1140,1290
while, they'll share files,| but
|但他们可能并不是在处理同一个共享文件。

1030
00:31:54,190 --> 00:31:55,300
0,60 60,240 240,480 480,720 720,1110
they were probably not banging

1031
00:31:55,300 --> 00:31:56,350
0,120 120,180 180,420 420,690 690,1050
on the same shared file.|
|

1032
00:32:02,980 --> 00:32:04,240
0,330 330,510 510,720 720,1020 1020,1260
{You,know,we're} {} using git,| but
我们在用 Git ，|你可以想象，如果你共享你的代码库，

1033
00:32:04,240 --> 00:32:05,170
0,90 90,180 180,570 570,780 780,930
you could imagine if you

1034
00:32:05,170 --> 00:32:06,250
0,120 120,210 210,540 540,870 870,1080
have a share your code

1035
00:32:06,250 --> 00:32:07,630
0,720 720,900 900,990 990,1230 1230,1380
repositories,| or you check out
|或者检出你自己的代码库副本，

1036
00:32:07,630 --> 00:32:08,830
0,150 150,270 270,600 600,690 690,1200
your own copy of the

1037
00:32:08,860 --> 00:32:10,780
0,210 210,810 810,1080 1080,1740 1740,1920
code repository,| {make,your,own} modifications,| and
|做了你自己的修改，|到某个时候，你把它写回去。

1038
00:32:10,780 --> 00:32:11,830
0,150 150,360 360,420 420,660 660,1050
some point you {write,it} back.|
|

1039
00:32:14,850 --> 00:32:15,810
0,240 240,480 480,660 660,750 750,960
I'm sorry, just to make
抱歉，只是为了确认你说的，

1040
00:32:15,810 --> 00:32:16,980
0,180 180,240 240,600 750,900 900,1170
sure you say,| you can
|你可以在缓存中仍有文件的情况下释放锁？

1041
00:32:16,980 --> 00:32:19,020
0,450 450,570 570,1170 1200,1530 1530,2040
release the lock {} while

1042
00:32:19,020 --> 00:32:20,280
0,120 120,570 570,900 900,990 990,1260
you still have the file

1043
00:32:20,280 --> 00:32:21,700
0,60 60,330 360,1140
in the cache?|
|

1044
00:32:23,040 --> 00:32:25,440
0,750 750,1140 1170,2100
You can, {}
你可以，好的，所以我小心一点，

1045
00:32:25,730 --> 00:32:26,840
0,300 300,720 720,930 930,1050 1050,1110
okay, so I'm going to

1046
00:32:26,840 --> 00:32:27,890
0,90 90,330 330,630 630,810 810,1050
be very careful with,| when
|当我提到释放锁的时候，

1047
00:32:27,890 --> 00:32:28,820
0,30 30,300 300,450 450,840 840,930
I mention with releasing the

1048
00:32:28,820 --> 00:32:30,380
0,270 270,780 840,1020 1020,1260 1260,1560
lock there,| is not releasing
|不是释放锁服务器的，

1049
00:32:30,380 --> 00:32:31,520
0,120 120,210 210,330 330,570 570,1140
it to the lock server,|
|

1050
00:32:31,670 --> 00:32:32,900
0,330 330,540 540,1050 1050,1110 1110,1230
{} but locally you know
而是在本地将状态从忙改为闲，

1051
00:32:32,900 --> 00:32:34,460
0,510 510,600 600,1020 1020,1230 1230,1560
changing the states from busy

1052
00:32:34,460 --> 00:32:35,220
0,120 120,510
to idle,|
|

1053
00:32:37,020 --> 00:32:37,980
0,300 300,480 480,600 600,720 720,960
and {since -} you know
因为是粘锁，

1054
00:32:37,980 --> 00:32:39,240
0,330 330,600 600,1080 1080,1170 1170,1260
the {lock,is} sticky,| you know
|它还在工作站 1 ，

1055
00:32:39,240 --> 00:32:40,410
0,90 90,330 330,600 600,690 690,1170
it still sits at workstation

1056
00:32:40,410 --> 00:32:41,640
0,330 330,450 450,750 750,990 990,1230
1,| and lock server still
|锁服务器仍然认为工作站 1 拥有这个锁。

1057
00:32:41,640 --> 00:32:43,230
0,450 450,840 840,1050 1050,1320 1320,1590
thinks actually {workstation -} 1

1058
00:32:43,230 --> 00:32:44,220
0,210 210,330 330,720
has the lock.|
|

1059
00:32:48,850 --> 00:32:50,280
0,270 270,510 510,630 630,1110
{Is,that} answer your question?|
这回答了你的问题吗？|

1060
00:32:51,330 --> 00:32:53,500
0,450 480,750 750,990 990,1410
Yeah, yeah, thank you.|
好的，好的，谢谢。|

1061
00:32:54,600 --> 00:32:56,260
0,210 210,330 330,780 780,1290
So what happens, {}|
那么，会发生什么，|

1062
00:32:56,510 --> 00:32:58,250
0,300 300,420 420,960 960,1380 1500,1740
if the request from {}
如果在它忙时， 2 的请求到来？

1063
00:32:58,250 --> 00:33:01,190
0,570 570,1050 1350,2160 2160,2280 2280,2940
2 comes while it's busy?|
|

1064
00:33:01,930 --> 00:33:03,010
0,390 390,540 540,870 870,1020 1020,1080
Yes, good question, what do
是的，好问题，你认为会发生什么？

1065
00:33:03,010 --> 00:33:04,200
0,60 60,330 330,810
you think happens?|
|

1066
00:33:10,100 --> 00:33:11,180
0,180 180,270 270,450 450,780 780,1080
Does it just reject them?|
它只是拒绝它们吗？|

1067
00:33:11,880 --> 00:33:13,290
0,600 600,810 810,1080 1080,1260 1260,1410
No, that's I think it
不，我认为它不会拒绝它，只是等待，

1068
00:33:13,290 --> 00:33:14,640
0,210 210,510 510,660 660,870 870,1350
doesn't reject it, just waits,|
|

1069
00:33:14,880 --> 00:33:16,530
0,120 120,390 390,1140 1170,1440 1440,1650
and waits until {} {workstation
等待直到工作站 1 完成，

1070
00:33:16,530 --> 00:33:19,170
0,270 270,840 960,1170 1170,1680 1740,2640
-} 1 is done,| modifying
|修改文件 f 或执行文件系统操作，

1071
00:33:19,170 --> 00:33:20,550
0,90 90,450 450,660 660,960 960,1380
the file f or executing

1072
00:33:20,550 --> 00:33:22,440
0,150 150,420 420,690 690,1290 1680,1890
its file system operation,| and
|然后 Frangipani 代码将在本地释放锁，

1073
00:33:22,440 --> 00:33:25,140
0,540 690,1170 1170,1530 1770,2430 2430,2700
then {} the Frangipani code

1074
00:33:25,140 --> 00:33:27,480
0,390 510,1230 1230,1710 1710,1830 1830,2340
will release locally the lock,|
|

1075
00:33:27,750 --> 00:33:29,010
0,330 330,630 630,810 810,1110 1110,1260
will see that someone is
会看到有人在等它，

1076
00:33:29,010 --> 00:33:30,630
0,330 330,630 630,810 1200,1440 1440,1620
waiting for it,| and so
|因此将其更改为忙，

1077
00:33:30,630 --> 00:33:32,250
0,510 510,750 750,840 840,1320 1320,1620
does change it to {}

1078
00:33:32,250 --> 00:33:33,870
0,540 600,840 840,1020 1020,1260 1260,1620
busy,| but actually starts flushing
|开始将所有操作都刷新到 Petal ，

1079
00:33:33,870 --> 00:33:35,520
0,180 180,240 240,840 840,1260 1260,1650
all the operations to Petal|
|

1080
00:33:35,520 --> 00:33:36,750
0,120 120,390 390,750 750,840 840,1230
and then releases the lock.|
然后释放锁。|

1081
00:33:38,530 --> 00:33:39,880
0,180 180,330 330,540 540,870 870,1350
So this comes actually nicely
所以这很好地谈到了第二点，

1082
00:33:39,880 --> 00:33:41,260
0,90 90,180 180,480 480,870 900,1380
to the second point, {}|
|

1083
00:33:41,260 --> 00:33:42,610
0,180 180,270 270,390 390,990 990,1350
which is this atomicity point,|
就是原子点，|

1084
00:33:42,640 --> 00:33:43,630
0,180 180,420 420,630 630,840 840,990
so maybe that will make
这或许会让事情变得更清楚。

1085
00:33:43,630 --> 00:33:44,880
0,90 90,270 270,690
it more clear.|
|

1086
00:33:45,330 --> 00:33:46,020
0,240 240,300 300,480 480,510 510,690
Let me talk a little
让我来谈谈原子性，

1087
00:33:46,020 --> 00:33:47,220
0,150 150,390 390,840 840,1020 1020,1200
bit about atomicity,| because it
|因为它也使用相同的锁

1088
00:33:47,220 --> 00:33:49,620
0,570 630,1290 1290,1380 1380,1740 1740,2400
also use the same locks|
|

1089
00:33:49,740 --> 00:33:52,830
0,780 930,1890 1920,2640 2640,2850 2850,3090
to achieve atomic file system
来实现原子文件系统操作，

1090
00:33:52,830 --> 00:33:53,780
0,720
operations,|
|

1091
00:33:56,260 --> 00:34:03,100
0,960 960,1110 1110,1260 1260,2190 4770,6840
{} atomicity, {using -} locks.|
原子性，使用锁。|

1092
00:34:03,130 --> 00:34:04,120
0,750
So
所以，当你执行创建操作时，

1093
00:34:04,200 --> 00:34:06,180
0,870 900,1350 1350,1440 1440,1650 1650,1980
when {for,example} you do create

1094
00:34:06,180 --> 00:34:07,830
0,600 600,810 810,960 960,1560 1560,1650
operation,| like you execute the
|你执行创建文件系统操作或 create f ，

1095
00:34:07,830 --> 00:34:10,110
0,330 330,600 600,870 870,1560 2130,2280
create file system operation or

1096
00:34:10,110 --> 00:34:12,040
0,420 420,750 750,1350
whatever create f,|
|

1097
00:34:12,850 --> 00:34:13,870
0,210 210,420 420,570 570,690 690,1020
{you,know} {whatever -} the usual
不管是什么参数，

1098
00:34:13,870 --> 00:34:14,900
0,630
arguments,|
|

1099
00:34:15,150 --> 00:34:16,800
0,270 270,570 570,660 660,900 900,1650
and there's of course internally,|
当然，在内部，|

1100
00:34:16,800 --> 00:34:18,270
0,210 210,330 330,660 690,1260 1260,1470
even though the application makes
尽管应用程序调用创建文件系统调用，

1101
00:34:18,270 --> 00:34:19,440
0,150 150,450 450,690 690,930 930,1170
this create file system call,|
|

1102
00:34:19,440 --> 00:34:21,150
0,90 90,540 540,780 780,990 990,1710
this internally actually has multiple
在内部实际上具有多个文件系统修改，

1103
00:34:21,630 --> 00:34:24,120
0,750 750,960 960,1200 1200,1980 2280,2490
{} file system modifications,| {you,know,for}
|例如，目录需要被修改，

1104
00:34:24,120 --> 00:34:25,980
0,510 510,780 780,1050 1110,1680 1680,1860
example {} the directory needs

1105
00:34:25,980 --> 00:34:27,780
0,90 90,180 180,1020 1080,1500 1500,1800
to be modified,| actually {let,me}
|让我以稍微不同的顺序来做，

1106
00:34:27,810 --> 00:34:28,980
0,330 330,450 450,600 630,930 930,1170
{do,it} in a slightly different

1107
00:34:28,980 --> 00:34:30,780
0,450 540,810 810,960 960,1320 1350,1800
order,| we need to allocate
|我们需要为 f 分配一个 inode ，

1108
00:34:30,780 --> 00:34:31,980
0,90 90,240 240,840 900,1080 1080,1200
an {inode -} you know

1109
00:34:31,980 --> 00:34:33,380
0,270 270,1140
for f,|
|

1110
00:34:34,260 --> 00:34:35,460
0,330 330,390 390,930 930,1080 1080,1200
{we,need} to initialize that {inode
我们需要初始化 inode ，写入 inode ，

1111
00:34:35,460 --> 00:34:38,550
0,510 1500,2130 2130,2280 2280,2400 2400,3090
-}, write the {inode -},|
|

1112
00:34:39,790 --> 00:34:40,960
0,150 150,510 510,600 600,810 810,1170
and then you know update
然后更新目录，

1113
00:34:40,960 --> 00:34:42,020
0,60 60,750
the directory,|
|

1114
00:34:44,150 --> 00:34:46,460
0,300 300,360 360,1110 1380,1770 1770,2310
update the directory to {}
更新目录以添加条目 f ，

1115
00:34:46,490 --> 00:34:48,500
0,240 240,330 330,810 810,1290 1290,2010
add an entry basically {for,you,know}

1116
00:34:48,500 --> 00:34:50,270
0,90 90,510 510,1170 1290,1440 1440,1770
the [] f,| and whatever
|为 f 分配的 inode ，

1117
00:34:50,270 --> 00:34:52,430
0,150 150,390 390,960 1500,1650 1650,2160
{inode -} number was allocated

1118
00:34:52,430 --> 00:34:53,100
0,450
{for,f},|
|

1119
00:34:53,980 --> 00:34:55,120
0,30 30,660 660,870 870,960 960,1140
{so,this,is} typical way in which
这是 Unix 文件系统实现文件的典型方式，

1120
00:34:55,120 --> 00:34:56,650
0,90 90,330 330,570 570,930 930,1530
{} Unix file system implements

1121
00:34:56,650 --> 00:34:58,210
0,540 1080,1230 1230,1320 1320,1410 1410,1560
files,| and so we need
|我们需要安排这些操作以原子方式进行，

1122
00:34:58,210 --> 00:34:59,770
0,60 60,570 570,720 720,870 870,1560
to arrange that these operations

1123
00:34:59,770 --> 00:35:02,770
0,690 690,1080 1080,1380 1800,2790 2790,3000
happen {atomically -},| {} because
|因为我们不想让其他工作站看到中间结果，

1124
00:35:02,770 --> 00:35:03,460
0,90 90,300 300,450 450,540 540,690
we don't want to sort

1125
00:35:03,460 --> 00:35:05,080
0,90 90,630 630,1050 1050,1170 1170,1620
of intermediate results be visible

1126
00:35:05,080 --> 00:35:06,400
0,120 120,570 570,1140 1140,1230 1230,1320
to other workstations,| in the
|发生的方式是通过获取这些锁，

1127
00:35:06,400 --> 00:35:07,990
0,240 240,420 420,780 780,990 990,1590
way that happens is using

1128
00:35:08,020 --> 00:35:10,570
0,390 390,840 840,990 990,1500 1920,2550
by acquiring those locks,| {acquire,the}
|获取这个特定 inode 的锁，

1129
00:35:10,570 --> 00:35:11,240
0,540
lock

1130
00:35:13,440 --> 00:35:14,910
0,300 300,780 810,990 990,1350 1350,1470
{} for this particular {inode

1131
00:35:14,910 --> 00:35:16,140
0,450 450,540 540,630 630,720 720,1230
-},| you know for example
|比如 inode 10 ，

1132
00:35:16,140 --> 00:35:17,460
0,330 330,570 570,720 720,1080 1080,1320
inode {inode -} 10,| so
|所以，你为 f 获取一把锁，

1133
00:35:17,460 --> 00:35:18,300
0,150 150,390 390,450 450,750 750,840
you require a lock for

1134
00:35:18,300 --> 00:35:19,740
0,360 390,510 510,630 630,870 930,1440
f,| I'm just gonna use
|我使用 "f" 作为锁，

1135
00:35:19,770 --> 00:35:22,170
0,360 360,750 1440,2010 2010,2160 2160,2400
"f" the lock I think,|
|

1136
00:35:22,170 --> 00:35:23,700
0,180 180,1140 1140,1290 1290,1440 1440,1530
but {you,know} it's gonna be
但是，它将是 inode 编号，

1137
00:35:23,700 --> 00:35:24,600
0,270 270,480 480,600 600,810 810,900
inode number,| and then at
|然后在某个时刻，

1138
00:35:24,600 --> 00:35:26,850
0,120 120,390 390,630 630,1290 1830,2250
some point,| it releases file
|它释放[]的文件系统，

1139
00:35:26,850 --> 00:35:28,230
0,270 270,360 360,600 600,1050 1050,1380
system at {[] -},| itself
|它本身释放锁，

1140
00:35:28,230 --> 00:35:29,580
0,420 420,540 540,960
releases the lock,|
|

1141
00:35:30,360 --> 00:35:31,860
0,120 120,390 390,810 810,1410 1410,1500
and again this releases a
同样地，这是一个本地释放操作，

1142
00:35:31,860 --> 00:35:33,570
0,390 390,690 690,1290 1290,1470 1470,1710
local release operation,| it doesn't
|这并不意味着立即将其释放回锁服务器，

1143
00:35:33,570 --> 00:35:36,720
0,390 390,750 750,1380 1710,2550 2580,3150
really mean immediately {} releasing

1144
00:35:36,720 --> 00:35:37,500
0,60 60,360 360,480 480,600 600,780
it back to the lock

1145
00:35:37,500 --> 00:35:39,240
0,420 420,900 900,1290 1290,1380 1380,1740
server,| just changing the status
|只是将状态从忙更改为闲。

1146
00:35:39,240 --> 00:35:40,590
0,150 150,450 450,840 900,1350 1350,1350
from busy to {} {idle

1147
00:35:40,590 --> 00:35:41,320
0,480
-}.|
|

1148
00:35:42,220 --> 00:35:44,080
0,150 150,540 630,1170 1170,1350 1350,1860
And so, {} so if
所以，如果在任何特定的时间点，

1149
00:35:44,110 --> 00:35:45,070
0,210 210,390 390,720 720,900 900,960
at any particular point in

1150
00:35:45,070 --> 00:35:46,870
0,570 630,1110 1110,1230 1230,1410 1410,1800
time,| as we just ask,|
|就像我们刚才问的那样，|

1151
00:35:46,870 --> 00:35:47,770
0,90 90,210 210,450 450,510 510,900
you know there's a request
有一个撤销锁的请求，

1152
00:35:47,770 --> 00:35:51,670
0,240 240,450 450,1020 1290,2070 2670,3900
coming in for {} revoke

1153
00:35:51,820 --> 00:35:52,880
0,810
{the,lock},|
|

1154
00:35:55,860 --> 00:35:58,470
0,540 540,960 1080,1740 1770,2490 2490,2610
{you,know} {revoke,f},| that request is
revoke f，|请求不会被[服务]，

1155
00:35:58,470 --> 00:36:00,780
0,210 210,450 450,630 630,1260 1380,2310
not actually being served,| until
|直到位于工作站 1 的本地 Frangipani 文件系统，

1156
00:36:00,870 --> 00:36:02,160
0,300 300,630 630,960 960,1050 1050,1290
the file system, the local

1157
00:36:02,160 --> 00:36:03,900
0,210 210,600 600,840 840,1200 1200,1740
{Frangipani -} file system {at,workstation}

1158
00:36:03,900 --> 00:36:04,760
0,420
1,|
|

1159
00:36:04,970 --> 00:36:06,920
0,480 480,1200 1230,1530 1530,1620 1620,1950
{} has called the local
调用了本地释放操作，

1160
00:36:06,920 --> 00:36:08,100
0,300 300,870
release operation,|
|

1161
00:36:08,300 --> 00:36:09,410
0,180 180,450 450,570 570,960 960,1110
and then it sees that
然后当本地释放操作时，

1162
00:36:09,410 --> 00:36:10,610
0,240 240,300 300,600 600,900 900,1200
when does the local release

1163
00:36:10,610 --> 00:36:12,050
0,480 480,570 570,960 960,1200 1200,1440
operation,| it sees that there's
|它看到有一个 revoke 在等待，

1164
00:36:12,050 --> 00:36:14,360
0,420 420,810 810,1290 1320,1770 1770,2310
{} a revoke {} waiting,|
|

1165
00:36:14,600 --> 00:36:15,830
0,180 180,270 270,450 450,960 1080,1230
so at this point,| it's
所以，在这一点上，|它将刷新缓存状态到 Petal ，

1166
00:36:15,830 --> 00:36:18,110
0,120 120,180 180,990 1500,1920 1920,2280
going to flush its cache

1167
00:36:18,110 --> 00:36:19,020
0,540
state,

1168
00:36:21,730 --> 00:36:23,590
0,540 540,990 990,1080 1080,1230 1230,1860
cache state you know to

1169
00:36:23,680 --> 00:36:25,160
0,570
Petal,|
|

1170
00:36:26,180 --> 00:36:27,260
0,240 240,510 510,630 630,900 900,1080
and once that actually have
一旦它刷新缓存状态到 Petal ，

1171
00:36:27,260 --> 00:36:28,400
0,270 270,600 600,840 840,1050 1050,1140
{} flush cache state to

1172
00:36:28,400 --> 00:36:31,040
0,570 690,1080 1080,1350 1350,2040 2070,2640
Petal,| {} it will grant
|它将授予撤销或接受撤销，

1173
00:36:31,040 --> 00:36:33,260
0,450 450,1050 1290,1680 1740,2130 2130,2220
basically revoke or accept the

1174
00:36:33,260 --> 00:36:35,210
0,540 660,1200 1200,1440 1440,1770 1770,1950
revoke| and send back a
|并向锁服务器发回 release ，

1175
00:36:35,210 --> 00:36:36,260
0,300 300,390 390,540 540,690 690,1050
release {to -} lock server,|
|

1176
00:36:36,260 --> 00:36:37,310
0,120 120,480 480,540 540,750 750,1050
so then the lock can
然后锁就可以分配给工作站 2 了。

1177
00:36:37,310 --> 00:36:39,770
0,300 300,750 990,1680 1680,2340 2340,2460
there be assigned to {}

1178
00:36:39,770 --> 00:36:40,760
0,450 450,720
workstation 2.

1179
00:36:43,590 --> 00:36:44,540
0,150 150,300 300,600
{Is,that} makes sense?|
这能理解吗？|

1180
00:36:48,620 --> 00:36:50,450
0,330 330,810 1080,1380 1380,1650 1650,1830
{} So just make sure,|
所以只是确认，|

1181
00:36:50,450 --> 00:36:51,830
0,210 210,480 480,660 660,960 960,1380
so in this create operation
在这里的创建操作中，

1182
00:36:51,830 --> 00:36:52,880
0,150 150,300 300,420 420,510 510,1050
here,| we have to modify
|我们必须修改 inode ，

1183
00:36:52,880 --> 00:36:54,980
0,450 450,600 600,990 1050,1500 1530,2100
the {inode -} for,| so
|我们必须修改 f 的 inode ，

1184
00:36:55,490 --> 00:36:56,450
0,360 360,510 510,600 600,900 900,960
we have to modify the

1185
00:36:56,450 --> 00:36:57,440
0,150 150,300 300,540 540,780 780,990
{inode -} for f,| and
|以及包含 f 的目录的 inode ，

1186
00:36:57,440 --> 00:36:58,370
0,120 120,240 240,450 450,540 540,930
{inode -} for the directory

1187
00:36:58,370 --> 00:36:59,570
0,120 120,450 450,870 870,1110 1110,1200
that contains f,| because we
|因为我们必须更新引用，

1188
00:36:59,570 --> 00:37:01,130
0,180 180,450 480,870 870,960 960,1560
have to update the references,|
|

1189
00:37:01,340 --> 00:37:02,690
0,180 180,600 600,840 840,1050 1050,1350
and so that means that,|
这就意味着，|

1190
00:37:02,690 --> 00:37:05,210
0,1170 1170,1230 1260,1830 1830,2220 2220,2520
{} is like technically speaking,
从技术上讲，我们持有两把锁，

1191
00:37:05,210 --> 00:37:07,020
0,150 150,480 480,870 870,1530
we're actually holding two

1192
00:37:07,260 --> 00:37:09,060
0,330 330,1020 1020,1470 1470,1620 1620,1800
{} locks,| and we have
|我们必须释放这两把锁，

1193
00:37:09,060 --> 00:37:10,020
0,120 120,450 450,660 660,780 780,960
to release both of them,|
|

1194
00:37:10,020 --> 00:37:11,010
0,270 270,390 390,750 750,900 900,990
before we reply back to
在回复撤销请求之前。

1195
00:37:11,010 --> 00:37:15,390
0,1160 1170,3840 3840,4020 4020,4170 4170,4380
{the,revoke,request}.| {Yes\,,absolutely},| {so,hold,a,second,about} {sort,of} read
|是的，当然，|所以稍等一下查看论文，

1196
00:37:15,390 --> 00:37:16,230
0,60 60,300 300,390 390,540 540,840
the paper| and then really
|然后讨论他们怎么做，

1197
00:37:16,230 --> 00:37:17,310
0,180 180,360 360,540 540,870 870,1080
talk about {what,they} do,| but
|但从根本上说，他们有一些，

1198
00:37:17,310 --> 00:37:18,540
0,450 450,630 630,840 840,900 900,1230
basically they sort of have,|
|

1199
00:37:19,210 --> 00:37:20,770
0,480 480,960 960,1110 1110,1380 1380,1560
not very {coarse-grained - -}
不是非常粗粒度的锁，

1200
00:37:20,770 --> 00:37:22,270
0,330 330,480 480,660 660,990 990,1500
locks,| but also very fine-grained
|而且还有非常细粒度的锁，[]锁，

1201
00:37:22,270 --> 00:37:24,070
0,600 600,900 900,1350 1350,1470 1470,1800
lock, [] locks,| they basically
|他们每个 inode 都有一个锁，

1202
00:37:24,070 --> 00:37:26,140
0,150 150,180 180,1440 1440,1590 1590,2070
have a {lock,you,know,per} {inode -},|
|

1203
00:37:26,440 --> 00:37:27,490
0,360 360,450 450,600 600,690 690,1050
and you know the {directory's
目录的 inode ，文件的 inode ，

1204
00:37:27,490 --> 00:37:28,450
0,120 120,240 240,540 540,870 870,960
-} {inode -}, {file's -}

1205
00:37:28,450 --> 00:37:30,070
0,150 150,600 870,1350 1350,1560 1560,1620
{inode -},| {} and in
|事实上，目录与文件没有什么不同，

1206
00:37:30,070 --> 00:37:30,940
0,210 210,270 270,570 570,630 630,870
fact the directory is nothing

1207
00:37:30,940 --> 00:37:32,170
0,210 210,300 300,390 390,720 720,1230
else than a file| with
|只不过是具有特定格式，

1208
00:37:32,380 --> 00:37:34,400
0,840 930,1080 1080,1770
specific a format,

1209
00:37:34,580 --> 00:37:36,290
0,630 810,1110 1110,1320 1320,1470 1470,1710
format,| {} and so {}
|所以创建 f ，

1210
00:37:36,290 --> 00:37:37,910
0,300 300,600 600,990 990,1320 1320,1620
really create f,| we actually
|我们必须分配，

1211
00:37:37,910 --> 00:37:39,920
0,210 210,360 360,930 1020,1500 1500,2010
have to allocate,| first allocate
|首先分配或获取目录 d 的锁，

1212
00:37:39,920 --> 00:37:41,600
0,60 60,540 750,1140 1170,1620 1620,1680
the lock or acquire the

1213
00:37:41,600 --> 00:37:42,920
0,270 270,360 360,420 420,810 810,1320
lock in the directory d,|
|

1214
00:37:43,160 --> 00:37:44,750
0,210 210,660 660,810 810,1080 1080,1590
and then {you,know} would allocate
然后分配或获取 inode f 的锁，

1215
00:37:44,750 --> 00:37:46,070
0,270 270,600 600,990 990,1050 1050,1320
{} or acquire the lock

1216
00:37:46,070 --> 00:37:48,800
0,390 390,1470 1530,1620 1620,2160 2190,2730
on {} {inode -} {}

1217
00:37:48,920 --> 00:37:49,840
0,450 450,810
for f,|
|

1218
00:37:49,950 --> 00:37:50,940
0,270 270,450 450,600 600,840 840,990
and so do hold two
所以持有两把锁。

1219
00:37:50,940 --> 00:37:51,740
0,540
locks.|
|

1220
00:37:52,060 --> 00:37:53,860
0,390 390,540 540,1020 1050,1680 1680,1800
And as you probably have
你可能已经注意到的，

1221
00:37:53,860 --> 00:37:55,300
0,420 420,480 480,870 870,1170 1170,1440
noticed,| you know of course
|当然，当你获取多个锁时，

1222
00:37:55,300 --> 00:37:55,990
0,90 90,330 330,390 390,510 510,690
you soon as you have

1223
00:37:55,990 --> 00:37:57,340
0,150 150,480 480,810 810,1110 1110,1350
to acquire multiple locks,| there's
|存在陷入死锁的风险，

1224
00:37:57,340 --> 00:37:59,650
0,390 750,1350 1350,1650 1650,1740 1740,2310
a potential risk of deadlock,|
|

1225
00:37:59,650 --> 00:38:02,260
0,360 360,690 690,930 930,1440 1920,2610
if one {workstation -} allocates
如果一个工作站以不同的顺序分配锁，

1226
00:38:02,260 --> 00:38:03,580
0,270 270,360 360,420 420,720 720,1320
locks in a different order,|
|

1227
00:38:03,580 --> 00:38:04,720
0,90 90,180 180,330 330,540 540,1140
you can have a deadlock,|
你可能会陷入死锁，|

1228
00:38:04,990 --> 00:38:06,940
0,390 390,690 690,1080 1080,1380 1380,1950
so {Frangipani -} follows rules,|
所以， Frangipani 遵循规则，|

1229
00:38:06,940 --> 00:38:08,620
0,90 90,540 540,810 810,1260 1260,1680
that basically all locks ordered
所有的锁都以特定的方式排序，

1230
00:38:08,620 --> 00:38:09,940
0,150 150,210 210,570 570,1050 1140,1320
in a particular way,| be
|以固定的顺序获取锁。

1231
00:38:09,940 --> 00:38:11,920
0,540 540,600 600,930 930,1710 1710,1980
acquire the locks {in,a} fixed

1232
00:38:11,920 --> 00:38:12,420
0,360
order.|
|

1233
00:38:14,370 --> 00:38:15,510
0,150 150,270 270,450 450,630 900,1140
I see, thank you.| I
我明白了，谢谢。|我想锁是按 inode 编号排序的。

1234
00:38:15,510 --> 00:38:16,590
0,150 150,210 210,450 450,810 810,1080
think the locks ordered by

1235
00:38:16,590 --> 00:38:17,940
0,300 300,570 570,720 720,870 870,1350
lock, {} {inode -} number.|
|

1236
00:38:21,480 --> 00:38:22,620
0,210 210,330 330,480 480,870
So {does,that} makes sense?|
这个能理解吗？|

1237
00:38:23,840 --> 00:38:24,620
0,180 180,300 300,480 480,540 540,780
Yeah, so there's a bunch
是的，所以那里有很多更复杂的东西。

1238
00:38:24,620 --> 00:38:25,900
0,210 210,660 660,960
more complexity there.|
|

1239
00:38:29,180 --> 00:38:31,020
0,480 510,900 930,1500
Okay, so the,|
好的，所以，|

1240
00:38:31,660 --> 00:38:33,670
0,120 120,240 240,840 1110,1500 1500,2010
you know, so having discussed
所以讨论了原子性文件系统操作，

1241
00:38:33,670 --> 00:38:34,900
0,300 300,450 450,660 660,1170 1170,1230
{atomicity - - - -}

1242
00:38:34,900 --> 00:38:36,400
0,240 240,480 480,1020 1020,1080 1080,1500
file system operations,| at least
|至少在崩溃时，

1243
00:38:36,400 --> 00:38:38,350
0,330 330,870 1260,1410 1410,1710 1710,1950
during crashes,| you know if
|如果没有崩溃，

1244
00:38:38,350 --> 00:38:39,670
0,150 150,300 300,840 990,1200 1200,1320
there's no crashes,| {you,know} at
|至少可以保证这些操作是原子发生的，

1245
00:38:39,670 --> 00:38:40,960
0,180 180,330 330,870 870,990 990,1290
least it's guaranteed that these

1246
00:38:40,960 --> 00:38:43,570
0,630 630,1440 1440,1800 1800,2340 2340,2610
{} operations happen atomically,| because
|因为锁确保了原子性，

1247
00:38:43,570 --> 00:38:45,310
0,90 90,510 510,1140 1140,1470 1470,1740
the locks ensure {atomicity -},|
|

1248
00:38:45,760 --> 00:38:47,080
0,150 150,690 750,990 990,1230 1230,1320
of course it could be
当然有可能是这样的，

1249
00:38:47,080 --> 00:38:48,190
0,90 90,480 480,720 720,900 900,1110
the case,| that like we're
|比如我们运气不好，

1250
00:38:48,190 --> 00:38:50,530
0,660 690,1020 1020,1230 1230,1620 2040,2340
unlucky, right,| and so {}
|工作站 1 崩溃，

1251
00:38:50,530 --> 00:38:52,780
0,150 150,780 780,1110 1110,1650 1650,2250
the workstation 1 crashes,| right
|正好在这些操作的中间，

1252
00:38:52,780 --> 00:38:53,530
0,150 150,210 210,480 480,570 570,750
in the middle of these

1253
00:38:53,530 --> 00:38:55,360
0,570 570,660 660,1050 1050,1260 1260,1830
operations,| for example as allocated
|例如在分配 inode 时，

1254
00:38:55,360 --> 00:38:56,980
0,720 720,840 840,990 990,1380 1500,1620
allocated the {inode -},| it
|它还没有更新目录。

1255
00:38:56,980 --> 00:38:58,000
0,210 210,330 330,540 540,930 930,1020
actually has not updated the

1256
00:38:58,000 --> 00:38:58,780
0,420 420,720
directory yet.|
|

1257
00:38:59,540 --> 00:39:01,520
0,420 630,1320 1440,1800 1800,1890 1890,1980
And {} let's say the
我们假设崩溃发生在这里，

1258
00:39:01,520 --> 00:39:02,840
0,270 270,600 600,960
crash happens here,|
|

1259
00:39:04,270 --> 00:39:05,900
0,420 420,510 510,690 690,1320
{} you know and
如果我们不做些特别的事，

1260
00:39:06,160 --> 00:39:06,910
0,150 150,210 210,390 390,450 450,750
if we don't do anything

1261
00:39:06,910 --> 00:39:08,110
0,450 450,690 690,930 930,1080 1080,1200
special,| like what is the
|我们可能会有什么顾虑。

1262
00:39:08,110 --> 00:39:09,130
0,60 60,570 570,690 690,810 810,1020
the concern that we might

1263
00:39:09,130 --> 00:39:09,920
0,450
have.|
|

1264
00:39:17,100 --> 00:39:18,870
0,240 240,390 390,600 600,1080 1290,1770
Okay, let me {} concern
好的，我们可能有的顾虑，

1265
00:39:18,870 --> 00:39:20,010
0,120 120,330 330,660 690,960 960,1140
we might have,| you know
|某些文件系统操作只是部分应用于 Petal ，

1266
00:39:20,010 --> 00:39:21,720
0,210 210,810 810,960 960,1500 1500,1710
some file system operation actually

1267
00:39:21,720 --> 00:39:23,070
0,180 180,390 390,930 930,1230 1230,1350
is only partially apply to

1268
00:39:23,070 --> 00:39:23,840
0,450
Petal,|
|

1269
00:39:24,220 --> 00:39:25,750
0,600 600,1110 1110,1230 1230,1380 1380,1530
{} and you know that
这个变得更清楚了，

1270
00:39:25,750 --> 00:39:27,070
0,270 270,390 390,960 1020,1200 1200,1320
becomes more clear,| if we
|如果我们考虑这个场景，

1271
00:39:27,070 --> 00:39:29,110
0,240 240,450 450,930 960,1380 1410,2040
actually think about the scenario,|
|

1272
00:39:29,110 --> 00:39:30,340
0,270 270,510 510,930 930,1020 1020,1230
what actually happens in this
在这个特殊的状态下发生了什么，

1273
00:39:30,340 --> 00:39:32,890
0,360 360,840 840,1050 1050,1830 2070,2550
particular state,| like when the
|当缓存状态已经刷新到 Petal 时。

1274
00:39:32,920 --> 00:39:34,540
0,690 720,840 840,930 930,1350 1350,1620
state of the cache actually

1275
00:39:34,540 --> 00:39:36,400
0,630 780,1170 1170,1620
flushed to Petal.|
|

1276
00:39:36,650 --> 00:39:37,430
0,270 270,390 390,570 570,660 660,780
And so this is the
所以，这就是崩溃恢复的主题。

1277
00:39:37,430 --> 00:39:38,960
0,330 330,390 390,690 690,1230
topic of crash recovery.|
|

1278
00:39:50,240 --> 00:39:51,170
0,120 120,360 360,540 540,690 690,930
It turns out that actually
事实证明，更新 Petal 中的状态，

1279
00:39:51,170 --> 00:39:53,720
0,330 330,420 420,780 780,1260 1290,2550
updating the state in {},

1280
00:39:54,140 --> 00:39:56,780
0,930 930,1380 1380,1980 2010,2310 2310,2640
updating {state,in} Petal,| also follows
|也遵循非常仔细的协议，

1281
00:39:56,780 --> 00:39:59,120
0,330 330,540 540,930 930,1500 1950,2340
actually pretty careful protocol,| and
|这个协议通常被称为预写式日志，

1282
00:39:59,120 --> 00:40:00,950
0,180 180,600 600,810 810,1290 1290,1830
this protocol some is typically

1283
00:40:00,950 --> 00:40:02,440
0,240 240,450 450,600 600,1020
called {write-ahead -} logging,|
|

1284
00:40:21,570 --> 00:40:22,320
0,210 210,360 360,480 480,660 660,750
and this is {} you
这可能是我们已经看到的术语，

1285
00:40:22,320 --> 00:40:23,190
0,90 90,420 420,510 510,750 750,870
know probably the term we've

1286
00:40:23,190 --> 00:40:24,840
0,270 270,840 840,1230 1230,1470 1470,1650
already seen| {} and you've
|你们可能已经在 6.033 中看到过，

1287
00:40:24,840 --> 00:40:27,120
0,270 270,630 630,1590 1830,2250 2250,2280
seen probably {in,6.033}, { -}|
|

1288
00:40:27,120 --> 00:40:28,500
0,600 600,900 900,1020 1020,1110 1110,1380
and {} you know Petal
Petal 也使用它，

1289
00:40:28,500 --> 00:40:29,730
0,390 390,630 630,750 750,930 930,1230
{use,it} too,| it's a very
|它是一种非常常见的技术，

1290
00:40:29,730 --> 00:40:31,020
0,300 300,840 870,990 990,1170 1170,1290
common technique,| and it will
|它也会发挥重要作用，

1291
00:40:31,020 --> 00:40:32,310
0,240 240,450 450,570 570,870 870,1290
also play a big important

1292
00:40:32,310 --> 00:40:34,260
0,330 330,870 990,1530 1530,1830 1830,1950
role| in subsequent papers that
|在之后我们看到的论文里，

1293
00:40:34,260 --> 00:40:36,030
0,120 120,450 660,870 870,1260 1320,1770
we'll see,| and so {}
|所以 Petal 很好的引入

1294
00:40:36,030 --> 00:40:37,020
0,270 270,330 330,570 570,600 600,990
Petal is actually a nice

1295
00:40:37,020 --> 00:40:39,330
0,870 870,1260 1260,1590 1680,1920 1920,2310
reintroduction| to {} this idea
|这种预写式日志的想法，

1296
00:40:39,330 --> 00:40:41,490
0,210 210,720 750,1020 1020,1410 1980,2160
of {} write-ahead logging,| and
|一种思考的方式，

1297
00:40:41,490 --> 00:40:42,240
0,60 60,300 300,420 420,540 540,750
a way to think about

1298
00:40:42,240 --> 00:40:45,210
0,300 300,540 540,630 630,1110 2250,2970
write,| {you,know} {} gonna Petal
|Petal 是为预写式日志设计的，

1299
00:40:45,210 --> 00:40:46,110
0,360 360,420 420,630 630,690 690,900
designed to {write-ahead - -}

1300
00:40:46,110 --> 00:40:47,790
0,480 630,1170 1170,1290 1290,1500 1500,1680
logging,| use of {wirte-ahead -}
|使用预写式日志与任何其他预写式日志方案非常相似。

1301
00:40:47,790 --> 00:40:49,200
0,270 270,390 390,600 600,1050 1050,1410
logging is very similar to

1302
00:40:49,200 --> 00:40:50,340
0,300 300,480 480,660 660,870 870,1140
any other {write-ahead -} logging

1303
00:40:50,340 --> 00:40:51,930
0,450 780,930 930,1290 1410,1500 1500,1590
scheme.| And so you know
|所以思考它的方式如下，

1304
00:40:51,930 --> 00:40:52,560
0,90 90,210 210,300 300,420 420,630
the way to think about

1305
00:40:52,560 --> 00:40:53,700
0,90 90,240 240,870 870,960 960,1140
it as follows,| you know
|我们有虚拟磁盘，

1306
00:40:53,700 --> 00:40:55,260
0,120 120,360 360,570 570,1050 1080,1560
we have our disk, virtual

1307
00:40:55,260 --> 00:40:55,680
0,360
disk,|
|

1308
00:40:56,390 --> 00:40:57,320
0,120 120,300 300,480 480,660 660,930
we can just think about
我们可以把磁盘想象成一个很长的块阵列，

1309
00:40:57,320 --> 00:40:59,510
0,270 270,480 480,660 660,930 1500,2190
disk as like a long

1310
00:40:59,510 --> 00:41:01,310
0,330 390,780 780,1050 1050,1140 1140,1800
[], long array of blocks,|
|

1311
00:41:01,900 --> 00:41:03,670
0,480 480,960 960,1230 1230,1500 1500,1770
and what they've done is,
他们所做的是，将磁盘的一部分保留为日志，

1312
00:41:03,670 --> 00:41:05,320
0,300 300,390 390,900 990,1500 1500,1650
part of the disk is

1313
00:41:05,320 --> 00:41:08,260
0,780 780,900 900,960 960,1530 2820,2940
reserved as the log,| in
|事实上，在 Petal 的情况中，

1314
00:41:08,260 --> 00:41:09,370
0,330 330,630 630,810 810,1050 1050,1110
fact, in the case of

1315
00:41:09,370 --> 00:41:10,600
0,510 540,720 720,750 750,1080 1080,1230
Petal,| there's a log per
|每台服务器都有一个日志，

1316
00:41:10,600 --> 00:41:12,220
0,510 540,750 750,960 960,1290 1290,1620
server,| but let's, for now,
|但现在，我们假设有一个单一的日志，

1317
00:41:12,220 --> 00:41:13,480
0,270 270,510 510,870 870,1110 1110,1260
let's just assume there's like

1318
00:41:13,480 --> 00:41:15,070
0,210 210,480 480,960 1290,1470 1470,1590
one single log,| and then
|然后是文件系统，

1319
00:41:15,070 --> 00:41:16,280
0,150 150,240 240,480 480,960
there's the file system,|
|

1320
00:41:17,060 --> 00:41:18,200
0,420 420,750 750,960 960,1050 1050,1140
so there's part of the
所以有一部分磁盘是为日志保留的，

1321
00:41:18,200 --> 00:41:19,970
0,300 300,570 570,1020 1020,1170 1170,1770
disk is reserved for logging,|
|

1322
00:41:19,970 --> 00:41:20,720
0,150 150,330 330,390 390,480 480,750
{you,know} part of the disk
一部分磁盘是文件系统，

1323
00:41:20,720 --> 00:41:21,800
0,150 150,360 360,660 660,990 990,1080
is the file system,| and
|文件系统包含 inode ，

1324
00:41:21,800 --> 00:41:23,090
0,90 90,330 330,600 600,960 960,1290
the file system contains {inodes

1325
00:41:23,090 --> 00:41:24,260
0,600
-},|
|

1326
00:41:24,560 --> 00:41:25,670
0,120 120,510 510,720 720,870 870,1110
you know and some data
还有一些数据块，等等。

1327
00:41:25,670 --> 00:41:27,640
0,630 630,960 960,1620
block, etc, etc.|
|

1328
00:41:28,120 --> 00:41:29,920
0,570 690,900 900,1200 1200,1380 1380,1800
And the rule is that,|
规则是，|

1329
00:41:30,130 --> 00:41:32,020
0,690 720,990 990,1530 1530,1620 1620,1890
when you update the state
当你更新 Petal 中的状态时，

1330
00:41:32,020 --> 00:41:32,980
0,120 120,660
in Petal,|
|

1331
00:41:33,160 --> 00:41:34,360
0,240 240,510 510,660 660,750 750,1200
the first thing you do
你要做的第一件事是第一次日志更新，

1332
00:41:34,450 --> 00:41:36,940
0,150 150,420 420,870 1200,1740 1740,2490
is actually your first log

1333
00:41:36,940 --> 00:41:37,600
0,360
update,|
|

1334
00:41:43,840 --> 00:41:45,190
0,210 210,690 720,1140 1140,1260 1260,1350
so when, {} if we
所以，如果我们回到上一张图片，

1335
00:41:45,190 --> 00:41:46,270
0,90 90,300 300,600 600,720 720,1080
go back to the previous

1336
00:41:46,270 --> 00:41:49,030
0,630 750,1620 1620,2130 2130,2250 2250,2760
picture,| and after the point,
|在那个点之后，在工作站 1 上的 Frangipani ，

1337
00:41:49,030 --> 00:41:51,020
0,120 120,120
that the

1338
00:41:51,580 --> 00:41:53,620
0,660 660,750 750,1230 1230,1740 1950,2040
Frangipani on workstation 1,| and
|想把锁还给锁服务器，

1339
00:41:53,620 --> 00:41:54,610
0,300 300,390 390,570 570,900 900,990
want to give back the

1340
00:41:54,610 --> 00:41:55,930
0,420 420,570 570,750 750,870 870,1320
lock {you,know} to the {lock,server},|
|

1341
00:41:55,930 --> 00:41:57,460
0,180 180,780 780,960 960,1230 1230,1530
it first has to write
它首先要把它的状态写入 Petal ，

1342
00:41:57,460 --> 00:41:58,600
0,150 150,630 630,720 720,870 870,1140
its state you know to

1343
00:41:58,600 --> 00:41:59,650
0,420 420,540 540,720 720,960 960,1050
Petal,| and that goes in
|这分为两步，

1344
00:41:59,650 --> 00:42:01,390
0,150 150,720 930,1170 1170,1440 1440,1740
two steps,| the first step
|第一步记录更新，

1345
00:42:01,390 --> 00:42:03,910
0,330 390,900 900,1440 1440,2430 2430,2520
is log the update,| the
|发送更新到日志，

1346
00:42:03,910 --> 00:42:05,170
0,540 540,630 630,720 720,1200 1200,1260
[distribution] of the update you

1347
00:42:05,170 --> 00:42:07,120
0,120 120,780 780,1020 1050,1680 1800,1950
know to the log, the

1348
00:42:07,120 --> 00:42:08,890
0,330 330,810 810,900 900,1170 1170,1770
log [],| {} {here,for} example,
|例如，在这里，我们获得一个记录，

1349
00:42:09,070 --> 00:42:10,540
0,330 330,510 510,570 570,1110
we get a record,|
|

1350
00:42:10,910 --> 00:42:12,980
0,480 480,1050 1050,1140 1140,1320 1320,2070
that's says you know create
这表示创建操作，

1351
00:42:13,010 --> 00:42:15,200
0,540 540,1230 1230,1380 1380,1710 1710,2190
basic describes the create operation,|
|

1352
00:42:15,200 --> 00:42:16,970
0,360 360,540 540,750 750,1230 1590,1770
so that will have you
所以有分配 inode 编号，

1353
00:42:16,970 --> 00:42:18,620
0,120 120,450 450,900 900,1140 1140,1650
know whatever allocate {inode -},

1354
00:42:19,690 --> 00:42:21,130
0,150 150,330 330,810 810,1200 1200,1440
{inode -} number,| whatever {}
|不管结果是什么，

1355
00:42:21,130 --> 00:42:22,420
0,510 510,630 630,1050 1050,1170 1170,1290
basically the result that would

1356
00:42:22,420 --> 00:42:23,560
0,90 90,450 450,570 570,660 660,1140
have happen,| if you allocate
|如果你分配 inode 编号并且目录发生变化，

1357
00:42:23,560 --> 00:42:26,260
0,420 420,900 900,1440 1470,2040 2040,2700
{inode,number -} {and,the} directory change,|
|

1358
00:42:30,900 --> 00:42:31,650
0,270 270,420 420,540 540,600 600,750
it will be a little
稍后我们会更具体一点，

1359
00:42:31,650 --> 00:42:32,370
0,120 120,240 240,600 600,660 660,720
bit more specific in a

1360
00:42:32,370 --> 00:42:33,240
0,270 270,450 450,630 630,750 750,870
second,| but that's sort of
|但是更新包括修改，

1361
00:42:33,240 --> 00:42:35,490
0,510 660,840 840,1260 1260,2010 2040,2250
the the update contains the

1362
00:42:35,490 --> 00:42:36,720
0,300 300,660 660,900 900,1020 1020,1230
{modifications -},| need to be
|需要发生在文件系统块上的（修改），

1363
00:42:36,780 --> 00:42:38,340
0,300 300,390 390,900 1020,1380 1380,1560
made to happen to the

1364
00:42:38,340 --> 00:42:40,710
0,270 270,540 540,1110 1170,1770 1770,2370
file system blocks,| {to,actually} {}
|为了反映这一变化。

1365
00:42:40,740 --> 00:42:43,230
0,720 720,810 810,1320 1800,2010 2010,2490
reflect the change.| So first
|所以首先记录更新，

1366
00:42:43,260 --> 00:42:45,270
0,540 540,600 600,840 840,1680 1710,2010
log to the, {} first

1367
00:42:45,270 --> 00:42:46,980
0,300 300,390 390,930 1170,1320 1320,1710
log the update,| and then
|然后，一旦你更新了日志，

1368
00:42:46,980 --> 00:42:48,570
0,300 300,420 420,540 540,1500 1500,1590
once you have update the

1369
00:42:48,570 --> 00:42:49,260
0,540
log,|
|

1370
00:42:49,610 --> 00:42:51,740
0,540 540,1260 1290,1380 1380,1680 1680,2130
then we, the second operation
然后，客户端的第二个执行的操作，

1371
00:42:51,740 --> 00:42:53,720
0,120 120,630 660,1080 1080,1680 1740,1980
of the client executes,| the
|工作站执行的是安装更新，

1372
00:42:53,720 --> 00:42:55,790
0,420 420,990 1020,1200 1200,1470 1470,2070
workstation executes is actually installing

1373
00:42:55,790 --> 00:42:57,620
0,90 90,600
the update,|
|

1374
00:43:01,870 --> 00:43:02,960
0,780

1375
00:43:03,370 --> 00:43:06,040
0,630 840,1380 1440,2040 2040,2040 2040,2670
and {the -} {} reason
做这两个步骤的原因是，

1376
00:43:06,160 --> 00:43:07,300
0,210 210,360 360,570 570,960 960,1140
you know for doing sort

1377
00:43:07,300 --> 00:43:09,070
0,60 60,210 210,810 930,1230 1230,1770
of two steps is that,|
|

1378
00:43:09,160 --> 00:43:11,080
0,210 210,330 330,990 1020,1590 1590,1920
you know once you've log
一旦你记录了所有的变化，

1379
00:43:11,080 --> 00:43:13,450
0,150 150,300 300,960 1320,2070 2100,2370
all your changes,| then {}
|那么更新数据块就完全安全了，

1380
00:43:13,450 --> 00:43:14,920
0,150 150,540 540,990 990,1080 1080,1470
it's completely safe to update

1381
00:43:14,920 --> 00:43:15,940
0,60 60,360 360,660 660,900 900,1020
the data blocks,| because they
|因为它们总是会更新文件系统，

1382
00:43:15,940 --> 00:43:17,830
0,600 600,750 750,930 930,1230 1230,1890
always will end up and

1383
00:43:18,100 --> 00:43:19,240
0,300 300,360 360,780 780,870 870,1140
update the {file,system},| and it
|它总是以一致的状态结束，

1384
00:43:19,240 --> 00:43:20,200
0,120 120,510 510,630 630,810 810,960
should always will end up

1385
00:43:20,200 --> 00:43:22,570
0,90 90,150 150,600 600,1110 1710,2370
in a consistent state, {}|
|

1386
00:43:22,870 --> 00:43:24,010
0,510 510,720 720,870 870,990 990,1140
and the way to see
而理解这一点的方法是，

1387
00:43:24,010 --> 00:43:25,930
0,180 180,300 300,1020 1050,1320 1320,1920
this is basically,| let's assume
|让我们假设客户端工作站，

1388
00:43:25,930 --> 00:43:26,760
0,90 90,210 210,660
you know the

1389
00:43:27,130 --> 00:43:28,720
0,390 390,960 960,1110 1110,1290 1290,1590
client workstation,| that was actually
|正在刷新它的数据到 Petal ，

1390
00:43:28,720 --> 00:43:30,400
0,390 390,540 540,720 720,1140 1140,1680
flushing it's data to Petal,|
|

1391
00:43:31,330 --> 00:43:33,160
0,600 600,1140 1140,1560
crashes right here.|
在这里崩溃。|

1392
00:43:34,840 --> 00:43:35,900
0,750

1393
00:43:36,870 --> 00:43:37,920
0,150 150,300 300,780
Is that okay?|
这可以吗？|

1394
00:43:43,900 --> 00:43:45,820
0,480 480,930 930,1260 1260,1740 1740,1920
Yes, because since everything is
是的，因为所有东西都已经存入日志，

1395
00:43:45,820 --> 00:43:47,950
0,450 450,990 1380,1710 1710,1950 1950,2130
log,| they {} what was
|他们所说的 demon 恢复服务。

1396
00:43:47,950 --> 00:43:50,890
0,90 90,420 420,660 900,1710 1740,2940
it called the demon recovery

1397
00:43:50,890 --> 00:43:53,770
0,690 900,2280 2280,2400 2400,2700 2700,2880
service.| Yeah, the demon just
|是的， demon 会回到，

1398
00:43:53,770 --> 00:43:55,930
0,570 600,780 780,1080 1080,1770 1890,2160
gonna go back to,| there's
|这里会有一个 demon ，

1399
00:43:55,930 --> 00:43:56,800
0,150 150,270 270,330 330,660 660,870
gonna be a demon,| when
|当发生崩溃时，

1400
00:43:56,800 --> 00:43:57,910
0,150 150,210 210,570 570,780 780,1110
there's a crash,| there's basically
|这里有一个 demon 查看日志中是否有什么东西，

1401
00:43:57,910 --> 00:43:59,170
0,420 420,690 690,810 810,960 960,1260
demon, sees if there's anything

1402
00:43:59,170 --> 00:44:00,040
0,120 120,210 210,600 600,690 690,870
in the log,| if there's
|如果日志里有任何东西，

1403
00:44:00,040 --> 00:44:00,940
0,240 240,300 300,390 390,690 690,900
anything in the log,| just
|就应用到文件系统。

1404
00:44:00,940 --> 00:44:02,170
0,480 480,570 570,660 660,930 930,1230
applies to the file system.|
|

1405
00:44:03,830 --> 00:44:06,380
0,420 480,1980 1980,2250 2250,2400 2400,2550
And why actually do this
为什么要这样做，

1406
00:44:06,380 --> 00:44:07,340
0,90 90,270 270,570 570,780 780,960
in the way,| why not
|为什么不立即写入或更新文件系统？

1407
00:44:07,340 --> 00:44:08,750
0,180 180,450 450,900 900,1110 1110,1410
just write immediately or update

1408
00:44:08,750 --> 00:44:09,660
0,60 60,300 300,630
the file system?|
|

1409
00:44:14,950 --> 00:44:16,060
0,390 390,480 480,660 660,1020 1020,1110
Because we can crash in
因为我们可能会在更新过程中崩溃，

1410
00:44:16,060 --> 00:44:17,200
0,60 60,390 390,510 510,780 780,1140
the middle of that update,|
|

1411
00:44:17,200 --> 00:44:18,280
0,90 90,180 180,390 390,810 900,1080
and we don't know what
我们不知道我们完成了[]。

1412
00:44:18,280 --> 00:44:20,110
0,150 150,420 420,690 690,1290 1320,1830
we've done {[] -}.| Yeah,
|是的，完全正确，

1413
00:44:20,110 --> 00:44:21,940
0,450 450,690 690,900 900,1530 1530,1830
exactly, correct,| so {in,sort,of -}
|在我们之前的例子中，

1414
00:44:21,940 --> 00:44:23,290
0,180 180,270 270,600 600,1260 1260,1350
{} our previous example,| you
|分配 inode 是在某个地方进行一些更改，

1415
00:44:23,290 --> 00:44:25,960
0,360 1050,1590 1590,1800 1800,2190 2190,2670
know allocating {inode -} {is,presumably}

1416
00:44:25,960 --> 00:44:26,740
0,60 60,210 210,300 300,540 540,780
you know to making some

1417
00:44:26,740 --> 00:44:28,690
0,300 300,900 1110,1410 1410,1680 1680,1950
change somewhere,| like onto {inode
|比如在 inode 块上，

1418
00:44:28,690 --> 00:44:30,700
0,180 180,630 1020,1470 1470,1710 1710,2010
-} block,| and actually adding
|添加目录到，

1419
00:44:30,700 --> 00:44:33,280
0,90 90,810 810,1530 1740,2340 2340,2580
the directory to| {} or
|或将文件 f 添加到特定目录，

1420
00:44:33,280 --> 00:44:34,720
0,300 300,390 390,750 750,1080 1080,1440
adding the file f to

1421
00:44:34,720 --> 00:44:36,850
0,300 300,720 870,1350 1350,1740 1740,2130
particular directory,| updates directory block,
|更新某处的目录块，数据块，

1422
00:44:36,850 --> 00:44:38,710
0,240 240,510 510,1110 1470,1680 1680,1860
data block somewhere,| so these
|所以这是两个独立的磁盘写入，

1423
00:44:38,710 --> 00:44:40,060
0,60 60,210 210,570 570,1080 1110,1350
are two separate writes, right,

1424
00:44:40,060 --> 00:44:41,140
0,90 90,420 420,870 870,960 960,1080
two separate {disk,writes},| and they're
|它们不是原子的，

1425
00:44:41,140 --> 00:44:42,280
0,210 210,630 630,840 840,990 990,1140
not atomic,| so we would
|所以我们会在两者中的一个崩溃，

1426
00:44:42,280 --> 00:44:43,300
0,300 300,600 600,810 810,900 900,1020
crash between one of the

1427
00:44:43,300 --> 00:44:44,590
0,480 660,870 870,960 960,1170 1170,1290
two,| then we might have
|我们可能已经分配了 inode ，

1428
00:44:44,590 --> 00:44:45,700
0,480 480,570 570,720 720,990 990,1110
allocated the {inode -},| but
|但是不在目录中，

1429
00:44:45,700 --> 00:44:46,840
0,210 210,390 390,570 570,630 630,1140
not [] in the directory,|
|

1430
00:44:47,540 --> 00:44:49,550
0,300 300,630 630,1290 1290,1560 1560,2010
then basically what will happen
那么，如果我们崩溃并恢复，会发生什么，

1431
00:44:49,550 --> 00:44:50,930
0,120 120,360 360,690 690,780 780,1380
if we crash and recover,|
|

1432
00:44:50,960 --> 00:44:52,340
0,450 450,690 690,810 810,930 930,1380
basically lose the {inode -},|
基本上会失去 inode ，|

1433
00:44:52,970 --> 00:44:54,170
0,450 450,720 720,840 840,1140 1140,1200
unless we could scan the
除非我们能扫描整个磁盘，

1434
00:44:54,170 --> 00:44:55,160
0,180 180,450 450,570 570,780 780,990
whole disk,| but that's very
|但那是非常昂贵的。

1435
00:44:55,160 --> 00:44:55,980
0,600
expensive.|
|

1436
00:44:57,380 --> 00:44:58,220
0,120 120,330 330,450 450,720 720,840
And so they said what
所以他们说我们做的是，

1437
00:44:58,220 --> 00:44:59,540
0,120 120,540 540,780 780,960 960,1320
we're doing is,| we're basically
|我们首先记录这两个更改，

1438
00:44:59,540 --> 00:45:01,340
0,420 420,510 510,780 780,1290 1290,1800
logging the two changes first,|
|

1439
00:45:01,340 --> 00:45:04,100
0,1080 1110,1560 1560,2010 2010,2490 2490,2760
we're logging records describing both
我们首先记录描述这两个更改的记录，

1440
00:45:04,100 --> 00:45:06,680
0,480 480,960 1320,1560 1560,2070 2100,2580
changes first| and then apply
|然后应用更改。

1441
00:45:06,680 --> 00:45:07,520
0,90 90,660
the changes.|
|

1442
00:45:08,800 --> 00:45:09,430
0,180 180,330 330,480 480,570 570,630
{} So how do we
那么我们如何确保操作是原子的，

1443
00:45:09,430 --> 00:45:10,960
0,240 240,330 330,960 960,1050 1050,1530
ensure the operation is atomic,|
|

1444
00:45:11,080 --> 00:45:12,070
0,270 270,420 420,720 720,900 900,990
so the first log to
所以第一个要更新的日志。

1445
00:45:12,070 --> 00:45:12,780
0,390
update.|
|

1446
00:45:13,140 --> 00:45:14,520
0,120 120,300 300,510 510,960 1110,1380
The first log update,| yeah
第一次日志更新，|是的，这很有趣，

1447
00:45:14,520 --> 00:45:16,560
0,150 150,600 660,930 930,1380 1590,2040
that's interesting,| so the paper
|论文[] 100% 对应这个，

1448
00:45:16,560 --> 00:45:18,120
0,270 270,360 360,630 630,1200 1200,1560
[] {100% - -} correspond

1449
00:45:18,120 --> 00:45:19,290
0,180 180,420 600,900 900,930 930,1170
this,| but there's a couple
|但有几种方法可以做到这一点，

1450
00:45:19,290 --> 00:45:21,030
0,150 150,210 210,450 450,690 960,1740
ways of doing {it -},|
|

1451
00:45:21,030 --> 00:45:22,890
0,240 240,660 660,1260 1260,1860 1860,1860
they mention that every {}
他们提到每个日志记录都有一个校验和，

1452
00:45:23,910 --> 00:45:25,560
0,420 420,660 660,990 990,1260 1260,1650
log record has a checksum,|
|

1453
00:45:26,380 --> 00:45:28,750
0,690 690,1290 1290,1470 1470,1620 1620,2370
and {} so they use
所以，他们使用校验和来查看是否，

1454
00:45:28,750 --> 00:45:29,800
0,390 390,510 510,750 750,870 870,1050
checksum to see, if there's

1455
00:45:29,800 --> 00:45:32,110
0,570 750,1350 1530,1680 1680,1950 1950,2310
actually,| before the read log
|在读日志记录之前，

1456
00:45:32,110 --> 00:45:33,490
0,300 300,570 570,810 810,1080 1080,1380
record, {you,know} read log record,|
|

1457
00:45:33,490 --> 00:45:34,840
0,120 120,390 390,450 450,990 1080,1350
we compute a checksum,| just
我们计算一个校验和，|为了确保整个记录是完整的。

1458
00:45:34,840 --> 00:45:35,440
0,60 60,210 210,390 390,540 540,600
to make sure that the

1459
00:45:35,440 --> 00:45:36,840
0,270 270,540 540,630 630,1140
whole record is complete.|
|

1460
00:45:38,620 --> 00:45:40,030
0,210 210,420 480,690 690,840 900,1410
I see, thank you.| Another
我明白了，谢谢。|另一种方法是，

1461
00:45:40,030 --> 00:45:40,720
0,120 120,210 210,420 420,540 540,690
way of doing it,| which
|一种其他方式是，

1462
00:45:40,720 --> 00:45:41,440
0,120 120,240 240,510 510,660 660,720
is a couple way of

1463
00:45:41,440 --> 00:45:42,370
0,180 180,270 270,390 390,540 540,930
doing it,| as you write
|在你写入多个块时，比如 1 2 ，

1464
00:45:42,370 --> 00:45:43,510
0,90 90,180 180,180 180,480 480,1140
you know a couple blocks
你知道几个街区就像一二

1465
00:45:43,750 --> 00:45:44,800
0,270 270,450 450,840 840,960 960,1050
like 1 2,| and then
|然后你写入一个提交记录，

1466
00:45:44,800 --> 00:45:45,820
0,120 120,270 270,300 300,600 600,1020
you write a commit record,|
|

1467
00:45:46,620 --> 00:45:48,300
0,690 690,780 780,1230 1230,1380 1380,1680
and the assumption is that,|
我们的假设是，|

1468
00:45:48,300 --> 00:45:49,650
0,210 210,300 300,720 720,1200 1230,1350
writing a single block, a
写入单个块，单个 512 扇区是原子操作，

1469
00:45:49,650 --> 00:45:51,720
0,300 300,1410 1410,1860 1860,1980 1980,2070
single 512 sector is an

1470
00:45:51,720 --> 00:45:53,430
0,390 390,900 900,1110 1110,1410 1410,1710
atomic operation,| so either happens
|所以要么发生，要么不发生，

1471
00:45:53,430 --> 00:45:54,720
0,60 60,120 120,360 360,690 1080,1290
or it doesn't happen,| so
|所以你需要提交记录，

1472
00:45:54,720 --> 00:45:55,560
0,60 60,150 150,270 270,510 510,840
you need to commit {records

1473
00:45:55,560 --> 00:45:57,180
0,390 420,750 750,840 840,1320 1410,1620
-},| writes are done or
|完成写入或未完成写入，

1474
00:45:57,180 --> 00:45:58,770
0,210 210,270 270,450 450,780 1170,1590
writes are not done,| and
|所以，你只需查看提交记录，

1475
00:45:58,770 --> 00:45:59,400
0,120 120,240 240,330 330,510 510,630
so you can just look

1476
00:45:59,400 --> 00:46:00,420
0,60 60,120 120,390 390,750 750,1020
at the commit record,| and
|如果提交记录不在那里，

1477
00:46:00,420 --> 00:46:02,100
0,120 120,210 210,450 450,870 870,1680
if the commit records is

1478
00:46:02,100 --> 00:46:03,930
0,390 390,900 930,1110 1110,1200 1200,1830
not there,| then you know
|那么你就知道操作还没有完全记录下来，

1479
00:46:03,930 --> 00:46:05,970
0,510 540,1080 1080,1200 1200,1650 1650,2040
the operation is not completely

1480
00:46:05,970 --> 00:46:07,350
0,390 390,720 870,1050 1050,1110 1110,1380
recorded yet,| and you shouldn't
|你不应该执行其中任何一项。

1481
00:46:07,350 --> 00:46:08,360
0,330 330,540 540,660 660,870
execute any of it.|
|

1482
00:46:10,000 --> 00:46:11,470
0,150 150,420 510,810 810,1230 1230,1470
I see,| and also to
我明白了，|再仔细检查一下上一张幻灯片，

1483
00:46:11,470 --> 00:46:13,630
0,690 690,750 750,870 870,1380 1380,2160
double-check on the previous slide,|
|

1484
00:46:13,630 --> 00:46:15,370
0,210 210,390 390,780 780,1230 1230,1740
if the crash happens before
如果崩溃发生在我们把东西刷新到 Petal 之前，

1485
00:46:15,370 --> 00:46:17,680
0,360 480,900 900,1260 1260,1710 1830,2310
we flush things to Petal,|
|

1486
00:46:17,980 --> 00:46:18,850
0,360 360,540 540,630 630,780 780,870
then this is not a
那么这不是问题，对吧，

1487
00:46:18,850 --> 00:46:20,830
0,390 390,600 600,1080 1080,1890 1890,1980
problem right,| because if the
|因为如果工作站崩溃，

1488
00:46:20,830 --> 00:46:22,390
0,480 480,960 960,1170 1170,1260 1260,1560
workstation crashes,| well, the crash
|崩溃跟工作站一起，

1489
00:46:22,390 --> 00:46:23,590
0,240 240,360 360,420 420,1020 1020,1200
goes with the workstation,| but
|但其他任何工作站都没有不一致的状态。

1490
00:46:23,590 --> 00:46:25,030
0,300 300,450 450,1080 1080,1320 1320,1440
there's no inconsistent state for

1491
00:46:25,030 --> 00:46:27,400
0,120 120,330 330,840 1080,1650 2040,2370
any other workstation.| {That's,correct\,,just} data
|这是正确的，只是数据会丢失，

1492
00:46:27,400 --> 00:46:30,280
0,90 90,180 180,660 1350,2490 2550,2880
would be lost,| if it's
|如果没有写到 Petal 中，

1493
00:46:30,280 --> 00:46:31,390
0,270 270,450 450,540 540,690 690,1110
not written to the Petals,|
|

1494
00:46:31,390 --> 00:46:33,250
0,270 270,360 360,480 480,1470 1470,1860
won't be any visibility problem.|
就不会有任何可见性问题。|

1495
00:46:33,670 --> 00:46:34,600
0,180 180,300 300,750 750,840 840,930
So it's really you know
所以崩溃发生在这里，

1496
00:46:34,600 --> 00:46:36,580
0,90 90,630 840,1170 1170,1590 1590,1980
the crash crash here, correct,|
|

1497
00:46:37,480 --> 00:46:38,710
0,150 150,360 360,540 540,720 720,1230
that one doesn't really matter
在某些方面，这个并不重要，

1498
00:46:38,740 --> 00:46:40,030
0,90 90,270 270,810 960,1140 1140,1290
in some ways,| the one
|真正重要的是这个刷新操作中的崩溃。

1499
00:46:40,030 --> 00:46:40,960
0,90 90,360 360,690 690,810 810,930
that actually matters is the

1500
00:46:40,960 --> 00:46:42,790
0,360 360,780 780,960 960,1260 1260,1830
crash during this flush operation.|
|

1501
00:46:43,790 --> 00:46:45,260
0,690 780,990 990,1170
Mhm, thank you.|
嗯，谢谢。|

1502
00:46:51,140 --> 00:46:52,940
0,450 480,930 1020,1590 1590,1680 1680,1800
Okay, so, {} you know
好的，所以，在 Frangipani 有一个技巧，

1503
00:46:52,940 --> 00:46:54,920
0,210 210,540 540,1320 1380,1620 1620,1980
there's one subtly {} in

1504
00:46:54,920 --> 00:46:56,240
0,240 240,300 300,720 720,930 930,1320
{Frangipani - -},| which we'll
|我们稍后会更详细地讨论这一点，

1505
00:46:56,240 --> 00:46:57,140
0,210 210,450 450,540 540,600 600,900
talk about in a second

1506
00:46:57,140 --> 00:46:58,610
0,30 30,180 180,300 300,450 480,1470
a little bit more detail,|
|

1507
00:46:58,610 --> 00:47:00,620
0,480 480,840 930,1320 1320,1740 1740,2010
namely that {in,Frangipani -}, there's
也就是，在 Frangipani 中，每个服务器都有一个锁，

1508
00:47:00,620 --> 00:47:01,220
0,300
{}

1509
00:47:03,320 --> 00:47:04,740
0,270 270,990
a lock

1510
00:47:05,030 --> 00:47:06,380
0,480 480,1050
per server,|
|

1511
00:47:07,300 --> 00:47:09,100
0,240 240,390 390,480 480,1230
that's sort of unusual,|
这有点不寻常，|

1512
00:47:09,410 --> 00:47:10,730
0,660 660,900 900,1050 1050,1260 1260,1320
and {} we'll see in
我们稍后会看到，

1513
00:47:10,730 --> 00:47:11,930
0,30 30,510 540,720 720,930 930,1200
a second,| you know how
|这回造成什么问题，

1514
00:47:11,930 --> 00:47:13,400
0,360 390,900 900,990 990,1230 1230,1470
the one that actually creates

1515
00:47:13,400 --> 00:47:15,650
0,120 120,780 810,1440 1740,2040 2040,2250
some problems,| {} and so
|所以我们将会看到，

1516
00:47:15,650 --> 00:47:17,900
0,780 780,960 960,1710 1710,1770 1770,2250
we'll see,| there's a small
|协议有一个小的扩展，

1517
00:47:17,900 --> 00:47:19,160
0,510 510,600 600,690 690,1140 1140,1260
extension to the protocol| to
|让这个正常工作。

1518
00:47:19,160 --> 00:47:20,210
0,360 360,600 600,780 780,900 900,1050
actually {} make this all

1519
00:47:20,210 --> 00:47:20,960
0,240 240,480
work out.|
|

1520
00:47:22,600 --> 00:47:24,190
0,390 420,720 720,1230 1260,1500 1500,1590
Okay, let me say a
好的，让我简单地说一下，

1521
00:47:24,190 --> 00:47:25,360
0,180 180,330 330,570 570,960 960,1170
little bit about [],| what
|日志记录中有什么，

1522
00:47:25,360 --> 00:47:26,050
0,120 120,240 240,420 420,480 480,690
is in one of those

1523
00:47:26,050 --> 00:47:27,160
0,300 300,840
log records,|
|

1524
00:47:32,570 --> 00:47:33,230
0,120 120,330 330,480 480,540 540,660
it turns out to be
事实证明，这对崩溃恢复非常重要，

1525
00:47:33,230 --> 00:47:36,320
0,540 540,1200 1230,2100 2130,2730 2760,3090
important for {} the crash

1526
00:47:36,320 --> 00:47:39,350
0,630 900,1980 1980,2250 2250,2430 2430,3030
recovery,| particularly because we have
|特别是我们每台服务器都有多个 Frangipani 日志。

1527
00:47:39,410 --> 00:47:41,390
0,240 240,660 660,990 990,1560 1650,1980
{Frangipani -} multiple logs per

1528
00:47:41,390 --> 00:47:42,140
0,510
server.|
|

1529
00:47:43,000 --> 00:47:44,260
0,150 150,360 360,720 720,930 930,1260
So every log has a,|
所以每个日志都有，|

1530
00:47:44,810 --> 00:47:46,940
0,480 750,1110 1110,1470 1470,2040 2040,2130
so your log, basically you
所以有记录在日志中，

1531
00:47:46,940 --> 00:47:48,170
0,150 150,360 360,720 720,870 870,1230
know {there,are} records in it,|
|

1532
00:47:48,500 --> 00:47:49,580
0,270 270,390 390,600 600,660 660,1080
{} they have a sequence
它们有一个序列号，

1533
00:47:49,580 --> 00:47:50,420
0,540
number,|
|

1534
00:47:51,060 --> 00:47:53,970
0,300 300,900 1470,1830 1830,2400 2430,2910
{you,know} whatever number 2, 1
不论编号 2 ， 1 2 ，

1535
00:47:53,970 --> 00:47:55,770
0,570 930,1350 1350,1470 1470,1590 1590,1800
2,| and you know what
|日志的结尾是，

1536
00:47:55,770 --> 00:47:56,460
0,120 120,210 210,300 300,390 390,690
the end of the log

1537
00:47:56,460 --> 00:47:57,870
0,270 270,630 630,840 840,1080 1080,1410
is,| if the next sequence
|下一个序列号比你的高一。

1538
00:47:57,870 --> 00:47:58,950
0,270 270,390 390,570 570,810 810,1080
number is now higher, one

1539
00:47:58,950 --> 00:48:00,620
0,420 420,810 900,1470
higher than yours.|
|

1540
00:48:01,220 --> 00:48:02,390
0,420 420,600 600,900 900,1050 1050,1170
So there's another way they
所以他们有另一种标记的方法，

1541
00:48:02,390 --> 00:48:04,220
0,330 330,420 420,750 990,1680 1680,1830
mark it up,| basically in
|在这些记录中是更新数组，

1542
00:48:04,220 --> 00:48:06,680
0,210 210,300 300,750 990,1980 2160,2460
one of these records is

1543
00:48:06,680 --> 00:48:08,940
0,1080 1080,1200 1200,1830
array of updates,|
|

1544
00:48:12,930 --> 00:48:14,520
0,390 390,990 990,1080 1080,1320 1320,1590
{} describe the file system
描述文件系统操作，

1545
00:48:14,520 --> 00:48:16,440
0,630 1020,1260 1260,1410 1410,1530 1530,1920
operation,| and so it contains
|所以它包含需要更新的块号，

1546
00:48:16,440 --> 00:48:17,600
0,90 90,390 390,870
the block number,

1547
00:48:18,120 --> 00:48:19,350
0,210 210,390 390,480 480,570 570,1230
that needs to be updated,|
|

1548
00:48:19,380 --> 00:48:20,460
0,210 210,570 570,660 660,810 810,1080
for example in our case,
例如，在我们的示例中，这是 inode 编号，

1549
00:48:20,460 --> 00:48:22,350
0,120 120,330 330,810 870,1380 1380,1890
that would usually be {

1550
00:48:22,740 --> 00:48:24,060
0,300 300,630 630,810 810,960 960,1320
-} the {inode -} number,|
|

1551
00:48:24,060 --> 00:48:25,110
0,90 90,330 330,510 510,900 900,1050
the block that contains the
包含信息节点的块，

1552
00:48:25,110 --> 00:48:26,190
0,90 90,480 480,840 840,990 990,1080
{inodes -},| that would be
|它会分配一个版本号，

1553
00:48:26,190 --> 00:48:28,700
0,660 900,1200 1200,1500 1500,2010
allocated a version number,|
|

1554
00:48:29,010 --> 00:48:30,210
0,300 300,420 420,630 630,1020 1020,1200
because in that record,| we've
因为在这一记录中，|我们随后会看到，为什么这很重要，

1555
00:48:30,210 --> 00:48:31,740
0,210 210,720 930,1260 1260,1440 1440,1530
seen second, why that is

1556
00:48:31,740 --> 00:48:33,330
0,600 750,900 900,1230 1230,1350 1350,1590
important,| and basically the new
|基本上是该块编号的新字节。

1557
00:48:33,330 --> 00:48:35,910
0,630 1530,1710 1710,1830 1830,2130 2130,2580
bytes for that block number.|
|

1558
00:48:37,840 --> 00:48:38,950
0,240 240,510 510,750 750,1050 1050,1110
And so, for example, in
例如，在创建文件的情况下， create f ，

1559
00:48:38,950 --> 00:48:40,150
0,60 60,300 300,390 390,930 930,1200
the case of creating {}

1560
00:48:40,150 --> 00:48:42,490
0,540 540,960 960,1410 2040,2190 2190,2340
file, create f,| it's gonna
|这个数组中会有两个条目，

1561
00:48:42,490 --> 00:48:43,960
0,300 300,510 510,1200
be {you,know} two

1562
00:48:44,190 --> 00:48:45,990
0,510 510,960 960,1050 1050,1200 1200,1800
{} entries in this array,|
|

1563
00:48:46,260 --> 00:48:47,700
0,420 420,1080
two entries,|
两个条目，|

1564
00:48:49,140 --> 00:48:51,540
0,360 360,1170 1260,1740 1740,2220 2220,2400
one describing the update to
一个描述对 inode 块的更新，

1565
00:48:51,540 --> 00:48:53,730
0,180 180,480 480,990 990,1320 1320,2190
the inode block,| one describing
|一个描述对目录数据块的更新。

1566
00:48:53,910 --> 00:48:56,190
0,210 210,630 630,840 840,1380 1620,2280
the update to the directory

1567
00:48:56,190 --> 00:48:57,120
0,300 300,360 360,600 600,840 840,930
block, the data block of

1568
00:48:57,120 --> 00:48:58,000
0,90 90,600
the directory.|
|

1569
00:48:58,500 --> 00:48:59,620
0,1020

1570
00:49:05,140 --> 00:49:06,340
0,150 150,330 330,690 690,870 870,1200
And so basically what happens
所以，复制过程中会发生什么，

1571
00:49:06,340 --> 00:49:07,690
0,180 180,810 810,990 990,1140 1140,1350
on replication,| just to like
|只是想把这一点说得非常清楚，

1572
00:49:07,690 --> 00:49:10,270
0,330 870,1020 1020,1500 1500,2190 2190,2580
make this abundantly clear,| when
|当 revoke 的请求传入时，

1573
00:49:10,270 --> 00:49:11,830
0,180 180,600 600,780 780,1290 1290,1560
{} request to {} revoke

1574
00:49:11,830 --> 00:49:13,450
0,210 210,600 900,1020 1020,1140 1140,1620
comes in,| you know the
|发生的第一件事是将日志放入 Petal ，

1575
00:49:13,780 --> 00:49:15,190
0,510 510,630 630,780 780,1230 1230,1410
first thing that happens is

1576
00:49:15,190 --> 00:49:16,680
0,420 420,510 510,1080
force the log

1577
00:49:18,810 --> 00:49:20,360
0,390 390,960
to Petal,|
|

1578
00:49:20,750 --> 00:49:22,400
0,300 300,480 480,570 570,1050 1230,1650
once that is done,| send
一旦完成，|发送更新块到 Petal ，

1579
00:49:22,400 --> 00:49:23,750
0,270 330,930 930,1050 1050,1260 1260,1350
the, updates were sent the

1580
00:49:23,750 --> 00:49:25,400
0,660 750,900 900,1260 1260,1560 1560,1650
blocks, the updated blocks to

1581
00:49:25,400 --> 00:49:26,200
0,510
Petal,|
|

1582
00:49:34,660 --> 00:49:36,190
0,210 210,690 690,1020 1020,1110 1110,1530
and then release the lock.|
然后释放锁。|

1583
00:49:41,790 --> 00:49:43,440
0,330 330,480 480,960 960,1380 1440,1650
And this ensures that,| you
这可以确保，|我们需要考虑几件事情，

1584
00:49:43,440 --> 00:49:44,400
0,90 90,330 330,570 570,810 810,960
know there's a couple things

1585
00:49:44,400 --> 00:49:45,450
0,120 120,180 180,360 360,870 870,1050
that we need to think

1586
00:49:45,450 --> 00:49:47,790
0,420 690,1770 1770,1830 1980,2190 2190,2340
about,| {} if if there's
|如果中间没有崩溃，

1587
00:49:47,790 --> 00:49:48,810
0,150 150,510 510,600 600,660 660,1020
no crashes in the middle,|
|

1588
00:49:48,810 --> 00:49:49,770
0,300 300,390 390,480 480,690 690,960
then you know this is
那么这如前所述，

1589
00:49:49,770 --> 00:49:53,070
0,810 810,1170 1620,2040 2040,2670 2790,3300
always as previously described,| really
|是有趣的例子，

1590
00:49:53,070 --> 00:49:54,750
0,60 60,210 210,570 570,1230 1230,1680
you know interesting cases,| when
|当崩溃发生在，

1591
00:49:54,750 --> 00:49:57,600
0,540 570,1080 1080,1740 1830,2550 2550,2850
a crash happens,| right after
|正好在发送日志到 P ，但是在更新 Petal 之前。

1592
00:49:57,600 --> 00:49:58,920
0,330 330,420 420,690 690,780 780,1320
forcing the log to P,

1593
00:49:59,040 --> 00:50:01,110
0,390 390,840 840,1320 1320,1680 1680,2070
{} but before updating Petal.|
|

1594
00:50:02,550 --> 00:50:03,240
0,150 150,300 300,450 450,480 480,690
So let's talk a little
所以，让我们稍微谈谈这一点。

1595
00:50:03,240 --> 00:50:04,320
0,120 120,330 330,750
bit about that.|
|

1596
00:50:06,670 --> 00:50:07,540
0,390 390,540 540,630 630,690 690,870
Sorry, what do you mean
抱歉，你说的新字节是什么意思？

1597
00:50:07,540 --> 00:50:09,120
0,270 270,630 630,1350
by new bytes?|
|

1598
00:50:09,730 --> 00:50:11,320
0,420 420,780 840,1020 1020,1170 1170,1590
{} Good, let me {}
好的，让我回去，

1599
00:50:13,070 --> 00:50:14,450
0,150 150,660 900,1110 1110,1260 1260,1380
go back,| so with another
|使用另一种方式，更改信息节点块，

1600
00:50:14,450 --> 00:50:16,310
0,120 120,750 750,1200 1200,1560 1560,1860
{} mean, changes to {inode

1601
00:50:16,310 --> 00:50:17,960
0,240 240,810 810,1020 1020,1530 1530,1650
-} blocks,| {so,for} example the
|以 inode 块为例，

1602
00:50:17,960 --> 00:50:20,300
0,150 150,330 330,870 1200,2190 2190,2340
{inode -} block,| {} you
|也许更新 inode 的某些部分，，

1603
00:50:20,300 --> 00:50:21,980
0,120 120,660 660,1230 1230,1590 1590,1680
know maybe {you,know} updating you

1604
00:50:21,980 --> 00:50:22,940
0,210 210,600 600,780 780,870 870,960
know some part of the

1605
00:50:22,940 --> 00:50:23,840
0,120 120,330 330,510 510,630 630,900
{inode -},| then you {sort,of}
|然后你可以写下字节发生了变化，

1606
00:50:23,840 --> 00:50:27,050
0,300 300,2130 2160,2550 2550,2760 2760,3210
write down {the,bytes} have changed,|
|

1607
00:50:27,050 --> 00:50:29,090
0,450 750,1320 1320,1680 1680,1800 1800,2040
like bytes 0 to 5
比如字节 0 到 5 和 12 有下列值，

1608
00:50:29,090 --> 00:50:30,410
0,120 120,540 540,630 630,900 900,1320
and 12 {have,the} following value,|
|

1609
00:50:30,740 --> 00:50:32,150
0,330 330,540 540,930 1020,1290 1290,1410
or {bytes -} 10 to
或字节 10 到 20 具有以下新值。

1610
00:50:32,150 --> 00:50:33,410
0,510 510,810 810,900 900,1080 1080,1260
20 have the following new

1611
00:50:33,410 --> 00:50:34,180
0,450
value.|
|

1612
00:50:36,200 --> 00:50:37,670
0,300 300,510 510,840 840,1290 1290,1470
But can those changes be
但这些变化会不会像，

1613
00:50:37,670 --> 00:50:38,840
0,420 480,720 720,870 870,1080 1080,1170
like,| because each one of
|因为这些块中的每一个最多为 512 字节，

1614
00:50:38,840 --> 00:50:40,160
0,300 300,780 780,930 930,1050 1050,1320
these blocks is at most

1615
00:50:40,160 --> 00:50:43,880
0,990 990,1350 1920,2670 2670,2820 2820,3720
512 bytes,| but the modifications
|但你所做的修改可能比 512 字节大得多，

1616
00:50:43,880 --> 00:50:44,510
0,120 120,240 240,420 420,510 510,630
that you make can be

1617
00:50:44,510 --> 00:50:47,030
0,300 300,570 570,1050 1050,1440 1650,2520
a lot larger than 512

1618
00:50:47,030 --> 00:50:48,650
0,720 810,1200 1200,1380 1380,1500 1500,1620
bytes,| {} there's gonna be
|每一个块都会有记录。

1619
00:50:48,650 --> 00:50:50,330
0,90 90,360 360,480 480,900 900,1680
a record for every {}

1620
00:50:50,330 --> 00:50:50,960
0,450
block.|
|

1621
00:50:51,980 --> 00:50:52,970
0,360 360,480 480,750 750,900 900,990
So, in fact, in the,
所以，事实上，好的，所以有几点，

1622
00:50:52,970 --> 00:50:54,320
0,270 270,420 420,630 630,870 870,1350
okay, so a couple points,|
|

1623
00:50:55,110 --> 00:50:56,780
0,570 600,840 840,930 930,1380
{} first of all,|
首先，|

1624
00:50:57,000 --> 00:50:59,220
0,570 840,1530 1530,1830 1830,2100 2100,2220
{} data writes actually are
数据写入不会通过日志，

1625
00:50:59,220 --> 00:51:00,420
0,300 300,510 510,690 690,810 810,1200
not going through the log,|
|

1626
00:51:00,450 --> 00:51:01,470
0,120 120,420 420,480 480,810 810,1020
so there's an important point,|
所以有一点很重要，|

1627
00:51:01,470 --> 00:51:02,250
0,120 120,360 360,420 420,690 690,780
so thank you, thank you
所以谢谢你问这个问题，

1628
00:51:02,250 --> 00:51:03,690
0,120 120,390 390,510 510,900 1230,1440
for asking that question,| so
|所以当你写一个文件时，

1629
00:51:03,690 --> 00:51:04,920
0,330 330,450 450,600 600,690 690,1230
when you write a file,|
|

1630
00:51:05,190 --> 00:51:07,230
0,420 420,810 810,870 870,1410 1410,2040
{} and the application {calls,like}
应用调用 write f 和一些数据，

1631
00:51:07,230 --> 00:51:08,580
0,300 300,660 660,990 990,1200 1200,1350
write file f and a

1632
00:51:08,580 --> 00:51:10,020
0,150 150,330 330,420 420,870 1140,1440
whole bunch of data,| all
|所有这些数据都不会通过日志，

1633
00:51:10,020 --> 00:51:11,340
0,240 240,480 480,720 720,900 900,1320
that data actually does not

1634
00:51:11,340 --> 00:51:12,460
0,180 180,390 390,480 480,930
go through the log,|
|

1635
00:51:12,670 --> 00:51:14,020
0,360 360,660 660,810 810,1020 1020,1350
{} that just goes straight
它们会直接传递给 Petal ，

1636
00:51:14,020 --> 00:51:15,250
0,90 90,540 570,840 840,1080 1080,1230
to Petal,| like once you
|比如一旦你刷新状态，

1637
00:51:15,250 --> 00:51:17,440
0,630 660,1290 1320,1860
flush the state,|
|

1638
00:51:17,680 --> 00:51:19,600
0,360 390,690 690,1260 1260,1800 1800,1920
{} the only changes that
通过日志的唯一更改是元更新更改，

1639
00:51:19,600 --> 00:51:20,590
0,150 150,360 360,450 450,870 870,990
go through the log are

1640
00:51:20,590 --> 00:51:23,230
0,360 360,1110 1200,1920 1950,2160 2160,2640
meta update changes,| so {metadata
|所以元数据更改，

1641
00:51:23,260 --> 00:51:25,240
0,360 360,1050
-} changes,|
|

1642
00:51:26,100 --> 00:51:28,110
0,180 180,660 900,1530 1530,1860 1860,2010
and what metadata means is
元数据的含义是关于文件的信息，

1643
00:51:28,110 --> 00:51:30,160
0,330 330,780 780,1170 1170,1770
really information about files,|
|

1644
00:51:30,640 --> 00:51:32,440
0,480 480,690 690,900 900,1290 1380,1800
so {inodes -} {} {directories
所以 inode 目录，这类东西，

1645
00:51:32,440 --> 00:51:33,700
0,480 510,720 720,870 870,930 930,1260
-}, that kind of stuff,|
|

1646
00:51:33,700 --> 00:51:35,020
0,210 210,450 450,660 660,780 780,1320
that actually goes through {the,log}.|
它们会通过日志。|

1647
00:51:35,660 --> 00:51:38,330
0,360 360,780 1020,1830 1950,2160 2160,2670
And so {} the description
所以你在这里看到的描述是，

1648
00:51:38,330 --> 00:51:39,500
0,150 150,270 270,540 540,660 660,1170
that you see in here

1649
00:51:39,500 --> 00:51:40,460
0,120 120,570 570,630 630,780 780,960
is,| really you know the
|文件系统元数据块的更新，

1650
00:51:40,460 --> 00:51:42,260
0,480 480,600 600,750 750,1260 1260,1800
updates to the metadata blocks

1651
00:51:42,290 --> 00:51:43,970
0,210 210,300 300,570 570,990 1320,1680
of the file system,| so
|inode 和目录数据。

1652
00:51:43,970 --> 00:51:46,280
0,180 180,780 960,1530 1530,1890 1890,2310
{inodes -} and directory data.|
|

1653
00:51:48,300 --> 00:51:50,460
0,480 480,780 810,1500 1500,1740 1740,2160
And the application level data,|
应用级别数据，|

1654
00:51:50,490 --> 00:51:52,020
0,660 660,780 780,1110 1110,1410 1410,1530
like the file blocks that
实际构成文件的文件块，

1655
00:51:52,020 --> 00:51:54,120
0,210 210,810 810,870 870,1380 1740,2100
actually constitute a file,| and
|这些数据块直接写入到 Petal ，

1656
00:51:54,120 --> 00:51:55,650
0,330 330,690 690,1140 1140,1470 1470,1530
that actually those blocks are

1657
00:51:55,650 --> 00:51:56,910
0,180 180,390 390,840 840,930 930,1260
just written straight to Petal,|
|

1658
00:51:56,910 --> 00:51:57,600
0,120 120,300 300,480 480,660 660,690
and no go through a
不通过日志。

1659
00:51:57,600 --> 00:51:58,300
0,480
log.|
|

1660
00:51:59,620 --> 00:52:01,270
0,180 180,270 270,630 630,780 780,1650
So it's interesting to contemplate
所以，思考这一点的含义是很有趣的，

1661
00:52:01,270 --> 00:52:02,320
0,270 270,330 330,450 450,960 960,1050
what is the implications of

1662
00:52:02,320 --> 00:52:04,270
0,360 570,930 930,1080 1080,1440 1440,1950
that,| like that design choice,|
|那个设计选择，|

1663
00:52:07,130 --> 00:52:08,630
0,240 240,360 360,1080 1110,1230 1230,1500
what's the downside of not
不把每件事都通过日志有什么坏处？

1664
00:52:08,630 --> 00:52:10,200
0,210 210,570 570,720 720,1290
writing everything through {the,log}?|
|

1665
00:52:12,330 --> 00:52:13,220
0,630
Assel.|
Assel 。|

1666
00:52:17,130 --> 00:52:18,420
0,300 300,690 690,780 780,930 930,1290
The updates to the data
对数据的更新可能会丢失。

1667
00:52:18,420 --> 00:52:20,120
0,150 150,360 360,450 450,1260
they can be lost.|
|

1668
00:52:20,840 --> 00:52:22,360
0,270 270,570 570,870 870,1200
{They,can} get lost, yeah,|
它们可能会丢失，是的，|

1669
00:52:23,010 --> 00:52:24,360
0,210 210,420 420,600 600,840 870,1350
what other sort of scenarios
还有哪些其他场景是可能的，

1670
00:52:24,360 --> 00:52:25,440
0,90 90,510 510,630 630,810 810,1080
are possible,| so let's say
|假设文件由 10 个数据块组成，

1671
00:52:25,440 --> 00:52:27,030
0,120 120,300 300,960 990,1290 1290,1590
you know the file consists

1672
00:52:27,030 --> 00:52:29,130
0,90 90,300 300,900 1260,1950 1950,2100
of 10 blocks,| {} we're
|我们开始写 10 个块，

1673
00:52:29,130 --> 00:52:30,780
0,510 510,840 870,1080 1080,1560 1560,1650
{start,writing} the 10 blocks,| you
|文件的最终状态是什么样的？

1674
00:52:30,780 --> 00:52:32,430
0,180 180,630 630,870 870,1350 1350,1650
know what's in what states

1675
00:52:32,430 --> 00:52:33,690
0,210 210,570 570,810 810,960 960,1260
can file actually end up?|
|

1676
00:52:36,910 --> 00:52:39,490
0,420 420,1380 1740,2160 2160,2400 2400,2580
{Be,inconsistent -}.| Yeah, well, yeah,
变得不一致。|是的，不一致，

1677
00:52:39,490 --> 00:52:40,570
0,480 480,600 600,810 810,990 990,1080
inconsistent,| could have some of
|一些写入，没有写入，全部写入，

1678
00:52:40,570 --> 00:52:41,440
0,90 90,480 480,660 660,780 780,870
the writes, none of the

1679
00:52:41,440 --> 00:52:42,820
0,390 390,600 600,750 750,1110 1110,1380
writes, all of them,| who
|谁知道是什么，

1680
00:52:42,820 --> 00:52:44,120
0,270 270,600 600,1020
knows what, right,|
|

1681
00:52:44,680 --> 00:52:45,730
0,180 180,300 300,510 510,900 900,1050
but it not guarantee that
但它不能保证所有 10 个都会同时应用。

1682
00:52:45,730 --> 00:52:46,510
0,180 180,360 360,420 420,570 570,780
all 10 of them will

1683
00:52:46,510 --> 00:52:47,700
0,90 90,420 420,900
be applied together.|
|

1684
00:52:48,470 --> 00:52:50,120
0,360 390,570 570,870 900,1410 1470,1650
{} This is, so this
所以这是很重要的，

1685
00:52:50,120 --> 00:52:51,290
0,120 120,630 630,810 810,930 930,1170
is important,| when you have
|当你需要原子写入时。

1686
00:52:51,290 --> 00:52:53,200
0,510 780,990 990,1230 1230,1560
like like this like

1687
00:52:53,370 --> 00:52:56,540
0,420 420,540 540,1320 1350,2190
need for atomic write.|
|

1688
00:52:56,980 --> 00:52:58,000
0,690

1689
00:52:58,350 --> 00:53:00,060
0,510 690,990 990,1320 1320,1470 1470,1710
Yeah, like if you didn't
好的，如果你不需要原子性，

1690
00:53:00,060 --> 00:53:02,910
0,270 300,1620 1620,2040 2220,2580 2580,2850
need {atomicity -},| {} with
|我们能不能去掉那些日志？

1691
00:53:02,910 --> 00:53:04,980
0,300 300,810 900,1110 1110,1470 1770,2070
this, like could we get

1692
00:53:04,980 --> 00:53:05,820
0,180 180,330 330,570 570,720 720,840
rid of that of the

1693
00:53:05,820 --> 00:53:06,620
0,540
log?|
|

1694
00:53:07,500 --> 00:53:09,810
0,660 660,1260 1320,1470 1470,1710 1890,2310
{} The, I think so,|
我想是的，|

1695
00:53:09,810 --> 00:53:11,040
0,120 120,540 540,600 600,930 930,1230
holds on the question {a,second},|
先保留这个问题，|

1696
00:53:11,040 --> 00:53:11,760
0,150 150,360 360,510 510,630 630,720
let's first talk about the
让我们首先来谈谈应用程序，

1697
00:53:11,760 --> 00:53:13,380
0,600 600,900 900,1410 1410,1530 1530,1620
applications,| and then we'll come
|然后我们再回到那个问题上。

1698
00:53:13,380 --> 00:53:16,720
0,510 900,1650 1800,2400 2430,3060
back {to,that}.| So, {}
|所以，好的，那个。

1699
00:53:16,830 --> 00:53:20,420
0,540 660,1260 1470,2250 2550,3270
okay, {} the {}.|
|

1700
00:53:21,480 --> 00:53:23,260
0,720

1701
00:53:23,460 --> 00:53:25,140
0,330 360,510 510,1080 1080,1410 1410,1680
So the applications can't really
所以，应用程序不能真正将它们的数据原子地写入日志，

1702
00:53:25,140 --> 00:53:26,280
0,450 450,540 540,660 660,840 840,1140
write you know their data

1703
00:53:26,280 --> 00:53:27,930
0,600 630,930 930,1170 1170,1410 1410,1650
atomically {} {to,the} log,| because
|因为数据没有写入日志，

1704
00:53:27,930 --> 00:53:28,950
0,300 300,510 510,600 600,780 780,1020
the data is not written

1705
00:53:28,950 --> 00:53:31,050
0,270 270,1110 1110,1650 1680,1920 1920,2100
for log,| and so not
|所以没有写入日志，然后应用，

1706
00:53:31,050 --> 00:53:31,890
0,210 210,360 360,630 630,720 720,840
written to log and then

1707
00:53:31,890 --> 00:53:33,900
0,360 390,810 1350,1530 1530,1680 1680,2010
apply,| so so that means
|所以，这意味着，

1708
00:53:33,900 --> 00:53:34,980
0,180 180,240 240,570 570,990 990,1080
that,| for example if an
|例如，如果应用程序希望原子性地写入某个文件，

1709
00:53:34,980 --> 00:53:36,000
0,480 480,600 600,840 840,960 960,1020
application you want {atomicity -

1710
00:53:36,000 --> 00:53:37,440
0,360 360,600 600,1230
-} of {}

1711
00:53:37,640 --> 00:53:39,410
0,270 270,420 420,1050 1110,1410 1410,1770
of your writes into particular

1712
00:53:39,410 --> 00:53:40,280
0,390 390,540 540,660 660,810 810,870
file,| then you have to
|那你就得自己安排，

1713
00:53:40,280 --> 00:53:42,230
0,330 330,510 510,780 810,1410 1830,1950
arrange that for yourself,| and
|事实证明，大多数 Unix 文件都是这种情况，

1714
00:53:42,230 --> 00:53:42,980
0,150 150,390 390,600 600,690 690,750
this actually turns out to

1715
00:53:42,980 --> 00:53:43,760
0,120 120,180 180,450 450,540 540,780
be the case on most

1716
00:53:43,760 --> 00:53:45,920
0,240 240,660 660,780 780,1350 1740,2160
Unix files in anyway,| so
|所以从 Frangipani 的角度来看，

1717
00:53:45,920 --> 00:53:47,060
0,150 150,360 360,600 600,810 810,1140
in that way from Frangipani,|
|

1718
00:53:47,060 --> 00:53:48,140
0,90 90,330 330,540 540,990 990,1080
it doesn't really change the
这并不能真正改变游戏规则，

1719
00:53:48,140 --> 00:53:50,570
0,510 840,1560 1830,2040 2040,2250 2250,2430
game,| you know you write
|你在 Unix 文件系统中写了一个文件，

1720
00:53:50,570 --> 00:53:51,350
0,60 60,390 390,450 450,510 510,780
a file in the Unix

1721
00:53:51,350 --> 00:53:53,120
0,270 270,810 990,1440 1440,1530 1530,1770
file system,| {} you write
|你写入一个 VM 镜像，

1722
00:53:53,120 --> 00:53:54,680
0,150 150,570 600,960 960,1350 1350,1560
like a VM image,| it's
|这不能保证整个镜像一致性地写入，

1723
00:53:54,680 --> 00:53:56,510
0,240 240,1020 1020,1230 1230,1320 1320,1830
not guaranteed like the whole

1724
00:53:56,540 --> 00:53:58,130
0,510 510,600 600,930 930,1530 1530,1590
image is written consistently,| in
|在一次访问文件系统中，

1725
00:53:58,130 --> 00:53:59,300
0,270 270,570 570,990 990,1080 1080,1170
one single shot you know

1726
00:53:59,300 --> 00:54:01,400
0,180 180,510 510,780 780,1170 1530,2100
to the file system, {}|
|

1727
00:54:01,610 --> 00:54:03,050
0,330 330,570 570,720 720,810 810,1440
even when {there -} crashes.|
甚至在崩溃时。|

1728
00:54:03,470 --> 00:54:04,550
0,180 180,270 270,630 630,960 960,1080
So the typical way you
所以人们在应用程序中解决这个问题的典型方式是，

1729
00:54:04,550 --> 00:54:06,590
0,510 570,1110 1110,1440 1440,1560 1560,2040
know people solve this problem

1730
00:54:06,590 --> 00:54:08,510
0,510 510,720 720,1440 1440,1620 1620,1920
{} in applications is that,|
|

1731
00:54:08,750 --> 00:54:09,740
0,150 150,390 390,540 540,600 600,990
it first write a temporary
它首先写入一个临时文件，

1732
00:54:09,740 --> 00:54:10,880
0,480 510,720 720,1020 1020,1110 1110,1140
file,| write everything in a
|将所有内容写入临时文件，

1733
00:54:10,880 --> 00:54:12,200
0,360 360,870 930,1080 1080,1200 1200,1320
temporary file,| and then do
|然后做一个原子重命名，变成最终文件名称。

1734
00:54:12,200 --> 00:54:14,030
0,90 90,510 510,990 1380,1710 1710,1830
an atomic rename to the

1735
00:54:14,030 --> 00:54:15,240
0,510 510,870
destination {file,name}.|
|

1736
00:54:15,720 --> 00:54:17,370
0,360 360,660 660,900 900,1290 1290,1650
So {Frangipani -} basically relies
所以， Frangipani 完全依赖于相同的设置，

1737
00:54:17,370 --> 00:54:20,550
0,600 600,690 690,780 780,1470 1740,3180
exactly on the same {}

1738
00:54:20,580 --> 00:54:21,840
0,330 330,600 630,1020 1020,1200 1200,1260
set up,| {} sort of
|一种通常的 Unix 所做的，

1739
00:54:21,840 --> 00:54:23,760
0,450 450,780 780,960 960,1230 1440,1920
normal Unix would do,| like
|Frangipani 不会修改规则，

1740
00:54:23,760 --> 00:54:24,660
0,210 210,450 450,690 690,840 840,900
{Frangipani -} doesn't change the

1741
00:54:24,660 --> 00:54:25,800
0,270 270,360 360,450 450,540 540,1140
game,| and this is why
|这就是为什么文件写入不会通过日志记录。

1742
00:54:26,220 --> 00:54:28,890
0,60 60,60 1020,1770 1770,1950 1950,2670
{} the writes of files

1743
00:54:28,920 --> 00:54:30,690
0,180 180,390 390,660 660,1410 1470,1770
are actually not logged through

1744
00:54:30,690 --> 00:54:31,500
0,120 120,600
the log.|
|

1745
00:54:31,960 --> 00:54:32,890
0,150 150,390 390,480 480,570 570,930
And what is the advantage
不通过日志有什么好处，

1746
00:54:32,890 --> 00:54:33,940
0,90 90,270 270,660 660,810 810,1050
of not logging,| so clearly
|所以很明显这是不利的一面，

1747
00:54:33,940 --> 00:54:35,560
0,240 240,300 300,870 900,1170 1170,1620
there's a downside, right,| because
|因为你不能使用日志原子地写入，

1748
00:54:35,950 --> 00:54:37,000
0,150 150,390 390,660 660,780 780,1050
you can't do a file

1749
00:54:37,000 --> 00:54:38,050
0,180 180,540 540,690 690,960 960,1050
writes {atomically -} using the

1750
00:54:38,050 --> 00:54:39,010
0,390 390,510 510,630 630,780 780,960
log,| you have to have
|你必须有自己的原子性方案，

1751
00:54:39,010 --> 00:54:40,600
0,180 180,390 390,810 810,1260 1290,1590
your own plan for {atomicity

1752
00:54:40,600 --> 00:54:42,700
0,240 240,720 960,1320 1320,1440 1440,2100
-},| but {what,is} the advantage?|
|但它的优势是什么？|

1753
00:54:45,780 --> 00:54:48,210
0,510 960,1440 1440,1920 1950,2340 2340,2430
Well, performance,| because metadata is
好的，性能，|因为元数据比实际数据要小得多。

1754
00:54:48,210 --> 00:54:49,080
0,180 180,450 450,690 690,750 750,870
very small compared to the

1755
00:54:49,080 --> 00:54:51,240
0,600 630,960 960,1320 1530,1920 1920,2160
actual user data.| Yeah.| And
|是的。|同样还有内存。

1756
00:54:51,240 --> 00:54:53,670
0,510 720,1230 1410,1530 1530,1830 2040,2430
also memory, as well.| Yeah,
|是的，就是这样，

1757
00:54:53,670 --> 00:54:55,800
0,390 390,570 570,750 750,1590 1770,2130
exactly,| so do the, like
|所以，如果你写一个巨大的文件，

1758
00:54:55,800 --> 00:54:57,420
0,390 390,540 540,780 780,1110 1110,1620
if you write a gigantic

1759
00:54:57,420 --> 00:54:59,400
0,390 390,810 1020,1260 1260,1680 1680,1980
file, correct,| saying gigabyte file,|
|比如千兆字节文件，|

1760
00:54:59,400 --> 00:55:00,120
0,150 150,330 330,540 540,600 600,720
that really means you have
这意味着你必须写入 2 千兆字节，

1761
00:55:00,120 --> 00:55:01,770
0,90 90,270 270,390 390,870 1230,1650
to write two gigabytes,| first
|首先，将千兆字节写入日志，

1762
00:55:01,770 --> 00:55:03,000
0,150 150,390 390,810 810,1140 1140,1230
{you,know} write gigabyte to the

1763
00:55:03,000 --> 00:55:03,750
0,300 300,390 390,570 570,720 720,750
log,| and then write {}
|然后将千兆字节写入磁盘，

1764
00:55:03,750 --> 00:55:04,770
0,450 450,510 510,690 690,870 870,1020
gigabyte you know to the

1765
00:55:04,770 --> 00:55:06,150
0,420 780,900 900,960 960,1230 1230,1380
disk,| and so basically this
|这会极大地降低性能，

1766
00:55:06,150 --> 00:55:07,860
0,330 330,570 570,1020 1020,1290 1290,1710
cuts {you,know} performance in a

1767
00:55:07,890 --> 00:55:09,930
0,390 390,1020 1500,1710 1710,1830 1830,2040
pretty dramatically,| and so which
|这就是为什么通常不会将用户数据写入日志。

1768
00:55:09,930 --> 00:55:10,890
0,60 60,390 390,540 540,660 660,960
is why {} you know

1769
00:55:10,920 --> 00:55:12,990
0,720 720,810 810,1080 1080,1890 1920,2070
typically the user data is

1770
00:55:12,990 --> 00:55:14,040
0,240 240,420 420,540 540,990
not written through log.|
|

1771
00:55:15,500 --> 00:55:17,060
0,450 600,870 870,990 990,1200 1200,1560
{} Yeah, it's very important
是的，这是回到前面这个问题的非常重要的部分，

1772
00:55:17,060 --> 00:55:18,020
0,330 330,420 420,630 630,870 870,960
portion of come back to

1773
00:55:18,020 --> 00:55:19,040
0,120 120,420 420,750 750,840 840,1020
this earlier question,| is very
|内部文件系统结构保持一致是非常重要的，

1774
00:55:19,040 --> 00:55:20,690
0,330 330,480 480,690 840,1380 1380,1650
important that the internal file

1775
00:55:20,690 --> 00:55:23,000
0,270 270,960 990,1530 1560,1800 1800,2310
system structures are kept consistent,|
|

1776
00:55:23,000 --> 00:55:25,070
0,180 180,480 480,930 930,1650 1650,2070
where you're not you're not
不是不一致的，

1777
00:55:25,070 --> 00:55:28,580
0,570 960,1830 2070,2340 2340,2790 2850,3510
{} inconsistent,| and so {}
|所以，元数据更新都会通过日志，

1778
00:55:28,610 --> 00:55:30,770
0,660 660,930 930,1410 1410,1800 1800,2160
therefore, the metadata updates all

1779
00:55:30,770 --> 00:55:32,780
0,150 150,330 330,900 1290,1560 1560,2010
go through {the,log},| so basically
|所以，当你创建文件时，

1780
00:55:32,780 --> 00:55:33,350
0,90 90,240 240,360 360,480 480,570
you know like when you

1781
00:55:33,350 --> 00:55:34,190
0,180 180,240 240,630 630,690 690,840
create the file,| you need
|你需要更新 inode 块，

1782
00:55:34,190 --> 00:55:35,180
0,60 60,300 300,390 390,630 630,990
to update the inode block,|
|

1783
00:55:35,180 --> 00:55:35,960
0,120 120,210 210,360 360,450 450,780
and you need to update
并且你需要更新目录块，

1784
00:55:35,960 --> 00:55:37,940
0,60 60,390 390,720 750,1140 1200,1980
the directory block,| that's guaranteed
|保证会一起发生。

1785
00:55:37,940 --> 00:55:38,840
0,60 60,330 330,810
to happen together.|
|

1786
00:55:42,490 --> 00:55:44,470
0,330 330,630 630,810 810,1290 1320,1980
{} So would the data
所以，数据块是否会介于步骤 2 和步骤 3 之间？

1787
00:55:44,500 --> 00:55:46,390
0,480 480,870 870,1050 1050,1530 1530,1890
block [] go between step

1788
00:55:46,390 --> 00:55:47,520
0,150 150,330 330,780
2 and 3?|
|

1789
00:55:48,300 --> 00:55:51,570
0,1380 1830,2220 2580,2910 2910,3150 3150,3270
Yeah, I think they just
是的，我想他们只是发送出去，

1790
00:55:51,570 --> 00:55:52,800
0,120 120,210 210,450 450,810 810,1230
send them out,| probably they
|可能在 1 之后，

1791
00:55:52,800 --> 00:55:55,020
0,450 450,1170 1170,1800 1800,1950 1950,2220
probably after 1,| they probably
|它们可能并行发送数据块，

1792
00:55:55,020 --> 00:55:56,340
0,300 300,480 480,720 720,1110 1110,1320
sent the data blocks in

1793
00:55:56,340 --> 00:55:57,960
0,600 600,990 990,1350
parallel| to {
|作为第 2 步的一部分，

1794
00:55:58,170 --> 00:56:00,120
0,720 720,1200 1200,1530 1530,1740 1740,1950
- -} {as,part,of} step 2|
|

1795
00:56:00,120 --> 00:56:01,590
0,300 300,600 600,1020 1020,1230 1230,1470
and straight to {Petal -},|
并直接发送到 Petal ，|

1796
00:56:02,500 --> 00:56:03,920
0,390 390,660 660,1110
{to,the,file} system area.|
到文件系统[区域]。|

1797
00:56:13,770 --> 00:56:14,640
0,570
Okay?|
好的?|

1798
00:56:15,620 --> 00:56:17,480
0,630 930,1140 1140,1350 1350,1800 1800,1860
So I I had a
所以我有个问题，

1799
00:56:17,480 --> 00:56:19,460
0,510 540,720 720,1050 1080,1620
question,| I think, {}
|我不记得日志有多大了，

1800
00:56:19,910 --> 00:56:21,290
0,120 120,210 210,570 570,1110 1110,1380
I don't remember exactly how

1801
00:56:21,290 --> 00:56:22,640
0,270 270,420 420,810 810,1200 1200,1350
big the log was,| but
|但我相信它可以跨越两个块。

1802
00:56:22,640 --> 00:56:24,680
0,90 90,600 630,870 1080,1590 1590,2040
I believe it could span

1803
00:56:24,680 --> 00:56:26,100
0,210 210,390 390,1110
like two blocks.|
|

1804
00:56:26,810 --> 00:56:32,090
0,1170 1170,1680 1680,2100 2100,2640 4260,5280
{It,can,log} is multiple records, yeah.|
日志可以是多条记录，是的。|

1805
00:56:32,480 --> 00:56:34,760
0,720 720,960 960,1290 1590,2160 2160,2280
Yeah, that's right, up to
是的，没错，最高可达 TB ，

1806
00:56:34,760 --> 00:56:36,350
0,180 180,630 630,780 780,1200 1200,1590
to terabytes,| so what happens
|那么，如果我们发送，

1807
00:56:36,350 --> 00:56:37,380
0,150 150,420 420,780
if we, {}

1808
00:56:38,060 --> 00:56:39,400
0,150 150,300 300,900
if we send,|
|

1809
00:56:39,940 --> 00:56:42,280
0,720 990,1200 1200,1560 1560,2070 2070,2340
like a log like part
比如发送部分日志，

1810
00:56:42,280 --> 00:56:43,030
0,90 90,150 150,480 480,600 600,750
of a log| and then
|然后它崩溃，

1811
00:56:43,030 --> 00:56:44,740
0,90 90,720 720,1200 1200,1320 1320,1710
it crashes,| as you're sending
|当你发送日志时，

1812
00:56:44,740 --> 00:56:46,180
0,390 390,900 900,1020 1020,1260 1260,1440
log,| when we get like
|我们得到问题。

1813
00:56:46,180 --> 00:56:47,710
0,270 450,690 690,1020 1020,1200 1200,1530
{} an issue with like.|
|

1814
00:56:48,460 --> 00:56:51,730
0,150 150,300 300,360 360,930 960,3270
That's exactly what {I,want,to} {talk,about},
这正是我想说的，谢谢。

1815
00:56:51,790 --> 00:56:54,280
0,390 390,600 870,1500 1740,2190 2250,2490
thank you.| {} So there's
|所以可能会发生多种崩溃，

1816
00:56:54,280 --> 00:56:55,060
0,60 60,240 240,300 300,660 660,780
a bunch of crashes that

1817
00:56:55,060 --> 00:56:56,500
0,120 120,450 450,780 780,990 990,1440
could happen right,| like so
|如果我们崩溃了，

1818
00:56:56,740 --> 00:56:58,000
0,630 630,990
{} so,

1819
00:56:58,580 --> 00:56:59,870
0,150 150,240 240,570 570,960 960,1290
if we crash,| {} consider
|考虑多种情况，

1820
00:56:59,870 --> 00:57:00,650
0,30 30,210 210,270 270,600 600,780
a bunch of cases,| like
|比如崩溃发生在写入日志之前。

1821
00:57:00,650 --> 00:57:01,970
0,90 90,270 270,360 360,690 690,1320
we write, a crash before

1822
00:57:01,970 --> 00:57:03,200
0,300 300,390 390,510 510,930
writing to the log.|
|

1823
00:57:10,440 --> 00:57:11,340
0,60

1824
00:57:11,530 --> 00:57:12,940
0,210 210,450 450,570 570,720 720,1410
So what, in that case,
那么，在这种情况下，结果会是什么？

1825
00:57:13,120 --> 00:57:14,420
0,300 300,450 450,990
what's the outcome?|
|

1826
00:57:18,910 --> 00:57:22,150
0,630 1020,1800 1800,2310 2340,2610 2610,3240
Hmm, it's lost.| Yeah, lost.|
嗯，丢失了。|是的，丢失了。|

1827
00:57:25,060 --> 00:57:27,490
0,540 540,1140 1530,2070 2070,2160 2160,2430
So, {} then we go
然后我们来看这个场景，

1828
00:57:27,490 --> 00:57:29,110
0,120 120,180 180,840 840,1140 1140,1620
the {} scenario,| like we
|比如崩溃发生在写入日志之后，

1829
00:57:29,140 --> 00:57:30,760
0,420 420,840 840,1140 1140,1230 1230,1620
crash after writing the log,|
|

1830
00:57:39,550 --> 00:57:40,700
0,210 210,420 420,840
what happens then?|
然后会发生什么？|

1831
00:57:42,180 --> 00:57:43,950
0,120 120,390 390,720 720,1200 1200,1770
It's actually {a,slightly} complicated scenario.|
这是一个稍微复杂的场景。|

1832
00:57:44,620 --> 00:57:46,420
0,330 330,630 630,930 930,1320 1320,1800
{} Is this after writing
这是在写入日志到 Petal 之后吗？

1833
00:57:46,420 --> 00:57:47,650
0,180 180,300 300,600 600,900 900,1230
like the log to {}

1834
00:57:47,680 --> 00:57:49,800
0,600
Petal?|
|

1835
00:57:50,500 --> 00:57:52,450
0,300 300,420 420,960 1080,1500 1500,1950
Then the demon steps then.|
然后 demon 会出来。|

1836
00:57:52,540 --> 00:57:53,650
0,270 270,480 480,540 540,810 810,1110
Yes, then the demon steps,|
是的，然后是 demon 步骤，|

1837
00:57:53,650 --> 00:57:54,460
0,360 360,450 450,600 600,720 720,810
it's a little bit of
这是一个有点复杂的故事，

1838
00:57:54,460 --> 00:57:56,260
0,60 60,510 510,870 900,1260 1260,1800
a complicated story, correct,| because
|因为这些是如何恢复的，

1839
00:57:56,620 --> 00:57:58,510
0,150 150,330 330,1260 1290,1740 1740,1890
you know how, how does

1840
00:57:58,510 --> 00:57:59,830
0,150 150,240 240,840 840,1050 1050,1320
this all recover,| what actually
|发生了什么。

1841
00:57:59,830 --> 00:58:00,540
0,540
happens.|
|

1842
00:58:01,480 --> 00:58:02,500
0,150 150,510 510,660 660,930 930,1020
So presumably what happens if
所以，假设其他人希望获得这个文件上的锁，

1843
00:58:02,500 --> 00:58:03,760
0,270 270,600 600,840 840,930 930,1260
somebody else wants the lock

1844
00:58:03,760 --> 00:58:04,870
0,150 150,270 270,570 570,1050 1050,1110
{ - -} correct on

1845
00:58:04,870 --> 00:58:06,370
0,120 120,720 750,1140 1140,1260 1260,1500
this file,| that you know
|崩溃的工作站所持有的，

1846
00:58:06,370 --> 00:58:08,560
0,420 420,630 660,1080 1080,1560 1560,2190
that the crashed workstation holds,|
|

1847
00:58:10,050 --> 00:58:11,100
0,420 420,540 540,600 600,870 870,1050
and you know here's where
在这里租期很重要，

1848
00:58:11,100 --> 00:58:13,770
0,360 360,630 630,1170 1170,1770 2190,2670
leases come important,| so every
|所以每把锁都有租期，

1849
00:58:13,770 --> 00:58:15,200
0,330 330,510 510,630 630,1170
lock has a lease,|
|

1850
00:58:15,400 --> 00:58:16,690
0,390 390,570 570,660 660,1050 1050,1290
and what the {lock,server} will
锁服务器将执行的操作，

1851
00:58:16,690 --> 00:58:18,520
0,510 660,1230 1230,1410 1410,1560 1560,1830
do,| {} it will not
|它不会授权，

1852
00:58:18,520 --> 00:58:20,800
0,600 630,990 1320,1740 1740,2100 2100,2280
grant,| {you,know} the {lock,server} will
|锁服务器访问工作站 1 ，

1853
00:58:20,800 --> 00:58:22,240
0,420 420,540 540,990 990,1230 1230,1440
ask {} workstation 1,| please
|请把锁 f 还给我，

1854
00:58:22,240 --> 00:58:24,220
0,180 180,690 690,1410 1440,1710 1710,1980
give me {} lock f

1855
00:58:24,220 --> 00:58:26,200
0,450 780,1230 1230,1380 1380,1890 1890,1980
back,| {workstation -} 1, it
|工作站 1 没有反应，因为它崩溃了，

1856
00:58:26,200 --> 00:58:27,760
0,180 180,600 600,840 840,930 930,1560
doesn't respond, because it's crashed,|
|

1857
00:58:28,090 --> 00:58:31,210
0,810 810,1140 1140,1470 1470,2100 2280,3120
and {} what the {lock,server}
锁服务器所做的，

1858
00:58:31,210 --> 00:58:32,470
0,450 480,690 690,930 930,1140 1140,1260
does,| it waits until the
|它会等到锁的租期过期。

1859
00:58:32,470 --> 00:58:33,850
0,240 240,810 810,930 930,990 990,1380
lease expires on the lock.|
|

1860
00:58:36,800 --> 00:58:37,910
0,270 270,600 600,750 750,840 840,1110
And why does it wait
为什么要等到锁租约到期？

1861
00:58:37,910 --> 00:58:39,170
0,210 210,270 270,660 660,960 960,1260
until the lock, the {lease,is}

1862
00:58:39,170 --> 00:58:40,160
0,660
expired?|
|

1863
00:58:44,180 --> 00:58:45,140
0,150 150,330 330,690 690,810 810,960
I I think I think
我想在这种情况下，

1864
00:58:45,140 --> 00:58:46,970
0,120 120,360 360,810 810,1200 1350,1830
in this case,| the {}
|服务器，

1865
00:58:47,730 --> 00:58:49,640
0,960 1080,1590
the {}

1866
00:58:50,060 --> 00:58:52,340
0,960 1470,1980
server {},|
|

1867
00:58:52,570 --> 00:58:53,950
0,210 210,270 270,570 570,690 690,1380
yeah, the server that crashed
是的，崩溃的服务器也知道，

1868
00:58:53,980 --> 00:58:55,480
0,270 270,570 570,1200
like also knows,|
|

1869
00:58:55,740 --> 00:58:57,600
0,480 510,690 690,1020 1020,1260 1500,1860
{} it didn't like renew
它不能续签租约，

1870
00:58:57,600 --> 00:58:58,590
0,210 210,510 510,690 690,810 810,990
its lease,| so it can
|这样它就可以自己清理。

1871
00:58:58,590 --> 00:59:00,090
0,240 240,450 450,570 570,1170 1170,1500
clean up by its own.|
|

1872
00:59:00,570 --> 00:59:03,690
0,300 300,660 660,2310 2310,2820 2820,3120
Yeah, {clean,up} {its,own,stuff},| {what's,the,fundamental} problem
是的，清理自己的东西，|这里的根本问题是什么，

1873
00:59:03,690 --> 00:59:04,590
0,180 180,330 330,450 450,690 690,900
here,| that we're actually trying
|我们试着挑战的，

1874
00:59:04,590 --> 00:59:05,820
0,60 60,390 390,630 630,780 780,1230
to challenge,| almost like the
|就像之前的场景，

1875
00:59:05,820 --> 00:59:07,440
0,630 630,810 810,990 990,1200 1200,1620
scenario,| that we've seen over
|我们在之前的课程中反复看到的，

1876
00:59:07,440 --> 00:59:08,790
0,120 120,450 450,540 540,990 990,1350
and over in previous lecture,|
|

1877
00:59:08,790 --> 00:59:10,290
0,240 240,510 510,840 840,900 900,1500
{} there's always a challenge.|
这里挑战总是存在的。|

1878
00:59:11,070 --> 00:59:13,590
0,480 480,1170 1320,1530 1530,2010 2010,2520
The partition.| {} Partition, exactly,|
分区。|分区，没错，|

1879
00:59:15,060 --> 00:59:17,280
0,450 450,540 540,600 600,1260 1680,2220
could be the case,| that
可能是这种情况，|实际上工作站 1 并没有崩溃，

1880
00:59:17,280 --> 00:59:18,930
0,150 150,600 660,1080 1080,1530 1530,1650
you know actually workstation 1

1881
00:59:18,930 --> 00:59:20,670
0,150 150,390 390,990 1350,1650 1650,1740
did not crash,| but the
|但锁服务器无法与工作站通信，

1882
00:59:20,670 --> 00:59:23,100
0,510 510,810 810,1500 1500,1740 1740,2430
{lock,server} can't talk to the

1883
00:59:23,220 --> 00:59:24,600
0,750 750,960 960,1020 1020,1080 1080,1380
workstation,| because of the network
|由于网络分区，

1884
00:59:24,600 --> 00:59:25,860
0,450 660,840 840,930 930,1170 1170,1260
partition,| but the log, {}
|但是工作站可以与 Petal 通信，

1885
00:59:25,860 --> 00:59:26,490
0,90 90,360 360,480 480,540 540,630
the {workstation -} {} can

1886
00:59:26,490 --> 00:59:27,440
0,210 210,300 300,750
talk to Petal,|
|

1887
00:59:28,100 --> 00:59:29,120
0,240 240,360 360,510 510,810 810,1020
and so it might still
所以它可能仍然在做出改变，

1888
00:59:29,120 --> 00:59:31,880
0,720 720,1140 1140,1680 1710,2160 2340,2760
may make changes, right,| but
|但正如你刚才所说，无论我们保证什么，

1889
00:59:31,880 --> 00:59:33,140
0,330 330,420 420,960 960,1080 1080,1260
whatever we guaranteed, as you

1890
00:59:33,140 --> 00:59:34,280
0,180 180,450 450,810 810,1080 1080,1140
just pointed out,| once the
|一旦租约到期，

1891
00:59:34,280 --> 00:59:36,440
0,210 210,780 780,1200 1200,1560 1560,2160
lease expires,| {workstation,1} will definitely
|工作站 1 肯定不会做任何更改。

1892
00:59:36,440 --> 00:59:37,840
0,240 240,420 420,600 600,1230
not make any changes.|
|

1893
00:59:38,830 --> 00:59:39,880
0,360 360,450 450,540 540,750 750,1050
Okay, it is not allowed
好的，这是不允许的，

1894
00:59:39,880 --> 00:59:41,290
0,120 360,660 660,750 750,1320 1320,1410
to,| follow the protocol,| is
|根据协议，|不允许再做任何更改。

1895
00:59:41,290 --> 00:59:42,070
0,180 180,390 390,450 450,600 600,780
not allowed to make any

1896
00:59:42,070 --> 00:59:43,100
0,300 300,720
changes anymore.|
|

1897
00:59:44,340 --> 00:59:45,750
0,240 240,360 360,540 540,750 750,1410
And so this is {}
所以，这就是为什么锁服务器要等到租约到期，

1898
00:59:45,750 --> 00:59:47,490
0,210 210,300 300,690 690,1200 1200,1740
why the {lock,server} waits until

1899
00:59:47,490 --> 00:59:48,660
0,90 90,300 300,930 930,1110 1110,1170
the lease expires,| then at
|然后在这一点上，知道没有人再持有锁，

1900
00:59:48,660 --> 00:59:49,500
0,180 180,450 450,540 540,750 750,840
that point and knows for

1901
00:59:49,500 --> 00:59:51,030
0,450 450,630 630,1080 1080,1470 1470,1530
sure that nobody holds a

1902
00:59:51,030 --> 00:59:52,860
0,240 240,840 1170,1380 1380,1650 1650,1830
lock anymore| or couldn't hold
|或者不持有锁，如果没有人写入 Petal ，

1903
00:59:52,860 --> 00:59:53,970
0,60 60,300 300,390 390,750 750,1110
the lock if nobody's writing

1904
00:59:53,970 --> 00:59:55,380
0,90 90,360 360,990 1170,1290 1290,1410
to Petal anymore,| and so
|所以，在这一点上，它将要求剩余的工作站，

1905
00:59:55,380 --> 00:59:56,700
0,60 60,210 210,630 630,930 930,1320
at this point, it will

1906
00:59:56,700 --> 00:59:58,260
0,390 390,570 570,720 720,990 1020,1560
ask one of the remaining

1907
00:59:58,260 --> 01:00:00,690
0,690 690,1140 1350,1920 1920,2280 2280,2430
workstations to,| {} basically what
|他们所说的恢复 demon ，

1908
01:00:00,690 --> 01:00:02,440
0,120 120,390 390,930 930,1530
they call the demon,

1909
01:00:06,020 --> 01:00:09,830
0,630 630,1110 1920,2910 2910,3300 3300,3810
recovery demon, the recovery demon,|
|

1910
01:00:10,720 --> 01:00:12,250
0,150 150,210 210,600 600,870 870,1530
and the recovery demon basically
恢复 demon 将应用，

1911
01:00:12,340 --> 01:00:14,680
0,300 300,1110 1140,1710 1710,1920 1920,2340
will apply,| {} will read
|将读取工作站 1 的日志，

1912
01:00:14,680 --> 01:00:16,210
0,300 300,420 420,870 870,990 990,1530
the the log the workstation

1913
01:00:16,210 --> 01:00:18,520
0,480 930,1260 1260,1710 1740,1950 1950,2310
1 its log| and basically
|并应用那个日志中的操作。

1914
01:00:18,520 --> 01:00:19,810
0,300 300,390 390,960 960,1110 1110,1290
apply the operations that are

1915
01:00:19,810 --> 01:00:20,700
0,60 60,240 240,660
in that log.|
|

1916
01:00:22,200 --> 01:00:23,080
0,600
Okay?|
好的?|

1917
01:00:25,110 --> 01:00:27,090
0,420 420,600 600,750 750,1050 1320,1980
{} You know the way
考虑 demon 的方式，

1918
01:00:27,090 --> 01:00:28,080
0,90 90,210 210,390 390,480 480,990
to think about the demon,|
|

1919
01:00:28,230 --> 01:00:29,460
0,450 450,660 660,990 990,1050 1050,1230
{} it's sort of like,
这是术语，

1920
01:00:29,460 --> 01:00:31,680
0,450 480,690 690,900 930,1830 1830,2220
{} this is terminology,| it's
|它通常只是一项服务或服务器或服务器进程，

1921
01:00:31,680 --> 01:00:33,240
0,360 360,570 570,600 600,1290 1320,1560
typically just a service or

1922
01:00:33,240 --> 01:00:35,070
0,30 30,780 930,1290 1290,1470 1470,1830
a server {} or server

1923
01:00:35,070 --> 01:00:36,900
0,750 840,1140 1140,1320 1320,1650 1650,1830
process,| {} that basically does
|做的是打扫房子或打扫房子的任务，

1924
01:00:36,900 --> 01:00:39,240
0,180 180,300 300,1320 1320,1440 1440,2340
sort of {house,cleaning} or house

1925
01:00:39,270 --> 01:00:41,130
0,420 420,1020 1020,1230 1230,1710 1710,1860
cleaning tasks,| and those kind
|不是真正持续使用的服务，

1926
01:00:41,130 --> 01:00:42,420
0,60 60,570 570,720 720,930 930,1290
of services that are not

1927
01:00:42,420 --> 01:00:45,030
0,210 210,630 630,960 1050,1980 2190,2610
really used {} continuously,| they're
|它们通常被称为 demon ，

1928
01:00:45,030 --> 01:00:46,140
0,390 390,1020
{often,called} demons,|
|

1929
01:00:48,950 --> 01:00:49,850
0,210 210,450 450,510 510,780 780,900
so once the demon is
所以一旦 demon 完成了，

1930
01:00:49,850 --> 01:00:51,530
0,390 420,720 720,1050 1050,1560 1590,1680
done,| then actually {the,lock} you
|然后锁可以，

1931
01:00:51,530 --> 01:00:53,090
0,120 120,300 300,870 1050,1350 1350,1560
know can be,| lock server
|锁服务器可以重新分配锁，

1932
01:00:53,090 --> 01:00:55,070
0,210 210,780 780,1560 1560,1770 1770,1980
can reassign {the,lock},| or grant
|或将锁授权给另一个工作站。

1933
01:00:55,070 --> 01:00:56,210
0,90 90,360 360,810 810,900 900,1140
the {lock,to} somebody to another

1934
01:00:56,210 --> 01:00:57,100
0,570
workstation.|
|

1935
01:00:58,820 --> 01:00:59,540
0,150 150,330 330,450 450,540 540,720
{} But just to double
为了再确认一下，

1936
01:00:59,540 --> 01:01:01,400
0,210 210,540 540,540 1080,1410 1710,1860
check,| so, { -} if
|如果你在写入日志后崩溃，

1937
01:01:01,400 --> 01:01:02,720
0,120 120,330 330,750 870,1230 1230,1320
you crash after writing the

1938
01:01:02,720 --> 01:01:03,860
0,270 270,390 390,540 540,750 750,1140
log,| then you'll get you're
|你会得到一个一致的状态，

1939
01:01:03,860 --> 01:01:04,700
0,120 120,180 180,330 330,390 390,840
going to have a consistent

1940
01:01:04,700 --> 01:01:05,540
0,240 240,330 330,420 420,630 630,840
state,| when it comes to
|当涉及元数据时，

1941
01:01:05,600 --> 01:01:06,920
0,180 180,630 630,840 870,1050 1050,1320
the metadata,| but the user
|但不能保证用户已经完成了用户数据的写入。

1942
01:01:06,920 --> 01:01:07,790
0,120 120,300 300,630 630,720 720,870
is not guaranteed to have

1943
01:01:07,790 --> 01:01:09,230
0,360 420,840 840,930 930,1200 1200,1440
finished writing the user data.|
|

1944
01:01:09,860 --> 01:01:11,900
0,1200 1200,1560 1560,1740 1740,1830 1830,2040
{Yeah\,,absolutely\,,no} guarantees about the user
是的，不能保证用户数据。

1945
01:01:11,900 --> 01:01:12,440
0,300
data.|
|

1946
01:01:13,060 --> 01:01:14,620
0,210 210,420 420,750 750,960 960,1560
So the only thing the
所以唯一保证的是，

1947
01:01:14,620 --> 01:01:16,330
0,120 120,750 750,960 960,1380 1380,1710
the guarantees,| that like really
|真正的日志系统帮助实现的是，

1948
01:01:16,330 --> 01:01:18,820
0,120 120,480 480,1380 1560,2010 2010,2490
the logging system helps achieving

1949
01:01:18,820 --> 01:01:20,200
0,180 180,510 510,1110 1110,1290 1290,1380
is| basically consistency of the
|内部文件系统数据结构一致。

1950
01:01:20,200 --> 01:01:22,300
0,630 630,930 930,1200 1200,1500 1500,2100
internal file system data structures.|
|

1951
01:01:23,830 --> 01:01:25,220
0,420 600,870 870,1080
Okay, sounds good.|
好的，听起来不错。|

1952
01:01:27,120 --> 01:01:28,350
0,270 270,330 330,720 720,1020 1020,1230
Which is important, correct,| because
这是重要的，|因为这将是相当糟糕的，

1953
01:01:28,350 --> 01:01:29,430
0,90 90,210 210,330 330,540 540,1080
it would be pretty bad,|
|

1954
01:01:29,460 --> 01:01:30,660
0,270 270,600 600,780 780,1020 1020,1200
{if,file} internal file system data
如果内部文件系统数据结构混乱，

1955
01:01:30,660 --> 01:01:31,940
0,360 360,420 420,690 690,990
structures are messed up,|
|

1956
01:01:32,110 --> 01:01:33,250
0,150 150,450 450,810 810,960 960,1140
you know, everybody might lose
每个人都可能会丢失他们的数据。

1957
01:01:33,250 --> 01:01:34,140
0,120 120,480
their data.|
|

1958
01:01:37,420 --> 01:01:39,520
0,330 330,840 870,1560 1590,1800 1800,2100
Okay, so then there's another
好的，还有另一个[]案例，

1959
01:01:39,520 --> 01:01:40,580
0,300 300,840
[] case,|
|

1960
01:01:40,900 --> 01:01:43,330
0,900 1350,1740 1740,1830 1830,2190 2190,2430
{} what can happen,| okay,
会发生什么，|好的，把日志写到 P ，

1961
01:01:43,330 --> 01:01:44,860
0,360 360,750 750,1020 1020,1080 1080,1530
so writing {the,log} to P,|
|

1962
01:01:44,890 --> 01:01:46,240
0,360 360,750 750,1110 1110,1230 1230,1350
{} what happens if we
如果我们在写入日志的过程中崩溃，会发生什么？

1963
01:01:46,240 --> 01:01:48,060
0,510 510,1170
crash during

1964
01:01:51,110 --> 01:01:52,740
0,420 420,540 540,960
writing the log?|
|

1965
01:02:05,250 --> 01:02:06,780
0,240 240,450 450,690 690,870 870,1530
Is this what you mentioned
这是不是你之前提到的它们的校验和，

1966
01:02:06,780 --> 01:02:08,760
0,450 450,780 780,1320 1320,1650 1650,1980
before that their {checksums -}|
|

1967
01:02:08,760 --> 01:02:09,750
0,150 150,270 270,450 450,690 690,990
and we can check whether
我们可以检查它是不是完整的。

1968
01:02:09,750 --> 01:02:10,770
0,120 120,360 360,480 480,930 930,1020
it was a complete or

1969
01:02:10,770 --> 01:02:15,270
0,420 480,2220 2250,2970 2970,3330 3360,4500
not.| Yeah, good point,| so
|是的，说得好，|所以在这种情况下会发生什么，

1970
01:02:15,420 --> 01:02:16,620
0,300 300,570 570,660 660,810 810,1200
what happens in this case,|
|

1971
01:02:16,620 --> 01:02:18,090
0,360 360,540 540,630 630,1200 1200,1470
{} that a prefix might
前缀可能会，

1972
01:02:18,120 --> 01:02:19,760
0,180 180,480 510,750 750,1050
end up in the,|
|

1973
01:02:20,850 --> 01:02:21,990
0,120 120,570 570,780 780,930 930,1140
the prefix might end {up,in}
前缀可能会在日志中，

1974
01:02:21,990 --> 01:02:23,120
0,90 90,480 480,720
the log, right,|
|

1975
01:02:24,500 --> 01:02:26,480
0,540 900,1260 1260,1410 1410,1560 1560,1980
{} but each of the
但是每个前缀可能包含多个日志记录，

1976
01:02:26,870 --> 01:02:29,480
0,600 600,780 780,1140 1140,1890 1890,2610
prefix might contain multiple {}

1977
01:02:29,540 --> 01:02:31,550
0,690 690,960 960,1080 1080,1410 1410,2010
log records| with multiple operations,
|包含多个操作，

1978
01:02:31,550 --> 01:02:32,870
0,420 420,510 510,660 660,990 990,1320
correct,| you know whatever sequence
|无论是序号 1 ，序号 2 ，多个记录，

1979
01:02:32,870 --> 01:02:34,280
0,210 210,600 600,780 780,990 990,1410
number 1, sequence number 2,

1980
01:02:34,280 --> 01:02:37,370
0,270 300,1080 1080,1620 2160,2790 2940,3090
the multiple records,| {} if
|如果我们在其中一个记录更新期间崩溃，

1981
01:02:37,370 --> 01:02:38,720
0,210 210,630 630,930 930,1260 1260,1350
we crash during one of

1982
01:02:38,720 --> 01:02:40,280
0,420 420,780 780,1350 1350,1440 1440,1560
these records updates,| you know
|然后校验和就不会通过，

1983
01:02:40,280 --> 01:02:42,050
0,480 480,480 480,1200 1200,1530 1530,1770
then {} the checksum won't

1984
01:02:42,050 --> 01:02:43,460
0,450 450,630 630,870 870,1020 1020,1410
checkout,| and so will basically
|所以恢复 demon 会停止在那个记录。

1985
01:02:43,460 --> 01:02:45,110
0,480 510,600 600,1200 1200,1440 1440,1650
stop you know the the

1986
01:02:45,110 --> 01:02:46,220
0,330 330,600 600,690 690,1050 1050,1110
recovery demon will stop at

1987
01:02:46,220 --> 01:02:46,980
0,210 210,570
that record.|
|

1988
01:02:47,190 --> 01:02:48,420
0,210 210,450 450,660 660,930 930,1230
So what will be in
那么日志中会有什么，

1989
01:02:48,420 --> 01:02:49,740
0,120 120,480 480,630 630,930 930,1320
the log,| will be {
|将是操作的正确前缀，

1990
01:02:49,980 --> 01:02:51,990
0,390 390,780 780,1290 1290,1830 1860,2010
- -} correct prefix of

1991
01:02:51,990 --> 01:02:54,060
0,120 120,900 1080,1350 1350,1410 1410,2070
the operations,| so for example
|例如，创建文件 f 在这里，

1992
01:02:54,060 --> 01:02:55,320
0,60 60,240 240,480 480,1140 1140,1260
you know the create of

1993
01:02:55,320 --> 01:02:57,180
0,720 720,990 990,1200 1200,1320 1320,1860
file f is in there,|
|

1994
01:02:57,210 --> 01:02:58,650
0,270 270,360 360,660 660,1140 1140,1440
maybe to create file {g,is}
也许创建文件 g 在那里，

1995
01:02:58,650 --> 01:03:00,210
0,180 180,660 690,990 990,1080 1080,1560
in there,| but the create
|但是创建文件 h 不在那里，

1996
01:03:00,210 --> 01:03:01,560
0,510 540,870 870,1020 1020,1260 1260,1350
file h is not in

1997
01:03:01,560 --> 01:03:02,040
0,270
there,|
|

1998
01:03:02,190 --> 01:03:03,900
0,270 270,480 480,600 600,1290 1290,1710
{} but each individual record
但是每个单独记录描述一个原子文件系统操作，

1999
01:03:03,930 --> 01:03:05,490
0,210 210,630 630,900 900,1440 1470,1560
that describes one atomic you

2000
01:03:05,490 --> 01:03:07,200
0,150 150,360 360,600 600,1350 1560,1710
know file system operation,| you
|就在那里，而且是完整的。

2001
01:03:07,200 --> 01:03:08,400
0,90 90,630 630,750 750,1080 1080,1200
know is in there and

2002
01:03:08,400 --> 01:03:09,240
0,90 90,570
is complete.|
|

2003
01:03:09,910 --> 01:03:11,350
0,210 210,570 660,960 960,1110 1110,1440
And so what will happen
所以接下来会发生的是，

2004
01:03:11,350 --> 01:03:12,460
0,120 120,240 240,660 660,810 810,1110
is,| that basically we apply
|我们应用在工作站上执行的操作前缀，

2005
01:03:12,460 --> 01:03:14,800
0,60 60,750 780,1080 1080,1710 1740,2340
the prefix of the operations

2006
01:03:14,800 --> 01:03:16,570
0,90 90,180 180,720 720,1080 1080,1770
at the workstation is {}

2007
01:03:16,600 --> 01:03:18,340
0,540 660,840 840,930 930,1290 1290,1740
doing,| and we basically lose
|我们丢掉前缀的结尾，

2008
01:03:18,340 --> 01:03:19,510
0,180 180,330 330,450 450,570 570,1170
the end of the prefix,|
|

2009
01:03:19,870 --> 01:03:20,800
0,180 180,300 300,420 420,570 570,930
or the end of {}
或更新的结尾，

2010
01:03:20,800 --> 01:03:22,960
0,150 150,540 540,750 750,1140 1440,2160
its updates,| but {you,know} undesirable,
|不是我们期望的，但完全没问题，

2011
01:03:22,960 --> 01:03:24,460
0,180 180,360 360,690 690,1050 1050,1500
but {you,know} totally okay,| because,
|因为，在另一个案例中，

2012
01:03:24,950 --> 01:03:26,150
0,420 450,840 840,930 930,1020 1020,1200
you know in the other

2013
01:03:26,150 --> 01:03:27,200
0,240 240,360 360,510 510,630 630,1050
case,| we might have lost
|我们可能失去所有的更新，

2014
01:03:27,200 --> 01:03:28,480
0,180 180,480 480,600 600,1050
{} all {updates -},|
|

2015
01:03:31,210 --> 01:03:32,350
0,300 300,420 420,510 510,750 750,1140
but in the first case,|
但在第一种情况下，|

2016
01:03:32,920 --> 01:03:33,820
0,270 270,450 450,570 570,630 630,900
{} we were {} crashed
我们在日志之前崩溃，

2017
01:03:33,820 --> 01:03:34,690
0,300 300,360 360,630 630,720 720,870
before the log,| we would
|我们将一无所有。

2018
01:03:34,690 --> 01:03:35,860
0,150 150,450 450,570 570,930
have nothing on this.|
|

2019
01:03:40,660 --> 01:03:42,180
0,120 120,300 300,420 420,750
Does that make sense?|
这能理解吗？|

2020
01:03:46,760 --> 01:03:49,640
0,390 390,720 720,1260 1440,2220 2550,2880
Okay, there's one, {} one
好的，一个棘手的情况，

2021
01:03:49,640 --> 01:03:51,950
0,150 150,450 450,1020 1050,2070 2100,2310
more tricky case,| {} you
|我们需要考虑，

2022
01:03:51,950 --> 01:03:52,880
0,90 90,180 180,330 330,390 390,930
know we need to consider,|
|

2023
01:03:53,210 --> 01:03:53,930
0,240 240,330 330,480 480,630 630,720
{} and that has to
这与一个事实有关，

2024
01:03:53,930 --> 01:03:54,860
0,120 120,330 330,390 390,720 720,930
do with the fact,| that
|Petal 在每个服务器上都有一个锁，或者在每个服务器上有一个日志。

2025
01:03:54,860 --> 01:03:56,420
0,480 480,780 780,960 960,1050 1050,1560
actually Petal has a lock

2026
01:03:56,420 --> 01:03:58,190
0,120 120,600 600,810 810,1410 1590,1770
per server or log per

2027
01:03:58,190 --> 01:03:59,160
0,510
server.|
|

2028
01:03:59,570 --> 01:04:00,380
0,180 180,420 420,600 600,630 630,810
So I talked a little
所以我稍微讨论一下，

2029
01:04:00,380 --> 01:04:01,670
0,120 120,300 300,870 960,1170 1170,1290
bit about that,| and these
|这些与你在阅读中看到的问题有关。

2030
01:04:01,670 --> 01:04:03,290
0,90 90,390 390,660 660,990 1020,1620
are related to the question

2031
01:04:03,500 --> 01:04:04,790
0,150 150,210 210,780 810,930 930,1290
you know post you know

2032
01:04:05,240 --> 01:04:06,440
0,270 270,360 360,900
for the reading.|
|

2033
01:04:06,760 --> 01:04:07,600
0,210 210,330 330,390 390,600 600,840
And this is about many
这是关于许多日志，

2034
01:04:07,600 --> 01:04:09,460
0,600 960,1410 1410,1560 1560,1710 1710,1860
logs,| and so let's say
|假设我们有工作站，

2035
01:04:09,460 --> 01:04:11,600
0,180 180,660 690,1920
we have workstations,|
|

2036
01:04:12,160 --> 01:04:13,330
0,180 180,330 330,480 480,570 570,1170
each with their own log,|
每个都有自己的日志，|

2037
01:04:13,920 --> 01:04:15,720
0,180 180,420 420,870 870,1290 1290,1800
so here's workstation 1, workstation
这是工作站 1 ，工作站 2 ，工作站 3 。

2038
01:04:15,720 --> 01:04:18,380
0,600 960,1620 1620,2130
2, workstation 3.|
|

2039
01:04:19,480 --> 01:04:21,070
0,570 570,1020 1020,1320 1320,1440 1440,1590
And workstation 1, at some
工作站 1 在某一时刻删除文件 f ，

2040
01:04:21,070 --> 01:04:23,320
0,330 330,540 540,630 630,1410 2010,2250
point, does a delete of

2041
01:04:23,320 --> 01:04:24,490
0,360 360,600 600,780 780,1080 1080,1170
file f,| that happened to
|它是之前存在的，

2042
01:04:24,490 --> 01:04:26,180
0,660 660,1320
exist before,|
|

2043
01:04:27,480 --> 01:04:30,630
0,810 810,1560 1860,2400 2400,2940 2970,3150
then {} workstation 2 does
然后工作站 2 创建 d/f ，

2044
01:04:30,630 --> 01:04:32,120
0,120 120,810
a create

2045
01:04:33,270 --> 01:04:35,880
0,300 300,840 870,1110 1110,1980 2190,2610
{d/f - - -}| and
|但是这个 create 写入自己的日志，

2046
01:04:35,880 --> 01:04:37,020
0,120 120,300 300,660 660,1050 1050,1140
but that create remember has

2047
01:04:37,020 --> 01:04:38,130
0,270 270,390 390,510 510,660 660,1110
written to his own log,|
|

2048
01:04:38,190 --> 01:04:41,160
0,960 960,1560 1860,2100 2100,2580 2580,2970
{so,this} delete is written to
所以这个 delete 写入工作站 1 的日志，

2049
01:04:41,160 --> 01:04:42,840
0,150 150,600 600,720 720,1230 1230,1680
the log of workstation 1,|
|

2050
01:04:43,020 --> 01:04:44,250
0,270 270,630 630,750 750,1050 1050,1230
this create is written to
这个 create 写入工作站 2 的日志。

2051
01:04:44,250 --> 01:04:45,840
0,90 90,540 540,750 750,1260 1260,1590
the log of workstation 2.|
|

2052
01:04:46,990 --> 01:04:48,880
0,420 420,630 630,1230
Now, let's say,
现在，假设工作站 1 崩溃了，

2053
01:04:49,420 --> 01:04:51,100
0,270 270,600 600,720 720,930 930,1680
{} {workstation -} 1 crashes

2054
01:04:52,950 --> 01:04:55,920
0,750 780,1890 2040,2280 2280,2520 2520,2970
in,| {} and then workstation
|然后工作站 3 恢复 demon 运行，

2055
01:04:55,920 --> 01:04:57,390
0,510 570,690 690,810 810,1380 1380,1470
3 you know basically you

2056
01:04:57,390 --> 01:04:59,100
0,210 210,390 390,810 810,1110 1110,1710
know the recovery demon runs,|
|

2057
01:05:07,600 --> 01:05:09,430
0,90 90,240 240,870 900,1530 1530,1830
you know for workstation 1,|
对于工作站 1 ，|

2058
01:05:14,700 --> 01:05:15,960
0,570 570,720 720,810 810,930 930,1260
and you know the bad
可能出现坏的结果，

2059
01:05:15,960 --> 01:05:17,730
0,420 420,870 870,1230 1230,1410 1410,1770
possible outcome, correctly,| that would
|这将重放 delete ，

2060
01:05:17,730 --> 01:05:19,640
0,420 420,900 900,1020 1020,1620
delete, replay the delete,|
|

2061
01:05:19,960 --> 01:05:22,210
0,180 180,390 390,1170 1260,1590 1590,2250
which would overwrite the changes,|
这将覆盖更改，|

2062
01:05:22,210 --> 01:05:24,040
0,60 60,690 690,900 900,1230 1500,1830
{} that {workstation -} 2
工作站 2 对 Petal 所做的。

2063
01:05:24,040 --> 01:05:25,020
0,270 270,690
{make,to} Petal,

2064
01:05:26,180 --> 01:05:27,470
0,180 180,270 270,510 510,600 600,1290
right.| So that's the context,|
|所以这就是背景，|

2065
01:05:28,130 --> 01:05:29,180
0,450 450,540 540,810 810,900 900,1050
and the question is how
问题是这是如何解决的，

2066
01:05:29,180 --> 01:05:30,710
0,240 240,780 810,1230 1230,1290 1290,1530
is {this,fixed},| and I think
|我认为我想解决的问题的方法是，

2067
01:05:30,710 --> 01:05:31,760
0,390 390,690 720,900 900,960 960,1050
this the way I would

2068
01:05:31,760 --> 01:05:32,630
0,150 150,210 210,510 510,720 720,870
like to address this is|
|

2069
01:05:32,630 --> 01:05:34,190
0,180 180,780 780,960 960,1350 1350,1560
by actually having you spend
让你们在分解会议室待上几分钟，

2070
01:05:34,190 --> 01:05:34,850
0,30 30,240 240,510 510,600 600,660
a couple minutes in the

2071
01:05:34,850 --> 01:05:36,620
0,390 390,840 1110,1440 1440,1620 1620,1770
breakout room,| debate this with
|互相讨论这个或任何 Petal 的方面，

2072
01:05:36,620 --> 01:05:37,640
0,120 120,480 480,660 660,810 810,1020
each other or any other

2073
01:05:37,640 --> 01:05:39,980
0,390 390,480 930,1740 1740,1890 1890,2340
aspect of Petal,| if you
|如果你想的话。

2074
01:05:40,010 --> 01:05:40,720
0,240 240,420
want to.|
|

2075
01:05:42,020 --> 01:05:43,300
0,270 270,1110
And so
所以， Lily 或任何其他助教，

2076
01:05:43,880 --> 01:05:44,800
0,480
{}

2077
01:05:45,040 --> 01:05:46,930
0,390 390,900 930,1320 1320,1680 1680,1890
Lily or anybody else, any

2078
01:05:46,930 --> 01:05:49,060
0,360 360,750 750,1020 1410,1800 1830,2130
other TAs,| so {} send
|所以把大家送到分解会议室。

2079
01:05:49,060 --> 01:05:50,020
0,180 180,240 240,300 300,570 570,960
people to {} breakout rooms.|
|

2080
01:06:02,130 --> 01:06:03,210
0,210 210,240 240,390 390,600 600,1080
Should I do it, or.|
我来做吧，还是。|

2081
01:06:03,240 --> 01:06:05,130
0,150 150,210 210,510 1110,1470 1470,1890
{Yeah\,,it'll} be great.| Okay cool,
好的，很好。|好的，酷。

2082
01:06:06,210 --> 01:06:07,400
0,690
right.|
|

2083
01:06:12,110 --> 01:06:13,880
0,690 720,1140 1140,1320 1320,1410 1410,1770
I'll close them in {about,five,minutes}.|
我会关闭大约五分钟。|

2084
01:06:13,880 --> 01:06:16,020
0,180 180,630
{Yeah\,,five} minutes.|
是的，五分钟。|

2085
01:06:16,370 --> 01:06:17,120
0,390
Cool.|
好的。|

2086
01:11:44,020 --> 01:11:45,280
0,510

2087
01:11:53,050 --> 01:11:53,940
0,660

2088
01:12:04,230 --> 01:12:05,080
0,630

2089
01:12:12,740 --> 01:12:13,580
0,510

2090
01:12:13,970 --> 01:12:14,680
0,510

2091
01:12:16,070 --> 01:12:16,760
0,60

2092
01:12:22,020 --> 01:12:23,140
0,270 270,840
Everybody back?|
大家都回来了吗？|

2093
01:12:28,360 --> 01:12:29,500
0,870

2094
01:12:32,010 --> 01:12:33,780
0,240 240,420 420,630 630,1080 1560,1770
Okay, so just, {} just
好的，所以，简单地总结一下，

2095
01:12:33,780 --> 01:12:36,900
0,420 450,1170 1170,1950 2100,2880 2880,3120
{} quickly {} summarize,| so
|我们有 3 台工作站，

2096
01:12:36,900 --> 01:12:39,030
0,90 90,210 210,390 390,1320 1620,2130
we have 3 workstations,| workstation
|工作站 1 在某个时刻删除了日志中的文件，

2097
01:12:39,030 --> 01:12:40,350
0,360 360,450 450,600 600,840 840,1320
1 at some point deleted

2098
01:12:40,350 --> 01:12:42,270
0,510 870,1410 1410,1710 1710,1830 1830,1920
the file that's in the

2099
01:12:42,270 --> 01:12:44,910
0,750 930,1650 1650,2130 2130,2460 2460,2640
log,| {} workstation 2 at
|工作站 2 在稍后创建文件 f ，

2100
01:12:44,910 --> 01:12:47,190
0,120 120,330 330,750 750,1200 1200,2280
some point later create {}

2101
01:12:47,250 --> 01:12:48,540
0,390 390,630 630,900 930,1140 1140,1290
{create,a} file f,| it is
|在他的日志里，

2102
01:12:48,540 --> 01:12:50,340
0,150 150,270 270,690 1080,1500 1500,1800
in his log,| and then
|然后 1 崩溃，

2103
01:12:50,340 --> 01:12:52,170
0,330 330,930 930,1140 1140,1590 1590,1830
1 crashes| and workstation 3
|工作站 3 运行 demon 对工作站 1 的日志，

2104
01:12:52,170 --> 01:12:53,730
0,240 240,600 600,960 960,1320 1320,1560
actually runs recovery demon on

2105
01:12:53,730 --> 01:12:54,900
0,90 90,510 510,660 660,960 960,1170
the log of {workstation -}

2106
01:12:54,900 --> 01:12:55,620
0,480
1,|
|

2107
01:12:55,840 --> 01:12:56,740
0,360 360,450 450,660 660,840 840,900
and of course, {it,would} be
当然，这将是一场灾难，

2108
01:12:56,740 --> 01:12:58,300
0,30 30,630 630,780 780,1140 1170,1560
{} disaster,| if the delete
|如果 delete 被重放，

2109
01:12:58,300 --> 01:13:00,010
0,120 120,270 270,930 1110,1650 1650,1710
would be replayed,| because {}
|因为后来的创建是在另一个工作站上进行的，

2110
01:13:00,010 --> 01:13:01,180
0,300 300,570 570,720 720,1020 1020,1170
later create has happened on

2111
01:13:01,180 --> 01:13:02,290
0,240 240,750 750,840 840,990 990,1110
another workstation,| but it's in
|它在另一个日志中，

2112
01:13:02,290 --> 01:13:04,120
0,270 270,660 690,1200 1230,1620 1620,1830
another log,| so demon doesn't
|所以 demon 不知道这个，

2113
01:13:04,120 --> 01:13:05,350
0,150 150,390 600,870 870,960 960,1230
know what,| how is this
|这个问题怎么解决，

2114
01:13:05,380 --> 01:13:06,680
0,510 510,1050
problem solved,|
|

2115
01:13:07,670 --> 01:13:09,950
0,240 240,420 420,810 1050,1710 1710,2280
or how this potential disaster
或者这场潜在的灾难怎么避免？

2116
01:13:09,950 --> 01:13:10,820
0,540
avoided?|
|

2117
01:13:14,590 --> 01:13:17,620
0,720 810,1170 1170,1500 1500,2220 2460,3030
We said version numbers.| Yeah.|
我们讨论的是版本号。|是的。|

2118
01:13:19,300 --> 01:13:20,170
0,330 330,450 450,600 600,780 780,870
Yes, you could say a
是的，如果你想的话，可以多说一点。

2119
01:13:20,170 --> 01:13:20,740
0,180 180,270 270,450 450,510 510,570
little bit more, if you

2120
01:13:20,740 --> 01:13:21,500
0,150 150,450
want to.|
|

2121
01:13:21,820 --> 01:13:24,910
0,510 540,1140 1230,1950 2010,2580 2790,3090
Sure, {} so like it's
当然，这保证了，

2122
01:13:24,910 --> 01:13:26,560
0,720 720,1200 1200,1320 1320,1530 1530,1650
guaranteed,| because we had the
|因为我们有锁，

2123
01:13:26,560 --> 01:13:29,380
0,390 390,600 600,930 1020,2550 2580,2820
lock,| that the operations have
|服务器 1 的操作已完成，

2124
01:13:29,380 --> 01:13:33,250
0,330 330,990 1020,1890 2220,2730 3420,3870
already completed for {} server

2125
01:13:33,250 --> 01:13:37,630
0,510 1680,2430 2430,3180 3360,3900 3930,4380
1,| and so the like
|日志的版本号写在 Petal 中，

2126
01:13:37,630 --> 01:13:39,370
0,390 540,1080 1080,1410 1410,1620 1620,1740
the version number for the

2127
01:13:39,370 --> 01:13:41,470
0,600 690,990 990,1590 1590,1890 1890,2100
log is written in {}

2128
01:13:41,470 --> 01:13:43,180
0,210 210,660 960,1260 1260,1350 1350,1710
the Petal,| like the last
|比如最后的操作，

2129
01:13:43,180 --> 01:13:45,580
0,570 570,720 720,1080 1110,1620 1890,2400
operation,| and so the recovery
|所以，恢复 demon 不会对当前版本号之前的执行任何操作。

2130
01:13:45,580 --> 01:13:47,830
0,270 270,510 510,660 660,1200 1410,2250
demon won't do anything previous

2131
01:13:47,860 --> 01:13:48,480
0,150 150,480
to the

2132
01:13:49,070 --> 01:13:51,500
0,270 270,600 600,870 870,1350 1710,2430
{} current version number.| Yeah,
|是的，这是绝对正确的，

2133
01:13:51,500 --> 01:13:53,450
0,210 210,870 870,1380 1380,1620 1620,1950
that's {} absolutely right,| so
|所以总结一下，

2134
01:13:53,450 --> 01:13:54,980
0,510 510,1110 1110,1290 1290,1410 1410,1530
just summarize,| so we have
|所以我们有两个日志，

2135
01:13:54,980 --> 01:13:55,880
0,600
two

2136
01:13:56,130 --> 01:13:58,050
0,420 420,750 750,1140 1140,1410 1440,1920
logs, correct,| actually {} {}
|这很重要，

2137
01:13:58,050 --> 01:13:59,520
0,660 660,1050 1050,1170 1170,1350 1350,1470
importance,| and we have some
|我们有一些文件系统状态，

2138
01:13:59,520 --> 01:14:00,860
0,240 240,540 540,1020
file system state,|
|

2139
01:14:01,250 --> 01:14:02,720
0,480 480,660 660,840 840,1050 1050,1470
that's in the Petal, right,|
它们在 Petal 中，|

2140
01:14:02,720 --> 01:14:03,620
0,150 150,330 330,420 420,510 510,900
so these are the logs,|
所以这些是日志，|

2141
01:14:03,620 --> 01:14:04,610
0,120 120,390 390,630 630,690 690,990
and then here's the actual
然后这是实际的文件系统，

2142
01:14:04,610 --> 01:14:05,620
0,270 270,660
file system,|
|

2143
01:14:07,740 --> 01:14:09,390
0,540 540,780 780,1140 1140,1530 1530,1650
and {} here was you
然后这是目录 d ，

2144
01:14:09,390 --> 01:14:10,470
0,120 120,390 390,570 570,720 720,1080
know like this is directory

2145
01:14:10,470 --> 01:14:12,900
0,720 720,1110 1110,1290 1890,2220 2220,2430
d,| {you,know} and directory d
|目录 d 被修改，文件 f 被删除，

2146
01:14:12,900 --> 01:14:14,010
0,120 120,720 720,780 780,840 840,1110
was modified and the file

2147
01:14:14,010 --> 01:14:15,660
0,480 480,660 660,1140 1140,1380 1380,1650
f was deleted,| that has
|有一个日志编号 i ，比如 10 ，

2148
01:14:15,660 --> 01:14:17,700
0,60 60,330 330,870 870,1470 1500,2040
a log number i say

2149
01:14:17,790 --> 01:14:18,860
0,540
10,|
|

2150
01:14:19,920 --> 01:14:21,990
0,1110 1170,1290 1290,1350 1350,1440 1440,2070
and this is {} workstation
这是工作站 2 ，

2151
01:14:21,990 --> 01:14:23,670
0,690 690,1080 1080,1440 1440,1560 1560,1680
2,| and here is {}
|这是 d ，

2152
01:14:23,670 --> 01:14:24,520
0,540
d,|
|

2153
01:14:24,730 --> 01:14:27,250
0,300 300,780 780,2070 2070,2370 2370,2520
those deleting d, {f,in,d} and
这些删除 d 中的 f 或创建 d 中的 f ，

2154
01:14:27,250 --> 01:14:28,540
0,120 120,600 600,930 930,1170 1170,1290
{} creating {f,in} d,| and
|在这个条目中日志编号是什么，抱歉，版本号，

2155
01:14:28,540 --> 01:14:29,680
0,390 390,630 630,840 840,990 990,1140
what log number will be

2156
01:14:29,680 --> 01:14:32,400
0,90 90,480 480,1500 1860,2460
in this {} entry,

2157
01:14:34,420 --> 01:14:35,800
0,480 480,720 720,1110
version number, sorry.|
|

2158
01:14:37,840 --> 01:14:42,760
0,1980 3240,3960 3960,4290 4290,4740 4740,4920
11?| {11\,,yep,basically} totally ordered| and
11 ？|11 是的，基本上是完全有序的，|锁协议确保了他们完全有序。

2159
01:14:42,760 --> 01:14:44,680
0,540 540,990 990,1500 1500,1590 1590,1920
locking protocols ensured they totally

2160
01:14:44,680 --> 01:14:45,420
0,390
ordered.|
|

2161
01:14:45,620 --> 01:14:47,060
0,360 360,660 660,990 1230,1380 1380,1440
And on the, in the
在包含元数据块的文件系统中，

2162
01:14:47,060 --> 01:14:48,590
0,270 270,720 720,990 990,1080 1080,1530
file system with the metadata

2163
01:14:48,590 --> 01:14:49,940
0,480 510,750 750,840 840,1260 1260,1350
blocks,| like for example if
|例如，如果 f 的 inode 块，

2164
01:14:49,940 --> 01:14:50,720
0,90 90,210 210,420 420,690 690,780
the {inode -} block for

2165
01:14:50,720 --> 01:14:51,460
0,480
f,|
|

2166
01:14:52,290 --> 01:14:53,220
0,180 180,360 360,570 570,750 750,930
{} {inode -} f the
inode f 的版本号将在磁盘中或 Petal ？

2167
01:14:53,220 --> 01:14:54,480
0,270 270,840 900,1080 1080,1200 1200,1260
version number is going to

2168
01:14:54,480 --> 01:14:55,700
0,150 150,360 360,450 450,960
be on the disk

2169
01:14:55,890 --> 01:14:57,020
0,240 240,330 330,840
or in Petal?|
|

2170
01:15:04,490 --> 01:15:05,400
0,600
11?|
11 ？|

2171
01:15:06,000 --> 01:15:06,870
0,300 300,390 390,450 450,720 720,870
Yeah, in the case that,|
是的，在这种情况下，|

2172
01:15:06,870 --> 01:15:08,580
0,330 330,600 600,1140 1140,1290 1290,1710
actually the operation was applied
应用到文件系统的操作是 11 。

2173
01:15:08,580 --> 01:15:09,720
0,270 270,360 360,750 750,1050 1050,1140
to the {file,system} will be

2174
01:15:09,720 --> 01:15:10,960
0,510 510,810
11, correct.|
|

2175
01:15:11,540 --> 01:15:13,910
0,390 390,690 690,1260 1260,1680 1710,2370
And so when the demon
所以 demon 什么时候，

2176
01:15:14,440 --> 01:15:16,690
0,720 750,780 810,1620 1830,2100 2100,2250
we,| { -} what rule
|demon 遵守的规则是什么？

2177
01:15:16,690 --> 01:15:18,140
0,180 180,270 270,570 570,1170
does the demon follow?|
|

2178
01:15:20,520 --> 01:15:22,740
0,480 480,1290 1290,1860
Never replace {}
永远不要替换已经应用的东西。

2179
01:15:22,930 --> 01:15:24,640
0,420 420,600 600,840 840,1050 1050,1710
something that's already been applied.|
|

2180
01:15:25,180 --> 01:15:26,380
0,270 270,420 420,660 660,1050 1050,1200
Yeah, that just decided it's
是的，什么决定它是不是应用了？

2181
01:15:26,380 --> 01:15:27,220
0,480
applied?|
|

2182
01:15:28,520 --> 01:15:30,620
0,360 360,690 690,990 990,1410 1800,2100
Like a version number.| {Yeah\,,version}
版本号。|是的，版本号，

2183
01:15:30,620 --> 01:15:31,520
0,240 270,480 480,600 600,780 780,900
number, right,| so if the
|所以如果版本号，

2184
01:15:31,520 --> 01:15:33,200
0,300 300,510 510,660 660,1050 1050,1680
version number,| and only replay
|只重放条目，

2185
01:15:33,200 --> 01:15:34,670
0,90 90,600 600,900 900,1170 1170,1470
an entry,| if the version
|如果日志记录中的版本号，

2186
01:15:34,670 --> 01:15:35,900
0,300 300,420 420,540 540,870 870,1230
number in the log record,|
|

2187
01:15:37,160 --> 01:15:39,040
0,360 360,990 990,1530
log version number
日志版本号高于 inode 或元数据版本号，

2188
01:15:39,380 --> 01:15:41,000
0,450 450,1140 1140,1350 1350,1440 1440,1620
is higher than the {inode

2189
01:15:41,000 --> 01:15:43,340
0,360 360,810 810,1470 1560,1950 1950,2340
-} {or,the} metadata version number,|
|

2190
01:15:45,980 --> 01:15:47,680
0,210 210,510 510,1020
you {know,then} replay,
然后进行重放，好的？

2191
01:15:48,450 --> 01:15:49,340
0,480
okay?|
|

2192
01:15:49,970 --> 01:15:50,930
0,210 210,270 270,420 420,870 870,960
So in this case,| you
所以在这种情况下，|恢复 demon 在日志记录中看到版本号为 10 ，

2193
01:15:50,930 --> 01:15:52,460
0,330 330,600 630,1080 1080,1410 1410,1530
know the recovery demon will

2194
01:15:52,460 --> 01:15:54,470
0,210 210,1020 1200,1590 1590,1890 1890,2010
see the version number in

2195
01:15:54,470 --> 01:15:55,610
0,240 240,540 540,750 750,870 870,1140
the log record is 10,|
|

2196
01:15:55,610 --> 01:15:57,080
0,240 240,300 300,780 780,930 930,1470
which is smaller than 11
小于 11 或等于 11 ，都无关紧要，

2197
01:15:57,380 --> 01:15:59,030
0,210 210,570 570,900 900,1110 1110,1650
or equals 11, doesn't matter,|
|

2198
01:15:59,120 --> 01:16:00,050
0,180 180,300 300,360 360,570 570,930
and so it won't replay
所以它不会重放，

2199
01:16:00,050 --> 01:16:00,890
0,240 240,330 330,420 420,570 570,840
it,| and so this problem
|所以，这个问题不会出现。

2200
01:16:00,890 --> 01:16:01,780
0,270 270,630
cannot appear.|
|

2201
01:16:02,380 --> 01:16:04,060
0,270 270,450 450,570 570,900 900,1680
So does the 10 necessarily
所以 10 是不是必须的，

2202
01:16:04,060 --> 01:16:06,220
0,360 390,810 810,1590 1590,1890 1890,2160
not,| does it okay such
|是否 10 不在工作站 2 的日志中也是可以的？

2203
01:16:06,220 --> 01:16:07,480
0,180 180,390 390,630 630,1050 1080,1260
that like that 10 is

2204
01:16:07,480 --> 01:16:09,490
0,240 240,450 450,600 600,1290 1320,2010
not on the ws workspace

2205
01:16:09,490 --> 01:16:10,780
0,540 540,1020
2's log?|
|

2206
01:16:11,850 --> 01:16:14,140
0,1290 1290,1470 1470,1620 1620,1980
Yeah, it's not there.|
是的，它不在那里。|

2207
01:16:14,520 --> 01:16:15,660
0,210 210,480 480,690 690,810 810,1140
So like in the work,|
所以，就像在，|

2208
01:16:15,660 --> 01:16:16,740
0,240 240,300 300,480 480,720 720,1080
because the {workstation -} 2
因为工作站 2 在工作站 1 之后写入 inode ，

2209
01:16:16,740 --> 01:16:19,890
0,1050 1080,1590 1590,2010 2010,2880 2970,3150
{} wrote actually the {inode

2210
01:16:19,890 --> 01:16:22,410
0,270 270,870 1620,1950 1950,2310 2310,2520
-} after workstation 1,| so
|所以它的版本号为 11 ，

2211
01:16:22,410 --> 01:16:24,600
0,210 210,990 990,1350 1350,1710 1710,2190
its version number be 11,|
|

2212
01:16:24,780 --> 01:16:25,740
0,420 420,600 600,660 660,750 750,960
basically what you do to
你要做的就是准备和更新，

2213
01:16:25,740 --> 01:16:27,990
0,360 360,480 480,990 1320,1890 1920,2250
prepare and update,| the version
|更新记录中的版本号

2214
01:16:27,990 --> 01:16:29,190
0,300 300,420 420,510 510,810 810,1200
number in the update record|
|

2215
01:16:29,190 --> 01:16:30,900
0,90 90,780 810,1530
is always one
始终是一加上 inode 中的当前版本号。

2216
01:16:31,270 --> 01:16:32,680
0,690 720,840 840,930 930,1020 1020,1410
plus you know the current

2217
01:16:32,680 --> 01:16:33,520
0,270 270,510 510,600 600,720 720,840
version number in the {inode

2218
01:16:33,520 --> 01:16:34,200
0,420
-}.|
|

2219
01:16:37,960 --> 01:16:38,980
0,390 420,570 570,660 660,750 750,1020
Okay?| This is a small
好的?|这是一个小问题，

2220
01:16:38,980 --> 01:16:40,090
0,330 330,450 450,780 780,900 900,1110
question,| {} what does the
|d 代表什么？

2221
01:16:40,090 --> 01:16:43,540
0,210 210,540 540,810 810,1650 2730,3450
d stand for?| It's directory,|
|它是目录，|

2222
01:16:45,220 --> 01:16:46,270
0,480 480,600 600,900 900,990 990,1050
creating a file in the
在目录 d 中创建一个文件，

2223
01:16:46,270 --> 01:16:47,590
0,360 360,660 660,810 810,1230 1230,1320
directory d,| {} deleting a
|从目录 d 中删除一个文件，

2224
01:16:47,590 --> 01:16:48,730
0,300 300,480 480,540 540,900 900,1140
file from the directory d,|
|

2225
01:16:49,860 --> 01:16:51,420
0,300 300,390 390,780 780,960 960,1560
and the update must include
更新必须包括一些有关目录的信息。

2226
01:16:51,420 --> 01:16:52,950
0,90 90,720 720,930 930,1380 1380,1530
you know some information about

2227
01:16:52,950 --> 01:16:53,760
0,60 60,480
the directory.|
|

2228
01:16:57,440 --> 01:16:59,540
0,540 780,1260 1560,1830 1830,1950 1950,2100
Okay.| {} Sorry, I had
好的。|抱歉，我有个小问题，

2229
01:16:59,540 --> 01:17:00,980
0,60 60,210 210,690 720,1230 1260,1440
a quick question,| so are
|所以版本号总是绑定到正在编辑的 inode 上吗？

2230
01:17:00,980 --> 01:17:02,870
0,360 390,840 840,1290 1290,1500 1530,1890
the version numbers like always

2231
01:17:02,870 --> 01:17:04,100
0,390 390,540 540,630 630,1170 1170,1230
tied to the specific {inode

2232
01:17:04,100 --> 01:17:06,500
0,330 330,510 510,720 720,1260 1740,2400
-} that's being edited?| Yes.|
|是的。|

2233
01:17:07,000 --> 01:17:07,800
0,510
Okay.|
好的。|

2234
01:17:08,520 --> 01:17:10,320
0,780 780,1020 1020,1410 1410,1650 1650,1800
Absolutely, the version number for
当然，每次更新的版本号，

2235
01:17:10,320 --> 01:17:11,670
0,270 270,750 780,1050 1050,1200 1200,1350
every update, right,| like there's
|比如，目录有一个版本号，

2236
01:17:11,670 --> 01:17:12,990
0,30 30,300 300,600 600,810 810,1320
a version number for directory,|
|

2237
01:17:12,990 --> 01:17:13,800
0,150 150,180 180,450 450,690 690,810
there's a version number for
文件有一个版本号，

2238
01:17:13,800 --> 01:17:14,970
0,60 60,390 390,690 690,870 870,1170
the file,| {} like showing
|这里显示的有点问题，

2239
01:17:14,970 --> 01:17:15,930
0,90 90,240 240,360 360,690 690,960
a little bit [wrong] here,|
|

2240
01:17:16,290 --> 01:17:17,070
0,300 300,390 390,480 480,540 540,780
like if you go back
如果你回到日志记录中，

2241
01:17:17,070 --> 01:17:18,340
0,90 90,180 180,480 480,990
to the log record,|
|

2242
01:17:18,830 --> 01:17:21,410
0,870 1260,1680 1680,2100 2100,2280 2280,2580
{} here, basically there's array
在这里，有一个更新的列表，

2243
01:17:21,410 --> 01:17:23,180
0,90 90,690 690,930 930,1200 1200,1770
of updates,| and every update
|列表中的每个更新，

2244
01:17:23,240 --> 01:17:24,260
0,150 150,240 240,720 720,870 870,1020
in the array,| {completes -
|在新字节中完成版本号。

2245
01:17:24,260 --> 01:17:25,550
0,240 240,540 540,780 780,1080 1080,1290
-} block number version number

2246
01:17:25,550 --> 01:17:26,540
0,90 90,150 150,300 300,780
in the new bytes.|
|

2247
01:17:28,590 --> 01:17:29,700
0,570
Thanks.|
谢谢。|

2248
01:17:32,440 --> 01:17:34,000
0,240 240,630 630,750 750,1020 1020,1560
Okay, so just stepping back,
好的，退一步，结束这篇论文的讨论。

2249
01:17:34,210 --> 01:17:35,560
0,240 240,570 570,750 750,900 900,1350
and closing off the discussion

2250
01:17:35,560 --> 01:17:37,080
0,90 90,840
of {this,paper}.|
|

2251
01:17:38,320 --> 01:17:39,250
0,210 210,420 420,510 510,690 690,930
It's probably the first paper
这可能是我们读到的第一篇论文，

2252
01:17:39,250 --> 01:17:41,140
0,150 150,660 960,1350 1350,1500 1500,1890
that we've read,| that basically
|系统本身并不是，

2253
01:17:41,140 --> 01:17:42,310
0,60 60,300 300,360 360,660 660,1170
in order, the system itself

2254
01:17:42,310 --> 01:17:43,120
0,120 120,330 330,390 390,720 720,810
is not the one,| you
|它不是主要的用途，

2255
01:17:43,120 --> 01:17:43,810
0,150 150,300 300,450 450,630 630,690
know it's not going to

2256
01:17:43,810 --> 01:17:45,010
0,60 60,510 510,810 810,900 900,1200
be dominant use,| and therefore
|因此谈论这件事[]很有趣，

2257
01:17:45,010 --> 01:17:45,970
0,120 120,360 360,660 660,750 750,960
it's [] interesting to talk

2258
01:17:45,970 --> 01:17:48,880
0,450 660,1290 1290,2280 2310,2820 2820,2910
about,| {} but what is
|但这个系统的有趣之处在于它里面的想法，

2259
01:17:48,880 --> 01:17:50,050
0,300 300,540 540,660 660,1020 1020,1170
interesting about this system is

2260
01:17:50,050 --> 01:17:51,700
0,150 150,630 630,780 780,1050 1350,1650
the ideas in it,| and
|所以缓存连贯性协议或缓存一致性协议，

2261
01:17:51,700 --> 01:17:54,120
0,450 480,780 780,1110 1110,1860
so cache coherence protocol

2262
01:17:56,270 --> 01:17:57,940
0,300 300,570 570,1410
or cache {consistence

2263
01:17:58,180 --> 01:18:00,100
0,540 540,1260
-} protocol,|
|

2264
01:18:03,320 --> 01:18:05,020
0,240 240,720 720,1290
{} distributed locking,
分布式锁，锁服务器，租期，

2265
01:18:07,280 --> 01:18:09,860
0,510 510,1110 1170,1830 1830,2160
lock servers, {leases -},|
|

2266
01:18:11,000 --> 01:18:14,930
0,480 480,1230 1710,2670 2670,3120 3150,3930
{} granting requiring {} revoking,|
授予，请求，撤销，|

2267
01:18:15,620 --> 01:18:18,580
0,780 810,1710 1710,2280
and distributed recovery,|
以及分布式恢复，|

2268
01:18:18,980 --> 01:18:20,930
0,360 360,660 660,1140 1140,1710 1710,1950
where one workstation crashes,| but
当一个工作站崩溃时，|另一个工作站上的 demon 进行恢复，

2269
01:18:20,930 --> 01:18:23,420
0,360 360,660 660,810 810,1410 1710,2490
like demon on another workstation

2270
01:18:23,420 --> 01:18:25,730
0,270 270,480 480,540 540,1260 1800,2310
actually does the recovery,| and
|特别有趣的是，

2271
01:18:25,730 --> 01:18:27,320
0,480 480,840 840,1170 1170,1320 1320,1590
what particularly interesting is that,|
|

2272
01:18:27,470 --> 01:18:28,850
0,210 210,510 510,660 660,900 900,1380
what's interesting is the interaction
有趣的是这三个部分之间的交互，

2273
01:18:28,850 --> 01:18:30,260
0,240 240,300 300,600 600,1260
between the three pieces,|
|

2274
01:18:32,140 --> 01:18:33,980
0,240 240,450 450,1230
then they interact.|
它们交互。|

2275
01:18:35,180 --> 01:18:36,260
0,390 390,600 600,690 690,990 990,1080
And what we'll see in
我们将在接下来的几篇论文中看到，

2276
01:18:36,260 --> 01:18:37,490
0,90 90,480 480,570 570,690 690,1230
the next you know couple

2277
01:18:37,490 --> 01:18:39,200
0,150 150,690 810,1170 1170,1380 1380,1710
of papers,| {} next week
|下周，不是，在周四，

2278
01:18:39,200 --> 01:18:40,550
0,360 360,930 930,1020 1020,1110 1110,1350
particularly not on the Thursday

2279
01:18:40,550 --> 01:18:42,500
0,180 180,390 390,780 1320,1710 1710,1950
day,| but the papers after
|但在那之后的论文，

2280
01:18:42,500 --> 01:18:43,610
0,300 480,690 690,870 870,1020 1020,1110
that,| which we're going to
|我们将谈论

2281
01:18:43,610 --> 01:18:44,330
0,240 240,510 510,600 600,660 660,720
talk about| some of the
|一些繁重的、相当复杂的事务系统，

2282
01:18:44,330 --> 01:18:46,130
0,240 240,840 840,960 960,1230 1230,1800
{heavy-duty -} {} pretty involved

2283
01:18:46,130 --> 01:18:48,110
0,510 510,1050 1230,1560 1560,1770 1770,1980
transaction systems,| we'll see these
|我们也会看到这三个主题，

2284
01:18:48,110 --> 01:18:49,430
0,180 180,600 600,810 810,960 960,1320
three topics that come up

2285
01:18:49,760 --> 01:18:52,040
0,990 1020,1440 1650,1860 1860,1980 1980,2280
{} too,| and so hopefully
|所以，希望这能帮助你阅读这些论文，

2286
01:18:52,040 --> 01:18:53,330
0,120 120,270 270,510 510,870 870,1290
this will help you in

2287
01:18:53,330 --> 01:18:54,980
0,210 210,750 750,1230 1230,1500 1500,1650
reading {those,papers},| understand actually what
|了解什么是缓存一致性，

2288
01:18:54,980 --> 01:18:56,930
0,420 420,930 1290,1740 1740,1830 1830,1950
{cache,coherence} is,| what's you know
|什么是崩溃恢复，

2289
01:18:56,930 --> 01:18:59,780
0,270 270,780 780,1140 1140,1830 2070,2850
crash recovery is| and {}
|以及分布式锁。

2290
01:18:59,780 --> 01:19:01,020
0,120 120,240 240,660 660,1140
you know distributed lock.|
|

2291
01:19:02,160 --> 01:19:03,990
0,480 480,720 720,1110 1110,1410 1410,1830
{} And {the,other} probably point
另一点可能很有趣的是，

2292
01:19:03,990 --> 01:19:06,150
0,570 570,1050 1050,1110 1110,1530 1740,2160
it's interesting to make is

2293
01:19:06,150 --> 01:19:07,830
0,300 300,390 390,1140 1170,1590 1590,1680
that,| you know Petal is
|Petal 很好，

2294
01:19:07,830 --> 01:19:10,200
0,210 210,750 750,1230 1770,2250 2250,2370
really good| for useful for
|对他们设计它的特定背景很有用，

2295
01:19:10,200 --> 01:19:12,030
0,90 90,720 720,1170 1170,1470 1470,1830
the particular setting they designed

2296
01:19:12,030 --> 01:19:12,740
0,120 120,450
it for,|
|

2297
01:19:16,110 --> 01:19:18,240
0,570 570,660 660,1260 1740,2040 2040,2130
there's the performance part of
论文的性能部分，

2298
01:19:18,240 --> 01:19:19,080
0,60 60,390 390,600 600,780 780,840
the papers,| but hard to
|但很难理解，

2299
01:19:19,080 --> 01:19:20,220
0,450 450,720 720,870 870,1020 1020,1140
understand,| because it's like from
|因为这是从 1999 年开始的，

2300
01:19:20,220 --> 01:19:22,290
0,450 450,1500 1500,1740 1740,1890 1890,2070
{1999 -},| but I give
|但我看了一下图表，

2301
01:19:22,290 --> 01:19:23,280
0,30 30,210 210,270 270,360 360,990
a look at the graph,|
|

2302
01:19:23,490 --> 01:19:25,800
0,210 210,450 450,690 690,1020 1500,2310
you'll see that the file
你将看到文件系统

2303
01:19:25,800 --> 01:19:27,540
0,270 270,900 900,1170 1170,1650 1650,1740
system basically| {} workload can
|工作负载可以随着工作站数量的增加而增加，

2304
01:19:27,540 --> 01:19:28,560
0,480 480,630 630,720 720,960 960,1020
increase with the number of

2305
01:19:28,560 --> 01:19:30,540
0,780 930,1350 1350,1470 1470,1650 1650,1980
workstations,| you know that's exactly
|这正是我们努力的目标，

2306
01:19:30,540 --> 01:19:33,330
0,270 270,450 450,750 750,1200 1470,2790
what we're shooting for,| and
|他们实现了这一目标，

2307
01:19:33,570 --> 01:19:34,950
0,330 330,570 570,810 810,990 990,1380
and they achieve that goal,|
|

2308
01:19:35,550 --> 01:19:36,690
0,360 390,750 750,870 870,1020 1020,1140
{} anyway I hope you
无论如何，我希望你对这个设计感兴趣，

2309
01:19:36,690 --> 01:19:38,220
0,180 180,510 510,810 810,1320 1320,1530
find this design interesting,| sort
|不像你通常的设计，

2310
01:19:38,220 --> 01:19:39,510
0,60 60,330 330,450 450,810 810,1290
of not your usual design,|
|

2311
01:19:39,510 --> 01:19:40,500
0,180 180,510 510,600 600,900 900,990
and so I hopefully will
所以我希望会发人深省。

2312
01:19:40,500 --> 01:19:41,440
0,210 210,420 420,810
have thought provoking.|
|

2313
01:19:42,340 --> 01:19:44,350
0,630 750,1020 1020,1290 1290,1470 1470,2010
And with that I'll stop,|
说到这里，我会停下来，|

2314
01:19:44,650 --> 01:19:46,000
0,180 180,630 630,720 720,900 930,1350
of course you know stick
当然，如果你想问更多的问题，就留下来，

2315
01:19:46,000 --> 01:19:46,570
0,240 240,300 300,390 390,510 510,570
around, if you want to

2316
01:19:46,570 --> 01:19:48,610
0,210 210,330 330,930 1260,1620 1620,2040
ask more questions| and otherwise
|否则我们周四再见。

2317
01:19:48,610 --> 01:19:49,420
0,60 60,210 210,330 330,570 570,810
I'll see you Thursday day.|
|

2318
01:19:53,400 --> 01:19:54,630
0,450 510,720 720,1050 1080,1200 1200,1230
{} Can I can I
我能问你两个问题吗，

2319
01:19:54,630 --> 01:19:56,850
0,300 300,420 420,1110 1110,1410 1680,2220
ask two questions,| so, {}
|所以，我的第一个问题是，

2320
01:19:57,000 --> 01:19:58,350
0,240 240,510 510,810 810,1050 1050,1350
my first question was just|
|

2321
01:19:58,350 --> 01:20:00,660
0,210 210,930 960,1380 1410,1770 1770,2310
in general the cache coherence
一般而言，这里的缓存一致性协议，

2322
01:20:00,660 --> 01:20:02,120
0,540 540,1260
protocol here,|
|

2323
01:20:02,330 --> 01:20:04,310
0,360 360,630 630,1170 1170,1590 1590,1980
it's not have one file
它不是在两个地方有一个文件缓存，对吧？

2324
01:20:04,310 --> 01:20:05,140
0,600
cache

2325
01:20:05,900 --> 01:20:08,420
0,210 210,360 360,1260 1290,1920 2040,2520
in two places, right?| Yep.|
|是的。|

2326
01:20:08,840 --> 01:20:10,730
0,660 960,1380 1380,1530 1530,1650 1650,1890
Okay, {} and my other
好的，我的另一个问题是关于，

2327
01:20:10,730 --> 01:20:13,280
0,360 360,540 540,840 840,1320 1560,2550
question was about the,| there
|有一页有日志，

2328
01:20:13,280 --> 01:20:14,960
0,660 720,1410
was {}

2329
01:20:15,110 --> 01:20:17,270
0,270 270,930 930,1260 1260,1470 1470,2160
a page with the log,|
|

2330
01:20:17,420 --> 01:20:18,890
0,480 480,900 930,1110 1110,1350 1350,1470
{} in you have the
在那里你有日志记录。

2331
01:20:18,890 --> 01:20:22,520
0,660 690,2070 2070,2730 2910,3420 3450,3630
log records, there.| Yep, let
|是的，让我回到这里。

2332
01:20:22,520 --> 01:20:24,080
0,90 90,180 180,420 420,780 1020,1560
me go back here. {}|
|

2333
01:20:24,080 --> 01:20:26,680
0,540 570,1200 1590,2400
Yeah, I was,
是的，我很好奇，

2334
01:20:26,970 --> 01:20:28,140
0,120 120,270 270,750 750,960 960,1170
I was wondering,| you said
|你说每一个记录都是原子的，

2335
01:20:28,140 --> 01:20:29,520
0,360 390,1110
that each,

2336
01:20:30,060 --> 01:20:31,140
0,330 330,780
each like

2337
01:20:31,610 --> 01:20:34,340
0,150 150,900 930,1500 1500,2430
{} record is atomic,|
|

2338
01:20:35,170 --> 01:20:36,310
0,390 390,600 600,900 900,1080 1080,1140
but each record has a
但每条记录也有一些更新，对吧？

2339
01:20:36,310 --> 01:20:38,920
0,360 360,480 480,1440 1650,2040 2040,2610
number of updates too, right?|
|

2340
01:20:38,950 --> 01:20:41,650
0,600 630,1440 1440,2400 2400,2490 2490,2700
Yes, {} again I think
是的，再一次，我认为论文有点含糊，

2341
01:20:41,650 --> 01:20:42,760
0,120 120,360 360,660 660,930 930,1110
the paper slightly vague here,|
|

2342
01:20:42,760 --> 01:20:43,810
0,180 180,510 510,660 660,720 720,1050
what exactly what it does,|
它到底是做什么的，|

2343
01:20:43,840 --> 01:20:44,770
0,300 300,360 360,660 660,840 840,930
either it always fits in
它要么始终适合 512 个字节，

2344
01:20:44,770 --> 01:20:46,060
0,630 630,1110
512 bytes,|
|

2345
01:20:46,390 --> 01:20:47,710
0,360 360,540 540,630 630,870 870,1320
and then the single sector
然后单个扇区 512 字节是原子的，

2346
01:20:47,710 --> 01:20:50,380
0,690 690,1020 1020,1500 1500,2100 2100,2670
{512 -} bytes is {}

2347
01:20:50,380 --> 01:20:53,050
0,540 600,1170 1170,1560 1560,2340 2400,2670
atomic,| or they {} use
|或者他们使用这种校验和技巧，

2348
01:20:53,050 --> 01:20:54,400
0,210 210,660 660,1110
this checksum trick,|
|

2349
01:20:54,570 --> 01:20:56,550
0,600 810,1290 1290,1470 1470,1650 1650,1980
so, {} you read to
所以，你读到[]扇区，

2350
01:20:56,550 --> 01:21:00,150
0,510 510,780 780,2010 2100,2670 3060,3600
five {[] -} sectors,| {re-compute
|重新计算校验并将其与存储的校验和进行比较，

2351
01:21:00,150 --> 01:21:01,800
0,630 630,1080 1080,1200 1200,1560 1560,1650
-} checksum and compare it

2352
01:21:01,800 --> 01:21:03,300
0,150 150,240 240,660 660,1020 1020,1500
with the checksum stored,| it's
|如果没错，那它一定是一个完整的记录。

2353
01:21:03,300 --> 01:21:04,680
0,450 450,840 870,1140 1140,1320 1320,1380
right, then it must be

2354
01:21:04,680 --> 01:21:05,700
0,60 60,390 390,780
a complete record.|
|

2355
01:21:07,390 --> 01:21:08,830
0,420 420,720 720,930 930,1050 1050,1440
Okay, okay, so if it's
好的，如果它少于，

2356
01:21:08,830 --> 01:21:09,970
0,450 450,600 600,810 810,930 930,1140
shorter than,| good, if it's
|如果不是，那你就玩这个技巧，

2357
01:21:09,970 --> 01:21:10,840
0,240 240,480 510,660 660,780 780,870
not then you do the

2358
01:21:10,840 --> 01:21:13,000
0,390 390,630 630,750 750,1140 1560,2160
trick,| okay, I see.| Yeah,
|好的，我明白了。|是的，我不确定他们到底是做什么的。

2359
01:21:13,000 --> 01:21:14,140
0,60 60,240 240,420 420,840 840,1140
I'm not sure what exactly

2360
01:21:14,140 --> 01:21:16,380
0,90 90,420 1140,1980
they do.| Okay,
|好的，非常感谢。

2361
01:21:16,660 --> 01:21:18,310
0,480 540,900 900,990 990,1140 1140,1650
okay, thank you so much.|
|

2362
01:21:18,310 --> 01:21:19,860
0,210 210,630
You're welcome.|
不用谢。|

2363
01:21:22,090 --> 01:21:23,560
0,210 210,420 420,1230
Any more questions?|
还有什么问题吗？|

2364
01:21:29,260 --> 01:21:31,510
0,390 390,600 600,690 690,1110 1320,2250
{} If you go back
如果你向后或向前看三张幻灯片？

2365
01:21:31,540 --> 01:21:34,570
0,180 180,870 1020,1470 1470,2520 2520,3030
or forward three slides?| Yep,
|好的，这个？

2366
01:21:35,210 --> 01:21:36,580
0,420 450,570 570,1110
here?| It was.|
|它是。|

2367
01:21:36,910 --> 01:21:38,080
0,270 270,270 270,780 780,1050 1050,1170
Oh, {} maybe back one
哦，也许倒退一张幻灯片，

2368
01:21:38,080 --> 01:21:39,580
0,510 540,840 840,930 930,1290 1290,1500
slide,| there's a section where
|有一节你谈到了，

2369
01:21:39,580 --> 01:21:41,040
0,180 180,480 480,750 750,1140
you talked about how,|
|

2370
01:21:41,330 --> 01:21:42,080
0,450
if
如果在写入过程中发生崩溃，

2371
01:21:42,320 --> 01:21:44,420
0,450 960,1380 1380,1800 1800,2010 2010,2100
{} crash happens during the

2372
01:21:44,420 --> 01:21:45,320
0,330 330,420 420,510 510,810 810,900
middle of a write| and
|我们得到日志中的前缀，

2373
01:21:45,320 --> 01:21:46,460
0,90 90,240 240,390 390,690 690,1140
we get like yeah prefix

2374
01:21:46,460 --> 01:21:48,290
0,90 90,180 180,720 1140,1440 1440,1830
in the log log,| that's
|就像好的或什么东西，

2375
01:21:48,290 --> 01:21:49,370
0,210 210,540 540,630 630,990 990,1080
like okay or something,| do
|你能重复一遍你的意思吗？

2376
01:21:49,370 --> 01:21:50,630
0,90 90,270 270,750 750,930 930,1260
you mind repeating what you

2377
01:21:50,630 --> 01:21:52,670
0,300 300,690 960,1470 1470,1650 1650,2040
meant there?| Yeah, okay, so
|是的，好的，让我们回到最后一张图片，

2378
01:21:52,670 --> 01:21:54,860
0,780 1110,1590 1620,1860 1860,1980 1980,2190
{} so let's go back

2379
01:21:54,860 --> 01:21:55,760
0,90 90,270 270,510 510,810 810,900
to this last picture,| I
|我刚才在这里展示了，

2380
01:21:55,760 --> 01:21:58,940
0,180 180,660 1680,2460 2640,3000 3000,3180
just showed earlier here,| so
|所以这里有我们的，

2381
01:21:58,940 --> 01:22:01,940
0,390 390,600 600,870 870,1230 1530,3000
we have our,| so the
|所以工作站 1 可以执行很多很多文件系统操作，

2382
01:22:02,480 --> 01:22:03,560
0,270 270,510 510,840 840,990 990,1080
{workstation -} 1 could have

2383
01:22:03,560 --> 01:22:05,030
0,450 450,780 780,990 990,1230 1230,1470
executed many, many file system

2384
01:22:05,030 --> 01:22:06,920
0,480 480,840 1350,1590 1590,1800 1800,1890
operations, correct,| each one of
|它们中的每一个由这些日志中的一个描述，

2385
01:22:06,920 --> 01:22:08,930
0,960 960,1410 1410,1710 1710,1920 1920,2010
them described by one of

2386
01:22:08,930 --> 01:22:10,160
0,150 150,510 510,780 780,900 900,1230
these log,| by an entry
|由日志中的一个条目，

2387
01:22:10,160 --> 01:22:11,690
0,60 60,150 150,540 1050,1320 1320,1530
in the log,| so like
|所以，第一个条目可能是创建文件 f ，

2388
01:22:11,690 --> 01:22:12,980
0,120 120,510 510,990 990,1080 1080,1290
the first entry it might

2389
01:22:12,980 --> 01:22:14,150
0,120 120,420 420,660 660,960 960,1170
be creating file f, {}|
|

2390
01:22:14,150 --> 01:22:15,260
0,300 300,660 660,750 750,840 840,1110
second entry in the log
日志中的第二个条目可以是创建文件 g ，

2391
01:22:15,260 --> 01:22:16,700
0,240 240,420 420,720 720,1320 1320,1440
might be creating {file,g},| you
|第三个可能是创建，删除文件 f 。

2392
01:22:16,700 --> 01:22:17,660
0,150 150,480 480,540 540,780 780,960
know whatever the third one

2393
01:22:17,660 --> 01:22:19,550
0,180 180,720 720,1140 1140,1530 1530,1890
might creating deleting file f.|
|

2394
01:22:20,140 --> 01:22:21,130
0,210 210,420 420,600 600,750 750,990
And so there's a whole
所以有一个完整的操作序列，

2395
01:22:21,130 --> 01:22:23,140
0,360 360,450 450,960 960,1200 1200,2010
sequence of operations,| because remember
|因为记住工作站只是继续执行文件系统操作，

2396
01:22:23,170 --> 01:22:24,910
0,150 150,630 630,810 810,1080 1080,1740
the workstation just keeps executing

2397
01:22:24,910 --> 01:22:28,060
0,480 510,720 720,960 960,1710 2190,3150
{} file system operations, {}|
|

2398
01:22:28,060 --> 01:22:29,320
0,150 150,360 360,510 510,810 810,1260
as long as {it,holds} locks,|
在它持有锁的时候，|

2399
01:22:29,320 --> 01:22:30,610
0,180 180,630 630,930 930,1170 1170,1290
and nobody else wants the
而且没有其他人想要这把锁，

2400
01:22:30,610 --> 01:22:31,340
0,570
lock,|
|

2401
01:22:31,590 --> 01:22:32,820
0,300 300,480 480,690 690,1080 1080,1230
and so the lock could
所以，锁可以是包含很多文件系统操作，

2402
01:22:32,820 --> 01:22:34,680
0,360 360,960 990,1410 1410,1470 1470,1860
be a contained a whole

2403
01:22:34,680 --> 01:22:37,020
0,690 720,990 990,1320 1320,1590 1590,2340
bunch of file system operations,|
|

2404
01:22:37,110 --> 01:22:38,370
0,270 270,420 420,720 720,990 990,1260
now for each file system
现在，对于每个文件系统操作，

2405
01:22:38,370 --> 01:22:39,870
0,450 450,570 570,660 660,1140 1140,1500
operation,| for each individual one,
|对于每个单独的操作，有一个日志记录，

2406
01:22:39,900 --> 01:22:41,160
0,240 240,300 300,600 600,1050
there's a log record,|
|

2407
01:22:42,180 --> 01:22:43,890
0,630 750,870 870,1200 1200,1620 1620,1710
and the log records you
而日志记录是原子文件系统操作，

2408
01:22:43,890 --> 01:22:46,080
0,420 480,1200 1200,1590 1590,2010 2010,2190
know is the atomic file

2409
01:22:46,080 --> 01:22:47,580
0,240 240,720 720,1290 1290,1410 1410,1500
system operations,| description of the
|描述更改，

2410
01:22:47,580 --> 01:22:48,480
0,420 420,570 570,720 720,780 780,900
changes,| that need to be
|需要执行到真正的文件系统块，

2411
01:22:48,480 --> 01:22:49,560
0,270 270,360 360,480 480,720 720,1080
made to the actual {file,system

2412
01:22:49,560 --> 01:22:52,260
0,120 120,660 840,1320 1320,2070 2100,2700
-} blocks| to {} reflect
|以反映那个文件系统操作。

2413
01:22:52,290 --> 01:22:54,020
0,480 480,690 690,930 930,1470
that file system operation.|
|

2414
01:22:54,590 --> 01:22:55,700
0,240 240,360 360,510 510,660 660,1110
And so what could happen,
那么会发生什么，

2415
01:22:55,700 --> 01:22:58,490
0,270 270,570 570,960 1200,2010 2130,2790
right,| is that {} {the,revoke}
|撤销消息进入，

2416
01:22:58,490 --> 01:23:00,950
0,300 300,570 570,1020 1140,1920 1950,2460
message comes in,| the workstation
|工作站 1 开始写入它的日志到 Petal ，

2417
01:23:00,950 --> 01:23:02,660
0,300 300,630 630,960 960,1140 1140,1710
1 starts writing its log

2418
01:23:02,690 --> 01:23:04,310
0,90 90,210 210,900 900,1080 1080,1620
you know to {} Petal,|
|

2419
01:23:04,550 --> 01:23:05,630
0,360 360,480 480,690 690,930 930,1080
but it just doesn't get
但这并不能一直持续到最后，

2420
01:23:05,630 --> 01:23:06,380
0,60 60,360 360,540 540,630 630,750
the whole way to the

2421
01:23:06,380 --> 01:23:07,430
0,270 270,420 420,600 600,930 930,1050
end,| it just happens to
|它只是碰巧崩溃了，

2422
01:23:07,430 --> 01:23:08,330
0,390 390,540 540,780 780,840 840,900
crash,| like somewhere in the
|在中间的某个地方，任何地方，

2423
01:23:08,330 --> 01:23:10,850
0,330 360,660 660,1230 1530,1980 2370,2520
middle like anywhere, right,| in
|在这种情况下，

2424
01:23:10,850 --> 01:23:13,130
0,360 360,960 960,1380 1380,2040 2040,2280
that case,| the prefix of
|工作站日志的前缀在磁盘上或在 Petal 中，

2425
01:23:13,130 --> 01:23:14,930
0,330 360,900 900,1440 1470,1650 1650,1800
the workstation log is on

2426
01:23:14,930 --> 01:23:15,600
0,90 90,600
the disk

2427
01:23:16,870 --> 01:23:18,040
0,240 240,420 420,870
or in Petal,|
|

2428
01:23:18,530 --> 01:23:19,970
0,540 540,900 900,1050 1050,1320 1320,1440
{} and that means that,|
这意味着，|

2429
01:23:19,970 --> 01:23:21,470
0,360 360,480 480,930 930,1200 1200,1500
basically the last couple {file,system
最后的几个文件系统操作只是日志，

2430
01:23:21,470 --> 01:23:22,940
0,180 180,660 660,720 720,960 960,1470
-} operation are just logs,|
|

2431
01:23:27,370 --> 01:23:29,200
0,270 270,570 570,960 990,1560 1560,1830
and only the prefix will
并且只有前缀将被重放。

2432
01:23:29,200 --> 01:23:30,240
0,150 150,690
be replayed.|
|

2433
01:23:31,300 --> 01:23:32,170
0,240 240,480 480,600 600,720 720,870
I see and we're just
我明白了，并且我们只是说好的。

2434
01:23:32,170 --> 01:23:33,790
0,210 210,450 450,930 1170,1380 1380,1620
saying that's okay.| Yeah, we're
|是的，我们接受这个结果。

2435
01:23:33,790 --> 01:23:35,020
0,360 360,540 540,930
accepting that outcome.|
|

2436
01:23:35,690 --> 01:23:36,920
0,270 270,390 390,600 600,810 900,1230
Got it, thank you.| Because
知道了，谢谢。|因为我们早些时候已经接受了这一结果，

2437
01:23:36,920 --> 01:23:37,940
0,120 120,330 330,720 720,810 810,1020
we're already accepted to that

2438
01:23:37,940 --> 01:23:39,470
0,270 270,840 870,1260 1260,1380 1380,1530
outcome earlier,| because it could
|因为在这种情况下是可以的，

2439
01:23:39,470 --> 01:23:40,940
0,570 570,690 690,870 870,1230 1230,1470
{in,the,case},| that we've got the
|我们得到文件系统崩溃

2440
01:23:40,940 --> 01:23:43,400
0,210 210,480 480,810 1530,1920 1920,2460
file system crashed| right before
|在收到撤销消息之前或之后，

2441
01:23:43,400 --> 01:23:44,270
0,180 180,390 390,660 660,720 720,870
or right after you got

2442
01:23:44,270 --> 01:23:45,380
0,90 90,510 510,840 840,990 990,1110
the revoke message,| but it
|但它没有向 Petal 写入任何日志条目。

2443
01:23:45,380 --> 01:23:46,490
0,180 180,360 360,570 570,840 840,1110
actually didn't write any log

2444
01:23:46,490 --> 01:23:48,640
0,480 540,780 780,1440 1500,1920
entries {} to Petal.|
|

2445
01:23:56,790 --> 01:23:58,020
0,240 240,390 390,930
Any more questions?|
还有什么问题吗？|

2446
01:23:58,500 --> 01:23:59,180
0,390

2447
01:24:01,880 --> 01:24:03,800
0,180 180,420 420,690 690,1260 1260,1920
I have a completely unrelated
我有一个与 6.824 完全无关的问题，

2448
01:24:03,830 --> 01:24:06,980
0,750 1590,2310 2370,2790 2790,3030 3030,3150
question {} to {6.824 -

2449
01:24:06,980 --> 01:24:09,080
0,450 450,1110 1290,1560 1560,1710 1710,2100
-},| but I was wondering
|但我想知道你是否知道下学期的 6.858 ，

2450
01:24:09,080 --> 01:24:11,450
0,240 240,360 360,840 1110,1740 1770,2370
if you knew {} anything

2451
01:24:11,450 --> 01:24:12,980
0,630 630,900 900,1170 1170,1260 1260,1530
about {} {6.858 - -

2452
01:24:12,980 --> 01:24:14,810
0,540 570,870 870,1050 1050,1320 1320,1830
-} {} for next semester,|
|

2453
01:24:14,810 --> 01:24:16,220
0,90 90,300 300,720 720,1290 1290,1410
I saw professor Zeldovich is
我看到 Zeldovich 教授要教 6.S060 。

2454
01:24:16,220 --> 01:24:18,020
0,120 120,180 180,360 360,960 1320,1800
going to be teaching {}

2455
01:24:18,080 --> 01:24:20,720
0,630 630,1080 1080,1380 1380,2130 2130,2640
{6.S060 - - -}.| Yeah,
|是的，我想我们，

2456
01:24:20,720 --> 01:24:22,250
0,150 150,330 330,870 900,1170 1170,1530
I think we're,| {} the
|目前的计划不会在秋季提供 6.858 ，

2457
01:24:22,250 --> 01:24:23,960
0,240 240,420 420,540 540,930 930,1710
current plan does not offer

2458
01:24:23,960 --> 01:24:25,640
0,150 150,390 390,570 570,930 930,1680
{} {6.858 -} in the

2459
01:24:26,240 --> 01:24:29,510
0,840 1200,1950 1980,2370 2370,2520 2520,3270
Fall,| {} but we're hoping
|但我们希望能在春季推出。

2460
01:24:29,510 --> 01:24:30,710
0,570 570,930 930,1020 1020,1140 1140,1200
to offer it in the

2461
01:24:30,710 --> 01:24:31,440
0,390
Spring.|
|

2462
01:24:31,790 --> 01:24:33,380
0,510 540,1050 1110,1410 1410,1500 1500,1590
Okay, awesome,| {} do you
好的，太棒了，|你知道 6.S060 是什么吗，

2463
01:24:33,380 --> 01:24:35,870
0,120 120,510 600,960 960,1260 1740,2490
know what {6.S060 - -}

2464
01:24:35,900 --> 01:24:37,190
0,360 360,540 540,720 720,1020 1020,1290
is,| I I couldn't find
|我找不到太多信息。

2465
01:24:37,190 --> 01:24:42,410
0,240 240,840 840,2430 2430,4230 4950,5220
much information for.| Yeah, that's
|是的，这是个好问题，

2466
01:24:42,410 --> 01:24:43,910
0,60 60,180 180,600 810,1350 1350,1500
a good question,| {} it's
|这是一门本科生课程。

2467
01:24:43,910 --> 01:24:47,210
0,450 450,540 540,900 900,2220 2220,3300
intended to be a undergraduate

2468
01:24:47,210 --> 01:24:47,820
0,480
class.|
|

2469
01:24:48,380 --> 01:24:49,260
0,660
Okay.|
好的。|

2470
01:24:49,560 --> 01:24:50,740
0,480 510,870
Okay, nice.|
好的，很好。|

2471
01:24:51,320 --> 01:24:52,820
0,300 300,480 480,750 750,930 930,1500
So like {6.858 - -
所以，像 6.858 ，但是本科生的。

2472
01:24:52,820 --> 01:24:54,890
0,570 600,870 870,1140 1140,1410 1410,2070
- - - -}, but

2473
01:24:55,100 --> 01:24:57,800
0,510 750,1590 1920,2280 2280,2490 2490,2700
{} undergrad.| {Yeah -}, sort
|是的，也许是 6.857 和 6.858 的入门。

2474
01:24:57,800 --> 01:25:00,470
0,90 90,270 270,1470 2190,2610 2610,2670
of like, {} maybe an

2475
01:25:00,470 --> 01:25:01,580
0,390 390,480 480,750 750,960 960,1110
intro to both {6.857 -

2476
01:25:01,580 --> 01:25:02,780
0,210 210,570 570,840 840,990 990,1200
- -} {and,6.858 - -

2477
01:25:02,780 --> 01:25:03,300
0,270
-}.|
|

2478
01:25:04,960 --> 01:25:06,180
0,660
Okay,
好的，编号是什么？

2479
01:25:06,540 --> 01:25:07,860
0,300 300,390 390,1020
what's the number?|
|

2480
01:25:08,070 --> 01:25:09,540
0,300 300,450 450,600 600,1170 1170,1470
{} It's an experimental number,|
这是一个试验性的编号，|

2481
01:25:09,540 --> 01:25:10,620
0,90 90,240 240,300 300,450 450,1080
it's one of these experimental,|
这是一个试验性的，|

2482
01:25:10,620 --> 01:25:11,880
0,420 420,480 480,720 720,930 930,1260
because the class doesn't exist
因为这个课还不存在，

2483
01:25:11,880 --> 01:25:13,560
0,510 930,1140 1140,1260 1260,1380 1380,1680
yet,| and will be offered
|并将提供，

2484
01:25:13,560 --> 01:25:14,490
0,420 420,540 540,660 660,750 750,930
for,| you know the goal
|目标是在秋季首次提供它。

2485
01:25:14,490 --> 01:25:15,120
0,90 90,150 150,420 420,510 510,630
is to offer it for

2486
01:25:15,120 --> 01:25:15,810
0,60 60,360 360,540 540,600 600,690
the first time in the

2487
01:25:15,810 --> 01:25:16,440
0,390
Fall.|
|

2488
01:25:17,530 --> 01:25:19,500
0,840 1080,1680
Okay, {}
好的，那么，是不是主要是因为，

2489
01:25:20,060 --> 01:25:21,380
0,420 420,630 630,900 900,1110 1110,1320
so, is it gonna be

2490
01:25:21,380 --> 01:25:23,690
0,510 510,990 990,1230 1230,1650 2100,2310
mostly content from,| like is
|6.858 是不是会保持它原来的样子，或者。

2491
01:25:23,690 --> 01:25:25,070
0,150 150,390 390,570 570,840 990,1380
{6.858 - -} gonna keep

2492
01:25:25,070 --> 01:25:26,600
0,180 180,630 630,1140 1140,1380 1380,1530
its original form, or is

2493
01:25:26,600 --> 01:25:29,570
0,240 330,1410 2130,2640 2640,2880 2880,2970
it.| {} You're asking me
|你在问我问题，我没有。

2494
01:25:29,570 --> 01:25:31,580
0,390 390,420 420,750 750,1110 1110,2010
questions, I don't.| Sorry.| Yeah,
|抱歉。|是的，我认为参与设计这门课的人，

2495
01:25:31,610 --> 01:25:36,200
0,2400 2430,2850 2850,3960 3960,4200 4200,4590
I think the people involved

2496
01:25:36,200 --> 01:25:37,760
0,180 180,900 900,1110 1110,1470 1470,1560
in {} in designing the

2497
01:25:37,760 --> 01:25:38,960
0,330 330,780 810,1050 1050,1170 1170,1200
class| or people that are
|或者参与 6.857 的人，

2498
01:25:38,960 --> 01:25:40,010
0,300 300,390 390,510 510,720 720,1050
involved in {6.857 - -},|
|

2499
01:25:40,010 --> 01:25:40,880
0,180 180,240 240,510 510,810 810,870
and the people involved in
以及参与 6.858 的人。

2500
01:25:40,880 --> 01:25:42,230
0,90 90,300 300,720 720,1140 1140,1350
{6.858 -}.| Yeah.| I'm not
|是的。|我并没有参与其中。

2501
01:25:42,230 --> 01:25:43,080
0,240 240,750
actually involved.|
|

2502
01:25:43,280 --> 01:25:44,900
0,540 570,810 810,1080 1080,1350 1350,1620
Okay.| Yet another reason,| but
好的。|还有一个原因，|他们正在努力制定课程，

2503
01:25:45,140 --> 01:25:47,300
0,720 990,1530 1530,1860 1860,2070 2070,2160
{} and they're trying to

2504
01:25:47,300 --> 01:25:48,110
0,180 180,300 300,390 390,450 450,810
work out with the curriculum

2505
01:25:48,110 --> 01:25:49,040
0,360 360,450 450,570 570,630 630,930
exactly it's going to be|
|

2506
01:25:49,040 --> 01:25:49,820
0,150 150,330 330,420 420,690 690,780
and then of course it
当然，会对 6.858 6.857 进行一些[]。

2507
01:25:49,820 --> 01:25:50,930
0,120 120,180 180,330 330,540 540,1110
going to have some []

2508
01:25:50,930 --> 01:25:52,010
0,300 300,390 390,630 630,960 960,1080
for {6.858 - -} {6.857

2509
01:25:52,010 --> 01:25:52,740
0,180 180,450
- -}.|
|

2510
01:25:53,580 --> 01:25:55,380
0,570 780,1170 1170,1500
Okay, sounds good.|
好的，听起来不错。|

2511
01:25:55,630 --> 01:25:56,650
0,270 270,540 540,660 660,840 840,1020
But {6.858 - -}, {6.857
但是 6.858 6.857 不会离开，这就是。

2512
01:25:56,650 --> 01:25:57,610
0,390 390,510 510,660 660,840 840,960
-} {} not gonna go

2513
01:25:57,610 --> 01:25:59,740
0,390 930,1320 1320,1800
away, that's the.|
|

2514
01:26:01,960 --> 01:26:04,360
0,630 870,1020 1020,1170 1170,1440 2130,2400
{Great\,,thanks}.| You're {welcome -}.| {I,have}
好的，谢谢。|不用谢。|我有个问题，

2515
01:26:04,360 --> 01:26:06,040
0,450 660,1410 1410,1530 1530,1620 1620,1680
a question,| I don't know
|我不知道它是否简单，

2516
01:26:06,040 --> 01:26:07,150
0,120 120,390 390,480 480,690 690,1110
how quick it is,| but
|但在论文中的页末，

2517
01:26:07,630 --> 01:26:09,190
0,540 540,750 750,870 870,1410 1410,1560
{} in the paper, at

2518
01:26:09,190 --> 01:26:11,470
0,180 180,420 420,750 1050,1650 1650,2280
the end of page, {}|
|

2519
01:26:12,190 --> 01:26:14,320
0,840 840,990 990,1260 1260,1620 1620,2130
like right before section seven,|
在第七节之前，|

2520
01:26:14,470 --> 01:26:16,540
0,420 420,750 750,1230 1230,1320 1320,2070
they talk about a case
他们谈到了一个失败案例，

2521
01:26:16,660 --> 01:26:18,240
0,300 300,840 840,1410
{} failure,| where
|就是租约到期了，

2522
01:26:18,520 --> 01:26:19,990
0,480 480,750 750,960 960,1140 1140,1470
{} with like the lease

2523
01:26:19,990 --> 01:26:21,760
0,780 780,1140 1140,1230 1230,1560 1560,1770
expiring,| and the server not
|而且服务器并没有真的崩溃。

2524
01:26:21,760 --> 01:26:24,040
0,180 180,870 1080,1530 1650,1950 1950,2280
really crashing.| Yeah.| And then
|是的。|然后谈论，

2525
01:26:24,040 --> 01:26:26,700
0,330 330,900 930,1590 1650,2400
talk about like, {}|
|

2526
01:26:26,970 --> 01:26:28,560
0,570 570,840 840,1110 1110,1320 1320,1590
basically that there's no real
基本上没有真正的解决方案。

2527
01:26:28,560 --> 01:26:32,520
0,510 990,2700 2700,3660 3660,3750 3750,3960
solution.| {Well\,,there,is,a,solution},| {there,is} a real
|嗯，有一个解决方案，|有一个真正的解决方案。

2528
01:26:32,520 --> 01:26:36,440
0,510 510,2010 2520,2880 2880,3600
solution.| Like human intervention.|
|比如，人类的干预。|

2529
01:26:36,730 --> 01:26:37,960
0,420 420,690 720,930 930,1080 1080,1230
Yeah, okay, so I think
是的，好的，所以我认为这里的问题，

2530
01:26:37,960 --> 01:26:38,680
0,60 60,330 330,570 570,630 630,720
the problem here| in the
|在论文主题中，

2531
01:26:38,680 --> 01:26:39,850
0,570 570,780 780,870 870,1080 1080,1170
sort of the theme of

2532
01:26:39,850 --> 01:26:40,690
0,90 90,330 330,540 540,690 690,840
the paper works,| like {}
|Petal 和 Frangipani 是独立设计的，

2533
01:26:40,690 --> 01:26:42,430
0,480 480,690 690,1290 1290,1410 1410,1740
Petal and Frangipani are designed

2534
01:26:42,430 --> 01:26:44,470
0,780 1170,1500 1500,1650 1650,1980 1980,2040
independently,| and that has a
|它有很多很好的特性，

2535
01:26:44,470 --> 01:26:46,330
0,150 150,210 210,450 450,1200 1470,1860
lot of nice properties, {}|
|

2536
01:26:46,330 --> 01:26:46,990
0,150 150,300 300,390 390,570 570,660
and this is going to
这将有一个地方，

2537
01:26:46,990 --> 01:26:48,250
0,180 180,420 420,660 660,1050 1050,1260
where one one place,| where
|这将是非常有帮助的，

2538
01:26:48,250 --> 01:26:49,480
0,90 90,240 240,300 300,600 600,1230
it would be very helpful,|
|

2539
01:26:49,480 --> 01:26:50,770
0,420 420,660 660,870 870,1140 1140,1290
helpfully that {you,know} Petal has
Petal 有一些支持来帮助 Frangipani ，

2540
01:26:50,770 --> 01:26:52,870
0,150 150,810 1080,1170 1170,1500 1500,2100
some support to help Frangipani

2541
01:26:52,870 --> 01:26:53,500
0,90 90,450
{along -},|
|

2542
01:26:53,760 --> 01:26:55,500
0,660 750,1020 1020,1410 1410,1530 1530,1740
and that support would be
这个支持会在写入 Petal 上有一个时间戳，

2543
01:26:55,500 --> 01:26:56,610
0,270 270,480 480,540 540,780 780,1110
actually have a {timestamp -}

2544
01:26:56,610 --> 01:26:58,110
0,150 150,300 300,870 900,1080 1080,1500
on the writes to Petal,|
|

2545
01:26:58,110 --> 01:26:59,310
0,120 120,390 420,690 690,810 810,1200
so that Petal could see
Petal 可以看出写入是否太旧。

2546
01:26:59,310 --> 01:27:00,270
0,180 180,240 240,570 570,870 870,960
{where -} write actually is

2547
01:27:00,270 --> 01:27:02,100
0,300 360,990 990,1440
out basically {too,old}.|
|

2548
01:27:04,010 --> 01:27:04,920
0,630
Okay.|
好的。|

2549
01:27:05,120 --> 01:27:06,290
0,210 210,510 510,660 660,810 810,1170
So unless you do that,|
所以除非你这么做，|

2550
01:27:06,290 --> 01:27:07,310
0,120 120,330 330,450 450,720 720,1020
you need to like [fiddle]
你需要[摆弄]边际。

2551
01:27:07,310 --> 01:27:08,720
0,390 390,510 510,690 690,780 780,1410
around with like the margin.|
|

2552
01:27:10,790 --> 01:27:11,700
0,630
Okay.|
好的。|

2553
01:27:11,920 --> 01:27:13,810
0,150 150,330 330,780 780,1230 1230,1890
And what happens if, {}|
如果会发生什么，|

2554
01:27:14,610 --> 01:27:18,060
0,1290 1530,1950 1980,2280 2280,2940 2940,3450
like that error occurs,| like
那个错误发生，|比如在边界之外。

2555
01:27:18,760 --> 01:27:19,750
0,480 480,540 540,660 660,930 930,990
outside of the bounds of

2556
01:27:19,750 --> 01:27:21,370
0,60 60,600 990,1230 1230,1500 1500,1620
the margin.| {} It'll be
|它会很酷，

2557
01:27:21,370 --> 01:27:24,670
0,240 240,660 1230,3000 3000,3120 3120,3300
that's [cool],| {you,know,basically} you get
|你得到的是较旧的写入，

2558
01:27:24,670 --> 01:27:26,200
0,90 90,570 570,1050 1050,1200 1200,1530
an older writes,| {you,know} show
|出现在，

2559
01:27:26,200 --> 01:27:28,810
0,210 210,360 360,720 1140,2130 2220,2610
up in the,| basically somebody
|其他人可能在那个时刻获得那个文件上的锁，

2560
01:27:28,810 --> 01:27:29,740
0,210 210,360 360,450 450,690 690,930
else might have that point

2561
01:27:29,740 --> 01:27:30,700
0,240 240,330 330,720 750,870 870,960
gotten the lock on the

2562
01:27:30,700 --> 01:27:32,170
0,360 360,720 720,1050 1050,1320 1320,1470
file, correct,| start writing to
|开始写入它，

2563
01:27:32,170 --> 01:27:33,280
0,240 300,600 600,780 780,900 900,1110
it,| and then there's old
|然后又出现了旧的写入，

2564
01:27:33,280 --> 01:27:34,660
0,240 240,480 480,720 720,810 810,1380
write shows up,| and basically
|基本上改写其中的某一部分。

2565
01:27:34,690 --> 01:27:35,770
0,240 240,330 330,720 720,870 870,1080
{presumably -} overwrite some part

2566
01:27:35,770 --> 01:27:36,180
0,60 60,210
of it.|
|

2567
01:27:37,210 --> 01:27:38,100
0,630
Okay.|
好的。|

2568
01:27:38,870 --> 01:27:40,460
0,240 240,360 360,600 600,1290
So will break consistency.|
所以，这将打破一致性。|

2569
01:27:42,460 --> 01:27:44,700
0,360 360,630 630,930
{I,see}, {thank,you}.| {You're,welcome}.|
了解了，谢谢。|不用谢。|

2570
01:27:49,280 --> 01:27:50,280
0,750
Okay,
好的，因为我们会停止了。

2571
01:27:51,740 --> 01:27:53,120
0,300 300,420 420,720 720,1080
because we'll stop that.

2572
01:27:55,370 --> 01:27:56,360
0,690
