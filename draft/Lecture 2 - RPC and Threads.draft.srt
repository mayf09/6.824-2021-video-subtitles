1
00:00:02,060 --> 00:00:04,280
0,570 1140,1530 1530,1710 1710,1830 1830,2220
{ -} Okay, so the
好的，今天的主题是线程和 RPC ，

2
00:00:04,310 --> 00:00:05,930
0,300 300,420 420,810 810,1050 1050,1620
topic for today is {}

3
00:00:05,930 --> 00:00:08,030
0,300 300,390 390,540 540,1170 1770,2100
threads and {RPC -},| second
|6.824 第二讲，

4
00:00:08,030 --> 00:00:10,460
0,390 390,1140 1620,1860 1860,1980 1980,2430
lecture in {6.824 - -},|
|

5
00:00:10,550 --> 00:00:12,170
0,1020 1020,1110 1110,1230 1230,1320 1320,1620
again we're going to mostly
我们将主要关注 Go 的线程和 RPC ，

6
00:00:12,170 --> 00:00:12,860
0,150 150,270 270,480 480,570 570,690
look at threads and {RPC

7
00:00:12,860 --> 00:00:13,880
0,360 360,450 450,510 510,900 900,1020
-} in the context of

8
00:00:13,880 --> 00:00:14,880
0,480
Go,|
|

9
00:00:14,880 --> 00:00:16,950
0,540 900,1440 1440,1770 1770,1920 1920,2070
{you,know} programming language that we're
我们在实验中使用的编程语言，

10
00:00:16,950 --> 00:00:18,720
0,330 330,510 510,960 990,1620 1680,1770
using in the labs,| and
|这节课的大部分内容都是量身定做的，

11
00:00:18,720 --> 00:00:19,890
0,270 270,660 660,930 930,990 990,1170
in fact most of this

12
00:00:19,890 --> 00:00:21,900
0,330 330,420 420,690 690,1320 1680,2010
lecture is really tailored, {}|
|

13
00:00:21,900 --> 00:00:25,020
0,330 330,870 930,1440 1440,2670 2700,3120
{towords -} helping you do
帮助你了解实验用的 Go 编程，

14
00:00:25,020 --> 00:00:27,060
0,210 210,810 810,1410 1440,1560 1560,2040
Go programming for the labs,|
|

15
00:00:27,960 --> 00:00:30,330
0,450 1170,1380 1380,1710 1710,1860 1860,2370
{} so {all,of} you've done
希望你完成了入门教程和爬虫练习，

16
00:00:30,330 --> 00:00:32,940
0,450 450,570 570,1320 1440,2400 2460,2610
hopefully the tutorial and the

17
00:00:32,940 --> 00:00:34,860
0,450 450,930 930,1110 1110,1560 1560,1920
crawler exercise,| which we'll discuss
|我们将在稍后的课程中详细讨论它们，

18
00:00:34,860 --> 00:00:35,460
0,90 90,300 300,330 330,480 480,600
them quite a bit of

19
00:00:35,460 --> 00:00:37,170
0,750 750,1080 1080,1200 1200,1290 1290,1710
detail later in the lecture,|
|

20
00:00:37,410 --> 00:00:39,060
0,510 510,960 960,1290 1290,1560 1560,1650
but before jumping into the
但在讨论细节之前，

21
00:00:39,060 --> 00:00:40,440
0,450 450,570 570,870 870,1170 1170,1380
details,| let me a little
|让我用更多的代码调用，

22
00:00:40,440 --> 00:00:41,940
0,180 180,510 510,630 630,930 930,1500
bit more of code calling,|
|

23
00:00:41,970 --> 00:00:43,350
0,330 450,780 780,930 930,1200 1200,1380
to break the [] and
来打破[]并让大家提问。

24
00:00:43,350 --> 00:00:44,670
0,180 180,360 360,480 480,660 660,1320
get people to ask questions.|
|

25
00:00:45,200 --> 00:00:46,520
0,360 360,540 540,780 780,870 870,1320
{} So maybe you can
也许你可以回答这个问题，

26
00:00:46,520 --> 00:00:48,200
0,270 270,330 330,1110 1110,1470 1470,1680
answer the question,| where are
|你在哪里，你觉得这个教程怎么样，

27
00:00:48,200 --> 00:00:49,460
0,240 240,750 780,1020 1020,1170 1170,1260
you and how did you

28
00:00:49,460 --> 00:00:51,110
0,330 330,480 480,960 960,1530 1530,1650
enjoy the tutorial,| what's your
|你对 Go 的第一印象是什么，

29
00:00:51,110 --> 00:00:53,930
0,210 210,660 660,1320 1350,1770 2220,2820
first impression to Go,| maybe
|也许我会。

30
00:00:53,930 --> 00:00:56,270
0,810 840,1320 1320,1530 1530,1980 1980,2340
I'll.| Yeah, how about Evan
|Evan Feldman 你觉得怎么样？

31
00:00:56,270 --> 00:00:57,400
0,600
Feldman?|
|

32
00:00:59,940 --> 00:01:02,910
0,390 390,900 960,1650 1860,2610 2610,2970
Hi, folks, I'm Batman,| I'm
大家好，我是 Batman ，|我在 Newton ，在大波士顿的郊区，

33
00:01:02,910 --> 00:01:04,710
0,600 600,1020 1020,1320 1320,1530 1530,1800
in Newton, which is {}

34
00:01:04,710 --> 00:01:05,730
0,120 120,240 240,690 690,780 780,1020
on the outskirts of greater

35
00:01:05,730 --> 00:01:08,310
0,540 870,1680 1680,1860 1860,2460 2460,2580
Boston,| {the,tutorial} was interesting,| it
|这个教程很有趣，|这是我第一次接触到面向对象的语言，

36
00:01:08,310 --> 00:01:09,960
0,120 120,240 240,540 540,1110 1110,1650
was my first exposure to

37
00:01:10,170 --> 00:01:11,700
0,360 360,450 450,630 630,1110 1110,1530
you know an object oriented

38
00:01:11,700 --> 00:01:14,010
0,540 600,1350 1380,1710 1710,1980 1980,2310
language,| {} so it's, {}
|所以，这是一种框架的改变，

39
00:01:14,010 --> 00:01:14,730
0,120 120,270 270,330 330,390 390,720
it's kind of a change,

40
00:01:14,730 --> 00:01:16,290
0,240 240,540 540,630 630,1110 1110,1560
a change in framework,| that
|适应这一点很有趣。

41
00:01:16,380 --> 00:01:18,030
0,540 570,930 930,1020 1020,1410 1410,1650
was interesting to adapt to.|
|

42
00:01:19,290 --> 00:01:22,620
0,210 210,1290 1440,2280 2280,2700
Okay, {how,about} Brendan Wall?|
好的，Brendan Wall 怎么样？|

43
00:01:28,390 --> 00:01:30,240
0,480 480,600 600,720 720,1290
Brendan, are you there?|
Brendan ，你在吗？|

44
00:01:30,530 --> 00:01:31,580
0,300 300,420 420,540 540,690 690,1050
Yes, I was just finding
是的，我只是在找取消静音按钮，

45
00:01:31,760 --> 00:01:33,260
0,450 600,840 840,1050 1050,1140 1140,1500
{the,unmute,button},| sorry, {what,was} the question,
|抱歉，问题是什么，我刚加入。

46
00:01:33,260 --> 00:01:35,000
0,120 120,300 300,600 930,1530 1530,1740
I just joined.| {} Where
|你在哪里，你对 Go 的第一印象是什么？

47
00:01:35,000 --> 00:01:35,870
0,150 150,270 270,690 690,750 750,870
are you {and,what,is -} your

48
00:01:35,870 --> 00:01:38,000
0,210 210,570 570,660 660,1050 1740,2130
first impressions of Go? {}|
|

49
00:01:38,000 --> 00:01:39,560
0,450 450,990 1020,1200 1200,1380 1380,1560
Yeah, it's, I had used
是的，我以前在实习中用过 Go ，

50
00:01:39,560 --> 00:01:40,400
0,60 60,240 240,600 600,750 750,840
to Go before, for an

51
00:01:40,400 --> 00:01:41,480
0,510 510,600 600,690 690,840 840,1080
internship,| that was my first
|那是我第一次处理并发的东西，

52
00:01:41,480 --> 00:01:42,620
0,210 210,630 690,930 930,1050 1050,1140
time actually dealing with the

53
00:01:42,620 --> 00:01:44,360
0,540 540,1080 1110,1230 1230,1290 1290,1740
concurrency stuff,| and I {like,Go},
|我喜欢 Go ，使用 goroutine 来工作，

54
00:01:44,420 --> 00:01:45,500
0,180 180,360 360,570 570,750 750,1080
like really working with goroutine,|
|

55
00:01:45,500 --> 00:01:47,920
0,420 630,1680 1680,1980
so kind of,
一开始很难想清楚，

56
00:01:48,010 --> 00:01:49,120
0,390 390,450 450,660 660,960 960,1110
initially it was tricky to

57
00:01:49,120 --> 00:01:51,880
0,210 210,420 420,1890 2190,2580 2610,2760
think through like,| like as
|比如主线程和所有的 goroutine 一起结束，

58
00:01:51,880 --> 00:01:52,900
0,120 120,240 240,360 360,690 690,1020
soon as the main thread

59
00:01:52,900 --> 00:01:54,340
0,420 420,750 750,1050 1050,1170 1170,1440
and {all,the,goroutines -} are ended,|
|

60
00:01:54,340 --> 00:01:55,870
0,180 180,420 420,630 960,1380 1380,1530
so kind of working through
解决早期的一些概念问题，

61
00:01:55,870 --> 00:01:57,250
0,210 210,690 690,870 870,930 930,1380
those early kind of conceptual

62
00:01:57,250 --> 00:02:00,970
0,360 360,480 480,930 930,1470 3420,3720
issues,| but it's interesting.| {How,about}
|但这很有趣。|[Connor Prisby] 怎么样？

63
00:02:00,970 --> 00:02:02,600
0,210 210,660 660,870 870,1170
the {[Connor,Prisby] - -}?|
|

64
00:02:13,170 --> 00:02:14,820
0,450 450,540 540,660 660,1080
[Connor], are you there?|
[Connor]，你在吗？|

65
00:02:19,120 --> 00:02:22,060
0,750 750,1020 1020,1200 1200,1530 1530,2940
Okay, {} try somebody else,
好的，试试其他人， Dory Shen 。

66
00:02:22,060 --> 00:02:23,740
0,420 420,990
Dory Shen.|
|

67
00:02:27,120 --> 00:02:29,190
0,660 750,1140 1140,1320 1320,1560 1560,2070
Hi, {} I'm in Cambridge
嗨，我现在在剑桥，

68
00:02:29,190 --> 00:02:30,600
0,180 180,450 450,870 900,1170 1170,1410
right now,| and I found
|我发现 Go 非常有趣，

69
00:02:30,600 --> 00:02:32,520
0,150 150,300 300,720 750,1440 1440,1920
Go to be pretty interesting,|
|

70
00:02:32,520 --> 00:02:33,690
0,90 90,270 270,600 690,930 930,1170
I thought like go through
我把教程的第一部分看了一遍，

71
00:02:33,690 --> 00:02:34,620
0,210 210,510 510,750 750,870 870,930
through the first part of

72
00:02:34,620 --> 00:02:36,870
0,90 90,660 660,1050 1050,1380 1710,2250
the tutorial,| I like learning
|比如我学习了 for 循环，以及它们 for 循环的方式，

73
00:02:36,870 --> 00:02:37,740
0,180 180,300 300,510 510,780 780,870
about the for loops and

74
00:02:37,740 --> 00:02:38,610
0,150 150,360 360,480 480,690 690,870
the way they do for

75
00:02:38,610 --> 00:02:39,810
0,420 450,810 810,960 960,1050 1050,1200
loops,| I thought that was
|我觉得这很有趣，

76
00:02:39,810 --> 00:02:41,250
0,210 210,690 690,780 780,1110 1140,1440
pretty interesting,| and like the
|比如它的组成方式，

77
00:02:41,250 --> 00:02:42,450
0,150 150,240 240,450 450,510 510,1200
way it's kind of structured,|
|

78
00:02:42,480 --> 00:02:43,980
0,360 360,630 630,1020 1020,1110 1110,1500
I think that I like
我想比如线程，

79
00:02:44,490 --> 00:02:46,650
0,300 450,840 840,1500 1500,1650 1680,2160
the the threads,| and I
|我发现它有点难，

80
00:02:46,740 --> 00:02:48,450
0,570 570,690 690,1080 1110,1560 1560,1710
found to be a little

81
00:02:48,450 --> 00:02:50,010
0,450 450,600 600,990 990,1320 1320,1560
bit more difficult about,| when
|当它结束时，

82
00:02:50,010 --> 00:02:51,990
0,120 120,690 690,1080 1200,1560 1560,1980
it ended,| like when {}
|比如有时函数会在所有例程之前结束，

83
00:02:52,530 --> 00:02:53,910
0,570 570,720 720,1050 1050,1230 1230,1380
sometimes the function would end

84
00:02:53,910 --> 00:02:55,110
0,240 240,360 360,450 450,990 990,1200
before all the routines,| like
|[比如结束]，

85
00:02:55,110 --> 00:02:56,730
0,390 390,690 900,1080 1080,1260 1260,1620
ended,| so that was like
|所以这想起来很有趣，

86
00:02:57,180 --> 00:02:58,350
0,480 480,600 600,780 780,1050 1050,1170
interesting to think about,| and
|我学到的更多，

87
00:02:58,350 --> 00:02:59,190
0,150 150,210 210,420 420,600 600,840
like I learned more about

88
00:02:59,190 --> 00:03:00,090
0,240 240,390 390,510 510,690 690,900
that,| so it's pretty cool,
|所以这很酷，我喜欢它。

89
00:03:00,090 --> 00:03:02,880
0,120 120,390 390,540 1110,2070 2100,2790
I liked it.| Well, hope
|好的，希望你们在这学期都会有一个好的 Go 的体验。

90
00:03:02,880 --> 00:03:03,600
0,150 150,300 300,420 420,480 480,720
{all,of,you} gonna have a very

91
00:03:03,600 --> 00:03:06,090
0,390 390,990 990,1410 1410,1890 1890,2490
positive experience with Go {}

92
00:03:07,440 --> 00:03:09,720
0,150 150,720 1020,1650 1650,2100 2130,2280
this semester.| {} And {}
|让我说一下为什么使用 Go 吗？

93
00:03:09,720 --> 00:03:10,530
0,180 180,330 330,540 540,720 720,810
so let me say a

94
00:03:10,530 --> 00:03:11,340
0,180 180,420 420,600 600,660 660,810
little bit like you know

95
00:03:11,340 --> 00:03:13,740
0,870 870,1350 1470,1980
why Go? {}|
|

96
00:03:14,210 --> 00:03:15,530
0,450 450,960 960,1050 1050,1170 1170,1320
In principle, you know there's
理论上，有很多编程语言，

97
00:03:15,530 --> 00:03:17,150
0,30 30,300 300,450 720,1170 1170,1620
a lot of programming languages,|
|

98
00:03:17,150 --> 00:03:18,200
0,90 90,210 210,360 360,510 510,1050
that you could have used
可以用来做分布式编程，

99
00:03:18,200 --> 00:03:19,670
0,180 180,450 450,840 840,1350 1350,1470
for doing distributed programming,| and
|Go 绝对不是唯一一个，

100
00:03:19,670 --> 00:03:20,780
0,330 330,420 420,840 840,1020 1020,1110
Go is absolutely not the

101
00:03:20,780 --> 00:03:22,610
0,180 180,540 960,1320 1320,1500 1500,1830
only one,| but some reasons
|但我们在 6.824 中选择 Go 有一些原因。

102
00:03:22,610 --> 00:03:24,680
0,240 240,990 1020,1410 1410,1650 1650,2070
why we why we chose

103
00:03:24,680 --> 00:03:26,000
0,390 390,630 630,690 690,870 870,1320
Go in {6.824 - -}.|
|

104
00:03:26,180 --> 00:03:27,530
0,750 750,870 870,1020 1020,1290 1290,1350
{} You know first of
首先，它对线程和 RPC 有很好的支持，

105
00:03:27,530 --> 00:03:28,670
0,120 120,210 210,360 360,540 540,1140
all, it has good support

106
00:03:30,320 --> 00:03:34,310
0,360 360,840 840,990 990,1740 3270,3990
for threads and RPC,| and
|这两点对于分布式编程非常重要，

107
00:03:34,910 --> 00:03:36,860
0,750 990,1260 1260,1350 1350,1620 1620,1950
those two are very important

108
00:03:36,860 --> 00:03:39,170
0,90 90,540 540,1110 1500,1980 2130,2310
for distributed programming,| so it
|所以这是有道理的，

109
00:03:39,170 --> 00:03:40,850
0,210 210,570 570,1140 1230,1290 1290,1680
makes sense to you know|
|

110
00:03:40,850 --> 00:03:41,930
0,420 420,690 690,840 840,900 900,1080
{} Go there's a good
Go 与这个很匹配。

111
00:03:41,930 --> 00:03:43,730
0,210 210,300 300,630 1080,1440 1440,1800
match for that.| Second reason
|我们非常喜欢它的第二个原因是，

112
00:03:43,730 --> 00:03:44,420
0,150 150,300 300,390 390,450 450,690
we like it a lot

113
00:03:44,420 --> 00:03:45,200
0,150 150,360 360,450 450,540 540,780
is| you know it has
|它有一个垃圾收集器，

114
00:03:45,200 --> 00:03:46,880
0,120 120,480 480,960 1020,1620 1620,1680
a garbage collector,| and if
|如果你做共享内存式的并发，

115
00:03:46,880 --> 00:03:48,440
0,120 120,570 570,840 840,1170 1170,1560
you do shared memory style

116
00:03:48,440 --> 00:03:50,720
0,570 570,1080 1080,1470 1470,1740 1740,2280
parallelism,| where multiple threads share
|多个线程共享一个结构体或变量，

117
00:03:50,750 --> 00:03:53,810
0,510 540,1260 1440,1770 1770,2460 2790,3060
a structure or variable {},|
|

118
00:03:53,810 --> 00:03:55,340
0,240 240,540 540,600 600,930 930,1530
then having a garbage collector
那么有垃圾收集器是很好的，

119
00:03:55,340 --> 00:03:56,690
0,420 420,810 810,1110 1110,1260 1260,1350
is nice,| because then the
|因为这样线程就不用考虑，

120
00:03:56,690 --> 00:03:57,770
0,240 240,480 480,570 570,660 660,1080
threads don't have to decide,|
|

121
00:03:57,770 --> 00:03:59,420
0,240 240,360 360,930 1080,1380 1380,1650
who's the last {} thread
谁是最后一个引用了这个内存的线程，

122
00:03:59,420 --> 00:04:00,650
0,150 150,510 510,720 720,840 840,1230
that actually has a reference

123
00:04:00,650 --> 00:04:02,030
0,150 150,360 360,810 810,1140 1140,1380
to this memory,| and should
|因此应该重新分配，

124
00:04:02,030 --> 00:04:04,220
0,450 450,630 630,1200 1290,1710 1770,2190
therefore {deallocated -},| the garbage
|垃圾收集器负责处理所有这些问题，

125
00:04:04,220 --> 00:04:05,420
0,300 300,600 630,870 870,1110 1110,1200
collector use takes care of

126
00:04:05,420 --> 00:04:06,680
0,180 180,360 360,1020
all those problems,|
|

127
00:04:06,980 --> 00:04:10,250
0,270 270,810 1470,1980 2130,2580 2580,3270
that's convenient.| {} {It's,type} safe.|
这很方便。|它是类型安全的。|

128
00:04:12,800 --> 00:04:14,180
0,780

129
00:04:14,420 --> 00:04:16,370
0,210 210,510 510,1290 1320,1470 1470,1950
It is simple, it's a
它很简单，是一种简单的编程语言，

130
00:04:16,400 --> 00:04:18,800
0,780 780,1080 1080,1500 1500,2040 2070,2400
reasonable simple programming language,| quite
|学起来很容易。

131
00:04:18,800 --> 00:04:20,270
0,570 570,690 690,1140 1140,1410 1410,1470
easy to learn.| And in
|这些想法，

132
00:04:20,270 --> 00:04:21,770
0,300 300,390 390,570 570,1050 1110,1500
fact you know ideas,| hopefully
|希望你在 Go 教程中感受到了，

133
00:04:21,770 --> 00:04:22,700
0,90 90,270 270,360 360,780 780,930
you've got that experience with

134
00:04:22,700 --> 00:04:24,200
0,360 360,960 960,1200 1200,1290 1290,1500
{in,Go} tutorial,| that I want
|你完成了 Go 教程，

135
00:04:24,200 --> 00:04:25,280
0,120 120,270 270,450 450,960 960,1080
you to Go tutorial,| you
|你就知道了 Go 的大部分。

136
00:04:25,280 --> 00:04:26,690
0,360 360,750 750,930 930,1020 1020,1410
mostly got most of Go.|
|

137
00:04:27,440 --> 00:04:29,810
0,600 900,1110 1110,1590 1590,1950 1950,2370
And then finally, {it,actually} have
最后，它有一个编译器，

138
00:04:29,810 --> 00:04:31,520
0,240 270,810 810,930 930,1050 1050,1710
a compiler,| so it's compiled,|
|所以它是编译的，|

139
00:04:32,200 --> 00:04:35,740
0,1500 1530,2250 2280,2730 2760,3420 3420,3540
unlike Python,| or {} you
与 Python 不同，|或者编译器产生可用的代码，

140
00:04:35,740 --> 00:04:37,690
0,210 210,870 870,1140 1140,1470 1470,1950
know actually the compiler produces

141
00:04:37,690 --> 00:04:39,070
0,270 270,540 540,960 960,1110 1110,1380
actually usable code,| so the
|所以运行时开销不是很大。

142
00:04:39,100 --> 00:04:40,690
0,420 420,840 840,960 960,1200 1200,1590
runtime overhead is not as

143
00:04:40,720 --> 00:04:43,900
0,450 1260,1710 2460,2820 2820,3120 3120,3180
large.| I guess sort of
|我想 6.824 使用 Go 的最后一个原因，

144
00:04:43,900 --> 00:04:45,310
0,90 90,420 420,720 720,1200 1200,1410
the final reason why {6.824

145
00:04:45,310 --> 00:04:46,480
0,150 150,330 330,480 480,870 870,1170
- - - -} in

146
00:04:46,480 --> 00:04:47,920
0,390 390,510 510,840 840,1170 1170,1440
Go,| {is,actually - -} I
|我很喜欢使用 Go 写程序，

147
00:04:47,920 --> 00:04:50,380
0,630 630,1050 1260,1620 1620,2190 2190,2460
enjoyed writing Go programs,| and
|这可能也是一个重要原因。

148
00:04:50,380 --> 00:04:51,730
0,210 210,420 420,570 570,960 960,1350
so that may be also

149
00:04:51,730 --> 00:04:53,540
0,90 90,450 450,780
an important reason.|
|

150
00:04:54,140 --> 00:04:55,490
0,570 780,960 960,1080 1080,1170 1170,1350
{} So what I'm gonna
所以我要做的是，

151
00:04:55,490 --> 00:04:56,420
0,330 330,690 690,750 750,870 870,930
do is,| I'm going to
|我将简单介绍一下线程和 RPC ，

152
00:04:56,420 --> 00:04:57,380
0,90 90,120 120,300 300,450 450,960
talk a little bit about

153
00:04:57,410 --> 00:04:58,700
0,240 240,300 300,780 780,930 930,1290
threads in general, {} RPC

154
00:04:58,700 --> 00:05:00,860
0,690 840,1410 1410,1980 1980,2100 2100,2160
{in,general},| {} and you know
|讨论一下使用线程编程的不同方面，

155
00:05:00,860 --> 00:05:02,000
0,210 210,240 240,450 450,630 630,1140
talk a little bit about

156
00:05:02,030 --> 00:05:04,640
0,1080 1110,1470 1470,1950 1950,2130 2130,2610
{} different aspects of programming

157
00:05:04,640 --> 00:05:06,320
0,600 930,1230 1230,1350 1350,1530 1530,1680
{with,threads},| some of that is
|其中一些是很好的教程，

158
00:05:06,320 --> 00:05:08,840
0,330 330,1110 1140,2160 2160,2340 2340,2520
pretty tutorial,| you have seen
|你在我[抱歉]之前见过的，

159
00:05:08,840 --> 00:05:10,820
0,120 120,780 960,1710 1710,1800 1800,1980
this before {} you know

160
00:05:10,820 --> 00:05:12,620
0,150 150,900 900,1290 1290,1470 1470,1800
my [apologies],| I'm gonna go
|我会很快介绍它，

161
00:05:12,620 --> 00:05:14,570
0,330 330,690 690,1170 1200,1620 1620,1950
reasonable quickly {through,it},| it's definitely
|它不是对并发编程的全面介绍，

162
00:05:14,570 --> 00:05:16,340
0,270 270,360 360,1170 1170,1650 1650,1770
not a comprehensive introduction to

163
00:05:16,340 --> 00:05:18,590
0,330 330,960 1230,1740 1740,2040 2040,2250
concurrent programming,| but hopefully enough
|但希望可以提醒你，

164
00:05:18,590 --> 00:05:19,910
0,120 120,480 480,960 990,1170 1170,1320
to remind you of| what
|问题是什么，以及你应该注意的是什么。

165
00:05:19,910 --> 00:05:21,410
0,60 60,450 450,840 870,1290 1290,1500
the issues are and what

166
00:05:21,410 --> 00:05:22,160
0,90 90,210 210,330 330,510 510,750
you should look out for.|
|

167
00:05:22,560 --> 00:05:23,700
0,480 480,600 600,840 840,1020 1020,1140
And we also spend some
我们还花了一些时间谈了不少关于爬虫的事情。

168
00:05:23,700 --> 00:05:24,930
0,510 510,1020 1020,1050 1050,1170 1170,1230
time quite a bit of

169
00:05:24,930 --> 00:05:26,320
0,150 150,300 300,360 360,810
talk about the crawler.|
|

170
00:05:26,520 --> 00:05:28,650
0,270 270,1020 1290,1530 1530,1800 1800,2130
And so I'll show you
所以我将向你们展示一个解决方案，我有两个解决方案，

171
00:05:28,650 --> 00:05:30,000
0,330 360,810 810,1080 1200,1230 1230,1350
a solution that I have

172
00:05:30,000 --> 00:05:31,500
0,150 150,600 600,840 840,1080 1080,1500
two solutions,| one using channels
|一个使用通道，另一个使用互斥锁

173
00:05:31,500 --> 00:05:33,240
0,120 120,300 300,780 780,1230 1230,1740
and ones using {mutexes -}|
|

174
00:05:33,360 --> 00:05:34,230
0,240 240,360 360,510 510,660 660,870
and we'll go through both
我们会把他们两个都检查一遍。

175
00:05:34,230 --> 00:05:35,060
0,60 60,300
of them.|
|

176
00:05:36,140 --> 00:05:37,400
0,210 210,510 510,660 660,960 960,1260
Any questions so far before
在我开始之前，有什么问题吗？

177
00:05:37,400 --> 00:05:39,180
0,270 420,900 900,1140
I dive in.|
|

178
00:05:44,920 --> 00:05:46,840
0,750 780,1200 1200,1440 1440,1650 1650,1920
Okay, when you get started
好的，当您开始使用线程时，

179
00:05:46,840 --> 00:05:48,120
0,120 120,660
with threads,|
|

180
00:05:50,050 --> 00:05:51,640
0,360 360,630 630,720 720,1080 1080,1590
so thread is basically shorthand
所以线程基本上是执行线程的简写，

181
00:05:51,640 --> 00:05:53,140
0,60 60,180 180,570 570,690 690,1500
for a thread of execution,|
|

182
00:05:57,360 --> 00:06:00,360
0,600 600,1170 1170,1860 1890,2700 2700,3000
{} in {} Go, thread
在围棋中，线被称为Goroutine，

183
00:06:00,360 --> 00:06:02,430
0,180 180,270 270,450 450,1080 1080,2070
called the {goroutine -},| but
|但其他人，基本上是世界上的每个人，都叫一根线

184
00:06:02,430 --> 00:06:03,600
0,300 300,660 660,870 870,1110 1110,1170
everybody else, basically in the

185
00:06:03,600 --> 00:06:05,130
0,360 360,780 780,1230 1230,1290 1290,1530
world Go, calls a thread

186
00:06:05,130 --> 00:06:06,600
0,30 30,420 1140,1290 1290,1410 1410,1470
of thread| and so the
|因此，思考这一问题的方法是，

187
00:06:06,600 --> 00:06:07,410
0,150 150,270 270,420 420,660 660,810
way to think about it

188
00:06:07,410 --> 00:06:09,570
0,210 210,420 420,780 780,1290 1410,2160
is that,| when you {}
|当你真的去跑步时，

189
00:06:09,600 --> 00:06:11,310
0,210 210,480 480,900 900,1170 1170,1710
do Go run,| {you,know} the
|你知道，Go会在你的操作系统上创建一个你知道的进程，

190
00:06:11,370 --> 00:06:13,050
0,480 480,750 750,990 990,1020 1020,1680
Go will create a process

191
00:06:13,080 --> 00:06:14,280
0,210 210,330 330,660 660,870 870,1200
you know on your operating

192
00:06:14,280 --> 00:06:15,300
0,630
system,|
|

193
00:06:15,480 --> 00:06:16,380
0,390 390,480 480,570 570,810 810,900
and in the sight of
在进程的视线中，你知道Go运行时系统，

194
00:06:16,380 --> 00:06:17,430
0,90 90,720 720,810 810,930 930,1050
{} process you know the

195
00:06:17,430 --> 00:06:19,680
0,240 240,630 630,1260
Go runtime system,|
|

196
00:06:19,860 --> 00:06:21,150
0,300 300,570 570,750 750,1170 1170,1290
and when Go start,| it
当开始的时候，|它实际上只有一个执行线程，即主线程

197
00:06:21,150 --> 00:06:22,170
0,300 300,450 450,690 690,930 930,1020
actually has one thread of

198
00:06:22,170 --> 00:06:24,360
0,630 630,720 720,990 990,1320 1620,2190
execution, the main thread| and
|然后它具有用于创建新线程的基元

199
00:06:24,360 --> 00:06:25,710
0,240 240,360 360,510 510,1260 1260,1350
then it has primitives to

200
00:06:25,710 --> 00:06:26,820
0,270 270,480 480,870 870,990 990,1110
create new threads| and so
|所以你可以想一想，

201
00:06:26,820 --> 00:06:27,660
0,120 120,270 270,450 450,690 690,840
you can think about this,|
|

202
00:06:27,660 --> 00:06:28,710
0,210 210,300 300,540 540,780 780,1050
those are many many threads
这些是许多许多执行的线索，

203
00:06:28,710 --> 00:06:30,180
0,90 90,900
of execution,|
|

204
00:06:30,180 --> 00:06:32,160
0,120 120,300 300,870 870,1320 1320,1980
you know running in parallel,|
你知道并行运行，|

205
00:06:32,460 --> 00:06:33,150
0,210 210,300 300,450 450,660 660,690
you can think about a
你可以认为单线程基本上是一种顺序运行的程序。

206
00:06:33,150 --> 00:06:34,470
0,360 360,720 720,810 810,1140 1140,1320
single thread is basically sort

207
00:06:34,470 --> 00:06:36,360
0,120 120,540 540,1050 1050,1500 1500,1890
of a sequential program running.|
|

208
00:06:36,920 --> 00:06:38,090
0,300 300,540 540,660 660,990 990,1170
{} So the program has
所以程序有一个程序计数器，

209
00:06:38,090 --> 00:06:40,520
0,540 570,900 900,1530 2010,2220 2220,2430
a program counter,| {} has
|有他自己的堆栈，

210
00:06:40,520 --> 00:06:42,120
0,150 150,300 300,990
his own stack,|
|

211
00:06:42,180 --> 00:06:43,140
0,360 360,510 510,660 660,810 810,960
and {} has his own
并且有他自己的一套登记簿。

212
00:06:43,140 --> 00:06:44,960
0,180 180,270 270,1050
set of registers.|
|

213
00:06:47,920 --> 00:06:48,910
0,180 180,270 270,480 480,870 870,990
And so this behaves like
因此，这就像一个顺序程序一样，

214
00:06:48,910 --> 00:06:50,680
0,60 60,450 450,1080 1410,1560 1560,1770
a sequential program,| you can
|你可以执行指令一和指令二，以及指令三和四，

215
00:06:51,400 --> 00:06:52,930
0,420 420,750 750,1050 1050,1170 1170,1530
execute instruction one and instruction

216
00:06:52,930 --> 00:06:54,250
0,270 270,510 510,810 810,1140 1140,1320
two, and instruction three and

217
00:06:54,250 --> 00:06:55,330
0,420 420,570 570,750 750,990 990,1080
four,| you may make a
|您可以让过程调用在堆栈上分配内存，

218
00:06:55,330 --> 00:06:56,890
0,420 420,780 780,1110 1110,1440 1440,1560
procedure call allocate memory on

219
00:06:56,890 --> 00:06:58,960
0,60 60,630 630,1080 1110,1680 1680,2070
the stack,| I'll return from
|我将从过程调用、递归调用、

220
00:06:58,960 --> 00:07:00,610
0,120 120,510 510,960 1020,1170 1170,1650
a procedure call, {} recursive

221
00:07:00,610 --> 00:07:01,720
0,480 510,720 720,900 900,990 990,1110
call,| all sort of your
|所有你的标准顺序调用编程，

222
00:07:01,720 --> 00:07:03,700
0,480 480,870 870,1200 1200,1770 1770,1980
standard sequence call programming,| just
|基本上就像一个顺序线程一样。

223
00:07:03,700 --> 00:07:05,020
0,180 180,570 570,1020 1020,1170 1170,1320
like happens about as a

224
00:07:05,020 --> 00:07:06,720
0,510 510,840 840,1260
sequential thread basically.|
|

225
00:07:07,980 --> 00:07:09,900
0,570 930,1140 1140,1590 1590,1740 1740,1920
{} The interesting thing is
有趣的是，您知道这些线程实际上可能与其他线程共享内存。

226
00:07:09,900 --> 00:07:10,980
0,210 210,300 300,450 450,720 750,1080
that, you know the threads

227
00:07:10,980 --> 00:07:13,260
0,150 150,510 510,870 870,1380 1770,2280
may actually share memory with

228
00:07:13,260 --> 00:07:14,680
0,300 300,810
other threads.|
|

229
00:07:15,940 --> 00:07:18,430
0,180 180,870 1140,1920 2160,2400 2400,2490
{} Since, {} all the
由于所有线程都在相同的地址空间中运行，

230
00:07:18,430 --> 00:07:19,150
0,240 240,330 330,570 570,660 660,720
threads are running in the

231
00:07:19,150 --> 00:07:20,950
0,240 240,540 540,1110 1200,1650 1650,1800
same address space,| {} the
|相同的操作系统地址空间，

232
00:07:20,950 --> 00:07:22,600
0,240 240,600 600,900 900,1170 1170,1650
same operating system address space,|
|

233
00:07:22,810 --> 00:07:23,800
0,210 210,270 270,390 390,570 570,990
which is the same process
其是相同的进程地址空间，

234
00:07:23,800 --> 00:07:25,510
0,270 270,810 990,1380 1380,1590 1590,1710
address space,| {} they can
|它们实际上可以共享内存，

235
00:07:25,510 --> 00:07:27,670
0,240 240,720 720,1470 1500,2010 2010,2160
actually share {} memory,| so
|所以一个线程可以写一个位置，比如你知道10

236
00:07:27,670 --> 00:07:29,350
0,210 210,480 480,660 660,1020 1020,1680
one thread can write a

237
00:07:29,530 --> 00:07:31,270
0,630 630,1020 1020,1140 1140,1260 1260,1740
location say you know 10|
|

238
00:07:31,480 --> 00:07:32,380
0,240 240,450 450,660 660,750 750,900
and then other {thread -}
然后其他线程可以实际读取该位置10，

239
00:07:32,380 --> 00:07:33,520
0,90 90,300 300,510 510,660 660,1140
can actually read that location

240
00:07:33,520 --> 00:07:34,720
0,300 480,630 630,840 840,1020 1020,1200
10,| so that way they
|这样他们才能真正交流信息。

241
00:07:34,720 --> 00:07:37,000
0,150 150,510 510,1140 1140,1740
can actually communicate information.|
|

242
00:07:37,390 --> 00:07:39,850
0,510 1410,1860 1860,2100 2100,2280 2280,2460
{} One way to think
考虑线程的一种方式也是

243
00:07:39,850 --> 00:07:41,980
0,750 750,1080 1200,1530 1530,1650 1650,2130
about {a,thread} too is| to
|将其视为运行库支持的某种抽象

244
00:07:41,980 --> 00:07:42,910
0,150 150,390 390,480 480,810 810,930
think about it as sort

245
00:07:42,910 --> 00:07:44,230
0,90 90,150 150,870 870,1080 1170,1320
of an abstraction that are

246
00:07:44,230 --> 00:07:46,630
0,630 630,1020 1020,1500 1620,2310 2310,2400
supported by the runtime| and
|并且运行时作为线程上的多个操作，

247
00:07:46,630 --> 00:07:47,500
0,90 90,450 450,570 570,630 630,870
the runtime as a number

248
00:07:47,500 --> 00:07:48,970
0,60 60,900 900,1080 1080,1140 1140,1470
of operations on a thread,|
|

249
00:07:48,970 --> 00:07:51,280
0,240 240,510 510,1260 1530,2160 2160,2310
so one operation, {} you
所以一个手术，你知道我们已经看过很多次了，

250
00:07:51,280 --> 00:07:52,480
0,210 210,420 420,630 630,840 840,1200
know we've seen many times,|
|

251
00:07:52,480 --> 00:07:53,350
0,210 210,360 360,540 540,660 660,870
if you've seen {you,know} many
如果您已经看到过多次实际启动创建线程的情况，

252
00:07:53,350 --> 00:07:54,610
0,420 420,540 540,720 720,1080 1080,1260
times to actually started for

253
00:07:54,760 --> 00:07:55,930
0,390 390,690 690,810 810,960 960,1170
create threads,| you know this
|你知道这是围棋语法，围棋键盘，

254
00:07:55,930 --> 00:07:58,510
0,210 210,750 1320,1620 1620,2040 2070,2580
is Go syntax, the Go

255
00:07:58,510 --> 00:08:01,390
0,750 780,1440 2070,2550 2550,2760 2760,2880
{} keyboard,| {} thread can
|线程可以退出，

256
00:08:01,390 --> 00:08:02,480
0,540
exit,|
|

257
00:08:03,310 --> 00:08:05,410
0,540 540,900 900,1470 1470,1590 1590,2100
generally, this means the []
通常，这意味着[]可以隐含，

258
00:08:05,410 --> 00:08:06,460
0,300 300,540 540,720 720,840 840,1050
can {implicit -},| like when
|就像当一个线程从这里返回时，

259
00:08:06,460 --> 00:08:08,710
0,60 60,360 360,1050 1140,1200 1200,2250
a thread returns { -}

260
00:08:08,740 --> 00:08:12,190
0,210 210,420 420,840 2520,3060 3090,3450
from this,| {} if you
|如果您创建一个函数，

261
00:08:12,190 --> 00:08:13,210
0,210 210,420 420,780 780,870 870,1020
create a function,| you can
|你可以去围棋关键字，

262
00:08:13,210 --> 00:08:15,490
0,480 480,720 720,1350 1350,1890 1890,2280
Go {} go keyword,| and
|当你从函数中返回时，

263
00:08:15,490 --> 00:08:16,420
0,300 300,600 600,750 750,810 810,930
you return out of the

264
00:08:16,420 --> 00:08:18,580
0,420 420,780 780,1440 1650,2070 2070,2160
function,| then implicitly the thread
|则该线程隐式退出，

265
00:08:18,580 --> 00:08:21,220
0,600 1140,1560 1710,2040 2040,2400 2400,2640
exits,| {} Go runtime also
|Go Runtime也有几个其他的Under of the Hands操作，

266
00:08:21,220 --> 00:08:22,900
0,180 180,240 240,510 510,1380 1380,1680
has a couple other of

267
00:08:22,900 --> 00:08:24,310
0,210 210,300 300,570 570,1290 1290,1410
under the hoods operations,| if
|如果你愿意，它实际上可以停止一个线程。

268
00:08:24,310 --> 00:08:25,720
0,120 120,510 600,1230 1230,1320 1320,1410
you will, one it can

269
00:08:25,720 --> 00:08:27,180
0,240 240,600 600,630 630,1080
actually stop a thread.|
|

270
00:08:27,580 --> 00:08:28,660
0,60 90,570 570,750 750,840 840,1080
For example, if a thread
例如，如果线程向通道写入数据，而该通道上还没有读取器，

271
00:08:28,660 --> 00:08:31,210
0,330 330,870 870,1350 1350,2040 2040,2550
writes to a channel and

272
00:08:31,210 --> 00:08:32,080
0,180 180,390 390,720 720,810 810,870
there's no reader on the

273
00:08:32,080 --> 00:08:33,610
0,360 360,660 660,1230 1230,1320 1320,1530
channel yet,| then the thread
|则该线程可能会被阻塞

274
00:08:33,610 --> 00:08:35,500
0,450 450,660 660,1170 1410,1770 1770,1890
might get blocked| and so
|因此GO运行时停止该线程，

275
00:08:35,500 --> 00:08:36,880
0,90 90,300 300,720 720,1290 1290,1380
the Go runtime stops the

276
00:08:36,880 --> 00:08:39,220
0,450 480,930 930,1140 1140,1710 2100,2340
thread,| puts its side,| so
|把它放在一边，|所以它实际上可以在处理器上运行另一个线程，

277
00:08:39,220 --> 00:08:40,240
0,240 240,330 330,570 570,750 750,1020
it can actually run another

278
00:08:40,240 --> 00:08:42,820
0,360 360,990 990,1080 1080,1710 2130,2580
thread on the processor, {}|
|

279
00:08:42,820 --> 00:08:44,290
0,330 330,450 450,750 750,1050 1050,1470
and then maybe later on
然后，也许稍后再继续这个帖子，

280
00:08:44,290 --> 00:08:47,200
0,420 420,660 660,930 930,1380 1470,2910
resume that thread,| so a
|因此，实际上为我们恢复了第三个原语。

281
00:08:47,200 --> 00:08:49,030
0,330 330,960 960,1290 1290,1530 1530,1830
third primitive actually is resumed

282
00:08:49,030 --> 00:08:49,780
0,150 150,450
for us.|
|

283
00:08:50,110 --> 00:08:50,890
0,210 210,360 360,480 480,570 570,780
And really what it means
而停止恢复线程的真正含义是

284
00:08:50,890 --> 00:08:51,970
0,90 90,420 420,750 750,960 960,1080
to stop resume thread is|
|

285
00:08:51,970 --> 00:08:53,080
0,360 360,660 660,750 750,1050 1050,1110
basically taking the state of
基本上是根据线程的状态，

286
00:08:53,080 --> 00:08:54,100
0,120 120,450 450,570 570,690 690,1020
the thread,| like the program
|像程序计数器堆栈指针和寄存器一样，

287
00:08:54,100 --> 00:08:56,380
0,600 930,1350 1350,1980 2070,2220 2220,2280
counter stack pointer and the

288
00:08:56,380 --> 00:08:59,470
0,390 390,780 780,1470 1800,2460 2460,3090
register,| {put,it} {on,the,side},| run another
|把它放在一边，|在处理器上运行另一个线程

289
00:08:59,650 --> 00:09:01,150
0,270 270,360 360,450 450,1050 1320,1500
thread on the processor| and
|然后在某个时候，你决定恢复这个过程

290
00:09:01,150 --> 00:09:02,140
0,150 150,240 240,390 390,870 870,990
then at some point you

291
00:09:02,140 --> 00:09:03,520
0,450 450,570 570,870 870,960 960,1380
decided to resume the process|
|

292
00:09:03,520 --> 00:09:04,840
0,180 180,450 450,900 900,1230 1230,1320
which means basically loading the
这意味着基本上将程序计数器堆栈指针和寄存器加载回处理器，

293
00:09:04,840 --> 00:09:06,430
0,330 330,780 780,960 960,1500 1500,1590
program counter stack pointer and

294
00:09:06,430 --> 00:09:07,540
0,90 90,480 480,810 810,990 990,1110
the registers back into the

295
00:09:07,540 --> 00:09:08,890
0,480 480,690 690,870 990,1290 1290,1350
processor,| so they start to
|所以他们开始运行它。

296
00:09:08,890 --> 00:09:09,580
0,150 150,270
run it.|
|

297
00:09:10,260 --> 00:09:11,100
0,270 270,480 480,600 600,690 690,840
So that's sort of a
这是对线的一种非常机械的看法。

298
00:09:11,100 --> 00:09:14,010
0,270 270,750 750,1440 1740,2100 2100,2910
very mechanical view of {}

299
00:09:14,010 --> 00:09:19,120
0,510
{what,thread,is}.|
|

300
00:09:19,180 --> 00:09:20,770
0,180 180,450 450,690 690,1020 1020,1590
So why you have threads
那么为什么你一开始就有线程呢？

301
00:09:20,770 --> 00:09:21,880
0,120 120,180 180,450 450,840 960,1110
in the first place| that
|这似乎是一个值得讨论的重要问题。

302
00:09:21,880 --> 00:09:22,960
0,240 240,420 420,480 480,840 840,1080
seems like an important point

303
00:09:22,960 --> 00:09:24,900
0,390 420,1260
to discuss.|
|

304
00:09:26,010 --> 00:09:27,360
0,90

305
00:09:28,110 --> 00:09:29,160
0,270 270,330 330,540 540,930 930,1050
Because in some ways, the
因为在某些方面，线程唯一能做的就是，

306
00:09:29,160 --> 00:09:30,990
0,360 360,630 630,630 1230,1680 1680,1830
{only,thing} threads do is,| make
|让你作为程序员的生活变得更加复杂。

307
00:09:30,990 --> 00:09:32,130
0,90 90,300 300,480 480,1020 1020,1140
your life more complicated as

308
00:09:32,130 --> 00:09:33,300
0,60 60,630
a programmer.|
|

309
00:09:33,660 --> 00:09:34,830
0,120 120,300 300,540 540,750 750,1170
You know, like writing sequential
你知道，就像编写顺序代码实际上比编写并行代码更容易一样，

310
00:09:34,830 --> 00:09:36,030
0,300 300,390 390,630 630,840 840,1200
code is actually {} easier

311
00:09:36,030 --> 00:09:37,890
0,180 180,420 420,750 750,1080 1500,1860
than writing parallel code,| the
|拥有它的主要原因是，

312
00:09:37,890 --> 00:09:38,940
0,240 240,480 480,570 570,840 840,1050
main reason to have it,|
|

313
00:09:39,500 --> 00:09:40,400
0,90 90,420 420,600 600,690 690,900
the main reason we care
在6.824中，我们非常关心的主要原因是表示并发性。

314
00:09:40,400 --> 00:09:41,930
0,60 60,210 210,420 420,930 930,1530
a lot about in {}

315
00:09:42,350 --> 00:09:44,940
0,1020 1020,1170 1170,1320 1320,2040
6.824 is to express

316
00:09:45,030 --> 00:09:46,400
0,540 540,720
{concurrency -}.|
|

317
00:09:49,890 --> 00:09:51,210
0,150 150,300 300,420 420,990 990,1320
And sort of three different
以及我们真正关心的三种不同类型或两三种不同类型的并发性，

318
00:09:51,210 --> 00:09:52,830
0,300 300,570 570,1050 1050,1380 1380,1620
types or two or three

319
00:09:52,830 --> 00:09:53,910
0,240 240,450 450,510 510,960 960,1080
different types of concurrency that

320
00:09:53,910 --> 00:09:54,900
0,90 90,300 300,540 540,810 810,990
we actually care about,| so
|因此，我们思考我们的过程，

321
00:09:54,900 --> 00:09:57,210
0,270 300,510 510,780 780,1050 1470,2310
we think about our process,|
|

322
00:09:57,210 --> 00:09:58,950
0,240 270,480 480,600 600,1230 1500,1740
we are in time with
我们的线程运行得很及时，

323
00:09:58,950 --> 00:10:00,560
0,210 210,480 480,1110
our thread running,|
|

324
00:10:00,560 --> 00:10:02,060
0,510 510,630 630,720 720,1230 1230,1500
{} you know one type
您知道，我们非常关心的一种并发类型是IO并发。

325
00:10:02,060 --> 00:10:02,900
0,60 60,480 480,570 570,660 660,840
of concurrency that we care

326
00:10:02,900 --> 00:10:03,860
0,60 60,240 240,540 540,690 690,960
a lot about is IO

327
00:10:03,860 --> 00:10:06,100
0,600
concurrency.|
|

328
00:10:08,740 --> 00:10:10,030
0,210 210,510 510,600 600,780 780,1290
So one of these threads
所以在这里运行的其中一个线程，

329
00:10:10,030 --> 00:10:11,770
0,450 450,750 750,1260 1350,1560 1560,1740
that running here,| it might
|它实际上可能使网络调用连接到网络上的另一台计算机，

330
00:10:11,770 --> 00:10:13,030
0,300 300,510 510,540 540,900 900,1260
actually make a network call

331
00:10:13,390 --> 00:10:15,220
0,360 360,990 990,1260 1260,1710 1710,1830
connect to another machine on

332
00:10:15,220 --> 00:10:16,900
0,90 90,600 900,1440 1440,1560 1560,1680
the network,| {} {you,know} to
|您知道要实现分布式应用程序

333
00:10:16,900 --> 00:10:18,940
0,360 360,390 390,810 810,1620 1830,2040
implement a distributed application| of
|就像MapReduce一样，

334
00:10:18,940 --> 00:10:21,400
0,180 180,390 390,930 1140,1770 1770,2460
like {mapreduce -},| {} and
|你知道，当它打出一个电话时，

335
00:10:21,400 --> 00:10:22,390
0,180 180,360 360,660 660,780 780,990
you know as it makes

336
00:10:22,390 --> 00:10:23,920
0,150 150,870 900,1350 1350,1440 1440,1530
up a call,| you know
|你知道它会被封锁，等待回复

337
00:10:23,920 --> 00:10:25,240
0,120 120,270 270,420 420,900 930,1320
it's gonna be blocked waiting

338
00:10:25,240 --> 00:10:26,410
0,120 120,150 150,810 840,960 960,1170
for a response| and why
|以及为什么它被屏蔽了，他们在等待回应，

339
00:10:26,410 --> 00:10:27,490
0,150 150,570 570,660 660,780 780,1080
it's blocked and they're waiting

340
00:10:27,490 --> 00:10:28,990
0,150 150,240 240,840 990,1380 1380,1500
for a response,| everything you
|实际运行一些其他线程所需的一切。

341
00:10:28,990 --> 00:10:30,160
0,420 420,570 570,810 810,1020 1020,1170
need to actually run some

342
00:10:30,160 --> 00:10:31,160
0,150 150,720
other threads.|
|

343
00:10:31,340 --> 00:10:33,470
0,420 420,570 570,750 750,1380 1920,2130
{} So that we're sort
所以我们可以说给予了更多，

344
00:10:33,470 --> 00:10:34,610
0,120 120,360 360,630 630,870 870,1140
of give more,| we're done
|例如，我们要发出多个请求和多台机器，大致并行，

345
00:10:34,610 --> 00:10:35,600
0,180 180,600 600,720 720,930 930,990
for example, we want to

346
00:10:35,600 --> 00:10:37,250
0,330 330,750 750,1140 1140,1230 1230,1650
issue multiple requests and multiple

347
00:10:37,250 --> 00:10:39,980
0,630 990,1380 1470,1980 1980,2640 2640,2730
machines, {} roughly parallel,| you
|你知道，我们可以只用一只猩猩就能做到这一点

348
00:10:39,980 --> 00:10:40,670
0,180 180,300 300,450 450,600 600,690
know we could just do

349
00:10:40,670 --> 00:10:41,930
0,210 210,300 300,690 690,930 930,1260
that with fire off one

350
00:10:41,930 --> 00:10:43,130
0,150 150,630 630,900 900,990 990,1200
{goroutine -}| and the fire
|和另一个大猩猩的火，大猩猩，所有发出的

351
00:10:43,130 --> 00:10:44,300
0,90 90,420 420,840 840,930 930,1170
in another goroutine, {} {goroutine

352
00:10:44,300 --> 00:10:45,380
0,270 270,420 420,900 900,1020 1020,1080
-} that all kind of

353
00:10:45,380 --> 00:10:46,700
0,420 540,660 660,810 810,1230 1230,1320
sent| and make connections to
|并连接到其他远程计算机。

354
00:10:46,700 --> 00:10:48,220
0,330 330,510 510,1020
other remote machines.|
|

355
00:10:48,810 --> 00:10:49,710
0,270 270,480 480,750 750,780 780,900
That's one reason {we -}
这是我们非常关心它的原因之一，IO并发性。

356
00:10:49,710 --> 00:10:50,580
0,180 180,240 240,420 420,660 660,870
care a lot about it,

357
00:10:51,210 --> 00:10:52,800
0,600 600,1020 1020,1140 1140,1380 1380,1590
IO concurrency.| The second reason
|我们关心的第二个原因是允许多核并行。

358
00:10:52,800 --> 00:10:54,000
0,90 90,150 150,360 360,720 720,1200
that we care about is

359
00:10:54,000 --> 00:10:55,290
0,90 90,210 210,600 600,780 780,1290
you know allows for {multi-core

360
00:10:55,290 --> 00:10:57,140
0,270 270,840
-} parallelism.|
|

361
00:11:03,310 --> 00:11:04,900
0,300 300,540 540,930 930,1170 1170,1590
So we have a multiple
所以我们有一个多核系统，

362
00:11:04,900 --> 00:11:06,430
0,630 630,780 780,900 900,1380 1410,1530
cores,| you know our you
|你知道我们的计算机或处理器，

363
00:11:06,430 --> 00:11:09,910
0,360 1320,1860 1860,1950 1950,2670 2760,3480
know computer or processor,| then
|然后我们可以运行一个线程，

364
00:11:09,910 --> 00:11:11,500
0,90 90,210 210,570 570,1170 1170,1590
we can have one thread

365
00:11:11,500 --> 00:11:12,820
0,270 270,480 480,780 780,960 960,1320
running on,| one {goroutine -}
|一个在一个核心上运行的Goroutine

366
00:11:12,820 --> 00:11:14,170
0,240 240,330 330,600 600,1080 1200,1350
running on one core| and
|和运行在另一个内核上的另一个线程或另一个Goroutine，

367
00:11:14,170 --> 00:11:15,460
0,270 270,720 720,870 870,1110 1110,1290
another thread or another {goroutine

368
00:11:15,460 --> 00:11:16,690
0,360 360,570 570,660 660,960 960,1230
-} running on another core,|
|

369
00:11:16,690 --> 00:11:18,440
0,270 270,720 720,1260
just {straight,in} parallel.|
只是直线平行。|

370
00:11:18,440 --> 00:11:19,790
0,240 240,330 330,690 690,1020 1020,1350
And for example we implement
例如，我们实现了密钥值服务器，

371
00:11:19,790 --> 00:11:21,380
0,300 300,480 480,810 810,1320 1320,1590
a {key-value -} servers,| then
|然后我们可以处理对不同密钥的请求

372
00:11:21,380 --> 00:11:23,540
0,120 120,300 300,960 960,1530 1560,2160
we could process {} request

373
00:11:23,540 --> 00:11:24,560
0,90 90,360 360,690 690,840 840,1020
for different keys| and {key-value
|并且Key-Value服务器在不同的核心上完全并行使用，

374
00:11:24,560 --> 00:11:26,030
0,330 330,720 720,990 990,1170 1170,1470
-} servers use on different

375
00:11:26,030 --> 00:11:28,430
0,270 270,690 690,1230 1230,2010 2010,2400
cores completely parallel,| increasing our
|增加我们的吞吐量。

376
00:11:28,760 --> 00:11:30,020
0,750
throughput.|
|

377
00:11:30,440 --> 00:11:31,430
0,150 150,450 450,720 720,780 780,990
So those are the two
这是我们非常关心并发性的两个主要原因，

378
00:11:31,430 --> 00:11:32,480
0,300 300,630 630,720 720,840 840,1050
main reasons that we care

379
00:11:32,480 --> 00:11:34,730
0,60 60,390 420,870 870,1320 1470,2250
a lot about {} concurrency,|
|

380
00:11:35,180 --> 00:11:36,800
0,570 570,930 930,1380 1380,1530 1530,1620
but threads, there's sort of
但是线程，还有第三个原因

381
00:11:36,800 --> 00:11:38,030
0,60 60,390 390,870 870,990 990,1230
a third reason| and there's
|而且也有一点方便。

382
00:11:38,030 --> 00:11:39,470
0,120 120,420 420,540 540,630 630,1440
a little bit of convenience.|
|

383
00:11:43,840 --> 00:11:45,100
0,240 240,390 390,510 510,870 870,1260
There's gonna be numerous cases
实验室里会有很多案例，

384
00:11:45,100 --> 00:11:45,910
0,90 90,180 180,450 450,510 510,810
in the lab,| for example
|例如，我们希望定期发生一些事情，

385
00:11:45,910 --> 00:11:48,310
0,240 240,360 360,810 1020,1950 1980,2400
where we wanna {} have

386
00:11:48,310 --> 00:11:50,380
0,270 270,630 630,1350 1410,1830 1830,2070
something happened periodically,| maybe every
|可能每隔一秒或每两毫秒

387
00:11:50,380 --> 00:11:51,610
0,420 450,660 660,900 900,1110 1110,1230
second or every two in

388
00:11:51,610 --> 00:11:53,440
0,780 840,1350 1440,1650 1650,1740 1740,1830
milliseconds| and now we can
|现在我们只需为此启动一个线程或围棋例程，

389
00:11:53,440 --> 00:11:54,640
0,270 270,630 630,690 690,990 990,1200
just launch a thread or

390
00:11:54,640 --> 00:11:55,630
0,150 150,360 360,690 690,780 780,990
a go routine for that,|
|

391
00:11:55,630 --> 00:11:57,370
0,300 300,360 360,690 690,810 810,1740
there's a sleep for {200,milliseconds,}|
有200毫秒的睡眠|

392
00:11:57,370 --> 00:11:58,060
0,180 180,360 360,450 450,510 510,690
it does what it needs
它做它需要做的事情

393
00:11:58,060 --> 00:11:58,930
0,90 90,450 450,570 570,780 780,870
to do| and then it
|然后它回到休眠状态200毫秒，

394
00:11:58,930 --> 00:11:59,800
0,180 180,390 390,480 480,750 750,870
goes back to sleep for

395
00:11:59,800 --> 00:12:02,200
0,990 1260,1500 1500,1650 1650,2100 2100,2400
{200,milliseconds},| so it's convenient to
|所以有这些后台活动是很方便的，

396
00:12:02,230 --> 00:12:05,020
0,360 360,690 1410,2070 2070,2640 2640,2790
have these background activities,| that
|这需要定期完成，

397
00:12:05,020 --> 00:12:06,310
0,150 150,210 210,330 330,540 540,1290
need to be done periodically,|
|

398
00:12:06,310 --> 00:12:07,210
0,150 150,240 240,360 360,720 720,900
and you can express that
你可以用线程来表达这一点

399
00:12:07,210 --> 00:12:08,560
0,450 630,990 990,1080 1080,1290 1290,1350
using threads,| of course you
|当然你可以用其他方式来表达，这些线索实际上是很方便的。

400
00:12:08,560 --> 00:12:09,250
0,90 90,360 360,450 450,540 540,690
can express it in other

401
00:12:09,250 --> 00:12:10,630
0,300 300,390 390,630 630,750 750,1380
ways, the threads are actually

402
00:12:10,840 --> 00:12:11,780
0,600
convenient.|
|

403
00:12:13,200 --> 00:12:14,640
0,390 390,750 750,870 870,1050 1050,1440
Another question that comes up
另一个经常出现的问题是，

404
00:12:14,670 --> 00:12:16,230
0,540 540,870 870,1140 1140,1350 1350,1560
often in,| I think came
|我想我想出了一些讲座问题，

405
00:12:16,230 --> 00:12:16,800
0,120 120,240 240,390 390,510 510,570
up with some of the

406
00:12:16,800 --> 00:12:18,210
0,360 360,810 810,990 990,1230 1230,1410
lecture questions,| so today look
|所以今天看看你创造了多少线索。

407
00:12:18,210 --> 00:12:18,990
0,120 120,300 300,630 630,690 690,780
how many threads {} you

408
00:12:18,990 --> 00:12:20,100
0,540
create.|
|

409
00:12:20,100 --> 00:12:21,270
0,210 210,210 210,750 750,870 870,1170
And I think the gold
我认为金色的设计或者他们想要你思考的方式是

410
00:12:21,270 --> 00:12:22,380
0,420 420,570 660,870 870,1020 1020,1110
design or the way they

411
00:12:22,380 --> 00:12:23,250
0,270 270,360 360,450 450,630 630,870
want you to think about

412
00:12:23,250 --> 00:12:24,030
0,150 150,300 300,510 510,600 600,780
it is| that you should
|您应该根据需要创建尽可能多的线程，

413
00:12:24,030 --> 00:12:24,900
0,240 240,360 360,570 570,780 780,870
create as many threads as

414
00:12:24,900 --> 00:12:26,910
0,120 120,480 630,1260 1440,1650 1650,2010
you need,| {} they're definitely
|当它们占用一些内存时，它们肯定不是空闲的，

415
00:12:26,910 --> 00:12:28,170
0,270 270,630 660,870 870,990 990,1260
not free when they tie

416
00:12:28,170 --> 00:12:29,310
0,150 150,270 270,810 810,1050 1050,1140
up some memory,| because you're
|因为你会有一堆东西，

417
00:12:29,310 --> 00:12:30,510
0,120 120,210 210,630 630,690 690,1200
going to have a stack,|
|

418
00:12:30,840 --> 00:12:33,090
0,480 480,990 990,1530 1530,1800 1830,2250
there's performance overhead we're starting
我们正在启动它们，这会带来性能开销，

419
00:12:33,090 --> 00:12:34,590
0,360 600,900 900,1080 1080,1320 1320,1500
them,| {} but there's you
|但有一点你应该认为它们非常轻，

420
00:12:34,590 --> 00:12:35,550
0,300 300,480 480,720 720,840 840,960
should think about them as

421
00:12:35,550 --> 00:12:37,950
0,270 270,930 1020,1680 1680,2160 2160,2400
very lightweight,| {} also you
|另外，你应该鼓励你，否则你会被鼓励在你前进的过程中创建主题。

422
00:12:37,950 --> 00:12:39,210
0,150 150,270 270,930 930,1110 1110,1260
should be encouraging or you're

423
00:12:39,210 --> 00:12:40,980
0,450 450,540 540,900 900,1410 1440,1770
encouraged to create {} threads

424
00:12:40,980 --> 00:12:41,900
0,120 120,210 210,450
as you go.|
|

425
00:12:43,640 --> 00:12:45,590
0,690 720,1470 1470,1710 1710,1860 1860,1950
Any questions about sort of
关于为什么要有帖子的这个基本原因，有什么问题吗？

426
00:12:45,590 --> 00:12:47,360
0,330 360,1050 1050,1320 1320,1650 1650,1770
this basic reason why to

427
00:12:47,360 --> 00:12:48,560
0,180 180,720
have threads?|
|

428
00:12:55,060 --> 00:12:56,470
0,270 270,420 420,660 660,990 990,1410
Okay, let me, {} then
好的，让我，你知道，就像我之前提到的，

429
00:12:56,590 --> 00:12:58,090
0,150 150,540 630,960 960,1080 1080,1500
you know as I mentioned

430
00:12:58,090 --> 00:13:00,790
0,1080 1110,1380 1380,1890 1890,2100 2100,2700
earlier,| threads actually have challenges,|
|线程实际上面临着挑战，|

431
00:13:03,350 --> 00:13:05,390
0,660 660,1080 1080,1230 1230,1800 1920,2040
programming {with,threads} has challenges,| so
使用线程进行编程具有挑战性，|所以，让我来谈谈这些挑战。

432
00:13:05,390 --> 00:13:06,110
0,120 120,210 210,450 450,510 510,720
let me talk a little

433
00:13:06,110 --> 00:13:07,780
0,120 120,300 300,390 390,960
bit about the challenges.|
|

434
00:13:07,780 --> 00:13:08,500
0,150 150,270 270,390 390,450 450,720
I'm not going to go
我不打算在这里深入探讨，

435
00:13:08,500 --> 00:13:10,210
0,240 240,480 480,690 780,1230 1230,1710
great amount of depth here,|
|

436
00:13:10,210 --> 00:13:11,650
0,330 330,690 690,1140 1140,1320 1320,1440
I I assume that you
我想你知道他们都说得通

437
00:13:11,650 --> 00:13:12,670
0,120 120,420 420,600 660,900 900,1020
know there's a they all

438
00:13:12,670 --> 00:13:13,870
0,180 180,510 510,720 720,960 960,1200
make sense| and will become
|如果我们看一些例子，就会变得更清楚

439
00:13:13,870 --> 00:13:14,860
0,150 150,480 480,570 570,810 810,990
more clear if we look

440
00:13:14,860 --> 00:13:16,000
0,180 180,330 330,390 390,480 480,1140
at some of the examples|
|

441
00:13:16,570 --> 00:13:18,580
0,180 180,510 510,810 810,1440 1440,2010
and probably the main reason
你了解线程并具有挑战性的主要原因可能是

442
00:13:18,700 --> 00:13:20,200
0,450 450,810 810,930 930,1110 1110,1500
{} that you know threads

443
00:13:20,200 --> 00:13:21,520
0,120 120,510 510,1020 1020,1170 1170,1320
and you're challenging is that|
|

444
00:13:21,520 --> 00:13:22,660
0,60 60,180 180,330 330,540 540,1140
you can have race conditions.|
你可以有比赛条件。|

445
00:13:30,890 --> 00:13:31,850
0,180 180,360 360,510 510,630 630,960
And just like a basic
就像种族状况的一个基本例子一样，

446
00:13:31,850 --> 00:13:34,160
0,780 810,1560 1560,2010 2010,2160 2160,2310
example {of,race} condition,| let's say
|假设你有两条线，

447
00:13:34,160 --> 00:13:35,390
0,120 120,390 390,600 600,1140 1140,1230
you have two threads,| you
|你知道，这是T1，这是T2，

448
00:13:35,390 --> 00:13:37,120
0,90 90,450 450,630 630,1140
know, here's {t1 -},

449
00:13:37,440 --> 00:13:39,240
0,270 270,510 510,1170
here's {t2 -},|
|

450
00:13:39,240 --> 00:13:41,370
0,1170 1200,1380 1380,1620 1620,1680 1680,2130
and they share {} variable
它们共享变量n，

451
00:13:41,370 --> 00:13:42,750
0,510 540,810 810,930 930,1080 1080,1380
n,| let's say the initial
|假设初始值为0，

452
00:13:42,750 --> 00:13:44,540
0,480 480,1200
value 0,|
|

453
00:13:45,390 --> 00:13:47,670
0,510 510,810 810,1080 1080,1800 1830,2280
and they both execute, {you,know}
它们都执行，你们都知道，EXECUTE语句，你们知道的形式相加，n加1。

454
00:13:47,670 --> 00:13:49,410
0,150 150,570 570,1200 1200,1320 1320,1740
both execute statement, the form

455
00:13:49,410 --> 00:13:51,420
0,90 90,210 210,720 1200,1500 1500,2010
you know adds, the increment

456
00:13:51,420 --> 00:13:52,660
0,150 150,270 270,660
n by 1.|
|

457
00:13:53,020 --> 00:13:53,830
0,120 120,240 240,570 570,660 660,810
And of course you might
当然，你可能会认为这句话是原子操作，或者是不可分割的东西，

458
00:13:53,830 --> 00:13:54,790
0,180 180,330 330,750 750,870 870,960
think that statement is an

459
00:13:54,790 --> 00:13:56,650
0,390 390,930 930,1350 1380,1710 1710,1860
atomic operation or something that

460
00:13:56,650 --> 00:13:57,880
0,90 90,660 660,780 780,900 900,1230
is indivisible,| but it isn't,|
|但事实并非如此，|

461
00:13:57,940 --> 00:13:59,350
0,60 60,600 660,960 960,1170 1170,1410
I mean there's a Go
我的意思是有一条GO语句已经编译成处理器正在执行的任何指令，

462
00:13:59,350 --> 00:14:01,600
0,360 360,660 660,1500 1500,1620 1620,2250
statement has compiled to whatever

463
00:14:01,720 --> 00:14:03,640
0,660 660,750 750,1110 1110,1170 1170,1920
instructions the processor is executing,|
|

464
00:14:04,030 --> 00:14:05,320
0,210 210,300 300,600 600,930 930,1290
so we cannot assume that
所以我们不能假设原子指令

465
00:14:05,320 --> 00:14:06,490
0,150 150,510 510,990 990,1110 1110,1170
an atomic instruction| and in
|事实上，你知道，它可能基本上是由一个负载组成的，

466
00:14:06,490 --> 00:14:07,300
0,330
fact,

467
00:14:07,300 --> 00:14:08,980
0,60 60,660 660,1020 1170,1560 1560,1680
you know, it's, {} it

468
00:14:08,980 --> 00:14:10,060
0,180 180,540 540,600 600,900 900,1080
could consist of basically like

469
00:14:10,060 --> 00:14:11,650
0,60 60,660 690,780 780,1200 1200,1590
a load,| you know which
|你知道哪一个存储了n，n的内容被寄存器，一个递增寄存器

470
00:14:12,400 --> 00:14:13,780
0,420 420,570 570,870 870,1020 1020,1380
stores the n, the content

471
00:14:13,780 --> 00:14:15,310
0,90 90,450 450,690 690,1410 1410,1530
of n to register, an

472
00:14:15,310 --> 00:14:16,720
0,390 390,870 870,960 960,1170 1170,1410
increment register| and then {you,know}
|然后你知道的，就像是注册回到了记忆中。

473
00:14:16,720 --> 00:14:17,860
0,180 180,270 270,660 660,960 960,1140
sort of register back into

474
00:14:17,860 --> 00:14:19,020
0,360
memory.|
|

475
00:14:19,220 --> 00:14:20,810
0,210 210,300 300,540 540,960 960,1590
So if you're very unlucky,|
所以如果你非常不走运，|

476
00:14:20,900 --> 00:14:22,040
0,150 150,360 360,540 540,750 750,1140
you know the two threads
你知道，这两个线程基本上都试图执行这条特定的指令，

477
00:14:22,040 --> 00:14:23,750
0,330 330,630 630,720 720,1140 1170,1710
basically try to, {} both

478
00:14:23,750 --> 00:14:25,700
0,450 450,600 600,900 900,1560 1740,1950
execute this particular instruction,| then
|然后我们就可以有一个非常不幸的事件序列

479
00:14:25,700 --> 00:14:26,780
0,120 120,210 210,420 420,510 510,1080
we can have a very

480
00:14:26,780 --> 00:14:28,190
0,120 120,360 360,1050 1050,1350 1350,1410
you know unfortunate sequence of

481
00:14:28,190 --> 00:14:30,050
0,450 450,900 1020,1440 1440,1740 1740,1860
events| where like both {threads
|其中，就像您知道的两个线程执行加载指令一样，

482
00:14:30,050 --> 00:14:31,000
0,390
-}

483
00:14:31,000 --> 00:14:31,780
0,60 60,150 150,510 510,540 540,780
you know perform the load

484
00:14:31,780 --> 00:14:33,040
0,690
instruction,|
|

485
00:14:34,380 --> 00:14:37,350
0,750 750,1200 1200,1620 1890,2430 2430,2970
load variable in {you,know} register
在你知道的寄存器中加载变量，比如r0，你知道这里也是r0，

486
00:14:37,350 --> 00:14:39,450
0,150 150,330 330,540 540,1230 1320,2100
let's say {r0 -}, {you,know,here}

487
00:14:39,450 --> 00:14:41,100
0,330 330,510 510,1110
{also,in} {r0 -},|
|

488
00:14:42,570 --> 00:14:44,130
0,270 270,420 420,1080 1080,1410 1410,1560
{you,know} the increment so {r0
你知道增量，所以R0变成1，1，

489
00:14:44,130 --> 00:14:45,960
0,300 300,660 660,1260
-} becomes 1,

490
00:14:46,790 --> 00:14:49,130
0,660 1200,1440 1440,2040 2040,2250 2250,2340
1,| and then write it
|然后把它写回你知道的存储指令，把结果写回到内存中的变量n中。

491
00:14:49,130 --> 00:14:51,710
0,510 720,1320 1380,1500 1500,1890 2250,2580
back to you know store

492
00:14:51,710 --> 00:14:54,350
0,540 540,870 870,1470 1800,2340 2340,2640
instruction that results results back

493
00:14:54,350 --> 00:14:56,120
0,240 240,300 300,750 750,960 1080,1770
into the {variable,n} in memory.|
|

494
00:14:56,960 --> 00:14:58,670
0,450 900,1230 1230,1410 1410,1560 1560,1710
And, {} so, if this
因此，如果在这种情况下发生这种情况，

495
00:14:58,670 --> 00:15:00,890
0,360 360,450 450,600 600,1380 1380,2220
happens at this particular {}

496
00:15:00,920 --> 00:15:02,420
0,150 150,300 300,810 810,1200 1200,1500
in this scenario,| where this
|这种情况是真正同时发生的，

497
00:15:02,420 --> 00:15:04,400
0,390 390,570 600,900 900,1560 1710,1980
happens are truly concurrently,| {you,know}
|你知道在这两个都递增的线程之后，n的值是多少。

498
00:15:04,400 --> 00:15:05,240
0,180 180,270 270,330 330,720 720,840
what is the value of

499
00:15:05,240 --> 00:15:06,830
0,450 510,870 870,1080 1080,1230 1230,1590
n after these two threads

500
00:15:06,830 --> 00:15:08,300
0,180 180,420 420,480 480,1020
that both {} increment.|
|

501
00:15:11,450 --> 00:15:13,880
0,360 360,720 1260,1530 1530,1950 2220,2430
Just 1.| Yes, 1,| and
只有1个。|是的，1，|这个价值应该是什么，

502
00:15:13,880 --> 00:15:14,990
0,210 210,480 480,780 780,870 870,1110
what is what is this

503
00:15:15,020 --> 00:15:16,490
0,480 480,810 810,870 870,1110 1110,1470
value supposed to be,| what
|我们期望它是什么。

504
00:15:16,490 --> 00:15:17,210
0,60 60,210 210,570 570,660 660,720
do we expect it to

505
00:15:17,210 --> 00:15:18,080
0,330
be.|
|

506
00:15:22,260 --> 00:15:23,610
0,390 660,780 780,1230 1230,1290 1290,1350
2.| Yeah, expect it to
2.|是的，预计是2，对吧。

507
00:15:23,610 --> 00:15:24,540
0,120 120,360 360,630 630,780 780,930
be 2, right.| {} So,
|所以，1肯定不等于2，这里面有个错误。

508
00:15:24,540 --> 00:15:25,530
0,210 210,270 270,570 570,780 780,990
1 is definitely not equal

509
00:15:25,530 --> 00:15:28,020
0,90 90,540 540,930 990,1920
to 2 and {there's,a,bug}.|
|

510
00:15:28,400 --> 00:15:30,170
0,540 540,870 870,1260 1410,1590 1590,1770
{} And so, {} and
所以，这就像你知道的那种比赛条件的核心，

511
00:15:30,170 --> 00:15:31,070
0,150 150,300 300,510 510,600 600,900
this is like you know

512
00:15:31,070 --> 00:15:31,880
0,210 210,330 330,390 390,750 750,810
the sort of heart of

513
00:15:31,880 --> 00:15:34,400
0,180 180,750 840,1470 1470,1770 1770,2520
race conditions,| {} which is
|也就是说，如果线程共享您知道的状态的[]事件序列，

514
00:15:34,400 --> 00:15:36,830
0,270 270,360 360,540 540,2130 2310,2430
{} you know if an

515
00:15:36,830 --> 00:15:38,510
0,480 480,750 750,840 840,1230 1230,1680
[] sequence of events where

516
00:15:38,510 --> 00:15:40,850
0,360 360,900 900,1110 1110,1590 1950,2340
threads share {you,know} state,| the
|更新实际上可能没有正确反映

517
00:15:40,850 --> 00:15:42,500
0,510 510,780 780,960 960,1230 1230,1650
updates actually might not be

518
00:15:42,500 --> 00:15:44,510
0,420 420,870 1620,1740 1740,1830 1830,2010
reflected correctly| and of course
|当然，在大多数情况下，这会很好地解决问题，

519
00:15:44,510 --> 00:15:45,320
0,240 240,300 300,360 360,660 660,810
most of the time, {this,will}

520
00:15:45,320 --> 00:15:46,430
0,210 210,330 330,720 720,990 990,1110
work out fine,| because you
|因为你只需要身处这种非常，

521
00:15:46,430 --> 00:15:47,180
0,150 150,420 420,510 510,660 660,750
just have to be in

522
00:15:47,180 --> 00:15:49,190
0,120 120,300 300,360 360,1020 1200,2010
this sort of very, {}|
|

523
00:15:49,430 --> 00:15:51,080
0,300 300,360 360,750 750,990 990,1650
sort of this very specific
在它出现之前，这是一个非常具体的案件，

524
00:15:51,080 --> 00:15:52,430
0,390 390,750 750,810 810,1020 1020,1350
case before it shows up,|
|

525
00:15:53,120 --> 00:15:54,770
0,210 210,540 540,660 660,810 810,1650
so general I think one
所以将军，我想你们中的一个人报告说，

526
00:15:54,770 --> 00:15:55,820
0,90 90,300 300,810 810,1050 1050,1050
of you reported,| like oh
|就像哦，我没有把我的锁和我的比赛联系起来，

527
00:15:55,820 --> 00:15:57,710
0,780 810,1080 1080,1230 1230,1440 1440,1890
I didn't have my locks

528
00:15:57,710 --> 00:15:58,610
0,120 120,210 210,570 570,690 690,900
with my race,| you know
|你知道我一直在看着秩序

529
00:15:58,610 --> 00:16:01,040
0,360 360,600 750,1320 1320,1830 2010,2430
I've been watching order| and
|我的程序运行得很好

530
00:16:01,100 --> 00:16:02,480
0,270 270,660 660,810 810,990 990,1380
my program just worked fine|
|

531
00:16:02,600 --> 00:16:04,550
0,300 300,630 630,1020 1020,1500 1650,1950
and that's actually the real
这实际上是比赛条件的真正问题所在，

532
00:16:04,550 --> 00:16:05,840
0,420 420,540 540,720 720,1140 1140,1290
issue with race conditions,| they
|它们通常工作得很好，但有时会出错。

533
00:16:05,840 --> 00:16:07,370
0,330 330,510 510,690 690,1050 1050,1530
typically just work fine, but

534
00:16:07,400 --> 00:16:08,740
0,450 450,510 510,660 660,960
sometimes it goes wrong.|
|

535
00:16:09,620 --> 00:16:10,370
0,240 240,330 330,360 360,480 480,750
So there are two ways
因此，有两种方法可以[解决]竞争状况。

536
00:16:10,370 --> 00:16:13,040
0,480 480,1230 1440,1890 1890,2070 2070,2670
to {} [address] race conditions.|
|

537
00:16:13,430 --> 00:16:14,450
0,270 270,360 360,630 630,870 870,1020
{} The first way is
第一种方法是避免分享，

538
00:16:14,450 --> 00:16:16,080
0,240 240,540 540,930
to avoid sharing,|
|

539
00:16:17,720 --> 00:16:19,540
0,330 330,540 540,1080
don't share variables.|
不要共享变量。|

540
00:16:20,720 --> 00:16:21,740
0,210 210,450 450,540 540,780 780,1020
And this is one style
这是一种你知道围棋鼓励的编程风格，

541
00:16:21,740 --> 00:16:23,000
0,90 90,600 600,900 900,960 960,1260
of programming that you know

542
00:16:23,000 --> 00:16:25,040
0,330 330,900 900,1230 1230,1500 1500,2040
Go encourages,| by using channels,
|通过使用通道，通道使用通信值，

543
00:16:25,100 --> 00:16:27,050
0,420 420,690 690,1260 1260,1800 1800,1950
channels use communicate values,| but
|但你们并不能直接共享记忆，

544
00:16:27,050 --> 00:16:28,190
0,90 90,300 300,510 510,870 870,1140
you don't really directly share

545
00:16:28,190 --> 00:16:29,570
0,330 750,870 870,1020 1020,1230 1230,1380
memory,| so that's one way
|所以这是一种方法。

546
00:16:29,570 --> 00:16:32,510
0,60 60,390 570,1710 2100,2490 2580,2940
of doing it.| So avoid
|所以避免共享一种大方法，另一种方法实际上是使用锁，

547
00:16:32,510 --> 00:16:33,680
0,240 240,540 540,690 690,1080 1080,1170
sharing one big approach, the

548
00:16:33,680 --> 00:16:34,760
0,150 150,510 510,630 630,960 960,1080
other approach is actually to

549
00:16:34,760 --> 00:16:36,080
0,240 240,750
use locks,|
|

550
00:16:38,640 --> 00:16:39,900
0,120 120,210 210,630 630,900 900,1260
you know to make a
你知道，要在原子操作中制作一系列指令，

551
00:16:39,900 --> 00:16:41,610
0,390 390,480 480,1200 1200,1350 1350,1710
sequence of instructions in atomic

552
00:16:41,610 --> 00:16:43,110
0,540 720,1200 1200,1320 1320,1470 1470,1500
operation,| {} we'll talk a
|稍后我们会更详细地讨论这一点。

553
00:16:43,110 --> 00:16:43,920
0,180 180,360 360,570 570,720 720,810
lot more about that in

554
00:16:43,920 --> 00:16:44,980
0,60 60,480
a second.|
|

555
00:16:45,040 --> 00:16:46,030
0,330 330,600 600,660 660,750 750,990
{} One of the things
我想指出的一点是，这真的很酷

556
00:16:46,030 --> 00:16:46,750
0,60 60,210 210,300 300,540 540,720
I want to point out

557
00:16:46,750 --> 00:16:48,070
0,150 150,240 240,540 540,990 990,1320
that is really cool| that
|通常工具是围棋实际上有一个比赛检测器，

558
00:16:48,100 --> 00:16:50,080
0,480 480,870 870,1350 1560,1740 1740,1980
a usual tool is {}

559
00:16:50,080 --> 00:16:50,950
0,210 210,450 450,600 600,660 660,870
Go actually have a race

560
00:16:50,950 --> 00:16:52,100
0,570
detector,|
|

561
00:16:52,760 --> 00:16:54,260
0,390 540,900 900,960 960,1050 1050,1500
and most of the labs
您所做的大多数实验基本上都会鼓励您使用-race标志来运行围棋

562
00:16:54,260 --> 00:16:55,520
0,150 150,690 690,810 810,930 930,1260
that {} you were doing

563
00:16:55,520 --> 00:16:56,810
0,150 150,510 510,630 630,960 960,1290
would encourage you basically {run

564
00:16:56,810 --> 00:16:58,550
0,150 150,630 630,1050 1050,1290 1290,1740
-} Go using the {-race

565
00:16:58,550 --> 00:17:00,890
0,270 270,870 1020,1500 1710,2010 2010,2340
-} flag| and {} that
|这实际上并不能捕捉到所有可能的比赛，

566
00:17:00,890 --> 00:17:02,780
0,240 240,660 660,1080 1080,1350 1350,1890
will actually not catch every

567
00:17:03,080 --> 00:17:04,040
0,390 390,600 600,720 720,780 780,960
possible race,| but it does
|但它在实际识别种族方面做得非常好。

568
00:17:04,040 --> 00:17:05,300
0,150 150,570 570,750 750,1140 1140,1260
an extremely good job of

569
00:17:05,300 --> 00:17:07,120
0,270 270,810 810,1380
actually identifying races.|
|

570
00:17:07,430 --> 00:17:08,870
0,360 360,570 570,720 720,930 930,1440
And so you should by
因此，默认情况下，您应该在启用比赛检测器的情况下运行Go。

571
00:17:08,870 --> 00:17:10,490
0,330 330,780 810,1380 1380,1530 1530,1620
default run Go with the

572
00:17:10,490 --> 00:17:12,120
0,150 150,510 510,1020
race detector enabled.|
|

573
00:17:13,180 --> 00:17:14,830
0,270 270,390 390,780 780,1290 1290,1650
Okay, so that's one challenge
好的，这是一个关于线程的挑战，

574
00:17:14,830 --> 00:17:16,120
0,150 150,570 570,660 660,990 990,1290
with threads,| the second challenge
|第二个挑战是线程实际上是协调的。

575
00:17:16,120 --> 00:17:18,960
0,90 90,450 450,720 720,1470
with threads actually coordination.|
|

576
00:17:19,640 --> 00:17:20,840
0,150 150,270 270,480 480,540 540,1200
So it's often the case
因此，通常情况下，一个人必须，

577
00:17:20,840 --> 00:17:22,760
0,510 540,840 840,1080 1080,1650 1770,1920
that one has to,| {you,know}
|你知道，一个线程必须等待另一个线程，

578
00:17:22,760 --> 00:17:24,110
0,210 210,480 480,720 720,960 960,1350
one thread must wait another

579
00:17:24,110 --> 00:17:26,030
0,330 330,810 810,1080 1080,1200 1200,1920
thread,| before something is accomplished,|
|在完成某件事之前，|

580
00:17:26,450 --> 00:17:28,220
0,420 420,600 630,1170 1170,1290 1290,1770
{} {you,know} number of the
你知道，教程中的围棋练习的编号有一个表格

581
00:17:28,250 --> 00:17:30,170
0,210 210,810 810,990 990,1080 1080,1920
Go exercise in the tutorial

582
00:17:30,170 --> 00:17:32,330
0,150 150,1080 1080,1440 1650,1980 1980,2160
have a form| and there's
|你知道有两种方法，实际上是两个原语，

583
00:17:32,330 --> 00:17:33,740
0,240 240,780 780,960 960,1140 1140,1410
two ways {you,know} Go actually

584
00:17:33,740 --> 00:17:35,570
0,270 270,750 750,1170 1170,1470 1470,1830
two primitives,| {} dealing with
|处理一条又一条渠道，

585
00:17:35,570 --> 00:17:37,080
0,210 210,450 450,1080
one again channels,|
|

586
00:17:37,550 --> 00:17:39,140
0,420 420,1050 1080,1410 1410,1500 1500,1590
channels basically allow you to
渠道基本上允许你在沟通和协调的同时。

587
00:17:39,140 --> 00:17:40,730
0,720 720,930 930,990 990,1500 1500,1590
communicate and to coordinate at

588
00:17:40,730 --> 00:17:42,140
0,90 90,300 300,840
the same time.|
|

589
00:17:42,140 --> 00:17:43,850
0,630 870,1470 1470,1530 1530,1620 1620,1710
Or, {} you know we
或者，你知道，我们稍后会讨论条件变量。

590
00:17:43,850 --> 00:17:44,870
0,300 300,360 360,570 570,720 720,1020
talk a little bit later

591
00:17:44,870 --> 00:17:47,270
0,390 390,510 510,1380 1410,1770 1770,2400
about you know condition variables.|
|

592
00:17:49,830 --> 00:17:51,000
0,510

593
00:17:53,640 --> 00:17:54,840
0,420 420,630 630,720 720,810 810,1200
And both can be useful,|
两者都很有用，|

594
00:17:54,870 --> 00:17:55,590
0,180 180,360 360,420 420,600 600,720
I'll talk a little bit
我会更多地谈到这一点，

595
00:17:55,590 --> 00:17:57,090
0,210 210,420 420,660 930,1380 1380,1500
more about that,| {} and
|最后是最后的挑战，

596
00:17:57,090 --> 00:17:58,170
0,120 120,540 540,810 810,960 960,1080
then finally there's sort of

597
00:17:58,170 --> 00:18:01,080
0,210 240,570 570,1230 1560,2370 2370,2910
{} final challenge,| {a,big,sort,of} conceptual
|一大类概念上的挑战是你可能会陷入僵局。

598
00:18:01,080 --> 00:18:03,930
0,600 600,1530 1950,2250 2250,2430 2430,2850
challenges {is,you,can} get {deadlock -}.|
|

599
00:18:05,620 --> 00:18:06,670
0,150 150,240 240,480 480,780 780,1050
So if one thread waits
因此，如果一个线程像T1在T2上等待并且T2在T1上等待，

600
00:18:06,670 --> 00:18:08,350
0,750 780,990 990,1140 1140,1440 1440,1680
{} like {t1 -} waits

601
00:18:08,350 --> 00:18:09,340
0,210 210,420 420,690 690,840 840,990
on {t2 -} and {t2

602
00:18:09,340 --> 00:18:10,780
0,270 270,510 510,630 630,780 780,1440
-} waits for {t1 -},|
|

603
00:18:10,780 --> 00:18:11,830
0,330 330,660 660,750 750,960 960,1050
{you,know,for} example to release your
你知道，例如，在其他程序之前释放你的锁，

604
00:18:11,830 --> 00:18:14,050
0,420 420,1170 1230,1410 1410,1800 1800,2220
lock before some other sequence,|
|

605
00:18:14,050 --> 00:18:14,980
0,240 240,330 330,690 690,810 810,930
you can basically set what
你基本上可以设置他们所谓的致命拥抱

606
00:18:14,980 --> 00:18:17,230
0,90 90,300 300,690 690,1350 1560,2250
they call deadly embrace| {you,know,where}
|你知道在哪里，双方都在等待对方，结果是什么都没有取得进展。

607
00:18:17,380 --> 00:18:18,700
0,360 360,660 660,750 750,900 900,1320
both waiting on the other

608
00:18:18,700 --> 00:18:20,140
0,690 690,720 720,990 990,1260 1260,1440
as a result nothing makes

609
00:18:20,140 --> 00:18:21,360
0,270 270,840
for progress.|
|

610
00:18:22,030 --> 00:18:23,080
0,540

611
00:18:23,440 --> 00:18:24,850
0,90 90,570 570,810 810,990 990,1410
{} Trivial way you're getting
你以一种微不足道的方式让你知道围棋的僵局将是

612
00:18:24,850 --> 00:18:26,740
0,270 270,390 390,960 960,1380 1410,1890
{} {you,know} deadlock in Go

613
00:18:26,740 --> 00:18:27,670
0,120 120,420 420,600 600,720 720,930
would be| like you have
|就像你只有一个线程，根本就没有其他线程，

614
00:18:27,670 --> 00:18:29,020
0,60 60,390 390,810 870,1170 1170,1350
a single thread, there's no

615
00:18:29,020 --> 00:18:31,150
0,180 180,420 420,510 510,900 1290,2130
other threads at all,| and
|而你正在写给频道，

616
00:18:31,150 --> 00:18:33,120
0,180 180,780 780,990 990,1410
you're write to channel,|
|

617
00:18:35,200 --> 00:18:36,400
0,210 210,270 270,480 480,960 990,1200
and that will block {}
这将阻止这一线程，

618
00:18:36,400 --> 00:18:37,720
0,180 180,390 390,750 750,990 990,1320
that one thread,| until somebody
|直到你认识的其他人读到，其他人从频道上读到，

619
00:18:37,720 --> 00:18:39,010
0,540 570,690 690,900 900,1170 1170,1290
else you know read, some

620
00:18:39,010 --> 00:18:40,090
0,180 180,600 600,720 720,810 810,1080
other read from the channel,|
|

621
00:18:40,090 --> 00:18:41,080
0,180 180,330 330,540 540,750 750,990
but if there's no other
但如果根本没有其他线索，

622
00:18:41,080 --> 00:18:42,010
0,210 210,300 300,690 690,780 780,930
thread at all,| you know
|你知道这会导致僵局，

623
00:18:42,010 --> 00:18:42,820
0,240 240,420 420,690 690,780 780,810
that will result in a

624
00:18:42,820 --> 00:18:45,430
0,510 1170,1440 1440,1530 1530,2070 2070,2610
deadlock,| like the simplest possible
|就像最简单的僵局一样，

625
00:18:45,430 --> 00:18:48,340
0,390 390,960 1530,2040 2280,2730 2730,2910
deadlock possible,| {} you know
|你知道围棋实际上会抓住这个案子

626
00:18:48,340 --> 00:18:50,110
0,210 210,780 780,1050 1050,1440 1440,1770
Go actually {} will catch

627
00:18:50,110 --> 00:18:51,880
0,180 180,630 630,1050 1050,1290 1290,1770
this case| and will run
|并将Run引发运行时错误，就像没有线程要运行一样，您有一个死锁。

628
00:18:51,880 --> 00:18:53,140
0,270 270,360 360,720 720,990 990,1260
raise a runtime error saying

629
00:18:53,140 --> 00:18:54,130
0,210 210,600 600,810 810,930 930,990
like no threads going to

630
00:18:54,130 --> 00:18:55,780
0,390 390,450 450,750 750,1320
run, you {have,a} deadlock.|
|

631
00:18:56,210 --> 00:18:57,080
0,390 390,540 540,630 630,750 750,870
{} But there could be
但如果涉及多个线程，可能会出现更复杂的死锁

632
00:18:57,080 --> 00:18:58,670
0,180 180,660 660,780 780,1110 1140,1590
more complicated {deadlock -} were

633
00:18:58,700 --> 00:19:00,740
0,450 450,840 840,1230 1650,1950 1950,2040
involved multiple threads| as you're
|当你通过实验室和学期的学习时，

634
00:19:00,740 --> 00:19:02,390
0,240 240,390 390,480 480,900 900,1650
going through the labs and

635
00:19:02,420 --> 00:19:03,710
0,90 90,480 480,780 780,930 930,1290
the semester,| you I'm sure
|你，我敢肯定，你对一些东西感兴趣。

636
00:19:03,710 --> 00:19:04,640
0,90 90,270 270,420 420,600 600,930
you were on into some.|
|

637
00:19:07,540 --> 00:19:08,350
0,180 180,360 360,450 450,660 660,810
So take a little bit
所以再往后走一小步

638
00:19:08,350 --> 00:19:10,000
0,90 90,630 660,1050 1050,1350 1350,1650
of a step back here|
|

639
00:19:10,000 --> 00:19:12,010
0,300 300,480 480,990 1020,1710 1710,2010
and think about Go for
想想围棋，因为你知道这些挑战，

640
00:19:12,010 --> 00:19:12,780
0,150
{}

641
00:19:12,980 --> 00:19:14,680
0,120 120,240 240,450 450,1140
you know these challenges,|
|

642
00:19:14,970 --> 00:19:16,280
0,750

643
00:19:17,750 --> 00:19:19,100
0,300 300,450 450,660 660,900 900,1350
that I just talked about.|
就是我刚才谈到的。|

644
00:19:20,080 --> 00:19:22,300
0,540 540,1260 1530,1860 1860,2100 2100,2220
Roughly speaking, {} Go as
粗略地说，可以说是两个计划，

645
00:19:22,300 --> 00:19:24,220
0,150 150,240 240,570 570,1320
sort of two plans,|
|

646
00:19:24,510 --> 00:19:28,230
0,840 1230,2220 2310,2580 2580,3090 3090,3720
to handle these concurrency challenges.|
来应对这些并发挑战。|

647
00:19:28,930 --> 00:19:31,150
0,450 450,810 810,1320 1320,2070 2100,2220
And one plan is you
一个计划是，你知道，基本上在频道周围，

648
00:19:31,150 --> 00:19:33,560
0,450 480,870 870,1140 1140,1800
know basically around channels,|
|

649
00:19:34,980 --> 00:19:36,420
0,360 360,510 510,750 750,1110 1110,1440
and there's another plan basically
还有另一个计划，基本上是关于条件变量中的锁。

650
00:19:36,420 --> 00:19:38,360
0,300 300,930
around locks

651
00:19:39,470 --> 00:19:43,020
0,990 990,1590
{in,condition} variables.|
|

652
00:19:44,210 --> 00:19:45,200
0,240

653
00:19:45,650 --> 00:19:46,600
0,60

654
00:19:49,630 --> 00:19:51,100
0,870

655
00:19:51,510 --> 00:19:53,490
0,510 870,1350 1350,1650 1650,1860 1860,1980
And {} the way I
在我看来，

656
00:19:53,490 --> 00:19:54,960
0,180 180,450 450,630 630,750 750,1470
think about it,| you know
|你知道，有些人对此相当武断，

657
00:19:54,960 --> 00:19:56,220
0,150 150,420 420,540 540,810 810,1260
some people are quite dogmatic

658
00:19:56,220 --> 00:19:57,300
0,240 240,420 420,570 570,870 870,1080
about this,| if one plan
|如果一个计划比另一个计划好，

659
00:19:57,300 --> 00:19:58,050
0,90 90,330 330,480 480,570 570,750
is better than the other

660
00:19:58,050 --> 00:20:00,660
0,450 750,1380 1410,1950 1950,2280 2280,2610
plan,| {} my general approach
|我在这里的总体做法是，我真的想要一个最适合我正在考虑的情况的计划，

661
00:20:00,660 --> 00:20:01,530
0,300 300,420 420,630 630,690 690,870
here is like I really

662
00:20:01,530 --> 00:20:02,310
0,180 180,240 240,540 540,690 690,780
want a plan that is

663
00:20:02,310 --> 00:20:03,420
0,210 210,660 660,750 750,810 810,1110
most suitable for the case

664
00:20:03,420 --> 00:20:04,680
0,120 120,210 210,510 510,780
that I'm looking at,|
|

665
00:20:04,710 --> 00:20:06,300
0,390 390,780 780,900 900,1140 1140,1590
{} what I'm running into|
我遇到的是什么|

666
00:20:06,360 --> 00:20:08,580
0,480 570,1530 1530,1620 1620,1860 1860,2220
and generally you know I've
一般来说，你知道我不会分享的，

667
00:20:08,580 --> 00:20:11,490
0,210 210,900 1320,2100 2100,2370 2370,2910
no sharing,| {} and basically
|基本上，我需要两个威胁来进行交流，

668
00:20:11,490 --> 00:20:12,900
0,360 360,570 570,690 690,1020 1020,1410
I need two threats basically

669
00:20:12,900 --> 00:20:14,430
0,120 120,870 870,1320 1320,1380 1380,1530
to communicate,| but I don't
|但我并不真正分享任何记忆，我倾向于使用你知道的频道。

670
00:20:14,430 --> 00:20:16,050
0,180 180,480 480,600 600,1140 1200,1620
really share any memory, I

671
00:20:16,050 --> 00:20:17,610
0,210 210,270 270,750 750,900 900,1560
tend to use {you,know} channels.|
|

672
00:20:18,080 --> 00:20:19,460
0,390 390,840 840,1080 1080,1200 1200,1380
{} If there are two
如果有两个线程可以共享内存，

673
00:20:19,460 --> 00:20:20,420
0,270 270,330 330,450 450,660 660,960
threads I can do share

674
00:20:20,420 --> 00:20:22,100
0,540 570,1050 1050,1140 1140,1590 1590,1680
memory,| because it's convenient to
|因为共享内存很方便，

675
00:20:22,100 --> 00:20:23,300
0,210 210,600 600,660 660,1110 1110,1200
share memory,| for example I
|例如，我编写了一个键值服务器

676
00:20:23,300 --> 00:20:24,500
0,180 180,210 210,390 390,690 690,1200
write a {key-value -} servers|
|

677
00:20:24,500 --> 00:20:25,340
0,240 240,330 330,510 510,570 570,840
and I want to share
我想要共享键值表，

678
00:20:25,340 --> 00:20:28,160
0,60 60,240 240,600 600,1170 1500,2820
the {key-value -} table,| then
|然后我使用锁和条件变量。

679
00:20:28,730 --> 00:20:32,750
0,720 1470,1890 1890,2430 3390,3690 3690,4020
I use locks and condition

680
00:20:32,750 --> 00:20:33,880
0,570
variables.|
|

681
00:20:37,630 --> 00:20:39,490
0,510 510,660 660,1050 1170,1710 1710,1860
{} And so, {} you
所以，你知道我的总体方法不是戏剧性的

682
00:20:39,490 --> 00:20:40,390
0,60 60,240 240,480 480,780 780,900
know my general approach is

683
00:20:40,390 --> 00:20:41,860
0,300 300,480 480,720 720,1320 1320,1470
not to be dramatic| and
|你采取任何方法来解决这个问题实际上是最方便的。

684
00:20:41,860 --> 00:20:43,330
0,270 270,510 510,780 780,1200 1200,1470
you take whatever approach gonna

685
00:20:43,330 --> 00:20:45,040
0,360 360,450 450,660 660,1170 1170,1710
actually is most convenient for

686
00:20:45,070 --> 00:20:46,520
0,90 90,390 390,570 570,930
the problem that has.|
|

687
00:20:47,150 --> 00:20:50,000
0,480 990,1680 2250,2670 2670,2790 2790,2850
{} The tutorial does a
该教程很好地实际讲授了有关渠道的知识

688
00:20:50,000 --> 00:20:51,290
0,180 180,270 270,690 690,750 750,1290
pretty good job of actually

689
00:20:51,290 --> 00:20:54,470
0,1110 1230,1680 1680,2190 2190,2730 2730,3180
{} teaching about channels| mentioned
|提到的锁似乎不太涉及条件变量，

690
00:20:54,470 --> 00:20:55,880
0,480 510,780 780,1020 1020,1200 1200,1410
locks doesn't seem much about

691
00:20:55,880 --> 00:20:57,860
0,360 360,990 1140,1410 1410,1560 1560,1980
condition variables,| {} so I
|所以我我认为有必要讨论一下条件变量

692
00:20:57,860 --> 00:20:59,870
0,300 300,450 450,540 540,1440 1800,2010
I think it's worthwhile to

693
00:20:59,870 --> 00:21:00,770
0,360 360,390 390,570 570,690 690,900
talk a little bit about

694
00:21:00,770 --> 00:21:02,840
0,360 360,810 810,1350 1380,1560 1560,2070
condition variables| to make sure
|以确保您知道它们的存在。

695
00:21:03,080 --> 00:21:04,430
0,570 570,660 660,750 750,1200 1200,1350
that you are aware that

696
00:21:04,430 --> 00:21:05,540
0,150 150,780
they exist.|
|

697
00:21:05,930 --> 00:21:06,560
0,270 270,330 330,450 450,510 510,630
And I'm going to do
我将用一个很小的例子来说明这一点，

698
00:21:06,560 --> 00:21:08,060
0,270 270,630 630,990 990,1260 1260,1500
that using a tiny little

699
00:21:08,060 --> 00:21:10,280
0,690 900,1290 1290,1680 1680,2130 2130,2220
example,| {} to illustrate the
|为了说明这些问题，

700
00:21:10,280 --> 00:21:12,170
0,570 780,1020 1020,1350 1350,1470 1470,1890
issues,| {attending -} a little
|举一个小例子，

701
00:21:12,170 --> 00:21:14,570
0,510 510,960 1230,1890 2070,2280 2280,2400
example is,| {} we have
|我们有一点灵感，这是来自实验室的一点灵感

702
00:21:14,570 --> 00:21:16,790
0,660 660,900 900,1050 1050,1740 1800,2220
a little bit inspired, {}

703
00:21:16,790 --> 00:21:18,290
0,150 150,210 210,420 420,630 1170,1500
its a little bit inspired

704
00:21:18,290 --> 00:21:19,580
0,90 90,660 870,1020 1020,1230 1230,1290
by {the,labs}| and have a
|并且有一条线T1

705
00:21:19,580 --> 00:21:22,280
0,300 300,600 600,1050 1470,1920 1920,2700
thread {t1 -}| {} and
|T1需要从远程机器收集一些选票，

706
00:21:22,310 --> 00:21:23,660
0,510 540,840 840,1080 1080,1260 1260,1350
{} {t1 -} needs to

707
00:21:23,660 --> 00:21:24,890
0,300 300,360 360,660 660,750 750,1230
collect a number of votes

708
00:21:24,890 --> 00:21:25,970
0,120 120,240 240,450 450,720 720,1080
you know {from -} remote

709
00:21:25,970 --> 00:21:29,060
0,600 720,2310 2340,2820 2820,3030 3030,3090
machines,| for example needs to
|例如，需要确定它拥有多数席位，

710
00:21:29,060 --> 00:21:29,780
0,330 330,450 450,540 540,660 660,720
decide that it has a

711
00:21:29,780 --> 00:21:31,610
0,660 690,1170 1170,1350 1350,1530 1530,1830
majority,| {} so that actually
|因此，这实际上带来了一些价值

712
00:21:31,610 --> 00:21:33,590
0,570 570,690 690,1140 1290,1440 1440,1980
proceeds to commit some value|
|

713
00:21:33,890 --> 00:21:34,880
0,240 240,390 390,510 510,630 630,990
and you'll see that later
稍后你会看到，在木筏实验室里会出现这样的场景

714
00:21:34,880 --> 00:21:35,840
0,240 240,450 450,570 570,780 780,960
in like this shows up

715
00:21:35,840 --> 00:21:37,400
0,60 60,150 150,510 510,990 990,1560
in the raft lab| as
|作为您需要的原语之一

716
00:21:37,400 --> 00:21:38,750
0,180 180,270 270,450 510,1230 1230,1350
one of the primitives that

717
00:21:38,750 --> 00:21:40,700
0,90 90,450 900,1440 1440,1590 1590,1950
you need| {} and so
|要做到这一点，你知道t1会分叉，你知道其他线程会说t2，

718
00:21:40,760 --> 00:21:41,780
0,270 270,390 390,750 750,870 870,1020
to do that you know

719
00:21:41,780 --> 00:21:43,460
0,330 330,570 570,810 810,1350 1500,1680
the t1 will fork {you,know}

720
00:21:43,460 --> 00:21:45,770
0,300 300,810 1290,1500 1500,1770 1770,2310
other threads say {t2 -},|
|

721
00:21:46,930 --> 00:21:48,190
0,210 210,360 360,540 540,1020 1020,1260
and {t2 -} amazingly it
令人惊讶的是，它做了一些昂贵的事情，

722
00:21:48,190 --> 00:21:49,360
0,150 150,360 360,870 870,1110 1110,1170
does something expensive,| like you
|就像你知道的，通过与远程机器交流来获得投票，

723
00:21:49,360 --> 00:21:51,280
0,330 810,1200 1200,1380 1380,1590 1590,1920
know talk to some remote

724
00:21:51,280 --> 00:21:52,360
0,390 390,510 510,720 720,900 900,1080
machine to actually get its

725
00:21:52,360 --> 00:21:53,340
0,480
vote,|
|

726
00:21:53,400 --> 00:21:55,230
0,300 300,870 870,1380 1380,1740 1740,1830
and then report back you
然后向T1报告投票结果

727
00:21:55,230 --> 00:21:56,070
0,120 120,300 300,570 570,660 660,840
know that vote to {t1

728
00:21:56,070 --> 00:21:57,720
0,390 390,540 540,690 690,1020 1020,1650
-}| and {t1 -} basically
|T1基本上需要收集他们所获得的所有选票

729
00:21:57,720 --> 00:21:58,650
0,270 270,420 420,510 510,840 840,930
{} need to collect all

730
00:21:58,650 --> 00:21:59,610
0,90 90,390 390,570 570,630 630,960
the votes held them up|
|

731
00:21:59,640 --> 00:22:01,440
0,300 300,540 540,900 900,1080 1080,1800
and then assume that majority,|
然后假设大多数人，|

732
00:22:01,620 --> 00:22:04,200
0,390 390,990 1020,1650 1650,2100
{} then {declare,sort,of} victory.|
然后宣布某种胜利。|

733
00:22:04,400 --> 00:22:05,810
0,180 180,360 360,540 540,750 750,1410
So there's a pretty straightforward
所以有一个相当简单的程序，

734
00:22:05,810 --> 00:22:07,370
0,90 90,360 360,630 630,1140 1350,1560
{ -} simple program,| I'm
|我要给你们一点，

735
00:22:07,370 --> 00:22:07,760
0,120 120,180 180,300 300,360 360,390
going to give you a

736
00:22:07,760 --> 00:22:08,960
0,210 210,390 390,510 510,960 960,1200
little bit,| {} it allows
|这让我可以向你们说明几个问题，

737
00:22:08,960 --> 00:22:09,860
0,150 150,240 240,690 690,810 810,900
me to illustrate you a

738
00:22:09,860 --> 00:22:11,570
0,360 360,510 510,1110 1440,1590 1590,1710
couple of issues,| we're going
|我们要切换到另一个屏幕。

739
00:22:11,570 --> 00:22:14,000
0,60 60,660 960,1410 1890,2370 2370,2430
to switch to {another -}

740
00:22:14,000 --> 00:22:15,120
0,660
screen.|
|

741
00:22:15,120 --> 00:22:16,360
0,690

742
00:22:16,850 --> 00:22:18,700
0,180 180,540 540,660 660,1290
Can everybody see this?|
每个人都能看到这个吗？|

743
00:22:21,510 --> 00:22:22,800
0,780

744
00:22:22,800 --> 00:22:25,230
0,540 540,1320 1500,1980 1980,2100 2100,2430
So, {} here I have
所以，这里我有一个非常简单的程序实现，

745
00:22:25,230 --> 00:22:27,720
0,480 480,750 750,1350 1440,2400 2400,2490
a very simple implementation of

746
00:22:27,720 --> 00:22:29,550
0,150 150,810 810,1140 1170,1500 1500,1830
this program,| the vote thing,|
|投票这件事，|

747
00:22:29,550 --> 00:22:30,690
0,510 510,810 810,960 960,990 990,1140
and again it's a little
这又是一个有点像玩具的例子

748
00:22:30,690 --> 00:22:31,590
0,90 90,180 180,240 240,450 450,900
bit of a toy example|
|

749
00:22:31,590 --> 00:22:33,030
0,210 210,570 570,780 780,1140 1170,1440
that hopefully gets the point
这有望让人们理解这一点。

750
00:22:33,030 --> 00:22:34,160
0,540
across.|
|

751
00:22:34,220 --> 00:22:35,810
0,330 330,450 450,630 630,1230 1230,1590
{} The two variables shared
这里共享的两个变量分别为计数和结束，

752
00:22:35,810 --> 00:22:37,940
0,90 90,540 570,1350 1350,1770 1770,2130
{here -} count {and,finished},| count
|计票计票，

753
00:22:37,940 --> 00:22:40,160
0,660 660,840 840,930 930,1470 1590,2220
count number of votes,| finished
|当我们数完的时候，

754
00:22:40,190 --> 00:22:43,970
0,570 570,1110 1500,2190 2700,3150 3150,3780
{count,when} we're done,| {} so
|所以你知道有一个循环是为了10，

755
00:22:44,090 --> 00:22:44,930
0,180 180,300 300,480 480,510 510,840
you know there's a loop

756
00:22:44,930 --> 00:22:47,390
0,390 390,510 510,1110 1230,2070 2100,2460
going for 10,| {} creating
|创造一个围棋创造发射，

757
00:22:47,390 --> 00:22:50,630
0,120 120,780 1410,1830 1830,2400 2430,3240
a Go creating {} launching,|
|

758
00:22:50,660 --> 00:22:51,960
0,420 420,840
and {}
和匿名函数，则匿名函数并发调用该函数请求投票，

759
00:22:53,000 --> 00:22:54,500
0,210 210,360 360,570 570,1170 1200,1500
{anonymous - -} function, an

760
00:22:54,500 --> 00:22:57,620
0,540 540,1260 1440,2220 2640,2970 2970,3120
anonymous function concurrently calls this

761
00:22:57,620 --> 00:23:00,140
0,510 510,840 840,1320 1350,1830 1830,2520
function {requestVote -},| requestVote basically
|您知道，RequestVote基本上是在某台远程机器上模拟执行一项耗时长、成本高昂的操作

762
00:23:00,140 --> 00:23:01,760
0,60 60,150 150,1110 1110,1470 1470,1620
you know simulates doing a

763
00:23:01,760 --> 00:23:02,840
0,600
long

764
00:23:02,840 --> 00:23:04,340
0,360 360,900 900,1020 1020,1260 1260,1500
expensive operation on some remote

765
00:23:04,340 --> 00:23:05,090
0,390 390,480 480,540 540,660 660,750
machine| and the way it
|而它的模拟方式是，它只是睡着了，

766
00:23:05,090 --> 00:23:06,140
0,450 450,570 570,720 720,900 900,1050
simulates, it was by just

767
00:23:06,140 --> 00:23:07,700
0,180 180,300 300,750 870,1230 1230,1560
going to sleep,| it block
|它会阻塞一小段时间，

768
00:23:07,700 --> 00:23:09,110
0,60 60,120 120,300 300,810 1200,1410
for a little while,| then
|然后它又回来了

769
00:23:09,110 --> 00:23:10,940
0,90 90,750 870,1170 1170,1710 1710,1830
it returns| and then you
|然后你就知道返回的投票结果是肯定的，

770
00:23:10,940 --> 00:23:12,980
0,180 180,750 780,1350 1350,1890 1890,2040
know the returns vote is

771
00:23:12,980 --> 00:23:14,450
0,390 390,930 930,1020 1020,1290 1290,1470
yes,| then the count goes
|然后，伯爵就上去了。

772
00:23:14,450 --> 00:23:15,890
0,360 360,840 870,1140 1140,1230 1230,1440
up| and count in fact
|事实上，我们还有一个主题投票

773
00:23:15,890 --> 00:23:16,880
0,120 120,510 510,690 690,810 810,990
that actually we have one

774
00:23:16,880 --> 00:23:17,800
0,420
more

775
00:23:17,800 --> 00:23:19,570
0,300 300,570 570,1170 1170,1410 1410,1770
{} thread voting| and then
|然后我们就完事了

776
00:23:19,570 --> 00:23:21,100
0,120 120,450 870,1080 1080,1230 1230,1530
we're done| and so that's
|所以这实际上是分出了10个线程，

777
00:23:21,100 --> 00:23:22,810
0,510 510,900 900,1110 1110,1620 1620,1710
actually {fork,off} 10 threads,| you
|您知道每个人都会请求投票并报告结果

778
00:23:22,810 --> 00:23:24,460
0,210 210,480 480,810 810,1230 1230,1650
know each do {requestVote -}

779
00:23:24,820 --> 00:23:25,960
0,210 210,450 450,540 540,1020 1020,1140
and report the results| and
|然后在最后，

780
00:23:25,960 --> 00:23:27,010
0,300 300,420 420,540 540,840 840,1050
then at the end,| we'll
|我们会检查计数是否小于5，

781
00:23:27,010 --> 00:23:29,050
0,240 240,330 330,810 1110,1590 1590,2040
check if the count smaller

782
00:23:29,050 --> 00:23:30,070
0,450 510,630 630,750 750,870 870,1020
{than,5},| you know we know
|你知道我们知道我们失败了，

783
00:23:30,070 --> 00:23:31,320
0,150 150,270 270,780
that we failed,|
|

784
00:23:31,350 --> 00:23:33,810
0,570 600,1140 1140,1230 1230,1860 1890,2460
{} lost the election| and
输掉了选举|如果我们的票数大于5，

785
00:23:33,810 --> 00:23:36,000
0,180 180,930 960,1170 1170,1650 1770,2190
if we have votes equal

786
00:23:36,000 --> 00:23:37,770
0,330 330,480 480,900 900,1200 1200,1770
larger than 5,| we'll basically
|我们基本上会赢得选举，

787
00:23:37,920 --> 00:23:39,270
0,300 300,360 360,750 1020,1170 1170,1350
won the election,| so this
|所以这个简单的，非常简单的程序。

788
00:23:39,270 --> 00:23:41,310
0,180 180,330 330,960 990,1560 1590,2040
sort of simple, a very

789
00:23:41,310 --> 00:23:42,680
0,240 240,810
simple program.|
|

790
00:23:42,740 --> 00:23:44,450
0,540 720,990 990,1080 1080,1260 1260,1710
Does it all make sense?|
这一切都说得通吗？|

791
00:23:45,630 --> 00:23:46,710
0,240 240,330 330,570 570,780 810,1080
Let me run it just
让我来跑一跑，只是为了好玩。

792
00:23:46,710 --> 00:23:48,680
0,180 180,510 690,1290
for the [kicks].|
|

793
00:23:52,180 --> 00:23:53,500
0,870
Then,
然后，你知道我们要跑几次，

794
00:23:54,040 --> 00:23:54,730
0,120 120,330 330,420 420,630 630,690
you know we're running a

795
00:23:54,730 --> 00:23:56,890
0,180 180,870 960,1290 1290,1800 1800,2160
couple times,| something lose, something
|有些输了，有些赢了，你知道这是有道理的。

796
00:23:56,890 --> 00:23:58,390
0,570 630,810 810,900 900,1110 1110,1500
win, you know makes sense.|
|

797
00:23:59,060 --> 00:24:00,380
0,750

798
00:24:00,380 --> 00:24:01,730
0,390 390,480 480,630 630,930 930,1350
And so this program looks
所以这个程序看起来工作正常，而且正确，

799
00:24:01,760 --> 00:24:03,220
0,900
working

800
00:24:03,700 --> 00:24:04,720
0,270 270,420 420,840 840,960 960,1020
{} and correct,| this is
|这实际上是正确的。

801
00:24:04,720 --> 00:24:06,060
0,240 240,780
actually correct.|
|

802
00:24:09,940 --> 00:24:11,710
0,330 330,450 450,540 540,1110 1110,1770
Sorry, {I,have} a question,| whether
抱歉，我有个问题，|这个程序是否真的是正确的。

803
00:24:11,710 --> 00:24:13,210
0,180 180,510 510,630 630,930 930,1500
this program is actually correct.|
|

804
00:24:13,750 --> 00:24:15,480
0,240 240,330 330,660 660,1080
{Yeah,it,seem} to produce results.|
是的，它似乎产生了效果。|

805
00:24:15,860 --> 00:24:17,960
0,780 1110,1650

806
00:24:19,060 --> 00:24:19,870
0,150 150,330 330,540 540,630 630,810
I think there's a race
我认为这是种族问题，

807
00:24:19,870 --> 00:24:21,010
0,420 420,660 660,810 810,990 990,1140
condition,| isn't there like you
|是不是所有这些不同的线程都实现了Count和Finish变量

808
00:24:21,010 --> 00:24:22,180
0,330 330,480 480,570 570,870 870,1170
have all of these different

809
00:24:22,180 --> 00:24:23,920
0,630 630,1200 1200,1290 1290,1620 1620,1740
threads implementing the count and

810
00:24:23,920 --> 00:24:27,040
0,360 360,1140 1560,2220 2220,2430 2430,3120
finished variables| and it's also,
|而且，我也不清楚，

811
00:24:27,870 --> 00:24:29,260
0,810
{}

812
00:24:31,830 --> 00:24:32,640
0,240 240,420 420,600 600,690 690,810
it's not clear to me,|
|

813
00:24:32,640 --> 00:24:34,440
0,180 180,510 510,1170 1170,1470 1470,1800
that finished necessarily always reaches
完成的必然会达到10个，

814
00:24:34,440 --> 00:24:37,050
0,450 900,1590 2010,2160 2160,2250 2250,2610
10,| {} is it possible
|有没有可能它不会。

815
00:24:37,050 --> 00:24:38,280
0,120 120,240 240,690
that it doesn't.|
|

816
00:24:38,700 --> 00:24:40,050
0,270 270,570 570,690 690,840 840,1350
{} Let me, let me
让我，让我把这些一一拿出来

817
00:24:40,050 --> 00:24:40,980
0,150 150,270 270,630 630,720 720,930
take these one by one|
|

818
00:24:40,980 --> 00:24:41,820
0,120 120,240 240,420 420,540 540,840
and just go for your
然后去拿你的第一分，

819
00:24:41,820 --> 00:24:42,750
0,240 240,480 480,600 600,720 720,930
first point,| which is really
|这才是我真正想要的

820
00:24:42,750 --> 00:24:44,580
0,450 450,480 480,630 630,1080 1380,1830
what I was after, {}|
|

821
00:24:44,580 --> 00:24:45,390
0,60 60,180 180,420 420,630 630,810
you know clear this as,|
你知道，把这件事说清楚，|

822
00:24:45,390 --> 00:24:48,690
0,1920 2160,2940 2940,3060 3060,3150 3150,3300
a fact, we have two
事实上，我们这里有两个变量，对吗，

823
00:24:48,690 --> 00:24:51,870
0,450 450,690 690,1080 1440,2100 2130,3180
variables here, correct,| {} {you,know}
|你知道，伯爵结束了，他们被不同的猩猩程序访问，

824
00:24:51,990 --> 00:24:53,910
0,570 570,1140 1290,1470 1470,1770 1770,1920
count finished they're access by

825
00:24:53,910 --> 00:24:55,200
0,270 270,450 450,960 960,1140 1140,1290
different {goroutines -},| so this
|所以这立即是一个危险信号，这可能是一个严重的问题，

826
00:24:55,200 --> 00:24:56,670
0,120 120,720 720,810 810,1050 1050,1470
is immediately a red flag,

827
00:24:56,670 --> 00:24:57,750
0,150 390,570 570,690 690,780 780,1080
that could be a serious

828
00:24:57,750 --> 00:24:59,010
0,360 360,600 690,870 870,1170 1170,1260
problem here,| as soon as
|一旦您拥有一个变量，该变量可以访问或修改两个不同的Goroutine，

829
00:24:59,010 --> 00:25:00,420
0,120 120,390 390,780 780,1230 1230,1410
you have a variable that

830
00:25:00,420 --> 00:25:01,830
0,150 150,540 540,690 690,750 750,1410
has access to or modified

831
00:25:01,830 --> 00:25:03,240
0,240 510,840 840,990 990,1260 1260,1410
and by two different {goroutines

832
00:25:03,240 --> 00:25:04,230
0,330 330,420 420,570 570,780 780,990
-},| you know there's gonna
|你知道会有一个问题

833
00:25:04,230 --> 00:25:05,790
0,120 120,180 180,630 1110,1260 1260,1560
be a problem| and so
|运行围棋比赛检测器是如此有趣，

834
00:25:05,790 --> 00:25:06,960
0,510 510,630 630,810 810,870 870,1170
interesting to run the {}

835
00:25:06,960 --> 00:25:08,250
0,240 240,480 480,960 960,1140 1140,1290
Go race detector,| {} it
|它真的抓住了它。

836
00:25:08,250 --> 00:25:10,080
0,270 270,630 630,840
actually catches it.|
|

837
00:25:10,460 --> 00:25:11,960
0,270 270,420 420,660 690,1320 1320,1500
And as you expect, {you,know}
正如你所预料的那样，你知道，种族检测器会准确地告诉你，你知道这里确实存在一些问题，

838
00:25:11,960 --> 00:25:13,910
0,300 300,1140 1140,1260 1260,1530 1530,1950
the Go the race detector

839
00:25:13,910 --> 00:25:15,020
0,300 300,360 360,900 900,960 960,1110
tells you exactly you know

840
00:25:15,020 --> 00:25:16,640
0,300 300,930 930,1050 1050,1410 1410,1620
there's indeed some problems here,|
|

841
00:25:16,640 --> 00:25:19,340
0,510 510,1050 1380,2070 2070,2610 2610,2700
this program and list the
此程序并列出行号或实际出错的情况。

842
00:25:19,340 --> 00:25:21,020
0,270 270,960 960,1140 1140,1410 1410,1680
line number or things actually

843
00:25:21,020 --> 00:25:22,200
0,330 330,720
go wrong.|
|

844
00:25:22,700 --> 00:25:23,960
0,540 570,810 810,990 990,1080 1080,1260
So it gives you a
所以它给你提供了一个很好的线索，表明有些东西不符合[]这个程序

845
00:25:23,960 --> 00:25:25,310
0,210 210,360 360,690 690,1080 1080,1350
pretty good clue that something

846
00:25:25,310 --> 00:25:26,870
0,270 300,780 810,1020 1020,1110 1110,1560
is not up to []

847
00:25:26,900 --> 00:25:28,700
0,240 240,780 1440,1590 1590,1710 1710,1800
this program| and so we're
|所以我们要分几步来修复它，

848
00:25:28,700 --> 00:25:29,930
0,210 210,450 480,900 900,960 960,1230
going to repair {it,in} more

849
00:25:29,930 --> 00:25:32,210
0,540 540,1740 1770,1980 1980,2130 2130,2280
steps,| and you know that
|你知道，这将有望为计算机编程带来更多的启示。

850
00:25:32,210 --> 00:25:34,460
0,510 990,1680 1680,1890 1890,2010 2010,2250
will hopefully shed some more

851
00:25:34,460 --> 00:25:36,800
0,360 360,960 960,1230 1230,1920
light on computer programming.|
|

852
00:25:36,950 --> 00:25:38,180
0,360 360,480 480,780 780,1080 1080,1230
So let me give you
所以让我给你我的第二个解决方案来解决这个项目。

853
00:25:38,180 --> 00:25:39,530
0,330 330,630 630,1080 1080,1170 1170,1350
my second solution to this

854
00:25:39,530 --> 00:25:40,700
0,630
program.|
|

855
00:25:40,970 --> 00:25:42,830
0,630 630,990 990,1170 1170,1590 1590,1860
{} In this case a
在这种情况下，我们将在稍后讨论频道，

856
00:25:42,830 --> 00:25:44,180
0,510 510,840 840,990 990,1320 1320,1350
we'll talk about channels a

857
00:25:44,180 --> 00:25:45,080
0,150 150,270 270,570 570,840 840,900
little bit later,| because I
|因为我想先说明锁和条件变量，

858
00:25:45,080 --> 00:25:48,170
0,240 240,330 330,900 1680,2400 2550,3090
wanted to illustrate {} locks

859
00:25:48,170 --> 00:25:49,940
0,210 210,510 510,900 900,1380 1410,1770
and condition variables first,| because
|因为它们在教程中没有得到很好的强调。

860
00:25:49,940 --> 00:25:51,320
0,300 300,510 510,720 720,1170 1170,1380
they've got less emphasis in

861
00:25:51,320 --> 00:25:52,660
0,180 180,840
the tutorial.|
|

862
00:25:52,660 --> 00:25:54,220
0,660 990,1320 1320,1410 1410,1500 1500,1560
{} So {you,know} have a
所以你知道有一个简单的解决方案，

863
00:25:54,220 --> 00:25:56,650
0,390 390,1110 1140,1770 1770,2040 2040,2430
simple solution,| {you,know} Go correct
|你知道，正确地引入一把锁，

864
00:25:56,650 --> 00:25:58,600
0,120 120,570 570,630 630,1170 1560,1950
{} introduce a lock, {}|
|

865
00:25:58,600 --> 00:25:59,950
0,150 150,360 360,450 450,870 870,1350
the lock is completely independent
该锁完全独立于变量

866
00:25:59,950 --> 00:26:02,200
0,60 60,150 150,930 960,1770 1770,2250
of the variables| {} and
|然后你遵循一些惯例，比如，哇，这把锁，新的保护措施算了，就完成了。

867
00:26:02,230 --> 00:26:04,030
0,540 540,930 930,1140 1140,1290 1290,1800
{} you follow some convention

868
00:26:04,030 --> 00:26:05,170
0,240 240,450 450,600 600,900 900,1140
which says like wow this

869
00:26:05,170 --> 00:26:07,690
0,270 270,1080 1140,1620 1620,2010 2010,2520
lock new protects {count,and} finished.|
|

870
00:26:08,340 --> 00:26:10,380
0,150 150,240 240,900 900,1530 1530,2040
And so whenever {you,know,you} access
因此，当您知道访问计数已完成时，

871
00:26:10,380 --> 00:26:11,880
0,420 420,870 870,1230 1230,1320 1320,1500
count finished,| basically you have
|基本上，您必须将其包装到lock和unlock语句中

872
00:26:11,880 --> 00:26:12,900
0,90 90,360 360,600 600,870 870,1020
to wrap that into the

873
00:26:12,900 --> 00:26:14,310
0,300 300,390 390,840 840,1290 1290,1410
lock and unlock statements| and
|我们在这里看到两个这样的函数是同时运行的

874
00:26:14,310 --> 00:26:15,450
0,180 180,510 510,630 630,810 810,1140
so here we see two

875
00:26:15,450 --> 00:26:16,350
0,210 210,390 390,480 480,660 660,900
like this is there Go

876
00:26:16,350 --> 00:26:19,530
0,540 540,870 870,1620 2070,2130 2130,3180
function runs concurrently| {} and
|在您了解了请求投票之后，

877
00:26:19,530 --> 00:26:21,090
0,540 540,600 600,960 960,1230 1230,1560
after you know the {requestVote

878
00:26:21,090 --> 00:26:22,830
0,510 750,930 930,1260 1260,1440 1440,1740
-},| it's about of the
|投票快结束了，

879
00:26:22,860 --> 00:26:24,030
0,300 300,390 390,840 840,1020 1020,1170
vote and finished,| we take
|我们就把它锁起来。

880
00:26:24,030 --> 00:26:25,240
0,60 60,360 360,750
a lock out.|
|

881
00:26:25,240 --> 00:26:25,990
0,120 120,270 270,450 450,600 600,750
And then Go has this
然后Go有一个很好的功能，叫做延期声明，

882
00:26:25,990 --> 00:26:28,750
0,240 240,1620 1620,1890 1890,2250 2250,2760
nice feature called defer statement,|
|

883
00:26:28,960 --> 00:26:31,420
0,540 840,1140 1140,1620 1980,2340 2340,2460
but if you {exit -}
但如果你退出基本区块，

884
00:26:31,420 --> 00:26:32,440
0,60 60,360 360,750 750,840 840,1020
the basic block,| you know
|您知道Will Run将运行由DEFER声明的函数，

885
00:26:32,440 --> 00:26:35,050
0,300 300,1050 1560,2280 2280,2520 2520,2610
will run will run the

886
00:26:35,050 --> 00:26:36,850
0,390 390,630 630,1050 1050,1500 1500,1800
function that is declared by

887
00:26:37,000 --> 00:26:39,370
0,480 540,720 720,1440 1950,2280 2280,2370
{defer -},| {} after the
|在关键字DEFER之后，

888
00:26:39,370 --> 00:26:41,320
0,390 390,870 1380,1560 1560,1710 1710,1950
keyword defer,| so this means
|这意味着在我们执行的过程中，我们让GO功能自动解锁，

889
00:26:41,320 --> 00:26:43,090
0,180 180,570 570,1110 1170,1710 1710,1770
like we execute, we leave

890
00:26:43,090 --> 00:26:45,460
0,360 360,750 750,1200 1320,1710 1710,2370
{the,Go} function here will automatically

891
00:26:45,460 --> 00:26:46,360
0,540
unlock,|
|

892
00:26:46,420 --> 00:26:47,740
0,300 300,360 360,840 840,1020 1020,1320
this is convenient,| because then
这很方便，|因为那样你就不会忘记解锁了。

893
00:26:47,740 --> 00:26:49,000
0,180 180,330 330,600 600,660 660,1260
you won't forget to unlock.|
|

894
00:26:49,780 --> 00:26:50,440
0,120 120,270 270,480 480,570 570,660
So it's nice to do
因此，在执行锁定时使用写指针很好

895
00:26:50,440 --> 00:26:51,310
0,210 210,390 390,450 450,720 720,870
that write {} point where

896
00:26:51,310 --> 00:26:52,420
0,90 90,240 240,360 360,810 840,1110
you do the lock| and
|所以你可以立即写信，

897
00:26:52,420 --> 00:26:53,350
0,180 180,270 270,390 390,600 600,930
so you can write immediately,|
|

898
00:26:53,350 --> 00:26:54,370
0,210 210,330 330,510 510,930 930,1020
do a {unlock -} and
做一次解锁，然后你就不必担心

899
00:26:54,370 --> 00:26:55,420
0,300 300,540 540,690 690,810 810,1050
then {you,don't} have to worry

900
00:26:55,420 --> 00:26:56,500
0,360 360,510 510,630 630,690 690,1080
about| if there are multiple
|如果有多个出口通过了Goroutine

901
00:26:56,500 --> 00:26:57,520
0,300 300,690 690,810 810,900 900,1020
exit pass out of the

902
00:26:57,520 --> 00:26:59,260
0,630 630,870 870,990 990,1110 1110,1740
goroutine| or at a function
|或者是在你忘记解锁的功能上。

903
00:26:59,620 --> 00:27:00,790
0,420 420,630 630,720 720,960 960,1170
{} that you forget to

904
00:27:00,790 --> 00:27:01,600
0,330
unlock.|
|

905
00:27:02,520 --> 00:27:03,930
0,150 150,750 780,930 930,1200 1200,1410
So now you know we're
所以现在你知道我们基本上已经到了关键的阶段了，

906
00:27:03,930 --> 00:27:05,100
0,360 360,420 420,480 480,780 780,1170
basically in the critical section

907
00:27:05,100 --> 00:27:06,540
0,390 390,540 540,840 840,930 930,1440
where we hold the lock,|
|

908
00:27:06,540 --> 00:27:08,700
0,600 600,960 960,1260 1260,1830 1830,2160
we update vote count| and
我们更新计票情况|当然，然后该函数会自动返回并解锁。

909
00:27:08,700 --> 00:27:09,630
0,330 330,420 420,600 600,660 660,930
then of course the function

910
00:27:09,630 --> 00:27:11,880
0,480 480,750 750,1170 1170,1740
returns and unlocks automatically.|
|

911
00:27:12,240 --> 00:27:14,040
0,630 630,780 780,1230
Similarly, at the,
同样，在最后，

912
00:27:14,040 --> 00:27:16,350
0,750 750,990 990,1770 1950,2160 2160,2310
{} at the, at the

913
00:27:16,350 --> 00:27:17,610
0,360 390,510 510,630 630,720 720,1260
end,| you know we got
|你知道，当我们每次访问时，你知道计数结束，

914
00:27:17,700 --> 00:27:19,470
0,600 1170,1260 1260,1440 1440,1650 1650,1770
{} when every time we

915
00:27:19,470 --> 00:27:21,030
0,390 390,540 540,870 870,930 930,1560
access {you,know} count {} finished,|
|

916
00:27:21,270 --> 00:27:22,500
0,330 330,540 540,690 690,1110 1110,1230
{} since they share you
因为他们共享你知道我们需要用锁把它围起来

917
00:27:22,500 --> 00:27:23,910
0,180 180,330 330,540 540,990 990,1410
know we need to {round,it}

918
00:27:23,910 --> 00:27:25,890
0,630 630,1140 1170,1590 1590,1860 1860,1980
{with,locks}| and a simple way
|要做到这一点，有一个简单的方法，

919
00:27:25,890 --> 00:27:26,610
0,60 60,270 270,480 480,570 570,720
of doing that,| we could
|我们本可以在身体里写下延迟解锁，

920
00:27:26,610 --> 00:27:28,080
0,150 150,420 420,930 930,1320 1320,1470
have written defer unlock here

921
00:27:28,080 --> 00:27:29,490
0,210 210,300 300,360 360,810 930,1410
too in the body,| {the,we're}
|我们都很好，对吧。

922
00:27:29,490 --> 00:27:31,320
0,210 210,630 840,1320
being fine, right.|
|

923
00:27:31,380 --> 00:27:32,400
0,300 300,390 390,510 510,780 780,1020
So we can actually run
所以我们可以实际运行这个程序。

924
00:27:32,400 --> 00:27:33,920
0,270 270,960
this program.|
|

925
00:27:34,270 --> 00:27:35,760
0,210 210,810
Let's see.|
让我们看看。|

926
00:27:36,820 --> 00:27:38,080
0,300 300,540 540,690 690,930 930,1260
And so we run it
所以我们运行它，你知道，种族探测器似乎很高兴，

927
00:27:38,080 --> 00:27:38,920
0,90 90,210 210,330 330,600 600,840
you know the race detector

928
00:27:38,920 --> 00:27:40,180
0,180 180,270 270,390 390,990 1050,1260
seems to be happy, {}|
|

929
00:27:40,180 --> 00:27:41,710
0,360 360,840 840,1140 1140,1350 1350,1530
so hopefully we'll have a
因此，希望我们会有一个更好的计划。

930
00:27:41,710 --> 00:27:43,800
0,240 240,660 960,1560
better program.| {All,right?}|
|好的?|

931
00:27:44,160 --> 00:27:44,880
0,240 240,360 360,450 450,600 600,720
{} So I just have
所以我有一个关于作用域的问题，

932
00:27:44,880 --> 00:27:46,860
0,60 60,420 420,810 840,1410 1410,1980
a question here about scoping,|
|

933
00:27:47,280 --> 00:27:48,270
0,270 270,510 510,690 690,840 840,990
so it seems that when
所以看起来，当我们有匿名函数时，

934
00:27:48,270 --> 00:27:49,470
0,90 90,210 210,300 300,690 690,1200
we have the anonymous function,|
|

935
00:27:49,470 --> 00:27:50,250
0,120 120,240 240,360 360,510 510,780
then we have {mu -}|
然后我们就有了亩|

936
00:27:50,250 --> 00:27:51,630
0,120 120,240 240,540 570,930 930,1380
and we have the count
我们有了计数，我们有了完成的

937
00:27:51,630 --> 00:27:52,350
0,90 90,150 150,270 270,330 330,720
and we have the finished|
|

938
00:27:52,350 --> 00:27:53,010
0,90 90,180 180,390 390,570 570,660
and it seems that the
并且匿名函数似乎可以访问在该函数外部定义的网络，

939
00:27:53,010 --> 00:27:54,690
0,330 330,630 630,780 780,1230 1230,1680
anonymous function has access to

940
00:27:54,960 --> 00:27:56,430
0,360 420,750 750,1050 1050,1380 1380,1470
the network defined outside the

941
00:27:56,430 --> 00:27:58,080
0,360 360,480 480,600 600,1350 1380,1650
function,| so how looping rules
|那么循环规则是如何工作的呢？

942
00:27:58,080 --> 00:27:58,860
0,360
work?|
|

943
00:27:59,300 --> 00:28:01,490
0,630 630,840 840,1080 1080,1440 1440,2190
Yeah, you've been any, {}
是的，你一直都是，在任何变量中都有一个匿名函数，

944
00:28:01,520 --> 00:28:02,630
0,180 180,240 240,630 630,990 990,1110
with an anonymous function in

945
00:28:02,630 --> 00:28:04,340
0,240 240,600 600,870 870,1320 1320,1710
any variable,| that's used inside
|在函数中使用的不是在函数中声明的，

946
00:28:04,340 --> 00:28:05,510
0,90 90,420 450,750 750,900 900,1170
of the function is not

947
00:28:05,510 --> 00:28:07,670
0,450 450,870 870,930 930,1470 1620,2160
declared inside a function,| basically
|基本上将指针解析到外部作用域之外的变量，

948
00:28:07,670 --> 00:28:10,250
0,480 480,1110 1110,1620 1650,2220 2220,2580
resolve points to variables outside

949
00:28:10,250 --> 00:28:11,580
0,120 120,240 240,450 450,870
of the outer scope,|
|

950
00:28:12,020 --> 00:28:13,540
0,150 150,540 540,930
so statically scoped.|
所以是静态作用域。|

951
00:28:14,830 --> 00:28:16,900
0,240 240,570 570,750 750,1230 1230,2070
What about the scope of
像互斥锁这样的作用域呢？

952
00:28:16,930 --> 00:28:18,640
0,270 270,360 360,1200
like the mutex.|
|

953
00:28:19,040 --> 00:28:20,600
0,690 690,900 900,1080 1080,1260 1260,1560
Yeah.| Like how many times
嗯。|比如你要申报多少次

954
00:28:20,600 --> 00:28:21,590
0,60 60,150 150,270 270,690 690,990
you have to declare that|
|

955
00:28:21,620 --> 00:28:23,210
0,600 720,1050 1050,1110 1110,1470 1470,1590
or what's the scope of
或者它的范围有多大，我猜。

956
00:28:23,210 --> 00:28:24,770
0,240 270,420 420,840 1110,1230 1230,1560
it, I guess.| The scope
|For语句的作用域是这个块，一个基本块。

957
00:28:24,770 --> 00:28:25,700
0,90 90,330 330,510 510,870 870,930
of the for statement is

958
00:28:25,700 --> 00:28:27,800
0,660 660,1110 1140,1380 1380,1680 1680,2100
this block, one basic block.|
|

959
00:28:29,190 --> 00:28:30,240
0,390 390,450 450,780 780,930 930,1050
No, I mean like when
不，我的意思是，当你真正像互斥数据结构那样声明的时候，我想。

960
00:28:30,240 --> 00:28:31,590
0,60 60,360 360,900 900,1140 1140,1350
you actually declare like the

961
00:28:31,590 --> 00:28:34,290
0,810 840,1440 1440,2100 2130,2250 2250,2700
mutex data structure, I guess.|
|

962
00:28:34,650 --> 00:28:37,500
0,1350 1350,1560 1560,1740 1740,2340
Like any other variable,|
像任何其他变量一样，|

963
00:28:37,560 --> 00:28:38,730
0,180 180,360 360,420 420,660 660,1170
it has the same {scope,as}
它的作用域与Finish或Count相同。

964
00:28:38,730 --> 00:28:40,380
0,450 450,570 570,1080
finished or count.|
|

965
00:28:40,550 --> 00:28:41,600
0,210 210,270 270,690 690,810 810,1050
So it applies to any
的其余部分中声明的任何变量。

966
00:28:41,600 --> 00:28:44,000
0,960 1020,1770 1800,2010 2010,2100 2100,2400
variable declared in the rest

967
00:28:44,000 --> 00:28:45,770
0,90 90,570 1020,1500 1500,1620 1620,1770
of the.| Yeah, the way
|是啊，我们可以这样想，

968
00:28:45,770 --> 00:28:46,910
0,120 120,270 270,600 600,780 780,1140
to think about is that,|
|

969
00:28:46,910 --> 00:28:49,130
0,480 810,1560 1590,1860 1860,2070 2070,2220
{} the {mutex -} is
互斥锁不直接与任何变量相关联，

970
00:28:49,130 --> 00:28:50,570
0,240 240,630 630,1140 1140,1320 1320,1440
not directly associated with any

971
00:28:50,570 --> 00:28:51,920
0,510 510,630 630,870 870,960 960,1350
variable,| it's just a lock,
|这只是一把锁，就像一个名字

972
00:28:51,980 --> 00:28:54,500
0,360 360,660 660,1170 1530,2220 2220,2520
{it's,like} a name| and it's
|作为程序员，您可以决定锁保护的是什么。

973
00:28:54,500 --> 00:28:55,190
0,150 150,240 240,450 450,570 570,690
up to you as a

974
00:28:55,190 --> 00:28:56,660
0,540 540,630 630,810 810,1080 1080,1470
programmer to {decide -} what

975
00:28:56,660 --> 00:28:58,020
0,150 150,330 330,990
the lock protects.|
|

976
00:29:01,450 --> 00:29:02,560
0,180 180,300 300,360 360,570 570,1110
But there are two independent
但有两个独立的概念。

977
00:29:02,560 --> 00:29:03,780
0,720
concepts.|
|

978
00:29:04,350 --> 00:29:05,920
0,390 390,1050
What happens,
会发生什么，如果你在Goroutine中使用i会发生什么，

979
00:29:05,920 --> 00:29:06,880
0,120 120,420 420,510 510,600 600,960
what happens if you use

980
00:29:06,880 --> 00:29:09,010
0,0 0,630 630,1140 1170,1890 1920,2130
i in the goroutine,| that
|那是行不通的，对吧，你需要把它传进去。

981
00:29:09,010 --> 00:29:09,940
0,270 270,510 510,720 720,810 810,930
won't work, right, you need

982
00:29:09,940 --> 00:29:11,680
0,90 90,390 390,660 660,900 1380,1740
to pass that in.| Yeah,
|是啊，不管这是个好问题，

983
00:29:11,680 --> 00:29:12,790
0,240 240,810 810,930 930,990 990,1110
so whatever that's a good

984
00:29:12,790 --> 00:29:13,810
0,360 360,480 480,630 630,780 780,1020
question,| and then the number
|然后这个数字也是你从电子邮件中询问的n个数字，

985
00:29:13,810 --> 00:29:14,590
0,90 90,360 360,540 540,630 630,780
be n number of you

986
00:29:14,590 --> 00:29:16,000
0,540 540,660 660,990 990,1230 1230,1410
asked from email too,| so
|所以什么是什么发生了什么就像

987
00:29:16,000 --> 00:29:17,200
0,180 180,390 390,780 780,1110 1110,1200
what yeah what happens to

988
00:29:17,200 --> 00:29:17,770
0,120 120,270 270,390 390,570 570,570
like| if we use i
|如果我们在这里使用I

989
00:29:17,770 --> 00:29:19,600
0,720 750,990 990,1080 1080,1440 1500,1830
here| and they want to
|他们想用它做点什么，就像我算什么，

990
00:29:20,080 --> 00:29:21,160
0,210 210,540 540,690 690,870 870,1080
do something with it, like

991
00:29:21,160 --> 00:29:22,120
0,540
whatever

992
00:29:22,120 --> 00:29:24,500
0,540 540,1020 1020,1530
count is i,|
|

993
00:29:24,620 --> 00:29:25,760
0,300 300,630 630,720 720,900 900,1140
{} is a good plan
这是不是一个好计划？

994
00:29:25,760 --> 00:29:26,720
0,60 60,420
or not?|
|

995
00:29:31,460 --> 00:29:32,570
0,300 300,570 570,660 660,870 870,1110
What value of i will
我将使用什么价值，

996
00:29:32,570 --> 00:29:34,100
0,240 240,720 780,1140 1140,1290 1290,1530
be using,| when this thread
|当这个线程实际运行时。

997
00:29:34,100 --> 00:29:35,820
0,330 330,690 690,810 810,1110
actually happens to run.|
|

998
00:29:36,020 --> 00:29:37,670
0,330 330,690 690,1020 1020,1140 1140,1650
If Go starts to function
如果GO开始运行并将在某个点运行，

999
00:29:37,670 --> 00:29:38,690
0,450 450,570 570,750 750,900 900,1020
function and will run at

1000
00:29:38,690 --> 00:29:40,040
0,150 150,480 480,780 780,1170 1170,1350
some point,| what value i
|我会用它有什么价值。

1001
00:29:40,040 --> 00:29:41,380
0,360 360,630 630,750
will use it.|
|

1002
00:29:41,710 --> 00:29:43,540
0,780 780,990 990,1410 1410,1560 1560,1830
Whatever, i happens to be
不管怎样，当时我碰巧在

1003
00:29:43,540 --> 00:29:44,920
0,180 180,270 270,660 660,990 990,1380
at the time| which is
|它正被外部的for循环更改。

1004
00:29:44,950 --> 00:29:46,900
0,600 600,1560 1560,1680 1680,1770 1770,1950
being changed by the for

1005
00:29:46,900 --> 00:29:49,900
0,210 210,810 870,1440 1710,2610 2610,3000
loop outside.| Yeah, so and
|是的，某某，这并不是很好，

1006
00:29:49,930 --> 00:29:50,590
0,150 150,300 300,360 360,540 540,660
so this is not so

1007
00:29:50,590 --> 00:29:51,970
0,360 480,690 690,870 870,1230 1230,1380
great,| it does probably not
|它可能不是我们想要的，

1008
00:29:51,970 --> 00:29:53,470
0,180 180,300 300,810 840,1170 1170,1500
what we intended,| we probably
|我们可能是想不顾一切地进行循环迭代，对吧。

1009
00:29:53,470 --> 00:29:55,240
0,420 420,510 510,1020 1020,1320 1320,1770
intended to i we whatever

1010
00:29:55,240 --> 00:29:57,040
0,90 90,570 570,930 930,1410 1440,1800
for desperately loop iteration, right.|
|

1011
00:29:58,270 --> 00:29:59,020
0,180 180,300 300,390 390,570 570,750
So how do we want
那么，我们想要如何，

1012
00:29:59,020 --> 00:29:59,710
0,90 90,330 330,510 510,600 600,690
to,| if we have to
|如果我们必须解决，我们会怎么做。

1013
00:29:59,710 --> 00:30:01,060
0,360 360,510 510,870 870,990 990,1350
solve, how would we do.|
|

1014
00:30:01,640 --> 00:30:03,650
0,270 270,1140 1380,1680 1680,1830 1830,2010
You could add it as
您可以将其作为参数添加到匿名函数中并传递给它，

1015
00:30:03,650 --> 00:30:04,910
0,60 60,660 660,750 750,840 840,1260
a parameter to the anonymous

1016
00:30:04,910 --> 00:30:06,050
0,360 360,540 540,810 810,870 870,1140
function and pass it in,|
|

1017
00:30:06,050 --> 00:30:07,910
0,150 150,300 300,840 990,1620 1620,1860
so it gets evaluated, we
所以它被评估，我们创建了Goroutine。

1018
00:30:07,910 --> 00:30:10,130
0,390 390,930 930,1320 1590,2100 2100,2220
create {goroutine -}.| Yeah, so
|是啊，所以我会写下这个，

1019
00:30:10,130 --> 00:30:12,340
0,90 90,210 210,420 420,930
would {} write this,|
|

1020
00:30:12,340 --> 00:30:13,810
0,150 150,270 270,600 600,1080 1260,1470
and then pass {it,in}, right,|
然后传进去，对，|

1021
00:30:13,810 --> 00:30:15,220
0,300 300,720 720,900 900,1230 1230,1410
then {at,a,point} what happens then
然后在某个点上发生了什么，在我们实际创建Goroutine I的点上被捕获，

1022
00:30:15,220 --> 00:30:16,270
0,120 120,210 210,720 720,840 840,1050
at the point we actually

1023
00:30:16,270 --> 00:30:18,310
0,600 600,1290 1290,1710 1710,1890 1890,2040
create {goroutine -} i is

1024
00:30:18,310 --> 00:30:19,620
0,180 180,780
being captured,|
|

1025
00:30:19,820 --> 00:30:21,240
0,180 180,300 300,630 630,840
and then passed it.|
然后通过了它。|

1026
00:30:22,250 --> 00:30:23,380
0,450
Okay?|
好吧?|

1027
00:30:24,390 --> 00:30:25,860
0,870
{I,also},
我还，局部变量是怎么分配的，

1028
00:30:25,920 --> 00:30:27,900
0,600 840,1140 1140,1440 1440,1620 1620,1980
{} how are the local

1029
00:30:27,900 --> 00:30:30,570
0,450 450,1380 1740,2010 2010,2460 2490,2670
variables allocated,| like if if
|就像如果计数完成就像局部变量一样，

1030
00:30:30,570 --> 00:30:32,250
0,270 270,810 810,930 930,1320 1350,1680
count finished are like local

1031
00:30:32,250 --> 00:30:34,410
0,540 540,840 840,1050 1050,1590 1710,2160
variables,| wouldn't they like be
|难道它们不希望在主函数退出后被销毁，

1032
00:30:34,410 --> 00:30:35,970
0,600 600,840 840,960 960,1170 1170,1560
destroyed after the main function

1033
00:30:35,970 --> 00:30:37,590
0,600 720,1080 1080,1230 1230,1380 1380,1620
exits,| like if this often
|就像如果这通常只是另一种功能，

1034
00:30:37,590 --> 00:30:38,850
0,240 240,450 450,750 750,1110 1110,1260
made but another function,| what
|就像击球功能在大猩猩之前就存在了一样。

1035
00:30:38,850 --> 00:30:40,410
0,150 150,450 540,1020 1020,1260 1260,1560
is like the hitting function

1036
00:30:40,410 --> 00:30:43,440
0,300 300,780 1050,1470 1470,2670 2670,3030
existed before goroutine.| The principal
|堆栈中分配的主体，

1037
00:30:43,440 --> 00:30:45,960
0,420 420,510 510,1080 1200,1890 1890,2520
allocated in stack,| {} and
|你知道那个有其他功能的房间，

1038
00:30:45,960 --> 00:30:47,070
0,120 120,330 330,750 780,990 990,1110
you know the room with

1039
00:30:47,070 --> 00:30:48,690
0,60 60,240 240,600 600,990 990,1620
the other functions,| there's memory
|有指向它们的内存地址，

1040
00:30:48,690 --> 00:30:50,820
0,570 570,1080 1080,1230 1230,1620 1890,2130
addresses references to them,| so
|所以确实是这样的，

1041
00:30:50,820 --> 00:30:51,720
0,90 90,360 360,420 420,750 750,900
it's indeed the case,| its
|它的主要返回值，那么这些你知道的堆栈分配的变量就不见了。

1042
00:30:51,720 --> 00:30:53,850
0,330 330,1050 1140,1440 1440,1950 1980,2130
main returns, then these you

1043
00:30:53,850 --> 00:30:55,830
0,480 480,870 870,1140 1140,1590 1590,1980
know the stack allocated variables

1044
00:30:55,830 --> 00:30:56,640
0,120 120,510
are gone.|
|

1045
00:30:56,820 --> 00:30:58,230
0,180 180,540 540,720 720,900 900,1410
So typically what you'll see
所以通常你会在围棋程序中看到，

1046
00:30:58,230 --> 00:30:59,700
0,210 210,510 510,780 780,990 990,1470
is in a go program,|
|

1047
00:30:59,700 --> 00:31:01,080
0,180 180,330 330,840 840,870 870,1380
you would allocate, I mean
你会分配，我是说，你知道在堆上

1048
00:31:01,110 --> 00:31:01,980
0,90 90,210 210,420 420,510 510,870
you know on the heap|
|

1049
00:31:02,010 --> 00:31:03,660
0,540 540,930 930,1260 1260,1440 1440,1650
using new if you make
如果您创建了一个新的结构或其他什么，则使用new。

1050
00:31:03,660 --> 00:31:05,250
0,30 30,180 180,750 780,1140 1140,1590
a new struct or whatever.|
|

1051
00:31:05,580 --> 00:31:06,750
0,240 240,360 360,480 480,510 510,1170
So you get a segmentation
因此，你会遇到分段故障，或者会出现故障。

1052
00:31:06,750 --> 00:31:07,920
0,270 270,570 570,870 870,1050 1050,1170
fault then, or would.| Yeah,
|是的，我们会得到的。

1053
00:31:07,920 --> 00:31:11,040
0,240 270,990 1290,1890
we'll get.| Okay.|
|好吧。|

1054
00:31:13,500 --> 00:31:14,670
0,360 360,450 450,540 540,840 840,1170
{} I have a question,
我有一个问题，我不记得这是不是正确的方法，

1055
00:31:14,670 --> 00:31:15,630
0,90 90,300 300,630 630,810 810,960
I not remember this is

1056
00:31:15,630 --> 00:31:17,520
0,210 210,900 1110,1680 1680,1740 1740,1890
the correct way to do

1057
00:31:17,520 --> 00:31:18,360
0,90 90,150 150,390 390,570 570,840
it or not,| but instead
|但是，它并没有把它传递出去，

1058
00:31:18,360 --> 00:31:19,770
0,120 120,570 570,690 690,1050 1140,1410
of passing it in,| would
|是否可以作为for循环中的第一行，

1059
00:31:19,770 --> 00:31:20,880
0,60 60,120 120,660 660,900 900,1110
it be possible to as

1060
00:31:20,880 --> 00:31:21,870
0,90 90,420 420,720 720,870 870,990
the first line in the

1061
00:31:21,870 --> 00:31:23,310
0,240 240,510 510,720 720,1140 1140,1440
for loop,| do i colon
|我冒号等于I吗，

1062
00:31:23,310 --> 00:31:24,660
0,300 300,750
equals i,|
|

1063
00:31:24,960 --> 00:31:26,070
0,450 450,630 630,750 750,930 930,1110
{} and then you're like
然后你就像你有一个，

1064
00:31:26,070 --> 00:31:27,180
0,180 180,360 360,750 840,1020 1020,1110
you have a,| I don't
|我不知道作用域在for循环的LIKE块中是如何工作的，

1065
00:31:27,180 --> 00:31:28,200
0,90 90,270 270,360 360,750 750,1020
know how the scoping works

1066
00:31:28,200 --> 00:31:30,330
0,570 600,810 810,1230 1290,1890 1890,2130
within the like block of

1067
00:31:30,330 --> 00:31:31,290
0,90 90,360 360,630 630,870 870,960
the for loop,| because I
|因为我认为这会产生一个新的变量i，

1068
00:31:31,290 --> 00:31:32,430
0,150 150,300 300,480 480,900 900,1140
think that should create a

1069
00:31:32,430 --> 00:31:34,530
0,510 660,1290 1290,1770 1830,2010 2010,2100
new variable i,| that the
|Goroutine可以访问的内容，不会再次更新。

1070
00:31:34,530 --> 00:31:35,700
0,210 210,510 510,630 630,1050 1050,1170
{goroutine -} can access, that

1071
00:31:35,700 --> 00:31:37,710
0,180 180,360 360,690 690,1290 1740,2010
isn't being updated again.| {Yeah,you,can,do,that}.|
|是的你可以做到的。|

1072
00:31:37,710 --> 00:31:40,230
0,2010 2010,2070 2070,2250 2250,2340 2340,2520
{That,can,help -} makes it look
这有助于让它在我看来很难看。

1073
00:31:40,230 --> 00:31:42,750
0,270 600,690 690,960 1710,1980 1980,2520
ugly to me.| Okay, I
|好的，我，我喜欢穿过去，

1074
00:31:42,750 --> 00:31:43,890
0,180 180,420 420,750 750,990 990,1140
I like passing in,| but
|但这是另一种方式，

1075
00:31:43,890 --> 00:31:44,700
0,180 180,420 420,570 570,630 630,810
that's another way of doing

1076
00:31:44,700 --> 00:31:46,410
0,390 390,810 810,1200 1200,1320 1320,1710
it,| I'll shows an example
|稍后我将展示一个示例。

1077
00:31:46,410 --> 00:31:47,120
0,330
later.|
|

1078
00:31:49,200 --> 00:31:51,300
0,450 600,840 840,1470 1470,1740 1740,2100
{} So somebody asked actually
所以有人问，实际上，你知道，

1079
00:31:51,300 --> 00:31:51,930
0,90 90,210 210,300 300,450 450,630
you know,| do we get
|我们会不会遇到分段故障，

1080
00:31:51,930 --> 00:31:54,570
0,1320 1380,1860 1860,2220 2220,2370 2370,2640
a segmentation fault,| we're not
|我们不会立即得到分段故障，实际上我们收回了这一点，

1081
00:31:54,570 --> 00:31:55,320
0,420 420,540 540,600 600,720 720,750
immediately going to get a

1082
00:31:55,320 --> 00:31:56,640
0,540 540,780 780,1020 1020,1200 1200,1320
segmentation fault actually take that

1083
00:31:56,640 --> 00:31:58,890
0,420 750,1200 1200,1620 1620,2040 2040,2250
back,| {} because basically one
|因为基本上一个线程仍将持有引用，

1084
00:31:58,890 --> 00:32:00,000
0,300 300,570 570,810 810,1020 1020,1110
thread will still hold a

1085
00:32:00,000 --> 00:32:02,130
0,630 930,1110 1110,1230 1230,1830 1830,2130
reference,| so the garbage collector
|因此垃圾回收器还不会删除该对象。

1086
00:32:02,130 --> 00:32:03,900
0,150 150,510 510,1290 1290,1380 1380,1770
will not delete the object

1087
00:32:03,900 --> 00:32:04,640
0,330
yet.|
|

1088
00:32:05,000 --> 00:32:06,080
0,210 210,510 510,630 630,720 720,1080
But only when the last
但只有当最后一条线索，

1089
00:32:06,080 --> 00:32:08,300
0,270 270,810 810,1140 1140,2040 2040,2220
thread actually,| {} only when
|仅当没有线程持有引用时，

1090
00:32:08,300 --> 00:32:09,650
0,240 240,510 510,810 810,870 870,1350
no thread holds a reference,|
|

1091
00:32:09,650 --> 00:32:10,820
0,90 90,270 270,750 750,870 870,1170
you know will the garbage
您知道垃圾回收器是否会删除该对象。

1092
00:32:10,820 --> 00:32:12,640
0,360 360,720 720,840 840,1320
collector delete the object.|
|

1093
00:32:12,640 --> 00:32:13,180
0,150 150,270 270,330 330,450 450,540
And these are one of
这些都是垃圾收集语言最酷的地方之一

1094
00:32:13,180 --> 00:32:14,110
0,60 60,300 300,510 510,750 750,930
the cool things about having

1095
00:32:14,110 --> 00:32:15,430
0,30 30,330 330,660 660,1050 1050,1320
a garbage collected language| and
|和共享存储器编程，

1096
00:32:15,430 --> 00:32:17,440
0,240 240,540 540,1200 1440,1860 1860,2010
shared memory programming,| you don't
|你不必担心这种情况。

1097
00:32:17,440 --> 00:32:18,250
0,90 90,210 210,450 450,660 660,810
have to worry about that

1098
00:32:18,250 --> 00:32:19,300
0,510
scenario.|
|

1099
00:32:21,300 --> 00:32:24,680
0,750 780,1410
Okay.| So.|
好吧。|所以。|

1100
00:32:24,680 --> 00:32:25,620
0,390
Yeah,
是的，那会，这个代码会不会像死锁一样，

1101
00:32:25,620 --> 00:32:27,420
0,360 450,750 750,1350 1380,1590 1590,1800
{} that would, could this

1102
00:32:27,420 --> 00:32:29,880
0,270 270,450 450,1140 1410,2250 2280,2460
code like deadlock,| because like
|因为如果我们是大猩猩，

1103
00:32:29,880 --> 00:32:31,290
0,270 270,660 660,870 870,1200 1200,1410
if we if the {goroutines

1104
00:32:31,290 --> 00:32:33,090
0,750 990,1110 1110,1380 1380,1500 1500,1800
-},| I took the first
|我选择了第一个for循环Will Exit

1105
00:32:33,090 --> 00:32:34,320
0,180 180,390 390,510 510,1050 1050,1230
for loop will exit| and
|然后第二个人会喜欢。

1106
00:32:34,320 --> 00:32:35,670
0,330 330,480 480,840 840,1170 1170,1350
then the second one will

1107
00:32:35,670 --> 00:32:37,140
0,330 420,960
like. {}|
|

1108
00:32:37,930 --> 00:32:40,540
0,240 240,420 420,840
Yeah, no, nevermind.|
是的，不，不要紧。|

1109
00:32:40,660 --> 00:32:41,980
0,330 330,750 750,840 840,1170 1170,1320
{} There are definitely some
肯定有一些问题还不理想，

1110
00:32:41,980 --> 00:32:43,000
0,270 270,450 450,510 510,690 690,1020
issues that are not ideal

1111
00:32:43,000 --> 00:32:44,110
0,240 240,510 510,630 630,840 840,1110
yet,| so let me actually
|所以让我来实际地谈谈它们，

1112
00:32:44,110 --> 00:32:45,640
0,210 210,420 420,660 990,1260 1260,1530
talk about them,| {} one
|其中之一是这个特殊的环路，

1113
00:32:45,640 --> 00:32:46,990
0,60 60,270 270,600 600,1080 1080,1350
of them is that this

1114
00:32:46,990 --> 00:32:49,450
0,480 480,1050 1230,1530 1530,2100 2100,2460
particular loop,| {a,little,bit} annoying,| like
|有点烦人，|就像这个for循环一样，除了等待计数达到5次之外，没有别的了。

1115
00:32:49,450 --> 00:32:50,950
0,360 360,720 840,1080 1080,1320 1320,1500
there's this for loop is

1116
00:32:50,950 --> 00:32:52,210
0,210 210,450 450,720 720,840 840,1260
there's nothing else than waiting

1117
00:32:52,210 --> 00:32:53,950
0,150 150,420 420,720 720,1230 1230,1740
utill count reaches 5 finished.|
|

1118
00:32:54,380 --> 00:32:55,130
0,210 210,270 270,420 420,480 480,750
And the way it does,|
而且它确实是这样的，|

1119
00:32:55,130 --> 00:32:56,120
0,120 120,210 210,390 390,510 510,990
it is about your spinning
这是关于你的旋转权，

1120
00:32:56,210 --> 00:32:58,070
0,300 300,450 450,720 720,1290 1290,1860
right,| so it locks locks
|所以它很快就锁定在这个值上，

1121
00:32:58,070 --> 00:32:59,360
0,420 420,480 480,570 570,870 870,1290
locks at the value quickly,|
|

1122
00:32:59,360 --> 00:33:00,260
0,150 150,420 420,540 540,630 630,900
it locks it and spins
它会把它锁住，然后再次旋转，

1123
00:33:00,260 --> 00:33:01,490
0,270 270,510 510,690 690,1020 1020,1230
around again,| so basically is
|所以基本上就是在处理器上旋转，实际上什么都不做，

1124
00:33:01,490 --> 00:33:02,840
0,480 480,570 570,660 660,1110 1110,1350
spinning on the processor doing

1125
00:33:02,840 --> 00:33:04,550
0,210 210,540 1110,1320 1320,1410 1410,1710
really nothing,| {it,would} be nice
|如果能用一种更好的方式来表达这一点就好了，

1126
00:33:04,550 --> 00:33:05,300
0,90 90,420 420,540 540,660 660,750
to express that in a

1127
00:33:05,300 --> 00:33:06,290
0,150 150,270 270,570 570,840 840,990
little bit better way,| so
|所以基本上围棋可以再次放弃核心，

1128
00:33:06,290 --> 00:33:07,850
0,300 300,750 750,990 990,1200 1200,1560
that basically the Go can

1129
00:33:07,850 --> 00:33:09,140
0,180 180,360 360,540 540,990 990,1290
give up the core again,|
|

1130
00:33:09,140 --> 00:33:09,980
0,120 120,240 240,510 510,750 750,840
so then another thread can
这样另一个线程就可以运行了。

1131
00:33:09,980 --> 00:33:11,040
0,450
run.|
|

1132
00:33:11,040 --> 00:33:11,940
0,180 180,300 300,360 360,720 720,900
And so the way you
这样做的方法就是使用条件变量，

1133
00:33:11,940 --> 00:33:12,660
0,90 90,180 180,420 420,510 510,720
can do that is using

1134
00:33:12,660 --> 00:33:14,220
0,330 330,930 930,1140 1140,1380 1380,1560
condition variables,| and so this
|这是我的下一个实现。

1135
00:33:14,220 --> 00:33:16,900
0,120 120,540 570,1170 1170,1950
is my next implementation.|
|

1136
00:33:17,300 --> 00:33:19,730
0,1380 1380,1770 1800,2130 2130,2190 2190,2430
{} Or actually I show
或者实际上我向您展示了另一个实现，

1137
00:33:19,730 --> 00:33:21,140
0,90 90,240 240,510 510,1080 1080,1410
you one other implementation,| one
|要做到这一点，一种方法是，

1138
00:33:21,140 --> 00:33:22,010
0,180 180,300 300,450 450,690 690,870
way to do that there's

1139
00:33:22,010 --> 00:33:22,850
0,30 30,180 180,300 300,690 720,840
a little bit,| not you
|不是你知道的不是很好，

1140
00:33:22,850 --> 00:33:23,720
0,90 90,330 330,420 420,750 750,870
know not so nice,| for
|例如，有人建议，

1141
00:33:23,720 --> 00:33:25,550
0,540 540,840 870,1200 1200,1560 1560,1830
example and somebody suggested,| this
|这实际上是要睡一段时间，

1142
00:33:25,880 --> 00:33:26,960
0,390 390,570 570,660 660,840 840,1080
{} is to actually sleep

1143
00:33:26,960 --> 00:33:27,980
0,90 90,120 120,330 330,720 750,1020
for a {} while,| so
|所以，与其疯狂地放弃旋转，

1144
00:33:27,980 --> 00:33:30,140
0,270 270,420 420,780 1140,1860 1890,2160
instead of like a giving

1145
00:33:30,140 --> 00:33:31,850
0,150 150,690 720,1170 1170,1290 1290,1710
up the spinning like crazy,|
|

1146
00:33:31,850 --> 00:33:33,590
0,180 180,390 390,810 810,1290 1350,1740
just sleep one period, sleep
只要睡一段时间，睡一段时间，然后回来。

1147
00:33:33,590 --> 00:33:34,310
0,120 120,210 210,510 510,600 600,720
for a period and then

1148
00:33:34,310 --> 00:33:35,200
0,90 90,480
come back.|
|

1149
00:33:35,500 --> 00:33:36,340
0,120 120,330 330,420 420,690 690,840
Of course, this solution will
当然，这个解决方案会奏效的，

1150
00:33:36,340 --> 00:33:37,420
0,360 360,450 450,540 540,990 990,1080
work,| but the downside of
|但它的缺点是你应该睡多久，对吧，

1151
00:33:37,420 --> 00:33:39,040
0,120 120,300 300,1170 1170,1440 1440,1620
it is how long should

1152
00:33:39,040 --> 00:33:40,570
0,120 120,600 630,1050 1080,1290 1290,1530
you sleep, right,| you really
|你真的很想这样，

1153
00:33:40,570 --> 00:33:41,230
0,150 150,390 390,450 450,570 570,660
would like to be the

1154
00:33:41,230 --> 00:33:42,430
0,360 360,570 570,750 750,1140 1140,1200
case,| that I assume for
|例如，我假设这个人到了5岁，

1155
00:33:42,430 --> 00:33:44,080
0,390 390,570 570,780 780,1050 1050,1650
example this guy reaches 5,|
|

1156
00:33:44,530 --> 00:33:46,480
0,1140 1140,1230 1230,1380 1380,1530 1530,1950
then you know you wake,
然后你知道你醒了，你可以唤醒这个特定的你知道主线。

1157
00:33:46,510 --> 00:33:48,130
0,480 570,780 780,1020 1020,1170 1170,1620
you could wake up this

1158
00:33:48,130 --> 00:33:49,300
0,570 600,720 720,810 810,930 930,1170
particular you know the main

1159
00:33:49,300 --> 00:33:50,100
0,330
thread.|
|

1160
00:33:50,130 --> 00:33:52,080
0,240 240,630 1290,1470 1470,1680 1680,1950
And so I was jumping
所以我往前跳了一点，

1161
00:33:52,080 --> 00:33:52,890
0,180 180,210 210,390 390,570 570,810
ahead a little bit,| but
|但这就是条件变量的作用，

1162
00:33:52,890 --> 00:33:54,720
0,540 660,840 840,1140 1140,1440 1440,1830
{} so that's what condition

1163
00:33:54,720 --> 00:33:57,870
0,450 450,570 570,1110 1530,2310 2550,3150
variables are for,| {} you
|你知道，这是一个带有条件变量的解。

1164
00:33:57,870 --> 00:33:58,860
0,90 90,390 390,450 450,870 870,990
know here's a solution with

1165
00:33:58,860 --> 00:34:00,300
0,360 360,990
condition variables.|
|

1166
00:34:00,670 --> 00:34:04,150
0,660 1050,1830 2040,2460 2460,3030 3030,3480
{} So, {} we allocated
所以，我们分配了一个新的条件，

1167
00:34:04,150 --> 00:34:06,100
0,60 60,570 600,990 990,1530 1530,1950
a new condition,| {} here's
|以下是分配的条件[]，

1168
00:34:06,100 --> 00:34:08,380
0,480 480,840 840,1470 1530,1680 1680,2280
condition [] allocated,| it's associated
|它与这个特定的锁相关联，

1169
00:34:08,380 --> 00:34:09,700
0,150 150,300 300,720 720,1140 1140,1320
with this particular lock,| we'll
|我们一会儿就会知道，为什么这么重要。

1170
00:34:09,700 --> 00:34:10,840
0,210 210,300 300,630 630,900 900,1140
see {in,a} second, why is

1171
00:34:10,840 --> 00:34:12,140
0,660
important.|
|

1172
00:34:12,340 --> 00:34:13,750
0,720 720,840 840,930 930,1290 1290,1410
And you know basically the
你基本上知道它现在的主线是什么，

1173
00:34:13,750 --> 00:34:14,740
0,300 300,540 540,690 690,750 750,990
main thread what it does

1174
00:34:14,740 --> 00:34:17,260
0,600 750,1470 1470,2160 2160,2430 2430,2520
now,| {} it grabs the
|它抓住了锁，

1175
00:34:17,260 --> 00:34:18,130
0,360 360,540 540,630 630,810 810,870
lock,| because it needs to
|因为它需要抓取锁来查看计数和完成，

1176
00:34:18,130 --> 00:34:18,970
0,180 180,270 270,540 540,660 660,840
grab the lock to look

1177
00:34:18,970 --> 00:34:20,410
0,150 150,510 510,600 600,990 990,1440
at count and finished,| otherwise
|否则可能会有比赛条件

1178
00:34:20,410 --> 00:34:20,980
0,90 90,240 240,330 330,390 390,570
there could be a race

1179
00:34:20,980 --> 00:34:25,060
0,660 1080,1470 1470,1980 1980,1980 1980,4080
conditions| and then, {} if
|然后，如果条件仍然不成立，

1180
00:34:25,090 --> 00:34:25,900
0,120 120,420 420,480 480,660 660,810
the condition is still not

1181
00:34:25,900 --> 00:34:27,580
0,480 540,750 750,960 960,1260 1260,1680
true,| it just calls wait
|它只是在此条件变量上调用WAIT。

1182
00:34:27,610 --> 00:34:29,260
0,210 210,330 330,690 690,1170
on this condition variable.|
|

1183
00:34:29,640 --> 00:34:30,720
0,180 180,360 360,570 570,930 930,1080
And what that does is
它所做的实际上是自动完成的，进入睡眠状态

1184
00:34:30,720 --> 00:34:32,880
0,330 330,750 840,1680 1680,1890 1890,2160
actually done {atomically -} goes

1185
00:34:32,880 --> 00:34:34,710
0,90 90,840 960,1320 1320,1710 1710,1830
to sleep| as well as
|以及释放与条件变量相关联的锁，

1186
00:34:34,710 --> 00:34:35,940
0,540 540,660 660,990 990,1110 1110,1230
releasing the lock that is

1187
00:34:35,940 --> 00:34:37,500
0,570 570,690 690,780 780,1110 1110,1560
associated with the condition variable,|
|

1188
00:34:37,830 --> 00:34:39,420
0,420 420,570 570,870 870,960 960,1590
since {you,know} mu is actually
由于您知道Mu实际上与条件变量相关联，

1189
00:34:39,420 --> 00:34:41,730
0,630 630,720 720,1050 1050,1650 1680,2310
associated the condition variable,| can't
|基本上不能解锁

1190
00:34:41,730 --> 00:34:46,290
0,630 750,1680 1800,2760 2880,3750 3780,4560
basically unlocks the lock {}|
|

1191
00:34:46,320 --> 00:34:47,700
0,480 480,690 690,750 750,1170 1200,1380
and goes to sleep in
然后在原子操作中入睡。

1192
00:34:47,700 --> 00:34:49,180
0,90 90,480 480,1080
an atomic operation.|
|

1193
00:34:49,580 --> 00:34:51,410
0,240 240,360 360,540 540,1350 1470,1830
And when it returns from
当它从Count返回时，

1194
00:34:51,410 --> 00:34:52,700
0,510 510,660 660,840 840,1080 1080,1290
count,| it will actually hold
|它实际上会再次锁住锁。

1195
00:34:52,700 --> 00:34:53,960
0,90 90,360 360,720
the lock again.|
|

1196
00:34:53,990 --> 00:34:55,790
0,240 240,360 360,1050 1050,1290 1440,1800
So the caller is, those
因此，来电者是，这些都是绝对肯定的，

1197
00:34:55,790 --> 00:34:56,900
0,60 60,450 450,690 690,840 840,1110
are absolutely sure,| that if
|如果调用者返回实际上将有助于再次锁定，

1198
00:34:56,900 --> 00:34:58,610
0,390 390,780 780,1140 1140,1410 1410,1710
caller returns will actually help

1199
00:34:58,610 --> 00:34:59,870
0,120 120,360 360,750 960,1140 1140,1260
to lock again,| so it's
|因此，再次安全地查看计数和完成

1200
00:34:59,870 --> 00:35:00,860
0,270 270,540 540,630 630,870 870,990
safe again to look at

1201
00:35:00,860 --> 00:35:02,000
0,300 300,390 390,750 750,960 960,1140
count and finished| and then
|然后再次呼叫等待。

1202
00:35:02,000 --> 00:35:03,220
0,180 180,390 390,690
call wait again.|
|

1203
00:35:03,690 --> 00:35:04,840
0,660
Okay?|
好吧?|

1204
00:35:05,160 --> 00:35:06,210
0,150 150,570 570,660 660,780 780,1050
So basically you know this
所以基本上你知道这个线程会进入休眠状态，

1205
00:35:06,210 --> 00:35:07,380
0,240 240,360 360,480 480,600 600,1170
thread will go to sleep,|
|

1206
00:35:07,800 --> 00:35:10,200
0,810 810,1410 1410,1950 1950,2190 2190,2400
{} and then the {goroutines
然后是收集选票的猩猩

1207
00:35:10,200 --> 00:35:11,970
0,450 450,1050 1080,1290 1290,1680 1680,1770
-} that are collecting the

1208
00:35:11,970 --> 00:35:13,650
0,600 870,1050 1050,1320 1320,1590 1590,1680
votes| the same code as
|与之前相同的代码，

1209
00:35:13,650 --> 00:35:15,900
0,630 660,900 900,1740 1740,1860 1860,2250
before,| my lock and unlock
|我的锁和解锁或推迟解锁

1210
00:35:15,900 --> 00:35:17,280
0,90 90,450 450,540 540,1050 1260,1380
or defer to unlock| and
|然后当你做完的时候

1211
00:35:17,280 --> 00:35:18,540
0,180 180,420 420,600 600,1080 1110,1260
then when you're done,| you
|你知道更新计数结束了，

1212
00:35:18,540 --> 00:35:20,640
0,210 210,630 630,960 960,1500 1770,2100
know updating count finished, {}|
|

1213
00:35:20,640 --> 00:35:22,110
0,420 420,960 960,1080 1080,1140 1140,1470
{there,two} primitives on {} condition
条件变量上有两个原语，

1214
00:35:22,110 --> 00:35:23,400
0,420 420,630 630,750 750,1200 1200,1290
variable,| one is signal and
|一个是信号，一个是广播。

1215
00:35:23,400 --> 00:35:24,720
0,120 120,210 210,930
one is broadcast.|
|

1216
00:35:24,720 --> 00:35:26,670
0,180 180,540 540,990 990,1680 1710,1950
{} And broadcast, basically {}
和广播，基本上是一个服务员的信号，

1217
00:35:26,670 --> 00:35:28,470
0,450 480,990 990,1080 1080,1350 1350,1800
signal which of one waiter,|
|

1218
00:35:28,470 --> 00:35:29,760
0,540 540,750 750,870 870,870 870,1290
broadcast which of all waiters,|
播报所有服务员中的哪一个，|

1219
00:35:30,120 --> 00:35:31,200
0,210 210,420 420,600 600,840 840,1080
{} there's only one waiter
这里只有一个服务员，

1220
00:35:31,200 --> 00:35:32,220
0,540 540,690 690,780 780,900 900,1020
here,| so we could have
|所以我们可以用它们中的任何一个。

1221
00:35:32,220 --> 00:35:33,150
0,240 240,390 390,600 600,690 690,930
used either one of them.|
|

1222
00:35:34,740 --> 00:35:36,000
0,450 450,630 630,960 960,1110 1110,1260
And so basically when it
所以基本上当它达到5，你知道，

1223
00:35:36,000 --> 00:35:37,710
0,690 750,870 870,1050 1050,1590 1620,1710
reaches you know 5,| you
|你知道多少分或10分，

1224
00:35:37,710 --> 00:35:39,030
0,150 150,330 330,630 630,720 720,1320
know some point or 10,|
|

1225
00:35:39,180 --> 00:35:40,800
0,570 570,720 720,1290 1290,1410 1410,1620
then you know, so every
然后你知道，所以每次完成都是递增的，

1226
00:35:40,800 --> 00:35:42,420
0,270 270,660 660,840 840,1440 1470,1620
time finished is incremented,| you
|你知道，主线会被唤醒，

1227
00:35:42,420 --> 00:35:43,600
0,630
know,

1228
00:35:43,600 --> 00:35:44,500
0,180 180,450 450,630 630,810 810,900
{} main thread will be

1229
00:35:44,500 --> 00:35:46,180
0,300 300,660 870,1020 1020,1110 1110,1680
woken up,| you can check
|你可以检查一下情况，然后继续前进。

1230
00:35:46,180 --> 00:35:47,440
0,90 90,750 750,870 870,1020 1020,1260
the condition and then keep

1231
00:35:47,440 --> 00:35:48,240
0,270
going.|
|

1232
00:35:48,580 --> 00:35:49,740
0,630
Okay?|
好吧?|

1233
00:35:50,260 --> 00:35:51,580
0,210 210,360 360,480 480,1080 1080,1320
So this is convenient,| so
所以这很方便，|因此，您可以将条件变量视为两个不同线程之间的协调原语

1234
00:35:51,580 --> 00:35:52,570
0,210 210,300 300,420 420,630 630,990
you can think about condition

1235
00:35:52,570 --> 00:35:54,760
0,510 510,660 660,810 810,1620 1620,2190
variables as a coordination primitive

1236
00:35:54,790 --> 00:35:57,280
0,870 1080,1260 1260,1560 1560,2070 2310,2490
between two different threads| and
|当你实际使用锁时，它们特别方便

1237
00:35:57,280 --> 00:35:58,570
0,120 120,450 450,870 870,1080 1080,1290
their particular convenient when you're

1238
00:35:58,570 --> 00:36:00,010
0,330 330,600 600,1170 1170,1260 1260,1440
actually using locks| you know
|你知道为了保护你的共享状态。

1239
00:36:00,010 --> 00:36:01,660
0,870 930,1020 1020,1290 1290,1380 1380,1650
for to protect your shared

1240
00:36:01,660 --> 00:36:02,540
0,390
state.|
|

1241
00:36:07,570 --> 00:36:09,400
0,990

1242
00:36:10,580 --> 00:36:13,130
0,210 210,510 510,870 870,1890 1950,2550
So here's the same {}
下面是使用通道的这个程序的相同实现。

1243
00:36:13,130 --> 00:36:15,680
0,990 1080,1740 1740,1860 1860,2280 2280,2550
implementation of this program using

1244
00:36:15,680 --> 00:36:16,900
0,720
channels.|
|

1245
00:36:16,930 --> 00:36:18,850
0,900 900,1350 1350,1710 1710,1770 1770,1920
{} And more or less
或多或少都是一样的工作方式，除了当然没有锁，

1246
00:36:18,850 --> 00:36:20,470
0,300 300,360 360,600 600,1110 1110,1620
worked the same way, except

1247
00:36:20,470 --> 00:36:21,640
0,150 150,330 330,510 510,660 660,1170
with of course no locks,|
|

1248
00:36:21,970 --> 00:36:24,010
0,450 450,780 810,1500 1560,1800 1800,2040
{} but, {} the main
但是，主线程创建通道，

1249
00:36:24,010 --> 00:36:26,440
0,180 180,540 540,1080 1080,1530 1530,2430
thread creates channel,| passes the
|传递Goroutine匿名函数，

1250
00:36:26,530 --> 00:36:28,720
0,420 420,870 870,1290 1290,1920 1920,2190
{goroutine -} anonymous function, {}|
|

1251
00:36:28,720 --> 00:36:29,800
0,330 330,570 570,900 900,1050 1050,1080
that's being created as a
这是作为一个单独的线程创建的，

1252
00:36:29,800 --> 00:36:31,840
0,330 330,780 1020,1350 1350,1650 1650,2040
separate thread,| {you,know} writes basically
|您知道，基本上将questVote写入通道

1253
00:36:31,840 --> 00:36:32,890
0,120 120,540 540,840 840,930 930,1050
the {requestVote -} to the

1254
00:36:32,890 --> 00:36:34,420
0,570 840,1050 1050,1200 1200,1260 1260,1530
channel| and then the main
|然后主线程基本上就会在这里阻塞

1255
00:36:34,420 --> 00:36:36,040
0,300 300,750 750,1140 1140,1440 1440,1620
thread basically blocks here right|
|

1256
00:36:36,040 --> 00:36:37,030
0,150 150,240 240,480 480,750 750,990
when it starts reading from
当它开始从频道读取时。

1257
00:36:37,030 --> 00:36:38,080
0,630
channel.|
|

1258
00:36:38,080 --> 00:36:39,370
0,360 360,690 690,780 780,1080 1080,1290
{} Once you actually get
一旦你真正得到了一些东西，当一些东西被写入通道时，就会解锁，

1259
00:36:39,370 --> 00:36:40,450
0,330 330,420 420,690 690,810 810,1080
something when something is written

1260
00:36:40,450 --> 00:36:41,890
0,120 120,210 210,750 750,930 930,1440
to the channel will unblock,|
|

1261
00:36:42,280 --> 00:36:43,600
0,150 150,420 420,510 510,570 570,1320
{you,know} look at the value|
你知道，看看它的价值|

1262
00:36:43,600 --> 00:36:45,400
0,510 510,720 720,1170 1170,1380 1380,1800
and its true add up|
和它真正的累加|

1263
00:36:45,400 --> 00:36:47,200
0,360 420,810 810,1170 1170,1500 1500,1800
and {} [auto] and always
和[AUTO]，并且始终递增完成。

1264
00:36:47,200 --> 00:36:48,520
0,330 330,870
increment finished.|
|

1265
00:36:48,830 --> 00:36:50,330
0,360 360,900 900,1080 1080,1230 1230,1500
And what's going on here
这里发生的一切都是正确的，

1266
00:36:50,330 --> 00:36:51,200
0,210 210,360 360,480 480,660 660,870
correct,| {} we don't need
|我们不需要锁，

1267
00:36:51,200 --> 00:36:52,670
0,420 420,540 540,720 720,1110 1110,1470
locks,| but {} count finished
|但计数已完成，未共享，

1268
00:36:52,670 --> 00:36:54,320
0,180 180,600 660,930 930,1140 1140,1650
not shared,| there's only one
|只有一个线程实际更新计数并完成

1269
00:36:54,320 --> 00:36:56,540
0,360 360,510 510,750 750,1440 1470,2220
thread that actually updates count

1270
00:36:56,540 --> 00:36:57,380
0,90 90,450 450,570 570,750 750,840
and finished| and that's the
|这就是主线。

1271
00:36:57,380 --> 00:36:58,460
0,240 240,510
main thread.|
|

1272
00:36:58,830 --> 00:37:00,100
0,780
Okay?|
好吧?|

1273
00:37:00,520 --> 00:37:01,740
0,660

1274
00:37:01,770 --> 00:37:03,120
0,750
The.|
这个。|

1275
00:37:03,240 --> 00:37:05,490
0,780 1080,1410 1410,1770 1770,2160 2160,2250
{} And this this you
这个，你知道的，主要的，你知道的，请求的线程，你知道的，基本上都是写到这个通道

1276
00:37:05,490 --> 00:37:07,050
0,120 120,450 450,540 540,1020 1020,1560
know the the main the

1277
00:37:07,620 --> 00:37:09,030
0,570 810,960 960,1200 1200,1320 1320,1410
requested for thread you know

1278
00:37:09,030 --> 00:37:10,410
0,330 330,810 810,960 960,1260 1260,1380
all basically just write to

1279
00:37:10,410 --> 00:37:12,060
0,240 240,1080 1080,1320 1320,1410 1410,1650
this channel| with a write
|利用可能在通道中并发的写入，

1280
00:37:12,060 --> 00:37:13,470
0,450 450,810 810,900 900,990 990,1410
concurrently perhaps in a channel,|
|

1281
00:37:13,770 --> 00:37:14,760
0,270 270,360 360,750 750,810 810,990
but the channels are one
但是通道是真正线程安全的东西之一，

1282
00:37:14,760 --> 00:37:15,480
0,60 60,150 150,360 360,510 510,720
of the things that Go

1283
00:37:15,480 --> 00:37:16,590
0,150 150,390 390,510 510,780 780,1110
that actually {} {thread-safe -},|
|

1284
00:37:16,590 --> 00:37:17,820
0,120 120,600 600,870 870,990 990,1230
so multiple threads can actually
因此，多个线程实际上可以写入通道。

1285
00:37:17,820 --> 00:37:19,140
0,300 300,390 390,480 480,900
write to the channel.|
|

1286
00:37:21,240 --> 00:37:22,770
0,360 390,600 600,900 900,1110 1110,1530
{} Any questions about this,
关于这个，关于解决方案的任何问题。

1287
00:37:24,310 --> 00:37:25,780
0,240 240,330 330,900
about the solution.|
|

1288
00:37:27,770 --> 00:37:28,970
0,300 300,540 540,750 750,960 960,1200
What was this thing about
这件事是怎么回事，就像有一个缓冲的频道。

1289
00:37:28,970 --> 00:37:30,940
0,180 180,540 540,660 660,1440
like having a buffer

1290
00:37:31,060 --> 00:37:33,100
0,240 240,360 360,990 1200,1620 1620,2040
for the channel.| Yeah, so,
|是的，所以，通常情况下，当你写到频道时

1291
00:37:33,100 --> 00:37:35,080
0,750 780,1350 1350,1560 1560,1680 1680,1980
{} normally when you're writing

1292
00:37:35,080 --> 00:37:36,550
0,90 90,240 240,570 570,690 690,1470
to the channel| and nobody's
|没有人从通道读取，或者没有线程从通道读取，

1293
00:37:36,580 --> 00:37:38,050
0,630 630,810 810,930 930,1320 1320,1470
reading from the channel or

1294
00:37:38,050 --> 00:37:38,950
0,180 180,420 420,540 540,750 750,900
no thread is reading from

1295
00:37:38,950 --> 00:37:40,360
0,120 120,630 720,990 990,1080 1080,1410
the channel,| then the sender
|则发送者将立即被阻止。

1296
00:37:40,360 --> 00:37:41,530
0,180 180,390 390,510 510,630 630,1170
will {immediately -} be blocked.|
|

1297
00:37:42,330 --> 00:37:44,850
0,840 990,1470 1470,1770 1770,2520 2520,2520
{} You can specify a
您可以指定一个缓冲区为10或20的通道

1298
00:37:45,540 --> 00:37:47,100
0,450 450,780 780,1290 1290,1410 1410,1560
channel has buffers {} of

1299
00:37:47,100 --> 00:37:50,310
0,390 390,480 480,1080 1320,2970 3000,3210
10 or 20| and that
|这允许通道具有多个值。

1300
00:37:50,310 --> 00:37:51,180
0,270 270,360 360,600 600,690 690,870
allows the channel to have

1301
00:37:51,180 --> 00:37:52,580
0,300 300,930
multiple values.|
|

1302
00:37:52,920 --> 00:37:54,300
0,390 570,900 900,1110 1110,1230 1230,1380
In {} in {6.824 -
在6.824个实验室中，

1303
00:37:54,300 --> 00:37:56,310
0,390 390,840 840,1110 1110,1410 1410,2010
-} labs,| I've never used
|我从未使用过缓冲频道

1304
00:37:56,400 --> 00:37:58,920
0,270 270,1380 1380,1830 1830,2130 2130,2520
{} buffered channels| and one
|我做了两三次中的一次，

1305
00:37:58,920 --> 00:37:59,640
0,90 90,210 210,390 390,660 660,720
of two three times I

1306
00:37:59,640 --> 00:38:01,140
0,180 180,540 540,780 780,1320 1320,1500
did it,| I regretted it,|
|我后悔了，|

1307
00:38:01,170 --> 00:38:02,910
0,390 450,1110 1260,1380 1380,1590 1590,1740
so generally I don't use
所以我一般不用它。

1308
00:38:02,910 --> 00:38:03,600
0,180
it.|
|

1309
00:38:04,180 --> 00:38:06,580
0,570 570,900 900,1320 1320,1770
But {this,is} important point.|
但这一点很重要。|

1310
00:38:06,780 --> 00:38:08,280
0,540 540,720 720,1080 1080,1410 1410,1500
{} This, this program is
这个，这个节目其实还不是很好，

1311
00:38:08,280 --> 00:38:09,630
0,240 240,510 510,720 720,990 990,1350
actually still not very good,|
|

1312
00:38:09,990 --> 00:38:14,700
0,780 1170,1890 1890,3000 3030,4110 4110,4710
for example when {} it
例如，当它在实践中无关紧要时，

1313
00:38:14,700 --> 00:38:15,900
0,240 240,480 480,540 540,1020 1020,1200
doesn't matter in practice,| {in,this}
|在这个特定的例子中，

1314
00:38:15,900 --> 00:38:17,130
0,450 450,870 870,1020 1020,1110 1110,1230
particular example,| but it does
|但它不会在某种程度上崩溃，这是我所能做到的，

1315
00:38:17,130 --> 00:38:19,920
0,330 330,1800 1830,2070 2070,2430 2430,2790
not in some collapse, that

1316
00:38:19,920 --> 00:38:22,050
0,390 390,450 450,660 1080,1620 1770,2130
could I do,| as soon
|一旦数到5，就会发生什么。

1317
00:38:22,050 --> 00:38:23,280
0,90 90,210 210,510 510,810 810,1230
as it reaches count 5

1318
00:38:23,280 --> 00:38:24,440
0,210 210,300 300,690
what will happen.|
|

1319
00:38:27,800 --> 00:38:30,080
0,270 270,600 600,1140 1200,1710 1860,2280
It stops listening for a
它停止监听新的频道，

1320
00:38:30,290 --> 00:38:31,970
0,330 330,780 900,1200 1200,1380 1380,1680
new channel,| so any other
|因此，任何其他线程都将被阻止。

1321
00:38:31,970 --> 00:38:33,320
0,540 570,870 990,1230 1230,1290 1290,1350
threads are going to be

1322
00:38:33,320 --> 00:38:35,000
0,480 750,1080 1080,1230 1230,1530 1530,1680
blocked.| Yeah, so basically it
|是的，所以基本上这意味着如果前5个线程投了赞成票，

1323
00:38:35,000 --> 00:38:35,870
0,240 240,390 390,540 540,630 630,870
means like if the first

1324
00:38:35,870 --> 00:38:38,160
0,510 510,720 720,1350 1350,1860
5 threads voted yes,|
|

1325
00:38:38,160 --> 00:38:39,210
0,330 330,420 420,600 600,870 870,1050
then the next 5 threads
那么接下来的五个线程将在这个通道中被阻止，对，

1326
00:38:39,210 --> 00:38:40,350
0,150 150,300 300,930 930,990 990,1140
will be blocked in this

1327
00:38:40,350 --> 00:38:41,700
0,360 390,780
channel, right,|
|

1328
00:38:42,480 --> 00:38:43,530
0,180 180,390 390,630 630,750 750,1050
{ -} they'll be hanging
他们会在附近徘徊。

1329
00:38:43,530 --> 00:38:44,580
0,510
around.|
|

1330
00:38:44,970 --> 00:38:46,980
0,510 510,1140 1140,1620 1710,1860 1860,2010
{} And {} in this
在这种情况下，这不会是一个问题，

1331
00:38:46,980 --> 00:38:47,700
0,180 180,240 240,450 450,630 630,720
case, it won't be a

1332
00:38:47,700 --> 00:38:48,810
0,390 390,720 720,930 930,1020 1020,1110
problem,| because most of you
|因为你们大多数人都注意到了，

1333
00:38:48,810 --> 00:38:50,340
0,210 210,420 420,660 660,1230 1230,1530
guys are most observed that,|
|

1334
00:38:50,340 --> 00:38:51,780
0,270 270,390 390,660 660,930 930,1440
if the main thread exit,
如果主线程退出，它实际上也会清除所有其他线程。

1335
00:38:52,080 --> 00:38:53,190
0,150 150,390 390,720 720,870 870,1110
it actually cleans up all

1336
00:38:53,190 --> 00:38:54,620
0,120 120,270 270,600 600,900
the other threads too.|
|

1337
00:38:54,810 --> 00:38:56,100
0,570 570,810 810,870 870,1200 1200,1290
{} But for example if
但例如，如果这是一项长期运行的服务，

1338
00:38:56,100 --> 00:38:57,090
0,150 150,270 270,420 420,750 750,990
this was a long running

1339
00:38:57,090 --> 00:38:58,800
0,750 1080,1320 1320,1470 1470,1620 1620,1710
service,| {} this would be
|这不是什么好事，

1340
00:38:58,800 --> 00:39:00,660
0,240 240,810 810,1260 1260,1470 1470,1860
not good,| basically we're leaking
|基本上我们是在泄露线索，

1341
00:39:00,660 --> 00:39:01,830
0,360 360,690 720,840 840,960 960,1170
threads here,| you know they're
|你知道他们被封锁在一边，在那个频道什么都不做，

1342
00:39:01,830 --> 00:39:03,360
0,300 300,630 630,720 720,780 780,1530
getting blocked on the side,

1343
00:39:03,360 --> 00:39:05,010
0,270 270,660 660,1110 1110,1290 1290,1650
doing nothing in that channel,|
|

1344
00:39:05,220 --> 00:39:07,410
0,330 330,510 510,990 990,1770 1770,2190
so that's quite inconvenient| and
所以这很不方便|这是一个需要注意的问题。

1345
00:39:07,560 --> 00:39:08,370
0,210 210,390 390,480 480,720 720,810
{} this is something to

1346
00:39:08,370 --> 00:39:09,600
0,270 270,480 480,780
watch out for.|
|

1347
00:39:09,980 --> 00:39:10,910
0,270 270,450 450,540 540,810 810,930
{} And this showed up
这一点出现在爬行器上，我想对许多人来说

1348
00:39:10,910 --> 00:39:11,690
0,60 60,120 120,540 540,630 630,780
in the crawler, I think

1349
00:39:11,690 --> 00:39:13,460
0,120 120,630 630,990 990,1140 1140,1770
for many people in the|
|

1350
00:39:13,490 --> 00:39:16,370
0,540 810,1320 2040,2580 2580,2670 2670,2880
and {} {flip,side} of this
另一方面，如果主线程在任何请求投票完成之前过早完成，

1351
00:39:16,370 --> 00:39:17,810
0,300 570,840 840,930 930,1140 1140,1440
is if the main thread

1352
00:39:17,810 --> 00:39:19,580
0,450 450,780 780,1140 1140,1620 1620,1770
and too early before any

1353
00:39:19,580 --> 00:39:20,390
0,60 60,150 150,480 480,720 720,810
of the {requestVotes -} are

1354
00:39:20,390 --> 00:39:21,920
0,420 660,1020 1020,1200 1200,1320 1320,1530
done,| {} then you also
|那么你也有一个问题

1355
00:39:21,920 --> 00:39:23,000
0,120 120,180 180,600 690,930 930,1080
have a problem| and so
|因此，对线程的管理实际上通常是一个棘手的问题。

1356
00:39:23,000 --> 00:39:24,470
0,360 360,900 900,990 990,1320 1320,1470
there's management of threads that

1357
00:39:24,470 --> 00:39:26,630
0,480 480,1380 1380,1710 1710,1830 1830,2160
actually is often a tricky

1358
00:39:26,630 --> 00:39:27,380
0,330
issue.|
|

1359
00:39:29,040 --> 00:39:29,580
0,120 120,240 240,270 270,390 390,540
Is there a way to
有没有一种方法可以在不退出Main的情况下杀死线程？

1360
00:39:29,580 --> 00:39:31,890
0,270 270,330 330,630 630,1140 1740,2310
kill the thread without exiting

1361
00:39:31,890 --> 00:39:32,980
0,150 150,480
from main?|
|

1362
00:39:33,530 --> 00:39:35,150
0,990 990,1230 1230,1320 1320,1410 1410,1620
{} Well, you can send
好的，你可以把它发送给一个变量，在某些通道上，这个值看起来像是请退出，

1363
00:39:35,150 --> 00:39:36,560
0,90 90,150 150,450 450,1020 1020,1410
it to a variable a

1364
00:39:36,590 --> 00:39:38,150
0,510 510,630 630,1020 1020,1350 1350,1560
value on some channels seemed

1365
00:39:38,150 --> 00:39:40,340
0,150 150,390 390,840 1170,1980 1980,2190
like please exit,| but you
|但你必须自己协调它。

1366
00:39:40,340 --> 00:39:41,690
0,150 150,240 240,720 720,840 840,1350
have to coordinate it yourself.|
|

1367
00:39:47,250 --> 00:39:49,320
0,600 930,1140 1140,1230 1230,1590 1590,2070
I'm gonna go back to
我将回到关于条件变量的一个很酷的事情上，

1368
00:39:49,350 --> 00:39:50,220
0,270 270,360 360,480 480,720 720,870
one of the things that

1369
00:39:50,220 --> 00:39:53,240
0,300 300,510 510,1140 1140,2400
actually is cool about

1370
00:39:53,620 --> 00:39:57,220
0,420 420,1140 1830,2310 2310,2760 2880,3600
condition variables,| is that, {}
|原则上，你可能会认为这里也存在同样的问题，

1371
00:39:58,860 --> 00:39:59,850
0,210 210,540 540,630 630,780 780,990
in principle you might think

1372
00:39:59,850 --> 00:40:00,570
0,90 90,180 180,270 270,510 510,720
you have the same issue

1373
00:40:00,570 --> 00:40:02,760
0,330 330,900 1170,1710 1710,2040 2040,2190
exists here,| {} we're like
|我们就像这个线程实际运行

1374
00:40:02,760 --> 00:40:04,260
0,210 210,450 450,720 720,1320 1350,1500
this thread actually runs {}|
|

1375
00:40:04,260 --> 00:40:06,720
0,780 810,1650 1650,1830 1830,2070 2070,2460
and {} in this thread,|
在这个帖子里，|

1376
00:40:06,750 --> 00:40:09,660
0,450 480,930 1380,2010 2010,2730 2730,2910
{} and {} it might
它可能会被屏蔽，

1377
00:40:09,660 --> 00:40:10,860
0,150 150,480 480,600 600,990 990,1200
get blocked,| like {for,example} if
|比如，如果达到5美元，

1378
00:40:10,860 --> 00:40:12,630
0,300 300,750 750,930 930,1170 1170,1770
it reach you know 5,|
|

1379
00:40:12,660 --> 00:40:13,590
0,90 90,300 300,450 450,690 690,930
you know this main thread
你知道这条主线，你会感觉到它在做它的事情，

1380
00:40:13,590 --> 00:40:15,390
0,480 480,600 600,990 990,1350 1350,1800
will {you,know} perceive doing its

1381
00:40:15,390 --> 00:40:17,100
0,420 870,1200 1200,1470 1470,1530 1530,1710
thing,| {} while the other
|而其他人可能还在坐在这里。

1382
00:40:17,100 --> 00:40:18,480
0,270 270,360 360,630 630,990 990,1380
guys are still maybe actually

1383
00:40:18,480 --> 00:40:19,700
0,270 270,480 480,810
sitting in here.|
|

1384
00:40:20,080 --> 00:40:21,910
0,420 480,1020 1020,1470 1470,1650 1650,1830
{} Notice these in this
请注意，在这种情况下，它们不会被阻止，

1385
00:40:21,910 --> 00:40:23,710
0,510 600,930 930,1140 1140,1260 1260,1800
case, they won't be blocked,|
|

1386
00:40:23,830 --> 00:40:25,540
0,690 690,1140 1140,1350 1350,1620 1620,1710
{} because will grab the
因为会抢到锁，

1387
00:40:25,540 --> 00:40:27,520
0,480 720,1410 1410,1500 1500,1680 1680,1980
lock,| then you know does
|那么你知道这东西是做广播的吗，

1388
00:40:27,520 --> 00:40:29,380
0,360 360,570 570,1320 1320,1380 1380,1860
{the,thing} {does,a} broadcast,| the broadcast
|广播实际上不是阻挡操作，

1389
00:40:29,380 --> 00:40:30,520
0,150 150,420 420,660 660,720 720,1140
is actually not a blocking

1390
00:40:30,520 --> 00:40:32,080
0,510 570,840 840,1350 1350,1410 1410,1560
operation,| so unlike you know
|所以不同于你所知道的向通道写入，

1391
00:40:32,080 --> 00:40:33,160
0,270 270,360 360,450 450,900 900,1080
writing to a channel,| that
|这是一次封锁行动，

1392
00:40:33,160 --> 00:40:34,240
0,90 90,150 150,540 540,990 990,1080
is a blocking operation,| if
|如果没有人在听，

1393
00:40:34,240 --> 00:40:36,040
0,390 390,570 570,1080 1290,1530 1530,1800
nobody is listening,| the {cond.Broadcast
|Cond.Broadcast不是阻止操作。

1394
00:40:36,040 --> 00:40:37,390
0,480 480,600 600,900 900,960 960,1350
-} is not a blocking

1395
00:40:37,390 --> 00:40:38,360
0,540
operation.|
|

1396
00:40:38,450 --> 00:40:39,380
0,180 180,330 330,570 570,780 780,930
So this actually works out
所以这实际上是在这个特别的项目中起作用的，

1397
00:40:39,380 --> 00:40:40,610
0,90 90,240 240,600 600,1170 1170,1230
in this particular program,| you
|你自己知道的是正确的。

1398
00:40:40,610 --> 00:40:42,410
0,120 120,300 300,990 1020,1320 1320,1800
know by itself {} correctly.|
|

1399
00:40:43,690 --> 00:40:44,820
0,600
Okay?|
好吧?|

1400
00:40:49,200 --> 00:40:50,440
0,300 300,690
Okay, good.|
好的，很好。|

1401
00:40:50,700 --> 00:40:52,260
0,450 450,690 690,1050 1050,1440 1470,1560
Any further questions about you
关于你知道这两个例子还有什么问题吗？

1402
00:40:52,260 --> 00:40:53,790
0,120 120,600 630,780 780,1320 1320,1530
know these two examples just

1403
00:40:53,790 --> 00:40:54,660
0,60 60,300
to do?|
|

1404
00:41:00,480 --> 00:41:01,980
0,420 420,990 990,1200 1200,1380 1380,1500
Okay, then let's talk about
好吧，那我们来谈谈爬行器吧。

1405
00:41:01,980 --> 00:41:05,260
0,60 60,570 840,2700
the crawler. {}|
|

1406
00:41:05,700 --> 00:41:07,650
0,450 450,840 1020,1620 1620,1680 1680,1950
So the crawler is also
因此，爬虫也是并发编程的一个更现实的例子。

1407
00:41:07,650 --> 00:41:09,030
0,120 120,360 360,840 840,1290 1290,1380
a more realistic example of

1408
00:41:09,030 --> 00:41:10,640
0,330 330,990
concurrent programming.|
|

1409
00:41:14,550 --> 00:41:15,900
0,480 480,630 630,810 810,1110 1110,1350
Yeah, and just remind you,|
是啊，提醒你一下，|

1410
00:41:15,900 --> 00:41:19,560
0,930 1350,2040 2040,2160 2160,2550 2580,3660
{ -} you know basically
你知道，基本上这个想法是，

1411
00:41:19,860 --> 00:41:21,210
0,240 240,720 720,810 810,1050 1050,1350
the idea is that,| you
|您从一些网页的URL开始，

1412
00:41:21,210 --> 00:41:23,100
0,480 600,900 900,1530 1530,1710 1710,1890
started with url for some

1413
00:41:23,100 --> 00:41:25,500
0,180 180,750 1110,1560 1560,1830 1830,2400
web page,| {} you fetch
|获取您获取的可能包含更多URL的网页，

1414
00:41:25,530 --> 00:41:27,000
0,600 600,900 900,990 990,1140 1140,1470
you fetch the web page

1415
00:41:27,000 --> 00:41:28,500
0,120 120,330 330,480 480,720 720,1500
that might have more urls,|
|

1416
00:41:28,940 --> 00:41:30,590
0,390 390,660 660,720 720,1110 1110,1650
and when you basically proceed,|
当你基本上继续的时候，|

1417
00:41:30,590 --> 00:41:31,760
0,90 90,270 270,570 570,870 870,1170
you know then fetching those
你知道，然后取回那些网页，

1418
00:41:31,760 --> 00:41:33,110
0,180 180,870 870,960 960,1080 1080,1350
web pages,| you know looking
|你知道，看着这些URL，你就会继续前进。

1419
00:41:33,110 --> 00:41:34,250
0,90 90,360 360,960 960,1080 1080,1140
at those urls and you

1420
00:41:34,250 --> 00:41:35,380
0,210 210,480
keep going.|
|

1421
00:41:35,730 --> 00:41:36,870
0,180 180,540 540,630 630,720 720,1140
The idea is to crawl
这个想法基本上是在你所知道的整个互联网上爬行所有存在的网页

1422
00:41:36,870 --> 00:41:38,550
0,360 360,450 450,750 750,1290 1470,1680
basically the whole Internet {you,know}

1423
00:41:38,550 --> 00:41:39,390
0,120 120,240 240,330 330,510 510,840
for all the web pages

1424
00:41:39,390 --> 00:41:41,220
0,210 210,660 660,1170 1620,1770 1770,1830
that are exist| and of
|当然，一些URL可能指向您已经访问过的网页，

1425
00:41:41,220 --> 00:41:43,200
0,420 630,1080 1110,1560 1560,1740 1740,1980
course some urls might point

1426
00:41:43,200 --> 00:41:44,700
0,420 450,840 840,1050 1050,1380 1380,1500
back to a {web,page} you

1427
00:41:44,700 --> 00:41:46,320
0,210 210,270 270,840 840,1170 1170,1620
already {} visited,| and so
|因此，目标是实际上不会两次访问同一个网页。

1428
00:41:46,440 --> 00:41:47,700
0,450 450,600 600,720 720,960 960,1260
goal is to actually not

1429
00:41:47,700 --> 00:41:49,530
0,300 300,1020 1050,1410 1410,1590 1590,1830
visit the same web page

1430
00:41:49,530 --> 00:41:50,560
0,630
twice.|
|

1431
00:41:51,070 --> 00:41:52,380
0,600

1432
00:41:52,380 --> 00:41:52,950
0,120 120,240 240,300 300,480 480,570
And so the goal of
所以这个练习的目标是几个目标，

1433
00:41:52,950 --> 00:41:54,390
0,60 60,570 570,690 690,1140 1140,1440
the {exercise,is} a couple of

1434
00:41:54,390 --> 00:41:55,110
0,300 300,360 360,480 480,630 630,720
goals,| if you want to
|如果你想达到，对，

1435
00:41:55,110 --> 00:41:57,660
0,750 990,1410 1410,1890 1890,2250 2250,2550
achieve, right,| one is IO
|一个是IO并发性。

1436
00:41:57,660 --> 00:41:58,980
0,810
concurrency.|
|

1437
00:42:02,000 --> 00:42:03,060
0,240

1438
00:42:03,180 --> 00:42:05,010
0,240 240,540 540,1050 1050,1200 1200,1830
The fetch operation is {}
获取操作IS可能需要很长时间，

1439
00:42:05,040 --> 00:42:06,360
0,300 300,480 480,540 540,750 750,1320
may take a long time,|
|

1440
00:42:06,360 --> 00:42:07,740
0,360 360,540 540,930 930,1140 1140,1380
maybe it's a web page,
也许它是一个网页，它在世界的另一边，

1441
00:42:07,740 --> 00:42:08,490
0,240 240,330 330,420 420,570 570,750
it's on the other side

1442
00:42:08,490 --> 00:42:10,110
0,90 90,180 180,600 600,1350 1410,1620
of the world,| {you,know} it
|你知道它是通过低速网络传输的，

1443
00:42:10,110 --> 00:42:11,670
0,180 180,300 300,510 510,1170 1350,1560
goes over slow networks,| and
|当您的一个线程正在获取该页面时

1444
00:42:11,670 --> 00:42:13,050
0,450 450,690 690,780 780,1080 1080,1380
while {your -} one {thread,is}

1445
00:42:13,050 --> 00:42:14,190
0,210 210,270 270,570 570,780 780,1140
sort of fetching that page|
|

1446
00:42:14,190 --> 00:42:14,880
0,90 90,330 330,510 510,570 570,690
you would like to be
您希望能够获取其他页面，

1447
00:42:14,880 --> 00:42:17,850
0,210 210,300 300,540 540,1050 1290,2970
able to fetch other other

1448
00:42:17,880 --> 00:42:20,490
0,270 270,780 1380,1920 1920,2280 2280,2610
other pages,| another goals is
|另一个目标是正确性目标或绩效目标，

1449
00:42:20,490 --> 00:42:22,950
0,420 420,840 840,1260 1710,2130 2130,2460
correctness goal or performance goal,|
|

1450
00:42:22,950 --> 00:42:25,440
0,510 600,990 990,1410 1620,2040 2040,2490
namely fetch one fetch url
即一次取回一个取回URL。

1451
00:42:25,440 --> 00:42:26,340
0,510
once.|
|

1452
00:42:30,000 --> 00:42:31,410
0,600 600,690 690,990 990,1290 1290,1410
And you know remember your
你知道，记住你的目标是开发多个核心，

1453
00:42:31,410 --> 00:42:32,400
0,300 300,360 360,540 540,600 600,990
goals are like to exploit

1454
00:42:32,400 --> 00:42:33,660
0,330 330,840 840,930 930,1080 1080,1260
multiple cores,| you know if
|你知道，如果你有多个核心并行工作。

1455
00:42:33,660 --> 00:42:35,670
0,90 90,300 300,600 600,1170 1470,2010
you have multiple cores doing

1456
00:42:35,670 --> 00:42:37,080
0,240 240,300 300,870
work in parallelism.|
|

1457
00:42:42,270 --> 00:42:43,400
0,600
Okay?|
好吧?|

1458
00:42:43,740 --> 00:42:45,780
0,540 750,1080 1080,1740 1740,1860 1860,2040
So, {} what I'd like
所以，在真正讨论并发解决方案之前，我想做的是，

1459
00:42:45,780 --> 00:42:48,720
0,480 510,1200 1230,1830 1830,2370 2370,2940
to do before actually {}

1460
00:42:49,560 --> 00:42:51,180
0,330 330,570 570,630 630,1200 1200,1620
talking about the concurrent solutions,|
|

1461
00:42:51,180 --> 00:42:52,890
0,420 510,750 750,870 870,1200 1200,1710
first let me show you
首先，让我向您展示一个简单的系列解决方案，

1462
00:42:52,920 --> 00:42:55,650
0,630 630,1260 1260,1650 1650,2220 2460,2730
a simple serial solution, {}|
|

1463
00:42:55,650 --> 00:42:58,520
0,150 150,300 300,1380 1800,2430
so that we, {}
所以我们，你知道，我们有一些东西可以作为基线来谈论。

1464
00:42:58,850 --> 00:42:59,840
0,210 210,330 330,420 420,660 660,990
{you,know} we have something to

1465
00:42:59,840 --> 00:43:01,280
0,300 300,630 630,810 810,870 870,1440
talk about as a baseline.|
|

1466
00:43:12,240 --> 00:43:14,130
0,1050 1080,1290 1290,1620 1620,1740 1740,1890
So, so I have three
所以，我这里有三个解决方案。

1467
00:43:14,130 --> 00:43:15,960
0,480 480,660 660,1110 1140,1530 1530,1830
solutions in here. { -}|
|

1468
00:43:16,230 --> 00:43:17,840
0,270 390,840

1469
00:43:19,040 --> 00:43:20,540
0,810
{Run,them},
跑吧，跑吧，

1470
00:43:21,020 --> 00:43:22,480
0,960
run,|
|

1471
00:43:26,080 --> 00:43:27,550
0,240 240,570 570,960 960,1260 1290,1470
a serious solution, and {}
一个严肃的解决方案，其中一个互斥体是其中一个通道，

1472
00:43:27,550 --> 00:43:28,360
0,180 180,240 240,330 330,480 480,810
one of the {mutex -}

1473
00:43:28,360 --> 00:43:29,380
0,60 60,240 240,300 300,360 360,1020
is, one of the channels,|
|

1474
00:43:29,440 --> 00:43:30,820
0,630 630,750 750,900 900,1050 1050,1380
{} you know you see
你知道，你看到它们产生的结果或多或少是一样的，

1475
00:43:30,820 --> 00:43:32,740
0,960 1200,1560 1560,1590 1590,1800 1800,1920
the more or less they

1476
00:43:32,740 --> 00:43:34,090
0,330 330,390 390,720 720,1200 1200,1350
produce the same results,| {you,know}
|你知道有两个找到了，一个失踪了，两个找到了。

1477
00:43:34,090 --> 00:43:35,410
0,180 180,630 630,840 840,1200 1200,1320
two found, one missing, two

1478
00:43:35,410 --> 00:43:36,440
0,540
found.|
|

1479
00:43:36,470 --> 00:43:37,430
0,210 210,330 330,510 510,840 840,960
{} The only difference is
唯一的区别是输出的顺序偶尔会略有不同

1480
00:43:37,430 --> 00:43:38,420
0,270 270,390 390,780 780,870 870,990
that the order of the

1481
00:43:38,420 --> 00:43:39,650
0,330 330,660 660,990 990,1170 1170,1230
output slightly different once in

1482
00:43:39,650 --> 00:43:40,430
0,60 60,330 330,420 420,540 540,780
a while| and of course
|当然，它还必须进行并发操作。

1483
00:43:40,430 --> 00:43:41,780
0,120 120,390 390,570 570,840 840,1350
{it,had} to do {} concurrency.|
|

1484
00:43:43,880 --> 00:43:45,740
0,270 270,870 1080,1530 1530,1620 1620,1860
Okay, so, {} the main
好的，所以，主函数是按顺序调用的

1485
00:43:45,740 --> 00:43:47,040
0,720
function

1486
00:43:47,100 --> 00:43:49,290
0,720 720,810 840,1350 1350,1620 1620,2190
{ -} calls in serial|
|

1487
00:43:49,290 --> 00:43:51,240
0,270 270,480 480,840 840,1560 1590,1950
with the starting url, fetcher
使用起始url、Fetcher，然后是一个空映射。

1488
00:43:51,240 --> 00:43:52,680
0,360 390,810 810,1050 1050,1170 1170,1440
{} and then an empty

1489
00:43:52,680 --> 00:43:53,640
0,480
map.|
|

1490
00:43:54,220 --> 00:43:56,200
0,390 390,840 960,1140 1140,1500 1500,1980
And then the serial solution
然后级数解基本上是一种标准的顺序递归解，

1491
00:43:56,200 --> 00:43:57,040
0,120 120,480 480,540 540,750 750,840
is basically {} sort of

1492
00:43:57,040 --> 00:44:00,130
0,600 630,1380 1410,2310 2310,2610 2640,3090
standard {} sequential {} recursive

1493
00:44:00,130 --> 00:44:02,230
0,630 1050,1350 1350,1500 1500,1770 1770,2100
solution,| {} we first check
|我们首先检查是否已经访问了传递给我们的URL，

1494
00:44:02,230 --> 00:44:03,370
0,240 240,360 360,630 630,1050 1050,1140
if we already visited the

1495
00:44:03,370 --> 00:44:04,570
0,450 450,660 660,960 960,1080 1080,1200
url that's passed {into -}

1496
00:44:04,570 --> 00:44:05,420
0,390
us,|
|

1497
00:44:05,420 --> 00:44:06,320
0,270 270,420 420,540 540,780 780,900
{} if we didn't know
如果我们不知道我们会立即返回，

1498
00:44:06,320 --> 00:44:07,730
0,90 90,330 330,780 780,1290 1290,1410
we return immediately,| otherwise we
|否则我们就会纪念这次访问，

1499
00:44:07,730 --> 00:44:09,560
0,360 360,510 510,1050 1350,1560 1560,1830
mark this visit,| we'll fetch
|我们去拿URL，

1500
00:44:09,560 --> 00:44:10,730
0,60 60,750 750,900 900,1080 1080,1170
the url,| that this is
|这是一堆URL，

1501
00:44:10,730 --> 00:44:12,770
0,90 90,270 270,390 390,1380 1770,2040
a bunch of urls, {}|
|

1502
00:44:12,770 --> 00:44:13,670
0,240 240,480 480,660 660,810 810,900
we look for all the
我们查找所有的URL

1503
00:44:13,670 --> 00:44:15,560
0,810 930,1080 1080,1230 1230,1590 1590,1890
urls| and go basically zero
|再一次基本归零，对吧，

1504
00:44:15,560 --> 00:44:17,000
0,450 540,870 870,1110 1110,1200 1200,1440
again, right,| this is your
|这就是您的顺序解决方案，这正是我所期望的。

1505
00:44:17,000 --> 00:44:18,590
0,480 480,1080 1080,1260 1260,1500 1500,1590
sequential solution, that's what I

1506
00:44:18,590 --> 00:44:19,580
0,450
expected.|
|

1507
00:44:19,760 --> 00:44:20,840
0,420 420,510 510,690 690,870 870,1080
And you know your goal
你知道你的目标，基本上就是写这个的并发版本。

1508
00:44:20,840 --> 00:44:22,160
0,150 150,270 270,810 810,1080 1080,1320
which is basically {} write

1509
00:44:22,160 --> 00:44:23,780
0,360 360,690 690,780 780,1110
concurrent version of this.|
|

1510
00:44:24,140 --> 00:44:26,760
0,510 720,930 930,1380 1440,2070
{} And so, {}
所以，我想做的是让课堂变得更具互动性，

1511
00:44:27,100 --> 00:44:28,180
0,570 600,870 870,900 900,1020 1020,1080
{} what I like to

1512
00:44:28,180 --> 00:44:29,020
0,120 120,270 270,570 570,660 660,840
do is actually to make

1513
00:44:29,020 --> 00:44:29,650
0,60 60,300 300,330 330,480 480,630
the class a little bit

1514
00:44:29,650 --> 00:44:31,330
0,630 690,750 750,750 1230,1440 1440,1680
interactive,| {} I wanna go
|我想换到休息室

1515
00:44:31,330 --> 00:44:32,800
0,300 300,510 510,630 630,1050 1050,1470
switch over to breakout rooms|
|

1516
00:44:32,830 --> 00:44:34,030
0,570 570,840 840,930 930,1080 1080,1200
and what we're gonna do
我们要做的基本上是让你们中的四到五个人在一个休息室里呆大约十分钟

1517
00:44:34,030 --> 00:44:37,210
0,150 150,750 1230,2580 2610,3030 3030,3180
is basically put four to

1518
00:44:37,210 --> 00:44:38,380
0,540 570,780 780,1050 1050,1110 1110,1170
five of you in a

1519
00:44:38,380 --> 00:44:40,570
0,270 270,690 690,1140 1680,1950 1950,2190
single breakout room for about

1520
00:44:40,570 --> 00:44:42,280
0,150 150,720 990,1500 1500,1560 1560,1710
ten minutes| and I would
|我希望你们彼此分享你们的解决方案，并进行讨论，

1521
00:44:42,280 --> 00:44:43,690
0,210 210,330 330,420 420,660 660,1410
like you to do is

1522
00:44:43,690 --> 00:44:45,130
0,270 270,390 390,990 1020,1290 1290,1440
share your solution with each

1523
00:44:45,130 --> 00:44:46,450
0,210 210,300 300,630 630,840 1140,1320
other and discuss it,| so
|所以也许最好的办法就是

1524
00:44:46,450 --> 00:44:48,100
0,510 510,1170 1200,1500 1500,1590 1590,1650
maybe the best way to

1525
00:44:48,100 --> 00:44:49,210
0,180 180,510 510,600 600,840 840,1110
go about it is {}|
|

1526
00:44:49,330 --> 00:44:50,950
0,420 420,540 540,1140 1170,1230 1230,1620
one of you, you know
你们中的一个人，你知道你进了一个房间，

1527
00:44:51,100 --> 00:44:52,120
0,150 150,270 270,450 450,540 540,1020
you get into a room,|
|

1528
00:44:52,240 --> 00:44:53,140
0,330 330,390 390,480 480,780 780,900
one of the persons in
房间里的一个人，

1529
00:44:53,140 --> 00:44:55,090
0,90 90,510 540,1110 1110,1470 1470,1950
the room,| basically screen shares
|Screen基本上分享了他们的解决方案，并讨论了其中一个问题，

1530
00:44:55,090 --> 00:44:57,370
0,360 360,1020 1350,1830 1830,2190 2190,2280
their solution and discuss what

1531
00:44:57,370 --> 00:44:58,090
0,90 90,240 240,570 570,630 630,720
has been one of the

1532
00:44:58,090 --> 00:44:59,710
0,480 480,870 870,1110 1110,1380 1380,1620
issues,| that you see running
|你所看到的撞上

1533
00:44:59,710 --> 00:45:00,850
0,360 360,600 600,810 810,1020 1020,1140
into| and other people can
|其他人可以评论或分享其他解决方案，

1534
00:45:00,850 --> 00:45:02,680
0,480 480,750 750,990 990,1170 1170,1830
comment or share other solutions,|
|

1535
00:45:02,920 --> 00:45:03,880
0,330 330,540 540,690 690,900 900,960
let's just get into a
让我们来讨论一下，见见班上的其他同学。

1536
00:45:03,880 --> 00:45:04,900
0,480 480,570 570,750 750,870 870,1020
discussion and meet some other

1537
00:45:04,900 --> 00:45:06,100
0,300 300,360 360,450 450,930
students in the class.|
|

1538
00:45:07,480 --> 00:45:09,120
0,210 210,540 540,750 750,1080
Any questions about that?|
对此有什么问题吗？|

1539
00:45:11,950 --> 00:45:13,450
0,150 150,510 600,960 960,1410 1410,1500
Okay, good, {} let me
好的，很好，让我回到过去，

1540
00:45:13,450 --> 00:45:14,820
0,180 180,510 510,780
go back,| to
|再次分享我的屏幕，

1541
00:45:15,550 --> 00:45:17,620
0,360 360,480 480,810 810,1320 1800,2070
sharing my screen again,| can
|大家能不能再看到我的屏幕。

1542
00:45:17,620 --> 00:45:18,370
0,270 270,420 420,540 540,690 690,750
everybody see my { -}

1543
00:45:18,370 --> 00:45:19,600
0,270 270,690
screen again.|
|

1544
00:45:21,600 --> 00:45:23,120
0,330 330,570 570,990
Yep, looks good.|
是的，看起来不错。|

1545
00:45:23,120 --> 00:45:24,740
0,480 510,780 780,1110
Good, thank you.|
很好，谢谢你。|

1546
00:45:29,140 --> 00:45:31,390
0,330 330,810 1200,2010 2010,2160 2160,2250
Okay, so hopefully that was
好的，希望这很有趣，

1547
00:45:31,390 --> 00:45:34,420
0,480 720,1470 1620,2550 2550,2940 2940,3030
interesting,| {} let me you
|让我知道你谈论你知道我有什么解决方案。

1548
00:45:34,420 --> 00:45:35,860
0,360 390,690 690,1080 1080,1200 1200,1440
know talk about you know

1549
00:45:35,860 --> 00:45:37,750
0,420 480,1050 1050,1200 1200,1410 1410,1890
the solutions that I have.|
|

1550
00:45:38,380 --> 00:45:39,490
0,210 210,450 450,750 750,1050 1050,1110
{} There {} posted on
有张贴在时间表页面上的，如果你还没有，

1551
00:45:39,490 --> 00:45:40,600
0,60 60,420 420,720 720,960 960,1110
the schedule page, if you

1552
00:45:40,600 --> 00:45:42,100
0,390 390,900
haven't, {}|
|

1553
00:45:42,130 --> 00:45:44,950
0,690 870,1050 1050,1170 1170,1650 2190,2820
{} you can look concurrently
你可以和我同时看，如果你想的话。

1554
00:45:44,950 --> 00:45:45,670
0,210 210,330 330,420 420,510 510,720
with me, if you want

1555
00:45:45,670 --> 00:45:46,560
0,300
to.|
|

1556
00:45:46,770 --> 00:45:49,080
0,660 1260,1410 1410,1860 1890,2130 2130,2310
{} You should you know
你应该知道，让我先看一遍互斥锁版本

1557
00:45:49,080 --> 00:45:50,370
0,150 150,240 240,540 540,720 720,1290
let me walk through the

1558
00:45:51,060 --> 00:45:52,140
0,210 210,450 450,720 720,990 990,1080
{mutex -} version first| and
|然后我会在一秒钟内穿过海峡，

1559
00:45:52,140 --> 00:45:54,060
0,120 120,240 240,480 480,690 690,1920
then I'll walk through the

1560
00:45:54,210 --> 00:45:57,960
0,630 630,1020 1380,1950 2130,2970 3120,3750
channel one second,| so here's
|这就是互斥体，

1561
00:45:57,960 --> 00:45:59,060
0,540
the

1562
00:45:59,990 --> 00:46:02,060
0,480 480,720 720,1080 1080,1530 1530,2070
mutex one,| mutex one the
|互斥锁1具有映射和互斥锁的声明结构

1563
00:46:02,120 --> 00:46:03,980
0,420 420,480 480,1050 1260,1680 1680,1860
{declareation -} struct with the

1564
00:46:03,980 --> 00:46:05,000
0,270 270,510 510,600 600,900 900,1020
have both the map and

1565
00:46:05,000 --> 00:46:06,920
0,60 60,210 210,690 690,1110 1560,1920
the {mutex -}| and the
|而地图需要由互斥体保护，

1566
00:46:06,950 --> 00:46:08,000
0,330 330,480 480,570 570,690 690,1050
map needs to be protected

1567
00:46:08,000 --> 00:46:09,170
0,150 150,660 660,900 900,1020 1020,1170
by mutex,| because it's going
|因为这将是对地图的并发访问，

1568
00:46:09,170 --> 00:46:10,220
0,60 60,150 150,540 540,930 930,1050
to be concurrent access to

1569
00:46:10,220 --> 00:46:12,440
0,90 90,720 1350,1680 1680,1800 1800,2220
the map,| map by itself
|它本身并不是线程安全的，

1570
00:46:12,440 --> 00:46:13,190
0,90 90,300 300,450 450,630 630,750
it's not thread-safe,| it's a
|这取决于程序员是否真正使映射是线程安全的。

1571
00:46:13,190 --> 00:46:14,210
0,210 210,360 360,420 420,540 540,1020
it's up to the programmer

1572
00:46:14,210 --> 00:46:15,650
0,90 90,300 300,510 510,1140 1170,1440
to actually make the map

1573
00:46:15,650 --> 00:46:16,700
0,240 240,630
{thread-safe -}.|
|

1574
00:46:17,330 --> 00:46:18,500
0,150 150,210 210,840 840,990 990,1170
And the concurrently {mutex -}
而并发互斥体又短了一个类似于序列互斥体，

1575
00:46:18,500 --> 00:46:19,790
0,240 240,450 450,840 840,1200 1200,1290
one more short similar to

1576
00:46:19,790 --> 00:46:21,590
0,90 90,540 540,990 990,1380 1380,1800
the serial one,| except whenever
|除了有舞台的时候，

1577
00:46:21,590 --> 00:46:23,030
0,510 510,840 840,1200 1200,1380 1380,1440
there's stage,| basically takes a
|基本上就是出去走走，

1578
00:46:23,030 --> 00:46:24,230
0,300 300,480 630,870 870,1080 1080,1200
walk out,| {you,know} so we'll
|你知道，所以我们会拿走锁，

1579
00:46:24,230 --> 00:46:25,520
0,180 180,270 270,720 750,1110 1110,1290
take the lock,| we look
|我们查看URL已经被取回，

1580
00:46:25,520 --> 00:46:27,380
0,90 90,1080 1110,1530 1530,1680 1680,1860
at the url has already

1581
00:46:27,380 --> 00:46:28,820
0,150 150,720 840,1050 1050,1320 1320,1440
being fetched,| it hasn't been
|它尚未从标记中提取，现在已被提取。

1582
00:46:28,820 --> 00:46:29,810
0,270 270,390 390,450 450,780 780,990
fetched from the markd has

1583
00:46:29,810 --> 00:46:31,160
0,210 210,450 450,960
now being fetched.|
|

1584
00:46:31,250 --> 00:46:32,570
0,210 210,450 450,630 630,1110 1110,1320
What hasn't been fetched and
还没拿到的我们就锁上了，

1585
00:46:32,570 --> 00:46:34,940
0,270 270,720 1140,1500 1500,1950 1950,2370
we lock,| {} and we
|我们保留了这个已经存在的价值，以决定我们是否应该返回。

1586
00:46:34,940 --> 00:46:36,110
0,240 240,360 360,690 690,1050 1050,1170
kept this already value to

1587
00:46:36,110 --> 00:46:37,190
0,300 300,480 480,600 600,780 780,1080
decide whether we should return

1588
00:46:37,190 --> 00:46:38,100
0,60 60,390
or not.|
|

1589
00:46:38,560 --> 00:46:40,480
0,150 150,660 930,1710 1710,1830 1830,1920
And then, {} you know
然后，你知道我们这些猩猩开始取一页，

1590
00:46:40,480 --> 00:46:42,340
0,570 570,780 780,1080 1080,1500 1500,1860
we this {goroutines -} starts

1591
00:46:42,340 --> 00:46:45,040
0,510 510,1680 1710,2460 2460,2640 2640,2700
fetching a page,| gets a
|取回一堆URL，

1592
00:46:45,040 --> 00:46:46,660
0,150 150,240 240,690 690,1110
bunch of urls back,|
|

1593
00:46:46,660 --> 00:46:48,430
0,90 90,270 270,420 420,1020 1050,1770
and then, for every url
然后，对于每个返回的URL，

1594
00:46:48,430 --> 00:46:50,950
0,510 810,1680 1680,2190 2190,2460 2460,2520
back,| {} it creates a
|它在这一边创造了一个新的猩猩，

1595
00:46:50,950 --> 00:46:52,420
0,480 480,780 780,1140 1140,1380 1380,1470
new {goroutine -} here on

1596
00:46:52,420 --> 00:46:54,610
0,150 150,600 1080,1740 1770,2100 2100,2190
this side,| {} {passes -}
|传入URL，

1597
00:46:54,610 --> 00:46:56,050
0,240 240,330 330,930 930,1230 1230,1440
in the url,| but {goroutine
|但大猩猩应该会抓取和爬行。

1598
00:46:56,050 --> 00:46:57,400
0,90 90,420 420,570 570,960 960,1350
- -} is supposed to

1599
00:46:57,400 --> 00:46:59,320
0,630 630,960 960,1440
fetch and crawl.|
|

1600
00:47:00,100 --> 00:47:01,300
0,570 600,720 720,990 990,1140 1140,1200
{} The only sort of
这里唯一有趣的是，

1601
00:47:01,300 --> 00:47:02,710
0,240 240,570 570,900 900,1410 1410,1410
other interesting thing here, {}|
|

1602
00:47:04,120 --> 00:47:05,590
0,330 330,510 510,630 630,930 930,1470
is that it uses something
它使用了关于WaitGroup的一些东西

1603
00:47:05,590 --> 00:47:07,450
0,330 330,600 600,1020 1410,1620 1620,1860
about {WaitGroup -}| and {WaitGroup
|WaitGroup是一个非常方便的原语，用于跟踪您仍有多少活动线程

1604
00:47:07,450 --> 00:47:08,590
0,210 210,360 360,480 480,720 720,1140
-} is a very convenient

1605
00:47:08,590 --> 00:47:09,880
0,510 510,600 600,840 840,1170 1170,1290
primitive to keep track how

1606
00:47:09,880 --> 00:47:11,230
0,210 210,510 510,630 630,870 870,1350
many threads you still have

1607
00:47:11,230 --> 00:47:12,490
0,510 510,780 780,1050 1050,1170 1170,1260
active| and when you can
|当你可以终止的时候。

1608
00:47:12,490 --> 00:47:13,520
0,570
terminate.|
|

1609
00:47:13,520 --> 00:47:14,750
0,150 150,270 270,420 420,1020 1020,1230
And this was a big
这是这次特别任务中的一个大问题

1610
00:47:14,750 --> 00:47:16,040
0,270 270,330 330,450 450,780 780,1290
issue in this particular assignment|
|

1611
00:47:16,040 --> 00:47:17,210
0,150 150,300 300,540 570,1050 1050,1170
that if you terminated too
如果你终止得太早，

1612
00:47:17,210 --> 00:47:18,620
0,390 390,630 630,780 780,990 990,1410
early,| then you didn't crawl
|那你就不会爬网页了。

1613
00:47:18,620 --> 00:47:19,920
0,90 90,270 270,810
the web pages.|
|

1614
00:47:19,980 --> 00:47:20,700
0,150 150,300 300,420 420,600 600,720
And so you need to
所以你需要跟踪任何东西，

1615
00:47:20,700 --> 00:47:23,640
0,600 600,930 930,1710 2130,2400 2400,2940
{keep,track} whatever,| { -} whatever
|无论还有什么优秀的网页需要抓取，

1616
00:47:23,640 --> 00:47:25,050
0,150 150,420 420,990 990,1170 1170,1410
there's still outstanding web pages

1617
00:47:25,050 --> 00:47:26,430
0,120 120,270 270,960 960,1200 1200,1380
to be crawled,| seeing {WaitGroup
|每次调用线程时，查看WaitGroup基本上都是非常容易的，

1618
00:47:26,430 --> 00:47:27,750
0,210 210,330 330,420 420,750 750,1320
-} is a very easily

1619
00:47:27,990 --> 00:47:29,670
0,750 750,930 930,1200 1200,1350 1350,1680
basically every time you call

1620
00:47:29,670 --> 00:47:31,560
0,300 300,420 420,960 990,1380 1380,1890
thread,| you call {} add
|调用Add，然后当线程终止时，调用Done，

1621
00:47:31,860 --> 00:47:33,060
0,390 390,600 600,840 840,1110 1110,1200
{} and then when the

1622
00:47:33,060 --> 00:47:35,340
0,240 240,990 1290,1710 1710,1830 1830,2280
thread terminates, {} you call

1623
00:47:35,370 --> 00:47:37,740
0,900 1020,1470 1470,1710 1710,2160 2160,2370
done,| {} and we could
|我们可以在延期声明中方便地做到这一点。

1624
00:47:37,740 --> 00:47:38,610
0,360 360,480 480,690 690,780 780,870
conveniently do that in a

1625
00:47:38,610 --> 00:47:39,940
0,360 360,930
defer statement.|
|

1626
00:47:39,970 --> 00:47:41,290
0,150 150,750 750,810 810,1080 1080,1320
And then the main thread
然后等待所有线程延迟语句的主线程，

1627
00:47:41,290 --> 00:47:42,280
0,120 120,210 210,570 570,900 900,990
that is waiting for all

1628
00:47:42,280 --> 00:47:43,390
0,120 120,300 300,750 750,900 900,1110
the thread {defer,statement},| just goes
|只是等待，等待将返回，直到每个线程，

1629
00:47:43,390 --> 00:47:44,770
0,390 390,510 510,750 750,870 870,1380
wait and wait will return

1630
00:47:44,770 --> 00:47:46,180
0,450 450,750 750,1080 1110,1320 1320,1410
until every thread,| that will
|每增加一个就会开始，

1631
00:47:46,180 --> 00:47:48,550
0,330 330,600 600,930 1080,1830 1830,2370
{started -} for every {add,one},|
|

1632
00:47:48,790 --> 00:47:49,840
0,210 210,450 450,600 600,840 840,1050
{} if all those threads
如果所有这些线程实际上都已退出。

1633
00:47:49,840 --> 00:47:51,700
0,330 330,450 450,810 810,1320 1380,1860
actually has been {} exited.|
|

1634
00:47:53,330 --> 00:47:54,900
0,510 510,990
That's the
这是互斥体的版本。

1635
00:47:55,190 --> 00:47:57,800
0,270 270,840 870,2040
{mutex -} version.|
|

1636
00:48:00,210 --> 00:48:01,080
0,150 150,240 240,330 330,480 480,870
And you can think about
您可以将同步等待看作是使用条件变量在内部实现的。

1637
00:48:01,080 --> 00:48:02,250
0,270 270,720 720,870 870,1080 1080,1170
sync wait as sort of

1638
00:48:02,250 --> 00:48:04,230
0,180 180,660 660,1200 1200,1800 1830,1980
being internally implemented using {}

1639
00:48:04,230 --> 00:48:05,580
0,390 390,840
condition variable.|
|

1640
00:48:07,230 --> 00:48:07,980
0,210 210,360 360,450 450,630 630,750
Okay, let me look at
好的，让我来看看频道版。

1641
00:48:07,980 --> 00:48:09,080
0,510
the

1642
00:48:09,110 --> 00:48:10,380
0,690
{}

1643
00:48:10,380 --> 00:48:12,040
0,570 570,1110
channel version.|
|

1644
00:48:12,380 --> 00:48:14,540
0,780 1020,1170 1170,1470 1470,1680 1890,2160
{} So here's {} channel
所以这里频道版本基本上是按照MapReduceLab组织的，

1645
00:48:14,540 --> 00:48:15,620
0,360 360,420 420,810 810,960 960,1080
version is basically sort of

1646
00:48:15,620 --> 00:48:20,270
0,1620 1620,2220 2250,2760 2760,3420 3450,4650
organized as {mapreduce -} lab,|
|

1647
00:48:20,300 --> 00:48:21,830
0,390 390,540 540,750 750,810 810,1530
lab where there's a coordinator
有协调员和工作人员的实验室。

1648
00:48:21,830 --> 00:48:23,180
0,270 270,870
and workers.|
|

1649
00:48:23,420 --> 00:48:25,550
0,300 300,930 1110,1680 1680,1860 1860,2130
{} So, {} we start
所以，我们开始，你知道我们开始创建一个协调器线程，

1650
00:48:25,550 --> 00:48:26,750
0,360 360,420 420,810 810,960 960,1200
off, you know we start

1651
00:48:26,750 --> 00:48:28,340
0,120 120,450 450,630 660,1200 1200,1590
off creating a coordinator thread,|
|

1652
00:48:28,790 --> 00:48:29,780
0,420 420,660 660,720 720,870 870,990
{} and the way we
我们实际上做到这一点的方式是

1653
00:48:29,780 --> 00:48:31,100
0,90 90,330 330,840 840,1050 1050,1320
do that actually is| we
|我们创建一个通道，然后将该通道传递给协调器，

1654
00:48:31,100 --> 00:48:33,230
0,180 180,240 240,780 1230,1890 1890,2130
make a channel and then

1655
00:48:33,230 --> 00:48:34,370
0,90 90,390 390,600 630,930 930,1140
we pass the channel into

1656
00:48:34,370 --> 00:48:36,200
0,60 60,810 870,1230 1290,1770 1770,1830
the coordinator,| the coordinator of
|协调器当然必须从URL开始，开始URL，

1657
00:48:36,200 --> 00:48:37,190
0,210 210,360 360,420 420,840 840,990
course has to start with

1658
00:48:37,190 --> 00:48:38,570
0,60 60,510 510,600 600,930 930,1380
a url, the beginning url,|
|

1659
00:48:38,570 --> 00:48:39,710
0,120 120,240 240,390 390,540 630,1140
so we need to supply
所以我们需要在频道上提供这些信息，

1660
00:48:39,710 --> 00:48:40,700
0,210 210,360 360,480 480,810 810,990
that on the channel,| that's
|这是最方便的事情，我们马上就会看到。

1661
00:48:40,700 --> 00:48:41,600
0,90 90,300 300,660 660,810 810,900
the most convenient thing to

1662
00:48:41,600 --> 00:48:42,440
0,330 330,450 450,540 540,750 750,840
do as we'll see in

1663
00:48:42,440 --> 00:48:43,420
0,60 60,510
a second.|
|

1664
00:48:43,540 --> 00:48:45,250
0,330 330,600 600,810 810,1290 1410,1710
{} But, {you,know} to send
但是，你知道，要在频道上发送它，

1665
00:48:45,250 --> 00:48:45,970
0,90 90,180 180,270 270,600 600,720
it on the channel,| we
|我们基本上要创造一个大猩猩，

1666
00:48:45,970 --> 00:48:46,780
0,300 300,390 390,480 480,750 750,810
basically have to create a

1667
00:48:46,780 --> 00:48:48,430
0,210 210,600 600,810 810,1380 1380,1650
{goroutine -},| because otherwise we
|因为不然的话，我们就会陷入僵局。

1668
00:48:48,430 --> 00:48:49,680
0,450 450,750
deadlock here.|
|

1669
00:48:49,950 --> 00:48:51,120
0,330 330,570 570,660 660,810 810,1170
We, this is a difficult
我们，这是一件困难的事情，

1670
00:48:51,120 --> 00:48:52,740
0,270 270,960 960,1230 1230,1350 1350,1620
thing,| we're going to just
|我们将在频道上发送该值。

1671
00:48:52,740 --> 00:48:53,790
0,300 300,450 450,840 840,960 960,1050
send that value on the

1672
00:48:53,790 --> 00:48:54,740
0,390
channel.|
|

1673
00:48:55,150 --> 00:48:55,750
0,150 150,330 330,480 480,540 540,600
So let's look at the
让我们来看一下协调器。

1674
00:48:55,750 --> 00:48:57,120
0,810
coordinator.|
|

1675
00:48:57,980 --> 00:49:00,020
0,240 240,480 480,540 540,1350 1410,2040
{} Here's the coordinator, it
这是协调器，它根本不使用任何锁，

1676
00:49:00,140 --> 00:49:01,520
0,450 450,720 720,1020 1020,1290 1290,1380
doesn't use any locks at

1677
00:49:01,520 --> 00:49:03,170
0,390 420,990 990,1110 1110,1260 1260,1650
all,| because you know the
|因为你知道数据结构，没有实际共享的数据结构，比如FETCHED，

1678
00:49:03,200 --> 00:49:05,990
0,360 360,750 750,1620 2040,2670 2670,2790
data structures, that there's no

1679
00:49:05,990 --> 00:49:07,340
0,240 240,540 540,750 750,960 960,1350
data structures actually being shared,

1680
00:49:07,370 --> 00:49:09,350
0,240 240,870 1140,1470 1470,1830 1830,1980
like fetched,| the map that
|实际跟踪哪些URL制造商的映射实际上是协调器内的唯一访问。

1681
00:49:09,350 --> 00:49:10,610
0,210 210,360 360,660 660,720 720,1260
actually keep track of which

1682
00:49:10,610 --> 00:49:12,470
0,870 870,1410 1410,1560 1560,1800 1800,1860
urls manufacturers is actually the

1683
00:49:12,470 --> 00:49:14,660
0,600 630,1080 1080,1470 1470,1530 1530,2190
only access within the coordinator.|
|

1684
00:49:16,480 --> 00:49:17,770
0,150 150,240 240,690 690,870 870,1290
So the coordinator got {}
所以协调人在我们最初叫它的时候就知道了，

1685
00:49:17,800 --> 00:49:18,910
0,180 180,330 330,600 630,1020 1020,1110
know when we called it

1686
00:49:18,910 --> 00:49:20,980
0,630 660,1230 1230,1410 1410,1620 1620,2070
initially,| {} we've got, {}|
|我们有，|

1687
00:49:20,980 --> 00:49:23,620
0,210 210,900 930,1230 1230,2010 2310,2640
it has one url checks
它有一个检查获取映射的url。

1688
00:49:23,620 --> 00:49:25,270
0,90 90,510 510,1290 1290,1530 1530,1650
the fetch map| and for
|并且对于每个URL，

1689
00:49:25,270 --> 00:49:26,740
0,240 240,990
every url,|
|

1690
00:49:26,800 --> 00:49:28,150
0,360 360,420 420,660 660,1110 1200,1350
then it goes basically you
然后它基本上循环到达海峡，

1691
00:49:28,150 --> 00:49:30,520
0,300 570,1050 1050,1710 1710,1980 1980,2370
know cycles through reach the

1692
00:49:30,700 --> 00:49:32,590
0,690 690,960 960,1050 1050,1320 1320,1890
channel,| using a range statement,|
|使用范围语句，|

1693
00:49:33,010 --> 00:49:34,090
0,120 120,420 420,570 570,750 750,1080
and basically what this does
基本上，它所做的就是

1694
00:49:34,090 --> 00:49:35,200
0,330 330,510 510,780 780,1020 1020,1110
is| just keep {reading -}
|只要继续看频道就行了

1695
00:49:35,200 --> 00:49:36,490
0,60 60,540 540,900 900,1200 1200,1290
the channel| and grab the
|然后抓住下一个值，

1696
00:49:36,490 --> 00:49:37,870
0,210 210,540 540,810 810,1050 1050,1380
next value, grab next value,

1697
00:49:37,870 --> 00:49:39,400
0,300 300,540 540,870 900,1140 1140,1530
grab next value,| so basically
|所以基本上就是抓取URL，

1698
00:49:39,400 --> 00:49:41,320
0,270 270,780 780,1470 1560,1740 1740,1920
grabs the url,| we know
|我们知道里面有一个，

1699
00:49:41,320 --> 00:49:42,520
0,180 180,390 390,540 540,750 780,1200
there's one in it,| because
|因为我们在制作它的时候就戴上了。

1700
00:49:42,520 --> 00:49:43,660
0,360 360,540 540,630 630,930 930,1140
we put it on when

1701
00:49:43,660 --> 00:49:44,800
0,90 90,480 480,720
we created it.|
|

1702
00:49:45,020 --> 00:49:46,550
0,180 180,660 660,810 810,990 990,1530
And then, for that url,|
然后，对于该URL，|

1703
00:49:46,550 --> 00:49:48,080
0,330 330,690 690,900 900,1170 1170,1530
we're roughly {do,the} same thing
我们所做的大致与，

1704
00:49:48,080 --> 00:49:50,840
0,390 390,930 1410,2190
as the, {}|
|

1705
00:49:51,170 --> 00:49:52,940
0,690 690,1170 1170,1440 1470,1620 1620,1770
concurrent as the {mutex -}
与互斥体并发，

1706
00:49:52,940 --> 00:49:55,100
0,480 810,1620 1620,1740 1740,1920 1920,2160
one,| {} you know we
|您知道，我们看到URL已经被获取，

1707
00:49:55,100 --> 00:49:56,540
0,300 300,570 570,900 900,1140 1140,1440
see the url has already

1708
00:49:56,540 --> 00:49:58,190
0,150 150,690 720,1380 1380,1590 1590,1650
been fetched,| {} if it
|如果还没拿到，那我们就完了，

1709
00:49:58,190 --> 00:49:59,690
0,270 270,450 450,930 930,1380 1380,1500
hasn't been fetched, then we're

1710
00:49:59,690 --> 00:50:01,490
0,480 540,1140 1140,1200 1200,1290 1290,1800
done,| otherwise we will create
|否则，我们将创建一个Go Worker来实际获取该URL。

1711
00:50:01,490 --> 00:50:03,290
0,180 180,570 570,1200 1230,1470 1470,1800
a Go worker to actually

1712
00:50:03,290 --> 00:50:04,900
0,360 360,600 600,1140
fetch that url.|
|

1713
00:50:06,380 --> 00:50:08,090
0,690 690,1050 1050,1140 1140,1290 1290,1710
{} And we keep track
我们会记录我们有多少优秀的员工，

1714
00:50:08,090 --> 00:50:10,310
0,60 60,240 240,840 870,1770 1770,2220
of how many outstanding workers

1715
00:50:10,310 --> 00:50:11,390
0,180 180,450 480,750 750,990 990,1080
we have,| so n is
|因此，n是计算工人的数量

1716
00:50:11,390 --> 00:50:12,770
0,360 360,570 570,630 630,1140 1140,1380
counting number of workers| and
|只有当n为0时，我们才会终止协调器，

1717
00:50:12,770 --> 00:50:14,060
0,240 240,450 450,570 570,660 660,1290
only when n is 0,

1718
00:50:14,240 --> 00:50:16,430
0,390 390,570 570,870 870,1650 1680,2190
{} do we terminate the

1719
00:50:16,460 --> 00:50:18,590
0,750 1140,1410 1410,1590 1590,1830 1830,2130
coordinator,| {} to make sure
|为了确保基本上我们已经获取了所有应该获取的网页。

1720
00:50:18,590 --> 00:50:20,180
0,120 120,600 600,900 900,1080 1080,1590
that basically we have fetched

1721
00:50:20,210 --> 00:50:21,860
0,300 300,630 660,870 870,1410 1440,1650
all the web pages, that

1722
00:50:21,860 --> 00:50:23,030
0,90 90,480 480,570 570,720 720,1170
were supposed to be fetching.|
|

1723
00:50:23,910 --> 00:50:25,110
0,270 270,390 390,570 570,870 870,1200
Unless you can work {}
除非您可以工作Worker基本上调用Fetch，否则该协调器完全并行进行

1724
00:50:25,110 --> 00:50:26,820
0,300 300,630 630,900 900,1320 1320,1710
worker basically calls fetch this

1725
00:50:26,820 --> 00:50:28,680
0,450 450,750 750,1170 1170,1710 1710,1860
coordinator happens completely parallel| with
|和任何其他工人在一起。

1726
00:50:28,680 --> 00:50:30,160
0,150 150,360 360,990
any other workers.|
|

1727
00:50:30,190 --> 00:50:32,410
0,720 1140,1290 1290,1440 1440,1680 1680,2220
{} If we actually fetch
如果我们实际上从该网页获取一些URL，

1728
00:50:32,440 --> 00:50:34,690
0,900 900,1530 1530,1770 1770,2040 2040,2250
some url from that web

1729
00:50:34,690 --> 00:50:35,890
0,270 270,450 450,780 780,1050 1050,1200
page,| it basically writes all
|它基本上将所有这些URL写入通道

1730
00:50:35,890 --> 00:50:37,720
0,210 210,840 840,1110 1110,1440 1440,1830
those urls to the channel|
|

1731
00:50:37,870 --> 00:50:39,760
0,450 450,960 990,1140 1140,1740 1740,1890
and so the coordinator will
因此协调器将通过范围语句获取所有这些通道。

1732
00:50:39,760 --> 00:50:41,230
0,150 150,330 330,540 540,1140 1140,1470
get all those channels through

1733
00:50:41,230 --> 00:50:42,540
0,270 270,810
range statements.|
|

1734
00:50:43,180 --> 00:50:44,590
0,390 390,540 540,720 720,840 840,1410
And then when it's done,|
然后当它完成的时候，|

1735
00:50:44,590 --> 00:50:46,780
0,360 360,540 540,1230 1410,1920 1920,2190
writing all the urls through
通过通道写入所有URL，

1736
00:50:46,780 --> 00:50:49,210
0,540 660,960 960,1200 1200,2010 2010,2430
channel,| then the coordinator {}
|然后协调器工作进程退出

1737
00:50:49,240 --> 00:50:51,820
0,540 540,1200 1200,1710 1710,2430 2430,2580
worker exits| and {that,will} {you,know}
|你会知道，在某一时刻，你知道吗？

1738
00:50:51,820 --> 00:50:53,580
0,150 150,300 300,750 750,1230
at some point {

1739
00:50:53,710 --> 00:50:55,750
0,360 360,1170 1170,1260 1260,1530 1530,2040
-} decrease you know n|
|

1740
00:50:55,750 --> 00:50:56,770
0,270 270,510 510,630 630,750 750,1020
and then at the end
然后在最后。

1741
00:50:56,920 --> 00:50:58,400
0,150 480,960
of. {}|
|

1742
00:50:58,920 --> 00:51:00,460
0,150 150,360 360,570 570,1020
And that's it basically.|
基本上就是这样。|

1743
00:51:01,180 --> 00:51:02,380
0,660
Okay?|
好吧?|

1744
00:51:02,470 --> 00:51:03,100
0,150 150,360 360,420 420,510 510,630
So those are the two
所以这就是两个解决方案，任何关于这些的问题。

1745
00:51:03,100 --> 00:51:05,230
0,570 600,1320 1350,1560 1560,1920 1920,2130
solutions, {} any questions about

1746
00:51:05,230 --> 00:51:06,240
0,420
these.|
|

1747
00:51:12,720 --> 00:51:14,100
0,180 180,270 270,390 390,840
Is it all clear?|
安全了吗？|

1748
00:51:16,100 --> 00:51:17,510
0,240 240,330 330,780 780,930 930,1410
There's a question in chat.|
聊天中有个问题。|

1749
00:51:17,720 --> 00:51:19,820
0,630 660,1020 1020,1170 1170,1620 1770,2100
Okay, {} let me get
好了，让我找回我的聊天列表。

1750
00:51:19,820 --> 00:51:22,500
0,120 120,390 390,840 1230,2160
my chat list {back,up}.|
|

1751
00:51:32,770 --> 00:51:34,930
0,360 360,540 540,660 660,1230 1230,2160
Okay, so the question is
好的，所以问题是ch什么时候有值，

1752
00:51:35,140 --> 00:51:36,310
0,390 390,720 720,930 930,1110 1110,1170
when {ch -} has a

1753
00:51:36,310 --> 00:51:37,540
0,360 360,510 510,720 750,1020 1020,1230
value in it,| when all
|当所有其他线程空闲时，

1754
00:51:37,540 --> 00:51:40,210
0,240 240,510 510,840 840,1440 1890,2670
other threads be idle, {}|
|

1755
00:51:40,210 --> 00:51:41,980
0,60 450,780 780,840 840,1140 1140,1770
if it's the case, {that's
如果是这样的话，那是，

1756
00:51:41,980 --> 00:51:43,330
0,30 30,840 870,1110 1110,1260 1260,1350
-},| {} since this is
|由于这不是缓冲通道，

1757
00:51:43,330 --> 00:51:44,560
0,240 240,300 300,570 570,930 930,1230
not a buffered channel,| but
|但你知道，在那个时候，渠道中只会有一个请求。

1758
00:51:44,590 --> 00:51:45,190
0,90 90,210 210,420 420,540 540,600
you know there's going to

1759
00:51:45,190 --> 00:51:46,660
0,90 90,480 480,990 990,1380 1380,1470
be only one request in

1760
00:51:46,660 --> 00:51:47,560
0,90 90,390 390,480 480,540 540,900
the channel at the time.|
|

1761
00:51:48,170 --> 00:51:49,430
0,180 180,540 540,750 750,840 840,1260
And so all the threads
所以你所知道的所有线索都将被一个接一个地附加到通道中。

1762
00:51:49,430 --> 00:51:51,200
0,120 120,330 330,600 600,1170 1200,1770
you know will be appended

1763
00:51:51,200 --> 00:51:52,040
0,90 90,180 180,480 480,720 720,840
to the channel one by

1764
00:51:52,040 --> 00:51:52,980
0,330
one.|
|

1765
00:51:54,010 --> 00:51:55,360
0,480 480,780 780,1020 1020,1260 1260,1350
But doesn't that make the
但这不是让程序顺序化了吗，

1766
00:51:55,360 --> 00:51:57,190
0,360 360,1050 1050,1500 1500,1680 1680,1830
program sequential,| because no two
|因为除了主线程和一个线程外，没有两个线程并行运行。

1767
00:51:57,190 --> 00:51:58,390
0,270 270,330 330,540 540,630 630,1200
threads are running in parallel

1768
00:51:58,570 --> 00:51:59,560
0,300 300,390 390,600 600,810 810,990
except the main thread and

1769
00:51:59,560 --> 00:52:02,350
0,570 1320,2010 2040,2310 2310,2520 2520,2790
one.| {Well,the,fetchers} will still happen
|好的，取回者仍然会并行发生，

1770
00:52:02,350 --> 00:52:03,460
0,60 60,600
in parallel,|
|

1771
00:52:04,080 --> 00:52:05,250
0,330 330,420 420,750 750,810 810,1170
those are presuming the expensive
这些人推定了昂贵的手术，

1772
00:52:05,250 --> 00:52:06,870
0,570 840,1050 1050,1290 1290,1470 1470,1620
operation,| where those go out
|这些信息在互联网上流传开来。

1773
00:52:06,870 --> 00:52:08,280
0,300 300,390 390,870
across the Internet.|
|

1774
00:52:09,350 --> 00:52:11,240
0,540 540,630 630,840 840,1230
Got it, thank you.|
知道了，谢谢。|

1775
00:52:14,040 --> 00:52:15,540
0,420 450,930 930,1020 1020,1230 1230,1500
Okay, let me switch back
好的，让我切换回我的另一个屏幕。

1776
00:52:15,540 --> 00:52:17,860
0,810 840,1020 1020,1230 1230,1770
to my other screen.|
|

1777
00:52:17,890 --> 00:52:19,100
0,720
And,
并且，稍微谈一下RPC，

1778
00:52:19,270 --> 00:52:20,050
0,240 240,420 420,480 480,660 660,780
{} talk a little bit

1779
00:52:20,050 --> 00:52:21,460
0,240 240,390 390,900 930,1230 1230,1410
about {RPC -},| {} since
|因为这是实验室需要的另一种工具。

1780
00:52:21,460 --> 00:52:22,630
0,210 210,300 300,510 510,840 840,1170
that's the other thing tool

1781
00:52:22,630 --> 00:52:23,800
0,150 150,300 300,720 750,1020 1020,1170
that you need {} for

1782
00:52:23,800 --> 00:52:24,920
0,600
{the,labs}.|
|

1783
00:52:27,540 --> 00:52:28,380
0,390 390,510 510,630 630,690 690,840
We're not going to say
关于这一点我们不会说太多，

1784
00:52:28,380 --> 00:52:29,460
0,90 90,270 270,510 510,720 720,1080
a ton about it,| but
|但是还有RPC，它代表远程过程调用。

1785
00:52:29,460 --> 00:52:30,920
0,90 90,330 330,930
there's { -}

1786
00:52:31,580 --> 00:52:33,200
0,270 270,840 840,1050 1050,1320 1320,1620
{RPC -} which stands for

1787
00:52:33,200 --> 00:52:35,360
0,600 750,1200 1200,1620
remote procedure calls.|
|

1788
00:52:41,680 --> 00:52:43,420
0,390 390,750 750,840 840,1560 1590,1740
And basically the goal you
基本上就是你知道的RPC系统中的目标，

1789
00:52:43,420 --> 00:52:45,940
0,120 120,510 810,1530 1530,1830 2190,2520
know the goal in {RPC

1790
00:52:45,940 --> 00:52:47,560
0,330 330,930 930,1380 1380,1440 1440,1620
-} system,| like the one
|就像Go有的那个，

1791
00:52:47,560 --> 00:52:48,700
0,150 150,390 390,750 750,840 840,1140
that Go has,| so {basically
|因此，基本上RPC的行为与过程调用大致相似，

1792
00:52:48,700 --> 00:52:51,010
0,270 270,450 450,1290 1350,1830 1830,2310
-} {RPCs -} behave roughly

1793
00:52:51,010 --> 00:52:53,860
0,690 1020,1230 1230,1710 1710,2250 2280,2850
similar to procedure calls,| local
|本地过程调用堆栈上的Execute，对吧。

1794
00:52:53,860 --> 00:52:55,090
0,330 330,600 600,720 720,1140 1140,1230
procedure calls the execute on

1795
00:52:55,090 --> 00:52:56,060
0,60 60,510
the stack,

1796
00:52:56,060 --> 00:52:57,470
0,330 330,450 450,870 1050,1290 1290,1410
right.| And, so {} the
|因此，我们的目标是，例如，如果你有一个客户，

1797
00:52:57,470 --> 00:52:58,730
0,330 330,540 540,660 660,1140 1140,1260
goal is for example if

1798
00:52:58,730 --> 00:53:00,500
0,90 90,180 180,270 270,840 1530,1770
you have a client,| in
|在RPC术语中，调用方通常称为客户端

1799
00:53:00,500 --> 00:53:03,170
0,180 180,630 630,1440 1440,1770 2310,2670
{RPC -} terminology, the caller

1800
00:53:03,170 --> 00:53:05,660
0,330 330,540 540,600 600,1290 1290,2490
typically called the client| and
|被呼叫方称为服务器。

1801
00:53:05,960 --> 00:53:07,700
0,450 450,660 660,1260
{callee,is} called server.|
|

1802
00:53:07,820 --> 00:53:09,170
0,210 210,510 510,630 630,720 720,1350
So you have a function
所以你有一个函数fn

1803
00:53:09,770 --> 00:53:11,270
0,510 510,1020 1020,1110 1110,1380 1380,1500
{fn -}| you know we're
|你知道我们是用x和y打电话的

1804
00:53:11,270 --> 00:53:13,010
0,450 450,660 660,960 960,1110 1110,1740
calling with x and y|
|

1805
00:53:13,190 --> 00:53:14,720
0,390 390,570 570,660 660,750 750,1530
and then at the server,|
然后在服务器上，|

1806
00:53:14,780 --> 00:53:16,010
0,330 330,420 420,990 990,1080 1080,1230
there's the implementation of this
这是这个函数的实现。

1807
00:53:16,010 --> 00:53:16,920
0,420
function.|
|

1808
00:53:18,560 --> 00:53:19,610
0,240 240,450 450,630 630,690 690,1050
And so there's a function
所以有一个函数n，不管x是多少，都在里面。

1809
00:53:19,610 --> 00:53:21,080
0,330 330,840 840,1050 1050,1170 1170,1470
n whatever x you know

1810
00:53:21,080 --> 00:53:22,760
0,540 540,1110
y {in,it}.|
|

1811
00:53:22,820 --> 00:53:25,550
0,870 870,1020 1020,1170 1170,2160 2550,2730
And you know {it,returns} you
你知道，它返回，你知道，无论做什么计算

1812
00:53:25,550 --> 00:53:27,050
0,90 90,420 420,750 750,1380 1380,1500
know whatever {does,some} computation| when
|当他们可以使用它时，返回x加y。

1813
00:53:27,050 --> 00:53:28,340
0,120 120,240 240,450 450,630 630,1290
they can use this returns

1814
00:53:30,040 --> 00:53:31,980
0,420 420,660 660,840 840,1230
{} x plus y.|
|

1815
00:53:33,580 --> 00:53:35,500
0,150 150,570 570,570 1470,1830 1830,1920
And so, {} what we
因此，我们希望发生的事情

1816
00:53:35,500 --> 00:53:36,820
0,120 120,660 660,720 720,930 930,1320
would like to have happen|
|

1817
00:53:36,820 --> 00:53:37,690
0,210 210,360 360,450 450,720 720,870
or like the model that
或者像我们想要自己思考的模型是

1818
00:53:37,690 --> 00:53:39,460
0,120 120,270 270,450 450,1230 1230,1770
we would like to ourselves

1819
00:53:39,460 --> 00:53:40,450
0,90 90,240 240,540 540,690 690,990
to think about is that|
|

1820
00:53:40,540 --> 00:53:41,440
0,210 210,300 300,600 600,780 780,900
when the client calls this
当客户端调用该函数Fn时，

1821
00:53:41,440 --> 00:53:44,410
0,570 810,1770 1950,2250 2250,2430 2430,2970
function fn,| {} the RPC
|RPC系统将确保在服务器端发生任何相应量的应用程序，

1822
00:53:44,410 --> 00:53:45,970
0,540 540,870 870,1080 1080,1440 1440,1560
system will make sure that

1823
00:53:45,970 --> 00:53:48,490
0,210 210,480 660,1320 1320,2130 2130,2520
there's any corresponding {amount,of,application} happening

1824
00:53:48,490 --> 00:53:49,920
0,120 120,210 210,540 540,990
on the server side,|
|

1825
00:53:49,920 --> 00:53:51,540
0,270 270,720 720,840 840,1320 1320,1620
{} passes the arguments {x,and}
将您知道的参数x和y传递给服务器，

1826
00:53:51,540 --> 00:53:52,380
0,390 390,540 540,630 630,750 750,840
y you know to the

1827
00:53:52,380 --> 00:53:53,940
0,660 720,900 900,1230 1230,1470 1470,1560
server,| the code runs on
|代码在服务器上运行，

1828
00:53:53,940 --> 00:53:55,950
0,60 60,810 960,1530 1530,1890 1890,2010
the server,| {} it you
|它会返回您看到的结果。

1829
00:53:55,950 --> 00:53:57,900
0,360 390,900 900,990 990,1560 1560,1950
know returns a result you

1830
00:53:57,900 --> 00:53:58,980
0,540
see.|
|

1831
00:53:59,040 --> 00:54:01,050
0,240 240,390 390,870 870,1050 1470,2010
And that result is communicating
其结果是向客户端发回信息

1832
00:54:01,050 --> 00:54:03,000
0,330 330,450 450,540 540,1110 1380,1950
back to the client| and
|你知道，然后FN将恢复，并将返回

1833
00:54:03,000 --> 00:54:05,040
0,60 60,390 390,930 930,1650 1650,2040
you know and then fn

1834
00:54:05,040 --> 00:54:07,170
0,180 180,1110 1110,1320 1320,1950 1950,2130
will resume will return| and
|客户端返回的结果是x加上y的值x，y和z，对。

1835
00:54:07,170 --> 00:54:08,490
0,60 60,420 420,510 510,1020 1050,1320
the client will return {}

1836
00:54:08,490 --> 00:54:10,770
0,210 210,810 810,1080 1170,1650 1980,2280
will resume with the x

1837
00:54:10,770 --> 00:54:12,240
0,180 180,540 540,990 1020,1230 1230,1470
plus y in the value

1838
00:54:12,240 --> 00:54:13,290
0,90 90,390 390,660 660,780 780,1050
of x y and z,

1839
00:54:13,760 --> 00:54:15,350
0,360 720,930 930,1110 1110,1350 1350,1590
right.| So this looks like
|所以这看起来就像是尽管这些程序运行在不同的计算机上，

1840
00:54:15,350 --> 00:54:16,490
0,390 390,540 540,630 630,1050 1050,1140
even though the programs are

1841
00:54:16,490 --> 00:54:18,110
0,270 270,390 390,660 660,1170 1470,1620
running on different computers,| you
|你知道他们实际上在这里是有界限的，

1842
00:54:18,110 --> 00:54:19,490
0,150 150,420 420,690 690,960 960,1380
know they're actually have boundary

1843
00:54:19,490 --> 00:54:20,930
0,450 570,810 810,960 960,1170 1170,1440
here,| {} it looks like
|看起来你知道他们会进行常规的过程调用。

1844
00:54:20,930 --> 00:54:22,940
0,60 60,210 210,1590 1620,1920 1920,2010
you know they make a

1845
00:54:22,940 --> 00:54:24,460
0,330 330,660 660,1080
regular procedure calls.|
|

1846
00:54:24,920 --> 00:54:26,090
0,450 660,870 870,1050 1050,1110 1110,1170
{} We'll see in a
我们一会儿就会看到，

1847
00:54:26,090 --> 00:54:28,700
0,540 540,1200 1200,2190 2190,2490 2490,2610
second,| actually, {} we can
|实际上，我们可以找到很多相似之处，

1848
00:54:28,700 --> 00:54:29,750
0,150 150,210 210,360 360,420 420,1050
make a lot of similarities,|
|

1849
00:54:29,750 --> 00:54:30,740
0,90 90,330 330,690 690,780 780,990
so it's possible to make
所以有可能让它们的行为非常相似，

1850
00:54:30,740 --> 00:54:32,420
0,90 90,660 660,900 900,1380 1470,1680
them behave very similar,| but
|但你会发现这也有一个根本的不同

1851
00:54:32,420 --> 00:54:33,320
0,120 120,360 360,570 570,810 810,900
you'll see there's also a

1852
00:54:33,320 --> 00:54:34,580
0,150 150,240 240,330 330,870 870,1260
sort of a fundamental difference|
|

1853
00:54:34,580 --> 00:54:35,510
0,90 90,480 480,720 720,840 840,930
and actually has what to
实际上与分布式计算有什么关系。

1854
00:54:35,510 --> 00:54:37,140
0,150 150,270 270,690 690,1110
do with distributed computing.|
|

1855
00:54:38,040 --> 00:54:39,060
0,210 210,480 480,690 690,870 870,1020
But before getting there,| let
但在到达那里之前，|首先让我勾勒出你是如何做这件事的。

1856
00:54:39,060 --> 00:54:41,430
0,90 90,300 300,1290 1680,2130 2130,2370
me first of sketch out

1857
00:54:41,430 --> 00:54:42,120
0,180 180,300 300,390 390,570 570,690
how you can make this

1858
00:54:42,120 --> 00:54:43,060
0,420
work.|
|

1859
00:54:43,300 --> 00:54:43,960
0,150 150,270 270,390 390,570 570,660
And this is sort of
这是一种粗略的，我们也是这样做的。

1860
00:54:43,960 --> 00:54:45,340
0,390 390,660 660,840 840,1110 1110,1380
roughly, let's Go does too.|
|

1861
00:54:45,670 --> 00:54:47,320
0,660 750,960 960,1050 1050,1320 1320,1650
So, so the way you
所以，你的想法是，当客户，

1862
00:54:47,320 --> 00:54:48,190
0,180 180,360 360,450 450,570 570,870
think about it is that

1863
00:54:48,220 --> 00:54:49,840
0,240 240,300 300,990
when the client,|
|

1864
00:54:50,060 --> 00:54:52,260
0,300 300,480 480,840 870,1590
so here our program,|
所以在这里我们的程序，|

1865
00:54:52,660 --> 00:54:53,860
0,390 390,570 570,630 630,900 900,1200
and when the client calls
当客户端调用函数fn时，函数中包含x和y。

1866
00:54:53,860 --> 00:54:55,540
0,120 120,540 540,1200 1230,1440 1440,1680
the function fn with x

1867
00:54:55,540 --> 00:54:57,060
0,120 120,420 420,660 660,930
and y in it.|
|

1868
00:54:57,210 --> 00:54:58,290
0,180 180,480 480,750 750,840 840,1080
{} What does it actually
它实际上叫什么，叫做存根，

1869
00:54:58,290 --> 00:55:00,150
0,480 480,780 780,930 930,1200 1200,1860
calls something that's called stub,|
|

1870
00:55:01,350 --> 00:55:02,970
0,510 510,750 750,810 810,1230 1230,1620
and stub is basically local
而存根基本上是本地函数，

1871
00:55:02,970 --> 00:55:04,530
0,510 540,690 690,840 840,1080 1080,1560
function,| you know call fn
|你知道，调用fn，并用两个参数声明x和y

1872
00:55:05,010 --> 00:55:06,720
0,390 390,690 690,870 870,1320 1320,1710
and with two arguments {}

1873
00:55:06,840 --> 00:55:08,220
0,540 540,660 660,810 810,900 900,1380
declared that x and y|
|

1874
00:55:08,370 --> 00:55:09,480
0,210 210,540 540,690 690,780 780,1110
and basically what the stub
以及存根的基本功能。

1875
00:55:09,480 --> 00:55:10,520
0,450
does.|
|

1876
00:55:11,280 --> 00:55:12,090
0,180 180,360 360,570 570,690 690,810
{} You think this is
你认为这是一个存根程序，

1877
00:55:12,090 --> 00:55:14,070
0,120 120,390 390,1170 1260,1590 1590,1980
a stub procedure,| but stub
|但存根程序的基本功能是构建消息，

1878
00:55:14,070 --> 00:55:15,600
0,360 360,540 540,660 660,1320 1320,1530
procedure {basically -} does, build

1879
00:55:15,600 --> 00:55:16,740
0,30 30,660
a message,|
|

1880
00:55:17,200 --> 00:55:18,700
0,630 630,720 720,810 810,1200 1200,1500
{} you know saying which
你知道说哪个函数需要被调用，

1881
00:55:18,700 --> 00:55:20,080
0,390 390,570 570,690 690,780 780,1380
function needs to be called,|
|

1882
00:55:20,380 --> 00:55:22,330
0,300 300,1020 1020,1140 1140,1230 1230,1950
the arguments of the function,|
函数的参数，|

1883
00:55:22,330 --> 00:55:23,920
0,90 90,180 180,300 300,660 660,1590
you know the types of
你知道争论的类型，

1884
00:55:24,040 --> 00:55:25,780
0,600 600,870 900,1470 1470,1560 1560,1740
arguments,| the values of these
|这些论点的价值等等。

1885
00:55:25,780 --> 00:55:28,040
0,690 780,1290 1290,1800
arguments etc etc.|
|

1886
00:55:28,130 --> 00:55:30,740
0,120 120,660 870,1380 1380,1800 1800,2610
And then {} what the
然后这些东西实际上做了什么，它通过网络发送

1887
00:55:30,920 --> 00:55:32,120
0,270 270,510 510,810 810,960 960,1200
stuff does actually it sends

1888
00:55:32,120 --> 00:55:33,590
0,90 90,300 300,390 390,990 1170,1470
it over the network| to
|到服务器上的相应存根。

1889
00:55:33,590 --> 00:55:35,810
0,210 210,1110 1140,1590 1590,1680 1680,2220
{} corresponding stub {at,the} server.|
|

1890
00:55:39,010 --> 00:55:41,080
0,390 420,870 870,1260 1260,1440 1440,2070
So server receives this message,|
因此服务器接收到该消息，|

1891
00:55:42,000 --> 00:55:44,160
0,330 330,960 1110,1260 1260,1530
and basically you know
基本上，你知道，传达了这样的信息，

1892
00:55:44,220 --> 00:55:46,040
0,90 90,330 330,450 450,1110
{} takes this message,|
|

1893
00:55:46,040 --> 00:55:48,770
0,450 480,1110 1110,1260 1260,1800 2370,2730
and marshall and marshall is
而马歇尔和马歇尔是一个术语，基本上是用来将值从字节数组转换回值。

1894
00:55:48,770 --> 00:55:50,600
0,570 600,1020 1020,1230 1230,1470 1470,1830
a term that's being used

1895
00:55:50,600 --> 00:55:53,420
0,60 60,390 390,1110 1530,2010 2010,2820
to basically convert {} values

1896
00:55:53,450 --> 00:55:55,730
0,630 750,1350 1350,1440 1440,2010 2010,2280
{from -} { -} byte

1897
00:55:55,730 --> 00:55:57,500
0,480 600,900 900,1110 1110,1530 1530,1770
arrays, byte arrays back to

1898
00:55:57,500 --> 00:55:58,680
0,720
values.|
|

1899
00:55:58,870 --> 00:56:00,070
0,240 240,390 390,1020 1020,1080 1080,1200
And then calls you know
然后在服务器上调用这个函数fn，

1900
00:56:00,070 --> 00:56:02,140
0,150 150,870 1020,1800 1800,1980 1980,2070
this function fn at the

1901
00:56:02,140 --> 00:56:04,690
0,630 810,1260 1260,1470 1470,1860 1860,2550
server,| {} here's our fn
|这是我们的FN x，诸如此类。

1902
00:56:04,900 --> 00:56:06,200
0,510
x,

1903
00:56:06,260 --> 00:56:07,760
0,180 180,360 360,960
blah blah blah.|
|

1904
00:56:09,620 --> 00:56:10,760
0,210 210,360 360,570 570,870 870,1140
So {stub -} basically calls
因此，存根基本上调用该函数，

1905
00:56:10,760 --> 00:56:12,170
0,90 90,540 540,630 630,960 960,1410
the function,| the function returns
|该函数返回到存根。

1906
00:56:12,170 --> 00:56:14,020
0,360 360,660 660,810 810,1290
back into the stub.|
|

1907
00:56:14,050 --> 00:56:15,370
0,180 180,420 420,1080 1080,1170 1170,1320
This stub marshals you know
这个存根编组了响应值，如z x+y。

1908
00:56:15,370 --> 00:56:18,220
0,420 420,900 900,1440 1470,2250 2490,2850
the response value {like,z} {}

1909
00:56:18,250 --> 00:56:19,900
0,330 330,510 510,1080
x plus y.|
|

1910
00:56:19,990 --> 00:56:21,880
0,600 810,1170 1170,1320 1320,1770 1770,1890
{} {And,since} that back you
因为您知道从客户机存根返回

1911
00:56:21,880 --> 00:56:23,780
0,120 120,750 780,1140
know to the

1912
00:56:24,050 --> 00:56:25,580
0,390 390,900 930,1080 1080,1320 1320,1530
client stub| and client stub
|而客户端存根仍在等待，

1913
00:56:25,580 --> 00:56:26,810
0,90 90,300 300,690 690,870 870,1230
is still waiting,| so basically
|因此，基本上客户端存根是它实际工作的方式，

1914
00:56:26,810 --> 00:56:27,710
0,90 90,390 390,600 600,690 690,900
the client stub the way

1915
00:56:27,710 --> 00:56:28,730
0,90 90,330 330,660 660,750 750,1020
it actually works,| it sends
|它发出请求，然后等待响应，

1916
00:56:28,730 --> 00:56:29,720
0,90 90,180 180,720 720,840 840,990
out the request and then

1917
00:56:29,720 --> 00:56:31,160
0,300 300,420 420,480 480,1050 1170,1440
wait for the response,| when
|当回应回来的时候，

1918
00:56:31,160 --> 00:56:32,510
0,90 90,480 480,690 690,960 960,1350
the response comes back in,|
|

1919
00:56:32,840 --> 00:56:34,620
0,150 150,270 270,570 570,1350
you know it unmarshalls,|
你知道的，你知道的，|

1920
00:56:38,120 --> 00:56:39,290
0,150 150,510 540,780 780,1110 1110,1170
and then it returns the
然后它将值返回给客户端，对吧。

1921
00:56:39,290 --> 00:56:40,910
0,330 330,450 450,510 510,1020 1380,1620
value to the client, right.|
|

1922
00:56:40,910 --> 00:56:42,710
0,120 120,510 510,930 930,1140 1140,1800
So, basically these two stub,|
所以，基本上这两个存根，|

1923
00:56:43,040 --> 00:56:44,990
0,420 420,600 600,660 660,1140 1140,1950
{} sort of make a
某种程度上使远程过程调用看起来像是常规过程调用

1924
00:56:45,020 --> 00:56:46,430
0,300 300,630 630,1020 1020,1200 1200,1410
remote procedure call look like

1925
00:56:46,430 --> 00:56:48,050
0,210 210,540 540,900 900,1200 1380,1620
a regular procedure call| for
|因为你几乎看不出来。

1926
00:56:48,050 --> 00:56:49,540
0,270 270,360 360,600 600,990
almost you can't tell.|
|

1927
00:56:49,820 --> 00:56:52,880
0,450 690,930 930,1140 1140,1860 2100,3060
{} And the key, and
密钥和这些存根通常是自动生成的，

1928
00:56:53,330 --> 00:56:54,590
0,390 390,690 690,720 720,1200 1200,1260
these stubs are generally you

1929
00:56:54,590 --> 00:56:56,780
0,120 120,630 630,1200 1800,2070 2070,2190
know automatically generated,| so the
|因此，编译器以及将为您生成两个存根的编译器，

1930
00:56:56,780 --> 00:56:58,700
0,660 660,930 930,1320 1320,1410 1410,1920
compiler and {in,case} the compiler

1931
00:56:58,700 --> 00:56:59,810
0,210 210,360 360,750 750,810 810,1110
that will generate two stubs

1932
00:56:59,810 --> 00:57:02,180
0,240 240,630 720,1470 1470,2130 2160,2370
for you,| {} and {}
|并为你整理和拆分论点。

1933
00:57:02,180 --> 00:57:04,190
0,330 330,780 810,1260 1260,1470 1470,2010
do the marshalling and unmarshalling

1934
00:57:04,190 --> 00:57:05,500
0,420 420,690 690,840
arguments for you.|
|

1935
00:57:06,200 --> 00:57:08,600
0,540 540,1230 1260,1890 1950,2160 2160,2400
{} And {} and also
以及它是如何发展的。

1936
00:57:08,600 --> 00:57:11,270
0,240 240,720 1050,1410 1410,2070 2100,2670
how {it,goes}.| Also the, so
|还有，所以当你从服务器到客户端做这件事时，

1937
00:57:11,360 --> 00:57:12,830
0,270 270,480 480,930 930,1170 1170,1470
when you're doing it from

1938
00:57:12,830 --> 00:57:14,150
0,180 180,630 630,750 750,870 870,1320
the server to the client,|
|

1939
00:57:14,150 --> 00:57:15,860
0,180 180,510 510,870 870,1230 1230,1710
there's also another stub again?|
还有另一个存根吗？|

1940
00:57:16,190 --> 00:57:18,050
0,720 720,1080 1080,1470 1470,1770 1770,1860
You basically return back to
您基本上返回到第一个存根。

1941
00:57:18,050 --> 00:57:19,700
0,240 480,780 780,1200
the first stub.|
|

1942
00:57:19,700 --> 00:57:20,960
0,150 150,420 420,840 840,1260 1260,1260
So this stub makes a
所以这个存根发出一个过程调用，主要调用过程Fn，

1943
00:57:20,960 --> 00:57:22,790
0,450 450,780 780,1080 1110,1500 1500,1830
procedure call to majorly calls

1944
00:57:22,790 --> 00:57:24,740
0,60 60,480 480,1110 1410,1560 1560,1950
the procedure fn,| that procedure
|该过程直接返回到存根，

1945
00:57:24,740 --> 00:57:26,300
0,570 570,810 810,1170 1170,1260 1260,1560
returns right into the stub,|
|

1946
00:57:26,300 --> 00:57:28,100
0,300 480,870 870,1230 1230,1440 1650,1800
because stub called it.| Oh,
因为斯塔布说了算。|哦，这是同样的存根，它在里面。

1947
00:57:28,100 --> 00:57:29,180
0,120 120,240 240,600 600,930 930,1080
it's the same stub, that

1948
00:57:29,180 --> 00:57:31,320
0,150 150,450 450,690 990,1650
it goes in.| Exactly.|
|一点儿没错。|

1949
00:57:31,780 --> 00:57:33,060
0,630
{Got,it}.|
明白了。|

1950
00:57:33,060 --> 00:57:34,820
0,390
Okay?|
好吧?|

1951
00:57:34,940 --> 00:57:36,290
0,210 210,510 510,990 1020,1170 1170,1350
Okay, so, {} let me
好的，那么，让我向你展示这是如何在围棋中进行的。

1952
00:57:36,290 --> 00:57:37,730
0,240 240,780 780,960 960,1140 1140,1440
show you how this plays

1953
00:57:37,730 --> 00:57:40,480
0,300 300,810 810,900 900,2190
out inside of Go.|
|

1954
00:57:43,320 --> 00:57:45,690
0,510 510,1050 1050,1500 1500,2070 2070,2370
And by showing you a
通过向您展示一个非常简单的键值服务器。

1955
00:57:45,690 --> 00:57:48,060
0,240 240,1020 1290,1440 1440,1770 1770,2370
very simple {key-value -} server.|
|

1956
00:57:48,730 --> 00:57:49,980
0,660

1957
00:57:50,010 --> 00:57:51,420
0,270 270,450 450,750 750,1140 1140,1410
And you'll see,| it doesn't
你会看到，|它看起来并不完全是我们的过程调用，

1958
00:57:51,420 --> 00:57:52,920
0,120 120,750 750,870 870,1230 1230,1500
look exactly our procedure calls,|
|

1959
00:57:52,920 --> 00:57:54,920
0,120 120,480 510,780 780,1350
but it's pretty close.|
但已经很接近了。|

1960
00:57:54,920 --> 00:57:56,840
0,690 960,1200 1200,1350 1350,1680 1680,1920
{} So the typical thing
所以典型的情况是

1961
00:57:56,840 --> 00:57:58,640
0,240 240,540 540,870 870,1080 1080,1800
is that| you actually declare
|实际上，您声明典型约定应该是主要目标

1962
00:57:58,700 --> 00:58:01,190
0,900 930,1680 1680,1890 1890,1980 1980,2490
typical convention should be {main,goal}|
|

1963
00:58:01,190 --> 00:58:03,770
0,210 210,360 360,1950 2460,2580 2580,2580
that you declare { -}
您声明了参数结构

1964
00:58:05,180 --> 00:58:06,980
0,180 180,600 600,1350 1350,1470 1470,1800
the argument structure| and so
|因此，我们将实施两个程序，

1965
00:58:06,980 --> 00:58:07,880
0,120 120,240 240,420 420,780 780,900
we're going to implement two

1966
00:58:07,880 --> 00:58:09,020
0,690
procedures,|
|

1967
00:58:09,020 --> 00:58:10,310
0,120 120,390 390,780 780,960 960,1290
two remote procedures,| one {is,put}
两个远程程序，|一个是放入，一个是得到

1968
00:58:10,430 --> 00:58:12,110
0,120 120,240 240,360 360,780 1200,1680
and one is get| and
|而PUT基本上就是PUT参数，是通过PUT和PUT回应的参数，

1969
00:58:12,110 --> 00:58:13,760
0,330 330,840 840,1140 1140,1500 1500,1650
{put,is} basically put arguments is

1970
00:58:13,760 --> 00:58:14,780
0,150 150,600 600,690 690,780 780,1020
the arguments through the put

1971
00:58:14,780 --> 00:58:16,160
0,120 120,300 300,750 750,810 810,1380
and put replies to response,|
|

1972
00:58:16,160 --> 00:58:17,630
0,540 540,750 750,990 990,1290 1290,1470
similar there's get arguments with
类似地，他们的请求中也有GET参数，其中参数通过请求、GET过程和应答。

1973
00:58:17,630 --> 00:58:19,790
0,480 480,1050 1050,1440 1440,1710 1710,2160
their request where the arguments

1974
00:58:19,790 --> 00:58:21,530
0,150 150,300 300,750 780,1110 1110,1740
through the request, get procedure

1975
00:58:21,650 --> 00:58:22,880
0,150 150,240 240,750
and the reply.|
|

1976
00:58:23,690 --> 00:58:24,470
0,150 150,270 270,420 420,540 540,780
And so let me first
所以让我先来看看服务器，

1977
00:58:24,470 --> 00:58:25,490
0,120 120,210 210,270 270,840 870,1020
look at the server,| so
|这里有两个函数，

1978
00:58:25,490 --> 00:58:27,050
0,270 270,390 390,600 600,1320 1410,1560
here are two functions,| you
|实际上，我们要在服务器上调用的两个函数。

1979
00:58:27,050 --> 00:58:29,210
0,210 210,660 660,1140 1170,1770 1830,2160
know actually the two function

1980
00:58:29,210 --> 00:58:29,660
0,90 90,180 180,300 300,360 360,450
that we're going to be

1981
00:58:29,660 --> 00:58:31,660
0,450 450,810 810,870 870,1470
calling on the server.|
|

1982
00:58:31,840 --> 00:58:33,700
0,690 720,1020 1020,1290 1320,1620 1620,1860
I think I'll skip down
我想我还是跳过这一步吧。

1983
00:58:33,700 --> 00:58:34,540
0,90 90,240 240,330 330,390 390,840
for that for a second.|
|

1984
00:58:35,370 --> 00:58:38,360
0,390 420,630 630,1110 1530,2400
So we actually. {}|
所以我们实际上。|

1985
00:58:41,220 --> 00:58:42,570
0,360 360,660 660,930 960,1170 1170,1350
Let me {} talk about
让我稍微谈一谈，

1986
00:58:42,570 --> 00:58:43,170
0,90 90,150 150,330 330,510 510,600
it a little bit,| so
|这就是客户端，

1987
00:58:43,170 --> 00:58:44,550
0,210 210,330 330,480 480,930 930,1380
this is the client side,|
|

1988
00:58:45,180 --> 00:58:46,230
0,240 240,390 390,480 480,810 810,1050
{} so the client calls
因此，客户端调用一个函数GET

1989
00:58:46,230 --> 00:58:48,270
0,90 90,420 420,870 900,1530 1530,2040
a function get| and {}
|在Get You Know中，这个函数实际上连接到服务器

1990
00:58:48,270 --> 00:58:49,530
0,330 330,750 750,810 810,1140 1140,1260
what inside of get you

1991
00:58:49,530 --> 00:58:51,240
0,180 180,750 960,1140 1140,1380 1380,1710
know you know this function

1992
00:58:51,240 --> 00:58:52,440
0,210 210,600 600,720 720,810 810,1200
actually connects to the server|
|

1993
00:58:52,440 --> 00:58:53,370
0,120 120,330 330,660 660,780 780,930
and see exactly what that
看看这到底是什么意思，

1994
00:58:53,370 --> 00:58:55,890
0,480 960,1650 1650,1710 2040,2280 2280,2520
means,| {} it, it fills
|它，它填充了论据

1995
00:58:55,890 --> 00:58:57,240
0,120 120,210 210,870 870,990 990,1350
in the arguments| and allocates
|并分配响应，然后调用此过程客户端

1996
00:58:57,240 --> 00:58:58,470
0,120 120,660 660,780 780,930 930,1230
a response and then calls

1997
00:58:58,470 --> 00:59:00,540
0,180 180,600 600,1260 1260,1560 1560,2070
this procedure client| calls call
|调用调用您可以将其视为通用存根，

1998
00:59:00,570 --> 00:59:01,350
0,180 180,270 270,420 420,630 630,780
you can think about this

1999
00:59:01,350 --> 00:59:03,120
0,120 120,270 270,750 750,1230 1590,1770
as a generic stub,| that
|这基本上采用了服务器中需要调用的方法

2000
00:59:03,120 --> 00:59:04,350
0,300 300,600 600,720 720,1110 1110,1230
basically takes the method that

2001
00:59:04,350 --> 00:59:05,040
0,150 150,240 240,330 330,570 570,690
needs to be called in

2002
00:59:05,040 --> 00:59:06,570
0,660 690,900 900,990 990,1410 1410,1530
server| and the arguments in
|以及答复中的论点，

2003
00:59:06,570 --> 00:59:08,220
0,60 60,570 930,1350 1350,1500 1500,1650
the reply,| {and,so} which has
|所以它有三个论点，

2004
00:59:08,220 --> 00:59:10,180
0,150 150,780 960,1080 1080,1590
three arguments,| the method,
|方法，回应的论点。

2005
00:59:10,180 --> 00:59:12,760
0,120 120,960 1200,1410 1410,2040
the argument in response.|
|

2006
00:59:13,200 --> 00:59:15,960
0,600 630,1020 1020,1650 1650,2280 2370,2760
And call internally will send
而内部调用将向Marshal发送参数，

2007
00:59:15,960 --> 00:59:18,180
0,450 450,720 720,1470 1770,1980 1980,2220
marshal the arguments,| {} send
|通过连接将消息发送到服务器

2008
00:59:18,180 --> 00:59:19,320
0,60 60,390 390,510 510,630 630,1140
the message to the server

2009
00:59:19,320 --> 00:59:21,690
0,480 480,900 930,1620 1860,2160 2160,2370
over the connection| and wait
|并在回复到来时等待响应回复，

2010
00:59:21,690 --> 00:59:23,700
0,120 120,240 240,990 1230,1800 1800,2010
for the response reply when

2011
00:59:23,700 --> 00:59:24,720
0,60 60,390 420,600 600,870 870,1020
the reply comes in,| the
|应答结构将由调用存根填充

2012
00:59:24,720 --> 00:59:25,890
0,330 330,630 630,750 750,870 870,1170
reply structure will be filled

2013
00:59:25,890 --> 00:59:27,330
0,210 210,420 420,540 540,870 870,1440
in by the call stub|
|

2014
00:59:27,540 --> 00:59:28,740
0,210 210,450 450,720 720,900 900,1200
and then when that's done|
然后当这件事完成后|

2015
00:59:28,740 --> 00:59:30,030
0,270 270,690 690,870 870,930 930,1290
then return after {} call
然后在呼叫后返回。

2016
00:59:30,030 --> 00:59:31,120
0,660
call.|
|

2017
00:59:32,240 --> 00:59:33,560
0,240 240,570 570,780 780,960 960,1320
And basically put looks exactly
基本上，Put看起来是完全一样的。

2018
00:59:33,560 --> 00:59:34,740
0,90 90,330 330,630
the same way.|
|

2019
00:59:36,680 --> 00:59:37,370
0,120 120,210 210,330 330,390 390,690
And so on the server
因此，在服务器端，

2020
00:59:37,370 --> 00:59:38,840
0,480 840,1050 1050,1230 1230,1350 1350,1470
side,| {you,know} let's see how
|你知道，让我们看看这是如何实施的。

2021
00:59:38,840 --> 00:59:40,360
0,180 180,270 270,930
that is implemented.|
|

2022
00:59:40,360 --> 00:59:41,230
0,120 120,420 420,630 630,720 720,870
The server has a {key-value
服务器具有键-值映射，

2023
00:59:41,230 --> 00:59:43,600
0,480 480,1050 1050,1410 1410,1740 1770,2370
-} map,| this is nothing
|这只是一张常规的围棋地图。

2024
00:59:43,600 --> 00:59:44,740
0,270 270,390 390,540 540,930 930,1140
else than a regular Go

2025
00:59:44,740 --> 00:59:45,700
0,450
map.|
|

2026
00:59:45,700 --> 00:59:49,280
0,750 1020,1860 2310,3000
{} And, {}
让我看看实际上的键值结构，

2027
00:59:50,010 --> 00:59:51,240
0,390 390,480 480,720 720,1080 1080,1230
let me see actually the

2028
00:59:51,240 --> 00:59:52,940
0,180 180,570 570,1140
{key-value -} struct,|
|

2029
00:59:55,450 --> 00:59:57,920
0,660 660,1290 1320,1890
declared somewhere. {}|
在某个地方宣布的。|

2030
00:59:58,930 --> 01:00:00,130
0,270 270,600 600,750 750,960 960,1200
Oh, sorry it's right above
哦，对不起，它就在上面，

2031
01:00:00,130 --> 01:00:01,810
0,210 690,1020 1050,1290 1290,1350 1350,1680
it,| so there's a structure
|所以有一种叫做KV的结构，

2032
01:00:01,810 --> 01:00:03,460
0,270 270,930 960,1200 1200,1530 1530,1650
called KV,| that actually has
|它实际上有一些互斥体和一个贴图

2033
01:00:03,460 --> 01:00:04,900
0,90 90,600 600,930 930,1140 1140,1440
some mutex and a map

2034
01:00:04,900 --> 01:00:06,070
0,120 120,330 630,870 870,930 930,1170
in it| and the map
|这张地图就像我们要做的是放入和获取操作。

2035
01:00:06,070 --> 01:00:06,880
0,180 180,360 360,630 630,750 750,810
is like we're going to

2036
01:00:06,880 --> 01:00:07,540
0,120 120,210 210,390 390,480 480,660
do the put and get

2037
01:00:07,540 --> 01:00:08,780
0,510 510,720
operations on.|
|

2038
01:00:10,320 --> 01:00:12,120
0,180 180,330 330,570 570,1020 1020,1800
And there's a little preamble|
有一个小小的前言|

2039
01:00:12,120 --> 01:00:13,230
0,420 420,510 510,690 690,930 930,1110
that you need to sort
您需要编写一些代码来设置服务器，

2040
01:00:13,230 --> 01:00:14,700
0,90 90,510 510,690 690,900 900,1470
of write {} to setup

2041
01:00:14,700 --> 01:00:16,200
0,60 60,630 900,1140 1140,1260 1260,1500
a server,| {} but here
|但事实就是这样，

2042
01:00:16,200 --> 01:00:18,180
0,90 90,510 780,1650 1650,1800 1800,1980
it is,| {} you know
|您知道，您基本上分配了一个新的服务器对象，

2043
01:00:18,180 --> 01:00:20,340
0,420 420,1110 1200,1650 1650,2100 2100,2160
you basically {} allocate a

2044
01:00:20,340 --> 01:00:22,650
0,180 180,750 750,1350 1680,2040 2040,2310
new server object,| and then
|然后这是RPC寄存器KV将进行的密钥操作，

2045
01:00:22,650 --> 01:00:24,120
0,180 180,390 390,480 480,720 720,1470
this is the key operation

2046
01:00:24,420 --> 01:00:28,440
0,480 480,960 960,1830 2010,2910 2940,4020
RPC register KV will,| register
|基本上向RPC服务器注册在KV结构上实现的所有方法。

2047
01:00:28,440 --> 01:00:29,940
0,390 390,690 690,810 810,1320 1320,1500
basically all the methods that

2048
01:00:29,940 --> 01:00:31,800
0,120 120,840 840,1200 1200,1380 1380,1860
are implemented on the KV

2049
01:00:31,800 --> 01:00:33,690
0,540 570,870 870,960 960,1380 1380,1890
struct with the RPC server.|
|

2050
01:00:35,010 --> 01:00:37,740
0,180 180,540 540,1170 1500,2100 2130,2730
With one [twist], the methods
只有一个[转折]，这些方法只命名为大写字母，

2051
01:00:37,740 --> 01:00:40,560
0,360 360,480 480,1080 1080,1620 2010,2820
only the capital named {

2052
01:00:40,890 --> 01:00:43,740
0,1470 1470,1470 2310,2670 2670,2790 2790,2850
- -},| methods with the
|用大写的方法实际上会被记录下来

2053
01:00:43,740 --> 01:00:45,450
0,570 960,1140 1140,1320 1320,1590 1590,1710
capital {} will actually be

2054
01:00:45,450 --> 01:00:47,940
0,540 630,810 810,1110 1140,1950 2040,2490
recorded| and so basically Go
|所以基本上使用大写名称来表示公共方法，

2055
01:00:47,940 --> 01:00:49,260
0,300 300,450 450,930 930,1230 1230,1320
use {} capital names to

2056
01:00:49,260 --> 01:00:52,500
0,780 780,1350 1380,2040 2040,2520 2610,3240
indicate public methods,| and {}
|并且具有小写的方法是私有方法，

2057
01:00:52,500 --> 01:00:54,360
0,150 150,660 660,810 810,870 870,1860
a method with a small

2058
01:00:54,630 --> 01:00:56,280
0,390 390,930 1020,1230 1230,1350 1350,1650
small caps is in private

2059
01:00:56,280 --> 01:00:59,070
0,510 840,1200 1200,1860 1890,2310 2310,2790
method,| so only, basically RPC
|因此，基本上RPC寄存器只导出大写的方法，

2060
01:00:59,070 --> 01:01:02,550
0,630 690,1620 1800,2190 2190,3000 3000,3480
register exports only capitalized methods,|
|

2061
01:01:02,820 --> 01:01:03,780
0,210 210,300 300,570 570,630 630,960
for example, here's a method
例如，下面是一个方法，使用GET方法，

2062
01:01:03,780 --> 01:01:05,010
0,360 360,510 510,630 630,840 840,1230
below, use a Get method,|
|

2063
01:01:05,430 --> 01:01:06,720
0,240 240,420 420,480 480,810 810,1290
it has a capital letter|
它有一个大写字母|

2064
01:01:07,020 --> 01:01:09,210
0,600 600,1080 1110,1470 1470,2010 2010,2190
and by calling register that
并且通过调用REGISTER，该方法不能通过应用于服务器的连接来调用。

2065
01:01:09,210 --> 01:01:10,410
0,270 270,360 360,540 540,1020 1020,1200
method is not callable by

2066
01:01:10,410 --> 01:01:11,490
0,480 480,570 570,630 630,990 990,1080
applying to the connection the

2067
01:01:11,490 --> 01:01:12,480
0,450
server.|
|

2068
01:01:14,040 --> 01:01:17,010
0,210 210,630 630,1440 1470,2310 2310,2970
So {the,server} internally,| basically it
因此，服务器在内部，|基本上，它创建了一个TCP连接，

2069
01:01:17,010 --> 01:01:19,260
0,270 270,360 360,720 720,1410 1650,2250
creates a TCP connection, {}|
|

2070
01:01:19,260 --> 01:01:21,000
0,390 390,750 750,930 930,1320 1320,1740
and waits on TCP connection
并等待TCP连接，以获取对新的连接请求的请求，

2071
01:01:21,000 --> 01:01:22,770
0,570 600,870 870,1050 1050,1560 1560,1770
to get a request for

2072
01:01:22,770 --> 01:01:24,450
0,60 60,750 780,1170 1170,1500 1500,1680
a new connection request for

2073
01:01:24,450 --> 01:01:26,070
0,300 300,720 720,840 840,960 960,1620
TCP connection,| and then calls
|然后调用RPC ServeConn来服务该TCP连接。

2074
01:01:26,160 --> 01:01:28,590
0,390 390,1290 1290,1620 1620,2190 2220,2430
{RPC -} {ServeConn -} to

2075
01:01:28,590 --> 01:01:30,380
0,330 330,480 480,810 810,1290
serve that TCP connection.|
|

2076
01:01:30,380 --> 01:01:32,090
0,120 120,810 960,1260 1260,1590 1590,1710
And basically every message that
基本上，你所知道的每一条信息都是相互联系的，

2077
01:01:32,090 --> 01:01:33,440
0,240 240,570 600,960 960,1200 1230,1350
comes in over that you

2078
01:01:33,440 --> 01:01:35,570
0,120 120,780 960,1170 1170,1350 1350,2130
know connection,| it will automatically
|它会自动找到正确的方法，

2079
01:01:35,570 --> 01:01:36,890
0,270 270,360 360,600 600,1110 1170,1320
find the right method,| you
|您知道与该消息相关联

2080
01:01:36,890 --> 01:01:38,210
0,240 240,480 480,1080 1080,1260 1260,1320
know is associated with the

2081
01:01:38,210 --> 01:01:40,370
0,570 750,1320 1320,1650 1650,1830 1830,2160
message| and call that method
|并使用未编组的参数和编组应答调用该方法。

2082
01:01:40,370 --> 01:01:42,380
0,330 360,720 720,870 870,1410 1410,2010
with {} {unmarshalled -} arguments

2083
01:01:42,380 --> 01:01:44,100
0,390 390,720 720,1230
and marshal reply.|
|

2084
01:01:45,380 --> 01:01:46,160
0,150 150,210 210,600 600,720 720,780
So, for example if the
例如，如果客户端调用GET，

2085
01:01:46,160 --> 01:01:47,450
0,390 390,660 660,1080 1080,1170 1170,1290
client calls Get,| you know
|你知道，连接到它将呼叫使这种连接成为存在

2086
01:01:47,450 --> 01:01:49,040
0,300 300,510 510,690 690,990 990,1590
connects to it will call

2087
01:01:49,370 --> 01:01:51,290
0,420 420,540 540,990 990,1200 1200,1920
makes this connection into existence|
|

2088
01:01:51,650 --> 01:01:52,430
0,150 150,300 300,390 390,450 450,780
and then if the client
然后，如果客户端使用GET调用Call，

2089
01:01:52,430 --> 01:01:54,920
0,390 390,1050 1080,1440 1440,1860 2040,2490
calls call with Get,| then
|然后将运行该GET函数。

2090
01:01:54,920 --> 01:01:56,000
0,120 120,450 450,840 840,960 960,1080
this Get function will be

2091
01:01:56,000 --> 01:01:56,820
0,300
run.|
|

2092
01:01:57,280 --> 01:01:58,030
0,330 330,420 420,510 510,600 600,750
And as you can see
正如您所看到的GET函数，

2093
01:01:58,030 --> 01:01:59,200
0,90 90,270 270,720 720,1020 1020,1170
the Get function,| first thing
|它做的第一件事是，

2094
01:01:59,200 --> 01:02:00,070
0,90 90,330 330,420 420,660 660,870
it does,| it actually takes
|它实际上是锁在外面的，

2095
01:02:00,070 --> 01:02:02,680
0,90 90,600 600,1020 1320,1800 1830,2610
a {lock,out},| because {} multiple
|因为多个客户端可能正在调用服务器

2096
01:02:03,250 --> 01:02:04,360
0,390 390,570 570,660 660,1020 1020,1110
clients could be calling the

2097
01:02:04,360 --> 01:02:05,410
0,510 510,630 630,750 750,840 840,1050
server| and so there will
|因此将会有多个大猩猩同时运行，

2098
01:02:05,410 --> 01:02:06,940
0,150 150,510 510,750 750,1140 1140,1530
be multiple {goroutines -} running

2099
01:02:06,940 --> 01:02:08,500
0,120 120,180 180,450 450,1020 1050,1560
at the same time,| perhaps
|也许调用GET和PUT。

2100
01:02:08,500 --> 01:02:10,240
0,390 390,750 750,930 930,1260
invoking get and put.|
|

2101
01:02:10,580 --> 01:02:11,900
0,240 240,360 360,480 480,690 690,1320
And so they were manipulating
所以他们同时在操纵地图

2102
01:02:11,900 --> 01:02:14,240
0,570 660,1110 1140,1650 1680,2250 2250,2340
the the map concurrently| and
|因此，我们需要确保你知道这些是以原子的方式完成的，

2103
01:02:14,240 --> 01:02:14,810
0,120 120,210 210,330 330,390 390,570
so we need to make

2104
01:02:14,810 --> 01:02:16,040
0,210 210,510 510,630 630,750 750,1230
sure that you know those

2105
01:02:16,070 --> 01:02:17,870
0,1170 1170,1290 1290,1500 1500,1680 1680,1800
that is done in an

2106
01:02:17,870 --> 01:02:19,240
0,390 390,840
atomic way,|
|

2107
01:02:19,240 --> 01:02:20,710
0,360 360,660 660,840 840,1020 1020,1470
so therefore we use locks.|
因此，我们使用锁。|

2108
01:02:22,210 --> 01:02:23,560
0,150 150,210 210,390 390,960 1080,1350
So the Get function looks
因此，GET函数查看映射中的密钥，

2109
01:02:23,560 --> 01:02:25,540
0,120 120,810 1170,1620 1620,1890 1890,1980
at the key into the

2110
01:02:25,540 --> 01:02:27,220
0,330 330,630 630,1200 1200,1620 1620,1680
map,| looks {at,the} key in
|查看映射中的键，基本上返回值。

2111
01:02:27,220 --> 01:02:28,510
0,60 60,480 480,870 870,1230 1230,1290
the map, returns basically the

2112
01:02:28,510 --> 01:02:29,580
0,570
value.|
|

2113
01:02:29,580 --> 01:02:31,290
0,390 390,630 630,840 840,1320 1320,1710
{} If there's no entry
如果地图上没有条目，

2114
01:02:31,290 --> 01:02:32,190
0,60 60,120 120,540 540,660 660,900
in the map,| it will
|它将返回ErrNoKey，

2115
01:02:32,190 --> 01:02:34,530
0,720 750,1230 1230,1830 1830,2280 2280,2340
return {ErrNoKey -},| otherwise it
|否则，它将返回适当的值

2116
01:02:34,530 --> 01:02:37,020
0,120 120,720 750,1020 1020,1740 1740,2490
will return the appropriate value|
|

2117
01:02:37,170 --> 01:02:38,300
0,150 150,300 300,540
and that's it.|
就是这样。|

2118
01:02:38,490 --> 01:02:39,780
0,420 420,810 810,900 900,960 960,1290
And so on the server
因此，在服务器端，

2119
01:02:39,780 --> 01:02:41,100
0,360 360,570 570,720 720,930 930,1320
side,| when these Get function
|当这些GET函数返回时，

2120
01:02:41,100 --> 01:02:43,230
0,630 630,810 810,990 990,1740 1740,2130
returns,| it will marshal its
|它将组织自己的回应，

2121
01:02:43,230 --> 01:02:45,300
0,780 1110,1440 1440,1470 1470,1860 1860,2070
response,| sends a response back
|将响应发送回客户端，

2122
01:02:45,300 --> 01:02:47,340
0,90 90,630 630,1110 1110,1560 1590,2040
to client,| {the,client} will set
|客户端将对其进行解组设置，实际上将其返回给调用者。

2123
01:02:47,340 --> 01:02:48,840
0,180 180,510 510,930 930,1260 1260,1500
it {unmarshal -} it actually

2124
01:02:48,840 --> 01:02:50,300
0,330 330,450 450,510 510,990
{return,it} to the caller.|
|

2125
01:02:52,880 --> 01:02:54,530
0,300 300,450 450,900 930,1200 1200,1650
Okay, so that makes sense,|
好的，这就说得通了，|

2126
01:02:54,560 --> 01:02:56,060
0,180 180,330 330,510 510,630 630,1500
so that's sort of a
所以这在某种程度上是在做一个简单的键值服务器。

2127
01:02:56,060 --> 01:02:59,030
0,690 690,810 810,1440 1770,2580 2730,2970
do a simple {} {key-value

2128
01:02:59,030 --> 01:03:00,900
0,300 300,750 750,900 900,1320
-} server in action.|
|

2129
01:03:08,690 --> 01:03:09,440
0,240 240,330 330,480 480,540 540,750
Okay, I want to make
好的，我想再说一点，这是很重要的一点

2130
01:03:09,440 --> 01:03:10,850
0,360 360,570 570,1020 1020,1350 1350,1410
one more point which is

2131
01:03:10,850 --> 01:03:13,460
0,60 60,450 450,870 990,1740 2100,2610
an important point| and {}
|最后，重要的是要考虑的是

2132
01:03:13,520 --> 01:03:14,800
0,150 150,300 300,750
in the end,

2133
01:03:15,150 --> 01:03:16,860
0,870 870,1200 1200,1260 1260,1380 1380,1710
what's important to think about

2134
01:03:16,860 --> 01:03:18,870
0,180 180,570 570,1080 1080,1620 1620,2010
is| what RPC semantics are
|失败后的RPC语义是什么。

2135
01:03:19,080 --> 01:03:20,540
0,270 270,900
under failures.|
|

2136
01:03:30,160 --> 01:03:31,420
0,600

2137
01:03:31,600 --> 01:03:32,710
0,150 150,270 270,330 330,780 780,1110
So there are different types
因此可能存在不同类型的语义，

2138
01:03:32,710 --> 01:03:34,340
0,90 90,510 510,1050
of semantics possible,|
|

2139
01:03:34,460 --> 01:03:35,600
0,330 330,450 450,780 780,870 870,1140
something is called at least
某些东西至少会被调用一次，

2140
01:03:35,600 --> 01:03:36,760
0,540
once,|
|

2141
01:03:37,800 --> 01:03:38,850
0,270 270,540 540,690 690,750 750,1050
this all has to do
这一切都与服务器发生故障时客户端所做的事情有关，

2142
01:03:38,850 --> 01:03:40,230
0,300 300,660 660,810 810,900 900,1380
with what does the client

2143
01:03:40,230 --> 01:03:41,610
0,210 210,420 420,510 510,870 870,1380
do if the server fails,|
|

2144
01:03:42,000 --> 01:03:44,070
0,750 900,1110 1110,1230 1230,1560 1560,2070
so let's say {the,client} sends
假设客户端发送请求，服务器崩溃。

2145
01:03:44,070 --> 01:03:46,600
0,630 960,1080 1080,1380 1380,1890
request, the server crashes.|
|

2146
01:03:46,940 --> 01:03:49,640
0,720 990,1680 1680,1740 2040,2280 2280,2700
And, {} of course now
当然，现在的某个时刻，客户端将超时

2147
01:03:49,640 --> 01:03:50,630
0,180 180,300 300,600 600,870 870,990
at some point, client will

2148
01:03:50,630 --> 01:03:51,980
0,240 240,600 630,810 810,1020 1020,1350
{timeout -}| and just doesn't
|只是不知道手术是否真的发生了。

2149
01:03:51,980 --> 01:03:53,390
0,300 300,600 600,690 690,1110 1110,1410
know whether the operation actually

2150
01:03:53,390 --> 01:03:55,000
0,360 360,450 450,690 690,990
happened or not happened.|
|

2151
01:03:55,420 --> 01:03:57,100
0,300 300,510 510,750 750,1230 1230,1680
And at least once RPC
并且至少一次RPC语义意味着客户端将自动重试

2152
01:03:57,100 --> 01:03:59,230
0,660 660,1440 1440,1650 1650,1740 1740,2130
semantics means that the client

2153
01:03:59,230 --> 01:04:00,880
0,240 240,750 750,1320 1350,1530 1530,1650
will automatically retry| and will
|并将继续前进，

2154
01:04:00,880 --> 01:04:02,590
0,210 210,810 810,960 960,1500 1500,1710
keep going,| so it has
|因此，它至少执行过一次。

2155
01:04:02,590 --> 01:04:04,320
0,480 480,540 540,780 780,1260
executed at least once.|
|

2156
01:04:06,020 --> 01:04:07,400
0,420 450,900 900,960 960,1260 1260,1380
{} {The,downside}, of course at
当然，缺点是，至少一次是，您知道同一个操作可能会被多次执行，

2157
01:04:07,400 --> 01:04:08,300
0,180 180,420 420,570 570,780 780,900
least once is that you

2158
01:04:08,300 --> 01:04:09,470
0,150 150,270 270,510 510,960 960,1170
know the same operation might

2159
01:04:09,470 --> 01:04:11,090
0,90 90,480 480,930 930,1440 1470,1620
be executed multiple times,| so
|举个例子，如果你做了一个推杆，

2160
01:04:11,090 --> 01:04:11,900
0,450 450,510 510,600 600,750 750,810
{for,example} if you do a

2161
01:04:11,900 --> 01:04:12,980
0,390 450,570 570,750 750,900 900,1080
put,| you know the put
|你知道看跌期权实际上可能会被执行多次

2162
01:04:12,980 --> 01:04:14,480
0,180 180,330 330,660 660,1170 1170,1500
might be actually executed multiple

2163
01:04:14,480 --> 01:04:15,440
0,300 300,390 390,570 570,780 780,960
times| and at least one
|和至少一个RPC系统。

2164
01:04:15,440 --> 01:04:16,700
0,390 390,810
RPC system.|
|

2165
01:04:17,580 --> 01:04:18,690
0,120 120,390 390,570 570,1020 1020,1110
So that's not appropriate for
所以这并不适用于许多应用程序，

2166
01:04:18,690 --> 01:04:21,630
0,240 240,1110 1440,1590 1590,2190 2220,2940
many applications,| so another type
|因此，RPC系统中常见的另一种类型的语义是最多一次。

2167
01:04:21,630 --> 01:04:22,950
0,60 60,540 540,750 750,1230 1230,1320
of semantics, that's common in

2168
01:04:22,950 --> 01:04:24,090
0,150 150,420 420,870 870,1020 1020,1140
{RPC -} systems is at

2169
01:04:24,090 --> 01:04:25,440
0,300 300,750
most once.|
|

2170
01:04:27,830 --> 01:04:30,440
0,630 660,1260 1290,1830 1830,2160 2160,2610
So the corresponding server request
因此相应的服务器请求实际上执行了零次或一次，

2171
01:04:30,440 --> 01:04:33,320
0,300 300,840 840,1350 1620,2340
actually executed either {}

2172
01:04:33,590 --> 01:04:35,480
0,390 390,960 1050,1230 1230,1680 1680,1890
zero times or once,| but
|但不会超过一次。

2173
01:04:35,480 --> 01:04:37,060
0,180 180,450 450,630 630,1080
no more than once.|
|

2174
01:04:37,210 --> 01:04:38,170
0,390 390,450 450,720 720,870 870,960
And the way you know
而你知道的方式通常是通过过滤重复项来实现的，

2175
01:04:38,170 --> 01:04:39,610
0,210 210,300 300,660 660,1260 1260,1440
that is typically implemented by

2176
01:04:39,610 --> 01:04:41,680
0,420 420,990 1110,1410 1410,1770 1770,2070
filtering duplicates,| you actually doing
|你实际上会在后面的实验中做到这一点。

2177
01:04:41,680 --> 01:04:43,320
0,360 360,720 720,1020
that in {}

2178
01:04:44,200 --> 01:04:45,780
0,270 270,540 540,1080
in later labs.|
|

2179
01:04:46,280 --> 01:04:47,210
0,450 450,630 630,780 780,870 870,930
That could could be the
这可能是两个请求实际上都通过的情况，

2180
01:04:47,210 --> 01:04:48,500
0,270 270,390 390,660 660,930 930,1290
case that actually both requests

2181
01:04:48,500 --> 01:04:50,300
0,210 210,360 360,810 1170,1710 1710,1800
actually come through,| maybe the
|也许电视网喜欢临时请愿，

2182
01:04:50,300 --> 01:04:52,610
0,450 450,840 1110,1680 1680,2250 2250,2310
networks like temporary petition,| the
|服务器实际上收到了这两个请求

2183
01:04:52,610 --> 01:04:53,810
0,270 270,450 450,600 600,810 810,1200
server actually gets both request|
|

2184
01:04:53,810 --> 01:04:54,740
0,270 270,390 390,690 690,840 840,930
and the server has to
而服务器必须安排

2185
01:04:54,740 --> 01:04:57,590
0,390 390,690 810,1110 1140,2340 2490,2850
arrange that| it detects a
|它检测到重新发送请求，并且不执行两次。

2186
01:04:57,590 --> 01:04:59,090
0,390 390,780 780,900 900,1170 1170,1500
resend request and doesn't execute

2187
01:04:59,090 --> 01:05:00,100
0,90 90,600
it twice.|
|

2188
01:05:01,390 --> 01:05:03,660
0,240 240,300 300,690 780,1680
Now, of course ideally,
现在，当然，理想情况下，你实际上可能只想要一次。

2189
01:05:03,660 --> 01:05:04,830
0,120 120,300 300,540 540,690 690,1170
you might actually want exactly

2190
01:05:04,830 --> 01:05:06,000
0,450
once.|
|

2191
01:05:06,060 --> 01:05:07,170
0,330 330,600 600,870 870,1020 1020,1110
Because that's actually what the
因为这实际上是正常的程序，

2192
01:05:07,170 --> 01:05:09,000
0,480 480,930 930,1110 1110,1380 1440,1830
normal procedure would be,| like
|就像在正常的顺序程序中调用服务器中的过程一样

2193
01:05:09,000 --> 01:05:10,140
0,120 120,240 240,540 540,630 630,1140
if you call a procedure

2194
01:05:10,140 --> 01:05:11,520
0,150 150,450 450,660 660,1050 1050,1380
in {} your server in

2195
01:05:11,520 --> 01:05:13,320
0,60 60,360 360,750 750,1170 1170,1800
a normal sequential program| execution
|只执行一次死刑，

2196
01:05:13,350 --> 01:05:15,060
0,540 540,810 810,960 960,1230 1230,1710
exactly once,| it's never possible
|它永远不可能是至少一次或最多一次。

2197
01:05:15,060 --> 01:05:15,900
0,90 90,270 270,390 390,630 630,840
to be at least once

2198
01:05:15,900 --> 01:05:17,240
0,120 120,210 210,450 450,900
or at most once.|
|

2199
01:05:17,330 --> 01:05:18,110
0,300 300,510 510,600 600,660 660,780
This turns out to be
事实证明，这实际上很难安排。

2200
01:05:18,110 --> 01:05:19,400
0,180 180,420 420,660 660,720 720,1290
actually very hard to arrange.|
|

2201
01:05:20,220 --> 01:05:21,750
0,330 330,540 540,1110 1110,1170 1170,1530
{} This requires you know
这需要您知道，基本上必须维护状态和磁盘

2202
01:05:21,750 --> 01:05:23,160
0,540 570,810 810,1140 1140,1320 1320,1410
{} {} basically have to

2203
01:05:23,160 --> 01:05:25,350
0,390 390,660 660,780 780,1260 1590,2190
maintain state and disk {}|
|

2204
01:05:25,350 --> 01:05:27,540
0,330 600,900 900,1110 1110,1410 1410,2190
and tend to be expensive|
而且往往很贵|

2205
01:05:27,540 --> 01:05:28,860
0,240 240,300 300,600 600,870 870,1320
and in fact in practice
事实上，很少有RPC系统只有一次，

2206
01:05:28,860 --> 01:05:30,180
0,240 240,480 480,630 630,900 900,1320
very few {RPC -} systems

2207
01:05:30,180 --> 01:05:32,190
0,240 240,630 630,1050 1320,1860 1860,2010
are exactly once,| although in
|虽然在实验室中，你实际上要在实验室3建造一个，

2208
01:05:32,190 --> 01:05:32,910
0,90 90,420 420,540 540,660 660,720
the lab you're going to

2209
01:05:32,910 --> 01:05:34,080
0,240 240,510 510,810 810,930 930,1170
build actually one in lab

2210
01:05:34,080 --> 01:05:35,370
0,450 660,840 840,960 960,1020 1020,1290
3,| you're going to actually
|您将实际构建一个RPC系统，基本上只需一次。

2211
01:05:35,370 --> 01:05:36,630
0,240 240,300 300,690 690,1080 1080,1260
build an RPC system that's

2212
01:05:36,630 --> 01:05:38,340
0,480 480,930 930,1380
basically exactly once.|
|

2213
01:05:38,890 --> 01:05:40,100
0,720
Okay?|
好吧?|

2214
01:05:40,160 --> 01:05:43,340
0,480 570,780 780,1560 1740,2610 2610,3180
{} In practice Go's RPC
实际上，围棋的RPC系统最多一次，

2215
01:05:43,340 --> 01:05:45,710
0,900 900,1590 1590,1680 1680,1920 1920,2370
system is at most once,|
|

2216
01:05:45,740 --> 01:05:46,340
0,150 150,240 240,360 360,510 510,600
so if you do a
所以如果你打个电话

2217
01:05:46,340 --> 01:05:47,540
0,600 750,930 930,1020 1020,1110 1110,1200
call| and you do the
|然后你通过TCP通道进行呼叫，

2218
01:05:47,540 --> 01:05:49,040
0,270 270,570 570,630 630,1080 1080,1500
call across {} TCP channel,|
|

2219
01:05:49,040 --> 01:05:50,210
0,90 90,540 540,840 840,990 990,1170
the TCP channel will make
TCP通道将确保不存在重复项，

2220
01:05:50,210 --> 01:05:50,960
0,240 240,390 390,510 510,600 600,750
sure that there are no

2221
01:05:50,960 --> 01:05:53,660
0,660 1050,1590 1590,1860 1860,2130 2130,2700
duplicates,| {} and so and
|因此AND和RPC系统要么执行一次，要么根本不执行，

2222
01:05:53,660 --> 01:05:55,250
0,420 420,750 750,900 900,1170 1170,1590
{} and {RPC -} system

2223
01:05:55,250 --> 01:05:56,900
0,450 450,660 660,840 840,1200 1200,1650
{} will either execute once

2224
01:05:57,170 --> 01:05:58,640
0,510 510,750 750,840 840,1110 1140,1470
or none at all,| and
|然后在这种情况下返回一个错误。

2225
01:05:58,640 --> 01:05:59,870
0,180 180,270 270,330 330,690 690,1230
then in the case and

2226
01:05:59,870 --> 01:06:00,980
0,270 270,360 360,720
return an error.|
|

2227
01:06:01,580 --> 01:06:02,660
0,450 510,660 660,810 810,870 870,1080
{} And then of course
然后该应用程序当然可以重试，

2228
01:06:02,660 --> 01:06:04,130
0,60 60,450 450,600 600,1230 1260,1470
the application may retry,| but
|但您知道，处理重复和失败消息的问题是应用程序的责任。

2229
01:06:04,130 --> 01:06:05,690
0,150 150,270 270,360 360,810 810,1560
{you,know} it's the applications responsibility

2230
01:06:05,690 --> 01:06:07,160
0,450 480,990 990,1110 1110,1170 1170,1470
to deal with the problems

2231
01:06:07,160 --> 01:06:08,810
0,90 90,750 750,870 870,1110 1110,1650
of duplication and failed messages.|
|

2232
01:06:10,700 --> 01:06:11,990
0,240 240,360 360,810 810,990 990,1290
Okay, so here's the sort
好的，这就是关键点，对吧，

2233
01:06:11,990 --> 01:06:13,760
0,180 270,570 570,930 930,1290 1650,1770
of key point, correct,| the
|事实上，它们的失败基本上使您知道RPC与过程调用不同，

2234
01:06:13,760 --> 01:06:15,890
0,270 270,360 360,540 540,1260 1440,2130
fact that their failures basically

2235
01:06:15,890 --> 01:06:17,880
0,360 360,540 540,780 780,1500
makes {you,know} {RPCs -}

2236
01:06:18,860 --> 01:06:20,720
0,420 420,960 960,1050 1050,1440 1440,1860
not identical to procedure calls,|
|

2237
01:06:21,200 --> 01:06:22,190
0,150 150,300 300,420 420,630 630,990
so you know the goal
所以你知道我们的目标是让它们看起来尽可能地相似，实际上并不完全相同

2238
01:06:22,190 --> 01:06:22,940
0,90 90,210 210,420 420,570 570,750
is to make them look

2239
01:06:22,940 --> 01:06:24,560
0,120 120,480 480,600 600,1230 1260,1620
as similar as possible actually

2240
01:06:24,560 --> 01:06:26,510
0,300 300,810 840,1290 1290,1770 1770,1950
not identical| and really the
|而真正暴露出差异的是故障或服务器崩溃。

2241
01:06:26,510 --> 01:06:28,310
0,180 180,330 330,960 960,1110 1110,1800
thing that exposes the differences

2242
01:06:28,400 --> 01:06:31,220
0,360 360,1410 1470,2130 2460,2730 2730,2820
is {} failures or the

2243
01:06:31,220 --> 01:06:32,480
0,300 300,690
server crashing.|
|

2244
01:06:35,550 --> 01:06:37,590
0,600 780,1140 1410,1770 1770,1920 1920,2040
Any quick questions about this
关于RPC的这篇快速介绍，有什么问题吗？

2245
01:06:37,590 --> 01:06:39,270
0,240 240,690 690,1050 1050,1230 1230,1680
quick intro for {RPC -}?|
|

2246
01:06:47,190 --> 01:06:48,570
0,120 120,540 540,840 840,1140 1140,1380
Okay, if not, then I
好吧，如果不是，那我就不讲了，

2247
01:06:48,570 --> 01:06:49,320
0,120 120,180 180,420 420,480 480,750
want to stop the lecture

2248
01:06:49,320 --> 01:06:50,310
0,420 420,540 540,660 660,720 720,990
here,| so there are people
|所以有些人需要离开

2249
01:06:50,310 --> 01:06:51,180
0,210 210,390 390,480 480,750 750,870
that need to go| or
|或者学生需要上下一节课，

2250
01:06:51,180 --> 01:06:51,960
0,270 270,510 510,570 570,690 690,780
students need to go to

2251
01:06:51,960 --> 01:06:52,890
0,120 120,390 390,720 720,810 810,930
the next class,| you can
|你可以去下一节课，

2252
01:06:52,890 --> 01:06:53,760
0,120 120,180 180,240 240,450 450,870
go to the next class,|
|

2253
01:06:53,760 --> 01:06:54,960
0,150 150,330 330,600 600,960 960,1200
I'll be hanging around,| so
我会在附近转悠，|所以如果还有什么问题，我很乐意回答

2254
01:06:54,960 --> 01:06:56,190
0,90 90,300 300,480 480,720 720,1230
if there's any more questions,

2255
01:06:56,190 --> 01:06:57,450
0,120 120,300 300,660 660,1020 1020,1260
I'll be happy to {

2256
01:06:57,940 --> 01:06:59,000
0,480
-}

2257
01:06:59,060 --> 01:07:00,560
0,150 150,390 390,660 810,1260 1260,1500
to answer them| and stick
|在这里逗留一段时间。

2258
01:07:00,560 --> 01:07:01,460
0,240 240,330 330,360 360,540 540,900
around for a little while.|
|

2259
01:07:03,230 --> 01:07:04,550
0,60 60,150 150,720 720,1080 1080,1320
In the meantime, enjoy lab
同时，请享受实验1，并祝您好运。

2260
01:07:04,550 --> 01:07:05,600
0,390 420,570 570,690 690,900 900,1050
1 and good luck with

2261
01:07:05,600 --> 01:07:06,360
0,210
it.
