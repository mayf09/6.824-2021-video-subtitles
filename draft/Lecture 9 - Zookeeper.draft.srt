1
00:00:00,450 --> 00:00:02,340
0,540 540,840 1020,1200 1200,1740 1740,1890
Thank you,| okay, {} good
谢谢,|好的，下午好，早上好，晚上好，晚上好，无论你在哪里，

2
00:00:02,340 --> 00:00:04,200
0,690 720,900 900,1260 1260,1410 1410,1860
afternoon, good morning, good evening,

3
00:00:04,260 --> 00:00:05,400
0,150 150,420 420,660 660,750 750,1140
good night, wherever you are,|
|

4
00:00:06,180 --> 00:00:07,920
0,300 300,720 720,1080 1410,1680 1680,1740
so today I want to
所以今天我想谈一谈动物园管理员

5
00:00:07,920 --> 00:00:10,230
0,180 180,570 570,750 750,1410 1770,2310
talk about the zookeeper {}|
|

6
00:00:10,230 --> 00:00:12,690
0,300 300,660 660,780 780,1110 1560,2460
and {with,the} this {} background
有了这篇背景论文，

7
00:00:12,720 --> 00:00:14,340
0,390 390,510 510,1290 1320,1470 1470,1620
paper,| that we you know
|我们，你知道，今天的任务是什么

8
00:00:14,340 --> 00:00:15,300
0,180 180,270 270,480 480,570 570,960
which is assigned for today|
|

9
00:00:15,300 --> 00:00:17,340
0,210 210,330 330,720 720,1470
which is from 2010.|
这是2010年的照片。|

10
00:00:17,890 --> 00:00:21,070
0,510 870,1590 1890,2550 2730,3030 3030,3180
{} And, {} so there's
所以我们会回顾上几节课的内容，

11
00:00:21,070 --> 00:00:22,750
0,150 150,750 750,990 990,1140 1140,1680
gonna be {referring -} back

12
00:00:22,780 --> 00:00:23,770
0,150 150,360 360,540 540,930 930,990
the last couple lectures,| I
|我想我们在木筏上做了相当多的细节

13
00:00:23,770 --> 00:00:24,940
0,210 210,630 630,900 900,1110 1110,1170
think {we,dove} in quite a

14
00:00:24,940 --> 00:00:26,170
0,120 120,180 180,600 600,780 780,1230
bit of detail into raft|
|

15
00:00:26,170 --> 00:00:29,530
0,750 1080,1590 1590,1890 2040,2550 2820,3360
including looking at code, {}|
包括查看代码，|

16
00:00:29,560 --> 00:00:30,700
0,150 150,480 480,630 630,870 870,1140
the lectures from now on
从现在开始的讲座将更加概念化

17
00:00:30,700 --> 00:00:31,210
0,90 90,210 210,270 270,420 420,510
are going to be {}

18
00:00:31,210 --> 00:00:35,650
0,660 690,1320 1590,2970 3000,3690 3690,4440
more conceptual| and exploring ideas
|并在分布式系统动物园管理员的想法中探索，

19
00:00:35,650 --> 00:00:38,170
0,540 780,1140 1140,1830 1830,1980 1980,2520
in distributed systems {zookeeper's -},|
|

20
00:00:38,740 --> 00:00:39,880
0,540 540,750 750,810 810,930 930,1140
{} and the {zookeeper -},
而动物园管理员，一个与我们特别相关的人，

21
00:00:39,880 --> 00:00:42,310
0,300 300,600 600,1230 1260,1860 1860,2430
one is {} particularly relevant

22
00:00:42,460 --> 00:00:45,100
0,210 210,540 840,2250 2250,2370 2370,2640
to us,| because it has
|因为它有一点关系

23
00:00:45,100 --> 00:00:45,700
0,90 90,300 300,420 420,510 510,600
a little bit of {}

24
00:00:45,700 --> 00:00:47,200
0,660 660,840 840,960 960,1290 1290,1500
relationship| as we'll see with
|正如我们将在实验3中看到的那样。

25
00:00:47,200 --> 00:00:48,540
0,270 270,720
lab 3.|
|

26
00:00:48,970 --> 00:00:50,020
0,210 210,420 420,540 540,720 720,1050
And so it will allow
因此，它将允许我们讨论实验3的一些属性

27
00:00:50,020 --> 00:00:51,160
0,120 120,210 210,390 390,960 960,1140
us to talk about some

28
00:00:51,160 --> 00:00:53,410
0,480 480,570 570,1260 1260,1350 1350,2250
properties of {lab,3}| and particularly
|尤其是可靠性，

29
00:00:53,410 --> 00:00:56,830
0,720 1350,2130 2130,2310 2310,2430 2430,3420
reliability,| but {zookeeper -} system
|但更重要的是动物园管理员系统，

30
00:00:56,830 --> 00:00:58,510
0,150 150,750 750,1170 1170,1440 1440,1680
more importantly,| it's interesting because
|这很有趣，因为其中一个系统在实践中得到了广泛的应用。

31
00:00:58,510 --> 00:00:59,440
0,180 210,480 480,630 630,660 660,930
one of {widely - -}

32
00:00:59,440 --> 00:01:07,160
0,300 300,810 4740,5910
used system {in,practice}.|
|

33
00:01:07,700 --> 00:01:10,760
0,240 240,870 870,1440 1470,2340 2340,3060
{} Well beyond {} Apache,
除了阿帕奇，雅虎之外还有一个开源的阿帕奇项目，

34
00:01:10,790 --> 00:01:12,650
0,360 360,570 570,900 900,1560 1560,1860
{} well beyond Yahoo is

35
00:01:12,650 --> 00:01:15,200
0,480 540,930 930,1230 1230,1920 1950,2550
a open source Apache project,|
|

36
00:01:15,200 --> 00:01:17,600
0,870 870,960 960,1440 1440,1920
that is still active.|
这仍然是活跃的。|

37
00:01:17,910 --> 00:01:20,370
0,540 990,1740 1740,2070 2070,2340 2340,2460
{} {What,particularly} interesting about it
对我们来说特别有趣的是，

38
00:01:20,370 --> 00:01:22,710
0,810 810,1290 1500,1620 1620,2190 2190,2340
for us,| in the lecture
|在今天这样的演讲中其实是高性能的

39
00:01:22,710 --> 00:01:23,670
0,90 90,360 360,480 480,780 780,960
like today is actually high

40
00:01:23,670 --> 00:01:26,280
0,810 1440,1860 1860,2070 2070,2550 2550,2610
performance| and high performance, I
|高性能，我的意思是比实验室3实际要高得多的性能。

41
00:01:26,280 --> 00:01:28,350
0,420 540,750 750,1020 1020,1590 1590,2070
mean much higher performance than

42
00:01:28,560 --> 00:01:31,230
0,810 1080,1620 1620,2190 2190,2520 2520,2670
{} what actually lab 3

43
00:01:31,230 --> 00:01:32,540
0,90 90,270 270,540
is gonna be.|
|

44
00:01:32,840 --> 00:01:34,610
0,390 390,540 540,690 690,1260 1290,1770
{} I'll talk to talk
关于这一点，我会详细地谈一谈

45
00:01:34,610 --> 00:01:35,480
0,240 240,270 270,420 420,570 570,870
quite a bit of detail

46
00:01:35,480 --> 00:01:36,950
0,240 240,540 900,1230 1230,1350 1350,1470
about this| and there's sort
|它之所以是高性能，有两个原因：第一，

47
00:01:36,950 --> 00:01:38,300
0,90 90,300 300,840 840,1170 1170,1350
of two reasons why it

48
00:01:38,300 --> 00:01:40,130
0,180 180,600 600,960 960,1440 1560,1830
is high performance one,| it
|它是客户端操作是异步的，

49
00:01:40,130 --> 00:01:42,020
0,540 630,810 810,1140 1140,1650 1650,1890
is the client operations are

50
00:01:42,020 --> 00:01:43,340
0,720
asynchronous,|
|

51
00:01:47,180 --> 00:01:48,080
0,270 270,450 450,660 660,780 780,900
{} and really what high
在这里，高性能的形式真正意味着

52
00:01:48,080 --> 00:01:49,610
0,360 360,690 690,900 900,1230 1230,1530
performing forms here means is|
|

53
00:01:49,610 --> 00:01:51,830
0,420 420,720 720,1110 1500,1950 1950,2220
we can, {} {the,system,can,process} many
我们可以，系统每秒可以处理更多的操作，

54
00:01:51,830 --> 00:01:54,170
0,720 750,1710 1710,1830 1830,2190 2190,2340
more operations per second,| so
|所以它实际上是一个吞吐量指标

55
00:01:54,170 --> 00:01:55,940
0,120 120,330 330,420 420,960 990,1770
it's really a throughput metric|
|

56
00:01:56,480 --> 00:01:57,920
0,450 450,600 600,660 660,930 930,1440
{} and the second reason
第二个原因是高性能，因为，

57
00:01:57,920 --> 00:01:59,990
0,210 210,420 420,1050 1050,1440 1590,2070
it's high performances because, {}|
|

58
00:01:59,990 --> 00:02:01,790
0,480 480,840 870,1170 1170,1530 1530,1800
it {} doesn't provide strong
它没有提供很强的一致性，

59
00:02:01,790 --> 00:02:04,370
0,720 750,1290 1290,1770 1770,2160 2160,2580
consistency,| {} {so,it} doesn't, {
|所以它没有，它有一个本能的一致性定义

60
00:02:04,730 --> 00:02:07,640
0,540 540,1560 1560,1800 1800,2070 2070,2910
-} it has an instinct

61
00:02:07,640 --> 00:02:09,320
0,240 240,1200
{} consistency

62
00:02:10,060 --> 00:02:12,130
0,840 1440,1710 1710,1800 1800,1980 1980,2070
definition| and it gives us
|它让我们可以自由地在任何复制品上执行基本的读取操作

63
00:02:12,130 --> 00:02:13,990
0,180 180,720 750,1110 1110,1440 1440,1860
some freedom {} to execute

64
00:02:13,990 --> 00:02:15,640
0,390 390,600 600,1260 1260,1410 1410,1650
basically read operations on any

65
00:02:15,640 --> 00:02:17,650
0,600 780,990 990,1380 1380,1530 1530,2010
replica| and therefore {reconforms -}
|因此重构体是可以扩展的。

66
00:02:17,650 --> 00:02:18,780
0,120 120,600
can scale.|
|

67
00:02:19,700 --> 00:02:21,350
0,330 330,390 390,690 690,1290 1320,1650
Then, the second aspect that
那么，动物园管理员有趣的第二个方面是

68
00:02:21,350 --> 00:02:22,820
0,90 90,510 510,690 690,1020 1020,1470
is interesting from {zookeeper -}

69
00:02:22,820 --> 00:02:23,810
0,210 210,450 450,720 720,810 810,990
is| in addition to being
|除了高性能之外，

70
00:02:23,810 --> 00:02:25,580
0,120 120,870 1080,1380 1380,1620 1620,1770
high performance,| {} {it,is} sort
|这是一种通用的，他们称之为协调服务器的东西。

71
00:02:25,580 --> 00:02:26,750
0,60 60,180 180,810 810,1050 1050,1170
of a generic, what they

72
00:02:26,750 --> 00:02:29,260
0,270 270,870 870,1560
call coordination servers.|
|

73
00:02:35,260 --> 00:02:37,150
0,510 510,990 990,1260 1260,1500 1500,1890
And the point being here
这里的重点是有很多应用程序，

74
00:02:37,150 --> 00:02:39,220
0,180 180,840 840,870 870,1110 1110,2070
is there are many applications,|
|

75
00:02:39,550 --> 00:02:42,070
0,990 1020,1740 1740,1980 1980,2220 2220,2520
{} where you need to
您需要跟踪哪些人是这个集群的一部分

76
00:02:42,100 --> 00:02:43,510
0,240 240,660 660,900 900,1020 1020,1410
keep track of like who's

77
00:02:43,510 --> 00:02:45,190
0,420 420,570 570,780 780,1410 1410,1680
part of this cluster| and
|谁是主宰，

78
00:02:45,190 --> 00:02:47,230
0,360 360,450 450,1020 1560,1860 1860,2040
who's the master,| so think
|所以想一想MapReduce或GFS，

79
00:02:47,230 --> 00:02:49,660
0,270 270,900 930,1170 1170,1830 1830,2430
about the {mapreduce -} or

80
00:02:49,660 --> 00:02:51,160
0,210 210,480 480,690 690,1260 1260,1500
think about the GFS,| the
|GFS中的主控需要跟踪或喜欢每个块，

81
00:02:51,160 --> 00:02:53,020
0,480 480,1140 1200,1560 1560,1650 1650,1860
{master,in} GFS needs to keep

82
00:02:53,020 --> 00:02:54,160
0,390 390,510 510,660 660,840 840,1140
track or like for every

83
00:02:54,160 --> 00:02:56,200
0,510 660,1110 1110,1290 1290,1620 1620,2040
chunk,| who are the servers
|谁是实际为该[]服务器块提供服务的服务器？服务器实际上是主服务器

84
00:02:56,200 --> 00:02:57,220
0,120 120,330 330,570 570,750 750,1020
that actually server that []

85
00:02:57,220 --> 00:02:59,170
0,360 360,600 600,1140 1140,1530 1530,1950
server chunk whom servers actually

86
00:02:59,170 --> 00:03:01,570
0,210 210,450 450,960 1650,2130 2130,2400
is the master| and so
|因此跟踪这类配置信息，

87
00:03:01,570 --> 00:03:03,010
0,420 420,630 630,780 780,840 840,1440
tracking that sort of configuration

88
00:03:03,010 --> 00:03:04,390
0,750 750,840 840,960 960,1200 1200,1380
information,| you know comes up
|你知道，在许多不同的分布式应用程序中，

89
00:03:04,390 --> 00:03:05,680
0,60 60,420 420,480 480,870 870,1290
in lots of different distributed

90
00:03:05,680 --> 00:03:08,260
0,810 1050,1560 1560,1680 1680,1920 1920,2580
applications,| zookeeper is really designed
|动物园看守人真的是为了支持这种东西而设计的，

91
00:03:08,680 --> 00:03:09,790
0,180 180,660 660,810 810,1020 1020,1110
to support that kind of

92
00:03:09,790 --> 00:03:10,630
0,180 180,300 300,540 540,750 750,840
thing,| so you sort of
|所以你可以把所有的配置管理外包给ZooKeeper，

93
00:03:10,630 --> 00:03:12,670
0,660 660,810 810,900 900,1500 1500,2040
outsource all the configuration management

94
00:03:12,670 --> 00:03:15,370
0,330 390,1080 1080,1590 1890,2400 2400,2700
to {zookeeper -},| {} and
|然后将应用程序开发的其余部分集中在分布式系统的其他方面。

95
00:03:15,370 --> 00:03:17,860
0,480 480,870 870,1440 1920,2430 2430,2490
then focus the rest of

96
00:03:17,860 --> 00:03:19,330
0,150 150,540 540,1050 1050,1200 1200,1470
your application development on other

97
00:03:19,330 --> 00:03:21,880
0,630 660,1440 1470,1740 1740,2190 2190,2550
aspects of your distributed system.|
|

98
00:03:22,860 --> 00:03:23,760
0,300 300,450 450,630 630,780 780,900
Okay, so that's sort of
好的，这是一个简短的介绍，

99
00:03:23,760 --> 00:03:26,160
0,390 690,1050 1050,1710 1710,1800 1800,2400
a brief introduction,| you know
|你知道我们要讨论的话题。

100
00:03:26,160 --> 00:03:27,240
0,210 360,780 780,870 870,930 930,1080
the topics that we're gonna

101
00:03:27,240 --> 00:03:28,600
0,120 120,450 450,840
be talking about.|
|

102
00:03:30,350 --> 00:03:31,280
0,180 180,270 270,390 390,630 630,930
And as {} {usual -},
像往常一样，你可以随时打断我

103
00:03:31,280 --> 00:03:32,300
0,150 150,360 360,540 540,660 660,1020
{} feel free to interrupt

104
00:03:32,300 --> 00:03:34,820
0,60 60,240 240,660 1170,1920 1920,2520
at any time| {} or
|或者你知道在聊天消息中发布一些东西，

105
00:03:34,820 --> 00:03:36,260
0,360 390,690 690,990 990,1170 1170,1440
{you,know} post something in the

106
00:03:36,290 --> 00:03:37,970
0,240 240,840 900,1230 1230,1290 1290,1680
chat message,| let me actually
|让我来调出聊天的内容。

107
00:03:37,970 --> 00:03:39,440
0,270 270,360 360,480 480,960
pull up the chat.|
|

108
00:03:40,670 --> 00:03:43,190
0,540 1500,1740 1740,2010 2010,2250 2250,2520
Okay, {} so we just
好的，我们只是从基本的动物园守护者复制状态机开始。

109
00:03:43,190 --> 00:03:45,140
0,330 330,480 480,630 1380,1860 1860,1950
to get {} start from

110
00:03:45,140 --> 00:03:47,540
0,60 60,630 630,1020 1020,1950 1980,2400
the basics {zookeeper -} is

111
00:03:47,540 --> 00:03:49,420
0,450 450,900
replicated {state,machine}.|
|

112
00:03:55,470 --> 00:03:56,940
0,630

113
00:03:58,730 --> 00:03:59,810
0,150 150,210 210,510 510,900 900,1080
In the same way that
就像我们所看到的复制状态机一样

114
00:03:59,810 --> 00:04:01,100
0,90 90,540 660,810 810,960 960,1290
you know {} the replicated

115
00:04:01,100 --> 00:04:02,450
0,480 480,600 600,750 750,840 840,1350
{state,machines} that we've been seeing|
|

116
00:04:02,750 --> 00:04:04,850
0,660 660,840 840,1380 1440,1830 1830,2100
{} and so let's draw
因此，让我们来画一幅通常的图画，

117
00:04:04,850 --> 00:04:06,620
0,90 90,420 420,1050 1260,1620 1620,1770
the usual picture,| um, we
|嗯，我们有一些服务器，

118
00:04:06,620 --> 00:04:08,030
0,120 120,270 270,960 1080,1260 1260,1410
have some servers,| {} in
|在这种情况下，它将是动物园管理员ZK。

119
00:04:08,030 --> 00:04:08,990
0,180 180,450 450,540 540,720 720,960
this case, it's gonna be

120
00:04:08,990 --> 00:04:10,790
0,30 30,240 240,810 990,1290 1290,1800
{} {zookeeper -} {ZK -}.|
|

121
00:04:11,670 --> 00:04:14,370
0,480 720,1320 1320,2160 2160,2550 2550,2700
{} It receives requests from
它接收来自客户端的请求，

122
00:04:14,370 --> 00:04:17,790
0,480 480,630 630,1290 2100,2880 2880,3420
clients,| that create {create,z} node
|其创建方式基本上是以交互方式创建z节点以分布这些操作，

123
00:04:17,850 --> 00:04:20,640
0,750 750,1260 1260,1380 1380,2010 2010,2790
{} {in,basically} the way {}

124
00:04:20,670 --> 00:04:24,840
0,120 120,870 870,2640 3120,3510 3510,4170
it interacts {} to distribute

125
00:04:24,840 --> 00:04:26,160
0,150 150,750 750,900 900,1170 1170,1320
these operations,| it has sort
|它有一种独立的图书馆，

126
00:04:26,160 --> 00:04:27,570
0,90 90,360 360,750 750,1320 1320,1410
of a separate library,| you
|你知道，把这个想象成他们案例中的木筏图书馆，它被称为Zab。

127
00:04:27,570 --> 00:04:28,560
0,180 180,360 360,630 630,810 810,990
know, think about this as

128
00:04:28,560 --> 00:04:30,720
0,270 330,960 960,1470 1920,1980 1980,2160
the raft library in their

129
00:04:30,720 --> 00:04:32,820
0,450 540,870 870,1110 1110,1650
case, it's called ZAB.|
|

130
00:04:34,620 --> 00:04:36,480
0,540 540,630 630,870 870,1260 1290,1860
Basically, you know the leader
基本上，你知道，你认识的领导人把操作放在你知道的相当于RAFT库的地方

131
00:04:36,480 --> 00:04:39,960
0,210 210,570 570,900 2040,2910 2910,3480
{you,know} sticks the operation into

132
00:04:39,960 --> 00:04:41,700
0,930 960,1050 1050,1170 1170,1260 1260,1740
{} you know the equivalent

133
00:04:41,700 --> 00:04:43,740
0,330 330,780 780,1170 1170,1410 1410,2040
raft library| that {you,know} talks
|你知道的与其他图书馆或其他同行的谈话，

134
00:04:43,800 --> 00:04:45,840
0,150 150,270 270,720 1410,1680 1680,2040
you know to you know

135
00:04:46,140 --> 00:04:49,020
0,630 660,1470 1620,1920 1920,2220 2220,2880
other libraries or other peers,|
|

136
00:04:49,440 --> 00:04:51,870
0,450 450,1200 1200,1560 1560,2070 2070,2430
{} that basically creates a
这基本上创建了一个日志，

137
00:04:51,870 --> 00:04:53,760
0,630 960,1080 1080,1260 1260,1470 1470,1890
log,| you know that conveys
|你知道，通过所有这些操作和这些机器

138
00:04:53,760 --> 00:04:55,080
0,150 150,270 270,420 420,1170 1170,1320
with all these operations and

139
00:04:55,080 --> 00:04:57,090
0,150 150,330 330,930 1740,1890 1890,2010
all these machines| and then
|然后操作是对[]的反馈日志，

140
00:04:57,090 --> 00:04:58,350
0,120 120,570 570,840 840,960 960,1260
the operations are the log

141
00:04:58,350 --> 00:05:00,570
0,90 90,780 990,1230 1230,1710 1740,2220
of feedback to the [],|
|

142
00:05:00,570 --> 00:05:01,800
0,240 240,600 600,690 690,990 990,1230
so in our case, we
因此，在我们的示例中，我们将通道应用到服务器，

143
00:05:01,800 --> 00:05:04,320
0,300 300,840 930,1530 1530,1860 1860,2520
apply channel {} to the

144
00:05:04,350 --> 00:05:05,850
0,720 720,810 810,1110 1110,1440 1440,1500
servers,| the servers applies the
|服务器应用该操作以响应客户端

145
00:05:05,850 --> 00:05:06,840
0,420 420,480 480,840 840,900 900,990
operation in response to the

146
00:05:06,840 --> 00:05:07,860
0,420 450,660 660,810 810,930 930,1020
client| and so we have
|因此，我们基本上已经在进行[分流]。

147
00:05:07,860 --> 00:05:09,040
0,540
basically

148
00:05:09,070 --> 00:05:10,880
0,630 630,780 780,1230
[diversion] is running.|
|

149
00:05:11,090 --> 00:05:13,160
0,540 780,1170 1170,1500 1500,1950 1980,2070
And, {} so far, you
到目前为止，你知道，在你知道的实验室里，你主要专注于

150
00:05:13,160 --> 00:05:15,140
0,300 300,900 1050,1260 1260,1470 1470,1980
know in {} the labs

151
00:05:15,140 --> 00:05:16,670
0,120 120,240 240,450 450,990 990,1530
you know really focusing mostly|
|

152
00:05:16,670 --> 00:05:17,540
0,90 90,330 330,600 600,780 780,870
you know lab 2 is
你知道，实验2就是关于这一部分的，

153
00:05:17,540 --> 00:05:18,530
0,150 150,570 570,660 660,750 750,990
all about you know this

154
00:05:18,530 --> 00:05:19,960
0,510
part,|
|

155
00:05:21,000 --> 00:05:23,580
0,870 870,1200 1200,1590 1590,2160 2190,2580
implementing {in,our,case -} raft,| so
在我们的案例中实施浮筏，|所以不是扎布

156
00:05:23,580 --> 00:05:25,110
0,360 360,450 450,810 1110,1440 1440,1530
instead of ZAB| and for
|而对于第一个处于非常高水平的订单，

157
00:05:25,110 --> 00:05:26,700
0,90 90,420 420,1380 1380,1530 1530,1590
the first order at a

158
00:05:26,700 --> 00:05:28,080
0,270 270,420 420,1110 1110,1260 1260,1380
very high level,| you can
|你可以把扎布想象成另一个木筏，

159
00:05:28,080 --> 00:05:30,990
0,150 150,690 900,1500 1500,2100 2100,2910
think about ZAB being another

160
00:05:31,080 --> 00:05:32,700
0,870 870,930 930,1080 1080,1440 1440,1620
raft,| you know providing sort
|你知道，提供类似的担保，你知道，实施方式截然不同，

161
00:05:32,700 --> 00:05:35,550
0,60 60,810 930,1800 1800,2310 2310,2850
of similar guarantees {you,know} implemented

162
00:05:35,550 --> 00:05:37,950
0,300 300,900 1200,1980 1980,2280 2280,2400
quite differently,| {} you know
|你知道，它提供了所有操作的顺序，尽管出现了故障、网络假期等，

163
00:05:37,950 --> 00:05:40,020
0,120 120,870 1020,1440 1440,1590 1590,2070
it provides {} an order

164
00:05:40,020 --> 00:05:42,480
0,90 90,240 240,360 360,1380 1440,2460
of all the operations despite

165
00:05:42,510 --> 00:05:45,150
0,750 750,1080 1080,1770 1770,2100 2100,2640
failures network vacations, etc etc,|
|

166
00:05:45,180 --> 00:05:46,830
0,270 270,570 570,720 720,1020 1020,1650
doesn't suffer from split brain,|
不会有大脑分裂的问题，|

167
00:05:46,830 --> 00:05:47,970
0,450 450,750 750,870 870,1050 1050,1140
brain all are sort of
大脑都是我们与木筏图书馆联系在一起的东西。

168
00:05:47,970 --> 00:05:49,440
0,270 270,510 510,630 630,1260 1260,1470
things which we associate with

169
00:05:49,440 --> 00:05:51,420
0,360 630,1230 1230,1680
the raft library.|
|

170
00:05:51,900 --> 00:05:54,300
0,570 1050,1680 1860,2010 2010,2070 2070,2400
{} In you know what
你知道我们在第三圈要关注的是

171
00:05:54,300 --> 00:05:55,620
0,120 120,270 270,360 360,810 810,1320
we're gonna be focusing in

172
00:05:55,620 --> 00:05:57,210
0,300 300,540 540,930 930,1350 1350,1590
lap 3 on is| actually
|实际上在上面实现了一项服务，

173
00:05:57,210 --> 00:05:58,440
0,390 390,450 450,870 870,960 960,1230
implementing a service on top

174
00:05:58,440 --> 00:06:00,090
0,90 90,210 450,900 1140,1440 1440,1650
of it,| so, {} this
|所以，本文讨论的是动物园饲养员的不协调，

175
00:06:00,090 --> 00:06:01,890
0,240 240,450 450,900 900,1560 1560,1800
paper talks about the {discoordination

176
00:06:01,890 --> 00:06:03,960
0,420 420,780 780,1260 1260,1860 1890,2070
-} {zookeeper -} in,| we're
|我们将在实验3中实际实施密钥价值存储。

177
00:06:03,960 --> 00:06:04,980
0,120 120,210 210,510 510,930 930,1020
going to actually implement in

178
00:06:04,980 --> 00:06:06,880
0,210 210,660 660,990 990,1500
{lab,3} key value stores.|
|

179
00:06:12,400 --> 00:06:13,390
0,90 90,150 150,360 360,840 840,990
In the data structure is
在数据结构中只是从键映射到值

180
00:06:13,390 --> 00:06:14,980
0,180 180,240 240,870 870,1020 1020,1590
just {} map from keys

181
00:06:14,980 --> 00:06:17,350
0,90 90,780 1710,2100 2100,2250 2250,2370
to values| and so the
|因此，我们将在那里支持的业务已经投入使用。

182
00:06:17,350 --> 00:06:18,550
0,600 600,840 840,990 990,1080 1080,1200
operations there that we're going

183
00:06:18,550 --> 00:06:19,990
0,90 90,150 150,630 630,1110 1140,1440
to be supporting are put

184
00:06:19,990 --> 00:06:21,100
0,120 120,540
and get.|
|

185
00:06:22,650 --> 00:06:23,760
0,150 150,210 210,630 630,810 810,1110
So the clients may put
所以客户可能会把GET操作，

186
00:06:23,760 --> 00:06:25,080
0,180 180,900 900,990 990,1110 1110,1320
get operations,| you know to
|你知道，对服务器来说，

187
00:06:25,080 --> 00:06:27,150
0,720 720,1320 1320,1440 1440,1770 1770,2070
the servers,| the servers runs
|服务器通过RAFT运行

188
00:06:27,150 --> 00:06:29,310
0,120 120,420 420,510 510,1140 1440,2160
in through {} raft| and
|然后将它们逐个应用到键值存储。

189
00:06:29,310 --> 00:06:30,300
0,180 180,570 570,660 660,840 840,990
then applies them one by

190
00:06:30,300 --> 00:06:31,590
0,360 360,540 540,780 780,930 930,1290
one to the key value

191
00:06:31,590 --> 00:06:32,480
0,360
store.|
|

192
00:06:32,810 --> 00:06:34,700
0,420 720,1230 1230,1410 1410,1740 1740,1890
{} In {zookeeper -} {you,know}
在动物园看守人，你知道结构略有不同，

193
00:06:34,700 --> 00:06:36,440
0,90 90,480 480,750 750,1230 1230,1740
the structures slightly different,| there's
|有一个由z个节点组成的树，

194
00:06:36,440 --> 00:06:37,730
0,60 60,390 390,480 480,690 690,1290
a tree of z nodes,|
|

195
00:06:38,180 --> 00:06:39,560
0,420 420,480 480,720 720,1200 1200,1380
but the basic operation is
但基本的操作是应用相同的，

196
00:06:39,560 --> 00:06:40,760
0,210 210,570 570,630 630,1140 1140,1200
the applys the same,| you
|你知道的。下层Zab

197
00:06:40,760 --> 00:06:42,300
0,540 540,990
know the.

198
00:06:42,390 --> 00:06:43,860
0,420 420,720 720,870 870,1350 1350,1470
lower layer the ZAB| or
|或者ZAB库或ZAB库以相同的顺序对它们应用的所有操作进行排序所有副本，

199
00:06:43,860 --> 00:06:45,900
0,630 750,1170 1170,1590 1590,1680 1680,2040
the ZAB library or ZAB

200
00:06:45,900 --> 00:06:47,370
0,330 330,630 630,750 750,840 840,1470
library orders all the operations

201
00:06:47,370 --> 00:06:48,510
0,180 180,630 630,720 720,780 780,1140
they're applied in the same

202
00:06:48,510 --> 00:06:50,430
0,390 390,600 600,1230 1410,1800 1800,1920
order all replicas,| because they
|因为它们都以相同的顺序应用，

203
00:06:50,430 --> 00:06:51,180
0,30 30,390 390,570 570,660 660,750
are applied all in the

204
00:06:51,180 --> 00:06:52,680
0,330 330,780 780,1050 1050,1200 1200,1500
same order,| there's no {non-determinism
|没有非决定论，

205
00:06:52,680 --> 00:06:55,500
0,840 1140,1500 1500,1770 1770,2250 2250,2820
-},| {} the resulting state
|每个复制副本上的结果状态将是相同的。

206
00:06:55,500 --> 00:06:56,460
0,210 210,360 360,450 450,540 540,960
on each of the replica

207
00:06:56,460 --> 00:06:57,360
0,90 90,210 210,270 270,390 390,900
is going to be identical.|
|

208
00:07:00,480 --> 00:07:02,520
0,600 1500,1740 1740,1860 1860,1950 1950,2040
Okay?| That's sort of the
好吧?|这是这篇论文的基本背景

209
00:07:02,520 --> 00:07:05,820
0,810 840,1470 1860,2730 2850,3150 3150,3300
basic {} setting of this

210
00:07:05,820 --> 00:07:07,530
0,660 780,1110 1110,1260 1260,1320 1320,1710
paper| and sort of also
|在某种程度上也是实验室3和动物园管理员服务本身之间关系的一部分。

211
00:07:07,530 --> 00:07:08,670
0,210 210,780 780,990 990,1050 1050,1140
the relation part of the

212
00:07:08,670 --> 00:07:12,120
0,570 570,1200 1410,2400 2400,3090 3090,3450
relationship between {} {lab,3} and

213
00:07:12,120 --> 00:07:13,620
0,270 270,420 420,660 660,990 990,1500
the {zookeeper -} service itself.|
|

214
00:07:14,280 --> 00:07:15,120
0,180 180,570 570,690 690,750 750,840
And mostly going to be
在这堂课中，主要讨论的是关注动物园饲养员本身

215
00:07:15,120 --> 00:07:16,860
0,420 420,750 750,900 900,1200 1200,1740
talking in this lecture on

216
00:07:16,860 --> 00:07:17,670
0,240 240,360 360,420 420,570 570,810
focus on the {zookeeper -}

217
00:07:17,670 --> 00:07:18,900
0,240 240,690 690,780 780,960 960,1230
part itself| and not talk
|也不要谈论扎布，

218
00:07:18,900 --> 00:07:21,120
0,390 390,600 600,1020 1380,2130 2130,2220
about {ZAB -},| because you're
|因为你会认为这和我们在实验室2做的事情很相似。

219
00:07:21,120 --> 00:07:22,920
0,120 120,660 660,1230 1230,1560 1560,1800
gonna assume that's similar to

220
00:07:22,920 --> 00:07:24,930
0,480 480,600 600,900 1290,1800 1800,2010
what we're doing and we're

221
00:07:24,930 --> 00:07:26,180
0,210 210,270 270,510 510,690
doing in lab 2.|
|

222
00:07:28,370 --> 00:07:30,680
0,510 720,1350 1680,2070 2070,2100 2100,2310
Okay, {} talking a little
好的，稍微谈一谈，

223
00:07:30,680 --> 00:07:32,420
0,150 150,660 810,1110 1110,1620 1620,1740
bit about,| {} what kind
|你会观察到什么样的表演，

224
00:07:32,420 --> 00:07:34,730
0,60 60,750 750,1290 1290,1470 1470,2310
of performance would you observe,|
|

225
00:07:34,820 --> 00:07:35,960
0,420 420,630 630,840 840,1050 1050,1140
{} if you want to
如果你想完成实验3。

226
00:07:35,960 --> 00:07:37,620
0,330 330,600 600,1080
finish lab 3.|
|

227
00:07:37,650 --> 00:07:40,200
0,870 960,1320 1320,1590 1590,2190 2220,2550
And, {} would measure how
并且，可以衡量你每秒进行或完成手术的次数，

228
00:07:40,200 --> 00:07:41,760
0,180 180,450 450,720 720,930 930,1560
many {you,puts,or} gets your operation

229
00:07:41,760 --> 00:07:43,260
0,180 180,390 390,540 540,930 1020,1500
get through per second,| because
|因为其中一个成果，这篇论文就是你所知道的高性能。

230
00:07:43,260 --> 00:07:45,570
0,270 270,360 360,660 990,2130 2130,2310
one of the achievements, this

231
00:07:45,570 --> 00:07:47,370
0,450 450,660 660,840 840,1020 1020,1800
paper is {you,know} high performance.|
|

232
00:07:47,760 --> 00:07:48,540
0,270 270,390 390,540 540,540 540,780
So let's think a little
所以让我们稍微想一想，

233
00:07:48,540 --> 00:07:50,040
0,150 150,360 360,720 1110,1350 1350,1500
bit about that,| {} so
|那么让我们假设有一个行动即将到来。

234
00:07:50,040 --> 00:07:51,690
0,150 150,660 660,1050 1050,1200 1200,1650
let's assume there's a operation

235
00:07:51,690 --> 00:07:52,960
0,210 210,600
coming in.|
|

236
00:07:54,360 --> 00:07:55,920
0,510 510,630 630,900 900,1350 1350,1560
And {you,know} put information comes
你知道，PUT信息是由领导者输入的

237
00:07:55,920 --> 00:07:56,610
0,60 60,180 180,270 270,570 570,690
in by the leader| and
|所以我们只会选择正常的情况

238
00:07:56,610 --> 00:07:57,390
0,120 120,240 240,420 420,570 570,780
so we're just gonna go

239
00:07:57,390 --> 00:07:58,470
0,120 120,210 210,570 570,930 930,1080
for the normal case| like
|就像标准的情况一样，一切都正常，没有网络故障，没有请愿，没有任何事情，一切都完美地解决了。

240
00:07:58,470 --> 00:07:59,490
0,90 90,420 420,630 630,750 750,1020
the standard case where everything

241
00:07:59,490 --> 00:08:00,930
0,60 60,570 570,750 750,1110 1110,1440
is working, no network failures,

242
00:08:00,930 --> 00:08:02,400
0,150 150,570 570,840 870,1230 1230,1470
no petitions, nothing everything works

243
00:08:02,400 --> 00:08:04,620
0,120 120,720 1170,1500 1500,1590 1590,2220
out perfectly.| Here's the leader,|
|这是领队，|

244
00:08:04,710 --> 00:08:06,480
0,330 330,450 450,570 570,1290
we've got two followers.|
我们有两个追随者。|

245
00:08:09,390 --> 00:08:11,100
0,450 450,510 510,960 1230,1590 1590,1710
And you know, now you
你知道，现在你知道你可能从里面翻出来的那个粒子

246
00:08:11,100 --> 00:08:12,480
0,120 120,300 300,840 840,1020 1020,1380
know that particle you probably

247
00:08:12,480 --> 00:08:13,920
0,450 450,840 1110,1260 1260,1350 1350,1440
inside out| you know the
|你知道，第一件事当然就是你会成为领头羊，

248
00:08:13,920 --> 00:08:14,640
0,240 240,360 360,420 420,630 630,720
first thing of course it

249
00:08:14,640 --> 00:08:15,750
0,420 420,600 600,690 690,840 840,1110
happens like you would be

250
00:08:15,780 --> 00:08:17,840
0,360 360,510 510,900 900,1560
{the,leader} {} call start,|
|

251
00:08:17,840 --> 00:08:19,010
0,330 330,420 420,750 750,840 840,1170
{} to start {} actually
首先要写的是，

252
00:08:19,010 --> 00:08:20,320
0,630
writes,|
|

253
00:08:20,530 --> 00:08:22,240
0,450 450,1140
{} the
将PUT操作提交给ITS，以登录领先者

254
00:08:22,240 --> 00:08:24,850
0,240 240,810 810,1140 1140,1590 1590,2610
put operation to its, to

255
00:08:24,970 --> 00:08:26,770
0,510 510,570 570,1110 1290,1560 1560,1800
{log,in} the leader| and then
|然后，你所认识的领导者将它的日志传播给其他追随者。

256
00:08:26,770 --> 00:08:28,150
0,120 120,660 660,750 750,870 870,1380
the leader you know propagates

257
00:08:28,150 --> 00:08:29,710
0,210 210,720 720,960 960,1080 1080,1560
it's log to the other

258
00:08:29,740 --> 00:08:31,100
0,930
followers.|
|

259
00:08:31,360 --> 00:08:33,310
0,570 600,990 990,1380 1380,1650 1650,1950
And {you,know} before it actually
你知道，在它真正平行发生或看到争论之前，

260
00:08:33,310 --> 00:08:35,290
0,330 330,390 390,900 1500,1770 1770,1980
happens in parallel or seeing

261
00:08:35,290 --> 00:08:36,730
0,600 690,870 870,1050 1080,1320 1320,1440
argue,| let me draw it
|让我稍微改变一下。

262
00:08:36,730 --> 00:08:38,220
0,330 330,930
slightly differently.|
|

263
00:08:38,780 --> 00:08:40,020
0,630

264
00:08:40,020 --> 00:08:41,220
0,420 420,510 510,930 930,990 990,1200
Basically it launches a bunch
基本上，它几乎同时向不同的追随者推出一系列RPC，

265
00:08:41,220 --> 00:08:43,980
0,60 60,240 240,930 930,1710 1710,2760
of {RPCs -} almost instantaneously

266
00:08:43,980 --> 00:08:47,160
0,510 540,900 900,1500 1650,2670 2970,3180
to the different followers,| each
|当然，您知道的每个关注者都会将该条目附加到其日志中，因此这需要向存储写入相同的内容

267
00:08:47,160 --> 00:08:48,390
0,360 360,420 420,840 840,930 930,1230
follower of course you know

268
00:08:48,420 --> 00:08:49,890
0,420 450,780 780,900 900,1350 1350,1470
will append the entry to

269
00:08:49,890 --> 00:08:51,030
0,150 150,450 450,660 660,990 990,1140
its logs {so,that} {requires -}

270
00:08:51,030 --> 00:08:53,760
0,90 90,570 1080,1200 1200,2070 2310,2730
a writes to storage {}

271
00:08:53,760 --> 00:08:55,170
0,270 270,450 450,1080 1110,1230 1230,1410
same thing here| and then
|然后他们会做出回应。

272
00:08:55,170 --> 00:08:56,560
0,90 90,570 570,990
they respond back.|
|

273
00:08:57,110 --> 00:08:58,580
0,240 240,540 540,1020 1020,1080 1080,1470
And so here's a response
所以这就是我的回应

274
00:08:58,580 --> 00:09:00,290
0,510 780,1050 1050,1110 1110,1290 1290,1710
back| and in this case,
|在这种情况下，大多数人都做出了回应，

275
00:09:00,290 --> 00:09:03,020
0,510 510,1020 1020,1200 1200,1920 2250,2730
{} majority has responded,| the
|领导者实际上可以实施手术，

276
00:09:03,020 --> 00:09:04,010
0,240 240,360 360,600 600,870 870,990
leader can actually apply the

277
00:09:04,010 --> 00:09:05,750
0,810 990,1170 1170,1290 1290,1530 1530,1740
operation,| so the leader will
|因此，领导者实际上将在这里对指示器应用操作。

278
00:09:05,750 --> 00:09:07,340
0,420 420,750 750,870 870,1320 1320,1590
actually apply the operation here

279
00:09:07,340 --> 00:09:09,680
0,300 420,870 930,1800
for {} indicator.|
|

280
00:09:10,000 --> 00:09:12,970
0,450 480,840 840,900 900,1830 2760,2970
So do the put and
因此执行PUT并将响应发送回客户端，

281
00:09:12,970 --> 00:09:14,110
0,180 180,240 240,660 660,960 960,1140
send the response back to

282
00:09:14,110 --> 00:09:16,660
0,60 60,570 1470,1800 1800,2190 2190,2550
the client,| what curious about
|令人好奇的是，我们实际上每秒能得到多少次推杆，

283
00:09:16,660 --> 00:09:19,840
0,180 180,330 330,540 540,1140 2550,3180
is like how many {put,per}

284
00:09:19,840 --> 00:09:21,010
0,330 330,510 510,600 600,840 840,1170
second can we actually get,|
|

285
00:09:21,040 --> 00:09:23,280
0,240 240,480 480,1020
{you,know} in this
你知道，在这个背景下。

286
00:09:24,170 --> 00:09:26,140
0,150 150,480 480,720 720,1170
in this {} setting.|
|

287
00:09:26,170 --> 00:09:27,820
0,450 870,1140 1140,1380 1380,1470 1470,1650
And you know {} think
你知道，想想看，

288
00:09:27,820 --> 00:09:29,290
0,270 270,510 510,600 600,720 720,1470
about it,| you know the
|你知道信封计算后你会变回原来的样子，

289
00:09:29,320 --> 00:09:31,750
0,600 600,1230 1230,1830 1860,2370 2370,2430
you {} grows back of

290
00:09:31,750 --> 00:09:32,980
0,120 120,450 450,1020 1020,1110 1110,1230
the envelope calculation,| we don't
|我们并不真正关心确切的数字，

291
00:09:32,980 --> 00:09:34,810
0,120 120,420 420,900 900,1140 1140,1830
really care exactly about the

292
00:09:34,840 --> 00:09:36,970
0,720 720,1080 1080,1290 1650,2040 2040,2130
exact numbers,| but {} you
|但你知道有一次往返，

293
00:09:36,970 --> 00:09:39,610
0,60 60,300 300,1020 1440,2280 2310,2640
know one roundtrip,| we need
|我们至少需要一次往返才能真正找到多数党领袖，

294
00:09:39,610 --> 00:09:40,690
0,150 150,330 330,510 510,990 990,1080
at least one roundtrip to

295
00:09:40,690 --> 00:09:42,250
0,210 210,360 360,420 420,1080 1110,1560
actually get the majority leader,|
|

296
00:09:42,250 --> 00:09:42,970
0,180 180,240 240,450 450,570 570,720
needs to talk to at
需要与至少一个关注者集合交谈以保持多数，

297
00:09:42,970 --> 00:09:44,590
0,210 210,420 420,930 930,1290 1290,1620
least one follower collection maintained

298
00:09:44,590 --> 00:09:45,520
0,30 30,570 570,690 690,810 810,930
{} majority,| so we're going
|因此，我们将至少有一条往返消息。

299
00:09:45,520 --> 00:09:46,540
0,90 90,450 450,600 600,780 780,1020
to have at least one

300
00:09:46,540 --> 00:09:48,420
0,630 660,1260
roundtrip messaging.|
|

301
00:09:52,340 --> 00:09:55,580
0,780 1230,1890 1890,2640 2640,3150 3150,3240
{} And {} then you
然后，您需要查看对稳定存储的写入，

302
00:09:55,580 --> 00:09:56,330
0,180 180,240 240,450 450,510 510,750
sort of need to look

303
00:09:56,330 --> 00:09:57,560
0,240 240,420 420,780 780,900 900,1230
at the writes to stable

304
00:09:57,560 --> 00:09:58,610
0,360 360,570 570,810 810,990 990,1050
storage,| because those tend to
|因为那些东西往往很贵

305
00:09:58,610 --> 00:10:00,320
0,120 120,900 1230,1380 1380,1470 1470,1710
be expensive| and we'll see
|在这种情况下，我们会让你知道，

306
00:10:00,320 --> 00:10:01,340
0,360 360,510 510,660 660,960 960,1020
{you,know} in this case,| we're
|我们将有两次写入，

307
00:10:01,340 --> 00:10:02,270
0,150 150,210 210,360 360,600 600,930
going to have two writes,|
|

308
00:10:02,270 --> 00:10:03,140
0,210 210,360 360,480 480,570 570,870
because there's gonna be one
因为在领导家会有一封信，

309
00:10:03,140 --> 00:10:04,190
0,210 210,300 300,390 390,810 810,1050
write at the leader's,| one
|在跟随者面前写了一句，

310
00:10:04,190 --> 00:10:05,360
0,240 240,360 360,510 510,1080 1080,1170
write at the follower,| at
|在这一点上，我们至少有两个节点具有副本，

311
00:10:05,360 --> 00:10:06,230
0,150 150,540 540,630 630,750 750,870
that point we have at

312
00:10:06,230 --> 00:10:07,640
0,330 330,690 690,1110 1110,1260 1260,1410
least two nodes that have

313
00:10:07,640 --> 00:10:09,170
0,90 90,720 900,1110 1110,1440 1440,1530
{} copy,| so what are
|那么，要承诺的事情是什么，

314
00:10:09,170 --> 00:10:10,100
0,90 90,240 240,360 360,450 450,930
the things will be committed,|
|

315
00:10:10,430 --> 00:10:13,340
0,540 540,1620 1620,2070 2070,2280 2280,2910
{} if no further failures,|
如果没有进一步的故障，|

316
00:10:13,520 --> 00:10:15,680
0,480 480,690 690,900 900,1590 1980,2160
{} and so basically {you,know}
所以基本上你知道

317
00:10:15,680 --> 00:10:16,720
0,510
to|
|

318
00:10:16,720 --> 00:10:17,770
0,120 120,690 750,870 870,990 990,1050
and minimum we're going to
最低限度，我们将需要写。

319
00:10:17,770 --> 00:10:19,220
0,210 210,390 390,870
need to write.|
|

320
00:10:20,590 --> 00:10:21,250
0,210 210,330 330,450 450,540 540,660
So that's sort of the
所以这就是基础，也是你能做的最好的事情，

321
00:10:21,250 --> 00:10:22,180
0,480 480,630 630,690 690,870 870,930
base and the best you

322
00:10:22,180 --> 00:10:23,200
0,120 120,450 450,690 690,930 930,1020
could do {right -},| in
|在我们在这里讨论的这个简单的方案中，

323
00:10:23,200 --> 00:10:24,400
0,330 330,600 600,900 900,1020 1020,1200
this simple scheme that we

324
00:10:24,400 --> 00:10:26,830
0,420 420,870 870,1260 1260,1680 2100,2430
discussed in discussed here,| sort
|在某种程度上，我们可以考虑成本是多少，

325
00:10:26,830 --> 00:10:28,210
0,90 90,540 540,660 660,840 840,1380
of, we can think about

326
00:10:28,210 --> 00:10:30,670
0,60 60,450 450,510 1050,1620 1710,2460
the cost is,| {} {in,a}
|在往返过程中，您知道也许那些在数据中心运行的网络不是跨互联网的，

327
00:10:30,670 --> 00:10:32,050
0,690 690,780 780,870 870,1140 1140,1380
roundtrip, you know maybe those

328
00:10:32,050 --> 00:10:32,860
0,210 210,300 300,360 360,600 600,810
running in the data center,

329
00:10:32,860 --> 00:10:33,910
0,420 420,480 480,660 660,960 960,1050
networks are not across the

330
00:10:33,910 --> 00:10:35,680
0,510 720,1200 1200,1410 1410,1530 1530,1770
Internet,| maybe you know that
|也许你知道这实际上可以精确到1毫秒。

331
00:10:35,680 --> 00:10:36,730
0,300 300,480 480,750 750,810 810,1050
actually comes down to 1

332
00:10:36,730 --> 00:10:37,840
0,540
millisecond.|
|

333
00:10:40,080 --> 00:10:41,610
0,420 420,870 870,960 960,1020 1020,1530
We're roughly in the neighborhood
我们大概在附近呆了一毫秒，

334
00:10:41,610 --> 00:10:42,390
0,180 180,300 300,570 570,750 750,780
for a millisecond,| maybe a
|可能会快一点，但我们很快就会关心这件事。

335
00:10:42,390 --> 00:10:43,470
0,150 150,270 270,720 720,930 930,1080
little bit faster, but we're

336
00:10:43,470 --> 00:10:44,850
0,210 210,420 420,750 840,990 990,1380
gonna care about this {in,a}

337
00:10:44,850 --> 00:10:45,860
0,480
second.|
|

338
00:10:45,890 --> 00:10:46,520
0,120 120,240 240,300 300,360 360,630
We're going to do two
我们将对稳定存储执行两次写入，

339
00:10:46,520 --> 00:10:49,490
0,390 390,510 510,840 840,1500 2310,2970
writes to stable storage,| write
|实际上，通过写入来节省存储空间似乎很昂贵

340
00:10:49,490 --> 00:10:50,510
0,420 420,540 540,690 690,780 780,1020
actually to save the storage

341
00:10:50,510 --> 00:10:51,830
0,150 150,240 240,360 360,1080 1080,1320
seems to be expensive| and
|这取决于你使用什么介质和什么技术来稳定存储，

342
00:10:51,830 --> 00:10:53,540
0,210 210,870 870,990 990,1290 1290,1710
it depends on what medium

343
00:10:53,540 --> 00:10:55,130
0,240 240,720 720,870 870,1170 1170,1590
what technology you're using for

344
00:10:55,130 --> 00:10:56,840
0,300 300,780 840,1170 1170,1530 1530,1710
stable storage,| let's assume when
|让我们假设我们使用固态硬盘时非常典型，

345
00:10:56,840 --> 00:10:58,400
0,90 90,360 360,870 870,1080 1410,1560
we're using {ssd's -} are

346
00:10:58,400 --> 00:11:00,530
0,240 240,900 1050,1590 1590,1920 1920,2130
pretty typical,| then there's only
|那么可能只有两毫秒左右的一次写入，

347
00:11:00,530 --> 00:11:01,910
0,270 270,630 630,810 810,930 930,1380
one write in the order

348
00:11:01,910 --> 00:11:03,380
0,150 210,570 570,720 720,1350 1350,1470
of maybe two milliseconds,| you
|您知道，我们必须真正确保写入数据最终会写入固态硬盘，

349
00:11:03,380 --> 00:11:03,950
0,90 90,210 210,300 300,390 390,570
know we've got to really

350
00:11:03,950 --> 00:11:04,970
0,150 150,360 360,600 600,720 720,1020
make sure actually the write

351
00:11:05,000 --> 00:11:06,680
0,300 300,540 540,870 870,1200 1410,1680
ends up {on -} the

352
00:11:06,680 --> 00:11:07,790
0,270 270,600 600,810 810,930 930,1110
{in,the,ssd -},| so we're gonna
|因此，我们可能必须进行同步写入。

353
00:11:07,790 --> 00:11:08,750
0,450 450,630 630,690 690,870 870,960
probably has to be a

354
00:11:08,750 --> 00:11:10,900
0,630 660,1320
synchronous write.|
|

355
00:11:10,990 --> 00:11:12,370
0,210 210,510 510,780 780,1110 1140,1380
So it means like two
所以这意味着一次写入需要两毫秒，

356
00:11:12,370 --> 00:11:14,350
0,600 600,840 840,1110 1110,1590 1590,1980
milliseconds for one write,| {so,two}
|所以两次写入大约是4毫秒。

357
00:11:14,350 --> 00:11:15,940
0,300 300,450 450,630 630,1230 1440,1590
writes would be roughly you

358
00:11:15,940 --> 00:11:17,640
0,120 120,360 360,1200
know 4 milliseconds.|
|

359
00:11:19,110 --> 00:11:20,580
0,330 330,480 480,690 690,1080 1110,1470
So we ended up, there's
所以我们结束了，将有5毫秒。

360
00:11:20,580 --> 00:11:21,990
0,120 120,180 180,300 300,540 540,1410
going to be 5 milliseconds.|
|

361
00:11:24,270 --> 00:11:25,410
0,240 240,360 360,450 450,630 630,1140
And so, how many operations
那么，每秒有多少次操作。

362
00:11:25,410 --> 00:11:26,680
0,150 150,660
per second.|
|

363
00:11:28,100 --> 00:11:28,970
0,210 210,270 270,420 420,510 510,870
Just to see if anybody
只是想看看有没有人还醒着。

364
00:11:28,970 --> 00:11:30,220
0,180 180,690
still awake.|
|

365
00:11:33,880 --> 00:11:35,740
0,1320 1320,1500 1500,1650 1650,1770 1770,1860
200.| {Yeah,so} there's gonna be
200美元。|是的，所以每秒会有200次推杆。

366
00:11:35,740 --> 00:11:39,480
0,1260 1260,1380 1380,1710
{200,put} per second.|
|

367
00:11:41,040 --> 00:11:42,210
0,210 210,570 570,720 720,900 900,1170
Any questions about this, doesn't
对此有任何疑问吗，说不通吗？

368
00:11:42,210 --> 00:11:43,320
0,150 150,600
make sense?|
|

369
00:11:46,010 --> 00:11:47,990
0,570 870,1110 1110,1290 1290,1650 1650,1980
Okay, so now let's look
好了，现在让我们来看看动物园管理员。

370
00:11:47,990 --> 00:11:50,150
0,90 90,1050 1080,1380 1380,1500 1500,2160
at zookeeper.| What's the roundtrip
|为什么要写往返，很抱歉我错过了你。

371
00:11:50,150 --> 00:11:51,620
0,300 300,450 450,930 930,1140 1140,1470
{for,in} the writes, I'm sorry

372
00:11:51,620 --> 00:11:52,820
0,90 90,420 420,630
I missed you.|
|

373
00:11:53,300 --> 00:11:55,310
0,390 570,1140 1140,1380 1380,1830 1830,2010
We, yeah the formula there
我们，是的，公式写在那里，你知道，往返，

374
00:11:55,310 --> 00:11:56,540
0,300 300,780 780,960 960,1080 1080,1230
writes there write there's {you,know}

375
00:11:56,540 --> 00:11:57,800
0,210 210,360 360,510 510,690 690,1260
{roundtrip -},| there's one roundtrip
|有一个从领导者到追随者的往返直接对话

376
00:11:57,800 --> 00:11:58,880
0,270 270,570 570,780 780,870 870,1080
direct talk from the leader

377
00:11:58,880 --> 00:11:59,810
0,120 120,210 210,720 720,840 840,930
to the follower| and the
|两个人写，一个在领导的稳定储藏室

378
00:11:59,810 --> 00:12:01,010
0,240 240,600 600,870 870,1020 1020,1200
two write, one at the

379
00:12:01,010 --> 00:12:02,480
0,360 360,720 720,840 840,900 900,1470
stable storage for the leader|
|

380
00:12:02,570 --> 00:12:04,910
0,150 150,390 390,1980 1980,2220 2220,2340
and one stable storage for
并为追随者提供一个稳定的储藏室。

381
00:12:04,910 --> 00:12:06,060
0,210 210,690
the follower.|
|

382
00:12:07,340 --> 00:12:08,390
0,150 150,270 270,570 570,900 900,1050
And the two writes end
两次写入以4结束，

383
00:12:08,390 --> 00:12:09,980
0,90 90,180 180,780 810,1380 1380,1590
up to 4,| roundtrip to
|往返大约1毫秒，

384
00:12:09,980 --> 00:12:11,240
0,330 330,540 540,1080 1080,1170 1170,1260
roughly 1 millisecond,| so the
|所以一次推杆的总和是5毫秒。

385
00:12:11,240 --> 00:12:12,500
0,240 240,330 330,720
total is 5

386
00:12:12,670 --> 00:12:14,400
0,540 540,660 660,840 840,1170
milliseconds for one put.|
|

387
00:12:17,160 --> 00:12:18,660
0,450 630,840 840,1290 1290,1380 1380,1500
Okay, let's look at the
好的，让我们来看看动物园管理员。

388
00:12:18,660 --> 00:12:19,860
0,150 150,660
{zookeeper -}.|
|

389
00:12:27,920 --> 00:12:29,690
0,150 150,840 840,930 930,1620 1620,1770
And again the metric that
同样，本文感兴趣的指标是吞吐量指标

390
00:12:29,690 --> 00:12:30,620
0,60 60,300 300,390 390,810 810,930
the paper is interested in

391
00:12:30,620 --> 00:12:32,390
0,330 330,450 450,990 1050,1440 1440,1770
is the {throughput -} metric|
|

392
00:12:32,390 --> 00:12:34,010
0,270 270,360 360,720 720,1350 1350,1620
where it basically declines you
从根本上说，你有很多客户

393
00:12:34,010 --> 00:12:35,360
0,120 120,330 330,510 510,720 720,1350
have many many many clients|
|

394
00:12:35,630 --> 00:12:39,230
0,1470 1500,1860 1860,2370 2400,3210 3240,3600
and they pump {} many
他们尽可能地向动物园饲养员提出许多要求

395
00:12:39,230 --> 00:12:40,340
0,690
requests

396
00:12:40,340 --> 00:12:43,220
0,870 990,1680 1680,2310
{} to {}

397
00:12:43,430 --> 00:12:45,020
0,450 480,810 810,1290 1290,1440 1440,1590
{} {zookeeper -} as much

398
00:12:45,020 --> 00:12:48,410
0,90 90,780 960,1530 1530,2400 2400,3390
as possible| and {} pipeline
|并积极地输送它们。

399
00:12:48,410 --> 00:12:49,780
0,180 180,810
them aggressively.|
|

400
00:12:49,930 --> 00:12:51,610
0,240 240,780 870,1410 1410,1530 1530,1680
And so, {} so let's
那么，让我们来看看结果是什么，

401
00:12:51,610 --> 00:12:53,770
0,270 270,570 570,1260 1290,1980 1980,2160
see what the results of

402
00:12:53,770 --> 00:12:55,630
0,360 360,750 1020,1590 1590,1740 1740,1860
that is,| and so let
|所以让我拉出这张纸的图表。

403
00:12:55,630 --> 00:12:57,740
0,210 210,480 480,810 840,1530
me pull up the

404
00:12:58,890 --> 00:13:01,080
0,720 930,1680
{graph,of,the} paper.|
|

405
00:13:04,260 --> 00:13:05,790
0,600 600,690 690,1230 1230,1320 1320,1530
And you look at that
你稍微看一下这张纸，

406
00:13:05,790 --> 00:13:06,960
0,420 420,480 480,810 810,960 960,1170
paper a little,| {} look
|稍微看看这张图。

407
00:13:06,960 --> 00:13:07,890
0,120 120,390 390,420 420,600 600,930
the graph a little bit.|
|

408
00:13:10,240 --> 00:13:11,800
0,600 600,900 900,1140 1140,1380 1380,1560
So a couple things that
所以有几件事应该是要注意的

409
00:13:11,800 --> 00:13:13,660
0,360 360,450 450,960 960,1410 1410,1860
presumably to observe| on the
|X轴上是请求的百分比，我们将在一秒钟内看到

410
00:13:13,780 --> 00:13:15,010
0,270 270,660 660,840 840,900 900,1230
x axis is the percentage

411
00:13:15,010 --> 00:13:16,360
0,150 150,840 840,990 990,1110 1110,1350
of requests as we'll see

412
00:13:16,360 --> 00:13:17,230
0,90 90,150 150,540 540,750 750,870
in a second| and this
|这对于区分读操作或写操作非常重要

413
00:13:17,230 --> 00:13:19,180
0,120 120,240 240,510 870,1350 1350,1950
is going to be important

414
00:13:19,180 --> 00:13:20,680
0,330 360,930 930,1140 1140,1290 1290,1500
to distinguish read or write

415
00:13:20,680 --> 00:13:22,420
0,630 630,780 780,960 960,1290 1290,1740
operations| and so write operations
|因此写操作实际上是修改修改状态的任何写操作的操作，

416
00:13:22,420 --> 00:13:23,710
0,90 90,270 270,720 720,810 810,1290
are really operations that modify

417
00:13:23,710 --> 00:13:25,390
0,390 390,720 720,1080 1080,1170 1170,1680
any write operation that modifies

418
00:13:25,390 --> 00:13:27,700
0,450 750,1080 1080,1560 1560,1710 1710,2310
state,| read operations or operations
|读操作或操作根本不修改状态，

419
00:13:27,700 --> 00:13:28,630
0,120 120,540 540,630 630,840 840,930
don't modify the state at

420
00:13:28,630 --> 00:13:30,850
0,360 630,810 810,900 900,1800 1890,2220
all,| so in our last
|因此，在我们的最后三个术语中，您将处于写入操作并获得读取操作。

421
00:13:30,850 --> 00:13:32,260
0,180 180,660 660,750 750,1260 1260,1410
three terms you would be

422
00:13:32,260 --> 00:13:33,940
0,180 180,300 300,540 540,1290 1290,1680
in the write operation and

423
00:13:33,940 --> 00:13:35,760
0,360 360,720 720,930 930,1440
get the read operation.|
|

424
00:13:36,340 --> 00:13:37,810
0,300 300,510 510,720 720,990 990,1470
And on the y axis
在y轴上是每秒的运算次数

425
00:13:37,810 --> 00:13:39,310
0,240 240,660 660,960 960,1410 1410,1500
is the number operations per

426
00:13:39,310 --> 00:13:40,600
0,510 510,780 780,990 990,1200 1200,1290
second| and let's look at
|让我们来看看有3台服务器的情况，

427
00:13:40,600 --> 00:13:41,860
0,60 60,300 300,390 390,570 570,1260
the case of 3 servers,|
|

428
00:13:42,130 --> 00:13:42,910
0,270 270,390 390,480 480,660 660,780
and so the first thing
所以你注意到的第一件事是零读，

429
00:13:42,910 --> 00:13:45,250
0,90 90,1110 1110,1320 1320,1650 1860,2340
you notice is that {}

430
00:13:45,400 --> 00:13:47,650
0,810 810,1110 1110,1410 1410,1920 1920,2250
zero reads,| so only write
|因此，只有写入操作，

431
00:13:47,650 --> 00:13:49,750
0,780 1110,1320 1320,1650 1650,1770 1770,2100
operations,| so once that modify
|因此，一旦修改了状态，我们就会得到大约每秒21000次操作作为吞吐量，

432
00:13:49,750 --> 00:13:50,860
0,120 120,510 690,870 870,990 990,1110
the state you know we

433
00:13:50,860 --> 00:13:53,580
0,600 600,1140 1170,2010
get roughly {21000

434
00:13:54,330 --> 00:13:56,970
0,720 1290,1830 1830,1950 1950,2400 2400,2640
-} operations per second as

435
00:13:56,970 --> 00:13:58,100
0,570
throughput,

436
00:13:58,480 --> 00:14:00,340
0,450 780,1230 1230,1590 1590,1740 1740,1860
right,| {} and you know
|你知道，看看你知道，如果系统只有读，

437
00:14:00,340 --> 00:14:01,840
0,300 300,480 480,600 600,810 810,1500
look at you know if

438
00:14:01,870 --> 00:14:03,910
0,540 540,870 870,1170 1170,1380 1380,2040
the system only has reads,|
|

439
00:14:04,240 --> 00:14:05,050
0,180 180,420 420,570 570,630 630,810
it actually gets a lot
它实际上得到了更多

440
00:14:05,050 --> 00:14:06,130
0,330 330,570 570,750 750,900 900,1080
more| and gets up in
|然后在你知道的60-70读到的区域内

441
00:14:06,130 --> 00:14:08,110
0,540 870,1500 1500,1620 1620,1710 1710,1980
the {} you know{} whatever

442
00:14:08,110 --> 00:14:11,170
0,90 90,1110 1110,2160 2460,2940 2940,3060
the {60,,70,reads} region| and in
|事实上，当事情继续下去的时候，数字是这样写的，

443
00:14:11,170 --> 00:14:12,670
0,390 510,810 810,990 990,1170 1170,1500
fact when things go on

444
00:14:12,670 --> 00:14:14,080
0,210 210,330 330,420 420,690 690,1410
is that the number reads,|
|

445
00:14:14,930 --> 00:14:16,190
0,180 180,600 600,690 690,1020 1020,1260
but throughput in {terms,of} reads
但就读取而言，吞吐量与众多服务器的规模相去甚远。

446
00:14:16,190 --> 00:14:17,330
0,90 90,600 600,720 720,810 810,1140
the scales with the numerous

447
00:14:17,330 --> 00:14:19,080
0,660
servers.|
|

448
00:14:25,510 --> 00:14:29,020
0,630 780,1560 2970,3150 3150,3330 3330,3510
So, {} if you're 3
因此，如果您有3台服务器，

449
00:14:29,020 --> 00:14:30,280
0,720 720,840 840,990 990,1110 1110,1260
servers,| you know you get
|你知道你得到了3次，你知道一台服务器的读表演者，

450
00:14:30,280 --> 00:14:31,450
0,150 150,690 690,780 780,930 930,1170
3 times, you know the

451
00:14:31,450 --> 00:14:32,740
0,180 180,600 600,660 660,900 900,1290
read performers of one server,|
|

452
00:14:32,740 --> 00:14:33,610
0,90 90,150 150,240 240,480 480,870
if you have 5 servers,
如果你有5台服务器，你可以在一台服务器上读到5次

453
00:14:33,610 --> 00:14:35,740
0,90 90,300 300,870 1170,1860 1860,2130
you get {} 5 times

454
00:14:35,740 --> 00:14:37,720
0,750 780,990 990,1350 1350,1560 1560,1980
to read performers one server|
|

455
00:14:38,200 --> 00:14:39,070
0,150 150,210 210,420 420,600 600,870
that of course not true
这当然不是真的写的，对吗，

456
00:14:39,070 --> 00:14:40,390
0,390 390,660 660,990 990,1260 1260,1320
writes, correct,| in fact if
|事实上，如果你看这张图，

457
00:14:40,390 --> 00:14:41,470
0,120 120,270 270,360 360,510 510,1080
you look at this graph,|
|

458
00:14:41,500 --> 00:14:43,180
0,150 150,300 300,540 540,1110 1440,1680
you see that if {}
您可以看到，如果有更多的服务器，写入性能实际上会下降。

459
00:14:43,180 --> 00:14:44,650
0,210 210,450 450,1080 1110,1290 1290,1470
with more servers the write

460
00:14:44,650 --> 00:14:46,260
0,360 360,600 600,810 810,1230
performance actually goes down.|
|

461
00:14:46,460 --> 00:14:48,020
0,600 600,1050 1050,1200 1200,1290 1290,1560
{} And you know that
你知道，这样做的原因大概是

462
00:14:48,020 --> 00:14:48,830
0,90 90,330 330,420 420,690 690,810
the reason for that is

463
00:14:48,830 --> 00:14:51,560
0,570 570,1590 1920,2370 2370,2550 2550,2730
presumably| the leader has to
|领导者必须聊天，我们有更多的服务器真正实现运营。

464
00:14:51,560 --> 00:14:52,850
0,360 360,420 420,540 540,750 750,1290
chat, we have more servers

465
00:14:52,850 --> 00:14:54,800
0,300 300,540 540,1050 1050,1410
actually gets operation through.|
|

466
00:14:54,980 --> 00:14:56,750
0,180 180,300 300,720 780,1290 1320,1770
And so when we're purely
因此，当我们纯粹进行写操作时

467
00:14:56,750 --> 00:14:59,180
0,210 210,450 450,1230 1350,1890 1890,2430
doing write operations| were actually
|实际上是有限的，我们不能期望比单台服务器更高的性能

468
00:14:59,210 --> 00:15:01,070
0,690 690,870 870,960 960,1410 1410,1860
limited and we cannot expect

469
00:15:01,070 --> 00:15:02,090
0,210 210,570 570,690 690,750 750,1020
more performance than a single

470
00:15:02,090 --> 00:15:03,080
0,300 300,390 390,450 450,810 810,990
server| and in fact the
|事实上，我们将降低服务器的性能。

471
00:15:03,080 --> 00:15:03,830
0,210 210,450 450,540 540,690 690,750
up servers we're going to

472
00:15:03,830 --> 00:15:05,960
0,330 360,1020 1020,1740
go down performance.|
|

473
00:15:07,540 --> 00:15:09,460
0,150 150,300 300,510 510,870 870,1920
And so, just {21000,per -}
因此，即使对于单个写入操作，每秒也只有21000，

474
00:15:09,460 --> 00:15:12,520
0,390 390,600 600,870 870,1590 1620,3060
second {you,know} {even,for} single {}

475
00:15:13,060 --> 00:15:15,250
0,450 450,600 600,840 840,1560 1830,2190
you know write operations, {}|
|

476
00:15:15,250 --> 00:15:16,990
0,480 480,630 630,1140 1140,1650 1650,1740
we have a configuration of
我们有3台服务器的配置是令人印象深刻的数字是相当高的

477
00:15:16,990 --> 00:15:18,700
0,360 360,750 750,840 840,1320 1320,1710
3 servers is impressive number

478
00:15:18,820 --> 00:15:19,960
0,120 120,540 540,600 600,720 720,1140
is quite a bit higher|
|

479
00:15:19,960 --> 00:15:22,570
0,180 180,600 600,1080 1110,1800 2130,2610
and actually the simple calculus
实际上，我们为实验3所做的简单微积分，

480
00:15:22,570 --> 00:15:24,160
0,120 120,210 210,420 420,1080 1110,1590
that we did for {lab,3},|
|

481
00:15:24,160 --> 00:15:25,540
0,510 510,630 630,900 900,1080 1080,1380
{lab,3} will never get into
实验室3永远不会进入，也不会离附近更近。

482
00:15:25,570 --> 00:15:26,830
0,180 180,510 540,780 780,1110 1110,1260
will not get closer to

483
00:15:26,830 --> 00:15:28,540
0,180 180,540 540,630 630,1050
the neighborhood at all.|
|

484
00:15:28,570 --> 00:15:30,490
0,540 540,870 870,1320 1440,1800 1800,1920
{} And so we want
所以我们想要了解，

485
00:15:30,490 --> 00:15:32,590
0,60 60,690 900,1470 1470,1950 1950,2100
to understand,| {} you want
|你想在这个设计中看到，

486
00:15:32,590 --> 00:15:33,700
0,60 60,240 240,300 300,480 480,1110
to see in this design,|
|

487
00:15:33,730 --> 00:15:35,320
0,330 330,900 900,1110 1110,1260 1260,1590
what designers do to actually
设计师做了什么才能真正获得这样的表现。

488
00:15:35,350 --> 00:15:36,910
0,420 420,570 570,750 750,810 810,1560
get that kind of performance.|
|

489
00:15:41,950 --> 00:15:42,940
0,240 240,390 390,480 480,840 840,990
And sort of two as
就像我之前提到的，大概有两个，

490
00:15:42,940 --> 00:15:43,840
0,30 30,330 330,660 660,780 780,900
I mentioned earlier,| there's sort
|有两个关键的想法，

491
00:15:43,840 --> 00:15:45,820
0,60 60,300 300,510 510,1200 1500,1980
of two key ideas, {}|
|

492
00:15:45,820 --> 00:15:48,220
0,630 690,1110 1110,1230 1230,2190 2220,2400
one everything is asynchronous| or
一，一切都是不同步的|或者客户可以向筏子或动物园管理员提交多个操作，对不起，一次拍摄，

493
00:15:48,220 --> 00:15:49,580
0,870
{the,clients}

494
00:15:49,760 --> 00:15:51,980
0,180 180,510 510,750 750,1650
can submit many operations

495
00:15:52,460 --> 00:15:54,620
0,330 330,960 990,1470 1500,1950 1950,2160
to raft or {zookeeper -}

496
00:15:54,620 --> 00:15:55,820
0,420 450,720 720,900 900,930 930,1200
sorry, {} in a single

497
00:15:55,820 --> 00:15:57,530
0,450 930,1260 1260,1410 1410,1590 1590,1710
shot,| {} so their own
|所以他们自己的管道，

498
00:15:57,530 --> 00:16:00,290
0,480 480,690 690,1320 1530,2610 2610,2760
pipeline,| so basically wins away
|所以基本上赢得了考虑动物园管理员客户的机会，

499
00:16:00,290 --> 00:16:01,670
0,120 120,270 270,930 930,1140 1140,1380
to think about {zookeeper -}

500
00:16:01,670 --> 00:16:04,070
0,420 420,750 750,1170 1350,2100 2100,2400
client,| basically says, please start
|基本上是说，请开始执行这个PUT，而不是等待PUT的响应，

501
00:16:04,070 --> 00:16:05,600
0,510 510,780 780,1080 1080,1200 1200,1530
executing this put and doesn't

502
00:16:05,600 --> 00:16:07,760
0,300 300,450 450,540 540,1260 1350,2160
wait in the response {}

503
00:16:07,760 --> 00:16:09,110
0,120 120,240 240,600 630,1110 1110,1350
of the put,| you know
|你知道马上就会发出第二个看跌期权

504
00:16:09,110 --> 00:16:10,760
0,630 630,960 960,1050 1050,1350 1350,1650
immediately issues the second put|
|

505
00:16:10,760 --> 00:16:11,480
0,90 90,180 180,240 240,570 570,720
and then the third and
然后是第三个、第四个和第五个。

506
00:16:11,480 --> 00:16:12,660
0,270 270,390 390,750
fourth and fifth.|
|

507
00:16:12,750 --> 00:16:13,740
0,180 180,240 240,630 630,810 810,990
So, for example a lot
因此，例如，许多看跌期权将被批量处理在一起，

508
00:16:13,740 --> 00:16:14,610
0,60 60,210 210,420 420,660 660,870
of these puts run will

509
00:16:14,610 --> 00:16:16,290
0,150 150,630 630,1050 1050,1380 1380,1680
be batched together,| maybe even
|也许甚至只有一条消息会被传递给领导者

510
00:16:16,290 --> 00:16:17,430
0,60 60,360 360,750 750,990 990,1140
a single message will be

511
00:16:17,430 --> 00:16:20,010
0,570 570,840 840,1140 1350,2220 2220,2580
transferred to the leader| and
|领导者将同时应用所有这些规则，

512
00:16:20,010 --> 00:16:20,910
0,90 90,300 300,450 450,750 750,900
the leader will apply them

513
00:16:20,910 --> 00:16:22,230
0,390 390,480 480,540 540,780 780,1320
all at the same time,|
|

514
00:16:22,500 --> 00:16:24,330
0,600 600,960 960,1260 1260,1590 1590,1830
{} in fact world leader
事实上，World Leader只会向永久存储写入一次

515
00:16:24,330 --> 00:16:25,470
0,210 210,540 540,630 630,720 720,1140
will write to the persistent

516
00:16:25,470 --> 00:16:26,850
0,420 420,720 720,1200 1200,1290 1290,1380
storage only once| you know
|你知道，对于一整批手术来说，

517
00:16:26,850 --> 00:16:27,840
0,120 120,240 240,630 630,870 870,990
for a whole batch of

518
00:16:27,840 --> 00:16:29,250
0,540 540,750 750,1080 1080,1140 1140,1410
operation,| so instead of having
|因此，不是每个操作具有一次写入，

519
00:16:29,250 --> 00:16:31,530
0,300 300,780 960,1200 1200,1560 1560,2280
one write {} per operation,|
|

520
00:16:31,560 --> 00:16:32,700
0,210 210,330 330,390 390,690 690,1140
you're going to have one
您将使用一个磁盘写入多个操作

521
00:16:32,700 --> 00:16:34,080
0,330 330,690 690,840 840,1140 1140,1380
disk write to many many

522
00:16:34,080 --> 00:16:35,670
0,210 210,870 1110,1350 1350,1500 1500,1590
many operations| and this is
|这是他们在写入操作上获得非常好的性能的原因之一。

523
00:16:35,670 --> 00:16:36,840
0,270 270,750 750,870 870,1020 1020,1170
one reason you know they

524
00:16:36,840 --> 00:16:38,790
0,180 180,570 570,1290 1320,1830 1830,1950
get this a very good

525
00:16:38,790 --> 00:16:41,440
0,750 780,1380 1380,1650 1650,2370
performance on write operations.|
|

526
00:16:41,710 --> 00:16:43,720
0,150 150,300 300,570 570,1020 1290,2010
And the second thing is,|
第二件事是，|

527
00:16:43,900 --> 00:16:45,550
0,720 750,960 960,1080 1080,1290 1290,1650
{} they do something special
它们为读取操作做了一些特殊的事情，

528
00:16:45,550 --> 00:16:48,520
0,660 690,1200 1200,1920 1980,2280 2280,2970
for read operations,| they allow
|它们允许任何服务器处理读取操作。

529
00:16:48,550 --> 00:16:50,880
0,240 240,1080 1200,1830
read operations to

530
00:16:50,970 --> 00:16:52,590
0,300 300,690 690,840 840,1020 1020,1620
be processed by any server.|
|

531
00:16:57,200 --> 00:16:58,220
0,180 180,480 480,600 600,870 870,1020
So instead of running all
因此，不是通过领导者来运行所有的操作，

532
00:16:58,220 --> 00:16:59,600
0,90 90,630 630,780 780,870 870,1380
the operations through the leader,|
|

533
00:16:59,990 --> 00:17:02,780
0,360 360,600 600,1980 2010,2550 2550,2790
{} they allow operations to
它们允许任何服务器实际处理操作。

534
00:17:02,780 --> 00:17:04,280
0,240 240,360 360,720 720,1050 1050,1500
actually be processed by any

535
00:17:04,280 --> 00:17:05,380
0,450
server.|
|

536
00:17:06,060 --> 00:17:07,340
0,780
So.|
所以。|

537
00:17:07,840 --> 00:17:08,980
0,150 150,420 420,540 540,900 900,1140
And then the later we
后来我们想要更多地谈论它，

538
00:17:08,980 --> 00:17:09,640
0,120 120,270 270,480 480,510 510,660
want to talk a little

539
00:17:09,640 --> 00:17:11,560
0,120 120,330 330,600 600,750 1290,1920
bit more about it, {}|
|

540
00:17:11,800 --> 00:17:13,000
0,390 390,660 660,840 840,1080 1080,1200
I think I wanted to
我想我想想想我们可以做些类似的事情，

541
00:17:13,000 --> 00:17:14,350
0,150 150,510 510,720 1020,1260 1260,1350
think about what could we

542
00:17:14,350 --> 00:17:15,520
0,120 120,360 360,780 780,990 990,1170
do something similar,| like let's
|比方说，我们想要做3号实验室。

543
00:17:15,520 --> 00:17:16,420
0,150 150,330 330,570 570,630 630,900
say we want to lab

544
00:17:16,420 --> 00:17:17,360
0,450
3.|
|

545
00:17:20,570 --> 00:17:21,980
0,720 750,960 960,1050 1050,1260 1260,1410
And {} we're gonna do
我们也要玩同样的把戏，

546
00:17:21,980 --> 00:17:23,030
0,90 90,360 360,720 720,930 930,1050
the same trick,| here we
|这里我们要看的基本上是从任何机器或任何对等点读取。

547
00:17:23,030 --> 00:17:24,470
0,150 150,240 240,630 630,720 720,1440
want to look at {}

548
00:17:24,470 --> 00:17:27,560
0,60 90,690 1050,1740 1770,2430
is basically reads from

549
00:17:30,500 --> 00:17:32,840
0,330 330,810 1380,1620 1620,1860 1860,2340
any machine or any peer.|
|

550
00:17:36,760 --> 00:17:37,960
0,330 330,600 600,870 870,1020 1020,1200
So the picture would be
因此，图片将如下所示，

551
00:17:37,960 --> 00:17:39,130
0,180 180,720 720,900 900,990 990,1170
as follows,| {you,know} we have
|你知道我们有个领袖，

552
00:17:39,130 --> 00:17:40,440
0,60 60,600
a leader,|
|

553
00:17:40,750 --> 00:17:42,310
0,180 180,510 510,600 600,780 780,1560
we have the two followers,|
我们有两个追随者，|

554
00:17:42,910 --> 00:17:44,020
0,150 150,450 450,750 750,990 990,1110
we just stick to the
我们只是坚持三个人的情况。

555
00:17:44,020 --> 00:17:45,900
0,270 270,360 360,1050
case of three.|
|

556
00:17:46,950 --> 00:17:48,240
0,240 240,450 450,600 600,660 660,1290
{} We have a client.|
我们有个客户。|

557
00:17:49,980 --> 00:17:53,340
0,870 900,1710 1980,2790 2790,3000 3000,3360
And, {} we're like consider
而且，我们就像在考虑实际可能发生的事情。

558
00:17:53,340 --> 00:17:54,960
0,180 180,390 390,570 570,990
what actually could happen.|
|

559
00:17:55,110 --> 00:17:56,400
0,210 210,690 690,930 930,1110 1110,1290
{} If you were sort
如果你很容易遵循这个策略，我们将从任何地方阅读，

560
00:17:56,400 --> 00:17:58,020
0,120 120,630 630,960 960,1110 1110,1620
of easily follow this strategy

561
00:17:58,020 --> 00:17:58,830
0,240 240,300 300,420 420,510 510,810
where we're going to read

562
00:17:58,830 --> 00:17:59,700
0,150 150,510 510,660 660,810 810,870
from anything,| we use our
|我们利用我们的客户。

563
00:17:59,700 --> 00:18:00,840
0,570
client.|
|

564
00:18:01,310 --> 00:18:02,690
0,300 300,630 630,1080 1080,1290 1290,1380
The leaders actually when we
实际上，当我们击球时，领先者，

565
00:18:02,690 --> 00:18:03,590
0,180 180,570 570,660 660,750 750,900
do puts,| you know they
|你知道他们都是通过领队的。

566
00:18:03,590 --> 00:18:05,030
0,240 240,390 390,630 630,930 930,1440
all go through the leader.|
|

567
00:18:06,150 --> 00:18:07,650
0,270 270,450 450,960 960,1170 1170,1500
And so {the,client} to basically
因此，客户端基本上可以进行阅读

568
00:18:07,650 --> 00:18:09,330
0,180 180,600 960,1410 1410,1500 1500,1680
does read| {} and let's
|假设你知道这是一次读操作，

569
00:18:09,330 --> 00:18:10,200
0,240 240,360 360,540 540,720 720,870
say you know this was

570
00:18:10,200 --> 00:18:12,280
0,90 90,390 420,900 900,1380
a read put done,|
|

571
00:18:12,310 --> 00:18:13,360
0,360 360,570 570,660 660,750 750,1050
{} and at the same
与此同时，在看跌期权之后，客户现在发出了一个GET，

572
00:18:13,360 --> 00:18:14,980
0,420 420,780 780,1140 1140,1530 1530,1620
time roughly after after the

573
00:18:14,980 --> 00:18:16,720
0,180 180,300 300,630 630,1110 1110,1740
put was now {the,client} issues

574
00:18:16,990 --> 00:18:18,300
0,480
{a,get},|
|

575
00:18:18,510 --> 00:18:19,770
0,210 210,630 630,870 870,1170 1170,1260
and talks to one of
并与其中一个追随者随意交谈，

576
00:18:19,770 --> 00:18:21,300
0,60 60,630 660,750 750,1290 1290,1530
the followers an arbitrary one,|
|

577
00:18:21,300 --> 00:18:22,620
0,210 210,480 480,840 900,1050 1050,1320
let's use this in case
让我们使用这个，以防它不能与领导交谈

578
00:18:22,620 --> 00:18:23,400
0,60 60,240 240,450 450,690 690,780
it does not talk to

579
00:18:23,400 --> 00:18:25,920
0,90 90,600 810,1620 1710,2370 2400,2520
the leader| and then you
|然后你就知道关注者的回应在哪里

580
00:18:25,920 --> 00:18:28,770
0,150 150,540 870,1410 1560,2160 2160,2850
know where the follower response|
|

581
00:18:29,040 --> 00:18:30,480
0,390 390,450 450,900 900,1230 1230,1440
and the question is like
问题是，需要观察的价值是什么。

582
00:18:30,480 --> 00:18:32,160
0,360 360,1110 1140,1410 1410,1500 1500,1680
what value does to get

583
00:18:32,160 --> 00:18:33,400
0,90 90,750
to observe.|
|

584
00:18:35,320 --> 00:18:36,100
0,180 180,330 330,360 360,450 450,780
So what are the possible
那么你知道客人们可以遵守的可能的价值观是什么，

585
00:18:36,100 --> 00:18:37,300
0,510 510,600 600,750 750,1020 1020,1200
values you know that the

586
00:18:37,300 --> 00:18:38,620
0,240 240,390 390,750 780,1050 1050,1320
guests can observe,| let's say
|比方说，你知道我们读的是什么关键字

587
00:18:38,620 --> 00:18:39,520
0,210 210,270 270,390 390,540 540,900
that you know we're reading

588
00:18:39,520 --> 00:18:42,220
0,570 630,1170 1170,1620 1890,2490 2490,2700
whatever the key x| and
|X的初始值为0

589
00:18:42,220 --> 00:18:43,600
0,120 120,660 660,1080 1080,1200 1200,1380
the initial value of {x,is}

590
00:18:43,600 --> 00:18:45,910
0,810 990,1170 1170,1770 1770,2070 2070,2310
0| and {in,the,put} actually put
|而在PUT中，x实际上等于1。

591
00:18:45,910 --> 00:18:47,300
0,210 210,390 390,870
x to 1.|
|

592
00:18:48,240 --> 00:18:49,380
0,360 360,570 570,630 630,720 720,1140
And what are the values
X实际返回的值是什么？

593
00:18:49,380 --> 00:18:51,120
0,180 180,390 390,780 780,1350 1380,1740
that x actually return| and
|如果我们不做任何特别的事情。

594
00:18:51,150 --> 00:18:51,960
0,300 300,450 450,540 540,690 690,810
{} if we don't do

595
00:18:51,960 --> 00:18:53,680
0,270 270,750 750,1140
anything particularly special.|
|

596
00:18:56,520 --> 00:18:57,390
0,180 180,360 360,540 540,570 570,870
{} So just a question
所以这里只有一个关于设置的问题，

597
00:18:57,390 --> 00:18:58,560
0,90 90,300 300,390 390,720 720,1170
here about the setup,| so
|所以如果我们假设木筏是这里的基础设施

598
00:18:58,560 --> 00:18:59,940
0,270 270,390 390,810 810,960 960,1380
if we're assuming that raft

599
00:18:59,940 --> 00:19:01,920
0,90 90,180 180,1320 1320,1620 1680,1980
is the infrastructure here| and
|并得到它的另一个命令，

600
00:19:01,920 --> 00:19:03,300
0,300 300,420 420,600 600,900 900,1380
get its just another command,|
|

601
00:19:03,420 --> 00:19:05,430
0,330 330,750 750,1260 1290,1740 1740,2010
then would the follower just
那么追随者会不会直接向领头人申请，

602
00:19:05,430 --> 00:19:06,990
0,480 480,870 870,1020 1020,1110 1110,1560
redirect applying to the leader,|
|

603
00:19:07,020 --> 00:19:08,190
0,120 120,390 390,480 480,660 660,1170
who put the get request
向领袖发出GET请求的人。

604
00:19:08,250 --> 00:19:12,420
0,150 150,240 240,570 930,4170 4170,4170
for the {leader -}.| {No,a}
|不，我们可以做的事情很多，

605
00:19:12,420 --> 00:19:13,200
0,330 330,390 390,600 600,690 690,780
lot of things we could

606
00:19:13,200 --> 00:19:15,030
0,240 240,390 390,1170 1470,1650 1650,1830
do,| but like we want
|但就像我们想要获得这种[完美的]可扩展性一样。

607
00:19:15,030 --> 00:19:16,350
0,60 60,210 210,360 360,690 690,1320
to get this [perfect] scalability.|
|

608
00:19:16,850 --> 00:19:18,530
0,420 420,510 510,690 690,930 930,1680
So to get perfect scalability,|
因此，为了获得完美的可扩展性，|

609
00:19:18,770 --> 00:19:20,480
0,390 390,720 720,1050 1050,1620 1620,1710
the follower cannot talk to
跟随者不能与领导者对话以进行读取操作，

610
00:19:20,480 --> 00:19:22,130
0,120 120,750 750,990 990,1200 1200,1650
the leader for read operations,|
|

611
00:19:22,130 --> 00:19:23,600
0,240 240,660 660,840 840,1320 1320,1470
so basically read operations are
所以基本上读操作是由单个追随者立即执行的，

612
00:19:23,600 --> 00:19:26,150
0,510 510,1020 1200,1380 1380,1860 1860,2550
executed by the individual followers

613
00:19:26,450 --> 00:19:28,910
0,540 660,1290 1440,1740 1740,1890 1890,2460
{} immediately,| without no communication,|
|如果没有沟通，|

614
00:19:29,060 --> 00:19:29,870
0,240 240,300 300,510 510,630 630,810
not to know the way
不知道我们将如何获得完美的可扩展性。

615
00:19:29,870 --> 00:19:30,590
0,90 90,210 210,270 270,420 420,720
we're going to get perfect

616
00:19:30,590 --> 00:19:32,360
0,570 750,1170 1170,1410 1410,1620 1620,1770
scalability.| Right, there not even
|对，那里甚至连交流都没有。

617
00:19:32,360 --> 00:19:35,090
0,630 630,870 2130,2220 2220,2580 2580,2730
communicating with.| Yep, I'm just
|是的，我只是在按计划行事，

618
00:19:35,090 --> 00:19:36,920
0,210 210,660 660,1320 1320,1530 1530,1830
doing beneath plan,| looks like
|看起来我们的目标是获得完美的可扩展性，

619
00:19:36,920 --> 00:19:37,610
0,150 150,390 390,450 450,540 540,690
our goal is to get

620
00:19:37,610 --> 00:19:39,590
0,270 270,930 1200,1530 1530,1800 1800,1980
perfect scalability,| like {you,know} {zookeeper
|就像你知道动物园管理员做的那样

621
00:19:39,590 --> 00:19:41,030
0,270 270,720 1020,1200 1200,1290 1290,1440
-} does| and we want
|我们想要理解的是你知道这是困难还是容易

622
00:19:41,030 --> 00:19:42,050
0,60 60,540 540,870 870,930 930,1020
to understand like you know

623
00:19:42,050 --> 00:19:43,190
0,90 90,240 240,630 630,750 750,1140
is that difficult or easy|
|

624
00:19:43,400 --> 00:19:44,330
0,300 300,480 480,600 600,780 780,930
or what does that really
或者这到底是什么意思

625
00:19:44,330 --> 00:19:45,620
0,450 630,780 780,900 900,1020 1020,1290
mean| and so the first
|因此，首先要做的就是在领导者身上什么都不做

626
00:19:45,620 --> 00:19:46,790
0,120 120,210 210,450 450,1020 1020,1170
thing to find experiment is

627
00:19:46,790 --> 00:19:48,170
0,150 150,270 270,420 420,900 900,1380
like would do absolutely nothing

628
00:19:48,200 --> 00:19:49,760
0,210 210,330 330,810 810,960 960,1560
at the leaders| and followers
|关注者和关注者执行读操作并返回值。

629
00:19:50,060 --> 00:19:52,670
0,420 420,570 570,1410 1410,1890 1920,2610
followers get read operation executed

630
00:19:52,670 --> 00:19:53,780
0,120 120,360 360,420 420,720
and return the value.|
|

631
00:19:55,060 --> 00:19:55,870
0,150 150,360 360,510 510,630 630,810
And what can you know,|
你又能知道些什么呢，|

632
00:19:55,870 --> 00:19:57,100
0,150 150,450 450,750 750,930 930,1230
so another question what values
那么另一个问题是什么值可以返回，同样是客户在这张图中观察到的？

633
00:19:57,100 --> 00:19:58,540
0,150 150,210 210,540 540,840 1020,1440
can be returned by, again

634
00:19:58,540 --> 00:19:59,900
0,60 60,330 330,840
the client observe

635
00:20:00,550 --> 00:20:02,380
0,180 180,330 330,1260 1380,1620 1620,1830
in this picture?| Can be
|可以是任何一种，

636
00:20:02,380 --> 00:20:04,750
0,570 570,1020 1020,1560 1590,1890 1890,2370
either,| because maybe you put
|因为也许你放进去了，他们就会通过领先者的圆盘。

637
00:20:04,840 --> 00:20:06,100
0,480 510,690 690,960 960,1110 1110,1260
then they make it through

638
00:20:06,100 --> 00:20:07,450
0,90 90,450 450,660 780,1020 1020,1350
the disk of the leader

639
00:20:07,450 --> 00:20:08,980
0,450 660,1200 1200,1260 1260,1380 1380,1530
yet.| Yeah, it could be
|是啊，也可能是，

640
00:20:08,980 --> 00:20:10,300
0,360 360,570 570,1110 1110,1230 1230,1320
either,| so either going to
|所以要么返回0，要么返回1，对。

641
00:20:10,300 --> 00:20:11,980
0,540 540,1170 1200,1470 1470,1530 1530,1680
return 0 or it could

642
00:20:11,980 --> 00:20:13,540
0,360 360,600 660,1080
return 1, right.|
|

643
00:20:14,180 --> 00:20:15,260
0,180 180,270 270,390 390,720 720,1080
So it can return stale
所以它可以返回过时的数据，这是有可能的。

644
00:20:15,260 --> 00:20:16,340
0,450
data,

645
00:20:16,790 --> 00:20:19,080
0,180 180,480 510,1290
it's {} possibility.|
|

646
00:20:19,330 --> 00:20:21,250
0,690 870,1230 1230,1440 1440,1650 1650,1920
{} Let's say, let's say
比方说，比方说我们知道，

647
00:20:21,250 --> 00:20:23,230
0,300 300,1020 1050,1290 1290,1470 1470,1980
we do,| let's say return
|假设返回1，

648
00:20:23,380 --> 00:20:24,840
0,360 360,870
{} 1,|
|

649
00:20:25,270 --> 00:20:26,980
0,180 180,360 360,750 780,1290 1290,1710
so this get returns 1
因此，对于[]实验，这个GET返回1

650
00:20:27,250 --> 00:20:28,630
0,480 480,600 600,840 840,1290 1290,1380
for a [] experiment| and
|然后又谢绝了另一位。

651
00:20:28,630 --> 00:20:31,500
0,360 870,1350 1350,1830 1830,2250
then declined another yet.|
|

652
00:20:33,680 --> 00:20:34,610
0,150 150,300 300,480 480,660 660,930
I'm not going to say
我不会说这笔钱的去向，

653
00:20:34,610 --> 00:20:35,420
0,150 150,390 390,540 540,690 690,810
to where that get is

654
00:20:35,420 --> 00:20:39,170
0,510 960,1710 1740,2250 2310,2490 2490,3750
going,| {} but you know
|但你知道，我们可以看到什么价值观，

655
00:20:40,860 --> 00:20:43,140
0,660 1200,1560 1560,2010 2010,2160 2160,2280
and what values could we

656
00:20:43,140 --> 00:20:44,080
0,390
see,|
|

657
00:20:44,750 --> 00:20:45,920
0,210 210,540 540,630 630,840 840,1170
for respond to that get.|
对这一点的回应。|

658
00:20:46,840 --> 00:20:47,920
0,390 390,510 510,600 600,750 750,1080
Assuming there are no other
假设没有其他写入，这应该是一个写入，对吧。

659
00:20:47,920 --> 00:20:49,090
0,330 330,450 450,600 600,720 720,1170
writes that should be one,

660
00:20:49,120 --> 00:20:50,100
0,390
right.|
|

661
00:20:50,820 --> 00:20:52,950
0,300 300,960 990,1950 1950,2010 2010,2130
Yeah, unfortunately,| because I have
是的，不幸的是，|因为我有3台服务器，

662
00:20:52,950 --> 00:20:54,240
0,210 210,780 900,1110 1110,1170 1170,1290
3 servers,| if I had
|如果我有5台服务器。

663
00:20:54,240 --> 00:20:55,700
0,270 270,870
5 servers.|
|

664
00:21:00,660 --> 00:21:03,570
0,690 1230,2190 2190,2310 2310,2430 2430,2910
Why, why is it different?|
为什么，为什么会不同？|

665
00:21:03,600 --> 00:21:06,040
0,1350 1380,1860
{Okay,let's,make,it} different.|
好的，让我们让它与众不同吧。|

666
00:21:07,200 --> 00:21:09,000
0,450 450,930 960,1380 1380,1530 1530,1800
{} So surely can return
所以肯定可以返回1，我们同意，

667
00:21:09,000 --> 00:21:11,610
0,330 360,1200 1230,1590 1590,2010 2250,2610
1, we're agreeing that,| because
|因为如果跟随者与第二个GET请求交谈，

668
00:21:11,610 --> 00:21:13,290
0,90 90,180 180,570 570,870 870,1680
if the follower talks to

669
00:21:13,440 --> 00:21:14,850
0,210 210,570 570,810 810,1320 1320,1410
the second get request,| you
|你知道，你会和一个真正看过看跌期权操作的追随者交谈，

670
00:21:14,850 --> 00:21:19,110
0,360 540,1230 1230,1530 1530,3150 3420,4260
know talks to a follower

671
00:21:19,110 --> 00:21:20,070
0,180 180,420 420,540 540,870 870,960
that actually has seen the

672
00:21:20,070 --> 00:21:21,990
0,180 180,900 1080,1350 1350,1470 1470,1920
put operation,| which the majority
|他们中的大多数人都看过PUT操作，

673
00:21:21,990 --> 00:21:22,740
0,90 90,210 210,330 330,570 570,750
of them have seen put

674
00:21:22,740 --> 00:21:23,790
0,540 540,720 720,840 840,900 900,1050
operation,| we're going to get
|我们会拿回1，对吧。

675
00:21:23,790 --> 00:21:25,180
0,240 240,570 600,990
1 back, right.|
|

676
00:21:25,920 --> 00:21:27,210
0,180 180,330 330,690 690,1080 1110,1290
The real question is could
真正的问题是它能不能看到0，

677
00:21:27,210 --> 00:21:29,040
0,120 120,570 570,660 660,1290
it see {} 0,|
|

678
00:21:31,670 --> 00:21:32,840
0,330 330,600 600,720 720,1110 1110,1170
even though it observed the
尽管它早些时候观察到了1。

679
00:21:32,840 --> 00:21:34,200
0,300 300,810
1 earlier.|
|

680
00:21:34,930 --> 00:21:36,070
0,90 90,330 360,480 480,960 960,1140
I mean you could see
我的意思是你可以看到0，

681
00:21:36,070 --> 00:21:36,820
0,60 60,300 300,570 570,660 660,750
that 0,| even in the
|即使在3台服务器的情况下，

682
00:21:36,820 --> 00:21:38,290
0,270 270,510 510,750 750,1020 1020,1470
case of a 3 servers

683
00:21:38,290 --> 00:21:39,910
0,180 180,600 600,810 810,1050 1050,1620
right,| because let's say that
|因为假设您拥有大多数服务器。

684
00:21:39,910 --> 00:21:40,750
0,150 150,300 300,360 360,780 780,840
you have the majority of

685
00:21:40,750 --> 00:21:42,340
0,510 510,1020 1020,1110 1110,1260 1260,1590
servers.| Let me do first
|让我来做前5个案例，因为它更容易看到。

686
00:21:42,340 --> 00:21:43,540
0,270 270,480 480,720 720,840 840,1200
5 case, because it's simpler

687
00:21:43,540 --> 00:21:44,720
0,60 60,450
to see.|
|

688
00:21:46,750 --> 00:21:48,130
0,210 210,360 360,810 810,1080 1080,1380
Are we assuming that the
我们是否假设客户端总是请求相同的对等点？

689
00:21:48,130 --> 00:21:50,530
0,780 780,1230 1230,1590 1590,1710 1710,2400
client always asks the same

690
00:21:50,680 --> 00:21:52,660
0,600 870,1110 1110,1380 1380,1830 1830,1980
peer?| {} No, there might
|不，可能会有一小段时间的网络请愿或断线，

691
00:21:52,660 --> 00:21:53,980
0,120 120,210 210,450 450,750 750,1320
be a little network petition

692
00:21:53,980 --> 00:21:55,390
0,360 360,510 510,990 990,1140 1140,1410
or {} disconnection for a

693
00:21:55,390 --> 00:21:56,560
0,240 240,540 540,630 630,930 930,1170
brief period of time,| so
|所以你实际上不需要和上次一样的人说话，对吧。

694
00:21:56,560 --> 00:21:57,520
0,120 120,510 510,690 690,870 870,960
you don't actually have to

695
00:21:57,520 --> 00:21:58,390
0,180 180,270 270,360 360,570 570,870
talk to the same peer

696
00:21:58,390 --> 00:21:59,440
0,180 180,270 270,510 510,690 720,1050
as the last time, right.|
|

697
00:22:00,070 --> 00:22:01,630
0,330 330,540 540,660 660,840 840,1560
Yeah, so in that case,
是的，所以在这种情况下，它可以与不同的对等体对话，

698
00:22:01,660 --> 00:22:02,950
0,480 480,690 690,930 930,1200 1200,1290
{} it can talk to

699
00:22:02,950 --> 00:22:04,600
0,60 60,390 390,750 750,1200 1200,1650
a different peer,| who and
|谁和那两个人可能会回答0，也就是。

700
00:22:04,600 --> 00:22:06,220
0,240 240,510 510,1080 1080,1500 1500,1620
that pair may respond with

701
00:22:06,220 --> 00:22:08,920
0,570 1710,2280 2280,2430 2430,2580 2580,2700
0, that's.| So, this is
|所以，这是可能的，

702
00:22:08,920 --> 00:22:11,410
0,570 990,1530 1800,2190 2190,2370 2370,2490
possible,| so we're gonna have
|所以我们将不得不采取一些奇怪的行为

703
00:22:11,410 --> 00:22:12,670
0,120 120,270 270,330 330,630 630,1260
to sort of strange behavior|
|

704
00:22:12,670 --> 00:22:14,530
0,180 180,300 300,870 870,1470 1530,1860
in this configuration where you
在此配置中，您可能会看到最近，

705
00:22:14,530 --> 00:22:16,150
0,270 270,630 630,840 840,1470 1500,1620
might see a recent,| you
|你知道，在第一种情况下，我们可能会看到最近的值

706
00:22:16,150 --> 00:22:17,380
0,540 540,690 690,780 780,990 990,1230
know in the first case

707
00:22:17,380 --> 00:22:18,100
0,60 60,300 300,450 450,660 660,720
we might see actually a

708
00:22:18,100 --> 00:22:19,480
0,300 300,840 930,1080 1080,1260 1260,1380
recent value| and then we
|然后我们实际上读到了一些回到过去的东西。

709
00:22:19,480 --> 00:22:20,890
0,210 210,450 450,750 750,960 960,1410
read actually something from back

710
00:22:20,920 --> 00:22:22,440
0,630 630,690 690,1110
back in time.|
|

711
00:22:28,090 --> 00:22:29,180
0,810
Yep.|
是啊。|

712
00:22:30,080 --> 00:22:32,030
0,240 240,540 540,720 720,1200 1200,1950
So we're doing nothing special,|
所以我们没做什么特别的事，|

713
00:22:32,180 --> 00:22:34,130
0,510 510,930 930,1200 1200,1380 1380,1950
{} and just like naively
就像天真地从任何同行那里读到的一样，

714
00:22:34,130 --> 00:22:35,750
0,240 240,390 390,750 750,1380 1380,1620
read from any peer,| and
|你知道我们有两种不同类型的问题

715
00:22:35,750 --> 00:22:36,440
0,90 90,270 270,420 420,540 540,690
you know we have sort

716
00:22:36,440 --> 00:22:37,610
0,60 60,240 240,480 480,660 660,1170
of two side {types,of} problems|
|

717
00:22:37,610 --> 00:22:38,660
0,270 270,420 420,600 600,750 750,1050
{I,mean} the get can return
我的意思是GET可以返回过时的数据，

718
00:22:38,660 --> 00:22:41,570
0,270 270,1380 1800,2040 2040,2520 2610,2910
stale data,| {} the get
|您已及时返回的获取返回数据。

719
00:22:41,570 --> 00:22:43,160
0,660 660,930 930,1170 1170,1320 1320,1590
return data you've gone back

720
00:22:43,160 --> 00:22:44,080
0,60 60,390
in time.|
|

721
00:22:44,840 --> 00:22:46,140
0,210 210,750
And so.|
所以。|

722
00:22:46,290 --> 00:22:48,480
0,540 900,1290 1290,1440 1440,1830 1830,2190
Sorry, wasn't this possible also
抱歉，这不是也可以有3个粉丝吗，

723
00:22:48,480 --> 00:22:50,370
0,210 210,540 540,1410 1410,1770 1770,1890
with 3 followers,| because the
|因为大多数人是领导者和一个追随者

724
00:22:50,370 --> 00:22:51,600
0,510 510,690 690,840 840,1140 1140,1230
majority was the leader and

725
00:22:51,600 --> 00:22:52,770
0,240 240,780 780,900 900,990 990,1170
one follower| and you could
|你可以问另一个人。

726
00:22:52,770 --> 00:22:54,380
0,300 300,420 420,600 600,1050
ask the other one.|
|

727
00:22:55,520 --> 00:22:56,870
0,210 210,450 450,810 810,870 870,1350
If you've seen the one
如果你见过里面的那个，

728
00:22:56,870 --> 00:22:59,180
0,360 360,1320 1650,2070 2070,2190 2190,2310
in,| {} yes, it could
|是的，这绝对是有可能的，

729
00:22:59,180 --> 00:23:01,100
0,90 90,570 690,1470 1530,1680 1680,1920
be possible, absolutely,| the three
|这三个也是可能的，

730
00:23:01,100 --> 00:23:02,150
0,120 120,240 240,570 570,780 900,1050
will be possible too, {}|
|

731
00:23:02,150 --> 00:23:02,960
0,120 120,300 300,360 360,600 600,810
I think the five is
我认为五国要清楚得多，这是可能的。

732
00:23:02,960 --> 00:23:03,890
0,210 210,330 330,630 630,780 780,930
much more clear, that this

733
00:23:03,890 --> 00:23:05,320
0,120 120,600
is possible.|
|

734
00:23:06,500 --> 00:23:07,600
0,540

735
00:23:09,520 --> 00:23:11,180
0,450 480,1050
Okay so.|
那好吧。|

736
00:23:11,420 --> 00:23:12,660
0,690

737
00:23:12,660 --> 00:23:13,410
0,210 210,420 420,540 540,690 690,750
So, now we're going to
所以，现在我们要回到过去，稍微考虑一下这种行为，

738
00:23:13,410 --> 00:23:14,310
0,120 120,570 570,660 660,840 840,900
go back and sort of

739
00:23:14,310 --> 00:23:15,210
0,240 240,450 450,480 480,690 690,900
think about a little bit

740
00:23:15,210 --> 00:23:16,590
0,210 210,390 390,930 1050,1230 1230,1380
of this behavior,| you know
|你知道返回那些值，可以吗？

741
00:23:16,590 --> 00:23:18,690
0,360 360,870 870,1080 1080,1830 1890,2100
the returning those values, is

742
00:23:18,690 --> 00:23:20,020
0,180 180,810
that okay?|
|

743
00:23:20,170 --> 00:23:21,400
0,510 510,780 780,930 930,1080 1080,1230
And this is a very
这是一个非常有趣的问题，

744
00:23:21,400 --> 00:23:22,900
0,270 270,900 930,1110 1110,1170 1170,1500
interesting question,| and it depends
|当然，这取决于你说的正确是什么意思。

745
00:23:22,900 --> 00:23:23,680
0,120 120,510 510,660 660,720 720,780
of course, what do you

746
00:23:23,680 --> 00:23:25,300
0,300 300,450 450,1140
mean with correct.|
|

747
00:23:25,740 --> 00:23:27,330
0,450 450,810 810,1410 1410,1470 1470,1590
{} And what you know,
而你所知道的，如果某件事是正常的，取决于我们的正确定义是什么。

748
00:23:27,330 --> 00:23:28,860
0,450 450,780 780,1050 1050,1380 1380,1530
if something's okay depends on

749
00:23:28,860 --> 00:23:30,330
0,180 180,300 300,690 690,1170 1170,1470
what our correct definition is.|
|

750
00:23:31,050 --> 00:23:32,700
0,360 360,600 600,990 990,1530 1530,1650
And the correctness definition that
而我们应该在最后几节课上兜售的正确性定义反映了学期初的情况，

751
00:23:32,700 --> 00:23:33,990
0,90 90,210 210,300 300,540 540,1290
we should have been peddling

752
00:23:33,990 --> 00:23:35,280
0,120 120,180 180,510 630,870 870,1290
for the last couple lectures

753
00:23:35,280 --> 00:23:37,230
0,480 480,750 750,810 810,1410 1620,1950
reflections beginning of term, {}|
|

754
00:23:37,230 --> 00:23:38,580
0,120 120,300 300,690 690,930 960,1350
is this notion of {linearizability
就是这种线性化的概念。

755
00:23:38,580 --> 00:23:40,140
0,720
-}.|
|

756
00:23:45,760 --> 00:23:47,740
0,660 720,1140 1140,1440 1440,1860 1860,1980
And, {} in roughly what
大体上来说，这意味着什么。

757
00:23:47,740 --> 00:23:49,080
0,150 150,870
that means.|
|

758
00:23:49,110 --> 00:23:50,460
0,270 270,780 840,1110 1110,1170 1170,1350
{} I talked a little
一周前我谈过这件事，

759
00:23:50,460 --> 00:23:51,690
0,150 150,390 390,510 510,660 660,1230
bit about it in a

760
00:23:51,930 --> 00:23:53,550
0,180 180,660 750,1050 1050,1440 1440,1620
week ago,| {you,know} behaves like
|你知道，它就像一台机器，

761
00:23:53,550 --> 00:23:55,500
0,510 510,780 780,1230
a single machine,|
|

762
00:23:57,460 --> 00:23:58,690
0,300 300,420 420,900 900,1050 1050,1230
that's the intuition that we've
这是我们从学期开始就一直使用的直觉，

763
00:23:58,690 --> 00:24:00,880
0,390 420,1050 1560,1860 1860,1920 1920,2190
been using since the beginning

764
00:24:00,880 --> 00:24:03,610
0,90 90,180 180,870 2040,2670 2670,2730
of the semester,| but you
|但你知道线性化的定义要更精确一点

765
00:24:03,610 --> 00:24:04,750
0,150 150,240 240,690 690,870 870,1140
know the definition of {linearizability

766
00:24:04,750 --> 00:24:05,740
0,540 540,600 600,690 690,840 840,990
-} is a little bit

767
00:24:05,740 --> 00:24:07,990
0,300 300,1050 1260,1830 1830,2130 2130,2250
more precise| {} sort of
|某种程度上，试图确定像一台机器一样运作意味着什么，

768
00:24:07,990 --> 00:24:09,160
0,360 360,480 480,690 690,1020 1020,1170
tries to nail down what

769
00:24:09,160 --> 00:24:10,180
0,120 120,450 450,540 540,840 840,1020
it means to behave like

770
00:24:10,180 --> 00:24:11,560
0,30 30,360 360,780 810,1020 1020,1380
a single machine,| and so
|因此，当某件事表现得像一台机器时，

771
00:24:11,740 --> 00:24:12,670
0,180 180,420 420,750 750,870 870,930
when something behaves like a

772
00:24:12,670 --> 00:24:14,140
0,240 240,810 810,990 990,1110 1110,1470
single machine,| first of all,
|首先，必须是这样的情况，即使操作实际上同时进行，

773
00:24:14,140 --> 00:24:14,800
0,210 210,420 420,480 480,570 570,660
it has to be the

774
00:24:14,800 --> 00:24:15,910
0,330 330,630 630,870 870,990 990,1110
case that even if the

775
00:24:15,910 --> 00:24:17,740
0,420 420,780 780,1440 1470,1680 1680,1830
operation actually concurrently,| you can
|您可以按总顺序对它们进行排序。

776
00:24:17,740 --> 00:24:18,700
0,210 210,330 330,630 630,900 900,960
sort of order them in

777
00:24:18,700 --> 00:24:19,860
0,60 60,330 330,810
a total order.|
|

778
00:24:20,300 --> 00:24:21,440
0,240 240,330 330,690 690,780 780,1140
So it's possible to construct
因此，可以构建所有操作的总顺序，

779
00:24:21,440 --> 00:24:24,110
0,30 30,330 330,990 2340,2520 2520,2670
a total order of all

780
00:24:24,110 --> 00:24:25,850
0,90 90,900 1140,1530 1530,1650 1650,1740
the operations,| because in the
|因为归根结底，这是一台单一的机器，

781
00:24:25,850 --> 00:24:26,900
0,150 150,270 270,360 360,600 600,1050
end, it's a single machine,|
|

782
00:24:26,900 --> 00:24:28,340
0,420 450,840 840,1260 1260,1350 1350,1440
so it behaves as a
因此，它的行为就像一台机器，

783
00:24:28,340 --> 00:24:29,630
0,210 210,540 540,690 690,930 930,1290
single machine,| there's only one
|只有一台机器，

784
00:24:29,630 --> 00:24:30,950
0,480 510,600 600,960 960,1230 1230,1320
machine,| so virtual machine that
|因此，可以实际执行操作的虚拟机

785
00:24:30,950 --> 00:24:33,620
0,90 90,540 1650,2040 2040,2130 2130,2670
can actually perform the operations|
|

786
00:24:33,620 --> 00:24:36,380
0,150 150,780 1350,1890 1920,2160 2160,2760
or total order of apps|
或应用程序的总订单|

787
00:24:37,370 --> 00:24:38,180
0,390 390,480 480,660 660,720 720,810
and there has to be
关于这个总的顺序，一定有一些属性是真的。

788
00:24:38,180 --> 00:24:40,250
0,360 390,900 900,1620 1650,1950 1950,2070
some properties true about that

789
00:24:40,250 --> 00:24:41,340
0,270 270,720
total order.|
|

790
00:24:41,700 --> 00:24:43,440
0,270 270,690 750,1260 1260,1620 1620,1740
And so one property that
因此，一个必须为真的属性是

791
00:24:43,440 --> 00:24:44,460
0,210 210,270 270,390 390,690 690,1020
has to be true is|
|

792
00:24:44,460 --> 00:24:46,320
0,330 330,420 420,720 720,1290 1290,1860
that the order matches real-time.|
订单是否与实时匹配。|

793
00:24:51,950 --> 00:24:53,030
0,180 180,240 240,630 630,870 870,1080
And the {real-time -} really
而实时我真正想说的是

794
00:24:53,030 --> 00:24:54,140
0,180 180,240 240,570 570,750 750,1110
what I mean is that|
|

795
00:24:54,140 --> 00:24:56,240
0,180 180,690 690,1380 1410,1890 1890,2100
even operation completed before another
即使在另一个手术开始之前就完成了手术，

796
00:24:56,240 --> 00:24:57,700
0,210 210,900
one started,|
|

797
00:24:58,930 --> 00:25:00,790
0,690 690,930 930,1110 1110,1350 1350,1860
then, now that first operation
然后，现在第一个手术必须进行了，

798
00:25:00,790 --> 00:25:02,410
0,180 180,270 270,810 810,1110 1110,1620
has to go,| {} before
|在第二次操作前放入总顺序。

799
00:25:02,410 --> 00:25:03,760
0,60 60,390 390,900 900,1050 1050,1350
the second operation into total

800
00:25:03,760 --> 00:25:04,620
0,330
order.|
|

801
00:25:05,870 --> 00:25:07,100
0,120 120,240 240,360 360,660 660,1230
And then there's third property,
然后是第三个属性，即读取操作，

802
00:25:07,900 --> 00:25:09,660
0,330 330,540 540,1140
{} that read

803
00:25:09,810 --> 00:25:13,540
0,990 1590,1860 1860,2220 2220,2850
operation,| read op returns
|READ OP返回上次写入的值。

804
00:25:15,080 --> 00:25:16,860
0,420 420,510 510,840 840,1230
value of last write.|
|

805
00:25:23,620 --> 00:25:24,700
0,270 270,450 450,510 510,600 600,1080
That's sort of the official
这是线性化的官方定义

806
00:25:24,700 --> 00:25:26,140
0,450 450,540 540,720 720,930 930,1440
definition of {linearizability - -}|
|

807
00:25:26,140 --> 00:25:26,770
0,120 120,210 210,300 300,480 480,630
and you can just think
你可以认为这是一种更精确的定义，更准确的表述，

808
00:25:26,770 --> 00:25:27,640
0,240 240,450 450,570 570,750 750,870
about this as sort of

809
00:25:27,640 --> 00:25:30,040
0,180 180,480 480,1440 1440,1800 1860,2400
{} more precise definition more

810
00:25:30,040 --> 00:25:32,020
0,360 360,990 990,1260 1260,1740 1740,1980
precise statement,| this first thing
|这首先是一种直觉，也就是整个事物的行为就像一台机器一样。

811
00:25:32,020 --> 00:25:34,090
0,150 150,780 900,1680 1710,1890 1890,2070
this intuition, namely the whole

812
00:25:34,090 --> 00:25:35,050
0,180 180,510 510,660 660,720 720,960
thing behaves like a single

813
00:25:35,050 --> 00:25:35,940
0,420
machine.|
|

814
00:25:37,370 --> 00:25:37,970
0,240 240,300 300,450 450,510 510,600
Now we want to go
现在我们想回到过去

815
00:25:37,970 --> 00:25:39,890
0,600 720,1440 1440,1620 1620,1860 1860,1920
back| and {you,know} think a
|你知道，想一想我们在白板上看到的情景，

816
00:25:39,890 --> 00:25:42,140
0,210 210,360 360,870 900,1650 1710,2250
little bit about {} scenario

817
00:25:42,140 --> 00:25:43,280
0,120 120,270 270,510 510,870 870,1140
that we either have just

818
00:25:43,280 --> 00:25:45,320
0,630 630,750 750,1320 1350,1830 1830,2040
on this whiteboard,| mainly these
|主要是这两种情况下的陈旧数据和时间倒流，

819
00:25:45,320 --> 00:25:46,730
0,150 150,660 660,750 750,1080 1080,1410
two cases of stale data

820
00:25:46,730 --> 00:25:48,170
0,330 330,540 540,630 630,1140 1350,1440
and back in time,| and
|想想看，线性化是否允许它们。

821
00:25:48,170 --> 00:25:50,120
0,210 210,480 480,960 990,1530 1530,1950
think about that think whether

822
00:25:50,120 --> 00:25:52,180
0,540 540,1020 1020,1470
{linearizability -} allows

823
00:25:52,800 --> 00:25:55,140
0,390 600,990 990,1140 1140,1860 1980,2340
them.| And so let's first
|所以让我们首先关注第一个问题，

824
00:25:55,140 --> 00:25:56,250
0,270 270,330 330,420 420,720 720,1110
focus on the first one,|
|

825
00:25:56,430 --> 00:25:57,210
0,210 210,330 330,420 420,480 480,780
so we have a client
所以我们有一个正确的客户，

826
00:25:57,210 --> 00:25:58,530
0,300 300,660 660,870 870,1200 1200,1320
one correct,| for this the
|对于这个，你会用这种方式把它拉出来

827
00:25:58,530 --> 00:26:00,030
0,300 300,420 420,630 840,1290 1290,1500
way you would draw this

828
00:26:00,030 --> 00:26:01,860
0,420 420,600 600,990 990,1230 1230,1830
out| and reasonable {linearizability -}
|合理的线性化是

829
00:26:01,860 --> 00:26:02,820
0,240 240,480 480,630 630,870 870,960
is| you could draw a
|你可以画一张这张图，

830
00:26:02,820 --> 00:26:04,770
0,390 390,510 510,690 690,1200 1530,1950
diagram for this one,| we're
|我们要去左边的酒吧是行动的开始，

831
00:26:04,770 --> 00:26:06,000
0,120 120,180 180,480 570,900 900,1230
going to the left bar

832
00:26:06,000 --> 00:26:06,750
0,150 150,240 240,540 540,630 630,750
is the start of the

833
00:26:06,750 --> 00:26:08,010
0,540 540,630 630,870 870,1110 1110,1260
operation,| the right bar is
|右边的栏是对客户的确认，

834
00:26:08,010 --> 00:26:09,900
0,810 1020,1140 1140,1230 1230,1740 1740,1890
acknowledgement to the client,| but
|但实际执行的操作

835
00:26:09,900 --> 00:26:11,910
0,90 90,480 480,750 750,1350 1740,2010
the operation actually executed| and
|在这种情况下，你知道我们开始说的是把x放到x上，然后输出值为1。

836
00:26:11,910 --> 00:26:12,600
0,60 60,210 210,510 510,570 570,690
in this case, you know

837
00:26:12,600 --> 00:26:13,980
0,120 120,360 360,930 960,1290 1290,1380
we started saying were to

838
00:26:13,980 --> 00:26:16,290
0,510 660,1080 1080,1380 1380,1920 1950,2310
put {} to x and

839
00:26:16,290 --> 00:26:17,370
0,270 270,330 330,690 690,750 750,1080
output the value of 1.|
|

840
00:26:18,170 --> 00:26:19,760
0,450 450,570 570,720 720,960 960,1590
Then we had another client
然后我们有了另一个客户，或者在同一个客户中，

841
00:26:20,180 --> 00:26:21,560
0,360 360,480 480,600 600,870 870,1380
or in the same client,|
|

842
00:26:22,040 --> 00:26:23,690
0,390 390,570 570,930 930,1140 1140,1650
let's do drawing other clients,|
我们来画其他客户吧，|

843
00:26:23,690 --> 00:26:24,560
0,90 90,240 240,630 630,780 780,870
you know basically did the
你知道，基本上是读完了

844
00:26:24,560 --> 00:26:26,300
0,450 480,780 780,900 900,1170 1170,1740
read| and the read started
|读操作在PUT操作之后很久才开始

845
00:26:26,330 --> 00:26:30,080
0,900 990,1710 2010,2880 2910,3270 3270,3750
well past the put operations|
|

846
00:26:30,080 --> 00:26:31,700
0,360 360,450 450,840 870,1080 1080,1620
there's a get of x.|
有一个x的取值。|

847
00:26:32,220 --> 00:26:33,720
0,660 870,990 990,1170 1170,1320 1320,1500
And, {} we had one
而且，我们有一个例子，加起来实际上回到了0，

848
00:26:33,720 --> 00:26:35,130
0,300 300,630 630,960 960,1170 1170,1410
case where together that's actually

849
00:26:35,130 --> 00:26:36,330
0,300 300,360 360,750 780,1050 1050,1200
returned to 0,| that was
|这是第一种可能性。

850
00:26:36,330 --> 00:26:39,820
0,300 300,690 690,1710
the first possibility.|
|

851
00:26:39,820 --> 00:26:41,410
0,630 930,1110 1110,1230 1230,1410 1410,1590
And, {} so that's what
这就是上一届董事会实际发生的事情

852
00:26:41,410 --> 00:26:42,790
0,300 300,720 750,900 900,990 990,1380
actually happened on the previous

853
00:26:42,790 --> 00:26:43,720
0,390 390,510 510,690 690,780 780,930
board| and now we want
|现在我们想考虑一下，这种执行是由线性化允许的吗，

854
00:26:43,720 --> 00:26:44,890
0,300 300,480 480,720 720,900 900,1170
to think about this, is

855
00:26:44,890 --> 00:26:47,140
0,450 450,1110 1110,1710 1740,1950 1950,2250
this execution allowed by {linearizability

856
00:26:47,140 --> 00:26:49,120
0,510 600,960 960,1080 1080,1470 1500,1980
-},| this is the correct
|这就是我们正在寻找的正确定义，

857
00:26:49,120 --> 00:26:50,560
0,450 450,570 570,660 660,930 930,1440
definition that we're looking for,|
|

858
00:26:50,680 --> 00:26:51,400
0,210 210,300 300,420 420,510 510,720
then we want to see
然后我们想看这场处决，

859
00:26:51,400 --> 00:26:54,010
0,270 270,810 840,1770 1770,2190 2190,2610
this {} execution,| this order
|在实践中发生的这种操作顺序，

860
00:26:54,010 --> 00:26:55,870
0,90 90,960 1230,1470 1470,1770 1770,1860
of operations that happened in

861
00:26:55,870 --> 00:26:57,130
0,540 540,660 660,870 870,1050 1050,1260
practice,| you know at least
|你知道，至少我们已经看到这在实践中是可能的，

862
00:26:57,130 --> 00:26:58,180
0,180 180,420 420,540 540,690 690,1050
we've seen that it's possible

863
00:26:58,180 --> 00:26:59,530
0,120 120,510 510,630 630,840 840,1350
in practice,| is this allowed
|这是线性化所允许的吗，这是我们的正确性标准。

864
00:26:59,530 --> 00:27:00,580
0,120 120,360 360,510 510,900 900,1050
by {linearizability - -} that

865
00:27:00,580 --> 00:27:02,140
0,90 90,240 240,630 630,1200
is our correctness criteria.|
|

866
00:27:03,360 --> 00:27:04,530
0,480 630,840 840,960 960,1020 1020,1170
{} This is a lot
这是不是很像可线性化？

867
00:27:04,530 --> 00:27:05,700
0,60 60,570
of like

868
00:27:05,760 --> 00:27:07,200
0,420 420,840
{linearizability -}?|
|

869
00:27:11,980 --> 00:27:14,980
0,390 900,1410 1440,1830 1830,2280 2640,3000
No.| No, why not?| Well,
不是的。|不，有何不可？|那么因为c2文件操作是在c1完成之后才开始的，

870
00:27:14,980 --> 00:27:17,680
0,540 540,990 990,1500 1530,1920 1920,2700
because the c2 file operation

871
00:27:17,800 --> 00:27:20,170
0,390 390,840 840,1080 1080,1770 1890,2370
started after the c1 completed,|
|

872
00:27:20,170 --> 00:27:21,550
0,180 180,300 300,360 360,810 990,1380
so in the total order
所以在总的顺序中，你必须把x1

873
00:27:21,550 --> 00:27:23,050
0,240 240,480 480,1080 1110,1320 1320,1500
you have to put x

874
00:27:23,050 --> 00:27:24,460
0,270 270,420 420,690 930,1290 1290,1410
1| and get x has
|得到的x必须是1，

875
00:27:24,460 --> 00:27:25,780
0,390 390,690 690,1020 1020,1140 1140,1320
{to,be} 1,| because it should
|因为它应该读取最后一次写入。

876
00:27:25,780 --> 00:27:26,980
0,210 210,300 300,600 600,750
read the last write.|
|

877
00:27:27,070 --> 00:27:28,510
0,450 480,720 720,1110 1110,1200 1200,1440
Yeah, so basically {in,the} total
是的，所以基本上按照总的顺序，

878
00:27:28,510 --> 00:27:30,040
0,210 210,360 360,450 450,1020 1380,1530
order,| that you construct you
|你知道，你知道，这个人，你知道，这次行动一定是在那次行动之后。

879
00:27:30,040 --> 00:27:31,060
0,120 120,360 360,810 810,930 930,1020
know this guy you know

880
00:27:31,060 --> 00:27:32,740
0,210 210,780 780,1170 1170,1350 1350,1680
this operation must be after

881
00:27:32,740 --> 00:27:34,220
0,240 240,930
that operation.|
|

882
00:27:34,340 --> 00:27:36,120
0,240 240,330 330,690 690,1230
Because it started later.|
因为它开始得比较晚。|

883
00:27:36,150 --> 00:27:37,470
0,150 150,570 570,840 840,1200 1230,1320
But then you look you
但你看起来，你知道违反了第三条规则是正确的。

884
00:27:37,470 --> 00:27:38,730
0,120 120,300 300,780 780,1050 1050,1260
know that violated rule number

885
00:27:38,730 --> 00:27:40,220
0,420 450,930
3 correct.|
|

886
00:27:40,220 --> 00:27:41,540
0,180 180,300 300,840 840,1230 1230,1320
That {} operation returns the
该操作返回最后一次写入的值，

887
00:27:41,540 --> 00:27:42,500
0,300 300,360 360,450 450,720 720,960
value of the last write,|
|

888
00:27:42,500 --> 00:27:43,520
0,150 150,360 360,540 540,600 600,1020
that's actually not the case
实际上并不是这样，实际上返回的是新的早先的值，

889
00:27:43,520 --> 00:27:45,560
0,450 450,810 810,990 990,1590 1620,2040
actually returns new earlier value,|
|

890
00:27:45,590 --> 00:27:47,000
0,180 180,330 330,420 420,720 720,1410
so this is not linearizable.|
所以这是不可线性化的。|

891
00:27:49,790 --> 00:27:51,140
0,120 120,240 240,390 390,840
Does that make sense?|
这说得通吗？|

892
00:27:53,060 --> 00:27:53,960
0,120 120,180 180,420 420,540 540,900
And of course it's totally
当然，这完全符合我们的直觉，对吧，

893
00:27:53,960 --> 00:27:55,670
0,360 360,450 450,960 990,1230 1230,1710
matches our intuition, right,| because
|因为任何一台机器都不可能发生，

894
00:27:55,670 --> 00:27:56,840
0,360 360,630 630,930 930,1050 1050,1170
a single machine just could

895
00:27:56,840 --> 00:27:57,830
0,150 150,270 270,660 720,870 870,990
not have happened,| you know
|你知道你给一台机器写了一个值，

896
00:27:57,830 --> 00:27:59,420
0,150 150,330 330,390 390,870 870,1590
you wrote a value to

897
00:27:59,450 --> 00:28:00,350
0,90 90,360 360,690 690,780 780,900
a single machine,| and then
|然后你再读一遍

898
00:28:00,350 --> 00:28:01,580
0,120 120,270 270,360 360,780 1050,1230
you read it back| and
|而且它肯定不是其他价值，

899
00:28:01,580 --> 00:28:02,780
0,120 120,510 510,750 750,1110 1110,1200
it's certainly {not,other} value,| it's
|它实际上是先前的值，

900
00:28:02,780 --> 00:28:03,830
0,210 210,270 270,600 600,930 930,1050
actually the previous value,| so
|所以并不是很多。

901
00:28:03,830 --> 00:28:05,100
0,180 180,360 360,420 420,780
there's not a lot.|
|

902
00:28:06,220 --> 00:28:07,060
0,210 210,420 420,510 510,600 600,840
Okay, let's do a second
好的，让我们再来一次，

903
00:28:07,060 --> 00:28:08,590
0,270 270,480 480,630 630,900 900,1530
one,| like our other examples,|
|就像我们的其他例子一样，|

904
00:28:08,590 --> 00:28:09,400
0,120 120,240 240,390 390,450 450,810
so we had a client
所以我们又有了一个客户，

905
00:28:09,400 --> 00:28:11,780
0,450 480,960 990,1350 1350,1860
one again,| just put,
|只是把，画得更紧凑一点，

906
00:28:12,120 --> 00:28:13,830
0,630 630,720 720,870 870,1170 1170,1710
draw a little bit more

907
00:28:13,950 --> 00:28:15,210
0,570 570,900 900,990 990,1140 1140,1260
compact,| because I don't have
|因为我没有太多的空间。

908
00:28:15,210 --> 00:28:16,620
0,180 180,750
much space.|
|

909
00:28:16,620 --> 00:28:17,970
0,720 720,780 780,930 930,1050 1050,1350
And you know we do
你知道我们会做推杆，

910
00:28:17,970 --> 00:28:19,890
0,270 300,720 720,1230 1230,1380 1380,1920
a put,| then we do,
|然后我们做了，这就是你得到的读物，

911
00:28:20,580 --> 00:28:22,050
0,270 270,390 390,900 1050,1380 1380,1470
there's the read where you

912
00:28:22,050 --> 00:28:23,200
0,690
get,|
|

913
00:28:23,320 --> 00:28:24,640
0,300 300,360 360,570 570,840 840,1320
get the [] turns 1,
得到[]转数1，所以我们不是在第一种情况下，

914
00:28:24,700 --> 00:28:26,020
0,540 750,930 930,1140 1140,1230 1230,1320
so we're not in the

915
00:28:26,020 --> 00:28:27,130
0,270 270,600 600,960 960,1050 1050,1110
first case,| but in the
|但在第二个，但在另一个案例中，

916
00:28:27,130 --> 00:28:29,080
0,330 330,720 720,1020 1020,1560 1800,1950
second, but another case,| and
|然后，我们必须得到0的回报。

917
00:28:29,080 --> 00:28:30,790
0,600 1020,1380 1380,1530 1530,1620 1620,1710
then, {} we have to

918
00:28:30,790 --> 00:28:33,280
0,390 390,990 1020,1560 1560,2010
get that returns 0.|
|

919
00:28:35,860 --> 00:28:37,630
0,180 180,270 270,480 480,990 1320,1770
And so that's the second
这是我们看到的第二种情况，对吗，

920
00:28:37,630 --> 00:28:38,710
0,210 210,450 480,660 660,930 930,1080
sort of {} case that

921
00:28:38,710 --> 00:28:40,570
0,90 90,330 330,540 540,840 840,1860
we looked at, correct,| {this,picture}
|这张照片，你知道时间倒流的情况。

922
00:28:40,570 --> 00:28:41,950
0,210 210,360 360,690 690,1020 1020,1380
you know the {back,in} time

923
00:28:42,340 --> 00:28:43,360
0,540
case.|
|

924
00:28:43,580 --> 00:28:44,390
0,150 150,390 390,480 480,600 600,810
And again we can ask
我们再一次问自己同样的问题，

925
00:28:44,390 --> 00:28:46,060
0,300 300,360 360,570 570,1080
ourselves the same question,|
|

926
00:28:46,350 --> 00:28:48,540
0,240 240,330 330,1110 1410,1920 1920,2190
is it allowed by {linearizability
它是否被线性化所允许。

927
00:28:48,540 --> 00:28:49,740
0,150 150,630
- -}.|
|

928
00:28:53,350 --> 00:28:56,110
0,720 720,1290 1290,1440 1440,1860 2280,2760
No, because they read wouldn't
不是，因为它们读取的不是最后一次写入的返回值。

929
00:28:56,110 --> 00:28:58,750
0,150 150,630 630,990 1650,2190 2190,2640
be {return,the,value} the last write.|
|

930
00:28:58,780 --> 00:29:01,270
0,510 510,660 660,1140 1320,2010 2010,2490
Yeah, its pretty straightforward observation
是的，这是相当直截了当的观察正确，

931
00:29:01,270 --> 00:29:02,590
0,450 450,630 630,720 720,1140 1140,1320
correct,| this is absolutely not
|情况绝对不是这样的，

932
00:29:02,590 --> 00:29:03,340
0,60 60,360 360,420 420,660 660,750
the case,| in fact it's
|事实上，在第一个案例中几乎是相似的，

933
00:29:03,340 --> 00:29:04,390
0,270 270,660 660,720 720,810 810,1050
almost similar in the first

934
00:29:04,390 --> 00:29:05,800
0,240 240,480 480,990 1110,1170 1170,1410
case,| because even though these
|因为即使这些操作必须按这个顺序进行，

935
00:29:05,800 --> 00:29:06,700
0,450 450,630 630,720 720,810 810,900
operations have to be in

936
00:29:06,700 --> 00:29:09,070
0,180 180,840 1080,1980 1980,2070 2070,2370
this order,| but you know
|但你知道你不可能发生的，

937
00:29:09,070 --> 00:29:10,480
0,210 270,900 900,1140 1140,1290 1290,1410
that you could not have

938
00:29:10,480 --> 00:29:11,890
0,360 360,570 570,660 660,810 810,1410
happened,| but it would violate
|但这违反了规则3，对吧。

939
00:29:11,920 --> 00:29:14,280
0,840 840,1140 1470,1950
rule 3, right.|
|

940
00:29:16,120 --> 00:29:18,100
0,810 1020,1530 1530,1620 1620,1740 1740,1980
Okay, so you know this
好的，你知道这给了你一种直觉，就像线性化意味着，

941
00:29:18,100 --> 00:29:19,360
0,180 180,330 330,420 420,990 990,1260
gives you an intuition like

942
00:29:19,360 --> 00:29:20,950
0,330 330,390 390,840 840,1290 1290,1590
{linearizability - -} means,| how
|你是如何推理的？

943
00:29:20,950 --> 00:29:22,270
0,150 150,420 420,720 720,930 930,1320
you reason about it| and
|基本上，如果我们不做任何特别的事情，

944
00:29:22,270 --> 00:29:24,100
0,690 840,1350 1350,1560 1560,1650 1650,1830
basically, {} if we don't

945
00:29:24,100 --> 00:29:26,140
0,90 90,390 390,1020 1200,1920 1920,2040
do anything special,| {} and
|我们做了这个天真的计划，

946
00:29:26,140 --> 00:29:27,520
0,120 120,210 210,450 450,780 780,1380
we do this naive scheme,|
|

947
00:29:27,640 --> 00:29:28,900
0,360 360,510 510,660 660,810 810,1260
{} if you were implementing
如果您正在实施实验3

948
00:29:28,900 --> 00:29:30,580
0,360 360,750 750,1080 1080,1350 1350,1680
lab 3| and you followed
|你遵循了这个天真的计划，

949
00:29:30,580 --> 00:29:33,010
0,150 150,450 450,1020 1230,1800 1800,2430
this naive scheme,| then {}
|那么你就不会通过测试，

950
00:29:33,010 --> 00:29:33,700
0,120 120,210 210,390 390,600 600,690
you would not pass the

951
00:29:33,700 --> 00:29:34,960
0,390 390,750 750,840 840,1110 1110,1260
test,| because you know the
|因为你知道，实验3中的测试假设或目标实际上是提供放置GET的线性化。

952
00:29:34,960 --> 00:29:37,090
0,270 270,930 960,1350 1380,1620 1620,2130
test assume or the goal

953
00:29:37,090 --> 00:29:37,930
0,240 240,390 390,510 510,780 780,840
{in,lab} 3 is actually to

954
00:29:37,930 --> 00:29:39,250
0,450 450,690 690,840 840,1200 1200,1320
provide {linearizability - -} for

955
00:29:39,250 --> 00:29:40,320
0,240 240,750
putting gets.|
|

956
00:29:40,320 --> 00:29:41,250
0,150 150,270 270,360 360,780 780,930
And so the scenarios like
所以像这样的场景是不允许的

957
00:29:41,250 --> 00:29:42,660
0,240 240,720 750,1020 1020,1200 1200,1410
these ones are just not

958
00:29:42,660 --> 00:29:44,100
0,360 390,450 450,570 570,840 840,1440
allowed| you know your implementation
|您知道，您的实现必须以一种不会出现这些结果的方式进行。

959
00:29:44,100 --> 00:29:45,690
0,270 270,360 360,810 930,1500 1500,1590
has to be a in

960
00:29:45,690 --> 00:29:47,850
0,90 90,420 420,1230 1230,1590 1590,2160
a way that these results

961
00:29:47,850 --> 00:29:49,100
0,300 300,750
cannot appear.|
|

962
00:29:50,400 --> 00:29:51,700
0,180 180,330 330,750
{Does,that} make sense?|
这说得通吗？|

963
00:29:53,150 --> 00:29:54,260
0,180 180,270 270,660 660,930 930,1110
So we're going lab 3
所以我们要做实验3是关于线性化的尝试

964
00:29:54,260 --> 00:29:56,960
0,480 570,1320 1350,1920 1950,2460 2460,2700
were a shoot for {linearizability

965
00:29:56,960 --> 00:29:58,640
0,150 150,780 1140,1440 1440,1620 1620,1680
- -}| and what is
|什么是获得线性化的简单方法，

966
00:29:58,640 --> 00:29:59,750
0,240 240,540 540,750 750,840 840,1110
one easy way of getting

967
00:29:59,750 --> 00:30:01,100
0,240 240,390 390,810
{linearizability - -},|
|

968
00:30:02,680 --> 00:30:03,310
0,270 270,330 330,420 420,540 540,630
how are we going to
我们如何确保PUT或GET操作是可线性化的。

969
00:30:03,310 --> 00:30:05,200
0,330 330,450 450,660 660,1140 1170,1890
sure that {puts,or} gets operation

970
00:30:05,200 --> 00:30:06,960
0,480 480,1200
are linearizable.|
|

971
00:30:08,800 --> 00:30:09,430
0,180 180,240 240,420 420,510 510,630
Well, I mean if you
我的意思是，如果你真的用一台机器，

972
00:30:09,430 --> 00:30:10,750
0,210 210,750 750,900 900,1110 1110,1320
do actually we use one

973
00:30:10,750 --> 00:30:12,080
0,780
machine,|
|

974
00:30:12,080 --> 00:30:12,920
0,120 120,210 210,420 420,510 510,840
then it will be {linearizable
那么它就是可线性化的，对吧。

975
00:30:12,920 --> 00:30:14,810
0,270 270,660 690,1080 1410,1710 1710,1890
- -}, right.| Yeah, so
|是的，那么什么是简单的解决方案，

976
00:30:14,810 --> 00:30:16,550
0,210 210,300 300,510 510,1140 1260,1740
what's the easy solution,| we
|我们为领队做了所有的阅读，对吧。

977
00:30:16,550 --> 00:30:17,570
0,360 360,480 480,600 600,930 930,1020
run all the reads you

978
00:30:17,570 --> 00:30:18,710
0,150 150,330 330,420 420,720 750,1140
know for the leader, right.|
|

979
00:30:19,600 --> 00:30:21,700
0,270 270,990 990,1350 1380,1680 1680,2100
So basically the easy solution
所以基本上，获得线性化的简单解决方案

980
00:30:21,700 --> 00:30:22,870
0,120 120,270 270,450 450,630 630,1170
to get {linearizability - -}|
|

981
00:30:22,870 --> 00:30:23,560
0,120 120,180 180,390 390,510 510,690
and in fact that's what
事实上，这就是我们在实验室3中要做的事情，

982
00:30:23,560 --> 00:30:24,250
0,90 90,240 240,330 330,600 600,690
we're gonna be doing in

983
00:30:24,250 --> 00:30:25,440
0,240 240,630
lab 3,|
|

984
00:30:25,440 --> 00:30:27,540
0,750 1170,1410 1410,1500 1500,1890 1890,2100
{} right lab 3 were
正确的实验3要做的是

985
00:30:27,540 --> 00:30:29,700
0,120 120,180 180,300 300,840 1260,2160
going to be doing is|
|

986
00:30:31,080 --> 00:30:32,520
0,150 150,600 630,1110 1110,1230 1230,1440
you know read or get
你知道，读取或获取操作获取操作要查看日志，

987
00:30:32,520 --> 00:30:34,080
0,1050
operations

988
00:30:34,430 --> 00:30:35,960
0,450 450,900 930,1230 1230,1440 1440,1530
get ops go through the

989
00:30:35,960 --> 00:30:37,220
0,450
log,|
|

990
00:30:37,400 --> 00:30:38,960
0,180 180,330 330,510 510,750 750,1560
{} they go through raft,|
他们穿过木筏，|

991
00:30:42,470 --> 00:30:43,790
0,330 330,450 450,630 630,1050 1050,1320
and as you observe,| it
正如你所观察到的，|似乎你知道如果他们真的通过一台机器

992
00:30:43,790 --> 00:30:44,840
0,390 390,480 480,630 630,810 810,1050
seems you know if they

993
00:30:44,840 --> 00:30:46,070
0,330 330,660 660,870 870,1050 1050,1230
really go all through one

994
00:30:46,070 --> 00:30:47,840
0,570 570,810 1230,1350 1350,1530 1530,1770
machine| or they might not
|或者他们可能不会选择一台机器，

995
00:30:47,840 --> 00:30:49,550
0,210 210,420 420,660 660,1140 1350,1710
go for one machine,| leader
|领导者可能会随着时间的推移而改变，

996
00:30:49,550 --> 00:30:51,260
0,150 150,480 480,660 660,1080 1500,1710
may change over time,| when
|当我们知道领袖总是井然有序的时候，

997
00:30:51,260 --> 00:30:52,190
0,90 90,300 300,450 450,540 540,930
we know that the leader

998
00:30:52,190 --> 00:30:53,540
0,90 90,390 390,660 660,1050 1050,1350
is always totally order,| creating
|创建日志是完全有序的

999
00:30:53,540 --> 00:30:54,830
0,90 90,510 510,600 600,870 870,1290
the log is total order|
|

1000
00:30:55,100 --> 00:30:55,700
0,150 150,270 270,390 390,510 510,600
and so we're going to
所以我们将能够构建一个总的顺序

1001
00:30:55,700 --> 00:30:56,840
0,150 150,420 420,510 510,1050 1050,1140
be able to construct you

1002
00:30:56,840 --> 00:30:58,370
0,300 300,750 750,1020 1020,1350 1350,1530
know a total order| that
|实际订单与实时匹配

1003
00:30:58,370 --> 00:30:59,660
0,300 300,900
actually has

1004
00:30:59,690 --> 00:31:01,130
0,210 210,390 390,690 690,1290 1290,1440
the order matches real-time| and
|和较旧的每个返回值都在最后一次写入时返回。

1005
00:31:01,130 --> 00:31:02,450
0,270 270,540 540,870 870,1200 1200,1320
older each return values up

1006
00:31:02,450 --> 00:31:04,340
0,660 660,930 930,1350
the last write.|
|

1007
00:31:04,340 --> 00:31:05,480
0,240 240,390 390,540 540,690 690,1140
Because this is the raft
因为这是RAFT协议将保证

1008
00:31:05,480 --> 00:31:08,510
0,750 960,1380 1380,2130 2130,2730 2730,3030
protocol will guarantee| that all
|日志中的所有条目都是按总顺序排列的，对吧。

1009
00:31:08,510 --> 00:31:10,430
0,540 570,1140 1140,1230 1230,1740 1740,1920
the entries in log are

1010
00:31:10,430 --> 00:31:12,020
0,300 300,360 360,660 660,1110
in a total order,

1011
00:31:12,080 --> 00:31:13,060
0,450
right.|
|

1012
00:31:13,320 --> 00:31:14,220
0,180 180,240 240,540 540,690 690,900
And of course the raft
当然，RAFT协议做了大量的工作

1013
00:31:14,220 --> 00:31:15,150
0,420 420,570 570,780 780,810 810,930
protocol do quite a bit

1014
00:31:15,150 --> 00:31:16,050
0,90 90,390 390,450 450,720 720,900
of work| to actually make
|才能真正实现这一切

1015
00:31:16,050 --> 00:31:18,450
0,120 120,240 240,780 930,1740 1740,2400
that all happen| and despite
|尽管你知道网络故障，

1016
00:31:18,450 --> 00:31:21,180
0,90 90,360 360,1050 1050,2010 2010,2730
you know network failures,| despite
|尽管网络分裂，

1017
00:31:21,180 --> 00:31:24,840
0,690 690,1290 1710,2370 2490,3390 3510,3660
network { -} splits,| you
|你知道RAFT协议会保证我们，

1018
00:31:24,840 --> 00:31:26,460
0,180 180,600 600,1020 1020,1410 1410,1620
know the raft protocol will

1019
00:31:26,460 --> 00:31:28,410
0,540 540,1050 1140,1350 1350,1680 1680,1950
guarantee us,| that basically all
|基本上所有的操作都是按总的顺序进行的。

1020
00:31:28,410 --> 00:31:30,120
0,90 90,750 750,1080 1080,1290 1290,1710
the operations happen in a

1021
00:31:30,120 --> 00:31:31,180
0,240 240,690
total order.|
|

1022
00:31:31,390 --> 00:31:32,680
0,120 120,570 570,660 660,870 870,1290
In fact, the whole replicated
事实上，整个复制状态机方法都是基于这个想法的，对吗，

1023
00:31:32,680 --> 00:31:34,090
0,210 210,480 480,900 900,1050 1050,1410
state machine approaches are based

1024
00:31:34,090 --> 00:31:35,380
0,90 90,240 240,690 690,1080 1080,1290
on this idea, correct,| like
|就像所有拍卖拍卖的总订单一样

1025
00:31:35,380 --> 00:31:36,400
0,120 120,210 210,570 570,930 930,1020
all the auction auction of

1026
00:31:36,400 --> 00:31:37,570
0,150 150,480 480,630 630,1110 1110,1170
the {total,order}| and applied in
|并以相同的顺序应用所有对等体

1027
00:31:37,570 --> 00:31:38,890
0,60 60,390 390,780 780,930 930,1320
the same order all peers|
|

1028
00:31:38,890 --> 00:31:40,360
0,90 90,180 180,240 240,780 960,1470
and as a result everyone
结果，每个人看起来都像一台机器，

1029
00:31:40,360 --> 00:31:42,130
0,150 150,960 990,1320 1350,1710 1710,1770
to a looks like a

1030
00:31:42,130 --> 00:31:44,440
0,240 240,630 1290,1530 1530,2010 2100,2310
single machine,| and so {}
|因此，解决这个问题的简单方法就是通过领导阅读你所知道的所有内容，

1031
00:31:44,440 --> 00:31:45,370
0,150 150,330 330,480 480,660 660,930
the easy way to solve

1032
00:31:45,370 --> 00:31:46,180
0,90 90,390 390,480 480,600 600,810
this problem is to run

1033
00:31:46,180 --> 00:31:47,230
0,180 180,300 300,810 840,960 960,1050
all the reads you know

1034
00:31:47,230 --> 00:31:49,660
0,330 330,1110 1170,2040
through the leader,|
|

1035
00:31:49,720 --> 00:31:50,920
0,570 570,690 690,960 960,1050 1050,1200
wherever the leaders at that
任何地方的领导人在那个特定的时间点

1036
00:31:50,920 --> 00:31:51,850
0,300 300,480 480,540 540,840 840,930
particular point of time| and
|现在我们可以线性化了。

1037
00:31:51,850 --> 00:31:52,540
0,180 180,330 330,510 510,600 600,690
now will give us {linearizability

1038
00:31:52,540 --> 00:31:53,800
0,690
-}.|
|

1039
00:31:57,830 --> 00:31:58,640
0,240 240,450 450,660 660,750 750,810
Let me pause for a
让我暂停一下，有什么问题吗？

1040
00:31:58,640 --> 00:31:59,660
0,210 210,330 330,510 510,840 840,1020
second, {} any questions about

1041
00:31:59,660 --> 00:32:00,600
0,420
this?|
|

1042
00:32:02,210 --> 00:32:03,920
0,210 210,600 600,1080 1080,1620 1620,1710
{} Sorry, matches real-time it
对不起，匹配是实时的这只是意味着如果操作一在操作二开始之前结束？

1043
00:32:03,920 --> 00:32:05,180
0,240 240,420 420,600 600,780 780,1260
just means that if operation

1044
00:32:05,180 --> 00:32:08,060
0,390 450,810 810,1380 1380,1920 1950,2880
one ends before {operation,two} starts?|
|

1045
00:32:08,560 --> 00:32:12,790
0,1380 1680,3180 3600,3660 3660,4170 4170,4230
Yeah, yeah, the raft, you
是的，是的，木筏，你知道你会看到这会自动发生，

1046
00:32:12,790 --> 00:32:13,780
0,360 360,510 510,690 690,870 870,990
know you will see that

1047
00:32:13,780 --> 00:32:15,310
0,180 180,300 300,660 660,1230 1230,1530
this will happen automatically correct,|
|

1048
00:32:15,310 --> 00:32:19,150
0,420 840,1950 2520,3000 3030,3270 3270,3840
because the the if operation
因为IF操作动作完全结束，

1049
00:32:19,150 --> 00:32:20,830
0,270 270,720 720,1200 1200,1350 1350,1680
action completely finished,| that must
|这肯定是领导回复我们的客户的情况

1050
00:32:20,830 --> 00:32:21,610
0,150 150,330 330,390 390,660 660,780
have been the case that

1051
00:32:21,610 --> 00:32:22,900
0,120 120,420 420,1050 1050,1110 1110,1290
the leader responded to go

1052
00:32:22,900 --> 00:32:24,340
0,300 300,660 660,780 780,1320 1320,1440
back to our clients| and
|然后，如果客户端稍后开始操作

1053
00:32:24,340 --> 00:32:25,330
0,150 150,270 270,330 330,630 630,990
then if the client started

1054
00:32:25,330 --> 00:32:27,130
0,390 390,960 1080,1260 1260,1620 1620,1800
operation later| and must end
|最终必须在领先者的日志中结束。

1055
00:32:27,130 --> 00:32:28,120
0,180 180,510 510,600 600,690 690,990
up later in the log

1056
00:32:28,120 --> 00:32:29,040
0,120 120,210 210,510
at the leader.|
|

1057
00:32:30,720 --> 00:32:31,470
0,210 210,510 510,570 570,690 690,750
So this is going to
所以这将是一种实践，这是真的。

1058
00:32:31,470 --> 00:32:32,400
0,90 90,150 150,420 420,540 540,930
be a practice is true.|
|

1059
00:32:33,500 --> 00:32:35,300
0,450 630,1020 1020,1260 1260,1530 1530,1800
And also, {} so just
而且，只要再检查一遍，也许再重申一遍，

1060
00:32:35,300 --> 00:32:36,800
0,180 180,420 420,720 720,1290 1290,1500
double check, maybe reiterate,| so
|因此，在实验3中，所有客户端请求都将是同步的。

1061
00:32:36,800 --> 00:32:37,850
0,240 240,510 510,630 630,870 870,1050
the {} in lab 3

1062
00:32:37,850 --> 00:32:39,140
0,240 240,390 390,510 510,900 900,1290
all of the client requests

1063
00:32:39,140 --> 00:32:40,500
0,150 150,270 270,930
gonna be synchronous,

1064
00:32:40,560 --> 00:32:43,080
0,210 210,420 420,780 1170,1950
or, so.| {Yes,it's} absolute.|
|是的，这是绝对的。|

1065
00:32:44,830 --> 00:32:46,780
0,300 300,660 870,1350 1380,1860 1860,1950
Okay, good,| so, {} you
好的，很好，|所以，你知道这个计划的丹方，

1066
00:32:46,780 --> 00:32:47,770
0,90 90,300 300,630 630,930 930,990
know what Dan side of

1067
00:32:47,770 --> 00:32:49,570
0,180 180,780 780,870 870,1230 1320,1800
this scheme,| you know go
|你知道，如果你非常仔细地阅读木筏纸，实际上可以回到过去，

1068
00:32:49,570 --> 00:32:50,740
0,330 330,660 660,840 840,930 930,1170
back actually if you read

1069
00:32:50,740 --> 00:32:51,940
0,210 210,480 480,660 660,810 810,1200
the raft paper very carefully,|
|

1070
00:32:51,940 --> 00:32:53,200
0,180 180,240 240,900 900,1080 1080,1260
there's an optimization for read
有一个针对只读操作的优化，

1071
00:32:53,200 --> 00:32:55,780
0,270 270,1080 1440,2220 2250,2400 2400,2580
only operations,| {} but even
|但即使是这种优化也需要一些沟通。

1072
00:32:55,780 --> 00:32:58,960
0,240 240,810 810,1350 1350,2190 2220,3180
that optimization requires some {}

1073
00:32:58,990 --> 00:33:00,320
0,210 210,810
some communication.|
|

1074
00:33:00,530 --> 00:33:01,820
0,270 270,630 720,990 990,1110 1110,1290
And so like if we
因此，如果我们只遵循这个天真的想法，

1075
00:33:01,820 --> 00:33:02,900
0,150 150,390 390,570 570,720 720,1080
just follow this {naive -},|
|

1076
00:33:02,930 --> 00:33:03,980
0,180 180,480 480,750 750,960 960,1050
there's this trick for a
对于一个计划来说，有一个诀窍可以真正实现线性化。

1077
00:33:03,980 --> 00:33:05,060
0,300 300,420 420,660 660,840 840,1080
plan to actually get {linearizability

1078
00:33:05,060 --> 00:33:07,360
0,120 120,690 840,1710
- -}. {}|
|

1079
00:33:07,360 --> 00:33:09,310
0,90 90,360 390,660 660,1170 1770,1950
You know, does this what
你知道，这对性能意味着什么，

1080
00:33:09,310 --> 00:33:10,510
0,120 120,270 270,450 450,540 540,1200
does that mean for performance,|
|

1081
00:33:10,510 --> 00:33:11,320
0,60 60,270 270,390 390,690 690,810
you know go back to
你知道，回到过去思考一下对比动物园饲养员。

1082
00:33:11,320 --> 00:33:13,120
0,210 210,270 270,600 600,1200 1200,1800
sort of thinking about contrasting

1083
00:33:13,120 --> 00:33:14,580
0,300 300,540 540,930
the {zookeeper -}.|
|

1084
00:33:20,350 --> 00:33:21,970
0,180 180,540 540,780 780,1260 1260,1620
Yeah, is for example the
是的，例如，读取操作的数量将随着服务器数量的增加而扩展。

1085
00:33:21,970 --> 00:33:22,990
0,180 180,240 240,420 420,870 870,1020
number of read operations is

1086
00:33:22,990 --> 00:33:23,650
0,120 120,180 180,480 480,570 570,660
going to scale with the

1087
00:33:23,650 --> 00:33:25,020
0,180 180,240 240,690
number of servers.|
|

1088
00:33:26,660 --> 00:33:28,730
0,330 330,1050 1050,1380 1380,1830 1830,2070
No, because now everything has
不，因为现在所有的东西都要经过。

1089
00:33:28,730 --> 00:33:31,040
0,120 120,540 540,1680 1710,2190 2190,2310
to pass through.| Exactly, I
|没错，我想我会再次挑战领头羊，

1090
00:33:31,040 --> 00:33:31,640
0,150 150,270 270,420 420,510 510,600
think I'll go for the

1091
00:33:31,640 --> 00:33:33,050
0,270 270,540 540,750 750,1080 1080,1410
leader again,| so here we
|所以我们又来了，

1092
00:33:33,050 --> 00:33:34,100
0,30 30,540 540,810 810,870 870,1050
are again,| that's a little
|这有点不受欢迎，对吧。

1093
00:33:34,100 --> 00:33:35,840
0,120 120,660 660,1020
bit undesirable, correct.|
|

1094
00:33:35,840 --> 00:33:36,590
0,150 150,450 450,540 540,690 690,750
And so it gives you
所以它给了你一个即时的问题是

1095
00:33:36,590 --> 00:33:37,970
0,180 180,450 450,780 780,930 930,1380
an instant question is| like
|就像你知道这怎么可能一样，

1096
00:33:38,120 --> 00:33:38,930
0,150 150,240 240,600 600,690 690,810
you know how is it

1097
00:33:38,930 --> 00:33:39,890
0,450 450,660 660,810 810,900 900,960
possible,| that when you go
|当你去找动物园管理员时，

1098
00:33:39,890 --> 00:33:42,440
0,600 630,1170 1500,2010 2010,2220 2220,2550
to a {zookeeper -},| zookeeper
|动物园饲养员表现出色，

1099
00:33:42,440 --> 00:33:44,420
0,300 300,600 600,1230 1260,1800 1800,1980
gets great performance,| like we
|就像我们看到的这个简单的方案并不真正起作用一样，

1100
00:33:44,420 --> 00:33:45,770
0,180 180,390 390,660 660,1020 1020,1350
see the simple scheme that

1101
00:33:45,770 --> 00:33:47,140
0,240 240,450 450,900
doesn't really work,|
|

1102
00:33:47,550 --> 00:33:48,690
0,240 240,330 330,510 510,930 930,1140
or at least violates {linearizability
或者至少违反了线性化。

1103
00:33:48,690 --> 00:33:49,920
0,150 150,660
- -}.|
|

1104
00:33:50,310 --> 00:33:51,960
0,210 210,330 330,1020 1050,1500 1500,1650
And so what {} so
所以呢，我们想谈一谈

1105
00:33:51,960 --> 00:33:52,500
0,150 150,270 270,360 360,510 510,540
we want to talk a

1106
00:33:52,500 --> 00:33:53,700
0,180 180,480 480,660 660,720 720,1200
little bit| like to understand
|我想知道你到底是怎么弄到这个的

1107
00:33:53,700 --> 00:33:55,140
0,300 300,510 510,900 1110,1260 1260,1440
what was really how did

1108
00:33:55,140 --> 00:33:57,810
0,420 420,630 630,1020 1770,2220 2400,2670
you get this| and so
|所以首先要真正意识到的是

1109
00:33:57,810 --> 00:33:59,040
0,150 150,510 510,810 810,900 900,1230
the first thing to really

1110
00:33:59,040 --> 00:34:00,330
0,570 570,720 720,900 900,1230 1230,1290
realize {} is| probably the
|也许最重要的部分是动物园管理员没有提供线性化。

1111
00:34:00,330 --> 00:34:01,840
0,180 180,570 570,1050
most important part

1112
00:34:02,040 --> 00:34:04,170
0,390 390,780 930,1320 1320,1500 1500,2130
is that {} {zookeeper -}

1113
00:34:05,110 --> 00:34:06,880
0,360 360,570 570,900 900,990 990,1770
does not provide the linearizability.|
|

1114
00:34:08,350 --> 00:34:10,150
0,240 240,600 600,1290 1290,1440 1440,1800
It basically changes the correctness
它基本上改变了正确性的定义。

1115
00:34:10,150 --> 00:34:11,560
0,540
definition.|
|

1116
00:34:22,740 --> 00:34:24,420
0,120 120,780 930,1320 1320,1470 1470,1680
And so the {zookeeper -}
因此动物园管理员服务器，它的行为不会像一台机器一样，

1117
00:34:24,420 --> 00:34:26,190
0,570 780,1230 1230,1410 1410,1650 1650,1770
servers, {} it's not going

1118
00:34:26,190 --> 00:34:27,150
0,60 60,450 450,600 600,660 660,960
to behave like a single

1119
00:34:27,150 --> 00:34:28,830
0,420 540,1290 1290,1410 1410,1500 1500,1680
machine,| {} you know it's
|你知道，它会产生在一台机器上永远不会发生的结果。

1120
00:34:28,830 --> 00:34:30,960
0,180 180,720 750,1470 1470,1920 1920,2130
gonna have results that would

1121
00:34:30,960 --> 00:34:32,220
0,330 330,720 780,960 960,1020 1020,1260
never happen on a single

1122
00:34:32,220 --> 00:34:33,120
0,390
machine.|
|

1123
00:34:33,450 --> 00:34:35,760
0,540 780,1140 1140,1500 1500,2160 2190,2310
{} So the particular, so
所以，它是什么，它提供了什么。

1124
00:34:35,760 --> 00:34:36,690
0,210 210,360 360,540 540,780 780,930
what is it, what does

1125
00:34:36,690 --> 00:34:39,060
0,240 240,690 690,1140 1500,2100 2190,2370
it provide.| Well, {} it
|它确实提供了可线性化的写入，

1126
00:34:39,060 --> 00:34:41,640
0,240 240,870 870,1500 1500,2130
does provide linearizable writes,|
|

1127
00:34:51,880 --> 00:34:54,190
0,390 390,720 720,1230 1230,2190 2190,2310
so all the operations all
所以所有的操作实际上所有的写入操作都要经过引导器

1128
00:34:54,190 --> 00:34:55,390
0,90 90,330 330,780 780,1140 1140,1200
the write operation actually you

1129
00:34:55,390 --> 00:34:56,710
0,150 150,390 390,660 660,780 780,1320
know go through the leader|
|

1130
00:34:56,710 --> 00:34:58,240
0,330 330,450 450,810 810,1200 1200,1530
and you go through the
您查看日志并以相同的顺序将每个对等点添加到日志中

1131
00:34:58,330 --> 00:35:00,580
0,870 1110,1620 1620,2040 2040,2130 2130,2250
log and appended to the

1132
00:35:00,580 --> 00:35:01,900
0,540 540,900 900,1200 1200,1260 1260,1320
log every peer in the

1133
00:35:01,900 --> 00:35:03,190
0,300 300,690 690,810 810,930 930,1290
same order| and so they're
|因此，它们也将以相同的顺序应用，

1134
00:35:03,190 --> 00:35:04,150
0,210 210,270 270,450 450,600 600,960
going to also be applied

1135
00:35:04,150 --> 00:35:04,870
0,60 60,120 120,420 420,570 570,720
in the same order,| so
|所以我们仍然有这个复制的状态机，

1136
00:35:04,870 --> 00:35:06,100
0,150 150,360 360,600 600,780 780,1230
we still have this replicated

1137
00:35:06,100 --> 00:35:09,460
0,270 270,870 1080,2280 2280,2850 2850,3360
state machine,| {} approach where
|按总顺序回复所有写操作更改数据的方法。

1138
00:35:09,460 --> 00:35:11,110
0,330 330,510 510,810 840,1170 1170,1650
reply all the write operational

1139
00:35:11,110 --> 00:35:12,910
0,480 480,780 780,1050 1050,1440 1440,1800
operations change data into {

1140
00:35:13,360 --> 00:35:15,520
0,1590
-}

1141
00:35:17,140 --> 00:35:18,440
0,120 120,180 180,420 420,780
in the total order.|
|

1142
00:35:18,680 --> 00:35:20,480
0,510 840,1320 1320,1530 1530,1620 1620,1800
But, {} there's a couple
但是，还有几处房产，

1143
00:35:20,480 --> 00:35:22,980
0,210 210,960 990,2010
more properties, {}|
|

1144
00:35:23,040 --> 00:35:24,150
0,360 360,510 510,570 570,840 840,1110
so, but it does not
因此，但它不提供读取的线性化，

1145
00:35:24,150 --> 00:35:25,740
0,270 270,630 630,960 960,1080 1080,1590
provide {linearizability -} for reads,|
|

1146
00:35:25,920 --> 00:35:27,570
0,450 480,960 960,1380 1380,1530 1530,1650
{instead,it,sort,of} provides two sort of
相反，它提供了两种不同属性，

1147
00:35:27,570 --> 00:35:29,970
0,480 540,1410 1650,1860 1860,2100 2100,2400
different property,| {} which is
|即所有操作以FIFO顺序、以FIFO客户端顺序出现。

1148
00:35:29,970 --> 00:35:32,550
0,480 480,780 780,1230 1290,1950 1950,2580
that all the operations appear

1149
00:35:32,550 --> 00:35:34,480
0,270 270,630 630,840 840,1410
in FIFO {} order,

1150
00:35:36,540 --> 00:35:40,100
0,1080 1080,1170 1170,1530 1530,2100
{in,FIFO} {} client order.|
|

1151
00:35:40,440 --> 00:35:41,340
0,300 300,600 600,720 720,780 780,900
This partly has to do
这在一定程度上与异步有关

1152
00:35:41,340 --> 00:35:43,770
0,240 240,870 1650,2010 2010,2310 2310,2430
with asynchronous| {you,know} client may
|您知道，客户可能会逐一提交多个请求

1153
00:35:43,770 --> 00:35:46,560
0,360 360,750 750,1380 1710,2370 2370,2790
submit multiple requests {} one

1154
00:35:46,560 --> 00:35:49,050
0,120 120,660 840,1650 1650,2220 2220,2490
by one| {} without waiting
|而不等待回复

1155
00:35:49,050 --> 00:35:50,850
0,120 120,180 180,900 1050,1680 1680,1800
for a response| and you
|你知道动物园管理员会保证，

1156
00:35:50,850 --> 00:35:52,050
0,480 540,810 810,870 870,960 960,1200
know {zookeeper - -} will

1157
00:35:52,050 --> 00:35:53,820
0,660 660,930 930,1140 1140,1320 1320,1770
guarantee,| {} if you submit
|如果您提交了客户1提交了请求，

1158
00:35:54,030 --> 00:35:55,440
0,60 60,390 390,900 930,1350 1350,1410
{} client one submitted the

1159
00:35:55,440 --> 00:35:56,520
0,690
request,|
|

1160
00:35:56,580 --> 00:35:57,930
0,240 240,600 600,870 870,1140 1140,1350
and then client one submitted
然后客户一提交了另一个请求，

1161
00:35:57,930 --> 00:35:59,880
0,330 330,990 1110,1500 1500,1650 1650,1950
another request,| then that second
|那么第二个请求将在稍后出现，

1162
00:35:59,880 --> 00:36:02,850
0,450 450,780 780,1620 1650,2280 2310,2970
request will appear {} later,|
|

1163
00:36:02,880 --> 00:36:05,190
0,450 450,1170 1200,1740 1740,1920 1920,2310
in a result will observe
在一个结果中会观察到第一次操作的结果。

1164
00:36:05,190 --> 00:36:06,120
0,60 60,360 360,450 450,540 540,930
the result of the first

1165
00:36:06,150 --> 00:36:07,520
0,840
operation.|
|

1166
00:36:08,740 --> 00:36:11,320
0,690 960,1680 1710,1860 1860,2520 2520,2580
And so, in particular you
因此，特别是你知道的，写的是客户订单，

1167
00:36:11,320 --> 00:36:13,420
0,180 180,690 690,1110 1110,1560 1560,2100
know writes goes client order,|
|

1168
00:36:22,080 --> 00:36:23,380
0,750

1169
00:36:23,600 --> 00:36:25,550
0,210 210,450 450,1080 1110,1410 1410,1950
and then reads {} where
然后读取所有动作所在的有趣属性的位置，

1170
00:36:25,550 --> 00:36:26,660
0,150 150,300 300,630 630,810 810,1110
all the action is where

1171
00:36:26,660 --> 00:36:29,270
0,90 90,390 390,870 870,1260 1770,2610
the interesting properties are, {}|
|

1172
00:36:30,270 --> 00:36:31,560
0,750

1173
00:36:32,430 --> 00:36:35,100
0,1080 1200,1650 1650,2130 2190,2460 2460,2670
{the,reads,observe} last write,| okay, so
读取观察最后一次写入，|好的，从同一个客户端读取读取观察最后一次写入。

1174
00:36:35,100 --> 00:36:36,500
0,810
reads

1175
00:36:36,610 --> 00:36:38,400
0,330 330,480 480,1260
{reads -} observe

1176
00:36:39,930 --> 00:36:41,910
0,510 510,840 840,1020 1020,1380 1380,1980
last write from same client.|
|

1177
00:36:51,050 --> 00:36:51,830
0,180 180,330 330,510 510,570 570,780
So this sort of makes
所以这基本上是有意义的，就像，

1178
00:36:51,830 --> 00:36:52,970
0,300 300,510 510,870 870,1020 1020,1140
sense going basically this sort

1179
00:36:52,970 --> 00:36:54,410
0,60 60,390 390,780 990,1260 1260,1440
of sense like,| {} you
|你读你自己写的东西，

1180
00:36:54,410 --> 00:36:55,910
0,180 180,360 360,510 510,1050 1320,1500
read your own writes,| so
|因此，如果您执行写入操作，您会立即执行读取操作，

1181
00:36:55,910 --> 00:36:56,660
0,120 120,270 270,390 390,480 480,750
if you do the write

1182
00:36:56,660 --> 00:36:58,100
0,510 510,630 630,960 960,1260 1260,1440
operation, you immediately follow the

1183
00:36:58,100 --> 00:36:59,180
0,210 210,660 660,780 780,960 960,1080
read operation,| you see at
|你至少可以看到你自己写作的结果。

1184
00:36:59,180 --> 00:37:00,680
0,570 570,810 810,1230 1230,1320 1320,1500
least the results of your

1185
00:37:00,680 --> 00:37:02,140
0,180 180,690
own writes.|
|

1186
00:37:02,380 --> 00:37:04,090
0,360 360,720 750,1170 1170,1470 1470,1710
{} But, {} for writes
但是，对于来自其他客户端的来自其他操作的写入，

1187
00:37:04,090 --> 00:37:05,530
0,180 180,480 480,1110 1110,1260 1260,1440
from other operations from other

1188
00:37:05,530 --> 00:37:08,470
0,630 720,1320 1590,2490 2490,2640 2640,2940
clients,| {} {the,zookeeper} does not
|动物园饲养员并不保证这一财产，

1189
00:37:08,470 --> 00:37:09,790
0,360 360,510 510,870 870,1230 1230,1320
guarantee that property,| instead what
|相反，它所保证的是读取器将观察到日志的某个前缀。

1190
00:37:09,790 --> 00:37:12,040
0,270 270,900 900,1110 1110,1560 1680,2250
it guarantees is that the

1191
00:37:12,070 --> 00:37:13,930
0,330 330,450 450,870 870,1080 1080,1860
read will observe some prefix

1192
00:37:16,540 --> 00:37:18,400
0,210 210,270 270,1170
of the log.|
|

1193
00:37:20,920 --> 00:37:22,990
0,390 390,810 810,1020 1020,1650 1680,2070
{} And {} so this
这意味着你可以看到陈旧的数据

1194
00:37:22,990 --> 00:37:24,250
0,450 450,810 810,930 930,1020 1020,1260
means right you can actually

1195
00:37:24,250 --> 00:37:30,490
0,540 600,960 960,1410 5370,5610 5610,6240
see stale data| which may
|其可以从跟随者读取并且该跟随者具有日志的前缀，

1196
00:37:30,490 --> 00:37:32,110
0,420 420,600 600,1350 1380,1500 1500,1620
{read,from} a follower and that

1197
00:37:32,110 --> 00:37:34,030
0,630 630,1140 1140,1320 1320,1770 1770,1920
follower has a prefix of

1198
00:37:34,030 --> 00:37:35,560
0,120 120,600 750,990 990,1350 1350,1530
the log,| but not only
|但不仅是日志中的最后条目，

1199
00:37:35,560 --> 00:37:36,550
0,120 120,420 420,810 810,900 900,990
the last entries in the

1200
00:37:36,550 --> 00:37:38,890
0,390 390,870 870,1200 1200,1560 1560,2340
log,| because maybe just lag
|因为也许只是稍微落后了一点，

1201
00:37:38,890 --> 00:37:40,390
0,330 330,390 390,570 570,870 1170,1500
behind a little bit, {}|
|

1202
00:37:40,390 --> 00:37:42,670
0,480 480,1230 1230,1920 1920,2250 2250,2280
and nevertheless that followers are
尽管如此，追随者被允许返回一个值，

1203
00:37:42,670 --> 00:37:45,700
0,300 300,720 900,1890 1920,2430 2430,3030
allowed to return a value,|
|

1204
00:37:45,850 --> 00:37:46,990
0,600 600,690 690,780 780,840 840,1140
because you know the only
因为你知道的唯一一件事，你知道的，动物园管理员将保证，真正的阅读，观察前缀日志。

1205
00:37:46,990 --> 00:37:49,120
0,330 330,780 780,900 900,1650 1680,2130
thing that's you know {zookeeper

1206
00:37:49,120 --> 00:37:50,200
0,270 270,390 390,450 450,900 900,1080
-} going to guarantee that

1207
00:37:50,200 --> 00:37:52,510
0,510 510,870 870,1380 1410,1710 1710,2310
actually reads observe a prefix

1208
00:37:52,510 --> 00:37:53,260
0,540
log.|
|

1209
00:37:54,680 --> 00:37:55,700
0,180 180,300 300,750 750,870 870,1020
So the operations can now
所以现在的行动可以不按顺序进行，

1210
00:37:55,700 --> 00:37:56,960
0,180 180,330 330,420 420,960 1110,1260
go out of order,| you
|你知道一旦他们在日志里

1211
00:37:56,960 --> 00:37:57,740
0,150 150,390 390,600 600,720 720,780
know once they in the

1212
00:37:57,740 --> 00:37:59,180
0,570 570,780 780,870 870,1080 1080,1440
log| and you can sort
|而且你可以读不能像读操作一样无序地读入日志，

1213
00:37:59,180 --> 00:38:00,920
0,90 90,720 840,1110 1110,1470 1470,1740
of {} reads can't like

1214
00:38:00,920 --> 00:38:02,510
0,300 330,930 930,1350 1350,1500 1500,1590
read {} operation out of

1215
00:38:02,510 --> 00:38:03,260
0,90 90,390 390,480 480,660 660,750
the log in out of

1216
00:38:03,260 --> 00:38:04,280
0,420 450,600 600,780 780,930 930,1020
order,| it really has to
|它真的必须是一个前缀，日志的前缀。

1217
00:38:04,280 --> 00:38:05,360
0,120 120,180 180,570 570,630 630,1080
be a prefix, a prefix

1218
00:38:05,360 --> 00:38:06,380
0,90 90,180 180,570
of the log.|
|

1219
00:38:07,070 --> 00:38:07,880
0,270 270,360 360,510 510,570 570,810
And then there's a second
然后还有第二个要求，

1220
00:38:07,880 --> 00:38:10,130
0,720 960,1350 1350,1470 1470,1830 1830,2250
requirement,| that you cannot do
|你不知道的东西是从过去读来的。

1221
00:38:10,160 --> 00:38:11,600
0,270 270,600 600,750 750,840 840,1440
know reads from the past.|
|

1222
00:38:18,250 --> 00:38:19,300
0,180 180,270 270,450 450,810 810,1050
And it really means like
这真的意味着如果你看到一些前缀。

1223
00:38:19,300 --> 00:38:20,620
0,210 210,390 390,660 660,930 930,1320
if you saw some prefix

1224
00:38:20,620 --> 00:38:21,780
0,510
one.|
|

1225
00:38:22,900 --> 00:38:24,580
0,180 180,450 450,570 570,1290 1290,1680
And then you issue reads
然后你发出一些前缀一

1226
00:38:24,580 --> 00:38:26,050
0,240 240,540 540,1020 1020,1200 1200,1470
some prefix one| and then
|然后你读二读，

1227
00:38:26,050 --> 00:38:27,340
0,120 120,270 270,330 330,750 750,1290
you read the second read,|
|

1228
00:38:27,700 --> 00:38:29,230
0,570 570,750 750,1020 1020,1260 1260,1530
then that second read has
那么第二次读取必须至少看到前缀1加更多。

1229
00:38:29,230 --> 00:38:30,280
0,90 90,300 300,420 420,720 720,1050
to see at least prefix

1230
00:38:30,280 --> 00:38:32,160
0,540 570,840 840,1290
one plus more.|
|

1231
00:38:34,780 --> 00:38:36,010
0,210 210,360 360,480 480,870 870,1230
It might be no, it
它可能是不，可能只是前缀一，

1232
00:38:36,010 --> 00:38:37,240
0,210 210,360 360,600 600,930 930,1230
might be just prefix one,|
|

1233
00:38:37,300 --> 00:38:38,410
0,180 180,600 600,750 750,1020 1020,1110
but cannot go back in
但不能回到过去，

1234
00:38:38,410 --> 00:38:39,730
0,330 330,480 480,570 570,990 990,1320
time,| so it cannot see
|因此它不能看到比前缀1更短的前缀。

1235
00:38:39,730 --> 00:38:42,310
0,60 60,840 870,1620 1800,2130 2130,2580
a shorter prefix than prefix

1236
00:38:42,310 --> 00:38:43,220
0,360
one.|
|

1237
00:38:44,120 --> 00:38:45,470
0,150 150,270 270,480 480,1140 1140,1350
And so this basically, {}
这基本上是这样的，所以如果我们回头看这张图，

1238
00:38:45,470 --> 00:38:46,400
0,300 300,540 540,690 690,750 750,930
so so if we look

1239
00:38:46,400 --> 00:38:48,000
0,270 270,330 330,480 480,1020
back at this picture,|
|

1240
00:38:48,000 --> 00:38:49,240
0,690

1241
00:38:49,690 --> 00:38:51,220
0,600 630,810 810,1080 1080,1230 1230,1530
the {zookeeper -} will allow
在某些情况下，动物园管理员会允许这样做，

1242
00:38:51,220 --> 00:38:53,080
0,420 420,600 600,870 870,1410 1410,1860
this in certain cases,| namely,
|也就是说，如果两个客户端不同，

1243
00:38:53,080 --> 00:38:54,880
0,240 240,660 810,1080 1080,1650 1650,1800
if the two clients are

1244
00:38:54,880 --> 00:38:56,000
0,630
different,|
|

1245
00:38:56,060 --> 00:38:58,040
0,210 210,360 360,750 750,1470
{} but {it,won't} allow
但它不允许这样，这是你永远不可能回到过去的。

1246
00:38:58,360 --> 00:38:59,620
0,270 270,270 510,870 870,1170 1170,1260
this, {} this you can

1247
00:38:59,620 --> 00:39:00,820
0,270 270,510 510,750 750,810 810,1200
never have back in time.|
|

1248
00:39:01,700 --> 00:39:02,900
0,690
Okay?|
好吧?|

1249
00:39:04,690 --> 00:39:06,370
0,270 270,450 450,930 960,1110 1110,1680
So I have a question,
所以我有一个问题，一个概念性的问题，

1250
00:39:06,370 --> 00:39:07,630
0,120 120,600 600,840 900,1140 1140,1260
a conceptual one,| so we
|所以我们有这两个一致性保证，

1251
00:39:07,630 --> 00:39:09,640
0,180 180,360 690,930 930,1500 1500,2010
have these two consistency guarantees,|
|

1252
00:39:09,640 --> 00:39:11,200
0,150 150,450 450,900 900,1260 1260,1560
the {linearizable -} writes {and,the}
可线性化写入和FIFO客户端顺序，

1253
00:39:11,200 --> 00:39:12,880
0,180 180,480 570,870 870,1230 1440,1680
{FIFO -} client order,| so
|因此，如果我们暂时忽略第二个约束

1254
00:39:12,880 --> 00:39:13,900
0,180 180,300 300,630 630,720 720,1020
if we ignore the second

1255
00:39:13,900 --> 00:39:15,250
0,450 450,690 690,780 780,1200 1200,1350
constraint for a second| and
|如果我们只关注第一个问题，

1256
00:39:15,250 --> 00:39:16,180
0,120 120,300 300,540 540,840 840,930
if we only focus on

1257
00:39:16,180 --> 00:39:18,400
0,90 90,330 330,570 930,2160 2160,2220
the first one,| does the
|可线性化写入的定义真的有意义吗，

1258
00:39:18,400 --> 00:39:20,050
0,600 600,780 780,1020 1020,1410 1410,1650
definition of {linearizable -} writes

1259
00:39:20,050 --> 00:39:21,250
0,330 330,570 570,870 870,1110 1110,1200
actually makes sense,| since the
|因为线性化的定义取决于具有读操作和写操作。

1260
00:39:21,250 --> 00:39:23,500
0,480 480,660 660,870 870,1620 1650,2250
definition of {linearizability -} depends

1261
00:39:23,500 --> 00:39:24,910
0,210 210,630 630,780 780,930 930,1410
on having a read operation

1262
00:39:24,910 --> 00:39:26,710
0,150 150,270 270,540 540,1410 1620,1800
and a write operation.| So
|所以你就像是在想一秒钟，

1263
00:39:26,710 --> 00:39:28,750
0,1020 1020,1380 1380,1650 1650,1800 1800,2040
you're like hold that thought

1264
00:39:28,750 --> 00:39:32,900
0,420 930,1680 1710,2040 2040,3570
for {a,second},| because, {}
|因为，他们定义可线性化写入的方式基本上不是写入是总顺序，

1265
00:39:33,320 --> 00:39:34,820
0,240 240,540 540,660 660,990 990,1500
the way they define linearizable

1266
00:39:34,820 --> 00:39:35,810
0,270 270,480 480,630 630,900 900,990
writes is not basically the

1267
00:39:35,810 --> 00:39:36,950
0,210 210,330 330,390 390,660 660,1140
writes are a total order,|
|

1268
00:39:37,040 --> 00:39:37,910
0,300 300,540 540,660 660,780 780,870
{} and but there is
但是在读取和写入之间存在关系，

1269
00:39:37,910 --> 00:39:38,990
0,120 120,600 600,810 810,900 900,1080
a relationship between the read

1270
00:39:38,990 --> 00:39:40,280
0,90 90,150 150,450 450,690 690,1290
and the write,| so hold
|所以把那个拿远一点，好吗？

1271
00:39:40,280 --> 00:39:41,300
0,210 210,300 300,360 360,630 630,1020
{that,far} for a second, okay.|
|

1272
00:39:42,160 --> 00:39:43,480
0,450 450,690 690,1020 1020,1140 1140,1320
{} {We'll,come} back,| we get
我们会回来的，|我们马上就到了，就像一块木板，

1273
00:39:43,480 --> 00:39:44,710
0,90 90,270 270,390 390,810 810,1230
to that in a in

1274
00:39:44,710 --> 00:39:46,360
0,90 90,480 510,900 900,1230 1230,1650
a minute like one board,|
|

1275
00:39:46,660 --> 00:39:47,830
0,120 120,270 270,330 330,450 450,1170
I want to make one
我想在中间做一块木板，好的。

1276
00:39:47,830 --> 00:39:49,440
0,210 210,270 270,630 660,1050
board in between, okay.|
|

1277
00:39:50,020 --> 00:39:51,240
0,270 270,600
Sounds good.|
听起来不错。|

1278
00:39:52,180 --> 00:39:53,620
0,330 330,900
Okay so,
好的，就像，

1279
00:39:53,770 --> 00:39:55,300
0,240 240,390 390,660 660,960 1170,1530
just {like -},| let's look
|让我们来看看C代码ZooKeeper实际上是如何提供这些保证的。

1280
00:39:55,300 --> 00:39:57,490
0,30 30,240 240,540 1140,1530 1530,2190
a little bit at how

1281
00:39:57,490 --> 00:39:59,350
0,210 210,660 660,990 990,1500 1500,1860
C code zookeeper actually provides

1282
00:39:59,350 --> 00:40:00,800
0,180 180,960
these guarantees.|
|

1283
00:40:00,890 --> 00:40:03,170
0,690 1050,1740 1740,2070 2070,2130 2130,2280
{} And if we get
如果我们得到了你知道的直觉，

1284
00:40:03,170 --> 00:40:05,480
0,60 60,840 870,1020 1020,1410 1410,2310
the intuition you know, {}|
|

1285
00:40:06,350 --> 00:40:07,700
0,360 360,450 450,570 570,990 990,1350
how you could implement this,|
你如何实现这一点，|

1286
00:40:07,970 --> 00:40:08,780
0,210 210,330 330,570 570,780 780,810
{} the paper section are
论文部分没有非常明确地说明他们是如何实现这一点的，

1287
00:40:08,780 --> 00:40:10,310
0,300 300,480 480,1110 1140,1410 1410,1530
not very explicit about how

1288
00:40:10,310 --> 00:40:11,750
0,150 150,540 540,930 1110,1380 1380,1440
they implement this,| sort of
|就像我要给你一个大概最好的猜测。

1289
00:40:11,750 --> 00:40:12,530
0,180 180,300 300,420 420,570 570,780
like I'm gonna give you

1290
00:40:12,530 --> 00:40:14,380
0,150 150,450 450,870 870,1440
a roughly best guess.|
|

1291
00:40:14,640 --> 00:40:16,620
0,630 900,1380
{} So,
所以，有一个动物园管理员的客户，

1292
00:40:16,680 --> 00:40:18,510
0,330 330,690 720,930 930,1200 1200,1830
there's a {zookeeper -} client,|
|

1293
00:40:21,150 --> 00:40:21,930
0,180 180,360 360,450 450,510 510,780
it runs on the client
它在客户机上运行，

1294
00:40:21,930 --> 00:40:24,060
0,450 570,1260 1260,1620 1620,2010 2010,2130
machine,| {} in {lab,3}, we
|在实验3中，我们称其为办事员

1295
00:40:24,060 --> 00:40:25,020
0,150 150,300 300,390 390,480 480,960
call this as a clerk|
|

1296
00:40:25,050 --> 00:40:25,680
0,180 180,270 270,450 450,540 540,630
and so this is a
这是一种与服务协作的软件库分类。

1297
00:40:25,680 --> 00:40:27,030
0,180 180,240 240,690 690,1080 1080,1350
piece of software library sort

1298
00:40:27,030 --> 00:40:28,710
0,150 150,480 480,1200 1200,1590 1590,1680
that works collaborates with the

1299
00:40:28,710 --> 00:40:29,740
0,570
service.|
|

1300
00:40:30,360 --> 00:40:32,670
0,660 690,1080 1080,1620 1620,2010 2010,2310
In {} in {zookeeper -}
在《动物园饲养员》的论文术语中，

1301
00:40:32,670 --> 00:40:34,230
0,90 90,180 180,420 420,1080 1080,1560
in the paper terminology,| basically
|基本上，它是有这个部分的东西，

1302
00:40:34,230 --> 00:40:34,860
0,150 150,300 300,390 390,540 540,630
it is the thing that

1303
00:40:34,860 --> 00:40:36,840
0,210 210,360 360,750 1170,1710 1740,1980
has this section,| so {}
|因此，当您加入时，客户端想要连接ZooKeeper服务器

1304
00:40:36,840 --> 00:40:37,920
0,360 360,510 510,870 870,990 990,1080
when you join when a

1305
00:40:37,920 --> 00:40:39,030
0,360 360,510 510,600 600,1050 1050,1110
client wants to connect the

1306
00:40:39,030 --> 00:40:40,080
0,180 180,330 330,390 390,960 960,1050
{zookeeper - -} servers| you
|你知道它创建了一个会话，

1307
00:40:40,080 --> 00:40:41,010
0,60 60,180 180,420 420,480 480,930
know it creates a session,|
|

1308
00:40:41,010 --> 00:40:42,630
0,120 120,510 510,1200 1200,1260 1260,1620
it connects using the session
它使用会话信息连接到领导者

1309
00:40:42,630 --> 00:40:44,550
0,660 1080,1320 1320,1440 1440,1830 1830,1920
information to the leader| and
|并在整个会话期间维护您知道的状态。

1310
00:40:44,550 --> 00:40:47,190
0,600 600,1350 1530,2040 2040,2100 2100,2640
maintains {you,know,state} across the session.|
|

1311
00:40:48,050 --> 00:40:49,490
0,420 450,720 720,810 810,870 870,1440
So we have a leader
所以我们有一位动物园管理员的领导者，就像我们将看到的追随者一样，

1312
00:40:49,520 --> 00:40:51,410
0,300 300,690 720,1410 1410,1560 1560,1890
{} in {} {zookeeper -}

1313
00:40:51,410 --> 00:40:53,570
0,150 150,360 360,870 990,1380 1410,2160
as we'll see with followers,|
|

1314
00:40:53,570 --> 00:40:54,980
0,120 120,570 570,1170 1170,1350 1350,1410
{you,know} basically {this,is,all} sort of
你知道，基本上这都有些相似，

1315
00:40:54,980 --> 00:40:56,100
0,600
similar,|
|

1316
00:40:56,100 --> 00:40:57,510
0,420 420,630 630,930 930,1080 1080,1410
{} to what we're used
到我们在第二个实验中所习惯的

1317
00:40:57,510 --> 00:40:59,910
0,120 120,330 330,720 720,1410 1740,2400
to from lab two| and
|动物园管理员的客户给领导写了一封信，

1318
00:40:59,910 --> 00:41:02,160
0,240 240,660 660,1140 1140,1710 1710,2250
the zookeeper client issues write

1319
00:41:02,160 --> 00:41:03,150
0,90 90,210 210,330 330,480 480,990
you know to the leader,|
|

1320
00:41:03,180 --> 00:41:04,830
0,690 990,1170 1170,1440 1440,1530 1530,1650
because the writes are going
因为写入将是可线性化的，

1321
00:41:04,830 --> 00:41:05,790
0,60 60,240 240,480 480,690 690,960
to be {linearizable -},| in
|事实上，写入基本上遵循与RAFT库中大致相同的策略，

1322
00:41:05,790 --> 00:41:07,260
0,210 210,570 570,870 870,1200 1200,1470
fact the writes basically follow

1323
00:41:07,260 --> 00:41:08,520
0,570 570,750 750,840 840,1140 1140,1260
exactly sort of roughly the

1324
00:41:08,520 --> 00:41:10,170
0,270 270,870 870,1080 1080,1320 1320,1650
same strategy as in the

1325
00:41:10,170 --> 00:41:12,030
0,570 630,1020 1020,1440 1560,1740 1740,1860
raft library,| so it's going
|所以这将是一段原木

1326
00:41:12,030 --> 00:41:13,860
0,60 60,180 180,240 240,840 1080,1830
to be a log| and
|在日志中，所有的写入都会被记录下来。

1327
00:41:14,040 --> 00:41:15,060
0,270 270,360 360,720 720,930 930,1020
in the log all the

1328
00:41:15,060 --> 00:41:16,290
0,270 270,390 390,840 870,1020 1020,1230
writes are entered you know

1329
00:41:16,290 --> 00:41:17,970
0,600 600,690 690,870 870,1020 1020,1680
whatever you know some slots,|
|

1330
00:41:18,000 --> 00:41:19,860
0,270 270,390 390,510 510,1140 1350,1860
let's say the leader pends
让我们假设领导者在这个特定的索引中挂起了这段文字，

1331
00:41:19,860 --> 00:41:21,720
0,210 210,720 1170,1440 1440,1590 1590,1860
this write here in this

1332
00:41:21,720 --> 00:41:24,660
0,990 990,1650 2070,2220 2220,2490 2490,2940
particular index,| so this {}
|所以这有一个索引

1333
00:41:24,660 --> 00:41:26,040
0,150 150,210 210,780 870,1200 1200,1380
has an index| {} and
|在论文中，他们将这个指数称为zxid。

1334
00:41:26,040 --> 00:41:27,060
0,60 60,150 150,480 480,660 660,1020
in the paper, they refer

1335
00:41:27,060 --> 00:41:29,220
0,90 90,240 240,660 660,1140 1290,2160
to this index as {zxid

1336
00:41:29,220 --> 00:41:30,180
0,240 240,660
- -}.|
|

1337
00:41:31,260 --> 00:41:32,460
0,510 510,780 780,900 900,1110 1110,1200
{} So I think you
因此，我认为您基本上可以将zxid视为日志中的索引。

1338
00:41:32,460 --> 00:41:33,360
0,90 90,240 240,390 390,480 480,900
can think about the {zxid

1339
00:41:33,360 --> 00:41:34,590
0,210 210,600 600,780 780,900 900,1230
-} basically as the index

1340
00:41:34,590 --> 00:41:35,760
0,120 120,180 180,630
in the log.|
|

1341
00:41:36,760 --> 00:41:39,430
0,690 720,1440 1470,1920 1920,2130 2130,2670
And {} when the leader
当领导者基本上做出承诺时，

1342
00:41:39,460 --> 00:41:41,680
0,480 480,1110 1170,1470 1470,1650 1650,2220
basically commits,| {} an entry
|一个条目将您知道的写入日志，

1343
00:41:41,710 --> 00:41:43,630
0,840 840,930 930,1050 1050,1350 1350,1920
writes you know to the

1344
00:41:43,660 --> 00:41:45,550
0,540 540,750 750,1200 1200,1350 1350,1890
log,| it returns the {zxid
|它将ZXID返回给客户端，

1345
00:41:45,550 --> 00:41:47,230
0,420 420,930 1080,1200 1200,1290 1290,1680
-} back to the client,|
|

1346
00:41:47,530 --> 00:41:48,760
0,150 150,240 240,510 510,1020 1020,1230
so the client maintains that
因此，客户端维护该状态。

1347
00:41:48,760 --> 00:41:49,720
0,480
state.|
|

1348
00:41:50,550 --> 00:41:52,080
0,300 300,900 900,1020 1020,1110 1110,1530
So associated with the session
所以与会话相关联的基本上是上次写入时的zxid和zxid。

1349
00:41:52,080 --> 00:41:54,090
0,120 120,750 750,960 960,1380 1380,2010
is basically with {zxids -}

1350
00:41:54,870 --> 00:41:56,160
0,360 360,510 510,810 810,930 930,1290
{zxid - -} at last

1351
00:41:56,160 --> 00:41:57,100
0,420
write.|
|

1352
00:41:59,540 --> 00:42:00,820
0,300 300,360 360,720
{Okay - -}?|
好吧?|

1353
00:42:02,060 --> 00:42:03,680
0,420 420,690 690,1200 1200,1260 1260,1620
And so when the client
因此，当客户稍后

1354
00:42:03,680 --> 00:42:05,900
0,420 420,870 900,1170 1170,1710
later on,| the read,
|阅读，阅读它不一定要交给领导者，

1355
00:42:06,200 --> 00:42:07,160
0,150 150,240 240,630 630,750 750,960
and the read it doesn't

1356
00:42:07,160 --> 00:42:07,820
0,180 180,270 270,450 450,570 570,660
have to go to the

1357
00:42:07,820 --> 00:42:08,780
0,300 300,480 480,690 690,750 750,960
leader,| because that's the whole
|因为这是获得更多性能的全部目标，

1358
00:42:08,780 --> 00:42:09,890
0,210 210,300 300,480 480,840 840,1110
goal to get more {}

1359
00:42:09,920 --> 00:42:11,810
0,390 390,510 510,900 900,1230 1650,1890
performance,| so maybe the read
|所以，你知道，读取器可能会传给其中一个追随者，

1360
00:42:11,810 --> 00:42:12,920
0,270 270,420 420,870 870,960 960,1110
actually will go you know

1361
00:42:12,920 --> 00:42:14,660
0,480 510,780 780,870 870,990 990,1740
to one of the followers,|
|

1362
00:42:16,180 --> 00:42:17,500
0,510 510,840 840,1020 1020,1110 1110,1320
and but then the read
然后，读取将使用上次写入的zxid进行标记

1363
00:42:17,500 --> 00:42:19,480
0,120 120,240 240,960 1320,1800 1800,1980
will be tagged with the

1364
00:42:19,480 --> 00:42:21,040
0,270 270,480 480,900 900,1350 1380,1560
{zxid - -} that of

1365
00:42:21,040 --> 00:42:22,540
0,90 90,450 450,870 870,1170 1170,1500
the last write| that particular
|那个特定的客户端已经完成了。

1366
00:42:22,540 --> 00:42:23,860
0,330 330,450 450,780
client is done.|
|

1367
00:42:24,930 --> 00:42:26,070
0,450 450,630 630,840 840,960 960,1140
And so what does that
那么这意味着什么呢，

1368
00:42:26,070 --> 00:42:27,600
0,450 450,990 990,1230 1230,1350 1350,1530
mean,| well let's say this
|好吧，让我们在后面说这个，对吗？

1369
00:42:27,600 --> 00:42:29,880
0,390 390,840 840,1230 1230,1680 1890,2280
following behind, right| and it
|它有两个条目，但还没有实际观察到，你知道写的是什么，

1370
00:42:29,880 --> 00:42:31,680
0,690 750,960 960,1350 1350,1500 1500,1800
has two entries, but hasn't

1371
00:42:31,680 --> 00:42:33,180
0,240 240,1020 1140,1290 1290,1380 1380,1500
actually observed, you know the

1372
00:42:33,180 --> 00:42:34,290
0,240 240,480 480,720 720,1020 1020,1110
write yet,| because whatever the
|因为无论领导人是什么，都是通过其他追随者做出的。

1373
00:42:34,290 --> 00:42:35,310
0,270 270,420 420,540 540,900 900,1020
leader may be committed it

1374
00:42:35,310 --> 00:42:36,880
0,180 180,300 300,600 600,1110
through these other followers.|
|

1375
00:42:37,560 --> 00:42:38,400
0,150 150,300 300,600 600,660 660,840
And what happens in this
而在这种情况下发生的是，

1376
00:42:38,400 --> 00:42:40,740
0,300 300,420 420,810 900,1410 1710,2340
case is that,| this read
|这位关注者不会立即做出回应，

1377
00:42:41,130 --> 00:42:42,540
0,570 570,720 720,930 930,1200 1200,1410
{} the follower won't really

1378
00:42:42,540 --> 00:42:44,430
0,360 360,810 810,1410 1410,1710 1710,1890
respond immediately,| instead it will
|相反，它将等待，直到您知道zxid。

1379
00:42:44,430 --> 00:42:47,340
0,630 1110,1650 1650,2430
wait until see

1380
00:42:47,340 --> 00:42:48,480
0,60 60,210 210,330 330,750 750,1140
you know the {zxid -}.|
|

1381
00:42:49,660 --> 00:42:50,440
0,150 150,240 240,450 450,540 540,780
And as soon as we've
一旦我们看到了zxid，

1382
00:42:50,440 --> 00:42:51,520
0,210 210,300 300,720 720,960 960,1080
seen the {zxid -},| it
|它实际上会做出回应。

1383
00:42:51,520 --> 00:42:53,200
0,390 390,600 600,1110
actually will respond.|
|

1384
00:42:56,620 --> 00:42:57,400
0,210 210,300 300,480 480,660 660,780
Now, of course there's gonna
现在，当然还会有另一个客户。

1385
00:42:57,400 --> 00:42:58,960
0,120 120,360 360,990
be another client.|
|

1386
00:42:59,050 --> 00:43:00,670
0,810 810,1140 1140,1290 1290,1530 1530,1620
{} And so maybe at
因此，也许在某个时候，这篇文章会被通过，

1387
00:43:00,670 --> 00:43:01,720
0,120 120,540 540,690 690,930 930,1050
some point this write will

1388
00:43:01,720 --> 00:43:06,040
0,120 120,660 1200,2070 2070,3630 3930,4320
come through,| {} and maybe
|现在，客户端可能会执行另一次读取

1389
00:43:06,040 --> 00:43:07,510
0,180 180,270 270,720 720,1110 1110,1470
now the read {the,client,does} another

1390
00:43:07,510 --> 00:43:08,770
0,390 450,720 720,930 930,1020 1020,1260
read| and so it hasn't
|所以它没有看到过其他的zxid

1391
00:43:08,770 --> 00:43:10,630
0,150 150,360 360,1080 1080,1410 1410,1860
seen no other {zxids -

1392
00:43:10,630 --> 00:43:12,820
0,480 900,1440 1440,1800 1800,1890 1890,2190
-}| and maybe {} like
|也许就像让我再做一个追随者。

1393
00:43:12,850 --> 00:43:13,990
0,240 240,510 510,690 690,900 900,1140
let me make one more

1394
00:43:13,990 --> 00:43:15,020
0,600
follower.|
|

1395
00:43:15,430 --> 00:43:16,540
0,210 210,330 330,600 600,810 810,1110
Let's see there's yet another
让我看看还有一个追随者

1396
00:43:16,540 --> 00:43:17,770
0,420 420,570 570,810 810,990 990,1230
follower| that actually has not
|它实际上还没有观察到，你知道，最后一篇文章，

1397
00:43:17,770 --> 00:43:19,330
0,600 600,690 690,810 810,1290 1290,1560
observed you know that that

1398
00:43:19,330 --> 00:43:21,910
0,570 570,810 810,1260 2010,2220 2220,2580
final write yet,| let me.|
|让我。|

1399
00:43:22,870 --> 00:43:23,710
0,240 240,450 450,570 570,630 630,840
So there's going to be
所以还会有另一个，

1400
00:43:23,710 --> 00:43:25,210
0,510 510,690 690,930 930,1170 1170,1500
another,| let's say there's {another
|假设还有另一个客户，

1401
00:43:25,240 --> 00:43:26,770
0,300 300,900 930,1080 1080,1410 1410,1530
-} client,| that sticks in
|这是在其他一些文字中坚持下来的，

1402
00:43:26,770 --> 00:43:28,120
0,150 150,390 390,870 1080,1260 1260,1350
some other write,| that's the
|这就是我想要谈论的情景，

1403
00:43:28,210 --> 00:43:29,020
0,390 390,420 420,570 570,630 630,810
scenario I want to talk

1404
00:43:29,020 --> 00:43:30,610
0,420 540,750 750,870 870,1110 1110,1590
about,| there was another client
|还有另一个客户端实际上将w附加在cxid之后，

1405
00:43:30,610 --> 00:43:32,680
0,150 150,420 420,990 1260,1410 1410,2070
that actually {appended -} w

1406
00:43:32,680 --> 00:43:34,150
0,390 390,510 510,1200 1200,1320 1320,1470
after the cxid,| you know
|你知道它就在这里，

1407
00:43:34,150 --> 00:43:36,280
0,240 240,390 390,660 660,1260 1590,2130
it is right here, {}|
|

1408
00:43:36,280 --> 00:43:37,420
0,210 210,300 300,450 450,660 660,1140
but it was not observed
但没有观察到特别是写，

1409
00:43:37,420 --> 00:43:38,710
0,450 450,900 900,990 990,1110 1110,1290
{that,particularly} write,| you know what
|你知道我们这里有什么，

1410
00:43:38,710 --> 00:43:40,140
0,120 120,390 390,1020
we have here,|
|

1411
00:43:40,140 --> 00:43:42,620
0,900 1140,1290 1290,1530 1530,1950
is we got the,
我们有，我们两个老虎机，

1412
00:43:43,320 --> 00:43:44,500
0,690

1413
00:43:45,930 --> 00:43:47,130
0,180 180,330 330,570 570,1050 1050,1200
we {} two slots,| we've
|我们得写点东西，

1414
00:43:47,130 --> 00:43:48,060
0,120 120,210 210,660 660,840 840,930
got to write,| but in
|但在绿色的文字中，并没有真正出现在特定的追随者身上，

1415
00:43:48,060 --> 00:43:49,230
0,120 120,450 450,690 690,960 960,1170
the green write, hasn't really

1416
00:43:49,230 --> 00:43:51,210
0,270 270,570 570,1230 1230,1380 1380,1980
show {up -} at particular

1417
00:43:51,240 --> 00:43:53,280
0,630 930,1170 1170,1290 1290,1650 1680,2040
follower,| so if the client
|因此，如果客户端现在发出Second Read，

1418
00:43:53,280 --> 00:43:55,290
0,120 120,660 660,1110 1200,1770 1770,2010
now issues second read,| maybe
|也许它会传给另一个追随者，

1419
00:43:55,290 --> 00:43:56,040
0,150 150,360 360,450 450,570 570,750
that goes to the other

1420
00:43:56,040 --> 00:43:57,260
0,690
follower,|
|

1421
00:43:57,350 --> 00:43:58,310
0,120 120,300 330,570 570,630 630,960
you know, that's the same
你知道，这是相同的zxid，

1422
00:43:58,310 --> 00:43:59,660
0,390 390,750 750,1020 1020,1110 1110,1350
{zxid -},| because it hasn't
|因为它没有看到任何新的，该客户端没有发出任何新的写入，

1423
00:43:59,660 --> 00:44:01,700
0,480 480,660 660,1350 1410,1800 1800,2040
seen any new, that client

1424
00:44:01,700 --> 00:44:03,140
0,180 180,420 420,750 750,960 960,1440
has not issued any new

1425
00:44:03,140 --> 00:44:05,150
0,480 960,1110 1110,1200 1200,1530 1530,2010
writes,| it will arrive there|
|它会到达那里|

1426
00:44:05,180 --> 00:44:08,060
0,570 600,780 780,2010 2010,2580 2760,2880
and that {} guy is
而那个人被允许立即做出回应，

1427
00:44:08,060 --> 00:44:09,980
0,270 270,330 330,750 750,1440
allowed to respond immediately,|
|

1428
00:44:10,600 --> 00:44:12,520
0,450 450,570 570,1260 1260,1800 1800,1920
because it has seen the
因为它已经看到了[]的ZXID已经看到了该特定客户端的最后ZXID，

1429
00:44:12,520 --> 00:44:15,520
0,510 510,990 1020,1470 1500,2190 2490,3000
{zxid -} of the []

1430
00:44:15,520 --> 00:44:16,390
0,180 180,330 330,390 390,630 630,870
has seen the last {zxid

1431
00:44:16,390 --> 00:44:18,130
0,420 420,660 660,810 810,1170 1170,1740
-} of that particular client,|
|

1432
00:44:18,430 --> 00:44:19,600
0,270 270,330 330,540 540,630 630,1170
{} of course it misses
当然，它遗漏了一些写入，

1433
00:44:19,780 --> 00:44:21,160
0,240 240,690 690,780 780,900 900,1380
some writes,| you know that
|您知道，从已经由大多数服务器处理的其他客户端，

1434
00:44:21,160 --> 00:44:22,210
0,180 180,480 480,870 870,990 990,1050
from other clients that are

1435
00:44:22,210 --> 00:44:23,950
0,330 330,480 480,1050 1050,1620 1710,1740
already being processed by some

1436
00:44:23,950 --> 00:44:25,480
0,540 540,600 600,690 690,1200 1290,1530
majority of the servers,| but
|但不需要返回该数据

1437
00:44:25,480 --> 00:44:26,530
0,90 90,180 180,390 390,930 930,1050
it is not required to

1438
00:44:26,530 --> 00:44:27,970
0,330 330,420 420,930 1140,1320 1320,1440
return that data| and so
|所以它可以直接退货。

1439
00:44:27,970 --> 00:44:28,870
0,120 120,210 210,330 330,690 690,900
it can just return it.|
|

1440
00:44:29,770 --> 00:44:30,790
0,180 180,330 330,480 480,720 720,1020
And so this might actually
因此，这实际上可能会以陈旧的价值返回。

1441
00:44:30,790 --> 00:44:33,640
0,210 210,450 450,1080 1110,2190
return in stale values.|
|

1442
00:44:33,640 --> 00:44:34,960
0,330 330,600 600,720 720,1200 1200,1320
But {you,know} they're allowed by
但你知道他们是被动物园管理员的正确性保证定义所允许的。

1443
00:44:34,960 --> 00:44:36,550
0,90 90,630 630,1140 1140,1320 1320,1590
the definition of the {zookeeper

1444
00:44:36,550 --> 00:44:38,740
0,270 270,960 960,1650
-} correctness guarantees.|
|

1445
00:44:39,040 --> 00:44:41,140
0,780 810,1260 1260,1410 1410,1440 1440,2100
{} Professor, {I,had} a question.|
教授，我有个问题。|

1446
00:44:41,170 --> 00:44:43,330
0,450 840,1320 1320,1890 1950,2160 2160,2160
Yeah.| At first I I
嗯。|一开始我我想，我不确定，但是，

1447
00:44:43,330 --> 00:44:45,610
0,660 660,1140 1320,1830 1830,2010 2010,2280
thought, {} I'm not sure

1448
00:44:45,610 --> 00:44:46,520
0,390
but,|
|

1449
00:44:46,520 --> 00:44:49,250
0,270 270,270 270,1530 1560,2130 2160,2730
{} I understood {} client
据我所知，客户读到的内容就像是会议线索有粘性，

1450
00:44:49,250 --> 00:44:50,570
0,420 420,570 570,660 660,1080 1080,1320
reads like the session leads

1451
00:44:50,570 --> 00:44:52,280
0,90 90,810 1230,1410 1410,1530 1530,1710
were sticky,| so they would
|所以他们一般都想去一样的地方。

1452
00:44:52,280 --> 00:44:53,660
0,360 390,570 570,1050 1050,1260 1260,1380
like in general go to

1453
00:44:53,660 --> 00:44:54,880
0,120 120,750
the same.|
|

1454
00:44:54,970 --> 00:44:59,230
0,510 1140,1980 2040,3930 3930,4020 4020,4260
Yeah {you,know} but, of course
是的，你知道，但是，当然可能会有一点，

1455
00:44:59,230 --> 00:45:00,100
0,300 300,510 510,600 600,690 690,870
there might be a little

1456
00:45:00,100 --> 00:45:01,090
0,180 180,330 330,690 690,840 840,990
bit of,| it might be
|这可能是一份快速的网络请愿书或任何类似的东西

1457
00:45:01,090 --> 00:45:02,890
0,120 120,330 330,660 660,1290 1290,1800
a quick network petition or

1458
00:45:02,890 --> 00:45:04,570
0,780 810,1170 1170,1410 1410,1560 1560,1680
{} anything like it| and
|所以在这中间，你知道，

1459
00:45:04,570 --> 00:45:05,800
0,150 150,300 300,720 720,1140 1140,1230
so in between time you

1460
00:45:05,800 --> 00:45:07,360
0,150 150,540 960,1170 1170,1410 1410,1560
know the,| {} it might
|它可能已经切换到另一台服务器。

1461
00:45:07,360 --> 00:45:08,680
0,120 120,510 510,600 600,870 870,1320
have switched to another server.|
|

1462
00:45:09,740 --> 00:45:12,320
0,600 750,990 990,1380 1410,1920 2160,2580
Okay, and then. { -}|
好的，然后。|

1463
00:45:12,320 --> 00:45:13,700
0,0 0,990 990,1200 1200,1290 1290,1380
{} {In,addition} turns out the
此外，事实证明，动物园饲养员确实做了一些负载平衡，

1464
00:45:13,700 --> 00:45:14,870
0,420 420,630 630,870 870,990 990,1170
zookeeper does actually do some

1465
00:45:14,870 --> 00:45:17,570
0,180 180,750 1500,1770 1770,2040 2040,2700
load balancing,| so but but
|因此，但无论如何，这是可以正确发生的。

1466
00:45:17,900 --> 00:45:19,910
0,1110 1110,1230 1230,1350 1350,1620 1650,2010
nevertheless it can happen right.|
|

1467
00:45:20,510 --> 00:45:21,600
0,570
Right.|
正确的。|

1468
00:45:21,690 --> 00:45:23,100
0,510 570,840 840,990 990,1140 1140,1410
{} The other thing was
另一件事是你说总是写给领导，

1469
00:45:23,100 --> 00:45:25,170
0,180 180,510 510,900 930,1500 1530,2070
{} you said write {}

1470
00:45:25,440 --> 00:45:26,970
0,750 780,1170 1170,1290 1290,1410 1410,1530
always always go to the

1471
00:45:26,970 --> 00:45:29,920
0,720 1470,2520
leader, {}|
|

1472
00:45:29,920 --> 00:45:32,830
0,660 660,1230 1350,1680 1680,2340 2370,2910
and then the leader {}
然后领导用zxid回应，

1473
00:45:32,860 --> 00:45:34,570
0,840 840,930 930,1200 1200,1380 1380,1710
responded with {zxid - -},|
|

1474
00:45:34,630 --> 00:45:36,880
0,510 930,1620 1620,1710 1710,1950 1950,2250
that doesn't the leader have
这并不是说领导人在回应之前必须先达成共识，

1475
00:45:36,880 --> 00:45:39,340
0,300 300,840 1230,1560 1560,2100 2100,2460
to first reach consensus before

1476
00:45:39,340 --> 00:45:40,880
0,660 660,1080
responding, {}|
|

1477
00:45:41,120 --> 00:45:42,760
0,240 240,360 360,870
or in this.|
或者在这里面。|

1478
00:45:42,980 --> 00:45:45,290
0,420 420,1110 1110,1200 1200,1440 1440,2310
{} Yeah, yeah, okay,| but,
是啊，是啊，好吧，|但是，我想是的，所以，

1479
00:45:45,920 --> 00:45:47,120
0,570 570,690 690,870 870,1200 1200,1200
yes I guess, so, {}|
|

1480
00:45:47,990 --> 00:45:49,280
0,90 90,270 270,630 630,1110 1110,1290
you know just to {commit,it},|
你知道，只要承诺就行了，|

1481
00:45:49,280 --> 00:45:52,040
0,600 600,870 870,1140 1140,1560 2010,2760
otherwise {it,is} uncommitted, right, {}|
否则就没有承诺了，对，|

1482
00:45:52,040 --> 00:45:54,380
0,780 810,1290 1290,1350 1350,1800 1800,2340
I think the exact protocol,|
我认为确切的协议是，|

1483
00:45:54,680 --> 00:45:56,060
0,150 150,360 360,1020 1020,1290 1290,1380
{} I'm abstracting away a
我在协议的细节上做了一点抽象，

1484
00:45:56,060 --> 00:45:57,350
0,210 210,450 450,660 660,990 990,1290
little bit in the details

1485
00:45:57,350 --> 00:45:58,310
0,90 90,180 180,660 660,780 780,960
of the protocol,| I'm just
|我只想略述一下它是如何工作的。

1486
00:45:58,310 --> 00:45:59,660
0,150 150,240 240,720 720,1230 1230,1350
going to sketch how it

1487
00:45:59,660 --> 00:46:00,600
0,570
works.|
|

1488
00:46:00,780 --> 00:46:02,310
0,600 630,810 810,1080 1080,1200 1200,1530
{} I believe you're right,|
我相信你是对的，|

1489
00:46:02,310 --> 00:46:03,810
0,60 60,180 180,990 1110,1290 1290,1500
you know that it must
您知道它必须返回，但只有在您知道条目真正提交之后才能返回。

1490
00:46:03,810 --> 00:46:05,250
0,420 420,540 540,810 810,1350 1350,1440
return but only after you

1491
00:46:05,250 --> 00:46:06,750
0,150 150,270 270,810 810,1020 1020,1500
know the entries really committed.|
|

1492
00:46:08,310 --> 00:46:10,020
0,330 360,840 870,1140 1140,1410 1410,1710
Then, {} sorry last thing,|
然后，对不起，最后一件事，|

1493
00:46:10,080 --> 00:46:12,240
0,600 990,1110 1110,1500 1500,1830 1830,2160
{ -} you said it
你说过它总是给领导的，

1494
00:46:12,240 --> 00:46:13,290
0,270 270,450 450,540 540,630 630,1050
always goes to the leader,|
|

1495
00:46:13,320 --> 00:46:14,370
0,210 210,300 300,630 630,750 750,1050
but I think the paper
但我认为报纸描述了它可能会被追随者接受，

1496
00:46:14,370 --> 00:46:15,870
0,780 780,930 930,1080 1080,1230 1230,1500
described it could go to

1497
00:46:15,900 --> 00:46:16,950
0,510 510,570 570,810 810,870 870,1050
followers,| or write to go
|或者写给追随者，然后被阅读。

1498
00:46:16,950 --> 00:46:17,730
0,120 120,210 210,540 540,630 630,780
to a follower and then

1499
00:46:17,730 --> 00:46:19,200
0,180 180,450 570,990 990,1260 1260,1470
be read.| But then ends
|但最后落到了领头羊的手里，对吧。

1500
00:46:19,200 --> 00:46:20,430
0,180 180,300 300,390 390,720 720,1230
up to the leader, right.|
|

1501
00:46:21,630 --> 00:46:22,440
0,150 150,270 270,540 540,630 630,810
So it ends it go
所以它结束了，去找领头羊。

1502
00:46:22,440 --> 00:46:25,200
0,90 90,180 180,570 1410,2340
to the leader.| Thanks.|
|谢谢。|

1503
00:46:25,200 --> 00:46:27,510
0,390 1260,1470 1470,1710 1710,1800 1800,2310
Yeah.| {} Just to clarify
嗯。|只是为了澄清一下，当你说等待zxid时，比如第二个追随者或第二个，

1504
00:46:27,510 --> 00:46:28,980
0,210 210,360 360,600 600,1020 1020,1470
when you say wait for

1505
00:46:28,980 --> 00:46:30,420
0,240 240,450 450,990 1020,1350 1350,1440
{zxid - -} like for

1506
00:46:30,420 --> 00:46:32,280
0,360 360,510 510,870 870,1440 1440,1860
example the second follower or

1507
00:46:32,520 --> 00:46:33,660
0,330 330,600 600,750 750,1020 1020,1140
second,| when we wait for
|当我们等待zxid时，我们实际上是在等待它被提交，

1508
00:46:33,660 --> 00:46:34,980
0,150 150,540 540,660 660,1020 1020,1320
the zxid, we're actually waiting

1509
00:46:34,980 --> 00:46:36,030
0,120 120,210 210,270 270,390 390,1050
for it to be committed,|
|

1510
00:46:36,210 --> 00:46:38,340
0,390 390,630 630,1320 1410,1710 1710,2130
it's not sufficient to just
仅仅得到是不够的。

1511
00:46:38,340 --> 00:46:39,480
0,150 150,330 330,570 570,840 840,1140
get.| {} It {must,be} committed
|它肯定还没有被承诺。

1512
00:46:39,480 --> 00:46:40,280
0,300
yet.|
|

1513
00:46:40,340 --> 00:46:41,320
0,210 210,420
Got it.|
明白了。|

1514
00:46:42,960 --> 00:46:44,910
0,270 270,690 720,1200 1230,1560 1560,1950
Wait, but {} would like
等等，但我希望到那时它已经犯下了

1515
00:46:45,240 --> 00:46:46,590
0,300 300,450 450,570 570,690 690,1350
it would have been committed

1516
00:46:46,830 --> 00:46:47,880
0,300 300,390 390,690 690,810 810,1050
by the time| it was
|这就像一个客户不会得到一个未承诺的zxid权利，就像以前一样。

1517
00:46:47,910 --> 00:46:50,310
0,450 780,1080 1080,1590 1590,1920 1920,2400
like a client wouldn't get

1518
00:46:50,340 --> 00:46:51,900
0,180 180,930 930,1110 1110,1320 1320,1560
an uncommitted {zxid - -}

1519
00:46:51,900 --> 00:46:53,640
0,600 840,1020 1020,1500 1530,1740 1740,1740
right, like ever, like.| Oh
|哦，是的，但这是正确的，

1520
00:46:53,640 --> 00:46:55,230
0,330 330,450 450,690 690,1530 1530,1590
yeah, but just {that's -}

1521
00:46:55,230 --> 00:46:57,450
0,390 750,1380 1380,1590 1590,2040 2040,2220
correct,| {} so if you
|所以如果你知道这一点。

1522
00:46:57,450 --> 00:47:00,060
0,240 240,660 930,1560 1560,1860
know the this point.|
|

1523
00:47:01,260 --> 00:47:02,670
0,180 180,330 330,840 840,1020 1020,1410
At this point, the follower
此时，关注者看到zxid

1524
00:47:02,670 --> 00:47:05,430
0,450 450,1470 1470,1800 1800,2400 2610,2760
sees {zxid -}| and the
|并且写入是在该特定的ZXID中，

1525
00:47:05,430 --> 00:47:06,450
0,270 270,390 390,510 510,660 660,1020
write is in that particular

1526
00:47:06,450 --> 00:47:08,010
0,420 420,930 960,1230 1230,1350 1350,1560
{zxid -},| now it must
|现在肯定是有人犯下了罪，

1527
00:47:08,010 --> 00:47:09,180
0,150 150,270 270,750 750,1080 1080,1170
have been committed,| because you
|因为你知道客户不可能得到那个zxid

1528
00:47:09,180 --> 00:47:10,170
0,120 120,240 240,570 570,810 810,990
know the client could not

1529
00:47:10,170 --> 00:47:11,340
0,120 120,420 420,600 600,780 780,1170
have gotten that {zxid -}|
|

1530
00:47:11,340 --> 00:47:12,690
0,480 480,570 570,720 720,960 960,1350
unless you know that option
除非您知道zxid的选项已提交。

1531
00:47:12,690 --> 00:47:14,280
0,240 240,630 630,990 990,1260 1260,1590
of {zxid -} was committed.|
|

1532
00:47:17,350 --> 00:47:18,360
0,450
Thanks.|
谢谢。|

1533
00:47:18,760 --> 00:47:20,920
0,570 780,1110 1110,1560 1590,1770 1770,2160
{} Also, so when you
此外，当你说从你的读数中你得到了陈旧的数据，

1534
00:47:20,920 --> 00:47:23,290
0,360 360,1290 1500,1830 1830,1950 1950,2370
say that from the read

1535
00:47:23,290 --> 00:47:24,940
0,240 240,750 750,1020 1020,1290 1290,1650
you you get stale data,|
|

1536
00:47:24,940 --> 00:47:26,740
0,270 270,570 570,720 720,1230 1260,1800
so like the last basic
所以就像最后一支基本的箭一样，

1537
00:47:26,770 --> 00:47:28,510
0,360 600,900 900,1260 1260,1380 1380,1740
arrow,| {} but the client
|但是在读请求中的客户端，

1538
00:47:28,510 --> 00:47:30,220
0,390 390,660 660,810 810,1140 1170,1710
here in the read request,|
|

1539
00:47:30,220 --> 00:47:31,930
0,180 180,780 780,990 990,1260 1260,1710
it supplied these {zxid -}
它在其中提供了这些zxid，

1540
00:47:31,930 --> 00:47:34,090
0,300 300,450 480,1140 1500,1980 1980,2160
within it,| so it's as
|因此，就好像客户故意想要日志中的那个位置一样，

1541
00:47:34,090 --> 00:47:36,310
0,180 180,270 270,660 660,1410 1620,2220
if the client knowingly exactly

1542
00:47:36,310 --> 00:47:38,020
0,510 510,720 720,1230 1230,1440 1470,1710
wanted that location in the

1543
00:47:38,020 --> 00:47:38,960
0,540
log,|
|

1544
00:47:38,990 --> 00:47:40,400
0,270 270,660 660,840 840,1050 1050,1410
that had {zxid - -}
它以zxid为索引，

1545
00:47:40,400 --> 00:47:42,800
0,360 390,570 570,1140 1590,2010 2010,2400
as its index,| so didn't
|那么它不是故意请求日志特定前缀的前缀吗？

1546
00:47:42,800 --> 00:47:44,720
0,240 240,750 750,1050 1290,1710 1710,1920
it knowingly just request that

1547
00:47:44,720 --> 00:47:46,490
0,450 450,690 690,1230 1230,1620 1620,1770
prefix that specific prefix of

1548
00:47:46,490 --> 00:47:48,380
0,90 90,420 630,1410 1410,1650 1650,1890
the log.| No, but really
|不是，但是你知道这个zxid实际上说了什么吗

1549
00:47:48,380 --> 00:47:49,370
0,390 390,480 480,540 540,690 690,990
says you know what this

1550
00:47:49,370 --> 00:47:51,680
0,390 390,810 810,1110 1110,1830 1920,2310
zxid actually says| like it's
|就像你知道的时间倒流的计数器。

1551
00:47:51,680 --> 00:47:53,360
0,600 600,1260 1260,1320 1320,1470 1470,1680
basically counters you know going

1552
00:47:53,360 --> 00:47:54,540
0,240 240,330 330,720
back in time.|
|

1553
00:47:55,320 --> 00:47:57,570
0,810 810,1110 1110,1260 1260,2040 2040,2250
And, {} so {the,zxid} like
所以，就像你知道你拥有的zxid，

1554
00:47:57,570 --> 00:47:58,530
0,60 60,150 150,360 360,690 720,960
you know you have,| as
|作为追随者，你必须返回到你的结果

1555
00:47:58,530 --> 00:47:59,850
0,90 90,720 780,960 960,1170 1170,1320
a follower, you have to

1556
00:47:59,850 --> 00:48:01,260
0,360 360,420 420,630 630,1200 1230,1410
return to your result| that
|这至少通过ZXID结束了日志的前缀，

1557
00:48:01,260 --> 00:48:03,060
0,210 210,600 600,990 990,1110 1110,1800
at least concludes the prefix

1558
00:48:03,120 --> 00:48:04,530
0,270 270,390 390,780 780,1140 1140,1410
of the log through {zxid

1559
00:48:04,530 --> 00:48:06,180
0,660 960,1230 1230,1380 1380,1530 1530,1650
-},| {} you might have
|你可能会有更多，那也没问题，

1560
00:48:06,180 --> 00:48:07,680
0,450 480,630 630,750 750,1020 1020,1500
more, that be fine too,|
|

1561
00:48:07,740 --> 00:48:09,390
0,210 210,570 570,960 960,1440 1440,1650
but {at,least} {zxid -}| and
但至少zxid|而这只是阻止了你回顾过去的一个案例。

1562
00:48:09,390 --> 00:48:10,680
0,210 210,360 360,720 720,1020 1020,1290
this just stops one case

1563
00:48:10,680 --> 00:48:11,490
0,180 180,300 300,510 510,750 750,810
where you read back in

1564
00:48:11,490 --> 00:48:13,280
0,330
time.|
|

1565
00:48:13,280 --> 00:48:14,200
0,240 240,390
{Okay,awesome}, {thank,you}.|
好的，太棒了，谢谢。|

1566
00:48:16,090 --> 00:48:18,040
0,390 390,870 990,1590 1590,1770 1770,1950
Okay, so now you might
好的，所以现在你可能会想，

1567
00:48:18,040 --> 00:48:19,160
0,570
wonder,|
|

1568
00:48:19,680 --> 00:48:20,640
0,390 390,510 510,630 630,810 810,960
{} you know, so this
你知道，这显然不能提供线性化

1569
00:48:20,640 --> 00:48:21,750
0,300 300,450 450,630 630,930 930,1110
clearly does not provide {linearizability

1570
00:48:21,750 --> 00:48:23,130
0,180 180,720 720,870 870,1080 1080,1380
- -}| and one reason
|人们对线性化感到兴奋的一个原因是，

1571
00:48:23,130 --> 00:48:24,180
0,270 270,390 390,720 720,900 900,1050
people are excited about the

1572
00:48:24,180 --> 00:48:25,500
0,210 210,720 720,990 990,1080 1080,1320
{linearizability,is -},| because it behaves
|因为它的行为就像一台机器，

1573
00:48:25,500 --> 00:48:26,430
0,150 150,210 210,450 450,840 840,930
like a single machine,| so
|所以它更容易编程，

1574
00:48:26,430 --> 00:48:27,900
0,150 150,390 390,480 480,900 990,1470
it's easier to program,| you
|你知道你确实放了，你确实得到了，

1575
00:48:27,900 --> 00:48:30,180
0,180 180,450 450,660 660,2100 2100,2280
know you {do,put}, {you,do,get},| {you,roughly}
|你大概知道你会得到什么，

1576
00:48:30,180 --> 00:48:31,080
0,120 120,270 270,390 390,570 570,900
know what you're gonna get,|
|

1577
00:48:31,610 --> 00:48:33,530
0,660 660,1140 1140,1290 1290,1470 1470,1920
{} and no pun intended,|
我没有双关语的意思，|

1578
00:48:33,800 --> 00:48:36,500
0,660 690,870 870,2190 2190,2310 2310,2700
{} but here you certainly
但在这里，你肯定有一个模型的编程模型不同于单一的机器。

1579
00:48:36,500 --> 00:48:38,000
0,420 420,510 510,1020 1020,1110 1110,1500
have a model of programming

1580
00:48:38,000 --> 00:48:39,110
0,330 330,480 480,900 900,1050 1050,1110
model is different from a

1581
00:48:39,110 --> 00:48:40,280
0,240 240,660
single machine.|
|

1582
00:48:40,560 --> 00:48:42,360
0,330 330,840 900,1410 1410,1530 1530,1800
And so, {} you know
所以，你知道如何对这个东西进行编程。

1583
00:48:42,390 --> 00:48:43,500
0,210 210,300 300,420 420,900 900,1110
how do you program this

1584
00:48:43,500 --> 00:48:44,360
0,270
thing.|
|

1585
00:48:44,700 --> 00:48:45,750
0,330 330,540 540,630 630,720 720,1050
And you know it turns
你知道，事实证明，

1586
00:48:45,750 --> 00:48:47,010
0,360 360,570 570,750 750,1140 1140,1260
out that,| there basically the
|基本上，你知道的规则，你知道的正确的定义，动物园管理员有

1587
00:48:47,010 --> 00:48:48,750
0,780 810,900 900,990 990,1320 1320,1740
rules you know the correct

1588
00:48:48,750 --> 00:48:50,850
0,600 600,840 840,1020 1020,1470 1470,2100
definition that {you,know} zookeeper has|
|

1589
00:48:51,240 --> 00:48:53,430
0,540 570,1380 1590,1920 1920,2010 2010,2190
are basically you can think
基本上你可以把它想象成那些足够好的东西，实际上是为了帮助编程而做的。

1590
00:48:53,430 --> 00:48:54,390
0,120 120,210 210,480 510,660 660,960
of it like those good

1591
00:48:54,390 --> 00:48:56,310
0,600 630,780 780,1080 1080,1560 1560,1920
enough to actually do {}

1592
00:48:56,430 --> 00:48:58,500
0,330 330,990 1170,1290 1290,1800 1800,2070
for purpose to do help

1593
00:48:58,500 --> 00:48:59,460
0,450
programming.|
|

1594
00:48:59,720 --> 00:49:00,530
0,180 180,420 420,600 600,750 750,810
And so I want to
因此，我想谈一谈这一点。

1595
00:49:00,530 --> 00:49:01,220
0,120 120,150 150,360 360,480 480,690
talk a little bit about

1596
00:49:01,220 --> 00:49:02,240
0,540
that.|
|

1597
00:49:12,470 --> 00:49:13,730
0,180 180,600 600,810 810,1080 1080,1260
So the real point is
所以真正的问题是，

1598
00:49:13,730 --> 00:49:16,010
0,360 630,750 750,1290 1290,1470 1470,2280
that,| you know with linearizability,|
|你知道，有了线性化，|

1599
00:49:16,010 --> 00:49:17,000
0,240 240,420 420,750 750,900 900,990
it's pretty clear that you
很明显，您知道这有助于编程

1600
00:49:17,000 --> 00:49:19,010
0,300 510,960 960,1200 1200,1440 1440,2010
know {} that helps programming|
|

1601
00:49:19,010 --> 00:49:20,900
0,420 420,750 990,1260 1260,1350 1350,1890
and writing {intuitive -} programs,|
以及编写直观的程序，|

1602
00:49:21,020 --> 00:49:21,650
0,240 240,390 390,420 420,570 570,630
you think are going to
你认为会有一点不同

1603
00:49:21,650 --> 00:49:23,270
0,60 60,420 420,930 1140,1500 1500,1620
be slightly different| and we
|我们想要了解的是，如果事情进展顺利，

1604
00:49:23,270 --> 00:49:24,530
0,120 120,180 180,660 660,960 960,1260
want to understand actually if

1605
00:49:24,560 --> 00:49:26,690
0,330 330,630 630,810 810,1230 1620,2130
things work out well, {}|
|

1606
00:49:26,690 --> 00:49:29,060
0,660 690,1350 1350,1530 1530,1740 1950,2370
and whether it's like {pain,in}
而它是否像网络程序中的痛苦一样，基本上是完全无法使用的。

1607
00:49:29,060 --> 00:49:30,260
0,60 60,360 360,750 750,930 930,1200
the network program is basically

1608
00:49:30,260 --> 00:49:31,680
0,450 450,990
completely unusable.|
|

1609
00:49:32,280 --> 00:49:34,350
0,540 630,1110 1530,1770 1770,1920 1920,2070
{} So, {} so let's
那么，让我们来看看这篇论文中提到的一个关键例子。

1610
00:49:34,350 --> 00:49:35,220
0,180 180,240 240,480 480,570 570,870
look at one of the

1611
00:49:35,220 --> 00:49:37,230
0,180 180,1140 1140,1500 1500,1770 1770,2010
key examples {} talk about

1612
00:49:37,230 --> 00:49:38,380
0,60 60,150 150,630
in the paper.|
|

1613
00:49:38,500 --> 00:49:40,810
0,630 900,1530 1620,1950 1950,2100 2100,2310
{} And {} the first
我想做的第一件事是

1614
00:49:40,810 --> 00:49:41,350
0,150 150,210 210,360 360,420 420,540
thing I want to do

1615
00:49:41,350 --> 00:49:42,790
0,150 150,630 630,1080 1080,1140 1140,1440
is| basically ignore the sync
|基本上忽略同步操作，

1616
00:49:42,790 --> 00:49:44,470
0,540 540,870 870,1020 1020,1140 1140,1680
operation,| because you can make
|因为只需发出SYNC命令，您就可以使每个操作真正线性化，

1617
00:49:44,470 --> 00:49:47,170
0,720 750,1110 1110,1680 1680,2010 2010,2700
{} every operation actually linearizable

1618
00:49:47,170 --> 00:49:48,340
0,150 150,300 300,630 630,720 720,1170
by just issuing {} sync,|
|

1619
00:49:48,840 --> 00:49:49,890
0,330 330,540 540,840 840,930 930,1050
{} like before you do
就像在你阅读之前，

1620
00:49:49,890 --> 00:49:51,600
0,90 90,450 810,1260 1260,1440 1440,1710
the read,| {} but that
|但这当然会让一切再次变得缓慢，

1621
00:49:51,600 --> 00:49:53,010
0,90 90,480 480,960 960,1290 1290,1410
of course makes everything {}

1622
00:49:53,010 --> 00:49:53,880
0,270 270,540 540,630 630,750 750,870
slow again,| and we're not
|我们得不到我们的表演，

1623
00:49:53,880 --> 00:49:54,810
0,120 120,180 180,330 330,420 420,930
going to get our performances,|
|

1624
00:49:55,050 --> 00:49:56,970
0,450 660,1470 1470,1710 1710,1860 1860,1920
so basically we want to
所以基本上我们想要避免做同步，

1625
00:49:56,970 --> 00:49:58,800
0,510 540,840 840,1110 1110,1680 1680,1830
avoid {} doing syncs,| and
|所以我要忽略同步

1626
00:49:58,800 --> 00:49:59,730
0,90 90,240 240,420 420,570 570,930
so I'm just gonna ignore

1627
00:49:59,730 --> 00:50:01,200
0,420 420,600 600,840 870,1380 1380,1470
syncs| and like program as
|喜欢程序，就像我们没有同步一样。

1628
00:50:01,200 --> 00:50:02,760
0,480 510,630 630,840 840,1080 1080,1560
if we don't have syncs.|
|

1629
00:50:04,200 --> 00:50:05,190
0,150 150,300 300,720 720,840 840,990
So let's look at the
那么让我们来看一下以下操作，

1630
00:50:05,190 --> 00:50:07,440
0,330 330,1080 1080,1470 1650,2160 2160,2250
following operations,| so here's the
|所以这是写的顺序，

1631
00:50:07,440 --> 00:50:08,940
0,240 240,780
write order,|
|

1632
00:50:13,220 --> 00:50:14,570
0,90 90,300 300,540 540,1230 1230,1350
the new couple operations| and
新的情侣行动|这就是准备好的文件的情况，

1633
00:50:14,570 --> 00:50:15,230
0,120 120,210 210,300 300,570 570,660
this is the case of

1634
00:50:15,230 --> 00:50:17,480
0,210 210,600 600,930 930,1260 1710,2250
the ready file,| so we
|因此，我们发出删除就绪文件的命令。

1635
00:50:17,480 --> 00:50:19,180
0,360 360,510 510,1200
issue a delete

1636
00:50:20,470 --> 00:50:22,380
0,390 390,1050
{of,the,ready} file.|
|

1637
00:50:23,420 --> 00:50:24,440
0,240 240,330 330,660 660,840 840,1020
So, for example, this is
那么比如说，这是一个，一个新的大师，

1638
00:50:24,440 --> 00:50:25,460
0,450
a,

1639
00:50:25,580 --> 00:50:28,760
0,540 540,1080 1080,1800 1830,2520 2550,3180
{} a new {} master,|
|

1640
00:50:28,760 --> 00:50:32,570
0,150 150,660 660,1530 1950,2760 3090,3810
that becomes, { - -}
成为，成为新的，新的领袖，

1641
00:50:32,720 --> 00:50:33,950
0,450 450,570 570,900 900,1140 1140,1230
becomes the new, {} the

1642
00:50:33,950 --> 00:50:35,990
0,180 180,780 990,1500 1500,1830 1830,2040
new leader,| um and so
|嗯，所以需要在里面写一个简短的配置信息，

1643
00:50:35,990 --> 00:50:36,980
0,210 210,360 360,600 600,660 660,990
need to write a short

1644
00:50:36,980 --> 00:50:38,960
0,690 690,1170 1170,1710 1710,1830 1830,1980
configuration {} information in it,|
|

1645
00:50:38,960 --> 00:50:40,400
0,210 210,270 270,360 360,1080 1110,1440
like you know who were
就像你知道谁是复制状态机的一部分

1646
00:50:40,400 --> 00:50:41,720
0,270 270,360 360,720
part of the,

1647
00:50:41,720 --> 00:50:44,120
0,720 1050,1590 1590,1830 1830,2220 2220,2400
the replicated state machine| and
|谁是领导者？

1648
00:50:44,120 --> 00:50:45,260
0,210 210,300 300,420 420,870 870,1140
who is the leader| and
|所以它写道，你知道一些配置文件，

1649
00:50:45,260 --> 00:50:46,040
0,150 150,300 300,540 540,660 660,780
so it writes you know

1650
00:50:46,040 --> 00:50:49,700
0,120 120,720 720,1320 1350,2070
some configuration files,| write
|写F1，写你知道的f2，写Create of Ready。

1651
00:50:49,700 --> 00:50:51,950
0,180 180,840 1170,1890 1920,2100 2100,2250
{f1 -}, write {you,know} {f2

1652
00:50:51,950 --> 00:50:57,520
0,690 3270,3870
-}, {create,of}

1653
00:50:57,800 --> 00:50:59,820
0,780
ready.|
|

1654
00:51:00,180 --> 00:51:01,060
0,90

1655
00:51:02,420 --> 00:51:04,560
0,150 150,390 390,840 840,1560
And then other followers
然后其他追随者可能是另一个阅读顺序的人

1656
00:51:04,560 --> 00:51:06,270
0,480 480,540 540,1020 1020,1500 1500,1710
might {another -} who is

1657
00:51:06,270 --> 00:51:09,140
0,90 90,300 300,810
the read order|
|

1658
00:51:11,430 --> 00:51:13,980
0,570 570,990 990,1620 1650,1920 1920,2550
begin {you,know,for} example {} call
开始你知道例如呼叫如果存在准备好了，

1659
00:51:14,100 --> 00:51:17,540
0,1080 1320,2370
if exists

1660
00:51:18,020 --> 00:51:19,360
0,810
ready,|
|

1661
00:51:22,650 --> 00:51:23,700
0,180 180,360 360,630 630,780 780,1050
and so {zookeeper -} actually
所以动物园饲养员实际上是在运作

1662
00:51:23,700 --> 00:51:27,180
0,300 300,750 750,1200 1200,2220 2700,3480
{} operation exists| and {}
|如果已经准备好了，

1663
00:51:27,180 --> 00:51:29,580
0,570 600,1260 1260,1800 1800,2250 2250,2400
if ready exists,| then it
|那么这将是一个真实的

1664
00:51:29,580 --> 00:51:31,770
0,180 180,450 450,810 810,1440 1590,2190
will be a true {}|
|

1665
00:51:31,770 --> 00:51:34,020
0,330 330,1410 1410,1800 1860,2100 2100,2250
and otherwise not and so
否则就不会了，所以你必须等待，

1666
00:51:34,020 --> 00:51:35,130
0,300 300,450 450,600 600,690 690,1110
you have to {} wait,|
|

1667
00:51:35,520 --> 00:51:36,840
0,360 360,510 510,840 840,1140 1140,1320
{} so let's ignore that
所以让我们暂时忽略这个案例，

1668
00:51:36,840 --> 00:51:37,740
0,240 240,360 360,390 390,720 720,900
case for a second,| let's
|假设你认识第二个客户，

1669
00:51:37,740 --> 00:51:39,120
0,360 360,600 600,720 720,870 870,1380
assume that you know the

1670
00:51:39,300 --> 00:51:40,650
0,360 360,810 810,990 990,1200 1200,1350
second clients,| so here was
|这是一个客户端执行写入操作的示例，

1671
00:51:40,650 --> 00:51:42,000
0,180 180,480 480,630 630,930 930,1350
the one for one client

1672
00:51:42,000 --> 00:51:43,860
0,390 390,600 600,1080 1080,1470 1620,1860
did write operations,| {second,client} read
|第二个客户端读取操作

1673
00:51:43,860 --> 00:51:46,170
0,690 1140,1320 1320,1920 1920,2220 2220,2310
operations| and then if it
|如果它真的存在，

1674
00:51:46,170 --> 00:51:49,020
0,420 420,930 2040,2190 2190,2580 2580,2850
exists,| then the client reads
|然后，客户端读取f1，然后读取f2。

1675
00:51:49,020 --> 00:51:50,160
0,150 150,690
{f1 -}

1676
00:51:50,420 --> 00:51:52,520
0,360 360,540 540,690 690,1080
{and,then} reads {f2 -}.|
|

1677
00:51:55,200 --> 00:51:57,210
0,240 240,720 870,1170 1170,1740 1800,2010
And so the thing that
所以你知道我们想要了解的事情

1678
00:51:57,210 --> 00:51:58,950
0,720 750,1230 1320,1560 1560,1680 1680,1740
you know we want to

1679
00:51:58,950 --> 00:52:00,420
0,540 540,900 900,990 990,1080 1080,1470
understand| like you know what
|就像你知道f1可以读取什么值，可以返回一样。

1680
00:52:00,420 --> 00:52:02,040
0,480 480,630 630,810 810,1200 1380,1620
values could {f1 -} this

1681
00:52:02,040 --> 00:52:03,900
0,450 480,630 630,750 750,1320
read that can return.|
|

1682
00:52:11,850 --> 00:52:13,110
0,540 540,690 690,810 810,930 930,1260
The thing that we worry
我们担心的是正确的事情，

1683
00:52:13,110 --> 00:52:14,520
0,360 360,630 630,990 990,1170 1170,1410
about correct,| is it could
|它可能会返回之前在此完成的写入的一些结果，

1684
00:52:14,520 --> 00:52:17,760
0,1290 1440,2220 2220,2580 2580,3030 3060,3240
return could return some {}

1685
00:52:17,760 --> 00:52:18,600
0,330 330,420 420,510 510,750 750,840
result of a write that

1686
00:52:18,600 --> 00:52:20,160
0,150 150,330 330,630 630,1200 1200,1560
was done much earlier here,|
|

1687
00:52:25,750 --> 00:52:26,830
0,210 210,330 330,570 570,660 660,1080
and we must have observed
我们一定已经注意到了这段文字。

1688
00:52:26,830 --> 00:52:28,020
0,180 180,630
this write.|
|

1689
00:52:33,230 --> 00:52:34,670
0,180 180,360 360,480 480,840 840,1440
I think the paper mentions
我想报纸上提到了，

1690
00:52:34,670 --> 00:52:36,890
0,270 300,930 1200,1590 1590,1890 1890,2220
that,| {} the reader can
|读者可以观看某些内容，并在发生变化时得到通知。

1691
00:52:36,890 --> 00:52:38,870
0,840 870,1380 1380,1740 1740,1890 1890,1980
watch certain things and be

1692
00:52:38,870 --> 00:52:42,140
0,690 690,1110 1440,2520 2940,3150 3150,3270
notified of changes.| Yeah, so
|是的，让我们假设文件确实存在，

1693
00:52:42,140 --> 00:52:43,010
0,180 180,450 450,600 600,810 810,870
let's assume that actually the

1694
00:52:43,010 --> 00:52:44,540
0,270 270,600 600,750 750,1170 1170,1530
file exists,| so created actually
|所以创造实际上是立即成功的，

1695
00:52:44,540 --> 00:52:46,190
0,390 390,870 900,1080 1080,1530 1530,1650
succeeds immediately,| so let's talk
|所以让我们稍后再来讨论一下这些通知。

1696
00:52:46,190 --> 00:52:47,060
0,150 150,210 210,750 750,840 840,870
about the notifications in a

1697
00:52:47,060 --> 00:52:47,960
0,360
second.|
|

1698
00:52:49,300 --> 00:52:51,820
0,120 120,300 300,900 930,1890 1920,2520
So this exists returns immediately,|
所以这个存在立即返回，|

1699
00:52:52,530 --> 00:52:54,300
0,270 270,600 600,1290 1380,1530 1530,1770
no watches evolved, it just
没有手表进化，它只是存在

1700
00:52:54,300 --> 00:52:56,010
0,510 960,1110 1110,1260 1260,1350 1350,1710
exist| and then we do
|然后我们执行第二个客户端读取F1。

1701
00:52:56,010 --> 00:52:56,850
0,210 210,450 450,720 720,840 840,840
that second client does a

1702
00:52:56,850 --> 00:52:58,280
0,240 240,300 300,510 510,810
read of {f1 -}.|
|

1703
00:52:59,510 --> 00:53:00,620
0,270 270,420 420,660 660,780 780,1110
{} I think it should
我认为它应该读第一个客户写的东西，

1704
00:53:00,620 --> 00:53:02,450
0,240 240,750 750,1230 1260,1650 1650,1830
read whatever was written by

1705
00:53:02,450 --> 00:53:03,860
0,150 150,480 480,900 900,1260 1260,1410
the first client,| because the
|因为操作是在FIFO中进行的。

1706
00:53:03,860 --> 00:53:05,960
0,570 570,810 810,1620
operations are {in,FIFO}.|
|

1707
00:53:06,250 --> 00:53:07,720
0,1110
Yeah,
是啊，对，

1708
00:53:07,810 --> 00:53:09,460
0,420 450,660 660,1080 1260,1470 1470,1650
right,| so the I think
|所以我认为真正有意义的是。

1709
00:53:09,460 --> 00:53:10,480
0,90 90,330 330,510 510,660 660,1020
the real thing that actually

1710
00:53:10,480 --> 00:53:12,860
0,120 120,1350
does. {}|
|

1711
00:53:14,020 --> 00:53:15,340
0,210 210,540 570,810 810,1020 1020,1320
If we saw this option,
如果我们看到了这个选项，那么对于前面的一些内容来说，正确的值是什么

1712
00:53:15,340 --> 00:53:16,720
0,270 270,660 660,1080 1080,1170 1170,1380
what value correctly for some

1713
00:53:16,720 --> 00:53:17,980
0,210 210,570 570,750 750,900 900,1260
write earlier| that would mean
|这将意味着我们在回顾过去，对吧。

1714
00:53:17,980 --> 00:53:18,850
0,120 120,270 270,540 540,780 780,870
that we're reading back in

1715
00:53:18,850 --> 00:53:20,260
0,330 480,900
time, right.|
|

1716
00:53:20,600 --> 00:53:21,770
0,450 450,720 720,810 810,990 990,1170
And that is just not
这是不允许的，

1717
00:53:21,770 --> 00:53:23,600
0,540 570,720 720,900 900,1260 1290,1830
allowed,| you know the rules
|你知道规则实际上是禁止的，

1718
00:53:23,600 --> 00:53:26,960
0,480 480,870 1560,2280 2370,2880 2880,3360
actually {forbid,that},| {} this read
|你知道这个读数必须遵守你知道这个写的价值，

1719
00:53:26,990 --> 00:53:28,760
0,210 210,570 570,1380 1410,1530 1530,1770
{you,know} must observe you know

1720
00:53:28,760 --> 00:53:30,920
0,480 480,480 1260,1890 1890,1950 1950,2160
this {} value of that

1721
00:53:30,920 --> 00:53:32,870
0,300 300,1050 1080,1500 1500,1830 1830,1950
write,| because this read the
|因为该读取先前的读取存在观察该写入权限，

1722
00:53:32,870 --> 00:53:34,940
0,450 450,780 780,1380 1410,1860 1860,2070
previous read exists observe this

1723
00:53:34,940 --> 00:53:36,800
0,420 450,750 750,1080 1110,1260 1260,1860
write right,| so we know
|所以我们知道，您知道这个eXist id一定已经看到了该create对应的zxid。

1724
00:53:37,040 --> 00:53:38,780
0,540 780,900 900,1050 1050,1260 1260,1740
that you know this exist

1725
00:53:38,780 --> 00:53:39,860
0,360 360,600 600,720 720,1020 1020,1080
id must have seen the

1726
00:53:39,860 --> 00:53:41,900
0,300 300,510 510,960 960,1890 1890,2040
{zxid - -} corresponding by

1727
00:53:41,900 --> 00:53:42,980
0,180 180,720
that create.|
|

1728
00:53:43,580 --> 00:53:44,420
0,120 120,240 240,420 420,690 690,840
And so that means that
也就是说，这个读操作必须看到最后一次写操作，

1729
00:53:44,420 --> 00:53:47,500
0,210 210,630 660,1260 1620,2520
this read will {}

1730
00:53:47,560 --> 00:53:49,900
0,540 570,1050 1050,1140 1140,1500 1500,2340
{} must you know {}

1731
00:53:50,050 --> 00:53:52,270
0,990 990,1200 1200,1320 1320,1800 1800,2220
must see the last write,|
|

1732
00:53:52,270 --> 00:53:53,260
0,90 90,180 180,390 390,510 510,990
you know that was performed
你知道，这是按照总的顺序进行的，

1733
00:53:53,260 --> 00:53:54,130
0,60 60,150 150,420 420,750 750,870
in the total order,| that
|你知道吗，这个特别的创造

1734
00:53:54,130 --> 00:53:55,540
0,630 630,720 720,810 810,990 990,1410
proceeded you know that particular

1735
00:53:55,540 --> 00:53:57,910
0,420 420,570 570,930 1320,1800 1860,2370
create| and so the last
|在此之前的最后一个写入关键顺序是这个特定的写入权限，

1736
00:53:57,910 --> 00:54:00,160
0,300 300,870 960,1530 1530,1950 1950,2250
write {you,know} critical order before

1737
00:54:00,160 --> 00:54:01,480
0,210 210,330 330,540 540,930 930,1320
that is this particular write

1738
00:54:01,660 --> 00:54:03,160
0,450 540,960 960,1140 1140,1230 1230,1500
right,| because all the writes
|因为所有写入实际上都是可线性化的。

1739
00:54:03,160 --> 00:54:04,780
0,120 120,480 480,900
are actually linearizable.|
|

1740
00:54:05,280 --> 00:54:05,910
0,120 120,210 210,330 330,570 570,630
And so it must be
因此，必须是该读F1观察到写F1的结果的情况。

1741
00:54:05,910 --> 00:54:06,960
0,90 90,420 420,570 570,750 750,1050
the case that this read

1742
00:54:06,960 --> 00:54:08,640
0,390 390,990 990,1290 1290,1590 1590,1680
f1 observes the result of

1743
00:54:08,640 --> 00:54:10,180
0,270 270,510 510,660 660,960
the write {f1 -}.|
|

1744
00:54:10,240 --> 00:54:11,440
0,210 210,360 360,480 480,930 930,1200
So this is nice, correct,|
所以这很好，对吧，|

1745
00:54:11,440 --> 00:54:13,660
0,570 750,1200 1230,1320 1320,1740 1920,2220
because if you know some
因为如果你知道某个新领导人成为了初选，就会得到一个配置文件，

1746
00:54:13,660 --> 00:54:15,700
0,180 180,750 780,1380 1380,1470 1470,2040
new leader became the primary,

1747
00:54:15,700 --> 00:54:17,710
0,240 240,570 570,1230 1230,1800 1890,2010
get raised configuration file,| you
|你知道我们肯定知道，

1748
00:54:17,710 --> 00:54:18,730
0,90 90,210 210,390 390,510 510,1020
know we know for sure,|
|

1749
00:54:18,730 --> 00:54:19,540
0,150 150,480 480,630 630,750 750,810
that actually we're going to
实际上，我们将看到由新领导创建的最后一个配置文件。

1750
00:54:19,540 --> 00:54:21,370
0,450 450,630 630,900 900,1500 1500,1830
see that last configuration file

1751
00:54:21,370 --> 00:54:22,300
0,180 180,330 330,630 630,750 750,930
that was created by that

1752
00:54:22,360 --> 00:54:24,080
0,300 300,570 570,810 810,1260
by that new leader.|
|

1753
00:54:26,020 --> 00:54:26,950
0,150 150,240 240,450 450,870 870,930
So we see here, an
所以我们在这里看到了一个例子，这些规则是经过精心挑选的，

1754
00:54:26,950 --> 00:54:28,180
0,420 420,540 540,720 720,1050 1050,1230
example that these rules are

1755
00:54:28,180 --> 00:54:30,370
0,480 480,1230 1590,1800 1800,2130 2130,2190
carefully chosen,| {} that you
|你知道一些你可能关心的事情，

1756
00:54:30,370 --> 00:54:31,180
0,120 120,390 390,510 510,630 630,810
know things that you might

1757
00:54:31,180 --> 00:54:32,680
0,210 210,720 750,1200 1200,1380 1380,1500
care about,| {} if you're
|如果您正在编写一个配置服务器，那么它确实是可行的。

1758
00:54:32,680 --> 00:54:34,090
0,270 270,360 360,870 870,1260 1260,1410
writing a configuration servers that

1759
00:54:34,090 --> 00:54:35,800
0,300 300,630 630,1230
actually certainly workout.|
|

1760
00:54:36,330 --> 00:54:37,780
0,330 360,840

1761
00:54:38,140 --> 00:54:39,850
0,300 300,900 900,1080 1080,1620 1620,1710
Sorry, I I might have
抱歉，我我之前可能没听懂你在说什么，

1762
00:54:39,850 --> 00:54:40,930
0,210 210,660 660,870 870,960 960,1080
not understood what you were

1763
00:54:40,930 --> 00:54:43,000
0,270 270,750 750,1200 1500,1830 1830,2070
saying before,| but in this
|但在这种情况下，如果它存在，

1764
00:54:43,000 --> 00:54:44,860
0,360 360,480 480,720 720,1410 1470,1860
case if it exists,| if
|如果检查存在就绪，

1765
00:54:44,860 --> 00:54:47,410
0,330 330,720 720,1080 1200,1920 1920,2550
checking exist ready,| couldn't read
|在Ready被删除之前不能阅读类似的东西吗？

1766
00:54:47,440 --> 00:54:49,090
0,210 210,690 690,1200 1200,1470 1470,1650
like stuff before ready was

1767
00:54:49,090 --> 00:54:50,240
0,630
deleted?|
|

1768
00:54:52,270 --> 00:54:53,470
0,270 270,750 750,810 810,960 960,1200
Okay, {all,the,writes} in the total
好的，所有的写入都按总顺序排列，

1769
00:54:53,470 --> 00:54:54,460
0,300 330,480 480,630 630,930 930,990
order,| so these writes in
|因此，这些写入按总顺序排列，

1770
00:54:54,460 --> 00:54:55,420
0,270 270,480 480,690 690,870 870,960
total order,| that write is
|该写入按总顺序进行，

1771
00:54:55,420 --> 00:54:56,500
0,60 60,300 300,630 630,750 750,1080
in total order,| that created
|以总的顺序创造出来的，

1772
00:54:56,500 --> 00:54:58,570
0,60 60,360 360,750 1650,1800 1800,2070
in total order,| so this
|因此，在另一边的这个读数已经观察到了那个创造。

1773
00:54:58,570 --> 00:54:59,560
0,450 480,660 660,750 750,840 840,990
read here on the other

1774
00:54:59,560 --> 00:55:01,150
0,300 300,480 480,960 960,1110 1110,1590
side has observed that creation.|
|

1775
00:55:02,020 --> 00:55:03,310
0,510 540,960 960,1170 1170,1230 1230,1290
So whatever {read -} is
所以不管里德要做什么

1776
00:55:03,310 --> 00:55:04,000
0,120 120,180 180,300 300,420 420,690
going to do is| go
|往回走，然后向右转，

1777
00:55:04,000 --> 00:55:05,200
0,240 240,330 330,450 450,870 870,1200
back and go {totol,order} right,|
|

1778
00:55:05,200 --> 00:55:07,030
0,570 600,990 990,1350 1350,1440 1440,1830
like you observed the last
就像你观察到的最后一次写入的总顺序一样

1779
00:55:07,030 --> 00:55:08,500
0,360 570,720 720,900 900,1140 1140,1470
write in that total order|
|

1780
00:55:08,500 --> 00:55:09,310
0,120 120,210 210,510 510,720 720,810
and at last {write -}
最后写下，F1就是这个。

1781
00:55:09,310 --> 00:55:10,240
0,150 150,360 360,480 480,660 660,930
{f1 -} is this one.|
|

1782
00:55:10,510 --> 00:55:13,300
0,300 300,780 900,1590 1590,2130
But it exists writes?|
但它确实存在，写道？|

1783
00:55:13,300 --> 00:55:14,440
0,150 150,480 480,630 630,930 960,1140
No, this is read, but
不，这是读的，但eXist观察到了这个特定的写操作。

1784
00:55:14,440 --> 00:55:16,150
0,330 330,780 780,930 930,1320 1320,1710
exist observed this particular write.|
|

1785
00:55:16,780 --> 00:55:18,910
0,690 720,1170 1170,1470 1470,1950 1950,2130
Oh, you're saying.| You, you
哦，你是说。|你，你不能回到过去，对吧，

1786
00:55:18,910 --> 00:55:19,990
0,360 360,600 600,750 750,990 990,1080
cannot read it back in

1787
00:55:19,990 --> 00:55:20,950
0,330 330,600 600,600 600,840 840,960
time, correct,| I just use
|我只是用了整个进球。

1788
00:55:20,950 --> 00:55:22,720
0,60 60,360 360,810 930,1350 1410,1770
the whole goal.| Right, but
|对，但我们怎么知道它观察到了，就是这样。

1789
00:55:22,720 --> 00:55:23,980
0,360 360,570 570,660 660,1020 1020,1260
how did we know that

1790
00:55:23,980 --> 00:55:26,590
0,750 900,1470 1470,1890 1890,2460 2460,2610
it observed, that exactly.| I
|我告诉过你，我说过就像文件存在一样，

1791
00:55:26,590 --> 00:55:27,700
0,330 330,390 390,630 660,810 810,1110
told you that, I said

1792
00:55:27,700 --> 00:55:28,930
0,210 210,300 300,540 540,1080 1080,1230
like the file existed,| so
|因此，它一定是观察到了这一点。

1793
00:55:28,930 --> 00:55:29,770
0,120 120,390 390,480 480,570 570,840
it must be the case

1794
00:55:29,770 --> 00:55:31,100
0,120 120,240 240,600 600,750
that it observed it.|
|

1795
00:55:31,520 --> 00:55:33,200
0,240 240,360 360,750 750,1230 1470,1680
Which is returned true.| But
返回TRUE。|但它在你删除之前就已经存在了，对吧。

1796
00:55:33,200 --> 00:55:34,580
0,210 210,390 390,510 510,1020 1020,1380
it but it existed before

1797
00:55:34,580 --> 00:55:36,260
0,150 150,570 570,720 720,1110
you deleted it, right.|
|

1798
00:55:37,720 --> 00:55:39,250
0,240 240,840 840,1050 1050,1140 1140,1530
{Yeah,yeah} {yeah,yeah},| but you know
是的是的|但你知道的，好的，我们一会儿就回去，

1799
00:55:39,850 --> 00:55:40,990
0,420 420,660 660,840 840,1080 1080,1140
okay we'll go back in

1800
00:55:40,990 --> 00:55:41,740
0,30 30,330 330,450 450,600 600,750
a second,| let me okay
|听我说，这是第二个案子了，

1801
00:55:41,740 --> 00:55:42,760
0,150 150,270 270,330 330,600 600,1020
this is the second case,|
|

1802
00:55:42,760 --> 00:55:43,600
0,150 150,210 210,270 270,450 450,840
this is a good point,|
这是很好的观点，|

1803
00:55:43,600 --> 00:55:45,100
0,330 330,690 690,1050 1080,1290 1290,1500
let me a talk about
让我来谈谈这一点，

1804
00:55:45,100 --> 00:55:47,380
0,270 270,480 480,870 870,1440 1650,2280
that,| so there's another scenario|
|所以还有另一种情况|

1805
00:55:47,380 --> 00:55:47,890
0,120 120,210 210,360 360,450 450,510
and I think this is
我认为这就是你所担心的可能会发生的事情

1806
00:55:47,890 --> 00:55:48,880
0,60 60,270 270,420 420,660 660,990
the one you're worrying about

1807
00:55:48,880 --> 00:55:50,290
0,150 150,270 270,360 360,840 1170,1410
that could have happened| and
|这就是通知的用武之地。

1808
00:55:50,290 --> 00:55:51,580
0,180 180,240 240,480 480,1110 1110,1290
this is where notifications come

1809
00:55:51,580 --> 00:55:52,340
0,180
in.|
|

1810
00:55:52,900 --> 00:55:54,580
0,510 660,1080 1080,1170 1170,1560 1560,1680
So this will agree that
所以这会同意这是正确的，正确的。

1811
00:55:54,580 --> 00:55:56,340
0,150 150,450 480,750 750,1200
this is right, correct.|
|

1812
00:55:56,340 --> 00:55:58,290
0,180 180,270 270,540 540,1110 1140,1950
So the second case, {}
所以第二种情况，更多的规则

1813
00:55:58,900 --> 00:56:02,080
0,330 330,840 2670,2910 2910,3030 3030,3180
more rules| and this is
|这确实很有趣。

1814
00:56:02,080 --> 00:56:03,600
0,300 300,870
indeed interesting.|
|

1815
00:56:04,450 --> 00:56:05,230
0,330 330,360 360,540 540,600 600,780
{} I think the case
我认为你所担心的情况是，

1816
00:56:05,230 --> 00:56:06,520
0,120 120,270 270,540 540,870 870,1290
where you're worried about is,|
|

1817
00:56:07,100 --> 00:56:09,620
0,540 870,1230 1230,1530 1530,2070 2160,2520
{} {here's,our} reader again,| {here's,our}
我们的读者又来了，|我们的作家又来了

1818
00:56:09,620 --> 00:56:12,350
0,330 330,870 1320,1980 2010,2220 2220,2730
writer again| and the reader
|你所知道的读卡器存在于Ready上，

1819
00:56:12,350 --> 00:56:14,000
0,60 60,150 150,450 450,1080
you know calls exists

1820
00:56:15,500 --> 00:56:17,560
0,300 300,930
on ready,|
|

1821
00:56:18,600 --> 00:56:20,250
0,330 330,630 630,1080 1080,1170 1170,1650
unless the file you know
除非你知道的文件在其中，否则你知道它读的是F1。

1822
00:56:21,420 --> 00:56:23,310
0,630 630,780 780,1200 1200,1740 1770,1890
{} is there in you

1823
00:56:23,310 --> 00:56:24,750
0,180 180,750 750,1020 1020,1200 1200,1440
know does read {f1 -}.|
|

1824
00:56:26,470 --> 00:56:27,760
0,420 450,660 660,930 930,1200 1200,1290
Alright, we're almost same as
好的，我们几乎和上一个场景中一样

1825
00:56:27,760 --> 00:56:29,560
0,90 90,150 150,540 540,1140 1650,1800
in the previous scenario| and
|现在，就像你知道的那样，领导层正在发生一些变化，

1826
00:56:29,560 --> 00:56:30,940
0,510 510,750 750,810 810,990 990,1380
now like you know there's

1827
00:56:30,940 --> 00:56:32,440
0,180 180,720 720,1260 1260,1350 1350,1500
some changing leadership,| you know
|你知道，有一场坠机，我们正在恢复

1828
00:56:32,440 --> 00:56:34,810
0,210 210,1230 1410,1650 1650,1710 1710,2370
there's a there's a crash

1829
00:56:34,810 --> 00:56:36,400
0,780 780,870 870,1050 1050,1500 1500,1590
we're you know recovery| and
|所有这类事情都在发生

1830
00:56:36,400 --> 00:56:36,970
0,120 120,210 210,330 330,390 390,570
all that kind of stuff

1831
00:56:36,970 --> 00:56:38,860
0,90 90,630 930,1170 1170,1680 1710,1890
is happening| and so there's
|所以有了一个新的初选，它准备删除，

1832
00:56:38,860 --> 00:56:41,890
0,30 30,870 900,1680 2130,2730 2730,3030
a new primary, {} it

1833
00:56:41,890 --> 00:56:44,080
0,390 390,1080
deletes ready,|
|

1834
00:56:46,170 --> 00:56:47,820
0,750 750,870 870,990 990,1440 1440,1650
{} you know writes {f1
你知道，写F1，写F2，

1835
00:56:47,820 --> 00:56:49,760
0,690
-},

1836
00:56:51,020 --> 00:56:53,520
0,270 270,600 600,840 840,1620
and writes {f2 -},|
|

1837
00:56:54,520 --> 00:56:57,640
0,930 960,1770 1770,2550
and it's {}
它可以像以前一样随时准备好。

1838
00:56:58,060 --> 00:57:00,080
0,240 240,690 690,1260
might creates ready

1839
00:57:01,210 --> 00:57:02,920
0,270 270,420 420,1050
like as before.|
|

1840
00:57:05,440 --> 00:57:06,520
0,390 390,540 540,780 780,900 900,1080
And let's assume that this
让我们假设这样的读数有一点延迟，

1841
00:57:06,520 --> 00:57:07,570
0,270 270,450 450,690 690,810 810,1050
like this read a little

1842
00:57:07,570 --> 00:57:08,560
0,90 90,600 630,720 720,900 900,990
bit delayed,| and you know
|你知道这台机器上还发生了其他事情。

1843
00:57:08,560 --> 00:57:09,490
0,240 240,480 480,750 750,840 840,930
something else happened on the

1844
00:57:09,490 --> 00:57:10,620
0,570
machine.|
|

1845
00:57:10,770 --> 00:57:12,180
0,600 600,750 750,900 900,1230 1230,1410
And you know now does
现在读数是f2。

1846
00:57:12,180 --> 00:57:13,720
0,90 90,360 360,540 540,810
the read {f2 -}.|
|

1847
00:57:15,480 --> 00:57:16,110
0,150 150,270 270,420 420,540 540,630
And I think this is
我认为这就是你所问的问题，

1848
00:57:16,110 --> 00:57:17,160
0,60 60,450 450,600 600,930 930,1050
a very the question you

1849
00:57:17,160 --> 00:57:18,270
0,240 240,540 540,750 750,960 960,1110
were asking about,| because this
|因为这是你担心的正确的事情，

1850
00:57:18,270 --> 00:57:19,380
0,120 120,210 210,480 480,720 750,1110
is the {you,worry} something right,|
|

1851
00:57:19,620 --> 00:57:21,780
0,450 450,1050 1050,1890 1890,2100 2100,2160
because now {} there's a
因为现在有了配置变化，

1852
00:57:21,780 --> 00:57:23,790
0,600 600,1260 1470,1800 1800,1890 1890,2010
configuration change,| and if this
|如果这种配置更改在中间被淹没，对吧，

1853
00:57:23,790 --> 00:57:25,350
0,600 600,840 840,1020 1020,1500 1500,1560
configuration change gets flooded in

1854
00:57:25,350 --> 00:57:27,420
0,90 90,360 360,900 1170,1590 1710,2070
the middle here, right,| this
|读取f2将返回新配置

1855
00:57:27,420 --> 00:57:28,890
0,210 210,300 300,510 510,1140 1290,1470
read of {f2 -} is

1856
00:57:28,890 --> 00:57:31,200
0,120 120,180 180,990 1020,1590 1620,2310
going to return the new

1857
00:57:31,200 --> 00:57:32,790
0,660 660,750 750,1200 1200,1440 1440,1590
configuration| as opposed to the
|与读取将返回旧配置的F1相反

1858
00:57:32,790 --> 00:57:33,750
0,180 180,240 240,420 420,780 780,960
read of {f1 -} that

1859
00:57:33,750 --> 00:57:34,470
0,120 120,240 240,330 330,660 660,720
is going to return the

1860
00:57:34,470 --> 00:57:36,540
0,240 240,840 900,1350 1410,1860 1860,2070
old configuration| and clearly things
|显然事情会变得一团糟，

1861
00:57:36,540 --> 00:57:37,440
0,30 30,180 180,300 300,570 570,900
are gonna be messed up,|
|

1862
00:57:38,200 --> 00:57:39,790
0,330 330,750 750,990 990,1020 1020,1590
{} that's not a scenario
这不是我们想要的情景，

1863
00:57:39,790 --> 00:57:40,510
0,180 180,330 330,390 390,540 540,720
we want to be in,|
|

1864
00:57:40,510 --> 00:57:42,320
0,240 240,450 450,780 780,1260
so we terrible outcome.|
所以我们的结局很糟糕。|

1865
00:57:42,870 --> 00:57:44,370
0,510 600,750 750,1020 1020,1170 1170,1500
So and how does that
那么，你知道这实际上是如何得到纠正的

1866
00:57:44,370 --> 00:57:46,920
0,540 540,660 660,960 1140,1860 1890,2550
actually you know get rectified|
|

1867
00:57:46,920 --> 00:57:48,240
0,120 120,240 240,450 450,930 930,1320
or how this actually {}
或者这位动物园管理员实际上是如何处理这件事的，

1868
00:57:48,240 --> 00:57:49,320
0,150 150,480 480,750 750,870 870,1080
{zookeeper -} deal with this,|
|

1869
00:57:49,320 --> 00:57:51,030
0,510 630,1050 1050,1140 1140,1320 1320,1710
well, this is where the
好吧，这就是手表的用武之地，

1870
00:57:51,060 --> 00:57:53,220
0,390 390,540 540,840 1260,1920 1950,2160
watches come in,| {} you
|你知道我在以前的黑板上画的画并不完全正确，

1871
00:57:53,220 --> 00:57:54,000
0,90 90,210 210,480 480,570 570,780
know the pictures I drew

1872
00:57:54,000 --> 00:57:55,260
0,60 60,150 150,540 540,990 990,1260
in the former previously board

1873
00:57:55,260 --> 00:57:56,490
0,60 60,240 240,600 600,1050 1080,1230
is not completely correct,| in
|除了一种存在的呼声，这真的是要说，看着真的。

1874
00:57:56,490 --> 00:57:59,400
0,630 630,1170 1470,1860 1860,2430 2430,2910
addition to a calling exists

1875
00:57:59,400 --> 00:58:00,330
0,210 210,360 360,690 690,810 810,930
with this really is going

1876
00:58:00,330 --> 00:58:01,710
0,60 60,390 390,840 840,930 930,1380
to say watch to true.|
|

1877
00:58:08,370 --> 00:58:11,130
0,600 1200,1860 1890,2250 2250,2520 2520,2760
{} And {} what that
这意味着这个删除，你知道，更改是准备好的文件，

1878
00:58:11,130 --> 00:58:13,170
0,390 390,750 750,1110 1110,1380 1380,2040
means is that this delete

1879
00:58:15,200 --> 00:58:16,130
0,180 180,390 390,720 720,840 840,930
you know change is the

1880
00:58:16,130 --> 00:58:17,240
0,240 240,660 660,870 870,960 960,1110
ready file,| and we have
|我们现在已经对准备好的文件进行了监视，

1881
00:58:17,240 --> 00:58:18,290
0,150 150,360 360,420 420,900 900,1050
now set a watch on

1882
00:58:18,290 --> 00:58:20,150
0,90 90,360 360,840 1320,1680 1680,1860
the ready file,| and so
|因此，当就绪文件被该新的主节点删除时，

1883
00:58:20,150 --> 00:58:22,370
0,330 330,750 810,1680 1680,1980 1980,2220
when the ready file gets

1884
00:58:22,370 --> 00:58:25,760
0,630 690,1230 1230,1440 1440,1980 2190,3390
deleted by this new primary,|
|

1885
00:58:25,790 --> 00:58:26,870
0,210 210,450 450,930 930,1050 1050,1080
that actually results in a
这实际上会导致通知。

1886
00:58:26,870 --> 00:58:28,100
0,660
notification.|
|

1887
00:58:34,780 --> 00:58:35,680
0,150 150,300 300,360 360,750 750,900
And there's a rule for
这份通知有一条规则，

1888
00:58:35,680 --> 00:58:37,810
0,150 150,900 1320,1620 1620,2010 2010,2130
this notification,| another rule for
|通知的另一条规则是，每一条通知都会在你知道他们在写通知之前送达。

1889
00:58:37,810 --> 00:58:39,190
0,60 60,660 660,810 810,1080 1080,1380
the notification is that every

1890
00:58:39,190 --> 00:58:42,460
0,900 1110,1410 1410,1500 1500,2190 2220,3270
notification will be delivered before

1891
00:58:42,490 --> 00:58:44,800
0,1290 1320,1710 1710,1800 1800,1980 1980,2310
{you,know} writes they go after

1892
00:58:44,800 --> 00:58:45,520
0,240
it.|
|

1893
00:58:46,320 --> 00:58:47,460
0,240 240,420 420,870 870,1080 1080,1140
And so what has to
那么情况会是怎样的呢？

1894
00:58:47,460 --> 00:58:48,570
0,120 120,210 210,600 600,960 990,1110
be the case| that you
|您知道此通知将在写入F1之前发送。

1895
00:58:48,570 --> 00:58:50,850
0,180 180,600 870,1320 1320,1710 1710,2280
know the {} this notification

1896
00:58:50,850 --> 00:58:53,610
0,180 180,1320 1320,1800 1800,2580 2610,2760
will be delivered before the

1897
00:58:53,610 --> 00:58:55,260
0,420 450,570 570,720 720,1080
write to {f1 -}.|
|

1898
00:58:56,320 --> 00:58:57,730
0,330 330,930 930,1080 1080,1260 1260,1410
So when so there's two
因此，如果是这样的话，有两种可能的情况会将通知送到这里，

1899
00:58:57,730 --> 00:58:59,380
0,360 360,840 840,1020 1020,1080 1080,1650
possible scenarios for the notification

1900
00:58:59,380 --> 00:59:01,080
0,180 180,630 630,1140
gets delivered here,|
|

1901
00:59:02,130 --> 00:59:04,260
0,450 450,960 960,1110 1110,1740 1860,2130
[] notification gets delivered like
[]通知在读取f2之后发送。

1902
00:59:04,260 --> 00:59:05,130
0,330 330,450 450,630 630,720 720,870
after the read of {f2

1903
00:59:05,130 --> 00:59:06,100
0,330
-}.|
|

1904
00:59:06,420 --> 00:59:07,680
0,300 300,510 540,840 840,1020 1020,1260
Let me move that we'd
让我移动一下，我们必须稍微往上一点，

1905
00:59:07,680 --> 00:59:09,360
0,150 150,300 300,720 720,1140
have to slightly up,|
|

1906
00:59:12,310 --> 00:59:14,500
0,210 210,1080 1620,1830 1830,1950 1950,2190
or yeah,| so it's still
或者是的，|所以它仍然在发生，

1907
00:59:14,500 --> 00:59:16,360
0,360 360,510 510,720 720,1260 1290,1860
happening,| so in time behind
|所以在你知道写操作之后的时间里，

1908
00:59:16,360 --> 00:59:18,010
0,120 120,240 240,690 720,990 990,1650
you know the write operation,|
|

1909
00:59:18,310 --> 00:59:19,510
0,360 360,390 390,870 870,1020 1020,1200
but {} notification gets easier
但根据延误情况，通知在这里会更容易送达

1910
00:59:19,510 --> 00:59:20,830
0,330 330,780 780,1110 1110,1230 1230,1320
delivered here depending on the

1911
00:59:20,830 --> 00:59:22,480
0,750 930,1320 1320,1440 1440,1590 1590,1650
delays| or it's going to
|或者它会把它送到这里。

1912
00:59:22,480 --> 00:59:23,680
0,240 240,390 390,720
deliver it here.|
|

1913
00:59:23,930 --> 00:59:26,390
0,750 750,1260 1260,1440 1440,1920 1920,2460
Sorry, what's the exact wording
抱歉，允许这种情况发生的具体规定是什么？

1914
00:59:26,390 --> 00:59:27,470
0,90 90,390 390,630 630,780 780,1080
of that rule that allows

1915
00:59:27,470 --> 00:59:28,960
0,120 120,270 270,810
this to happen?|
|

1916
00:59:30,260 --> 00:59:32,120
0,690 720,1410 1410,1500 1500,1650 1650,1860
{} Basically, I think one
基本上，我认为一种方式来考虑它，

1917
00:59:32,120 --> 00:59:32,900
0,150 150,240 240,360 360,660 660,780
way to think about it,|
|

1918
00:59:32,900 --> 00:59:33,950
0,90 90,630 630,840 840,990 990,1050
the notification is like it
通知就像它总是像写操作一样，

1919
00:59:33,950 --> 00:59:34,730
0,90 90,330 330,450 450,540 540,780
was always like a write

1920
00:59:34,730 --> 00:59:35,820
0,540
operation,|
|

1921
00:59:36,200 --> 00:59:37,910
0,630 630,900 900,1530 1530,1590 1590,1710
and the followers you know
而你知道的追随者实施了，

1922
00:59:37,910 --> 00:59:40,520
0,720 810,1470 1470,1710 1710,2010 2010,2610
implemented,| {} so that the
|这样，您的更改恰好会删除该通知

1923
00:59:41,630 --> 00:59:43,220
0,300 300,660 660,1080 1080,1320 1320,1590
your change happens to delete

1924
00:59:43,220 --> 00:59:44,420
0,90 90,660 660,870 870,1080 1080,1200
the notification goes off| that
|该通知与该ZXID一起被传递给客户端。

1925
00:59:44,420 --> 00:59:45,620
0,570 570,630 630,1020 1020,1080 1080,1200
notification is delivered to the

1926
00:59:45,620 --> 00:59:47,420
0,600 600,780 780,990 990,1560 1560,1800
client with that {zxid -

1927
00:59:47,420 --> 00:59:48,340
0,420
-}.|
|

1928
00:59:51,010 --> 00:59:53,050
0,1410 1410,1530 1530,1590 1590,1800 1800,2040
Yeah, but I still don't
是啊，但我还是不明白为什么这能保证它能像以前一样，

1929
00:59:53,050 --> 00:59:54,370
0,360 360,510 510,660 660,1170 1170,1320
understand why this guarantees that

1930
00:59:54,370 --> 00:59:56,480
0,390 570,960 960,1560
it can go

1931
00:59:56,600 --> 00:59:57,740
0,570
like

1932
00:59:58,740 --> 01:00:00,820
0,1530
before,|
|

1933
01:00:00,850 --> 01:00:02,470
0,540 540,690 690,840 840,1200 1200,1620
wait, so the valid places
等等，所以它的有效位置是，

1934
01:00:02,470 --> 01:00:04,840
0,180 180,270 270,810 840,2010 2010,2370
for it are,| before the
|在写入f1之前，也像在写入f2之后，对。

1935
01:00:04,840 --> 01:00:06,520
0,270 270,360 360,600 600,1200 1410,1680
write of {f1 -} and

1936
01:00:06,520 --> 01:00:08,140
0,420 420,750 750,1260 1260,1380 1380,1620
also like after the write

1937
01:00:08,140 --> 01:00:09,220
0,600
of

1938
01:00:09,220 --> 01:00:11,280
0,300 300,900 990,1500
{f2 -}, right.|
|

1939
01:00:11,340 --> 01:00:13,380
0,420 450,1140 1140,1260 1260,1680 1680,2040
The innovation is delivered after
在删除READY之后交付创新，

1940
01:00:13,380 --> 01:00:15,210
0,930 990,1380 1380,1560 1560,1740 1740,1830
the after the delete of

1941
01:00:15,210 --> 01:00:16,260
0,510
ready,|
|

1942
01:00:16,260 --> 01:00:18,210
0,330 330,810 810,900 900,1350 1350,1950
and before the writes, before
并且在写入之前，在f1和f2的写入可见之前，

1943
01:00:18,210 --> 01:00:18,960
0,120 120,360 360,450 450,570 570,750
the writes of {f1 -}

1944
01:00:18,960 --> 01:00:19,770
0,90 90,180 180,300 300,390 390,810
and {f2 -} are visible,|
|

1945
01:00:20,340 --> 01:00:21,720
0,270 270,390 390,480 480,960 1230,1380
where in the creator for
在这件事上的创造者在哪里。

1946
01:00:21,720 --> 01:00:22,820
0,120 120,540
that matter.|
|

1947
01:00:23,540 --> 01:00:24,820
0,150 150,270 270,720
Oh, I see.|
哦，我明白了。|

1948
01:00:25,380 --> 01:00:26,900
0,870

1949
01:00:30,230 --> 01:00:31,730
0,270 270,450 450,540 540,960 1020,1500
That's just a rule, {zookeeper
这只是一个规则，动物园管理员必须保证这一点。

1950
01:00:31,730 --> 01:00:32,870
0,210 210,360 360,450 450,810 810,1140
-} has to guarantee that.|
|

1951
01:00:33,480 --> 01:00:34,800
0,750
Okay.|
好吧。|

1952
01:00:34,800 --> 01:00:36,060
0,240 240,660 720,900 900,1050 1050,1260
Okay, so so that means
好的，所以这意味着有两个案例，对吗，

1953
01:00:36,060 --> 01:00:37,350
0,210 210,360 360,780 780,1080 1080,1290
there's two cases, correct,| like
|类似于在读取F1之前或在读取F1之后发送通知。

1954
01:00:37,350 --> 01:00:39,060
0,360 390,930 930,1110 1110,1380 1380,1710
the notification gets delivered before

1955
01:00:39,060 --> 01:00:40,200
0,60 60,300 300,480 480,840 870,1140
the {read,of} {f1 -} or

1956
01:00:40,200 --> 01:00:41,220
0,300 300,360 360,600 600,780 780,1020
after the {read,of} {f1 -}.|
|

1957
01:00:42,560 --> 01:00:43,640
0,210 210,360 360,720 720,960 960,1080
If we deliver if it
如果我们交付如果它是在读取f2的f1之后交付的，会有问题吗？

1958
01:00:43,640 --> 01:00:44,990
0,210 210,540 540,930 930,1140 1140,1350
gets delivered after the read

1959
01:00:44,990 --> 01:00:46,790
0,120 120,270 270,780 930,1290 1290,1800
of {f1 -} {of,f2 -}

1960
01:00:47,030 --> 01:00:48,620
0,210 210,330 330,420 420,990
is there a problem?|
|

1961
01:00:50,920 --> 01:00:52,630
0,480 510,1110 1110,1380 1380,1590 1590,1710
No.| No, because then the
不是的。|不是，因为读操作就发生在写操作之前。

1962
01:00:52,630 --> 01:00:53,710
0,180 180,330 330,630 630,960 960,1080
read just happened before the

1963
01:00:53,710 --> 01:00:55,630
0,630 900,1080 1080,1440 1440,1710 1740,1920
writes.| So everything's good,| so
|所以一切都很好，|这就是整个数据块发生在f2的读取完全正常之后

1964
01:00:55,630 --> 01:00:56,980
0,180 180,300 300,750 750,990 990,1350
this is this whole block

1965
01:00:56,980 --> 01:00:58,090
0,150 150,510 510,840 840,930 930,1110
is happening after the read

1966
01:00:58,090 --> 01:00:59,230
0,90 90,240 240,360 360,480 480,1140
of {f2 -} is perfectly

1967
01:00:59,230 --> 01:01:00,220
0,240 240,420 420,510 510,660 660,990
fine| and {} about here.|
|就在这里。|

1968
01:01:03,270 --> 01:01:04,920
0,720 720,1110 1110,1230 1230,1350 1350,1650
{} Professor, did you say
教授，你是说手表就像是在写东西吗？

1969
01:01:04,920 --> 01:01:07,230
0,720 750,1500 1530,1800 1800,1980 1980,2310
that watch is like a

1970
01:01:07,260 --> 01:01:09,180
0,300 330,690 690,1350
like write something?|
|

1971
01:01:09,450 --> 01:01:11,040
0,570 930,1080 1080,1170 1170,1320 1320,1590
Well, you can think about
嗯，你可以考虑一下，

1972
01:01:11,040 --> 01:01:12,180
0,600 600,690 690,900 900,990 990,1140
it,| the watch is not
|该手表不是写操作，

1973
01:01:12,180 --> 01:01:13,410
0,60 60,300 300,840 840,990 990,1230
a write operation,| I didn't
|我并不是想暗示你写给，

1974
01:01:13,410 --> 01:01:14,580
0,360 360,480 480,840 840,1080 1080,1170
mean to imply that the

1975
01:01:14,580 --> 01:01:16,080
0,300 300,390 390,660 660,780 780,1500
write to,| watch is executed
|使用适当的ZXID执行监视，

1976
01:01:16,110 --> 01:01:17,820
0,330 330,540 540,1080 1080,1530 1530,1710
with the appropriate {zxid -

1977
01:01:17,820 --> 01:01:19,800
0,600 780,1020 1020,1230 1230,1800 1800,1980
-},| {} that's associated with
|这与这一修改有关。

1978
01:01:19,800 --> 01:01:21,940
0,960 960,1620
that modification.|
|

1979
01:01:21,940 --> 01:01:23,800
0,300 300,390 390,780 780,1260 1320,1860
Those are local, right, watches.|
那些是本地产的，对，手表。|

1980
01:01:23,800 --> 01:01:25,240
0,420 420,480 480,780 780,840 840,1440
Yeah, the watchers are local|
是啊，守望者是当地人|

1981
01:01:25,240 --> 01:01:26,410
0,90 90,210 210,420 420,600 600,1170
and so when they're executed,|
所以当他们被处决时，|

1982
01:01:26,590 --> 01:01:29,740
0,810 1020,1620 1980,2220 2220,2970 3030,3150
{} the it's guaranteed you
你肯定知道它们是在写的时候发生的，

1983
01:01:29,740 --> 01:01:31,570
0,150 150,480 480,1230 1260,1710 1710,1830
know that they happened at

1984
01:01:31,570 --> 01:01:33,190
0,90 90,540 840,1320 1320,1380 1380,1620
the write,| when the write
|当观察到写入或者客户端发现这很容易被用zxid传播到客户端时

1985
01:01:33,190 --> 01:01:35,200
0,90 90,810 1110,1350 1350,1770 1770,2010
is observed or {the,client} sees

1986
01:01:35,200 --> 01:01:36,790
0,180 180,540 540,660 660,990 990,1590
that's easy to watch propagated

1987
01:01:36,790 --> 01:01:37,720
0,180 180,240 240,570 570,840 840,930
with the {zxid -} to

1988
01:01:37,720 --> 01:01:38,920
0,90 90,630 630,750 750,930 930,1200
the client| and make sure
|并确保他们执行它。

1989
01:01:38,920 --> 01:01:40,260
0,240 240,690 690,900
they execute it.|
|

1990
01:01:41,070 --> 01:01:42,100
0,480
Thanks.|
谢谢。|

1991
01:01:44,200 --> 01:01:45,460
0,480 480,540 540,840 840,900 900,1260
Again, the papers are slightly
再说一次，这些文件稍微有点[模糊]，完全是如何实施的，

1992
01:01:45,460 --> 01:01:47,080
0,420 420,810 810,930 930,1050 1050,1620
[vapor] exactly how it's implemented,|
|

1993
01:01:47,110 --> 01:01:48,040
0,180 180,300 300,390 390,690 690,930
but you can imagine different
但你可以想象不同的情景。

1994
01:01:48,040 --> 01:01:49,280
0,750
scenarios.|
|

1995
01:01:50,170 --> 01:01:51,250
0,180 180,360 360,540 540,840 840,1080
But the more important points
但像这些规则这样更重要的几点是可以保证的。

1996
01:01:51,250 --> 01:01:52,720
0,210 210,330 330,630 630,1080 1170,1470
like these rules guaranteed.| Okay,
|好的，那么如果通知送到这里会发生什么？

1997
01:01:52,720 --> 01:01:53,650
0,120 120,270 270,510 510,600 600,930
so what happens if the

1998
01:01:53,650 --> 01:01:55,520
0,510 510,630 630,930 930,1290
notification is delivered here?|
|

1999
01:01:58,140 --> 01:01:59,190
0,270 270,360 360,690 690,750 750,1050
So the client is running
因此，客户端运行正常，

2000
01:01:59,190 --> 01:02:00,660
0,540 540,780 780,1110 1110,1200 1200,1470
correct,| it exist to read
|它存在读F1，现在这个通知进来了。

2001
01:02:00,660 --> 01:02:02,250
0,450 450,630 630,930 930,1080 1080,1590
f1 and now this notification

2002
01:02:02,250 --> 01:02:03,260
0,240 240,390
comes in.|
|

2003
01:02:06,020 --> 01:02:07,100
0,180 180,300 300,450 450,540 540,1080
Then you have to restart
然后，您可能必须重新启动。

2004
01:02:07,100 --> 01:02:08,960
0,420 420,810 840,1020 1020,1080 1080,1860
probably.| You have to restart.|
|您必须重新启动。|

2005
01:02:12,400 --> 01:02:13,720
0,300

2006
01:02:14,800 --> 01:02:16,040
0,690
Okay,
好的，所以我们在这里看到的基本上是

2007
01:02:16,430 --> 01:02:17,750
0,270 270,720 720,810 810,1050 1050,1320
So what we see here

2008
01:02:17,750 --> 01:02:19,070
0,510 510,750 750,1050 1080,1200 1200,1320
basically is that| you know
|你知道，你知道的规则肯定会让编程变得更加困难，但并不是不可能。

2009
01:02:19,070 --> 01:02:20,810
0,360 360,930 930,1050 1050,1320 1320,1740
the rules {you,know} make programming

2010
01:02:20,810 --> 01:02:22,520
0,390 390,450 450,600 600,990 1020,1710
definitely a bit more a

2011
01:02:22,520 --> 01:02:25,780
0,630 840,1770 1770,2070 2070,2730
difficult, but not impossible.|
|

2012
01:02:25,840 --> 01:02:26,890
0,420 420,690 690,840 840,870 870,1050
You know with a little
你知道，只要稍加小心的编程，

2013
01:02:26,890 --> 01:02:28,240
0,180 180,690 690,870 870,1020 1020,1350
bit careful sort of {}

2014
01:02:28,240 --> 01:02:29,980
0,690 690,810 810,960 960,1290 1290,1740
programming,| you know you and
|你了解你，了解你的规则，你实际上可以得到想要的结果

2015
01:02:30,010 --> 01:02:31,420
0,420 420,510 510,990 990,1290 1290,1410
understand the rules you can

2016
01:02:31,420 --> 01:02:33,670
0,510 540,870 870,990 990,1740 1740,2250
actually get the desirable results|
|

2017
01:02:33,670 --> 01:02:35,020
0,270 270,510 510,810 810,870 870,1350
that actually probably the application
这实际上可能是应用程序想要的。

2018
01:02:35,020 --> 01:02:36,080
0,600
wants.|
|

2019
01:02:36,080 --> 01:02:37,190
0,210 210,600 600,690 690,840 840,1110
What happens to the read
然而，Read F1发生了什么？

2020
01:02:37,190 --> 01:02:38,700
0,240 240,570 570,960
{f1 -} though?|
|

2021
01:02:39,480 --> 01:02:40,560
0,150 150,510 510,660 660,900 900,1080
What happens to read {f1
读F1会发生什么。

2022
01:02:40,560 --> 01:02:43,950
0,480 660,1110 1110,1380 1380,2010 2550,3390
-}.| You start over.| Including
|你得从头开始。|包括这一点。

2023
01:02:43,950 --> 01:02:45,380
0,240 300,900
that.| Right.|
|正确的。|

2024
01:02:47,780 --> 01:02:48,960
0,630
Okay?|
好吧?|

2025
01:02:50,120 --> 01:02:50,990
0,120 120,270 270,480 480,690 690,870
And you'll see this is
你会发现这是个骗局

2026
01:02:50,990 --> 01:02:51,860
0,120 120,420 420,540 540,750 750,870
a trick| that shows up
|这一点在那些食谱中表现得相当明显

2027
01:02:51,860 --> 01:02:52,880
0,90 90,270 270,750 750,990 990,1020
in those recipes quite a

2028
01:02:52,880 --> 01:02:54,110
0,300 330,750 750,900 900,1110 1110,1230
bit| like this there's an
|就像这样，有一种想法，实际上你会跳出水面，重新开始。

2029
01:02:54,110 --> 01:02:56,480
0,510 510,720 720,1230 1230,1710 1800,2370
idea of actually you bailing

2030
01:02:56,480 --> 01:02:58,640
0,450 510,1230 1260,1590 1590,1830 1830,2160
out and starting over again.|
|

2031
01:02:59,820 --> 01:03:01,770
0,630 930,1440 1440,1590 1590,1830 1830,1950
Okay, {} so hopefully that
好的，希望这能给你两件事的感觉，

2032
01:03:01,770 --> 01:03:02,670
0,180 180,270 270,330 330,660 660,900
gives you a sense that

2033
01:03:02,670 --> 01:03:04,320
0,270 270,480 480,720 720,1200 1440,1650
got for two things,| sort
|尽管人们喜欢线性化的一个原因是因为它非常直观，

2034
01:03:04,320 --> 01:03:07,530
0,540 1140,1470 1470,2160 2520,2910 2910,3210
of even though people, one

2035
01:03:07,530 --> 01:03:08,460
0,240 240,390 390,630 630,840 840,930
reason like people like {linearizability

2036
01:03:08,460 --> 01:03:09,570
0,150 150,270 270,750 750,840 840,1110
- - -} is because

2037
01:03:09,570 --> 01:03:11,070
0,120 120,330 330,870 900,1350 1350,1500
it's very intuitive,| very easy
|非常容易编程，

2038
01:03:11,070 --> 01:03:12,270
0,90 90,480 480,720 720,930 930,1200
to program with,| because everything
|因为每件事都像一台机器一样运转。

2039
01:03:12,270 --> 01:03:13,350
0,270 270,420 420,480 480,690 690,1080
behaves like a single machine.|
|

2040
01:03:13,800 --> 01:03:14,790
0,240 240,480 480,570 570,780 780,990
But if you want fault
但如果您想要容错、可伸缩性、

2041
01:03:14,790 --> 01:03:17,310
0,690 810,1980 2070,2250 2250,2430 2430,2520
tolerance, scalability,| it's hard to
|很难得到真正好的表现，

2042
01:03:17,310 --> 01:03:18,780
0,180 180,480 480,690 690,1260 1260,1470
get actually good performance,| and
|因此，获得良好性能的一种方法是在一致性保证上妥协

2043
01:03:18,780 --> 01:03:19,830
0,150 150,510 510,780 780,870 870,1050
so one way to get

2044
01:03:19,830 --> 01:03:21,570
0,150 150,690 690,810 810,1500 1500,1740
good performances to compromise on

2045
01:03:21,570 --> 01:03:23,730
0,90 90,630 630,1260 1530,2070 2070,2160
the consistency guarantee| and in
|在这种情况下，您知道折衷的线性化，并提供一些其他持久的保证

2046
01:03:23,730 --> 01:03:25,140
0,150 150,480 480,540 540,690 690,1410
this case, you know compromising

2047
01:03:25,140 --> 01:03:26,970
0,300 300,990 1110,1380 1380,1680 1680,1830
{linearizability -} and provide some

2048
01:03:26,970 --> 01:03:28,350
0,330 330,720 720,1110 1110,1260 1260,1380
other persistent guarantee| and as
|正如我们所看到的，让我们将程序员所经历的用户体验复杂化，

2049
01:03:28,350 --> 01:03:30,960
0,90 90,180 180,660 780,1230 2010,2610
we can see let's complicate

2050
01:03:30,960 --> 01:03:32,940
0,810 900,1410 1410,1830 1830,1890 1890,1980
the user experience of the

2051
01:03:32,940 --> 01:03:34,830
0,420 420,990 1080,1320 1320,1500 1500,1890
programmer experienced,| {} but, {}
|但是，《动物园看守人》中的这些规则是经过精心挑选的，

2052
01:03:34,830 --> 01:03:36,480
0,0 0,810 810,1110 1110,1230 1230,1650
{} these rules {in,zookeeper -}

2053
01:03:36,480 --> 01:03:38,370
0,120 120,480 480,1020 1140,1380 1380,1890
are carefully chosen,| so still
|因此，你仍然知道事情实际上是可以解决的，它是可行的。

2054
01:03:38,370 --> 01:03:39,180
0,60 60,180 180,390 390,510 510,810
you know things can actually

2055
01:03:39,180 --> 01:03:40,900
0,240 240,510
work out,

2056
01:03:41,320 --> 01:03:43,460
0,630 870,1080 1080,1590
{} it's doable.|
|

2057
01:03:43,650 --> 01:03:44,520
0,270 270,390 390,510 510,810 810,870
So it is possible to
因此，有可能获得某种程度上的写入保证。

2058
01:03:44,520 --> 01:03:45,570
0,120 120,210 210,450 450,690 690,1050
get the write to sort

2059
01:03:45,750 --> 01:03:47,420
0,150 150,1200
of guarantees.|
|

2060
01:03:48,300 --> 01:03:50,040
0,180 180,570 660,930 930,1230 1230,1740
So now there's another aspect
所以现在这个编程模型还有另一个方面

2061
01:03:50,040 --> 01:03:51,600
0,120 120,330 330,810 810,1290 1320,1560
to this programming model| and
|然后我想谈一谈现在，

2062
01:03:51,600 --> 01:03:52,140
0,150 150,180 180,330 330,390 390,540
then I want to talk

2063
01:03:52,140 --> 01:03:52,980
0,60 60,240 240,360 360,600 600,840
a little bit about now,|
|

2064
01:03:52,980 --> 01:03:53,970
0,180 180,300 300,540 540,900 900,990
that is really related to
这确实与协调服务部分有关。

2065
01:03:53,970 --> 01:03:56,640
0,90 90,660 660,1020 1020,1470
the coordination service part.|
|

2066
01:04:02,630 --> 01:04:03,580
0,120

2067
01:04:05,830 --> 01:04:09,130
0,780 810,1350 1620,1950 1950,3150 3150,3300
And {} so examples, you
举个例子，你知道你需要你知道作为一个协调服务意味着什么。

2068
01:04:09,130 --> 01:04:10,330
0,450 540,810 810,960 960,1110 1110,1200
know that you need to

2069
01:04:10,330 --> 01:04:11,110
0,330 330,420 420,540 540,690 690,780
you know what does it

2070
01:04:11,110 --> 01:04:12,280
0,390 390,480 480,600 600,660 660,1170
mean to be a coordination

2071
01:04:12,280 --> 01:04:13,400
0,480
service.|
|

2072
01:04:13,460 --> 01:04:15,590
0,540 690,1290 1290,1470 1470,1980 1980,2130
{} One good example is
一个很好的例子可能是我们读到的不久前的《虚拟机容错》白皮书

2073
01:04:15,590 --> 01:04:17,690
0,390 390,540 540,1170 1230,1680 1680,2100
probably the vm virtual machine

2074
01:04:17,690 --> 01:04:18,830
0,180 180,630 630,960 960,1080 1080,1140
fault tolerance paper from a

2075
01:04:18,830 --> 01:04:20,000
0,210 210,480 480,720 720,930 930,1170
little while ago that we

2076
01:04:20,000 --> 01:04:22,220
0,420 720,1410 1530,1740 1740,2010 2010,2220
read| and {} that had
|并进行了测试和设置操作。

2077
01:04:22,220 --> 01:04:23,570
0,180 180,450 450,540 540,780 780,1350
this test and set operation.|
|

2078
01:04:27,520 --> 01:04:28,390
0,90 90,450 450,510 510,780 780,870
The goal of the you
你知道，测试和设置操作的目标基本上是确保没有分裂的大脑，

2079
01:04:28,390 --> 01:04:29,110
0,150 150,240 240,420 420,510 510,720
know the test and set

2080
01:04:29,110 --> 01:04:30,460
0,420 420,510 510,870 870,1020 1020,1350
operation is basically make sure

2081
01:04:30,460 --> 01:04:31,570
0,90 90,240 240,390 390,690 690,1110
that there's no split brain,|
|

2082
01:04:31,570 --> 01:04:32,800
0,270 270,630 630,780 780,1110 1110,1230
because basically two clients would
因为基本上会有两个客户端运行

2083
01:04:32,800 --> 01:04:34,900
0,510 900,1440 1440,1740 1740,1890 1890,2100
run| and one would win
|其中一个会赢得测试，而另一个则不会

2084
01:04:34,900 --> 01:04:35,770
0,90 90,330 330,660 660,720 720,870
the test and the other

2085
01:04:35,770 --> 01:04:36,700
0,150 150,660 660,780 780,870 870,930
one wouldn't| and as a
|结果就是你知道那个赢得了测试集的人

2086
01:04:36,700 --> 01:04:37,930
0,450 450,510 510,750 750,930 930,1230
result you know the one

2087
01:04:37,930 --> 01:04:39,040
0,150 150,360 360,450 450,720 720,1110
that won the testing set|
|

2088
01:04:39,160 --> 01:04:40,900
0,690 690,1290 1290,1380 1380,1530 1530,1740
could conclude you know that
可以得出结论，你知道这将是初选。

2089
01:04:40,900 --> 01:04:41,770
0,180 180,510 510,630 630,690 690,870
{} that's going to be

2090
01:04:41,770 --> 01:04:42,980
0,300 300,720
a primary.|
|

2091
01:04:43,130 --> 01:04:43,940
0,150 150,270 270,510 510,600 600,810
And so that is sort
因此，这是一个特色协调服务的例子，应该能够提供。

2092
01:04:43,940 --> 01:04:46,130
0,300 330,750 750,900 900,1680 1680,2190
of a an example of

2093
01:04:46,490 --> 01:04:49,100
0,210 210,840 1380,1470 1470,1980 1980,2610
{} featured {} coordination service

2094
01:04:49,100 --> 01:04:50,060
0,150 150,240 240,390 390,480 480,960
should be able to provide.|
|

2095
01:04:51,520 --> 01:04:52,960
0,510 510,690 690,780 780,1230 1260,1440
{} And I wanna you
我想让你知道，只是让它更具体一点，

2096
01:04:52,960 --> 01:04:54,280
0,240 300,870 870,1080 1080,1260 1260,1320
know just just make a

2097
01:04:54,280 --> 01:04:56,290
0,150 150,270 270,390 390,900 1140,2010
little bit more concrete, {}|
|

2098
01:04:56,320 --> 01:04:58,450
0,1050 1050,1230 1230,1590 1590,1800 1800,2130
let's think about one lab
让我们来考虑一个实验3，

2099
01:04:58,450 --> 01:05:00,310
0,540 570,960 960,1050 1050,1560 1560,1860
3,| could you get that
|你能帮我拿三号实验室的电话吗？

2100
01:05:00,310 --> 01:05:01,560
0,150 150,390 390,720
with lab 3.|
|

2101
01:05:01,810 --> 01:05:03,010
0,330 330,570 570,930 930,1110 1110,1200
You know, basically sort of
你知道，基本上是一种测试集类型的东西。

2102
01:05:03,010 --> 01:05:04,690
0,810 810,1080 1080,1260 1260,1470 1470,1680
{} test set type thing.|
|

2103
01:05:04,690 --> 01:05:06,340
0,420
Well,
那么，让我们来做一个非常简单的案例，

2104
01:05:08,040 --> 01:05:08,910
0,330 330,510 510,660 660,780 780,870
{} so let's do a

2105
01:05:08,910 --> 01:05:10,410
0,180 180,420 420,870 870,960 960,1500
very simple case,| you know
|您知道，假设我们使用测试和设置的简单实现，

2106
01:05:10,560 --> 01:05:12,990
0,420 420,630 630,1020 1290,2130 2130,2430
let's say we use our

2107
01:05:12,990 --> 01:05:14,340
0,300 300,930 930,1020 1020,1260 1260,1350
simple implementation of test and

2108
01:05:14,340 --> 01:05:19,500
0,510 3060,3690 3810,4830 4830,4980 4980,5160
set,| {and,in} {lab,3}, we only
|在实验3中，我们只进行了GET操作，

2109
01:05:19,500 --> 01:05:20,970
0,120 120,360 360,570 570,1080 1080,1470
have put get operations,| there's
|没有其他行动了，

2110
01:05:20,970 --> 01:05:22,620
0,420 420,720 720,1260 1260,1410 1410,1650
no other operations,| so those
|这就是两个行动，

2111
01:05:22,620 --> 01:05:23,670
0,60 60,150 150,300 300,840 840,1050
are the two operations,| so
|所以你会怎么写这个，

2112
01:05:23,670 --> 01:05:24,660
0,240 240,390 390,570 570,720 720,990
like how would you write

2113
01:05:24,660 --> 01:05:26,300
0,360 360,480 480,990
this,| you know,
|你知道吗，也许你知道如何弹奏一把琴键，比方说大师。

2114
01:05:26,330 --> 01:05:29,270
0,570 600,1170 1350,1470 1470,1830 2550,2940
{} maybe you know do

2115
01:05:29,270 --> 01:05:30,890
0,90 90,600 690,1080 1080,1080 1080,1620
a put to a key,

2116
01:05:30,920 --> 01:05:32,840
0,210 210,390 390,1080
let's say master.|
|

2117
01:05:34,760 --> 01:05:35,840
0,300 300,450 450,630 630,840 840,1080
And we put my IP
我们把我的IP地址放进去

2118
01:05:35,840 --> 01:05:37,310
0,270 270,420 420,720 1080,1380 1380,1470
address in it| the IP
|呼叫方的IP地址

2119
01:05:37,310 --> 01:05:38,780
0,270 270,510 510,660 660,840 840,1470
{address -} of the caller|
|

2120
01:05:40,490 --> 01:05:42,110
0,210 210,660 660,900 900,1110 1110,1620
and then you do get|
然后你就会得到|

2121
01:05:42,290 --> 01:05:43,880
0,210 210,600 600,1080 1080,1320 1320,1590
you know and we say
你知道，我们说如果它在主机上的访问等于我的IP地址，

2122
01:05:43,880 --> 01:05:46,970
0,450 450,540 540,1050 1740,2160 2160,3090
if it gets on master

2123
01:05:48,320 --> 01:05:50,120
0,630 660,1080 1080,1200 1200,1500 1500,1800
is equal to my IP

2124
01:05:50,120 --> 01:05:51,400
0,840
address,|
|

2125
01:05:55,520 --> 01:05:57,080
0,570 570,1080 1080,1140 1140,1290 1290,1560
{} then you know act
然后你就会知道，当主人还是当领袖。

2126
01:05:57,080 --> 01:05:58,820
0,90 90,720 1200,1440 1440,1620 1620,1740
as masters or act as

2127
01:05:58,820 --> 01:06:01,640
0,690
leader.|
|

2128
01:06:02,550 --> 01:06:04,260
0,300 300,450 450,540 540,990 1020,1710
Actually, this is our naive
实际上，这是我们天真的实现，

2129
01:06:04,260 --> 01:06:06,120
0,870 900,1020 1020,1230 1230,1590 1620,1860
implementation,| you know we don't
|你知道我们别无选择，

2130
01:06:06,120 --> 01:06:07,350
0,150 150,330 330,540 540,990 990,1230
have many other choices,| because
|因为我们把钱投进去，然后就能得到

2131
01:06:07,350 --> 01:06:09,090
0,390 420,1020 1020,1410 1440,1650 1650,1740
we put we put in

2132
01:06:09,090 --> 01:06:10,260
0,330 720,870 870,990 990,1050 1050,1170
{and,get}| and this is how
|这就是我们可以实现这一点的方式。

2133
01:06:10,260 --> 01:06:11,680
0,90 90,210 210,570 570,930
we can implement this.|
|

2134
01:06:13,150 --> 01:06:14,800
0,210 210,600 630,930 930,1050 1050,1650
Will this do the desirable
这会带来令人向往的结果吗？

2135
01:06:14,800 --> 01:06:15,740
0,330
thing?|
|

2136
01:06:23,240 --> 01:06:25,820
0,420 450,840 840,1170 1170,2100 2130,2580
Oh, there's no atomicity between
哦，在缝隙中的投放物之间没有原子性，

2137
01:06:25,820 --> 01:06:26,960
0,90 90,360 360,600 600,690 690,1140
the put in the gaps,|
|

2138
01:06:26,960 --> 01:06:30,380
0,420 660,2070 2460,2850 2850,3060 3060,3420
{so,maybe,something} changed.| Correct, so basically
因此，也许有些事情发生了变化。|对，所以基本上可以有两个客户端，对吧，

2139
01:06:30,380 --> 01:06:31,250
0,120 120,270 270,360 360,480 480,870
there could be two clients,

2140
01:06:31,250 --> 01:06:33,080
0,360 360,600 600,780 780,1380 1380,1830
correct,| both could execute both
|两者都可以同时执行两个看跌期权。

2141
01:06:33,080 --> 01:06:34,220
0,210 210,330 330,390 390,660 660,1140
puts at the same time.|
|

2142
01:06:34,850 --> 01:06:36,380
0,990

2143
01:06:36,440 --> 01:06:38,840
0,750 750,1350 1350,1590 1590,1740 1740,2400
And, {} and then observe,
然后，然后观察，你知道，

2144
01:06:38,960 --> 01:06:41,860
0,1260 1320,1470 1470,1650 1650,2310
{} you know the,|
|

2145
01:06:41,860 --> 01:06:44,590
0,510 510,1050 1860,2460 2460,2580 2580,2730
{} in roughly they could
大体上，他们可以同时做这件事

2146
01:06:44,590 --> 01:06:45,280
0,90 90,270 270,390 390,450 450,690
do it at the same

2147
01:06:45,280 --> 01:06:47,230
0,510 510,600 600,720 720,1350 1350,1950
time| and the interleave correctly
|而交织正确地涉及到正确地在两个返回中获得它们的特定IP地址，对吗，

2148
01:06:47,230 --> 01:06:48,820
0,420 420,720 720,1200 1200,1500 1500,1590
involve {correct,in,both} return gets you

2149
01:06:48,820 --> 01:06:50,020
0,150 150,330 330,540 540,930 930,1200
know with their particular IP

2150
01:06:50,020 --> 01:06:51,640
0,420 420,780 1170,1380 1380,1500 1500,1620
address, right,| so we can
|这样我们就可以有两个领袖了。

2151
01:06:51,640 --> 01:06:53,780
0,330 330,870 900,1530
get 2 leaders.|
|

2152
01:06:57,240 --> 01:06:58,200
0,270 270,390 390,660 660,780 780,960
And of course not what
当然也不是我们想要的，

2153
01:06:58,200 --> 01:07:00,090
0,90 90,360 360,630 630,1020 1530,1890
we want,| so the main
|所以这件事的要点是

2154
01:07:00,090 --> 01:07:01,560
0,240 240,330 330,540 540,870 900,1470
point of this,| for example
|例如，基本上你只需放入并获得，

2155
01:07:01,560 --> 01:07:03,330
0,120 120,900 1140,1320 1320,1590 1590,1770
is basically you just put

2156
01:07:03,330 --> 01:07:04,530
0,60 60,540 810,960 960,1110 1110,1200
and get,| it's gonna be
|要真正实现测试和设置将是非常困难的。

2157
01:07:04,530 --> 01:07:05,970
0,270 270,750 780,900 900,1140 1140,1440
very hard to actually implement

2158
01:07:05,970 --> 01:07:07,240
0,60 60,300 300,750
the {test-and-set -}.|
|

2159
01:07:07,580 --> 01:07:08,450
0,300 300,360 360,630 630,780 780,870
{} It turns out it's
事实证明，这是可能的，但非常复杂，

2160
01:07:08,450 --> 01:07:10,850
0,540 540,720 720,990 990,1560 1590,2400
possible, but very complex,| use
|使用面包房算法，你可能真的能做到，

2161
01:07:10,850 --> 01:07:12,560
0,330 330,900 900,1320 1320,1470 1470,1710
bakery algorithm, you can actually

2162
01:07:12,560 --> 01:07:13,610
0,300 300,420 420,690 690,870 870,1050
probably {do,it},| {but,it's} not gonna
|但在分布式系统中这样做并不可笑，

2163
01:07:13,610 --> 01:07:14,780
0,240 240,750 750,930 930,1020 1020,1170
be ridiculous like to do

2164
01:07:14,780 --> 01:07:15,980
0,210 210,330 330,390 390,810 810,1200
that in a distributed system,|
|

2165
01:07:17,090 --> 01:07:19,400
0,360 360,840 1020,1530 1620,2070 2070,2310
and so what {zookeeper -}
因此，动物园管理员所做的是，

2166
01:07:19,400 --> 01:07:21,290
0,600 810,1200 1200,1320 1320,1470 1470,1890
does,| {} it just provides
|它只是提供了一些额外的帮助，

2167
01:07:21,290 --> 01:07:24,680
0,150 150,1020 1200,2250 2280,3120
some additional {} help,|
|

2168
01:07:24,710 --> 01:07:25,940
0,600 600,870 870,960 960,1140 1140,1230
to build the sort of
来构建类型基元的类型。

2169
01:07:25,940 --> 01:07:27,560
0,390 390,1110
type primitives.|
|

2170
01:07:27,710 --> 01:07:28,640
0,210 210,390 390,450 450,480 480,930
We'll see in a second.|
我们一会儿就知道了。|

2171
01:07:29,330 --> 01:07:30,600
0,690

2172
01:07:31,120 --> 01:07:32,320
0,120 120,300 300,540 540,720 720,1200
The other thing that usually
另一件事通常是你想知道的

2173
01:07:32,320 --> 01:07:33,280
0,150 150,210 210,390 390,450 450,960
what you want to know|
|

2174
01:07:33,310 --> 01:07:34,870
0,480 480,870 870,1050 1050,1230 1230,1560
and {lab,3} does not provide
实验室3不为您的服务器配置服务或协调服务提供任何支持

2175
01:07:34,870 --> 01:07:37,180
0,540 1170,1590 1590,1830 1830,2040 2040,2310
any support for your server

2176
01:07:37,180 --> 01:07:39,970
0,600 600,1110 1290,1800 1800,2400 2400,2790
configuration service {or,coordination} services| that
|当有人倒下的时候你想知道，

2177
01:07:40,150 --> 01:07:40,810
0,90 90,240 240,300 300,450 450,660
you want to know when

2178
01:07:40,810 --> 01:07:42,760
0,300 300,480 480,960 1380,1560 1560,1950
somebody goes down,| for example
|例如，您想要观察

2179
01:07:42,760 --> 01:07:43,630
0,90 90,210 210,270 270,660 660,870
you want to observe that|
|

2180
01:07:43,630 --> 01:07:44,980
0,450 450,540 540,810 810,990 990,1350
like the leader goes down,|
就像领袖倒下一样，|

2181
01:07:44,980 --> 01:07:46,900
0,300 630,810 810,1170 1170,1560 1560,1920
like so many other parties
就像许多其他政党想知道的那样

2182
01:07:46,900 --> 01:07:47,950
0,120 120,330 330,390 390,720 720,1050
would like to know| like
|就像是领队倒下了，

2183
01:07:48,220 --> 01:07:49,150
0,210 210,300 300,540 540,840 840,930
is the leader down,| so
|这样我们就可以在需要的时候选择一个新的。

2184
01:07:49,150 --> 01:07:49,750
0,120 120,210 210,330 330,540 540,600
that we can choose a

2185
01:07:49,750 --> 01:07:50,710
0,120 120,390 390,480 480,690 690,960
new one if it needed

2186
01:07:50,710 --> 01:07:51,280
0,120
to.|
|

2187
01:07:51,810 --> 01:07:53,460
0,180 180,570 720,1290 1290,1440 1440,1650
And so at least on
因此，至少在使用服务的建筑物的应用上是如此。

2188
01:07:53,460 --> 01:07:55,080
0,90 90,540 540,600 600,900 930,1620
the application of the building

2189
01:07:55,140 --> 01:07:57,080
0,360 360,870 870,1440
using a service.|
|

2190
01:07:57,330 --> 01:07:58,980
0,330 330,720 1110,1380 1380,1500 1500,1650
Okay, so, {} so there
好吧，那么，我们有两样东西是真正想要的，

2191
01:07:58,980 --> 01:07:59,730
0,120 120,240 240,450 450,570 570,750
are two things that we

2192
01:07:59,730 --> 01:08:00,900
0,180 180,660 690,810 810,900 900,1170
really want,| you know one
|你知道，一种是你知道的一种试图获得这种原子性的方式，

2193
01:08:00,900 --> 01:08:01,950
0,330 330,420 420,810 810,960 960,1050
is you know sort of

2194
01:08:01,950 --> 01:08:02,850
0,270 270,450 450,690 690,750 750,900
way of trying to get

2195
01:08:02,850 --> 01:08:04,280
0,120 120,390 390,870
this {atomicity -},|
|

2196
01:08:04,780 --> 01:08:06,490
0,930 960,1140 1140,1290 1290,1380 1380,1710
{} that's what we're looking
这就是我们在动物园管理员设计中寻找的

2197
01:08:06,490 --> 01:08:07,840
0,240 240,360 360,420 420,840 840,1350
for in the zookeeper design|
|

2198
01:08:07,840 --> 01:08:09,070
0,90 90,330 330,690 690,960 960,1230
and then zookeeper design second
然后是动物园饲养员设计，我们在动物园饲养员设计中寻找的第二个是

2199
01:08:09,070 --> 01:08:09,970
0,210 210,300 300,630 630,810 810,900
we were looking for in

2200
01:08:09,970 --> 01:08:12,010
0,270 270,810 810,960 960,1470 1680,2040
zookeeper design is| for an
|让应用程序了解某个节点是否出现故障。

2201
01:08:12,040 --> 01:08:14,260
0,660 660,840 840,1620 1650,2040 2040,2220
application to learn whether some

2202
01:08:14,260 --> 01:08:15,580
0,240 240,420 420,840
node goes down.|
|

2203
01:08:16,680 --> 01:08:17,910
0,270 270,450 450,630 630,750 750,1230
So let's look at the
那么让我们来看一下ZooKeeper API

2204
01:08:17,940 --> 01:08:20,250
0,330 330,900 930,1680 1680,1950 1950,2310
{zookeeper -} API| and really
|我们真正想要了解的是Znode API。

2205
01:08:20,250 --> 01:08:21,120
0,390 390,540 540,600 600,750 750,870
we want to look at

2206
01:08:21,120 --> 01:08:25,420
0,150 150,480 480,840 930,1620
is {znode -} API.|
|

2207
01:08:27,360 --> 01:08:28,380
0,150 150,300 300,480 480,840 840,1020
And you'll see again,| that
你会再次看到，|这实际上是精心设计的，实际上使我们有可能做我们正在寻找的事情。

2208
01:08:28,380 --> 01:08:30,030
0,120 120,360 360,900 900,1500 1500,1650
is actually carefully designed to

2209
01:08:30,030 --> 01:08:31,620
0,240 240,360 360,480 480,1020 1020,1590
actually make it possible to

2210
01:08:32,040 --> 01:08:33,420
0,180 180,270 270,540 540,720 720,1380
do the things that we're

2211
01:08:33,450 --> 01:08:34,860
0,180 180,600 600,870
we're looking for.|
|

2212
01:08:34,980 --> 01:08:36,330
0,240 240,720 720,870 870,1230 1230,1350
Okay, so the way the
好的，所以这个系统的组织方式是

2213
01:08:36,330 --> 01:08:37,740
0,270 270,390 390,1050 1050,1320 1320,1410
system is organized is| you
|你知道有一棵znodes树，

2214
01:08:37,740 --> 01:08:39,000
0,150 150,750 750,810 810,1140 1140,1260
know there's a tree of

2215
01:08:39,000 --> 01:08:41,220
0,180 180,840 1200,1590 1590,2130 2130,2220
{znodes -},| {} typically you
|通常情况下，你知道有一种App1作为Znode，

2216
01:08:41,220 --> 01:08:43,200
0,120 120,390 390,540 540,930 1740,1980
know there's like one sort

2217
01:08:43,200 --> 01:08:44,970
0,120 120,360 360,900 900,1200 1200,1770
of {app1 -} as a

2218
01:08:45,060 --> 01:08:46,800
0,690 690,1200 1230,1410 1410,1590 1590,1740
{znode -},| that might have
|它可能有一些与App1中的机器相对应的子项。

2219
01:08:46,800 --> 01:08:48,240
0,120 120,630 630,750 750,1260 1260,1440
some children that correspond to

2220
01:08:48,240 --> 01:08:50,280
0,300 690,1200 1200,1350 1350,1470 1470,2040
the machines that are part

2221
01:08:50,430 --> 01:08:52,160
0,510 540,720 720,1290
of {app1 -}.|
|

2222
01:08:52,190 --> 01:08:53,660
0,210 210,450 450,690 690,1320 1320,1470
So it's like peer or
所以这就像是同级或机器一，机器二，

2223
01:08:53,660 --> 01:08:56,660
0,450 450,1020 2100,2490 2490,2820 2820,3000
machine one, machine two,| like
|例如IP地址或DNS名称，

2224
01:08:56,660 --> 01:08:58,160
0,300 300,450 450,780 780,1320 1320,1500
maybe {} IP addresses or

2225
01:08:58,160 --> 01:09:01,080
0,450 450,1020 1380,1770 1770,2400
dns names,| machine three,
|第三台机器，它们实际上可能有版本号

2226
01:09:01,080 --> 01:09:02,340
0,450 450,750 750,840 840,1050 1050,1260
{} and they might actually

2227
01:09:02,340 --> 01:09:04,830
0,120 120,420 420,900 960,1770 2370,2490
have version numbers| associated or
|与它们相关联的编号或序列号

2228
01:09:04,830 --> 01:09:07,050
0,390 390,660 660,840 840,1170 1500,2220
sequence numbers with them| and
|基本上，znode可以有三种类型。

2229
01:09:07,050 --> 01:09:08,850
0,450 450,690 690,1260 1410,1740 1740,1800
basically {znodes -} can be

2230
01:09:08,850 --> 01:09:10,260
0,90 90,300 300,870
of three types.|
|

2231
01:09:10,450 --> 01:09:11,110
0,210 210,330 330,420 420,540 540,660
{One -}, they can be
其一，它们可以是常规的，

2232
01:09:11,110 --> 01:09:14,590
0,600 1920,2160 2160,2790 2790,2970 2970,3480
regular,| so they're fault tolerance
|所以他们的容错能力复制了所有这类东西。

2233
01:09:14,590 --> 01:09:15,550
0,510 510,660 660,750 750,900 900,960
replicated all that kind of

2234
01:09:15,550 --> 01:09:17,200
0,420 690,840 840,1320 1350,1500 1500,1650
stuff.| And then they could
|然后它们可能是短暂的，

2235
01:09:17,200 --> 01:09:18,760
0,120 120,240 240,900
be {ephemeral -},|
|

2236
01:09:21,220 --> 01:09:23,230
0,360 360,870 870,1260 1260,1590 1590,2010
and ephemeral basically means that
而短暂基本上意味着节点将自动消失

2237
01:09:23,230 --> 01:09:25,960
0,240 240,540 540,660 660,1500 1560,2730
the node will disappear automatically|
|

2238
01:09:25,960 --> 01:09:28,300
0,720 780,930 930,1590 1830,2100 2100,2340
when the session {} with
当与该机器3的会话离开时。

2239
01:09:28,300 --> 01:09:30,820
0,420 420,1050 1080,1590 1590,1980 1980,2520
that {} the machine 3

2240
01:09:30,910 --> 01:09:32,260
0,420 420,840
goes away.|
|

2241
01:09:32,380 --> 01:09:33,430
0,210 210,510 510,810 810,990 990,1050
So either because there's a
所以要么是因为有网络请愿书，

2242
01:09:33,430 --> 01:09:35,140
0,240 240,960 960,1140 1140,1260 1260,1710
network petition,| there's no heartbeat
|三号机器没有更多的心跳，

2243
01:09:35,140 --> 01:09:36,490
0,240 240,510 510,720 720,1140 1170,1350
more coming in from {}

2244
01:09:36,490 --> 01:09:38,380
0,330 330,810 1140,1650 1650,1740 1740,1890
machine 3,| but at some
|但在某个时候，动物园管理员认为你知道那段时间已经过去了

2245
01:09:38,380 --> 01:09:39,520
0,210 210,330 330,600 600,1080 1080,1140
point {zookeeper -} decides you

2246
01:09:39,520 --> 01:09:40,810
0,90 90,300 300,630 630,720 720,1290
know that session is gone|
|

2247
01:09:41,050 --> 01:09:42,160
0,510 510,720 720,900 900,990 990,1110
and so then it will
然后它会自动删除该节点，

2248
01:09:42,160 --> 01:09:44,050
0,540 540,810 810,1050 1050,1500 1530,1890
{delete -} that node {}

2249
01:09:44,050 --> 01:09:45,200
0,660
automatically,|
|

2250
01:09:46,040 --> 01:09:47,270
0,240 240,330 330,510 510,690 690,1230
and so that's where ephemeral
这就是短暂的节点。

2251
01:09:47,270 --> 01:09:48,300
0,480
nodes.|
|

2252
01:09:49,400 --> 01:09:50,030
0,180 180,270 270,390 390,450 450,630
And then there's a third
然后是第三个是顺序的，

2253
01:09:50,030 --> 01:09:52,040
0,450 480,690 690,930 930,1170 1170,2010
one {} which is sequential,|
|

2254
01:09:52,930 --> 01:09:55,090
0,510 570,1050 1050,1290 1290,1590 1980,2160
oops, go back to the
哦，返回到您键入的第三个节点顺序节点

2255
01:09:55,090 --> 01:09:56,770
0,240 240,720 720,780 780,1410 1410,1680
third one you type node

2256
01:09:56,770 --> 01:09:58,660
0,990
sequential

2257
01:09:58,890 --> 01:10:00,180
0,480 480,600 600,750 750,990 990,1290
nodes| and that really means
|这实际上意味着你知道他们名字中与他们相关联的版本号

2258
01:10:00,180 --> 01:10:01,290
0,240 240,300 300,420 420,660 660,1110
that you know that version

2259
01:10:01,320 --> 01:10:03,000
0,390 390,600 600,1350 1350,1530 1530,1680
version number associated with them

2260
01:10:03,000 --> 01:10:05,580
0,120 120,270 270,750 1140,1950 1950,2580
in their name| and {}
|它们是在特定的Znode下一个接一个地创建的，

2261
01:10:05,580 --> 01:10:07,050
0,270 270,480 480,1080 1080,1320 1320,1470
and they're created one by

2262
01:10:07,050 --> 01:10:09,030
0,510 510,750 750,1140 1140,1380 1380,1980
one in {under -} particular

2263
01:10:09,360 --> 01:10:10,710
0,300 300,720 810,1050 1050,1200 1200,1350
{znode -},| {} all the
|所有的孩子都将在他们的名字中有一个序列号，

2264
01:10:10,710 --> 01:10:13,200
0,480 480,660 660,1200 1560,1920 1950,2490
children will have a sequence

2265
01:10:13,200 --> 01:10:15,000
0,360 360,570 570,780 780,1320 1470,1800
number in their name, {}|
|

2266
01:10:15,000 --> 01:10:16,050
0,330 330,450 450,690 690,780 780,1050
and the nodes are now
并且节点现在按序列号排序。

2267
01:10:16,050 --> 01:10:17,370
0,360 360,480 480,630 630,990 990,1320
ordered by the sequence number.|
|

2268
01:10:19,400 --> 01:10:20,300
0,150 150,300 300,600 600,720 720,900
And so again this might
同样，这可能是第一个序列，

2269
01:10:20,300 --> 01:10:21,350
0,120 120,390 390,600 600,900 900,1050
have sequence number one,| this
|这可能是第二个顺序

2270
01:10:21,350 --> 01:10:22,520
0,270 270,540 540,780 780,1050 1050,1170
might sequence number two| and
|这个可能有序列号3

2271
01:10:22,520 --> 01:10:23,480
0,120 120,300 300,450 450,750 750,960
this might have sequence number

2272
01:10:23,480 --> 01:10:24,590
0,390 390,540 540,720 720,870 870,1110
three| and the new one
|而创建的新文件的序列号将大于3。

2273
01:10:24,590 --> 01:10:25,580
0,150 150,630 630,780 780,930 930,990
gets created will have a

2274
01:10:25,580 --> 01:10:27,080
0,360 360,660 660,1050 1050,1170 1170,1500
sequence number higher than three.|
|

2275
01:10:29,480 --> 01:10:31,970
0,270 270,900 930,1170 1170,1470 1860,2490
Okay, then, there's a API
好的，那么，有一个与之相关的API，

2276
01:10:31,970 --> 01:10:33,440
0,570 570,720 720,1020 1020,1290 1290,1470
associated with that,| but I
|但我想谈一谈，

2277
01:10:33,440 --> 01:10:33,980
0,120 120,180 180,330 330,360 360,540
want to talk a little

2278
01:10:33,980 --> 01:10:37,040
0,150 150,510 510,1440 2700,2910 2910,3060
bit about,| {there's,create} which we
|还有我们已经提到过的Create。

2279
01:10:37,040 --> 01:10:38,270
0,240 240,570 570,630 630,870 870,1230
already mentioned a little bit.|
|

2280
01:10:38,760 --> 01:10:40,080
0,120 120,240 240,450 450,540 540,1320
You know, takes a path,|
你知道，选择一条路，|

2281
01:10:40,440 --> 01:10:41,910
0,540 540,630 630,780 780,900 900,1470
{} it takes some data
它需要一些数据和标志

2282
01:10:41,940 --> 01:10:44,460
0,450 450,1200 1860,2040 2040,2130 2130,2520
and flags| and the flags
|而这些标志对应于这三种情况。

2283
01:10:44,460 --> 01:10:46,740
0,690 960,1140 1140,1290 1290,1590 1590,2280
correspond to the three cases.|
|

2284
01:10:47,850 --> 01:10:49,840
0,180 180,330 330,510 510,1110
And then there's delete,|
然后是删除，|

2285
01:10:50,390 --> 01:10:51,680
0,390 390,510 510,600 600,930 930,1290
and in the previous slide
在上一张幻灯片中，有一点误导

2286
01:10:51,680 --> 01:10:53,000
0,240 240,420 420,540 540,1170 1170,1320
effort little bit misleading| and
|Delete在获取版本号之前先获取一条路径。

2287
01:10:53,000 --> 01:10:54,560
0,300 300,480 480,540 540,930 930,1560
delete takes a path before

2288
01:10:54,590 --> 01:10:55,490
0,180 180,360 360,540 540,570 570,900
it also takes a version

2289
01:10:55,490 --> 01:10:56,440
0,360
number.|
|

2290
01:10:57,980 --> 01:11:01,430
0,750 750,1080 1080,1890 2730,3060 3060,3450
And, {} exists {} takes
而且，Existes在手表中走了一条路。

2291
01:11:01,430 --> 01:11:02,930
0,60 60,630 630,750 750,840 840,1500
a path in a watch.|
|

2292
01:11:05,240 --> 01:11:06,590
0,300 300,450 450,660 660,990 1020,1350
And then there's a {getData
然后是一个getData，

2293
01:11:06,590 --> 01:11:07,920
0,540
-},|
|

2294
01:11:08,280 --> 01:11:10,500
0,720 750,1260 1260,1320 1320,2010 2010,2220
primitive takes a path and
Primitive采用路径和版本号。

2295
01:11:10,500 --> 01:11:11,940
0,300 300,900
version number.|
|

2296
01:11:14,290 --> 01:11:15,040
0,150 150,240 240,450 450,600 600,750
And we'll see that these
我们将看到这些版本号就是诀窍

2297
01:11:15,040 --> 01:11:16,360
0,300 300,570 570,660 660,810 810,1320
version numbers are the trick|
|

2298
01:11:16,420 --> 01:11:17,530
0,330 330,390 390,720 720,840 840,1110
are the key to actually
是真正获得的关键是原子性。

2299
01:11:17,530 --> 01:11:19,150
0,150 150,300 300,900 1170,1380 1380,1620
get are atomicity.| And then
|然后setData有一个数据和版本号。

2300
01:11:19,150 --> 01:11:21,540
0,360 360,990 1110,1860
{setData -} have

2301
01:11:21,540 --> 01:11:24,240
0,630 630,1260 1290,1710 1740,2190 2190,2700
a data and version number.|
|

2302
01:11:26,130 --> 01:11:27,570
0,750 750,900 900,1110 1110,1200 1200,1440
And there's also a call
还有一个关于获取儿童的呼声

2303
01:11:27,570 --> 01:11:28,710
0,90 90,300 300,750 780,960 960,1140
for {getChildren -}| to get
|为了获得特定Znode的实际子节点，

2304
01:11:28,710 --> 01:11:31,530
0,330 330,450 450,990 1020,1410 2670,2820
actual the children of a

2305
01:11:31,530 --> 01:11:33,090
0,330 330,690 930,1260 1260,1500 1500,1560
particular znode,| which takes a
|它走的是一条路，我认为这块手表

2306
01:11:33,090 --> 01:11:34,200
0,600
path,

2307
01:11:34,900 --> 01:11:36,370
0,450 450,510 510,660 660,750 750,1470
and I think the watch|
|

2308
01:11:38,710 --> 01:11:40,150
0,180 180,270 270,420 420,840 870,1440
and they are seeing basically
他们看到的基本上是一次突击行动

2309
01:11:40,150 --> 01:11:41,680
0,330 330,630 630,840 840,1380 1380,1530
a pop out operation| to
|为了真正确保每件事，

2310
01:11:41,680 --> 01:11:43,000
0,270 270,630 630,780 780,960 960,1320
actually ensure that {everything -},|
|

2311
01:11:43,330 --> 01:11:44,410
0,120 120,450 450,570 570,840 840,1080
so if you really need
所以如果你真的需要很强的线性化。

2312
01:11:44,410 --> 01:11:46,400
0,660 660,870 870,1020 1020,1500
strong {linearizability - -}.|
|

2313
01:11:47,450 --> 01:11:48,560
0,600
Okay,
好的，我想谈谈你们知道为什么

2314
01:11:48,620 --> 01:11:49,490
0,180 180,210 210,330 330,660 660,870
so I want to talk

2315
01:11:49,490 --> 01:11:50,240
0,30 30,210 210,330 330,660 660,750
a little bit about you

2316
01:11:50,240 --> 01:11:51,710
0,90 90,570 570,840 840,960 960,1470
know why| you know this
|你知道这个版本的手提式

2317
01:11:51,740 --> 01:11:53,870
0,450 450,600 600,1200 1200,1800 1830,2130
version of a handy| and
|所以，让我们来看一个特定的例子，这个简单的例子，

2318
01:11:53,870 --> 01:11:56,690
0,450 690,1380 1440,1890 1890,2730 2730,2820
so, {} let's look at

2319
01:11:56,690 --> 01:11:58,010
0,150 150,570 570,930 930,1020 1020,1320
a particular example, the simple

2320
01:11:58,010 --> 01:11:58,850
0,420 420,450 450,570 570,720 720,840
example,| I can come up
|我通常可以想出一个基本实现计数器的方法。

2321
01:11:58,850 --> 01:12:00,290
0,270 270,630 630,990 990,1350 1350,1440
with usually basically implementing a

2322
01:12:00,290 --> 01:12:01,340
0,420
counter.|
|

2323
01:12:07,090 --> 01:12:08,590
0,660 660,900 900,1050 1050,1170 1170,1500
{} And so the way
所以你写这本书的方式，

2324
01:12:08,590 --> 01:12:11,380
0,390 390,540 540,1050 1290,2220
you would write the,|
|

2325
01:12:11,560 --> 01:12:13,030
0,570 750,960 960,1080 1080,1380 1380,1470
{} if you write you
如果你写下你知道的，

2326
01:12:13,030 --> 01:12:14,620
0,330 330,690 960,1230 1230,1320 1320,1590
know,| {okay,so}, let me actually
|好的，那么，让我首先得到写入解决方案，

2327
01:12:14,620 --> 01:12:15,760
0,240 240,360 360,450 450,660 660,1140
first get the write solution,|
|

2328
01:12:15,760 --> 01:12:18,160
0,480 540,1140 1140,1320 1320,1530 1650,2400
so while {you,know} {} true,|
所以当你知道真相的时候，|

2329
01:12:19,450 --> 01:12:20,110
0,120 120,210 210,330 330,570 570,660
you know the way you
你知道你实现增量的方式，

2330
01:12:20,110 --> 01:12:21,940
0,390 390,1050 1350,1560 1560,1770 1770,1830
implement increment,| so there's the
|所以这里有这个计数器递增的伪代码

2331
01:12:21,940 --> 01:12:23,740
0,360 360,630 630,750 750,1380 1530,1800
pseudo code for increment of

2332
01:12:23,740 --> 01:12:26,050
0,120 120,750 930,1500 1500,1830 1830,2310
this counter| is you do
|就是你得到了xv，你知道你得到了计数器的数据，

2333
01:12:26,110 --> 01:12:28,200
0,330 360,810 810,1530
get x v,

2334
01:12:28,290 --> 01:12:30,220
0,270 270,510 510,1140
{you,know,you} {getData -}

2335
01:12:31,480 --> 01:12:33,220
0,210 210,300 300,930
of the counter,|
|

2336
01:12:34,720 --> 01:12:37,980
0,840 840,1380 1650,2370
{getData -} count.|
GetData计数。|

2337
01:12:39,160 --> 01:12:41,180
0,180 180,720 720,720
And then, {}
然后，如果您知道setData Count，

2338
01:12:42,050 --> 01:12:43,320
0,780
if

2339
01:12:43,380 --> 01:12:45,940
0,180 180,300 300,690 690,1350
you know {setData -}

2340
01:12:47,720 --> 01:12:49,300
0,1050
count,|
|

2341
01:12:50,470 --> 01:12:52,510
0,450 810,1200 1200,1440 1440,1620 1620,2040
that's a sort of {x+1
这是一种x+1，版本号。

2342
01:12:52,510 --> 01:12:54,380
0,690
-},

2343
01:12:56,140 --> 01:12:58,340
0,870 870,1260 1260,1680
and {the,version} numbers.|
|

2344
01:12:59,100 --> 01:13:00,240
0,540 570,690 690,930 930,1050 1050,1140
And if that is the
如果是这样的话，那就分手吧。

2345
01:13:00,240 --> 01:13:02,440
0,600 600,960 960,1440
case, then break.|
|

2346
01:13:03,920 --> 01:13:05,300
0,180 180,300 300,450 450,930 990,1380
Okay, so let me quickly
好的，让我快速回顾一下，

2347
01:13:05,300 --> 01:13:06,440
0,150 150,330 330,690 870,1050 1050,1140
go over this,| so to
|因此，为了将数据返回到当前版本号和密钥的值，

2348
01:13:06,440 --> 01:13:08,570
0,180 180,1410 1440,1920 1920,2010 2010,2130
get data returns to the

2349
01:13:08,570 --> 01:13:10,130
0,270 270,540 540,1050 1080,1470 1470,1560
current version number and the

2350
01:13:10,130 --> 01:13:13,460
0,660 660,1560 1560,1980 2010,2580 3150,3330
value of the key,| so
|所以你知道的钥匙或路径，

2351
01:13:13,460 --> 01:13:14,540
0,150 150,330 330,480 480,570 570,1080
the key or the path

2352
01:13:14,570 --> 01:13:15,620
0,90 90,600 600,840 840,960 960,1050
you know,| so for the
|因此，就文件数量而言，

2353
01:13:15,620 --> 01:13:17,000
0,300 300,780 780,990 990,1320 1320,1380
file count,| it returns the
|它返回值及其在该特定点上的版本，

2354
01:13:17,000 --> 01:13:18,170
0,360 360,540 540,660 660,960 960,1170
value and its version over

2355
01:13:18,170 --> 01:13:19,220
0,150 150,510 510,780 780,930 930,1050
that particular point,| when they
|当它们读取，然后您调用，setData接受三个参数，

2356
01:13:19,220 --> 01:13:20,930
0,150 150,240 240,660 1260,1410 1410,1710
did {read -} and then

2357
01:13:20,930 --> 01:13:22,760
0,150 150,1170 1170,1350 1350,1560 1560,1830
you call and {setData -}

2358
01:13:22,760 --> 01:13:23,870
0,180 180,330 330,900 900,990 990,1110
takes three arguments,| you know
|您知道路径会更新新值

2359
01:13:23,870 --> 01:13:25,700
0,150 150,630 1050,1530 1530,1650 1650,1830
the path updates the new

2360
01:13:25,700 --> 01:13:26,750
0,480 480,660 660,780 780,960 960,1050
value| in this case it's
|在这种情况下，它将是x+1，

2361
01:13:26,750 --> 01:13:27,320
0,120 120,180 180,240 240,390 390,570
going to be {x+1 -

2362
01:13:27,320 --> 01:13:28,070
0,240 240,450 450,540 540,690 690,750
-},| because we want to
|因为我们希望将该值递增1

2363
01:13:28,070 --> 01:13:29,690
0,540 540,750 750,1050 1050,1140 1140,1620
increment the value by one|
|

2364
01:13:29,930 --> 01:13:31,400
0,330 330,450 450,870 870,1260 1260,1470
and it actually passes in
它实际上是通过版本号传入的

2365
01:13:31,400 --> 01:13:32,960
0,180 180,270 270,540 540,960 1050,1560
over the version number| and
|而setData的语义是

2366
01:13:33,080 --> 01:13:34,080
0,690
the

2367
01:13:34,290 --> 01:13:35,850
0,540 540,1020 1020,1110 1110,1290 1290,1560
{} semantics of {setData -}

2368
01:13:35,850 --> 01:13:36,870
0,240 240,510 510,840 840,930 930,1020
is that| if you know
|如果您知道版本号仍然相同，

2369
01:13:36,870 --> 01:13:38,610
0,90 90,390 390,840 1320,1530 1530,1740
the version numbers are still

2370
01:13:38,610 --> 01:13:39,800
0,90 90,690
the same,|
|

2371
01:13:40,330 --> 01:13:41,770
0,660 660,750 750,960 960,1170 1170,1440
then the {setData -} actually
则setData实际发生，否则不发生。

2372
01:13:41,770 --> 01:13:43,980
0,600 630,810 810,1260 1260,1650
happens and otherwise not.|
|

2373
01:13:44,770 --> 01:13:45,970
0,180 180,570 570,720 720,870 870,1200
So what does this protect
那么，这能防止什么呢。

2374
01:13:45,970 --> 01:13:47,020
0,540
against.|
|

2375
01:13:49,740 --> 01:13:51,930
0,330 330,510 510,1050 1050,1320 1320,2190
{} This prevents you from
这基本上可以防止您交错Get-and-Set。

2376
01:13:52,620 --> 01:13:54,600
0,660 660,780 780,1230 1230,1530 1530,1980
interleaving the {get-and-set - -},

2377
01:13:54,780 --> 01:13:57,660
0,480 1620,1800 1800,1950 1950,2160 2160,2880
basically.| So if like two
|因此，如果两个操作，两个客户端确实在同一时间获得，

2378
01:13:57,660 --> 01:13:59,430
0,990 990,1080 1080,1410 1410,1590 1590,1770
operate, two clients did get

2379
01:13:59,430 --> 01:14:00,780
0,60 60,150 150,390 390,870 1080,1350
at the same time,| they
|他们会读到，

2380
01:14:00,780 --> 01:14:03,660
0,210 210,750 780,1440
would read, {}|
|

2381
01:14:03,980 --> 01:14:04,850
0,300 300,510 510,690 690,780 780,870
they do get at the
他们确实是在同一时间，

2382
01:14:04,850 --> 01:14:06,280
0,240 240,810
same time,|
|

2383
01:14:06,640 --> 01:14:08,200
0,300 300,570 570,840 840,1110 1110,1560
they get both back say
他们两个都回来了，说你知道吗x0

2384
01:14:08,200 --> 01:14:10,420
0,120 120,240 240,750 930,1380 1380,2220
you know whatever x 0|
|

2385
01:14:10,900 --> 01:14:13,390
0,450 450,720 720,1080 1080,1800 2190,2490
and version number 0 x
和版本号0×0版本号0。

2386
01:14:13,390 --> 01:14:16,080
0,750 750,1020 1020,1290 1290,2010
0 version number 0.|
|

2387
01:14:16,170 --> 01:14:18,210
0,660 990,1440 1440,1560 1560,1740 1740,2040
{} Then they do both
然后它们都会放在哪里，就像本例中的setData一样。

2388
01:14:18,210 --> 01:14:19,470
0,90 90,540 810,1020 1020,1200 1200,1260
{} put where like in

2389
01:14:19,470 --> 01:14:20,550
0,120 120,300 300,360 360,570 570,1080
this case a {setData -}.|
|

2390
01:14:22,400 --> 01:14:23,960
0,180 180,600 600,840 840,1110 1110,1560
So the {setData -} with
所以，无论x是1，setData都是，

2391
01:14:23,960 --> 01:14:25,580
0,120 120,210 210,780 870,1380 1380,1620
you know whatever {} x

2392
01:14:25,580 --> 01:14:26,780
0,60 60,600
is 1,|
|

2393
01:14:27,040 --> 01:14:29,260
0,210 210,540 540,810 810,1530
{you,know} version number 0.|
您知道版本号为0。|

2394
01:14:29,260 --> 01:14:30,190
0,360 360,510 510,690 690,870 870,930
Also, this guy does the
另外，这个人也做了同样的事情，

2395
01:14:30,190 --> 01:14:32,170
0,300 300,750 780,1320 1350,1440 1440,1980
same thing,| set you know
|把你知道的设定为10。

2396
01:14:32,720 --> 01:14:35,360
0,600 630,1410
1 0.|
|

2397
01:14:35,480 --> 01:14:37,130
0,540 540,930 930,1020 1020,1140 1140,1650
{} And you know why
您知道为什么，因此两个客户端都发出了两个SET操作

2398
01:14:37,130 --> 01:14:39,020
0,180 180,480 480,1380 1380,1590 1590,1890
and so both both clients

2399
01:14:39,020 --> 01:14:40,670
0,540 540,750 750,930 930,1170 1170,1650
issued to two set operations|
|

2400
01:14:40,670 --> 01:14:42,380
0,90 90,330 330,510 510,1080 1080,1710
are both set operation [].|
都是设置操作[]。|

2401
01:14:48,100 --> 01:14:49,300
0,660

2402
01:14:50,590 --> 01:14:51,840
0,270 270,690
Well, no.|
嗯，没有。|

2403
01:14:51,900 --> 01:14:53,600
0,120 120,300 300,480 480,870
And yeah, why not.|
是啊，为什么不呢。|

2404
01:14:53,660 --> 01:14:55,190
0,870 870,1110 1110,1170 1170,1260 1260,1530
Because one of the version
因为其中一个版本号将是错误的。

2405
01:14:55,190 --> 01:14:56,760
0,300 300,420 420,660 660,1080
numbers will be wrong.|
|

2406
01:14:56,960 --> 01:14:58,670
0,360 360,540 540,900 900,1230 1440,1710
Yeah, right, like what one
是的，对，就像两个人中谁先走，

2407
01:14:58,670 --> 01:14:59,570
0,90 90,150 150,300 300,510 510,900
of the two goes first,|
|

2408
01:14:59,600 --> 01:15:00,620
0,480 480,600 600,750 750,870 870,1020
why does one of the
为什么两个人中有一个会先走。

2409
01:15:00,620 --> 01:15:01,920
0,150 150,300 300,780
two go first.|
|

2410
01:15:02,440 --> 01:15:04,180
0,420 420,660 660,960 960,1350 1350,1740
Because all writes are {linearizable
因为所有写入都是可线性化的。

2411
01:15:04,180 --> 01:15:05,470
0,180 180,480 540,840 840,1020 1020,1290
- -}.| Yeah, all writes
|是的，所有的写入都是可线性化的，

2412
01:15:05,470 --> 01:15:06,760
0,480 480,750 750,900 900,1110 1110,1290
{are,linearizable},| also they're going some
|而且他们正在进行一些总的订单，

2413
01:15:06,760 --> 01:15:08,200
0,240 240,690 720,1200 1230,1320 1320,1440
total order,| so you know
|所以你知道我们可以选一个，

2414
01:15:08,200 --> 01:15:09,040
0,90 90,210 210,360 360,690 690,840
we can pick one,| so
|所以我们假设这个人先来，

2415
01:15:09,040 --> 01:15:09,880
0,150 150,300 300,480 480,660 660,840
let's say this guy goes

2416
01:15:09,880 --> 01:15:11,110
0,360 360,510 510,690 690,810 810,1230
first,| or this the operation
|要不就先做这个手术。

2417
01:15:11,110 --> 01:15:12,240
0,180 180,600
goes first.|
|

2418
01:15:12,300 --> 01:15:14,700
0,180 180,360 360,540 540,1080 1080,2400
So that will increase the,
所以这会增加，这会增加正确的值，

2419
01:15:14,880 --> 01:15:17,440
0,840 840,990 990,1410 1410,1980
that will increase the,

2420
01:15:17,640 --> 01:15:21,330
0,780 1200,1830 1830,2520 2520,3060 3180,3690
the value correct,| one {}
|从零到一是正确的

2421
01:15:21,330 --> 01:15:22,020
0,120 120,360 360,420 420,600 600,690
from zero to one is

2422
01:15:22,020 --> 01:15:23,760
0,540 540,870 870,1170 1170,1320 1320,1740
correctly| and but will also
|而且也将会执行，

2423
01:15:23,760 --> 01:15:25,380
0,660 660,870 870,1320 1320,1560 1560,1620
and will execute,| because the
|因为版本号是匹配的，对，

2424
01:15:25,380 --> 01:15:26,850
0,300 300,600 600,1050 1080,1320 1320,1470
version numbers match, right,| like
|比如版本号0实际上就是当前的版本号，

2425
01:15:26,850 --> 01:15:27,870
0,180 180,420 420,570 570,930 930,1020
the version number 0 is

2426
01:15:27,870 --> 01:15:28,800
0,240 240,360 360,450 450,660 660,930
actually what the current version

2427
01:15:28,800 --> 01:15:30,630
0,240 240,570 960,1230 1230,1560 1590,1830
number is,| so the version
|因此，版本号与增量匹配

2428
01:15:30,630 --> 01:15:32,370
0,210 210,600 600,720 720,1110 1110,1740
numbers match the increment happens|
|

2429
01:15:32,490 --> 01:15:34,770
0,180 180,390 390,630 630,1290 1620,2280
and {setData -} returns true.|
并且setData返回TRUE。|

2430
01:15:35,360 --> 01:15:36,080
0,240 240,330 330,540 540,660 660,720
What will happen with the
第二个会发生什么，

2431
01:15:36,080 --> 01:15:37,070
0,300 300,540 540,660 660,720 720,990
second one,| while the second
|而第二个版本，版本号将不匹配，

2432
01:15:37,070 --> 01:15:38,090
0,210 210,300 300,540 540,750 750,1020
one, the version numbers won't

2433
01:15:38,090 --> 01:15:39,350
0,330 330,570 570,660 660,960 960,1260
match,| because the version number
|因为版本号会增加，

2434
01:15:39,350 --> 01:15:40,790
0,180 180,270 270,870 870,1170 1170,1440
will be increased,| because of
|由于之前的setData操作

2435
01:15:40,820 --> 01:15:42,860
0,330 330,870 870,1080 1080,1710 1890,2040
{} previous setData operation| and
|因此，第二个setData操作将失败

2436
01:15:42,860 --> 01:15:44,270
0,330 330,390 390,750 750,990 990,1410
therefore the second setData operation

2437
01:15:44,270 --> 01:15:45,890
0,180 180,750 1140,1290 1290,1500 1500,1620
will fail| and so and
|然后，客户端将循环返回并重试

2438
01:15:45,890 --> 01:15:47,060
0,360 360,450 450,780 780,960 960,1170
then the client will loop

2439
01:15:47,060 --> 01:15:48,950
0,480 480,570 570,780 780,1350 1350,1890
back and try again| and
|试着，试着再拍一次，做一个增量。

2440
01:15:49,250 --> 01:15:52,040
0,540 540,780 780,1140 1140,2580 2610,2790
{} try to and try

2441
01:15:52,040 --> 01:15:53,030
0,120 120,270 270,510 510,900 900,990
to take another shot and

2442
01:15:53,030 --> 01:15:54,280
0,90 90,240 240,750
do the increment.|
|

2443
01:15:54,480 --> 01:15:56,670
0,150 150,420 420,870 960,1860 1860,2190
And correct, so what happens
正确，所以在这种情况下发生的事情是正确的，

2444
01:15:56,670 --> 01:15:57,540
0,60 60,210 210,510 510,600 600,870
in this case is correct,|
|

2445
01:15:57,540 --> 01:15:58,950
0,210 210,360 360,510 510,660 660,1410
even though the two clients
即使两个客户端同时执行该操作，

2446
01:15:59,040 --> 01:16:02,130
0,570 570,660 660,1380 1620,2460 2700,3090
executed the operation concurrently, {}|
|

2447
01:16:02,130 --> 01:16:03,540
0,240 240,330 330,780 780,900 900,1410
if the interleaving is bad,|
如果交织不好，|

2448
01:16:03,540 --> 01:16:04,770
0,60 60,180 180,780 810,1050 1050,1230
you know the this piece
你知道这段代码实际上会做写的事情，

2449
01:16:04,770 --> 01:16:05,610
0,60 60,360 360,540 540,720 720,840
of code will actually do

2450
01:16:05,610 --> 01:16:06,720
0,210 210,510 510,750 750,840 840,1110
the write thing,| the second
|第二个客户端将重试

2451
01:16:06,720 --> 01:16:08,010
0,240 240,330 330,540 540,1020 1110,1290
client will try again| and
|结果就是你知道，

2452
01:16:08,010 --> 01:16:08,910
0,90 90,210 210,690 690,780 780,900
as a result you know

2453
01:16:08,910 --> 01:16:09,780
0,360
the,|
|

2454
01:16:09,810 --> 01:16:11,580
0,600 600,720 720,870 870,1380 1380,1770
what the end value will
最终的价值会是什么，你知道应该是什么。

2455
01:16:11,580 --> 01:16:13,110
0,390 420,510 510,630 630,960 1110,1530
be you know to supposed

2456
01:16:13,110 --> 01:16:14,820
0,300 510,1080
to one.|
|

2457
01:16:14,990 --> 01:16:16,260
0,720
Okay?|
好吧?|

2458
01:16:19,430 --> 01:16:20,740
0,120 120,210 210,330 330,780
Does that make sense?|
这说得通吗？|

2459
01:16:23,860 --> 01:16:24,940
0,150 150,480 480,690 690,930 930,1080
If you've done any sort
如果您在过去做过任何类型的无锁编程，

2460
01:16:24,940 --> 01:16:26,320
0,120 120,390 390,600 600,1290 1290,1380
of {lock-free -} programming in

2461
01:16:26,320 --> 01:16:27,970
0,90 90,660 750,960 960,1500 1500,1650
the past,| {} then this
|那么你现在可能看起来很眼熟了

2462
01:16:27,970 --> 01:16:29,110
0,150 150,300 300,540 540,720 720,1140
might now look very familiar

2463
01:16:29,110 --> 01:16:30,040
0,120 120,300 390,600 600,720 720,930
to you| and so this
|所以这种无锁的风格基本上就是动物园管理员鼓励这种无锁的编程风格。

2464
01:16:30,040 --> 01:16:30,940
0,150 150,300 300,600 600,690 690,900
sort of style of {lock-free

2465
01:16:30,940 --> 01:16:32,770
0,120 120,750 750,1080 1080,1290 1290,1830
- -} basically {zookeeper -}

2466
01:16:32,800 --> 01:16:34,120
0,240 240,690 690,1050 1050,1260 1260,1320
to encourage this sort of

2467
01:16:34,120 --> 01:16:35,440
0,360 360,480 480,720 720,870 870,1320
style of {lock-free -} programming.|
|

2468
01:16:44,840 --> 01:16:46,480
0,480 480,1050
Okay. {}|
好吧。|

2469
01:16:47,450 --> 01:16:48,890
0,300 300,450 450,630 630,720 720,1440
What I'd like to do,|
我想做的是，|

2470
01:16:49,010 --> 01:16:50,000
0,270 270,510 510,690 690,930 930,990
since I'm always running out
因为我总是没时间了，

2471
01:16:50,000 --> 01:16:50,900
0,60 60,420 420,690 690,840 840,900
of time,| last time I
|上次我跑加时赛是，

2472
01:16:50,900 --> 01:16:53,450
0,240 240,840 840,1350 1350,1860 2190,2550
ran overtime is,| I'll want
|我想谈几点关于原木的问题，

2473
01:16:53,450 --> 01:16:54,410
0,60 60,240 240,360 360,510 510,960
to talk with some points

2474
01:16:54,500 --> 01:16:57,110
0,840 840,1560 1920,2460 2460,2490 2490,2610
about logs,| but I will
|但我下次会这么做的，

2475
01:16:57,110 --> 01:17:01,550
0,180 180,1230 1230,1530 1530,1860 2340,4440
do that next time,| the
|下一堂课，

2476
01:17:01,550 --> 01:17:02,900
0,270 450,960 960,1110 1110,1200 1200,1350
{next,lecture},| now let me just
|现在让我来总结一下我们到目前为止所学到的东西

2477
01:17:02,900 --> 01:17:04,100
0,150 150,360 420,930 930,1020 1020,1200
sort of summarize what we've

2478
01:17:04,100 --> 01:17:05,510
0,240 240,420 420,900 900,990 990,1410
learned so far| and then
|然后我将在下一节课中更多地谈论动物园饲养员。

2479
01:17:05,510 --> 01:17:06,530
0,450 450,630 630,660 660,840 840,1020
I'll talk a little bit

2480
01:17:06,530 --> 01:17:07,460
0,270 270,480 480,600 600,840 840,930
more about {zookeeper -} {}

2481
01:17:07,460 --> 01:17:09,080
0,150 150,480 540,900 900,1230
in the next lecture.|
|

2482
01:17:10,560 --> 01:17:12,000
0,750
So,
所以，总而言之，

2483
01:17:12,030 --> 01:17:14,840
0,510 510,1230
as summary,|
|

2484
01:17:15,550 --> 01:17:17,260
0,480 480,720 720,1170 1200,1650 1650,1710
{ -} so basically you
所以基本上你知道一个非常成功的设计，

2485
01:17:17,260 --> 01:17:18,310
0,150 150,300 300,390 390,630 630,1050
know just a very successful

2486
01:17:18,310 --> 01:17:19,820
0,600
design,|
|

2487
01:17:22,230 --> 01:17:23,680
0,660

2488
01:17:25,300 --> 01:17:27,010
0,420 420,930 960,1200 1200,1350 1350,1710
widely used,| {} you can
被广泛使用，|你可以在GitHub上下载你知道的，

2489
01:17:27,040 --> 01:17:28,930
0,960 960,1050 1050,1440 1500,1740 1740,1890
download you know on {github

2490
01:17:28,930 --> 01:17:30,340
0,300 300,450 450,900 930,1110 1110,1410
-},| you can play around
|你可以玩它，如果你想的话

2491
01:17:30,340 --> 01:17:31,000
0,150 150,270 270,330 330,420 420,660
with it, if you wanted

2492
01:17:31,000 --> 01:17:32,800
0,330 690,1260 1260,1410 1410,1740 1740,1800
to| {} and one of
|其中有趣的一点是，

2493
01:17:32,800 --> 01:17:33,820
0,90 90,240 240,450 450,780 780,1020
the things that's interesting about

2494
01:17:33,820 --> 01:17:34,990
0,210 510,870 870,960 960,1080 1080,1170
it,| compared to all the
|与我们目前看到的所有系统相比，

2495
01:17:34,990 --> 01:17:35,920
0,360 360,510 510,570 570,750 750,930
systems that we look so

2496
01:17:35,920 --> 01:17:38,650
0,420 600,750 750,1380 1380,2070 2070,2730
far,| it has weaker consistency,|
|它的一致性较弱，|

2497
01:17:38,650 --> 01:17:40,540
0,240 240,750 750,1350 1350,1440 1440,1890
which weaker consistency, I mean
这种较弱的一致性，我的意思是，它不提供线性化。

2498
01:17:40,630 --> 01:17:42,280
0,120 120,330 330,660 660,1020 1020,1650
it doesn't provide {linearizability -}.|
|

2499
01:17:44,350 --> 01:17:46,300
0,690 690,1170 1530,1710 1710,1830 1830,1950
{} And you know we're
你知道，我们基本上把它看作是一个精心设计的API，

2500
01:17:46,300 --> 01:17:47,740
0,390 390,570 570,1050 1050,1260 1260,1440
seeing that basically as a

2501
01:17:47,740 --> 01:17:50,440
0,750 870,1440 1440,2280 2280,2460 2460,2700
careful design API,| at least
|至少我们已经看到了精心设计的API的某些方面，

2502
01:17:50,440 --> 01:17:51,580
0,210 210,390 390,630 630,1050 1050,1140
we've seen some aspects of

2503
01:17:51,580 --> 01:17:53,170
0,180 180,510 510,840 840,1320 1320,1590
the careful design API,| that
|尽管它实际上具有很好的一致性，

2504
01:17:53,230 --> 01:17:54,730
0,720 720,810 810,1110 1110,1260 1260,1500
despite the fact that actually

2505
01:17:54,730 --> 01:17:56,170
0,120 120,270 270,390 390,1230 1290,1440
has really good consistency,| you
|你仍然可以使用它

2506
01:17:56,170 --> 01:17:57,490
0,90 90,510 510,720 720,1020 1020,1320
can still use it| and
|事实上，你知道你可以把它用在非常重要的应用上，

2507
01:17:57,670 --> 01:17:58,600
0,150 150,420 420,510 510,780 780,930
in fact you know you

2508
01:17:58,600 --> 01:17:59,290
0,120 120,300 300,390 390,570 570,690
can use it actually for

2509
01:17:59,290 --> 01:18:01,060
0,60 60,360 360,900 930,1680 1680,1770
{} pretty important applications,| you
|您实际上可以将ZooKeeper用作配置服务，

2510
01:18:01,060 --> 01:18:02,410
0,150 150,390 390,870 870,1200 1200,1350
can actually use {zookeeper -

2511
01:18:02,410 --> 01:18:05,020
0,270 270,480 480,1080 1080,1650 2130,2610
-} {as,a} configuration service,| like
|就像它跟踪的主要目的看起来像是谁的初选谁在里面，谁想要一套复制品等等，

2512
01:18:05,020 --> 01:18:06,670
0,180 180,450 450,960 1260,1380 1380,1650
its main purpose of keeping

2513
01:18:06,670 --> 01:18:08,680
0,420 420,570 570,870 900,1320 1320,2010
track looks like whose primary

2514
01:18:08,680 --> 01:18:10,750
0,780 780,900 900,1410 1680,1920 1920,2070
who's in the, {} who

2515
01:18:10,750 --> 01:18:12,250
0,540 540,630 630,810 810,900 900,1500
wants the set of replicas

2516
01:18:12,250 --> 01:18:13,840
0,390 390,960 1170,1350 1350,1470 1470,1590
etc etc,| and so for
|因此，对于这种作为配置服务器的关键操作，

2517
01:18:13,840 --> 01:18:15,220
0,90 90,270 270,330 330,750 750,1380
this sort of crucial operation

2518
01:18:15,250 --> 01:18:16,510
0,210 210,390 390,450 450,960 960,1260
of being a configuration server,|
|

2519
01:18:16,510 --> 01:18:17,500
0,120 120,420 420,480 480,600 600,990
that has to be correct,|
这必须是正确的，|

2520
01:18:17,500 --> 01:18:18,640
0,180 180,720 720,900 900,1050 1050,1140
because otherwise we get to
因为否则我们就会有分裂大脑的问题，

2521
01:18:18,640 --> 01:18:20,440
0,330 330,570 570,1110 1380,1710 1710,1800
split brain problem,| {} the
|API精心设计，

2522
01:18:20,440 --> 01:18:22,450
0,390 390,810 810,1650 1650,1800 1800,2010
API carefully designed,| so that
|因此，如果您正确使用API，您仍然可以在其上实现这个关键的应用程序，

2523
01:18:22,450 --> 01:18:23,620
0,90 90,420 420,630 630,690 690,1170
if you use the API

2524
01:18:23,650 --> 01:18:26,380
0,690 930,1650 1650,2160 2160,2310 2310,2730
correctly, you still can implement

2525
01:18:26,380 --> 01:18:29,380
0,270 270,1080 1200,2160 2160,2850 2850,3000
this crucial {} application on

2526
01:18:29,380 --> 01:18:30,360
0,300 300,390 390,660
top of it,|
|

2527
01:18:30,570 --> 01:18:32,160
0,750 750,840 840,1170 1170,1290 1290,1590
despite the fact that actually
尽管这实际上提供了弱一致性。

2528
01:18:32,160 --> 01:18:34,140
0,360 360,600 600,1320
provides weak consistency.|
|

2529
01:18:34,420 --> 01:18:35,530
0,480 480,570 570,810 810,1050 1050,1110
And the cool part of
最酷的是

2530
01:18:35,530 --> 01:18:37,870
0,300 300,450 450,930 990,1440 1440,2340
that is| that this discrimination
|你知道，这种区别就像一种精心设计的API

2531
01:18:37,930 --> 01:18:39,250
0,120 120,330 330,690 690,990 990,1320
you know {like,sort,of} careful design

2532
01:18:39,250 --> 01:18:40,960
0,540 540,630 630,690 690,930 930,1710
API| and the weaker consistency
|而较弱的一致性使我们能够获得真正高性能的动物园管理员。

2533
01:18:41,050 --> 01:18:41,980
0,360 360,450 450,540 540,840 840,930
allows us to get you

2534
01:18:41,980 --> 01:18:42,880
0,210 210,390 390,600 600,690 690,900
know {zookeeper -} {} really

2535
01:18:42,880 --> 01:18:44,540
0,180 180,870
high performance.|
|

2536
01:18:49,400 --> 01:18:50,570
0,210 210,360 360,780 780,1080 1080,1170
And we'll see later in
我们将在后面的课程中看到，

2537
01:18:50,570 --> 01:18:52,640
0,240 240,750 810,1650 1650,1920 1920,2070
later lectures,| more of this
|更多这种试图削弱一致性保证的伎俩

2538
01:18:52,640 --> 01:18:54,020
0,390 390,450 450,840 870,990 990,1380
sort of trick of trying

2539
01:18:54,020 --> 01:18:57,050
0,300 690,1530 1530,1800 1800,2400 2400,3030
to weaken the consistency guarantees|
|

2540
01:18:57,050 --> 01:18:58,370
0,210 210,630 630,690 690,1110 1110,1320
to actually you know get
实际上，你知道为了一场更好的表演而变得更好

2541
01:18:58,370 --> 01:19:00,380
0,510 510,810 810,1410 1440,1830 1830,2010
better for a get better

2542
01:19:00,380 --> 01:19:02,630
0,630 630,1080 1230,2040 2040,2160 2160,2250
performance| or {} you know
|或者您知道，即使网络分区，也能够继续。

2543
01:19:02,630 --> 01:19:06,350
0,660 660,1080 1230,2790 2820,3270 3270,3720
able to {} continue despite

2544
01:19:06,350 --> 01:19:07,660
0,240 240,960
network partitions.|
|

2545
01:19:09,810 --> 01:19:10,950
0,270 270,390 390,480 480,690 690,1140
Okay, let me stop here,|
好了，让我停在这里，|

2546
01:19:10,980 --> 01:19:13,500
0,480 480,720 720,990 990,1440 1440,2520
{} and then I'll resume
然后我会在一小段时间内继续。

2547
01:19:14,110 --> 01:19:15,130
0,240 240,420 420,480 480,660 660,1020
{} in a little while.|
|

2548
01:19:15,720 --> 01:19:16,710
0,210 210,420 420,600 600,900 900,990
The next time around for
下一次来听[]讲座。

2549
01:19:16,710 --> 01:19:18,000
0,120 120,330 330,720
the [] lecture.|
|

2550
01:19:19,280 --> 01:19:20,600
0,210 210,810
Any questions?|
有什么问题吗？|

2551
01:19:21,280 --> 01:19:23,260
0,360 660,960 960,1080 1080,1680 1680,1980
Where again as usual,| if
像往常一样，|如果你一定要走，请感觉到放手，

2552
01:19:23,260 --> 01:19:24,250
0,90 90,210 210,300 300,780 780,990
you have to go, please

2553
01:19:24,250 --> 01:19:25,420
0,360 360,450 450,780 780,1020 1020,1170
feel to let go,| if
|如果你想留下来问更多的问题，

2554
01:19:25,420 --> 01:19:26,320
0,180 180,360 360,480 480,630 630,900
you want to hang around

2555
01:19:26,320 --> 01:19:27,460
0,150 150,390 390,600 600,1050 1050,1140
and ask more questions,| you
|你知道，请随意，请随意这样做。

2556
01:19:27,460 --> 01:19:28,840
0,90 90,450 450,810 960,1230 1230,1380
know feel free, please feel

2557
01:19:28,840 --> 01:19:30,140
0,210 210,300 300,420 420,720
free to do so.|
|

2558
01:19:41,940 --> 01:19:43,260
0,420 450,780 780,900 900,1050 1050,1320
I'm sorry, can you go
抱歉，你能看一下这张幻灯片吗，上面写着，

2559
01:19:43,260 --> 01:19:45,840
0,180 180,450 450,1290 1320,2070 2070,2580
to this slide which said

2560
01:19:45,900 --> 01:19:47,000
0,570
the

2561
01:19:47,220 --> 01:19:49,140
0,420 420,1410
{} set,|
|

2562
01:19:49,140 --> 01:19:51,450
0,450 720,990 990,1560 1560,2040 2040,2310
{} the unsuccessful example for
集合以及测试和集合的不成功示例。

2563
01:19:51,450 --> 01:19:53,320
0,180 180,600 630,1320
the set and

2564
01:19:53,380 --> 01:19:54,920
0,450 450,540 540,990
{for,the,test} and set.|
|

2565
01:19:55,380 --> 01:19:57,120
0,390 390,600 600,870 870,1260 1260,1740
I think it's two slides
我想是倒退两张幻灯片。

2566
01:19:57,120 --> 01:19:59,160
0,540 630,1200
back.| {This,one}?|
|这一个?|

2567
01:19:59,160 --> 01:20:00,380
0,720
Yeah,
是的，所以新的设计，

2568
01:20:00,580 --> 01:20:02,530
0,450 600,810 810,1140 1350,1710 1710,1950
{} so {} the new

2569
01:20:02,530 --> 01:20:03,840
0,750
design,|
|

2570
01:20:03,960 --> 01:20:05,760
0,780 1110,1290 1290,1410 1410,1680 1680,1800
it's, it is able to
它是，它能够修复那个写。

2571
01:20:05,760 --> 01:20:07,830
0,300 300,540 540,900 1260,2010 2040,2070
fix that write.| [right, I
|[对，我的意思是像[]版中的z]。

2572
01:20:08,520 --> 01:20:12,160
0,570 570,720 720,2460
mean like z]

2573
01:20:14,700 --> 01:20:16,650
0,210 210,450 450,990 990,1350 1680,1950
In the {[],version} write.| Yeah,
|是的，如果你必须这么做的话，

2574
01:20:16,650 --> 01:20:18,750
0,150 150,240 240,360 360,1530 1530,2100
if you have to exactly,|
|

2575
01:20:19,110 --> 01:20:20,550
0,780 810,1080 1080,1230 1230,1320 1320,1440
I didn't get to do
我没能这么做，

2576
01:20:20,550 --> 01:20:21,780
0,180 180,270 270,390 390,720 960,1230
that,| but that was going
|但这一点将在课程的其余部分讨论，

2577
01:20:21,780 --> 01:20:22,800
0,60 60,420 420,510 510,900 900,1020
to {the,rest,of} the lecture is

2578
01:20:22,800 --> 01:20:24,000
0,180 180,390 390,570 570,1080 1080,1200
to talk about,| how you
|如何使用版本号实现测试和设置。

2579
01:20:24,000 --> 01:20:25,290
0,120 120,450 450,690 690,1020 1020,1290
can implement {test-and-set -} using

2580
01:20:25,290 --> 01:20:26,580
0,60 60,300 300,720
the version numbers.|
|

2581
01:20:27,100 --> 01:20:29,470
0,150 150,630 1080,1290 1290,1890 1980,2370
And clearly the increment suggests
很明显，增量表明你可以，正确地说，

2582
01:20:29,470 --> 01:20:30,580
0,120 120,420 420,780 780,990 990,1110
you can, correct,| because this
|因为这基本上是相同的序列。

2583
01:20:30,580 --> 01:20:31,900
0,60 60,390 390,450 450,720 720,1320
is basically the same sequence.|
|

2584
01:20:33,940 --> 01:20:34,940
0,480
Right.|
正确的。|

2585
01:20:35,830 --> 01:20:37,030
0,450 450,660 660,1020 1020,1110 1110,1200
Oh, if this is the
哦，如果这和大师是一回事，好吧。

2586
01:20:37,030 --> 01:20:38,260
0,270 270,450 450,630 630,750 750,1230
same thing as the master,

2587
01:20:38,260 --> 01:20:40,820
0,180 180,690 750,1170 1200,1980
okay.| Yeah, that exactly.|
|是的，就是这样。|

2588
01:20:41,060 --> 01:20:42,800
0,480 630,990 990,1080 1080,1200 1200,1740
Okay, thank you so much.|
好的，非常感谢。|

2589
01:20:44,780 --> 01:20:45,830
0,150 150,270 270,360 360,750 750,1050
I have a question about
我有一个关于防止锁定的版本控制的问题

2590
01:20:45,830 --> 01:20:48,590
0,420 420,1290 1380,1950 1980,2400 2400,2760
this version {} {versioning -}

2591
01:20:48,590 --> 01:20:51,110
0,210 210,660 660,1170 1410,2070 2070,2520
to prevent lock| to implement
|为了实现无锁编程，

2592
01:20:51,110 --> 01:20:52,580
0,240 240,390 390,960 960,1170 1170,1470
{lock-free -} programming,| is this
|这是不是像更高效的无锁编程一样，

2593
01:20:52,580 --> 01:20:54,380
0,420 450,480 600,990 990,1290 1320,1800
like {} much more efficient

2594
01:20:54,380 --> 01:20:56,270
0,330 330,510 510,960 960,1530 1680,1890
{lock-free -} programming,| because you
|因为你还需要阅读，

2595
01:20:56,270 --> 01:20:58,280
0,180 180,390 390,690 720,1320 1620,2010
still need to read,| try
|反复尝试该操作

2596
01:20:58,280 --> 01:20:59,630
0,90 90,630 630,870 870,990 990,1350
the operation again and again|
|

2597
01:20:59,630 --> 01:21:03,410
0,330 330,390 390,1020 1020,1320 2010,3780
until it succeeds write.| Yeah,
直到它成功写入。|是的，再说一次，这个测试和设置有类似的属性，对吗，

2598
01:21:03,410 --> 01:21:04,550
0,180 180,480 480,750 750,990 990,1140
again, this {test-and-set -} has

2599
01:21:04,550 --> 01:21:05,750
0,60 60,390 390,810 810,1080 1080,1200
a similar property, correct,| if
|如果测试失败了

2600
01:21:05,750 --> 01:21:07,040
0,90 90,420 420,570 570,1080 1140,1290
the tests have failed| and
|你想成为你所知道的真正的增量，

2601
01:21:07,040 --> 01:21:08,060
0,120 120,330 330,390 390,960 960,1020
you wanted to become you

2602
01:21:08,060 --> 01:21:09,050
0,150 150,450 450,750 750,870 870,990
know actually increment,| you have
|你必须再做一次。

2603
01:21:09,050 --> 01:21:10,190
0,90 90,240 240,420 420,690 720,1140
to do that again.| So,
|因此，在这种无锁风格的编程中通常会出现这种情况

2604
01:21:10,680 --> 01:21:11,610
0,270 270,510 510,570 570,840 840,930
it's often the case in

2605
01:21:11,610 --> 01:21:12,960
0,150 150,360 360,510 510,810 810,1350
this {lock-free -} style programming|
|

2606
01:21:12,960 --> 01:21:14,220
0,480 480,690 690,840 840,1020 1020,1260
that you have these loops
你有这些循环，你可以重试。

2607
01:21:14,220 --> 01:21:15,660
0,210 210,330 330,600 600,810
where you {retry -}.|
|

2608
01:21:16,420 --> 01:21:16,960
0,120 120,240 240,360 360,480 480,540
And so if there's a
因此，如果有很多争论，

2609
01:21:16,960 --> 01:21:18,580
0,150 150,210 210,960 1350,1500 1500,1620
lot of contention,| you're gonna
|你会有很多次重审，

2610
01:21:18,580 --> 01:21:19,630
0,150 150,180 180,360 360,420 420,1050
get a lot of retry,|
|

2611
01:21:19,750 --> 01:21:21,070
0,300 300,540 540,660 660,1140 1140,1320
because there's no contention, there's
因为没有争用，所以没有重试

2612
01:21:21,070 --> 01:21:23,890
0,150 150,660 1140,1890 1890,2310 2310,2820
no retry| {} and typically
|通常情况下，你知道这些无锁算法实际上在如何进行后退方面非常谨慎，

2613
01:21:23,890 --> 01:21:25,000
0,60 60,180 180,390 390,690 690,1110
you know these lock-free algorithms

2614
01:21:25,000 --> 01:21:26,080
0,270 270,330 330,540 540,960 960,1080
actually are pretty careful in

2615
01:21:26,080 --> 01:21:26,920
0,150 150,300 300,450 450,540 540,840
how they do the back

2616
01:21:26,920 --> 01:21:28,510
0,330 690,870 870,990 990,1200 1200,1590
off,| so they don't really
|所以他们不会立即重试，

2617
01:21:28,510 --> 01:21:29,470
0,210 210,660 660,720 720,840 840,960
retry immediately,| you know they
|你知道他们有后备计划。

2618
01:21:29,470 --> 01:21:30,860
0,150 150,240 240,630 630,900
have some backup plan.|
|

2619
01:21:32,150 --> 01:21:33,710
0,330 330,450 450,750 750,1320 1320,1560
Right, but what benefits this
对，但这比标准锁有什么好处，

2620
01:21:33,710 --> 01:21:36,440
0,420 420,900 900,1470 1620,2190 2190,2730
skip over a standard lock,|
|

2621
01:21:36,530 --> 01:21:38,060
0,690 870,1140 1140,1350 1350,1470 1470,1530
because either way if you
因为无论哪种方式，如果你有很多争论，

2622
01:21:38,060 --> 01:21:38,960
0,90 90,150 150,330 330,390 390,900
have a lot of contention,|
|

2623
01:21:38,960 --> 01:21:40,610
0,120 120,300 300,600 660,1230 1260,1650
you're gonna be like sitting
你就会像坐在那里反复尝试一样。

2624
01:21:40,610 --> 01:21:42,020
0,270 270,480 480,990 990,1080 1080,1410
there and retrying a lot.|
|

2625
01:21:42,170 --> 01:21:43,850
0,270 270,450 450,990 990,1410 1410,1680
Yeah, so let's,| yeah so
是啊，所以让我们，|是的，所以你知道，

2626
01:21:43,850 --> 01:21:46,130
0,180 180,720 810,1230 1260,1800 2040,2280
you know,| so, {} the
|因此，增量计数器是一个基本上隐式执行锁定的示例，

2627
01:21:46,130 --> 01:21:48,230
0,660 660,1380 1380,1590 1590,1680 1680,2100
increment counter is an example

2628
01:21:48,230 --> 01:21:50,720
0,180 180,900 1140,2010 2070,2430 2430,2490
where basically {} sort of

2629
01:21:50,720 --> 01:21:52,400
0,630 630,750 750,870 870,1440 1440,1680
implicitly do the locking, {}|
|

2630
01:21:52,400 --> 01:21:53,330
0,210 210,270 270,420 420,780 780,930
because you will see if
因为您将看到如果我们在ZooKeeper中实现锁，

2631
01:21:53,330 --> 01:21:54,960
0,210 240,720 720,1350
we implement locks

2632
01:21:54,960 --> 01:21:57,390
0,450 450,840 840,1020 1020,1470 1470,2430
{} in {zookeeper -},| like
|就像ZooKeeper使用ZooKeeper API实现锁一样，

2633
01:21:57,480 --> 01:21:59,790
0,630 630,990 1380,1860 1860,2160 2160,2310
{zookeeper -} implement locks with

2634
01:21:59,790 --> 01:22:01,620
0,180 180,450 450,1200 1380,1650 1650,1830
{zookeeper -} API,| and then
|如果你用这个愚蠢的锁，

2635
01:22:01,620 --> 01:22:02,310
0,90 90,180 180,270 270,390 390,690
if you do this stupid

2636
01:22:02,310 --> 01:22:03,570
0,390 420,690 690,810 810,1080 1080,1260
lock,| you can also have
|你也可能会有这个争执的问题，

2637
01:22:03,570 --> 01:22:05,670
0,150 150,600 600,1140 1650,2010 2010,2100
this contention issue,| {} of
|当然，有一种方法可以实现更智能的锁，

2638
01:22:05,670 --> 01:22:06,420
0,210 210,390 390,450 450,660 660,750
course, there's a way of

2639
01:22:06,420 --> 01:22:08,370
0,540 540,960 960,1410 1410,1650 1650,1950
implementing smarter lock,| they talked
|他们无伤大雅地谈论着

2640
01:22:08,370 --> 01:22:10,560
0,270 270,480 480,840 840,1410 1680,2190
about like without hurting {}|
|

2641
01:22:10,560 --> 01:22:11,820
0,600 600,930 930,1080 1080,1170 1170,1260
and then you could do
然后你就可以做得更好。

2642
01:22:11,820 --> 01:22:12,660
0,420
better.|
|

2643
01:22:12,830 --> 01:22:14,360
0,510 510,810 810,1110 1110,1380 1380,1530
{} And so I was
所以我希望下一次能谈到。

2644
01:22:14,360 --> 01:22:16,040
0,270 270,450 450,660 660,1020 1020,1680
hoping to talk about {}

2645
01:22:16,130 --> 01:22:17,320
0,270 270,630
next time.|
|

2646
01:22:18,690 --> 01:22:20,400
0,450 480,690 690,900 1350,1530 1530,1710
Okay, thank you.| I think
好的谢谢。|我认为真正的问题是你知道

2647
01:22:20,400 --> 01:22:21,450
0,60 60,270 270,540 540,780 780,1050
the real point here is

2648
01:22:21,450 --> 01:22:22,620
0,90 90,660 660,840 840,990 990,1170
you {know,that}| you can use
|您可以使用这些原语来实际进行无锁编程。

2649
01:22:22,620 --> 01:22:23,790
0,150 150,600 600,720 720,990 990,1170
these primitives to actually do

2650
01:22:23,790 --> 01:22:25,280
0,270 270,420 420,930
{lock-free -} programming.|
|

2651
01:22:25,740 --> 01:22:27,180
0,210 210,390 390,660 660,1110 1110,1440
Like with the interface that
就像实验室3提供的界面一样，这是不可能的。

2652
01:22:27,180 --> 01:22:28,740
0,300 330,720 720,1260 1260,1380 1380,1560
the {lab,3} provides, its not

2653
01:22:28,740 --> 01:22:29,820
0,510
possible.|
|

2654
01:22:31,820 --> 01:22:33,680
0,270 270,630 630,840 840,1140
Makes sense, thank you.|
有道理，谢谢。|

2655
01:22:42,960 --> 01:22:44,520
0,300 300,480 480,1020
Any further questions?
还有什么问题吗？

